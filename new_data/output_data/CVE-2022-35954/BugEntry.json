{"buggy_code": ["# @actions/core Releases\n\n### 1.9.0\n- Added `toPosixPath`, `toWin32Path` and `toPlatformPath` utilities [#1102](https://github.com/actions/toolkit/pull/1102)\n\n### 1.8.2\n- Update to v2.0.1 of `@actions/http-client` [#1087](https://github.com/actions/toolkit/pull/1087)\n\n### 1.8.1\n- Update to v2.0.0 of `@actions/http-client`\n\n### 1.8.0\n- Deprecate `markdownSummary` extension export in favor of `summary`\n  - https://github.com/actions/toolkit/pull/1072\n  - https://github.com/actions/toolkit/pull/1073\n\n### 1.7.0\n- [Added `markdownSummary` extension](https://github.com/actions/toolkit/pull/1014)\n\n### 1.6.0\n- [Added OIDC Client function `getIDToken`](https://github.com/actions/toolkit/pull/919)\n- [Added `file` parameter to `AnnotationProperties`](https://github.com/actions/toolkit/pull/896) \n\n### 1.5.0\n- [Added support for notice annotations and more annotation fields](https://github.com/actions/toolkit/pull/855)\n\n### 1.4.0\n- [Added the `getMultilineInput` function](https://github.com/actions/toolkit/pull/829)\n\n### 1.3.0\n- [Added the trimWhitespace option to getInput](https://github.com/actions/toolkit/pull/802)\n- [Added the getBooleanInput function](https://github.com/actions/toolkit/pull/725)\n\n### 1.2.7\n- [Prepend newline for set-output](https://github.com/actions/toolkit/pull/772)\n\n### 1.2.6\n- [Update `exportVariable` and `addPath` to use environment files](https://github.com/actions/toolkit/pull/571)\n\n### 1.2.5\n- [Correctly bundle License File with package](https://github.com/actions/toolkit/pull/548)\n\n### 1.2.4\n- [Be more lenient in accepting non-string command inputs](https://github.com/actions/toolkit/pull/405)\n- [Add Echo commands](https://github.com/actions/toolkit/pull/411)\n\n### 1.2.3\n\n- [IsDebug logging](README.md#logging)\n\n### 1.2.2\n\n- [Fix escaping for runner commands](https://github.com/actions/toolkit/pull/302)\n\n### 1.2.1\n\n- [Remove trailing comma from commands](https://github.com/actions/toolkit/pull/263)\n- [Add \\\"types\\\" to package.json](https://github.com/actions/toolkit/pull/221)\n\n### 1.2.0\n\n- saveState and getState functions for wrapper tasks (on finally entry points that run post job)\n\n### 1.1.3 \n\n- setSecret added to register a secret with the runner to be masked from the logs\n- exportSecret which was not implemented and never worked was removed after clarification from product.\n\n### 1.1.1\n\n- Add support for action input variables with multiple spaces [#127](https://github.com/actions/toolkit/issues/127)\n- Switched ## commands to :: commands (should have no noticeable impact) [#110)(https://github.com/actions/toolkit/pull/110)\n\n### 1.1.0\n\n- Added helpers for `group` and `endgroup` [#98](https://github.com/actions/toolkit/pull/98)\n\n### 1.0.0\n\n- Initial release\n", "import * as fs from 'fs'\nimport * as os from 'os'\nimport * as path from 'path'\nimport * as core from '../src/core'\nimport {HttpClient} from '@actions/http-client'\nimport {toCommandProperties} from '../src/utils'\n\n/* eslint-disable @typescript-eslint/unbound-method */\n\nconst testEnvVars = {\n  'my var': '',\n  'special char var \\r\\n];': '',\n  'my var2': '',\n  'my secret': '',\n  'special char secret \\r\\n];': '',\n  'my secret2': '',\n  PATH: `path1${path.delimiter}path2`,\n\n  // Set inputs\n  INPUT_MY_INPUT: 'val',\n  INPUT_MISSING: '',\n  'INPUT_SPECIAL_CHARS_\\'\\t\"\\\\': '\\'\\t\"\\\\ response ',\n  INPUT_MULTIPLE_SPACES_VARIABLE: 'I have multiple spaces',\n  INPUT_BOOLEAN_INPUT: 'true',\n  INPUT_BOOLEAN_INPUT_TRUE1: 'true',\n  INPUT_BOOLEAN_INPUT_TRUE2: 'True',\n  INPUT_BOOLEAN_INPUT_TRUE3: 'TRUE',\n  INPUT_BOOLEAN_INPUT_FALSE1: 'false',\n  INPUT_BOOLEAN_INPUT_FALSE2: 'False',\n  INPUT_BOOLEAN_INPUT_FALSE3: 'FALSE',\n  INPUT_WRONG_BOOLEAN_INPUT: 'wrong',\n  INPUT_WITH_TRAILING_WHITESPACE: '  some val  ',\n\n  INPUT_MY_INPUT_LIST: 'val1\\nval2\\nval3',\n\n  // Save inputs\n  STATE_TEST_1: 'state_val',\n\n  // File Commands\n  GITHUB_PATH: '',\n  GITHUB_ENV: ''\n}\n\ndescribe('@actions/core', () => {\n  beforeAll(() => {\n    const filePath = path.join(__dirname, `test`)\n    if (!fs.existsSync(filePath)) {\n      fs.mkdirSync(filePath)\n    }\n  })\n\n  beforeEach(() => {\n    for (const key in testEnvVars) {\n      process.env[key] = testEnvVars[key as keyof typeof testEnvVars]\n    }\n    process.stdout.write = jest.fn()\n  })\n\n  it('legacy exportVariable produces the correct command and sets the env', () => {\n    core.exportVariable('my var', 'var val')\n    assertWriteCalls([`::set-env name=my var::var val${os.EOL}`])\n  })\n\n  it('legacy exportVariable escapes variable names', () => {\n    core.exportVariable('special char var \\r\\n,:', 'special val')\n    expect(process.env['special char var \\r\\n,:']).toBe('special val')\n    assertWriteCalls([\n      `::set-env name=special char var %0D%0A%2C%3A::special val${os.EOL}`\n    ])\n  })\n\n  it('legacy exportVariable escapes variable values', () => {\n    core.exportVariable('my var2', 'var val\\r\\n')\n    expect(process.env['my var2']).toBe('var val\\r\\n')\n    assertWriteCalls([`::set-env name=my var2::var val%0D%0A${os.EOL}`])\n  })\n\n  it('legacy exportVariable handles boolean inputs', () => {\n    core.exportVariable('my var', true)\n    assertWriteCalls([`::set-env name=my var::true${os.EOL}`])\n  })\n\n  it('legacy exportVariable handles number inputs', () => {\n    core.exportVariable('my var', 5)\n    assertWriteCalls([`::set-env name=my var::5${os.EOL}`])\n  })\n\n  it('exportVariable produces the correct command and sets the env', () => {\n    const command = 'ENV'\n    createFileCommandFile(command)\n    core.exportVariable('my var', 'var val')\n    verifyFileCommand(\n      command,\n      `my var<<_GitHubActionsFileCommandDelimeter_${os.EOL}var val${os.EOL}_GitHubActionsFileCommandDelimeter_${os.EOL}`\n    )\n  })\n\n  it('exportVariable handles boolean inputs', () => {\n    const command = 'ENV'\n    createFileCommandFile(command)\n    core.exportVariable('my var', true)\n    verifyFileCommand(\n      command,\n      `my var<<_GitHubActionsFileCommandDelimeter_${os.EOL}true${os.EOL}_GitHubActionsFileCommandDelimeter_${os.EOL}`\n    )\n  })\n\n  it('exportVariable handles number inputs', () => {\n    const command = 'ENV'\n    createFileCommandFile(command)\n    core.exportVariable('my var', 5)\n    verifyFileCommand(\n      command,\n      `my var<<_GitHubActionsFileCommandDelimeter_${os.EOL}5${os.EOL}_GitHubActionsFileCommandDelimeter_${os.EOL}`\n    )\n  })\n\n  it('setSecret produces the correct command', () => {\n    core.setSecret('secret val')\n    assertWriteCalls([`::add-mask::secret val${os.EOL}`])\n  })\n\n  it('prependPath produces the correct commands and sets the env', () => {\n    const command = 'PATH'\n    createFileCommandFile(command)\n    core.addPath('myPath')\n    expect(process.env['PATH']).toBe(\n      `myPath${path.delimiter}path1${path.delimiter}path2`\n    )\n    verifyFileCommand(command, `myPath${os.EOL}`)\n  })\n\n  it('legacy prependPath produces the correct commands and sets the env', () => {\n    core.addPath('myPath')\n    expect(process.env['PATH']).toBe(\n      `myPath${path.delimiter}path1${path.delimiter}path2`\n    )\n    assertWriteCalls([`::add-path::myPath${os.EOL}`])\n  })\n\n  it('getInput gets non-required input', () => {\n    expect(core.getInput('my input')).toBe('val')\n  })\n\n  it('getInput gets required input', () => {\n    expect(core.getInput('my input', {required: true})).toBe('val')\n  })\n\n  it('getInput throws on missing required input', () => {\n    expect(() => core.getInput('missing', {required: true})).toThrow(\n      'Input required and not supplied: missing'\n    )\n  })\n\n  it('getInput does not throw on missing non-required input', () => {\n    expect(core.getInput('missing', {required: false})).toBe('')\n  })\n\n  it('getInput is case insensitive', () => {\n    expect(core.getInput('My InPuT')).toBe('val')\n  })\n\n  it('getInput handles special characters', () => {\n    expect(core.getInput('special chars_\\'\\t\"\\\\')).toBe('\\'\\t\"\\\\ response')\n  })\n\n  it('getInput handles multiple spaces', () => {\n    expect(core.getInput('multiple spaces variable')).toBe(\n      'I have multiple spaces'\n    )\n  })\n\n  it('getMultilineInput works', () => {\n    expect(core.getMultilineInput('my input list')).toEqual([\n      'val1',\n      'val2',\n      'val3'\n    ])\n  })\n\n  it('getInput trims whitespace by default', () => {\n    expect(core.getInput('with trailing whitespace')).toBe('some val')\n  })\n\n  it('getInput trims whitespace when option is explicitly true', () => {\n    expect(\n      core.getInput('with trailing whitespace', {trimWhitespace: true})\n    ).toBe('some val')\n  })\n\n  it('getInput does not trim whitespace when option is false', () => {\n    expect(\n      core.getInput('with trailing whitespace', {trimWhitespace: false})\n    ).toBe('  some val  ')\n  })\n\n  it('getInput gets non-required boolean input', () => {\n    expect(core.getBooleanInput('boolean input')).toBe(true)\n  })\n\n  it('getInput gets required input', () => {\n    expect(core.getBooleanInput('boolean input', {required: true})).toBe(true)\n  })\n\n  it('getBooleanInput handles boolean input', () => {\n    expect(core.getBooleanInput('boolean input true1')).toBe(true)\n    expect(core.getBooleanInput('boolean input true2')).toBe(true)\n    expect(core.getBooleanInput('boolean input true3')).toBe(true)\n    expect(core.getBooleanInput('boolean input false1')).toBe(false)\n    expect(core.getBooleanInput('boolean input false2')).toBe(false)\n    expect(core.getBooleanInput('boolean input false3')).toBe(false)\n  })\n\n  it('getBooleanInput handles wrong boolean input', () => {\n    expect(() => core.getBooleanInput('wrong boolean input')).toThrow(\n      'Input does not meet YAML 1.2 \"Core Schema\" specification: wrong boolean input\\n' +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``\n    )\n  })\n\n  it('setOutput produces the correct command', () => {\n    core.setOutput('some output', 'some value')\n    assertWriteCalls([\n      os.EOL,\n      `::set-output name=some output::some value${os.EOL}`\n    ])\n  })\n\n  it('setOutput handles bools', () => {\n    core.setOutput('some output', false)\n    assertWriteCalls([os.EOL, `::set-output name=some output::false${os.EOL}`])\n  })\n\n  it('setOutput handles numbers', () => {\n    core.setOutput('some output', 1.01)\n    assertWriteCalls([os.EOL, `::set-output name=some output::1.01${os.EOL}`])\n  })\n\n  it('setFailed sets the correct exit code and failure message', () => {\n    core.setFailed('Failure message')\n    expect(process.exitCode).toBe(core.ExitCode.Failure)\n    assertWriteCalls([`::error::Failure message${os.EOL}`])\n  })\n\n  it('setFailed escapes the failure message', () => {\n    core.setFailed('Failure \\r\\n\\nmessage\\r')\n    expect(process.exitCode).toBe(core.ExitCode.Failure)\n    assertWriteCalls([`::error::Failure %0D%0A%0Amessage%0D${os.EOL}`])\n  })\n\n  it('setFailed handles Error', () => {\n    const message = 'this is my error message'\n    core.setFailed(new Error(message))\n    expect(process.exitCode).toBe(core.ExitCode.Failure)\n    assertWriteCalls([`::error::Error: ${message}${os.EOL}`])\n  })\n\n  it('error sets the correct error message', () => {\n    core.error('Error message')\n    assertWriteCalls([`::error::Error message${os.EOL}`])\n  })\n\n  it('error escapes the error message', () => {\n    core.error('Error message\\r\\n\\n')\n    assertWriteCalls([`::error::Error message%0D%0A%0A${os.EOL}`])\n  })\n\n  it('error handles an error object', () => {\n    const message = 'this is my error message'\n    core.error(new Error(message))\n    assertWriteCalls([`::error::Error: ${message}${os.EOL}`])\n  })\n\n  it('error handles parameters correctly', () => {\n    const message = 'this is my error message'\n    core.error(new Error(message), {\n      title: 'A title',\n      file: 'root/test.txt',\n      startColumn: 1,\n      endColumn: 2,\n      startLine: 5,\n      endLine: 5\n    })\n    assertWriteCalls([\n      `::error title=A title,file=root/test.txt,line=5,endLine=5,col=1,endColumn=2::Error: ${message}${os.EOL}`\n    ])\n  })\n\n  it('warning sets the correct message', () => {\n    core.warning('Warning')\n    assertWriteCalls([`::warning::Warning${os.EOL}`])\n  })\n\n  it('warning escapes the message', () => {\n    core.warning('\\r\\nwarning\\n')\n    assertWriteCalls([`::warning::%0D%0Awarning%0A${os.EOL}`])\n  })\n\n  it('warning handles an error object', () => {\n    const message = 'this is my error message'\n    core.warning(new Error(message))\n    assertWriteCalls([`::warning::Error: ${message}${os.EOL}`])\n  })\n\n  it('warning handles parameters correctly', () => {\n    const message = 'this is my error message'\n    core.warning(new Error(message), {\n      title: 'A title',\n      file: 'root/test.txt',\n      startColumn: 1,\n      endColumn: 2,\n      startLine: 5,\n      endLine: 5\n    })\n    assertWriteCalls([\n      `::warning title=A title,file=root/test.txt,line=5,endLine=5,col=1,endColumn=2::Error: ${message}${os.EOL}`\n    ])\n  })\n\n  it('notice sets the correct message', () => {\n    core.notice('Notice')\n    assertWriteCalls([`::notice::Notice${os.EOL}`])\n  })\n\n  it('notice escapes the message', () => {\n    core.notice('\\r\\nnotice\\n')\n    assertWriteCalls([`::notice::%0D%0Anotice%0A${os.EOL}`])\n  })\n\n  it('notice handles an error object', () => {\n    const message = 'this is my error message'\n    core.notice(new Error(message))\n    assertWriteCalls([`::notice::Error: ${message}${os.EOL}`])\n  })\n\n  it('notice handles parameters correctly', () => {\n    const message = 'this is my error message'\n    core.notice(new Error(message), {\n      title: 'A title',\n      file: 'root/test.txt',\n      startColumn: 1,\n      endColumn: 2,\n      startLine: 5,\n      endLine: 5\n    })\n    assertWriteCalls([\n      `::notice title=A title,file=root/test.txt,line=5,endLine=5,col=1,endColumn=2::Error: ${message}${os.EOL}`\n    ])\n  })\n\n  it('annotations map field names correctly', () => {\n    const commandProperties = toCommandProperties({\n      title: 'A title',\n      file: 'root/test.txt',\n      startColumn: 1,\n      endColumn: 2,\n      startLine: 5,\n      endLine: 5\n    })\n    expect(commandProperties.title).toBe('A title')\n    expect(commandProperties.file).toBe('root/test.txt')\n    expect(commandProperties.col).toBe(1)\n    expect(commandProperties.endColumn).toBe(2)\n    expect(commandProperties.line).toBe(5)\n    expect(commandProperties.endLine).toBe(5)\n\n    expect(commandProperties.startColumn).toBeUndefined()\n    expect(commandProperties.startLine).toBeUndefined()\n  })\n\n  it('startGroup starts a new group', () => {\n    core.startGroup('my-group')\n    assertWriteCalls([`::group::my-group${os.EOL}`])\n  })\n\n  it('endGroup ends new group', () => {\n    core.endGroup()\n    assertWriteCalls([`::endgroup::${os.EOL}`])\n  })\n\n  it('group wraps an async call in a group', async () => {\n    const result = await core.group('mygroup', async () => {\n      process.stdout.write('in my group\\n')\n      return true\n    })\n    expect(result).toBe(true)\n    assertWriteCalls([\n      `::group::mygroup${os.EOL}`,\n      'in my group\\n',\n      `::endgroup::${os.EOL}`\n    ])\n  })\n\n  it('debug sets the correct message', () => {\n    core.debug('Debug')\n    assertWriteCalls([`::debug::Debug${os.EOL}`])\n  })\n\n  it('debug escapes the message', () => {\n    core.debug('\\r\\ndebug\\n')\n    assertWriteCalls([`::debug::%0D%0Adebug%0A${os.EOL}`])\n  })\n\n  it('saveState produces the correct command', () => {\n    core.saveState('state_1', 'some value')\n    assertWriteCalls([`::save-state name=state_1::some value${os.EOL}`])\n  })\n\n  it('saveState handles numbers', () => {\n    core.saveState('state_1', 1)\n    assertWriteCalls([`::save-state name=state_1::1${os.EOL}`])\n  })\n\n  it('saveState handles bools', () => {\n    core.saveState('state_1', true)\n    assertWriteCalls([`::save-state name=state_1::true${os.EOL}`])\n  })\n\n  it('getState gets wrapper action state', () => {\n    expect(core.getState('TEST_1')).toBe('state_val')\n  })\n\n  it('isDebug check debug state', () => {\n    const current = process.env['RUNNER_DEBUG']\n    try {\n      delete process.env.RUNNER_DEBUG\n      expect(core.isDebug()).toBe(false)\n\n      process.env['RUNNER_DEBUG'] = '1'\n      expect(core.isDebug()).toBe(true)\n    } finally {\n      process.env['RUNNER_DEBUG'] = current\n    }\n  })\n\n  it('setCommandEcho can enable echoing', () => {\n    core.setCommandEcho(true)\n    assertWriteCalls([`::echo::on${os.EOL}`])\n  })\n\n  it('setCommandEcho can disable echoing', () => {\n    core.setCommandEcho(false)\n    assertWriteCalls([`::echo::off${os.EOL}`])\n  })\n})\n\n// Assert that process.stdout.write calls called only with the given arguments.\nfunction assertWriteCalls(calls: string[]): void {\n  expect(process.stdout.write).toHaveBeenCalledTimes(calls.length)\n\n  for (let i = 0; i < calls.length; i++) {\n    expect(process.stdout.write).toHaveBeenNthCalledWith(i + 1, calls[i])\n  }\n}\n\nfunction createFileCommandFile(command: string): void {\n  const filePath = path.join(__dirname, `test/${command}`)\n  process.env[`GITHUB_${command}`] = filePath\n  fs.appendFileSync(filePath, '', {\n    encoding: 'utf8'\n  })\n}\n\nfunction verifyFileCommand(command: string, expectedContents: string): void {\n  const filePath = path.join(__dirname, `test/${command}`)\n  const contents = fs.readFileSync(filePath, 'utf8')\n  try {\n    expect(contents).toEqual(expectedContents)\n  } finally {\n    fs.unlinkSync(filePath)\n  }\n}\n\nfunction getTokenEndPoint(): string {\n  return 'https://vstoken.actions.githubusercontent.com/.well-known/openid-configuration'\n}\n\ndescribe('oidc-client-tests', () => {\n  it('Get Http Client', async () => {\n    const http = new HttpClient('actions/oidc-client')\n    expect(http).toBeDefined()\n  })\n\n  it('HTTP get request to get token endpoint', async () => {\n    const http = new HttpClient('actions/oidc-client')\n    const res = await http.get(getTokenEndPoint())\n    expect(res.message.statusCode).toBe(200)\n  })\n})\n", "{\n  \"name\": \"@actions/core\",\n  \"version\": \"1.9.0\",\n  \"lockfileVersion\": 2,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"@actions/core\",\n      \"version\": \"1.8.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@actions/http-client\": \"^2.0.1\"\n      },\n      \"devDependencies\": {\n        \"@types/node\": \"^12.0.2\"\n      }\n    },\n    \"node_modules/@actions/http-client\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/@actions/http-client/-/http-client-2.0.1.tgz\",\n      \"integrity\": \"sha512-PIXiMVtz6VvyaRsGY268qvj57hXQEpsYogYOu2nrQhlf+XCGmZstmuZBbAybUl1nQGnvS1k1eEsQ69ZoD7xlSw==\",\n      \"dependencies\": {\n        \"tunnel\": \"^0.0.6\"\n      }\n    },\n    \"node_modules/@types/node\": {\n      \"version\": \"12.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-12.0.2.tgz\",\n      \"integrity\": \"sha512-5tabW/i+9mhrfEOUcLDu2xBPsHJ+X5Orqy9FKpale3SjDA17j5AEpYq5vfy3oAeAHGcvANRCO3NV3d2D6q3NiA==\",\n      \"dev\": true\n    },\n    \"node_modules/tunnel\": {\n      \"version\": \"0.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/tunnel/-/tunnel-0.0.6.tgz\",\n      \"integrity\": \"sha512-1h/Lnq9yajKY2PEbBadPXj3VxsDDu844OnaAo52UVmIzIvwwtBPIuNvkjuzBlTWpfJyUbG3ez0KSBibQkj4ojg==\",\n      \"engines\": {\n        \"node\": \">=0.6.11 <=0.7.0 || >=0.7.3\"\n      }\n    }\n  },\n  \"dependencies\": {\n    \"@actions/http-client\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/@actions/http-client/-/http-client-2.0.1.tgz\",\n      \"integrity\": \"sha512-PIXiMVtz6VvyaRsGY268qvj57hXQEpsYogYOu2nrQhlf+XCGmZstmuZBbAybUl1nQGnvS1k1eEsQ69ZoD7xlSw==\",\n      \"requires\": {\n        \"tunnel\": \"^0.0.6\"\n      }\n    },\n    \"@types/node\": {\n      \"version\": \"12.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-12.0.2.tgz\",\n      \"integrity\": \"sha512-5tabW/i+9mhrfEOUcLDu2xBPsHJ+X5Orqy9FKpale3SjDA17j5AEpYq5vfy3oAeAHGcvANRCO3NV3d2D6q3NiA==\",\n      \"dev\": true\n    },\n    \"tunnel\": {\n      \"version\": \"0.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/tunnel/-/tunnel-0.0.6.tgz\",\n      \"integrity\": \"sha512-1h/Lnq9yajKY2PEbBadPXj3VxsDDu844OnaAo52UVmIzIvwwtBPIuNvkjuzBlTWpfJyUbG3ez0KSBibQkj4ojg==\"\n    }\n  }\n}\n", "{\n  \"name\": \"@actions/core\",\n  \"version\": \"1.9.0\",\n  \"description\": \"Actions core lib\",\n  \"keywords\": [\n    \"github\",\n    \"actions\",\n    \"core\"\n  ],\n  \"homepage\": \"https://github.com/actions/toolkit/tree/main/packages/core\",\n  \"license\": \"MIT\",\n  \"main\": \"lib/core.js\",\n  \"types\": \"lib/core.d.ts\",\n  \"directories\": {\n    \"lib\": \"lib\",\n    \"test\": \"__tests__\"\n  },\n  \"files\": [\n    \"lib\",\n    \"!.DS_Store\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/actions/toolkit.git\",\n    \"directory\": \"packages/core\"\n  },\n  \"scripts\": {\n    \"audit-moderate\": \"npm install && npm audit --json --audit-level=moderate > audit.json\",\n    \"test\": \"echo \\\"Error: run tests from root\\\" && exit 1\",\n    \"tsc\": \"tsc\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/actions/toolkit/issues\"\n  },\n  \"dependencies\": {\n    \"@actions/http-client\": \"^2.0.1\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^12.0.2\"\n  }\n}\n", "import {issue, issueCommand} from './command'\nimport {issueCommand as issueFileCommand} from './file-command'\nimport {toCommandProperties, toCommandValue} from './utils'\n\nimport * as os from 'os'\nimport * as path from 'path'\n\nimport {OidcClient} from './oidc-utils'\n\n/**\n * Interface for getInput options\n */\nexport interface InputOptions {\n  /** Optional. Whether the input is required. If required and not present, will throw. Defaults to false */\n  required?: boolean\n\n  /** Optional. Whether leading/trailing whitespace will be trimmed for the input. Defaults to true */\n  trimWhitespace?: boolean\n}\n\n/**\n * The code to exit an action\n */\nexport enum ExitCode {\n  /**\n   * A code indicating that the action was successful\n   */\n  Success = 0,\n\n  /**\n   * A code indicating that the action was a failure\n   */\n  Failure = 1\n}\n\n/**\n * Optional properties that can be sent with annotatation commands (notice, error, and warning)\n * See: https://docs.github.com/en/rest/reference/checks#create-a-check-run for more information about annotations.\n */\nexport interface AnnotationProperties {\n  /**\n   * A title for the annotation.\n   */\n  title?: string\n\n  /**\n   * The path of the file for which the annotation should be created.\n   */\n  file?: string\n\n  /**\n   * The start line for the annotation.\n   */\n  startLine?: number\n\n  /**\n   * The end line for the annotation. Defaults to `startLine` when `startLine` is provided.\n   */\n  endLine?: number\n\n  /**\n   * The start column for the annotation. Cannot be sent when `startLine` and `endLine` are different values.\n   */\n  startColumn?: number\n\n  /**\n   * The start column for the annotation. Cannot be sent when `startLine` and `endLine` are different values.\n   * Defaults to `startColumn` when `startColumn` is provided.\n   */\n  endColumn?: number\n}\n\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function exportVariable(name: string, val: any): void {\n  const convertedVal = toCommandValue(val)\n  process.env[name] = convertedVal\n\n  const filePath = process.env['GITHUB_ENV'] || ''\n  if (filePath) {\n    const delimiter = '_GitHubActionsFileCommandDelimeter_'\n    const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`\n    issueFileCommand('ENV', commandValue)\n  } else {\n    issueCommand('set-env', {name}, convertedVal)\n  }\n}\n\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nexport function setSecret(secret: string): void {\n  issueCommand('add-mask', {}, secret)\n}\n\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nexport function addPath(inputPath: string): void {\n  const filePath = process.env['GITHUB_PATH'] || ''\n  if (filePath) {\n    issueFileCommand('PATH', inputPath)\n  } else {\n    issueCommand('add-path', {}, inputPath)\n  }\n  process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`\n}\n\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nexport function getInput(name: string, options?: InputOptions): string {\n  const val: string =\n    process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || ''\n  if (options && options.required && !val) {\n    throw new Error(`Input required and not supplied: ${name}`)\n  }\n\n  if (options && options.trimWhitespace === false) {\n    return val\n  }\n\n  return val.trim()\n}\n\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nexport function getMultilineInput(\n  name: string,\n  options?: InputOptions\n): string[] {\n  const inputs: string[] = getInput(name, options)\n    .split('\\n')\n    .filter(x => x !== '')\n\n  return inputs\n}\n\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nexport function getBooleanInput(name: string, options?: InputOptions): boolean {\n  const trueValue = ['true', 'True', 'TRUE']\n  const falseValue = ['false', 'False', 'FALSE']\n  const val = getInput(name, options)\n  if (trueValue.includes(val)) return true\n  if (falseValue.includes(val)) return false\n  throw new TypeError(\n    `Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n      `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``\n  )\n}\n\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function setOutput(name: string, value: any): void {\n  process.stdout.write(os.EOL)\n  issueCommand('set-output', {name}, value)\n}\n\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nexport function setCommandEcho(enabled: boolean): void {\n  issue('echo', enabled ? 'on' : 'off')\n}\n\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nexport function setFailed(message: string | Error): void {\n  process.exitCode = ExitCode.Failure\n\n  error(message)\n}\n\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n\n/**\n * Gets whether Actions Step Debug is on or not\n */\nexport function isDebug(): boolean {\n  return process.env['RUNNER_DEBUG'] === '1'\n}\n\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nexport function debug(message: string): void {\n  issueCommand('debug', {}, message)\n}\n\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nexport function error(\n  message: string | Error,\n  properties: AnnotationProperties = {}\n): void {\n  issueCommand(\n    'error',\n    toCommandProperties(properties),\n    message instanceof Error ? message.toString() : message\n  )\n}\n\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nexport function warning(\n  message: string | Error,\n  properties: AnnotationProperties = {}\n): void {\n  issueCommand(\n    'warning',\n    toCommandProperties(properties),\n    message instanceof Error ? message.toString() : message\n  )\n}\n\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nexport function notice(\n  message: string | Error,\n  properties: AnnotationProperties = {}\n): void {\n  issueCommand(\n    'notice',\n    toCommandProperties(properties),\n    message instanceof Error ? message.toString() : message\n  )\n}\n\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nexport function info(message: string): void {\n  process.stdout.write(message + os.EOL)\n}\n\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nexport function startGroup(name: string): void {\n  issue('group', name)\n}\n\n/**\n * End an output group.\n */\nexport function endGroup(): void {\n  issue('endgroup')\n}\n\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nexport async function group<T>(name: string, fn: () => Promise<T>): Promise<T> {\n  startGroup(name)\n\n  let result: T\n\n  try {\n    result = await fn()\n  } finally {\n    endGroup()\n  }\n\n  return result\n}\n\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function saveState(name: string, value: any): void {\n  issueCommand('save-state', {name}, value)\n}\n\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nexport function getState(name: string): string {\n  return process.env[`STATE_${name}`] || ''\n}\n\nexport async function getIDToken(aud?: string): Promise<string> {\n  return await OidcClient.getIDToken(aud)\n}\n\n/**\n * Summary exports\n */\nexport {summary} from './summary'\n\n/**\n * @deprecated use core.summary\n */\nexport {markdownSummary} from './summary'\n\n/**\n * Path exports\n */\nexport {toPosixPath, toWin32Path, toPlatformPath} from './path-utils'\n"], "fixing_code": ["# @actions/core Releases\n\n### 1.9.1\n- Randomize delimiter when calling `core.exportVariable`\n\n### 1.9.0\n- Added `toPosixPath`, `toWin32Path` and `toPlatformPath` utilities [#1102](https://github.com/actions/toolkit/pull/1102)\n\n### 1.8.2\n- Update to v2.0.1 of `@actions/http-client` [#1087](https://github.com/actions/toolkit/pull/1087)\n\n### 1.8.1\n- Update to v2.0.0 of `@actions/http-client`\n\n### 1.8.0\n- Deprecate `markdownSummary` extension export in favor of `summary`\n  - https://github.com/actions/toolkit/pull/1072\n  - https://github.com/actions/toolkit/pull/1073\n\n### 1.7.0\n- [Added `markdownSummary` extension](https://github.com/actions/toolkit/pull/1014)\n\n### 1.6.0\n- [Added OIDC Client function `getIDToken`](https://github.com/actions/toolkit/pull/919)\n- [Added `file` parameter to `AnnotationProperties`](https://github.com/actions/toolkit/pull/896) \n\n### 1.5.0\n- [Added support for notice annotations and more annotation fields](https://github.com/actions/toolkit/pull/855)\n\n### 1.4.0\n- [Added the `getMultilineInput` function](https://github.com/actions/toolkit/pull/829)\n\n### 1.3.0\n- [Added the trimWhitespace option to getInput](https://github.com/actions/toolkit/pull/802)\n- [Added the getBooleanInput function](https://github.com/actions/toolkit/pull/725)\n\n### 1.2.7\n- [Prepend newline for set-output](https://github.com/actions/toolkit/pull/772)\n\n### 1.2.6\n- [Update `exportVariable` and `addPath` to use environment files](https://github.com/actions/toolkit/pull/571)\n\n### 1.2.5\n- [Correctly bundle License File with package](https://github.com/actions/toolkit/pull/548)\n\n### 1.2.4\n- [Be more lenient in accepting non-string command inputs](https://github.com/actions/toolkit/pull/405)\n- [Add Echo commands](https://github.com/actions/toolkit/pull/411)\n\n### 1.2.3\n\n- [IsDebug logging](README.md#logging)\n\n### 1.2.2\n\n- [Fix escaping for runner commands](https://github.com/actions/toolkit/pull/302)\n\n### 1.2.1\n\n- [Remove trailing comma from commands](https://github.com/actions/toolkit/pull/263)\n- [Add \\\"types\\\" to package.json](https://github.com/actions/toolkit/pull/221)\n\n### 1.2.0\n\n- saveState and getState functions for wrapper tasks (on finally entry points that run post job)\n\n### 1.1.3 \n\n- setSecret added to register a secret with the runner to be masked from the logs\n- exportSecret which was not implemented and never worked was removed after clarification from product.\n\n### 1.1.1\n\n- Add support for action input variables with multiple spaces [#127](https://github.com/actions/toolkit/issues/127)\n- Switched ## commands to :: commands (should have no noticeable impact) [#110)(https://github.com/actions/toolkit/pull/110)\n\n### 1.1.0\n\n- Added helpers for `group` and `endgroup` [#98](https://github.com/actions/toolkit/pull/98)\n\n### 1.0.0\n\n- Initial release\n", "import * as fs from 'fs'\nimport * as os from 'os'\nimport * as path from 'path'\nimport * as core from '../src/core'\nimport {HttpClient} from '@actions/http-client'\nimport {toCommandProperties} from '../src/utils'\nimport * as uuid from 'uuid'\n\njest.mock('uuid')\n\n/* eslint-disable @typescript-eslint/unbound-method */\n\nconst testEnvVars = {\n  'my var': '',\n  'special char var \\r\\n];': '',\n  'my var2': '',\n  'my secret': '',\n  'special char secret \\r\\n];': '',\n  'my secret2': '',\n  PATH: `path1${path.delimiter}path2`,\n\n  // Set inputs\n  INPUT_MY_INPUT: 'val',\n  INPUT_MISSING: '',\n  'INPUT_SPECIAL_CHARS_\\'\\t\"\\\\': '\\'\\t\"\\\\ response ',\n  INPUT_MULTIPLE_SPACES_VARIABLE: 'I have multiple spaces',\n  INPUT_BOOLEAN_INPUT: 'true',\n  INPUT_BOOLEAN_INPUT_TRUE1: 'true',\n  INPUT_BOOLEAN_INPUT_TRUE2: 'True',\n  INPUT_BOOLEAN_INPUT_TRUE3: 'TRUE',\n  INPUT_BOOLEAN_INPUT_FALSE1: 'false',\n  INPUT_BOOLEAN_INPUT_FALSE2: 'False',\n  INPUT_BOOLEAN_INPUT_FALSE3: 'FALSE',\n  INPUT_WRONG_BOOLEAN_INPUT: 'wrong',\n  INPUT_WITH_TRAILING_WHITESPACE: '  some val  ',\n\n  INPUT_MY_INPUT_LIST: 'val1\\nval2\\nval3',\n\n  // Save inputs\n  STATE_TEST_1: 'state_val',\n\n  // File Commands\n  GITHUB_PATH: '',\n  GITHUB_ENV: ''\n}\n\nconst UUID = '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'\nconst DELIMITER = `ghadelimiter_${UUID}`\n\ndescribe('@actions/core', () => {\n  beforeAll(() => {\n    const filePath = path.join(__dirname, `test`)\n    if (!fs.existsSync(filePath)) {\n      fs.mkdirSync(filePath)\n    }\n  })\n\n  beforeEach(() => {\n    for (const key in testEnvVars) {\n      process.env[key] = testEnvVars[key as keyof typeof testEnvVars]\n    }\n    process.stdout.write = jest.fn()\n\n    jest.spyOn(uuid, 'v4').mockImplementation(() => {\n      return UUID\n    })\n  })\n\n  afterEach(() => {\n    jest.restoreAllMocks()\n  })\n\n  it('legacy exportVariable produces the correct command and sets the env', () => {\n    core.exportVariable('my var', 'var val')\n    assertWriteCalls([`::set-env name=my var::var val${os.EOL}`])\n  })\n\n  it('legacy exportVariable escapes variable names', () => {\n    core.exportVariable('special char var \\r\\n,:', 'special val')\n    expect(process.env['special char var \\r\\n,:']).toBe('special val')\n    assertWriteCalls([\n      `::set-env name=special char var %0D%0A%2C%3A::special val${os.EOL}`\n    ])\n  })\n\n  it('legacy exportVariable escapes variable values', () => {\n    core.exportVariable('my var2', 'var val\\r\\n')\n    expect(process.env['my var2']).toBe('var val\\r\\n')\n    assertWriteCalls([`::set-env name=my var2::var val%0D%0A${os.EOL}`])\n  })\n\n  it('legacy exportVariable handles boolean inputs', () => {\n    core.exportVariable('my var', true)\n    assertWriteCalls([`::set-env name=my var::true${os.EOL}`])\n  })\n\n  it('legacy exportVariable handles number inputs', () => {\n    core.exportVariable('my var', 5)\n    assertWriteCalls([`::set-env name=my var::5${os.EOL}`])\n  })\n\n  it('exportVariable produces the correct command and sets the env', () => {\n    const command = 'ENV'\n    createFileCommandFile(command)\n    core.exportVariable('my var', 'var val')\n    verifyFileCommand(\n      command,\n      `my var<<${DELIMITER}${os.EOL}var val${os.EOL}${DELIMITER}${os.EOL}`\n    )\n  })\n\n  it('exportVariable handles boolean inputs', () => {\n    const command = 'ENV'\n    createFileCommandFile(command)\n    core.exportVariable('my var', true)\n    verifyFileCommand(\n      command,\n      `my var<<${DELIMITER}${os.EOL}true${os.EOL}${DELIMITER}${os.EOL}`\n    )\n  })\n\n  it('exportVariable handles number inputs', () => {\n    const command = 'ENV'\n    createFileCommandFile(command)\n    core.exportVariable('my var', 5)\n    verifyFileCommand(\n      command,\n      `my var<<${DELIMITER}${os.EOL}5${os.EOL}${DELIMITER}${os.EOL}`\n    )\n  })\n\n  it('exportVariable does not allow delimiter as value', () => {\n    const command = 'ENV'\n    createFileCommandFile(command)\n    \n    expect(() => {\n      core.exportVariable('my var', `good stuff ${DELIMITER} bad stuff`)\n    }).toThrow(`Unexpected input: value should not contain the delimiter \"${DELIMITER}\"`)\n\n    const filePath = path.join(__dirname, `test/${command}`)\n    fs.unlinkSync(filePath)\n  })\n\n  it('exportVariable does not allow delimiter as name', () => {\n    const command = 'ENV'\n    createFileCommandFile(command)\n    \n    expect(() => {\n      core.exportVariable(`good stuff ${DELIMITER} bad stuff`, 'test')\n    }).toThrow(`Unexpected input: name should not contain the delimiter \"${DELIMITER}\"`)\n    \n    const filePath = path.join(__dirname, `test/${command}`)\n    fs.unlinkSync(filePath)\n  })\n\n  it('setSecret produces the correct command', () => {\n    core.setSecret('secret val')\n    assertWriteCalls([`::add-mask::secret val${os.EOL}`])\n  })\n\n  it('prependPath produces the correct commands and sets the env', () => {\n    const command = 'PATH'\n    createFileCommandFile(command)\n    core.addPath('myPath')\n    expect(process.env['PATH']).toBe(\n      `myPath${path.delimiter}path1${path.delimiter}path2`\n    )\n    verifyFileCommand(command, `myPath${os.EOL}`)\n  })\n\n  it('legacy prependPath produces the correct commands and sets the env', () => {\n    core.addPath('myPath')\n    expect(process.env['PATH']).toBe(\n      `myPath${path.delimiter}path1${path.delimiter}path2`\n    )\n    assertWriteCalls([`::add-path::myPath${os.EOL}`])\n  })\n\n  it('getInput gets non-required input', () => {\n    expect(core.getInput('my input')).toBe('val')\n  })\n\n  it('getInput gets required input', () => {\n    expect(core.getInput('my input', {required: true})).toBe('val')\n  })\n\n  it('getInput throws on missing required input', () => {\n    expect(() => core.getInput('missing', {required: true})).toThrow(\n      'Input required and not supplied: missing'\n    )\n  })\n\n  it('getInput does not throw on missing non-required input', () => {\n    expect(core.getInput('missing', {required: false})).toBe('')\n  })\n\n  it('getInput is case insensitive', () => {\n    expect(core.getInput('My InPuT')).toBe('val')\n  })\n\n  it('getInput handles special characters', () => {\n    expect(core.getInput('special chars_\\'\\t\"\\\\')).toBe('\\'\\t\"\\\\ response')\n  })\n\n  it('getInput handles multiple spaces', () => {\n    expect(core.getInput('multiple spaces variable')).toBe(\n      'I have multiple spaces'\n    )\n  })\n\n  it('getMultilineInput works', () => {\n    expect(core.getMultilineInput('my input list')).toEqual([\n      'val1',\n      'val2',\n      'val3'\n    ])\n  })\n\n  it('getInput trims whitespace by default', () => {\n    expect(core.getInput('with trailing whitespace')).toBe('some val')\n  })\n\n  it('getInput trims whitespace when option is explicitly true', () => {\n    expect(\n      core.getInput('with trailing whitespace', {trimWhitespace: true})\n    ).toBe('some val')\n  })\n\n  it('getInput does not trim whitespace when option is false', () => {\n    expect(\n      core.getInput('with trailing whitespace', {trimWhitespace: false})\n    ).toBe('  some val  ')\n  })\n\n  it('getInput gets non-required boolean input', () => {\n    expect(core.getBooleanInput('boolean input')).toBe(true)\n  })\n\n  it('getInput gets required input', () => {\n    expect(core.getBooleanInput('boolean input', {required: true})).toBe(true)\n  })\n\n  it('getBooleanInput handles boolean input', () => {\n    expect(core.getBooleanInput('boolean input true1')).toBe(true)\n    expect(core.getBooleanInput('boolean input true2')).toBe(true)\n    expect(core.getBooleanInput('boolean input true3')).toBe(true)\n    expect(core.getBooleanInput('boolean input false1')).toBe(false)\n    expect(core.getBooleanInput('boolean input false2')).toBe(false)\n    expect(core.getBooleanInput('boolean input false3')).toBe(false)\n  })\n\n  it('getBooleanInput handles wrong boolean input', () => {\n    expect(() => core.getBooleanInput('wrong boolean input')).toThrow(\n      'Input does not meet YAML 1.2 \"Core Schema\" specification: wrong boolean input\\n' +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``\n    )\n  })\n\n  it('setOutput produces the correct command', () => {\n    core.setOutput('some output', 'some value')\n    assertWriteCalls([\n      os.EOL,\n      `::set-output name=some output::some value${os.EOL}`\n    ])\n  })\n\n  it('setOutput handles bools', () => {\n    core.setOutput('some output', false)\n    assertWriteCalls([os.EOL, `::set-output name=some output::false${os.EOL}`])\n  })\n\n  it('setOutput handles numbers', () => {\n    core.setOutput('some output', 1.01)\n    assertWriteCalls([os.EOL, `::set-output name=some output::1.01${os.EOL}`])\n  })\n\n  it('setFailed sets the correct exit code and failure message', () => {\n    core.setFailed('Failure message')\n    expect(process.exitCode).toBe(core.ExitCode.Failure)\n    assertWriteCalls([`::error::Failure message${os.EOL}`])\n  })\n\n  it('setFailed escapes the failure message', () => {\n    core.setFailed('Failure \\r\\n\\nmessage\\r')\n    expect(process.exitCode).toBe(core.ExitCode.Failure)\n    assertWriteCalls([`::error::Failure %0D%0A%0Amessage%0D${os.EOL}`])\n  })\n\n  it('setFailed handles Error', () => {\n    const message = 'this is my error message'\n    core.setFailed(new Error(message))\n    expect(process.exitCode).toBe(core.ExitCode.Failure)\n    assertWriteCalls([`::error::Error: ${message}${os.EOL}`])\n  })\n\n  it('error sets the correct error message', () => {\n    core.error('Error message')\n    assertWriteCalls([`::error::Error message${os.EOL}`])\n  })\n\n  it('error escapes the error message', () => {\n    core.error('Error message\\r\\n\\n')\n    assertWriteCalls([`::error::Error message%0D%0A%0A${os.EOL}`])\n  })\n\n  it('error handles an error object', () => {\n    const message = 'this is my error message'\n    core.error(new Error(message))\n    assertWriteCalls([`::error::Error: ${message}${os.EOL}`])\n  })\n\n  it('error handles parameters correctly', () => {\n    const message = 'this is my error message'\n    core.error(new Error(message), {\n      title: 'A title',\n      file: 'root/test.txt',\n      startColumn: 1,\n      endColumn: 2,\n      startLine: 5,\n      endLine: 5\n    })\n    assertWriteCalls([\n      `::error title=A title,file=root/test.txt,line=5,endLine=5,col=1,endColumn=2::Error: ${message}${os.EOL}`\n    ])\n  })\n\n  it('warning sets the correct message', () => {\n    core.warning('Warning')\n    assertWriteCalls([`::warning::Warning${os.EOL}`])\n  })\n\n  it('warning escapes the message', () => {\n    core.warning('\\r\\nwarning\\n')\n    assertWriteCalls([`::warning::%0D%0Awarning%0A${os.EOL}`])\n  })\n\n  it('warning handles an error object', () => {\n    const message = 'this is my error message'\n    core.warning(new Error(message))\n    assertWriteCalls([`::warning::Error: ${message}${os.EOL}`])\n  })\n\n  it('warning handles parameters correctly', () => {\n    const message = 'this is my error message'\n    core.warning(new Error(message), {\n      title: 'A title',\n      file: 'root/test.txt',\n      startColumn: 1,\n      endColumn: 2,\n      startLine: 5,\n      endLine: 5\n    })\n    assertWriteCalls([\n      `::warning title=A title,file=root/test.txt,line=5,endLine=5,col=1,endColumn=2::Error: ${message}${os.EOL}`\n    ])\n  })\n\n  it('notice sets the correct message', () => {\n    core.notice('Notice')\n    assertWriteCalls([`::notice::Notice${os.EOL}`])\n  })\n\n  it('notice escapes the message', () => {\n    core.notice('\\r\\nnotice\\n')\n    assertWriteCalls([`::notice::%0D%0Anotice%0A${os.EOL}`])\n  })\n\n  it('notice handles an error object', () => {\n    const message = 'this is my error message'\n    core.notice(new Error(message))\n    assertWriteCalls([`::notice::Error: ${message}${os.EOL}`])\n  })\n\n  it('notice handles parameters correctly', () => {\n    const message = 'this is my error message'\n    core.notice(new Error(message), {\n      title: 'A title',\n      file: 'root/test.txt',\n      startColumn: 1,\n      endColumn: 2,\n      startLine: 5,\n      endLine: 5\n    })\n    assertWriteCalls([\n      `::notice title=A title,file=root/test.txt,line=5,endLine=5,col=1,endColumn=2::Error: ${message}${os.EOL}`\n    ])\n  })\n\n  it('annotations map field names correctly', () => {\n    const commandProperties = toCommandProperties({\n      title: 'A title',\n      file: 'root/test.txt',\n      startColumn: 1,\n      endColumn: 2,\n      startLine: 5,\n      endLine: 5\n    })\n    expect(commandProperties.title).toBe('A title')\n    expect(commandProperties.file).toBe('root/test.txt')\n    expect(commandProperties.col).toBe(1)\n    expect(commandProperties.endColumn).toBe(2)\n    expect(commandProperties.line).toBe(5)\n    expect(commandProperties.endLine).toBe(5)\n\n    expect(commandProperties.startColumn).toBeUndefined()\n    expect(commandProperties.startLine).toBeUndefined()\n  })\n\n  it('startGroup starts a new group', () => {\n    core.startGroup('my-group')\n    assertWriteCalls([`::group::my-group${os.EOL}`])\n  })\n\n  it('endGroup ends new group', () => {\n    core.endGroup()\n    assertWriteCalls([`::endgroup::${os.EOL}`])\n  })\n\n  it('group wraps an async call in a group', async () => {\n    const result = await core.group('mygroup', async () => {\n      process.stdout.write('in my group\\n')\n      return true\n    })\n    expect(result).toBe(true)\n    assertWriteCalls([\n      `::group::mygroup${os.EOL}`,\n      'in my group\\n',\n      `::endgroup::${os.EOL}`\n    ])\n  })\n\n  it('debug sets the correct message', () => {\n    core.debug('Debug')\n    assertWriteCalls([`::debug::Debug${os.EOL}`])\n  })\n\n  it('debug escapes the message', () => {\n    core.debug('\\r\\ndebug\\n')\n    assertWriteCalls([`::debug::%0D%0Adebug%0A${os.EOL}`])\n  })\n\n  it('saveState produces the correct command', () => {\n    core.saveState('state_1', 'some value')\n    assertWriteCalls([`::save-state name=state_1::some value${os.EOL}`])\n  })\n\n  it('saveState handles numbers', () => {\n    core.saveState('state_1', 1)\n    assertWriteCalls([`::save-state name=state_1::1${os.EOL}`])\n  })\n\n  it('saveState handles bools', () => {\n    core.saveState('state_1', true)\n    assertWriteCalls([`::save-state name=state_1::true${os.EOL}`])\n  })\n\n  it('getState gets wrapper action state', () => {\n    expect(core.getState('TEST_1')).toBe('state_val')\n  })\n\n  it('isDebug check debug state', () => {\n    const current = process.env['RUNNER_DEBUG']\n    try {\n      delete process.env.RUNNER_DEBUG\n      expect(core.isDebug()).toBe(false)\n\n      process.env['RUNNER_DEBUG'] = '1'\n      expect(core.isDebug()).toBe(true)\n    } finally {\n      process.env['RUNNER_DEBUG'] = current\n    }\n  })\n\n  it('setCommandEcho can enable echoing', () => {\n    core.setCommandEcho(true)\n    assertWriteCalls([`::echo::on${os.EOL}`])\n  })\n\n  it('setCommandEcho can disable echoing', () => {\n    core.setCommandEcho(false)\n    assertWriteCalls([`::echo::off${os.EOL}`])\n  })\n})\n\n// Assert that process.stdout.write calls called only with the given arguments.\nfunction assertWriteCalls(calls: string[]): void {\n  expect(process.stdout.write).toHaveBeenCalledTimes(calls.length)\n\n  for (let i = 0; i < calls.length; i++) {\n    expect(process.stdout.write).toHaveBeenNthCalledWith(i + 1, calls[i])\n  }\n}\n\nfunction createFileCommandFile(command: string): void {\n  const filePath = path.join(__dirname, `test/${command}`)\n  process.env[`GITHUB_${command}`] = filePath\n  fs.appendFileSync(filePath, '', {\n    encoding: 'utf8'\n  })\n}\n\nfunction verifyFileCommand(command: string, expectedContents: string): void {\n  const filePath = path.join(__dirname, `test/${command}`)\n  const contents = fs.readFileSync(filePath, 'utf8')\n  try {\n    expect(contents).toEqual(expectedContents)\n  } finally {\n    fs.unlinkSync(filePath)\n  }\n}\n\nfunction getTokenEndPoint(): string {\n  return 'https://vstoken.actions.githubusercontent.com/.well-known/openid-configuration'\n}\n\ndescribe('oidc-client-tests', () => {\n  it('Get Http Client', async () => {\n    const http = new HttpClient('actions/oidc-client')\n    expect(http).toBeDefined()\n  })\n\n  it('HTTP get request to get token endpoint', async () => {\n    const http = new HttpClient('actions/oidc-client')\n    const res = await http.get(getTokenEndPoint())\n    expect(res.message.statusCode).toBe(200)\n  })\n})\n", "{\n  \"name\": \"@actions/core\",\n  \"version\": \"1.9.1\",\n  \"lockfileVersion\": 2,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"@actions/core\",\n      \"version\": \"1.9.1\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@actions/http-client\": \"^2.0.1\",\n        \"uuid\": \"^8.3.2\"\n      },\n      \"devDependencies\": {\n        \"@types/node\": \"^12.0.2\",\n        \"@types/uuid\": \"^8.3.4\"\n      }\n    },\n    \"node_modules/@actions/http-client\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/@actions/http-client/-/http-client-2.0.1.tgz\",\n      \"integrity\": \"sha512-PIXiMVtz6VvyaRsGY268qvj57hXQEpsYogYOu2nrQhlf+XCGmZstmuZBbAybUl1nQGnvS1k1eEsQ69ZoD7xlSw==\",\n      \"dependencies\": {\n        \"tunnel\": \"^0.0.6\"\n      }\n    },\n    \"node_modules/@types/node\": {\n      \"version\": \"12.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-12.0.2.tgz\",\n      \"integrity\": \"sha512-5tabW/i+9mhrfEOUcLDu2xBPsHJ+X5Orqy9FKpale3SjDA17j5AEpYq5vfy3oAeAHGcvANRCO3NV3d2D6q3NiA==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/uuid\": {\n      \"version\": \"8.3.4\",\n      \"resolved\": \"https://registry.npmjs.org/@types/uuid/-/uuid-8.3.4.tgz\",\n      \"integrity\": \"sha512-c/I8ZRb51j+pYGAu5CrFMRxqZ2ke4y2grEBO5AUjgSkSk+qT2Ea+OdWElz/OiMf5MNpn2b17kuVBwZLQJXzihw==\",\n      \"dev\": true\n    },\n    \"node_modules/tunnel\": {\n      \"version\": \"0.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/tunnel/-/tunnel-0.0.6.tgz\",\n      \"integrity\": \"sha512-1h/Lnq9yajKY2PEbBadPXj3VxsDDu844OnaAo52UVmIzIvwwtBPIuNvkjuzBlTWpfJyUbG3ez0KSBibQkj4ojg==\",\n      \"engines\": {\n        \"node\": \">=0.6.11 <=0.7.0 || >=0.7.3\"\n      }\n    },\n    \"node_modules/uuid\": {\n      \"version\": \"8.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz\",\n      \"integrity\": \"sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==\",\n      \"bin\": {\n        \"uuid\": \"dist/bin/uuid\"\n      }\n    }\n  },\n  \"dependencies\": {\n    \"@actions/http-client\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/@actions/http-client/-/http-client-2.0.1.tgz\",\n      \"integrity\": \"sha512-PIXiMVtz6VvyaRsGY268qvj57hXQEpsYogYOu2nrQhlf+XCGmZstmuZBbAybUl1nQGnvS1k1eEsQ69ZoD7xlSw==\",\n      \"requires\": {\n        \"tunnel\": \"^0.0.6\"\n      }\n    },\n    \"@types/node\": {\n      \"version\": \"12.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-12.0.2.tgz\",\n      \"integrity\": \"sha512-5tabW/i+9mhrfEOUcLDu2xBPsHJ+X5Orqy9FKpale3SjDA17j5AEpYq5vfy3oAeAHGcvANRCO3NV3d2D6q3NiA==\",\n      \"dev\": true\n    },\n    \"@types/uuid\": {\n      \"version\": \"8.3.4\",\n      \"resolved\": \"https://registry.npmjs.org/@types/uuid/-/uuid-8.3.4.tgz\",\n      \"integrity\": \"sha512-c/I8ZRb51j+pYGAu5CrFMRxqZ2ke4y2grEBO5AUjgSkSk+qT2Ea+OdWElz/OiMf5MNpn2b17kuVBwZLQJXzihw==\",\n      \"dev\": true\n    },\n    \"tunnel\": {\n      \"version\": \"0.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/tunnel/-/tunnel-0.0.6.tgz\",\n      \"integrity\": \"sha512-1h/Lnq9yajKY2PEbBadPXj3VxsDDu844OnaAo52UVmIzIvwwtBPIuNvkjuzBlTWpfJyUbG3ez0KSBibQkj4ojg==\"\n    },\n    \"uuid\": {\n      \"version\": \"8.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz\",\n      \"integrity\": \"sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==\"\n    }\n  }\n}\n", "{\n  \"name\": \"@actions/core\",\n  \"version\": \"1.9.1\",\n  \"description\": \"Actions core lib\",\n  \"keywords\": [\n    \"github\",\n    \"actions\",\n    \"core\"\n  ],\n  \"homepage\": \"https://github.com/actions/toolkit/tree/main/packages/core\",\n  \"license\": \"MIT\",\n  \"main\": \"lib/core.js\",\n  \"types\": \"lib/core.d.ts\",\n  \"directories\": {\n    \"lib\": \"lib\",\n    \"test\": \"__tests__\"\n  },\n  \"files\": [\n    \"lib\",\n    \"!.DS_Store\"\n  ],\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/actions/toolkit.git\",\n    \"directory\": \"packages/core\"\n  },\n  \"scripts\": {\n    \"audit-moderate\": \"npm install && npm audit --json --audit-level=moderate > audit.json\",\n    \"test\": \"echo \\\"Error: run tests from root\\\" && exit 1\",\n    \"tsc\": \"tsc\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/actions/toolkit/issues\"\n  },\n  \"dependencies\": {\n    \"@actions/http-client\": \"^2.0.1\",\n    \"uuid\": \"^8.3.2\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^12.0.2\",\n    \"@types/uuid\": \"^8.3.4\"\n  }\n}\n", "import {issue, issueCommand} from './command'\nimport {issueCommand as issueFileCommand} from './file-command'\nimport {toCommandProperties, toCommandValue} from './utils'\n\nimport * as os from 'os'\nimport * as path from 'path'\nimport { v4 as uuidv4 } from 'uuid'\n\nimport {OidcClient} from './oidc-utils'\n\n/**\n * Interface for getInput options\n */\nexport interface InputOptions {\n  /** Optional. Whether the input is required. If required and not present, will throw. Defaults to false */\n  required?: boolean\n\n  /** Optional. Whether leading/trailing whitespace will be trimmed for the input. Defaults to true */\n  trimWhitespace?: boolean\n}\n\n/**\n * The code to exit an action\n */\nexport enum ExitCode {\n  /**\n   * A code indicating that the action was successful\n   */\n  Success = 0,\n\n  /**\n   * A code indicating that the action was a failure\n   */\n  Failure = 1\n}\n\n/**\n * Optional properties that can be sent with annotatation commands (notice, error, and warning)\n * See: https://docs.github.com/en/rest/reference/checks#create-a-check-run for more information about annotations.\n */\nexport interface AnnotationProperties {\n  /**\n   * A title for the annotation.\n   */\n  title?: string\n\n  /**\n   * The path of the file for which the annotation should be created.\n   */\n  file?: string\n\n  /**\n   * The start line for the annotation.\n   */\n  startLine?: number\n\n  /**\n   * The end line for the annotation. Defaults to `startLine` when `startLine` is provided.\n   */\n  endLine?: number\n\n  /**\n   * The start column for the annotation. Cannot be sent when `startLine` and `endLine` are different values.\n   */\n  startColumn?: number\n\n  /**\n   * The start column for the annotation. Cannot be sent when `startLine` and `endLine` are different values.\n   * Defaults to `startColumn` when `startColumn` is provided.\n   */\n  endColumn?: number\n}\n\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function exportVariable(name: string, val: any): void {\n  const convertedVal = toCommandValue(val)\n  process.env[name] = convertedVal\n\n  const filePath = process.env['GITHUB_ENV'] || ''\n  if (filePath) {\n    const delimiter = `ghadelimiter_${uuidv4()}`\n\n    // These should realistically never happen, but just in case someone finds a way to exploit uuid generation let's not allow keys or values that contain the delimiter.  \n    if (name.includes(delimiter)) {\n      throw new Error(`Unexpected input: name should not contain the delimiter \"${delimiter}\"`)\n    }\n\n    if (convertedVal.includes(delimiter)) {\n      throw new Error(`Unexpected input: value should not contain the delimiter \"${delimiter}\"`)\n    }\n\n    const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`\n    issueFileCommand('ENV', commandValue)\n  } else {\n    issueCommand('set-env', {name}, convertedVal)\n  }\n}\n\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nexport function setSecret(secret: string): void {\n  issueCommand('add-mask', {}, secret)\n}\n\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nexport function addPath(inputPath: string): void {\n  const filePath = process.env['GITHUB_PATH'] || ''\n  if (filePath) {\n    issueFileCommand('PATH', inputPath)\n  } else {\n    issueCommand('add-path', {}, inputPath)\n  }\n  process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`\n}\n\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nexport function getInput(name: string, options?: InputOptions): string {\n  const val: string =\n    process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || ''\n  if (options && options.required && !val) {\n    throw new Error(`Input required and not supplied: ${name}`)\n  }\n\n  if (options && options.trimWhitespace === false) {\n    return val\n  }\n\n  return val.trim()\n}\n\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nexport function getMultilineInput(\n  name: string,\n  options?: InputOptions\n): string[] {\n  const inputs: string[] = getInput(name, options)\n    .split('\\n')\n    .filter(x => x !== '')\n\n  return inputs\n}\n\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nexport function getBooleanInput(name: string, options?: InputOptions): boolean {\n  const trueValue = ['true', 'True', 'TRUE']\n  const falseValue = ['false', 'False', 'FALSE']\n  const val = getInput(name, options)\n  if (trueValue.includes(val)) return true\n  if (falseValue.includes(val)) return false\n  throw new TypeError(\n    `Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n      `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``\n  )\n}\n\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function setOutput(name: string, value: any): void {\n  process.stdout.write(os.EOL)\n  issueCommand('set-output', {name}, value)\n}\n\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nexport function setCommandEcho(enabled: boolean): void {\n  issue('echo', enabled ? 'on' : 'off')\n}\n\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nexport function setFailed(message: string | Error): void {\n  process.exitCode = ExitCode.Failure\n\n  error(message)\n}\n\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n\n/**\n * Gets whether Actions Step Debug is on or not\n */\nexport function isDebug(): boolean {\n  return process.env['RUNNER_DEBUG'] === '1'\n}\n\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nexport function debug(message: string): void {\n  issueCommand('debug', {}, message)\n}\n\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nexport function error(\n  message: string | Error,\n  properties: AnnotationProperties = {}\n): void {\n  issueCommand(\n    'error',\n    toCommandProperties(properties),\n    message instanceof Error ? message.toString() : message\n  )\n}\n\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nexport function warning(\n  message: string | Error,\n  properties: AnnotationProperties = {}\n): void {\n  issueCommand(\n    'warning',\n    toCommandProperties(properties),\n    message instanceof Error ? message.toString() : message\n  )\n}\n\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nexport function notice(\n  message: string | Error,\n  properties: AnnotationProperties = {}\n): void {\n  issueCommand(\n    'notice',\n    toCommandProperties(properties),\n    message instanceof Error ? message.toString() : message\n  )\n}\n\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nexport function info(message: string): void {\n  process.stdout.write(message + os.EOL)\n}\n\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nexport function startGroup(name: string): void {\n  issue('group', name)\n}\n\n/**\n * End an output group.\n */\nexport function endGroup(): void {\n  issue('endgroup')\n}\n\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nexport async function group<T>(name: string, fn: () => Promise<T>): Promise<T> {\n  startGroup(name)\n\n  let result: T\n\n  try {\n    result = await fn()\n  } finally {\n    endGroup()\n  }\n\n  return result\n}\n\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function saveState(name: string, value: any): void {\n  issueCommand('save-state', {name}, value)\n}\n\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nexport function getState(name: string): string {\n  return process.env[`STATE_${name}`] || ''\n}\n\nexport async function getIDToken(aud?: string): Promise<string> {\n  return await OidcClient.getIDToken(aud)\n}\n\n/**\n * Summary exports\n */\nexport {summary} from './summary'\n\n/**\n * @deprecated use core.summary\n */\nexport {markdownSummary} from './summary'\n\n/**\n * Path exports\n */\nexport {toPosixPath, toWin32Path, toPlatformPath} from './path-utils'\n"], "filenames": ["packages/core/RELEASES.md", "packages/core/__tests__/core.test.ts", "packages/core/package-lock.json", "packages/core/package.json", "packages/core/src/core.ts"], "buggy_code_start_loc": [1, 6, 3, 3, 6], "buggy_code_end_loc": [1, 116, 59, 43, 90], "fixing_code_start_loc": [2, 7, 3, 3, 7], "fixing_code_end_loc": [5, 154, 87, 45, 101], "type": "CWE-74", "message": "The GitHub Actions ToolKit provides a set of packages to make creating actions easier. The `core.exportVariable` function uses a well known delimiter that attackers can use to break out of that specific variable and assign values to other arbitrary variables. Workflows that write untrusted values to the `GITHUB_ENV` file may cause the path or other environment variables to be modified without the intention of the workflow or action author. Users should upgrade to `@actions/core v1.9.1`. If you are unable to upgrade the `@actions/core` package, you can modify your action to ensure that any user input does not contain the delimiter `_GitHubActionsFileCommandDelimeter_` before calling `core.exportVariable`.", "other": {"cve": {"id": "CVE-2022-35954", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-15T11:21:39.040", "lastModified": "2022-08-16T16:54:47.373", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The GitHub Actions ToolKit provides a set of packages to make creating actions easier. The `core.exportVariable` function uses a well known delimiter that attackers can use to break out of that specific variable and assign values to other arbitrary variables. Workflows that write untrusted values to the `GITHUB_ENV` file may cause the path or other environment variables to be modified without the intention of the workflow or action author. Users should upgrade to `@actions/core v1.9.1`. If you are unable to upgrade the `@actions/core` package, you can modify your action to ensure that any user input does not contain the delimiter `_GitHubActionsFileCommandDelimeter_` before calling `core.exportVariable`."}, {"lang": "es", "value": "El GitHub Actions ToolKit proporciona un conjunto de paquetes para facilitar la creaci\u00f3n de acciones. La funci\u00f3n \"core.exportVariable\" usa un delimitador bien conocido que atacantes pueden usar para salir de esa variable espec\u00edfica y asignar valores a otras variables arbitrarias. Los flujos de trabajo que escriben valores no confiables en el archivo \"GITHUB_ENV\" pueden causar que la ruta u otras variables de entorno sean modificadas sin la intenci\u00f3n del flujo de trabajo o del autor de la acci\u00f3n. Los usuarios deben actualizar a \"@actions/core versi\u00f3n v1.9.1\". Si no puede actualizar el paquete \"@actions/core\", puede modificar su acci\u00f3n para asegurarse de que cualquier entrada del usuario no contenga el delimitador \"_GitHubActionsFileCommandDelimeter_\" antes de llamar a \"core.exportVariable\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:github:toolkit:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.9.1", "matchCriteriaId": "EE49BC87-9BE8-4ED0-A751-952D968302B6"}]}]}], "references": [{"url": "https://github.com/actions/toolkit/commit/4beda9cbc00ba6eefe387a937c21087ccb8ee9df", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/actions/toolkit/security/advisories/GHSA-7r3h-m5j6-3q42", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/actions/toolkit/commit/4beda9cbc00ba6eefe387a937c21087ccb8ee9df"}}