{"buggy_code": ["/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Enterprise License (PEL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PEL\n */\n\npimcore.registerNS(\"pimcore.settings.translations\");\npimcore.settings.translations = Class.create({\n\n\n    filterField: null,\n    preconfiguredFilter: \"\",\n\n    initialize: function (filter) {\n\n        this.filterField = new Ext.form.TextField({\n            xtype: \"textfield\",\n            width: 200,\n            style: \"margin: 0 10px 0 0;\",\n            enableKeyEvents: true,\n            value: this.preconfiguredFilter,\n            listeners: {\n                \"keydown\": function (field, key) {\n                    if (key.getKey() == key.ENTER) {\n                        var input = field;\n                        var proxy = this.store.getProxy();\n                        proxy.extraParams.searchString = input.getValue();\n                        this.store.load({\n                            page: 1\n                        });\n                    }\n                }.bind(this)\n            }\n        });\n\n        this.preconfiguredFilter = filter;\n        this.filterField.setValue(filter);\n        this.getAvailableLanguages();\n        this.config = {};\n    },\n\n\n    getRowEditor: function () {\n\n        var stateId = \"tr_\" + this.translationType;\n        var applyInitialSettings = false;\n        var showInfo = false;\n        var state = Ext.state.Manager.getProvider().get(stateId, null);\n        var languages = this.languages;\n\n        var maxCols = 7;   // include creation date / modification date / action column)\n        var maxLanguages = maxCols - 3;\n\n        if (state == null) {\n            applyInitialSettings = true;\n            if (languages.length > maxLanguages) {\n                showInfo = true;\n            }\n        } else {\n            if (state.columns) {\n                for (var i = 0; i < state.columns.length; i++) {\n                    var colState = state.columns[i];\n                    if (colState.hidden) {\n                        showInfo = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        var dateConverter = function (v, r) {\n            var d = new Date(intval(v));\n            return d;\n        };\n\n        var readerFields = [\n            {name: 'id', persist: false},\n            {name: 'editor', persist: false},\n            {name: 'key', allowBlank: false},\n            {name: 'creationDate', type: 'date', convert: dateConverter, persist: false},\n            {name: 'modificationDate', type: 'date', convert: dateConverter, persist: false}\n        ];\n\n        var typesColumns = [\n            {text: t(\"key\"), sortable: true, dataIndex: 'key', editable: false, filter: 'string'}\n        ];\n\n        for (var i = 0; i < languages.length; i++) {\n            readerFields.push({name: \"_\" + languages[i]});\n\n            var columnConfig = {\n                cls: \"x-column-header_\" + languages[i].toLowerCase(),\n                text: pimcore.available_languages[languages[i]],\n                sortable: true,\n                dataIndex: \"_\" + languages[i],\n                filter: 'string',\n                getEditor: this.getCellEditor.bind(this, languages[i]),\n                id: \"translation_column_\" + this.translationType + \"_\" + languages[i].toLowerCase()\n            };\n            if (applyInitialSettings) {\n                var hidden = i >= maxLanguages;\n                columnConfig.hidden = hidden;\n            }\n\n            typesColumns.push(columnConfig);\n        }\n\n        if (showInfo) {\n            pimcore.helpers.showNotification(t(\"info\"), t(\"there_are_more_columns\"), null, null, 2000);\n        }\n\n        var dateRenderer = function (d) {\n            var date = new Date(d * 1000);\n            return Ext.Date.format(date, \"Y-m-d H:i:s\");\n        };\n        typesColumns.push({\n            text: t(\"creationDate\"), sortable: true, dataIndex: 'creationDate', editable: false\n            , renderer: dateRenderer, filter: 'date'\n        });\n        typesColumns.push({\n            text: t(\"modificationDate\"), sortable: true, dataIndex: 'modificationDate', editable: false\n            , renderer: dateRenderer, filter: 'date'\n        })\n        ;\n\n        if (pimcore.settings.websiteLanguages.length == this.editableLanguages.length || this.translationType === 'admin') {\n            typesColumns.push({\n                xtype: 'actioncolumn',\n                menuText: t('delete'),\n                width: 30,\n                items: [{\n                    tooltip: t('delete'),\n                    icon: \"/bundles/pimcoreadmin/img/flat-color-icons/delete.svg\",\n                    handler: function (grid, rowIndex) {\n                        grid.getStore().removeAt(rowIndex);\n                    }.bind(this)\n                }]\n            });\n        }\n\n        var itemsPerPage = pimcore.helpers.grid.getDefaultPageSize(-1);\n\n        this.store = pimcore.helpers.grid.buildDefaultStore(\n            this.dataUrl,\n            readerFields,\n            itemsPerPage, {\n                idProperty: 'key'\n            }\n        );\n\n        var store = this.store;\n\n        this.store.getProxy().on('exception', function (proxy, request, operation) {\n            operation.config.records.forEach(function (item) {\n                store.remove(item);\n            });\n        });\n\n        if (this.preconfiguredFilter) {\n            this.store.getProxy().extraParams.searchString = this.preconfiguredFilter;\n        }\n\n        this.pagingtoolbar = pimcore.helpers.grid.buildDefaultPagingToolbar(this.store, {pageSize: itemsPerPage});\n\n        this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {\n            clicksToEdit: 1,\n            listeners: {\n                beforeedit: function(editor, context, eOpts) {\n                    editor.editors.each(function (e) {\n                        try {\n                            // complete edit, so the value is stored when hopping around with TAB\n                            e.completeEdit();\n                            Ext.destroy(e);\n                        } catch (exception) {\n                            // garbage collector was faster\n                            // already destroyed\n                        }\n                    });\n\n                    editor.editors.clear();\n                }\n            }\n        });\n\n        var toolbar = Ext.create('Ext.Toolbar', {\n            cls: 'pimcore_main_toolbar',\n            items: [\n                {\n                    text: t('add'),\n                    handler: this.onAdd.bind(this),\n                    iconCls: \"pimcore_icon_add\"\n                },\n                '-', {\n                    text: this.getHint(),\n                    xtype: \"tbtext\",\n                    style: \"margin: 0 10px 0 0;\"\n                },\n                \"->\",\n                {\n                    text: t('cleanup'),\n                    handler: this.cleanup.bind(this),\n                    iconCls: \"pimcore_icon_cleanup\"\n                },\n                \"-\",\n                {\n                    text: t('merge_csv'),\n                    handler: this.doMerge.bind(this),\n                    iconCls: \"pimcore_icon_merge\"\n                },\n                '-',\n                {\n                    text: t('export_csv'),\n                    handler: this.doExport.bind(this),\n                    iconCls: \"pimcore_icon_export\"\n                }, '-', {\n                    text: t(\"filter\") + \"/\" + t(\"search\"),\n                    xtype: \"tbtext\",\n                    style: \"margin: 0 10px 0 0;\"\n                }, this.filterField\n            ]\n        });\n\n        this.grid = Ext.create('Ext.grid.Panel', {\n            frame: false,\n            bodyCls: \"pimcore_editable_grid\",\n            autoScroll: true,\n            store: this.store,\n            columnLines: true,\n            stripeRows: true,\n            columns: {\n                items: typesColumns,\n                defaults: {\n                    flex: 1\n                }\n            },\n            trackMouseOver: true,\n            bbar: this.pagingtoolbar,\n            stateful: true,\n            stateId: stateId,\n            stateEvents: ['columnmove', 'columnresize', 'sortchange', 'groupchange'],\n            selModel: Ext.create('Ext.selection.RowModel', {}),\n            plugins: [\n                \"pimcore.gridfilters\",\n                this.cellEditing\n            ],\n            tbar: toolbar,\n            viewConfig: {\n                forceFit: true,\n                loadingText: t('please_wait'),\n                enableTextSelection: true\n            },\n            listeners: {\n                cellcontextmenu: this.createCellContextMenu.bind(this),\n                cellClick: function( grid, cell, cellIndex, record, row, recordIndex, e ) {\n                    var cm = grid.headerCt.getGridColumns()\n                    var dataIndex = cm[cellIndex].dataIndex;\n                    if (!in_array(trim(dataIndex, \"_\"), this.languages)) {\n                        return;\n                    }\n\n                    var data = record.get(dataIndex);\n\n                    var htmlRegex = /<([A-Za-z][A-Za-z0-9]*)\\b[^>]*>(.*?)<\\/\\1>/;\n                    if (htmlRegex.test(data)) {\n                        record.set(\"editor\", \"html\");\n                    } else if (data && data.match(/\\n/gm))  {\n                        record.set(\"editor\", \"plain\");\n                    } else {\n                        record.set(\"editor\", null);\n                    }\n                    return true;\n\n                }.bind(this)\n            }\n        });\n\n        this.store.load();\n\n        return this.grid;\n    },\n\n    createCellContextMenu: function (grid, td, cellIndex, record, tr, rowIndex, e, eOpts ) {\n        var cm = grid.headerCt.getGridColumns();\n        var dataIndex = trim(cm[cellIndex].dataIndex, \"_\");\n        if (!in_array(dataIndex, this.languages)) {\n            return;\n        }\n\n        e.stopEvent();\n\n        var handler = function(rowIndex, cellIndex, mode) {\n            record.set(\"editor\", mode);\n            this.cellEditing.startEditByPosition({\n                row : rowIndex,\n                column: cellIndex\n            });\n        };\n\n        var menu = new Ext.menu.Menu();\n        menu.add(new Ext.menu.Item({\n            text: t('edit_as_plain_text'),\n            iconCls: \"pimcore_icon_edit\",\n            handler: handler.bind(this, rowIndex, cellIndex, \"plain\")\n        }));\n\n\n        menu.add(new Ext.menu.Item({\n            text: t('edit_as_html'),\n            iconCls: \"pimcore_icon_edit\",\n            handler: handler.bind(this, rowIndex, cellIndex, \"html\")\n        }));\n\n        menu.showAt(e.pageX, e.pageY);\n    },\n\n    doMerge: function () {\n        pimcore.helpers.uploadDialog(this.uploadImportUrl, \"Filedata\", function (result) {\n            var data = result.response.responseText;\n            data = Ext.decode(data);\n\n            if(data && data.success == true) {\n                this.config = data.config;\n                this.showImportForm();\n            } else {\n                Ext.MessageBox.alert(t(\"error\"), t(\"error\"));\n            }\n        }.bind(this), function () {\n            Ext.MessageBox.alert(t(\"error\"), t(\"error\"));\n        });\n    },\n\n    refresh: function () {\n        this.store.reload();\n    },\n\n    showImportForm: function () {\n        this.csvSettingsPanel = new pimcore.object.helpers.import.csvSettingsTab(this.config, false, this);\n\n        var ImportForm = new Ext.form.FormPanel({\n            width: 500,\n            bodyStyle: 'padding: 10px;',\n            items: [{\n                    xtype: \"form\",\n                    bodyStyle: \"padding: 10px;\",\n                    defaults: {\n                        labelWidth: 250,\n                        width: 550\n                    },\n                    itemId: \"form\",\n                    items: [this.csvSettingsPanel.getPanel()],\n                    buttons: [{\n                        text: t(\"cancel\"),\n                        iconCls: \"pimcore_icon_cancel\",\n                        handler: function () {\n                            win.close();\n                        }\n                    },\n                    {\n                    text: t(\"import\"),\n                    iconCls: \"pimcore_icon_import\",\n                    handler: function () {\n                        if(ImportForm.isValid()) {\n                            this.csvSettingsPanel.commitData();\n                            var csvSettings = Ext.encode(this.config.csvSettings);\n                            ImportForm.getForm().submit({\n                                url: this.mergeUrl,\n                                params: {importFile: this.config.tmpFile, csvSettings: csvSettings},\n                                waitMsg: t(\"please_wait\"),\n                                success: function (el, response) {\n                                    try {\n                                        var data = response.response.responseText;\n                                        data = Ext.decode(data);\n                                        var merger = new pimcore.settings.translation.translationmerger(this.translationType, data, this);\n                                        this.refresh();\n                                        win.close();\n                                    } catch (e) {\n                                        Ext.MessageBox.alert(t(\"error\"), t(\"error\"));\n                                        win.close();\n                                    }\n                                }.bind(this),\n                                failure: function (el, res) {\n                                    Ext.MessageBox.alert(t(\"error\"), t(\"error\"));\n                                    win.close();\n                                }\n                            });\n                        }\n                    }.bind(this)\n                    }]\n                }]\n        });\n\n        var windowCfg = {\n            title: t(\"merge_csv\"),\n            width: 600,\n            layout: \"fit\",\n            closeAction: \"close\",\n            items: [ImportForm]\n        };\n\n        var win = new Ext.Window(windowCfg);\n\n        win.show();\n    },\n\n    doExport: function () {\n        var store = this.grid.store;\n        var storeFilters = store.getFilters().items;\n        var proxy = store.getProxy();\n\n        var filtersActive = this.filterField.getValue() || storeFilters.length > 0;\n        if (filtersActive) {\n            Ext.MessageBox.confirm(\"\", t(\"filter_active_message\"), function (buttonValue) {\n                if (buttonValue == \"yes\") {\n                    var queryString = \"searchString=\" + this.filterField.getValue();\n                    var encodedFilters = proxy.encodeFilters(storeFilters);\n                    queryString += \"&filter=\" + encodedFilters;\n                    pimcore.helpers.download(Ext.urlAppend(this.exportUrl, queryString));\n                } else {\n                    pimcore.helpers.download(this.exportUrl);\n                }\n            }.bind(this));\n        } else {\n            pimcore.helpers.download(this.exportUrl);\n        }\n    },\n\n    onAdd: function (btn, ev) {\n\n        Ext.MessageBox.prompt(\"\", t(\"please_enter_the_new_name\"), function (button, value) {\n            if (button == \"ok\") {\n                this.cellEditing.cancelEdit();\n\n                this.grid.store.insert(0, {\n                    key: value\n                });\n\n                this.cellEditing.startEditByPosition({\n                    row: 0,\n                    column: 1\n                });\n            }\n        }.bind(this));\n    },\n\n    cleanup: function () {\n        Ext.Ajax.request({\n            url: this.cleanupUrl,\n            method: 'DELETE',\n            success: function (response) {\n                this.store.reload();\n            }.bind(this)\n        });\n    },\n\n    getCellEditor: function(language, record) {\n\n        var editor;\n\n        if (!record.data.editor) {\n            editor = this.editableLanguages.indexOf(language) >= 0 ? new Ext.form.TextField({}) : null;\n        } else {\n            editor = new pimcore.settings.translationEditor({\n                __editorType: record.data.editor,\n                __outerTitle: record.data.editor == \"plain\" ? t(\"edit_as_plain_text\") : t(\"edit_as_html\"),\n                __innerTitle: record.data.key\n            });\n\n        }\n\n        return editor;\n    }\n\n});\n"], "fixing_code": ["/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Enterprise License (PEL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PEL\n */\n\npimcore.registerNS(\"pimcore.settings.translations\");\npimcore.settings.translations = Class.create({\n\n\n    filterField: null,\n    preconfiguredFilter: \"\",\n\n    initialize: function (filter) {\n\n        this.filterField = new Ext.form.TextField({\n            xtype: \"textfield\",\n            width: 200,\n            style: \"margin: 0 10px 0 0;\",\n            enableKeyEvents: true,\n            value: this.preconfiguredFilter,\n            listeners: {\n                \"keydown\": function (field, key) {\n                    if (key.getKey() == key.ENTER) {\n                        var input = field;\n                        var proxy = this.store.getProxy();\n                        proxy.extraParams.searchString = input.getValue();\n                        this.store.load({\n                            page: 1\n                        });\n                    }\n                }.bind(this)\n            }\n        });\n\n        this.preconfiguredFilter = filter;\n        this.filterField.setValue(filter);\n        this.getAvailableLanguages();\n        this.config = {};\n    },\n\n\n    getRowEditor: function () {\n\n        var stateId = \"tr_\" + this.translationType;\n        var applyInitialSettings = false;\n        var showInfo = false;\n        var state = Ext.state.Manager.getProvider().get(stateId, null);\n        var languages = this.languages;\n\n        var maxCols = 7;   // include creation date / modification date / action column)\n        var maxLanguages = maxCols - 3;\n\n        if (state == null) {\n            applyInitialSettings = true;\n            if (languages.length > maxLanguages) {\n                showInfo = true;\n            }\n        } else {\n            if (state.columns) {\n                for (var i = 0; i < state.columns.length; i++) {\n                    var colState = state.columns[i];\n                    if (colState.hidden) {\n                        showInfo = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        var dateConverter = function (v, r) {\n            var d = new Date(intval(v));\n            return d;\n        };\n\n        var readerFields = [\n            {name: 'id', persist: false},\n            {name: 'editor', persist: false},\n            {name: 'key', allowBlank: false},\n            {name: 'creationDate', type: 'date', convert: dateConverter, persist: false},\n            {name: 'modificationDate', type: 'date', convert: dateConverter, persist: false}\n        ];\n\n        var typesColumns = [\n            {text: t(\"key\"), sortable: true, dataIndex: 'key', editable: false, filter: 'string'}\n        ];\n\n        for (var i = 0; i < languages.length; i++) {\n            readerFields.push({name: \"_\" + languages[i]});\n\n            var columnConfig = {\n                cls: \"x-column-header_\" + languages[i].toLowerCase(),\n                text: pimcore.available_languages[languages[i]],\n                sortable: true,\n                dataIndex: \"_\" + languages[i],\n                filter: 'string',\n                getEditor: this.getCellEditor.bind(this, languages[i]),\n                renderer: function (text) {\n                    return replace_html_event_attributes(strip_tags(text, 'div,span,b,strong,em,i,small,sup,sub,p'));\n                },\n                id: \"translation_column_\" + this.translationType + \"_\" + languages[i].toLowerCase()\n            };\n            if (applyInitialSettings) {\n                var hidden = i >= maxLanguages;\n                columnConfig.hidden = hidden;\n            }\n\n            typesColumns.push(columnConfig);\n        }\n\n        if (showInfo) {\n            pimcore.helpers.showNotification(t(\"info\"), t(\"there_are_more_columns\"), null, null, 2000);\n        }\n\n        var dateRenderer = function (d) {\n            var date = new Date(d * 1000);\n            return Ext.Date.format(date, \"Y-m-d H:i:s\");\n        };\n        typesColumns.push({\n            text: t(\"creationDate\"), sortable: true, dataIndex: 'creationDate', editable: false\n            , renderer: dateRenderer, filter: 'date'\n        });\n        typesColumns.push({\n            text: t(\"modificationDate\"), sortable: true, dataIndex: 'modificationDate', editable: false\n            , renderer: dateRenderer, filter: 'date'\n        })\n        ;\n\n        if (pimcore.settings.websiteLanguages.length == this.editableLanguages.length || this.translationType === 'admin') {\n            typesColumns.push({\n                xtype: 'actioncolumn',\n                menuText: t('delete'),\n                width: 30,\n                items: [{\n                    tooltip: t('delete'),\n                    icon: \"/bundles/pimcoreadmin/img/flat-color-icons/delete.svg\",\n                    handler: function (grid, rowIndex) {\n                        grid.getStore().removeAt(rowIndex);\n                    }.bind(this)\n                }]\n            });\n        }\n\n        var itemsPerPage = pimcore.helpers.grid.getDefaultPageSize(-1);\n\n        this.store = pimcore.helpers.grid.buildDefaultStore(\n            this.dataUrl,\n            readerFields,\n            itemsPerPage, {\n                idProperty: 'key'\n            }\n        );\n\n        var store = this.store;\n\n        this.store.getProxy().on('exception', function (proxy, request, operation) {\n            operation.config.records.forEach(function (item) {\n                store.remove(item);\n            });\n        });\n\n        if (this.preconfiguredFilter) {\n            this.store.getProxy().extraParams.searchString = this.preconfiguredFilter;\n        }\n\n        this.pagingtoolbar = pimcore.helpers.grid.buildDefaultPagingToolbar(this.store, {pageSize: itemsPerPage});\n\n        this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {\n            clicksToEdit: 1,\n            listeners: {\n                beforeedit: function(editor, context, eOpts) {\n                    editor.editors.each(function (e) {\n                        try {\n                            // complete edit, so the value is stored when hopping around with TAB\n                            e.completeEdit();\n                            Ext.destroy(e);\n                        } catch (exception) {\n                            // garbage collector was faster\n                            // already destroyed\n                        }\n                    });\n\n                    editor.editors.clear();\n                }\n            }\n        });\n\n        var toolbar = Ext.create('Ext.Toolbar', {\n            cls: 'pimcore_main_toolbar',\n            items: [\n                {\n                    text: t('add'),\n                    handler: this.onAdd.bind(this),\n                    iconCls: \"pimcore_icon_add\"\n                },\n                '-', {\n                    text: this.getHint(),\n                    xtype: \"tbtext\",\n                    style: \"margin: 0 10px 0 0;\"\n                },\n                \"->\",\n                {\n                    text: t('cleanup'),\n                    handler: this.cleanup.bind(this),\n                    iconCls: \"pimcore_icon_cleanup\"\n                },\n                \"-\",\n                {\n                    text: t('merge_csv'),\n                    handler: this.doMerge.bind(this),\n                    iconCls: \"pimcore_icon_merge\"\n                },\n                '-',\n                {\n                    text: t('export_csv'),\n                    handler: this.doExport.bind(this),\n                    iconCls: \"pimcore_icon_export\"\n                }, '-', {\n                    text: t(\"filter\") + \"/\" + t(\"search\"),\n                    xtype: \"tbtext\",\n                    style: \"margin: 0 10px 0 0;\"\n                }, this.filterField\n            ]\n        });\n\n        this.grid = Ext.create('Ext.grid.Panel', {\n            frame: false,\n            bodyCls: \"pimcore_editable_grid\",\n            autoScroll: true,\n            store: this.store,\n            columnLines: true,\n            stripeRows: true,\n            columns: {\n                items: typesColumns,\n                defaults: {\n                    flex: 1\n                }\n            },\n            trackMouseOver: true,\n            bbar: this.pagingtoolbar,\n            stateful: true,\n            stateId: stateId,\n            stateEvents: ['columnmove', 'columnresize', 'sortchange', 'groupchange'],\n            selModel: Ext.create('Ext.selection.RowModel', {}),\n            plugins: [\n                \"pimcore.gridfilters\",\n                this.cellEditing\n            ],\n            tbar: toolbar,\n            viewConfig: {\n                forceFit: true,\n                loadingText: t('please_wait'),\n                enableTextSelection: true\n            },\n            listeners: {\n                cellcontextmenu: this.createCellContextMenu.bind(this),\n                cellClick: function( grid, cell, cellIndex, record, row, recordIndex, e ) {\n                    var cm = grid.headerCt.getGridColumns()\n                    var dataIndex = cm[cellIndex].dataIndex;\n                    if (!in_array(trim(dataIndex, \"_\"), this.languages)) {\n                        return;\n                    }\n\n                    var data = record.get(dataIndex);\n\n                    var htmlRegex = /<([A-Za-z][A-Za-z0-9]*)\\b[^>]*>(.*?)<\\/\\1>/;\n                    if (htmlRegex.test(data)) {\n                        record.set(\"editor\", \"html\");\n                    } else if (data && data.match(/\\n/gm))  {\n                        record.set(\"editor\", \"plain\");\n                    } else {\n                        record.set(\"editor\", null);\n                    }\n                    return true;\n\n                }.bind(this)\n            }\n        });\n\n        this.store.load();\n\n        return this.grid;\n    },\n\n    createCellContextMenu: function (grid, td, cellIndex, record, tr, rowIndex, e, eOpts ) {\n        var cm = grid.headerCt.getGridColumns();\n        var dataIndex = trim(cm[cellIndex].dataIndex, \"_\");\n        if (!in_array(dataIndex, this.languages)) {\n            return;\n        }\n\n        e.stopEvent();\n\n        var handler = function(rowIndex, cellIndex, mode) {\n            record.set(\"editor\", mode);\n            this.cellEditing.startEditByPosition({\n                row : rowIndex,\n                column: cellIndex\n            });\n        };\n\n        var menu = new Ext.menu.Menu();\n        menu.add(new Ext.menu.Item({\n            text: t('edit_as_plain_text'),\n            iconCls: \"pimcore_icon_edit\",\n            handler: handler.bind(this, rowIndex, cellIndex, \"plain\")\n        }));\n\n\n        menu.add(new Ext.menu.Item({\n            text: t('edit_as_html'),\n            iconCls: \"pimcore_icon_edit\",\n            handler: handler.bind(this, rowIndex, cellIndex, \"html\")\n        }));\n\n        menu.showAt(e.pageX, e.pageY);\n    },\n\n    doMerge: function () {\n        pimcore.helpers.uploadDialog(this.uploadImportUrl, \"Filedata\", function (result) {\n            var data = result.response.responseText;\n            data = Ext.decode(data);\n\n            if(data && data.success == true) {\n                this.config = data.config;\n                this.showImportForm();\n            } else {\n                Ext.MessageBox.alert(t(\"error\"), t(\"error\"));\n            }\n        }.bind(this), function () {\n            Ext.MessageBox.alert(t(\"error\"), t(\"error\"));\n        });\n    },\n\n    refresh: function () {\n        this.store.reload();\n    },\n\n    showImportForm: function () {\n        this.csvSettingsPanel = new pimcore.object.helpers.import.csvSettingsTab(this.config, false, this);\n\n        var ImportForm = new Ext.form.FormPanel({\n            width: 500,\n            bodyStyle: 'padding: 10px;',\n            items: [{\n                    xtype: \"form\",\n                    bodyStyle: \"padding: 10px;\",\n                    defaults: {\n                        labelWidth: 250,\n                        width: 550\n                    },\n                    itemId: \"form\",\n                    items: [this.csvSettingsPanel.getPanel()],\n                    buttons: [{\n                        text: t(\"cancel\"),\n                        iconCls: \"pimcore_icon_cancel\",\n                        handler: function () {\n                            win.close();\n                        }\n                    },\n                    {\n                    text: t(\"import\"),\n                    iconCls: \"pimcore_icon_import\",\n                    handler: function () {\n                        if(ImportForm.isValid()) {\n                            this.csvSettingsPanel.commitData();\n                            var csvSettings = Ext.encode(this.config.csvSettings);\n                            ImportForm.getForm().submit({\n                                url: this.mergeUrl,\n                                params: {importFile: this.config.tmpFile, csvSettings: csvSettings},\n                                waitMsg: t(\"please_wait\"),\n                                success: function (el, response) {\n                                    try {\n                                        var data = response.response.responseText;\n                                        data = Ext.decode(data);\n                                        var merger = new pimcore.settings.translation.translationmerger(this.translationType, data, this);\n                                        this.refresh();\n                                        win.close();\n                                    } catch (e) {\n                                        Ext.MessageBox.alert(t(\"error\"), t(\"error\"));\n                                        win.close();\n                                    }\n                                }.bind(this),\n                                failure: function (el, res) {\n                                    Ext.MessageBox.alert(t(\"error\"), t(\"error\"));\n                                    win.close();\n                                }\n                            });\n                        }\n                    }.bind(this)\n                    }]\n                }]\n        });\n\n        var windowCfg = {\n            title: t(\"merge_csv\"),\n            width: 600,\n            layout: \"fit\",\n            closeAction: \"close\",\n            items: [ImportForm]\n        };\n\n        var win = new Ext.Window(windowCfg);\n\n        win.show();\n    },\n\n    doExport: function () {\n        var store = this.grid.store;\n        var storeFilters = store.getFilters().items;\n        var proxy = store.getProxy();\n\n        var filtersActive = this.filterField.getValue() || storeFilters.length > 0;\n        if (filtersActive) {\n            Ext.MessageBox.confirm(\"\", t(\"filter_active_message\"), function (buttonValue) {\n                if (buttonValue == \"yes\") {\n                    var queryString = \"searchString=\" + this.filterField.getValue();\n                    var encodedFilters = proxy.encodeFilters(storeFilters);\n                    queryString += \"&filter=\" + encodedFilters;\n                    pimcore.helpers.download(Ext.urlAppend(this.exportUrl, queryString));\n                } else {\n                    pimcore.helpers.download(this.exportUrl);\n                }\n            }.bind(this));\n        } else {\n            pimcore.helpers.download(this.exportUrl);\n        }\n    },\n\n    onAdd: function (btn, ev) {\n\n        Ext.MessageBox.prompt(\"\", t(\"please_enter_the_new_name\"), function (button, value) {\n            if (button == \"ok\") {\n                this.cellEditing.cancelEdit();\n\n                this.grid.store.insert(0, {\n                    key: value\n                });\n\n                this.cellEditing.startEditByPosition({\n                    row: 0,\n                    column: 1\n                });\n            }\n        }.bind(this));\n    },\n\n    cleanup: function () {\n        Ext.Ajax.request({\n            url: this.cleanupUrl,\n            method: 'DELETE',\n            success: function (response) {\n                this.store.reload();\n            }.bind(this)\n        });\n    },\n\n    getCellEditor: function(language, record) {\n\n        var editor;\n\n        if (!record.data.editor) {\n            editor = this.editableLanguages.indexOf(language) >= 0 ? new Ext.form.TextField({}) : null;\n        } else {\n            editor = new pimcore.settings.translationEditor({\n                __editorType: record.data.editor,\n                __outerTitle: record.data.editor == \"plain\" ? t(\"edit_as_plain_text\") : t(\"edit_as_html\"),\n                __innerTitle: record.data.key\n            });\n\n        }\n\n        return editor;\n    }\n\n});\n"], "filenames": ["bundles/AdminBundle/Resources/public/js/pimcore/settings/translations.js"], "buggy_code_start_loc": [104], "buggy_code_end_loc": [104], "fixing_code_start_loc": [105], "fixing_code_end_loc": [108], "type": "CWE-79", "message": "Pimcore 6.2.3 has XSS in the translations grid because bundles/AdminBundle/Resources/public/js/pimcore/settings/translations.js mishandles certain HTML elements.", "other": {"cve": {"id": "CVE-2019-18656", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-31T17:15:10.570", "lastModified": "2019-11-01T12:31:36.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Pimcore 6.2.3 has XSS in the translations grid because bundles/AdminBundle/Resources/public/js/pimcore/settings/translations.js mishandles certain HTML elements."}, {"lang": "es", "value": "Pimcore versi\u00f3n 6.2.3, presenta una vulnerabilidad de tipo XSS en la cuadr\u00edcula de traducciones porque el archivo bundles/AdminBundle/Resources/public/js/pimcore/settings/translations.js maneja inapropiadamente ciertos elementos HTML."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:6.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "890E0C99-9414-4C09-B6DE-5DAE1883859A"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/ca036e9f86bb5cdb3dac0930ec131e5f35e26c5f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/ca036e9f86bb5cdb3dac0930ec131e5f35e26c5f"}}