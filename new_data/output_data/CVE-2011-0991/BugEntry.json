{"buggy_code": ["//\n// System.Reflection.Emit.DynamicMethod.cs\n//\n// Author:\n//   Paolo Molaro (lupus@ximian.com)\n//   Zoltan Varga (vargaz@freemail.hu)\n//\n// (C) 2003 Ximian, Inc.  http://www.ximian.com\n//\n\n//\n// Copyright (C) 2004 Novell, Inc (http://www.novell.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n// \n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n#if NET_2_0 || BOOTSTRAP_NET_2_0\n\nusing System;\nusing System.Reflection;\nusing System.Reflection.Emit;\nusing System.Globalization;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\nnamespace System.Reflection.Emit {\n\n#if NET_2_0\n\t[ComVisible (true)]\n#endif\n\tpublic sealed class DynamicMethod : MethodInfo {\n\n#pragma warning disable 169, 414\n\t\t#region Sync with reflection.h\n\t\tprivate RuntimeMethodHandle mhandle;\n\t\tprivate string name;\n\t\tprivate Type returnType;\n\t\tprivate Type[] parameters;\n\t\tprivate MethodAttributes attributes;\n\t\tprivate CallingConventions callingConvention;\n\t\tprivate Module module;\n\t\tprivate bool skipVisibility;\n\t\tprivate bool init_locals = true;\n\t\tprivate ILGenerator ilgen;\n\t\tprivate int nrefs;\n\t\tprivate object[] refs;\n\t\tprivate IntPtr referenced_by;\n\t\tprivate Type owner;\n\t\t#endregion\n#pragma warning restore 169, 414\n\t\t\n\t\tprivate Delegate deleg;\n\t\tprivate MonoMethod method;\n\t\tprivate ParameterBuilder[] pinfo;\n\t\tinternal bool creating;\n\n\t\tpublic DynamicMethod (string name, Type returnType, Type[] parameterTypes, Module m) : this (name, returnType, parameterTypes, m, false) {\n\t\t}\n\n\t\tpublic DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner) : this (name, returnType, parameterTypes, owner, false) {\n\t\t}\n\n\t\tpublic DynamicMethod (string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility) : this (name, MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, returnType, parameterTypes, m, skipVisibility) {\n\t\t}\n\n\t\tpublic DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility) : this (name, MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, returnType, parameterTypes, owner, skipVisibility) {\n\t\t}\n\n\t\tpublic DynamicMethod (string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility) : this (name, attributes, callingConvention, returnType, parameterTypes, owner, owner.Module, skipVisibility, false) {\n\t\t}\n\n\t\tpublic DynamicMethod (string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility) : this (name, attributes, callingConvention, returnType, parameterTypes, null, m, skipVisibility, false) {\n\t\t}\n\n\t\tpublic DynamicMethod (string name, Type returnType, Type[] parameterTypes) : this (name, returnType, parameterTypes, false) {\n\t\t}\n\n\t\t[MonoTODO (\"Visibility is not restricted\")]\n\t\tpublic DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility)\n\t\t\t: this (name, MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, returnType, parameterTypes, null, null, restrictedSkipVisibility, true)\n\t\t{\n\t\t}\n\n\t\tDynamicMethod (string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type [] parameterTypes, Type owner, Module m, bool skipVisibility, bool anonHosted)\n\t\t{\n\t\t\tif (name == null)\n\t\t\t\tthrow new ArgumentNullException (\"name\");\n\t\t\tif (returnType == null)\n\t\t\t\treturnType = typeof (void);\n\t\t\tif ((m == null) && !anonHosted)\n\t\t\t\tthrow new ArgumentNullException (\"m\");\n\t\t\tif (returnType.IsByRef)\n\t\t\t\tthrow new ArgumentException (\"Return type can't be a byref type\", \"returnType\");\n\t\t\tif (parameterTypes != null) {\n\t\t\t\tfor (int i = 0; i < parameterTypes.Length; ++i)\n\t\t\t\t\tif (parameterTypes [i] == null)\n\t\t\t\t\t\tthrow new ArgumentException (\"Parameter \" + i + \" is null\", \"parameterTypes\");\n\t\t\t}\n\n\t\t\tif (m == null)\n\t\t\t\tm = AnonHostModuleHolder.anon_host_module;\n\n\t\t\tthis.name = name;\n\t\t\tthis.attributes = attributes | MethodAttributes.Static;\n\t\t\tthis.callingConvention = callingConvention;\n\t\t\tthis.returnType = returnType;\n\t\t\tthis.parameters = parameterTypes;\n\t\t\tthis.owner = owner;\n\t\t\tthis.module = m;\n\t\t\tthis.skipVisibility = skipVisibility;\n\t\t}\n\n\t\t[MethodImplAttribute(MethodImplOptions.InternalCall)]\n\t\tprivate extern void create_dynamic_method (DynamicMethod m);\n\n\t\t[MethodImplAttribute(MethodImplOptions.InternalCall)]\n\t\tprivate extern void destroy_dynamic_method (DynamicMethod m);\n\n\t\tprivate void CreateDynMethod () {\n\t\t\tif (mhandle.Value == IntPtr.Zero) {\n\t\t\t\tif (ilgen == null || (ILGenerator.Mono_GetCurrentOffset (ilgen) == 0))\n\t\t\t\t\tthrow new InvalidOperationException (\"Method '\" + name + \"' does not have a method body.\");\n\n\t\t\t\tilgen.label_fixup ();\n\n\t\t\t\t// Have to create all DynamicMethods referenced by this one\n\t\t\t\ttry {\n\t\t\t\t\t// Used to avoid cycles\n\t\t\t\t\tcreating = true;\n\t\t\t\t\tif (refs != null) {\n\t\t\t\t\t\tfor (int i = 0; i < refs.Length; ++i) {\n\t\t\t\t\t\t\tif (refs [i] is DynamicMethod) {\n\t\t\t\t\t\t\t\tDynamicMethod m = (DynamicMethod)refs [i];\n\t\t\t\t\t\t\t\tif (!m.creating)\n\t\t\t\t\t\t\t\t\tm.CreateDynMethod ();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tcreating = false;\n\t\t\t\t}\n\n\t\t\t\tcreate_dynamic_method (this);\n\t\t\t}\n\t\t}\n\n\t\t~DynamicMethod ()\n\t\t{\n\t\t\tdestroy_dynamic_method (this);\n\t\t}\n\n\t\t[ComVisible (true)]\n\t\tpublic Delegate CreateDelegate (Type delegateType)\n\t\t{\n\t\t\tif (delegateType == null)\n\t\t\t\tthrow new ArgumentNullException (\"delegateType\");\n\t\t\tif (deleg != null)\n\t\t\t\treturn deleg;\n\n\t\t\tCreateDynMethod ();\n\n\t\t\tdeleg = Delegate.CreateDelegate (delegateType, this);\n\t\t\treturn deleg;\n\t\t}\n\n\t\t[ComVisible (true)]\n\t\tpublic Delegate CreateDelegate (Type delegateType, object target)\n\t\t{\n\t\t\tif (delegateType == null)\n\t\t\t\tthrow new ArgumentNullException (\"delegateType\");\n\n\t\t\tCreateDynMethod ();\n\n\t\t\t/* Can't cache the delegate since it is different for each target */\n\t\t\treturn Delegate.CreateDelegate (delegateType, target, this);\n\t\t}\n\t\t\n\t\tpublic ParameterBuilder DefineParameter (int position, ParameterAttributes attributes, string parameterName)\n\t\t{\n\t\t\t//\n\t\t\t// Extension: Mono allows position == 0 for the return attribute\n\t\t\t//\n\t\t\tif ((position < 0) || (position > parameters.Length))\n\t\t\t\tthrow new ArgumentOutOfRangeException (\"position\");\n\n\t\t\tRejectIfCreated ();\n\n\t\t\tParameterBuilder pb = new ParameterBuilder (this, position, attributes, parameterName);\n\t\t\tif (pinfo == null)\n\t\t\t\tpinfo = new ParameterBuilder [parameters.Length + 1];\n\t\t\tpinfo [position] = pb;\n\t\t\treturn pb;\n\t\t}\n\n\t\tpublic override MethodInfo GetBaseDefinition () {\n\t\t\treturn this;\n\t\t}\n\n\t\t[MonoTODO(\"Not implemented\")]\n\t\tpublic override object[] GetCustomAttributes (bool inherit) {\n\t\t\tthrow new NotImplementedException ();\n\t\t}\n\n\t\t[MonoTODO(\"Not implemented\")]\n\t\tpublic override object[] GetCustomAttributes (Type attributeType,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  bool inherit) {\n\t\t\tthrow new NotImplementedException ();\n\t\t}\n\n\t\t[MonoTODO(\"Not implemented\")]\n\t\tpublic DynamicILInfo GetDynamicILInfo () {\n\t\t\tthrow new NotImplementedException ();\n\t\t}\n\n\t\tpublic ILGenerator GetILGenerator () {\n\t\t\treturn GetILGenerator (64);\n\t\t}\n\n\t\tpublic ILGenerator GetILGenerator (int streamSize) {\n\t\t\tif (((GetMethodImplementationFlags () & MethodImplAttributes.CodeTypeMask) != \n\t\t\t\t MethodImplAttributes.IL) ||\n\t\t\t\t((GetMethodImplementationFlags () & MethodImplAttributes.ManagedMask) != \n\t\t\t\t MethodImplAttributes.Managed))\n\t\t\t\tthrow new InvalidOperationException (\"Method body should not exist.\");\n\t\t\tif (ilgen != null)\n\t\t\t\treturn ilgen;\n\t\t\tilgen = new ILGenerator (Module, new DynamicMethodTokenGenerator (this), streamSize);\n\t\t\treturn ilgen;\n\t\t}\t\t\n\n\t\tpublic override MethodImplAttributes GetMethodImplementationFlags () {\n\t\t\treturn MethodImplAttributes.IL | MethodImplAttributes.Managed;\n\t\t}\n\n\t\tpublic override ParameterInfo[] GetParameters () {\n\t\t\tif (parameters == null)\n\t\t\t\treturn new ParameterInfo [0];\n\n\t\t\tParameterInfo[] retval = new ParameterInfo [parameters.Length];\n\t\t\tfor (int i = 0; i < parameters.Length; i++) {\n\t\t\t\tretval [i] = new ParameterInfo (pinfo == null ? null : pinfo [i + 1], parameters [i], this, i + 1);\n\t\t\t}\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\tpublic override object Invoke (object obj, object[] parameters) {\n\t\t\tCreateDynMethod ();\n\t\t\tif (method == null)\n\t\t\t\tmethod = new MonoMethod (mhandle);\n\t\t\treturn method.Invoke (obj, parameters);\n\t\t}\n\t\t*/\n\n\t\tpublic override object Invoke (object obj, BindingFlags invokeAttr,\n\t\t\t\t\t\t\t\t\t   Binder binder, object[] parameters,\n\t\t\t\t\t\t\t\t\t   CultureInfo culture)\n\t\t{\n\t\t\ttry {\n\t\t\t\tCreateDynMethod ();\n\t\t\t\tif (method == null)\n\t\t\t\t\tmethod = new MonoMethod (mhandle);\n\n\t\t\t\treturn method.Invoke (obj, parameters);\n\t\t\t}\n\t\t\tcatch (MethodAccessException mae) {\n\t\t\t\tthrow new TargetInvocationException (\"Method cannot be invoked.\", mae);\n\t\t\t}\n\t\t}\n\n\t\t[MonoTODO(\"Not implemented\")]\n\t\tpublic override bool IsDefined (Type attributeType, bool inherit) {\n\t\t\tthrow new NotImplementedException ();\n\t\t}\n\n\t\tpublic override string ToString () {\n\t\t\tstring parms = String.Empty;\n\t\t\tParameterInfo[] p = GetParameters ();\n\t\t\tfor (int i = 0; i < p.Length; ++i) {\n\t\t\t\tif (i > 0)\n\t\t\t\t\tparms = parms + \", \";\n\t\t\t\tparms = parms + p [i].ParameterType.Name;\n\t\t\t}\n\t\t\treturn ReturnType.Name+\" \"+Name+\"(\"+parms+\")\";\n\t\t}\n\n\t\tpublic override MethodAttributes Attributes {\n\t\t\tget {\n\t\t\t\treturn attributes;\n\t\t\t}\n\t\t}\n\n\t\tpublic override CallingConventions CallingConvention {\n\t\t\tget {\n\t\t\t\treturn callingConvention;\n\t\t\t}\n\t\t}\n\n\t\tpublic override Type DeclaringType {\n\t\t\tget {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tpublic bool InitLocals {\n\t\t\tget {\n\t\t\t\treturn init_locals;\n\t\t\t}\n\t\t\tset {\n\t\t\t\tinit_locals = value;\n\t\t\t}\n\t\t}\n\n\t\tpublic override RuntimeMethodHandle MethodHandle {\n\t\t\tget {\n\t\t\t\treturn mhandle;\n\t\t\t}\n\t\t}\n\n\t\tpublic override Module Module {\n\t\t\tget {\n\t\t\t\treturn module;\n\t\t\t}\n\t\t}\n\n\t\tpublic override string Name {\n\t\t\tget {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\n\t\tpublic override Type ReflectedType {\n\t\t\tget {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t[MonoTODO(\"Not implemented\")]\n\t\tpublic override ParameterInfo ReturnParameter {\n\t\t\tget {\n\t\t\t\tthrow new NotImplementedException ();\n\t\t\t}\n\t\t}\n\n\t\tpublic override Type ReturnType {\n\t\t\tget {\n\t\t\t\treturn returnType;\n\t\t\t}\n\t\t}\n\n\t\t[MonoTODO(\"Not implemented\")]\n\t\tpublic override ICustomAttributeProvider ReturnTypeCustomAttributes {\n\t\t\tget {\n\t\t\t\tthrow new NotImplementedException ();\n\t\t\t}\n\t\t}\n\n/*\n\t\tpublic override int MetadataToken {\n\t\t\tget {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n*/\n\n\t\tprivate void RejectIfCreated () {\n\t\t\tif (mhandle.Value != IntPtr.Zero)\n\t\t\t\tthrow new InvalidOperationException (\"Type definition of the method is complete.\");\n\t\t}\n\n\t\tinternal int AddRef (object reference) {\n\t\t\tif (refs == null)\n\t\t\t\trefs = new object [4];\n\t\t\tif (nrefs >= refs.Length - 1) {\n\t\t\t\tobject [] new_refs = new object [refs.Length * 2];\n\t\t\t\tSystem.Array.Copy (refs, new_refs, refs.Length);\n\t\t\t\trefs = new_refs;\n\t\t\t}\n\t\t\trefs [nrefs] = reference;\n\t\t\t/* Reserved by the runtime */\n\t\t\trefs [nrefs + 1] = null;\n\t\t\tnrefs += 2;\n\t\t\treturn nrefs - 1;\n\t\t}\n\n\t\t// This class takes care of constructing the module in a thread safe manner\n\t\tclass AnonHostModuleHolder {\n\t\t\tpublic static Module anon_host_module;\n\n\t\t\tstatic AnonHostModuleHolder () {\n\t\t\t\tAssemblyName aname = new AssemblyName ();\n\t\t\t\taname.Name = \"Anonymously Hosted DynamicMethods Assembly\";\n\t\t\t\tAssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly (aname, AssemblyBuilderAccess.Run);\n\n\t\t\t\tanon_host_module = ab.GetManifestModule ();\n\t\t\t}\n\t\t}\n\t}\n\n\tinternal class DynamicMethodTokenGenerator : TokenGenerator {\n\n\t\tprivate DynamicMethod m;\n\n\t\tpublic DynamicMethodTokenGenerator (DynamicMethod m) {\n\t\t\tthis.m = m;\n\t\t}\n\n\t\tpublic int GetToken (string str) {\n\t\t\treturn m.AddRef (str);\n\t\t}\n\n\t\tpublic int GetToken (MethodInfo method, Type[] opt_param_types) {\n\t\t\tthrow new InvalidOperationException ();\n\t\t}\n\n\t\tpublic int GetToken (MemberInfo member) {\n\t\t\treturn m.AddRef (member);\n\t\t}\n\n\t\tpublic int GetToken (SignatureHelper helper) {\n\t\t\treturn m.AddRef (helper);\n\t\t}\n\t}\n}\n\n#endif\n", "/*\n * This file contains the default set of the mono internal calls.\n * Each type that has internal call methods must be declared here\n * with the ICALL_TYPE macro as follows:\n *\n * \tICALL_TYPE(typeid, typename, first_icall_id)\n *\n * typeid must be a C symbol name unique to the type, don't worry about namespace\n * \tpollution, since it will be automatically prefixed to avoid it.\n * typename is a C string containing the full name of the type\n * first_icall_id s the symbol ID of the first internal call of the declared\n * \ttype (see below)\n *\n * The list of internal calls of the methods of a type must follow the\n * type declaration. Each internal call is defined by the following macro:\n *\n * \tICALL(icallid, methodname, cfuncptr)\n *\n * icallid must be a C symbol, unique for each icall defined in this file and\n * tipically equal to the typeid + '_' + a sequential number.\n * methodname is a C string defining the method name and the optional signature\n * (the signature is required only when several internal calls in the type\n * have the same name)\n * cfuncptr is the C function that implements the internal call. Note that this\n * file is included at the end of metadata/icall.c, so the C function must be\n * visible to the compiler there.\n *\n * *** Adding a new internal call ***\n * Remember that ICALL_TYPE declarations must be kept sorted wrt each other\n * ICALL_TYPE declaration. The same happens for ICALL declarations, but only\n * limited to the icall list of each type. The sorting is based on the type or\n * method name.\n * When adding a new icall, make sure it is inserted correctly in the list and\n * that it defines a unique ID. ID are currently numbered and ordered, but if\n * you need to insert a method in the middle, don't bother renaming all the symbols.\n * Remember to change also the first_icall_id argument in the ICALL_TYPE \n * declaration if you add a new icall at the beginning of a type's icall list.\n */\nICALL_TYPE(UNORM, \"Mono.Globalization.Unicode.Normalization\", UNORM_1)\nICALL(UNORM_1, \"load_normalization_resource\", load_normalization_resource)\n\n#ifndef DISABLE_COM\nICALL_TYPE(COMPROX, \"Mono.Interop.ComInteropProxy\", COMPROX_1)\nICALL(COMPROX_1, \"AddProxy\", ves_icall_Mono_Interop_ComInteropProxy_AddProxy)\nICALL(COMPROX_2, \"FindProxy\", ves_icall_Mono_Interop_ComInteropProxy_FindProxy)\n#endif\n\nICALL_TYPE(RUNTIME, \"Mono.Runtime\", RUNTIME_1)\nICALL(RUNTIME_1, \"GetDisplayName\", ves_icall_Mono_Runtime_GetDisplayName)\n\n#ifndef PLATFORM_RO_FS\nICALL_TYPE(KPAIR, \"Mono.Security.Cryptography.KeyPairPersistence\", KPAIR_1)\nICALL(KPAIR_1, \"_CanSecure\", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_CanSecure)\nICALL(KPAIR_2, \"_IsMachineProtected\", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_IsMachineProtected)\nICALL(KPAIR_3, \"_IsUserProtected\", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_IsUserProtected)\nICALL(KPAIR_4, \"_ProtectMachine\", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_ProtectMachine)\nICALL(KPAIR_5, \"_ProtectUser\", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_ProtectUser)\n#endif /* !PLATFORM_RO_FS */\n\nICALL_TYPE(ACTIV, \"System.Activator\", ACTIV_1)\nICALL(ACTIV_1, \"CreateInstanceInternal\", ves_icall_System_Activator_CreateInstanceInternal)\n\nICALL_TYPE(APPDOM, \"System.AppDomain\", APPDOM_1)\nICALL(APPDOM_1, \"ExecuteAssembly\", ves_icall_System_AppDomain_ExecuteAssembly)\nICALL(APPDOM_2, \"GetAssemblies\", ves_icall_System_AppDomain_GetAssemblies)\nICALL(APPDOM_3, \"GetData\", ves_icall_System_AppDomain_GetData)\nICALL(APPDOM_4, \"InternalGetContext\", ves_icall_System_AppDomain_InternalGetContext)\nICALL(APPDOM_5, \"InternalGetDefaultContext\", ves_icall_System_AppDomain_InternalGetDefaultContext)\nICALL(APPDOM_6, \"InternalGetProcessGuid\", ves_icall_System_AppDomain_InternalGetProcessGuid)\nICALL(APPDOM_7, \"InternalIsFinalizingForUnload\", ves_icall_System_AppDomain_InternalIsFinalizingForUnload)\nICALL(APPDOM_8, \"InternalPopDomainRef\", ves_icall_System_AppDomain_InternalPopDomainRef)\nICALL(APPDOM_9, \"InternalPushDomainRef\", ves_icall_System_AppDomain_InternalPushDomainRef)\nICALL(APPDOM_10, \"InternalPushDomainRefByID\", ves_icall_System_AppDomain_InternalPushDomainRefByID)\nICALL(APPDOM_11, \"InternalSetContext\", ves_icall_System_AppDomain_InternalSetContext)\nICALL(APPDOM_12, \"InternalSetDomain\", ves_icall_System_AppDomain_InternalSetDomain)\nICALL(APPDOM_13, \"InternalSetDomainByID\", ves_icall_System_AppDomain_InternalSetDomainByID)\nICALL(APPDOM_14, \"InternalUnload\", ves_icall_System_AppDomain_InternalUnload)\nICALL(APPDOM_15, \"LoadAssembly\", ves_icall_System_AppDomain_LoadAssembly)\nICALL(APPDOM_16, \"LoadAssemblyRaw\", ves_icall_System_AppDomain_LoadAssemblyRaw)\nICALL(APPDOM_17, \"SetData\", ves_icall_System_AppDomain_SetData)\nICALL(APPDOM_18, \"createDomain\", ves_icall_System_AppDomain_createDomain)\nICALL(APPDOM_19, \"getCurDomain\", ves_icall_System_AppDomain_getCurDomain)\nICALL(APPDOM_20, \"getFriendlyName\", ves_icall_System_AppDomain_getFriendlyName)\nICALL(APPDOM_21, \"getRootDomain\", ves_icall_System_AppDomain_getRootDomain)\nICALL(APPDOM_22, \"getSetup\", ves_icall_System_AppDomain_getSetup)\n\nICALL_TYPE(ARGI, \"System.ArgIterator\", ARGI_1)\nICALL(ARGI_1, \"IntGetNextArg()\",                  mono_ArgIterator_IntGetNextArg)\nICALL(ARGI_2, \"IntGetNextArg(intptr)\", mono_ArgIterator_IntGetNextArgT)\nICALL(ARGI_3, \"IntGetNextArgType\",                mono_ArgIterator_IntGetNextArgType)\nICALL(ARGI_4, \"Setup\",                            mono_ArgIterator_Setup)\n\nICALL_TYPE(ARRAY, \"System.Array\", ARRAY_1)\nICALL(ARRAY_1, \"ClearInternal\",    ves_icall_System_Array_ClearInternal)\nICALL(ARRAY_2, \"Clone\",            mono_array_clone)\nICALL(ARRAY_3, \"CreateInstanceImpl\",   ves_icall_System_Array_CreateInstanceImpl)\nICALL(ARRAY_14, \"CreateInstanceImpl64\",   ves_icall_System_Array_CreateInstanceImpl64)\nICALL(ARRAY_4, \"FastCopy\",         ves_icall_System_Array_FastCopy)\nICALL(ARRAY_5, \"GetGenericValueImpl\", ves_icall_System_Array_GetGenericValueImpl)\nICALL(ARRAY_6, \"GetLength\",        ves_icall_System_Array_GetLength)\nICALL(ARRAY_15, \"GetLongLength\",        ves_icall_System_Array_GetLongLength)\nICALL(ARRAY_7, \"GetLowerBound\",    ves_icall_System_Array_GetLowerBound)\nICALL(ARRAY_8, \"GetRank\",          ves_icall_System_Array_GetRank)\nICALL(ARRAY_9, \"GetValue\",         ves_icall_System_Array_GetValue)\nICALL(ARRAY_10, \"GetValueImpl\",     ves_icall_System_Array_GetValueImpl)\nICALL(ARRAY_11, \"SetGenericValueImpl\", ves_icall_System_Array_SetGenericValueImpl)\nICALL(ARRAY_12, \"SetValue\",         ves_icall_System_Array_SetValue)\nICALL(ARRAY_13, \"SetValueImpl\",     ves_icall_System_Array_SetValueImpl)\n\nICALL_TYPE(BUFFER, \"System.Buffer\", BUFFER_1)\nICALL(BUFFER_1, \"BlockCopyInternal\", ves_icall_System_Buffer_BlockCopyInternal)\nICALL(BUFFER_2, \"ByteLengthInternal\", ves_icall_System_Buffer_ByteLengthInternal)\nICALL(BUFFER_3, \"GetByteInternal\", ves_icall_System_Buffer_GetByteInternal)\nICALL(BUFFER_4, \"SetByteInternal\", ves_icall_System_Buffer_SetByteInternal)\n\nICALL_TYPE(CHAR, \"System.Char\", CHAR_1)\nICALL(CHAR_1, \"GetDataTablePointers\", ves_icall_System_Char_GetDataTablePointers)\n\nICALL_TYPE (COMPO_W, \"System.ComponentModel.Win32Exception\", COMPO_W_1)\nICALL (COMPO_W_1, \"W32ErrorMessage\", ves_icall_System_ComponentModel_Win32Exception_W32ErrorMessage)\n\nICALL_TYPE(DEFAULTC, \"System.Configuration.DefaultConfig\", DEFAULTC_1)\nICALL(DEFAULTC_1, \"get_bundled_machine_config\", get_bundled_machine_config)\nICALL(DEFAULTC_2, \"get_machine_config_path\", ves_icall_System_Configuration_DefaultConfig_get_machine_config_path)\n\n/* Note that the below icall shares the same function as DefaultConfig uses */\nICALL_TYPE(INTCFGHOST, \"System.Configuration.InternalConfigurationHost\", INTCFGHOST_1)\nICALL(INTCFGHOST_1, \"get_bundled_machine_config\", get_bundled_machine_config)\n\nICALL_TYPE(CONSOLE, \"System.ConsoleDriver\", CONSOLE_1)\nICALL(CONSOLE_1, \"InternalKeyAvailable\", ves_icall_System_ConsoleDriver_InternalKeyAvailable )\nICALL(CONSOLE_2, \"Isatty\", ves_icall_System_ConsoleDriver_Isatty )\nICALL(CONSOLE_3, \"SetBreak\", ves_icall_System_ConsoleDriver_SetBreak )\nICALL(CONSOLE_4, \"SetEcho\", ves_icall_System_ConsoleDriver_SetEcho )\nICALL(CONSOLE_5, \"TtySetup\", ves_icall_System_ConsoleDriver_TtySetup )\n\nICALL_TYPE(CONVERT, \"System.Convert\", CONVERT_1)\nICALL(CONVERT_1, \"InternalFromBase64CharArray\", InternalFromBase64CharArray )\nICALL(CONVERT_2, \"InternalFromBase64String\", InternalFromBase64String )\n\nICALL_TYPE(TZONE, \"System.CurrentSystemTimeZone\", TZONE_1)\nICALL(TZONE_1, \"GetTimeZoneData\", ves_icall_System_CurrentSystemTimeZone_GetTimeZoneData)\n\nICALL_TYPE(DTIME, \"System.DateTime\", DTIME_1)\nICALL(DTIME_1, \"GetNow\", mono_100ns_datetime)\nICALL(DTIME_2, \"GetTimeMonotonic\", mono_100ns_ticks)\n\n#ifndef DISABLE_DECIMAL\nICALL_TYPE(DECIMAL, \"System.Decimal\", DECIMAL_1)\nICALL(DECIMAL_1, \"decimal2Int64\", mono_decimal2Int64)\nICALL(DECIMAL_2, \"decimal2UInt64\", mono_decimal2UInt64)\nICALL(DECIMAL_3, \"decimal2double\", mono_decimal2double)\nICALL(DECIMAL_4, \"decimal2string\", mono_decimal2string)\nICALL(DECIMAL_5, \"decimalCompare\", mono_decimalCompare)\nICALL(DECIMAL_6, \"decimalDiv\", mono_decimalDiv)\nICALL(DECIMAL_7, \"decimalFloorAndTrunc\", mono_decimalFloorAndTrunc)\nICALL(DECIMAL_8, \"decimalIncr\", mono_decimalIncr)\nICALL(DECIMAL_9, \"decimalIntDiv\", mono_decimalIntDiv)\nICALL(DECIMAL_10, \"decimalMult\", mono_decimalMult)\nICALL(DECIMAL_11, \"decimalRound\", mono_decimalRound)\nICALL(DECIMAL_12, \"decimalSetExponent\", mono_decimalSetExponent)\nICALL(DECIMAL_13, \"double2decimal\", mono_double2decimal) /* FIXME: wrong signature. */\nICALL(DECIMAL_14, \"string2decimal\", mono_string2decimal)\n#endif\n\nICALL_TYPE(DELEGATE, \"System.Delegate\", DELEGATE_1)\nICALL(DELEGATE_1, \"CreateDelegate_internal\", ves_icall_System_Delegate_CreateDelegate_internal)\nICALL(DELEGATE_2, \"SetMulticastInvoke\", ves_icall_System_Delegate_SetMulticastInvoke)\n\nICALL_TYPE(DEBUGR, \"System.Diagnostics.Debugger\", DEBUGR_1)\nICALL(DEBUGR_1, \"IsAttached_internal\", ves_icall_System_Diagnostics_Debugger_IsAttached_internal)\n\nICALL_TYPE(TRACEL, \"System.Diagnostics.DefaultTraceListener\", TRACEL_1)\nICALL(TRACEL_1, \"WriteWindowsDebugString\", ves_icall_System_Diagnostics_DefaultTraceListener_WriteWindowsDebugString)\n\n#ifndef DISABLE_PROCESS_HANDLING\nICALL_TYPE(FILEV, \"System.Diagnostics.FileVersionInfo\", FILEV_1)\nICALL(FILEV_1, \"GetVersionInfo_internal(string)\", ves_icall_System_Diagnostics_FileVersionInfo_GetVersionInfo_internal)\n\nICALL_TYPE(PERFCTR, \"System.Diagnostics.PerformanceCounter\", PERFCTR_1)\nICALL(PERFCTR_1, \"FreeData\", mono_perfcounter_free_data)\nICALL(PERFCTR_2, \"GetImpl\", mono_perfcounter_get_impl)\nICALL(PERFCTR_3, \"GetSample\", mono_perfcounter_get_sample)\nICALL(PERFCTR_4, \"UpdateValue\", mono_perfcounter_update_value)\n\nICALL_TYPE(PERFCTRCAT, \"System.Diagnostics.PerformanceCounterCategory\", PERFCTRCAT_1)\nICALL(PERFCTRCAT_1, \"CategoryDelete\", mono_perfcounter_category_del)\nICALL(PERFCTRCAT_2, \"CategoryHelpInternal\",   mono_perfcounter_category_help)\nICALL(PERFCTRCAT_3, \"CounterCategoryExists\", mono_perfcounter_category_exists)\nICALL(PERFCTRCAT_4, \"Create\",         mono_perfcounter_create)\nICALL(PERFCTRCAT_5, \"GetCategoryNames\", mono_perfcounter_category_names)\nICALL(PERFCTRCAT_6, \"GetCounterNames\", mono_perfcounter_counter_names)\nICALL(PERFCTRCAT_7, \"GetInstanceNames\", mono_perfcounter_instance_names)\nICALL(PERFCTRCAT_8, \"InstanceExistsInternal\", mono_perfcounter_instance_exists)\n\nICALL_TYPE(PROCESS, \"System.Diagnostics.Process\", PROCESS_1)\nICALL(PROCESS_1, \"CreateProcess_internal(System.Diagnostics.ProcessStartInfo,intptr,intptr,intptr,System.Diagnostics.Process/ProcInfo&)\", ves_icall_System_Diagnostics_Process_CreateProcess_internal)\nICALL(PROCESS_2, \"ExitCode_internal(intptr)\", ves_icall_System_Diagnostics_Process_ExitCode_internal)\nICALL(PROCESS_3, \"ExitTime_internal(intptr)\", ves_icall_System_Diagnostics_Process_ExitTime_internal)\nICALL(PROCESS_4, \"GetModules_internal(intptr)\", ves_icall_System_Diagnostics_Process_GetModules_internal)\nICALL(PROCESS_5, \"GetPid_internal()\", ves_icall_System_Diagnostics_Process_GetPid_internal)\nICALL(PROCESS_5B, \"GetPriorityClass(intptr,int&)\", ves_icall_System_Diagnostics_Process_GetPriorityClass)\nICALL(PROCESS_5H, \"GetProcessData\", ves_icall_System_Diagnostics_Process_GetProcessData)\nICALL(PROCESS_6, \"GetProcess_internal(int)\", ves_icall_System_Diagnostics_Process_GetProcess_internal)\nICALL(PROCESS_7, \"GetProcesses_internal()\", ves_icall_System_Diagnostics_Process_GetProcesses_internal)\nICALL(PROCESS_8, \"GetWorkingSet_internal(intptr,int&,int&)\", ves_icall_System_Diagnostics_Process_GetWorkingSet_internal)\nICALL(PROCESS_9, \"Kill_internal\", ves_icall_System_Diagnostics_Process_Kill_internal)\nICALL(PROCESS_10, \"ProcessName_internal(intptr)\", ves_icall_System_Diagnostics_Process_ProcessName_internal)\nICALL(PROCESS_11, \"Process_free_internal(intptr)\", ves_icall_System_Diagnostics_Process_Process_free_internal)\nICALL(PROCESS_11B, \"SetPriorityClass(intptr,int,int&)\", ves_icall_System_Diagnostics_Process_SetPriorityClass)\nICALL(PROCESS_12, \"SetWorkingSet_internal(intptr,int,int,bool)\", ves_icall_System_Diagnostics_Process_SetWorkingSet_internal)\nICALL(PROCESS_13, \"ShellExecuteEx_internal(System.Diagnostics.ProcessStartInfo,System.Diagnostics.Process/ProcInfo&)\", ves_icall_System_Diagnostics_Process_ShellExecuteEx_internal)\nICALL(PROCESS_14, \"StartTime_internal(intptr)\", ves_icall_System_Diagnostics_Process_StartTime_internal)\nICALL(PROCESS_14M, \"Times\", ves_icall_System_Diagnostics_Process_Times)\nICALL(PROCESS_15, \"WaitForExit_internal(intptr,int)\", ves_icall_System_Diagnostics_Process_WaitForExit_internal)\nICALL(PROCESS_16, \"WaitForInputIdle_internal(intptr,int)\", ves_icall_System_Diagnostics_Process_WaitForInputIdle_internal)\n\nICALL_TYPE (PROCESSHANDLE, \"System.Diagnostics.Process/ProcessWaitHandle\", PROCESSHANDLE_1)\nICALL (PROCESSHANDLE_1, \"ProcessHandle_close(intptr)\", ves_icall_System_Diagnostics_Process_ProcessHandle_close)\nICALL (PROCESSHANDLE_2, \"ProcessHandle_duplicate(intptr)\", ves_icall_System_Diagnostics_Process_ProcessHandle_duplicate)\n#endif /* !DISABLE_PROCESS_HANDLING */\n\nICALL_TYPE(STOPWATCH, \"System.Diagnostics.Stopwatch\", STOPWATCH_1)\nICALL(STOPWATCH_1, \"GetTimestamp\", mono_100ns_ticks)\n\nICALL_TYPE(DOUBLE, \"System.Double\", DOUBLE_1)\nICALL(DOUBLE_1, \"ParseImpl\",    mono_double_ParseImpl)\n\nICALL_TYPE(ENUM, \"System.Enum\", ENUM_1)\nICALL(ENUM_1, \"ToObject\", ves_icall_System_Enum_ToObject)\nICALL(ENUM_5, \"compare_value_to\", ves_icall_System_Enum_compare_value_to)\nICALL(ENUM_4, \"get_hashcode\", ves_icall_System_Enum_get_hashcode)\nICALL(ENUM_3, \"get_underlying_type\", ves_icall_System_Enum_get_underlying_type)\nICALL(ENUM_2, \"get_value\", ves_icall_System_Enum_get_value)\n\nICALL_TYPE(ENV, \"System.Environment\", ENV_1)\nICALL(ENV_1, \"Exit\", ves_icall_System_Environment_Exit)\nICALL(ENV_2, \"GetCommandLineArgs\", mono_runtime_get_main_args)\nICALL(ENV_3, \"GetEnvironmentVariableNames\", ves_icall_System_Environment_GetEnvironmentVariableNames)\nICALL(ENV_4, \"GetLogicalDrivesInternal\", ves_icall_System_Environment_GetLogicalDrives )\nICALL(ENV_5, \"GetMachineConfigPath\", ves_icall_System_Configuration_DefaultConfig_get_machine_config_path)\nICALL(ENV_6, \"GetOSVersionString\", ves_icall_System_Environment_GetOSVersionString)\nICALL(ENV_7, \"GetWindowsFolderPath\", ves_icall_System_Environment_GetWindowsFolderPath)\nICALL(ENV_8, \"InternalSetEnvironmentVariable\", ves_icall_System_Environment_InternalSetEnvironmentVariable)\nICALL(ENV_9, \"get_ExitCode\", mono_environment_exitcode_get)\nICALL(ENV_10, \"get_HasShutdownStarted\", ves_icall_System_Environment_get_HasShutdownStarted)\nICALL(ENV_11, \"get_MachineName\", ves_icall_System_Environment_get_MachineName)\nICALL(ENV_12, \"get_NewLine\", ves_icall_System_Environment_get_NewLine)\nICALL(ENV_13, \"get_Platform\", ves_icall_System_Environment_get_Platform)\nICALL(ENV_14, \"get_ProcessorCount\", mono_cpu_count)\nICALL(ENV_15, \"get_TickCount\", mono_msec_ticks)\nICALL(ENV_16, \"get_UserName\", ves_icall_System_Environment_get_UserName)\nICALL(ENV_16m, \"internalBroadcastSettingChange\", ves_icall_System_Environment_BroadcastSettingChange)\nICALL(ENV_17, \"internalGetEnvironmentVariable\", ves_icall_System_Environment_GetEnvironmentVariable)\nICALL(ENV_18, \"internalGetGacPath\", ves_icall_System_Environment_GetGacPath)\nICALL(ENV_19, \"internalGetHome\", ves_icall_System_Environment_InternalGetHome)\nICALL(ENV_20, \"set_ExitCode\", mono_environment_exitcode_set)\n\nICALL_TYPE(GC, \"System.GC\", GC_0)\nICALL(GC_0, \"CollectionCount\", mono_gc_collection_count)\nICALL(GC_0a, \"GetGeneration\", mono_gc_get_generation)\nICALL(GC_1, \"GetTotalMemory\", ves_icall_System_GC_GetTotalMemory)\nICALL(GC_2, \"InternalCollect\", ves_icall_System_GC_InternalCollect)\nICALL(GC_3, \"KeepAlive\", ves_icall_System_GC_KeepAlive)\nICALL(GC_4, \"ReRegisterForFinalize\", ves_icall_System_GC_ReRegisterForFinalize)\nICALL(GC_4a, \"RecordPressure\", mono_gc_add_memory_pressure)\nICALL(GC_5, \"SuppressFinalize\", ves_icall_System_GC_SuppressFinalize)\nICALL(GC_6, \"WaitForPendingFinalizers\", ves_icall_System_GC_WaitForPendingFinalizers)\nICALL(GC_7, \"get_MaxGeneration\", mono_gc_max_generation)\n\nICALL_TYPE(COMPINF, \"System.Globalization.CompareInfo\", COMPINF_1)\nICALL(COMPINF_1, \"assign_sortkey(object,string,System.Globalization.CompareOptions)\", ves_icall_System_Globalization_CompareInfo_assign_sortkey)\nICALL(COMPINF_2, \"construct_compareinfo(string)\", ves_icall_System_Globalization_CompareInfo_construct_compareinfo)\nICALL(COMPINF_3, \"free_internal_collator()\", ves_icall_System_Globalization_CompareInfo_free_internal_collator)\nICALL(COMPINF_4, \"internal_compare(string,int,int,string,int,int,System.Globalization.CompareOptions)\", ves_icall_System_Globalization_CompareInfo_internal_compare)\nICALL(COMPINF_5, \"internal_index(string,int,int,char,System.Globalization.CompareOptions,bool)\", ves_icall_System_Globalization_CompareInfo_internal_index_char)\nICALL(COMPINF_6, \"internal_index(string,int,int,string,System.Globalization.CompareOptions,bool)\", ves_icall_System_Globalization_CompareInfo_internal_index)\n\nICALL_TYPE(CULINF, \"System.Globalization.CultureInfo\", CULINF_2)\nICALL(CULINF_2, \"construct_datetime_format\", ves_icall_System_Globalization_CultureInfo_construct_datetime_format)\nICALL(CULINF_4, \"construct_internal_locale_from_current_locale\", ves_icall_System_Globalization_CultureInfo_construct_internal_locale_from_current_locale)\nICALL(CULINF_5, \"construct_internal_locale_from_lcid\", ves_icall_System_Globalization_CultureInfo_construct_internal_locale_from_lcid)\nICALL(CULINF_6, \"construct_internal_locale_from_name\", ves_icall_System_Globalization_CultureInfo_construct_internal_locale_from_name)\nICALL(CULINF_7, \"construct_internal_locale_from_specific_name\", ves_icall_System_Globalization_CultureInfo_construct_internal_locale_from_specific_name)\nICALL(CULINF_8, \"construct_number_format\", ves_icall_System_Globalization_CultureInfo_construct_number_format)\nICALL(CULINF_9, \"internal_get_cultures\", ves_icall_System_Globalization_CultureInfo_internal_get_cultures)\nICALL(CULINF_10, \"internal_is_lcid_neutral\", ves_icall_System_Globalization_CultureInfo_internal_is_lcid_neutral)\n\nICALL_TYPE(REGINF, \"System.Globalization.RegionInfo\", REGINF_1)\nICALL(REGINF_1, \"construct_internal_region_from_lcid\", ves_icall_System_Globalization_RegionInfo_construct_internal_region_from_lcid)\nICALL(REGINF_2, \"construct_internal_region_from_name\", ves_icall_System_Globalization_RegionInfo_construct_internal_region_from_name)\n\n#ifndef PLATFORM_NO_DRIVEINFO\nICALL_TYPE(IODRIVEINFO, \"System.IO.DriveInfo\", IODRIVEINFO_1)\nICALL(IODRIVEINFO_1, \"GetDiskFreeSpaceInternal\", ves_icall_System_IO_DriveInfo_GetDiskFreeSpace)\nICALL(IODRIVEINFO_2, \"GetDriveTypeInternal\", ves_icall_System_IO_DriveInfo_GetDriveType)\n#endif\n\nICALL_TYPE(FAMW, \"System.IO.FAMWatcher\", FAMW_1)\nICALL(FAMW_1, \"InternalFAMNextEvent\", ves_icall_System_IO_FAMW_InternalFAMNextEvent)\n\nICALL_TYPE(FILEW, \"System.IO.FileSystemWatcher\", FILEW_4)\nICALL(FILEW_4, \"InternalSupportsFSW\", ves_icall_System_IO_FSW_SupportsFSW)\n\nICALL_TYPE(INOW, \"System.IO.InotifyWatcher\", INOW_1)\nICALL(INOW_1, \"AddWatch\", ves_icall_System_IO_InotifyWatcher_AddWatch)\nICALL(INOW_2, \"GetInotifyInstance\", ves_icall_System_IO_InotifyWatcher_GetInotifyInstance)\nICALL(INOW_3, \"RemoveWatch\", ves_icall_System_IO_InotifyWatcher_RemoveWatch)\n\nICALL_TYPE(MONOIO, \"System.IO.MonoIO\", MONOIO_1)\nICALL(MONOIO_1, \"Close(intptr,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Close)\n#ifndef PLATFORM_RO_FS\nICALL(MONOIO_2, \"CopyFile(string,string,bool,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_CopyFile)\nICALL(MONOIO_3, \"CreateDirectory(string,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_CreateDirectory)\nICALL(MONOIO_4, \"CreatePipe(intptr&,intptr&)\", ves_icall_System_IO_MonoIO_CreatePipe)\nICALL(MONOIO_5, \"DeleteFile(string,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_DeleteFile)\n#endif /* !PLATFORM_RO_FS */\nICALL(MONOIO_34, \"DuplicateHandle\", ves_icall_System_IO_MonoIO_DuplicateHandle)\nICALL(MONOIO_6, \"Flush(intptr,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Flush)\nICALL(MONOIO_7, \"GetCurrentDirectory(System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_GetCurrentDirectory)\nICALL(MONOIO_8, \"GetFileAttributes(string,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_GetFileAttributes)\nICALL(MONOIO_9, \"GetFileStat(string,System.IO.MonoIOStat&,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_GetFileStat)\nICALL(MONOIO_10, \"GetFileSystemEntries\", ves_icall_System_IO_MonoIO_GetFileSystemEntries)\nICALL(MONOIO_11, \"GetFileType(intptr,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_GetFileType)\nICALL(MONOIO_12, \"GetLength(intptr,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_GetLength)\n#ifndef PLATFORM_RO_FS\nICALL(MONOIO_13, \"GetTempPath(string&)\", ves_icall_System_IO_MonoIO_GetTempPath)\nICALL(MONOIO_14, \"Lock(intptr,long,long,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Lock)\nICALL(MONOIO_15, \"MoveFile(string,string,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_MoveFile)\n#endif /* !PLATFORM_RO_FS */\nICALL(MONOIO_16, \"Open(string,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.FileOptions,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Open)\nICALL(MONOIO_17, \"Read(intptr,byte[],int,int,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Read)\n#ifndef PLATFORM_RO_FS\nICALL(MONOIO_18, \"RemoveDirectory(string,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_RemoveDirectory)\nICALL(MONOIO_18M, \"ReplaceFile(string,string,string,bool,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_ReplaceFile)\n#endif /* !PLATFORM_RO_FS */\nICALL(MONOIO_19, \"Seek(intptr,long,System.IO.SeekOrigin,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Seek)\nICALL(MONOIO_20, \"SetCurrentDirectory(string,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_SetCurrentDirectory)\nICALL(MONOIO_21, \"SetFileAttributes(string,System.IO.FileAttributes,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_SetFileAttributes)\nICALL(MONOIO_22, \"SetFileTime(intptr,long,long,long,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_SetFileTime)\nICALL(MONOIO_23, \"SetLength(intptr,long,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_SetLength)\n#ifndef PLATFORM_RO_FS\nICALL(MONOIO_24, \"Unlock(intptr,long,long,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Unlock)\n#endif\nICALL(MONOIO_25, \"Write(intptr,byte[],int,int,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Write)\nICALL(MONOIO_26, \"get_AltDirectorySeparatorChar\", ves_icall_System_IO_MonoIO_get_AltDirectorySeparatorChar)\nICALL(MONOIO_27, \"get_ConsoleError\", ves_icall_System_IO_MonoIO_get_ConsoleError)\nICALL(MONOIO_28, \"get_ConsoleInput\", ves_icall_System_IO_MonoIO_get_ConsoleInput)\nICALL(MONOIO_29, \"get_ConsoleOutput\", ves_icall_System_IO_MonoIO_get_ConsoleOutput)\nICALL(MONOIO_30, \"get_DirectorySeparatorChar\", ves_icall_System_IO_MonoIO_get_DirectorySeparatorChar)\nICALL(MONOIO_31, \"get_InvalidPathChars\", ves_icall_System_IO_MonoIO_get_InvalidPathChars)\nICALL(MONOIO_32, \"get_PathSeparator\", ves_icall_System_IO_MonoIO_get_PathSeparator)\nICALL(MONOIO_33, \"get_VolumeSeparatorChar\", ves_icall_System_IO_MonoIO_get_VolumeSeparatorChar)\n\nICALL_TYPE(IOPATH, \"System.IO.Path\", IOPATH_1)\nICALL(IOPATH_1, \"get_temp_path\", ves_icall_System_IO_get_temp_path)\n\nICALL_TYPE(MATH, \"System.Math\", MATH_1)\nICALL(MATH_1, \"Acos\", ves_icall_System_Math_Acos)\nICALL(MATH_2, \"Asin\", ves_icall_System_Math_Asin)\nICALL(MATH_3, \"Atan\", ves_icall_System_Math_Atan)\nICALL(MATH_4, \"Atan2\", ves_icall_System_Math_Atan2)\nICALL(MATH_5, \"Cos\", ves_icall_System_Math_Cos)\nICALL(MATH_6, \"Cosh\", ves_icall_System_Math_Cosh)\nICALL(MATH_7, \"Exp\", ves_icall_System_Math_Exp)\nICALL(MATH_8, \"Floor\", ves_icall_System_Math_Floor)\nICALL(MATH_9, \"Log\", ves_icall_System_Math_Log)\nICALL(MATH_10, \"Log10\", ves_icall_System_Math_Log10)\nICALL(MATH_11, \"Pow\", ves_icall_System_Math_Pow)\nICALL(MATH_12, \"Round\", ves_icall_System_Math_Round)\nICALL(MATH_13, \"Round2\", ves_icall_System_Math_Round2)\nICALL(MATH_14, \"Sin\", ves_icall_System_Math_Sin)\nICALL(MATH_15, \"Sinh\", ves_icall_System_Math_Sinh)\nICALL(MATH_16, \"Sqrt\", ves_icall_System_Math_Sqrt)\nICALL(MATH_17, \"Tan\", ves_icall_System_Math_Tan)\nICALL(MATH_18, \"Tanh\", ves_icall_System_Math_Tanh)\n\nICALL_TYPE(MCATTR, \"System.MonoCustomAttrs\", MCATTR_1)\nICALL(MCATTR_1, \"GetCustomAttributesDataInternal\", mono_reflection_get_custom_attrs_data)\nICALL(MCATTR_2, \"GetCustomAttributesInternal\", custom_attrs_get_by_type)\nICALL(MCATTR_3, \"IsDefinedInternal\", custom_attrs_defined_internal)\n\nICALL_TYPE(MENUM, \"System.MonoEnumInfo\", MENUM_1)\nICALL(MENUM_1, \"get_enum_info\", ves_icall_get_enum_info)\n\nICALL_TYPE(MTYPE, \"System.MonoType\", MTYPE_1)\nICALL(MTYPE_1, \"GetArrayRank\", ves_icall_MonoType_GetArrayRank)\nICALL(MTYPE_2, \"GetConstructors\", ves_icall_Type_GetConstructors_internal)\nICALL(MTYPE_3, \"GetConstructors_internal\", ves_icall_Type_GetConstructors_internal)\nICALL(MTYPE_4, \"GetCorrespondingInflatedConstructor\", ves_icall_MonoType_GetCorrespondingInflatedMethod)\nICALL(MTYPE_5, \"GetCorrespondingInflatedMethod\", ves_icall_MonoType_GetCorrespondingInflatedMethod)\nICALL(MTYPE_6, \"GetElementType\", ves_icall_MonoType_GetElementType)\nICALL(MTYPE_7, \"GetEvents_internal\", ves_icall_Type_GetEvents_internal)\nICALL(MTYPE_8, \"GetField\", ves_icall_Type_GetField)\nICALL(MTYPE_9, \"GetFields_internal\", ves_icall_Type_GetFields_internal)\nICALL(MTYPE_10, \"GetGenericArguments\", ves_icall_MonoType_GetGenericArguments)\nICALL(MTYPE_11, \"GetInterfaces\", ves_icall_Type_GetInterfaces)\nICALL(MTYPE_12, \"GetMethodsByName\", ves_icall_Type_GetMethodsByName)\nICALL(MTYPE_13, \"GetNestedType\", ves_icall_Type_GetNestedType)\nICALL(MTYPE_14, \"GetNestedTypes\", ves_icall_Type_GetNestedTypes)\nICALL(MTYPE_15, \"GetPropertiesByName\", ves_icall_Type_GetPropertiesByName)\nICALL(MTYPE_16, \"InternalGetEvent\", ves_icall_MonoType_GetEvent)\nICALL(MTYPE_17, \"IsByRefImpl\", ves_icall_type_isbyref)\nICALL(MTYPE_18, \"IsCOMObjectImpl\", ves_icall_type_iscomobject)\nICALL(MTYPE_19, \"IsPointerImpl\", ves_icall_type_ispointer)\nICALL(MTYPE_20, \"IsPrimitiveImpl\", ves_icall_type_isprimitive)\nICALL(MTYPE_21, \"getFullName\", ves_icall_System_MonoType_getFullName)\nICALL(MTYPE_22, \"get_Assembly\", ves_icall_MonoType_get_Assembly)\nICALL(MTYPE_23, \"get_BaseType\", ves_icall_get_type_parent)\nICALL(MTYPE_24, \"get_DeclaringMethod\", ves_icall_MonoType_get_DeclaringMethod)\nICALL(MTYPE_25, \"get_DeclaringType\", ves_icall_MonoType_get_DeclaringType)\nICALL(MTYPE_26, \"get_IsGenericParameter\", ves_icall_MonoType_get_IsGenericParameter)\nICALL(MTYPE_27, \"get_Module\", ves_icall_MonoType_get_Module)\nICALL(MTYPE_28, \"get_Name\", ves_icall_MonoType_get_Name)\nICALL(MTYPE_29, \"get_Namespace\", ves_icall_MonoType_get_Namespace)\nICALL(MTYPE_30, \"get_UnderlyingSystemType\", ves_icall_MonoType_get_UnderlyingSystemType)\nICALL(MTYPE_31, \"get_attributes\", ves_icall_get_attributes)\nICALL(MTYPE_32, \"type_from_obj\", mono_type_type_from_obj)\n\n#ifndef DISABLE_SOCKETS\nICALL_TYPE(NDNS, \"System.Net.Dns\", NDNS_1)\nICALL(NDNS_1, \"GetHostByAddr_internal(string,string&,string[]&,string[]&)\", ves_icall_System_Net_Dns_GetHostByAddr_internal)\nICALL(NDNS_2, \"GetHostByName_internal(string,string&,string[]&,string[]&)\", ves_icall_System_Net_Dns_GetHostByName_internal)\nICALL(NDNS_3, \"GetHostName_internal(string&)\", ves_icall_System_Net_Dns_GetHostName_internal)\n\nICALL_TYPE(SOCK, \"System.Net.Sockets.Socket\", SOCK_1)\nICALL(SOCK_1, \"Accept_internal(intptr,int&,bool)\", ves_icall_System_Net_Sockets_Socket_Accept_internal)\nICALL(SOCK_2, \"Available_internal(intptr,int&)\", ves_icall_System_Net_Sockets_Socket_Available_internal)\nICALL(SOCK_3, \"Bind_internal(intptr,System.Net.SocketAddress,int&)\", ves_icall_System_Net_Sockets_Socket_Bind_internal)\nICALL(SOCK_4, \"Blocking_internal(intptr,bool,int&)\", ves_icall_System_Net_Sockets_Socket_Blocking_internal)\nICALL(SOCK_5, \"Close_internal(intptr,int&)\", ves_icall_System_Net_Sockets_Socket_Close_internal)\nICALL(SOCK_6, \"Connect_internal(intptr,System.Net.SocketAddress,int&)\", ves_icall_System_Net_Sockets_Socket_Connect_internal)\nICALL (SOCK_6a, \"Disconnect_internal(intptr,bool,int&)\", ves_icall_System_Net_Sockets_Socket_Disconnect_internal)\nICALL(SOCK_7, \"GetSocketOption_arr_internal(intptr,System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,byte[]&,int&)\", ves_icall_System_Net_Sockets_Socket_GetSocketOption_arr_internal)\nICALL(SOCK_8, \"GetSocketOption_obj_internal(intptr,System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,object&,int&)\", ves_icall_System_Net_Sockets_Socket_GetSocketOption_obj_internal)\nICALL(SOCK_9, \"Listen_internal(intptr,int,int&)\", ves_icall_System_Net_Sockets_Socket_Listen_internal)\nICALL(SOCK_10, \"LocalEndPoint_internal(intptr,int,int&)\", ves_icall_System_Net_Sockets_Socket_LocalEndPoint_internal)\nICALL(SOCK_11, \"Poll_internal\", ves_icall_System_Net_Sockets_Socket_Poll_internal)\nICALL(SOCK_11a, \"Receive_internal(intptr,System.Net.Sockets.Socket/WSABUF[],System.Net.Sockets.SocketFlags,int&)\", ves_icall_System_Net_Sockets_Socket_Receive_array_internal)\nICALL(SOCK_12, \"Receive_internal(intptr,byte[],int,int,System.Net.Sockets.SocketFlags,int&)\", ves_icall_System_Net_Sockets_Socket_Receive_internal)\nICALL(SOCK_13, \"RecvFrom_internal(intptr,byte[],int,int,System.Net.Sockets.SocketFlags,System.Net.SocketAddress&,int&)\", ves_icall_System_Net_Sockets_Socket_RecvFrom_internal)\nICALL(SOCK_14, \"RemoteEndPoint_internal(intptr,int,int&)\", ves_icall_System_Net_Sockets_Socket_RemoteEndPoint_internal)\nICALL(SOCK_15, \"Select_internal(System.Net.Sockets.Socket[]&,int,int&)\", ves_icall_System_Net_Sockets_Socket_Select_internal)\nICALL(SOCK_15a, \"SendFile(intptr,string,byte[],byte[],System.Net.Sockets.TransmitFileOptions)\", ves_icall_System_Net_Sockets_Socket_SendFile)\nICALL(SOCK_16, \"SendTo_internal(intptr,byte[],int,int,System.Net.Sockets.SocketFlags,System.Net.SocketAddress,int&)\", ves_icall_System_Net_Sockets_Socket_SendTo_internal)\nICALL(SOCK_16a, \"Send_internal(intptr,System.Net.Sockets.Socket/WSABUF[],System.Net.Sockets.SocketFlags,int&)\", ves_icall_System_Net_Sockets_Socket_Send_array_internal)\nICALL(SOCK_17, \"Send_internal(intptr,byte[],int,int,System.Net.Sockets.SocketFlags,int&)\", ves_icall_System_Net_Sockets_Socket_Send_internal)\nICALL(SOCK_18, \"SetSocketOption_internal(intptr,System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,object,byte[],int,int&)\", ves_icall_System_Net_Sockets_Socket_SetSocketOption_internal)\nICALL(SOCK_19, \"Shutdown_internal(intptr,System.Net.Sockets.SocketShutdown,int&)\", ves_icall_System_Net_Sockets_Socket_Shutdown_internal)\nICALL(SOCK_20, \"Socket_internal(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,int&)\", ves_icall_System_Net_Sockets_Socket_Socket_internal)\nICALL(SOCK_21, \"WSAIoctl(intptr,int,byte[],byte[],int&)\", ves_icall_System_Net_Sockets_Socket_WSAIoctl)\n\nICALL_TYPE(SOCKEX, \"System.Net.Sockets.SocketException\", SOCKEX_1)\nICALL(SOCKEX_1, \"WSAGetLastError_internal\", ves_icall_System_Net_Sockets_SocketException_WSAGetLastError_internal)\n#endif /* !DISABLE_SOCKETS */\n\nICALL_TYPE(NUMBER_FORMATTER, \"System.NumberFormatter\", NUMBER_FORMATTER_1)\nICALL(NUMBER_FORMATTER_1, \"GetFormatterTables\", ves_icall_System_NumberFormatter_GetFormatterTables)\n\nICALL_TYPE(OBJ, \"System.Object\", OBJ_1)\nICALL(OBJ_1, \"GetType\", ves_icall_System_Object_GetType)\nICALL(OBJ_2, \"InternalGetHashCode\", mono_object_hash)\nICALL(OBJ_3, \"MemberwiseClone\", ves_icall_System_Object_MemberwiseClone)\nICALL(OBJ_4, \"obj_address\", ves_icall_System_Object_obj_address)\n\nICALL_TYPE(ASSEM, \"System.Reflection.Assembly\", ASSEM_1)\nICALL(ASSEM_1, \"FillName\", ves_icall_System_Reflection_Assembly_FillName)\nICALL(ASSEM_2, \"GetCallingAssembly\", ves_icall_System_Reflection_Assembly_GetCallingAssembly)\nICALL(ASSEM_3, \"GetEntryAssembly\", ves_icall_System_Reflection_Assembly_GetEntryAssembly)\nICALL(ASSEM_4, \"GetExecutingAssembly\", ves_icall_System_Reflection_Assembly_GetExecutingAssembly)\nICALL(ASSEM_5, \"GetFilesInternal\", ves_icall_System_Reflection_Assembly_GetFilesInternal)\nICALL(ASSEM_6, \"GetManifestModuleInternal\", ves_icall_System_Reflection_Assembly_GetManifestModuleInternal)\nICALL(ASSEM_7, \"GetManifestResourceInfoInternal\", ves_icall_System_Reflection_Assembly_GetManifestResourceInfoInternal)\nICALL(ASSEM_8, \"GetManifestResourceInternal\", ves_icall_System_Reflection_Assembly_GetManifestResourceInternal)\nICALL(ASSEM_9, \"GetManifestResourceNames\", ves_icall_System_Reflection_Assembly_GetManifestResourceNames)\nICALL(ASSEM_10, \"GetModulesInternal\", ves_icall_System_Reflection_Assembly_GetModulesInternal)\nICALL(ASSEM_11, \"GetNamespaces\", ves_icall_System_Reflection_Assembly_GetNamespaces)\nICALL(ASSEM_12, \"GetReferencedAssemblies\", ves_icall_System_Reflection_Assembly_GetReferencedAssemblies)\nICALL(ASSEM_13, \"GetTypes\", ves_icall_System_Reflection_Assembly_GetTypes)\nICALL(ASSEM_14, \"InternalGetAssemblyName\", ves_icall_System_Reflection_Assembly_InternalGetAssemblyName)\nICALL(ASSEM_15, \"InternalGetType\", ves_icall_System_Reflection_Assembly_InternalGetType)\nICALL(ASSEM_16, \"InternalImageRuntimeVersion\", ves_icall_System_Reflection_Assembly_InternalImageRuntimeVersion)\nICALL(ASSEM_17, \"LoadFrom\", ves_icall_System_Reflection_Assembly_LoadFrom)\nICALL(ASSEM_18, \"LoadPermissions\", ves_icall_System_Reflection_Assembly_LoadPermissions)\n\t/*\n\t * Private icalls for the Mono Debugger\n\t */\nICALL(ASSEM_19, \"MonoDebugger_GetMethodToken\", ves_icall_MonoDebugger_GetMethodToken)\n\n\t/* normal icalls again */\nICALL(ASSEM_20, \"get_EntryPoint\", ves_icall_System_Reflection_Assembly_get_EntryPoint)\nICALL(ASSEM_21, \"get_ReflectionOnly\", ves_icall_System_Reflection_Assembly_get_ReflectionOnly)\nICALL(ASSEM_22, \"get_code_base\", ves_icall_System_Reflection_Assembly_get_code_base)\nICALL(ASSEM_23, \"get_fullname\", ves_icall_System_Reflection_Assembly_get_fullName)\nICALL(ASSEM_24, \"get_global_assembly_cache\", ves_icall_System_Reflection_Assembly_get_global_assembly_cache)\nICALL(ASSEM_25, \"get_location\", ves_icall_System_Reflection_Assembly_get_location)\nICALL(ASSEM_26, \"load_with_partial_name\", ves_icall_System_Reflection_Assembly_load_with_partial_name)\n\nICALL_TYPE(ASSEMN, \"System.Reflection.AssemblyName\", ASSEMN_1)\nICALL(ASSEMN_1, \"ParseName\", ves_icall_System_Reflection_AssemblyName_ParseName)\n\nICALL_TYPE(ASSEMB, \"System.Reflection.Emit.AssemblyBuilder\", ASSEMB_1)\nICALL(ASSEMB_1, \"InternalAddModule\", mono_image_load_module_dynamic)\nICALL(ASSEMB_2, \"basic_init\", mono_image_basic_init)\n\nICALL_TYPE(CATTRB, \"System.Reflection.Emit.CustomAttributeBuilder\", CATTRB_1)\nICALL(CATTRB_1, \"GetBlob\", mono_reflection_get_custom_attrs_blob)\n\n#ifndef DISABLE_REFLECTION_EMIT\nICALL_TYPE(DERIVEDTYPE, \"System.Reflection.Emit.DerivedType\", DERIVEDTYPE_1)\nICALL(DERIVEDTYPE_1, \"create_unmanaged_type\", mono_reflection_create_unmanaged_type)\n#endif\n\nICALL_TYPE(DYNM, \"System.Reflection.Emit.DynamicMethod\", DYNM_1)\nICALL(DYNM_1, \"create_dynamic_method\", mono_reflection_create_dynamic_method)\nICALL(DYNM_2, \"destroy_dynamic_method\", mono_reflection_destroy_dynamic_method)\n\nICALL_TYPE(ENUMB, \"System.Reflection.Emit.EnumBuilder\", ENUMB_1)\nICALL(ENUMB_1, \"setup_enum_type\", ves_icall_EnumBuilder_setup_enum_type)\n\nICALL_TYPE(GPARB, \"System.Reflection.Emit.GenericTypeParameterBuilder\", GPARB_1)\nICALL(GPARB_1, \"initialize\", mono_reflection_initialize_generic_parameter)\n\nICALL_TYPE(METHODB, \"System.Reflection.Emit.MethodBuilder\", METHODB_1)\nICALL(METHODB_1, \"MakeGenericMethod\", mono_reflection_bind_generic_method_parameters)\n\nICALL_TYPE(MODULEB, \"System.Reflection.Emit.ModuleBuilder\", MODULEB_8)\nICALL(MODULEB_8, \"RegisterToken\", ves_icall_ModuleBuilder_RegisterToken)\nICALL(MODULEB_1, \"WriteToFile\", ves_icall_ModuleBuilder_WriteToFile)\nICALL(MODULEB_2, \"basic_init\", mono_image_module_basic_init)\nICALL(MODULEB_3, \"build_metadata\", ves_icall_ModuleBuilder_build_metadata)\nICALL(MODULEB_4, \"create_modified_type\", ves_icall_ModuleBuilder_create_modified_type)\nICALL(MODULEB_5, \"getMethodToken\", ves_icall_ModuleBuilder_getMethodToken)\nICALL(MODULEB_6, \"getToken\", ves_icall_ModuleBuilder_getToken)\nICALL(MODULEB_7, \"getUSIndex\", mono_image_insert_string)\nICALL(MODULEB_9, \"set_wrappers_type\", mono_image_set_wrappers_type)\n\nICALL_TYPE(SIGH, \"System.Reflection.Emit.SignatureHelper\", SIGH_1)\nICALL(SIGH_1, \"get_signature_field\", mono_reflection_sighelper_get_signature_field)\nICALL(SIGH_2, \"get_signature_local\", mono_reflection_sighelper_get_signature_local)\n\nICALL_TYPE(TYPEB, \"System.Reflection.Emit.TypeBuilder\", TYPEB_1)\nICALL(TYPEB_1, \"create_generic_class\", mono_reflection_create_generic_class)\nICALL(TYPEB_2, \"create_internal_class\", mono_reflection_create_internal_class)\nICALL(TYPEB_3, \"create_runtime_class\", mono_reflection_create_runtime_class)\nICALL(TYPEB_4, \"get_IsGenericParameter\", ves_icall_TypeBuilder_get_IsGenericParameter)\nICALL(TYPEB_5, \"get_event_info\", mono_reflection_event_builder_get_event_info)\nICALL(TYPEB_6, \"setup_generic_class\", mono_reflection_setup_generic_class)\nICALL(TYPEB_7, \"setup_internal_class\", mono_reflection_setup_internal_class)\n\nICALL_TYPE(FIELDI, \"System.Reflection.FieldInfo\", FILEDI_1)\nICALL(FILEDI_1, \"GetTypeModifiers\", ves_icall_System_Reflection_FieldInfo_GetTypeModifiers)\nICALL(FILEDI_2, \"GetUnmanagedMarshal\", ves_icall_System_Reflection_FieldInfo_GetUnmanagedMarshal)\nICALL(FILEDI_3, \"internal_from_handle_type\", ves_icall_System_Reflection_FieldInfo_internal_from_handle_type)\n\nICALL_TYPE(MEMBERI, \"System.Reflection.MemberInfo\", MEMBERI_1)\nICALL(MEMBERI_1, \"get_MetadataToken\", mono_reflection_get_token)\n\nICALL_TYPE(MBASE, \"System.Reflection.MethodBase\", MBASE_1)\nICALL(MBASE_1, \"GetCurrentMethod\", ves_icall_GetCurrentMethod)\nICALL(MBASE_2, \"GetMethodBodyInternal\", ves_icall_System_Reflection_MethodBase_GetMethodBodyInternal)\nICALL(MBASE_3, \"GetMethodFromHandleInternal\", ves_icall_System_Reflection_MethodBase_GetMethodFromHandleInternal)\nICALL(MBASE_4, \"GetMethodFromHandleInternalType\", ves_icall_System_Reflection_MethodBase_GetMethodFromHandleInternalType)\n\nICALL_TYPE(MODULE, \"System.Reflection.Module\", MODULE_1)\nICALL(MODULE_1, \"Close\", ves_icall_System_Reflection_Module_Close)\nICALL(MODULE_2, \"GetGlobalType\", ves_icall_System_Reflection_Module_GetGlobalType)\nICALL(MODULE_3, \"GetGuidInternal\", ves_icall_System_Reflection_Module_GetGuidInternal)\nICALL(MODULE_14, \"GetHINSTANCE\", ves_icall_System_Reflection_Module_GetHINSTANCE)\nICALL(MODULE_4, \"GetMDStreamVersion\", ves_icall_System_Reflection_Module_GetMDStreamVersion)\nICALL(MODULE_5, \"GetPEKind\", ves_icall_System_Reflection_Module_GetPEKind)\nICALL(MODULE_6, \"InternalGetTypes\", ves_icall_System_Reflection_Module_InternalGetTypes)\nICALL(MODULE_7, \"ResolveFieldToken\", ves_icall_System_Reflection_Module_ResolveFieldToken)\nICALL(MODULE_8, \"ResolveMemberToken\", ves_icall_System_Reflection_Module_ResolveMemberToken)\nICALL(MODULE_9, \"ResolveMethodToken\", ves_icall_System_Reflection_Module_ResolveMethodToken)\nICALL(MODULE_10, \"ResolveSignature\", ves_icall_System_Reflection_Module_ResolveSignature)\nICALL(MODULE_11, \"ResolveStringToken\", ves_icall_System_Reflection_Module_ResolveStringToken)\nICALL(MODULE_12, \"ResolveTypeToken\", ves_icall_System_Reflection_Module_ResolveTypeToken)\nICALL(MODULE_13, \"get_MetadataToken\", mono_reflection_get_token)\n\nICALL_TYPE(MCMETH, \"System.Reflection.MonoCMethod\", MCMETH_1)\nICALL(MCMETH_1, \"GetGenericMethodDefinition_impl\", ves_icall_MonoMethod_GetGenericMethodDefinition)\nICALL(MCMETH_2, \"InternalInvoke\", ves_icall_InternalInvoke)\n\nICALL_TYPE(MEVIN, \"System.Reflection.MonoEventInfo\", MEVIN_1)\nICALL(MEVIN_1, \"get_event_info\", ves_icall_get_event_info)\n\nICALL_TYPE(MFIELD, \"System.Reflection.MonoField\", MFIELD_1)\nICALL(MFIELD_1, \"GetFieldOffset\", ves_icall_MonoField_GetFieldOffset)\nICALL(MFIELD_2, \"GetParentType\", ves_icall_MonoField_GetParentType)\nICALL(MFIELD_5, \"GetRawConstantValue\", ves_icall_MonoField_GetRawConstantValue)\nICALL(MFIELD_3, \"GetValueInternal\", ves_icall_MonoField_GetValueInternal)\nICALL(MFIELD_4, \"SetValueInternal\", ves_icall_MonoField_SetValueInternal)\n\nICALL_TYPE(MGENCM, \"System.Reflection.MonoGenericCMethod\", MGENCM_1)\nICALL(MGENCM_1, \"get_ReflectedType\", ves_icall_MonoGenericMethod_get_ReflectedType)\n\nICALL_TYPE(MGENCL, \"System.Reflection.MonoGenericClass\", MGENCL_1)\nICALL(MGENCL_1, \"GetElementType\", ves_icall_MonoType_GetElementType)\nICALL(MGENCL_2, \"IsByRefImpl\", ves_icall_type_isbyref)\nICALL(MGENCL_3, \"IsPointerImpl\", ves_icall_type_ispointer)\nICALL(MGENCL_4, \"IsPrimitiveImpl\", ves_icall_type_isprimitive)\nICALL(MGENCL_5, \"initialize\", mono_reflection_generic_class_initialize)\n\n/* note this is the same as above: unify */\nICALL_TYPE(MGENM, \"System.Reflection.MonoGenericMethod\", MGENM_1)\nICALL(MGENM_1, \"get_ReflectedType\", ves_icall_MonoGenericMethod_get_ReflectedType)\n\nICALL_TYPE(MMETH, \"System.Reflection.MonoMethod\", MMETH_1)\nICALL(MMETH_1, \"GetDllImportAttribute\", ves_icall_MonoMethod_GetDllImportAttribute)\nICALL(MMETH_2, \"GetGenericArguments\", ves_icall_MonoMethod_GetGenericArguments)\nICALL(MMETH_3, \"GetGenericMethodDefinition_impl\", ves_icall_MonoMethod_GetGenericMethodDefinition)\nICALL(MMETH_4, \"InternalInvoke\", ves_icall_InternalInvoke)\nICALL(MMETH_5, \"MakeGenericMethod_impl\", mono_reflection_bind_generic_method_parameters)\nICALL(MMETH_6, \"get_IsGenericMethod\", ves_icall_MonoMethod_get_IsGenericMethod)\nICALL(MMETH_7, \"get_IsGenericMethodDefinition\", ves_icall_MonoMethod_get_IsGenericMethodDefinition)\nICALL(MMETH_8, \"get_base_definition\", ves_icall_MonoMethod_get_base_definition)\nICALL(MMETH_9, \"get_name\", ves_icall_MonoMethod_get_name)\n\nICALL_TYPE(MMETHI, \"System.Reflection.MonoMethodInfo\", MMETHI_1)\nICALL(MMETHI_1, \"get_method_info\", ves_icall_get_method_info)\nICALL(MMETHI_2, \"get_parameter_info\", ves_icall_get_parameter_info)\nICALL(MMETHI_3, \"get_retval_marshal\", ves_icall_System_MonoMethodInfo_get_retval_marshal)\n\nICALL_TYPE(MPROPI, \"System.Reflection.MonoPropertyInfo\", MPROPI_1)\nICALL(MPROPI_1, \"GetTypeModifiers\", property_info_get_type_modifiers)\nICALL(MPROPI_2, \"get_property_info\", ves_icall_get_property_info)\n\nICALL_TYPE(PARAMI, \"System.Reflection.ParameterInfo\", PARAMI_1)\nICALL(PARAMI_1, \"GetMetadataToken\", mono_reflection_get_token)\nICALL(PARAMI_2, \"GetTypeModifiers\", param_info_get_type_modifiers)\n\nICALL_TYPE(RUNH, \"System.Runtime.CompilerServices.RuntimeHelpers\", RUNH_1)\nICALL(RUNH_1, \"GetObjectValue\", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetObjectValue)\n\t /* REMOVEME: no longer needed, just so we dont break things when not needed */\nICALL(RUNH_2, \"GetOffsetToStringData\", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetOffsetToStringData)\nICALL(RUNH_3, \"InitializeArray\", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray)\nICALL(RUNH_4, \"RunClassConstructor\", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_RunClassConstructor)\nICALL(RUNH_5, \"RunModuleConstructor\", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_RunModuleConstructor)\nICALL(RUNH_6, \"get_OffsetToStringData\", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetOffsetToStringData)\n\nICALL_TYPE(GCH, \"System.Runtime.InteropServices.GCHandle\", GCH_1)\nICALL(GCH_1, \"CheckCurrentDomain\", GCHandle_CheckCurrentDomain)\nICALL(GCH_2, \"FreeHandle\", ves_icall_System_GCHandle_FreeHandle)\nICALL(GCH_3, \"GetAddrOfPinnedObject\", ves_icall_System_GCHandle_GetAddrOfPinnedObject)\nICALL(GCH_4, \"GetTarget\", ves_icall_System_GCHandle_GetTarget)\nICALL(GCH_5, \"GetTargetHandle\", ves_icall_System_GCHandle_GetTargetHandle)\n\n#ifndef DISABLE_COM\nICALL_TYPE(MARSHAL, \"System.Runtime.InteropServices.Marshal\", MARSHAL_1)\nICALL(MARSHAL_1, \"AddRefInternal\", ves_icall_System_Runtime_InteropServices_Marshal_AddRefInternal)\n#else\nICALL_TYPE(MARSHAL, \"System.Runtime.InteropServices.Marshal\", MARSHAL_2)\n#endif\nICALL(MARSHAL_2, \"AllocCoTaskMem\", ves_icall_System_Runtime_InteropServices_Marshal_AllocCoTaskMem)\nICALL(MARSHAL_3, \"AllocHGlobal\", ves_icall_System_Runtime_InteropServices_Marshal_AllocHGlobal)\nICALL(MARSHAL_4, \"DestroyStructure\", ves_icall_System_Runtime_InteropServices_Marshal_DestroyStructure)\n#ifndef DISABLE_COM\nICALL(MARSHAL_5, \"FreeBSTR\", ves_icall_System_Runtime_InteropServices_Marshal_FreeBSTR)\n#endif\nICALL(MARSHAL_6, \"FreeCoTaskMem\", ves_icall_System_Runtime_InteropServices_Marshal_FreeCoTaskMem)\nICALL(MARSHAL_7, \"FreeHGlobal\", ves_icall_System_Runtime_InteropServices_Marshal_FreeHGlobal)\n#ifndef DISABLE_COM\nICALL(MARSHAL_44, \"GetCCW\", ves_icall_System_Runtime_InteropServices_Marshal_GetCCW)\nICALL(MARSHAL_8, \"GetComSlotForMethodInfoInternal\", ves_icall_System_Runtime_InteropServices_Marshal_GetComSlotForMethodInfoInternal)\n#endif\nICALL(MARSHAL_9, \"GetDelegateForFunctionPointerInternal\", ves_icall_System_Runtime_InteropServices_Marshal_GetDelegateForFunctionPointerInternal)\nICALL(MARSHAL_10, \"GetFunctionPointerForDelegateInternal\", mono_delegate_to_ftnptr)\n#ifndef DISABLE_COM\nICALL(MARSHAL_45, \"GetIDispatchForObjectInternal\", ves_icall_System_Runtime_InteropServices_Marshal_GetIDispatchForObjectInternal)\nICALL(MARSHAL_46, \"GetIUnknownForObjectInternal\", ves_icall_System_Runtime_InteropServices_Marshal_GetIUnknownForObjectInternal)\n#endif\nICALL(MARSHAL_11, \"GetLastWin32Error\", ves_icall_System_Runtime_InteropServices_Marshal_GetLastWin32Error)\n#ifndef DISABLE_COM\nICALL(MARSHAL_47, \"GetObjectForCCW\", ves_icall_System_Runtime_InteropServices_Marshal_GetObjectForCCW)\nICALL(MARSHAL_48, \"IsComObject\", ves_icall_System_Runtime_InteropServices_Marshal_IsComObject)\n#endif\nICALL(MARSHAL_12, \"OffsetOf\", ves_icall_System_Runtime_InteropServices_Marshal_OffsetOf)\nICALL(MARSHAL_13, \"Prelink\", ves_icall_System_Runtime_InteropServices_Marshal_Prelink)\nICALL(MARSHAL_14, \"PrelinkAll\", ves_icall_System_Runtime_InteropServices_Marshal_PrelinkAll)\nICALL(MARSHAL_15, \"PtrToStringAnsi(intptr)\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringAnsi)\nICALL(MARSHAL_16, \"PtrToStringAnsi(intptr,int)\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringAnsi_len)\n#ifndef DISABLE_COM\nICALL(MARSHAL_17, \"PtrToStringBSTR\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringBSTR)\n#endif\nICALL(MARSHAL_18, \"PtrToStringUni(intptr)\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringUni)\nICALL(MARSHAL_19, \"PtrToStringUni(intptr,int)\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringUni_len)\nICALL(MARSHAL_20, \"PtrToStructure(intptr,System.Type)\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStructure_type)\nICALL(MARSHAL_21, \"PtrToStructure(intptr,object)\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStructure)\n#ifndef DISABLE_COM\nICALL(MARSHAL_22, \"QueryInterfaceInternal\", ves_icall_System_Runtime_InteropServices_Marshal_QueryInterfaceInternal)\n#endif\nICALL(MARSHAL_43, \"ReAllocCoTaskMem\", ves_icall_System_Runtime_InteropServices_Marshal_ReAllocCoTaskMem)\nICALL(MARSHAL_23, \"ReAllocHGlobal\", ves_icall_System_Runtime_InteropServices_Marshal_ReAllocHGlobal)\nICALL(MARSHAL_24, \"ReadByte\", ves_icall_System_Runtime_InteropServices_Marshal_ReadByte)\nICALL(MARSHAL_25, \"ReadInt16\", ves_icall_System_Runtime_InteropServices_Marshal_ReadInt16)\nICALL(MARSHAL_26, \"ReadInt32\", ves_icall_System_Runtime_InteropServices_Marshal_ReadInt32)\nICALL(MARSHAL_27, \"ReadInt64\", ves_icall_System_Runtime_InteropServices_Marshal_ReadInt64)\nICALL(MARSHAL_28, \"ReadIntPtr\", ves_icall_System_Runtime_InteropServices_Marshal_ReadIntPtr)\n#ifndef DISABLE_COM\nICALL(MARSHAL_49, \"ReleaseComObjectInternal\", ves_icall_System_Runtime_InteropServices_Marshal_ReleaseComObjectInternal)\nICALL(MARSHAL_29, \"ReleaseInternal\", ves_icall_System_Runtime_InteropServices_Marshal_ReleaseInternal)\n#endif\nICALL(MARSHAL_30, \"SizeOf\", ves_icall_System_Runtime_InteropServices_Marshal_SizeOf)\n#ifndef DISABLE_COM\nICALL(MARSHAL_31, \"StringToBSTR\", ves_icall_System_Runtime_InteropServices_Marshal_StringToBSTR)\n#endif\nICALL(MARSHAL_32, \"StringToHGlobalAnsi\", ves_icall_System_Runtime_InteropServices_Marshal_StringToHGlobalAnsi)\nICALL(MARSHAL_33, \"StringToHGlobalUni\", ves_icall_System_Runtime_InteropServices_Marshal_StringToHGlobalUni)\nICALL(MARSHAL_34, \"StructureToPtr\", ves_icall_System_Runtime_InteropServices_Marshal_StructureToPtr)\nICALL(MARSHAL_35, \"UnsafeAddrOfPinnedArrayElement\", ves_icall_System_Runtime_InteropServices_Marshal_UnsafeAddrOfPinnedArrayElement)\nICALL(MARSHAL_36, \"WriteByte\", ves_icall_System_Runtime_InteropServices_Marshal_WriteByte)\nICALL(MARSHAL_37, \"WriteInt16\", ves_icall_System_Runtime_InteropServices_Marshal_WriteInt16)\nICALL(MARSHAL_38, \"WriteInt32\", ves_icall_System_Runtime_InteropServices_Marshal_WriteInt32)\nICALL(MARSHAL_39, \"WriteInt64\", ves_icall_System_Runtime_InteropServices_Marshal_WriteInt64)\nICALL(MARSHAL_40, \"WriteIntPtr\", ves_icall_System_Runtime_InteropServices_Marshal_WriteIntPtr)\nICALL(MARSHAL_41, \"copy_from_unmanaged\", ves_icall_System_Runtime_InteropServices_Marshal_copy_from_unmanaged)\nICALL(MARSHAL_42, \"copy_to_unmanaged\", ves_icall_System_Runtime_InteropServices_Marshal_copy_to_unmanaged)\n\nICALL_TYPE(ACTS, \"System.Runtime.Remoting.Activation.ActivationServices\", ACTS_1)\nICALL(ACTS_1, \"AllocateUninitializedClassInstance\", ves_icall_System_Runtime_Activation_ActivationServices_AllocateUninitializedClassInstance)\nICALL(ACTS_2, \"EnableProxyActivation\", ves_icall_System_Runtime_Activation_ActivationServices_EnableProxyActivation)\n\nICALL_TYPE(MONOMM, \"System.Runtime.Remoting.Messaging.MonoMethodMessage\", MONOMM_1)\nICALL(MONOMM_1, \"InitMessage\", ves_icall_MonoMethodMessage_InitMessage)\n\nICALL_TYPE(REALP, \"System.Runtime.Remoting.Proxies.RealProxy\", REALP_1)\nICALL(REALP_1, \"InternalGetProxyType\", ves_icall_Remoting_RealProxy_InternalGetProxyType)\nICALL(REALP_2, \"InternalGetTransparentProxy\", ves_icall_Remoting_RealProxy_GetTransparentProxy)\n\nICALL_TYPE(REMSER, \"System.Runtime.Remoting.RemotingServices\", REMSER_0)\nICALL(REMSER_0, \"GetVirtualMethod\", ves_icall_Remoting_RemotingServices_GetVirtualMethod)\nICALL(REMSER_1, \"InternalExecute\", ves_icall_InternalExecute)\nICALL(REMSER_2, \"IsTransparentProxy\", ves_icall_IsTransparentProxy)\n\nICALL_TYPE(MHAN, \"System.RuntimeMethodHandle\", MHAN_1)\nICALL(MHAN_1, \"GetFunctionPointer\", ves_icall_RuntimeMethod_GetFunctionPointer)\n\nICALL_TYPE(RNG, \"System.Security.Cryptography.RNGCryptoServiceProvider\", RNG_1)\nICALL(RNG_1, \"RngClose\", ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngClose)\nICALL(RNG_2, \"RngGetBytes\", ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngGetBytes)\nICALL(RNG_3, \"RngInitialize\", ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngInitialize)\nICALL(RNG_4, \"RngOpen\", ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngOpen)\n\n#ifndef DISABLE_POLICY_EVIDENCE\nICALL_TYPE(EVID, \"System.Security.Policy.Evidence\", EVID_1)\nICALL(EVID_1, \"IsAuthenticodePresent\", ves_icall_System_Security_Policy_Evidence_IsAuthenticodePresent)\n\nICALL_TYPE(WINID, \"System.Security.Principal.WindowsIdentity\", WINID_1)\nICALL(WINID_1, \"GetCurrentToken\", ves_icall_System_Security_Principal_WindowsIdentity_GetCurrentToken)\nICALL(WINID_2, \"GetTokenName\", ves_icall_System_Security_Principal_WindowsIdentity_GetTokenName)\nICALL(WINID_3, \"GetUserToken\", ves_icall_System_Security_Principal_WindowsIdentity_GetUserToken)\nICALL(WINID_4, \"_GetRoles\", ves_icall_System_Security_Principal_WindowsIdentity_GetRoles)\n\nICALL_TYPE(WINIMP, \"System.Security.Principal.WindowsImpersonationContext\", WINIMP_1)\nICALL(WINIMP_1, \"CloseToken\", ves_icall_System_Security_Principal_WindowsImpersonationContext_CloseToken)\nICALL(WINIMP_2, \"DuplicateToken\", ves_icall_System_Security_Principal_WindowsImpersonationContext_DuplicateToken)\nICALL(WINIMP_3, \"RevertToSelf\", ves_icall_System_Security_Principal_WindowsImpersonationContext_RevertToSelf)\nICALL(WINIMP_4, \"SetCurrentToken\", ves_icall_System_Security_Principal_WindowsImpersonationContext_SetCurrentToken)\n\nICALL_TYPE(WINPRIN, \"System.Security.Principal.WindowsPrincipal\", WINPRIN_1)\nICALL(WINPRIN_1, \"IsMemberOfGroupId\", ves_icall_System_Security_Principal_WindowsPrincipal_IsMemberOfGroupId)\nICALL(WINPRIN_2, \"IsMemberOfGroupName\", ves_icall_System_Security_Principal_WindowsPrincipal_IsMemberOfGroupName)\n\nICALL_TYPE(SECSTRING, \"System.Security.SecureString\", SECSTRING_1)\nICALL(SECSTRING_1, \"DecryptInternal\", ves_icall_System_Security_SecureString_DecryptInternal)\nICALL(SECSTRING_2, \"EncryptInternal\", ves_icall_System_Security_SecureString_EncryptInternal)\n#endif /* !DISABLE_POLICY_EVIDENCE */\n\nICALL_TYPE(SECMAN, \"System.Security.SecurityManager\", SECMAN_1)\nICALL(SECMAN_1, \"GetLinkDemandSecurity\", ves_icall_System_Security_SecurityManager_GetLinkDemandSecurity)\nICALL(SECMAN_2, \"get_CheckExecutionRights\", ves_icall_System_Security_SecurityManager_get_CheckExecutionRights)\nICALL(SECMAN_3, \"get_SecurityEnabled\", ves_icall_System_Security_SecurityManager_get_SecurityEnabled)\nICALL(SECMAN_4, \"set_CheckExecutionRights\", ves_icall_System_Security_SecurityManager_set_CheckExecutionRights)\nICALL(SECMAN_5, \"set_SecurityEnabled\", ves_icall_System_Security_SecurityManager_set_SecurityEnabled)\n\nICALL_TYPE(STRING, \"System.String\", STRING_1)\nICALL(STRING_1, \".ctor(char*)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_2, \".ctor(char*,int,int)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_3, \".ctor(char,int)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_4, \".ctor(char[])\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_5, \".ctor(char[],int,int)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_6, \".ctor(sbyte*)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_7, \".ctor(sbyte*,int,int)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_8, \".ctor(sbyte*,int,int,System.Text.Encoding)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_9, \"InternalAllocateStr\", ves_icall_System_String_InternalAllocateStr)\nICALL(STRING_10, \"InternalIntern\", ves_icall_System_String_InternalIntern)\nICALL(STRING_11, \"InternalIsInterned\", ves_icall_System_String_InternalIsInterned)\nICALL(STRING_12, \"InternalSplit\", ves_icall_System_String_InternalSplit)\n\nICALL_TYPE(TENC, \"System.Text.Encoding\", TENC_1)\nICALL(TENC_1, \"InternalCodePage\", ves_icall_System_Text_Encoding_InternalCodePage)\n\nICALL_TYPE(ILOCK, \"System.Threading.Interlocked\", ILOCK_1)\nICALL(ILOCK_1, \"Add(int&,int)\", ves_icall_System_Threading_Interlocked_Add_Int)\nICALL(ILOCK_2, \"Add(long&,long)\", ves_icall_System_Threading_Interlocked_Add_Long)\nICALL(ILOCK_3, \"CompareExchange(T&,T,T)\", ves_icall_System_Threading_Interlocked_CompareExchange_T)\nICALL(ILOCK_4, \"CompareExchange(double&,double,double)\", ves_icall_System_Threading_Interlocked_CompareExchange_Double)\nICALL(ILOCK_5, \"CompareExchange(int&,int,int)\", ves_icall_System_Threading_Interlocked_CompareExchange_Int)\nICALL(ILOCK_6, \"CompareExchange(intptr&,intptr,intptr)\", ves_icall_System_Threading_Interlocked_CompareExchange_IntPtr)\nICALL(ILOCK_7, \"CompareExchange(long&,long,long)\", ves_icall_System_Threading_Interlocked_CompareExchange_Long)\nICALL(ILOCK_8, \"CompareExchange(object&,object,object)\", ves_icall_System_Threading_Interlocked_CompareExchange_Object)\nICALL(ILOCK_9, \"CompareExchange(single&,single,single)\", ves_icall_System_Threading_Interlocked_CompareExchange_Single)\nICALL(ILOCK_10, \"Decrement(int&)\", ves_icall_System_Threading_Interlocked_Decrement_Int)\nICALL(ILOCK_11, \"Decrement(long&)\", ves_icall_System_Threading_Interlocked_Decrement_Long)\nICALL(ILOCK_12, \"Exchange(T&,T)\", ves_icall_System_Threading_Interlocked_Exchange_T)\nICALL(ILOCK_13, \"Exchange(double&,double)\", ves_icall_System_Threading_Interlocked_Exchange_Double)\nICALL(ILOCK_14, \"Exchange(int&,int)\", ves_icall_System_Threading_Interlocked_Exchange_Int)\nICALL(ILOCK_15, \"Exchange(intptr&,intptr)\", ves_icall_System_Threading_Interlocked_Exchange_IntPtr)\nICALL(ILOCK_16, \"Exchange(long&,long)\", ves_icall_System_Threading_Interlocked_Exchange_Long)\nICALL(ILOCK_17, \"Exchange(object&,object)\", ves_icall_System_Threading_Interlocked_Exchange_Object)\nICALL(ILOCK_18, \"Exchange(single&,single)\", ves_icall_System_Threading_Interlocked_Exchange_Single)\nICALL(ILOCK_19, \"Increment(int&)\", ves_icall_System_Threading_Interlocked_Increment_Int)\nICALL(ILOCK_20, \"Increment(long&)\", ves_icall_System_Threading_Interlocked_Increment_Long)\nICALL(ILOCK_21, \"Read(long&)\", ves_icall_System_Threading_Interlocked_Read_Long)\n\nICALL_TYPE(MONIT, \"System.Threading.Monitor\", MONIT_8)\nICALL(MONIT_8, \"Enter\", mono_monitor_enter)\nICALL(MONIT_1, \"Exit\", mono_monitor_exit)\nICALL(MONIT_2, \"Monitor_pulse\", ves_icall_System_Threading_Monitor_Monitor_pulse)\nICALL(MONIT_3, \"Monitor_pulse_all\", ves_icall_System_Threading_Monitor_Monitor_pulse_all)\nICALL(MONIT_4, \"Monitor_test_owner\", ves_icall_System_Threading_Monitor_Monitor_test_owner)\nICALL(MONIT_5, \"Monitor_test_synchronised\", ves_icall_System_Threading_Monitor_Monitor_test_synchronised)\nICALL(MONIT_6, \"Monitor_try_enter\", ves_icall_System_Threading_Monitor_Monitor_try_enter)\nICALL(MONIT_7, \"Monitor_wait\", ves_icall_System_Threading_Monitor_Monitor_wait)\n\nICALL_TYPE(MUTEX, \"System.Threading.Mutex\", MUTEX_1)\nICALL(MUTEX_1, \"CreateMutex_internal(bool,string,bool&)\", ves_icall_System_Threading_Mutex_CreateMutex_internal)\nICALL(MUTEX_2, \"OpenMutex_internal(string,System.Security.AccessControl.MutexRights,System.IO.MonoIOError&)\", ves_icall_System_Threading_Mutex_OpenMutex_internal)\nICALL(MUTEX_3, \"ReleaseMutex_internal(intptr)\", ves_icall_System_Threading_Mutex_ReleaseMutex_internal)\n\nICALL_TYPE(NATIVEC, \"System.Threading.NativeEventCalls\", NATIVEC_1)\nICALL(NATIVEC_1, \"CloseEvent_internal\", ves_icall_System_Threading_Events_CloseEvent_internal)\nICALL(NATIVEC_2, \"CreateEvent_internal(bool,bool,string,bool&)\", ves_icall_System_Threading_Events_CreateEvent_internal)\nICALL(NATIVEC_3, \"OpenEvent_internal(string,System.Security.AccessControl.EventWaitHandleRights,System.IO.MonoIOError&)\", ves_icall_System_Threading_Events_OpenEvent_internal)\nICALL(NATIVEC_4, \"ResetEvent_internal\",  ves_icall_System_Threading_Events_ResetEvent_internal)\nICALL(NATIVEC_5, \"SetEvent_internal\",    ves_icall_System_Threading_Events_SetEvent_internal)\n\nICALL_TYPE(SEMA, \"System.Threading.Semaphore\", SEMA_1)\nICALL(SEMA_1, \"CreateSemaphore_internal(int,int,string,bool&)\", ves_icall_System_Threading_Semaphore_CreateSemaphore_internal)\nICALL(SEMA_2, \"OpenSemaphore_internal(string,System.Security.AccessControl.SemaphoreRights,System.IO.MonoIOError&)\", ves_icall_System_Threading_Semaphore_OpenSemaphore_internal)\nICALL(SEMA_3, \"ReleaseSemaphore_internal(intptr,int,bool&)\", ves_icall_System_Threading_Semaphore_ReleaseSemaphore_internal)\n\nICALL_TYPE(THREAD, \"System.Threading.Thread\", THREAD_1)\nICALL(THREAD_1, \"Abort_internal(object)\", ves_icall_System_Threading_Thread_Abort)\nICALL(THREAD_2, \"ClrState\", ves_icall_System_Threading_Thread_ClrState)\nICALL(THREAD_3, \"CurrentThread_internal\", mono_thread_current)\nICALL(THREAD_4, \"FreeLocalSlotValues\", mono_thread_free_local_slot_values)\nICALL(THREAD_55, \"GetAbortExceptionState\", ves_icall_System_Threading_Thread_GetAbortExceptionState)\nICALL(THREAD_5, \"GetCachedCurrentCulture\", ves_icall_System_Threading_Thread_GetCachedCurrentCulture)\nICALL(THREAD_6, \"GetCachedCurrentUICulture\", ves_icall_System_Threading_Thread_GetCachedCurrentUICulture)\nICALL(THREAD_7, \"GetDomainID\", ves_icall_System_Threading_Thread_GetDomainID)\nICALL(THREAD_8, \"GetName_internal\", ves_icall_System_Threading_Thread_GetName_internal)\nICALL(THREAD_9, \"GetSerializedCurrentCulture\", ves_icall_System_Threading_Thread_GetSerializedCurrentCulture)\nICALL(THREAD_10, \"GetSerializedCurrentUICulture\", ves_icall_System_Threading_Thread_GetSerializedCurrentUICulture)\nICALL(THREAD_11, \"GetState\", ves_icall_System_Threading_Thread_GetState)\nICALL(THREAD_53, \"Interrupt_internal\", ves_icall_System_Threading_Thread_Interrupt_internal)\nICALL(THREAD_12, \"Join_internal\", ves_icall_System_Threading_Thread_Join_internal)\nICALL(THREAD_13, \"MemoryBarrier\", ves_icall_System_Threading_Thread_MemoryBarrier)\nICALL(THREAD_14, \"ResetAbort_internal()\", ves_icall_System_Threading_Thread_ResetAbort)\nICALL(THREAD_15, \"Resume_internal()\", ves_icall_System_Threading_Thread_Resume)\nICALL(THREAD_16, \"SetCachedCurrentCulture\", ves_icall_System_Threading_Thread_SetCachedCurrentCulture)\nICALL(THREAD_17, \"SetCachedCurrentUICulture\", ves_icall_System_Threading_Thread_SetCachedCurrentUICulture)\nICALL(THREAD_18, \"SetName_internal\", ves_icall_System_Threading_Thread_SetName_internal)\nICALL(THREAD_19, \"SetSerializedCurrentCulture\", ves_icall_System_Threading_Thread_SetSerializedCurrentCulture)\nICALL(THREAD_20, \"SetSerializedCurrentUICulture\", ves_icall_System_Threading_Thread_SetSerializedCurrentUICulture)\nICALL(THREAD_21, \"SetState\", ves_icall_System_Threading_Thread_SetState)\nICALL(THREAD_22, \"Sleep_internal\", ves_icall_System_Threading_Thread_Sleep_internal)\nICALL(THREAD_54, \"SpinWait_nop\", ves_icall_System_Threading_Thread_SpinWait_nop)\nICALL(THREAD_23, \"Suspend_internal\", ves_icall_System_Threading_Thread_Suspend)\nICALL(THREAD_24, \"Thread_free_internal\", ves_icall_System_Threading_Thread_Thread_free_internal)\nICALL(THREAD_24a, \"Thread_init\", ves_icall_System_Threading_Thread_Thread_init)\nICALL(THREAD_25, \"Thread_internal\", ves_icall_System_Threading_Thread_Thread_internal)\nICALL(THREAD_26, \"VolatileRead(byte&)\", ves_icall_System_Threading_Thread_VolatileRead1)\nICALL(THREAD_27, \"VolatileRead(double&)\", ves_icall_System_Threading_Thread_VolatileRead8)\nICALL(THREAD_28, \"VolatileRead(int&)\", ves_icall_System_Threading_Thread_VolatileRead4)\nICALL(THREAD_29, \"VolatileRead(int16&)\", ves_icall_System_Threading_Thread_VolatileRead2)\nICALL(THREAD_30, \"VolatileRead(intptr&)\", ves_icall_System_Threading_Thread_VolatileReadIntPtr)\nICALL(THREAD_31, \"VolatileRead(long&)\", ves_icall_System_Threading_Thread_VolatileRead8)\nICALL(THREAD_32, \"VolatileRead(object&)\", ves_icall_System_Threading_Thread_VolatileReadIntPtr)\nICALL(THREAD_33, \"VolatileRead(sbyte&)\", ves_icall_System_Threading_Thread_VolatileRead1)\nICALL(THREAD_34, \"VolatileRead(single&)\", ves_icall_System_Threading_Thread_VolatileRead4)\nICALL(THREAD_35, \"VolatileRead(uint&)\", ves_icall_System_Threading_Thread_VolatileRead2)\nICALL(THREAD_36, \"VolatileRead(uint16&)\", ves_icall_System_Threading_Thread_VolatileRead2)\nICALL(THREAD_37, \"VolatileRead(uintptr&)\", ves_icall_System_Threading_Thread_VolatileReadIntPtr)\nICALL(THREAD_38, \"VolatileRead(ulong&)\", ves_icall_System_Threading_Thread_VolatileRead8)\nICALL(THREAD_39, \"VolatileWrite(byte&,byte)\", ves_icall_System_Threading_Thread_VolatileWrite1)\nICALL(THREAD_40, \"VolatileWrite(double&,double)\", ves_icall_System_Threading_Thread_VolatileWrite8)\nICALL(THREAD_41, \"VolatileWrite(int&,int)\", ves_icall_System_Threading_Thread_VolatileWrite4)\nICALL(THREAD_42, \"VolatileWrite(int16&,int16)\", ves_icall_System_Threading_Thread_VolatileWrite2)\nICALL(THREAD_43, \"VolatileWrite(intptr&,intptr)\", ves_icall_System_Threading_Thread_VolatileWriteIntPtr)\nICALL(THREAD_44, \"VolatileWrite(long&,long)\", ves_icall_System_Threading_Thread_VolatileWrite8)\nICALL(THREAD_45, \"VolatileWrite(object&,object)\", ves_icall_System_Threading_Thread_VolatileWriteObject)\nICALL(THREAD_46, \"VolatileWrite(sbyte&,sbyte)\", ves_icall_System_Threading_Thread_VolatileWrite1)\nICALL(THREAD_47, \"VolatileWrite(single&,single)\", ves_icall_System_Threading_Thread_VolatileWrite4)\nICALL(THREAD_48, \"VolatileWrite(uint&,uint)\", ves_icall_System_Threading_Thread_VolatileWrite2)\nICALL(THREAD_49, \"VolatileWrite(uint16&,uint16)\", ves_icall_System_Threading_Thread_VolatileWrite2)\nICALL(THREAD_50, \"VolatileWrite(uintptr&,uintptr)\", ves_icall_System_Threading_Thread_VolatileWriteIntPtr)\nICALL(THREAD_51, \"VolatileWrite(ulong&,ulong)\", ves_icall_System_Threading_Thread_VolatileWrite8)\nICALL(THREAD_52, \"current_lcid()\", ves_icall_System_Threading_Thread_current_lcid)\n\nICALL_TYPE(THREADP, \"System.Threading.ThreadPool\", THREADP_1)\nICALL(THREADP_1, \"GetAvailableThreads\", ves_icall_System_Threading_ThreadPool_GetAvailableThreads)\nICALL(THREADP_2, \"GetMaxThreads\", ves_icall_System_Threading_ThreadPool_GetMaxThreads)\nICALL(THREADP_3, \"GetMinThreads\", ves_icall_System_Threading_ThreadPool_GetMinThreads)\nICALL(THREADP_35, \"SetMaxThreads\", ves_icall_System_Threading_ThreadPool_SetMaxThreads)\nICALL(THREADP_4, \"SetMinThreads\", ves_icall_System_Threading_ThreadPool_SetMinThreads)\n\nICALL_TYPE(WAITH, \"System.Threading.WaitHandle\", WAITH_1)\nICALL(WAITH_1, \"SignalAndWait_Internal\", ves_icall_System_Threading_WaitHandle_SignalAndWait_Internal)\nICALL(WAITH_2, \"WaitAll_internal\", ves_icall_System_Threading_WaitHandle_WaitAll_internal)\nICALL(WAITH_3, \"WaitAny_internal\", ves_icall_System_Threading_WaitHandle_WaitAny_internal)\nICALL(WAITH_4, \"WaitOne_internal\", ves_icall_System_Threading_WaitHandle_WaitOne_internal)\n\nICALL_TYPE(TYPE, \"System.Type\", TYPE_1)\nICALL(TYPE_1, \"EqualsInternal\", ves_icall_System_Type_EqualsInternal)\nICALL(TYPE_2, \"GetGenericParameterAttributes\", ves_icall_Type_GetGenericParameterAttributes)\nICALL(TYPE_3, \"GetGenericParameterConstraints_impl\", ves_icall_Type_GetGenericParameterConstraints)\nICALL(TYPE_4, \"GetGenericParameterPosition\", ves_icall_Type_GetGenericParameterPosition)\nICALL(TYPE_5, \"GetGenericTypeDefinition_impl\", ves_icall_Type_GetGenericTypeDefinition_impl)\nICALL(TYPE_6, \"GetInterfaceMapData\", ves_icall_Type_GetInterfaceMapData)\nICALL(TYPE_7, \"GetPacking\", ves_icall_Type_GetPacking)\nICALL(TYPE_8, \"GetTypeCode\", ves_icall_type_GetTypeCodeInternal)\nICALL(TYPE_9, \"GetTypeCodeInternal\", ves_icall_type_GetTypeCodeInternal)\nICALL(TYPE_10, \"IsArrayImpl\", ves_icall_Type_IsArrayImpl)\nICALL(TYPE_11, \"IsInstanceOfType\", ves_icall_type_IsInstanceOfType)\nICALL(TYPE_12, \"MakeGenericType\", ves_icall_Type_MakeGenericType)\nICALL(TYPE_13, \"MakePointerType\", ves_icall_Type_MakePointerType)\nICALL(TYPE_14, \"get_IsGenericInstance\", ves_icall_Type_get_IsGenericInstance)\nICALL(TYPE_15, \"get_IsGenericType\", ves_icall_Type_get_IsGenericType)\nICALL(TYPE_16, \"get_IsGenericTypeDefinition\", ves_icall_Type_get_IsGenericTypeDefinition)\nICALL(TYPE_17, \"internal_from_handle\", ves_icall_type_from_handle)\nICALL(TYPE_18, \"internal_from_name\", ves_icall_type_from_name)\nICALL(TYPE_19, \"make_array_type\", ves_icall_Type_make_array_type)\nICALL(TYPE_20, \"make_byref_type\", ves_icall_Type_make_byref_type)\nICALL(TYPE_21, \"type_is_assignable_from\", ves_icall_type_is_assignable_from)\nICALL(TYPE_22, \"type_is_subtype_of\", ves_icall_type_is_subtype_of)\n\nICALL_TYPE(TYPEDR, \"System.TypedReference\", TYPEDR_1)\nICALL(TYPEDR_1, \"ToObject\",\tmono_TypedReference_ToObject)\nICALL(TYPEDR_2, \"ToObjectInternal\",\tmono_TypedReference_ToObjectInternal)\n\nICALL_TYPE(VALUET, \"System.ValueType\", VALUET_1)\nICALL(VALUET_1, \"InternalEquals\", ves_icall_System_ValueType_Equals)\nICALL(VALUET_2, \"InternalGetHashCode\", ves_icall_System_ValueType_InternalGetHashCode)\n\nICALL_TYPE(WEBIC, \"System.Web.Util.ICalls\", WEBIC_1)\nICALL(WEBIC_1, \"GetMachineConfigPath\", ves_icall_System_Configuration_DefaultConfig_get_machine_config_path)\nICALL(WEBIC_2, \"GetMachineInstallDirectory\", ves_icall_System_Web_Util_ICalls_get_machine_install_dir)\nICALL(WEBIC_3, \"GetUnmanagedResourcesPtr\", ves_icall_get_resources_ptr)\n\n#ifndef DISABLE_COM\nICALL_TYPE(COMOBJ, \"System.__ComObject\", COMOBJ_1)\nICALL(COMOBJ_1, \"CreateRCW\", ves_icall_System_ComObject_CreateRCW)\nICALL(COMOBJ_2, \"GetInterfaceInternal\", ves_icall_System_ComObject_GetInterfaceInternal)\nICALL(COMOBJ_3, \"ReleaseInterfaces\", ves_icall_System_ComObject_ReleaseInterfaces)\n#endif\n", "#ifndef __MONO_OBJECT_INTERNALS_H__\n#define __MONO_OBJECT_INTERNALS_H__\n\n#include <mono/metadata/object.h>\n#include <mono/metadata/threads.h>\n#include <mono/metadata/reflection.h>\n#include <mono/metadata/mempool.h>\n#include <mono/metadata/class-internals.h>\n#include <mono/io-layer/io-layer.h>\n#include \"mono/utils/mono-compiler.h\"\n#include \"mono/utils/mono-error.h\"\n\n/* \n * We should find a better place for this stuff. We can't put it in mono-compiler.h,\n * since that is included by libgc.\n */\n#ifndef G_LIKELY\n#define G_LIKELY(a) (a)\n#define G_UNLIKELY(a) (a)\n#endif\n\n/*\n * glib defines this macro and uses it in the definition of G_LIKELY, and thus,\n * g_assert (). The macro expands to a complex piece of code, preventing some\n * gcc versions like 4.3.0 from handling the __builtin_expect construct properly,\n * causing the generation of the unlikely branch into the middle of the code.\n */\n#ifdef _G_BOOLEAN_EXPR\n#undef _G_BOOLEAN_EXPR\n#define _G_BOOLEAN_EXPR(expr) ((gsize)(expr) != 0)\n#endif\n\n#if 1\n#ifdef __GNUC__\n#define mono_assert(expr)\t\t   G_STMT_START{\t\t  \\\n     if (!(expr))\t\t\t\t\t\t\t  \\\n       {\t\t\t\t\t\t\t\t  \\\n\t\tMonoException *ex;\t\t\t\t\t  \\\n\t\tchar *msg = g_strdup_printf (\"file %s: line %d (%s): \"\t  \\\n\t\t\"assertion failed: (%s)\", __FILE__, __LINE__,\t\t  \\\n\t\t__PRETTY_FUNCTION__, #expr);\t\t\t\t  \\\n\t\tex = mono_get_exception_execution_engine (msg);\t\t  \\\n\t\tg_free (msg);\t\t\t\t\t\t  \\\n\t\tmono_raise_exception (ex);\t\t\t\t  \\\n       };\t\t\t\t}G_STMT_END\n\n#define mono_assert_not_reached()\t\t  G_STMT_START{\t\t  \\\n     MonoException *ex;\t\t\t\t\t\t\t  \\\n     char *msg = g_strdup_printf (\"file %s: line %d (%s): \"\t\t  \\\n     \"should not be reached\", __FILE__, __LINE__, __PRETTY_FUNCTION__);\t  \\\n     ex = mono_get_exception_execution_engine (msg);\t\t\t  \\\n     g_free (msg);\t\t\t\t\t\t\t  \\\n     mono_raise_exception (ex);\t\t\t\t\t\t  \\\n}G_STMT_END\n#else /* not GNUC */\n#define mono_assert(expr)\t\t   G_STMT_START{\t\t  \\\n     if (!(expr))\t\t\t\t\t\t\t  \\\n       {\t\t\t\t\t\t\t\t  \\\n\t\tMonoException *ex;\t\t\t\t\t  \\\n\t\tchar *msg = g_strdup_printf (\"file %s: line %d: \"\t  \\\n\t\t\"assertion failed: (%s)\", __FILE__, __LINE__,\t\t  \\\n\t\t#expr);\t\t\t\t\t\t\t  \\\n\t\tex = mono_get_exception_execution_engine (msg);\t\t  \\\n\t\tg_free (msg);\t\t\t\t\t\t  \\\n\t\tmono_raise_exception (ex);\t\t\t\t  \\\n       };\t\t\t\t}G_STMT_END\n\n#define mono_assert_not_reached()\t\t  G_STMT_START{\t\t  \\\n     MonoException *ex;\t\t\t\t\t\t\t  \\\n     char *msg = g_strdup_printf (\"file %s: line %d): \"\t\t\t  \\\n     \"should not be reached\", __FILE__, __LINE__);\t\t\t  \\\n     ex = mono_get_exception_execution_engine (msg);\t\t\t  \\\n     g_free (msg);\t\t\t\t\t\t\t  \\\n     mono_raise_exception (ex);\t\t\t\t\t\t  \\\n}G_STMT_END\n#endif\n#else\n#define mono_assert(expr) g_assert(expr)\n#define mono_assert_not_reached() g_assert_not_reached() \n#endif\n\n#define MONO_CHECK_ARG(arg, expr)\t\tG_STMT_START{\t\t  \\\n     if (!(expr))\t\t\t\t\t\t\t  \\\n       {\t\t\t\t\t\t\t\t  \\\n\t\tMonoException *ex;\t\t\t\t\t  \\\n\t\tchar *msg = g_strdup_printf (\"assertion `%s' failed\",\t  \\\n\t\t#expr);\t\t\t\t\t\t\t  \\\n\t\tif (arg) {} /* check if the name exists */\t\t  \\\n\t\tex = mono_get_exception_argument (#arg, msg);\t\t  \\\n\t\tg_free (msg);\t\t\t\t\t\t  \\\n\t\tmono_raise_exception (ex);\t\t\t\t  \\\n       };\t\t\t\t}G_STMT_END\n\n#define MONO_CHECK_ARG_NULL(arg)\t    G_STMT_START{\t\t  \\\n     if (arg == NULL)\t\t\t\t\t\t\t  \\\n       {\t\t\t\t\t\t\t\t  \\\n\t\tMonoException *ex;\t\t\t\t\t  \\\n\t\tif (arg) {} /* check if the name exists */\t\t  \\\n\t\tex = mono_get_exception_argument_null (#arg);\t\t  \\\n\t\tmono_raise_exception (ex);\t\t\t\t  \\\n       };\t\t\t\t}G_STMT_END\n\n/* 16 == default capacity */\n#define mono_stringbuilder_capacity(sb) ((sb)->str ? ((sb)->str->length) : 16)\n\n/* \n * Macros which cache the results of lookups locally.\n * These should be used instead of the original versions, if the __GNUC__\n * restriction is acceptable.\n */\n\n#ifdef __GNUC__\n\n/* namespace and name should be a constant */\n#define mono_class_from_name_cached(image,namespace,name) ({ \\\n\t\t\tstatic MonoClass *tmp_klass; \\\n\t\t\tif (!tmp_klass) { \\\n\t\t\t\ttmp_klass = mono_class_from_name ((image), (namespace), (name)); \\\n\t\t\t\tg_assert (tmp_klass); \\\n\t\t\t}; \\\n\t\t\ttmp_klass; })\n/* name should be a compile-time constant */\n#define mono_class_get_field_from_name_cached(klass,name) ({ \\\n\t\t\tstatic MonoClassField *tmp_field; \\\n\t\t\tif (!tmp_field) { \\\n\t\t\t\ttmp_field = mono_class_get_field_from_name ((klass), (name)); \\\n\t\t\t\tg_assert (tmp_field); \\\n\t\t\t}; \\\n\t\t\ttmp_field; })\n/* eclass should be a run-time constant */\n#define mono_array_class_get_cached(eclass,rank) ({\t\\\n\t\t\tstatic MonoClass *tmp_klass; \\\n\t\t\tif (!tmp_klass) { \\\n\t\t\t\ttmp_klass = mono_array_class_get ((eclass), (rank));\t\\\n\t\t\t\tg_assert (tmp_klass); \\\n\t\t\t}; \\\n\t\t\ttmp_klass; })\n/* eclass should be a run-time constant */\n#define mono_array_new_cached(domain, eclass, size) mono_array_new_specific (mono_class_vtable ((domain), mono_array_class_get_cached ((eclass), 1)), (size))\n\n#else\n\n#define mono_class_from_name_cached(image,namespace,name) mono_class_from_name ((image), (namespace), (name))\n#define mono_class_get_field_from_name_cached(klass,name) mono_class_get_field_from_name ((klass), (name))\n#define mono_array_class_get_cached(eclass,rank) mono_array_class_get ((eclass), (rank))\n#define mono_array_new_cached(domain, eclass, size) mono_array_new_specific (mono_class_vtable ((domain), mono_array_class_get_cached ((eclass), 1)), (size))\n\n#endif\n\ntypedef struct {\n\tMonoObject obj;\n\tMonoObject *identity;\n} MonoMarshalByRefObject;\n\n/* This is a copy of System.AppDomain */\nstruct _MonoAppDomain {\n\tMonoMarshalByRefObject mbr;\n\tMonoDomain *data;\n};\n\ntypedef struct {\n\tMonoObject object;\n\tgint32 length;\n\tMonoString *str;\n\tMonoString *cached_str;\n\tgint32 max_capacity;\n} MonoStringBuilder;\n\ntypedef struct {\n\tMonoType *type;\n\tgpointer  value;\n\tMonoClass *klass;\n} MonoTypedRef;\n\ntypedef struct {\n\tgpointer args;\n} MonoArgumentHandle;\n\ntypedef struct {\n\tMonoMethodSignature *sig;\n\tgpointer args;\n\tgint32 next_arg;\n\tgint32 num_args;\n} MonoArgIterator;\n\nstruct _MonoException {\n\tMonoObject object;\n\t/* Stores the IPs and the generic sharing infos\n\t   (vtable/MRGCTX) of the frames. */\n\tMonoArray  *trace_ips;\n\tMonoObject *inner_ex;\n\tMonoString *message;\n\tMonoString *help_link;\n\tMonoString *class_name;\n\tMonoString *stack_trace;\n\tMonoString *remote_stack_trace;\n\tgint32\t    remote_stack_index;\n\tgint32\t    hresult;\n\tMonoString *source;\n\tMonoObject *_data;\n};\n\ntypedef struct {\n\tMonoException base;\n} MonoSystemException;\n\ntypedef struct {\n\tMonoSystemException base;\n\tMonoString *param_name;\n} MonoArgumentException;\n\ntypedef struct {\n\tMonoSystemException base;\n\tMonoString *msg;\n\tMonoString *type_name;\n} MonoTypeLoadException;\n\ntypedef struct {\n\tMonoObject   object;\n\tMonoObject  *async_state;\n\tMonoObject  *handle;\n\tMonoObject  *async_delegate;\n\tgpointer    *data;\n\tMonoObject  *object_data;\n\tMonoBoolean  sync_completed;\n\tMonoBoolean  completed;\n\tMonoBoolean  endinvoke_called;\n\tMonoObject  *async_callback;\n\tMonoObject  *execution_context;\n\tMonoObject  *original_context;\n} MonoAsyncResult;\n\ntypedef struct {\n\tMonoMarshalByRefObject object;\n\tgpointer     handle;\n\tMonoBoolean  disposed;\n} MonoWaitHandle;\n\n/* This is a copy of System.Runtime.Remoting.Messaging.CallType */\ntypedef enum {\n\tCallType_Sync = 0,\n\tCallType_BeginInvoke = 1,\n\tCallType_EndInvoke = 2,\n\tCallType_OneWay = 3\n} MonoCallType;\n\n/* This corresponds to System.Type */\nstruct _MonoReflectionType {\n\tMonoObject object;\n\tMonoType  *type;\n};\n\ntypedef struct {\n\tMonoReflectionType type;\n\tMonoObject *type_info;\n} MonoReflectionMonoType;\n\ntypedef struct {\n\tMonoObject  object;\n\tMonoReflectionType *class_to_proxy;\t\n\tMonoObject *context;\n\tMonoObject *unwrapped_server;\n\tgint32      target_domain_id;\n\tMonoString *target_uri;\n\tMonoObject *object_identity;\n\tMonoObject *obj_TP;\n\tMonoObject *stub_data;\n} MonoRealProxy;\n\ntypedef struct {\n\tMonoMarshalByRefObject object;\n\tgpointer iunknown;\n\tGHashTable* itf_hash;\n} MonoComObject;\n\ntypedef struct {\n\tMonoRealProxy real_proxy;\n\tMonoComObject *com_object;\n\tgint32 ref_count;\n} MonoComInteropProxy;\n\ntypedef struct {\n\tMonoObject\t object;\n\tMonoRealProxy\t*rp;\t\n\tMonoRemoteClass *remote_class;\n\tMonoBoolean\t custom_type_info;\n} MonoTransparentProxy;\n\ntypedef struct {\n\tMonoObject obj;\n\tMonoReflectionMethod *method;\n\tMonoArray  *args;\t\t\n\tMonoArray  *names;\t\t\n\tMonoArray  *arg_types;\t\n\tMonoObject *ctx;\n\tMonoObject *rval;\n\tMonoObject *exc;\n\tMonoAsyncResult *async_result;\n\tguint32\t    call_type;\n} MonoMethodMessage;\n\ntypedef struct {\n\tMonoObject obj;\n\tgint32 il_offset;\n\tgint32 native_offset;\n\tMonoReflectionMethod *method;\n\tMonoString *filename;\n\tgint32 line;\n\tgint32 column;\n\tMonoString *internal_method_name;\n} MonoStackFrame;\n\ntypedef enum {\n\tMONO_THREAD_FLAG_DONT_MANAGE = 1, // Don't wait for or abort this thread\n} MonoThreadFlags;\n\nstruct _MonoThread {\n\tMonoObject  obj;\n\tint         lock_thread_id; /* to be used as the pre-shifted thread id in thin locks */\n\tHANDLE\t    handle;\n\tMonoArray  *cached_culture_info;\n\tgpointer    unused1;\n\tMonoBoolean threadpool_thread;\n\tgunichar2  *name;\n\tguint32\t    name_len;\n\tguint32\t    state;\n\tMonoException *abort_exc;\n\tint abort_state_handle;\n\tguint64 tid;\t/* This is accessed as a gsize in the code (so it can hold a 64bit pointer on systems that need it), but needs to reserve 64 bits of space on all machines as it corresponds to a field in managed code */\n\tHANDLE\t    start_notify;\n\tgpointer stack_ptr;\n\tgpointer *static_data;\n\tgpointer jit_data;\n\tgpointer lock_data;\n\tMonoAppContext *current_appcontext;\n\tint stack_size;\n\tMonoObject *start_obj;\n\tGSList *appdomain_refs;\n\t/* This is modified using atomic ops, so keep it a gint32 */\n\tgint32 interruption_requested;\n\tgpointer suspend_event;\n\tgpointer suspended_event;\n\tgpointer resume_event;\n\tCRITICAL_SECTION *synch_cs;\n\tguint8* serialized_culture_info;\n\tguint32 serialized_culture_info_len;\n\tguint8* serialized_ui_culture_info;\n\tguint32 serialized_ui_culture_info_len;\n\tMonoBoolean thread_dump_requested;\n\tgpointer end_stack; /* This is only used when running in the debugger. */\n\tMonoBoolean thread_interrupt_requested;\n\tguint8\tapartment_state;\n\tgint32 critical_region_level;\n\tguint32 small_id; /* A small, unique id, used for the hazard pointer table. */\n\tMonoThreadManageCallback manage_callback;\n\tMonoException *pending_exception;\n\tMonoObject *ec_to_set;\n\t/* \n\t * These fields are used to avoid having to increment corlib versions\n\t * when a new field is added to the unmanaged MonoThread structure.\n\t */\n\tgpointer interrupt_on_stop;\n\tgsize    flags;\n\tgpointer unused4;\n\tgpointer unused5;\n\tgpointer unused6;\n};\n\ntypedef struct {\n\tMonoString *name;\n\tMonoReflectionType *type;\n\tMonoObject *value;\n} MonoSerializationEntry;\n\ntypedef struct {\n\tguint32 state;\n\tMonoObject *additional;\n} MonoStreamingContext;\n\ntypedef struct {\n\tMonoObject obj;\n\tMonoBoolean readOnly;\n\tMonoString *AMDesignator;\n\tMonoString *PMDesignator;\n\tMonoString *DateSeparator;\n\tMonoString *TimeSeparator;\n\tMonoString *ShortDatePattern;\n\tMonoString *LongDatePattern;\n\tMonoString *ShortTimePattern;\n\tMonoString *LongTimePattern;\n\tMonoString *MonthDayPattern;\n\tMonoString *YearMonthPattern;\n\tMonoString *FullDateTimePattern;\n\tMonoString *RFC1123Pattern;\n\tMonoString *SortableDateTimePattern;\n\tMonoString *UniversalSortableDateTimePattern;\n\tguint32 FirstDayOfWeek;\n\tMonoObject *Calendar;\n\tguint32 CalendarWeekRule;\n\tMonoArray *AbbreviatedDayNames;\n\tMonoArray *DayNames;\n\tMonoArray *MonthNames;\n\tMonoArray *AbbreviatedMonthNames;\n\tMonoArray *ShortDatePatterns;\n\tMonoArray *LongDatePatterns;\n\tMonoArray *ShortTimePatterns;\n\tMonoArray *LongTimePatterns;\n\tMonoArray *MonthDayPatterns;\n\tMonoArray *YearMonthPatterns;\n\tMonoArray *shortDayNames;\n} MonoDateTimeFormatInfo;\n\ntypedef struct \n{\n\tMonoObject obj;\n\tMonoBoolean readOnly;\n\tMonoString *decimalFormats;\n\tMonoString *currencyFormats;\n\tMonoString *percentFormats;\n\tMonoString *digitPattern;\n\tMonoString *zeroPattern;\n\tgint32 currencyDecimalDigits;\n\tMonoString *currencyDecimalSeparator;\n\tMonoString *currencyGroupSeparator;\n\tMonoArray *currencyGroupSizes;\n\tgint32 currencyNegativePattern;\n\tgint32 currencyPositivePattern;\n\tMonoString *currencySymbol;\n\tMonoString *naNSymbol;\n\tMonoString *negativeInfinitySymbol;\n\tMonoString *negativeSign;\n\tguint32 numberDecimalDigits;\n\tMonoString *numberDecimalSeparator;\n\tMonoString *numberGroupSeparator;\n\tMonoArray *numberGroupSizes;\n\tgint32 numberNegativePattern;\n\tgint32 percentDecimalDigits;\n\tMonoString *percentDecimalSeparator;\n\tMonoString *percentGroupSeparator;\n\tMonoArray *percentGroupSizes;\n\tgint32 percentNegativePattern;\n\tgint32 percentPositivePattern;\n\tMonoString *percentSymbol;\n\tMonoString *perMilleSymbol;\n\tMonoString *positiveInfinitySymbol;\n\tMonoString *positiveSign;\n} MonoNumberFormatInfo;\n\ntypedef struct {\n\tMonoObject obj;\n\tgint32 lcid;\n\tMonoString *icu_name;\n\tgpointer ICU_collator;\n} MonoCompareInfo;\n\ntypedef struct {\n\tMonoObject obj;\n\tMonoBoolean is_read_only;\n\tgint32 lcid;\n\tgint32 parent_lcid;\n\tgint32 specific_lcid;\n\tgint32 datetime_index;\n\tgint32 number_index;\n\tMonoBoolean use_user_override;\n\tMonoNumberFormatInfo *number_format;\n\tMonoDateTimeFormatInfo *datetime_format;\n\tMonoObject *textinfo;\n\tMonoString *name;\n\tMonoString *displayname;\n\tMonoString *englishname;\n\tMonoString *nativename;\n\tMonoString *iso3lang;\n\tMonoString *iso2lang;\n\tMonoString *icu_name;\n\tMonoString *win3lang;\n\tMonoString *territory;\n\tMonoCompareInfo *compareinfo;\n\tconst gint32 *calendar_data;\n\tconst void* text_info_data;\n} MonoCultureInfo;\n\ntypedef struct {\n\tMonoObject obj;\n\tgint32 region_id;\n\tMonoString *iso2name;\n\tMonoString *iso3name;\n\tMonoString *win3name;\n\tMonoString *english_name;\n\tMonoString *currency_symbol;\n\tMonoString *iso_currency_symbol;\n\tMonoString *currency_english_name;\n} MonoRegionInfo;\n\ntypedef struct {\n\tMonoObject obj;\n\tMonoString *str;\n\tgint32 options;\n\tMonoArray *key;\n\tgint32 lcid;\n} MonoSortKey;\n\ntypedef struct {\n\tMonoObject object;\n\tguint32 intType;\n} MonoInterfaceTypeAttribute;\n\n/* \n * Callbacks supplied by the runtime and called by the modules in metadata/\n * This interface is easier to extend than adding a new function type +\n * a new 'install' function for every callback.\n */\ntypedef struct {\n\tgpointer (*create_ftnptr) (MonoDomain *domain, gpointer addr);\n\tgpointer (*get_addr_from_ftnptr) (gpointer descr);\n\tchar*    (*get_runtime_build_info) (void);\n} MonoRuntimeCallbacks;\n\n/* used to free a dynamic method */\ntypedef void        (*MonoFreeMethodFunc)\t (MonoDomain *domain, MonoMethod *method);\n\n/* Used to initialize the method pointers inside vtables */\ntypedef gboolean    (*MonoInitVTableFunc)    (MonoVTable *vtable);\n\nvoid mono_set_pending_exception (MonoException *exc) MONO_INTERNAL;\n\n/* remoting and async support */\n\nMonoAsyncResult *\nmono_async_result_new\t    (MonoDomain *domain, HANDLE handle, \n\t\t\t     MonoObject *state, gpointer data, MonoObject *object_data) MONO_INTERNAL;\n\nMonoWaitHandle *\nmono_wait_handle_new\t    (MonoDomain *domain, HANDLE handle) MONO_INTERNAL;\n\nHANDLE\nmono_wait_handle_get_handle (MonoWaitHandle *handle) MONO_INTERNAL;\n\nvoid\nmono_message_init\t    (MonoDomain *domain, MonoMethodMessage *this_obj, \n\t\t\t     MonoReflectionMethod *method, MonoArray *out_args) MONO_INTERNAL;\n\nMonoObject *\nmono_remoting_invoke\t    (MonoObject *real_proxy, MonoMethodMessage *msg, \n\t\t\t     MonoObject **exc, MonoArray **out_args) MONO_INTERNAL;\n\nMonoObject *\nmono_message_invoke\t    (MonoObject *target, MonoMethodMessage *msg, \n\t\t\t     MonoObject **exc, MonoArray **out_args) MONO_INTERNAL;\n\nMonoMethodMessage *\nmono_method_call_message_new (MonoMethod *method, gpointer *params, MonoMethod *invoke, \n\t\t\t      MonoDelegate **cb, MonoObject **state) MONO_INTERNAL;\n\nvoid\nmono_method_return_message_restore (MonoMethod *method, gpointer *params, MonoArray *out_args) MONO_INTERNAL;\n\nvoid\nmono_delegate_ctor_with_method (MonoObject *this, MonoObject *target, gpointer addr, MonoMethod *method) MONO_INTERNAL;\n\nvoid\nmono_delegate_ctor\t    (MonoObject *this_obj, MonoObject *target, gpointer addr) MONO_INTERNAL;\n\nvoid*\nmono_class_get_allocation_ftn (MonoVTable *vtable, gboolean for_box, gboolean *pass_size_in_words) MONO_INTERNAL;\n\nvoid\nmono_runtime_free_method    (MonoDomain *domain, MonoMethod *method) MONO_INTERNAL;\n\n/* runtime initialization functions */\ntypedef void (*MonoExceptionFunc) (MonoException *ex);\n\nvoid\nmono_install_handler\t    (MonoExceptionFunc func) MONO_INTERNAL;\n\nvoid\t    \nmono_install_runtime_invoke (MonoInvokeFunc func) MONO_INTERNAL;\n\nvoid\t    \nmono_install_compile_method (MonoCompileFunc func) MONO_INTERNAL;\n\nvoid\nmono_install_free_method    (MonoFreeMethodFunc func) MONO_INTERNAL;\n\nvoid\nmono_install_callbacks      (MonoRuntimeCallbacks *cbs) MONO_INTERNAL;\n\nMonoRuntimeCallbacks*\nmono_get_runtime_callbacks (void) MONO_INTERNAL;\n\nvoid\nmono_type_initialization_init (void) MONO_INTERNAL;\n\nvoid\nmono_type_initialization_cleanup (void) MONO_INTERNAL;\n\nguint32\nmono_thread_get_tls_key    (void) MONO_INTERNAL;\n\ngint32\nmono_thread_get_tls_offset (void) MONO_INTERNAL;\n\nguint32\nmono_domain_get_tls_key    (void) MONO_INTERNAL;\n\ngint32\nmono_domain_get_tls_offset (void) MONO_INTERNAL;\n\n/* Reflection and Reflection.Emit support */\n\n/*\n * Handling System.Type objects:\n *\n *   Fields defined as System.Type in managed code should be defined as MonoObject* \n * in unmanaged structures, and the monotype_cast () function should be used for \n * casting them to MonoReflectionType* to avoid crashes/security issues when \n * encountering instances of user defined subclasses of System.Type.\n */\n\n#define IS_MONOTYPE(obj) (!(obj) || (((MonoObject*)(obj))->vtable->klass->image == mono_defaults.corlib && ((MonoReflectionType*)(obj))->type != NULL))\n\n/* \n * Make sure the argument, which should be a System.Type is a System.MonoType object \n * or equivalent, and not an instance of \n * a user defined subclass of System.Type. This should be used in places were throwing\n * an exception is safe.\n */\n#define CHECK_MONOTYPE(obj) do { \\\n\tif (!IS_MONOTYPE (obj)) \\\n\t\tmono_raise_exception (mono_get_exception_not_supported (\"User defined subclasses of System.Type are not yet supported\")); \\\n\t} while (0)\n\n/* This should be used for accessing members of Type[] arrays */\n#define mono_type_array_get(arr,index) monotype_cast (mono_array_get ((arr), gpointer, (index)))\n\n/*\n * Cast an object to MonoReflectionType, making sure it is a System.MonoType or\n * a subclass of it.\n */\nstatic inline MonoReflectionType*\nmonotype_cast (MonoObject *obj)\n{\n\tg_assert (IS_MONOTYPE (obj));\n\n\treturn (MonoReflectionType*)obj;\n}\n\n/*\n * The following structure must match the C# implementation in our corlib.\n */\n\nstruct _MonoReflectionMethod {\n\tMonoObject object;\n\tMonoMethod *method;\n\tMonoString *name;\n\tMonoReflectionType *reftype;\n};\n\ntypedef struct _MonoReflectionGenericMethod MonoReflectionGenericMethod;\nstruct _MonoReflectionGenericMethod {\n\tMonoReflectionMethod method;\n};\n\nstruct _MonoDelegate {\n\tMonoObject object;\n\t/* The compiled code of the target method */\n\tgpointer method_ptr;\n\t/* The invoke code */\n\tgpointer invoke_impl;\n\tMonoObject *target;\n\tMonoMethod *method;\n\tgpointer delegate_trampoline;\n\t/* \n\t * If non-NULL, this points to a memory location which stores the address of \n\t * the compiled code of the method, or NULL if it is not yet compiled.\n\t */\n\tguint8 **method_code;\n\tMonoReflectionMethod *method_info;\n\tMonoReflectionMethod *original_method_info;\n\tMonoObject *data;\n};\n\ntypedef struct _MonoMulticastDelegate MonoMulticastDelegate;\nstruct _MonoMulticastDelegate {\n\tMonoDelegate delegate;\n\tMonoMulticastDelegate *prev;\n};\n\nstruct _MonoReflectionField {\n\tMonoObject object;\n\tMonoClass *klass;\n\tMonoClassField *field;\n\tMonoString *name;\n\tMonoReflectionType *type;\n\tguint32 attrs;\n};\n\nstruct _MonoReflectionProperty {\n\tMonoObject object;\n\tMonoClass *klass;\n\tMonoProperty *property;\n};\n\n/*This is System.EventInfo*/\nstruct _MonoReflectionEvent {\n\tMonoObject object;\n\tMonoObject *cached_add_event;\n};\n\ntypedef struct {\n\tMonoReflectionEvent object;\n\tMonoClass *klass;\n\tMonoEvent *event;\n} MonoReflectionMonoEvent;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionType *ClassImpl;\n\tMonoObject *DefaultValueImpl;\n\tMonoObject *MemberImpl;\n\tMonoString *NameImpl;\n\tgint32 PositionImpl;\n\tguint32 AttrsImpl;\n\tMonoObject *MarshalAsImpl;\n} MonoReflectionParameter;\n\nstruct _MonoReflectionMethodBody {\n\tMonoObject object;\n\tMonoArray *clauses;\n\tMonoArray *locals;\n\tMonoArray *il;\n\tMonoBoolean init_locals;\n\tguint32 local_var_sig_token;\n\tguint32 max_stack;\n};\n\nstruct _MonoReflectionAssembly {\n\tMonoObject object;\n\tMonoAssembly *assembly;\n\tMonoObject *resolve_event_holder;\n\t/* CAS related */\n\tMonoObject *evidence;\t/* Evidence */\n\tMonoObject *minimum;\t/* PermissionSet - for SecurityAction.RequestMinimum */\n\tMonoObject *optional;\t/* PermissionSet - for SecurityAction.RequestOptional */\n\tMonoObject *refuse;\t/* PermissionSet - for SecurityAction.RequestRefuse */\n\tMonoObject *granted;\t/* PermissionSet - for the resolved assembly granted permissions */\n\tMonoObject *denied;\t/* PermissionSet - for the resolved assembly denied permissions */\n\t/* */\n\tMonoBoolean from_byte_array;\n\tMonoString *name;\n};\n\ntypedef struct {\n\tMonoReflectionType *utype;\n\tMonoArray *values;\n\tMonoArray *names;\n} MonoEnumInfo;\n\ntypedef struct {\n\tMonoReflectionType *parent;\n\tMonoReflectionType *ret;\n\tguint32 attrs;\n\tguint32 implattrs;\n\tguint32 callconv;\n} MonoMethodInfo;\n\ntypedef struct {\n\tMonoReflectionType *parent;\n\tMonoString *name;\n\tMonoReflectionMethod *get;\n\tMonoReflectionMethod *set;\n\tguint32 attrs;\n} MonoPropertyInfo;\n\ntypedef struct {\n\tMonoReflectionType *declaring_type;\n\tMonoReflectionType *reflected_type;\n\tMonoString *name;\n\tMonoReflectionMethod *add_method;\n\tMonoReflectionMethod *remove_method;\n\tMonoReflectionMethod *raise_method;\n\tguint32 attrs;\n\tMonoArray *other_methods;\n} MonoEventInfo;\n\ntypedef struct {\n\tMonoString *name;\n\tMonoString *name_space;\n\tMonoReflectionType *etype;\n\tMonoReflectionType *nested_in;\n\tMonoReflectionAssembly *assembly;\n\tguint32 rank;\n\tMonoBoolean isprimitive;\n} MonoTypeInfo;\n\ntypedef struct {\n\tMonoObject *member;\n\tgint32 code_pos;\n} MonoReflectionILTokenInfo;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoArray *code;\n\tgint32 code_len;\n\tgint32 max_stack;\n\tgint32 cur_stack;\n\tMonoArray *locals;\n\tMonoArray *ex_handlers;\n\tgint32 num_token_fixups;\n\tMonoArray *token_fixups;\n} MonoReflectionILGen;\n\ntypedef struct {\n\tMonoArray *handlers;\n\tgint32 start;\n\tgint32 len;\n\tgint32 label;\n} MonoILExceptionInfo;\n\ntypedef struct {\n\tMonoObject *extype;\n\tgint32 type;\n\tgint32 start;\n\tgint32 len;\n\tgint32 filter_offset;\n} MonoILExceptionBlock;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoObject *catch_type;\n\tgint32 filter_offset;\n\tgint32 flags;\n\tgint32 try_offset;\n\tgint32 try_length;\n\tgint32 handler_offset;\n\tgint32 handler_length;\n} MonoReflectionExceptionHandlingClause;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionType *local_type;\n\tMonoBoolean is_pinned;\n\tguint16 local_index;\n} MonoReflectionLocalVariableInfo;\n\ntypedef struct {\n\t/*\n\t * Must have the same layout as MonoReflectionLocalVariableInfo, since\n\t * LocalBuilder inherits from it under net 2.0.\n\t */\n\tMonoObject object;\n\tMonoObject *type;\n\tMonoBoolean is_pinned;\n\tguint16 local_index;\n\tMonoString *name;\n} MonoReflectionLocalBuilder;\n\ntypedef struct {\n\tMonoObject object;\n\tgint32 count;\n\tgint32 type;\n\tgint32 eltype;\n\tMonoString *guid;\n\tMonoString *mcookie;\n\tMonoString *marshaltype;\n\tMonoObject *marshaltyperef;\n\tgint32 param_num;\n\tMonoBoolean has_size;\n} MonoReflectionMarshal;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoObject* methodb;\n\tMonoString *name;\n\tMonoArray *cattrs;\n\tMonoReflectionMarshal *marshal_info;\n\tguint32 attrs;\n\tint position;\n\tguint32 table_idx;\n\tMonoObject *def_value;\n} MonoReflectionParamBuilder;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoMethod *mhandle;\n\tMonoReflectionILGen *ilgen;\n\tMonoArray *parameters;\n\tguint32 attrs;\n\tguint32 iattrs;\n\tguint32 table_idx;\n\tguint32 call_conv;\n\tMonoObject *type;\n\tMonoArray *pinfo;\n\tMonoArray *cattrs;\n\tMonoBoolean init_locals;\n\tMonoArray *param_modreq;\n\tMonoArray *param_modopt;\n\tMonoArray *permissions;\n} MonoReflectionCtorBuilder;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoMethod *mhandle;\n\tMonoObject *rtype;\n\tMonoArray *parameters;\n\tguint32 attrs;\n\tguint32 iattrs;\n\tMonoString *name;\n\tguint32 table_idx;\n\tMonoArray *code;\n\tMonoReflectionILGen *ilgen;\n\tMonoObject *type;\n\tMonoArray *pinfo;\n\tMonoArray *cattrs;\n\tMonoReflectionMethod *override_method;\n\tMonoString *dll;\n\tMonoString *dllentry;\n\tguint32 charset;\n\tguint32 extra_flags;\n\tguint32 native_cc;\n\tguint32 call_conv;\n\tMonoBoolean init_locals;\n\tMonoGenericContainer *generic_container;\n\tMonoArray *generic_params;\n\tMonoArray *return_modreq;\n\tMonoArray *return_modopt;\n\tMonoArray *param_modreq;\n\tMonoArray *param_modopt;\n\tMonoArray *permissions;\n} MonoReflectionMethodBuilder;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoMethod *mhandle;\n\tMonoReflectionType *parent;\n\tMonoReflectionType *ret;\n\tMonoArray *parameters;\n\tMonoString *name;\n\tguint32 table_idx;\n\tguint32 call_conv;\n} MonoReflectionArrayMethod;\n\ntypedef struct {\n\tMonoArray *data;\n\tMonoString *name;\n\tMonoString *filename;\n\tguint32 attrs;\n\tguint32 offset;\n\tMonoObject *stream;\n} MonoReflectionResource;\n\ntypedef struct {\n\tguint32 res_type;\n\tguint32 res_id;\n\tguint32 lang_id;\n\tMonoArray *res_data;\n} MonoReflectionWin32Resource;\n\ntypedef struct {\n\tguint32 action;\n\tMonoString *pset;\n} MonoReflectionPermissionSet;\n\ntypedef struct {\n\tMonoReflectionAssembly assembly;\n\tMonoDynamicAssembly *dynamic_assembly;\n\tMonoReflectionMethod *entry_point;\n\tMonoArray *modules;\n\tMonoString *name;\n\tMonoString *dir;\n\tMonoArray *cattrs;\n\tMonoArray *resources;\n\tMonoArray *public_key;\n\tMonoString *version;\n\tMonoString *culture;\n\tguint32 algid;\n\tguint32 flags;\n\tguint32 pekind;\n\tMonoBoolean delay_sign;\n\tguint32 access;\n\tMonoArray *loaded_modules;\n\tMonoArray *win32_resources;\n\t/* CAS related */\n\tMonoArray *permissions_minimum;\n\tMonoArray *permissions_optional;\n\tMonoArray *permissions_refused;\n\tgint32 pe_kind;\n\tgint32 machine;\n\tMonoBoolean corlib_internal;\n\tMonoArray *type_forwarders;\n\tMonoArray *pktoken; /* as hexadecimal byte[] */\n} MonoReflectionAssemblyBuilder;\n\ntypedef struct {\n\tMonoObject object;\n\tguint32 attrs;\n\tMonoObject *type;\n\tMonoString *name;\n\tMonoObject *def_value;\n\tgint32 offset;\n\tgint32 table_idx;\n\tMonoReflectionType *typeb;\n\tMonoArray *rva_data;\n\tMonoArray *cattrs;\n\tMonoReflectionMarshal *marshal_info;\n\tMonoClassField *handle;\n\tMonoArray *modreq;\n\tMonoArray *modopt;\n} MonoReflectionFieldBuilder;\n\ntypedef struct {\n\tMonoObject object;\n\tguint32 attrs;\n\tMonoString *name;\n\tMonoObject *type;\n\tMonoArray *parameters;\n\tMonoArray *cattrs;\n\tMonoObject *def_value;\n\tMonoReflectionMethodBuilder *set_method;\n\tMonoReflectionMethodBuilder *get_method;\n\tgint32 table_idx;\n} MonoReflectionPropertyBuilder;\n\nstruct _MonoReflectionModule {\n\tMonoObject\tobj;\n\tMonoImage  *image;\n\tMonoReflectionAssembly *assembly;\n\tMonoString *fqname;\n\tMonoString *name;\n\tMonoString *scopename;\n\tMonoBoolean is_resource;\n\tguint32 token;\n};\n\ntypedef struct {\n\tMonoReflectionModule module;\n\tMonoDynamicImage *dynamic_image;\n\tgint32     num_types;\n\tMonoArray *types;\n\tMonoArray *cattrs;\n\tMonoArray *guid;\n\tguint32    table_idx;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoArray *global_methods;\n\tMonoArray *global_fields;\n\tgboolean is_main;\n\tMonoArray *resources;\n} MonoReflectionModuleBuilder;\n\ntypedef struct {\n\tMonoReflectionType type;\n\tMonoString *name;\n\tMonoString *nspace;\n\tMonoObject *parent;\n\tMonoReflectionType *nesting_type;\n\tMonoArray *interfaces;\n\tgint32     num_methods;\n\tMonoArray *methods;\n\tMonoArray *ctors;\n\tMonoArray *properties;\n\tgint32     num_fields;\n\tMonoArray *fields;\n\tMonoArray *events;\n\tMonoArray *cattrs;\n\tMonoArray *subtypes;\n\tguint32 attrs;\n\tguint32 table_idx;\n\tMonoReflectionModuleBuilder *module;\n\tgint32 class_size;\n\tgint32 packing_size;\n\tMonoGenericContainer *generic_container;\n\tMonoArray *generic_params;\n\tMonoArray *permissions;\n\tMonoReflectionType *created;\n} MonoReflectionTypeBuilder;\n\ntypedef struct {\n\tMonoReflectionType type;\n\tMonoReflectionType *element_type;\n\tint rank;\n} MonoReflectionArrayType;\n\ntypedef struct {\n\tMonoReflectionType type;\n\tMonoReflectionType *element_type;\n} MonoReflectionDerivedType;\n\ntypedef struct {\n\tMonoReflectionType type;\n\tMonoReflectionTypeBuilder *tbuilder;\n\tMonoReflectionMethodBuilder *mbuilder;\n\tMonoString *name;\n\tguint32 index;\n\tMonoReflectionType *base_type;\n\tMonoArray *iface_constraints;\n\tMonoArray *cattrs;\n\tguint32 attrs;\n} MonoReflectionGenericParam;\n\ntypedef struct _MonoReflectionGenericClass MonoReflectionGenericClass;\nstruct _MonoReflectionGenericClass {\n\tMonoReflectionType type;\n\t/* From System.MonoType */\n\tMonoObject *type_info;\n\tMonoReflectionTypeBuilder *generic_type;\n\tMonoArray *type_arguments;\n\tguint32 initialized;\n};\n\ntypedef struct {\n\tMonoObject  obj;\n\tMonoString *name;\n\tMonoString *codebase;\n\tgint32 major, minor, build, revision;\n\tMonoObject  *cultureInfo;\n\tguint32     flags;\n\tguint32     hashalg;\n\tMonoObject  *keypair;\n\tMonoArray   *publicKey;\n\tMonoArray   *keyToken;\n\tguint32     versioncompat;\n\tMonoObject *version;\n\tguint32     processor_architecture;\n} MonoReflectionAssemblyName;\n\ntypedef struct {\n\tMonoObject  obj;\n\tMonoString *name;\n\tMonoReflectionType *type;\n\tMonoReflectionTypeBuilder *typeb;\n\tMonoArray *cattrs;\n\tMonoReflectionMethodBuilder *add_method;\n\tMonoReflectionMethodBuilder *remove_method;\n\tMonoReflectionMethodBuilder *raise_method;\n\tMonoArray *other_methods;\n\tguint32 attrs;\n\tguint32 table_idx;\n} MonoReflectionEventBuilder;\n\ntypedef struct {\n\tMonoObject  obj;\n\tMonoReflectionMethod *ctor;\n\tMonoArray *data;\n} MonoReflectionCustomAttr;\n\ntypedef struct {\n\tMonoObject object;\n\tgint32 call_conv;\n\tgint32 charset;\n\tMonoString *dll;\n\tMonoString *entry_point;\n\tMonoBoolean exact_spelling;\n\tMonoBoolean preserve_sig;\n\tMonoBoolean set_last_error;\n\tMonoBoolean best_fit_mapping;\n\tMonoBoolean throw_on_unmappable;\n} MonoReflectionDllImportAttribute;\n\ntypedef struct {\n\tMonoObject object;\n\tgint32 call_conv;\n\tgint32 charset;\n\tMonoBoolean set_last_error;\n\tMonoBoolean best_fit_mapping;\n\tMonoBoolean throw_on_unmappable;\n} MonoReflectionUnmanagedFunctionPointerAttribute;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoString *guid;\n} MonoReflectionGuidAttribute;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoMethod *mhandle;\n\tMonoString *name;\n\tMonoReflectionType *rtype;\n\tMonoArray *parameters;\n\tguint32 attrs;\n\tguint32 call_conv;\n\tMonoReflectionModule *module;\n\tMonoBoolean skip_visibility;\n\tMonoBoolean init_locals;\n\tMonoReflectionILGen *ilgen;\n\tgint32 nrefs;\n\tMonoArray *refs;\n\tGSList *referenced_by;\n\tMonoReflectionType *owner;\n} MonoReflectionDynamicMethod;\t\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionModuleBuilder *module;\n\tMonoArray *arguments;\n\tguint32 type;\n\tMonoReflectionType *return_type;\n\tguint32 call_conv;\n\tguint32 unmanaged_call_conv;\n\tMonoArray *modreqs;\n\tMonoArray *modopts;\n} MonoReflectionSigHelper;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionGenericClass *inst;\n\tMonoReflectionFieldBuilder *fb;\n} MonoReflectionFieldOnTypeBuilderInst;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionGenericClass *inst;\n\tMonoReflectionCtorBuilder *cb;\n} MonoReflectionCtorOnTypeBuilderInst;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionGenericClass *inst;\n\tMonoReflectionMethodBuilder *mb;\n\tMonoArray *method_args;\n\tMonoReflectionMethodBuilder *generic_method_definition;\n} MonoReflectionMethodOnTypeBuilderInst;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoBoolean visible;\n} MonoReflectionComVisibleAttribute;\n\nenum {\n\tRESOURCE_LOCATION_EMBEDDED = 1,\n\tRESOURCE_LOCATION_ANOTHER_ASSEMBLY = 2,\n\tRESOURCE_LOCATION_IN_MANIFEST = 4\n};\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionAssembly *assembly;\n\tMonoString *filename;\n\tguint32 location;\n} MonoManifestResourceInfo;\n\n/* A boxed IntPtr */\ntypedef struct {\n\tMonoObject object;\n\tgpointer m_value;\n} MonoIntPtr;\n\n/* Keep in sync with System.GenericParameterAttributes */\ntypedef enum {\n\tGENERIC_PARAMETER_ATTRIBUTE_NON_VARIANT\t\t= 0,\n\tGENERIC_PARAMETER_ATTRIBUTE_COVARIANT\t\t= 1,\n\tGENERIC_PARAMETER_ATTRIBUTE_CONTRAVARIANT\t= 2,\n\tGENERIC_PARAMETER_ATTRIBUTE_VARIANCE_MASK\t= 3,\n\n\tGENERIC_PARAMETER_ATTRIBUTE_NO_SPECIAL_CONSTRAINT\t= 0,\n\tGENERIC_PARAMETER_ATTRIBUTE_REFERENCE_TYPE_CONSTRAINT\t= 4,\n\tGENERIC_PARAMETER_ATTRIBUTE_VALUE_TYPE_CONSTRAINT\t= 8,\n\tGENERIC_PARAMETER_ATTRIBUTE_CONSTRUCTOR_CONSTRAINT\t= 16,\n\tGENERIC_PARAMETER_ATTRIBUTE_SPECIAL_CONSTRAINTS_MASK\t= 28\n} GenericParameterAttributes;\n\ntypedef struct {\n\tMonoType *type;\n\tMonoClassField *field;\n\tMonoProperty *prop;\n} CattrNamedArg;\n\nvoid          mono_image_create_pefile (MonoReflectionModuleBuilder *module, HANDLE file) MONO_INTERNAL;\nvoid          mono_image_basic_init (MonoReflectionAssemblyBuilder *assembly) MONO_INTERNAL;\nMonoReflectionModule * mono_image_load_module_dynamic (MonoReflectionAssemblyBuilder *assembly, MonoString *file_name) MONO_INTERNAL;\nguint32       mono_image_insert_string (MonoReflectionModuleBuilder *module, MonoString *str) MONO_INTERNAL;\nguint32       mono_image_create_token  (MonoDynamicImage *assembly, MonoObject *obj, gboolean create_methodspec, gboolean register_token) MONO_INTERNAL;\nguint32       mono_image_create_method_token (MonoDynamicImage *assembly, MonoObject *obj, MonoArray *opt_param_types) MONO_INTERNAL;\nvoid          mono_image_module_basic_init (MonoReflectionModuleBuilder *module) MONO_INTERNAL;\nvoid          mono_image_register_token (MonoDynamicImage *assembly, guint32 token, MonoObject *obj) MONO_INTERNAL;\nvoid          mono_dynamic_image_free (MonoDynamicImage *image) MONO_INTERNAL;\nvoid          mono_image_set_wrappers_type (MonoReflectionModuleBuilder *mb, MonoReflectionType *type) MONO_INTERNAL;\n\nvoid        mono_reflection_setup_internal_class  (MonoReflectionTypeBuilder *tb) MONO_INTERNAL;\n\nvoid        mono_reflection_create_internal_class (MonoReflectionTypeBuilder *tb) MONO_INTERNAL;\n\nvoid        mono_reflection_setup_generic_class   (MonoReflectionTypeBuilder *tb) MONO_INTERNAL;\n\nvoid        mono_reflection_create_generic_class  (MonoReflectionTypeBuilder *tb) MONO_INTERNAL;\n\nMonoReflectionType* mono_reflection_create_runtime_class  (MonoReflectionTypeBuilder *tb) MONO_INTERNAL;\n\nvoid        mono_reflection_get_dynamic_overrides (MonoClass *klass, MonoMethod ***overrides, int *num_overrides) MONO_INTERNAL;\n\nvoid mono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *m) MONO_INTERNAL;\nvoid mono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb) MONO_INTERNAL;\n\nvoid        mono_reflection_initialize_generic_parameter (MonoReflectionGenericParam *gparam) MONO_INTERNAL;\nvoid        mono_reflection_create_unmanaged_type (MonoReflectionType *type) MONO_INTERNAL;\nvoid        mono_reflection_create_custom_attr_data_args (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len, MonoArray **typed_args, MonoArray **named_args, CattrNamedArg **named_arg_info) MONO_INTERNAL;\n\nMonoArray* mono_param_get_objects_internal  (MonoDomain *domain, MonoMethod *method, MonoClass *refclass) MONO_INTERNAL;\n\nMonoClass*\nmono_class_bind_generic_parameters (MonoClass *klass, int type_argc, MonoType **types, gboolean is_dynamic) MONO_INTERNAL;\nMonoType*\nmono_reflection_bind_generic_parameters (MonoReflectionType *type, int type_argc, MonoType **types) MONO_INTERNAL;\nMonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *method, MonoArray *types) MONO_INTERNAL;\nvoid\nmono_reflection_generic_class_initialize (MonoReflectionGenericClass *type, MonoArray *methods, MonoArray *ctors, MonoArray *fields, MonoArray *properties, MonoArray *events) MONO_INTERNAL;\nMonoReflectionEvent *\nmono_reflection_event_builder_get_event_info (MonoReflectionTypeBuilder *tb, MonoReflectionEventBuilder *eb) MONO_INTERNAL;\n\nMonoArray  *mono_reflection_sighelper_get_signature_local (MonoReflectionSigHelper *sig) MONO_INTERNAL;\n\nMonoArray  *mono_reflection_sighelper_get_signature_field (MonoReflectionSigHelper *sig) MONO_INTERNAL;\n\nMonoReflectionMarshal* mono_reflection_marshal_from_marshal_spec (MonoDomain *domain, MonoClass *klass, MonoMarshalSpec *spec) MONO_INTERNAL;\n\ngpointer\nmono_reflection_lookup_dynamic_token (MonoImage *image, guint32 token, gboolean valid_token, MonoClass **handle_class, MonoGenericContext *context) MONO_INTERNAL;\n\ngboolean\nmono_reflection_call_is_assignable_to (MonoClass *klass, MonoClass *oklass) MONO_INTERNAL;\n\ngboolean\nmono_reflection_is_valid_dynamic_token (MonoDynamicImage *image, guint32 token) MONO_INTERNAL;\n\nMonoType*\nmono_reflection_type_get_handle (MonoReflectionType *ref) MONO_INTERNAL;\n\nvoid\nmono_image_build_metadata (MonoReflectionModuleBuilder *module) MONO_INTERNAL;\n\nint\nmono_get_constant_value_from_blob (MonoDomain* domain, MonoTypeEnum type, const char *blob, void *value) MONO_INTERNAL;\n\nvoid\nmono_release_type_locks (MonoThread *thread) MONO_INTERNAL;\n\nchar *\nmono_string_to_utf8_mp\t(MonoMemPool *mp, MonoString *s, MonoError *error) MONO_INTERNAL;\n\nchar *\nmono_string_to_utf8_image (MonoImage *image, MonoString *s, MonoError *error) MONO_INTERNAL;\n\n\nMonoArray*\nmono_array_clone_in_domain (MonoDomain *domain, MonoArray *array) MONO_INTERNAL;\n\nvoid\nmono_array_full_copy (MonoArray *src, MonoArray *dest) MONO_INTERNAL;\n\ngpointer\nmono_remote_class_vtable (MonoDomain *domain, MonoRemoteClass *remote_class, MonoRealProxy *real_proxy) MONO_INTERNAL;\n\nvoid\nmono_upgrade_remote_class (MonoDomain *domain, MonoObject *tproxy, MonoClass *klass) MONO_INTERNAL;\n\ngpointer\nmono_create_ftnptr (MonoDomain *domain, gpointer addr) MONO_INTERNAL;\n\ngpointer\nmono_get_addr_from_ftnptr (gpointer descr) MONO_INTERNAL;\n\nvoid\nmono_nullable_init (guint8 *buf, MonoObject *value, MonoClass *klass) MONO_INTERNAL;\n\nMonoObject*\nmono_nullable_box (guint8 *buf, MonoClass *klass) MONO_INTERNAL;\n\n#define MONO_IMT_SIZE 19\n\ntypedef union {\n\tint vtable_slot;\n\tgpointer target_code;\n} MonoImtItemValue;\n\ntypedef struct _MonoImtBuilderEntry {\n\tgpointer key;\n\tstruct _MonoImtBuilderEntry *next;\n\tMonoImtItemValue value;\n\tint children;\n\tguint8 has_target_code : 1;\n} MonoImtBuilderEntry;\n\ntypedef struct _MonoIMTCheckItem MonoIMTCheckItem;\n\nstruct _MonoIMTCheckItem {\n\tgpointer          key;\n\tint               check_target_idx;\n\tMonoImtItemValue  value;\n\tguint8           *jmp_code;\n\tguint8           *code_target;\n\tguint8            is_equals;\n\tguint8            compare_done;\n\tguint8            chunk_size;\n\tguint8            short_branch;\n\tguint8            has_target_code;\n};\n\ntypedef gpointer (*MonoImtThunkBuilder) (MonoVTable *vtable, MonoDomain *domain,\n\t\tMonoIMTCheckItem **imt_entries, int count, gpointer fail_trunk);\n\nvoid\nmono_install_imt_thunk_builder (MonoImtThunkBuilder func) MONO_INTERNAL;\n\nvoid\nmono_install_imt_trampoline (gpointer tramp) MONO_INTERNAL;\n\nvoid\nmono_install_vtable_trampoline (gpointer tramp) MONO_INTERNAL;\n\nvoid\nmono_vtable_build_imt_slot (MonoVTable* vtable, int imt_slot) MONO_INTERNAL;\n\nguint32\nmono_method_get_imt_slot (MonoMethod *method) MONO_INTERNAL;\n\nvoid\nmono_method_add_generic_virtual_invocation (MonoDomain *domain, MonoVTable *vtable,\n\t\t\t\t\t\t\t\t\t\t\tgpointer *vtable_slot,\n\t\t\t\t\t\t\t\t\t\t\tMonoMethod *method, gpointer code) MONO_INTERNAL;\n\ngpointer\nmono_method_alloc_generic_virtual_thunk (MonoDomain *domain, int size) MONO_INTERNAL;\n\ntypedef enum {\n\tMONO_UNHANDLED_POLICY_LEGACY,\n\tMONO_UNHANDLED_POLICY_CURRENT\n} MonoRuntimeUnhandledExceptionPolicy;\n\nMonoRuntimeUnhandledExceptionPolicy\nmono_runtime_unhandled_exception_policy_get (void) MONO_INTERNAL;\nvoid\nmono_runtime_unhandled_exception_policy_set (MonoRuntimeUnhandledExceptionPolicy policy) MONO_INTERNAL;\n\nMonoVTable *\nmono_class_try_get_vtable (MonoDomain *domain, MonoClass *class) MONO_INTERNAL;\n\nMonoException *\nmono_runtime_class_init_full (MonoVTable *vtable, gboolean raise_exception) MONO_INTERNAL;\n\nvoid\nmono_method_clear_object (MonoDomain *domain, MonoMethod *method) MONO_INTERNAL;\n\nvoid\nmono_class_compute_gc_descriptor (MonoClass *class) MONO_INTERNAL;\n\nchar *\nmono_string_to_utf8_checked (MonoString *s, MonoError *error) MONO_INTERNAL;\n\ngboolean\nmono_class_is_reflection_method_or_constructor (MonoClass *class) MONO_INTERNAL;\n\n#endif /* __MONO_OBJECT_INTERNALS_H__ */\n\n\n", "/*\n * reflection.c: Routines for creating an image at runtime.\n * \n * Author:\n *   Paolo Molaro (lupus@ximian.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n *\n */\n#include <config.h>\n#include \"mono/utils/mono-digest.h\"\n#include \"mono/utils/mono-membar.h\"\n#include \"mono/metadata/reflection.h\"\n#include \"mono/metadata/tabledefs.h\"\n#include \"mono/metadata/metadata-internals.h\"\n#include <mono/metadata/profiler-private.h>\n#include \"mono/metadata/class-internals.h\"\n#include \"mono/metadata/gc-internal.h\"\n#include \"mono/metadata/tokentype.h\"\n#include \"mono/metadata/domain-internals.h\"\n#include \"mono/metadata/opcodes.h\"\n#include \"mono/metadata/assembly.h\"\n#include \"mono/metadata/object-internals.h\"\n#include <mono/metadata/exception.h>\n#include <mono/metadata/marshal.h>\n#include <mono/metadata/security-manager.h>\n#include <stdio.h>\n#include <glib.h>\n#include <errno.h>\n#include <time.h>\n#include <string.h>\n#include <ctype.h>\n#include \"image.h\"\n#include \"cil-coff.h\"\n#include \"mono-endian.h\"\n#include <mono/metadata/gc-internal.h>\n#include <mono/metadata/mempool-internals.h>\n#include <mono/metadata/security-core-clr.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/utils/mono-string.h>\n#include <mono/utils/mono-error-internals.h>\n\n\n#if HAVE_SGEN_GC\nstatic void* reflection_info_desc = NULL;\n#define MOVING_GC_REGISTER(addr) do {\t\\\n\t\tif (!reflection_info_desc) {\t\\\n\t\t\tgsize bmap = 1;\t\t\\\n\t\t\treflection_info_desc = mono_gc_make_descr_from_bitmap (&bmap, 1);\t\\\n\t\t}\t\\\n\t\tmono_gc_register_root ((char*)(addr), sizeof (gpointer), reflection_info_desc); \\\n\t} while (0)\n#else\n#define MOVING_GC_REGISTER(addr)\n#endif\n\ntypedef struct {\n\tchar *p;\n\tchar *buf;\n\tchar *end;\n} SigBuffer;\n\n#define TEXT_OFFSET 512\n#define CLI_H_SIZE 136\n#define FILE_ALIGN 512\n#define VIRT_ALIGN 8192\n#define START_TEXT_RVA  0x00002000\n\ntypedef struct {\n\tMonoReflectionILGen *ilgen;\n\tMonoReflectionType *rtype;\n\tMonoArray *parameters;\n\tMonoArray *generic_params;\n\tMonoGenericContainer *generic_container;\n\tMonoArray *pinfo;\n\tMonoArray *opt_types;\n\tguint32 attrs;\n\tguint32 iattrs;\n\tguint32 call_conv;\n\tguint32 *table_idx; /* note: it's a pointer */\n\tMonoArray *code;\n\tMonoObject *type;\n\tMonoString *name;\n\tMonoBoolean init_locals;\n\tMonoBoolean skip_visibility;\n\tMonoArray *return_modreq;\n\tMonoArray *return_modopt;\n\tMonoArray *param_modreq;\n\tMonoArray *param_modopt;\n\tMonoArray *permissions;\n\tMonoMethod *mhandle;\n\tguint32 nrefs;\n\tgpointer *refs;\n\t/* for PInvoke */\n\tint charset, extra_flags, native_cc;\n\tMonoString *dll, *dllentry;\n} ReflectionMethodBuilder;\n\ntypedef struct {\n\tguint32 owner;\n\tMonoReflectionGenericParam *gparam;\n} GenericParamTableEntry;\n\nconst unsigned char table_sizes [MONO_TABLE_NUM] = {\n\tMONO_MODULE_SIZE,\n\tMONO_TYPEREF_SIZE,\n\tMONO_TYPEDEF_SIZE,\n\t0,\n\tMONO_FIELD_SIZE,\n\t0,\n\tMONO_METHOD_SIZE,\n\t0,\n\tMONO_PARAM_SIZE,\n\tMONO_INTERFACEIMPL_SIZE,\n\tMONO_MEMBERREF_SIZE,\t/* 0x0A */\n\tMONO_CONSTANT_SIZE,\n\tMONO_CUSTOM_ATTR_SIZE,\n\tMONO_FIELD_MARSHAL_SIZE,\n\tMONO_DECL_SECURITY_SIZE,\n\tMONO_CLASS_LAYOUT_SIZE,\n\tMONO_FIELD_LAYOUT_SIZE,\t/* 0x10 */\n\tMONO_STAND_ALONE_SIGNATURE_SIZE,\n\tMONO_EVENT_MAP_SIZE,\n\t0,\n\tMONO_EVENT_SIZE,\n\tMONO_PROPERTY_MAP_SIZE,\n\t0,\n\tMONO_PROPERTY_SIZE,\n\tMONO_METHOD_SEMA_SIZE,\n\tMONO_METHODIMPL_SIZE,\n\tMONO_MODULEREF_SIZE,\t/* 0x1A */\n\tMONO_TYPESPEC_SIZE,\n\tMONO_IMPLMAP_SIZE,\t\n\tMONO_FIELD_RVA_SIZE,\n\t0,\n\t0,\n\tMONO_ASSEMBLY_SIZE,\t/* 0x20 */\n\tMONO_ASSEMBLY_PROCESSOR_SIZE,\n\tMONO_ASSEMBLYOS_SIZE,\n\tMONO_ASSEMBLYREF_SIZE,\n\tMONO_ASSEMBLYREFPROC_SIZE,\n\tMONO_ASSEMBLYREFOS_SIZE,\n\tMONO_FILE_SIZE,\n\tMONO_EXP_TYPE_SIZE,\n\tMONO_MANIFEST_SIZE,\n\tMONO_NESTED_CLASS_SIZE,\n\n\tMONO_GENERICPARAM_SIZE,\t/* 0x2A */\n\tMONO_METHODSPEC_SIZE,\n\tMONO_GENPARCONSTRAINT_SIZE\n\n};\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32 mono_image_get_methodref_token (MonoDynamicImage *assembly, MonoMethod *method, gboolean create_typespec);\nstatic guint32 mono_image_get_methodbuilder_token (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb, gboolean create_methodspec);\nstatic guint32 mono_image_get_ctorbuilder_token (MonoDynamicImage *assembly, MonoReflectionCtorBuilder *cb);\nstatic guint32 mono_image_get_sighelper_token (MonoDynamicImage *assembly, MonoReflectionSigHelper *helper);\nstatic void    ensure_runtime_vtable (MonoClass *klass);\nstatic gpointer resolve_object (MonoImage *image, MonoObject *obj, MonoClass **handle_class, MonoGenericContext *context);\nstatic guint32 mono_image_get_methodref_token_for_methodbuilder (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *method);\nstatic guint32 encode_generic_method_sig (MonoDynamicImage *assembly, MonoGenericContext *context);\nstatic gpointer register_assembly (MonoDomain *domain, MonoReflectionAssembly *res, MonoAssembly *assembly);\nstatic void reflection_methodbuilder_from_method_builder (ReflectionMethodBuilder *rmb, MonoReflectionMethodBuilder *mb);\nstatic void reflection_methodbuilder_from_ctor_builder (ReflectionMethodBuilder *rmb, MonoReflectionCtorBuilder *mb);\n#endif\n\nstatic guint32 mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type);\nstatic guint32 mono_image_typedef_or_ref_full (MonoDynamicImage *assembly, MonoType *type, gboolean try_typespec);\nstatic void    mono_image_get_generic_param_info (MonoReflectionGenericParam *gparam, guint32 owner, MonoDynamicImage *assembly);\nstatic guint32 encode_marshal_blob (MonoDynamicImage *assembly, MonoReflectionMarshal *minfo);\nstatic guint32 encode_constant (MonoDynamicImage *assembly, MonoObject *val, guint32 *ret_type);\nstatic char*   type_get_qualified_name (MonoType *type, MonoAssembly *ass);\nstatic void    encode_type (MonoDynamicImage *assembly, MonoType *type, SigBuffer *buf);\nstatic void get_default_param_value_blobs (MonoMethod *method, char **blobs, guint32 *types);\nstatic MonoObject *mono_get_object_from_blob (MonoDomain *domain, MonoType *type, const char *blob);\nstatic MonoReflectionType *mono_reflection_type_get_underlying_system_type (MonoReflectionType* t);\nstatic MonoType* mono_reflection_get_type_with_rootimage (MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean *type_resolve);\nstatic MonoReflectionType* mono_reflection_type_resolve_user_types (MonoReflectionType *type);\nstatic gboolean is_sre_array (MonoClass *class);\nstatic gboolean is_sre_byref (MonoClass *class);\nstatic gboolean is_sre_pointer (MonoClass *class);\nstatic gboolean is_sre_method_builder (MonoClass *class);\nstatic gboolean is_sre_ctor_builder (MonoClass *class);\nstatic gboolean is_sr_mono_method (MonoClass *class);\nstatic gboolean is_sr_mono_cmethod (MonoClass *class);\nstatic gboolean is_sr_mono_generic_method (MonoClass *class);\nstatic gboolean is_sr_mono_generic_cmethod (MonoClass *class);\nstatic gboolean is_sr_mono_field (MonoClass *class);\nstatic gboolean is_sr_mono_property (MonoClass *class);\nstatic gboolean is_sre_method_on_tb_inst (MonoClass *class);\nstatic gboolean is_sre_ctor_on_tb_inst (MonoClass *class);\n\nstatic guint32 mono_image_get_methodspec_token (MonoDynamicImage *assembly, MonoMethod *method);\nstatic guint32 mono_image_get_inflated_method_token (MonoDynamicImage *assembly, MonoMethod *m);\nstatic MonoMethod * inflate_method (MonoReflectionGenericClass *type, MonoObject *obj);\n\n#define RESOLVE_TYPE(type) do { type = (void*)mono_reflection_type_resolve_user_types ((MonoReflectionType*)type); } while (0)\n#define RESOLVE_ARRAY_TYPE_ELEMENT(array, index) do {\t\\\n\tMonoReflectionType *__type = mono_array_get (array, MonoReflectionType*, index);\t\\\n\t__type = mono_reflection_type_resolve_user_types (__type);\t\\\n\tmono_array_set (arr, MonoReflectionType*, index, __type);\t\\\n} while (0)\n\n#define mono_type_array_get_and_resolve(array, index) mono_reflection_type_get_handle ((MonoReflectionType*)mono_array_get (array, gpointer, index))\n\nvoid\nmono_reflection_init (void)\n{\n}\n\nstatic void\nsigbuffer_init (SigBuffer *buf, int size)\n{\n\tbuf->buf = g_malloc (size);\n\tbuf->p = buf->buf;\n\tbuf->end = buf->buf + size;\n}\n\nstatic void\nsigbuffer_make_room (SigBuffer *buf, int size)\n{\n\tif (buf->end - buf->p < size) {\n\t\tint new_size = buf->end - buf->buf + size + 32;\n\t\tchar *p = g_realloc (buf->buf, new_size);\n\t\tsize = buf->p - buf->buf;\n\t\tbuf->buf = p;\n\t\tbuf->p = p + size;\n\t\tbuf->end = buf->buf + new_size;\n\t}\n}\n\nstatic void\nsigbuffer_add_value (SigBuffer *buf, guint32 val)\n{\n\tsigbuffer_make_room (buf, 6);\n\tmono_metadata_encode_value (val, buf->p, &buf->p);\n}\n\nstatic void\nsigbuffer_add_byte (SigBuffer *buf, guint8 val)\n{\n\tsigbuffer_make_room (buf, 1);\n\tbuf->p [0] = val;\n\tbuf->p++;\n}\n\nstatic void\nsigbuffer_add_mem (SigBuffer *buf, char *p, guint32 size)\n{\n\tsigbuffer_make_room (buf, size);\n\tmemcpy (buf->p, p, size);\n\tbuf->p += size;\n}\n\nstatic void\nsigbuffer_free (SigBuffer *buf)\n{\n\tg_free (buf->buf);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/**\n * mp_g_alloc:\n *\n * Allocate memory from the @image mempool if it is non-NULL. Otherwise, allocate memory\n * from the C heap.\n */\nstatic gpointer\nimage_g_malloc (MonoImage *image, guint size)\n{\n\tif (image)\n\t\treturn mono_image_alloc (image, size);\n\telse\n\t\treturn g_malloc (size);\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\n/**\n * image_g_alloc0:\n *\n * Allocate memory from the @image mempool if it is non-NULL. Otherwise, allocate memory\n * from the C heap.\n */\nstatic gpointer\nimage_g_malloc0 (MonoImage *image, guint size)\n{\n\tif (image)\n\t\treturn mono_image_alloc0 (image, size);\n\telse\n\t\treturn g_malloc0 (size);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic char*\nimage_strdup (MonoImage *image, const char *s)\n{\n\tif (image)\n\t\treturn mono_image_strdup (image, s);\n\telse\n\t\treturn g_strdup (s);\n}\n#endif\n\n#define image_g_new(image,struct_type, n_structs)\t\t\\\n    ((struct_type *) image_g_malloc (image, ((gsize) sizeof (struct_type)) * ((gsize) (n_structs))))\n\n#define image_g_new0(image,struct_type, n_structs)\t\t\\\n    ((struct_type *) image_g_malloc0 (image, ((gsize) sizeof (struct_type)) * ((gsize) (n_structs))))\n\n\nstatic void\nalloc_table (MonoDynamicTable *table, guint nrows)\n{\n\ttable->rows = nrows;\n\tg_assert (table->columns);\n\tif (nrows + 1 >= table->alloc_rows) {\n\t\twhile (nrows + 1 >= table->alloc_rows) {\n\t\t\tif (table->alloc_rows == 0)\n\t\t\t\ttable->alloc_rows = 16;\n\t\t\telse\n\t\t\t\ttable->alloc_rows *= 2;\n\t\t}\n\n\t\ttable->values = g_renew (guint32, table->values, (table->alloc_rows) * table->columns);\n\t}\n}\n\nstatic void\nmake_room_in_stream (MonoDynamicStream *stream, int size)\n{\n\tif (size <= stream->alloc_size)\n\t\treturn;\n\t\n\twhile (stream->alloc_size <= size) {\n\t\tif (stream->alloc_size < 4096)\n\t\t\tstream->alloc_size = 4096;\n\t\telse\n\t\t\tstream->alloc_size *= 2;\n\t}\n\t\n\tstream->data = g_realloc (stream->data, stream->alloc_size);\n}\n\nstatic guint32\nstring_heap_insert (MonoDynamicStream *sh, const char *str)\n{\n\tguint32 idx;\n\tguint32 len;\n\tgpointer oldkey, oldval;\n\n\tif (g_hash_table_lookup_extended (sh->hash, str, &oldkey, &oldval))\n\t\treturn GPOINTER_TO_UINT (oldval);\n\n\tlen = strlen (str) + 1;\n\tidx = sh->index;\n\t\n\tmake_room_in_stream (sh, idx + len);\n\n\t/*\n\t * We strdup the string even if we already copy them in sh->data\n\t * so that the string pointers in the hash remain valid even if\n\t * we need to realloc sh->data. We may want to avoid that later.\n\t */\n\tg_hash_table_insert (sh->hash, g_strdup (str), GUINT_TO_POINTER (idx));\n\tmemcpy (sh->data + idx, str, len);\n\tsh->index += len;\n\treturn idx;\n}\n\nstatic guint32\nstring_heap_insert_mstring (MonoDynamicStream *sh, MonoString *str)\n{\n\tchar *name = mono_string_to_utf8 (str);\n\tguint32 idx;\n\tidx = string_heap_insert (sh, name);\n\tg_free (name);\n\treturn idx;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nstring_heap_init (MonoDynamicStream *sh)\n{\n\tsh->index = 0;\n\tsh->alloc_size = 4096;\n\tsh->data = g_malloc (4096);\n\tsh->hash = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n\tstring_heap_insert (sh, \"\");\n}\n#endif\n\nstatic guint32\nmono_image_add_stream_data (MonoDynamicStream *stream, const char *data, guint32 len)\n{\n\tguint32 idx;\n\t\n\tmake_room_in_stream (stream, stream->index + len);\n\tmemcpy (stream->data + stream->index, data, len);\n\tidx = stream->index;\n\tstream->index += len;\n\t/* \n\t * align index? Not without adding an additional param that controls it since\n\t * we may store a blob value in pieces.\n\t */\n\treturn idx;\n}\n\nstatic guint32\nmono_image_add_stream_zero (MonoDynamicStream *stream, guint32 len)\n{\n\tguint32 idx;\n\t\n\tmake_room_in_stream (stream, stream->index + len);\n\tmemset (stream->data + stream->index, 0, len);\n\tidx = stream->index;\n\tstream->index += len;\n\treturn idx;\n}\n\nstatic void\nstream_data_align (MonoDynamicStream *stream)\n{\n\tchar buf [4] = {0};\n\tguint32 count = stream->index % 4;\n\n\t/* we assume the stream data will be aligned */\n\tif (count)\n\t\tmono_image_add_stream_data (stream, buf, 4 - count);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic int\nmono_blob_entry_hash (const char* str)\n{\n\tguint len, h;\n\tconst char *end;\n\tlen = mono_metadata_decode_blob_size (str, &str);\n\tif (len > 0) {\n\t\tend = str + len;\n\t\th = *str;\n\t\tfor (str += 1; str < end; str++)\n\t\t\th = (h << 5) - h + *str;\n\t\treturn h;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic gboolean\nmono_blob_entry_equal (const char *str1, const char *str2) {\n\tint len, len2;\n\tconst char *end1;\n\tconst char *end2;\n\tlen = mono_metadata_decode_blob_size (str1, &end1);\n\tlen2 = mono_metadata_decode_blob_size (str2, &end2);\n\tif (len != len2)\n\t\treturn 0;\n\treturn memcmp (end1, end2, len) == 0;\n}\n#endif\nstatic guint32\nadd_to_blob_cached (MonoDynamicImage *assembly, char *b1, int s1, char *b2, int s2)\n{\n\tguint32 idx;\n\tchar *copy;\n\tgpointer oldkey, oldval;\n\n\tcopy = g_malloc (s1+s2);\n\tmemcpy (copy, b1, s1);\n\tmemcpy (copy + s1, b2, s2);\n\tif (g_hash_table_lookup_extended (assembly->blob_cache, copy, &oldkey, &oldval)) {\n\t\tg_free (copy);\n\t\tidx = GPOINTER_TO_UINT (oldval);\n\t} else {\n\t\tidx = mono_image_add_stream_data (&assembly->blob, b1, s1);\n\t\tmono_image_add_stream_data (&assembly->blob, b2, s2);\n\t\tg_hash_table_insert (assembly->blob_cache, copy, GUINT_TO_POINTER (idx));\n\t}\n\treturn idx;\n}\n\nstatic guint32\nsigbuffer_add_to_blob_cached (MonoDynamicImage *assembly, SigBuffer *buf)\n{\n\tchar blob_size [8];\n\tchar *b = blob_size;\n\tguint32 size = buf->p - buf->buf;\n\t/* store length */\n\tg_assert (size <= (buf->end - buf->buf));\n\tmono_metadata_encode_value (size, b, &b);\n\treturn add_to_blob_cached (assembly, blob_size, b-blob_size, buf->buf, size);\n}\n\n/*\n * Copy len * nelem bytes from val to dest, swapping bytes to LE if necessary.\n * dest may be misaligned.\n */\nstatic void\nswap_with_size (char *dest, const char* val, int len, int nelem) {\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\tint elem;\n\n\tfor (elem = 0; elem < nelem; ++elem) {\n\t\tswitch (len) {\n\t\tcase 1:\n\t\t\t*dest = *val;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdest [0] = val [1];\n\t\t\tdest [1] = val [0];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdest [0] = val [3];\n\t\t\tdest [1] = val [2];\n\t\t\tdest [2] = val [1];\n\t\t\tdest [3] = val [0];\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tdest [0] = val [7];\n\t\t\tdest [1] = val [6];\n\t\t\tdest [2] = val [5];\n\t\t\tdest [3] = val [4];\n\t\t\tdest [4] = val [3];\n\t\t\tdest [5] = val [2];\n\t\t\tdest [6] = val [1];\n\t\t\tdest [7] = val [0];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t\tdest += len;\n\t\tval += len;\n\t}\n#else\n\tmemcpy (dest, val, len * nelem);\n#endif\n}\n\nstatic guint32\nadd_mono_string_to_blob_cached (MonoDynamicImage *assembly, MonoString *str)\n{\n\tchar blob_size [64];\n\tchar *b = blob_size;\n\tguint32 idx = 0, len;\n\n\tlen = str->length * 2;\n\tmono_metadata_encode_value (len, b, &b);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\t{\n\t\tchar *swapped = g_malloc (2 * mono_string_length (str));\n\t\tconst char *p = (const char*)mono_string_chars (str);\n\n\t\tswap_with_size (swapped, p, 2, mono_string_length (str));\n\t\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, swapped, len);\n\t\tg_free (swapped);\n\t}\n#else\n\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, (char*)mono_string_chars (str), len);\n#endif\n\treturn idx;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic MonoClass *\ndefault_class_from_mono_type (MonoType *type)\n{\n\tswitch (type->type) {\n\tcase MONO_TYPE_OBJECT:\n\t\treturn mono_defaults.object_class;\n\tcase MONO_TYPE_VOID:\n\t\treturn mono_defaults.void_class;\n\tcase MONO_TYPE_BOOLEAN:\n\t\treturn mono_defaults.boolean_class;\n\tcase MONO_TYPE_CHAR:\n\t\treturn mono_defaults.char_class;\n\tcase MONO_TYPE_I1:\n\t\treturn mono_defaults.sbyte_class;\n\tcase MONO_TYPE_U1:\n\t\treturn mono_defaults.byte_class;\n\tcase MONO_TYPE_I2:\n\t\treturn mono_defaults.int16_class;\n\tcase MONO_TYPE_U2:\n\t\treturn mono_defaults.uint16_class;\n\tcase MONO_TYPE_I4:\n\t\treturn mono_defaults.int32_class;\n\tcase MONO_TYPE_U4:\n\t\treturn mono_defaults.uint32_class;\n\tcase MONO_TYPE_I:\n\t\treturn mono_defaults.int_class;\n\tcase MONO_TYPE_U:\n\t\treturn mono_defaults.uint_class;\n\tcase MONO_TYPE_I8:\n\t\treturn mono_defaults.int64_class;\n\tcase MONO_TYPE_U8:\n\t\treturn mono_defaults.uint64_class;\n\tcase MONO_TYPE_R4:\n\t\treturn mono_defaults.single_class;\n\tcase MONO_TYPE_R8:\n\t\treturn mono_defaults.double_class;\n\tcase MONO_TYPE_STRING:\n\t\treturn mono_defaults.string_class;\n\tdefault:\n\t\tg_warning (\"default_class_from_mono_type: implement me 0x%02x\\n\", type->type);\n\t\tg_assert_not_reached ();\n\t}\n\t\n\treturn NULL;\n}\n#endif\n\nstatic void\nencode_generic_class (MonoDynamicImage *assembly, MonoGenericClass *gclass, SigBuffer *buf)\n{\n\tint i;\n\tMonoGenericInst *class_inst;\n\tMonoClass *klass;\n\n\tg_assert (gclass);\n\n\tclass_inst = gclass->context.class_inst;\n\n\tsigbuffer_add_value (buf, MONO_TYPE_GENERICINST);\n\tklass = gclass->container_class;\n\tsigbuffer_add_value (buf, klass->byval_arg.type);\n\tsigbuffer_add_value (buf, mono_image_typedef_or_ref_full (assembly, &klass->byval_arg, FALSE));\n\n\tsigbuffer_add_value (buf, class_inst->type_argc);\n\tfor (i = 0; i < class_inst->type_argc; ++i)\n\t\tencode_type (assembly, class_inst->type_argv [i], buf);\n\n}\n\nstatic void\nencode_type (MonoDynamicImage *assembly, MonoType *type, SigBuffer *buf)\n{\n\tif (!type) {\n\t\tg_assert_not_reached ();\n\t\treturn;\n\t}\n\t\t\n\tif (type->byref)\n\t\tsigbuffer_add_value (buf, MONO_TYPE_BYREF);\n\n\tswitch (type->type){\n\tcase MONO_TYPE_VOID:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tbreak;\n\tcase MONO_TYPE_PTR:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tencode_type (assembly, type->data.type, buf);\n\t\tbreak;\n\tcase MONO_TYPE_SZARRAY:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tencode_type (assembly, &type->data.klass->byval_arg, buf);\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS: {\n\t\tMonoClass *k = mono_class_from_mono_type (type);\n\n\t\tif (k->generic_container) {\n\t\t\tMonoGenericClass *gclass = mono_metadata_lookup_generic_class (k, k->generic_container->context.class_inst, TRUE);\n\t\t\tencode_generic_class (assembly, gclass, buf);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make sure we use the correct type.\n\t\t\t */\n\t\t\tsigbuffer_add_value (buf, k->byval_arg.type);\n\t\t\t/*\n\t\t\t * ensure only non-byref gets passed to mono_image_typedef_or_ref(),\n\t\t\t * otherwise two typerefs could point to the same type, leading to\n\t\t\t * verification errors.\n\t\t\t */\n\t\t\tsigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, &k->byval_arg));\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_ARRAY:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tencode_type (assembly, &type->data.array->eklass->byval_arg, buf);\n\t\tsigbuffer_add_value (buf, type->data.array->rank);\n\t\tsigbuffer_add_value (buf, 0); /* FIXME: set to 0 for now */\n\t\tsigbuffer_add_value (buf, 0);\n\t\tbreak;\n\tcase MONO_TYPE_GENERICINST:\n\t\tencode_generic_class (assembly, type->data.generic_class, buf);\n\t\tbreak;\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tsigbuffer_add_value (buf, mono_type_get_generic_param_num (type));\n\t\tbreak;\n\tdefault:\n\t\tg_error (\"need to encode type %x\", type->type);\n\t}\n}\n\nstatic void\nencode_reflection_type (MonoDynamicImage *assembly, MonoReflectionType *type, SigBuffer *buf)\n{\n\tif (!type) {\n\t\tsigbuffer_add_value (buf, MONO_TYPE_VOID);\n\t\treturn;\n\t}\n\n\tencode_type (assembly, mono_reflection_type_get_handle (type), buf);\n}\n\nstatic void\nencode_custom_modifiers (MonoDynamicImage *assembly, MonoArray *modreq, MonoArray *modopt, SigBuffer *buf)\n{\n\tint i;\n\n\tif (modreq) {\n\t\tfor (i = 0; i < mono_array_length (modreq); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modreq, i);\n\t\t\tsigbuffer_add_byte (buf, MONO_TYPE_CMOD_REQD);\n\t\t\tsigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, mod));\n\t\t}\n\t}\n\tif (modopt) {\n\t\tfor (i = 0; i < mono_array_length (modopt); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modopt, i);\n\t\t\tsigbuffer_add_byte (buf, MONO_TYPE_CMOD_OPT);\n\t\t\tsigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, mod));\n\t\t}\n\t}\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32\nmethod_encode_signature (MonoDynamicImage *assembly, MonoMethodSignature *sig)\n{\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams =  sig->param_count;\n\tguint32 idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\t/*\n\t * FIXME: vararg, explicit_this, differenc call_conv values...\n\t */\n\tidx = sig->call_convention;\n\tif (sig->hasthis)\n\t\tidx |= 0x20; /* hasthis */\n\tif (sig->generic_param_count)\n\t\tidx |= 0x10; /* generic */\n\tsigbuffer_add_byte (&buf, idx);\n\tif (sig->generic_param_count)\n\t\tsigbuffer_add_value (&buf, sig->generic_param_count);\n\tsigbuffer_add_value (&buf, nparams);\n\tencode_type (assembly, sig->ret, &buf);\n\tfor (i = 0; i < nparams; ++i) {\n\t\tif (i == sig->sentinelpos)\n\t\t\tsigbuffer_add_byte (&buf, MONO_TYPE_SENTINEL);\n\t\tencode_type (assembly, sig->params [i], &buf);\n\t}\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n#endif\n\nstatic guint32\nmethod_builder_encode_signature (MonoDynamicImage *assembly, ReflectionMethodBuilder *mb)\n{\n\t/*\n\t * FIXME: reuse code from method_encode_signature().\n\t */\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams =  mb->parameters ? mono_array_length (mb->parameters): 0;\n\tguint32 ngparams = mb->generic_params ? mono_array_length (mb->generic_params): 0;\n\tguint32 notypes = mb->opt_types ? mono_array_length (mb->opt_types): 0;\n\tguint32 idx;\n\n\tsigbuffer_init (&buf, 32);\n\t/* LAMESPEC: all the call conv spec is foobared */\n\tidx = mb->call_conv & 0x60; /* has-this, explicit-this */\n\tif (mb->call_conv & 2)\n\t\tidx |= 0x5; /* vararg */\n\tif (!(mb->attrs & METHOD_ATTRIBUTE_STATIC))\n\t\tidx |= 0x20; /* hasthis */\n\tif (ngparams)\n\t\tidx |= 0x10; /* generic */\n\tsigbuffer_add_byte (&buf, idx);\n\tif (ngparams)\n\t\tsigbuffer_add_value (&buf, ngparams);\n\tsigbuffer_add_value (&buf, nparams + notypes);\n\tencode_custom_modifiers (assembly, mb->return_modreq, mb->return_modopt, &buf);\n\tencode_reflection_type (assembly, mb->rtype, &buf);\n\tfor (i = 0; i < nparams; ++i) {\n\t\tMonoArray *modreq = NULL;\n\t\tMonoArray *modopt = NULL;\n\t\tMonoReflectionType *pt;\n\n\t\tif (mb->param_modreq && (i < mono_array_length (mb->param_modreq)))\n\t\t\tmodreq = mono_array_get (mb->param_modreq, MonoArray*, i);\n\t\tif (mb->param_modopt && (i < mono_array_length (mb->param_modopt)))\n\t\t\tmodopt = mono_array_get (mb->param_modopt, MonoArray*, i);\n\t\tencode_custom_modifiers (assembly, modreq, modopt, &buf);\n\t\tpt = mono_array_get (mb->parameters, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, pt, &buf);\n\t}\n\tif (notypes)\n\t\tsigbuffer_add_byte (&buf, MONO_TYPE_SENTINEL);\n\tfor (i = 0; i < notypes; ++i) {\n\t\tMonoReflectionType *pt;\n\n\t\tpt = mono_array_get (mb->opt_types, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, pt, &buf);\n\t}\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nencode_locals (MonoDynamicImage *assembly, MonoReflectionILGen *ilgen)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 idx, sig_idx;\n\tguint nl = mono_array_length (ilgen->locals);\n\tSigBuffer buf;\n\tint i;\n\n\tsigbuffer_init (&buf, 32);\n\tsigbuffer_add_value (&buf, 0x07);\n\tsigbuffer_add_value (&buf, nl);\n\tfor (i = 0; i < nl; ++i) {\n\t\tMonoReflectionLocalBuilder *lb = mono_array_get (ilgen->locals, MonoReflectionLocalBuilder*, i);\n\t\t\n\t\tif (lb->is_pinned)\n\t\t\tsigbuffer_add_value (&buf, MONO_TYPE_PINNED);\n\t\t\n\t\tencode_reflection_type (assembly, (MonoReflectionType*)lb->type, &buf);\n\t}\n\tsig_idx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\n\tif (assembly->standalonesig_cache == NULL)\n\t\tassembly->standalonesig_cache = g_hash_table_new (NULL, NULL);\n\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->standalonesig_cache, GUINT_TO_POINTER (sig_idx)));\n\tif (idx)\n\t\treturn idx;\n\n\ttable = &assembly->tables [MONO_TABLE_STANDALONESIG];\n\tidx = table->next_idx ++;\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + idx * MONO_STAND_ALONE_SIGNATURE_SIZE;\n\n\tvalues [MONO_STAND_ALONE_SIGNATURE] = sig_idx;\n\n\tg_hash_table_insert (assembly->standalonesig_cache, GUINT_TO_POINTER (sig_idx), GUINT_TO_POINTER (idx));\n\n\treturn idx;\n}\n\nstatic guint32\nmethod_count_clauses (MonoReflectionILGen *ilgen)\n{\n\tguint32 num_clauses = 0;\n\tint i;\n\n\tMonoILExceptionInfo *ex_info;\n\tfor (i = 0; i < mono_array_length (ilgen->ex_handlers); ++i) {\n\t\tex_info = (MonoILExceptionInfo*)mono_array_addr (ilgen->ex_handlers, MonoILExceptionInfo, i);\n\t\tif (ex_info->handlers)\n\t\t\tnum_clauses += mono_array_length (ex_info->handlers);\n\t\telse\n\t\t\tnum_clauses++;\n\t}\n\n\treturn num_clauses;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic MonoExceptionClause*\nmethod_encode_clauses (MonoImage *image, MonoDynamicImage *assembly, MonoReflectionILGen *ilgen, guint32 num_clauses)\n{\n\tMonoExceptionClause *clauses;\n\tMonoExceptionClause *clause;\n\tMonoILExceptionInfo *ex_info;\n\tMonoILExceptionBlock *ex_block;\n\tguint32 finally_start;\n\tint i, j, clause_index;;\n\n\tclauses = image_g_new0 (image, MonoExceptionClause, num_clauses);\n\n\tclause_index = 0;\n\tfor (i = mono_array_length (ilgen->ex_handlers) - 1; i >= 0; --i) {\n\t\tex_info = (MonoILExceptionInfo*)mono_array_addr (ilgen->ex_handlers, MonoILExceptionInfo, i);\n\t\tfinally_start = ex_info->start + ex_info->len;\n\t\tif (!ex_info->handlers)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < mono_array_length (ex_info->handlers); ++j) {\n\t\t\tex_block = (MonoILExceptionBlock*)mono_array_addr (ex_info->handlers, MonoILExceptionBlock, j);\n\t\t\tclause = &(clauses [clause_index]);\n\n\t\t\tclause->flags = ex_block->type;\n\t\t\tclause->try_offset = ex_info->start;\n\n\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FINALLY)\n\t\t\t\tclause->try_len = finally_start - ex_info->start;\n\t\t\telse\n\t\t\t\tclause->try_len = ex_info->len;\n\t\t\tclause->handler_offset = ex_block->start;\n\t\t\tclause->handler_len = ex_block->len;\n\t\t\tif (ex_block->extype) {\n\t\t\t\tclause->data.catch_class = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)ex_block->extype));\n\t\t\t} else {\n\t\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\t\t\tclause->data.filter_offset = ex_block->filter_offset;\n\t\t\t\telse\n\t\t\t\t\tclause->data.filter_offset = 0;\n\t\t\t}\n\t\t\tfinally_start = ex_block->start + ex_block->len;\n\n\t\t\tclause_index ++;\n\t\t}\n\t}\n\n\treturn clauses;\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\nstatic guint32\nmethod_encode_code (MonoDynamicImage *assembly, ReflectionMethodBuilder *mb)\n{\n\tchar flags = 0;\n\tguint32 idx;\n\tguint32 code_size;\n\tgint32 max_stack, i;\n\tgint32 num_locals = 0;\n\tgint32 num_exception = 0;\n\tgint maybe_small;\n\tguint32 fat_flags;\n\tchar fat_header [12];\n\tguint32 int_value;\n\tguint16 short_value;\n\tguint32 local_sig = 0;\n\tguint32 header_size = 12;\n\tMonoArray *code;\n\n\tif ((mb->attrs & (METHOD_ATTRIBUTE_PINVOKE_IMPL | METHOD_ATTRIBUTE_ABSTRACT)) ||\n\t\t\t(mb->iattrs & (METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL | METHOD_IMPL_ATTRIBUTE_RUNTIME)))\n\t\treturn 0;\n\n\t/*if (mb->name)\n\t\tg_print (\"Encode method %s\\n\", mono_string_to_utf8 (mb->name));*/\n\tif (mb->ilgen) {\n\t\tcode = mb->ilgen->code;\n\t\tcode_size = mb->ilgen->code_len;\n\t\tmax_stack = mb->ilgen->max_stack;\n\t\tnum_locals = mb->ilgen->locals ? mono_array_length (mb->ilgen->locals) : 0;\n\t\tif (mb->ilgen->ex_handlers)\n\t\t\tnum_exception = method_count_clauses (mb->ilgen);\n\t} else {\n\t\tcode = mb->code;\n\t\tif (code == NULL){\n\t\t\tchar *name = mono_string_to_utf8 (mb->name);\n\t\t\tchar *str = g_strdup_printf (\"Method %s does not have any IL associated\", name);\n\t\t\tMonoException *exception = mono_get_exception_argument (NULL, \"a method does not have any IL associated\");\n\t\t\tg_free (str);\n\t\t\tg_free (name);\n\t\t\tmono_raise_exception (exception);\n\t\t}\n\n\t\tcode_size = mono_array_length (code);\n\t\tmax_stack = 8; /* we probably need to run a verifier on the code... */\n\t}\n\n\tstream_data_align (&assembly->code);\n\n\t/* check for exceptions, maxstack, locals */\n\tmaybe_small = (max_stack <= 8) && (!num_locals) && (!num_exception);\n\tif (maybe_small) {\n\t\tif (code_size < 64 && !(code_size & 1)) {\n\t\t\tflags = (code_size << 2) | 0x2;\n\t\t} else if (code_size < 32 && (code_size & 1)) {\n\t\t\tflags = (code_size << 2) | 0x6; /* LAMESPEC: see metadata.c */\n\t\t} else {\n\t\t\tgoto fat_header;\n\t\t}\n\t\tidx = mono_image_add_stream_data (&assembly->code, &flags, 1);\n\t\t/* add to the fixup todo list */\n\t\tif (mb->ilgen && mb->ilgen->num_token_fixups)\n\t\t\tmono_g_hash_table_insert (assembly->token_fixups, mb->ilgen, GUINT_TO_POINTER (idx + 1));\n\t\tmono_image_add_stream_data (&assembly->code, mono_array_addr (code, char, 0), code_size);\n\t\treturn assembly->text_rva + idx;\n\t} \nfat_header:\n\tif (num_locals)\n\t\tlocal_sig = MONO_TOKEN_SIGNATURE | encode_locals (assembly, mb->ilgen);\n\t/* \n\t * FIXME: need to set also the header size in fat_flags.\n\t * (and more sects and init locals flags)\n\t */\n\tfat_flags =  0x03;\n\tif (num_exception)\n\t\tfat_flags |= METHOD_HEADER_MORE_SECTS;\n\tif (mb->init_locals)\n\t\tfat_flags |= METHOD_HEADER_INIT_LOCALS;\n\tfat_header [0] = fat_flags;\n\tfat_header [1] = (header_size / 4 ) << 4;\n\tshort_value = GUINT16_TO_LE (max_stack);\n\tmemcpy (fat_header + 2, &short_value, 2);\n\tint_value = GUINT32_TO_LE (code_size);\n\tmemcpy (fat_header + 4, &int_value, 4);\n\tint_value = GUINT32_TO_LE (local_sig);\n\tmemcpy (fat_header + 8, &int_value, 4);\n\tidx = mono_image_add_stream_data (&assembly->code, fat_header, 12);\n\t/* add to the fixup todo list */\n\tif (mb->ilgen && mb->ilgen->num_token_fixups)\n\t\tmono_g_hash_table_insert (assembly->token_fixups, mb->ilgen, GUINT_TO_POINTER (idx + 12));\n\t\n\tmono_image_add_stream_data (&assembly->code, mono_array_addr (code, char, 0), code_size);\n\tif (num_exception) {\n\t\tunsigned char sheader [4];\n\t\tMonoILExceptionInfo * ex_info;\n\t\tMonoILExceptionBlock * ex_block;\n\t\tint j;\n\n\t\tstream_data_align (&assembly->code);\n\t\t/* always use fat format for now */\n\t\tsheader [0] = METHOD_HEADER_SECTION_FAT_FORMAT | METHOD_HEADER_SECTION_EHTABLE;\n\t\tnum_exception *= 6 * sizeof (guint32);\n\t\tnum_exception += 4; /* include the size of the header */\n\t\tsheader [1] = num_exception & 0xff;\n\t\tsheader [2] = (num_exception >> 8) & 0xff;\n\t\tsheader [3] = (num_exception >> 16) & 0xff;\n\t\tmono_image_add_stream_data (&assembly->code, (char*)sheader, 4);\n\t\t/* fat header, so we are already aligned */\n\t\t/* reverse order */\n\t\tfor (i = mono_array_length (mb->ilgen->ex_handlers) - 1; i >= 0; --i) {\n\t\t\tex_info = (MonoILExceptionInfo *)mono_array_addr (mb->ilgen->ex_handlers, MonoILExceptionInfo, i);\n\t\t\tif (ex_info->handlers) {\n\t\t\t\tint finally_start = ex_info->start + ex_info->len;\n\t\t\t\tfor (j = 0; j < mono_array_length (ex_info->handlers); ++j) {\n\t\t\t\t\tguint32 val;\n\t\t\t\t\tex_block = (MonoILExceptionBlock*)mono_array_addr (ex_info->handlers, MonoILExceptionBlock, j);\n\t\t\t\t\t/* the flags */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_block->type);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* try offset */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_info->start);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* need fault, too, probably */\n\t\t\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FINALLY)\n\t\t\t\t\t\tval = GUINT32_TO_LE (finally_start - ex_info->start);\n\t\t\t\t\telse\n\t\t\t\t\t\tval = GUINT32_TO_LE (ex_info->len);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* handler offset */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_block->start);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* handler len */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_block->len);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\tfinally_start = ex_block->start + ex_block->len;\n\t\t\t\t\tif (ex_block->extype) {\n\t\t\t\t\t\tval = mono_metadata_token_from_dor (mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)ex_block->extype)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\t\t\t\t\tval = ex_block->filter_offset;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tval = 0;\n\t\t\t\t\t}\n\t\t\t\t\tval = GUINT32_TO_LE (val);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/*g_print (\"out clause %d: from %d len=%d, handler at %d, %d, finally_start=%d, ex_info->start=%d, ex_info->len=%d, ex_block->type=%d, j=%d, i=%d\\n\", \n\t\t\t\t\t\t\tclause.flags, clause.try_offset, clause.try_len, clause.handler_offset, clause.handler_len, finally_start, ex_info->start, ex_info->len, ex_block->type, j, i);*/\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tg_error (\"No clauses for ex info block %d\", i);\n\t\t\t}\n\t\t}\n\t}\n\treturn assembly->text_rva + idx;\n}\n\nstatic guint32\nfind_index_in_table (MonoDynamicImage *assembly, int table_idx, int col, guint32 token)\n{\n\tint i;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\t\n\ttable = &assembly->tables [table_idx];\n\n\tg_assert (col < table->columns);\n\n\tvalues = table->values + table->columns;\n\tfor (i = 1; i <= table->rows; ++i) {\n\t\tif (values [col] == token)\n\t\t\treturn i;\n\t\tvalues += table->columns;\n\t}\n\treturn 0;\n}\n\n/*\n * LOCKING: Acquires the loader lock. \n */\nstatic MonoCustomAttrInfo*\nlookup_custom_attr (MonoImage *image, gpointer member)\n{\n\tMonoCustomAttrInfo* res;\n\n\tres = mono_image_property_lookup (image, member, MONO_PROP_DYNAMIC_CATTR);\n\n\tif (!res)\n\t\treturn NULL;\n\n\treturn g_memdup (res, MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * res->num_attrs);\n}\n\nstatic gboolean\ncustom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)\n{\n\t/* FIXME: Need to do more checks */\n\tif (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {\n\t\tint visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\n\t\tif ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic MonoCustomAttrInfo*\nmono_custom_attrs_from_builders (MonoImage *alloc_img, MonoImage *image, MonoArray *cattrs)\n{\n\tint i, index, count, not_visible;\n\tMonoCustomAttrInfo *ainfo;\n\tMonoReflectionCustomAttr *cattr;\n\n\tif (!cattrs)\n\t\treturn NULL;\n\t/* FIXME: check in assembly the Run flag is set */\n\n\tcount = mono_array_length (cattrs);\n\n\t/* Skip nonpublic attributes since MS.NET seems to do the same */\n\t/* FIXME: This needs to be done more globally */\n\tnot_visible = 0;\n\tfor (i = 0; i < count; ++i) {\n\t\tcattr = (MonoReflectionCustomAttr*)mono_array_get (cattrs, gpointer, i);\n\t\tif (!custom_attr_visible (image, cattr))\n\t\t\tnot_visible ++;\n\t}\n\tcount -= not_visible;\n\n\tainfo = image_g_malloc0 (alloc_img, MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * count);\n\n\tainfo->image = image;\n\tainfo->num_attrs = count;\n\tainfo->cached = alloc_img != NULL;\n\tindex = 0;\n\tfor (i = 0; i < count; ++i) {\n\t\tcattr = (MonoReflectionCustomAttr*)mono_array_get (cattrs, gpointer, i);\n\t\tif (custom_attr_visible (image, cattr)) {\n\t\t\tunsigned char *saved = mono_image_alloc (image, mono_array_length (cattr->data));\n\t\t\tmemcpy (saved, mono_array_addr (cattr->data, char, 0), mono_array_length (cattr->data));\n\t\t\tainfo->attrs [index].ctor = cattr->ctor->method;\n\t\t\tainfo->attrs [index].data = saved;\n\t\t\tainfo->attrs [index].data_size = mono_array_length (cattr->data);\n\t\t\tindex ++;\n\t\t}\n\t}\n\n\treturn ainfo;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/*\n * LOCKING: Acquires the loader lock. \n */\nstatic void\nmono_save_custom_attrs (MonoImage *image, void *obj, MonoArray *cattrs)\n{\n\tMonoCustomAttrInfo *ainfo, *tmp;\n\n\tif (!cattrs || !mono_array_length (cattrs))\n\t\treturn;\n\n\tainfo = mono_custom_attrs_from_builders (image, image, cattrs);\n\n\tmono_loader_lock ();\n\ttmp = mono_image_property_lookup (image, obj, MONO_PROP_DYNAMIC_CATTR);\n\tif (tmp)\n\t\tmono_custom_attrs_free (tmp);\n\tmono_image_property_insert (image, obj, MONO_PROP_DYNAMIC_CATTR, ainfo);\n\tmono_loader_unlock ();\n\n}\n#endif\n\nvoid\nmono_custom_attrs_free (MonoCustomAttrInfo *ainfo)\n{\n\tif (!ainfo->cached)\n\t\tg_free (ainfo);\n}\n\n/*\n * idx is the table index of the object\n * type is one of MONO_CUSTOM_ATTR_*\n */\nstatic void\nmono_image_add_cattrs (MonoDynamicImage *assembly, guint32 idx, guint32 type, MonoArray *cattrs)\n{\n\tMonoDynamicTable *table;\n\tMonoReflectionCustomAttr *cattr;\n\tguint32 *values;\n\tguint32 count, i, token;\n\tchar blob_size [6];\n\tchar *p = blob_size;\n\t\n\t/* it is legal to pass a NULL cattrs: we avoid to use the if in a lot of places */\n\tif (!cattrs)\n\t\treturn;\n\tcount = mono_array_length (cattrs);\n\ttable = &assembly->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\ttable->rows += count;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_CUSTOM_ATTR_SIZE;\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= type;\n\tfor (i = 0; i < count; ++i) {\n\t\tcattr = (MonoReflectionCustomAttr*)mono_array_get (cattrs, gpointer, i);\n\t\tvalues [MONO_CUSTOM_ATTR_PARENT] = idx;\n\t\ttoken = mono_image_create_token (assembly, (MonoObject*)cattr->ctor, FALSE, FALSE);\n\t\ttype = mono_metadata_token_index (token);\n\t\ttype <<= MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\tswitch (mono_metadata_token_table (token)) {\n\t\tcase MONO_TABLE_METHOD:\n\t\t\ttype |= MONO_CUSTOM_ATTR_TYPE_METHODDEF;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_MEMBERREF:\n\t\t\ttype |= MONO_CUSTOM_ATTR_TYPE_MEMBERREF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_warning (\"got wrong token in custom attr\");\n\t\t\tcontinue;\n\t\t}\n\t\tvalues [MONO_CUSTOM_ATTR_TYPE] = type;\n\t\tp = blob_size;\n\t\tmono_metadata_encode_value (mono_array_length (cattr->data), p, &p);\n\t\tvalues [MONO_CUSTOM_ATTR_VALUE] = add_to_blob_cached (assembly, blob_size, p - blob_size,\n\t\t\tmono_array_addr (cattr->data, char, 0), mono_array_length (cattr->data));\n\t\tvalues += MONO_CUSTOM_ATTR_SIZE;\n\t\t++table->next_idx;\n\t}\n}\n\nstatic void\nmono_image_add_decl_security (MonoDynamicImage *assembly, guint32 parent_token, MonoArray *permissions)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 count, i, idx;\n\tMonoReflectionPermissionSet *perm;\n\n\tif (!permissions)\n\t\treturn;\n\n\tcount = mono_array_length (permissions);\n\ttable = &assembly->tables [MONO_TABLE_DECLSECURITY];\n\ttable->rows += count;\n\talloc_table (table, table->rows);\n\n\tfor (i = 0; i < mono_array_length (permissions); ++i) {\n\t\tperm = (MonoReflectionPermissionSet*)mono_array_addr (permissions, MonoReflectionPermissionSet, i);\n\n\t\tvalues = table->values + table->next_idx * MONO_DECL_SECURITY_SIZE;\n\n\t\tidx = mono_metadata_token_index (parent_token);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tswitch (mono_metadata_token_table (parent_token)) {\n\t\tcase MONO_TABLE_TYPEDEF:\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_METHOD:\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_ASSEMBLY:\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_ASSEMBLY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tvalues [MONO_DECL_SECURITY_ACTION] = perm->action;\n\t\tvalues [MONO_DECL_SECURITY_PARENT] = idx;\n\t\tvalues [MONO_DECL_SECURITY_PERMISSIONSET] = add_mono_string_to_blob_cached (assembly, perm->pset);\n\n\t\t++table->next_idx;\n\t}\n}\n\n/*\n * Fill in the MethodDef and ParamDef tables for a method.\n * This is used for both normal methods and constructors.\n */\nstatic void\nmono_image_basic_method (ReflectionMethodBuilder *mb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint i, count;\n\n\t/* room in this table is already allocated */\n\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t*mb->table_idx = table->next_idx ++;\n\tg_hash_table_insert (assembly->method_to_table_idx, mb->mhandle, GUINT_TO_POINTER ((*mb->table_idx)));\n\tvalues = table->values + *mb->table_idx * MONO_METHOD_SIZE;\n\tvalues [MONO_METHOD_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->name);\n\tvalues [MONO_METHOD_FLAGS] = mb->attrs;\n\tvalues [MONO_METHOD_IMPLFLAGS] = mb->iattrs;\n\tvalues [MONO_METHOD_SIGNATURE] = method_builder_encode_signature (assembly, mb);\n\tvalues [MONO_METHOD_RVA] = method_encode_code (assembly, mb);\n\t\n\ttable = &assembly->tables [MONO_TABLE_PARAM];\n\tvalues [MONO_METHOD_PARAMLIST] = table->next_idx;\n\n\tmono_image_add_decl_security (assembly, \n\t\tmono_metadata_make_token (MONO_TABLE_METHOD, *mb->table_idx), mb->permissions);\n\n\tif (mb->pinfo) {\n\t\tMonoDynamicTable *mtable;\n\t\tguint32 *mvalues;\n\t\t\n\t\tmtable = &assembly->tables [MONO_TABLE_FIELDMARSHAL];\n\t\tmvalues = mtable->values + mtable->next_idx * MONO_FIELD_MARSHAL_SIZE;\n\t\t\n\t\tcount = 0;\n\t\tfor (i = 0; i < mono_array_length (mb->pinfo); ++i) {\n\t\t\tif (mono_array_get (mb->pinfo, gpointer, i))\n\t\t\t\tcount++;\n\t\t}\n\t\ttable->rows += count;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->next_idx * MONO_PARAM_SIZE;\n\t\tfor (i = 0; i < mono_array_length (mb->pinfo); ++i) {\n\t\t\tMonoReflectionParamBuilder *pb;\n\t\t\tif ((pb = mono_array_get (mb->pinfo, MonoReflectionParamBuilder*, i))) {\n\t\t\t\tvalues [MONO_PARAM_FLAGS] = pb->attrs;\n\t\t\t\tvalues [MONO_PARAM_SEQUENCE] = i;\n\t\t\t\tif (pb->name != NULL) {\n\t\t\t\t\tvalues [MONO_PARAM_NAME] = string_heap_insert_mstring (&assembly->sheap, pb->name);\n\t\t\t\t} else {\n\t\t\t\t\tvalues [MONO_PARAM_NAME] = 0;\n\t\t\t\t}\n\t\t\t\tvalues += MONO_PARAM_SIZE;\n\t\t\t\tif (pb->marshal_info) {\n\t\t\t\t\tmtable->rows++;\n\t\t\t\t\talloc_table (mtable, mtable->rows);\n\t\t\t\t\tmvalues = mtable->values + mtable->rows * MONO_FIELD_MARSHAL_SIZE;\n\t\t\t\t\tmvalues [MONO_FIELD_MARSHAL_PARENT] = (table->next_idx << MONO_HAS_FIELD_MARSHAL_BITS) | MONO_HAS_FIELD_MARSHAL_PARAMDEF;\n\t\t\t\t\tmvalues [MONO_FIELD_MARSHAL_NATIVE_TYPE] = encode_marshal_blob (assembly, pb->marshal_info);\n\t\t\t\t}\n\t\t\t\tpb->table_idx = table->next_idx++;\n\t\t\t\tif (pb->attrs & PARAM_ATTRIBUTE_HAS_DEFAULT) {\n\t\t\t\t\tguint32 field_type = 0;\n\t\t\t\t\tmtable = &assembly->tables [MONO_TABLE_CONSTANT];\n\t\t\t\t\tmtable->rows ++;\n\t\t\t\t\talloc_table (mtable, mtable->rows);\n\t\t\t\t\tmvalues = mtable->values + mtable->rows * MONO_CONSTANT_SIZE;\n\t\t\t\t\tmvalues [MONO_CONSTANT_PARENT] = MONO_HASCONSTANT_PARAM | (pb->table_idx << MONO_HASCONSTANT_BITS);\n\t\t\t\t\tmvalues [MONO_CONSTANT_VALUE] = encode_constant (assembly, pb->def_value, &field_type);\n\t\t\t\t\tmvalues [MONO_CONSTANT_TYPE] = field_type;\n\t\t\t\t\tmvalues [MONO_CONSTANT_PADDING] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nreflection_methodbuilder_from_method_builder (ReflectionMethodBuilder *rmb, MonoReflectionMethodBuilder *mb)\n{\n\tmemset (rmb, 0, sizeof (ReflectionMethodBuilder));\n\n\trmb->ilgen = mb->ilgen;\n\trmb->rtype = mono_reflection_type_resolve_user_types ((MonoReflectionType*)mb->rtype);\n\trmb->parameters = mb->parameters;\n\trmb->generic_params = mb->generic_params;\n\trmb->generic_container = mb->generic_container;\n\trmb->opt_types = NULL;\n\trmb->pinfo = mb->pinfo;\n\trmb->attrs = mb->attrs;\n\trmb->iattrs = mb->iattrs;\n\trmb->call_conv = mb->call_conv;\n\trmb->code = mb->code;\n\trmb->type = mb->type;\n\trmb->name = mb->name;\n\trmb->table_idx = &mb->table_idx;\n\trmb->init_locals = mb->init_locals;\n\trmb->skip_visibility = FALSE;\n\trmb->return_modreq = mb->return_modreq;\n\trmb->return_modopt = mb->return_modopt;\n\trmb->param_modreq = mb->param_modreq;\n\trmb->param_modopt = mb->param_modopt;\n\trmb->permissions = mb->permissions;\n\trmb->mhandle = mb->mhandle;\n\trmb->nrefs = 0;\n\trmb->refs = NULL;\n\n\tif (mb->dll) {\n\t\trmb->charset = mb->charset;\n\t\trmb->extra_flags = mb->extra_flags;\n\t\trmb->native_cc = mb->native_cc;\n\t\trmb->dllentry = mb->dllentry;\n\t\trmb->dll = mb->dll;\n\t}\n}\n\nstatic void\nreflection_methodbuilder_from_ctor_builder (ReflectionMethodBuilder *rmb, MonoReflectionCtorBuilder *mb)\n{\n\tconst char *name = mb->attrs & METHOD_ATTRIBUTE_STATIC ? \".cctor\": \".ctor\";\n\n\tmemset (rmb, 0, sizeof (ReflectionMethodBuilder));\n\n\trmb->ilgen = mb->ilgen;\n\trmb->rtype = mono_type_get_object (mono_domain_get (), &mono_defaults.void_class->byval_arg);\n\trmb->parameters = mb->parameters;\n\trmb->generic_params = NULL;\n\trmb->generic_container = NULL;\n\trmb->opt_types = NULL;\n\trmb->pinfo = mb->pinfo;\n\trmb->attrs = mb->attrs;\n\trmb->iattrs = mb->iattrs;\n\trmb->call_conv = mb->call_conv;\n\trmb->code = NULL;\n\trmb->type = mb->type;\n\trmb->name = mono_string_new (mono_domain_get (), name);\n\trmb->table_idx = &mb->table_idx;\n\trmb->init_locals = mb->init_locals;\n\trmb->skip_visibility = FALSE;\n\trmb->return_modreq = NULL;\n\trmb->return_modopt = NULL;\n\trmb->param_modreq = mb->param_modreq;\n\trmb->param_modopt = mb->param_modopt;\n\trmb->permissions = mb->permissions;\n\trmb->mhandle = mb->mhandle;\n\trmb->nrefs = 0;\n\trmb->refs = NULL;\n}\n\nstatic void\nreflection_methodbuilder_from_dynamic_method (ReflectionMethodBuilder *rmb, MonoReflectionDynamicMethod *mb)\n{\n\tmemset (rmb, 0, sizeof (ReflectionMethodBuilder));\n\n\trmb->ilgen = mb->ilgen;\n\trmb->rtype = mb->rtype;\n\trmb->parameters = mb->parameters;\n\trmb->generic_params = NULL;\n\trmb->generic_container = NULL;\n\trmb->opt_types = NULL;\n\trmb->pinfo = NULL;\n\trmb->attrs = mb->attrs;\n\trmb->iattrs = 0;\n\trmb->call_conv = mb->call_conv;\n\trmb->code = NULL;\n\trmb->type = (MonoObject *) mb->owner;\n\trmb->name = mb->name;\n\trmb->table_idx = NULL;\n\trmb->init_locals = mb->init_locals;\n\trmb->skip_visibility = mb->skip_visibility;\n\trmb->return_modreq = NULL;\n\trmb->return_modopt = NULL;\n\trmb->param_modreq = NULL;\n\trmb->param_modopt = NULL;\n\trmb->permissions = NULL;\n\trmb->mhandle = mb->mhandle;\n\trmb->nrefs = 0;\n\trmb->refs = NULL;\n}\t\n#endif\n\nstatic void\nmono_image_add_methodimpl (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb)\n{\n\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)mb->type;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 tok;\n\n\tif (!mb->override_method)\n\t\treturn;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODIMPL];\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->rows * MONO_METHODIMPL_SIZE;\n\tvalues [MONO_METHODIMPL_CLASS] = tb->table_idx;\n\tvalues [MONO_METHODIMPL_BODY] = MONO_METHODDEFORREF_METHODDEF | (mb->table_idx << MONO_METHODDEFORREF_BITS);\n\n\ttok = mono_image_create_token (assembly, (MonoObject*)mb->override_method, FALSE, FALSE);\n\tswitch (mono_metadata_token_table (tok)) {\n\tcase MONO_TABLE_MEMBERREF:\n\t\ttok = (mono_metadata_token_index (tok) << MONO_METHODDEFORREF_BITS ) | MONO_METHODDEFORREF_METHODREF;\n\t\tbreak;\n\tcase MONO_TABLE_METHOD:\n\t\ttok = (mono_metadata_token_index (tok) << MONO_METHODDEFORREF_BITS ) | MONO_METHODDEFORREF_METHODDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\tvalues [MONO_METHODIMPL_DECLARATION] = tok;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nmono_image_get_method_info (MonoReflectionMethodBuilder *mb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tReflectionMethodBuilder rmb;\n\tint i;\n\n\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\n\tmono_image_basic_method (&rmb, assembly);\n\tmb->table_idx = *rmb.table_idx;\n\n\tif (mb->dll) { /* It's a P/Invoke method */\n\t\tguint32 moduleref;\n\t\t/* map CharSet values to on-disk values */\n\t\tint ncharset = (mb->charset ? (mb->charset - 1) * 2 : 0);\n\t\tint extra_flags = mb->extra_flags;\n\t\ttable = &assembly->tables [MONO_TABLE_IMPLMAP];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_IMPLMAP_SIZE;\n\t\t\n\t\tvalues [MONO_IMPLMAP_FLAGS] = (mb->native_cc << 8) | ncharset | extra_flags;\n\t\tvalues [MONO_IMPLMAP_MEMBER] = (mb->table_idx << 1) | 1; /* memberforwarded: method */\n\t\tif (mb->dllentry)\n\t\t\tvalues [MONO_IMPLMAP_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->dllentry);\n\t\telse\n\t\t\tvalues [MONO_IMPLMAP_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->name);\n\t\tmoduleref = string_heap_insert_mstring (&assembly->sheap, mb->dll);\n\t\tif (!(values [MONO_IMPLMAP_SCOPE] = find_index_in_table (assembly, MONO_TABLE_MODULEREF, MONO_MODULEREF_NAME, moduleref))) {\n\t\t\ttable = &assembly->tables [MONO_TABLE_MODULEREF];\n\t\t\ttable->rows ++;\n\t\t\talloc_table (table, table->rows);\n\t\t\ttable->values [table->rows * MONO_MODULEREF_SIZE + MONO_MODULEREF_NAME] = moduleref;\n\t\t\tvalues [MONO_IMPLMAP_SCOPE] = table->rows;\n\t\t}\n\t}\n\n\tif (mb->generic_params) {\n\t\ttable = &assembly->tables [MONO_TABLE_GENERICPARAM];\n\t\ttable->rows += mono_array_length (mb->generic_params);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (mb->generic_params); ++i) {\n\t\t\tguint32 owner = MONO_TYPEORMETHOD_METHOD | (mb->table_idx << MONO_TYPEORMETHOD_BITS);\n\n\t\t\tmono_image_get_generic_param_info (\n\t\t\t\tmono_array_get (mb->generic_params, gpointer, i), owner, assembly);\n\t\t}\n\t}\n\n}\n\nstatic void\nmono_image_get_ctor_info (MonoDomain *domain, MonoReflectionCtorBuilder *mb, MonoDynamicImage *assembly)\n{\n\tReflectionMethodBuilder rmb;\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, mb);\n\n\tmono_image_basic_method (&rmb, assembly);\n\tmb->table_idx = *rmb.table_idx;\n}\n#endif\n\nstatic char*\ntype_get_fully_qualified_name (MonoType *type)\n{\n\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED);\n}\n\nstatic char*\ntype_get_qualified_name (MonoType *type, MonoAssembly *ass) {\n\tMonoClass *klass;\n\tMonoAssembly *ta;\n\n\tklass = mono_class_from_mono_type (type);\n\tif (!klass) \n\t\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_REFLECTION);\n\tta = klass->image->assembly;\n\tif (ta->dynamic || (ta == ass)) {\n\t\tif (klass->generic_class || klass->generic_container)\n\t\t\t/* For generic type definitions, we want T, while REFLECTION returns T<K> */\n\t\t\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_FULL_NAME);\n\t\telse\n\t\t\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_REFLECTION);\n\t}\n\n\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/*field_image is the image to which the eventual custom mods have been encoded against*/\nstatic guint32\nfieldref_encode_signature (MonoDynamicImage *assembly, MonoImage *field_image, MonoType *type)\n{\n\tSigBuffer buf;\n\tguint32 idx, i, token;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\t\n\tsigbuffer_add_value (&buf, 0x06);\n\t/* encode custom attributes before the type */\n\tif (type->num_mods) {\n\t\tfor (i = 0; i < type->num_mods; ++i) {\n\t\t\tif (field_image) {\n\t\t\t\tMonoClass *class = mono_class_get (field_image, type->modifiers [i].token);\n\t\t\t\tg_assert (class);\n\t\t\t\ttoken = mono_image_typedef_or_ref (assembly, &class->byval_arg);\n\t\t\t} else {\n\t\t\t\ttoken = type->modifiers [i].token;\n\t\t\t}\n\n\t\t\tif (type->modifiers [i].required)\n\t\t\t\tsigbuffer_add_byte (&buf, MONO_TYPE_CMOD_REQD);\n\t\t\telse\n\t\t\t\tsigbuffer_add_byte (&buf, MONO_TYPE_CMOD_OPT);\n\n\t\t\tsigbuffer_add_value (&buf, token);\n\t\t}\n\t}\n\tencode_type (assembly, type, &buf);\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n#endif\n\nstatic guint32\nfield_encode_signature (MonoDynamicImage *assembly, MonoReflectionFieldBuilder *fb)\n{\n\tSigBuffer buf;\n\tguint32 idx;\n\n\tsigbuffer_init (&buf, 32);\n\t\n\tsigbuffer_add_value (&buf, 0x06);\n\tencode_custom_modifiers (assembly, fb->modreq, fb->modopt, &buf);\n\t/* encode custom attributes before the type */\n\tencode_reflection_type (assembly, (MonoReflectionType*)fb->type, &buf);\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nencode_constant (MonoDynamicImage *assembly, MonoObject *val, guint32 *ret_type) {\n\tchar blob_size [64];\n\tchar *b = blob_size;\n\tchar *p, *box_val;\n\tchar* buf;\n\tguint32 idx = 0, len = 0, dummy = 0;\n#ifdef ARM_FPU_FPA\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n\tguint32 fpa_double [2];\n\tguint32 *fpa_p;\n#endif\n#endif\n\t\n\tp = buf = g_malloc (64);\n\tif (!val) {\n\t\t*ret_type = MONO_TYPE_CLASS;\n\t\tlen = 4;\n\t\tbox_val = (char*)&dummy;\n\t} else {\n\t\tbox_val = ((char*)val) + sizeof (MonoObject);\n\t\t*ret_type = val->vtable->klass->byval_arg.type;\n\t}\nhandle_enum:\n\tswitch (*ret_type) {\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\t\tlen = 1;\n\t\tbreak;\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\t\tlen = 2;\n\t\tbreak;\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_R4:\n\t\tlen = 4;\n\t\tbreak;\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\t\tlen = 8;\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n\t\tlen = 8;\n#ifdef ARM_FPU_FPA\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n\t\tfpa_p = (guint32*)box_val;\n\t\tfpa_double [0] = fpa_p [1];\n\t\tfpa_double [1] = fpa_p [0];\n\t\tbox_val = (char*)fpa_double;\n#endif\n#endif\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (val->vtable->klass->enumtype) {\n\t\t\t*ret_type = mono_class_enum_basetype (val->vtable->klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else\n\t\t\tg_error (\"we can't encode valuetypes\");\n\tcase MONO_TYPE_CLASS:\n\t\tbreak;\n\tcase MONO_TYPE_STRING: {\n\t\tMonoString *str = (MonoString*)val;\n\t\t/* there is no signature */\n\t\tlen = str->length * 2;\n\t\tmono_metadata_encode_value (len, b, &b);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\t\t{\n\t\t\tchar *swapped = g_malloc (2 * mono_string_length (str));\n\t\t\tconst char *p = (const char*)mono_string_chars (str);\n\n\t\t\tswap_with_size (swapped, p, 2, mono_string_length (str));\n\t\t\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, swapped, len);\n\t\t\tg_free (swapped);\n\t\t}\n#else\n\t\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, (char*)mono_string_chars (str), len);\n#endif\n\n\t\tg_free (buf);\n\t\treturn idx;\n\t}\n\tcase MONO_TYPE_GENERICINST:\n\t\t*ret_type = val->vtable->klass->generic_class->container_class->byval_arg.type;\n\t\tgoto handle_enum;\n\tdefault:\n\t\tg_error (\"we don't encode constant type 0x%02x yet\", *ret_type);\n\t}\n\n\t/* there is no signature */\n\tmono_metadata_encode_value (len, b, &b);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\tidx = mono_image_add_stream_data (&assembly->blob, blob_size, b-blob_size);\n\tswap_with_size (blob_size, box_val, len, 1);\n\tmono_image_add_stream_data (&assembly->blob, blob_size, len);\n#else\n\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, box_val, len);\n#endif\n\n\tg_free (buf);\n\treturn idx;\n}\n\nstatic guint32\nencode_marshal_blob (MonoDynamicImage *assembly, MonoReflectionMarshal *minfo) {\n\tchar *str;\n\tSigBuffer buf;\n\tguint32 idx, len;\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, minfo->type);\n\n\tswitch (minfo->type) {\n\tcase MONO_NATIVE_BYVALTSTR:\n\tcase MONO_NATIVE_BYVALARRAY:\n\t\tsigbuffer_add_value (&buf, minfo->count);\n\t\tbreak;\n\tcase MONO_NATIVE_LPARRAY:\n\t\tif (minfo->eltype || minfo->has_size) {\n\t\t\tsigbuffer_add_value (&buf, minfo->eltype);\n\t\t\tif (minfo->has_size) {\n\t\t\t\tsigbuffer_add_value (&buf, minfo->param_num != -1? minfo->param_num: 0);\n\t\t\t\tsigbuffer_add_value (&buf, minfo->count != -1? minfo->count: 0);\n\n\t\t\t\t/* LAMESPEC: ElemMult is undocumented */\n\t\t\t\tsigbuffer_add_value (&buf, minfo->param_num != -1? 1: 0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MONO_NATIVE_SAFEARRAY:\n\t\tif (minfo->eltype)\n\t\t\tsigbuffer_add_value (&buf, minfo->eltype);\n\t\tbreak;\n\tcase MONO_NATIVE_CUSTOM:\n\t\tif (minfo->guid) {\n\t\t\tstr = mono_string_to_utf8 (minfo->guid);\n\t\t\tlen = strlen (str);\n\t\t\tsigbuffer_add_value (&buf, len);\n\t\t\tsigbuffer_add_mem (&buf, str, len);\n\t\t\tg_free (str);\n\t\t} else {\n\t\t\tsigbuffer_add_value (&buf, 0);\n\t\t}\n\t\t/* native type name */\n\t\tsigbuffer_add_value (&buf, 0);\n\t\t/* custom marshaler type name */\n\t\tif (minfo->marshaltype || minfo->marshaltyperef) {\n\t\t\tif (minfo->marshaltyperef)\n\t\t\t\tstr = type_get_fully_qualified_name (mono_reflection_type_get_handle ((MonoReflectionType*)minfo->marshaltyperef));\n\t\t\telse\n\t\t\t\tstr = mono_string_to_utf8 (minfo->marshaltype);\n\t\t\tlen = strlen (str);\n\t\t\tsigbuffer_add_value (&buf, len);\n\t\t\tsigbuffer_add_mem (&buf, str, len);\n\t\t\tg_free (str);\n\t\t} else {\n\t\t\t/* FIXME: Actually a bug, since this field is required.  Punting for now ... */\n\t\t\tsigbuffer_add_value (&buf, 0);\n\t\t}\n\t\tif (minfo->mcookie) {\n\t\t\tstr = mono_string_to_utf8 (minfo->mcookie);\n\t\t\tlen = strlen (str);\n\t\t\tsigbuffer_add_value (&buf, len);\n\t\t\tsigbuffer_add_mem (&buf, str, len);\n\t\t\tg_free (str);\n\t\t} else {\n\t\t\tsigbuffer_add_value (&buf, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic void\nmono_image_get_field_info (MonoReflectionFieldBuilder *fb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\n\t/* maybe this fixup should be done in the C# code */\n\tif (fb->attrs & FIELD_ATTRIBUTE_LITERAL)\n\t\tfb->attrs |= FIELD_ATTRIBUTE_HAS_DEFAULT;\n\ttable = &assembly->tables [MONO_TABLE_FIELD];\n\tfb->table_idx = table->next_idx ++;\n\tg_hash_table_insert (assembly->field_to_table_idx, fb->handle, GUINT_TO_POINTER (fb->table_idx));\n\tvalues = table->values + fb->table_idx * MONO_FIELD_SIZE;\n\tvalues [MONO_FIELD_NAME] = string_heap_insert_mstring (&assembly->sheap, fb->name);\n\tvalues [MONO_FIELD_FLAGS] = fb->attrs;\n\tvalues [MONO_FIELD_SIGNATURE] = field_encode_signature (assembly, fb);\n\n\tif (fb->offset != -1) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELDLAYOUT];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_FIELD_LAYOUT_SIZE;\n\t\tvalues [MONO_FIELD_LAYOUT_FIELD] = fb->table_idx;\n\t\tvalues [MONO_FIELD_LAYOUT_OFFSET] = fb->offset;\n\t}\n\tif (fb->attrs & FIELD_ATTRIBUTE_LITERAL) {\n\t\tguint32 field_type = 0;\n\t\ttable = &assembly->tables [MONO_TABLE_CONSTANT];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_CONSTANT_SIZE;\n\t\tvalues [MONO_CONSTANT_PARENT] = MONO_HASCONSTANT_FIEDDEF | (fb->table_idx << MONO_HASCONSTANT_BITS);\n\t\tvalues [MONO_CONSTANT_VALUE] = encode_constant (assembly, fb->def_value, &field_type);\n\t\tvalues [MONO_CONSTANT_TYPE] = field_type;\n\t\tvalues [MONO_CONSTANT_PADDING] = 0;\n\t}\n\tif (fb->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA) {\n\t\tguint32 rva_idx;\n\t\ttable = &assembly->tables [MONO_TABLE_FIELDRVA];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_FIELD_RVA_SIZE;\n\t\tvalues [MONO_FIELD_RVA_FIELD] = fb->table_idx;\n\t\t/*\n\t\t * We store it in the code section because it's simpler for now.\n\t\t */\n\t\tif (fb->rva_data) {\n\t\t\tif (mono_array_length (fb->rva_data) >= 10)\n\t\t\t\tstream_data_align (&assembly->code);\n\t\t\trva_idx = mono_image_add_stream_data (&assembly->code, mono_array_addr (fb->rva_data, char, 0), mono_array_length (fb->rva_data));\n\t\t} else\n\t\t\trva_idx = mono_image_add_stream_zero (&assembly->code, mono_class_value_size (fb->handle->parent, NULL));\n\t\tvalues [MONO_FIELD_RVA_RVA] = rva_idx + assembly->text_rva;\n\t}\n\tif (fb->marshal_info) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELDMARSHAL];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_FIELD_MARSHAL_SIZE;\n\t\tvalues [MONO_FIELD_MARSHAL_PARENT] = (fb->table_idx << MONO_HAS_FIELD_MARSHAL_BITS) | MONO_HAS_FIELD_MARSHAL_FIELDSREF;\n\t\tvalues [MONO_FIELD_MARSHAL_NATIVE_TYPE] = encode_marshal_blob (assembly, fb->marshal_info);\n\t}\n}\n\nstatic guint32\nproperty_encode_signature (MonoDynamicImage *assembly, MonoReflectionPropertyBuilder *fb)\n{\n\tSigBuffer buf;\n\tguint32 nparams = 0;\n\tMonoReflectionMethodBuilder *mb = fb->get_method;\n\tMonoReflectionMethodBuilder *smb = fb->set_method;\n\tguint32 idx, i;\n\n\tif (mb && mb->parameters)\n\t\tnparams = mono_array_length (mb->parameters);\n\tif (!mb && smb && smb->parameters)\n\t\tnparams = mono_array_length (smb->parameters) - 1;\n\tsigbuffer_init (&buf, 32);\n\tsigbuffer_add_byte (&buf, 0x08);\n\tsigbuffer_add_value (&buf, nparams);\n\tif (mb) {\n\t\tencode_reflection_type (assembly, (MonoReflectionType*)mb->rtype, &buf);\n\t\tfor (i = 0; i < nparams; ++i) {\n\t\t\tMonoReflectionType *pt = mono_array_get (mb->parameters, MonoReflectionType*, i);\n\t\t\tencode_reflection_type (assembly, pt, &buf);\n\t\t}\n\t} else if (smb && smb->parameters) {\n\t\t/* the property type is the last param */\n\t\tencode_reflection_type (assembly, mono_array_get (smb->parameters, MonoReflectionType*, nparams), &buf);\n\t\tfor (i = 0; i < nparams; ++i) {\n\t\t\tMonoReflectionType *pt = mono_array_get (smb->parameters, MonoReflectionType*, i);\n\t\t\tencode_reflection_type (assembly, pt, &buf);\n\t\t}\n\t} else {\n\t\tencode_reflection_type (assembly, (MonoReflectionType*)fb->type, &buf);\n\t}\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic void\nmono_image_get_property_info (MonoReflectionPropertyBuilder *pb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint num_methods = 0;\n\tguint32 semaidx;\n\n\t/* \n\t * we need to set things in the following tables:\n\t * PROPERTYMAP (info already filled in _get_type_info ())\n\t * PROPERTY    (rows already preallocated in _get_type_info ())\n\t * METHOD      (method info already done with the generic method code)\n\t * METHODSEMANTICS\n\t */\n\ttable = &assembly->tables [MONO_TABLE_PROPERTY];\n\tpb->table_idx = table->next_idx ++;\n\tvalues = table->values + pb->table_idx * MONO_PROPERTY_SIZE;\n\tvalues [MONO_PROPERTY_NAME] = string_heap_insert_mstring (&assembly->sheap, pb->name);\n\tvalues [MONO_PROPERTY_FLAGS] = pb->attrs;\n\tvalues [MONO_PROPERTY_TYPE] = property_encode_signature (assembly, pb);\n\n\t/* FIXME: we still don't handle 'other' methods */\n\tif (pb->get_method) num_methods ++;\n\tif (pb->set_method) num_methods ++;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSEMANTICS];\n\ttable->rows += num_methods;\n\talloc_table (table, table->rows);\n\n\tif (pb->get_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_GETTER;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = pb->get_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (pb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_PROPERTY;\n\t}\n\tif (pb->set_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_SETTER;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = pb->set_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (pb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_PROPERTY;\n\t}\n}\n\nstatic void\nmono_image_get_event_info (MonoReflectionEventBuilder *eb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint num_methods = 0;\n\tguint32 semaidx;\n\n\t/* \n\t * we need to set things in the following tables:\n\t * EVENTMAP (info already filled in _get_type_info ())\n\t * EVENT    (rows already preallocated in _get_type_info ())\n\t * METHOD      (method info already done with the generic method code)\n\t * METHODSEMANTICS\n\t */\n\ttable = &assembly->tables [MONO_TABLE_EVENT];\n\teb->table_idx = table->next_idx ++;\n\tvalues = table->values + eb->table_idx * MONO_EVENT_SIZE;\n\tvalues [MONO_EVENT_NAME] = string_heap_insert_mstring (&assembly->sheap, eb->name);\n\tvalues [MONO_EVENT_FLAGS] = eb->attrs;\n\tvalues [MONO_EVENT_TYPE] = mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle (eb->type));\n\n\t/*\n\t * FIXME: we still don't handle 'other' methods \n\t */\n\tif (eb->add_method) num_methods ++;\n\tif (eb->remove_method) num_methods ++;\n\tif (eb->raise_method) num_methods ++;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSEMANTICS];\n\ttable->rows += num_methods;\n\talloc_table (table, table->rows);\n\n\tif (eb->add_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_ADD_ON;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = eb->add_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (eb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_EVENT;\n\t}\n\tif (eb->remove_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_REMOVE_ON;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = eb->remove_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (eb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_EVENT;\n\t}\n\tif (eb->raise_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_FIRE;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = eb->raise_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (eb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_EVENT;\n\t}\n}\n\nstatic void\nencode_constraints (MonoReflectionGenericParam *gparam, guint32 owner, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 num_constraints, i;\n\tguint32 *values;\n\tguint32 table_idx;\n\n\ttable = &assembly->tables [MONO_TABLE_GENERICPARAMCONSTRAINT];\n\tnum_constraints = gparam->iface_constraints ?\n\t\tmono_array_length (gparam->iface_constraints) : 0;\n\ttable->rows += num_constraints;\n\tif (gparam->base_type)\n\t\ttable->rows++;\n\talloc_table (table, table->rows);\n\n\tif (gparam->base_type) {\n\t\ttable_idx = table->next_idx ++;\n\t\tvalues = table->values + table_idx * MONO_GENPARCONSTRAINT_SIZE;\n\n\t\tvalues [MONO_GENPARCONSTRAINT_GENERICPAR] = owner;\n\t\tvalues [MONO_GENPARCONSTRAINT_CONSTRAINT] = mono_image_typedef_or_ref (\n\t\t\tassembly, mono_reflection_type_get_handle (gparam->base_type));\n\t}\n\n\tfor (i = 0; i < num_constraints; i++) {\n\t\tMonoReflectionType *constraint = mono_array_get (\n\t\t\tgparam->iface_constraints, gpointer, i);\n\n\t\ttable_idx = table->next_idx ++;\n\t\tvalues = table->values + table_idx * MONO_GENPARCONSTRAINT_SIZE;\n\n\t\tvalues [MONO_GENPARCONSTRAINT_GENERICPAR] = owner;\n\t\tvalues [MONO_GENPARCONSTRAINT_CONSTRAINT] = mono_image_typedef_or_ref (\n\t\t\tassembly, mono_reflection_type_get_handle (constraint));\n\t}\n}\n\nstatic void\nmono_image_get_generic_param_info (MonoReflectionGenericParam *gparam, guint32 owner, MonoDynamicImage *assembly)\n{\n\tGenericParamTableEntry *entry;\n\n\t/*\n\t * The GenericParam table must be sorted according to the `owner' field.\n\t * We need to do this sorting prior to writing the GenericParamConstraint\n\t * table, since we have to use the final GenericParam table indices there\n\t * and they must also be sorted.\n\t */\n\n\tentry = g_new0 (GenericParamTableEntry, 1);\n\tentry->owner = owner;\n\t/* FIXME: track where gen_params should be freed and remove the GC root as well */\n\tMOVING_GC_REGISTER (&entry->gparam);\n\tentry->gparam = gparam;\n\n\tg_ptr_array_add (assembly->gen_params, entry);\n}\n\nstatic void\nwrite_generic_param_entry (MonoDynamicImage *assembly, GenericParamTableEntry *entry)\n{\n\tMonoDynamicTable *table;\n\tMonoGenericParam *param;\n\tguint32 *values;\n\tguint32 table_idx;\n\n\ttable = &assembly->tables [MONO_TABLE_GENERICPARAM];\n\ttable_idx = table->next_idx ++;\n\tvalues = table->values + table_idx * MONO_GENERICPARAM_SIZE;\n\n\tparam = mono_reflection_type_get_handle ((MonoReflectionType*)entry->gparam)->data.generic_param;\n\n\tvalues [MONO_GENERICPARAM_OWNER] = entry->owner;\n\tvalues [MONO_GENERICPARAM_FLAGS] = entry->gparam->attrs;\n\tvalues [MONO_GENERICPARAM_NUMBER] = mono_generic_param_num (param);\n\tvalues [MONO_GENERICPARAM_NAME] = string_heap_insert (&assembly->sheap, mono_generic_param_info (param)->name);\n\n\tmono_image_add_cattrs (assembly, table_idx, MONO_CUSTOM_ATTR_GENERICPAR, entry->gparam->cattrs);\n\n\tencode_constraints (entry->gparam, table_idx, assembly);\n}\n\nstatic guint32\nresolution_scope_from_image (MonoDynamicImage *assembly, MonoImage *image)\n{\n\tMonoDynamicTable *table;\n\tguint32 token;\n\tguint32 *values;\n\tguint32 cols [MONO_ASSEMBLY_SIZE];\n\tconst char *pubkey;\n\tguint32 publen;\n\n\tif ((token = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, image))))\n\t\treturn token;\n\n\tif (image->assembly->dynamic && (image->assembly == assembly->image.assembly)) {\n\t\ttable = &assembly->tables [MONO_TABLE_MODULEREF];\n\t\ttoken = table->next_idx ++;\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + token * MONO_MODULEREF_SIZE;\n\t\tvalues [MONO_MODULEREF_NAME] = string_heap_insert (&assembly->sheap, image->module_name);\n\n\t\ttoken <<= MONO_RESOLTION_SCOPE_BITS;\n\t\ttoken |= MONO_RESOLTION_SCOPE_MODULEREF;\n\t\tg_hash_table_insert (assembly->handleref, image, GUINT_TO_POINTER (token));\n\n\t\treturn token;\n\t}\n\t\n\tif (image->assembly->dynamic)\n\t\t/* FIXME: */\n\t\tmemset (cols, 0, sizeof (cols));\n\telse {\n\t\t/* image->assembly->image is the manifest module */\n\t\timage = image->assembly->image;\n\t\tmono_metadata_decode_row (&image->tables [MONO_TABLE_ASSEMBLY], 0, cols, MONO_ASSEMBLY_SIZE);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_ASSEMBLYREF];\n\ttoken = table->next_idx ++;\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + token * MONO_ASSEMBLYREF_SIZE;\n\tvalues [MONO_ASSEMBLYREF_NAME] = string_heap_insert (&assembly->sheap, image->assembly_name);\n\tvalues [MONO_ASSEMBLYREF_MAJOR_VERSION] = cols [MONO_ASSEMBLY_MAJOR_VERSION];\n\tvalues [MONO_ASSEMBLYREF_MINOR_VERSION] = cols [MONO_ASSEMBLY_MINOR_VERSION];\n\tvalues [MONO_ASSEMBLYREF_BUILD_NUMBER] = cols [MONO_ASSEMBLY_BUILD_NUMBER];\n\tvalues [MONO_ASSEMBLYREF_REV_NUMBER] = cols [MONO_ASSEMBLY_REV_NUMBER];\n\tvalues [MONO_ASSEMBLYREF_FLAGS] = 0;\n\tvalues [MONO_ASSEMBLYREF_CULTURE] = 0;\n\tvalues [MONO_ASSEMBLYREF_HASH_VALUE] = 0;\n\n\tif (strcmp (\"\", image->assembly->aname.culture)) {\n\t\tvalues [MONO_ASSEMBLYREF_CULTURE] = string_heap_insert (&assembly->sheap,\n\t\t\t\timage->assembly->aname.culture);\n\t}\n\n\tif ((pubkey = mono_image_get_public_key (image, &publen))) {\n\t\tguchar pubtoken [9];\n\t\tpubtoken [0] = 8;\n\t\tmono_digest_get_public_token (pubtoken + 1, (guchar*)pubkey, publen);\n\t\tvalues [MONO_ASSEMBLYREF_PUBLIC_KEY] = mono_image_add_stream_data (&assembly->blob, (char*)pubtoken, 9);\n\t} else {\n\t\tvalues [MONO_ASSEMBLYREF_PUBLIC_KEY] = 0;\n\t}\n\ttoken <<= MONO_RESOLTION_SCOPE_BITS;\n\ttoken |= MONO_RESOLTION_SCOPE_ASSEMBLYREF;\n\tg_hash_table_insert (assembly->handleref, image, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic guint32\ncreate_typespec (MonoDynamicImage *assembly, MonoType *type)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token;\n\tSigBuffer buf;\n\n\tif ((token = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typespec, type))))\n\t\treturn token;\n\n\tsigbuffer_init (&buf, 32);\n\tswitch (type->type) {\n\tcase MONO_TYPE_FNPTR:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\tcase MONO_TYPE_GENERICINST:\n\t\tencode_type (assembly, type, &buf);\n\t\tbreak;\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_VALUETYPE: {\n\t\tMonoClass *k = mono_class_from_mono_type (type);\n\t\tif (!k || !k->generic_container) {\n\t\t\tsigbuffer_free (&buf);\n\t\t\treturn 0;\n\t\t}\n\t\tencode_type (assembly, type, &buf);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tsigbuffer_free (&buf);\n\t\treturn 0;\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_TYPESPEC];\n\tif (assembly->save) {\n\t\ttoken = sigbuffer_add_to_blob_cached (assembly, &buf);\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_TYPESPEC_SIZE;\n\t\tvalues [MONO_TYPESPEC_SIGNATURE] = token;\n\t}\n\tsigbuffer_free (&buf);\n\n\ttoken = MONO_TYPEDEFORREF_TYPESPEC | (table->next_idx << MONO_TYPEDEFORREF_BITS);\n\tg_hash_table_insert (assembly->typespec, type, GUINT_TO_POINTER(token));\n\ttable->next_idx ++;\n\treturn token;\n}\n\nstatic guint32\nmono_image_typedef_or_ref_full (MonoDynamicImage *assembly, MonoType *type, gboolean try_typespec)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, scope, enclosing;\n\tMonoClass *klass;\n\n\t/* if the type requires a typespec, we must try that first*/\n\tif (try_typespec && (token = create_typespec (assembly, type)))\n\t\treturn token;\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typeref, type));\n\tif (token)\n\t\treturn token;\n\tklass = mono_class_from_mono_type (type);\n\tif (!klass)\n\t\tklass = mono_class_from_mono_type (type);\n\n\t/*\n\t * If it's in the same module and not a generic type parameter:\n\t */\n\tif ((klass->image == &assembly->image) && (type->type != MONO_TYPE_VAR) && \n\t\t\t(type->type != MONO_TYPE_MVAR)) {\n\t\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\t\ttoken = MONO_TYPEDEFORREF_TYPEDEF | (tb->table_idx << MONO_TYPEDEFORREF_BITS);\n\t\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (token), klass->reflection_info);\n\t\treturn token;\n\t}\n\n\tif (klass->nested_in) {\n\t\tenclosing = mono_image_typedef_or_ref_full (assembly, &klass->nested_in->byval_arg, FALSE);\n\t\t/* get the typeref idx of the enclosing type */\n\t\tenclosing >>= MONO_TYPEDEFORREF_BITS;\n\t\tscope = (enclosing << MONO_RESOLTION_SCOPE_BITS) | MONO_RESOLTION_SCOPE_TYPEREF;\n\t} else {\n\t\tscope = resolution_scope_from_image (assembly, klass->image);\n\t}\n\ttable = &assembly->tables [MONO_TABLE_TYPEREF];\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_TYPEREF_SIZE;\n\t\tvalues [MONO_TYPEREF_SCOPE] = scope;\n\t\tvalues [MONO_TYPEREF_NAME] = string_heap_insert (&assembly->sheap, klass->name);\n\t\tvalues [MONO_TYPEREF_NAMESPACE] = string_heap_insert (&assembly->sheap, klass->name_space);\n\t}\n\ttoken = MONO_TYPEDEFORREF_TYPEREF | (table->next_idx << MONO_TYPEDEFORREF_BITS); /* typeref */\n\tg_hash_table_insert (assembly->typeref, type, GUINT_TO_POINTER(token));\n\ttable->next_idx ++;\n\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (token), klass->reflection_info);\n\treturn token;\n}\n\n/*\n * Despite the name, we handle also TypeSpec (with the above helper).\n */\nstatic guint32\nmono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type)\n{\n\treturn mono_image_typedef_or_ref_full (assembly, type, TRUE);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/*\n * Insert a memberef row into the metadata: the token that point to the memberref\n * is returned. Caching is done in the caller (mono_image_get_methodref_token() or\n * mono_image_get_fieldref_token()).\n * The sig param is an index to an already built signature.\n */\nstatic guint32\nmono_image_get_memberref_token (MonoDynamicImage *assembly, MonoType *type, const char *name, guint32 sig)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, pclass;\n\tguint32 parent;\n\n\tparent = mono_image_typedef_or_ref (assembly, type);\n\tswitch (parent & MONO_TYPEDEFORREF_MASK) {\n\tcase MONO_TYPEDEFORREF_TYPEREF:\n\t\tpclass = MONO_MEMBERREF_PARENT_TYPEREF;\n\t\tbreak;\n\tcase MONO_TYPEDEFORREF_TYPESPEC:\n\t\tpclass = MONO_MEMBERREF_PARENT_TYPESPEC;\n\t\tbreak;\n\tcase MONO_TYPEDEFORREF_TYPEDEF:\n\t\tpclass = MONO_MEMBERREF_PARENT_TYPEDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_warning (\"unknown typeref or def token 0x%08x for %s\", parent, name);\n\t\treturn 0;\n\t}\n\t/* extract the index */\n\tparent >>= MONO_TYPEDEFORREF_BITS;\n\n\ttable = &assembly->tables [MONO_TABLE_MEMBERREF];\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_MEMBERREF_SIZE;\n\t\tvalues [MONO_MEMBERREF_CLASS] = pclass | (parent << MONO_MEMBERREF_PARENT_BITS);\n\t\tvalues [MONO_MEMBERREF_NAME] = string_heap_insert (&assembly->sheap, name);\n\t\tvalues [MONO_MEMBERREF_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_MEMBER_REF | table->next_idx;\n\ttable->next_idx ++;\n\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodref_token (MonoDynamicImage *assembly, MonoMethod *method, gboolean create_typespec)\n{\n\tguint32 token;\n\tMonoMethodSignature *sig;\n\t\n\tcreate_typespec = create_typespec && method->is_generic && method->klass->image != &assembly->image;\n\n\tif (create_typespec) {\n\t\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, GUINT_TO_POINTER (GPOINTER_TO_UINT (method) + 1)));\n\t\tif (token)\n\t\t\treturn token;\n\t} \n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, method));\n\tif (token && !create_typespec)\n\t\treturn token;\n\n\tg_assert (!method->is_inflated);\n\tif (!token) {\n\t\t/*\n\t\t * A methodref signature can't contain an unmanaged calling convention.\n\t\t */\n\t\tsig = mono_metadata_signature_dup (mono_method_signature (method));\n\t\tif ((sig->call_convention != MONO_CALL_DEFAULT) && (sig->call_convention != MONO_CALL_VARARG))\n\t\t\tsig->call_convention = MONO_CALL_DEFAULT;\n\t\ttoken = mono_image_get_memberref_token (assembly, &method->klass->byval_arg,\n\t\t\tmethod->name,  method_encode_signature (assembly, sig));\n\t\tg_free (sig);\n\t\tg_hash_table_insert (assembly->handleref, method, GUINT_TO_POINTER(token));\n\t}\n\n\tif (create_typespec) {\n\t\tMonoDynamicTable *table = &assembly->tables [MONO_TABLE_METHODSPEC];\n\t\tg_assert (mono_metadata_token_table (token) == MONO_TABLE_MEMBERREF);\n\t\ttoken = (mono_metadata_token_index (token) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODREF;\n\n\t\tif (assembly->save) {\n\t\t\tguint32 *values;\n\n\t\t\talloc_table (table, table->rows + 1);\n\t\t\tvalues = table->values + table->next_idx * MONO_METHODSPEC_SIZE;\n\t\t\tvalues [MONO_METHODSPEC_METHOD] = token;\n\t\t\tvalues [MONO_METHODSPEC_SIGNATURE] = encode_generic_method_sig (assembly, &mono_method_get_generic_container (method)->context);\n\t\t}\n\n\t\ttoken = MONO_TOKEN_METHOD_SPEC | table->next_idx;\n\t\ttable->next_idx ++;\n\t\t/*methodspec and memberef tokens are diferent, */\n\t\tg_hash_table_insert (assembly->handleref, GUINT_TO_POINTER (GPOINTER_TO_UINT (method) + 1), GUINT_TO_POINTER (token));\n\t\treturn token;\n\t}\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodref_token_for_methodbuilder (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *method)\n{\n\tguint32 token;\n\tReflectionMethodBuilder rmb;\n\tchar *name;\n\t\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, method));\n\tif (token)\n\t\treturn token;\n\n\tname = mono_string_to_utf8 (method->name);\n\treflection_methodbuilder_from_method_builder (&rmb, method);\n\n\t/*\n\t * A methodref signature can't contain an unmanaged calling convention.\n\t * Since some flags are encoded as part of call_conv, we need to check against it.\n\t*/\n\tif ((rmb.call_conv & ~0x60) != MONO_CALL_DEFAULT && (rmb.call_conv & ~0x60) != MONO_CALL_VARARG)\n\t\trmb.call_conv = (rmb.call_conv & 0x60) | MONO_CALL_DEFAULT;\n\ttoken = mono_image_get_memberref_token (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)rmb.type),\n\t\t\t\t\tname, method_builder_encode_signature (assembly, &rmb));\n\n\tg_free (name);\n\tg_hash_table_insert (assembly->handleref, method, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_varargs_method_token (MonoDynamicImage *assembly, guint32 original,\n\t\t\t\t     const gchar *name, guint32 sig)\n{\n\tMonoDynamicTable *table;\n\tguint32 token;\n\tguint32 *values;\n\t\n\ttable = &assembly->tables [MONO_TABLE_MEMBERREF];\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_MEMBERREF_SIZE;\n\t\tvalues [MONO_MEMBERREF_CLASS] = original;\n\t\tvalues [MONO_MEMBERREF_NAME] = string_heap_insert (&assembly->sheap, name);\n\t\tvalues [MONO_MEMBERREF_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_MEMBER_REF | table->next_idx;\n\ttable->next_idx ++;\n\n\treturn token;\n}\n\nstatic guint32\nencode_generic_method_definition_sig (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb)\n{\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams = mono_array_length (mb->generic_params);\n\tguint32 idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, 0xa);\n\tsigbuffer_add_value (&buf, nparams);\n\n\tfor (i = 0; i < nparams; i++) {\n\t\tsigbuffer_add_value (&buf, MONO_TYPE_MVAR);\n\t\tsigbuffer_add_value (&buf, i);\n\t}\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nmono_image_get_methodspec_token_for_generic_method_definition (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, mtoken = 0;\n\n\ttoken = GPOINTER_TO_UINT (mono_g_hash_table_lookup (assembly->methodspec, mb));\n\tif (token)\n\t\treturn token;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSPEC];\n\n\tmtoken = mono_image_get_methodref_token_for_methodbuilder (assembly, mb);\n\tswitch (mono_metadata_token_table (mtoken)) {\n\tcase MONO_TABLE_MEMBERREF:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODREF;\n\t\tbreak;\n\tcase MONO_TABLE_METHOD:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_METHODSPEC_SIZE;\n\t\tvalues [MONO_METHODSPEC_METHOD] = mtoken;\n\t\tvalues [MONO_METHODSPEC_SIGNATURE] = encode_generic_method_definition_sig (assembly, mb);\n\t}\n\n\ttoken = MONO_TOKEN_METHOD_SPEC | table->next_idx;\n\ttable->next_idx ++;\n\n\tmono_g_hash_table_insert (assembly->methodspec, mb, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodbuilder_token (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb, gboolean create_methodspec)\n{\n\tguint32 token;\n\t\n\tif (mb->generic_params && create_methodspec) \n\t\treturn mono_image_get_methodspec_token_for_generic_method_definition (assembly, mb);\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, mb));\n\tif (token)\n\t\treturn token;\n\n\ttoken = mono_image_get_methodref_token_for_methodbuilder (assembly, mb);\n\tg_hash_table_insert (assembly->handleref, mb, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_ctorbuilder_token (MonoDynamicImage *assembly, MonoReflectionCtorBuilder *mb)\n{\n\tguint32 token;\n\tReflectionMethodBuilder rmb;\n\tchar *name;\n\t\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, mb));\n\tif (token)\n\t\treturn token;\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, mb);\n\n\tname = mono_string_to_utf8 (rmb.name);\n\ttoken = mono_image_get_memberref_token (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)rmb.type),\n\t\tname, method_builder_encode_signature (assembly, &rmb));\n\n\tg_free (name);\n\tg_hash_table_insert (assembly->handleref, mb, GUINT_TO_POINTER(token));\n\treturn token;\n}\n#endif\n\nstatic gboolean\nis_field_on_inst (MonoClassField *field)\n{\n\treturn (field->parent->generic_class && field->parent->generic_class->is_dynamic && ((MonoDynamicGenericClass*)field->parent->generic_class)->fields);\n}\n\n/*\n * If FIELD is a field of a MonoDynamicGenericClass, return its non-inflated type.\n */\nstatic MonoType*\nget_field_on_inst_generic_type (MonoClassField *field)\n{\n\tMonoDynamicGenericClass *dgclass;\n\tint field_index;\n\n\tg_assert (is_field_on_inst (field));\n\n\tdgclass = (MonoDynamicGenericClass*)field->parent->generic_class;\n\tfield_index = field - dgclass->fields;\n\n\tg_assert (field_index >= 0 && field_index < dgclass->count_fields);\n\treturn dgclass->field_generic_types [field_index];\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32\nmono_image_get_fieldref_token (MonoDynamicImage *assembly, MonoReflectionField *f)\n{\n\tMonoType *type;\n\tguint32 token;\n\tMonoClassField *field;\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, f));\n\tif (token)\n\t\treturn token;\n\tg_assert (f->field->parent);\n\n\tfield = f->field;\n\tif (field->parent->generic_class && field->parent->generic_class->container_class && field->parent->generic_class->container_class->fields) {\n\t\tint index = field - field->parent->fields;\n\t\ttype = field->parent->generic_class->container_class->fields [index].type;\n\t} else {\n\t\tif (is_field_on_inst (f->field))\n\t\t\ttype = get_field_on_inst_generic_type (f->field);\n\t\telse\n\t\t\ttype = f->field->type;\n\t}\n\ttoken = mono_image_get_memberref_token (assembly, &f->field->parent->byval_arg, \n\t\t\t\t\t\t\t\t\t\t\tmono_field_get_name (f->field),  \n\t\t\t\t\t\t\t\t\t\t\tfieldref_encode_signature (assembly, field->parent->image, type));\n\tg_hash_table_insert (assembly->handleref, f, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_field_on_inst_token (MonoDynamicImage *assembly, MonoReflectionFieldOnTypeBuilderInst *f)\n{\n\tguint32 token;\n\tMonoClass *klass;\n\tMonoGenericClass *gclass;\n\tMonoDynamicGenericClass *dgclass;\n\tMonoReflectionFieldBuilder *fb = f->fb;\n\tMonoType *type;\n\tchar *name;\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, f));\n\tif (token)\n\t\treturn token;\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)f->inst);\n\tklass = mono_class_from_mono_type (type);\n\tgclass = type->data.generic_class;\n\tg_assert (gclass->is_dynamic);\n\tdgclass = (MonoDynamicGenericClass *) gclass;\n\n\tname = mono_string_to_utf8 (fb->name);\n\ttoken = mono_image_get_memberref_token (assembly, &klass->byval_arg, name, \n\t\t\t\t\t\t\t\t\t\t\tfield_encode_signature (assembly, fb));\n\tg_free (name);\n\tg_hash_table_insert (assembly->handleref, f, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_ctor_on_inst_token (MonoDynamicImage *assembly, MonoReflectionCtorOnTypeBuilderInst *c, gboolean create_methodspec)\n{\n\tguint32 sig, token;\n\tMonoClass *klass;\n\tMonoGenericClass *gclass;\n\tMonoDynamicGenericClass *dgclass;\n\tMonoReflectionCtorBuilder *cb = c->cb;\n\tReflectionMethodBuilder rmb;\n\tMonoType *type;\n\tchar *name;\n\n\t/* A ctor cannot be a generic method, so we can ignore create_methodspec */\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, c));\n\tif (token)\n\t\treturn token;\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)c->inst);\n\tklass = mono_class_from_mono_type (type);\n\tgclass = type->data.generic_class;\n\tg_assert (gclass->is_dynamic);\n\tdgclass = (MonoDynamicGenericClass *) gclass;\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, cb);\n\n\tname = mono_string_to_utf8 (rmb.name);\n\n\tsig = method_builder_encode_signature (assembly, &rmb);\n\n\ttoken = mono_image_get_memberref_token (assembly, &klass->byval_arg, name, sig);\n\tg_free (name);\n\n\tg_hash_table_insert (assembly->handleref, c, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic MonoMethod*\nmono_reflection_method_on_tb_inst_get_handle (MonoReflectionMethodOnTypeBuilderInst *m)\n{\n\tMonoClass *klass;\n\tMonoGenericContext tmp_context;\n\tMonoType **type_argv;\n\tMonoGenericInst *ginst;\n\tMonoMethod *method, *inflated;\n\tint count, i;\n\n\tmethod = inflate_method (m->inst, (MonoObject*)m->mb);\n\n\tklass = method->klass;\n\n\tif (m->method_args == NULL)\n\t\treturn method;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_array_length (m->method_args);\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (m->method_args, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\treturn inflated;\n}\n\nstatic guint32\nmono_image_get_method_on_inst_token (MonoDynamicImage *assembly, MonoReflectionMethodOnTypeBuilderInst *m, gboolean create_methodspec)\n{\n\tguint32 sig, token;\n\tMonoClass *klass;\n\tMonoGenericClass *gclass;\n\tMonoReflectionMethodBuilder *mb = m->mb;\n\tReflectionMethodBuilder rmb;\n\tMonoType *type;\n\tchar *name;\n\n\tif (m->method_args) {\n\t\tMonoMethod *inflated;\n\n\t\tinflated = mono_reflection_method_on_tb_inst_get_handle (m);\n\t\tif (create_methodspec)\n\t\t\ttoken = mono_image_get_methodspec_token (assembly, inflated);\n\t\telse\n\t\t\ttoken = mono_image_get_inflated_method_token (assembly, inflated);\n\t\treturn token;\n\t}\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, m));\n\tif (token)\n\t\treturn token;\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)m->inst);\n\tklass = mono_class_from_mono_type (type);\n\tgclass = type->data.generic_class;\n\tg_assert (gclass->is_dynamic);\n\n\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\n\tname = mono_string_to_utf8 (rmb.name);\n\n\tsig = method_builder_encode_signature (assembly, &rmb);\n\n\ttoken = mono_image_get_memberref_token (assembly, &klass->byval_arg, name, sig);\n\tg_free (name);\n\n\tg_hash_table_insert (assembly->handleref, m, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic guint32\nencode_generic_method_sig (MonoDynamicImage *assembly, MonoGenericContext *context)\n{\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams = context->method_inst->type_argc;\n\tguint32 idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\t/*\n\t * FIXME: vararg, explicit_this, differenc call_conv values...\n\t */\n\tsigbuffer_add_value (&buf, 0xa); /* FIXME FIXME FIXME */\n\tsigbuffer_add_value (&buf, nparams);\n\n\tfor (i = 0; i < nparams; i++)\n\t\tencode_type (assembly, context->method_inst->type_argv [i], &buf);\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nmethod_encode_methodspec (MonoDynamicImage *assembly, MonoMethod *method)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, mtoken = 0, sig;\n\tMonoMethodInflated *imethod;\n\tMonoMethod *declaring;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSPEC];\n\n\tg_assert (method->is_inflated);\n\timethod = (MonoMethodInflated *) method;\n\tdeclaring = imethod->declaring;\n\n\tsig = method_encode_signature (assembly, mono_method_signature (declaring));\n\tmtoken = mono_image_get_memberref_token (assembly, &method->klass->byval_arg, declaring->name, sig);\n\n\tif (!mono_method_signature (declaring)->generic_param_count)\n\t\treturn mtoken;\n\n\tswitch (mono_metadata_token_table (mtoken)) {\n\tcase MONO_TABLE_MEMBERREF:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODREF;\n\t\tbreak;\n\tcase MONO_TABLE_METHOD:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\tsig = encode_generic_method_sig (assembly, mono_method_get_context (method));\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_METHODSPEC_SIZE;\n\t\tvalues [MONO_METHODSPEC_METHOD] = mtoken;\n\t\tvalues [MONO_METHODSPEC_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_METHOD_SPEC | table->next_idx;\n\ttable->next_idx ++;\n\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodspec_token (MonoDynamicImage *assembly, MonoMethod *method)\n{\n\tMonoMethodInflated *imethod;\n\tguint32 token;\n\t\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, method));\n\tif (token)\n\t\treturn token;\n\n\tg_assert (method->is_inflated);\n\timethod = (MonoMethodInflated *) method;\n\n\tif (mono_method_signature (imethod->declaring)->generic_param_count) {\n\t\ttoken = method_encode_methodspec (assembly, method);\n\t} else {\n\t\tguint32 sig = method_encode_signature (\n\t\t\tassembly, mono_method_signature (imethod->declaring));\n\t\ttoken = mono_image_get_memberref_token (\n\t\t\tassembly, &method->klass->byval_arg, method->name, sig);\n\t}\n\n\tg_hash_table_insert (assembly->handleref, method, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_inflated_method_token (MonoDynamicImage *assembly, MonoMethod *m)\n{\n\tMonoMethodInflated *imethod = (MonoMethodInflated *) m;\n\tguint32 sig, token;\n\n\tsig = method_encode_signature (assembly, mono_method_signature (imethod->declaring));\n\ttoken = mono_image_get_memberref_token (\n\t\tassembly, &m->klass->byval_arg, m->name, sig);\n\n\treturn token;\n}\n\nstatic guint32\ncreate_generic_typespec (MonoDynamicImage *assembly, MonoReflectionTypeBuilder *tb)\n{\n\tMonoDynamicTable *table;\n\tMonoClass *klass;\n\tMonoType *type;\n\tguint32 *values;\n\tguint32 token;\n\tSigBuffer buf;\n\tint count, i;\n\n\t/*\n\t * We're creating a TypeSpec for the TypeBuilder of a generic type declaration,\n\t * ie. what we'd normally use as the generic type in a TypeSpec signature.\n\t * Because of this, we must not insert it into the `typeref' hash table.\n\t */\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)tb);\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typespec, type));\n\tif (token)\n\t\treturn token;\n\n\tsigbuffer_init (&buf, 32);\n\n\tg_assert (tb->generic_params);\n\tklass = mono_class_from_mono_type (type);\n\n\tif (tb->generic_container)\n\t\tmono_reflection_create_generic_class (tb);\n\n\tsigbuffer_add_value (&buf, MONO_TYPE_GENERICINST);\n\tg_assert (klass->generic_container);\n\tsigbuffer_add_value (&buf, klass->byval_arg.type);\n\tsigbuffer_add_value (&buf, mono_image_typedef_or_ref_full (assembly, &klass->byval_arg, FALSE));\n\n\tcount = mono_array_length (tb->generic_params);\n\tsigbuffer_add_value (&buf, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionGenericParam *gparam;\n\n\t\tgparam = mono_array_get (tb->generic_params, MonoReflectionGenericParam *, i);\n\n\t\tencode_type (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)gparam), &buf);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_TYPESPEC];\n\n\tif (assembly->save) {\n\t\ttoken = sigbuffer_add_to_blob_cached (assembly, &buf);\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_TYPESPEC_SIZE;\n\t\tvalues [MONO_TYPESPEC_SIGNATURE] = token;\n\t}\n\tsigbuffer_free (&buf);\n\n\ttoken = MONO_TYPEDEFORREF_TYPESPEC | (table->next_idx << MONO_TYPEDEFORREF_BITS);\n\tg_hash_table_insert (assembly->typespec, type, GUINT_TO_POINTER(token));\n\ttable->next_idx ++;\n\treturn token;\n}\n\n/*\n * Return a copy of TYPE, adding the custom modifiers in MODREQ and MODOPT.\n */\nstatic MonoType*\nadd_custom_modifiers (MonoDynamicImage *assembly, MonoType *type, MonoArray *modreq, MonoArray *modopt)\n{\n\tint i, count, len, pos;\n\tMonoType *t;\n\n\tcount = 0;\n\tif (modreq)\n\t\tcount += mono_array_length (modreq);\n\tif (modopt)\n\t\tcount += mono_array_length (modopt);\n\n\tif (count == 0)\n\t\treturn mono_metadata_type_dup (NULL, type);\n\n\tlen = MONO_SIZEOF_TYPE + ((gint32)count) * sizeof (MonoCustomMod);\n\tt = g_malloc (len);\n\tmemcpy (t, type, MONO_SIZEOF_TYPE);\n\n\tt->num_mods = count;\n\tpos = 0;\n\tif (modreq) {\n\t\tfor (i = 0; i < mono_array_length (modreq); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modreq, i);\n\t\t\tt->modifiers [pos].required = 1;\n\t\t\tt->modifiers [pos].token = mono_image_typedef_or_ref (assembly, mod);\n\t\t\tpos ++;\n\t\t}\n\t}\n\tif (modopt) {\n\t\tfor (i = 0; i < mono_array_length (modopt); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modopt, i);\n\t\t\tt->modifiers [pos].required = 0;\n\t\t\tt->modifiers [pos].token = mono_image_typedef_or_ref (assembly, mod);\n\t\t\tpos ++;\n\t\t}\n\t}\n\n\treturn t;\n}\n\nstatic guint32\nmono_image_get_generic_field_token (MonoDynamicImage *assembly, MonoReflectionFieldBuilder *fb)\n{\n\tMonoDynamicTable *table;\n\tMonoClass *klass;\n\tMonoType *custom = NULL;\n\tguint32 *values;\n\tguint32 token, pclass, parent, sig;\n\tgchar *name;\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, fb));\n\tif (token)\n\t\treturn token;\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle (fb->typeb));\n\tname = mono_string_to_utf8 (fb->name);\n\n\t/* fb->type does not include the custom modifiers */\n\t/* FIXME: We should do this in one place when a fieldbuilder is created */\n\tif (fb->modreq || fb->modopt) {\n\t\tcustom = add_custom_modifiers (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type), fb->modreq, fb->modopt);\n\t\tsig = fieldref_encode_signature (assembly, NULL, custom);\n\t\tg_free (custom);\n\t} else {\n\t\tsig = fieldref_encode_signature (assembly, NULL, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type));\n\t}\n\n\tparent = create_generic_typespec (assembly, (MonoReflectionTypeBuilder *) fb->typeb);\n\tg_assert ((parent & MONO_TYPEDEFORREF_MASK) == MONO_TYPEDEFORREF_TYPESPEC);\n\t\n\tpclass = MONO_MEMBERREF_PARENT_TYPESPEC;\n\tparent >>= MONO_TYPEDEFORREF_BITS;\n\n\ttable = &assembly->tables [MONO_TABLE_MEMBERREF];\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_MEMBERREF_SIZE;\n\t\tvalues [MONO_MEMBERREF_CLASS] = pclass | (parent << MONO_MEMBERREF_PARENT_BITS);\n\t\tvalues [MONO_MEMBERREF_NAME] = string_heap_insert (&assembly->sheap, name);\n\t\tvalues [MONO_MEMBERREF_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_MEMBER_REF | table->next_idx;\n\ttable->next_idx ++;\n\tg_hash_table_insert (assembly->handleref, fb, GUINT_TO_POINTER(token));\n\tg_free (name);\n\treturn token;\n}\n\nstatic guint32\nmono_reflection_encode_sighelper (MonoDynamicImage *assembly, MonoReflectionSigHelper *helper)\n{\n\tSigBuffer buf;\n\tguint32 nargs;\n\tguint32 size;\n\tguint32 i, idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\t/* FIXME: this means SignatureHelper.SignatureHelpType.HELPER_METHOD */\n\tg_assert (helper->type == 2);\n\n\tif (helper->arguments)\n\t\tnargs = mono_array_length (helper->arguments);\n\telse\n\t\tnargs = 0;\n\n\tsize = 10 + (nargs * 10);\n\t\n\tsigbuffer_init (&buf, 32);\n\n\t/* Encode calling convention */\n\t/* Change Any to Standard */\n\tif ((helper->call_conv & 0x03) == 0x03)\n\t\thelper->call_conv = 0x01;\n\t/* explicit_this implies has_this */\n\tif (helper->call_conv & 0x40)\n\t\thelper->call_conv &= 0x20;\n\n\tif (helper->call_conv == 0) { /* Unmanaged */\n\t\tidx = helper->unmanaged_call_conv - 1;\n\t} else {\n\t\t/* Managed */\n\t\tidx = helper->call_conv & 0x60; /* has_this + explicit_this */\n\t\tif (helper->call_conv & 0x02) /* varargs */\n\t\t\tidx += 0x05;\n\t}\n\n\tsigbuffer_add_byte (&buf, idx);\n\tsigbuffer_add_value (&buf, nargs);\n\tencode_reflection_type (assembly, helper->return_type, &buf);\n\tfor (i = 0; i < nargs; ++i) {\n\t\tMonoArray *modreqs = NULL;\n\t\tMonoArray *modopts = NULL;\n\t\tMonoReflectionType *pt;\n\n\t\tif (helper->modreqs && (i < mono_array_length (helper->modreqs)))\n\t\t\tmodreqs = mono_array_get (helper->modreqs, MonoArray*, i);\n\t\tif (helper->modopts && (i < mono_array_length (helper->modopts)))\n\t\t\tmodopts = mono_array_get (helper->modopts, MonoArray*, i);\n\n\t\tencode_custom_modifiers (assembly, modreqs, modopts, &buf);\n\t\tpt = mono_array_get (helper->arguments, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, pt, &buf);\n\t}\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\n\treturn idx;\n}\n\nstatic guint32 \nmono_image_get_sighelper_token (MonoDynamicImage *assembly, MonoReflectionSigHelper *helper)\n{\n\tguint32 idx;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\n\ttable = &assembly->tables [MONO_TABLE_STANDALONESIG];\n\tidx = table->next_idx ++;\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + idx * MONO_STAND_ALONE_SIGNATURE_SIZE;\n\n\tvalues [MONO_STAND_ALONE_SIGNATURE] =\n\t\tmono_reflection_encode_sighelper (assembly, helper);\n\n\treturn idx;\n}\n\nstatic int\nreflection_cc_to_file (int call_conv) {\n\tswitch (call_conv & 0x3) {\n\tcase 0:\n\tcase 1: return MONO_CALL_DEFAULT;\n\tcase 2: return MONO_CALL_VARARG;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn 0;\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\ntypedef struct {\n\tMonoType *parent;\n\tMonoMethodSignature *sig;\n\tchar *name;\n\tguint32 token;\n} ArrayMethod;\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32\nmono_image_get_array_token (MonoDynamicImage *assembly, MonoReflectionArrayMethod *m)\n{\n\tguint32 nparams, i;\n\tGList *tmp;\n\tchar *name;\n\tMonoMethodSignature *sig;\n\tArrayMethod *am;\n\tMonoType *mtype;\n\n\tname = mono_string_to_utf8 (m->name);\n\tnparams = mono_array_length (m->parameters);\n\tsig = g_malloc0 (MONO_SIZEOF_METHOD_SIGNATURE + sizeof (MonoType*) * nparams);\n\tsig->hasthis = 1;\n\tsig->sentinelpos = -1;\n\tsig->call_convention = reflection_cc_to_file (m->call_conv);\n\tsig->param_count = nparams;\n\tsig->ret = m->ret ? mono_reflection_type_get_handle (m->ret): &mono_defaults.void_class->byval_arg;\n\tmtype = mono_reflection_type_get_handle (m->parent);\n\tfor (i = 0; i < nparams; ++i)\n\t\tsig->params [i] = mono_type_array_get_and_resolve (m->parameters, i);\n\n\tfor (tmp = assembly->array_methods; tmp; tmp = tmp->next) {\n\t\tam = tmp->data;\n\t\tif (strcmp (name, am->name) == 0 && \n\t\t\t\tmono_metadata_type_equal (am->parent, mtype) &&\n\t\t\t\tmono_metadata_signature_equal (am->sig, sig)) {\n\t\t\tg_free (name);\n\t\t\tg_free (sig);\n\t\t\tm->table_idx = am->token & 0xffffff;\n\t\t\treturn am->token;\n\t\t}\n\t}\n\tam = g_new0 (ArrayMethod, 1);\n\tam->name = name;\n\tam->sig = sig;\n\tam->parent = mtype;\n\tam->token = mono_image_get_memberref_token (assembly, am->parent, name,\n\t\tmethod_encode_signature (assembly, sig));\n\tassembly->array_methods = g_list_prepend (assembly->array_methods, am);\n\tm->table_idx = am->token & 0xffffff;\n\treturn am->token;\n}\n\n/*\n * Insert into the metadata tables all the info about the TypeBuilder tb.\n * Data in the tables is inserted in a predefined order, since some tables need to be sorted.\n */\nstatic void\nmono_image_get_type_info (MonoDomain *domain, MonoReflectionTypeBuilder *tb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint *values;\n\tint i, is_object = 0, is_system = 0;\n\tchar *n;\n\n\ttable = &assembly->tables [MONO_TABLE_TYPEDEF];\n\tvalues = table->values + tb->table_idx * MONO_TYPEDEF_SIZE;\n\tvalues [MONO_TYPEDEF_FLAGS] = tb->attrs;\n\tn = mono_string_to_utf8 (tb->name);\n\tif (strcmp (n, \"Object\") == 0)\n\t\tis_object++;\n\tvalues [MONO_TYPEDEF_NAME] = string_heap_insert (&assembly->sheap, n);\n\tg_free (n);\n\tn = mono_string_to_utf8 (tb->nspace);\n\tif (strcmp (n, \"System\") == 0)\n\t\tis_system++;\n\tvalues [MONO_TYPEDEF_NAMESPACE] = string_heap_insert (&assembly->sheap, n);\n\tg_free (n);\n\tif (tb->parent && !(is_system && is_object) && \n\t\t\t!(tb->attrs & TYPE_ATTRIBUTE_INTERFACE)) { /* interfaces don't have a parent */\n\t\tvalues [MONO_TYPEDEF_EXTENDS] = mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)tb->parent));\n\t} else {\n\t\tvalues [MONO_TYPEDEF_EXTENDS] = 0;\n\t}\n\tvalues [MONO_TYPEDEF_FIELD_LIST] = assembly->tables [MONO_TABLE_FIELD].next_idx;\n\tvalues [MONO_TYPEDEF_METHOD_LIST] = assembly->tables [MONO_TABLE_METHOD].next_idx;\n\n\t/*\n\t * if we have explicitlayout or sequentiallayouts, output data in the\n\t * ClassLayout table.\n\t */\n\tif (((tb->attrs & TYPE_ATTRIBUTE_LAYOUT_MASK) != TYPE_ATTRIBUTE_AUTO_LAYOUT) &&\n\t\t\t((tb->class_size > 0) || (tb->packing_size > 0))) {\n\t\ttable = &assembly->tables [MONO_TABLE_CLASSLAYOUT];\n\t\ttable->rows++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_CLASS_LAYOUT_SIZE;\n\t\tvalues [MONO_CLASS_LAYOUT_PARENT] = tb->table_idx;\n\t\tvalues [MONO_CLASS_LAYOUT_CLASS_SIZE] = tb->class_size;\n\t\tvalues [MONO_CLASS_LAYOUT_PACKING_SIZE] = tb->packing_size;\n\t}\n\n\t/* handle interfaces */\n\tif (tb->interfaces) {\n\t\ttable = &assembly->tables [MONO_TABLE_INTERFACEIMPL];\n\t\ti = table->rows;\n\t\ttable->rows += mono_array_length (tb->interfaces);\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + (i + 1) * MONO_INTERFACEIMPL_SIZE;\n\t\tfor (i = 0; i < mono_array_length (tb->interfaces); ++i) {\n\t\t\tMonoReflectionType* iface = (MonoReflectionType*) mono_array_get (tb->interfaces, gpointer, i);\n\t\t\tvalues [MONO_INTERFACEIMPL_CLASS] = tb->table_idx;\n\t\t\tvalues [MONO_INTERFACEIMPL_INTERFACE] = mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle (iface));\n\t\t\tvalues += MONO_INTERFACEIMPL_SIZE;\n\t\t}\n\t}\n\n\t/* handle fields */\n\tif (tb->fields) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELD];\n\t\ttable->rows += tb->num_fields;\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < tb->num_fields; ++i)\n\t\t\tmono_image_get_field_info (\n\t\t\t\tmono_array_get (tb->fields, MonoReflectionFieldBuilder*, i), assembly);\n\t}\n\n\t/* handle constructors */\n\tif (tb->ctors) {\n\t\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t\ttable->rows += mono_array_length (tb->ctors);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (tb->ctors); ++i)\n\t\t\tmono_image_get_ctor_info (domain,\n\t\t\t\tmono_array_get (tb->ctors, MonoReflectionCtorBuilder*, i), assembly);\n\t}\n\n\t/* handle methods */\n\tif (tb->methods) {\n\t\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t\ttable->rows += tb->num_methods;\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < tb->num_methods; ++i)\n\t\t\tmono_image_get_method_info (\n\t\t\t\tmono_array_get (tb->methods, MonoReflectionMethodBuilder*, i), assembly);\n\t}\n\n\t/* Do the same with properties etc.. */\n\tif (tb->events && mono_array_length (tb->events)) {\n\t\ttable = &assembly->tables [MONO_TABLE_EVENT];\n\t\ttable->rows += mono_array_length (tb->events);\n\t\talloc_table (table, table->rows);\n\t\ttable = &assembly->tables [MONO_TABLE_EVENTMAP];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_EVENT_MAP_SIZE;\n\t\tvalues [MONO_EVENT_MAP_PARENT] = tb->table_idx;\n\t\tvalues [MONO_EVENT_MAP_EVENTLIST] = assembly->tables [MONO_TABLE_EVENT].next_idx;\n\t\tfor (i = 0; i < mono_array_length (tb->events); ++i)\n\t\t\tmono_image_get_event_info (\n\t\t\t\tmono_array_get (tb->events, MonoReflectionEventBuilder*, i), assembly);\n\t}\n\tif (tb->properties && mono_array_length (tb->properties)) {\n\t\ttable = &assembly->tables [MONO_TABLE_PROPERTY];\n\t\ttable->rows += mono_array_length (tb->properties);\n\t\talloc_table (table, table->rows);\n\t\ttable = &assembly->tables [MONO_TABLE_PROPERTYMAP];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_PROPERTY_MAP_SIZE;\n\t\tvalues [MONO_PROPERTY_MAP_PARENT] = tb->table_idx;\n\t\tvalues [MONO_PROPERTY_MAP_PROPERTY_LIST] = assembly->tables [MONO_TABLE_PROPERTY].next_idx;\n\t\tfor (i = 0; i < mono_array_length (tb->properties); ++i)\n\t\t\tmono_image_get_property_info (\n\t\t\t\tmono_array_get (tb->properties, MonoReflectionPropertyBuilder*, i), assembly);\n\t}\n\n\t/* handle generic parameters */\n\tif (tb->generic_params) {\n\t\ttable = &assembly->tables [MONO_TABLE_GENERICPARAM];\n\t\ttable->rows += mono_array_length (tb->generic_params);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (tb->generic_params); ++i) {\n\t\t\tguint32 owner = MONO_TYPEORMETHOD_TYPE | (tb->table_idx << MONO_TYPEORMETHOD_BITS);\n\n\t\t\tmono_image_get_generic_param_info (\n\t\t\t\tmono_array_get (tb->generic_params, MonoReflectionGenericParam*, i), owner, assembly);\n\t\t}\n\t}\n\n\tmono_image_add_decl_security (assembly, \n\t\tmono_metadata_make_token (MONO_TABLE_TYPEDEF, tb->table_idx), tb->permissions);\n\n\tif (tb->subtypes) {\n\t\tMonoDynamicTable *ntable;\n\t\t\n\t\tntable = &assembly->tables [MONO_TABLE_NESTEDCLASS];\n\t\tntable->rows += mono_array_length (tb->subtypes);\n\t\talloc_table (ntable, ntable->rows);\n\t\tvalues = ntable->values + ntable->next_idx * MONO_NESTED_CLASS_SIZE;\n\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i) {\n\t\t\tMonoReflectionTypeBuilder *subtype = mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i);\n\n\t\t\tvalues [MONO_NESTED_CLASS_NESTED] = subtype->table_idx;\n\t\t\tvalues [MONO_NESTED_CLASS_ENCLOSING] = tb->table_idx;\n\t\t\t/*g_print (\"nesting %s (%d) in %s (%d) (rows %d/%d)\\n\",\n\t\t\t\tmono_string_to_utf8 (subtype->name), subtype->table_idx,\n\t\t\t\tmono_string_to_utf8 (tb->name), tb->table_idx,\n\t\t\t\tntable->next_idx, ntable->rows);*/\n\t\t\tvalues += MONO_NESTED_CLASS_SIZE;\n\t\t\tntable->next_idx++;\n\t\t}\n\t}\n}\n#endif\n\nstatic void\ncollect_types (GPtrArray *types, MonoReflectionTypeBuilder *type)\n{\n\tint i;\n\n\tg_ptr_array_add (types, type); /* FIXME: GC object added to unmanaged memory */\n\n\tif (!type->subtypes)\n\t\treturn;\n\n\tfor (i = 0; i < mono_array_length (type->subtypes); ++i) {\n\t\tMonoReflectionTypeBuilder *subtype = mono_array_get (type->subtypes, MonoReflectionTypeBuilder*, i);\n\t\tcollect_types (types, subtype);\n\t}\n}\n\nstatic gint\ncompare_types_by_table_idx (MonoReflectionTypeBuilder **type1, MonoReflectionTypeBuilder **type2)\n{\n\tif ((*type1)->table_idx < (*type2)->table_idx)\n\t\treturn -1;\n\telse\n\t\tif ((*type1)->table_idx > (*type2)->table_idx)\n\t\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void\nparams_add_cattrs (MonoDynamicImage *assembly, MonoArray *pinfo) {\n\tint i;\n\n\tif (!pinfo)\n\t\treturn;\n\tfor (i = 0; i < mono_array_length (pinfo); ++i) {\n\t\tMonoReflectionParamBuilder *pb;\n\t\tpb = mono_array_get (pinfo, MonoReflectionParamBuilder *, i);\n\t\tif (!pb)\n\t\t\tcontinue;\n\t\tmono_image_add_cattrs (assembly, pb->table_idx, MONO_CUSTOM_ATTR_PARAMDEF, pb->cattrs);\n\t}\n}\n\nstatic void\ntype_add_cattrs (MonoDynamicImage *assembly, MonoReflectionTypeBuilder *tb) {\n\tint i;\n\t\n\tmono_image_add_cattrs (assembly, tb->table_idx, MONO_CUSTOM_ATTR_TYPEDEF, tb->cattrs);\n\tif (tb->fields) {\n\t\tfor (i = 0; i < tb->num_fields; ++i) {\n\t\t\tMonoReflectionFieldBuilder* fb;\n\t\t\tfb = mono_array_get (tb->fields, MonoReflectionFieldBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, fb->table_idx, MONO_CUSTOM_ATTR_FIELDDEF, fb->cattrs);\n\t\t}\n\t}\n\tif (tb->events) {\n\t\tfor (i = 0; i < mono_array_length (tb->events); ++i) {\n\t\t\tMonoReflectionEventBuilder* eb;\n\t\t\teb = mono_array_get (tb->events, MonoReflectionEventBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, eb->table_idx, MONO_CUSTOM_ATTR_EVENT, eb->cattrs);\n\t\t}\n\t}\n\tif (tb->properties) {\n\t\tfor (i = 0; i < mono_array_length (tb->properties); ++i) {\n\t\t\tMonoReflectionPropertyBuilder* pb;\n\t\t\tpb = mono_array_get (tb->properties, MonoReflectionPropertyBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, pb->table_idx, MONO_CUSTOM_ATTR_PROPERTY, pb->cattrs);\n\t\t}\n\t}\n\tif (tb->ctors) {\n\t\tfor (i = 0; i < mono_array_length (tb->ctors); ++i) {\n\t\t\tMonoReflectionCtorBuilder* cb;\n\t\t\tcb = mono_array_get (tb->ctors, MonoReflectionCtorBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, cb->table_idx, MONO_CUSTOM_ATTR_METHODDEF, cb->cattrs);\n\t\t\tparams_add_cattrs (assembly, cb->pinfo);\n\t\t}\n\t}\n\n\tif (tb->methods) {\n\t\tfor (i = 0; i < tb->num_methods; ++i) {\n\t\t\tMonoReflectionMethodBuilder* mb;\n\t\t\tmb = mono_array_get (tb->methods, MonoReflectionMethodBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, mb->table_idx, MONO_CUSTOM_ATTR_METHODDEF, mb->cattrs);\n\t\t\tparams_add_cattrs (assembly, mb->pinfo);\n\t\t}\n\t}\n\n\tif (tb->subtypes) {\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i)\n\t\t\ttype_add_cattrs (assembly, mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i));\n\t}\n}\n\nstatic void\nmodule_add_cattrs (MonoDynamicImage *assembly, MonoReflectionModuleBuilder *moduleb)\n{\n\tint i;\n\t\n\tmono_image_add_cattrs (assembly, moduleb->table_idx, MONO_CUSTOM_ATTR_MODULE, moduleb->cattrs);\n\n\tif (moduleb->global_methods) {\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_methods); ++i) {\n\t\t\tMonoReflectionMethodBuilder* mb = mono_array_get (moduleb->global_methods, MonoReflectionMethodBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, mb->table_idx, MONO_CUSTOM_ATTR_METHODDEF, mb->cattrs);\n\t\t\tparams_add_cattrs (assembly, mb->pinfo);\n\t\t}\n\t}\n\n\tif (moduleb->global_fields) {\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_fields); ++i) {\n\t\t\tMonoReflectionFieldBuilder *fb = mono_array_get (moduleb->global_fields, MonoReflectionFieldBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, fb->table_idx, MONO_CUSTOM_ATTR_FIELDDEF, fb->cattrs);\n\t\t}\n\t}\n\t\n\tif (moduleb->types) {\n\t\tfor (i = 0; i < moduleb->num_types; ++i)\n\t\t\ttype_add_cattrs (assembly, mono_array_get (moduleb->types, MonoReflectionTypeBuilder*, i));\n\t}\n}\n\nstatic void\nmono_image_fill_file_table (MonoDomain *domain, MonoReflectionModule *module, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tchar blob_size [6];\n\tguchar hash [20];\n\tchar *b = blob_size;\n\tchar *dir, *path;\n\n\ttable = &assembly->tables [MONO_TABLE_FILE];\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_FILE_SIZE;\n\tvalues [MONO_FILE_FLAGS] = FILE_CONTAINS_METADATA;\n\tvalues [MONO_FILE_NAME] = string_heap_insert (&assembly->sheap, module->image->module_name);\n\tif (module->image->dynamic) {\n\t\t/* This depends on the fact that the main module is emitted last */\n\t\tdir = mono_string_to_utf8 (((MonoReflectionModuleBuilder*)module)->assemblyb->dir);\n\t\tpath = g_strdup_printf (\"%s%c%s\", dir, G_DIR_SEPARATOR, module->image->module_name);\n\t} else {\n\t\tdir = NULL;\n\t\tpath = g_strdup (module->image->name);\n\t}\n\tmono_sha1_get_digest_from_file (path, hash);\n\tg_free (dir);\n\tg_free (path);\n\tmono_metadata_encode_value (20, b, &b);\n\tvalues [MONO_FILE_HASH_VALUE] = mono_image_add_stream_data (&assembly->blob, blob_size, b-blob_size);\n\tmono_image_add_stream_data (&assembly->blob, (char*)hash, 20);\n\ttable->next_idx ++;\n}\n\nstatic void\nmono_image_fill_module_table (MonoDomain *domain, MonoReflectionModuleBuilder *mb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tint i;\n\n\ttable = &assembly->tables [MONO_TABLE_MODULE];\n\tmb->table_idx = table->next_idx ++;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->module.name);\n\ti = mono_image_add_stream_data (&assembly->guid, mono_array_addr (mb->guid, char, 0), 16);\n\ti /= 16;\n\t++i;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_GENERATION] = 0;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_MVID] = i;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_ENC] = 0;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_ENCBASE] = 0;\n}\n\nstatic guint32\nmono_image_fill_export_table_from_class (MonoDomain *domain, MonoClass *klass,\n\tguint32 module_index, guint32 parent_index, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 visib, res;\n\n\tvisib = klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\tif (! ((visib & TYPE_ATTRIBUTE_PUBLIC) || (visib & TYPE_ATTRIBUTE_NESTED_PUBLIC)))\n\t\treturn 0;\n\n\ttable = &assembly->tables [MONO_TABLE_EXPORTEDTYPE];\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_EXP_TYPE_SIZE;\n\n\tvalues [MONO_EXP_TYPE_FLAGS] = klass->flags;\n\tvalues [MONO_EXP_TYPE_TYPEDEF] = klass->type_token;\n\tif (klass->nested_in)\n\t\tvalues [MONO_EXP_TYPE_IMPLEMENTATION] = (parent_index << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_EXP_TYPE;\n\telse\n\t\tvalues [MONO_EXP_TYPE_IMPLEMENTATION] = (module_index << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_FILE;\n\tvalues [MONO_EXP_TYPE_NAME] = string_heap_insert (&assembly->sheap, klass->name);\n\tvalues [MONO_EXP_TYPE_NAMESPACE] = string_heap_insert (&assembly->sheap, klass->name_space);\n\n\tres = table->next_idx;\n\n\ttable->next_idx ++;\n\n\t/* Emit nested types */\n\tif (klass->ext && klass->ext->nested_classes) {\n\t\tGList *tmp;\n\n\t\tfor (tmp = klass->ext->nested_classes; tmp; tmp = tmp->next)\n\t\t\tmono_image_fill_export_table_from_class (domain, tmp->data, module_index, table->next_idx - 1, assembly);\n\t}\n\n\treturn res;\n}\n\nstatic void\nmono_image_fill_export_table (MonoDomain *domain, MonoReflectionTypeBuilder *tb,\n\tguint32 module_index, guint32 parent_index, MonoDynamicImage *assembly)\n{\n\tMonoClass *klass;\n\tguint32 idx, i;\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\tklass->type_token = mono_metadata_make_token (MONO_TABLE_TYPEDEF, tb->table_idx);\n\n\tidx = mono_image_fill_export_table_from_class (domain, klass, module_index, \n\t\t\t\t\t\t\t\t\t\t\t\t   parent_index, assembly);\n\n\t/* \n\t * Emit nested types\n\t * We need to do this ourselves since klass->nested_classes is not set up.\n\t */\n\tif (tb->subtypes) {\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i)\n\t\t\tmono_image_fill_export_table (domain, mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i), module_index, idx, assembly);\n\t}\n}\n\nstatic void\nmono_image_fill_export_table_from_module (MonoDomain *domain, MonoReflectionModule *module,\n\tguint32 module_index, MonoDynamicImage *assembly)\n{\n\tMonoImage *image = module->image;\n\tMonoTableInfo  *t;\n\tguint32 i;\n\n\tt = &image->tables [MONO_TABLE_TYPEDEF];\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tMonoClass *klass = mono_class_get (image, mono_metadata_make_token (MONO_TABLE_TYPEDEF, i + 1));\n\n\t\tif (klass->flags & TYPE_ATTRIBUTE_PUBLIC)\n\t\t\tmono_image_fill_export_table_from_class (domain, klass, module_index, 0, assembly);\n\t}\n}\n\nstatic guint32\nadd_exported_type (MonoReflectionAssemblyBuilder *assemblyb, MonoDynamicImage *assembly, MonoClass *klass)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 scope, idx, res, impl;\n\tgboolean forwarder = TRUE;\n\n\tif (klass->nested_in) {\n\t\timpl = add_exported_type (assemblyb, assembly, klass->nested_in);\n\t\tforwarder = FALSE;\n\t} else {\n\t\tscope = resolution_scope_from_image (assembly, klass->image);\n\t\tg_assert ((scope & MONO_RESOLTION_SCOPE_MASK) == MONO_RESOLTION_SCOPE_ASSEMBLYREF);\n\t\tidx = scope >> MONO_RESOLTION_SCOPE_BITS;\n\t\timpl = (idx << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_ASSEMBLYREF;\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_EXPORTEDTYPE];\n\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_EXP_TYPE_SIZE;\n\n\tvalues [MONO_EXP_TYPE_FLAGS] = forwarder ? TYPE_ATTRIBUTE_FORWARDER : 0;\n\tvalues [MONO_EXP_TYPE_TYPEDEF] = 0;\n\tvalues [MONO_EXP_TYPE_IMPLEMENTATION] = impl;\n\tvalues [MONO_EXP_TYPE_NAME] = string_heap_insert (&assembly->sheap, klass->name);\n\tvalues [MONO_EXP_TYPE_NAMESPACE] = string_heap_insert (&assembly->sheap, klass->name_space);\n\n\tres = (table->next_idx << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_EXP_TYPE;\n\n\ttable->next_idx++;\n\n\treturn res;\n}\n\nstatic void\nmono_image_fill_export_table_from_type_forwarders (MonoReflectionAssemblyBuilder *assemblyb, MonoDynamicImage *assembly)\n{\n\tMonoClass *klass;\n\tint i;\n\n\tif (!assemblyb->type_forwarders)\n\t\treturn;\n\n\tfor (i = 0; i < mono_array_length (assemblyb->type_forwarders); ++i) {\n\t\tMonoReflectionType *t = mono_array_get (assemblyb->type_forwarders, MonoReflectionType *, i);\n\t\tMonoType *type;\n\t\tif (!t)\n\t\t\tcontinue;\n\n\t\ttype = mono_reflection_type_get_handle (t);\n\t\tg_assert (type);\n\n\t\tklass = mono_class_from_mono_type (type);\n\n\t\tadd_exported_type (assemblyb, assembly, klass);\n\t}\n}\n\n#define align_pointer(base,p)\\\n\tdo {\\\n\t\tguint32 __diff = (unsigned char*)(p)-(unsigned char*)(base);\\\n\t\tif (__diff & 3)\\\n\t\t\t(p) += 4 - (__diff & 3);\\\n\t} while (0)\n\nstatic int\ncompare_constants (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\treturn a_values [MONO_CONSTANT_PARENT] - b_values [MONO_CONSTANT_PARENT];\n}\n\nstatic int\ncompare_semantics (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\tint assoc = a_values [MONO_METHOD_SEMA_ASSOCIATION] - b_values [MONO_METHOD_SEMA_ASSOCIATION];\n\tif (assoc)\n\t\treturn assoc;\n\treturn a_values [MONO_METHOD_SEMA_SEMANTICS] - b_values [MONO_METHOD_SEMA_SEMANTICS];\n}\n\nstatic int\ncompare_custom_attrs (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_CUSTOM_ATTR_PARENT] - b_values [MONO_CUSTOM_ATTR_PARENT];\n}\n\nstatic int\ncompare_field_marshal (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_FIELD_MARSHAL_PARENT] - b_values [MONO_FIELD_MARSHAL_PARENT];\n}\n\nstatic int\ncompare_nested (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_NESTED_CLASS_NESTED] - b_values [MONO_NESTED_CLASS_NESTED];\n}\n\nstatic int\ncompare_genericparam (const void *a, const void *b)\n{\n\tconst GenericParamTableEntry **a_entry = (const GenericParamTableEntry **) a;\n\tconst GenericParamTableEntry **b_entry = (const GenericParamTableEntry **) b;\n\n\tif ((*b_entry)->owner == (*a_entry)->owner)\n\t\treturn \n\t\t\tmono_type_get_generic_param_num (mono_reflection_type_get_handle ((MonoReflectionType*)(*a_entry)->gparam)) -\n\t\t\tmono_type_get_generic_param_num (mono_reflection_type_get_handle ((MonoReflectionType*)(*b_entry)->gparam));\n\telse\n\t\treturn (*a_entry)->owner - (*b_entry)->owner;\n}\n\nstatic int\ncompare_declsecurity_attrs (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_DECL_SECURITY_PARENT] - b_values [MONO_DECL_SECURITY_PARENT];\n}\n\nstatic int\ncompare_interface_impl (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\tint klass = a_values [MONO_INTERFACEIMPL_CLASS] - b_values [MONO_INTERFACEIMPL_CLASS];\n\tif (klass)\n\t\treturn klass;\n\n\treturn a_values [MONO_INTERFACEIMPL_INTERFACE] - b_values [MONO_INTERFACEIMPL_INTERFACE];\n}\n\nstatic void\npad_heap (MonoDynamicStream *sh)\n{\n\tif (sh->index & 3) {\n\t\tint sz = 4 - (sh->index & 3);\n\t\tmemset (sh->data + sh->index, 0, sz);\n\t\tsh->index += sz;\n\t}\n}\n\nstruct StreamDesc {\n\tconst char *name;\n\tMonoDynamicStream *stream;\n};\n\n/*\n * build_compressed_metadata() fills in the blob of data that represents the \n * raw metadata as it will be saved in the PE file. The five streams are output \n * and the metadata tables are comnpressed from the guint32 array representation, \n * to the compressed on-disk format.\n */\nstatic void\nbuild_compressed_metadata (MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tint i;\n\tguint64 valid_mask = 0;\n\tguint64 sorted_mask;\n\tguint32 heapt_size = 0;\n\tguint32 meta_size = 256; /* allow for header and other stuff */\n\tguint32 table_offset;\n\tguint32 ntables = 0;\n\tguint64 *int64val;\n\tguint32 *int32val;\n\tguint16 *int16val;\n\tMonoImage *meta;\n\tunsigned char *p;\n\tstruct StreamDesc stream_desc [5];\n\n\tqsort (assembly->gen_params->pdata, assembly->gen_params->len, sizeof (gpointer), compare_genericparam);\n\tfor (i = 0; i < assembly->gen_params->len; i++){\n\t\tGenericParamTableEntry *entry = g_ptr_array_index (assembly->gen_params, i);\n\t\twrite_generic_param_entry (assembly, entry);\n\t}\n\n\tstream_desc [0].name  = \"#~\";\n\tstream_desc [0].stream = &assembly->tstream;\n\tstream_desc [1].name  = \"#Strings\";\n\tstream_desc [1].stream = &assembly->sheap;\n\tstream_desc [2].name  = \"#US\";\n\tstream_desc [2].stream = &assembly->us;\n\tstream_desc [3].name  = \"#Blob\";\n\tstream_desc [3].stream = &assembly->blob;\n\tstream_desc [4].name  = \"#GUID\";\n\tstream_desc [4].stream = &assembly->guid;\n\t\n\t/* tables that are sorted */\n\tsorted_mask = ((guint64)1 << MONO_TABLE_CONSTANT) | ((guint64)1 << MONO_TABLE_FIELDMARSHAL)\n\t\t| ((guint64)1 << MONO_TABLE_METHODSEMANTICS) | ((guint64)1 << MONO_TABLE_CLASSLAYOUT)\n\t\t| ((guint64)1 << MONO_TABLE_FIELDLAYOUT) | ((guint64)1 << MONO_TABLE_FIELDRVA)\n\t\t| ((guint64)1 << MONO_TABLE_IMPLMAP) | ((guint64)1 << MONO_TABLE_NESTEDCLASS)\n\t\t| ((guint64)1 << MONO_TABLE_METHODIMPL) | ((guint64)1 << MONO_TABLE_CUSTOMATTRIBUTE)\n\t\t| ((guint64)1 << MONO_TABLE_DECLSECURITY) | ((guint64)1 << MONO_TABLE_GENERICPARAM)\n\t\t| ((guint64)1 << MONO_TABLE_INTERFACEIMPL);\n\t\n\t/* Compute table sizes */\n\t/* the MonoImage has already been created in mono_image_basic_init() */\n\tmeta = &assembly->image;\n\n\t/* sizes should be multiple of 4 */\n\tpad_heap (&assembly->blob);\n\tpad_heap (&assembly->guid);\n\tpad_heap (&assembly->sheap);\n\tpad_heap (&assembly->us);\n\n\t/* Setup the info used by compute_sizes () */\n\tmeta->idx_blob_wide = assembly->blob.index >= 65536 ? 1 : 0;\n\tmeta->idx_guid_wide = assembly->guid.index >= 65536 ? 1 : 0;\n\tmeta->idx_string_wide = assembly->sheap.index >= 65536 ? 1 : 0;\n\n\tmeta_size += assembly->blob.index;\n\tmeta_size += assembly->guid.index;\n\tmeta_size += assembly->sheap.index;\n\tmeta_size += assembly->us.index;\n\n\tfor (i=0; i < MONO_TABLE_NUM; ++i)\n\t\tmeta->tables [i].rows = assembly->tables [i].rows;\n\t\n\tfor (i = 0; i < MONO_TABLE_NUM; i++){\n\t\tif (meta->tables [i].rows == 0)\n\t\t\tcontinue;\n\t\tvalid_mask |= (guint64)1 << i;\n\t\tntables ++;\n\t\tmeta->tables [i].row_size = mono_metadata_compute_size (\n\t\t\tmeta, i, &meta->tables [i].size_bitfield);\n\t\theapt_size += meta->tables [i].row_size * meta->tables [i].rows;\n\t}\n\theapt_size += 24; /* #~ header size */\n\theapt_size += ntables * 4;\n\t/* make multiple of 4 */\n\theapt_size += 3;\n\theapt_size &= ~3;\n\tmeta_size += heapt_size;\n\tmeta->raw_metadata = g_malloc0 (meta_size);\n\tp = (unsigned char*)meta->raw_metadata;\n\t/* the metadata signature */\n\t*p++ = 'B'; *p++ = 'S'; *p++ = 'J'; *p++ = 'B';\n\t/* version numbers and 4 bytes reserved */\n\tint16val = (guint16*)p;\n\t*int16val++ = GUINT16_TO_LE (meta->md_version_major);\n\t*int16val = GUINT16_TO_LE (meta->md_version_minor);\n\tp += 8;\n\t/* version string */\n\tint32val = (guint32*)p;\n\t*int32val = GUINT32_TO_LE ((strlen (meta->version) + 3) & (~3)); /* needs to be multiple of 4 */\n\tp += 4;\n\tmemcpy (p, meta->version, strlen (meta->version));\n\tp += GUINT32_FROM_LE (*int32val);\n\talign_pointer (meta->raw_metadata, p);\n\tint16val = (guint16*)p;\n\t*int16val++ = GUINT16_TO_LE (0); /* flags must be 0 */\n\t*int16val = GUINT16_TO_LE (5); /* number of streams */\n\tp += 4;\n\n\t/*\n\t * write the stream info.\n\t */\n\ttable_offset = (p - (unsigned char*)meta->raw_metadata) + 5 * 8 + 40; /* room needed for stream headers */\n\ttable_offset += 3; table_offset &= ~3;\n\n\tassembly->tstream.index = heapt_size;\n\tfor (i = 0; i < 5; ++i) {\n\t\tint32val = (guint32*)p;\n\t\tstream_desc [i].stream->offset = table_offset;\n\t\t*int32val++ = GUINT32_TO_LE (table_offset);\n\t\t*int32val = GUINT32_TO_LE (stream_desc [i].stream->index);\n\t\ttable_offset += GUINT32_FROM_LE (*int32val);\n\t\ttable_offset += 3; table_offset &= ~3;\n\t\tp += 8;\n\t\tstrcpy ((char*)p, stream_desc [i].name);\n\t\tp += strlen (stream_desc [i].name) + 1;\n\t\talign_pointer (meta->raw_metadata, p);\n\t}\n\t/* \n\t * now copy the data, the table stream header and contents goes first.\n\t */\n\tg_assert ((p - (unsigned char*)meta->raw_metadata) < assembly->tstream.offset);\n\tp = (guchar*)meta->raw_metadata + assembly->tstream.offset;\n\tint32val = (guint32*)p;\n\t*int32val = GUINT32_TO_LE (0); /* reserved */\n\tp += 4;\n\n\tif (mono_framework_version () > 1) {\n\t\t*p++ = 2; /* version */\n\t\t*p++ = 0;\n\t} else {\n\t\t*p++ = 1; /* version */\n\t\t*p++ = 0;\n\t}\n\n\tif (meta->idx_string_wide)\n\t\t*p |= 0x01;\n\tif (meta->idx_guid_wide)\n\t\t*p |= 0x02;\n\tif (meta->idx_blob_wide)\n\t\t*p |= 0x04;\n\t++p;\n\t*p++ = 1; /* reserved */\n\tint64val = (guint64*)p;\n\t*int64val++ = GUINT64_TO_LE (valid_mask);\n\t*int64val++ = GUINT64_TO_LE (valid_mask & sorted_mask); /* bitvector of sorted tables  */\n\tp += 16;\n\tint32val = (guint32*)p;\n\tfor (i = 0; i < MONO_TABLE_NUM; i++){\n\t\tif (meta->tables [i].rows == 0)\n\t\t\tcontinue;\n\t\t*int32val++ = GUINT32_TO_LE (meta->tables [i].rows);\n\t}\n\tp = (unsigned char*)int32val;\n\n\t/* sort the tables that still need sorting */\n\ttable = &assembly->tables [MONO_TABLE_CONSTANT];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_CONSTANT_SIZE, table->rows, sizeof (guint32) * MONO_CONSTANT_SIZE, compare_constants);\n\ttable = &assembly->tables [MONO_TABLE_METHODSEMANTICS];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_METHOD_SEMA_SIZE, table->rows, sizeof (guint32) * MONO_METHOD_SEMA_SIZE, compare_semantics);\n\ttable = &assembly->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_CUSTOM_ATTR_SIZE, table->rows, sizeof (guint32) * MONO_CUSTOM_ATTR_SIZE, compare_custom_attrs);\n\ttable = &assembly->tables [MONO_TABLE_FIELDMARSHAL];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_FIELD_MARSHAL_SIZE, table->rows, sizeof (guint32) * MONO_FIELD_MARSHAL_SIZE, compare_field_marshal);\n\ttable = &assembly->tables [MONO_TABLE_NESTEDCLASS];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_NESTED_CLASS_SIZE, table->rows, sizeof (guint32) * MONO_NESTED_CLASS_SIZE, compare_nested);\n\t/* Section 21.11 DeclSecurity in Partition II doesn't specify this to be sorted by MS implementation requires it */\n\ttable = &assembly->tables [MONO_TABLE_DECLSECURITY];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_DECL_SECURITY_SIZE, table->rows, sizeof (guint32) * MONO_DECL_SECURITY_SIZE, compare_declsecurity_attrs);\n\ttable = &assembly->tables [MONO_TABLE_INTERFACEIMPL];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_INTERFACEIMPL_SIZE, table->rows, sizeof (guint32) * MONO_INTERFACEIMPL_SIZE, compare_interface_impl);\n\n\t/* compress the tables */\n\tfor (i = 0; i < MONO_TABLE_NUM; i++){\n\t\tint row, col;\n\t\tguint32 *values;\n\t\tguint32 bitfield = meta->tables [i].size_bitfield;\n\t\tif (!meta->tables [i].rows)\n\t\t\tcontinue;\n\t\tif (assembly->tables [i].columns != mono_metadata_table_count (bitfield))\n\t\t\tg_error (\"col count mismatch in %d: %d %d\", i, assembly->tables [i].columns, mono_metadata_table_count (bitfield));\n\t\tmeta->tables [i].base = (char*)p;\n\t\tfor (row = 1; row <= meta->tables [i].rows; ++row) {\n\t\t\tvalues = assembly->tables [i].values + row * assembly->tables [i].columns;\n\t\t\tfor (col = 0; col < assembly->tables [i].columns; ++col) {\n\t\t\t\tswitch (mono_metadata_table_size (bitfield, col)) {\n\t\t\t\tcase 1:\n\t\t\t\t\t*p++ = values [col];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t*p++ = values [col] & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 8) & 0xff;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\t*p++ = values [col] & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 8) & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 16) & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 24) & 0xff;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_assert ((p - (const unsigned char*)meta->tables [i].base) == (meta->tables [i].rows * meta->tables [i].row_size));\n\t}\n\t\n\tg_assert (assembly->guid.offset + assembly->guid.index < meta_size);\n\tmemcpy (meta->raw_metadata + assembly->sheap.offset, assembly->sheap.data, assembly->sheap.index);\n\tmemcpy (meta->raw_metadata + assembly->us.offset, assembly->us.data, assembly->us.index);\n\tmemcpy (meta->raw_metadata + assembly->blob.offset, assembly->blob.data, assembly->blob.index);\n\tmemcpy (meta->raw_metadata + assembly->guid.offset, assembly->guid.data, assembly->guid.index);\n\n\tassembly->meta_size = assembly->guid.offset + assembly->guid.index;\n}\n\n/*\n * Some tables in metadata need to be sorted according to some criteria, but\n * when methods and fields are first created with reflection, they may be assigned a token\n * that doesn't correspond to the final token they will get assigned after the sorting.\n * ILGenerator.cs keeps a fixup table that maps the position of tokens in the IL code stream\n * with the reflection objects that represent them. Once all the tables are set up, the \n * reflection objects will contains the correct table index. fixup_method() will fixup the\n * tokens for the method with ILGenerator @ilgen.\n */\nstatic void\nfixup_method (MonoReflectionILGen *ilgen, gpointer value, MonoDynamicImage *assembly)\n{\n\tguint32 code_idx = GPOINTER_TO_UINT (value);\n\tMonoReflectionILTokenInfo *iltoken;\n\tMonoReflectionFieldBuilder *field;\n\tMonoReflectionCtorBuilder *ctor;\n\tMonoReflectionMethodBuilder *method;\n\tMonoReflectionTypeBuilder *tb;\n\tMonoReflectionArrayMethod *am;\n\tguint32 i, idx = 0;\n\tunsigned char *target;\n\n\tfor (i = 0; i < ilgen->num_token_fixups; ++i) {\n\t\tiltoken = (MonoReflectionILTokenInfo *)mono_array_addr_with_size (ilgen->token_fixups, sizeof (MonoReflectionILTokenInfo), i);\n\t\ttarget = (guchar*)assembly->code.data + code_idx + iltoken->code_pos;\n\t\tswitch (target [3]) {\n\t\tcase MONO_TABLE_FIELD:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"FieldBuilder\")) {\n\t\t\t\tfield = (MonoReflectionFieldBuilder *)iltoken->member;\n\t\t\t\tidx = field->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoField\")) {\n\t\t\t\tMonoClassField *f = ((MonoReflectionField*)iltoken->member)->field;\n\t\t\t\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->field_to_table_idx, f));\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_TABLE_METHOD:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"MethodBuilder\")) {\n\t\t\t\tmethod = (MonoReflectionMethodBuilder *)iltoken->member;\n\t\t\t\tidx = method->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"ConstructorBuilder\")) {\n\t\t\t\tctor = (MonoReflectionCtorBuilder *)iltoken->member;\n\t\t\t\tidx = ctor->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoMethod\") || \n\t\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoCMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)iltoken->member)->method;\n\t\t\t\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->method_to_table_idx, m));\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_TABLE_TYPEDEF:\n\t\t\tif (strcmp (iltoken->member->vtable->klass->name, \"TypeBuilder\"))\n\t\t\t\tg_assert_not_reached ();\n\t\t\ttb = (MonoReflectionTypeBuilder *)iltoken->member;\n\t\t\tidx = tb->table_idx;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_MEMBERREF:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"MonoArrayMethod\")) {\n\t\t\t\tam = (MonoReflectionArrayMethod*)iltoken->member;\n\t\t\t\tidx = am->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoMethod\") ||\n\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoCMethod\") ||\n\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoGenericMethod\") ||\n\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoGenericCMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)iltoken->member)->method;\n\t\t\t\tg_assert (m->klass->generic_class || m->klass->generic_container);\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"FieldBuilder\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoField\")) {\n\t\t\t\tMonoClassField *f = ((MonoReflectionField*)iltoken->member)->field;\n\t\t\t\tg_assert (is_field_on_inst (f));\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodBuilder\") ||\n\t\t\t\t\t!strcmp (iltoken->member->vtable->klass->name, \"ConstructorBuilder\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"FieldOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"ConstructorOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_TABLE_METHODSPEC:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"MonoGenericMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)iltoken->member)->method;\n\t\t\t\tg_assert (mono_method_signature (m)->generic_param_count);\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodBuilder\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_error (\"got unexpected table 0x%02x in fixup\", target [3]);\n\t\t}\n\t\ttarget [0] = idx & 0xff;\n\t\ttarget [1] = (idx >> 8) & 0xff;\n\t\ttarget [2] = (idx >> 16) & 0xff;\n\t}\n}\n\n/*\n * fixup_cattrs:\n *\n *   The CUSTOM_ATTRIBUTE table might contain METHODDEF tokens whose final\n * value is not known when the table is emitted.\n */\nstatic void\nfixup_cattrs (MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 type, i, idx, token;\n\tMonoObject *ctor;\n\n\ttable = &assembly->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tvalues = table->values + ((i + 1) * MONO_CUSTOM_ATTR_SIZE);\n\n\t\ttype = values [MONO_CUSTOM_ATTR_TYPE];\n\t\tif ((type & MONO_CUSTOM_ATTR_TYPE_MASK) == MONO_CUSTOM_ATTR_TYPE_METHODDEF) {\n\t\t\tidx = type >> MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\t\ttoken = mono_metadata_make_token (MONO_TABLE_METHOD, idx);\n\t\t\tctor = mono_g_hash_table_lookup (assembly->tokens, GUINT_TO_POINTER (token));\n\t\t\tg_assert (ctor);\n\n\t\t\tif (!strcmp (ctor->vtable->klass->name, \"MonoCMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)ctor)->method;\n\t\t\t\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->method_to_table_idx, m));\n\t\t\t\tvalues [MONO_CUSTOM_ATTR_TYPE] = (idx << MONO_CUSTOM_ATTR_TYPE_BITS) | MONO_CUSTOM_ATTR_TYPE_METHODDEF;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nassembly_add_resource_manifest (MonoReflectionModuleBuilder *mb, MonoDynamicImage *assembly, MonoReflectionResource *rsrc, guint32 implementation)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\n\ttable = &assembly->tables [MONO_TABLE_MANIFESTRESOURCE];\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_MANIFEST_SIZE;\n\tvalues [MONO_MANIFEST_OFFSET] = rsrc->offset;\n\tvalues [MONO_MANIFEST_FLAGS] = rsrc->attrs;\n\tvalues [MONO_MANIFEST_NAME] = string_heap_insert_mstring (&assembly->sheap, rsrc->name);\n\tvalues [MONO_MANIFEST_IMPLEMENTATION] = implementation;\n\ttable->next_idx++;\n}\n\nstatic void\nassembly_add_resource (MonoReflectionModuleBuilder *mb, MonoDynamicImage *assembly, MonoReflectionResource *rsrc)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tchar blob_size [6];\n\tguchar hash [20];\n\tchar *b = blob_size;\n\tchar *name, *sname;\n\tguint32 idx, offset;\n\n\tif (rsrc->filename) {\n\t\tname = mono_string_to_utf8 (rsrc->filename);\n\t\tsname = g_path_get_basename (name);\n\t\n\t\ttable = &assembly->tables [MONO_TABLE_FILE];\n\t\ttable->rows++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->next_idx * MONO_FILE_SIZE;\n\t\tvalues [MONO_FILE_FLAGS] = FILE_CONTAINS_NO_METADATA;\n\t\tvalues [MONO_FILE_NAME] = string_heap_insert (&assembly->sheap, sname);\n\t\tg_free (sname);\n\n\t\tmono_sha1_get_digest_from_file (name, hash);\n\t\tmono_metadata_encode_value (20, b, &b);\n\t\tvalues [MONO_FILE_HASH_VALUE] = mono_image_add_stream_data (&assembly->blob, blob_size, b-blob_size);\n\t\tmono_image_add_stream_data (&assembly->blob, (char*)hash, 20);\n\t\tg_free (name);\n\t\tidx = table->next_idx++;\n\t\trsrc->offset = 0;\n\t\tidx = MONO_IMPLEMENTATION_FILE | (idx << MONO_IMPLEMENTATION_BITS);\n\t} else {\n\t\tchar sizebuf [4];\n\t\tchar *data;\n\t\tguint len;\n\t\tif (rsrc->data) {\n\t\t\tdata = mono_array_addr (rsrc->data, char, 0);\n\t\t\tlen = mono_array_length (rsrc->data);\n\t\t} else {\n\t\t\tdata = NULL;\n\t\t\tlen = 0;\n\t\t}\n\t\toffset = len;\n\t\tsizebuf [0] = offset; sizebuf [1] = offset >> 8;\n\t\tsizebuf [2] = offset >> 16; sizebuf [3] = offset >> 24;\n\t\trsrc->offset = mono_image_add_stream_data (&assembly->resources, sizebuf, 4);\n\t\tmono_image_add_stream_data (&assembly->resources, data, len);\n\n\t\tif (!mb->is_main)\n\t\t\t/* \n\t\t\t * The entry should be emitted into the MANIFESTRESOURCE table of \n\t\t\t * the main module, but that needs to reference the FILE table\n\t\t\t * which isn't emitted yet.\n\t\t\t */\n\t\t\treturn;\n\t\telse\n\t\t\tidx = 0;\n\t}\n\n\tassembly_add_resource_manifest (mb, assembly, rsrc, idx);\n}\n\nstatic void\nset_version_from_string (MonoString *version, guint32 *values)\n{\n\tgchar *ver, *p, *str;\n\tguint32 i;\n\t\n\tvalues [MONO_ASSEMBLY_MAJOR_VERSION] = 0;\n\tvalues [MONO_ASSEMBLY_MINOR_VERSION] = 0;\n\tvalues [MONO_ASSEMBLY_REV_NUMBER] = 0;\n\tvalues [MONO_ASSEMBLY_BUILD_NUMBER] = 0;\n\tif (!version)\n\t\treturn;\n\tver = str = mono_string_to_utf8 (version);\n\tfor (i = 0; i < 4; ++i) {\n\t\tvalues [MONO_ASSEMBLY_MAJOR_VERSION + i] = strtol (ver, &p, 10);\n\t\tswitch (*p) {\n\t\tcase '.':\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\t/* handle Revision and Build */\n\t\t\tp++;\n\t\t\tbreak;\n\t\t}\n\t\tver = p;\n\t}\n\tg_free (str);\n}\n\nstatic guint32\nload_public_key (MonoArray *pkey, MonoDynamicImage *assembly) {\n\tgsize len;\n\tguint32 token = 0;\n\tchar blob_size [6];\n\tchar *b = blob_size;\n\n\tif (!pkey)\n\t\treturn token;\n\n\tlen = mono_array_length (pkey);\n\tmono_metadata_encode_value (len, b, &b);\n\ttoken = mono_image_add_stream_data (&assembly->blob, blob_size, b - blob_size);\n\tmono_image_add_stream_data (&assembly->blob, mono_array_addr (pkey, char, 0), len);\n\n\tassembly->public_key = g_malloc (len);\n\tmemcpy (assembly->public_key, mono_array_addr (pkey, char, 0), len);\n\tassembly->public_key_len = len;\n\n\t/* Special case: check for ECMA key (16 bytes) */\n\tif ((len == MONO_ECMA_KEY_LENGTH) && mono_is_ecma_key (mono_array_addr (pkey, char, 0), len)) {\n\t\t/* In this case we must reserve 128 bytes (1024 bits) for the signature */\n\t\tassembly->strong_name_size = MONO_DEFAULT_PUBLIC_KEY_LENGTH;\n\t} else if (len >= MONO_PUBLIC_KEY_HEADER_LENGTH + MONO_MINIMUM_PUBLIC_KEY_LENGTH) {\n\t\t/* minimum key size (in 2.0) is 384 bits */\n\t\tassembly->strong_name_size = len - MONO_PUBLIC_KEY_HEADER_LENGTH;\n\t} else {\n\t\t/* FIXME - verifier */\n\t\tg_warning (\"Invalid public key length: %d bits (total: %d)\", (int)MONO_PUBLIC_KEY_BIT_SIZE (len), (int)len);\n\t\tassembly->strong_name_size = MONO_DEFAULT_PUBLIC_KEY_LENGTH; /* to be safe */\n\t}\n\tassembly->strong_name = g_malloc0 (assembly->strong_name_size);\n\n\treturn token;\n}\n\nstatic void\nmono_image_emit_manifest (MonoReflectionModuleBuilder *moduleb)\n{\n\tMonoDynamicTable *table;\n\tMonoDynamicImage *assembly;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoDomain *domain;\n\tguint32 *values;\n\tint i;\n\tguint32 module_index;\n\n\tassemblyb = moduleb->assemblyb;\n\tassembly = moduleb->dynamic_image;\n\tdomain = mono_object_domain (assemblyb);\n\n\t/* Emit ASSEMBLY table */\n\ttable = &assembly->tables [MONO_TABLE_ASSEMBLY];\n\talloc_table (table, 1);\n\tvalues = table->values + MONO_ASSEMBLY_SIZE;\n\tvalues [MONO_ASSEMBLY_HASH_ALG] = assemblyb->algid? assemblyb->algid: ASSEMBLY_HASH_SHA1;\n\tvalues [MONO_ASSEMBLY_NAME] = string_heap_insert_mstring (&assembly->sheap, assemblyb->name);\n\tif (assemblyb->culture) {\n\t\tvalues [MONO_ASSEMBLY_CULTURE] = string_heap_insert_mstring (&assembly->sheap, assemblyb->culture);\n\t} else {\n\t\tvalues [MONO_ASSEMBLY_CULTURE] = string_heap_insert (&assembly->sheap, \"\");\n\t}\n\tvalues [MONO_ASSEMBLY_PUBLIC_KEY] = load_public_key (assemblyb->public_key, assembly);\n\tvalues [MONO_ASSEMBLY_FLAGS] = assemblyb->flags;\n\tset_version_from_string (assemblyb->version, values);\n\n\t/* Emit FILE + EXPORTED_TYPE table */\n\tmodule_index = 0;\n\tfor (i = 0; i < mono_array_length (assemblyb->modules); ++i) {\n\t\tint j;\n\t\tMonoReflectionModuleBuilder *file_module = \n\t\t\tmono_array_get (assemblyb->modules, MonoReflectionModuleBuilder*, i);\n\t\tif (file_module != moduleb) {\n\t\t\tmono_image_fill_file_table (domain, (MonoReflectionModule*)file_module, assembly);\n\t\t\tmodule_index ++;\n\t\t\tif (file_module->types) {\n\t\t\t\tfor (j = 0; j < file_module->num_types; ++j) {\n\t\t\t\t\tMonoReflectionTypeBuilder *tb = mono_array_get (file_module->types, MonoReflectionTypeBuilder*, j);\n\t\t\t\t\tmono_image_fill_export_table (domain, tb, module_index, 0, assembly);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (assemblyb->loaded_modules) {\n\t\tfor (i = 0; i < mono_array_length (assemblyb->loaded_modules); ++i) {\n\t\t\tMonoReflectionModule *file_module = \n\t\t\t\tmono_array_get (assemblyb->loaded_modules, MonoReflectionModule*, i);\n\t\t\tmono_image_fill_file_table (domain, file_module, assembly);\n\t\t\tmodule_index ++;\n\t\t\tmono_image_fill_export_table_from_module (domain, file_module, module_index, assembly);\n\t\t}\n\t}\n\tif (assemblyb->type_forwarders)\n\t\tmono_image_fill_export_table_from_type_forwarders (assemblyb, assembly);\n\n\t/* Emit MANIFESTRESOURCE table */\n\tmodule_index = 0;\n\tfor (i = 0; i < mono_array_length (assemblyb->modules); ++i) {\n\t\tint j;\n\t\tMonoReflectionModuleBuilder *file_module = \n\t\t\tmono_array_get (assemblyb->modules, MonoReflectionModuleBuilder*, i);\n\t\t/* The table for the main module is emitted later */\n\t\tif (file_module != moduleb) {\n\t\t\tmodule_index ++;\n\t\t\tif (file_module->resources) {\n\t\t\t\tint len = mono_array_length (file_module->resources);\n\t\t\t\tfor (j = 0; j < len; ++j) {\n\t\t\t\t\tMonoReflectionResource* res = (MonoReflectionResource*)mono_array_addr (file_module->resources, MonoReflectionResource, j);\n\t\t\t\t\tassembly_add_resource_manifest (file_module, assembly, res, MONO_IMPLEMENTATION_FILE | (module_index << MONO_IMPLEMENTATION_BITS));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\t\n}\n\n#ifndef DISABLE_REFLECTION_EMIT_SAVE\n\n/*\n * mono_image_build_metadata() will fill the info in all the needed metadata tables\n * for the modulebuilder @moduleb.\n * At the end of the process, method and field tokens are fixed up and the \n * on-disk compressed metadata representation is created.\n */\nvoid\nmono_image_build_metadata (MonoReflectionModuleBuilder *moduleb)\n{\n\tMonoDynamicTable *table;\n\tMonoDynamicImage *assembly;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoDomain *domain;\n\tGPtrArray *types;\n\tguint32 *values;\n\tint i, j;\n\n\tassemblyb = moduleb->assemblyb;\n\tassembly = moduleb->dynamic_image;\n\tdomain = mono_object_domain (assemblyb);\n\n\tif (assembly->text_rva)\n\t\treturn;\n\n\tassembly->text_rva = START_TEXT_RVA;\n\n\tif (moduleb->is_main) {\n\t\tmono_image_emit_manifest (moduleb);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_TYPEDEF];\n\ttable->rows = 1; /* .<Module> */\n\ttable->next_idx++;\n\talloc_table (table, table->rows);\n\t/*\n\t * Set the first entry.\n\t */\n\tvalues = table->values + table->columns;\n\tvalues [MONO_TYPEDEF_FLAGS] = 0;\n\tvalues [MONO_TYPEDEF_NAME] = string_heap_insert (&assembly->sheap, \"<Module>\") ;\n\tvalues [MONO_TYPEDEF_NAMESPACE] = string_heap_insert (&assembly->sheap, \"\") ;\n\tvalues [MONO_TYPEDEF_EXTENDS] = 0;\n\tvalues [MONO_TYPEDEF_FIELD_LIST] = 1;\n\tvalues [MONO_TYPEDEF_METHOD_LIST] = 1;\n\n\t/* \n\t * handle global methods \n\t * FIXME: test what to do when global methods are defined in multiple modules.\n\t */\n\tif (moduleb->global_methods) {\n\t\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t\ttable->rows += mono_array_length (moduleb->global_methods);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_methods); ++i)\n\t\t\tmono_image_get_method_info (\n\t\t\t\tmono_array_get (moduleb->global_methods, MonoReflectionMethodBuilder*, i), assembly);\n\t}\n\tif (moduleb->global_fields) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELD];\n\t\ttable->rows += mono_array_length (moduleb->global_fields);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_fields); ++i)\n\t\t\tmono_image_get_field_info (\n\t\t\t\tmono_array_get (moduleb->global_fields, MonoReflectionFieldBuilder*, i), assembly);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_MODULE];\n\talloc_table (table, 1);\n\tmono_image_fill_module_table (domain, moduleb, assembly);\n\n\t/* Collect all types into a list sorted by their table_idx */\n\ttypes = g_ptr_array_new ();\n\n\tif (moduleb->types)\n\t\tfor (i = 0; i < moduleb->num_types; ++i) {\n\t\t\tMonoReflectionTypeBuilder *type = mono_array_get (moduleb->types, MonoReflectionTypeBuilder*, i);\n\t\t\tcollect_types (types, type);\n\t\t}\n\n\tg_ptr_array_sort (types, (GCompareFunc)compare_types_by_table_idx);\n\ttable = &assembly->tables [MONO_TABLE_TYPEDEF];\n\ttable->rows += types->len;\n\talloc_table (table, table->rows);\n\n\t/*\n\t * Emit type names + namespaces at one place inside the string heap,\n\t * so load_class_names () needs to touch fewer pages.\n\t */\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *tb = g_ptr_array_index (types, i);\n\t\tstring_heap_insert_mstring (&assembly->sheap, tb->nspace);\n\t}\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *tb = g_ptr_array_index (types, i);\n\t\tstring_heap_insert_mstring (&assembly->sheap, tb->name);\n\t}\n\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *type = g_ptr_array_index (types, i);\n\t\tmono_image_get_type_info (domain, type, assembly);\n\t}\n\n\t/* \n\t * table->rows is already set above and in mono_image_fill_module_table.\n\t */\n\t/* add all the custom attributes at the end, once all the indexes are stable */\n\tmono_image_add_cattrs (assembly, 1, MONO_CUSTOM_ATTR_ASSEMBLY, assemblyb->cattrs);\n\n\t/* CAS assembly permissions */\n\tif (assemblyb->permissions_minimum)\n\t\tmono_image_add_decl_security (assembly, mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1), assemblyb->permissions_minimum);\n\tif (assemblyb->permissions_optional)\n\t\tmono_image_add_decl_security (assembly, mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1), assemblyb->permissions_optional);\n\tif (assemblyb->permissions_refused)\n\t\tmono_image_add_decl_security (assembly, mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1), assemblyb->permissions_refused);\n\n\tmodule_add_cattrs (assembly, moduleb);\n\n\t/* fixup tokens */\n\tmono_g_hash_table_foreach (assembly->token_fixups, (GHFunc)fixup_method, assembly);\n\n\t/* Create the MethodImpl table.  We do this after emitting all methods so we already know\n\t * the final tokens and don't need another fixup pass. */\n\n\tif (moduleb->global_methods) {\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_methods); ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = mono_array_get (\n\t\t\t\tmoduleb->global_methods, MonoReflectionMethodBuilder*, i);\n\t\t\tmono_image_add_methodimpl (assembly, mb);\n\t\t}\n\t}\n\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *type = g_ptr_array_index (types, i);\n\t\tif (type->methods) {\n\t\t\tfor (j = 0; j < type->num_methods; ++j) {\n\t\t\t\tMonoReflectionMethodBuilder *mb = mono_array_get (\n\t\t\t\t\ttype->methods, MonoReflectionMethodBuilder*, j);\n\n\t\t\t\tmono_image_add_methodimpl (assembly, mb);\n\t\t\t}\n\t\t}\n\t}\n\n\tg_ptr_array_free (types, TRUE);\n\n\tfixup_cattrs (assembly);\n}\n\n#else /* DISABLE_REFLECTION_EMIT_SAVE */\n\nvoid\nmono_image_build_metadata (MonoReflectionModuleBuilder *moduleb)\n{\n\tg_error (\"This mono runtime was configured with --enable-minimal=reflection_emit_save, so saving of dynamic assemblies is not supported.\");\n}\n\n#endif /* DISABLE_REFLECTION_EMIT_SAVE */\n\n\ntypedef struct {\n\tguint32 import_lookup_table;\n\tguint32 timestamp;\n\tguint32 forwarder;\n\tguint32 name_rva;\n\tguint32 import_address_table_rva;\n} MonoIDT;\n\ntypedef struct {\n\tguint32 name_rva;\n\tguint32 flags;\n} MonoILT;\n\n#ifndef DISABLE_REFLECTION_EMIT\n\n/*\n * mono_image_insert_string:\n * @module: module builder object\n * @str: a string\n *\n * Insert @str into the user string stream of @module.\n */\nguint32\nmono_image_insert_string (MonoReflectionModuleBuilder *module, MonoString *str)\n{\n\tMonoDynamicImage *assembly;\n\tguint32 idx;\n\tchar buf [16];\n\tchar *b = buf;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!module->dynamic_image)\n\t\tmono_image_module_basic_init (module);\n\n\tassembly = module->dynamic_image;\n\t\n\tif (assembly->save) {\n\t\tmono_metadata_encode_value (1 | (str->length * 2), b, &b);\n\t\tidx = mono_image_add_stream_data (&assembly->us, buf, b-buf);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\t{\n\t\tchar *swapped = g_malloc (2 * mono_string_length (str));\n\t\tconst char *p = (const char*)mono_string_chars (str);\n\n\t\tswap_with_size (swapped, p, 2, mono_string_length (str));\n\t\tmono_image_add_stream_data (&assembly->us, swapped, str->length * 2);\n\t\tg_free (swapped);\n\t}\n#else\n\t\tmono_image_add_stream_data (&assembly->us, (const char*)mono_string_chars (str), str->length * 2);\n#endif\n\t\tmono_image_add_stream_data (&assembly->us, \"\", 1);\n\t} else {\n\t\tidx = assembly->us.index ++;\n\t}\n\n\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (MONO_TOKEN_STRING | idx), str);\n\n\treturn MONO_TOKEN_STRING | idx;\n}\n\nguint32\nmono_image_create_method_token (MonoDynamicImage *assembly, MonoObject *obj, MonoArray *opt_param_types)\n{\n\tMonoClass *klass;\n\tguint32 token = 0;\n\n\tklass = obj->vtable->klass;\n\tif (strcmp (klass->name, \"MonoMethod\") == 0) {\n\t\tMonoMethod *method = ((MonoReflectionMethod *)obj)->method;\n\t\tMonoMethodSignature *sig, *old;\n\t\tguint32 sig_token, parent;\n\t\tint nargs, i;\n\n\t\tg_assert (opt_param_types && (mono_method_signature (method)->sentinelpos >= 0));\n\n\t\tnargs = mono_array_length (opt_param_types);\n\t\told = mono_method_signature (method);\n\t\tsig = mono_metadata_signature_alloc ( &assembly->image, old->param_count + nargs);\n\n\t\tsig->hasthis = old->hasthis;\n\t\tsig->explicit_this = old->explicit_this;\n\t\tsig->call_convention = old->call_convention;\n\t\tsig->generic_param_count = old->generic_param_count;\n\t\tsig->param_count = old->param_count + nargs;\n\t\tsig->sentinelpos = old->param_count;\n\t\tsig->ret = old->ret;\n\n\t\tfor (i = 0; i < old->param_count; i++)\n\t\t\tsig->params [i] = old->params [i];\n\n\t\tfor (i = 0; i < nargs; i++) {\n\t\t\tMonoReflectionType *rt = mono_array_get (opt_param_types, MonoReflectionType *, i);\n\t\t\tsig->params [old->param_count + i] = mono_reflection_type_get_handle (rt);\n\t\t}\n\n\t\tparent = mono_image_typedef_or_ref (assembly, &method->klass->byval_arg);\n\t\tg_assert ((parent & MONO_TYPEDEFORREF_MASK) == MONO_MEMBERREF_PARENT_TYPEREF);\n\t\tparent >>= MONO_TYPEDEFORREF_BITS;\n\n\t\tparent <<= MONO_MEMBERREF_PARENT_BITS;\n\t\tparent |= MONO_MEMBERREF_PARENT_TYPEREF;\n\n\t\tsig_token = method_encode_signature (assembly, sig);\n\t\ttoken = mono_image_get_varargs_method_token (assembly, parent, method->name, sig_token);\n\t} else if (strcmp (klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder *)obj;\n\t\tReflectionMethodBuilder rmb;\n\t\tguint32 parent, sig;\n\t\tchar *name;\n\n\t\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\t\trmb.opt_types = opt_param_types;\n\n\t\tsig = method_builder_encode_signature (assembly, &rmb);\n\n\t\tparent = mono_image_create_token (assembly, obj, TRUE, TRUE);\n\t\tg_assert (mono_metadata_token_table (parent) == MONO_TABLE_METHOD);\n\n\t\tparent = mono_metadata_token_index (parent) << MONO_MEMBERREF_PARENT_BITS;\n\t\tparent |= MONO_MEMBERREF_PARENT_METHODDEF;\n\n\t\tname = mono_string_to_utf8 (rmb.name);\n\t\ttoken = mono_image_get_varargs_method_token (\n\t\t\tassembly, parent, name, sig);\n\t\tg_free (name);\n\t} else {\n\t\tg_error (\"requested method token for %s\\n\", klass->name);\n\t}\n\n\treturn token;\n}\n\n/*\n * mono_image_create_token:\n * @assembly: a dynamic assembly\n * @obj:\n * @register_token: Whenever to register the token in the assembly->tokens hash. \n *\n * Get a token to insert in the IL code stream for the given MemberInfo.\n * The metadata emission routines need to pass FALSE as REGISTER_TOKEN, since by that time, \n * the table_idx-es were recomputed, so registering the token would overwrite an existing \n * entry.\n */\nguint32\nmono_image_create_token (MonoDynamicImage *assembly, MonoObject *obj, \n\t\t\t\t\t\t gboolean create_methodspec, gboolean register_token)\n{\n\tMonoClass *klass;\n\tguint32 token = 0;\n\n\tklass = obj->vtable->klass;\n\n\t/* Check for user defined reflection objects */\n\t/* TypeDelegator is the only corlib type which doesn't look like a MonoReflectionType */\n\tif (klass->image != mono_defaults.corlib || (strcmp (klass->name, \"TypeDelegator\") == 0))\n\t\tmono_raise_exception (mono_get_exception_not_supported (\"User defined subclasses of System.Type are not yet supported\")); \\\n\n\tif (strcmp (klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder *)obj;\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)mb->type;\n\n\t\tif (tb->module->dynamic_image == assembly && !tb->generic_params && !mb->generic_params)\n\t\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t\telse\n\t\t\ttoken = mono_image_get_methodbuilder_token (assembly, mb, create_methodspec);\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, mono_string_to_utf8 (mb->name));*/\n\t} else if (strcmp (klass->name, \"ConstructorBuilder\") == 0) {\n\t\tMonoReflectionCtorBuilder *mb = (MonoReflectionCtorBuilder *)obj;\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)mb->type;\n\n\t\tif (tb->module->dynamic_image == assembly && !tb->generic_params)\n\t\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t\telse\n\t\t\ttoken = mono_image_get_ctorbuilder_token (assembly, mb);\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, mono_string_to_utf8 (mb->name));*/\n\t} else if (strcmp (klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder *)obj;\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)fb->typeb;\n\t\tif (tb->generic_params) {\n\t\t\ttoken = mono_image_get_generic_field_token (assembly, fb);\n\t\t} else {\n\t\t\ttoken = fb->table_idx | MONO_TOKEN_FIELD_DEF;\n\t\t}\n\t} else if (strcmp (klass->name, \"TypeBuilder\") == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)obj;\n\t\ttoken = tb->table_idx | MONO_TOKEN_TYPE_DEF;\n\t} else if (strcmp (klass->name, \"MonoType\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\tMonoClass *mc = mono_class_from_mono_type (type);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref_full (assembly, type, mc->generic_container == NULL));\n\t} else if (strcmp (klass->name, \"GenericTypeParameterBuilder\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref (assembly, type));\n\t} else if (strcmp (klass->name, \"MonoGenericClass\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref (assembly, type));\n\t} else if (strcmp (klass->name, \"MonoCMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericCMethod\") == 0) {\n\t\tMonoReflectionMethod *m = (MonoReflectionMethod *)obj;\n\t\tif (m->method->is_inflated) {\n\t\t\tif (create_methodspec)\n\t\t\t\ttoken = mono_image_get_methodspec_token (assembly, m->method);\n\t\t\telse\n\t\t\t\ttoken = mono_image_get_inflated_method_token (assembly, m->method);\n\t\t} else if ((m->method->klass->image == &assembly->image) &&\n\t\t\t !m->method->klass->generic_class) {\n\t\t\tstatic guint32 method_table_idx = 0xffffff;\n\t\t\tif (m->method->klass->wastypebuilder) {\n\t\t\t\t/* we use the same token as the one that was assigned\n\t\t\t\t * to the Methodbuilder.\n\t\t\t\t * FIXME: do the equivalent for Fields.\n\t\t\t\t */\n\t\t\t\ttoken = m->method->token;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Each token should have a unique index, but the indexes are\n\t\t\t\t * assigned by managed code, so we don't know about them. An\n\t\t\t\t * easy solution is to count backwards...\n\t\t\t\t */\n\t\t\t\tmethod_table_idx --;\n\t\t\t\ttoken = MONO_TOKEN_METHOD_DEF | method_table_idx;\n\t\t\t}\n\t\t} else {\n\t\t\ttoken = mono_image_get_methodref_token (assembly, m->method, create_methodspec);\n\t\t}\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, m->method->name);*/\n\t} else if (strcmp (klass->name, \"MonoField\") == 0) {\n\t\tMonoReflectionField *f = (MonoReflectionField *)obj;\n\t\tif ((f->field->parent->image == &assembly->image) && !is_field_on_inst (f->field)) {\n\t\t\tstatic guint32 field_table_idx = 0xffffff;\n\t\t\tfield_table_idx --;\n\t\t\ttoken = MONO_TOKEN_FIELD_DEF | field_table_idx;\n\t\t} else {\n\t\t\ttoken = mono_image_get_fieldref_token (assembly, f);\n\t\t}\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, f->field->name);*/\n\t} else if (strcmp (klass->name, \"MonoArrayMethod\") == 0) {\n\t\tMonoReflectionArrayMethod *m = (MonoReflectionArrayMethod *)obj;\n\t\ttoken = mono_image_get_array_token (assembly, m);\n\t} else if (strcmp (klass->name, \"SignatureHelper\") == 0) {\n\t\tMonoReflectionSigHelper *s = (MonoReflectionSigHelper*)obj;\n\t\ttoken = MONO_TOKEN_SIGNATURE | mono_image_get_sighelper_token (assembly, s);\n\t} else if (strcmp (klass->name, \"EnumBuilder\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref (assembly, type));\n\t} else if (strcmp (klass->name, \"FieldOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionFieldOnTypeBuilderInst *f = (MonoReflectionFieldOnTypeBuilderInst*)obj;\n\t\ttoken = mono_image_get_field_on_inst_token (assembly, f);\n\t} else if (strcmp (klass->name, \"ConstructorOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionCtorOnTypeBuilderInst *c = (MonoReflectionCtorOnTypeBuilderInst*)obj;\n\t\ttoken = mono_image_get_ctor_on_inst_token (assembly, c, create_methodspec);\n\t} else if (strcmp (klass->name, \"MethodOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionMethodOnTypeBuilderInst *m = (MonoReflectionMethodOnTypeBuilderInst*)obj;\n\t\ttoken = mono_image_get_method_on_inst_token (assembly, m, create_methodspec);\n\t} else if (is_sre_array (klass) || is_sre_byref (klass) || is_sre_pointer (klass)) {\n\t\tMonoReflectionType *type = (MonoReflectionType *)obj;\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\t\tmono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle (type)));\n\t} else {\n\t\tg_error (\"requested token for %s\\n\", klass->name);\n\t}\n\n\tif (register_token)\n\t\tmono_image_register_token (assembly, token, obj);\n\n\treturn token;\n}\n\n/*\n * mono_image_register_token:\n *\n *   Register the TOKEN->OBJ mapping in the mapping table in ASSEMBLY. This is required for\n * the Module.ResolveXXXToken () methods to work.\n */\nvoid\nmono_image_register_token (MonoDynamicImage *assembly, guint32 token, MonoObject *obj)\n{\n\tMonoObject *prev = mono_g_hash_table_lookup (assembly->tokens, GUINT_TO_POINTER (token));\n\tif (prev) {\n\t\t/* There could be multiple MethodInfo objects with the same token */\n\t\t//g_assert (prev == obj);\n\t} else {\n\t\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (token), obj);\n\t}\n}\n\nstatic MonoDynamicImage*\ncreate_dynamic_mono_image (MonoDynamicAssembly *assembly, char *assembly_name, char *module_name)\n{\n\tstatic const guchar entrycode [16] = {0xff, 0x25, 0};\n\tMonoDynamicImage *image;\n\tint i;\n\n\tconst char *version;\n\n\tif (!strcmp (mono_get_runtime_info ()->framework_version, \"2.1\"))\n\t\tversion = \"v2.0.50727\"; /* HACK: SL 2 enforces the .net 2 metadata version */\n\telse\n\t\tversion = mono_get_runtime_info ()->runtime_version;\n\n#if HAVE_BOEHM_GC\n\timage = GC_MALLOC (sizeof (MonoDynamicImage));\n#else\n\timage = g_new0 (MonoDynamicImage, 1);\n#endif\n\t\n\tmono_profiler_module_event (&image->image, MONO_PROFILE_START_LOAD);\n\t\n\t/*g_print (\"created image %p\\n\", image);*/\n\t/* keep in sync with image.c */\n\timage->image.name = assembly_name;\n\timage->image.assembly_name = image->image.name; /* they may be different */\n\timage->image.module_name = module_name;\n\timage->image.version = g_strdup (version);\n\timage->image.md_version_major = 1;\n\timage->image.md_version_minor = 1;\n\timage->image.dynamic = TRUE;\n\n\timage->image.references = g_new0 (MonoAssembly*, 1);\n\timage->image.references [0] = NULL;\n\n\tmono_image_init (&image->image);\n\n\timage->token_fixups = mono_g_hash_table_new_type ((GHashFunc)mono_object_hash, NULL, MONO_HASH_KEY_GC);\n\timage->method_to_table_idx = g_hash_table_new (NULL, NULL);\n\timage->field_to_table_idx = g_hash_table_new (NULL, NULL);\n\timage->method_aux_hash = g_hash_table_new (NULL, NULL);\n\timage->handleref = g_hash_table_new (NULL, NULL);\n\timage->tokens = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_VALUE_GC);\n\timage->generic_def_objects = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_VALUE_GC);\n\timage->methodspec = mono_g_hash_table_new_type ((GHashFunc)mono_object_hash, NULL, MONO_HASH_KEY_GC);\n\timage->typespec = g_hash_table_new ((GHashFunc)mono_metadata_type_hash, (GCompareFunc)mono_metadata_type_equal);\n\timage->typeref = g_hash_table_new ((GHashFunc)mono_metadata_type_hash, (GCompareFunc)mono_metadata_type_equal);\n\timage->blob_cache = g_hash_table_new ((GHashFunc)mono_blob_entry_hash, (GCompareFunc)mono_blob_entry_equal);\n\timage->gen_params = g_ptr_array_new ();\n\n\t/*g_print (\"string heap create for image %p (%s)\\n\", image, module_name);*/\n\tstring_heap_init (&image->sheap);\n\tmono_image_add_stream_data (&image->us, \"\", 1);\n\tadd_to_blob_cached (image, (char*) \"\", 1, NULL, 0);\n\t/* import tables... */\n\tmono_image_add_stream_data (&image->code, (char*)entrycode, sizeof (entrycode));\n\timage->iat_offset = mono_image_add_stream_zero (&image->code, 8); /* two IAT entries */\n\timage->idt_offset = mono_image_add_stream_zero (&image->code, 2 * sizeof (MonoIDT)); /* two IDT entries */\n\timage->imp_names_offset = mono_image_add_stream_zero (&image->code, 2); /* flags for name entry */\n\tmono_image_add_stream_data (&image->code, \"_CorExeMain\", 12);\n\tmono_image_add_stream_data (&image->code, \"mscoree.dll\", 12);\n\timage->ilt_offset = mono_image_add_stream_zero (&image->code, 8); /* two ILT entries */\n\tstream_data_align (&image->code);\n\n\timage->cli_header_offset = mono_image_add_stream_zero (&image->code, sizeof (MonoCLIHeader));\n\n\tfor (i=0; i < MONO_TABLE_NUM; ++i) {\n\t\timage->tables [i].next_idx = 1;\n\t\timage->tables [i].columns = table_sizes [i];\n\t}\n\n\timage->image.assembly = (MonoAssembly*)assembly;\n\timage->run = assembly->run;\n\timage->save = assembly->save;\n\timage->pe_kind = 0x1; /* ILOnly */\n\timage->machine = 0x14c; /* I386 */\n\t\n\tmono_profiler_module_loaded (&image->image, MONO_PROFILE_OK);\n\n\treturn image;\n}\n#endif\n\nstatic void\nfree_blob_cache_entry (gpointer key, gpointer val, gpointer user_data)\n{\n\tg_free (key);\n}\n\nvoid\nmono_dynamic_image_free (MonoDynamicImage *image)\n{\n\tMonoDynamicImage *di = image;\n\tGList *list;\n\tint i;\n\n\tif (di->methodspec)\n\t\tmono_g_hash_table_destroy (di->methodspec);\n\tif (di->typespec)\n\t\tg_hash_table_destroy (di->typespec);\n\tif (di->typeref)\n\t\tg_hash_table_destroy (di->typeref);\n\tif (di->handleref)\n\t\tg_hash_table_destroy (di->handleref);\n\tif (di->tokens)\n\t\tmono_g_hash_table_destroy (di->tokens);\n\tif (di->generic_def_objects)\n\t\tmono_g_hash_table_destroy (di->generic_def_objects);\n\tif (di->blob_cache) {\n\t\tg_hash_table_foreach (di->blob_cache, free_blob_cache_entry, NULL);\n\t\tg_hash_table_destroy (di->blob_cache);\n\t}\n\tif (di->standalonesig_cache)\n\t\tg_hash_table_destroy (di->standalonesig_cache);\n\tfor (list = di->array_methods; list; list = list->next) {\n\t\tArrayMethod *am = (ArrayMethod *)list->data;\n\t\tg_free (am->sig);\n\t\tg_free (am->name);\n\t\tg_free (am);\n\t}\n\tg_list_free (di->array_methods);\n\tif (di->gen_params) {\n\t\tfor (i = 0; i < di->gen_params->len; i++) {\n\t\t\tGenericParamTableEntry *entry = g_ptr_array_index (di->gen_params, i);\n\t\t\tif (entry->gparam->type.type) {\n\t\t\t\tMonoGenericParam *param = entry->gparam->type.type->data.generic_param;\n\t\t\t\tg_free ((char*)mono_generic_param_info (param)->name);\n\t\t\t\tg_free (param);\n\t\t\t}\n\t\t\tg_free (entry);\n\t\t}\n\t \tg_ptr_array_free (di->gen_params, TRUE);\n\t}\n\tif (di->token_fixups)\n\t\tmono_g_hash_table_destroy (di->token_fixups);\n\tif (di->method_to_table_idx)\n\t\tg_hash_table_destroy (di->method_to_table_idx);\n\tif (di->field_to_table_idx)\n\t\tg_hash_table_destroy (di->field_to_table_idx);\n\tif (di->method_aux_hash)\n\t\tg_hash_table_destroy (di->method_aux_hash);\n\tg_free (di->strong_name);\n\tg_free (di->win32_res);\n\tif (di->public_key)\n\t\tg_free (di->public_key);\n\n\t/*g_print (\"string heap destroy for image %p\\n\", di);*/\n\tmono_dynamic_stream_reset (&di->sheap);\n\tmono_dynamic_stream_reset (&di->code);\n\tmono_dynamic_stream_reset (&di->resources);\n\tmono_dynamic_stream_reset (&di->us);\n\tmono_dynamic_stream_reset (&di->blob);\n\tmono_dynamic_stream_reset (&di->tstream);\n\tmono_dynamic_stream_reset (&di->guid);\n\tfor (i = 0; i < MONO_TABLE_NUM; ++i) {\n\t\tg_free (di->tables [i].values);\n\t}\n}\t\n\n#ifndef DISABLE_REFLECTION_EMIT\n\n/*\n * mono_image_basic_init:\n * @assembly: an assembly builder object\n *\n * Create the MonoImage that represents the assembly builder and setup some\n * of the helper hash table and the basic metadata streams.\n */\nvoid\nmono_image_basic_init (MonoReflectionAssemblyBuilder *assemblyb)\n{\n\tMonoDynamicAssembly *assembly;\n\tMonoDynamicImage *image;\n\tMonoDomain *domain = mono_object_domain (assemblyb);\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (assemblyb->dynamic_assembly)\n\t\treturn;\n\n#if HAVE_BOEHM_GC\n\tassembly = assemblyb->dynamic_assembly = GC_MALLOC (sizeof (MonoDynamicAssembly));\n#else\n\tassembly = assemblyb->dynamic_assembly = g_new0 (MonoDynamicAssembly, 1);\n#endif\n\n\tmono_profiler_assembly_event (&assembly->assembly, MONO_PROFILE_START_LOAD);\n\t\n\tassembly->assembly.ref_count = 1;\n\tassembly->assembly.dynamic = TRUE;\n\tassembly->assembly.corlib_internal = assemblyb->corlib_internal;\n\tassemblyb->assembly.assembly = (MonoAssembly*)assembly;\n\tassembly->assembly.basedir = mono_string_to_utf8 (assemblyb->dir);\n\tif (assemblyb->culture)\n\t\tassembly->assembly.aname.culture = mono_string_to_utf8 (assemblyb->culture);\n\telse\n\t\tassembly->assembly.aname.culture = g_strdup (\"\");\n\n        if (assemblyb->version) {\n\t\t\tchar *vstr = mono_string_to_utf8 (assemblyb->version);\n\t\t\tchar **version = g_strsplit (vstr, \".\", 4);\n\t\t\tchar **parts = version;\n\t\t\tassembly->assembly.aname.major = atoi (*parts++);\n\t\t\tassembly->assembly.aname.minor = atoi (*parts++);\n\t\t\tassembly->assembly.aname.build = *parts != NULL ? atoi (*parts++) : 0;\n\t\t\tassembly->assembly.aname.revision = *parts != NULL ? atoi (*parts) : 0;\n\n\t\t\tg_strfreev (version);\n\t\t\tg_free (vstr);\n        } else {\n\t\t\tassembly->assembly.aname.major = 0;\n\t\t\tassembly->assembly.aname.minor = 0;\n\t\t\tassembly->assembly.aname.build = 0;\n\t\t\tassembly->assembly.aname.revision = 0;\n        }\n\n\tassembly->run = assemblyb->access != 2;\n\tassembly->save = assemblyb->access != 1;\n\tassembly->domain = domain;\n\n\timage = create_dynamic_mono_image (assembly, mono_string_to_utf8 (assemblyb->name), g_strdup (\"RefEmit_YouForgotToDefineAModule\"));\n\timage->initial_image = TRUE;\n\tassembly->assembly.aname.name = image->image.name;\n\tassembly->assembly.image = &image->image;\n\tif (assemblyb->pktoken && assemblyb->pktoken->max_length) {\n\t\t/* -1 to correct for the trailing NULL byte */\n\t\tif (assemblyb->pktoken->max_length != MONO_PUBLIC_KEY_TOKEN_LENGTH - 1) {\n\t\t\tg_error (\"Public key token length invalid for assembly %s: %i\", assembly->assembly.aname.name, assemblyb->pktoken->max_length);\n\t\t}\n\t\tmemcpy (&assembly->assembly.aname.public_key_token, mono_array_addr (assemblyb->pktoken, guint8, 0), assemblyb->pktoken->max_length);\t\t\n\t}\n\n\tmono_domain_assemblies_lock (domain);\n\tdomain->domain_assemblies = g_slist_prepend (domain->domain_assemblies, assembly);\n\tmono_domain_assemblies_unlock (domain);\n\n\tregister_assembly (mono_object_domain (assemblyb), &assemblyb->assembly, &assembly->assembly);\n\t\n\tmono_profiler_assembly_loaded (&assembly->assembly, MONO_PROFILE_OK);\n\t\n\tmono_assembly_invoke_load_hook ((MonoAssembly*)assembly);\n}\n\n#endif /* !DISABLE_REFLECTION_EMIT */\n\n#ifndef DISABLE_REFLECTION_EMIT_SAVE\n\nstatic int\ncalc_section_size (MonoDynamicImage *assembly)\n{\n\tint nsections = 0;\n\n\t/* alignment constraints */\n\tmono_image_add_stream_zero (&assembly->code, 4 - (assembly->code.index % 4));\n\tg_assert ((assembly->code.index % 4) == 0);\n\tassembly->meta_size += 3;\n\tassembly->meta_size &= ~3;\n\tmono_image_add_stream_zero (&assembly->resources, 4 - (assembly->resources.index % 4));\n\tg_assert ((assembly->resources.index % 4) == 0);\n\n\tassembly->sections [MONO_SECTION_TEXT].size = assembly->meta_size + assembly->code.index + assembly->resources.index + assembly->strong_name_size;\n\tassembly->sections [MONO_SECTION_TEXT].attrs = SECT_FLAGS_HAS_CODE | SECT_FLAGS_MEM_EXECUTE | SECT_FLAGS_MEM_READ;\n\tnsections++;\n\n\tif (assembly->win32_res) {\n\t\tguint32 res_size = (assembly->win32_res_size + 3) & ~3;\n\n\t\tassembly->sections [MONO_SECTION_RSRC].size = res_size;\n\t\tassembly->sections [MONO_SECTION_RSRC].attrs = SECT_FLAGS_HAS_INITIALIZED_DATA | SECT_FLAGS_MEM_READ;\n\t\tnsections++;\n\t}\n\n\tassembly->sections [MONO_SECTION_RELOC].size = 12;\n\tassembly->sections [MONO_SECTION_RELOC].attrs = SECT_FLAGS_MEM_READ | SECT_FLAGS_MEM_DISCARDABLE | SECT_FLAGS_HAS_INITIALIZED_DATA;\n\tnsections++;\n\n\treturn nsections;\n}\n\ntypedef struct {\n\tguint32 id;\n\tguint32 offset;\n\tGSList *children;\n\tMonoReflectionWin32Resource *win32_res; /* Only for leaf nodes */\n} ResTreeNode;\n\nstatic int\nresource_tree_compare_by_id (gconstpointer a, gconstpointer b)\n{\n\tResTreeNode *t1 = (ResTreeNode*)a;\n\tResTreeNode *t2 = (ResTreeNode*)b;\n\n\treturn t1->id - t2->id;\n}\n\n/*\n * resource_tree_create:\n *\n *  Organize the resources into a resource tree.\n */\nstatic ResTreeNode *\nresource_tree_create (MonoArray *win32_resources)\n{\n\tResTreeNode *tree, *res_node, *type_node, *lang_node;\n\tGSList *l;\n\tint i;\n\n\ttree = g_new0 (ResTreeNode, 1);\n\t\n\tfor (i = 0; i < mono_array_length (win32_resources); ++i) {\n\t\tMonoReflectionWin32Resource *win32_res =\n\t\t\t(MonoReflectionWin32Resource*)mono_array_addr (win32_resources, MonoReflectionWin32Resource, i);\n\n\t\t/* Create node */\n\n\t\t/* FIXME: BUG: this stores managed references in unmanaged memory */\n\t\tlang_node = g_new0 (ResTreeNode, 1);\n\t\tlang_node->id = win32_res->lang_id;\n\t\tlang_node->win32_res = win32_res;\n\n\t\t/* Create type node if neccesary */\n\t\ttype_node = NULL;\n\t\tfor (l = tree->children; l; l = l->next)\n\t\t\tif (((ResTreeNode*)(l->data))->id == win32_res->res_type) {\n\t\t\t\ttype_node = (ResTreeNode*)l->data;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!type_node) {\n\t\t\ttype_node = g_new0 (ResTreeNode, 1);\n\t\t\ttype_node->id = win32_res->res_type;\n\n\t\t\t/* \n\t\t\t * The resource types have to be sorted otherwise\n\t\t\t * Windows Explorer can't display the version information.\n\t\t\t */\n\t\t\ttree->children = g_slist_insert_sorted (tree->children, \n\t\t\t\ttype_node, resource_tree_compare_by_id);\n\t\t}\n\n\t\t/* Create res node if neccesary */\n\t\tres_node = NULL;\n\t\tfor (l = type_node->children; l; l = l->next)\n\t\t\tif (((ResTreeNode*)(l->data))->id == win32_res->res_id) {\n\t\t\t\tres_node = (ResTreeNode*)l->data;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!res_node) {\n\t\t\tres_node = g_new0 (ResTreeNode, 1);\n\t\t\tres_node->id = win32_res->res_id;\n\t\t\ttype_node->children = g_slist_append (type_node->children, res_node);\n\t\t}\n\n\t\tres_node->children = g_slist_append (res_node->children, lang_node);\n\t}\n\n\treturn tree;\n}\n\n/*\n * resource_tree_encode:\n * \n *   Encode the resource tree into the format used in the PE file.\n */\nstatic void\nresource_tree_encode (ResTreeNode *node, char *begin, char *p, char **endbuf)\n{\n\tchar *entries;\n\tMonoPEResourceDir dir;\n\tMonoPEResourceDirEntry dir_entry;\n\tMonoPEResourceDataEntry data_entry;\n\tGSList *l;\n\tguint32 res_id_entries;\n\n\t/*\n\t * For the format of the resource directory, see the article\n\t * \"An In-Depth Look into the Win32 Portable Executable File Format\" by\n\t * Matt Pietrek\n\t */\n\n\tmemset (&dir, 0, sizeof (dir));\n\tmemset (&dir_entry, 0, sizeof (dir_entry));\n\tmemset (&data_entry, 0, sizeof (data_entry));\n\n\tg_assert (sizeof (dir) == 16);\n\tg_assert (sizeof (dir_entry) == 8);\n\tg_assert (sizeof (data_entry) == 16);\n\n\tnode->offset = p - begin;\n\n\t/* IMAGE_RESOURCE_DIRECTORY */\n\tres_id_entries = g_slist_length (node->children);\n\tdir.res_id_entries = GUINT16_TO_LE (res_id_entries);\n\n\tmemcpy (p, &dir, sizeof (dir));\n\tp += sizeof (dir);\n\n\t/* Reserve space for entries */\n\tentries = p;\n\tp += sizeof (dir_entry) * res_id_entries;\n\n\t/* Write children */\n\tfor (l = node->children; l; l = l->next) {\n\t\tResTreeNode *child = (ResTreeNode*)l->data;\n\n\t\tif (child->win32_res) {\n\t\t\tguint32 size;\n\n\t\t\tchild->offset = p - begin;\n\n\t\t\t/* IMAGE_RESOURCE_DATA_ENTRY */\n\t\t\tdata_entry.rde_data_offset = GUINT32_TO_LE (p - begin + sizeof (data_entry));\n\t\t\tsize = mono_array_length (child->win32_res->res_data);\n\t\t\tdata_entry.rde_size = GUINT32_TO_LE (size);\n\n\t\t\tmemcpy (p, &data_entry, sizeof (data_entry));\n\t\t\tp += sizeof (data_entry);\n\n\t\t\tmemcpy (p, mono_array_addr (child->win32_res->res_data, char, 0), size);\n\t\t\tp += size;\n\t\t} else {\n\t\t\tresource_tree_encode (child, begin, p, &p);\n\t\t}\n\t}\n\n\t/* IMAGE_RESOURCE_ENTRY */\n\tfor (l = node->children; l; l = l->next) {\n\t\tResTreeNode *child = (ResTreeNode*)l->data;\n\n\t\tMONO_PE_RES_DIR_ENTRY_SET_NAME (dir_entry, FALSE, child->id);\n\t\tMONO_PE_RES_DIR_ENTRY_SET_DIR (dir_entry, !child->win32_res, child->offset);\n\n\t\tmemcpy (entries, &dir_entry, sizeof (dir_entry));\n\t\tentries += sizeof (dir_entry);\n\t}\n\n\t*endbuf = p;\n}\n\nstatic void\nresource_tree_free (ResTreeNode * node)\n{\n\tGSList * list;\n\tfor (list = node->children; list; list = list->next)\n\t\tresource_tree_free ((ResTreeNode*)list->data);\n\tg_slist_free(node->children);\n\tg_free (node);\n}\n\nstatic void\nassembly_add_win32_resources (MonoDynamicImage *assembly, MonoReflectionAssemblyBuilder *assemblyb)\n{\n\tchar *buf;\n\tchar *p;\n\tguint32 size, i;\n\tMonoReflectionWin32Resource *win32_res;\n\tResTreeNode *tree;\n\n\tif (!assemblyb->win32_resources)\n\t\treturn;\n\n\t/*\n\t * Resources are stored in a three level tree inside the PE file.\n\t * - level one contains a node for each type of resource\n\t * - level two contains a node for each resource\n\t * - level three contains a node for each instance of a resource for a\n\t *   specific language.\n\t */\n\n\ttree = resource_tree_create (assemblyb->win32_resources);\n\n\t/* Estimate the size of the encoded tree */\n\tsize = 0;\n\tfor (i = 0; i < mono_array_length (assemblyb->win32_resources); ++i) {\n\t\twin32_res = (MonoReflectionWin32Resource*)mono_array_addr (assemblyb->win32_resources, MonoReflectionWin32Resource, i);\n\t\tsize += mono_array_length (win32_res->res_data);\n\t}\n\t/* Directory structure */\n\tsize += mono_array_length (assemblyb->win32_resources) * 256;\n\tp = buf = g_malloc (size);\n\n\tresource_tree_encode (tree, p, p, &p);\n\n\tg_assert (p - buf <= size);\n\n\tassembly->win32_res = g_malloc (p - buf);\n\tassembly->win32_res_size = p - buf;\n\tmemcpy (assembly->win32_res, buf, p - buf);\n\n\tg_free (buf);\n\tresource_tree_free (tree);\n}\n\nstatic void\nfixup_resource_directory (char *res_section, char *p, guint32 rva)\n{\n\tMonoPEResourceDir *dir = (MonoPEResourceDir*)p;\n\tint i;\n\n\tp += sizeof (MonoPEResourceDir);\n\tfor (i = 0; i < GUINT16_FROM_LE (dir->res_named_entries) + GUINT16_FROM_LE (dir->res_id_entries); ++i) {\n\t\tMonoPEResourceDirEntry *dir_entry = (MonoPEResourceDirEntry*)p;\n\t\tchar *child = res_section + MONO_PE_RES_DIR_ENTRY_DIR_OFFSET (*dir_entry);\n\t\tif (MONO_PE_RES_DIR_ENTRY_IS_DIR (*dir_entry)) {\n\t\t\tfixup_resource_directory (res_section, child, rva);\n\t\t} else {\n\t\t\tMonoPEResourceDataEntry *data_entry = (MonoPEResourceDataEntry*)child;\n\t\t\tdata_entry->rde_data_offset = GUINT32_TO_LE (GUINT32_FROM_LE (data_entry->rde_data_offset) + rva);\n\t\t}\n\n\t\tp += sizeof (MonoPEResourceDirEntry);\n\t}\n}\n\nstatic void\nchecked_write_file (HANDLE f, gconstpointer buffer, guint32 numbytes)\n{\n\tguint32 dummy;\n\tif (!WriteFile (f, buffer, numbytes, &dummy, NULL))\n\t\tg_error (\"WriteFile returned %d\\n\", GetLastError ());\n}\n\n/*\n * mono_image_create_pefile:\n * @mb: a module builder object\n * \n * This function creates the PE-COFF header, the image sections, the CLI header  * etc. all the data is written in\n * assembly->pefile where it can be easily retrieved later in chunks.\n */\nvoid\nmono_image_create_pefile (MonoReflectionModuleBuilder *mb, HANDLE file)\n{\n\tMonoMSDOSHeader *msdos;\n\tMonoDotNetHeader *header;\n\tMonoSectionTable *section;\n\tMonoCLIHeader *cli_header;\n\tguint32 size, image_size, virtual_base, text_offset;\n\tguint32 header_start, section_start, file_offset, virtual_offset;\n\tMonoDynamicImage *assembly;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoDynamicStream pefile_stream = {0};\n\tMonoDynamicStream *pefile = &pefile_stream;\n\tint i, nsections;\n\tguint32 *rva, value;\n\tguchar *p;\n\tstatic const unsigned char msheader[] = {\n\t\t0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00,  0x04, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,\n\t\t0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,\n\t\t0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd,  0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21, 0x54, 0x68,\n\t\t0x69, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x67, 0x72,  0x61, 0x6d, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f,\n\t\t0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6e,  0x20, 0x69, 0x6e, 0x20, 0x44, 0x4f, 0x53, 0x20,\n\t\t0x6d, 0x6f, 0x64, 0x65, 0x2e, 0x0d, 0x0d, 0x0a,  0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\n\tassemblyb = mb->assemblyb;\n\n\tmono_image_basic_init (assemblyb);\n\tassembly = mb->dynamic_image;\n\n\tassembly->pe_kind = assemblyb->pe_kind;\n\tassembly->machine = assemblyb->machine;\n\t((MonoDynamicImage*)assemblyb->dynamic_assembly->assembly.image)->pe_kind = assemblyb->pe_kind;\n\t((MonoDynamicImage*)assemblyb->dynamic_assembly->assembly.image)->machine = assemblyb->machine;\n\t\n\tmono_image_build_metadata (mb);\n\n\tif (mb->is_main && assemblyb->resources) {\n\t\tint len = mono_array_length (assemblyb->resources);\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tassembly_add_resource (mb, assembly, (MonoReflectionResource*)mono_array_addr (assemblyb->resources, MonoReflectionResource, i));\n\t}\n\n\tif (mb->resources) {\n\t\tint len = mono_array_length (mb->resources);\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tassembly_add_resource (mb, assembly, (MonoReflectionResource*)mono_array_addr (mb->resources, MonoReflectionResource, i));\n\t}\n\n\tbuild_compressed_metadata (assembly);\n\n\tif (mb->is_main)\n\t\tassembly_add_win32_resources (assembly, assemblyb);\n\n\tnsections = calc_section_size (assembly);\n\t\n\t/* The DOS header and stub */\n\tg_assert (sizeof (MonoMSDOSHeader) == sizeof (msheader));\n\tmono_image_add_stream_data (pefile, (char*)msheader, sizeof (msheader));\n\n\t/* the dotnet header */\n\theader_start = mono_image_add_stream_zero (pefile, sizeof (MonoDotNetHeader));\n\n\t/* the section tables */\n\tsection_start = mono_image_add_stream_zero (pefile, sizeof (MonoSectionTable) * nsections);\n\n\tfile_offset = section_start + sizeof (MonoSectionTable) * nsections;\n\tvirtual_offset = VIRT_ALIGN;\n\timage_size = 0;\n\n\tfor (i = 0; i < MONO_SECTION_MAX; ++i) {\n\t\tif (!assembly->sections [i].size)\n\t\t\tcontinue;\n\t\t/* align offsets */\n\t\tfile_offset += FILE_ALIGN - 1;\n\t\tfile_offset &= ~(FILE_ALIGN - 1);\n\t\tvirtual_offset += VIRT_ALIGN - 1;\n\t\tvirtual_offset &= ~(VIRT_ALIGN - 1);\n\n\t\tassembly->sections [i].offset = file_offset;\n\t\tassembly->sections [i].rva = virtual_offset;\n\n\t\tfile_offset += assembly->sections [i].size;\n\t\tvirtual_offset += assembly->sections [i].size;\n\t\timage_size += (assembly->sections [i].size + VIRT_ALIGN - 1) & ~(VIRT_ALIGN - 1);\n\t}\n\n\tfile_offset += FILE_ALIGN - 1;\n\tfile_offset &= ~(FILE_ALIGN - 1);\n\n\timage_size += section_start + sizeof (MonoSectionTable) * nsections;\n\n\t/* back-patch info */\n\tmsdos = (MonoMSDOSHeader*)pefile->data;\n\tmsdos->pe_offset = GUINT32_FROM_LE (sizeof (MonoMSDOSHeader));\n\n\theader = (MonoDotNetHeader*)(pefile->data + header_start);\n\theader->pesig [0] = 'P';\n\theader->pesig [1] = 'E';\n\t\n\theader->coff.coff_machine = GUINT16_FROM_LE (assemblyb->machine);\n\theader->coff.coff_sections = GUINT16_FROM_LE (nsections);\n\theader->coff.coff_time = GUINT32_FROM_LE (time (NULL));\n\theader->coff.coff_opt_header_size = GUINT16_FROM_LE (sizeof (MonoDotNetHeader) - sizeof (MonoCOFFHeader) - 4);\n\tif (assemblyb->pekind == 1) {\n\t\t/* it's a dll */\n\t\theader->coff.coff_attributes = GUINT16_FROM_LE (0x210e);\n\t} else {\n\t\t/* it's an exe */\n\t\theader->coff.coff_attributes = GUINT16_FROM_LE (0x010e);\n\t}\n\n\tvirtual_base = 0x400000; /* FIXME: 0x10000000 if a DLL */\n\n\theader->pe.pe_magic = GUINT16_FROM_LE (0x10B);\n\theader->pe.pe_major = 6;\n\theader->pe.pe_minor = 0;\n\tsize = assembly->sections [MONO_SECTION_TEXT].size;\n\tsize += FILE_ALIGN - 1;\n\tsize &= ~(FILE_ALIGN - 1);\n\theader->pe.pe_code_size = GUINT32_FROM_LE(size);\n\tsize = assembly->sections [MONO_SECTION_RSRC].size;\n\tsize += FILE_ALIGN - 1;\n\tsize &= ~(FILE_ALIGN - 1);\n\theader->pe.pe_data_size = GUINT32_FROM_LE(size);\n\tg_assert (START_TEXT_RVA == assembly->sections [MONO_SECTION_TEXT].rva);\n\theader->pe.pe_rva_code_base = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_TEXT].rva);\n\theader->pe.pe_rva_data_base = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RSRC].rva);\n\t/* pe_rva_entry_point always at the beginning of the text section */\n\theader->pe.pe_rva_entry_point = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_TEXT].rva);\n\n\theader->nt.pe_image_base = GUINT32_FROM_LE (virtual_base);\n\theader->nt.pe_section_align = GUINT32_FROM_LE (VIRT_ALIGN);\n\theader->nt.pe_file_alignment = GUINT32_FROM_LE (FILE_ALIGN);\n\theader->nt.pe_os_major = GUINT16_FROM_LE (4);\n\theader->nt.pe_os_minor = GUINT16_FROM_LE (0);\n\theader->nt.pe_subsys_major = GUINT16_FROM_LE (4);\n\tsize = section_start;\n\tsize += FILE_ALIGN - 1;\n\tsize &= ~(FILE_ALIGN - 1);\n\theader->nt.pe_header_size = GUINT32_FROM_LE (size);\n\tsize = image_size;\n\tsize += VIRT_ALIGN - 1;\n\tsize &= ~(VIRT_ALIGN - 1);\n\theader->nt.pe_image_size = GUINT32_FROM_LE (size);\n\n\t/*\n\t// Translate the PEFileKind value to the value expected by the Windows loader\n\t*/\n\t{\n\t\tshort kind;\n\n\t\t/*\n\t\t// PEFileKinds.Dll == 1\n\t\t// PEFileKinds.ConsoleApplication == 2\n\t\t// PEFileKinds.WindowApplication == 3\n\t\t//\n\t\t// need to get:\n\t\t//     IMAGE_SUBSYSTEM_WINDOWS_GUI 2 // Image runs in the Windows GUI subsystem.\n                //     IMAGE_SUBSYSTEM_WINDOWS_CUI 3 // Image runs in the Windows character subsystem.\n\t\t*/\n\t\tif (assemblyb->pekind == 3)\n\t\t\tkind = 2;\n\t\telse\n\t\t\tkind = 3;\n\t\t\n\t\theader->nt.pe_subsys_required = GUINT16_FROM_LE (kind);\n\t}    \n\theader->nt.pe_stack_reserve = GUINT32_FROM_LE (0x00100000);\n\theader->nt.pe_stack_commit = GUINT32_FROM_LE (0x00001000);\n\theader->nt.pe_heap_reserve = GUINT32_FROM_LE (0x00100000);\n\theader->nt.pe_heap_commit = GUINT32_FROM_LE (0x00001000);\n\theader->nt.pe_loader_flags = GUINT32_FROM_LE (0);\n\theader->nt.pe_data_dir_count = GUINT32_FROM_LE (16);\n\n\t/* fill data directory entries */\n\n\theader->datadir.pe_resource_table.size = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RSRC].size);\n\theader->datadir.pe_resource_table.rva = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RSRC].rva);\n\n\theader->datadir.pe_reloc_table.size = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RELOC].size);\n\theader->datadir.pe_reloc_table.rva = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RELOC].rva);\n\n\theader->datadir.pe_cli_header.size = GUINT32_FROM_LE (72);\n\theader->datadir.pe_cli_header.rva = GUINT32_FROM_LE (assembly->text_rva + assembly->cli_header_offset);\n\theader->datadir.pe_iat.size = GUINT32_FROM_LE (8);\n\theader->datadir.pe_iat.rva = GUINT32_FROM_LE (assembly->text_rva + assembly->iat_offset);\n\t/* patch entrypoint name */\n\tif (assemblyb->pekind == 1)\n\t\tmemcpy (assembly->code.data + assembly->imp_names_offset + 2, \"_CorDllMain\", 12);\n\telse\n\t\tmemcpy (assembly->code.data + assembly->imp_names_offset + 2, \"_CorExeMain\", 12);\n\t/* patch imported function RVA name */\n\trva = (guint32*)(assembly->code.data + assembly->iat_offset);\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->imp_names_offset);\n\n\t/* the import table */\n\theader->datadir.pe_import_table.size = GUINT32_FROM_LE (79); /* FIXME: magic number? */\n\theader->datadir.pe_import_table.rva = GUINT32_FROM_LE (assembly->text_rva + assembly->idt_offset);\n\t/* patch imported dll RVA name and other entries in the dir */\n\trva = (guint32*)(assembly->code.data + assembly->idt_offset + G_STRUCT_OFFSET (MonoIDT, name_rva));\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->imp_names_offset + 14); /* 14 is hint+strlen+1 of func name */\n\trva = (guint32*)(assembly->code.data + assembly->idt_offset + G_STRUCT_OFFSET (MonoIDT, import_address_table_rva));\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->iat_offset);\n\trva = (guint32*)(assembly->code.data + assembly->idt_offset + G_STRUCT_OFFSET (MonoIDT, import_lookup_table));\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->ilt_offset);\n\n\tp = (guchar*)(assembly->code.data + assembly->ilt_offset);\n\tvalue = (assembly->text_rva + assembly->imp_names_offset);\n\t*p++ = (value) & 0xff;\n\t*p++ = (value >> 8) & (0xff);\n\t*p++ = (value >> 16) & (0xff);\n\t*p++ = (value >> 24) & (0xff);\n\n\t/* the CLI header info */\n\tcli_header = (MonoCLIHeader*)(assembly->code.data + assembly->cli_header_offset);\n\tcli_header->ch_size = GUINT32_FROM_LE (72);\n\tcli_header->ch_runtime_major = GUINT16_FROM_LE (2);\n\tif (mono_framework_version () > 1)\n\t\tcli_header->ch_runtime_minor = GUINT16_FROM_LE (5);\n\telse \n\t\tcli_header->ch_runtime_minor = GUINT16_FROM_LE (0);\n\tcli_header->ch_flags = GUINT32_FROM_LE (assemblyb->pe_kind);\n\tif (assemblyb->entry_point) {\n\t\tguint32 table_idx = 0;\n\t\tif (!strcmp (assemblyb->entry_point->object.vtable->klass->name, \"MethodBuilder\")) {\n\t\t\tMonoReflectionMethodBuilder *methodb = (MonoReflectionMethodBuilder*)assemblyb->entry_point;\n\t\t\ttable_idx = methodb->table_idx;\n\t\t} else {\n\t\t\ttable_idx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->method_to_table_idx, assemblyb->entry_point->method));\n\t\t}\n\t\tcli_header->ch_entry_point = GUINT32_FROM_LE (table_idx | MONO_TOKEN_METHOD_DEF);\n\t} else {\n\t\tcli_header->ch_entry_point = GUINT32_FROM_LE (0);\n\t}\n\t/* The embedded managed resources */\n\ttext_offset = assembly->text_rva + assembly->code.index;\n\tcli_header->ch_resources.rva = GUINT32_FROM_LE (text_offset);\n\tcli_header->ch_resources.size = GUINT32_FROM_LE (assembly->resources.index);\n\ttext_offset += assembly->resources.index;\n\tcli_header->ch_metadata.rva = GUINT32_FROM_LE (text_offset);\n\tcli_header->ch_metadata.size = GUINT32_FROM_LE (assembly->meta_size);\n\ttext_offset += assembly->meta_size;\n\tif (assembly->strong_name_size) {\n\t\tcli_header->ch_strong_name.rva = GUINT32_FROM_LE (text_offset);\n\t\tcli_header->ch_strong_name.size = GUINT32_FROM_LE (assembly->strong_name_size);\n\t\ttext_offset += assembly->strong_name_size;\n\t}\n\n\t/* write the section tables and section content */\n\tsection = (MonoSectionTable*)(pefile->data + section_start);\n\tfor (i = 0; i < MONO_SECTION_MAX; ++i) {\n\t\tstatic const char section_names [][7] = {\n\t\t\t\".text\", \".rsrc\", \".reloc\"\n\t\t};\n\t\tif (!assembly->sections [i].size)\n\t\t\tcontinue;\n\t\tstrcpy (section->st_name, section_names [i]);\n\t\t/*g_print (\"output section %s (%d), size: %d\\n\", section->st_name, i, assembly->sections [i].size);*/\n\t\tsection->st_virtual_address = GUINT32_FROM_LE (assembly->sections [i].rva);\n\t\tsection->st_virtual_size = GUINT32_FROM_LE (assembly->sections [i].size);\n\t\tsection->st_raw_data_size = GUINT32_FROM_LE (GUINT32_TO_LE (section->st_virtual_size) + (FILE_ALIGN - 1));\n\t\tsection->st_raw_data_size &= GUINT32_FROM_LE (~(FILE_ALIGN - 1));\n\t\tsection->st_raw_data_ptr = GUINT32_FROM_LE (assembly->sections [i].offset);\n\t\tsection->st_flags = GUINT32_FROM_LE (assembly->sections [i].attrs);\n\t\tsection ++;\n\t}\n\t\n\tchecked_write_file (file, pefile->data, pefile->index);\n\t\n\tmono_dynamic_stream_reset (pefile);\n\t\n\tfor (i = 0; i < MONO_SECTION_MAX; ++i) {\n\t\tif (!assembly->sections [i].size)\n\t\t\tcontinue;\n\t\t\n\t\tif (SetFilePointer (file, assembly->sections [i].offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)\n\t\t\tg_error (\"SetFilePointer returned %d\\n\", GetLastError ());\n\t\t\n\t\tswitch (i) {\n\t\tcase MONO_SECTION_TEXT:\n\t\t\t/* patch entry point */\n\t\t\tp = (guchar*)(assembly->code.data + 2);\n\t\t\tvalue = (virtual_base + assembly->text_rva + assembly->iat_offset);\n\t\t\t*p++ = (value) & 0xff;\n\t\t\t*p++ = (value >> 8) & 0xff;\n\t\t\t*p++ = (value >> 16) & 0xff;\n\t\t\t*p++ = (value >> 24) & 0xff;\n\t\t\n\t\t\tchecked_write_file (file, assembly->code.data, assembly->code.index);\n\t\t\tchecked_write_file (file, assembly->resources.data, assembly->resources.index);\n\t\t\tchecked_write_file (file, assembly->image.raw_metadata, assembly->meta_size);\n\t\t\tchecked_write_file (file, assembly->strong_name, assembly->strong_name_size);\n\t\t\t\t\n\n\t\t\tg_free (assembly->image.raw_metadata);\n\t\t\tbreak;\n\t\tcase MONO_SECTION_RELOC: {\n\t\t\tstruct {\n\t\t\t\tguint32 page_rva;\n\t\t\t\tguint32 block_size;\n\t\t\t\tguint16 type_and_offset;\n\t\t\t\tguint16 term;\n\t\t\t} reloc;\n\t\t\t\n\t\t\tg_assert (sizeof (reloc) == 12);\n\t\t\t\n\t\t\treloc.page_rva = GUINT32_FROM_LE (assembly->text_rva);\n\t\t\treloc.block_size = GUINT32_FROM_LE (12);\n\t\t\t\n\t\t\t/* \n\t\t\t * the entrypoint is always at the start of the text section \n\t\t\t * 3 is IMAGE_REL_BASED_HIGHLOW\n\t\t\t * 2 is patch_size_rva - text_rva\n\t\t\t */\n\t\t\treloc.type_and_offset = GUINT16_FROM_LE ((3 << 12) + (2));\n\t\t\treloc.term = 0;\n\t\t\t\n\t\t\tchecked_write_file (file, &reloc, sizeof (reloc));\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_SECTION_RSRC:\n\t\t\tif (assembly->win32_res) {\n\n\t\t\t\t/* Fixup the offsets in the IMAGE_RESOURCE_DATA_ENTRY structures */\n\t\t\t\tfixup_resource_directory (assembly->win32_res, assembly->win32_res, assembly->sections [i].rva);\n\t\t\t\tchecked_write_file (file, assembly->win32_res, assembly->win32_res_size);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n\t\n\t/* check that the file is properly padded */\n\tif (SetFilePointer (file, file_offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)\n\t\tg_error (\"SetFilePointer returned %d\\n\", GetLastError ());\n\tif (! SetEndOfFile (file))\n\t\tg_error (\"SetEndOfFile returned %d\\n\", GetLastError ());\n\t\n\tmono_dynamic_stream_reset (&assembly->code);\n\tmono_dynamic_stream_reset (&assembly->us);\n\tmono_dynamic_stream_reset (&assembly->blob);\n\tmono_dynamic_stream_reset (&assembly->guid);\n\tmono_dynamic_stream_reset (&assembly->sheap);\n\n\tg_hash_table_foreach (assembly->blob_cache, (GHFunc)g_free, NULL);\n\tg_hash_table_destroy (assembly->blob_cache);\n\tassembly->blob_cache = NULL;\n}\n\n#else /* DISABLE_REFLECTION_EMIT_SAVE */\n\nvoid\nmono_image_create_pefile (MonoReflectionModuleBuilder *mb, HANDLE file)\n{\n\tg_assert_not_reached ();\n}\n\n#endif /* DISABLE_REFLECTION_EMIT_SAVE */\n\n#ifndef DISABLE_REFLECTION_EMIT\n\nMonoReflectionModule *\nmono_image_load_module_dynamic (MonoReflectionAssemblyBuilder *ab, MonoString *fileName)\n{\n\tchar *name;\n\tMonoImage *image;\n\tMonoImageOpenStatus status;\n\tMonoDynamicAssembly *assembly;\n\tguint32 module_count;\n\tMonoImage **new_modules;\n\tgboolean *new_modules_loaded;\n\t\n\tname = mono_string_to_utf8 (fileName);\n\n\timage = mono_image_open (name, &status);\n\tif (!image) {\n\t\tMonoException *exc;\n\t\tif (status == MONO_IMAGE_ERROR_ERRNO)\n\t\t\texc = mono_get_exception_file_not_found (fileName);\n\t\telse\n\t\t\texc = mono_get_exception_bad_image_format (name);\n\t\tg_free (name);\n\t\tmono_raise_exception (exc);\n\t}\n\n\tg_free (name);\n\n\tassembly = ab->dynamic_assembly;\n\timage->assembly = (MonoAssembly*)assembly;\n\n\tmodule_count = image->assembly->image->module_count;\n\tnew_modules = g_new0 (MonoImage *, module_count + 1);\n\tnew_modules_loaded = g_new0 (gboolean, module_count + 1);\n\n\tif (image->assembly->image->modules)\n\t\tmemcpy (new_modules, image->assembly->image->modules, module_count * sizeof (MonoImage *));\n\tif (image->assembly->image->modules_loaded)\n\t\tmemcpy (new_modules_loaded, image->assembly->image->modules_loaded, module_count * sizeof (gboolean));\n\tnew_modules [module_count] = image;\n\tnew_modules_loaded [module_count] = TRUE;\n\tmono_image_addref (image);\n\n\tg_free (image->assembly->image->modules);\n\timage->assembly->image->modules = new_modules;\n\timage->assembly->image->modules_loaded = new_modules_loaded;\n\timage->assembly->image->module_count ++;\n\n\tmono_assembly_load_references (image, &status);\n\tif (status) {\n\t\tmono_image_close (image);\n\t\tmono_raise_exception (mono_get_exception_file_not_found (fileName));\n\t}\n\n\treturn mono_module_get_object (mono_domain_get (), image);\n}\n\n#endif /* DISABLE_REFLECTION_EMIT */\n\n/*\n * We need to return always the same object for MethodInfo, FieldInfo etc..\n * but we need to consider the reflected type.\n * type uses a different hash, since it uses custom hash/equal functions.\n */\n\ntypedef struct {\n\tgpointer item;\n\tMonoClass *refclass;\n} ReflectedEntry;\n\nstatic gboolean\nreflected_equal (gconstpointer a, gconstpointer b) {\n\tconst ReflectedEntry *ea = a;\n\tconst ReflectedEntry *eb = b;\n\n\treturn (ea->item == eb->item) && (ea->refclass == eb->refclass);\n}\n\nstatic guint\nreflected_hash (gconstpointer a) {\n\tconst ReflectedEntry *ea = a;\n\treturn mono_aligned_addr_hash (ea->item);\n}\n\n#define CHECK_OBJECT(t,p,k)\t\\\n\tdo {\t\\\n\t\tt _obj;\t\\\n\t\tReflectedEntry e; \t\\\n\t\te.item = (p);\t\\\n\t\te.refclass = (k);\t\\\n\t\tmono_domain_lock (domain);\t\\\n\t\tif (!domain->refobject_hash)\t\\\n\t\t\tdomain->refobject_hash = mono_g_hash_table_new_type (reflected_hash, reflected_equal, MONO_HASH_VALUE_GC);\t\\\n\t\tif ((_obj = mono_g_hash_table_lookup (domain->refobject_hash, &e))) {\t\\\n\t\t\tmono_domain_unlock (domain);\t\\\n\t\t\treturn _obj;\t\\\n\t\t}\t\\\n        mono_domain_unlock (domain); \\\n\t} while (0)\n\n#ifdef HAVE_BOEHM_GC\n/* ReflectedEntry doesn't need to be GC tracked */\n#define ALLOC_REFENTRY g_new0 (ReflectedEntry, 1)\n#define FREE_REFENTRY(entry) g_free ((entry))\n#define REFENTRY_REQUIRES_CLEANUP\n#else\n#define ALLOC_REFENTRY mono_mempool_alloc (domain->mp, sizeof (ReflectedEntry))\n/* FIXME: */\n#define FREE_REFENTRY(entry)\n#endif\n\n#define CACHE_OBJECT(t,p,o,k)\t\\\n\tdo {\t\\\n\t\tt _obj;\t\\\n        ReflectedEntry pe; \\\n        pe.item = (p); \\\n        pe.refclass = (k); \\\n        mono_domain_lock (domain); \\\n\t\tif (!domain->refobject_hash)\t\\\n\t\t\tdomain->refobject_hash = mono_g_hash_table_new_type (reflected_hash, reflected_equal, MONO_HASH_VALUE_GC);\t\\\n        _obj = mono_g_hash_table_lookup (domain->refobject_hash, &pe); \\\n        if (!_obj) { \\\n\t\t    ReflectedEntry *e = ALLOC_REFENTRY; \t\\\n\t\t    e->item = (p);\t\\\n\t\t    e->refclass = (k);\t\\\n\t\t    mono_g_hash_table_insert (domain->refobject_hash, e,o);\t\\\n            _obj = o; \\\n        } \\\n\t\tmono_domain_unlock (domain);\t\\\n        return _obj; \\\n\t} while (0)\n\nstatic void\nclear_cached_object (MonoDomain *domain, gpointer o, MonoClass *klass)\n{\n\tmono_domain_lock (domain);\n\tif (domain->refobject_hash) {\n        ReflectedEntry pe;\n\t\tgpointer orig_pe, orig_value;\n\n\t\tpe.item = o;\n\t\tpe.refclass = klass;\n\t\tif (mono_g_hash_table_lookup_extended (domain->refobject_hash, &pe, &orig_pe, &orig_value)) {\n\t\t\tmono_g_hash_table_remove (domain->refobject_hash, &pe);\n\t\t\tFREE_REFENTRY (orig_pe);\n\t\t}\n\t}\n\tmono_domain_unlock (domain);\n}\n\n#ifdef REFENTRY_REQUIRES_CLEANUP\nstatic void\ncleanup_refobject_hash (gpointer key, gpointer value, gpointer user_data)\n{\n\tFREE_REFENTRY (key);\n}\n#endif\n\nvoid\nmono_reflection_cleanup_domain (MonoDomain *domain)\n{\n\tif (domain->refobject_hash) {\n/*let's avoid scanning the whole hashtable if not needed*/\n#ifdef REFENTRY_REQUIRES_CLEANUP\n\t\tmono_g_hash_table_foreach (domain->refobject_hash, cleanup_refobject_hash, NULL);\n#endif\n\t\tmono_g_hash_table_destroy (domain->refobject_hash);\n\t\tdomain->refobject_hash = NULL;\n\t}\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic gpointer\nregister_assembly (MonoDomain *domain, MonoReflectionAssembly *res, MonoAssembly *assembly)\n{\n\tCACHE_OBJECT (MonoReflectionAssembly *, assembly, res, NULL);\n}\n\nstatic gpointer\nregister_module (MonoDomain *domain, MonoReflectionModuleBuilder *res, MonoDynamicImage *module)\n{\n\tCACHE_OBJECT (MonoReflectionModuleBuilder *, module, res, NULL);\n}\n\nvoid\nmono_image_module_basic_init (MonoReflectionModuleBuilder *moduleb)\n{\n\tMonoDynamicImage *image = moduleb->dynamic_image;\n\tMonoReflectionAssemblyBuilder *ab = moduleb->assemblyb;\n\tif (!image) {\n\t\tMonoError error;\n\t\tint module_count;\n\t\tMonoImage **new_modules;\n\t\tMonoImage *ass;\n\t\tchar *name, *fqname;\n\t\t/*\n\t\t * FIXME: we already created an image in mono_image_basic_init (), but\n\t\t * we don't know which module it belongs to, since that is only \n\t\t * determined at assembly save time.\n\t\t */\n\t\t/*image = (MonoDynamicImage*)ab->dynamic_assembly->assembly.image; */\n\t\tname = mono_string_to_utf8 (ab->name);\n\t\tfqname = mono_string_to_utf8_checked (moduleb->module.fqname, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tg_free (name);\n\t\t\tmono_error_raise_exception (&error);\n\t\t}\n\t\timage = create_dynamic_mono_image (ab->dynamic_assembly, name, fqname);\n\n\t\tmoduleb->module.image = &image->image;\n\t\tmoduleb->dynamic_image = image;\n\t\tregister_module (mono_object_domain (moduleb), moduleb, image);\n\n\t\t/* register the module with the assembly */\n\t\tass = ab->dynamic_assembly->assembly.image;\n\t\tmodule_count = ass->module_count;\n\t\tnew_modules = g_new0 (MonoImage *, module_count + 1);\n\n\t\tif (ass->modules)\n\t\t\tmemcpy (new_modules, ass->modules, module_count * sizeof (MonoImage *));\n\t\tnew_modules [module_count] = &image->image;\n\t\tmono_image_addref (&image->image);\n\n\t\tg_free (ass->modules);\n\t\tass->modules = new_modules;\n\t\tass->module_count ++;\n\t}\n}\n\nvoid\nmono_image_set_wrappers_type (MonoReflectionModuleBuilder *moduleb, MonoReflectionType *type)\n{\n\tMonoDynamicImage *image = moduleb->dynamic_image;\n\n\tg_assert (type->type);\n\timage->wrappers_type = mono_class_from_mono_type (type->type);\n}\n\n#endif\n\n/*\n * mono_assembly_get_object:\n * @domain: an app domain\n * @assembly: an assembly\n *\n * Return an System.Reflection.Assembly object representing the MonoAssembly @assembly.\n */\nMonoReflectionAssembly*\nmono_assembly_get_object (MonoDomain *domain, MonoAssembly *assembly)\n{\n\tstatic MonoClass *System_Reflection_Assembly;\n\tMonoReflectionAssembly *res;\n\t\n\tCHECK_OBJECT (MonoReflectionAssembly *, assembly, NULL);\n\tif (!System_Reflection_Assembly)\n\t\tSystem_Reflection_Assembly = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Assembly\");\n\tres = (MonoReflectionAssembly *)mono_object_new (domain, System_Reflection_Assembly);\n\tres->assembly = assembly;\n\n\tCACHE_OBJECT (MonoReflectionAssembly *, assembly, res, NULL);\n}\n\n\n\nMonoReflectionModule*   \nmono_module_get_object   (MonoDomain *domain, MonoImage *image)\n{\n\tstatic MonoClass *System_Reflection_Module;\n\tMonoReflectionModule *res;\n\tchar* basename;\n\t\n\tCHECK_OBJECT (MonoReflectionModule *, image, NULL);\n\tif (!System_Reflection_Module)\n\t\tSystem_Reflection_Module = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Module\");\n\tres = (MonoReflectionModule *)mono_object_new (domain, System_Reflection_Module);\n\n\tres->image = image;\n\tMONO_OBJECT_SETREF (res, assembly, (MonoReflectionAssembly *) mono_assembly_get_object(domain, image->assembly));\n\n\tMONO_OBJECT_SETREF (res, fqname, mono_string_new (domain, image->name));\n\tbasename = g_path_get_basename (image->name);\n\tMONO_OBJECT_SETREF (res, name, mono_string_new (domain, basename));\n\tMONO_OBJECT_SETREF (res, scopename, mono_string_new (domain, image->module_name));\n\t\n\tg_free (basename);\n\n\tif (image->assembly->image == image) {\n\t\tres->token = mono_metadata_make_token (MONO_TABLE_MODULE, 1);\n\t} else {\n\t\tint i;\n\t\tres->token = 0;\n\t\tif (image->assembly->image->modules) {\n\t\t\tfor (i = 0; i < image->assembly->image->module_count; i++) {\n\t\t\t\tif (image->assembly->image->modules [i] == image)\n\t\t\t\t\tres->token = mono_metadata_make_token (MONO_TABLE_MODULEREF, i + 1);\n\t\t\t}\n\t\t\tg_assert (res->token);\n\t\t}\n\t}\n\n\tCACHE_OBJECT (MonoReflectionModule *, image, res, NULL);\n}\n\nMonoReflectionModule*   \nmono_module_file_get_object (MonoDomain *domain, MonoImage *image, int table_index)\n{\n\tstatic MonoClass *System_Reflection_Module;\n\tMonoReflectionModule *res;\n\tMonoTableInfo *table;\n\tguint32 cols [MONO_FILE_SIZE];\n\tconst char *name;\n\tguint32 i, name_idx;\n\tconst char *val;\n\t\n\tif (!System_Reflection_Module)\n\t\tSystem_Reflection_Module = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Module\");\n\tres = (MonoReflectionModule *)mono_object_new (domain, System_Reflection_Module);\n\n\ttable = &image->tables [MONO_TABLE_FILE];\n\tg_assert (table_index < table->rows);\n\tmono_metadata_decode_row (table, table_index, cols, MONO_FILE_SIZE);\n\n\tres->image = NULL;\n\tMONO_OBJECT_SETREF (res, assembly, (MonoReflectionAssembly *) mono_assembly_get_object(domain, image->assembly));\n\tname = mono_metadata_string_heap (image, cols [MONO_FILE_NAME]);\n\n\t/* Check whenever the row has a corresponding row in the moduleref table */\n\ttable = &image->tables [MONO_TABLE_MODULEREF];\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tname_idx = mono_metadata_decode_row_col (table, i, MONO_MODULEREF_NAME);\n\t\tval = mono_metadata_string_heap (image, name_idx);\n\t\tif (strcmp (val, name) == 0)\n\t\t\tres->image = image->modules [i];\n\t}\n\n\tMONO_OBJECT_SETREF (res, fqname, mono_string_new (domain, name));\n\tMONO_OBJECT_SETREF (res, name, mono_string_new (domain, name));\n\tMONO_OBJECT_SETREF (res, scopename, mono_string_new (domain, name));\n\tres->is_resource = cols [MONO_FILE_FLAGS] && FILE_CONTAINS_NO_METADATA;\n\tres->token = mono_metadata_make_token (MONO_TABLE_FILE, table_index + 1);\n\n\treturn res;\n}\n\nstatic gboolean\nmymono_metadata_type_equal (MonoType *t1, MonoType *t2)\n{\n\tif ((t1->type != t2->type) ||\n\t    (t1->byref != t2->byref))\n\t\treturn FALSE;\n\n\tswitch (t1->type) {\n\tcase MONO_TYPE_VOID:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn TRUE;\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_SZARRAY:\n\t\treturn t1->data.klass == t2->data.klass;\n\tcase MONO_TYPE_PTR:\n\t\treturn mymono_metadata_type_equal (t1->data.type, t2->data.type);\n\tcase MONO_TYPE_ARRAY:\n\t\tif (t1->data.array->rank != t2->data.array->rank)\n\t\t\treturn FALSE;\n\t\treturn t1->data.array->eklass == t2->data.array->eklass;\n\tcase MONO_TYPE_GENERICINST: {\n\t\tint i;\n\t\tMonoGenericInst *i1 = t1->data.generic_class->context.class_inst;\n\t\tMonoGenericInst *i2 = t2->data.generic_class->context.class_inst;\n\t\tif (i1->type_argc != i2->type_argc)\n\t\t\treturn FALSE;\n\t\tif (!mono_metadata_type_equal (&t1->data.generic_class->container_class->byval_arg,\n\t\t\t\t\t       &t2->data.generic_class->container_class->byval_arg))\n\t\t\treturn FALSE;\n\t\t/* FIXME: we should probably just compare the instance pointers directly.  */\n\t\tfor (i = 0; i < i1->type_argc; ++i) {\n\t\t\tif (!mono_metadata_type_equal (i1->type_argv [i], i2->type_argv [i]))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\treturn t1->data.generic_param == t2->data.generic_param;\n\tdefault:\n\t\tg_error (\"implement type compare for %0x!\", t1->type);\n\t\treturn FALSE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic guint\nmymono_metadata_type_hash (MonoType *t1)\n{\n\tguint hash;\n\n\thash = t1->type;\n\n\thash |= t1->byref << 6; /* do not collide with t1->type values */\n\tswitch (t1->type) {\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_SZARRAY:\n\t\t/* check if the distribution is good enough */\n\t\treturn ((hash << 5) - hash) ^ g_str_hash (t1->data.klass->name);\n\tcase MONO_TYPE_PTR:\n\t\treturn ((hash << 5) - hash) ^ mymono_metadata_type_hash (t1->data.type);\n\tcase MONO_TYPE_GENERICINST: {\n\t\tint i;\n\t\tMonoGenericInst *inst = t1->data.generic_class->context.class_inst;\n\t\thash += g_str_hash (t1->data.generic_class->container_class->name);\n\t\thash *= 13;\n\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\thash += mymono_metadata_type_hash (inst->type_argv [i]);\n\t\t\thash *= 13;\n\t\t}\n\t\treturn hash;\n\t}\n\t}\n\treturn hash;\n}\n\nstatic MonoReflectionGenericClass*\nmono_generic_class_get_object (MonoDomain *domain, MonoType *geninst)\n{\n\tstatic MonoClass *System_Reflection_MonoGenericClass;\n\tMonoReflectionGenericClass *res;\n\tMonoClass *klass, *gklass;\n\tMonoGenericInst *ginst;\n\tMonoArray *type_args;\n\tint i;\n\n\tif (!System_Reflection_MonoGenericClass) {\n\t\tSystem_Reflection_MonoGenericClass = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"MonoGenericClass\");\n\t\tg_assert (System_Reflection_MonoGenericClass);\n\t}\n\n\tklass = mono_class_from_mono_type (geninst);\n\tgklass = klass->generic_class->container_class;\n\n\tmono_class_init (klass);\n\n#ifdef HAVE_SGEN_GC\n\tres = (MonoReflectionGenericClass *) mono_gc_alloc_pinned_obj (mono_class_vtable (domain, System_Reflection_MonoGenericClass), mono_class_instance_size (System_Reflection_MonoGenericClass));\n#else\n\tres = (MonoReflectionGenericClass *) mono_object_new (domain, System_Reflection_MonoGenericClass);\n#endif\n\n\tres->type.type = geninst;\n\tg_assert (gklass->reflection_info);\n\tg_assert (!strcmp (((MonoObject*)gklass->reflection_info)->vtable->klass->name, \"TypeBuilder\"));\n\tMONO_OBJECT_SETREF (res, generic_type, gklass->reflection_info);\n\n\tginst = klass->generic_class->context.class_inst;\n\ttype_args = mono_array_new (domain, mono_defaults.systemtype_class, ginst->type_argc);\n\tfor (i = 0; i < ginst->type_argc; ++i)\n\t\tmono_array_setref (type_args, i, mono_type_get_object (domain, ginst->type_argv [i]));\n\tMONO_OBJECT_SETREF (res, type_arguments, type_args);\n\n\treturn res;\n}\n\nstatic gboolean\nverify_safe_for_managed_space (MonoType *type)\n{\n\tswitch (type->type) {\n#ifdef DEBUG_HARDER\n\tcase MONO_TYPE_ARRAY:\n\t\treturn verify_safe_for_managed_space (&type->data.array->eklass->byval_arg);\n\tcase MONO_TYPE_PTR:\n\t\treturn verify_safe_for_managed_space (type->data.type);\n\tcase MONO_TYPE_SZARRAY:\n\t\treturn verify_safe_for_managed_space (&type->data.klass->byval_arg);\n\tcase MONO_TYPE_GENERICINST: {\n\t\tMonoGenericInst *inst = type->data.generic_class->inst;\n\t\tint i;\n\t\tif (!inst->is_open)\n\t\t\tbreak;\n\t\tfor (i = 0; i < inst->type_argc; ++i)\n\t\t\tif (!verify_safe_for_managed_space (inst->type_argv [i]))\n\t\t\t\treturn FALSE;\n\t\tbreak;\n\t}\n#endif\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\treturn TRUE;\n\t}\n\treturn TRUE;\n}\n\n/*\n * mono_type_get_object:\n * @domain: an app domain\n * @type: a type\n *\n * Return an System.MonoType object representing the type @type.\n */\nMonoReflectionType*\nmono_type_get_object (MonoDomain *domain, MonoType *type)\n{\n\tMonoReflectionType *res;\n\tMonoClass *klass = mono_class_from_mono_type (type);\n\n\t/*we must avoid using @type as it might have come\n\t * from a mono_metadata_type_dup and the caller\n\t * expects that is can be freed.\n\t * Using the right type from \n\t */\n\ttype = klass->byval_arg.byref == type->byref ? &klass->byval_arg : &klass->this_arg;\n\n\t/* void is very common */\n\tif (type->type == MONO_TYPE_VOID && domain->typeof_void)\n\t\treturn (MonoReflectionType*)domain->typeof_void;\n\n\t/*\n\t * If the vtable of the given class was already created, we can use\n\t * the MonoType from there and avoid all locking and hash table lookups.\n\t * \n\t * We cannot do this for TypeBuilders as mono_reflection_create_runtime_class expects\n\t * that the resulting object is different.   \n\t */\n\tif (type == &klass->byval_arg && !klass->image->dynamic) {\n\t\tMonoVTable *vtable = mono_class_try_get_vtable (domain, klass);\n\t\tif (vtable && vtable->type)\n\t\t\treturn vtable->type;\n\t}\n\n\tmono_loader_lock (); /*FIXME mono_class_init and mono_class_vtable acquire it*/\n\tmono_domain_lock (domain);\n\tif (!domain->type_hash)\n\t\tdomain->type_hash = mono_g_hash_table_new_type ((GHashFunc)mymono_metadata_type_hash, \n\t\t\t\t(GCompareFunc)mymono_metadata_type_equal, MONO_HASH_VALUE_GC);\n\tif ((res = mono_g_hash_table_lookup (domain->type_hash, type))) {\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\t/* Create a MonoGenericClass object for instantiations of not finished TypeBuilders */\n\tif ((type->type == MONO_TYPE_GENERICINST) && type->data.generic_class->is_dynamic && !type->data.generic_class->container_class->wastypebuilder) {\n\t\tres = (MonoReflectionType *)mono_generic_class_get_object (domain, type);\n\t\tmono_g_hash_table_insert (domain->type_hash, type, res);\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\n\tif (!verify_safe_for_managed_space (type)) {\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\"This type cannot be propagated to managed space\"));\n\t}\n\n\tif (klass->reflection_info && !klass->wastypebuilder) {\n\t\tgboolean is_type_done = TRUE;\n\t\t/* Generic parameters have reflection_info set but they are not finished together with their enclosing type.\n\t\t * We must ensure that once a type is finished we don't return a GenericTypeParameterBuilder.\n\t\t * We can't simply close the types as this will interfere with other parts of the generics machinery.\n\t\t*/\n\t\tif (klass->byval_arg.type == MONO_TYPE_MVAR || klass->byval_arg.type == MONO_TYPE_VAR) {\n\t\t\tMonoGenericParam *gparam = klass->byval_arg.data.generic_param;\n\n\t\t\tif (gparam->owner && gparam->owner->is_method) {\n\t\t\t\tMonoMethod *method = gparam->owner->owner.method;\n\t\t\t\tif (method && mono_class_get_generic_type_definition (method->klass)->wastypebuilder)\n\t\t\t\t\tis_type_done = FALSE;\n\t\t\t} else if (gparam->owner && !gparam->owner->is_method) {\n\t\t\t\tMonoClass *klass = gparam->owner->owner.klass;\n\t\t\t\tif (klass && mono_class_get_generic_type_definition (klass)->wastypebuilder)\n\t\t\t\t\tis_type_done = FALSE;\n\t\t\t}\n\t\t} \n\n\t\t/* g_assert_not_reached (); */\n\t\t/* should this be considered an error condition? */\n\t\tif (is_type_done && !type->byref) {\n\t\t\tmono_domain_unlock (domain);\n\t\t\tmono_loader_unlock ();\n\t\t\treturn klass->reflection_info;\n\t\t}\n\t}\n\t// FIXME: Get rid of this, do it in the icalls for Type\n\tmono_class_init (klass);\n#ifdef HAVE_SGEN_GC\n\tres = (MonoReflectionType *)mono_gc_alloc_pinned_obj (mono_class_vtable (domain, mono_defaults.monotype_class), mono_class_instance_size (mono_defaults.monotype_class));\n#else\n\tres = (MonoReflectionType *)mono_object_new (domain, mono_defaults.monotype_class);\n#endif\n\tres->type = type;\n\tmono_g_hash_table_insert (domain->type_hash, type, res);\n\n\tif (type->type == MONO_TYPE_VOID)\n\t\tdomain->typeof_void = (MonoObject*)res;\n\n\tmono_domain_unlock (domain);\n\tmono_loader_unlock ();\n\treturn res;\n}\n\n/*\n * mono_method_get_object:\n * @domain: an app domain\n * @method: a method\n * @refclass: the reflected type (can be NULL)\n *\n * Return an System.Reflection.MonoMethod object representing the method @method.\n */\nMonoReflectionMethod*\nmono_method_get_object (MonoDomain *domain, MonoMethod *method, MonoClass *refclass)\n{\n\t/*\n\t * We use the same C representation for methods and constructors, but the type \n\t * name in C# is different.\n\t */\n\tstatic MonoClass *System_Reflection_MonoMethod = NULL;\n\tstatic MonoClass *System_Reflection_MonoCMethod = NULL;\n\tstatic MonoClass *System_Reflection_MonoGenericMethod = NULL;\n\tstatic MonoClass *System_Reflection_MonoGenericCMethod = NULL;\n\tMonoClass *klass;\n\tMonoReflectionMethod *ret;\n\n\tif (method->is_inflated) {\n\t\tMonoReflectionGenericMethod *gret;\n\n\t\trefclass = method->klass;\n\t\tCHECK_OBJECT (MonoReflectionMethod *, method, refclass);\n\t\tif ((*method->name == '.') && (!strcmp (method->name, \".ctor\") || !strcmp (method->name, \".cctor\"))) {\n\t\t\tif (!System_Reflection_MonoGenericCMethod)\n\t\t\t\tSystem_Reflection_MonoGenericCMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoGenericCMethod\");\n\t\t\tklass = System_Reflection_MonoGenericCMethod;\n\t\t} else {\n\t\t\tif (!System_Reflection_MonoGenericMethod)\n\t\t\t\tSystem_Reflection_MonoGenericMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoGenericMethod\");\n\t\t\tklass = System_Reflection_MonoGenericMethod;\n\t\t}\n\t\tgret = (MonoReflectionGenericMethod*)mono_object_new (domain, klass);\n\t\tgret->method.method = method;\n\t\tMONO_OBJECT_SETREF (gret, method.name, mono_string_new (domain, method->name));\n\t\tMONO_OBJECT_SETREF (gret, method.reftype, mono_type_get_object (domain, &refclass->byval_arg));\n\t\tCACHE_OBJECT (MonoReflectionMethod *, method, (MonoReflectionMethod*)gret, refclass);\n\t}\n\n\tif (!refclass)\n\t\trefclass = method->klass;\n\n\tCHECK_OBJECT (MonoReflectionMethod *, method, refclass);\n\tif (*method->name == '.' && (strcmp (method->name, \".ctor\") == 0 || strcmp (method->name, \".cctor\") == 0)) {\n\t\tif (!System_Reflection_MonoCMethod)\n\t\t\tSystem_Reflection_MonoCMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoCMethod\");\n\t\tklass = System_Reflection_MonoCMethod;\n\t}\n\telse {\n\t\tif (!System_Reflection_MonoMethod)\n\t\t\tSystem_Reflection_MonoMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoMethod\");\n\t\tklass = System_Reflection_MonoMethod;\n\t}\n\tret = (MonoReflectionMethod*)mono_object_new (domain, klass);\n\tret->method = method;\n\tMONO_OBJECT_SETREF (ret, reftype, mono_type_get_object (domain, &refclass->byval_arg));\n\tCACHE_OBJECT (MonoReflectionMethod *, method, ret, refclass);\n}\n\n/*\n * mono_method_clear_object:\n *\n *   Clear the cached reflection objects for the dynamic method METHOD.\n */\nvoid\nmono_method_clear_object (MonoDomain *domain, MonoMethod *method)\n{\n\tMonoClass *klass;\n\tg_assert (method->dynamic);\n\n\tklass = method->klass;\n\twhile (klass) {\n\t\tclear_cached_object (domain, method, klass);\n\t\tklass = klass->parent;\n\t}\n\t/* Added by mono_param_get_objects () */\n\tclear_cached_object (domain, &(method->signature), NULL);\n\tklass = method->klass;\n\twhile (klass) {\n\t\tclear_cached_object (domain, &(method->signature), klass);\n\t\tklass = klass->parent;\n\t}\n}\n\n/*\n * mono_field_get_object:\n * @domain: an app domain\n * @klass: a type\n * @field: a field\n *\n * Return an System.Reflection.MonoField object representing the field @field\n * in class @klass.\n */\nMonoReflectionField*\nmono_field_get_object (MonoDomain *domain, MonoClass *klass, MonoClassField *field)\n{\n\tMonoReflectionField *res;\n\tstatic MonoClass *monofield_klass;\n\n\tCHECK_OBJECT (MonoReflectionField *, field, klass);\n\tif (!monofield_klass)\n\t\tmonofield_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoField\");\n\tres = (MonoReflectionField *)mono_object_new (domain, monofield_klass);\n\tres->klass = klass;\n\tres->field = field;\n\tMONO_OBJECT_SETREF (res, name, mono_string_new (domain, mono_field_get_name (field)));\n\tif (is_field_on_inst (field))\n\t\tres->attrs = get_field_on_inst_generic_type (field)->attrs;\n\telse\n\t\tres->attrs = field->type->attrs;\n\tMONO_OBJECT_SETREF (res, type, mono_type_get_object (domain, field->type));\n\tCACHE_OBJECT (MonoReflectionField *, field, res, klass);\n}\n\n/*\n * mono_property_get_object:\n * @domain: an app domain\n * @klass: a type\n * @property: a property\n *\n * Return an System.Reflection.MonoProperty object representing the property @property\n * in class @klass.\n */\nMonoReflectionProperty*\nmono_property_get_object (MonoDomain *domain, MonoClass *klass, MonoProperty *property)\n{\n\tMonoReflectionProperty *res;\n\tstatic MonoClass *monoproperty_klass;\n\n\tCHECK_OBJECT (MonoReflectionProperty *, property, klass);\n\tif (!monoproperty_klass)\n\t\tmonoproperty_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoProperty\");\n\tres = (MonoReflectionProperty *)mono_object_new (domain, monoproperty_klass);\n\tres->klass = klass;\n\tres->property = property;\n\tCACHE_OBJECT (MonoReflectionProperty *, property, res, klass);\n}\n\n/*\n * mono_event_get_object:\n * @domain: an app domain\n * @klass: a type\n * @event: a event\n *\n * Return an System.Reflection.MonoEvent object representing the event @event\n * in class @klass.\n */\nMonoReflectionEvent*\nmono_event_get_object (MonoDomain *domain, MonoClass *klass, MonoEvent *event)\n{\n\tMonoReflectionEvent *res;\n\tMonoReflectionMonoEvent *mono_event;\n\tstatic MonoClass *monoevent_klass;\n\n\tCHECK_OBJECT (MonoReflectionEvent *, event, klass);\n\tif (!monoevent_klass)\n\t\tmonoevent_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoEvent\");\n\tmono_event = (MonoReflectionMonoEvent *)mono_object_new (domain, monoevent_klass);\n\tmono_event->klass = klass;\n\tmono_event->event = event;\n\tres = (MonoReflectionEvent*)mono_event;\n\tCACHE_OBJECT (MonoReflectionEvent *, event, res, klass);\n}\n\n/**\n * mono_get_reflection_missing_object:\n * @domain: Domain where the object lives\n *\n * Returns the System.Reflection.Missing.Value singleton object\n * (of type System.Reflection.Missing).\n *\n * Used as the value for ParameterInfo.DefaultValue when Optional\n * is present\n */\nstatic MonoObject *\nmono_get_reflection_missing_object (MonoDomain *domain)\n{\n\tMonoObject *obj;\n\tstatic MonoClassField *missing_value_field = NULL;\n\t\n\tif (!missing_value_field) {\n\t\tMonoClass *missing_klass;\n\t\tmissing_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"Missing\");\n\t\tmono_class_init (missing_klass);\n\t\tmissing_value_field = mono_class_get_field_from_name (missing_klass, \"Value\");\n\t\tg_assert (missing_value_field);\n\t}\n\tobj = mono_field_get_value_object (domain, missing_value_field, NULL); \n\tg_assert (obj);\n\treturn obj;\n}\n\nstatic MonoObject*\nget_dbnull (MonoDomain *domain, MonoObject **dbnull)\n{\n\tif (!*dbnull)\n\t\t*dbnull = mono_get_dbnull_object (domain);\n\treturn *dbnull;\n}\n\nstatic MonoObject*\nget_reflection_missing (MonoDomain *domain, MonoObject **reflection_missing)\n{\n\tif (!*reflection_missing)\n\t\t*reflection_missing = mono_get_reflection_missing_object (domain);\n\treturn *reflection_missing;\n}\n\n/*\n * mono_param_get_objects:\n * @domain: an app domain\n * @method: a method\n *\n * Return an System.Reflection.ParameterInfo array object representing the parameters\n * in the method @method.\n */\nMonoArray*\nmono_param_get_objects_internal (MonoDomain *domain, MonoMethod *method, MonoClass *refclass)\n{\n\tstatic MonoClass *System_Reflection_ParameterInfo;\n\tstatic MonoClass *System_Reflection_ParameterInfo_array;\n\tMonoArray *res = NULL;\n\tMonoReflectionMethod *member = NULL;\n\tMonoReflectionParameter *param = NULL;\n\tchar **names, **blobs = NULL;\n\tguint32 *types = NULL;\n\tMonoType *type = NULL;\n\tMonoObject *dbnull = NULL;\n\tMonoObject *missing = NULL;\n\tMonoMarshalSpec **mspecs;\n\tMonoMethodSignature *sig;\n\tMonoVTable *pinfo_vtable;\n\tint i;\n\n\tif (!System_Reflection_ParameterInfo_array) {\n\t\tMonoClass *klass;\n\n\t\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"ParameterInfo\");\n\t\tmono_memory_barrier ();\n\t\tSystem_Reflection_ParameterInfo = klass; \n\t\n\t\tklass = mono_array_class_get (klass, 1);\n\t\tmono_memory_barrier ();\n\t\tSystem_Reflection_ParameterInfo_array = klass;\n\t}\n\t\n\tif (!mono_method_signature (method)->param_count)\n\t\treturn mono_array_new_specific (mono_class_vtable (domain, System_Reflection_ParameterInfo_array), 0);\n\n\t/* Note: the cache is based on the address of the signature into the method\n\t * since we already cache MethodInfos with the method as keys.\n\t */\n\tCHECK_OBJECT (MonoArray*, &(method->signature), refclass);\n\n\tsig = mono_method_signature (method);\n\tmember = mono_method_get_object (domain, method, refclass);\n\tnames = g_new (char *, sig->param_count);\n\tmono_method_get_param_names (method, (const char **) names);\n\n\tmspecs = g_new (MonoMarshalSpec*, sig->param_count + 1);\n\tmono_method_get_marshal_info (method, mspecs);\n\n\tres = mono_array_new_specific (mono_class_vtable (domain, System_Reflection_ParameterInfo_array), sig->param_count);\n\tpinfo_vtable = mono_class_vtable (domain, System_Reflection_ParameterInfo);\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tparam = (MonoReflectionParameter *)mono_object_new_specific (pinfo_vtable);\n\t\tMONO_OBJECT_SETREF (param, ClassImpl, mono_type_get_object (domain, sig->params [i]));\n\t\tMONO_OBJECT_SETREF (param, MemberImpl, (MonoObject*)member);\n\t\tMONO_OBJECT_SETREF (param, NameImpl, mono_string_new (domain, names [i]));\n\t\tparam->PositionImpl = i;\n\t\tparam->AttrsImpl = sig->params [i]->attrs;\n\n\t\tif (!(param->AttrsImpl & PARAM_ATTRIBUTE_HAS_DEFAULT)) {\n\t\t\tif (param->AttrsImpl & PARAM_ATTRIBUTE_OPTIONAL)\n\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_reflection_missing (domain, &missing));\n\t\t\telse\n\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_dbnull (domain, &dbnull));\n\t\t} else {\n\n\t\t\tif (!blobs) {\n\t\t\t\tblobs = g_new0 (char *, sig->param_count);\n\t\t\t\ttypes = g_new0 (guint32, sig->param_count);\n\t\t\t\tget_default_param_value_blobs (method, blobs, types); \n\t\t\t}\n\n\t\t\t/* Build MonoType for the type from the Constant Table */\n\t\t\tif (!type)\n\t\t\t\ttype = g_new0 (MonoType, 1);\n\t\t\ttype->type = types [i];\n\t\t\ttype->data.klass = NULL;\n\t\t\tif (types [i] == MONO_TYPE_CLASS)\n\t\t\t\ttype->data.klass = mono_defaults.object_class;\n\t\t\telse if ((sig->params [i]->type == MONO_TYPE_VALUETYPE) && sig->params [i]->data.klass->enumtype) {\n\t\t\t\t/* For enums, types [i] contains the base type */\n\n\t\t\t\t\ttype->type = MONO_TYPE_VALUETYPE;\n\t\t\t\t\ttype->data.klass = mono_class_from_mono_type (sig->params [i]);\n\t\t\t} else\n\t\t\t\ttype->data.klass = mono_class_from_mono_type (type);\n\n\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, mono_get_object_from_blob (domain, type, blobs [i]));\n\n\t\t\t/* Type in the Constant table is MONO_TYPE_CLASS for nulls */\n\t\t\tif (types [i] != MONO_TYPE_CLASS && !param->DefaultValueImpl) {\n\t\t\t\tif (param->AttrsImpl & PARAM_ATTRIBUTE_OPTIONAL)\n\t\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_reflection_missing (domain, &missing));\n\t\t\t\telse\n\t\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_dbnull (domain, &dbnull));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif (mspecs [i + 1])\n\t\t\tMONO_OBJECT_SETREF (param, MarshalAsImpl, (MonoObject*)mono_reflection_marshal_from_marshal_spec (domain, method->klass, mspecs [i + 1]));\n\t\t\n\t\tmono_array_setref (res, i, param);\n\t}\n\tg_free (names);\n\tg_free (blobs);\n\tg_free (types);\n\tg_free (type);\n\n\tfor (i = mono_method_signature (method)->param_count; i >= 0; i--)\n\t\tif (mspecs [i])\n\t\t\tmono_metadata_free_marshal_spec (mspecs [i]);\n\tg_free (mspecs);\n\t\n\tCACHE_OBJECT (MonoArray *, &(method->signature), res, refclass);\n}\n\nMonoArray*\nmono_param_get_objects (MonoDomain *domain, MonoMethod *method)\n{\n\treturn mono_param_get_objects_internal (domain, method, NULL);\n}\n\n/*\n * mono_method_body_get_object:\n * @domain: an app domain\n * @method: a method\n *\n * Return an System.Reflection.MethodBody object representing the method @method.\n */\nMonoReflectionMethodBody*\nmono_method_body_get_object (MonoDomain *domain, MonoMethod *method)\n{\n\tstatic MonoClass *System_Reflection_MethodBody = NULL;\n\tstatic MonoClass *System_Reflection_LocalVariableInfo = NULL;\n\tstatic MonoClass *System_Reflection_ExceptionHandlingClause = NULL;\n\tMonoReflectionMethodBody *ret;\n\tMonoMethodNormal *mn;\n\tMonoMethodHeader *header;\n\tMonoImage *image;\n\tguint32 method_rva, local_var_sig_token;\n    char *ptr;\n\tunsigned char format, flags;\n\tint i;\n\n\t/* for compatibility with .net */\n    if (method->dynamic)\n        mono_raise_exception (mono_get_exception_invalid_operation (NULL));\n\n\tif (!System_Reflection_MethodBody)\n\t\tSystem_Reflection_MethodBody = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MethodBody\");\n\tif (!System_Reflection_LocalVariableInfo)\n\t\tSystem_Reflection_LocalVariableInfo = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"LocalVariableInfo\");\n\tif (!System_Reflection_ExceptionHandlingClause)\n\t\tSystem_Reflection_ExceptionHandlingClause = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"ExceptionHandlingClause\");\n\n\tCHECK_OBJECT (MonoReflectionMethodBody *, method, NULL);\n\n\tif ((method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t(method->flags & METHOD_ATTRIBUTE_ABSTRACT) ||\n\t    (method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||\n\t    (method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME))\n\t\treturn NULL;\n\n\tmn = (MonoMethodNormal *)method;\n\timage = method->klass->image;\n\theader = mono_method_get_header (method);\n\n\tif (!image->dynamic) {\n\t\t/* Obtain local vars signature token */\n\t\tmethod_rva = mono_metadata_decode_row_col (&image->tables [MONO_TABLE_METHOD], mono_metadata_token_index (method->token) - 1, MONO_METHOD_RVA);\n\t\tptr = mono_image_rva_map (image, method_rva);\n\t\tflags = *(const unsigned char *) ptr;\n\t\tformat = flags & METHOD_HEADER_FORMAT_MASK;\n\t\tswitch (format){\n\t\tcase METHOD_HEADER_TINY_FORMAT:\n\t\t\tlocal_var_sig_token = 0;\n\t\t\tbreak;\n\t\tcase METHOD_HEADER_FAT_FORMAT:\n\t\t\tptr += 2;\n\t\t\tptr += 2;\n\t\t\tptr += 4;\n\t\t\tlocal_var_sig_token = read32 (ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t} else\n\t\tlocal_var_sig_token = 0; //FIXME\n\n\tret = (MonoReflectionMethodBody*)mono_object_new (domain, System_Reflection_MethodBody);\n\n\tret->init_locals = header->init_locals;\n\tret->max_stack = header->max_stack;\n\tret->local_var_sig_token = local_var_sig_token;\n\tMONO_OBJECT_SETREF (ret, il, mono_array_new_cached (domain, mono_defaults.byte_class, header->code_size));\n\tmemcpy (mono_array_addr (ret->il, guint8, 0), header->code, header->code_size);\n\n\t/* Locals */\n\tMONO_OBJECT_SETREF (ret, locals, mono_array_new_cached (domain, System_Reflection_LocalVariableInfo, header->num_locals));\n\tfor (i = 0; i < header->num_locals; ++i) {\n\t\tMonoReflectionLocalVariableInfo *info = (MonoReflectionLocalVariableInfo*)mono_object_new (domain, System_Reflection_LocalVariableInfo);\n\t\tMONO_OBJECT_SETREF (info, local_type, mono_type_get_object (domain, header->locals [i]));\n\t\tinfo->is_pinned = header->locals [i]->pinned;\n\t\tinfo->local_index = i;\n\t\tmono_array_setref (ret->locals, i, info);\n\t}\n\n\t/* Exceptions */\n\tMONO_OBJECT_SETREF (ret, clauses, mono_array_new_cached (domain, System_Reflection_ExceptionHandlingClause, header->num_clauses));\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tMonoReflectionExceptionHandlingClause *info = (MonoReflectionExceptionHandlingClause*)mono_object_new (domain, System_Reflection_ExceptionHandlingClause);\n\t\tMonoExceptionClause *clause = &header->clauses [i];\n\n\t\tinfo->flags = clause->flags;\n\t\tinfo->try_offset = clause->try_offset;\n\t\tinfo->try_length = clause->try_len;\n\t\tinfo->handler_offset = clause->handler_offset;\n\t\tinfo->handler_length = clause->handler_len;\n\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\tinfo->filter_offset = clause->data.filter_offset;\n\t\telse if (clause->data.catch_class)\n\t\t\tMONO_OBJECT_SETREF (info, catch_type, mono_type_get_object (mono_domain_get (), &clause->data.catch_class->byval_arg));\n\n\t\tmono_array_setref (ret->clauses, i, info);\n\t}\n\n\tCACHE_OBJECT (MonoReflectionMethodBody *, method, ret, NULL);\n\treturn ret;\n}\n\n/**\n * mono_get_dbnull_object:\n * @domain: Domain where the object lives\n *\n * Returns the System.DBNull.Value singleton object\n *\n * Used as the value for ParameterInfo.DefaultValue \n */\nMonoObject *\nmono_get_dbnull_object (MonoDomain *domain)\n{\n\tMonoObject *obj;\n\tstatic MonoClassField *dbnull_value_field = NULL;\n\t\n\tif (!dbnull_value_field) {\n\t\tMonoClass *dbnull_klass;\n\t\tdbnull_klass = mono_class_from_name (mono_defaults.corlib, \"System\", \"DBNull\");\n\t\tmono_class_init (dbnull_klass);\n\t\tdbnull_value_field = mono_class_get_field_from_name (dbnull_klass, \"Value\");\n\t\tg_assert (dbnull_value_field);\n\t}\n\tobj = mono_field_get_value_object (domain, dbnull_value_field, NULL); \n\tg_assert (obj);\n\treturn obj;\n}\n\nstatic void\nget_default_param_value_blobs (MonoMethod *method, char **blobs, guint32 *types)\n{\n\tguint32 param_index, i, lastp, crow = 0;\n\tguint32 param_cols [MONO_PARAM_SIZE], const_cols [MONO_CONSTANT_SIZE];\n\tgint32 idx;\n\n\tMonoClass *klass = method->klass;\n\tMonoImage *image = klass->image;\n\tMonoMethodSignature *methodsig = mono_method_signature (method);\n\n\tMonoTableInfo *constt;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\n\tif (!methodsig->param_count)\n\t\treturn;\n\n\tmono_class_init (klass);\n\n\tif (klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *aux;\n\t\tif (method->is_inflated)\n\t\t\tmethod = ((MonoMethodInflated*)method)->declaring;\n\t\taux = g_hash_table_lookup (((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (aux && aux->param_defaults) {\n\t\t\tmemcpy (blobs, &(aux->param_defaults [1]), methodsig->param_count * sizeof (char*));\n\t\t\tmemcpy (types, &(aux->param_default_types [1]), methodsig->param_count * sizeof (guint32));\n\t\t}\n\t\treturn;\n\t}\n\n\tmethodt = &klass->image->tables [MONO_TABLE_METHOD];\n\tparamt = &klass->image->tables [MONO_TABLE_PARAM];\n\tconstt = &image->tables [MONO_TABLE_CONSTANT];\n\n\tidx = mono_method_get_index (method) - 1;\n\tg_assert (idx != -1);\n\n\tparam_index = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\tif (idx + 1 < methodt->rows)\n\t\tlastp = mono_metadata_decode_row_col (methodt, idx + 1, MONO_METHOD_PARAMLIST);\n\telse\n\t\tlastp = paramt->rows + 1;\n\n\tfor (i = param_index; i < lastp; ++i) {\n\t\tguint32 paramseq;\n\n\t\tmono_metadata_decode_row (paramt, i - 1, param_cols, MONO_PARAM_SIZE);\n\t\tparamseq = param_cols [MONO_PARAM_SEQUENCE];\n\n\t\tif (!(param_cols [MONO_PARAM_FLAGS] & PARAM_ATTRIBUTE_HAS_DEFAULT))\n\t\t\tcontinue;\n\n\t\tcrow = mono_metadata_get_constant_index (image, MONO_TOKEN_PARAM_DEF | i, crow + 1);\n\t\tif (!crow) {\n\t\t\tcontinue;\n\t\t}\n\t\n\t\tmono_metadata_decode_row (constt, crow - 1, const_cols, MONO_CONSTANT_SIZE);\n\t\tblobs [paramseq - 1] = (gpointer) mono_metadata_blob_heap (image, const_cols [MONO_CONSTANT_VALUE]);\n\t\ttypes [paramseq - 1] = const_cols [MONO_CONSTANT_TYPE];\n\t}\n\n\treturn;\n}\n\nstatic MonoObject *\nmono_get_object_from_blob (MonoDomain *domain, MonoType *type, const char *blob)\n{\n\tvoid *retval;\n\tMonoClass *klass;\n\tMonoObject *object;\n\tMonoType *basetype = type;\n\n\tif (!blob)\n\t\treturn NULL;\n\t\n\tklass = mono_class_from_mono_type (type);\n\tif (klass->valuetype) {\n\t\tobject = mono_object_new (domain, klass);\n\t\tretval = ((gchar *) object + sizeof (MonoObject));\n\t\tif (klass->enumtype)\n\t\t\tbasetype = mono_class_enum_basetype (klass);\n\t} else {\n\t\tretval = &object;\n\t}\n\t\t\t\n\tif (!mono_get_constant_value_from_blob (domain, basetype->type,  blob, retval))\n\t\treturn object;\n\telse\n\t\treturn NULL;\n}\n\nstatic int\nassembly_name_to_aname (MonoAssemblyName *assembly, char *p) {\n\tint found_sep;\n\tchar *s;\n\n\tmemset (assembly, 0, sizeof (MonoAssemblyName));\n\tassembly->name = p;\n\tassembly->culture = \"\";\n\tmemset (assembly->public_key_token, 0, MONO_PUBLIC_KEY_TOKEN_LENGTH);\n\n\twhile (*p && (isalnum (*p) || *p == '.' || *p == '-' || *p == '_' || *p == '$' || *p == '@'))\n\t\tp++;\n\tfound_sep = 0;\n\twhile (g_ascii_isspace (*p) || *p == ',') {\n\t\t*p++ = 0;\n\t\tfound_sep = 1;\n\t\tcontinue;\n\t}\n\t/* failed */\n\tif (!found_sep)\n\t\treturn 1;\n\twhile (*p) {\n\t\tif (*p == 'V' && g_ascii_strncasecmp (p, \"Version=\", 8) == 0) {\n\t\t\tp += 8;\n\t\t\tassembly->major = strtoul (p, &s, 10);\n\t\t\tif (s == p || *s != '.')\n\t\t\t\treturn 1;\n\t\t\tp = ++s;\n\t\t\tassembly->minor = strtoul (p, &s, 10);\n\t\t\tif (s == p || *s != '.')\n\t\t\t\treturn 1;\n\t\t\tp = ++s;\n\t\t\tassembly->build = strtoul (p, &s, 10);\n\t\t\tif (s == p || *s != '.')\n\t\t\t\treturn 1;\n\t\t\tp = ++s;\n\t\t\tassembly->revision = strtoul (p, &s, 10);\n\t\t\tif (s == p)\n\t\t\t\treturn 1;\n\t\t\tp = s;\n\t\t} else if (*p == 'C' && g_ascii_strncasecmp (p, \"Culture=\", 8) == 0) {\n\t\t\tp += 8;\n\t\t\tif (g_ascii_strncasecmp (p, \"neutral\", 7) == 0) {\n\t\t\t\tassembly->culture = \"\";\n\t\t\t\tp += 7;\n\t\t\t} else {\n\t\t\t\tassembly->culture = p;\n\t\t\t\twhile (*p && *p != ',') {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (*p == 'P' && g_ascii_strncasecmp (p, \"PublicKeyToken=\", 15) == 0) {\n\t\t\tp += 15;\n\t\t\tif (strncmp (p, \"null\", 4) == 0) {\n\t\t\t\tp += 4;\n\t\t\t} else {\n\t\t\t\tint len;\n\t\t\t\tgchar *start = p;\n\t\t\t\twhile (*p && *p != ',') {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tlen = (p - start + 1);\n\t\t\t\tif (len > MONO_PUBLIC_KEY_TOKEN_LENGTH)\n\t\t\t\t\tlen = MONO_PUBLIC_KEY_TOKEN_LENGTH;\n\t\t\t\tg_strlcpy ((char*)assembly->public_key_token, start, len);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (*p && *p != ',')\n\t\t\t\tp++;\n\t\t}\n\t\tfound_sep = 0;\n\t\twhile (g_ascii_isspace (*p) || *p == ',') {\n\t\t\t*p++ = 0;\n\t\t\tfound_sep = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* failed */\n\t\tif (!found_sep)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * mono_reflection_parse_type:\n * @name: type name\n *\n * Parse a type name as accepted by the GetType () method and output the info\n * extracted in the info structure.\n * the name param will be mangled, so, make a copy before passing it to this function.\n * The fields in info will be valid until the memory pointed to by name is valid.\n *\n * See also mono_type_get_name () below.\n *\n * Returns: 0 on parse error.\n */\nstatic int\n_mono_reflection_parse_type (char *name, char **endptr, gboolean is_recursed,\n\t\t\t     MonoTypeNameParse *info)\n{\n\tchar *start, *p, *w, *temp, *last_point, *startn;\n\tint in_modifiers = 0;\n\tint isbyref = 0, rank, arity = 0, i;\n\n\tstart = p = w = name;\n\n\t//FIXME could we just zero the whole struct? memset (&info, 0, sizeof (MonoTypeNameParse))\n\tmemset (&info->assembly, 0, sizeof (MonoAssemblyName));\n\tinfo->name = info->name_space = NULL;\n\tinfo->nested = NULL;\n\tinfo->modifiers = NULL;\n\tinfo->type_arguments = NULL;\n\n\t/* last_point separates the namespace from the name */\n\tlast_point = NULL;\n\t/* Skips spaces */\n\twhile (*p == ' ') p++, start++, w++, name++;\n\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase '+':\n\t\t\t*p = 0; /* NULL terminate the name */\n\t\t\tstartn = p + 1;\n\t\t\tinfo->nested = g_list_append (info->nested, startn);\n\t\t\t/* we have parsed the nesting namespace + name */\n\t\t\tif (info->name)\n\t\t\t\tbreak;\n\t\t\tif (last_point) {\n\t\t\t\tinfo->name_space = start;\n\t\t\t\t*last_point = 0;\n\t\t\t\tinfo->name = last_point + 1;\n\t\t\t} else {\n\t\t\t\tinfo->name_space = (char *)\"\";\n\t\t\t\tinfo->name = start;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tlast_point = p;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\t++p;\n\t\t\tbreak;\n\t\tcase '&':\n\t\tcase '*':\n\t\tcase '[':\n\t\tcase ',':\n\t\tcase ']':\n\t\t\tin_modifiers = 1;\n\t\t\tbreak;\n\t\tcase '`':\n\t\t\t++p;\n\t\t\ti = strtol (p, &temp, 10);\n\t\t\tarity += i;\n\t\t\tif (p == temp)\n\t\t\t\treturn 0;\n\t\t\tp = temp-1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (in_modifiers)\n\t\t\tbreak;\n\t\t// *w++ = *p++;\n\t\tp++;\n\t}\n\t\n\tif (!info->name) {\n\t\tif (last_point) {\n\t\t\tinfo->name_space = start;\n\t\t\t*last_point = 0;\n\t\t\tinfo->name = last_point + 1;\n\t\t} else {\n\t\t\tinfo->name_space = (char *)\"\";\n\t\t\tinfo->name = start;\n\t\t}\n\t}\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase '&':\n\t\t\tif (isbyref) /* only one level allowed by the spec */\n\t\t\t\treturn 0;\n\t\t\tisbyref = 1;\n\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (0));\n\t\t\t*p++ = 0;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (-1));\n\t\t\t*p++ = 0;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tif (arity != 0) {\n\t\t\t\t*p++ = 0;\n\t\t\t\tinfo->type_arguments = g_ptr_array_new ();\n\t\t\t\tfor (i = 0; i < arity; i++) {\n\t\t\t\t\tMonoTypeNameParse *subinfo = g_new0 (MonoTypeNameParse, 1);\n\t\t\t\t\tgboolean fqname = FALSE;\n\n\t\t\t\t\tg_ptr_array_add (info->type_arguments, subinfo);\n\n\t\t\t\t\tif (*p == '[') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tfqname = TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!_mono_reflection_parse_type (p, &p, TRUE, subinfo))\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t/*MS is lenient on [] delimited parameters that aren't fqn - and F# uses them.*/\n\t\t\t\t\tif (fqname && (*p != ']')) {\n\t\t\t\t\t\tchar *aname;\n\n\t\t\t\t\t\tif (*p != ',')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t*p++ = 0;\n\n\t\t\t\t\t\taname = p;\n\t\t\t\t\t\twhile (*p && (*p != ']'))\n\t\t\t\t\t\t\tp++;\n\n\t\t\t\t\t\tif (*p != ']')\n\t\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t\t*p++ = 0;\n\t\t\t\t\t\twhile (*aname) {\n\t\t\t\t\t\t\tif (g_ascii_isspace (*aname)) {\n\t\t\t\t\t\t\t\t++aname;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!*aname ||\n\t\t\t\t\t\t    !assembly_name_to_aname (&subinfo->assembly, aname))\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else if (fqname && (*p == ']')) {\n\t\t\t\t\t\t*p++ = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < arity) {\n\t\t\t\t\t\tif (*p != ',')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (*p != ']')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t*p++ = 0;\n\t\t\t\t}\n\n\t\t\t\tarity = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trank = 1;\n\t\t\t*p++ = 0;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == ']')\n\t\t\t\t\tbreak;\n\t\t\t\tif (*p == ',')\n\t\t\t\t\trank++;\n\t\t\t\telse if (*p == '*') /* '*' means unknown lower bound */\n\t\t\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (-2));\n\t\t\t\telse\n\t\t\t\t\treturn 0;\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tif (*p++ != ']')\n\t\t\t\treturn 0;\n\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (rank));\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tif (is_recursed)\n\t\t\t\tgoto end;\n\t\t\treturn 0;\n\t\tcase ',':\n\t\t\tif (is_recursed)\n\t\t\t\tgoto end;\n\t\t\t*p++ = 0;\n\t\t\twhile (*p) {\n\t\t\t\tif (g_ascii_isspace (*p)) {\n\t\t\t\t\t++p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*p)\n\t\t\t\treturn 0; /* missing assembly name */\n\t\t\tif (!assembly_name_to_aname (&info->assembly, p))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\tif (info->assembly.name)\n\t\t\tbreak;\n\t}\n\t// *w = 0; /* terminate class name */\n end:\n\tif (!info->name || !*info->name)\n\t\treturn 0;\n\tif (endptr)\n\t\t*endptr = p;\n\t/* add other consistency checks */\n\treturn 1;\n}\n\nint\nmono_reflection_parse_type (char *name, MonoTypeNameParse *info)\n{\n\treturn _mono_reflection_parse_type (name, NULL, FALSE, info);\n}\n\nstatic MonoType*\n_mono_reflection_get_type_from_info (MonoTypeNameParse *info, MonoImage *image, gboolean ignorecase)\n{\n\tgboolean type_resolve = FALSE;\n\tMonoType *type;\n\tMonoImage *rootimage = image;\n\n\tif (info->assembly.name) {\n\t\tMonoAssembly *assembly = mono_assembly_loaded (&info->assembly);\n\t\tif (!assembly && image && image->assembly && mono_assembly_names_equal (&info->assembly, &image->assembly->aname))\n\t\t\t/* \n\t\t\t * This could happen in the AOT compiler case when the search hook is not\n\t\t\t * installed.\n\t\t\t */\n\t\t\tassembly = image->assembly;\n\t\tif (!assembly) {\n\t\t\t/* then we must load the assembly ourselve - see #60439 */\n\t\t\tassembly = mono_assembly_load (&info->assembly, NULL, NULL);\n\t\t\tif (!assembly)\n\t\t\t\treturn NULL;\n\t\t}\n\t\timage = assembly->image;\n\t} else if (!image) {\n\t\timage = mono_defaults.corlib;\n\t}\n\n\ttype = mono_reflection_get_type_with_rootimage (rootimage, image, info, ignorecase, &type_resolve);\n\tif (type == NULL && !info->assembly.name && image != mono_defaults.corlib) {\n\t\timage = mono_defaults.corlib;\n\t\ttype = mono_reflection_get_type_with_rootimage (rootimage, image, info, ignorecase, &type_resolve);\n\t}\n\n\treturn type;\n}\n\nstatic MonoType*\nmono_reflection_get_type_internal (MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase)\n{\n\tMonoClass *klass;\n\tGList *mod;\n\tint modval;\n\tgboolean bounded = FALSE;\n\t\n\tif (!image)\n\t\timage = mono_defaults.corlib;\n\n\tif (ignorecase)\n\t\tklass = mono_class_from_name_case (image, info->name_space, info->name);\n\telse\n\t\tklass = mono_class_from_name (image, info->name_space, info->name);\n\tif (!klass)\n\t\treturn NULL;\n\tfor (mod = info->nested; mod; mod = mod->next) {\n\t\tgpointer iter = NULL;\n\t\tMonoClass *parent;\n\n\t\tparent = klass;\n\t\tmono_class_init (parent);\n\n\t\twhile ((klass = mono_class_get_nested_types (parent, &iter))) {\n\t\t\tif (ignorecase) {\n\t\t\t\tif (mono_utf8_strcasecmp (klass->name, mod->data) == 0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (strcmp (klass->name, mod->data) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!klass)\n\t\t\tbreak;\n\t}\n\tif (!klass)\n\t\treturn NULL;\n\tmono_class_init (klass);\n\n\tif (info->type_arguments) {\n\t\tMonoType **type_args = g_new0 (MonoType *, info->type_arguments->len);\n\t\tMonoReflectionType *the_type;\n\t\tMonoType *instance;\n\t\tint i;\n\n\t\tfor (i = 0; i < info->type_arguments->len; i++) {\n\t\t\tMonoTypeNameParse *subinfo = g_ptr_array_index (info->type_arguments, i);\n\n\t\t\ttype_args [i] = _mono_reflection_get_type_from_info (subinfo, rootimage, ignorecase);\n\t\t\tif (!type_args [i]) {\n\t\t\t\tg_free (type_args);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tthe_type = mono_type_get_object (mono_domain_get (), &klass->byval_arg);\n\n\t\tinstance = mono_reflection_bind_generic_parameters (\n\t\t\tthe_type, info->type_arguments->len, type_args);\n\n\t\tg_free (type_args);\n\t\tif (!instance)\n\t\t\treturn NULL;\n\n\t\tklass = mono_class_from_mono_type (instance);\n\t}\n\n\tfor (mod = info->modifiers; mod; mod = mod->next) {\n\t\tmodval = GPOINTER_TO_UINT (mod->data);\n\t\tif (!modval) { /* byref: must be last modifier */\n\t\t\treturn &klass->this_arg;\n\t\t} else if (modval == -1) {\n\t\t\tklass = mono_ptr_class_get (&klass->byval_arg);\n\t\t} else if (modval == -2) {\n\t\t\tbounded = TRUE;\n\t\t} else { /* array rank */\n\t\t\tklass = mono_bounded_array_class_get (klass, modval, bounded);\n\t\t}\n\t\tmono_class_init (klass);\n\t}\n\n\treturn &klass->byval_arg;\n}\n\n/*\n * mono_reflection_get_type:\n * @image: a metadata context\n * @info: type description structure\n * @ignorecase: flag for case-insensitive string compares\n * @type_resolve: whenever type resolve was already tried\n *\n * Build a MonoType from the type description in @info.\n * \n */\n\nMonoType*\nmono_reflection_get_type (MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean *type_resolve) {\n\treturn mono_reflection_get_type_with_rootimage(image, image, info, ignorecase, type_resolve);\n}\n\nstatic MonoType*\nmono_reflection_get_type_internal_dynamic (MonoImage *rootimage, MonoAssembly *assembly, MonoTypeNameParse *info, gboolean ignorecase)\n{\n\tMonoReflectionAssemblyBuilder *abuilder;\n\tMonoType *type;\n\tint i;\n\n\tg_assert (assembly->dynamic);\n\tabuilder = (MonoReflectionAssemblyBuilder*)mono_assembly_get_object (((MonoDynamicAssembly*)assembly)->domain, assembly);\n\n\t/* Enumerate all modules */\n\n\ttype = NULL;\n\tif (abuilder->modules) {\n\t\tfor (i = 0; i < mono_array_length (abuilder->modules); ++i) {\n\t\t\tMonoReflectionModuleBuilder *mb = mono_array_get (abuilder->modules, MonoReflectionModuleBuilder*, i);\n\t\t\ttype = mono_reflection_get_type_internal (rootimage, &mb->dynamic_image->image, info, ignorecase);\n\t\t\tif (type)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!type && abuilder->loaded_modules) {\n\t\tfor (i = 0; i < mono_array_length (abuilder->loaded_modules); ++i) {\n\t\t\tMonoReflectionModule *mod = mono_array_get (abuilder->loaded_modules, MonoReflectionModule*, i);\n\t\t\ttype = mono_reflection_get_type_internal (rootimage, mod->image, info, ignorecase);\n\t\t\tif (type)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn type;\n}\n\t\nMonoType*\nmono_reflection_get_type_with_rootimage (MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean *type_resolve)\n{\n\tMonoType *type;\n\tMonoReflectionAssembly *assembly;\n\tGString *fullName;\n\tGList *mod;\n\n\tif (image && image->dynamic)\n\t\ttype = mono_reflection_get_type_internal_dynamic (rootimage, image->assembly, info, ignorecase);\n\telse\n\t\ttype = mono_reflection_get_type_internal (rootimage, image, info, ignorecase);\n\tif (type)\n\t\treturn type;\n\tif (!mono_domain_has_type_resolve (mono_domain_get ()))\n\t\treturn NULL;\n\n\tif (type_resolve) {\n\t\tif (*type_resolve) \n\t\t\treturn NULL;\n\t\telse\n\t\t\t*type_resolve = TRUE;\n\t}\n\t\n\t/* Reconstruct the type name */\n\tfullName = g_string_new (\"\");\n\tif (info->name_space && (info->name_space [0] != '\\0'))\n\t\tg_string_printf (fullName, \"%s.%s\", info->name_space, info->name);\n\telse\n\t\tg_string_printf (fullName, \"%s\", info->name);\n\tfor (mod = info->nested; mod; mod = mod->next)\n\t\tg_string_append_printf (fullName, \"+%s\", (char*)mod->data);\n\n\tassembly = mono_domain_try_type_resolve ( mono_domain_get (), fullName->str, NULL);\n\tif (assembly) {\n\t\tif (assembly->assembly->dynamic)\n\t\t\ttype = mono_reflection_get_type_internal_dynamic (rootimage, assembly->assembly, info, ignorecase);\n\t\telse\n\t\t\ttype = mono_reflection_get_type_internal (rootimage, assembly->assembly->image, \n\t\t\t\t\t\t\t\t\t\t\t\t\t  info, ignorecase);\n\t}\n\tg_string_free (fullName, TRUE);\n\treturn type;\n}\n\nvoid\nmono_reflection_free_type_info (MonoTypeNameParse *info)\n{\n\tg_list_free (info->modifiers);\n\tg_list_free (info->nested);\n\n\tif (info->type_arguments) {\n\t\tint i;\n\n\t\tfor (i = 0; i < info->type_arguments->len; i++) {\n\t\t\tMonoTypeNameParse *subinfo = g_ptr_array_index (info->type_arguments, i);\n\n\t\t\tmono_reflection_free_type_info (subinfo);\n\t\t\t/*We free the subinfo since it is allocated by _mono_reflection_parse_type*/\n\t\t\tg_free (subinfo);\n\t\t}\n\n\t\tg_ptr_array_free (info->type_arguments, TRUE);\n\t}\n}\n\n/*\n * mono_reflection_type_from_name:\n * @name: type name.\n * @image: a metadata context (can be NULL).\n *\n * Retrieves a MonoType from its @name. If the name is not fully qualified,\n * it defaults to get the type from @image or, if @image is NULL or loading\n * from it fails, uses corlib.\n * \n */\nMonoType*\nmono_reflection_type_from_name (char *name, MonoImage *image)\n{\n\tMonoType *type = NULL;\n\tMonoTypeNameParse info;\n\tchar *tmp;\n\n\t/* Make a copy since parse_type modifies its argument */\n\ttmp = g_strdup (name);\n\t\n\t/*g_print (\"requested type %s\\n\", str);*/\n\tif (mono_reflection_parse_type (tmp, &info)) {\n\t\ttype = _mono_reflection_get_type_from_info (&info, image, FALSE);\n\t}\n\n\tg_free (tmp);\n\tmono_reflection_free_type_info (&info);\n\treturn type;\n}\n\n/*\n * mono_reflection_get_token:\n *\n *   Return the metadata token of OBJ which should be an object\n * representing a metadata element.\n */\nguint32\nmono_reflection_get_token (MonoObject *obj)\n{\n\tMonoClass *klass;\n\tguint32 token = 0;\n\n\tklass = obj->vtable->klass;\n\n\tif (strcmp (klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder *)obj;\n\n\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t} else if (strcmp (klass->name, \"ConstructorBuilder\") == 0) {\n\t\tMonoReflectionCtorBuilder *mb = (MonoReflectionCtorBuilder *)obj;\n\n\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t} else if (strcmp (klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder *)obj;\n\n\t\t/* Call mono_image_create_token so the object gets added to the tokens hash table */\n\t\ttoken = mono_image_create_token (((MonoReflectionTypeBuilder*)fb->typeb)->module->dynamic_image, obj, FALSE, TRUE);\n\t} else if (strcmp (klass->name, \"TypeBuilder\") == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)obj;\n\t\ttoken = tb->table_idx | MONO_TOKEN_TYPE_DEF;\n\t} else if (strcmp (klass->name, \"MonoType\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_class_from_mono_type (type)->type_token;\n\t} else if (strcmp (klass->name, \"MonoCMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericCMethod\") == 0) {\n\t\tMonoReflectionMethod *m = (MonoReflectionMethod *)obj;\n\t\tif (m->method->is_inflated) {\n\t\t\tMonoMethodInflated *inflated = (MonoMethodInflated *) m->method;\n\t\t\treturn inflated->declaring->token;\n\t\t} else {\n\t\t\ttoken = m->method->token;\n\t\t}\n\t} else if (strcmp (klass->name, \"MonoField\") == 0) {\n\t\tMonoReflectionField *f = (MonoReflectionField*)obj;\n\n\t\tif (is_field_on_inst (f->field)) {\n\t\t\tMonoDynamicGenericClass *dgclass = (MonoDynamicGenericClass*)f->field->parent->generic_class;\n\t\t\tint field_index = f->field - dgclass->fields;\n\t\t\tMonoObject *obj;\n\n\t\t\tg_assert (field_index >= 0 && field_index < dgclass->count_fields);\n\t\t\tobj = dgclass->field_objects [field_index];\n\t\t\treturn mono_reflection_get_token (obj);\n\t\t}\n\t\ttoken = mono_class_get_field_token (f->field);\n\t} else if (strcmp (klass->name, \"MonoProperty\") == 0) {\n\t\tMonoReflectionProperty *p = (MonoReflectionProperty*)obj;\n\n\t\ttoken = mono_class_get_property_token (p->property);\n\t} else if (strcmp (klass->name, \"MonoEvent\") == 0) {\n\t\tMonoReflectionMonoEvent *p = (MonoReflectionMonoEvent*)obj;\n\n\t\ttoken = mono_class_get_event_token (p->event);\n\t} else if (strcmp (klass->name, \"ParameterInfo\") == 0) {\n\t\tMonoReflectionParameter *p = (MonoReflectionParameter*)obj;\n\t\tMonoClass *member_class = mono_object_class (p->MemberImpl);\n\t\tg_assert (mono_class_is_reflection_method_or_constructor (member_class));\n\n\t\ttoken = mono_method_get_param_token (((MonoReflectionMethod*)p->MemberImpl)->method, p->PositionImpl);\n\t} else if (strcmp (klass->name, \"Module\") == 0) {\n\t\tMonoReflectionModule *m = (MonoReflectionModule*)obj;\n\n\t\ttoken = m->token;\n\t} else if (strcmp (klass->name, \"Assembly\") == 0) {\n\t\ttoken = mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1);\n\t} else {\n\t\tgchar *msg = g_strdup_printf (\"MetadataToken is not supported for type '%s.%s'\", klass->name_space, klass->name);\n\t\tMonoException *ex = mono_get_exception_not_implemented (msg);\n\t\tg_free (msg);\n\t\tmono_raise_exception (ex);\n\t}\n\n\treturn token;\n}\n\nstatic void*\nload_cattr_value (MonoImage *image, MonoType *t, const char *p, const char **end)\n{\n\tint slen, type = t->type;\n\tMonoClass *tklass = t->data.klass;\n\nhandle_enum:\n\tswitch (type) {\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_BOOLEAN: {\n\t\tMonoBoolean *bval = g_malloc (sizeof (MonoBoolean));\n\t\t*bval = *p;\n\t\t*end = p + 1;\n\t\treturn bval;\n\t}\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2: {\n\t\tguint16 *val = g_malloc (sizeof (guint16));\n\t\t*val = read16 (p);\n\t\t*end = p + 2;\n\t\treturn val;\n\t}\n#if SIZEOF_VOID_P == 4\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n#endif\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4: {\n\t\tguint32 *val = g_malloc (sizeof (guint32));\n\t\t*val = read32 (p);\n\t\t*end = p + 4;\n\t\treturn val;\n\t}\n#if SIZEOF_VOID_P == 8\n\tcase MONO_TYPE_U: /* error out instead? this should probably not happen */\n\tcase MONO_TYPE_I:\n#endif\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8: {\n\t\tguint64 *val = g_malloc (sizeof (guint64));\n\t\t*val = read64 (p);\n\t\t*end = p + 8;\n\t\treturn val;\n\t}\n\tcase MONO_TYPE_R8: {\n\t\tdouble *val = g_malloc (sizeof (double));\n\t\treadr8 (p, val);\n\t\t*end = p + 8;\n\t\treturn val;\n\t}\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (t->data.klass->enumtype) {\n\t\t\ttype = mono_class_enum_basetype (t->data.klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tg_error (\"generic valutype %s not handled in custom attr value decoding\", t->data.klass->name);\n\t\t}\n\t\tbreak;\n\tcase MONO_TYPE_STRING:\n\t\tif (*p == (char)0xFF) {\n\t\t\t*end = p + 1;\n\t\t\treturn NULL;\n\t\t}\n\t\tslen = mono_metadata_decode_value (p, &p);\n\t\t*end = p + slen;\n\t\treturn mono_string_new_len (mono_domain_get (), p, slen);\n\tcase MONO_TYPE_CLASS: {\n\t\tchar *n;\n\t\tMonoType *t;\n\t\tif (*p == (char)0xFF) {\n\t\t\t*end = p + 1;\n\t\t\treturn NULL;\n\t\t}\nhandle_type:\n\t\tslen = mono_metadata_decode_value (p, &p);\n\t\tn = g_memdup (p, slen + 1);\n\t\tn [slen] = 0;\n\t\tt = mono_reflection_type_from_name (n, image);\n\t\tif (!t)\n\t\t\tg_warning (\"Cannot load type '%s'\", n);\n\t\tg_free (n);\n\t\t*end = p + slen;\n\t\tif (t)\n\t\t\treturn mono_type_get_object (mono_domain_get (), t);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\tcase MONO_TYPE_OBJECT: {\n\t\tchar subt = *p++;\n\t\tMonoObject *obj;\n\t\tMonoClass *subc = NULL;\n\t\tvoid *val;\n\n\t\tif (subt == 0x50) {\n\t\t\tgoto handle_type;\n\t\t} else if (subt == 0x0E) {\n\t\t\ttype = MONO_TYPE_STRING;\n\t\t\tgoto handle_enum;\n\t\t} else if (subt == 0x1D) {\n\t\t\tMonoType simple_type = {{0}};\n\t\t\tint etype = *p;\n\t\t\tp ++;\n\n\t\t\tif (etype == 0x51)\n\t\t\t\t/* See Partition II, Appendix B3 */\n\t\t\t\tetype = MONO_TYPE_OBJECT;\n\t\t\ttype = MONO_TYPE_SZARRAY;\n\t\t\tsimple_type.type = etype;\n\t\t\ttklass = mono_class_from_mono_type (&simple_type);\n\t\t\tgoto handle_enum;\n\t\t} else if (subt == 0x55) {\n\t\t\tchar *n;\n\t\t\tMonoType *t;\n\t\t\tslen = mono_metadata_decode_value (p, &p);\n\t\t\tn = g_memdup (p, slen + 1);\n\t\t\tn [slen] = 0;\n\t\t\tt = mono_reflection_type_from_name (n, image);\n\t\t\tif (!t)\n\t\t\t\tg_error (\"Cannot load type '%s'\", n);\n\t\t\tg_free (n);\n\t\t\tp += slen;\n\t\t\tsubc = mono_class_from_mono_type (t);\n\t\t} else if (subt >= MONO_TYPE_BOOLEAN && subt <= MONO_TYPE_R8) {\n\t\t\tMonoType simple_type = {{0}};\n\t\t\tsimple_type.type = subt;\n\t\t\tsubc = mono_class_from_mono_type (&simple_type);\n\t\t} else {\n\t\t\tg_error (\"Unknown type 0x%02x for object type encoding in custom attr\", subt);\n\t\t}\n\t\tval = load_cattr_value (image, &subc->byval_arg, p, end);\n\t\tobj = mono_object_new (mono_domain_get (), subc);\n\t\tmemcpy ((char*)obj + sizeof (MonoObject), val, mono_class_value_size (subc, NULL));\n\t\tg_free (val);\n\t\treturn obj;\n\t}\n\tcase MONO_TYPE_SZARRAY: {\n\t\tMonoArray *arr;\n\t\tguint32 i, alen, basetype;\n\t\talen = read32 (p);\n\t\tp += 4;\n\t\tif (alen == 0xffffffff) {\n\t\t\t*end = p;\n\t\t\treturn NULL;\n\t\t}\n\t\tarr = mono_array_new (mono_domain_get(), tklass, alen);\n\t\tbasetype = tklass->byval_arg.type;\n\t\tif (basetype == MONO_TYPE_VALUETYPE && tklass->enumtype)\n\t\t\tbasetype = mono_class_enum_basetype (tklass)->type;\n\t\tswitch (basetype)\n\t\t{\n\t\t\tcase MONO_TYPE_U1:\n\t\t\tcase MONO_TYPE_I1:\n\t\t\tcase MONO_TYPE_BOOLEAN:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tMonoBoolean val = *p++;\n\t\t\t\t\tmono_array_set (arr, MonoBoolean, i, val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_CHAR:\n\t\t\tcase MONO_TYPE_U2:\n\t\t\tcase MONO_TYPE_I2:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tguint16 val = read16 (p);\n\t\t\t\t\tmono_array_set (arr, guint16, i, val);\n\t\t\t\t\tp += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_R4:\n\t\t\tcase MONO_TYPE_U4:\n\t\t\tcase MONO_TYPE_I4:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tguint32 val = read32 (p);\n\t\t\t\t\tmono_array_set (arr, guint32, i, val);\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_R8:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tdouble val;\n\t\t\t\t\treadr8 (p, &val);\n\t\t\t\t\tmono_array_set (arr, double, i, val);\n\t\t\t\t\tp += 8;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_U8:\n\t\t\tcase MONO_TYPE_I8:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tguint64 val = read64 (p);\n\t\t\t\t\tmono_array_set (arr, guint64, i, val);\n\t\t\t\t\tp += 8;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_CLASS:\n\t\t\tcase MONO_TYPE_OBJECT:\n\t\t\tcase MONO_TYPE_STRING:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tMonoObject *item = load_cattr_value (image, &tklass->byval_arg, p, &p);\n\t\t\t\t\tmono_array_setref (arr, i, item);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_error (\"Type 0x%02x not handled in custom attr array decoding\", basetype);\n\t\t}\n\t\t*end=p;\n\t\treturn arr;\n\t}\n\tdefault:\n\t\tg_error (\"Type 0x%02x not handled in custom attr value decoding\", type);\n\t}\n\treturn NULL;\n}\n\nstatic MonoObject*\ncreate_cattr_typed_arg (MonoType *t, MonoObject *val)\n{\n\tstatic MonoClass *klass;\n\tstatic MonoMethod *ctor;\n\tMonoObject *retval;\n\tvoid *params [2], *unboxed;\n\n\tif (!klass)\n\t\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"CustomAttributeTypedArgument\");\n\tif (!ctor)\n\t\tctor = mono_class_get_method_from_name (klass, \".ctor\", 2);\n\t\n\tparams [0] = mono_type_get_object (mono_domain_get (), t);\n\tparams [1] = val;\n\tretval = mono_object_new (mono_domain_get (), klass);\n\tunboxed = mono_object_unbox (retval);\n\tmono_runtime_invoke (ctor, unboxed, params, NULL);\n\n\treturn retval;\n}\n\nstatic MonoObject*\ncreate_cattr_named_arg (void *minfo, MonoObject *typedarg)\n{\n\tstatic MonoClass *klass;\n\tstatic MonoMethod *ctor;\n\tMonoObject *retval;\n\tvoid *unboxed, *params [2];\n\n\tif (!klass)\n\t\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"CustomAttributeNamedArgument\");\n\tif (!ctor)\n\t\tctor = mono_class_get_method_from_name (klass, \".ctor\", 2);\n\n\tparams [0] = minfo;\n\tparams [1] = typedarg;\n\tretval = mono_object_new (mono_domain_get (), klass);\n\tunboxed = mono_object_unbox (retval);\n\tmono_runtime_invoke (ctor, unboxed, params, NULL);\n\n\treturn retval;\n}\n\nstatic gboolean\ntype_is_reference (MonoType *type)\n{\n\tswitch (type->type) {\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_VALUETYPE:\n\t\treturn FALSE;\n\tdefault:\n\t\treturn TRUE;\n\t}\n}\n\nstatic void\nfree_param_data (MonoMethodSignature *sig, void **params) {\n\tint i;\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tif (!type_is_reference (sig->params [i]))\n\t\t\tg_free (params [i]);\n\t}\n}\n\n/*\n * Find the field index in the metadata FieldDef table.\n */\nstatic guint32\nfind_field_index (MonoClass *klass, MonoClassField *field) {\n\tint i;\n\n\tfor (i = 0; i < klass->field.count; ++i) {\n\t\tif (field == &klass->fields [i])\n\t\t\treturn klass->field.first + 1 + i;\n\t}\n\treturn 0;\n}\n\n/*\n * Find the property index in the metadata Property table.\n */\nstatic guint32\nfind_property_index (MonoClass *klass, MonoProperty *property) {\n\tint i;\n\n\tfor (i = 0; i < klass->ext->property.count; ++i) {\n\t\tif (property == &klass->ext->properties [i])\n\t\t\treturn klass->ext->property.first + 1 + i;\n\t}\n\treturn 0;\n}\n\n/*\n * Find the event index in the metadata Event table.\n */\nstatic guint32\nfind_event_index (MonoClass *klass, MonoEvent *event) {\n\tint i;\n\n\tfor (i = 0; i < klass->ext->event.count; ++i) {\n\t\tif (event == &klass->ext->events [i])\n\t\t\treturn klass->ext->event.first + 1 + i;\n\t}\n\treturn 0;\n}\n\nstatic MonoObject*\ncreate_custom_attr (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len)\n{\n\tconst char *p = (const char*)data;\n\tconst char *named;\n\tguint32 i, j, num_named;\n\tMonoObject *attr;\n\tvoid *params_buf [32];\n\tvoid **params;\n\tMonoMethodSignature *sig;\n\n\tmono_class_init (method->klass);\n\n\tif (len == 0) {\n\t\tattr = mono_object_new (mono_domain_get (), method->klass);\n\t\tmono_runtime_invoke (method, attr, NULL, NULL);\n\t\treturn attr;\n\t}\n\n\tif (len < 2 || read16 (p) != 0x0001) /* Prolog */\n\t\treturn NULL;\n\n\t/*g_print (\"got attr %s\\n\", method->klass->name);*/\n\n\tsig = mono_method_signature (method);\n\tif (sig->param_count < 32)\n\t\tparams = params_buf;\n\telse\n\t\t/* Allocate using GC so it gets GC tracking */\n\t\tparams = mono_gc_alloc_fixed (sig->param_count * sizeof (void*), NULL);\n\n\t/* skip prolog */\n\tp += 2;\n\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i) {\n\t\tparams [i] = load_cattr_value (image, mono_method_signature (method)->params [i], p, &p);\n\t}\n\n\tnamed = p;\n\tattr = mono_object_new (mono_domain_get (), method->klass);\n\tmono_runtime_invoke (method, attr, params, NULL);\n\tfree_param_data (method->signature, params);\n\tnum_named = read16 (named);\n\tnamed += 2;\n\tfor (j = 0; j < num_named; j++) {\n\t\tgint name_len;\n\t\tchar *name, named_type, data_type;\n\t\tnamed_type = *named++;\n\t\tdata_type = *named++; /* type of data */\n\t\tif (data_type == MONO_TYPE_SZARRAY)\n\t\t\tdata_type = *named++;\n\t\tif (data_type == MONO_TYPE_ENUM) {\n\t\t\tgint type_len;\n\t\t\tchar *type_name;\n\t\t\ttype_len = mono_metadata_decode_blob_size (named, &named);\n\t\t\ttype_name = g_malloc (type_len + 1);\n\t\t\tmemcpy (type_name, named, type_len);\n\t\t\ttype_name [type_len] = 0;\n\t\t\tnamed += type_len;\n\t\t\t/* FIXME: lookup the type and check type consistency */\n\t\t\tg_free (type_name);\n\t\t}\n\t\tname_len = mono_metadata_decode_blob_size (named, &named);\n\t\tname = g_malloc (name_len + 1);\n\t\tmemcpy (name, named, name_len);\n\t\tname [name_len] = 0;\n\t\tnamed += name_len;\n\t\tif (named_type == 0x53) {\n\t\t\tMonoClassField *field = mono_class_get_field_from_name (mono_object_class (attr), name);\n\t\t\tvoid *val = load_cattr_value (image, field->type, named, &named);\n\t\t\tmono_field_set_value (attr, field, val);\n\t\t\tif (!type_is_reference (field->type))\n\t\t\t\tg_free (val);\n\t\t} else if (named_type == 0x54) {\n\t\t\tMonoProperty *prop;\n\t\t\tvoid *pparams [1];\n\t\t\tMonoType *prop_type;\n\n\t\t\tprop = mono_class_get_property_from_name (mono_object_class (attr), name);\n\t\t\t/* can we have more that 1 arg in a custom attr named property? */\n\t\t\tprop_type = prop->get? mono_method_signature (prop->get)->ret :\n\t\t\t     mono_method_signature (prop->set)->params [mono_method_signature (prop->set)->param_count - 1];\n\t\t\tpparams [0] = load_cattr_value (image, prop_type, named, &named);\n\t\t\tmono_property_set_value (prop, attr, pparams, NULL);\n\t\t\tif (!type_is_reference (prop_type))\n\t\t\t\tg_free (pparams [0]);\n\t\t}\n\t\tg_free (name);\n\t}\n\n\tif (params != params_buf)\n\t\tmono_gc_free_fixed (params);\n\n\treturn attr;\n}\n\t\n/*\n * mono_reflection_create_custom_attr_data_args:\n *\n *   Create an array of typed and named arguments from the cattr blob given by DATA.\n * TYPED_ARGS and NAMED_ARGS will contain the objects representing the arguments,\n * NAMED_ARG_INFO will contain information about the named arguments.\n */\nvoid\nmono_reflection_create_custom_attr_data_args (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len, MonoArray **typed_args, MonoArray **named_args, CattrNamedArg **named_arg_info)\n{\n\tMonoArray *typedargs, *namedargs;\n\tMonoClass *attrklass;\n\tMonoDomain *domain;\n\tconst char *p = (const char*)data;\n\tconst char *named;\n\tguint32 i, j, num_named;\n\tCattrNamedArg *arginfo = NULL;\n\n\tmono_class_init (method->klass);\n\n\t*typed_args = NULL;\n\t*named_args = NULL;\n\t*named_arg_info = NULL;\n\t\n\tdomain = mono_domain_get ();\n\n\tif (len < 2 || read16 (p) != 0x0001) /* Prolog */\n\t\treturn;\n\n\ttypedargs = mono_array_new (domain, mono_get_object_class (), mono_method_signature (method)->param_count);\n\t\n\t/* skip prolog */\n\tp += 2;\n\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i) {\n\t\tMonoObject *obj;\n\t\tvoid *val;\n\n\t\tval = load_cattr_value (image, mono_method_signature (method)->params [i], p, &p);\n\t\tobj = type_is_reference (mono_method_signature (method)->params [i]) ? \n\t\t\tval : mono_value_box (domain, mono_class_from_mono_type (mono_method_signature (method)->params [i]), val);\n\t\tmono_array_setref (typedargs, i, obj);\n\n\t\tif (!type_is_reference (mono_method_signature (method)->params [i]))\n\t\t\tg_free (val);\n\t}\n\n\tnamed = p;\n\tnum_named = read16 (named);\n\tnamedargs = mono_array_new (domain, mono_get_object_class (), num_named);\n\tnamed += 2;\n\tattrklass = method->klass;\n\n\targinfo = g_new0 (CattrNamedArg, num_named);\n\t*named_arg_info = arginfo;\n\n\tfor (j = 0; j < num_named; j++) {\n\t\tgint name_len;\n\t\tchar *name, named_type, data_type;\n\t\tnamed_type = *named++;\n\t\tdata_type = *named++; /* type of data */\n\t\tif (data_type == MONO_TYPE_SZARRAY)\n\t\t\tdata_type = *named++;\n\t\tif (data_type == MONO_TYPE_ENUM) {\n\t\t\tgint type_len;\n\t\t\tchar *type_name;\n\t\t\ttype_len = mono_metadata_decode_blob_size (named, &named);\n\t\t\ttype_name = g_malloc (type_len + 1);\n\t\t\tmemcpy (type_name, named, type_len);\n\t\t\ttype_name [type_len] = 0;\n\t\t\tnamed += type_len;\n\t\t\t/* FIXME: lookup the type and check type consistency */\n\t\t\tg_free (type_name);\n\t\t}\n\t\tname_len = mono_metadata_decode_blob_size (named, &named);\n\t\tname = g_malloc (name_len + 1);\n\t\tmemcpy (name, named, name_len);\n\t\tname [name_len] = 0;\n\t\tnamed += name_len;\n\t\tif (named_type == 0x53) {\n\t\t\tMonoObject *obj;\n\t\t\tMonoClassField *field = mono_class_get_field_from_name (attrklass, name);\n\t\t\tvoid *val;\n\n\t\t\targinfo [j].type = field->type;\n\t\t\targinfo [j].field = field;\n\n\t\t\tval = load_cattr_value (image, field->type, named, &named);\n\t\t\tobj = type_is_reference (field->type) ? val : mono_value_box (domain, mono_class_from_mono_type (field->type), val);\n\t\t\tmono_array_setref (namedargs, j, obj);\n\t\t\tif (!type_is_reference (field->type))\n\t\t\t\tg_free (val);\n\t\t} else if (named_type == 0x54) {\n\t\t\tMonoObject *obj;\n\t\t\tMonoType *prop_type;\n\t\t\tMonoProperty *prop = mono_class_get_property_from_name (attrklass, name);\n\t\t\tvoid *val;\n\n\t\t\tprop_type = prop->get? mono_method_signature (prop->get)->ret :\n\t\t\t     mono_method_signature (prop->set)->params [mono_method_signature (prop->set)->param_count - 1];\n\n\t\t\targinfo [j].type = prop_type;\n\t\t\targinfo [j].prop = prop;\n\n\t\t\tval = load_cattr_value (image, prop_type, named, &named);\n\t\t\tobj = type_is_reference (prop_type) ? val : mono_value_box (domain, mono_class_from_mono_type (prop_type), val);\n\t\t\tmono_array_setref (namedargs, j, obj);\n\t\t\tif (!type_is_reference (prop_type))\n\t\t\t\tg_free (val);\n\t\t}\n\t\tg_free (name);\n\t}\n\n\t*typed_args = typedargs;\n\t*named_args = namedargs;\n}\n\nstatic MonoObject*\ncreate_custom_attr_data (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len)\n{\n\tMonoArray *typedargs, *namedargs;\n\tstatic MonoMethod *ctor;\n\tMonoDomain *domain;\n\tMonoObject *attr;\n\tvoid *params [3];\n\tCattrNamedArg *arginfo;\n\tint i;\n\n\tmono_class_init (method->klass);\n\n\tif (!ctor)\n\t\tctor = mono_class_get_method_from_name (mono_defaults.customattribute_data_class, \".ctor\", 3);\n\n\tdomain = mono_domain_get ();\n\tif (len == 0) {\n\t\t/* This is for Attributes with no parameters */\n\t\tattr = mono_object_new (domain, mono_defaults.customattribute_data_class);\n\t\tparams [0] = mono_method_get_object (domain, method, NULL);\n\t\tparams [1] = params [2] = NULL;\n\t\tmono_runtime_invoke (method, attr, params, NULL);\n\t\treturn attr;\n\t}\n\n\tmono_reflection_create_custom_attr_data_args (image, method, data, len, &typedargs, &namedargs, &arginfo);\n\tif (!typedargs || !namedargs)\n\t\treturn NULL;\n\n\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i) {\n\t\tMonoObject *obj = mono_array_get (typedargs, MonoObject*, i);\n\t\tMonoObject *typedarg;\n\n\t\ttypedarg = create_cattr_typed_arg (mono_method_signature (method)->params [i], obj);\n\t\tmono_array_setref (typedargs, i, typedarg);\n\t}\n\n\tfor (i = 0; i < mono_array_length (namedargs); ++i) {\n\t\tMonoObject *obj = mono_array_get (namedargs, MonoObject*, i);\n\t\tMonoObject *typedarg, *namedarg, *minfo;\n\n\t\tif (arginfo [i].prop)\n\t\t\tminfo = (MonoObject*)mono_property_get_object (domain, NULL, arginfo [i].prop);\n\t\telse\n\t\t\tminfo = (MonoObject*)mono_field_get_object (domain, NULL, arginfo [i].field);\n\n\t\ttypedarg = create_cattr_typed_arg (arginfo [i].type, obj);\n\t\tnamedarg = create_cattr_named_arg (minfo, typedarg);\n\n\t\tmono_array_setref (namedargs, i, namedarg);\n\t}\n\n\tattr = mono_object_new (domain, mono_defaults.customattribute_data_class);\n\tparams [0] = mono_method_get_object (domain, method, NULL);\n\tparams [1] = typedargs;\n\tparams [2] = namedargs;\n\tmono_runtime_invoke (ctor, attr, params, NULL);\n\treturn attr;\n}\n\nMonoArray*\nmono_custom_attrs_construct (MonoCustomAttrInfo *cinfo)\n{\n\tMonoArray *result;\n\tMonoObject *attr;\n\tint i;\n\n\tresult = mono_array_new_cached (mono_domain_get (), mono_defaults.attribute_class, cinfo->num_attrs);\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tif (!cinfo->attrs [i].ctor)\n\t\t\t/* The cattr type is not finished yet */\n\t\t\t/* We should include the type name but cinfo doesn't contain it */\n\t\t\tmono_raise_exception (mono_get_exception_type_load (NULL, NULL));\n\t\tattr = create_custom_attr (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);\n\t\tmono_array_setref (result, i, attr);\n\t}\n\treturn result;\n}\n\nstatic MonoArray*\nmono_custom_attrs_construct_by_type (MonoCustomAttrInfo *cinfo, MonoClass *attr_klass)\n{\n\tMonoArray *result;\n\tMonoObject *attr;\n\tint i, n;\n\n\tn = 0;\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tif (mono_class_is_assignable_from (attr_klass, cinfo->attrs [i].ctor->klass))\n\t\t\tn ++;\n\t}\n\n\tresult = mono_array_new_cached (mono_domain_get (), mono_defaults.attribute_class, n);\n\tn = 0;\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tif (mono_class_is_assignable_from (attr_klass, cinfo->attrs [i].ctor->klass)) {\n\t\t\tattr = create_custom_attr (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);\n\t\t\tmono_array_setref (result, n, attr);\n\t\t\tn ++;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic MonoArray*\nmono_custom_attrs_data_construct (MonoCustomAttrInfo *cinfo)\n{\n\tMonoArray *result;\n\tMonoObject *attr;\n\tint i;\n\t\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.customattribute_data_class, cinfo->num_attrs);\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tattr = create_custom_attr_data (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);\n\t\tmono_array_setref (result, i, attr);\n\t}\n\treturn result;\n}\n\n/**\n * mono_custom_attrs_from_index:\n *\n * Returns: NULL if no attributes are found or if a loading error occurs.\n */\nMonoCustomAttrInfo*\nmono_custom_attrs_from_index (MonoImage *image, guint32 idx)\n{\n\tguint32 mtoken, i, len;\n\tguint32 cols [MONO_CUSTOM_ATTR_SIZE];\n\tMonoTableInfo *ca;\n\tMonoCustomAttrInfo *ainfo;\n\tGList *tmp, *list = NULL;\n\tconst char *data;\n\n\tca = &image->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\n\ti = mono_metadata_custom_attrs_from_index (image, idx);\n\tif (!i)\n\t\treturn NULL;\n\ti --;\n\twhile (i < ca->rows) {\n\t\tif (mono_metadata_decode_row_col (ca, i, MONO_CUSTOM_ATTR_PARENT) != idx)\n\t\t\tbreak;\n\t\tlist = g_list_prepend (list, GUINT_TO_POINTER (i));\n\t\t++i;\n\t}\n\tlen = g_list_length (list);\n\tif (!len)\n\t\treturn NULL;\n\tainfo = g_malloc0 (MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * len);\n\tainfo->num_attrs = len;\n\tainfo->image = image;\n\tfor (i = 0, tmp = list; i < len; ++i, tmp = tmp->next) {\n\t\tmono_metadata_decode_row (ca, GPOINTER_TO_UINT (tmp->data), cols, MONO_CUSTOM_ATTR_SIZE);\n\t\tmtoken = cols [MONO_CUSTOM_ATTR_TYPE] >> MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\tswitch (cols [MONO_CUSTOM_ATTR_TYPE] & MONO_CUSTOM_ATTR_TYPE_MASK) {\n\t\tcase MONO_CUSTOM_ATTR_TYPE_METHODDEF:\n\t\t\tmtoken |= MONO_TOKEN_METHOD_DEF;\n\t\t\tbreak;\n\t\tcase MONO_CUSTOM_ATTR_TYPE_MEMBERREF:\n\t\t\tmtoken |= MONO_TOKEN_MEMBER_REF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_error (\"Unknown table for custom attr type %08x\", cols [MONO_CUSTOM_ATTR_TYPE]);\n\t\t\tbreak;\n\t\t}\n\t\tainfo->attrs [i].ctor = mono_get_method (image, mtoken, NULL);\n\t\tif (!ainfo->attrs [i].ctor) {\n\t\t\tg_warning (\"Can't find custom attr constructor image: %s mtoken: 0x%08x\", image->name, mtoken);\n\t\t\tg_list_free (list);\n\t\t\tg_free (ainfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tdata = mono_metadata_blob_heap (image, cols [MONO_CUSTOM_ATTR_VALUE]);\n\t\tainfo->attrs [i].data_size = mono_metadata_decode_value (data, &data);\n\t\tainfo->attrs [i].data = (guchar*)data;\n\t}\n\tg_list_free (list);\n\n\treturn ainfo;\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_method (MonoMethod *method)\n{\n\tguint32 idx;\n\n\t/*\n\t * An instantiated method has the same cattrs as the generic method definition.\n\t *\n\t * LAMESPEC: The .NET SRE throws an exception for instantiations of generic method builders\n\t *           Note that this stanza is not necessary for non-SRE types, but it's a micro-optimization\n\t */\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\t\n\tif (method->dynamic || method->klass->image->dynamic)\n\t\treturn lookup_custom_attr (method->klass->image, method);\n\n\tif (!method->token)\n\t\t/* Synthetic methods */\n\t\treturn NULL;\n\n\tidx = mono_method_get_index (method);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_METHODDEF;\n\treturn mono_custom_attrs_from_index (method->klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_class (MonoClass *klass)\n{\n\tguint32 idx;\n\n\tif (klass->generic_class)\n\t\tklass = klass->generic_class->container_class;\n\n\tif (klass->image->dynamic)\n\t\treturn lookup_custom_attr (klass->image, klass);\n\n\tif (klass->byval_arg.type == MONO_TYPE_VAR || klass->byval_arg.type == MONO_TYPE_MVAR) {\n\t\tidx = mono_metadata_token_index (klass->sizes.generic_param_token);\n\t\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\t\tidx |= MONO_CUSTOM_ATTR_GENERICPAR;\n\t} else {\n\t\tidx = mono_metadata_token_index (klass->type_token);\n\t\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\t\tidx |= MONO_CUSTOM_ATTR_TYPEDEF;\n\t}\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_assembly (MonoAssembly *assembly)\n{\n\tguint32 idx;\n\t\n\tif (assembly->image->dynamic)\n\t\treturn lookup_custom_attr (assembly->image, assembly);\n\tidx = 1; /* there is only one assembly */\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_ASSEMBLY;\n\treturn mono_custom_attrs_from_index (assembly->image, idx);\n}\n\nstatic MonoCustomAttrInfo*\nmono_custom_attrs_from_module (MonoImage *image)\n{\n\tguint32 idx;\n\t\n\tif (image->dynamic)\n\t\treturn lookup_custom_attr (image, image);\n\tidx = 1; /* there is only one module */\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_MODULE;\n\treturn mono_custom_attrs_from_index (image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_property (MonoClass *klass, MonoProperty *property)\n{\n\tguint32 idx;\n\t\n\tif (klass->image->dynamic) {\n\t\tproperty = mono_metadata_get_corresponding_property_from_generic_type_definition (property);\n\t\treturn lookup_custom_attr (klass->image, property);\n\t}\n\tidx = find_property_index (klass, property);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_PROPERTY;\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_event (MonoClass *klass, MonoEvent *event)\n{\n\tguint32 idx;\n\t\n\tif (klass->image->dynamic) {\n\t\tevent = mono_metadata_get_corresponding_event_from_generic_type_definition (event);\n\t\treturn lookup_custom_attr (klass->image, event);\n\t}\n\tidx = find_event_index (klass, event);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_EVENT;\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_field (MonoClass *klass, MonoClassField *field)\n{\n\tguint32 idx;\n\tif (klass->image->dynamic) {\n\t\tfield = mono_metadata_get_corresponding_field_from_generic_type_definition (field);\n\t\treturn lookup_custom_attr (klass->image, field);\n\t}\n\tidx = find_field_index (klass, field);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_FIELDDEF;\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_param (MonoMethod *method, guint32 param)\n{\n\tMonoTableInfo *ca;\n\tguint32 i, idx, method_index;\n\tguint32 param_list, param_last, param_pos, found;\n\tMonoImage *image;\n\tMonoReflectionMethodAux *aux;\n\n\t/*\n\t * An instantiated method has the same cattrs as the generic method definition.\n\t *\n\t * LAMESPEC: The .NET SRE throws an exception for instantiations of generic method builders\n\t *           Note that this stanza is not necessary for non-SRE types, but it's a micro-optimization\n\t */\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoCustomAttrInfo *res, *ainfo;\n\t\tint size;\n\n\t\taux = g_hash_table_lookup (((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (!aux || !aux->param_cattr)\n\t\t\treturn NULL;\n\n\t\t/* Need to copy since it will be freed later */\n\t\tainfo = aux->param_cattr [param];\n\t\tif (!ainfo)\n\t\t\treturn NULL;\n\t\tsize = MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * ainfo->num_attrs;\n\t\tres = g_malloc0 (size);\n\t\tmemcpy (res, ainfo, size);\n\t\treturn res;\n\t}\n\n\timage = method->klass->image;\n\tmethod_index = mono_method_get_index (method);\n\tca = &image->tables [MONO_TABLE_METHOD];\n\n\tparam_list = mono_metadata_decode_row_col (ca, method_index - 1, MONO_METHOD_PARAMLIST);\n\tif (method_index == ca->rows) {\n\t\tca = &image->tables [MONO_TABLE_PARAM];\n\t\tparam_last = ca->rows + 1;\n\t} else {\n\t\tparam_last = mono_metadata_decode_row_col (ca, method_index, MONO_METHOD_PARAMLIST);\n\t\tca = &image->tables [MONO_TABLE_PARAM];\n\t}\n\tfound = FALSE;\n\tfor (i = param_list; i < param_last; ++i) {\n\t\tparam_pos = mono_metadata_decode_row_col (ca, i - 1, MONO_PARAM_SEQUENCE);\n\t\tif (param_pos == param) {\n\t\t\tfound = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn NULL;\n\tidx = i;\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_PARAMDEF;\n\treturn mono_custom_attrs_from_index (image, idx);\n}\n\ngboolean\nmono_custom_attrs_has_attr (MonoCustomAttrInfo *ainfo, MonoClass *attr_klass)\n{\n\tint i;\n\tMonoClass *klass;\n\tfor (i = 0; i < ainfo->num_attrs; ++i) {\n\t\tklass = ainfo->attrs [i].ctor->klass;\n\t\tif (mono_class_has_parent (klass, attr_klass) || (MONO_CLASS_IS_INTERFACE (attr_klass) && mono_class_is_assignable_from (attr_klass, klass)))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nMonoObject*\nmono_custom_attrs_get_attr (MonoCustomAttrInfo *ainfo, MonoClass *attr_klass)\n{\n\tint i, attr_index;\n\tMonoClass *klass;\n\tMonoArray *attrs;\n\n\tattr_index = -1;\n\tfor (i = 0; i < ainfo->num_attrs; ++i) {\n\t\tklass = ainfo->attrs [i].ctor->klass;\n\t\tif (mono_class_has_parent (klass, attr_klass)) {\n\t\t\tattr_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (attr_index == -1)\n\t\treturn NULL;\n\n\tattrs = mono_custom_attrs_construct (ainfo);\n\tif (attrs)\n\t\treturn mono_array_get (attrs, MonoObject*, attr_index);\n\telse\n\t\treturn NULL;\n}\n\n/*\n * mono_reflection_get_custom_attrs_info:\n * @obj: a reflection object handle\n *\n * Return the custom attribute info for attributes defined for the\n * reflection handle @obj. The objects.\n *\n * FIXME this function leaks like a sieve for SRE objects.\n */\nMonoCustomAttrInfo*\nmono_reflection_get_custom_attrs_info (MonoObject *obj)\n{\n\tMonoClass *klass;\n\tMonoCustomAttrInfo *cinfo = NULL;\n\t\n\tklass = obj->vtable->klass;\n\tif (klass == mono_defaults.monotype_class) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\tklass = mono_class_from_mono_type (type);\n\t\tcinfo = mono_custom_attrs_from_class (klass);\n\t} else if (strcmp (\"Assembly\", klass->name) == 0) {\n\t\tMonoReflectionAssembly *rassembly = (MonoReflectionAssembly*)obj;\n\t\tcinfo = mono_custom_attrs_from_assembly (rassembly->assembly);\n\t} else if (strcmp (\"Module\", klass->name) == 0) {\n\t\tMonoReflectionModule *module = (MonoReflectionModule*)obj;\n\t\tcinfo = mono_custom_attrs_from_module (module->image);\n\t} else if (strcmp (\"MonoProperty\", klass->name) == 0) {\n\t\tMonoReflectionProperty *rprop = (MonoReflectionProperty*)obj;\n\t\tcinfo = mono_custom_attrs_from_property (rprop->property->parent, rprop->property);\n\t} else if (strcmp (\"MonoEvent\", klass->name) == 0) {\n\t\tMonoReflectionMonoEvent *revent = (MonoReflectionMonoEvent*)obj;\n\t\tcinfo = mono_custom_attrs_from_event (revent->event->parent, revent->event);\n\t} else if (strcmp (\"MonoField\", klass->name) == 0) {\n\t\tMonoReflectionField *rfield = (MonoReflectionField*)obj;\n\t\tcinfo = mono_custom_attrs_from_field (rfield->field->parent, rfield->field);\n\t} else if ((strcmp (\"MonoMethod\", klass->name) == 0) || (strcmp (\"MonoCMethod\", klass->name) == 0)) {\n\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)obj;\n\t\tcinfo = mono_custom_attrs_from_method (rmethod->method);\n\t} else if ((strcmp (\"MonoGenericMethod\", klass->name) == 0) || (strcmp (\"MonoGenericCMethod\", klass->name) == 0)) {\n\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)obj;\n\t\tcinfo = mono_custom_attrs_from_method (rmethod->method);\n\t} else if (strcmp (\"ParameterInfo\", klass->name) == 0) {\n\t\tMonoReflectionParameter *param = (MonoReflectionParameter*)obj;\n\t\tMonoClass *member_class = mono_object_class (param->MemberImpl);\n\t\tif (mono_class_is_reflection_method_or_constructor (member_class)) {\n\t\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)param->MemberImpl;\n\t\t\tcinfo = mono_custom_attrs_from_param (rmethod->method, param->PositionImpl + 1);\n\t\t} else if (is_sr_mono_property (member_class)) {\n\t\t\tMonoReflectionProperty *prop = (MonoReflectionProperty *)param->MemberImpl;\n\t\t\tMonoMethod *method;\n\t\t\tif (!(method = prop->property->get))\n\t\t\t\tmethod = prop->property->set;\n\t\t\tg_assert (method);\n\n\t\t\tcinfo = mono_custom_attrs_from_param (method, param->PositionImpl + 1);\n\t\t} else if (is_sre_method_on_tb_inst (member_class)) {/*XXX This is a workaround for Compiler Context*/\n\t\t\tMonoMethod *method = mono_reflection_method_on_tb_inst_get_handle ((MonoReflectionMethodOnTypeBuilderInst*)param->MemberImpl);\n\t\t\tcinfo = mono_custom_attrs_from_param (method, param->PositionImpl + 1);\n\t\t} else if (is_sre_ctor_on_tb_inst (member_class)) { /*XX This is a workaround for Compiler Context*/\n\t\tMonoReflectionCtorOnTypeBuilderInst *c = (MonoReflectionCtorOnTypeBuilderInst*)param->MemberImpl;\n\t\t\tMonoMethod *method = NULL;\n\t\t\tif (is_sre_ctor_builder (mono_object_class (c->cb)))\n\t\t\t\tmethod = ((MonoReflectionCtorBuilder *)c->cb)->mhandle;\n\t\t\telse if (is_sr_mono_cmethod (mono_object_class (c->cb)))\n\t\t\t\tmethod = ((MonoReflectionMethod *)c->cb)->method;\n\t\t\telse\n\t\t\t\tg_error (\"mono_reflection_get_custom_attrs_info:: can't handle a CTBI with base_method of type %s\", mono_type_get_full_name (member_class));\n\n\t\t\tcinfo = mono_custom_attrs_from_param (method, param->PositionImpl + 1);\n\t\t} else {\n\t\t\tchar *type_name = mono_type_get_full_name (member_class);\n\t\t\tchar *msg = g_strdup_printf (\"Custom attributes on a ParamInfo with member %s are not supported\", type_name);\n\t\t\tMonoException *ex = mono_get_exception_not_supported  (msg);\n\t\t\tg_free (type_name);\n\t\t\tg_free (msg);\n\t\t\tmono_raise_exception (ex);\n\t\t}\n\t} else if (strcmp (\"AssemblyBuilder\", klass->name) == 0) {\n\t\tMonoReflectionAssemblyBuilder *assemblyb = (MonoReflectionAssemblyBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, assemblyb->assembly.assembly->image, assemblyb->cattrs);\n\t} else if (strcmp (\"TypeBuilder\", klass->name) == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, &tb->module->dynamic_image->image, tb->cattrs);\n\t} else if (strcmp (\"ModuleBuilder\", klass->name) == 0) {\n\t\tMonoReflectionModuleBuilder *mb = (MonoReflectionModuleBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, &mb->dynamic_image->image, mb->cattrs);\n\t} else if (strcmp (\"ConstructorBuilder\", klass->name) == 0) {\n\t\tMonoReflectionCtorBuilder *cb = (MonoReflectionCtorBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, cb->mhandle->klass->image, cb->cattrs);\n\t} else if (strcmp (\"MethodBuilder\", klass->name) == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, mb->mhandle->klass->image, mb->cattrs);\n\t} else if (strcmp (\"FieldBuilder\", klass->name) == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, &((MonoReflectionTypeBuilder*)fb->typeb)->module->dynamic_image->image, fb->cattrs);\n\t} else if (strcmp (\"MonoGenericClass\", klass->name) == 0) {\n\t\tMonoReflectionGenericClass *gclass = (MonoReflectionGenericClass*)obj;\n\t\tcinfo = mono_reflection_get_custom_attrs_info ((MonoObject*)gclass->generic_type);\n\t} else { /* handle other types here... */\n\t\tg_error (\"get custom attrs not yet supported for %s\", klass->name);\n\t}\n\n\treturn cinfo;\n}\n\n/*\n * mono_reflection_get_custom_attrs_by_type:\n * @obj: a reflection object handle\n *\n * Return an array with all the custom attributes defined of the\n * reflection handle @obj. If @attr_klass is non-NULL, only custom attributes \n * of that type are returned. The objects are fully build. Return NULL if a loading error\n * occurs.\n */\nMonoArray*\nmono_reflection_get_custom_attrs_by_type (MonoObject *obj, MonoClass *attr_klass)\n{\n\tMonoArray *result;\n\tMonoCustomAttrInfo *cinfo;\n\n\tcinfo = mono_reflection_get_custom_attrs_info (obj);\n\tif (cinfo) {\n\t\tif (attr_klass)\n\t\t\tresult = mono_custom_attrs_construct_by_type (cinfo, attr_klass);\n\t\telse\n\t\t\tresult = mono_custom_attrs_construct (cinfo);\n\t\tif (!cinfo->cached)\n\t\t\tmono_custom_attrs_free (cinfo);\n\t} else {\n\t\tif (mono_loader_get_last_error ())\n\t\t\treturn NULL;\n\t\tresult = mono_array_new_cached (mono_domain_get (), mono_defaults.attribute_class, 0);\n\t}\n\n\treturn result;\n}\n\n/*\n * mono_reflection_get_custom_attrs:\n * @obj: a reflection object handle\n *\n * Return an array with all the custom attributes defined of the\n * reflection handle @obj. The objects are fully build. Return NULL if a loading error\n * occurs.\n */\nMonoArray*\nmono_reflection_get_custom_attrs (MonoObject *obj)\n{\n\treturn mono_reflection_get_custom_attrs_by_type (obj, NULL);\n}\n\n/*\n * mono_reflection_get_custom_attrs_data:\n * @obj: a reflection obj handle\n *\n * Returns an array of System.Reflection.CustomAttributeData,\n * which include information about attributes reflected on\n * types loaded using the Reflection Only methods\n */\nMonoArray*\nmono_reflection_get_custom_attrs_data (MonoObject *obj)\n{\n\tMonoArray *result;\n\tMonoCustomAttrInfo *cinfo;\n\n\tcinfo = mono_reflection_get_custom_attrs_info (obj);\n\tif (cinfo) {\n\t\tresult = mono_custom_attrs_data_construct (cinfo);\n\t\tif (!cinfo->cached)\n\t\t\tmono_custom_attrs_free (cinfo);\n\t} else\n\t\tresult = mono_array_new (mono_domain_get (), mono_defaults.customattribute_data_class, 0);\n\n\treturn result;\n}\n\nstatic MonoReflectionType*\nmono_reflection_type_get_underlying_system_type (MonoReflectionType* t)\n{\n        MonoMethod *method_get_underlying_system_type;\n\n        method_get_underlying_system_type = mono_object_get_virtual_method ((MonoObject *) t,\n                                                                            mono_class_get_method_from_name (mono_object_class (t),\n                                                                                                             \"get_UnderlyingSystemType\",\n                                                                                                             0));\n        return (MonoReflectionType *) mono_runtime_invoke (method_get_underlying_system_type, t, NULL, NULL);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n\nstatic gboolean\nis_corlib_type (MonoClass *class)\n{\n\treturn class->image == mono_defaults.corlib;\n}\n\nstatic gboolean\nis_usertype (MonoReflectionType *ref)\n{\n\tMonoClass *class = mono_object_class (ref);\n\treturn class->image != mono_defaults.corlib || strcmp (\"TypeDelegator\", class->name) == 0;\n}\n\n#define check_corlib_type_cached(_class, _namespace, _name) do { \\\n\tstatic MonoClass *cached_class; \\\n\tif (cached_class) \\\n\t\treturn cached_class == _class; \\\n\tif (is_corlib_type (_class) && !strcmp (_name, _class->name) && !strcmp (_namespace, _class->name_space)) { \\\n\t\tcached_class = _class; \\\n\t\treturn TRUE; \\\n\t} \\\n\treturn FALSE; \\\n} while (0) \\\n\nstatic gboolean\nis_sre_array (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ArrayType\");\n}\n\nstatic gboolean\nis_sre_byref (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ByRefType\");\n}\n\nstatic gboolean\nis_sre_pointer (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"PointerType\");\n}\n\nstatic gboolean\nis_sre_generic_instance (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoGenericClass\");\n}\n\nstatic gboolean\nis_sre_method_builder (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"MethodBuilder\");\n}\n\nstatic gboolean\nis_sre_ctor_builder (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ConstructorBuilder\");\n}\n\nstatic gboolean\nis_sr_mono_method (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoMethod\");\n}\n\nstatic gboolean\nis_sr_mono_cmethod (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoCMethod\");\n}\n\nstatic gboolean\nis_sr_mono_generic_method (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoGenericMethod\");\n}\n\nstatic gboolean\nis_sr_mono_generic_cmethod (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoGenericCMethod\");\n}\n\nstatic gboolean\nis_sr_mono_property (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoProperty\");\n}\n\nstatic gboolean\nis_sre_method_on_tb_inst (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"MethodOnTypeBuilderInst\");\n}\n\nstatic gboolean\nis_sre_ctor_on_tb_inst (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ConstructorOnTypeBuilderInst\");\n}\n\ngboolean\nmono_class_is_reflection_method_or_constructor (MonoClass *class)\n{\n\treturn is_sr_mono_method (class) || is_sr_mono_cmethod (class) || is_sr_mono_generic_method (class) || is_sr_mono_generic_cmethod (class);\n}\nMonoType*\nmono_reflection_type_get_handle (MonoReflectionType* ref)\n{\n\tMonoClass *class;\n\tif (!ref)\n\t\treturn NULL;\n\tif (ref->type)\n\t\treturn ref->type;\n\n\tif (is_usertype (ref)) {\n\t\tref = mono_reflection_type_get_underlying_system_type (ref);\n\t\tg_assert (!is_usertype (ref)); /*FIXME fail better*/\n\t\tif (ref->type)\n\t\t\treturn ref->type;\n\t}\n\n\tclass = mono_object_class (ref);\n\n\tif (is_sre_array (class)) {\n\t\tMonoType *res;\n\t\tMonoReflectionArrayType *sre_array = (MonoReflectionArrayType*)ref;\n\t\tMonoType *base = mono_reflection_type_get_handle (sre_array->element_type);\n\t\tg_assert (base);\n\t\tif (sre_array->rank == 0) //single dimentional array\n\t\t\tres = &mono_array_class_get (mono_class_from_mono_type (base), 1)->byval_arg;\n\t\telse\n\t\t\tres = &mono_bounded_array_class_get (mono_class_from_mono_type (base), sre_array->rank, TRUE)->byval_arg;\n\t\tsre_array->type.type = res;\n\t\treturn res;\n\t} else if (is_sre_byref (class)) {\n\t\tMonoType *res;\n\t\tMonoReflectionDerivedType *sre_byref = (MonoReflectionDerivedType*)ref;\n\t\tMonoType *base = mono_reflection_type_get_handle (sre_byref->element_type);\n\t\tg_assert (base);\n\t\tres = &mono_class_from_mono_type (base)->this_arg;\n\t\tsre_byref->type.type = res;\n\t\treturn res;\n\t} else if (is_sre_pointer (class)) {\n\t\tMonoType *res;\n\t\tMonoReflectionDerivedType *sre_pointer = (MonoReflectionDerivedType*)ref;\n\t\tMonoType *base = mono_reflection_type_get_handle (sre_pointer->element_type);\n\t\tg_assert (base);\n\t\tres = &mono_ptr_class_get (base)->byval_arg;\n\t\tsre_pointer->type.type = res;\n\t\treturn res;\n\t} else if (is_sre_generic_instance (class)) {\n\t\tMonoType *res, **types;\n\t\tMonoReflectionGenericClass *gclass = (MonoReflectionGenericClass*)ref;\n\t\tint i, count;\n\n\t\tcount = mono_array_length (gclass->type_arguments);\n\t\ttypes = g_new0 (MonoType*, count);\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tMonoReflectionType *t = mono_array_get (gclass->type_arguments, gpointer, i);\n\t\t\ttypes [i] = mono_reflection_type_get_handle (t);\n\t\t}\n\n\t\tres = mono_reflection_bind_generic_parameters ((MonoReflectionType*)gclass->generic_type, count, types);\n\t\tg_free (types);\n\t\tg_assert (res);\n\t\tgclass->type.type = res;\n\t\treturn res;\n\t}\n\n\tg_error (\"Cannot handle corlib user type %s\", mono_type_full_name (&mono_object_class(ref)->byval_arg));\n\treturn NULL;\n}\n\nstatic MonoReflectionType*\nmono_reflection_type_resolve_user_types (MonoReflectionType *type)\n{\n\tif (!type || type->type)\n\t\treturn type;\n\n\tif (is_usertype (type)) {\n\t\ttype = mono_reflection_type_get_underlying_system_type (type);\n\t\tif (is_usertype (type))\n\t\t\tmono_raise_exception (mono_get_exception_not_supported (\"User defined subclasses of System.Type are not yet supported22\"));\n\t}\n\n\treturn type;\n}\n\nvoid\nmono_reflection_create_unmanaged_type (MonoReflectionType *type)\n{\n\tmono_reflection_type_get_handle (type);\n}\n\n/**\n * LOCKING: Assumes the loader lock is held.\n */\nstatic MonoMethodSignature*\nparameters_to_signature (MonoImage *image, MonoArray *parameters) {\n\tMonoMethodSignature *sig;\n\tint count, i;\n\n\tcount = parameters? mono_array_length (parameters): 0;\n\n\tsig = image_g_malloc0 (image, MONO_SIZEOF_METHOD_SIGNATURE + sizeof (MonoType*) * count);\n\tsig->param_count = count;\n\tsig->sentinelpos = -1; /* FIXME */\n\tfor (i = 0; i < count; ++i)\n\t\tsig->params [i] = mono_type_array_get_and_resolve (parameters, i);\n\treturn sig;\n}\n\n/**\n * LOCKING: Assumes the loader lock is held.\n */\nstatic MonoMethodSignature*\nctor_builder_to_signature (MonoImage *image, MonoReflectionCtorBuilder *ctor) {\n\tMonoMethodSignature *sig;\n\n\tsig = parameters_to_signature (image, ctor->parameters);\n\tsig->hasthis = ctor->attrs & METHOD_ATTRIBUTE_STATIC? 0: 1;\n\tsig->ret = &mono_defaults.void_class->byval_arg;\n\treturn sig;\n}\n\n/**\n * LOCKING: Assumes the loader lock is held.\n */\nstatic MonoMethodSignature*\nmethod_builder_to_signature (MonoImage *image, MonoReflectionMethodBuilder *method) {\n\tMonoMethodSignature *sig;\n\n\tsig = parameters_to_signature (image, method->parameters);\n\tsig->hasthis = method->attrs & METHOD_ATTRIBUTE_STATIC? 0: 1;\n\tsig->ret = method->rtype? mono_reflection_type_get_handle ((MonoReflectionType*)method->rtype): &mono_defaults.void_class->byval_arg;\n\tsig->generic_param_count = method->generic_params ? mono_array_length (method->generic_params) : 0;\n\treturn sig;\n}\n\nstatic MonoMethodSignature*\ndynamic_method_to_signature (MonoReflectionDynamicMethod *method) {\n\tMonoMethodSignature *sig;\n\n\tsig = parameters_to_signature (NULL, method->parameters);\n\tsig->hasthis = method->attrs & METHOD_ATTRIBUTE_STATIC? 0: 1;\n\tsig->ret = method->rtype? mono_reflection_type_get_handle (method->rtype): &mono_defaults.void_class->byval_arg;\n\tsig->generic_param_count = 0;\n\treturn sig;\n}\n\nstatic void\nget_prop_name_and_type (MonoObject *prop, char **name, MonoType **type)\n{\n\tMonoClass *klass = mono_object_class (prop);\n\tif (strcmp (klass->name, \"PropertyBuilder\") == 0) {\n\t\tMonoReflectionPropertyBuilder *pb = (MonoReflectionPropertyBuilder *)prop;\n\t\t*name = mono_string_to_utf8 (pb->name);\n\t\t*type = mono_reflection_type_get_handle ((MonoReflectionType*)pb->type);\n\t} else {\n\t\tMonoReflectionProperty *p = (MonoReflectionProperty *)prop;\n\t\t*name = g_strdup (p->property->name);\n\t\tif (p->property->get)\n\t\t\t*type = mono_method_signature (p->property->get)->ret;\n\t\telse\n\t\t\t*type = mono_method_signature (p->property->set)->params [mono_method_signature (p->property->set)->param_count - 1];\n\t}\n}\n\nstatic void\nget_field_name_and_type (MonoObject *field, char **name, MonoType **type)\n{\n\tMonoClass *klass = mono_object_class (field);\n\tif (strcmp (klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder *)field;\n\t\t*name = mono_string_to_utf8 (fb->name);\n\t\t*type = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t} else {\n\t\tMonoReflectionField *f = (MonoReflectionField *)field;\n\t\t*name = g_strdup (mono_field_get_name (f->field));\n\t\t*type = f->field->type;\n\t}\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\n/*\n * Encode a value in a custom attribute stream of bytes.\n * The value to encode is either supplied as an object in argument val\n * (valuetypes are boxed), or as a pointer to the data in the\n * argument argval.\n * @type represents the type of the value\n * @buffer is the start of the buffer\n * @p the current position in the buffer\n * @buflen contains the size of the buffer and is used to return the new buffer size\n * if this needs to be realloced.\n * @retbuffer and @retp return the start and the position of the buffer\n */\nstatic void\nencode_cattr_value (MonoAssembly *assembly, char *buffer, char *p, char **retbuffer, char **retp, guint32 *buflen, MonoType *type, MonoObject *arg, char *argval)\n{\n\tMonoTypeEnum simple_type;\n\t\n\tif ((p-buffer) + 10 >= *buflen) {\n\t\tchar *newbuf;\n\t\t*buflen *= 2;\n\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\tp = newbuf + (p-buffer);\n\t\tbuffer = newbuf;\n\t}\n\tif (!argval)\n\t\targval = ((char*)arg + sizeof (MonoObject));\n\tsimple_type = type->type;\nhandle_enum:\n\tswitch (simple_type) {\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\t\t*p++ = *argval;\n\t\tbreak;\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\t\tswap_with_size (p, argval, 2, 1);\n\t\tp += 2;\n\t\tbreak;\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_R4:\n\t\tswap_with_size (p, argval, 4, 1);\n\t\tp += 4;\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n#if defined(ARM_FPU_FPA) && G_BYTE_ORDER == G_LITTLE_ENDIAN\n\t\tp [0] = argval [4];\n\t\tp [1] = argval [5];\n\t\tp [2] = argval [6];\n\t\tp [3] = argval [7];\n\t\tp [4] = argval [0];\n\t\tp [5] = argval [1];\n\t\tp [6] = argval [2];\n\t\tp [7] = argval [3];\n#else\n\t\tswap_with_size (p, argval, 8, 1);\n#endif\n\t\tp += 8;\n\t\tbreak;\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\t\tswap_with_size (p, argval, 8, 1);\n\t\tp += 8;\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (type->data.klass->enumtype) {\n\t\t\tsimple_type = mono_class_enum_basetype (type->data.klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tg_warning (\"generic valutype %s not handled in custom attr value decoding\", type->data.klass->name);\n\t\t}\n\t\tbreak;\n\tcase MONO_TYPE_STRING: {\n\t\tchar *str;\n\t\tguint32 slen;\n\t\tif (!arg) {\n\t\t\t*p++ = 0xFF;\n\t\t\tbreak;\n\t\t}\n\t\tstr = mono_string_to_utf8 ((MonoString*)arg);\n\t\tslen = strlen (str);\n\t\tif ((p-buffer) + 10 + slen >= *buflen) {\n\t\t\tchar *newbuf;\n\t\t\t*buflen *= 2;\n\t\t\t*buflen += slen;\n\t\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\t\tp = newbuf + (p-buffer);\n\t\t\tbuffer = newbuf;\n\t\t}\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_CLASS: {\n\t\tchar *str;\n\t\tguint32 slen;\n\t\tif (!arg) {\n\t\t\t*p++ = 0xFF;\n\t\t\tbreak;\n\t\t}\nhandle_type:\n\t\tstr = type_get_qualified_name (mono_reflection_type_get_handle ((MonoReflectionType*)arg), NULL);\n\t\tslen = strlen (str);\n\t\tif ((p-buffer) + 10 + slen >= *buflen) {\n\t\t\tchar *newbuf;\n\t\t\t*buflen *= 2;\n\t\t\t*buflen += slen;\n\t\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\t\tp = newbuf + (p-buffer);\n\t\t\tbuffer = newbuf;\n\t\t}\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_SZARRAY: {\n\t\tint len, i;\n\t\tMonoClass *eclass, *arg_eclass;\n\n\t\tif (!arg) {\n\t\t\t*p++ = 0xff; *p++ = 0xff; *p++ = 0xff; *p++ = 0xff;\n\t\t\tbreak;\n\t\t}\n\t\tlen = mono_array_length ((MonoArray*)arg);\n\t\t*p++ = len & 0xff;\n\t\t*p++ = (len >> 8) & 0xff;\n\t\t*p++ = (len >> 16) & 0xff;\n\t\t*p++ = (len >> 24) & 0xff;\n\t\t*retp = p;\n\t\t*retbuffer = buffer;\n\t\teclass = type->data.klass;\n\t\targ_eclass = mono_object_class (arg)->element_class;\n\n\t\tif (!eclass) {\n\t\t\t/* Happens when we are called from the MONO_TYPE_OBJECT case below */\n\t\t\teclass = mono_defaults.object_class;\n\t\t}\n\t\tif (eclass == mono_defaults.object_class && arg_eclass->valuetype) {\n\t\t\tchar *elptr = mono_array_addr ((MonoArray*)arg, char, 0);\n\t\t\tint elsize = mono_class_array_element_size (arg_eclass);\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &arg_eclass->byval_arg, NULL, elptr);\n\t\t\t\telptr += elsize;\n\t\t\t}\n\t\t} else if (eclass->valuetype && arg_eclass->valuetype) {\n\t\t\tchar *elptr = mono_array_addr ((MonoArray*)arg, char, 0);\n\t\t\tint elsize = mono_class_array_element_size (eclass);\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &eclass->byval_arg, NULL, elptr);\n\t\t\t\telptr += elsize;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &eclass->byval_arg, mono_array_get ((MonoArray*)arg, MonoObject*, i), NULL);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_OBJECT: {\n\t\tMonoClass *klass;\n\t\tchar *str;\n\t\tguint32 slen;\n\n\t\t/*\n\t\t * The parameter type is 'object' but the type of the actual\n\t\t * argument is not. So we have to add type information to the blob\n\t\t * too. This is completely undocumented in the spec.\n\t\t */\n\n\t\tif (arg == NULL) {\n\t\t\t*p++ = MONO_TYPE_STRING;\t// It's same hack as MS uses\n\t\t\t*p++ = 0xFF;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tklass = mono_object_class (arg);\n\n\t\tif (mono_object_isinst (arg, mono_defaults.systemtype_class)) {\n\t\t\t*p++ = 0x50;\n\t\t\tgoto handle_type;\n\t\t} else if (klass->enumtype) {\n\t\t\t*p++ = 0x55;\n\t\t} else if (klass == mono_defaults.string_class) {\n\t\t\tsimple_type = MONO_TYPE_STRING;\n\t\t\t*p++ = 0x0E;\n\t\t\tgoto handle_enum;\n\t\t} else if (klass->rank == 1) {\n\t\t\t*p++ = 0x1D;\n\t\t\tif (klass->element_class->byval_arg.type == MONO_TYPE_OBJECT)\n\t\t\t\t/* See Partition II, Appendix B3 */\n\t\t\t\t*p++ = 0x51;\n\t\t\telse\n\t\t\t\t*p++ = klass->element_class->byval_arg.type;\n\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &klass->byval_arg, arg, NULL);\n\t\t\tbreak;\n\t\t} else if (klass->byval_arg.type >= MONO_TYPE_BOOLEAN && klass->byval_arg.type <= MONO_TYPE_R8) {\n\t\t\t*p++ = simple_type = klass->byval_arg.type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tg_error (\"unhandled type in custom attr\");\n\t\t}\n\t\tstr = type_get_qualified_name (mono_class_get_type(klass), NULL);\n\t\tslen = strlen (str);\n\t\tif ((p-buffer) + 10 + slen >= *buflen) {\n\t\t\tchar *newbuf;\n\t\t\t*buflen *= 2;\n\t\t\t*buflen += slen;\n\t\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\t\tp = newbuf + (p-buffer);\n\t\t\tbuffer = newbuf;\n\t\t}\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t\tsimple_type = mono_class_enum_basetype (klass)->type;\n\t\tgoto handle_enum;\n\t}\n\tdefault:\n\t\tg_error (\"type 0x%02x not yet supported in custom attr encoder\", simple_type);\n\t}\n\t*retp = p;\n\t*retbuffer = buffer;\n}\n\nstatic void\nencode_field_or_prop_type (MonoType *type, char *p, char **retp)\n{\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype) {\n\t\tchar *str = type_get_qualified_name (type, NULL);\n\t\tint slen = strlen (str);\n\n\t\t*p++ = 0x55;\n\t\t/*\n\t\t * This seems to be optional...\n\t\t * *p++ = 0x80;\n\t\t */\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t} else if (type->type == MONO_TYPE_OBJECT) {\n\t\t*p++ = 0x51;\n\t} else if (type->type == MONO_TYPE_CLASS) {\n\t\t/* it should be a type: encode_cattr_value () has the check */\n\t\t*p++ = 0x50;\n\t} else {\n\t\tmono_metadata_encode_value (type->type, p, &p);\n\t\tif (type->type == MONO_TYPE_SZARRAY)\n\t\t\t/* See the examples in Partition VI, Annex B */\n\t\t\tencode_field_or_prop_type (&type->data.klass->byval_arg, p, &p);\n\t}\n\n\t*retp = p;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nencode_named_val (MonoReflectionAssembly *assembly, char *buffer, char *p, char **retbuffer, char **retp, guint32 *buflen, MonoType *type, char *name, MonoObject *value)\n{\n\tint len;\n\t/* Preallocate a large enough buffer */\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype) {\n\t\tchar *str = type_get_qualified_name (type, NULL);\n\t\tlen = strlen (str);\n\t\tg_free (str);\n\t} else if (type->type == MONO_TYPE_SZARRAY && type->data.klass->enumtype) {\n\t\tchar *str = type_get_qualified_name (&type->data.klass->byval_arg, NULL);\n\t\tlen = strlen (str);\n\t\tg_free (str);\n\t} else {\n\t\tlen = 0;\n\t}\n\tlen += strlen (name);\n\n\tif ((p-buffer) + 20 + len >= *buflen) {\n\t\tchar *newbuf;\n\t\t*buflen *= 2;\n\t\t*buflen += len;\n\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\tp = newbuf + (p-buffer);\n\t\tbuffer = newbuf;\n\t}\n\n\tencode_field_or_prop_type (type, p, &p);\n\n\tlen = strlen (name);\n\tmono_metadata_encode_value (len, p, &p);\n\tmemcpy (p, name, len);\n\tp += len;\n\tencode_cattr_value (assembly->assembly, buffer, p, &buffer, &p, buflen, type, value, NULL);\n\t*retp = p;\n\t*retbuffer = buffer;\n}\n\n/*\n * mono_reflection_get_custom_attrs_blob:\n * @ctor: custom attribute constructor\n * @ctorArgs: arguments o the constructor\n * @properties:\n * @propValues:\n * @fields:\n * @fieldValues:\n * \n * Creates the blob of data that needs to be saved in the metadata and that represents\n * the custom attributed described by @ctor, @ctorArgs etc.\n * Returns: a Byte array representing the blob of data.\n */\nMonoArray*\nmono_reflection_get_custom_attrs_blob (MonoReflectionAssembly *assembly, MonoObject *ctor, MonoArray *ctorArgs, MonoArray *properties, MonoArray *propValues, MonoArray *fields, MonoArray* fieldValues) \n{\n\tMonoArray *result;\n\tMonoMethodSignature *sig;\n\tMonoObject *arg;\n\tchar *buffer, *p;\n\tguint32 buflen, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (strcmp (ctor->vtable->klass->name, \"MonoCMethod\")) {\n\t\t/* sig is freed later so allocate it in the heap */\n\t\tsig = ctor_builder_to_signature (NULL, (MonoReflectionCtorBuilder*)ctor);\n\t} else {\n\t\tsig = mono_method_signature (((MonoReflectionMethod*)ctor)->method);\n\t}\n\n\tg_assert (mono_array_length (ctorArgs) == sig->param_count);\n\tbuflen = 256;\n\tp = buffer = g_malloc (buflen);\n\t/* write the prolog */\n\t*p++ = 1;\n\t*p++ = 0;\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\targ = mono_array_get (ctorArgs, MonoObject*, i);\n\t\tencode_cattr_value (assembly->assembly, buffer, p, &buffer, &p, &buflen, sig->params [i], arg, NULL);\n\t}\n\ti = 0;\n\tif (properties)\n\t\ti += mono_array_length (properties);\n\tif (fields)\n\t\ti += mono_array_length (fields);\n\t*p++ = i & 0xff;\n\t*p++ = (i >> 8) & 0xff;\n\tif (properties) {\n\t\tMonoObject *prop;\n\t\tfor (i = 0; i < mono_array_length (properties); ++i) {\n\t\t\tMonoType *ptype;\n\t\t\tchar *pname;\n\n\t\t\tprop = mono_array_get (properties, gpointer, i);\n\t\t\tget_prop_name_and_type (prop, &pname, &ptype);\n\t\t\t*p++ = 0x54; /* PROPERTY signature */\n\t\t\tencode_named_val (assembly, buffer, p, &buffer, &p, &buflen, ptype, pname, (MonoObject*)mono_array_get (propValues, gpointer, i));\n\t\t\tg_free (pname);\n\t\t}\n\t}\n\n\tif (fields) {\n\t\tMonoObject *field;\n\t\tfor (i = 0; i < mono_array_length (fields); ++i) {\n\t\t\tMonoType *ftype;\n\t\t\tchar *fname;\n\n\t\t\tfield = mono_array_get (fields, gpointer, i);\n\t\t\tget_field_name_and_type (field, &fname, &ftype);\n\t\t\t*p++ = 0x53; /* FIELD signature */\n\t\t\tencode_named_val (assembly, buffer, p, &buffer, &p, &buflen, ftype, fname, (MonoObject*)mono_array_get (fieldValues, gpointer, i));\n\t\t\tg_free (fname);\n\t\t}\n\t}\n\n\tg_assert (p - buffer <= buflen);\n\tbuflen = p - buffer;\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, buflen);\n\tp = mono_array_addr (result, char, 0);\n\tmemcpy (p, buffer, buflen);\n\tg_free (buffer);\n\tif (strcmp (ctor->vtable->klass->name, \"MonoCMethod\"))\n\t\tg_free (sig);\n\treturn result;\n}\n\n/*\n * mono_reflection_setup_internal_class:\n * @tb: a TypeBuilder object\n *\n * Creates a MonoClass that represents the TypeBuilder.\n * This is a trick that lets us simplify a lot of reflection code\n * (and will allow us to support Build and Run assemblies easier).\n */\nvoid\nmono_reflection_setup_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoError error;\n\tMonoClass *klass, *parent;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tRESOLVE_TYPE (tb->parent);\n\n\tmono_loader_lock ();\n\n\tif (tb->parent) {\n\t\t/* check so we can compile corlib correctly */\n\t\tif (strcmp (mono_object_class (tb->parent)->name, \"TypeBuilder\") == 0) {\n\t\t\t/* mono_class_setup_mono_type () guaranteess type->data.klass is valid */\n\t\t\tparent = mono_reflection_type_get_handle ((MonoReflectionType*)tb->parent)->data.klass;\n\t\t} else {\n\t\t\tparent = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb->parent));\n\t\t}\n\t} else {\n\t\tparent = NULL;\n\t}\n\t\n\t/* the type has already being created: it means we just have to change the parent */\n\tif (tb->type.type) {\n\t\tklass = mono_class_from_mono_type (tb->type.type);\n\t\tklass->parent = NULL;\n\t\t/* fool mono_class_setup_parent */\n\t\tklass->supertypes = NULL;\n\t\tmono_class_setup_parent (klass, parent);\n\t\tmono_class_setup_mono_type (klass);\n\t\tmono_loader_unlock ();\n\t\treturn;\n\t}\n\n\tklass = mono_image_alloc0 (&tb->module->dynamic_image->image, sizeof (MonoClass));\n\n\tklass->image = &tb->module->dynamic_image->image;\n\n\tklass->inited = 1; /* we lie to the runtime */\n\tklass->name = mono_string_to_utf8_image (klass->image, tb->name, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\tklass->name_space = mono_string_to_utf8_image (klass->image, tb->nspace, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\tklass->type_token = MONO_TOKEN_TYPE_DEF | tb->table_idx;\n\tklass->flags = tb->attrs;\n\t\n\tmono_profiler_class_event (klass, MONO_PROFILE_START_LOAD);\n\n\tklass->element_class = klass;\n\n\tMOVING_GC_REGISTER (&klass->reflection_info);\n\tklass->reflection_info = tb;\n\n\t/* Put into cache so mono_class_get () will find it */\n\tmono_image_add_to_name_cache (klass->image, klass->name_space, klass->name, tb->table_idx);\n\n\tmono_g_hash_table_insert (tb->module->dynamic_image->tokens,\n\t\tGUINT_TO_POINTER (MONO_TOKEN_TYPE_DEF | tb->table_idx), tb);\n\n\tif (parent != NULL) {\n\t\tmono_class_setup_parent (klass, parent);\n\t} else if (strcmp (klass->name, \"Object\") == 0 && strcmp (klass->name_space, \"System\") == 0) {\n\t\tconst char *old_n = klass->name;\n\t\t/* trick to get relative numbering right when compiling corlib */\n\t\tklass->name = \"BuildingObject\";\n\t\tmono_class_setup_parent (klass, mono_defaults.object_class);\n\t\tklass->name = old_n;\n\t}\n\n\tif ((!strcmp (klass->name, \"ValueType\") && !strcmp (klass->name_space, \"System\")) ||\n\t\t\t(!strcmp (klass->name, \"Object\") && !strcmp (klass->name_space, \"System\")) ||\n\t\t\t(!strcmp (klass->name, \"Enum\") && !strcmp (klass->name_space, \"System\"))) {\n\t\tklass->instance_size = sizeof (MonoObject);\n\t\tklass->size_inited = 1;\n\t\tmono_class_setup_vtable_general (klass, NULL, 0);\n\t}\n\n\tmono_class_setup_mono_type (klass);\n\n\tmono_class_setup_supertypes (klass);\n\n\t/*\n\t * FIXME: handle interfaces.\n\t */\n\n\ttb->type.type = &klass->byval_arg;\n\n\tif (tb->nesting_type) {\n\t\tg_assert (tb->nesting_type->type);\n\t\tklass->nested_in = mono_class_from_mono_type (mono_reflection_type_get_handle (tb->nesting_type));\n\t}\n\n\t/*g_print (\"setup %s as %s (%p)\\n\", klass->name, ((MonoObject*)tb)->vtable->klass->name, tb);*/\n\n\tmono_profiler_class_loaded (klass, MONO_PROFILE_OK);\n\t\n\tmono_loader_unlock ();\n\treturn;\n\nfailure:\n\tmono_loader_unlock ();\n\tmono_error_raise_exception (&error);\n}\n\n/*\n * mono_reflection_setup_generic_class:\n * @tb: a TypeBuilder object\n *\n * Setup the generic class before adding the first generic parameter.\n */\nvoid\nmono_reflection_setup_generic_class (MonoReflectionTypeBuilder *tb)\n{\n}\n\n/*\n * mono_reflection_create_generic_class:\n * @tb: a TypeBuilder object\n *\n * Creates the generic class after all generic parameters have been added.\n */\nvoid\nmono_reflection_create_generic_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoClass *klass;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (tb->type.type);\n\n\tcount = tb->generic_params ? mono_array_length (tb->generic_params) : 0;\n\n\tif (klass->generic_container || (count == 0))\n\t\treturn;\n\n\tg_assert (tb->generic_container && (tb->generic_container->owner.klass == klass));\n\n\tklass->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\n\tklass->generic_container->owner.klass = klass;\n\tklass->generic_container->type_argc = count;\n\tklass->generic_container->type_params = mono_image_alloc0 (klass->image, sizeof (MonoGenericParamFull) * count);\n\n\tklass->is_generic = 1;\n\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionGenericParam *gparam = mono_array_get (tb->generic_params, gpointer, i);\n\t\tMonoGenericParamFull *param = (MonoGenericParamFull *) mono_reflection_type_get_handle ((MonoReflectionType*)gparam)->data.generic_param;\n\t\tklass->generic_container->type_params [i] = *param;\n\t\t/*Make sure we are a diferent type instance */\n\t\tklass->generic_container->type_params [i].param.owner = klass->generic_container;\n\t\tklass->generic_container->type_params [i].info.pklass = NULL;\n\t\tklass->generic_container->type_params [i].info.flags = gparam->attrs;\n\n\t\tg_assert (klass->generic_container->type_params [i].param.owner);\n\t}\n\n\tklass->generic_container->context.class_inst = mono_get_shared_generic_inst (klass->generic_container);\n}\n\n/*\n * mono_reflection_create_internal_class:\n * @tb: a TypeBuilder object\n *\n * Actually create the MonoClass that is associated with the TypeBuilder.\n */\nvoid\nmono_reflection_create_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoClass *klass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (tb->type.type);\n\n\tmono_loader_lock ();\n\tif (klass->enumtype && mono_class_enum_basetype (klass) == NULL) {\n\t\tMonoReflectionFieldBuilder *fb;\n\t\tMonoClass *ec;\n\t\tMonoType *enum_basetype;\n\n\t\tg_assert (tb->fields != NULL);\n\t\tg_assert (mono_array_length (tb->fields) >= 1);\n\n\t\tfb = mono_array_get (tb->fields, MonoReflectionFieldBuilder*, 0);\n\n\t\tif (!mono_type_is_valid_enum_basetype (mono_reflection_type_get_handle ((MonoReflectionType*)fb->type))) {\n\t\t\tmono_loader_unlock ();\n\t\t\treturn;\n\t\t}\n\n\t\tenum_basetype = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t\tklass->element_class = mono_class_from_mono_type (enum_basetype);\n\t\tif (!klass->element_class)\n\t\t\tklass->element_class = mono_class_from_mono_type (enum_basetype);\n\n\t\t/*\n\t\t * get the element_class from the current corlib.\n\t\t */\n\t\tec = default_class_from_mono_type (enum_basetype);\n\t\tklass->instance_size = ec->instance_size;\n\t\tklass->size_inited = 1;\n\t\t/* \n\t\t * this is almost safe to do with enums and it's needed to be able\n\t\t * to create objects of the enum type (for use in SetConstant).\n\t\t */\n\t\t/* FIXME: Does this mean enums can't have method overrides ? */\n\t\tmono_class_setup_vtable_general (klass, NULL, 0);\n\t}\n\tmono_loader_unlock ();\n}\n\nstatic MonoMarshalSpec*\nmono_marshal_spec_from_builder (MonoImage *image, MonoAssembly *assembly,\n\t\t\t\t\t\t\t\tMonoReflectionMarshal *minfo)\n{\n\tMonoMarshalSpec *res;\n\n\tres = image_g_new0 (image, MonoMarshalSpec, 1);\n\tres->native = minfo->type;\n\n\tswitch (minfo->type) {\n\tcase MONO_NATIVE_LPARRAY:\n\t\tres->data.array_data.elem_type = minfo->eltype;\n\t\tif (minfo->has_size) {\n\t\t\tres->data.array_data.param_num = minfo->param_num;\n\t\t\tres->data.array_data.num_elem = minfo->count;\n\t\t\tres->data.array_data.elem_mult = minfo->param_num == -1 ? 0 : 1;\n\t\t}\n\t\telse {\n\t\t\tres->data.array_data.param_num = -1;\n\t\t\tres->data.array_data.num_elem = -1;\n\t\t\tres->data.array_data.elem_mult = -1;\n\t\t}\n\t\tbreak;\n\n\tcase MONO_NATIVE_BYVALTSTR:\n\tcase MONO_NATIVE_BYVALARRAY:\n\t\tres->data.array_data.num_elem = minfo->count;\n\t\tbreak;\n\n\tcase MONO_NATIVE_CUSTOM:\n\t\tif (minfo->marshaltyperef)\n\t\t\tres->data.custom_data.custom_name =\n\t\t\t\ttype_get_fully_qualified_name (mono_reflection_type_get_handle ((MonoReflectionType*)minfo->marshaltyperef));\n\t\tif (minfo->mcookie)\n\t\t\tres->data.custom_data.cookie = mono_string_to_utf8 (minfo->mcookie);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\nMonoReflectionMarshal*\nmono_reflection_marshal_from_marshal_spec (MonoDomain *domain, MonoClass *klass,\n\t\t\t\t\t\t\t\t\t\t   MonoMarshalSpec *spec)\n{\n\tstatic MonoClass *System_Reflection_Emit_UnmanagedMarshalClass;\n\tMonoReflectionMarshal *minfo;\n\tMonoType *mtype;\n\n\tif (!System_Reflection_Emit_UnmanagedMarshalClass) {\n\t\tSystem_Reflection_Emit_UnmanagedMarshalClass = mono_class_from_name (\n\t\t   mono_defaults.corlib, \"System.Reflection.Emit\", \"UnmanagedMarshal\");\n\t\tg_assert (System_Reflection_Emit_UnmanagedMarshalClass);\n\t}\n\n\tminfo = (MonoReflectionMarshal*)mono_object_new (domain, System_Reflection_Emit_UnmanagedMarshalClass);\n\tminfo->type = spec->native;\n\n\tswitch (minfo->type) {\n\tcase MONO_NATIVE_LPARRAY:\n\t\tminfo->eltype = spec->data.array_data.elem_type;\n\t\tminfo->count = spec->data.array_data.num_elem;\n\t\tminfo->param_num = spec->data.array_data.param_num;\n\t\tbreak;\n\n\tcase MONO_NATIVE_BYVALTSTR:\n\tcase MONO_NATIVE_BYVALARRAY:\n\t\tminfo->count = spec->data.array_data.num_elem;\n\t\tbreak;\n\n\tcase MONO_NATIVE_CUSTOM:\n\t\tif (spec->data.custom_data.custom_name) {\n\t\t\tmtype = mono_reflection_type_from_name (spec->data.custom_data.custom_name, klass->image);\n\t\t\tif (mtype)\n\t\t\t\tMONO_OBJECT_SETREF (minfo, marshaltyperef, mono_type_get_object (domain, mtype));\n\n\t\t\tMONO_OBJECT_SETREF (minfo, marshaltype, mono_string_new (domain, spec->data.custom_data.custom_name));\n\t\t}\n\t\tif (spec->data.custom_data.cookie)\n\t\t\tMONO_OBJECT_SETREF (minfo, mcookie, mono_string_new (domain, spec->data.custom_data.cookie));\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn minfo;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic MonoMethod*\nreflection_methodbuilder_to_mono_method (MonoClass *klass,\n\t\t\t\t\t ReflectionMethodBuilder *rmb,\n\t\t\t\t\t MonoMethodSignature *sig)\n{\n\tMonoError error;\n\tMonoMethod *m;\n\tMonoMethodNormal *pm;\n\tMonoMarshalSpec **specs;\n\tMonoReflectionMethodAux *method_aux;\n\tMonoImage *image;\n\tgboolean dynamic;\n\tint i;\n\n\tmono_error_init (&error);\n\t/*\n\t * Methods created using a MethodBuilder should have their memory allocated\n\t * inside the image mempool, while dynamic methods should have their memory\n\t * malloc'd.\n\t */\n\tdynamic = rmb->refs != NULL;\n\timage = dynamic ? NULL : klass->image;\n\n\tif (!dynamic)\n\t\tg_assert (!klass->generic_class);\n\n\tmono_loader_lock ();\n\n\tif ((rmb->attrs & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t\t(rmb->iattrs & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL))\n\t\tm = (MonoMethod *)image_g_new0 (image, MonoMethodPInvoke, 1);\n\telse if (rmb->refs)\n\t\tm = (MonoMethod *)image_g_new0 (image, MonoMethodWrapper, 1);\n\telse\n\t\tm = (MonoMethod *)image_g_new0 (image, MonoMethodNormal, 1);\n\n\tpm = (MonoMethodNormal*)m;\n\n\tm->dynamic = dynamic;\n\tm->slot = -1;\n\tm->flags = rmb->attrs;\n\tm->iflags = rmb->iattrs;\n\tm->name = mono_string_to_utf8_image (image, rmb->name, &error);\n\tg_assert (mono_error_ok (&error));\n\tm->klass = klass;\n\tm->signature = sig;\n\tm->skip_visibility = rmb->skip_visibility;\n\tif (rmb->table_idx)\n\t\tm->token = MONO_TOKEN_METHOD_DEF | (*rmb->table_idx);\n\n\tif (m->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {\n\t\tif (klass == mono_defaults.string_class && !strcmp (m->name, \".ctor\"))\n\t\t\tm->string_ctor = 1;\n\n\t\tm->signature->pinvoke = 1;\n\t} else if (m->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) {\n\t\tm->signature->pinvoke = 1;\n\n\t\tmethod_aux = image_g_new0 (image, MonoReflectionMethodAux, 1);\n\n\t\tmethod_aux->dllentry = rmb->dllentry ? mono_string_to_utf8_image (image, rmb->dllentry, &error) : image_strdup (image, m->name);\n\t\tg_assert (mono_error_ok (&error));\n\t\tmethod_aux->dll = mono_string_to_utf8_image (image, rmb->dll, &error);\n\t\tg_assert (mono_error_ok (&error));\n\t\t\n\t\t((MonoMethodPInvoke*)m)->piflags = (rmb->native_cc << 8) | (rmb->charset ? (rmb->charset - 1) * 2 : 0) | rmb->extra_flags;\n\n\t\tif (klass->image->dynamic)\n\t\t\tg_hash_table_insert (((MonoDynamicImage*)klass->image)->method_aux_hash, m, method_aux);\n\n\t\tmono_loader_unlock ();\n\n\t\treturn m;\n\t} else if (!(m->flags & METHOD_ATTRIBUTE_ABSTRACT) &&\n\t\t\t   !(m->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME)) {\n\t\tMonoMethodHeader *header;\n\t\tguint32 code_size;\n\t\tgint32 max_stack, i;\n\t\tgint32 num_locals = 0;\n\t\tgint32 num_clauses = 0;\n\t\tguint8 *code;\n\n\t\tif (rmb->ilgen) {\n\t\t\tcode = mono_array_addr (rmb->ilgen->code, guint8, 0);\n\t\t\tcode_size = rmb->ilgen->code_len;\n\t\t\tmax_stack = rmb->ilgen->max_stack;\n\t\t\tnum_locals = rmb->ilgen->locals ? mono_array_length (rmb->ilgen->locals) : 0;\n\t\t\tif (rmb->ilgen->ex_handlers)\n\t\t\t\tnum_clauses = method_count_clauses (rmb->ilgen);\n\t\t} else {\n\t\t\tif (rmb->code) {\n\t\t\t\tcode = mono_array_addr (rmb->code, guint8, 0);\n\t\t\t\tcode_size = mono_array_length (rmb->code);\n\t\t\t\t/* we probably need to run a verifier on the code... */\n\t\t\t\tmax_stack = 8; \n\t\t\t}\n\t\t\telse {\n\t\t\t\tcode = NULL;\n\t\t\t\tcode_size = 0;\n\t\t\t\tmax_stack = 8;\n\t\t\t}\n\t\t}\n\n\t\theader = image_g_malloc0 (image, MONO_SIZEOF_METHOD_HEADER + num_locals * sizeof (MonoType*));\n\t\theader->code_size = code_size;\n\t\theader->code = image_g_malloc (image, code_size);\n\t\tmemcpy ((char*)header->code, code, code_size);\n\t\theader->max_stack = max_stack;\n\t\theader->init_locals = rmb->init_locals;\n\t\theader->num_locals = num_locals;\n\n\t\tfor (i = 0; i < num_locals; ++i) {\n\t\t\tMonoReflectionLocalBuilder *lb = \n\t\t\t\tmono_array_get (rmb->ilgen->locals, MonoReflectionLocalBuilder*, i);\n\n\t\t\theader->locals [i] = image_g_new0 (image, MonoType, 1);\n\t\t\tmemcpy (header->locals [i], mono_reflection_type_get_handle ((MonoReflectionType*)lb->type), MONO_SIZEOF_TYPE);\n\t\t}\n\n\t\theader->num_clauses = num_clauses;\n\t\tif (num_clauses) {\n\t\t\theader->clauses = method_encode_clauses (image, (MonoDynamicImage*)klass->image,\n\t\t\t\t rmb->ilgen, num_clauses);\n\t\t}\n\n\t\tpm->header = header;\n\t}\n\n\tif (rmb->generic_params) {\n\t\tint count = mono_array_length (rmb->generic_params);\n\t\tMonoGenericContainer *container;\n\n\t\tcontainer = rmb->generic_container;\n\t\tif (container) {\n\t\t\tm->is_generic = TRUE;\n\t\t\tmono_method_set_generic_container (m, container);\n\t\t}\n\t\tcontainer->type_argc = count;\n\t\tcontainer->type_params = image_g_new0 (image, MonoGenericParamFull, count);\n\t\tcontainer->owner.method = m;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tMonoReflectionGenericParam *gp =\n\t\t\t\tmono_array_get (rmb->generic_params, MonoReflectionGenericParam*, i);\n\t\t\tMonoGenericParamFull *param = (MonoGenericParamFull *) mono_reflection_type_get_handle ((MonoReflectionType*)gp)->data.generic_param;\n\t\t\tcontainer->type_params [i] = *param;\n\t\t}\n\n\t\tif (klass->generic_container) {\n\t\t\tcontainer->parent = klass->generic_container;\n\t\t\tcontainer->context.class_inst = klass->generic_container->context.class_inst;\n\t\t}\n\t\tcontainer->context.method_inst = mono_get_shared_generic_inst (container);\n\t}\n\n\tif (rmb->refs) {\n\t\tMonoMethodWrapper *mw = (MonoMethodWrapper*)m;\n\t\tint i;\n\t\tvoid **data;\n\n\t\tm->wrapper_type = MONO_WRAPPER_DYNAMIC_METHOD;\n\n\t\tmw->method_data = data = image_g_new (image, gpointer, rmb->nrefs + 1);\n\t\tdata [0] = GUINT_TO_POINTER (rmb->nrefs);\n\t\tfor (i = 0; i < rmb->nrefs; ++i)\n\t\t\tdata [i + 1] = rmb->refs [i];\n\t}\n\n\tmethod_aux = NULL;\n\n\t/* Parameter info */\n\tif (rmb->pinfo) {\n\t\tif (!method_aux)\n\t\t\tmethod_aux = image_g_new0 (image, MonoReflectionMethodAux, 1);\n\t\tmethod_aux->param_names = image_g_new0 (image, char *, mono_method_signature (m)->param_count + 1);\n\t\tfor (i = 0; i <= m->signature->param_count; ++i) {\n\t\t\tMonoReflectionParamBuilder *pb;\n\t\t\tif ((pb = mono_array_get (rmb->pinfo, MonoReflectionParamBuilder*, i))) {\n\t\t\t\tif ((i > 0) && (pb->attrs)) {\n\t\t\t\t\t/* Make a copy since it might point to a shared type structure */\n\t\t\t\t\tm->signature->params [i - 1] = mono_metadata_type_dup (klass->image, m->signature->params [i - 1]);\n\t\t\t\t\tm->signature->params [i - 1]->attrs = pb->attrs;\n\t\t\t\t}\n\n\t\t\t\tif (pb->attrs & PARAM_ATTRIBUTE_HAS_DEFAULT) {\n\t\t\t\t\tMonoDynamicImage *assembly;\n\t\t\t\t\tguint32 idx, def_type, len;\n\t\t\t\t\tchar *p;\n\t\t\t\t\tconst char *p2;\n\n\t\t\t\t\tif (!method_aux->param_defaults) {\n\t\t\t\t\t\tmethod_aux->param_defaults = image_g_new0 (image, guint8*, m->signature->param_count + 1);\n\t\t\t\t\t\tmethod_aux->param_default_types = image_g_new0 (image, guint32, m->signature->param_count + 1);\n\t\t\t\t\t}\n\t\t\t\t\tassembly = (MonoDynamicImage*)klass->image;\n\t\t\t\t\tidx = encode_constant (assembly, pb->def_value, &def_type);\n\t\t\t\t\t/* Copy the data from the blob since it might get realloc-ed */\n\t\t\t\t\tp = assembly->blob.data + idx;\n\t\t\t\t\tlen = mono_metadata_decode_blob_size (p, &p2);\n\t\t\t\t\tlen += p2 - p;\n\t\t\t\t\tmethod_aux->param_defaults [i] = image_g_malloc (image, len);\n\t\t\t\t\tmethod_aux->param_default_types [i] = def_type;\n\t\t\t\t\tmemcpy ((gpointer)method_aux->param_defaults [i], p, len);\n\t\t\t\t}\n\n\t\t\t\tif (pb->name) {\n\t\t\t\t\tmethod_aux->param_names [i] = mono_string_to_utf8_image (image, pb->name, &error);\n\t\t\t\t\tg_assert (mono_error_ok (&error));\n\t\t\t\t}\n\t\t\t\tif (pb->cattrs) {\n\t\t\t\t\tif (!method_aux->param_cattr)\n\t\t\t\t\t\tmethod_aux->param_cattr = image_g_new0 (image, MonoCustomAttrInfo*, m->signature->param_count + 1);\n\t\t\t\t\tmethod_aux->param_cattr [i] = mono_custom_attrs_from_builders (image, klass->image, pb->cattrs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Parameter marshalling */\n\tspecs = NULL;\n\tif (rmb->pinfo)\t\t\n\t\tfor (i = 0; i < mono_array_length (rmb->pinfo); ++i) {\n\t\t\tMonoReflectionParamBuilder *pb;\n\t\t\tif ((pb = mono_array_get (rmb->pinfo, MonoReflectionParamBuilder*, i))) {\n\t\t\t\tif (pb->marshal_info) {\n\t\t\t\t\tif (specs == NULL)\n\t\t\t\t\t\tspecs = image_g_new0 (image, MonoMarshalSpec*, sig->param_count + 1);\n\t\t\t\t\tspecs [pb->position] = \n\t\t\t\t\t\tmono_marshal_spec_from_builder (image, klass->image->assembly, pb->marshal_info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (specs != NULL) {\n\t\tif (!method_aux)\n\t\t\tmethod_aux = image_g_new0 (image, MonoReflectionMethodAux, 1);\n\t\tmethod_aux->param_marshall = specs;\n\t}\n\n\tif (klass->image->dynamic && method_aux)\n\t\tg_hash_table_insert (((MonoDynamicImage*)klass->image)->method_aux_hash, m, method_aux);\n\n\tmono_loader_unlock ();\n\n\treturn m;\n}\t\n\nstatic MonoMethod*\nctorbuilder_to_mono_method (MonoClass *klass, MonoReflectionCtorBuilder* mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\n\tmono_loader_lock ();\n\tsig = ctor_builder_to_signature (klass->image, mb);\n\tmono_loader_unlock ();\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, mb);\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\tmono_save_custom_attrs (klass->image, mb->mhandle, mb->cattrs);\n\n\t/* If we are in a generic class, we might be called multiple times from inflate_method */\n\tif (!((MonoDynamicImage*)(MonoDynamicImage*)klass->image)->save && !klass->generic_container) {\n\t\t/* ilgen is no longer needed */\n\t\tmb->ilgen = NULL;\n\t}\n\n\treturn mb->mhandle;\n}\n\nstatic MonoMethod*\nmethodbuilder_to_mono_method (MonoClass *klass, MonoReflectionMethodBuilder* mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\n\tmono_loader_lock ();\n\tsig = method_builder_to_signature (klass->image, mb);\n\tmono_loader_unlock ();\n\n\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\tmono_save_custom_attrs (klass->image, mb->mhandle, mb->cattrs);\n\n\t/* If we are in a generic class, we might be called multiple times from inflate_method */\n\tif (!((MonoDynamicImage*)(MonoDynamicImage*)klass->image)->save && !klass->generic_container) {\n\t\t/* ilgen is no longer needed */\n\t\tmb->ilgen = NULL;\n\t}\n\treturn mb->mhandle;\n}\n\nstatic MonoClassField*\nfieldbuilder_to_mono_class_field (MonoClass *klass, MonoReflectionFieldBuilder* fb)\n{\n\tMonoClassField *field;\n\tMonoType *custom;\n\n\tfield = g_new0 (MonoClassField, 1);\n\n\tfield->name = mono_string_to_utf8 (fb->name);\n\tif (fb->attrs || fb->modreq || fb->modopt) {\n\t\tfield->type = mono_metadata_type_dup (NULL, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type));\n\t\tfield->type->attrs = fb->attrs;\n\n\t\tg_assert (klass->image->dynamic);\n\t\tcustom = add_custom_modifiers ((MonoDynamicImage*)klass->image, field->type, fb->modreq, fb->modopt);\n\t\tg_free (field->type);\n\t\tfield->type = custom;\n\t} else {\n\t\tfield->type = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t}\n\tif (fb->offset != -1)\n\t\tfield->offset = fb->offset;\n\tfield->parent = klass;\n\tmono_save_custom_attrs (klass->image, field, fb->cattrs);\n\n\t// FIXME: Can't store fb->def_value/RVA, is it needed for field_on_insts ?\n\n\treturn field;\n}\n#endif\n\nMonoType*\nmono_reflection_bind_generic_parameters (MonoReflectionType *type, int type_argc, MonoType **types)\n{\n\tMonoClass *klass;\n\tMonoReflectionTypeBuilder *tb = NULL;\n\tgboolean is_dynamic = FALSE;\n\tMonoDomain *domain;\n\tMonoClass *geninst;\n\n\tmono_loader_lock ();\n\n\tdomain = mono_object_domain (type);\n\n\tif (!strcmp (((MonoObject *) type)->vtable->klass->name, \"TypeBuilder\")) {\n\t\ttb = (MonoReflectionTypeBuilder *) type;\n\n\t\tis_dynamic = TRUE;\n\t} else if (!strcmp (((MonoObject *) type)->vtable->klass->name, \"MonoGenericClass\")) {\n\t\tMonoReflectionGenericClass *rgi = (MonoReflectionGenericClass *) type;\n\n\t\ttb = rgi->generic_type;\n\t\tis_dynamic = TRUE;\n\t}\n\n\t/* FIXME: fix the CreateGenericParameters protocol to avoid the two stage setup of TypeBuilders */\n\tif (tb && tb->generic_container)\n\t\tmono_reflection_create_generic_class (tb);\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle (type));\n\tif (!klass->generic_container) {\n\t\tmono_loader_unlock ();\n\t\treturn NULL;\n\t}\n\n\tif (klass->wastypebuilder) {\n\t\ttb = (MonoReflectionTypeBuilder *) klass->reflection_info;\n\n\t\tis_dynamic = TRUE;\n\t}\n\n\tmono_loader_unlock ();\n\n\tgeninst = mono_class_bind_generic_parameters (klass, type_argc, types, is_dynamic);\n\n\treturn &geninst->byval_arg;\n}\n\nMonoClass*\nmono_class_bind_generic_parameters (MonoClass *klass, int type_argc, MonoType **types, gboolean is_dynamic)\n{\n\tMonoGenericClass *gclass;\n\tMonoGenericInst *inst;\n\n\tg_assert (klass->generic_container);\n\n\tinst = mono_metadata_get_generic_inst (type_argc, types);\n\tgclass = mono_metadata_lookup_generic_class (klass, inst, is_dynamic);\n\n\treturn mono_generic_class_get_class (gclass);\n}\n\nMonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\n\tklass = method->klass;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\t/*\n\t\t * This table maps metadata structures representing inflated methods/fields\n\t\t * to the reflection objects representing their generic definitions.\n\t\t */\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\n\tif (!mono_verifier_is_method_valid_generic_instantiation (inflated))\n\t\tmono_raise_exception (mono_get_exception_argument (\"typeArguments\", \"Invalid generic arguments\"));\n\t\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n\nstatic MonoMethod *\ninflate_mono_method (MonoClass *klass, MonoMethod *method, MonoObject *obj)\n{\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext *context;\n\tint i;\n\n\t/*\n\t * With generic code sharing the klass might not be inflated.\n\t * This can happen because classes inflated with their own\n\t * type arguments are \"normalized\" to the uninflated class.\n\t */\n\tif (!klass->generic_class)\n\t\treturn method;\n\n\tcontext = mono_class_get_context (klass);\n\n\tif (klass->method.count) {\n\t\t/* Find the already created inflated method */\n\t\tfor (i = 0; i < klass->method.count; ++i) {\n\t\t\tg_assert (klass->methods [i]->is_inflated);\n\t\t\tif (((MonoMethodInflated*)klass->methods [i])->declaring == method)\n\t\t\t\tbreak;\n\t\t}\n\t\tg_assert (i < klass->method.count);\n\t\timethod = (MonoMethodInflated*)klass->methods [i];\n\t} else {\n\t\timethod = (MonoMethodInflated *) mono_class_inflate_generic_method_full (method, klass, context);\n\t}\n\n\tif (method->is_generic && method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, obj);\n\t\tmono_loader_unlock ();\n\t}\n\treturn (MonoMethod *) imethod;\n}\n\nstatic MonoMethod *\ninflate_method (MonoReflectionGenericClass *type, MonoObject *obj)\n{\n\tMonoMethod *method;\n\tMonoClass *gklass;\n\n\tgklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)type->generic_type));\n\n\tif (!strcmp (obj->vtable->klass->name, \"MethodBuilder\"))\n\t\tif (((MonoReflectionMethodBuilder*)obj)->mhandle)\n\t\t\tmethod = ((MonoReflectionMethodBuilder*)obj)->mhandle;\n\t\telse\n\t\t\tmethod = methodbuilder_to_mono_method (gklass, (MonoReflectionMethodBuilder *) obj);\n\telse if (!strcmp (obj->vtable->klass->name, \"ConstructorBuilder\"))\n\t\tmethod = ctorbuilder_to_mono_method (gklass, (MonoReflectionCtorBuilder *) obj);\n\telse if (!strcmp (obj->vtable->klass->name, \"MonoMethod\") || !strcmp (obj->vtable->klass->name, \"MonoCMethod\"))\n\t\tmethod = ((MonoReflectionMethod *) obj)->method;\n\telse {\n\t\tmethod = NULL; /* prevent compiler warning */\n\t\tg_error (\"can't handle type %s\", obj->vtable->klass->name);\n\t}\n\n\treturn inflate_mono_method (mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)type)), method, obj);\n}\n\n/*TODO avoid saving custom attrs for generic classes as it's enough to have them on the generic type definition.*/\nvoid\nmono_reflection_generic_class_initialize (MonoReflectionGenericClass *type, MonoArray *methods, \n\t\t\t\t\t  MonoArray *ctors, MonoArray *fields, MonoArray *properties,\n\t\t\t\t\t  MonoArray *events)\n{\n\tMonoGenericClass *gclass;\n\tMonoDynamicGenericClass *dgclass;\n\tMonoClass *klass, *gklass;\n\tMonoType *gtype;\n\tint i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tgtype = mono_reflection_type_get_handle ((MonoReflectionType*)type);\n\tklass = mono_class_from_mono_type (gtype);\n\tg_assert (gtype->type == MONO_TYPE_GENERICINST);\n\tgclass = gtype->data.generic_class;\n\n\tg_assert (gclass->is_dynamic);\n\tdgclass = (MonoDynamicGenericClass *) gclass;\n\n\tif (dgclass->initialized)\n\t\treturn;\n\n\tgklass = gclass->container_class;\n\tmono_class_init (gklass);\n\n\tdgclass->count_methods = methods ? mono_array_length (methods) : 0;\n\tdgclass->count_ctors = ctors ? mono_array_length (ctors) : 0;\n\tdgclass->count_fields = fields ? mono_array_length (fields) : 0;\n\tdgclass->count_properties = properties ? mono_array_length (properties) : 0;\n\tdgclass->count_events = events ? mono_array_length (events) : 0;\n\n\tdgclass->methods = g_new0 (MonoMethod *, dgclass->count_methods);\n\tdgclass->ctors = g_new0 (MonoMethod *, dgclass->count_ctors);\n\tdgclass->fields = g_new0 (MonoClassField, dgclass->count_fields);\n\tdgclass->properties = g_new0 (MonoProperty, dgclass->count_properties);\n\tdgclass->events = g_new0 (MonoEvent, dgclass->count_events);\n\tdgclass->field_objects = g_new0 (MonoObject*, dgclass->count_fields);\n\tdgclass->field_generic_types = g_new0 (MonoType*, dgclass->count_fields);\n\n\tfor (i = 0; i < dgclass->count_methods; i++) {\n\t\tMonoObject *obj = mono_array_get (methods, gpointer, i);\n\n\t\tdgclass->methods [i] = inflate_method (type, obj);\n\t}\n\n\tfor (i = 0; i < dgclass->count_ctors; i++) {\n\t\tMonoObject *obj = mono_array_get (ctors, gpointer, i);\n\n\t\tdgclass->ctors [i] = inflate_method (type, obj);\n\t}\n\n\tfor (i = 0; i < dgclass->count_fields; i++) {\n\t\tMonoObject *obj = mono_array_get (fields, gpointer, i);\n\t\tMonoClassField *field, *inflated_field = NULL;\n\n\t\tif (!strcmp (obj->vtable->klass->name, \"FieldBuilder\"))\n\t\t\tinflated_field = field = fieldbuilder_to_mono_class_field (klass, (MonoReflectionFieldBuilder *) obj);\n\t\telse if (!strcmp (obj->vtable->klass->name, \"MonoField\"))\n\t\t\tfield = ((MonoReflectionField *) obj)->field;\n\t\telse {\n\t\t\tfield = NULL; /* prevent compiler warning */\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tdgclass->fields [i] = *field;\n\t\tdgclass->fields [i].parent = klass;\n\t\tdgclass->fields [i].type = mono_class_inflate_generic_type (\n\t\t\tfield->type, mono_generic_class_get_context ((MonoGenericClass *) dgclass));\n\t\tdgclass->field_generic_types [i] = field->type;\n\t\tMOVING_GC_REGISTER (&dgclass->field_objects [i]);\n\t\tdgclass->field_objects [i] = obj;\n\n\t\tif (inflated_field) {\n\t\t\tg_free (inflated_field);\n\t\t} else {\n\t\t\tdgclass->fields [i].name = g_strdup (dgclass->fields [i].name);\n\t\t}\n\t}\n\n\tfor (i = 0; i < dgclass->count_properties; i++) {\n\t\tMonoObject *obj = mono_array_get (properties, gpointer, i);\n\t\tMonoProperty *property = &dgclass->properties [i];\n\n\t\tif (!strcmp (obj->vtable->klass->name, \"PropertyBuilder\")) {\n\t\t\tMonoReflectionPropertyBuilder *pb = (MonoReflectionPropertyBuilder *) obj;\n\n\t\t\tproperty->parent = klass;\n\t\t\tproperty->attrs = pb->attrs;\n\t\t\tproperty->name = mono_string_to_utf8 (pb->name);\n\t\t\tif (pb->get_method)\n\t\t\t\tproperty->get = inflate_method (type, (MonoObject *) pb->get_method);\n\t\t\tif (pb->set_method)\n\t\t\t\tproperty->set = inflate_method (type, (MonoObject *) pb->set_method);\n\t\t} else if (!strcmp (obj->vtable->klass->name, \"MonoProperty\")) {\n\t\t\t*property = *((MonoReflectionProperty *) obj)->property;\n\t\t\tproperty->name = g_strdup (property->name);\n\n\t\t\tif (property->get)\n\t\t\t\tproperty->get = inflate_mono_method (klass, property->get, NULL);\n\t\t\tif (property->set)\n\t\t\t\tproperty->set = inflate_mono_method (klass, property->set, NULL);\n\t\t} else\n\t\t\tg_assert_not_reached ();\n\t}\n\n\tfor (i = 0; i < dgclass->count_events; i++) {\n\t\tMonoObject *obj = mono_array_get (events, gpointer, i);\n\t\tMonoEvent *event = &dgclass->events [i];\n\n\t\tif (!strcmp (obj->vtable->klass->name, \"EventBuilder\")) {\n\t\t\tMonoReflectionEventBuilder *eb = (MonoReflectionEventBuilder *) obj;\n\n\t\t\tevent->parent = klass;\n\t\t\tevent->attrs = eb->attrs;\n\t\t\tevent->name = mono_string_to_utf8 (eb->name);\n\t\t\tif (eb->add_method)\n\t\t\t\tevent->add = inflate_method (type, (MonoObject *) eb->add_method);\n\t\t\tif (eb->remove_method)\n\t\t\t\tevent->remove = inflate_method (type, (MonoObject *) eb->remove_method);\n\t\t} else if (!strcmp (obj->vtable->klass->name, \"MonoEvent\")) {\n\t\t\t*event = *((MonoReflectionMonoEvent *) obj)->event;\n\t\t\tevent->name = g_strdup (event->name);\n\n\t\t\tif (event->add)\n\t\t\t\tevent->add = inflate_mono_method (klass, event->add, NULL);\n\t\t\tif (event->remove)\n\t\t\t\tevent->remove = inflate_mono_method (klass, event->remove, NULL);\n\t\t} else\n\t\t\tg_assert_not_reached ();\n\t}\n\n\tdgclass->initialized = TRUE;\n}\n\nstatic void\nensure_generic_class_runtime_vtable (MonoClass *klass)\n{\n\tMonoClass *gklass = klass->generic_class->container_class;\n\tint i;\n\n\tif (klass->wastypebuilder)\n\t\treturn;\n\n\tensure_runtime_vtable (gklass);\n\n\tklass->method.count = gklass->method.count;\n\tklass->methods = mono_image_alloc (klass->image, sizeof (MonoMethod*) * (klass->method.count + 1));\n\n\tfor (i = 0; i < klass->method.count; i++) {\n\t\tklass->methods [i] = mono_class_inflate_generic_method_full (\n\t\t\tgklass->methods [i], klass, mono_class_get_context (klass));\n\t}\n\n\tklass->interface_count = gklass->interface_count;\n\tklass->interfaces = mono_image_alloc (klass->image, sizeof (MonoClass*) * klass->interface_count);\n\tfor (i = 0; i < klass->interface_count; ++i) {\n\t\tMonoType *iface_type = mono_class_inflate_generic_type (&gklass->interfaces [i]->byval_arg, mono_class_get_context (klass));\n\t\tklass->interfaces [i] = mono_class_from_mono_type (iface_type);\n\t\tmono_metadata_free_type (iface_type);\n\n\t\tensure_runtime_vtable (klass->interfaces [i]);\n\t}\n\tklass->interfaces_inited = 1;\n\n\t/*We can only finish with this klass once it's parent has as well*/\n\tif (gklass->wastypebuilder)\n\t\tklass->wastypebuilder = TRUE;\n\treturn;\n}\n\nstatic void\nensure_runtime_vtable (MonoClass *klass)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tint i, num, j;\n\n\tif (!klass->image->dynamic || (!tb && !klass->generic_class) || klass->wastypebuilder)\n\t\treturn;\n\tif (klass->parent)\n\t\tensure_runtime_vtable (klass->parent);\n\n\tif (tb) {\n\t\tnum = tb->ctors? mono_array_length (tb->ctors): 0;\n\t\tnum += tb->num_methods;\n\t\tklass->method.count = num;\n\t\tklass->methods = mono_image_alloc (klass->image, sizeof (MonoMethod*) * num);\n\t\tnum = tb->ctors? mono_array_length (tb->ctors): 0;\n\t\tfor (i = 0; i < num; ++i)\n\t\t\tklass->methods [i] = ctorbuilder_to_mono_method (klass, mono_array_get (tb->ctors, MonoReflectionCtorBuilder*, i));\n\t\tnum = tb->num_methods;\n\t\tj = i;\n\t\tfor (i = 0; i < num; ++i)\n\t\t\tklass->methods [j++] = methodbuilder_to_mono_method (klass, mono_array_get (tb->methods, MonoReflectionMethodBuilder*, i));\n\t\n\t\tif (tb->interfaces) {\n\t\t\tklass->interface_count = mono_array_length (tb->interfaces);\n\t\t\tklass->interfaces = mono_image_alloc (klass->image, sizeof (MonoClass*) * klass->interface_count);\n\t\t\tfor (i = 0; i < klass->interface_count; ++i) {\n\t\t\t\tMonoType *iface = mono_type_array_get_and_resolve (tb->interfaces, i);\n\t\t\t\tklass->interfaces [i] = mono_class_from_mono_type (iface);\n\t\t\t\tensure_runtime_vtable (klass->interfaces [i]);\n\t\t\t}\n\t\t\tklass->interfaces_inited = 1;\n\t\t}\n\t} else if (klass->generic_class){\n\t\tensure_generic_class_runtime_vtable (klass);\n\t}\n\n\tif (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {\n\t\tfor (i = 0; i < klass->method.count; ++i)\n\t\t\tklass->methods [i]->slot = i;\n\t\t\n\t\tmono_class_setup_interface_offsets (klass);\n\t\tmono_class_setup_interface_id (klass);\n\t}\n\n\t/*\n\t * The generic vtable is needed even if image->run is not set since some\n\t * runtime code like ves_icall_Type_GetMethodsByName depends on \n\t * method->slot being defined.\n\t */\n\n\t/* \n\t * tb->methods could not be freed since it is used for determining \n\t * overrides during dynamic vtable construction.\n\t */\n}\n\nstatic MonoMethod*\nmono_reflection_method_get_handle (MonoObject *method)\n{\n\tMonoClass *class = mono_object_class (method);\n\tif (is_sr_mono_method (class) || is_sr_mono_generic_method (class)) {\n\t\tMonoReflectionMethod *sr_method = (MonoReflectionMethod*)method;\n\t\treturn sr_method->method;\n\t}\n\tif (is_sre_method_builder (class)) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder*)method;\n\t\treturn mb->mhandle;\n\t}\n\tif (is_sre_method_on_tb_inst (class)) {\n\t\tMonoReflectionMethodOnTypeBuilderInst *m = (MonoReflectionMethodOnTypeBuilderInst*)method;\n\t\tMonoMethod *result;\n\t\t/*FIXME move this to a proper method and unify with resolve_object*/\n\t\tif (m->method_args) {\n\t\t\tresult = mono_reflection_method_on_tb_inst_get_handle (m);\n\t\t} else {\n\t\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)m->inst);\n\t\t\tMonoClass *inflated_klass = mono_class_from_mono_type (type);\n\t\t\tMonoMethod *mono_method;\n\n\t\t\tif (is_sre_method_builder (mono_object_class (m->mb)))\n\t\t\t\tmono_method = ((MonoReflectionMethodBuilder *)m->mb)->mhandle;\n \t\t\telse if (is_sr_mono_method (mono_object_class (m->mb)))\n\t\t\t\tmono_method = ((MonoReflectionMethod *)m->mb)->method;\n\t\t\telse\n\t\t\t\tg_error (\"resolve_object:: can't handle a MTBI with base_method of type %s\", mono_type_get_full_name (mono_object_class (m->mb)));\n\n\t\t\tresult = inflate_mono_method (inflated_klass, mono_method, (MonoObject*)m->mb);\n\t\t}\n\t\treturn result;\n\t}\n\n\tg_error (\"Can't handle methods of type %s:%s\", class->name_space, class->name);\n\treturn NULL;\n}\n\nvoid\nmono_reflection_get_dynamic_overrides (MonoClass *klass, MonoMethod ***overrides, int *num_overrides)\n{\n\tMonoReflectionTypeBuilder *tb;\n\tint i, onum;\n\n\t*overrides = NULL;\n\t*num_overrides = 0;\n\n\tg_assert (klass->image->dynamic);\n\n\tif (!klass->reflection_info)\n\t\treturn;\n\n\tg_assert (strcmp (((MonoObject*)klass->reflection_info)->vtable->klass->name, \"TypeBuilder\") == 0);\n\n\ttb = (MonoReflectionTypeBuilder*)klass->reflection_info;\n\n\tonum = 0;\n\tif (tb->methods) {\n\t\tfor (i = 0; i < tb->num_methods; ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\tmono_array_get (tb->methods, MonoReflectionMethodBuilder*, i);\n\t\t\tif (mb->override_method)\n\t\t\t\tonum ++;\n\t\t}\n\t}\n\n\tif (onum) {\n\t\t*overrides = g_new0 (MonoMethod*, onum * 2);\n\n\t\tonum = 0;\n\t\tfor (i = 0; i < tb->num_methods; ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\tmono_array_get (tb->methods, MonoReflectionMethodBuilder*, i);\n\t\t\tif (mb->override_method) {\n\t\t\t\t(*overrides) [onum * 2] = mono_reflection_method_get_handle ((MonoObject *)mb->override_method);\n\t\t\t\t(*overrides) [onum * 2 + 1] = mb->mhandle;\n\n\t\t\t\tg_assert (mb->mhandle);\n\n\t\t\t\tonum ++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*num_overrides = onum;\n}\n\nstatic void\ntypebuilder_setup_fields (MonoClass *klass, MonoError *error)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tMonoReflectionFieldBuilder *fb;\n\tMonoClassField *field;\n\tMonoImage *image = klass->image;\n\tconst char *p, *p2;\n\tint i;\n\tguint32 len, idx, real_size = 0;\n\n\tklass->field.count = tb->num_fields;\n\tklass->field.first = 0;\n\n\tmono_error_init (error);\n\n\tif (tb->class_size) {\n\t\tg_assert ((tb->packing_size & 0xfffffff0) == 0);\n\t\tklass->packing_size = tb->packing_size;\n\t\treal_size = klass->instance_size + tb->class_size;\n\t}\n\n\tif (!klass->field.count) {\n\t\tklass->instance_size = MAX (klass->instance_size, real_size);\n\t\treturn;\n\t}\n\t\n\tklass->fields = image_g_new0 (image, MonoClassField, klass->field.count);\n\tmono_class_alloc_ext (klass);\n\tklass->ext->field_def_values = image_g_new0 (image, MonoFieldDefaultValue, klass->field.count);\n\t/*\n\tThis is, guess what, a hack.\n\tThe issue is that the runtime doesn't know how to setup the fields of a typebuider and crash.\n\tOn the static path no field class is resolved, only types are built. This is the right thing to do\n\tbut we suck.\n\tSetting size_inited is harmless because we're doing the same job as mono_class_setup_fields anyway.\n\t*/\n\tklass->size_inited = 1;\n\n\tfor (i = 0; i < klass->field.count; ++i) {\n\t\tfb = mono_array_get (tb->fields, gpointer, i);\n\t\tfield = &klass->fields [i];\n\t\tfield->name = mono_string_to_utf8_image (image, fb->name, error);\n\t\tif (!mono_error_ok (error))\n\t\t\treturn;\n\t\tif (fb->attrs) {\n\t\t\tfield->type = mono_metadata_type_dup (klass->image, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type));\n\t\t\tfield->type->attrs = fb->attrs;\n\t\t} else {\n\t\t\tfield->type = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t\t}\n\t\tif ((fb->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA) && fb->rva_data)\n\t\t\tklass->ext->field_def_values [i].data = mono_array_addr (fb->rva_data, char, 0);\n\t\tif (fb->offset != -1)\n\t\t\tfield->offset = fb->offset;\n\t\tfield->parent = klass;\n\t\tfb->handle = field;\n\t\tmono_save_custom_attrs (klass->image, field, fb->cattrs);\n\n\t\tif (fb->def_value) {\n\t\t\tMonoDynamicImage *assembly = (MonoDynamicImage*)klass->image;\n\t\t\tfield->type->attrs |= FIELD_ATTRIBUTE_HAS_DEFAULT;\n\t\t\tidx = encode_constant (assembly, fb->def_value, &klass->ext->field_def_values [i].def_type);\n\t\t\t/* Copy the data from the blob since it might get realloc-ed */\n\t\t\tp = assembly->blob.data + idx;\n\t\t\tlen = mono_metadata_decode_blob_size (p, &p2);\n\t\t\tlen += p2 - p;\n\t\t\tklass->ext->field_def_values [i].data = mono_image_alloc (image, len);\n\t\t\tmemcpy ((gpointer)klass->ext->field_def_values [i].data, p, len);\n\t\t}\n\t}\n\n\tklass->instance_size = MAX (klass->instance_size, real_size);\n\tmono_class_layout_fields (klass);\n}\n\nstatic void\ntypebuilder_setup_properties (MonoClass *klass, MonoError *error)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tMonoReflectionPropertyBuilder *pb;\n\tMonoImage *image = klass->image;\n\tMonoProperty *properties;\n\tint i;\n\n\tmono_error_init (error);\n\n\tif (!klass->ext)\n\t\tklass->ext = image_g_new0 (image, MonoClassExt, 1);\n\n\tklass->ext->property.count = tb->properties ? mono_array_length (tb->properties) : 0;\n\tklass->ext->property.first = 0;\n\n\tproperties = image_g_new0 (image, MonoProperty, klass->ext->property.count);\n\tklass->ext->properties = properties;\n\tfor (i = 0; i < klass->ext->property.count; ++i) {\n\t\tpb = mono_array_get (tb->properties, MonoReflectionPropertyBuilder*, i);\n\t\tproperties [i].parent = klass;\n\t\tproperties [i].attrs = pb->attrs;\n\t\tproperties [i].name = mono_string_to_utf8_image (image, pb->name, error);\n\t\tif (!mono_error_ok (error))\n\t\t\treturn;\n\t\tif (pb->get_method)\n\t\t\tproperties [i].get = pb->get_method->mhandle;\n\t\tif (pb->set_method)\n\t\t\tproperties [i].set = pb->set_method->mhandle;\n\n\t\tmono_save_custom_attrs (klass->image, &properties [i], pb->cattrs);\n\t}\n}\n\nMonoReflectionEvent *\nmono_reflection_event_builder_get_event_info (MonoReflectionTypeBuilder *tb, MonoReflectionEventBuilder *eb)\n{\n\tMonoEvent *event = g_new0 (MonoEvent, 1);\n\tMonoClass *klass;\n\tint j;\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\tevent->parent = klass;\n\tevent->attrs = eb->attrs;\n\tevent->name = mono_string_to_utf8 (eb->name);\n\tif (eb->add_method)\n\t\tevent->add = eb->add_method->mhandle;\n\tif (eb->remove_method)\n\t\tevent->remove = eb->remove_method->mhandle;\n\tif (eb->raise_method)\n\t\tevent->raise = eb->raise_method->mhandle;\n\n\tif (eb->other_methods) {\n\t\tevent->other = g_new0 (MonoMethod*, mono_array_length (eb->other_methods) + 1);\n\t\tfor (j = 0; j < mono_array_length (eb->other_methods); ++j) {\n\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\tmono_array_get (eb->other_methods,\n\t\t\t\t\t\tMonoReflectionMethodBuilder*, j);\n\t\t\tevent->other [j] = mb->mhandle;\n\t\t}\n\t}\n\n\treturn mono_event_get_object (mono_object_domain (tb), klass, event);\n}\n\nstatic void\ntypebuilder_setup_events (MonoClass *klass, MonoError *error)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tMonoReflectionEventBuilder *eb;\n\tMonoImage *image = klass->image;\n\tMonoEvent *events;\n\tint i, j;\n\n\tmono_error_init (error);\n\n\tif (!klass->ext)\n\t\tklass->ext = image_g_new0 (image, MonoClassExt, 1);\n\n\tklass->ext->event.count = tb->events ? mono_array_length (tb->events) : 0;\n\tklass->ext->event.first = 0;\n\n\tevents = image_g_new0 (image, MonoEvent, klass->ext->event.count);\n\tklass->ext->events = events;\n\tfor (i = 0; i < klass->ext->event.count; ++i) {\n\t\teb = mono_array_get (tb->events, MonoReflectionEventBuilder*, i);\n\t\tevents [i].parent = klass;\n\t\tevents [i].attrs = eb->attrs;\n\t\tevents [i].name = mono_string_to_utf8_image (image, eb->name, error);\n\t\tif (!mono_error_ok (error))\n\t\t\treturn;\n\t\tif (eb->add_method)\n\t\t\tevents [i].add = eb->add_method->mhandle;\n\t\tif (eb->remove_method)\n\t\t\tevents [i].remove = eb->remove_method->mhandle;\n\t\tif (eb->raise_method)\n\t\t\tevents [i].raise = eb->raise_method->mhandle;\n\n\t\tif (eb->other_methods) {\n\t\t\tevents [i].other = image_g_new0 (image, MonoMethod*, mono_array_length (eb->other_methods) + 1);\n\t\t\tfor (j = 0; j < mono_array_length (eb->other_methods); ++j) {\n\t\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\t\tmono_array_get (eb->other_methods,\n\t\t\t\t\t\t\t\t\tMonoReflectionMethodBuilder*, j);\n\t\t\t\tevents [i].other [j] = mb->mhandle;\n\t\t\t}\n\t\t}\n\t\tmono_save_custom_attrs (klass->image, &events [i], eb->cattrs);\n\t}\n}\n\nstatic gboolean\nremove_instantiations_of (gpointer key,\n\t\t\t\t\t\t  gpointer value,\n\t\t\t\t\t\t  gpointer user_data)\n{\n\tMonoType *type = (MonoType*)key;\n\tMonoClass *klass = (MonoClass*)user_data;\n\n\tif ((type->type == MONO_TYPE_GENERICINST) && (type->data.generic_class->container_class == klass))\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}\n\nstatic void\ncheck_array_for_usertypes (MonoArray *arr)\n{\n\tint i;\n\n\tif (!arr)\n\t\treturn;\n\n\tfor (i = 0; i < mono_array_length (arr); ++i)\n\t\tRESOLVE_ARRAY_TYPE_ELEMENT (arr, i);\n}\n\nMonoReflectionType*\nmono_reflection_create_runtime_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoError error;\n\tMonoClass *klass;\n\tMonoDomain* domain;\n\tMonoReflectionType* res;\n\tint i, j;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = mono_object_domain (tb);\n\tklass = mono_class_from_mono_type (tb->type.type);\n\n\t/*\n\t * Check for user defined Type subclasses.\n\t */\n\tRESOLVE_TYPE (tb->parent);\n\tcheck_array_for_usertypes (tb->interfaces);\n\tif (tb->fields) {\n\t\tfor (i = 0; i < mono_array_length (tb->fields); ++i) {\n\t\t\tMonoReflectionFieldBuilder *fb = mono_array_get (tb->fields, gpointer, i);\n\t\t\tif (fb) {\n\t\t\t\tRESOLVE_TYPE (fb->type);\n\t\t\t\tcheck_array_for_usertypes (fb->modreq);\n\t\t\t\tcheck_array_for_usertypes (fb->modopt);\n\t\t\t\tif (fb->marshal_info && fb->marshal_info->marshaltyperef)\n\t\t\t\t\tRESOLVE_TYPE (fb->marshal_info->marshaltyperef);\n\t\t\t}\n\t\t}\n\t}\n\tif (tb->methods) {\n\t\tfor (i = 0; i < mono_array_length (tb->methods); ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = mono_array_get (tb->methods, gpointer, i);\n\t\t\tif (mb) {\n\t\t\t\tRESOLVE_TYPE (mb->rtype);\n\t\t\t\tcheck_array_for_usertypes (mb->return_modreq);\n\t\t\t\tcheck_array_for_usertypes (mb->return_modopt);\n\t\t\t\tcheck_array_for_usertypes (mb->parameters);\n\t\t\t\tif (mb->param_modreq)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modreq); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modreq, MonoArray*, j));\n\t\t\t\tif (mb->param_modopt)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modopt); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modopt, MonoArray*, j));\n\t\t\t}\n\t\t}\n\t}\n\tif (tb->ctors) {\n\t\tfor (i = 0; i < mono_array_length (tb->ctors); ++i) {\n\t\t\tMonoReflectionCtorBuilder *mb = mono_array_get (tb->ctors, gpointer, i);\n\t\t\tif (mb) {\n\t\t\t\tcheck_array_for_usertypes (mb->parameters);\n\t\t\t\tif (mb->param_modreq)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modreq); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modreq, MonoArray*, j));\n\t\t\t\tif (mb->param_modopt)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modopt); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modopt, MonoArray*, j));\n\t\t\t}\n\t\t}\n\t}\n\n\tmono_save_custom_attrs (klass->image, klass, tb->cattrs);\n\n\t/* \n\t * we need to lock the domain because the lock will be taken inside\n\t * So, we need to keep the locking order correct.\n\t */\n\tmono_loader_lock ();\n\tmono_domain_lock (domain);\n\tif (klass->wastypebuilder) {\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\treturn mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n\t}\n\t/*\n\t * Fields to set in klass:\n\t * the various flags: delegate/unicode/contextbound etc.\n\t */\n\tklass->flags = tb->attrs;\n\tklass->has_cctor = 1;\n\tklass->has_finalize = 1;\n\n#if 0\n\tif (!((MonoDynamicImage*)klass->image)->run) {\n\t\tif (klass->generic_container) {\n\t\t\t/* FIXME: The code below can't handle generic classes */\n\t\t\tklass->wastypebuilder = TRUE;\n\t\t\tmono_loader_unlock ();\n\t\t\tmono_domain_unlock (domain);\n\t\t\treturn mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n\t\t}\n\t}\n#endif\n\n\t/* enums are done right away */\n\tif (!klass->enumtype)\n\t\tensure_runtime_vtable (klass);\n\n\tif (tb->subtypes) {\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i) {\n\t\t\tMonoReflectionTypeBuilder *subtb = mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i);\n\t\t\tmono_class_alloc_ext (klass);\n\t\t\tklass->ext->nested_classes = g_list_prepend_image (klass->image, klass->ext->nested_classes, mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)subtb)));\n\t\t}\n\t}\n\n\tklass->nested_classes_inited = TRUE;\n\n\t/* fields and object layout */\n\tif (klass->parent) {\n\t\tif (!klass->parent->size_inited)\n\t\t\tmono_class_init (klass->parent);\n\t\tklass->instance_size = klass->parent->instance_size;\n\t\tklass->sizes.class_size = 0;\n\t\tklass->min_align = klass->parent->min_align;\n\t\t/* if the type has no fields we won't call the field_setup\n\t\t * routine which sets up klass->has_references.\n\t\t */\n\t\tklass->has_references |= klass->parent->has_references;\n\t} else {\n\t\tklass->instance_size = sizeof (MonoObject);\n\t\tklass->min_align = 1;\n\t}\n\n\t/* FIXME: handle packing_size and instance_size */\n\ttypebuilder_setup_fields (klass, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\ttypebuilder_setup_properties (klass, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\n\ttypebuilder_setup_events (klass, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\n\tklass->wastypebuilder = TRUE;\n\n\t/* \n\t * If we are a generic TypeBuilder, there might be instantiations in the type cache\n\t * which have type System.Reflection.MonoGenericClass, but after the type is created, \n\t * we want to return normal System.MonoType objects, so clear these out from the cache.\n\t */\n\tif (domain->type_hash && klass->generic_container)\n\t\tmono_g_hash_table_foreach_remove (domain->type_hash, remove_instantiations_of, klass);\n\n\tmono_domain_unlock (domain);\n\tmono_loader_unlock ();\n\n\tif (klass->enumtype && !mono_class_is_valid_enum (klass)) {\n\t\tmono_class_set_failure (klass, MONO_EXCEPTION_TYPE_LOAD, NULL);\n\t\tmono_raise_exception (mono_get_exception_type_load (tb->name, NULL));\n\t}\n\n\tres = mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n\tg_assert (res != (MonoReflectionType*)tb);\n\n\treturn res;\n\nfailure:\n\tmono_class_set_failure (klass, MONO_EXCEPTION_TYPE_LOAD, NULL);\n\tklass->wastypebuilder = TRUE;\n\tmono_domain_unlock (domain);\n\tmono_loader_unlock ();\n\tmono_error_raise_exception (&error);\n\treturn NULL;\n}\n\nvoid\nmono_reflection_initialize_generic_parameter (MonoReflectionGenericParam *gparam)\n{\n\tMonoGenericParamFull *param;\n\tMonoImage *image;\n\tMonoClass *pklass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tparam = g_new0 (MonoGenericParamFull, 1);\n\n\tif (gparam->mbuilder) {\n\t\tif (!gparam->mbuilder->generic_container) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)gparam->mbuilder->type;\n\t\t\tMonoClass *klass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\t\t\tgparam->mbuilder->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\t\t\tgparam->mbuilder->generic_container->is_method = TRUE;\n\t\t\t/* \n\t\t\t * Cannot set owner.method, since the MonoMethod is not created yet.\n\t\t\t * Set the image field instead, so type_in_image () works.\n\t\t\t */\n\t\t\tgparam->mbuilder->generic_container->image = klass->image;\n\t\t}\n\t\tparam->param.owner = gparam->mbuilder->generic_container;\n\t} else if (gparam->tbuilder) {\n\t\tif (!gparam->tbuilder->generic_container) {\n\t\t\tMonoClass *klass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)gparam->tbuilder));\n\t\t\tgparam->tbuilder->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\t\t\tgparam->tbuilder->generic_container->owner.klass = klass;\n\t\t}\n\t\tparam->param.owner = gparam->tbuilder->generic_container;\n\t}\n\n\tparam->info.name = mono_string_to_utf8 (gparam->name);\n\tparam->param.num = gparam->index;\n\n\timage = &gparam->tbuilder->module->dynamic_image->image;\n\tpklass = mono_class_from_generic_parameter ((MonoGenericParam *) param, image, gparam->mbuilder != NULL);\n\n\tgparam->type.type = &pklass->byval_arg;\n\n\tMOVING_GC_REGISTER (&pklass->reflection_info);\n\tpklass->reflection_info = gparam; /* FIXME: GC pin gparam */\n\tmono_image_lock (image);\n\timage->reflection_info_unregister_classes = g_slist_prepend (image->reflection_info_unregister_classes, pklass);\n\tmono_image_unlock (image);\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_local (MonoReflectionSigHelper *sig)\n{\n\tMonoReflectionModuleBuilder *module = sig->module;\n\tMonoDynamicImage *assembly = module != NULL ? module->dynamic_image : NULL;\n\tguint32 na = sig->arguments ? mono_array_length (sig->arguments) : 0;\n\tguint32 buflen, i;\n\tMonoArray *result;\n\tSigBuffer buf;\n\n\tcheck_array_for_usertypes (sig->arguments);\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, 0x07);\n\tsigbuffer_add_value (&buf, na);\n\tif (assembly != NULL){\n\t\tfor (i = 0; i < na; ++i) {\n\t\t\tMonoReflectionType *type = mono_array_get (sig->arguments, MonoReflectionType*, i);\n\t\t\tencode_reflection_type (assembly, type, &buf);\n\t\t}\n\t}\n\n\tbuflen = buf.p - buf.buf;\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, buflen);\n\tmemcpy (mono_array_addr (result, char, 0), buf.buf, buflen);\n\tsigbuffer_free (&buf);\n\n\treturn result;\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_field (MonoReflectionSigHelper *sig)\n{\n\tMonoDynamicImage *assembly = sig->module->dynamic_image;\n\tguint32 na = sig->arguments ? mono_array_length (sig->arguments) : 0;\n\tguint32 buflen, i;\n\tMonoArray *result;\n\tSigBuffer buf;\n\n\tcheck_array_for_usertypes (sig->arguments);\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, 0x06);\n\tfor (i = 0; i < na; ++i) {\n\t\tMonoReflectionType *type = mono_array_get (sig->arguments, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, type, &buf);\n\t}\n\n\tbuflen = buf.p - buf.buf;\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, buflen);\n\tmemcpy (mono_array_addr (result, char, 0), buf.buf, buflen);\n\tsigbuffer_free (&buf);\n\n\treturn result;\n}\n\nvoid \nmono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\tMonoClass *klass;\n\tGSList *l;\n\tint i;\n\n\tsig = dynamic_method_to_signature (mb);\n\n\treflection_methodbuilder_from_dynamic_method (&rmb, mb);\n\n\t/*\n\t * Resolve references.\n\t */\n\t/* \n\t * Every second entry in the refs array is reserved for storing handle_class,\n\t * which is needed by the ldtoken implementation in the JIT.\n\t */\n\trmb.nrefs = mb->nrefs;\n\trmb.refs = g_new0 (gpointer, mb->nrefs + 1);\n\tfor (i = 0; i < mb->nrefs; i += 2) {\n\t\tMonoClass *handle_class;\n\t\tgpointer ref;\n\t\tMonoObject *obj = mono_array_get (mb->refs, MonoObject*, i);\n\n\t\tif (strcmp (obj->vtable->klass->name, \"DynamicMethod\") == 0) {\n\t\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)obj;\n\t\t\t/*\n\t\t\t * The referenced DynamicMethod should already be created by the managed\n\t\t\t * code, except in the case of circular references. In that case, we store\n\t\t\t * method in the refs array, and fix it up later when the referenced \n\t\t\t * DynamicMethod is created.\n\t\t\t */\n\t\t\tif (method->mhandle) {\n\t\t\t\tref = method->mhandle;\n\t\t\t} else {\n\t\t\t\t/* FIXME: GC object stored in unmanaged memory */\n\t\t\t\tref = method;\n\n\t\t\t\t/* FIXME: GC object stored in unmanaged memory */\n\t\t\t\tmethod->referenced_by = g_slist_append (method->referenced_by, mb);\n\t\t\t}\n\t\t\thandle_class = mono_defaults.methodhandle_class;\n\t\t} else {\n\t\t\tMonoException *ex = NULL;\n\t\t\tref = resolve_object (mb->module->image, obj, &handle_class, NULL);\n\t\t\tif (!ref)\n\t\t\t\tex = mono_get_exception_type_load (NULL, NULL);\n\t\t\telse if (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\t\t\tex = mono_security_core_clr_ensure_dynamic_method_resolved_object (ref, handle_class);\n\n\t\t\tif (ex) {\n\t\t\t\tg_free (rmb.refs);\n\t\t\t\tmono_raise_exception (ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\trmb.refs [i] = ref; /* FIXME: GC object stored in unmanaged memory (change also resolve_object() signature) */\n\t\trmb.refs [i + 1] = handle_class;\n\t}\t\t\n\n\tklass = mb->owner ? mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)mb->owner)) : mono_defaults.object_class;\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\n\t/* Fix up refs entries pointing at us */\n\tfor (l = mb->referenced_by; l; l = l->next) {\n\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)l->data;\n\t\tMonoMethodWrapper *wrapper = (MonoMethodWrapper*)method->mhandle;\n\t\tgpointer *data;\n\t\t\n\t\tg_assert (method->mhandle);\n\n\t\tdata = (gpointer*)wrapper->method_data;\n\t\tfor (i = 0; i < GPOINTER_TO_UINT (data [0]); i += 2) {\n\t\t\tif ((data [i + 1] == mb) && (data [i + 1 + 1] == mono_defaults.methodhandle_class))\n\t\t\t\tdata [i + 1] = mb->mhandle;\n\t\t}\n\t}\n\tg_slist_free (mb->referenced_by);\n\n\tg_free (rmb.refs);\n\n\t/* ilgen is no longer needed */\n\tmb->ilgen = NULL;\n}\n\n#endif /* DISABLE_REFLECTION_EMIT */\n\nvoid\nmono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tg_assert (mb);\n\n\tif (mb->mhandle)\n\t\tmono_runtime_free_method (\n\t\t\tmono_object_get_domain ((MonoObject*)mb), mb->mhandle);\n}\n\n/**\n * \n * mono_reflection_is_valid_dynamic_token:\n * \n * Returns TRUE if token is valid.\n * \n */\ngboolean\nmono_reflection_is_valid_dynamic_token (MonoDynamicImage *image, guint32 token)\n{\n\treturn mono_g_hash_table_lookup (image->tokens, GUINT_TO_POINTER (token)) != NULL;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n\n/**\n * mono_reflection_lookup_dynamic_token:\n *\n * Finish the Builder object pointed to by TOKEN and return the corresponding\n * runtime structure. If HANDLE_CLASS is not NULL, it is set to the class required by \n * mono_ldtoken. If valid_token is TRUE, assert if it is not found in the token->object\n * mapping table.\n *\n * LOCKING: Take the loader lock\n */\ngpointer\nmono_reflection_lookup_dynamic_token (MonoImage *image, guint32 token, gboolean valid_token, MonoClass **handle_class, MonoGenericContext *context)\n{\n\tMonoDynamicImage *assembly = (MonoDynamicImage*)image;\n\tMonoObject *obj;\n\tMonoClass *klass;\n\n\tmono_loader_lock ();\n\tobj = mono_g_hash_table_lookup (assembly->tokens, GUINT_TO_POINTER (token));\n\tmono_loader_unlock ();\n\tif (!obj) {\n\t\tif (valid_token)\n\t\t\tg_error (\"Could not find required dynamic token 0x%08x\", token);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tif (!handle_class)\n\t\thandle_class = &klass;\n\treturn resolve_object (image, obj, handle_class, context);\n}\n\n/*\n * ensure_complete_type:\n *\n *   Ensure that KLASS is completed if it is a dynamic type, or references\n * dynamic types.\n */\nstatic void\nensure_complete_type (MonoClass *klass)\n{\n\tif (klass->image->dynamic && !klass->wastypebuilder) {\n\t\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\n\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\n\t\t// Asserting here could break a lot of code\n\t\t//g_assert (klass->wastypebuilder);\n\t}\n\n\tif (klass->generic_class) {\n\t\tMonoGenericInst *inst = klass->generic_class->context.class_inst;\n\t\tint i;\n\n\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\tensure_complete_type (mono_class_from_mono_type (inst->type_argv [i]));\n\t\t}\n\t}\n}\n\nstatic gpointer\nresolve_object (MonoImage *image, MonoObject *obj, MonoClass **handle_class, MonoGenericContext *context)\n{\n\tgpointer result = NULL;\n\n\tif (strcmp (obj->vtable->klass->name, \"String\") == 0) {\n\t\tresult = mono_string_intern ((MonoString*)obj);\n\t\t*handle_class = mono_defaults.string_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoType\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)obj);\n\t\tif (context) {\n\t\t\tMonoType *inflated = mono_class_inflate_generic_type (type, context);\n\t\t\tresult = mono_class_from_mono_type (inflated);\n\t\t\tmono_metadata_free_type (inflated);\n\t\t} else {\n\t\t\tresult = mono_class_from_mono_type (type);\n\t\t}\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoMethod\") == 0 ||\n\t\t   strcmp (obj->vtable->klass->name, \"MonoCMethod\") == 0 ||\n\t\t   strcmp (obj->vtable->klass->name, \"MonoGenericCMethod\") == 0 ||\n\t\t   strcmp (obj->vtable->klass->name, \"MonoGenericMethod\") == 0) {\n\t\tresult = ((MonoReflectionMethod*)obj)->method;\n\t\tif (context)\n\t\t\tresult = mono_class_inflate_generic_method (result, context);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder*)obj;\n\t\tresult = mb->mhandle;\n\t\tif (!result) {\n\t\t\t/* Type is not yet created */\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)mb->type;\n\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\n\t\t\t/*\n\t\t\t * Hopefully this has been filled in by calling CreateType() on the\n\t\t\t * TypeBuilder.\n\t\t\t */\n\t\t\t/*\n\t\t\t * TODO: This won't work if the application finishes another \n\t\t\t * TypeBuilder instance instead of this one.\n\t\t\t */\n\t\t\tresult = mb->mhandle;\n\t\t}\n\t\tif (context)\n\t\t\tresult = mono_class_inflate_generic_method (result, context);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"ConstructorBuilder\") == 0) {\n\t\tMonoReflectionCtorBuilder *cb = (MonoReflectionCtorBuilder*)obj;\n\n\t\tresult = cb->mhandle;\n\t\tif (!result) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)cb->type;\n\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\t\t\tresult = cb->mhandle;\n\t\t}\n\t\tif (context)\n\t\t\tresult = mono_class_inflate_generic_method (result, context);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoField\") == 0) {\n\t\tMonoClassField *field = ((MonoReflectionField*)obj)->field;\n\n\t\tensure_complete_type (field->parent);\n\t\tif (context) {\n\t\t\tMonoType *inflated = mono_class_inflate_generic_type (&field->parent->byval_arg, context);\n\t\t\tMonoClass *class = mono_class_from_mono_type (inflated);\n\t\t\tMonoClassField *inflated_field;\n\t\t\tgpointer iter = NULL;\n\t\t\tmono_metadata_free_type (inflated);\n\t\t\twhile ((inflated_field = mono_class_get_fields (class, &iter))) {\n\t\t\t\tif (!strcmp (field->name, inflated_field->name))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tg_assert (inflated_field && !strcmp (field->name, inflated_field->name));\n\t\t\tresult = inflated_field;\n\t\t} else {\n\t\t\tresult = field;\n\t\t}\n\t\t*handle_class = mono_defaults.fieldhandle_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder*)obj;\n\t\tresult = fb->handle;\n\n\t\tif (!result) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)fb->typeb;\n\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\t\t\tresult = fb->handle;\n\t\t}\n\n\t\tif (fb->handle && fb->handle->parent->generic_container) {\n\t\t\tMonoClass *klass = fb->handle->parent;\n\t\t\tMonoType *type = mono_class_inflate_generic_type (&klass->byval_arg, context);\n\t\t\tMonoClass *inflated = mono_class_from_mono_type (type);\n\n\t\t\tresult = mono_class_get_field_from_name (inflated, mono_field_get_name (fb->handle));\n\t\t\tg_assert (result);\n\t\t\tmono_metadata_free_type (type);\n\t\t}\n\t\t*handle_class = mono_defaults.fieldhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"TypeBuilder\") == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)obj;\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)tb); \n\t\tMonoClass *klass;\n\n\t\tklass = type->data.klass;\n\t\tif (klass->wastypebuilder) {\n\t\t\t/* Already created */\n\t\t\tresult = klass;\n\t\t}\n\t\telse {\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\t\t\tresult = type->data.klass;\n\t\t\tg_assert (result);\n\t\t}\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"SignatureHelper\") == 0) {\n\t\tMonoReflectionSigHelper *helper = (MonoReflectionSigHelper*)obj;\n\t\tMonoMethodSignature *sig;\n\t\tint nargs, i;\n\n\t\tif (helper->arguments)\n\t\t\tnargs = mono_array_length (helper->arguments);\n\t\telse\n\t\t\tnargs = 0;\n\n\t\tsig = mono_metadata_signature_alloc (image, nargs);\n\t\tsig->explicit_this = helper->call_conv & 64 ? 1 : 0;\n\t\tsig->hasthis = helper->call_conv & 32 ? 1 : 0;\n\n\t\tif (helper->unmanaged_call_conv) { /* unmanaged */\n\t\t\tsig->call_convention = helper->unmanaged_call_conv - 1;\n\t\t\tsig->pinvoke = TRUE;\n\t\t} else if (helper->call_conv & 0x02) {\n\t\t\tsig->call_convention = MONO_CALL_VARARG;\n\t\t} else {\n\t\t\tsig->call_convention = MONO_CALL_DEFAULT;\n\t\t}\n\n\t\tsig->param_count = nargs;\n\t\t/* TODO: Copy type ? */\n\t\tsig->ret = helper->return_type->type;\n\t\tfor (i = 0; i < nargs; ++i)\n\t\t\tsig->params [i] = mono_type_array_get_and_resolve (helper->arguments, i);\n\n\t\tresult = sig;\n\t\t*handle_class = NULL;\n\t} else if (strcmp (obj->vtable->klass->name, \"DynamicMethod\") == 0) {\n\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)obj;\n\t\t/* Already created by the managed code */\n\t\tg_assert (method->mhandle);\n\t\tresult = method->mhandle;\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"GenericTypeParameterBuilder\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)obj);\n\t\ttype = mono_class_inflate_generic_type (type, context);\n\t\tresult = mono_class_from_mono_type (type);\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t\tg_assert (result);\n\t\tmono_metadata_free_type (type);\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoGenericClass\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)obj);\n\t\ttype = mono_class_inflate_generic_type (type, context);\n\t\tresult = mono_class_from_mono_type (type);\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t\tg_assert (result);\n\t\tmono_metadata_free_type (type);\n\t} else if (strcmp (obj->vtable->klass->name, \"FieldOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionFieldOnTypeBuilderInst *f = (MonoReflectionFieldOnTypeBuilderInst*)obj;\n\t\tMonoClass *inflated;\n\t\tMonoType *type;\n\n\t\ttype = mono_class_inflate_generic_type (mono_reflection_type_get_handle ((MonoReflectionType*)f->inst), context);\n\t\tinflated = mono_class_from_mono_type (type);\n\n\t\tg_assert (f->fb->handle);\n\t\tresult = mono_class_get_field_from_name (inflated, mono_field_get_name (f->fb->handle));\n\t\tg_assert (result);\n\t\tmono_metadata_free_type (type);\n\t\t*handle_class = mono_defaults.fieldhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"ConstructorOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionCtorOnTypeBuilderInst *c = (MonoReflectionCtorOnTypeBuilderInst*)obj;\n\t\tMonoType *type = mono_class_inflate_generic_type (mono_reflection_type_get_handle ((MonoReflectionType*)c->inst), context);\n\t\tMonoClass *inflated_klass = mono_class_from_mono_type (type);\n\t\tg_assert (c->cb->mhandle);\n\t\tresult = inflate_mono_method (inflated_klass, c->cb->mhandle, (MonoObject*)c->cb);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t\tmono_metadata_free_type (type);\n\t} else if (strcmp (obj->vtable->klass->name, \"MethodOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionMethodOnTypeBuilderInst *m = (MonoReflectionMethodOnTypeBuilderInst*)obj;\n\t\tif (m->method_args) {\n\t\t\tresult = mono_reflection_method_on_tb_inst_get_handle (m);\n\t\t} else {\n\t\t\tMonoType *type = mono_class_inflate_generic_type (mono_reflection_type_get_handle ((MonoReflectionType*)m->inst), context);\n\t\t\tMonoClass *inflated_klass = mono_class_from_mono_type (type);\n\t\t\tg_assert (m->mb->mhandle);\n\t\t\tresult = inflate_mono_method (inflated_klass, m->mb->mhandle, (MonoObject*)m->mb);\n\t\t\tmono_metadata_free_type (type);\n\t\t}\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoArrayMethod\") == 0) {\n\t\tMonoReflectionArrayMethod *m = (MonoReflectionArrayMethod*)obj;\n\t\tMonoType *mtype;\n\t\tMonoClass *klass;\n\t\tMonoMethod *method;\n\t\tgpointer iter;\n\t\tchar *name;\n\n\t\tmtype = mono_reflection_type_get_handle (m->parent);\n\t\tklass = mono_class_from_mono_type (mtype);\n\n\t\t/* Find the method */\n\n\t\tname = mono_string_to_utf8 (m->name);\n\t\titer = NULL;\n\t\twhile ((method = mono_class_get_methods (klass, &iter))) {\n\t\t\tif (!strcmp (method->name, name))\n\t\t\t\tbreak;\n\t\t}\n\t\tg_free (name);\n\n\t\t// FIXME:\n\t\tg_assert (method);\n\t\t// FIXME: Check parameters/return value etc. match\n\n\t\tresult = method;\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (is_sre_array (mono_object_get_class(obj)) ||\n\t\t\t\tis_sre_byref (mono_object_get_class(obj)) ||\n\t\t\t\tis_sre_pointer (mono_object_get_class(obj))) {\n\t\tMonoReflectionType *ref_type = (MonoReflectionType *)obj;\n\t\tMonoType *type = mono_reflection_type_get_handle (ref_type);\n\t\tresult = mono_class_from_mono_type (type);\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t} else {\n\t\tg_print (\"%s\\n\", obj->vtable->klass->name);\n\t\tg_assert_not_reached ();\n\t}\n\treturn result;\n}\n\n#else /* DISABLE_REFLECTION_EMIT */\n\nMonoArray*\nmono_reflection_get_custom_attrs_blob (MonoReflectionAssembly *assembly, MonoObject *ctor, MonoArray *ctorArgs, MonoArray *properties, MonoArray *propValues, MonoArray *fields, MonoArray* fieldValues) \n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid\nmono_reflection_setup_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_setup_generic_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_create_generic_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_create_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_image_basic_init (MonoReflectionAssemblyBuilder *assemblyb)\n{\n\tg_error (\"This mono runtime was configured with --enable-minimal=reflection_emit, so System.Reflection.Emit is not supported.\");\n}\n\nvoid\nmono_image_module_basic_init (MonoReflectionModuleBuilder *moduleb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_image_set_wrappers_type (MonoReflectionModuleBuilder *moduleb, MonoReflectionType *type)\n{\n\tg_assert_not_reached ();\n}\n\nMonoReflectionModule *\nmono_image_load_module_dynamic (MonoReflectionAssemblyBuilder *ab, MonoString *fileName)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nguint32\nmono_image_insert_string (MonoReflectionModuleBuilder *module, MonoString *str)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nguint32\nmono_image_create_method_token (MonoDynamicImage *assembly, MonoObject *obj, MonoArray *opt_param_types)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nguint32\nmono_image_create_token (MonoDynamicImage *assembly, MonoObject *obj, \n\t\t\t\t\t\t gboolean create_methodspec, gboolean register_token)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nvoid\nmono_image_register_token (MonoDynamicImage *assembly, guint32 token, MonoObject *obj)\n{\n}\n\nvoid\nmono_reflection_generic_class_initialize (MonoReflectionGenericClass *type, MonoArray *methods, \n\t\t\t\t\t  MonoArray *ctors, MonoArray *fields, MonoArray *properties,\n\t\t\t\t\t  MonoArray *events)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_get_dynamic_overrides (MonoClass *klass, MonoMethod ***overrides, int *num_overrides)\n{\n\t*overrides = NULL;\n\t*num_overrides = 0;\n}\n\nMonoReflectionEvent *\nmono_reflection_event_builder_get_event_info (MonoReflectionTypeBuilder *tb, MonoReflectionEventBuilder *eb)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nMonoReflectionType*\nmono_reflection_create_runtime_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid\nmono_reflection_initialize_generic_parameter (MonoReflectionGenericParam *gparam)\n{\n\tg_assert_not_reached ();\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_local (MonoReflectionSigHelper *sig)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_field (MonoReflectionSigHelper *sig)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid \nmono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n}\n\ngpointer\nmono_reflection_lookup_dynamic_token (MonoImage *image, guint32 token, gboolean valid_token, MonoClass **handle_class, MonoGenericContext *context)\n{\n\treturn NULL;\n}\n\nMonoType*\nmono_reflection_type_get_handle (MonoReflectionType* ref)\n{\n\tif (!ref)\n\t\treturn NULL;\n\treturn ref->type;\n}\n\n#endif /* DISABLE_REFLECTION_EMIT */\n\n/* SECURITY_ACTION_* are defined in mono/metadata/tabledefs.h */\nconst static guint32 declsec_flags_map[] = {\n\t0x00000000,\t\t\t\t\t/* empty */\n\tMONO_DECLSEC_FLAG_REQUEST,\t\t\t/* SECURITY_ACTION_REQUEST\t\t\t(x01) */\n\tMONO_DECLSEC_FLAG_DEMAND,\t\t\t/* SECURITY_ACTION_DEMAND\t\t\t(x02) */\n\tMONO_DECLSEC_FLAG_ASSERT,\t\t\t/* SECURITY_ACTION_ASSERT\t\t\t(x03) */\n\tMONO_DECLSEC_FLAG_DENY,\t\t\t\t/* SECURITY_ACTION_DENY\t\t\t\t(x04) */\n\tMONO_DECLSEC_FLAG_PERMITONLY,\t\t\t/* SECURITY_ACTION_PERMITONLY\t\t\t(x05) */\n\tMONO_DECLSEC_FLAG_LINKDEMAND,\t\t\t/* SECURITY_ACTION_LINKDEMAND\t\t\t(x06) */\n\tMONO_DECLSEC_FLAG_INHERITANCEDEMAND,\t\t/* SECURITY_ACTION_INHERITANCEDEMAND\t\t(x07) */\n\tMONO_DECLSEC_FLAG_REQUEST_MINIMUM,\t\t/* SECURITY_ACTION_REQUEST_MINIMUM\t\t(x08) */\n\tMONO_DECLSEC_FLAG_REQUEST_OPTIONAL,\t\t/* SECURITY_ACTION_REQUEST_OPTIONAL\t\t(x09) */\n\tMONO_DECLSEC_FLAG_REQUEST_REFUSE,\t\t/* SECURITY_ACTION_REQUEST_REFUSE\t\t(x0A) */\n\tMONO_DECLSEC_FLAG_PREJIT_GRANT,\t\t\t/* SECURITY_ACTION_PREJIT_GRANT\t\t\t(x0B) */\n\tMONO_DECLSEC_FLAG_PREJIT_DENY,\t\t\t/* SECURITY_ACTION_PREJIT_DENY\t\t\t(x0C) */\n\tMONO_DECLSEC_FLAG_NONCAS_DEMAND,\t\t/* SECURITY_ACTION_NONCAS_DEMAND\t\t(x0D) */\n\tMONO_DECLSEC_FLAG_NONCAS_LINKDEMAND,\t\t/* SECURITY_ACTION_NONCAS_LINKDEMAND\t\t(x0E) */\n\tMONO_DECLSEC_FLAG_NONCAS_INHERITANCEDEMAND,\t/* SECURITY_ACTION_NONCAS_INHERITANCEDEMAND\t(x0F) */\n\tMONO_DECLSEC_FLAG_LINKDEMAND_CHOICE,\t\t/* SECURITY_ACTION_LINKDEMAND_CHOICE\t\t(x10) */\n\tMONO_DECLSEC_FLAG_INHERITANCEDEMAND_CHOICE,\t/* SECURITY_ACTION_INHERITANCEDEMAND_CHOICE\t(x11) */\n\tMONO_DECLSEC_FLAG_DEMAND_CHOICE,\t\t/* SECURITY_ACTION_DEMAND_CHOICE\t\t(x12) */\n};\n\n/*\n * Returns flags that includes all available security action associated to the handle.\n * @token: metadata token (either for a class or a method)\n * @image: image where resides the metadata.\n */\nstatic guint32\nmono_declsec_get_flags (MonoImage *image, guint32 token)\n{\n\tint index = mono_metadata_declsec_from_index (image, token);\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_DECLSECURITY];\n\tguint32 result = 0;\n\tguint32 action;\n\tint i;\n\n\t/* HasSecurity can be present for other, not specially encoded, attributes,\n\t   e.g. SuppressUnmanagedCodeSecurityAttribute */\n\tif (index < 0)\n\t\treturn 0;\n\n\tfor (i = index; i < t->rows; i++) {\n\t\tguint32 cols [MONO_DECL_SECURITY_SIZE];\n\n\t\tmono_metadata_decode_row (t, i, cols, MONO_DECL_SECURITY_SIZE);\n\t\tif (cols [MONO_DECL_SECURITY_PARENT] != token)\n\t\t\tbreak;\n\n\t\taction = cols [MONO_DECL_SECURITY_ACTION];\n\t\tif ((action >= MONO_DECLSEC_ACTION_MIN) && (action <= MONO_DECLSEC_ACTION_MAX)) {\n\t\t\tresult |= declsec_flags_map [action];\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\n * Get the security actions (in the form of flags) associated with the specified method.\n *\n * @method: The method for which we want the declarative security flags.\n * Return the declarative security flags for the method (only).\n *\n * Note: To keep MonoMethod size down we do not cache the declarative security flags\n *       (except for the stack modifiers which are kept in the MonoJitInfo structure)\n */\nguint32\nmono_declsec_flags_from_method (MonoMethod *method)\n{\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\t/* FIXME: No cache (for the moment) */\n\t\tguint32 idx = mono_method_get_index (method);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\t\treturn mono_declsec_get_flags (method->klass->image, idx);\n\t}\n\treturn 0;\n}\n\n/*\n * Get the security actions (in the form of flags) associated with the specified class.\n *\n * @klass: The class for which we want the declarative security flags.\n * Return the declarative security flags for the class.\n *\n * Note: We cache the flags inside the MonoClass structure as this will get \n *       called very often (at least for each method).\n */\nguint32\nmono_declsec_flags_from_class (MonoClass *klass)\n{\n\tif (klass->flags & TYPE_ATTRIBUTE_HAS_SECURITY) {\n\t\tif (!klass->ext || !klass->ext->declsec_flags) {\n\t\t\tguint32 idx;\n\n\t\t\tidx = mono_metadata_token_index (klass->type_token);\n\t\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\t\t\tmono_loader_lock ();\n\t\t\tmono_class_alloc_ext (klass);\n\t\t\tmono_loader_unlock ();\n\t\t\t/* we cache the flags on classes */\n\t\t\tklass->ext->declsec_flags = mono_declsec_get_flags (klass->image, idx);\n\t\t}\n\t\treturn klass->ext->declsec_flags;\n\t}\n\treturn 0;\n}\n\n/*\n * Get the security actions (in the form of flags) associated with the specified assembly.\n *\n * @assembly: The assembly for which we want the declarative security flags.\n * Return the declarative security flags for the assembly.\n */\nguint32\nmono_declsec_flags_from_assembly (MonoAssembly *assembly)\n{\n\tguint32 idx = 1; /* there is only one assembly */\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_ASSEMBLY;\n\treturn mono_declsec_get_flags (assembly->image, idx);\n}\n\n\n/*\n * Fill actions for the specific index (which may either be an encoded class token or\n * an encoded method token) from the metadata image.\n * Returns TRUE if some actions requiring code generation are present, FALSE otherwise.\n */\nstatic MonoBoolean\nfill_actions_from_index (MonoImage *image, guint32 token, MonoDeclSecurityActions* actions,\n\tguint32 id_std, guint32 id_noncas, guint32 id_choice)\n{\n\tMonoBoolean result = FALSE;\n\tMonoTableInfo *t;\n\tguint32 cols [MONO_DECL_SECURITY_SIZE];\n\tint index = mono_metadata_declsec_from_index (image, token);\n\tint i;\n\n\tt  = &image->tables [MONO_TABLE_DECLSECURITY];\n\tfor (i = index; i < t->rows; i++) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_DECL_SECURITY_SIZE);\n\n\t\tif (cols [MONO_DECL_SECURITY_PARENT] != token)\n\t\t\treturn result;\n\n\t\t/* if present only replace (class) permissions with method permissions */\n\t\t/* if empty accept either class or method permissions */\n\t\tif (cols [MONO_DECL_SECURITY_ACTION] == id_std) {\n\t\t\tif (!actions->demand.blob) {\n\t\t\t\tconst char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\t\tactions->demand.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];\n\t\t\t\tactions->demand.blob = (char*) (blob + 2);\n\t\t\t\tactions->demand.size = mono_metadata_decode_blob_size (blob, &blob);\n\t\t\t\tresult = TRUE;\n\t\t\t}\n\t\t} else if (cols [MONO_DECL_SECURITY_ACTION] == id_noncas) {\n\t\t\tif (!actions->noncasdemand.blob) {\n\t\t\t\tconst char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\t\tactions->noncasdemand.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];\n\t\t\t\tactions->noncasdemand.blob = (char*) (blob + 2);\n\t\t\t\tactions->noncasdemand.size = mono_metadata_decode_blob_size (blob, &blob);\n\t\t\t\tresult = TRUE;\n\t\t\t}\n\t\t} else if (cols [MONO_DECL_SECURITY_ACTION] == id_choice) {\n\t\t\tif (!actions->demandchoice.blob) {\n\t\t\t\tconst char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\t\tactions->demandchoice.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];\n\t\t\t\tactions->demandchoice.blob = (char*) (blob + 2);\n\t\t\t\tactions->demandchoice.size = mono_metadata_decode_blob_size (blob, &blob);\n\t\t\t\tresult = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic MonoBoolean\nmono_declsec_get_class_demands_params (MonoClass *klass, MonoDeclSecurityActions* demands, \n\tguint32 id_std, guint32 id_noncas, guint32 id_choice)\n{\n\tguint32 idx = mono_metadata_token_index (klass->type_token);\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\treturn fill_actions_from_index (klass->image, idx, demands, id_std, id_noncas, id_choice);\n}\n\nstatic MonoBoolean\nmono_declsec_get_method_demands_params (MonoMethod *method, MonoDeclSecurityActions* demands, \n\tguint32 id_std, guint32 id_noncas, guint32 id_choice)\n{\n\tguint32 idx = mono_method_get_index (method);\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\treturn fill_actions_from_index (method->klass->image, idx, demands, id_std, id_noncas, id_choice);\n}\n\n/*\n * Collect all actions (that requires to generate code in mini) assigned for\n * the specified method.\n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_demands (MonoMethod *method, MonoDeclSecurityActions* demands)\n{\n\tguint32 mask = MONO_DECLSEC_FLAG_DEMAND | MONO_DECLSEC_FLAG_NONCAS_DEMAND | \n\t\tMONO_DECLSEC_FLAG_DEMAND_CHOICE;\n\tMonoBoolean result = FALSE;\n\tguint32 flags;\n\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* we want the original as the wrapper is \"free\" of the security informations */\n\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE || method->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\tmethod = mono_marshal_method_from_wrapper (method);\n\t\tif (!method)\n\t\t\treturn FALSE;\n\t}\n\n\t/* First we look for method-level attributes */\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tmono_class_init (method->klass);\n\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\n\t\tresult = mono_declsec_get_method_demands_params (method, demands, \n\t\t\tSECURITY_ACTION_DEMAND, SECURITY_ACTION_NONCASDEMAND, SECURITY_ACTION_DEMANDCHOICE);\n\t}\n\n\t/* Here we use (or create) the class declarative cache to look for demands */\n\tflags = mono_declsec_flags_from_class (method->klass);\n\tif (flags & mask) {\n\t\tif (!result) {\n\t\t\tmono_class_init (method->klass);\n\t\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\t\t}\n\t\tresult |= mono_declsec_get_class_demands_params (method->klass, demands, \n\t\t\tSECURITY_ACTION_DEMAND, SECURITY_ACTION_NONCASDEMAND, SECURITY_ACTION_DEMANDCHOICE);\n\t}\n\n\t/* The boolean return value is used as a shortcut in case nothing needs to\n\t   be generated (e.g. LinkDemand[Choice] and InheritanceDemand[Choice]) */\n\treturn result;\n}\n\n\n/*\n * Collect all Link actions: LinkDemand, NonCasLinkDemand and LinkDemandChoice (2.0).\n *\n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_linkdemands (MonoMethod *method, MonoDeclSecurityActions* klass, MonoDeclSecurityActions *cmethod)\n{\n\tMonoBoolean result = FALSE;\n\tguint32 flags;\n\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* we want the original as the wrapper is \"free\" of the security informations */\n\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE || method->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\tmethod = mono_marshal_method_from_wrapper (method);\n\t\tif (!method)\n\t\t\treturn FALSE;\n\t}\n\n\t/* results are independant - zeroize both */\n\tmemset (cmethod, 0, sizeof (MonoDeclSecurityActions));\n\tmemset (klass, 0, sizeof (MonoDeclSecurityActions));\n\n\t/* First we look for method-level attributes */\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tmono_class_init (method->klass);\n\n\t\tresult = mono_declsec_get_method_demands_params (method, cmethod, \n\t\t\tSECURITY_ACTION_LINKDEMAND, SECURITY_ACTION_NONCASLINKDEMAND, SECURITY_ACTION_LINKDEMANDCHOICE);\n\t}\n\n\t/* Here we use (or create) the class declarative cache to look for demands */\n\tflags = mono_declsec_flags_from_class (method->klass);\n\tif (flags & (MONO_DECLSEC_FLAG_LINKDEMAND | MONO_DECLSEC_FLAG_NONCAS_LINKDEMAND | MONO_DECLSEC_FLAG_LINKDEMAND_CHOICE)) {\n\t\tmono_class_init (method->klass);\n\n\t\tresult |= mono_declsec_get_class_demands_params (method->klass, klass, \n\t\t\tSECURITY_ACTION_LINKDEMAND, SECURITY_ACTION_NONCASLINKDEMAND, SECURITY_ACTION_LINKDEMANDCHOICE);\n\t}\n\n\treturn result;\n}\n\n/*\n * Collect all Inherit actions: InheritanceDemand, NonCasInheritanceDemand and InheritanceDemandChoice (2.0).\n *\n * @klass\tThe inherited class - this is the class that provides the security check (attributes)\n * @demans\t\n * return TRUE if inheritance demands (any kind) are present, FALSE otherwise.\n * \n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_inheritdemands_class (MonoClass *klass, MonoDeclSecurityActions* demands)\n{\n\tMonoBoolean result = FALSE;\n\tguint32 flags;\n\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* Here we use (or create) the class declarative cache to look for demands */\n\tflags = mono_declsec_flags_from_class (klass);\n\tif (flags & (MONO_DECLSEC_FLAG_INHERITANCEDEMAND | MONO_DECLSEC_FLAG_NONCAS_INHERITANCEDEMAND | MONO_DECLSEC_FLAG_INHERITANCEDEMAND_CHOICE)) {\n\t\tmono_class_init (klass);\n\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\n\t\tresult |= mono_declsec_get_class_demands_params (klass, demands, \n\t\t\tSECURITY_ACTION_INHERITDEMAND, SECURITY_ACTION_NONCASINHERITANCE, SECURITY_ACTION_INHERITDEMANDCHOICE);\n\t}\n\n\treturn result;\n}\n\n/*\n * Collect all Inherit actions: InheritanceDemand, NonCasInheritanceDemand and InheritanceDemandChoice (2.0).\n *\n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_inheritdemands_method (MonoMethod *method, MonoDeclSecurityActions* demands)\n{\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* we want the original as the wrapper is \"free\" of the security informations */\n\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE || method->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\tmethod = mono_marshal_method_from_wrapper (method);\n\t\tif (!method)\n\t\t\treturn FALSE;\n\t}\n\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tmono_class_init (method->klass);\n\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\n\t\treturn mono_declsec_get_method_demands_params (method, demands, \n\t\t\tSECURITY_ACTION_INHERITDEMAND, SECURITY_ACTION_NONCASINHERITANCE, SECURITY_ACTION_INHERITDEMANDCHOICE);\n\t}\n\treturn FALSE;\n}\n\n\nstatic MonoBoolean\nget_declsec_action (MonoImage *image, guint32 token, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\tguint32 cols [MONO_DECL_SECURITY_SIZE];\n\tMonoTableInfo *t;\n\tint i;\n\n\tint index = mono_metadata_declsec_from_index (image, token);\n\tif (index == -1)\n\t\treturn FALSE;\n\n\tt =  &image->tables [MONO_TABLE_DECLSECURITY];\n\tfor (i = index; i < t->rows; i++) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_DECL_SECURITY_SIZE);\n\n\t\t/* shortcut - index are ordered */\n\t\tif (token != cols [MONO_DECL_SECURITY_PARENT])\n\t\t\treturn FALSE;\n\n\t\tif (cols [MONO_DECL_SECURITY_ACTION] == action) {\n\t\t\tconst char *metadata = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\tentry->blob = (char*) (metadata + 2);\n\t\t\tentry->size = mono_metadata_decode_blob_size (metadata, &metadata);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\nMonoBoolean\nmono_declsec_get_method_action (MonoMethod *method, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tguint32 idx = mono_method_get_index (method);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\t\treturn get_declsec_action (method->klass->image, idx, action, entry);\n\t}\n\treturn FALSE;\n}\n\nMonoBoolean\nmono_declsec_get_class_action (MonoClass *klass, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\t/* use cache */\n\tguint32 flags = mono_declsec_flags_from_class (klass);\n\tif (declsec_flags_map [action] & flags) {\n\t\tguint32 idx = mono_metadata_token_index (klass->type_token);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\t\treturn get_declsec_action (klass->image, idx, action, entry);\n\t}\n\treturn FALSE;\n}\n\nMonoBoolean\nmono_declsec_get_assembly_action (MonoAssembly *assembly, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\tguint32 idx = 1; /* there is only one assembly */\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_ASSEMBLY;\n\n\treturn get_declsec_action (assembly->image, idx, action, entry);\n}\n\ngboolean\nmono_reflection_call_is_assignable_to (MonoClass *klass, MonoClass *oklass)\n{\n\tMonoObject *res, *exc;\n\tvoid *params [1];\n\tstatic MonoClass *System_Reflection_Emit_TypeBuilder = NULL;\n\tstatic MonoMethod *method = NULL;\n\n\tif (!System_Reflection_Emit_TypeBuilder) {\n\t\tSystem_Reflection_Emit_TypeBuilder = mono_class_from_name (mono_defaults.corlib, \"System.Reflection.Emit\", \"TypeBuilder\");\n\t\tg_assert (System_Reflection_Emit_TypeBuilder);\n\t}\n\tif (method == NULL) {\n\t\tmethod = mono_class_get_method_from_name (System_Reflection_Emit_TypeBuilder, \"IsAssignableTo\", 1);\n\t\tg_assert (method);\n\t}\n\n\t/* \n\t * The result of mono_type_get_object () might be a System.MonoType but we\n\t * need a TypeBuilder so use klass->reflection_info.\n\t */\n\tg_assert (klass->reflection_info);\n\tg_assert (!strcmp (((MonoObject*)(klass->reflection_info))->vtable->klass->name, \"TypeBuilder\"));\n\n\tparams [0] = mono_type_get_object (mono_domain_get (), &oklass->byval_arg);\n\n\tres = mono_runtime_invoke (method, (MonoObject*)(klass->reflection_info), params, &exc);\n\tif (exc)\n\t\treturn FALSE;\n\telse\n\t\treturn *(MonoBoolean*)mono_object_unbox (res);\n}\n"], "fixing_code": ["//\n// System.Reflection.Emit.DynamicMethod.cs\n//\n// Author:\n//   Paolo Molaro (lupus@ximian.com)\n//   Zoltan Varga (vargaz@freemail.hu)\n//\n// (C) 2003 Ximian, Inc.  http://www.ximian.com\n//\n\n//\n// Copyright (C) 2004 Novell, Inc (http://www.novell.com)\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n// \n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n#if NET_2_0 || BOOTSTRAP_NET_2_0\n\nusing System;\nusing System.Reflection;\nusing System.Reflection.Emit;\nusing System.Globalization;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\nnamespace System.Reflection.Emit {\n\n#if NET_2_0\n\t[ComVisible (true)]\n#endif\n\tpublic sealed class DynamicMethod : MethodInfo {\n\n#pragma warning disable 169, 414\n\t\t#region Sync with reflection.h\n\t\tprivate RuntimeMethodHandle mhandle;\n\t\tprivate string name;\n\t\tprivate Type returnType;\n\t\tprivate Type[] parameters;\n\t\tprivate MethodAttributes attributes;\n\t\tprivate CallingConventions callingConvention;\n\t\tprivate Module module;\n\t\tprivate bool skipVisibility;\n\t\tprivate bool init_locals = true;\n\t\tprivate ILGenerator ilgen;\n\t\tprivate int nrefs;\n\t\tprivate object[] refs;\n\t\tprivate IntPtr referenced_by;\n\t\tprivate Type owner;\n\t\t#endregion\n#pragma warning restore 169, 414\n\t\t\n\t\tprivate Delegate deleg;\n\t\tprivate MonoMethod method;\n\t\tprivate ParameterBuilder[] pinfo;\n\t\tinternal bool creating;\n\n\t\tpublic DynamicMethod (string name, Type returnType, Type[] parameterTypes, Module m) : this (name, returnType, parameterTypes, m, false) {\n\t\t}\n\n\t\tpublic DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner) : this (name, returnType, parameterTypes, owner, false) {\n\t\t}\n\n\t\tpublic DynamicMethod (string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility) : this (name, MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, returnType, parameterTypes, m, skipVisibility) {\n\t\t}\n\n\t\tpublic DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility) : this (name, MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, returnType, parameterTypes, owner, skipVisibility) {\n\t\t}\n\n\t\tpublic DynamicMethod (string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility) : this (name, attributes, callingConvention, returnType, parameterTypes, owner, owner.Module, skipVisibility, false) {\n\t\t}\n\n\t\tpublic DynamicMethod (string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility) : this (name, attributes, callingConvention, returnType, parameterTypes, null, m, skipVisibility, false) {\n\t\t}\n\n\t\tpublic DynamicMethod (string name, Type returnType, Type[] parameterTypes) : this (name, returnType, parameterTypes, false) {\n\t\t}\n\n\t\t[MonoTODO (\"Visibility is not restricted\")]\n\t\tpublic DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility)\n\t\t\t: this (name, MethodAttributes.Public | MethodAttributes.Static, CallingConventions.Standard, returnType, parameterTypes, null, null, restrictedSkipVisibility, true)\n\t\t{\n\t\t}\n\n\t\tDynamicMethod (string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type [] parameterTypes, Type owner, Module m, bool skipVisibility, bool anonHosted)\n\t\t{\n\t\t\tif (name == null)\n\t\t\t\tthrow new ArgumentNullException (\"name\");\n\t\t\tif (returnType == null)\n\t\t\t\treturnType = typeof (void);\n\t\t\tif ((m == null) && !anonHosted)\n\t\t\t\tthrow new ArgumentNullException (\"m\");\n\t\t\tif (returnType.IsByRef)\n\t\t\t\tthrow new ArgumentException (\"Return type can't be a byref type\", \"returnType\");\n\t\t\tif (parameterTypes != null) {\n\t\t\t\tfor (int i = 0; i < parameterTypes.Length; ++i)\n\t\t\t\t\tif (parameterTypes [i] == null)\n\t\t\t\t\t\tthrow new ArgumentException (\"Parameter \" + i + \" is null\", \"parameterTypes\");\n\t\t\t}\n\n\t\t\tif (m == null)\n\t\t\t\tm = AnonHostModuleHolder.anon_host_module;\n\n\t\t\tthis.name = name;\n\t\t\tthis.attributes = attributes | MethodAttributes.Static;\n\t\t\tthis.callingConvention = callingConvention;\n\t\t\tthis.returnType = returnType;\n\t\t\tthis.parameters = parameterTypes;\n\t\t\tthis.owner = owner;\n\t\t\tthis.module = m;\n\t\t\tthis.skipVisibility = skipVisibility;\n\t\t}\n\n\t\t[MethodImplAttribute(MethodImplOptions.InternalCall)]\n\t\tprivate extern void create_dynamic_method (DynamicMethod m);\n\n\t\tprivate void CreateDynMethod () {\n\t\t\tif (mhandle.Value == IntPtr.Zero) {\n\t\t\t\tif (ilgen == null || (ILGenerator.Mono_GetCurrentOffset (ilgen) == 0))\n\t\t\t\t\tthrow new InvalidOperationException (\"Method '\" + name + \"' does not have a method body.\");\n\n\t\t\t\tilgen.label_fixup ();\n\n\t\t\t\t// Have to create all DynamicMethods referenced by this one\n\t\t\t\ttry {\n\t\t\t\t\t// Used to avoid cycles\n\t\t\t\t\tcreating = true;\n\t\t\t\t\tif (refs != null) {\n\t\t\t\t\t\tfor (int i = 0; i < refs.Length; ++i) {\n\t\t\t\t\t\t\tif (refs [i] is DynamicMethod) {\n\t\t\t\t\t\t\t\tDynamicMethod m = (DynamicMethod)refs [i];\n\t\t\t\t\t\t\t\tif (!m.creating)\n\t\t\t\t\t\t\t\t\tm.CreateDynMethod ();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tcreating = false;\n\t\t\t\t}\n\n\t\t\t\tcreate_dynamic_method (this);\n\t\t\t}\n\t\t}\n\n\t\t[ComVisible (true)]\n\t\tpublic Delegate CreateDelegate (Type delegateType)\n\t\t{\n\t\t\tif (delegateType == null)\n\t\t\t\tthrow new ArgumentNullException (\"delegateType\");\n\t\t\tif (deleg != null)\n\t\t\t\treturn deleg;\n\n\t\t\tCreateDynMethod ();\n\n\t\t\tdeleg = Delegate.CreateDelegate (delegateType, this);\n\t\t\treturn deleg;\n\t\t}\n\n\t\t[ComVisible (true)]\n\t\tpublic Delegate CreateDelegate (Type delegateType, object target)\n\t\t{\n\t\t\tif (delegateType == null)\n\t\t\t\tthrow new ArgumentNullException (\"delegateType\");\n\n\t\t\tCreateDynMethod ();\n\n\t\t\t/* Can't cache the delegate since it is different for each target */\n\t\t\treturn Delegate.CreateDelegate (delegateType, target, this);\n\t\t}\n\t\t\n\t\tpublic ParameterBuilder DefineParameter (int position, ParameterAttributes attributes, string parameterName)\n\t\t{\n\t\t\t//\n\t\t\t// Extension: Mono allows position == 0 for the return attribute\n\t\t\t//\n\t\t\tif ((position < 0) || (position > parameters.Length))\n\t\t\t\tthrow new ArgumentOutOfRangeException (\"position\");\n\n\t\t\tRejectIfCreated ();\n\n\t\t\tParameterBuilder pb = new ParameterBuilder (this, position, attributes, parameterName);\n\t\t\tif (pinfo == null)\n\t\t\t\tpinfo = new ParameterBuilder [parameters.Length + 1];\n\t\t\tpinfo [position] = pb;\n\t\t\treturn pb;\n\t\t}\n\n\t\tpublic override MethodInfo GetBaseDefinition () {\n\t\t\treturn this;\n\t\t}\n\n\t\t[MonoTODO(\"Not implemented\")]\n\t\tpublic override object[] GetCustomAttributes (bool inherit) {\n\t\t\tthrow new NotImplementedException ();\n\t\t}\n\n\t\t[MonoTODO(\"Not implemented\")]\n\t\tpublic override object[] GetCustomAttributes (Type attributeType,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  bool inherit) {\n\t\t\tthrow new NotImplementedException ();\n\t\t}\n\n\t\t[MonoTODO(\"Not implemented\")]\n\t\tpublic DynamicILInfo GetDynamicILInfo () {\n\t\t\tthrow new NotImplementedException ();\n\t\t}\n\n\t\tpublic ILGenerator GetILGenerator () {\n\t\t\treturn GetILGenerator (64);\n\t\t}\n\n\t\tpublic ILGenerator GetILGenerator (int streamSize) {\n\t\t\tif (((GetMethodImplementationFlags () & MethodImplAttributes.CodeTypeMask) != \n\t\t\t\t MethodImplAttributes.IL) ||\n\t\t\t\t((GetMethodImplementationFlags () & MethodImplAttributes.ManagedMask) != \n\t\t\t\t MethodImplAttributes.Managed))\n\t\t\t\tthrow new InvalidOperationException (\"Method body should not exist.\");\n\t\t\tif (ilgen != null)\n\t\t\t\treturn ilgen;\n\t\t\tilgen = new ILGenerator (Module, new DynamicMethodTokenGenerator (this), streamSize);\n\t\t\treturn ilgen;\n\t\t}\t\t\n\n\t\tpublic override MethodImplAttributes GetMethodImplementationFlags () {\n\t\t\treturn MethodImplAttributes.IL | MethodImplAttributes.Managed;\n\t\t}\n\n\t\tpublic override ParameterInfo[] GetParameters () {\n\t\t\tif (parameters == null)\n\t\t\t\treturn new ParameterInfo [0];\n\n\t\t\tParameterInfo[] retval = new ParameterInfo [parameters.Length];\n\t\t\tfor (int i = 0; i < parameters.Length; i++) {\n\t\t\t\tretval [i] = new ParameterInfo (pinfo == null ? null : pinfo [i + 1], parameters [i], this, i + 1);\n\t\t\t}\n\t\t\treturn retval;\n\t\t}\n\n\t\t/*\n\t\tpublic override object Invoke (object obj, object[] parameters) {\n\t\t\tCreateDynMethod ();\n\t\t\tif (method == null)\n\t\t\t\tmethod = new MonoMethod (mhandle);\n\t\t\treturn method.Invoke (obj, parameters);\n\t\t}\n\t\t*/\n\n\t\tpublic override object Invoke (object obj, BindingFlags invokeAttr,\n\t\t\t\t\t\t\t\t\t   Binder binder, object[] parameters,\n\t\t\t\t\t\t\t\t\t   CultureInfo culture)\n\t\t{\n\t\t\ttry {\n\t\t\t\tCreateDynMethod ();\n\t\t\t\tif (method == null)\n\t\t\t\t\tmethod = new MonoMethod (mhandle);\n\n\t\t\t\treturn method.Invoke (obj, parameters);\n\t\t\t}\n\t\t\tcatch (MethodAccessException mae) {\n\t\t\t\tthrow new TargetInvocationException (\"Method cannot be invoked.\", mae);\n\t\t\t}\n\t\t}\n\n\t\t[MonoTODO(\"Not implemented\")]\n\t\tpublic override bool IsDefined (Type attributeType, bool inherit) {\n\t\t\tthrow new NotImplementedException ();\n\t\t}\n\n\t\tpublic override string ToString () {\n\t\t\tstring parms = String.Empty;\n\t\t\tParameterInfo[] p = GetParameters ();\n\t\t\tfor (int i = 0; i < p.Length; ++i) {\n\t\t\t\tif (i > 0)\n\t\t\t\t\tparms = parms + \", \";\n\t\t\t\tparms = parms + p [i].ParameterType.Name;\n\t\t\t}\n\t\t\treturn ReturnType.Name+\" \"+Name+\"(\"+parms+\")\";\n\t\t}\n\n\t\tpublic override MethodAttributes Attributes {\n\t\t\tget {\n\t\t\t\treturn attributes;\n\t\t\t}\n\t\t}\n\n\t\tpublic override CallingConventions CallingConvention {\n\t\t\tget {\n\t\t\t\treturn callingConvention;\n\t\t\t}\n\t\t}\n\n\t\tpublic override Type DeclaringType {\n\t\t\tget {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tpublic bool InitLocals {\n\t\t\tget {\n\t\t\t\treturn init_locals;\n\t\t\t}\n\t\t\tset {\n\t\t\t\tinit_locals = value;\n\t\t\t}\n\t\t}\n\n\t\tpublic override RuntimeMethodHandle MethodHandle {\n\t\t\tget {\n\t\t\t\treturn mhandle;\n\t\t\t}\n\t\t}\n\n\t\tpublic override Module Module {\n\t\t\tget {\n\t\t\t\treturn module;\n\t\t\t}\n\t\t}\n\n\t\tpublic override string Name {\n\t\t\tget {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\n\t\tpublic override Type ReflectedType {\n\t\t\tget {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t[MonoTODO(\"Not implemented\")]\n\t\tpublic override ParameterInfo ReturnParameter {\n\t\t\tget {\n\t\t\t\tthrow new NotImplementedException ();\n\t\t\t}\n\t\t}\n\n\t\tpublic override Type ReturnType {\n\t\t\tget {\n\t\t\t\treturn returnType;\n\t\t\t}\n\t\t}\n\n\t\t[MonoTODO(\"Not implemented\")]\n\t\tpublic override ICustomAttributeProvider ReturnTypeCustomAttributes {\n\t\t\tget {\n\t\t\t\tthrow new NotImplementedException ();\n\t\t\t}\n\t\t}\n\n/*\n\t\tpublic override int MetadataToken {\n\t\t\tget {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n*/\n\n\t\tprivate void RejectIfCreated () {\n\t\t\tif (mhandle.Value != IntPtr.Zero)\n\t\t\t\tthrow new InvalidOperationException (\"Type definition of the method is complete.\");\n\t\t}\n\n\t\tinternal int AddRef (object reference) {\n\t\t\tif (refs == null)\n\t\t\t\trefs = new object [4];\n\t\t\tif (nrefs >= refs.Length - 1) {\n\t\t\t\tobject [] new_refs = new object [refs.Length * 2];\n\t\t\t\tSystem.Array.Copy (refs, new_refs, refs.Length);\n\t\t\t\trefs = new_refs;\n\t\t\t}\n\t\t\trefs [nrefs] = reference;\n\t\t\t/* Reserved by the runtime */\n\t\t\trefs [nrefs + 1] = null;\n\t\t\tnrefs += 2;\n\t\t\treturn nrefs - 1;\n\t\t}\n\n\t\t// This class takes care of constructing the module in a thread safe manner\n\t\tclass AnonHostModuleHolder {\n\t\t\tpublic static Module anon_host_module;\n\n\t\t\tstatic AnonHostModuleHolder () {\n\t\t\t\tAssemblyName aname = new AssemblyName ();\n\t\t\t\taname.Name = \"Anonymously Hosted DynamicMethods Assembly\";\n\t\t\t\tAssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly (aname, AssemblyBuilderAccess.Run);\n\n\t\t\t\tanon_host_module = ab.GetManifestModule ();\n\t\t\t}\n\t\t}\n\t}\n\n\tinternal class DynamicMethodTokenGenerator : TokenGenerator {\n\n\t\tprivate DynamicMethod m;\n\n\t\tpublic DynamicMethodTokenGenerator (DynamicMethod m) {\n\t\t\tthis.m = m;\n\t\t}\n\n\t\tpublic int GetToken (string str) {\n\t\t\treturn m.AddRef (str);\n\t\t}\n\n\t\tpublic int GetToken (MethodInfo method, Type[] opt_param_types) {\n\t\t\tthrow new InvalidOperationException ();\n\t\t}\n\n\t\tpublic int GetToken (MemberInfo member) {\n\t\t\treturn m.AddRef (member);\n\t\t}\n\n\t\tpublic int GetToken (SignatureHelper helper) {\n\t\t\treturn m.AddRef (helper);\n\t\t}\n\t}\n}\n\n#endif\n", "/*\n * This file contains the default set of the mono internal calls.\n * Each type that has internal call methods must be declared here\n * with the ICALL_TYPE macro as follows:\n *\n * \tICALL_TYPE(typeid, typename, first_icall_id)\n *\n * typeid must be a C symbol name unique to the type, don't worry about namespace\n * \tpollution, since it will be automatically prefixed to avoid it.\n * typename is a C string containing the full name of the type\n * first_icall_id s the symbol ID of the first internal call of the declared\n * \ttype (see below)\n *\n * The list of internal calls of the methods of a type must follow the\n * type declaration. Each internal call is defined by the following macro:\n *\n * \tICALL(icallid, methodname, cfuncptr)\n *\n * icallid must be a C symbol, unique for each icall defined in this file and\n * tipically equal to the typeid + '_' + a sequential number.\n * methodname is a C string defining the method name and the optional signature\n * (the signature is required only when several internal calls in the type\n * have the same name)\n * cfuncptr is the C function that implements the internal call. Note that this\n * file is included at the end of metadata/icall.c, so the C function must be\n * visible to the compiler there.\n *\n * *** Adding a new internal call ***\n * Remember that ICALL_TYPE declarations must be kept sorted wrt each other\n * ICALL_TYPE declaration. The same happens for ICALL declarations, but only\n * limited to the icall list of each type. The sorting is based on the type or\n * method name.\n * When adding a new icall, make sure it is inserted correctly in the list and\n * that it defines a unique ID. ID are currently numbered and ordered, but if\n * you need to insert a method in the middle, don't bother renaming all the symbols.\n * Remember to change also the first_icall_id argument in the ICALL_TYPE \n * declaration if you add a new icall at the beginning of a type's icall list.\n */\nICALL_TYPE(UNORM, \"Mono.Globalization.Unicode.Normalization\", UNORM_1)\nICALL(UNORM_1, \"load_normalization_resource\", load_normalization_resource)\n\n#ifndef DISABLE_COM\nICALL_TYPE(COMPROX, \"Mono.Interop.ComInteropProxy\", COMPROX_1)\nICALL(COMPROX_1, \"AddProxy\", ves_icall_Mono_Interop_ComInteropProxy_AddProxy)\nICALL(COMPROX_2, \"FindProxy\", ves_icall_Mono_Interop_ComInteropProxy_FindProxy)\n#endif\n\nICALL_TYPE(RUNTIME, \"Mono.Runtime\", RUNTIME_1)\nICALL(RUNTIME_1, \"GetDisplayName\", ves_icall_Mono_Runtime_GetDisplayName)\n\n#ifndef PLATFORM_RO_FS\nICALL_TYPE(KPAIR, \"Mono.Security.Cryptography.KeyPairPersistence\", KPAIR_1)\nICALL(KPAIR_1, \"_CanSecure\", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_CanSecure)\nICALL(KPAIR_2, \"_IsMachineProtected\", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_IsMachineProtected)\nICALL(KPAIR_3, \"_IsUserProtected\", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_IsUserProtected)\nICALL(KPAIR_4, \"_ProtectMachine\", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_ProtectMachine)\nICALL(KPAIR_5, \"_ProtectUser\", ves_icall_Mono_Security_Cryptography_KeyPairPersistence_ProtectUser)\n#endif /* !PLATFORM_RO_FS */\n\nICALL_TYPE(ACTIV, \"System.Activator\", ACTIV_1)\nICALL(ACTIV_1, \"CreateInstanceInternal\", ves_icall_System_Activator_CreateInstanceInternal)\n\nICALL_TYPE(APPDOM, \"System.AppDomain\", APPDOM_1)\nICALL(APPDOM_1, \"ExecuteAssembly\", ves_icall_System_AppDomain_ExecuteAssembly)\nICALL(APPDOM_2, \"GetAssemblies\", ves_icall_System_AppDomain_GetAssemblies)\nICALL(APPDOM_3, \"GetData\", ves_icall_System_AppDomain_GetData)\nICALL(APPDOM_4, \"InternalGetContext\", ves_icall_System_AppDomain_InternalGetContext)\nICALL(APPDOM_5, \"InternalGetDefaultContext\", ves_icall_System_AppDomain_InternalGetDefaultContext)\nICALL(APPDOM_6, \"InternalGetProcessGuid\", ves_icall_System_AppDomain_InternalGetProcessGuid)\nICALL(APPDOM_7, \"InternalIsFinalizingForUnload\", ves_icall_System_AppDomain_InternalIsFinalizingForUnload)\nICALL(APPDOM_8, \"InternalPopDomainRef\", ves_icall_System_AppDomain_InternalPopDomainRef)\nICALL(APPDOM_9, \"InternalPushDomainRef\", ves_icall_System_AppDomain_InternalPushDomainRef)\nICALL(APPDOM_10, \"InternalPushDomainRefByID\", ves_icall_System_AppDomain_InternalPushDomainRefByID)\nICALL(APPDOM_11, \"InternalSetContext\", ves_icall_System_AppDomain_InternalSetContext)\nICALL(APPDOM_12, \"InternalSetDomain\", ves_icall_System_AppDomain_InternalSetDomain)\nICALL(APPDOM_13, \"InternalSetDomainByID\", ves_icall_System_AppDomain_InternalSetDomainByID)\nICALL(APPDOM_14, \"InternalUnload\", ves_icall_System_AppDomain_InternalUnload)\nICALL(APPDOM_15, \"LoadAssembly\", ves_icall_System_AppDomain_LoadAssembly)\nICALL(APPDOM_16, \"LoadAssemblyRaw\", ves_icall_System_AppDomain_LoadAssemblyRaw)\nICALL(APPDOM_17, \"SetData\", ves_icall_System_AppDomain_SetData)\nICALL(APPDOM_18, \"createDomain\", ves_icall_System_AppDomain_createDomain)\nICALL(APPDOM_19, \"getCurDomain\", ves_icall_System_AppDomain_getCurDomain)\nICALL(APPDOM_20, \"getFriendlyName\", ves_icall_System_AppDomain_getFriendlyName)\nICALL(APPDOM_21, \"getRootDomain\", ves_icall_System_AppDomain_getRootDomain)\nICALL(APPDOM_22, \"getSetup\", ves_icall_System_AppDomain_getSetup)\n\nICALL_TYPE(ARGI, \"System.ArgIterator\", ARGI_1)\nICALL(ARGI_1, \"IntGetNextArg()\",                  mono_ArgIterator_IntGetNextArg)\nICALL(ARGI_2, \"IntGetNextArg(intptr)\", mono_ArgIterator_IntGetNextArgT)\nICALL(ARGI_3, \"IntGetNextArgType\",                mono_ArgIterator_IntGetNextArgType)\nICALL(ARGI_4, \"Setup\",                            mono_ArgIterator_Setup)\n\nICALL_TYPE(ARRAY, \"System.Array\", ARRAY_1)\nICALL(ARRAY_1, \"ClearInternal\",    ves_icall_System_Array_ClearInternal)\nICALL(ARRAY_2, \"Clone\",            mono_array_clone)\nICALL(ARRAY_3, \"CreateInstanceImpl\",   ves_icall_System_Array_CreateInstanceImpl)\nICALL(ARRAY_14, \"CreateInstanceImpl64\",   ves_icall_System_Array_CreateInstanceImpl64)\nICALL(ARRAY_4, \"FastCopy\",         ves_icall_System_Array_FastCopy)\nICALL(ARRAY_5, \"GetGenericValueImpl\", ves_icall_System_Array_GetGenericValueImpl)\nICALL(ARRAY_6, \"GetLength\",        ves_icall_System_Array_GetLength)\nICALL(ARRAY_15, \"GetLongLength\",        ves_icall_System_Array_GetLongLength)\nICALL(ARRAY_7, \"GetLowerBound\",    ves_icall_System_Array_GetLowerBound)\nICALL(ARRAY_8, \"GetRank\",          ves_icall_System_Array_GetRank)\nICALL(ARRAY_9, \"GetValue\",         ves_icall_System_Array_GetValue)\nICALL(ARRAY_10, \"GetValueImpl\",     ves_icall_System_Array_GetValueImpl)\nICALL(ARRAY_11, \"SetGenericValueImpl\", ves_icall_System_Array_SetGenericValueImpl)\nICALL(ARRAY_12, \"SetValue\",         ves_icall_System_Array_SetValue)\nICALL(ARRAY_13, \"SetValueImpl\",     ves_icall_System_Array_SetValueImpl)\n\nICALL_TYPE(BUFFER, \"System.Buffer\", BUFFER_1)\nICALL(BUFFER_1, \"BlockCopyInternal\", ves_icall_System_Buffer_BlockCopyInternal)\nICALL(BUFFER_2, \"ByteLengthInternal\", ves_icall_System_Buffer_ByteLengthInternal)\nICALL(BUFFER_3, \"GetByteInternal\", ves_icall_System_Buffer_GetByteInternal)\nICALL(BUFFER_4, \"SetByteInternal\", ves_icall_System_Buffer_SetByteInternal)\n\nICALL_TYPE(CHAR, \"System.Char\", CHAR_1)\nICALL(CHAR_1, \"GetDataTablePointers\", ves_icall_System_Char_GetDataTablePointers)\n\nICALL_TYPE (COMPO_W, \"System.ComponentModel.Win32Exception\", COMPO_W_1)\nICALL (COMPO_W_1, \"W32ErrorMessage\", ves_icall_System_ComponentModel_Win32Exception_W32ErrorMessage)\n\nICALL_TYPE(DEFAULTC, \"System.Configuration.DefaultConfig\", DEFAULTC_1)\nICALL(DEFAULTC_1, \"get_bundled_machine_config\", get_bundled_machine_config)\nICALL(DEFAULTC_2, \"get_machine_config_path\", ves_icall_System_Configuration_DefaultConfig_get_machine_config_path)\n\n/* Note that the below icall shares the same function as DefaultConfig uses */\nICALL_TYPE(INTCFGHOST, \"System.Configuration.InternalConfigurationHost\", INTCFGHOST_1)\nICALL(INTCFGHOST_1, \"get_bundled_machine_config\", get_bundled_machine_config)\n\nICALL_TYPE(CONSOLE, \"System.ConsoleDriver\", CONSOLE_1)\nICALL(CONSOLE_1, \"InternalKeyAvailable\", ves_icall_System_ConsoleDriver_InternalKeyAvailable )\nICALL(CONSOLE_2, \"Isatty\", ves_icall_System_ConsoleDriver_Isatty )\nICALL(CONSOLE_3, \"SetBreak\", ves_icall_System_ConsoleDriver_SetBreak )\nICALL(CONSOLE_4, \"SetEcho\", ves_icall_System_ConsoleDriver_SetEcho )\nICALL(CONSOLE_5, \"TtySetup\", ves_icall_System_ConsoleDriver_TtySetup )\n\nICALL_TYPE(CONVERT, \"System.Convert\", CONVERT_1)\nICALL(CONVERT_1, \"InternalFromBase64CharArray\", InternalFromBase64CharArray )\nICALL(CONVERT_2, \"InternalFromBase64String\", InternalFromBase64String )\n\nICALL_TYPE(TZONE, \"System.CurrentSystemTimeZone\", TZONE_1)\nICALL(TZONE_1, \"GetTimeZoneData\", ves_icall_System_CurrentSystemTimeZone_GetTimeZoneData)\n\nICALL_TYPE(DTIME, \"System.DateTime\", DTIME_1)\nICALL(DTIME_1, \"GetNow\", mono_100ns_datetime)\nICALL(DTIME_2, \"GetTimeMonotonic\", mono_100ns_ticks)\n\n#ifndef DISABLE_DECIMAL\nICALL_TYPE(DECIMAL, \"System.Decimal\", DECIMAL_1)\nICALL(DECIMAL_1, \"decimal2Int64\", mono_decimal2Int64)\nICALL(DECIMAL_2, \"decimal2UInt64\", mono_decimal2UInt64)\nICALL(DECIMAL_3, \"decimal2double\", mono_decimal2double)\nICALL(DECIMAL_4, \"decimal2string\", mono_decimal2string)\nICALL(DECIMAL_5, \"decimalCompare\", mono_decimalCompare)\nICALL(DECIMAL_6, \"decimalDiv\", mono_decimalDiv)\nICALL(DECIMAL_7, \"decimalFloorAndTrunc\", mono_decimalFloorAndTrunc)\nICALL(DECIMAL_8, \"decimalIncr\", mono_decimalIncr)\nICALL(DECIMAL_9, \"decimalIntDiv\", mono_decimalIntDiv)\nICALL(DECIMAL_10, \"decimalMult\", mono_decimalMult)\nICALL(DECIMAL_11, \"decimalRound\", mono_decimalRound)\nICALL(DECIMAL_12, \"decimalSetExponent\", mono_decimalSetExponent)\nICALL(DECIMAL_13, \"double2decimal\", mono_double2decimal) /* FIXME: wrong signature. */\nICALL(DECIMAL_14, \"string2decimal\", mono_string2decimal)\n#endif\n\nICALL_TYPE(DELEGATE, \"System.Delegate\", DELEGATE_1)\nICALL(DELEGATE_1, \"CreateDelegate_internal\", ves_icall_System_Delegate_CreateDelegate_internal)\nICALL(DELEGATE_2, \"SetMulticastInvoke\", ves_icall_System_Delegate_SetMulticastInvoke)\n\nICALL_TYPE(DEBUGR, \"System.Diagnostics.Debugger\", DEBUGR_1)\nICALL(DEBUGR_1, \"IsAttached_internal\", ves_icall_System_Diagnostics_Debugger_IsAttached_internal)\n\nICALL_TYPE(TRACEL, \"System.Diagnostics.DefaultTraceListener\", TRACEL_1)\nICALL(TRACEL_1, \"WriteWindowsDebugString\", ves_icall_System_Diagnostics_DefaultTraceListener_WriteWindowsDebugString)\n\n#ifndef DISABLE_PROCESS_HANDLING\nICALL_TYPE(FILEV, \"System.Diagnostics.FileVersionInfo\", FILEV_1)\nICALL(FILEV_1, \"GetVersionInfo_internal(string)\", ves_icall_System_Diagnostics_FileVersionInfo_GetVersionInfo_internal)\n\nICALL_TYPE(PERFCTR, \"System.Diagnostics.PerformanceCounter\", PERFCTR_1)\nICALL(PERFCTR_1, \"FreeData\", mono_perfcounter_free_data)\nICALL(PERFCTR_2, \"GetImpl\", mono_perfcounter_get_impl)\nICALL(PERFCTR_3, \"GetSample\", mono_perfcounter_get_sample)\nICALL(PERFCTR_4, \"UpdateValue\", mono_perfcounter_update_value)\n\nICALL_TYPE(PERFCTRCAT, \"System.Diagnostics.PerformanceCounterCategory\", PERFCTRCAT_1)\nICALL(PERFCTRCAT_1, \"CategoryDelete\", mono_perfcounter_category_del)\nICALL(PERFCTRCAT_2, \"CategoryHelpInternal\",   mono_perfcounter_category_help)\nICALL(PERFCTRCAT_3, \"CounterCategoryExists\", mono_perfcounter_category_exists)\nICALL(PERFCTRCAT_4, \"Create\",         mono_perfcounter_create)\nICALL(PERFCTRCAT_5, \"GetCategoryNames\", mono_perfcounter_category_names)\nICALL(PERFCTRCAT_6, \"GetCounterNames\", mono_perfcounter_counter_names)\nICALL(PERFCTRCAT_7, \"GetInstanceNames\", mono_perfcounter_instance_names)\nICALL(PERFCTRCAT_8, \"InstanceExistsInternal\", mono_perfcounter_instance_exists)\n\nICALL_TYPE(PROCESS, \"System.Diagnostics.Process\", PROCESS_1)\nICALL(PROCESS_1, \"CreateProcess_internal(System.Diagnostics.ProcessStartInfo,intptr,intptr,intptr,System.Diagnostics.Process/ProcInfo&)\", ves_icall_System_Diagnostics_Process_CreateProcess_internal)\nICALL(PROCESS_2, \"ExitCode_internal(intptr)\", ves_icall_System_Diagnostics_Process_ExitCode_internal)\nICALL(PROCESS_3, \"ExitTime_internal(intptr)\", ves_icall_System_Diagnostics_Process_ExitTime_internal)\nICALL(PROCESS_4, \"GetModules_internal(intptr)\", ves_icall_System_Diagnostics_Process_GetModules_internal)\nICALL(PROCESS_5, \"GetPid_internal()\", ves_icall_System_Diagnostics_Process_GetPid_internal)\nICALL(PROCESS_5B, \"GetPriorityClass(intptr,int&)\", ves_icall_System_Diagnostics_Process_GetPriorityClass)\nICALL(PROCESS_5H, \"GetProcessData\", ves_icall_System_Diagnostics_Process_GetProcessData)\nICALL(PROCESS_6, \"GetProcess_internal(int)\", ves_icall_System_Diagnostics_Process_GetProcess_internal)\nICALL(PROCESS_7, \"GetProcesses_internal()\", ves_icall_System_Diagnostics_Process_GetProcesses_internal)\nICALL(PROCESS_8, \"GetWorkingSet_internal(intptr,int&,int&)\", ves_icall_System_Diagnostics_Process_GetWorkingSet_internal)\nICALL(PROCESS_9, \"Kill_internal\", ves_icall_System_Diagnostics_Process_Kill_internal)\nICALL(PROCESS_10, \"ProcessName_internal(intptr)\", ves_icall_System_Diagnostics_Process_ProcessName_internal)\nICALL(PROCESS_11, \"Process_free_internal(intptr)\", ves_icall_System_Diagnostics_Process_Process_free_internal)\nICALL(PROCESS_11B, \"SetPriorityClass(intptr,int,int&)\", ves_icall_System_Diagnostics_Process_SetPriorityClass)\nICALL(PROCESS_12, \"SetWorkingSet_internal(intptr,int,int,bool)\", ves_icall_System_Diagnostics_Process_SetWorkingSet_internal)\nICALL(PROCESS_13, \"ShellExecuteEx_internal(System.Diagnostics.ProcessStartInfo,System.Diagnostics.Process/ProcInfo&)\", ves_icall_System_Diagnostics_Process_ShellExecuteEx_internal)\nICALL(PROCESS_14, \"StartTime_internal(intptr)\", ves_icall_System_Diagnostics_Process_StartTime_internal)\nICALL(PROCESS_14M, \"Times\", ves_icall_System_Diagnostics_Process_Times)\nICALL(PROCESS_15, \"WaitForExit_internal(intptr,int)\", ves_icall_System_Diagnostics_Process_WaitForExit_internal)\nICALL(PROCESS_16, \"WaitForInputIdle_internal(intptr,int)\", ves_icall_System_Diagnostics_Process_WaitForInputIdle_internal)\n\nICALL_TYPE (PROCESSHANDLE, \"System.Diagnostics.Process/ProcessWaitHandle\", PROCESSHANDLE_1)\nICALL (PROCESSHANDLE_1, \"ProcessHandle_close(intptr)\", ves_icall_System_Diagnostics_Process_ProcessHandle_close)\nICALL (PROCESSHANDLE_2, \"ProcessHandle_duplicate(intptr)\", ves_icall_System_Diagnostics_Process_ProcessHandle_duplicate)\n#endif /* !DISABLE_PROCESS_HANDLING */\n\nICALL_TYPE(STOPWATCH, \"System.Diagnostics.Stopwatch\", STOPWATCH_1)\nICALL(STOPWATCH_1, \"GetTimestamp\", mono_100ns_ticks)\n\nICALL_TYPE(DOUBLE, \"System.Double\", DOUBLE_1)\nICALL(DOUBLE_1, \"ParseImpl\",    mono_double_ParseImpl)\n\nICALL_TYPE(ENUM, \"System.Enum\", ENUM_1)\nICALL(ENUM_1, \"ToObject\", ves_icall_System_Enum_ToObject)\nICALL(ENUM_5, \"compare_value_to\", ves_icall_System_Enum_compare_value_to)\nICALL(ENUM_4, \"get_hashcode\", ves_icall_System_Enum_get_hashcode)\nICALL(ENUM_3, \"get_underlying_type\", ves_icall_System_Enum_get_underlying_type)\nICALL(ENUM_2, \"get_value\", ves_icall_System_Enum_get_value)\n\nICALL_TYPE(ENV, \"System.Environment\", ENV_1)\nICALL(ENV_1, \"Exit\", ves_icall_System_Environment_Exit)\nICALL(ENV_2, \"GetCommandLineArgs\", mono_runtime_get_main_args)\nICALL(ENV_3, \"GetEnvironmentVariableNames\", ves_icall_System_Environment_GetEnvironmentVariableNames)\nICALL(ENV_4, \"GetLogicalDrivesInternal\", ves_icall_System_Environment_GetLogicalDrives )\nICALL(ENV_5, \"GetMachineConfigPath\", ves_icall_System_Configuration_DefaultConfig_get_machine_config_path)\nICALL(ENV_6, \"GetOSVersionString\", ves_icall_System_Environment_GetOSVersionString)\nICALL(ENV_7, \"GetWindowsFolderPath\", ves_icall_System_Environment_GetWindowsFolderPath)\nICALL(ENV_8, \"InternalSetEnvironmentVariable\", ves_icall_System_Environment_InternalSetEnvironmentVariable)\nICALL(ENV_9, \"get_ExitCode\", mono_environment_exitcode_get)\nICALL(ENV_10, \"get_HasShutdownStarted\", ves_icall_System_Environment_get_HasShutdownStarted)\nICALL(ENV_11, \"get_MachineName\", ves_icall_System_Environment_get_MachineName)\nICALL(ENV_12, \"get_NewLine\", ves_icall_System_Environment_get_NewLine)\nICALL(ENV_13, \"get_Platform\", ves_icall_System_Environment_get_Platform)\nICALL(ENV_14, \"get_ProcessorCount\", mono_cpu_count)\nICALL(ENV_15, \"get_TickCount\", mono_msec_ticks)\nICALL(ENV_16, \"get_UserName\", ves_icall_System_Environment_get_UserName)\nICALL(ENV_16m, \"internalBroadcastSettingChange\", ves_icall_System_Environment_BroadcastSettingChange)\nICALL(ENV_17, \"internalGetEnvironmentVariable\", ves_icall_System_Environment_GetEnvironmentVariable)\nICALL(ENV_18, \"internalGetGacPath\", ves_icall_System_Environment_GetGacPath)\nICALL(ENV_19, \"internalGetHome\", ves_icall_System_Environment_InternalGetHome)\nICALL(ENV_20, \"set_ExitCode\", mono_environment_exitcode_set)\n\nICALL_TYPE(GC, \"System.GC\", GC_0)\nICALL(GC_0, \"CollectionCount\", mono_gc_collection_count)\nICALL(GC_0a, \"GetGeneration\", mono_gc_get_generation)\nICALL(GC_1, \"GetTotalMemory\", ves_icall_System_GC_GetTotalMemory)\nICALL(GC_2, \"InternalCollect\", ves_icall_System_GC_InternalCollect)\nICALL(GC_3, \"KeepAlive\", ves_icall_System_GC_KeepAlive)\nICALL(GC_4, \"ReRegisterForFinalize\", ves_icall_System_GC_ReRegisterForFinalize)\nICALL(GC_4a, \"RecordPressure\", mono_gc_add_memory_pressure)\nICALL(GC_5, \"SuppressFinalize\", ves_icall_System_GC_SuppressFinalize)\nICALL(GC_6, \"WaitForPendingFinalizers\", ves_icall_System_GC_WaitForPendingFinalizers)\nICALL(GC_7, \"get_MaxGeneration\", mono_gc_max_generation)\n\nICALL_TYPE(COMPINF, \"System.Globalization.CompareInfo\", COMPINF_1)\nICALL(COMPINF_1, \"assign_sortkey(object,string,System.Globalization.CompareOptions)\", ves_icall_System_Globalization_CompareInfo_assign_sortkey)\nICALL(COMPINF_2, \"construct_compareinfo(string)\", ves_icall_System_Globalization_CompareInfo_construct_compareinfo)\nICALL(COMPINF_3, \"free_internal_collator()\", ves_icall_System_Globalization_CompareInfo_free_internal_collator)\nICALL(COMPINF_4, \"internal_compare(string,int,int,string,int,int,System.Globalization.CompareOptions)\", ves_icall_System_Globalization_CompareInfo_internal_compare)\nICALL(COMPINF_5, \"internal_index(string,int,int,char,System.Globalization.CompareOptions,bool)\", ves_icall_System_Globalization_CompareInfo_internal_index_char)\nICALL(COMPINF_6, \"internal_index(string,int,int,string,System.Globalization.CompareOptions,bool)\", ves_icall_System_Globalization_CompareInfo_internal_index)\n\nICALL_TYPE(CULINF, \"System.Globalization.CultureInfo\", CULINF_2)\nICALL(CULINF_2, \"construct_datetime_format\", ves_icall_System_Globalization_CultureInfo_construct_datetime_format)\nICALL(CULINF_4, \"construct_internal_locale_from_current_locale\", ves_icall_System_Globalization_CultureInfo_construct_internal_locale_from_current_locale)\nICALL(CULINF_5, \"construct_internal_locale_from_lcid\", ves_icall_System_Globalization_CultureInfo_construct_internal_locale_from_lcid)\nICALL(CULINF_6, \"construct_internal_locale_from_name\", ves_icall_System_Globalization_CultureInfo_construct_internal_locale_from_name)\nICALL(CULINF_7, \"construct_internal_locale_from_specific_name\", ves_icall_System_Globalization_CultureInfo_construct_internal_locale_from_specific_name)\nICALL(CULINF_8, \"construct_number_format\", ves_icall_System_Globalization_CultureInfo_construct_number_format)\nICALL(CULINF_9, \"internal_get_cultures\", ves_icall_System_Globalization_CultureInfo_internal_get_cultures)\nICALL(CULINF_10, \"internal_is_lcid_neutral\", ves_icall_System_Globalization_CultureInfo_internal_is_lcid_neutral)\n\nICALL_TYPE(REGINF, \"System.Globalization.RegionInfo\", REGINF_1)\nICALL(REGINF_1, \"construct_internal_region_from_lcid\", ves_icall_System_Globalization_RegionInfo_construct_internal_region_from_lcid)\nICALL(REGINF_2, \"construct_internal_region_from_name\", ves_icall_System_Globalization_RegionInfo_construct_internal_region_from_name)\n\n#ifndef PLATFORM_NO_DRIVEINFO\nICALL_TYPE(IODRIVEINFO, \"System.IO.DriveInfo\", IODRIVEINFO_1)\nICALL(IODRIVEINFO_1, \"GetDiskFreeSpaceInternal\", ves_icall_System_IO_DriveInfo_GetDiskFreeSpace)\nICALL(IODRIVEINFO_2, \"GetDriveTypeInternal\", ves_icall_System_IO_DriveInfo_GetDriveType)\n#endif\n\nICALL_TYPE(FAMW, \"System.IO.FAMWatcher\", FAMW_1)\nICALL(FAMW_1, \"InternalFAMNextEvent\", ves_icall_System_IO_FAMW_InternalFAMNextEvent)\n\nICALL_TYPE(FILEW, \"System.IO.FileSystemWatcher\", FILEW_4)\nICALL(FILEW_4, \"InternalSupportsFSW\", ves_icall_System_IO_FSW_SupportsFSW)\n\nICALL_TYPE(INOW, \"System.IO.InotifyWatcher\", INOW_1)\nICALL(INOW_1, \"AddWatch\", ves_icall_System_IO_InotifyWatcher_AddWatch)\nICALL(INOW_2, \"GetInotifyInstance\", ves_icall_System_IO_InotifyWatcher_GetInotifyInstance)\nICALL(INOW_3, \"RemoveWatch\", ves_icall_System_IO_InotifyWatcher_RemoveWatch)\n\nICALL_TYPE(MONOIO, \"System.IO.MonoIO\", MONOIO_1)\nICALL(MONOIO_1, \"Close(intptr,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Close)\n#ifndef PLATFORM_RO_FS\nICALL(MONOIO_2, \"CopyFile(string,string,bool,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_CopyFile)\nICALL(MONOIO_3, \"CreateDirectory(string,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_CreateDirectory)\nICALL(MONOIO_4, \"CreatePipe(intptr&,intptr&)\", ves_icall_System_IO_MonoIO_CreatePipe)\nICALL(MONOIO_5, \"DeleteFile(string,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_DeleteFile)\n#endif /* !PLATFORM_RO_FS */\nICALL(MONOIO_34, \"DuplicateHandle\", ves_icall_System_IO_MonoIO_DuplicateHandle)\nICALL(MONOIO_6, \"Flush(intptr,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Flush)\nICALL(MONOIO_7, \"GetCurrentDirectory(System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_GetCurrentDirectory)\nICALL(MONOIO_8, \"GetFileAttributes(string,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_GetFileAttributes)\nICALL(MONOIO_9, \"GetFileStat(string,System.IO.MonoIOStat&,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_GetFileStat)\nICALL(MONOIO_10, \"GetFileSystemEntries\", ves_icall_System_IO_MonoIO_GetFileSystemEntries)\nICALL(MONOIO_11, \"GetFileType(intptr,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_GetFileType)\nICALL(MONOIO_12, \"GetLength(intptr,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_GetLength)\n#ifndef PLATFORM_RO_FS\nICALL(MONOIO_13, \"GetTempPath(string&)\", ves_icall_System_IO_MonoIO_GetTempPath)\nICALL(MONOIO_14, \"Lock(intptr,long,long,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Lock)\nICALL(MONOIO_15, \"MoveFile(string,string,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_MoveFile)\n#endif /* !PLATFORM_RO_FS */\nICALL(MONOIO_16, \"Open(string,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.FileOptions,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Open)\nICALL(MONOIO_17, \"Read(intptr,byte[],int,int,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Read)\n#ifndef PLATFORM_RO_FS\nICALL(MONOIO_18, \"RemoveDirectory(string,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_RemoveDirectory)\nICALL(MONOIO_18M, \"ReplaceFile(string,string,string,bool,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_ReplaceFile)\n#endif /* !PLATFORM_RO_FS */\nICALL(MONOIO_19, \"Seek(intptr,long,System.IO.SeekOrigin,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Seek)\nICALL(MONOIO_20, \"SetCurrentDirectory(string,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_SetCurrentDirectory)\nICALL(MONOIO_21, \"SetFileAttributes(string,System.IO.FileAttributes,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_SetFileAttributes)\nICALL(MONOIO_22, \"SetFileTime(intptr,long,long,long,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_SetFileTime)\nICALL(MONOIO_23, \"SetLength(intptr,long,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_SetLength)\n#ifndef PLATFORM_RO_FS\nICALL(MONOIO_24, \"Unlock(intptr,long,long,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Unlock)\n#endif\nICALL(MONOIO_25, \"Write(intptr,byte[],int,int,System.IO.MonoIOError&)\", ves_icall_System_IO_MonoIO_Write)\nICALL(MONOIO_26, \"get_AltDirectorySeparatorChar\", ves_icall_System_IO_MonoIO_get_AltDirectorySeparatorChar)\nICALL(MONOIO_27, \"get_ConsoleError\", ves_icall_System_IO_MonoIO_get_ConsoleError)\nICALL(MONOIO_28, \"get_ConsoleInput\", ves_icall_System_IO_MonoIO_get_ConsoleInput)\nICALL(MONOIO_29, \"get_ConsoleOutput\", ves_icall_System_IO_MonoIO_get_ConsoleOutput)\nICALL(MONOIO_30, \"get_DirectorySeparatorChar\", ves_icall_System_IO_MonoIO_get_DirectorySeparatorChar)\nICALL(MONOIO_31, \"get_InvalidPathChars\", ves_icall_System_IO_MonoIO_get_InvalidPathChars)\nICALL(MONOIO_32, \"get_PathSeparator\", ves_icall_System_IO_MonoIO_get_PathSeparator)\nICALL(MONOIO_33, \"get_VolumeSeparatorChar\", ves_icall_System_IO_MonoIO_get_VolumeSeparatorChar)\n\nICALL_TYPE(IOPATH, \"System.IO.Path\", IOPATH_1)\nICALL(IOPATH_1, \"get_temp_path\", ves_icall_System_IO_get_temp_path)\n\nICALL_TYPE(MATH, \"System.Math\", MATH_1)\nICALL(MATH_1, \"Acos\", ves_icall_System_Math_Acos)\nICALL(MATH_2, \"Asin\", ves_icall_System_Math_Asin)\nICALL(MATH_3, \"Atan\", ves_icall_System_Math_Atan)\nICALL(MATH_4, \"Atan2\", ves_icall_System_Math_Atan2)\nICALL(MATH_5, \"Cos\", ves_icall_System_Math_Cos)\nICALL(MATH_6, \"Cosh\", ves_icall_System_Math_Cosh)\nICALL(MATH_7, \"Exp\", ves_icall_System_Math_Exp)\nICALL(MATH_8, \"Floor\", ves_icall_System_Math_Floor)\nICALL(MATH_9, \"Log\", ves_icall_System_Math_Log)\nICALL(MATH_10, \"Log10\", ves_icall_System_Math_Log10)\nICALL(MATH_11, \"Pow\", ves_icall_System_Math_Pow)\nICALL(MATH_12, \"Round\", ves_icall_System_Math_Round)\nICALL(MATH_13, \"Round2\", ves_icall_System_Math_Round2)\nICALL(MATH_14, \"Sin\", ves_icall_System_Math_Sin)\nICALL(MATH_15, \"Sinh\", ves_icall_System_Math_Sinh)\nICALL(MATH_16, \"Sqrt\", ves_icall_System_Math_Sqrt)\nICALL(MATH_17, \"Tan\", ves_icall_System_Math_Tan)\nICALL(MATH_18, \"Tanh\", ves_icall_System_Math_Tanh)\n\nICALL_TYPE(MCATTR, \"System.MonoCustomAttrs\", MCATTR_1)\nICALL(MCATTR_1, \"GetCustomAttributesDataInternal\", mono_reflection_get_custom_attrs_data)\nICALL(MCATTR_2, \"GetCustomAttributesInternal\", custom_attrs_get_by_type)\nICALL(MCATTR_3, \"IsDefinedInternal\", custom_attrs_defined_internal)\n\nICALL_TYPE(MENUM, \"System.MonoEnumInfo\", MENUM_1)\nICALL(MENUM_1, \"get_enum_info\", ves_icall_get_enum_info)\n\nICALL_TYPE(MTYPE, \"System.MonoType\", MTYPE_1)\nICALL(MTYPE_1, \"GetArrayRank\", ves_icall_MonoType_GetArrayRank)\nICALL(MTYPE_2, \"GetConstructors\", ves_icall_Type_GetConstructors_internal)\nICALL(MTYPE_3, \"GetConstructors_internal\", ves_icall_Type_GetConstructors_internal)\nICALL(MTYPE_4, \"GetCorrespondingInflatedConstructor\", ves_icall_MonoType_GetCorrespondingInflatedMethod)\nICALL(MTYPE_5, \"GetCorrespondingInflatedMethod\", ves_icall_MonoType_GetCorrespondingInflatedMethod)\nICALL(MTYPE_6, \"GetElementType\", ves_icall_MonoType_GetElementType)\nICALL(MTYPE_7, \"GetEvents_internal\", ves_icall_Type_GetEvents_internal)\nICALL(MTYPE_8, \"GetField\", ves_icall_Type_GetField)\nICALL(MTYPE_9, \"GetFields_internal\", ves_icall_Type_GetFields_internal)\nICALL(MTYPE_10, \"GetGenericArguments\", ves_icall_MonoType_GetGenericArguments)\nICALL(MTYPE_11, \"GetInterfaces\", ves_icall_Type_GetInterfaces)\nICALL(MTYPE_12, \"GetMethodsByName\", ves_icall_Type_GetMethodsByName)\nICALL(MTYPE_13, \"GetNestedType\", ves_icall_Type_GetNestedType)\nICALL(MTYPE_14, \"GetNestedTypes\", ves_icall_Type_GetNestedTypes)\nICALL(MTYPE_15, \"GetPropertiesByName\", ves_icall_Type_GetPropertiesByName)\nICALL(MTYPE_16, \"InternalGetEvent\", ves_icall_MonoType_GetEvent)\nICALL(MTYPE_17, \"IsByRefImpl\", ves_icall_type_isbyref)\nICALL(MTYPE_18, \"IsCOMObjectImpl\", ves_icall_type_iscomobject)\nICALL(MTYPE_19, \"IsPointerImpl\", ves_icall_type_ispointer)\nICALL(MTYPE_20, \"IsPrimitiveImpl\", ves_icall_type_isprimitive)\nICALL(MTYPE_21, \"getFullName\", ves_icall_System_MonoType_getFullName)\nICALL(MTYPE_22, \"get_Assembly\", ves_icall_MonoType_get_Assembly)\nICALL(MTYPE_23, \"get_BaseType\", ves_icall_get_type_parent)\nICALL(MTYPE_24, \"get_DeclaringMethod\", ves_icall_MonoType_get_DeclaringMethod)\nICALL(MTYPE_25, \"get_DeclaringType\", ves_icall_MonoType_get_DeclaringType)\nICALL(MTYPE_26, \"get_IsGenericParameter\", ves_icall_MonoType_get_IsGenericParameter)\nICALL(MTYPE_27, \"get_Module\", ves_icall_MonoType_get_Module)\nICALL(MTYPE_28, \"get_Name\", ves_icall_MonoType_get_Name)\nICALL(MTYPE_29, \"get_Namespace\", ves_icall_MonoType_get_Namespace)\nICALL(MTYPE_30, \"get_UnderlyingSystemType\", ves_icall_MonoType_get_UnderlyingSystemType)\nICALL(MTYPE_31, \"get_attributes\", ves_icall_get_attributes)\nICALL(MTYPE_32, \"type_from_obj\", mono_type_type_from_obj)\n\n#ifndef DISABLE_SOCKETS\nICALL_TYPE(NDNS, \"System.Net.Dns\", NDNS_1)\nICALL(NDNS_1, \"GetHostByAddr_internal(string,string&,string[]&,string[]&)\", ves_icall_System_Net_Dns_GetHostByAddr_internal)\nICALL(NDNS_2, \"GetHostByName_internal(string,string&,string[]&,string[]&)\", ves_icall_System_Net_Dns_GetHostByName_internal)\nICALL(NDNS_3, \"GetHostName_internal(string&)\", ves_icall_System_Net_Dns_GetHostName_internal)\n\nICALL_TYPE(SOCK, \"System.Net.Sockets.Socket\", SOCK_1)\nICALL(SOCK_1, \"Accept_internal(intptr,int&,bool)\", ves_icall_System_Net_Sockets_Socket_Accept_internal)\nICALL(SOCK_2, \"Available_internal(intptr,int&)\", ves_icall_System_Net_Sockets_Socket_Available_internal)\nICALL(SOCK_3, \"Bind_internal(intptr,System.Net.SocketAddress,int&)\", ves_icall_System_Net_Sockets_Socket_Bind_internal)\nICALL(SOCK_4, \"Blocking_internal(intptr,bool,int&)\", ves_icall_System_Net_Sockets_Socket_Blocking_internal)\nICALL(SOCK_5, \"Close_internal(intptr,int&)\", ves_icall_System_Net_Sockets_Socket_Close_internal)\nICALL(SOCK_6, \"Connect_internal(intptr,System.Net.SocketAddress,int&)\", ves_icall_System_Net_Sockets_Socket_Connect_internal)\nICALL (SOCK_6a, \"Disconnect_internal(intptr,bool,int&)\", ves_icall_System_Net_Sockets_Socket_Disconnect_internal)\nICALL(SOCK_7, \"GetSocketOption_arr_internal(intptr,System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,byte[]&,int&)\", ves_icall_System_Net_Sockets_Socket_GetSocketOption_arr_internal)\nICALL(SOCK_8, \"GetSocketOption_obj_internal(intptr,System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,object&,int&)\", ves_icall_System_Net_Sockets_Socket_GetSocketOption_obj_internal)\nICALL(SOCK_9, \"Listen_internal(intptr,int,int&)\", ves_icall_System_Net_Sockets_Socket_Listen_internal)\nICALL(SOCK_10, \"LocalEndPoint_internal(intptr,int,int&)\", ves_icall_System_Net_Sockets_Socket_LocalEndPoint_internal)\nICALL(SOCK_11, \"Poll_internal\", ves_icall_System_Net_Sockets_Socket_Poll_internal)\nICALL(SOCK_11a, \"Receive_internal(intptr,System.Net.Sockets.Socket/WSABUF[],System.Net.Sockets.SocketFlags,int&)\", ves_icall_System_Net_Sockets_Socket_Receive_array_internal)\nICALL(SOCK_12, \"Receive_internal(intptr,byte[],int,int,System.Net.Sockets.SocketFlags,int&)\", ves_icall_System_Net_Sockets_Socket_Receive_internal)\nICALL(SOCK_13, \"RecvFrom_internal(intptr,byte[],int,int,System.Net.Sockets.SocketFlags,System.Net.SocketAddress&,int&)\", ves_icall_System_Net_Sockets_Socket_RecvFrom_internal)\nICALL(SOCK_14, \"RemoteEndPoint_internal(intptr,int,int&)\", ves_icall_System_Net_Sockets_Socket_RemoteEndPoint_internal)\nICALL(SOCK_15, \"Select_internal(System.Net.Sockets.Socket[]&,int,int&)\", ves_icall_System_Net_Sockets_Socket_Select_internal)\nICALL(SOCK_15a, \"SendFile(intptr,string,byte[],byte[],System.Net.Sockets.TransmitFileOptions)\", ves_icall_System_Net_Sockets_Socket_SendFile)\nICALL(SOCK_16, \"SendTo_internal(intptr,byte[],int,int,System.Net.Sockets.SocketFlags,System.Net.SocketAddress,int&)\", ves_icall_System_Net_Sockets_Socket_SendTo_internal)\nICALL(SOCK_16a, \"Send_internal(intptr,System.Net.Sockets.Socket/WSABUF[],System.Net.Sockets.SocketFlags,int&)\", ves_icall_System_Net_Sockets_Socket_Send_array_internal)\nICALL(SOCK_17, \"Send_internal(intptr,byte[],int,int,System.Net.Sockets.SocketFlags,int&)\", ves_icall_System_Net_Sockets_Socket_Send_internal)\nICALL(SOCK_18, \"SetSocketOption_internal(intptr,System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,object,byte[],int,int&)\", ves_icall_System_Net_Sockets_Socket_SetSocketOption_internal)\nICALL(SOCK_19, \"Shutdown_internal(intptr,System.Net.Sockets.SocketShutdown,int&)\", ves_icall_System_Net_Sockets_Socket_Shutdown_internal)\nICALL(SOCK_20, \"Socket_internal(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,int&)\", ves_icall_System_Net_Sockets_Socket_Socket_internal)\nICALL(SOCK_21, \"WSAIoctl(intptr,int,byte[],byte[],int&)\", ves_icall_System_Net_Sockets_Socket_WSAIoctl)\n\nICALL_TYPE(SOCKEX, \"System.Net.Sockets.SocketException\", SOCKEX_1)\nICALL(SOCKEX_1, \"WSAGetLastError_internal\", ves_icall_System_Net_Sockets_SocketException_WSAGetLastError_internal)\n#endif /* !DISABLE_SOCKETS */\n\nICALL_TYPE(NUMBER_FORMATTER, \"System.NumberFormatter\", NUMBER_FORMATTER_1)\nICALL(NUMBER_FORMATTER_1, \"GetFormatterTables\", ves_icall_System_NumberFormatter_GetFormatterTables)\n\nICALL_TYPE(OBJ, \"System.Object\", OBJ_1)\nICALL(OBJ_1, \"GetType\", ves_icall_System_Object_GetType)\nICALL(OBJ_2, \"InternalGetHashCode\", mono_object_hash)\nICALL(OBJ_3, \"MemberwiseClone\", ves_icall_System_Object_MemberwiseClone)\nICALL(OBJ_4, \"obj_address\", ves_icall_System_Object_obj_address)\n\nICALL_TYPE(ASSEM, \"System.Reflection.Assembly\", ASSEM_1)\nICALL(ASSEM_1, \"FillName\", ves_icall_System_Reflection_Assembly_FillName)\nICALL(ASSEM_2, \"GetCallingAssembly\", ves_icall_System_Reflection_Assembly_GetCallingAssembly)\nICALL(ASSEM_3, \"GetEntryAssembly\", ves_icall_System_Reflection_Assembly_GetEntryAssembly)\nICALL(ASSEM_4, \"GetExecutingAssembly\", ves_icall_System_Reflection_Assembly_GetExecutingAssembly)\nICALL(ASSEM_5, \"GetFilesInternal\", ves_icall_System_Reflection_Assembly_GetFilesInternal)\nICALL(ASSEM_6, \"GetManifestModuleInternal\", ves_icall_System_Reflection_Assembly_GetManifestModuleInternal)\nICALL(ASSEM_7, \"GetManifestResourceInfoInternal\", ves_icall_System_Reflection_Assembly_GetManifestResourceInfoInternal)\nICALL(ASSEM_8, \"GetManifestResourceInternal\", ves_icall_System_Reflection_Assembly_GetManifestResourceInternal)\nICALL(ASSEM_9, \"GetManifestResourceNames\", ves_icall_System_Reflection_Assembly_GetManifestResourceNames)\nICALL(ASSEM_10, \"GetModulesInternal\", ves_icall_System_Reflection_Assembly_GetModulesInternal)\nICALL(ASSEM_11, \"GetNamespaces\", ves_icall_System_Reflection_Assembly_GetNamespaces)\nICALL(ASSEM_12, \"GetReferencedAssemblies\", ves_icall_System_Reflection_Assembly_GetReferencedAssemblies)\nICALL(ASSEM_13, \"GetTypes\", ves_icall_System_Reflection_Assembly_GetTypes)\nICALL(ASSEM_14, \"InternalGetAssemblyName\", ves_icall_System_Reflection_Assembly_InternalGetAssemblyName)\nICALL(ASSEM_15, \"InternalGetType\", ves_icall_System_Reflection_Assembly_InternalGetType)\nICALL(ASSEM_16, \"InternalImageRuntimeVersion\", ves_icall_System_Reflection_Assembly_InternalImageRuntimeVersion)\nICALL(ASSEM_17, \"LoadFrom\", ves_icall_System_Reflection_Assembly_LoadFrom)\nICALL(ASSEM_18, \"LoadPermissions\", ves_icall_System_Reflection_Assembly_LoadPermissions)\n\t/*\n\t * Private icalls for the Mono Debugger\n\t */\nICALL(ASSEM_19, \"MonoDebugger_GetMethodToken\", ves_icall_MonoDebugger_GetMethodToken)\n\n\t/* normal icalls again */\nICALL(ASSEM_20, \"get_EntryPoint\", ves_icall_System_Reflection_Assembly_get_EntryPoint)\nICALL(ASSEM_21, \"get_ReflectionOnly\", ves_icall_System_Reflection_Assembly_get_ReflectionOnly)\nICALL(ASSEM_22, \"get_code_base\", ves_icall_System_Reflection_Assembly_get_code_base)\nICALL(ASSEM_23, \"get_fullname\", ves_icall_System_Reflection_Assembly_get_fullName)\nICALL(ASSEM_24, \"get_global_assembly_cache\", ves_icall_System_Reflection_Assembly_get_global_assembly_cache)\nICALL(ASSEM_25, \"get_location\", ves_icall_System_Reflection_Assembly_get_location)\nICALL(ASSEM_26, \"load_with_partial_name\", ves_icall_System_Reflection_Assembly_load_with_partial_name)\n\nICALL_TYPE(ASSEMN, \"System.Reflection.AssemblyName\", ASSEMN_1)\nICALL(ASSEMN_1, \"ParseName\", ves_icall_System_Reflection_AssemblyName_ParseName)\n\nICALL_TYPE(ASSEMB, \"System.Reflection.Emit.AssemblyBuilder\", ASSEMB_1)\nICALL(ASSEMB_1, \"InternalAddModule\", mono_image_load_module_dynamic)\nICALL(ASSEMB_2, \"basic_init\", mono_image_basic_init)\n\nICALL_TYPE(CATTRB, \"System.Reflection.Emit.CustomAttributeBuilder\", CATTRB_1)\nICALL(CATTRB_1, \"GetBlob\", mono_reflection_get_custom_attrs_blob)\n\n#ifndef DISABLE_REFLECTION_EMIT\nICALL_TYPE(DERIVEDTYPE, \"System.Reflection.Emit.DerivedType\", DERIVEDTYPE_1)\nICALL(DERIVEDTYPE_1, \"create_unmanaged_type\", mono_reflection_create_unmanaged_type)\n#endif\n\nICALL_TYPE(DYNM, \"System.Reflection.Emit.DynamicMethod\", DYNM_1)\nICALL(DYNM_1, \"create_dynamic_method\", mono_reflection_create_dynamic_method)\n\nICALL_TYPE(ENUMB, \"System.Reflection.Emit.EnumBuilder\", ENUMB_1)\nICALL(ENUMB_1, \"setup_enum_type\", ves_icall_EnumBuilder_setup_enum_type)\n\nICALL_TYPE(GPARB, \"System.Reflection.Emit.GenericTypeParameterBuilder\", GPARB_1)\nICALL(GPARB_1, \"initialize\", mono_reflection_initialize_generic_parameter)\n\nICALL_TYPE(METHODB, \"System.Reflection.Emit.MethodBuilder\", METHODB_1)\nICALL(METHODB_1, \"MakeGenericMethod\", mono_reflection_bind_generic_method_parameters)\n\nICALL_TYPE(MODULEB, \"System.Reflection.Emit.ModuleBuilder\", MODULEB_8)\nICALL(MODULEB_8, \"RegisterToken\", ves_icall_ModuleBuilder_RegisterToken)\nICALL(MODULEB_1, \"WriteToFile\", ves_icall_ModuleBuilder_WriteToFile)\nICALL(MODULEB_2, \"basic_init\", mono_image_module_basic_init)\nICALL(MODULEB_3, \"build_metadata\", ves_icall_ModuleBuilder_build_metadata)\nICALL(MODULEB_4, \"create_modified_type\", ves_icall_ModuleBuilder_create_modified_type)\nICALL(MODULEB_5, \"getMethodToken\", ves_icall_ModuleBuilder_getMethodToken)\nICALL(MODULEB_6, \"getToken\", ves_icall_ModuleBuilder_getToken)\nICALL(MODULEB_7, \"getUSIndex\", mono_image_insert_string)\nICALL(MODULEB_9, \"set_wrappers_type\", mono_image_set_wrappers_type)\n\nICALL_TYPE(SIGH, \"System.Reflection.Emit.SignatureHelper\", SIGH_1)\nICALL(SIGH_1, \"get_signature_field\", mono_reflection_sighelper_get_signature_field)\nICALL(SIGH_2, \"get_signature_local\", mono_reflection_sighelper_get_signature_local)\n\nICALL_TYPE(TYPEB, \"System.Reflection.Emit.TypeBuilder\", TYPEB_1)\nICALL(TYPEB_1, \"create_generic_class\", mono_reflection_create_generic_class)\nICALL(TYPEB_2, \"create_internal_class\", mono_reflection_create_internal_class)\nICALL(TYPEB_3, \"create_runtime_class\", mono_reflection_create_runtime_class)\nICALL(TYPEB_4, \"get_IsGenericParameter\", ves_icall_TypeBuilder_get_IsGenericParameter)\nICALL(TYPEB_5, \"get_event_info\", mono_reflection_event_builder_get_event_info)\nICALL(TYPEB_6, \"setup_generic_class\", mono_reflection_setup_generic_class)\nICALL(TYPEB_7, \"setup_internal_class\", mono_reflection_setup_internal_class)\n\nICALL_TYPE(FIELDI, \"System.Reflection.FieldInfo\", FILEDI_1)\nICALL(FILEDI_1, \"GetTypeModifiers\", ves_icall_System_Reflection_FieldInfo_GetTypeModifiers)\nICALL(FILEDI_2, \"GetUnmanagedMarshal\", ves_icall_System_Reflection_FieldInfo_GetUnmanagedMarshal)\nICALL(FILEDI_3, \"internal_from_handle_type\", ves_icall_System_Reflection_FieldInfo_internal_from_handle_type)\n\nICALL_TYPE(MEMBERI, \"System.Reflection.MemberInfo\", MEMBERI_1)\nICALL(MEMBERI_1, \"get_MetadataToken\", mono_reflection_get_token)\n\nICALL_TYPE(MBASE, \"System.Reflection.MethodBase\", MBASE_1)\nICALL(MBASE_1, \"GetCurrentMethod\", ves_icall_GetCurrentMethod)\nICALL(MBASE_2, \"GetMethodBodyInternal\", ves_icall_System_Reflection_MethodBase_GetMethodBodyInternal)\nICALL(MBASE_3, \"GetMethodFromHandleInternal\", ves_icall_System_Reflection_MethodBase_GetMethodFromHandleInternal)\nICALL(MBASE_4, \"GetMethodFromHandleInternalType\", ves_icall_System_Reflection_MethodBase_GetMethodFromHandleInternalType)\n\nICALL_TYPE(MODULE, \"System.Reflection.Module\", MODULE_1)\nICALL(MODULE_1, \"Close\", ves_icall_System_Reflection_Module_Close)\nICALL(MODULE_2, \"GetGlobalType\", ves_icall_System_Reflection_Module_GetGlobalType)\nICALL(MODULE_3, \"GetGuidInternal\", ves_icall_System_Reflection_Module_GetGuidInternal)\nICALL(MODULE_14, \"GetHINSTANCE\", ves_icall_System_Reflection_Module_GetHINSTANCE)\nICALL(MODULE_4, \"GetMDStreamVersion\", ves_icall_System_Reflection_Module_GetMDStreamVersion)\nICALL(MODULE_5, \"GetPEKind\", ves_icall_System_Reflection_Module_GetPEKind)\nICALL(MODULE_6, \"InternalGetTypes\", ves_icall_System_Reflection_Module_InternalGetTypes)\nICALL(MODULE_7, \"ResolveFieldToken\", ves_icall_System_Reflection_Module_ResolveFieldToken)\nICALL(MODULE_8, \"ResolveMemberToken\", ves_icall_System_Reflection_Module_ResolveMemberToken)\nICALL(MODULE_9, \"ResolveMethodToken\", ves_icall_System_Reflection_Module_ResolveMethodToken)\nICALL(MODULE_10, \"ResolveSignature\", ves_icall_System_Reflection_Module_ResolveSignature)\nICALL(MODULE_11, \"ResolveStringToken\", ves_icall_System_Reflection_Module_ResolveStringToken)\nICALL(MODULE_12, \"ResolveTypeToken\", ves_icall_System_Reflection_Module_ResolveTypeToken)\nICALL(MODULE_13, \"get_MetadataToken\", mono_reflection_get_token)\n\nICALL_TYPE(MCMETH, \"System.Reflection.MonoCMethod\", MCMETH_1)\nICALL(MCMETH_1, \"GetGenericMethodDefinition_impl\", ves_icall_MonoMethod_GetGenericMethodDefinition)\nICALL(MCMETH_2, \"InternalInvoke\", ves_icall_InternalInvoke)\n\nICALL_TYPE(MEVIN, \"System.Reflection.MonoEventInfo\", MEVIN_1)\nICALL(MEVIN_1, \"get_event_info\", ves_icall_get_event_info)\n\nICALL_TYPE(MFIELD, \"System.Reflection.MonoField\", MFIELD_1)\nICALL(MFIELD_1, \"GetFieldOffset\", ves_icall_MonoField_GetFieldOffset)\nICALL(MFIELD_2, \"GetParentType\", ves_icall_MonoField_GetParentType)\nICALL(MFIELD_5, \"GetRawConstantValue\", ves_icall_MonoField_GetRawConstantValue)\nICALL(MFIELD_3, \"GetValueInternal\", ves_icall_MonoField_GetValueInternal)\nICALL(MFIELD_4, \"SetValueInternal\", ves_icall_MonoField_SetValueInternal)\n\nICALL_TYPE(MGENCM, \"System.Reflection.MonoGenericCMethod\", MGENCM_1)\nICALL(MGENCM_1, \"get_ReflectedType\", ves_icall_MonoGenericMethod_get_ReflectedType)\n\nICALL_TYPE(MGENCL, \"System.Reflection.MonoGenericClass\", MGENCL_1)\nICALL(MGENCL_1, \"GetElementType\", ves_icall_MonoType_GetElementType)\nICALL(MGENCL_2, \"IsByRefImpl\", ves_icall_type_isbyref)\nICALL(MGENCL_3, \"IsPointerImpl\", ves_icall_type_ispointer)\nICALL(MGENCL_4, \"IsPrimitiveImpl\", ves_icall_type_isprimitive)\nICALL(MGENCL_5, \"initialize\", mono_reflection_generic_class_initialize)\n\n/* note this is the same as above: unify */\nICALL_TYPE(MGENM, \"System.Reflection.MonoGenericMethod\", MGENM_1)\nICALL(MGENM_1, \"get_ReflectedType\", ves_icall_MonoGenericMethod_get_ReflectedType)\n\nICALL_TYPE(MMETH, \"System.Reflection.MonoMethod\", MMETH_1)\nICALL(MMETH_1, \"GetDllImportAttribute\", ves_icall_MonoMethod_GetDllImportAttribute)\nICALL(MMETH_2, \"GetGenericArguments\", ves_icall_MonoMethod_GetGenericArguments)\nICALL(MMETH_3, \"GetGenericMethodDefinition_impl\", ves_icall_MonoMethod_GetGenericMethodDefinition)\nICALL(MMETH_4, \"InternalInvoke\", ves_icall_InternalInvoke)\nICALL(MMETH_5, \"MakeGenericMethod_impl\", mono_reflection_bind_generic_method_parameters)\nICALL(MMETH_6, \"get_IsGenericMethod\", ves_icall_MonoMethod_get_IsGenericMethod)\nICALL(MMETH_7, \"get_IsGenericMethodDefinition\", ves_icall_MonoMethod_get_IsGenericMethodDefinition)\nICALL(MMETH_8, \"get_base_definition\", ves_icall_MonoMethod_get_base_definition)\nICALL(MMETH_9, \"get_name\", ves_icall_MonoMethod_get_name)\n\nICALL_TYPE(MMETHI, \"System.Reflection.MonoMethodInfo\", MMETHI_1)\nICALL(MMETHI_1, \"get_method_info\", ves_icall_get_method_info)\nICALL(MMETHI_2, \"get_parameter_info\", ves_icall_get_parameter_info)\nICALL(MMETHI_3, \"get_retval_marshal\", ves_icall_System_MonoMethodInfo_get_retval_marshal)\n\nICALL_TYPE(MPROPI, \"System.Reflection.MonoPropertyInfo\", MPROPI_1)\nICALL(MPROPI_1, \"GetTypeModifiers\", property_info_get_type_modifiers)\nICALL(MPROPI_2, \"get_property_info\", ves_icall_get_property_info)\n\nICALL_TYPE(PARAMI, \"System.Reflection.ParameterInfo\", PARAMI_1)\nICALL(PARAMI_1, \"GetMetadataToken\", mono_reflection_get_token)\nICALL(PARAMI_2, \"GetTypeModifiers\", param_info_get_type_modifiers)\n\nICALL_TYPE(RUNH, \"System.Runtime.CompilerServices.RuntimeHelpers\", RUNH_1)\nICALL(RUNH_1, \"GetObjectValue\", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetObjectValue)\n\t /* REMOVEME: no longer needed, just so we dont break things when not needed */\nICALL(RUNH_2, \"GetOffsetToStringData\", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetOffsetToStringData)\nICALL(RUNH_3, \"InitializeArray\", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray)\nICALL(RUNH_4, \"RunClassConstructor\", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_RunClassConstructor)\nICALL(RUNH_5, \"RunModuleConstructor\", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_RunModuleConstructor)\nICALL(RUNH_6, \"get_OffsetToStringData\", ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_GetOffsetToStringData)\n\nICALL_TYPE(GCH, \"System.Runtime.InteropServices.GCHandle\", GCH_1)\nICALL(GCH_1, \"CheckCurrentDomain\", GCHandle_CheckCurrentDomain)\nICALL(GCH_2, \"FreeHandle\", ves_icall_System_GCHandle_FreeHandle)\nICALL(GCH_3, \"GetAddrOfPinnedObject\", ves_icall_System_GCHandle_GetAddrOfPinnedObject)\nICALL(GCH_4, \"GetTarget\", ves_icall_System_GCHandle_GetTarget)\nICALL(GCH_5, \"GetTargetHandle\", ves_icall_System_GCHandle_GetTargetHandle)\n\n#ifndef DISABLE_COM\nICALL_TYPE(MARSHAL, \"System.Runtime.InteropServices.Marshal\", MARSHAL_1)\nICALL(MARSHAL_1, \"AddRefInternal\", ves_icall_System_Runtime_InteropServices_Marshal_AddRefInternal)\n#else\nICALL_TYPE(MARSHAL, \"System.Runtime.InteropServices.Marshal\", MARSHAL_2)\n#endif\nICALL(MARSHAL_2, \"AllocCoTaskMem\", ves_icall_System_Runtime_InteropServices_Marshal_AllocCoTaskMem)\nICALL(MARSHAL_3, \"AllocHGlobal\", ves_icall_System_Runtime_InteropServices_Marshal_AllocHGlobal)\nICALL(MARSHAL_4, \"DestroyStructure\", ves_icall_System_Runtime_InteropServices_Marshal_DestroyStructure)\n#ifndef DISABLE_COM\nICALL(MARSHAL_5, \"FreeBSTR\", ves_icall_System_Runtime_InteropServices_Marshal_FreeBSTR)\n#endif\nICALL(MARSHAL_6, \"FreeCoTaskMem\", ves_icall_System_Runtime_InteropServices_Marshal_FreeCoTaskMem)\nICALL(MARSHAL_7, \"FreeHGlobal\", ves_icall_System_Runtime_InteropServices_Marshal_FreeHGlobal)\n#ifndef DISABLE_COM\nICALL(MARSHAL_44, \"GetCCW\", ves_icall_System_Runtime_InteropServices_Marshal_GetCCW)\nICALL(MARSHAL_8, \"GetComSlotForMethodInfoInternal\", ves_icall_System_Runtime_InteropServices_Marshal_GetComSlotForMethodInfoInternal)\n#endif\nICALL(MARSHAL_9, \"GetDelegateForFunctionPointerInternal\", ves_icall_System_Runtime_InteropServices_Marshal_GetDelegateForFunctionPointerInternal)\nICALL(MARSHAL_10, \"GetFunctionPointerForDelegateInternal\", mono_delegate_to_ftnptr)\n#ifndef DISABLE_COM\nICALL(MARSHAL_45, \"GetIDispatchForObjectInternal\", ves_icall_System_Runtime_InteropServices_Marshal_GetIDispatchForObjectInternal)\nICALL(MARSHAL_46, \"GetIUnknownForObjectInternal\", ves_icall_System_Runtime_InteropServices_Marshal_GetIUnknownForObjectInternal)\n#endif\nICALL(MARSHAL_11, \"GetLastWin32Error\", ves_icall_System_Runtime_InteropServices_Marshal_GetLastWin32Error)\n#ifndef DISABLE_COM\nICALL(MARSHAL_47, \"GetObjectForCCW\", ves_icall_System_Runtime_InteropServices_Marshal_GetObjectForCCW)\nICALL(MARSHAL_48, \"IsComObject\", ves_icall_System_Runtime_InteropServices_Marshal_IsComObject)\n#endif\nICALL(MARSHAL_12, \"OffsetOf\", ves_icall_System_Runtime_InteropServices_Marshal_OffsetOf)\nICALL(MARSHAL_13, \"Prelink\", ves_icall_System_Runtime_InteropServices_Marshal_Prelink)\nICALL(MARSHAL_14, \"PrelinkAll\", ves_icall_System_Runtime_InteropServices_Marshal_PrelinkAll)\nICALL(MARSHAL_15, \"PtrToStringAnsi(intptr)\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringAnsi)\nICALL(MARSHAL_16, \"PtrToStringAnsi(intptr,int)\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringAnsi_len)\n#ifndef DISABLE_COM\nICALL(MARSHAL_17, \"PtrToStringBSTR\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringBSTR)\n#endif\nICALL(MARSHAL_18, \"PtrToStringUni(intptr)\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringUni)\nICALL(MARSHAL_19, \"PtrToStringUni(intptr,int)\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStringUni_len)\nICALL(MARSHAL_20, \"PtrToStructure(intptr,System.Type)\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStructure_type)\nICALL(MARSHAL_21, \"PtrToStructure(intptr,object)\", ves_icall_System_Runtime_InteropServices_Marshal_PtrToStructure)\n#ifndef DISABLE_COM\nICALL(MARSHAL_22, \"QueryInterfaceInternal\", ves_icall_System_Runtime_InteropServices_Marshal_QueryInterfaceInternal)\n#endif\nICALL(MARSHAL_43, \"ReAllocCoTaskMem\", ves_icall_System_Runtime_InteropServices_Marshal_ReAllocCoTaskMem)\nICALL(MARSHAL_23, \"ReAllocHGlobal\", ves_icall_System_Runtime_InteropServices_Marshal_ReAllocHGlobal)\nICALL(MARSHAL_24, \"ReadByte\", ves_icall_System_Runtime_InteropServices_Marshal_ReadByte)\nICALL(MARSHAL_25, \"ReadInt16\", ves_icall_System_Runtime_InteropServices_Marshal_ReadInt16)\nICALL(MARSHAL_26, \"ReadInt32\", ves_icall_System_Runtime_InteropServices_Marshal_ReadInt32)\nICALL(MARSHAL_27, \"ReadInt64\", ves_icall_System_Runtime_InteropServices_Marshal_ReadInt64)\nICALL(MARSHAL_28, \"ReadIntPtr\", ves_icall_System_Runtime_InteropServices_Marshal_ReadIntPtr)\n#ifndef DISABLE_COM\nICALL(MARSHAL_49, \"ReleaseComObjectInternal\", ves_icall_System_Runtime_InteropServices_Marshal_ReleaseComObjectInternal)\nICALL(MARSHAL_29, \"ReleaseInternal\", ves_icall_System_Runtime_InteropServices_Marshal_ReleaseInternal)\n#endif\nICALL(MARSHAL_30, \"SizeOf\", ves_icall_System_Runtime_InteropServices_Marshal_SizeOf)\n#ifndef DISABLE_COM\nICALL(MARSHAL_31, \"StringToBSTR\", ves_icall_System_Runtime_InteropServices_Marshal_StringToBSTR)\n#endif\nICALL(MARSHAL_32, \"StringToHGlobalAnsi\", ves_icall_System_Runtime_InteropServices_Marshal_StringToHGlobalAnsi)\nICALL(MARSHAL_33, \"StringToHGlobalUni\", ves_icall_System_Runtime_InteropServices_Marshal_StringToHGlobalUni)\nICALL(MARSHAL_34, \"StructureToPtr\", ves_icall_System_Runtime_InteropServices_Marshal_StructureToPtr)\nICALL(MARSHAL_35, \"UnsafeAddrOfPinnedArrayElement\", ves_icall_System_Runtime_InteropServices_Marshal_UnsafeAddrOfPinnedArrayElement)\nICALL(MARSHAL_36, \"WriteByte\", ves_icall_System_Runtime_InteropServices_Marshal_WriteByte)\nICALL(MARSHAL_37, \"WriteInt16\", ves_icall_System_Runtime_InteropServices_Marshal_WriteInt16)\nICALL(MARSHAL_38, \"WriteInt32\", ves_icall_System_Runtime_InteropServices_Marshal_WriteInt32)\nICALL(MARSHAL_39, \"WriteInt64\", ves_icall_System_Runtime_InteropServices_Marshal_WriteInt64)\nICALL(MARSHAL_40, \"WriteIntPtr\", ves_icall_System_Runtime_InteropServices_Marshal_WriteIntPtr)\nICALL(MARSHAL_41, \"copy_from_unmanaged\", ves_icall_System_Runtime_InteropServices_Marshal_copy_from_unmanaged)\nICALL(MARSHAL_42, \"copy_to_unmanaged\", ves_icall_System_Runtime_InteropServices_Marshal_copy_to_unmanaged)\n\nICALL_TYPE(ACTS, \"System.Runtime.Remoting.Activation.ActivationServices\", ACTS_1)\nICALL(ACTS_1, \"AllocateUninitializedClassInstance\", ves_icall_System_Runtime_Activation_ActivationServices_AllocateUninitializedClassInstance)\nICALL(ACTS_2, \"EnableProxyActivation\", ves_icall_System_Runtime_Activation_ActivationServices_EnableProxyActivation)\n\nICALL_TYPE(MONOMM, \"System.Runtime.Remoting.Messaging.MonoMethodMessage\", MONOMM_1)\nICALL(MONOMM_1, \"InitMessage\", ves_icall_MonoMethodMessage_InitMessage)\n\nICALL_TYPE(REALP, \"System.Runtime.Remoting.Proxies.RealProxy\", REALP_1)\nICALL(REALP_1, \"InternalGetProxyType\", ves_icall_Remoting_RealProxy_InternalGetProxyType)\nICALL(REALP_2, \"InternalGetTransparentProxy\", ves_icall_Remoting_RealProxy_GetTransparentProxy)\n\nICALL_TYPE(REMSER, \"System.Runtime.Remoting.RemotingServices\", REMSER_0)\nICALL(REMSER_0, \"GetVirtualMethod\", ves_icall_Remoting_RemotingServices_GetVirtualMethod)\nICALL(REMSER_1, \"InternalExecute\", ves_icall_InternalExecute)\nICALL(REMSER_2, \"IsTransparentProxy\", ves_icall_IsTransparentProxy)\n\nICALL_TYPE(MHAN, \"System.RuntimeMethodHandle\", MHAN_1)\nICALL(MHAN_1, \"GetFunctionPointer\", ves_icall_RuntimeMethod_GetFunctionPointer)\n\nICALL_TYPE(RNG, \"System.Security.Cryptography.RNGCryptoServiceProvider\", RNG_1)\nICALL(RNG_1, \"RngClose\", ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngClose)\nICALL(RNG_2, \"RngGetBytes\", ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngGetBytes)\nICALL(RNG_3, \"RngInitialize\", ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngInitialize)\nICALL(RNG_4, \"RngOpen\", ves_icall_System_Security_Cryptography_RNGCryptoServiceProvider_RngOpen)\n\n#ifndef DISABLE_POLICY_EVIDENCE\nICALL_TYPE(EVID, \"System.Security.Policy.Evidence\", EVID_1)\nICALL(EVID_1, \"IsAuthenticodePresent\", ves_icall_System_Security_Policy_Evidence_IsAuthenticodePresent)\n\nICALL_TYPE(WINID, \"System.Security.Principal.WindowsIdentity\", WINID_1)\nICALL(WINID_1, \"GetCurrentToken\", ves_icall_System_Security_Principal_WindowsIdentity_GetCurrentToken)\nICALL(WINID_2, \"GetTokenName\", ves_icall_System_Security_Principal_WindowsIdentity_GetTokenName)\nICALL(WINID_3, \"GetUserToken\", ves_icall_System_Security_Principal_WindowsIdentity_GetUserToken)\nICALL(WINID_4, \"_GetRoles\", ves_icall_System_Security_Principal_WindowsIdentity_GetRoles)\n\nICALL_TYPE(WINIMP, \"System.Security.Principal.WindowsImpersonationContext\", WINIMP_1)\nICALL(WINIMP_1, \"CloseToken\", ves_icall_System_Security_Principal_WindowsImpersonationContext_CloseToken)\nICALL(WINIMP_2, \"DuplicateToken\", ves_icall_System_Security_Principal_WindowsImpersonationContext_DuplicateToken)\nICALL(WINIMP_3, \"RevertToSelf\", ves_icall_System_Security_Principal_WindowsImpersonationContext_RevertToSelf)\nICALL(WINIMP_4, \"SetCurrentToken\", ves_icall_System_Security_Principal_WindowsImpersonationContext_SetCurrentToken)\n\nICALL_TYPE(WINPRIN, \"System.Security.Principal.WindowsPrincipal\", WINPRIN_1)\nICALL(WINPRIN_1, \"IsMemberOfGroupId\", ves_icall_System_Security_Principal_WindowsPrincipal_IsMemberOfGroupId)\nICALL(WINPRIN_2, \"IsMemberOfGroupName\", ves_icall_System_Security_Principal_WindowsPrincipal_IsMemberOfGroupName)\n\nICALL_TYPE(SECSTRING, \"System.Security.SecureString\", SECSTRING_1)\nICALL(SECSTRING_1, \"DecryptInternal\", ves_icall_System_Security_SecureString_DecryptInternal)\nICALL(SECSTRING_2, \"EncryptInternal\", ves_icall_System_Security_SecureString_EncryptInternal)\n#endif /* !DISABLE_POLICY_EVIDENCE */\n\nICALL_TYPE(SECMAN, \"System.Security.SecurityManager\", SECMAN_1)\nICALL(SECMAN_1, \"GetLinkDemandSecurity\", ves_icall_System_Security_SecurityManager_GetLinkDemandSecurity)\nICALL(SECMAN_2, \"get_CheckExecutionRights\", ves_icall_System_Security_SecurityManager_get_CheckExecutionRights)\nICALL(SECMAN_3, \"get_SecurityEnabled\", ves_icall_System_Security_SecurityManager_get_SecurityEnabled)\nICALL(SECMAN_4, \"set_CheckExecutionRights\", ves_icall_System_Security_SecurityManager_set_CheckExecutionRights)\nICALL(SECMAN_5, \"set_SecurityEnabled\", ves_icall_System_Security_SecurityManager_set_SecurityEnabled)\n\nICALL_TYPE(STRING, \"System.String\", STRING_1)\nICALL(STRING_1, \".ctor(char*)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_2, \".ctor(char*,int,int)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_3, \".ctor(char,int)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_4, \".ctor(char[])\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_5, \".ctor(char[],int,int)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_6, \".ctor(sbyte*)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_7, \".ctor(sbyte*,int,int)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_8, \".ctor(sbyte*,int,int,System.Text.Encoding)\", ves_icall_System_String_ctor_RedirectToCreateString)\nICALL(STRING_9, \"InternalAllocateStr\", ves_icall_System_String_InternalAllocateStr)\nICALL(STRING_10, \"InternalIntern\", ves_icall_System_String_InternalIntern)\nICALL(STRING_11, \"InternalIsInterned\", ves_icall_System_String_InternalIsInterned)\nICALL(STRING_12, \"InternalSplit\", ves_icall_System_String_InternalSplit)\n\nICALL_TYPE(TENC, \"System.Text.Encoding\", TENC_1)\nICALL(TENC_1, \"InternalCodePage\", ves_icall_System_Text_Encoding_InternalCodePage)\n\nICALL_TYPE(ILOCK, \"System.Threading.Interlocked\", ILOCK_1)\nICALL(ILOCK_1, \"Add(int&,int)\", ves_icall_System_Threading_Interlocked_Add_Int)\nICALL(ILOCK_2, \"Add(long&,long)\", ves_icall_System_Threading_Interlocked_Add_Long)\nICALL(ILOCK_3, \"CompareExchange(T&,T,T)\", ves_icall_System_Threading_Interlocked_CompareExchange_T)\nICALL(ILOCK_4, \"CompareExchange(double&,double,double)\", ves_icall_System_Threading_Interlocked_CompareExchange_Double)\nICALL(ILOCK_5, \"CompareExchange(int&,int,int)\", ves_icall_System_Threading_Interlocked_CompareExchange_Int)\nICALL(ILOCK_6, \"CompareExchange(intptr&,intptr,intptr)\", ves_icall_System_Threading_Interlocked_CompareExchange_IntPtr)\nICALL(ILOCK_7, \"CompareExchange(long&,long,long)\", ves_icall_System_Threading_Interlocked_CompareExchange_Long)\nICALL(ILOCK_8, \"CompareExchange(object&,object,object)\", ves_icall_System_Threading_Interlocked_CompareExchange_Object)\nICALL(ILOCK_9, \"CompareExchange(single&,single,single)\", ves_icall_System_Threading_Interlocked_CompareExchange_Single)\nICALL(ILOCK_10, \"Decrement(int&)\", ves_icall_System_Threading_Interlocked_Decrement_Int)\nICALL(ILOCK_11, \"Decrement(long&)\", ves_icall_System_Threading_Interlocked_Decrement_Long)\nICALL(ILOCK_12, \"Exchange(T&,T)\", ves_icall_System_Threading_Interlocked_Exchange_T)\nICALL(ILOCK_13, \"Exchange(double&,double)\", ves_icall_System_Threading_Interlocked_Exchange_Double)\nICALL(ILOCK_14, \"Exchange(int&,int)\", ves_icall_System_Threading_Interlocked_Exchange_Int)\nICALL(ILOCK_15, \"Exchange(intptr&,intptr)\", ves_icall_System_Threading_Interlocked_Exchange_IntPtr)\nICALL(ILOCK_16, \"Exchange(long&,long)\", ves_icall_System_Threading_Interlocked_Exchange_Long)\nICALL(ILOCK_17, \"Exchange(object&,object)\", ves_icall_System_Threading_Interlocked_Exchange_Object)\nICALL(ILOCK_18, \"Exchange(single&,single)\", ves_icall_System_Threading_Interlocked_Exchange_Single)\nICALL(ILOCK_19, \"Increment(int&)\", ves_icall_System_Threading_Interlocked_Increment_Int)\nICALL(ILOCK_20, \"Increment(long&)\", ves_icall_System_Threading_Interlocked_Increment_Long)\nICALL(ILOCK_21, \"Read(long&)\", ves_icall_System_Threading_Interlocked_Read_Long)\n\nICALL_TYPE(MONIT, \"System.Threading.Monitor\", MONIT_8)\nICALL(MONIT_8, \"Enter\", mono_monitor_enter)\nICALL(MONIT_1, \"Exit\", mono_monitor_exit)\nICALL(MONIT_2, \"Monitor_pulse\", ves_icall_System_Threading_Monitor_Monitor_pulse)\nICALL(MONIT_3, \"Monitor_pulse_all\", ves_icall_System_Threading_Monitor_Monitor_pulse_all)\nICALL(MONIT_4, \"Monitor_test_owner\", ves_icall_System_Threading_Monitor_Monitor_test_owner)\nICALL(MONIT_5, \"Monitor_test_synchronised\", ves_icall_System_Threading_Monitor_Monitor_test_synchronised)\nICALL(MONIT_6, \"Monitor_try_enter\", ves_icall_System_Threading_Monitor_Monitor_try_enter)\nICALL(MONIT_7, \"Monitor_wait\", ves_icall_System_Threading_Monitor_Monitor_wait)\n\nICALL_TYPE(MUTEX, \"System.Threading.Mutex\", MUTEX_1)\nICALL(MUTEX_1, \"CreateMutex_internal(bool,string,bool&)\", ves_icall_System_Threading_Mutex_CreateMutex_internal)\nICALL(MUTEX_2, \"OpenMutex_internal(string,System.Security.AccessControl.MutexRights,System.IO.MonoIOError&)\", ves_icall_System_Threading_Mutex_OpenMutex_internal)\nICALL(MUTEX_3, \"ReleaseMutex_internal(intptr)\", ves_icall_System_Threading_Mutex_ReleaseMutex_internal)\n\nICALL_TYPE(NATIVEC, \"System.Threading.NativeEventCalls\", NATIVEC_1)\nICALL(NATIVEC_1, \"CloseEvent_internal\", ves_icall_System_Threading_Events_CloseEvent_internal)\nICALL(NATIVEC_2, \"CreateEvent_internal(bool,bool,string,bool&)\", ves_icall_System_Threading_Events_CreateEvent_internal)\nICALL(NATIVEC_3, \"OpenEvent_internal(string,System.Security.AccessControl.EventWaitHandleRights,System.IO.MonoIOError&)\", ves_icall_System_Threading_Events_OpenEvent_internal)\nICALL(NATIVEC_4, \"ResetEvent_internal\",  ves_icall_System_Threading_Events_ResetEvent_internal)\nICALL(NATIVEC_5, \"SetEvent_internal\",    ves_icall_System_Threading_Events_SetEvent_internal)\n\nICALL_TYPE(SEMA, \"System.Threading.Semaphore\", SEMA_1)\nICALL(SEMA_1, \"CreateSemaphore_internal(int,int,string,bool&)\", ves_icall_System_Threading_Semaphore_CreateSemaphore_internal)\nICALL(SEMA_2, \"OpenSemaphore_internal(string,System.Security.AccessControl.SemaphoreRights,System.IO.MonoIOError&)\", ves_icall_System_Threading_Semaphore_OpenSemaphore_internal)\nICALL(SEMA_3, \"ReleaseSemaphore_internal(intptr,int,bool&)\", ves_icall_System_Threading_Semaphore_ReleaseSemaphore_internal)\n\nICALL_TYPE(THREAD, \"System.Threading.Thread\", THREAD_1)\nICALL(THREAD_1, \"Abort_internal(object)\", ves_icall_System_Threading_Thread_Abort)\nICALL(THREAD_2, \"ClrState\", ves_icall_System_Threading_Thread_ClrState)\nICALL(THREAD_3, \"CurrentThread_internal\", mono_thread_current)\nICALL(THREAD_4, \"FreeLocalSlotValues\", mono_thread_free_local_slot_values)\nICALL(THREAD_55, \"GetAbortExceptionState\", ves_icall_System_Threading_Thread_GetAbortExceptionState)\nICALL(THREAD_5, \"GetCachedCurrentCulture\", ves_icall_System_Threading_Thread_GetCachedCurrentCulture)\nICALL(THREAD_6, \"GetCachedCurrentUICulture\", ves_icall_System_Threading_Thread_GetCachedCurrentUICulture)\nICALL(THREAD_7, \"GetDomainID\", ves_icall_System_Threading_Thread_GetDomainID)\nICALL(THREAD_8, \"GetName_internal\", ves_icall_System_Threading_Thread_GetName_internal)\nICALL(THREAD_9, \"GetSerializedCurrentCulture\", ves_icall_System_Threading_Thread_GetSerializedCurrentCulture)\nICALL(THREAD_10, \"GetSerializedCurrentUICulture\", ves_icall_System_Threading_Thread_GetSerializedCurrentUICulture)\nICALL(THREAD_11, \"GetState\", ves_icall_System_Threading_Thread_GetState)\nICALL(THREAD_53, \"Interrupt_internal\", ves_icall_System_Threading_Thread_Interrupt_internal)\nICALL(THREAD_12, \"Join_internal\", ves_icall_System_Threading_Thread_Join_internal)\nICALL(THREAD_13, \"MemoryBarrier\", ves_icall_System_Threading_Thread_MemoryBarrier)\nICALL(THREAD_14, \"ResetAbort_internal()\", ves_icall_System_Threading_Thread_ResetAbort)\nICALL(THREAD_15, \"Resume_internal()\", ves_icall_System_Threading_Thread_Resume)\nICALL(THREAD_16, \"SetCachedCurrentCulture\", ves_icall_System_Threading_Thread_SetCachedCurrentCulture)\nICALL(THREAD_17, \"SetCachedCurrentUICulture\", ves_icall_System_Threading_Thread_SetCachedCurrentUICulture)\nICALL(THREAD_18, \"SetName_internal\", ves_icall_System_Threading_Thread_SetName_internal)\nICALL(THREAD_19, \"SetSerializedCurrentCulture\", ves_icall_System_Threading_Thread_SetSerializedCurrentCulture)\nICALL(THREAD_20, \"SetSerializedCurrentUICulture\", ves_icall_System_Threading_Thread_SetSerializedCurrentUICulture)\nICALL(THREAD_21, \"SetState\", ves_icall_System_Threading_Thread_SetState)\nICALL(THREAD_22, \"Sleep_internal\", ves_icall_System_Threading_Thread_Sleep_internal)\nICALL(THREAD_54, \"SpinWait_nop\", ves_icall_System_Threading_Thread_SpinWait_nop)\nICALL(THREAD_23, \"Suspend_internal\", ves_icall_System_Threading_Thread_Suspend)\nICALL(THREAD_24, \"Thread_free_internal\", ves_icall_System_Threading_Thread_Thread_free_internal)\nICALL(THREAD_24a, \"Thread_init\", ves_icall_System_Threading_Thread_Thread_init)\nICALL(THREAD_25, \"Thread_internal\", ves_icall_System_Threading_Thread_Thread_internal)\nICALL(THREAD_26, \"VolatileRead(byte&)\", ves_icall_System_Threading_Thread_VolatileRead1)\nICALL(THREAD_27, \"VolatileRead(double&)\", ves_icall_System_Threading_Thread_VolatileRead8)\nICALL(THREAD_28, \"VolatileRead(int&)\", ves_icall_System_Threading_Thread_VolatileRead4)\nICALL(THREAD_29, \"VolatileRead(int16&)\", ves_icall_System_Threading_Thread_VolatileRead2)\nICALL(THREAD_30, \"VolatileRead(intptr&)\", ves_icall_System_Threading_Thread_VolatileReadIntPtr)\nICALL(THREAD_31, \"VolatileRead(long&)\", ves_icall_System_Threading_Thread_VolatileRead8)\nICALL(THREAD_32, \"VolatileRead(object&)\", ves_icall_System_Threading_Thread_VolatileReadIntPtr)\nICALL(THREAD_33, \"VolatileRead(sbyte&)\", ves_icall_System_Threading_Thread_VolatileRead1)\nICALL(THREAD_34, \"VolatileRead(single&)\", ves_icall_System_Threading_Thread_VolatileRead4)\nICALL(THREAD_35, \"VolatileRead(uint&)\", ves_icall_System_Threading_Thread_VolatileRead2)\nICALL(THREAD_36, \"VolatileRead(uint16&)\", ves_icall_System_Threading_Thread_VolatileRead2)\nICALL(THREAD_37, \"VolatileRead(uintptr&)\", ves_icall_System_Threading_Thread_VolatileReadIntPtr)\nICALL(THREAD_38, \"VolatileRead(ulong&)\", ves_icall_System_Threading_Thread_VolatileRead8)\nICALL(THREAD_39, \"VolatileWrite(byte&,byte)\", ves_icall_System_Threading_Thread_VolatileWrite1)\nICALL(THREAD_40, \"VolatileWrite(double&,double)\", ves_icall_System_Threading_Thread_VolatileWrite8)\nICALL(THREAD_41, \"VolatileWrite(int&,int)\", ves_icall_System_Threading_Thread_VolatileWrite4)\nICALL(THREAD_42, \"VolatileWrite(int16&,int16)\", ves_icall_System_Threading_Thread_VolatileWrite2)\nICALL(THREAD_43, \"VolatileWrite(intptr&,intptr)\", ves_icall_System_Threading_Thread_VolatileWriteIntPtr)\nICALL(THREAD_44, \"VolatileWrite(long&,long)\", ves_icall_System_Threading_Thread_VolatileWrite8)\nICALL(THREAD_45, \"VolatileWrite(object&,object)\", ves_icall_System_Threading_Thread_VolatileWriteObject)\nICALL(THREAD_46, \"VolatileWrite(sbyte&,sbyte)\", ves_icall_System_Threading_Thread_VolatileWrite1)\nICALL(THREAD_47, \"VolatileWrite(single&,single)\", ves_icall_System_Threading_Thread_VolatileWrite4)\nICALL(THREAD_48, \"VolatileWrite(uint&,uint)\", ves_icall_System_Threading_Thread_VolatileWrite2)\nICALL(THREAD_49, \"VolatileWrite(uint16&,uint16)\", ves_icall_System_Threading_Thread_VolatileWrite2)\nICALL(THREAD_50, \"VolatileWrite(uintptr&,uintptr)\", ves_icall_System_Threading_Thread_VolatileWriteIntPtr)\nICALL(THREAD_51, \"VolatileWrite(ulong&,ulong)\", ves_icall_System_Threading_Thread_VolatileWrite8)\nICALL(THREAD_52, \"current_lcid()\", ves_icall_System_Threading_Thread_current_lcid)\n\nICALL_TYPE(THREADP, \"System.Threading.ThreadPool\", THREADP_1)\nICALL(THREADP_1, \"GetAvailableThreads\", ves_icall_System_Threading_ThreadPool_GetAvailableThreads)\nICALL(THREADP_2, \"GetMaxThreads\", ves_icall_System_Threading_ThreadPool_GetMaxThreads)\nICALL(THREADP_3, \"GetMinThreads\", ves_icall_System_Threading_ThreadPool_GetMinThreads)\nICALL(THREADP_35, \"SetMaxThreads\", ves_icall_System_Threading_ThreadPool_SetMaxThreads)\nICALL(THREADP_4, \"SetMinThreads\", ves_icall_System_Threading_ThreadPool_SetMinThreads)\n\nICALL_TYPE(WAITH, \"System.Threading.WaitHandle\", WAITH_1)\nICALL(WAITH_1, \"SignalAndWait_Internal\", ves_icall_System_Threading_WaitHandle_SignalAndWait_Internal)\nICALL(WAITH_2, \"WaitAll_internal\", ves_icall_System_Threading_WaitHandle_WaitAll_internal)\nICALL(WAITH_3, \"WaitAny_internal\", ves_icall_System_Threading_WaitHandle_WaitAny_internal)\nICALL(WAITH_4, \"WaitOne_internal\", ves_icall_System_Threading_WaitHandle_WaitOne_internal)\n\nICALL_TYPE(TYPE, \"System.Type\", TYPE_1)\nICALL(TYPE_1, \"EqualsInternal\", ves_icall_System_Type_EqualsInternal)\nICALL(TYPE_2, \"GetGenericParameterAttributes\", ves_icall_Type_GetGenericParameterAttributes)\nICALL(TYPE_3, \"GetGenericParameterConstraints_impl\", ves_icall_Type_GetGenericParameterConstraints)\nICALL(TYPE_4, \"GetGenericParameterPosition\", ves_icall_Type_GetGenericParameterPosition)\nICALL(TYPE_5, \"GetGenericTypeDefinition_impl\", ves_icall_Type_GetGenericTypeDefinition_impl)\nICALL(TYPE_6, \"GetInterfaceMapData\", ves_icall_Type_GetInterfaceMapData)\nICALL(TYPE_7, \"GetPacking\", ves_icall_Type_GetPacking)\nICALL(TYPE_8, \"GetTypeCode\", ves_icall_type_GetTypeCodeInternal)\nICALL(TYPE_9, \"GetTypeCodeInternal\", ves_icall_type_GetTypeCodeInternal)\nICALL(TYPE_10, \"IsArrayImpl\", ves_icall_Type_IsArrayImpl)\nICALL(TYPE_11, \"IsInstanceOfType\", ves_icall_type_IsInstanceOfType)\nICALL(TYPE_12, \"MakeGenericType\", ves_icall_Type_MakeGenericType)\nICALL(TYPE_13, \"MakePointerType\", ves_icall_Type_MakePointerType)\nICALL(TYPE_14, \"get_IsGenericInstance\", ves_icall_Type_get_IsGenericInstance)\nICALL(TYPE_15, \"get_IsGenericType\", ves_icall_Type_get_IsGenericType)\nICALL(TYPE_16, \"get_IsGenericTypeDefinition\", ves_icall_Type_get_IsGenericTypeDefinition)\nICALL(TYPE_17, \"internal_from_handle\", ves_icall_type_from_handle)\nICALL(TYPE_18, \"internal_from_name\", ves_icall_type_from_name)\nICALL(TYPE_19, \"make_array_type\", ves_icall_Type_make_array_type)\nICALL(TYPE_20, \"make_byref_type\", ves_icall_Type_make_byref_type)\nICALL(TYPE_21, \"type_is_assignable_from\", ves_icall_type_is_assignable_from)\nICALL(TYPE_22, \"type_is_subtype_of\", ves_icall_type_is_subtype_of)\n\nICALL_TYPE(TYPEDR, \"System.TypedReference\", TYPEDR_1)\nICALL(TYPEDR_1, \"ToObject\",\tmono_TypedReference_ToObject)\nICALL(TYPEDR_2, \"ToObjectInternal\",\tmono_TypedReference_ToObjectInternal)\n\nICALL_TYPE(VALUET, \"System.ValueType\", VALUET_1)\nICALL(VALUET_1, \"InternalEquals\", ves_icall_System_ValueType_Equals)\nICALL(VALUET_2, \"InternalGetHashCode\", ves_icall_System_ValueType_InternalGetHashCode)\n\nICALL_TYPE(WEBIC, \"System.Web.Util.ICalls\", WEBIC_1)\nICALL(WEBIC_1, \"GetMachineConfigPath\", ves_icall_System_Configuration_DefaultConfig_get_machine_config_path)\nICALL(WEBIC_2, \"GetMachineInstallDirectory\", ves_icall_System_Web_Util_ICalls_get_machine_install_dir)\nICALL(WEBIC_3, \"GetUnmanagedResourcesPtr\", ves_icall_get_resources_ptr)\n\n#ifndef DISABLE_COM\nICALL_TYPE(COMOBJ, \"System.__ComObject\", COMOBJ_1)\nICALL(COMOBJ_1, \"CreateRCW\", ves_icall_System_ComObject_CreateRCW)\nICALL(COMOBJ_2, \"GetInterfaceInternal\", ves_icall_System_ComObject_GetInterfaceInternal)\nICALL(COMOBJ_3, \"ReleaseInterfaces\", ves_icall_System_ComObject_ReleaseInterfaces)\n#endif\n", "#ifndef __MONO_OBJECT_INTERNALS_H__\n#define __MONO_OBJECT_INTERNALS_H__\n\n#include <mono/metadata/object.h>\n#include <mono/metadata/threads.h>\n#include <mono/metadata/reflection.h>\n#include <mono/metadata/mempool.h>\n#include <mono/metadata/class-internals.h>\n#include <mono/io-layer/io-layer.h>\n#include \"mono/utils/mono-compiler.h\"\n#include \"mono/utils/mono-error.h\"\n\n/* \n * We should find a better place for this stuff. We can't put it in mono-compiler.h,\n * since that is included by libgc.\n */\n#ifndef G_LIKELY\n#define G_LIKELY(a) (a)\n#define G_UNLIKELY(a) (a)\n#endif\n\n/*\n * glib defines this macro and uses it in the definition of G_LIKELY, and thus,\n * g_assert (). The macro expands to a complex piece of code, preventing some\n * gcc versions like 4.3.0 from handling the __builtin_expect construct properly,\n * causing the generation of the unlikely branch into the middle of the code.\n */\n#ifdef _G_BOOLEAN_EXPR\n#undef _G_BOOLEAN_EXPR\n#define _G_BOOLEAN_EXPR(expr) ((gsize)(expr) != 0)\n#endif\n\n#if 1\n#ifdef __GNUC__\n#define mono_assert(expr)\t\t   G_STMT_START{\t\t  \\\n     if (!(expr))\t\t\t\t\t\t\t  \\\n       {\t\t\t\t\t\t\t\t  \\\n\t\tMonoException *ex;\t\t\t\t\t  \\\n\t\tchar *msg = g_strdup_printf (\"file %s: line %d (%s): \"\t  \\\n\t\t\"assertion failed: (%s)\", __FILE__, __LINE__,\t\t  \\\n\t\t__PRETTY_FUNCTION__, #expr);\t\t\t\t  \\\n\t\tex = mono_get_exception_execution_engine (msg);\t\t  \\\n\t\tg_free (msg);\t\t\t\t\t\t  \\\n\t\tmono_raise_exception (ex);\t\t\t\t  \\\n       };\t\t\t\t}G_STMT_END\n\n#define mono_assert_not_reached()\t\t  G_STMT_START{\t\t  \\\n     MonoException *ex;\t\t\t\t\t\t\t  \\\n     char *msg = g_strdup_printf (\"file %s: line %d (%s): \"\t\t  \\\n     \"should not be reached\", __FILE__, __LINE__, __PRETTY_FUNCTION__);\t  \\\n     ex = mono_get_exception_execution_engine (msg);\t\t\t  \\\n     g_free (msg);\t\t\t\t\t\t\t  \\\n     mono_raise_exception (ex);\t\t\t\t\t\t  \\\n}G_STMT_END\n#else /* not GNUC */\n#define mono_assert(expr)\t\t   G_STMT_START{\t\t  \\\n     if (!(expr))\t\t\t\t\t\t\t  \\\n       {\t\t\t\t\t\t\t\t  \\\n\t\tMonoException *ex;\t\t\t\t\t  \\\n\t\tchar *msg = g_strdup_printf (\"file %s: line %d: \"\t  \\\n\t\t\"assertion failed: (%s)\", __FILE__, __LINE__,\t\t  \\\n\t\t#expr);\t\t\t\t\t\t\t  \\\n\t\tex = mono_get_exception_execution_engine (msg);\t\t  \\\n\t\tg_free (msg);\t\t\t\t\t\t  \\\n\t\tmono_raise_exception (ex);\t\t\t\t  \\\n       };\t\t\t\t}G_STMT_END\n\n#define mono_assert_not_reached()\t\t  G_STMT_START{\t\t  \\\n     MonoException *ex;\t\t\t\t\t\t\t  \\\n     char *msg = g_strdup_printf (\"file %s: line %d): \"\t\t\t  \\\n     \"should not be reached\", __FILE__, __LINE__);\t\t\t  \\\n     ex = mono_get_exception_execution_engine (msg);\t\t\t  \\\n     g_free (msg);\t\t\t\t\t\t\t  \\\n     mono_raise_exception (ex);\t\t\t\t\t\t  \\\n}G_STMT_END\n#endif\n#else\n#define mono_assert(expr) g_assert(expr)\n#define mono_assert_not_reached() g_assert_not_reached() \n#endif\n\n#define MONO_CHECK_ARG(arg, expr)\t\tG_STMT_START{\t\t  \\\n     if (!(expr))\t\t\t\t\t\t\t  \\\n       {\t\t\t\t\t\t\t\t  \\\n\t\tMonoException *ex;\t\t\t\t\t  \\\n\t\tchar *msg = g_strdup_printf (\"assertion `%s' failed\",\t  \\\n\t\t#expr);\t\t\t\t\t\t\t  \\\n\t\tif (arg) {} /* check if the name exists */\t\t  \\\n\t\tex = mono_get_exception_argument (#arg, msg);\t\t  \\\n\t\tg_free (msg);\t\t\t\t\t\t  \\\n\t\tmono_raise_exception (ex);\t\t\t\t  \\\n       };\t\t\t\t}G_STMT_END\n\n#define MONO_CHECK_ARG_NULL(arg)\t    G_STMT_START{\t\t  \\\n     if (arg == NULL)\t\t\t\t\t\t\t  \\\n       {\t\t\t\t\t\t\t\t  \\\n\t\tMonoException *ex;\t\t\t\t\t  \\\n\t\tif (arg) {} /* check if the name exists */\t\t  \\\n\t\tex = mono_get_exception_argument_null (#arg);\t\t  \\\n\t\tmono_raise_exception (ex);\t\t\t\t  \\\n       };\t\t\t\t}G_STMT_END\n\n/* 16 == default capacity */\n#define mono_stringbuilder_capacity(sb) ((sb)->str ? ((sb)->str->length) : 16)\n\n/* \n * Macros which cache the results of lookups locally.\n * These should be used instead of the original versions, if the __GNUC__\n * restriction is acceptable.\n */\n\n#ifdef __GNUC__\n\n/* namespace and name should be a constant */\n#define mono_class_from_name_cached(image,namespace,name) ({ \\\n\t\t\tstatic MonoClass *tmp_klass; \\\n\t\t\tif (!tmp_klass) { \\\n\t\t\t\ttmp_klass = mono_class_from_name ((image), (namespace), (name)); \\\n\t\t\t\tg_assert (tmp_klass); \\\n\t\t\t}; \\\n\t\t\ttmp_klass; })\n/* name should be a compile-time constant */\n#define mono_class_get_field_from_name_cached(klass,name) ({ \\\n\t\t\tstatic MonoClassField *tmp_field; \\\n\t\t\tif (!tmp_field) { \\\n\t\t\t\ttmp_field = mono_class_get_field_from_name ((klass), (name)); \\\n\t\t\t\tg_assert (tmp_field); \\\n\t\t\t}; \\\n\t\t\ttmp_field; })\n/* eclass should be a run-time constant */\n#define mono_array_class_get_cached(eclass,rank) ({\t\\\n\t\t\tstatic MonoClass *tmp_klass; \\\n\t\t\tif (!tmp_klass) { \\\n\t\t\t\ttmp_klass = mono_array_class_get ((eclass), (rank));\t\\\n\t\t\t\tg_assert (tmp_klass); \\\n\t\t\t}; \\\n\t\t\ttmp_klass; })\n/* eclass should be a run-time constant */\n#define mono_array_new_cached(domain, eclass, size) mono_array_new_specific (mono_class_vtable ((domain), mono_array_class_get_cached ((eclass), 1)), (size))\n\n#else\n\n#define mono_class_from_name_cached(image,namespace,name) mono_class_from_name ((image), (namespace), (name))\n#define mono_class_get_field_from_name_cached(klass,name) mono_class_get_field_from_name ((klass), (name))\n#define mono_array_class_get_cached(eclass,rank) mono_array_class_get ((eclass), (rank))\n#define mono_array_new_cached(domain, eclass, size) mono_array_new_specific (mono_class_vtable ((domain), mono_array_class_get_cached ((eclass), 1)), (size))\n\n#endif\n\ntypedef struct {\n\tMonoObject obj;\n\tMonoObject *identity;\n} MonoMarshalByRefObject;\n\n/* This is a copy of System.AppDomain */\nstruct _MonoAppDomain {\n\tMonoMarshalByRefObject mbr;\n\tMonoDomain *data;\n};\n\ntypedef struct {\n\tMonoObject object;\n\tgint32 length;\n\tMonoString *str;\n\tMonoString *cached_str;\n\tgint32 max_capacity;\n} MonoStringBuilder;\n\ntypedef struct {\n\tMonoType *type;\n\tgpointer  value;\n\tMonoClass *klass;\n} MonoTypedRef;\n\ntypedef struct {\n\tgpointer args;\n} MonoArgumentHandle;\n\ntypedef struct {\n\tMonoMethodSignature *sig;\n\tgpointer args;\n\tgint32 next_arg;\n\tgint32 num_args;\n} MonoArgIterator;\n\nstruct _MonoException {\n\tMonoObject object;\n\t/* Stores the IPs and the generic sharing infos\n\t   (vtable/MRGCTX) of the frames. */\n\tMonoArray  *trace_ips;\n\tMonoObject *inner_ex;\n\tMonoString *message;\n\tMonoString *help_link;\n\tMonoString *class_name;\n\tMonoString *stack_trace;\n\tMonoString *remote_stack_trace;\n\tgint32\t    remote_stack_index;\n\tgint32\t    hresult;\n\tMonoString *source;\n\tMonoObject *_data;\n};\n\ntypedef struct {\n\tMonoException base;\n} MonoSystemException;\n\ntypedef struct {\n\tMonoSystemException base;\n\tMonoString *param_name;\n} MonoArgumentException;\n\ntypedef struct {\n\tMonoSystemException base;\n\tMonoString *msg;\n\tMonoString *type_name;\n} MonoTypeLoadException;\n\ntypedef struct {\n\tMonoObject   object;\n\tMonoObject  *async_state;\n\tMonoObject  *handle;\n\tMonoObject  *async_delegate;\n\tgpointer    *data;\n\tMonoObject  *object_data;\n\tMonoBoolean  sync_completed;\n\tMonoBoolean  completed;\n\tMonoBoolean  endinvoke_called;\n\tMonoObject  *async_callback;\n\tMonoObject  *execution_context;\n\tMonoObject  *original_context;\n} MonoAsyncResult;\n\ntypedef struct {\n\tMonoMarshalByRefObject object;\n\tgpointer     handle;\n\tMonoBoolean  disposed;\n} MonoWaitHandle;\n\n/* This is a copy of System.Runtime.Remoting.Messaging.CallType */\ntypedef enum {\n\tCallType_Sync = 0,\n\tCallType_BeginInvoke = 1,\n\tCallType_EndInvoke = 2,\n\tCallType_OneWay = 3\n} MonoCallType;\n\n/* This corresponds to System.Type */\nstruct _MonoReflectionType {\n\tMonoObject object;\n\tMonoType  *type;\n};\n\ntypedef struct {\n\tMonoReflectionType type;\n\tMonoObject *type_info;\n} MonoReflectionMonoType;\n\ntypedef struct {\n\tMonoObject  object;\n\tMonoReflectionType *class_to_proxy;\t\n\tMonoObject *context;\n\tMonoObject *unwrapped_server;\n\tgint32      target_domain_id;\n\tMonoString *target_uri;\n\tMonoObject *object_identity;\n\tMonoObject *obj_TP;\n\tMonoObject *stub_data;\n} MonoRealProxy;\n\ntypedef struct {\n\tMonoMarshalByRefObject object;\n\tgpointer iunknown;\n\tGHashTable* itf_hash;\n} MonoComObject;\n\ntypedef struct {\n\tMonoRealProxy real_proxy;\n\tMonoComObject *com_object;\n\tgint32 ref_count;\n} MonoComInteropProxy;\n\ntypedef struct {\n\tMonoObject\t object;\n\tMonoRealProxy\t*rp;\t\n\tMonoRemoteClass *remote_class;\n\tMonoBoolean\t custom_type_info;\n} MonoTransparentProxy;\n\ntypedef struct {\n\tMonoObject obj;\n\tMonoReflectionMethod *method;\n\tMonoArray  *args;\t\t\n\tMonoArray  *names;\t\t\n\tMonoArray  *arg_types;\t\n\tMonoObject *ctx;\n\tMonoObject *rval;\n\tMonoObject *exc;\n\tMonoAsyncResult *async_result;\n\tguint32\t    call_type;\n} MonoMethodMessage;\n\ntypedef struct {\n\tMonoObject obj;\n\tgint32 il_offset;\n\tgint32 native_offset;\n\tMonoReflectionMethod *method;\n\tMonoString *filename;\n\tgint32 line;\n\tgint32 column;\n\tMonoString *internal_method_name;\n} MonoStackFrame;\n\ntypedef enum {\n\tMONO_THREAD_FLAG_DONT_MANAGE = 1, // Don't wait for or abort this thread\n} MonoThreadFlags;\n\nstruct _MonoThread {\n\tMonoObject  obj;\n\tint         lock_thread_id; /* to be used as the pre-shifted thread id in thin locks */\n\tHANDLE\t    handle;\n\tMonoArray  *cached_culture_info;\n\tgpointer    unused1;\n\tMonoBoolean threadpool_thread;\n\tgunichar2  *name;\n\tguint32\t    name_len;\n\tguint32\t    state;\n\tMonoException *abort_exc;\n\tint abort_state_handle;\n\tguint64 tid;\t/* This is accessed as a gsize in the code (so it can hold a 64bit pointer on systems that need it), but needs to reserve 64 bits of space on all machines as it corresponds to a field in managed code */\n\tHANDLE\t    start_notify;\n\tgpointer stack_ptr;\n\tgpointer *static_data;\n\tgpointer jit_data;\n\tgpointer lock_data;\n\tMonoAppContext *current_appcontext;\n\tint stack_size;\n\tMonoObject *start_obj;\n\tGSList *appdomain_refs;\n\t/* This is modified using atomic ops, so keep it a gint32 */\n\tgint32 interruption_requested;\n\tgpointer suspend_event;\n\tgpointer suspended_event;\n\tgpointer resume_event;\n\tCRITICAL_SECTION *synch_cs;\n\tguint8* serialized_culture_info;\n\tguint32 serialized_culture_info_len;\n\tguint8* serialized_ui_culture_info;\n\tguint32 serialized_ui_culture_info_len;\n\tMonoBoolean thread_dump_requested;\n\tgpointer end_stack; /* This is only used when running in the debugger. */\n\tMonoBoolean thread_interrupt_requested;\n\tguint8\tapartment_state;\n\tgint32 critical_region_level;\n\tguint32 small_id; /* A small, unique id, used for the hazard pointer table. */\n\tMonoThreadManageCallback manage_callback;\n\tMonoException *pending_exception;\n\tMonoObject *ec_to_set;\n\t/* \n\t * These fields are used to avoid having to increment corlib versions\n\t * when a new field is added to the unmanaged MonoThread structure.\n\t */\n\tgpointer interrupt_on_stop;\n\tgsize    flags;\n\tgpointer unused4;\n\tgpointer unused5;\n\tgpointer unused6;\n};\n\ntypedef struct {\n\tMonoString *name;\n\tMonoReflectionType *type;\n\tMonoObject *value;\n} MonoSerializationEntry;\n\ntypedef struct {\n\tguint32 state;\n\tMonoObject *additional;\n} MonoStreamingContext;\n\ntypedef struct {\n\tMonoObject obj;\n\tMonoBoolean readOnly;\n\tMonoString *AMDesignator;\n\tMonoString *PMDesignator;\n\tMonoString *DateSeparator;\n\tMonoString *TimeSeparator;\n\tMonoString *ShortDatePattern;\n\tMonoString *LongDatePattern;\n\tMonoString *ShortTimePattern;\n\tMonoString *LongTimePattern;\n\tMonoString *MonthDayPattern;\n\tMonoString *YearMonthPattern;\n\tMonoString *FullDateTimePattern;\n\tMonoString *RFC1123Pattern;\n\tMonoString *SortableDateTimePattern;\n\tMonoString *UniversalSortableDateTimePattern;\n\tguint32 FirstDayOfWeek;\n\tMonoObject *Calendar;\n\tguint32 CalendarWeekRule;\n\tMonoArray *AbbreviatedDayNames;\n\tMonoArray *DayNames;\n\tMonoArray *MonthNames;\n\tMonoArray *AbbreviatedMonthNames;\n\tMonoArray *ShortDatePatterns;\n\tMonoArray *LongDatePatterns;\n\tMonoArray *ShortTimePatterns;\n\tMonoArray *LongTimePatterns;\n\tMonoArray *MonthDayPatterns;\n\tMonoArray *YearMonthPatterns;\n\tMonoArray *shortDayNames;\n} MonoDateTimeFormatInfo;\n\ntypedef struct \n{\n\tMonoObject obj;\n\tMonoBoolean readOnly;\n\tMonoString *decimalFormats;\n\tMonoString *currencyFormats;\n\tMonoString *percentFormats;\n\tMonoString *digitPattern;\n\tMonoString *zeroPattern;\n\tgint32 currencyDecimalDigits;\n\tMonoString *currencyDecimalSeparator;\n\tMonoString *currencyGroupSeparator;\n\tMonoArray *currencyGroupSizes;\n\tgint32 currencyNegativePattern;\n\tgint32 currencyPositivePattern;\n\tMonoString *currencySymbol;\n\tMonoString *naNSymbol;\n\tMonoString *negativeInfinitySymbol;\n\tMonoString *negativeSign;\n\tguint32 numberDecimalDigits;\n\tMonoString *numberDecimalSeparator;\n\tMonoString *numberGroupSeparator;\n\tMonoArray *numberGroupSizes;\n\tgint32 numberNegativePattern;\n\tgint32 percentDecimalDigits;\n\tMonoString *percentDecimalSeparator;\n\tMonoString *percentGroupSeparator;\n\tMonoArray *percentGroupSizes;\n\tgint32 percentNegativePattern;\n\tgint32 percentPositivePattern;\n\tMonoString *percentSymbol;\n\tMonoString *perMilleSymbol;\n\tMonoString *positiveInfinitySymbol;\n\tMonoString *positiveSign;\n} MonoNumberFormatInfo;\n\ntypedef struct {\n\tMonoObject obj;\n\tgint32 lcid;\n\tMonoString *icu_name;\n\tgpointer ICU_collator;\n} MonoCompareInfo;\n\ntypedef struct {\n\tMonoObject obj;\n\tMonoBoolean is_read_only;\n\tgint32 lcid;\n\tgint32 parent_lcid;\n\tgint32 specific_lcid;\n\tgint32 datetime_index;\n\tgint32 number_index;\n\tMonoBoolean use_user_override;\n\tMonoNumberFormatInfo *number_format;\n\tMonoDateTimeFormatInfo *datetime_format;\n\tMonoObject *textinfo;\n\tMonoString *name;\n\tMonoString *displayname;\n\tMonoString *englishname;\n\tMonoString *nativename;\n\tMonoString *iso3lang;\n\tMonoString *iso2lang;\n\tMonoString *icu_name;\n\tMonoString *win3lang;\n\tMonoString *territory;\n\tMonoCompareInfo *compareinfo;\n\tconst gint32 *calendar_data;\n\tconst void* text_info_data;\n} MonoCultureInfo;\n\ntypedef struct {\n\tMonoObject obj;\n\tgint32 region_id;\n\tMonoString *iso2name;\n\tMonoString *iso3name;\n\tMonoString *win3name;\n\tMonoString *english_name;\n\tMonoString *currency_symbol;\n\tMonoString *iso_currency_symbol;\n\tMonoString *currency_english_name;\n} MonoRegionInfo;\n\ntypedef struct {\n\tMonoObject obj;\n\tMonoString *str;\n\tgint32 options;\n\tMonoArray *key;\n\tgint32 lcid;\n} MonoSortKey;\n\ntypedef struct {\n\tMonoObject object;\n\tguint32 intType;\n} MonoInterfaceTypeAttribute;\n\n/* \n * Callbacks supplied by the runtime and called by the modules in metadata/\n * This interface is easier to extend than adding a new function type +\n * a new 'install' function for every callback.\n */\ntypedef struct {\n\tgpointer (*create_ftnptr) (MonoDomain *domain, gpointer addr);\n\tgpointer (*get_addr_from_ftnptr) (gpointer descr);\n\tchar*    (*get_runtime_build_info) (void);\n} MonoRuntimeCallbacks;\n\n/* used to free a dynamic method */\ntypedef void        (*MonoFreeMethodFunc)\t (MonoDomain *domain, MonoMethod *method);\n\n/* Used to initialize the method pointers inside vtables */\ntypedef gboolean    (*MonoInitVTableFunc)    (MonoVTable *vtable);\n\nvoid mono_set_pending_exception (MonoException *exc) MONO_INTERNAL;\n\n/* remoting and async support */\n\nMonoAsyncResult *\nmono_async_result_new\t    (MonoDomain *domain, HANDLE handle, \n\t\t\t     MonoObject *state, gpointer data, MonoObject *object_data) MONO_INTERNAL;\n\nMonoWaitHandle *\nmono_wait_handle_new\t    (MonoDomain *domain, HANDLE handle) MONO_INTERNAL;\n\nHANDLE\nmono_wait_handle_get_handle (MonoWaitHandle *handle) MONO_INTERNAL;\n\nvoid\nmono_message_init\t    (MonoDomain *domain, MonoMethodMessage *this_obj, \n\t\t\t     MonoReflectionMethod *method, MonoArray *out_args) MONO_INTERNAL;\n\nMonoObject *\nmono_remoting_invoke\t    (MonoObject *real_proxy, MonoMethodMessage *msg, \n\t\t\t     MonoObject **exc, MonoArray **out_args) MONO_INTERNAL;\n\nMonoObject *\nmono_message_invoke\t    (MonoObject *target, MonoMethodMessage *msg, \n\t\t\t     MonoObject **exc, MonoArray **out_args) MONO_INTERNAL;\n\nMonoMethodMessage *\nmono_method_call_message_new (MonoMethod *method, gpointer *params, MonoMethod *invoke, \n\t\t\t      MonoDelegate **cb, MonoObject **state) MONO_INTERNAL;\n\nvoid\nmono_method_return_message_restore (MonoMethod *method, gpointer *params, MonoArray *out_args) MONO_INTERNAL;\n\nvoid\nmono_delegate_ctor_with_method (MonoObject *this, MonoObject *target, gpointer addr, MonoMethod *method) MONO_INTERNAL;\n\nvoid\nmono_delegate_ctor\t    (MonoObject *this_obj, MonoObject *target, gpointer addr) MONO_INTERNAL;\n\nvoid*\nmono_class_get_allocation_ftn (MonoVTable *vtable, gboolean for_box, gboolean *pass_size_in_words) MONO_INTERNAL;\n\nvoid\nmono_runtime_free_method    (MonoDomain *domain, MonoMethod *method) MONO_INTERNAL;\n\n/* runtime initialization functions */\ntypedef void (*MonoExceptionFunc) (MonoException *ex);\n\nvoid\nmono_install_handler\t    (MonoExceptionFunc func) MONO_INTERNAL;\n\nvoid\t    \nmono_install_runtime_invoke (MonoInvokeFunc func) MONO_INTERNAL;\n\nvoid\t    \nmono_install_compile_method (MonoCompileFunc func) MONO_INTERNAL;\n\nvoid\nmono_install_free_method    (MonoFreeMethodFunc func) MONO_INTERNAL;\n\nvoid\nmono_install_callbacks      (MonoRuntimeCallbacks *cbs) MONO_INTERNAL;\n\nMonoRuntimeCallbacks*\nmono_get_runtime_callbacks (void) MONO_INTERNAL;\n\nvoid\nmono_type_initialization_init (void) MONO_INTERNAL;\n\nvoid\nmono_type_initialization_cleanup (void) MONO_INTERNAL;\n\nguint32\nmono_thread_get_tls_key    (void) MONO_INTERNAL;\n\ngint32\nmono_thread_get_tls_offset (void) MONO_INTERNAL;\n\nguint32\nmono_domain_get_tls_key    (void) MONO_INTERNAL;\n\ngint32\nmono_domain_get_tls_offset (void) MONO_INTERNAL;\n\n/* Reflection and Reflection.Emit support */\n\n/*\n * Handling System.Type objects:\n *\n *   Fields defined as System.Type in managed code should be defined as MonoObject* \n * in unmanaged structures, and the monotype_cast () function should be used for \n * casting them to MonoReflectionType* to avoid crashes/security issues when \n * encountering instances of user defined subclasses of System.Type.\n */\n\n#define IS_MONOTYPE(obj) (!(obj) || (((MonoObject*)(obj))->vtable->klass->image == mono_defaults.corlib && ((MonoReflectionType*)(obj))->type != NULL))\n\n/* \n * Make sure the argument, which should be a System.Type is a System.MonoType object \n * or equivalent, and not an instance of \n * a user defined subclass of System.Type. This should be used in places were throwing\n * an exception is safe.\n */\n#define CHECK_MONOTYPE(obj) do { \\\n\tif (!IS_MONOTYPE (obj)) \\\n\t\tmono_raise_exception (mono_get_exception_not_supported (\"User defined subclasses of System.Type are not yet supported\")); \\\n\t} while (0)\n\n/* This should be used for accessing members of Type[] arrays */\n#define mono_type_array_get(arr,index) monotype_cast (mono_array_get ((arr), gpointer, (index)))\n\n/*\n * Cast an object to MonoReflectionType, making sure it is a System.MonoType or\n * a subclass of it.\n */\nstatic inline MonoReflectionType*\nmonotype_cast (MonoObject *obj)\n{\n\tg_assert (IS_MONOTYPE (obj));\n\n\treturn (MonoReflectionType*)obj;\n}\n\n/*\n * The following structure must match the C# implementation in our corlib.\n */\n\nstruct _MonoReflectionMethod {\n\tMonoObject object;\n\tMonoMethod *method;\n\tMonoString *name;\n\tMonoReflectionType *reftype;\n};\n\ntypedef struct _MonoReflectionGenericMethod MonoReflectionGenericMethod;\nstruct _MonoReflectionGenericMethod {\n\tMonoReflectionMethod method;\n};\n\nstruct _MonoDelegate {\n\tMonoObject object;\n\t/* The compiled code of the target method */\n\tgpointer method_ptr;\n\t/* The invoke code */\n\tgpointer invoke_impl;\n\tMonoObject *target;\n\tMonoMethod *method;\n\tgpointer delegate_trampoline;\n\t/* \n\t * If non-NULL, this points to a memory location which stores the address of \n\t * the compiled code of the method, or NULL if it is not yet compiled.\n\t */\n\tguint8 **method_code;\n\tMonoReflectionMethod *method_info;\n\tMonoReflectionMethod *original_method_info;\n\tMonoObject *data;\n};\n\ntypedef struct _MonoMulticastDelegate MonoMulticastDelegate;\nstruct _MonoMulticastDelegate {\n\tMonoDelegate delegate;\n\tMonoMulticastDelegate *prev;\n};\n\nstruct _MonoReflectionField {\n\tMonoObject object;\n\tMonoClass *klass;\n\tMonoClassField *field;\n\tMonoString *name;\n\tMonoReflectionType *type;\n\tguint32 attrs;\n};\n\nstruct _MonoReflectionProperty {\n\tMonoObject object;\n\tMonoClass *klass;\n\tMonoProperty *property;\n};\n\n/*This is System.EventInfo*/\nstruct _MonoReflectionEvent {\n\tMonoObject object;\n\tMonoObject *cached_add_event;\n};\n\ntypedef struct {\n\tMonoReflectionEvent object;\n\tMonoClass *klass;\n\tMonoEvent *event;\n} MonoReflectionMonoEvent;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionType *ClassImpl;\n\tMonoObject *DefaultValueImpl;\n\tMonoObject *MemberImpl;\n\tMonoString *NameImpl;\n\tgint32 PositionImpl;\n\tguint32 AttrsImpl;\n\tMonoObject *MarshalAsImpl;\n} MonoReflectionParameter;\n\nstruct _MonoReflectionMethodBody {\n\tMonoObject object;\n\tMonoArray *clauses;\n\tMonoArray *locals;\n\tMonoArray *il;\n\tMonoBoolean init_locals;\n\tguint32 local_var_sig_token;\n\tguint32 max_stack;\n};\n\nstruct _MonoReflectionAssembly {\n\tMonoObject object;\n\tMonoAssembly *assembly;\n\tMonoObject *resolve_event_holder;\n\t/* CAS related */\n\tMonoObject *evidence;\t/* Evidence */\n\tMonoObject *minimum;\t/* PermissionSet - for SecurityAction.RequestMinimum */\n\tMonoObject *optional;\t/* PermissionSet - for SecurityAction.RequestOptional */\n\tMonoObject *refuse;\t/* PermissionSet - for SecurityAction.RequestRefuse */\n\tMonoObject *granted;\t/* PermissionSet - for the resolved assembly granted permissions */\n\tMonoObject *denied;\t/* PermissionSet - for the resolved assembly denied permissions */\n\t/* */\n\tMonoBoolean from_byte_array;\n\tMonoString *name;\n};\n\ntypedef struct {\n\tMonoReflectionType *utype;\n\tMonoArray *values;\n\tMonoArray *names;\n} MonoEnumInfo;\n\ntypedef struct {\n\tMonoReflectionType *parent;\n\tMonoReflectionType *ret;\n\tguint32 attrs;\n\tguint32 implattrs;\n\tguint32 callconv;\n} MonoMethodInfo;\n\ntypedef struct {\n\tMonoReflectionType *parent;\n\tMonoString *name;\n\tMonoReflectionMethod *get;\n\tMonoReflectionMethod *set;\n\tguint32 attrs;\n} MonoPropertyInfo;\n\ntypedef struct {\n\tMonoReflectionType *declaring_type;\n\tMonoReflectionType *reflected_type;\n\tMonoString *name;\n\tMonoReflectionMethod *add_method;\n\tMonoReflectionMethod *remove_method;\n\tMonoReflectionMethod *raise_method;\n\tguint32 attrs;\n\tMonoArray *other_methods;\n} MonoEventInfo;\n\ntypedef struct {\n\tMonoString *name;\n\tMonoString *name_space;\n\tMonoReflectionType *etype;\n\tMonoReflectionType *nested_in;\n\tMonoReflectionAssembly *assembly;\n\tguint32 rank;\n\tMonoBoolean isprimitive;\n} MonoTypeInfo;\n\ntypedef struct {\n\tMonoObject *member;\n\tgint32 code_pos;\n} MonoReflectionILTokenInfo;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoArray *code;\n\tgint32 code_len;\n\tgint32 max_stack;\n\tgint32 cur_stack;\n\tMonoArray *locals;\n\tMonoArray *ex_handlers;\n\tgint32 num_token_fixups;\n\tMonoArray *token_fixups;\n} MonoReflectionILGen;\n\ntypedef struct {\n\tMonoArray *handlers;\n\tgint32 start;\n\tgint32 len;\n\tgint32 label;\n} MonoILExceptionInfo;\n\ntypedef struct {\n\tMonoObject *extype;\n\tgint32 type;\n\tgint32 start;\n\tgint32 len;\n\tgint32 filter_offset;\n} MonoILExceptionBlock;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoObject *catch_type;\n\tgint32 filter_offset;\n\tgint32 flags;\n\tgint32 try_offset;\n\tgint32 try_length;\n\tgint32 handler_offset;\n\tgint32 handler_length;\n} MonoReflectionExceptionHandlingClause;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionType *local_type;\n\tMonoBoolean is_pinned;\n\tguint16 local_index;\n} MonoReflectionLocalVariableInfo;\n\ntypedef struct {\n\t/*\n\t * Must have the same layout as MonoReflectionLocalVariableInfo, since\n\t * LocalBuilder inherits from it under net 2.0.\n\t */\n\tMonoObject object;\n\tMonoObject *type;\n\tMonoBoolean is_pinned;\n\tguint16 local_index;\n\tMonoString *name;\n} MonoReflectionLocalBuilder;\n\ntypedef struct {\n\tMonoObject object;\n\tgint32 count;\n\tgint32 type;\n\tgint32 eltype;\n\tMonoString *guid;\n\tMonoString *mcookie;\n\tMonoString *marshaltype;\n\tMonoObject *marshaltyperef;\n\tgint32 param_num;\n\tMonoBoolean has_size;\n} MonoReflectionMarshal;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoObject* methodb;\n\tMonoString *name;\n\tMonoArray *cattrs;\n\tMonoReflectionMarshal *marshal_info;\n\tguint32 attrs;\n\tint position;\n\tguint32 table_idx;\n\tMonoObject *def_value;\n} MonoReflectionParamBuilder;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoMethod *mhandle;\n\tMonoReflectionILGen *ilgen;\n\tMonoArray *parameters;\n\tguint32 attrs;\n\tguint32 iattrs;\n\tguint32 table_idx;\n\tguint32 call_conv;\n\tMonoObject *type;\n\tMonoArray *pinfo;\n\tMonoArray *cattrs;\n\tMonoBoolean init_locals;\n\tMonoArray *param_modreq;\n\tMonoArray *param_modopt;\n\tMonoArray *permissions;\n} MonoReflectionCtorBuilder;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoMethod *mhandle;\n\tMonoObject *rtype;\n\tMonoArray *parameters;\n\tguint32 attrs;\n\tguint32 iattrs;\n\tMonoString *name;\n\tguint32 table_idx;\n\tMonoArray *code;\n\tMonoReflectionILGen *ilgen;\n\tMonoObject *type;\n\tMonoArray *pinfo;\n\tMonoArray *cattrs;\n\tMonoReflectionMethod *override_method;\n\tMonoString *dll;\n\tMonoString *dllentry;\n\tguint32 charset;\n\tguint32 extra_flags;\n\tguint32 native_cc;\n\tguint32 call_conv;\n\tMonoBoolean init_locals;\n\tMonoGenericContainer *generic_container;\n\tMonoArray *generic_params;\n\tMonoArray *return_modreq;\n\tMonoArray *return_modopt;\n\tMonoArray *param_modreq;\n\tMonoArray *param_modopt;\n\tMonoArray *permissions;\n} MonoReflectionMethodBuilder;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoMethod *mhandle;\n\tMonoReflectionType *parent;\n\tMonoReflectionType *ret;\n\tMonoArray *parameters;\n\tMonoString *name;\n\tguint32 table_idx;\n\tguint32 call_conv;\n} MonoReflectionArrayMethod;\n\ntypedef struct {\n\tMonoArray *data;\n\tMonoString *name;\n\tMonoString *filename;\n\tguint32 attrs;\n\tguint32 offset;\n\tMonoObject *stream;\n} MonoReflectionResource;\n\ntypedef struct {\n\tguint32 res_type;\n\tguint32 res_id;\n\tguint32 lang_id;\n\tMonoArray *res_data;\n} MonoReflectionWin32Resource;\n\ntypedef struct {\n\tguint32 action;\n\tMonoString *pset;\n} MonoReflectionPermissionSet;\n\ntypedef struct {\n\tMonoReflectionAssembly assembly;\n\tMonoDynamicAssembly *dynamic_assembly;\n\tMonoReflectionMethod *entry_point;\n\tMonoArray *modules;\n\tMonoString *name;\n\tMonoString *dir;\n\tMonoArray *cattrs;\n\tMonoArray *resources;\n\tMonoArray *public_key;\n\tMonoString *version;\n\tMonoString *culture;\n\tguint32 algid;\n\tguint32 flags;\n\tguint32 pekind;\n\tMonoBoolean delay_sign;\n\tguint32 access;\n\tMonoArray *loaded_modules;\n\tMonoArray *win32_resources;\n\t/* CAS related */\n\tMonoArray *permissions_minimum;\n\tMonoArray *permissions_optional;\n\tMonoArray *permissions_refused;\n\tgint32 pe_kind;\n\tgint32 machine;\n\tMonoBoolean corlib_internal;\n\tMonoArray *type_forwarders;\n\tMonoArray *pktoken; /* as hexadecimal byte[] */\n} MonoReflectionAssemblyBuilder;\n\ntypedef struct {\n\tMonoObject object;\n\tguint32 attrs;\n\tMonoObject *type;\n\tMonoString *name;\n\tMonoObject *def_value;\n\tgint32 offset;\n\tgint32 table_idx;\n\tMonoReflectionType *typeb;\n\tMonoArray *rva_data;\n\tMonoArray *cattrs;\n\tMonoReflectionMarshal *marshal_info;\n\tMonoClassField *handle;\n\tMonoArray *modreq;\n\tMonoArray *modopt;\n} MonoReflectionFieldBuilder;\n\ntypedef struct {\n\tMonoObject object;\n\tguint32 attrs;\n\tMonoString *name;\n\tMonoObject *type;\n\tMonoArray *parameters;\n\tMonoArray *cattrs;\n\tMonoObject *def_value;\n\tMonoReflectionMethodBuilder *set_method;\n\tMonoReflectionMethodBuilder *get_method;\n\tgint32 table_idx;\n} MonoReflectionPropertyBuilder;\n\nstruct _MonoReflectionModule {\n\tMonoObject\tobj;\n\tMonoImage  *image;\n\tMonoReflectionAssembly *assembly;\n\tMonoString *fqname;\n\tMonoString *name;\n\tMonoString *scopename;\n\tMonoBoolean is_resource;\n\tguint32 token;\n};\n\ntypedef struct {\n\tMonoReflectionModule module;\n\tMonoDynamicImage *dynamic_image;\n\tgint32     num_types;\n\tMonoArray *types;\n\tMonoArray *cattrs;\n\tMonoArray *guid;\n\tguint32    table_idx;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoArray *global_methods;\n\tMonoArray *global_fields;\n\tgboolean is_main;\n\tMonoArray *resources;\n} MonoReflectionModuleBuilder;\n\ntypedef struct {\n\tMonoReflectionType type;\n\tMonoString *name;\n\tMonoString *nspace;\n\tMonoObject *parent;\n\tMonoReflectionType *nesting_type;\n\tMonoArray *interfaces;\n\tgint32     num_methods;\n\tMonoArray *methods;\n\tMonoArray *ctors;\n\tMonoArray *properties;\n\tgint32     num_fields;\n\tMonoArray *fields;\n\tMonoArray *events;\n\tMonoArray *cattrs;\n\tMonoArray *subtypes;\n\tguint32 attrs;\n\tguint32 table_idx;\n\tMonoReflectionModuleBuilder *module;\n\tgint32 class_size;\n\tgint32 packing_size;\n\tMonoGenericContainer *generic_container;\n\tMonoArray *generic_params;\n\tMonoArray *permissions;\n\tMonoReflectionType *created;\n} MonoReflectionTypeBuilder;\n\ntypedef struct {\n\tMonoReflectionType type;\n\tMonoReflectionType *element_type;\n\tint rank;\n} MonoReflectionArrayType;\n\ntypedef struct {\n\tMonoReflectionType type;\n\tMonoReflectionType *element_type;\n} MonoReflectionDerivedType;\n\ntypedef struct {\n\tMonoReflectionType type;\n\tMonoReflectionTypeBuilder *tbuilder;\n\tMonoReflectionMethodBuilder *mbuilder;\n\tMonoString *name;\n\tguint32 index;\n\tMonoReflectionType *base_type;\n\tMonoArray *iface_constraints;\n\tMonoArray *cattrs;\n\tguint32 attrs;\n} MonoReflectionGenericParam;\n\ntypedef struct _MonoReflectionGenericClass MonoReflectionGenericClass;\nstruct _MonoReflectionGenericClass {\n\tMonoReflectionType type;\n\t/* From System.MonoType */\n\tMonoObject *type_info;\n\tMonoReflectionTypeBuilder *generic_type;\n\tMonoArray *type_arguments;\n\tguint32 initialized;\n};\n\ntypedef struct {\n\tMonoObject  obj;\n\tMonoString *name;\n\tMonoString *codebase;\n\tgint32 major, minor, build, revision;\n\tMonoObject  *cultureInfo;\n\tguint32     flags;\n\tguint32     hashalg;\n\tMonoObject  *keypair;\n\tMonoArray   *publicKey;\n\tMonoArray   *keyToken;\n\tguint32     versioncompat;\n\tMonoObject *version;\n\tguint32     processor_architecture;\n} MonoReflectionAssemblyName;\n\ntypedef struct {\n\tMonoObject  obj;\n\tMonoString *name;\n\tMonoReflectionType *type;\n\tMonoReflectionTypeBuilder *typeb;\n\tMonoArray *cattrs;\n\tMonoReflectionMethodBuilder *add_method;\n\tMonoReflectionMethodBuilder *remove_method;\n\tMonoReflectionMethodBuilder *raise_method;\n\tMonoArray *other_methods;\n\tguint32 attrs;\n\tguint32 table_idx;\n} MonoReflectionEventBuilder;\n\ntypedef struct {\n\tMonoObject  obj;\n\tMonoReflectionMethod *ctor;\n\tMonoArray *data;\n} MonoReflectionCustomAttr;\n\ntypedef struct {\n\tMonoObject object;\n\tgint32 call_conv;\n\tgint32 charset;\n\tMonoString *dll;\n\tMonoString *entry_point;\n\tMonoBoolean exact_spelling;\n\tMonoBoolean preserve_sig;\n\tMonoBoolean set_last_error;\n\tMonoBoolean best_fit_mapping;\n\tMonoBoolean throw_on_unmappable;\n} MonoReflectionDllImportAttribute;\n\ntypedef struct {\n\tMonoObject object;\n\tgint32 call_conv;\n\tgint32 charset;\n\tMonoBoolean set_last_error;\n\tMonoBoolean best_fit_mapping;\n\tMonoBoolean throw_on_unmappable;\n} MonoReflectionUnmanagedFunctionPointerAttribute;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoString *guid;\n} MonoReflectionGuidAttribute;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoMethod *mhandle;\n\tMonoString *name;\n\tMonoReflectionType *rtype;\n\tMonoArray *parameters;\n\tguint32 attrs;\n\tguint32 call_conv;\n\tMonoReflectionModule *module;\n\tMonoBoolean skip_visibility;\n\tMonoBoolean init_locals;\n\tMonoReflectionILGen *ilgen;\n\tgint32 nrefs;\n\tMonoArray *refs;\n\tGSList *referenced_by;\n\tMonoReflectionType *owner;\n} MonoReflectionDynamicMethod;\t\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionModuleBuilder *module;\n\tMonoArray *arguments;\n\tguint32 type;\n\tMonoReflectionType *return_type;\n\tguint32 call_conv;\n\tguint32 unmanaged_call_conv;\n\tMonoArray *modreqs;\n\tMonoArray *modopts;\n} MonoReflectionSigHelper;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionGenericClass *inst;\n\tMonoReflectionFieldBuilder *fb;\n} MonoReflectionFieldOnTypeBuilderInst;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionGenericClass *inst;\n\tMonoReflectionCtorBuilder *cb;\n} MonoReflectionCtorOnTypeBuilderInst;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionGenericClass *inst;\n\tMonoReflectionMethodBuilder *mb;\n\tMonoArray *method_args;\n\tMonoReflectionMethodBuilder *generic_method_definition;\n} MonoReflectionMethodOnTypeBuilderInst;\n\ntypedef struct {\n\tMonoObject object;\n\tMonoBoolean visible;\n} MonoReflectionComVisibleAttribute;\n\nenum {\n\tRESOURCE_LOCATION_EMBEDDED = 1,\n\tRESOURCE_LOCATION_ANOTHER_ASSEMBLY = 2,\n\tRESOURCE_LOCATION_IN_MANIFEST = 4\n};\n\ntypedef struct {\n\tMonoObject object;\n\tMonoReflectionAssembly *assembly;\n\tMonoString *filename;\n\tguint32 location;\n} MonoManifestResourceInfo;\n\n/* A boxed IntPtr */\ntypedef struct {\n\tMonoObject object;\n\tgpointer m_value;\n} MonoIntPtr;\n\n/* Keep in sync with System.GenericParameterAttributes */\ntypedef enum {\n\tGENERIC_PARAMETER_ATTRIBUTE_NON_VARIANT\t\t= 0,\n\tGENERIC_PARAMETER_ATTRIBUTE_COVARIANT\t\t= 1,\n\tGENERIC_PARAMETER_ATTRIBUTE_CONTRAVARIANT\t= 2,\n\tGENERIC_PARAMETER_ATTRIBUTE_VARIANCE_MASK\t= 3,\n\n\tGENERIC_PARAMETER_ATTRIBUTE_NO_SPECIAL_CONSTRAINT\t= 0,\n\tGENERIC_PARAMETER_ATTRIBUTE_REFERENCE_TYPE_CONSTRAINT\t= 4,\n\tGENERIC_PARAMETER_ATTRIBUTE_VALUE_TYPE_CONSTRAINT\t= 8,\n\tGENERIC_PARAMETER_ATTRIBUTE_CONSTRUCTOR_CONSTRAINT\t= 16,\n\tGENERIC_PARAMETER_ATTRIBUTE_SPECIAL_CONSTRAINTS_MASK\t= 28\n} GenericParameterAttributes;\n\ntypedef struct {\n\tMonoType *type;\n\tMonoClassField *field;\n\tMonoProperty *prop;\n} CattrNamedArg;\n\nvoid          mono_image_create_pefile (MonoReflectionModuleBuilder *module, HANDLE file) MONO_INTERNAL;\nvoid          mono_image_basic_init (MonoReflectionAssemblyBuilder *assembly) MONO_INTERNAL;\nMonoReflectionModule * mono_image_load_module_dynamic (MonoReflectionAssemblyBuilder *assembly, MonoString *file_name) MONO_INTERNAL;\nguint32       mono_image_insert_string (MonoReflectionModuleBuilder *module, MonoString *str) MONO_INTERNAL;\nguint32       mono_image_create_token  (MonoDynamicImage *assembly, MonoObject *obj, gboolean create_methodspec, gboolean register_token) MONO_INTERNAL;\nguint32       mono_image_create_method_token (MonoDynamicImage *assembly, MonoObject *obj, MonoArray *opt_param_types) MONO_INTERNAL;\nvoid          mono_image_module_basic_init (MonoReflectionModuleBuilder *module) MONO_INTERNAL;\nvoid          mono_image_register_token (MonoDynamicImage *assembly, guint32 token, MonoObject *obj) MONO_INTERNAL;\nvoid          mono_dynamic_image_free (MonoDynamicImage *image) MONO_INTERNAL;\nvoid          mono_image_set_wrappers_type (MonoReflectionModuleBuilder *mb, MonoReflectionType *type) MONO_INTERNAL;\n\nvoid        mono_reflection_setup_internal_class  (MonoReflectionTypeBuilder *tb) MONO_INTERNAL;\n\nvoid        mono_reflection_create_internal_class (MonoReflectionTypeBuilder *tb) MONO_INTERNAL;\n\nvoid        mono_reflection_setup_generic_class   (MonoReflectionTypeBuilder *tb) MONO_INTERNAL;\n\nvoid        mono_reflection_create_generic_class  (MonoReflectionTypeBuilder *tb) MONO_INTERNAL;\n\nMonoReflectionType* mono_reflection_create_runtime_class  (MonoReflectionTypeBuilder *tb) MONO_INTERNAL;\n\nvoid        mono_reflection_get_dynamic_overrides (MonoClass *klass, MonoMethod ***overrides, int *num_overrides) MONO_INTERNAL;\n\nvoid mono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *m) MONO_INTERNAL;\nvoid mono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb) MONO_INTERNAL;\n\nvoid        mono_reflection_initialize_generic_parameter (MonoReflectionGenericParam *gparam) MONO_INTERNAL;\nvoid        mono_reflection_create_unmanaged_type (MonoReflectionType *type) MONO_INTERNAL;\nvoid        mono_reflection_create_custom_attr_data_args (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len, MonoArray **typed_args, MonoArray **named_args, CattrNamedArg **named_arg_info) MONO_INTERNAL;\n\nMonoArray* mono_param_get_objects_internal  (MonoDomain *domain, MonoMethod *method, MonoClass *refclass) MONO_INTERNAL;\n\nMonoClass*\nmono_class_bind_generic_parameters (MonoClass *klass, int type_argc, MonoType **types, gboolean is_dynamic) MONO_INTERNAL;\nMonoType*\nmono_reflection_bind_generic_parameters (MonoReflectionType *type, int type_argc, MonoType **types) MONO_INTERNAL;\nMonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *method, MonoArray *types) MONO_INTERNAL;\nvoid\nmono_reflection_generic_class_initialize (MonoReflectionGenericClass *type, MonoArray *methods, MonoArray *ctors, MonoArray *fields, MonoArray *properties, MonoArray *events) MONO_INTERNAL;\nMonoReflectionEvent *\nmono_reflection_event_builder_get_event_info (MonoReflectionTypeBuilder *tb, MonoReflectionEventBuilder *eb) MONO_INTERNAL;\n\nMonoArray  *mono_reflection_sighelper_get_signature_local (MonoReflectionSigHelper *sig) MONO_INTERNAL;\n\nMonoArray  *mono_reflection_sighelper_get_signature_field (MonoReflectionSigHelper *sig) MONO_INTERNAL;\n\nMonoReflectionMarshal* mono_reflection_marshal_from_marshal_spec (MonoDomain *domain, MonoClass *klass, MonoMarshalSpec *spec) MONO_INTERNAL;\n\ngpointer\nmono_reflection_lookup_dynamic_token (MonoImage *image, guint32 token, gboolean valid_token, MonoClass **handle_class, MonoGenericContext *context) MONO_INTERNAL;\n\ngboolean\nmono_reflection_call_is_assignable_to (MonoClass *klass, MonoClass *oklass) MONO_INTERNAL;\n\ngboolean\nmono_reflection_is_valid_dynamic_token (MonoDynamicImage *image, guint32 token) MONO_INTERNAL;\n\nMonoType*\nmono_reflection_type_get_handle (MonoReflectionType *ref) MONO_INTERNAL;\n\nvoid\nmono_image_build_metadata (MonoReflectionModuleBuilder *module) MONO_INTERNAL;\n\nint\nmono_get_constant_value_from_blob (MonoDomain* domain, MonoTypeEnum type, const char *blob, void *value) MONO_INTERNAL;\n\nvoid\nmono_release_type_locks (MonoThread *thread) MONO_INTERNAL;\n\nchar *\nmono_string_to_utf8_mp\t(MonoMemPool *mp, MonoString *s, MonoError *error) MONO_INTERNAL;\n\nchar *\nmono_string_to_utf8_image (MonoImage *image, MonoString *s, MonoError *error) MONO_INTERNAL;\n\n\nMonoArray*\nmono_array_clone_in_domain (MonoDomain *domain, MonoArray *array) MONO_INTERNAL;\n\nvoid\nmono_array_full_copy (MonoArray *src, MonoArray *dest) MONO_INTERNAL;\n\ngpointer\nmono_remote_class_vtable (MonoDomain *domain, MonoRemoteClass *remote_class, MonoRealProxy *real_proxy) MONO_INTERNAL;\n\nvoid\nmono_upgrade_remote_class (MonoDomain *domain, MonoObject *tproxy, MonoClass *klass) MONO_INTERNAL;\n\ngpointer\nmono_create_ftnptr (MonoDomain *domain, gpointer addr) MONO_INTERNAL;\n\ngpointer\nmono_get_addr_from_ftnptr (gpointer descr) MONO_INTERNAL;\n\nvoid\nmono_nullable_init (guint8 *buf, MonoObject *value, MonoClass *klass) MONO_INTERNAL;\n\nMonoObject*\nmono_nullable_box (guint8 *buf, MonoClass *klass) MONO_INTERNAL;\n\n#define MONO_IMT_SIZE 19\n\ntypedef union {\n\tint vtable_slot;\n\tgpointer target_code;\n} MonoImtItemValue;\n\ntypedef struct _MonoImtBuilderEntry {\n\tgpointer key;\n\tstruct _MonoImtBuilderEntry *next;\n\tMonoImtItemValue value;\n\tint children;\n\tguint8 has_target_code : 1;\n} MonoImtBuilderEntry;\n\ntypedef struct _MonoIMTCheckItem MonoIMTCheckItem;\n\nstruct _MonoIMTCheckItem {\n\tgpointer          key;\n\tint               check_target_idx;\n\tMonoImtItemValue  value;\n\tguint8           *jmp_code;\n\tguint8           *code_target;\n\tguint8            is_equals;\n\tguint8            compare_done;\n\tguint8            chunk_size;\n\tguint8            short_branch;\n\tguint8            has_target_code;\n};\n\ntypedef gpointer (*MonoImtThunkBuilder) (MonoVTable *vtable, MonoDomain *domain,\n\t\tMonoIMTCheckItem **imt_entries, int count, gpointer fail_trunk);\n\nvoid\nmono_install_imt_thunk_builder (MonoImtThunkBuilder func) MONO_INTERNAL;\n\nvoid\nmono_install_imt_trampoline (gpointer tramp) MONO_INTERNAL;\n\nvoid\nmono_install_vtable_trampoline (gpointer tramp) MONO_INTERNAL;\n\nvoid\nmono_vtable_build_imt_slot (MonoVTable* vtable, int imt_slot) MONO_INTERNAL;\n\nguint32\nmono_method_get_imt_slot (MonoMethod *method) MONO_INTERNAL;\n\nvoid\nmono_method_add_generic_virtual_invocation (MonoDomain *domain, MonoVTable *vtable,\n\t\t\t\t\t\t\t\t\t\t\tgpointer *vtable_slot,\n\t\t\t\t\t\t\t\t\t\t\tMonoMethod *method, gpointer code) MONO_INTERNAL;\n\ngpointer\nmono_method_alloc_generic_virtual_thunk (MonoDomain *domain, int size) MONO_INTERNAL;\n\ntypedef enum {\n\tMONO_UNHANDLED_POLICY_LEGACY,\n\tMONO_UNHANDLED_POLICY_CURRENT\n} MonoRuntimeUnhandledExceptionPolicy;\n\nMonoRuntimeUnhandledExceptionPolicy\nmono_runtime_unhandled_exception_policy_get (void) MONO_INTERNAL;\nvoid\nmono_runtime_unhandled_exception_policy_set (MonoRuntimeUnhandledExceptionPolicy policy) MONO_INTERNAL;\n\nMonoVTable *\nmono_class_try_get_vtable (MonoDomain *domain, MonoClass *class) MONO_INTERNAL;\n\nMonoException *\nmono_runtime_class_init_full (MonoVTable *vtable, gboolean raise_exception) MONO_INTERNAL;\n\nvoid\nmono_method_clear_object (MonoDomain *domain, MonoMethod *method) MONO_INTERNAL;\n\nvoid\nmono_class_compute_gc_descriptor (MonoClass *class) MONO_INTERNAL;\n\nchar *\nmono_string_to_utf8_checked (MonoString *s, MonoError *error) MONO_INTERNAL;\n\ngboolean\nmono_class_is_reflection_method_or_constructor (MonoClass *class) MONO_INTERNAL;\n\nvoid\nmono_reflection_shutdown (void) MONO_INTERNAL;\n\n#endif /* __MONO_OBJECT_INTERNALS_H__ */\n\n\n", "/*\n * reflection.c: Routines for creating an image at runtime.\n * \n * Author:\n *   Paolo Molaro (lupus@ximian.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n *\n */\n#include <config.h>\n#include \"mono/utils/mono-digest.h\"\n#include \"mono/utils/mono-membar.h\"\n#include \"mono/metadata/reflection.h\"\n#include \"mono/metadata/tabledefs.h\"\n#include \"mono/metadata/metadata-internals.h\"\n#include <mono/metadata/profiler-private.h>\n#include \"mono/metadata/class-internals.h\"\n#include \"mono/metadata/gc-internal.h\"\n#include \"mono/metadata/tokentype.h\"\n#include \"mono/metadata/domain-internals.h\"\n#include \"mono/metadata/opcodes.h\"\n#include \"mono/metadata/assembly.h\"\n#include \"mono/metadata/object-internals.h\"\n#include <mono/metadata/exception.h>\n#include <mono/metadata/marshal.h>\n#include <mono/metadata/security-manager.h>\n#include <stdio.h>\n#include <glib.h>\n#include <errno.h>\n#include <time.h>\n#include <string.h>\n#include <ctype.h>\n#include \"image.h\"\n#include \"cil-coff.h\"\n#include \"mono-endian.h\"\n#include <mono/metadata/gc-internal.h>\n#include <mono/metadata/mempool-internals.h>\n#include <mono/metadata/security-core-clr.h>\n#include <mono/metadata/debug-helpers.h>\n#include <mono/utils/mono-string.h>\n#include <mono/utils/mono-error-internals.h>\n\n\n#if HAVE_SGEN_GC\nstatic void* reflection_info_desc = NULL;\n#define MOVING_GC_REGISTER(addr) do {\t\\\n\t\tif (!reflection_info_desc) {\t\\\n\t\t\tgsize bmap = 1;\t\t\\\n\t\t\treflection_info_desc = mono_gc_make_descr_from_bitmap (&bmap, 1);\t\\\n\t\t}\t\\\n\t\tmono_gc_register_root ((char*)(addr), sizeof (gpointer), reflection_info_desc); \\\n\t} while (0)\n#else\n#define MOVING_GC_REGISTER(addr)\n#endif\n\ntypedef struct {\n\tchar *p;\n\tchar *buf;\n\tchar *end;\n} SigBuffer;\n\n#define TEXT_OFFSET 512\n#define CLI_H_SIZE 136\n#define FILE_ALIGN 512\n#define VIRT_ALIGN 8192\n#define START_TEXT_RVA  0x00002000\n\ntypedef struct {\n\tMonoReflectionILGen *ilgen;\n\tMonoReflectionType *rtype;\n\tMonoArray *parameters;\n\tMonoArray *generic_params;\n\tMonoGenericContainer *generic_container;\n\tMonoArray *pinfo;\n\tMonoArray *opt_types;\n\tguint32 attrs;\n\tguint32 iattrs;\n\tguint32 call_conv;\n\tguint32 *table_idx; /* note: it's a pointer */\n\tMonoArray *code;\n\tMonoObject *type;\n\tMonoString *name;\n\tMonoBoolean init_locals;\n\tMonoBoolean skip_visibility;\n\tMonoArray *return_modreq;\n\tMonoArray *return_modopt;\n\tMonoArray *param_modreq;\n\tMonoArray *param_modopt;\n\tMonoArray *permissions;\n\tMonoMethod *mhandle;\n\tguint32 nrefs;\n\tgpointer *refs;\n\t/* for PInvoke */\n\tint charset, extra_flags, native_cc;\n\tMonoString *dll, *dllentry;\n} ReflectionMethodBuilder;\n\ntypedef struct {\n\tguint32 owner;\n\tMonoReflectionGenericParam *gparam;\n} GenericParamTableEntry;\n\nconst unsigned char table_sizes [MONO_TABLE_NUM] = {\n\tMONO_MODULE_SIZE,\n\tMONO_TYPEREF_SIZE,\n\tMONO_TYPEDEF_SIZE,\n\t0,\n\tMONO_FIELD_SIZE,\n\t0,\n\tMONO_METHOD_SIZE,\n\t0,\n\tMONO_PARAM_SIZE,\n\tMONO_INTERFACEIMPL_SIZE,\n\tMONO_MEMBERREF_SIZE,\t/* 0x0A */\n\tMONO_CONSTANT_SIZE,\n\tMONO_CUSTOM_ATTR_SIZE,\n\tMONO_FIELD_MARSHAL_SIZE,\n\tMONO_DECL_SECURITY_SIZE,\n\tMONO_CLASS_LAYOUT_SIZE,\n\tMONO_FIELD_LAYOUT_SIZE,\t/* 0x10 */\n\tMONO_STAND_ALONE_SIGNATURE_SIZE,\n\tMONO_EVENT_MAP_SIZE,\n\t0,\n\tMONO_EVENT_SIZE,\n\tMONO_PROPERTY_MAP_SIZE,\n\t0,\n\tMONO_PROPERTY_SIZE,\n\tMONO_METHOD_SEMA_SIZE,\n\tMONO_METHODIMPL_SIZE,\n\tMONO_MODULEREF_SIZE,\t/* 0x1A */\n\tMONO_TYPESPEC_SIZE,\n\tMONO_IMPLMAP_SIZE,\t\n\tMONO_FIELD_RVA_SIZE,\n\t0,\n\t0,\n\tMONO_ASSEMBLY_SIZE,\t/* 0x20 */\n\tMONO_ASSEMBLY_PROCESSOR_SIZE,\n\tMONO_ASSEMBLYOS_SIZE,\n\tMONO_ASSEMBLYREF_SIZE,\n\tMONO_ASSEMBLYREFPROC_SIZE,\n\tMONO_ASSEMBLYREFOS_SIZE,\n\tMONO_FILE_SIZE,\n\tMONO_EXP_TYPE_SIZE,\n\tMONO_MANIFEST_SIZE,\n\tMONO_NESTED_CLASS_SIZE,\n\n\tMONO_GENERICPARAM_SIZE,\t/* 0x2A */\n\tMONO_METHODSPEC_SIZE,\n\tMONO_GENPARCONSTRAINT_SIZE\n\n};\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32 mono_image_get_methodref_token (MonoDynamicImage *assembly, MonoMethod *method, gboolean create_typespec);\nstatic guint32 mono_image_get_methodbuilder_token (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb, gboolean create_methodspec);\nstatic guint32 mono_image_get_ctorbuilder_token (MonoDynamicImage *assembly, MonoReflectionCtorBuilder *cb);\nstatic guint32 mono_image_get_sighelper_token (MonoDynamicImage *assembly, MonoReflectionSigHelper *helper);\nstatic void    ensure_runtime_vtable (MonoClass *klass);\nstatic gpointer resolve_object (MonoImage *image, MonoObject *obj, MonoClass **handle_class, MonoGenericContext *context);\nstatic guint32 mono_image_get_methodref_token_for_methodbuilder (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *method);\nstatic guint32 encode_generic_method_sig (MonoDynamicImage *assembly, MonoGenericContext *context);\nstatic gpointer register_assembly (MonoDomain *domain, MonoReflectionAssembly *res, MonoAssembly *assembly);\nstatic void reflection_methodbuilder_from_method_builder (ReflectionMethodBuilder *rmb, MonoReflectionMethodBuilder *mb);\nstatic void reflection_methodbuilder_from_ctor_builder (ReflectionMethodBuilder *rmb, MonoReflectionCtorBuilder *mb);\n#endif\n\nstatic guint32 mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type);\nstatic guint32 mono_image_typedef_or_ref_full (MonoDynamicImage *assembly, MonoType *type, gboolean try_typespec);\nstatic void    mono_image_get_generic_param_info (MonoReflectionGenericParam *gparam, guint32 owner, MonoDynamicImage *assembly);\nstatic guint32 encode_marshal_blob (MonoDynamicImage *assembly, MonoReflectionMarshal *minfo);\nstatic guint32 encode_constant (MonoDynamicImage *assembly, MonoObject *val, guint32 *ret_type);\nstatic char*   type_get_qualified_name (MonoType *type, MonoAssembly *ass);\nstatic void    encode_type (MonoDynamicImage *assembly, MonoType *type, SigBuffer *buf);\nstatic void get_default_param_value_blobs (MonoMethod *method, char **blobs, guint32 *types);\nstatic MonoObject *mono_get_object_from_blob (MonoDomain *domain, MonoType *type, const char *blob);\nstatic MonoReflectionType *mono_reflection_type_get_underlying_system_type (MonoReflectionType* t);\nstatic MonoType* mono_reflection_get_type_with_rootimage (MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean *type_resolve);\nstatic MonoReflectionType* mono_reflection_type_resolve_user_types (MonoReflectionType *type);\nstatic gboolean is_sre_array (MonoClass *class);\nstatic gboolean is_sre_byref (MonoClass *class);\nstatic gboolean is_sre_pointer (MonoClass *class);\nstatic gboolean is_sre_method_builder (MonoClass *class);\nstatic gboolean is_sre_ctor_builder (MonoClass *class);\nstatic gboolean is_sr_mono_method (MonoClass *class);\nstatic gboolean is_sr_mono_cmethod (MonoClass *class);\nstatic gboolean is_sr_mono_generic_method (MonoClass *class);\nstatic gboolean is_sr_mono_generic_cmethod (MonoClass *class);\nstatic gboolean is_sr_mono_field (MonoClass *class);\nstatic gboolean is_sr_mono_property (MonoClass *class);\nstatic gboolean is_sre_method_on_tb_inst (MonoClass *class);\nstatic gboolean is_sre_ctor_on_tb_inst (MonoClass *class);\n\nstatic guint32 mono_image_get_methodspec_token (MonoDynamicImage *assembly, MonoMethod *method);\nstatic guint32 mono_image_get_inflated_method_token (MonoDynamicImage *assembly, MonoMethod *m);\nstatic MonoMethod * inflate_method (MonoReflectionGenericClass *type, MonoObject *obj);\n\n#define RESOLVE_TYPE(type) do { type = (void*)mono_reflection_type_resolve_user_types ((MonoReflectionType*)type); } while (0)\n#define RESOLVE_ARRAY_TYPE_ELEMENT(array, index) do {\t\\\n\tMonoReflectionType *__type = mono_array_get (array, MonoReflectionType*, index);\t\\\n\t__type = mono_reflection_type_resolve_user_types (__type);\t\\\n\tmono_array_set (arr, MonoReflectionType*, index, __type);\t\\\n} while (0)\n\n#define mono_type_array_get_and_resolve(array, index) mono_reflection_type_get_handle ((MonoReflectionType*)mono_array_get (array, gpointer, index))\n\nvoid\nmono_reflection_init (void)\n{\n}\n\nstatic void\nsigbuffer_init (SigBuffer *buf, int size)\n{\n\tbuf->buf = g_malloc (size);\n\tbuf->p = buf->buf;\n\tbuf->end = buf->buf + size;\n}\n\nstatic void\nsigbuffer_make_room (SigBuffer *buf, int size)\n{\n\tif (buf->end - buf->p < size) {\n\t\tint new_size = buf->end - buf->buf + size + 32;\n\t\tchar *p = g_realloc (buf->buf, new_size);\n\t\tsize = buf->p - buf->buf;\n\t\tbuf->buf = p;\n\t\tbuf->p = p + size;\n\t\tbuf->end = buf->buf + new_size;\n\t}\n}\n\nstatic void\nsigbuffer_add_value (SigBuffer *buf, guint32 val)\n{\n\tsigbuffer_make_room (buf, 6);\n\tmono_metadata_encode_value (val, buf->p, &buf->p);\n}\n\nstatic void\nsigbuffer_add_byte (SigBuffer *buf, guint8 val)\n{\n\tsigbuffer_make_room (buf, 1);\n\tbuf->p [0] = val;\n\tbuf->p++;\n}\n\nstatic void\nsigbuffer_add_mem (SigBuffer *buf, char *p, guint32 size)\n{\n\tsigbuffer_make_room (buf, size);\n\tmemcpy (buf->p, p, size);\n\tbuf->p += size;\n}\n\nstatic void\nsigbuffer_free (SigBuffer *buf)\n{\n\tg_free (buf->buf);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/**\n * mp_g_alloc:\n *\n * Allocate memory from the @image mempool if it is non-NULL. Otherwise, allocate memory\n * from the C heap.\n */\nstatic gpointer\nimage_g_malloc (MonoImage *image, guint size)\n{\n\tif (image)\n\t\treturn mono_image_alloc (image, size);\n\telse\n\t\treturn g_malloc (size);\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\n/**\n * image_g_alloc0:\n *\n * Allocate memory from the @image mempool if it is non-NULL. Otherwise, allocate memory\n * from the C heap.\n */\nstatic gpointer\nimage_g_malloc0 (MonoImage *image, guint size)\n{\n\tif (image)\n\t\treturn mono_image_alloc0 (image, size);\n\telse\n\t\treturn g_malloc0 (size);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic char*\nimage_strdup (MonoImage *image, const char *s)\n{\n\tif (image)\n\t\treturn mono_image_strdup (image, s);\n\telse\n\t\treturn g_strdup (s);\n}\n#endif\n\n#define image_g_new(image,struct_type, n_structs)\t\t\\\n    ((struct_type *) image_g_malloc (image, ((gsize) sizeof (struct_type)) * ((gsize) (n_structs))))\n\n#define image_g_new0(image,struct_type, n_structs)\t\t\\\n    ((struct_type *) image_g_malloc0 (image, ((gsize) sizeof (struct_type)) * ((gsize) (n_structs))))\n\n\nstatic void\nalloc_table (MonoDynamicTable *table, guint nrows)\n{\n\ttable->rows = nrows;\n\tg_assert (table->columns);\n\tif (nrows + 1 >= table->alloc_rows) {\n\t\twhile (nrows + 1 >= table->alloc_rows) {\n\t\t\tif (table->alloc_rows == 0)\n\t\t\t\ttable->alloc_rows = 16;\n\t\t\telse\n\t\t\t\ttable->alloc_rows *= 2;\n\t\t}\n\n\t\ttable->values = g_renew (guint32, table->values, (table->alloc_rows) * table->columns);\n\t}\n}\n\nstatic void\nmake_room_in_stream (MonoDynamicStream *stream, int size)\n{\n\tif (size <= stream->alloc_size)\n\t\treturn;\n\t\n\twhile (stream->alloc_size <= size) {\n\t\tif (stream->alloc_size < 4096)\n\t\t\tstream->alloc_size = 4096;\n\t\telse\n\t\t\tstream->alloc_size *= 2;\n\t}\n\t\n\tstream->data = g_realloc (stream->data, stream->alloc_size);\n}\n\nstatic guint32\nstring_heap_insert (MonoDynamicStream *sh, const char *str)\n{\n\tguint32 idx;\n\tguint32 len;\n\tgpointer oldkey, oldval;\n\n\tif (g_hash_table_lookup_extended (sh->hash, str, &oldkey, &oldval))\n\t\treturn GPOINTER_TO_UINT (oldval);\n\n\tlen = strlen (str) + 1;\n\tidx = sh->index;\n\t\n\tmake_room_in_stream (sh, idx + len);\n\n\t/*\n\t * We strdup the string even if we already copy them in sh->data\n\t * so that the string pointers in the hash remain valid even if\n\t * we need to realloc sh->data. We may want to avoid that later.\n\t */\n\tg_hash_table_insert (sh->hash, g_strdup (str), GUINT_TO_POINTER (idx));\n\tmemcpy (sh->data + idx, str, len);\n\tsh->index += len;\n\treturn idx;\n}\n\nstatic guint32\nstring_heap_insert_mstring (MonoDynamicStream *sh, MonoString *str)\n{\n\tchar *name = mono_string_to_utf8 (str);\n\tguint32 idx;\n\tidx = string_heap_insert (sh, name);\n\tg_free (name);\n\treturn idx;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nstring_heap_init (MonoDynamicStream *sh)\n{\n\tsh->index = 0;\n\tsh->alloc_size = 4096;\n\tsh->data = g_malloc (4096);\n\tsh->hash = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n\tstring_heap_insert (sh, \"\");\n}\n#endif\n\nstatic guint32\nmono_image_add_stream_data (MonoDynamicStream *stream, const char *data, guint32 len)\n{\n\tguint32 idx;\n\t\n\tmake_room_in_stream (stream, stream->index + len);\n\tmemcpy (stream->data + stream->index, data, len);\n\tidx = stream->index;\n\tstream->index += len;\n\t/* \n\t * align index? Not without adding an additional param that controls it since\n\t * we may store a blob value in pieces.\n\t */\n\treturn idx;\n}\n\nstatic guint32\nmono_image_add_stream_zero (MonoDynamicStream *stream, guint32 len)\n{\n\tguint32 idx;\n\t\n\tmake_room_in_stream (stream, stream->index + len);\n\tmemset (stream->data + stream->index, 0, len);\n\tidx = stream->index;\n\tstream->index += len;\n\treturn idx;\n}\n\nstatic void\nstream_data_align (MonoDynamicStream *stream)\n{\n\tchar buf [4] = {0};\n\tguint32 count = stream->index % 4;\n\n\t/* we assume the stream data will be aligned */\n\tif (count)\n\t\tmono_image_add_stream_data (stream, buf, 4 - count);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic int\nmono_blob_entry_hash (const char* str)\n{\n\tguint len, h;\n\tconst char *end;\n\tlen = mono_metadata_decode_blob_size (str, &str);\n\tif (len > 0) {\n\t\tend = str + len;\n\t\th = *str;\n\t\tfor (str += 1; str < end; str++)\n\t\t\th = (h << 5) - h + *str;\n\t\treturn h;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nstatic gboolean\nmono_blob_entry_equal (const char *str1, const char *str2) {\n\tint len, len2;\n\tconst char *end1;\n\tconst char *end2;\n\tlen = mono_metadata_decode_blob_size (str1, &end1);\n\tlen2 = mono_metadata_decode_blob_size (str2, &end2);\n\tif (len != len2)\n\t\treturn 0;\n\treturn memcmp (end1, end2, len) == 0;\n}\n#endif\nstatic guint32\nadd_to_blob_cached (MonoDynamicImage *assembly, char *b1, int s1, char *b2, int s2)\n{\n\tguint32 idx;\n\tchar *copy;\n\tgpointer oldkey, oldval;\n\n\tcopy = g_malloc (s1+s2);\n\tmemcpy (copy, b1, s1);\n\tmemcpy (copy + s1, b2, s2);\n\tif (g_hash_table_lookup_extended (assembly->blob_cache, copy, &oldkey, &oldval)) {\n\t\tg_free (copy);\n\t\tidx = GPOINTER_TO_UINT (oldval);\n\t} else {\n\t\tidx = mono_image_add_stream_data (&assembly->blob, b1, s1);\n\t\tmono_image_add_stream_data (&assembly->blob, b2, s2);\n\t\tg_hash_table_insert (assembly->blob_cache, copy, GUINT_TO_POINTER (idx));\n\t}\n\treturn idx;\n}\n\nstatic guint32\nsigbuffer_add_to_blob_cached (MonoDynamicImage *assembly, SigBuffer *buf)\n{\n\tchar blob_size [8];\n\tchar *b = blob_size;\n\tguint32 size = buf->p - buf->buf;\n\t/* store length */\n\tg_assert (size <= (buf->end - buf->buf));\n\tmono_metadata_encode_value (size, b, &b);\n\treturn add_to_blob_cached (assembly, blob_size, b-blob_size, buf->buf, size);\n}\n\n/*\n * Copy len * nelem bytes from val to dest, swapping bytes to LE if necessary.\n * dest may be misaligned.\n */\nstatic void\nswap_with_size (char *dest, const char* val, int len, int nelem) {\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\tint elem;\n\n\tfor (elem = 0; elem < nelem; ++elem) {\n\t\tswitch (len) {\n\t\tcase 1:\n\t\t\t*dest = *val;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdest [0] = val [1];\n\t\t\tdest [1] = val [0];\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdest [0] = val [3];\n\t\t\tdest [1] = val [2];\n\t\t\tdest [2] = val [1];\n\t\t\tdest [3] = val [0];\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tdest [0] = val [7];\n\t\t\tdest [1] = val [6];\n\t\t\tdest [2] = val [5];\n\t\t\tdest [3] = val [4];\n\t\t\tdest [4] = val [3];\n\t\t\tdest [5] = val [2];\n\t\t\tdest [6] = val [1];\n\t\t\tdest [7] = val [0];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t\tdest += len;\n\t\tval += len;\n\t}\n#else\n\tmemcpy (dest, val, len * nelem);\n#endif\n}\n\nstatic guint32\nadd_mono_string_to_blob_cached (MonoDynamicImage *assembly, MonoString *str)\n{\n\tchar blob_size [64];\n\tchar *b = blob_size;\n\tguint32 idx = 0, len;\n\n\tlen = str->length * 2;\n\tmono_metadata_encode_value (len, b, &b);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\t{\n\t\tchar *swapped = g_malloc (2 * mono_string_length (str));\n\t\tconst char *p = (const char*)mono_string_chars (str);\n\n\t\tswap_with_size (swapped, p, 2, mono_string_length (str));\n\t\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, swapped, len);\n\t\tg_free (swapped);\n\t}\n#else\n\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, (char*)mono_string_chars (str), len);\n#endif\n\treturn idx;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic MonoClass *\ndefault_class_from_mono_type (MonoType *type)\n{\n\tswitch (type->type) {\n\tcase MONO_TYPE_OBJECT:\n\t\treturn mono_defaults.object_class;\n\tcase MONO_TYPE_VOID:\n\t\treturn mono_defaults.void_class;\n\tcase MONO_TYPE_BOOLEAN:\n\t\treturn mono_defaults.boolean_class;\n\tcase MONO_TYPE_CHAR:\n\t\treturn mono_defaults.char_class;\n\tcase MONO_TYPE_I1:\n\t\treturn mono_defaults.sbyte_class;\n\tcase MONO_TYPE_U1:\n\t\treturn mono_defaults.byte_class;\n\tcase MONO_TYPE_I2:\n\t\treturn mono_defaults.int16_class;\n\tcase MONO_TYPE_U2:\n\t\treturn mono_defaults.uint16_class;\n\tcase MONO_TYPE_I4:\n\t\treturn mono_defaults.int32_class;\n\tcase MONO_TYPE_U4:\n\t\treturn mono_defaults.uint32_class;\n\tcase MONO_TYPE_I:\n\t\treturn mono_defaults.int_class;\n\tcase MONO_TYPE_U:\n\t\treturn mono_defaults.uint_class;\n\tcase MONO_TYPE_I8:\n\t\treturn mono_defaults.int64_class;\n\tcase MONO_TYPE_U8:\n\t\treturn mono_defaults.uint64_class;\n\tcase MONO_TYPE_R4:\n\t\treturn mono_defaults.single_class;\n\tcase MONO_TYPE_R8:\n\t\treturn mono_defaults.double_class;\n\tcase MONO_TYPE_STRING:\n\t\treturn mono_defaults.string_class;\n\tdefault:\n\t\tg_warning (\"default_class_from_mono_type: implement me 0x%02x\\n\", type->type);\n\t\tg_assert_not_reached ();\n\t}\n\t\n\treturn NULL;\n}\n#endif\n\nstatic void\nencode_generic_class (MonoDynamicImage *assembly, MonoGenericClass *gclass, SigBuffer *buf)\n{\n\tint i;\n\tMonoGenericInst *class_inst;\n\tMonoClass *klass;\n\n\tg_assert (gclass);\n\n\tclass_inst = gclass->context.class_inst;\n\n\tsigbuffer_add_value (buf, MONO_TYPE_GENERICINST);\n\tklass = gclass->container_class;\n\tsigbuffer_add_value (buf, klass->byval_arg.type);\n\tsigbuffer_add_value (buf, mono_image_typedef_or_ref_full (assembly, &klass->byval_arg, FALSE));\n\n\tsigbuffer_add_value (buf, class_inst->type_argc);\n\tfor (i = 0; i < class_inst->type_argc; ++i)\n\t\tencode_type (assembly, class_inst->type_argv [i], buf);\n\n}\n\nstatic void\nencode_type (MonoDynamicImage *assembly, MonoType *type, SigBuffer *buf)\n{\n\tif (!type) {\n\t\tg_assert_not_reached ();\n\t\treturn;\n\t}\n\t\t\n\tif (type->byref)\n\t\tsigbuffer_add_value (buf, MONO_TYPE_BYREF);\n\n\tswitch (type->type){\n\tcase MONO_TYPE_VOID:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tbreak;\n\tcase MONO_TYPE_PTR:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tencode_type (assembly, type->data.type, buf);\n\t\tbreak;\n\tcase MONO_TYPE_SZARRAY:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tencode_type (assembly, &type->data.klass->byval_arg, buf);\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS: {\n\t\tMonoClass *k = mono_class_from_mono_type (type);\n\n\t\tif (k->generic_container) {\n\t\t\tMonoGenericClass *gclass = mono_metadata_lookup_generic_class (k, k->generic_container->context.class_inst, TRUE);\n\t\t\tencode_generic_class (assembly, gclass, buf);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make sure we use the correct type.\n\t\t\t */\n\t\t\tsigbuffer_add_value (buf, k->byval_arg.type);\n\t\t\t/*\n\t\t\t * ensure only non-byref gets passed to mono_image_typedef_or_ref(),\n\t\t\t * otherwise two typerefs could point to the same type, leading to\n\t\t\t * verification errors.\n\t\t\t */\n\t\t\tsigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, &k->byval_arg));\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_ARRAY:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tencode_type (assembly, &type->data.array->eklass->byval_arg, buf);\n\t\tsigbuffer_add_value (buf, type->data.array->rank);\n\t\tsigbuffer_add_value (buf, 0); /* FIXME: set to 0 for now */\n\t\tsigbuffer_add_value (buf, 0);\n\t\tbreak;\n\tcase MONO_TYPE_GENERICINST:\n\t\tencode_generic_class (assembly, type->data.generic_class, buf);\n\t\tbreak;\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\tsigbuffer_add_value (buf, type->type);\n\t\tsigbuffer_add_value (buf, mono_type_get_generic_param_num (type));\n\t\tbreak;\n\tdefault:\n\t\tg_error (\"need to encode type %x\", type->type);\n\t}\n}\n\nstatic void\nencode_reflection_type (MonoDynamicImage *assembly, MonoReflectionType *type, SigBuffer *buf)\n{\n\tif (!type) {\n\t\tsigbuffer_add_value (buf, MONO_TYPE_VOID);\n\t\treturn;\n\t}\n\n\tencode_type (assembly, mono_reflection_type_get_handle (type), buf);\n}\n\nstatic void\nencode_custom_modifiers (MonoDynamicImage *assembly, MonoArray *modreq, MonoArray *modopt, SigBuffer *buf)\n{\n\tint i;\n\n\tif (modreq) {\n\t\tfor (i = 0; i < mono_array_length (modreq); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modreq, i);\n\t\t\tsigbuffer_add_byte (buf, MONO_TYPE_CMOD_REQD);\n\t\t\tsigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, mod));\n\t\t}\n\t}\n\tif (modopt) {\n\t\tfor (i = 0; i < mono_array_length (modopt); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modopt, i);\n\t\t\tsigbuffer_add_byte (buf, MONO_TYPE_CMOD_OPT);\n\t\t\tsigbuffer_add_value (buf, mono_image_typedef_or_ref (assembly, mod));\n\t\t}\n\t}\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32\nmethod_encode_signature (MonoDynamicImage *assembly, MonoMethodSignature *sig)\n{\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams =  sig->param_count;\n\tguint32 idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\t/*\n\t * FIXME: vararg, explicit_this, differenc call_conv values...\n\t */\n\tidx = sig->call_convention;\n\tif (sig->hasthis)\n\t\tidx |= 0x20; /* hasthis */\n\tif (sig->generic_param_count)\n\t\tidx |= 0x10; /* generic */\n\tsigbuffer_add_byte (&buf, idx);\n\tif (sig->generic_param_count)\n\t\tsigbuffer_add_value (&buf, sig->generic_param_count);\n\tsigbuffer_add_value (&buf, nparams);\n\tencode_type (assembly, sig->ret, &buf);\n\tfor (i = 0; i < nparams; ++i) {\n\t\tif (i == sig->sentinelpos)\n\t\t\tsigbuffer_add_byte (&buf, MONO_TYPE_SENTINEL);\n\t\tencode_type (assembly, sig->params [i], &buf);\n\t}\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n#endif\n\nstatic guint32\nmethod_builder_encode_signature (MonoDynamicImage *assembly, ReflectionMethodBuilder *mb)\n{\n\t/*\n\t * FIXME: reuse code from method_encode_signature().\n\t */\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams =  mb->parameters ? mono_array_length (mb->parameters): 0;\n\tguint32 ngparams = mb->generic_params ? mono_array_length (mb->generic_params): 0;\n\tguint32 notypes = mb->opt_types ? mono_array_length (mb->opt_types): 0;\n\tguint32 idx;\n\n\tsigbuffer_init (&buf, 32);\n\t/* LAMESPEC: all the call conv spec is foobared */\n\tidx = mb->call_conv & 0x60; /* has-this, explicit-this */\n\tif (mb->call_conv & 2)\n\t\tidx |= 0x5; /* vararg */\n\tif (!(mb->attrs & METHOD_ATTRIBUTE_STATIC))\n\t\tidx |= 0x20; /* hasthis */\n\tif (ngparams)\n\t\tidx |= 0x10; /* generic */\n\tsigbuffer_add_byte (&buf, idx);\n\tif (ngparams)\n\t\tsigbuffer_add_value (&buf, ngparams);\n\tsigbuffer_add_value (&buf, nparams + notypes);\n\tencode_custom_modifiers (assembly, mb->return_modreq, mb->return_modopt, &buf);\n\tencode_reflection_type (assembly, mb->rtype, &buf);\n\tfor (i = 0; i < nparams; ++i) {\n\t\tMonoArray *modreq = NULL;\n\t\tMonoArray *modopt = NULL;\n\t\tMonoReflectionType *pt;\n\n\t\tif (mb->param_modreq && (i < mono_array_length (mb->param_modreq)))\n\t\t\tmodreq = mono_array_get (mb->param_modreq, MonoArray*, i);\n\t\tif (mb->param_modopt && (i < mono_array_length (mb->param_modopt)))\n\t\t\tmodopt = mono_array_get (mb->param_modopt, MonoArray*, i);\n\t\tencode_custom_modifiers (assembly, modreq, modopt, &buf);\n\t\tpt = mono_array_get (mb->parameters, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, pt, &buf);\n\t}\n\tif (notypes)\n\t\tsigbuffer_add_byte (&buf, MONO_TYPE_SENTINEL);\n\tfor (i = 0; i < notypes; ++i) {\n\t\tMonoReflectionType *pt;\n\n\t\tpt = mono_array_get (mb->opt_types, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, pt, &buf);\n\t}\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nencode_locals (MonoDynamicImage *assembly, MonoReflectionILGen *ilgen)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 idx, sig_idx;\n\tguint nl = mono_array_length (ilgen->locals);\n\tSigBuffer buf;\n\tint i;\n\n\tsigbuffer_init (&buf, 32);\n\tsigbuffer_add_value (&buf, 0x07);\n\tsigbuffer_add_value (&buf, nl);\n\tfor (i = 0; i < nl; ++i) {\n\t\tMonoReflectionLocalBuilder *lb = mono_array_get (ilgen->locals, MonoReflectionLocalBuilder*, i);\n\t\t\n\t\tif (lb->is_pinned)\n\t\t\tsigbuffer_add_value (&buf, MONO_TYPE_PINNED);\n\t\t\n\t\tencode_reflection_type (assembly, (MonoReflectionType*)lb->type, &buf);\n\t}\n\tsig_idx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\n\tif (assembly->standalonesig_cache == NULL)\n\t\tassembly->standalonesig_cache = g_hash_table_new (NULL, NULL);\n\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->standalonesig_cache, GUINT_TO_POINTER (sig_idx)));\n\tif (idx)\n\t\treturn idx;\n\n\ttable = &assembly->tables [MONO_TABLE_STANDALONESIG];\n\tidx = table->next_idx ++;\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + idx * MONO_STAND_ALONE_SIGNATURE_SIZE;\n\n\tvalues [MONO_STAND_ALONE_SIGNATURE] = sig_idx;\n\n\tg_hash_table_insert (assembly->standalonesig_cache, GUINT_TO_POINTER (sig_idx), GUINT_TO_POINTER (idx));\n\n\treturn idx;\n}\n\nstatic guint32\nmethod_count_clauses (MonoReflectionILGen *ilgen)\n{\n\tguint32 num_clauses = 0;\n\tint i;\n\n\tMonoILExceptionInfo *ex_info;\n\tfor (i = 0; i < mono_array_length (ilgen->ex_handlers); ++i) {\n\t\tex_info = (MonoILExceptionInfo*)mono_array_addr (ilgen->ex_handlers, MonoILExceptionInfo, i);\n\t\tif (ex_info->handlers)\n\t\t\tnum_clauses += mono_array_length (ex_info->handlers);\n\t\telse\n\t\t\tnum_clauses++;\n\t}\n\n\treturn num_clauses;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic MonoExceptionClause*\nmethod_encode_clauses (MonoImage *image, MonoDynamicImage *assembly, MonoReflectionILGen *ilgen, guint32 num_clauses)\n{\n\tMonoExceptionClause *clauses;\n\tMonoExceptionClause *clause;\n\tMonoILExceptionInfo *ex_info;\n\tMonoILExceptionBlock *ex_block;\n\tguint32 finally_start;\n\tint i, j, clause_index;;\n\n\tclauses = image_g_new0 (image, MonoExceptionClause, num_clauses);\n\n\tclause_index = 0;\n\tfor (i = mono_array_length (ilgen->ex_handlers) - 1; i >= 0; --i) {\n\t\tex_info = (MonoILExceptionInfo*)mono_array_addr (ilgen->ex_handlers, MonoILExceptionInfo, i);\n\t\tfinally_start = ex_info->start + ex_info->len;\n\t\tif (!ex_info->handlers)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < mono_array_length (ex_info->handlers); ++j) {\n\t\t\tex_block = (MonoILExceptionBlock*)mono_array_addr (ex_info->handlers, MonoILExceptionBlock, j);\n\t\t\tclause = &(clauses [clause_index]);\n\n\t\t\tclause->flags = ex_block->type;\n\t\t\tclause->try_offset = ex_info->start;\n\n\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FINALLY)\n\t\t\t\tclause->try_len = finally_start - ex_info->start;\n\t\t\telse\n\t\t\t\tclause->try_len = ex_info->len;\n\t\t\tclause->handler_offset = ex_block->start;\n\t\t\tclause->handler_len = ex_block->len;\n\t\t\tif (ex_block->extype) {\n\t\t\t\tclause->data.catch_class = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)ex_block->extype));\n\t\t\t} else {\n\t\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\t\t\tclause->data.filter_offset = ex_block->filter_offset;\n\t\t\t\telse\n\t\t\t\t\tclause->data.filter_offset = 0;\n\t\t\t}\n\t\t\tfinally_start = ex_block->start + ex_block->len;\n\n\t\t\tclause_index ++;\n\t\t}\n\t}\n\n\treturn clauses;\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\nstatic guint32\nmethod_encode_code (MonoDynamicImage *assembly, ReflectionMethodBuilder *mb)\n{\n\tchar flags = 0;\n\tguint32 idx;\n\tguint32 code_size;\n\tgint32 max_stack, i;\n\tgint32 num_locals = 0;\n\tgint32 num_exception = 0;\n\tgint maybe_small;\n\tguint32 fat_flags;\n\tchar fat_header [12];\n\tguint32 int_value;\n\tguint16 short_value;\n\tguint32 local_sig = 0;\n\tguint32 header_size = 12;\n\tMonoArray *code;\n\n\tif ((mb->attrs & (METHOD_ATTRIBUTE_PINVOKE_IMPL | METHOD_ATTRIBUTE_ABSTRACT)) ||\n\t\t\t(mb->iattrs & (METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL | METHOD_IMPL_ATTRIBUTE_RUNTIME)))\n\t\treturn 0;\n\n\t/*if (mb->name)\n\t\tg_print (\"Encode method %s\\n\", mono_string_to_utf8 (mb->name));*/\n\tif (mb->ilgen) {\n\t\tcode = mb->ilgen->code;\n\t\tcode_size = mb->ilgen->code_len;\n\t\tmax_stack = mb->ilgen->max_stack;\n\t\tnum_locals = mb->ilgen->locals ? mono_array_length (mb->ilgen->locals) : 0;\n\t\tif (mb->ilgen->ex_handlers)\n\t\t\tnum_exception = method_count_clauses (mb->ilgen);\n\t} else {\n\t\tcode = mb->code;\n\t\tif (code == NULL){\n\t\t\tchar *name = mono_string_to_utf8 (mb->name);\n\t\t\tchar *str = g_strdup_printf (\"Method %s does not have any IL associated\", name);\n\t\t\tMonoException *exception = mono_get_exception_argument (NULL, \"a method does not have any IL associated\");\n\t\t\tg_free (str);\n\t\t\tg_free (name);\n\t\t\tmono_raise_exception (exception);\n\t\t}\n\n\t\tcode_size = mono_array_length (code);\n\t\tmax_stack = 8; /* we probably need to run a verifier on the code... */\n\t}\n\n\tstream_data_align (&assembly->code);\n\n\t/* check for exceptions, maxstack, locals */\n\tmaybe_small = (max_stack <= 8) && (!num_locals) && (!num_exception);\n\tif (maybe_small) {\n\t\tif (code_size < 64 && !(code_size & 1)) {\n\t\t\tflags = (code_size << 2) | 0x2;\n\t\t} else if (code_size < 32 && (code_size & 1)) {\n\t\t\tflags = (code_size << 2) | 0x6; /* LAMESPEC: see metadata.c */\n\t\t} else {\n\t\t\tgoto fat_header;\n\t\t}\n\t\tidx = mono_image_add_stream_data (&assembly->code, &flags, 1);\n\t\t/* add to the fixup todo list */\n\t\tif (mb->ilgen && mb->ilgen->num_token_fixups)\n\t\t\tmono_g_hash_table_insert (assembly->token_fixups, mb->ilgen, GUINT_TO_POINTER (idx + 1));\n\t\tmono_image_add_stream_data (&assembly->code, mono_array_addr (code, char, 0), code_size);\n\t\treturn assembly->text_rva + idx;\n\t} \nfat_header:\n\tif (num_locals)\n\t\tlocal_sig = MONO_TOKEN_SIGNATURE | encode_locals (assembly, mb->ilgen);\n\t/* \n\t * FIXME: need to set also the header size in fat_flags.\n\t * (and more sects and init locals flags)\n\t */\n\tfat_flags =  0x03;\n\tif (num_exception)\n\t\tfat_flags |= METHOD_HEADER_MORE_SECTS;\n\tif (mb->init_locals)\n\t\tfat_flags |= METHOD_HEADER_INIT_LOCALS;\n\tfat_header [0] = fat_flags;\n\tfat_header [1] = (header_size / 4 ) << 4;\n\tshort_value = GUINT16_TO_LE (max_stack);\n\tmemcpy (fat_header + 2, &short_value, 2);\n\tint_value = GUINT32_TO_LE (code_size);\n\tmemcpy (fat_header + 4, &int_value, 4);\n\tint_value = GUINT32_TO_LE (local_sig);\n\tmemcpy (fat_header + 8, &int_value, 4);\n\tidx = mono_image_add_stream_data (&assembly->code, fat_header, 12);\n\t/* add to the fixup todo list */\n\tif (mb->ilgen && mb->ilgen->num_token_fixups)\n\t\tmono_g_hash_table_insert (assembly->token_fixups, mb->ilgen, GUINT_TO_POINTER (idx + 12));\n\t\n\tmono_image_add_stream_data (&assembly->code, mono_array_addr (code, char, 0), code_size);\n\tif (num_exception) {\n\t\tunsigned char sheader [4];\n\t\tMonoILExceptionInfo * ex_info;\n\t\tMonoILExceptionBlock * ex_block;\n\t\tint j;\n\n\t\tstream_data_align (&assembly->code);\n\t\t/* always use fat format for now */\n\t\tsheader [0] = METHOD_HEADER_SECTION_FAT_FORMAT | METHOD_HEADER_SECTION_EHTABLE;\n\t\tnum_exception *= 6 * sizeof (guint32);\n\t\tnum_exception += 4; /* include the size of the header */\n\t\tsheader [1] = num_exception & 0xff;\n\t\tsheader [2] = (num_exception >> 8) & 0xff;\n\t\tsheader [3] = (num_exception >> 16) & 0xff;\n\t\tmono_image_add_stream_data (&assembly->code, (char*)sheader, 4);\n\t\t/* fat header, so we are already aligned */\n\t\t/* reverse order */\n\t\tfor (i = mono_array_length (mb->ilgen->ex_handlers) - 1; i >= 0; --i) {\n\t\t\tex_info = (MonoILExceptionInfo *)mono_array_addr (mb->ilgen->ex_handlers, MonoILExceptionInfo, i);\n\t\t\tif (ex_info->handlers) {\n\t\t\t\tint finally_start = ex_info->start + ex_info->len;\n\t\t\t\tfor (j = 0; j < mono_array_length (ex_info->handlers); ++j) {\n\t\t\t\t\tguint32 val;\n\t\t\t\t\tex_block = (MonoILExceptionBlock*)mono_array_addr (ex_info->handlers, MonoILExceptionBlock, j);\n\t\t\t\t\t/* the flags */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_block->type);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* try offset */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_info->start);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* need fault, too, probably */\n\t\t\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FINALLY)\n\t\t\t\t\t\tval = GUINT32_TO_LE (finally_start - ex_info->start);\n\t\t\t\t\telse\n\t\t\t\t\t\tval = GUINT32_TO_LE (ex_info->len);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* handler offset */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_block->start);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/* handler len */\n\t\t\t\t\tval = GUINT32_TO_LE (ex_block->len);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\tfinally_start = ex_block->start + ex_block->len;\n\t\t\t\t\tif (ex_block->extype) {\n\t\t\t\t\t\tval = mono_metadata_token_from_dor (mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)ex_block->extype)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (ex_block->type == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\t\t\t\t\tval = ex_block->filter_offset;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tval = 0;\n\t\t\t\t\t}\n\t\t\t\t\tval = GUINT32_TO_LE (val);\n\t\t\t\t\tmono_image_add_stream_data (&assembly->code, (char*)&val, sizeof (guint32));\n\t\t\t\t\t/*g_print (\"out clause %d: from %d len=%d, handler at %d, %d, finally_start=%d, ex_info->start=%d, ex_info->len=%d, ex_block->type=%d, j=%d, i=%d\\n\", \n\t\t\t\t\t\t\tclause.flags, clause.try_offset, clause.try_len, clause.handler_offset, clause.handler_len, finally_start, ex_info->start, ex_info->len, ex_block->type, j, i);*/\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tg_error (\"No clauses for ex info block %d\", i);\n\t\t\t}\n\t\t}\n\t}\n\treturn assembly->text_rva + idx;\n}\n\nstatic guint32\nfind_index_in_table (MonoDynamicImage *assembly, int table_idx, int col, guint32 token)\n{\n\tint i;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\t\n\ttable = &assembly->tables [table_idx];\n\n\tg_assert (col < table->columns);\n\n\tvalues = table->values + table->columns;\n\tfor (i = 1; i <= table->rows; ++i) {\n\t\tif (values [col] == token)\n\t\t\treturn i;\n\t\tvalues += table->columns;\n\t}\n\treturn 0;\n}\n\n/*\n * LOCKING: Acquires the loader lock. \n */\nstatic MonoCustomAttrInfo*\nlookup_custom_attr (MonoImage *image, gpointer member)\n{\n\tMonoCustomAttrInfo* res;\n\n\tres = mono_image_property_lookup (image, member, MONO_PROP_DYNAMIC_CATTR);\n\n\tif (!res)\n\t\treturn NULL;\n\n\treturn g_memdup (res, MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * res->num_attrs);\n}\n\nstatic gboolean\ncustom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)\n{\n\t/* FIXME: Need to do more checks */\n\tif (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {\n\t\tint visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\n\t\tif ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic MonoCustomAttrInfo*\nmono_custom_attrs_from_builders (MonoImage *alloc_img, MonoImage *image, MonoArray *cattrs)\n{\n\tint i, index, count, not_visible;\n\tMonoCustomAttrInfo *ainfo;\n\tMonoReflectionCustomAttr *cattr;\n\n\tif (!cattrs)\n\t\treturn NULL;\n\t/* FIXME: check in assembly the Run flag is set */\n\n\tcount = mono_array_length (cattrs);\n\n\t/* Skip nonpublic attributes since MS.NET seems to do the same */\n\t/* FIXME: This needs to be done more globally */\n\tnot_visible = 0;\n\tfor (i = 0; i < count; ++i) {\n\t\tcattr = (MonoReflectionCustomAttr*)mono_array_get (cattrs, gpointer, i);\n\t\tif (!custom_attr_visible (image, cattr))\n\t\t\tnot_visible ++;\n\t}\n\tcount -= not_visible;\n\n\tainfo = image_g_malloc0 (alloc_img, MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * count);\n\n\tainfo->image = image;\n\tainfo->num_attrs = count;\n\tainfo->cached = alloc_img != NULL;\n\tindex = 0;\n\tfor (i = 0; i < count; ++i) {\n\t\tcattr = (MonoReflectionCustomAttr*)mono_array_get (cattrs, gpointer, i);\n\t\tif (custom_attr_visible (image, cattr)) {\n\t\t\tunsigned char *saved = mono_image_alloc (image, mono_array_length (cattr->data));\n\t\t\tmemcpy (saved, mono_array_addr (cattr->data, char, 0), mono_array_length (cattr->data));\n\t\t\tainfo->attrs [index].ctor = cattr->ctor->method;\n\t\t\tainfo->attrs [index].data = saved;\n\t\t\tainfo->attrs [index].data_size = mono_array_length (cattr->data);\n\t\t\tindex ++;\n\t\t}\n\t}\n\n\treturn ainfo;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/*\n * LOCKING: Acquires the loader lock. \n */\nstatic void\nmono_save_custom_attrs (MonoImage *image, void *obj, MonoArray *cattrs)\n{\n\tMonoCustomAttrInfo *ainfo, *tmp;\n\n\tif (!cattrs || !mono_array_length (cattrs))\n\t\treturn;\n\n\tainfo = mono_custom_attrs_from_builders (image, image, cattrs);\n\n\tmono_loader_lock ();\n\ttmp = mono_image_property_lookup (image, obj, MONO_PROP_DYNAMIC_CATTR);\n\tif (tmp)\n\t\tmono_custom_attrs_free (tmp);\n\tmono_image_property_insert (image, obj, MONO_PROP_DYNAMIC_CATTR, ainfo);\n\tmono_loader_unlock ();\n\n}\n#endif\n\nvoid\nmono_custom_attrs_free (MonoCustomAttrInfo *ainfo)\n{\n\tif (!ainfo->cached)\n\t\tg_free (ainfo);\n}\n\n/*\n * idx is the table index of the object\n * type is one of MONO_CUSTOM_ATTR_*\n */\nstatic void\nmono_image_add_cattrs (MonoDynamicImage *assembly, guint32 idx, guint32 type, MonoArray *cattrs)\n{\n\tMonoDynamicTable *table;\n\tMonoReflectionCustomAttr *cattr;\n\tguint32 *values;\n\tguint32 count, i, token;\n\tchar blob_size [6];\n\tchar *p = blob_size;\n\t\n\t/* it is legal to pass a NULL cattrs: we avoid to use the if in a lot of places */\n\tif (!cattrs)\n\t\treturn;\n\tcount = mono_array_length (cattrs);\n\ttable = &assembly->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\ttable->rows += count;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_CUSTOM_ATTR_SIZE;\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= type;\n\tfor (i = 0; i < count; ++i) {\n\t\tcattr = (MonoReflectionCustomAttr*)mono_array_get (cattrs, gpointer, i);\n\t\tvalues [MONO_CUSTOM_ATTR_PARENT] = idx;\n\t\ttoken = mono_image_create_token (assembly, (MonoObject*)cattr->ctor, FALSE, FALSE);\n\t\ttype = mono_metadata_token_index (token);\n\t\ttype <<= MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\tswitch (mono_metadata_token_table (token)) {\n\t\tcase MONO_TABLE_METHOD:\n\t\t\ttype |= MONO_CUSTOM_ATTR_TYPE_METHODDEF;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_MEMBERREF:\n\t\t\ttype |= MONO_CUSTOM_ATTR_TYPE_MEMBERREF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_warning (\"got wrong token in custom attr\");\n\t\t\tcontinue;\n\t\t}\n\t\tvalues [MONO_CUSTOM_ATTR_TYPE] = type;\n\t\tp = blob_size;\n\t\tmono_metadata_encode_value (mono_array_length (cattr->data), p, &p);\n\t\tvalues [MONO_CUSTOM_ATTR_VALUE] = add_to_blob_cached (assembly, blob_size, p - blob_size,\n\t\t\tmono_array_addr (cattr->data, char, 0), mono_array_length (cattr->data));\n\t\tvalues += MONO_CUSTOM_ATTR_SIZE;\n\t\t++table->next_idx;\n\t}\n}\n\nstatic void\nmono_image_add_decl_security (MonoDynamicImage *assembly, guint32 parent_token, MonoArray *permissions)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 count, i, idx;\n\tMonoReflectionPermissionSet *perm;\n\n\tif (!permissions)\n\t\treturn;\n\n\tcount = mono_array_length (permissions);\n\ttable = &assembly->tables [MONO_TABLE_DECLSECURITY];\n\ttable->rows += count;\n\talloc_table (table, table->rows);\n\n\tfor (i = 0; i < mono_array_length (permissions); ++i) {\n\t\tperm = (MonoReflectionPermissionSet*)mono_array_addr (permissions, MonoReflectionPermissionSet, i);\n\n\t\tvalues = table->values + table->next_idx * MONO_DECL_SECURITY_SIZE;\n\n\t\tidx = mono_metadata_token_index (parent_token);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tswitch (mono_metadata_token_table (parent_token)) {\n\t\tcase MONO_TABLE_TYPEDEF:\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_METHOD:\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_ASSEMBLY:\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_ASSEMBLY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tvalues [MONO_DECL_SECURITY_ACTION] = perm->action;\n\t\tvalues [MONO_DECL_SECURITY_PARENT] = idx;\n\t\tvalues [MONO_DECL_SECURITY_PERMISSIONSET] = add_mono_string_to_blob_cached (assembly, perm->pset);\n\n\t\t++table->next_idx;\n\t}\n}\n\n/*\n * Fill in the MethodDef and ParamDef tables for a method.\n * This is used for both normal methods and constructors.\n */\nstatic void\nmono_image_basic_method (ReflectionMethodBuilder *mb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint i, count;\n\n\t/* room in this table is already allocated */\n\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t*mb->table_idx = table->next_idx ++;\n\tg_hash_table_insert (assembly->method_to_table_idx, mb->mhandle, GUINT_TO_POINTER ((*mb->table_idx)));\n\tvalues = table->values + *mb->table_idx * MONO_METHOD_SIZE;\n\tvalues [MONO_METHOD_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->name);\n\tvalues [MONO_METHOD_FLAGS] = mb->attrs;\n\tvalues [MONO_METHOD_IMPLFLAGS] = mb->iattrs;\n\tvalues [MONO_METHOD_SIGNATURE] = method_builder_encode_signature (assembly, mb);\n\tvalues [MONO_METHOD_RVA] = method_encode_code (assembly, mb);\n\t\n\ttable = &assembly->tables [MONO_TABLE_PARAM];\n\tvalues [MONO_METHOD_PARAMLIST] = table->next_idx;\n\n\tmono_image_add_decl_security (assembly, \n\t\tmono_metadata_make_token (MONO_TABLE_METHOD, *mb->table_idx), mb->permissions);\n\n\tif (mb->pinfo) {\n\t\tMonoDynamicTable *mtable;\n\t\tguint32 *mvalues;\n\t\t\n\t\tmtable = &assembly->tables [MONO_TABLE_FIELDMARSHAL];\n\t\tmvalues = mtable->values + mtable->next_idx * MONO_FIELD_MARSHAL_SIZE;\n\t\t\n\t\tcount = 0;\n\t\tfor (i = 0; i < mono_array_length (mb->pinfo); ++i) {\n\t\t\tif (mono_array_get (mb->pinfo, gpointer, i))\n\t\t\t\tcount++;\n\t\t}\n\t\ttable->rows += count;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->next_idx * MONO_PARAM_SIZE;\n\t\tfor (i = 0; i < mono_array_length (mb->pinfo); ++i) {\n\t\t\tMonoReflectionParamBuilder *pb;\n\t\t\tif ((pb = mono_array_get (mb->pinfo, MonoReflectionParamBuilder*, i))) {\n\t\t\t\tvalues [MONO_PARAM_FLAGS] = pb->attrs;\n\t\t\t\tvalues [MONO_PARAM_SEQUENCE] = i;\n\t\t\t\tif (pb->name != NULL) {\n\t\t\t\t\tvalues [MONO_PARAM_NAME] = string_heap_insert_mstring (&assembly->sheap, pb->name);\n\t\t\t\t} else {\n\t\t\t\t\tvalues [MONO_PARAM_NAME] = 0;\n\t\t\t\t}\n\t\t\t\tvalues += MONO_PARAM_SIZE;\n\t\t\t\tif (pb->marshal_info) {\n\t\t\t\t\tmtable->rows++;\n\t\t\t\t\talloc_table (mtable, mtable->rows);\n\t\t\t\t\tmvalues = mtable->values + mtable->rows * MONO_FIELD_MARSHAL_SIZE;\n\t\t\t\t\tmvalues [MONO_FIELD_MARSHAL_PARENT] = (table->next_idx << MONO_HAS_FIELD_MARSHAL_BITS) | MONO_HAS_FIELD_MARSHAL_PARAMDEF;\n\t\t\t\t\tmvalues [MONO_FIELD_MARSHAL_NATIVE_TYPE] = encode_marshal_blob (assembly, pb->marshal_info);\n\t\t\t\t}\n\t\t\t\tpb->table_idx = table->next_idx++;\n\t\t\t\tif (pb->attrs & PARAM_ATTRIBUTE_HAS_DEFAULT) {\n\t\t\t\t\tguint32 field_type = 0;\n\t\t\t\t\tmtable = &assembly->tables [MONO_TABLE_CONSTANT];\n\t\t\t\t\tmtable->rows ++;\n\t\t\t\t\talloc_table (mtable, mtable->rows);\n\t\t\t\t\tmvalues = mtable->values + mtable->rows * MONO_CONSTANT_SIZE;\n\t\t\t\t\tmvalues [MONO_CONSTANT_PARENT] = MONO_HASCONSTANT_PARAM | (pb->table_idx << MONO_HASCONSTANT_BITS);\n\t\t\t\t\tmvalues [MONO_CONSTANT_VALUE] = encode_constant (assembly, pb->def_value, &field_type);\n\t\t\t\t\tmvalues [MONO_CONSTANT_TYPE] = field_type;\n\t\t\t\t\tmvalues [MONO_CONSTANT_PADDING] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nreflection_methodbuilder_from_method_builder (ReflectionMethodBuilder *rmb, MonoReflectionMethodBuilder *mb)\n{\n\tmemset (rmb, 0, sizeof (ReflectionMethodBuilder));\n\n\trmb->ilgen = mb->ilgen;\n\trmb->rtype = mono_reflection_type_resolve_user_types ((MonoReflectionType*)mb->rtype);\n\trmb->parameters = mb->parameters;\n\trmb->generic_params = mb->generic_params;\n\trmb->generic_container = mb->generic_container;\n\trmb->opt_types = NULL;\n\trmb->pinfo = mb->pinfo;\n\trmb->attrs = mb->attrs;\n\trmb->iattrs = mb->iattrs;\n\trmb->call_conv = mb->call_conv;\n\trmb->code = mb->code;\n\trmb->type = mb->type;\n\trmb->name = mb->name;\n\trmb->table_idx = &mb->table_idx;\n\trmb->init_locals = mb->init_locals;\n\trmb->skip_visibility = FALSE;\n\trmb->return_modreq = mb->return_modreq;\n\trmb->return_modopt = mb->return_modopt;\n\trmb->param_modreq = mb->param_modreq;\n\trmb->param_modopt = mb->param_modopt;\n\trmb->permissions = mb->permissions;\n\trmb->mhandle = mb->mhandle;\n\trmb->nrefs = 0;\n\trmb->refs = NULL;\n\n\tif (mb->dll) {\n\t\trmb->charset = mb->charset;\n\t\trmb->extra_flags = mb->extra_flags;\n\t\trmb->native_cc = mb->native_cc;\n\t\trmb->dllentry = mb->dllentry;\n\t\trmb->dll = mb->dll;\n\t}\n}\n\nstatic void\nreflection_methodbuilder_from_ctor_builder (ReflectionMethodBuilder *rmb, MonoReflectionCtorBuilder *mb)\n{\n\tconst char *name = mb->attrs & METHOD_ATTRIBUTE_STATIC ? \".cctor\": \".ctor\";\n\n\tmemset (rmb, 0, sizeof (ReflectionMethodBuilder));\n\n\trmb->ilgen = mb->ilgen;\n\trmb->rtype = mono_type_get_object (mono_domain_get (), &mono_defaults.void_class->byval_arg);\n\trmb->parameters = mb->parameters;\n\trmb->generic_params = NULL;\n\trmb->generic_container = NULL;\n\trmb->opt_types = NULL;\n\trmb->pinfo = mb->pinfo;\n\trmb->attrs = mb->attrs;\n\trmb->iattrs = mb->iattrs;\n\trmb->call_conv = mb->call_conv;\n\trmb->code = NULL;\n\trmb->type = mb->type;\n\trmb->name = mono_string_new (mono_domain_get (), name);\n\trmb->table_idx = &mb->table_idx;\n\trmb->init_locals = mb->init_locals;\n\trmb->skip_visibility = FALSE;\n\trmb->return_modreq = NULL;\n\trmb->return_modopt = NULL;\n\trmb->param_modreq = mb->param_modreq;\n\trmb->param_modopt = mb->param_modopt;\n\trmb->permissions = mb->permissions;\n\trmb->mhandle = mb->mhandle;\n\trmb->nrefs = 0;\n\trmb->refs = NULL;\n}\n\nstatic void\nreflection_methodbuilder_from_dynamic_method (ReflectionMethodBuilder *rmb, MonoReflectionDynamicMethod *mb)\n{\n\tmemset (rmb, 0, sizeof (ReflectionMethodBuilder));\n\n\trmb->ilgen = mb->ilgen;\n\trmb->rtype = mb->rtype;\n\trmb->parameters = mb->parameters;\n\trmb->generic_params = NULL;\n\trmb->generic_container = NULL;\n\trmb->opt_types = NULL;\n\trmb->pinfo = NULL;\n\trmb->attrs = mb->attrs;\n\trmb->iattrs = 0;\n\trmb->call_conv = mb->call_conv;\n\trmb->code = NULL;\n\trmb->type = (MonoObject *) mb->owner;\n\trmb->name = mb->name;\n\trmb->table_idx = NULL;\n\trmb->init_locals = mb->init_locals;\n\trmb->skip_visibility = mb->skip_visibility;\n\trmb->return_modreq = NULL;\n\trmb->return_modopt = NULL;\n\trmb->param_modreq = NULL;\n\trmb->param_modopt = NULL;\n\trmb->permissions = NULL;\n\trmb->mhandle = mb->mhandle;\n\trmb->nrefs = 0;\n\trmb->refs = NULL;\n}\t\n#endif\n\nstatic void\nmono_image_add_methodimpl (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb)\n{\n\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)mb->type;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 tok;\n\n\tif (!mb->override_method)\n\t\treturn;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODIMPL];\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->rows * MONO_METHODIMPL_SIZE;\n\tvalues [MONO_METHODIMPL_CLASS] = tb->table_idx;\n\tvalues [MONO_METHODIMPL_BODY] = MONO_METHODDEFORREF_METHODDEF | (mb->table_idx << MONO_METHODDEFORREF_BITS);\n\n\ttok = mono_image_create_token (assembly, (MonoObject*)mb->override_method, FALSE, FALSE);\n\tswitch (mono_metadata_token_table (tok)) {\n\tcase MONO_TABLE_MEMBERREF:\n\t\ttok = (mono_metadata_token_index (tok) << MONO_METHODDEFORREF_BITS ) | MONO_METHODDEFORREF_METHODREF;\n\t\tbreak;\n\tcase MONO_TABLE_METHOD:\n\t\ttok = (mono_metadata_token_index (tok) << MONO_METHODDEFORREF_BITS ) | MONO_METHODDEFORREF_METHODDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\tvalues [MONO_METHODIMPL_DECLARATION] = tok;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nmono_image_get_method_info (MonoReflectionMethodBuilder *mb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tReflectionMethodBuilder rmb;\n\tint i;\n\n\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\n\tmono_image_basic_method (&rmb, assembly);\n\tmb->table_idx = *rmb.table_idx;\n\n\tif (mb->dll) { /* It's a P/Invoke method */\n\t\tguint32 moduleref;\n\t\t/* map CharSet values to on-disk values */\n\t\tint ncharset = (mb->charset ? (mb->charset - 1) * 2 : 0);\n\t\tint extra_flags = mb->extra_flags;\n\t\ttable = &assembly->tables [MONO_TABLE_IMPLMAP];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_IMPLMAP_SIZE;\n\t\t\n\t\tvalues [MONO_IMPLMAP_FLAGS] = (mb->native_cc << 8) | ncharset | extra_flags;\n\t\tvalues [MONO_IMPLMAP_MEMBER] = (mb->table_idx << 1) | 1; /* memberforwarded: method */\n\t\tif (mb->dllentry)\n\t\t\tvalues [MONO_IMPLMAP_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->dllentry);\n\t\telse\n\t\t\tvalues [MONO_IMPLMAP_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->name);\n\t\tmoduleref = string_heap_insert_mstring (&assembly->sheap, mb->dll);\n\t\tif (!(values [MONO_IMPLMAP_SCOPE] = find_index_in_table (assembly, MONO_TABLE_MODULEREF, MONO_MODULEREF_NAME, moduleref))) {\n\t\t\ttable = &assembly->tables [MONO_TABLE_MODULEREF];\n\t\t\ttable->rows ++;\n\t\t\talloc_table (table, table->rows);\n\t\t\ttable->values [table->rows * MONO_MODULEREF_SIZE + MONO_MODULEREF_NAME] = moduleref;\n\t\t\tvalues [MONO_IMPLMAP_SCOPE] = table->rows;\n\t\t}\n\t}\n\n\tif (mb->generic_params) {\n\t\ttable = &assembly->tables [MONO_TABLE_GENERICPARAM];\n\t\ttable->rows += mono_array_length (mb->generic_params);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (mb->generic_params); ++i) {\n\t\t\tguint32 owner = MONO_TYPEORMETHOD_METHOD | (mb->table_idx << MONO_TYPEORMETHOD_BITS);\n\n\t\t\tmono_image_get_generic_param_info (\n\t\t\t\tmono_array_get (mb->generic_params, gpointer, i), owner, assembly);\n\t\t}\n\t}\n\n}\n\nstatic void\nmono_image_get_ctor_info (MonoDomain *domain, MonoReflectionCtorBuilder *mb, MonoDynamicImage *assembly)\n{\n\tReflectionMethodBuilder rmb;\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, mb);\n\n\tmono_image_basic_method (&rmb, assembly);\n\tmb->table_idx = *rmb.table_idx;\n}\n#endif\n\nstatic char*\ntype_get_fully_qualified_name (MonoType *type)\n{\n\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED);\n}\n\nstatic char*\ntype_get_qualified_name (MonoType *type, MonoAssembly *ass) {\n\tMonoClass *klass;\n\tMonoAssembly *ta;\n\n\tklass = mono_class_from_mono_type (type);\n\tif (!klass) \n\t\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_REFLECTION);\n\tta = klass->image->assembly;\n\tif (ta->dynamic || (ta == ass)) {\n\t\tif (klass->generic_class || klass->generic_container)\n\t\t\t/* For generic type definitions, we want T, while REFLECTION returns T<K> */\n\t\t\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_FULL_NAME);\n\t\telse\n\t\t\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_REFLECTION);\n\t}\n\n\treturn mono_type_get_name_full (type, MONO_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/*field_image is the image to which the eventual custom mods have been encoded against*/\nstatic guint32\nfieldref_encode_signature (MonoDynamicImage *assembly, MonoImage *field_image, MonoType *type)\n{\n\tSigBuffer buf;\n\tguint32 idx, i, token;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\t\n\tsigbuffer_add_value (&buf, 0x06);\n\t/* encode custom attributes before the type */\n\tif (type->num_mods) {\n\t\tfor (i = 0; i < type->num_mods; ++i) {\n\t\t\tif (field_image) {\n\t\t\t\tMonoClass *class = mono_class_get (field_image, type->modifiers [i].token);\n\t\t\t\tg_assert (class);\n\t\t\t\ttoken = mono_image_typedef_or_ref (assembly, &class->byval_arg);\n\t\t\t} else {\n\t\t\t\ttoken = type->modifiers [i].token;\n\t\t\t}\n\n\t\t\tif (type->modifiers [i].required)\n\t\t\t\tsigbuffer_add_byte (&buf, MONO_TYPE_CMOD_REQD);\n\t\t\telse\n\t\t\t\tsigbuffer_add_byte (&buf, MONO_TYPE_CMOD_OPT);\n\n\t\t\tsigbuffer_add_value (&buf, token);\n\t\t}\n\t}\n\tencode_type (assembly, type, &buf);\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n#endif\n\nstatic guint32\nfield_encode_signature (MonoDynamicImage *assembly, MonoReflectionFieldBuilder *fb)\n{\n\tSigBuffer buf;\n\tguint32 idx;\n\n\tsigbuffer_init (&buf, 32);\n\t\n\tsigbuffer_add_value (&buf, 0x06);\n\tencode_custom_modifiers (assembly, fb->modreq, fb->modopt, &buf);\n\t/* encode custom attributes before the type */\n\tencode_reflection_type (assembly, (MonoReflectionType*)fb->type, &buf);\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nencode_constant (MonoDynamicImage *assembly, MonoObject *val, guint32 *ret_type) {\n\tchar blob_size [64];\n\tchar *b = blob_size;\n\tchar *p, *box_val;\n\tchar* buf;\n\tguint32 idx = 0, len = 0, dummy = 0;\n#ifdef ARM_FPU_FPA\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n\tguint32 fpa_double [2];\n\tguint32 *fpa_p;\n#endif\n#endif\n\t\n\tp = buf = g_malloc (64);\n\tif (!val) {\n\t\t*ret_type = MONO_TYPE_CLASS;\n\t\tlen = 4;\n\t\tbox_val = (char*)&dummy;\n\t} else {\n\t\tbox_val = ((char*)val) + sizeof (MonoObject);\n\t\t*ret_type = val->vtable->klass->byval_arg.type;\n\t}\nhandle_enum:\n\tswitch (*ret_type) {\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\t\tlen = 1;\n\t\tbreak;\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\t\tlen = 2;\n\t\tbreak;\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_R4:\n\t\tlen = 4;\n\t\tbreak;\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\t\tlen = 8;\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n\t\tlen = 8;\n#ifdef ARM_FPU_FPA\n#if G_BYTE_ORDER == G_LITTLE_ENDIAN\n\t\tfpa_p = (guint32*)box_val;\n\t\tfpa_double [0] = fpa_p [1];\n\t\tfpa_double [1] = fpa_p [0];\n\t\tbox_val = (char*)fpa_double;\n#endif\n#endif\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (val->vtable->klass->enumtype) {\n\t\t\t*ret_type = mono_class_enum_basetype (val->vtable->klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else\n\t\t\tg_error (\"we can't encode valuetypes\");\n\tcase MONO_TYPE_CLASS:\n\t\tbreak;\n\tcase MONO_TYPE_STRING: {\n\t\tMonoString *str = (MonoString*)val;\n\t\t/* there is no signature */\n\t\tlen = str->length * 2;\n\t\tmono_metadata_encode_value (len, b, &b);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\t\t{\n\t\t\tchar *swapped = g_malloc (2 * mono_string_length (str));\n\t\t\tconst char *p = (const char*)mono_string_chars (str);\n\n\t\t\tswap_with_size (swapped, p, 2, mono_string_length (str));\n\t\t\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, swapped, len);\n\t\t\tg_free (swapped);\n\t\t}\n#else\n\t\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, (char*)mono_string_chars (str), len);\n#endif\n\n\t\tg_free (buf);\n\t\treturn idx;\n\t}\n\tcase MONO_TYPE_GENERICINST:\n\t\t*ret_type = val->vtable->klass->generic_class->container_class->byval_arg.type;\n\t\tgoto handle_enum;\n\tdefault:\n\t\tg_error (\"we don't encode constant type 0x%02x yet\", *ret_type);\n\t}\n\n\t/* there is no signature */\n\tmono_metadata_encode_value (len, b, &b);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\tidx = mono_image_add_stream_data (&assembly->blob, blob_size, b-blob_size);\n\tswap_with_size (blob_size, box_val, len, 1);\n\tmono_image_add_stream_data (&assembly->blob, blob_size, len);\n#else\n\tidx = add_to_blob_cached (assembly, blob_size, b-blob_size, box_val, len);\n#endif\n\n\tg_free (buf);\n\treturn idx;\n}\n\nstatic guint32\nencode_marshal_blob (MonoDynamicImage *assembly, MonoReflectionMarshal *minfo) {\n\tchar *str;\n\tSigBuffer buf;\n\tguint32 idx, len;\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, minfo->type);\n\n\tswitch (minfo->type) {\n\tcase MONO_NATIVE_BYVALTSTR:\n\tcase MONO_NATIVE_BYVALARRAY:\n\t\tsigbuffer_add_value (&buf, minfo->count);\n\t\tbreak;\n\tcase MONO_NATIVE_LPARRAY:\n\t\tif (minfo->eltype || minfo->has_size) {\n\t\t\tsigbuffer_add_value (&buf, minfo->eltype);\n\t\t\tif (minfo->has_size) {\n\t\t\t\tsigbuffer_add_value (&buf, minfo->param_num != -1? minfo->param_num: 0);\n\t\t\t\tsigbuffer_add_value (&buf, minfo->count != -1? minfo->count: 0);\n\n\t\t\t\t/* LAMESPEC: ElemMult is undocumented */\n\t\t\t\tsigbuffer_add_value (&buf, minfo->param_num != -1? 1: 0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MONO_NATIVE_SAFEARRAY:\n\t\tif (minfo->eltype)\n\t\t\tsigbuffer_add_value (&buf, minfo->eltype);\n\t\tbreak;\n\tcase MONO_NATIVE_CUSTOM:\n\t\tif (minfo->guid) {\n\t\t\tstr = mono_string_to_utf8 (minfo->guid);\n\t\t\tlen = strlen (str);\n\t\t\tsigbuffer_add_value (&buf, len);\n\t\t\tsigbuffer_add_mem (&buf, str, len);\n\t\t\tg_free (str);\n\t\t} else {\n\t\t\tsigbuffer_add_value (&buf, 0);\n\t\t}\n\t\t/* native type name */\n\t\tsigbuffer_add_value (&buf, 0);\n\t\t/* custom marshaler type name */\n\t\tif (minfo->marshaltype || minfo->marshaltyperef) {\n\t\t\tif (minfo->marshaltyperef)\n\t\t\t\tstr = type_get_fully_qualified_name (mono_reflection_type_get_handle ((MonoReflectionType*)minfo->marshaltyperef));\n\t\t\telse\n\t\t\t\tstr = mono_string_to_utf8 (minfo->marshaltype);\n\t\t\tlen = strlen (str);\n\t\t\tsigbuffer_add_value (&buf, len);\n\t\t\tsigbuffer_add_mem (&buf, str, len);\n\t\t\tg_free (str);\n\t\t} else {\n\t\t\t/* FIXME: Actually a bug, since this field is required.  Punting for now ... */\n\t\t\tsigbuffer_add_value (&buf, 0);\n\t\t}\n\t\tif (minfo->mcookie) {\n\t\t\tstr = mono_string_to_utf8 (minfo->mcookie);\n\t\t\tlen = strlen (str);\n\t\t\tsigbuffer_add_value (&buf, len);\n\t\t\tsigbuffer_add_mem (&buf, str, len);\n\t\t\tg_free (str);\n\t\t} else {\n\t\t\tsigbuffer_add_value (&buf, 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic void\nmono_image_get_field_info (MonoReflectionFieldBuilder *fb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\n\t/* maybe this fixup should be done in the C# code */\n\tif (fb->attrs & FIELD_ATTRIBUTE_LITERAL)\n\t\tfb->attrs |= FIELD_ATTRIBUTE_HAS_DEFAULT;\n\ttable = &assembly->tables [MONO_TABLE_FIELD];\n\tfb->table_idx = table->next_idx ++;\n\tg_hash_table_insert (assembly->field_to_table_idx, fb->handle, GUINT_TO_POINTER (fb->table_idx));\n\tvalues = table->values + fb->table_idx * MONO_FIELD_SIZE;\n\tvalues [MONO_FIELD_NAME] = string_heap_insert_mstring (&assembly->sheap, fb->name);\n\tvalues [MONO_FIELD_FLAGS] = fb->attrs;\n\tvalues [MONO_FIELD_SIGNATURE] = field_encode_signature (assembly, fb);\n\n\tif (fb->offset != -1) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELDLAYOUT];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_FIELD_LAYOUT_SIZE;\n\t\tvalues [MONO_FIELD_LAYOUT_FIELD] = fb->table_idx;\n\t\tvalues [MONO_FIELD_LAYOUT_OFFSET] = fb->offset;\n\t}\n\tif (fb->attrs & FIELD_ATTRIBUTE_LITERAL) {\n\t\tguint32 field_type = 0;\n\t\ttable = &assembly->tables [MONO_TABLE_CONSTANT];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_CONSTANT_SIZE;\n\t\tvalues [MONO_CONSTANT_PARENT] = MONO_HASCONSTANT_FIEDDEF | (fb->table_idx << MONO_HASCONSTANT_BITS);\n\t\tvalues [MONO_CONSTANT_VALUE] = encode_constant (assembly, fb->def_value, &field_type);\n\t\tvalues [MONO_CONSTANT_TYPE] = field_type;\n\t\tvalues [MONO_CONSTANT_PADDING] = 0;\n\t}\n\tif (fb->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA) {\n\t\tguint32 rva_idx;\n\t\ttable = &assembly->tables [MONO_TABLE_FIELDRVA];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_FIELD_RVA_SIZE;\n\t\tvalues [MONO_FIELD_RVA_FIELD] = fb->table_idx;\n\t\t/*\n\t\t * We store it in the code section because it's simpler for now.\n\t\t */\n\t\tif (fb->rva_data) {\n\t\t\tif (mono_array_length (fb->rva_data) >= 10)\n\t\t\t\tstream_data_align (&assembly->code);\n\t\t\trva_idx = mono_image_add_stream_data (&assembly->code, mono_array_addr (fb->rva_data, char, 0), mono_array_length (fb->rva_data));\n\t\t} else\n\t\t\trva_idx = mono_image_add_stream_zero (&assembly->code, mono_class_value_size (fb->handle->parent, NULL));\n\t\tvalues [MONO_FIELD_RVA_RVA] = rva_idx + assembly->text_rva;\n\t}\n\tif (fb->marshal_info) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELDMARSHAL];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_FIELD_MARSHAL_SIZE;\n\t\tvalues [MONO_FIELD_MARSHAL_PARENT] = (fb->table_idx << MONO_HAS_FIELD_MARSHAL_BITS) | MONO_HAS_FIELD_MARSHAL_FIELDSREF;\n\t\tvalues [MONO_FIELD_MARSHAL_NATIVE_TYPE] = encode_marshal_blob (assembly, fb->marshal_info);\n\t}\n}\n\nstatic guint32\nproperty_encode_signature (MonoDynamicImage *assembly, MonoReflectionPropertyBuilder *fb)\n{\n\tSigBuffer buf;\n\tguint32 nparams = 0;\n\tMonoReflectionMethodBuilder *mb = fb->get_method;\n\tMonoReflectionMethodBuilder *smb = fb->set_method;\n\tguint32 idx, i;\n\n\tif (mb && mb->parameters)\n\t\tnparams = mono_array_length (mb->parameters);\n\tif (!mb && smb && smb->parameters)\n\t\tnparams = mono_array_length (smb->parameters) - 1;\n\tsigbuffer_init (&buf, 32);\n\tsigbuffer_add_byte (&buf, 0x08);\n\tsigbuffer_add_value (&buf, nparams);\n\tif (mb) {\n\t\tencode_reflection_type (assembly, (MonoReflectionType*)mb->rtype, &buf);\n\t\tfor (i = 0; i < nparams; ++i) {\n\t\t\tMonoReflectionType *pt = mono_array_get (mb->parameters, MonoReflectionType*, i);\n\t\t\tencode_reflection_type (assembly, pt, &buf);\n\t\t}\n\t} else if (smb && smb->parameters) {\n\t\t/* the property type is the last param */\n\t\tencode_reflection_type (assembly, mono_array_get (smb->parameters, MonoReflectionType*, nparams), &buf);\n\t\tfor (i = 0; i < nparams; ++i) {\n\t\t\tMonoReflectionType *pt = mono_array_get (smb->parameters, MonoReflectionType*, i);\n\t\t\tencode_reflection_type (assembly, pt, &buf);\n\t\t}\n\t} else {\n\t\tencode_reflection_type (assembly, (MonoReflectionType*)fb->type, &buf);\n\t}\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic void\nmono_image_get_property_info (MonoReflectionPropertyBuilder *pb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint num_methods = 0;\n\tguint32 semaidx;\n\n\t/* \n\t * we need to set things in the following tables:\n\t * PROPERTYMAP (info already filled in _get_type_info ())\n\t * PROPERTY    (rows already preallocated in _get_type_info ())\n\t * METHOD      (method info already done with the generic method code)\n\t * METHODSEMANTICS\n\t */\n\ttable = &assembly->tables [MONO_TABLE_PROPERTY];\n\tpb->table_idx = table->next_idx ++;\n\tvalues = table->values + pb->table_idx * MONO_PROPERTY_SIZE;\n\tvalues [MONO_PROPERTY_NAME] = string_heap_insert_mstring (&assembly->sheap, pb->name);\n\tvalues [MONO_PROPERTY_FLAGS] = pb->attrs;\n\tvalues [MONO_PROPERTY_TYPE] = property_encode_signature (assembly, pb);\n\n\t/* FIXME: we still don't handle 'other' methods */\n\tif (pb->get_method) num_methods ++;\n\tif (pb->set_method) num_methods ++;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSEMANTICS];\n\ttable->rows += num_methods;\n\talloc_table (table, table->rows);\n\n\tif (pb->get_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_GETTER;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = pb->get_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (pb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_PROPERTY;\n\t}\n\tif (pb->set_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_SETTER;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = pb->set_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (pb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_PROPERTY;\n\t}\n}\n\nstatic void\nmono_image_get_event_info (MonoReflectionEventBuilder *eb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint num_methods = 0;\n\tguint32 semaidx;\n\n\t/* \n\t * we need to set things in the following tables:\n\t * EVENTMAP (info already filled in _get_type_info ())\n\t * EVENT    (rows already preallocated in _get_type_info ())\n\t * METHOD      (method info already done with the generic method code)\n\t * METHODSEMANTICS\n\t */\n\ttable = &assembly->tables [MONO_TABLE_EVENT];\n\teb->table_idx = table->next_idx ++;\n\tvalues = table->values + eb->table_idx * MONO_EVENT_SIZE;\n\tvalues [MONO_EVENT_NAME] = string_heap_insert_mstring (&assembly->sheap, eb->name);\n\tvalues [MONO_EVENT_FLAGS] = eb->attrs;\n\tvalues [MONO_EVENT_TYPE] = mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle (eb->type));\n\n\t/*\n\t * FIXME: we still don't handle 'other' methods \n\t */\n\tif (eb->add_method) num_methods ++;\n\tif (eb->remove_method) num_methods ++;\n\tif (eb->raise_method) num_methods ++;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSEMANTICS];\n\ttable->rows += num_methods;\n\talloc_table (table, table->rows);\n\n\tif (eb->add_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_ADD_ON;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = eb->add_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (eb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_EVENT;\n\t}\n\tif (eb->remove_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_REMOVE_ON;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = eb->remove_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (eb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_EVENT;\n\t}\n\tif (eb->raise_method) {\n\t\tsemaidx = table->next_idx ++;\n\t\tvalues = table->values + semaidx * MONO_METHOD_SEMA_SIZE;\n\t\tvalues [MONO_METHOD_SEMA_SEMANTICS] = METHOD_SEMANTIC_FIRE;\n\t\tvalues [MONO_METHOD_SEMA_METHOD] = eb->raise_method->table_idx;\n\t\tvalues [MONO_METHOD_SEMA_ASSOCIATION] = (eb->table_idx << MONO_HAS_SEMANTICS_BITS) | MONO_HAS_SEMANTICS_EVENT;\n\t}\n}\n\nstatic void\nencode_constraints (MonoReflectionGenericParam *gparam, guint32 owner, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 num_constraints, i;\n\tguint32 *values;\n\tguint32 table_idx;\n\n\ttable = &assembly->tables [MONO_TABLE_GENERICPARAMCONSTRAINT];\n\tnum_constraints = gparam->iface_constraints ?\n\t\tmono_array_length (gparam->iface_constraints) : 0;\n\ttable->rows += num_constraints;\n\tif (gparam->base_type)\n\t\ttable->rows++;\n\talloc_table (table, table->rows);\n\n\tif (gparam->base_type) {\n\t\ttable_idx = table->next_idx ++;\n\t\tvalues = table->values + table_idx * MONO_GENPARCONSTRAINT_SIZE;\n\n\t\tvalues [MONO_GENPARCONSTRAINT_GENERICPAR] = owner;\n\t\tvalues [MONO_GENPARCONSTRAINT_CONSTRAINT] = mono_image_typedef_or_ref (\n\t\t\tassembly, mono_reflection_type_get_handle (gparam->base_type));\n\t}\n\n\tfor (i = 0; i < num_constraints; i++) {\n\t\tMonoReflectionType *constraint = mono_array_get (\n\t\t\tgparam->iface_constraints, gpointer, i);\n\n\t\ttable_idx = table->next_idx ++;\n\t\tvalues = table->values + table_idx * MONO_GENPARCONSTRAINT_SIZE;\n\n\t\tvalues [MONO_GENPARCONSTRAINT_GENERICPAR] = owner;\n\t\tvalues [MONO_GENPARCONSTRAINT_CONSTRAINT] = mono_image_typedef_or_ref (\n\t\t\tassembly, mono_reflection_type_get_handle (constraint));\n\t}\n}\n\nstatic void\nmono_image_get_generic_param_info (MonoReflectionGenericParam *gparam, guint32 owner, MonoDynamicImage *assembly)\n{\n\tGenericParamTableEntry *entry;\n\n\t/*\n\t * The GenericParam table must be sorted according to the `owner' field.\n\t * We need to do this sorting prior to writing the GenericParamConstraint\n\t * table, since we have to use the final GenericParam table indices there\n\t * and they must also be sorted.\n\t */\n\n\tentry = g_new0 (GenericParamTableEntry, 1);\n\tentry->owner = owner;\n\t/* FIXME: track where gen_params should be freed and remove the GC root as well */\n\tMOVING_GC_REGISTER (&entry->gparam);\n\tentry->gparam = gparam;\n\n\tg_ptr_array_add (assembly->gen_params, entry);\n}\n\nstatic void\nwrite_generic_param_entry (MonoDynamicImage *assembly, GenericParamTableEntry *entry)\n{\n\tMonoDynamicTable *table;\n\tMonoGenericParam *param;\n\tguint32 *values;\n\tguint32 table_idx;\n\n\ttable = &assembly->tables [MONO_TABLE_GENERICPARAM];\n\ttable_idx = table->next_idx ++;\n\tvalues = table->values + table_idx * MONO_GENERICPARAM_SIZE;\n\n\tparam = mono_reflection_type_get_handle ((MonoReflectionType*)entry->gparam)->data.generic_param;\n\n\tvalues [MONO_GENERICPARAM_OWNER] = entry->owner;\n\tvalues [MONO_GENERICPARAM_FLAGS] = entry->gparam->attrs;\n\tvalues [MONO_GENERICPARAM_NUMBER] = mono_generic_param_num (param);\n\tvalues [MONO_GENERICPARAM_NAME] = string_heap_insert (&assembly->sheap, mono_generic_param_info (param)->name);\n\n\tmono_image_add_cattrs (assembly, table_idx, MONO_CUSTOM_ATTR_GENERICPAR, entry->gparam->cattrs);\n\n\tencode_constraints (entry->gparam, table_idx, assembly);\n}\n\nstatic guint32\nresolution_scope_from_image (MonoDynamicImage *assembly, MonoImage *image)\n{\n\tMonoDynamicTable *table;\n\tguint32 token;\n\tguint32 *values;\n\tguint32 cols [MONO_ASSEMBLY_SIZE];\n\tconst char *pubkey;\n\tguint32 publen;\n\n\tif ((token = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, image))))\n\t\treturn token;\n\n\tif (image->assembly->dynamic && (image->assembly == assembly->image.assembly)) {\n\t\ttable = &assembly->tables [MONO_TABLE_MODULEREF];\n\t\ttoken = table->next_idx ++;\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + token * MONO_MODULEREF_SIZE;\n\t\tvalues [MONO_MODULEREF_NAME] = string_heap_insert (&assembly->sheap, image->module_name);\n\n\t\ttoken <<= MONO_RESOLTION_SCOPE_BITS;\n\t\ttoken |= MONO_RESOLTION_SCOPE_MODULEREF;\n\t\tg_hash_table_insert (assembly->handleref, image, GUINT_TO_POINTER (token));\n\n\t\treturn token;\n\t}\n\t\n\tif (image->assembly->dynamic)\n\t\t/* FIXME: */\n\t\tmemset (cols, 0, sizeof (cols));\n\telse {\n\t\t/* image->assembly->image is the manifest module */\n\t\timage = image->assembly->image;\n\t\tmono_metadata_decode_row (&image->tables [MONO_TABLE_ASSEMBLY], 0, cols, MONO_ASSEMBLY_SIZE);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_ASSEMBLYREF];\n\ttoken = table->next_idx ++;\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + token * MONO_ASSEMBLYREF_SIZE;\n\tvalues [MONO_ASSEMBLYREF_NAME] = string_heap_insert (&assembly->sheap, image->assembly_name);\n\tvalues [MONO_ASSEMBLYREF_MAJOR_VERSION] = cols [MONO_ASSEMBLY_MAJOR_VERSION];\n\tvalues [MONO_ASSEMBLYREF_MINOR_VERSION] = cols [MONO_ASSEMBLY_MINOR_VERSION];\n\tvalues [MONO_ASSEMBLYREF_BUILD_NUMBER] = cols [MONO_ASSEMBLY_BUILD_NUMBER];\n\tvalues [MONO_ASSEMBLYREF_REV_NUMBER] = cols [MONO_ASSEMBLY_REV_NUMBER];\n\tvalues [MONO_ASSEMBLYREF_FLAGS] = 0;\n\tvalues [MONO_ASSEMBLYREF_CULTURE] = 0;\n\tvalues [MONO_ASSEMBLYREF_HASH_VALUE] = 0;\n\n\tif (strcmp (\"\", image->assembly->aname.culture)) {\n\t\tvalues [MONO_ASSEMBLYREF_CULTURE] = string_heap_insert (&assembly->sheap,\n\t\t\t\timage->assembly->aname.culture);\n\t}\n\n\tif ((pubkey = mono_image_get_public_key (image, &publen))) {\n\t\tguchar pubtoken [9];\n\t\tpubtoken [0] = 8;\n\t\tmono_digest_get_public_token (pubtoken + 1, (guchar*)pubkey, publen);\n\t\tvalues [MONO_ASSEMBLYREF_PUBLIC_KEY] = mono_image_add_stream_data (&assembly->blob, (char*)pubtoken, 9);\n\t} else {\n\t\tvalues [MONO_ASSEMBLYREF_PUBLIC_KEY] = 0;\n\t}\n\ttoken <<= MONO_RESOLTION_SCOPE_BITS;\n\ttoken |= MONO_RESOLTION_SCOPE_ASSEMBLYREF;\n\tg_hash_table_insert (assembly->handleref, image, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic guint32\ncreate_typespec (MonoDynamicImage *assembly, MonoType *type)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token;\n\tSigBuffer buf;\n\n\tif ((token = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typespec, type))))\n\t\treturn token;\n\n\tsigbuffer_init (&buf, 32);\n\tswitch (type->type) {\n\tcase MONO_TYPE_FNPTR:\n\tcase MONO_TYPE_PTR:\n\tcase MONO_TYPE_SZARRAY:\n\tcase MONO_TYPE_ARRAY:\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\tcase MONO_TYPE_GENERICINST:\n\t\tencode_type (assembly, type, &buf);\n\t\tbreak;\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_VALUETYPE: {\n\t\tMonoClass *k = mono_class_from_mono_type (type);\n\t\tif (!k || !k->generic_container) {\n\t\t\tsigbuffer_free (&buf);\n\t\t\treturn 0;\n\t\t}\n\t\tencode_type (assembly, type, &buf);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tsigbuffer_free (&buf);\n\t\treturn 0;\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_TYPESPEC];\n\tif (assembly->save) {\n\t\ttoken = sigbuffer_add_to_blob_cached (assembly, &buf);\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_TYPESPEC_SIZE;\n\t\tvalues [MONO_TYPESPEC_SIGNATURE] = token;\n\t}\n\tsigbuffer_free (&buf);\n\n\ttoken = MONO_TYPEDEFORREF_TYPESPEC | (table->next_idx << MONO_TYPEDEFORREF_BITS);\n\tg_hash_table_insert (assembly->typespec, type, GUINT_TO_POINTER(token));\n\ttable->next_idx ++;\n\treturn token;\n}\n\nstatic guint32\nmono_image_typedef_or_ref_full (MonoDynamicImage *assembly, MonoType *type, gboolean try_typespec)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, scope, enclosing;\n\tMonoClass *klass;\n\n\t/* if the type requires a typespec, we must try that first*/\n\tif (try_typespec && (token = create_typespec (assembly, type)))\n\t\treturn token;\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typeref, type));\n\tif (token)\n\t\treturn token;\n\tklass = mono_class_from_mono_type (type);\n\tif (!klass)\n\t\tklass = mono_class_from_mono_type (type);\n\n\t/*\n\t * If it's in the same module and not a generic type parameter:\n\t */\n\tif ((klass->image == &assembly->image) && (type->type != MONO_TYPE_VAR) && \n\t\t\t(type->type != MONO_TYPE_MVAR)) {\n\t\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\t\ttoken = MONO_TYPEDEFORREF_TYPEDEF | (tb->table_idx << MONO_TYPEDEFORREF_BITS);\n\t\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (token), klass->reflection_info);\n\t\treturn token;\n\t}\n\n\tif (klass->nested_in) {\n\t\tenclosing = mono_image_typedef_or_ref_full (assembly, &klass->nested_in->byval_arg, FALSE);\n\t\t/* get the typeref idx of the enclosing type */\n\t\tenclosing >>= MONO_TYPEDEFORREF_BITS;\n\t\tscope = (enclosing << MONO_RESOLTION_SCOPE_BITS) | MONO_RESOLTION_SCOPE_TYPEREF;\n\t} else {\n\t\tscope = resolution_scope_from_image (assembly, klass->image);\n\t}\n\ttable = &assembly->tables [MONO_TABLE_TYPEREF];\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_TYPEREF_SIZE;\n\t\tvalues [MONO_TYPEREF_SCOPE] = scope;\n\t\tvalues [MONO_TYPEREF_NAME] = string_heap_insert (&assembly->sheap, klass->name);\n\t\tvalues [MONO_TYPEREF_NAMESPACE] = string_heap_insert (&assembly->sheap, klass->name_space);\n\t}\n\ttoken = MONO_TYPEDEFORREF_TYPEREF | (table->next_idx << MONO_TYPEDEFORREF_BITS); /* typeref */\n\tg_hash_table_insert (assembly->typeref, type, GUINT_TO_POINTER(token));\n\ttable->next_idx ++;\n\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (token), klass->reflection_info);\n\treturn token;\n}\n\n/*\n * Despite the name, we handle also TypeSpec (with the above helper).\n */\nstatic guint32\nmono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type)\n{\n\treturn mono_image_typedef_or_ref_full (assembly, type, TRUE);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n/*\n * Insert a memberef row into the metadata: the token that point to the memberref\n * is returned. Caching is done in the caller (mono_image_get_methodref_token() or\n * mono_image_get_fieldref_token()).\n * The sig param is an index to an already built signature.\n */\nstatic guint32\nmono_image_get_memberref_token (MonoDynamicImage *assembly, MonoType *type, const char *name, guint32 sig)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, pclass;\n\tguint32 parent;\n\n\tparent = mono_image_typedef_or_ref (assembly, type);\n\tswitch (parent & MONO_TYPEDEFORREF_MASK) {\n\tcase MONO_TYPEDEFORREF_TYPEREF:\n\t\tpclass = MONO_MEMBERREF_PARENT_TYPEREF;\n\t\tbreak;\n\tcase MONO_TYPEDEFORREF_TYPESPEC:\n\t\tpclass = MONO_MEMBERREF_PARENT_TYPESPEC;\n\t\tbreak;\n\tcase MONO_TYPEDEFORREF_TYPEDEF:\n\t\tpclass = MONO_MEMBERREF_PARENT_TYPEDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_warning (\"unknown typeref or def token 0x%08x for %s\", parent, name);\n\t\treturn 0;\n\t}\n\t/* extract the index */\n\tparent >>= MONO_TYPEDEFORREF_BITS;\n\n\ttable = &assembly->tables [MONO_TABLE_MEMBERREF];\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_MEMBERREF_SIZE;\n\t\tvalues [MONO_MEMBERREF_CLASS] = pclass | (parent << MONO_MEMBERREF_PARENT_BITS);\n\t\tvalues [MONO_MEMBERREF_NAME] = string_heap_insert (&assembly->sheap, name);\n\t\tvalues [MONO_MEMBERREF_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_MEMBER_REF | table->next_idx;\n\ttable->next_idx ++;\n\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodref_token (MonoDynamicImage *assembly, MonoMethod *method, gboolean create_typespec)\n{\n\tguint32 token;\n\tMonoMethodSignature *sig;\n\t\n\tcreate_typespec = create_typespec && method->is_generic && method->klass->image != &assembly->image;\n\n\tif (create_typespec) {\n\t\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, GUINT_TO_POINTER (GPOINTER_TO_UINT (method) + 1)));\n\t\tif (token)\n\t\t\treturn token;\n\t} \n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, method));\n\tif (token && !create_typespec)\n\t\treturn token;\n\n\tg_assert (!method->is_inflated);\n\tif (!token) {\n\t\t/*\n\t\t * A methodref signature can't contain an unmanaged calling convention.\n\t\t */\n\t\tsig = mono_metadata_signature_dup (mono_method_signature (method));\n\t\tif ((sig->call_convention != MONO_CALL_DEFAULT) && (sig->call_convention != MONO_CALL_VARARG))\n\t\t\tsig->call_convention = MONO_CALL_DEFAULT;\n\t\ttoken = mono_image_get_memberref_token (assembly, &method->klass->byval_arg,\n\t\t\tmethod->name,  method_encode_signature (assembly, sig));\n\t\tg_free (sig);\n\t\tg_hash_table_insert (assembly->handleref, method, GUINT_TO_POINTER(token));\n\t}\n\n\tif (create_typespec) {\n\t\tMonoDynamicTable *table = &assembly->tables [MONO_TABLE_METHODSPEC];\n\t\tg_assert (mono_metadata_token_table (token) == MONO_TABLE_MEMBERREF);\n\t\ttoken = (mono_metadata_token_index (token) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODREF;\n\n\t\tif (assembly->save) {\n\t\t\tguint32 *values;\n\n\t\t\talloc_table (table, table->rows + 1);\n\t\t\tvalues = table->values + table->next_idx * MONO_METHODSPEC_SIZE;\n\t\t\tvalues [MONO_METHODSPEC_METHOD] = token;\n\t\t\tvalues [MONO_METHODSPEC_SIGNATURE] = encode_generic_method_sig (assembly, &mono_method_get_generic_container (method)->context);\n\t\t}\n\n\t\ttoken = MONO_TOKEN_METHOD_SPEC | table->next_idx;\n\t\ttable->next_idx ++;\n\t\t/*methodspec and memberef tokens are diferent, */\n\t\tg_hash_table_insert (assembly->handleref, GUINT_TO_POINTER (GPOINTER_TO_UINT (method) + 1), GUINT_TO_POINTER (token));\n\t\treturn token;\n\t}\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodref_token_for_methodbuilder (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *method)\n{\n\tguint32 token;\n\tReflectionMethodBuilder rmb;\n\tchar *name;\n\t\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, method));\n\tif (token)\n\t\treturn token;\n\n\tname = mono_string_to_utf8 (method->name);\n\treflection_methodbuilder_from_method_builder (&rmb, method);\n\n\t/*\n\t * A methodref signature can't contain an unmanaged calling convention.\n\t * Since some flags are encoded as part of call_conv, we need to check against it.\n\t*/\n\tif ((rmb.call_conv & ~0x60) != MONO_CALL_DEFAULT && (rmb.call_conv & ~0x60) != MONO_CALL_VARARG)\n\t\trmb.call_conv = (rmb.call_conv & 0x60) | MONO_CALL_DEFAULT;\n\ttoken = mono_image_get_memberref_token (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)rmb.type),\n\t\t\t\t\tname, method_builder_encode_signature (assembly, &rmb));\n\n\tg_free (name);\n\tg_hash_table_insert (assembly->handleref, method, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_varargs_method_token (MonoDynamicImage *assembly, guint32 original,\n\t\t\t\t     const gchar *name, guint32 sig)\n{\n\tMonoDynamicTable *table;\n\tguint32 token;\n\tguint32 *values;\n\t\n\ttable = &assembly->tables [MONO_TABLE_MEMBERREF];\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_MEMBERREF_SIZE;\n\t\tvalues [MONO_MEMBERREF_CLASS] = original;\n\t\tvalues [MONO_MEMBERREF_NAME] = string_heap_insert (&assembly->sheap, name);\n\t\tvalues [MONO_MEMBERREF_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_MEMBER_REF | table->next_idx;\n\ttable->next_idx ++;\n\n\treturn token;\n}\n\nstatic guint32\nencode_generic_method_definition_sig (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb)\n{\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams = mono_array_length (mb->generic_params);\n\tguint32 idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, 0xa);\n\tsigbuffer_add_value (&buf, nparams);\n\n\tfor (i = 0; i < nparams; i++) {\n\t\tsigbuffer_add_value (&buf, MONO_TYPE_MVAR);\n\t\tsigbuffer_add_value (&buf, i);\n\t}\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nmono_image_get_methodspec_token_for_generic_method_definition (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, mtoken = 0;\n\n\ttoken = GPOINTER_TO_UINT (mono_g_hash_table_lookup (assembly->methodspec, mb));\n\tif (token)\n\t\treturn token;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSPEC];\n\n\tmtoken = mono_image_get_methodref_token_for_methodbuilder (assembly, mb);\n\tswitch (mono_metadata_token_table (mtoken)) {\n\tcase MONO_TABLE_MEMBERREF:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODREF;\n\t\tbreak;\n\tcase MONO_TABLE_METHOD:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_METHODSPEC_SIZE;\n\t\tvalues [MONO_METHODSPEC_METHOD] = mtoken;\n\t\tvalues [MONO_METHODSPEC_SIGNATURE] = encode_generic_method_definition_sig (assembly, mb);\n\t}\n\n\ttoken = MONO_TOKEN_METHOD_SPEC | table->next_idx;\n\ttable->next_idx ++;\n\n\tmono_g_hash_table_insert (assembly->methodspec, mb, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodbuilder_token (MonoDynamicImage *assembly, MonoReflectionMethodBuilder *mb, gboolean create_methodspec)\n{\n\tguint32 token;\n\t\n\tif (mb->generic_params && create_methodspec) \n\t\treturn mono_image_get_methodspec_token_for_generic_method_definition (assembly, mb);\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, mb));\n\tif (token)\n\t\treturn token;\n\n\ttoken = mono_image_get_methodref_token_for_methodbuilder (assembly, mb);\n\tg_hash_table_insert (assembly->handleref, mb, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_ctorbuilder_token (MonoDynamicImage *assembly, MonoReflectionCtorBuilder *mb)\n{\n\tguint32 token;\n\tReflectionMethodBuilder rmb;\n\tchar *name;\n\t\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, mb));\n\tif (token)\n\t\treturn token;\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, mb);\n\n\tname = mono_string_to_utf8 (rmb.name);\n\ttoken = mono_image_get_memberref_token (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)rmb.type),\n\t\tname, method_builder_encode_signature (assembly, &rmb));\n\n\tg_free (name);\n\tg_hash_table_insert (assembly->handleref, mb, GUINT_TO_POINTER(token));\n\treturn token;\n}\n#endif\n\nstatic gboolean\nis_field_on_inst (MonoClassField *field)\n{\n\treturn (field->parent->generic_class && field->parent->generic_class->is_dynamic && ((MonoDynamicGenericClass*)field->parent->generic_class)->fields);\n}\n\n/*\n * If FIELD is a field of a MonoDynamicGenericClass, return its non-inflated type.\n */\nstatic MonoType*\nget_field_on_inst_generic_type (MonoClassField *field)\n{\n\tMonoDynamicGenericClass *dgclass;\n\tint field_index;\n\n\tg_assert (is_field_on_inst (field));\n\n\tdgclass = (MonoDynamicGenericClass*)field->parent->generic_class;\n\tfield_index = field - dgclass->fields;\n\n\tg_assert (field_index >= 0 && field_index < dgclass->count_fields);\n\treturn dgclass->field_generic_types [field_index];\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32\nmono_image_get_fieldref_token (MonoDynamicImage *assembly, MonoReflectionField *f)\n{\n\tMonoType *type;\n\tguint32 token;\n\tMonoClassField *field;\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, f));\n\tif (token)\n\t\treturn token;\n\tg_assert (f->field->parent);\n\n\tfield = f->field;\n\tif (field->parent->generic_class && field->parent->generic_class->container_class && field->parent->generic_class->container_class->fields) {\n\t\tint index = field - field->parent->fields;\n\t\ttype = field->parent->generic_class->container_class->fields [index].type;\n\t} else {\n\t\tif (is_field_on_inst (f->field))\n\t\t\ttype = get_field_on_inst_generic_type (f->field);\n\t\telse\n\t\t\ttype = f->field->type;\n\t}\n\ttoken = mono_image_get_memberref_token (assembly, &f->field->parent->byval_arg, \n\t\t\t\t\t\t\t\t\t\t\tmono_field_get_name (f->field),  \n\t\t\t\t\t\t\t\t\t\t\tfieldref_encode_signature (assembly, field->parent->image, type));\n\tg_hash_table_insert (assembly->handleref, f, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_field_on_inst_token (MonoDynamicImage *assembly, MonoReflectionFieldOnTypeBuilderInst *f)\n{\n\tguint32 token;\n\tMonoClass *klass;\n\tMonoGenericClass *gclass;\n\tMonoDynamicGenericClass *dgclass;\n\tMonoReflectionFieldBuilder *fb = f->fb;\n\tMonoType *type;\n\tchar *name;\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, f));\n\tif (token)\n\t\treturn token;\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)f->inst);\n\tklass = mono_class_from_mono_type (type);\n\tgclass = type->data.generic_class;\n\tg_assert (gclass->is_dynamic);\n\tdgclass = (MonoDynamicGenericClass *) gclass;\n\n\tname = mono_string_to_utf8 (fb->name);\n\ttoken = mono_image_get_memberref_token (assembly, &klass->byval_arg, name, \n\t\t\t\t\t\t\t\t\t\t\tfield_encode_signature (assembly, fb));\n\tg_free (name);\n\tg_hash_table_insert (assembly->handleref, f, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_ctor_on_inst_token (MonoDynamicImage *assembly, MonoReflectionCtorOnTypeBuilderInst *c, gboolean create_methodspec)\n{\n\tguint32 sig, token;\n\tMonoClass *klass;\n\tMonoGenericClass *gclass;\n\tMonoDynamicGenericClass *dgclass;\n\tMonoReflectionCtorBuilder *cb = c->cb;\n\tReflectionMethodBuilder rmb;\n\tMonoType *type;\n\tchar *name;\n\n\t/* A ctor cannot be a generic method, so we can ignore create_methodspec */\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, c));\n\tif (token)\n\t\treturn token;\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)c->inst);\n\tklass = mono_class_from_mono_type (type);\n\tgclass = type->data.generic_class;\n\tg_assert (gclass->is_dynamic);\n\tdgclass = (MonoDynamicGenericClass *) gclass;\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, cb);\n\n\tname = mono_string_to_utf8 (rmb.name);\n\n\tsig = method_builder_encode_signature (assembly, &rmb);\n\n\ttoken = mono_image_get_memberref_token (assembly, &klass->byval_arg, name, sig);\n\tg_free (name);\n\n\tg_hash_table_insert (assembly->handleref, c, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic MonoMethod*\nmono_reflection_method_on_tb_inst_get_handle (MonoReflectionMethodOnTypeBuilderInst *m)\n{\n\tMonoClass *klass;\n\tMonoGenericContext tmp_context;\n\tMonoType **type_argv;\n\tMonoGenericInst *ginst;\n\tMonoMethod *method, *inflated;\n\tint count, i;\n\n\tmethod = inflate_method (m->inst, (MonoObject*)m->mb);\n\n\tklass = method->klass;\n\n\tif (m->method_args == NULL)\n\t\treturn method;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_array_length (m->method_args);\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (m->method_args, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\treturn inflated;\n}\n\nstatic guint32\nmono_image_get_method_on_inst_token (MonoDynamicImage *assembly, MonoReflectionMethodOnTypeBuilderInst *m, gboolean create_methodspec)\n{\n\tguint32 sig, token;\n\tMonoClass *klass;\n\tMonoGenericClass *gclass;\n\tMonoReflectionMethodBuilder *mb = m->mb;\n\tReflectionMethodBuilder rmb;\n\tMonoType *type;\n\tchar *name;\n\n\tif (m->method_args) {\n\t\tMonoMethod *inflated;\n\n\t\tinflated = mono_reflection_method_on_tb_inst_get_handle (m);\n\t\tif (create_methodspec)\n\t\t\ttoken = mono_image_get_methodspec_token (assembly, inflated);\n\t\telse\n\t\t\ttoken = mono_image_get_inflated_method_token (assembly, inflated);\n\t\treturn token;\n\t}\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, m));\n\tif (token)\n\t\treturn token;\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)m->inst);\n\tklass = mono_class_from_mono_type (type);\n\tgclass = type->data.generic_class;\n\tg_assert (gclass->is_dynamic);\n\n\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\n\tname = mono_string_to_utf8 (rmb.name);\n\n\tsig = method_builder_encode_signature (assembly, &rmb);\n\n\ttoken = mono_image_get_memberref_token (assembly, &klass->byval_arg, name, sig);\n\tg_free (name);\n\n\tg_hash_table_insert (assembly->handleref, m, GUINT_TO_POINTER (token));\n\treturn token;\n}\n\nstatic guint32\nencode_generic_method_sig (MonoDynamicImage *assembly, MonoGenericContext *context)\n{\n\tSigBuffer buf;\n\tint i;\n\tguint32 nparams = context->method_inst->type_argc;\n\tguint32 idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\tsigbuffer_init (&buf, 32);\n\t/*\n\t * FIXME: vararg, explicit_this, differenc call_conv values...\n\t */\n\tsigbuffer_add_value (&buf, 0xa); /* FIXME FIXME FIXME */\n\tsigbuffer_add_value (&buf, nparams);\n\n\tfor (i = 0; i < nparams; i++)\n\t\tencode_type (assembly, context->method_inst->type_argv [i], &buf);\n\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\treturn idx;\n}\n\nstatic guint32\nmethod_encode_methodspec (MonoDynamicImage *assembly, MonoMethod *method)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 token, mtoken = 0, sig;\n\tMonoMethodInflated *imethod;\n\tMonoMethod *declaring;\n\n\ttable = &assembly->tables [MONO_TABLE_METHODSPEC];\n\n\tg_assert (method->is_inflated);\n\timethod = (MonoMethodInflated *) method;\n\tdeclaring = imethod->declaring;\n\n\tsig = method_encode_signature (assembly, mono_method_signature (declaring));\n\tmtoken = mono_image_get_memberref_token (assembly, &method->klass->byval_arg, declaring->name, sig);\n\n\tif (!mono_method_signature (declaring)->generic_param_count)\n\t\treturn mtoken;\n\n\tswitch (mono_metadata_token_table (mtoken)) {\n\tcase MONO_TABLE_MEMBERREF:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODREF;\n\t\tbreak;\n\tcase MONO_TABLE_METHOD:\n\t\tmtoken = (mono_metadata_token_index (mtoken) << MONO_METHODDEFORREF_BITS) | MONO_METHODDEFORREF_METHODDEF;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\n\tsig = encode_generic_method_sig (assembly, mono_method_get_context (method));\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_METHODSPEC_SIZE;\n\t\tvalues [MONO_METHODSPEC_METHOD] = mtoken;\n\t\tvalues [MONO_METHODSPEC_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_METHOD_SPEC | table->next_idx;\n\ttable->next_idx ++;\n\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_methodspec_token (MonoDynamicImage *assembly, MonoMethod *method)\n{\n\tMonoMethodInflated *imethod;\n\tguint32 token;\n\t\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, method));\n\tif (token)\n\t\treturn token;\n\n\tg_assert (method->is_inflated);\n\timethod = (MonoMethodInflated *) method;\n\n\tif (mono_method_signature (imethod->declaring)->generic_param_count) {\n\t\ttoken = method_encode_methodspec (assembly, method);\n\t} else {\n\t\tguint32 sig = method_encode_signature (\n\t\t\tassembly, mono_method_signature (imethod->declaring));\n\t\ttoken = mono_image_get_memberref_token (\n\t\t\tassembly, &method->klass->byval_arg, method->name, sig);\n\t}\n\n\tg_hash_table_insert (assembly->handleref, method, GUINT_TO_POINTER(token));\n\treturn token;\n}\n\nstatic guint32\nmono_image_get_inflated_method_token (MonoDynamicImage *assembly, MonoMethod *m)\n{\n\tMonoMethodInflated *imethod = (MonoMethodInflated *) m;\n\tguint32 sig, token;\n\n\tsig = method_encode_signature (assembly, mono_method_signature (imethod->declaring));\n\ttoken = mono_image_get_memberref_token (\n\t\tassembly, &m->klass->byval_arg, m->name, sig);\n\n\treturn token;\n}\n\nstatic guint32\ncreate_generic_typespec (MonoDynamicImage *assembly, MonoReflectionTypeBuilder *tb)\n{\n\tMonoDynamicTable *table;\n\tMonoClass *klass;\n\tMonoType *type;\n\tguint32 *values;\n\tguint32 token;\n\tSigBuffer buf;\n\tint count, i;\n\n\t/*\n\t * We're creating a TypeSpec for the TypeBuilder of a generic type declaration,\n\t * ie. what we'd normally use as the generic type in a TypeSpec signature.\n\t * Because of this, we must not insert it into the `typeref' hash table.\n\t */\n\ttype = mono_reflection_type_get_handle ((MonoReflectionType*)tb);\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->typespec, type));\n\tif (token)\n\t\treturn token;\n\n\tsigbuffer_init (&buf, 32);\n\n\tg_assert (tb->generic_params);\n\tklass = mono_class_from_mono_type (type);\n\n\tif (tb->generic_container)\n\t\tmono_reflection_create_generic_class (tb);\n\n\tsigbuffer_add_value (&buf, MONO_TYPE_GENERICINST);\n\tg_assert (klass->generic_container);\n\tsigbuffer_add_value (&buf, klass->byval_arg.type);\n\tsigbuffer_add_value (&buf, mono_image_typedef_or_ref_full (assembly, &klass->byval_arg, FALSE));\n\n\tcount = mono_array_length (tb->generic_params);\n\tsigbuffer_add_value (&buf, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionGenericParam *gparam;\n\n\t\tgparam = mono_array_get (tb->generic_params, MonoReflectionGenericParam *, i);\n\n\t\tencode_type (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)gparam), &buf);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_TYPESPEC];\n\n\tif (assembly->save) {\n\t\ttoken = sigbuffer_add_to_blob_cached (assembly, &buf);\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_TYPESPEC_SIZE;\n\t\tvalues [MONO_TYPESPEC_SIGNATURE] = token;\n\t}\n\tsigbuffer_free (&buf);\n\n\ttoken = MONO_TYPEDEFORREF_TYPESPEC | (table->next_idx << MONO_TYPEDEFORREF_BITS);\n\tg_hash_table_insert (assembly->typespec, type, GUINT_TO_POINTER(token));\n\ttable->next_idx ++;\n\treturn token;\n}\n\n/*\n * Return a copy of TYPE, adding the custom modifiers in MODREQ and MODOPT.\n */\nstatic MonoType*\nadd_custom_modifiers (MonoDynamicImage *assembly, MonoType *type, MonoArray *modreq, MonoArray *modopt)\n{\n\tint i, count, len, pos;\n\tMonoType *t;\n\n\tcount = 0;\n\tif (modreq)\n\t\tcount += mono_array_length (modreq);\n\tif (modopt)\n\t\tcount += mono_array_length (modopt);\n\n\tif (count == 0)\n\t\treturn mono_metadata_type_dup (NULL, type);\n\n\tlen = MONO_SIZEOF_TYPE + ((gint32)count) * sizeof (MonoCustomMod);\n\tt = g_malloc (len);\n\tmemcpy (t, type, MONO_SIZEOF_TYPE);\n\n\tt->num_mods = count;\n\tpos = 0;\n\tif (modreq) {\n\t\tfor (i = 0; i < mono_array_length (modreq); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modreq, i);\n\t\t\tt->modifiers [pos].required = 1;\n\t\t\tt->modifiers [pos].token = mono_image_typedef_or_ref (assembly, mod);\n\t\t\tpos ++;\n\t\t}\n\t}\n\tif (modopt) {\n\t\tfor (i = 0; i < mono_array_length (modopt); ++i) {\n\t\t\tMonoType *mod = mono_type_array_get_and_resolve (modopt, i);\n\t\t\tt->modifiers [pos].required = 0;\n\t\t\tt->modifiers [pos].token = mono_image_typedef_or_ref (assembly, mod);\n\t\t\tpos ++;\n\t\t}\n\t}\n\n\treturn t;\n}\n\nstatic guint32\nmono_image_get_generic_field_token (MonoDynamicImage *assembly, MonoReflectionFieldBuilder *fb)\n{\n\tMonoDynamicTable *table;\n\tMonoClass *klass;\n\tMonoType *custom = NULL;\n\tguint32 *values;\n\tguint32 token, pclass, parent, sig;\n\tgchar *name;\n\n\ttoken = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->handleref, fb));\n\tif (token)\n\t\treturn token;\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle (fb->typeb));\n\tname = mono_string_to_utf8 (fb->name);\n\n\t/* fb->type does not include the custom modifiers */\n\t/* FIXME: We should do this in one place when a fieldbuilder is created */\n\tif (fb->modreq || fb->modopt) {\n\t\tcustom = add_custom_modifiers (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type), fb->modreq, fb->modopt);\n\t\tsig = fieldref_encode_signature (assembly, NULL, custom);\n\t\tg_free (custom);\n\t} else {\n\t\tsig = fieldref_encode_signature (assembly, NULL, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type));\n\t}\n\n\tparent = create_generic_typespec (assembly, (MonoReflectionTypeBuilder *) fb->typeb);\n\tg_assert ((parent & MONO_TYPEDEFORREF_MASK) == MONO_TYPEDEFORREF_TYPESPEC);\n\t\n\tpclass = MONO_MEMBERREF_PARENT_TYPESPEC;\n\tparent >>= MONO_TYPEDEFORREF_BITS;\n\n\ttable = &assembly->tables [MONO_TABLE_MEMBERREF];\n\n\tif (assembly->save) {\n\t\talloc_table (table, table->rows + 1);\n\t\tvalues = table->values + table->next_idx * MONO_MEMBERREF_SIZE;\n\t\tvalues [MONO_MEMBERREF_CLASS] = pclass | (parent << MONO_MEMBERREF_PARENT_BITS);\n\t\tvalues [MONO_MEMBERREF_NAME] = string_heap_insert (&assembly->sheap, name);\n\t\tvalues [MONO_MEMBERREF_SIGNATURE] = sig;\n\t}\n\n\ttoken = MONO_TOKEN_MEMBER_REF | table->next_idx;\n\ttable->next_idx ++;\n\tg_hash_table_insert (assembly->handleref, fb, GUINT_TO_POINTER(token));\n\tg_free (name);\n\treturn token;\n}\n\nstatic guint32\nmono_reflection_encode_sighelper (MonoDynamicImage *assembly, MonoReflectionSigHelper *helper)\n{\n\tSigBuffer buf;\n\tguint32 nargs;\n\tguint32 size;\n\tguint32 i, idx;\n\n\tif (!assembly->save)\n\t\treturn 0;\n\n\t/* FIXME: this means SignatureHelper.SignatureHelpType.HELPER_METHOD */\n\tg_assert (helper->type == 2);\n\n\tif (helper->arguments)\n\t\tnargs = mono_array_length (helper->arguments);\n\telse\n\t\tnargs = 0;\n\n\tsize = 10 + (nargs * 10);\n\t\n\tsigbuffer_init (&buf, 32);\n\n\t/* Encode calling convention */\n\t/* Change Any to Standard */\n\tif ((helper->call_conv & 0x03) == 0x03)\n\t\thelper->call_conv = 0x01;\n\t/* explicit_this implies has_this */\n\tif (helper->call_conv & 0x40)\n\t\thelper->call_conv &= 0x20;\n\n\tif (helper->call_conv == 0) { /* Unmanaged */\n\t\tidx = helper->unmanaged_call_conv - 1;\n\t} else {\n\t\t/* Managed */\n\t\tidx = helper->call_conv & 0x60; /* has_this + explicit_this */\n\t\tif (helper->call_conv & 0x02) /* varargs */\n\t\t\tidx += 0x05;\n\t}\n\n\tsigbuffer_add_byte (&buf, idx);\n\tsigbuffer_add_value (&buf, nargs);\n\tencode_reflection_type (assembly, helper->return_type, &buf);\n\tfor (i = 0; i < nargs; ++i) {\n\t\tMonoArray *modreqs = NULL;\n\t\tMonoArray *modopts = NULL;\n\t\tMonoReflectionType *pt;\n\n\t\tif (helper->modreqs && (i < mono_array_length (helper->modreqs)))\n\t\t\tmodreqs = mono_array_get (helper->modreqs, MonoArray*, i);\n\t\tif (helper->modopts && (i < mono_array_length (helper->modopts)))\n\t\t\tmodopts = mono_array_get (helper->modopts, MonoArray*, i);\n\n\t\tencode_custom_modifiers (assembly, modreqs, modopts, &buf);\n\t\tpt = mono_array_get (helper->arguments, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, pt, &buf);\n\t}\n\tidx = sigbuffer_add_to_blob_cached (assembly, &buf);\n\tsigbuffer_free (&buf);\n\n\treturn idx;\n}\n\nstatic guint32 \nmono_image_get_sighelper_token (MonoDynamicImage *assembly, MonoReflectionSigHelper *helper)\n{\n\tguint32 idx;\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\n\ttable = &assembly->tables [MONO_TABLE_STANDALONESIG];\n\tidx = table->next_idx ++;\n\ttable->rows ++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + idx * MONO_STAND_ALONE_SIGNATURE_SIZE;\n\n\tvalues [MONO_STAND_ALONE_SIGNATURE] =\n\t\tmono_reflection_encode_sighelper (assembly, helper);\n\n\treturn idx;\n}\n\nstatic int\nreflection_cc_to_file (int call_conv) {\n\tswitch (call_conv & 0x3) {\n\tcase 0:\n\tcase 1: return MONO_CALL_DEFAULT;\n\tcase 2: return MONO_CALL_VARARG;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn 0;\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\ntypedef struct {\n\tMonoType *parent;\n\tMonoMethodSignature *sig;\n\tchar *name;\n\tguint32 token;\n} ArrayMethod;\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic guint32\nmono_image_get_array_token (MonoDynamicImage *assembly, MonoReflectionArrayMethod *m)\n{\n\tguint32 nparams, i;\n\tGList *tmp;\n\tchar *name;\n\tMonoMethodSignature *sig;\n\tArrayMethod *am;\n\tMonoType *mtype;\n\n\tname = mono_string_to_utf8 (m->name);\n\tnparams = mono_array_length (m->parameters);\n\tsig = g_malloc0 (MONO_SIZEOF_METHOD_SIGNATURE + sizeof (MonoType*) * nparams);\n\tsig->hasthis = 1;\n\tsig->sentinelpos = -1;\n\tsig->call_convention = reflection_cc_to_file (m->call_conv);\n\tsig->param_count = nparams;\n\tsig->ret = m->ret ? mono_reflection_type_get_handle (m->ret): &mono_defaults.void_class->byval_arg;\n\tmtype = mono_reflection_type_get_handle (m->parent);\n\tfor (i = 0; i < nparams; ++i)\n\t\tsig->params [i] = mono_type_array_get_and_resolve (m->parameters, i);\n\n\tfor (tmp = assembly->array_methods; tmp; tmp = tmp->next) {\n\t\tam = tmp->data;\n\t\tif (strcmp (name, am->name) == 0 && \n\t\t\t\tmono_metadata_type_equal (am->parent, mtype) &&\n\t\t\t\tmono_metadata_signature_equal (am->sig, sig)) {\n\t\t\tg_free (name);\n\t\t\tg_free (sig);\n\t\t\tm->table_idx = am->token & 0xffffff;\n\t\t\treturn am->token;\n\t\t}\n\t}\n\tam = g_new0 (ArrayMethod, 1);\n\tam->name = name;\n\tam->sig = sig;\n\tam->parent = mtype;\n\tam->token = mono_image_get_memberref_token (assembly, am->parent, name,\n\t\tmethod_encode_signature (assembly, sig));\n\tassembly->array_methods = g_list_prepend (assembly->array_methods, am);\n\tm->table_idx = am->token & 0xffffff;\n\treturn am->token;\n}\n\n/*\n * Insert into the metadata tables all the info about the TypeBuilder tb.\n * Data in the tables is inserted in a predefined order, since some tables need to be sorted.\n */\nstatic void\nmono_image_get_type_info (MonoDomain *domain, MonoReflectionTypeBuilder *tb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint *values;\n\tint i, is_object = 0, is_system = 0;\n\tchar *n;\n\n\ttable = &assembly->tables [MONO_TABLE_TYPEDEF];\n\tvalues = table->values + tb->table_idx * MONO_TYPEDEF_SIZE;\n\tvalues [MONO_TYPEDEF_FLAGS] = tb->attrs;\n\tn = mono_string_to_utf8 (tb->name);\n\tif (strcmp (n, \"Object\") == 0)\n\t\tis_object++;\n\tvalues [MONO_TYPEDEF_NAME] = string_heap_insert (&assembly->sheap, n);\n\tg_free (n);\n\tn = mono_string_to_utf8 (tb->nspace);\n\tif (strcmp (n, \"System\") == 0)\n\t\tis_system++;\n\tvalues [MONO_TYPEDEF_NAMESPACE] = string_heap_insert (&assembly->sheap, n);\n\tg_free (n);\n\tif (tb->parent && !(is_system && is_object) && \n\t\t\t!(tb->attrs & TYPE_ATTRIBUTE_INTERFACE)) { /* interfaces don't have a parent */\n\t\tvalues [MONO_TYPEDEF_EXTENDS] = mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle ((MonoReflectionType*)tb->parent));\n\t} else {\n\t\tvalues [MONO_TYPEDEF_EXTENDS] = 0;\n\t}\n\tvalues [MONO_TYPEDEF_FIELD_LIST] = assembly->tables [MONO_TABLE_FIELD].next_idx;\n\tvalues [MONO_TYPEDEF_METHOD_LIST] = assembly->tables [MONO_TABLE_METHOD].next_idx;\n\n\t/*\n\t * if we have explicitlayout or sequentiallayouts, output data in the\n\t * ClassLayout table.\n\t */\n\tif (((tb->attrs & TYPE_ATTRIBUTE_LAYOUT_MASK) != TYPE_ATTRIBUTE_AUTO_LAYOUT) &&\n\t\t\t((tb->class_size > 0) || (tb->packing_size > 0))) {\n\t\ttable = &assembly->tables [MONO_TABLE_CLASSLAYOUT];\n\t\ttable->rows++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_CLASS_LAYOUT_SIZE;\n\t\tvalues [MONO_CLASS_LAYOUT_PARENT] = tb->table_idx;\n\t\tvalues [MONO_CLASS_LAYOUT_CLASS_SIZE] = tb->class_size;\n\t\tvalues [MONO_CLASS_LAYOUT_PACKING_SIZE] = tb->packing_size;\n\t}\n\n\t/* handle interfaces */\n\tif (tb->interfaces) {\n\t\ttable = &assembly->tables [MONO_TABLE_INTERFACEIMPL];\n\t\ti = table->rows;\n\t\ttable->rows += mono_array_length (tb->interfaces);\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + (i + 1) * MONO_INTERFACEIMPL_SIZE;\n\t\tfor (i = 0; i < mono_array_length (tb->interfaces); ++i) {\n\t\t\tMonoReflectionType* iface = (MonoReflectionType*) mono_array_get (tb->interfaces, gpointer, i);\n\t\t\tvalues [MONO_INTERFACEIMPL_CLASS] = tb->table_idx;\n\t\t\tvalues [MONO_INTERFACEIMPL_INTERFACE] = mono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle (iface));\n\t\t\tvalues += MONO_INTERFACEIMPL_SIZE;\n\t\t}\n\t}\n\n\t/* handle fields */\n\tif (tb->fields) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELD];\n\t\ttable->rows += tb->num_fields;\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < tb->num_fields; ++i)\n\t\t\tmono_image_get_field_info (\n\t\t\t\tmono_array_get (tb->fields, MonoReflectionFieldBuilder*, i), assembly);\n\t}\n\n\t/* handle constructors */\n\tif (tb->ctors) {\n\t\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t\ttable->rows += mono_array_length (tb->ctors);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (tb->ctors); ++i)\n\t\t\tmono_image_get_ctor_info (domain,\n\t\t\t\tmono_array_get (tb->ctors, MonoReflectionCtorBuilder*, i), assembly);\n\t}\n\n\t/* handle methods */\n\tif (tb->methods) {\n\t\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t\ttable->rows += tb->num_methods;\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < tb->num_methods; ++i)\n\t\t\tmono_image_get_method_info (\n\t\t\t\tmono_array_get (tb->methods, MonoReflectionMethodBuilder*, i), assembly);\n\t}\n\n\t/* Do the same with properties etc.. */\n\tif (tb->events && mono_array_length (tb->events)) {\n\t\ttable = &assembly->tables [MONO_TABLE_EVENT];\n\t\ttable->rows += mono_array_length (tb->events);\n\t\talloc_table (table, table->rows);\n\t\ttable = &assembly->tables [MONO_TABLE_EVENTMAP];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_EVENT_MAP_SIZE;\n\t\tvalues [MONO_EVENT_MAP_PARENT] = tb->table_idx;\n\t\tvalues [MONO_EVENT_MAP_EVENTLIST] = assembly->tables [MONO_TABLE_EVENT].next_idx;\n\t\tfor (i = 0; i < mono_array_length (tb->events); ++i)\n\t\t\tmono_image_get_event_info (\n\t\t\t\tmono_array_get (tb->events, MonoReflectionEventBuilder*, i), assembly);\n\t}\n\tif (tb->properties && mono_array_length (tb->properties)) {\n\t\ttable = &assembly->tables [MONO_TABLE_PROPERTY];\n\t\ttable->rows += mono_array_length (tb->properties);\n\t\talloc_table (table, table->rows);\n\t\ttable = &assembly->tables [MONO_TABLE_PROPERTYMAP];\n\t\ttable->rows ++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->rows * MONO_PROPERTY_MAP_SIZE;\n\t\tvalues [MONO_PROPERTY_MAP_PARENT] = tb->table_idx;\n\t\tvalues [MONO_PROPERTY_MAP_PROPERTY_LIST] = assembly->tables [MONO_TABLE_PROPERTY].next_idx;\n\t\tfor (i = 0; i < mono_array_length (tb->properties); ++i)\n\t\t\tmono_image_get_property_info (\n\t\t\t\tmono_array_get (tb->properties, MonoReflectionPropertyBuilder*, i), assembly);\n\t}\n\n\t/* handle generic parameters */\n\tif (tb->generic_params) {\n\t\ttable = &assembly->tables [MONO_TABLE_GENERICPARAM];\n\t\ttable->rows += mono_array_length (tb->generic_params);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (tb->generic_params); ++i) {\n\t\t\tguint32 owner = MONO_TYPEORMETHOD_TYPE | (tb->table_idx << MONO_TYPEORMETHOD_BITS);\n\n\t\t\tmono_image_get_generic_param_info (\n\t\t\t\tmono_array_get (tb->generic_params, MonoReflectionGenericParam*, i), owner, assembly);\n\t\t}\n\t}\n\n\tmono_image_add_decl_security (assembly, \n\t\tmono_metadata_make_token (MONO_TABLE_TYPEDEF, tb->table_idx), tb->permissions);\n\n\tif (tb->subtypes) {\n\t\tMonoDynamicTable *ntable;\n\t\t\n\t\tntable = &assembly->tables [MONO_TABLE_NESTEDCLASS];\n\t\tntable->rows += mono_array_length (tb->subtypes);\n\t\talloc_table (ntable, ntable->rows);\n\t\tvalues = ntable->values + ntable->next_idx * MONO_NESTED_CLASS_SIZE;\n\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i) {\n\t\t\tMonoReflectionTypeBuilder *subtype = mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i);\n\n\t\t\tvalues [MONO_NESTED_CLASS_NESTED] = subtype->table_idx;\n\t\t\tvalues [MONO_NESTED_CLASS_ENCLOSING] = tb->table_idx;\n\t\t\t/*g_print (\"nesting %s (%d) in %s (%d) (rows %d/%d)\\n\",\n\t\t\t\tmono_string_to_utf8 (subtype->name), subtype->table_idx,\n\t\t\t\tmono_string_to_utf8 (tb->name), tb->table_idx,\n\t\t\t\tntable->next_idx, ntable->rows);*/\n\t\t\tvalues += MONO_NESTED_CLASS_SIZE;\n\t\t\tntable->next_idx++;\n\t\t}\n\t}\n}\n#endif\n\nstatic void\ncollect_types (GPtrArray *types, MonoReflectionTypeBuilder *type)\n{\n\tint i;\n\n\tg_ptr_array_add (types, type); /* FIXME: GC object added to unmanaged memory */\n\n\tif (!type->subtypes)\n\t\treturn;\n\n\tfor (i = 0; i < mono_array_length (type->subtypes); ++i) {\n\t\tMonoReflectionTypeBuilder *subtype = mono_array_get (type->subtypes, MonoReflectionTypeBuilder*, i);\n\t\tcollect_types (types, subtype);\n\t}\n}\n\nstatic gint\ncompare_types_by_table_idx (MonoReflectionTypeBuilder **type1, MonoReflectionTypeBuilder **type2)\n{\n\tif ((*type1)->table_idx < (*type2)->table_idx)\n\t\treturn -1;\n\telse\n\t\tif ((*type1)->table_idx > (*type2)->table_idx)\n\t\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void\nparams_add_cattrs (MonoDynamicImage *assembly, MonoArray *pinfo) {\n\tint i;\n\n\tif (!pinfo)\n\t\treturn;\n\tfor (i = 0; i < mono_array_length (pinfo); ++i) {\n\t\tMonoReflectionParamBuilder *pb;\n\t\tpb = mono_array_get (pinfo, MonoReflectionParamBuilder *, i);\n\t\tif (!pb)\n\t\t\tcontinue;\n\t\tmono_image_add_cattrs (assembly, pb->table_idx, MONO_CUSTOM_ATTR_PARAMDEF, pb->cattrs);\n\t}\n}\n\nstatic void\ntype_add_cattrs (MonoDynamicImage *assembly, MonoReflectionTypeBuilder *tb) {\n\tint i;\n\t\n\tmono_image_add_cattrs (assembly, tb->table_idx, MONO_CUSTOM_ATTR_TYPEDEF, tb->cattrs);\n\tif (tb->fields) {\n\t\tfor (i = 0; i < tb->num_fields; ++i) {\n\t\t\tMonoReflectionFieldBuilder* fb;\n\t\t\tfb = mono_array_get (tb->fields, MonoReflectionFieldBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, fb->table_idx, MONO_CUSTOM_ATTR_FIELDDEF, fb->cattrs);\n\t\t}\n\t}\n\tif (tb->events) {\n\t\tfor (i = 0; i < mono_array_length (tb->events); ++i) {\n\t\t\tMonoReflectionEventBuilder* eb;\n\t\t\teb = mono_array_get (tb->events, MonoReflectionEventBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, eb->table_idx, MONO_CUSTOM_ATTR_EVENT, eb->cattrs);\n\t\t}\n\t}\n\tif (tb->properties) {\n\t\tfor (i = 0; i < mono_array_length (tb->properties); ++i) {\n\t\t\tMonoReflectionPropertyBuilder* pb;\n\t\t\tpb = mono_array_get (tb->properties, MonoReflectionPropertyBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, pb->table_idx, MONO_CUSTOM_ATTR_PROPERTY, pb->cattrs);\n\t\t}\n\t}\n\tif (tb->ctors) {\n\t\tfor (i = 0; i < mono_array_length (tb->ctors); ++i) {\n\t\t\tMonoReflectionCtorBuilder* cb;\n\t\t\tcb = mono_array_get (tb->ctors, MonoReflectionCtorBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, cb->table_idx, MONO_CUSTOM_ATTR_METHODDEF, cb->cattrs);\n\t\t\tparams_add_cattrs (assembly, cb->pinfo);\n\t\t}\n\t}\n\n\tif (tb->methods) {\n\t\tfor (i = 0; i < tb->num_methods; ++i) {\n\t\t\tMonoReflectionMethodBuilder* mb;\n\t\t\tmb = mono_array_get (tb->methods, MonoReflectionMethodBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, mb->table_idx, MONO_CUSTOM_ATTR_METHODDEF, mb->cattrs);\n\t\t\tparams_add_cattrs (assembly, mb->pinfo);\n\t\t}\n\t}\n\n\tif (tb->subtypes) {\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i)\n\t\t\ttype_add_cattrs (assembly, mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i));\n\t}\n}\n\nstatic void\nmodule_add_cattrs (MonoDynamicImage *assembly, MonoReflectionModuleBuilder *moduleb)\n{\n\tint i;\n\t\n\tmono_image_add_cattrs (assembly, moduleb->table_idx, MONO_CUSTOM_ATTR_MODULE, moduleb->cattrs);\n\n\tif (moduleb->global_methods) {\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_methods); ++i) {\n\t\t\tMonoReflectionMethodBuilder* mb = mono_array_get (moduleb->global_methods, MonoReflectionMethodBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, mb->table_idx, MONO_CUSTOM_ATTR_METHODDEF, mb->cattrs);\n\t\t\tparams_add_cattrs (assembly, mb->pinfo);\n\t\t}\n\t}\n\n\tif (moduleb->global_fields) {\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_fields); ++i) {\n\t\t\tMonoReflectionFieldBuilder *fb = mono_array_get (moduleb->global_fields, MonoReflectionFieldBuilder*, i);\n\t\t\tmono_image_add_cattrs (assembly, fb->table_idx, MONO_CUSTOM_ATTR_FIELDDEF, fb->cattrs);\n\t\t}\n\t}\n\t\n\tif (moduleb->types) {\n\t\tfor (i = 0; i < moduleb->num_types; ++i)\n\t\t\ttype_add_cattrs (assembly, mono_array_get (moduleb->types, MonoReflectionTypeBuilder*, i));\n\t}\n}\n\nstatic void\nmono_image_fill_file_table (MonoDomain *domain, MonoReflectionModule *module, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tchar blob_size [6];\n\tguchar hash [20];\n\tchar *b = blob_size;\n\tchar *dir, *path;\n\n\ttable = &assembly->tables [MONO_TABLE_FILE];\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_FILE_SIZE;\n\tvalues [MONO_FILE_FLAGS] = FILE_CONTAINS_METADATA;\n\tvalues [MONO_FILE_NAME] = string_heap_insert (&assembly->sheap, module->image->module_name);\n\tif (module->image->dynamic) {\n\t\t/* This depends on the fact that the main module is emitted last */\n\t\tdir = mono_string_to_utf8 (((MonoReflectionModuleBuilder*)module)->assemblyb->dir);\n\t\tpath = g_strdup_printf (\"%s%c%s\", dir, G_DIR_SEPARATOR, module->image->module_name);\n\t} else {\n\t\tdir = NULL;\n\t\tpath = g_strdup (module->image->name);\n\t}\n\tmono_sha1_get_digest_from_file (path, hash);\n\tg_free (dir);\n\tg_free (path);\n\tmono_metadata_encode_value (20, b, &b);\n\tvalues [MONO_FILE_HASH_VALUE] = mono_image_add_stream_data (&assembly->blob, blob_size, b-blob_size);\n\tmono_image_add_stream_data (&assembly->blob, (char*)hash, 20);\n\ttable->next_idx ++;\n}\n\nstatic void\nmono_image_fill_module_table (MonoDomain *domain, MonoReflectionModuleBuilder *mb, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tint i;\n\n\ttable = &assembly->tables [MONO_TABLE_MODULE];\n\tmb->table_idx = table->next_idx ++;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_NAME] = string_heap_insert_mstring (&assembly->sheap, mb->module.name);\n\ti = mono_image_add_stream_data (&assembly->guid, mono_array_addr (mb->guid, char, 0), 16);\n\ti /= 16;\n\t++i;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_GENERATION] = 0;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_MVID] = i;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_ENC] = 0;\n\ttable->values [mb->table_idx * MONO_MODULE_SIZE + MONO_MODULE_ENCBASE] = 0;\n}\n\nstatic guint32\nmono_image_fill_export_table_from_class (MonoDomain *domain, MonoClass *klass,\n\tguint32 module_index, guint32 parent_index, MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 visib, res;\n\n\tvisib = klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;\n\tif (! ((visib & TYPE_ATTRIBUTE_PUBLIC) || (visib & TYPE_ATTRIBUTE_NESTED_PUBLIC)))\n\t\treturn 0;\n\n\ttable = &assembly->tables [MONO_TABLE_EXPORTEDTYPE];\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_EXP_TYPE_SIZE;\n\n\tvalues [MONO_EXP_TYPE_FLAGS] = klass->flags;\n\tvalues [MONO_EXP_TYPE_TYPEDEF] = klass->type_token;\n\tif (klass->nested_in)\n\t\tvalues [MONO_EXP_TYPE_IMPLEMENTATION] = (parent_index << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_EXP_TYPE;\n\telse\n\t\tvalues [MONO_EXP_TYPE_IMPLEMENTATION] = (module_index << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_FILE;\n\tvalues [MONO_EXP_TYPE_NAME] = string_heap_insert (&assembly->sheap, klass->name);\n\tvalues [MONO_EXP_TYPE_NAMESPACE] = string_heap_insert (&assembly->sheap, klass->name_space);\n\n\tres = table->next_idx;\n\n\ttable->next_idx ++;\n\n\t/* Emit nested types */\n\tif (klass->ext && klass->ext->nested_classes) {\n\t\tGList *tmp;\n\n\t\tfor (tmp = klass->ext->nested_classes; tmp; tmp = tmp->next)\n\t\t\tmono_image_fill_export_table_from_class (domain, tmp->data, module_index, table->next_idx - 1, assembly);\n\t}\n\n\treturn res;\n}\n\nstatic void\nmono_image_fill_export_table (MonoDomain *domain, MonoReflectionTypeBuilder *tb,\n\tguint32 module_index, guint32 parent_index, MonoDynamicImage *assembly)\n{\n\tMonoClass *klass;\n\tguint32 idx, i;\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\tklass->type_token = mono_metadata_make_token (MONO_TABLE_TYPEDEF, tb->table_idx);\n\n\tidx = mono_image_fill_export_table_from_class (domain, klass, module_index, \n\t\t\t\t\t\t\t\t\t\t\t\t   parent_index, assembly);\n\n\t/* \n\t * Emit nested types\n\t * We need to do this ourselves since klass->nested_classes is not set up.\n\t */\n\tif (tb->subtypes) {\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i)\n\t\t\tmono_image_fill_export_table (domain, mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i), module_index, idx, assembly);\n\t}\n}\n\nstatic void\nmono_image_fill_export_table_from_module (MonoDomain *domain, MonoReflectionModule *module,\n\tguint32 module_index, MonoDynamicImage *assembly)\n{\n\tMonoImage *image = module->image;\n\tMonoTableInfo  *t;\n\tguint32 i;\n\n\tt = &image->tables [MONO_TABLE_TYPEDEF];\n\n\tfor (i = 0; i < t->rows; ++i) {\n\t\tMonoClass *klass = mono_class_get (image, mono_metadata_make_token (MONO_TABLE_TYPEDEF, i + 1));\n\n\t\tif (klass->flags & TYPE_ATTRIBUTE_PUBLIC)\n\t\t\tmono_image_fill_export_table_from_class (domain, klass, module_index, 0, assembly);\n\t}\n}\n\nstatic guint32\nadd_exported_type (MonoReflectionAssemblyBuilder *assemblyb, MonoDynamicImage *assembly, MonoClass *klass)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 scope, idx, res, impl;\n\tgboolean forwarder = TRUE;\n\n\tif (klass->nested_in) {\n\t\timpl = add_exported_type (assemblyb, assembly, klass->nested_in);\n\t\tforwarder = FALSE;\n\t} else {\n\t\tscope = resolution_scope_from_image (assembly, klass->image);\n\t\tg_assert ((scope & MONO_RESOLTION_SCOPE_MASK) == MONO_RESOLTION_SCOPE_ASSEMBLYREF);\n\t\tidx = scope >> MONO_RESOLTION_SCOPE_BITS;\n\t\timpl = (idx << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_ASSEMBLYREF;\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_EXPORTEDTYPE];\n\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_EXP_TYPE_SIZE;\n\n\tvalues [MONO_EXP_TYPE_FLAGS] = forwarder ? TYPE_ATTRIBUTE_FORWARDER : 0;\n\tvalues [MONO_EXP_TYPE_TYPEDEF] = 0;\n\tvalues [MONO_EXP_TYPE_IMPLEMENTATION] = impl;\n\tvalues [MONO_EXP_TYPE_NAME] = string_heap_insert (&assembly->sheap, klass->name);\n\tvalues [MONO_EXP_TYPE_NAMESPACE] = string_heap_insert (&assembly->sheap, klass->name_space);\n\n\tres = (table->next_idx << MONO_IMPLEMENTATION_BITS) + MONO_IMPLEMENTATION_EXP_TYPE;\n\n\ttable->next_idx++;\n\n\treturn res;\n}\n\nstatic void\nmono_image_fill_export_table_from_type_forwarders (MonoReflectionAssemblyBuilder *assemblyb, MonoDynamicImage *assembly)\n{\n\tMonoClass *klass;\n\tint i;\n\n\tif (!assemblyb->type_forwarders)\n\t\treturn;\n\n\tfor (i = 0; i < mono_array_length (assemblyb->type_forwarders); ++i) {\n\t\tMonoReflectionType *t = mono_array_get (assemblyb->type_forwarders, MonoReflectionType *, i);\n\t\tMonoType *type;\n\t\tif (!t)\n\t\t\tcontinue;\n\n\t\ttype = mono_reflection_type_get_handle (t);\n\t\tg_assert (type);\n\n\t\tklass = mono_class_from_mono_type (type);\n\n\t\tadd_exported_type (assemblyb, assembly, klass);\n\t}\n}\n\n#define align_pointer(base,p)\\\n\tdo {\\\n\t\tguint32 __diff = (unsigned char*)(p)-(unsigned char*)(base);\\\n\t\tif (__diff & 3)\\\n\t\t\t(p) += 4 - (__diff & 3);\\\n\t} while (0)\n\nstatic int\ncompare_constants (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\treturn a_values [MONO_CONSTANT_PARENT] - b_values [MONO_CONSTANT_PARENT];\n}\n\nstatic int\ncompare_semantics (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\tint assoc = a_values [MONO_METHOD_SEMA_ASSOCIATION] - b_values [MONO_METHOD_SEMA_ASSOCIATION];\n\tif (assoc)\n\t\treturn assoc;\n\treturn a_values [MONO_METHOD_SEMA_SEMANTICS] - b_values [MONO_METHOD_SEMA_SEMANTICS];\n}\n\nstatic int\ncompare_custom_attrs (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_CUSTOM_ATTR_PARENT] - b_values [MONO_CUSTOM_ATTR_PARENT];\n}\n\nstatic int\ncompare_field_marshal (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_FIELD_MARSHAL_PARENT] - b_values [MONO_FIELD_MARSHAL_PARENT];\n}\n\nstatic int\ncompare_nested (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_NESTED_CLASS_NESTED] - b_values [MONO_NESTED_CLASS_NESTED];\n}\n\nstatic int\ncompare_genericparam (const void *a, const void *b)\n{\n\tconst GenericParamTableEntry **a_entry = (const GenericParamTableEntry **) a;\n\tconst GenericParamTableEntry **b_entry = (const GenericParamTableEntry **) b;\n\n\tif ((*b_entry)->owner == (*a_entry)->owner)\n\t\treturn \n\t\t\tmono_type_get_generic_param_num (mono_reflection_type_get_handle ((MonoReflectionType*)(*a_entry)->gparam)) -\n\t\t\tmono_type_get_generic_param_num (mono_reflection_type_get_handle ((MonoReflectionType*)(*b_entry)->gparam));\n\telse\n\t\treturn (*a_entry)->owner - (*b_entry)->owner;\n}\n\nstatic int\ncompare_declsecurity_attrs (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\treturn a_values [MONO_DECL_SECURITY_PARENT] - b_values [MONO_DECL_SECURITY_PARENT];\n}\n\nstatic int\ncompare_interface_impl (const void *a, const void *b)\n{\n\tconst guint32 *a_values = a;\n\tconst guint32 *b_values = b;\n\n\tint klass = a_values [MONO_INTERFACEIMPL_CLASS] - b_values [MONO_INTERFACEIMPL_CLASS];\n\tif (klass)\n\t\treturn klass;\n\n\treturn a_values [MONO_INTERFACEIMPL_INTERFACE] - b_values [MONO_INTERFACEIMPL_INTERFACE];\n}\n\nstatic void\npad_heap (MonoDynamicStream *sh)\n{\n\tif (sh->index & 3) {\n\t\tint sz = 4 - (sh->index & 3);\n\t\tmemset (sh->data + sh->index, 0, sz);\n\t\tsh->index += sz;\n\t}\n}\n\nstruct StreamDesc {\n\tconst char *name;\n\tMonoDynamicStream *stream;\n};\n\n/*\n * build_compressed_metadata() fills in the blob of data that represents the \n * raw metadata as it will be saved in the PE file. The five streams are output \n * and the metadata tables are comnpressed from the guint32 array representation, \n * to the compressed on-disk format.\n */\nstatic void\nbuild_compressed_metadata (MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tint i;\n\tguint64 valid_mask = 0;\n\tguint64 sorted_mask;\n\tguint32 heapt_size = 0;\n\tguint32 meta_size = 256; /* allow for header and other stuff */\n\tguint32 table_offset;\n\tguint32 ntables = 0;\n\tguint64 *int64val;\n\tguint32 *int32val;\n\tguint16 *int16val;\n\tMonoImage *meta;\n\tunsigned char *p;\n\tstruct StreamDesc stream_desc [5];\n\n\tqsort (assembly->gen_params->pdata, assembly->gen_params->len, sizeof (gpointer), compare_genericparam);\n\tfor (i = 0; i < assembly->gen_params->len; i++){\n\t\tGenericParamTableEntry *entry = g_ptr_array_index (assembly->gen_params, i);\n\t\twrite_generic_param_entry (assembly, entry);\n\t}\n\n\tstream_desc [0].name  = \"#~\";\n\tstream_desc [0].stream = &assembly->tstream;\n\tstream_desc [1].name  = \"#Strings\";\n\tstream_desc [1].stream = &assembly->sheap;\n\tstream_desc [2].name  = \"#US\";\n\tstream_desc [2].stream = &assembly->us;\n\tstream_desc [3].name  = \"#Blob\";\n\tstream_desc [3].stream = &assembly->blob;\n\tstream_desc [4].name  = \"#GUID\";\n\tstream_desc [4].stream = &assembly->guid;\n\t\n\t/* tables that are sorted */\n\tsorted_mask = ((guint64)1 << MONO_TABLE_CONSTANT) | ((guint64)1 << MONO_TABLE_FIELDMARSHAL)\n\t\t| ((guint64)1 << MONO_TABLE_METHODSEMANTICS) | ((guint64)1 << MONO_TABLE_CLASSLAYOUT)\n\t\t| ((guint64)1 << MONO_TABLE_FIELDLAYOUT) | ((guint64)1 << MONO_TABLE_FIELDRVA)\n\t\t| ((guint64)1 << MONO_TABLE_IMPLMAP) | ((guint64)1 << MONO_TABLE_NESTEDCLASS)\n\t\t| ((guint64)1 << MONO_TABLE_METHODIMPL) | ((guint64)1 << MONO_TABLE_CUSTOMATTRIBUTE)\n\t\t| ((guint64)1 << MONO_TABLE_DECLSECURITY) | ((guint64)1 << MONO_TABLE_GENERICPARAM)\n\t\t| ((guint64)1 << MONO_TABLE_INTERFACEIMPL);\n\t\n\t/* Compute table sizes */\n\t/* the MonoImage has already been created in mono_image_basic_init() */\n\tmeta = &assembly->image;\n\n\t/* sizes should be multiple of 4 */\n\tpad_heap (&assembly->blob);\n\tpad_heap (&assembly->guid);\n\tpad_heap (&assembly->sheap);\n\tpad_heap (&assembly->us);\n\n\t/* Setup the info used by compute_sizes () */\n\tmeta->idx_blob_wide = assembly->blob.index >= 65536 ? 1 : 0;\n\tmeta->idx_guid_wide = assembly->guid.index >= 65536 ? 1 : 0;\n\tmeta->idx_string_wide = assembly->sheap.index >= 65536 ? 1 : 0;\n\n\tmeta_size += assembly->blob.index;\n\tmeta_size += assembly->guid.index;\n\tmeta_size += assembly->sheap.index;\n\tmeta_size += assembly->us.index;\n\n\tfor (i=0; i < MONO_TABLE_NUM; ++i)\n\t\tmeta->tables [i].rows = assembly->tables [i].rows;\n\t\n\tfor (i = 0; i < MONO_TABLE_NUM; i++){\n\t\tif (meta->tables [i].rows == 0)\n\t\t\tcontinue;\n\t\tvalid_mask |= (guint64)1 << i;\n\t\tntables ++;\n\t\tmeta->tables [i].row_size = mono_metadata_compute_size (\n\t\t\tmeta, i, &meta->tables [i].size_bitfield);\n\t\theapt_size += meta->tables [i].row_size * meta->tables [i].rows;\n\t}\n\theapt_size += 24; /* #~ header size */\n\theapt_size += ntables * 4;\n\t/* make multiple of 4 */\n\theapt_size += 3;\n\theapt_size &= ~3;\n\tmeta_size += heapt_size;\n\tmeta->raw_metadata = g_malloc0 (meta_size);\n\tp = (unsigned char*)meta->raw_metadata;\n\t/* the metadata signature */\n\t*p++ = 'B'; *p++ = 'S'; *p++ = 'J'; *p++ = 'B';\n\t/* version numbers and 4 bytes reserved */\n\tint16val = (guint16*)p;\n\t*int16val++ = GUINT16_TO_LE (meta->md_version_major);\n\t*int16val = GUINT16_TO_LE (meta->md_version_minor);\n\tp += 8;\n\t/* version string */\n\tint32val = (guint32*)p;\n\t*int32val = GUINT32_TO_LE ((strlen (meta->version) + 3) & (~3)); /* needs to be multiple of 4 */\n\tp += 4;\n\tmemcpy (p, meta->version, strlen (meta->version));\n\tp += GUINT32_FROM_LE (*int32val);\n\talign_pointer (meta->raw_metadata, p);\n\tint16val = (guint16*)p;\n\t*int16val++ = GUINT16_TO_LE (0); /* flags must be 0 */\n\t*int16val = GUINT16_TO_LE (5); /* number of streams */\n\tp += 4;\n\n\t/*\n\t * write the stream info.\n\t */\n\ttable_offset = (p - (unsigned char*)meta->raw_metadata) + 5 * 8 + 40; /* room needed for stream headers */\n\ttable_offset += 3; table_offset &= ~3;\n\n\tassembly->tstream.index = heapt_size;\n\tfor (i = 0; i < 5; ++i) {\n\t\tint32val = (guint32*)p;\n\t\tstream_desc [i].stream->offset = table_offset;\n\t\t*int32val++ = GUINT32_TO_LE (table_offset);\n\t\t*int32val = GUINT32_TO_LE (stream_desc [i].stream->index);\n\t\ttable_offset += GUINT32_FROM_LE (*int32val);\n\t\ttable_offset += 3; table_offset &= ~3;\n\t\tp += 8;\n\t\tstrcpy ((char*)p, stream_desc [i].name);\n\t\tp += strlen (stream_desc [i].name) + 1;\n\t\talign_pointer (meta->raw_metadata, p);\n\t}\n\t/* \n\t * now copy the data, the table stream header and contents goes first.\n\t */\n\tg_assert ((p - (unsigned char*)meta->raw_metadata) < assembly->tstream.offset);\n\tp = (guchar*)meta->raw_metadata + assembly->tstream.offset;\n\tint32val = (guint32*)p;\n\t*int32val = GUINT32_TO_LE (0); /* reserved */\n\tp += 4;\n\n\tif (mono_framework_version () > 1) {\n\t\t*p++ = 2; /* version */\n\t\t*p++ = 0;\n\t} else {\n\t\t*p++ = 1; /* version */\n\t\t*p++ = 0;\n\t}\n\n\tif (meta->idx_string_wide)\n\t\t*p |= 0x01;\n\tif (meta->idx_guid_wide)\n\t\t*p |= 0x02;\n\tif (meta->idx_blob_wide)\n\t\t*p |= 0x04;\n\t++p;\n\t*p++ = 1; /* reserved */\n\tint64val = (guint64*)p;\n\t*int64val++ = GUINT64_TO_LE (valid_mask);\n\t*int64val++ = GUINT64_TO_LE (valid_mask & sorted_mask); /* bitvector of sorted tables  */\n\tp += 16;\n\tint32val = (guint32*)p;\n\tfor (i = 0; i < MONO_TABLE_NUM; i++){\n\t\tif (meta->tables [i].rows == 0)\n\t\t\tcontinue;\n\t\t*int32val++ = GUINT32_TO_LE (meta->tables [i].rows);\n\t}\n\tp = (unsigned char*)int32val;\n\n\t/* sort the tables that still need sorting */\n\ttable = &assembly->tables [MONO_TABLE_CONSTANT];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_CONSTANT_SIZE, table->rows, sizeof (guint32) * MONO_CONSTANT_SIZE, compare_constants);\n\ttable = &assembly->tables [MONO_TABLE_METHODSEMANTICS];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_METHOD_SEMA_SIZE, table->rows, sizeof (guint32) * MONO_METHOD_SEMA_SIZE, compare_semantics);\n\ttable = &assembly->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_CUSTOM_ATTR_SIZE, table->rows, sizeof (guint32) * MONO_CUSTOM_ATTR_SIZE, compare_custom_attrs);\n\ttable = &assembly->tables [MONO_TABLE_FIELDMARSHAL];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_FIELD_MARSHAL_SIZE, table->rows, sizeof (guint32) * MONO_FIELD_MARSHAL_SIZE, compare_field_marshal);\n\ttable = &assembly->tables [MONO_TABLE_NESTEDCLASS];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_NESTED_CLASS_SIZE, table->rows, sizeof (guint32) * MONO_NESTED_CLASS_SIZE, compare_nested);\n\t/* Section 21.11 DeclSecurity in Partition II doesn't specify this to be sorted by MS implementation requires it */\n\ttable = &assembly->tables [MONO_TABLE_DECLSECURITY];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_DECL_SECURITY_SIZE, table->rows, sizeof (guint32) * MONO_DECL_SECURITY_SIZE, compare_declsecurity_attrs);\n\ttable = &assembly->tables [MONO_TABLE_INTERFACEIMPL];\n\tif (table->rows)\n\t\tqsort (table->values + MONO_INTERFACEIMPL_SIZE, table->rows, sizeof (guint32) * MONO_INTERFACEIMPL_SIZE, compare_interface_impl);\n\n\t/* compress the tables */\n\tfor (i = 0; i < MONO_TABLE_NUM; i++){\n\t\tint row, col;\n\t\tguint32 *values;\n\t\tguint32 bitfield = meta->tables [i].size_bitfield;\n\t\tif (!meta->tables [i].rows)\n\t\t\tcontinue;\n\t\tif (assembly->tables [i].columns != mono_metadata_table_count (bitfield))\n\t\t\tg_error (\"col count mismatch in %d: %d %d\", i, assembly->tables [i].columns, mono_metadata_table_count (bitfield));\n\t\tmeta->tables [i].base = (char*)p;\n\t\tfor (row = 1; row <= meta->tables [i].rows; ++row) {\n\t\t\tvalues = assembly->tables [i].values + row * assembly->tables [i].columns;\n\t\t\tfor (col = 0; col < assembly->tables [i].columns; ++col) {\n\t\t\t\tswitch (mono_metadata_table_size (bitfield, col)) {\n\t\t\t\tcase 1:\n\t\t\t\t\t*p++ = values [col];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t*p++ = values [col] & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 8) & 0xff;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\t*p++ = values [col] & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 8) & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 16) & 0xff;\n\t\t\t\t\t*p++ = (values [col] >> 24) & 0xff;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tg_assert_not_reached ();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_assert ((p - (const unsigned char*)meta->tables [i].base) == (meta->tables [i].rows * meta->tables [i].row_size));\n\t}\n\t\n\tg_assert (assembly->guid.offset + assembly->guid.index < meta_size);\n\tmemcpy (meta->raw_metadata + assembly->sheap.offset, assembly->sheap.data, assembly->sheap.index);\n\tmemcpy (meta->raw_metadata + assembly->us.offset, assembly->us.data, assembly->us.index);\n\tmemcpy (meta->raw_metadata + assembly->blob.offset, assembly->blob.data, assembly->blob.index);\n\tmemcpy (meta->raw_metadata + assembly->guid.offset, assembly->guid.data, assembly->guid.index);\n\n\tassembly->meta_size = assembly->guid.offset + assembly->guid.index;\n}\n\n/*\n * Some tables in metadata need to be sorted according to some criteria, but\n * when methods and fields are first created with reflection, they may be assigned a token\n * that doesn't correspond to the final token they will get assigned after the sorting.\n * ILGenerator.cs keeps a fixup table that maps the position of tokens in the IL code stream\n * with the reflection objects that represent them. Once all the tables are set up, the \n * reflection objects will contains the correct table index. fixup_method() will fixup the\n * tokens for the method with ILGenerator @ilgen.\n */\nstatic void\nfixup_method (MonoReflectionILGen *ilgen, gpointer value, MonoDynamicImage *assembly)\n{\n\tguint32 code_idx = GPOINTER_TO_UINT (value);\n\tMonoReflectionILTokenInfo *iltoken;\n\tMonoReflectionFieldBuilder *field;\n\tMonoReflectionCtorBuilder *ctor;\n\tMonoReflectionMethodBuilder *method;\n\tMonoReflectionTypeBuilder *tb;\n\tMonoReflectionArrayMethod *am;\n\tguint32 i, idx = 0;\n\tunsigned char *target;\n\n\tfor (i = 0; i < ilgen->num_token_fixups; ++i) {\n\t\tiltoken = (MonoReflectionILTokenInfo *)mono_array_addr_with_size (ilgen->token_fixups, sizeof (MonoReflectionILTokenInfo), i);\n\t\ttarget = (guchar*)assembly->code.data + code_idx + iltoken->code_pos;\n\t\tswitch (target [3]) {\n\t\tcase MONO_TABLE_FIELD:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"FieldBuilder\")) {\n\t\t\t\tfield = (MonoReflectionFieldBuilder *)iltoken->member;\n\t\t\t\tidx = field->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoField\")) {\n\t\t\t\tMonoClassField *f = ((MonoReflectionField*)iltoken->member)->field;\n\t\t\t\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->field_to_table_idx, f));\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_TABLE_METHOD:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"MethodBuilder\")) {\n\t\t\t\tmethod = (MonoReflectionMethodBuilder *)iltoken->member;\n\t\t\t\tidx = method->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"ConstructorBuilder\")) {\n\t\t\t\tctor = (MonoReflectionCtorBuilder *)iltoken->member;\n\t\t\t\tidx = ctor->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoMethod\") || \n\t\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoCMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)iltoken->member)->method;\n\t\t\t\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->method_to_table_idx, m));\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_TABLE_TYPEDEF:\n\t\t\tif (strcmp (iltoken->member->vtable->klass->name, \"TypeBuilder\"))\n\t\t\t\tg_assert_not_reached ();\n\t\t\ttb = (MonoReflectionTypeBuilder *)iltoken->member;\n\t\t\tidx = tb->table_idx;\n\t\t\tbreak;\n\t\tcase MONO_TABLE_MEMBERREF:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"MonoArrayMethod\")) {\n\t\t\t\tam = (MonoReflectionArrayMethod*)iltoken->member;\n\t\t\t\tidx = am->table_idx;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoMethod\") ||\n\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoCMethod\") ||\n\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoGenericMethod\") ||\n\t\t\t\t   !strcmp (iltoken->member->vtable->klass->name, \"MonoGenericCMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)iltoken->member)->method;\n\t\t\t\tg_assert (m->klass->generic_class || m->klass->generic_container);\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"FieldBuilder\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MonoField\")) {\n\t\t\t\tMonoClassField *f = ((MonoReflectionField*)iltoken->member)->field;\n\t\t\t\tg_assert (is_field_on_inst (f));\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodBuilder\") ||\n\t\t\t\t\t!strcmp (iltoken->member->vtable->klass->name, \"ConstructorBuilder\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"FieldOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"ConstructorOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MONO_TABLE_METHODSPEC:\n\t\t\tif (!strcmp (iltoken->member->vtable->klass->name, \"MonoGenericMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)iltoken->member)->method;\n\t\t\t\tg_assert (mono_method_signature (m)->generic_param_count);\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodBuilder\")) {\n\t\t\t\tcontinue;\n\t\t\t} else if (!strcmp (iltoken->member->vtable->klass->name, \"MethodOnTypeBuilderInst\")) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tg_assert_not_reached ();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_error (\"got unexpected table 0x%02x in fixup\", target [3]);\n\t\t}\n\t\ttarget [0] = idx & 0xff;\n\t\ttarget [1] = (idx >> 8) & 0xff;\n\t\ttarget [2] = (idx >> 16) & 0xff;\n\t}\n}\n\n/*\n * fixup_cattrs:\n *\n *   The CUSTOM_ATTRIBUTE table might contain METHODDEF tokens whose final\n * value is not known when the table is emitted.\n */\nstatic void\nfixup_cattrs (MonoDynamicImage *assembly)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tguint32 type, i, idx, token;\n\tMonoObject *ctor;\n\n\ttable = &assembly->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tvalues = table->values + ((i + 1) * MONO_CUSTOM_ATTR_SIZE);\n\n\t\ttype = values [MONO_CUSTOM_ATTR_TYPE];\n\t\tif ((type & MONO_CUSTOM_ATTR_TYPE_MASK) == MONO_CUSTOM_ATTR_TYPE_METHODDEF) {\n\t\t\tidx = type >> MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\t\ttoken = mono_metadata_make_token (MONO_TABLE_METHOD, idx);\n\t\t\tctor = mono_g_hash_table_lookup (assembly->tokens, GUINT_TO_POINTER (token));\n\t\t\tg_assert (ctor);\n\n\t\t\tif (!strcmp (ctor->vtable->klass->name, \"MonoCMethod\")) {\n\t\t\t\tMonoMethod *m = ((MonoReflectionMethod*)ctor)->method;\n\t\t\t\tidx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->method_to_table_idx, m));\n\t\t\t\tvalues [MONO_CUSTOM_ATTR_TYPE] = (idx << MONO_CUSTOM_ATTR_TYPE_BITS) | MONO_CUSTOM_ATTR_TYPE_METHODDEF;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nassembly_add_resource_manifest (MonoReflectionModuleBuilder *mb, MonoDynamicImage *assembly, MonoReflectionResource *rsrc, guint32 implementation)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\n\ttable = &assembly->tables [MONO_TABLE_MANIFESTRESOURCE];\n\ttable->rows++;\n\talloc_table (table, table->rows);\n\tvalues = table->values + table->next_idx * MONO_MANIFEST_SIZE;\n\tvalues [MONO_MANIFEST_OFFSET] = rsrc->offset;\n\tvalues [MONO_MANIFEST_FLAGS] = rsrc->attrs;\n\tvalues [MONO_MANIFEST_NAME] = string_heap_insert_mstring (&assembly->sheap, rsrc->name);\n\tvalues [MONO_MANIFEST_IMPLEMENTATION] = implementation;\n\ttable->next_idx++;\n}\n\nstatic void\nassembly_add_resource (MonoReflectionModuleBuilder *mb, MonoDynamicImage *assembly, MonoReflectionResource *rsrc)\n{\n\tMonoDynamicTable *table;\n\tguint32 *values;\n\tchar blob_size [6];\n\tguchar hash [20];\n\tchar *b = blob_size;\n\tchar *name, *sname;\n\tguint32 idx, offset;\n\n\tif (rsrc->filename) {\n\t\tname = mono_string_to_utf8 (rsrc->filename);\n\t\tsname = g_path_get_basename (name);\n\t\n\t\ttable = &assembly->tables [MONO_TABLE_FILE];\n\t\ttable->rows++;\n\t\talloc_table (table, table->rows);\n\t\tvalues = table->values + table->next_idx * MONO_FILE_SIZE;\n\t\tvalues [MONO_FILE_FLAGS] = FILE_CONTAINS_NO_METADATA;\n\t\tvalues [MONO_FILE_NAME] = string_heap_insert (&assembly->sheap, sname);\n\t\tg_free (sname);\n\n\t\tmono_sha1_get_digest_from_file (name, hash);\n\t\tmono_metadata_encode_value (20, b, &b);\n\t\tvalues [MONO_FILE_HASH_VALUE] = mono_image_add_stream_data (&assembly->blob, blob_size, b-blob_size);\n\t\tmono_image_add_stream_data (&assembly->blob, (char*)hash, 20);\n\t\tg_free (name);\n\t\tidx = table->next_idx++;\n\t\trsrc->offset = 0;\n\t\tidx = MONO_IMPLEMENTATION_FILE | (idx << MONO_IMPLEMENTATION_BITS);\n\t} else {\n\t\tchar sizebuf [4];\n\t\tchar *data;\n\t\tguint len;\n\t\tif (rsrc->data) {\n\t\t\tdata = mono_array_addr (rsrc->data, char, 0);\n\t\t\tlen = mono_array_length (rsrc->data);\n\t\t} else {\n\t\t\tdata = NULL;\n\t\t\tlen = 0;\n\t\t}\n\t\toffset = len;\n\t\tsizebuf [0] = offset; sizebuf [1] = offset >> 8;\n\t\tsizebuf [2] = offset >> 16; sizebuf [3] = offset >> 24;\n\t\trsrc->offset = mono_image_add_stream_data (&assembly->resources, sizebuf, 4);\n\t\tmono_image_add_stream_data (&assembly->resources, data, len);\n\n\t\tif (!mb->is_main)\n\t\t\t/* \n\t\t\t * The entry should be emitted into the MANIFESTRESOURCE table of \n\t\t\t * the main module, but that needs to reference the FILE table\n\t\t\t * which isn't emitted yet.\n\t\t\t */\n\t\t\treturn;\n\t\telse\n\t\t\tidx = 0;\n\t}\n\n\tassembly_add_resource_manifest (mb, assembly, rsrc, idx);\n}\n\nstatic void\nset_version_from_string (MonoString *version, guint32 *values)\n{\n\tgchar *ver, *p, *str;\n\tguint32 i;\n\t\n\tvalues [MONO_ASSEMBLY_MAJOR_VERSION] = 0;\n\tvalues [MONO_ASSEMBLY_MINOR_VERSION] = 0;\n\tvalues [MONO_ASSEMBLY_REV_NUMBER] = 0;\n\tvalues [MONO_ASSEMBLY_BUILD_NUMBER] = 0;\n\tif (!version)\n\t\treturn;\n\tver = str = mono_string_to_utf8 (version);\n\tfor (i = 0; i < 4; ++i) {\n\t\tvalues [MONO_ASSEMBLY_MAJOR_VERSION + i] = strtol (ver, &p, 10);\n\t\tswitch (*p) {\n\t\tcase '.':\n\t\t\tp++;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\t/* handle Revision and Build */\n\t\t\tp++;\n\t\t\tbreak;\n\t\t}\n\t\tver = p;\n\t}\n\tg_free (str);\n}\n\nstatic guint32\nload_public_key (MonoArray *pkey, MonoDynamicImage *assembly) {\n\tgsize len;\n\tguint32 token = 0;\n\tchar blob_size [6];\n\tchar *b = blob_size;\n\n\tif (!pkey)\n\t\treturn token;\n\n\tlen = mono_array_length (pkey);\n\tmono_metadata_encode_value (len, b, &b);\n\ttoken = mono_image_add_stream_data (&assembly->blob, blob_size, b - blob_size);\n\tmono_image_add_stream_data (&assembly->blob, mono_array_addr (pkey, char, 0), len);\n\n\tassembly->public_key = g_malloc (len);\n\tmemcpy (assembly->public_key, mono_array_addr (pkey, char, 0), len);\n\tassembly->public_key_len = len;\n\n\t/* Special case: check for ECMA key (16 bytes) */\n\tif ((len == MONO_ECMA_KEY_LENGTH) && mono_is_ecma_key (mono_array_addr (pkey, char, 0), len)) {\n\t\t/* In this case we must reserve 128 bytes (1024 bits) for the signature */\n\t\tassembly->strong_name_size = MONO_DEFAULT_PUBLIC_KEY_LENGTH;\n\t} else if (len >= MONO_PUBLIC_KEY_HEADER_LENGTH + MONO_MINIMUM_PUBLIC_KEY_LENGTH) {\n\t\t/* minimum key size (in 2.0) is 384 bits */\n\t\tassembly->strong_name_size = len - MONO_PUBLIC_KEY_HEADER_LENGTH;\n\t} else {\n\t\t/* FIXME - verifier */\n\t\tg_warning (\"Invalid public key length: %d bits (total: %d)\", (int)MONO_PUBLIC_KEY_BIT_SIZE (len), (int)len);\n\t\tassembly->strong_name_size = MONO_DEFAULT_PUBLIC_KEY_LENGTH; /* to be safe */\n\t}\n\tassembly->strong_name = g_malloc0 (assembly->strong_name_size);\n\n\treturn token;\n}\n\nstatic void\nmono_image_emit_manifest (MonoReflectionModuleBuilder *moduleb)\n{\n\tMonoDynamicTable *table;\n\tMonoDynamicImage *assembly;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoDomain *domain;\n\tguint32 *values;\n\tint i;\n\tguint32 module_index;\n\n\tassemblyb = moduleb->assemblyb;\n\tassembly = moduleb->dynamic_image;\n\tdomain = mono_object_domain (assemblyb);\n\n\t/* Emit ASSEMBLY table */\n\ttable = &assembly->tables [MONO_TABLE_ASSEMBLY];\n\talloc_table (table, 1);\n\tvalues = table->values + MONO_ASSEMBLY_SIZE;\n\tvalues [MONO_ASSEMBLY_HASH_ALG] = assemblyb->algid? assemblyb->algid: ASSEMBLY_HASH_SHA1;\n\tvalues [MONO_ASSEMBLY_NAME] = string_heap_insert_mstring (&assembly->sheap, assemblyb->name);\n\tif (assemblyb->culture) {\n\t\tvalues [MONO_ASSEMBLY_CULTURE] = string_heap_insert_mstring (&assembly->sheap, assemblyb->culture);\n\t} else {\n\t\tvalues [MONO_ASSEMBLY_CULTURE] = string_heap_insert (&assembly->sheap, \"\");\n\t}\n\tvalues [MONO_ASSEMBLY_PUBLIC_KEY] = load_public_key (assemblyb->public_key, assembly);\n\tvalues [MONO_ASSEMBLY_FLAGS] = assemblyb->flags;\n\tset_version_from_string (assemblyb->version, values);\n\n\t/* Emit FILE + EXPORTED_TYPE table */\n\tmodule_index = 0;\n\tfor (i = 0; i < mono_array_length (assemblyb->modules); ++i) {\n\t\tint j;\n\t\tMonoReflectionModuleBuilder *file_module = \n\t\t\tmono_array_get (assemblyb->modules, MonoReflectionModuleBuilder*, i);\n\t\tif (file_module != moduleb) {\n\t\t\tmono_image_fill_file_table (domain, (MonoReflectionModule*)file_module, assembly);\n\t\t\tmodule_index ++;\n\t\t\tif (file_module->types) {\n\t\t\t\tfor (j = 0; j < file_module->num_types; ++j) {\n\t\t\t\t\tMonoReflectionTypeBuilder *tb = mono_array_get (file_module->types, MonoReflectionTypeBuilder*, j);\n\t\t\t\t\tmono_image_fill_export_table (domain, tb, module_index, 0, assembly);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (assemblyb->loaded_modules) {\n\t\tfor (i = 0; i < mono_array_length (assemblyb->loaded_modules); ++i) {\n\t\t\tMonoReflectionModule *file_module = \n\t\t\t\tmono_array_get (assemblyb->loaded_modules, MonoReflectionModule*, i);\n\t\t\tmono_image_fill_file_table (domain, file_module, assembly);\n\t\t\tmodule_index ++;\n\t\t\tmono_image_fill_export_table_from_module (domain, file_module, module_index, assembly);\n\t\t}\n\t}\n\tif (assemblyb->type_forwarders)\n\t\tmono_image_fill_export_table_from_type_forwarders (assemblyb, assembly);\n\n\t/* Emit MANIFESTRESOURCE table */\n\tmodule_index = 0;\n\tfor (i = 0; i < mono_array_length (assemblyb->modules); ++i) {\n\t\tint j;\n\t\tMonoReflectionModuleBuilder *file_module = \n\t\t\tmono_array_get (assemblyb->modules, MonoReflectionModuleBuilder*, i);\n\t\t/* The table for the main module is emitted later */\n\t\tif (file_module != moduleb) {\n\t\t\tmodule_index ++;\n\t\t\tif (file_module->resources) {\n\t\t\t\tint len = mono_array_length (file_module->resources);\n\t\t\t\tfor (j = 0; j < len; ++j) {\n\t\t\t\t\tMonoReflectionResource* res = (MonoReflectionResource*)mono_array_addr (file_module->resources, MonoReflectionResource, j);\n\t\t\t\t\tassembly_add_resource_manifest (file_module, assembly, res, MONO_IMPLEMENTATION_FILE | (module_index << MONO_IMPLEMENTATION_BITS));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\t\n}\n\n#ifndef DISABLE_REFLECTION_EMIT_SAVE\n\n/*\n * mono_image_build_metadata() will fill the info in all the needed metadata tables\n * for the modulebuilder @moduleb.\n * At the end of the process, method and field tokens are fixed up and the \n * on-disk compressed metadata representation is created.\n */\nvoid\nmono_image_build_metadata (MonoReflectionModuleBuilder *moduleb)\n{\n\tMonoDynamicTable *table;\n\tMonoDynamicImage *assembly;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoDomain *domain;\n\tGPtrArray *types;\n\tguint32 *values;\n\tint i, j;\n\n\tassemblyb = moduleb->assemblyb;\n\tassembly = moduleb->dynamic_image;\n\tdomain = mono_object_domain (assemblyb);\n\n\tif (assembly->text_rva)\n\t\treturn;\n\n\tassembly->text_rva = START_TEXT_RVA;\n\n\tif (moduleb->is_main) {\n\t\tmono_image_emit_manifest (moduleb);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_TYPEDEF];\n\ttable->rows = 1; /* .<Module> */\n\ttable->next_idx++;\n\talloc_table (table, table->rows);\n\t/*\n\t * Set the first entry.\n\t */\n\tvalues = table->values + table->columns;\n\tvalues [MONO_TYPEDEF_FLAGS] = 0;\n\tvalues [MONO_TYPEDEF_NAME] = string_heap_insert (&assembly->sheap, \"<Module>\") ;\n\tvalues [MONO_TYPEDEF_NAMESPACE] = string_heap_insert (&assembly->sheap, \"\") ;\n\tvalues [MONO_TYPEDEF_EXTENDS] = 0;\n\tvalues [MONO_TYPEDEF_FIELD_LIST] = 1;\n\tvalues [MONO_TYPEDEF_METHOD_LIST] = 1;\n\n\t/* \n\t * handle global methods \n\t * FIXME: test what to do when global methods are defined in multiple modules.\n\t */\n\tif (moduleb->global_methods) {\n\t\ttable = &assembly->tables [MONO_TABLE_METHOD];\n\t\ttable->rows += mono_array_length (moduleb->global_methods);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_methods); ++i)\n\t\t\tmono_image_get_method_info (\n\t\t\t\tmono_array_get (moduleb->global_methods, MonoReflectionMethodBuilder*, i), assembly);\n\t}\n\tif (moduleb->global_fields) {\n\t\ttable = &assembly->tables [MONO_TABLE_FIELD];\n\t\ttable->rows += mono_array_length (moduleb->global_fields);\n\t\talloc_table (table, table->rows);\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_fields); ++i)\n\t\t\tmono_image_get_field_info (\n\t\t\t\tmono_array_get (moduleb->global_fields, MonoReflectionFieldBuilder*, i), assembly);\n\t}\n\n\ttable = &assembly->tables [MONO_TABLE_MODULE];\n\talloc_table (table, 1);\n\tmono_image_fill_module_table (domain, moduleb, assembly);\n\n\t/* Collect all types into a list sorted by their table_idx */\n\ttypes = g_ptr_array_new ();\n\n\tif (moduleb->types)\n\t\tfor (i = 0; i < moduleb->num_types; ++i) {\n\t\t\tMonoReflectionTypeBuilder *type = mono_array_get (moduleb->types, MonoReflectionTypeBuilder*, i);\n\t\t\tcollect_types (types, type);\n\t\t}\n\n\tg_ptr_array_sort (types, (GCompareFunc)compare_types_by_table_idx);\n\ttable = &assembly->tables [MONO_TABLE_TYPEDEF];\n\ttable->rows += types->len;\n\talloc_table (table, table->rows);\n\n\t/*\n\t * Emit type names + namespaces at one place inside the string heap,\n\t * so load_class_names () needs to touch fewer pages.\n\t */\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *tb = g_ptr_array_index (types, i);\n\t\tstring_heap_insert_mstring (&assembly->sheap, tb->nspace);\n\t}\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *tb = g_ptr_array_index (types, i);\n\t\tstring_heap_insert_mstring (&assembly->sheap, tb->name);\n\t}\n\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *type = g_ptr_array_index (types, i);\n\t\tmono_image_get_type_info (domain, type, assembly);\n\t}\n\n\t/* \n\t * table->rows is already set above and in mono_image_fill_module_table.\n\t */\n\t/* add all the custom attributes at the end, once all the indexes are stable */\n\tmono_image_add_cattrs (assembly, 1, MONO_CUSTOM_ATTR_ASSEMBLY, assemblyb->cattrs);\n\n\t/* CAS assembly permissions */\n\tif (assemblyb->permissions_minimum)\n\t\tmono_image_add_decl_security (assembly, mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1), assemblyb->permissions_minimum);\n\tif (assemblyb->permissions_optional)\n\t\tmono_image_add_decl_security (assembly, mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1), assemblyb->permissions_optional);\n\tif (assemblyb->permissions_refused)\n\t\tmono_image_add_decl_security (assembly, mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1), assemblyb->permissions_refused);\n\n\tmodule_add_cattrs (assembly, moduleb);\n\n\t/* fixup tokens */\n\tmono_g_hash_table_foreach (assembly->token_fixups, (GHFunc)fixup_method, assembly);\n\n\t/* Create the MethodImpl table.  We do this after emitting all methods so we already know\n\t * the final tokens and don't need another fixup pass. */\n\n\tif (moduleb->global_methods) {\n\t\tfor (i = 0; i < mono_array_length (moduleb->global_methods); ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = mono_array_get (\n\t\t\t\tmoduleb->global_methods, MonoReflectionMethodBuilder*, i);\n\t\t\tmono_image_add_methodimpl (assembly, mb);\n\t\t}\n\t}\n\n\tfor (i = 0; i < types->len; ++i) {\n\t\tMonoReflectionTypeBuilder *type = g_ptr_array_index (types, i);\n\t\tif (type->methods) {\n\t\t\tfor (j = 0; j < type->num_methods; ++j) {\n\t\t\t\tMonoReflectionMethodBuilder *mb = mono_array_get (\n\t\t\t\t\ttype->methods, MonoReflectionMethodBuilder*, j);\n\n\t\t\t\tmono_image_add_methodimpl (assembly, mb);\n\t\t\t}\n\t\t}\n\t}\n\n\tg_ptr_array_free (types, TRUE);\n\n\tfixup_cattrs (assembly);\n}\n\n#else /* DISABLE_REFLECTION_EMIT_SAVE */\n\nvoid\nmono_image_build_metadata (MonoReflectionModuleBuilder *moduleb)\n{\n\tg_error (\"This mono runtime was configured with --enable-minimal=reflection_emit_save, so saving of dynamic assemblies is not supported.\");\n}\n\n#endif /* DISABLE_REFLECTION_EMIT_SAVE */\n\n\ntypedef struct {\n\tguint32 import_lookup_table;\n\tguint32 timestamp;\n\tguint32 forwarder;\n\tguint32 name_rva;\n\tguint32 import_address_table_rva;\n} MonoIDT;\n\ntypedef struct {\n\tguint32 name_rva;\n\tguint32 flags;\n} MonoILT;\n\n#ifndef DISABLE_REFLECTION_EMIT\n\n/*\n * mono_image_insert_string:\n * @module: module builder object\n * @str: a string\n *\n * Insert @str into the user string stream of @module.\n */\nguint32\nmono_image_insert_string (MonoReflectionModuleBuilder *module, MonoString *str)\n{\n\tMonoDynamicImage *assembly;\n\tguint32 idx;\n\tchar buf [16];\n\tchar *b = buf;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!module->dynamic_image)\n\t\tmono_image_module_basic_init (module);\n\n\tassembly = module->dynamic_image;\n\t\n\tif (assembly->save) {\n\t\tmono_metadata_encode_value (1 | (str->length * 2), b, &b);\n\t\tidx = mono_image_add_stream_data (&assembly->us, buf, b-buf);\n#if G_BYTE_ORDER != G_LITTLE_ENDIAN\n\t{\n\t\tchar *swapped = g_malloc (2 * mono_string_length (str));\n\t\tconst char *p = (const char*)mono_string_chars (str);\n\n\t\tswap_with_size (swapped, p, 2, mono_string_length (str));\n\t\tmono_image_add_stream_data (&assembly->us, swapped, str->length * 2);\n\t\tg_free (swapped);\n\t}\n#else\n\t\tmono_image_add_stream_data (&assembly->us, (const char*)mono_string_chars (str), str->length * 2);\n#endif\n\t\tmono_image_add_stream_data (&assembly->us, \"\", 1);\n\t} else {\n\t\tidx = assembly->us.index ++;\n\t}\n\n\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (MONO_TOKEN_STRING | idx), str);\n\n\treturn MONO_TOKEN_STRING | idx;\n}\n\nguint32\nmono_image_create_method_token (MonoDynamicImage *assembly, MonoObject *obj, MonoArray *opt_param_types)\n{\n\tMonoClass *klass;\n\tguint32 token = 0;\n\n\tklass = obj->vtable->klass;\n\tif (strcmp (klass->name, \"MonoMethod\") == 0) {\n\t\tMonoMethod *method = ((MonoReflectionMethod *)obj)->method;\n\t\tMonoMethodSignature *sig, *old;\n\t\tguint32 sig_token, parent;\n\t\tint nargs, i;\n\n\t\tg_assert (opt_param_types && (mono_method_signature (method)->sentinelpos >= 0));\n\n\t\tnargs = mono_array_length (opt_param_types);\n\t\told = mono_method_signature (method);\n\t\tsig = mono_metadata_signature_alloc ( &assembly->image, old->param_count + nargs);\n\n\t\tsig->hasthis = old->hasthis;\n\t\tsig->explicit_this = old->explicit_this;\n\t\tsig->call_convention = old->call_convention;\n\t\tsig->generic_param_count = old->generic_param_count;\n\t\tsig->param_count = old->param_count + nargs;\n\t\tsig->sentinelpos = old->param_count;\n\t\tsig->ret = old->ret;\n\n\t\tfor (i = 0; i < old->param_count; i++)\n\t\t\tsig->params [i] = old->params [i];\n\n\t\tfor (i = 0; i < nargs; i++) {\n\t\t\tMonoReflectionType *rt = mono_array_get (opt_param_types, MonoReflectionType *, i);\n\t\t\tsig->params [old->param_count + i] = mono_reflection_type_get_handle (rt);\n\t\t}\n\n\t\tparent = mono_image_typedef_or_ref (assembly, &method->klass->byval_arg);\n\t\tg_assert ((parent & MONO_TYPEDEFORREF_MASK) == MONO_MEMBERREF_PARENT_TYPEREF);\n\t\tparent >>= MONO_TYPEDEFORREF_BITS;\n\n\t\tparent <<= MONO_MEMBERREF_PARENT_BITS;\n\t\tparent |= MONO_MEMBERREF_PARENT_TYPEREF;\n\n\t\tsig_token = method_encode_signature (assembly, sig);\n\t\ttoken = mono_image_get_varargs_method_token (assembly, parent, method->name, sig_token);\n\t} else if (strcmp (klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder *)obj;\n\t\tReflectionMethodBuilder rmb;\n\t\tguint32 parent, sig;\n\t\tchar *name;\n\n\t\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\t\trmb.opt_types = opt_param_types;\n\n\t\tsig = method_builder_encode_signature (assembly, &rmb);\n\n\t\tparent = mono_image_create_token (assembly, obj, TRUE, TRUE);\n\t\tg_assert (mono_metadata_token_table (parent) == MONO_TABLE_METHOD);\n\n\t\tparent = mono_metadata_token_index (parent) << MONO_MEMBERREF_PARENT_BITS;\n\t\tparent |= MONO_MEMBERREF_PARENT_METHODDEF;\n\n\t\tname = mono_string_to_utf8 (rmb.name);\n\t\ttoken = mono_image_get_varargs_method_token (\n\t\t\tassembly, parent, name, sig);\n\t\tg_free (name);\n\t} else {\n\t\tg_error (\"requested method token for %s\\n\", klass->name);\n\t}\n\n\treturn token;\n}\n\n/*\n * mono_image_create_token:\n * @assembly: a dynamic assembly\n * @obj:\n * @register_token: Whenever to register the token in the assembly->tokens hash. \n *\n * Get a token to insert in the IL code stream for the given MemberInfo.\n * The metadata emission routines need to pass FALSE as REGISTER_TOKEN, since by that time, \n * the table_idx-es were recomputed, so registering the token would overwrite an existing \n * entry.\n */\nguint32\nmono_image_create_token (MonoDynamicImage *assembly, MonoObject *obj, \n\t\t\t\t\t\t gboolean create_methodspec, gboolean register_token)\n{\n\tMonoClass *klass;\n\tguint32 token = 0;\n\n\tklass = obj->vtable->klass;\n\n\t/* Check for user defined reflection objects */\n\t/* TypeDelegator is the only corlib type which doesn't look like a MonoReflectionType */\n\tif (klass->image != mono_defaults.corlib || (strcmp (klass->name, \"TypeDelegator\") == 0))\n\t\tmono_raise_exception (mono_get_exception_not_supported (\"User defined subclasses of System.Type are not yet supported\")); \\\n\n\tif (strcmp (klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder *)obj;\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)mb->type;\n\n\t\tif (tb->module->dynamic_image == assembly && !tb->generic_params && !mb->generic_params)\n\t\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t\telse\n\t\t\ttoken = mono_image_get_methodbuilder_token (assembly, mb, create_methodspec);\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, mono_string_to_utf8 (mb->name));*/\n\t} else if (strcmp (klass->name, \"ConstructorBuilder\") == 0) {\n\t\tMonoReflectionCtorBuilder *mb = (MonoReflectionCtorBuilder *)obj;\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)mb->type;\n\n\t\tif (tb->module->dynamic_image == assembly && !tb->generic_params)\n\t\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t\telse\n\t\t\ttoken = mono_image_get_ctorbuilder_token (assembly, mb);\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, mono_string_to_utf8 (mb->name));*/\n\t} else if (strcmp (klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder *)obj;\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)fb->typeb;\n\t\tif (tb->generic_params) {\n\t\t\ttoken = mono_image_get_generic_field_token (assembly, fb);\n\t\t} else {\n\t\t\ttoken = fb->table_idx | MONO_TOKEN_FIELD_DEF;\n\t\t}\n\t} else if (strcmp (klass->name, \"TypeBuilder\") == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)obj;\n\t\ttoken = tb->table_idx | MONO_TOKEN_TYPE_DEF;\n\t} else if (strcmp (klass->name, \"MonoType\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\tMonoClass *mc = mono_class_from_mono_type (type);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref_full (assembly, type, mc->generic_container == NULL));\n\t} else if (strcmp (klass->name, \"GenericTypeParameterBuilder\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref (assembly, type));\n\t} else if (strcmp (klass->name, \"MonoGenericClass\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref (assembly, type));\n\t} else if (strcmp (klass->name, \"MonoCMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericCMethod\") == 0) {\n\t\tMonoReflectionMethod *m = (MonoReflectionMethod *)obj;\n\t\tif (m->method->is_inflated) {\n\t\t\tif (create_methodspec)\n\t\t\t\ttoken = mono_image_get_methodspec_token (assembly, m->method);\n\t\t\telse\n\t\t\t\ttoken = mono_image_get_inflated_method_token (assembly, m->method);\n\t\t} else if ((m->method->klass->image == &assembly->image) &&\n\t\t\t !m->method->klass->generic_class) {\n\t\t\tstatic guint32 method_table_idx = 0xffffff;\n\t\t\tif (m->method->klass->wastypebuilder) {\n\t\t\t\t/* we use the same token as the one that was assigned\n\t\t\t\t * to the Methodbuilder.\n\t\t\t\t * FIXME: do the equivalent for Fields.\n\t\t\t\t */\n\t\t\t\ttoken = m->method->token;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Each token should have a unique index, but the indexes are\n\t\t\t\t * assigned by managed code, so we don't know about them. An\n\t\t\t\t * easy solution is to count backwards...\n\t\t\t\t */\n\t\t\t\tmethod_table_idx --;\n\t\t\t\ttoken = MONO_TOKEN_METHOD_DEF | method_table_idx;\n\t\t\t}\n\t\t} else {\n\t\t\ttoken = mono_image_get_methodref_token (assembly, m->method, create_methodspec);\n\t\t}\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, m->method->name);*/\n\t} else if (strcmp (klass->name, \"MonoField\") == 0) {\n\t\tMonoReflectionField *f = (MonoReflectionField *)obj;\n\t\tif ((f->field->parent->image == &assembly->image) && !is_field_on_inst (f->field)) {\n\t\t\tstatic guint32 field_table_idx = 0xffffff;\n\t\t\tfield_table_idx --;\n\t\t\ttoken = MONO_TOKEN_FIELD_DEF | field_table_idx;\n\t\t} else {\n\t\t\ttoken = mono_image_get_fieldref_token (assembly, f);\n\t\t}\n\t\t/*g_print (\"got token 0x%08x for %s\\n\", token, f->field->name);*/\n\t} else if (strcmp (klass->name, \"MonoArrayMethod\") == 0) {\n\t\tMonoReflectionArrayMethod *m = (MonoReflectionArrayMethod *)obj;\n\t\ttoken = mono_image_get_array_token (assembly, m);\n\t} else if (strcmp (klass->name, \"SignatureHelper\") == 0) {\n\t\tMonoReflectionSigHelper *s = (MonoReflectionSigHelper*)obj;\n\t\ttoken = MONO_TOKEN_SIGNATURE | mono_image_get_sighelper_token (assembly, s);\n\t} else if (strcmp (klass->name, \"EnumBuilder\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\tmono_image_typedef_or_ref (assembly, type));\n\t} else if (strcmp (klass->name, \"FieldOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionFieldOnTypeBuilderInst *f = (MonoReflectionFieldOnTypeBuilderInst*)obj;\n\t\ttoken = mono_image_get_field_on_inst_token (assembly, f);\n\t} else if (strcmp (klass->name, \"ConstructorOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionCtorOnTypeBuilderInst *c = (MonoReflectionCtorOnTypeBuilderInst*)obj;\n\t\ttoken = mono_image_get_ctor_on_inst_token (assembly, c, create_methodspec);\n\t} else if (strcmp (klass->name, \"MethodOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionMethodOnTypeBuilderInst *m = (MonoReflectionMethodOnTypeBuilderInst*)obj;\n\t\ttoken = mono_image_get_method_on_inst_token (assembly, m, create_methodspec);\n\t} else if (is_sre_array (klass) || is_sre_byref (klass) || is_sre_pointer (klass)) {\n\t\tMonoReflectionType *type = (MonoReflectionType *)obj;\n\t\ttoken = mono_metadata_token_from_dor (\n\t\t\t\tmono_image_typedef_or_ref (assembly, mono_reflection_type_get_handle (type)));\n\t} else {\n\t\tg_error (\"requested token for %s\\n\", klass->name);\n\t}\n\n\tif (register_token)\n\t\tmono_image_register_token (assembly, token, obj);\n\n\treturn token;\n}\n\n/*\n * mono_image_register_token:\n *\n *   Register the TOKEN->OBJ mapping in the mapping table in ASSEMBLY. This is required for\n * the Module.ResolveXXXToken () methods to work.\n */\nvoid\nmono_image_register_token (MonoDynamicImage *assembly, guint32 token, MonoObject *obj)\n{\n\tMonoObject *prev = mono_g_hash_table_lookup (assembly->tokens, GUINT_TO_POINTER (token));\n\tif (prev) {\n\t\t/* There could be multiple MethodInfo objects with the same token */\n\t\t//g_assert (prev == obj);\n\t} else {\n\t\tmono_g_hash_table_insert (assembly->tokens, GUINT_TO_POINTER (token), obj);\n\t}\n}\n\nstatic MonoDynamicImage*\ncreate_dynamic_mono_image (MonoDynamicAssembly *assembly, char *assembly_name, char *module_name)\n{\n\tstatic const guchar entrycode [16] = {0xff, 0x25, 0};\n\tMonoDynamicImage *image;\n\tint i;\n\n\tconst char *version;\n\n\tif (!strcmp (mono_get_runtime_info ()->framework_version, \"2.1\"))\n\t\tversion = \"v2.0.50727\"; /* HACK: SL 2 enforces the .net 2 metadata version */\n\telse\n\t\tversion = mono_get_runtime_info ()->runtime_version;\n\n#if HAVE_BOEHM_GC\n\timage = GC_MALLOC (sizeof (MonoDynamicImage));\n#else\n\timage = g_new0 (MonoDynamicImage, 1);\n#endif\n\t\n\tmono_profiler_module_event (&image->image, MONO_PROFILE_START_LOAD);\n\t\n\t/*g_print (\"created image %p\\n\", image);*/\n\t/* keep in sync with image.c */\n\timage->image.name = assembly_name;\n\timage->image.assembly_name = image->image.name; /* they may be different */\n\timage->image.module_name = module_name;\n\timage->image.version = g_strdup (version);\n\timage->image.md_version_major = 1;\n\timage->image.md_version_minor = 1;\n\timage->image.dynamic = TRUE;\n\n\timage->image.references = g_new0 (MonoAssembly*, 1);\n\timage->image.references [0] = NULL;\n\n\tmono_image_init (&image->image);\n\n\timage->token_fixups = mono_g_hash_table_new_type ((GHashFunc)mono_object_hash, NULL, MONO_HASH_KEY_GC);\n\timage->method_to_table_idx = g_hash_table_new (NULL, NULL);\n\timage->field_to_table_idx = g_hash_table_new (NULL, NULL);\n\timage->method_aux_hash = g_hash_table_new (NULL, NULL);\n\timage->handleref = g_hash_table_new (NULL, NULL);\n\timage->tokens = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_VALUE_GC);\n\timage->generic_def_objects = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_VALUE_GC);\n\timage->methodspec = mono_g_hash_table_new_type ((GHashFunc)mono_object_hash, NULL, MONO_HASH_KEY_GC);\n\timage->typespec = g_hash_table_new ((GHashFunc)mono_metadata_type_hash, (GCompareFunc)mono_metadata_type_equal);\n\timage->typeref = g_hash_table_new ((GHashFunc)mono_metadata_type_hash, (GCompareFunc)mono_metadata_type_equal);\n\timage->blob_cache = g_hash_table_new ((GHashFunc)mono_blob_entry_hash, (GCompareFunc)mono_blob_entry_equal);\n\timage->gen_params = g_ptr_array_new ();\n\n\t/*g_print (\"string heap create for image %p (%s)\\n\", image, module_name);*/\n\tstring_heap_init (&image->sheap);\n\tmono_image_add_stream_data (&image->us, \"\", 1);\n\tadd_to_blob_cached (image, (char*) \"\", 1, NULL, 0);\n\t/* import tables... */\n\tmono_image_add_stream_data (&image->code, (char*)entrycode, sizeof (entrycode));\n\timage->iat_offset = mono_image_add_stream_zero (&image->code, 8); /* two IAT entries */\n\timage->idt_offset = mono_image_add_stream_zero (&image->code, 2 * sizeof (MonoIDT)); /* two IDT entries */\n\timage->imp_names_offset = mono_image_add_stream_zero (&image->code, 2); /* flags for name entry */\n\tmono_image_add_stream_data (&image->code, \"_CorExeMain\", 12);\n\tmono_image_add_stream_data (&image->code, \"mscoree.dll\", 12);\n\timage->ilt_offset = mono_image_add_stream_zero (&image->code, 8); /* two ILT entries */\n\tstream_data_align (&image->code);\n\n\timage->cli_header_offset = mono_image_add_stream_zero (&image->code, sizeof (MonoCLIHeader));\n\n\tfor (i=0; i < MONO_TABLE_NUM; ++i) {\n\t\timage->tables [i].next_idx = 1;\n\t\timage->tables [i].columns = table_sizes [i];\n\t}\n\n\timage->image.assembly = (MonoAssembly*)assembly;\n\timage->run = assembly->run;\n\timage->save = assembly->save;\n\timage->pe_kind = 0x1; /* ILOnly */\n\timage->machine = 0x14c; /* I386 */\n\t\n\tmono_profiler_module_loaded (&image->image, MONO_PROFILE_OK);\n\n\treturn image;\n}\n#endif\n\nstatic void\nfree_blob_cache_entry (gpointer key, gpointer val, gpointer user_data)\n{\n\tg_free (key);\n}\n\nvoid\nmono_dynamic_image_free (MonoDynamicImage *image)\n{\n\tMonoDynamicImage *di = image;\n\tGList *list;\n\tint i;\n\n\tif (di->methodspec)\n\t\tmono_g_hash_table_destroy (di->methodspec);\n\tif (di->typespec)\n\t\tg_hash_table_destroy (di->typespec);\n\tif (di->typeref)\n\t\tg_hash_table_destroy (di->typeref);\n\tif (di->handleref)\n\t\tg_hash_table_destroy (di->handleref);\n\tif (di->tokens)\n\t\tmono_g_hash_table_destroy (di->tokens);\n\tif (di->generic_def_objects)\n\t\tmono_g_hash_table_destroy (di->generic_def_objects);\n\tif (di->blob_cache) {\n\t\tg_hash_table_foreach (di->blob_cache, free_blob_cache_entry, NULL);\n\t\tg_hash_table_destroy (di->blob_cache);\n\t}\n\tif (di->standalonesig_cache)\n\t\tg_hash_table_destroy (di->standalonesig_cache);\n\tfor (list = di->array_methods; list; list = list->next) {\n\t\tArrayMethod *am = (ArrayMethod *)list->data;\n\t\tg_free (am->sig);\n\t\tg_free (am->name);\n\t\tg_free (am);\n\t}\n\tg_list_free (di->array_methods);\n\tif (di->gen_params) {\n\t\tfor (i = 0; i < di->gen_params->len; i++) {\n\t\t\tGenericParamTableEntry *entry = g_ptr_array_index (di->gen_params, i);\n\t\t\tif (entry->gparam->type.type) {\n\t\t\t\tMonoGenericParam *param = entry->gparam->type.type->data.generic_param;\n\t\t\t\tg_free ((char*)mono_generic_param_info (param)->name);\n\t\t\t\tg_free (param);\n\t\t\t}\n\t\t\tg_free (entry);\n\t\t}\n\t \tg_ptr_array_free (di->gen_params, TRUE);\n\t}\n\tif (di->token_fixups)\n\t\tmono_g_hash_table_destroy (di->token_fixups);\n\tif (di->method_to_table_idx)\n\t\tg_hash_table_destroy (di->method_to_table_idx);\n\tif (di->field_to_table_idx)\n\t\tg_hash_table_destroy (di->field_to_table_idx);\n\tif (di->method_aux_hash)\n\t\tg_hash_table_destroy (di->method_aux_hash);\n\tg_free (di->strong_name);\n\tg_free (di->win32_res);\n\tif (di->public_key)\n\t\tg_free (di->public_key);\n\n\t/*g_print (\"string heap destroy for image %p\\n\", di);*/\n\tmono_dynamic_stream_reset (&di->sheap);\n\tmono_dynamic_stream_reset (&di->code);\n\tmono_dynamic_stream_reset (&di->resources);\n\tmono_dynamic_stream_reset (&di->us);\n\tmono_dynamic_stream_reset (&di->blob);\n\tmono_dynamic_stream_reset (&di->tstream);\n\tmono_dynamic_stream_reset (&di->guid);\n\tfor (i = 0; i < MONO_TABLE_NUM; ++i) {\n\t\tg_free (di->tables [i].values);\n\t}\n}\t\n\n#ifndef DISABLE_REFLECTION_EMIT\n\n/*\n * mono_image_basic_init:\n * @assembly: an assembly builder object\n *\n * Create the MonoImage that represents the assembly builder and setup some\n * of the helper hash table and the basic metadata streams.\n */\nvoid\nmono_image_basic_init (MonoReflectionAssemblyBuilder *assemblyb)\n{\n\tMonoDynamicAssembly *assembly;\n\tMonoDynamicImage *image;\n\tMonoDomain *domain = mono_object_domain (assemblyb);\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (assemblyb->dynamic_assembly)\n\t\treturn;\n\n#if HAVE_BOEHM_GC\n\tassembly = assemblyb->dynamic_assembly = GC_MALLOC (sizeof (MonoDynamicAssembly));\n#else\n\tassembly = assemblyb->dynamic_assembly = g_new0 (MonoDynamicAssembly, 1);\n#endif\n\n\tmono_profiler_assembly_event (&assembly->assembly, MONO_PROFILE_START_LOAD);\n\t\n\tassembly->assembly.ref_count = 1;\n\tassembly->assembly.dynamic = TRUE;\n\tassembly->assembly.corlib_internal = assemblyb->corlib_internal;\n\tassemblyb->assembly.assembly = (MonoAssembly*)assembly;\n\tassembly->assembly.basedir = mono_string_to_utf8 (assemblyb->dir);\n\tif (assemblyb->culture)\n\t\tassembly->assembly.aname.culture = mono_string_to_utf8 (assemblyb->culture);\n\telse\n\t\tassembly->assembly.aname.culture = g_strdup (\"\");\n\n        if (assemblyb->version) {\n\t\t\tchar *vstr = mono_string_to_utf8 (assemblyb->version);\n\t\t\tchar **version = g_strsplit (vstr, \".\", 4);\n\t\t\tchar **parts = version;\n\t\t\tassembly->assembly.aname.major = atoi (*parts++);\n\t\t\tassembly->assembly.aname.minor = atoi (*parts++);\n\t\t\tassembly->assembly.aname.build = *parts != NULL ? atoi (*parts++) : 0;\n\t\t\tassembly->assembly.aname.revision = *parts != NULL ? atoi (*parts) : 0;\n\n\t\t\tg_strfreev (version);\n\t\t\tg_free (vstr);\n        } else {\n\t\t\tassembly->assembly.aname.major = 0;\n\t\t\tassembly->assembly.aname.minor = 0;\n\t\t\tassembly->assembly.aname.build = 0;\n\t\t\tassembly->assembly.aname.revision = 0;\n        }\n\n\tassembly->run = assemblyb->access != 2;\n\tassembly->save = assemblyb->access != 1;\n\tassembly->domain = domain;\n\n\timage = create_dynamic_mono_image (assembly, mono_string_to_utf8 (assemblyb->name), g_strdup (\"RefEmit_YouForgotToDefineAModule\"));\n\timage->initial_image = TRUE;\n\tassembly->assembly.aname.name = image->image.name;\n\tassembly->assembly.image = &image->image;\n\tif (assemblyb->pktoken && assemblyb->pktoken->max_length) {\n\t\t/* -1 to correct for the trailing NULL byte */\n\t\tif (assemblyb->pktoken->max_length != MONO_PUBLIC_KEY_TOKEN_LENGTH - 1) {\n\t\t\tg_error (\"Public key token length invalid for assembly %s: %i\", assembly->assembly.aname.name, assemblyb->pktoken->max_length);\n\t\t}\n\t\tmemcpy (&assembly->assembly.aname.public_key_token, mono_array_addr (assemblyb->pktoken, guint8, 0), assemblyb->pktoken->max_length);\t\t\n\t}\n\n\tmono_domain_assemblies_lock (domain);\n\tdomain->domain_assemblies = g_slist_prepend (domain->domain_assemblies, assembly);\n\tmono_domain_assemblies_unlock (domain);\n\n\tregister_assembly (mono_object_domain (assemblyb), &assemblyb->assembly, &assembly->assembly);\n\t\n\tmono_profiler_assembly_loaded (&assembly->assembly, MONO_PROFILE_OK);\n\t\n\tmono_assembly_invoke_load_hook ((MonoAssembly*)assembly);\n}\n\n#endif /* !DISABLE_REFLECTION_EMIT */\n\n#ifndef DISABLE_REFLECTION_EMIT_SAVE\n\nstatic int\ncalc_section_size (MonoDynamicImage *assembly)\n{\n\tint nsections = 0;\n\n\t/* alignment constraints */\n\tmono_image_add_stream_zero (&assembly->code, 4 - (assembly->code.index % 4));\n\tg_assert ((assembly->code.index % 4) == 0);\n\tassembly->meta_size += 3;\n\tassembly->meta_size &= ~3;\n\tmono_image_add_stream_zero (&assembly->resources, 4 - (assembly->resources.index % 4));\n\tg_assert ((assembly->resources.index % 4) == 0);\n\n\tassembly->sections [MONO_SECTION_TEXT].size = assembly->meta_size + assembly->code.index + assembly->resources.index + assembly->strong_name_size;\n\tassembly->sections [MONO_SECTION_TEXT].attrs = SECT_FLAGS_HAS_CODE | SECT_FLAGS_MEM_EXECUTE | SECT_FLAGS_MEM_READ;\n\tnsections++;\n\n\tif (assembly->win32_res) {\n\t\tguint32 res_size = (assembly->win32_res_size + 3) & ~3;\n\n\t\tassembly->sections [MONO_SECTION_RSRC].size = res_size;\n\t\tassembly->sections [MONO_SECTION_RSRC].attrs = SECT_FLAGS_HAS_INITIALIZED_DATA | SECT_FLAGS_MEM_READ;\n\t\tnsections++;\n\t}\n\n\tassembly->sections [MONO_SECTION_RELOC].size = 12;\n\tassembly->sections [MONO_SECTION_RELOC].attrs = SECT_FLAGS_MEM_READ | SECT_FLAGS_MEM_DISCARDABLE | SECT_FLAGS_HAS_INITIALIZED_DATA;\n\tnsections++;\n\n\treturn nsections;\n}\n\ntypedef struct {\n\tguint32 id;\n\tguint32 offset;\n\tGSList *children;\n\tMonoReflectionWin32Resource *win32_res; /* Only for leaf nodes */\n} ResTreeNode;\n\nstatic int\nresource_tree_compare_by_id (gconstpointer a, gconstpointer b)\n{\n\tResTreeNode *t1 = (ResTreeNode*)a;\n\tResTreeNode *t2 = (ResTreeNode*)b;\n\n\treturn t1->id - t2->id;\n}\n\n/*\n * resource_tree_create:\n *\n *  Organize the resources into a resource tree.\n */\nstatic ResTreeNode *\nresource_tree_create (MonoArray *win32_resources)\n{\n\tResTreeNode *tree, *res_node, *type_node, *lang_node;\n\tGSList *l;\n\tint i;\n\n\ttree = g_new0 (ResTreeNode, 1);\n\t\n\tfor (i = 0; i < mono_array_length (win32_resources); ++i) {\n\t\tMonoReflectionWin32Resource *win32_res =\n\t\t\t(MonoReflectionWin32Resource*)mono_array_addr (win32_resources, MonoReflectionWin32Resource, i);\n\n\t\t/* Create node */\n\n\t\t/* FIXME: BUG: this stores managed references in unmanaged memory */\n\t\tlang_node = g_new0 (ResTreeNode, 1);\n\t\tlang_node->id = win32_res->lang_id;\n\t\tlang_node->win32_res = win32_res;\n\n\t\t/* Create type node if neccesary */\n\t\ttype_node = NULL;\n\t\tfor (l = tree->children; l; l = l->next)\n\t\t\tif (((ResTreeNode*)(l->data))->id == win32_res->res_type) {\n\t\t\t\ttype_node = (ResTreeNode*)l->data;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!type_node) {\n\t\t\ttype_node = g_new0 (ResTreeNode, 1);\n\t\t\ttype_node->id = win32_res->res_type;\n\n\t\t\t/* \n\t\t\t * The resource types have to be sorted otherwise\n\t\t\t * Windows Explorer can't display the version information.\n\t\t\t */\n\t\t\ttree->children = g_slist_insert_sorted (tree->children, \n\t\t\t\ttype_node, resource_tree_compare_by_id);\n\t\t}\n\n\t\t/* Create res node if neccesary */\n\t\tres_node = NULL;\n\t\tfor (l = type_node->children; l; l = l->next)\n\t\t\tif (((ResTreeNode*)(l->data))->id == win32_res->res_id) {\n\t\t\t\tres_node = (ResTreeNode*)l->data;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif (!res_node) {\n\t\t\tres_node = g_new0 (ResTreeNode, 1);\n\t\t\tres_node->id = win32_res->res_id;\n\t\t\ttype_node->children = g_slist_append (type_node->children, res_node);\n\t\t}\n\n\t\tres_node->children = g_slist_append (res_node->children, lang_node);\n\t}\n\n\treturn tree;\n}\n\n/*\n * resource_tree_encode:\n * \n *   Encode the resource tree into the format used in the PE file.\n */\nstatic void\nresource_tree_encode (ResTreeNode *node, char *begin, char *p, char **endbuf)\n{\n\tchar *entries;\n\tMonoPEResourceDir dir;\n\tMonoPEResourceDirEntry dir_entry;\n\tMonoPEResourceDataEntry data_entry;\n\tGSList *l;\n\tguint32 res_id_entries;\n\n\t/*\n\t * For the format of the resource directory, see the article\n\t * \"An In-Depth Look into the Win32 Portable Executable File Format\" by\n\t * Matt Pietrek\n\t */\n\n\tmemset (&dir, 0, sizeof (dir));\n\tmemset (&dir_entry, 0, sizeof (dir_entry));\n\tmemset (&data_entry, 0, sizeof (data_entry));\n\n\tg_assert (sizeof (dir) == 16);\n\tg_assert (sizeof (dir_entry) == 8);\n\tg_assert (sizeof (data_entry) == 16);\n\n\tnode->offset = p - begin;\n\n\t/* IMAGE_RESOURCE_DIRECTORY */\n\tres_id_entries = g_slist_length (node->children);\n\tdir.res_id_entries = GUINT16_TO_LE (res_id_entries);\n\n\tmemcpy (p, &dir, sizeof (dir));\n\tp += sizeof (dir);\n\n\t/* Reserve space for entries */\n\tentries = p;\n\tp += sizeof (dir_entry) * res_id_entries;\n\n\t/* Write children */\n\tfor (l = node->children; l; l = l->next) {\n\t\tResTreeNode *child = (ResTreeNode*)l->data;\n\n\t\tif (child->win32_res) {\n\t\t\tguint32 size;\n\n\t\t\tchild->offset = p - begin;\n\n\t\t\t/* IMAGE_RESOURCE_DATA_ENTRY */\n\t\t\tdata_entry.rde_data_offset = GUINT32_TO_LE (p - begin + sizeof (data_entry));\n\t\t\tsize = mono_array_length (child->win32_res->res_data);\n\t\t\tdata_entry.rde_size = GUINT32_TO_LE (size);\n\n\t\t\tmemcpy (p, &data_entry, sizeof (data_entry));\n\t\t\tp += sizeof (data_entry);\n\n\t\t\tmemcpy (p, mono_array_addr (child->win32_res->res_data, char, 0), size);\n\t\t\tp += size;\n\t\t} else {\n\t\t\tresource_tree_encode (child, begin, p, &p);\n\t\t}\n\t}\n\n\t/* IMAGE_RESOURCE_ENTRY */\n\tfor (l = node->children; l; l = l->next) {\n\t\tResTreeNode *child = (ResTreeNode*)l->data;\n\n\t\tMONO_PE_RES_DIR_ENTRY_SET_NAME (dir_entry, FALSE, child->id);\n\t\tMONO_PE_RES_DIR_ENTRY_SET_DIR (dir_entry, !child->win32_res, child->offset);\n\n\t\tmemcpy (entries, &dir_entry, sizeof (dir_entry));\n\t\tentries += sizeof (dir_entry);\n\t}\n\n\t*endbuf = p;\n}\n\nstatic void\nresource_tree_free (ResTreeNode * node)\n{\n\tGSList * list;\n\tfor (list = node->children; list; list = list->next)\n\t\tresource_tree_free ((ResTreeNode*)list->data);\n\tg_slist_free(node->children);\n\tg_free (node);\n}\n\nstatic void\nassembly_add_win32_resources (MonoDynamicImage *assembly, MonoReflectionAssemblyBuilder *assemblyb)\n{\n\tchar *buf;\n\tchar *p;\n\tguint32 size, i;\n\tMonoReflectionWin32Resource *win32_res;\n\tResTreeNode *tree;\n\n\tif (!assemblyb->win32_resources)\n\t\treturn;\n\n\t/*\n\t * Resources are stored in a three level tree inside the PE file.\n\t * - level one contains a node for each type of resource\n\t * - level two contains a node for each resource\n\t * - level three contains a node for each instance of a resource for a\n\t *   specific language.\n\t */\n\n\ttree = resource_tree_create (assemblyb->win32_resources);\n\n\t/* Estimate the size of the encoded tree */\n\tsize = 0;\n\tfor (i = 0; i < mono_array_length (assemblyb->win32_resources); ++i) {\n\t\twin32_res = (MonoReflectionWin32Resource*)mono_array_addr (assemblyb->win32_resources, MonoReflectionWin32Resource, i);\n\t\tsize += mono_array_length (win32_res->res_data);\n\t}\n\t/* Directory structure */\n\tsize += mono_array_length (assemblyb->win32_resources) * 256;\n\tp = buf = g_malloc (size);\n\n\tresource_tree_encode (tree, p, p, &p);\n\n\tg_assert (p - buf <= size);\n\n\tassembly->win32_res = g_malloc (p - buf);\n\tassembly->win32_res_size = p - buf;\n\tmemcpy (assembly->win32_res, buf, p - buf);\n\n\tg_free (buf);\n\tresource_tree_free (tree);\n}\n\nstatic void\nfixup_resource_directory (char *res_section, char *p, guint32 rva)\n{\n\tMonoPEResourceDir *dir = (MonoPEResourceDir*)p;\n\tint i;\n\n\tp += sizeof (MonoPEResourceDir);\n\tfor (i = 0; i < GUINT16_FROM_LE (dir->res_named_entries) + GUINT16_FROM_LE (dir->res_id_entries); ++i) {\n\t\tMonoPEResourceDirEntry *dir_entry = (MonoPEResourceDirEntry*)p;\n\t\tchar *child = res_section + MONO_PE_RES_DIR_ENTRY_DIR_OFFSET (*dir_entry);\n\t\tif (MONO_PE_RES_DIR_ENTRY_IS_DIR (*dir_entry)) {\n\t\t\tfixup_resource_directory (res_section, child, rva);\n\t\t} else {\n\t\t\tMonoPEResourceDataEntry *data_entry = (MonoPEResourceDataEntry*)child;\n\t\t\tdata_entry->rde_data_offset = GUINT32_TO_LE (GUINT32_FROM_LE (data_entry->rde_data_offset) + rva);\n\t\t}\n\n\t\tp += sizeof (MonoPEResourceDirEntry);\n\t}\n}\n\nstatic void\nchecked_write_file (HANDLE f, gconstpointer buffer, guint32 numbytes)\n{\n\tguint32 dummy;\n\tif (!WriteFile (f, buffer, numbytes, &dummy, NULL))\n\t\tg_error (\"WriteFile returned %d\\n\", GetLastError ());\n}\n\n/*\n * mono_image_create_pefile:\n * @mb: a module builder object\n * \n * This function creates the PE-COFF header, the image sections, the CLI header  * etc. all the data is written in\n * assembly->pefile where it can be easily retrieved later in chunks.\n */\nvoid\nmono_image_create_pefile (MonoReflectionModuleBuilder *mb, HANDLE file)\n{\n\tMonoMSDOSHeader *msdos;\n\tMonoDotNetHeader *header;\n\tMonoSectionTable *section;\n\tMonoCLIHeader *cli_header;\n\tguint32 size, image_size, virtual_base, text_offset;\n\tguint32 header_start, section_start, file_offset, virtual_offset;\n\tMonoDynamicImage *assembly;\n\tMonoReflectionAssemblyBuilder *assemblyb;\n\tMonoDynamicStream pefile_stream = {0};\n\tMonoDynamicStream *pefile = &pefile_stream;\n\tint i, nsections;\n\tguint32 *rva, value;\n\tguchar *p;\n\tstatic const unsigned char msheader[] = {\n\t\t0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00,  0x04, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,\n\t\t0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,\n\t\t0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd,  0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21, 0x54, 0x68,\n\t\t0x69, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x67, 0x72,  0x61, 0x6d, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f,\n\t\t0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6e,  0x20, 0x69, 0x6e, 0x20, 0x44, 0x4f, 0x53, 0x20,\n\t\t0x6d, 0x6f, 0x64, 0x65, 0x2e, 0x0d, 0x0d, 0x0a,  0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\n\tassemblyb = mb->assemblyb;\n\n\tmono_image_basic_init (assemblyb);\n\tassembly = mb->dynamic_image;\n\n\tassembly->pe_kind = assemblyb->pe_kind;\n\tassembly->machine = assemblyb->machine;\n\t((MonoDynamicImage*)assemblyb->dynamic_assembly->assembly.image)->pe_kind = assemblyb->pe_kind;\n\t((MonoDynamicImage*)assemblyb->dynamic_assembly->assembly.image)->machine = assemblyb->machine;\n\t\n\tmono_image_build_metadata (mb);\n\n\tif (mb->is_main && assemblyb->resources) {\n\t\tint len = mono_array_length (assemblyb->resources);\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tassembly_add_resource (mb, assembly, (MonoReflectionResource*)mono_array_addr (assemblyb->resources, MonoReflectionResource, i));\n\t}\n\n\tif (mb->resources) {\n\t\tint len = mono_array_length (mb->resources);\n\t\tfor (i = 0; i < len; ++i)\n\t\t\tassembly_add_resource (mb, assembly, (MonoReflectionResource*)mono_array_addr (mb->resources, MonoReflectionResource, i));\n\t}\n\n\tbuild_compressed_metadata (assembly);\n\n\tif (mb->is_main)\n\t\tassembly_add_win32_resources (assembly, assemblyb);\n\n\tnsections = calc_section_size (assembly);\n\t\n\t/* The DOS header and stub */\n\tg_assert (sizeof (MonoMSDOSHeader) == sizeof (msheader));\n\tmono_image_add_stream_data (pefile, (char*)msheader, sizeof (msheader));\n\n\t/* the dotnet header */\n\theader_start = mono_image_add_stream_zero (pefile, sizeof (MonoDotNetHeader));\n\n\t/* the section tables */\n\tsection_start = mono_image_add_stream_zero (pefile, sizeof (MonoSectionTable) * nsections);\n\n\tfile_offset = section_start + sizeof (MonoSectionTable) * nsections;\n\tvirtual_offset = VIRT_ALIGN;\n\timage_size = 0;\n\n\tfor (i = 0; i < MONO_SECTION_MAX; ++i) {\n\t\tif (!assembly->sections [i].size)\n\t\t\tcontinue;\n\t\t/* align offsets */\n\t\tfile_offset += FILE_ALIGN - 1;\n\t\tfile_offset &= ~(FILE_ALIGN - 1);\n\t\tvirtual_offset += VIRT_ALIGN - 1;\n\t\tvirtual_offset &= ~(VIRT_ALIGN - 1);\n\n\t\tassembly->sections [i].offset = file_offset;\n\t\tassembly->sections [i].rva = virtual_offset;\n\n\t\tfile_offset += assembly->sections [i].size;\n\t\tvirtual_offset += assembly->sections [i].size;\n\t\timage_size += (assembly->sections [i].size + VIRT_ALIGN - 1) & ~(VIRT_ALIGN - 1);\n\t}\n\n\tfile_offset += FILE_ALIGN - 1;\n\tfile_offset &= ~(FILE_ALIGN - 1);\n\n\timage_size += section_start + sizeof (MonoSectionTable) * nsections;\n\n\t/* back-patch info */\n\tmsdos = (MonoMSDOSHeader*)pefile->data;\n\tmsdos->pe_offset = GUINT32_FROM_LE (sizeof (MonoMSDOSHeader));\n\n\theader = (MonoDotNetHeader*)(pefile->data + header_start);\n\theader->pesig [0] = 'P';\n\theader->pesig [1] = 'E';\n\t\n\theader->coff.coff_machine = GUINT16_FROM_LE (assemblyb->machine);\n\theader->coff.coff_sections = GUINT16_FROM_LE (nsections);\n\theader->coff.coff_time = GUINT32_FROM_LE (time (NULL));\n\theader->coff.coff_opt_header_size = GUINT16_FROM_LE (sizeof (MonoDotNetHeader) - sizeof (MonoCOFFHeader) - 4);\n\tif (assemblyb->pekind == 1) {\n\t\t/* it's a dll */\n\t\theader->coff.coff_attributes = GUINT16_FROM_LE (0x210e);\n\t} else {\n\t\t/* it's an exe */\n\t\theader->coff.coff_attributes = GUINT16_FROM_LE (0x010e);\n\t}\n\n\tvirtual_base = 0x400000; /* FIXME: 0x10000000 if a DLL */\n\n\theader->pe.pe_magic = GUINT16_FROM_LE (0x10B);\n\theader->pe.pe_major = 6;\n\theader->pe.pe_minor = 0;\n\tsize = assembly->sections [MONO_SECTION_TEXT].size;\n\tsize += FILE_ALIGN - 1;\n\tsize &= ~(FILE_ALIGN - 1);\n\theader->pe.pe_code_size = GUINT32_FROM_LE(size);\n\tsize = assembly->sections [MONO_SECTION_RSRC].size;\n\tsize += FILE_ALIGN - 1;\n\tsize &= ~(FILE_ALIGN - 1);\n\theader->pe.pe_data_size = GUINT32_FROM_LE(size);\n\tg_assert (START_TEXT_RVA == assembly->sections [MONO_SECTION_TEXT].rva);\n\theader->pe.pe_rva_code_base = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_TEXT].rva);\n\theader->pe.pe_rva_data_base = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RSRC].rva);\n\t/* pe_rva_entry_point always at the beginning of the text section */\n\theader->pe.pe_rva_entry_point = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_TEXT].rva);\n\n\theader->nt.pe_image_base = GUINT32_FROM_LE (virtual_base);\n\theader->nt.pe_section_align = GUINT32_FROM_LE (VIRT_ALIGN);\n\theader->nt.pe_file_alignment = GUINT32_FROM_LE (FILE_ALIGN);\n\theader->nt.pe_os_major = GUINT16_FROM_LE (4);\n\theader->nt.pe_os_minor = GUINT16_FROM_LE (0);\n\theader->nt.pe_subsys_major = GUINT16_FROM_LE (4);\n\tsize = section_start;\n\tsize += FILE_ALIGN - 1;\n\tsize &= ~(FILE_ALIGN - 1);\n\theader->nt.pe_header_size = GUINT32_FROM_LE (size);\n\tsize = image_size;\n\tsize += VIRT_ALIGN - 1;\n\tsize &= ~(VIRT_ALIGN - 1);\n\theader->nt.pe_image_size = GUINT32_FROM_LE (size);\n\n\t/*\n\t// Translate the PEFileKind value to the value expected by the Windows loader\n\t*/\n\t{\n\t\tshort kind;\n\n\t\t/*\n\t\t// PEFileKinds.Dll == 1\n\t\t// PEFileKinds.ConsoleApplication == 2\n\t\t// PEFileKinds.WindowApplication == 3\n\t\t//\n\t\t// need to get:\n\t\t//     IMAGE_SUBSYSTEM_WINDOWS_GUI 2 // Image runs in the Windows GUI subsystem.\n                //     IMAGE_SUBSYSTEM_WINDOWS_CUI 3 // Image runs in the Windows character subsystem.\n\t\t*/\n\t\tif (assemblyb->pekind == 3)\n\t\t\tkind = 2;\n\t\telse\n\t\t\tkind = 3;\n\t\t\n\t\theader->nt.pe_subsys_required = GUINT16_FROM_LE (kind);\n\t}    \n\theader->nt.pe_stack_reserve = GUINT32_FROM_LE (0x00100000);\n\theader->nt.pe_stack_commit = GUINT32_FROM_LE (0x00001000);\n\theader->nt.pe_heap_reserve = GUINT32_FROM_LE (0x00100000);\n\theader->nt.pe_heap_commit = GUINT32_FROM_LE (0x00001000);\n\theader->nt.pe_loader_flags = GUINT32_FROM_LE (0);\n\theader->nt.pe_data_dir_count = GUINT32_FROM_LE (16);\n\n\t/* fill data directory entries */\n\n\theader->datadir.pe_resource_table.size = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RSRC].size);\n\theader->datadir.pe_resource_table.rva = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RSRC].rva);\n\n\theader->datadir.pe_reloc_table.size = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RELOC].size);\n\theader->datadir.pe_reloc_table.rva = GUINT32_FROM_LE (assembly->sections [MONO_SECTION_RELOC].rva);\n\n\theader->datadir.pe_cli_header.size = GUINT32_FROM_LE (72);\n\theader->datadir.pe_cli_header.rva = GUINT32_FROM_LE (assembly->text_rva + assembly->cli_header_offset);\n\theader->datadir.pe_iat.size = GUINT32_FROM_LE (8);\n\theader->datadir.pe_iat.rva = GUINT32_FROM_LE (assembly->text_rva + assembly->iat_offset);\n\t/* patch entrypoint name */\n\tif (assemblyb->pekind == 1)\n\t\tmemcpy (assembly->code.data + assembly->imp_names_offset + 2, \"_CorDllMain\", 12);\n\telse\n\t\tmemcpy (assembly->code.data + assembly->imp_names_offset + 2, \"_CorExeMain\", 12);\n\t/* patch imported function RVA name */\n\trva = (guint32*)(assembly->code.data + assembly->iat_offset);\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->imp_names_offset);\n\n\t/* the import table */\n\theader->datadir.pe_import_table.size = GUINT32_FROM_LE (79); /* FIXME: magic number? */\n\theader->datadir.pe_import_table.rva = GUINT32_FROM_LE (assembly->text_rva + assembly->idt_offset);\n\t/* patch imported dll RVA name and other entries in the dir */\n\trva = (guint32*)(assembly->code.data + assembly->idt_offset + G_STRUCT_OFFSET (MonoIDT, name_rva));\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->imp_names_offset + 14); /* 14 is hint+strlen+1 of func name */\n\trva = (guint32*)(assembly->code.data + assembly->idt_offset + G_STRUCT_OFFSET (MonoIDT, import_address_table_rva));\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->iat_offset);\n\trva = (guint32*)(assembly->code.data + assembly->idt_offset + G_STRUCT_OFFSET (MonoIDT, import_lookup_table));\n\t*rva = GUINT32_FROM_LE (assembly->text_rva + assembly->ilt_offset);\n\n\tp = (guchar*)(assembly->code.data + assembly->ilt_offset);\n\tvalue = (assembly->text_rva + assembly->imp_names_offset);\n\t*p++ = (value) & 0xff;\n\t*p++ = (value >> 8) & (0xff);\n\t*p++ = (value >> 16) & (0xff);\n\t*p++ = (value >> 24) & (0xff);\n\n\t/* the CLI header info */\n\tcli_header = (MonoCLIHeader*)(assembly->code.data + assembly->cli_header_offset);\n\tcli_header->ch_size = GUINT32_FROM_LE (72);\n\tcli_header->ch_runtime_major = GUINT16_FROM_LE (2);\n\tif (mono_framework_version () > 1)\n\t\tcli_header->ch_runtime_minor = GUINT16_FROM_LE (5);\n\telse \n\t\tcli_header->ch_runtime_minor = GUINT16_FROM_LE (0);\n\tcli_header->ch_flags = GUINT32_FROM_LE (assemblyb->pe_kind);\n\tif (assemblyb->entry_point) {\n\t\tguint32 table_idx = 0;\n\t\tif (!strcmp (assemblyb->entry_point->object.vtable->klass->name, \"MethodBuilder\")) {\n\t\t\tMonoReflectionMethodBuilder *methodb = (MonoReflectionMethodBuilder*)assemblyb->entry_point;\n\t\t\ttable_idx = methodb->table_idx;\n\t\t} else {\n\t\t\ttable_idx = GPOINTER_TO_UINT (g_hash_table_lookup (assembly->method_to_table_idx, assemblyb->entry_point->method));\n\t\t}\n\t\tcli_header->ch_entry_point = GUINT32_FROM_LE (table_idx | MONO_TOKEN_METHOD_DEF);\n\t} else {\n\t\tcli_header->ch_entry_point = GUINT32_FROM_LE (0);\n\t}\n\t/* The embedded managed resources */\n\ttext_offset = assembly->text_rva + assembly->code.index;\n\tcli_header->ch_resources.rva = GUINT32_FROM_LE (text_offset);\n\tcli_header->ch_resources.size = GUINT32_FROM_LE (assembly->resources.index);\n\ttext_offset += assembly->resources.index;\n\tcli_header->ch_metadata.rva = GUINT32_FROM_LE (text_offset);\n\tcli_header->ch_metadata.size = GUINT32_FROM_LE (assembly->meta_size);\n\ttext_offset += assembly->meta_size;\n\tif (assembly->strong_name_size) {\n\t\tcli_header->ch_strong_name.rva = GUINT32_FROM_LE (text_offset);\n\t\tcli_header->ch_strong_name.size = GUINT32_FROM_LE (assembly->strong_name_size);\n\t\ttext_offset += assembly->strong_name_size;\n\t}\n\n\t/* write the section tables and section content */\n\tsection = (MonoSectionTable*)(pefile->data + section_start);\n\tfor (i = 0; i < MONO_SECTION_MAX; ++i) {\n\t\tstatic const char section_names [][7] = {\n\t\t\t\".text\", \".rsrc\", \".reloc\"\n\t\t};\n\t\tif (!assembly->sections [i].size)\n\t\t\tcontinue;\n\t\tstrcpy (section->st_name, section_names [i]);\n\t\t/*g_print (\"output section %s (%d), size: %d\\n\", section->st_name, i, assembly->sections [i].size);*/\n\t\tsection->st_virtual_address = GUINT32_FROM_LE (assembly->sections [i].rva);\n\t\tsection->st_virtual_size = GUINT32_FROM_LE (assembly->sections [i].size);\n\t\tsection->st_raw_data_size = GUINT32_FROM_LE (GUINT32_TO_LE (section->st_virtual_size) + (FILE_ALIGN - 1));\n\t\tsection->st_raw_data_size &= GUINT32_FROM_LE (~(FILE_ALIGN - 1));\n\t\tsection->st_raw_data_ptr = GUINT32_FROM_LE (assembly->sections [i].offset);\n\t\tsection->st_flags = GUINT32_FROM_LE (assembly->sections [i].attrs);\n\t\tsection ++;\n\t}\n\t\n\tchecked_write_file (file, pefile->data, pefile->index);\n\t\n\tmono_dynamic_stream_reset (pefile);\n\t\n\tfor (i = 0; i < MONO_SECTION_MAX; ++i) {\n\t\tif (!assembly->sections [i].size)\n\t\t\tcontinue;\n\t\t\n\t\tif (SetFilePointer (file, assembly->sections [i].offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)\n\t\t\tg_error (\"SetFilePointer returned %d\\n\", GetLastError ());\n\t\t\n\t\tswitch (i) {\n\t\tcase MONO_SECTION_TEXT:\n\t\t\t/* patch entry point */\n\t\t\tp = (guchar*)(assembly->code.data + 2);\n\t\t\tvalue = (virtual_base + assembly->text_rva + assembly->iat_offset);\n\t\t\t*p++ = (value) & 0xff;\n\t\t\t*p++ = (value >> 8) & 0xff;\n\t\t\t*p++ = (value >> 16) & 0xff;\n\t\t\t*p++ = (value >> 24) & 0xff;\n\t\t\n\t\t\tchecked_write_file (file, assembly->code.data, assembly->code.index);\n\t\t\tchecked_write_file (file, assembly->resources.data, assembly->resources.index);\n\t\t\tchecked_write_file (file, assembly->image.raw_metadata, assembly->meta_size);\n\t\t\tchecked_write_file (file, assembly->strong_name, assembly->strong_name_size);\n\t\t\t\t\n\n\t\t\tg_free (assembly->image.raw_metadata);\n\t\t\tbreak;\n\t\tcase MONO_SECTION_RELOC: {\n\t\t\tstruct {\n\t\t\t\tguint32 page_rva;\n\t\t\t\tguint32 block_size;\n\t\t\t\tguint16 type_and_offset;\n\t\t\t\tguint16 term;\n\t\t\t} reloc;\n\t\t\t\n\t\t\tg_assert (sizeof (reloc) == 12);\n\t\t\t\n\t\t\treloc.page_rva = GUINT32_FROM_LE (assembly->text_rva);\n\t\t\treloc.block_size = GUINT32_FROM_LE (12);\n\t\t\t\n\t\t\t/* \n\t\t\t * the entrypoint is always at the start of the text section \n\t\t\t * 3 is IMAGE_REL_BASED_HIGHLOW\n\t\t\t * 2 is patch_size_rva - text_rva\n\t\t\t */\n\t\t\treloc.type_and_offset = GUINT16_FROM_LE ((3 << 12) + (2));\n\t\t\treloc.term = 0;\n\t\t\t\n\t\t\tchecked_write_file (file, &reloc, sizeof (reloc));\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tcase MONO_SECTION_RSRC:\n\t\t\tif (assembly->win32_res) {\n\n\t\t\t\t/* Fixup the offsets in the IMAGE_RESOURCE_DATA_ENTRY structures */\n\t\t\t\tfixup_resource_directory (assembly->win32_res, assembly->win32_res, assembly->sections [i].rva);\n\t\t\t\tchecked_write_file (file, assembly->win32_res, assembly->win32_res_size);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n\t\n\t/* check that the file is properly padded */\n\tif (SetFilePointer (file, file_offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)\n\t\tg_error (\"SetFilePointer returned %d\\n\", GetLastError ());\n\tif (! SetEndOfFile (file))\n\t\tg_error (\"SetEndOfFile returned %d\\n\", GetLastError ());\n\t\n\tmono_dynamic_stream_reset (&assembly->code);\n\tmono_dynamic_stream_reset (&assembly->us);\n\tmono_dynamic_stream_reset (&assembly->blob);\n\tmono_dynamic_stream_reset (&assembly->guid);\n\tmono_dynamic_stream_reset (&assembly->sheap);\n\n\tg_hash_table_foreach (assembly->blob_cache, (GHFunc)g_free, NULL);\n\tg_hash_table_destroy (assembly->blob_cache);\n\tassembly->blob_cache = NULL;\n}\n\n#else /* DISABLE_REFLECTION_EMIT_SAVE */\n\nvoid\nmono_image_create_pefile (MonoReflectionModuleBuilder *mb, HANDLE file)\n{\n\tg_assert_not_reached ();\n}\n\n#endif /* DISABLE_REFLECTION_EMIT_SAVE */\n\n#ifndef DISABLE_REFLECTION_EMIT\n\nMonoReflectionModule *\nmono_image_load_module_dynamic (MonoReflectionAssemblyBuilder *ab, MonoString *fileName)\n{\n\tchar *name;\n\tMonoImage *image;\n\tMonoImageOpenStatus status;\n\tMonoDynamicAssembly *assembly;\n\tguint32 module_count;\n\tMonoImage **new_modules;\n\tgboolean *new_modules_loaded;\n\t\n\tname = mono_string_to_utf8 (fileName);\n\n\timage = mono_image_open (name, &status);\n\tif (!image) {\n\t\tMonoException *exc;\n\t\tif (status == MONO_IMAGE_ERROR_ERRNO)\n\t\t\texc = mono_get_exception_file_not_found (fileName);\n\t\telse\n\t\t\texc = mono_get_exception_bad_image_format (name);\n\t\tg_free (name);\n\t\tmono_raise_exception (exc);\n\t}\n\n\tg_free (name);\n\n\tassembly = ab->dynamic_assembly;\n\timage->assembly = (MonoAssembly*)assembly;\n\n\tmodule_count = image->assembly->image->module_count;\n\tnew_modules = g_new0 (MonoImage *, module_count + 1);\n\tnew_modules_loaded = g_new0 (gboolean, module_count + 1);\n\n\tif (image->assembly->image->modules)\n\t\tmemcpy (new_modules, image->assembly->image->modules, module_count * sizeof (MonoImage *));\n\tif (image->assembly->image->modules_loaded)\n\t\tmemcpy (new_modules_loaded, image->assembly->image->modules_loaded, module_count * sizeof (gboolean));\n\tnew_modules [module_count] = image;\n\tnew_modules_loaded [module_count] = TRUE;\n\tmono_image_addref (image);\n\n\tg_free (image->assembly->image->modules);\n\timage->assembly->image->modules = new_modules;\n\timage->assembly->image->modules_loaded = new_modules_loaded;\n\timage->assembly->image->module_count ++;\n\n\tmono_assembly_load_references (image, &status);\n\tif (status) {\n\t\tmono_image_close (image);\n\t\tmono_raise_exception (mono_get_exception_file_not_found (fileName));\n\t}\n\n\treturn mono_module_get_object (mono_domain_get (), image);\n}\n\n#endif /* DISABLE_REFLECTION_EMIT */\n\n/*\n * We need to return always the same object for MethodInfo, FieldInfo etc..\n * but we need to consider the reflected type.\n * type uses a different hash, since it uses custom hash/equal functions.\n */\n\ntypedef struct {\n\tgpointer item;\n\tMonoClass *refclass;\n} ReflectedEntry;\n\nstatic gboolean\nreflected_equal (gconstpointer a, gconstpointer b) {\n\tconst ReflectedEntry *ea = a;\n\tconst ReflectedEntry *eb = b;\n\n\treturn (ea->item == eb->item) && (ea->refclass == eb->refclass);\n}\n\nstatic guint\nreflected_hash (gconstpointer a) {\n\tconst ReflectedEntry *ea = a;\n\treturn mono_aligned_addr_hash (ea->item);\n}\n\n#define CHECK_OBJECT(t,p,k)\t\\\n\tdo {\t\\\n\t\tt _obj;\t\\\n\t\tReflectedEntry e; \t\\\n\t\te.item = (p);\t\\\n\t\te.refclass = (k);\t\\\n\t\tmono_domain_lock (domain);\t\\\n\t\tif (!domain->refobject_hash)\t\\\n\t\t\tdomain->refobject_hash = mono_g_hash_table_new_type (reflected_hash, reflected_equal, MONO_HASH_VALUE_GC);\t\\\n\t\tif ((_obj = mono_g_hash_table_lookup (domain->refobject_hash, &e))) {\t\\\n\t\t\tmono_domain_unlock (domain);\t\\\n\t\t\treturn _obj;\t\\\n\t\t}\t\\\n        mono_domain_unlock (domain); \\\n\t} while (0)\n\n#ifdef HAVE_BOEHM_GC\n/* ReflectedEntry doesn't need to be GC tracked */\n#define ALLOC_REFENTRY g_new0 (ReflectedEntry, 1)\n#define FREE_REFENTRY(entry) g_free ((entry))\n#define REFENTRY_REQUIRES_CLEANUP\n#else\n#define ALLOC_REFENTRY mono_mempool_alloc (domain->mp, sizeof (ReflectedEntry))\n/* FIXME: */\n#define FREE_REFENTRY(entry)\n#endif\n\n#define CACHE_OBJECT(t,p,o,k)\t\\\n\tdo {\t\\\n\t\tt _obj;\t\\\n        ReflectedEntry pe; \\\n        pe.item = (p); \\\n        pe.refclass = (k); \\\n        mono_domain_lock (domain); \\\n\t\tif (!domain->refobject_hash)\t\\\n\t\t\tdomain->refobject_hash = mono_g_hash_table_new_type (reflected_hash, reflected_equal, MONO_HASH_VALUE_GC);\t\\\n        _obj = mono_g_hash_table_lookup (domain->refobject_hash, &pe); \\\n        if (!_obj) { \\\n\t\t    ReflectedEntry *e = ALLOC_REFENTRY; \t\\\n\t\t    e->item = (p);\t\\\n\t\t    e->refclass = (k);\t\\\n\t\t    mono_g_hash_table_insert (domain->refobject_hash, e,o);\t\\\n            _obj = o; \\\n        } \\\n\t\tmono_domain_unlock (domain);\t\\\n        return _obj; \\\n\t} while (0)\n\nstatic void\nclear_cached_object (MonoDomain *domain, gpointer o, MonoClass *klass)\n{\n\tmono_domain_lock (domain);\n\tif (domain->refobject_hash) {\n        ReflectedEntry pe;\n\t\tgpointer orig_pe, orig_value;\n\n\t\tpe.item = o;\n\t\tpe.refclass = klass;\n\t\tif (mono_g_hash_table_lookup_extended (domain->refobject_hash, &pe, &orig_pe, &orig_value)) {\n\t\t\tmono_g_hash_table_remove (domain->refobject_hash, &pe);\n\t\t\tFREE_REFENTRY (orig_pe);\n\t\t}\n\t}\n\tmono_domain_unlock (domain);\n}\n\n#ifdef REFENTRY_REQUIRES_CLEANUP\nstatic void\ncleanup_refobject_hash (gpointer key, gpointer value, gpointer user_data)\n{\n\tFREE_REFENTRY (key);\n}\n#endif\n\nvoid\nmono_reflection_cleanup_domain (MonoDomain *domain)\n{\n\tif (domain->refobject_hash) {\n/*let's avoid scanning the whole hashtable if not needed*/\n#ifdef REFENTRY_REQUIRES_CLEANUP\n\t\tmono_g_hash_table_foreach (domain->refobject_hash, cleanup_refobject_hash, NULL);\n#endif\n\t\tmono_g_hash_table_destroy (domain->refobject_hash);\n\t\tdomain->refobject_hash = NULL;\n\t}\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic gpointer\nregister_assembly (MonoDomain *domain, MonoReflectionAssembly *res, MonoAssembly *assembly)\n{\n\tCACHE_OBJECT (MonoReflectionAssembly *, assembly, res, NULL);\n}\n\nstatic gpointer\nregister_module (MonoDomain *domain, MonoReflectionModuleBuilder *res, MonoDynamicImage *module)\n{\n\tCACHE_OBJECT (MonoReflectionModuleBuilder *, module, res, NULL);\n}\n\nvoid\nmono_image_module_basic_init (MonoReflectionModuleBuilder *moduleb)\n{\n\tMonoDynamicImage *image = moduleb->dynamic_image;\n\tMonoReflectionAssemblyBuilder *ab = moduleb->assemblyb;\n\tif (!image) {\n\t\tMonoError error;\n\t\tint module_count;\n\t\tMonoImage **new_modules;\n\t\tMonoImage *ass;\n\t\tchar *name, *fqname;\n\t\t/*\n\t\t * FIXME: we already created an image in mono_image_basic_init (), but\n\t\t * we don't know which module it belongs to, since that is only \n\t\t * determined at assembly save time.\n\t\t */\n\t\t/*image = (MonoDynamicImage*)ab->dynamic_assembly->assembly.image; */\n\t\tname = mono_string_to_utf8 (ab->name);\n\t\tfqname = mono_string_to_utf8_checked (moduleb->module.fqname, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tg_free (name);\n\t\t\tmono_error_raise_exception (&error);\n\t\t}\n\t\timage = create_dynamic_mono_image (ab->dynamic_assembly, name, fqname);\n\n\t\tmoduleb->module.image = &image->image;\n\t\tmoduleb->dynamic_image = image;\n\t\tregister_module (mono_object_domain (moduleb), moduleb, image);\n\n\t\t/* register the module with the assembly */\n\t\tass = ab->dynamic_assembly->assembly.image;\n\t\tmodule_count = ass->module_count;\n\t\tnew_modules = g_new0 (MonoImage *, module_count + 1);\n\n\t\tif (ass->modules)\n\t\t\tmemcpy (new_modules, ass->modules, module_count * sizeof (MonoImage *));\n\t\tnew_modules [module_count] = &image->image;\n\t\tmono_image_addref (&image->image);\n\n\t\tg_free (ass->modules);\n\t\tass->modules = new_modules;\n\t\tass->module_count ++;\n\t}\n}\n\nvoid\nmono_image_set_wrappers_type (MonoReflectionModuleBuilder *moduleb, MonoReflectionType *type)\n{\n\tMonoDynamicImage *image = moduleb->dynamic_image;\n\n\tg_assert (type->type);\n\timage->wrappers_type = mono_class_from_mono_type (type->type);\n}\n\n#endif\n\n/*\n * mono_assembly_get_object:\n * @domain: an app domain\n * @assembly: an assembly\n *\n * Return an System.Reflection.Assembly object representing the MonoAssembly @assembly.\n */\nMonoReflectionAssembly*\nmono_assembly_get_object (MonoDomain *domain, MonoAssembly *assembly)\n{\n\tstatic MonoClass *System_Reflection_Assembly;\n\tMonoReflectionAssembly *res;\n\t\n\tCHECK_OBJECT (MonoReflectionAssembly *, assembly, NULL);\n\tif (!System_Reflection_Assembly)\n\t\tSystem_Reflection_Assembly = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Assembly\");\n\tres = (MonoReflectionAssembly *)mono_object_new (domain, System_Reflection_Assembly);\n\tres->assembly = assembly;\n\n\tCACHE_OBJECT (MonoReflectionAssembly *, assembly, res, NULL);\n}\n\n\n\nMonoReflectionModule*   \nmono_module_get_object   (MonoDomain *domain, MonoImage *image)\n{\n\tstatic MonoClass *System_Reflection_Module;\n\tMonoReflectionModule *res;\n\tchar* basename;\n\t\n\tCHECK_OBJECT (MonoReflectionModule *, image, NULL);\n\tif (!System_Reflection_Module)\n\t\tSystem_Reflection_Module = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Module\");\n\tres = (MonoReflectionModule *)mono_object_new (domain, System_Reflection_Module);\n\n\tres->image = image;\n\tMONO_OBJECT_SETREF (res, assembly, (MonoReflectionAssembly *) mono_assembly_get_object(domain, image->assembly));\n\n\tMONO_OBJECT_SETREF (res, fqname, mono_string_new (domain, image->name));\n\tbasename = g_path_get_basename (image->name);\n\tMONO_OBJECT_SETREF (res, name, mono_string_new (domain, basename));\n\tMONO_OBJECT_SETREF (res, scopename, mono_string_new (domain, image->module_name));\n\t\n\tg_free (basename);\n\n\tif (image->assembly->image == image) {\n\t\tres->token = mono_metadata_make_token (MONO_TABLE_MODULE, 1);\n\t} else {\n\t\tint i;\n\t\tres->token = 0;\n\t\tif (image->assembly->image->modules) {\n\t\t\tfor (i = 0; i < image->assembly->image->module_count; i++) {\n\t\t\t\tif (image->assembly->image->modules [i] == image)\n\t\t\t\t\tres->token = mono_metadata_make_token (MONO_TABLE_MODULEREF, i + 1);\n\t\t\t}\n\t\t\tg_assert (res->token);\n\t\t}\n\t}\n\n\tCACHE_OBJECT (MonoReflectionModule *, image, res, NULL);\n}\n\nMonoReflectionModule*   \nmono_module_file_get_object (MonoDomain *domain, MonoImage *image, int table_index)\n{\n\tstatic MonoClass *System_Reflection_Module;\n\tMonoReflectionModule *res;\n\tMonoTableInfo *table;\n\tguint32 cols [MONO_FILE_SIZE];\n\tconst char *name;\n\tguint32 i, name_idx;\n\tconst char *val;\n\t\n\tif (!System_Reflection_Module)\n\t\tSystem_Reflection_Module = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"Module\");\n\tres = (MonoReflectionModule *)mono_object_new (domain, System_Reflection_Module);\n\n\ttable = &image->tables [MONO_TABLE_FILE];\n\tg_assert (table_index < table->rows);\n\tmono_metadata_decode_row (table, table_index, cols, MONO_FILE_SIZE);\n\n\tres->image = NULL;\n\tMONO_OBJECT_SETREF (res, assembly, (MonoReflectionAssembly *) mono_assembly_get_object(domain, image->assembly));\n\tname = mono_metadata_string_heap (image, cols [MONO_FILE_NAME]);\n\n\t/* Check whenever the row has a corresponding row in the moduleref table */\n\ttable = &image->tables [MONO_TABLE_MODULEREF];\n\tfor (i = 0; i < table->rows; ++i) {\n\t\tname_idx = mono_metadata_decode_row_col (table, i, MONO_MODULEREF_NAME);\n\t\tval = mono_metadata_string_heap (image, name_idx);\n\t\tif (strcmp (val, name) == 0)\n\t\t\tres->image = image->modules [i];\n\t}\n\n\tMONO_OBJECT_SETREF (res, fqname, mono_string_new (domain, name));\n\tMONO_OBJECT_SETREF (res, name, mono_string_new (domain, name));\n\tMONO_OBJECT_SETREF (res, scopename, mono_string_new (domain, name));\n\tres->is_resource = cols [MONO_FILE_FLAGS] && FILE_CONTAINS_NO_METADATA;\n\tres->token = mono_metadata_make_token (MONO_TABLE_FILE, table_index + 1);\n\n\treturn res;\n}\n\nstatic gboolean\nmymono_metadata_type_equal (MonoType *t1, MonoType *t2)\n{\n\tif ((t1->type != t2->type) ||\n\t    (t1->byref != t2->byref))\n\t\treturn FALSE;\n\n\tswitch (t1->type) {\n\tcase MONO_TYPE_VOID:\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_STRING:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_OBJECT:\n\tcase MONO_TYPE_TYPEDBYREF:\n\t\treturn TRUE;\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_SZARRAY:\n\t\treturn t1->data.klass == t2->data.klass;\n\tcase MONO_TYPE_PTR:\n\t\treturn mymono_metadata_type_equal (t1->data.type, t2->data.type);\n\tcase MONO_TYPE_ARRAY:\n\t\tif (t1->data.array->rank != t2->data.array->rank)\n\t\t\treturn FALSE;\n\t\treturn t1->data.array->eklass == t2->data.array->eklass;\n\tcase MONO_TYPE_GENERICINST: {\n\t\tint i;\n\t\tMonoGenericInst *i1 = t1->data.generic_class->context.class_inst;\n\t\tMonoGenericInst *i2 = t2->data.generic_class->context.class_inst;\n\t\tif (i1->type_argc != i2->type_argc)\n\t\t\treturn FALSE;\n\t\tif (!mono_metadata_type_equal (&t1->data.generic_class->container_class->byval_arg,\n\t\t\t\t\t       &t2->data.generic_class->container_class->byval_arg))\n\t\t\treturn FALSE;\n\t\t/* FIXME: we should probably just compare the instance pointers directly.  */\n\t\tfor (i = 0; i < i1->type_argc; ++i) {\n\t\t\tif (!mono_metadata_type_equal (i1->type_argv [i], i2->type_argv [i]))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\treturn t1->data.generic_param == t2->data.generic_param;\n\tdefault:\n\t\tg_error (\"implement type compare for %0x!\", t1->type);\n\t\treturn FALSE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic guint\nmymono_metadata_type_hash (MonoType *t1)\n{\n\tguint hash;\n\n\thash = t1->type;\n\n\thash |= t1->byref << 6; /* do not collide with t1->type values */\n\tswitch (t1->type) {\n\tcase MONO_TYPE_VALUETYPE:\n\tcase MONO_TYPE_CLASS:\n\tcase MONO_TYPE_SZARRAY:\n\t\t/* check if the distribution is good enough */\n\t\treturn ((hash << 5) - hash) ^ g_str_hash (t1->data.klass->name);\n\tcase MONO_TYPE_PTR:\n\t\treturn ((hash << 5) - hash) ^ mymono_metadata_type_hash (t1->data.type);\n\tcase MONO_TYPE_GENERICINST: {\n\t\tint i;\n\t\tMonoGenericInst *inst = t1->data.generic_class->context.class_inst;\n\t\thash += g_str_hash (t1->data.generic_class->container_class->name);\n\t\thash *= 13;\n\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\thash += mymono_metadata_type_hash (inst->type_argv [i]);\n\t\t\thash *= 13;\n\t\t}\n\t\treturn hash;\n\t}\n\t}\n\treturn hash;\n}\n\nstatic MonoReflectionGenericClass*\nmono_generic_class_get_object (MonoDomain *domain, MonoType *geninst)\n{\n\tstatic MonoClass *System_Reflection_MonoGenericClass;\n\tMonoReflectionGenericClass *res;\n\tMonoClass *klass, *gklass;\n\tMonoGenericInst *ginst;\n\tMonoArray *type_args;\n\tint i;\n\n\tif (!System_Reflection_MonoGenericClass) {\n\t\tSystem_Reflection_MonoGenericClass = mono_class_from_name (\n\t\t\tmono_defaults.corlib, \"System.Reflection\", \"MonoGenericClass\");\n\t\tg_assert (System_Reflection_MonoGenericClass);\n\t}\n\n\tklass = mono_class_from_mono_type (geninst);\n\tgklass = klass->generic_class->container_class;\n\n\tmono_class_init (klass);\n\n#ifdef HAVE_SGEN_GC\n\tres = (MonoReflectionGenericClass *) mono_gc_alloc_pinned_obj (mono_class_vtable (domain, System_Reflection_MonoGenericClass), mono_class_instance_size (System_Reflection_MonoGenericClass));\n#else\n\tres = (MonoReflectionGenericClass *) mono_object_new (domain, System_Reflection_MonoGenericClass);\n#endif\n\n\tres->type.type = geninst;\n\tg_assert (gklass->reflection_info);\n\tg_assert (!strcmp (((MonoObject*)gklass->reflection_info)->vtable->klass->name, \"TypeBuilder\"));\n\tMONO_OBJECT_SETREF (res, generic_type, gklass->reflection_info);\n\n\tginst = klass->generic_class->context.class_inst;\n\ttype_args = mono_array_new (domain, mono_defaults.systemtype_class, ginst->type_argc);\n\tfor (i = 0; i < ginst->type_argc; ++i)\n\t\tmono_array_setref (type_args, i, mono_type_get_object (domain, ginst->type_argv [i]));\n\tMONO_OBJECT_SETREF (res, type_arguments, type_args);\n\n\treturn res;\n}\n\nstatic gboolean\nverify_safe_for_managed_space (MonoType *type)\n{\n\tswitch (type->type) {\n#ifdef DEBUG_HARDER\n\tcase MONO_TYPE_ARRAY:\n\t\treturn verify_safe_for_managed_space (&type->data.array->eklass->byval_arg);\n\tcase MONO_TYPE_PTR:\n\t\treturn verify_safe_for_managed_space (type->data.type);\n\tcase MONO_TYPE_SZARRAY:\n\t\treturn verify_safe_for_managed_space (&type->data.klass->byval_arg);\n\tcase MONO_TYPE_GENERICINST: {\n\t\tMonoGenericInst *inst = type->data.generic_class->inst;\n\t\tint i;\n\t\tif (!inst->is_open)\n\t\t\tbreak;\n\t\tfor (i = 0; i < inst->type_argc; ++i)\n\t\t\tif (!verify_safe_for_managed_space (inst->type_argv [i]))\n\t\t\t\treturn FALSE;\n\t\tbreak;\n\t}\n#endif\n\tcase MONO_TYPE_VAR:\n\tcase MONO_TYPE_MVAR:\n\t\treturn TRUE;\n\t}\n\treturn TRUE;\n}\n\n/*\n * mono_type_get_object:\n * @domain: an app domain\n * @type: a type\n *\n * Return an System.MonoType object representing the type @type.\n */\nMonoReflectionType*\nmono_type_get_object (MonoDomain *domain, MonoType *type)\n{\n\tMonoReflectionType *res;\n\tMonoClass *klass = mono_class_from_mono_type (type);\n\n\t/*we must avoid using @type as it might have come\n\t * from a mono_metadata_type_dup and the caller\n\t * expects that is can be freed.\n\t * Using the right type from \n\t */\n\ttype = klass->byval_arg.byref == type->byref ? &klass->byval_arg : &klass->this_arg;\n\n\t/* void is very common */\n\tif (type->type == MONO_TYPE_VOID && domain->typeof_void)\n\t\treturn (MonoReflectionType*)domain->typeof_void;\n\n\t/*\n\t * If the vtable of the given class was already created, we can use\n\t * the MonoType from there and avoid all locking and hash table lookups.\n\t * \n\t * We cannot do this for TypeBuilders as mono_reflection_create_runtime_class expects\n\t * that the resulting object is different.   \n\t */\n\tif (type == &klass->byval_arg && !klass->image->dynamic) {\n\t\tMonoVTable *vtable = mono_class_try_get_vtable (domain, klass);\n\t\tif (vtable && vtable->type)\n\t\t\treturn vtable->type;\n\t}\n\n\tmono_loader_lock (); /*FIXME mono_class_init and mono_class_vtable acquire it*/\n\tmono_domain_lock (domain);\n\tif (!domain->type_hash)\n\t\tdomain->type_hash = mono_g_hash_table_new_type ((GHashFunc)mymono_metadata_type_hash, \n\t\t\t\t(GCompareFunc)mymono_metadata_type_equal, MONO_HASH_VALUE_GC);\n\tif ((res = mono_g_hash_table_lookup (domain->type_hash, type))) {\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\t/* Create a MonoGenericClass object for instantiations of not finished TypeBuilders */\n\tif ((type->type == MONO_TYPE_GENERICINST) && type->data.generic_class->is_dynamic && !type->data.generic_class->container_class->wastypebuilder) {\n\t\tres = (MonoReflectionType *)mono_generic_class_get_object (domain, type);\n\t\tmono_g_hash_table_insert (domain->type_hash, type, res);\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\treturn res;\n\t}\n\n\tif (!verify_safe_for_managed_space (type)) {\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\"This type cannot be propagated to managed space\"));\n\t}\n\n\tif (klass->reflection_info && !klass->wastypebuilder) {\n\t\tgboolean is_type_done = TRUE;\n\t\t/* Generic parameters have reflection_info set but they are not finished together with their enclosing type.\n\t\t * We must ensure that once a type is finished we don't return a GenericTypeParameterBuilder.\n\t\t * We can't simply close the types as this will interfere with other parts of the generics machinery.\n\t\t*/\n\t\tif (klass->byval_arg.type == MONO_TYPE_MVAR || klass->byval_arg.type == MONO_TYPE_VAR) {\n\t\t\tMonoGenericParam *gparam = klass->byval_arg.data.generic_param;\n\n\t\t\tif (gparam->owner && gparam->owner->is_method) {\n\t\t\t\tMonoMethod *method = gparam->owner->owner.method;\n\t\t\t\tif (method && mono_class_get_generic_type_definition (method->klass)->wastypebuilder)\n\t\t\t\t\tis_type_done = FALSE;\n\t\t\t} else if (gparam->owner && !gparam->owner->is_method) {\n\t\t\t\tMonoClass *klass = gparam->owner->owner.klass;\n\t\t\t\tif (klass && mono_class_get_generic_type_definition (klass)->wastypebuilder)\n\t\t\t\t\tis_type_done = FALSE;\n\t\t\t}\n\t\t} \n\n\t\t/* g_assert_not_reached (); */\n\t\t/* should this be considered an error condition? */\n\t\tif (is_type_done && !type->byref) {\n\t\t\tmono_domain_unlock (domain);\n\t\t\tmono_loader_unlock ();\n\t\t\treturn klass->reflection_info;\n\t\t}\n\t}\n\t// FIXME: Get rid of this, do it in the icalls for Type\n\tmono_class_init (klass);\n#ifdef HAVE_SGEN_GC\n\tres = (MonoReflectionType *)mono_gc_alloc_pinned_obj (mono_class_vtable (domain, mono_defaults.monotype_class), mono_class_instance_size (mono_defaults.monotype_class));\n#else\n\tres = (MonoReflectionType *)mono_object_new (domain, mono_defaults.monotype_class);\n#endif\n\tres->type = type;\n\tmono_g_hash_table_insert (domain->type_hash, type, res);\n\n\tif (type->type == MONO_TYPE_VOID)\n\t\tdomain->typeof_void = (MonoObject*)res;\n\n\tmono_domain_unlock (domain);\n\tmono_loader_unlock ();\n\treturn res;\n}\n\n/*\n * mono_method_get_object:\n * @domain: an app domain\n * @method: a method\n * @refclass: the reflected type (can be NULL)\n *\n * Return an System.Reflection.MonoMethod object representing the method @method.\n */\nMonoReflectionMethod*\nmono_method_get_object (MonoDomain *domain, MonoMethod *method, MonoClass *refclass)\n{\n\t/*\n\t * We use the same C representation for methods and constructors, but the type \n\t * name in C# is different.\n\t */\n\tstatic MonoClass *System_Reflection_MonoMethod = NULL;\n\tstatic MonoClass *System_Reflection_MonoCMethod = NULL;\n\tstatic MonoClass *System_Reflection_MonoGenericMethod = NULL;\n\tstatic MonoClass *System_Reflection_MonoGenericCMethod = NULL;\n\tMonoClass *klass;\n\tMonoReflectionMethod *ret;\n\n\tif (method->is_inflated) {\n\t\tMonoReflectionGenericMethod *gret;\n\n\t\trefclass = method->klass;\n\t\tCHECK_OBJECT (MonoReflectionMethod *, method, refclass);\n\t\tif ((*method->name == '.') && (!strcmp (method->name, \".ctor\") || !strcmp (method->name, \".cctor\"))) {\n\t\t\tif (!System_Reflection_MonoGenericCMethod)\n\t\t\t\tSystem_Reflection_MonoGenericCMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoGenericCMethod\");\n\t\t\tklass = System_Reflection_MonoGenericCMethod;\n\t\t} else {\n\t\t\tif (!System_Reflection_MonoGenericMethod)\n\t\t\t\tSystem_Reflection_MonoGenericMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoGenericMethod\");\n\t\t\tklass = System_Reflection_MonoGenericMethod;\n\t\t}\n\t\tgret = (MonoReflectionGenericMethod*)mono_object_new (domain, klass);\n\t\tgret->method.method = method;\n\t\tMONO_OBJECT_SETREF (gret, method.name, mono_string_new (domain, method->name));\n\t\tMONO_OBJECT_SETREF (gret, method.reftype, mono_type_get_object (domain, &refclass->byval_arg));\n\t\tCACHE_OBJECT (MonoReflectionMethod *, method, (MonoReflectionMethod*)gret, refclass);\n\t}\n\n\tif (!refclass)\n\t\trefclass = method->klass;\n\n\tCHECK_OBJECT (MonoReflectionMethod *, method, refclass);\n\tif (*method->name == '.' && (strcmp (method->name, \".ctor\") == 0 || strcmp (method->name, \".cctor\") == 0)) {\n\t\tif (!System_Reflection_MonoCMethod)\n\t\t\tSystem_Reflection_MonoCMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoCMethod\");\n\t\tklass = System_Reflection_MonoCMethod;\n\t}\n\telse {\n\t\tif (!System_Reflection_MonoMethod)\n\t\t\tSystem_Reflection_MonoMethod = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoMethod\");\n\t\tklass = System_Reflection_MonoMethod;\n\t}\n\tret = (MonoReflectionMethod*)mono_object_new (domain, klass);\n\tret->method = method;\n\tMONO_OBJECT_SETREF (ret, reftype, mono_type_get_object (domain, &refclass->byval_arg));\n\tCACHE_OBJECT (MonoReflectionMethod *, method, ret, refclass);\n}\n\n/*\n * mono_method_clear_object:\n *\n *   Clear the cached reflection objects for the dynamic method METHOD.\n */\nvoid\nmono_method_clear_object (MonoDomain *domain, MonoMethod *method)\n{\n\tMonoClass *klass;\n\tg_assert (method->dynamic);\n\n\tklass = method->klass;\n\twhile (klass) {\n\t\tclear_cached_object (domain, method, klass);\n\t\tklass = klass->parent;\n\t}\n\t/* Added by mono_param_get_objects () */\n\tclear_cached_object (domain, &(method->signature), NULL);\n\tklass = method->klass;\n\twhile (klass) {\n\t\tclear_cached_object (domain, &(method->signature), klass);\n\t\tklass = klass->parent;\n\t}\n}\n\n/*\n * mono_field_get_object:\n * @domain: an app domain\n * @klass: a type\n * @field: a field\n *\n * Return an System.Reflection.MonoField object representing the field @field\n * in class @klass.\n */\nMonoReflectionField*\nmono_field_get_object (MonoDomain *domain, MonoClass *klass, MonoClassField *field)\n{\n\tMonoReflectionField *res;\n\tstatic MonoClass *monofield_klass;\n\n\tCHECK_OBJECT (MonoReflectionField *, field, klass);\n\tif (!monofield_klass)\n\t\tmonofield_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoField\");\n\tres = (MonoReflectionField *)mono_object_new (domain, monofield_klass);\n\tres->klass = klass;\n\tres->field = field;\n\tMONO_OBJECT_SETREF (res, name, mono_string_new (domain, mono_field_get_name (field)));\n\tif (is_field_on_inst (field))\n\t\tres->attrs = get_field_on_inst_generic_type (field)->attrs;\n\telse\n\t\tres->attrs = field->type->attrs;\n\tMONO_OBJECT_SETREF (res, type, mono_type_get_object (domain, field->type));\n\tCACHE_OBJECT (MonoReflectionField *, field, res, klass);\n}\n\n/*\n * mono_property_get_object:\n * @domain: an app domain\n * @klass: a type\n * @property: a property\n *\n * Return an System.Reflection.MonoProperty object representing the property @property\n * in class @klass.\n */\nMonoReflectionProperty*\nmono_property_get_object (MonoDomain *domain, MonoClass *klass, MonoProperty *property)\n{\n\tMonoReflectionProperty *res;\n\tstatic MonoClass *monoproperty_klass;\n\n\tCHECK_OBJECT (MonoReflectionProperty *, property, klass);\n\tif (!monoproperty_klass)\n\t\tmonoproperty_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoProperty\");\n\tres = (MonoReflectionProperty *)mono_object_new (domain, monoproperty_klass);\n\tres->klass = klass;\n\tres->property = property;\n\tCACHE_OBJECT (MonoReflectionProperty *, property, res, klass);\n}\n\n/*\n * mono_event_get_object:\n * @domain: an app domain\n * @klass: a type\n * @event: a event\n *\n * Return an System.Reflection.MonoEvent object representing the event @event\n * in class @klass.\n */\nMonoReflectionEvent*\nmono_event_get_object (MonoDomain *domain, MonoClass *klass, MonoEvent *event)\n{\n\tMonoReflectionEvent *res;\n\tMonoReflectionMonoEvent *mono_event;\n\tstatic MonoClass *monoevent_klass;\n\n\tCHECK_OBJECT (MonoReflectionEvent *, event, klass);\n\tif (!monoevent_klass)\n\t\tmonoevent_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MonoEvent\");\n\tmono_event = (MonoReflectionMonoEvent *)mono_object_new (domain, monoevent_klass);\n\tmono_event->klass = klass;\n\tmono_event->event = event;\n\tres = (MonoReflectionEvent*)mono_event;\n\tCACHE_OBJECT (MonoReflectionEvent *, event, res, klass);\n}\n\n/**\n * mono_get_reflection_missing_object:\n * @domain: Domain where the object lives\n *\n * Returns the System.Reflection.Missing.Value singleton object\n * (of type System.Reflection.Missing).\n *\n * Used as the value for ParameterInfo.DefaultValue when Optional\n * is present\n */\nstatic MonoObject *\nmono_get_reflection_missing_object (MonoDomain *domain)\n{\n\tMonoObject *obj;\n\tstatic MonoClassField *missing_value_field = NULL;\n\t\n\tif (!missing_value_field) {\n\t\tMonoClass *missing_klass;\n\t\tmissing_klass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"Missing\");\n\t\tmono_class_init (missing_klass);\n\t\tmissing_value_field = mono_class_get_field_from_name (missing_klass, \"Value\");\n\t\tg_assert (missing_value_field);\n\t}\n\tobj = mono_field_get_value_object (domain, missing_value_field, NULL); \n\tg_assert (obj);\n\treturn obj;\n}\n\nstatic MonoObject*\nget_dbnull (MonoDomain *domain, MonoObject **dbnull)\n{\n\tif (!*dbnull)\n\t\t*dbnull = mono_get_dbnull_object (domain);\n\treturn *dbnull;\n}\n\nstatic MonoObject*\nget_reflection_missing (MonoDomain *domain, MonoObject **reflection_missing)\n{\n\tif (!*reflection_missing)\n\t\t*reflection_missing = mono_get_reflection_missing_object (domain);\n\treturn *reflection_missing;\n}\n\n/*\n * mono_param_get_objects:\n * @domain: an app domain\n * @method: a method\n *\n * Return an System.Reflection.ParameterInfo array object representing the parameters\n * in the method @method.\n */\nMonoArray*\nmono_param_get_objects_internal (MonoDomain *domain, MonoMethod *method, MonoClass *refclass)\n{\n\tstatic MonoClass *System_Reflection_ParameterInfo;\n\tstatic MonoClass *System_Reflection_ParameterInfo_array;\n\tMonoArray *res = NULL;\n\tMonoReflectionMethod *member = NULL;\n\tMonoReflectionParameter *param = NULL;\n\tchar **names, **blobs = NULL;\n\tguint32 *types = NULL;\n\tMonoType *type = NULL;\n\tMonoObject *dbnull = NULL;\n\tMonoObject *missing = NULL;\n\tMonoMarshalSpec **mspecs;\n\tMonoMethodSignature *sig;\n\tMonoVTable *pinfo_vtable;\n\tint i;\n\n\tif (!System_Reflection_ParameterInfo_array) {\n\t\tMonoClass *klass;\n\n\t\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"ParameterInfo\");\n\t\tmono_memory_barrier ();\n\t\tSystem_Reflection_ParameterInfo = klass; \n\t\n\t\tklass = mono_array_class_get (klass, 1);\n\t\tmono_memory_barrier ();\n\t\tSystem_Reflection_ParameterInfo_array = klass;\n\t}\n\t\n\tif (!mono_method_signature (method)->param_count)\n\t\treturn mono_array_new_specific (mono_class_vtable (domain, System_Reflection_ParameterInfo_array), 0);\n\n\t/* Note: the cache is based on the address of the signature into the method\n\t * since we already cache MethodInfos with the method as keys.\n\t */\n\tCHECK_OBJECT (MonoArray*, &(method->signature), refclass);\n\n\tsig = mono_method_signature (method);\n\tmember = mono_method_get_object (domain, method, refclass);\n\tnames = g_new (char *, sig->param_count);\n\tmono_method_get_param_names (method, (const char **) names);\n\n\tmspecs = g_new (MonoMarshalSpec*, sig->param_count + 1);\n\tmono_method_get_marshal_info (method, mspecs);\n\n\tres = mono_array_new_specific (mono_class_vtable (domain, System_Reflection_ParameterInfo_array), sig->param_count);\n\tpinfo_vtable = mono_class_vtable (domain, System_Reflection_ParameterInfo);\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tparam = (MonoReflectionParameter *)mono_object_new_specific (pinfo_vtable);\n\t\tMONO_OBJECT_SETREF (param, ClassImpl, mono_type_get_object (domain, sig->params [i]));\n\t\tMONO_OBJECT_SETREF (param, MemberImpl, (MonoObject*)member);\n\t\tMONO_OBJECT_SETREF (param, NameImpl, mono_string_new (domain, names [i]));\n\t\tparam->PositionImpl = i;\n\t\tparam->AttrsImpl = sig->params [i]->attrs;\n\n\t\tif (!(param->AttrsImpl & PARAM_ATTRIBUTE_HAS_DEFAULT)) {\n\t\t\tif (param->AttrsImpl & PARAM_ATTRIBUTE_OPTIONAL)\n\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_reflection_missing (domain, &missing));\n\t\t\telse\n\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_dbnull (domain, &dbnull));\n\t\t} else {\n\n\t\t\tif (!blobs) {\n\t\t\t\tblobs = g_new0 (char *, sig->param_count);\n\t\t\t\ttypes = g_new0 (guint32, sig->param_count);\n\t\t\t\tget_default_param_value_blobs (method, blobs, types); \n\t\t\t}\n\n\t\t\t/* Build MonoType for the type from the Constant Table */\n\t\t\tif (!type)\n\t\t\t\ttype = g_new0 (MonoType, 1);\n\t\t\ttype->type = types [i];\n\t\t\ttype->data.klass = NULL;\n\t\t\tif (types [i] == MONO_TYPE_CLASS)\n\t\t\t\ttype->data.klass = mono_defaults.object_class;\n\t\t\telse if ((sig->params [i]->type == MONO_TYPE_VALUETYPE) && sig->params [i]->data.klass->enumtype) {\n\t\t\t\t/* For enums, types [i] contains the base type */\n\n\t\t\t\t\ttype->type = MONO_TYPE_VALUETYPE;\n\t\t\t\t\ttype->data.klass = mono_class_from_mono_type (sig->params [i]);\n\t\t\t} else\n\t\t\t\ttype->data.klass = mono_class_from_mono_type (type);\n\n\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, mono_get_object_from_blob (domain, type, blobs [i]));\n\n\t\t\t/* Type in the Constant table is MONO_TYPE_CLASS for nulls */\n\t\t\tif (types [i] != MONO_TYPE_CLASS && !param->DefaultValueImpl) {\n\t\t\t\tif (param->AttrsImpl & PARAM_ATTRIBUTE_OPTIONAL)\n\t\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_reflection_missing (domain, &missing));\n\t\t\t\telse\n\t\t\t\t\tMONO_OBJECT_SETREF (param, DefaultValueImpl, get_dbnull (domain, &dbnull));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif (mspecs [i + 1])\n\t\t\tMONO_OBJECT_SETREF (param, MarshalAsImpl, (MonoObject*)mono_reflection_marshal_from_marshal_spec (domain, method->klass, mspecs [i + 1]));\n\t\t\n\t\tmono_array_setref (res, i, param);\n\t}\n\tg_free (names);\n\tg_free (blobs);\n\tg_free (types);\n\tg_free (type);\n\n\tfor (i = mono_method_signature (method)->param_count; i >= 0; i--)\n\t\tif (mspecs [i])\n\t\t\tmono_metadata_free_marshal_spec (mspecs [i]);\n\tg_free (mspecs);\n\t\n\tCACHE_OBJECT (MonoArray *, &(method->signature), res, refclass);\n}\n\nMonoArray*\nmono_param_get_objects (MonoDomain *domain, MonoMethod *method)\n{\n\treturn mono_param_get_objects_internal (domain, method, NULL);\n}\n\n/*\n * mono_method_body_get_object:\n * @domain: an app domain\n * @method: a method\n *\n * Return an System.Reflection.MethodBody object representing the method @method.\n */\nMonoReflectionMethodBody*\nmono_method_body_get_object (MonoDomain *domain, MonoMethod *method)\n{\n\tstatic MonoClass *System_Reflection_MethodBody = NULL;\n\tstatic MonoClass *System_Reflection_LocalVariableInfo = NULL;\n\tstatic MonoClass *System_Reflection_ExceptionHandlingClause = NULL;\n\tMonoReflectionMethodBody *ret;\n\tMonoMethodNormal *mn;\n\tMonoMethodHeader *header;\n\tMonoImage *image;\n\tguint32 method_rva, local_var_sig_token;\n    char *ptr;\n\tunsigned char format, flags;\n\tint i;\n\n\t/* for compatibility with .net */\n    if (method->dynamic)\n        mono_raise_exception (mono_get_exception_invalid_operation (NULL));\n\n\tif (!System_Reflection_MethodBody)\n\t\tSystem_Reflection_MethodBody = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"MethodBody\");\n\tif (!System_Reflection_LocalVariableInfo)\n\t\tSystem_Reflection_LocalVariableInfo = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"LocalVariableInfo\");\n\tif (!System_Reflection_ExceptionHandlingClause)\n\t\tSystem_Reflection_ExceptionHandlingClause = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"ExceptionHandlingClause\");\n\n\tCHECK_OBJECT (MonoReflectionMethodBody *, method, NULL);\n\n\tif ((method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t(method->flags & METHOD_ATTRIBUTE_ABSTRACT) ||\n\t    (method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||\n\t    (method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME))\n\t\treturn NULL;\n\n\tmn = (MonoMethodNormal *)method;\n\timage = method->klass->image;\n\theader = mono_method_get_header (method);\n\n\tif (!image->dynamic) {\n\t\t/* Obtain local vars signature token */\n\t\tmethod_rva = mono_metadata_decode_row_col (&image->tables [MONO_TABLE_METHOD], mono_metadata_token_index (method->token) - 1, MONO_METHOD_RVA);\n\t\tptr = mono_image_rva_map (image, method_rva);\n\t\tflags = *(const unsigned char *) ptr;\n\t\tformat = flags & METHOD_HEADER_FORMAT_MASK;\n\t\tswitch (format){\n\t\tcase METHOD_HEADER_TINY_FORMAT:\n\t\t\tlocal_var_sig_token = 0;\n\t\t\tbreak;\n\t\tcase METHOD_HEADER_FAT_FORMAT:\n\t\t\tptr += 2;\n\t\t\tptr += 2;\n\t\t\tptr += 4;\n\t\t\tlocal_var_sig_token = read32 (ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t} else\n\t\tlocal_var_sig_token = 0; //FIXME\n\n\tret = (MonoReflectionMethodBody*)mono_object_new (domain, System_Reflection_MethodBody);\n\n\tret->init_locals = header->init_locals;\n\tret->max_stack = header->max_stack;\n\tret->local_var_sig_token = local_var_sig_token;\n\tMONO_OBJECT_SETREF (ret, il, mono_array_new_cached (domain, mono_defaults.byte_class, header->code_size));\n\tmemcpy (mono_array_addr (ret->il, guint8, 0), header->code, header->code_size);\n\n\t/* Locals */\n\tMONO_OBJECT_SETREF (ret, locals, mono_array_new_cached (domain, System_Reflection_LocalVariableInfo, header->num_locals));\n\tfor (i = 0; i < header->num_locals; ++i) {\n\t\tMonoReflectionLocalVariableInfo *info = (MonoReflectionLocalVariableInfo*)mono_object_new (domain, System_Reflection_LocalVariableInfo);\n\t\tMONO_OBJECT_SETREF (info, local_type, mono_type_get_object (domain, header->locals [i]));\n\t\tinfo->is_pinned = header->locals [i]->pinned;\n\t\tinfo->local_index = i;\n\t\tmono_array_setref (ret->locals, i, info);\n\t}\n\n\t/* Exceptions */\n\tMONO_OBJECT_SETREF (ret, clauses, mono_array_new_cached (domain, System_Reflection_ExceptionHandlingClause, header->num_clauses));\n\tfor (i = 0; i < header->num_clauses; ++i) {\n\t\tMonoReflectionExceptionHandlingClause *info = (MonoReflectionExceptionHandlingClause*)mono_object_new (domain, System_Reflection_ExceptionHandlingClause);\n\t\tMonoExceptionClause *clause = &header->clauses [i];\n\n\t\tinfo->flags = clause->flags;\n\t\tinfo->try_offset = clause->try_offset;\n\t\tinfo->try_length = clause->try_len;\n\t\tinfo->handler_offset = clause->handler_offset;\n\t\tinfo->handler_length = clause->handler_len;\n\t\tif (clause->flags == MONO_EXCEPTION_CLAUSE_FILTER)\n\t\t\tinfo->filter_offset = clause->data.filter_offset;\n\t\telse if (clause->data.catch_class)\n\t\t\tMONO_OBJECT_SETREF (info, catch_type, mono_type_get_object (mono_domain_get (), &clause->data.catch_class->byval_arg));\n\n\t\tmono_array_setref (ret->clauses, i, info);\n\t}\n\n\tCACHE_OBJECT (MonoReflectionMethodBody *, method, ret, NULL);\n\treturn ret;\n}\n\n/**\n * mono_get_dbnull_object:\n * @domain: Domain where the object lives\n *\n * Returns the System.DBNull.Value singleton object\n *\n * Used as the value for ParameterInfo.DefaultValue \n */\nMonoObject *\nmono_get_dbnull_object (MonoDomain *domain)\n{\n\tMonoObject *obj;\n\tstatic MonoClassField *dbnull_value_field = NULL;\n\t\n\tif (!dbnull_value_field) {\n\t\tMonoClass *dbnull_klass;\n\t\tdbnull_klass = mono_class_from_name (mono_defaults.corlib, \"System\", \"DBNull\");\n\t\tmono_class_init (dbnull_klass);\n\t\tdbnull_value_field = mono_class_get_field_from_name (dbnull_klass, \"Value\");\n\t\tg_assert (dbnull_value_field);\n\t}\n\tobj = mono_field_get_value_object (domain, dbnull_value_field, NULL); \n\tg_assert (obj);\n\treturn obj;\n}\n\nstatic void\nget_default_param_value_blobs (MonoMethod *method, char **blobs, guint32 *types)\n{\n\tguint32 param_index, i, lastp, crow = 0;\n\tguint32 param_cols [MONO_PARAM_SIZE], const_cols [MONO_CONSTANT_SIZE];\n\tgint32 idx;\n\n\tMonoClass *klass = method->klass;\n\tMonoImage *image = klass->image;\n\tMonoMethodSignature *methodsig = mono_method_signature (method);\n\n\tMonoTableInfo *constt;\n\tMonoTableInfo *methodt;\n\tMonoTableInfo *paramt;\n\n\tif (!methodsig->param_count)\n\t\treturn;\n\n\tmono_class_init (klass);\n\n\tif (klass->image->dynamic) {\n\t\tMonoReflectionMethodAux *aux;\n\t\tif (method->is_inflated)\n\t\t\tmethod = ((MonoMethodInflated*)method)->declaring;\n\t\taux = g_hash_table_lookup (((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (aux && aux->param_defaults) {\n\t\t\tmemcpy (blobs, &(aux->param_defaults [1]), methodsig->param_count * sizeof (char*));\n\t\t\tmemcpy (types, &(aux->param_default_types [1]), methodsig->param_count * sizeof (guint32));\n\t\t}\n\t\treturn;\n\t}\n\n\tmethodt = &klass->image->tables [MONO_TABLE_METHOD];\n\tparamt = &klass->image->tables [MONO_TABLE_PARAM];\n\tconstt = &image->tables [MONO_TABLE_CONSTANT];\n\n\tidx = mono_method_get_index (method) - 1;\n\tg_assert (idx != -1);\n\n\tparam_index = mono_metadata_decode_row_col (methodt, idx, MONO_METHOD_PARAMLIST);\n\tif (idx + 1 < methodt->rows)\n\t\tlastp = mono_metadata_decode_row_col (methodt, idx + 1, MONO_METHOD_PARAMLIST);\n\telse\n\t\tlastp = paramt->rows + 1;\n\n\tfor (i = param_index; i < lastp; ++i) {\n\t\tguint32 paramseq;\n\n\t\tmono_metadata_decode_row (paramt, i - 1, param_cols, MONO_PARAM_SIZE);\n\t\tparamseq = param_cols [MONO_PARAM_SEQUENCE];\n\n\t\tif (!(param_cols [MONO_PARAM_FLAGS] & PARAM_ATTRIBUTE_HAS_DEFAULT))\n\t\t\tcontinue;\n\n\t\tcrow = mono_metadata_get_constant_index (image, MONO_TOKEN_PARAM_DEF | i, crow + 1);\n\t\tif (!crow) {\n\t\t\tcontinue;\n\t\t}\n\t\n\t\tmono_metadata_decode_row (constt, crow - 1, const_cols, MONO_CONSTANT_SIZE);\n\t\tblobs [paramseq - 1] = (gpointer) mono_metadata_blob_heap (image, const_cols [MONO_CONSTANT_VALUE]);\n\t\ttypes [paramseq - 1] = const_cols [MONO_CONSTANT_TYPE];\n\t}\n\n\treturn;\n}\n\nstatic MonoObject *\nmono_get_object_from_blob (MonoDomain *domain, MonoType *type, const char *blob)\n{\n\tvoid *retval;\n\tMonoClass *klass;\n\tMonoObject *object;\n\tMonoType *basetype = type;\n\n\tif (!blob)\n\t\treturn NULL;\n\t\n\tklass = mono_class_from_mono_type (type);\n\tif (klass->valuetype) {\n\t\tobject = mono_object_new (domain, klass);\n\t\tretval = ((gchar *) object + sizeof (MonoObject));\n\t\tif (klass->enumtype)\n\t\t\tbasetype = mono_class_enum_basetype (klass);\n\t} else {\n\t\tretval = &object;\n\t}\n\t\t\t\n\tif (!mono_get_constant_value_from_blob (domain, basetype->type,  blob, retval))\n\t\treturn object;\n\telse\n\t\treturn NULL;\n}\n\nstatic int\nassembly_name_to_aname (MonoAssemblyName *assembly, char *p) {\n\tint found_sep;\n\tchar *s;\n\n\tmemset (assembly, 0, sizeof (MonoAssemblyName));\n\tassembly->name = p;\n\tassembly->culture = \"\";\n\tmemset (assembly->public_key_token, 0, MONO_PUBLIC_KEY_TOKEN_LENGTH);\n\n\twhile (*p && (isalnum (*p) || *p == '.' || *p == '-' || *p == '_' || *p == '$' || *p == '@'))\n\t\tp++;\n\tfound_sep = 0;\n\twhile (g_ascii_isspace (*p) || *p == ',') {\n\t\t*p++ = 0;\n\t\tfound_sep = 1;\n\t\tcontinue;\n\t}\n\t/* failed */\n\tif (!found_sep)\n\t\treturn 1;\n\twhile (*p) {\n\t\tif (*p == 'V' && g_ascii_strncasecmp (p, \"Version=\", 8) == 0) {\n\t\t\tp += 8;\n\t\t\tassembly->major = strtoul (p, &s, 10);\n\t\t\tif (s == p || *s != '.')\n\t\t\t\treturn 1;\n\t\t\tp = ++s;\n\t\t\tassembly->minor = strtoul (p, &s, 10);\n\t\t\tif (s == p || *s != '.')\n\t\t\t\treturn 1;\n\t\t\tp = ++s;\n\t\t\tassembly->build = strtoul (p, &s, 10);\n\t\t\tif (s == p || *s != '.')\n\t\t\t\treturn 1;\n\t\t\tp = ++s;\n\t\t\tassembly->revision = strtoul (p, &s, 10);\n\t\t\tif (s == p)\n\t\t\t\treturn 1;\n\t\t\tp = s;\n\t\t} else if (*p == 'C' && g_ascii_strncasecmp (p, \"Culture=\", 8) == 0) {\n\t\t\tp += 8;\n\t\t\tif (g_ascii_strncasecmp (p, \"neutral\", 7) == 0) {\n\t\t\t\tassembly->culture = \"\";\n\t\t\t\tp += 7;\n\t\t\t} else {\n\t\t\t\tassembly->culture = p;\n\t\t\t\twhile (*p && *p != ',') {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (*p == 'P' && g_ascii_strncasecmp (p, \"PublicKeyToken=\", 15) == 0) {\n\t\t\tp += 15;\n\t\t\tif (strncmp (p, \"null\", 4) == 0) {\n\t\t\t\tp += 4;\n\t\t\t} else {\n\t\t\t\tint len;\n\t\t\t\tgchar *start = p;\n\t\t\t\twhile (*p && *p != ',') {\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\tlen = (p - start + 1);\n\t\t\t\tif (len > MONO_PUBLIC_KEY_TOKEN_LENGTH)\n\t\t\t\t\tlen = MONO_PUBLIC_KEY_TOKEN_LENGTH;\n\t\t\t\tg_strlcpy ((char*)assembly->public_key_token, start, len);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (*p && *p != ',')\n\t\t\t\tp++;\n\t\t}\n\t\tfound_sep = 0;\n\t\twhile (g_ascii_isspace (*p) || *p == ',') {\n\t\t\t*p++ = 0;\n\t\t\tfound_sep = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* failed */\n\t\tif (!found_sep)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * mono_reflection_parse_type:\n * @name: type name\n *\n * Parse a type name as accepted by the GetType () method and output the info\n * extracted in the info structure.\n * the name param will be mangled, so, make a copy before passing it to this function.\n * The fields in info will be valid until the memory pointed to by name is valid.\n *\n * See also mono_type_get_name () below.\n *\n * Returns: 0 on parse error.\n */\nstatic int\n_mono_reflection_parse_type (char *name, char **endptr, gboolean is_recursed,\n\t\t\t     MonoTypeNameParse *info)\n{\n\tchar *start, *p, *w, *temp, *last_point, *startn;\n\tint in_modifiers = 0;\n\tint isbyref = 0, rank, arity = 0, i;\n\n\tstart = p = w = name;\n\n\t//FIXME could we just zero the whole struct? memset (&info, 0, sizeof (MonoTypeNameParse))\n\tmemset (&info->assembly, 0, sizeof (MonoAssemblyName));\n\tinfo->name = info->name_space = NULL;\n\tinfo->nested = NULL;\n\tinfo->modifiers = NULL;\n\tinfo->type_arguments = NULL;\n\n\t/* last_point separates the namespace from the name */\n\tlast_point = NULL;\n\t/* Skips spaces */\n\twhile (*p == ' ') p++, start++, w++, name++;\n\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase '+':\n\t\t\t*p = 0; /* NULL terminate the name */\n\t\t\tstartn = p + 1;\n\t\t\tinfo->nested = g_list_append (info->nested, startn);\n\t\t\t/* we have parsed the nesting namespace + name */\n\t\t\tif (info->name)\n\t\t\t\tbreak;\n\t\t\tif (last_point) {\n\t\t\t\tinfo->name_space = start;\n\t\t\t\t*last_point = 0;\n\t\t\t\tinfo->name = last_point + 1;\n\t\t\t} else {\n\t\t\t\tinfo->name_space = (char *)\"\";\n\t\t\t\tinfo->name = start;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '.':\n\t\t\tlast_point = p;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\t++p;\n\t\t\tbreak;\n\t\tcase '&':\n\t\tcase '*':\n\t\tcase '[':\n\t\tcase ',':\n\t\tcase ']':\n\t\t\tin_modifiers = 1;\n\t\t\tbreak;\n\t\tcase '`':\n\t\t\t++p;\n\t\t\ti = strtol (p, &temp, 10);\n\t\t\tarity += i;\n\t\t\tif (p == temp)\n\t\t\t\treturn 0;\n\t\t\tp = temp-1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (in_modifiers)\n\t\t\tbreak;\n\t\t// *w++ = *p++;\n\t\tp++;\n\t}\n\t\n\tif (!info->name) {\n\t\tif (last_point) {\n\t\t\tinfo->name_space = start;\n\t\t\t*last_point = 0;\n\t\t\tinfo->name = last_point + 1;\n\t\t} else {\n\t\t\tinfo->name_space = (char *)\"\";\n\t\t\tinfo->name = start;\n\t\t}\n\t}\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase '&':\n\t\t\tif (isbyref) /* only one level allowed by the spec */\n\t\t\t\treturn 0;\n\t\t\tisbyref = 1;\n\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (0));\n\t\t\t*p++ = 0;\n\t\t\tbreak;\n\t\tcase '*':\n\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (-1));\n\t\t\t*p++ = 0;\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\tif (arity != 0) {\n\t\t\t\t*p++ = 0;\n\t\t\t\tinfo->type_arguments = g_ptr_array_new ();\n\t\t\t\tfor (i = 0; i < arity; i++) {\n\t\t\t\t\tMonoTypeNameParse *subinfo = g_new0 (MonoTypeNameParse, 1);\n\t\t\t\t\tgboolean fqname = FALSE;\n\n\t\t\t\t\tg_ptr_array_add (info->type_arguments, subinfo);\n\n\t\t\t\t\tif (*p == '[') {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tfqname = TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!_mono_reflection_parse_type (p, &p, TRUE, subinfo))\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t/*MS is lenient on [] delimited parameters that aren't fqn - and F# uses them.*/\n\t\t\t\t\tif (fqname && (*p != ']')) {\n\t\t\t\t\t\tchar *aname;\n\n\t\t\t\t\t\tif (*p != ',')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t*p++ = 0;\n\n\t\t\t\t\t\taname = p;\n\t\t\t\t\t\twhile (*p && (*p != ']'))\n\t\t\t\t\t\t\tp++;\n\n\t\t\t\t\t\tif (*p != ']')\n\t\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t\t*p++ = 0;\n\t\t\t\t\t\twhile (*aname) {\n\t\t\t\t\t\t\tif (g_ascii_isspace (*aname)) {\n\t\t\t\t\t\t\t\t++aname;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!*aname ||\n\t\t\t\t\t\t    !assembly_name_to_aname (&subinfo->assembly, aname))\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else if (fqname && (*p == ']')) {\n\t\t\t\t\t\t*p++ = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i + 1 < arity) {\n\t\t\t\t\t\tif (*p != ',')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (*p != ']')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t*p++ = 0;\n\t\t\t\t}\n\n\t\t\t\tarity = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trank = 1;\n\t\t\t*p++ = 0;\n\t\t\twhile (*p) {\n\t\t\t\tif (*p == ']')\n\t\t\t\t\tbreak;\n\t\t\t\tif (*p == ',')\n\t\t\t\t\trank++;\n\t\t\t\telse if (*p == '*') /* '*' means unknown lower bound */\n\t\t\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (-2));\n\t\t\t\telse\n\t\t\t\t\treturn 0;\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tif (*p++ != ']')\n\t\t\t\treturn 0;\n\t\t\tinfo->modifiers = g_list_append (info->modifiers, GUINT_TO_POINTER (rank));\n\t\t\tbreak;\n\t\tcase ']':\n\t\t\tif (is_recursed)\n\t\t\t\tgoto end;\n\t\t\treturn 0;\n\t\tcase ',':\n\t\t\tif (is_recursed)\n\t\t\t\tgoto end;\n\t\t\t*p++ = 0;\n\t\t\twhile (*p) {\n\t\t\t\tif (g_ascii_isspace (*p)) {\n\t\t\t\t\t++p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*p)\n\t\t\t\treturn 0; /* missing assembly name */\n\t\t\tif (!assembly_name_to_aname (&info->assembly, p))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t\tif (info->assembly.name)\n\t\t\tbreak;\n\t}\n\t// *w = 0; /* terminate class name */\n end:\n\tif (!info->name || !*info->name)\n\t\treturn 0;\n\tif (endptr)\n\t\t*endptr = p;\n\t/* add other consistency checks */\n\treturn 1;\n}\n\nint\nmono_reflection_parse_type (char *name, MonoTypeNameParse *info)\n{\n\treturn _mono_reflection_parse_type (name, NULL, FALSE, info);\n}\n\nstatic MonoType*\n_mono_reflection_get_type_from_info (MonoTypeNameParse *info, MonoImage *image, gboolean ignorecase)\n{\n\tgboolean type_resolve = FALSE;\n\tMonoType *type;\n\tMonoImage *rootimage = image;\n\n\tif (info->assembly.name) {\n\t\tMonoAssembly *assembly = mono_assembly_loaded (&info->assembly);\n\t\tif (!assembly && image && image->assembly && mono_assembly_names_equal (&info->assembly, &image->assembly->aname))\n\t\t\t/* \n\t\t\t * This could happen in the AOT compiler case when the search hook is not\n\t\t\t * installed.\n\t\t\t */\n\t\t\tassembly = image->assembly;\n\t\tif (!assembly) {\n\t\t\t/* then we must load the assembly ourselve - see #60439 */\n\t\t\tassembly = mono_assembly_load (&info->assembly, NULL, NULL);\n\t\t\tif (!assembly)\n\t\t\t\treturn NULL;\n\t\t}\n\t\timage = assembly->image;\n\t} else if (!image) {\n\t\timage = mono_defaults.corlib;\n\t}\n\n\ttype = mono_reflection_get_type_with_rootimage (rootimage, image, info, ignorecase, &type_resolve);\n\tif (type == NULL && !info->assembly.name && image != mono_defaults.corlib) {\n\t\timage = mono_defaults.corlib;\n\t\ttype = mono_reflection_get_type_with_rootimage (rootimage, image, info, ignorecase, &type_resolve);\n\t}\n\n\treturn type;\n}\n\nstatic MonoType*\nmono_reflection_get_type_internal (MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase)\n{\n\tMonoClass *klass;\n\tGList *mod;\n\tint modval;\n\tgboolean bounded = FALSE;\n\t\n\tif (!image)\n\t\timage = mono_defaults.corlib;\n\n\tif (ignorecase)\n\t\tklass = mono_class_from_name_case (image, info->name_space, info->name);\n\telse\n\t\tklass = mono_class_from_name (image, info->name_space, info->name);\n\tif (!klass)\n\t\treturn NULL;\n\tfor (mod = info->nested; mod; mod = mod->next) {\n\t\tgpointer iter = NULL;\n\t\tMonoClass *parent;\n\n\t\tparent = klass;\n\t\tmono_class_init (parent);\n\n\t\twhile ((klass = mono_class_get_nested_types (parent, &iter))) {\n\t\t\tif (ignorecase) {\n\t\t\t\tif (mono_utf8_strcasecmp (klass->name, mod->data) == 0)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (strcmp (klass->name, mod->data) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!klass)\n\t\t\tbreak;\n\t}\n\tif (!klass)\n\t\treturn NULL;\n\tmono_class_init (klass);\n\n\tif (info->type_arguments) {\n\t\tMonoType **type_args = g_new0 (MonoType *, info->type_arguments->len);\n\t\tMonoReflectionType *the_type;\n\t\tMonoType *instance;\n\t\tint i;\n\n\t\tfor (i = 0; i < info->type_arguments->len; i++) {\n\t\t\tMonoTypeNameParse *subinfo = g_ptr_array_index (info->type_arguments, i);\n\n\t\t\ttype_args [i] = _mono_reflection_get_type_from_info (subinfo, rootimage, ignorecase);\n\t\t\tif (!type_args [i]) {\n\t\t\t\tg_free (type_args);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tthe_type = mono_type_get_object (mono_domain_get (), &klass->byval_arg);\n\n\t\tinstance = mono_reflection_bind_generic_parameters (\n\t\t\tthe_type, info->type_arguments->len, type_args);\n\n\t\tg_free (type_args);\n\t\tif (!instance)\n\t\t\treturn NULL;\n\n\t\tklass = mono_class_from_mono_type (instance);\n\t}\n\n\tfor (mod = info->modifiers; mod; mod = mod->next) {\n\t\tmodval = GPOINTER_TO_UINT (mod->data);\n\t\tif (!modval) { /* byref: must be last modifier */\n\t\t\treturn &klass->this_arg;\n\t\t} else if (modval == -1) {\n\t\t\tklass = mono_ptr_class_get (&klass->byval_arg);\n\t\t} else if (modval == -2) {\n\t\t\tbounded = TRUE;\n\t\t} else { /* array rank */\n\t\t\tklass = mono_bounded_array_class_get (klass, modval, bounded);\n\t\t}\n\t\tmono_class_init (klass);\n\t}\n\n\treturn &klass->byval_arg;\n}\n\n/*\n * mono_reflection_get_type:\n * @image: a metadata context\n * @info: type description structure\n * @ignorecase: flag for case-insensitive string compares\n * @type_resolve: whenever type resolve was already tried\n *\n * Build a MonoType from the type description in @info.\n * \n */\n\nMonoType*\nmono_reflection_get_type (MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean *type_resolve) {\n\treturn mono_reflection_get_type_with_rootimage(image, image, info, ignorecase, type_resolve);\n}\n\nstatic MonoType*\nmono_reflection_get_type_internal_dynamic (MonoImage *rootimage, MonoAssembly *assembly, MonoTypeNameParse *info, gboolean ignorecase)\n{\n\tMonoReflectionAssemblyBuilder *abuilder;\n\tMonoType *type;\n\tint i;\n\n\tg_assert (assembly->dynamic);\n\tabuilder = (MonoReflectionAssemblyBuilder*)mono_assembly_get_object (((MonoDynamicAssembly*)assembly)->domain, assembly);\n\n\t/* Enumerate all modules */\n\n\ttype = NULL;\n\tif (abuilder->modules) {\n\t\tfor (i = 0; i < mono_array_length (abuilder->modules); ++i) {\n\t\t\tMonoReflectionModuleBuilder *mb = mono_array_get (abuilder->modules, MonoReflectionModuleBuilder*, i);\n\t\t\ttype = mono_reflection_get_type_internal (rootimage, &mb->dynamic_image->image, info, ignorecase);\n\t\t\tif (type)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!type && abuilder->loaded_modules) {\n\t\tfor (i = 0; i < mono_array_length (abuilder->loaded_modules); ++i) {\n\t\t\tMonoReflectionModule *mod = mono_array_get (abuilder->loaded_modules, MonoReflectionModule*, i);\n\t\t\ttype = mono_reflection_get_type_internal (rootimage, mod->image, info, ignorecase);\n\t\t\tif (type)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn type;\n}\n\t\nMonoType*\nmono_reflection_get_type_with_rootimage (MonoImage *rootimage, MonoImage* image, MonoTypeNameParse *info, gboolean ignorecase, gboolean *type_resolve)\n{\n\tMonoType *type;\n\tMonoReflectionAssembly *assembly;\n\tGString *fullName;\n\tGList *mod;\n\n\tif (image && image->dynamic)\n\t\ttype = mono_reflection_get_type_internal_dynamic (rootimage, image->assembly, info, ignorecase);\n\telse\n\t\ttype = mono_reflection_get_type_internal (rootimage, image, info, ignorecase);\n\tif (type)\n\t\treturn type;\n\tif (!mono_domain_has_type_resolve (mono_domain_get ()))\n\t\treturn NULL;\n\n\tif (type_resolve) {\n\t\tif (*type_resolve) \n\t\t\treturn NULL;\n\t\telse\n\t\t\t*type_resolve = TRUE;\n\t}\n\t\n\t/* Reconstruct the type name */\n\tfullName = g_string_new (\"\");\n\tif (info->name_space && (info->name_space [0] != '\\0'))\n\t\tg_string_printf (fullName, \"%s.%s\", info->name_space, info->name);\n\telse\n\t\tg_string_printf (fullName, \"%s\", info->name);\n\tfor (mod = info->nested; mod; mod = mod->next)\n\t\tg_string_append_printf (fullName, \"+%s\", (char*)mod->data);\n\n\tassembly = mono_domain_try_type_resolve ( mono_domain_get (), fullName->str, NULL);\n\tif (assembly) {\n\t\tif (assembly->assembly->dynamic)\n\t\t\ttype = mono_reflection_get_type_internal_dynamic (rootimage, assembly->assembly, info, ignorecase);\n\t\telse\n\t\t\ttype = mono_reflection_get_type_internal (rootimage, assembly->assembly->image, \n\t\t\t\t\t\t\t\t\t\t\t\t\t  info, ignorecase);\n\t}\n\tg_string_free (fullName, TRUE);\n\treturn type;\n}\n\nvoid\nmono_reflection_free_type_info (MonoTypeNameParse *info)\n{\n\tg_list_free (info->modifiers);\n\tg_list_free (info->nested);\n\n\tif (info->type_arguments) {\n\t\tint i;\n\n\t\tfor (i = 0; i < info->type_arguments->len; i++) {\n\t\t\tMonoTypeNameParse *subinfo = g_ptr_array_index (info->type_arguments, i);\n\n\t\t\tmono_reflection_free_type_info (subinfo);\n\t\t\t/*We free the subinfo since it is allocated by _mono_reflection_parse_type*/\n\t\t\tg_free (subinfo);\n\t\t}\n\n\t\tg_ptr_array_free (info->type_arguments, TRUE);\n\t}\n}\n\n/*\n * mono_reflection_type_from_name:\n * @name: type name.\n * @image: a metadata context (can be NULL).\n *\n * Retrieves a MonoType from its @name. If the name is not fully qualified,\n * it defaults to get the type from @image or, if @image is NULL or loading\n * from it fails, uses corlib.\n * \n */\nMonoType*\nmono_reflection_type_from_name (char *name, MonoImage *image)\n{\n\tMonoType *type = NULL;\n\tMonoTypeNameParse info;\n\tchar *tmp;\n\n\t/* Make a copy since parse_type modifies its argument */\n\ttmp = g_strdup (name);\n\t\n\t/*g_print (\"requested type %s\\n\", str);*/\n\tif (mono_reflection_parse_type (tmp, &info)) {\n\t\ttype = _mono_reflection_get_type_from_info (&info, image, FALSE);\n\t}\n\n\tg_free (tmp);\n\tmono_reflection_free_type_info (&info);\n\treturn type;\n}\n\n/*\n * mono_reflection_get_token:\n *\n *   Return the metadata token of OBJ which should be an object\n * representing a metadata element.\n */\nguint32\nmono_reflection_get_token (MonoObject *obj)\n{\n\tMonoClass *klass;\n\tguint32 token = 0;\n\n\tklass = obj->vtable->klass;\n\n\tif (strcmp (klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder *)obj;\n\n\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t} else if (strcmp (klass->name, \"ConstructorBuilder\") == 0) {\n\t\tMonoReflectionCtorBuilder *mb = (MonoReflectionCtorBuilder *)obj;\n\n\t\ttoken = mb->table_idx | MONO_TOKEN_METHOD_DEF;\n\t} else if (strcmp (klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder *)obj;\n\n\t\t/* Call mono_image_create_token so the object gets added to the tokens hash table */\n\t\ttoken = mono_image_create_token (((MonoReflectionTypeBuilder*)fb->typeb)->module->dynamic_image, obj, FALSE, TRUE);\n\t} else if (strcmp (klass->name, \"TypeBuilder\") == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)obj;\n\t\ttoken = tb->table_idx | MONO_TOKEN_TYPE_DEF;\n\t} else if (strcmp (klass->name, \"MonoType\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\ttoken = mono_class_from_mono_type (type)->type_token;\n\t} else if (strcmp (klass->name, \"MonoCMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericMethod\") == 0 ||\n\t\t   strcmp (klass->name, \"MonoGenericCMethod\") == 0) {\n\t\tMonoReflectionMethod *m = (MonoReflectionMethod *)obj;\n\t\tif (m->method->is_inflated) {\n\t\t\tMonoMethodInflated *inflated = (MonoMethodInflated *) m->method;\n\t\t\treturn inflated->declaring->token;\n\t\t} else {\n\t\t\ttoken = m->method->token;\n\t\t}\n\t} else if (strcmp (klass->name, \"MonoField\") == 0) {\n\t\tMonoReflectionField *f = (MonoReflectionField*)obj;\n\n\t\tif (is_field_on_inst (f->field)) {\n\t\t\tMonoDynamicGenericClass *dgclass = (MonoDynamicGenericClass*)f->field->parent->generic_class;\n\t\t\tint field_index = f->field - dgclass->fields;\n\t\t\tMonoObject *obj;\n\n\t\t\tg_assert (field_index >= 0 && field_index < dgclass->count_fields);\n\t\t\tobj = dgclass->field_objects [field_index];\n\t\t\treturn mono_reflection_get_token (obj);\n\t\t}\n\t\ttoken = mono_class_get_field_token (f->field);\n\t} else if (strcmp (klass->name, \"MonoProperty\") == 0) {\n\t\tMonoReflectionProperty *p = (MonoReflectionProperty*)obj;\n\n\t\ttoken = mono_class_get_property_token (p->property);\n\t} else if (strcmp (klass->name, \"MonoEvent\") == 0) {\n\t\tMonoReflectionMonoEvent *p = (MonoReflectionMonoEvent*)obj;\n\n\t\ttoken = mono_class_get_event_token (p->event);\n\t} else if (strcmp (klass->name, \"ParameterInfo\") == 0) {\n\t\tMonoReflectionParameter *p = (MonoReflectionParameter*)obj;\n\t\tMonoClass *member_class = mono_object_class (p->MemberImpl);\n\t\tg_assert (mono_class_is_reflection_method_or_constructor (member_class));\n\n\t\ttoken = mono_method_get_param_token (((MonoReflectionMethod*)p->MemberImpl)->method, p->PositionImpl);\n\t} else if (strcmp (klass->name, \"Module\") == 0) {\n\t\tMonoReflectionModule *m = (MonoReflectionModule*)obj;\n\n\t\ttoken = m->token;\n\t} else if (strcmp (klass->name, \"Assembly\") == 0) {\n\t\ttoken = mono_metadata_make_token (MONO_TABLE_ASSEMBLY, 1);\n\t} else {\n\t\tgchar *msg = g_strdup_printf (\"MetadataToken is not supported for type '%s.%s'\", klass->name_space, klass->name);\n\t\tMonoException *ex = mono_get_exception_not_implemented (msg);\n\t\tg_free (msg);\n\t\tmono_raise_exception (ex);\n\t}\n\n\treturn token;\n}\n\nstatic void*\nload_cattr_value (MonoImage *image, MonoType *t, const char *p, const char **end)\n{\n\tint slen, type = t->type;\n\tMonoClass *tklass = t->data.klass;\n\nhandle_enum:\n\tswitch (type) {\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_BOOLEAN: {\n\t\tMonoBoolean *bval = g_malloc (sizeof (MonoBoolean));\n\t\t*bval = *p;\n\t\t*end = p + 1;\n\t\treturn bval;\n\t}\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2: {\n\t\tguint16 *val = g_malloc (sizeof (guint16));\n\t\t*val = read16 (p);\n\t\t*end = p + 2;\n\t\treturn val;\n\t}\n#if SIZEOF_VOID_P == 4\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n#endif\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4: {\n\t\tguint32 *val = g_malloc (sizeof (guint32));\n\t\t*val = read32 (p);\n\t\t*end = p + 4;\n\t\treturn val;\n\t}\n#if SIZEOF_VOID_P == 8\n\tcase MONO_TYPE_U: /* error out instead? this should probably not happen */\n\tcase MONO_TYPE_I:\n#endif\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8: {\n\t\tguint64 *val = g_malloc (sizeof (guint64));\n\t\t*val = read64 (p);\n\t\t*end = p + 8;\n\t\treturn val;\n\t}\n\tcase MONO_TYPE_R8: {\n\t\tdouble *val = g_malloc (sizeof (double));\n\t\treadr8 (p, val);\n\t\t*end = p + 8;\n\t\treturn val;\n\t}\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (t->data.klass->enumtype) {\n\t\t\ttype = mono_class_enum_basetype (t->data.klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tg_error (\"generic valutype %s not handled in custom attr value decoding\", t->data.klass->name);\n\t\t}\n\t\tbreak;\n\tcase MONO_TYPE_STRING:\n\t\tif (*p == (char)0xFF) {\n\t\t\t*end = p + 1;\n\t\t\treturn NULL;\n\t\t}\n\t\tslen = mono_metadata_decode_value (p, &p);\n\t\t*end = p + slen;\n\t\treturn mono_string_new_len (mono_domain_get (), p, slen);\n\tcase MONO_TYPE_CLASS: {\n\t\tchar *n;\n\t\tMonoType *t;\n\t\tif (*p == (char)0xFF) {\n\t\t\t*end = p + 1;\n\t\t\treturn NULL;\n\t\t}\nhandle_type:\n\t\tslen = mono_metadata_decode_value (p, &p);\n\t\tn = g_memdup (p, slen + 1);\n\t\tn [slen] = 0;\n\t\tt = mono_reflection_type_from_name (n, image);\n\t\tif (!t)\n\t\t\tg_warning (\"Cannot load type '%s'\", n);\n\t\tg_free (n);\n\t\t*end = p + slen;\n\t\tif (t)\n\t\t\treturn mono_type_get_object (mono_domain_get (), t);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\tcase MONO_TYPE_OBJECT: {\n\t\tchar subt = *p++;\n\t\tMonoObject *obj;\n\t\tMonoClass *subc = NULL;\n\t\tvoid *val;\n\n\t\tif (subt == 0x50) {\n\t\t\tgoto handle_type;\n\t\t} else if (subt == 0x0E) {\n\t\t\ttype = MONO_TYPE_STRING;\n\t\t\tgoto handle_enum;\n\t\t} else if (subt == 0x1D) {\n\t\t\tMonoType simple_type = {{0}};\n\t\t\tint etype = *p;\n\t\t\tp ++;\n\n\t\t\tif (etype == 0x51)\n\t\t\t\t/* See Partition II, Appendix B3 */\n\t\t\t\tetype = MONO_TYPE_OBJECT;\n\t\t\ttype = MONO_TYPE_SZARRAY;\n\t\t\tsimple_type.type = etype;\n\t\t\ttklass = mono_class_from_mono_type (&simple_type);\n\t\t\tgoto handle_enum;\n\t\t} else if (subt == 0x55) {\n\t\t\tchar *n;\n\t\t\tMonoType *t;\n\t\t\tslen = mono_metadata_decode_value (p, &p);\n\t\t\tn = g_memdup (p, slen + 1);\n\t\t\tn [slen] = 0;\n\t\t\tt = mono_reflection_type_from_name (n, image);\n\t\t\tif (!t)\n\t\t\t\tg_error (\"Cannot load type '%s'\", n);\n\t\t\tg_free (n);\n\t\t\tp += slen;\n\t\t\tsubc = mono_class_from_mono_type (t);\n\t\t} else if (subt >= MONO_TYPE_BOOLEAN && subt <= MONO_TYPE_R8) {\n\t\t\tMonoType simple_type = {{0}};\n\t\t\tsimple_type.type = subt;\n\t\t\tsubc = mono_class_from_mono_type (&simple_type);\n\t\t} else {\n\t\t\tg_error (\"Unknown type 0x%02x for object type encoding in custom attr\", subt);\n\t\t}\n\t\tval = load_cattr_value (image, &subc->byval_arg, p, end);\n\t\tobj = mono_object_new (mono_domain_get (), subc);\n\t\tmemcpy ((char*)obj + sizeof (MonoObject), val, mono_class_value_size (subc, NULL));\n\t\tg_free (val);\n\t\treturn obj;\n\t}\n\tcase MONO_TYPE_SZARRAY: {\n\t\tMonoArray *arr;\n\t\tguint32 i, alen, basetype;\n\t\talen = read32 (p);\n\t\tp += 4;\n\t\tif (alen == 0xffffffff) {\n\t\t\t*end = p;\n\t\t\treturn NULL;\n\t\t}\n\t\tarr = mono_array_new (mono_domain_get(), tklass, alen);\n\t\tbasetype = tklass->byval_arg.type;\n\t\tif (basetype == MONO_TYPE_VALUETYPE && tklass->enumtype)\n\t\t\tbasetype = mono_class_enum_basetype (tklass)->type;\n\t\tswitch (basetype)\n\t\t{\n\t\t\tcase MONO_TYPE_U1:\n\t\t\tcase MONO_TYPE_I1:\n\t\t\tcase MONO_TYPE_BOOLEAN:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tMonoBoolean val = *p++;\n\t\t\t\t\tmono_array_set (arr, MonoBoolean, i, val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_CHAR:\n\t\t\tcase MONO_TYPE_U2:\n\t\t\tcase MONO_TYPE_I2:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tguint16 val = read16 (p);\n\t\t\t\t\tmono_array_set (arr, guint16, i, val);\n\t\t\t\t\tp += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_R4:\n\t\t\tcase MONO_TYPE_U4:\n\t\t\tcase MONO_TYPE_I4:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tguint32 val = read32 (p);\n\t\t\t\t\tmono_array_set (arr, guint32, i, val);\n\t\t\t\t\tp += 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_R8:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tdouble val;\n\t\t\t\t\treadr8 (p, &val);\n\t\t\t\t\tmono_array_set (arr, double, i, val);\n\t\t\t\t\tp += 8;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_U8:\n\t\t\tcase MONO_TYPE_I8:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tguint64 val = read64 (p);\n\t\t\t\t\tmono_array_set (arr, guint64, i, val);\n\t\t\t\t\tp += 8;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MONO_TYPE_CLASS:\n\t\t\tcase MONO_TYPE_OBJECT:\n\t\t\tcase MONO_TYPE_STRING:\n\t\t\t\tfor (i = 0; i < alen; i++) {\n\t\t\t\t\tMonoObject *item = load_cattr_value (image, &tklass->byval_arg, p, &p);\n\t\t\t\t\tmono_array_setref (arr, i, item);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_error (\"Type 0x%02x not handled in custom attr array decoding\", basetype);\n\t\t}\n\t\t*end=p;\n\t\treturn arr;\n\t}\n\tdefault:\n\t\tg_error (\"Type 0x%02x not handled in custom attr value decoding\", type);\n\t}\n\treturn NULL;\n}\n\nstatic MonoObject*\ncreate_cattr_typed_arg (MonoType *t, MonoObject *val)\n{\n\tstatic MonoClass *klass;\n\tstatic MonoMethod *ctor;\n\tMonoObject *retval;\n\tvoid *params [2], *unboxed;\n\n\tif (!klass)\n\t\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"CustomAttributeTypedArgument\");\n\tif (!ctor)\n\t\tctor = mono_class_get_method_from_name (klass, \".ctor\", 2);\n\t\n\tparams [0] = mono_type_get_object (mono_domain_get (), t);\n\tparams [1] = val;\n\tretval = mono_object_new (mono_domain_get (), klass);\n\tunboxed = mono_object_unbox (retval);\n\tmono_runtime_invoke (ctor, unboxed, params, NULL);\n\n\treturn retval;\n}\n\nstatic MonoObject*\ncreate_cattr_named_arg (void *minfo, MonoObject *typedarg)\n{\n\tstatic MonoClass *klass;\n\tstatic MonoMethod *ctor;\n\tMonoObject *retval;\n\tvoid *unboxed, *params [2];\n\n\tif (!klass)\n\t\tklass = mono_class_from_name (mono_defaults.corlib, \"System.Reflection\", \"CustomAttributeNamedArgument\");\n\tif (!ctor)\n\t\tctor = mono_class_get_method_from_name (klass, \".ctor\", 2);\n\n\tparams [0] = minfo;\n\tparams [1] = typedarg;\n\tretval = mono_object_new (mono_domain_get (), klass);\n\tunboxed = mono_object_unbox (retval);\n\tmono_runtime_invoke (ctor, unboxed, params, NULL);\n\n\treturn retval;\n}\n\nstatic gboolean\ntype_is_reference (MonoType *type)\n{\n\tswitch (type->type) {\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U:\n\tcase MONO_TYPE_I:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\tcase MONO_TYPE_R8:\n\tcase MONO_TYPE_R4:\n\tcase MONO_TYPE_VALUETYPE:\n\t\treturn FALSE;\n\tdefault:\n\t\treturn TRUE;\n\t}\n}\n\nstatic void\nfree_param_data (MonoMethodSignature *sig, void **params) {\n\tint i;\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\tif (!type_is_reference (sig->params [i]))\n\t\t\tg_free (params [i]);\n\t}\n}\n\n/*\n * Find the field index in the metadata FieldDef table.\n */\nstatic guint32\nfind_field_index (MonoClass *klass, MonoClassField *field) {\n\tint i;\n\n\tfor (i = 0; i < klass->field.count; ++i) {\n\t\tif (field == &klass->fields [i])\n\t\t\treturn klass->field.first + 1 + i;\n\t}\n\treturn 0;\n}\n\n/*\n * Find the property index in the metadata Property table.\n */\nstatic guint32\nfind_property_index (MonoClass *klass, MonoProperty *property) {\n\tint i;\n\n\tfor (i = 0; i < klass->ext->property.count; ++i) {\n\t\tif (property == &klass->ext->properties [i])\n\t\t\treturn klass->ext->property.first + 1 + i;\n\t}\n\treturn 0;\n}\n\n/*\n * Find the event index in the metadata Event table.\n */\nstatic guint32\nfind_event_index (MonoClass *klass, MonoEvent *event) {\n\tint i;\n\n\tfor (i = 0; i < klass->ext->event.count; ++i) {\n\t\tif (event == &klass->ext->events [i])\n\t\t\treturn klass->ext->event.first + 1 + i;\n\t}\n\treturn 0;\n}\n\nstatic MonoObject*\ncreate_custom_attr (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len)\n{\n\tconst char *p = (const char*)data;\n\tconst char *named;\n\tguint32 i, j, num_named;\n\tMonoObject *attr;\n\tvoid *params_buf [32];\n\tvoid **params;\n\tMonoMethodSignature *sig;\n\n\tmono_class_init (method->klass);\n\n\tif (len == 0) {\n\t\tattr = mono_object_new (mono_domain_get (), method->klass);\n\t\tmono_runtime_invoke (method, attr, NULL, NULL);\n\t\treturn attr;\n\t}\n\n\tif (len < 2 || read16 (p) != 0x0001) /* Prolog */\n\t\treturn NULL;\n\n\t/*g_print (\"got attr %s\\n\", method->klass->name);*/\n\n\tsig = mono_method_signature (method);\n\tif (sig->param_count < 32)\n\t\tparams = params_buf;\n\telse\n\t\t/* Allocate using GC so it gets GC tracking */\n\t\tparams = mono_gc_alloc_fixed (sig->param_count * sizeof (void*), NULL);\n\n\t/* skip prolog */\n\tp += 2;\n\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i) {\n\t\tparams [i] = load_cattr_value (image, mono_method_signature (method)->params [i], p, &p);\n\t}\n\n\tnamed = p;\n\tattr = mono_object_new (mono_domain_get (), method->klass);\n\tmono_runtime_invoke (method, attr, params, NULL);\n\tfree_param_data (method->signature, params);\n\tnum_named = read16 (named);\n\tnamed += 2;\n\tfor (j = 0; j < num_named; j++) {\n\t\tgint name_len;\n\t\tchar *name, named_type, data_type;\n\t\tnamed_type = *named++;\n\t\tdata_type = *named++; /* type of data */\n\t\tif (data_type == MONO_TYPE_SZARRAY)\n\t\t\tdata_type = *named++;\n\t\tif (data_type == MONO_TYPE_ENUM) {\n\t\t\tgint type_len;\n\t\t\tchar *type_name;\n\t\t\ttype_len = mono_metadata_decode_blob_size (named, &named);\n\t\t\ttype_name = g_malloc (type_len + 1);\n\t\t\tmemcpy (type_name, named, type_len);\n\t\t\ttype_name [type_len] = 0;\n\t\t\tnamed += type_len;\n\t\t\t/* FIXME: lookup the type and check type consistency */\n\t\t\tg_free (type_name);\n\t\t}\n\t\tname_len = mono_metadata_decode_blob_size (named, &named);\n\t\tname = g_malloc (name_len + 1);\n\t\tmemcpy (name, named, name_len);\n\t\tname [name_len] = 0;\n\t\tnamed += name_len;\n\t\tif (named_type == 0x53) {\n\t\t\tMonoClassField *field = mono_class_get_field_from_name (mono_object_class (attr), name);\n\t\t\tvoid *val = load_cattr_value (image, field->type, named, &named);\n\t\t\tmono_field_set_value (attr, field, val);\n\t\t\tif (!type_is_reference (field->type))\n\t\t\t\tg_free (val);\n\t\t} else if (named_type == 0x54) {\n\t\t\tMonoProperty *prop;\n\t\t\tvoid *pparams [1];\n\t\t\tMonoType *prop_type;\n\n\t\t\tprop = mono_class_get_property_from_name (mono_object_class (attr), name);\n\t\t\t/* can we have more that 1 arg in a custom attr named property? */\n\t\t\tprop_type = prop->get? mono_method_signature (prop->get)->ret :\n\t\t\t     mono_method_signature (prop->set)->params [mono_method_signature (prop->set)->param_count - 1];\n\t\t\tpparams [0] = load_cattr_value (image, prop_type, named, &named);\n\t\t\tmono_property_set_value (prop, attr, pparams, NULL);\n\t\t\tif (!type_is_reference (prop_type))\n\t\t\t\tg_free (pparams [0]);\n\t\t}\n\t\tg_free (name);\n\t}\n\n\tif (params != params_buf)\n\t\tmono_gc_free_fixed (params);\n\n\treturn attr;\n}\n\t\n/*\n * mono_reflection_create_custom_attr_data_args:\n *\n *   Create an array of typed and named arguments from the cattr blob given by DATA.\n * TYPED_ARGS and NAMED_ARGS will contain the objects representing the arguments,\n * NAMED_ARG_INFO will contain information about the named arguments.\n */\nvoid\nmono_reflection_create_custom_attr_data_args (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len, MonoArray **typed_args, MonoArray **named_args, CattrNamedArg **named_arg_info)\n{\n\tMonoArray *typedargs, *namedargs;\n\tMonoClass *attrklass;\n\tMonoDomain *domain;\n\tconst char *p = (const char*)data;\n\tconst char *named;\n\tguint32 i, j, num_named;\n\tCattrNamedArg *arginfo = NULL;\n\n\tmono_class_init (method->klass);\n\n\t*typed_args = NULL;\n\t*named_args = NULL;\n\t*named_arg_info = NULL;\n\t\n\tdomain = mono_domain_get ();\n\n\tif (len < 2 || read16 (p) != 0x0001) /* Prolog */\n\t\treturn;\n\n\ttypedargs = mono_array_new (domain, mono_get_object_class (), mono_method_signature (method)->param_count);\n\t\n\t/* skip prolog */\n\tp += 2;\n\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i) {\n\t\tMonoObject *obj;\n\t\tvoid *val;\n\n\t\tval = load_cattr_value (image, mono_method_signature (method)->params [i], p, &p);\n\t\tobj = type_is_reference (mono_method_signature (method)->params [i]) ? \n\t\t\tval : mono_value_box (domain, mono_class_from_mono_type (mono_method_signature (method)->params [i]), val);\n\t\tmono_array_setref (typedargs, i, obj);\n\n\t\tif (!type_is_reference (mono_method_signature (method)->params [i]))\n\t\t\tg_free (val);\n\t}\n\n\tnamed = p;\n\tnum_named = read16 (named);\n\tnamedargs = mono_array_new (domain, mono_get_object_class (), num_named);\n\tnamed += 2;\n\tattrklass = method->klass;\n\n\targinfo = g_new0 (CattrNamedArg, num_named);\n\t*named_arg_info = arginfo;\n\n\tfor (j = 0; j < num_named; j++) {\n\t\tgint name_len;\n\t\tchar *name, named_type, data_type;\n\t\tnamed_type = *named++;\n\t\tdata_type = *named++; /* type of data */\n\t\tif (data_type == MONO_TYPE_SZARRAY)\n\t\t\tdata_type = *named++;\n\t\tif (data_type == MONO_TYPE_ENUM) {\n\t\t\tgint type_len;\n\t\t\tchar *type_name;\n\t\t\ttype_len = mono_metadata_decode_blob_size (named, &named);\n\t\t\ttype_name = g_malloc (type_len + 1);\n\t\t\tmemcpy (type_name, named, type_len);\n\t\t\ttype_name [type_len] = 0;\n\t\t\tnamed += type_len;\n\t\t\t/* FIXME: lookup the type and check type consistency */\n\t\t\tg_free (type_name);\n\t\t}\n\t\tname_len = mono_metadata_decode_blob_size (named, &named);\n\t\tname = g_malloc (name_len + 1);\n\t\tmemcpy (name, named, name_len);\n\t\tname [name_len] = 0;\n\t\tnamed += name_len;\n\t\tif (named_type == 0x53) {\n\t\t\tMonoObject *obj;\n\t\t\tMonoClassField *field = mono_class_get_field_from_name (attrklass, name);\n\t\t\tvoid *val;\n\n\t\t\targinfo [j].type = field->type;\n\t\t\targinfo [j].field = field;\n\n\t\t\tval = load_cattr_value (image, field->type, named, &named);\n\t\t\tobj = type_is_reference (field->type) ? val : mono_value_box (domain, mono_class_from_mono_type (field->type), val);\n\t\t\tmono_array_setref (namedargs, j, obj);\n\t\t\tif (!type_is_reference (field->type))\n\t\t\t\tg_free (val);\n\t\t} else if (named_type == 0x54) {\n\t\t\tMonoObject *obj;\n\t\t\tMonoType *prop_type;\n\t\t\tMonoProperty *prop = mono_class_get_property_from_name (attrklass, name);\n\t\t\tvoid *val;\n\n\t\t\tprop_type = prop->get? mono_method_signature (prop->get)->ret :\n\t\t\t     mono_method_signature (prop->set)->params [mono_method_signature (prop->set)->param_count - 1];\n\n\t\t\targinfo [j].type = prop_type;\n\t\t\targinfo [j].prop = prop;\n\n\t\t\tval = load_cattr_value (image, prop_type, named, &named);\n\t\t\tobj = type_is_reference (prop_type) ? val : mono_value_box (domain, mono_class_from_mono_type (prop_type), val);\n\t\t\tmono_array_setref (namedargs, j, obj);\n\t\t\tif (!type_is_reference (prop_type))\n\t\t\t\tg_free (val);\n\t\t}\n\t\tg_free (name);\n\t}\n\n\t*typed_args = typedargs;\n\t*named_args = namedargs;\n}\n\nstatic MonoObject*\ncreate_custom_attr_data (MonoImage *image, MonoMethod *method, const guchar *data, guint32 len)\n{\n\tMonoArray *typedargs, *namedargs;\n\tstatic MonoMethod *ctor;\n\tMonoDomain *domain;\n\tMonoObject *attr;\n\tvoid *params [3];\n\tCattrNamedArg *arginfo;\n\tint i;\n\n\tmono_class_init (method->klass);\n\n\tif (!ctor)\n\t\tctor = mono_class_get_method_from_name (mono_defaults.customattribute_data_class, \".ctor\", 3);\n\n\tdomain = mono_domain_get ();\n\tif (len == 0) {\n\t\t/* This is for Attributes with no parameters */\n\t\tattr = mono_object_new (domain, mono_defaults.customattribute_data_class);\n\t\tparams [0] = mono_method_get_object (domain, method, NULL);\n\t\tparams [1] = params [2] = NULL;\n\t\tmono_runtime_invoke (method, attr, params, NULL);\n\t\treturn attr;\n\t}\n\n\tmono_reflection_create_custom_attr_data_args (image, method, data, len, &typedargs, &namedargs, &arginfo);\n\tif (!typedargs || !namedargs)\n\t\treturn NULL;\n\n\tfor (i = 0; i < mono_method_signature (method)->param_count; ++i) {\n\t\tMonoObject *obj = mono_array_get (typedargs, MonoObject*, i);\n\t\tMonoObject *typedarg;\n\n\t\ttypedarg = create_cattr_typed_arg (mono_method_signature (method)->params [i], obj);\n\t\tmono_array_setref (typedargs, i, typedarg);\n\t}\n\n\tfor (i = 0; i < mono_array_length (namedargs); ++i) {\n\t\tMonoObject *obj = mono_array_get (namedargs, MonoObject*, i);\n\t\tMonoObject *typedarg, *namedarg, *minfo;\n\n\t\tif (arginfo [i].prop)\n\t\t\tminfo = (MonoObject*)mono_property_get_object (domain, NULL, arginfo [i].prop);\n\t\telse\n\t\t\tminfo = (MonoObject*)mono_field_get_object (domain, NULL, arginfo [i].field);\n\n\t\ttypedarg = create_cattr_typed_arg (arginfo [i].type, obj);\n\t\tnamedarg = create_cattr_named_arg (minfo, typedarg);\n\n\t\tmono_array_setref (namedargs, i, namedarg);\n\t}\n\n\tattr = mono_object_new (domain, mono_defaults.customattribute_data_class);\n\tparams [0] = mono_method_get_object (domain, method, NULL);\n\tparams [1] = typedargs;\n\tparams [2] = namedargs;\n\tmono_runtime_invoke (ctor, attr, params, NULL);\n\treturn attr;\n}\n\nMonoArray*\nmono_custom_attrs_construct (MonoCustomAttrInfo *cinfo)\n{\n\tMonoArray *result;\n\tMonoObject *attr;\n\tint i;\n\n\tresult = mono_array_new_cached (mono_domain_get (), mono_defaults.attribute_class, cinfo->num_attrs);\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tif (!cinfo->attrs [i].ctor)\n\t\t\t/* The cattr type is not finished yet */\n\t\t\t/* We should include the type name but cinfo doesn't contain it */\n\t\t\tmono_raise_exception (mono_get_exception_type_load (NULL, NULL));\n\t\tattr = create_custom_attr (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);\n\t\tmono_array_setref (result, i, attr);\n\t}\n\treturn result;\n}\n\nstatic MonoArray*\nmono_custom_attrs_construct_by_type (MonoCustomAttrInfo *cinfo, MonoClass *attr_klass)\n{\n\tMonoArray *result;\n\tMonoObject *attr;\n\tint i, n;\n\n\tn = 0;\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tif (mono_class_is_assignable_from (attr_klass, cinfo->attrs [i].ctor->klass))\n\t\t\tn ++;\n\t}\n\n\tresult = mono_array_new_cached (mono_domain_get (), mono_defaults.attribute_class, n);\n\tn = 0;\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tif (mono_class_is_assignable_from (attr_klass, cinfo->attrs [i].ctor->klass)) {\n\t\t\tattr = create_custom_attr (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);\n\t\t\tmono_array_setref (result, n, attr);\n\t\t\tn ++;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic MonoArray*\nmono_custom_attrs_data_construct (MonoCustomAttrInfo *cinfo)\n{\n\tMonoArray *result;\n\tMonoObject *attr;\n\tint i;\n\t\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.customattribute_data_class, cinfo->num_attrs);\n\tfor (i = 0; i < cinfo->num_attrs; ++i) {\n\t\tattr = create_custom_attr_data (cinfo->image, cinfo->attrs [i].ctor, cinfo->attrs [i].data, cinfo->attrs [i].data_size);\n\t\tmono_array_setref (result, i, attr);\n\t}\n\treturn result;\n}\n\n/**\n * mono_custom_attrs_from_index:\n *\n * Returns: NULL if no attributes are found or if a loading error occurs.\n */\nMonoCustomAttrInfo*\nmono_custom_attrs_from_index (MonoImage *image, guint32 idx)\n{\n\tguint32 mtoken, i, len;\n\tguint32 cols [MONO_CUSTOM_ATTR_SIZE];\n\tMonoTableInfo *ca;\n\tMonoCustomAttrInfo *ainfo;\n\tGList *tmp, *list = NULL;\n\tconst char *data;\n\n\tca = &image->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\n\ti = mono_metadata_custom_attrs_from_index (image, idx);\n\tif (!i)\n\t\treturn NULL;\n\ti --;\n\twhile (i < ca->rows) {\n\t\tif (mono_metadata_decode_row_col (ca, i, MONO_CUSTOM_ATTR_PARENT) != idx)\n\t\t\tbreak;\n\t\tlist = g_list_prepend (list, GUINT_TO_POINTER (i));\n\t\t++i;\n\t}\n\tlen = g_list_length (list);\n\tif (!len)\n\t\treturn NULL;\n\tainfo = g_malloc0 (MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * len);\n\tainfo->num_attrs = len;\n\tainfo->image = image;\n\tfor (i = 0, tmp = list; i < len; ++i, tmp = tmp->next) {\n\t\tmono_metadata_decode_row (ca, GPOINTER_TO_UINT (tmp->data), cols, MONO_CUSTOM_ATTR_SIZE);\n\t\tmtoken = cols [MONO_CUSTOM_ATTR_TYPE] >> MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\tswitch (cols [MONO_CUSTOM_ATTR_TYPE] & MONO_CUSTOM_ATTR_TYPE_MASK) {\n\t\tcase MONO_CUSTOM_ATTR_TYPE_METHODDEF:\n\t\t\tmtoken |= MONO_TOKEN_METHOD_DEF;\n\t\t\tbreak;\n\t\tcase MONO_CUSTOM_ATTR_TYPE_MEMBERREF:\n\t\t\tmtoken |= MONO_TOKEN_MEMBER_REF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_error (\"Unknown table for custom attr type %08x\", cols [MONO_CUSTOM_ATTR_TYPE]);\n\t\t\tbreak;\n\t\t}\n\t\tainfo->attrs [i].ctor = mono_get_method (image, mtoken, NULL);\n\t\tif (!ainfo->attrs [i].ctor) {\n\t\t\tg_warning (\"Can't find custom attr constructor image: %s mtoken: 0x%08x\", image->name, mtoken);\n\t\t\tg_list_free (list);\n\t\t\tg_free (ainfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tdata = mono_metadata_blob_heap (image, cols [MONO_CUSTOM_ATTR_VALUE]);\n\t\tainfo->attrs [i].data_size = mono_metadata_decode_value (data, &data);\n\t\tainfo->attrs [i].data = (guchar*)data;\n\t}\n\tg_list_free (list);\n\n\treturn ainfo;\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_method (MonoMethod *method)\n{\n\tguint32 idx;\n\n\t/*\n\t * An instantiated method has the same cattrs as the generic method definition.\n\t *\n\t * LAMESPEC: The .NET SRE throws an exception for instantiations of generic method builders\n\t *           Note that this stanza is not necessary for non-SRE types, but it's a micro-optimization\n\t */\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\t\n\tif (method->dynamic || method->klass->image->dynamic)\n\t\treturn lookup_custom_attr (method->klass->image, method);\n\n\tif (!method->token)\n\t\t/* Synthetic methods */\n\t\treturn NULL;\n\n\tidx = mono_method_get_index (method);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_METHODDEF;\n\treturn mono_custom_attrs_from_index (method->klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_class (MonoClass *klass)\n{\n\tguint32 idx;\n\n\tif (klass->generic_class)\n\t\tklass = klass->generic_class->container_class;\n\n\tif (klass->image->dynamic)\n\t\treturn lookup_custom_attr (klass->image, klass);\n\n\tif (klass->byval_arg.type == MONO_TYPE_VAR || klass->byval_arg.type == MONO_TYPE_MVAR) {\n\t\tidx = mono_metadata_token_index (klass->sizes.generic_param_token);\n\t\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\t\tidx |= MONO_CUSTOM_ATTR_GENERICPAR;\n\t} else {\n\t\tidx = mono_metadata_token_index (klass->type_token);\n\t\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\t\tidx |= MONO_CUSTOM_ATTR_TYPEDEF;\n\t}\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_assembly (MonoAssembly *assembly)\n{\n\tguint32 idx;\n\t\n\tif (assembly->image->dynamic)\n\t\treturn lookup_custom_attr (assembly->image, assembly);\n\tidx = 1; /* there is only one assembly */\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_ASSEMBLY;\n\treturn mono_custom_attrs_from_index (assembly->image, idx);\n}\n\nstatic MonoCustomAttrInfo*\nmono_custom_attrs_from_module (MonoImage *image)\n{\n\tguint32 idx;\n\t\n\tif (image->dynamic)\n\t\treturn lookup_custom_attr (image, image);\n\tidx = 1; /* there is only one module */\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_MODULE;\n\treturn mono_custom_attrs_from_index (image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_property (MonoClass *klass, MonoProperty *property)\n{\n\tguint32 idx;\n\t\n\tif (klass->image->dynamic) {\n\t\tproperty = mono_metadata_get_corresponding_property_from_generic_type_definition (property);\n\t\treturn lookup_custom_attr (klass->image, property);\n\t}\n\tidx = find_property_index (klass, property);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_PROPERTY;\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_event (MonoClass *klass, MonoEvent *event)\n{\n\tguint32 idx;\n\t\n\tif (klass->image->dynamic) {\n\t\tevent = mono_metadata_get_corresponding_event_from_generic_type_definition (event);\n\t\treturn lookup_custom_attr (klass->image, event);\n\t}\n\tidx = find_event_index (klass, event);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_EVENT;\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_field (MonoClass *klass, MonoClassField *field)\n{\n\tguint32 idx;\n\tif (klass->image->dynamic) {\n\t\tfield = mono_metadata_get_corresponding_field_from_generic_type_definition (field);\n\t\treturn lookup_custom_attr (klass->image, field);\n\t}\n\tidx = find_field_index (klass, field);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_FIELDDEF;\n\treturn mono_custom_attrs_from_index (klass->image, idx);\n}\n\nMonoCustomAttrInfo*\nmono_custom_attrs_from_param (MonoMethod *method, guint32 param)\n{\n\tMonoTableInfo *ca;\n\tguint32 i, idx, method_index;\n\tguint32 param_list, param_last, param_pos, found;\n\tMonoImage *image;\n\tMonoReflectionMethodAux *aux;\n\n\t/*\n\t * An instantiated method has the same cattrs as the generic method definition.\n\t *\n\t * LAMESPEC: The .NET SRE throws an exception for instantiations of generic method builders\n\t *           Note that this stanza is not necessary for non-SRE types, but it's a micro-optimization\n\t */\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoCustomAttrInfo *res, *ainfo;\n\t\tint size;\n\n\t\taux = g_hash_table_lookup (((MonoDynamicImage*)method->klass->image)->method_aux_hash, method);\n\t\tif (!aux || !aux->param_cattr)\n\t\t\treturn NULL;\n\n\t\t/* Need to copy since it will be freed later */\n\t\tainfo = aux->param_cattr [param];\n\t\tif (!ainfo)\n\t\t\treturn NULL;\n\t\tsize = MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * ainfo->num_attrs;\n\t\tres = g_malloc0 (size);\n\t\tmemcpy (res, ainfo, size);\n\t\treturn res;\n\t}\n\n\timage = method->klass->image;\n\tmethod_index = mono_method_get_index (method);\n\tca = &image->tables [MONO_TABLE_METHOD];\n\n\tparam_list = mono_metadata_decode_row_col (ca, method_index - 1, MONO_METHOD_PARAMLIST);\n\tif (method_index == ca->rows) {\n\t\tca = &image->tables [MONO_TABLE_PARAM];\n\t\tparam_last = ca->rows + 1;\n\t} else {\n\t\tparam_last = mono_metadata_decode_row_col (ca, method_index, MONO_METHOD_PARAMLIST);\n\t\tca = &image->tables [MONO_TABLE_PARAM];\n\t}\n\tfound = FALSE;\n\tfor (i = param_list; i < param_last; ++i) {\n\t\tparam_pos = mono_metadata_decode_row_col (ca, i - 1, MONO_PARAM_SEQUENCE);\n\t\tif (param_pos == param) {\n\t\t\tfound = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn NULL;\n\tidx = i;\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_PARAMDEF;\n\treturn mono_custom_attrs_from_index (image, idx);\n}\n\ngboolean\nmono_custom_attrs_has_attr (MonoCustomAttrInfo *ainfo, MonoClass *attr_klass)\n{\n\tint i;\n\tMonoClass *klass;\n\tfor (i = 0; i < ainfo->num_attrs; ++i) {\n\t\tklass = ainfo->attrs [i].ctor->klass;\n\t\tif (mono_class_has_parent (klass, attr_klass) || (MONO_CLASS_IS_INTERFACE (attr_klass) && mono_class_is_assignable_from (attr_klass, klass)))\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nMonoObject*\nmono_custom_attrs_get_attr (MonoCustomAttrInfo *ainfo, MonoClass *attr_klass)\n{\n\tint i, attr_index;\n\tMonoClass *klass;\n\tMonoArray *attrs;\n\n\tattr_index = -1;\n\tfor (i = 0; i < ainfo->num_attrs; ++i) {\n\t\tklass = ainfo->attrs [i].ctor->klass;\n\t\tif (mono_class_has_parent (klass, attr_klass)) {\n\t\t\tattr_index = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (attr_index == -1)\n\t\treturn NULL;\n\n\tattrs = mono_custom_attrs_construct (ainfo);\n\tif (attrs)\n\t\treturn mono_array_get (attrs, MonoObject*, attr_index);\n\telse\n\t\treturn NULL;\n}\n\n/*\n * mono_reflection_get_custom_attrs_info:\n * @obj: a reflection object handle\n *\n * Return the custom attribute info for attributes defined for the\n * reflection handle @obj. The objects.\n *\n * FIXME this function leaks like a sieve for SRE objects.\n */\nMonoCustomAttrInfo*\nmono_reflection_get_custom_attrs_info (MonoObject *obj)\n{\n\tMonoClass *klass;\n\tMonoCustomAttrInfo *cinfo = NULL;\n\t\n\tklass = obj->vtable->klass;\n\tif (klass == mono_defaults.monotype_class) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType *)obj);\n\t\tklass = mono_class_from_mono_type (type);\n\t\tcinfo = mono_custom_attrs_from_class (klass);\n\t} else if (strcmp (\"Assembly\", klass->name) == 0) {\n\t\tMonoReflectionAssembly *rassembly = (MonoReflectionAssembly*)obj;\n\t\tcinfo = mono_custom_attrs_from_assembly (rassembly->assembly);\n\t} else if (strcmp (\"Module\", klass->name) == 0) {\n\t\tMonoReflectionModule *module = (MonoReflectionModule*)obj;\n\t\tcinfo = mono_custom_attrs_from_module (module->image);\n\t} else if (strcmp (\"MonoProperty\", klass->name) == 0) {\n\t\tMonoReflectionProperty *rprop = (MonoReflectionProperty*)obj;\n\t\tcinfo = mono_custom_attrs_from_property (rprop->property->parent, rprop->property);\n\t} else if (strcmp (\"MonoEvent\", klass->name) == 0) {\n\t\tMonoReflectionMonoEvent *revent = (MonoReflectionMonoEvent*)obj;\n\t\tcinfo = mono_custom_attrs_from_event (revent->event->parent, revent->event);\n\t} else if (strcmp (\"MonoField\", klass->name) == 0) {\n\t\tMonoReflectionField *rfield = (MonoReflectionField*)obj;\n\t\tcinfo = mono_custom_attrs_from_field (rfield->field->parent, rfield->field);\n\t} else if ((strcmp (\"MonoMethod\", klass->name) == 0) || (strcmp (\"MonoCMethod\", klass->name) == 0)) {\n\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)obj;\n\t\tcinfo = mono_custom_attrs_from_method (rmethod->method);\n\t} else if ((strcmp (\"MonoGenericMethod\", klass->name) == 0) || (strcmp (\"MonoGenericCMethod\", klass->name) == 0)) {\n\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)obj;\n\t\tcinfo = mono_custom_attrs_from_method (rmethod->method);\n\t} else if (strcmp (\"ParameterInfo\", klass->name) == 0) {\n\t\tMonoReflectionParameter *param = (MonoReflectionParameter*)obj;\n\t\tMonoClass *member_class = mono_object_class (param->MemberImpl);\n\t\tif (mono_class_is_reflection_method_or_constructor (member_class)) {\n\t\t\tMonoReflectionMethod *rmethod = (MonoReflectionMethod*)param->MemberImpl;\n\t\t\tcinfo = mono_custom_attrs_from_param (rmethod->method, param->PositionImpl + 1);\n\t\t} else if (is_sr_mono_property (member_class)) {\n\t\t\tMonoReflectionProperty *prop = (MonoReflectionProperty *)param->MemberImpl;\n\t\t\tMonoMethod *method;\n\t\t\tif (!(method = prop->property->get))\n\t\t\t\tmethod = prop->property->set;\n\t\t\tg_assert (method);\n\n\t\t\tcinfo = mono_custom_attrs_from_param (method, param->PositionImpl + 1);\n\t\t} else if (is_sre_method_on_tb_inst (member_class)) {/*XXX This is a workaround for Compiler Context*/\n\t\t\tMonoMethod *method = mono_reflection_method_on_tb_inst_get_handle ((MonoReflectionMethodOnTypeBuilderInst*)param->MemberImpl);\n\t\t\tcinfo = mono_custom_attrs_from_param (method, param->PositionImpl + 1);\n\t\t} else if (is_sre_ctor_on_tb_inst (member_class)) { /*XX This is a workaround for Compiler Context*/\n\t\tMonoReflectionCtorOnTypeBuilderInst *c = (MonoReflectionCtorOnTypeBuilderInst*)param->MemberImpl;\n\t\t\tMonoMethod *method = NULL;\n\t\t\tif (is_sre_ctor_builder (mono_object_class (c->cb)))\n\t\t\t\tmethod = ((MonoReflectionCtorBuilder *)c->cb)->mhandle;\n\t\t\telse if (is_sr_mono_cmethod (mono_object_class (c->cb)))\n\t\t\t\tmethod = ((MonoReflectionMethod *)c->cb)->method;\n\t\t\telse\n\t\t\t\tg_error (\"mono_reflection_get_custom_attrs_info:: can't handle a CTBI with base_method of type %s\", mono_type_get_full_name (member_class));\n\n\t\t\tcinfo = mono_custom_attrs_from_param (method, param->PositionImpl + 1);\n\t\t} else {\n\t\t\tchar *type_name = mono_type_get_full_name (member_class);\n\t\t\tchar *msg = g_strdup_printf (\"Custom attributes on a ParamInfo with member %s are not supported\", type_name);\n\t\t\tMonoException *ex = mono_get_exception_not_supported  (msg);\n\t\t\tg_free (type_name);\n\t\t\tg_free (msg);\n\t\t\tmono_raise_exception (ex);\n\t\t}\n\t} else if (strcmp (\"AssemblyBuilder\", klass->name) == 0) {\n\t\tMonoReflectionAssemblyBuilder *assemblyb = (MonoReflectionAssemblyBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, assemblyb->assembly.assembly->image, assemblyb->cattrs);\n\t} else if (strcmp (\"TypeBuilder\", klass->name) == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, &tb->module->dynamic_image->image, tb->cattrs);\n\t} else if (strcmp (\"ModuleBuilder\", klass->name) == 0) {\n\t\tMonoReflectionModuleBuilder *mb = (MonoReflectionModuleBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, &mb->dynamic_image->image, mb->cattrs);\n\t} else if (strcmp (\"ConstructorBuilder\", klass->name) == 0) {\n\t\tMonoReflectionCtorBuilder *cb = (MonoReflectionCtorBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, cb->mhandle->klass->image, cb->cattrs);\n\t} else if (strcmp (\"MethodBuilder\", klass->name) == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, mb->mhandle->klass->image, mb->cattrs);\n\t} else if (strcmp (\"FieldBuilder\", klass->name) == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder*)obj;\n\t\tcinfo = mono_custom_attrs_from_builders (NULL, &((MonoReflectionTypeBuilder*)fb->typeb)->module->dynamic_image->image, fb->cattrs);\n\t} else if (strcmp (\"MonoGenericClass\", klass->name) == 0) {\n\t\tMonoReflectionGenericClass *gclass = (MonoReflectionGenericClass*)obj;\n\t\tcinfo = mono_reflection_get_custom_attrs_info ((MonoObject*)gclass->generic_type);\n\t} else { /* handle other types here... */\n\t\tg_error (\"get custom attrs not yet supported for %s\", klass->name);\n\t}\n\n\treturn cinfo;\n}\n\n/*\n * mono_reflection_get_custom_attrs_by_type:\n * @obj: a reflection object handle\n *\n * Return an array with all the custom attributes defined of the\n * reflection handle @obj. If @attr_klass is non-NULL, only custom attributes \n * of that type are returned. The objects are fully build. Return NULL if a loading error\n * occurs.\n */\nMonoArray*\nmono_reflection_get_custom_attrs_by_type (MonoObject *obj, MonoClass *attr_klass)\n{\n\tMonoArray *result;\n\tMonoCustomAttrInfo *cinfo;\n\n\tcinfo = mono_reflection_get_custom_attrs_info (obj);\n\tif (cinfo) {\n\t\tif (attr_klass)\n\t\t\tresult = mono_custom_attrs_construct_by_type (cinfo, attr_klass);\n\t\telse\n\t\t\tresult = mono_custom_attrs_construct (cinfo);\n\t\tif (!cinfo->cached)\n\t\t\tmono_custom_attrs_free (cinfo);\n\t} else {\n\t\tif (mono_loader_get_last_error ())\n\t\t\treturn NULL;\n\t\tresult = mono_array_new_cached (mono_domain_get (), mono_defaults.attribute_class, 0);\n\t}\n\n\treturn result;\n}\n\n/*\n * mono_reflection_get_custom_attrs:\n * @obj: a reflection object handle\n *\n * Return an array with all the custom attributes defined of the\n * reflection handle @obj. The objects are fully build. Return NULL if a loading error\n * occurs.\n */\nMonoArray*\nmono_reflection_get_custom_attrs (MonoObject *obj)\n{\n\treturn mono_reflection_get_custom_attrs_by_type (obj, NULL);\n}\n\n/*\n * mono_reflection_get_custom_attrs_data:\n * @obj: a reflection obj handle\n *\n * Returns an array of System.Reflection.CustomAttributeData,\n * which include information about attributes reflected on\n * types loaded using the Reflection Only methods\n */\nMonoArray*\nmono_reflection_get_custom_attrs_data (MonoObject *obj)\n{\n\tMonoArray *result;\n\tMonoCustomAttrInfo *cinfo;\n\n\tcinfo = mono_reflection_get_custom_attrs_info (obj);\n\tif (cinfo) {\n\t\tresult = mono_custom_attrs_data_construct (cinfo);\n\t\tif (!cinfo->cached)\n\t\t\tmono_custom_attrs_free (cinfo);\n\t} else\n\t\tresult = mono_array_new (mono_domain_get (), mono_defaults.customattribute_data_class, 0);\n\n\treturn result;\n}\n\nstatic MonoReflectionType*\nmono_reflection_type_get_underlying_system_type (MonoReflectionType* t)\n{\n        MonoMethod *method_get_underlying_system_type;\n\n        method_get_underlying_system_type = mono_object_get_virtual_method ((MonoObject *) t,\n                                                                            mono_class_get_method_from_name (mono_object_class (t),\n                                                                                                             \"get_UnderlyingSystemType\",\n                                                                                                             0));\n        return (MonoReflectionType *) mono_runtime_invoke (method_get_underlying_system_type, t, NULL, NULL);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n\nstatic gboolean\nis_corlib_type (MonoClass *class)\n{\n\treturn class->image == mono_defaults.corlib;\n}\n\nstatic gboolean\nis_usertype (MonoReflectionType *ref)\n{\n\tMonoClass *class = mono_object_class (ref);\n\treturn class->image != mono_defaults.corlib || strcmp (\"TypeDelegator\", class->name) == 0;\n}\n\n#define check_corlib_type_cached(_class, _namespace, _name) do { \\\n\tstatic MonoClass *cached_class; \\\n\tif (cached_class) \\\n\t\treturn cached_class == _class; \\\n\tif (is_corlib_type (_class) && !strcmp (_name, _class->name) && !strcmp (_namespace, _class->name_space)) { \\\n\t\tcached_class = _class; \\\n\t\treturn TRUE; \\\n\t} \\\n\treturn FALSE; \\\n} while (0) \\\n\nstatic gboolean\nis_sre_array (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ArrayType\");\n}\n\nstatic gboolean\nis_sre_byref (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ByRefType\");\n}\n\nstatic gboolean\nis_sre_pointer (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"PointerType\");\n}\n\nstatic gboolean\nis_sre_generic_instance (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoGenericClass\");\n}\n\nstatic gboolean\nis_sre_method_builder (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"MethodBuilder\");\n}\n\nstatic gboolean\nis_sre_ctor_builder (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ConstructorBuilder\");\n}\n\nstatic gboolean\nis_sr_mono_method (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoMethod\");\n}\n\nstatic gboolean\nis_sr_mono_cmethod (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoCMethod\");\n}\n\nstatic gboolean\nis_sr_mono_generic_method (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoGenericMethod\");\n}\n\nstatic gboolean\nis_sr_mono_generic_cmethod (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoGenericCMethod\");\n}\n\nstatic gboolean\nis_sr_mono_property (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection\", \"MonoProperty\");\n}\n\nstatic gboolean\nis_sre_method_on_tb_inst (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"MethodOnTypeBuilderInst\");\n}\n\nstatic gboolean\nis_sre_ctor_on_tb_inst (MonoClass *class)\n{\n\tcheck_corlib_type_cached (class, \"System.Reflection.Emit\", \"ConstructorOnTypeBuilderInst\");\n}\n\ngboolean\nmono_class_is_reflection_method_or_constructor (MonoClass *class)\n{\n\treturn is_sr_mono_method (class) || is_sr_mono_cmethod (class) || is_sr_mono_generic_method (class) || is_sr_mono_generic_cmethod (class);\n}\nMonoType*\nmono_reflection_type_get_handle (MonoReflectionType* ref)\n{\n\tMonoClass *class;\n\tif (!ref)\n\t\treturn NULL;\n\tif (ref->type)\n\t\treturn ref->type;\n\n\tif (is_usertype (ref)) {\n\t\tref = mono_reflection_type_get_underlying_system_type (ref);\n\t\tg_assert (!is_usertype (ref)); /*FIXME fail better*/\n\t\tif (ref->type)\n\t\t\treturn ref->type;\n\t}\n\n\tclass = mono_object_class (ref);\n\n\tif (is_sre_array (class)) {\n\t\tMonoType *res;\n\t\tMonoReflectionArrayType *sre_array = (MonoReflectionArrayType*)ref;\n\t\tMonoType *base = mono_reflection_type_get_handle (sre_array->element_type);\n\t\tg_assert (base);\n\t\tif (sre_array->rank == 0) //single dimentional array\n\t\t\tres = &mono_array_class_get (mono_class_from_mono_type (base), 1)->byval_arg;\n\t\telse\n\t\t\tres = &mono_bounded_array_class_get (mono_class_from_mono_type (base), sre_array->rank, TRUE)->byval_arg;\n\t\tsre_array->type.type = res;\n\t\treturn res;\n\t} else if (is_sre_byref (class)) {\n\t\tMonoType *res;\n\t\tMonoReflectionDerivedType *sre_byref = (MonoReflectionDerivedType*)ref;\n\t\tMonoType *base = mono_reflection_type_get_handle (sre_byref->element_type);\n\t\tg_assert (base);\n\t\tres = &mono_class_from_mono_type (base)->this_arg;\n\t\tsre_byref->type.type = res;\n\t\treturn res;\n\t} else if (is_sre_pointer (class)) {\n\t\tMonoType *res;\n\t\tMonoReflectionDerivedType *sre_pointer = (MonoReflectionDerivedType*)ref;\n\t\tMonoType *base = mono_reflection_type_get_handle (sre_pointer->element_type);\n\t\tg_assert (base);\n\t\tres = &mono_ptr_class_get (base)->byval_arg;\n\t\tsre_pointer->type.type = res;\n\t\treturn res;\n\t} else if (is_sre_generic_instance (class)) {\n\t\tMonoType *res, **types;\n\t\tMonoReflectionGenericClass *gclass = (MonoReflectionGenericClass*)ref;\n\t\tint i, count;\n\n\t\tcount = mono_array_length (gclass->type_arguments);\n\t\ttypes = g_new0 (MonoType*, count);\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tMonoReflectionType *t = mono_array_get (gclass->type_arguments, gpointer, i);\n\t\t\ttypes [i] = mono_reflection_type_get_handle (t);\n\t\t}\n\n\t\tres = mono_reflection_bind_generic_parameters ((MonoReflectionType*)gclass->generic_type, count, types);\n\t\tg_free (types);\n\t\tg_assert (res);\n\t\tgclass->type.type = res;\n\t\treturn res;\n\t}\n\n\tg_error (\"Cannot handle corlib user type %s\", mono_type_full_name (&mono_object_class(ref)->byval_arg));\n\treturn NULL;\n}\n\nstatic MonoReflectionType*\nmono_reflection_type_resolve_user_types (MonoReflectionType *type)\n{\n\tif (!type || type->type)\n\t\treturn type;\n\n\tif (is_usertype (type)) {\n\t\ttype = mono_reflection_type_get_underlying_system_type (type);\n\t\tif (is_usertype (type))\n\t\t\tmono_raise_exception (mono_get_exception_not_supported (\"User defined subclasses of System.Type are not yet supported22\"));\n\t}\n\n\treturn type;\n}\n\nvoid\nmono_reflection_create_unmanaged_type (MonoReflectionType *type)\n{\n\tmono_reflection_type_get_handle (type);\n}\n\n/**\n * LOCKING: Assumes the loader lock is held.\n */\nstatic MonoMethodSignature*\nparameters_to_signature (MonoImage *image, MonoArray *parameters) {\n\tMonoMethodSignature *sig;\n\tint count, i;\n\n\tcount = parameters? mono_array_length (parameters): 0;\n\n\tsig = image_g_malloc0 (image, MONO_SIZEOF_METHOD_SIGNATURE + sizeof (MonoType*) * count);\n\tsig->param_count = count;\n\tsig->sentinelpos = -1; /* FIXME */\n\tfor (i = 0; i < count; ++i)\n\t\tsig->params [i] = mono_type_array_get_and_resolve (parameters, i);\n\treturn sig;\n}\n\n/**\n * LOCKING: Assumes the loader lock is held.\n */\nstatic MonoMethodSignature*\nctor_builder_to_signature (MonoImage *image, MonoReflectionCtorBuilder *ctor) {\n\tMonoMethodSignature *sig;\n\n\tsig = parameters_to_signature (image, ctor->parameters);\n\tsig->hasthis = ctor->attrs & METHOD_ATTRIBUTE_STATIC? 0: 1;\n\tsig->ret = &mono_defaults.void_class->byval_arg;\n\treturn sig;\n}\n\n/**\n * LOCKING: Assumes the loader lock is held.\n */\nstatic MonoMethodSignature*\nmethod_builder_to_signature (MonoImage *image, MonoReflectionMethodBuilder *method) {\n\tMonoMethodSignature *sig;\n\n\tsig = parameters_to_signature (image, method->parameters);\n\tsig->hasthis = method->attrs & METHOD_ATTRIBUTE_STATIC? 0: 1;\n\tsig->ret = method->rtype? mono_reflection_type_get_handle ((MonoReflectionType*)method->rtype): &mono_defaults.void_class->byval_arg;\n\tsig->generic_param_count = method->generic_params ? mono_array_length (method->generic_params) : 0;\n\treturn sig;\n}\n\nstatic MonoMethodSignature*\ndynamic_method_to_signature (MonoReflectionDynamicMethod *method) {\n\tMonoMethodSignature *sig;\n\n\tsig = parameters_to_signature (NULL, method->parameters);\n\tsig->hasthis = method->attrs & METHOD_ATTRIBUTE_STATIC? 0: 1;\n\tsig->ret = method->rtype? mono_reflection_type_get_handle (method->rtype): &mono_defaults.void_class->byval_arg;\n\tsig->generic_param_count = 0;\n\treturn sig;\n}\n\nstatic void\nget_prop_name_and_type (MonoObject *prop, char **name, MonoType **type)\n{\n\tMonoClass *klass = mono_object_class (prop);\n\tif (strcmp (klass->name, \"PropertyBuilder\") == 0) {\n\t\tMonoReflectionPropertyBuilder *pb = (MonoReflectionPropertyBuilder *)prop;\n\t\t*name = mono_string_to_utf8 (pb->name);\n\t\t*type = mono_reflection_type_get_handle ((MonoReflectionType*)pb->type);\n\t} else {\n\t\tMonoReflectionProperty *p = (MonoReflectionProperty *)prop;\n\t\t*name = g_strdup (p->property->name);\n\t\tif (p->property->get)\n\t\t\t*type = mono_method_signature (p->property->get)->ret;\n\t\telse\n\t\t\t*type = mono_method_signature (p->property->set)->params [mono_method_signature (p->property->set)->param_count - 1];\n\t}\n}\n\nstatic void\nget_field_name_and_type (MonoObject *field, char **name, MonoType **type)\n{\n\tMonoClass *klass = mono_object_class (field);\n\tif (strcmp (klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder *)field;\n\t\t*name = mono_string_to_utf8 (fb->name);\n\t\t*type = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t} else {\n\t\tMonoReflectionField *f = (MonoReflectionField *)field;\n\t\t*name = g_strdup (mono_field_get_name (f->field));\n\t\t*type = f->field->type;\n\t}\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\n/*\n * Encode a value in a custom attribute stream of bytes.\n * The value to encode is either supplied as an object in argument val\n * (valuetypes are boxed), or as a pointer to the data in the\n * argument argval.\n * @type represents the type of the value\n * @buffer is the start of the buffer\n * @p the current position in the buffer\n * @buflen contains the size of the buffer and is used to return the new buffer size\n * if this needs to be realloced.\n * @retbuffer and @retp return the start and the position of the buffer\n */\nstatic void\nencode_cattr_value (MonoAssembly *assembly, char *buffer, char *p, char **retbuffer, char **retp, guint32 *buflen, MonoType *type, MonoObject *arg, char *argval)\n{\n\tMonoTypeEnum simple_type;\n\t\n\tif ((p-buffer) + 10 >= *buflen) {\n\t\tchar *newbuf;\n\t\t*buflen *= 2;\n\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\tp = newbuf + (p-buffer);\n\t\tbuffer = newbuf;\n\t}\n\tif (!argval)\n\t\targval = ((char*)arg + sizeof (MonoObject));\n\tsimple_type = type->type;\nhandle_enum:\n\tswitch (simple_type) {\n\tcase MONO_TYPE_BOOLEAN:\n\tcase MONO_TYPE_U1:\n\tcase MONO_TYPE_I1:\n\t\t*p++ = *argval;\n\t\tbreak;\n\tcase MONO_TYPE_CHAR:\n\tcase MONO_TYPE_U2:\n\tcase MONO_TYPE_I2:\n\t\tswap_with_size (p, argval, 2, 1);\n\t\tp += 2;\n\t\tbreak;\n\tcase MONO_TYPE_U4:\n\tcase MONO_TYPE_I4:\n\tcase MONO_TYPE_R4:\n\t\tswap_with_size (p, argval, 4, 1);\n\t\tp += 4;\n\t\tbreak;\n\tcase MONO_TYPE_R8:\n#if defined(ARM_FPU_FPA) && G_BYTE_ORDER == G_LITTLE_ENDIAN\n\t\tp [0] = argval [4];\n\t\tp [1] = argval [5];\n\t\tp [2] = argval [6];\n\t\tp [3] = argval [7];\n\t\tp [4] = argval [0];\n\t\tp [5] = argval [1];\n\t\tp [6] = argval [2];\n\t\tp [7] = argval [3];\n#else\n\t\tswap_with_size (p, argval, 8, 1);\n#endif\n\t\tp += 8;\n\t\tbreak;\n\tcase MONO_TYPE_U8:\n\tcase MONO_TYPE_I8:\n\t\tswap_with_size (p, argval, 8, 1);\n\t\tp += 8;\n\t\tbreak;\n\tcase MONO_TYPE_VALUETYPE:\n\t\tif (type->data.klass->enumtype) {\n\t\t\tsimple_type = mono_class_enum_basetype (type->data.klass)->type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tg_warning (\"generic valutype %s not handled in custom attr value decoding\", type->data.klass->name);\n\t\t}\n\t\tbreak;\n\tcase MONO_TYPE_STRING: {\n\t\tchar *str;\n\t\tguint32 slen;\n\t\tif (!arg) {\n\t\t\t*p++ = 0xFF;\n\t\t\tbreak;\n\t\t}\n\t\tstr = mono_string_to_utf8 ((MonoString*)arg);\n\t\tslen = strlen (str);\n\t\tif ((p-buffer) + 10 + slen >= *buflen) {\n\t\t\tchar *newbuf;\n\t\t\t*buflen *= 2;\n\t\t\t*buflen += slen;\n\t\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\t\tp = newbuf + (p-buffer);\n\t\t\tbuffer = newbuf;\n\t\t}\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_CLASS: {\n\t\tchar *str;\n\t\tguint32 slen;\n\t\tif (!arg) {\n\t\t\t*p++ = 0xFF;\n\t\t\tbreak;\n\t\t}\nhandle_type:\n\t\tstr = type_get_qualified_name (mono_reflection_type_get_handle ((MonoReflectionType*)arg), NULL);\n\t\tslen = strlen (str);\n\t\tif ((p-buffer) + 10 + slen >= *buflen) {\n\t\t\tchar *newbuf;\n\t\t\t*buflen *= 2;\n\t\t\t*buflen += slen;\n\t\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\t\tp = newbuf + (p-buffer);\n\t\t\tbuffer = newbuf;\n\t\t}\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_SZARRAY: {\n\t\tint len, i;\n\t\tMonoClass *eclass, *arg_eclass;\n\n\t\tif (!arg) {\n\t\t\t*p++ = 0xff; *p++ = 0xff; *p++ = 0xff; *p++ = 0xff;\n\t\t\tbreak;\n\t\t}\n\t\tlen = mono_array_length ((MonoArray*)arg);\n\t\t*p++ = len & 0xff;\n\t\t*p++ = (len >> 8) & 0xff;\n\t\t*p++ = (len >> 16) & 0xff;\n\t\t*p++ = (len >> 24) & 0xff;\n\t\t*retp = p;\n\t\t*retbuffer = buffer;\n\t\teclass = type->data.klass;\n\t\targ_eclass = mono_object_class (arg)->element_class;\n\n\t\tif (!eclass) {\n\t\t\t/* Happens when we are called from the MONO_TYPE_OBJECT case below */\n\t\t\teclass = mono_defaults.object_class;\n\t\t}\n\t\tif (eclass == mono_defaults.object_class && arg_eclass->valuetype) {\n\t\t\tchar *elptr = mono_array_addr ((MonoArray*)arg, char, 0);\n\t\t\tint elsize = mono_class_array_element_size (arg_eclass);\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &arg_eclass->byval_arg, NULL, elptr);\n\t\t\t\telptr += elsize;\n\t\t\t}\n\t\t} else if (eclass->valuetype && arg_eclass->valuetype) {\n\t\t\tchar *elptr = mono_array_addr ((MonoArray*)arg, char, 0);\n\t\t\tint elsize = mono_class_array_element_size (eclass);\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &eclass->byval_arg, NULL, elptr);\n\t\t\t\telptr += elsize;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; ++i) {\n\t\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &eclass->byval_arg, mono_array_get ((MonoArray*)arg, MonoObject*, i), NULL);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase MONO_TYPE_OBJECT: {\n\t\tMonoClass *klass;\n\t\tchar *str;\n\t\tguint32 slen;\n\n\t\t/*\n\t\t * The parameter type is 'object' but the type of the actual\n\t\t * argument is not. So we have to add type information to the blob\n\t\t * too. This is completely undocumented in the spec.\n\t\t */\n\n\t\tif (arg == NULL) {\n\t\t\t*p++ = MONO_TYPE_STRING;\t// It's same hack as MS uses\n\t\t\t*p++ = 0xFF;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tklass = mono_object_class (arg);\n\n\t\tif (mono_object_isinst (arg, mono_defaults.systemtype_class)) {\n\t\t\t*p++ = 0x50;\n\t\t\tgoto handle_type;\n\t\t} else if (klass->enumtype) {\n\t\t\t*p++ = 0x55;\n\t\t} else if (klass == mono_defaults.string_class) {\n\t\t\tsimple_type = MONO_TYPE_STRING;\n\t\t\t*p++ = 0x0E;\n\t\t\tgoto handle_enum;\n\t\t} else if (klass->rank == 1) {\n\t\t\t*p++ = 0x1D;\n\t\t\tif (klass->element_class->byval_arg.type == MONO_TYPE_OBJECT)\n\t\t\t\t/* See Partition II, Appendix B3 */\n\t\t\t\t*p++ = 0x51;\n\t\t\telse\n\t\t\t\t*p++ = klass->element_class->byval_arg.type;\n\t\t\tencode_cattr_value (assembly, buffer, p, &buffer, &p, buflen, &klass->byval_arg, arg, NULL);\n\t\t\tbreak;\n\t\t} else if (klass->byval_arg.type >= MONO_TYPE_BOOLEAN && klass->byval_arg.type <= MONO_TYPE_R8) {\n\t\t\t*p++ = simple_type = klass->byval_arg.type;\n\t\t\tgoto handle_enum;\n\t\t} else {\n\t\t\tg_error (\"unhandled type in custom attr\");\n\t\t}\n\t\tstr = type_get_qualified_name (mono_class_get_type(klass), NULL);\n\t\tslen = strlen (str);\n\t\tif ((p-buffer) + 10 + slen >= *buflen) {\n\t\t\tchar *newbuf;\n\t\t\t*buflen *= 2;\n\t\t\t*buflen += slen;\n\t\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\t\tp = newbuf + (p-buffer);\n\t\t\tbuffer = newbuf;\n\t\t}\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t\tsimple_type = mono_class_enum_basetype (klass)->type;\n\t\tgoto handle_enum;\n\t}\n\tdefault:\n\t\tg_error (\"type 0x%02x not yet supported in custom attr encoder\", simple_type);\n\t}\n\t*retp = p;\n\t*retbuffer = buffer;\n}\n\nstatic void\nencode_field_or_prop_type (MonoType *type, char *p, char **retp)\n{\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype) {\n\t\tchar *str = type_get_qualified_name (type, NULL);\n\t\tint slen = strlen (str);\n\n\t\t*p++ = 0x55;\n\t\t/*\n\t\t * This seems to be optional...\n\t\t * *p++ = 0x80;\n\t\t */\n\t\tmono_metadata_encode_value (slen, p, &p);\n\t\tmemcpy (p, str, slen);\n\t\tp += slen;\n\t\tg_free (str);\n\t} else if (type->type == MONO_TYPE_OBJECT) {\n\t\t*p++ = 0x51;\n\t} else if (type->type == MONO_TYPE_CLASS) {\n\t\t/* it should be a type: encode_cattr_value () has the check */\n\t\t*p++ = 0x50;\n\t} else {\n\t\tmono_metadata_encode_value (type->type, p, &p);\n\t\tif (type->type == MONO_TYPE_SZARRAY)\n\t\t\t/* See the examples in Partition VI, Annex B */\n\t\t\tencode_field_or_prop_type (&type->data.klass->byval_arg, p, &p);\n\t}\n\n\t*retp = p;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic void\nencode_named_val (MonoReflectionAssembly *assembly, char *buffer, char *p, char **retbuffer, char **retp, guint32 *buflen, MonoType *type, char *name, MonoObject *value)\n{\n\tint len;\n\t/* Preallocate a large enough buffer */\n\tif (type->type == MONO_TYPE_VALUETYPE && type->data.klass->enumtype) {\n\t\tchar *str = type_get_qualified_name (type, NULL);\n\t\tlen = strlen (str);\n\t\tg_free (str);\n\t} else if (type->type == MONO_TYPE_SZARRAY && type->data.klass->enumtype) {\n\t\tchar *str = type_get_qualified_name (&type->data.klass->byval_arg, NULL);\n\t\tlen = strlen (str);\n\t\tg_free (str);\n\t} else {\n\t\tlen = 0;\n\t}\n\tlen += strlen (name);\n\n\tif ((p-buffer) + 20 + len >= *buflen) {\n\t\tchar *newbuf;\n\t\t*buflen *= 2;\n\t\t*buflen += len;\n\t\tnewbuf = g_realloc (buffer, *buflen);\n\t\tp = newbuf + (p-buffer);\n\t\tbuffer = newbuf;\n\t}\n\n\tencode_field_or_prop_type (type, p, &p);\n\n\tlen = strlen (name);\n\tmono_metadata_encode_value (len, p, &p);\n\tmemcpy (p, name, len);\n\tp += len;\n\tencode_cattr_value (assembly->assembly, buffer, p, &buffer, &p, buflen, type, value, NULL);\n\t*retp = p;\n\t*retbuffer = buffer;\n}\n\n/*\n * mono_reflection_get_custom_attrs_blob:\n * @ctor: custom attribute constructor\n * @ctorArgs: arguments o the constructor\n * @properties:\n * @propValues:\n * @fields:\n * @fieldValues:\n * \n * Creates the blob of data that needs to be saved in the metadata and that represents\n * the custom attributed described by @ctor, @ctorArgs etc.\n * Returns: a Byte array representing the blob of data.\n */\nMonoArray*\nmono_reflection_get_custom_attrs_blob (MonoReflectionAssembly *assembly, MonoObject *ctor, MonoArray *ctorArgs, MonoArray *properties, MonoArray *propValues, MonoArray *fields, MonoArray* fieldValues) \n{\n\tMonoArray *result;\n\tMonoMethodSignature *sig;\n\tMonoObject *arg;\n\tchar *buffer, *p;\n\tguint32 buflen, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (strcmp (ctor->vtable->klass->name, \"MonoCMethod\")) {\n\t\t/* sig is freed later so allocate it in the heap */\n\t\tsig = ctor_builder_to_signature (NULL, (MonoReflectionCtorBuilder*)ctor);\n\t} else {\n\t\tsig = mono_method_signature (((MonoReflectionMethod*)ctor)->method);\n\t}\n\n\tg_assert (mono_array_length (ctorArgs) == sig->param_count);\n\tbuflen = 256;\n\tp = buffer = g_malloc (buflen);\n\t/* write the prolog */\n\t*p++ = 1;\n\t*p++ = 0;\n\tfor (i = 0; i < sig->param_count; ++i) {\n\t\targ = mono_array_get (ctorArgs, MonoObject*, i);\n\t\tencode_cattr_value (assembly->assembly, buffer, p, &buffer, &p, &buflen, sig->params [i], arg, NULL);\n\t}\n\ti = 0;\n\tif (properties)\n\t\ti += mono_array_length (properties);\n\tif (fields)\n\t\ti += mono_array_length (fields);\n\t*p++ = i & 0xff;\n\t*p++ = (i >> 8) & 0xff;\n\tif (properties) {\n\t\tMonoObject *prop;\n\t\tfor (i = 0; i < mono_array_length (properties); ++i) {\n\t\t\tMonoType *ptype;\n\t\t\tchar *pname;\n\n\t\t\tprop = mono_array_get (properties, gpointer, i);\n\t\t\tget_prop_name_and_type (prop, &pname, &ptype);\n\t\t\t*p++ = 0x54; /* PROPERTY signature */\n\t\t\tencode_named_val (assembly, buffer, p, &buffer, &p, &buflen, ptype, pname, (MonoObject*)mono_array_get (propValues, gpointer, i));\n\t\t\tg_free (pname);\n\t\t}\n\t}\n\n\tif (fields) {\n\t\tMonoObject *field;\n\t\tfor (i = 0; i < mono_array_length (fields); ++i) {\n\t\t\tMonoType *ftype;\n\t\t\tchar *fname;\n\n\t\t\tfield = mono_array_get (fields, gpointer, i);\n\t\t\tget_field_name_and_type (field, &fname, &ftype);\n\t\t\t*p++ = 0x53; /* FIELD signature */\n\t\t\tencode_named_val (assembly, buffer, p, &buffer, &p, &buflen, ftype, fname, (MonoObject*)mono_array_get (fieldValues, gpointer, i));\n\t\t\tg_free (fname);\n\t\t}\n\t}\n\n\tg_assert (p - buffer <= buflen);\n\tbuflen = p - buffer;\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, buflen);\n\tp = mono_array_addr (result, char, 0);\n\tmemcpy (p, buffer, buflen);\n\tg_free (buffer);\n\tif (strcmp (ctor->vtable->klass->name, \"MonoCMethod\"))\n\t\tg_free (sig);\n\treturn result;\n}\n\n/*\n * mono_reflection_setup_internal_class:\n * @tb: a TypeBuilder object\n *\n * Creates a MonoClass that represents the TypeBuilder.\n * This is a trick that lets us simplify a lot of reflection code\n * (and will allow us to support Build and Run assemblies easier).\n */\nvoid\nmono_reflection_setup_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoError error;\n\tMonoClass *klass, *parent;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tRESOLVE_TYPE (tb->parent);\n\n\tmono_loader_lock ();\n\n\tif (tb->parent) {\n\t\t/* check so we can compile corlib correctly */\n\t\tif (strcmp (mono_object_class (tb->parent)->name, \"TypeBuilder\") == 0) {\n\t\t\t/* mono_class_setup_mono_type () guaranteess type->data.klass is valid */\n\t\t\tparent = mono_reflection_type_get_handle ((MonoReflectionType*)tb->parent)->data.klass;\n\t\t} else {\n\t\t\tparent = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb->parent));\n\t\t}\n\t} else {\n\t\tparent = NULL;\n\t}\n\t\n\t/* the type has already being created: it means we just have to change the parent */\n\tif (tb->type.type) {\n\t\tklass = mono_class_from_mono_type (tb->type.type);\n\t\tklass->parent = NULL;\n\t\t/* fool mono_class_setup_parent */\n\t\tklass->supertypes = NULL;\n\t\tmono_class_setup_parent (klass, parent);\n\t\tmono_class_setup_mono_type (klass);\n\t\tmono_loader_unlock ();\n\t\treturn;\n\t}\n\n\tklass = mono_image_alloc0 (&tb->module->dynamic_image->image, sizeof (MonoClass));\n\n\tklass->image = &tb->module->dynamic_image->image;\n\n\tklass->inited = 1; /* we lie to the runtime */\n\tklass->name = mono_string_to_utf8_image (klass->image, tb->name, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\tklass->name_space = mono_string_to_utf8_image (klass->image, tb->nspace, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\tklass->type_token = MONO_TOKEN_TYPE_DEF | tb->table_idx;\n\tklass->flags = tb->attrs;\n\t\n\tmono_profiler_class_event (klass, MONO_PROFILE_START_LOAD);\n\n\tklass->element_class = klass;\n\n\tMOVING_GC_REGISTER (&klass->reflection_info);\n\tklass->reflection_info = tb;\n\n\t/* Put into cache so mono_class_get () will find it */\n\tmono_image_add_to_name_cache (klass->image, klass->name_space, klass->name, tb->table_idx);\n\n\tmono_g_hash_table_insert (tb->module->dynamic_image->tokens,\n\t\tGUINT_TO_POINTER (MONO_TOKEN_TYPE_DEF | tb->table_idx), tb);\n\n\tif (parent != NULL) {\n\t\tmono_class_setup_parent (klass, parent);\n\t} else if (strcmp (klass->name, \"Object\") == 0 && strcmp (klass->name_space, \"System\") == 0) {\n\t\tconst char *old_n = klass->name;\n\t\t/* trick to get relative numbering right when compiling corlib */\n\t\tklass->name = \"BuildingObject\";\n\t\tmono_class_setup_parent (klass, mono_defaults.object_class);\n\t\tklass->name = old_n;\n\t}\n\n\tif ((!strcmp (klass->name, \"ValueType\") && !strcmp (klass->name_space, \"System\")) ||\n\t\t\t(!strcmp (klass->name, \"Object\") && !strcmp (klass->name_space, \"System\")) ||\n\t\t\t(!strcmp (klass->name, \"Enum\") && !strcmp (klass->name_space, \"System\"))) {\n\t\tklass->instance_size = sizeof (MonoObject);\n\t\tklass->size_inited = 1;\n\t\tmono_class_setup_vtable_general (klass, NULL, 0);\n\t}\n\n\tmono_class_setup_mono_type (klass);\n\n\tmono_class_setup_supertypes (klass);\n\n\t/*\n\t * FIXME: handle interfaces.\n\t */\n\n\ttb->type.type = &klass->byval_arg;\n\n\tif (tb->nesting_type) {\n\t\tg_assert (tb->nesting_type->type);\n\t\tklass->nested_in = mono_class_from_mono_type (mono_reflection_type_get_handle (tb->nesting_type));\n\t}\n\n\t/*g_print (\"setup %s as %s (%p)\\n\", klass->name, ((MonoObject*)tb)->vtable->klass->name, tb);*/\n\n\tmono_profiler_class_loaded (klass, MONO_PROFILE_OK);\n\t\n\tmono_loader_unlock ();\n\treturn;\n\nfailure:\n\tmono_loader_unlock ();\n\tmono_error_raise_exception (&error);\n}\n\n/*\n * mono_reflection_setup_generic_class:\n * @tb: a TypeBuilder object\n *\n * Setup the generic class before adding the first generic parameter.\n */\nvoid\nmono_reflection_setup_generic_class (MonoReflectionTypeBuilder *tb)\n{\n}\n\n/*\n * mono_reflection_create_generic_class:\n * @tb: a TypeBuilder object\n *\n * Creates the generic class after all generic parameters have been added.\n */\nvoid\nmono_reflection_create_generic_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoClass *klass;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (tb->type.type);\n\n\tcount = tb->generic_params ? mono_array_length (tb->generic_params) : 0;\n\n\tif (klass->generic_container || (count == 0))\n\t\treturn;\n\n\tg_assert (tb->generic_container && (tb->generic_container->owner.klass == klass));\n\n\tklass->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\n\tklass->generic_container->owner.klass = klass;\n\tklass->generic_container->type_argc = count;\n\tklass->generic_container->type_params = mono_image_alloc0 (klass->image, sizeof (MonoGenericParamFull) * count);\n\n\tklass->is_generic = 1;\n\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionGenericParam *gparam = mono_array_get (tb->generic_params, gpointer, i);\n\t\tMonoGenericParamFull *param = (MonoGenericParamFull *) mono_reflection_type_get_handle ((MonoReflectionType*)gparam)->data.generic_param;\n\t\tklass->generic_container->type_params [i] = *param;\n\t\t/*Make sure we are a diferent type instance */\n\t\tklass->generic_container->type_params [i].param.owner = klass->generic_container;\n\t\tklass->generic_container->type_params [i].info.pklass = NULL;\n\t\tklass->generic_container->type_params [i].info.flags = gparam->attrs;\n\n\t\tg_assert (klass->generic_container->type_params [i].param.owner);\n\t}\n\n\tklass->generic_container->context.class_inst = mono_get_shared_generic_inst (klass->generic_container);\n}\n\n/*\n * mono_reflection_create_internal_class:\n * @tb: a TypeBuilder object\n *\n * Actually create the MonoClass that is associated with the TypeBuilder.\n */\nvoid\nmono_reflection_create_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoClass *klass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tklass = mono_class_from_mono_type (tb->type.type);\n\n\tmono_loader_lock ();\n\tif (klass->enumtype && mono_class_enum_basetype (klass) == NULL) {\n\t\tMonoReflectionFieldBuilder *fb;\n\t\tMonoClass *ec;\n\t\tMonoType *enum_basetype;\n\n\t\tg_assert (tb->fields != NULL);\n\t\tg_assert (mono_array_length (tb->fields) >= 1);\n\n\t\tfb = mono_array_get (tb->fields, MonoReflectionFieldBuilder*, 0);\n\n\t\tif (!mono_type_is_valid_enum_basetype (mono_reflection_type_get_handle ((MonoReflectionType*)fb->type))) {\n\t\t\tmono_loader_unlock ();\n\t\t\treturn;\n\t\t}\n\n\t\tenum_basetype = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t\tklass->element_class = mono_class_from_mono_type (enum_basetype);\n\t\tif (!klass->element_class)\n\t\t\tklass->element_class = mono_class_from_mono_type (enum_basetype);\n\n\t\t/*\n\t\t * get the element_class from the current corlib.\n\t\t */\n\t\tec = default_class_from_mono_type (enum_basetype);\n\t\tklass->instance_size = ec->instance_size;\n\t\tklass->size_inited = 1;\n\t\t/* \n\t\t * this is almost safe to do with enums and it's needed to be able\n\t\t * to create objects of the enum type (for use in SetConstant).\n\t\t */\n\t\t/* FIXME: Does this mean enums can't have method overrides ? */\n\t\tmono_class_setup_vtable_general (klass, NULL, 0);\n\t}\n\tmono_loader_unlock ();\n}\n\nstatic MonoMarshalSpec*\nmono_marshal_spec_from_builder (MonoImage *image, MonoAssembly *assembly,\n\t\t\t\t\t\t\t\tMonoReflectionMarshal *minfo)\n{\n\tMonoMarshalSpec *res;\n\n\tres = image_g_new0 (image, MonoMarshalSpec, 1);\n\tres->native = minfo->type;\n\n\tswitch (minfo->type) {\n\tcase MONO_NATIVE_LPARRAY:\n\t\tres->data.array_data.elem_type = minfo->eltype;\n\t\tif (minfo->has_size) {\n\t\t\tres->data.array_data.param_num = minfo->param_num;\n\t\t\tres->data.array_data.num_elem = minfo->count;\n\t\t\tres->data.array_data.elem_mult = minfo->param_num == -1 ? 0 : 1;\n\t\t}\n\t\telse {\n\t\t\tres->data.array_data.param_num = -1;\n\t\t\tres->data.array_data.num_elem = -1;\n\t\t\tres->data.array_data.elem_mult = -1;\n\t\t}\n\t\tbreak;\n\n\tcase MONO_NATIVE_BYVALTSTR:\n\tcase MONO_NATIVE_BYVALARRAY:\n\t\tres->data.array_data.num_elem = minfo->count;\n\t\tbreak;\n\n\tcase MONO_NATIVE_CUSTOM:\n\t\tif (minfo->marshaltyperef)\n\t\t\tres->data.custom_data.custom_name =\n\t\t\t\ttype_get_fully_qualified_name (mono_reflection_type_get_handle ((MonoReflectionType*)minfo->marshaltyperef));\n\t\tif (minfo->mcookie)\n\t\t\tres->data.custom_data.cookie = mono_string_to_utf8 (minfo->mcookie);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn res;\n}\n#endif /* !DISABLE_REFLECTION_EMIT */\n\nMonoReflectionMarshal*\nmono_reflection_marshal_from_marshal_spec (MonoDomain *domain, MonoClass *klass,\n\t\t\t\t\t\t\t\t\t\t   MonoMarshalSpec *spec)\n{\n\tstatic MonoClass *System_Reflection_Emit_UnmanagedMarshalClass;\n\tMonoReflectionMarshal *minfo;\n\tMonoType *mtype;\n\n\tif (!System_Reflection_Emit_UnmanagedMarshalClass) {\n\t\tSystem_Reflection_Emit_UnmanagedMarshalClass = mono_class_from_name (\n\t\t   mono_defaults.corlib, \"System.Reflection.Emit\", \"UnmanagedMarshal\");\n\t\tg_assert (System_Reflection_Emit_UnmanagedMarshalClass);\n\t}\n\n\tminfo = (MonoReflectionMarshal*)mono_object_new (domain, System_Reflection_Emit_UnmanagedMarshalClass);\n\tminfo->type = spec->native;\n\n\tswitch (minfo->type) {\n\tcase MONO_NATIVE_LPARRAY:\n\t\tminfo->eltype = spec->data.array_data.elem_type;\n\t\tminfo->count = spec->data.array_data.num_elem;\n\t\tminfo->param_num = spec->data.array_data.param_num;\n\t\tbreak;\n\n\tcase MONO_NATIVE_BYVALTSTR:\n\tcase MONO_NATIVE_BYVALARRAY:\n\t\tminfo->count = spec->data.array_data.num_elem;\n\t\tbreak;\n\n\tcase MONO_NATIVE_CUSTOM:\n\t\tif (spec->data.custom_data.custom_name) {\n\t\t\tmtype = mono_reflection_type_from_name (spec->data.custom_data.custom_name, klass->image);\n\t\t\tif (mtype)\n\t\t\t\tMONO_OBJECT_SETREF (minfo, marshaltyperef, mono_type_get_object (domain, mtype));\n\n\t\t\tMONO_OBJECT_SETREF (minfo, marshaltype, mono_string_new (domain, spec->data.custom_data.custom_name));\n\t\t}\n\t\tif (spec->data.custom_data.cookie)\n\t\t\tMONO_OBJECT_SETREF (minfo, mcookie, mono_string_new (domain, spec->data.custom_data.cookie));\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn minfo;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\nstatic MonoMethod*\nreflection_methodbuilder_to_mono_method (MonoClass *klass,\n\t\t\t\t\t ReflectionMethodBuilder *rmb,\n\t\t\t\t\t MonoMethodSignature *sig)\n{\n\tMonoError error;\n\tMonoMethod *m;\n\tMonoMethodNormal *pm;\n\tMonoMarshalSpec **specs;\n\tMonoReflectionMethodAux *method_aux;\n\tMonoImage *image;\n\tgboolean dynamic;\n\tint i;\n\n\tmono_error_init (&error);\n\t/*\n\t * Methods created using a MethodBuilder should have their memory allocated\n\t * inside the image mempool, while dynamic methods should have their memory\n\t * malloc'd.\n\t */\n\tdynamic = rmb->refs != NULL;\n\timage = dynamic ? NULL : klass->image;\n\n\tif (!dynamic)\n\t\tg_assert (!klass->generic_class);\n\n\tmono_loader_lock ();\n\n\tif ((rmb->attrs & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||\n\t\t\t(rmb->iattrs & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL))\n\t\tm = (MonoMethod *)image_g_new0 (image, MonoMethodPInvoke, 1);\n\telse if (rmb->refs)\n\t\tm = (MonoMethod *)image_g_new0 (image, MonoMethodWrapper, 1);\n\telse\n\t\tm = (MonoMethod *)image_g_new0 (image, MonoMethodNormal, 1);\n\n\tpm = (MonoMethodNormal*)m;\n\n\tm->dynamic = dynamic;\n\tm->slot = -1;\n\tm->flags = rmb->attrs;\n\tm->iflags = rmb->iattrs;\n\tm->name = mono_string_to_utf8_image (image, rmb->name, &error);\n\tg_assert (mono_error_ok (&error));\n\tm->klass = klass;\n\tm->signature = sig;\n\tm->skip_visibility = rmb->skip_visibility;\n\tif (rmb->table_idx)\n\t\tm->token = MONO_TOKEN_METHOD_DEF | (*rmb->table_idx);\n\n\tif (m->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) {\n\t\tif (klass == mono_defaults.string_class && !strcmp (m->name, \".ctor\"))\n\t\t\tm->string_ctor = 1;\n\n\t\tm->signature->pinvoke = 1;\n\t} else if (m->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) {\n\t\tm->signature->pinvoke = 1;\n\n\t\tmethod_aux = image_g_new0 (image, MonoReflectionMethodAux, 1);\n\n\t\tmethod_aux->dllentry = rmb->dllentry ? mono_string_to_utf8_image (image, rmb->dllentry, &error) : image_strdup (image, m->name);\n\t\tg_assert (mono_error_ok (&error));\n\t\tmethod_aux->dll = mono_string_to_utf8_image (image, rmb->dll, &error);\n\t\tg_assert (mono_error_ok (&error));\n\t\t\n\t\t((MonoMethodPInvoke*)m)->piflags = (rmb->native_cc << 8) | (rmb->charset ? (rmb->charset - 1) * 2 : 0) | rmb->extra_flags;\n\n\t\tif (klass->image->dynamic)\n\t\t\tg_hash_table_insert (((MonoDynamicImage*)klass->image)->method_aux_hash, m, method_aux);\n\n\t\tmono_loader_unlock ();\n\n\t\treturn m;\n\t} else if (!(m->flags & METHOD_ATTRIBUTE_ABSTRACT) &&\n\t\t\t   !(m->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME)) {\n\t\tMonoMethodHeader *header;\n\t\tguint32 code_size;\n\t\tgint32 max_stack, i;\n\t\tgint32 num_locals = 0;\n\t\tgint32 num_clauses = 0;\n\t\tguint8 *code;\n\n\t\tif (rmb->ilgen) {\n\t\t\tcode = mono_array_addr (rmb->ilgen->code, guint8, 0);\n\t\t\tcode_size = rmb->ilgen->code_len;\n\t\t\tmax_stack = rmb->ilgen->max_stack;\n\t\t\tnum_locals = rmb->ilgen->locals ? mono_array_length (rmb->ilgen->locals) : 0;\n\t\t\tif (rmb->ilgen->ex_handlers)\n\t\t\t\tnum_clauses = method_count_clauses (rmb->ilgen);\n\t\t} else {\n\t\t\tif (rmb->code) {\n\t\t\t\tcode = mono_array_addr (rmb->code, guint8, 0);\n\t\t\t\tcode_size = mono_array_length (rmb->code);\n\t\t\t\t/* we probably need to run a verifier on the code... */\n\t\t\t\tmax_stack = 8; \n\t\t\t}\n\t\t\telse {\n\t\t\t\tcode = NULL;\n\t\t\t\tcode_size = 0;\n\t\t\t\tmax_stack = 8;\n\t\t\t}\n\t\t}\n\n\t\theader = image_g_malloc0 (image, MONO_SIZEOF_METHOD_HEADER + num_locals * sizeof (MonoType*));\n\t\theader->code_size = code_size;\n\t\theader->code = image_g_malloc (image, code_size);\n\t\tmemcpy ((char*)header->code, code, code_size);\n\t\theader->max_stack = max_stack;\n\t\theader->init_locals = rmb->init_locals;\n\t\theader->num_locals = num_locals;\n\n\t\tfor (i = 0; i < num_locals; ++i) {\n\t\t\tMonoReflectionLocalBuilder *lb = \n\t\t\t\tmono_array_get (rmb->ilgen->locals, MonoReflectionLocalBuilder*, i);\n\n\t\t\theader->locals [i] = image_g_new0 (image, MonoType, 1);\n\t\t\tmemcpy (header->locals [i], mono_reflection_type_get_handle ((MonoReflectionType*)lb->type), MONO_SIZEOF_TYPE);\n\t\t}\n\n\t\theader->num_clauses = num_clauses;\n\t\tif (num_clauses) {\n\t\t\theader->clauses = method_encode_clauses (image, (MonoDynamicImage*)klass->image,\n\t\t\t\t rmb->ilgen, num_clauses);\n\t\t}\n\n\t\tpm->header = header;\n\t}\n\n\tif (rmb->generic_params) {\n\t\tint count = mono_array_length (rmb->generic_params);\n\t\tMonoGenericContainer *container;\n\n\t\tcontainer = rmb->generic_container;\n\t\tif (container) {\n\t\t\tm->is_generic = TRUE;\n\t\t\tmono_method_set_generic_container (m, container);\n\t\t}\n\t\tcontainer->type_argc = count;\n\t\tcontainer->type_params = image_g_new0 (image, MonoGenericParamFull, count);\n\t\tcontainer->owner.method = m;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tMonoReflectionGenericParam *gp =\n\t\t\t\tmono_array_get (rmb->generic_params, MonoReflectionGenericParam*, i);\n\t\t\tMonoGenericParamFull *param = (MonoGenericParamFull *) mono_reflection_type_get_handle ((MonoReflectionType*)gp)->data.generic_param;\n\t\t\tcontainer->type_params [i] = *param;\n\t\t}\n\n\t\tif (klass->generic_container) {\n\t\t\tcontainer->parent = klass->generic_container;\n\t\t\tcontainer->context.class_inst = klass->generic_container->context.class_inst;\n\t\t}\n\t\tcontainer->context.method_inst = mono_get_shared_generic_inst (container);\n\t}\n\n\tif (rmb->refs) {\n\t\tMonoMethodWrapper *mw = (MonoMethodWrapper*)m;\n\t\tint i;\n\t\tvoid **data;\n\n\t\tm->wrapper_type = MONO_WRAPPER_DYNAMIC_METHOD;\n\n\t\tmw->method_data = data = image_g_new (image, gpointer, rmb->nrefs + 1);\n\t\tdata [0] = GUINT_TO_POINTER (rmb->nrefs);\n\t\tfor (i = 0; i < rmb->nrefs; ++i)\n\t\t\tdata [i + 1] = rmb->refs [i];\n\t}\n\n\tmethod_aux = NULL;\n\n\t/* Parameter info */\n\tif (rmb->pinfo) {\n\t\tif (!method_aux)\n\t\t\tmethod_aux = image_g_new0 (image, MonoReflectionMethodAux, 1);\n\t\tmethod_aux->param_names = image_g_new0 (image, char *, mono_method_signature (m)->param_count + 1);\n\t\tfor (i = 0; i <= m->signature->param_count; ++i) {\n\t\t\tMonoReflectionParamBuilder *pb;\n\t\t\tif ((pb = mono_array_get (rmb->pinfo, MonoReflectionParamBuilder*, i))) {\n\t\t\t\tif ((i > 0) && (pb->attrs)) {\n\t\t\t\t\t/* Make a copy since it might point to a shared type structure */\n\t\t\t\t\tm->signature->params [i - 1] = mono_metadata_type_dup (klass->image, m->signature->params [i - 1]);\n\t\t\t\t\tm->signature->params [i - 1]->attrs = pb->attrs;\n\t\t\t\t}\n\n\t\t\t\tif (pb->attrs & PARAM_ATTRIBUTE_HAS_DEFAULT) {\n\t\t\t\t\tMonoDynamicImage *assembly;\n\t\t\t\t\tguint32 idx, def_type, len;\n\t\t\t\t\tchar *p;\n\t\t\t\t\tconst char *p2;\n\n\t\t\t\t\tif (!method_aux->param_defaults) {\n\t\t\t\t\t\tmethod_aux->param_defaults = image_g_new0 (image, guint8*, m->signature->param_count + 1);\n\t\t\t\t\t\tmethod_aux->param_default_types = image_g_new0 (image, guint32, m->signature->param_count + 1);\n\t\t\t\t\t}\n\t\t\t\t\tassembly = (MonoDynamicImage*)klass->image;\n\t\t\t\t\tidx = encode_constant (assembly, pb->def_value, &def_type);\n\t\t\t\t\t/* Copy the data from the blob since it might get realloc-ed */\n\t\t\t\t\tp = assembly->blob.data + idx;\n\t\t\t\t\tlen = mono_metadata_decode_blob_size (p, &p2);\n\t\t\t\t\tlen += p2 - p;\n\t\t\t\t\tmethod_aux->param_defaults [i] = image_g_malloc (image, len);\n\t\t\t\t\tmethod_aux->param_default_types [i] = def_type;\n\t\t\t\t\tmemcpy ((gpointer)method_aux->param_defaults [i], p, len);\n\t\t\t\t}\n\n\t\t\t\tif (pb->name) {\n\t\t\t\t\tmethod_aux->param_names [i] = mono_string_to_utf8_image (image, pb->name, &error);\n\t\t\t\t\tg_assert (mono_error_ok (&error));\n\t\t\t\t}\n\t\t\t\tif (pb->cattrs) {\n\t\t\t\t\tif (!method_aux->param_cattr)\n\t\t\t\t\t\tmethod_aux->param_cattr = image_g_new0 (image, MonoCustomAttrInfo*, m->signature->param_count + 1);\n\t\t\t\t\tmethod_aux->param_cattr [i] = mono_custom_attrs_from_builders (image, klass->image, pb->cattrs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Parameter marshalling */\n\tspecs = NULL;\n\tif (rmb->pinfo)\t\t\n\t\tfor (i = 0; i < mono_array_length (rmb->pinfo); ++i) {\n\t\t\tMonoReflectionParamBuilder *pb;\n\t\t\tif ((pb = mono_array_get (rmb->pinfo, MonoReflectionParamBuilder*, i))) {\n\t\t\t\tif (pb->marshal_info) {\n\t\t\t\t\tif (specs == NULL)\n\t\t\t\t\t\tspecs = image_g_new0 (image, MonoMarshalSpec*, sig->param_count + 1);\n\t\t\t\t\tspecs [pb->position] = \n\t\t\t\t\t\tmono_marshal_spec_from_builder (image, klass->image->assembly, pb->marshal_info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif (specs != NULL) {\n\t\tif (!method_aux)\n\t\t\tmethod_aux = image_g_new0 (image, MonoReflectionMethodAux, 1);\n\t\tmethod_aux->param_marshall = specs;\n\t}\n\n\tif (klass->image->dynamic && method_aux)\n\t\tg_hash_table_insert (((MonoDynamicImage*)klass->image)->method_aux_hash, m, method_aux);\n\n\tmono_loader_unlock ();\n\n\treturn m;\n}\t\n\nstatic MonoMethod*\nctorbuilder_to_mono_method (MonoClass *klass, MonoReflectionCtorBuilder* mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\n\tmono_loader_lock ();\n\tsig = ctor_builder_to_signature (klass->image, mb);\n\tmono_loader_unlock ();\n\n\treflection_methodbuilder_from_ctor_builder (&rmb, mb);\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\tmono_save_custom_attrs (klass->image, mb->mhandle, mb->cattrs);\n\n\t/* If we are in a generic class, we might be called multiple times from inflate_method */\n\tif (!((MonoDynamicImage*)(MonoDynamicImage*)klass->image)->save && !klass->generic_container) {\n\t\t/* ilgen is no longer needed */\n\t\tmb->ilgen = NULL;\n\t}\n\n\treturn mb->mhandle;\n}\n\nstatic MonoMethod*\nmethodbuilder_to_mono_method (MonoClass *klass, MonoReflectionMethodBuilder* mb)\n{\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\n\tmono_loader_lock ();\n\tsig = method_builder_to_signature (klass->image, mb);\n\tmono_loader_unlock ();\n\n\treflection_methodbuilder_from_method_builder (&rmb, mb);\n\n\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\tmono_save_custom_attrs (klass->image, mb->mhandle, mb->cattrs);\n\n\t/* If we are in a generic class, we might be called multiple times from inflate_method */\n\tif (!((MonoDynamicImage*)(MonoDynamicImage*)klass->image)->save && !klass->generic_container) {\n\t\t/* ilgen is no longer needed */\n\t\tmb->ilgen = NULL;\n\t}\n\treturn mb->mhandle;\n}\n\nstatic MonoClassField*\nfieldbuilder_to_mono_class_field (MonoClass *klass, MonoReflectionFieldBuilder* fb)\n{\n\tMonoClassField *field;\n\tMonoType *custom;\n\n\tfield = g_new0 (MonoClassField, 1);\n\n\tfield->name = mono_string_to_utf8 (fb->name);\n\tif (fb->attrs || fb->modreq || fb->modopt) {\n\t\tfield->type = mono_metadata_type_dup (NULL, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type));\n\t\tfield->type->attrs = fb->attrs;\n\n\t\tg_assert (klass->image->dynamic);\n\t\tcustom = add_custom_modifiers ((MonoDynamicImage*)klass->image, field->type, fb->modreq, fb->modopt);\n\t\tg_free (field->type);\n\t\tfield->type = custom;\n\t} else {\n\t\tfield->type = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t}\n\tif (fb->offset != -1)\n\t\tfield->offset = fb->offset;\n\tfield->parent = klass;\n\tmono_save_custom_attrs (klass->image, field, fb->cattrs);\n\n\t// FIXME: Can't store fb->def_value/RVA, is it needed for field_on_insts ?\n\n\treturn field;\n}\n#endif\n\nMonoType*\nmono_reflection_bind_generic_parameters (MonoReflectionType *type, int type_argc, MonoType **types)\n{\n\tMonoClass *klass;\n\tMonoReflectionTypeBuilder *tb = NULL;\n\tgboolean is_dynamic = FALSE;\n\tMonoDomain *domain;\n\tMonoClass *geninst;\n\n\tmono_loader_lock ();\n\n\tdomain = mono_object_domain (type);\n\n\tif (!strcmp (((MonoObject *) type)->vtable->klass->name, \"TypeBuilder\")) {\n\t\ttb = (MonoReflectionTypeBuilder *) type;\n\n\t\tis_dynamic = TRUE;\n\t} else if (!strcmp (((MonoObject *) type)->vtable->klass->name, \"MonoGenericClass\")) {\n\t\tMonoReflectionGenericClass *rgi = (MonoReflectionGenericClass *) type;\n\n\t\ttb = rgi->generic_type;\n\t\tis_dynamic = TRUE;\n\t}\n\n\t/* FIXME: fix the CreateGenericParameters protocol to avoid the two stage setup of TypeBuilders */\n\tif (tb && tb->generic_container)\n\t\tmono_reflection_create_generic_class (tb);\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle (type));\n\tif (!klass->generic_container) {\n\t\tmono_loader_unlock ();\n\t\treturn NULL;\n\t}\n\n\tif (klass->wastypebuilder) {\n\t\ttb = (MonoReflectionTypeBuilder *) klass->reflection_info;\n\n\t\tis_dynamic = TRUE;\n\t}\n\n\tmono_loader_unlock ();\n\n\tgeninst = mono_class_bind_generic_parameters (klass, type_argc, types, is_dynamic);\n\n\treturn &geninst->byval_arg;\n}\n\nMonoClass*\nmono_class_bind_generic_parameters (MonoClass *klass, int type_argc, MonoType **types, gboolean is_dynamic)\n{\n\tMonoGenericClass *gclass;\n\tMonoGenericInst *inst;\n\n\tg_assert (klass->generic_container);\n\n\tinst = mono_metadata_get_generic_inst (type_argc, types);\n\tgclass = mono_metadata_lookup_generic_class (klass, inst, is_dynamic);\n\n\treturn mono_generic_class_get_class (gclass);\n}\n\nMonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"MethodBuilder\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\n\tklass = method->klass;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\t/*\n\t\t * This table maps metadata structures representing inflated methods/fields\n\t\t * to the reflection objects representing their generic definitions.\n\t\t */\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\n\tif (!mono_verifier_is_method_valid_generic_instantiation (inflated))\n\t\tmono_raise_exception (mono_get_exception_argument (\"typeArguments\", \"Invalid generic arguments\"));\n\t\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n\nstatic MonoMethod *\ninflate_mono_method (MonoClass *klass, MonoMethod *method, MonoObject *obj)\n{\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext *context;\n\tint i;\n\n\t/*\n\t * With generic code sharing the klass might not be inflated.\n\t * This can happen because classes inflated with their own\n\t * type arguments are \"normalized\" to the uninflated class.\n\t */\n\tif (!klass->generic_class)\n\t\treturn method;\n\n\tcontext = mono_class_get_context (klass);\n\n\tif (klass->method.count) {\n\t\t/* Find the already created inflated method */\n\t\tfor (i = 0; i < klass->method.count; ++i) {\n\t\t\tg_assert (klass->methods [i]->is_inflated);\n\t\t\tif (((MonoMethodInflated*)klass->methods [i])->declaring == method)\n\t\t\t\tbreak;\n\t\t}\n\t\tg_assert (i < klass->method.count);\n\t\timethod = (MonoMethodInflated*)klass->methods [i];\n\t} else {\n\t\timethod = (MonoMethodInflated *) mono_class_inflate_generic_method_full (method, klass, context);\n\t}\n\n\tif (method->is_generic && method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, obj);\n\t\tmono_loader_unlock ();\n\t}\n\treturn (MonoMethod *) imethod;\n}\n\nstatic MonoMethod *\ninflate_method (MonoReflectionGenericClass *type, MonoObject *obj)\n{\n\tMonoMethod *method;\n\tMonoClass *gklass;\n\n\tgklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)type->generic_type));\n\n\tif (!strcmp (obj->vtable->klass->name, \"MethodBuilder\"))\n\t\tif (((MonoReflectionMethodBuilder*)obj)->mhandle)\n\t\t\tmethod = ((MonoReflectionMethodBuilder*)obj)->mhandle;\n\t\telse\n\t\t\tmethod = methodbuilder_to_mono_method (gklass, (MonoReflectionMethodBuilder *) obj);\n\telse if (!strcmp (obj->vtable->klass->name, \"ConstructorBuilder\"))\n\t\tmethod = ctorbuilder_to_mono_method (gklass, (MonoReflectionCtorBuilder *) obj);\n\telse if (!strcmp (obj->vtable->klass->name, \"MonoMethod\") || !strcmp (obj->vtable->klass->name, \"MonoCMethod\"))\n\t\tmethod = ((MonoReflectionMethod *) obj)->method;\n\telse {\n\t\tmethod = NULL; /* prevent compiler warning */\n\t\tg_error (\"can't handle type %s\", obj->vtable->klass->name);\n\t}\n\n\treturn inflate_mono_method (mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)type)), method, obj);\n}\n\n/*TODO avoid saving custom attrs for generic classes as it's enough to have them on the generic type definition.*/\nvoid\nmono_reflection_generic_class_initialize (MonoReflectionGenericClass *type, MonoArray *methods, \n\t\t\t\t\t  MonoArray *ctors, MonoArray *fields, MonoArray *properties,\n\t\t\t\t\t  MonoArray *events)\n{\n\tMonoGenericClass *gclass;\n\tMonoDynamicGenericClass *dgclass;\n\tMonoClass *klass, *gklass;\n\tMonoType *gtype;\n\tint i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tgtype = mono_reflection_type_get_handle ((MonoReflectionType*)type);\n\tklass = mono_class_from_mono_type (gtype);\n\tg_assert (gtype->type == MONO_TYPE_GENERICINST);\n\tgclass = gtype->data.generic_class;\n\n\tg_assert (gclass->is_dynamic);\n\tdgclass = (MonoDynamicGenericClass *) gclass;\n\n\tif (dgclass->initialized)\n\t\treturn;\n\n\tgklass = gclass->container_class;\n\tmono_class_init (gklass);\n\n\tdgclass->count_methods = methods ? mono_array_length (methods) : 0;\n\tdgclass->count_ctors = ctors ? mono_array_length (ctors) : 0;\n\tdgclass->count_fields = fields ? mono_array_length (fields) : 0;\n\tdgclass->count_properties = properties ? mono_array_length (properties) : 0;\n\tdgclass->count_events = events ? mono_array_length (events) : 0;\n\n\tdgclass->methods = g_new0 (MonoMethod *, dgclass->count_methods);\n\tdgclass->ctors = g_new0 (MonoMethod *, dgclass->count_ctors);\n\tdgclass->fields = g_new0 (MonoClassField, dgclass->count_fields);\n\tdgclass->properties = g_new0 (MonoProperty, dgclass->count_properties);\n\tdgclass->events = g_new0 (MonoEvent, dgclass->count_events);\n\tdgclass->field_objects = g_new0 (MonoObject*, dgclass->count_fields);\n\tdgclass->field_generic_types = g_new0 (MonoType*, dgclass->count_fields);\n\n\tfor (i = 0; i < dgclass->count_methods; i++) {\n\t\tMonoObject *obj = mono_array_get (methods, gpointer, i);\n\n\t\tdgclass->methods [i] = inflate_method (type, obj);\n\t}\n\n\tfor (i = 0; i < dgclass->count_ctors; i++) {\n\t\tMonoObject *obj = mono_array_get (ctors, gpointer, i);\n\n\t\tdgclass->ctors [i] = inflate_method (type, obj);\n\t}\n\n\tfor (i = 0; i < dgclass->count_fields; i++) {\n\t\tMonoObject *obj = mono_array_get (fields, gpointer, i);\n\t\tMonoClassField *field, *inflated_field = NULL;\n\n\t\tif (!strcmp (obj->vtable->klass->name, \"FieldBuilder\"))\n\t\t\tinflated_field = field = fieldbuilder_to_mono_class_field (klass, (MonoReflectionFieldBuilder *) obj);\n\t\telse if (!strcmp (obj->vtable->klass->name, \"MonoField\"))\n\t\t\tfield = ((MonoReflectionField *) obj)->field;\n\t\telse {\n\t\t\tfield = NULL; /* prevent compiler warning */\n\t\t\tg_assert_not_reached ();\n\t\t}\n\n\t\tdgclass->fields [i] = *field;\n\t\tdgclass->fields [i].parent = klass;\n\t\tdgclass->fields [i].type = mono_class_inflate_generic_type (\n\t\t\tfield->type, mono_generic_class_get_context ((MonoGenericClass *) dgclass));\n\t\tdgclass->field_generic_types [i] = field->type;\n\t\tMOVING_GC_REGISTER (&dgclass->field_objects [i]);\n\t\tdgclass->field_objects [i] = obj;\n\n\t\tif (inflated_field) {\n\t\t\tg_free (inflated_field);\n\t\t} else {\n\t\t\tdgclass->fields [i].name = g_strdup (dgclass->fields [i].name);\n\t\t}\n\t}\n\n\tfor (i = 0; i < dgclass->count_properties; i++) {\n\t\tMonoObject *obj = mono_array_get (properties, gpointer, i);\n\t\tMonoProperty *property = &dgclass->properties [i];\n\n\t\tif (!strcmp (obj->vtable->klass->name, \"PropertyBuilder\")) {\n\t\t\tMonoReflectionPropertyBuilder *pb = (MonoReflectionPropertyBuilder *) obj;\n\n\t\t\tproperty->parent = klass;\n\t\t\tproperty->attrs = pb->attrs;\n\t\t\tproperty->name = mono_string_to_utf8 (pb->name);\n\t\t\tif (pb->get_method)\n\t\t\t\tproperty->get = inflate_method (type, (MonoObject *) pb->get_method);\n\t\t\tif (pb->set_method)\n\t\t\t\tproperty->set = inflate_method (type, (MonoObject *) pb->set_method);\n\t\t} else if (!strcmp (obj->vtable->klass->name, \"MonoProperty\")) {\n\t\t\t*property = *((MonoReflectionProperty *) obj)->property;\n\t\t\tproperty->name = g_strdup (property->name);\n\n\t\t\tif (property->get)\n\t\t\t\tproperty->get = inflate_mono_method (klass, property->get, NULL);\n\t\t\tif (property->set)\n\t\t\t\tproperty->set = inflate_mono_method (klass, property->set, NULL);\n\t\t} else\n\t\t\tg_assert_not_reached ();\n\t}\n\n\tfor (i = 0; i < dgclass->count_events; i++) {\n\t\tMonoObject *obj = mono_array_get (events, gpointer, i);\n\t\tMonoEvent *event = &dgclass->events [i];\n\n\t\tif (!strcmp (obj->vtable->klass->name, \"EventBuilder\")) {\n\t\t\tMonoReflectionEventBuilder *eb = (MonoReflectionEventBuilder *) obj;\n\n\t\t\tevent->parent = klass;\n\t\t\tevent->attrs = eb->attrs;\n\t\t\tevent->name = mono_string_to_utf8 (eb->name);\n\t\t\tif (eb->add_method)\n\t\t\t\tevent->add = inflate_method (type, (MonoObject *) eb->add_method);\n\t\t\tif (eb->remove_method)\n\t\t\t\tevent->remove = inflate_method (type, (MonoObject *) eb->remove_method);\n\t\t} else if (!strcmp (obj->vtable->klass->name, \"MonoEvent\")) {\n\t\t\t*event = *((MonoReflectionMonoEvent *) obj)->event;\n\t\t\tevent->name = g_strdup (event->name);\n\n\t\t\tif (event->add)\n\t\t\t\tevent->add = inflate_mono_method (klass, event->add, NULL);\n\t\t\tif (event->remove)\n\t\t\t\tevent->remove = inflate_mono_method (klass, event->remove, NULL);\n\t\t} else\n\t\t\tg_assert_not_reached ();\n\t}\n\n\tdgclass->initialized = TRUE;\n}\n\nstatic void\nensure_generic_class_runtime_vtable (MonoClass *klass)\n{\n\tMonoClass *gklass = klass->generic_class->container_class;\n\tint i;\n\n\tif (klass->wastypebuilder)\n\t\treturn;\n\n\tensure_runtime_vtable (gklass);\n\n\tklass->method.count = gklass->method.count;\n\tklass->methods = mono_image_alloc (klass->image, sizeof (MonoMethod*) * (klass->method.count + 1));\n\n\tfor (i = 0; i < klass->method.count; i++) {\n\t\tklass->methods [i] = mono_class_inflate_generic_method_full (\n\t\t\tgklass->methods [i], klass, mono_class_get_context (klass));\n\t}\n\n\tklass->interface_count = gklass->interface_count;\n\tklass->interfaces = mono_image_alloc (klass->image, sizeof (MonoClass*) * klass->interface_count);\n\tfor (i = 0; i < klass->interface_count; ++i) {\n\t\tMonoType *iface_type = mono_class_inflate_generic_type (&gklass->interfaces [i]->byval_arg, mono_class_get_context (klass));\n\t\tklass->interfaces [i] = mono_class_from_mono_type (iface_type);\n\t\tmono_metadata_free_type (iface_type);\n\n\t\tensure_runtime_vtable (klass->interfaces [i]);\n\t}\n\tklass->interfaces_inited = 1;\n\n\t/*We can only finish with this klass once it's parent has as well*/\n\tif (gklass->wastypebuilder)\n\t\tklass->wastypebuilder = TRUE;\n\treturn;\n}\n\nstatic void\nensure_runtime_vtable (MonoClass *klass)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tint i, num, j;\n\n\tif (!klass->image->dynamic || (!tb && !klass->generic_class) || klass->wastypebuilder)\n\t\treturn;\n\tif (klass->parent)\n\t\tensure_runtime_vtable (klass->parent);\n\n\tif (tb) {\n\t\tnum = tb->ctors? mono_array_length (tb->ctors): 0;\n\t\tnum += tb->num_methods;\n\t\tklass->method.count = num;\n\t\tklass->methods = mono_image_alloc (klass->image, sizeof (MonoMethod*) * num);\n\t\tnum = tb->ctors? mono_array_length (tb->ctors): 0;\n\t\tfor (i = 0; i < num; ++i)\n\t\t\tklass->methods [i] = ctorbuilder_to_mono_method (klass, mono_array_get (tb->ctors, MonoReflectionCtorBuilder*, i));\n\t\tnum = tb->num_methods;\n\t\tj = i;\n\t\tfor (i = 0; i < num; ++i)\n\t\t\tklass->methods [j++] = methodbuilder_to_mono_method (klass, mono_array_get (tb->methods, MonoReflectionMethodBuilder*, i));\n\t\n\t\tif (tb->interfaces) {\n\t\t\tklass->interface_count = mono_array_length (tb->interfaces);\n\t\t\tklass->interfaces = mono_image_alloc (klass->image, sizeof (MonoClass*) * klass->interface_count);\n\t\t\tfor (i = 0; i < klass->interface_count; ++i) {\n\t\t\t\tMonoType *iface = mono_type_array_get_and_resolve (tb->interfaces, i);\n\t\t\t\tklass->interfaces [i] = mono_class_from_mono_type (iface);\n\t\t\t\tensure_runtime_vtable (klass->interfaces [i]);\n\t\t\t}\n\t\t\tklass->interfaces_inited = 1;\n\t\t}\n\t} else if (klass->generic_class){\n\t\tensure_generic_class_runtime_vtable (klass);\n\t}\n\n\tif (klass->flags & TYPE_ATTRIBUTE_INTERFACE) {\n\t\tfor (i = 0; i < klass->method.count; ++i)\n\t\t\tklass->methods [i]->slot = i;\n\t\t\n\t\tmono_class_setup_interface_offsets (klass);\n\t\tmono_class_setup_interface_id (klass);\n\t}\n\n\t/*\n\t * The generic vtable is needed even if image->run is not set since some\n\t * runtime code like ves_icall_Type_GetMethodsByName depends on \n\t * method->slot being defined.\n\t */\n\n\t/* \n\t * tb->methods could not be freed since it is used for determining \n\t * overrides during dynamic vtable construction.\n\t */\n}\n\nstatic MonoMethod*\nmono_reflection_method_get_handle (MonoObject *method)\n{\n\tMonoClass *class = mono_object_class (method);\n\tif (is_sr_mono_method (class) || is_sr_mono_generic_method (class)) {\n\t\tMonoReflectionMethod *sr_method = (MonoReflectionMethod*)method;\n\t\treturn sr_method->method;\n\t}\n\tif (is_sre_method_builder (class)) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder*)method;\n\t\treturn mb->mhandle;\n\t}\n\tif (is_sre_method_on_tb_inst (class)) {\n\t\tMonoReflectionMethodOnTypeBuilderInst *m = (MonoReflectionMethodOnTypeBuilderInst*)method;\n\t\tMonoMethod *result;\n\t\t/*FIXME move this to a proper method and unify with resolve_object*/\n\t\tif (m->method_args) {\n\t\t\tresult = mono_reflection_method_on_tb_inst_get_handle (m);\n\t\t} else {\n\t\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)m->inst);\n\t\t\tMonoClass *inflated_klass = mono_class_from_mono_type (type);\n\t\t\tMonoMethod *mono_method;\n\n\t\t\tif (is_sre_method_builder (mono_object_class (m->mb)))\n\t\t\t\tmono_method = ((MonoReflectionMethodBuilder *)m->mb)->mhandle;\n \t\t\telse if (is_sr_mono_method (mono_object_class (m->mb)))\n\t\t\t\tmono_method = ((MonoReflectionMethod *)m->mb)->method;\n\t\t\telse\n\t\t\t\tg_error (\"resolve_object:: can't handle a MTBI with base_method of type %s\", mono_type_get_full_name (mono_object_class (m->mb)));\n\n\t\t\tresult = inflate_mono_method (inflated_klass, mono_method, (MonoObject*)m->mb);\n\t\t}\n\t\treturn result;\n\t}\n\n\tg_error (\"Can't handle methods of type %s:%s\", class->name_space, class->name);\n\treturn NULL;\n}\n\nvoid\nmono_reflection_get_dynamic_overrides (MonoClass *klass, MonoMethod ***overrides, int *num_overrides)\n{\n\tMonoReflectionTypeBuilder *tb;\n\tint i, onum;\n\n\t*overrides = NULL;\n\t*num_overrides = 0;\n\n\tg_assert (klass->image->dynamic);\n\n\tif (!klass->reflection_info)\n\t\treturn;\n\n\tg_assert (strcmp (((MonoObject*)klass->reflection_info)->vtable->klass->name, \"TypeBuilder\") == 0);\n\n\ttb = (MonoReflectionTypeBuilder*)klass->reflection_info;\n\n\tonum = 0;\n\tif (tb->methods) {\n\t\tfor (i = 0; i < tb->num_methods; ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\tmono_array_get (tb->methods, MonoReflectionMethodBuilder*, i);\n\t\t\tif (mb->override_method)\n\t\t\t\tonum ++;\n\t\t}\n\t}\n\n\tif (onum) {\n\t\t*overrides = g_new0 (MonoMethod*, onum * 2);\n\n\t\tonum = 0;\n\t\tfor (i = 0; i < tb->num_methods; ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\tmono_array_get (tb->methods, MonoReflectionMethodBuilder*, i);\n\t\t\tif (mb->override_method) {\n\t\t\t\t(*overrides) [onum * 2] = mono_reflection_method_get_handle ((MonoObject *)mb->override_method);\n\t\t\t\t(*overrides) [onum * 2 + 1] = mb->mhandle;\n\n\t\t\t\tg_assert (mb->mhandle);\n\n\t\t\t\tonum ++;\n\t\t\t}\n\t\t}\n\t}\n\n\t*num_overrides = onum;\n}\n\nstatic void\ntypebuilder_setup_fields (MonoClass *klass, MonoError *error)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tMonoReflectionFieldBuilder *fb;\n\tMonoClassField *field;\n\tMonoImage *image = klass->image;\n\tconst char *p, *p2;\n\tint i;\n\tguint32 len, idx, real_size = 0;\n\n\tklass->field.count = tb->num_fields;\n\tklass->field.first = 0;\n\n\tmono_error_init (error);\n\n\tif (tb->class_size) {\n\t\tg_assert ((tb->packing_size & 0xfffffff0) == 0);\n\t\tklass->packing_size = tb->packing_size;\n\t\treal_size = klass->instance_size + tb->class_size;\n\t}\n\n\tif (!klass->field.count) {\n\t\tklass->instance_size = MAX (klass->instance_size, real_size);\n\t\treturn;\n\t}\n\t\n\tklass->fields = image_g_new0 (image, MonoClassField, klass->field.count);\n\tmono_class_alloc_ext (klass);\n\tklass->ext->field_def_values = image_g_new0 (image, MonoFieldDefaultValue, klass->field.count);\n\t/*\n\tThis is, guess what, a hack.\n\tThe issue is that the runtime doesn't know how to setup the fields of a typebuider and crash.\n\tOn the static path no field class is resolved, only types are built. This is the right thing to do\n\tbut we suck.\n\tSetting size_inited is harmless because we're doing the same job as mono_class_setup_fields anyway.\n\t*/\n\tklass->size_inited = 1;\n\n\tfor (i = 0; i < klass->field.count; ++i) {\n\t\tfb = mono_array_get (tb->fields, gpointer, i);\n\t\tfield = &klass->fields [i];\n\t\tfield->name = mono_string_to_utf8_image (image, fb->name, error);\n\t\tif (!mono_error_ok (error))\n\t\t\treturn;\n\t\tif (fb->attrs) {\n\t\t\tfield->type = mono_metadata_type_dup (klass->image, mono_reflection_type_get_handle ((MonoReflectionType*)fb->type));\n\t\t\tfield->type->attrs = fb->attrs;\n\t\t} else {\n\t\t\tfield->type = mono_reflection_type_get_handle ((MonoReflectionType*)fb->type);\n\t\t}\n\t\tif ((fb->attrs & FIELD_ATTRIBUTE_HAS_FIELD_RVA) && fb->rva_data)\n\t\t\tklass->ext->field_def_values [i].data = mono_array_addr (fb->rva_data, char, 0);\n\t\tif (fb->offset != -1)\n\t\t\tfield->offset = fb->offset;\n\t\tfield->parent = klass;\n\t\tfb->handle = field;\n\t\tmono_save_custom_attrs (klass->image, field, fb->cattrs);\n\n\t\tif (fb->def_value) {\n\t\t\tMonoDynamicImage *assembly = (MonoDynamicImage*)klass->image;\n\t\t\tfield->type->attrs |= FIELD_ATTRIBUTE_HAS_DEFAULT;\n\t\t\tidx = encode_constant (assembly, fb->def_value, &klass->ext->field_def_values [i].def_type);\n\t\t\t/* Copy the data from the blob since it might get realloc-ed */\n\t\t\tp = assembly->blob.data + idx;\n\t\t\tlen = mono_metadata_decode_blob_size (p, &p2);\n\t\t\tlen += p2 - p;\n\t\t\tklass->ext->field_def_values [i].data = mono_image_alloc (image, len);\n\t\t\tmemcpy ((gpointer)klass->ext->field_def_values [i].data, p, len);\n\t\t}\n\t}\n\n\tklass->instance_size = MAX (klass->instance_size, real_size);\n\tmono_class_layout_fields (klass);\n}\n\nstatic void\ntypebuilder_setup_properties (MonoClass *klass, MonoError *error)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tMonoReflectionPropertyBuilder *pb;\n\tMonoImage *image = klass->image;\n\tMonoProperty *properties;\n\tint i;\n\n\tmono_error_init (error);\n\n\tif (!klass->ext)\n\t\tklass->ext = image_g_new0 (image, MonoClassExt, 1);\n\n\tklass->ext->property.count = tb->properties ? mono_array_length (tb->properties) : 0;\n\tklass->ext->property.first = 0;\n\n\tproperties = image_g_new0 (image, MonoProperty, klass->ext->property.count);\n\tklass->ext->properties = properties;\n\tfor (i = 0; i < klass->ext->property.count; ++i) {\n\t\tpb = mono_array_get (tb->properties, MonoReflectionPropertyBuilder*, i);\n\t\tproperties [i].parent = klass;\n\t\tproperties [i].attrs = pb->attrs;\n\t\tproperties [i].name = mono_string_to_utf8_image (image, pb->name, error);\n\t\tif (!mono_error_ok (error))\n\t\t\treturn;\n\t\tif (pb->get_method)\n\t\t\tproperties [i].get = pb->get_method->mhandle;\n\t\tif (pb->set_method)\n\t\t\tproperties [i].set = pb->set_method->mhandle;\n\n\t\tmono_save_custom_attrs (klass->image, &properties [i], pb->cattrs);\n\t}\n}\n\nMonoReflectionEvent *\nmono_reflection_event_builder_get_event_info (MonoReflectionTypeBuilder *tb, MonoReflectionEventBuilder *eb)\n{\n\tMonoEvent *event = g_new0 (MonoEvent, 1);\n\tMonoClass *klass;\n\tint j;\n\n\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\tevent->parent = klass;\n\tevent->attrs = eb->attrs;\n\tevent->name = mono_string_to_utf8 (eb->name);\n\tif (eb->add_method)\n\t\tevent->add = eb->add_method->mhandle;\n\tif (eb->remove_method)\n\t\tevent->remove = eb->remove_method->mhandle;\n\tif (eb->raise_method)\n\t\tevent->raise = eb->raise_method->mhandle;\n\n\tif (eb->other_methods) {\n\t\tevent->other = g_new0 (MonoMethod*, mono_array_length (eb->other_methods) + 1);\n\t\tfor (j = 0; j < mono_array_length (eb->other_methods); ++j) {\n\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\tmono_array_get (eb->other_methods,\n\t\t\t\t\t\tMonoReflectionMethodBuilder*, j);\n\t\t\tevent->other [j] = mb->mhandle;\n\t\t}\n\t}\n\n\treturn mono_event_get_object (mono_object_domain (tb), klass, event);\n}\n\nstatic void\ntypebuilder_setup_events (MonoClass *klass, MonoError *error)\n{\n\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\tMonoReflectionEventBuilder *eb;\n\tMonoImage *image = klass->image;\n\tMonoEvent *events;\n\tint i, j;\n\n\tmono_error_init (error);\n\n\tif (!klass->ext)\n\t\tklass->ext = image_g_new0 (image, MonoClassExt, 1);\n\n\tklass->ext->event.count = tb->events ? mono_array_length (tb->events) : 0;\n\tklass->ext->event.first = 0;\n\n\tevents = image_g_new0 (image, MonoEvent, klass->ext->event.count);\n\tklass->ext->events = events;\n\tfor (i = 0; i < klass->ext->event.count; ++i) {\n\t\teb = mono_array_get (tb->events, MonoReflectionEventBuilder*, i);\n\t\tevents [i].parent = klass;\n\t\tevents [i].attrs = eb->attrs;\n\t\tevents [i].name = mono_string_to_utf8_image (image, eb->name, error);\n\t\tif (!mono_error_ok (error))\n\t\t\treturn;\n\t\tif (eb->add_method)\n\t\t\tevents [i].add = eb->add_method->mhandle;\n\t\tif (eb->remove_method)\n\t\t\tevents [i].remove = eb->remove_method->mhandle;\n\t\tif (eb->raise_method)\n\t\t\tevents [i].raise = eb->raise_method->mhandle;\n\n\t\tif (eb->other_methods) {\n\t\t\tevents [i].other = image_g_new0 (image, MonoMethod*, mono_array_length (eb->other_methods) + 1);\n\t\t\tfor (j = 0; j < mono_array_length (eb->other_methods); ++j) {\n\t\t\t\tMonoReflectionMethodBuilder *mb = \n\t\t\t\t\tmono_array_get (eb->other_methods,\n\t\t\t\t\t\t\t\t\tMonoReflectionMethodBuilder*, j);\n\t\t\t\tevents [i].other [j] = mb->mhandle;\n\t\t\t}\n\t\t}\n\t\tmono_save_custom_attrs (klass->image, &events [i], eb->cattrs);\n\t}\n}\n\nstatic gboolean\nremove_instantiations_of (gpointer key,\n\t\t\t\t\t\t  gpointer value,\n\t\t\t\t\t\t  gpointer user_data)\n{\n\tMonoType *type = (MonoType*)key;\n\tMonoClass *klass = (MonoClass*)user_data;\n\n\tif ((type->type == MONO_TYPE_GENERICINST) && (type->data.generic_class->container_class == klass))\n\t\treturn TRUE;\n\telse\n\t\treturn FALSE;\n}\n\nstatic void\ncheck_array_for_usertypes (MonoArray *arr)\n{\n\tint i;\n\n\tif (!arr)\n\t\treturn;\n\n\tfor (i = 0; i < mono_array_length (arr); ++i)\n\t\tRESOLVE_ARRAY_TYPE_ELEMENT (arr, i);\n}\n\nMonoReflectionType*\nmono_reflection_create_runtime_class (MonoReflectionTypeBuilder *tb)\n{\n\tMonoError error;\n\tMonoClass *klass;\n\tMonoDomain* domain;\n\tMonoReflectionType* res;\n\tint i, j;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tdomain = mono_object_domain (tb);\n\tklass = mono_class_from_mono_type (tb->type.type);\n\n\t/*\n\t * Check for user defined Type subclasses.\n\t */\n\tRESOLVE_TYPE (tb->parent);\n\tcheck_array_for_usertypes (tb->interfaces);\n\tif (tb->fields) {\n\t\tfor (i = 0; i < mono_array_length (tb->fields); ++i) {\n\t\t\tMonoReflectionFieldBuilder *fb = mono_array_get (tb->fields, gpointer, i);\n\t\t\tif (fb) {\n\t\t\t\tRESOLVE_TYPE (fb->type);\n\t\t\t\tcheck_array_for_usertypes (fb->modreq);\n\t\t\t\tcheck_array_for_usertypes (fb->modopt);\n\t\t\t\tif (fb->marshal_info && fb->marshal_info->marshaltyperef)\n\t\t\t\t\tRESOLVE_TYPE (fb->marshal_info->marshaltyperef);\n\t\t\t}\n\t\t}\n\t}\n\tif (tb->methods) {\n\t\tfor (i = 0; i < mono_array_length (tb->methods); ++i) {\n\t\t\tMonoReflectionMethodBuilder *mb = mono_array_get (tb->methods, gpointer, i);\n\t\t\tif (mb) {\n\t\t\t\tRESOLVE_TYPE (mb->rtype);\n\t\t\t\tcheck_array_for_usertypes (mb->return_modreq);\n\t\t\t\tcheck_array_for_usertypes (mb->return_modopt);\n\t\t\t\tcheck_array_for_usertypes (mb->parameters);\n\t\t\t\tif (mb->param_modreq)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modreq); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modreq, MonoArray*, j));\n\t\t\t\tif (mb->param_modopt)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modopt); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modopt, MonoArray*, j));\n\t\t\t}\n\t\t}\n\t}\n\tif (tb->ctors) {\n\t\tfor (i = 0; i < mono_array_length (tb->ctors); ++i) {\n\t\t\tMonoReflectionCtorBuilder *mb = mono_array_get (tb->ctors, gpointer, i);\n\t\t\tif (mb) {\n\t\t\t\tcheck_array_for_usertypes (mb->parameters);\n\t\t\t\tif (mb->param_modreq)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modreq); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modreq, MonoArray*, j));\n\t\t\t\tif (mb->param_modopt)\n\t\t\t\t\tfor (j = 0; j < mono_array_length (mb->param_modopt); ++j)\n\t\t\t\t\t\tcheck_array_for_usertypes (mono_array_get (mb->param_modopt, MonoArray*, j));\n\t\t\t}\n\t\t}\n\t}\n\n\tmono_save_custom_attrs (klass->image, klass, tb->cattrs);\n\n\t/* \n\t * we need to lock the domain because the lock will be taken inside\n\t * So, we need to keep the locking order correct.\n\t */\n\tmono_loader_lock ();\n\tmono_domain_lock (domain);\n\tif (klass->wastypebuilder) {\n\t\tmono_domain_unlock (domain);\n\t\tmono_loader_unlock ();\n\t\treturn mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n\t}\n\t/*\n\t * Fields to set in klass:\n\t * the various flags: delegate/unicode/contextbound etc.\n\t */\n\tklass->flags = tb->attrs;\n\tklass->has_cctor = 1;\n\tklass->has_finalize = 1;\n\n#if 0\n\tif (!((MonoDynamicImage*)klass->image)->run) {\n\t\tif (klass->generic_container) {\n\t\t\t/* FIXME: The code below can't handle generic classes */\n\t\t\tklass->wastypebuilder = TRUE;\n\t\t\tmono_loader_unlock ();\n\t\t\tmono_domain_unlock (domain);\n\t\t\treturn mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n\t\t}\n\t}\n#endif\n\n\t/* enums are done right away */\n\tif (!klass->enumtype)\n\t\tensure_runtime_vtable (klass);\n\n\tif (tb->subtypes) {\n\t\tfor (i = 0; i < mono_array_length (tb->subtypes); ++i) {\n\t\t\tMonoReflectionTypeBuilder *subtb = mono_array_get (tb->subtypes, MonoReflectionTypeBuilder*, i);\n\t\t\tmono_class_alloc_ext (klass);\n\t\t\tklass->ext->nested_classes = g_list_prepend_image (klass->image, klass->ext->nested_classes, mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)subtb)));\n\t\t}\n\t}\n\n\tklass->nested_classes_inited = TRUE;\n\n\t/* fields and object layout */\n\tif (klass->parent) {\n\t\tif (!klass->parent->size_inited)\n\t\t\tmono_class_init (klass->parent);\n\t\tklass->instance_size = klass->parent->instance_size;\n\t\tklass->sizes.class_size = 0;\n\t\tklass->min_align = klass->parent->min_align;\n\t\t/* if the type has no fields we won't call the field_setup\n\t\t * routine which sets up klass->has_references.\n\t\t */\n\t\tklass->has_references |= klass->parent->has_references;\n\t} else {\n\t\tklass->instance_size = sizeof (MonoObject);\n\t\tklass->min_align = 1;\n\t}\n\n\t/* FIXME: handle packing_size and instance_size */\n\ttypebuilder_setup_fields (klass, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\ttypebuilder_setup_properties (klass, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\n\ttypebuilder_setup_events (klass, &error);\n\tif (!mono_error_ok (&error))\n\t\tgoto failure;\n\n\tklass->wastypebuilder = TRUE;\n\n\t/* \n\t * If we are a generic TypeBuilder, there might be instantiations in the type cache\n\t * which have type System.Reflection.MonoGenericClass, but after the type is created, \n\t * we want to return normal System.MonoType objects, so clear these out from the cache.\n\t */\n\tif (domain->type_hash && klass->generic_container)\n\t\tmono_g_hash_table_foreach_remove (domain->type_hash, remove_instantiations_of, klass);\n\n\tmono_domain_unlock (domain);\n\tmono_loader_unlock ();\n\n\tif (klass->enumtype && !mono_class_is_valid_enum (klass)) {\n\t\tmono_class_set_failure (klass, MONO_EXCEPTION_TYPE_LOAD, NULL);\n\t\tmono_raise_exception (mono_get_exception_type_load (tb->name, NULL));\n\t}\n\n\tres = mono_type_get_object (mono_object_domain (tb), &klass->byval_arg);\n\tg_assert (res != (MonoReflectionType*)tb);\n\n\treturn res;\n\nfailure:\n\tmono_class_set_failure (klass, MONO_EXCEPTION_TYPE_LOAD, NULL);\n\tklass->wastypebuilder = TRUE;\n\tmono_domain_unlock (domain);\n\tmono_loader_unlock ();\n\tmono_error_raise_exception (&error);\n\treturn NULL;\n}\n\nvoid\nmono_reflection_initialize_generic_parameter (MonoReflectionGenericParam *gparam)\n{\n\tMonoGenericParamFull *param;\n\tMonoImage *image;\n\tMonoClass *pklass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tparam = g_new0 (MonoGenericParamFull, 1);\n\n\tif (gparam->mbuilder) {\n\t\tif (!gparam->mbuilder->generic_container) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)gparam->mbuilder->type;\n\t\t\tMonoClass *klass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\t\t\tgparam->mbuilder->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\t\t\tgparam->mbuilder->generic_container->is_method = TRUE;\n\t\t\t/* \n\t\t\t * Cannot set owner.method, since the MonoMethod is not created yet.\n\t\t\t * Set the image field instead, so type_in_image () works.\n\t\t\t */\n\t\t\tgparam->mbuilder->generic_container->image = klass->image;\n\t\t}\n\t\tparam->param.owner = gparam->mbuilder->generic_container;\n\t} else if (gparam->tbuilder) {\n\t\tif (!gparam->tbuilder->generic_container) {\n\t\t\tMonoClass *klass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)gparam->tbuilder));\n\t\t\tgparam->tbuilder->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\t\t\tgparam->tbuilder->generic_container->owner.klass = klass;\n\t\t}\n\t\tparam->param.owner = gparam->tbuilder->generic_container;\n\t}\n\n\tparam->info.name = mono_string_to_utf8 (gparam->name);\n\tparam->param.num = gparam->index;\n\n\timage = &gparam->tbuilder->module->dynamic_image->image;\n\tpklass = mono_class_from_generic_parameter ((MonoGenericParam *) param, image, gparam->mbuilder != NULL);\n\n\tgparam->type.type = &pklass->byval_arg;\n\n\tMOVING_GC_REGISTER (&pklass->reflection_info);\n\tpklass->reflection_info = gparam; /* FIXME: GC pin gparam */\n\tmono_image_lock (image);\n\timage->reflection_info_unregister_classes = g_slist_prepend (image->reflection_info_unregister_classes, pklass);\n\tmono_image_unlock (image);\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_local (MonoReflectionSigHelper *sig)\n{\n\tMonoReflectionModuleBuilder *module = sig->module;\n\tMonoDynamicImage *assembly = module != NULL ? module->dynamic_image : NULL;\n\tguint32 na = sig->arguments ? mono_array_length (sig->arguments) : 0;\n\tguint32 buflen, i;\n\tMonoArray *result;\n\tSigBuffer buf;\n\n\tcheck_array_for_usertypes (sig->arguments);\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, 0x07);\n\tsigbuffer_add_value (&buf, na);\n\tif (assembly != NULL){\n\t\tfor (i = 0; i < na; ++i) {\n\t\t\tMonoReflectionType *type = mono_array_get (sig->arguments, MonoReflectionType*, i);\n\t\t\tencode_reflection_type (assembly, type, &buf);\n\t\t}\n\t}\n\n\tbuflen = buf.p - buf.buf;\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, buflen);\n\tmemcpy (mono_array_addr (result, char, 0), buf.buf, buflen);\n\tsigbuffer_free (&buf);\n\n\treturn result;\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_field (MonoReflectionSigHelper *sig)\n{\n\tMonoDynamicImage *assembly = sig->module->dynamic_image;\n\tguint32 na = sig->arguments ? mono_array_length (sig->arguments) : 0;\n\tguint32 buflen, i;\n\tMonoArray *result;\n\tSigBuffer buf;\n\n\tcheck_array_for_usertypes (sig->arguments);\n\n\tsigbuffer_init (&buf, 32);\n\n\tsigbuffer_add_value (&buf, 0x06);\n\tfor (i = 0; i < na; ++i) {\n\t\tMonoReflectionType *type = mono_array_get (sig->arguments, MonoReflectionType*, i);\n\t\tencode_reflection_type (assembly, type, &buf);\n\t}\n\n\tbuflen = buf.p - buf.buf;\n\tresult = mono_array_new (mono_domain_get (), mono_defaults.byte_class, buflen);\n\tmemcpy (mono_array_addr (result, char, 0), buf.buf, buflen);\n\tsigbuffer_free (&buf);\n\n\treturn result;\n}\n\ntypedef struct {\n\tMonoMethod *handle;\n\tMonoDomain *domain;\n} DynamicMethodReleaseData;\n\t\nstatic MonoReferenceQueue *dynamic_method_queue;\n\nvoid\nmono_reflection_shutdown (void)\n{\n\tMonoReferenceQueue *queue;\n\tmono_loader_lock ();\n\tqueue = dynamic_method_queue;\n\tdynamic_method_queue = NULL;\n\tif (queue)\n\t\tmono_gc_reference_queue_free (queue);\n\tmono_loader_unlock ();\n}\n\nstatic void\nfree_dynamic_method (void *dynamic_method)\n{\n\tDynamicMethodReleaseData *data = dynamic_method;\n\n\tmono_runtime_free_method (data->domain, data->handle);\n\tg_free (data);\n}\n\nvoid \nmono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tMonoReferenceQueue *queue;\n\tMonoMethod *handle;\n\tDynamicMethodReleaseData *release_data;\n\tReflectionMethodBuilder rmb;\n\tMonoMethodSignature *sig;\n\tMonoClass *klass;\n\tGSList *l;\n\tint i;\n\n\tif (mono_runtime_is_shutting_down ())\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\"\"));\n\n\tif (!(queue = dynamic_method_queue)) {\n\t\tmono_loader_lock ();\n\t\tif (!(queue = dynamic_method_queue))\n\t\t\tqueue = dynamic_method_queue = mono_gc_reference_queue_new (free_dynamic_method);\n\t\tmono_loader_unlock ();\n\t}\n\n\tsig = dynamic_method_to_signature (mb);\n\n\treflection_methodbuilder_from_dynamic_method (&rmb, mb);\n\n\t/*\n\t * Resolve references.\n\t */\n\t/* \n\t * Every second entry in the refs array is reserved for storing handle_class,\n\t * which is needed by the ldtoken implementation in the JIT.\n\t */\n\trmb.nrefs = mb->nrefs;\n\trmb.refs = g_new0 (gpointer, mb->nrefs + 1);\n\tfor (i = 0; i < mb->nrefs; i += 2) {\n\t\tMonoClass *handle_class;\n\t\tgpointer ref;\n\t\tMonoObject *obj = mono_array_get (mb->refs, MonoObject*, i);\n\n\t\tif (strcmp (obj->vtable->klass->name, \"DynamicMethod\") == 0) {\n\t\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)obj;\n\t\t\t/*\n\t\t\t * The referenced DynamicMethod should already be created by the managed\n\t\t\t * code, except in the case of circular references. In that case, we store\n\t\t\t * method in the refs array, and fix it up later when the referenced \n\t\t\t * DynamicMethod is created.\n\t\t\t */\n\t\t\tif (method->mhandle) {\n\t\t\t\tref = method->mhandle;\n\t\t\t} else {\n\t\t\t\t/* FIXME: GC object stored in unmanaged memory */\n\t\t\t\tref = method;\n\n\t\t\t\t/* FIXME: GC object stored in unmanaged memory */\n\t\t\t\tmethod->referenced_by = g_slist_append (method->referenced_by, mb);\n\t\t\t}\n\t\t\thandle_class = mono_defaults.methodhandle_class;\n\t\t} else {\n\t\t\tMonoException *ex = NULL;\n\t\t\tref = resolve_object (mb->module->image, obj, &handle_class, NULL);\n\t\t\tif (!ref)\n\t\t\t\tex = mono_get_exception_type_load (NULL, NULL);\n\t\t\telse if (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR)\n\t\t\t\tex = mono_security_core_clr_ensure_dynamic_method_resolved_object (ref, handle_class);\n\n\t\t\tif (ex) {\n\t\t\t\tg_free (rmb.refs);\n\t\t\t\tmono_raise_exception (ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\trmb.refs [i] = ref; /* FIXME: GC object stored in unmanaged memory (change also resolve_object() signature) */\n\t\trmb.refs [i + 1] = handle_class;\n\t}\t\t\n\n\tklass = mb->owner ? mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)mb->owner)) : mono_defaults.object_class;\n\n\tmb->mhandle = handle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n\trelease_data = g_new (DynamicMethodReleaseData, 1);\n\trelease_data->handle = handle;\n\trelease_data->domain = mono_object_get_domain ((MonoObject*)mb);\n\tif (!mono_gc_reference_queue_add (queue, (MonoObject*)mb, release_data))\n\t\tg_free (release_data);\n\n\t/* Fix up refs entries pointing at us */\n\tfor (l = mb->referenced_by; l; l = l->next) {\n\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)l->data;\n\t\tMonoMethodWrapper *wrapper = (MonoMethodWrapper*)method->mhandle;\n\t\tgpointer *data;\n\t\t\n\t\tg_assert (method->mhandle);\n\n\t\tdata = (gpointer*)wrapper->method_data;\n\t\tfor (i = 0; i < GPOINTER_TO_UINT (data [0]); i += 2) {\n\t\t\tif ((data [i + 1] == mb) && (data [i + 1 + 1] == mono_defaults.methodhandle_class))\n\t\t\t\tdata [i + 1] = mb->mhandle;\n\t\t}\n\t}\n\tg_slist_free (mb->referenced_by);\n\n\tg_free (rmb.refs);\n\n\t/* ilgen is no longer needed */\n\tmb->ilgen = NULL;\n}\n\n#endif /* DISABLE_REFLECTION_EMIT */\n\n/**\n * \n * mono_reflection_is_valid_dynamic_token:\n * \n * Returns TRUE if token is valid.\n * \n */\ngboolean\nmono_reflection_is_valid_dynamic_token (MonoDynamicImage *image, guint32 token)\n{\n\treturn mono_g_hash_table_lookup (image->tokens, GUINT_TO_POINTER (token)) != NULL;\n}\n\n#ifndef DISABLE_REFLECTION_EMIT\n\n/**\n * mono_reflection_lookup_dynamic_token:\n *\n * Finish the Builder object pointed to by TOKEN and return the corresponding\n * runtime structure. If HANDLE_CLASS is not NULL, it is set to the class required by \n * mono_ldtoken. If valid_token is TRUE, assert if it is not found in the token->object\n * mapping table.\n *\n * LOCKING: Take the loader lock\n */\ngpointer\nmono_reflection_lookup_dynamic_token (MonoImage *image, guint32 token, gboolean valid_token, MonoClass **handle_class, MonoGenericContext *context)\n{\n\tMonoDynamicImage *assembly = (MonoDynamicImage*)image;\n\tMonoObject *obj;\n\tMonoClass *klass;\n\n\tmono_loader_lock ();\n\tobj = mono_g_hash_table_lookup (assembly->tokens, GUINT_TO_POINTER (token));\n\tmono_loader_unlock ();\n\tif (!obj) {\n\t\tif (valid_token)\n\t\t\tg_error (\"Could not find required dynamic token 0x%08x\", token);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tif (!handle_class)\n\t\thandle_class = &klass;\n\treturn resolve_object (image, obj, handle_class, context);\n}\n\n/*\n * ensure_complete_type:\n *\n *   Ensure that KLASS is completed if it is a dynamic type, or references\n * dynamic types.\n */\nstatic void\nensure_complete_type (MonoClass *klass)\n{\n\tif (klass->image->dynamic && !klass->wastypebuilder) {\n\t\tMonoReflectionTypeBuilder *tb = klass->reflection_info;\n\n\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\n\t\t// Asserting here could break a lot of code\n\t\t//g_assert (klass->wastypebuilder);\n\t}\n\n\tif (klass->generic_class) {\n\t\tMonoGenericInst *inst = klass->generic_class->context.class_inst;\n\t\tint i;\n\n\t\tfor (i = 0; i < inst->type_argc; ++i) {\n\t\t\tensure_complete_type (mono_class_from_mono_type (inst->type_argv [i]));\n\t\t}\n\t}\n}\n\nstatic gpointer\nresolve_object (MonoImage *image, MonoObject *obj, MonoClass **handle_class, MonoGenericContext *context)\n{\n\tgpointer result = NULL;\n\n\tif (strcmp (obj->vtable->klass->name, \"String\") == 0) {\n\t\tresult = mono_string_intern ((MonoString*)obj);\n\t\t*handle_class = mono_defaults.string_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoType\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)obj);\n\t\tif (context) {\n\t\t\tMonoType *inflated = mono_class_inflate_generic_type (type, context);\n\t\t\tresult = mono_class_from_mono_type (inflated);\n\t\t\tmono_metadata_free_type (inflated);\n\t\t} else {\n\t\t\tresult = mono_class_from_mono_type (type);\n\t\t}\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoMethod\") == 0 ||\n\t\t   strcmp (obj->vtable->klass->name, \"MonoCMethod\") == 0 ||\n\t\t   strcmp (obj->vtable->klass->name, \"MonoGenericCMethod\") == 0 ||\n\t\t   strcmp (obj->vtable->klass->name, \"MonoGenericMethod\") == 0) {\n\t\tresult = ((MonoReflectionMethod*)obj)->method;\n\t\tif (context)\n\t\t\tresult = mono_class_inflate_generic_method (result, context);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"MethodBuilder\") == 0) {\n\t\tMonoReflectionMethodBuilder *mb = (MonoReflectionMethodBuilder*)obj;\n\t\tresult = mb->mhandle;\n\t\tif (!result) {\n\t\t\t/* Type is not yet created */\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)mb->type;\n\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\n\t\t\t/*\n\t\t\t * Hopefully this has been filled in by calling CreateType() on the\n\t\t\t * TypeBuilder.\n\t\t\t */\n\t\t\t/*\n\t\t\t * TODO: This won't work if the application finishes another \n\t\t\t * TypeBuilder instance instead of this one.\n\t\t\t */\n\t\t\tresult = mb->mhandle;\n\t\t}\n\t\tif (context)\n\t\t\tresult = mono_class_inflate_generic_method (result, context);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"ConstructorBuilder\") == 0) {\n\t\tMonoReflectionCtorBuilder *cb = (MonoReflectionCtorBuilder*)obj;\n\n\t\tresult = cb->mhandle;\n\t\tif (!result) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)cb->type;\n\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\t\t\tresult = cb->mhandle;\n\t\t}\n\t\tif (context)\n\t\t\tresult = mono_class_inflate_generic_method (result, context);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoField\") == 0) {\n\t\tMonoClassField *field = ((MonoReflectionField*)obj)->field;\n\n\t\tensure_complete_type (field->parent);\n\t\tif (context) {\n\t\t\tMonoType *inflated = mono_class_inflate_generic_type (&field->parent->byval_arg, context);\n\t\t\tMonoClass *class = mono_class_from_mono_type (inflated);\n\t\t\tMonoClassField *inflated_field;\n\t\t\tgpointer iter = NULL;\n\t\t\tmono_metadata_free_type (inflated);\n\t\t\twhile ((inflated_field = mono_class_get_fields (class, &iter))) {\n\t\t\t\tif (!strcmp (field->name, inflated_field->name))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tg_assert (inflated_field && !strcmp (field->name, inflated_field->name));\n\t\t\tresult = inflated_field;\n\t\t} else {\n\t\t\tresult = field;\n\t\t}\n\t\t*handle_class = mono_defaults.fieldhandle_class;\n\t\tg_assert (result);\n\t} else if (strcmp (obj->vtable->klass->name, \"FieldBuilder\") == 0) {\n\t\tMonoReflectionFieldBuilder *fb = (MonoReflectionFieldBuilder*)obj;\n\t\tresult = fb->handle;\n\n\t\tif (!result) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)fb->typeb;\n\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\t\t\tresult = fb->handle;\n\t\t}\n\n\t\tif (fb->handle && fb->handle->parent->generic_container) {\n\t\t\tMonoClass *klass = fb->handle->parent;\n\t\t\tMonoType *type = mono_class_inflate_generic_type (&klass->byval_arg, context);\n\t\t\tMonoClass *inflated = mono_class_from_mono_type (type);\n\n\t\t\tresult = mono_class_get_field_from_name (inflated, mono_field_get_name (fb->handle));\n\t\t\tg_assert (result);\n\t\t\tmono_metadata_free_type (type);\n\t\t}\n\t\t*handle_class = mono_defaults.fieldhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"TypeBuilder\") == 0) {\n\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder*)obj;\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)tb); \n\t\tMonoClass *klass;\n\n\t\tklass = type->data.klass;\n\t\tif (klass->wastypebuilder) {\n\t\t\t/* Already created */\n\t\t\tresult = klass;\n\t\t}\n\t\telse {\n\t\t\tmono_domain_try_type_resolve (mono_domain_get (), NULL, (MonoObject*)tb);\n\t\t\tresult = type->data.klass;\n\t\t\tg_assert (result);\n\t\t}\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"SignatureHelper\") == 0) {\n\t\tMonoReflectionSigHelper *helper = (MonoReflectionSigHelper*)obj;\n\t\tMonoMethodSignature *sig;\n\t\tint nargs, i;\n\n\t\tif (helper->arguments)\n\t\t\tnargs = mono_array_length (helper->arguments);\n\t\telse\n\t\t\tnargs = 0;\n\n\t\tsig = mono_metadata_signature_alloc (image, nargs);\n\t\tsig->explicit_this = helper->call_conv & 64 ? 1 : 0;\n\t\tsig->hasthis = helper->call_conv & 32 ? 1 : 0;\n\n\t\tif (helper->unmanaged_call_conv) { /* unmanaged */\n\t\t\tsig->call_convention = helper->unmanaged_call_conv - 1;\n\t\t\tsig->pinvoke = TRUE;\n\t\t} else if (helper->call_conv & 0x02) {\n\t\t\tsig->call_convention = MONO_CALL_VARARG;\n\t\t} else {\n\t\t\tsig->call_convention = MONO_CALL_DEFAULT;\n\t\t}\n\n\t\tsig->param_count = nargs;\n\t\t/* TODO: Copy type ? */\n\t\tsig->ret = helper->return_type->type;\n\t\tfor (i = 0; i < nargs; ++i)\n\t\t\tsig->params [i] = mono_type_array_get_and_resolve (helper->arguments, i);\n\n\t\tresult = sig;\n\t\t*handle_class = NULL;\n\t} else if (strcmp (obj->vtable->klass->name, \"DynamicMethod\") == 0) {\n\t\tMonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)obj;\n\t\t/* Already created by the managed code */\n\t\tg_assert (method->mhandle);\n\t\tresult = method->mhandle;\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"GenericTypeParameterBuilder\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)obj);\n\t\ttype = mono_class_inflate_generic_type (type, context);\n\t\tresult = mono_class_from_mono_type (type);\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t\tg_assert (result);\n\t\tmono_metadata_free_type (type);\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoGenericClass\") == 0) {\n\t\tMonoType *type = mono_reflection_type_get_handle ((MonoReflectionType*)obj);\n\t\ttype = mono_class_inflate_generic_type (type, context);\n\t\tresult = mono_class_from_mono_type (type);\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t\tg_assert (result);\n\t\tmono_metadata_free_type (type);\n\t} else if (strcmp (obj->vtable->klass->name, \"FieldOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionFieldOnTypeBuilderInst *f = (MonoReflectionFieldOnTypeBuilderInst*)obj;\n\t\tMonoClass *inflated;\n\t\tMonoType *type;\n\n\t\ttype = mono_class_inflate_generic_type (mono_reflection_type_get_handle ((MonoReflectionType*)f->inst), context);\n\t\tinflated = mono_class_from_mono_type (type);\n\n\t\tg_assert (f->fb->handle);\n\t\tresult = mono_class_get_field_from_name (inflated, mono_field_get_name (f->fb->handle));\n\t\tg_assert (result);\n\t\tmono_metadata_free_type (type);\n\t\t*handle_class = mono_defaults.fieldhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"ConstructorOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionCtorOnTypeBuilderInst *c = (MonoReflectionCtorOnTypeBuilderInst*)obj;\n\t\tMonoType *type = mono_class_inflate_generic_type (mono_reflection_type_get_handle ((MonoReflectionType*)c->inst), context);\n\t\tMonoClass *inflated_klass = mono_class_from_mono_type (type);\n\t\tg_assert (c->cb->mhandle);\n\t\tresult = inflate_mono_method (inflated_klass, c->cb->mhandle, (MonoObject*)c->cb);\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t\tmono_metadata_free_type (type);\n\t} else if (strcmp (obj->vtable->klass->name, \"MethodOnTypeBuilderInst\") == 0) {\n\t\tMonoReflectionMethodOnTypeBuilderInst *m = (MonoReflectionMethodOnTypeBuilderInst*)obj;\n\t\tif (m->method_args) {\n\t\t\tresult = mono_reflection_method_on_tb_inst_get_handle (m);\n\t\t} else {\n\t\t\tMonoType *type = mono_class_inflate_generic_type (mono_reflection_type_get_handle ((MonoReflectionType*)m->inst), context);\n\t\t\tMonoClass *inflated_klass = mono_class_from_mono_type (type);\n\t\t\tg_assert (m->mb->mhandle);\n\t\t\tresult = inflate_mono_method (inflated_klass, m->mb->mhandle, (MonoObject*)m->mb);\n\t\t\tmono_metadata_free_type (type);\n\t\t}\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (strcmp (obj->vtable->klass->name, \"MonoArrayMethod\") == 0) {\n\t\tMonoReflectionArrayMethod *m = (MonoReflectionArrayMethod*)obj;\n\t\tMonoType *mtype;\n\t\tMonoClass *klass;\n\t\tMonoMethod *method;\n\t\tgpointer iter;\n\t\tchar *name;\n\n\t\tmtype = mono_reflection_type_get_handle (m->parent);\n\t\tklass = mono_class_from_mono_type (mtype);\n\n\t\t/* Find the method */\n\n\t\tname = mono_string_to_utf8 (m->name);\n\t\titer = NULL;\n\t\twhile ((method = mono_class_get_methods (klass, &iter))) {\n\t\t\tif (!strcmp (method->name, name))\n\t\t\t\tbreak;\n\t\t}\n\t\tg_free (name);\n\n\t\t// FIXME:\n\t\tg_assert (method);\n\t\t// FIXME: Check parameters/return value etc. match\n\n\t\tresult = method;\n\t\t*handle_class = mono_defaults.methodhandle_class;\n\t} else if (is_sre_array (mono_object_get_class(obj)) ||\n\t\t\t\tis_sre_byref (mono_object_get_class(obj)) ||\n\t\t\t\tis_sre_pointer (mono_object_get_class(obj))) {\n\t\tMonoReflectionType *ref_type = (MonoReflectionType *)obj;\n\t\tMonoType *type = mono_reflection_type_get_handle (ref_type);\n\t\tresult = mono_class_from_mono_type (type);\n\t\t*handle_class = mono_defaults.typehandle_class;\n\t} else {\n\t\tg_print (\"%s\\n\", obj->vtable->klass->name);\n\t\tg_assert_not_reached ();\n\t}\n\treturn result;\n}\n\n#else /* DISABLE_REFLECTION_EMIT */\n\nMonoArray*\nmono_reflection_get_custom_attrs_blob (MonoReflectionAssembly *assembly, MonoObject *ctor, MonoArray *ctorArgs, MonoArray *properties, MonoArray *propValues, MonoArray *fields, MonoArray* fieldValues) \n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid\nmono_reflection_setup_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_setup_generic_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_create_generic_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_create_internal_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_image_basic_init (MonoReflectionAssemblyBuilder *assemblyb)\n{\n\tg_error (\"This mono runtime was configured with --enable-minimal=reflection_emit, so System.Reflection.Emit is not supported.\");\n}\n\nvoid\nmono_image_module_basic_init (MonoReflectionModuleBuilder *moduleb)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_image_set_wrappers_type (MonoReflectionModuleBuilder *moduleb, MonoReflectionType *type)\n{\n\tg_assert_not_reached ();\n}\n\nMonoReflectionModule *\nmono_image_load_module_dynamic (MonoReflectionAssemblyBuilder *ab, MonoString *fileName)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nguint32\nmono_image_insert_string (MonoReflectionModuleBuilder *module, MonoString *str)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nguint32\nmono_image_create_method_token (MonoDynamicImage *assembly, MonoObject *obj, MonoArray *opt_param_types)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nguint32\nmono_image_create_token (MonoDynamicImage *assembly, MonoObject *obj, \n\t\t\t\t\t\t gboolean create_methodspec, gboolean register_token)\n{\n\tg_assert_not_reached ();\n\treturn 0;\n}\n\nvoid\nmono_image_register_token (MonoDynamicImage *assembly, guint32 token, MonoObject *obj)\n{\n}\n\nvoid\nmono_reflection_generic_class_initialize (MonoReflectionGenericClass *type, MonoArray *methods, \n\t\t\t\t\t  MonoArray *ctors, MonoArray *fields, MonoArray *properties,\n\t\t\t\t\t  MonoArray *events)\n{\n\tg_assert_not_reached ();\n}\n\nvoid\nmono_reflection_get_dynamic_overrides (MonoClass *klass, MonoMethod ***overrides, int *num_overrides)\n{\n\t*overrides = NULL;\n\t*num_overrides = 0;\n}\n\nMonoReflectionEvent *\nmono_reflection_event_builder_get_event_info (MonoReflectionTypeBuilder *tb, MonoReflectionEventBuilder *eb)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nMonoReflectionType*\nmono_reflection_create_runtime_class (MonoReflectionTypeBuilder *tb)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid\nmono_reflection_initialize_generic_parameter (MonoReflectionGenericParam *gparam)\n{\n\tg_assert_not_reached ();\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_local (MonoReflectionSigHelper *sig)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nMonoArray *\nmono_reflection_sighelper_get_signature_field (MonoReflectionSigHelper *sig)\n{\n\tg_assert_not_reached ();\n\treturn NULL;\n}\n\nvoid \nmono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n}\n\ngpointer\nmono_reflection_lookup_dynamic_token (MonoImage *image, guint32 token, gboolean valid_token, MonoClass **handle_class, MonoGenericContext *context)\n{\n\treturn NULL;\n}\n\nMonoType*\nmono_reflection_type_get_handle (MonoReflectionType* ref)\n{\n\tif (!ref)\n\t\treturn NULL;\n\treturn ref->type;\n}\n\n#endif /* DISABLE_REFLECTION_EMIT */\n\n/* SECURITY_ACTION_* are defined in mono/metadata/tabledefs.h */\nconst static guint32 declsec_flags_map[] = {\n\t0x00000000,\t\t\t\t\t/* empty */\n\tMONO_DECLSEC_FLAG_REQUEST,\t\t\t/* SECURITY_ACTION_REQUEST\t\t\t(x01) */\n\tMONO_DECLSEC_FLAG_DEMAND,\t\t\t/* SECURITY_ACTION_DEMAND\t\t\t(x02) */\n\tMONO_DECLSEC_FLAG_ASSERT,\t\t\t/* SECURITY_ACTION_ASSERT\t\t\t(x03) */\n\tMONO_DECLSEC_FLAG_DENY,\t\t\t\t/* SECURITY_ACTION_DENY\t\t\t\t(x04) */\n\tMONO_DECLSEC_FLAG_PERMITONLY,\t\t\t/* SECURITY_ACTION_PERMITONLY\t\t\t(x05) */\n\tMONO_DECLSEC_FLAG_LINKDEMAND,\t\t\t/* SECURITY_ACTION_LINKDEMAND\t\t\t(x06) */\n\tMONO_DECLSEC_FLAG_INHERITANCEDEMAND,\t\t/* SECURITY_ACTION_INHERITANCEDEMAND\t\t(x07) */\n\tMONO_DECLSEC_FLAG_REQUEST_MINIMUM,\t\t/* SECURITY_ACTION_REQUEST_MINIMUM\t\t(x08) */\n\tMONO_DECLSEC_FLAG_REQUEST_OPTIONAL,\t\t/* SECURITY_ACTION_REQUEST_OPTIONAL\t\t(x09) */\n\tMONO_DECLSEC_FLAG_REQUEST_REFUSE,\t\t/* SECURITY_ACTION_REQUEST_REFUSE\t\t(x0A) */\n\tMONO_DECLSEC_FLAG_PREJIT_GRANT,\t\t\t/* SECURITY_ACTION_PREJIT_GRANT\t\t\t(x0B) */\n\tMONO_DECLSEC_FLAG_PREJIT_DENY,\t\t\t/* SECURITY_ACTION_PREJIT_DENY\t\t\t(x0C) */\n\tMONO_DECLSEC_FLAG_NONCAS_DEMAND,\t\t/* SECURITY_ACTION_NONCAS_DEMAND\t\t(x0D) */\n\tMONO_DECLSEC_FLAG_NONCAS_LINKDEMAND,\t\t/* SECURITY_ACTION_NONCAS_LINKDEMAND\t\t(x0E) */\n\tMONO_DECLSEC_FLAG_NONCAS_INHERITANCEDEMAND,\t/* SECURITY_ACTION_NONCAS_INHERITANCEDEMAND\t(x0F) */\n\tMONO_DECLSEC_FLAG_LINKDEMAND_CHOICE,\t\t/* SECURITY_ACTION_LINKDEMAND_CHOICE\t\t(x10) */\n\tMONO_DECLSEC_FLAG_INHERITANCEDEMAND_CHOICE,\t/* SECURITY_ACTION_INHERITANCEDEMAND_CHOICE\t(x11) */\n\tMONO_DECLSEC_FLAG_DEMAND_CHOICE,\t\t/* SECURITY_ACTION_DEMAND_CHOICE\t\t(x12) */\n};\n\n/*\n * Returns flags that includes all available security action associated to the handle.\n * @token: metadata token (either for a class or a method)\n * @image: image where resides the metadata.\n */\nstatic guint32\nmono_declsec_get_flags (MonoImage *image, guint32 token)\n{\n\tint index = mono_metadata_declsec_from_index (image, token);\n\tMonoTableInfo *t = &image->tables [MONO_TABLE_DECLSECURITY];\n\tguint32 result = 0;\n\tguint32 action;\n\tint i;\n\n\t/* HasSecurity can be present for other, not specially encoded, attributes,\n\t   e.g. SuppressUnmanagedCodeSecurityAttribute */\n\tif (index < 0)\n\t\treturn 0;\n\n\tfor (i = index; i < t->rows; i++) {\n\t\tguint32 cols [MONO_DECL_SECURITY_SIZE];\n\n\t\tmono_metadata_decode_row (t, i, cols, MONO_DECL_SECURITY_SIZE);\n\t\tif (cols [MONO_DECL_SECURITY_PARENT] != token)\n\t\t\tbreak;\n\n\t\taction = cols [MONO_DECL_SECURITY_ACTION];\n\t\tif ((action >= MONO_DECLSEC_ACTION_MIN) && (action <= MONO_DECLSEC_ACTION_MAX)) {\n\t\t\tresult |= declsec_flags_map [action];\n\t\t} else {\n\t\t\tg_assert_not_reached ();\n\t\t}\n\t}\n\treturn result;\n}\n\n/*\n * Get the security actions (in the form of flags) associated with the specified method.\n *\n * @method: The method for which we want the declarative security flags.\n * Return the declarative security flags for the method (only).\n *\n * Note: To keep MonoMethod size down we do not cache the declarative security flags\n *       (except for the stack modifiers which are kept in the MonoJitInfo structure)\n */\nguint32\nmono_declsec_flags_from_method (MonoMethod *method)\n{\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\t/* FIXME: No cache (for the moment) */\n\t\tguint32 idx = mono_method_get_index (method);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\t\treturn mono_declsec_get_flags (method->klass->image, idx);\n\t}\n\treturn 0;\n}\n\n/*\n * Get the security actions (in the form of flags) associated with the specified class.\n *\n * @klass: The class for which we want the declarative security flags.\n * Return the declarative security flags for the class.\n *\n * Note: We cache the flags inside the MonoClass structure as this will get \n *       called very often (at least for each method).\n */\nguint32\nmono_declsec_flags_from_class (MonoClass *klass)\n{\n\tif (klass->flags & TYPE_ATTRIBUTE_HAS_SECURITY) {\n\t\tif (!klass->ext || !klass->ext->declsec_flags) {\n\t\t\tguint32 idx;\n\n\t\t\tidx = mono_metadata_token_index (klass->type_token);\n\t\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\t\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\t\t\tmono_loader_lock ();\n\t\t\tmono_class_alloc_ext (klass);\n\t\t\tmono_loader_unlock ();\n\t\t\t/* we cache the flags on classes */\n\t\t\tklass->ext->declsec_flags = mono_declsec_get_flags (klass->image, idx);\n\t\t}\n\t\treturn klass->ext->declsec_flags;\n\t}\n\treturn 0;\n}\n\n/*\n * Get the security actions (in the form of flags) associated with the specified assembly.\n *\n * @assembly: The assembly for which we want the declarative security flags.\n * Return the declarative security flags for the assembly.\n */\nguint32\nmono_declsec_flags_from_assembly (MonoAssembly *assembly)\n{\n\tguint32 idx = 1; /* there is only one assembly */\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_ASSEMBLY;\n\treturn mono_declsec_get_flags (assembly->image, idx);\n}\n\n\n/*\n * Fill actions for the specific index (which may either be an encoded class token or\n * an encoded method token) from the metadata image.\n * Returns TRUE if some actions requiring code generation are present, FALSE otherwise.\n */\nstatic MonoBoolean\nfill_actions_from_index (MonoImage *image, guint32 token, MonoDeclSecurityActions* actions,\n\tguint32 id_std, guint32 id_noncas, guint32 id_choice)\n{\n\tMonoBoolean result = FALSE;\n\tMonoTableInfo *t;\n\tguint32 cols [MONO_DECL_SECURITY_SIZE];\n\tint index = mono_metadata_declsec_from_index (image, token);\n\tint i;\n\n\tt  = &image->tables [MONO_TABLE_DECLSECURITY];\n\tfor (i = index; i < t->rows; i++) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_DECL_SECURITY_SIZE);\n\n\t\tif (cols [MONO_DECL_SECURITY_PARENT] != token)\n\t\t\treturn result;\n\n\t\t/* if present only replace (class) permissions with method permissions */\n\t\t/* if empty accept either class or method permissions */\n\t\tif (cols [MONO_DECL_SECURITY_ACTION] == id_std) {\n\t\t\tif (!actions->demand.blob) {\n\t\t\t\tconst char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\t\tactions->demand.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];\n\t\t\t\tactions->demand.blob = (char*) (blob + 2);\n\t\t\t\tactions->demand.size = mono_metadata_decode_blob_size (blob, &blob);\n\t\t\t\tresult = TRUE;\n\t\t\t}\n\t\t} else if (cols [MONO_DECL_SECURITY_ACTION] == id_noncas) {\n\t\t\tif (!actions->noncasdemand.blob) {\n\t\t\t\tconst char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\t\tactions->noncasdemand.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];\n\t\t\t\tactions->noncasdemand.blob = (char*) (blob + 2);\n\t\t\t\tactions->noncasdemand.size = mono_metadata_decode_blob_size (blob, &blob);\n\t\t\t\tresult = TRUE;\n\t\t\t}\n\t\t} else if (cols [MONO_DECL_SECURITY_ACTION] == id_choice) {\n\t\t\tif (!actions->demandchoice.blob) {\n\t\t\t\tconst char *blob = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\t\tactions->demandchoice.index = cols [MONO_DECL_SECURITY_PERMISSIONSET];\n\t\t\t\tactions->demandchoice.blob = (char*) (blob + 2);\n\t\t\t\tactions->demandchoice.size = mono_metadata_decode_blob_size (blob, &blob);\n\t\t\t\tresult = TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic MonoBoolean\nmono_declsec_get_class_demands_params (MonoClass *klass, MonoDeclSecurityActions* demands, \n\tguint32 id_std, guint32 id_noncas, guint32 id_choice)\n{\n\tguint32 idx = mono_metadata_token_index (klass->type_token);\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\treturn fill_actions_from_index (klass->image, idx, demands, id_std, id_noncas, id_choice);\n}\n\nstatic MonoBoolean\nmono_declsec_get_method_demands_params (MonoMethod *method, MonoDeclSecurityActions* demands, \n\tguint32 id_std, guint32 id_noncas, guint32 id_choice)\n{\n\tguint32 idx = mono_method_get_index (method);\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\treturn fill_actions_from_index (method->klass->image, idx, demands, id_std, id_noncas, id_choice);\n}\n\n/*\n * Collect all actions (that requires to generate code in mini) assigned for\n * the specified method.\n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_demands (MonoMethod *method, MonoDeclSecurityActions* demands)\n{\n\tguint32 mask = MONO_DECLSEC_FLAG_DEMAND | MONO_DECLSEC_FLAG_NONCAS_DEMAND | \n\t\tMONO_DECLSEC_FLAG_DEMAND_CHOICE;\n\tMonoBoolean result = FALSE;\n\tguint32 flags;\n\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* we want the original as the wrapper is \"free\" of the security informations */\n\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE || method->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\tmethod = mono_marshal_method_from_wrapper (method);\n\t\tif (!method)\n\t\t\treturn FALSE;\n\t}\n\n\t/* First we look for method-level attributes */\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tmono_class_init (method->klass);\n\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\n\t\tresult = mono_declsec_get_method_demands_params (method, demands, \n\t\t\tSECURITY_ACTION_DEMAND, SECURITY_ACTION_NONCASDEMAND, SECURITY_ACTION_DEMANDCHOICE);\n\t}\n\n\t/* Here we use (or create) the class declarative cache to look for demands */\n\tflags = mono_declsec_flags_from_class (method->klass);\n\tif (flags & mask) {\n\t\tif (!result) {\n\t\t\tmono_class_init (method->klass);\n\t\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\t\t}\n\t\tresult |= mono_declsec_get_class_demands_params (method->klass, demands, \n\t\t\tSECURITY_ACTION_DEMAND, SECURITY_ACTION_NONCASDEMAND, SECURITY_ACTION_DEMANDCHOICE);\n\t}\n\n\t/* The boolean return value is used as a shortcut in case nothing needs to\n\t   be generated (e.g. LinkDemand[Choice] and InheritanceDemand[Choice]) */\n\treturn result;\n}\n\n\n/*\n * Collect all Link actions: LinkDemand, NonCasLinkDemand and LinkDemandChoice (2.0).\n *\n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_linkdemands (MonoMethod *method, MonoDeclSecurityActions* klass, MonoDeclSecurityActions *cmethod)\n{\n\tMonoBoolean result = FALSE;\n\tguint32 flags;\n\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* we want the original as the wrapper is \"free\" of the security informations */\n\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE || method->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\tmethod = mono_marshal_method_from_wrapper (method);\n\t\tif (!method)\n\t\t\treturn FALSE;\n\t}\n\n\t/* results are independant - zeroize both */\n\tmemset (cmethod, 0, sizeof (MonoDeclSecurityActions));\n\tmemset (klass, 0, sizeof (MonoDeclSecurityActions));\n\n\t/* First we look for method-level attributes */\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tmono_class_init (method->klass);\n\n\t\tresult = mono_declsec_get_method_demands_params (method, cmethod, \n\t\t\tSECURITY_ACTION_LINKDEMAND, SECURITY_ACTION_NONCASLINKDEMAND, SECURITY_ACTION_LINKDEMANDCHOICE);\n\t}\n\n\t/* Here we use (or create) the class declarative cache to look for demands */\n\tflags = mono_declsec_flags_from_class (method->klass);\n\tif (flags & (MONO_DECLSEC_FLAG_LINKDEMAND | MONO_DECLSEC_FLAG_NONCAS_LINKDEMAND | MONO_DECLSEC_FLAG_LINKDEMAND_CHOICE)) {\n\t\tmono_class_init (method->klass);\n\n\t\tresult |= mono_declsec_get_class_demands_params (method->klass, klass, \n\t\t\tSECURITY_ACTION_LINKDEMAND, SECURITY_ACTION_NONCASLINKDEMAND, SECURITY_ACTION_LINKDEMANDCHOICE);\n\t}\n\n\treturn result;\n}\n\n/*\n * Collect all Inherit actions: InheritanceDemand, NonCasInheritanceDemand and InheritanceDemandChoice (2.0).\n *\n * @klass\tThe inherited class - this is the class that provides the security check (attributes)\n * @demans\t\n * return TRUE if inheritance demands (any kind) are present, FALSE otherwise.\n * \n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_inheritdemands_class (MonoClass *klass, MonoDeclSecurityActions* demands)\n{\n\tMonoBoolean result = FALSE;\n\tguint32 flags;\n\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* Here we use (or create) the class declarative cache to look for demands */\n\tflags = mono_declsec_flags_from_class (klass);\n\tif (flags & (MONO_DECLSEC_FLAG_INHERITANCEDEMAND | MONO_DECLSEC_FLAG_NONCAS_INHERITANCEDEMAND | MONO_DECLSEC_FLAG_INHERITANCEDEMAND_CHOICE)) {\n\t\tmono_class_init (klass);\n\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\n\t\tresult |= mono_declsec_get_class_demands_params (klass, demands, \n\t\t\tSECURITY_ACTION_INHERITDEMAND, SECURITY_ACTION_NONCASINHERITANCE, SECURITY_ACTION_INHERITDEMANDCHOICE);\n\t}\n\n\treturn result;\n}\n\n/*\n * Collect all Inherit actions: InheritanceDemand, NonCasInheritanceDemand and InheritanceDemandChoice (2.0).\n *\n * Note: Don't use the content of actions if the function return FALSE.\n */\nMonoBoolean\nmono_declsec_get_inheritdemands_method (MonoMethod *method, MonoDeclSecurityActions* demands)\n{\n\t/* quick exit if no declarative security is present in the metadata */\n\tif (!method->klass->image->tables [MONO_TABLE_DECLSECURITY].rows)\n\t\treturn FALSE;\n\n\t/* we want the original as the wrapper is \"free\" of the security informations */\n\tif (method->wrapper_type == MONO_WRAPPER_MANAGED_TO_NATIVE || method->wrapper_type == MONO_WRAPPER_MANAGED_TO_MANAGED) {\n\t\tmethod = mono_marshal_method_from_wrapper (method);\n\t\tif (!method)\n\t\t\treturn FALSE;\n\t}\n\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tmono_class_init (method->klass);\n\t\tmemset (demands, 0, sizeof (MonoDeclSecurityActions));\n\n\t\treturn mono_declsec_get_method_demands_params (method, demands, \n\t\t\tSECURITY_ACTION_INHERITDEMAND, SECURITY_ACTION_NONCASINHERITANCE, SECURITY_ACTION_INHERITDEMANDCHOICE);\n\t}\n\treturn FALSE;\n}\n\n\nstatic MonoBoolean\nget_declsec_action (MonoImage *image, guint32 token, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\tguint32 cols [MONO_DECL_SECURITY_SIZE];\n\tMonoTableInfo *t;\n\tint i;\n\n\tint index = mono_metadata_declsec_from_index (image, token);\n\tif (index == -1)\n\t\treturn FALSE;\n\n\tt =  &image->tables [MONO_TABLE_DECLSECURITY];\n\tfor (i = index; i < t->rows; i++) {\n\t\tmono_metadata_decode_row (t, i, cols, MONO_DECL_SECURITY_SIZE);\n\n\t\t/* shortcut - index are ordered */\n\t\tif (token != cols [MONO_DECL_SECURITY_PARENT])\n\t\t\treturn FALSE;\n\n\t\tif (cols [MONO_DECL_SECURITY_ACTION] == action) {\n\t\t\tconst char *metadata = mono_metadata_blob_heap (image, cols [MONO_DECL_SECURITY_PERMISSIONSET]);\n\t\t\tentry->blob = (char*) (metadata + 2);\n\t\t\tentry->size = mono_metadata_decode_blob_size (metadata, &metadata);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\nMonoBoolean\nmono_declsec_get_method_action (MonoMethod *method, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\tif (method->flags & METHOD_ATTRIBUTE_HAS_SECURITY) {\n\t\tguint32 idx = mono_method_get_index (method);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tidx |= MONO_HAS_DECL_SECURITY_METHODDEF;\n\t\treturn get_declsec_action (method->klass->image, idx, action, entry);\n\t}\n\treturn FALSE;\n}\n\nMonoBoolean\nmono_declsec_get_class_action (MonoClass *klass, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\t/* use cache */\n\tguint32 flags = mono_declsec_flags_from_class (klass);\n\tif (declsec_flags_map [action] & flags) {\n\t\tguint32 idx = mono_metadata_token_index (klass->type_token);\n\t\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\t\tidx |= MONO_HAS_DECL_SECURITY_TYPEDEF;\n\t\treturn get_declsec_action (klass->image, idx, action, entry);\n\t}\n\treturn FALSE;\n}\n\nMonoBoolean\nmono_declsec_get_assembly_action (MonoAssembly *assembly, guint32 action, MonoDeclSecurityEntry *entry)\n{\n\tguint32 idx = 1; /* there is only one assembly */\n\tidx <<= MONO_HAS_DECL_SECURITY_BITS;\n\tidx |= MONO_HAS_DECL_SECURITY_ASSEMBLY;\n\n\treturn get_declsec_action (assembly->image, idx, action, entry);\n}\n\ngboolean\nmono_reflection_call_is_assignable_to (MonoClass *klass, MonoClass *oklass)\n{\n\tMonoObject *res, *exc;\n\tvoid *params [1];\n\tstatic MonoClass *System_Reflection_Emit_TypeBuilder = NULL;\n\tstatic MonoMethod *method = NULL;\n\n\tif (!System_Reflection_Emit_TypeBuilder) {\n\t\tSystem_Reflection_Emit_TypeBuilder = mono_class_from_name (mono_defaults.corlib, \"System.Reflection.Emit\", \"TypeBuilder\");\n\t\tg_assert (System_Reflection_Emit_TypeBuilder);\n\t}\n\tif (method == NULL) {\n\t\tmethod = mono_class_get_method_from_name (System_Reflection_Emit_TypeBuilder, \"IsAssignableTo\", 1);\n\t\tg_assert (method);\n\t}\n\n\t/* \n\t * The result of mono_type_get_object () might be a System.MonoType but we\n\t * need a TypeBuilder so use klass->reflection_info.\n\t */\n\tg_assert (klass->reflection_info);\n\tg_assert (!strcmp (((MonoObject*)(klass->reflection_info))->vtable->klass->name, \"TypeBuilder\"));\n\n\tparams [0] = mono_type_get_object (mono_domain_get (), &oklass->byval_arg);\n\n\tres = mono_runtime_invoke (method, (MonoObject*)(klass->reflection_info), params, &exc);\n\tif (exc)\n\t\treturn FALSE;\n\telse\n\t\treturn *(MonoBoolean*)mono_object_unbox (res);\n}\n"], "filenames": ["mcs/class/corlib/System.Reflection.Emit/DynamicMethod.cs", "mono/metadata/icall-def.h", "mono/metadata/object-internals.h", "mono/metadata/reflection.c"], "buggy_code_start_loc": [133, 516, 1450, 11066], "buggy_code_end_loc": [169, 517, 1450, 11168], "fixing_code_start_loc": [132, 515, 1451, 11067], "fixing_code_end_loc": [160, 515, 1454, 11203], "type": "CWE-399", "message": "Use-after-free vulnerability in Mono, when Moonlight 2.x before 2.4.1 or 3.x before 3.99.3 is used, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to finalizing and then resurrecting a DynamicMethod instance.", "other": {"cve": {"id": "CVE-2011-0991", "sourceIdentifier": "cve@mitre.org", "published": "2011-04-13T21:55:00.830", "lastModified": "2017-08-17T01:33:46.120", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use-after-free vulnerability in Mono, when Moonlight 2.x before 2.4.1 or 3.x before 3.99.3 is used, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to finalizing and then resurrecting a DynamicMethod instance."}, {"lang": "es", "value": "Vulnerabilidad de uso despu\u00e9s de la liberaci\u00f3n en Mono cuando se usa Moonlight v2.x anteriores a v2.4.1 o v3.x anteriores a v3.99.3 , permite a atacantes remotos producir una denegaci\u00f3n de servicio (ca\u00edda de aplicaci\u00f3n) o posiblemente alg\u00fan impacto a trav\u00e9s de vectores relacionados con la finalizaci\u00f3n y luego resucitar una instancia DynamicMethod."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:*:*:*:*:*:*:*:*", "matchCriteriaId": "E062208D-082B-4BFD-85CA-3848ECE6F8CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "711824C0-5BFC-4D3A-BAB2-84B8F20BDD7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "C74F2C01-7E26-474A-B8CA-EFCC5C91D83D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.4:*:*:*:*:*:*:*", "matchCriteriaId": "704EB745-3307-4903-8B3B-DCC6682EE228"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.31:*:*:*:*:*:*:*", "matchCriteriaId": "DB7A6358-630E-43FA-B2B8-C99A8808BB09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "AADDCD5B-D116-4BFC-BD2B-4EB6F4470359"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:3.99:*:*:*:*:*:*:*", "matchCriteriaId": "21676825-737D-4071-A7F1-BFB6047215F1"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2011-04/msg00024.html", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2011/04/06/14", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.mono-project.com/Vulnerabilities", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/47208", "source": "cve@mitre.org"}, {"url": "http://www.vupen.com/english/advisories/2011/0904", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=660422", "source": "cve@mitre.org"}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=667077", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/66626", "source": "cve@mitre.org"}, {"url": "https://github.com/mono/mono/commit/3f8ee42b8c867d9a4c18c22657840d072cca5c3a", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/mono/mono/commit/89d1455a80ef13cddee5d79ec00c06055da3085c", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/mono/mono/commit/8eb1189099e02372fd45ca1c67230eccf1edddc0", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/mono/mono/commit/3f8ee42b8c867d9a4c18c22657840d072cca5c3a"}}