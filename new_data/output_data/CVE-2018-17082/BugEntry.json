{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2016 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Sascha Schumann <sascha@schumann.cx>                        |\n   |          Parts based on Apache 1.3 SAPI module by                    |\n   |          Rasmus Lerdorf and Zeev Suraski                             |\n   +----------------------------------------------------------------------+\n */\n\n/* $Id$ */\n\n#define ZEND_INCLUDE_FULL_WINDOWS_HEADERS\n\n#include \"php.h\"\n#include \"php_main.h\"\n#include \"php_ini.h\"\n#include \"php_variables.h\"\n#include \"SAPI.h\"\n\n#include <fcntl.h>\n\n#include \"ext/standard/php_smart_str.h\"\n#ifndef NETWARE\n#include \"ext/standard/php_standard.h\"\n#else\n#include \"ext/standard/basic_functions.h\"\n#endif\n\n#include \"apr_strings.h\"\n#include \"ap_config.h\"\n#include \"util_filter.h\"\n#include \"httpd.h\"\n#include \"http_config.h\"\n#include \"http_request.h\"\n#include \"http_core.h\"\n#include \"http_protocol.h\"\n#include \"http_log.h\"\n#include \"http_main.h\"\n#include \"util_script.h\"\n#include \"http_core.h\"\n#include \"ap_mpm.h\"\n\n#include \"php_apache.h\"\n\n#ifdef PHP_WIN32\n# if _MSC_VER <= 1300\n#  include \"win32/php_strtoi64.h\"\n# endif\n#endif\n\n/* UnixWare and Netware define shutdown to _shutdown, which causes problems later\n * on when using a structure member named shutdown. Since this source\n * file does not use the system call shutdown, it is safe to #undef it.K\n */\n#undef shutdown\n\n#define PHP_MAGIC_TYPE \"application/x-httpd-php\"\n#define PHP_SOURCE_MAGIC_TYPE \"application/x-httpd-php-source\"\n#define PHP_SCRIPT \"php5-script\"\n\n/* A way to specify the location of the php.ini dir in an apache directive */\nchar *apache2_php_ini_path_override = NULL;\n\nstatic int\nphp_apache_sapi_ub_write(const char *str, uint str_length TSRMLS_DC)\n{\n\trequest_rec *r;\n\tphp_struct *ctx;\n\n\tctx = SG(server_context);\n\tr = ctx->r;\n\n\tif (ap_rwrite(str, str_length, r) < 0) {\n\t\tphp_handle_aborted_connection();\n\t}\n\n\treturn str_length; /* we always consume all the data passed to us. */\n}\n\nstatic int\nphp_apache_sapi_header_handler(sapi_header_struct *sapi_header, sapi_header_op_enum op, sapi_headers_struct *sapi_headers TSRMLS_DC)\n{\n\tphp_struct *ctx;\n\tchar *val, *ptr;\n\n\tctx = SG(server_context);\n\n\tswitch (op) {\n\t\tcase SAPI_HEADER_DELETE:\n\t\t\tapr_table_unset(ctx->r->headers_out, sapi_header->header);\n\t\t\treturn 0;\n\n\t\tcase SAPI_HEADER_DELETE_ALL:\n\t\t\tapr_table_clear(ctx->r->headers_out);\n\t\t\treturn 0;\n\n\t\tcase SAPI_HEADER_ADD:\n\t\tcase SAPI_HEADER_REPLACE:\n\t\t\tval = strchr(sapi_header->header, ':');\n\n\t\t\tif (!val) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tptr = val;\n\n\t\t\t*val = '\\0';\n\n\t\t\tdo {\n\t\t\t\tval++;\n\t\t\t} while (*val == ' ');\n\n\t\t\tif (!strcasecmp(sapi_header->header, \"content-type\")) {\n\t\t\t\tif (ctx->content_type) {\n\t\t\t\t\tefree(ctx->content_type);\n\t\t\t\t}\n\t\t\t\tctx->content_type = estrdup(val);\n\t\t\t} else if (!strcasecmp(sapi_header->header, \"content-length\")) {\n\t\t\t\tapr_off_t clen = 0;\n\n\t\t\t\tif (APR_SUCCESS != apr_strtoff(&clen, val, (char **) NULL, 10)) {\n\t\t\t\t\t/* We'll fall back to strtol, since that's what we used to\n\t\t\t\t\t * do anyway. */\n\t\t\t\t\tclen = (apr_off_t) strtol(val, (char **) NULL, 10);\n\t\t\t\t}\n\n\t\t\t\tap_set_content_length(ctx->r, clen);\n\t\t\t} else if (op == SAPI_HEADER_REPLACE) {\n\t\t\t\tapr_table_set(ctx->r->headers_out, sapi_header->header, val);\n\t\t\t} else {\n\t\t\t\tapr_table_add(ctx->r->headers_out, sapi_header->header, val);\n\t\t\t}\n\n\t\t\t*ptr = ':';\n\n\t\t\treturn SAPI_HEADER_ADD;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\nstatic int\nphp_apache_sapi_send_headers(sapi_headers_struct *sapi_headers TSRMLS_DC)\n{\n\tphp_struct *ctx = SG(server_context);\n\tconst char *sline = SG(sapi_headers).http_status_line;\n\n\tctx->r->status = SG(sapi_headers).http_response_code;\n\n\t/* httpd requires that r->status_line is set to the first digit of\n\t * the status-code: */\n\tif (sline && strlen(sline) > 12 && strncmp(sline, \"HTTP/1.\", 7) == 0 && sline[8] == ' ') {\n\t\tctx->r->status_line = apr_pstrdup(ctx->r->pool, sline + 9);\n\t\tctx->r->proto_num = 1000 + (sline[7]-'0');\n\t\tif ((sline[7]-'0') == 0) {\n\t\t\tapr_table_set(ctx->r->subprocess_env, \"force-response-1.0\", \"true\");\n\t\t}\n\t}\n\n\t/*\tcall ap_set_content_type only once, else each time we call it,\n\t\tconfigured output filters for that content type will be added */\n\tif (!ctx->content_type) {\n\t\tctx->content_type = sapi_get_default_content_type(TSRMLS_C);\n\t}\n\tap_set_content_type(ctx->r, apr_pstrdup(ctx->r->pool, ctx->content_type));\n\tefree(ctx->content_type);\n\tctx->content_type = NULL;\n\n\treturn SAPI_HEADER_SENT_SUCCESSFULLY;\n}\n\nstatic int\nphp_apache_sapi_read_post(char *buf, uint count_bytes TSRMLS_DC)\n{\n\tapr_size_t len, tlen=0;\n\tphp_struct *ctx = SG(server_context);\n\trequest_rec *r;\n\tapr_bucket_brigade *brigade;\n\n\tr = ctx->r;\n\tbrigade = ctx->brigade;\n\tlen = count_bytes;\n\n\t/*\n\t * This loop is needed because ap_get_brigade() can return us partial data\n\t * which would cause premature termination of request read. Therefor we\n\t * need to make sure that if data is available we fill the buffer completely.\n\t */\n\n\twhile (ap_get_brigade(r->input_filters, brigade, AP_MODE_READBYTES, APR_BLOCK_READ, len) == APR_SUCCESS) {\n\t\tapr_brigade_flatten(brigade, buf, &len);\n\t\tapr_brigade_cleanup(brigade);\n\t\ttlen += len;\n\t\tif (tlen == count_bytes || !len) {\n\t\t\tbreak;\n\t\t}\n\t\tbuf += len;\n\t\tlen = count_bytes - tlen;\n\t}\n\n\treturn tlen;\n}\n\nstatic struct stat*\nphp_apache_sapi_get_stat(TSRMLS_D)\n{\n\tphp_struct *ctx = SG(server_context);\n\n\tctx->finfo.st_uid = ctx->r->finfo.user;\n\tctx->finfo.st_gid = ctx->r->finfo.group;\n\tctx->finfo.st_dev = ctx->r->finfo.device;\n\tctx->finfo.st_ino = ctx->r->finfo.inode;\n#if defined(NETWARE) && defined(CLIB_STAT_PATCH)\n\tctx->finfo.st_atime.tv_sec = apr_time_sec(ctx->r->finfo.atime);\n\tctx->finfo.st_mtime.tv_sec = apr_time_sec(ctx->r->finfo.mtime);\n\tctx->finfo.st_ctime.tv_sec = apr_time_sec(ctx->r->finfo.ctime);\n#else\n\tctx->finfo.st_atime = apr_time_sec(ctx->r->finfo.atime);\n\tctx->finfo.st_mtime = apr_time_sec(ctx->r->finfo.mtime);\n\tctx->finfo.st_ctime = apr_time_sec(ctx->r->finfo.ctime);\n#endif\n\n\tctx->finfo.st_size = ctx->r->finfo.size;\n\tctx->finfo.st_nlink = ctx->r->finfo.nlink;\n\n\treturn &ctx->finfo;\n}\n\nstatic char *\nphp_apache_sapi_read_cookies(TSRMLS_D)\n{\n\tphp_struct *ctx = SG(server_context);\n\tconst char *http_cookie;\n\n\thttp_cookie = apr_table_get(ctx->r->headers_in, \"cookie\");\n\n\t/* The SAPI interface should use 'const char *' */\n\treturn (char *) http_cookie;\n}\n\nstatic char *\nphp_apache_sapi_getenv(char *name, size_t name_len TSRMLS_DC)\n{\n\tphp_struct *ctx = SG(server_context);\n\tconst char *env_var;\n\n\tif (ctx == NULL) {\n\t\treturn NULL;\n\t}\n\n\tenv_var = apr_table_get(ctx->r->subprocess_env, name);\n\n\treturn (char *) env_var;\n}\n\nstatic void\nphp_apache_sapi_register_variables(zval *track_vars_array TSRMLS_DC)\n{\n\tphp_struct *ctx = SG(server_context);\n\tconst apr_array_header_t *arr = apr_table_elts(ctx->r->subprocess_env);\n\tchar *key, *val;\n\tint new_val_len;\n\n\tAPR_ARRAY_FOREACH_OPEN(arr, key, val)\n\t\tif (!val) {\n\t\t\tval = \"\";\n\t\t}\n\t\tif (sapi_module.input_filter(PARSE_SERVER, key, &val, strlen(val), (unsigned int *)&new_val_len TSRMLS_CC)) {\n\t\t\tphp_register_variable_safe(key, val, new_val_len, track_vars_array TSRMLS_CC);\n\t\t}\n\tAPR_ARRAY_FOREACH_CLOSE()\n\n\tif (sapi_module.input_filter(PARSE_SERVER, \"PHP_SELF\", &ctx->r->uri, strlen(ctx->r->uri), (unsigned int *)&new_val_len TSRMLS_CC)) {\n\t\tphp_register_variable_safe(\"PHP_SELF\", ctx->r->uri, new_val_len, track_vars_array TSRMLS_CC);\n\t}\n}\n\nstatic void\nphp_apache_sapi_flush(void *server_context)\n{\n\tphp_struct *ctx;\n\trequest_rec *r;\n\tTSRMLS_FETCH();\n\n\tctx = server_context;\n\n\t/* If we haven't registered a server_context yet,\n\t * then don't bother flushing. */\n\tif (!server_context) {\n\t\treturn;\n\t}\n\n\tr = ctx->r;\n\n\tsapi_send_headers(TSRMLS_C);\n\n\tr->status = SG(sapi_headers).http_response_code;\n\tSG(headers_sent) = 1;\n\n\tif (ap_rflush(r) < 0 || r->connection->aborted) {\n\t\tphp_handle_aborted_connection();\n\t}\n}\n\nstatic void php_apache_sapi_log_message(char *msg TSRMLS_DC)\n{\n\tphp_struct *ctx;\n\n\tctx = SG(server_context);\n\n\tif (ctx == NULL) { /* we haven't initialized our ctx yet, oh well */\n\t\tap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, 0, NULL, \"%s\", msg);\n\t} else {\n\t\tap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, \"%s\", msg);\n\t}\n}\n\nstatic void php_apache_sapi_log_message_ex(char *msg, request_rec *r TSRMLS_DC)\n{\n\tif (r) {\n\t\tap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, msg, r->filename);\n\t} else {\n\t\tphp_apache_sapi_log_message(msg TSRMLS_CC);\n\t}\n}\n\nstatic double php_apache_sapi_get_request_time(TSRMLS_D)\n{\n\tphp_struct *ctx = SG(server_context);\n\treturn ((double) apr_time_as_msec(ctx->r->request_time)) / 1000.0;\n}\n\nextern zend_module_entry php_apache_module;\n\nstatic int php_apache2_startup(sapi_module_struct *sapi_module)\n{\n\tif (php_module_startup(sapi_module, &php_apache_module, 1)==FAILURE) {\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}\n\nstatic sapi_module_struct apache2_sapi_module = {\n\t\"apache2handler\",\n\t\"Apache 2.0 Handler\",\n\n\tphp_apache2_startup,\t\t\t\t/* startup */\n\tphp_module_shutdown_wrapper,\t\t\t/* shutdown */\n\n\tNULL,\t\t\t\t\t\t/* activate */\n\tNULL,\t\t\t\t\t\t/* deactivate */\n\n\tphp_apache_sapi_ub_write,\t\t\t/* unbuffered write */\n\tphp_apache_sapi_flush,\t\t\t\t/* flush */\n\tphp_apache_sapi_get_stat,\t\t\t/* get uid */\n\tphp_apache_sapi_getenv,\t\t\t\t/* getenv */\n\n\tphp_error,\t\t\t\t\t/* error handler */\n\n\tphp_apache_sapi_header_handler,\t\t\t/* header handler */\n\tphp_apache_sapi_send_headers,\t\t\t/* send headers handler */\n\tNULL,\t\t\t\t\t\t/* send header handler */\n\n\tphp_apache_sapi_read_post,\t\t\t/* read POST data */\n\tphp_apache_sapi_read_cookies,\t\t\t/* read Cookies */\n\n\tphp_apache_sapi_register_variables,\n\tphp_apache_sapi_log_message,\t\t\t/* Log message */\n\tphp_apache_sapi_get_request_time,\t\t/* Request Time */\n\tNULL,\t\t\t\t\t\t/* Child Terminate */\n\n\tSTANDARD_SAPI_MODULE_PROPERTIES\n};\n\nstatic apr_status_t php_apache_server_shutdown(void *tmp)\n{\n\tapache2_sapi_module.shutdown(&apache2_sapi_module);\n\tsapi_shutdown();\n#ifdef ZTS\n\ttsrm_shutdown();\n#endif\n\treturn APR_SUCCESS;\n}\n\nstatic apr_status_t php_apache_child_shutdown(void *tmp)\n{\n\tapache2_sapi_module.shutdown(&apache2_sapi_module);\n#if defined(ZTS) && !defined(PHP_WIN32)\n\ttsrm_shutdown();\n#endif\n\treturn APR_SUCCESS;\n}\n\nstatic void php_apache_add_version(apr_pool_t *p)\n{\n\tTSRMLS_FETCH();\n\tif (PG(expose_php)) {\n\t\tap_add_version_component(p, \"PHP/\" PHP_VERSION);\n\t}\n}\n\nstatic int php_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)\n{\n#ifndef ZTS\n\tint threaded_mpm;\n\n\tap_mpm_query(AP_MPMQ_IS_THREADED, &threaded_mpm);\n\tif(threaded_mpm) {\n\t\tap_log_error(APLOG_MARK, APLOG_CRIT, 0, 0, \"Apache is running a threaded MPM, but your PHP Module is not compiled to be threadsafe.  You need to recompile PHP.\");\n\t\treturn DONE;\n\t}\n#endif\n\t/* When this is NULL, apache won't override the hard-coded default\n\t * php.ini path setting. */\n\tapache2_php_ini_path_override = NULL;\n\treturn OK;\n}\n\nstatic int\nphp_apache_server_startup(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)\n{\n\tvoid *data = NULL;\n\tconst char *userdata_key = \"apache2hook_post_config\";\n\n\t/* Apache will load, unload and then reload a DSO module. This\n\t * prevents us from starting PHP until the second load. */\n\tapr_pool_userdata_get(&data, userdata_key, s->process->pool);\n\tif (data == NULL) {\n\t\t/* We must use set() here and *not* setn(), otherwise the\n\t\t * static string pointed to by userdata_key will be mapped\n\t\t * to a different location when the DSO is reloaded and the\n\t\t * pointers won't match, causing get() to return NULL when\n\t\t * we expected it to return non-NULL. */\n\t\tapr_pool_userdata_set((const void *)1, userdata_key, apr_pool_cleanup_null, s->process->pool);\n\t\treturn OK;\n\t}\n\n\t/* Set up our overridden path. */\n\tif (apache2_php_ini_path_override) {\n\t\tapache2_sapi_module.php_ini_path_override = apache2_php_ini_path_override;\n\t}\n#ifdef ZTS\n\ttsrm_startup(1, 1, 0, NULL);\n#endif\n\tsapi_startup(&apache2_sapi_module);\n\tapache2_sapi_module.startup(&apache2_sapi_module);\n\tapr_pool_cleanup_register(pconf, NULL, php_apache_server_shutdown, apr_pool_cleanup_null);\n\tphp_apache_add_version(pconf);\n\n\treturn OK;\n}\n\nstatic apr_status_t php_server_context_cleanup(void *data_)\n{\n\tvoid **data = data_;\n\t*data = NULL;\n\treturn APR_SUCCESS;\n}\n\nstatic int php_apache_request_ctor(request_rec *r, php_struct *ctx TSRMLS_DC)\n{\n\tchar *content_length;\n\tconst char *auth;\n\n\tSG(sapi_headers).http_response_code = !r->status ? HTTP_OK : r->status;\n\tSG(request_info).content_type = apr_table_get(r->headers_in, \"Content-Type\");\n\tSG(request_info).query_string = apr_pstrdup(r->pool, r->args);\n\tSG(request_info).request_method = r->method;\n\tSG(request_info).proto_num = r->proto_num;\n\tSG(request_info).request_uri = apr_pstrdup(r->pool, r->uri);\n\tSG(request_info).path_translated = apr_pstrdup(r->pool, r->filename);\n\tr->no_local_copy = 1;\n\n\tcontent_length = (char *) apr_table_get(r->headers_in, \"Content-Length\");\n\tSG(request_info).content_length = (content_length ? atol(content_length) : 0);\n\n\tapr_table_unset(r->headers_out, \"Content-Length\");\n\tapr_table_unset(r->headers_out, \"Last-Modified\");\n\tapr_table_unset(r->headers_out, \"Expires\");\n\tapr_table_unset(r->headers_out, \"ETag\");\n\n\tauth = apr_table_get(r->headers_in, \"Authorization\");\n\tphp_handle_auth_data(auth TSRMLS_CC);\n\n\tif (SG(request_info).auth_user == NULL && r->user) {\n\t\tSG(request_info).auth_user = estrdup(r->user);\n\t}\n\n\tctx->r->user = apr_pstrdup(ctx->r->pool, SG(request_info).auth_user);\n\n\treturn php_request_startup(TSRMLS_C);\n}\n\nstatic void php_apache_request_dtor(request_rec *r TSRMLS_DC)\n{\n\tphp_request_shutdown(NULL);\n}\n\nstatic void php_apache_ini_dtor(request_rec *r, request_rec *p TSRMLS_DC)\n{\n\tif (strcmp(r->protocol, \"INCLUDED\")) {\n\t\tzend_try { zend_ini_deactivate(TSRMLS_C); } zend_end_try();\n\t} else {\ntypedef struct {\n\tHashTable config;\n} php_conf_rec;\n\t\tchar *str;\n\t\tuint str_len;\n\t\tphp_conf_rec *c = ap_get_module_config(r->per_dir_config, &php5_module);\n\n\t\tfor (zend_hash_internal_pointer_reset(&c->config);\n\t\t\tzend_hash_get_current_key_ex(&c->config, &str, &str_len, NULL, 0,  NULL) == HASH_KEY_IS_STRING;\n\t\t\tzend_hash_move_forward(&c->config)\n\t\t) {\n\t\t\tzend_restore_ini_entry(str, str_len, ZEND_INI_STAGE_SHUTDOWN);\n\t\t}\n\t}\n\tif (p) {\n\t\t((php_struct *)SG(server_context))->r = p;\n\t} else {\n\t\tapr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);\n\t}\n}\n\nstatic int php_handler(request_rec *r)\n{\n\tphp_struct * volatile ctx;\n\tvoid *conf;\n\tapr_bucket_brigade * volatile brigade;\n\tapr_bucket *bucket;\n\tapr_status_t rv;\n\trequest_rec * volatile parent_req = NULL;\n\tTSRMLS_FETCH();\n\n#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);\n\n\tconf = ap_get_module_config(r->per_dir_config, &php5_module);\n\n\t/* apply_config() needs r in some cases, so allocate server_context early */\n\tctx = SG(server_context);\n\tif (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, \"INCLUDED\"))) {\nnormal:\n\t\tctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));\n\t\t/* register a cleanup so we clear out the SG(server_context)\n\t\t * after each request. Note: We pass in the pointer to the\n\t\t * server_context in case this is handled by a different thread.\n\t\t */\n\t\tapr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);\n\t\tctx->r = r;\n\t\tctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */\n\t} else {\n\t\tparent_req = ctx->r;\n\t\tctx->r = r;\n\t}\n\tapply_config(conf);\n\n\tif (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {\n\t\t/* Check for xbithack in this case. */\n\t\tif (!AP2(xbithack) || strcmp(r->handler, \"text/html\") || !(r->finfo.protection & APR_UEXECUTE)) {\n\t\t\tPHPAP_INI_OFF;\n\t\t\treturn DECLINED;\n\t\t}\n\t}\n\n\t/* Give a 404 if PATH_INFO is used but is explicitly disabled in\n\t * the configuration; default behaviour is to accept. */\n\tif (r->used_path_info == AP_REQ_REJECT_PATH_INFO\n\t\t&& r->path_info && r->path_info[0]) {\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* handle situations where user turns the engine off */\n\tif (!AP2(engine)) {\n\t\tPHPAP_INI_OFF;\n\t\treturn DECLINED;\n\t}\n\n\tif (r->finfo.filetype == 0) {\n\t\tphp_apache_sapi_log_message_ex(\"script '%s' not found or unable to stat\", r TSRMLS_CC);\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\tif (r->finfo.filetype == APR_DIR) {\n\t\tphp_apache_sapi_log_message_ex(\"attempt to invoke directory '%s' as script\", r TSRMLS_CC);\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_FORBIDDEN;\n\t}\n\n\t/* Setup the CGI variables if this is the main request */\n\tif (r->main == NULL ||\n\t\t/* .. or if the sub-request environment differs from the main-request. */\n\t\tr->subprocess_env != r->main->subprocess_env\n\t) {\n\t\t/* setup standard CGI variables */\n\t\tap_add_common_vars(r);\n\t\tap_add_cgi_vars(r);\n\t}\n\nzend_first_try {\n\n\tif (ctx == NULL) {\n\t\tbrigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n\t\tctx = SG(server_context);\n\t\tctx->brigade = brigade;\n\n\t\tif (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {\n\t\t\tzend_bailout();\n\t\t}\n\t} else {\n\t\tif (!parent_req) {\n\t\t\tparent_req = ctx->r;\n\t\t}\n\t\tif (parent_req && parent_req->handler &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_MAGIC_TYPE) &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_SCRIPT)) {\n\t\t\tif (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {\n\t\t\t\tzend_bailout();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * check if coming due to ErrorDocument\n\t\t * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs\n\t\t * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting\n\t\t * PHP instance to handle the request rather then creating a new one.\n\t\t*/\n\t\tif (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, \"INCLUDED\")) {\n\t\t\tparent_req = NULL;\n\t\t\tgoto normal;\n\t\t}\n\t\tctx->r = r;\n\t\tbrigade = ctx->brigade;\n\t}\n\n\tif (AP2(last_modified)) {\n\t\tap_update_mtime(r, r->finfo.mtime);\n\t\tap_set_last_modified(r);\n\t}\n\n\t/* Determine if we need to parse the file or show the source */\n\tif (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {\n\t\tzend_syntax_highlighter_ini syntax_highlighter_ini;\n\t\tphp_get_highlight_struct(&syntax_highlighter_ini);\n\t\thighlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);\n\t} else {\n\t\tzend_file_handle zfd;\n\n\t\tzfd.type = ZEND_HANDLE_FILENAME;\n\t\tzfd.filename = (char *) r->filename;\n\t\tzfd.free_filename = 0;\n\t\tzfd.opened_path = NULL;\n\n\t\tif (!parent_req) {\n\t\t\tphp_execute_script(&zfd TSRMLS_CC);\n\t\t} else {\n\t\t\tzend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);\n\t\t}\n\n\t\tapr_table_set(r->notes, \"mod_php_memory_usage\",\n\t\t\tapr_psprintf(ctx->r->pool, \"%\" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));\n\t}\n\n} zend_end_try();\n\n\tif (!parent_req) {\n\t\tphp_apache_request_dtor(r TSRMLS_CC);\n\t\tctx->request_processed = 1;\n\t\tbucket = apr_bucket_eos_create(r->connection->bucket_alloc);\n\t\tAPR_BRIGADE_INSERT_TAIL(brigade, bucket);\n\n\t\trv = ap_pass_brigade(r->output_filters, brigade);\n\t\tif (rv != APR_SUCCESS || r->connection->aborted) {\nzend_first_try {\n\t\t\tphp_handle_aborted_connection();\n} zend_end_try();\n\t\t}\n\t\tapr_brigade_cleanup(brigade);\n\t\tapr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);\n\t} else {\n\t\tctx->r = parent_req;\n\t}\n\n\treturn OK;\n}\n\nstatic void php_apache_child_init(apr_pool_t *pchild, server_rec *s)\n{\n\tapr_pool_cleanup_register(pchild, NULL, php_apache_child_shutdown, apr_pool_cleanup_null);\n}\n\nvoid php_ap2_register_hook(apr_pool_t *p)\n{\n\tap_hook_pre_config(php_pre_config, NULL, NULL, APR_HOOK_MIDDLE);\n\tap_hook_post_config(php_apache_server_startup, NULL, NULL, APR_HOOK_MIDDLE);\n\tap_hook_handler(php_handler, NULL, NULL, APR_HOOK_MIDDLE);\n\tap_hook_child_init(php_apache_child_init, NULL, NULL, APR_HOOK_MIDDLE);\n}\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: sw=4 ts=4 fdm=marker\n * vim<600: sw=4 ts=4\n */\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2016 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Authors: Sascha Schumann <sascha@schumann.cx>                        |\n   |          Parts based on Apache 1.3 SAPI module by                    |\n   |          Rasmus Lerdorf and Zeev Suraski                             |\n   +----------------------------------------------------------------------+\n */\n\n/* $Id$ */\n\n#define ZEND_INCLUDE_FULL_WINDOWS_HEADERS\n\n#include \"php.h\"\n#include \"php_main.h\"\n#include \"php_ini.h\"\n#include \"php_variables.h\"\n#include \"SAPI.h\"\n\n#include <fcntl.h>\n\n#include \"ext/standard/php_smart_str.h\"\n#ifndef NETWARE\n#include \"ext/standard/php_standard.h\"\n#else\n#include \"ext/standard/basic_functions.h\"\n#endif\n\n#include \"apr_strings.h\"\n#include \"ap_config.h\"\n#include \"util_filter.h\"\n#include \"httpd.h\"\n#include \"http_config.h\"\n#include \"http_request.h\"\n#include \"http_core.h\"\n#include \"http_protocol.h\"\n#include \"http_log.h\"\n#include \"http_main.h\"\n#include \"util_script.h\"\n#include \"http_core.h\"\n#include \"ap_mpm.h\"\n\n#include \"php_apache.h\"\n\n#ifdef PHP_WIN32\n# if _MSC_VER <= 1300\n#  include \"win32/php_strtoi64.h\"\n# endif\n#endif\n\n/* UnixWare and Netware define shutdown to _shutdown, which causes problems later\n * on when using a structure member named shutdown. Since this source\n * file does not use the system call shutdown, it is safe to #undef it.K\n */\n#undef shutdown\n\n#define PHP_MAGIC_TYPE \"application/x-httpd-php\"\n#define PHP_SOURCE_MAGIC_TYPE \"application/x-httpd-php-source\"\n#define PHP_SCRIPT \"php5-script\"\n\n/* A way to specify the location of the php.ini dir in an apache directive */\nchar *apache2_php_ini_path_override = NULL;\n\nstatic int\nphp_apache_sapi_ub_write(const char *str, uint str_length TSRMLS_DC)\n{\n\trequest_rec *r;\n\tphp_struct *ctx;\n\n\tctx = SG(server_context);\n\tr = ctx->r;\n\n\tif (ap_rwrite(str, str_length, r) < 0) {\n\t\tphp_handle_aborted_connection();\n\t}\n\n\treturn str_length; /* we always consume all the data passed to us. */\n}\n\nstatic int\nphp_apache_sapi_header_handler(sapi_header_struct *sapi_header, sapi_header_op_enum op, sapi_headers_struct *sapi_headers TSRMLS_DC)\n{\n\tphp_struct *ctx;\n\tchar *val, *ptr;\n\n\tctx = SG(server_context);\n\n\tswitch (op) {\n\t\tcase SAPI_HEADER_DELETE:\n\t\t\tapr_table_unset(ctx->r->headers_out, sapi_header->header);\n\t\t\treturn 0;\n\n\t\tcase SAPI_HEADER_DELETE_ALL:\n\t\t\tapr_table_clear(ctx->r->headers_out);\n\t\t\treturn 0;\n\n\t\tcase SAPI_HEADER_ADD:\n\t\tcase SAPI_HEADER_REPLACE:\n\t\t\tval = strchr(sapi_header->header, ':');\n\n\t\t\tif (!val) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tptr = val;\n\n\t\t\t*val = '\\0';\n\n\t\t\tdo {\n\t\t\t\tval++;\n\t\t\t} while (*val == ' ');\n\n\t\t\tif (!strcasecmp(sapi_header->header, \"content-type\")) {\n\t\t\t\tif (ctx->content_type) {\n\t\t\t\t\tefree(ctx->content_type);\n\t\t\t\t}\n\t\t\t\tctx->content_type = estrdup(val);\n\t\t\t} else if (!strcasecmp(sapi_header->header, \"content-length\")) {\n\t\t\t\tapr_off_t clen = 0;\n\n\t\t\t\tif (APR_SUCCESS != apr_strtoff(&clen, val, (char **) NULL, 10)) {\n\t\t\t\t\t/* We'll fall back to strtol, since that's what we used to\n\t\t\t\t\t * do anyway. */\n\t\t\t\t\tclen = (apr_off_t) strtol(val, (char **) NULL, 10);\n\t\t\t\t}\n\n\t\t\t\tap_set_content_length(ctx->r, clen);\n\t\t\t} else if (op == SAPI_HEADER_REPLACE) {\n\t\t\t\tapr_table_set(ctx->r->headers_out, sapi_header->header, val);\n\t\t\t} else {\n\t\t\t\tapr_table_add(ctx->r->headers_out, sapi_header->header, val);\n\t\t\t}\n\n\t\t\t*ptr = ':';\n\n\t\t\treturn SAPI_HEADER_ADD;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\nstatic int\nphp_apache_sapi_send_headers(sapi_headers_struct *sapi_headers TSRMLS_DC)\n{\n\tphp_struct *ctx = SG(server_context);\n\tconst char *sline = SG(sapi_headers).http_status_line;\n\n\tctx->r->status = SG(sapi_headers).http_response_code;\n\n\t/* httpd requires that r->status_line is set to the first digit of\n\t * the status-code: */\n\tif (sline && strlen(sline) > 12 && strncmp(sline, \"HTTP/1.\", 7) == 0 && sline[8] == ' ') {\n\t\tctx->r->status_line = apr_pstrdup(ctx->r->pool, sline + 9);\n\t\tctx->r->proto_num = 1000 + (sline[7]-'0');\n\t\tif ((sline[7]-'0') == 0) {\n\t\t\tapr_table_set(ctx->r->subprocess_env, \"force-response-1.0\", \"true\");\n\t\t}\n\t}\n\n\t/*\tcall ap_set_content_type only once, else each time we call it,\n\t\tconfigured output filters for that content type will be added */\n\tif (!ctx->content_type) {\n\t\tctx->content_type = sapi_get_default_content_type(TSRMLS_C);\n\t}\n\tap_set_content_type(ctx->r, apr_pstrdup(ctx->r->pool, ctx->content_type));\n\tefree(ctx->content_type);\n\tctx->content_type = NULL;\n\n\treturn SAPI_HEADER_SENT_SUCCESSFULLY;\n}\n\nstatic int\nphp_apache_sapi_read_post(char *buf, uint count_bytes TSRMLS_DC)\n{\n\tapr_size_t len, tlen=0;\n\tphp_struct *ctx = SG(server_context);\n\trequest_rec *r;\n\tapr_bucket_brigade *brigade;\n\n\tr = ctx->r;\n\tbrigade = ctx->brigade;\n\tlen = count_bytes;\n\n\t/*\n\t * This loop is needed because ap_get_brigade() can return us partial data\n\t * which would cause premature termination of request read. Therefor we\n\t * need to make sure that if data is available we fill the buffer completely.\n\t */\n\n\twhile (ap_get_brigade(r->input_filters, brigade, AP_MODE_READBYTES, APR_BLOCK_READ, len) == APR_SUCCESS) {\n\t\tapr_brigade_flatten(brigade, buf, &len);\n\t\tapr_brigade_cleanup(brigade);\n\t\ttlen += len;\n\t\tif (tlen == count_bytes || !len) {\n\t\t\tbreak;\n\t\t}\n\t\tbuf += len;\n\t\tlen = count_bytes - tlen;\n\t}\n\n\treturn tlen;\n}\n\nstatic struct stat*\nphp_apache_sapi_get_stat(TSRMLS_D)\n{\n\tphp_struct *ctx = SG(server_context);\n\n\tctx->finfo.st_uid = ctx->r->finfo.user;\n\tctx->finfo.st_gid = ctx->r->finfo.group;\n\tctx->finfo.st_dev = ctx->r->finfo.device;\n\tctx->finfo.st_ino = ctx->r->finfo.inode;\n#if defined(NETWARE) && defined(CLIB_STAT_PATCH)\n\tctx->finfo.st_atime.tv_sec = apr_time_sec(ctx->r->finfo.atime);\n\tctx->finfo.st_mtime.tv_sec = apr_time_sec(ctx->r->finfo.mtime);\n\tctx->finfo.st_ctime.tv_sec = apr_time_sec(ctx->r->finfo.ctime);\n#else\n\tctx->finfo.st_atime = apr_time_sec(ctx->r->finfo.atime);\n\tctx->finfo.st_mtime = apr_time_sec(ctx->r->finfo.mtime);\n\tctx->finfo.st_ctime = apr_time_sec(ctx->r->finfo.ctime);\n#endif\n\n\tctx->finfo.st_size = ctx->r->finfo.size;\n\tctx->finfo.st_nlink = ctx->r->finfo.nlink;\n\n\treturn &ctx->finfo;\n}\n\nstatic char *\nphp_apache_sapi_read_cookies(TSRMLS_D)\n{\n\tphp_struct *ctx = SG(server_context);\n\tconst char *http_cookie;\n\n\thttp_cookie = apr_table_get(ctx->r->headers_in, \"cookie\");\n\n\t/* The SAPI interface should use 'const char *' */\n\treturn (char *) http_cookie;\n}\n\nstatic char *\nphp_apache_sapi_getenv(char *name, size_t name_len TSRMLS_DC)\n{\n\tphp_struct *ctx = SG(server_context);\n\tconst char *env_var;\n\n\tif (ctx == NULL) {\n\t\treturn NULL;\n\t}\n\n\tenv_var = apr_table_get(ctx->r->subprocess_env, name);\n\n\treturn (char *) env_var;\n}\n\nstatic void\nphp_apache_sapi_register_variables(zval *track_vars_array TSRMLS_DC)\n{\n\tphp_struct *ctx = SG(server_context);\n\tconst apr_array_header_t *arr = apr_table_elts(ctx->r->subprocess_env);\n\tchar *key, *val;\n\tint new_val_len;\n\n\tAPR_ARRAY_FOREACH_OPEN(arr, key, val)\n\t\tif (!val) {\n\t\t\tval = \"\";\n\t\t}\n\t\tif (sapi_module.input_filter(PARSE_SERVER, key, &val, strlen(val), (unsigned int *)&new_val_len TSRMLS_CC)) {\n\t\t\tphp_register_variable_safe(key, val, new_val_len, track_vars_array TSRMLS_CC);\n\t\t}\n\tAPR_ARRAY_FOREACH_CLOSE()\n\n\tif (sapi_module.input_filter(PARSE_SERVER, \"PHP_SELF\", &ctx->r->uri, strlen(ctx->r->uri), (unsigned int *)&new_val_len TSRMLS_CC)) {\n\t\tphp_register_variable_safe(\"PHP_SELF\", ctx->r->uri, new_val_len, track_vars_array TSRMLS_CC);\n\t}\n}\n\nstatic void\nphp_apache_sapi_flush(void *server_context)\n{\n\tphp_struct *ctx;\n\trequest_rec *r;\n\tTSRMLS_FETCH();\n\n\tctx = server_context;\n\n\t/* If we haven't registered a server_context yet,\n\t * then don't bother flushing. */\n\tif (!server_context) {\n\t\treturn;\n\t}\n\n\tr = ctx->r;\n\n\tsapi_send_headers(TSRMLS_C);\n\n\tr->status = SG(sapi_headers).http_response_code;\n\tSG(headers_sent) = 1;\n\n\tif (ap_rflush(r) < 0 || r->connection->aborted) {\n\t\tphp_handle_aborted_connection();\n\t}\n}\n\nstatic void php_apache_sapi_log_message(char *msg TSRMLS_DC)\n{\n\tphp_struct *ctx;\n\n\tctx = SG(server_context);\n\n\tif (ctx == NULL) { /* we haven't initialized our ctx yet, oh well */\n\t\tap_log_error(APLOG_MARK, APLOG_ERR | APLOG_STARTUP, 0, NULL, \"%s\", msg);\n\t} else {\n\t\tap_log_rerror(APLOG_MARK, APLOG_ERR, 0, ctx->r, \"%s\", msg);\n\t}\n}\n\nstatic void php_apache_sapi_log_message_ex(char *msg, request_rec *r TSRMLS_DC)\n{\n\tif (r) {\n\t\tap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, msg, r->filename);\n\t} else {\n\t\tphp_apache_sapi_log_message(msg TSRMLS_CC);\n\t}\n}\n\nstatic double php_apache_sapi_get_request_time(TSRMLS_D)\n{\n\tphp_struct *ctx = SG(server_context);\n\treturn ((double) apr_time_as_msec(ctx->r->request_time)) / 1000.0;\n}\n\nextern zend_module_entry php_apache_module;\n\nstatic int php_apache2_startup(sapi_module_struct *sapi_module)\n{\n\tif (php_module_startup(sapi_module, &php_apache_module, 1)==FAILURE) {\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}\n\nstatic sapi_module_struct apache2_sapi_module = {\n\t\"apache2handler\",\n\t\"Apache 2.0 Handler\",\n\n\tphp_apache2_startup,\t\t\t\t/* startup */\n\tphp_module_shutdown_wrapper,\t\t\t/* shutdown */\n\n\tNULL,\t\t\t\t\t\t/* activate */\n\tNULL,\t\t\t\t\t\t/* deactivate */\n\n\tphp_apache_sapi_ub_write,\t\t\t/* unbuffered write */\n\tphp_apache_sapi_flush,\t\t\t\t/* flush */\n\tphp_apache_sapi_get_stat,\t\t\t/* get uid */\n\tphp_apache_sapi_getenv,\t\t\t\t/* getenv */\n\n\tphp_error,\t\t\t\t\t/* error handler */\n\n\tphp_apache_sapi_header_handler,\t\t\t/* header handler */\n\tphp_apache_sapi_send_headers,\t\t\t/* send headers handler */\n\tNULL,\t\t\t\t\t\t/* send header handler */\n\n\tphp_apache_sapi_read_post,\t\t\t/* read POST data */\n\tphp_apache_sapi_read_cookies,\t\t\t/* read Cookies */\n\n\tphp_apache_sapi_register_variables,\n\tphp_apache_sapi_log_message,\t\t\t/* Log message */\n\tphp_apache_sapi_get_request_time,\t\t/* Request Time */\n\tNULL,\t\t\t\t\t\t/* Child Terminate */\n\n\tSTANDARD_SAPI_MODULE_PROPERTIES\n};\n\nstatic apr_status_t php_apache_server_shutdown(void *tmp)\n{\n\tapache2_sapi_module.shutdown(&apache2_sapi_module);\n\tsapi_shutdown();\n#ifdef ZTS\n\ttsrm_shutdown();\n#endif\n\treturn APR_SUCCESS;\n}\n\nstatic apr_status_t php_apache_child_shutdown(void *tmp)\n{\n\tapache2_sapi_module.shutdown(&apache2_sapi_module);\n#if defined(ZTS) && !defined(PHP_WIN32)\n\ttsrm_shutdown();\n#endif\n\treturn APR_SUCCESS;\n}\n\nstatic void php_apache_add_version(apr_pool_t *p)\n{\n\tTSRMLS_FETCH();\n\tif (PG(expose_php)) {\n\t\tap_add_version_component(p, \"PHP/\" PHP_VERSION);\n\t}\n}\n\nstatic int php_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)\n{\n#ifndef ZTS\n\tint threaded_mpm;\n\n\tap_mpm_query(AP_MPMQ_IS_THREADED, &threaded_mpm);\n\tif(threaded_mpm) {\n\t\tap_log_error(APLOG_MARK, APLOG_CRIT, 0, 0, \"Apache is running a threaded MPM, but your PHP Module is not compiled to be threadsafe.  You need to recompile PHP.\");\n\t\treturn DONE;\n\t}\n#endif\n\t/* When this is NULL, apache won't override the hard-coded default\n\t * php.ini path setting. */\n\tapache2_php_ini_path_override = NULL;\n\treturn OK;\n}\n\nstatic int\nphp_apache_server_startup(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)\n{\n\tvoid *data = NULL;\n\tconst char *userdata_key = \"apache2hook_post_config\";\n\n\t/* Apache will load, unload and then reload a DSO module. This\n\t * prevents us from starting PHP until the second load. */\n\tapr_pool_userdata_get(&data, userdata_key, s->process->pool);\n\tif (data == NULL) {\n\t\t/* We must use set() here and *not* setn(), otherwise the\n\t\t * static string pointed to by userdata_key will be mapped\n\t\t * to a different location when the DSO is reloaded and the\n\t\t * pointers won't match, causing get() to return NULL when\n\t\t * we expected it to return non-NULL. */\n\t\tapr_pool_userdata_set((const void *)1, userdata_key, apr_pool_cleanup_null, s->process->pool);\n\t\treturn OK;\n\t}\n\n\t/* Set up our overridden path. */\n\tif (apache2_php_ini_path_override) {\n\t\tapache2_sapi_module.php_ini_path_override = apache2_php_ini_path_override;\n\t}\n#ifdef ZTS\n\ttsrm_startup(1, 1, 0, NULL);\n#endif\n\tsapi_startup(&apache2_sapi_module);\n\tapache2_sapi_module.startup(&apache2_sapi_module);\n\tapr_pool_cleanup_register(pconf, NULL, php_apache_server_shutdown, apr_pool_cleanup_null);\n\tphp_apache_add_version(pconf);\n\n\treturn OK;\n}\n\nstatic apr_status_t php_server_context_cleanup(void *data_)\n{\n\tvoid **data = data_;\n\t*data = NULL;\n\treturn APR_SUCCESS;\n}\n\nstatic int php_apache_request_ctor(request_rec *r, php_struct *ctx TSRMLS_DC)\n{\n\tchar *content_length;\n\tconst char *auth;\n\n\tSG(sapi_headers).http_response_code = !r->status ? HTTP_OK : r->status;\n\tSG(request_info).content_type = apr_table_get(r->headers_in, \"Content-Type\");\n\tSG(request_info).query_string = apr_pstrdup(r->pool, r->args);\n\tSG(request_info).request_method = r->method;\n\tSG(request_info).proto_num = r->proto_num;\n\tSG(request_info).request_uri = apr_pstrdup(r->pool, r->uri);\n\tSG(request_info).path_translated = apr_pstrdup(r->pool, r->filename);\n\tr->no_local_copy = 1;\n\n\tcontent_length = (char *) apr_table_get(r->headers_in, \"Content-Length\");\n\tSG(request_info).content_length = (content_length ? atol(content_length) : 0);\n\n\tapr_table_unset(r->headers_out, \"Content-Length\");\n\tapr_table_unset(r->headers_out, \"Last-Modified\");\n\tapr_table_unset(r->headers_out, \"Expires\");\n\tapr_table_unset(r->headers_out, \"ETag\");\n\n\tauth = apr_table_get(r->headers_in, \"Authorization\");\n\tphp_handle_auth_data(auth TSRMLS_CC);\n\n\tif (SG(request_info).auth_user == NULL && r->user) {\n\t\tSG(request_info).auth_user = estrdup(r->user);\n\t}\n\n\tctx->r->user = apr_pstrdup(ctx->r->pool, SG(request_info).auth_user);\n\n\treturn php_request_startup(TSRMLS_C);\n}\n\nstatic void php_apache_request_dtor(request_rec *r TSRMLS_DC)\n{\n\tphp_request_shutdown(NULL);\n}\n\nstatic void php_apache_ini_dtor(request_rec *r, request_rec *p TSRMLS_DC)\n{\n\tif (strcmp(r->protocol, \"INCLUDED\")) {\n\t\tzend_try { zend_ini_deactivate(TSRMLS_C); } zend_end_try();\n\t} else {\ntypedef struct {\n\tHashTable config;\n} php_conf_rec;\n\t\tchar *str;\n\t\tuint str_len;\n\t\tphp_conf_rec *c = ap_get_module_config(r->per_dir_config, &php5_module);\n\n\t\tfor (zend_hash_internal_pointer_reset(&c->config);\n\t\t\tzend_hash_get_current_key_ex(&c->config, &str, &str_len, NULL, 0,  NULL) == HASH_KEY_IS_STRING;\n\t\t\tzend_hash_move_forward(&c->config)\n\t\t) {\n\t\t\tzend_restore_ini_entry(str, str_len, ZEND_INI_STAGE_SHUTDOWN);\n\t\t}\n\t}\n\tif (p) {\n\t\t((php_struct *)SG(server_context))->r = p;\n\t} else {\n\t\tapr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);\n\t}\n}\n\nstatic int php_handler(request_rec *r)\n{\n\tphp_struct * volatile ctx;\n\tvoid *conf;\n\tapr_bucket_brigade * volatile brigade;\n\tapr_bucket *bucket;\n\tapr_status_t rv;\n\trequest_rec * volatile parent_req = NULL;\n\tTSRMLS_FETCH();\n\n#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);\n\n\tconf = ap_get_module_config(r->per_dir_config, &php5_module);\n\n\t/* apply_config() needs r in some cases, so allocate server_context early */\n\tctx = SG(server_context);\n\tif (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, \"INCLUDED\"))) {\nnormal:\n\t\tctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));\n\t\t/* register a cleanup so we clear out the SG(server_context)\n\t\t * after each request. Note: We pass in the pointer to the\n\t\t * server_context in case this is handled by a different thread.\n\t\t */\n\t\tapr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);\n\t\tctx->r = r;\n\t\tctx = NULL; /* May look weird to null it here, but it is to catch the right case in the first_try later on */\n\t} else {\n\t\tparent_req = ctx->r;\n\t\tctx->r = r;\n\t}\n\tapply_config(conf);\n\n\tif (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {\n\t\t/* Check for xbithack in this case. */\n\t\tif (!AP2(xbithack) || strcmp(r->handler, \"text/html\") || !(r->finfo.protection & APR_UEXECUTE)) {\n\t\t\tPHPAP_INI_OFF;\n\t\t\treturn DECLINED;\n\t\t}\n\t}\n\n\t/* Give a 404 if PATH_INFO is used but is explicitly disabled in\n\t * the configuration; default behaviour is to accept. */\n\tif (r->used_path_info == AP_REQ_REJECT_PATH_INFO\n\t\t&& r->path_info && r->path_info[0]) {\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\n\t/* handle situations where user turns the engine off */\n\tif (!AP2(engine)) {\n\t\tPHPAP_INI_OFF;\n\t\treturn DECLINED;\n\t}\n\n\tif (r->finfo.filetype == 0) {\n\t\tphp_apache_sapi_log_message_ex(\"script '%s' not found or unable to stat\", r TSRMLS_CC);\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_NOT_FOUND;\n\t}\n\tif (r->finfo.filetype == APR_DIR) {\n\t\tphp_apache_sapi_log_message_ex(\"attempt to invoke directory '%s' as script\", r TSRMLS_CC);\n\t\tPHPAP_INI_OFF;\n\t\treturn HTTP_FORBIDDEN;\n\t}\n\n\t/* Setup the CGI variables if this is the main request */\n\tif (r->main == NULL ||\n\t\t/* .. or if the sub-request environment differs from the main-request. */\n\t\tr->subprocess_env != r->main->subprocess_env\n\t) {\n\t\t/* setup standard CGI variables */\n\t\tap_add_common_vars(r);\n\t\tap_add_cgi_vars(r);\n\t}\n\nzend_first_try {\n\n\tif (ctx == NULL) {\n\t\tbrigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);\n\t\tctx = SG(server_context);\n\t\tctx->brigade = brigade;\n\n\t\tif (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {\n\t\t\tzend_bailout();\n\t\t}\n\t} else {\n\t\tif (!parent_req) {\n\t\t\tparent_req = ctx->r;\n\t\t}\n\t\tif (parent_req && parent_req->handler &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_MAGIC_TYPE) &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&\n\t\t\t\tstrcmp(parent_req->handler, PHP_SCRIPT)) {\n\t\t\tif (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {\n\t\t\t\tzend_bailout();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * check if coming due to ErrorDocument\n\t\t * We make a special exception of 413 (Invalid POST request) as the invalidity of the request occurs\n\t\t * during processing of the request by PHP during POST processing. Therefor we need to re-use the exiting\n\t\t * PHP instance to handle the request rather then creating a new one.\n\t\t*/\n\t\tif (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, \"INCLUDED\")) {\n\t\t\tparent_req = NULL;\n\t\t\tgoto normal;\n\t\t}\n\t\tctx->r = r;\n\t\tbrigade = ctx->brigade;\n\t}\n\n\tif (AP2(last_modified)) {\n\t\tap_update_mtime(r, r->finfo.mtime);\n\t\tap_set_last_modified(r);\n\t}\n\n\t/* Determine if we need to parse the file or show the source */\n\tif (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {\n\t\tzend_syntax_highlighter_ini syntax_highlighter_ini;\n\t\tphp_get_highlight_struct(&syntax_highlighter_ini);\n\t\thighlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);\n\t} else {\n\t\tzend_file_handle zfd;\n\n\t\tzfd.type = ZEND_HANDLE_FILENAME;\n\t\tzfd.filename = (char *) r->filename;\n\t\tzfd.free_filename = 0;\n\t\tzfd.opened_path = NULL;\n\n\t\tif (!parent_req) {\n\t\t\tphp_execute_script(&zfd TSRMLS_CC);\n\t\t} else {\n\t\t\tzend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);\n\t\t}\n\n\t\tapr_table_set(r->notes, \"mod_php_memory_usage\",\n\t\t\tapr_psprintf(ctx->r->pool, \"%\" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));\n\t}\n\n} zend_end_try();\n\n\tif (!parent_req) {\n\t\tphp_apache_request_dtor(r TSRMLS_CC);\n\t\tctx->request_processed = 1;\n\t\tapr_brigade_cleanup(brigade);\n\t\tbucket = apr_bucket_eos_create(r->connection->bucket_alloc);\n\t\tAPR_BRIGADE_INSERT_TAIL(brigade, bucket);\n\n\t\trv = ap_pass_brigade(r->output_filters, brigade);\n\t\tif (rv != APR_SUCCESS || r->connection->aborted) {\nzend_first_try {\n\t\t\tphp_handle_aborted_connection();\n} zend_end_try();\n\t\t}\n\t\tapr_brigade_cleanup(brigade);\n\t\tapr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);\n\t} else {\n\t\tctx->r = parent_req;\n\t}\n\n\treturn OK;\n}\n\nstatic void php_apache_child_init(apr_pool_t *pchild, server_rec *s)\n{\n\tapr_pool_cleanup_register(pchild, NULL, php_apache_child_shutdown, apr_pool_cleanup_null);\n}\n\nvoid php_ap2_register_hook(apr_pool_t *p)\n{\n\tap_hook_pre_config(php_pre_config, NULL, NULL, APR_HOOK_MIDDLE);\n\tap_hook_post_config(php_apache_server_startup, NULL, NULL, APR_HOOK_MIDDLE);\n\tap_hook_handler(php_handler, NULL, NULL, APR_HOOK_MIDDLE);\n\tap_hook_child_init(php_apache_child_init, NULL, NULL, APR_HOOK_MIDDLE);\n}\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: sw=4 ts=4 fdm=marker\n * vim<600: sw=4 ts=4\n */\n"], "filenames": ["sapi/apache2handler/sapi_apache2.c"], "buggy_code_start_loc": [680], "buggy_code_end_loc": [680], "fixing_code_start_loc": [681], "fixing_code_end_loc": [682], "type": "CWE-79", "message": "The Apache2 component in PHP before 5.6.38, 7.0.x before 7.0.32, 7.1.x before 7.1.22, and 7.2.x before 7.2.10 allows XSS via the body of a \"Transfer-Encoding: chunked\" request, because the bucket brigade is mishandled in the php_handler function in sapi/apache2handler/sapi_apache2.c.", "other": {"cve": {"id": "CVE-2018-17082", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-16T15:29:00.253", "lastModified": "2019-08-19T11:15:13.930", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The Apache2 component in PHP before 5.6.38, 7.0.x before 7.0.32, 7.1.x before 7.1.22, and 7.2.x before 7.2.10 allows XSS via the body of a \"Transfer-Encoding: chunked\" request, because the bucket brigade is mishandled in the php_handler function in sapi/apache2handler/sapi_apache2.c."}, {"lang": "es", "value": "El componente Apache2 en PHP en versiones anteriores a la 5.6.38, versiones 7.0.x anteriores a la 7.0.32, versiones 7.1.x anteriores a la 7.1.22 y versiones 7.2.x anteriores a la 7.2.10 permite Cross-Site Scripting (XSS) mediante el cuerpo de una petici\u00f3n \"Transfer-Encoding: chunked\". Esto se debe a que bucket brigade se gestiona de manera incorrecta en la funci\u00f3n php_handler en sapi apache2handler sapi_apache2.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.38", "matchCriteriaId": "D9248490-9A20-4460-B86A-24C93003E4F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.32", "matchCriteriaId": "10CEAD5B-EBF6-4F97-8FF5-9A6F7EE4ED63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.1.0", "versionEndExcluding": "7.1.22", "matchCriteriaId": "A5EC8503-F23F-41D8-9C11-E19A5326C23B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.2.0", "versionEndExcluding": "7.2.10", "matchCriteriaId": "328F266C-29A2-458B-8B2F-B83C65EB22BB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:storage_automation_store:-:*:*:*:*:*:*:*", "matchCriteriaId": "7B7A6697-98CC-4E36-93DB-B7160F8399F9"}]}]}], "references": [{"url": "http://php.net/ChangeLog-5.php", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://php.net/ChangeLog-7.php", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2519", "source": "cve@mitre.org"}, {"url": "https://bugs.php.net/bug.php?id=76582", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/php/php-src/commit/23b057742e3cf199612fa8050ae86cae675e214e", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/09/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201812-01", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20180924-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4353", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.tenable.com/security/tns-2019-07", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/php/php-src/commit/23b057742e3cf199612fa8050ae86cae675e214e"}}