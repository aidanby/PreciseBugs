{"buggy_code": ["/*!\n   Flowplayer : The Video Player for Web\n\n   Copyright (c) 2008-2012 Flowplayer Ltd\n   http://flowplayer.org\n\n   Author: Tero Piirainen\n\n   -----\n\n   This GPL version includes Flowplayer branding\n\n   http://flowplayer.org/GPL-license/#term-7\n\n   Commercial versions are available\n      * part of the upgrade cycle\n      * support the player development\n      * no Flowplayer trademark\n\n   http://flowplayer.org/download/\n*/\npackage {\n\nimport flash.display.Sprite;\nimport flash.display.StageAlign;\nimport flash.display.StageScaleMode;\nimport flash.events.*;\nimport flash.external.ExternalInterface;\nimport flash.media.SoundTransform;\nimport flash.media.Video;\nimport flash.net.NetConnection;\nimport flash.net.NetStream;\nimport flash.system.Security;\nimport flash.utils.Timer;\nimport flash.utils.setTimeout;\n\npublic class Flowplayer extends Sprite {\n\n      // events\n      private static const PLAY:String       = \"play\";\n      private static const READY:String      = \"ready\";\n      private static const PAUSE:String      = \"pause\";\n      private static const RESUME:String     = \"resume\";\n      private static const SEEK:String       = \"seek\";\n      private static const STATUS:String     = \"status\";\n      private static const BUFFERED:String   = \"buffered\";\n      private static const VOLUME:String     = \"volume\";\n      private static const FINISH:String     = \"finish\";\n      private static const UNLOAD:String     = \"unload\";\n      private static const ERROR:String      = \"error\";\n\n      // external interface\n      private static const INTERFACE:Array\n         = new Array(PLAY, PAUSE, RESUME, SEEK, VOLUME, UNLOAD);\n\n      // flashvars\n      private var conf:Object;\n\n      // state\n      private var preloadComplete:Boolean;\n      private var finished:Boolean;\n      private var paused:Boolean;\n      private var ready:Boolean;\n      private var volumeLevel:Number;\n\n      // clip hack properties\n      private var seekTo:Number;\n      private var clipUrl:String;\n\n      // video stream\n      private var conn:NetConnection;\n      private var stream:NetStream;\n      private var video:Video;\n      private var logo:Logo;\n\n      private var timer:Timer;\n\n\n      /* constructor */\n      public function Flowplayer() {\n         Security.allowDomain(\"*\");\n         stage.scaleMode = StageScaleMode.NO_SCALE;\n         stage.align = StageAlign.TOP_LEFT;\n\n         conf = this.loaderInfo.parameters;\n\n         // The API\n         for (var i:Number = 0; i < INTERFACE.length; i++) {\n            ExternalInterface.addCallback(\"__\" + INTERFACE[i], this[INTERFACE[i]]);\n         }\n\n         // IE needs mouse / keyboard events\n         stage.addEventListener(MouseEvent.CLICK, function(e:MouseEvent):void {\n            fire(\"click\", null);\n         });\n\n         stage.addEventListener(KeyboardEvent.KEY_DOWN, function(e:KeyboardEvent):void {\n            fire(\"keydown\", e.keyCode);\n         });\n\n         stage.addEventListener(Event.RESIZE, arrange);\n\n         // timeupdate event\n         timer = new Timer(250);\n         timer.addEventListener(\"timer\", timeupdate);\n\n         init();\n      }\n\n      /************ Public API ************/\n\n      // switch url\n      public function play(url:String):void {\n         debug(\"play\");\n         if (ready) {\n            url = unescape(url);\n            conf.autoplay = true; // always begin playback\n            if (conf.rtmp) conn.connect(conf.rtmp);\n            stream.play(url);\n            conf.url = url;\n            paused = ready = false;\n            startTimer();\n         }\n      }\n\n      public function pause():void {\n          debug(\"pause()\");\n         if (ready && !paused) {\n            stream.pause();\n            fire(PAUSE, null);\n            paused = true;\n         }\n      }\n\n      public function resume():void {\n         debug(\"resume()\", { ready: ready,  preloadComplete: preloadComplete, splash: conf.splash });\n         if (!ready) return;\n         if (preloadComplete && !paused) return;\n\n         if (!conf.autoplay) {\n             volume(1, false);\n         }\n\n         try {\n             if (doPreload() && ! preloadComplete) {\n                 debug(\"preload == none, starting stream.play()\");\n                 conf.autoplay = true;\n                 paused = false;\n                 stream.play(conf.url);\n             } else {\n                 if (finished) { seek(0); }\n                 paused = false;\n                 conf.autoplay = true;\n                 if (stream.time == 0 && !conf.rtmp) {\n                     debug(\"playing stream\");\n                     stream.play(conf.url);\n                 } else {\n                     debug(\"resuming stream\");\n                     stream.resume();\n                 }\n             }\n             debug(\"firing RESUME\");\n             fire(RESUME, null);\n         } catch (e:Error) {\n             debug(\"resume(), error\", e);\n             // net stream is invalid, because of a timeout\n             conn.connect(conf.rtmp);\n             conf.autoplay = true;\n             ready = true;\n             stream.play(conf.url);\n         }\n         startTimer();\n      }\n\n    private function doPreload():Boolean {\n        var result:Boolean = !conf.splash && conf.preload == \"none\";\n        debug(\"preload enabled? \" + result);\n        return result;\n    }\n\n      public function seek(seconds:Number):void {\n         if (ready) {\n            seekTo = seconds;\n            stream.seek(seconds);\n         }\n      }\n\n      public function volume(level:Number, fireEvent:Boolean = true):void {\n          debug(\"volume(), setting to \" + level + \" (was at \" + volumeLevel + \")\");\n          if (stream && volumeLevel != level) {\n              debug(\"setting volume to \" + level);\n            if (level > 1) level = 1;\n            else if (level < 0) level = 0;\n\n            stream.soundTransform = new SoundTransform(level);\n            volumeLevel = level;\n            if (fireEvent) {\n               fire(VOLUME, level);\n            }\n         }\n      }\n\n\n      public function unload():void {\n          debug(\"unload\");\n         if (ready) {\n            pause();\n            stream.close();\n            conn.close();\n            fire(UNLOAD, null);\n         }\n      }\n\n\n      /************* Private API ***********/\n\n\n      // setup video stream\n      private function init(): void {\n         initVideo();\n      }\n\n      private function initVideo():void {\n         debug(\"initVideo()\", conf);\n         video = new Video();\n         video.smoothing = true;\n         this.addChild(video);\n         logo = new Logo();\n         addChild(logo);\n         arrange();\n\n         conf.url = unescape(conf.url);\n\n         if (conf.debug) fire(\"debug.url\", conf.url);\n\n         conn = new NetConnection();\n\n         // RTMP requires this\n         conn.client = { onBWDone:function ():void {} };\n\n         paused = !conf.autoplay;\n         preloadComplete = false;\n\n         if (conf.autoplay) {\n            startTimer();\n         }\n\n         conn.addEventListener(NetStatusEvent.NET_STATUS, function (e:NetStatusEvent):void {\n\n            if (conf.debug) fire(\"debug.conn\", e.info);\n\n            switch (e.info.code) {\n\n               case \"NetConnection.Connect.Success\":\n                  debug(\"NetConnection.Connect.Success\", { ready: ready, preloadCompete: preloadComplete, paused: paused, autoplay: conf.autoplay });\n                  stream = new NetStream(conn);\n                  video.attachNetStream(stream);\n\n                  // set volume to zero so that we don't hear anything if stopping on first frame\n                  if (!conf.autoplay) {\n                     volume(0, false);\n                  }\n\n                  fire(\"debug-preloadComplete = \" + preloadComplete, null);\n                  // start streaming\n\n                   if (doPreload() && !preloadComplete) {\n                       ready = true;\n                       fire(Flowplayer.READY, {\n                           seekable: !!conf.rtmp,\n                           bytes: stream.bytesTotal,\n                           src: conf.url,\n                           url: conf.url\n                       });\n                       fire(Flowplayer.PAUSE, null);\n\n                       // we pause when metadata is received\n                   } else {\n                       debug(\"starting play\");\n                       stream.play(conf.url);\n                       if (conf.autoplay) {\n                           startTimer();\n                       }\n                   }\n\n                  // metadata\n                  stream.client = {\n\n                      onPlayStatus: function (info:Object):void {\n                          debug(\"onPlayStatus\", info);\n                          if (info.code == \"NetStream.Play.Complete\") {\n                              finished = true;\n                              if (conf.loop) {\n                                  stream.seek(0);\n                              }  else {\n                                  paused = true;\n                                  fire(Flowplayer.FINISH, null);\n                              }\n                          }\n                      },\n\n                      onMetaData:function (info:Object):void {\n                          debug(\"onMetaData()\", { ready: ready, preloadCompete: preloadComplete, paused: paused, autoplay: conf.autoplay });\n\n                        // use a real object\n                        var meta:Object = { seekpoints: [] };\n                        for (var key:String in info) { meta[key] = info[key]; }\n                        if (conf.debug) fire(\"debug.metadata\", meta);\n\n                        var clip:Object = {\n                           seekable: !!conf.rtmp,\n                           bytes: stream.bytesTotal,\n                           duration: meta.duration,\n                           height: meta.height,\n                           width: meta.width,\n                           seekpoints: meta.seekpoints,\n                           src: conf.url,\n                           url: conf.url\n                        };\n\n                        if (!ready) {\n                            ready = true;\n\n                           fire(Flowplayer.READY, clip);\n                           if (conf.autoplay) fire(Flowplayer.RESUME, null);\n\n                           // stop at first frame\n                            if (!conf.autoplay) {\n                                volume(1);\n                                stream.pause();\n                            }\n                        }\n\n                        if (doPreload() && !preloadComplete) {\n                            preloadComplete = true;\n                            fire(Flowplayer.READY, clip);\n                            fire(Flowplayer.RESUME, null);\n                        }\n                     }\n                  };\n\n                  // listen for playback events\n                  stream.addEventListener(NetStatusEvent.NET_STATUS, function (e:NetStatusEvent):void {\n\n                     if (conf.debug) fire(\"debug.stream\", e.info.code);\n\n                     switch (e.info.code) {\n\n                        case \"NetStream.Play.Start\":\n\n                           finished = false;\n\n                           // RTMP fires start a lot\n                           if (!conf.rtmp) {\n                              if (conf.autoplay) {\n                                 paused = false;\n\n                              // stop at first frame\n                              }\n                           }\n                           break;\n\n                        case \"NetStream.Seek.Notify\":\n                           finished = false;\n                           timeupdate(true);\n                           fire(Flowplayer.SEEK, seekTo);\n                           break;\n\n                        case \"NetStream.Buffer.Full\":\n                           fire(Flowplayer.BUFFERED, null);\n                           break;\n\n                        case \"NetStream.Play.StreamNotFound\": case \"NetStream.Play.Failed\":\n                           finished = true;\n                           fire(Flowplayer.ERROR, { code:4 });\n                           break;\n\n                     }\n\n                  });\n\n                  break;\n\n               case \"NetConnection.Connect.Failed\":\n                  fire(Flowplayer.ERROR, { code: 9, url: conf.rtmp });\n                  break;\n\n               case \"NetConnection.Connect.Closed\":\n                  ready = false;\n                  // fire(\"close\", null);\n                  break;\n\n            }\n\n         });\n\n         conn.addEventListener(SecurityErrorEvent.SECURITY_ERROR, function (e:SecurityError):void {\n            fire(Flowplayer.ERROR, e.message);\n         });\n\n         conn.connect(conf.rtmp);\n      }\n\n    private function startTimer():void {\n        debug(\"starting progress timer\");\n        timer.start();\n    }\n\n\n\n      private function timeupdate(e:Object):void {\n         if (ready) {\n            var buffer:Number = stream.bytesLoaded,\n               delta:Number = stream.bytesTotal - buffer;\n\n            // first frame & no preload\n            if (!conf.autoplay && !conf.preload && !conf.rtmp) { stream.close(); }\n\n            // http://www.brooksandrus.com/blog/2008/11/05/3-years-later-netstream-still-sucks/\n            if (e === true) {\n               fire(STATUS, { time: seekTo, buffer: buffer });\n               setTimeout(function():void { seekTo = 0; }, 100);\n\n            } else if (!(paused || finished || seekTo) || delta > 0) {\n               fire(STATUS, { time: stream.time, buffer: buffer });\n            }\n         }\n      }\n\n    private function debug(msg:String, data:Object = null):void {\n        if (!conf.debug) return;\n        fire(\"debug: \" + msg, data);\n    }\n\n    private function fire(type:String, data:Object = null):void {\n        if (conf.callback) {\n            if (data) {\n                ExternalInterface.call(conf.callback, type, data);\n            } else {\n                ExternalInterface.call(conf.callback, type);\n            }\n      }\n    }\n\n      private function arrange(e:Event = null):void {\n         logo.x = 12;\n         logo.y = stage.stageHeight - 50;\n         video.width = stage.stageWidth;\n         video.height = stage.stageHeight;\n      };\n\n   }\n\n}\n"], "fixing_code": ["/*!\n   Flowplayer : The Video Player for Web\n\n   Copyright (c) 2008-2012 Flowplayer Ltd\n   http://flowplayer.org\n\n   Author: Tero Piirainen\n\n   -----\n\n   This GPL version includes Flowplayer branding\n\n   http://flowplayer.org/GPL-license/#term-7\n\n   Commercial versions are available\n      * part of the upgrade cycle\n      * support the player development\n      * no Flowplayer trademark\n\n   http://flowplayer.org/download/\n*/\npackage {\n\nimport flash.display.Sprite;\nimport flash.display.StageAlign;\nimport flash.display.StageScaleMode;\nimport flash.events.*;\nimport flash.external.ExternalInterface;\nimport flash.media.SoundTransform;\nimport flash.media.Video;\nimport flash.net.NetConnection;\nimport flash.net.NetStream;\nimport flash.system.Security;\nimport flash.utils.Timer;\nimport flash.utils.setTimeout;\n\npublic class Flowplayer extends Sprite {\n\n      // events\n      private static const PLAY:String       = \"play\";\n      private static const READY:String      = \"ready\";\n      private static const PAUSE:String      = \"pause\";\n      private static const RESUME:String     = \"resume\";\n      private static const SEEK:String       = \"seek\";\n      private static const STATUS:String     = \"status\";\n      private static const BUFFERED:String   = \"buffered\";\n      private static const VOLUME:String     = \"volume\";\n      private static const FINISH:String     = \"finish\";\n      private static const UNLOAD:String     = \"unload\";\n      private static const ERROR:String      = \"error\";\n\n      // external interface\n      private static const INTERFACE:Array\n         = new Array(PLAY, PAUSE, RESUME, SEEK, VOLUME, UNLOAD);\n\n      // flashvars\n      private var conf:Object;\n\n      // state\n      private var preloadComplete:Boolean;\n      private var finished:Boolean;\n      private var paused:Boolean;\n      private var ready:Boolean;\n      private var volumeLevel:Number;\n\n      // clip hack properties\n      private var seekTo:Number;\n      private var clipUrl:String;\n\n      // video stream\n      private var conn:NetConnection;\n      private var stream:NetStream;\n      private var video:Video;\n      private var logo:Logo;\n\n      private var timer:Timer;\n\n\n      /* constructor */\n      public function Flowplayer() {\n         Security.allowDomain(\"*\");\n         stage.scaleMode = StageScaleMode.NO_SCALE;\n         stage.align = StageAlign.TOP_LEFT;\n\n         if (this.loaderInfo.url.indexOf(\"callback=\") > 0) throw new Error(\"Security error\");\n         conf = this.loaderInfo.parameters;\n\n         // The API\n         for (var i:Number = 0; i < INTERFACE.length; i++) {\n            ExternalInterface.addCallback(\"__\" + INTERFACE[i], this[INTERFACE[i]]);\n         }\n\n         // IE needs mouse / keyboard events\n         stage.addEventListener(MouseEvent.CLICK, function(e:MouseEvent):void {\n            fire(\"click\", null);\n         });\n\n         stage.addEventListener(KeyboardEvent.KEY_DOWN, function(e:KeyboardEvent):void {\n            fire(\"keydown\", e.keyCode);\n         });\n\n         stage.addEventListener(Event.RESIZE, arrange);\n\n         // timeupdate event\n         timer = new Timer(250);\n         timer.addEventListener(\"timer\", timeupdate);\n\n         init();\n      }\n\n      /************ Public API ************/\n\n      // switch url\n      public function play(url:String):void {\n         debug(\"play\");\n         if (ready) {\n            url = unescape(url);\n            conf.autoplay = true; // always begin playback\n            if (conf.rtmp) conn.connect(conf.rtmp);\n            stream.play(url);\n            conf.url = url;\n            paused = ready = false;\n            startTimer();\n         }\n      }\n\n      public function pause():void {\n          debug(\"pause()\");\n         if (ready && !paused) {\n            stream.pause();\n            fire(PAUSE, null);\n            paused = true;\n         }\n      }\n\n      public function resume():void {\n         debug(\"resume()\", { ready: ready,  preloadComplete: preloadComplete, splash: conf.splash });\n         if (!ready) return;\n         if (preloadComplete && !paused) return;\n\n         if (!conf.autoplay) {\n             volume(1, false);\n         }\n\n         try {\n             if (doPreload() && ! preloadComplete) {\n                 debug(\"preload == none, starting stream.play()\");\n                 conf.autoplay = true;\n                 paused = false;\n                 stream.play(conf.url);\n             } else {\n                 if (finished) { seek(0); }\n                 paused = false;\n                 conf.autoplay = true;\n                 if (stream.time == 0 && !conf.rtmp) {\n                     debug(\"playing stream\");\n                     stream.play(conf.url);\n                 } else {\n                     debug(\"resuming stream\");\n                     stream.resume();\n                 }\n             }\n             debug(\"firing RESUME\");\n             fire(RESUME, null);\n         } catch (e:Error) {\n             debug(\"resume(), error\", e);\n             // net stream is invalid, because of a timeout\n             conn.connect(conf.rtmp);\n             conf.autoplay = true;\n             ready = true;\n             stream.play(conf.url);\n         }\n         startTimer();\n      }\n\n    private function doPreload():Boolean {\n        var result:Boolean = !conf.splash && conf.preload == \"none\";\n        debug(\"preload enabled? \" + result);\n        return result;\n    }\n\n      public function seek(seconds:Number):void {\n         if (ready) {\n            seekTo = seconds;\n            stream.seek(seconds);\n         }\n      }\n\n      public function volume(level:Number, fireEvent:Boolean = true):void {\n          debug(\"volume(), setting to \" + level + \" (was at \" + volumeLevel + \")\");\n          if (stream && volumeLevel != level) {\n              debug(\"setting volume to \" + level);\n            if (level > 1) level = 1;\n            else if (level < 0) level = 0;\n\n            stream.soundTransform = new SoundTransform(level);\n            volumeLevel = level;\n            if (fireEvent) {\n               fire(VOLUME, level);\n            }\n         }\n      }\n\n\n      public function unload():void {\n          debug(\"unload\");\n         if (ready) {\n            pause();\n            stream.close();\n            conn.close();\n            fire(UNLOAD, null);\n         }\n      }\n\n\n      /************* Private API ***********/\n\n\n      // setup video stream\n      private function init(): void {\n         initVideo();\n      }\n\n      private function initVideo():void {\n         debug(\"initVideo()\", conf);\n         video = new Video();\n         video.smoothing = true;\n         this.addChild(video);\n         logo = new Logo();\n         addChild(logo);\n         arrange();\n\n         conf.url = unescape(conf.url);\n\n         debug(\"debug.url\", conf.url);\n\n         conn = new NetConnection();\n\n         // RTMP requires this\n         conn.client = { onBWDone:function ():void {} };\n\n         paused = !conf.autoplay;\n         preloadComplete = false;\n\n         if (conf.autoplay) {\n            startTimer();\n         }\n\n         conn.addEventListener(NetStatusEvent.NET_STATUS, function (e:NetStatusEvent):void {\n\n            if (conf.debug) fire(\"debug.conn\", e.info);\n\n            switch (e.info.code) {\n\n               case \"NetConnection.Connect.Success\":\n                  debug(\"NetConnection.Connect.Success\", { ready: ready, preloadCompete: preloadComplete, paused: paused, autoplay: conf.autoplay });\n                  stream = new NetStream(conn);\n                  video.attachNetStream(stream);\n\n                  // set volume to zero so that we don't hear anything if stopping on first frame\n                  if (!conf.autoplay) {\n                     volume(0, false);\n                  }\n\n                  fire(\"debug-preloadComplete = \" + preloadComplete, null);\n                  // start streaming\n\n                   if (doPreload() && !preloadComplete) {\n                       ready = true;\n                       fire(Flowplayer.READY, {\n                           seekable: !!conf.rtmp,\n                           bytes: stream.bytesTotal,\n                           src: conf.url,\n                           url: conf.url\n                       });\n                       fire(Flowplayer.PAUSE, null);\n\n                       // we pause when metadata is received\n                   } else {\n                       debug(\"starting play\");\n                       stream.play(conf.url);\n                       if (conf.autoplay) {\n                           startTimer();\n                       }\n                   }\n\n                  // metadata\n                  stream.client = {\n\n                      onPlayStatus: function (info:Object):void {\n                          debug(\"onPlayStatus\", info);\n                          if (info.code == \"NetStream.Play.Complete\") {\n                              finished = true;\n                              if (conf.loop) {\n                                  stream.seek(0);\n                              }  else {\n                                  paused = true;\n                                  fire(Flowplayer.FINISH, null);\n                              }\n                          }\n                      },\n\n                      onMetaData:function (info:Object):void {\n                          debug(\"onMetaData()\", { ready: ready, preloadCompete: preloadComplete, paused: paused, autoplay: conf.autoplay });\n\n                        // use a real object\n                        var meta:Object = { seekpoints: [] };\n                        for (var key:String in info) { meta[key] = info[key]; }\n                        if (conf.debug) fire(\"debug.metadata\", meta);\n\n                        var clip:Object = {\n                           seekable: !!conf.rtmp,\n                           bytes: stream.bytesTotal,\n                           duration: meta.duration,\n                           height: meta.height,\n                           width: meta.width,\n                           seekpoints: meta.seekpoints,\n                           src: conf.url,\n                           url: conf.url\n                        };\n\n                        if (!ready) {\n                            ready = true;\n\n                           fire(Flowplayer.READY, clip);\n                           if (conf.autoplay) fire(Flowplayer.RESUME, null);\n\n                           // stop at first frame\n                            if (!conf.autoplay) {\n                                volume(1);\n                                stream.pause();\n                            }\n                        }\n\n                        if (doPreload() && !preloadComplete) {\n                            preloadComplete = true;\n                            fire(Flowplayer.READY, clip);\n                            fire(Flowplayer.RESUME, null);\n                        }\n                     }\n                  };\n\n                  // listen for playback events\n                  stream.addEventListener(NetStatusEvent.NET_STATUS, function (e:NetStatusEvent):void {\n\n                     if (conf.debug) fire(\"debug.stream\", e.info.code);\n\n                     switch (e.info.code) {\n\n                        case \"NetStream.Play.Start\":\n\n                           finished = false;\n\n                           // RTMP fires start a lot\n                           if (!conf.rtmp) {\n                              if (conf.autoplay) {\n                                 paused = false;\n\n                              // stop at first frame\n                              }\n                           }\n                           break;\n\n                        case \"NetStream.Seek.Notify\":\n                           finished = false;\n                           timeupdate(true);\n                           fire(Flowplayer.SEEK, seekTo);\n                           break;\n\n                        case \"NetStream.Buffer.Full\":\n                           fire(Flowplayer.BUFFERED, null);\n                           break;\n\n                        case \"NetStream.Play.StreamNotFound\": case \"NetStream.Play.Failed\":\n                           finished = true;\n                           fire(Flowplayer.ERROR, { code:4 });\n                           break;\n\n                     }\n\n                  });\n\n                  break;\n\n               case \"NetConnection.Connect.Failed\":\n                  fire(Flowplayer.ERROR, { code: 9, url: conf.rtmp });\n                  break;\n\n               case \"NetConnection.Connect.Closed\":\n                  ready = false;\n                  // fire(\"close\", null);\n                  break;\n\n            }\n\n         });\n\n         conn.addEventListener(SecurityErrorEvent.SECURITY_ERROR, function (e:SecurityError):void {\n            fire(Flowplayer.ERROR, e.message);\n         });\n\n         conn.connect(conf.rtmp);\n      }\n\n    private function startTimer():void {\n        debug(\"starting progress timer\");\n        timer.start();\n    }\n\n\n\n      private function timeupdate(e:Object):void {\n         if (ready) {\n            var buffer:Number = stream.bytesLoaded,\n               delta:Number = stream.bytesTotal - buffer;\n\n            // first frame & no preload\n            if (!conf.autoplay && !conf.preload && !conf.rtmp) { stream.close(); }\n\n            // http://www.brooksandrus.com/blog/2008/11/05/3-years-later-netstream-still-sucks/\n            if (e === true) {\n               fire(STATUS, { time: seekTo, buffer: buffer });\n               setTimeout(function():void { seekTo = 0; }, 100);\n\n            } else if (!(paused || finished || seekTo) || delta > 0) {\n               fire(STATUS, { time: stream.time, buffer: buffer });\n            }\n         }\n      }\n\n    private function debug(msg:String, data:Object = null):void {\n        if (!conf.debug) return;\n        fire(\"debug: \" + msg, data);\n//        ExternalInterface.call(\"console.log\", msg, data);\n    }\n\n    private function fire(type:String, data:Object = null):void {\n        if (conf.callback) {\n            if (data) {\n                ExternalInterface.call(conf.callback, type, data);\n            } else {\n                ExternalInterface.call(conf.callback, type);\n            }\n      }\n    }\n\n      private function arrange(e:Event = null):void {\n         logo.x = 12;\n         logo.y = stage.stageHeight - 50;\n         video.width = stage.stageWidth;\n         video.height = stage.stageHeight;\n      };\n\n   }\n\n}\n"], "filenames": ["lib/as/Flowplayer.as"], "buggy_code_start_loc": [84], "buggy_code_end_loc": [432], "fixing_code_start_loc": [85], "fixing_code_end_loc": [435], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in flowplayer.swf in the Flash fallback feature in Flowplayer HTML5 5.4.1 allows remote attackers to inject arbitrary web script or HTML via the callback parameter, a related issue to CVE-2013-7341.", "other": {"cve": {"id": "CVE-2013-7342", "sourceIdentifier": "cve@mitre.org", "published": "2014-03-24T14:20:39.357", "lastModified": "2014-03-24T15:14:32.543", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in flowplayer.swf in the Flash fallback feature in Flowplayer HTML5 5.4.1 allows remote attackers to inject arbitrary web script or HTML via the callback parameter, a related issue to CVE-2013-7341."}, {"lang": "es", "value": "Vulnerabilidad de XSS en flowplayer.swf en la funcionalidad de reserva de Flash en Flowplayer HTML5 5.4.1 permite a atacantes remotos inyectar script Web o HTML arbitrarios a trav\u00e9s del par\u00e1metro callback, un problema relacionado con CVE-2013-7341."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flowplayer:flowplayer_html5:5.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "3E3700E1-7C93-43ED-A255-5C8C6E4CAF86"}]}]}], "references": [{"url": "https://github.com/flowplayer/flowplayer/commit/017f8c2a0865ab31e01d591adc43d34f2dd60e59", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://github.com/flowplayer/flowplayer/issues/381", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/flowplayer/flowplayer/commit/017f8c2a0865ab31e01d591adc43d34f2dd60e59"}}