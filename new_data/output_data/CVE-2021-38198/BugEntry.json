{"buggy_code": [".. SPDX-License-Identifier: GPL-2.0\n\n======================\nThe x86 kvm shadow mmu\n======================\n\nThe mmu (in arch/x86/kvm, files mmu.[ch] and paging_tmpl.h) is responsible\nfor presenting a standard x86 mmu to the guest, while translating guest\nphysical addresses to host physical addresses.\n\nThe mmu code attempts to satisfy the following requirements:\n\n- correctness:\n\t       the guest should not be able to determine that it is running\n               on an emulated mmu except for timing (we attempt to comply\n               with the specification, not emulate the characteristics of\n               a particular implementation such as tlb size)\n- security:\n\t       the guest must not be able to touch host memory not assigned\n               to it\n- performance:\n               minimize the performance penalty imposed by the mmu\n- scaling:\n               need to scale to large memory and large vcpu guests\n- hardware:\n               support the full range of x86 virtualization hardware\n- integration:\n               Linux memory management code must be in control of guest memory\n               so that swapping, page migration, page merging, transparent\n               hugepages, and similar features work without change\n- dirty tracking:\n               report writes to guest memory to enable live migration\n               and framebuffer-based displays\n- footprint:\n               keep the amount of pinned kernel memory low (most memory\n               should be shrinkable)\n- reliability:\n               avoid multipage or GFP_ATOMIC allocations\n\nAcronyms\n========\n\n====  ====================================================================\npfn   host page frame number\nhpa   host physical address\nhva   host virtual address\ngfn   guest frame number\ngpa   guest physical address\ngva   guest virtual address\nngpa  nested guest physical address\nngva  nested guest virtual address\npte   page table entry (used also to refer generically to paging structure\n      entries)\ngpte  guest pte (referring to gfns)\nspte  shadow pte (referring to pfns)\ntdp   two dimensional paging (vendor neutral term for NPT and EPT)\n====  ====================================================================\n\nVirtual and real hardware supported\n===================================\n\nThe mmu supports first-generation mmu hardware, which allows an atomic switch\nof the current paging mode and cr3 during guest entry, as well as\ntwo-dimensional paging (AMD's NPT and Intel's EPT).  The emulated hardware\nit exposes is the traditional 2/3/4 level x86 mmu, with support for global\npages, pae, pse, pse36, cr0.wp, and 1GB pages. Emulated hardware also\nable to expose NPT capable hardware on NPT capable hosts.\n\nTranslation\n===========\n\nThe primary job of the mmu is to program the processor's mmu to translate\naddresses for the guest.  Different translations are required at different\ntimes:\n\n- when guest paging is disabled, we translate guest physical addresses to\n  host physical addresses (gpa->hpa)\n- when guest paging is enabled, we translate guest virtual addresses, to\n  guest physical addresses, to host physical addresses (gva->gpa->hpa)\n- when the guest launches a guest of its own, we translate nested guest\n  virtual addresses, to nested guest physical addresses, to guest physical\n  addresses, to host physical addresses (ngva->ngpa->gpa->hpa)\n\nThe primary challenge is to encode between 1 and 3 translations into hardware\nthat support only 1 (traditional) and 2 (tdp) translations.  When the\nnumber of required translations matches the hardware, the mmu operates in\ndirect mode; otherwise it operates in shadow mode (see below).\n\nMemory\n======\n\nGuest memory (gpa) is part of the user address space of the process that is\nusing kvm.  Userspace defines the translation between guest addresses and user\naddresses (gpa->hva); note that two gpas may alias to the same hva, but not\nvice versa.\n\nThese hvas may be backed using any method available to the host: anonymous\nmemory, file backed memory, and device memory.  Memory might be paged by the\nhost at any time.\n\nEvents\n======\n\nThe mmu is driven by events, some from the guest, some from the host.\n\nGuest generated events:\n\n- writes to control registers (especially cr3)\n- invlpg/invlpga instruction execution\n- access to missing or protected translations\n\nHost generated events:\n\n- changes in the gpa->hpa translation (either through gpa->hva changes or\n  through hva->hpa changes)\n- memory pressure (the shrinker)\n\nShadow pages\n============\n\nThe principal data structure is the shadow page, 'struct kvm_mmu_page'.  A\nshadow page contains 512 sptes, which can be either leaf or nonleaf sptes.  A\nshadow page may contain a mix of leaf and nonleaf sptes.\n\nA nonleaf spte allows the hardware mmu to reach the leaf pages and\nis not related to a translation directly.  It points to other shadow pages.\n\nA leaf spte corresponds to either one or two translations encoded into\none paging structure entry.  These are always the lowest level of the\ntranslation stack, with optional higher level translations left to NPT/EPT.\nLeaf ptes point at guest pages.\n\nThe following table shows translations encoded by leaf ptes, with higher-level\ntranslations in parentheses:\n\n Non-nested guests::\n\n  nonpaging:     gpa->hpa\n  paging:        gva->gpa->hpa\n  paging, tdp:   (gva->)gpa->hpa\n\n Nested guests::\n\n  non-tdp:       ngva->gpa->hpa  (*)\n  tdp:           (ngva->)ngpa->gpa->hpa\n\n  (*) the guest hypervisor will encode the ngva->gpa translation into its page\n      tables if npt is not present\n\nShadow pages contain the following information:\n  role.level:\n    The level in the shadow paging hierarchy that this shadow page belongs to.\n    1=4k sptes, 2=2M sptes, 3=1G sptes, etc.\n  role.direct:\n    If set, leaf sptes reachable from this page are for a linear range.\n    Examples include real mode translation, large guest pages backed by small\n    host pages, and gpa->hpa translations when NPT or EPT is active.\n    The linear range starts at (gfn << PAGE_SHIFT) and its size is determined\n    by role.level (2MB for first level, 1GB for second level, 0.5TB for third\n    level, 256TB for fourth level)\n    If clear, this page corresponds to a guest page table denoted by the gfn\n    field.\n  role.quadrant:\n    When role.gpte_is_8_bytes=0, the guest uses 32-bit gptes while the host uses 64-bit\n    sptes.  That means a guest page table contains more ptes than the host,\n    so multiple shadow pages are needed to shadow one guest page.\n    For first-level shadow pages, role.quadrant can be 0 or 1 and denotes the\n    first or second 512-gpte block in the guest page table.  For second-level\n    page tables, each 32-bit gpte is converted to two 64-bit sptes\n    (since each first-level guest page is shadowed by two first-level\n    shadow pages) so role.quadrant takes values in the range 0..3.  Each\n    quadrant maps 1GB virtual address space.\n  role.access:\n    Inherited guest access permissions in the form uwx.  Note execute\n    permission is positive, not negative.\n  role.invalid:\n    The page is invalid and should not be used.  It is a root page that is\n    currently pinned (by a cpu hardware register pointing to it); once it is\n    unpinned it will be destroyed.\n  role.gpte_is_8_bytes:\n    Reflects the size of the guest PTE for which the page is valid, i.e. '1'\n    if 64-bit gptes are in use, '0' if 32-bit gptes are in use.\n  role.nxe:\n    Contains the value of efer.nxe for which the page is valid.\n  role.cr0_wp:\n    Contains the value of cr0.wp for which the page is valid.\n  role.smep_andnot_wp:\n    Contains the value of cr4.smep && !cr0.wp for which the page is valid\n    (pages for which this is true are different from other pages; see the\n    treatment of cr0.wp=0 below).\n  role.smap_andnot_wp:\n    Contains the value of cr4.smap && !cr0.wp for which the page is valid\n    (pages for which this is true are different from other pages; see the\n    treatment of cr0.wp=0 below).\n  role.ept_sp:\n    This is a virtual flag to denote a shadowed nested EPT page.  ept_sp\n    is true if \"cr0_wp && smap_andnot_wp\", an otherwise invalid combination.\n  role.smm:\n    Is 1 if the page is valid in system management mode.  This field\n    determines which of the kvm_memslots array was used to build this\n    shadow page; it is also used to go back from a struct kvm_mmu_page\n    to a memslot, through the kvm_memslots_for_spte_role macro and\n    __gfn_to_memslot.\n  role.ad_disabled:\n    Is 1 if the MMU instance cannot use A/D bits.  EPT did not have A/D\n    bits before Haswell; shadow EPT page tables also cannot use A/D bits\n    if the L1 hypervisor does not enable them.\n  gfn:\n    Either the guest page table containing the translations shadowed by this\n    page, or the base page frame for linear translations.  See role.direct.\n  spt:\n    A pageful of 64-bit sptes containing the translations for this page.\n    Accessed by both kvm and hardware.\n    The page pointed to by spt will have its page->private pointing back\n    at the shadow page structure.\n    sptes in spt point either at guest pages, or at lower-level shadow pages.\n    Specifically, if sp1 and sp2 are shadow pages, then sp1->spt[n] may point\n    at __pa(sp2->spt).  sp2 will point back at sp1 through parent_pte.\n    The spt array forms a DAG structure with the shadow page as a node, and\n    guest pages as leaves.\n  gfns:\n    An array of 512 guest frame numbers, one for each present pte.  Used to\n    perform a reverse map from a pte to a gfn. When role.direct is set, any\n    element of this array can be calculated from the gfn field when used, in\n    this case, the array of gfns is not allocated. See role.direct and gfn.\n  root_count:\n    A counter keeping track of how many hardware registers (guest cr3 or\n    pdptrs) are now pointing at the page.  While this counter is nonzero, the\n    page cannot be destroyed.  See role.invalid.\n  parent_ptes:\n    The reverse mapping for the pte/ptes pointing at this page's spt. If\n    parent_ptes bit 0 is zero, only one spte points at this page and\n    parent_ptes points at this single spte, otherwise, there exists multiple\n    sptes pointing at this page and (parent_ptes & ~0x1) points at a data\n    structure with a list of parent sptes.\n  unsync:\n    If true, then the translations in this page may not match the guest's\n    translation.  This is equivalent to the state of the tlb when a pte is\n    changed but before the tlb entry is flushed.  Accordingly, unsync ptes\n    are synchronized when the guest executes invlpg or flushes its tlb by\n    other means.  Valid for leaf pages.\n  unsync_children:\n    How many sptes in the page point at pages that are unsync (or have\n    unsynchronized children).\n  unsync_child_bitmap:\n    A bitmap indicating which sptes in spt point (directly or indirectly) at\n    pages that may be unsynchronized.  Used to quickly locate all unsychronized\n    pages reachable from a given page.\n  clear_spte_count:\n    Only present on 32-bit hosts, where a 64-bit spte cannot be written\n    atomically.  The reader uses this while running out of the MMU lock\n    to detect in-progress updates and retry them until the writer has\n    finished the write.\n  write_flooding_count:\n    A guest may write to a page table many times, causing a lot of\n    emulations if the page needs to be write-protected (see \"Synchronized\n    and unsynchronized pages\" below).  Leaf pages can be unsynchronized\n    so that they do not trigger frequent emulation, but this is not\n    possible for non-leafs.  This field counts the number of emulations\n    since the last time the page table was actually used; if emulation\n    is triggered too frequently on this page, KVM will unmap the page\n    to avoid emulation in the future.\n\nReverse map\n===========\n\nThe mmu maintains a reverse mapping whereby all ptes mapping a page can be\nreached given its gfn.  This is used, for example, when swapping out a page.\n\nSynchronized and unsynchronized pages\n=====================================\n\nThe guest uses two events to synchronize its tlb and page tables: tlb flushes\nand page invalidations (invlpg).\n\nA tlb flush means that we need to synchronize all sptes reachable from the\nguest's cr3.  This is expensive, so we keep all guest page tables write\nprotected, and synchronize sptes to gptes when a gpte is written.\n\nA special case is when a guest page table is reachable from the current\nguest cr3.  In this case, the guest is obliged to issue an invlpg instruction\nbefore using the translation.  We take advantage of that by removing write\nprotection from the guest page, and allowing the guest to modify it freely.\nWe synchronize modified gptes when the guest invokes invlpg.  This reduces\nthe amount of emulation we have to do when the guest modifies multiple gptes,\nor when the a guest page is no longer used as a page table and is used for\nrandom guest data.\n\nAs a side effect we have to resynchronize all reachable unsynchronized shadow\npages on a tlb flush.\n\n\nReaction to events\n==================\n\n- guest page fault (or npt page fault, or ept violation)\n\nThis is the most complicated event.  The cause of a page fault can be:\n\n  - a true guest fault (the guest translation won't allow the access) (*)\n  - access to a missing translation\n  - access to a protected translation\n    - when logging dirty pages, memory is write protected\n    - synchronized shadow pages are write protected (*)\n  - access to untranslatable memory (mmio)\n\n  (*) not applicable in direct mode\n\nHandling a page fault is performed as follows:\n\n - if the RSV bit of the error code is set, the page fault is caused by guest\n   accessing MMIO and cached MMIO information is available.\n\n   - walk shadow page table\n   - check for valid generation number in the spte (see \"Fast invalidation of\n     MMIO sptes\" below)\n   - cache the information to vcpu->arch.mmio_gva, vcpu->arch.mmio_access and\n     vcpu->arch.mmio_gfn, and call the emulator\n\n - If both P bit and R/W bit of error code are set, this could possibly\n   be handled as a \"fast page fault\" (fixed without taking the MMU lock).  See\n   the description in Documentation/virt/kvm/locking.rst.\n\n - if needed, walk the guest page tables to determine the guest translation\n   (gva->gpa or ngpa->gpa)\n\n   - if permissions are insufficient, reflect the fault back to the guest\n\n - determine the host page\n\n   - if this is an mmio request, there is no host page; cache the info to\n     vcpu->arch.mmio_gva, vcpu->arch.mmio_access and vcpu->arch.mmio_gfn\n\n - walk the shadow page table to find the spte for the translation,\n   instantiating missing intermediate page tables as necessary\n\n   - If this is an mmio request, cache the mmio info to the spte and set some\n     reserved bit on the spte (see callers of kvm_mmu_set_mmio_spte_mask)\n\n - try to unsynchronize the page\n\n   - if successful, we can let the guest continue and modify the gpte\n\n - emulate the instruction\n\n   - if failed, unshadow the page and let the guest continue\n\n - update any translations that were modified by the instruction\n\ninvlpg handling:\n\n  - walk the shadow page hierarchy and drop affected translations\n  - try to reinstantiate the indicated translation in the hope that the\n    guest will use it in the near future\n\nGuest control register updates:\n\n- mov to cr3\n\n  - look up new shadow roots\n  - synchronize newly reachable shadow pages\n\n- mov to cr0/cr4/efer\n\n  - set up mmu context for new paging mode\n  - look up new shadow roots\n  - synchronize newly reachable shadow pages\n\nHost translation updates:\n\n  - mmu notifier called with updated hva\n  - look up affected sptes through reverse map\n  - drop (or update) translations\n\nEmulating cr0.wp\n================\n\nIf tdp is not enabled, the host must keep cr0.wp=1 so page write protection\nworks for the guest kernel, not guest guest userspace.  When the guest\ncr0.wp=1, this does not present a problem.  However when the guest cr0.wp=0,\nwe cannot map the permissions for gpte.u=1, gpte.w=0 to any spte (the\nsemantics require allowing any guest kernel access plus user read access).\n\nWe handle this by mapping the permissions to two possible sptes, depending\non fault type:\n\n- kernel write fault: spte.u=0, spte.w=1 (allows full kernel access,\n  disallows user access)\n- read fault: spte.u=1, spte.w=0 (allows full read access, disallows kernel\n  write access)\n\n(user write faults generate a #PF)\n\nIn the first case there are two additional complications:\n\n- if CR4.SMEP is enabled: since we've turned the page into a kernel page,\n  the kernel may now execute it.  We handle this by also setting spte.nx.\n  If we get a user fetch or read fault, we'll change spte.u=1 and\n  spte.nx=gpte.nx back.  For this to work, KVM forces EFER.NX to 1 when\n  shadow paging is in use.\n- if CR4.SMAP is disabled: since the page has been changed to a kernel\n  page, it can not be reused when CR4.SMAP is enabled. We set\n  CR4.SMAP && !CR0.WP into shadow page's role to avoid this case. Note,\n  here we do not care the case that CR4.SMAP is enabled since KVM will\n  directly inject #PF to guest due to failed permission check.\n\nTo prevent an spte that was converted into a kernel page with cr0.wp=0\nfrom being written by the kernel after cr0.wp has changed to 1, we make\nthe value of cr0.wp part of the page role.  This means that an spte created\nwith one value of cr0.wp cannot be used when cr0.wp has a different value -\nit will simply be missed by the shadow page lookup code.  A similar issue\nexists when an spte created with cr0.wp=0 and cr4.smep=0 is used after\nchanging cr4.smep to 1.  To avoid this, the value of !cr0.wp && cr4.smep\nis also made a part of the page role.\n\nLarge pages\n===========\n\nThe mmu supports all combinations of large and small guest and host pages.\nSupported page sizes include 4k, 2M, 4M, and 1G.  4M pages are treated as\ntwo separate 2M pages, on both guest and host, since the mmu always uses PAE\npaging.\n\nTo instantiate a large spte, four constraints must be satisfied:\n\n- the spte must point to a large host page\n- the guest pte must be a large pte of at least equivalent size (if tdp is\n  enabled, there is no guest pte and this condition is satisfied)\n- if the spte will be writeable, the large page frame may not overlap any\n  write-protected pages\n- the guest page must be wholly contained by a single memory slot\n\nTo check the last two conditions, the mmu maintains a ->disallow_lpage set of\narrays for each memory slot and large page size.  Every write protected page\ncauses its disallow_lpage to be incremented, thus preventing instantiation of\na large spte.  The frames at the end of an unaligned memory slot have\nartificially inflated ->disallow_lpages so they can never be instantiated.\n\nFast invalidation of MMIO sptes\n===============================\n\nAs mentioned in \"Reaction to events\" above, kvm will cache MMIO\ninformation in leaf sptes.  When a new memslot is added or an existing\nmemslot is changed, this information may become stale and needs to be\ninvalidated.  This also needs to hold the MMU lock while walking all\nshadow pages, and is made more scalable with a similar technique.\n\nMMIO sptes have a few spare bits, which are used to store a\ngeneration number.  The global generation number is stored in\nkvm_memslots(kvm)->generation, and increased whenever guest memory info\nchanges.\n\nWhen KVM finds an MMIO spte, it checks the generation number of the spte.\nIf the generation number of the spte does not equal the global generation\nnumber, it will ignore the cached MMIO information and handle the page\nfault through the slow path.\n\nSince only 18 bits are used to store generation-number on mmio spte, all\npages are zapped when there is an overflow.\n\nUnfortunately, a single memory access might access kvm_memslots(kvm) multiple\ntimes, the last one happening when the generation number is retrieved and\nstored into the MMIO spte.  Thus, the MMIO spte might be created based on\nout-of-date information, but with an up-to-date generation number.\n\nTo avoid this, the generation number is incremented again after synchronize_srcu\nreturns; thus, bit 63 of kvm_memslots(kvm)->generation set to 1 only during a\nmemslot update, while some SRCU readers might be using the old copy.  We do not\nwant to use an MMIO sptes created with an odd generation number, and we can do\nthis without losing a bit in the MMIO spte.  The \"update in-progress\" bit of the\ngeneration is not stored in MMIO spte, and is so is implicitly zero when the\ngeneration is extracted out of the spte.  If KVM is unlucky and creates an MMIO\nspte while an update is in-progress, the next access to the spte will always be\na cache miss.  For example, a subsequent access during the update window will\nmiss due to the in-progress flag diverging, while an access after the update\nwindow closes will have a higher generation number (as compared to the spte).\n\n\nFurther reading\n===============\n\n- NPT presentation from KVM Forum 2008\n  https://www.linux-kvm.org/images/c/c8/KvmForum2008%24kdf2008_21.pdf\n", "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This module enables machines with Intel VT-x extensions to run virtual\n * machines without emulation or binary translation.\n *\n * MMU support\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *   Avi Kivity   <avi@qumranet.com>\n */\n\n/*\n * We need the mmu code to access both 32-bit and 64-bit guest ptes,\n * so the code in this file is compiled twice, once per pte size.\n */\n\n#if PTTYPE == 64\n\t#define pt_element_t u64\n\t#define guest_walker guest_walker64\n\t#define FNAME(name) paging##64_##name\n\t#define PT_BASE_ADDR_MASK PT64_BASE_ADDR_MASK\n\t#define PT_LVL_ADDR_MASK(lvl) PT64_LVL_ADDR_MASK(lvl)\n\t#define PT_LVL_OFFSET_MASK(lvl) PT64_LVL_OFFSET_MASK(lvl)\n\t#define PT_INDEX(addr, level) PT64_INDEX(addr, level)\n\t#define PT_LEVEL_BITS PT64_LEVEL_BITS\n\t#define PT_GUEST_DIRTY_SHIFT PT_DIRTY_SHIFT\n\t#define PT_GUEST_ACCESSED_SHIFT PT_ACCESSED_SHIFT\n\t#define PT_HAVE_ACCESSED_DIRTY(mmu) true\n\t#ifdef CONFIG_X86_64\n\t#define PT_MAX_FULL_LEVELS PT64_ROOT_MAX_LEVEL\n\t#define CMPXCHG cmpxchg\n\t#else\n\t#define CMPXCHG cmpxchg64\n\t#define PT_MAX_FULL_LEVELS 2\n\t#endif\n#elif PTTYPE == 32\n\t#define pt_element_t u32\n\t#define guest_walker guest_walker32\n\t#define FNAME(name) paging##32_##name\n\t#define PT_BASE_ADDR_MASK PT32_BASE_ADDR_MASK\n\t#define PT_LVL_ADDR_MASK(lvl) PT32_LVL_ADDR_MASK(lvl)\n\t#define PT_LVL_OFFSET_MASK(lvl) PT32_LVL_OFFSET_MASK(lvl)\n\t#define PT_INDEX(addr, level) PT32_INDEX(addr, level)\n\t#define PT_LEVEL_BITS PT32_LEVEL_BITS\n\t#define PT_MAX_FULL_LEVELS 2\n\t#define PT_GUEST_DIRTY_SHIFT PT_DIRTY_SHIFT\n\t#define PT_GUEST_ACCESSED_SHIFT PT_ACCESSED_SHIFT\n\t#define PT_HAVE_ACCESSED_DIRTY(mmu) true\n\t#define CMPXCHG cmpxchg\n#elif PTTYPE == PTTYPE_EPT\n\t#define pt_element_t u64\n\t#define guest_walker guest_walkerEPT\n\t#define FNAME(name) ept_##name\n\t#define PT_BASE_ADDR_MASK PT64_BASE_ADDR_MASK\n\t#define PT_LVL_ADDR_MASK(lvl) PT64_LVL_ADDR_MASK(lvl)\n\t#define PT_LVL_OFFSET_MASK(lvl) PT64_LVL_OFFSET_MASK(lvl)\n\t#define PT_INDEX(addr, level) PT64_INDEX(addr, level)\n\t#define PT_LEVEL_BITS PT64_LEVEL_BITS\n\t#define PT_GUEST_DIRTY_SHIFT 9\n\t#define PT_GUEST_ACCESSED_SHIFT 8\n\t#define PT_HAVE_ACCESSED_DIRTY(mmu) ((mmu)->ept_ad)\n\t#define CMPXCHG cmpxchg64\n\t#define PT_MAX_FULL_LEVELS PT64_ROOT_MAX_LEVEL\n#else\n\t#error Invalid PTTYPE value\n#endif\n\n#define PT_GUEST_DIRTY_MASK    (1 << PT_GUEST_DIRTY_SHIFT)\n#define PT_GUEST_ACCESSED_MASK (1 << PT_GUEST_ACCESSED_SHIFT)\n\n#define gpte_to_gfn_lvl FNAME(gpte_to_gfn_lvl)\n#define gpte_to_gfn(pte) gpte_to_gfn_lvl((pte), PG_LEVEL_4K)\n\n/*\n * The guest_walker structure emulates the behavior of the hardware page\n * table walker.\n */\nstruct guest_walker {\n\tint level;\n\tunsigned max_level;\n\tgfn_t table_gfn[PT_MAX_FULL_LEVELS];\n\tpt_element_t ptes[PT_MAX_FULL_LEVELS];\n\tpt_element_t prefetch_ptes[PTE_PREFETCH_NUM];\n\tgpa_t pte_gpa[PT_MAX_FULL_LEVELS];\n\tpt_element_t __user *ptep_user[PT_MAX_FULL_LEVELS];\n\tbool pte_writable[PT_MAX_FULL_LEVELS];\n\tunsigned pt_access;\n\tunsigned pte_access;\n\tgfn_t gfn;\n\tstruct x86_exception fault;\n};\n\nstatic gfn_t gpte_to_gfn_lvl(pt_element_t gpte, int lvl)\n{\n\treturn (gpte & PT_LVL_ADDR_MASK(lvl)) >> PAGE_SHIFT;\n}\n\nstatic inline void FNAME(protect_clean_gpte)(struct kvm_mmu *mmu, unsigned *access,\n\t\t\t\t\t     unsigned gpte)\n{\n\tunsigned mask;\n\n\t/* dirty bit is not supported, so no need to track it */\n\tif (!PT_HAVE_ACCESSED_DIRTY(mmu))\n\t\treturn;\n\n\tBUILD_BUG_ON(PT_WRITABLE_MASK != ACC_WRITE_MASK);\n\n\tmask = (unsigned)~ACC_WRITE_MASK;\n\t/* Allow write access to dirty gptes */\n\tmask |= (gpte >> (PT_GUEST_DIRTY_SHIFT - PT_WRITABLE_SHIFT)) &\n\t\tPT_WRITABLE_MASK;\n\t*access &= mask;\n}\n\nstatic inline int FNAME(is_present_gpte)(unsigned long pte)\n{\n#if PTTYPE != PTTYPE_EPT\n\treturn pte & PT_PRESENT_MASK;\n#else\n\treturn pte & 7;\n#endif\n}\n\nstatic bool FNAME(is_bad_mt_xwr)(struct rsvd_bits_validate *rsvd_check, u64 gpte)\n{\n#if PTTYPE != PTTYPE_EPT\n\treturn false;\n#else\n\treturn __is_bad_mt_xwr(rsvd_check, gpte);\n#endif\n}\n\nstatic bool FNAME(is_rsvd_bits_set)(struct kvm_mmu *mmu, u64 gpte, int level)\n{\n\treturn __is_rsvd_bits_set(&mmu->guest_rsvd_check, gpte, level) ||\n\t       FNAME(is_bad_mt_xwr)(&mmu->guest_rsvd_check, gpte);\n}\n\nstatic int FNAME(cmpxchg_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t       pt_element_t __user *ptep_user, unsigned index,\n\t\t\t       pt_element_t orig_pte, pt_element_t new_pte)\n{\n\tint npages;\n\tpt_element_t ret;\n\tpt_element_t *table;\n\tstruct page *page;\n\n\tnpages = get_user_pages_fast((unsigned long)ptep_user, 1, FOLL_WRITE, &page);\n\tif (likely(npages == 1)) {\n\t\ttable = kmap_atomic(page);\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tkunmap_atomic(table);\n\n\t\tkvm_release_page_dirty(page);\n\t} else {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned long vaddr = (unsigned long)ptep_user & PAGE_MASK;\n\t\tunsigned long pfn;\n\t\tunsigned long paddr;\n\n\t\tmmap_read_lock(current->mm);\n\t\tvma = find_vma_intersection(current->mm, vaddr, vaddr + PAGE_SIZE);\n\t\tif (!vma || !(vma->vm_flags & VM_PFNMAP)) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tpfn = ((vaddr - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\t\tpaddr = pfn << PAGE_SHIFT;\n\t\ttable = memremap(paddr, PAGE_SIZE, MEMREMAP_WB);\n\t\tif (!table) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tmemunmap(table);\n\t\tmmap_read_unlock(current->mm);\n\t}\n\n\treturn (ret != orig_pte);\n}\n\nstatic bool FNAME(prefetch_invalid_gpte)(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  u64 gpte)\n{\n\tif (!FNAME(is_present_gpte)(gpte))\n\t\tgoto no_present;\n\n\t/* if accessed bit is not supported prefetch non accessed gpte */\n\tif (PT_HAVE_ACCESSED_DIRTY(vcpu->arch.mmu) &&\n\t    !(gpte & PT_GUEST_ACCESSED_MASK))\n\t\tgoto no_present;\n\n\tif (FNAME(is_rsvd_bits_set)(vcpu->arch.mmu, gpte, PG_LEVEL_4K))\n\t\tgoto no_present;\n\n\treturn false;\n\nno_present:\n\tdrop_spte(vcpu->kvm, spte);\n\treturn true;\n}\n\n/*\n * For PTTYPE_EPT, a page table can be executable but not readable\n * on supported processors. Therefore, set_spte does not automatically\n * set bit 0 if execute only is supported. Here, we repurpose ACC_USER_MASK\n * to signify readability since it isn't used in the EPT case\n */\nstatic inline unsigned FNAME(gpte_access)(u64 gpte)\n{\n\tunsigned access;\n#if PTTYPE == PTTYPE_EPT\n\taccess = ((gpte & VMX_EPT_WRITABLE_MASK) ? ACC_WRITE_MASK : 0) |\n\t\t((gpte & VMX_EPT_EXECUTABLE_MASK) ? ACC_EXEC_MASK : 0) |\n\t\t((gpte & VMX_EPT_READABLE_MASK) ? ACC_USER_MASK : 0);\n#else\n\tBUILD_BUG_ON(ACC_EXEC_MASK != PT_PRESENT_MASK);\n\tBUILD_BUG_ON(ACC_EXEC_MASK != 1);\n\taccess = gpte & (PT_WRITABLE_MASK | PT_USER_MASK | PT_PRESENT_MASK);\n\t/* Combine NX with P (which is set here) to get ACC_EXEC_MASK.  */\n\taccess ^= (gpte >> PT64_NX_SHIFT);\n#endif\n\n\treturn access;\n}\n\nstatic int FNAME(update_accessed_dirty_bits)(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_mmu *mmu,\n\t\t\t\t\t     struct guest_walker *walker,\n\t\t\t\t\t     gpa_t addr, int write_fault)\n{\n\tunsigned level, index;\n\tpt_element_t pte, orig_pte;\n\tpt_element_t __user *ptep_user;\n\tgfn_t table_gfn;\n\tint ret;\n\n\t/* dirty/accessed bits are not supported, so no need to update them */\n\tif (!PT_HAVE_ACCESSED_DIRTY(mmu))\n\t\treturn 0;\n\n\tfor (level = walker->max_level; level >= walker->level; --level) {\n\t\tpte = orig_pte = walker->ptes[level - 1];\n\t\ttable_gfn = walker->table_gfn[level - 1];\n\t\tptep_user = walker->ptep_user[level - 1];\n\t\tindex = offset_in_page(ptep_user) / sizeof(pt_element_t);\n\t\tif (!(pte & PT_GUEST_ACCESSED_MASK)) {\n\t\t\ttrace_kvm_mmu_set_accessed_bit(table_gfn, index, sizeof(pte));\n\t\t\tpte |= PT_GUEST_ACCESSED_MASK;\n\t\t}\n\t\tif (level == walker->level && write_fault &&\n\t\t\t\t!(pte & PT_GUEST_DIRTY_MASK)) {\n\t\t\ttrace_kvm_mmu_set_dirty_bit(table_gfn, index, sizeof(pte));\n#if PTTYPE == PTTYPE_EPT\n\t\t\tif (kvm_x86_ops.nested_ops->write_log_dirty(vcpu, addr))\n\t\t\t\treturn -EINVAL;\n#endif\n\t\t\tpte |= PT_GUEST_DIRTY_MASK;\n\t\t}\n\t\tif (pte == orig_pte)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the slot is read-only, simply do not process the accessed\n\t\t * and dirty bits.  This is the correct thing to do if the slot\n\t\t * is ROM, and page tables in read-as-ROM/write-as-MMIO slots\n\t\t * are only supported if the accessed and dirty bits are already\n\t\t * set in the ROM (so that MMIO writes are never needed).\n\t\t *\n\t\t * Note that NPT does not allow this at all and faults, since\n\t\t * it always wants nested page table entries for the guest\n\t\t * page tables to be writable.  And EPT works but will simply\n\t\t * overwrite the read-only memory to set the accessed and dirty\n\t\t * bits.\n\t\t */\n\t\tif (unlikely(!walker->pte_writable[level - 1]))\n\t\t\tcontinue;\n\n\t\tret = FNAME(cmpxchg_gpte)(vcpu, mmu, ptep_user, index, orig_pte, pte);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tkvm_vcpu_mark_page_dirty(vcpu, table_gfn);\n\t\twalker->ptes[level - 1] = pte;\n\t}\n\treturn 0;\n}\n\nstatic inline unsigned FNAME(gpte_pkeys)(struct kvm_vcpu *vcpu, u64 gpte)\n{\n\tunsigned pkeys = 0;\n#if PTTYPE == 64\n\tpte_t pte = {.pte = gpte};\n\n\tpkeys = pte_flags_pkey(pte_flags(pte));\n#endif\n\treturn pkeys;\n}\n\n/*\n * Fetch a guest pte for a guest virtual address, or for an L2's GPA.\n */\nstatic int FNAME(walk_addr_generic)(struct guest_walker *walker,\n\t\t\t\t    struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\t    gpa_t addr, u32 access)\n{\n\tint ret;\n\tpt_element_t pte;\n\tpt_element_t __user *ptep_user;\n\tgfn_t table_gfn;\n\tu64 pt_access, pte_access;\n\tunsigned index, accessed_dirty, pte_pkey;\n\tunsigned nested_access;\n\tgpa_t pte_gpa;\n\tbool have_ad;\n\tint offset;\n\tu64 walk_nx_mask = 0;\n\tconst int write_fault = access & PFERR_WRITE_MASK;\n\tconst int user_fault  = access & PFERR_USER_MASK;\n\tconst int fetch_fault = access & PFERR_FETCH_MASK;\n\tu16 errcode = 0;\n\tgpa_t real_gpa;\n\tgfn_t gfn;\n\n\ttrace_kvm_mmu_pagetable_walk(addr, access);\nretry_walk:\n\twalker->level = mmu->root_level;\n\tpte           = mmu->get_guest_pgd(vcpu);\n\thave_ad       = PT_HAVE_ACCESSED_DIRTY(mmu);\n\n#if PTTYPE == 64\n\twalk_nx_mask = 1ULL << PT64_NX_SHIFT;\n\tif (walker->level == PT32E_ROOT_LEVEL) {\n\t\tpte = mmu->get_pdptr(vcpu, (addr >> 30) & 3);\n\t\ttrace_kvm_mmu_paging_element(pte, walker->level);\n\t\tif (!FNAME(is_present_gpte)(pte))\n\t\t\tgoto error;\n\t\t--walker->level;\n\t}\n#endif\n\twalker->max_level = walker->level;\n\tASSERT(!(is_long_mode(vcpu) && !is_pae(vcpu)));\n\n\t/*\n\t * FIXME: on Intel processors, loads of the PDPTE registers for PAE paging\n\t * by the MOV to CR instruction are treated as reads and do not cause the\n\t * processor to set the dirty flag in any EPT paging-structure entry.\n\t */\n\tnested_access = (have_ad ? PFERR_WRITE_MASK : 0) | PFERR_USER_MASK;\n\n\tpte_access = ~0;\n\t++walker->level;\n\n\tdo {\n\t\tunsigned long host_addr;\n\n\t\tpt_access = pte_access;\n\t\t--walker->level;\n\n\t\tindex = PT_INDEX(addr, walker->level);\n\t\ttable_gfn = gpte_to_gfn(pte);\n\t\toffset    = index * sizeof(pt_element_t);\n\t\tpte_gpa   = gfn_to_gpa(table_gfn) + offset;\n\n\t\tBUG_ON(walker->level < 1);\n\t\twalker->table_gfn[walker->level - 1] = table_gfn;\n\t\twalker->pte_gpa[walker->level - 1] = pte_gpa;\n\n\t\treal_gpa = mmu->translate_gpa(vcpu, gfn_to_gpa(table_gfn),\n\t\t\t\t\t      nested_access,\n\t\t\t\t\t      &walker->fault);\n\n\t\t/*\n\t\t * FIXME: This can happen if emulation (for of an INS/OUTS\n\t\t * instruction) triggers a nested page fault.  The exit\n\t\t * qualification / exit info field will incorrectly have\n\t\t * \"guest page access\" as the nested page fault's cause,\n\t\t * instead of \"guest page structure access\".  To fix this,\n\t\t * the x86_exception struct should be augmented with enough\n\t\t * information to fix the exit_qualification or exit_info_1\n\t\t * fields.\n\t\t */\n\t\tif (unlikely(real_gpa == UNMAPPED_GVA))\n\t\t\treturn 0;\n\n\t\thost_addr = kvm_vcpu_gfn_to_hva_prot(vcpu, gpa_to_gfn(real_gpa),\n\t\t\t\t\t    &walker->pte_writable[walker->level - 1]);\n\t\tif (unlikely(kvm_is_error_hva(host_addr)))\n\t\t\tgoto error;\n\n\t\tptep_user = (pt_element_t __user *)((void *)host_addr + offset);\n\t\tif (unlikely(__get_user(pte, ptep_user)))\n\t\t\tgoto error;\n\t\twalker->ptep_user[walker->level - 1] = ptep_user;\n\n\t\ttrace_kvm_mmu_paging_element(pte, walker->level);\n\n\t\t/*\n\t\t * Inverting the NX it lets us AND it like other\n\t\t * permission bits.\n\t\t */\n\t\tpte_access = pt_access & (pte ^ walk_nx_mask);\n\n\t\tif (unlikely(!FNAME(is_present_gpte)(pte)))\n\t\t\tgoto error;\n\n\t\tif (unlikely(FNAME(is_rsvd_bits_set)(mmu, pte, walker->level))) {\n\t\t\terrcode = PFERR_RSVD_MASK | PFERR_PRESENT_MASK;\n\t\t\tgoto error;\n\t\t}\n\n\t\twalker->ptes[walker->level - 1] = pte;\n\t} while (!is_last_gpte(mmu, walker->level, pte));\n\n\tpte_pkey = FNAME(gpte_pkeys)(vcpu, pte);\n\taccessed_dirty = have_ad ? pte_access & PT_GUEST_ACCESSED_MASK : 0;\n\n\t/* Convert to ACC_*_MASK flags for struct guest_walker.  */\n\twalker->pt_access = FNAME(gpte_access)(pt_access ^ walk_nx_mask);\n\twalker->pte_access = FNAME(gpte_access)(pte_access ^ walk_nx_mask);\n\terrcode = permission_fault(vcpu, mmu, walker->pte_access, pte_pkey, access);\n\tif (unlikely(errcode))\n\t\tgoto error;\n\n\tgfn = gpte_to_gfn_lvl(pte, walker->level);\n\tgfn += (addr & PT_LVL_OFFSET_MASK(walker->level)) >> PAGE_SHIFT;\n\n\tif (PTTYPE == 32 && walker->level > PG_LEVEL_4K && is_cpuid_PSE36())\n\t\tgfn += pse36_gfn_delta(pte);\n\n\treal_gpa = mmu->translate_gpa(vcpu, gfn_to_gpa(gfn), access, &walker->fault);\n\tif (real_gpa == UNMAPPED_GVA)\n\t\treturn 0;\n\n\twalker->gfn = real_gpa >> PAGE_SHIFT;\n\n\tif (!write_fault)\n\t\tFNAME(protect_clean_gpte)(mmu, &walker->pte_access, pte);\n\telse\n\t\t/*\n\t\t * On a write fault, fold the dirty bit into accessed_dirty.\n\t\t * For modes without A/D bits support accessed_dirty will be\n\t\t * always clear.\n\t\t */\n\t\taccessed_dirty &= pte >>\n\t\t\t(PT_GUEST_DIRTY_SHIFT - PT_GUEST_ACCESSED_SHIFT);\n\n\tif (unlikely(!accessed_dirty)) {\n\t\tret = FNAME(update_accessed_dirty_bits)(vcpu, mmu, walker,\n\t\t\t\t\t\t\taddr, write_fault);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error;\n\t\telse if (ret)\n\t\t\tgoto retry_walk;\n\t}\n\n\tpgprintk(\"%s: pte %llx pte_access %x pt_access %x\\n\",\n\t\t __func__, (u64)pte, walker->pte_access, walker->pt_access);\n\treturn 1;\n\nerror:\n\terrcode |= write_fault | user_fault;\n\tif (fetch_fault && (mmu->nx ||\n\t\t\t    kvm_read_cr4_bits(vcpu, X86_CR4_SMEP)))\n\t\terrcode |= PFERR_FETCH_MASK;\n\n\twalker->fault.vector = PF_VECTOR;\n\twalker->fault.error_code_valid = true;\n\twalker->fault.error_code = errcode;\n\n#if PTTYPE == PTTYPE_EPT\n\t/*\n\t * Use PFERR_RSVD_MASK in error_code to to tell if EPT\n\t * misconfiguration requires to be injected. The detection is\n\t * done by is_rsvd_bits_set() above.\n\t *\n\t * We set up the value of exit_qualification to inject:\n\t * [2:0] - Derive from the access bits. The exit_qualification might be\n\t *         out of date if it is serving an EPT misconfiguration.\n\t * [5:3] - Calculated by the page walk of the guest EPT page tables\n\t * [7:8] - Derived from [7:8] of real exit_qualification\n\t *\n\t * The other bits are set to 0.\n\t */\n\tif (!(errcode & PFERR_RSVD_MASK)) {\n\t\tvcpu->arch.exit_qualification &= 0x180;\n\t\tif (write_fault)\n\t\t\tvcpu->arch.exit_qualification |= EPT_VIOLATION_ACC_WRITE;\n\t\tif (user_fault)\n\t\t\tvcpu->arch.exit_qualification |= EPT_VIOLATION_ACC_READ;\n\t\tif (fetch_fault)\n\t\t\tvcpu->arch.exit_qualification |= EPT_VIOLATION_ACC_INSTR;\n\t\tvcpu->arch.exit_qualification |= (pte_access & 0x7) << 3;\n\t}\n#endif\n\twalker->fault.address = addr;\n\twalker->fault.nested_page_fault = mmu != vcpu->arch.walk_mmu;\n\twalker->fault.async_page_fault = false;\n\n\ttrace_kvm_mmu_walker_error(walker->fault.error_code);\n\treturn 0;\n}\n\nstatic int FNAME(walk_addr)(struct guest_walker *walker,\n\t\t\t    struct kvm_vcpu *vcpu, gpa_t addr, u32 access)\n{\n\treturn FNAME(walk_addr_generic)(walker, vcpu, vcpu->arch.mmu, addr,\n\t\t\t\t\taccess);\n}\n\n#if PTTYPE != PTTYPE_EPT\nstatic int FNAME(walk_addr_nested)(struct guest_walker *walker,\n\t\t\t\t   struct kvm_vcpu *vcpu, gva_t addr,\n\t\t\t\t   u32 access)\n{\n\treturn FNAME(walk_addr_generic)(walker, vcpu, &vcpu->arch.nested_mmu,\n\t\t\t\t\taddr, access);\n}\n#endif\n\nstatic bool\nFNAME(prefetch_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t     u64 *spte, pt_element_t gpte, bool no_dirty_log)\n{\n\tunsigned pte_access;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\n\tif (FNAME(prefetch_invalid_gpte)(vcpu, sp, spte, gpte))\n\t\treturn false;\n\n\tpgprintk(\"%s: gpte %llx spte %p\\n\", __func__, (u64)gpte, spte);\n\n\tgfn = gpte_to_gfn(gpte);\n\tpte_access = sp->role.access & FNAME(gpte_access)(gpte);\n\tFNAME(protect_clean_gpte)(vcpu->arch.mmu, &pte_access, gpte);\n\tpfn = pte_prefetch_gfn_to_pfn(vcpu, gfn,\n\t\t\tno_dirty_log && (pte_access & ACC_WRITE_MASK));\n\tif (is_error_pfn(pfn))\n\t\treturn false;\n\n\t/*\n\t * we call mmu_set_spte() with host_writable = true because\n\t * pte_prefetch_gfn_to_pfn always gets a writable pfn.\n\t */\n\tmmu_set_spte(vcpu, spte, pte_access, false, PG_LEVEL_4K, gfn, pfn,\n\t\t     true, true);\n\n\tkvm_release_pfn_clean(pfn);\n\treturn true;\n}\n\nstatic void FNAME(update_pte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t      u64 *spte, const void *pte)\n{\n\tpt_element_t gpte = *(const pt_element_t *)pte;\n\n\tFNAME(prefetch_gpte)(vcpu, sp, spte, gpte, false);\n}\n\nstatic bool FNAME(gpte_changed)(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct guest_walker *gw, int level)\n{\n\tpt_element_t curr_pte;\n\tgpa_t base_gpa, pte_gpa = gw->pte_gpa[level - 1];\n\tu64 mask;\n\tint r, index;\n\n\tif (level == PG_LEVEL_4K) {\n\t\tmask = PTE_PREFETCH_NUM * sizeof(pt_element_t) - 1;\n\t\tbase_gpa = pte_gpa & ~mask;\n\t\tindex = (pte_gpa - base_gpa) / sizeof(pt_element_t);\n\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, base_gpa,\n\t\t\t\tgw->prefetch_ptes, sizeof(gw->prefetch_ptes));\n\t\tcurr_pte = gw->prefetch_ptes[index];\n\t} else\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, pte_gpa,\n\t\t\t\t  &curr_pte, sizeof(curr_pte));\n\n\treturn r || curr_pte != gw->ptes[level - 1];\n}\n\nstatic void FNAME(pte_prefetch)(struct kvm_vcpu *vcpu, struct guest_walker *gw,\n\t\t\t\tu64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\tpt_element_t *gptep = gw->prefetch_ptes;\n\tu64 *spte;\n\tint i;\n\n\tsp = sptep_to_sp(sptep);\n\n\tif (sp->role.level > PG_LEVEL_4K)\n\t\treturn;\n\n\t/*\n\t * If addresses are being invalidated, skip prefetching to avoid\n\t * accidentally prefetching those addresses.\n\t */\n\tif (unlikely(vcpu->kvm->mmu_notifier_count))\n\t\treturn;\n\n\tif (sp->role.direct)\n\t\treturn __direct_pte_prefetch(vcpu, sp, sptep);\n\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (spte == sptep)\n\t\t\tcontinue;\n\n\t\tif (is_shadow_present_pte(*spte))\n\t\t\tcontinue;\n\n\t\tif (!FNAME(prefetch_gpte)(vcpu, sp, spte, gptep[i], true))\n\t\t\tbreak;\n\t}\n}\n\n/*\n * Fetch a shadow pte for a specific level in the paging hierarchy.\n * If the guest tries to write a write-protected page, we need to\n * emulate this operation, return 1 to indicate this case.\n */\nstatic int FNAME(fetch)(struct kvm_vcpu *vcpu, gpa_t addr,\n\t\t\t struct guest_walker *gw, u32 error_code,\n\t\t\t int max_level, kvm_pfn_t pfn, bool map_writable,\n\t\t\t bool prefault)\n{\n\tbool nx_huge_page_workaround_enabled = is_nx_huge_page_enabled();\n\tbool write_fault = error_code & PFERR_WRITE_MASK;\n\tbool exec = error_code & PFERR_FETCH_MASK;\n\tbool huge_page_disallowed = exec && nx_huge_page_workaround_enabled;\n\tstruct kvm_mmu_page *sp = NULL;\n\tstruct kvm_shadow_walk_iterator it;\n\tunsigned direct_access, access = gw->pt_access;\n\tint top_level, level, req_level, ret;\n\tgfn_t base_gfn = gw->gfn;\n\n\tdirect_access = gw->pte_access;\n\n\ttop_level = vcpu->arch.mmu->root_level;\n\tif (top_level == PT32E_ROOT_LEVEL)\n\t\ttop_level = PT32_ROOT_LEVEL;\n\t/*\n\t * Verify that the top-level gpte is still there.  Since the page\n\t * is a root page, it is either write protected (and cannot be\n\t * changed from now on) or it is invalid (in which case, we don't\n\t * really care if it changes underneath us after this point).\n\t */\n\tif (FNAME(gpte_changed)(vcpu, gw, top_level))\n\t\tgoto out_gpte_changed;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\tgoto out_gpte_changed;\n\n\tfor (shadow_walk_init(&it, vcpu, addr);\n\t     shadow_walk_okay(&it) && it.level > gw->level;\n\t     shadow_walk_next(&it)) {\n\t\tgfn_t table_gfn;\n\n\t\tclear_sp_write_flooding_count(it.sptep);\n\t\tdrop_large_spte(vcpu, it.sptep);\n\n\t\tsp = NULL;\n\t\tif (!is_shadow_present_pte(*it.sptep)) {\n\t\t\ttable_gfn = gw->table_gfn[it.level - 2];\n\t\t\tsp = kvm_mmu_get_page(vcpu, table_gfn, addr, it.level-1,\n\t\t\t\t\t      false, access);\n\t\t}\n\n\t\t/*\n\t\t * Verify that the gpte in the page we've just write\n\t\t * protected is still there.\n\t\t */\n\t\tif (FNAME(gpte_changed)(vcpu, gw, it.level - 1))\n\t\t\tgoto out_gpte_changed;\n\n\t\tif (sp)\n\t\t\tlink_shadow_page(vcpu, it.sptep, sp);\n\t}\n\n\tlevel = kvm_mmu_hugepage_adjust(vcpu, gw->gfn, max_level, &pfn,\n\t\t\t\t\thuge_page_disallowed, &req_level);\n\n\ttrace_kvm_mmu_spte_requested(addr, gw->level, pfn);\n\n\tfor (; shadow_walk_okay(&it); shadow_walk_next(&it)) {\n\t\tclear_sp_write_flooding_count(it.sptep);\n\n\t\t/*\n\t\t * We cannot overwrite existing page tables with an NX\n\t\t * large page, as the leaf could be executable.\n\t\t */\n\t\tif (nx_huge_page_workaround_enabled)\n\t\t\tdisallowed_hugepage_adjust(*it.sptep, gw->gfn, it.level,\n\t\t\t\t\t\t   &pfn, &level);\n\n\t\tbase_gfn = gw->gfn & ~(KVM_PAGES_PER_HPAGE(it.level) - 1);\n\t\tif (it.level == level)\n\t\t\tbreak;\n\n\t\tvalidate_direct_spte(vcpu, it.sptep, direct_access);\n\n\t\tdrop_large_spte(vcpu, it.sptep);\n\n\t\tif (!is_shadow_present_pte(*it.sptep)) {\n\t\t\tsp = kvm_mmu_get_page(vcpu, base_gfn, addr,\n\t\t\t\t\t      it.level - 1, true, direct_access);\n\t\t\tlink_shadow_page(vcpu, it.sptep, sp);\n\t\t\tif (huge_page_disallowed && req_level >= it.level)\n\t\t\t\taccount_huge_nx_page(vcpu->kvm, sp);\n\t\t}\n\t}\n\n\tret = mmu_set_spte(vcpu, it.sptep, gw->pte_access, write_fault,\n\t\t\t   it.level, base_gfn, pfn, prefault, map_writable);\n\tif (ret == RET_PF_SPURIOUS)\n\t\treturn ret;\n\n\tFNAME(pte_prefetch)(vcpu, gw, it.sptep);\n\t++vcpu->stat.pf_fixed;\n\treturn ret;\n\nout_gpte_changed:\n\treturn RET_PF_RETRY;\n}\n\n /*\n * To see whether the mapped gfn can write its page table in the current\n * mapping.\n *\n * It is the helper function of FNAME(page_fault). When guest uses large page\n * size to map the writable gfn which is used as current page table, we should\n * force kvm to use small page size to map it because new shadow page will be\n * created when kvm establishes shadow page table that stop kvm using large\n * page size. Do it early can avoid unnecessary #PF and emulation.\n *\n * @write_fault_to_shadow_pgtable will return true if the fault gfn is\n * currently used as its page table.\n *\n * Note: the PDPT page table is not checked for PAE-32 bit guest. It is ok\n * since the PDPT is always shadowed, that means, we can not use large page\n * size to map the gfn which is used as PDPT.\n */\nstatic bool\nFNAME(is_self_change_mapping)(struct kvm_vcpu *vcpu,\n\t\t\t      struct guest_walker *walker, bool user_fault,\n\t\t\t      bool *write_fault_to_shadow_pgtable)\n{\n\tint level;\n\tgfn_t mask = ~(KVM_PAGES_PER_HPAGE(walker->level) - 1);\n\tbool self_changed = false;\n\n\tif (!(walker->pte_access & ACC_WRITE_MASK ||\n\t      (!is_write_protection(vcpu) && !user_fault)))\n\t\treturn false;\n\n\tfor (level = walker->level; level <= walker->max_level; level++) {\n\t\tgfn_t gfn = walker->gfn ^ walker->table_gfn[level - 1];\n\n\t\tself_changed |= !(gfn & mask);\n\t\t*write_fault_to_shadow_pgtable |= !gfn;\n\t}\n\n\treturn self_changed;\n}\n\n/*\n * Page fault handler.  There are several causes for a page fault:\n *   - there is no shadow pte for the guest pte\n *   - write access through a shadow pte marked read only so that we can set\n *     the dirty bit\n *   - write access to a shadow pte marked read only so we can update the page\n *     dirty bitmap, when userspace requests it\n *   - mmio access; in this case we will never install a present shadow pte\n *   - normal guest page fault due to the guest pte marked not present, not\n *     writable, or not executable\n *\n *  Returns: 1 if we need to emulate the instruction, 0 otherwise, or\n *           a negative value on error.\n */\nstatic int FNAME(page_fault)(struct kvm_vcpu *vcpu, gpa_t addr, u32 error_code,\n\t\t\t     bool prefault)\n{\n\tbool write_fault = error_code & PFERR_WRITE_MASK;\n\tbool user_fault = error_code & PFERR_USER_MASK;\n\tstruct guest_walker walker;\n\tint r;\n\tkvm_pfn_t pfn;\n\thva_t hva;\n\tunsigned long mmu_seq;\n\tbool map_writable, is_self_change_mapping;\n\tint max_level;\n\n\tpgprintk(\"%s: addr %lx err %x\\n\", __func__, addr, error_code);\n\n\t/*\n\t * If PFEC.RSVD is set, this is a shadow page fault.\n\t * The bit needs to be cleared before walking guest page tables.\n\t */\n\terror_code &= ~PFERR_RSVD_MASK;\n\n\t/*\n\t * Look up the guest pte for the faulting address.\n\t */\n\tr = FNAME(walk_addr)(&walker, vcpu, addr, error_code);\n\n\t/*\n\t * The page is not mapped by the guest.  Let the guest handle it.\n\t */\n\tif (!r) {\n\t\tpgprintk(\"%s: guest page fault\\n\", __func__);\n\t\tif (!prefault)\n\t\t\tkvm_inject_emulated_page_fault(vcpu, &walker.fault);\n\n\t\treturn RET_PF_RETRY;\n\t}\n\n\tif (page_fault_handle_page_track(vcpu, error_code, walker.gfn)) {\n\t\tshadow_page_table_clear_flood(vcpu, addr);\n\t\treturn RET_PF_EMULATE;\n\t}\n\n\tr = mmu_topup_memory_caches(vcpu, true);\n\tif (r)\n\t\treturn r;\n\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\n\tis_self_change_mapping = FNAME(is_self_change_mapping)(vcpu,\n\t      &walker, user_fault, &vcpu->arch.write_fault_to_shadow_pgtable);\n\n\tif (is_self_change_mapping)\n\t\tmax_level = PG_LEVEL_4K;\n\telse\n\t\tmax_level = walker.level;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, walker.gfn, addr, &pfn, &hva,\n\t\t\t write_fault, &map_writable))\n\t\treturn RET_PF_RETRY;\n\n\tif (handle_abnormal_pfn(vcpu, addr, walker.gfn, pfn, walker.pte_access, &r))\n\t\treturn r;\n\n\t/*\n\t * Do not change pte_access if the pfn is a mmio page, otherwise\n\t * we will cache the incorrect access into mmio spte.\n\t */\n\tif (write_fault && !(walker.pte_access & ACC_WRITE_MASK) &&\n\t     !is_write_protection(vcpu) && !user_fault &&\n\t      !is_noslot_pfn(pfn)) {\n\t\twalker.pte_access |= ACC_WRITE_MASK;\n\t\twalker.pte_access &= ~ACC_USER_MASK;\n\n\t\t/*\n\t\t * If we converted a user page to a kernel page,\n\t\t * so that the kernel can write to it when cr0.wp=0,\n\t\t * then we should prevent the kernel from executing it\n\t\t * if SMEP is enabled.\n\t\t */\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_SMEP))\n\t\t\twalker.pte_access &= ~ACC_EXEC_MASK;\n\t}\n\n\tr = RET_PF_RETRY;\n\twrite_lock(&vcpu->kvm->mmu_lock);\n\tif (!is_noslot_pfn(pfn) && mmu_notifier_retry_hva(vcpu->kvm, mmu_seq, hva))\n\t\tgoto out_unlock;\n\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_PAGE_FAULT);\n\tr = make_mmu_pages_available(vcpu);\n\tif (r)\n\t\tgoto out_unlock;\n\tr = FNAME(fetch)(vcpu, addr, &walker, error_code, max_level, pfn,\n\t\t\t map_writable, prefault);\n\tkvm_mmu_audit(vcpu, AUDIT_POST_PAGE_FAULT);\n\nout_unlock:\n\twrite_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn r;\n}\n\nstatic gpa_t FNAME(get_level1_sp_gpa)(struct kvm_mmu_page *sp)\n{\n\tint offset = 0;\n\n\tWARN_ON(sp->role.level != PG_LEVEL_4K);\n\n\tif (PTTYPE == 32)\n\t\toffset = sp->role.quadrant << PT64_LEVEL_BITS;\n\n\treturn gfn_to_gpa(sp->gfn) + offset * sizeof(pt_element_t);\n}\n\nstatic void FNAME(invlpg)(struct kvm_vcpu *vcpu, gva_t gva, hpa_t root_hpa)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tu64 old_spte;\n\tint level;\n\tu64 *sptep;\n\n\tvcpu_clear_mmio_info(vcpu, gva);\n\n\t/*\n\t * No need to check return value here, rmap_can_add() can\n\t * help us to skip pte prefetch later.\n\t */\n\tmmu_topup_memory_caches(vcpu, true);\n\n\tif (!VALID_PAGE(root_hpa)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\twrite_lock(&vcpu->kvm->mmu_lock);\n\tfor_each_shadow_entry_using_root(vcpu, root_hpa, gva, iterator) {\n\t\tlevel = iterator.level;\n\t\tsptep = iterator.sptep;\n\n\t\tsp = sptep_to_sp(sptep);\n\t\told_spte = *sptep;\n\t\tif (is_last_spte(old_spte, level)) {\n\t\t\tpt_element_t gpte;\n\t\t\tgpa_t pte_gpa;\n\n\t\t\tif (!sp->unsync)\n\t\t\t\tbreak;\n\n\t\t\tpte_gpa = FNAME(get_level1_sp_gpa)(sp);\n\t\t\tpte_gpa += (sptep - sp->spt) * sizeof(pt_element_t);\n\n\t\t\tmmu_page_zap_pte(vcpu->kvm, sp, sptep, NULL);\n\t\t\tif (is_shadow_present_pte(old_spte))\n\t\t\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm,\n\t\t\t\t\tsp->gfn, KVM_PAGES_PER_HPAGE(sp->role.level));\n\n\t\t\tif (!rmap_can_add(vcpu))\n\t\t\t\tbreak;\n\n\t\t\tif (kvm_vcpu_read_guest_atomic(vcpu, pte_gpa, &gpte,\n\t\t\t\t\t\t       sizeof(pt_element_t)))\n\t\t\t\tbreak;\n\n\t\t\tFNAME(update_pte)(vcpu, sp, sptep, &gpte);\n\t\t}\n\n\t\tif (!is_shadow_present_pte(*sptep) || !sp->unsync_children)\n\t\t\tbreak;\n\t}\n\twrite_unlock(&vcpu->kvm->mmu_lock);\n}\n\n/* Note, @addr is a GPA when gva_to_gpa() translates an L2 GPA to an L1 GPA. */\nstatic gpa_t FNAME(gva_to_gpa)(struct kvm_vcpu *vcpu, gpa_t addr, u32 access,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = UNMAPPED_GVA;\n\tint r;\n\n\tr = FNAME(walk_addr)(&walker, vcpu, addr, access);\n\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= addr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\n\treturn gpa;\n}\n\n#if PTTYPE != PTTYPE_EPT\n/* Note, gva_to_gpa_nested() is only used to translate L2 GVAs. */\nstatic gpa_t FNAME(gva_to_gpa_nested)(struct kvm_vcpu *vcpu, gpa_t vaddr,\n\t\t\t\t      u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = UNMAPPED_GVA;\n\tint r;\n\n#ifndef CONFIG_X86_64\n\t/* A 64-bit GVA should be impossible on 32-bit KVM. */\n\tWARN_ON_ONCE(vaddr >> 32);\n#endif\n\n\tr = FNAME(walk_addr_nested)(&walker, vcpu, vaddr, access);\n\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= vaddr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\n\treturn gpa;\n}\n#endif\n\n/*\n * Using the cached information from sp->gfns is safe because:\n * - The spte has a reference to the struct page, so the pfn for a given gfn\n *   can't change unless all sptes pointing to it are nuked first.\n *\n * Note:\n *   We should flush all tlbs if spte is dropped even though guest is\n *   responsible for it. Since if we don't, kvm_mmu_notifier_invalidate_page\n *   and kvm_mmu_notifier_invalidate_range_start detect the mapping page isn't\n *   used by guest then tlbs are not flushed, so guest is allowed to access the\n *   freed pages.\n *   And we increase kvm->tlbs_dirty to delay tlbs flush in this case.\n */\nstatic int FNAME(sync_page)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)\n{\n\tint i, nr_present = 0;\n\tbool host_writable;\n\tgpa_t first_pte_gpa;\n\tint set_spte_ret = 0;\n\n\t/* direct kvm_mmu_page can not be unsync. */\n\tBUG_ON(sp->role.direct);\n\n\tfirst_pte_gpa = FNAME(get_level1_sp_gpa)(sp);\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; i++) {\n\t\tunsigned pte_access;\n\t\tpt_element_t gpte;\n\t\tgpa_t pte_gpa;\n\t\tgfn_t gfn;\n\n\t\tif (!sp->spt[i])\n\t\t\tcontinue;\n\n\t\tpte_gpa = first_pte_gpa + i * sizeof(pt_element_t);\n\n\t\tif (kvm_vcpu_read_guest_atomic(vcpu, pte_gpa, &gpte,\n\t\t\t\t\t       sizeof(pt_element_t)))\n\t\t\treturn 0;\n\n\t\tif (FNAME(prefetch_invalid_gpte)(vcpu, sp, &sp->spt[i], gpte)) {\n\t\t\t/*\n\t\t\t * Update spte before increasing tlbs_dirty to make\n\t\t\t * sure no tlb flush is lost after spte is zapped; see\n\t\t\t * the comments in kvm_flush_remote_tlbs().\n\t\t\t */\n\t\t\tsmp_wmb();\n\t\t\tvcpu->kvm->tlbs_dirty++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tgfn = gpte_to_gfn(gpte);\n\t\tpte_access = sp->role.access;\n\t\tpte_access &= FNAME(gpte_access)(gpte);\n\t\tFNAME(protect_clean_gpte)(vcpu->arch.mmu, &pte_access, gpte);\n\n\t\tif (sync_mmio_spte(vcpu, &sp->spt[i], gfn, pte_access,\n\t\t      &nr_present))\n\t\t\tcontinue;\n\n\t\tif (gfn != sp->gfns[i]) {\n\t\t\tdrop_spte(vcpu->kvm, &sp->spt[i]);\n\t\t\t/*\n\t\t\t * The same as above where we are doing\n\t\t\t * prefetch_invalid_gpte().\n\t\t\t */\n\t\t\tsmp_wmb();\n\t\t\tvcpu->kvm->tlbs_dirty++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnr_present++;\n\n\t\thost_writable = sp->spt[i] & shadow_host_writable_mask;\n\n\t\tset_spte_ret |= set_spte(vcpu, &sp->spt[i],\n\t\t\t\t\t pte_access, PG_LEVEL_4K,\n\t\t\t\t\t gfn, spte_to_pfn(sp->spt[i]),\n\t\t\t\t\t true, false, host_writable);\n\t}\n\n\tif (set_spte_ret & SET_SPTE_NEED_REMOTE_TLB_FLUSH)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\n\treturn nr_present;\n}\n\n#undef pt_element_t\n#undef guest_walker\n#undef FNAME\n#undef PT_BASE_ADDR_MASK\n#undef PT_INDEX\n#undef PT_LVL_ADDR_MASK\n#undef PT_LVL_OFFSET_MASK\n#undef PT_LEVEL_BITS\n#undef PT_MAX_FULL_LEVELS\n#undef gpte_to_gfn\n#undef gpte_to_gfn_lvl\n#undef CMPXCHG\n#undef PT_GUEST_ACCESSED_MASK\n#undef PT_GUEST_DIRTY_MASK\n#undef PT_GUEST_DIRTY_SHIFT\n#undef PT_GUEST_ACCESSED_SHIFT\n#undef PT_HAVE_ACCESSED_DIRTY\n"], "fixing_code": [".. SPDX-License-Identifier: GPL-2.0\n\n======================\nThe x86 kvm shadow mmu\n======================\n\nThe mmu (in arch/x86/kvm, files mmu.[ch] and paging_tmpl.h) is responsible\nfor presenting a standard x86 mmu to the guest, while translating guest\nphysical addresses to host physical addresses.\n\nThe mmu code attempts to satisfy the following requirements:\n\n- correctness:\n\t       the guest should not be able to determine that it is running\n               on an emulated mmu except for timing (we attempt to comply\n               with the specification, not emulate the characteristics of\n               a particular implementation such as tlb size)\n- security:\n\t       the guest must not be able to touch host memory not assigned\n               to it\n- performance:\n               minimize the performance penalty imposed by the mmu\n- scaling:\n               need to scale to large memory and large vcpu guests\n- hardware:\n               support the full range of x86 virtualization hardware\n- integration:\n               Linux memory management code must be in control of guest memory\n               so that swapping, page migration, page merging, transparent\n               hugepages, and similar features work without change\n- dirty tracking:\n               report writes to guest memory to enable live migration\n               and framebuffer-based displays\n- footprint:\n               keep the amount of pinned kernel memory low (most memory\n               should be shrinkable)\n- reliability:\n               avoid multipage or GFP_ATOMIC allocations\n\nAcronyms\n========\n\n====  ====================================================================\npfn   host page frame number\nhpa   host physical address\nhva   host virtual address\ngfn   guest frame number\ngpa   guest physical address\ngva   guest virtual address\nngpa  nested guest physical address\nngva  nested guest virtual address\npte   page table entry (used also to refer generically to paging structure\n      entries)\ngpte  guest pte (referring to gfns)\nspte  shadow pte (referring to pfns)\ntdp   two dimensional paging (vendor neutral term for NPT and EPT)\n====  ====================================================================\n\nVirtual and real hardware supported\n===================================\n\nThe mmu supports first-generation mmu hardware, which allows an atomic switch\nof the current paging mode and cr3 during guest entry, as well as\ntwo-dimensional paging (AMD's NPT and Intel's EPT).  The emulated hardware\nit exposes is the traditional 2/3/4 level x86 mmu, with support for global\npages, pae, pse, pse36, cr0.wp, and 1GB pages. Emulated hardware also\nable to expose NPT capable hardware on NPT capable hosts.\n\nTranslation\n===========\n\nThe primary job of the mmu is to program the processor's mmu to translate\naddresses for the guest.  Different translations are required at different\ntimes:\n\n- when guest paging is disabled, we translate guest physical addresses to\n  host physical addresses (gpa->hpa)\n- when guest paging is enabled, we translate guest virtual addresses, to\n  guest physical addresses, to host physical addresses (gva->gpa->hpa)\n- when the guest launches a guest of its own, we translate nested guest\n  virtual addresses, to nested guest physical addresses, to guest physical\n  addresses, to host physical addresses (ngva->ngpa->gpa->hpa)\n\nThe primary challenge is to encode between 1 and 3 translations into hardware\nthat support only 1 (traditional) and 2 (tdp) translations.  When the\nnumber of required translations matches the hardware, the mmu operates in\ndirect mode; otherwise it operates in shadow mode (see below).\n\nMemory\n======\n\nGuest memory (gpa) is part of the user address space of the process that is\nusing kvm.  Userspace defines the translation between guest addresses and user\naddresses (gpa->hva); note that two gpas may alias to the same hva, but not\nvice versa.\n\nThese hvas may be backed using any method available to the host: anonymous\nmemory, file backed memory, and device memory.  Memory might be paged by the\nhost at any time.\n\nEvents\n======\n\nThe mmu is driven by events, some from the guest, some from the host.\n\nGuest generated events:\n\n- writes to control registers (especially cr3)\n- invlpg/invlpga instruction execution\n- access to missing or protected translations\n\nHost generated events:\n\n- changes in the gpa->hpa translation (either through gpa->hva changes or\n  through hva->hpa changes)\n- memory pressure (the shrinker)\n\nShadow pages\n============\n\nThe principal data structure is the shadow page, 'struct kvm_mmu_page'.  A\nshadow page contains 512 sptes, which can be either leaf or nonleaf sptes.  A\nshadow page may contain a mix of leaf and nonleaf sptes.\n\nA nonleaf spte allows the hardware mmu to reach the leaf pages and\nis not related to a translation directly.  It points to other shadow pages.\n\nA leaf spte corresponds to either one or two translations encoded into\none paging structure entry.  These are always the lowest level of the\ntranslation stack, with optional higher level translations left to NPT/EPT.\nLeaf ptes point at guest pages.\n\nThe following table shows translations encoded by leaf ptes, with higher-level\ntranslations in parentheses:\n\n Non-nested guests::\n\n  nonpaging:     gpa->hpa\n  paging:        gva->gpa->hpa\n  paging, tdp:   (gva->)gpa->hpa\n\n Nested guests::\n\n  non-tdp:       ngva->gpa->hpa  (*)\n  tdp:           (ngva->)ngpa->gpa->hpa\n\n  (*) the guest hypervisor will encode the ngva->gpa translation into its page\n      tables if npt is not present\n\nShadow pages contain the following information:\n  role.level:\n    The level in the shadow paging hierarchy that this shadow page belongs to.\n    1=4k sptes, 2=2M sptes, 3=1G sptes, etc.\n  role.direct:\n    If set, leaf sptes reachable from this page are for a linear range.\n    Examples include real mode translation, large guest pages backed by small\n    host pages, and gpa->hpa translations when NPT or EPT is active.\n    The linear range starts at (gfn << PAGE_SHIFT) and its size is determined\n    by role.level (2MB for first level, 1GB for second level, 0.5TB for third\n    level, 256TB for fourth level)\n    If clear, this page corresponds to a guest page table denoted by the gfn\n    field.\n  role.quadrant:\n    When role.gpte_is_8_bytes=0, the guest uses 32-bit gptes while the host uses 64-bit\n    sptes.  That means a guest page table contains more ptes than the host,\n    so multiple shadow pages are needed to shadow one guest page.\n    For first-level shadow pages, role.quadrant can be 0 or 1 and denotes the\n    first or second 512-gpte block in the guest page table.  For second-level\n    page tables, each 32-bit gpte is converted to two 64-bit sptes\n    (since each first-level guest page is shadowed by two first-level\n    shadow pages) so role.quadrant takes values in the range 0..3.  Each\n    quadrant maps 1GB virtual address space.\n  role.access:\n    Inherited guest access permissions from the parent ptes in the form uwx.\n    Note execute permission is positive, not negative.\n  role.invalid:\n    The page is invalid and should not be used.  It is a root page that is\n    currently pinned (by a cpu hardware register pointing to it); once it is\n    unpinned it will be destroyed.\n  role.gpte_is_8_bytes:\n    Reflects the size of the guest PTE for which the page is valid, i.e. '1'\n    if 64-bit gptes are in use, '0' if 32-bit gptes are in use.\n  role.nxe:\n    Contains the value of efer.nxe for which the page is valid.\n  role.cr0_wp:\n    Contains the value of cr0.wp for which the page is valid.\n  role.smep_andnot_wp:\n    Contains the value of cr4.smep && !cr0.wp for which the page is valid\n    (pages for which this is true are different from other pages; see the\n    treatment of cr0.wp=0 below).\n  role.smap_andnot_wp:\n    Contains the value of cr4.smap && !cr0.wp for which the page is valid\n    (pages for which this is true are different from other pages; see the\n    treatment of cr0.wp=0 below).\n  role.ept_sp:\n    This is a virtual flag to denote a shadowed nested EPT page.  ept_sp\n    is true if \"cr0_wp && smap_andnot_wp\", an otherwise invalid combination.\n  role.smm:\n    Is 1 if the page is valid in system management mode.  This field\n    determines which of the kvm_memslots array was used to build this\n    shadow page; it is also used to go back from a struct kvm_mmu_page\n    to a memslot, through the kvm_memslots_for_spte_role macro and\n    __gfn_to_memslot.\n  role.ad_disabled:\n    Is 1 if the MMU instance cannot use A/D bits.  EPT did not have A/D\n    bits before Haswell; shadow EPT page tables also cannot use A/D bits\n    if the L1 hypervisor does not enable them.\n  gfn:\n    Either the guest page table containing the translations shadowed by this\n    page, or the base page frame for linear translations.  See role.direct.\n  spt:\n    A pageful of 64-bit sptes containing the translations for this page.\n    Accessed by both kvm and hardware.\n    The page pointed to by spt will have its page->private pointing back\n    at the shadow page structure.\n    sptes in spt point either at guest pages, or at lower-level shadow pages.\n    Specifically, if sp1 and sp2 are shadow pages, then sp1->spt[n] may point\n    at __pa(sp2->spt).  sp2 will point back at sp1 through parent_pte.\n    The spt array forms a DAG structure with the shadow page as a node, and\n    guest pages as leaves.\n  gfns:\n    An array of 512 guest frame numbers, one for each present pte.  Used to\n    perform a reverse map from a pte to a gfn. When role.direct is set, any\n    element of this array can be calculated from the gfn field when used, in\n    this case, the array of gfns is not allocated. See role.direct and gfn.\n  root_count:\n    A counter keeping track of how many hardware registers (guest cr3 or\n    pdptrs) are now pointing at the page.  While this counter is nonzero, the\n    page cannot be destroyed.  See role.invalid.\n  parent_ptes:\n    The reverse mapping for the pte/ptes pointing at this page's spt. If\n    parent_ptes bit 0 is zero, only one spte points at this page and\n    parent_ptes points at this single spte, otherwise, there exists multiple\n    sptes pointing at this page and (parent_ptes & ~0x1) points at a data\n    structure with a list of parent sptes.\n  unsync:\n    If true, then the translations in this page may not match the guest's\n    translation.  This is equivalent to the state of the tlb when a pte is\n    changed but before the tlb entry is flushed.  Accordingly, unsync ptes\n    are synchronized when the guest executes invlpg or flushes its tlb by\n    other means.  Valid for leaf pages.\n  unsync_children:\n    How many sptes in the page point at pages that are unsync (or have\n    unsynchronized children).\n  unsync_child_bitmap:\n    A bitmap indicating which sptes in spt point (directly or indirectly) at\n    pages that may be unsynchronized.  Used to quickly locate all unsychronized\n    pages reachable from a given page.\n  clear_spte_count:\n    Only present on 32-bit hosts, where a 64-bit spte cannot be written\n    atomically.  The reader uses this while running out of the MMU lock\n    to detect in-progress updates and retry them until the writer has\n    finished the write.\n  write_flooding_count:\n    A guest may write to a page table many times, causing a lot of\n    emulations if the page needs to be write-protected (see \"Synchronized\n    and unsynchronized pages\" below).  Leaf pages can be unsynchronized\n    so that they do not trigger frequent emulation, but this is not\n    possible for non-leafs.  This field counts the number of emulations\n    since the last time the page table was actually used; if emulation\n    is triggered too frequently on this page, KVM will unmap the page\n    to avoid emulation in the future.\n\nReverse map\n===========\n\nThe mmu maintains a reverse mapping whereby all ptes mapping a page can be\nreached given its gfn.  This is used, for example, when swapping out a page.\n\nSynchronized and unsynchronized pages\n=====================================\n\nThe guest uses two events to synchronize its tlb and page tables: tlb flushes\nand page invalidations (invlpg).\n\nA tlb flush means that we need to synchronize all sptes reachable from the\nguest's cr3.  This is expensive, so we keep all guest page tables write\nprotected, and synchronize sptes to gptes when a gpte is written.\n\nA special case is when a guest page table is reachable from the current\nguest cr3.  In this case, the guest is obliged to issue an invlpg instruction\nbefore using the translation.  We take advantage of that by removing write\nprotection from the guest page, and allowing the guest to modify it freely.\nWe synchronize modified gptes when the guest invokes invlpg.  This reduces\nthe amount of emulation we have to do when the guest modifies multiple gptes,\nor when the a guest page is no longer used as a page table and is used for\nrandom guest data.\n\nAs a side effect we have to resynchronize all reachable unsynchronized shadow\npages on a tlb flush.\n\n\nReaction to events\n==================\n\n- guest page fault (or npt page fault, or ept violation)\n\nThis is the most complicated event.  The cause of a page fault can be:\n\n  - a true guest fault (the guest translation won't allow the access) (*)\n  - access to a missing translation\n  - access to a protected translation\n    - when logging dirty pages, memory is write protected\n    - synchronized shadow pages are write protected (*)\n  - access to untranslatable memory (mmio)\n\n  (*) not applicable in direct mode\n\nHandling a page fault is performed as follows:\n\n - if the RSV bit of the error code is set, the page fault is caused by guest\n   accessing MMIO and cached MMIO information is available.\n\n   - walk shadow page table\n   - check for valid generation number in the spte (see \"Fast invalidation of\n     MMIO sptes\" below)\n   - cache the information to vcpu->arch.mmio_gva, vcpu->arch.mmio_access and\n     vcpu->arch.mmio_gfn, and call the emulator\n\n - If both P bit and R/W bit of error code are set, this could possibly\n   be handled as a \"fast page fault\" (fixed without taking the MMU lock).  See\n   the description in Documentation/virt/kvm/locking.rst.\n\n - if needed, walk the guest page tables to determine the guest translation\n   (gva->gpa or ngpa->gpa)\n\n   - if permissions are insufficient, reflect the fault back to the guest\n\n - determine the host page\n\n   - if this is an mmio request, there is no host page; cache the info to\n     vcpu->arch.mmio_gva, vcpu->arch.mmio_access and vcpu->arch.mmio_gfn\n\n - walk the shadow page table to find the spte for the translation,\n   instantiating missing intermediate page tables as necessary\n\n   - If this is an mmio request, cache the mmio info to the spte and set some\n     reserved bit on the spte (see callers of kvm_mmu_set_mmio_spte_mask)\n\n - try to unsynchronize the page\n\n   - if successful, we can let the guest continue and modify the gpte\n\n - emulate the instruction\n\n   - if failed, unshadow the page and let the guest continue\n\n - update any translations that were modified by the instruction\n\ninvlpg handling:\n\n  - walk the shadow page hierarchy and drop affected translations\n  - try to reinstantiate the indicated translation in the hope that the\n    guest will use it in the near future\n\nGuest control register updates:\n\n- mov to cr3\n\n  - look up new shadow roots\n  - synchronize newly reachable shadow pages\n\n- mov to cr0/cr4/efer\n\n  - set up mmu context for new paging mode\n  - look up new shadow roots\n  - synchronize newly reachable shadow pages\n\nHost translation updates:\n\n  - mmu notifier called with updated hva\n  - look up affected sptes through reverse map\n  - drop (or update) translations\n\nEmulating cr0.wp\n================\n\nIf tdp is not enabled, the host must keep cr0.wp=1 so page write protection\nworks for the guest kernel, not guest guest userspace.  When the guest\ncr0.wp=1, this does not present a problem.  However when the guest cr0.wp=0,\nwe cannot map the permissions for gpte.u=1, gpte.w=0 to any spte (the\nsemantics require allowing any guest kernel access plus user read access).\n\nWe handle this by mapping the permissions to two possible sptes, depending\non fault type:\n\n- kernel write fault: spte.u=0, spte.w=1 (allows full kernel access,\n  disallows user access)\n- read fault: spte.u=1, spte.w=0 (allows full read access, disallows kernel\n  write access)\n\n(user write faults generate a #PF)\n\nIn the first case there are two additional complications:\n\n- if CR4.SMEP is enabled: since we've turned the page into a kernel page,\n  the kernel may now execute it.  We handle this by also setting spte.nx.\n  If we get a user fetch or read fault, we'll change spte.u=1 and\n  spte.nx=gpte.nx back.  For this to work, KVM forces EFER.NX to 1 when\n  shadow paging is in use.\n- if CR4.SMAP is disabled: since the page has been changed to a kernel\n  page, it can not be reused when CR4.SMAP is enabled. We set\n  CR4.SMAP && !CR0.WP into shadow page's role to avoid this case. Note,\n  here we do not care the case that CR4.SMAP is enabled since KVM will\n  directly inject #PF to guest due to failed permission check.\n\nTo prevent an spte that was converted into a kernel page with cr0.wp=0\nfrom being written by the kernel after cr0.wp has changed to 1, we make\nthe value of cr0.wp part of the page role.  This means that an spte created\nwith one value of cr0.wp cannot be used when cr0.wp has a different value -\nit will simply be missed by the shadow page lookup code.  A similar issue\nexists when an spte created with cr0.wp=0 and cr4.smep=0 is used after\nchanging cr4.smep to 1.  To avoid this, the value of !cr0.wp && cr4.smep\nis also made a part of the page role.\n\nLarge pages\n===========\n\nThe mmu supports all combinations of large and small guest and host pages.\nSupported page sizes include 4k, 2M, 4M, and 1G.  4M pages are treated as\ntwo separate 2M pages, on both guest and host, since the mmu always uses PAE\npaging.\n\nTo instantiate a large spte, four constraints must be satisfied:\n\n- the spte must point to a large host page\n- the guest pte must be a large pte of at least equivalent size (if tdp is\n  enabled, there is no guest pte and this condition is satisfied)\n- if the spte will be writeable, the large page frame may not overlap any\n  write-protected pages\n- the guest page must be wholly contained by a single memory slot\n\nTo check the last two conditions, the mmu maintains a ->disallow_lpage set of\narrays for each memory slot and large page size.  Every write protected page\ncauses its disallow_lpage to be incremented, thus preventing instantiation of\na large spte.  The frames at the end of an unaligned memory slot have\nartificially inflated ->disallow_lpages so they can never be instantiated.\n\nFast invalidation of MMIO sptes\n===============================\n\nAs mentioned in \"Reaction to events\" above, kvm will cache MMIO\ninformation in leaf sptes.  When a new memslot is added or an existing\nmemslot is changed, this information may become stale and needs to be\ninvalidated.  This also needs to hold the MMU lock while walking all\nshadow pages, and is made more scalable with a similar technique.\n\nMMIO sptes have a few spare bits, which are used to store a\ngeneration number.  The global generation number is stored in\nkvm_memslots(kvm)->generation, and increased whenever guest memory info\nchanges.\n\nWhen KVM finds an MMIO spte, it checks the generation number of the spte.\nIf the generation number of the spte does not equal the global generation\nnumber, it will ignore the cached MMIO information and handle the page\nfault through the slow path.\n\nSince only 18 bits are used to store generation-number on mmio spte, all\npages are zapped when there is an overflow.\n\nUnfortunately, a single memory access might access kvm_memslots(kvm) multiple\ntimes, the last one happening when the generation number is retrieved and\nstored into the MMIO spte.  Thus, the MMIO spte might be created based on\nout-of-date information, but with an up-to-date generation number.\n\nTo avoid this, the generation number is incremented again after synchronize_srcu\nreturns; thus, bit 63 of kvm_memslots(kvm)->generation set to 1 only during a\nmemslot update, while some SRCU readers might be using the old copy.  We do not\nwant to use an MMIO sptes created with an odd generation number, and we can do\nthis without losing a bit in the MMIO spte.  The \"update in-progress\" bit of the\ngeneration is not stored in MMIO spte, and is so is implicitly zero when the\ngeneration is extracted out of the spte.  If KVM is unlucky and creates an MMIO\nspte while an update is in-progress, the next access to the spte will always be\na cache miss.  For example, a subsequent access during the update window will\nmiss due to the in-progress flag diverging, while an access after the update\nwindow closes will have a higher generation number (as compared to the spte).\n\n\nFurther reading\n===============\n\n- NPT presentation from KVM Forum 2008\n  https://www.linux-kvm.org/images/c/c8/KvmForum2008%24kdf2008_21.pdf\n", "/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This module enables machines with Intel VT-x extensions to run virtual\n * machines without emulation or binary translation.\n *\n * MMU support\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *   Avi Kivity   <avi@qumranet.com>\n */\n\n/*\n * We need the mmu code to access both 32-bit and 64-bit guest ptes,\n * so the code in this file is compiled twice, once per pte size.\n */\n\n#if PTTYPE == 64\n\t#define pt_element_t u64\n\t#define guest_walker guest_walker64\n\t#define FNAME(name) paging##64_##name\n\t#define PT_BASE_ADDR_MASK PT64_BASE_ADDR_MASK\n\t#define PT_LVL_ADDR_MASK(lvl) PT64_LVL_ADDR_MASK(lvl)\n\t#define PT_LVL_OFFSET_MASK(lvl) PT64_LVL_OFFSET_MASK(lvl)\n\t#define PT_INDEX(addr, level) PT64_INDEX(addr, level)\n\t#define PT_LEVEL_BITS PT64_LEVEL_BITS\n\t#define PT_GUEST_DIRTY_SHIFT PT_DIRTY_SHIFT\n\t#define PT_GUEST_ACCESSED_SHIFT PT_ACCESSED_SHIFT\n\t#define PT_HAVE_ACCESSED_DIRTY(mmu) true\n\t#ifdef CONFIG_X86_64\n\t#define PT_MAX_FULL_LEVELS PT64_ROOT_MAX_LEVEL\n\t#define CMPXCHG cmpxchg\n\t#else\n\t#define CMPXCHG cmpxchg64\n\t#define PT_MAX_FULL_LEVELS 2\n\t#endif\n#elif PTTYPE == 32\n\t#define pt_element_t u32\n\t#define guest_walker guest_walker32\n\t#define FNAME(name) paging##32_##name\n\t#define PT_BASE_ADDR_MASK PT32_BASE_ADDR_MASK\n\t#define PT_LVL_ADDR_MASK(lvl) PT32_LVL_ADDR_MASK(lvl)\n\t#define PT_LVL_OFFSET_MASK(lvl) PT32_LVL_OFFSET_MASK(lvl)\n\t#define PT_INDEX(addr, level) PT32_INDEX(addr, level)\n\t#define PT_LEVEL_BITS PT32_LEVEL_BITS\n\t#define PT_MAX_FULL_LEVELS 2\n\t#define PT_GUEST_DIRTY_SHIFT PT_DIRTY_SHIFT\n\t#define PT_GUEST_ACCESSED_SHIFT PT_ACCESSED_SHIFT\n\t#define PT_HAVE_ACCESSED_DIRTY(mmu) true\n\t#define CMPXCHG cmpxchg\n#elif PTTYPE == PTTYPE_EPT\n\t#define pt_element_t u64\n\t#define guest_walker guest_walkerEPT\n\t#define FNAME(name) ept_##name\n\t#define PT_BASE_ADDR_MASK PT64_BASE_ADDR_MASK\n\t#define PT_LVL_ADDR_MASK(lvl) PT64_LVL_ADDR_MASK(lvl)\n\t#define PT_LVL_OFFSET_MASK(lvl) PT64_LVL_OFFSET_MASK(lvl)\n\t#define PT_INDEX(addr, level) PT64_INDEX(addr, level)\n\t#define PT_LEVEL_BITS PT64_LEVEL_BITS\n\t#define PT_GUEST_DIRTY_SHIFT 9\n\t#define PT_GUEST_ACCESSED_SHIFT 8\n\t#define PT_HAVE_ACCESSED_DIRTY(mmu) ((mmu)->ept_ad)\n\t#define CMPXCHG cmpxchg64\n\t#define PT_MAX_FULL_LEVELS PT64_ROOT_MAX_LEVEL\n#else\n\t#error Invalid PTTYPE value\n#endif\n\n#define PT_GUEST_DIRTY_MASK    (1 << PT_GUEST_DIRTY_SHIFT)\n#define PT_GUEST_ACCESSED_MASK (1 << PT_GUEST_ACCESSED_SHIFT)\n\n#define gpte_to_gfn_lvl FNAME(gpte_to_gfn_lvl)\n#define gpte_to_gfn(pte) gpte_to_gfn_lvl((pte), PG_LEVEL_4K)\n\n/*\n * The guest_walker structure emulates the behavior of the hardware page\n * table walker.\n */\nstruct guest_walker {\n\tint level;\n\tunsigned max_level;\n\tgfn_t table_gfn[PT_MAX_FULL_LEVELS];\n\tpt_element_t ptes[PT_MAX_FULL_LEVELS];\n\tpt_element_t prefetch_ptes[PTE_PREFETCH_NUM];\n\tgpa_t pte_gpa[PT_MAX_FULL_LEVELS];\n\tpt_element_t __user *ptep_user[PT_MAX_FULL_LEVELS];\n\tbool pte_writable[PT_MAX_FULL_LEVELS];\n\tunsigned int pt_access[PT_MAX_FULL_LEVELS];\n\tunsigned int pte_access;\n\tgfn_t gfn;\n\tstruct x86_exception fault;\n};\n\nstatic gfn_t gpte_to_gfn_lvl(pt_element_t gpte, int lvl)\n{\n\treturn (gpte & PT_LVL_ADDR_MASK(lvl)) >> PAGE_SHIFT;\n}\n\nstatic inline void FNAME(protect_clean_gpte)(struct kvm_mmu *mmu, unsigned *access,\n\t\t\t\t\t     unsigned gpte)\n{\n\tunsigned mask;\n\n\t/* dirty bit is not supported, so no need to track it */\n\tif (!PT_HAVE_ACCESSED_DIRTY(mmu))\n\t\treturn;\n\n\tBUILD_BUG_ON(PT_WRITABLE_MASK != ACC_WRITE_MASK);\n\n\tmask = (unsigned)~ACC_WRITE_MASK;\n\t/* Allow write access to dirty gptes */\n\tmask |= (gpte >> (PT_GUEST_DIRTY_SHIFT - PT_WRITABLE_SHIFT)) &\n\t\tPT_WRITABLE_MASK;\n\t*access &= mask;\n}\n\nstatic inline int FNAME(is_present_gpte)(unsigned long pte)\n{\n#if PTTYPE != PTTYPE_EPT\n\treturn pte & PT_PRESENT_MASK;\n#else\n\treturn pte & 7;\n#endif\n}\n\nstatic bool FNAME(is_bad_mt_xwr)(struct rsvd_bits_validate *rsvd_check, u64 gpte)\n{\n#if PTTYPE != PTTYPE_EPT\n\treturn false;\n#else\n\treturn __is_bad_mt_xwr(rsvd_check, gpte);\n#endif\n}\n\nstatic bool FNAME(is_rsvd_bits_set)(struct kvm_mmu *mmu, u64 gpte, int level)\n{\n\treturn __is_rsvd_bits_set(&mmu->guest_rsvd_check, gpte, level) ||\n\t       FNAME(is_bad_mt_xwr)(&mmu->guest_rsvd_check, gpte);\n}\n\nstatic int FNAME(cmpxchg_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t       pt_element_t __user *ptep_user, unsigned index,\n\t\t\t       pt_element_t orig_pte, pt_element_t new_pte)\n{\n\tint npages;\n\tpt_element_t ret;\n\tpt_element_t *table;\n\tstruct page *page;\n\n\tnpages = get_user_pages_fast((unsigned long)ptep_user, 1, FOLL_WRITE, &page);\n\tif (likely(npages == 1)) {\n\t\ttable = kmap_atomic(page);\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tkunmap_atomic(table);\n\n\t\tkvm_release_page_dirty(page);\n\t} else {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned long vaddr = (unsigned long)ptep_user & PAGE_MASK;\n\t\tunsigned long pfn;\n\t\tunsigned long paddr;\n\n\t\tmmap_read_lock(current->mm);\n\t\tvma = find_vma_intersection(current->mm, vaddr, vaddr + PAGE_SIZE);\n\t\tif (!vma || !(vma->vm_flags & VM_PFNMAP)) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tpfn = ((vaddr - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\t\tpaddr = pfn << PAGE_SHIFT;\n\t\ttable = memremap(paddr, PAGE_SIZE, MEMREMAP_WB);\n\t\tif (!table) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tmemunmap(table);\n\t\tmmap_read_unlock(current->mm);\n\t}\n\n\treturn (ret != orig_pte);\n}\n\nstatic bool FNAME(prefetch_invalid_gpte)(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  u64 gpte)\n{\n\tif (!FNAME(is_present_gpte)(gpte))\n\t\tgoto no_present;\n\n\t/* if accessed bit is not supported prefetch non accessed gpte */\n\tif (PT_HAVE_ACCESSED_DIRTY(vcpu->arch.mmu) &&\n\t    !(gpte & PT_GUEST_ACCESSED_MASK))\n\t\tgoto no_present;\n\n\tif (FNAME(is_rsvd_bits_set)(vcpu->arch.mmu, gpte, PG_LEVEL_4K))\n\t\tgoto no_present;\n\n\treturn false;\n\nno_present:\n\tdrop_spte(vcpu->kvm, spte);\n\treturn true;\n}\n\n/*\n * For PTTYPE_EPT, a page table can be executable but not readable\n * on supported processors. Therefore, set_spte does not automatically\n * set bit 0 if execute only is supported. Here, we repurpose ACC_USER_MASK\n * to signify readability since it isn't used in the EPT case\n */\nstatic inline unsigned FNAME(gpte_access)(u64 gpte)\n{\n\tunsigned access;\n#if PTTYPE == PTTYPE_EPT\n\taccess = ((gpte & VMX_EPT_WRITABLE_MASK) ? ACC_WRITE_MASK : 0) |\n\t\t((gpte & VMX_EPT_EXECUTABLE_MASK) ? ACC_EXEC_MASK : 0) |\n\t\t((gpte & VMX_EPT_READABLE_MASK) ? ACC_USER_MASK : 0);\n#else\n\tBUILD_BUG_ON(ACC_EXEC_MASK != PT_PRESENT_MASK);\n\tBUILD_BUG_ON(ACC_EXEC_MASK != 1);\n\taccess = gpte & (PT_WRITABLE_MASK | PT_USER_MASK | PT_PRESENT_MASK);\n\t/* Combine NX with P (which is set here) to get ACC_EXEC_MASK.  */\n\taccess ^= (gpte >> PT64_NX_SHIFT);\n#endif\n\n\treturn access;\n}\n\nstatic int FNAME(update_accessed_dirty_bits)(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_mmu *mmu,\n\t\t\t\t\t     struct guest_walker *walker,\n\t\t\t\t\t     gpa_t addr, int write_fault)\n{\n\tunsigned level, index;\n\tpt_element_t pte, orig_pte;\n\tpt_element_t __user *ptep_user;\n\tgfn_t table_gfn;\n\tint ret;\n\n\t/* dirty/accessed bits are not supported, so no need to update them */\n\tif (!PT_HAVE_ACCESSED_DIRTY(mmu))\n\t\treturn 0;\n\n\tfor (level = walker->max_level; level >= walker->level; --level) {\n\t\tpte = orig_pte = walker->ptes[level - 1];\n\t\ttable_gfn = walker->table_gfn[level - 1];\n\t\tptep_user = walker->ptep_user[level - 1];\n\t\tindex = offset_in_page(ptep_user) / sizeof(pt_element_t);\n\t\tif (!(pte & PT_GUEST_ACCESSED_MASK)) {\n\t\t\ttrace_kvm_mmu_set_accessed_bit(table_gfn, index, sizeof(pte));\n\t\t\tpte |= PT_GUEST_ACCESSED_MASK;\n\t\t}\n\t\tif (level == walker->level && write_fault &&\n\t\t\t\t!(pte & PT_GUEST_DIRTY_MASK)) {\n\t\t\ttrace_kvm_mmu_set_dirty_bit(table_gfn, index, sizeof(pte));\n#if PTTYPE == PTTYPE_EPT\n\t\t\tif (kvm_x86_ops.nested_ops->write_log_dirty(vcpu, addr))\n\t\t\t\treturn -EINVAL;\n#endif\n\t\t\tpte |= PT_GUEST_DIRTY_MASK;\n\t\t}\n\t\tif (pte == orig_pte)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If the slot is read-only, simply do not process the accessed\n\t\t * and dirty bits.  This is the correct thing to do if the slot\n\t\t * is ROM, and page tables in read-as-ROM/write-as-MMIO slots\n\t\t * are only supported if the accessed and dirty bits are already\n\t\t * set in the ROM (so that MMIO writes are never needed).\n\t\t *\n\t\t * Note that NPT does not allow this at all and faults, since\n\t\t * it always wants nested page table entries for the guest\n\t\t * page tables to be writable.  And EPT works but will simply\n\t\t * overwrite the read-only memory to set the accessed and dirty\n\t\t * bits.\n\t\t */\n\t\tif (unlikely(!walker->pte_writable[level - 1]))\n\t\t\tcontinue;\n\n\t\tret = FNAME(cmpxchg_gpte)(vcpu, mmu, ptep_user, index, orig_pte, pte);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tkvm_vcpu_mark_page_dirty(vcpu, table_gfn);\n\t\twalker->ptes[level - 1] = pte;\n\t}\n\treturn 0;\n}\n\nstatic inline unsigned FNAME(gpte_pkeys)(struct kvm_vcpu *vcpu, u64 gpte)\n{\n\tunsigned pkeys = 0;\n#if PTTYPE == 64\n\tpte_t pte = {.pte = gpte};\n\n\tpkeys = pte_flags_pkey(pte_flags(pte));\n#endif\n\treturn pkeys;\n}\n\n/*\n * Fetch a guest pte for a guest virtual address, or for an L2's GPA.\n */\nstatic int FNAME(walk_addr_generic)(struct guest_walker *walker,\n\t\t\t\t    struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\t    gpa_t addr, u32 access)\n{\n\tint ret;\n\tpt_element_t pte;\n\tpt_element_t __user *ptep_user;\n\tgfn_t table_gfn;\n\tu64 pt_access, pte_access;\n\tunsigned index, accessed_dirty, pte_pkey;\n\tunsigned nested_access;\n\tgpa_t pte_gpa;\n\tbool have_ad;\n\tint offset;\n\tu64 walk_nx_mask = 0;\n\tconst int write_fault = access & PFERR_WRITE_MASK;\n\tconst int user_fault  = access & PFERR_USER_MASK;\n\tconst int fetch_fault = access & PFERR_FETCH_MASK;\n\tu16 errcode = 0;\n\tgpa_t real_gpa;\n\tgfn_t gfn;\n\n\ttrace_kvm_mmu_pagetable_walk(addr, access);\nretry_walk:\n\twalker->level = mmu->root_level;\n\tpte           = mmu->get_guest_pgd(vcpu);\n\thave_ad       = PT_HAVE_ACCESSED_DIRTY(mmu);\n\n#if PTTYPE == 64\n\twalk_nx_mask = 1ULL << PT64_NX_SHIFT;\n\tif (walker->level == PT32E_ROOT_LEVEL) {\n\t\tpte = mmu->get_pdptr(vcpu, (addr >> 30) & 3);\n\t\ttrace_kvm_mmu_paging_element(pte, walker->level);\n\t\tif (!FNAME(is_present_gpte)(pte))\n\t\t\tgoto error;\n\t\t--walker->level;\n\t}\n#endif\n\twalker->max_level = walker->level;\n\tASSERT(!(is_long_mode(vcpu) && !is_pae(vcpu)));\n\n\t/*\n\t * FIXME: on Intel processors, loads of the PDPTE registers for PAE paging\n\t * by the MOV to CR instruction are treated as reads and do not cause the\n\t * processor to set the dirty flag in any EPT paging-structure entry.\n\t */\n\tnested_access = (have_ad ? PFERR_WRITE_MASK : 0) | PFERR_USER_MASK;\n\n\tpte_access = ~0;\n\t++walker->level;\n\n\tdo {\n\t\tunsigned long host_addr;\n\n\t\tpt_access = pte_access;\n\t\t--walker->level;\n\n\t\tindex = PT_INDEX(addr, walker->level);\n\t\ttable_gfn = gpte_to_gfn(pte);\n\t\toffset    = index * sizeof(pt_element_t);\n\t\tpte_gpa   = gfn_to_gpa(table_gfn) + offset;\n\n\t\tBUG_ON(walker->level < 1);\n\t\twalker->table_gfn[walker->level - 1] = table_gfn;\n\t\twalker->pte_gpa[walker->level - 1] = pte_gpa;\n\n\t\treal_gpa = mmu->translate_gpa(vcpu, gfn_to_gpa(table_gfn),\n\t\t\t\t\t      nested_access,\n\t\t\t\t\t      &walker->fault);\n\n\t\t/*\n\t\t * FIXME: This can happen if emulation (for of an INS/OUTS\n\t\t * instruction) triggers a nested page fault.  The exit\n\t\t * qualification / exit info field will incorrectly have\n\t\t * \"guest page access\" as the nested page fault's cause,\n\t\t * instead of \"guest page structure access\".  To fix this,\n\t\t * the x86_exception struct should be augmented with enough\n\t\t * information to fix the exit_qualification or exit_info_1\n\t\t * fields.\n\t\t */\n\t\tif (unlikely(real_gpa == UNMAPPED_GVA))\n\t\t\treturn 0;\n\n\t\thost_addr = kvm_vcpu_gfn_to_hva_prot(vcpu, gpa_to_gfn(real_gpa),\n\t\t\t\t\t    &walker->pte_writable[walker->level - 1]);\n\t\tif (unlikely(kvm_is_error_hva(host_addr)))\n\t\t\tgoto error;\n\n\t\tptep_user = (pt_element_t __user *)((void *)host_addr + offset);\n\t\tif (unlikely(__get_user(pte, ptep_user)))\n\t\t\tgoto error;\n\t\twalker->ptep_user[walker->level - 1] = ptep_user;\n\n\t\ttrace_kvm_mmu_paging_element(pte, walker->level);\n\n\t\t/*\n\t\t * Inverting the NX it lets us AND it like other\n\t\t * permission bits.\n\t\t */\n\t\tpte_access = pt_access & (pte ^ walk_nx_mask);\n\n\t\tif (unlikely(!FNAME(is_present_gpte)(pte)))\n\t\t\tgoto error;\n\n\t\tif (unlikely(FNAME(is_rsvd_bits_set)(mmu, pte, walker->level))) {\n\t\t\terrcode = PFERR_RSVD_MASK | PFERR_PRESENT_MASK;\n\t\t\tgoto error;\n\t\t}\n\n\t\twalker->ptes[walker->level - 1] = pte;\n\n\t\t/* Convert to ACC_*_MASK flags for struct guest_walker.  */\n\t\twalker->pt_access[walker->level - 1] = FNAME(gpte_access)(pt_access ^ walk_nx_mask);\n\t} while (!is_last_gpte(mmu, walker->level, pte));\n\n\tpte_pkey = FNAME(gpte_pkeys)(vcpu, pte);\n\taccessed_dirty = have_ad ? pte_access & PT_GUEST_ACCESSED_MASK : 0;\n\n\t/* Convert to ACC_*_MASK flags for struct guest_walker.  */\n\twalker->pte_access = FNAME(gpte_access)(pte_access ^ walk_nx_mask);\n\terrcode = permission_fault(vcpu, mmu, walker->pte_access, pte_pkey, access);\n\tif (unlikely(errcode))\n\t\tgoto error;\n\n\tgfn = gpte_to_gfn_lvl(pte, walker->level);\n\tgfn += (addr & PT_LVL_OFFSET_MASK(walker->level)) >> PAGE_SHIFT;\n\n\tif (PTTYPE == 32 && walker->level > PG_LEVEL_4K && is_cpuid_PSE36())\n\t\tgfn += pse36_gfn_delta(pte);\n\n\treal_gpa = mmu->translate_gpa(vcpu, gfn_to_gpa(gfn), access, &walker->fault);\n\tif (real_gpa == UNMAPPED_GVA)\n\t\treturn 0;\n\n\twalker->gfn = real_gpa >> PAGE_SHIFT;\n\n\tif (!write_fault)\n\t\tFNAME(protect_clean_gpte)(mmu, &walker->pte_access, pte);\n\telse\n\t\t/*\n\t\t * On a write fault, fold the dirty bit into accessed_dirty.\n\t\t * For modes without A/D bits support accessed_dirty will be\n\t\t * always clear.\n\t\t */\n\t\taccessed_dirty &= pte >>\n\t\t\t(PT_GUEST_DIRTY_SHIFT - PT_GUEST_ACCESSED_SHIFT);\n\n\tif (unlikely(!accessed_dirty)) {\n\t\tret = FNAME(update_accessed_dirty_bits)(vcpu, mmu, walker,\n\t\t\t\t\t\t\taddr, write_fault);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error;\n\t\telse if (ret)\n\t\t\tgoto retry_walk;\n\t}\n\n\tpgprintk(\"%s: pte %llx pte_access %x pt_access %x\\n\",\n\t\t __func__, (u64)pte, walker->pte_access,\n\t\t walker->pt_access[walker->level - 1]);\n\treturn 1;\n\nerror:\n\terrcode |= write_fault | user_fault;\n\tif (fetch_fault && (mmu->nx ||\n\t\t\t    kvm_read_cr4_bits(vcpu, X86_CR4_SMEP)))\n\t\terrcode |= PFERR_FETCH_MASK;\n\n\twalker->fault.vector = PF_VECTOR;\n\twalker->fault.error_code_valid = true;\n\twalker->fault.error_code = errcode;\n\n#if PTTYPE == PTTYPE_EPT\n\t/*\n\t * Use PFERR_RSVD_MASK in error_code to to tell if EPT\n\t * misconfiguration requires to be injected. The detection is\n\t * done by is_rsvd_bits_set() above.\n\t *\n\t * We set up the value of exit_qualification to inject:\n\t * [2:0] - Derive from the access bits. The exit_qualification might be\n\t *         out of date if it is serving an EPT misconfiguration.\n\t * [5:3] - Calculated by the page walk of the guest EPT page tables\n\t * [7:8] - Derived from [7:8] of real exit_qualification\n\t *\n\t * The other bits are set to 0.\n\t */\n\tif (!(errcode & PFERR_RSVD_MASK)) {\n\t\tvcpu->arch.exit_qualification &= 0x180;\n\t\tif (write_fault)\n\t\t\tvcpu->arch.exit_qualification |= EPT_VIOLATION_ACC_WRITE;\n\t\tif (user_fault)\n\t\t\tvcpu->arch.exit_qualification |= EPT_VIOLATION_ACC_READ;\n\t\tif (fetch_fault)\n\t\t\tvcpu->arch.exit_qualification |= EPT_VIOLATION_ACC_INSTR;\n\t\tvcpu->arch.exit_qualification |= (pte_access & 0x7) << 3;\n\t}\n#endif\n\twalker->fault.address = addr;\n\twalker->fault.nested_page_fault = mmu != vcpu->arch.walk_mmu;\n\twalker->fault.async_page_fault = false;\n\n\ttrace_kvm_mmu_walker_error(walker->fault.error_code);\n\treturn 0;\n}\n\nstatic int FNAME(walk_addr)(struct guest_walker *walker,\n\t\t\t    struct kvm_vcpu *vcpu, gpa_t addr, u32 access)\n{\n\treturn FNAME(walk_addr_generic)(walker, vcpu, vcpu->arch.mmu, addr,\n\t\t\t\t\taccess);\n}\n\n#if PTTYPE != PTTYPE_EPT\nstatic int FNAME(walk_addr_nested)(struct guest_walker *walker,\n\t\t\t\t   struct kvm_vcpu *vcpu, gva_t addr,\n\t\t\t\t   u32 access)\n{\n\treturn FNAME(walk_addr_generic)(walker, vcpu, &vcpu->arch.nested_mmu,\n\t\t\t\t\taddr, access);\n}\n#endif\n\nstatic bool\nFNAME(prefetch_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t     u64 *spte, pt_element_t gpte, bool no_dirty_log)\n{\n\tunsigned pte_access;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\n\tif (FNAME(prefetch_invalid_gpte)(vcpu, sp, spte, gpte))\n\t\treturn false;\n\n\tpgprintk(\"%s: gpte %llx spte %p\\n\", __func__, (u64)gpte, spte);\n\n\tgfn = gpte_to_gfn(gpte);\n\tpte_access = sp->role.access & FNAME(gpte_access)(gpte);\n\tFNAME(protect_clean_gpte)(vcpu->arch.mmu, &pte_access, gpte);\n\tpfn = pte_prefetch_gfn_to_pfn(vcpu, gfn,\n\t\t\tno_dirty_log && (pte_access & ACC_WRITE_MASK));\n\tif (is_error_pfn(pfn))\n\t\treturn false;\n\n\t/*\n\t * we call mmu_set_spte() with host_writable = true because\n\t * pte_prefetch_gfn_to_pfn always gets a writable pfn.\n\t */\n\tmmu_set_spte(vcpu, spte, pte_access, false, PG_LEVEL_4K, gfn, pfn,\n\t\t     true, true);\n\n\tkvm_release_pfn_clean(pfn);\n\treturn true;\n}\n\nstatic void FNAME(update_pte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t      u64 *spte, const void *pte)\n{\n\tpt_element_t gpte = *(const pt_element_t *)pte;\n\n\tFNAME(prefetch_gpte)(vcpu, sp, spte, gpte, false);\n}\n\nstatic bool FNAME(gpte_changed)(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct guest_walker *gw, int level)\n{\n\tpt_element_t curr_pte;\n\tgpa_t base_gpa, pte_gpa = gw->pte_gpa[level - 1];\n\tu64 mask;\n\tint r, index;\n\n\tif (level == PG_LEVEL_4K) {\n\t\tmask = PTE_PREFETCH_NUM * sizeof(pt_element_t) - 1;\n\t\tbase_gpa = pte_gpa & ~mask;\n\t\tindex = (pte_gpa - base_gpa) / sizeof(pt_element_t);\n\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, base_gpa,\n\t\t\t\tgw->prefetch_ptes, sizeof(gw->prefetch_ptes));\n\t\tcurr_pte = gw->prefetch_ptes[index];\n\t} else\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, pte_gpa,\n\t\t\t\t  &curr_pte, sizeof(curr_pte));\n\n\treturn r || curr_pte != gw->ptes[level - 1];\n}\n\nstatic void FNAME(pte_prefetch)(struct kvm_vcpu *vcpu, struct guest_walker *gw,\n\t\t\t\tu64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\tpt_element_t *gptep = gw->prefetch_ptes;\n\tu64 *spte;\n\tint i;\n\n\tsp = sptep_to_sp(sptep);\n\n\tif (sp->role.level > PG_LEVEL_4K)\n\t\treturn;\n\n\t/*\n\t * If addresses are being invalidated, skip prefetching to avoid\n\t * accidentally prefetching those addresses.\n\t */\n\tif (unlikely(vcpu->kvm->mmu_notifier_count))\n\t\treturn;\n\n\tif (sp->role.direct)\n\t\treturn __direct_pte_prefetch(vcpu, sp, sptep);\n\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (spte == sptep)\n\t\t\tcontinue;\n\n\t\tif (is_shadow_present_pte(*spte))\n\t\t\tcontinue;\n\n\t\tif (!FNAME(prefetch_gpte)(vcpu, sp, spte, gptep[i], true))\n\t\t\tbreak;\n\t}\n}\n\n/*\n * Fetch a shadow pte for a specific level in the paging hierarchy.\n * If the guest tries to write a write-protected page, we need to\n * emulate this operation, return 1 to indicate this case.\n */\nstatic int FNAME(fetch)(struct kvm_vcpu *vcpu, gpa_t addr,\n\t\t\t struct guest_walker *gw, u32 error_code,\n\t\t\t int max_level, kvm_pfn_t pfn, bool map_writable,\n\t\t\t bool prefault)\n{\n\tbool nx_huge_page_workaround_enabled = is_nx_huge_page_enabled();\n\tbool write_fault = error_code & PFERR_WRITE_MASK;\n\tbool exec = error_code & PFERR_FETCH_MASK;\n\tbool huge_page_disallowed = exec && nx_huge_page_workaround_enabled;\n\tstruct kvm_mmu_page *sp = NULL;\n\tstruct kvm_shadow_walk_iterator it;\n\tunsigned int direct_access, access;\n\tint top_level, level, req_level, ret;\n\tgfn_t base_gfn = gw->gfn;\n\n\tdirect_access = gw->pte_access;\n\n\ttop_level = vcpu->arch.mmu->root_level;\n\tif (top_level == PT32E_ROOT_LEVEL)\n\t\ttop_level = PT32_ROOT_LEVEL;\n\t/*\n\t * Verify that the top-level gpte is still there.  Since the page\n\t * is a root page, it is either write protected (and cannot be\n\t * changed from now on) or it is invalid (in which case, we don't\n\t * really care if it changes underneath us after this point).\n\t */\n\tif (FNAME(gpte_changed)(vcpu, gw, top_level))\n\t\tgoto out_gpte_changed;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\tgoto out_gpte_changed;\n\n\tfor (shadow_walk_init(&it, vcpu, addr);\n\t     shadow_walk_okay(&it) && it.level > gw->level;\n\t     shadow_walk_next(&it)) {\n\t\tgfn_t table_gfn;\n\n\t\tclear_sp_write_flooding_count(it.sptep);\n\t\tdrop_large_spte(vcpu, it.sptep);\n\n\t\tsp = NULL;\n\t\tif (!is_shadow_present_pte(*it.sptep)) {\n\t\t\ttable_gfn = gw->table_gfn[it.level - 2];\n\t\t\taccess = gw->pt_access[it.level - 2];\n\t\t\tsp = kvm_mmu_get_page(vcpu, table_gfn, addr, it.level-1,\n\t\t\t\t\t      false, access);\n\t\t}\n\n\t\t/*\n\t\t * Verify that the gpte in the page we've just write\n\t\t * protected is still there.\n\t\t */\n\t\tif (FNAME(gpte_changed)(vcpu, gw, it.level - 1))\n\t\t\tgoto out_gpte_changed;\n\n\t\tif (sp)\n\t\t\tlink_shadow_page(vcpu, it.sptep, sp);\n\t}\n\n\tlevel = kvm_mmu_hugepage_adjust(vcpu, gw->gfn, max_level, &pfn,\n\t\t\t\t\thuge_page_disallowed, &req_level);\n\n\ttrace_kvm_mmu_spte_requested(addr, gw->level, pfn);\n\n\tfor (; shadow_walk_okay(&it); shadow_walk_next(&it)) {\n\t\tclear_sp_write_flooding_count(it.sptep);\n\n\t\t/*\n\t\t * We cannot overwrite existing page tables with an NX\n\t\t * large page, as the leaf could be executable.\n\t\t */\n\t\tif (nx_huge_page_workaround_enabled)\n\t\t\tdisallowed_hugepage_adjust(*it.sptep, gw->gfn, it.level,\n\t\t\t\t\t\t   &pfn, &level);\n\n\t\tbase_gfn = gw->gfn & ~(KVM_PAGES_PER_HPAGE(it.level) - 1);\n\t\tif (it.level == level)\n\t\t\tbreak;\n\n\t\tvalidate_direct_spte(vcpu, it.sptep, direct_access);\n\n\t\tdrop_large_spte(vcpu, it.sptep);\n\n\t\tif (!is_shadow_present_pte(*it.sptep)) {\n\t\t\tsp = kvm_mmu_get_page(vcpu, base_gfn, addr,\n\t\t\t\t\t      it.level - 1, true, direct_access);\n\t\t\tlink_shadow_page(vcpu, it.sptep, sp);\n\t\t\tif (huge_page_disallowed && req_level >= it.level)\n\t\t\t\taccount_huge_nx_page(vcpu->kvm, sp);\n\t\t}\n\t}\n\n\tret = mmu_set_spte(vcpu, it.sptep, gw->pte_access, write_fault,\n\t\t\t   it.level, base_gfn, pfn, prefault, map_writable);\n\tif (ret == RET_PF_SPURIOUS)\n\t\treturn ret;\n\n\tFNAME(pte_prefetch)(vcpu, gw, it.sptep);\n\t++vcpu->stat.pf_fixed;\n\treturn ret;\n\nout_gpte_changed:\n\treturn RET_PF_RETRY;\n}\n\n /*\n * To see whether the mapped gfn can write its page table in the current\n * mapping.\n *\n * It is the helper function of FNAME(page_fault). When guest uses large page\n * size to map the writable gfn which is used as current page table, we should\n * force kvm to use small page size to map it because new shadow page will be\n * created when kvm establishes shadow page table that stop kvm using large\n * page size. Do it early can avoid unnecessary #PF and emulation.\n *\n * @write_fault_to_shadow_pgtable will return true if the fault gfn is\n * currently used as its page table.\n *\n * Note: the PDPT page table is not checked for PAE-32 bit guest. It is ok\n * since the PDPT is always shadowed, that means, we can not use large page\n * size to map the gfn which is used as PDPT.\n */\nstatic bool\nFNAME(is_self_change_mapping)(struct kvm_vcpu *vcpu,\n\t\t\t      struct guest_walker *walker, bool user_fault,\n\t\t\t      bool *write_fault_to_shadow_pgtable)\n{\n\tint level;\n\tgfn_t mask = ~(KVM_PAGES_PER_HPAGE(walker->level) - 1);\n\tbool self_changed = false;\n\n\tif (!(walker->pte_access & ACC_WRITE_MASK ||\n\t      (!is_write_protection(vcpu) && !user_fault)))\n\t\treturn false;\n\n\tfor (level = walker->level; level <= walker->max_level; level++) {\n\t\tgfn_t gfn = walker->gfn ^ walker->table_gfn[level - 1];\n\n\t\tself_changed |= !(gfn & mask);\n\t\t*write_fault_to_shadow_pgtable |= !gfn;\n\t}\n\n\treturn self_changed;\n}\n\n/*\n * Page fault handler.  There are several causes for a page fault:\n *   - there is no shadow pte for the guest pte\n *   - write access through a shadow pte marked read only so that we can set\n *     the dirty bit\n *   - write access to a shadow pte marked read only so we can update the page\n *     dirty bitmap, when userspace requests it\n *   - mmio access; in this case we will never install a present shadow pte\n *   - normal guest page fault due to the guest pte marked not present, not\n *     writable, or not executable\n *\n *  Returns: 1 if we need to emulate the instruction, 0 otherwise, or\n *           a negative value on error.\n */\nstatic int FNAME(page_fault)(struct kvm_vcpu *vcpu, gpa_t addr, u32 error_code,\n\t\t\t     bool prefault)\n{\n\tbool write_fault = error_code & PFERR_WRITE_MASK;\n\tbool user_fault = error_code & PFERR_USER_MASK;\n\tstruct guest_walker walker;\n\tint r;\n\tkvm_pfn_t pfn;\n\thva_t hva;\n\tunsigned long mmu_seq;\n\tbool map_writable, is_self_change_mapping;\n\tint max_level;\n\n\tpgprintk(\"%s: addr %lx err %x\\n\", __func__, addr, error_code);\n\n\t/*\n\t * If PFEC.RSVD is set, this is a shadow page fault.\n\t * The bit needs to be cleared before walking guest page tables.\n\t */\n\terror_code &= ~PFERR_RSVD_MASK;\n\n\t/*\n\t * Look up the guest pte for the faulting address.\n\t */\n\tr = FNAME(walk_addr)(&walker, vcpu, addr, error_code);\n\n\t/*\n\t * The page is not mapped by the guest.  Let the guest handle it.\n\t */\n\tif (!r) {\n\t\tpgprintk(\"%s: guest page fault\\n\", __func__);\n\t\tif (!prefault)\n\t\t\tkvm_inject_emulated_page_fault(vcpu, &walker.fault);\n\n\t\treturn RET_PF_RETRY;\n\t}\n\n\tif (page_fault_handle_page_track(vcpu, error_code, walker.gfn)) {\n\t\tshadow_page_table_clear_flood(vcpu, addr);\n\t\treturn RET_PF_EMULATE;\n\t}\n\n\tr = mmu_topup_memory_caches(vcpu, true);\n\tif (r)\n\t\treturn r;\n\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\n\tis_self_change_mapping = FNAME(is_self_change_mapping)(vcpu,\n\t      &walker, user_fault, &vcpu->arch.write_fault_to_shadow_pgtable);\n\n\tif (is_self_change_mapping)\n\t\tmax_level = PG_LEVEL_4K;\n\telse\n\t\tmax_level = walker.level;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, walker.gfn, addr, &pfn, &hva,\n\t\t\t write_fault, &map_writable))\n\t\treturn RET_PF_RETRY;\n\n\tif (handle_abnormal_pfn(vcpu, addr, walker.gfn, pfn, walker.pte_access, &r))\n\t\treturn r;\n\n\t/*\n\t * Do not change pte_access if the pfn is a mmio page, otherwise\n\t * we will cache the incorrect access into mmio spte.\n\t */\n\tif (write_fault && !(walker.pte_access & ACC_WRITE_MASK) &&\n\t     !is_write_protection(vcpu) && !user_fault &&\n\t      !is_noslot_pfn(pfn)) {\n\t\twalker.pte_access |= ACC_WRITE_MASK;\n\t\twalker.pte_access &= ~ACC_USER_MASK;\n\n\t\t/*\n\t\t * If we converted a user page to a kernel page,\n\t\t * so that the kernel can write to it when cr0.wp=0,\n\t\t * then we should prevent the kernel from executing it\n\t\t * if SMEP is enabled.\n\t\t */\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_SMEP))\n\t\t\twalker.pte_access &= ~ACC_EXEC_MASK;\n\t}\n\n\tr = RET_PF_RETRY;\n\twrite_lock(&vcpu->kvm->mmu_lock);\n\tif (!is_noslot_pfn(pfn) && mmu_notifier_retry_hva(vcpu->kvm, mmu_seq, hva))\n\t\tgoto out_unlock;\n\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_PAGE_FAULT);\n\tr = make_mmu_pages_available(vcpu);\n\tif (r)\n\t\tgoto out_unlock;\n\tr = FNAME(fetch)(vcpu, addr, &walker, error_code, max_level, pfn,\n\t\t\t map_writable, prefault);\n\tkvm_mmu_audit(vcpu, AUDIT_POST_PAGE_FAULT);\n\nout_unlock:\n\twrite_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn r;\n}\n\nstatic gpa_t FNAME(get_level1_sp_gpa)(struct kvm_mmu_page *sp)\n{\n\tint offset = 0;\n\n\tWARN_ON(sp->role.level != PG_LEVEL_4K);\n\n\tif (PTTYPE == 32)\n\t\toffset = sp->role.quadrant << PT64_LEVEL_BITS;\n\n\treturn gfn_to_gpa(sp->gfn) + offset * sizeof(pt_element_t);\n}\n\nstatic void FNAME(invlpg)(struct kvm_vcpu *vcpu, gva_t gva, hpa_t root_hpa)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tu64 old_spte;\n\tint level;\n\tu64 *sptep;\n\n\tvcpu_clear_mmio_info(vcpu, gva);\n\n\t/*\n\t * No need to check return value here, rmap_can_add() can\n\t * help us to skip pte prefetch later.\n\t */\n\tmmu_topup_memory_caches(vcpu, true);\n\n\tif (!VALID_PAGE(root_hpa)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\twrite_lock(&vcpu->kvm->mmu_lock);\n\tfor_each_shadow_entry_using_root(vcpu, root_hpa, gva, iterator) {\n\t\tlevel = iterator.level;\n\t\tsptep = iterator.sptep;\n\n\t\tsp = sptep_to_sp(sptep);\n\t\told_spte = *sptep;\n\t\tif (is_last_spte(old_spte, level)) {\n\t\t\tpt_element_t gpte;\n\t\t\tgpa_t pte_gpa;\n\n\t\t\tif (!sp->unsync)\n\t\t\t\tbreak;\n\n\t\t\tpte_gpa = FNAME(get_level1_sp_gpa)(sp);\n\t\t\tpte_gpa += (sptep - sp->spt) * sizeof(pt_element_t);\n\n\t\t\tmmu_page_zap_pte(vcpu->kvm, sp, sptep, NULL);\n\t\t\tif (is_shadow_present_pte(old_spte))\n\t\t\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm,\n\t\t\t\t\tsp->gfn, KVM_PAGES_PER_HPAGE(sp->role.level));\n\n\t\t\tif (!rmap_can_add(vcpu))\n\t\t\t\tbreak;\n\n\t\t\tif (kvm_vcpu_read_guest_atomic(vcpu, pte_gpa, &gpte,\n\t\t\t\t\t\t       sizeof(pt_element_t)))\n\t\t\t\tbreak;\n\n\t\t\tFNAME(update_pte)(vcpu, sp, sptep, &gpte);\n\t\t}\n\n\t\tif (!is_shadow_present_pte(*sptep) || !sp->unsync_children)\n\t\t\tbreak;\n\t}\n\twrite_unlock(&vcpu->kvm->mmu_lock);\n}\n\n/* Note, @addr is a GPA when gva_to_gpa() translates an L2 GPA to an L1 GPA. */\nstatic gpa_t FNAME(gva_to_gpa)(struct kvm_vcpu *vcpu, gpa_t addr, u32 access,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = UNMAPPED_GVA;\n\tint r;\n\n\tr = FNAME(walk_addr)(&walker, vcpu, addr, access);\n\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= addr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\n\treturn gpa;\n}\n\n#if PTTYPE != PTTYPE_EPT\n/* Note, gva_to_gpa_nested() is only used to translate L2 GVAs. */\nstatic gpa_t FNAME(gva_to_gpa_nested)(struct kvm_vcpu *vcpu, gpa_t vaddr,\n\t\t\t\t      u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = UNMAPPED_GVA;\n\tint r;\n\n#ifndef CONFIG_X86_64\n\t/* A 64-bit GVA should be impossible on 32-bit KVM. */\n\tWARN_ON_ONCE(vaddr >> 32);\n#endif\n\n\tr = FNAME(walk_addr_nested)(&walker, vcpu, vaddr, access);\n\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= vaddr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\n\treturn gpa;\n}\n#endif\n\n/*\n * Using the cached information from sp->gfns is safe because:\n * - The spte has a reference to the struct page, so the pfn for a given gfn\n *   can't change unless all sptes pointing to it are nuked first.\n *\n * Note:\n *   We should flush all tlbs if spte is dropped even though guest is\n *   responsible for it. Since if we don't, kvm_mmu_notifier_invalidate_page\n *   and kvm_mmu_notifier_invalidate_range_start detect the mapping page isn't\n *   used by guest then tlbs are not flushed, so guest is allowed to access the\n *   freed pages.\n *   And we increase kvm->tlbs_dirty to delay tlbs flush in this case.\n */\nstatic int FNAME(sync_page)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)\n{\n\tint i, nr_present = 0;\n\tbool host_writable;\n\tgpa_t first_pte_gpa;\n\tint set_spte_ret = 0;\n\n\t/* direct kvm_mmu_page can not be unsync. */\n\tBUG_ON(sp->role.direct);\n\n\tfirst_pte_gpa = FNAME(get_level1_sp_gpa)(sp);\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; i++) {\n\t\tunsigned pte_access;\n\t\tpt_element_t gpte;\n\t\tgpa_t pte_gpa;\n\t\tgfn_t gfn;\n\n\t\tif (!sp->spt[i])\n\t\t\tcontinue;\n\n\t\tpte_gpa = first_pte_gpa + i * sizeof(pt_element_t);\n\n\t\tif (kvm_vcpu_read_guest_atomic(vcpu, pte_gpa, &gpte,\n\t\t\t\t\t       sizeof(pt_element_t)))\n\t\t\treturn 0;\n\n\t\tif (FNAME(prefetch_invalid_gpte)(vcpu, sp, &sp->spt[i], gpte)) {\n\t\t\t/*\n\t\t\t * Update spte before increasing tlbs_dirty to make\n\t\t\t * sure no tlb flush is lost after spte is zapped; see\n\t\t\t * the comments in kvm_flush_remote_tlbs().\n\t\t\t */\n\t\t\tsmp_wmb();\n\t\t\tvcpu->kvm->tlbs_dirty++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tgfn = gpte_to_gfn(gpte);\n\t\tpte_access = sp->role.access;\n\t\tpte_access &= FNAME(gpte_access)(gpte);\n\t\tFNAME(protect_clean_gpte)(vcpu->arch.mmu, &pte_access, gpte);\n\n\t\tif (sync_mmio_spte(vcpu, &sp->spt[i], gfn, pte_access,\n\t\t      &nr_present))\n\t\t\tcontinue;\n\n\t\tif (gfn != sp->gfns[i]) {\n\t\t\tdrop_spte(vcpu->kvm, &sp->spt[i]);\n\t\t\t/*\n\t\t\t * The same as above where we are doing\n\t\t\t * prefetch_invalid_gpte().\n\t\t\t */\n\t\t\tsmp_wmb();\n\t\t\tvcpu->kvm->tlbs_dirty++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnr_present++;\n\n\t\thost_writable = sp->spt[i] & shadow_host_writable_mask;\n\n\t\tset_spte_ret |= set_spte(vcpu, &sp->spt[i],\n\t\t\t\t\t pte_access, PG_LEVEL_4K,\n\t\t\t\t\t gfn, spte_to_pfn(sp->spt[i]),\n\t\t\t\t\t true, false, host_writable);\n\t}\n\n\tif (set_spte_ret & SET_SPTE_NEED_REMOTE_TLB_FLUSH)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\n\treturn nr_present;\n}\n\n#undef pt_element_t\n#undef guest_walker\n#undef FNAME\n#undef PT_BASE_ADDR_MASK\n#undef PT_INDEX\n#undef PT_LVL_ADDR_MASK\n#undef PT_LVL_OFFSET_MASK\n#undef PT_LEVEL_BITS\n#undef PT_MAX_FULL_LEVELS\n#undef gpte_to_gfn\n#undef gpte_to_gfn_lvl\n#undef CMPXCHG\n#undef PT_GUEST_ACCESSED_MASK\n#undef PT_GUEST_DIRTY_MASK\n#undef PT_GUEST_DIRTY_SHIFT\n#undef PT_GUEST_ACCESSED_SHIFT\n#undef PT_HAVE_ACCESSED_DIRTY\n"], "filenames": ["Documentation/virt/kvm/mmu.rst", "arch/x86/kvm/mmu/paging_tmpl.h"], "buggy_code_start_loc": [174, 93], "buggy_code_end_loc": [176, 677], "fixing_code_start_loc": [174, 93], "fixing_code_end_loc": [176, 682], "type": "NVD-CWE-noinfo", "message": "arch/x86/kvm/mmu/paging_tmpl.h in the Linux kernel before 5.12.11 incorrectly computes the access permissions of a shadow page, leading to a missing guest protection page fault.", "other": {"cve": {"id": "CVE-2021-38198", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-08T20:15:07.027", "lastModified": "2022-01-04T16:38:41.460", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "arch/x86/kvm/mmu/paging_tmpl.h in the Linux kernel before 5.12.11 incorrectly computes the access permissions of a shadow page, leading to a missing guest protection page fault."}, {"lang": "es", "value": "El archivo arch/x86/kvm/mmu/paging_tmpl.h en el kernel de Linux versiones anteriores a 5.12.11, computa incorrectamente los permisos de acceso de una p\u00e1gina sombra, conllevando a un fallo de p\u00e1gina de protecci\u00f3n de invitados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.12.11", "matchCriteriaId": "FB3C9604-BFC9-4C0B-BA5C-974549F97FF6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.12.11", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b1bd5cba3306691c771d558e94baa73e8b0b96b7", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/10/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/12/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b1bd5cba3306691c771d558e94baa73e8b0b96b7"}}