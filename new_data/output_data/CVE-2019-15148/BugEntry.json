{"buggy_code": ["/*! @file GPMF_parser.c\n * \n *  @brief GPMF Parser library\n *\n *  @version 1.2.1\n * \n *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n *\t\n *  Licensed under either:\n *  - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0  \n *  - MIT license, http://opensource.org/licenses/MIT\n *  at your option.\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n * \n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n#include \"GPMF_parser.h\"\n\n\n#ifdef DBG\n#if _WINDOWS\n#define DBG_MSG printf\n#else\n#define DBG_MSG(...)\n#endif\n#else\n#define DBG_MSG(...)\n#endif\n\n\nGPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not bytes.\n{\n\tif (ms)\n\t{\n\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n\t\tif (nestsize == 0 && ms->nest_level == 0)\n\t\t\tnestsize = ms->buffer_size_longs;\n\n\t\tif (size + 2 <= nestsize) return GPMF_OK;\n\t}\n\treturn GPMF_ERROR_BAD_STRUCTURE;\n}\n\n\nGPMF_ERR GPMF_Validate(GPMF_stream *ms, GPMF_LEVELS recurse)\n{\n\tif (ms)\n\t{\n\t\tuint32_t currpos = ms->pos;\n\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n\t\tif (nestsize == 0 && ms->nest_level == 0)\n\t\t\tnestsize = ms->buffer_size_longs;\n\t\t\n\t\twhile (ms->pos+1 < ms->buffer_size_longs && nestsize > 0)\n\t\t{\n\t\t\tuint32_t key = ms->buffer[ms->pos];\n\n\t\t\tif (ms->nest_level == 0 && key != GPMF_KEY_DEVICE && ms->device_count == 0 && ms->pos == 0)\n\t\t\t{\n\t\t\t\tDBG_MSG(\"ERROR: uninitized -- GPMF_ERROR_BAD_STRUCTURE\\n\");\n\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t}\n\n\t\t\tif (GPMF_VALID_FOURCC(key))\n\t\t\t{\n\t\t\t\tuint32_t type_size_repeat = ms->buffer[ms->pos + 1];\n\t\t\t\tint32_t size = GPMF_DATA_SIZE(type_size_repeat) >> 2;\n\t\t\t\tuint8_t type = GPMF_SAMPLE_TYPE(type_size_repeat);\n\t\t\t\tif (size + 2 > nestsize)\n\t\t\t\t{\n\t\t\t\t\tDBG_MSG(\"ERROR: nest size too small within %c%c%c%c-- GPMF_ERROR_BAD_STRUCTURE\\n\", PRINTF_4CC(key));\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t}\n\n\t\t\t\tif (!GPMF_VALID_FOURCC(key))\n\t\t\t\t{\n\t\t\t\t\tDBG_MSG(\"ERROR: invalid 4CC -- GPMF_ERROR_BAD_STRUCTURE\\n\");\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t}\n\n\t\t\t\tif (type == GPMF_TYPE_NEST && recurse == GPMF_RECURSE_LEVELS)\n\t\t\t\t{\n\t\t\t\t\tuint32_t validnest;\n\t\t\t\t\tms->pos += 2;\n\t\t\t\t\tms->nest_level++;\n\t\t\t\t\tif (ms->nest_level > GPMF_NEST_LIMIT)\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_MSG(\"ERROR: nest level within %c%c%c%c too deep -- GPMF_ERROR_BAD_STRUCTURE\\n\", PRINTF_4CC(key));\n\t\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t\t}\n\t\t\t\t\tms->nest_size[ms->nest_level] = size;\n\t\t\t\t\tvalidnest = GPMF_Validate(ms, recurse);\n\t\t\t\t\tms->nest_level--;\n\t\t\t\t\tif (GPMF_OK != validnest)\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_MSG(\"ERROR: invalid nest within %c%c%c%c -- GPMF_ERROR_BAD_STRUCTURE\\n\", PRINTF_4CC(key));\n\t\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ms->nest_level == 0)\n\t\t\t\t\t\t\tms->device_count++;\n\t\t\t\t\t}\n\n\t\t\t\t\tms->pos += size;\n\t\t\t\t\tnestsize -= 2 + size;\n\n\t\t\t\t\twhile (ms->pos < ms->buffer_size_longs && nestsize > 0 && ms->buffer[ms->pos] == GPMF_KEY_END)\n\t\t\t\t\t{\n\t\t\t\t\t\tms->pos++;\n\t\t\t\t\t\tnestsize--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tms->pos += 2 + size;\n\t\t\t\t\tnestsize -= 2 + size;\n\t\t\t\t}\n\n\t\t\t\tif (ms->pos == ms->buffer_size_longs)\n\t\t\t\t{\n\t\t\t\t\tms->pos = currpos;\n\t\t\t\t\treturn GPMF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (key == GPMF_KEY_END)\n\t\t\t\t{\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tms->pos++;\n\t\t\t\t\t\tnestsize--;\n\t\t\t\t\t} while (ms->pos < ms->buffer_size_longs && nestsize > 0 && ms->buffer[ms->pos] == 0);\n\t\t\t\t}\n\t\t\t\telse if (ms->nest_level == 0 && ms->device_count > 0)\n\t\t\t\t{\n\t\t\t\t\tms->pos = currpos;\n\t\t\t\t\treturn GPMF_OK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDBG_MSG(\"ERROR: bad struct within %c%c%c%c -- GPMF_ERROR_BAD_STRUCTURE\\n\", PRINTF_4CC(key));\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tms->pos = currpos;\n\t\treturn GPMF_OK;\n\t}\n\telse\n\t{\n\t\tDBG_MSG(\"ERROR: Invalid handle -- GPMF_ERROR_MEMORY\\n\");\n\t\treturn GPMF_ERROR_MEMORY;\n\t}\n}\n\n\nGPMF_ERR GPMF_ResetState(GPMF_stream *ms)\n{\n\tif (ms)\n\t{\n\t\tms->pos = 0;\n\t\tms->nest_level = 0;\n\t\tms->device_count = 0;\n\t\tms->nest_size[ms->nest_level] = 0;\n\t\tms->last_level_pos[ms->nest_level] = 0;\n\t\tms->last_seek[ms->nest_level] = 0;\n\t\tms->device_id = 0;\n\t\tms->device_name[0] = 0;\n\n\t\treturn GPMF_OK;\n\t}\n\t\n\treturn GPMF_ERROR_MEMORY;\n}\n\n\nGPMF_ERR GPMF_Init(GPMF_stream *ms, uint32_t *buffer, int datasize)\n{\n\tif(ms)\n\t{\n\t\tms->buffer = buffer;\n\t\tms->buffer_size_longs = datasize >>2;\n\n\t\tGPMF_ResetState(ms);\n\n\t\treturn GPMF_OK;\n\t}\n\t\n\treturn GPMF_ERROR_MEMORY;\n}\n\n\nGPMF_ERR GPMF_CopyState(GPMF_stream *msrc, GPMF_stream *mdst)\n{\n\tif (msrc && mdst)\n\t{\n\t\tmemcpy(mdst, msrc, sizeof(GPMF_stream));\n\t\treturn GPMF_OK;\n\t}\n\treturn GPMF_ERROR_MEMORY;\n}\n\n\nGPMF_ERR GPMF_Next(GPMF_stream *ms, GPMF_LEVELS recurse)\n{\n\tif (ms)\n\t{\n\t\tif (ms->pos+1 < ms->buffer_size_longs)\n\t\t{\n\n\t\t\tuint32_t key, type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\t\t\tuint32_t size = (GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]) >> 2);\n\n\t\t\tif (GPMF_OK != IsValidSize(ms, size)) return GPMF_ERROR_BAD_STRUCTURE;\n\n\t\t\tif (GPMF_TYPE_NEST == type && GPMF_KEY_DEVICE == ms->buffer[ms->pos] && ms->nest_level == 0)\n\t\t\t{\n\t\t\t\tms->last_level_pos[ms->nest_level] = ms->pos;\n\t\t\t\tms->nest_size[ms->nest_level] = size;\n\t\t\t\tif (recurse)\n\t\t\t\t\tms->pos += 2;\n\t\t\t\telse\n\t\t\t\t\tms->pos += 2 + size;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (size + 2 > ms->nest_size[ms->nest_level])\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\n\t\t\t\tif (recurse && type == GPMF_TYPE_NEST)\n\t\t\t\t{\n\t\t\t\t\tms->last_level_pos[ms->nest_level] = ms->pos;\n\t\t\t\t\tms->pos += 2;\n\t\t\t\t\tms->nest_size[ms->nest_level] -= size + 2;\n\n\t\t\t\t\tms->nest_level++;\n\t\t\t\t\tif (ms->nest_level > GPMF_NEST_LIMIT)\n\t\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\n\t\t\t\t\tms->nest_size[ms->nest_level] = size;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (recurse)\n\t\t\t\t\t{\n\t\t\t\t\t\tms->pos += size + 2;\n\t\t\t\t\t\tms->nest_size[ms->nest_level] -= size + 2;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ms->nest_size[ms->nest_level] - (size + 2) > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tms->pos += size + 2;\n\t\t\t\t\t\t\tms->nest_size[ms->nest_level] -= size + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn GPMF_ERROR_LAST;   \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n\n\t\t\twhile (ms->pos < ms->buffer_size_longs && ms->nest_size[ms->nest_level] > 0 && ms->buffer[ms->pos] == GPMF_KEY_END)\n\t\t\t{\n\t\t\t\tms->pos++;\n\t\t\t\tms->nest_size[ms->nest_level]--;\n\t\t\t}\n\n\t\t\twhile (ms->nest_level > 0 && ms->nest_size[ms->nest_level] == 0)\n\t\t\t{\n\t\t\t\tms->nest_level--;\n\t\t\t\t//if (ms->nest_level == 0)\n\t\t\t\t//{\n\t\t\t\t//\tms->device_count++;\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (ms->pos < ms->buffer_size_longs)\n\t\t\t{\n\t\t\t\twhile (ms->pos < ms->buffer_size_longs && ms->nest_size[ms->nest_level] > 0 && ms->buffer[ms->pos] == GPMF_KEY_END)\n\t\t\t\t{\n\t\t\t\t\tms->pos++;\n\t\t\t\t\tms->nest_size[ms->nest_level]--;\n\t\t\t\t}\n\n\t\t\t\tkey = ms->buffer[ms->pos];\n\t\t\t\tif (!GPMF_VALID_FOURCC(key))\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\n\t\t\t\tif (key == GPMF_KEY_DEVICE_ID)\n\t\t\t\t\tms->device_id = BYTESWAP32(ms->buffer[ms->pos + 2]);\n\t\t\t\tif (key == GPMF_KEY_DEVICE_NAME)\n\t\t\t\t{\n\t\t\t\t\tsize = GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]); // in bytes\n\t\t\t\t\tif (size > sizeof(ms->device_name) - 1)\n\t\t\t\t\t\tsize = sizeof(ms->device_name) - 1;\n\t\t\t\t\tmemcpy(ms->device_name, &ms->buffer[ms->pos + 2], size);\n\t\t\t\t\tms->device_name[size] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// end of buffer\n\t\t\t\treturn GPMF_ERROR_BUFFER_END;\n\t\t\t}\n\n\t\t\treturn GPMF_OK;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// end of buffer\n\t\t\treturn GPMF_ERROR_BUFFER_END;\n\t\t}\n\t}\n\treturn GPMF_ERROR_MEMORY;\n}\n\n\n\nGPMF_ERR GPMF_FindNext(GPMF_stream *ms, uint32_t fourcc, GPMF_LEVELS recurse)\n{\n\tGPMF_stream prevstate;\n\n\tif (ms)\n\t{\n\t\tmemcpy(&prevstate, ms, sizeof(GPMF_stream));\n\n\t\tif (ms->pos < ms->buffer_size_longs)\n\t\t{\n\t\t\twhile (0 == GPMF_Next(ms, recurse))\n\t\t\t{\n\t\t\t\tif (ms->buffer[ms->pos] == fourcc)\n\t\t\t\t{\n\t\t\t\t\treturn GPMF_OK; //found match\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// restore read position\n\t\t\tmemcpy(ms, &prevstate, sizeof(GPMF_stream));\n\t\t\treturn GPMF_ERROR_FIND;\n\t\t}\n\t}\n\treturn GPMF_ERROR_FIND;\n}\n\nGPMF_ERR GPMF_Reserved(uint32_t key)\n{\n\tif(key == GPMF_KEY_DEVICE)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_DEVICE_ID)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_DEVICE_NAME)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_STREAM)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_STREAM_NAME)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_SI_UNITS)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_UNITS)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_SCALE)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_TYPE)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_TOTAL_SAMPLES)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_TICK)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_TOCK)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_EMPTY_PAYLOADS)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_REMARK)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\treturn GPMF_OK;\n}\n\nuint32_t GPMF_PayloadSampleCount(GPMF_stream *ms)\n{\n\tuint32_t count = 0;\n\tif (ms)\n\t{\n\t\tuint32_t fourcc = GPMF_Key(ms);\n\n\t\tGPMF_stream find_stream;\n\t\tGPMF_CopyState(ms, &find_stream);\n\n\t\tif (GPMF_OK == GPMF_FindNext(&find_stream, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats\n\t\t{\n\t\t\tcount=2;\n\t\t\twhile (GPMF_OK == GPMF_FindNext(&find_stream, fourcc, GPMF_CURRENT_LEVEL))\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t} \n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount = GPMF_Repeat(ms);\n\t\t}\n\t}\n\treturn count;\n}\n\n\nGPMF_ERR GPMF_SeekToSamples(GPMF_stream *ms)\n{\n\tGPMF_stream prevstate;\n\n\tif (ms)\n\t{\n\n\t\tif (ms->pos+1 < ms->buffer_size_longs)\n\t\t{\n\t\t\tuint32_t type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\n\t\t\tmemcpy(&prevstate, ms, sizeof(GPMF_stream));\n\n\t\t\tif (type == GPMF_TYPE_NEST)\n\t\t\t\tGPMF_Next(ms, GPMF_RECURSE_LEVELS); // open STRM and recurse in\n\n\t\t\twhile (0 == GPMF_Next(ms, GPMF_CURRENT_LEVEL))\n\t\t\t{\n\t\t\t\tuint32_t size = (GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]) >> 2);\n\t\t\t\tif (GPMF_OK != IsValidSize(ms, size))\n\t\t\t\t{\n\t\t\t\t\tmemcpy(ms, &prevstate, sizeof(GPMF_stream));\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t}\n\n\t\t\t\ttype = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\n\n\t\t\t\tif (type == GPMF_TYPE_NEST)  // Nest with-in nest\n\t\t\t\t{\n\t\t\t\t\treturn GPMF_OK; //found match\n\t\t\t\t}\n\n\t\t\t\tif (size + 2 == ms->nest_size[ms->nest_level])\n\t\t\t\t{\n\t\t\t\t\tuint32_t key = GPMF_Key(ms);\n\n\t\t\t\t\tif (GPMF_ERROR_RESERVED == GPMF_Reserved(key))\n\t\t\t\t\t\treturn GPMF_ERROR_FIND;\n\t\t\t\t\t\n\t\t\t\t\treturn GPMF_OK; //found match\n\t\t\t\t}\n\n\t\t\t\tif (ms->buffer[ms->pos] == ms->buffer[ms->pos + size + 2]) // Matching tags\n\t\t\t\t{\n\t\t\t\t\treturn GPMF_OK; //found match\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// restore read position\n\t\t\tmemcpy(ms, &prevstate, sizeof(GPMF_stream));\n\t\t\treturn GPMF_ERROR_FIND;\n\t\t}\n\t}\n\treturn GPMF_ERROR_FIND;\n}\n\n\nGPMF_ERR GPMF_FindPrev(GPMF_stream *ms, uint32_t fourcc, GPMF_LEVELS recurse)\n{\n\tGPMF_stream prevstate;\n\n\tif (ms)\n\t{\n\t\tuint32_t curr_level = ms->nest_level;\n\n\t\tmemcpy(&prevstate, ms, sizeof(GPMF_stream));\n\n\t\tif (ms->pos < ms->buffer_size_longs && curr_level > 0)\n\t\t{\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tms->last_seek[curr_level] = ms->pos;\n\t\t\t\tms->pos = ms->last_level_pos[curr_level - 1] + 2;\n\t\t\t\tms->nest_size[curr_level] += ms->last_seek[curr_level] - ms->pos;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tif (ms->last_seek[curr_level] > ms->pos && ms->buffer[ms->pos] == fourcc)\n\t\t\t\t\t{\n\n\t\t\t\t\t\treturn GPMF_OK; //found match\n\t\t\t\t\t}\n\t\t\t\t} while (ms->last_seek[curr_level] > ms->pos && 0 == GPMF_Next(ms, GPMF_CURRENT_LEVEL));\n\n\t\t\t\tcurr_level--;\n\t\t\t} while (recurse == GPMF_RECURSE_LEVELS && curr_level > 0);\n\n\t\t\t// restore read position\n\t\t\tmemcpy(ms, &prevstate, sizeof(GPMF_stream));\n\n\t\t\treturn GPMF_ERROR_FIND;\n\t\t}\n\t}\n\n\treturn GPMF_ERROR_FIND;\n}\n\n\n\n\n\nuint32_t GPMF_Key(GPMF_stream *ms)\n{\n\tif (ms)\n\t{\n\t\tuint32_t key = ms->buffer[ms->pos];\n\t\treturn key;\n\t}\n\treturn 0;\n}\n\n\nuint32_t GPMF_Type(GPMF_stream *ms)\n{\n\tif (ms && ms->pos+1 < ms->buffer_size_longs)\n\t{\n\t\tuint32_t type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos+1]);\n\t\treturn type;\n\t}\n\treturn 0;\n}\n\n\nuint32_t GPMF_StructSize(GPMF_stream *ms)\n{\n\tif (ms && ms->pos+1 < ms->buffer_size_longs)\n\t{\n\t\tuint32_t ssize = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1]);\n\t\tuint32_t size = (GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]) >> 2);\n\n\t\tif (GPMF_OK != IsValidSize(ms, size)) return 0; // as the structure is corrupted. i.e. GPMF_ERROR_BAD_STRUCTURE;\n\n\t\treturn ssize;\n\t}\n\treturn 0;\n}\n\n\nuint32_t GPMF_ElementsInStruct(GPMF_stream *ms)\n{\n\tif (ms && ms->pos+1 < ms->buffer_size_longs)\n\t{\n\t\tuint32_t ssize = GPMF_StructSize(ms);\n\t\tGPMF_SampleType type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\n\t\tif (type != GPMF_TYPE_NEST && type != GPMF_TYPE_COMPLEX)\n\t\t{\n\t\t\tint32_t tsize = GPMF_SizeofType(type);\n\t\t\tif (tsize > 0)\n\t\t\t\treturn ssize / tsize;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif (type == GPMF_TYPE_COMPLEX)\n\t\t{\n\t\t\tGPMF_stream find_stream;\n\t\t\tGPMF_CopyState(ms, &find_stream);\n\n\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_CURRENT_LEVEL))\n\t\t\t{\n\t\t\t\tchar tmp[64] = \"\";\n\t\t\t\tuint32_t tmpsize = sizeof(tmp);\n\t\t\t\tchar *data = (char *)GPMF_RawData(&find_stream);\n\t\t\t\tint size = GPMF_RawDataSize(&find_stream);\n\t\t\t\t\n\t\t\t\tif (GPMF_OK == GPMF_ExpandComplexTYPE(data, size, tmp, &tmpsize))\n\t\t\t\t\treturn tmpsize;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nuint32_t GPMF_Repeat(GPMF_stream *ms)\n{\n\tif (ms && ms->pos+1 < ms->buffer_size_longs)\n\t{\n\t\tuint32_t repeat = GPMF_SAMPLES(ms->buffer[ms->pos + 1]);\n\t\treturn repeat;\n\t}\n\treturn 0;\n}\n\nuint32_t GPMF_RawDataSize(GPMF_stream *ms)\n{\n\tif (ms && ms->pos+1 < ms->buffer_size_longs)\n\t{\n\t\tuint32_t size = GPMF_DATA_PACKEDSIZE(ms->buffer[ms->pos + 1]);\n\t\tif (GPMF_OK != IsValidSize(ms, size >> 2)) return 0;\n\n\t\treturn size;\n\t}\n\treturn 0;\n}\n\n\nuint32_t GPMF_NestLevel(GPMF_stream *ms)\n{\n\tif (ms)\n\t{\n\t\treturn ms->nest_level;\n\t}\n\treturn 0;\n}\n\nuint32_t GPMF_DeviceID(GPMF_stream *ms)\n{\n\tif (ms)\n\t{\n\t\treturn ms->device_id;\n\t}\n\treturn 0;\n}\n\nGPMF_ERR GPMF_DeviceName(GPMF_stream *ms, char *devicenamebuf, uint32_t devicename_buf_size)\n{\n\tif (ms && devicenamebuf)\n\t{\n\t\tuint32_t len = (uint32_t)strlen(ms->device_name);\n\t\tif (len >= devicename_buf_size)\n\t\t\treturn GPMF_ERROR_MEMORY;\n\n\t\tmemcpy(devicenamebuf, ms->device_name, len);\n\t\tdevicenamebuf[len] = 0;\n\t\treturn GPMF_OK;\n\t}\n\treturn GPMF_ERROR_MEMORY;\n}\n\n\nvoid *GPMF_RawData(GPMF_stream *ms)\n{\n\tif (ms)\n\t{\n\t\treturn (void *)&ms->buffer[ms->pos + 2];\n\t}\n\treturn NULL;\n}\n\n\n\n\nuint32_t GPMF_SizeofType(GPMF_SampleType type)\n{\n\tuint32_t ssize = 0;\n\n\tswitch ((int)type)\n\t{\n\tcase GPMF_TYPE_STRING_ASCII:\t\tssize = 1; break;\n\tcase GPMF_TYPE_SIGNED_BYTE:\t\t\tssize = 1; break;\n\tcase GPMF_TYPE_UNSIGNED_BYTE:\t\tssize = 1; break;\n\n\t// These datatypes are always be stored in Big-Endian\n\tcase GPMF_TYPE_SIGNED_SHORT:\t\tssize = 2; break;\n\tcase GPMF_TYPE_UNSIGNED_SHORT:\t\tssize = 2; break;\n\tcase GPMF_TYPE_FLOAT:\t\t\t\tssize = 4; break;\n\tcase GPMF_TYPE_FOURCC:\t\t\t\tssize = 4; break;\n\tcase GPMF_TYPE_SIGNED_LONG:\t\t\tssize = 4; break;\n\tcase GPMF_TYPE_UNSIGNED_LONG:\t\tssize = 4; break;\n\tcase GPMF_TYPE_Q15_16_FIXED_POINT:  ssize = 4; break;\n\tcase GPMF_TYPE_Q31_32_FIXED_POINT:  ssize = 8; break;\n\tcase GPMF_TYPE_DOUBLE:\t\t\t\tssize = 8; break;\n\tcase GPMF_TYPE_SIGNED_64BIT_INT:\tssize = 8; break;\n\tcase GPMF_TYPE_UNSIGNED_64BIT_INT:  ssize = 8; break;\n\n\t//All unknown or larger than 8-bytes stored as is:\n\tcase GPMF_TYPE_GUID:\t\t\t\tssize = 16; break;\n\tcase GPMF_TYPE_UTC_DATE_TIME:\t\tssize = 16; break;\n\t}\n\n\treturn ssize;\n}\n\nuint32_t GPMF_ExpandComplexTYPE(char *src, uint32_t srcsize, char *dst, uint32_t *dstsize)\n{\n\tuint32_t i = 0, k = 0, count = 0;\n\n\twhile (i<srcsize && k<*dstsize)\n\t{\n\t\tif (src[i] == '[' && i>0)\n\t\t{\n\t\t\tint j = 1;\n\t\t\tcount = 0;\n\t\t\twhile (src[i + j] >= '0' && src[i + j] <= '9')\n\t\t\t{\n\t\t\t\tcount *= 10;\n\t\t\t\tcount += src[i + j] - '0';\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tif (count > 1)\n\t\t\t{\n\t\t\t\tuint32_t l;\n\t\t\t\tfor (l = 1; l<count; l++)\n\t\t\t\t{\n\t\t\t\t\tdst[k] = src[i - 1];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += j;\n\t\t\tif (src[i] == ']') i++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdst[k] = src[i];\n\t\t\tif (dst[k] == 0) break;\n\t\t\ti++, k++;\n\t\t}\n\t}\n\n\tif (k >= *dstsize)\n\t\treturn GPMF_ERROR_MEMORY; // bad structure formed\n\n\tdst[k] = 0;\n\t*dstsize = k;\n\n\treturn GPMF_OK;\n}\n\n\n\nuint32_t GPMF_SizeOfComplexTYPE(char *type, uint32_t typestringlength)\n{\n\tchar *typearray = type;\n\tuint32_t size = 0, expand = 0;\n\tuint32_t i, len = typestringlength;\n\n\n\tfor (i = 0; i < len; i++)\n\t\tif (typearray[i] == '[')\n\t\t\texpand = 1;\n\t\t\t\n\tif (expand)\n\t{\n\t\tchar exptypearray[64];\n\t\tuint32_t dstsize = sizeof(exptypearray);\n\n\t\tif (GPMF_OK == GPMF_ExpandComplexTYPE(typearray, len, exptypearray, &dstsize))\n\t\t{\n\t\t\ttypearray = exptypearray;\n\t\t\tlen = dstsize;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tuint32_t typesize = GPMF_SizeofType((GPMF_SampleType)typearray[i]);\n\n\t\tif (typesize < 1) return 0;\n\t\tsize += typesize;\n\t}\n\n\treturn size;\n}\n\n\nGPMF_ERR GPMF_FormattedData(GPMF_stream *ms, void *buffer, uint32_t buffersize, uint32_t sample_offset, uint32_t read_samples)\n{\n\tif (ms && buffer)\n\t{\n\t\tuint8_t *data = (uint8_t *)&ms->buffer[ms->pos + 2];\n\t\tuint8_t *output = (uint8_t *)buffer;\n\t\tuint32_t sample_size = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1]);\n\t\tuint32_t remaining_sample_size = GPMF_DATA_PACKEDSIZE(ms->buffer[ms->pos + 1]);\n\t\tuint8_t type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\t\tuint32_t typesize = 1;\n\t\tuint32_t elements = 0;\n\t\tuint32_t typestringlength = 1;\n\t\tchar complextype[64] = \"L\";\n\n\t\tif (type == GPMF_TYPE_NEST)\n\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\n\t\tif (GPMF_OK != IsValidSize(ms, remaining_sample_size>>2))\n\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\n\t\tif (sample_size * read_samples > buffersize)\n\t\t\treturn GPMF_ERROR_MEMORY;\n\n\t\tremaining_sample_size -= sample_offset * sample_size; // skip samples\n\t\tdata += sample_offset * sample_size;\n\n\t\tif (remaining_sample_size < sample_size * read_samples)\n\t\t\treturn GPMF_ERROR_MEMORY;\n\n\t\tif (type == GPMF_TYPE_COMPLEX)\n\t\t{\n\t\t\tGPMF_stream find_stream;\n\t\t\tGPMF_CopyState(ms, &find_stream);\n\n\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_RECURSE_LEVELS))\n\t\t\t{\n\t\t\t\tchar *data1 = (char *)GPMF_RawData(&find_stream);\n\t\t\t\tint size = GPMF_RawDataSize(&find_stream);\n\n\t\t\t\ttypestringlength = sizeof(complextype);\n\t\t\t\tif (GPMF_OK == GPMF_ExpandComplexTYPE(data1, size, complextype, &typestringlength))\n\t\t\t\t{\n\t\t\t\t\telements = (uint32_t)strlen(complextype);\n\n\t\t\t\t\tif (sample_size != GPMF_SizeOfComplexTYPE(complextype, typestringlength))\n\t\t\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypesize = GPMF_SizeofType((GPMF_SampleType)type);\n\n\t\t\tif (type == GPMF_TYPE_FOURCC)\n\t\t\t\ttypesize = 1; // Do not ByteSWAP\n\n\t\t\tif (typesize == 0)\n\t\t\t\treturn GPMF_ERROR_MEMORY;\n\n\t\t\telements = sample_size / typesize;\n\t\t}\n\n\t\twhile (read_samples--)\n\t\t{\n\t\t\tuint32_t i,j;\n\n\t\t\tfor (i = 0; i < elements; i++)\n\t\t\t{\n\t\t\t\tif (type == GPMF_TYPE_COMPLEX)\n\t\t\t\t{\n\t\t\t\t\tif (complextype[i] == GPMF_TYPE_FOURCC)\n\t\t\t\t\t{\n\t\t\t\t\t\t*output++ = *data++;\n\t\t\t\t\t\t*output++ = *data++;\n\t\t\t\t\t\t*output++ = *data++;\n\t\t\t\t\t\t*output++ = *data++;\n\t\t\t\t\t\ttypesize = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\ttypesize = GPMF_SizeofType(complextype[i]);\n\t\t\t\t}\n\n\t\t\t\tswitch (typesize)\n\t\t\t\t{\n\t\t\t\tcase 2:\n\t\t\t\t{\n\t\t\t\t\tuint16_t *data16 = (uint16_t *)data;\n\t\t\t\t\tuint16_t *output16 = (uint16_t *)output;\n\t\t\t\t\t*output16 = BYTESWAP16(*data16);\n\t\t\t\t\toutput16++;\n\t\t\t\t\tdata16++;\n\n\t\t\t\t\tdata = (uint8_t *)data16;\n\t\t\t\t\toutput = (uint8_t *)output16;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t{\n\t\t\t\t\tuint32_t *data32 = (uint32_t *)data;\n\t\t\t\t\tuint32_t *output32 = (uint32_t *)output;\n\t\t\t\t\t*output32 = BYTESWAP32(*data32);\n\t\t\t\t\toutput32++;\n\t\t\t\t\tdata32++;\n\n\t\t\t\t\tdata = (uint8_t *)data32;\n\t\t\t\t\toutput = (uint8_t *)output32;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t{\n\t\t\t\t\tuint32_t *data32 = (uint32_t *)data;\n\t\t\t\t\tuint32_t *output32 = (uint32_t *)output;\n\t\t\t\t\t*(output32+1) = BYTESWAP32(*data32);\n\t\t\t\t\t*(output32) = BYTESWAP32(*(data32+1));\n\t\t\t\t\tdata32 += 2;\n\t\t\t\t\toutput32 += 2;\n\n\t\t\t\t\tdata = (uint8_t *)data32;\n\t\t\t\t\toutput = (uint8_t *)output32;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tdefault: //1, 16 or more not byteswapped\n\t\t\t\t\tfor (j = 0; j < typesize; j++)\n\t\t\t\t\t\t*output++ = *data++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn GPMF_OK;\n\t}\n\n\treturn GPMF_ERROR_MEMORY;\n}\n\n\n#define MACRO_CAST_SCALE_UNSIGNED_TYPE(casttype)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcasttype *tmp = (casttype *)output;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tswitch (scaletype)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcase GPMF_TYPE_SIGNED_BYTE:\t\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((int8_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_UNSIGNED_BYTE:\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((uint8_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_SIGNED_SHORT:\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((int16_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_UNSIGNED_SHORT:\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((uint16_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_SIGNED_LONG:\t\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((int32_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_UNSIGNED_LONG:\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((uint32_t *)scaledata8);\tbreak;  \\\n\tcase GPMF_TYPE_FLOAT:\t\t\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((float *)scaledata8);\tbreak;\t\\\n\tdefault: break;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\toutput = (uint8_t *)tmp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n\n#define MACRO_CAST_SCALE_SIGNED_TYPE(casttype)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcasttype *tmp = (casttype *)output;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tswitch (scaletype)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcase GPMF_TYPE_SIGNED_BYTE:\t\t*tmp++ = (casttype)*val / (casttype)*((int8_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_UNSIGNED_BYTE:\t*tmp++ = (casttype)*val / (casttype)*((uint8_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_SIGNED_SHORT:\t*tmp++ = (casttype)*val / (casttype)*((int16_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_UNSIGNED_SHORT:\t*tmp++ = (casttype)*val / (casttype)*((uint16_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_SIGNED_LONG:\t\t*tmp++ = (casttype)*val / (casttype)*((int32_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_UNSIGNED_LONG:\t*tmp++ = (casttype)*val / (casttype)*((uint32_t *)scaledata8);\tbreak;  \\\n\tcase GPMF_TYPE_FLOAT:\t\t\t*tmp++ = (casttype)*val / (casttype)*((float *)scaledata8);\t\tbreak;\t\\\n\tdefault: break;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\toutput = (uint8_t *)tmp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n\n#define MACRO_CAST_SCALE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tswitch (outputType)\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tcase GPMF_TYPE_SIGNED_BYTE: \tMACRO_CAST_SCALE_SIGNED_TYPE(int8_t)\tbreak;\t\t\\\n\t\tcase GPMF_TYPE_UNSIGNED_BYTE:\tMACRO_CAST_SCALE_UNSIGNED_TYPE(uint8_t)\tbreak;\t\t\\\n\t\tcase GPMF_TYPE_SIGNED_SHORT: \tMACRO_CAST_SCALE_SIGNED_TYPE(int16_t)\tbreak;\t\t\\\n\t\tcase GPMF_TYPE_UNSIGNED_SHORT:\tMACRO_CAST_SCALE_UNSIGNED_TYPE(uint16_t)\tbreak;\t\\\n\t\tcase GPMF_TYPE_FLOAT:\t\t\tMACRO_CAST_SCALE_SIGNED_TYPE(float)\tbreak;\t\t\t\\\n\t\tcase GPMF_TYPE_SIGNED_LONG:\t\tMACRO_CAST_SCALE_SIGNED_TYPE(int32_t)\tbreak;\t\t\\\n\t\tcase GPMF_TYPE_UNSIGNED_LONG:\tMACRO_CAST_SCALE_UNSIGNED_TYPE(uint32_t)\tbreak;\t\\\n\t\tcase GPMF_TYPE_DOUBLE:\t\t\tMACRO_CAST_SCALE_SIGNED_TYPE(double)\tbreak;\t\t\\\n\t\tdefault: break;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n#define MACRO_BSWAP_CAST_SCALE(swap, inputcast, tempcast)\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tinputcast *val;\t\t\t\t\t\t\t\t\t\t\\\n\ttempcast temp,  *datatemp = (tempcast *)data;\t\t\\\n\ttemp = swap(*datatemp);\t\t\t\t\t\t\t\t\\\n\tval = (inputcast *)&temp;\t\t\t\t\t\t\t\\\n\tMACRO_CAST_SCALE\t\t\t\t\t\t\t\t\t\\\n\tdatatemp++;\t\t\t\t\t\t\t\t\t\t\t\\\n\tdata = (uint8_t *)datatemp;\t\t\t\t\t\t\t\\\n}\n\nGPMF_ERR GPMF_ScaledData(GPMF_stream *ms, void *buffer, uint32_t buffersize, uint32_t sample_offset, uint32_t read_samples, GPMF_SampleType outputType)\n{\n\tif (ms && buffer)\n\t{\n\t\tuint8_t *data = (uint8_t *)&ms->buffer[ms->pos + 2];\n\t\tuint8_t *output = (uint8_t *)buffer;\n\t\tuint32_t sample_size = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1]);\n\t\tuint32_t output_sample_size = GPMF_SizeofType(outputType);\n\t\tuint32_t remaining_sample_size = GPMF_DATA_PACKEDSIZE(ms->buffer[ms->pos + 1]);\n\t\tuint8_t type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\t\tchar complextype[64] = \"L\";\n\t\tuint32_t inputtypesize = 0;\n\t\tuint32_t inputtypeelements = 0;\n\t\tuint8_t scaletype = 0;\n\t\tuint8_t scalecount = 0;\n\t\tuint32_t scaletypesize = 0;\n\t\tuint32_t *scaledata = NULL;\n\t\tuint32_t tmpbuffer[64];\n\t\tuint32_t tmpbuffersize = sizeof(tmpbuffer);\n\t\tuint32_t elements = 1;\n\n\t\ttype = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\n\t\tif (type == GPMF_TYPE_NEST)\n\t\t\treturn GPMF_ERROR_MEMORY;\n\n\t\tif (GPMF_OK != IsValidSize(ms, remaining_sample_size >> 2))\n\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\n\t\tremaining_sample_size -= sample_offset * sample_size; // skip samples\n\t\tdata += sample_offset * sample_size;\n\n\t\tif (remaining_sample_size < sample_size * read_samples)\n\t\t\treturn GPMF_ERROR_MEMORY;\n\n\t\tif (type == GPMF_TYPE_COMPLEX)\n\t\t{\n\n\t\t\tGPMF_stream find_stream;\n\t\t\tGPMF_CopyState(ms, &find_stream);\n\n\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_RECURSE_LEVELS))\n\t\t\t{\n\t\t\t\tchar *data1 = (char *)GPMF_RawData(&find_stream);\n\t\t\t\tint size = GPMF_RawDataSize(&find_stream);\n\t\t\t\tuint32_t typestringlength = sizeof(complextype);\n\t\t\t\tif (GPMF_OK == GPMF_ExpandComplexTYPE(data1, size, complextype, &typestringlength))\n\t\t\t\t{\n\t\t\t\t\tinputtypeelements = elements = typestringlength;\n\n\t\t\t\t\tif (sample_size != GPMF_SizeOfComplexTYPE(complextype, typestringlength))\n\t\t\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcomplextype[0] = type;\n\t\t\tinputtypesize = GPMF_SizeofType(type);\n\t\t\tif (inputtypesize == 0)\n\t\t\t\treturn GPMF_ERROR_MEMORY;\n\t\t\tinputtypeelements = 1;\n\t\t\telements = sample_size / inputtypesize;\n\t\t}\n\n\t\tif (output_sample_size * elements * read_samples > buffersize)\n\t\t\treturn GPMF_ERROR_MEMORY;\n\n\n\t\tswitch (outputType)\t{\n\t\tcase GPMF_TYPE_SIGNED_BYTE:\n\t\tcase GPMF_TYPE_UNSIGNED_BYTE:\n\t\tcase GPMF_TYPE_SIGNED_SHORT:\n\t\tcase GPMF_TYPE_UNSIGNED_SHORT:\n\t\tcase GPMF_TYPE_FLOAT:\n\t\tcase GPMF_TYPE_SIGNED_LONG:\n\t\tcase GPMF_TYPE_UNSIGNED_LONG:\n\t\tcase GPMF_TYPE_DOUBLE:\n\t\t\t// All supported formats.\n\t\t{\n\t\t\tGPMF_stream fs;\n\t\t\tGPMF_CopyState(ms, &fs);\n\n\t\t\tif (GPMF_OK == GPMF_FindPrev(&fs, GPMF_KEY_SCALE, GPMF_CURRENT_LEVEL))\n\t\t\t{\n\t\t\t\tscaledata = (uint32_t *)GPMF_RawData(&fs);\n\t\t\t\tscaletype = GPMF_SAMPLE_TYPE(fs.buffer[fs.pos + 1]);\n\n\t\t\t\tswitch (scaletype)\n\t\t\t\t{\n\t\t\t\tcase GPMF_TYPE_SIGNED_BYTE:\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_BYTE:\n\t\t\t\tcase GPMF_TYPE_SIGNED_SHORT:\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_SHORT:\n\t\t\t\tcase GPMF_TYPE_SIGNED_LONG:\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_LONG:\n\t\t\t\tcase GPMF_TYPE_FLOAT:\n\t\t\t\t\tscalecount = GPMF_SAMPLES(fs.buffer[fs.pos + 1]);\n\t\t\t\t\tscaletypesize = GPMF_SizeofType(scaletype);\n\n\t\t\t\t\tif (scalecount > 1)\n\t\t\t\t\t\tif (scalecount != elements)\n\t\t\t\t\t\t\treturn GPMF_ERROR_SCALE_COUNT;\n\n\t\t\t\t\tGPMF_FormattedData(&fs, tmpbuffer, tmpbuffersize, 0, scalecount);\n\n\t\t\t\t\tscaledata = (uint32_t *)tmpbuffer;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tscaletype = 'L';\n\t\t\t\tscalecount = 1;\n\t\t\t\ttmpbuffer[0] = 1; // set the scale to 1 is no scale was provided\n\t\t\t\tscaledata = (uint32_t *)tmpbuffer;\n\t\t\t}\n\t\t}\n\n\t\twhile (read_samples--)\n\t\t{\n\t\t\tuint32_t i;\n\t\t\tuint8_t *scaledata8 = (uint8_t *)scaledata;\n\n\t\t\tfor (i = 0; i < elements; i++)\n\t\t\t{\n\t\t\t\tswitch (complextype[i % inputtypeelements])\n\t\t\t\t{\n\t\t\t\tcase GPMF_TYPE_FLOAT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, float, uint32_t) break;\n\t\t\t\tcase GPMF_TYPE_SIGNED_BYTE:  MACRO_BSWAP_CAST_SCALE(NOSWAP8, int8_t, uint8_t) break;\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_BYTE:  MACRO_BSWAP_CAST_SCALE(NOSWAP8, uint8_t, uint8_t) break;\n\t\t\t\tcase GPMF_TYPE_SIGNED_SHORT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP16, int16_t, uint16_t) break;\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_SHORT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP16, uint16_t, uint16_t) break;\n\t\t\t\tcase GPMF_TYPE_SIGNED_LONG:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, int32_t, uint32_t) break;\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_LONG:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, uint32_t, uint32_t) break;\n\t\t\t\tcase GPMF_TYPE_SIGNED_64BIT_INT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP64, uint64_t, uint64_t) break;\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_64BIT_INT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP64, uint64_t, uint64_t) break;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (scalecount > 1)\n\t\t\t\t\tscaledata8 += scaletypesize;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn GPMF_OK;\n\t}\n\n\treturn GPMF_ERROR_MEMORY;\n}\n", "/*! @file GPMF_parser.h\n * \n *  @brief GPMF Parser library include\n * \n *  @version 1.1.0\n * \n *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n *\t\n *  Licensed under either:\n *  - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0  \n *  - MIT license, http://opensource.org/licenses/MIT\n *  at your option.\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n * \n */\n\n#ifndef _GPMF_PARSER_H\n#define _GPMF_PARSER_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define GPMF_NEST_LIMIT 16\n\ntypedef struct GPMF_stream\n{\n\tuint32_t *buffer;\n\tuint32_t buffer_size_longs;\n\tuint32_t pos;\n\tuint32_t last_level_pos[GPMF_NEST_LIMIT];\n\tuint32_t nest_size[GPMF_NEST_LIMIT];\n\tuint32_t last_seek[GPMF_NEST_LIMIT];\n\tuint32_t nest_level;\n\tuint32_t device_count;\n\tuint32_t device_id;\n\tchar device_name[32];\n} GPMF_stream;\n\ntypedef enum GPMF_ERROR\n{\n\tGPMF_OK = 0,\n\tGPMF_ERROR_MEMORY,\n\tGPMF_ERROR_BAD_STRUCTURE,\n\tGPMF_ERROR_BUFFER_END,\n\tGPMF_ERROR_FIND,\n\tGPMF_ERROR_LAST,\n\tGPMF_ERROR_TYPE_NOT_SUPPORTED,\n\tGPMF_ERROR_SCALE_NOT_SUPPORTED,\n\tGPMF_ERROR_SCALE_COUNT,\n\tGPMF_ERROR_RESERVED\n} GPMF_ERROR;\n\ntypedef enum GPMF_LEVELS\n{\n\tGPMF_CURRENT_LEVEL = 0,\n\tGPMF_RECURSE_LEVELS\n} GPMF_LEVELS;\n\n#define GPMF_ERR\tuint32_t\n\ntypedef enum\n{\n\tGPMF_TYPE_STRING_ASCII = 'c', //single byte 'c' style character string\n\tGPMF_TYPE_SIGNED_BYTE = 'b',//single byte signed number\n\tGPMF_TYPE_UNSIGNED_BYTE = 'B', //single byte unsigned number\n\tGPMF_TYPE_SIGNED_SHORT = 's',//16-bit integer\n\tGPMF_TYPE_UNSIGNED_SHORT = 'S',//16-bit integer\n\tGPMF_TYPE_FLOAT = 'f', //32-bit single precision float (IEEE 754)\n\tGPMF_TYPE_FOURCC = 'F', //32-bit four character tag \n\tGPMF_TYPE_SIGNED_LONG = 'l',//32-bit integer\n\tGPMF_TYPE_UNSIGNED_LONG = 'L', //32-bit integer\n\tGPMF_TYPE_Q15_16_FIXED_POINT = 'q', // Q number Q15.16 - 16-bit signed integer (A) with 16-bit fixed point (B) for A.B value (range -32768.0 to 32767.99998). \n\tGPMF_TYPE_Q31_32_FIXED_POINT = 'Q', // Q number Q31.32 - 32-bit signed integer (A) with 32-bit fixed point (B) for A.B value. \n\tGPMF_TYPE_SIGNED_64BIT_INT = 'j', //64 bit signed long\n\tGPMF_TYPE_UNSIGNED_64BIT_INT = 'J', //64 bit unsigned long\t\n\tGPMF_TYPE_DOUBLE = 'd', //64 bit double precision float (IEEE 754)\n\tGPMF_TYPE_UTC_DATE_TIME = 'U', //128-bit ASCII Date + UTC Time format yymmddhhmmss.sss - 16 bytes ASCII (years 20xx covered)\n\tGPMF_TYPE_GUID = 'G', //128-bit ID (like UUID)\n\n\tGPMF_TYPE_COMPLEX = '?', //for sample with complex data structures, base size in bytes.  Data is either opaque, or the stream has a TYPE structure field for the sample.\n\n\tGPMF_TYPE_NEST = 0, // used to nest more GPMF formatted metadata \n\n} GPMF_SampleType;\n\n\n\n#define MAKEID(a,b,c,d)\t\t\t(((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))\n#define STR2FOURCC(s)\t\t\t((s[0]<<0)|(s[1]<<8)|(s[2]<<16)|(s[3]<<24))\n\n#define BYTESWAP64(a)\t\t\t(((a&0xff)<<56)|((a&0xff00)<<40)|((a&0xff0000)<<24)|((a&0xff000000)<<8) | ((a>>56)&0xff)|((a>>40)&0xff00)|((a>>24)&0xff0000)|((a>>8)&0xff000000) )\n#define BYTESWAP32(a)\t\t\t(((a&0xff)<<24)|((a&0xff00)<<8)|((a>>8)&0xff00)|((a>>24)&0xff))\n#define BYTESWAP16(a)\t\t\t((((a)>>8)&0xff)|(((a)<<8)&0xff00))\n#define NOSWAP8(a)\t\t\t\t(a)\n\n#define GPMF_SAMPLES(a)\t\t\t(((a>>24) & 0xff)|(((a>>16)&0xff)<<8))\n#define GPMF_SAMPLE_SIZE(a)\t\t(((a)>>8)&0xff)\n#define GPMF_SAMPLE_TYPE(a)\t\t(a&0xff)\n#define GPMF_MAKE_TYPE_SIZE_COUNT(t,s,c)\t\t((t)&0xff)|(((s)&0xff)<<8)|(((c)&0xff)<<24)|(((c)&0xff00)<<8)\n#define GPMF_DATA_SIZE(a)\t\t((GPMF_SAMPLE_SIZE(a)*GPMF_SAMPLES(a)+3)&~0x3)\n#define GPMF_DATA_PACKEDSIZE(a)\t((GPMF_SAMPLE_SIZE(a)*GPMF_SAMPLES(a)))\n#define GPMF_VALID_FOURCC(a)\t(((((a>>24)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>24)&0xff)>='A'&&((a>>24)&0xff)<='Z') || (((a>>24)&0xff)>='0'&&((a>>24)&0xff)<='9') || (((a>>24)&0xff)==' ') ) && \\\n\t\t\t\t\t\t\t\t( (((a>>16)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>16)&0xff)>='A'&&((a>>16)&0xff)<='Z') || (((a>>16)&0xff)>='0'&&((a>>16)&0xff)<='9') || (((a>>16)&0xff)==' ') ) && \\\n\t\t\t\t\t\t\t\t( (((a>>8)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>8)&0xff)>='A'&&((a>>8)&0xff)<='Z') || (((a>>8)&0xff)>='0'&&((a>>8)&0xff)<='9') || (((a>>8)&0xff)==' ') ) && \\\n\t\t\t\t\t\t\t\t( (((a>>0)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>0)&0xff)>='A'&&((a>>0)&0xff)<='Z') || (((a>>0)&0xff)>='0'&&((a>>0)&0xff)<='9') || (((a>>0)&0xff)==' ') )) \n#define GPMF_KEY_TYPE(a)\t\t(a&0xff)\n\n#define PRINTF_4CC(k)\t\t\t((k) >> 0) & 0xff, ((k) >> 8) & 0xff, ((k) >> 16) & 0xff, ((k) >> 24) & 0xff\n\n \ntypedef enum GPMFKey // TAG in all caps are GoPro preserved (are defined by GoPro, but can be used by others.)\n{\n\t// Internal Metadata structure and formatting tags\n\tGPMF_KEY_DEVICE =\t\t\tMAKEID('D','E','V','C'),//DEVC - nested device data to speed the parsing of multiple devices in post \n\tGPMF_KEY_DEVICE_ID =\t\tMAKEID('D','V','I','D'),//DVID - unique id per stream for a metadata source (in camera or external input) (single 4 byte int)\n\tGPMF_KEY_DEVICE_NAME =\t\tMAKEID('D','V','N','M'),//DVNM - human readable device type/name (char string)\n\tGPMF_KEY_STREAM =\t\t\tMAKEID('S','T','R','M'),//STRM - nested channel/stream of telemetry data\n\tGPMF_KEY_STREAM_NAME =\t\tMAKEID('S','T','N','M'),//STNM - human readable telemetry/metadata stream type/name (char string)\n\tGPMF_KEY_SI_UNITS =\t\t\tMAKEID('S','I','U','N'),//SIUN - Display string for metadata units where inputs are in SI units \"uT\",\"rad/s\",\"km/s\",\"m/s\",\"mm/s\" etc.\n\tGPMF_KEY_UNITS =\t\t\tMAKEID('U','N','I','T'),//UNIT - Freedform display string for metadata units (char sting like \"RPM\", \"MPH\", \"km/h\", etc)\n\tGPMF_KEY_SCALE =\t\t\tMAKEID('S','C','A','L'),//SCAL - divisor for input data to scale to the correct units.\n\tGPMF_KEY_TYPE =\t\t\t\tMAKEID('T','Y','P','E'),//TYPE - Type define for complex data structures\n\tGPMF_KEY_TOTAL_SAMPLES =\tMAKEID('T','S','M','P'),//TOTL - Total Sample Count including the current payload \t\n\tGPMF_KEY_TICK =\t\t\t\tMAKEID('T','I','C','K'),//TICK - Used for slow data. Beginning of data timing in milliseconds. \n\tGPMF_KEY_TOCK =\t\t\t\tMAKEID('T','O','C','K'),//TOCK - Used for slow data. End of data timing in milliseconds. \n\tGPMF_KEY_EMPTY_PAYLOADS =\tMAKEID('E','M','P','T'),//EMPT - Payloads that are empty since the device start (e.g. BLE disconnect.)\n\tGPMF_KEY_REMARK =\t\t\tMAKEID('R','M','R','K'),//RMRK - addcing comments to the bitstream (debugging)\n\n\tGPMF_KEY_END = 0//(null)\n} GPMFKey;\n\n\n\n// Prepare GPMF data \nGPMF_ERR GPMF_Init(GPMF_stream *gs, uint32_t *buffer, int datasize);\t\t\t\t\t\t\t//Initialize a GPMF_stream for parsing a particular buffer.\nGPMF_ERR GPMF_ResetState(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Read from beginning of the buffer again\nGPMF_ERR GPMF_CopyState(GPMF_stream *src, GPMF_stream *dst);\t\t\t\t\t\t\t\t\t//Copy state, \nGPMF_ERR GPMF_Validate(GPMF_stream *gs, GPMF_LEVELS recurse);\t\t\t\t\t\t\t\t\t//Is the nest structure valid GPMF? \n\n// Navigate through GPMF data \nGPMF_ERR GPMF_Next(GPMF_stream *gs, GPMF_LEVELS recurse);\t\t\t\t\t\t\t\t\t\t//Step to the next GPMF KLV entrance, optionally recurse up or down nesting levels.\nGPMF_ERR GPMF_FindPrev(GPMF_stream *gs, uint32_t fourCC, GPMF_LEVELS recurse);\t\t\t\t\t//find a previous FourCC -- at the current level only if recurse is false\nGPMF_ERR GPMF_FindNext(GPMF_stream *gs, uint32_t fourCC, GPMF_LEVELS recurse);\t\t\t\t\t//find a particular FourCC upcoming -- at the current level only if recurse is false\nGPMF_ERR GPMF_SeekToSamples(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t//find the last FourCC in the current level, this is raw data for any STRM\n\n// Get information about the current GPMF KLV\nuint32_t GPMF_Key(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current Key (FourCC)\nuint32_t GPMF_Type(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current Type (GPMF_Type)\nuint32_t GPMF_StructSize(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current sample structure size\nuint32_t GPMF_Repeat(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current repeat or the number of samples of this structure\nuint32_t GPMF_PayloadSampleCount(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current number of samples of this structure, supporting multisample entries.\nuint32_t GPMF_ElementsInStruct(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t//return the current number elements within the structure (e.g. 3-axis gyro)\nuint32_t GPMF_RawDataSize(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the data size for the current GPMF KLV \nvoid *   GPMF_RawData(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return a pointer the KLV data (which is Bigendian if the type is known.)\n\n// Get information about where the GPMF KLV is nested\nuint32_t GPMF_NestLevel(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current nest level\nuint32_t GPMF_DeviceID(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current device ID (DVID), to seperate match sensor data from difference devices.\nGPMF_ERR GPMF_DeviceName(GPMF_stream *gs, char *devicename_buf, uint32_t devicename_buf_size);\t//return the current device name (DVNM), to seperate match sensor data from difference devices.\n\n// Utilities for data types\nuint32_t GPMF_SizeofType(GPMF_SampleType type);\t\t\t\t\t\t\t\t\t\t\t\t\t// GPMF equivalent to sizeof(type)\nuint32_t GPMF_ExpandComplexTYPE(char *src, uint32_t srcsize, char *dst, uint32_t *dstsize);\t\t// GPMF using TYPE for cmple structure.  { float val[16],uin32_t flags; } has type \"f[8]L\", this tools expands to the simpler format \"ffffffffL\"\nuint32_t GPMF_SizeOfComplexTYPE(char *typearray, uint32_t typestringlength);\t\t\t\t\t// GPMF equivalent to sizeof(typedef) for complex types. \nGPMF_ERR GPMF_Reserved(uint32_t key);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Test for a reverse GPMF Key, returns GPMF_OK is not reversed.\n\n//Tools for extracting sensor data \nGPMF_ERR GPMF_FormattedData(GPMF_stream *gs, void *buffer, uint32_t buffersize, uint32_t sample_offset, uint32_t read_samples);  // extract 'n' samples into local endian memory format.\nGPMF_ERR GPMF_ScaledData(GPMF_stream *gs, void *buffer, uint32_t buffersize, uint32_t sample_offset, uint32_t read_samples, GPMF_SampleType type); // extract 'n' samples into local endian memory format\t\t\t\t\t\t\t\t\t\t// return a point the KLV data.\n\n\n\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*! @file GPMF_demo.c\n *\n *  @brief Demo to extract GPMF from an MP4\n *\n *  @version 1.0.1\n *\n *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n *\t\n *  Licensed under either:\n *  - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0  \n *  - MIT license, http://opensource.org/licenses/MIT\n *  at your option.\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n#include \"../GPMF_parser.h\"\n#include \"GPMF_mp4reader.h\"\n\n\nextern void PrintGPMF(GPMF_stream *ms);\n\nint main(int argc, char *argv[])\n{\n\tint32_t ret = GPMF_OK;\n\tGPMF_stream metadata_stream, *ms = &metadata_stream;\n\tdouble metadatalength;\n\tuint32_t *payload = NULL; //buffer to store GPMF samples from the MP4.\n\n\n\t// get file return data\n\tif (argc != 2)\n\t{\n\t\tprintf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);\n\t\treturn -1;\n\t}\n\n\tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);\n//\tsize_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4's udta \n\n\tmetadatalength = GetDuration(mp4);\n\n\tif (metadatalength > 0.0)\n\t{\n\t\tuint32_t index, payloads = GetNumberPayloads(mp4);\n//\t\tprintf(\"found %.2fs of metadata, from %d payloads, within %s\\n\", metadatalength, payloads, argv[1]);\n\n#if 1\n\t\tif (payloads == 1) // Printf the contents of the single payload\n\t\t{\n\t\t\tuint32_t payloadsize = GetPayloadSize(mp4,0);\n\t\t\tpayload = GetPayload(mp4, payload, 0);\n\t\t\tif(payload == NULL)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n\t\t\t// Output (printf) all the contained GPMF data within this payload\n\t\t\tret = GPMF_Validate(ms, GPMF_RECURSE_LEVELS); // optional\n\t\t\tif (GPMF_OK != ret)\n\t\t\t{\n\t\t\t\tprintf(\"Invalid Structure\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tGPMF_ResetState(ms);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tPrintGPMF(ms);  // printf current GPMF KLV\n\t\t\t} while (GPMF_OK == GPMF_Next(ms, GPMF_RECURSE_LEVELS));\n\t\t\tGPMF_ResetState(ms);\n\t\t\tprintf(\"\\n\");\n\n\t\t}\n#endif\n\n\n\t\tfor (index = 0; index < payloads; index++)\n\t\t{\n\t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);\n\t\t\tfloat in = 0.0, out = 0.0; //times\n\t\t\tpayload = GetPayload(mp4, payload, index);\n\t\t\tif (payload == NULL)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GetPayloadTime(mp4, index, &in, &out);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n#if 1\t\t// Find all the available Streams and the data carrying FourCC\n\t\t\tif (index == 0) // show first payload \n\t\t\t{\n\t\t\t\tret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);\n\t\t\t\twhile (GPMF_OK == ret)\n\t\t\t\t{\n\t\t\t\t\tret = GPMF_SeekToSamples(ms);\n\t\t\t\t\tif (GPMF_OK == ret) //find the last FOURCC within the stream\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t key = GPMF_Key(ms);\n\t\t\t\t\t\tGPMF_SampleType type = GPMF_Type(ms);\n\t\t\t\t\t\tuint32_t elements = GPMF_ElementsInStruct(ms);\n\t\t\t\t\t\t//uint32_t samples = GPMF_Repeat(ms);\n\t\t\t\t\t\tuint32_t samples = GPMF_PayloadSampleCount(ms);\n\n\t\t\t\t\t\tif (samples)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"  STRM of %c%c%c%c \", PRINTF_4CC(key));\n\n\t\t\t\t\t\t\tif (type == GPMF_TYPE_COMPLEX)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGPMF_stream find_stream;\n\t\t\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n\n\t\t\t\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_CURRENT_LEVEL))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tchar tmp[64];\n\t\t\t\t\t\t\t\t\tchar *data = (char *)GPMF_RawData(&find_stream);\n\t\t\t\t\t\t\t\t\tint size = GPMF_RawDataSize(&find_stream);\n\n\t\t\t\t\t\t\t\t\tif (size < sizeof(tmp))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmemcpy(tmp, data, size);\n\t\t\t\t\t\t\t\t\t\ttmp[size] = 0;\n\t\t\t\t\t\t\t\t\t\tprintf(\"of type %s \", tmp);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprintf(\"of type %c \", type);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprintf(\"with %d sample%s \", samples, samples > 1 ? \"s\" : \"\");\n\n\t\t\t\t\t\t\tif (elements > 1)\n\t\t\t\t\t\t\t\tprintf(\"-- %d elements per sample\", elements);\n\n\t\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ret == GPMF_ERROR_BAD_STRUCTURE) // some payload element was corrupt, skip to the next valid GPMF KLV at the previous level.\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tret = GPMF_Next(ms, GPMF_CURRENT_LEVEL); // this will be the next stream if any more are present.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tGPMF_ResetState(ms);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n#endif \n\n\n\n\n#if 1\t\t// Find GPS values and return scaled doubles. \n\t\t\tif (index == 0) // show first payload \n\t\t\t{\n\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"GPS5\"), GPMF_RECURSE_LEVELS) || //GoPro Hero5/6/7 GPS\n\t\t\t\t\tGPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"GPRI\"), GPMF_RECURSE_LEVELS))   //GoPro Karma GPS\n\t\t\t\t{\n\t\t\t\t\tuint32_t key = GPMF_Key(ms);\n\t\t\t\t\tuint32_t samples = GPMF_Repeat(ms);\n\t\t\t\t\tuint32_t elements = GPMF_ElementsInStruct(ms);\n\t\t\t\t\tuint32_t buffersize = samples * elements * sizeof(double);\n\t\t\t\t\tGPMF_stream find_stream;\n\t\t\t\t\tdouble *ptr, *tmpbuffer = malloc(buffersize);\n\t\t\t\t\tchar units[10][6] = { \"\" };\n\t\t\t\t\tuint32_t unit_samples = 1;\n\n\t\t\t\t\tprintf(\"MP4 Payload time %.3f to %.3f seconds\\n\", in, out);\n\n\t\t\t\t\tif (tmpbuffer && samples)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t i, j;\n\n\t\t\t\t\t\t//Search for any units to display\n\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n\t\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_SI_UNITS, GPMF_CURRENT_LEVEL) ||\n\t\t\t\t\t\t\tGPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_UNITS, GPMF_CURRENT_LEVEL))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar *data = (char *)GPMF_RawData(&find_stream);\n\t\t\t\t\t\t\tint ssize = GPMF_StructSize(&find_stream);\n\t\t\t\t\t\t\tunit_samples = GPMF_Repeat(&find_stream);\n\n\t\t\t\t\t\t\tfor (i = 0; i < unit_samples; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmemcpy(units[i], data, ssize);\n\t\t\t\t\t\t\t\tunits[i][ssize] = 0;\n\t\t\t\t\t\t\t\tdata += ssize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//GPMF_FormattedData(ms, tmpbuffer, buffersize, 0, samples); // Output data in LittleEnd, but no scale\n\t\t\t\t\t\tGPMF_ScaledData(ms, tmpbuffer, buffersize, 0, samples, GPMF_TYPE_DOUBLE);  //Output scaled data as floats\n\n\t\t\t\t\t\tptr = tmpbuffer;\n\t\t\t\t\t\tfor (i = 0; i < samples; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"%c%c%c%c \", PRINTF_4CC(key));\n\t\t\t\t\t\t\tfor (j = 0; j < elements; j++)\n\t\t\t\t\t\t\t\tprintf(\"%.3f%s, \", *ptr++, units[j%unit_samples]);\n\n\t\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(tmpbuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tGPMF_ResetState(ms);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n#endif \n\t\t}\n\n#if 1\n\t\t// Find all the available Streams and compute they sample rates\n\t\twhile (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))\n\t\t{\n\t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream\n\t\t\t{\n\t\t\t\tuint32_t fourcc = GPMF_Key(ms);\n\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);\n\t\t\t\tprintf(\"%c%c%c%c sampling rate = %f Hz\\n\", PRINTF_4CC(fourcc), rate);\n\t\t\t}\n\t\t}\n#endif\n\n\n\tcleanup:\n\t\tif (payload) FreePayload(payload); payload = NULL;\n\t\tCloseSource(mp4);\n\t}\n\n\treturn ret;\n}\n", "/*! @file mp4reader.c\n*\n*  @brief Way Too Crude MP4|MOV reader\n*\n*  @version 1.2.1\n*\n*  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n*\n*  Licensed under the Apache License, Version 2.0 (the \"License\");\n*  you may not use this file except in compliance with the License.\n*  You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n*  Unless required by applicable law or agreed to in writing, software\n*  distributed under the License is distributed on an \"AS IS\" BASIS,\n*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n*  See the License for the specific language governing permissions and\n*  limitations under the License.\n*\n*/\n\n/* This is not an elegant MP4 parser, only used to help demonstrate extraction of MP4 */\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include \"GPMF_mp4reader.h\"\n\n#define PRINT_MP4_STRUCTURE\t\t0\n\n#ifdef WIN32\n#define LONGSEEK  _fseeki64\n#else\n#define LONGSEEK  fseeko\n#endif\n\n\nuint32_t GetNumberPayloads(size_t handle)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\n\tif (mp4)\n\t{\n\t\treturn mp4->indexcount;\n\t}\n\n\treturn 0;\n}\n\n\nuint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return NULL;\n\n\tuint32_t *MP4buffer = NULL;\n\tif (index < mp4->indexcount && mp4->mediafp)\n\t{\n\t\tMP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4->metasizes[index]);\n\n\t\tif (MP4buffer)\n\t\t{\n\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);\n\t\t\treturn MP4buffer;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\nvoid SavePayload(size_t handle, uint32_t *payload, uint32_t index)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return;\n\n\tuint32_t *MP4buffer = NULL;\n\tif (index < mp4->indexcount && mp4->mediafp && payload)\n\t{\n\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n\t\tfwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);\n\t}\n\treturn;\n}\n\n\n\nvoid FreePayload(uint32_t *lastpayload)\n{\n\tif (lastpayload)\n\t\tfree(lastpayload);\n}\n\n\nuint32_t GetPayloadSize(size_t handle, uint32_t index)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return 0;\n\n\tif (mp4->metasizes && mp4->metasize_count > index)\n\t\treturn mp4->metasizes[index];\n\n\treturn 0;\n}\n\n#define MAX_NEST_LEVEL\t20\n\nsize_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  //RAW or within MP4\n{\n\tmp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));\n\tif (mp4 == NULL) return 0;\n\n\tmemset(mp4, 0, sizeof(mp4object));\n\n#ifdef _WINDOWS\n\tfopen_s(&mp4->mediafp, filename, \"rb\");\n#else\n\tmp4->mediafp = fopen(filename, \"rb\");\n#endif\n\n\tif (mp4->mediafp)\n\t{\n\t\tuint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;\n\t\tsize_t len;\n\t\tint32_t nest = 0;\n\t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\n\t\tuint64_t lastsize = 0, qtsize;\n\n\t\tdo\n\t\t{\n\t\t\tlen = fread(&qtsize32, 1, 4, mp4->mediafp);\n\t\t\tlen += fread(&qttag, 1, 4, mp4->mediafp);\n\t\t\tif (len == 8)\n\t\t\t{\n\t\t\t\tif (!VALID_FOURCC(qttag))\n\t\t\t\t{\n\t\t\t\t\tLONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);\n\n\t\t\t\t\tNESTSIZE(lastsize - 8);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tqtsize32 = BYTESWAP32(qtsize32);\n\n\t\t\t\tif (qtsize32 == 1) // 64-bit Atom\n\t\t\t\t{\n\t\t\t\t\tfread(&qtsize, 1, 8, mp4->mediafp);\n\t\t\t\t\tqtsize = BYTESWAP64(qtsize) - 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tqtsize = qtsize32;\n\n\t\t\t\tnest++;\n\n\t\t\t\tif (qtsize < 8) break;\n\t\t\t\tif (nest >= MAX_NEST_LEVEL) break;\n\n\t\t\t\tnestsize[nest] = qtsize;\n\t\t\t\tlastsize = qtsize;\n\n#if PRINT_MP4_STRUCTURE\t\n\n\t\t\t\tfor (int i = 1; i < nest; i++) printf(\"    \");\n\t\t\t\tprintf(\"%c%c%c%c (%lld)\\n\", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);\n\n\t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||\n\t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p') ||\n\t\t\t\t\tqttag == MAKEID('u', 'd', 't', 'a'))\n\t\t\t\t{\n\t\t\t\t\tLONGSEEK(mediafp, qtsize - 8, SEEK_CUR);\n\n\t\t\t\t\tNESTSIZE(qtsize);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#else\n\t\t\t\tif (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms\n\t\t\t\t\tqttag != MAKEID('m', 'v', 'h', 'd') &&\n\t\t\t\t\tqttag != MAKEID('t', 'r', 'a', 'k') &&\n\t\t\t\t\tqttag != MAKEID('m', 'd', 'i', 'a') &&\n\t\t\t\t\tqttag != MAKEID('m', 'd', 'h', 'd') &&\n\t\t\t\t\tqttag != MAKEID('m', 'i', 'n', 'f') &&\n\t\t\t\t\tqttag != MAKEID('g', 'm', 'i', 'n') &&\n\t\t\t\t\tqttag != MAKEID('d', 'i', 'n', 'f') &&\n\t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n\t\t\t\t\tqttag != MAKEID('s', 't', 's', 'd') &&\n\t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n\t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n\t\t\t\t\tqttag != MAKEID('s', 't', 'b', 'l') &&\n\t\t\t\t\tqttag != MAKEID('s', 't', 't', 's') &&\n\t\t\t\t\tqttag != MAKEID('s', 't', 's', 'c') &&\n\t\t\t\t\tqttag != MAKEID('s', 't', 's', 'z') &&\n\t\t\t\t\tqttag != MAKEID('s', 't', 'c', 'o') &&\n\t\t\t\t\tqttag != MAKEID('c', 'o', '6', '4') &&\n\t\t\t\t\tqttag != MAKEID('h', 'd', 'l', 'r'))\n\t\t\t\t{\n\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n\n\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t\tif (qttag == MAKEID('m', 'v', 'h', 'd')) //mvhd  movie header\n\t\t\t\t\t{\n\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\tlen += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);\n\t\t\t\t\t\tlen += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);\n\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('m', 'd', 'h', 'd')) //mdhd  media header\n\t\t\t\t\t{\n\t\t\t\t\t\tmedia_header md;\n\t\t\t\t\t\tlen = fread(&md, 1, sizeof(md), mp4->mediafp);\n\t\t\t\t\t\tif (len == sizeof(md))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmd.creation_time = BYTESWAP32(md.creation_time);\n\t\t\t\t\t\t\tmd.modification_time = BYTESWAP32(md.modification_time);\n\t\t\t\t\t\t\tmd.time_scale = BYTESWAP32(md.time_scale);\n\t\t\t\t\t\t\tmd.duration = BYTESWAP32(md.duration);\n\n\t\t\t\t\t\t\tmp4->trak_clockdemon = md.time_scale;\n\t\t\t\t\t\t\tmp4->trak_clockcount = md.duration;\n\n\t\t\t\t\t\t\tif (mp4->videolength == 0.0) // Get the video length from the first track\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('h', 'd', 'l', 'r')) //hldr\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t temp;\n\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\tlen += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.\n\n\t\t\t\t\t\tif (temp != MAKEID('a', 'l', 'i', 's'))\n\t\t\t\t\t\t\ttype = temp;\n\n\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('s', 't', 's', 'd')) //read the sample decription to determine the type of metadata\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type == traktype) //like meta\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&subtype, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.\n\t\t\t\t\t\t\tif (len == 16)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (subtype != traksubtype) // MP4 metadata \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttype = 0; // MP4\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('s', 't', 's', 'c')) // metadata stsc - offset chunks\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type == traktype) // meta\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n\n\t\t\t\t\t\t\tnum = BYTESWAP32(num);\n\t\t\t\t\t\t\tif (num * 12 <= qtsize - 8 - len)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmp4->metastsc_count = num;\n\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n\t\t\t\t\t\t\t\tmp4->metastsc = (SampleToChunk *)malloc(num * 12);\n\t\t\t\t\t\t\t\tif (mp4->metastsc)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32_t total_stsc = num;\n\t\t\t\t\t\t\t\t\tlen += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);\n\n\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);\n\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);\n\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);\n\t\t\t\t\t\t\t\t\t} while (num > 0);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('s', 't', 's', 'z')) // metadata stsz - sizes\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type == traktype) // meta\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint32_t equalsamplesize;\n\n\t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&equalsamplesize, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n\n\t\t\t\t\t\t\tnum = BYTESWAP32(num);\n\t\t\t\t\t\t\tif (num * 4 <= qtsize - 8 - len)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmp4->metasize_count = num;\n\t\t\t\t\t\t\t\tif (mp4->metasizes) free(mp4->metasizes);\n\t\t\t\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(num * 4);\n\t\t\t\t\t\t\t\tif (mp4->metasizes)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (equalsamplesize == 0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);\n\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);\n\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tequalsamplesize = BYTESWAP32(equalsamplesize);\n\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = equalsamplesize;\n\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('s', 't', 'c', 'o')) // metadata stco - offsets\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type == traktype) // meta\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tnum = BYTESWAP32(num);\n\t\t\t\t\t\t\tif (num * 4 <= qtsize - 8 - len)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmp4->indexcount = mp4->metasize_count;\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n\t\t\t\t\t\t\t\t\t\t\tint repeat = 1;\n\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n\t\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);\n\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\n\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];\n\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++; stsc_pos++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];\n\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse if (repeat == mp4->metastsc[stsc_pos].samples)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];\n\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\trepeat++;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t//printf(\"%3d:%08x, delta = %08x\\n\", num, (int)fileoffset, delta);\n\n\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n\n\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmp4->indexcount = num;\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tsize_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n\t\t\t\t\t\t\t\t\t\t\tlen += readlen;\n\t\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);\n\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\n\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\n\t\t\t\t\telse if (qttag == MAKEID('c', 'o', '6', '4')) // metadata stco - offsets\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type == traktype) // meta\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tnum = BYTESWAP32(num);\n\t\t\t\t\t\t\tif (num * 8 <= qtsize - 8 - len)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmp4->indexcount = mp4->metasize_count;\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tuint64_t *metaoffsets64 = NULL;\n\t\t\t\t\t\t\t\t\t\tmetaoffsets64 = (uint64_t *)malloc(num * 8);\n\t\t\t\t\t\t\t\t\t\tif (metaoffsets64)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets64, 1, num * 8, mp4->mediafp);\n\t\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);\n\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\n\t\t\t\t\t\t\t\t\t\t\tfileoffset = metaoffsets64[0];\n\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset;\n\t\t\t\t\t\t\t\t\t\t\t//printf(\"%3d:%08x, delta = %08x\\n\", 0, (int)fileoffset, 0);\n\n\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets64[stco_pos];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t//printf(\"%3d:%08x, delta = %08x\\n\", num, (int)fileoffset, delta);\n\n\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n\n\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets64);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmp4->indexcount = num;\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);\n\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);\n\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('s', 't', 't', 's')) // time to samples\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type == traktype) // meta \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint32_t totaldur = 0, samples = 0;\n\t\t\t\t\t\t\tint32_t entries = 0;\n\t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tnum = BYTESWAP32(num);\n\t\t\t\t\t\t\tif (num * 8 <= qtsize - 8 - len)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tentries = num;\n\n\t\t\t\t\t\t\t\tmp4->meta_clockdemon = mp4->trak_clockdemon;\n\t\t\t\t\t\t\t\tmp4->meta_clockcount = mp4->trak_clockcount;\n\n\t\t\t\t\t\t\t\twhile (entries > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint32_t samplecount;\n\t\t\t\t\t\t\t\t\tint32_t duration;\n\t\t\t\t\t\t\t\t\tlen += fread(&samplecount, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\t\t\tsamplecount = BYTESWAP32(samplecount);\n\t\t\t\t\t\t\t\t\tlen += fread(&duration, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\t\t\tduration = BYTESWAP32(duration);\n\n\t\t\t\t\t\t\t\t\tsamples += samplecount;\n\t\t\t\t\t\t\t\t\tentries--;\n\n\t\t\t\t\t\t\t\t\ttotaldur += duration;\n\t\t\t\t\t\t\t\t\tmp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tNESTSIZE(8);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (len > 0);\n\t}\n\telse\n\t{\n\t\t//\tprintf(\"Could not open %s for input\\n\", filename);\n\t\t//\texit(1);\n\n\t\tfree(mp4);\n\t\tmp4 = NULL;\n\t}\n\n\treturn (size_t)mp4;\n}\n\n\nfloat GetDuration(size_t handle)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return 0.0;\n\n\treturn (float)mp4->metadatalength;\n}\n\n\nvoid CloseSource(size_t handle)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return;\n\n\tif (mp4->mediafp) fclose(mp4->mediafp), mp4->mediafp = NULL;\n\tif (mp4->metasizes) free(mp4->metasizes), mp4->metasizes = 0;\n\tif (mp4->metaoffsets) free(mp4->metaoffsets), mp4->metaoffsets = 0;\n\n\tfree(mp4);\n}\n\n\nuint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return 0;\n\n\tif (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;\n\n\t*in = (float)((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n\t*out = (float)((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n\treturn 0;\n}\n\n\n\n\nsize_t OpenMP4SourceUDTA(char *filename)\n{\n\tmp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));\n\tif (mp4 == NULL) return 0;\n\n\tmemset(mp4, 0, sizeof(mp4object));\n\n#ifdef _WINDOWS\n\tfopen_s(&mp4->mediafp, filename, \"rb\");\n#else\n\tmp4->mediafp = fopen(filename, \"rb\");\n#endif\n\n\tif (mp4->mediafp)\n\t{\n\t\tuint32_t qttag, qtsize32, len;\n\t\tint32_t nest = 0;\n\t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\n\t\tuint64_t lastsize = 0, qtsize;\n\n\t\tdo\n\t\t{\n\t\t\tlen = fread(&qtsize32, 1, 4, mp4->mediafp);\n\t\t\tlen += fread(&qttag, 1, 4, mp4->mediafp);\n\t\t\tif (len == 8)\n\t\t\t{\n\t\t\t\tif (!GPMF_VALID_FOURCC(qttag))\n\t\t\t\t{\n\t\t\t\t\tLONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);\n\n\t\t\t\t\tNESTSIZE(lastsize - 8);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tqtsize32 = BYTESWAP32(qtsize32);\n\n\t\t\t\tif (qtsize32 == 1) // 64-bit Atom\n\t\t\t\t{\n\t\t\t\t\tfread(&qtsize, 1, 8, mp4->mediafp);\n\t\t\t\t\tqtsize = BYTESWAP64(qtsize) - 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tqtsize = qtsize32;\n\n\t\t\t\tnest++;\n\n\t\t\t\tif (qtsize < 8) break;\n\t\t\t\tif (nest >= MAX_NEST_LEVEL) break;\n\n\t\t\t\tnestsize[nest] = qtsize;\n\t\t\t\tlastsize = qtsize;\n\n\t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||\n\t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p'))\n\t\t\t\t{\n\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (qttag == MAKEID('G', 'P', 'M', 'F'))\n\t\t\t\t{\n\t\t\t\t\tmp4->videolength += 1.0;\n\t\t\t\t\tmp4->metadatalength += 1.0;\n\n\t\t\t\t\tmp4->indexcount = (int)mp4->metadatalength;\n\n\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(mp4->indexcount * 4 + 4);  memset(mp4->metasizes, 0, mp4->indexcount * 4 + 4);\n\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->indexcount * 8 + 8);  memset(mp4->metaoffsets, 0, mp4->indexcount * 8 + 8);\n\n\t\t\t\t\tmp4->metasizes[0] = (int)qtsize - 8;\n\t\t\t\t\tmp4->metaoffsets[0] = ftell(mp4->mediafp);\n\t\t\t\t\tmp4->metasize_count = 1;\n\n\t\t\t\t\treturn (size_t)mp4;  // not an MP4, RAW GPMF which has not inherent timing, assigning a during of 1second.\n\t\t\t\t}\n\t\t\t\tif (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms\n\t\t\t\t\tqttag != MAKEID('u', 'd', 't', 'a'))\n\t\t\t\t{\n\t\t\t\t\tLONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);\n\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNESTSIZE(8);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (len > 0);\n\t}\n\treturn (size_t)mp4;\n}\n\n\ndouble GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return 0.0;\n\n\tGPMF_stream metadata_stream, *ms = &metadata_stream;\n\tuint32_t teststart = 0;\n\tuint32_t testend = mp4->indexcount;\n\tdouble rate = 0.0;\n\n\tif (mp4->indexcount < 1)\n\t\treturn 0.0;\n\n\tif (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies. \n\t{\n\t\tteststart++;\n\t\ttestend--;\n\t}\n\n\tuint32_t *payload = GetPayload(handle, NULL, teststart); // second payload\n\tuint32_t payloadsize = GetPayloadSize(handle, teststart);\n\tint32_t ret = GPMF_Init(ms, payload, payloadsize);\n\n\tif (ret != GPMF_OK)\n\t\tgoto cleanup;\n\n\t{\n\t\tuint32_t startsamples = 0;\n\t\tuint32_t endsamples = 0;\n\t\tuint32_t missing_samples = 0;\n\n\t\twhile (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n\t\t{\n\t\t\tmissing_samples = 1;\n\t\t\tteststart++;\n\t\t\tpayload = GetPayload(handle, payload, teststart); // second last payload\n\t\t\tpayloadsize = GetPayloadSize(handle, teststart);\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t}\n\n\t\tif (missing_samples)\n\t\t{\n\t\t\tteststart++;   //samples after sensor start are statistically the best\n\t\t\tpayload = GetPayload(handle, payload, teststart);\n\t\t\tpayloadsize = GetPayloadSize(handle, teststart);\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t}\n\n\t\tif (ret == GPMF_OK)\n\t\t{\n\t\t\tuint32_t samples = GPMF_Repeat(ms);\n\t\t\tGPMF_stream find_stream;\n\t\t\tGPMF_CopyState(ms, &find_stream);\n\n\t\t\tif (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n\t\t\t{\n\t\t\t\tstartsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;\n\n\t\t\t\tpayload = GetPayload(handle, payload, testend); // second last payload\n\t\t\t\tpayloadsize = GetPayloadSize(handle, testend);\n\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\t\tif (ret != GPMF_OK)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n\t\t\t\t{\n\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n\t\t\t\t\t{\n\t\t\t\t\t\tendsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n\t\t\t\t\t\trate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n\t\t\t}\n\t\t\telse // for increased precision, for older GPMF streams sometimes missing the total sample count \n\t\t\t{\n\t\t\t\tuint32_t payloadpos = 0, payloadcount = 0;\n\t\t\t\tdouble slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;\n\t\t\t\tuint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);\n\t\t\t\tmemset(repeatarray, 0, mp4->indexcount * 4 + 4);\n\n\t\t\t\tsamples = 0;\n\n\t\t\t\tfor (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)\n\t\t\t\t{\n\t\t\t\t\tpayload = GetPayload(handle, payload, payloadpos); // second last payload\n\t\t\t\t\tpayloadsize = GetPayloadSize(handle, payloadpos);\n\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\n\t\t\t\t\tif (ret != GPMF_OK)\n\t\t\t\t\t\tgoto cleanup;\n\n\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n\t\t\t\t\t{\n\t\t\t\t\t\tGPMF_stream find_stream2;\n\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream2);\n\n\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (repeatarray)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfloat in, out;\n\n\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tsamples++;\n\t\t\t\t\t\t\t\t} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));\n\n\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n\t\t\t\t\t\t\t\tmeanY += (double)samples;\n\n\t\t\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n\t\t\t\t\t\t\t\tmeanX += out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint32_t repeat = GPMF_Repeat(ms);\n\t\t\t\t\t\t\tsamples += repeat;\n\n\t\t\t\t\t\t\tif (repeatarray)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfloat in, out;\n\n\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n\t\t\t\t\t\t\t\tmeanY += (double)samples;\n\n\t\t\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n\t\t\t\t\t\t\t\tmeanX += out;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Compute the line of best fit for a jitter removed sample rate.  \n\t\t\t\t// This does assume an unchanging clock, even though the IMU data can thermally impacted causing small clock changes.  \n\t\t\t\t// TODO: Next enhancement would be a low order polynominal fit the compensate for any thermal clock drift.\n\t\t\t\tif (repeatarray)\n\t\t\t\t{\n\t\t\t\t\tmeanY /= (double)payloadcount;\n\t\t\t\t\tmeanX /= (double)payloadcount;\n\n\t\t\t\t\tfor (payloadpos = teststart; payloadpos < testend; payloadpos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat in, out;\n\t\t\t\t\t\tGetPayloadTime(handle, payloadpos, &in, &out);\n\n\t\t\t\t\t\ttop += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);\n\t\t\t\t\t\tbot += ((double)out - meanX)*((double)out - meanX);\n\t\t\t\t\t}\n\n\t\t\t\t\tslope = top / bot;\n\n#if 0\n\t\t\t\t\t// This sample code might be useful for compare data latency between channels.\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble intercept;\n\t\t\t\t\t\tintercept = meanY - slope*meanX;\n\t\t\t\t\t\tprintf(\"%c%c%c%c start offset = %f (%.3fms)\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);\n\t\t\t\t\t}\n#endif\n\t\t\t\t\trate = slope;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n\t\t\t\t}\n\n\t\t\t\tfree(repeatarray);\n\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tif (payload) \n\t{\n\t\tFreePayload(payload);\n\t\tpayload = NULL;\n\t}\n\n\treturn rate;\n}\n\n\ndouble GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return 0.0;\n\n\tuint32_t key, insamples;\n\tuint32_t repeat, outsamples;\n\tGPMF_stream find_stream;\n\n\tif (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;\n\n\tkey = GPMF_Key(gs);\n\trepeat = GPMF_Repeat(gs);\n\tif (rate == 0.0)\n\t\trate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);\n\n\tif (rate == 0.0)\n\t{\n\t\t*in = *out = 0.0;\n\t\treturn 0.0;\n\t}\n\n\tGPMF_CopyState(gs, &find_stream);\n\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n\t{\n\t\toutsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n\t\tinsamples = outsamples - repeat;\n\n\t\t*in = ((double)insamples / (double)rate);\n\t\t*out = ((double)outsamples / (double)rate);\n\t}\n\telse\n\t{\n\t\t// might too costly in some applications read all the samples to determine the clock jitter, here I return the estimate from the MP4 track.\n\t\t*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n\t\t*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n\t}\n\treturn rate;\n}\n", "/*! @file mp4reader.h\n*\n*  @brief Way Too Crude MP4|MOV reader\n*\n*  @version 1.2.0\n*\n*  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n*\n*  Licensed under the Apache License, Version 2.0 (the \"License\");\n*  you may not use this file except in compliance with the License.\n*  You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n*  Unless required by applicable law or agreed to in writing, software\n*  distributed under the License is distributed on an \"AS IS\" BASIS,\n*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n*  See the License for the specific language governing permissions and\n*  limitations under the License.\n*\n*/\n\n#ifndef _GPMF_MP4READER_H\n#define _GPMF_MP4READER_H\n\n#include \"../GPMF_parser.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct media_header\n{\n\tuint8_t version_flags[4];\n\tuint32_t creation_time;\n\tuint32_t modification_time;\n\tuint32_t time_scale;\n\tuint32_t duration;\n\tuint16_t language;\n\tuint16_t quality;\n} media_header;\n\n\ntypedef struct SampleToChunk\n{\n\tuint32_t chunk_num;\n\tuint32_t samples;\n\tuint32_t id;\n} SampleToChunk;\n\n\ntypedef struct mp4object\n{\n\tuint32_t *metasizes;\n\tuint32_t metasize_count;\n\tuint64_t *metaoffsets;\n\tSampleToChunk *metastsc;\n\tuint32_t metastsc_count;\n\tuint32_t indexcount;\n\tdouble videolength;\n\tdouble metadatalength;\n\tuint32_t clockdemon, clockcount;\n\tuint32_t trak_clockdemon, trak_clockcount;\n\tuint32_t meta_clockdemon, meta_clockcount;\n\tdouble basemetadataduration;\n\tFILE *mediafp;\n} mp4object;\n\n#define MAKEID(a,b,c,d)\t\t\t(((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))\n#define STR2FOURCC(s)\t\t\t((s[0]<<0)|(s[1]<<8)|(s[2]<<16)|(s[3]<<24))\n\n#define BYTESWAP64(a)\t\t\t(((a&0xff)<<56)|((a&0xff00)<<40)|((a&0xff0000)<<24)|((a&0xff000000)<<8) | ((a>>56)&0xff)|((a>>40)&0xff00)|((a>>24)&0xff0000)|((a>>8)&0xff000000) )\n#define BYTESWAP32(a)\t\t\t(((a&0xff)<<24)|((a&0xff00)<<8)|((a>>8)&0xff00)|((a>>24)&0xff))\n#define BYTESWAP16(a)\t\t\t((((a)>>8)&0xff)|(((a)<<8)&0xff00))\n#define NOSWAP8(a)\t\t\t\t(a)\n\n\n\n\n#define MOV_GPMF_TRAK_TYPE\t\tMAKEID('m', 'e', 't', 'a')\t\t// track is the type for metadata\n#define MOV_GPMF_TRAK_SUBTYPE\tMAKEID('g', 'p', 'm', 'd')\t\t// subtype is GPMF\n#define MOV_VIDE_TRAK_TYPE\t\tMAKEID('v', 'i', 'd', 'e')\t\t// MP4 track for video\n#define MOV_SOUN_TRAK_TYPE\t\tMAKEID('s', 'o', 'u', 'n')\t\t// MP4 track for audio\n#define MOV_AVC1_SUBTYPE\t\tMAKEID('a', 'v', 'c', '1')\t\t// subtype H264\n#define MOV_HVC1_SUBTYPE\t\tMAKEID('h', 'v', 'c', '1')\t\t// subtype H265\n#define MOV_MP4A_SUBTYPE\t\tMAKEID('m', 'p', '4', 'a')\t\t// subtype for audio\n#define MOV_CFHD_SUBTYPE\t\tMAKEID('C', 'F', 'H', 'D')\t\t// subtype is CineForm HD\n#define AVI_VIDS_TRAK_TYPE\t\tMAKEID('v', 'i', 'd', 's')\t\t// track is the type for video\n#define AVI_CFHD_SUBTYPE\t\tMAKEID('c', 'f', 'h', 'd')\t\t// subtype is CineForm HD\n\n#define NESTSIZE(x) { int i = nest; while (i > 0 && nestsize[i] > 0) { nestsize[i] -= x; if(nestsize[i]>=0 && nestsize[i] <= 8) { nestsize[i]=0; nest--; } i--; } }\n\n#define VALID_FOURCC(a)\t(((((a>>24)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>24)&0xff)>='A'&&((a>>24)&0xff)<='Z') || (((a>>24)&0xff)>='0'&&((a>>24)&0xff)<='9') || (((a>>24)&0xff)==' ') ) && \\\n\t\t\t\t\t\t( (((a>>16)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>16)&0xff)>='A'&&((a>>16)&0xff)<='Z') || (((a>>16)&0xff)>='0'&&((a>>16)&0xff)<='9') || (((a>>16)&0xff)==' ') ) && \\\n\t\t\t\t\t\t( (((a>>8)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>8)&0xff)>='A'&&((a>>8)&0xff)<='Z') || (((a>>8)&0xff)>='0'&&((a>>8)&0xff)<='9') || (((a>>8)&0xff)==' ') ) && \\\n\t\t\t\t\t\t( (((a>>0)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>0)&0xff)>='A'&&((a>>0)&0xff)<='Z') || (((a>>0)&0xff)>='0'&&((a>>0)&0xff)<='9') || (((a>>0)&0xff)==' ') )) \n\nsize_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t subtype);\nsize_t OpenMP4SourceUDTA(char *filename);\nvoid CloseSource(size_t handle);\nfloat GetDuration(size_t handle);\nuint32_t GetNumberPayloads(size_t handle);\nuint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index);\nvoid SavePayload(size_t handle, uint32_t *payload, uint32_t index);\nvoid FreePayload(uint32_t *lastpayload);\nuint32_t GetPayloadSize(size_t handle, uint32_t index);\nuint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out); //MP4 timestamps for the payload\n\n#define GPMF_SAMPLE_RATE_FAST\t\t0\n#define GPMF_SAMPLE_RATE_PRECISE\t1\n\ndouble GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags);\ndouble GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double lastrate, uint32_t index, double *in, double *out); //Jitter corrected sample(s) time, if lastrate is unknown, send 0.0 and it will be computed\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"], "fixing_code": ["/*! @file GPMF_parser.c\n * \n *  @brief GPMF Parser library\n *\n *  @version 1.2.2\n * \n *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n *\t\n *  Licensed under either:\n *  - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0  \n *  - MIT license, http://opensource.org/licenses/MIT\n *  at your option.\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n * \n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n#include \"GPMF_parser.h\"\n\n\n#ifdef DBG\n#if _WINDOWS\n#define DBG_MSG printf\n#else\n#define DBG_MSG(...)\n#endif\n#else\n#define DBG_MSG(...)\n#endif\n\n\nGPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not bytes.\n{\n\tif (ms)\n\t{\n\t\tuint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];\n\t\tif (nestsize == 0 && ms->nest_level == 0)\n\t\t\tnestsize = ms->buffer_size_longs;\n\n\t\tif (size + 2 <= nestsize) return GPMF_OK;\n\t}\n\treturn GPMF_ERROR_BAD_STRUCTURE;\n}\n\n\nGPMF_ERR GPMF_Validate(GPMF_stream *ms, GPMF_LEVELS recurse)\n{\n\tif (ms)\n\t{\n\t\tuint32_t currpos = ms->pos;\n\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n\t\tif (nestsize == 0 && ms->nest_level == 0)\n\t\t\tnestsize = ms->buffer_size_longs;\n\t\t\n\t\twhile (ms->pos+1 < ms->buffer_size_longs && nestsize > 0)\n\t\t{\n\t\t\tuint32_t key = ms->buffer[ms->pos];\n\n\t\t\tif (ms->nest_level == 0 && key != GPMF_KEY_DEVICE && ms->device_count == 0 && ms->pos == 0)\n\t\t\t{\n\t\t\t\tDBG_MSG(\"ERROR: uninitized -- GPMF_ERROR_BAD_STRUCTURE\\n\");\n\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t}\n\n\t\t\tif (GPMF_VALID_FOURCC(key))\n\t\t\t{\n\t\t\t\tuint32_t type_size_repeat = ms->buffer[ms->pos + 1];\n\t\t\t\tint32_t size = GPMF_DATA_SIZE(type_size_repeat) >> 2;\n\t\t\t\tuint8_t type = GPMF_SAMPLE_TYPE(type_size_repeat);\n\t\t\t\tif (size + 2 > nestsize)\n\t\t\t\t{\n\t\t\t\t\tDBG_MSG(\"ERROR: nest size too small within %c%c%c%c-- GPMF_ERROR_BAD_STRUCTURE\\n\", PRINTF_4CC(key));\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t}\n\n\t\t\t\tif (!GPMF_VALID_FOURCC(key))\n\t\t\t\t{\n\t\t\t\t\tDBG_MSG(\"ERROR: invalid 4CC -- GPMF_ERROR_BAD_STRUCTURE\\n\");\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t}\n\n\t\t\t\tif (type == GPMF_TYPE_NEST && recurse == GPMF_RECURSE_LEVELS)\n\t\t\t\t{\n\t\t\t\t\tuint32_t validnest;\n\t\t\t\t\tms->pos += 2;\n\t\t\t\t\tms->nest_level++;\n\t\t\t\t\tif (ms->nest_level > GPMF_NEST_LIMIT)\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_MSG(\"ERROR: nest level within %c%c%c%c too deep -- GPMF_ERROR_BAD_STRUCTURE\\n\", PRINTF_4CC(key));\n\t\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t\t}\n\t\t\t\t\tms->nest_size[ms->nest_level] = size;\n\t\t\t\t\tvalidnest = GPMF_Validate(ms, recurse);\n\t\t\t\t\tms->nest_level--;\n\t\t\t\t\tif (GPMF_OK != validnest)\n\t\t\t\t\t{\n\t\t\t\t\t\tDBG_MSG(\"ERROR: invalid nest within %c%c%c%c -- GPMF_ERROR_BAD_STRUCTURE\\n\", PRINTF_4CC(key));\n\t\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ms->nest_level == 0)\n\t\t\t\t\t\t\tms->device_count++;\n\t\t\t\t\t}\n\n\t\t\t\t\tms->pos += size;\n\t\t\t\t\tnestsize -= 2 + size;\n\n\t\t\t\t\twhile (ms->pos < ms->buffer_size_longs && nestsize > 0 && ms->buffer[ms->pos] == GPMF_KEY_END)\n\t\t\t\t\t{\n\t\t\t\t\t\tms->pos++;\n\t\t\t\t\t\tnestsize--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tms->pos += 2 + size;\n\t\t\t\t\tnestsize -= 2 + size;\n\t\t\t\t}\n\n\t\t\t\tif (ms->pos == ms->buffer_size_longs)\n\t\t\t\t{\n\t\t\t\t\tms->pos = currpos;\n\t\t\t\t\treturn GPMF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (key == GPMF_KEY_END)\n\t\t\t\t{\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tms->pos++;\n\t\t\t\t\t\tnestsize--;\n\t\t\t\t\t} while (ms->pos < ms->buffer_size_longs && nestsize > 0 && ms->buffer[ms->pos] == 0);\n\t\t\t\t}\n\t\t\t\telse if (ms->nest_level == 0 && ms->device_count > 0)\n\t\t\t\t{\n\t\t\t\t\tms->pos = currpos;\n\t\t\t\t\treturn GPMF_OK;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDBG_MSG(\"ERROR: bad struct within %c%c%c%c -- GPMF_ERROR_BAD_STRUCTURE\\n\", PRINTF_4CC(key));\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tms->pos = currpos;\n\t\treturn GPMF_OK;\n\t}\n\telse\n\t{\n\t\tDBG_MSG(\"ERROR: Invalid handle -- GPMF_ERROR_MEMORY\\n\");\n\t\treturn GPMF_ERROR_MEMORY;\n\t}\n}\n\n\nGPMF_ERR GPMF_ResetState(GPMF_stream *ms)\n{\n\tif (ms)\n\t{\n\t\tms->pos = 0;\n\t\tms->nest_level = 0;\n\t\tms->device_count = 0;\n\t\tms->nest_size[ms->nest_level] = 0;\n\t\tms->last_level_pos[ms->nest_level] = 0;\n\t\tms->last_seek[ms->nest_level] = 0;\n\t\tms->device_id = 0;\n\t\tms->device_name[0] = 0;\n\n\t\treturn GPMF_OK;\n\t}\n\t\n\treturn GPMF_ERROR_MEMORY;\n}\n\n\nGPMF_ERR GPMF_Init(GPMF_stream *ms, uint32_t *buffer, int datasize)\n{\n\tif(ms)\n\t{\n\t\tms->buffer = buffer;\n\t\tms->buffer_size_longs = datasize >>2;\n\n\t\tGPMF_ResetState(ms);\n\n\t\treturn GPMF_OK;\n\t}\n\t\n\treturn GPMF_ERROR_MEMORY;\n}\n\n\nGPMF_ERR GPMF_CopyState(GPMF_stream *msrc, GPMF_stream *mdst)\n{\n\tif (msrc && mdst)\n\t{\n\t\tmemcpy(mdst, msrc, sizeof(GPMF_stream));\n\t\treturn GPMF_OK;\n\t}\n\treturn GPMF_ERROR_MEMORY;\n}\n\n\nGPMF_ERR GPMF_Next(GPMF_stream *ms, GPMF_LEVELS recurse)\n{\n\tif (ms)\n\t{\n\t\tif (ms->pos+1 < ms->buffer_size_longs)\n\t\t{\n\n\t\t\tuint32_t key, type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\t\t\tuint32_t size = (GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]) >> 2);\n\n\t\t\tif (GPMF_OK != IsValidSize(ms, size)) return GPMF_ERROR_BAD_STRUCTURE;\n\n\t\t\tif (GPMF_TYPE_NEST == type && GPMF_KEY_DEVICE == ms->buffer[ms->pos] && ms->nest_level == 0)\n\t\t\t{\n\t\t\t\tms->last_level_pos[ms->nest_level] = ms->pos;\n\t\t\t\tms->nest_size[ms->nest_level] = size;\n\t\t\t\tif (recurse)\n\t\t\t\t\tms->pos += 2;\n\t\t\t\telse\n\t\t\t\t\tms->pos += 2 + size;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (size + 2 > ms->nest_size[ms->nest_level])\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\n\t\t\t\tif (recurse && type == GPMF_TYPE_NEST)\n\t\t\t\t{\n\t\t\t\t\tms->last_level_pos[ms->nest_level] = ms->pos;\n\t\t\t\t\tms->pos += 2;\n\t\t\t\t\tms->nest_size[ms->nest_level] -= size + 2;\n\n\t\t\t\t\tms->nest_level++;\n\t\t\t\t\tif (ms->nest_level > GPMF_NEST_LIMIT)\n\t\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\n\t\t\t\t\tms->nest_size[ms->nest_level] = size;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (recurse)\n\t\t\t\t\t{\n\t\t\t\t\t\tms->pos += size + 2;\n\t\t\t\t\t\tms->nest_size[ms->nest_level] -= size + 2;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ms->nest_size[ms->nest_level] - (size + 2) > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tms->pos += size + 2;\n\t\t\t\t\t\t\tms->nest_size[ms->nest_level] -= size + 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn GPMF_ERROR_LAST;   \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n\n\t\t\twhile (ms->pos < ms->buffer_size_longs && ms->nest_size[ms->nest_level] > 0 && ms->buffer[ms->pos] == GPMF_KEY_END)\n\t\t\t{\n\t\t\t\tms->pos++;\n\t\t\t\tms->nest_size[ms->nest_level]--;\n\t\t\t}\n\n\t\t\twhile (ms->nest_level > 0 && ms->nest_size[ms->nest_level] == 0)\n\t\t\t{\n\t\t\t\tms->nest_level--;\n\t\t\t\t//if (ms->nest_level == 0)\n\t\t\t\t//{\n\t\t\t\t//\tms->device_count++;\n\t\t\t\t//}\n\t\t\t}\n\n\t\t\tif (ms->pos < ms->buffer_size_longs)\n\t\t\t{\n\t\t\t\twhile (ms->pos < ms->buffer_size_longs && ms->nest_size[ms->nest_level] > 0 && ms->buffer[ms->pos] == GPMF_KEY_END)\n\t\t\t\t{\n\t\t\t\t\tms->pos++;\n\t\t\t\t\tms->nest_size[ms->nest_level]--;\n\t\t\t\t}\n\n\t\t\t\tkey = ms->buffer[ms->pos];\n\t\t\t\tif (!GPMF_VALID_FOURCC(key))\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\n\t\t\t\tif (key == GPMF_KEY_DEVICE_ID)\n\t\t\t\t\tms->device_id = BYTESWAP32(ms->buffer[ms->pos + 2]);\n\t\t\t\tif (key == GPMF_KEY_DEVICE_NAME)\n\t\t\t\t{\n\t\t\t\t\tsize = GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]); // in bytes\n\t\t\t\t\tif (size > sizeof(ms->device_name) - 1)\n\t\t\t\t\t\tsize = sizeof(ms->device_name) - 1;\n\t\t\t\t\tmemcpy(ms->device_name, &ms->buffer[ms->pos + 2], size);\n\t\t\t\t\tms->device_name[size] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// end of buffer\n\t\t\t\treturn GPMF_ERROR_BUFFER_END;\n\t\t\t}\n\n\t\t\treturn GPMF_OK;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// end of buffer\n\t\t\treturn GPMF_ERROR_BUFFER_END;\n\t\t}\n\t}\n\treturn GPMF_ERROR_MEMORY;\n}\n\n\n\nGPMF_ERR GPMF_FindNext(GPMF_stream *ms, uint32_t fourcc, GPMF_LEVELS recurse)\n{\n\tGPMF_stream prevstate;\n\n\tif (ms)\n\t{\n\t\tmemcpy(&prevstate, ms, sizeof(GPMF_stream));\n\n\t\tif (ms->pos < ms->buffer_size_longs)\n\t\t{\n\t\t\twhile (0 == GPMF_Next(ms, recurse))\n\t\t\t{\n\t\t\t\tif (ms->buffer[ms->pos] == fourcc)\n\t\t\t\t{\n\t\t\t\t\treturn GPMF_OK; //found match\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// restore read position\n\t\t\tmemcpy(ms, &prevstate, sizeof(GPMF_stream));\n\t\t\treturn GPMF_ERROR_FIND;\n\t\t}\n\t}\n\treturn GPMF_ERROR_FIND;\n}\n\nGPMF_ERR GPMF_Reserved(uint32_t key)\n{\n\tif(key == GPMF_KEY_DEVICE)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_DEVICE_ID)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_DEVICE_NAME)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_STREAM)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_STREAM_NAME)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_SI_UNITS)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_UNITS)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_SCALE)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_TYPE)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_TOTAL_SAMPLES)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_TICK)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_TOCK)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_EMPTY_PAYLOADS)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\tif(key == GPMF_KEY_REMARK)\n\t\treturn GPMF_ERROR_RESERVED;\n\n\treturn GPMF_OK;\n}\n\nuint32_t GPMF_PayloadSampleCount(GPMF_stream *ms)\n{\n\tuint32_t count = 0;\n\tif (ms)\n\t{\n\t\tuint32_t fourcc = GPMF_Key(ms);\n\n\t\tGPMF_stream find_stream;\n\t\tGPMF_CopyState(ms, &find_stream);\n\n\t\tif (GPMF_OK == GPMF_FindNext(&find_stream, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats\n\t\t{\n\t\t\tcount=2;\n\t\t\twhile (GPMF_OK == GPMF_FindNext(&find_stream, fourcc, GPMF_CURRENT_LEVEL))\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t} \n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount = GPMF_Repeat(ms);\n\t\t}\n\t}\n\treturn count;\n}\n\n\nGPMF_ERR GPMF_SeekToSamples(GPMF_stream *ms)\n{\n\tGPMF_stream prevstate;\n\n\tif (ms)\n\t{\n\n\t\tif (ms->pos+1 < ms->buffer_size_longs)\n\t\t{\n\t\t\tuint32_t type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\n\t\t\tmemcpy(&prevstate, ms, sizeof(GPMF_stream));\n\n\t\t\tif (type == GPMF_TYPE_NEST)\n\t\t\t\tGPMF_Next(ms, GPMF_RECURSE_LEVELS); // open STRM and recurse in\n\n\t\t\twhile (0 == GPMF_Next(ms, GPMF_CURRENT_LEVEL))\n\t\t\t{\n\t\t\t\tuint32_t size = (GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]) >> 2);\n\t\t\t\tif (GPMF_OK != IsValidSize(ms, size))\n\t\t\t\t{\n\t\t\t\t\tmemcpy(ms, &prevstate, sizeof(GPMF_stream));\n\t\t\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\t\t}\n\n\t\t\t\ttype = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\n\n\t\t\t\tif (type == GPMF_TYPE_NEST)  // Nest with-in nest\n\t\t\t\t{\n\t\t\t\t\treturn GPMF_OK; //found match\n\t\t\t\t}\n\n\t\t\t\tif (size + 2 == ms->nest_size[ms->nest_level])\n\t\t\t\t{\n\t\t\t\t\tuint32_t key = GPMF_Key(ms);\n\n\t\t\t\t\tif (GPMF_ERROR_RESERVED == GPMF_Reserved(key))\n\t\t\t\t\t\treturn GPMF_ERROR_FIND;\n\t\t\t\t\t\n\t\t\t\t\treturn GPMF_OK; //found match\n\t\t\t\t}\n\n\t\t\t\tif (ms->buffer[ms->pos] == ms->buffer[ms->pos + size + 2]) // Matching tags\n\t\t\t\t{\n\t\t\t\t\treturn GPMF_OK; //found match\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// restore read position\n\t\t\tmemcpy(ms, &prevstate, sizeof(GPMF_stream));\n\t\t\treturn GPMF_ERROR_FIND;\n\t\t}\n\t}\n\treturn GPMF_ERROR_FIND;\n}\n\n\nGPMF_ERR GPMF_FindPrev(GPMF_stream *ms, uint32_t fourcc, GPMF_LEVELS recurse)\n{\n\tGPMF_stream prevstate;\n\n\tif (ms)\n\t{\n\t\tuint32_t curr_level = ms->nest_level;\n\n\t\tmemcpy(&prevstate, ms, sizeof(GPMF_stream));\n\n\t\tif (ms->pos < ms->buffer_size_longs && curr_level > 0)\n\t\t{\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tms->last_seek[curr_level] = ms->pos;\n\t\t\t\tms->pos = ms->last_level_pos[curr_level - 1] + 2;\n\t\t\t\tms->nest_size[curr_level] += ms->last_seek[curr_level] - ms->pos;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tif (ms->last_seek[curr_level] > ms->pos && ms->buffer[ms->pos] == fourcc)\n\t\t\t\t\t{\n\n\t\t\t\t\t\treturn GPMF_OK; //found match\n\t\t\t\t\t}\n\t\t\t\t} while (ms->last_seek[curr_level] > ms->pos && 0 == GPMF_Next(ms, GPMF_CURRENT_LEVEL));\n\n\t\t\t\tcurr_level--;\n\t\t\t} while (recurse == GPMF_RECURSE_LEVELS && curr_level > 0);\n\n\t\t\t// restore read position\n\t\t\tmemcpy(ms, &prevstate, sizeof(GPMF_stream));\n\n\t\t\treturn GPMF_ERROR_FIND;\n\t\t}\n\t}\n\n\treturn GPMF_ERROR_FIND;\n}\n\n\n\n\n\nuint32_t GPMF_Key(GPMF_stream *ms)\n{\n\tif (ms)\n\t{\n\t\tuint32_t key = ms->buffer[ms->pos];\n\t\treturn key;\n\t}\n\treturn 0;\n}\n\n\nuint32_t GPMF_Type(GPMF_stream *ms)\n{\n\tif (ms && ms->pos+1 < ms->buffer_size_longs)\n\t{\n\t\tuint32_t type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos+1]);\n\t\treturn type;\n\t}\n\treturn 0;\n}\n\n\nuint32_t GPMF_StructSize(GPMF_stream *ms)\n{\n\tif (ms && ms->pos+1 < ms->buffer_size_longs)\n\t{\n\t\tuint32_t ssize = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1]);\n\t\tuint32_t size = (GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]) >> 2);\n\n\t\tif (GPMF_OK != IsValidSize(ms, size)) return 0; // as the structure is corrupted. i.e. GPMF_ERROR_BAD_STRUCTURE;\n\n\t\treturn ssize;\n\t}\n\treturn 0;\n}\n\n\nuint32_t GPMF_ElementsInStruct(GPMF_stream *ms)\n{\n\tif (ms && ms->pos+1 < ms->buffer_size_longs)\n\t{\n\t\tuint32_t ssize = GPMF_StructSize(ms);\n\t\tGPMF_SampleType type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\n\t\tif (type != GPMF_TYPE_NEST && type != GPMF_TYPE_COMPLEX)\n\t\t{\n\t\t\tint32_t tsize = GPMF_SizeofType(type);\n\t\t\tif (tsize > 0)\n\t\t\t\treturn ssize / tsize;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tif (type == GPMF_TYPE_COMPLEX)\n\t\t{\n\t\t\tGPMF_stream find_stream;\n\t\t\tGPMF_CopyState(ms, &find_stream);\n\n\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_CURRENT_LEVEL))\n\t\t\t{\n\t\t\t\tchar tmp[64] = \"\";\n\t\t\t\tuint32_t tmpsize = sizeof(tmp);\n\t\t\t\tchar *data = (char *)GPMF_RawData(&find_stream);\n\t\t\t\tint size = GPMF_RawDataSize(&find_stream);\n\t\t\t\t\n\t\t\t\tif (GPMF_OK == GPMF_ExpandComplexTYPE(data, size, tmp, &tmpsize))\n\t\t\t\t\treturn tmpsize;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nuint32_t GPMF_Repeat(GPMF_stream *ms)\n{\n\tif (ms && ms->pos+1 < ms->buffer_size_longs)\n\t{\n\t\tuint32_t repeat = GPMF_SAMPLES(ms->buffer[ms->pos + 1]);\n\t\treturn repeat;\n\t}\n\treturn 0;\n}\n\nuint32_t GPMF_RawDataSize(GPMF_stream *ms)\n{\n\tif (ms && ms->pos+1 < ms->buffer_size_longs)\n\t{\n\t\tuint32_t size = GPMF_DATA_PACKEDSIZE(ms->buffer[ms->pos + 1]);\n\t\tif (GPMF_OK != IsValidSize(ms, size >> 2)) return 0;\n\n\t\treturn size;\n\t}\n\treturn 0;\n}\n\n\nuint32_t GPMF_NestLevel(GPMF_stream *ms)\n{\n\tif (ms)\n\t{\n\t\treturn ms->nest_level;\n\t}\n\treturn 0;\n}\n\nuint32_t GPMF_DeviceID(GPMF_stream *ms)\n{\n\tif (ms)\n\t{\n\t\treturn ms->device_id;\n\t}\n\treturn 0;\n}\n\nGPMF_ERR GPMF_DeviceName(GPMF_stream *ms, char *devicenamebuf, uint32_t devicename_buf_size)\n{\n\tif (ms && devicenamebuf)\n\t{\n\t\tuint32_t len = (uint32_t)strlen(ms->device_name);\n\t\tif (len >= devicename_buf_size)\n\t\t\treturn GPMF_ERROR_MEMORY;\n\n\t\tmemcpy(devicenamebuf, ms->device_name, len);\n\t\tdevicenamebuf[len] = 0;\n\t\treturn GPMF_OK;\n\t}\n\treturn GPMF_ERROR_MEMORY;\n}\n\n\nvoid *GPMF_RawData(GPMF_stream *ms)\n{\n\tif (ms)\n\t{\n\t\treturn (void *)&ms->buffer[ms->pos + 2];\n\t}\n\treturn NULL;\n}\n\n\n\n\nuint32_t GPMF_SizeofType(GPMF_SampleType type)\n{\n\tuint32_t ssize = 0;\n\n\tswitch ((int)type)\n\t{\n\tcase GPMF_TYPE_STRING_ASCII:\t\tssize = 1; break;\n\tcase GPMF_TYPE_SIGNED_BYTE:\t\t\tssize = 1; break;\n\tcase GPMF_TYPE_UNSIGNED_BYTE:\t\tssize = 1; break;\n\n\t// These datatypes are always be stored in Big-Endian\n\tcase GPMF_TYPE_SIGNED_SHORT:\t\tssize = 2; break;\n\tcase GPMF_TYPE_UNSIGNED_SHORT:\t\tssize = 2; break;\n\tcase GPMF_TYPE_FLOAT:\t\t\t\tssize = 4; break;\n\tcase GPMF_TYPE_FOURCC:\t\t\t\tssize = 4; break;\n\tcase GPMF_TYPE_SIGNED_LONG:\t\t\tssize = 4; break;\n\tcase GPMF_TYPE_UNSIGNED_LONG:\t\tssize = 4; break;\n\tcase GPMF_TYPE_Q15_16_FIXED_POINT:  ssize = 4; break;\n\tcase GPMF_TYPE_Q31_32_FIXED_POINT:  ssize = 8; break;\n\tcase GPMF_TYPE_DOUBLE:\t\t\t\tssize = 8; break;\n\tcase GPMF_TYPE_SIGNED_64BIT_INT:\tssize = 8; break;\n\tcase GPMF_TYPE_UNSIGNED_64BIT_INT:  ssize = 8; break;\n\n\t//All unknown or larger than 8-bytes stored as is:\n\tcase GPMF_TYPE_GUID:\t\t\t\tssize = 16; break;\n\tcase GPMF_TYPE_UTC_DATE_TIME:\t\tssize = 16; break;\n\t}\n\n\treturn ssize;\n}\n\nuint32_t GPMF_ExpandComplexTYPE(char *src, uint32_t srcsize, char *dst, uint32_t *dstsize)\n{\n\tuint32_t i = 0, k = 0, count = 0;\n\n\twhile (i<srcsize && k<*dstsize)\n\t{\n\t\tif (src[i] == '[' && i>0)\n\t\t{\n\t\t\tint j = 1;\n\t\t\tcount = 0;\n\t\t\twhile (src[i + j] >= '0' && src[i + j] <= '9')\n\t\t\t{\n\t\t\t\tcount *= 10;\n\t\t\t\tcount += src[i + j] - '0';\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tif (count > 1)\n\t\t\t{\n\t\t\t\tuint32_t l;\n\t\t\t\tfor (l = 1; l<count; l++)\n\t\t\t\t{\n\t\t\t\t\tdst[k] = src[i - 1];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += j;\n\t\t\tif (src[i] == ']') i++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdst[k] = src[i];\n\t\t\tif (dst[k] == 0) break;\n\t\t\ti++, k++;\n\t\t}\n\t}\n\n\tif (k >= *dstsize)\n\t\treturn GPMF_ERROR_MEMORY; // bad structure formed\n\n\tdst[k] = 0;\n\t*dstsize = k;\n\n\treturn GPMF_OK;\n}\n\n\n\nuint32_t GPMF_SizeOfComplexTYPE(char *type, uint32_t typestringlength)\n{\n\tchar *typearray = type;\n\tuint32_t size = 0, expand = 0;\n\tuint32_t i, len = typestringlength;\n\n\n\tfor (i = 0; i < len; i++)\n\t\tif (typearray[i] == '[')\n\t\t\texpand = 1;\n\t\t\t\n\tif (expand)\n\t{\n\t\tchar exptypearray[64];\n\t\tuint32_t dstsize = sizeof(exptypearray);\n\n\t\tif (GPMF_OK == GPMF_ExpandComplexTYPE(typearray, len, exptypearray, &dstsize))\n\t\t{\n\t\t\ttypearray = exptypearray;\n\t\t\tlen = dstsize;\n\t\t}\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tuint32_t typesize = GPMF_SizeofType((GPMF_SampleType)typearray[i]);\n\n\t\tif (typesize < 1) return 0;\n\t\tsize += typesize;\n\t}\n\n\treturn size;\n}\n\n\nGPMF_ERR GPMF_FormattedData(GPMF_stream *ms, void *buffer, uint32_t buffersize, uint32_t sample_offset, uint32_t read_samples)\n{\n\tif (ms && buffer)\n\t{\n\t\tuint8_t *data = (uint8_t *)&ms->buffer[ms->pos + 2];\n\t\tuint8_t *output = (uint8_t *)buffer;\n\t\tuint32_t sample_size = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1]);\n\t\tuint32_t remaining_sample_size = GPMF_DATA_PACKEDSIZE(ms->buffer[ms->pos + 1]);\n\t\tuint8_t type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\t\tuint32_t typesize = 1;\n\t\tuint32_t elements = 0;\n\t\tuint32_t typestringlength = 1;\n\t\tchar complextype[64] = \"L\";\n\n\t\tif (type == GPMF_TYPE_NEST)\n\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\t\t\n\t\tif (GPMF_OK != IsValidSize(ms, remaining_sample_size>>2))\n\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\n\t\tif (sample_size * read_samples > buffersize)\n\t\t\treturn GPMF_ERROR_MEMORY;\n\n\t\tremaining_sample_size -= sample_offset * sample_size; // skip samples\n\t\tdata += sample_offset * sample_size;\n\n\t\tif (remaining_sample_size < sample_size * read_samples)\n\t\t\treturn GPMF_ERROR_MEMORY;\n\n\t\tif (type == GPMF_TYPE_COMPLEX)\n\t\t{\n\t\t\tGPMF_stream find_stream;\n\t\t\tGPMF_CopyState(ms, &find_stream);\n\n\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_RECURSE_LEVELS))\n\t\t\t{\n\t\t\t\tchar *data1 = (char *)GPMF_RawData(&find_stream);\n\t\t\t\tint size = GPMF_RawDataSize(&find_stream);\n\n\t\t\t\ttypestringlength = sizeof(complextype);\n\t\t\t\tif (GPMF_OK == GPMF_ExpandComplexTYPE(data1, size, complextype, &typestringlength))\n\t\t\t\t{\n\t\t\t\t\telements = (uint32_t)strlen(complextype);\n\n\t\t\t\t\tif (sample_size != GPMF_SizeOfComplexTYPE(complextype, typestringlength))\n\t\t\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypesize = GPMF_SizeofType((GPMF_SampleType)type);\n\n\t\t\tif (type == GPMF_TYPE_FOURCC)\n\t\t\t\ttypesize = 1; // Do not ByteSWAP\n\n\t\t\tif (typesize == 0)\n\t\t\t\treturn GPMF_ERROR_MEMORY;\n\n\t\t\telements = sample_size / typesize;\n\t\t}\n\n\t\twhile (read_samples--)\n\t\t{\n\t\t\tuint32_t i,j;\n\n\t\t\tfor (i = 0; i < elements; i++)\n\t\t\t{\n\t\t\t\tif (type == GPMF_TYPE_COMPLEX)\n\t\t\t\t{\n\t\t\t\t\tif (complextype[i] == GPMF_TYPE_FOURCC)\n\t\t\t\t\t{\n\t\t\t\t\t\t*output++ = *data++;\n\t\t\t\t\t\t*output++ = *data++;\n\t\t\t\t\t\t*output++ = *data++;\n\t\t\t\t\t\t*output++ = *data++;\n\t\t\t\t\t\ttypesize = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\ttypesize = GPMF_SizeofType(complextype[i]);\n\t\t\t\t}\n\n\t\t\t\tswitch (typesize)\n\t\t\t\t{\n\t\t\t\tcase 2:\n\t\t\t\t{\n\t\t\t\t\tuint16_t *data16 = (uint16_t *)data;\n\t\t\t\t\tuint16_t *output16 = (uint16_t *)output;\n\t\t\t\t\t*output16 = BYTESWAP16(*data16);\n\t\t\t\t\toutput16++;\n\t\t\t\t\tdata16++;\n\n\t\t\t\t\tdata = (uint8_t *)data16;\n\t\t\t\t\toutput = (uint8_t *)output16;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t{\n\t\t\t\t\tuint32_t *data32 = (uint32_t *)data;\n\t\t\t\t\tuint32_t *output32 = (uint32_t *)output;\n\t\t\t\t\t*output32 = BYTESWAP32(*data32);\n\t\t\t\t\toutput32++;\n\t\t\t\t\tdata32++;\n\n\t\t\t\t\tdata = (uint8_t *)data32;\n\t\t\t\t\toutput = (uint8_t *)output32;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t{\n\t\t\t\t\tuint32_t *data32 = (uint32_t *)data;\n\t\t\t\t\tuint32_t *output32 = (uint32_t *)output;\n\t\t\t\t\t*(output32+1) = BYTESWAP32(*data32);\n\t\t\t\t\t*(output32) = BYTESWAP32(*(data32+1));\n\t\t\t\t\tdata32 += 2;\n\t\t\t\t\toutput32 += 2;\n\n\t\t\t\t\tdata = (uint8_t *)data32;\n\t\t\t\t\toutput = (uint8_t *)output32;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tdefault: //1, 16 or more not byteswapped\n\t\t\t\t\tfor (j = 0; j < typesize; j++)\n\t\t\t\t\t\t*output++ = *data++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn GPMF_OK;\n\t}\n\n\treturn GPMF_ERROR_MEMORY;\n}\n\n\n#define MACRO_CAST_SCALE_UNSIGNED_TYPE(casttype)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcasttype *tmp = (casttype *)output;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tswitch (scaletype)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcase GPMF_TYPE_SIGNED_BYTE:\t\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((int8_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_UNSIGNED_BYTE:\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((uint8_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_SIGNED_SHORT:\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((int16_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_UNSIGNED_SHORT:\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((uint16_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_SIGNED_LONG:\t\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((int32_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_UNSIGNED_LONG:\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((uint32_t *)scaledata8);\tbreak;  \\\n\tcase GPMF_TYPE_FLOAT:\t\t\t*tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((float *)scaledata8);\tbreak;\t\\\n\tdefault: break;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\toutput = (uint8_t *)tmp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n\n#define MACRO_CAST_SCALE_SIGNED_TYPE(casttype)\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcasttype *tmp = (casttype *)output;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tswitch (scaletype)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcase GPMF_TYPE_SIGNED_BYTE:\t\t*tmp++ = (casttype)*val / (casttype)*((int8_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_UNSIGNED_BYTE:\t*tmp++ = (casttype)*val / (casttype)*((uint8_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_SIGNED_SHORT:\t*tmp++ = (casttype)*val / (casttype)*((int16_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_UNSIGNED_SHORT:\t*tmp++ = (casttype)*val / (casttype)*((uint16_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_SIGNED_LONG:\t\t*tmp++ = (casttype)*val / (casttype)*((int32_t *)scaledata8);\tbreak;\t\\\n\tcase GPMF_TYPE_UNSIGNED_LONG:\t*tmp++ = (casttype)*val / (casttype)*((uint32_t *)scaledata8);\tbreak;  \\\n\tcase GPMF_TYPE_FLOAT:\t\t\t*tmp++ = (casttype)*val / (casttype)*((float *)scaledata8);\t\tbreak;\t\\\n\tdefault: break;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\toutput = (uint8_t *)tmp;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n}\n\n#define MACRO_CAST_SCALE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tswitch (outputType)\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tcase GPMF_TYPE_SIGNED_BYTE: \tMACRO_CAST_SCALE_SIGNED_TYPE(int8_t)\tbreak;\t\t\\\n\t\tcase GPMF_TYPE_UNSIGNED_BYTE:\tMACRO_CAST_SCALE_UNSIGNED_TYPE(uint8_t)\tbreak;\t\t\\\n\t\tcase GPMF_TYPE_SIGNED_SHORT: \tMACRO_CAST_SCALE_SIGNED_TYPE(int16_t)\tbreak;\t\t\\\n\t\tcase GPMF_TYPE_UNSIGNED_SHORT:\tMACRO_CAST_SCALE_UNSIGNED_TYPE(uint16_t)\tbreak;\t\\\n\t\tcase GPMF_TYPE_FLOAT:\t\t\tMACRO_CAST_SCALE_SIGNED_TYPE(float)\tbreak;\t\t\t\\\n\t\tcase GPMF_TYPE_SIGNED_LONG:\t\tMACRO_CAST_SCALE_SIGNED_TYPE(int32_t)\tbreak;\t\t\\\n\t\tcase GPMF_TYPE_UNSIGNED_LONG:\tMACRO_CAST_SCALE_UNSIGNED_TYPE(uint32_t)\tbreak;\t\\\n\t\tcase GPMF_TYPE_DOUBLE:\t\t\tMACRO_CAST_SCALE_SIGNED_TYPE(double)\tbreak;\t\t\\\n\t\tdefault: break;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n#define MACRO_BSWAP_CAST_SCALE(swap, inputcast, tempcast)\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tinputcast *val;\t\t\t\t\t\t\t\t\t\t\\\n\ttempcast temp,  *datatemp = (tempcast *)data;\t\t\\\n\ttemp = swap(*datatemp);\t\t\t\t\t\t\t\t\\\n\tval = (inputcast *)&temp;\t\t\t\t\t\t\t\\\n\tMACRO_CAST_SCALE\t\t\t\t\t\t\t\t\t\\\n\tdatatemp++;\t\t\t\t\t\t\t\t\t\t\t\\\n\tdata = (uint8_t *)datatemp;\t\t\t\t\t\t\t\\\n}\n\nGPMF_ERR GPMF_ScaledData(GPMF_stream *ms, void *buffer, uint32_t buffersize, uint32_t sample_offset, uint32_t read_samples, GPMF_SampleType outputType)\n{\n\tif (ms && buffer)\n\t{\n\t\tuint8_t *data = (uint8_t *)&ms->buffer[ms->pos + 2];\n\t\tuint8_t *output = (uint8_t *)buffer;\n\t\tuint32_t sample_size = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1]);\n\t\tuint32_t output_sample_size = GPMF_SizeofType(outputType);\n\t\tuint32_t remaining_sample_size = GPMF_DATA_PACKEDSIZE(ms->buffer[ms->pos + 1]);\n\t\tuint8_t type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\t\tchar complextype[64] = \"L\";\n\t\tuint32_t inputtypesize = 0;\n\t\tuint32_t inputtypeelements = 0;\n\t\tuint8_t scaletype = 0;\n\t\tuint8_t scalecount = 0;\n\t\tuint32_t scaletypesize = 0;\n\t\tuint32_t *scaledata = NULL;\n\t\tuint32_t tmpbuffer[64];\n\t\tuint32_t tmpbuffersize = sizeof(tmpbuffer);\n\t\tuint32_t elements = 1;\n\n\t\ttype = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);\n\n\t\tif (type == GPMF_TYPE_NEST)\n\t\t\treturn GPMF_ERROR_MEMORY;\n\n\t\tif (GPMF_OK != IsValidSize(ms, remaining_sample_size >> 2))\n\t\t\treturn GPMF_ERROR_BAD_STRUCTURE;\n\n\t\tremaining_sample_size -= sample_offset * sample_size; // skip samples\n\t\tdata += sample_offset * sample_size;\n\n\t\tif (remaining_sample_size < sample_size * read_samples)\n\t\t\treturn GPMF_ERROR_MEMORY;\n\n\t\tif (type == GPMF_TYPE_COMPLEX)\n\t\t{\n\n\t\t\tGPMF_stream find_stream;\n\t\t\tGPMF_CopyState(ms, &find_stream);\n\n\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_RECURSE_LEVELS))\n\t\t\t{\n\t\t\t\tchar *data1 = (char *)GPMF_RawData(&find_stream);\n\t\t\t\tint size = GPMF_RawDataSize(&find_stream);\n\t\t\t\tuint32_t typestringlength = sizeof(complextype);\n\t\t\t\tif (GPMF_OK == GPMF_ExpandComplexTYPE(data1, size, complextype, &typestringlength))\n\t\t\t\t{\n\t\t\t\t\tinputtypeelements = elements = typestringlength;\n\n\t\t\t\t\tif (sample_size != GPMF_SizeOfComplexTYPE(complextype, typestringlength))\n\t\t\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcomplextype[0] = type;\n\t\t\tinputtypesize = GPMF_SizeofType(type);\n\t\t\tif (inputtypesize == 0)\n\t\t\t\treturn GPMF_ERROR_MEMORY;\n\t\t\tinputtypeelements = 1;\n\t\t\telements = sample_size / inputtypesize;\n\t\t}\n\n\t\tif (output_sample_size * elements * read_samples > buffersize)\n\t\t\treturn GPMF_ERROR_MEMORY;\n\n\n\t\tswitch (outputType)\t{\n\t\tcase GPMF_TYPE_SIGNED_BYTE:\n\t\tcase GPMF_TYPE_UNSIGNED_BYTE:\n\t\tcase GPMF_TYPE_SIGNED_SHORT:\n\t\tcase GPMF_TYPE_UNSIGNED_SHORT:\n\t\tcase GPMF_TYPE_FLOAT:\n\t\tcase GPMF_TYPE_SIGNED_LONG:\n\t\tcase GPMF_TYPE_UNSIGNED_LONG:\n\t\tcase GPMF_TYPE_DOUBLE:\n\t\t\t// All supported formats.\n\t\t{\n\t\t\tGPMF_stream fs;\n\t\t\tGPMF_CopyState(ms, &fs);\n\n\t\t\tif (GPMF_OK == GPMF_FindPrev(&fs, GPMF_KEY_SCALE, GPMF_CURRENT_LEVEL))\n\t\t\t{\n\t\t\t\tscaledata = (uint32_t *)GPMF_RawData(&fs);\n\t\t\t\tscaletype = GPMF_SAMPLE_TYPE(fs.buffer[fs.pos + 1]);\n\n\t\t\t\tswitch (scaletype)\n\t\t\t\t{\n\t\t\t\tcase GPMF_TYPE_SIGNED_BYTE:\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_BYTE:\n\t\t\t\tcase GPMF_TYPE_SIGNED_SHORT:\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_SHORT:\n\t\t\t\tcase GPMF_TYPE_SIGNED_LONG:\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_LONG:\n\t\t\t\tcase GPMF_TYPE_FLOAT:\n\t\t\t\t\tscalecount = GPMF_SAMPLES(fs.buffer[fs.pos + 1]);\n\t\t\t\t\tscaletypesize = GPMF_SizeofType(scaletype);\n\n\t\t\t\t\tif (scalecount > 1)\n\t\t\t\t\t\tif (scalecount != elements)\n\t\t\t\t\t\t\treturn GPMF_ERROR_SCALE_COUNT;\n\n\t\t\t\t\tGPMF_FormattedData(&fs, tmpbuffer, tmpbuffersize, 0, scalecount);\n\n\t\t\t\t\tscaledata = (uint32_t *)tmpbuffer;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tscaletype = 'L';\n\t\t\t\tscalecount = 1;\n\t\t\t\ttmpbuffer[0] = 1; // set the scale to 1 is no scale was provided\n\t\t\t\tscaledata = (uint32_t *)tmpbuffer;\n\t\t\t}\n\t\t}\n\n\t\twhile (read_samples--)\n\t\t{\n\t\t\tuint32_t i;\n\t\t\tuint8_t *scaledata8 = (uint8_t *)scaledata;\n\n\t\t\tfor (i = 0; i < elements; i++)\n\t\t\t{\n\t\t\t\tswitch (complextype[i % inputtypeelements])\n\t\t\t\t{\n\t\t\t\tcase GPMF_TYPE_FLOAT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, float, uint32_t) break;\n\t\t\t\tcase GPMF_TYPE_SIGNED_BYTE:  MACRO_BSWAP_CAST_SCALE(NOSWAP8, int8_t, uint8_t) break;\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_BYTE:  MACRO_BSWAP_CAST_SCALE(NOSWAP8, uint8_t, uint8_t) break;\n\t\t\t\tcase GPMF_TYPE_SIGNED_SHORT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP16, int16_t, uint16_t) break;\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_SHORT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP16, uint16_t, uint16_t) break;\n\t\t\t\tcase GPMF_TYPE_SIGNED_LONG:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, int32_t, uint32_t) break;\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_LONG:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, uint32_t, uint32_t) break;\n\t\t\t\tcase GPMF_TYPE_SIGNED_64BIT_INT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP64, uint64_t, uint64_t) break;\n\t\t\t\tcase GPMF_TYPE_UNSIGNED_64BIT_INT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP64, uint64_t, uint64_t) break;\n\t\t\t\tdefault:\n\t\t\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (scalecount > 1)\n\t\t\t\t\tscaledata8 += scaletypesize;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn GPMF_ERROR_TYPE_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn GPMF_OK;\n\t}\n\n\treturn GPMF_ERROR_MEMORY;\n}\n", "/*! @file GPMF_parser.h\n * \n *  @brief GPMF Parser library include\n * \n *  @version 1.1.1\n * \n *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n *\t\n *  Licensed under either:\n *  - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0  \n *  - MIT license, http://opensource.org/licenses/MIT\n *  at your option.\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n * \n */\n\n#ifndef _GPMF_PARSER_H\n#define _GPMF_PARSER_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define GPMF_NEST_LIMIT 16\n\ntypedef struct GPMF_stream\n{\n\tuint32_t *buffer;\n\tuint32_t buffer_size_longs;\n\tuint32_t pos;\n\tuint32_t last_level_pos[GPMF_NEST_LIMIT];\n\tuint32_t nest_size[GPMF_NEST_LIMIT];\n\tuint32_t last_seek[GPMF_NEST_LIMIT];\n\tuint32_t nest_level;\n\tuint32_t device_count;\n\tuint32_t device_id;\n\tchar device_name[32];\n} GPMF_stream;\n\ntypedef enum GPMF_ERROR\n{\n\tGPMF_OK = 0,\n\tGPMF_ERROR_MEMORY,\n\tGPMF_ERROR_BAD_STRUCTURE,\n\tGPMF_ERROR_BUFFER_END,\n\tGPMF_ERROR_FIND,\n\tGPMF_ERROR_LAST,\n\tGPMF_ERROR_TYPE_NOT_SUPPORTED,\n\tGPMF_ERROR_SCALE_NOT_SUPPORTED,\n\tGPMF_ERROR_SCALE_COUNT,\n\tGPMF_ERROR_RESERVED\n} GPMF_ERROR;\n\ntypedef enum GPMF_LEVELS\n{\n\tGPMF_CURRENT_LEVEL = 0,\n\tGPMF_RECURSE_LEVELS\n} GPMF_LEVELS;\n\n#define GPMF_ERR\tuint32_t\n\ntypedef enum\n{\n\tGPMF_TYPE_STRING_ASCII = 'c', //single byte 'c' style character string\n\tGPMF_TYPE_SIGNED_BYTE = 'b',//single byte signed number\n\tGPMF_TYPE_UNSIGNED_BYTE = 'B', //single byte unsigned number\n\tGPMF_TYPE_SIGNED_SHORT = 's',//16-bit integer\n\tGPMF_TYPE_UNSIGNED_SHORT = 'S',//16-bit integer\n\tGPMF_TYPE_FLOAT = 'f', //32-bit single precision float (IEEE 754)\n\tGPMF_TYPE_FOURCC = 'F', //32-bit four character tag \n\tGPMF_TYPE_SIGNED_LONG = 'l',//32-bit integer\n\tGPMF_TYPE_UNSIGNED_LONG = 'L', //32-bit integer\n\tGPMF_TYPE_Q15_16_FIXED_POINT = 'q', // Q number Q15.16 - 16-bit signed integer (A) with 16-bit fixed point (B) for A.B value (range -32768.0 to 32767.99998). \n\tGPMF_TYPE_Q31_32_FIXED_POINT = 'Q', // Q number Q31.32 - 32-bit signed integer (A) with 32-bit fixed point (B) for A.B value. \n\tGPMF_TYPE_SIGNED_64BIT_INT = 'j', //64 bit signed long\n\tGPMF_TYPE_UNSIGNED_64BIT_INT = 'J', //64 bit unsigned long\t\n\tGPMF_TYPE_DOUBLE = 'd', //64 bit double precision float (IEEE 754)\n\tGPMF_TYPE_UTC_DATE_TIME = 'U', //128-bit ASCII Date + UTC Time format yymmddhhmmss.sss - 16 bytes ASCII (years 20xx covered)\n\tGPMF_TYPE_GUID = 'G', //128-bit ID (like UUID)\n\n\tGPMF_TYPE_COMPLEX = '?', //for sample with complex data structures, base size in bytes.  Data is either opaque, or the stream has a TYPE structure field for the sample.\n\n\tGPMF_TYPE_NEST = 0, // used to nest more GPMF formatted metadata \n\n} GPMF_SampleType;\n\n\n\n#define MAKEID(a,b,c,d)\t\t\t(((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))\n#define STR2FOURCC(s)\t\t\t((s[0]<<0)|(s[1]<<8)|(s[2]<<16)|(s[3]<<24))\n\n#define BYTESWAP64(a)\t\t\t(((a&0xff)<<56)|((a&0xff00)<<40)|((a&0xff0000)<<24)|((a&0xff000000)<<8) | ((a>>56)&0xff)|((a>>40)&0xff00)|((a>>24)&0xff0000)|((a>>8)&0xff000000) )\n#define BYTESWAP32(a)\t\t\t(((a&0xff)<<24)|((a&0xff00)<<8)|((a>>8)&0xff00)|((a>>24)&0xff))\n#define BYTESWAP16(a)\t\t\t((((a)>>8)&0xff)|(((a)<<8)&0xff00))\n#define NOSWAP8(a)\t\t\t\t(a)\n\n#define GPMF_SAMPLES(a)\t\t\t(((a>>24) & 0xff)|(((a>>16)&0xff)<<8))\n#define GPMF_SAMPLE_SIZE(a)\t\t(((a)>>8)&0xff)\n#define GPMF_SAMPLE_TYPE(a)\t\t(a&0xff)\n#define GPMF_MAKE_TYPE_SIZE_COUNT(t,s,c)\t\t((t)&0xff)|(((s)&0xff)<<8)|(((c)&0xff)<<24)|(((c)&0xff00)<<8)\n#define GPMF_DATA_SIZE(a)\t\t((GPMF_SAMPLE_SIZE(a)*GPMF_SAMPLES(a)+3)&~0x3)\n#define GPMF_DATA_PACKEDSIZE(a)\t((GPMF_SAMPLE_SIZE(a)*GPMF_SAMPLES(a)))\n#define GPMF_VALID_FOURCC(a)\t(((((a>>24)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>24)&0xff)>='A'&&((a>>24)&0xff)<='Z') || (((a>>24)&0xff)>='0'&&((a>>24)&0xff)<='9') || (((a>>24)&0xff)==' ') ) && \\\n\t\t\t\t\t\t\t\t( (((a>>16)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>16)&0xff)>='A'&&((a>>16)&0xff)<='Z') || (((a>>16)&0xff)>='0'&&((a>>16)&0xff)<='9') || (((a>>16)&0xff)==' ') ) && \\\n\t\t\t\t\t\t\t\t( (((a>>8)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>8)&0xff)>='A'&&((a>>8)&0xff)<='Z') || (((a>>8)&0xff)>='0'&&((a>>8)&0xff)<='9') || (((a>>8)&0xff)==' ') ) && \\\n\t\t\t\t\t\t\t\t( (((a>>0)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>0)&0xff)>='A'&&((a>>0)&0xff)<='Z') || (((a>>0)&0xff)>='0'&&((a>>0)&0xff)<='9') || (((a>>0)&0xff)==' ') )) \n#define GPMF_KEY_TYPE(a)\t\t(a&0xff)\n\n#define PRINTF_4CC(k)\t\t\t((k) >> 0) & 0xff, ((k) >> 8) & 0xff, ((k) >> 16) & 0xff, ((k) >> 24) & 0xff\n\n \ntypedef enum GPMFKey // TAG in all caps are GoPro preserved (are defined by GoPro, but can be used by others.)\n{\n\t// Internal Metadata structure and formatting tags\n\tGPMF_KEY_DEVICE =\t\t\tMAKEID('D','E','V','C'),//DEVC - nested device data to speed the parsing of multiple devices in post \n\tGPMF_KEY_DEVICE_ID =\t\tMAKEID('D','V','I','D'),//DVID - unique id per stream for a metadata source (in camera or external input) (single 4 byte int)\n\tGPMF_KEY_DEVICE_NAME =\t\tMAKEID('D','V','N','M'),//DVNM - human readable device type/name (char string)\n\tGPMF_KEY_STREAM =\t\t\tMAKEID('S','T','R','M'),//STRM - nested channel/stream of telemetry data\n\tGPMF_KEY_STREAM_NAME =\t\tMAKEID('S','T','N','M'),//STNM - human readable telemetry/metadata stream type/name (char string)\n\tGPMF_KEY_SI_UNITS =\t\t\tMAKEID('S','I','U','N'),//SIUN - Display string for metadata units where inputs are in SI units \"uT\",\"rad/s\",\"km/s\",\"m/s\",\"mm/s\" etc.\n\tGPMF_KEY_UNITS =\t\t\tMAKEID('U','N','I','T'),//UNIT - Freedform display string for metadata units (char sting like \"RPM\", \"MPH\", \"km/h\", etc)\n\tGPMF_KEY_SCALE =\t\t\tMAKEID('S','C','A','L'),//SCAL - divisor for input data to scale to the correct units.\n\tGPMF_KEY_TYPE =\t\t\t\tMAKEID('T','Y','P','E'),//TYPE - Type define for complex data structures\n\tGPMF_KEY_TOTAL_SAMPLES =\tMAKEID('T','S','M','P'),//TSMP - Total Sample Count including the current payload \t\n\tGPMF_KEY_TIME_OFFSET =\t\tMAKEID('T','I','M','O'),//TIMO - Time offset of the metadata stream that follows (single 4 byte float)\n\tGPMF_KEY_TIMING_OFFSET =\tMAKEID('T','I','M','O'),//TIMO - duplicated, as older code might use the other version of TIMO\n\tGPMF_KEY_TIME_STAMP =\t\tMAKEID('S','T','M','P'),//STMP - Time stamp for the first sample. \n\tGPMF_KEY_TIME_STAMPS =\t\tMAKEID('S','T','P','S'),//STPS - Stream of all the timestamps delivered (Generally don't use this. This would be if your sensor has no peroidic times, yet precision is required, or for debugging.) \n\tGPMF_KEY_TICK =\t\t\t\tMAKEID('T','I','C','K'),//TICK - Used for slow data. Beginning of data timing in milliseconds. \n\tGPMF_KEY_TOCK =\t\t\t\tMAKEID('T','O','C','K'),//TOCK - Used for slow data. End of data timing in milliseconds. \n\tGPMF_KEY_EMPTY_PAYLOADS =\tMAKEID('E','M','P','T'),//EMPT - Payloads that are empty since the device start (e.g. BLE disconnect.)\n\tGPMF_KEY_REMARK =\t\t\tMAKEID('R','M','R','K'),//RMRK - addcing comments to the bitstream (debugging)\n\n\tGPMF_KEY_END = 0//(null)\n} GPMFKey;\n\n\n\n// Prepare GPMF data \nGPMF_ERR GPMF_Init(GPMF_stream *gs, uint32_t *buffer, int datasize);\t\t\t\t\t\t\t//Initialize a GPMF_stream for parsing a particular buffer.\nGPMF_ERR GPMF_ResetState(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Read from beginning of the buffer again\nGPMF_ERR GPMF_CopyState(GPMF_stream *src, GPMF_stream *dst);\t\t\t\t\t\t\t\t\t//Copy state, \nGPMF_ERR GPMF_Validate(GPMF_stream *gs, GPMF_LEVELS recurse);\t\t\t\t\t\t\t\t\t//Is the nest structure valid GPMF? \n\n// Navigate through GPMF data \nGPMF_ERR GPMF_Next(GPMF_stream *gs, GPMF_LEVELS recurse);\t\t\t\t\t\t\t\t\t\t//Step to the next GPMF KLV entrance, optionally recurse up or down nesting levels.\nGPMF_ERR GPMF_FindPrev(GPMF_stream *gs, uint32_t fourCC, GPMF_LEVELS recurse);\t\t\t\t\t//find a previous FourCC -- at the current level only if recurse is false\nGPMF_ERR GPMF_FindNext(GPMF_stream *gs, uint32_t fourCC, GPMF_LEVELS recurse);\t\t\t\t\t//find a particular FourCC upcoming -- at the current level only if recurse is false\nGPMF_ERR GPMF_SeekToSamples(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t//find the last FourCC in the current level, this is raw data for any STRM\n\n// Get information about the current GPMF KLV\nuint32_t GPMF_Key(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current Key (FourCC)\nuint32_t GPMF_Type(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current Type (GPMF_Type)\nuint32_t GPMF_StructSize(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current sample structure size\nuint32_t GPMF_Repeat(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current repeat or the number of samples of this structure\nuint32_t GPMF_PayloadSampleCount(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current number of samples of this structure, supporting multisample entries.\nuint32_t GPMF_ElementsInStruct(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t//return the current number elements within the structure (e.g. 3-axis gyro)\nuint32_t GPMF_RawDataSize(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the data size for the current GPMF KLV \nvoid *   GPMF_RawData(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return a pointer the KLV data (which is Bigendian if the type is known.)\n\n// Get information about where the GPMF KLV is nested\nuint32_t GPMF_NestLevel(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current nest level\nuint32_t GPMF_DeviceID(GPMF_stream *gs);\t\t\t\t\t\t\t\t\t\t\t\t\t\t//return the current device ID (DVID), to seperate match sensor data from difference devices.\nGPMF_ERR GPMF_DeviceName(GPMF_stream *gs, char *devicename_buf, uint32_t devicename_buf_size);\t//return the current device name (DVNM), to seperate match sensor data from difference devices.\n\n// Utilities for data types\nuint32_t GPMF_SizeofType(GPMF_SampleType type);\t\t\t\t\t\t\t\t\t\t\t\t\t// GPMF equivalent to sizeof(type)\nuint32_t GPMF_ExpandComplexTYPE(char *src, uint32_t srcsize, char *dst, uint32_t *dstsize);\t\t// GPMF using TYPE for cmple structure.  { float val[16],uin32_t flags; } has type \"f[8]L\", this tools expands to the simpler format \"ffffffffL\"\nuint32_t GPMF_SizeOfComplexTYPE(char *typearray, uint32_t typestringlength);\t\t\t\t\t// GPMF equivalent to sizeof(typedef) for complex types. \nGPMF_ERR GPMF_Reserved(uint32_t key);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Test for a reverse GPMF Key, returns GPMF_OK is not reversed.\n\n//Tools for extracting sensor data \nGPMF_ERR GPMF_FormattedData(GPMF_stream *gs, void *buffer, uint32_t buffersize, uint32_t sample_offset, uint32_t read_samples);  // extract 'n' samples into local endian memory format.\nGPMF_ERR GPMF_ScaledData(GPMF_stream *gs, void *buffer, uint32_t buffersize, uint32_t sample_offset, uint32_t read_samples, GPMF_SampleType type); // extract 'n' samples into local endian memory format\t\t\t\t\t\t\t\t\t\t// return a point the KLV data.\n\n\n\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "/*! @file GPMF_demo.c\n *\n *  @brief Demo to extract GPMF from an MP4\n *\n *  @version 1.0.1\n *\n *  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n *\t\n *  Licensed under either:\n *  - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0  \n *  - MIT license, http://opensource.org/licenses/MIT\n *  at your option.\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\n#include \"../GPMF_parser.h\"\n#include \"GPMF_mp4reader.h\"\n\n\nextern void PrintGPMF(GPMF_stream *ms);\n\nint main(int argc, char *argv[])\n{\n\tint32_t ret = GPMF_OK;\n\tGPMF_stream metadata_stream, *ms = &metadata_stream;\n\tdouble metadatalength;\n\tuint32_t *payload = NULL; //buffer to store GPMF samples from the MP4.\n\n\n\t// get file return data\n\tif (argc != 2)\n\t{\n\t\tprintf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);\n\t\treturn -1;\n\t}\n\n\tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);\n\tif (mp4 == 0)\n\t{\n\t\tprintf(\"error: %s is an invalid MP4/MOV\\n\", argv[1]);\n\t\treturn -1;\n\t}\n\n//\tsize_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4's udta \n\n\tmetadatalength = GetDuration(mp4);\n\n\tif (metadatalength > 0.0)\n\t{\n\t\tuint32_t index, payloads = GetNumberPayloads(mp4);\n//\t\tprintf(\"found %.2fs of metadata, from %d payloads, within %s\\n\", metadatalength, payloads, argv[1]);\n\n#if 1\n\t\tif (payloads == 1) // Printf the contents of the single payload\n\t\t{\n\t\t\tuint32_t payloadsize = GetPayloadSize(mp4,0);\n\t\t\tpayload = GetPayload(mp4, payload, 0);\n\t\t\tif(payload == NULL)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n\t\t\t// Output (printf) all the contained GPMF data within this payload\n\t\t\tret = GPMF_Validate(ms, GPMF_RECURSE_LEVELS); // optional\n\t\t\tif (GPMF_OK != ret)\n\t\t\t{\n\t\t\t\tprintf(\"Invalid Structure\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tGPMF_ResetState(ms);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tPrintGPMF(ms);  // printf current GPMF KLV\n\t\t\t} while (GPMF_OK == GPMF_Next(ms, GPMF_RECURSE_LEVELS));\n\t\t\tGPMF_ResetState(ms);\n\t\t\tprintf(\"\\n\");\n\n\t\t}\n#endif\n\n\n\t\tfor (index = 0; index < payloads; index++)\n\t\t{\n\t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);\n\t\t\tdouble in = 0.0, out = 0.0; //times\n\t\t\tpayload = GetPayload(mp4, payload, index);\n\t\t\tif (payload == NULL)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GetPayloadTime(mp4, index, &in, &out);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n#if 1\t\t// Find all the available Streams and the data carrying FourCC\n\t\t\tif (index == 0) // show first payload \n\t\t\t{\n\t\t\t\tret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);\n\t\t\t\twhile (GPMF_OK == ret)\n\t\t\t\t{\n\t\t\t\t\tret = GPMF_SeekToSamples(ms);\n\t\t\t\t\tif (GPMF_OK == ret) //find the last FOURCC within the stream\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t key = GPMF_Key(ms);\n\t\t\t\t\t\tGPMF_SampleType type = GPMF_Type(ms);\n\t\t\t\t\t\tuint32_t elements = GPMF_ElementsInStruct(ms);\n\t\t\t\t\t\t//uint32_t samples = GPMF_Repeat(ms);\n\t\t\t\t\t\tuint32_t samples = GPMF_PayloadSampleCount(ms);\n\n\t\t\t\t\t\tif (samples)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"  STRM of %c%c%c%c \", PRINTF_4CC(key));\n\n\t\t\t\t\t\t\tif (type == GPMF_TYPE_COMPLEX)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGPMF_stream find_stream;\n\t\t\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n\n\t\t\t\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_CURRENT_LEVEL))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tchar tmp[64];\n\t\t\t\t\t\t\t\t\tchar *data = (char *)GPMF_RawData(&find_stream);\n\t\t\t\t\t\t\t\t\tint size = GPMF_RawDataSize(&find_stream);\n\n\t\t\t\t\t\t\t\t\tif (size < sizeof(tmp))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmemcpy(tmp, data, size);\n\t\t\t\t\t\t\t\t\t\ttmp[size] = 0;\n\t\t\t\t\t\t\t\t\t\tprintf(\"of type %s \", tmp);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tprintf(\"of type %c \", type);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprintf(\"with %d sample%s \", samples, samples > 1 ? \"s\" : \"\");\n\n\t\t\t\t\t\t\tif (elements > 1)\n\t\t\t\t\t\t\t\tprintf(\"-- %d elements per sample\", elements);\n\n\t\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ret == GPMF_ERROR_BAD_STRUCTURE) // some payload element was corrupt, skip to the next valid GPMF KLV at the previous level.\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tret = GPMF_Next(ms, GPMF_CURRENT_LEVEL); // this will be the next stream if any more are present.\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tGPMF_ResetState(ms);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n#endif \n\n\n\n\n#if 1\t\t// Find GPS values and return scaled doubles. \n\t\t\tif (index == 0) // show first payload \n\t\t\t{\n\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"GPS5\"), GPMF_RECURSE_LEVELS) || //GoPro Hero5/6/7 GPS\n\t\t\t\t\tGPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"GPRI\"), GPMF_RECURSE_LEVELS))   //GoPro Karma GPS\n\t\t\t\t{\n\t\t\t\t\tuint32_t key = GPMF_Key(ms);\n\t\t\t\t\tuint32_t samples = GPMF_Repeat(ms);\n\t\t\t\t\tuint32_t elements = GPMF_ElementsInStruct(ms);\n\t\t\t\t\tuint32_t buffersize = samples * elements * sizeof(double);\n\t\t\t\t\tGPMF_stream find_stream;\n\t\t\t\t\tdouble *ptr, *tmpbuffer = malloc(buffersize);\n\t\t\t\t\tchar units[10][6] = { \"\" };\n\t\t\t\t\tuint32_t unit_samples = 1;\n\n\t\t\t\t\tprintf(\"MP4 Payload time %.3f to %.3f seconds\\n\", in, out);\n\n\t\t\t\t\tif (tmpbuffer && samples)\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t i, j;\n\n\t\t\t\t\t\t//Search for any units to display\n\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n\t\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_SI_UNITS, GPMF_CURRENT_LEVEL) ||\n\t\t\t\t\t\t\tGPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_UNITS, GPMF_CURRENT_LEVEL))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tchar *data = (char *)GPMF_RawData(&find_stream);\n\t\t\t\t\t\t\tint ssize = GPMF_StructSize(&find_stream);\n\t\t\t\t\t\t\tunit_samples = GPMF_Repeat(&find_stream);\n\n\t\t\t\t\t\t\tfor (i = 0; i < unit_samples; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmemcpy(units[i], data, ssize);\n\t\t\t\t\t\t\t\tunits[i][ssize] = 0;\n\t\t\t\t\t\t\t\tdata += ssize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//GPMF_FormattedData(ms, tmpbuffer, buffersize, 0, samples); // Output data in LittleEnd, but no scale\n\t\t\t\t\t\tGPMF_ScaledData(ms, tmpbuffer, buffersize, 0, samples, GPMF_TYPE_DOUBLE);  //Output scaled data as floats\n\n\t\t\t\t\t\tptr = tmpbuffer;\n\t\t\t\t\t\tfor (i = 0; i < samples; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"%c%c%c%c \", PRINTF_4CC(key));\n\t\t\t\t\t\t\tfor (j = 0; j < elements; j++)\n\t\t\t\t\t\t\t\tprintf(\"%.3f%s, \", *ptr++, units[j%unit_samples]);\n\n\t\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(tmpbuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tGPMF_ResetState(ms);\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n#endif \n\t\t}\n\n#if 1\n\t\t// Find all the available Streams and compute they sample rates\n\t\twhile (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))\n\t\t{\n\t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream\n\t\t\t{\n\t\t\t\tdouble in = 0.0, out = 0.0;\n\t\t\t\tuint32_t fourcc = GPMF_Key(ms);\n\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);// GPMF_SAMPLE_RATE_FAST);\n\t\t\t\tprintf(\"%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\", PRINTF_4CC(fourcc), rate, in, out);\n\t\t\t}\n\t\t}\n#endif\n\n\n\tcleanup:\n\t\tif (payload) FreePayload(payload); payload = NULL;\n\t\tCloseSource(mp4);\n\t}\n\n\treturn ret;\n}\n", "/*! @file mp4reader.c\n*\n*  @brief Way Too Crude MP4|MOV reader\n*\n*  @version 1.3.1\n*\n*  (C) Copyright 2017-2019 GoPro Inc (http://gopro.com/).\n*\n*  Licensed under either:\n*  - Apache License, Version 2.0, http://www.apache.org/licenses/LICENSE-2.0\n*  - MIT license, http://opensource.org/licenses/MIT\n*  at your option.\n*\n*  Unless required by applicable law or agreed to in writing, software\n*  distributed under the License is distributed on an \"AS IS\" BASIS,\n*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n*  See the License for the specific language governing permissions and\n*  limitations under the License.\n*\n*/\n\n/* This is not an elegant MP4 parser, only used to help demonstrate extraction of GPMF */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n#include \"GPMF_mp4reader.h\"\n\n#define PRINT_MP4_STRUCTURE\t\t0\n\n#ifdef WIN32\n#define LONGSEEK\t_fseeki64\n#define stat64\t\t_stat64\n#else\n#define LONGSEEK\tfseeko\n#endif\n\n\nuint32_t GetNumberPayloads(size_t handle)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\n\tif (mp4)\n\t{\n\t\treturn mp4->indexcount;\n\t}\n\n\treturn 0;\n}\n\nuint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return NULL;\n\n\tuint32_t *MP4buffer = NULL;\n\tif (index < mp4->indexcount && mp4->mediafp)\n\t{\n\t\tMP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4->metasizes[index]);\n\n\t\tif (MP4buffer)\n\t\t{\n\t\t\tif (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])\n\t\t\t{\n\t\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n\t\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);\n\t\t\t\tmp4->filepos = mp4->metaoffsets[index] + mp4->metasizes[index];\n\t\t\t\treturn MP4buffer;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n\nvoid LongSeek(mp4object *mp4, int64_t offset)\n{\n\tif (mp4 && offset)\n\t{\n\t\tif (mp4->filepos + offset < mp4->filesize)\n\t\t{\n\t\t\tLONGSEEK(mp4->mediafp, offset, SEEK_CUR);\n\t\t\tmp4->filepos += offset;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmp4->filepos = mp4->filesize;\n\t\t}\n\t}\n}\n\nvoid FreePayload(uint32_t *lastpayload)\n{\n\tif (lastpayload)\n\t\tfree(lastpayload);\n}\n\n\nuint32_t GetPayloadSize(size_t handle, uint32_t index)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return 0;\n\n\tif (mp4->metasizes && mp4->metasize_count > index)\n\t\treturn mp4->metasizes[index];\n\n\treturn 0;\n}\n\n\n#define MAX_NEST_LEVEL\t20\n\nsize_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t traksubtype)  //RAW or within MP4\n{\n\tmp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));\n\tif (mp4 == NULL) return 0;\n\n\tmemset(mp4, 0, sizeof(mp4object));\n\n\tstruct stat64 mp4stat;\n\tstat64(filename, &mp4stat);\n\tmp4->filesize = mp4stat.st_size;\n\n\tif (mp4->filesize < 64) return 0;\n\n#ifdef _WINDOWS\n\tfopen_s(&mp4->mediafp, filename, \"rb\");\n#else\n\tmp4->mediafp = fopen(filename, \"rb\");\n#endif\n\n\tif (mp4->mediafp)\n\t{\n\t\tuint32_t qttag, qtsize32, skip, type = 0, subtype = 0, num;\n\t\tsize_t len;\n\t\tint32_t nest = 0;\n\t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\n\t\tuint64_t lastsize = 0, qtsize;\n\n\n\t\tdo\n\t\t{\n\t\t\tlen = fread(&qtsize32, 1, 4, mp4->mediafp);\n\t\t\tlen += fread(&qttag, 1, 4, mp4->mediafp);\n\t\t\tmp4->filepos += len;\n\t\t\tif (len == 8 && mp4->filepos < mp4->filesize)\n\t\t\t{\n\t\t\t\tif (!VALID_FOURCC(qttag))\n\t\t\t\t{\n\t\t\t\t\tCloseSource((size_t)mp4);\n\t\t\t\t\tmp4 = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tqtsize32 = BYTESWAP32(qtsize32);\n\n\t\t\t\tif (qtsize32 == 1) // 64-bit Atom\n\t\t\t\t{\n\t\t\t\t\tlen = fread(&qtsize, 1, 8, mp4->mediafp);\n\t\t\t\t\tmp4->filepos += len;\n\t\t\t\t\tqtsize = BYTESWAP64(qtsize) - 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tqtsize = qtsize32;\n\n\t\t\t\tnest++;\n\n\t\t\t\tif (qtsize < 8) break;\n\t\t\t\tif (nest >= MAX_NEST_LEVEL) break;\n\n\t\t\t\tnestsize[nest] = qtsize;\n\t\t\t\tlastsize = qtsize;\n\n#if PRINT_MP4_STRUCTURE\t\n\n\t\t\t\tfor (int i = 1; i < nest; i++) printf(\"    \");\n\t\t\t\tprintf(\"%c%c%c%c (%lld)\\n\", (qttag & 0xff), ((qttag >> 8) & 0xff), ((qttag >> 16) & 0xff), ((qttag >> 24) & 0xff), qtsize);\n\n\t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||\n\t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p') ||\n\t\t\t\t\tqttag == MAKEID('u', 'd', 't', 'a') ||\n\t\t\t\t\tqttag == MAKEID('f', 'r', 'e', 'e'))\n\t\t\t\t{\n\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n\n\t\t\t\t\tNESTSIZE(qtsize);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n#else\n\t\t\t\tif (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms\n\t\t\t\t\tqttag != MAKEID('m', 'v', 'h', 'd') &&\n\t\t\t\t\tqttag != MAKEID('t', 'r', 'a', 'k') &&\n\t\t\t\t\tqttag != MAKEID('m', 'd', 'i', 'a') &&\n\t\t\t\t\tqttag != MAKEID('m', 'd', 'h', 'd') &&\n\t\t\t\t\tqttag != MAKEID('m', 'i', 'n', 'f') &&\n\t\t\t\t\tqttag != MAKEID('g', 'm', 'i', 'n') &&\n\t\t\t\t\tqttag != MAKEID('d', 'i', 'n', 'f') &&\n\t\t\t\t\tqttag != MAKEID('a', 'l', 'i', 's') &&\n\t\t\t\t\tqttag != MAKEID('s', 't', 's', 'd') &&\n\t\t\t\t\tqttag != MAKEID('s', 't', 'b', 'l') &&\n\t\t\t\t\tqttag != MAKEID('s', 't', 't', 's') &&\n\t\t\t\t\tqttag != MAKEID('s', 't', 's', 'c') &&\n\t\t\t\t\tqttag != MAKEID('s', 't', 's', 'z') &&\n\t\t\t\t\tqttag != MAKEID('s', 't', 'c', 'o') &&\n\t\t\t\t\tqttag != MAKEID('c', 'o', '6', '4') &&\n\t\t\t\t\tqttag != MAKEID('h', 'd', 'l', 'r'))\n\t\t\t\t{\n\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n\n\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t}\n\t\t\t\telse\n#endif\n\t\t\t\t\tif (qttag == MAKEID('m', 'v', 'h', 'd')) //mvhd  movie header\n\t\t\t\t\t{\n\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\tlen += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);\n\t\t\t\t\t\tlen += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);\n\n\t\t\t\t\t\tmp4->filepos += len;\n\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over mvhd\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('m', 'd', 'h', 'd')) //mdhd  media header\n\t\t\t\t\t{\n\t\t\t\t\t\tmedia_header md;\n\t\t\t\t\t\tlen = fread(&md, 1, sizeof(md), mp4->mediafp);\n\t\t\t\t\t\tif (len == sizeof(md))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmd.creation_time = BYTESWAP32(md.creation_time);\n\t\t\t\t\t\t\tmd.modification_time = BYTESWAP32(md.modification_time);\n\t\t\t\t\t\t\tmd.time_scale = BYTESWAP32(md.time_scale);\n\t\t\t\t\t\t\tmd.duration = BYTESWAP32(md.duration);\n\n\t\t\t\t\t\t\tmp4->trak_clockdemon = md.time_scale;\n\t\t\t\t\t\t\tmp4->trak_clockcount = md.duration;\n\n\t\t\t\t\t\t\tif (mp4->videolength == 0.0) // Get the video length from the first track\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmp4->filepos += len;\n\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over mvhd\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('h', 'd', 'l', 'r')) //hldr\n\t\t\t\t\t{\n\t\t\t\t\t\tuint32_t temp;\n\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\tlen += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.\n\n\t\t\t\t\t\tif (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))\n\t\t\t\t\t\t\ttype = temp;\n\n\t\t\t\t\t\tmp4->filepos += len;\n\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over hldr\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('s', 't', 's', 'd')) //read the sample decription to determine the type of metadata\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type == traktype) //like meta\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&subtype, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.\n\t\t\t\t\t\t\tif (len == 16)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (subtype != traksubtype) // MP4 metadata \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttype = 0; // MP4\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmp4->filepos += len;\n\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stsd\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('s', 't', 's', 'c')) // metadata stsc - offset chunks\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type == traktype) // meta\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n\n\t\t\t\t\t\t\tnum = BYTESWAP32(num);\n\t\t\t\t\t\t\tif (num * 12 <= qtsize - 8 - len)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmp4->metastsc_count = num;\n\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n\t\t\t\t\t\t\t\tif (num > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));\n\t\t\t\t\t\t\t\t\tif (mp4->metastsc)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);\n\n\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);\n\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);\n\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);\n\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//size of null\n\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n\t\t\t\t\t\t\t\t\tmp4 = NULL;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmp4->filepos += len;\n\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stsx\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('s', 't', 's', 'z')) // metadata stsz - sizes\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type == traktype) // meta\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint32_t equalsamplesize;\n\n\t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&equalsamplesize, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n\n\t\t\t\t\t\t\tnum = BYTESWAP32(num);\n\t\t\t\t\t\t\tif (num * 4 <= qtsize - 8 - len)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmp4->metasize_count = num;\n\t\t\t\t\t\t\t\tif (mp4->metasizes) free(mp4->metasizes);\n\t\t\t\t\t\t\t\tif(num > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(num * 4);\n\t\t\t\t\t\t\t\t\tif (mp4->metasizes)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (equalsamplesize == 0)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);\n\t\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);\n\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tequalsamplesize = BYTESWAP32(equalsamplesize);\n\t\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\t\tmp4->metasizes[num] = equalsamplesize;\n\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//size of null\n\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n\t\t\t\t\t\t\t\t\tmp4 = NULL;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmp4->filepos += len;\n\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stsz\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('s', 't', 'c', 'o')) // metadata stco - offsets\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type == traktype) // meta\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tnum = BYTESWAP32(num);\n\t\t\t\t\t\t\tif (num * 4 <= qtsize - 8 - len)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuint32_t metastco_count = num;\n\n\t\t\t\t\t\t\t\tif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmp4->indexcount = num;\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n\t\t\t\t\t\t\t\t\tif(num > 0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n\t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n\t\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tint repeat = 1;\n\t\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n\t\t\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);\n\t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\n\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];\n\t\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n\t\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->indexcount)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)stco_pos + 1 < metastco_count)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets32[stco_pos];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstsc_pos++;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trepeat = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trepeat++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n\t\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t//printf(\"%3d:%08x, delta = %08x\\n\", num, (int)fileoffset, delta);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//size of null\n\t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n\t\t\t\t\t\t\t\t\t\tmp4 = NULL;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmp4->indexcount = num;\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n\t\t\t\t\t\t\t\t\tif (num > 0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n\t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tuint32_t *metaoffsets32 = NULL;\n\t\t\t\t\t\t\t\t\t\t\tmetaoffsets32 = (uint32_t *)malloc(num * 4);\n\t\t\t\t\t\t\t\t\t\t\tif (metaoffsets32)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tsize_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);\n\t\t\t\t\t\t\t\t\t\t\t\tlen += readlen;\n\t\t\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);\n\t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\n\t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets32);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//size of null\n\t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n\t\t\t\t\t\t\t\t\t\tmp4 = NULL;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmp4->filepos += len;\n\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stco\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\n\t\t\t\t\telse if (qttag == MAKEID('c', 'o', '6', '4')) // metadata stco - offsets\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type == traktype) // meta\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tnum = BYTESWAP32(num);\n\n\t\t\t\t\t\t\tif(num == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//size of null\n\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n\t\t\t\t\t\t\t\tmp4 = NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (num * 8 <= qtsize - 8 - len)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (mp4->metastsc_count > 0 && num != mp4->metasize_count)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmp4->indexcount = mp4->metasize_count;\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n\t\t\t\t\t\t\t\t\tif (mp4->metasize_count)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);\n\t\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tuint64_t *metaoffsets64 = NULL;\n\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64 = (uint64_t *)malloc(num * 8);\n\t\t\t\t\t\t\t\t\t\t\tif (metaoffsets64)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tuint64_t fileoffset = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tint stsc_pos = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tint stco_pos = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tlen += fread(metaoffsets64, 1, num * 8, mp4->mediafp);\n\t\t\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\t\t\tmetaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);\n\t\t\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\n\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = metaoffsets64[0];\n\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[0] = fileoffset;\n\t\t\t\t\t\t\t\t\t\t\t\t//printf(\"%3d:%08x, delta = %08x\\n\", 0, (int)fileoffset, 0);\n\n\t\t\t\t\t\t\t\t\t\t\t\tnum = 1;\n\t\t\t\t\t\t\t\t\t\t\t\twhile (num < mp4->metasize_count)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstco_pos++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset = (uint64_t)metaoffsets64[stco_pos];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfileoffset += (uint64_t)mp4->metasizes[num - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = fileoffset;\n\t\t\t\t\t\t\t\t\t\t\t\t\t//int delta = metaoffsets[num] - metaoffsets[num - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t//printf(\"%3d:%08x, delta = %08x\\n\", num, (int)fileoffset, delta);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tnum++;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (mp4->metastsc) free(mp4->metastsc);\n\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc = NULL;\n\t\t\t\t\t\t\t\t\t\t\t\tmp4->metastsc_count = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfree(metaoffsets64);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t//size of null\n\t\t\t\t\t\t\t\t\t\tCloseSource((size_t)mp4);\n\t\t\t\t\t\t\t\t\t\tmp4 = NULL;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmp4->indexcount = num;\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets) free(mp4->metaoffsets);\n\t\t\t\t\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(num * 8);\n\t\t\t\t\t\t\t\t\tif (mp4->metaoffsets)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlen += fread(mp4->metaoffsets, 1, num * 8, mp4->mediafp);\n\t\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tnum--;\n\t\t\t\t\t\t\t\t\t\t\tmp4->metaoffsets[num] = BYTESWAP64(mp4->metaoffsets[num]);\n\t\t\t\t\t\t\t\t\t\t} while (num > 0);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmp4->filepos += len;\n\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stco\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse if (qttag == MAKEID('s', 't', 't', 's')) // time to samples\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type == traktype) // meta \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuint32_t totaldur = 0, samples = 0;\n\t\t\t\t\t\t\tint32_t entries = 0;\n\t\t\t\t\t\t\tlen = fread(&skip, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tlen += fread(&num, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\tnum = BYTESWAP32(num);\n\t\t\t\t\t\t\tif (num * 8 <= qtsize - 8 - len)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tentries = num;\n\n\t\t\t\t\t\t\t\tmp4->meta_clockdemon = mp4->trak_clockdemon;\n\t\t\t\t\t\t\t\tmp4->meta_clockcount = mp4->trak_clockcount;\n\n\t\t\t\t\t\t\t\twhile (entries > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tint32_t samplecount;\n\t\t\t\t\t\t\t\t\tint32_t duration;\n\t\t\t\t\t\t\t\t\tlen += fread(&samplecount, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\t\t\tsamplecount = BYTESWAP32(samplecount);\n\t\t\t\t\t\t\t\t\tlen += fread(&duration, 1, 4, mp4->mediafp);\n\t\t\t\t\t\t\t\t\tduration = BYTESWAP32(duration);\n\n\t\t\t\t\t\t\t\t\tsamples += samplecount;\n\t\t\t\t\t\t\t\t\tentries--;\n\n\t\t\t\t\t\t\t\t\ttotaldur += duration;\n\t\t\t\t\t\t\t\t\tmp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmp4->filepos += len;\n\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8 - len); // skip over stco\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n\n\t\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tNESTSIZE(8);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (len > 0);\n\n\t\tif (mp4)\n\t\t{\n\t\t\tif (mp4->metasizes == NULL || mp4->metaoffsets == NULL)\n\t\t\t{\n\t\t\t\tCloseSource((size_t)mp4);\n\t\t\t\tmp4 = NULL;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t//\tprintf(\"Could not open %s for input\\n\", filename);\n\t\t//\texit(1);\n\n\t\tfree(mp4);\n\t\tmp4 = NULL;\n\t}\n\n\treturn (size_t)mp4;\n}\n\n\nfloat GetDuration(size_t handle)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return 0.0;\n\n\treturn (float)mp4->metadatalength;\n}\n\n\nvoid CloseSource(size_t handle)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return;\n\n\tif (mp4->mediafp) fclose(mp4->mediafp), mp4->mediafp = NULL;\n\tif (mp4->metasizes) free(mp4->metasizes), mp4->metasizes = 0;\n\tif (mp4->metaoffsets) free(mp4->metaoffsets), mp4->metaoffsets = 0;\n\n\tfree(mp4);\n}\n\n\nuint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return GPMF_ERROR_MEMORY;\n\n\tif (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return GPMF_ERROR_MEMORY;\n\n\t*in = ((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n\t*out = ((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n\treturn GPMF_OK;\n}\n\n\nuint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator)\n{\n    mp4object *mp4 = (mp4object *)handle;\n    if (mp4 == NULL) return GPMF_ERROR_MEMORY;\n    \n    if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in_numerator == NULL || out_numerator == NULL) return GPMF_ERROR_MEMORY;\n\n\t*in_numerator = (uint32_t)(index * mp4->basemetadataduration);\n\t*out_numerator = (uint32_t)((index + 1) * mp4->basemetadataduration);\n\t*denominator = (uint32_t)mp4->meta_clockdemon;\n    \n    return GPMF_OK;\n}\n\nsize_t OpenMP4SourceUDTA(char *filename)\n{\n\tmp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));\n\tif (mp4 == NULL) return 0;\n\n\tmemset(mp4, 0, sizeof(mp4object));\n\n#ifdef _WINDOWS\n\tfopen_s(&mp4->mediafp, filename, \"rb\");\n#else\n\tmp4->mediafp = fopen(filename, \"rb\");\n#endif\n\n\tif (mp4->mediafp)\n\t{\n\t\tuint32_t qttag, qtsize32;\n\t\tsize_t len;\n\t\tint32_t nest = 0;\n\t\tuint64_t nestsize[MAX_NEST_LEVEL] = { 0 };\n\t\tuint64_t lastsize = 0, qtsize;\n\n\t\tdo\n\t\t{\n\t\t\tlen = fread(&qtsize32, 1, 4, mp4->mediafp);\n\t\t\tlen += fread(&qttag, 1, 4, mp4->mediafp);\n\t\t\tif (len == 8)\n\t\t\t{\n\t\t\t\tif (!GPMF_VALID_FOURCC(qttag))\n\t\t\t\t{\n\t\t\t\t\tLongSeek(mp4, lastsize - 8 - 8);\n\n\t\t\t\t\tNESTSIZE(lastsize - 8);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tqtsize32 = BYTESWAP32(qtsize32);\n\n\t\t\t\tif (qtsize32 == 1) // 64-bit Atom\n\t\t\t\t{\n\t\t\t\t\tfread(&qtsize, 1, 8, mp4->mediafp);\n\t\t\t\t\tqtsize = BYTESWAP64(qtsize) - 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tqtsize = qtsize32;\n\n\t\t\t\tnest++;\n\n\t\t\t\tif (qtsize < 8) break;\n\t\t\t\tif (nest >= MAX_NEST_LEVEL) break;\n\n\t\t\t\tnestsize[nest] = qtsize;\n\t\t\t\tlastsize = qtsize;\n\n\t\t\t\tif (qttag == MAKEID('m', 'd', 'a', 't') ||\n\t\t\t\t\tqttag == MAKEID('f', 't', 'y', 'p'))\n\t\t\t\t{\n\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (qttag == MAKEID('G', 'P', 'M', 'F'))\n\t\t\t\t{\n\t\t\t\t\tmp4->videolength += 1.0;\n\t\t\t\t\tmp4->metadatalength += 1.0;\n\n\t\t\t\t\tmp4->indexcount = (int)mp4->metadatalength;\n\n\t\t\t\t\tmp4->metasizes = (uint32_t *)malloc(mp4->indexcount * 4 + 4);  memset(mp4->metasizes, 0, mp4->indexcount * 4 + 4);\n\t\t\t\t\tmp4->metaoffsets = (uint64_t *)malloc(mp4->indexcount * 8 + 8);  memset(mp4->metaoffsets, 0, mp4->indexcount * 8 + 8);\n\n\t\t\t\t\tmp4->metasizes[0] = (int)qtsize - 8;\n\t\t\t\t\tmp4->metaoffsets[0] = ftell(mp4->mediafp);\n\t\t\t\t\tmp4->metasize_count = 1;\n\n\t\t\t\t\treturn (size_t)mp4;  // not an MP4, RAW GPMF which has not inherent timing, assigning a during of 1second.\n\t\t\t\t}\n\t\t\t\tif (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms\n\t\t\t\t\tqttag != MAKEID('u', 'd', 't', 'a'))\n\t\t\t\t{\n\t\t\t\t\tLongSeek(mp4, qtsize - 8);\n\t\t\t\t\tNESTSIZE(qtsize);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNESTSIZE(8);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (len > 0);\n\t}\n\treturn (size_t)mp4;\n}\n\n\ndouble GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *firstsampletime, double *lastsampletime)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return 0.0;\n\n\tGPMF_stream metadata_stream, *ms = &metadata_stream;\n\tuint32_t teststart = 0;\n\tuint32_t testend = mp4->indexcount;\n\tdouble rate = 0.0;\n\n\tuint32_t *payload;\n\tuint32_t payloadsize;\n\tint32_t ret;\n\n\tif (mp4->indexcount < 1)\n\t\treturn 0.0;\n\n\tpayload = GetPayload(handle, NULL, teststart); \n\tpayloadsize = GetPayloadSize(handle, teststart);\n\tret = GPMF_Init(ms, payload, payloadsize);\n\n\tif (ret != GPMF_OK)\n\t\tgoto cleanup;\n\n\t{\n\t\tuint64_t minimumtimestamp = 0;\n\t\tuint64_t starttimestamp = 0;\n\t\tuint64_t endtimestamp = 0;\n\t\tuint32_t startsamples = 0;\n\t\tuint32_t endsamples = 0;\n\t\tdouble intercept = 0.0;\n\n\n\n\t\twhile (teststart < mp4->indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n\t\t{\n\t\t\tteststart++;\n\t\t\tpayload = GetPayload(handle, payload, teststart); // second last payload\n\t\t\tpayloadsize = GetPayloadSize(handle, teststart);\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t}\n\n\t\tif (ret == GPMF_OK && payload)\n\t\t{\n\t\t\tuint32_t samples = GPMF_PayloadSampleCount(ms);\n\t\t\tGPMF_stream find_stream;\n\t\t\tGPMF_CopyState(ms, &find_stream);\n\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n\t\t\t\tstartsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;\n\n\t\t\tGPMF_CopyState(ms, &find_stream);\n\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))\n\t\t\t\tstarttimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));\n\n\t\t\tif (starttimestamp) // is this earliest in the payload, examine the other streams in this early payload.\n\t\t\t{\n\t\t\t\tGPMF_stream any_stream;\n\t\t\t\tGPMF_Init(&any_stream, payload, payloadsize);\n\n\t\t\t\tminimumtimestamp = starttimestamp;\n\t\t\t\twhile (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))\n\t\t\t\t{\n\t\t\t\t\tuint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));\n\t\t\t\t\tif (timestamp < minimumtimestamp)\n\t\t\t\t\t\tminimumtimestamp = timestamp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttestend = mp4->indexcount;\n\t\t\tdo\n\t\t\t{\n\t\t\t\ttestend--;// last payload with the fourcc needed\n\t\t\t\tpayload = GetPayload(handle, payload, testend);\n\t\t\t\tpayloadsize = GetPayloadSize(handle, testend);\n\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\t} while (testend > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));\n\n\t\t\tGPMF_CopyState(ms, &find_stream);\n\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))\n\t\t\t\tendsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));\n\t\t\telse // If there is no TSMP we have to count the samples.\n\t\t\t{\n\t\t\t\tuint32_t i;\n\t\t\t\tfor (i = teststart; i <= testend; i++)\n\t\t\t\t{\n\t\t\t\t\tpayload = GetPayload(handle,payload, i); // second last payload\n\t\t\t\t\tpayloadsize = GetPayloadSize(handle, i);\n\t\t\t\t\tif (GPMF_OK == GPMF_Init(ms, payload, payloadsize))\n\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n\t\t\t\t\t\t\tendsamples += GPMF_PayloadSampleCount(ms);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (starttimestamp != 0)\n\t\t\t{\n\t\t\t\tuint32_t last_samples = GPMF_PayloadSampleCount(ms);\n\t\t\t\tuint32_t totaltimestamped_samples = endsamples - last_samples - startsamples;\n\t\t\t\tdouble time_stamp_scale = 1000000000.0; // scan for nanoseconds, microseconds to seconds, all base 10.\n\n\t\t\t\tGPMF_CopyState(ms, &find_stream);\n\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))\n\t\t\t\t\tendtimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));\n\n\t\t\t\tif (endtimestamp)\n\t\t\t\t{\n\t\t\t\t\tdouble approxrate = 0.0;\n\t\t\t\t\tif (endsamples > startsamples)\n\t\t\t\t\t\tapproxrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n\n\t\t\t\t\tif (approxrate == 0.0)\n\t\t\t\t\t\tapproxrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n\n\n\t\t\t\t\twhile (time_stamp_scale >= 1)\n\t\t\t\t\t{\n\t\t\t\t\t\trate = (double)(totaltimestamped_samples) / ((double)(endtimestamp - starttimestamp) / time_stamp_scale);\n\t\t\t\t\t\tif (rate*0.9 < approxrate && approxrate < rate*1.1)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\ttime_stamp_scale *= 0.1;\n\t\t\t\t\t}\n\t\t\t\t\tif (time_stamp_scale < 1.0) rate = 0.0;\n\t\t\t\t\tintercept = (((double)minimumtimestamp - (double)starttimestamp) / time_stamp_scale) * rate;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rate == 0.0) //Timestamps didn't help weren't available\n\t\t\t{\n\t\t\t\tif (!(flags & GPMF_SAMPLE_RATE_PRECISE))\n\t\t\t\t{\n\t\t\t\t\tif (endsamples > startsamples)\n\t\t\t\t\t\trate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n\n\t\t\t\t\tif (rate == 0.0)\n\t\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n\n\t\t\t\t\tdouble in, out;\n\t\t\t\t\tif (GPMF_OK == GetPayloadTime(handle, teststart, &in, &out))\n\t\t\t\t\t\tintercept = (double)-in * rate;\n\t\t\t\t}\n\t\t\t\telse // for increased precision, for older GPMF streams sometimes missing the total sample count \n\t\t\t\t{\n\t\t\t\t\tuint32_t payloadpos = 0, payloadcount = 0;\n\t\t\t\t\tdouble slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;\n\t\t\t\t\tuint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);\n\t\t\t\t\tmemset(repeatarray, 0, mp4->indexcount * 4 + 4);\n\n\t\t\t\t\tsamples = 0;\n\n\t\t\t\t\tfor (payloadpos = teststart; payloadpos <= testend; payloadpos++)\n\t\t\t\t\t{\n\t\t\t\t\t\tpayload = GetPayload(handle, payload, payloadpos); // second last payload\n\t\t\t\t\t\tpayloadsize = GetPayloadSize(handle, payloadpos);\n\t\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\n\t\t\t\t\t\tif (ret != GPMF_OK)\n\t\t\t\t\t\t\tgoto cleanup;\n\n\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGPMF_stream find_stream2;\n\t\t\t\t\t\t\tGPMF_CopyState(ms, &find_stream2);\n\n\t\t\t\t\t\t\tpayloadcount++;\n\n\t\t\t\t\t\t\tif (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (repeatarray)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdouble in, out;\n\n\t\t\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tsamples++;\n\t\t\t\t\t\t\t\t\t} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));\n\n\t\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n\t\t\t\t\t\t\t\t\tmeanY += (double)samples;\n\n\t\t\t\t\t\t\t\t\tif (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n\t\t\t\t\t\t\t\t\t\tmeanX += out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tuint32_t repeat = GPMF_PayloadSampleCount(ms);\n\t\t\t\t\t\t\t\tsamples += repeat;\n\n\t\t\t\t\t\t\t\tif (repeatarray)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdouble in, out;\n\n\t\t\t\t\t\t\t\t\trepeatarray[payloadpos] = samples;\n\t\t\t\t\t\t\t\t\tmeanY += (double)samples;\n\n\t\t\t\t\t\t\t\t\tif (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n\t\t\t\t\t\t\t\t\t\tmeanX += out;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trepeatarray[payloadpos] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Compute the line of best fit for a jitter removed sample rate.  \n\t\t\t\t\t// This does assume an unchanging clock, even though the IMU data can thermally impacted causing small clock changes.  \n\t\t\t\t\t// TODO: Next enhancement would be a low order polynominal fit the compensate for any thermal clock drift.\n\t\t\t\t\tif (repeatarray)\n\t\t\t\t\t{\n\t\t\t\t\t\tmeanY /= (double)payloadcount;\n\t\t\t\t\t\tmeanX /= (double)payloadcount;\n\n\t\t\t\t\t\tfor (payloadpos = teststart; payloadpos <= testend; payloadpos++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdouble in, out;\n\t\t\t\t\t\t\tif (repeatarray[payloadpos] && GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttop += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);\n\t\t\t\t\t\t\t\tbot += ((double)out - meanX)*((double)out - meanX);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tslope = top / bot;\n\t\t\t\t\t\trate = slope;\n\n\t\t\t\t\t\t// This sample code might be useful for compare data latency between channels.\n\t\t\t\t\t\tintercept = meanY - slope * meanX;\n#if 0\n\t\t\t\t\t\tprintf(\"%c%c%c%c start offset = %f (%.3fms) rate = %f\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope, rate);\n\t\t\t\t\t\tprintf(\"%c%c%c%c first sample at time %.3fms\\n\", PRINTF_4CC(fourcc), -1000.0 * intercept / slope);\n#endif\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\trate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);\n\t\t\t\t\t}\n\n\t\t\t\t\tfree(repeatarray);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (firstsampletime && lastsampletime)\n\t\t\t{\n\t\t\t\tuint32_t endpayload = mp4->indexcount;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tendpayload--;// last payload with the fourcc needed\n\t\t\t\t\tpayload = GetPayload(handle, payload, endpayload);\n\t\t\t\t\tpayloadsize = GetPayloadSize(handle, endpayload);\n\t\t\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\t\t} while (endpayload > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));\n\n\t\t\t\tif (endpayload > 0 && ret == GPMF_OK)\n\t\t\t\t{\n\t\t\t\t\tuint32_t totalsamples = endsamples - startsamples;\n\t\t\t\t\tfloat timo = 0.0;\n\n\t\t\t\t\tGPMF_CopyState(ms, &find_stream);\n\t\t\t\t\tif (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_OFFSET, GPMF_CURRENT_LEVEL))\n\t\t\t\t\t\tGPMF_FormattedData(&find_stream, &timo, 4, 0, 1);\n\n\t\t\t\t\tdouble first, last;\n\t\t\t\t\tfirst = -intercept / rate - timo;\n\t\t\t\t\tlast = first + (double)totalsamples / rate;\n\n\t\t\t\t\t//printf(\"%c%c%c%c first sample at time %.3fms, last at %.3fms\\n\", PRINTF_4CC(fourcc), 1000.0*first, 1000.0*last);\n\n\t\t\t\t\tif (firstsampletime) *firstsampletime = first;\n\n\t\t\t\t\tif (lastsampletime) *lastsampletime = last;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tif (payload)\n\t\tFreePayload(payload);\n\tpayload = NULL;\n\n\treturn rate;\n}\n\n", "/*! @file mp4reader.h\n*\n*  @brief Way Too Crude MP4|MOV reader\n*\n*  @version 1.2.0\n*\n*  (C) Copyright 2017 GoPro Inc (http://gopro.com/).\n*\n*  Licensed under the Apache License, Version 2.0 (the \"License\");\n*  you may not use this file except in compliance with the License.\n*  You may obtain a copy of the License at\n*\n*      http://www.apache.org/licenses/LICENSE-2.0\n*\n*  Unless required by applicable law or agreed to in writing, software\n*  distributed under the License is distributed on an \"AS IS\" BASIS,\n*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n*  See the License for the specific language governing permissions and\n*  limitations under the License.\n*\n*/\n\n#ifndef _GPMF_MP4READER_H\n#define _GPMF_MP4READER_H\n\n#include \"../GPMF_parser.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct media_header\n{\n\tuint8_t version_flags[4];\n\tuint32_t creation_time;\n\tuint32_t modification_time;\n\tuint32_t time_scale;\n\tuint32_t duration;\n\tuint16_t language;\n\tuint16_t quality;\n} media_header;\n\n\ntypedef struct SampleToChunk\n{\n\tuint32_t chunk_num;\n\tuint32_t samples;\n\tuint32_t id;\n} SampleToChunk;\n\n\ntypedef struct mp4object\n{\n\tuint32_t *metasizes;\n\tuint32_t metasize_count;\n\tuint64_t *metaoffsets;\n\tSampleToChunk *metastsc;\n\tuint32_t metastsc_count;\n\tuint32_t indexcount;\n\tdouble videolength;\n\tdouble metadatalength;\n\tuint32_t clockdemon, clockcount;\n\tuint32_t trak_clockdemon, trak_clockcount;\n\tuint32_t meta_clockdemon, meta_clockcount;\n\tdouble basemetadataduration;\n\tFILE *mediafp;\n\tuint64_t filesize;\n\tuint64_t filepos;\n} mp4object;\n\n#define MAKEID(a,b,c,d)\t\t\t(((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))\n#define STR2FOURCC(s)\t\t\t((s[0]<<0)|(s[1]<<8)|(s[2]<<16)|(s[3]<<24))\n\n#define BYTESWAP64(a)\t\t\t(((a&0xff)<<56)|((a&0xff00)<<40)|((a&0xff0000)<<24)|((a&0xff000000)<<8) | ((a>>56)&0xff)|((a>>40)&0xff00)|((a>>24)&0xff0000)|((a>>8)&0xff000000) )\n#define BYTESWAP32(a)\t\t\t(((a&0xff)<<24)|((a&0xff00)<<8)|((a>>8)&0xff00)|((a>>24)&0xff))\n#define BYTESWAP16(a)\t\t\t((((a)>>8)&0xff)|(((a)<<8)&0xff00))\n#define NOSWAP8(a)\t\t\t\t(a)\n\n\n\n\n#define MOV_GPMF_TRAK_TYPE\t\tMAKEID('m', 'e', 't', 'a')\t\t// track is the type for metadata\n#define MOV_GPMF_TRAK_SUBTYPE\tMAKEID('g', 'p', 'm', 'd')\t\t// subtype is GPMF\n#define MOV_VIDE_TRAK_TYPE\t\tMAKEID('v', 'i', 'd', 'e')\t\t// MP4 track for video\n#define MOV_SOUN_TRAK_TYPE\t\tMAKEID('s', 'o', 'u', 'n')\t\t// MP4 track for audio\n#define MOV_AVC1_SUBTYPE\t\tMAKEID('a', 'v', 'c', '1')\t\t// subtype H264\n#define MOV_HVC1_SUBTYPE\t\tMAKEID('h', 'v', 'c', '1')\t\t// subtype H265\n#define MOV_MP4A_SUBTYPE\t\tMAKEID('m', 'p', '4', 'a')\t\t// subtype for audio\n#define MOV_CFHD_SUBTYPE\t\tMAKEID('C', 'F', 'H', 'D')\t\t// subtype is CineForm HD\n#define AVI_VIDS_TRAK_TYPE\t\tMAKEID('v', 'i', 'd', 's')\t\t// track is the type for video\n#define AVI_CFHD_SUBTYPE\t\tMAKEID('c', 'f', 'h', 'd')\t\t// subtype is CineForm HD\n\n#define NESTSIZE(x) { int i = nest; while (i > 0 && nestsize[i] > 0) { nestsize[i] -= x; if(nestsize[i]>=0 && nestsize[i] <= 8) { nestsize[i]=0; nest--; } i--; } }\n\n#define VALID_FOURCC(a)\t(((((a>>24)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>24)&0xff)>='A'&&((a>>24)&0xff)<='Z') || (((a>>24)&0xff)>='0'&&((a>>24)&0xff)<='9') || (((a>>24)&0xff)==' ') ) && \\\n\t\t\t\t\t\t( (((a>>16)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>16)&0xff)>='A'&&((a>>16)&0xff)<='Z') || (((a>>16)&0xff)>='0'&&((a>>16)&0xff)<='9') || (((a>>16)&0xff)==' ') ) && \\\n\t\t\t\t\t\t( (((a>>8)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>8)&0xff)>='A'&&((a>>8)&0xff)<='Z') || (((a>>8)&0xff)>='0'&&((a>>8)&0xff)<='9') || (((a>>8)&0xff)==' ') ) && \\\n\t\t\t\t\t\t( (((a>>0)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>0)&0xff)>='A'&&((a>>0)&0xff)<='Z') || (((a>>0)&0xff)>='0'&&((a>>0)&0xff)<='9') || (((a>>0)&0xff)==' ') )) \n\nsize_t OpenMP4Source(char *filename, uint32_t traktype, uint32_t subtype);\nsize_t OpenMP4SourceUDTA(char *filename);\nvoid CloseSource(size_t handle);\nfloat GetDuration(size_t handle);\nuint32_t GetNumberPayloads(size_t handle);\nuint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index);\nvoid FreePayload(uint32_t *lastpayload);\nuint32_t GetPayloadSize(size_t handle, uint32_t index);\nuint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out); //MP4 timestamps for the payload\nuint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator);\n\n#define GPMF_SAMPLE_RATE_FAST\t\t0\n#define GPMF_SAMPLE_RATE_PRECISE\t1\n\ndouble GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *in, double *out);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n"], "filenames": ["GPMF_parser.c", "GPMF_parser.h", "demo/GPMF_demo.c", "demo/GPMF_mp4reader.c", "demo/GPMF_mp4reader.h"], "buggy_code_start_loc": [5, 5, 48, 5, 66], "buggy_code_end_loc": [46, 130, 244, 971, 114], "fixing_code_start_loc": [5, 5, 49, 5, 67], "fixing_code_end_loc": [46, 134, 251, 1131, 115], "type": "CWE-787", "message": "GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c.", "other": {"cve": {"id": "CVE-2019-15148", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-18T19:15:10.620", "lastModified": "2019-08-22T17:06:30.960", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GoPro GPMF-parser 1.2.2 has an out-of-bounds write in OpenMP4Source in demo/GPMF_mp4reader.c."}, {"lang": "es", "value": "GoPro GPMF-parser versi\u00f3n 1.2.2, tiene  una escritura fuera de l\u00edmites en la funci\u00f3n OpenMP4Source en el archivo demo/GPMF_mp4reader.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gopro:gpmf-parser:1.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "BA83C3BC-F72D-453A-B3E4-DB1065FC99A6"}]}]}], "references": [{"url": "https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gopro/gpmf-parser/issues/60", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681"}}