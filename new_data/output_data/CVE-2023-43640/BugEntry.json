{"buggy_code": ["# A special purpose notes field that records the notes of someone observing one or more collection objects.\n#\n# Includes verbatim block of text (perhaps json too ultimately) that details observations on a collection object.\n# Should only include notes on CollectionObjects, not field observations, i.e. this is a precursor of a\n# CollectionObject instance.\n#\n# Example usages:\n# 1) Recording notes metadata about a image that contains multiple slides or non-emunmarated collection objects\n# 2) While working in a collection a user rapidly types all labels/metadata from a specimen into one field, and moves\n#     on.  This data is later broken down into individual records\n#\n# @!attribute data\n#   @return [String]\n#   @todo\n#\n# @!attribute project_id\n#   @return [Integer]\n#   the project ID\n#\nclass CollectionObjectObservation < ApplicationRecord\n  include Housekeeping\n  include Shared::Tags\n  include Shared::Notes\n  include Shared::Depictions\n  include Shared::IsData\n\n  ignore_whitespace_on(:data)\n\n  has_many :derived_collection_objects, inverse_of: :collection_object_observation\n  has_many :collection_objects, through: :derived_collection_objects\n\n  validates_presence_of :data\n\n  # @param [ActionController::Parameters] params\n  # @return [Scope]\n  def self.find_for_autocomplete(params)\n    term = \"#{params[:term]}%\"\n    where('data LIKE ? OR data ILIKE ? OR data = ?', term, \"#{term}%\", '%term')\n      .where(project_id: params[:project_id])\n  end\n\nend\n", "# Content is text related blocks, at present it only pertains to Otus.\n# It requires both a Topic and an Otu.\n# Future extensions may be added to use the model for Projects, etc. via STI.\n#\n# @!attribute text\n#   @return [String]\n#   The written content.\n#\n# @!attribute otu_id\n#   @return [Integer]\n#   When OtuContent::Text the id of the Otu the content pertains to.  At present required.\n#\n# @!attribute topic_id\n#   @return [Integer]\n#   When OtuContent::Text the id of the Topic the content pertains to. At present required.\n#\n# @!attribute project_id\n#   @return [Integer]\n#   the project ID\n#\n# @!attribute revision_id\n#   @return [Integer]\n#   Stubbed placeholder for Revision (sensus taxonomy) model. NOT PRESENTLY USED.\n#\nclass Content < ApplicationRecord\n  include Housekeeping\n  include Shared::Depictions\n  include Shared::Confidences\n  include Shared::Citations\n  include Shared::Attributions\n  include Shared::HasPapertrail\n  include Shared::DataAttributes # TODO: reconsider, why is this here?  Should be removed, use case is currently cross reference to an identifier, if required use Identifier\n  include Shared::IsData\n\n  ignore_whitespace_on(:text)\n\n  attr_accessor :is_public\n\n  after_save :publish, if: -> { (is_public == true) || is_public == '1' }\n  after_save :unpublish, if: -> { (is_public == false) || (is_public == '0') }\n\n  belongs_to :otu, inverse_of: :contents\n  belongs_to :topic, inverse_of: :contents\n  has_one :public_content, inverse_of: :content, dependent: :destroy\n  belongs_to :language\n\n  validate :topic_id_is_type_topic\n\n  validates_uniqueness_of :topic_id, scope: [:otu_id]\n  validates_presence_of :text, :topic_id, :otu_id\n\n  # scope :for_otu_page_layout, -> (otu_page_layout_id) {\n  #   where('otu_page_layout_id = ?', otu_page_layout.od)\n  # }\n\n  # @return [Boolean]\n  #    true if this content has been published\n  def is_published?\n    public_content.present?\n  end\n\n  # TODO: this will have to be updated in subclasses.\n  def publish\n    public_content.delete if public_content\n    PublicContent.create!(\n      content: self,\n      topic:,\n      text:,\n      otu:\n    )\n  end\n\n  def unpublish\n    public_content&.destroy\n  end\n\n  # OTU_PAGE_LAYOUTS\n  #       V\n  # OTU_PAGE_LAYOUT_SECTIONS ^ .otu_page_layout_id v .topic_id\n  #       V\n  #     TOPICS\n  #       V\n  #    CONTENTS              v otu_id              ^ .topic_id\n  #       ^\n  #      OTU\n  #\n  # Given an otu_page_layout id. find all the topics\n  # For this otu_page_layout, find the topics (ControlledVocabularyTerm.of_type(:topic))\n\n  def self.for_page_layout(otu_page_layout_id)\n    where('topic_id in (?)', OtuPageLayout.where(id: otu_page_layout_id).first.topics.pluck(:id))\n  end\n\n  def self.find_for_autocomplete(params)\n    where('text ILIKE ? OR text ILIKE ?', \"#{params[:term]}%\", \"%#{params[:term]}%\")\n  end\n\n  def self.used_recently(user_id, project_id)\n    Content.touched_by(user_id).where(project_id:).order(updated_at: :desc).limit(6).to_a\n  end\n\n  def self.select_optimized(user_id, project_id)\n    r = used_recently(user_id, project_id)\n\n    h = {\n      quick: Content.pinned_by(user_id).pinboard_inserted.where(project_id:).to_a,\n      pinboard: Content.pinned_by(user_id).where(project_id:).to_a,\n      recent: used_recently(user_id, project_id)\n    }\n\n    h\n  end\n\n  private\n\n  def topic_id_is_type_topic\n    if topic_id\n      errors.add(:topic_id, 'is not a Topic id') if !Topic.find(topic_id)\n    end\n  end\nend\n", "# This is a 1:1 representation of ISO 639-2.\n# It is built on initialization with a rake task, and not further touched.\n# Many of the languages have multiple version (e.g. there are 4 variations of German)\n#\n# @!attribute alpha_3_bibiographic\n#   @return [String] attribute alpha_3_bibliographic always has a distinct 3 character value\n#\n# @!attribute alpha_3_terminologic\n#   @return [String]\n#\n# @!attribute alpha_2\n#   @return [String] alpha_2 will have either a 2 character value or and empty string ('')\n#\n# @!attribute english_name\n#   @return [String] english_name may be more than one word long\n#     (e.g. 'English, Middle (1100-1500)', 'Filipino; Pilipino','Finno-Ugrian languages')\n#\n# @!attribute french_name\n#   @return [String] french_name may be more than one word long\n#\nclass Language < ApplicationRecord\n  include Housekeeping::Users\n  include Housekeeping::Timestamps\n  include Shared::IsData\n  include Shared::IsApplicationData\n\n  has_many :serials, inverse_of: :language, foreign_key: :primary_language_id\n  has_many :sources, inverse_of: :source_language, class_name: 'Source::Bibtex'\n  has_many :alternate_value_translations, class_name: 'AlternateValue::Translation'\n\n  scope :used_recently_on_sources, -> { joins(sources: [:project_sources]).includes(sources: [:project_sources]).where(sources: { updated_at: 10.weeks.ago..Time.now } ).order('\"sources\".\"updated_at\" DESC') }\n\n\n  # TODO: dry\n  scope :used_recently_on_serials, -> { joins(:serials).includes(:serials).where(serials: { updated_at: 10.weeks.ago..Time.now } ).order('\"serials\".\"updated_at\" DESC') }\n  scope :used_recently_on_common_names, -> { joins(:common_names).includes(:common_names).where(common_names: { updated_at: 10.weeks.ago..Time.now } ).order('\"serials\".\"updated_at\" DESC') }\n  scope :used_recently_on_alternate_values, -> { joins(:alternate_value_translations).includes(:alternate_value_translations).where(alternate_values: { updated_at: 10.weeks.ago..Time.now } ).order('\"alternate_values\".\"updated_at\" DESC') }\n\n  scope :with_english_name_containing, ->(name) {where('english_name ILIKE ?', \"%#{name}%\")}  # non-case sensitive comparison\n\n  validates_presence_of :english_name, :alpha_3_bibliographic\n\n  def self.with_english_name_or_abbreviation(value)\n    value = [value] if value.class == String\n\n    t = Language.arel_table\n    a = t[:english_name].matches_any(value)\n    b = t[:alpha_2].matches_any(value)\n    c = t[:alpha_3_bibliographic].matches_any(value)\n    d = t[:alpha_3_terminologic].matches_any(value)\n    Language.where(a.or(b).or(c).or(d).to_sql)\n  end\n\n  def self.find_for_autocomplete(params)\n    term = \"#{params[:term]}%\"\n    where('english_name ILIKE ? OR english_name = ?', term, params[:term])\n  end\n\n  # @param klass ['Source' || 'Serial']\n  def self.select_optimized(user_id, project_id, klass = 'Source')\n    language_ids = case klass\n                   when 'Source'\n                     Language.used_recently_on_sources.where('project_sources.project_id = ? AND sources.updated_by_id = ?', project_id, user_id).pluck(:id).uniq\n                   when 'Serial'\n                     Language.used_recently_on_serials.where('serials.updated_by_id = ?', user_id).pluck(:id).uniq\n                   when 'AlternateValue'\n                     Language.used_recently_on_alternate_values.where('alternate_values.updated_by_id = ?', user_id).pluck(:id).uniq\n                   when 'CommonNames'\n                     Language.used_recently_on_alternate_values.where('alternate_values.updated_by_id = ?', user_id).pluck(:id).uniq\n                   end\n\n    h = {\n      recent: Language.where(id: language_ids.first(10)).order(:english_name).to_a,\n      pinboard: Language.pinned_by(user_id).pinned_in_project(project_id).to_a,\n      quick: (Language.pinned_by(user_id).pinboard_inserted.pinned_in_project(project_id).to_a + Language.where(id: language_ids.first(4)).order(:english_name).to_a).uniq\n    }\n    h\n  end\nend\n", "# A Topic is a user defined subject.  It is used in conjuction with a citation on an OTU.\n# Topics assert that \"this source says something about this taxon on this topic.\"\n#\nclass Topic < ControlledVocabularyTerm\n\n  # TODO: Why?!\n  include Shared::Tags\n\n  has_many :citation_topics, inverse_of: :topic, dependent: :destroy\n  has_many :citations, through: :citation_topics, inverse_of: :topics\n  has_many :sources, through: :citations, inverse_of: :topics\n  has_many :citation_objects, through: :citations, source_type: 'Citation'\n  has_many :contents, inverse_of: :topic, dependent: :destroy\n  has_many :public_contents, inverse_of: :topic, dependent: :destroy\n  has_many :otus, through: :contents\n\n  # TODO: Layout handling as a concern\n  has_many :otu_page_layout_sections, -> {\n    where(otu_page_layout_sections:\n          {type: 'OtuPageLayoutSection::StandardSection'}) }, inverse_of: :topic\n  has_many :otu_page_layouts, through: :otu_page_layout_sections\n\n  scope :used_on_klass, -> (klass) { joins(:citations).where(citations: {citation_object_type: klass}) }\n\n  # TODO: Deprecate for CVT + params (if not already done)\n  def self.find_for_autocomplete(params)\n    term = \"#{params[:term]}%\"\n    where_string = \"name LIKE '#{term}' OR name ILIKE '%#{term}' OR name = '#{term}' OR definition ILIKE '%#{term}'\"\n    ControlledVocabularyTerm.where(where_string).where(project_id: params[:project_id], type: 'Topic')\n  end\n\n  # @param used_on [String] one of `Citation` (default) or `Content`\n  # @return [Scope]\n  #    the max 10 most recently used topics, as used on Content or Citation\n  def self.used_recently(user_id, project_id, klass, used_on = 'Citation')\n    t = case used_on\n        when 'Citation'\n          CitationTopic.arel_table\n        when 'Content'\n          Content.arel_table\n        end\n\n    p = Topic.arel_table\n\n    # i is a select manager\n    i = t.project(t['topic_id'], t['updated_at']).from(t)\n      .where(t['updated_at'].gt(10.weeks.ago))\n      .where(t['updated_by_id'].eq(user_id))\n      .where(t['project_id'].eq(project_id))\n      .order(t['updated_at'].desc)\n\n    # z is a table alias\n    z = i.as('recent_t')\n\n    if klass.blank?\n      Topic.joins(\n          Arel::Nodes::InnerJoin.new(z, Arel::Nodes::On.new(z['topic_id'].eq(p['id'])))\n      ).pluck(:id).uniq\n    else\n      Topic.used_on_klass(klass).joins(\n          Arel::Nodes::InnerJoin.new(z, Arel::Nodes::On.new(z['topic_id'].eq(p['id'])))\n      ).pluck(:id).uniq\n    end\n  end\n\n  # @params klass [String] if target is `Citation` then if provided limits to those classes with citations,\n  # if `Content` then not used\n  # @params target [String] one of `Citation` or `Content`\n  # @params klass [String] like TaxonName, required if target == `Citation`\n  # @return [Hash] topics optimized for user selection\n  def self.select_optimized(user_id, project_id, klass, target = 'Citation')\n    r = used_recently(user_id, project_id, klass, target)\n    h = {\n        quick: [],\n        pinboard: Topic.pinned_by(user_id).where(project_id: project_id).to_a,\n        recent: []\n    }\n\n    if r.empty?\n      h[:quick] = Topic.pinned_by(user_id).pinboard_inserted.where(project_id: project_id).to_a\n    else\n      h[:recent] = Topic.where('\"controlled_vocabulary_terms\".\"id\" IN (?)', r.first(10) ).order(:name).to_a\n      h[:quick] = (Topic.pinned_by(user_id).pinboard_inserted.where(project_id: project_id).to_a +\n          Topic.where('\"controlled_vocabulary_terms\".\"id\" IN (?)', r.first(5) ).order(:name).to_a +\n          Topic.where(project_id: project_id, created_by_id: user_id, updated_at: (3.hours.ago..Time.now)).limit(5).to_a).uniq\n    end\n\n    h\n  end\n\nend\n"], "fixing_code": ["# A special purpose notes field that records the notes of someone observing one or more collection objects.\n#\n# Includes verbatim block of text (perhaps json too ultimately) that details observations on a collection object.\n# Should only include notes on CollectionObjects, not field observations, i.e. this is a precursor of a\n# CollectionObject instance.\n#\n# Example usages:\n# 1) Recording notes metadata about a image that contains multiple slides or non-emunmarated collection objects\n# 2) While working in a collection a user rapidly types all labels/metadata from a specimen into one field, and moves\n#     on.  This data is later broken down into individual records\n#\n# @!attribute data\n#   @return [String]\n#   @todo\n#\n# @!attribute project_id\n#   @return [Integer]\n#   the project ID\n#\nclass CollectionObjectObservation < ApplicationRecord\n  include Housekeeping\n  include Shared::Tags\n  include Shared::Notes\n  include Shared::Depictions\n  include Shared::IsData\n\n  ignore_whitespace_on(:data)\n\n  has_many :derived_collection_objects, inverse_of: :collection_object_observation\n  has_many :collection_objects, through: :derived_collection_objects\n\n  validates_presence_of :data\n\n  # @param [ActionController::Parameters] params\n  # @return [Scope]\n  def self.find_for_autocomplete(params)\n    where('data ILIKE ? OR data = ?', \"#{params[:term]}%\", params[:term])\n      .where(project_id: params[:project_id])\n  end\n\nend\n", "# Content is text related blocks, at present it only pertains to Otus.\n# It requires both a Topic and an Otu.\n# Future extensions may be added to use the model for Projects, etc. via STI.\n#\n# @!attribute text\n#   @return [String]\n#   The written content.\n#\n# @!attribute otu_id\n#   @return [Integer]\n#   When OtuContent::Text the id of the Otu the content pertains to.  At present required.\n#\n# @!attribute topic_id\n#   @return [Integer]\n#   When OtuContent::Text the id of the Topic the content pertains to. At present required.\n#\n# @!attribute project_id\n#   @return [Integer]\n#   the project ID\n#\n# @!attribute revision_id\n#   @return [Integer]\n#   Stubbed placeholder for Revision (sensus taxonomy) model. NOT PRESENTLY USED.\n#\nclass Content < ApplicationRecord\n  include Housekeeping\n  include Shared::Depictions\n  include Shared::Confidences\n  include Shared::Citations\n  include Shared::Attributions\n  include Shared::HasPapertrail\n  include Shared::DataAttributes # TODO: reconsider, why is this here?  Should be removed, use case is currently cross reference to an identifier, if required use Identifier\n  include Shared::IsData\n\n  ignore_whitespace_on(:text)\n\n  attr_accessor :is_public\n\n  after_save :publish, if: -> { (is_public == true) || is_public == '1' }\n  after_save :unpublish, if: -> { (is_public == false) || (is_public == '0') }\n\n  belongs_to :otu, inverse_of: :contents\n  belongs_to :topic, inverse_of: :contents\n  has_one :public_content, inverse_of: :content, dependent: :destroy\n  belongs_to :language\n\n  validate :topic_id_is_type_topic\n\n  validates_uniqueness_of :topic_id, scope: [:otu_id]\n  validates_presence_of :text, :topic_id, :otu_id\n\n  # scope :for_otu_page_layout, -> (otu_page_layout_id) {\n  #   where('otu_page_layout_id = ?', otu_page_layout.od)\n  # }\n\n  # @return [Boolean]\n  #    true if this content has been published\n  def is_published?\n    public_content.present?\n  end\n\n  # TODO: this will have to be updated in subclasses.\n  def publish\n    public_content.delete if public_content\n    PublicContent.create!(\n      content: self,\n      topic:,\n      text:,\n      otu:\n    )\n  end\n\n  def unpublish\n    public_content&.destroy\n  end\n\n  # OTU_PAGE_LAYOUTS\n  #       V\n  # OTU_PAGE_LAYOUT_SECTIONS ^ .otu_page_layout_id v .topic_id\n  #       V\n  #     TOPICS\n  #       V\n  #    CONTENTS              v otu_id              ^ .topic_id\n  #       ^\n  #      OTU\n  #\n  # Given an otu_page_layout id. find all the topics\n  # For this otu_page_layout, find the topics (ControlledVocabularyTerm.of_type(:topic))\n\n  def self.for_page_layout(otu_page_layout_id)\n    where('topic_id in (?)', OtuPageLayout.where(id: otu_page_layout_id).first.topics.pluck(:id))\n  end\n\n  def self.find_for_autocomplete(params)\n    where('text ILIKE ?', \"%#{params[:term]}%\")\n  end\n\n  def self.used_recently(user_id, project_id)\n    Content.touched_by(user_id).where(project_id:).order(updated_at: :desc).limit(6).to_a\n  end\n\n  def self.select_optimized(user_id, project_id)\n    r = used_recently(user_id, project_id)\n\n    h = {\n      quick: Content.pinned_by(user_id).pinboard_inserted.where(project_id:).to_a,\n      pinboard: Content.pinned_by(user_id).where(project_id:).to_a,\n      recent: used_recently(user_id, project_id)\n    }\n\n    h\n  end\n\n  private\n\n  def topic_id_is_type_topic\n    if topic_id\n      errors.add(:topic_id, 'is not a Topic id') if !Topic.find(topic_id)\n    end\n  end\nend\n", "# This is a 1:1 representation of ISO 639-2.\n# It is built on initialization with a rake task, and not further touched.\n# Many of the languages have multiple version (e.g. there are 4 variations of German)\n#\n# @!attribute alpha_3_bibiographic\n#   @return [String] attribute alpha_3_bibliographic always has a distinct 3 character value\n#\n# @!attribute alpha_3_terminologic\n#   @return [String]\n#\n# @!attribute alpha_2\n#   @return [String] alpha_2 will have either a 2 character value or and empty string ('')\n#\n# @!attribute english_name\n#   @return [String] english_name may be more than one word long\n#     (e.g. 'English, Middle (1100-1500)', 'Filipino; Pilipino','Finno-Ugrian languages')\n#\n# @!attribute french_name\n#   @return [String] french_name may be more than one word long\n#\nclass Language < ApplicationRecord\n  include Housekeeping::Users\n  include Housekeeping::Timestamps\n  include Shared::IsData\n  include Shared::IsApplicationData\n\n  has_many :serials, inverse_of: :language, foreign_key: :primary_language_id\n  has_many :sources, inverse_of: :source_language, class_name: 'Source::Bibtex'\n  has_many :alternate_value_translations, class_name: 'AlternateValue::Translation'\n\n  scope :used_recently_on_sources, -> { joins(sources: [:project_sources]).includes(sources: [:project_sources]).where(sources: { updated_at: 10.weeks.ago..Time.now } ).order('\"sources\".\"updated_at\" DESC') }\n\n\n  # TODO: dry\n  scope :used_recently_on_serials, -> { joins(:serials).includes(:serials).where(serials: { updated_at: 10.weeks.ago..Time.now } ).order('\"serials\".\"updated_at\" DESC') }\n  scope :used_recently_on_common_names, -> { joins(:common_names).includes(:common_names).where(common_names: { updated_at: 10.weeks.ago..Time.now } ).order('\"serials\".\"updated_at\" DESC') }\n  scope :used_recently_on_alternate_values, -> { joins(:alternate_value_translations).includes(:alternate_value_translations).where(alternate_values: { updated_at: 10.weeks.ago..Time.now } ).order('\"alternate_values\".\"updated_at\" DESC') }\n\n  scope :with_english_name_containing, ->(name) {where('english_name ILIKE ?', \"%#{name}%\")}  # non-case sensitive comparison\n\n  validates_presence_of :english_name, :alpha_3_bibliographic\n\n  def self.with_english_name_or_abbreviation(value)\n    value = [value] if value.class == String\n\n    t = Language.arel_table\n    a = t[:english_name].matches_any(value)\n    b = t[:alpha_2].matches_any(value)\n    c = t[:alpha_3_bibliographic].matches_any(value)\n    d = t[:alpha_3_terminologic].matches_any(value)\n    Language.where(a.or(b).or(c).or(d).to_sql)\n  end\n\n  def self.find_for_autocomplete(params)\n    where('english_name ILIKE ? OR english_name = ?', \"#{params[:term]}%\", params[:term])\n  end\n\n  # @param klass ['Source' || 'Serial']\n  def self.select_optimized(user_id, project_id, klass = 'Source')\n    language_ids = case klass\n                   when 'Source'\n                     Language.used_recently_on_sources.where('project_sources.project_id = ? AND sources.updated_by_id = ?', project_id, user_id).pluck(:id).uniq\n                   when 'Serial'\n                     Language.used_recently_on_serials.where('serials.updated_by_id = ?', user_id).pluck(:id).uniq\n                   when 'AlternateValue'\n                     Language.used_recently_on_alternate_values.where('alternate_values.updated_by_id = ?', user_id).pluck(:id).uniq\n                   when 'CommonNames'\n                     Language.used_recently_on_alternate_values.where('alternate_values.updated_by_id = ?', user_id).pluck(:id).uniq\n                   end\n\n    h = {\n      recent: Language.where(id: language_ids.first(10)).order(:english_name).to_a,\n      pinboard: Language.pinned_by(user_id).pinned_in_project(project_id).to_a,\n      quick: (Language.pinned_by(user_id).pinboard_inserted.pinned_in_project(project_id).to_a + Language.where(id: language_ids.first(4)).order(:english_name).to_a).uniq\n    }\n    h\n  end\nend\n", "# A Topic is a user defined subject.  It is used in conjuction with a citation on an OTU.\n# Topics assert that \"this source says something about this taxon on this topic.\"\n#\nclass Topic < ControlledVocabularyTerm\n\n  # TODO: Why?!\n  include Shared::Tags\n\n  has_many :citation_topics, inverse_of: :topic, dependent: :destroy\n  has_many :citations, through: :citation_topics, inverse_of: :topics\n  has_many :sources, through: :citations, inverse_of: :topics\n  has_many :citation_objects, through: :citations, source_type: 'Citation'\n  has_many :contents, inverse_of: :topic, dependent: :destroy\n  has_many :public_contents, inverse_of: :topic, dependent: :destroy\n  has_many :otus, through: :contents\n\n  # TODO: Layout handling as a concern\n  has_many :otu_page_layout_sections, -> {\n    where(otu_page_layout_sections:\n          {type: 'OtuPageLayoutSection::StandardSection'}) }, inverse_of: :topic\n  has_many :otu_page_layouts, through: :otu_page_layout_sections\n\n  scope :used_on_klass, -> (klass) { joins(:citations).where(citations: {citation_object_type: klass}) }\n\n  # TODO: Deprecate for CVT + params (if not already done)\n  def self.find_for_autocomplete(params)\n    term = params[:term]\n    ControlledVocabularyTerm\n      .where('name ILIKE ? OR name = ? OR definition ILIKE ?', \"%#{term}%\", term, \"%#{term}%\")\n      .where(project_id: params[:project_id], type: 'Topic')\n  end\n\n  # @param used_on [String] one of `Citation` (default) or `Content`\n  # @return [Scope]\n  #    the max 10 most recently used topics, as used on Content or Citation\n  def self.used_recently(user_id, project_id, klass, used_on = 'Citation')\n    t = case used_on\n        when 'Citation'\n          CitationTopic.arel_table\n        when 'Content'\n          Content.arel_table\n        end\n\n    p = Topic.arel_table\n\n    # i is a select manager\n    i = t.project(t['topic_id'], t['updated_at']).from(t)\n      .where(t['updated_at'].gt(10.weeks.ago))\n      .where(t['updated_by_id'].eq(user_id))\n      .where(t['project_id'].eq(project_id))\n      .order(t['updated_at'].desc)\n\n    # z is a table alias\n    z = i.as('recent_t')\n\n    if klass.blank?\n      Topic.joins(\n          Arel::Nodes::InnerJoin.new(z, Arel::Nodes::On.new(z['topic_id'].eq(p['id'])))\n      ).pluck(:id).uniq\n    else\n      Topic.used_on_klass(klass).joins(\n          Arel::Nodes::InnerJoin.new(z, Arel::Nodes::On.new(z['topic_id'].eq(p['id'])))\n      ).pluck(:id).uniq\n    end\n  end\n\n  # @params klass [String] if target is `Citation` then if provided limits to those classes with citations,\n  # if `Content` then not used\n  # @params target [String] one of `Citation` or `Content`\n  # @params klass [String] like TaxonName, required if target == `Citation`\n  # @return [Hash] topics optimized for user selection\n  def self.select_optimized(user_id, project_id, klass, target = 'Citation')\n    r = used_recently(user_id, project_id, klass, target)\n    h = {\n        quick: [],\n        pinboard: Topic.pinned_by(user_id).where(project_id: project_id).to_a,\n        recent: []\n    }\n\n    if r.empty?\n      h[:quick] = Topic.pinned_by(user_id).pinboard_inserted.where(project_id: project_id).to_a\n    else\n      h[:recent] = Topic.where('\"controlled_vocabulary_terms\".\"id\" IN (?)', r.first(10) ).order(:name).to_a\n      h[:quick] = (Topic.pinned_by(user_id).pinboard_inserted.where(project_id: project_id).to_a +\n          Topic.where('\"controlled_vocabulary_terms\".\"id\" IN (?)', r.first(5) ).order(:name).to_a +\n          Topic.where(project_id: project_id, created_by_id: user_id, updated_at: (3.hours.ago..Time.now)).limit(5).to_a).uniq\n    end\n\n    h\n  end\n\nend\n"], "filenames": ["app/models/collection_object_observation.rb", "app/models/content.rb", "app/models/language.rb", "app/models/topic.rb"], "buggy_code_start_loc": [37, 95, 55, 27], "buggy_code_end_loc": [39, 96, 57, 30], "fixing_code_start_loc": [37, 95, 55, 27], "fixing_code_end_loc": [38, 96, 56, 31], "type": "CWE-89", "message": "TaxonWorks is a web-based workbench designed for taxonomists and biodiversity scientists. Prior to version 0.34.0, a SQL injection vulnerability was found in TaxonWorks that allows authenticated attackers to extract arbitrary data from the TaxonWorks database (including the users table). This issue may lead to information disclosure. Version 0.34.0 contains a fix for the issue.\n", "other": {"cve": {"id": "CVE-2023-43640", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-22T18:15:12.243", "lastModified": "2023-09-25T17:38:59.270", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TaxonWorks is a web-based workbench designed for taxonomists and biodiversity scientists. Prior to version 0.34.0, a SQL injection vulnerability was found in TaxonWorks that allows authenticated attackers to extract arbitrary data from the TaxonWorks database (including the users table). This issue may lead to information disclosure. Version 0.34.0 contains a fix for the issue.\n"}, {"lang": "es", "value": "TaxonWorks es un banco de trabajo basado en web dise\u00f1ado para tax\u00f3nomos y cient\u00edficos de la biodiversidad. Antes de la versi\u00f3n 0.34.0, se encontr\u00f3 una vulnerabilidad de inyecci\u00f3n SQL en TaxonWorks que permit\u00eda a atacantes autenticados extraer datos arbitrarios de la base de datos de TaxonWorks (incluida la tabla de usuarios). Este problema puede dar lugar a la divulgaci\u00f3n de informaci\u00f3n. La versi\u00f3n 0.34.0 contiene una soluci\u00f3n para el problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:speciesfilegroup:taxonworks:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.34.0", "matchCriteriaId": "4433F93B-CC23-465C-B9A4-2F67DEFC4D6D"}]}]}], "references": [{"url": "https://github.com/SpeciesFileGroup/taxonworks/commit/a98f2dc610a541678e1e51af47659cd8b30179ae", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/SpeciesFileGroup/taxonworks/security/advisories/GHSA-m9p2-jxr6-4p6c", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/SpeciesFileGroup/taxonworks/commit/a98f2dc610a541678e1e51af47659cd8b30179ae"}}