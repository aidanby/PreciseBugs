{"buggy_code": ["#\n# Copyright (C) 2008-2010 Wayne Meissner\n#\n# This file is part of ruby-ffi.\n#\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n# * Redistributions in binary form must reproduce the above copyright notice\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n# * Neither the name of the Ruby FFI project nor the names of its contributors\n#   may be used to endorse or promote products derived from this software\n#   without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.#\n\nmodule FFI\n  CURRENT_PROCESS = USE_THIS_PROCESS_AS_LIBRARY = Object.new\n\n  # @param [#to_s] lib library name\n  # @return [String] library name formatted for current platform\n  # Transform a generic library name to a platform library name\n  # @example\n  #  # Linux\n  #  FFI.map_library_name 'c'     # -> \"libc.so.6\"\n  #  FFI.map_library_name 'jpeg'  # -> \"libjpeg.so\"\n  #  # Windows\n  #  FFI.map_library_name 'c'     # -> \"msvcrt.dll\"\n  #  FFI.map_library_name 'jpeg'  # -> \"jpeg.dll\"\n  def self.map_library_name(lib)\n    # Mangle the library name to reflect the native library naming conventions\n    lib = Library::LIBC if lib == 'c'\n\n    if lib && File.basename(lib) == lib\n      lib = Platform::LIBPREFIX + lib unless lib =~ /^#{Platform::LIBPREFIX}/\n      r = Platform::IS_GNU ? \"\\\\.so($|\\\\.[1234567890]+)\" : \"\\\\.#{Platform::LIBSUFFIX}$\"\n      lib += \".#{Platform::LIBSUFFIX}\" unless lib =~ /#{r}/\n    end\n\n    lib\n  end\n\n  # Exception raised when a function is not found in libraries\n  class NotFoundError < LoadError\n    def initialize(function, *libraries)\n      super(\"Function '#{function}' not found in [#{libraries[0].nil? ? 'current process' : libraries.join(\", \")}]\")\n    end\n  end\n\n  # This module is the base to use native functions.\n  #\n  # A basic usage may be:\n  #  require 'ffi'\n  #  \n  #  module Hello\n  #    extend FFI::Library\n  #    ffi_lib FFI::Library::LIBC\n  #    attach_function 'puts', [ :string ], :int\n  #  end\n  #  \n  #  Hello.puts(\"Hello, World\")\n  #\n  # \n  module Library\n    CURRENT_PROCESS = FFI::CURRENT_PROCESS\n    LIBC = FFI::Platform::LIBC\n\n    # @param mod extended object\n    # @return [nil]\n    # @raise {RuntimeError} if +mod+ is not a Module\n    # Test if extended object is a Module. If not, raise RuntimeError.\n    def self.extended(mod)\n      raise RuntimeError.new(\"must only be extended by module\") unless mod.kind_of?(Module)\n    end\n\n    \n    # @param [Array] names names of libraries to load\n    # @return [Array<DynamicLibrary>]\n    # @raise {LoadError} if a library cannot be opened\n    # Load native libraries.\n    def ffi_lib(*names)\n      raise LoadError.new(\"library names list must not be empty\") if names.empty?\n\n      lib_flags = defined?(@ffi_lib_flags) ? @ffi_lib_flags : FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL\n      ffi_libs = names.map do |name|\n\n        if name == FFI::CURRENT_PROCESS\n          FFI::DynamicLibrary.open(nil, FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL)\n\n        else\n          libnames = (name.is_a?(::Array) ? name : [ name ]).map(&:to_s).map { |n| [ n, FFI.map_library_name(n) ].uniq }.flatten.compact\n          lib = nil\n          errors = {}\n\n          libnames.each do |libname|\n            begin\n              orig = libname\n              lib = FFI::DynamicLibrary.open(libname, lib_flags)\n              break if lib\n\n            rescue Exception => ex\n              ldscript = false\n              if ex.message =~ /(([^ \\t()])+\\.so([^ \\t:()])*):([ \\t])*(invalid ELF header|file too short|invalid file format)/\n                if File.read($1) =~ /(?:GROUP|INPUT) *\\( *([^ \\)]+)/\n                  libname = $1\n                  ldscript = true\n                end\n              end\n\n              if ldscript\n                retry\n              else\n                # TODO better library lookup logic\n                unless libname.start_with?(\"/\")\n                  path = ['/usr/lib/','/usr/local/lib/'].find do |pth|\n                    File.exist?(pth + libname)\n                  end\n                  if path\n                    libname = path + libname\n                    retry\n                  end\n                end\n\n                libr = (orig == libname ? orig : \"#{orig} #{libname}\")\n                errors[libr] = ex\n              end\n            end\n          end\n\n          if lib.nil?\n            raise LoadError.new(errors.values.join(\".\\n\"))\n          end\n\n          # return the found lib\n          lib\n        end\n      end\n\n      @ffi_libs = ffi_libs\n    end\n\n    # Set the calling convention for {#attach_function} and {#callback}\n    #\n    # @see http://en.wikipedia.org/wiki/Stdcall#stdcall\n    # @note +:stdcall+ is typically used for attaching Windows API functions\n    #\n    # @param [Symbol] convention one of +:default+, +:stdcall+\n    # @return [Symbol] the new calling convention\n    def ffi_convention(convention = nil)\n      @ffi_convention ||= :default\n      @ffi_convention = convention if convention\n      @ffi_convention\n    end\n\n    # @see #ffi_lib\n    # @return [Array<FFI::DynamicLibrary>] array of currently loaded FFI libraries\n    # @raise [LoadError] if no libraries have been loaded (using {#ffi_lib})\n    # Get FFI libraries loaded using {#ffi_lib}.\n    def ffi_libraries\n      raise LoadError.new(\"no library specified\") if !defined?(@ffi_libs) || @ffi_libs.empty?\n      @ffi_libs\n    end\n\n    # Flags used in {#ffi_lib}.\n    #\n    # This map allows you to supply symbols to {#ffi_lib_flags} instead of\n    # the actual constants.\n    FlagsMap = {\n      :global => DynamicLibrary::RTLD_GLOBAL,\n      :local => DynamicLibrary::RTLD_LOCAL,\n      :lazy => DynamicLibrary::RTLD_LAZY,\n      :now => DynamicLibrary::RTLD_NOW\n    }\n\n    # Sets library flags for {#ffi_lib}.\n    #\n    # @example\n    #   ffi_lib_flags(:lazy, :local) # => 5\n    #\n    # @param [Symbol, \u2026] flags (see {FlagsMap})\n    # @return [Fixnum] the new value\n    def ffi_lib_flags(*flags)\n      @ffi_lib_flags = flags.inject(0) { |result, f| result | FlagsMap[f] }\n    end\n\n\n    ##\n    # @overload attach_function(func, args, returns, options = {})\n    #  @example attach function without an explicit name\n    #    module Foo\n    #      extend FFI::Library\n    #      ffi_lib FFI::Library::LIBC\n    #      attach_function :malloc, [:size_t], :pointer\n    #    end\n    #    # now callable via Foo.malloc\n    # @overload attach_function(name, func, args, returns, options = {})\n    #  @example attach function with an explicit name\n    #    module Bar\n    #      extend FFI::Library\n    #      ffi_lib FFI::Library::LIBC\n    #      attach_function :c_malloc, :malloc, [:size_t], :pointer\n    #    end\n    #    # now callable via Bar.c_malloc\n    #\n    # Attach C function +func+ to this module.\n    #\n    #\n    # @param [#to_s] name name of ruby method to attach as\n    # @param [#to_s] func name of C function to attach\n    # @param [Array<Symbol>] args an array of types\n    # @param [Symbol] returns type of return value\n    # @option options [Boolean] :blocking (@blocking) set to true if the C function is a blocking call\n    # @option options [Symbol] :convention (:default) calling convention (see {#ffi_convention})\n    # @option options [FFI::Enums] :enums\n    # @option options [Hash] :type_map\n    #\n    # @return [FFI::VariadicInvoker]\n    #\n    # @raise [FFI::NotFoundError] if +func+ cannot be found in the attached libraries (see {#ffi_lib})\n    def attach_function(name, func, args, returns = nil, options = nil)\n      mname, a2, a3, a4, a5 = name, func, args, returns, options\n      cname, arg_types, ret_type, opts = (a4 && (a2.is_a?(String) || a2.is_a?(Symbol))) ? [ a2, a3, a4, a5 ] : [ mname.to_s, a2, a3, a4 ]\n\n      # Convert :foo to the native type\n      arg_types = arg_types.map { |e| find_type(e) }\n      options = {\n        :convention => ffi_convention,\n        :type_map => defined?(@ffi_typedefs) ? @ffi_typedefs : nil,\n        :blocking => defined?(@blocking) && @blocking,\n        :enums => defined?(@ffi_enums) ? @ffi_enums : nil,\n      }\n\n      @blocking = false\n      options.merge!(opts) if opts && opts.is_a?(Hash)\n\n      # Try to locate the function in any of the libraries\n      invokers = []\n      ffi_libraries.each do |lib|\n        if invokers.empty?\n          begin\n            function = nil\n            function_names(cname, arg_types).find do |fname|\n              function = lib.find_function(fname)\n            end\n            raise LoadError unless function\n\n            invokers << if arg_types.length > 0 && arg_types[arg_types.length - 1] == FFI::NativeType::VARARGS\n              VariadicInvoker.new(function, arg_types, find_type(ret_type), options)\n\n            else\n              Function.new(find_type(ret_type), arg_types, function, options)\n            end\n\n          rescue LoadError\n          end\n        end\n      end\n      invoker = invokers.compact.shift\n      raise FFI::NotFoundError.new(cname.to_s, ffi_libraries.map { |lib| lib.name }) unless invoker\n\n      invoker.attach(self, mname.to_s)\n      invoker\n    end\n\n    # @param [#to_s] name function name\n    # @param [Array] arg_types function's argument types\n    # @return [Array<String>]\n    # This function returns a list of possible names to lookup.\n    # @note Function names on windows may be decorated if they are using stdcall. See\n    #   * http://en.wikipedia.org/wiki/Name_mangling#C_name_decoration_in_Microsoft_Windows\n    #   * http://msdn.microsoft.com/en-us/library/zxk0tw93%28v=VS.100%29.aspx\n    #   * http://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions#STDCALL\n    #   Note that decorated names can be overridden via def files.  Also note that the\n    #   windows api, although using, doesn't have decorated names.\n    def function_names(name, arg_types)\n      result = [name.to_s]\n      if ffi_convention == :stdcall\n        # Get the size of each parameter\n        size = arg_types.inject(0) do |mem, arg|\n          size = arg.size\n          # The size must be a multiple of 4\n          size += (4 - size) % 4\n          mem + size\n        end\n\n        result << \"_#{name.to_s}@#{size}\" # win32\n        result << \"#{name.to_s}@#{size}\" # win64\n      end\n      result\n    end\n\n    # @overload attach_variable(mname, cname, type)\n    #   @param [#to_s] mname name of ruby method to attach as\n    #   @param [#to_s] cname name of C variable to attach\n    #   @param [DataConverter, Struct, Symbol, Type] type C variable's type\n    #   @example\n    #     module Bar\n    #       extend FFI::Library\n    #       ffi_lib 'my_lib'\n    #       attach_variable :c_myvar, :myvar, :long\n    #     end\n    #     # now callable via Bar.c_myvar\n    # @overload attach_variable(cname, type)\n    #   @param [#to_s] mname name of ruby method to attach as\n    #   @param [DataConverter, Struct, Symbol, Type] type C variable's type\n    #   @example\n    #     module Bar\n    #       extend FFI::Library\n    #       ffi_lib 'my_lib'\n    #       attach_variable :myvar, :long\n    #     end\n    #     # now callable via Bar.myvar\n    # @return [DynamicLibrary::Symbol]\n    # @raise {FFI::NotFoundError} if +cname+ cannot be found in libraries\n    #\n    # Attach C variable +cname+ to this module.\n    def attach_variable(mname, a1, a2 = nil)\n      cname, type = a2 ? [ a1, a2 ] : [ mname.to_s, a1 ]\n      address = nil\n      ffi_libraries.each do |lib|\n        begin\n          address = lib.find_variable(cname.to_s)\n          break unless address.nil?\n        rescue LoadError\n        end\n      end\n\n      raise FFI::NotFoundError.new(cname, ffi_libraries) if address.nil? || address.null?\n      if type.is_a?(Class) && type < FFI::Struct\n        # If it is a global struct, just attach directly to the pointer\n        s = s = type.new(address) # Assigning twice to suppress unused variable warning\n        self.module_eval <<-code, __FILE__, __LINE__\n          @@ffi_gvar_#{mname} = s\n          def self.#{mname}\n            @@ffi_gvar_#{mname}\n          end\n        code\n\n      else\n        sc = Class.new(FFI::Struct)\n        sc.layout :gvar, find_type(type)\n        s = sc.new(address)\n        #\n        # Attach to this module as mname/mname=\n        #\n        self.module_eval <<-code, __FILE__, __LINE__\n          @@ffi_gvar_#{mname} = s\n          def self.#{mname}\n            @@ffi_gvar_#{mname}[:gvar]\n          end\n          def self.#{mname}=(value)\n            @@ffi_gvar_#{mname}[:gvar] = value\n          end\n        code\n\n      end\n\n      address\n    end\n\n\n    # @overload callback(name, params, ret)\n    #   @param name callback name to add to type map\n    #   @param [Array] params array of parameters' types\n    #   @param [DataConverter, Struct, Symbol, Type] ret callback return type\n    # @overload callback(params, ret)\n    #   @param [Array] params array of parameters' types\n    #   @param [DataConverter, Struct, Symbol, Type] ret callback return type\n    # @return [FFI::CallbackInfo]\n    def callback(*args)\n      raise ArgumentError, \"wrong number of arguments\" if args.length < 2 || args.length > 3\n      name, params, ret = if args.length == 3\n        args\n      else\n        [ nil, args[0], args[1] ]\n      end\n\n      native_params = params.map { |e| find_type(e) }\n      raise ArgumentError, \"callbacks cannot have variadic parameters\" if native_params.include?(FFI::Type::VARARGS)\n      options = Hash.new\n      options[:convention] = ffi_convention\n      options[:enums] = @ffi_enums if defined?(@ffi_enums)\n      cb = FFI::CallbackInfo.new(find_type(ret), native_params, options)\n\n      # Add to the symbol -> type map (unless there was no name)\n      unless name.nil?\n        typedef cb, name\n      end\n\n      cb\n    end\n\n    # Register or get an already registered type definition.\n    #\n    # To register a new type definition, +old+ should be a {FFI::Type}. +add+\n    # is in this case the type definition.\n    #\n    # If +old+ is a {DataConverter}, a {Type::Mapped} is returned.\n    #\n    # If +old+ is +:enum+\n    # * and +add+ is an +Array+, a call to {#enum} is made with +add+ as single parameter;\n    # * in others cases, +info+ is used to create a named enum.\n    #\n    # If +old+ is a key for type map, #typedef get +old+ type definition.\n    #\n    # @param [DataConverter, Symbol, Type] old\n    # @param [Symbol] add\n    # @param [Symbol] info\n    # @return [FFI::Enum, FFI::Type]\n    def typedef(old, add, info=nil)\n      @ffi_typedefs = Hash.new unless defined?(@ffi_typedefs)\n\n      @ffi_typedefs[add] = if old.kind_of?(FFI::Type)\n        old\n\n      elsif @ffi_typedefs.has_key?(old)\n        @ffi_typedefs[old]\n\n      elsif old.is_a?(DataConverter)\n        FFI::Type::Mapped.new(old)\n\n      elsif old == :enum\n        if add.kind_of?(Array)\n          self.enum(add)\n        else\n          self.enum(info, add)\n        end\n\n      else\n        FFI.find_type(old)\n      end\n    end\n\n    private\n    # Generic enum builder\n    #  @param [Class] klass can be one of FFI::Enum or FFI::Bitmask\n    #  @param args (see #enum or #bitmask)\n    def generic_enum(klass, *args)\n      native_type = args.first.kind_of?(FFI::Type) ? args.shift : nil\n      name, values = if args[0].kind_of?(Symbol) && args[1].kind_of?(Array)\n        [ args[0], args[1] ]\n      elsif args[0].kind_of?(Array)\n        [ nil, args[0] ]\n      else\n        [ nil, args ]\n      end\n      @ffi_enums = FFI::Enums.new unless defined?(@ffi_enums)\n      @ffi_enums << (e = native_type ? klass.new(native_type, values, name) : klass.new(values, name))\n\n      # If called with a name, add a typedef alias\n      typedef(e, name) if name\n      e\n    end\n\n    public\n    # @overload enum(name, values)\n    #  Create a named enum.\n    #  @example\n    #   enum :foo, [:zero, :one, :two]  # named enum\n    #  @param [Symbol] name name for new enum\n    #  @param [Array] values values for enum\n    # @overload enum(*args)\n    #  Create an unnamed enum.\n    #  @example\n    #   enum :zero, :one, :two  # unnamed enum\n    #  @param args values for enum\n    # @overload enum(values)\n    #  Create an unnamed enum.\n    #  @example\n    #   enum [:zero, :one, :two]  # unnamed enum, equivalent to above example\n    #  @param [Array] values values for enum\n    # @overload enum(native_type, name, values)\n    #  Create a named enum and specify the native type.\n    #  @example\n    #   enum FFI::Type::UINT64, :foo, [:zero, :one, :two]  # named enum\n    #  @param [FFI::Type] native_type native type for new enum\n    #  @param [Symbol] name name for new enum\n    #  @param [Array] values values for enum\n    # @overload enum(native_type, *args)\n    #  Create an unnamed enum and specify the native type.\n    #  @example\n    #   enum FFI::Type::UINT64, :zero, :one, :two  # unnamed enum\n    #  @param [FFI::Type] native_type native type for new enum\n    #  @param args values for enum\n    # @overload enum(native_type, values)\n    #  Create an unnamed enum and specify the native type.\n    #  @example\n    #   enum Type::UINT64, [:zero, :one, :two]  # unnamed enum, equivalent to above example\n    #  @param [FFI::Type] native_type native type for new enum\n    #  @param [Array] values values for enum\n    # @return [FFI::Enum]\n    # Create a new {FFI::Enum}.\n    def enum(*args)\n      generic_enum(FFI::Enum, *args)\n    end\n\n    # @overload bitmask(name, values)\n    #  Create a named bitmask\n    #  @example\n    #   bitmask :foo, [:red, :green, :blue] # bits 0,1,2 are used\n    #   bitmask :foo, [:red, :green, 5, :blue] # bits 0,5,6 are used\n    #  @param [Symbol] name for new bitmask\n    #  @param [Array<Symbol, Integer>] values for new bitmask\n    # @overload bitmask(*args)\n    #  Create an unamed bitmask\n    #  @example\n    #   bm = bitmask :red, :green, :blue # bits 0,1,2 are used\n    #   bm = bitmask :red, :green, 5, blue # bits 0,5,6 are used\n    #  @param [Symbol, Integer] args values for new bitmask\n    # @overload bitmask(values)\n    #  Create an unamed bitmask\n    #  @example\n    #   bm = bitmask [:red, :green, :blue] # bits 0,1,2 are used\n    #   bm = bitmask [:red, :green, 5, blue] # bits 0,5,6 are used\n    #  @param [Array<Symbol, Integer>] values for new bitmask\n    # @overload bitmask(native_type, name, values)\n    #  Create a named enum and specify the native type.\n    #  @example\n    #   bitmask FFI::Type::UINT64, :foo, [:red, :green, :blue]\n    #  @param [FFI::Type] native_type native type for new bitmask\n    #  @param [Symbol] name for new bitmask\n    #  @param [Array<Symbol, Integer>] values for new bitmask\n    # @overload bitmask(native_type, *args)\n    #  @example\n    #   bitmask FFI::Type::UINT64, :red, :green, :blue\n    #  @param [FFI::Type] native_type native type for new bitmask\n    #  @param [Symbol, Integer] args values for new bitmask\n    # @overload bitmask(native_type, values)\n    #  Create a named enum and specify the native type.\n    #  @example\n    #   bitmask FFI::Type::UINT64, [:red, :green, :blue]\n    #  @param [FFI::Type] native_type native type for new bitmask\n    #  @param [Array<Symbol, Integer>] values for new bitmask\n    # @return [FFI::Bitmask]\n    # Create a new FFI::Bitmask\n    def bitmask(*args)\n      generic_enum(FFI::Bitmask, *args)\n    end\n\n    # @param name\n    # @return [FFI::Enum]\n    # Find an enum by name.\n    def enum_type(name)\n      @ffi_enums.find(name) if defined?(@ffi_enums)\n    end\n\n    # @param symbol\n    # @return [FFI::Enum]\n    # Find an enum by a symbol it contains.\n    def enum_value(symbol)\n      @ffi_enums.__map_symbol(symbol)\n    end\n\n    # @param [DataConverter, Type, Struct, Symbol] t type to find\n    # @return [Type]\n    # Find a type definition.\n    def find_type(t)\n      if t.kind_of?(Type)\n        t\n\n      elsif defined?(@ffi_typedefs) && @ffi_typedefs.has_key?(t)\n        @ffi_typedefs[t]\n\n      elsif t.is_a?(Class) && t < Struct\n        Type::POINTER\n\n      elsif t.is_a?(DataConverter)\n        # Add a typedef so next time the converter is used, it hits the cache\n        typedef Type::Mapped.new(t), t\n\n      end || FFI.find_type(t)\n    end\n  end\nend\n"], "fixing_code": ["#\n# Copyright (C) 2008-2010 Wayne Meissner\n#\n# This file is part of ruby-ffi.\n#\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n# * Redistributions in binary form must reproduce the above copyright notice\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n# * Neither the name of the Ruby FFI project nor the names of its contributors\n#   may be used to endorse or promote products derived from this software\n#   without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.#\n\nmodule FFI\n  CURRENT_PROCESS = USE_THIS_PROCESS_AS_LIBRARY = Object.new\n\n  # @param [#to_s] lib library name\n  # @return [String] library name formatted for current platform\n  # Transform a generic library name to a platform library name\n  # @example\n  #  # Linux\n  #  FFI.map_library_name 'c'     # -> \"libc.so.6\"\n  #  FFI.map_library_name 'jpeg'  # -> \"libjpeg.so\"\n  #  # Windows\n  #  FFI.map_library_name 'c'     # -> \"msvcrt.dll\"\n  #  FFI.map_library_name 'jpeg'  # -> \"jpeg.dll\"\n  def self.map_library_name(lib)\n    # Mangle the library name to reflect the native library naming conventions\n    lib = Library::LIBC if lib == 'c'\n\n    if lib && File.basename(lib) == lib\n      lib = Platform::LIBPREFIX + lib unless lib =~ /^#{Platform::LIBPREFIX}/\n      r = Platform::IS_GNU ? \"\\\\.so($|\\\\.[1234567890]+)\" : \"\\\\.#{Platform::LIBSUFFIX}$\"\n      lib += \".#{Platform::LIBSUFFIX}\" unless lib =~ /#{r}/\n    end\n\n    lib\n  end\n\n  # Exception raised when a function is not found in libraries\n  class NotFoundError < LoadError\n    def initialize(function, *libraries)\n      super(\"Function '#{function}' not found in [#{libraries[0].nil? ? 'current process' : libraries.join(\", \")}]\")\n    end\n  end\n\n  # This module is the base to use native functions.\n  #\n  # A basic usage may be:\n  #  require 'ffi'\n  #  \n  #  module Hello\n  #    extend FFI::Library\n  #    ffi_lib FFI::Library::LIBC\n  #    attach_function 'puts', [ :string ], :int\n  #  end\n  #  \n  #  Hello.puts(\"Hello, World\")\n  #\n  # \n  module Library\n    CURRENT_PROCESS = FFI::CURRENT_PROCESS\n    LIBC = FFI::Platform::LIBC\n\n    # @param mod extended object\n    # @return [nil]\n    # @raise {RuntimeError} if +mod+ is not a Module\n    # Test if extended object is a Module. If not, raise RuntimeError.\n    def self.extended(mod)\n      raise RuntimeError.new(\"must only be extended by module\") unless mod.kind_of?(Module)\n    end\n\n    \n    # @param [Array] names names of libraries to load\n    # @return [Array<DynamicLibrary>]\n    # @raise {LoadError} if a library cannot be opened\n    # Load native libraries.\n    def ffi_lib(*names)\n      raise LoadError.new(\"library names list must not be empty\") if names.empty?\n\n      lib_flags = defined?(@ffi_lib_flags) ? @ffi_lib_flags : FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL\n      ffi_libs = names.map do |name|\n\n        if name == FFI::CURRENT_PROCESS\n          FFI::DynamicLibrary.open(nil, FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL)\n\n        else\n          libnames = (name.is_a?(::Array) ? name : [ name ]).map(&:to_s).map { |n| [ n, FFI.map_library_name(n) ].uniq }.flatten.compact\n          lib = nil\n          errors = {}\n\n          libnames.each do |libname|\n            begin\n              orig = libname\n              lib = FFI::DynamicLibrary.open(libname, lib_flags)\n              break if lib\n\n            rescue Exception => ex\n              ldscript = false\n              if ex.message =~ /(([^ \\t()])+\\.so([^ \\t:()])*):([ \\t])*(invalid ELF header|file too short|invalid file format)/\n                if File.read($1) =~ /(?:GROUP|INPUT) *\\( *([^ \\)]+)/\n                  libname = $1\n                  ldscript = true\n                end\n              end\n\n              if ldscript\n                retry\n              else\n                # TODO better library lookup logic\n                unless libname.start_with?(\"/\") || FFI::Platform.windows?\n                  path = ['/usr/lib/','/usr/local/lib/'].find do |pth|\n                    File.exist?(pth + libname)\n                  end\n                  if path\n                    libname = path + libname\n                    retry\n                  end\n                end\n\n                libr = (orig == libname ? orig : \"#{orig} #{libname}\")\n                errors[libr] = ex\n              end\n            end\n          end\n\n          if lib.nil?\n            raise LoadError.new(errors.values.join(\".\\n\"))\n          end\n\n          # return the found lib\n          lib\n        end\n      end\n\n      @ffi_libs = ffi_libs\n    end\n\n    # Set the calling convention for {#attach_function} and {#callback}\n    #\n    # @see http://en.wikipedia.org/wiki/Stdcall#stdcall\n    # @note +:stdcall+ is typically used for attaching Windows API functions\n    #\n    # @param [Symbol] convention one of +:default+, +:stdcall+\n    # @return [Symbol] the new calling convention\n    def ffi_convention(convention = nil)\n      @ffi_convention ||= :default\n      @ffi_convention = convention if convention\n      @ffi_convention\n    end\n\n    # @see #ffi_lib\n    # @return [Array<FFI::DynamicLibrary>] array of currently loaded FFI libraries\n    # @raise [LoadError] if no libraries have been loaded (using {#ffi_lib})\n    # Get FFI libraries loaded using {#ffi_lib}.\n    def ffi_libraries\n      raise LoadError.new(\"no library specified\") if !defined?(@ffi_libs) || @ffi_libs.empty?\n      @ffi_libs\n    end\n\n    # Flags used in {#ffi_lib}.\n    #\n    # This map allows you to supply symbols to {#ffi_lib_flags} instead of\n    # the actual constants.\n    FlagsMap = {\n      :global => DynamicLibrary::RTLD_GLOBAL,\n      :local => DynamicLibrary::RTLD_LOCAL,\n      :lazy => DynamicLibrary::RTLD_LAZY,\n      :now => DynamicLibrary::RTLD_NOW\n    }\n\n    # Sets library flags for {#ffi_lib}.\n    #\n    # @example\n    #   ffi_lib_flags(:lazy, :local) # => 5\n    #\n    # @param [Symbol, \u2026] flags (see {FlagsMap})\n    # @return [Fixnum] the new value\n    def ffi_lib_flags(*flags)\n      @ffi_lib_flags = flags.inject(0) { |result, f| result | FlagsMap[f] }\n    end\n\n\n    ##\n    # @overload attach_function(func, args, returns, options = {})\n    #  @example attach function without an explicit name\n    #    module Foo\n    #      extend FFI::Library\n    #      ffi_lib FFI::Library::LIBC\n    #      attach_function :malloc, [:size_t], :pointer\n    #    end\n    #    # now callable via Foo.malloc\n    # @overload attach_function(name, func, args, returns, options = {})\n    #  @example attach function with an explicit name\n    #    module Bar\n    #      extend FFI::Library\n    #      ffi_lib FFI::Library::LIBC\n    #      attach_function :c_malloc, :malloc, [:size_t], :pointer\n    #    end\n    #    # now callable via Bar.c_malloc\n    #\n    # Attach C function +func+ to this module.\n    #\n    #\n    # @param [#to_s] name name of ruby method to attach as\n    # @param [#to_s] func name of C function to attach\n    # @param [Array<Symbol>] args an array of types\n    # @param [Symbol] returns type of return value\n    # @option options [Boolean] :blocking (@blocking) set to true if the C function is a blocking call\n    # @option options [Symbol] :convention (:default) calling convention (see {#ffi_convention})\n    # @option options [FFI::Enums] :enums\n    # @option options [Hash] :type_map\n    #\n    # @return [FFI::VariadicInvoker]\n    #\n    # @raise [FFI::NotFoundError] if +func+ cannot be found in the attached libraries (see {#ffi_lib})\n    def attach_function(name, func, args, returns = nil, options = nil)\n      mname, a2, a3, a4, a5 = name, func, args, returns, options\n      cname, arg_types, ret_type, opts = (a4 && (a2.is_a?(String) || a2.is_a?(Symbol))) ? [ a2, a3, a4, a5 ] : [ mname.to_s, a2, a3, a4 ]\n\n      # Convert :foo to the native type\n      arg_types = arg_types.map { |e| find_type(e) }\n      options = {\n        :convention => ffi_convention,\n        :type_map => defined?(@ffi_typedefs) ? @ffi_typedefs : nil,\n        :blocking => defined?(@blocking) && @blocking,\n        :enums => defined?(@ffi_enums) ? @ffi_enums : nil,\n      }\n\n      @blocking = false\n      options.merge!(opts) if opts && opts.is_a?(Hash)\n\n      # Try to locate the function in any of the libraries\n      invokers = []\n      ffi_libraries.each do |lib|\n        if invokers.empty?\n          begin\n            function = nil\n            function_names(cname, arg_types).find do |fname|\n              function = lib.find_function(fname)\n            end\n            raise LoadError unless function\n\n            invokers << if arg_types.length > 0 && arg_types[arg_types.length - 1] == FFI::NativeType::VARARGS\n              VariadicInvoker.new(function, arg_types, find_type(ret_type), options)\n\n            else\n              Function.new(find_type(ret_type), arg_types, function, options)\n            end\n\n          rescue LoadError\n          end\n        end\n      end\n      invoker = invokers.compact.shift\n      raise FFI::NotFoundError.new(cname.to_s, ffi_libraries.map { |lib| lib.name }) unless invoker\n\n      invoker.attach(self, mname.to_s)\n      invoker\n    end\n\n    # @param [#to_s] name function name\n    # @param [Array] arg_types function's argument types\n    # @return [Array<String>]\n    # This function returns a list of possible names to lookup.\n    # @note Function names on windows may be decorated if they are using stdcall. See\n    #   * http://en.wikipedia.org/wiki/Name_mangling#C_name_decoration_in_Microsoft_Windows\n    #   * http://msdn.microsoft.com/en-us/library/zxk0tw93%28v=VS.100%29.aspx\n    #   * http://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions#STDCALL\n    #   Note that decorated names can be overridden via def files.  Also note that the\n    #   windows api, although using, doesn't have decorated names.\n    def function_names(name, arg_types)\n      result = [name.to_s]\n      if ffi_convention == :stdcall\n        # Get the size of each parameter\n        size = arg_types.inject(0) do |mem, arg|\n          size = arg.size\n          # The size must be a multiple of 4\n          size += (4 - size) % 4\n          mem + size\n        end\n\n        result << \"_#{name.to_s}@#{size}\" # win32\n        result << \"#{name.to_s}@#{size}\" # win64\n      end\n      result\n    end\n\n    # @overload attach_variable(mname, cname, type)\n    #   @param [#to_s] mname name of ruby method to attach as\n    #   @param [#to_s] cname name of C variable to attach\n    #   @param [DataConverter, Struct, Symbol, Type] type C variable's type\n    #   @example\n    #     module Bar\n    #       extend FFI::Library\n    #       ffi_lib 'my_lib'\n    #       attach_variable :c_myvar, :myvar, :long\n    #     end\n    #     # now callable via Bar.c_myvar\n    # @overload attach_variable(cname, type)\n    #   @param [#to_s] mname name of ruby method to attach as\n    #   @param [DataConverter, Struct, Symbol, Type] type C variable's type\n    #   @example\n    #     module Bar\n    #       extend FFI::Library\n    #       ffi_lib 'my_lib'\n    #       attach_variable :myvar, :long\n    #     end\n    #     # now callable via Bar.myvar\n    # @return [DynamicLibrary::Symbol]\n    # @raise {FFI::NotFoundError} if +cname+ cannot be found in libraries\n    #\n    # Attach C variable +cname+ to this module.\n    def attach_variable(mname, a1, a2 = nil)\n      cname, type = a2 ? [ a1, a2 ] : [ mname.to_s, a1 ]\n      address = nil\n      ffi_libraries.each do |lib|\n        begin\n          address = lib.find_variable(cname.to_s)\n          break unless address.nil?\n        rescue LoadError\n        end\n      end\n\n      raise FFI::NotFoundError.new(cname, ffi_libraries) if address.nil? || address.null?\n      if type.is_a?(Class) && type < FFI::Struct\n        # If it is a global struct, just attach directly to the pointer\n        s = s = type.new(address) # Assigning twice to suppress unused variable warning\n        self.module_eval <<-code, __FILE__, __LINE__\n          @@ffi_gvar_#{mname} = s\n          def self.#{mname}\n            @@ffi_gvar_#{mname}\n          end\n        code\n\n      else\n        sc = Class.new(FFI::Struct)\n        sc.layout :gvar, find_type(type)\n        s = sc.new(address)\n        #\n        # Attach to this module as mname/mname=\n        #\n        self.module_eval <<-code, __FILE__, __LINE__\n          @@ffi_gvar_#{mname} = s\n          def self.#{mname}\n            @@ffi_gvar_#{mname}[:gvar]\n          end\n          def self.#{mname}=(value)\n            @@ffi_gvar_#{mname}[:gvar] = value\n          end\n        code\n\n      end\n\n      address\n    end\n\n\n    # @overload callback(name, params, ret)\n    #   @param name callback name to add to type map\n    #   @param [Array] params array of parameters' types\n    #   @param [DataConverter, Struct, Symbol, Type] ret callback return type\n    # @overload callback(params, ret)\n    #   @param [Array] params array of parameters' types\n    #   @param [DataConverter, Struct, Symbol, Type] ret callback return type\n    # @return [FFI::CallbackInfo]\n    def callback(*args)\n      raise ArgumentError, \"wrong number of arguments\" if args.length < 2 || args.length > 3\n      name, params, ret = if args.length == 3\n        args\n      else\n        [ nil, args[0], args[1] ]\n      end\n\n      native_params = params.map { |e| find_type(e) }\n      raise ArgumentError, \"callbacks cannot have variadic parameters\" if native_params.include?(FFI::Type::VARARGS)\n      options = Hash.new\n      options[:convention] = ffi_convention\n      options[:enums] = @ffi_enums if defined?(@ffi_enums)\n      cb = FFI::CallbackInfo.new(find_type(ret), native_params, options)\n\n      # Add to the symbol -> type map (unless there was no name)\n      unless name.nil?\n        typedef cb, name\n      end\n\n      cb\n    end\n\n    # Register or get an already registered type definition.\n    #\n    # To register a new type definition, +old+ should be a {FFI::Type}. +add+\n    # is in this case the type definition.\n    #\n    # If +old+ is a {DataConverter}, a {Type::Mapped} is returned.\n    #\n    # If +old+ is +:enum+\n    # * and +add+ is an +Array+, a call to {#enum} is made with +add+ as single parameter;\n    # * in others cases, +info+ is used to create a named enum.\n    #\n    # If +old+ is a key for type map, #typedef get +old+ type definition.\n    #\n    # @param [DataConverter, Symbol, Type] old\n    # @param [Symbol] add\n    # @param [Symbol] info\n    # @return [FFI::Enum, FFI::Type]\n    def typedef(old, add, info=nil)\n      @ffi_typedefs = Hash.new unless defined?(@ffi_typedefs)\n\n      @ffi_typedefs[add] = if old.kind_of?(FFI::Type)\n        old\n\n      elsif @ffi_typedefs.has_key?(old)\n        @ffi_typedefs[old]\n\n      elsif old.is_a?(DataConverter)\n        FFI::Type::Mapped.new(old)\n\n      elsif old == :enum\n        if add.kind_of?(Array)\n          self.enum(add)\n        else\n          self.enum(info, add)\n        end\n\n      else\n        FFI.find_type(old)\n      end\n    end\n\n    private\n    # Generic enum builder\n    #  @param [Class] klass can be one of FFI::Enum or FFI::Bitmask\n    #  @param args (see #enum or #bitmask)\n    def generic_enum(klass, *args)\n      native_type = args.first.kind_of?(FFI::Type) ? args.shift : nil\n      name, values = if args[0].kind_of?(Symbol) && args[1].kind_of?(Array)\n        [ args[0], args[1] ]\n      elsif args[0].kind_of?(Array)\n        [ nil, args[0] ]\n      else\n        [ nil, args ]\n      end\n      @ffi_enums = FFI::Enums.new unless defined?(@ffi_enums)\n      @ffi_enums << (e = native_type ? klass.new(native_type, values, name) : klass.new(values, name))\n\n      # If called with a name, add a typedef alias\n      typedef(e, name) if name\n      e\n    end\n\n    public\n    # @overload enum(name, values)\n    #  Create a named enum.\n    #  @example\n    #   enum :foo, [:zero, :one, :two]  # named enum\n    #  @param [Symbol] name name for new enum\n    #  @param [Array] values values for enum\n    # @overload enum(*args)\n    #  Create an unnamed enum.\n    #  @example\n    #   enum :zero, :one, :two  # unnamed enum\n    #  @param args values for enum\n    # @overload enum(values)\n    #  Create an unnamed enum.\n    #  @example\n    #   enum [:zero, :one, :two]  # unnamed enum, equivalent to above example\n    #  @param [Array] values values for enum\n    # @overload enum(native_type, name, values)\n    #  Create a named enum and specify the native type.\n    #  @example\n    #   enum FFI::Type::UINT64, :foo, [:zero, :one, :two]  # named enum\n    #  @param [FFI::Type] native_type native type for new enum\n    #  @param [Symbol] name name for new enum\n    #  @param [Array] values values for enum\n    # @overload enum(native_type, *args)\n    #  Create an unnamed enum and specify the native type.\n    #  @example\n    #   enum FFI::Type::UINT64, :zero, :one, :two  # unnamed enum\n    #  @param [FFI::Type] native_type native type for new enum\n    #  @param args values for enum\n    # @overload enum(native_type, values)\n    #  Create an unnamed enum and specify the native type.\n    #  @example\n    #   enum Type::UINT64, [:zero, :one, :two]  # unnamed enum, equivalent to above example\n    #  @param [FFI::Type] native_type native type for new enum\n    #  @param [Array] values values for enum\n    # @return [FFI::Enum]\n    # Create a new {FFI::Enum}.\n    def enum(*args)\n      generic_enum(FFI::Enum, *args)\n    end\n\n    # @overload bitmask(name, values)\n    #  Create a named bitmask\n    #  @example\n    #   bitmask :foo, [:red, :green, :blue] # bits 0,1,2 are used\n    #   bitmask :foo, [:red, :green, 5, :blue] # bits 0,5,6 are used\n    #  @param [Symbol] name for new bitmask\n    #  @param [Array<Symbol, Integer>] values for new bitmask\n    # @overload bitmask(*args)\n    #  Create an unamed bitmask\n    #  @example\n    #   bm = bitmask :red, :green, :blue # bits 0,1,2 are used\n    #   bm = bitmask :red, :green, 5, blue # bits 0,5,6 are used\n    #  @param [Symbol, Integer] args values for new bitmask\n    # @overload bitmask(values)\n    #  Create an unamed bitmask\n    #  @example\n    #   bm = bitmask [:red, :green, :blue] # bits 0,1,2 are used\n    #   bm = bitmask [:red, :green, 5, blue] # bits 0,5,6 are used\n    #  @param [Array<Symbol, Integer>] values for new bitmask\n    # @overload bitmask(native_type, name, values)\n    #  Create a named enum and specify the native type.\n    #  @example\n    #   bitmask FFI::Type::UINT64, :foo, [:red, :green, :blue]\n    #  @param [FFI::Type] native_type native type for new bitmask\n    #  @param [Symbol] name for new bitmask\n    #  @param [Array<Symbol, Integer>] values for new bitmask\n    # @overload bitmask(native_type, *args)\n    #  @example\n    #   bitmask FFI::Type::UINT64, :red, :green, :blue\n    #  @param [FFI::Type] native_type native type for new bitmask\n    #  @param [Symbol, Integer] args values for new bitmask\n    # @overload bitmask(native_type, values)\n    #  Create a named enum and specify the native type.\n    #  @example\n    #   bitmask FFI::Type::UINT64, [:red, :green, :blue]\n    #  @param [FFI::Type] native_type native type for new bitmask\n    #  @param [Array<Symbol, Integer>] values for new bitmask\n    # @return [FFI::Bitmask]\n    # Create a new FFI::Bitmask\n    def bitmask(*args)\n      generic_enum(FFI::Bitmask, *args)\n    end\n\n    # @param name\n    # @return [FFI::Enum]\n    # Find an enum by name.\n    def enum_type(name)\n      @ffi_enums.find(name) if defined?(@ffi_enums)\n    end\n\n    # @param symbol\n    # @return [FFI::Enum]\n    # Find an enum by a symbol it contains.\n    def enum_value(symbol)\n      @ffi_enums.__map_symbol(symbol)\n    end\n\n    # @param [DataConverter, Type, Struct, Symbol] t type to find\n    # @return [Type]\n    # Find a type definition.\n    def find_type(t)\n      if t.kind_of?(Type)\n        t\n\n      elsif defined?(@ffi_typedefs) && @ffi_typedefs.has_key?(t)\n        @ffi_typedefs[t]\n\n      elsif t.is_a?(Class) && t < Struct\n        Type::POINTER\n\n      elsif t.is_a?(DataConverter)\n        # Add a typedef so next time the converter is used, it hits the cache\n        typedef Type::Mapped.new(t), t\n\n      end || FFI.find_type(t)\n    end\n  end\nend\n"], "filenames": ["lib/ffi/library.rb"], "buggy_code_start_loc": [128], "buggy_code_end_loc": [129], "fixing_code_start_loc": [128], "fixing_code_end_loc": [129], "type": "CWE-426", "message": "ruby-ffi version 1.9.23 and earlier has a DLL loading issue which can be hijacked on Windows OS, when a Symbol is used as DLL name instead of a String This vulnerability appears to have been fixed in v1.9.24 and later.", "other": {"cve": {"id": "CVE-2018-1000201", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-22T18:29:00.217", "lastModified": "2018-08-13T18:55:29.817", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ruby-ffi version 1.9.23 and earlier has a DLL loading issue which can be hijacked on Windows OS, when a Symbol is used as DLL name instead of a String This vulnerability appears to have been fixed in v1.9.24 and later."}, {"lang": "es", "value": "ruby-ffi en versiones 1.9.23 y anteriores tiene un problema de carga de DLL que puede secuestrarse en el sistema operativo Windows, cuando se emplea un s\u00edmbolo como nombre de DLL en lugar de una cadena. Esta vulnerabilidad parece haber sido solucionada en la versi\u00f3n v1.9.24 y siguientes."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-426"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ruby-ffi_project:ruby-ffi:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.9.23", "matchCriteriaId": "823ABD10-29B5-4C06-9662-D36480631E21"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "https://github.com/ffi/ffi/commit/09e0c6076466b4383da7fa4e13f714311109945a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ffi/ffi/commit/e0fe486df0e117ed67b0282b6ada04b7214ca05c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ffi/ffi/commit/09e0c6076466b4383da7fa4e13f714311109945a"}}