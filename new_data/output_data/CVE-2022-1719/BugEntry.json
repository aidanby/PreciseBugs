{"buggy_code": ["/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n **/\n\nconst ticketSchema = require('../models/ticket')\nconst async = require('async')\nconst path = require('path')\nconst _ = require('lodash')\nconst winston = require('../logger')\nconst groupSchema = require('../models/group')\nconst departmentSchema = require('../models/department')\nconst permissions = require('../permissions')\nconst xss = require('xss')\n/**\n * @since 1.0\n * @author Chris Brame <polonel@gmail.com>\n * @copyright 2015 Chris Brame\n **/\n\n/**\n * @namespace\n * @description Controller for each Ticket View\n * @requires {@link Ticket}\n * @requires {@link Group}\n * @requires {@link TicketType}\n * @requires {@link Emitter}\n *\n */\nconst ticketsController = {}\n\n/**\n * @name ticketsController.content\n * @description Main Content sent to the view\n */\nticketsController.content = {}\n\nticketsController.pubNewIssue = function (req, res) {\n  const marked = require('marked')\n  const settings = require('../models/setting')\n  settings.getSettingByName('allowPublicTickets:enable', function (err, setting) {\n    if (err) return handleError(res, err)\n    if (setting && setting.value === true) {\n      settings.getSettingByName('legal:privacypolicy', function (err, privacyPolicy) {\n        if (err) return handleError(res, err)\n\n        const content = {}\n        content.title = 'New Issue'\n        content.layout = false\n        content.data = {}\n        if (privacyPolicy === null || _.isUndefined(privacyPolicy.value)) {\n          content.data.privacyPolicy = 'No Privacy Policy has been set.'\n        } else {\n          content.data.privacyPolicy = xss(marked.parse(privacyPolicy.value))\n        }\n\n        return res.render('pub_createTicket', content)\n      })\n    } else {\n      return res.redirect('/')\n    }\n  })\n}\n\n/**\n * Get Ticket View based on ticket status\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getByStatus = function (req, res, next) {\n  const url = require('url')\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: []\n  }\n\n  const fullUrl = url.format({\n    protocol: req.protocol,\n    host: req.get('host'),\n    pathname: req.originalUrl\n  })\n\n  const pathname = new url.URL(fullUrl).pathname\n  const arr = pathname.split('/')\n  let tType = 'new'\n  let s = 0\n  if (_.size(arr) > 2) tType = arr[2]\n\n  switch (tType) {\n    case 'open':\n      s = 1\n      break\n    case 'pending':\n      s = 2\n      break\n    case 'closed':\n      s = 3\n      break\n  }\n\n  processor.subnav += tType\n  processor.pagetype = tType\n  processor.object.status.push(s)\n\n  req.processor = processor\n  return next()\n}\n\n/**\n * Get Ticket View based on ticket active tickets\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getActive = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-active'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2]\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getAssigned = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-assigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'assigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    assignedSelf: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getUnassigned = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-unassigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'unassigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    unassigned: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\nticketsController.filter = function (req, res, next) {\n  let page = req.query.page\n  if (_.isUndefined(page)) page = 0\n\n  const queryString = req.query\n  const uid = queryString.uid\n  const subject = queryString.fs\n  const issue = queryString.it\n  const dateStart = queryString.ds\n  const dateEnd = queryString.de\n  let status = queryString.st\n  let priority = queryString.pr\n  let groups = queryString.gp\n  let types = queryString.tt\n  let tags = queryString.tag\n  let assignee = queryString.au\n\n  const rawNoPage = req.originalUrl.replace(/[?&]page=[^&#]*(#.*)?$/, '$1').replace(/([?&])page=[^&]*&/, '$1')\n\n  if (!_.isUndefined(status) && !_.isArray(status)) status = [status]\n  if (!_.isUndefined(priority) && !_.isArray(priority)) priority = [priority]\n  if (!_.isUndefined(groups) && !_.isArray(groups)) groups = [groups]\n  if (!_.isUndefined(types) && !_.isArray(types)) types = [types]\n  if (!_.isUndefined(tags) && !_.isArray(tags)) tags = [tags]\n  if (!_.isUndefined(assignee) && !_.isArray(assignee)) assignee = [assignee]\n\n  const filter = {\n    uid: uid,\n    subject: subject,\n    issue: issue,\n    date: {\n      start: dateStart,\n      end: dateEnd\n    },\n    status: status,\n    priority: priority,\n    groups: groups,\n    tags: tags,\n    types: types,\n    assignee: assignee,\n    raw: rawNoPage\n  }\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'filter'\n  processor.filter = filter\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: filter.status,\n    user: req.user._id,\n    filter: filter\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Process the ```req.processor``` object and render the correct view\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Tickets View\n * @see Ticket\n */\nticketsController.processor = function (req, res) {\n  const processor = req.processor\n  if (_.isUndefined(processor)) return res.redirect('/')\n\n  const content = {}\n  content.title = processor.title\n  content.nav = processor.nav\n  content.subnav = processor.subnav\n  content.view = processor.pagetype\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n\n  const object = processor.object\n  content.data.page = object.page\n  content.data.filter = object.filter\n\n  return res.render(processor.renderpage, content)\n}\n\nticketsController.pdf = function (req, res) {\n  const TicketPDFGenerator = require('../pdf/ticketGenerator')\n  let uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.status(404).send('Invalid Ticket UID')\n  }\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n\n    const ticketGenerator = new TicketPDFGenerator(ticket)\n\n    ticketGenerator.generate(function (err, obj) {\n      if (err) return res.redirect('/tickets')\n\n      return res.writeHead(200, obj.headers).end(obj.data)\n    })\n  })\n}\n\n/**\n * Print Ticket View\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Subviews/PrintTicket View\n */\nticketsController.print = function (req, res) {\n  const user = req.user\n  let uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.redirect('/tickets')\n  }\n\n  const content = {}\n  content.title = 'Tickets - ' + req.params.uid\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    const hasPublic = permissions.canThis(user.role, 'tickets:public')\n    let hasAccess = false\n    async.series(\n      [\n        function (next) {\n          if (user.role.isAdmin || user.role.isAgent) {\n            departmentSchema.getDepartmentGroupsOfUser(user._id, function (err, groups) {\n              if (err) return res.redirect('/tickets')\n              const gIds = groups.map(function (g) {\n                return g._id\n              })\n\n              if (_.some(gIds, ticket.group._id)) {\n                if (!permissions.canThis(user.role, 'tickets:notes')) {\n                  ticket.notes = []\n                }\n\n                hasAccess = true\n                return next()\n              } else {\n                return next('UNAUTHORIZED_GROUP_ACCESS')\n              }\n            })\n          } else {\n            return next()\n          }\n        },\n        function (next) {\n          if (hasAccess) return next()\n\n          const members = ticket.group.members.map(function (m) {\n            return m._id.toString()\n          })\n\n          if (!members.includes(user._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              return next('UNAUTHORIZED_GROUP_ACCESS')\n            }\n          }\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) {\n            ticket.notes = []\n          }\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          if (err === 'UNAUTHORIZED_GROUP_ACCESS')\n            winston.warn(\n              'User tried to access ticket outside of group - UserId: ' + user._id + ' (' + user.username + ')'\n            )\n\n          return res.redirect('/tickets')\n        }\n\n        content.data.ticket = ticket\n        content.data.ticket.priorityname = ticket.priority.name\n        content.data.ticket.tagsArray = ticket.tags\n        content.data.ticket.commentCount = _.size(ticket.comments)\n        content.layout = 'layout/print'\n\n        return res.render('subviews/printticket', content)\n      }\n    )\n  })\n}\n\n/**\n * Get Single Ticket view based on UID\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Single Ticket View\n * @see Ticket\n * @example\n * //Content Object\n * content.title = \"Tickets - \" + req.params.id;\n * content.nav = 'tickets';\n *\n * content.data = {};\n * content.data.user = req.user;\n * content.data.common = req.viewdata;\n *\n * //Ticket Data\n * content.data.ticket = ticket;\n * content.data.ticket.priorityname = getPriorityName(ticket.priority);\n * content.data.ticket.tagsArray = ticket.tags;\n * content.data.ticket.commentCount = _.size(ticket.comments);\n */\nticketsController.single = function (req, res) {\n  const user = req.user\n  const uid = req.params.id\n  if (isNaN(uid)) {\n    return res.redirect('/tickets')\n  }\n\n  const content = {}\n  content.title = 'Tickets - ' + req.params.id\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    const departmentSchema = require('../models/department')\n    async.waterfall(\n      [\n        function (next) {\n          if (!req.user.role.isAdmin && !req.user.role.isAgent) {\n            return groupSchema.getAllGroupsOfUserNoPopulate(req.user._id, next)\n          }\n\n          departmentSchema.getUserDepartments(req.user._id, function (err, departments) {\n            if (err) return next(err)\n            if (_.some(departments, { allGroups: true })) {\n              return groupSchema.find({}, next)\n            }\n\n            const groups = _.flattenDeep(\n              departments.map(function (d) {\n                return d.groups\n              })\n            )\n\n            return next(null, groups)\n          })\n        },\n        function (userGroups, next) {\n          const hasPublic = permissions.canThis(user.role, 'tickets:public')\n          const groupIds = userGroups.map(function (g) {\n            return g._id.toString()\n          })\n\n          if (!groupIds.includes(ticket.group._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              winston.warn('User access ticket outside of group - UserId: ' + user._id)\n              return res.redirect('/tickets')\n            }\n          }\n\n          if (!permissions.canThis(user.role, 'comments:view')) ticket.comments = []\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) ticket.notes = []\n\n          content.data.ticket = ticket\n          content.data.ticket.priorityname = ticket.priority.name\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          winston.warn(err)\n          return res.redirect('/tickets')\n        }\n\n        return res.render('subviews/singleticket', content)\n      }\n    )\n  })\n}\n\nticketsController.uploadImageMDE = function (req, res) {\n  const Chance = require('chance')\n  const chance = new Chance()\n  const fs = require('fs-extra')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 5 * 1024 * 1024 // 5mb limit\n    }\n  })\n\n  const object = {}\n  let error\n\n  object.ticketId = req.headers.ticketid\n  if (!object.ticketId) return res.status(400).json({ success: false })\n\n  busboy.on('file', function (name, file, info) {\n    const filename = info.filename\n    const mimetype = info.mimeType\n    if (mimetype.indexOf('image/') === -1) {\n      error = {\n        status: 500,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const ext = path.extname(filename)\n    const allowedExtensions = [\n      '.jpg',\n      '.jpeg',\n      '.jpe',\n      '.jif',\n      '.jfif',\n      '.jfi',\n      '.png',\n      '.gif',\n      '.webp',\n      '.tiff',\n      '.tif',\n      '.bmp',\n      '.dib',\n      '.heif',\n      '.heic'\n    ]\n\n    if (!allowedExtensions.includes(ext.toLocaleLowerCase())) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    // const sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase();\n    const sanitizedFilename = chance.hash({ length: 20 }) + ext\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'inline_' + sanitizedFilename)\n    object.filename = sanitizedFilename\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 500,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 500,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.ticketId) || _.isUndefined(object.filename) || _.isUndefined(object.filePath)) {\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(500).send('File Failed to Save to Disk')\n\n    const fileUrl = '/uploads/tickets/' + object.ticketId + '/inline_' + object.filename\n\n    return res.json({ filename: fileUrl, ticketId: object.ticketId })\n  })\n\n  req.pipe(busboy)\n}\n\nticketsController.uploadAttachment = function (req, res) {\n  const fs = require('fs-extra')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 10 * 1024 * 1024 // 10mb limit\n    }\n  })\n\n  const object = {\n    ownerId: req.user._id\n  }\n  let error\n\n  busboy.on('field', function (fieldname, val) {\n    if (fieldname === 'ticketId') object.ticketId = val\n    if (fieldname === 'ownerId') object.ownerId = val\n  })\n\n  busboy.on('file', function (name, file, info) {\n    const filename = info.filename\n    const mimetype = info.mimeType\n\n    if (\n      mimetype.indexOf('image/') === -1 &&\n      mimetype.indexOf('text/plain') === -1 &&\n      mimetype.indexOf('audio/mpeg') === -1 &&\n      mimetype.indexOf('audio/mp3') === -1 &&\n      mimetype.indexOf('audio/wav') === -1 &&\n      mimetype.indexOf('application/x-zip-compressed') === -1 &&\n      mimetype.indexOf('application/pdf') === -1 &&\n      //  Office Mime-Types\n      mimetype.indexOf('application/msword') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.wordprocessingml.document') === -1 &&\n      mimetype.indexOf('application/vnd.ms-excel') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') === -1\n    ) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    const sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase()\n\n    const ext = path.extname(sanitizedFilename)\n    const badExts = ['.html', '.htm', '.js']\n\n    if (badExts.includes(ext)) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'attachment_' + sanitizedFilename)\n    object.filename = sanitizedFilename\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 500,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 500,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.ticketId) || _.isUndefined(object.ownerId) || _.isUndefined(object.filePath)) {\n      fs.unlinkSync(object.filePath)\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(500).send('File Failed to Save to Disk')\n\n    ticketSchema.getTicketById(object.ticketId, function (err, ticket) {\n      if (err) {\n        winston.warn(err)\n        return res.status(500).send(err.message)\n      }\n\n      const attachment = {\n        owner: object.ownerId,\n        name: object.filename,\n        path: '/uploads/tickets/' + object.ticketId + '/attachment_' + object.filename,\n        type: object.mimetype\n      }\n      ticket.attachments.push(attachment)\n\n      const historyItem = {\n        action: 'ticket:added:attachment',\n        description: 'Attachment ' + object.filename + ' was added.',\n        owner: object.ownerId\n      }\n      ticket.history.push(historyItem)\n\n      ticket.updated = Date.now()\n      ticket.save(function (err, t) {\n        if (err) {\n          fs.unlinkSync(object.filePath)\n          winston.warn(err)\n          return res.status(500).send(err.message)\n        }\n\n        const returnData = {\n          ticket: t\n        }\n\n        return res.json(returnData)\n      })\n    })\n  })\n\n  req.pipe(busboy)\n}\n\nfunction handleError (res, err) {\n  if (err) {\n    winston.warn(err)\n    if (!err.status) res.status = 500\n    else res.status = err.status\n    return res.render('error', {\n      layout: false,\n      error: err,\n      message: err.message\n    })\n  }\n}\n\nmodule.exports = ticketsController\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst _ = require('lodash')\nconst xss = require('xss')\nconst fs = require('fs')\nconst piexifjs = require('piexifjs')\n\nconst MAX_FIELD_TEXT_LENGTH = 255\nconst MAX_SHORT_FIELD_TEXT_LENGTH = 25\n\nmodule.exports.applyMaxShortTextLength = function (text) {\n  return text.toString().substring(0, MAX_SHORT_FIELD_TEXT_LENGTH)\n}\n\nmodule.exports.sanitizeFieldPlainText = function (text) {\n  return xss(text, {\n    whileList: {},\n    stripIgnoreTag: true,\n    stripIgnoreTagBody: ['script']\n  })\n}\n\nmodule.exports.stripExifData = function (path) {\n  const imgData = fs.readFileSync(path).toString('binary')\n  const newImgData = piexifjs.remove(imgData)\n  fs.writeFileSync(path, newImgData, 'binary')\n}\n\nmodule.exports.sendToSelf = function (socket, method, data) {\n  socket.emit(method, data)\n}\n\nmodule.exports._sendToSelf = function (io, socketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id === socketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.sendToAllConnectedClients = function (io, method, data) {\n  io.sockets.emit(method, data)\n}\n\nmodule.exports.sendToAllClientsInRoom = function (io, room, method, data) {\n  io.sockets.in(room).emit(method, data)\n}\n\nmodule.exports.sendToUser = function (socketList, userList, username, method, data) {\n  let userOnline = null\n  _.forEach(userList, function (v, k) {\n    if (k.toLowerCase() === username.toLowerCase()) {\n      userOnline = v\n      return true\n    }\n  })\n\n  if (_.isNull(userOnline)) return true\n\n  _.forEach(userOnline.sockets, function (socket) {\n    const o = _.findKey(socketList, { id: socket })\n    const i = socketList[o]\n    if (_.isUndefined(i)) return true\n    i.emit(method, data)\n  })\n}\n\nmodule.exports.sendToAllExcept = function (io, exceptSocketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id !== exceptSocketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.disconnectAllClients = function (io) {\n  Object.keys(io.sockets.sockets).forEach(function (sock) {\n    io.sockets.sockets[sock].disconnect(true)\n  })\n}\n"], "fixing_code": ["/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n **/\n\nconst ticketSchema = require('../models/ticket')\nconst async = require('async')\nconst path = require('path')\nconst _ = require('lodash')\nconst winston = require('../logger')\nconst groupSchema = require('../models/group')\nconst departmentSchema = require('../models/department')\nconst permissions = require('../permissions')\nconst xss = require('xss')\n/**\n * @since 1.0\n * @author Chris Brame <polonel@gmail.com>\n * @copyright 2015 Chris Brame\n **/\n\n/**\n * @namespace\n * @description Controller for each Ticket View\n * @requires {@link Ticket}\n * @requires {@link Group}\n * @requires {@link TicketType}\n * @requires {@link Emitter}\n *\n */\nconst ticketsController = {}\n\n/**\n * @name ticketsController.content\n * @description Main Content sent to the view\n */\nticketsController.content = {}\n\nticketsController.pubNewIssue = function (req, res) {\n  const marked = require('marked')\n  const settings = require('../models/setting')\n  settings.getSettingByName('allowPublicTickets:enable', function (err, setting) {\n    if (err) return handleError(res, err)\n    if (setting && setting.value === true) {\n      settings.getSettingByName('legal:privacypolicy', function (err, privacyPolicy) {\n        if (err) return handleError(res, err)\n\n        const content = {}\n        content.title = 'New Issue'\n        content.layout = false\n        content.data = {}\n        if (privacyPolicy === null || _.isUndefined(privacyPolicy.value)) {\n          content.data.privacyPolicy = 'No Privacy Policy has been set.'\n        } else {\n          content.data.privacyPolicy = xss(marked.parse(privacyPolicy.value))\n        }\n\n        return res.render('pub_createTicket', content)\n      })\n    } else {\n      return res.redirect('/')\n    }\n  })\n}\n\n/**\n * Get Ticket View based on ticket status\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getByStatus = function (req, res, next) {\n  const url = require('url')\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: []\n  }\n\n  const fullUrl = url.format({\n    protocol: req.protocol,\n    host: req.get('host'),\n    pathname: req.originalUrl\n  })\n\n  const pathname = new url.URL(fullUrl).pathname\n  const arr = pathname.split('/')\n  let tType = 'new'\n  let s = 0\n  if (_.size(arr) > 2) tType = arr[2]\n\n  switch (tType) {\n    case 'open':\n      s = 1\n      break\n    case 'pending':\n      s = 2\n      break\n    case 'closed':\n      s = 3\n      break\n  }\n\n  processor.subnav += tType\n  processor.pagetype = tType\n  processor.object.status.push(s)\n\n  req.processor = processor\n  return next()\n}\n\n/**\n * Get Ticket View based on ticket active tickets\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getActive = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-active'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2]\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getAssigned = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-assigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'assigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    assignedSelf: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getUnassigned = function (req, res, next) {\n  let page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-unassigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'unassigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    unassigned: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\nticketsController.filter = function (req, res, next) {\n  let page = req.query.page\n  if (_.isUndefined(page)) page = 0\n\n  const queryString = req.query\n  const uid = queryString.uid\n  const subject = queryString.fs\n  const issue = queryString.it\n  const dateStart = queryString.ds\n  const dateEnd = queryString.de\n  let status = queryString.st\n  let priority = queryString.pr\n  let groups = queryString.gp\n  let types = queryString.tt\n  let tags = queryString.tag\n  let assignee = queryString.au\n\n  const rawNoPage = req.originalUrl.replace(/[?&]page=[^&#]*(#.*)?$/, '$1').replace(/([?&])page=[^&]*&/, '$1')\n\n  if (!_.isUndefined(status)) status = xss(status)\n  if (!_.isUndefined(status) && !_.isArray(status)) status = [status]\n  if (!_.isUndefined(priority)) priority = xss(priority)\n  if (!_.isUndefined(priority) && !_.isArray(priority)) priority = [priority]\n  if (!_.isUndefined(groups)) groups = xss(groups)\n  if (!_.isUndefined(groups) && !_.isArray(groups)) groups = [groups]\n  if (!_.isUndefined(types)) types = xss(types)\n  if (!_.isUndefined(types) && !_.isArray(types)) types = [types]\n  if (!_.isUndefined(tags)) tags = xss(tags)\n  if (!_.isUndefined(tags) && !_.isArray(tags)) tags = [tags]\n  if (!_.isUndefined(assignee)) assignee = xss(assignee)\n  if (!_.isUndefined(assignee) && !_.isArray(assignee)) assignee = [assignee]\n\n  const filter = {\n    uid: uid,\n    subject: xss(subject),\n    issue: issue,\n    date: {\n      start: dateStart,\n      end: dateEnd\n    },\n    status: status,\n    priority: priority,\n    groups: groups,\n    tags: tags,\n    types: types,\n    assignee: assignee,\n    raw: rawNoPage\n  }\n\n  const processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'filter'\n  processor.filter = filter\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: filter.status,\n    user: req.user._id,\n    filter: filter\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Process the ```req.processor``` object and render the correct view\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Tickets View\n * @see Ticket\n */\nticketsController.processor = function (req, res) {\n  const processor = req.processor\n  if (_.isUndefined(processor)) return res.redirect('/')\n\n  const content = {}\n  content.title = processor.title\n  content.nav = processor.nav\n  content.subnav = processor.subnav\n  content.view = processor.pagetype\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n\n  const object = processor.object\n  content.data.page = object.page\n  content.data.filter = object.filter\n\n  return res.render(processor.renderpage, content)\n}\n\nticketsController.pdf = function (req, res) {\n  const TicketPDFGenerator = require('../pdf/ticketGenerator')\n  let uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.status(404).send('Invalid Ticket UID')\n  }\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n\n    const ticketGenerator = new TicketPDFGenerator(ticket)\n\n    ticketGenerator.generate(function (err, obj) {\n      if (err) return res.redirect('/tickets')\n\n      return res.writeHead(200, obj.headers).end(obj.data)\n    })\n  })\n}\n\n/**\n * Print Ticket View\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Subviews/PrintTicket View\n */\nticketsController.print = function (req, res) {\n  const user = req.user\n  let uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.redirect('/tickets')\n  }\n\n  const content = {}\n  content.title = 'Tickets - ' + req.params.uid\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    const hasPublic = permissions.canThis(user.role, 'tickets:public')\n    let hasAccess = false\n    async.series(\n      [\n        function (next) {\n          if (user.role.isAdmin || user.role.isAgent) {\n            departmentSchema.getDepartmentGroupsOfUser(user._id, function (err, groups) {\n              if (err) return res.redirect('/tickets')\n              const gIds = groups.map(function (g) {\n                return g._id\n              })\n\n              if (_.some(gIds, ticket.group._id)) {\n                if (!permissions.canThis(user.role, 'tickets:notes')) {\n                  ticket.notes = []\n                }\n\n                hasAccess = true\n                return next()\n              } else {\n                return next('UNAUTHORIZED_GROUP_ACCESS')\n              }\n            })\n          } else {\n            return next()\n          }\n        },\n        function (next) {\n          if (hasAccess) return next()\n\n          const members = ticket.group.members.map(function (m) {\n            return m._id.toString()\n          })\n\n          if (!members.includes(user._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              return next('UNAUTHORIZED_GROUP_ACCESS')\n            }\n          }\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) {\n            ticket.notes = []\n          }\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          if (err === 'UNAUTHORIZED_GROUP_ACCESS')\n            winston.warn(\n              'User tried to access ticket outside of group - UserId: ' + user._id + ' (' + user.username + ')'\n            )\n\n          return res.redirect('/tickets')\n        }\n\n        content.data.ticket = ticket\n        content.data.ticket.priorityname = ticket.priority.name\n        content.data.ticket.tagsArray = ticket.tags\n        content.data.ticket.commentCount = _.size(ticket.comments)\n        content.layout = 'layout/print'\n\n        return res.render('subviews/printticket', content)\n      }\n    )\n  })\n}\n\n/**\n * Get Single Ticket view based on UID\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Single Ticket View\n * @see Ticket\n * @example\n * //Content Object\n * content.title = \"Tickets - \" + req.params.id;\n * content.nav = 'tickets';\n *\n * content.data = {};\n * content.data.user = req.user;\n * content.data.common = req.viewdata;\n *\n * //Ticket Data\n * content.data.ticket = ticket;\n * content.data.ticket.priorityname = getPriorityName(ticket.priority);\n * content.data.ticket.tagsArray = ticket.tags;\n * content.data.ticket.commentCount = _.size(ticket.comments);\n */\nticketsController.single = function (req, res) {\n  const user = req.user\n  const uid = req.params.id\n  if (isNaN(uid)) {\n    return res.redirect('/tickets')\n  }\n\n  const content = {}\n  content.title = 'Tickets - ' + req.params.id\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    const departmentSchema = require('../models/department')\n    async.waterfall(\n      [\n        function (next) {\n          if (!req.user.role.isAdmin && !req.user.role.isAgent) {\n            return groupSchema.getAllGroupsOfUserNoPopulate(req.user._id, next)\n          }\n\n          departmentSchema.getUserDepartments(req.user._id, function (err, departments) {\n            if (err) return next(err)\n            if (_.some(departments, { allGroups: true })) {\n              return groupSchema.find({}, next)\n            }\n\n            const groups = _.flattenDeep(\n              departments.map(function (d) {\n                return d.groups\n              })\n            )\n\n            return next(null, groups)\n          })\n        },\n        function (userGroups, next) {\n          const hasPublic = permissions.canThis(user.role, 'tickets:public')\n          const groupIds = userGroups.map(function (g) {\n            return g._id.toString()\n          })\n\n          if (!groupIds.includes(ticket.group._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              winston.warn('User access ticket outside of group - UserId: ' + user._id)\n              return res.redirect('/tickets')\n            }\n          }\n\n          if (!permissions.canThis(user.role, 'comments:view')) ticket.comments = []\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) ticket.notes = []\n\n          content.data.ticket = ticket\n          content.data.ticket.priorityname = ticket.priority.name\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          winston.warn(err)\n          return res.redirect('/tickets')\n        }\n\n        return res.render('subviews/singleticket', content)\n      }\n    )\n  })\n}\n\nticketsController.uploadImageMDE = function (req, res) {\n  const Chance = require('chance')\n  const chance = new Chance()\n  const fs = require('fs-extra')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 5 * 1024 * 1024 // 5mb limit\n    }\n  })\n\n  const object = {}\n  let error\n\n  object.ticketId = req.headers.ticketid\n  if (!object.ticketId) return res.status(400).json({ success: false })\n\n  busboy.on('file', function (name, file, info) {\n    const filename = info.filename\n    const mimetype = info.mimeType\n    if (mimetype.indexOf('image/') === -1) {\n      error = {\n        status: 500,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const ext = path.extname(filename)\n    const allowedExtensions = [\n      '.jpg',\n      '.jpeg',\n      '.jpe',\n      '.jif',\n      '.jfif',\n      '.jfi',\n      '.png',\n      '.gif',\n      '.webp',\n      '.tiff',\n      '.tif',\n      '.bmp',\n      '.dib',\n      '.heif',\n      '.heic'\n    ]\n\n    if (!allowedExtensions.includes(ext.toLocaleLowerCase())) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    // const sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase();\n    const sanitizedFilename = chance.hash({ length: 20 }) + ext\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'inline_' + sanitizedFilename)\n    object.filename = sanitizedFilename\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 500,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 500,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.ticketId) || _.isUndefined(object.filename) || _.isUndefined(object.filePath)) {\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(500).send('File Failed to Save to Disk')\n\n    const fileUrl = '/uploads/tickets/' + object.ticketId + '/inline_' + object.filename\n\n    return res.json({ filename: fileUrl, ticketId: object.ticketId })\n  })\n\n  req.pipe(busboy)\n}\n\nticketsController.uploadAttachment = function (req, res) {\n  const fs = require('fs-extra')\n  const Busboy = require('busboy')\n  const busboy = Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 10 * 1024 * 1024 // 10mb limit\n    }\n  })\n\n  const object = {\n    ownerId: req.user._id\n  }\n  let error\n\n  busboy.on('field', function (fieldname, val) {\n    if (fieldname === 'ticketId') object.ticketId = val\n    if (fieldname === 'ownerId') object.ownerId = val\n  })\n\n  busboy.on('file', function (name, file, info) {\n    const filename = info.filename\n    const mimetype = info.mimeType\n\n    if (\n      mimetype.indexOf('image/') === -1 &&\n      mimetype.indexOf('text/plain') === -1 &&\n      mimetype.indexOf('audio/mpeg') === -1 &&\n      mimetype.indexOf('audio/mp3') === -1 &&\n      mimetype.indexOf('audio/wav') === -1 &&\n      mimetype.indexOf('application/x-zip-compressed') === -1 &&\n      mimetype.indexOf('application/pdf') === -1 &&\n      //  Office Mime-Types\n      mimetype.indexOf('application/msword') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.wordprocessingml.document') === -1 &&\n      mimetype.indexOf('application/vnd.ms-excel') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') === -1\n    ) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    const savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    const sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase()\n\n    const ext = path.extname(sanitizedFilename)\n    const badExts = ['.html', '.htm', '.js']\n\n    if (badExts.includes(ext)) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'attachment_' + sanitizedFilename)\n    object.filename = sanitizedFilename\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 500,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 500,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.ticketId) || _.isUndefined(object.ownerId) || _.isUndefined(object.filePath)) {\n      fs.unlinkSync(object.filePath)\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(500).send('File Failed to Save to Disk')\n\n    ticketSchema.getTicketById(object.ticketId, function (err, ticket) {\n      if (err) {\n        winston.warn(err)\n        return res.status(500).send(err.message)\n      }\n\n      const attachment = {\n        owner: object.ownerId,\n        name: object.filename,\n        path: '/uploads/tickets/' + object.ticketId + '/attachment_' + object.filename,\n        type: object.mimetype\n      }\n      ticket.attachments.push(attachment)\n\n      const historyItem = {\n        action: 'ticket:added:attachment',\n        description: 'Attachment ' + object.filename + ' was added.',\n        owner: object.ownerId\n      }\n      ticket.history.push(historyItem)\n\n      ticket.updated = Date.now()\n      ticket.save(function (err, t) {\n        if (err) {\n          fs.unlinkSync(object.filePath)\n          winston.warn(err)\n          return res.status(500).send(err.message)\n        }\n\n        const returnData = {\n          ticket: t\n        }\n\n        return res.json(returnData)\n      })\n    })\n  })\n\n  req.pipe(busboy)\n}\n\nfunction handleError (res, err) {\n  if (err) {\n    winston.warn(err)\n    if (!err.status) res.status = 500\n    else res.status = err.status\n    return res.render('error', {\n      layout: false,\n      error: err,\n      message: err.message\n    })\n  }\n}\n\nmodule.exports = ticketsController\n", "/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\nconst _ = require('lodash')\nconst xss = require('xss')\nconst fs = require('fs')\nconst piexifjs = require('piexifjs')\n\nconst MAX_FIELD_TEXT_LENGTH = 255\nconst MAX_SHORT_FIELD_TEXT_LENGTH = 25\n\nmodule.exports.applyMaxTextLength = function (text) {\n  return text.toString().substring(0, MAX_FIELD_TEXT_LENGTH)\n}\n\nmodule.exports.applyMaxShortTextLength = function (text) {\n  return text.toString().substring(0, MAX_SHORT_FIELD_TEXT_LENGTH)\n}\n\nmodule.exports.sanitizeFieldPlainText = function (text) {\n  return xss(text, {\n    whileList: {},\n    stripIgnoreTag: true,\n    stripIgnoreTagBody: ['script']\n  })\n}\n\nmodule.exports.stripExifData = function (path) {\n  const imgData = fs.readFileSync(path).toString('binary')\n  const newImgData = piexifjs.remove(imgData)\n  fs.writeFileSync(path, newImgData, 'binary')\n}\n\nmodule.exports.sendToSelf = function (socket, method, data) {\n  socket.emit(method, data)\n}\n\nmodule.exports._sendToSelf = function (io, socketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id === socketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.sendToAllConnectedClients = function (io, method, data) {\n  io.sockets.emit(method, data)\n}\n\nmodule.exports.sendToAllClientsInRoom = function (io, room, method, data) {\n  io.sockets.in(room).emit(method, data)\n}\n\nmodule.exports.sendToUser = function (socketList, userList, username, method, data) {\n  let userOnline = null\n  _.forEach(userList, function (v, k) {\n    if (k.toLowerCase() === username.toLowerCase()) {\n      userOnline = v\n      return true\n    }\n  })\n\n  if (_.isNull(userOnline)) return true\n\n  _.forEach(userOnline.sockets, function (socket) {\n    const o = _.findKey(socketList, { id: socket })\n    const i = socketList[o]\n    if (_.isUndefined(i)) return true\n    i.emit(method, data)\n  })\n}\n\nmodule.exports.sendToAllExcept = function (io, exceptSocketId, method, data) {\n  _.each(io.sockets.sockets, function (socket) {\n    if (socket.id !== exceptSocketId) {\n      socket.emit(method, data)\n    }\n  })\n}\n\nmodule.exports.disconnectAllClients = function (io) {\n  Object.keys(io.sockets.sockets).forEach(function (sock) {\n    io.sockets.sockets[sock].disconnect(true)\n  })\n}\n"], "filenames": ["src/controllers/tickets.js", "src/helpers/utils/index.js"], "buggy_code_start_loc": [235, 21], "buggy_code_end_loc": [246, 21], "fixing_code_start_loc": [236, 22], "fixing_code_end_loc": [252, 26], "type": "CWE-79", "message": "Reflected XSS on ticket filter function in GitHub repository polonel/trudesk prior to 1.2.2. This vulnerability is capable of executing a malicious javascript code in web page", "other": {"cve": {"id": "CVE-2022-1719", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-29T03:15:15.190", "lastModified": "2022-09-30T18:35:06.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Reflected XSS on ticket filter function in GitHub repository polonel/trudesk prior to 1.2.2. This vulnerability is capable of executing a malicious javascript code in web page"}, {"lang": "es", "value": "Un ataque de tipo XSS reflejado en la funci\u00f3n ticket filter en el repositorio de GitHub polonel/trudesk versiones anteriores a 1.2.2. Esta vulnerabilidad es capaz de ejecutar un c\u00f3digo javascript malicioso en la p\u00e1gina web"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trudesk_project:trudesk:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.2", "matchCriteriaId": "129D9FED-E43F-47B1-8FB3-012D00E93181"}]}]}], "references": [{"url": "https://github.com/polonel/trudesk/commit/36a542abbbb74828338ce402d65653ac58db42e0", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/790ba3fd-41e9-4393-8e2f-71161b56279b", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/polonel/trudesk/commit/36a542abbbb74828338ce402d65653ac58db42e0"}}