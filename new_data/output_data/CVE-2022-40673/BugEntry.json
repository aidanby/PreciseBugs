{"buggy_code": ["#include \"helper.h\"\n\n#include <QCoreApplication>\n#include <QtDBus>\n#include <QFile>\n#include <PolkitQt1/Authority>\n#include <PolkitQt1/Subject>\n\n#include <signal.h>\n\nHelperAdaptor::HelperAdaptor(Helper *parent) :\n    QDBusAbstractAdaptor(parent)\n{\n    m_parentHelper = parent;\n}\n\nQVariantMap HelperAdaptor::listStorages()\n{\n    return m_parentHelper->listStorages();\n}\n\nvoid HelperAdaptor::prepareBenchmarkFile(const QString &benchmarkFile, int fileSize, bool fillZeros)\n{\n    return m_parentHelper->prepareBenchmarkFile(benchmarkFile, fileSize, fillZeros);\n}\n\nvoid HelperAdaptor::startBenchmarkTest(int measuringTime, int fileSize, int randomReadPercentage, bool fillZeros, bool cacheBypass,\n                                       int blockSize, int queueDepth, int threads, const QString &rw)\n{\n    m_parentHelper->startBenchmarkTest(measuringTime, fileSize, randomReadPercentage, fillZeros, cacheBypass, blockSize, queueDepth, threads, rw);\n}\n\nQVariantMap HelperAdaptor::flushPageCache()\n{\n    return m_parentHelper->flushPageCache();\n}\n\nbool HelperAdaptor::removeBenchmarkFile()\n{\n    return m_parentHelper->removeBenchmarkFile();\n}\n\nvoid HelperAdaptor::stopCurrentTask()\n{\n    m_parentHelper->stopCurrentTask();\n}\n\nHelper::Helper() : m_helperAdaptor(new HelperAdaptor(this))\n{\n    if (!QDBusConnection::systemBus().isConnected() || !QDBusConnection::systemBus().registerService(QStringLiteral(\"dev.jonmagon.kdiskmark.helperinterface\")) ||\n        !QDBusConnection::systemBus().registerObject(QStringLiteral(\"/Helper\"), this)) {\n        qWarning() << QDBusConnection::systemBus().lastError().message();\n        qApp->quit();\n    }\n\n    m_serviceWatcher = new QDBusServiceWatcher(this);\n    m_serviceWatcher->setConnection(QDBusConnection ::systemBus());\n    m_serviceWatcher->setWatchMode(QDBusServiceWatcher::WatchForUnregistration);\n\n    connect(m_serviceWatcher, &QDBusServiceWatcher::serviceUnregistered, qApp, [this](const QString &service) {\n        m_serviceWatcher->removeWatchedService(service);\n        if (m_serviceWatcher->watchedServices().isEmpty()) {\n            qApp->quit();\n        }\n    });\n\n    QObject::connect(this, &Helper::taskFinished, m_helperAdaptor, &HelperAdaptor::taskFinished);\n}\n\nbool Helper::testFilePath(const QString &benchmarkFile)\n{\n#if (QT_VERSION >= QT_VERSION_CHECK(5, 14, 0))\n    if (QFileInfo(benchmarkFile).isSymbolicLink()) {\n#else\n    // detects *.lnk on Windows, but there's not Windows version, whatever\n    if (QFileInfo(benchmarkFile).isSymLink()) {\n#endif\n        qWarning(\"The path should not be symbolic link.\");\n        return false;\n    }\n\n    if (!benchmarkFile.endsWith(\"/.kdiskmark.tmp\")) {\n        qWarning(\"The path must end with /.kdiskmark.tmp\");\n        return false;\n    }\n\n    // Actually superfluous because of above, makes the check more obvious\n    // Just in case something changes in the backend\n    if (benchmarkFile.startsWith(\"/dev\")) {\n        qWarning(\"Cannot specify a raw device.\");\n        return false;\n    }\n\n    return true;\n}\n\nQVariantMap Helper::listStorages()\n{\n    if (!isCallerAuthorized()) {\n        return {};\n    }\n\n    QVariantMap reply;\n    foreach (const QStorageInfo &storage, QStorageInfo::mountedVolumes()) {\n        if (storage.isValid() && storage.isReady() && !storage.isReadOnly()) {\n            if (storage.device().indexOf(\"/dev\") != -1) {\n                reply[storage.rootPath()] =\n                        QVariant::fromValue(QDBusVariant(QVariant::fromValue(QVector<qlonglong> { storage.bytesTotal(), storage.bytesAvailable() })));\n            }\n        }\n    }\n\n    return reply;\n}\n\nvoid Helper::prepareBenchmarkFile(const QString &benchmarkFile, int fileSize, bool fillZeros)\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    // If benchmarking has been done, but removeBenchmarkFile has not been called,\n    // and benchmarking on a new file is called, then reject the request. The *previous* file must be removed first.\n    if (!m_benchmarkFile.isEmpty()) {\n        qWarning() << \"The previous benchmarking was not completed correctly.\";\n        return;\n    }\n\n    if (!testFilePath(benchmarkFile)) {\n        return;\n    }\n\n    m_benchmarkFile = benchmarkFile;\n\n    m_process = new QProcess();\n    m_process->start(\"fio\", QStringList()\n                     << QStringLiteral(\"--output-format=json\")\n                     << QStringLiteral(\"--create_only=1\")\n                     << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                     << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                     << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                     << QStringLiteral(\"--name=prepare\"));\n\n    connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n            [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n        emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n    });\n}\n\nvoid Helper::startBenchmarkTest(int measuringTime, int fileSize, int randomReadPercentage, bool fillZeros, bool cacheBypass,\n                                int blockSize, int queueDepth, int threads, const QString &rw)\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    if (m_benchmarkFile.isEmpty()) {\n        return;\n    }\n\n    if (!QFile(m_benchmarkFile).exists()) {\n        qWarning() << \"The benchmark file was not pre-created.\";\n        return;\n    }\n\n    m_process = new QProcess();\n    m_process->start(\"fio\", QStringList()\n                     << QStringLiteral(\"--output-format=json\")\n                     << QStringLiteral(\"--ioengine=libaio\")\n                     << QStringLiteral(\"--randrepeat=0\")\n                     << QStringLiteral(\"--refill_buffers\")\n                     << QStringLiteral(\"--end_fsync=1\")\n                     << QStringLiteral(\"--direct=%1\").arg(cacheBypass)\n                     << QStringLiteral(\"--rwmixread=%1\").arg(randomReadPercentage)\n                     << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                     << QStringLiteral(\"--name=%1\").arg(rw)\n                     << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                     << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                     << QStringLiteral(\"--bs=%1k\").arg(blockSize)\n                     << QStringLiteral(\"--runtime=%1\").arg(measuringTime)\n                     << QStringLiteral(\"--rw=%1\").arg(rw)\n                     << QStringLiteral(\"--iodepth=%1\").arg(queueDepth)\n                     << QStringLiteral(\"--numjobs=%1\").arg(threads));\n\n    connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n            [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n        emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n    });\n}\n\nQVariantMap Helper::flushPageCache()\n{\n    QVariantMap reply;\n    reply[QStringLiteral(\"success\")] = true;\n\n    if (!isCallerAuthorized()) {\n        reply[QStringLiteral(\"success\")] = false;\n        return reply;\n    }\n\n    QFile file(\"/proc/sys/vm/drop_caches\");\n\n    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {\n        file.write(\"1\");\n        file.close();\n    }\n    else {\n        reply[QStringLiteral(\"success\")] = false;\n        reply[QStringLiteral(\"error\")] = file.errorString();\n    }\n\n    return reply;\n}\n\nbool Helper::removeBenchmarkFile()\n{\n    if (!isCallerAuthorized()) {\n        return false;\n    }\n\n    if (m_benchmarkFile.isEmpty()) {\n        return false;\n    }\n\n    bool deletionState = QFile(m_benchmarkFile).remove();\n    m_benchmarkFile.clear();\n\n    return deletionState;\n}\n\nvoid Helper::stopCurrentTask()\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    if (!m_process) return;\n\n    if (m_process->state() == QProcess::Running || m_process->state() == QProcess::Starting) {\n        m_process->terminate();\n        m_process->waitForFinished(-1);\n    }\n\n    delete m_process;\n}\n\nbool Helper::isCallerAuthorized()\n{\n    if (!calledFromDBus()) {\n        return false;\n    }\n\n    if (m_serviceWatcher->watchedServices().contains(message().service())) {\n        return true;\n    }\n\n    if (!m_serviceWatcher->watchedServices().isEmpty()) {\n        qDebug() << \"There are already registered DBus connections.\";\n        return false;\n    }\n\n    PolkitQt1::SystemBusNameSubject subject(message().service());\n    PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n\n    PolkitQt1::Authority::Result result;\n    QEventLoop e;\n    connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n        result = _result;\n        e.quit();\n    });\n\n    authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n    e.exec();\n\n    if (authority->hasError()) {\n        qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n        authority->clearError();\n    }\n\n    switch (result) {\n    case PolkitQt1::Authority::Yes:\n        // track who called into us so we can close when all callers have gone away\n        m_serviceWatcher->addWatchedService(message().service());\n        return true;\n    default:\n        sendErrorReply(QDBusError::AccessDenied);\n        if (m_serviceWatcher->watchedServices().isEmpty())\n            qApp->quit();\n        return false;\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    QCoreApplication a(argc, argv);\n    Helper helper;\n    a.exec();\n}\n"], "fixing_code": ["#include \"helper.h\"\n\n#include <QCoreApplication>\n#include <QtDBus>\n#include <QFile>\n#include <PolkitQt1/Authority>\n#include <PolkitQt1/Subject>\n\n#include <signal.h>\n\nHelperAdaptor::HelperAdaptor(Helper *parent) :\n    QDBusAbstractAdaptor(parent)\n{\n    m_parentHelper = parent;\n}\n\nQVariantMap HelperAdaptor::listStorages()\n{\n    return m_parentHelper->listStorages();\n}\n\nvoid HelperAdaptor::prepareBenchmarkFile(const QString &benchmarkFile, int fileSize, bool fillZeros)\n{\n    return m_parentHelper->prepareBenchmarkFile(benchmarkFile, fileSize, fillZeros);\n}\n\nvoid HelperAdaptor::startBenchmarkTest(int measuringTime, int fileSize, int randomReadPercentage, bool fillZeros, bool cacheBypass,\n                                       int blockSize, int queueDepth, int threads, const QString &rw)\n{\n    m_parentHelper->startBenchmarkTest(measuringTime, fileSize, randomReadPercentage, fillZeros, cacheBypass, blockSize, queueDepth, threads, rw);\n}\n\nQVariantMap HelperAdaptor::flushPageCache()\n{\n    return m_parentHelper->flushPageCache();\n}\n\nbool HelperAdaptor::removeBenchmarkFile()\n{\n    return m_parentHelper->removeBenchmarkFile();\n}\n\nvoid HelperAdaptor::stopCurrentTask()\n{\n    m_parentHelper->stopCurrentTask();\n}\n\nHelper::Helper() : m_helperAdaptor(new HelperAdaptor(this))\n{\n    if (!QDBusConnection::systemBus().isConnected() || !QDBusConnection::systemBus().registerService(QStringLiteral(\"dev.jonmagon.kdiskmark.helperinterface\")) ||\n        !QDBusConnection::systemBus().registerObject(QStringLiteral(\"/Helper\"), this)) {\n        qWarning() << QDBusConnection::systemBus().lastError().message();\n        qApp->quit();\n    }\n\n    m_serviceWatcher = new QDBusServiceWatcher(this);\n    m_serviceWatcher->setConnection(QDBusConnection ::systemBus());\n    m_serviceWatcher->setWatchMode(QDBusServiceWatcher::WatchForUnregistration);\n\n    connect(m_serviceWatcher, &QDBusServiceWatcher::serviceUnregistered, qApp, [this](const QString &service) {\n        m_serviceWatcher->removeWatchedService(service);\n        if (m_serviceWatcher->watchedServices().isEmpty()) {\n            qApp->quit();\n        }\n    });\n\n    QObject::connect(this, &Helper::taskFinished, m_helperAdaptor, &HelperAdaptor::taskFinished);\n}\n\nbool Helper::testFilePath(const QString &benchmarkFile)\n{\n#if (QT_VERSION >= QT_VERSION_CHECK(5, 14, 0))\n    if (QFileInfo(benchmarkFile).isSymbolicLink()) {\n#else\n    // detects *.lnk on Windows, but there's not Windows version, whatever\n    if (QFileInfo(benchmarkFile).isSymLink()) {\n#endif\n        qWarning(\"The path should not be symbolic link.\");\n        return false;\n    }\n\n    if (!benchmarkFile.endsWith(\"/.kdiskmark.tmp\")) {\n        qWarning(\"The path must end with /.kdiskmark.tmp\");\n        return false;\n    }\n\n    // Actually superfluous because of above, makes the check more obvious\n    // Just in case something changes in the backend\n    if (benchmarkFile.startsWith(\"/dev\")) {\n        qWarning(\"Cannot specify a raw device.\");\n        return false;\n    }\n\n    return true;\n}\n\nQVariantMap Helper::listStorages()\n{\n    if (!isCallerAuthorized()) {\n        return {};\n    }\n\n    QVariantMap reply;\n    foreach (const QStorageInfo &storage, QStorageInfo::mountedVolumes()) {\n        if (storage.isValid() && storage.isReady() && !storage.isReadOnly()) {\n            if (storage.device().indexOf(\"/dev\") != -1) {\n                reply[storage.rootPath()] =\n                        QVariant::fromValue(QDBusVariant(QVariant::fromValue(QVector<qlonglong> { storage.bytesTotal(), storage.bytesAvailable() })));\n            }\n        }\n    }\n\n    return reply;\n}\n\nvoid Helper::prepareBenchmarkFile(const QString &benchmarkFile, int fileSize, bool fillZeros)\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    // If benchmarking has been done, but removeBenchmarkFile has not been called,\n    // and benchmarking on a new file is called, then reject the request. The *previous* file must be removed first.\n    if (!m_benchmarkFile.isEmpty()) {\n        qWarning() << \"The previous benchmarking was not completed correctly.\";\n        return;\n    }\n\n    if (!testFilePath(benchmarkFile)) {\n        return;\n    }\n\n    m_benchmarkFile = benchmarkFile;\n\n    m_process = new QProcess();\n    m_process->start(\"fio\", QStringList()\n                     << QStringLiteral(\"--output-format=json\")\n                     << QStringLiteral(\"--create_only=1\")\n                     << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                     << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                     << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                     << QStringLiteral(\"--name=prepare\"));\n\n    connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n            [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n        emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n    });\n}\n\nvoid Helper::startBenchmarkTest(int measuringTime, int fileSize, int randomReadPercentage, bool fillZeros, bool cacheBypass,\n                                int blockSize, int queueDepth, int threads, const QString &rw)\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    if (m_benchmarkFile.isEmpty()) {\n        return;\n    }\n\n    if (!QFile(m_benchmarkFile).exists()) {\n        qWarning() << \"The benchmark file was not pre-created.\";\n        return;\n    }\n\n    m_process = new QProcess();\n    m_process->start(\"fio\", QStringList()\n                     << QStringLiteral(\"--output-format=json\")\n                     << QStringLiteral(\"--ioengine=libaio\")\n                     << QStringLiteral(\"--randrepeat=0\")\n                     << QStringLiteral(\"--refill_buffers\")\n                     << QStringLiteral(\"--end_fsync=1\")\n                     << QStringLiteral(\"--direct=%1\").arg(cacheBypass)\n                     << QStringLiteral(\"--rwmixread=%1\").arg(randomReadPercentage)\n                     << QStringLiteral(\"--filename=%1\").arg(m_benchmarkFile)\n                     << QStringLiteral(\"--name=%1\").arg(rw)\n                     << QStringLiteral(\"--size=%1m\").arg(fileSize)\n                     << QStringLiteral(\"--zero_buffers=%1\").arg(fillZeros)\n                     << QStringLiteral(\"--bs=%1k\").arg(blockSize)\n                     << QStringLiteral(\"--runtime=%1\").arg(measuringTime)\n                     << QStringLiteral(\"--rw=%1\").arg(rw)\n                     << QStringLiteral(\"--iodepth=%1\").arg(queueDepth)\n                     << QStringLiteral(\"--numjobs=%1\").arg(threads));\n\n    connect(m_process, static_cast<void(QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n            [=] (int exitCode, QProcess::ExitStatus exitStatus) {\n        emit taskFinished(exitStatus == QProcess::NormalExit, QString(m_process->readAllStandardOutput()), QString(m_process->readAllStandardError()));\n    });\n}\n\nQVariantMap Helper::flushPageCache()\n{\n    if (!isCallerAuthorized()) {\n        return {};\n    }\n\n    QVariantMap reply;\n    reply[QStringLiteral(\"success\")] = true;\n\n    if (!isCallerAuthorized()) {\n        reply[QStringLiteral(\"success\")] = false;\n        return reply;\n    }\n\n    QFile file(\"/proc/sys/vm/drop_caches\");\n\n    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {\n        file.write(\"1\");\n        file.close();\n    }\n    else {\n        reply[QStringLiteral(\"success\")] = false;\n        reply[QStringLiteral(\"error\")] = file.errorString();\n    }\n\n    return reply;\n}\n\nbool Helper::removeBenchmarkFile()\n{\n    if (!isCallerAuthorized()) {\n        return false;\n    }\n\n    if (m_benchmarkFile.isEmpty()) {\n        return false;\n    }\n\n    bool deletionState = QFile(m_benchmarkFile).remove();\n    m_benchmarkFile.clear();\n\n    return deletionState;\n}\n\nvoid Helper::stopCurrentTask()\n{\n    if (!isCallerAuthorized()) {\n        return;\n    }\n\n    if (!m_process) return;\n\n    if (m_process->state() == QProcess::Running || m_process->state() == QProcess::Starting) {\n        m_process->terminate();\n        m_process->waitForFinished(-1);\n    }\n\n    delete m_process;\n}\n\nbool Helper::isCallerAuthorized()\n{\n    if (!calledFromDBus()) {\n        return false;\n    }\n\n    if (m_serviceWatcher->watchedServices().contains(message().service())) {\n        return true;\n    }\n\n    if (!m_serviceWatcher->watchedServices().isEmpty()) {\n        qDebug() << \"There are already registered DBus connections.\";\n        return false;\n    }\n\n    PolkitQt1::SystemBusNameSubject subject(message().service());\n    PolkitQt1::Authority *authority = PolkitQt1::Authority::instance();\n\n    PolkitQt1::Authority::Result result;\n    QEventLoop e;\n    connect(authority, &PolkitQt1::Authority::checkAuthorizationFinished, &e, [&e, &result](PolkitQt1::Authority::Result _result) {\n        result = _result;\n        e.quit();\n    });\n\n    authority->checkAuthorization(QStringLiteral(\"dev.jonmagon.kdiskmark.helper.init\"), subject, PolkitQt1::Authority::AllowUserInteraction);\n    e.exec();\n\n    if (authority->hasError()) {\n        qDebug() << \"Encountered error while checking authorization, error code: \" << authority->lastError() << authority->errorDetails();\n        authority->clearError();\n    }\n\n    switch (result) {\n    case PolkitQt1::Authority::Yes:\n        // track who called into us so we can close when all callers have gone away\n        m_serviceWatcher->addWatchedService(message().service());\n        return true;\n    default:\n        sendErrorReply(QDBusError::AccessDenied);\n        if (m_serviceWatcher->watchedServices().isEmpty())\n            qApp->quit();\n        return false;\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    QCoreApplication a(argc, argv);\n    Helper helper;\n    a.exec();\n}\n"], "filenames": ["src/helper.cpp"], "buggy_code_start_loc": [192], "buggy_code_end_loc": [192], "fixing_code_start_loc": [193], "fixing_code_end_loc": [197], "type": "CWE-862", "message": "KDiskMark before 3.1.0 lacks authorization checking for D-Bus methods such as Helper::flushPageCache.", "other": {"cve": {"id": "CVE-2022-40673", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-14T11:15:53.837", "lastModified": "2022-10-01T02:32:48.573", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "KDiskMark before 3.1.0 lacks authorization checking for D-Bus methods such as Helper::flushPageCache."}, {"lang": "es", "value": "KDiskMark versiones anteriores a 3.1.0, carece de comprobaci\u00f3n de autorizaci\u00f3n para los m\u00e9todos D-Bus como Helper::flushPageCache"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kdiskmark_project:kdiskmark:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.0", "matchCriteriaId": "39BAECF8-9240-451F-A20B-5DB8FBA3B003"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/09/14/1", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/JonMagon/KDiskMark/commit/3c90083a4f5ba3f240a797e509d818221542bbdc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/JonMagon/KDiskMark/compare/3.0.0...3.1.0", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/JonMagon/KDiskMark/releases/tag/3.1.0", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YYO3GWTNPHNCLHSI562Q3KX43PW7FQ4Q/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/JonMagon/KDiskMark/commit/3c90083a4f5ba3f240a797e509d818221542bbdc"}}