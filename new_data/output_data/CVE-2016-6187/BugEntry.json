{"buggy_code": ["/*\n * AppArmor security module\n *\n * This file contains AppArmor LSM hooks.\n *\n * Copyright (C) 1998-2008 Novell/SUSE\n * Copyright 2009-2010 Canonical Ltd.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation, version 2 of the\n * License.\n */\n\n#include <linux/lsm_hooks.h>\n#include <linux/moduleparam.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/sysctl.h>\n#include <linux/audit.h>\n#include <linux/user_namespace.h>\n#include <net/sock.h>\n\n#include \"include/apparmor.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include \"include/capability.h\"\n#include \"include/context.h\"\n#include \"include/file.h\"\n#include \"include/ipc.h\"\n#include \"include/path.h\"\n#include \"include/policy.h\"\n#include \"include/procattr.h\"\n\n/* Flag indicating whether initialization completed */\nint apparmor_initialized __initdata;\n\n/*\n * LSM hook functions\n */\n\n/*\n * free the associated aa_task_cxt and put its profiles\n */\nstatic void apparmor_cred_free(struct cred *cred)\n{\n\taa_free_task_context(cred_cxt(cred));\n\tcred_cxt(cred) = NULL;\n}\n\n/*\n * allocate the apparmor part of blank credentials\n */\nstatic int apparmor_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_cxt *cxt = aa_alloc_task_context(gfp);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\tcred_cxt(cred) = cxt;\n\treturn 0;\n}\n\n/*\n * prepare new aa_task_cxt for modification by prepare_cred block\n */\nstatic int apparmor_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t\t gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_cxt *cxt = aa_alloc_task_context(gfp);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\taa_dup_task_context(cxt, cred_cxt(old));\n\tcred_cxt(new) = cxt;\n\treturn 0;\n}\n\n/*\n * transfer the apparmor data to a blank set of creds\n */\nstatic void apparmor_cred_transfer(struct cred *new, const struct cred *old)\n{\n\tconst struct aa_task_cxt *old_cxt = cred_cxt(old);\n\tstruct aa_task_cxt *new_cxt = cred_cxt(new);\n\n\taa_dup_task_context(new_cxt, old_cxt);\n}\n\nstatic int apparmor_ptrace_access_check(struct task_struct *child,\n\t\t\t\t\tunsigned int mode)\n{\n\treturn aa_ptrace(current, child, mode);\n}\n\nstatic int apparmor_ptrace_traceme(struct task_struct *parent)\n{\n\treturn aa_ptrace(parent, current, PTRACE_MODE_ATTACH);\n}\n\n/* Derived from security/commoncap.c:cap_capget */\nstatic int apparmor_capget(struct task_struct *target, kernel_cap_t *effective,\n\t\t\t   kernel_cap_t *inheritable, kernel_cap_t *permitted)\n{\n\tstruct aa_profile *profile;\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\tcred = __task_cred(target);\n\tprofile = aa_cred_profile(cred);\n\n\t/*\n\t * cap_capget is stacked ahead of this and will\n\t * initialize effective and permitted.\n\t */\n\tif (!unconfined(profile) && !COMPLAIN_MODE(profile)) {\n\t\t*effective = cap_intersect(*effective, profile->caps.allow);\n\t\t*permitted = cap_intersect(*permitted, profile->caps.allow);\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int apparmor_capable(const struct cred *cred, struct user_namespace *ns,\n\t\t\t    int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tprofile = aa_cred_profile(cred);\n\tif (!unconfined(profile))\n\t\terror = aa_capable(profile, cap, audit);\n\treturn error;\n}\n\n/**\n * common_perm - basic common permission check wrapper fn for paths\n * @op: operation being checked\n * @path: path to check permission of  (NOT NULL)\n * @mask: requested permissions mask\n * @cond: conditional info for the permission request  (NOT NULL)\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm(int op, const struct path *path, u32 mask,\n\t\t       struct path_cond *cond)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tprofile = __aa_current_profile();\n\tif (!unconfined(profile))\n\t\terror = aa_path_perm(op, profile, path, 0, mask, cond);\n\n\treturn error;\n}\n\n/**\n * common_perm_dir_dentry - common permission wrapper when path is dir, dentry\n * @op: operation being checked\n * @dir: directory of the dentry  (NOT NULL)\n * @dentry: dentry to check  (NOT NULL)\n * @mask: requested permissions mask\n * @cond: conditional info for the permission request  (NOT NULL)\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_dir_dentry(int op, const struct path *dir,\n\t\t\t\t  struct dentry *dentry, u32 mask,\n\t\t\t\t  struct path_cond *cond)\n{\n\tstruct path path = { dir->mnt, dentry };\n\n\treturn common_perm(op, &path, mask, cond);\n}\n\n/**\n * common_perm_path - common permission wrapper when mnt, dentry\n * @op: operation being checked\n * @path: location to check (NOT NULL)\n * @mask: requested permissions mask\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic inline int common_perm_path(int op, const struct path *path, u32 mask)\n{\n\tstruct path_cond cond = { d_backing_inode(path->dentry)->i_uid,\n\t\t\t\t  d_backing_inode(path->dentry)->i_mode\n\t};\n\tif (!mediated_filesystem(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}\n\n/**\n * common_perm_rm - common permission wrapper for operations doing rm\n * @op: operation being checked\n * @dir: directory that the dentry is in  (NOT NULL)\n * @dentry: dentry being rm'd  (NOT NULL)\n * @mask: requested permission mask\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_rm(int op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\n\tif (!inode || !mediated_filesystem(dentry))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}\n\n/**\n * common_perm_create - common permission wrapper for operations doing create\n * @op: operation being checked\n * @dir: directory that dentry will be created in  (NOT NULL)\n * @dentry: dentry to create   (NOT NULL)\n * @mask: request permission mask\n * @mode: created file mode\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_create(int op, const struct path *dir,\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!mediated_filesystem(dir->dentry))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}\n\nstatic int apparmor_path_unlink(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_UNLINK, dir, dentry, AA_MAY_DELETE);\n}\n\nstatic int apparmor_path_mkdir(const struct path *dir, struct dentry *dentry,\n\t\t\t       umode_t mode)\n{\n\treturn common_perm_create(OP_MKDIR, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFDIR);\n}\n\nstatic int apparmor_path_rmdir(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_RMDIR, dir, dentry, AA_MAY_DELETE);\n}\n\nstatic int apparmor_path_mknod(const struct path *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, unsigned int dev)\n{\n\treturn common_perm_create(OP_MKNOD, dir, dentry, AA_MAY_CREATE, mode);\n}\n\nstatic int apparmor_path_truncate(const struct path *path)\n{\n\treturn common_perm_path(OP_TRUNC, path, MAY_WRITE | AA_MAY_META_WRITE);\n}\n\nstatic int apparmor_path_symlink(const struct path *dir, struct dentry *dentry,\n\t\t\t\t const char *old_name)\n{\n\treturn common_perm_create(OP_SYMLINK, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFLNK);\n}\n\nstatic int apparmor_path_link(struct dentry *old_dentry, const struct path *new_dir,\n\t\t\t      struct dentry *new_dentry)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tif (!mediated_filesystem(old_dentry))\n\t\treturn 0;\n\n\tprofile = aa_current_profile();\n\tif (!unconfined(profile))\n\t\terror = aa_path_link(profile, old_dentry, new_dir, new_dentry);\n\treturn error;\n}\n\nstatic int apparmor_path_rename(const struct path *old_dir, struct dentry *old_dentry,\n\t\t\t\tconst struct path *new_dir, struct dentry *new_dentry)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tif (!mediated_filesystem(old_dentry))\n\t\treturn 0;\n\n\tprofile = aa_current_profile();\n\tif (!unconfined(profile)) {\n\t\tstruct path old_path = { old_dir->mnt, old_dentry };\n\t\tstruct path new_path = { new_dir->mnt, new_dentry };\n\t\tstruct path_cond cond = { d_backing_inode(old_dentry)->i_uid,\n\t\t\t\t\t  d_backing_inode(old_dentry)->i_mode\n\t\t};\n\n\t\terror = aa_path_perm(OP_RENAME_SRC, profile, &old_path, 0,\n\t\t\t\t     MAY_READ | AA_MAY_META_READ | MAY_WRITE |\n\t\t\t\t     AA_MAY_META_WRITE | AA_MAY_DELETE,\n\t\t\t\t     &cond);\n\t\tif (!error)\n\t\t\terror = aa_path_perm(OP_RENAME_DEST, profile, &new_path,\n\t\t\t\t\t     0, MAY_WRITE | AA_MAY_META_WRITE |\n\t\t\t\t\t     AA_MAY_CREATE, &cond);\n\n\t}\n\treturn error;\n}\n\nstatic int apparmor_path_chmod(const struct path *path, umode_t mode)\n{\n\treturn common_perm_path(OP_CHMOD, path, AA_MAY_CHMOD);\n}\n\nstatic int apparmor_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n{\n\treturn common_perm_path(OP_CHOWN, path, AA_MAY_CHOWN);\n}\n\nstatic int apparmor_inode_getattr(const struct path *path)\n{\n\treturn common_perm_path(OP_GETATTR, path, AA_MAY_META_READ);\n}\n\nstatic int apparmor_file_open(struct file *file, const struct cred *cred)\n{\n\tstruct aa_file_cxt *fcxt = file->f_security;\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tif (!mediated_filesystem(file->f_path.dentry))\n\t\treturn 0;\n\n\t/* If in exec, permission is handled by bprm hooks.\n\t * Cache permissions granted by the previous exec check, with\n\t * implicit read and executable mmap which are required to\n\t * actually execute the image.\n\t */\n\tif (current->in_execve) {\n\t\tfcxt->allow = MAY_EXEC | MAY_READ | AA_EXEC_MMAP;\n\t\treturn 0;\n\t}\n\n\tprofile = aa_cred_profile(cred);\n\tif (!unconfined(profile)) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tstruct path_cond cond = { inode->i_uid, inode->i_mode };\n\n\t\terror = aa_path_perm(OP_OPEN, profile, &file->f_path, 0,\n\t\t\t\t     aa_map_file_to_perms(file), &cond);\n\t\t/* todo cache full allowed permissions set and state */\n\t\tfcxt->allow = aa_map_file_to_perms(file);\n\t}\n\n\treturn error;\n}\n\nstatic int apparmor_file_alloc_security(struct file *file)\n{\n\t/* freed by apparmor_file_free_security */\n\tfile->f_security = aa_alloc_file_context(GFP_KERNEL);\n\tif (!file->f_security)\n\t\treturn -ENOMEM;\n\treturn 0;\n\n}\n\nstatic void apparmor_file_free_security(struct file *file)\n{\n\tstruct aa_file_cxt *cxt = file->f_security;\n\n\taa_free_file_context(cxt);\n}\n\nstatic int common_file_perm(int op, struct file *file, u32 mask)\n{\n\tstruct aa_file_cxt *fcxt = file->f_security;\n\tstruct aa_profile *profile, *fprofile = aa_cred_profile(file->f_cred);\n\tint error = 0;\n\n\tBUG_ON(!fprofile);\n\n\tif (!file->f_path.mnt ||\n\t    !mediated_filesystem(file->f_path.dentry))\n\t\treturn 0;\n\n\tprofile = __aa_current_profile();\n\n\t/* revalidate access, if task is unconfined, or the cached cred\n\t * doesn't match or if the request is for more permissions than\n\t * was granted.\n\t *\n\t * Note: the test for !unconfined(fprofile) is to handle file\n\t *       delegation from unconfined tasks\n\t */\n\tif (!unconfined(profile) && !unconfined(fprofile) &&\n\t    ((fprofile != profile) || (mask & ~fcxt->allow)))\n\t\terror = aa_file_perm(op, profile, file, mask);\n\n\treturn error;\n}\n\nstatic int apparmor_file_permission(struct file *file, int mask)\n{\n\treturn common_file_perm(OP_FPERM, file, mask);\n}\n\nstatic int apparmor_file_lock(struct file *file, unsigned int cmd)\n{\n\tu32 mask = AA_MAY_LOCK;\n\n\tif (cmd == F_WRLCK)\n\t\tmask |= MAY_WRITE;\n\n\treturn common_file_perm(OP_FLOCK, file, mask);\n}\n\nstatic int common_mmap(int op, struct file *file, unsigned long prot,\n\t\t       unsigned long flags)\n{\n\tint mask = 0;\n\n\tif (!file || !file->f_security)\n\t\treturn 0;\n\n\tif (prot & PROT_READ)\n\t\tmask |= MAY_READ;\n\t/*\n\t * Private mappings don't require write perms since they don't\n\t * write back to the files\n\t */\n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\n\t\tmask |= MAY_WRITE;\n\tif (prot & PROT_EXEC)\n\t\tmask |= AA_EXEC_MMAP;\n\n\treturn common_file_perm(op, file, mask);\n}\n\nstatic int apparmor_mmap_file(struct file *file, unsigned long reqprot,\n\t\t\t      unsigned long prot, unsigned long flags)\n{\n\treturn common_mmap(OP_FMMAP, file, prot, flags);\n}\n\nstatic int apparmor_file_mprotect(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long reqprot, unsigned long prot)\n{\n\treturn common_mmap(OP_FMPROT, vma->vm_file, prot,\n\t\t\t   !(vma->vm_flags & VM_SHARED) ? MAP_PRIVATE : 0);\n}\n\nstatic int apparmor_getprocattr(struct task_struct *task, char *name,\n\t\t\t\tchar **value)\n{\n\tint error = -ENOENT;\n\t/* released below */\n\tconst struct cred *cred = get_task_cred(task);\n\tstruct aa_task_cxt *cxt = cred_cxt(cred);\n\tstruct aa_profile *profile = NULL;\n\n\tif (strcmp(name, \"current\") == 0)\n\t\tprofile = aa_get_newest_profile(cxt->profile);\n\telse if (strcmp(name, \"prev\") == 0  && cxt->previous)\n\t\tprofile = aa_get_newest_profile(cxt->previous);\n\telse if (strcmp(name, \"exec\") == 0 && cxt->onexec)\n\t\tprofile = aa_get_newest_profile(cxt->onexec);\n\telse\n\t\terror = -EINVAL;\n\n\tif (profile)\n\t\terror = aa_getprocattr(profile, value);\n\n\taa_put_profile(profile);\n\tput_cred(cred);\n\n\treturn error;\n}\n\nstatic int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\treturn -EINVAL;\n\n\tif (!error)\n\t\terror = size;\n\treturn error;\n\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n}\n\nstatic int apparmor_task_setrlimit(struct task_struct *task,\n\t\tunsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_profile *profile = __aa_current_profile();\n\tint error = 0;\n\n\tif (!unconfined(profile))\n\t\terror = aa_task_setrlimit(profile, task, resource, new_rlim);\n\n\treturn error;\n}\n\nstatic struct security_hook_list apparmor_hooks[] = {\n\tLSM_HOOK_INIT(ptrace_access_check, apparmor_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, apparmor_ptrace_traceme),\n\tLSM_HOOK_INIT(capget, apparmor_capget),\n\tLSM_HOOK_INIT(capable, apparmor_capable),\n\n\tLSM_HOOK_INIT(path_link, apparmor_path_link),\n\tLSM_HOOK_INIT(path_unlink, apparmor_path_unlink),\n\tLSM_HOOK_INIT(path_symlink, apparmor_path_symlink),\n\tLSM_HOOK_INIT(path_mkdir, apparmor_path_mkdir),\n\tLSM_HOOK_INIT(path_rmdir, apparmor_path_rmdir),\n\tLSM_HOOK_INIT(path_mknod, apparmor_path_mknod),\n\tLSM_HOOK_INIT(path_rename, apparmor_path_rename),\n\tLSM_HOOK_INIT(path_chmod, apparmor_path_chmod),\n\tLSM_HOOK_INIT(path_chown, apparmor_path_chown),\n\tLSM_HOOK_INIT(path_truncate, apparmor_path_truncate),\n\tLSM_HOOK_INIT(inode_getattr, apparmor_inode_getattr),\n\n\tLSM_HOOK_INIT(file_open, apparmor_file_open),\n\tLSM_HOOK_INIT(file_permission, apparmor_file_permission),\n\tLSM_HOOK_INIT(file_alloc_security, apparmor_file_alloc_security),\n\tLSM_HOOK_INIT(file_free_security, apparmor_file_free_security),\n\tLSM_HOOK_INIT(mmap_file, apparmor_mmap_file),\n\tLSM_HOOK_INIT(file_mprotect, apparmor_file_mprotect),\n\tLSM_HOOK_INIT(file_lock, apparmor_file_lock),\n\n\tLSM_HOOK_INIT(getprocattr, apparmor_getprocattr),\n\tLSM_HOOK_INIT(setprocattr, apparmor_setprocattr),\n\n\tLSM_HOOK_INIT(cred_alloc_blank, apparmor_cred_alloc_blank),\n\tLSM_HOOK_INIT(cred_free, apparmor_cred_free),\n\tLSM_HOOK_INIT(cred_prepare, apparmor_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, apparmor_cred_transfer),\n\n\tLSM_HOOK_INIT(bprm_set_creds, apparmor_bprm_set_creds),\n\tLSM_HOOK_INIT(bprm_committing_creds, apparmor_bprm_committing_creds),\n\tLSM_HOOK_INIT(bprm_committed_creds, apparmor_bprm_committed_creds),\n\tLSM_HOOK_INIT(bprm_secureexec, apparmor_bprm_secureexec),\n\n\tLSM_HOOK_INIT(task_setrlimit, apparmor_task_setrlimit),\n};\n\n/*\n * AppArmor sysfs module parameters\n */\n\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\n#define param_check_aabool param_check_bool\nstatic const struct kernel_param_ops param_ops_aabool = {\n\t.flags = KERNEL_PARAM_OPS_FL_NOARG,\n\t.set = param_set_aabool,\n\t.get = param_get_aabool\n};\n\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\n#define param_check_aauint param_check_uint\nstatic const struct kernel_param_ops param_ops_aauint = {\n\t.set = param_set_aauint,\n\t.get = param_get_aauint\n};\n\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\n#define param_check_aalockpolicy param_check_bool\nstatic const struct kernel_param_ops param_ops_aalockpolicy = {\n\t.flags = KERNEL_PARAM_OPS_FL_NOARG,\n\t.set = param_set_aalockpolicy,\n\t.get = param_get_aalockpolicy\n};\n\nstatic int param_set_audit(const char *val, struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, struct kernel_param *kp);\n\nstatic int param_set_mode(const char *val, struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, struct kernel_param *kp);\n\n/* Flag values, also controllable via /sys/module/apparmor/parameters\n * We define special types as we want to do additional mediation.\n */\n\n/* AppArmor global enforcement switch - complain, enforce, kill */\nenum profile_mode aa_g_profile_mode = APPARMOR_ENFORCE;\nmodule_param_call(mode, param_set_mode, param_get_mode,\n\t\t  &aa_g_profile_mode, S_IRUSR | S_IWUSR);\n\n/* Debug mode */\nbool aa_g_debug;\nmodule_param_named(debug, aa_g_debug, aabool, S_IRUSR | S_IWUSR);\n\n/* Audit mode */\nenum audit_mode aa_g_audit;\nmodule_param_call(audit, param_set_audit, param_get_audit,\n\t\t  &aa_g_audit, S_IRUSR | S_IWUSR);\n\n/* Determines if audit header is included in audited messages.  This\n * provides more context if the audit daemon is not running\n */\nbool aa_g_audit_header = 1;\nmodule_param_named(audit_header, aa_g_audit_header, aabool,\n\t\t   S_IRUSR | S_IWUSR);\n\n/* lock out loading/removal of policy\n * TODO: add in at boot loading of policy, which is the only way to\n *       load policy, if lock_policy is set\n */\nbool aa_g_lock_policy;\nmodule_param_named(lock_policy, aa_g_lock_policy, aalockpolicy,\n\t\t   S_IRUSR | S_IWUSR);\n\n/* Syscall logging mode */\nbool aa_g_logsyscall;\nmodule_param_named(logsyscall, aa_g_logsyscall, aabool, S_IRUSR | S_IWUSR);\n\n/* Maximum pathname length before accesses will start getting rejected */\nunsigned int aa_g_path_max = 2 * PATH_MAX;\nmodule_param_named(path_max, aa_g_path_max, aauint, S_IRUSR | S_IWUSR);\n\n/* Determines how paranoid loading of policy is and how much verification\n * on the loaded policy is done.\n */\nbool aa_g_paranoid_load = 1;\nmodule_param_named(paranoid_load, aa_g_paranoid_load, aabool,\n\t\t   S_IRUSR | S_IWUSR);\n\n/* Boot time disable flag */\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\nmodule_param_named(enabled, apparmor_enabled, bool, S_IRUGO);\n\nstatic int __init apparmor_enabled_setup(char *str)\n{\n\tunsigned long enabled;\n\tint error = kstrtoul(str, 0, &enabled);\n\tif (!error)\n\t\tapparmor_enabled = enabled ? 1 : 0;\n\treturn 1;\n}\n\n__setup(\"apparmor=\", apparmor_enabled_setup);\n\n/* set global flag turning off the ability to load policy */\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (aa_g_lock_policy)\n\t\treturn -EACCES;\n\treturn param_set_bool(val, kp);\n}\n\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}\n\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_set_bool(val, kp);\n}\n\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}\n\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_set_uint(val, kp);\n}\n\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_uint(buffer, kp);\n}\n\nstatic int param_get_audit(char *buffer, struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buffer, \"%s\", audit_mode_names[aa_g_audit]);\n}\n\nstatic int param_set_audit(const char *val, struct kernel_param *kp)\n{\n\tint i;\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < AUDIT_MAX_INDEX; i++) {\n\t\tif (strcmp(val, audit_mode_names[i]) == 0) {\n\t\t\taa_g_audit = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int param_get_mode(char *buffer, struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buffer, \"%s\", aa_profile_mode_names[aa_g_profile_mode]);\n}\n\nstatic int param_set_mode(const char *val, struct kernel_param *kp)\n{\n\tint i;\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < APPARMOR_MODE_NAMES_MAX_INDEX; i++) {\n\t\tif (strcmp(val, aa_profile_mode_names[i]) == 0) {\n\t\t\taa_g_profile_mode = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n/*\n * AppArmor init functions\n */\n\n/**\n * set_init_cxt - set a task context and profile on the first task.\n *\n * TODO: allow setting an alternate profile than unconfined\n */\nstatic int __init set_init_cxt(void)\n{\n\tstruct cred *cred = (struct cred *)current->real_cred;\n\tstruct aa_task_cxt *cxt;\n\n\tcxt = aa_alloc_task_context(GFP_KERNEL);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\tcxt->profile = aa_get_profile(root_ns->unconfined);\n\tcred_cxt(cred) = cxt;\n\n\treturn 0;\n}\n\nstatic int __init apparmor_init(void)\n{\n\tint error;\n\n\tif (!apparmor_enabled || !security_module_enable(\"apparmor\")) {\n\t\taa_info_message(\"AppArmor disabled by boot time parameter\");\n\t\tapparmor_enabled = 0;\n\t\treturn 0;\n\t}\n\n\terror = aa_alloc_root_ns();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to allocate default profile namespace\\n\");\n\t\tgoto alloc_out;\n\t}\n\n\terror = set_init_cxt();\n\tif (error) {\n\t\tAA_ERROR(\"Failed to set context on init task\\n\");\n\t\taa_free_root_ns();\n\t\tgoto alloc_out;\n\t}\n\tsecurity_add_hooks(apparmor_hooks, ARRAY_SIZE(apparmor_hooks));\n\n\t/* Report that AppArmor successfully initialized */\n\tapparmor_initialized = 1;\n\tif (aa_g_profile_mode == APPARMOR_COMPLAIN)\n\t\taa_info_message(\"AppArmor initialized: complain mode enabled\");\n\telse if (aa_g_profile_mode == APPARMOR_KILL)\n\t\taa_info_message(\"AppArmor initialized: kill mode enabled\");\n\telse\n\t\taa_info_message(\"AppArmor initialized\");\n\n\treturn error;\n\nalloc_out:\n\taa_destroy_aafs();\n\n\tapparmor_enabled = 0;\n\treturn error;\n}\n\nsecurity_initcall(apparmor_init);\n"], "fixing_code": ["/*\n * AppArmor security module\n *\n * This file contains AppArmor LSM hooks.\n *\n * Copyright (C) 1998-2008 Novell/SUSE\n * Copyright 2009-2010 Canonical Ltd.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation, version 2 of the\n * License.\n */\n\n#include <linux/lsm_hooks.h>\n#include <linux/moduleparam.h>\n#include <linux/mm.h>\n#include <linux/mman.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/ptrace.h>\n#include <linux/ctype.h>\n#include <linux/sysctl.h>\n#include <linux/audit.h>\n#include <linux/user_namespace.h>\n#include <net/sock.h>\n\n#include \"include/apparmor.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include \"include/capability.h\"\n#include \"include/context.h\"\n#include \"include/file.h\"\n#include \"include/ipc.h\"\n#include \"include/path.h\"\n#include \"include/policy.h\"\n#include \"include/procattr.h\"\n\n/* Flag indicating whether initialization completed */\nint apparmor_initialized __initdata;\n\n/*\n * LSM hook functions\n */\n\n/*\n * free the associated aa_task_cxt and put its profiles\n */\nstatic void apparmor_cred_free(struct cred *cred)\n{\n\taa_free_task_context(cred_cxt(cred));\n\tcred_cxt(cred) = NULL;\n}\n\n/*\n * allocate the apparmor part of blank credentials\n */\nstatic int apparmor_cred_alloc_blank(struct cred *cred, gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_cxt *cxt = aa_alloc_task_context(gfp);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\tcred_cxt(cred) = cxt;\n\treturn 0;\n}\n\n/*\n * prepare new aa_task_cxt for modification by prepare_cred block\n */\nstatic int apparmor_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t\t gfp_t gfp)\n{\n\t/* freed by apparmor_cred_free */\n\tstruct aa_task_cxt *cxt = aa_alloc_task_context(gfp);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\taa_dup_task_context(cxt, cred_cxt(old));\n\tcred_cxt(new) = cxt;\n\treturn 0;\n}\n\n/*\n * transfer the apparmor data to a blank set of creds\n */\nstatic void apparmor_cred_transfer(struct cred *new, const struct cred *old)\n{\n\tconst struct aa_task_cxt *old_cxt = cred_cxt(old);\n\tstruct aa_task_cxt *new_cxt = cred_cxt(new);\n\n\taa_dup_task_context(new_cxt, old_cxt);\n}\n\nstatic int apparmor_ptrace_access_check(struct task_struct *child,\n\t\t\t\t\tunsigned int mode)\n{\n\treturn aa_ptrace(current, child, mode);\n}\n\nstatic int apparmor_ptrace_traceme(struct task_struct *parent)\n{\n\treturn aa_ptrace(parent, current, PTRACE_MODE_ATTACH);\n}\n\n/* Derived from security/commoncap.c:cap_capget */\nstatic int apparmor_capget(struct task_struct *target, kernel_cap_t *effective,\n\t\t\t   kernel_cap_t *inheritable, kernel_cap_t *permitted)\n{\n\tstruct aa_profile *profile;\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\tcred = __task_cred(target);\n\tprofile = aa_cred_profile(cred);\n\n\t/*\n\t * cap_capget is stacked ahead of this and will\n\t * initialize effective and permitted.\n\t */\n\tif (!unconfined(profile) && !COMPLAIN_MODE(profile)) {\n\t\t*effective = cap_intersect(*effective, profile->caps.allow);\n\t\t*permitted = cap_intersect(*permitted, profile->caps.allow);\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int apparmor_capable(const struct cred *cred, struct user_namespace *ns,\n\t\t\t    int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tprofile = aa_cred_profile(cred);\n\tif (!unconfined(profile))\n\t\terror = aa_capable(profile, cap, audit);\n\treturn error;\n}\n\n/**\n * common_perm - basic common permission check wrapper fn for paths\n * @op: operation being checked\n * @path: path to check permission of  (NOT NULL)\n * @mask: requested permissions mask\n * @cond: conditional info for the permission request  (NOT NULL)\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm(int op, const struct path *path, u32 mask,\n\t\t       struct path_cond *cond)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tprofile = __aa_current_profile();\n\tif (!unconfined(profile))\n\t\terror = aa_path_perm(op, profile, path, 0, mask, cond);\n\n\treturn error;\n}\n\n/**\n * common_perm_dir_dentry - common permission wrapper when path is dir, dentry\n * @op: operation being checked\n * @dir: directory of the dentry  (NOT NULL)\n * @dentry: dentry to check  (NOT NULL)\n * @mask: requested permissions mask\n * @cond: conditional info for the permission request  (NOT NULL)\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_dir_dentry(int op, const struct path *dir,\n\t\t\t\t  struct dentry *dentry, u32 mask,\n\t\t\t\t  struct path_cond *cond)\n{\n\tstruct path path = { dir->mnt, dentry };\n\n\treturn common_perm(op, &path, mask, cond);\n}\n\n/**\n * common_perm_path - common permission wrapper when mnt, dentry\n * @op: operation being checked\n * @path: location to check (NOT NULL)\n * @mask: requested permissions mask\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic inline int common_perm_path(int op, const struct path *path, u32 mask)\n{\n\tstruct path_cond cond = { d_backing_inode(path->dentry)->i_uid,\n\t\t\t\t  d_backing_inode(path->dentry)->i_mode\n\t};\n\tif (!mediated_filesystem(path->dentry))\n\t\treturn 0;\n\n\treturn common_perm(op, path, mask, &cond);\n}\n\n/**\n * common_perm_rm - common permission wrapper for operations doing rm\n * @op: operation being checked\n * @dir: directory that the dentry is in  (NOT NULL)\n * @dentry: dentry being rm'd  (NOT NULL)\n * @mask: requested permission mask\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_rm(int op, const struct path *dir,\n\t\t\t  struct dentry *dentry, u32 mask)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct path_cond cond = { };\n\n\tif (!inode || !mediated_filesystem(dentry))\n\t\treturn 0;\n\n\tcond.uid = inode->i_uid;\n\tcond.mode = inode->i_mode;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}\n\n/**\n * common_perm_create - common permission wrapper for operations doing create\n * @op: operation being checked\n * @dir: directory that dentry will be created in  (NOT NULL)\n * @dentry: dentry to create   (NOT NULL)\n * @mask: request permission mask\n * @mode: created file mode\n *\n * Returns: %0 else error code if error or permission denied\n */\nstatic int common_perm_create(int op, const struct path *dir,\n\t\t\t      struct dentry *dentry, u32 mask, umode_t mode)\n{\n\tstruct path_cond cond = { current_fsuid(), mode };\n\n\tif (!mediated_filesystem(dir->dentry))\n\t\treturn 0;\n\n\treturn common_perm_dir_dentry(op, dir, dentry, mask, &cond);\n}\n\nstatic int apparmor_path_unlink(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_UNLINK, dir, dentry, AA_MAY_DELETE);\n}\n\nstatic int apparmor_path_mkdir(const struct path *dir, struct dentry *dentry,\n\t\t\t       umode_t mode)\n{\n\treturn common_perm_create(OP_MKDIR, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFDIR);\n}\n\nstatic int apparmor_path_rmdir(const struct path *dir, struct dentry *dentry)\n{\n\treturn common_perm_rm(OP_RMDIR, dir, dentry, AA_MAY_DELETE);\n}\n\nstatic int apparmor_path_mknod(const struct path *dir, struct dentry *dentry,\n\t\t\t       umode_t mode, unsigned int dev)\n{\n\treturn common_perm_create(OP_MKNOD, dir, dentry, AA_MAY_CREATE, mode);\n}\n\nstatic int apparmor_path_truncate(const struct path *path)\n{\n\treturn common_perm_path(OP_TRUNC, path, MAY_WRITE | AA_MAY_META_WRITE);\n}\n\nstatic int apparmor_path_symlink(const struct path *dir, struct dentry *dentry,\n\t\t\t\t const char *old_name)\n{\n\treturn common_perm_create(OP_SYMLINK, dir, dentry, AA_MAY_CREATE,\n\t\t\t\t  S_IFLNK);\n}\n\nstatic int apparmor_path_link(struct dentry *old_dentry, const struct path *new_dir,\n\t\t\t      struct dentry *new_dentry)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tif (!mediated_filesystem(old_dentry))\n\t\treturn 0;\n\n\tprofile = aa_current_profile();\n\tif (!unconfined(profile))\n\t\terror = aa_path_link(profile, old_dentry, new_dir, new_dentry);\n\treturn error;\n}\n\nstatic int apparmor_path_rename(const struct path *old_dir, struct dentry *old_dentry,\n\t\t\t\tconst struct path *new_dir, struct dentry *new_dentry)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tif (!mediated_filesystem(old_dentry))\n\t\treturn 0;\n\n\tprofile = aa_current_profile();\n\tif (!unconfined(profile)) {\n\t\tstruct path old_path = { old_dir->mnt, old_dentry };\n\t\tstruct path new_path = { new_dir->mnt, new_dentry };\n\t\tstruct path_cond cond = { d_backing_inode(old_dentry)->i_uid,\n\t\t\t\t\t  d_backing_inode(old_dentry)->i_mode\n\t\t};\n\n\t\terror = aa_path_perm(OP_RENAME_SRC, profile, &old_path, 0,\n\t\t\t\t     MAY_READ | AA_MAY_META_READ | MAY_WRITE |\n\t\t\t\t     AA_MAY_META_WRITE | AA_MAY_DELETE,\n\t\t\t\t     &cond);\n\t\tif (!error)\n\t\t\terror = aa_path_perm(OP_RENAME_DEST, profile, &new_path,\n\t\t\t\t\t     0, MAY_WRITE | AA_MAY_META_WRITE |\n\t\t\t\t\t     AA_MAY_CREATE, &cond);\n\n\t}\n\treturn error;\n}\n\nstatic int apparmor_path_chmod(const struct path *path, umode_t mode)\n{\n\treturn common_perm_path(OP_CHMOD, path, AA_MAY_CHMOD);\n}\n\nstatic int apparmor_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n{\n\treturn common_perm_path(OP_CHOWN, path, AA_MAY_CHOWN);\n}\n\nstatic int apparmor_inode_getattr(const struct path *path)\n{\n\treturn common_perm_path(OP_GETATTR, path, AA_MAY_META_READ);\n}\n\nstatic int apparmor_file_open(struct file *file, const struct cred *cred)\n{\n\tstruct aa_file_cxt *fcxt = file->f_security;\n\tstruct aa_profile *profile;\n\tint error = 0;\n\n\tif (!mediated_filesystem(file->f_path.dentry))\n\t\treturn 0;\n\n\t/* If in exec, permission is handled by bprm hooks.\n\t * Cache permissions granted by the previous exec check, with\n\t * implicit read and executable mmap which are required to\n\t * actually execute the image.\n\t */\n\tif (current->in_execve) {\n\t\tfcxt->allow = MAY_EXEC | MAY_READ | AA_EXEC_MMAP;\n\t\treturn 0;\n\t}\n\n\tprofile = aa_cred_profile(cred);\n\tif (!unconfined(profile)) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tstruct path_cond cond = { inode->i_uid, inode->i_mode };\n\n\t\terror = aa_path_perm(OP_OPEN, profile, &file->f_path, 0,\n\t\t\t\t     aa_map_file_to_perms(file), &cond);\n\t\t/* todo cache full allowed permissions set and state */\n\t\tfcxt->allow = aa_map_file_to_perms(file);\n\t}\n\n\treturn error;\n}\n\nstatic int apparmor_file_alloc_security(struct file *file)\n{\n\t/* freed by apparmor_file_free_security */\n\tfile->f_security = aa_alloc_file_context(GFP_KERNEL);\n\tif (!file->f_security)\n\t\treturn -ENOMEM;\n\treturn 0;\n\n}\n\nstatic void apparmor_file_free_security(struct file *file)\n{\n\tstruct aa_file_cxt *cxt = file->f_security;\n\n\taa_free_file_context(cxt);\n}\n\nstatic int common_file_perm(int op, struct file *file, u32 mask)\n{\n\tstruct aa_file_cxt *fcxt = file->f_security;\n\tstruct aa_profile *profile, *fprofile = aa_cred_profile(file->f_cred);\n\tint error = 0;\n\n\tBUG_ON(!fprofile);\n\n\tif (!file->f_path.mnt ||\n\t    !mediated_filesystem(file->f_path.dentry))\n\t\treturn 0;\n\n\tprofile = __aa_current_profile();\n\n\t/* revalidate access, if task is unconfined, or the cached cred\n\t * doesn't match or if the request is for more permissions than\n\t * was granted.\n\t *\n\t * Note: the test for !unconfined(fprofile) is to handle file\n\t *       delegation from unconfined tasks\n\t */\n\tif (!unconfined(profile) && !unconfined(fprofile) &&\n\t    ((fprofile != profile) || (mask & ~fcxt->allow)))\n\t\terror = aa_file_perm(op, profile, file, mask);\n\n\treturn error;\n}\n\nstatic int apparmor_file_permission(struct file *file, int mask)\n{\n\treturn common_file_perm(OP_FPERM, file, mask);\n}\n\nstatic int apparmor_file_lock(struct file *file, unsigned int cmd)\n{\n\tu32 mask = AA_MAY_LOCK;\n\n\tif (cmd == F_WRLCK)\n\t\tmask |= MAY_WRITE;\n\n\treturn common_file_perm(OP_FLOCK, file, mask);\n}\n\nstatic int common_mmap(int op, struct file *file, unsigned long prot,\n\t\t       unsigned long flags)\n{\n\tint mask = 0;\n\n\tif (!file || !file->f_security)\n\t\treturn 0;\n\n\tif (prot & PROT_READ)\n\t\tmask |= MAY_READ;\n\t/*\n\t * Private mappings don't require write perms since they don't\n\t * write back to the files\n\t */\n\tif ((prot & PROT_WRITE) && !(flags & MAP_PRIVATE))\n\t\tmask |= MAY_WRITE;\n\tif (prot & PROT_EXEC)\n\t\tmask |= AA_EXEC_MMAP;\n\n\treturn common_file_perm(op, file, mask);\n}\n\nstatic int apparmor_mmap_file(struct file *file, unsigned long reqprot,\n\t\t\t      unsigned long prot, unsigned long flags)\n{\n\treturn common_mmap(OP_FMMAP, file, prot, flags);\n}\n\nstatic int apparmor_file_mprotect(struct vm_area_struct *vma,\n\t\t\t\t  unsigned long reqprot, unsigned long prot)\n{\n\treturn common_mmap(OP_FMPROT, vma->vm_file, prot,\n\t\t\t   !(vma->vm_flags & VM_SHARED) ? MAP_PRIVATE : 0);\n}\n\nstatic int apparmor_getprocattr(struct task_struct *task, char *name,\n\t\t\t\tchar **value)\n{\n\tint error = -ENOENT;\n\t/* released below */\n\tconst struct cred *cred = get_task_cred(task);\n\tstruct aa_task_cxt *cxt = cred_cxt(cred);\n\tstruct aa_profile *profile = NULL;\n\n\tif (strcmp(name, \"current\") == 0)\n\t\tprofile = aa_get_newest_profile(cxt->profile);\n\telse if (strcmp(name, \"prev\") == 0  && cxt->previous)\n\t\tprofile = aa_get_newest_profile(cxt->previous);\n\telse if (strcmp(name, \"exec\") == 0 && cxt->onexec)\n\t\tprofile = aa_get_newest_profile(cxt->onexec);\n\telse\n\t\terror = -EINVAL;\n\n\tif (profile)\n\t\terror = aa_getprocattr(profile, value);\n\n\taa_put_profile(profile);\n\tput_cred(cred);\n\n\treturn error;\n}\n\nstatic int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *largs = NULL, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\t/* AppArmor requires that the buffer must be null terminated atm */\n\tif (args[size - 1] != '\\0') {\n\t\t/* null terminate */\n\t\tlargs = args = kmalloc(size + 1, GFP_KERNEL);\n\t\tif (!args)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(args, value, size);\n\t\targs[size] = '\\0';\n\t}\n\n\terror = -EINVAL;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\tgoto out;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\tgoto out;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\tgoto fail;\n\n\tif (!error)\n\t\terror = size;\nout:\n\tkfree(largs);\n\treturn error;\n\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\tgoto out;\n}\n\nstatic int apparmor_task_setrlimit(struct task_struct *task,\n\t\tunsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_profile *profile = __aa_current_profile();\n\tint error = 0;\n\n\tif (!unconfined(profile))\n\t\terror = aa_task_setrlimit(profile, task, resource, new_rlim);\n\n\treturn error;\n}\n\nstatic struct security_hook_list apparmor_hooks[] = {\n\tLSM_HOOK_INIT(ptrace_access_check, apparmor_ptrace_access_check),\n\tLSM_HOOK_INIT(ptrace_traceme, apparmor_ptrace_traceme),\n\tLSM_HOOK_INIT(capget, apparmor_capget),\n\tLSM_HOOK_INIT(capable, apparmor_capable),\n\n\tLSM_HOOK_INIT(path_link, apparmor_path_link),\n\tLSM_HOOK_INIT(path_unlink, apparmor_path_unlink),\n\tLSM_HOOK_INIT(path_symlink, apparmor_path_symlink),\n\tLSM_HOOK_INIT(path_mkdir, apparmor_path_mkdir),\n\tLSM_HOOK_INIT(path_rmdir, apparmor_path_rmdir),\n\tLSM_HOOK_INIT(path_mknod, apparmor_path_mknod),\n\tLSM_HOOK_INIT(path_rename, apparmor_path_rename),\n\tLSM_HOOK_INIT(path_chmod, apparmor_path_chmod),\n\tLSM_HOOK_INIT(path_chown, apparmor_path_chown),\n\tLSM_HOOK_INIT(path_truncate, apparmor_path_truncate),\n\tLSM_HOOK_INIT(inode_getattr, apparmor_inode_getattr),\n\n\tLSM_HOOK_INIT(file_open, apparmor_file_open),\n\tLSM_HOOK_INIT(file_permission, apparmor_file_permission),\n\tLSM_HOOK_INIT(file_alloc_security, apparmor_file_alloc_security),\n\tLSM_HOOK_INIT(file_free_security, apparmor_file_free_security),\n\tLSM_HOOK_INIT(mmap_file, apparmor_mmap_file),\n\tLSM_HOOK_INIT(file_mprotect, apparmor_file_mprotect),\n\tLSM_HOOK_INIT(file_lock, apparmor_file_lock),\n\n\tLSM_HOOK_INIT(getprocattr, apparmor_getprocattr),\n\tLSM_HOOK_INIT(setprocattr, apparmor_setprocattr),\n\n\tLSM_HOOK_INIT(cred_alloc_blank, apparmor_cred_alloc_blank),\n\tLSM_HOOK_INIT(cred_free, apparmor_cred_free),\n\tLSM_HOOK_INIT(cred_prepare, apparmor_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, apparmor_cred_transfer),\n\n\tLSM_HOOK_INIT(bprm_set_creds, apparmor_bprm_set_creds),\n\tLSM_HOOK_INIT(bprm_committing_creds, apparmor_bprm_committing_creds),\n\tLSM_HOOK_INIT(bprm_committed_creds, apparmor_bprm_committed_creds),\n\tLSM_HOOK_INIT(bprm_secureexec, apparmor_bprm_secureexec),\n\n\tLSM_HOOK_INIT(task_setrlimit, apparmor_task_setrlimit),\n};\n\n/*\n * AppArmor sysfs module parameters\n */\n\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp);\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp);\n#define param_check_aabool param_check_bool\nstatic const struct kernel_param_ops param_ops_aabool = {\n\t.flags = KERNEL_PARAM_OPS_FL_NOARG,\n\t.set = param_set_aabool,\n\t.get = param_get_aabool\n};\n\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp);\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp);\n#define param_check_aauint param_check_uint\nstatic const struct kernel_param_ops param_ops_aauint = {\n\t.set = param_set_aauint,\n\t.get = param_get_aauint\n};\n\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp);\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp);\n#define param_check_aalockpolicy param_check_bool\nstatic const struct kernel_param_ops param_ops_aalockpolicy = {\n\t.flags = KERNEL_PARAM_OPS_FL_NOARG,\n\t.set = param_set_aalockpolicy,\n\t.get = param_get_aalockpolicy\n};\n\nstatic int param_set_audit(const char *val, struct kernel_param *kp);\nstatic int param_get_audit(char *buffer, struct kernel_param *kp);\n\nstatic int param_set_mode(const char *val, struct kernel_param *kp);\nstatic int param_get_mode(char *buffer, struct kernel_param *kp);\n\n/* Flag values, also controllable via /sys/module/apparmor/parameters\n * We define special types as we want to do additional mediation.\n */\n\n/* AppArmor global enforcement switch - complain, enforce, kill */\nenum profile_mode aa_g_profile_mode = APPARMOR_ENFORCE;\nmodule_param_call(mode, param_set_mode, param_get_mode,\n\t\t  &aa_g_profile_mode, S_IRUSR | S_IWUSR);\n\n/* Debug mode */\nbool aa_g_debug;\nmodule_param_named(debug, aa_g_debug, aabool, S_IRUSR | S_IWUSR);\n\n/* Audit mode */\nenum audit_mode aa_g_audit;\nmodule_param_call(audit, param_set_audit, param_get_audit,\n\t\t  &aa_g_audit, S_IRUSR | S_IWUSR);\n\n/* Determines if audit header is included in audited messages.  This\n * provides more context if the audit daemon is not running\n */\nbool aa_g_audit_header = 1;\nmodule_param_named(audit_header, aa_g_audit_header, aabool,\n\t\t   S_IRUSR | S_IWUSR);\n\n/* lock out loading/removal of policy\n * TODO: add in at boot loading of policy, which is the only way to\n *       load policy, if lock_policy is set\n */\nbool aa_g_lock_policy;\nmodule_param_named(lock_policy, aa_g_lock_policy, aalockpolicy,\n\t\t   S_IRUSR | S_IWUSR);\n\n/* Syscall logging mode */\nbool aa_g_logsyscall;\nmodule_param_named(logsyscall, aa_g_logsyscall, aabool, S_IRUSR | S_IWUSR);\n\n/* Maximum pathname length before accesses will start getting rejected */\nunsigned int aa_g_path_max = 2 * PATH_MAX;\nmodule_param_named(path_max, aa_g_path_max, aauint, S_IRUSR | S_IWUSR);\n\n/* Determines how paranoid loading of policy is and how much verification\n * on the loaded policy is done.\n */\nbool aa_g_paranoid_load = 1;\nmodule_param_named(paranoid_load, aa_g_paranoid_load, aabool,\n\t\t   S_IRUSR | S_IWUSR);\n\n/* Boot time disable flag */\nstatic bool apparmor_enabled = CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE;\nmodule_param_named(enabled, apparmor_enabled, bool, S_IRUGO);\n\nstatic int __init apparmor_enabled_setup(char *str)\n{\n\tunsigned long enabled;\n\tint error = kstrtoul(str, 0, &enabled);\n\tif (!error)\n\t\tapparmor_enabled = enabled ? 1 : 0;\n\treturn 1;\n}\n\n__setup(\"apparmor=\", apparmor_enabled_setup);\n\n/* set global flag turning off the ability to load policy */\nstatic int param_set_aalockpolicy(const char *val, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (aa_g_lock_policy)\n\t\treturn -EACCES;\n\treturn param_set_bool(val, kp);\n}\n\nstatic int param_get_aalockpolicy(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}\n\nstatic int param_set_aabool(const char *val, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_set_bool(val, kp);\n}\n\nstatic int param_get_aabool(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_bool(buffer, kp);\n}\n\nstatic int param_set_aauint(const char *val, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_set_uint(val, kp);\n}\n\nstatic int param_get_aauint(char *buffer, const struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\treturn param_get_uint(buffer, kp);\n}\n\nstatic int param_get_audit(char *buffer, struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buffer, \"%s\", audit_mode_names[aa_g_audit]);\n}\n\nstatic int param_set_audit(const char *val, struct kernel_param *kp)\n{\n\tint i;\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < AUDIT_MAX_INDEX; i++) {\n\t\tif (strcmp(val, audit_mode_names[i]) == 0) {\n\t\t\taa_g_audit = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int param_get_mode(char *buffer, struct kernel_param *kp)\n{\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\treturn sprintf(buffer, \"%s\", aa_profile_mode_names[aa_g_profile_mode]);\n}\n\nstatic int param_set_mode(const char *val, struct kernel_param *kp)\n{\n\tint i;\n\tif (!capable(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!apparmor_enabled)\n\t\treturn -EINVAL;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < APPARMOR_MODE_NAMES_MAX_INDEX; i++) {\n\t\tif (strcmp(val, aa_profile_mode_names[i]) == 0) {\n\t\t\taa_g_profile_mode = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n/*\n * AppArmor init functions\n */\n\n/**\n * set_init_cxt - set a task context and profile on the first task.\n *\n * TODO: allow setting an alternate profile than unconfined\n */\nstatic int __init set_init_cxt(void)\n{\n\tstruct cred *cred = (struct cred *)current->real_cred;\n\tstruct aa_task_cxt *cxt;\n\n\tcxt = aa_alloc_task_context(GFP_KERNEL);\n\tif (!cxt)\n\t\treturn -ENOMEM;\n\n\tcxt->profile = aa_get_profile(root_ns->unconfined);\n\tcred_cxt(cred) = cxt;\n\n\treturn 0;\n}\n\nstatic int __init apparmor_init(void)\n{\n\tint error;\n\n\tif (!apparmor_enabled || !security_module_enable(\"apparmor\")) {\n\t\taa_info_message(\"AppArmor disabled by boot time parameter\");\n\t\tapparmor_enabled = 0;\n\t\treturn 0;\n\t}\n\n\terror = aa_alloc_root_ns();\n\tif (error) {\n\t\tAA_ERROR(\"Unable to allocate default profile namespace\\n\");\n\t\tgoto alloc_out;\n\t}\n\n\terror = set_init_cxt();\n\tif (error) {\n\t\tAA_ERROR(\"Failed to set context on init task\\n\");\n\t\taa_free_root_ns();\n\t\tgoto alloc_out;\n\t}\n\tsecurity_add_hooks(apparmor_hooks, ARRAY_SIZE(apparmor_hooks));\n\n\t/* Report that AppArmor successfully initialized */\n\tapparmor_initialized = 1;\n\tif (aa_g_profile_mode == APPARMOR_COMPLAIN)\n\t\taa_info_message(\"AppArmor initialized: complain mode enabled\");\n\telse if (aa_g_profile_mode == APPARMOR_KILL)\n\t\taa_info_message(\"AppArmor initialized: kill mode enabled\");\n\telse\n\t\taa_info_message(\"AppArmor initialized\");\n\n\treturn error;\n\nalloc_out:\n\taa_destroy_aafs();\n\n\tapparmor_enabled = 0;\n\treturn error;\n}\n\nsecurity_initcall(apparmor_init);\n"], "filenames": ["security/apparmor/lsm.c"], "buggy_code_start_loc": [503], "buggy_code_end_loc": [571], "fixing_code_start_loc": [503], "fixing_code_end_loc": [573], "type": "CWE-119", "message": "The apparmor_setprocattr function in security/apparmor/lsm.c in the Linux kernel before 4.6.5 does not validate the buffer size, which allows local users to gain privileges by triggering an AppArmor setprocattr hook.", "other": {"cve": {"id": "CVE-2016-6187", "sourceIdentifier": "cve@mitre.org", "published": "2016-08-06T20:59:10.800", "lastModified": "2023-01-17T21:15:40.233", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The apparmor_setprocattr function in security/apparmor/lsm.c in the Linux kernel before 4.6.5 does not validate the buffer size, which allows local users to gain privileges by triggering an AppArmor setprocattr hook."}, {"lang": "es", "value": "La funci\u00f3n apparmor_setprocattr en security/apparmor/lsm.c en el kernel de Linux en versiones anteriores a 4.6.5 no valida el tama\u00f1o de b\u00fafer, lo que permite a usuarios locales obtener privilegios desencadenando un gancho AppArmor setprocattr."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}, {"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.6.5", "matchCriteriaId": "3C4D37E6-8AC8-49A3-8C2F-A9FB2A4F7102"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=30a46a4647fd1df9cf52e43bf467f0d9265096ca", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://marc.info/?l=linux-kernel&m=146793642811929&w=2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.6.5", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/07/09/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/91696", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1354383", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/30a46a4647fd1df9cf52e43bf467f0d9265096ca", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/30a46a4647fd1df9cf52e43bf467f0d9265096ca"}}