{"buggy_code": ["/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * sf-pcapng.c - pcapng-file-format-specific code from savefile.c\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <pcap/pcap-inttypes.h>\n\n#include <errno.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"pcap-int.h\"\n\n#include \"pcap-common.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n#include \"sf-pcapng.h\"\n\n/*\n * Block types.\n */\n\n/*\n * Common part at the beginning of all blocks.\n */\nstruct block_header {\n\tbpf_u_int32\tblock_type;\n\tbpf_u_int32\ttotal_length;\n};\n\n/*\n * Common trailer at the end of all blocks.\n */\nstruct block_trailer {\n\tbpf_u_int32\ttotal_length;\n};\n\n/*\n * Common options.\n */\n#define OPT_ENDOFOPT\t0\t/* end of options */\n#define OPT_COMMENT\t1\t/* comment string */\n\n/*\n * Option header.\n */\nstruct option_header {\n\tu_short\t\toption_code;\n\tu_short\t\toption_length;\n};\n\n/*\n * Structures for the part of each block type following the common\n * part.\n */\n\n/*\n * Section Header Block.\n */\n#define BT_SHB\t\t\t0x0A0D0D0A\n\nstruct section_header_block {\n\tbpf_u_int32\tbyte_order_magic;\n\tu_short\t\tmajor_version;\n\tu_short\t\tminor_version;\n\tuint64_t\tsection_length;\n\t/* followed by options and trailer */\n};\n\n/*\n * Byte-order magic value.\n */\n#define BYTE_ORDER_MAGIC\t0x1A2B3C4D\n\n/*\n * Current version number.  If major_version isn't PCAP_NG_VERSION_MAJOR,\n * that means that this code can't read the file.\n */\n#define PCAP_NG_VERSION_MAJOR\t1\n#define PCAP_NG_VERSION_MINOR\t0\n\n/*\n * Interface Description Block.\n */\n#define BT_IDB\t\t\t0x00000001\n\nstruct interface_description_block {\n\tu_short\t\tlinktype;\n\tu_short\t\treserved;\n\tbpf_u_int32\tsnaplen;\n\t/* followed by options and trailer */\n};\n\n/*\n * Options in the IDB.\n */\n#define IF_NAME\t\t2\t/* interface name string */\n#define IF_DESCRIPTION\t3\t/* interface description string */\n#define IF_IPV4ADDR\t4\t/* interface's IPv4 address and netmask */\n#define IF_IPV6ADDR\t5\t/* interface's IPv6 address and prefix length */\n#define IF_MACADDR\t6\t/* interface's MAC address */\n#define IF_EUIADDR\t7\t/* interface's EUI address */\n#define IF_SPEED\t8\t/* interface's speed, in bits/s */\n#define IF_TSRESOL\t9\t/* interface's time stamp resolution */\n#define IF_TZONE\t10\t/* interface's time zone */\n#define IF_FILTER\t11\t/* filter used when capturing on interface */\n#define IF_OS\t\t12\t/* string OS on which capture on this interface was done */\n#define IF_FCSLEN\t13\t/* FCS length for this interface */\n#define IF_TSOFFSET\t14\t/* time stamp offset for this interface */\n\n/*\n * Enhanced Packet Block.\n */\n#define BT_EPB\t\t\t0x00000006\n\nstruct enhanced_packet_block {\n\tbpf_u_int32\tinterface_id;\n\tbpf_u_int32\ttimestamp_high;\n\tbpf_u_int32\ttimestamp_low;\n\tbpf_u_int32\tcaplen;\n\tbpf_u_int32\tlen;\n\t/* followed by packet data, options, and trailer */\n};\n\n/*\n * Simple Packet Block.\n */\n#define BT_SPB\t\t\t0x00000003\n\nstruct simple_packet_block {\n\tbpf_u_int32\tlen;\n\t/* followed by packet data and trailer */\n};\n\n/*\n * Packet Block.\n */\n#define BT_PB\t\t\t0x00000002\n\nstruct packet_block {\n\tu_short\t\tinterface_id;\n\tu_short\t\tdrops_count;\n\tbpf_u_int32\ttimestamp_high;\n\tbpf_u_int32\ttimestamp_low;\n\tbpf_u_int32\tcaplen;\n\tbpf_u_int32\tlen;\n\t/* followed by packet data, options, and trailer */\n};\n\n/*\n * Block cursor - used when processing the contents of a block.\n * Contains a pointer into the data being processed and a count\n * of bytes remaining in the block.\n */\nstruct block_cursor {\n\tu_char\t\t*data;\n\tsize_t\t\tdata_remaining;\n\tbpf_u_int32\tblock_type;\n};\n\ntypedef enum {\n\tPASS_THROUGH,\n\tSCALE_UP_DEC,\n\tSCALE_DOWN_DEC,\n\tSCALE_UP_BIN,\n\tSCALE_DOWN_BIN\n} tstamp_scale_type_t;\n\n/*\n * Per-interface information.\n */\nstruct pcap_ng_if {\n\tuint64_t tsresol;\t\t/* time stamp resolution */\n\ttstamp_scale_type_t scale_type;\t/* how to scale */\n\tuint64_t scale_factor;\t\t/* time stamp scale factor for power-of-10 tsresol */\n\tuint64_t tsoffset;\t\t/* time stamp offset */\n};\n\n/*\n * Per-pcap_t private data.\n *\n * max_blocksize is the maximum size of a block that we'll accept.  We\n * reject blocks bigger than this, so we don't consume too much memory\n * with a truly huge block.  It can change as we see IDBs with different\n * link-layer header types.  (Currently, we don't support IDBs with\n * different link-layer header types, but we will support it in the\n * future, when we offer file-reading APIs that support it.)\n *\n * XXX - that's an issue on ILP32 platforms, where the maximum block\n * size of 2^31-1 would eat all but one byte of the entire address space.\n * It's less of an issue on ILP64/LLP64 platforms, but the actual size\n * of the address space may be limited by 1) the number of *significant*\n * address bits (currently, x86-64 only supports 48 bits of address), 2)\n * any limitations imposed by the operating system; 3) any limitations\n * imposed by the amount of available backing store for anonymous pages,\n * so we impose a limit regardless of the size of a pointer.\n */\nstruct pcap_ng_sf {\n\tuint64_t user_tsresol;\t\t/* time stamp resolution requested by the user */\n\tu_int max_blocksize;\t\t/* don't grow buffer size past this */\n\tbpf_u_int32 ifcount;\t\t/* number of interfaces seen in this capture */\n\tbpf_u_int32 ifaces_size;\t/* size of array below */\n\tstruct pcap_ng_if *ifaces;\t/* array of interface information */\n};\n\n/*\n * The maximum block size we start with; we use an arbitrary value of\n * 16 MiB.\n */\n#define INITIAL_MAX_BLOCKSIZE\t(16*1024*1024)\n\n/*\n * Maximum block size for a given maximum snapshot length; we define it\n * as the size of an EPB with a max_snaplen-sized packet and 128KB of\n * options.\n */\n#define MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen) \\\n\t(sizeof (struct block_header) + \\\n\t sizeof (struct enhanced_packet_block) + \\\n\t (max_snaplen) + 131072 + \\\n\t sizeof (struct block_trailer))\n\nstatic void pcap_ng_cleanup(pcap_t *p);\nstatic int pcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr,\n    u_char **data);\n\nstatic int\nread_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,\n    char *errbuf)\n{\n\tsize_t amt_read;\n\n\tamt_read = fread(buf, 1, bytes_to_read, fp);\n\tif (amt_read != bytes_to_read) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t} else {\n\t\t\tif (amt_read == 0 && !fail_on_eof)\n\t\t\t\treturn (0);\t/* EOF */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"truncated dump file; tried to read %\" PRIsize \" bytes, only got %\" PRIsize,\n\t\t\t    bytes_to_read, amt_read);\n\t\t}\n\t\treturn (-1);\n\t}\n\treturn (1);\n}\n\nstatic int\nread_block(FILE *fp, pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_header bhdr;\n\tstruct block_trailer *btrlr;\n\tu_char *bdata;\n\tsize_t data_remaining;\n\n\tps = p->priv;\n\n\tstatus = read_bytes(fp, &bhdr, sizeof(bhdr), 0, errbuf);\n\tif (status <= 0)\n\t\treturn (status);\t/* error or EOF */\n\n\tif (p->swapped) {\n\t\tbhdr.block_type = SWAPLONG(bhdr.block_type);\n\t\tbhdr.total_length = SWAPLONG(bhdr.total_length);\n\t}\n\n\t/*\n\t * Is this block \"too small\" - i.e., is it shorter than a block\n\t * header plus a block trailer?\n\t */\n\tif (bhdr.total_length < sizeof(struct block_header) +\n\t    sizeof(struct block_trailer)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block in pcapng dump file has a length of %u < %\" PRIsize,\n\t\t    bhdr.total_length,\n\t\t    sizeof(struct block_header) + sizeof(struct block_trailer));\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Is the block total length a multiple of 4?\n\t */\n\tif ((bhdr.total_length % 4) != 0) {\n\t\t/*\n\t\t * No.  Report that as an error.\n\t\t */\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block in pcapng dump file has a length of %u that is not a multiple of 4\" PRIsize,\n\t\t    bhdr.total_length);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Is the buffer big enough?\n\t */\n\tif (p->bufsize < bhdr.total_length) {\n\t\t/*\n\t\t * No - make it big enough, unless it's too big, in\n\t\t * which case we fail.\n\t\t */\n\t\tvoid *bigger_buffer;\n\n\t\tif (bhdr.total_length > ps->max_blocksize) {\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"pcapng block size %u > maximum %u\", bhdr.total_length,\n\t\t\t    ps->max_blocksize);\n\t\t\treturn (-1);\n\t\t}\n\t\tbigger_buffer = realloc(p->buffer, bhdr.total_length);\n\t\tif (bigger_buffer == NULL) {\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\t\treturn (-1);\n\t\t}\n\t\tp->buffer = bigger_buffer;\n\t}\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the block.\n\t */\n\tmemcpy(p->buffer, &bhdr, sizeof(bhdr));\n\tbdata = (u_char *)p->buffer + sizeof(bhdr);\n\tdata_remaining = bhdr.total_length - sizeof(bhdr);\n\tif (read_bytes(fp, bdata, data_remaining, 1, errbuf) == -1)\n\t\treturn (-1);\n\n\t/*\n\t * Get the block size from the trailer.\n\t */\n\tbtrlr = (struct block_trailer *)(bdata + data_remaining - sizeof (struct block_trailer));\n\tif (p->swapped)\n\t\tbtrlr->total_length = SWAPLONG(btrlr->total_length);\n\n\t/*\n\t * Is the total length from the trailer the same as the total\n\t * length from the header?\n\t */\n\tif (bhdr.total_length != btrlr->total_length) {\n\t\t/*\n\t\t * No.\n\t\t */\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block total length in header and trailer don't match\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Initialize the cursor.\n\t */\n\tcursor->data = bdata;\n\tcursor->data_remaining = data_remaining - sizeof(struct block_trailer);\n\tcursor->block_type = bhdr.block_type;\n\treturn (1);\n}\n\nstatic void *\nget_from_block_data(struct block_cursor *cursor, size_t chunk_size,\n    char *errbuf)\n{\n\tvoid *data;\n\n\t/*\n\t * Make sure we have the specified amount of data remaining in\n\t * the block data.\n\t */\n\tif (cursor->data_remaining < chunk_size) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block of type %u in pcapng dump file is too short\",\n\t\t    cursor->block_type);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Return the current pointer, and skip past the chunk.\n\t */\n\tdata = cursor->data;\n\tcursor->data += chunk_size;\n\tcursor->data_remaining -= chunk_size;\n\treturn (data);\n}\n\nstatic struct option_header *\nget_opthdr_from_block_data(pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct option_header *opthdr;\n\n\topthdr = get_from_block_data(cursor, sizeof(*opthdr), errbuf);\n\tif (opthdr == NULL) {\n\t\t/*\n\t\t * Option header is cut short.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Byte-swap it if necessary.\n\t */\n\tif (p->swapped) {\n\t\topthdr->option_code = SWAPSHORT(opthdr->option_code);\n\t\topthdr->option_length = SWAPSHORT(opthdr->option_length);\n\t}\n\n\treturn (opthdr);\n}\n\nstatic void *\nget_optvalue_from_block_data(struct block_cursor *cursor,\n    struct option_header *opthdr, char *errbuf)\n{\n\tsize_t padded_option_len;\n\tvoid *optvalue;\n\n\t/* Pad option length to 4-byte boundary */\n\tpadded_option_len = opthdr->option_length;\n\tpadded_option_len = ((padded_option_len + 3)/4)*4;\n\n\toptvalue = get_from_block_data(cursor, padded_option_len, errbuf);\n\tif (optvalue == NULL) {\n\t\t/*\n\t\t * Option value is cut short.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\treturn (optvalue);\n}\n\nstatic int\nprocess_idb_options(pcap_t *p, struct block_cursor *cursor, uint64_t *tsresol,\n    uint64_t *tsoffset, int *is_binary, char *errbuf)\n{\n\tstruct option_header *opthdr;\n\tvoid *optvalue;\n\tint saw_tsresol, saw_tsoffset;\n\tuint8_t tsresol_opt;\n\tu_int i;\n\n\tsaw_tsresol = 0;\n\tsaw_tsoffset = 0;\n\twhile (cursor->data_remaining != 0) {\n\t\t/*\n\t\t * Get the option header.\n\t\t */\n\t\topthdr = get_opthdr_from_block_data(p, cursor, errbuf);\n\t\tif (opthdr == NULL) {\n\t\t\t/*\n\t\t\t * Option header is cut short.\n\t\t\t */\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Get option value.\n\t\t */\n\t\toptvalue = get_optvalue_from_block_data(cursor, opthdr,\n\t\t    errbuf);\n\t\tif (optvalue == NULL) {\n\t\t\t/*\n\t\t\t * Option value is cut short.\n\t\t\t */\n\t\t\treturn (-1);\n\t\t}\n\n\t\tswitch (opthdr->option_code) {\n\n\t\tcase OPT_ENDOFOPT:\n\t\t\tif (opthdr->option_length != 0) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has opt_endofopt option with length %u != 0\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tcase IF_TSRESOL:\n\t\t\tif (opthdr->option_length != 1) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has if_tsresol option with length %u != 1\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (saw_tsresol) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has more than one if_tsresol option\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tsaw_tsresol = 1;\n\t\t\tmemcpy(&tsresol_opt, optvalue, sizeof(tsresol_opt));\n\t\t\tif (tsresol_opt & 0x80) {\n\t\t\t\t/*\n\t\t\t\t * Resolution is negative power of 2.\n\t\t\t\t */\n\t\t\t\tuint8_t tsresol_shift = (tsresol_opt & 0x7F);\n\n\t\t\t\tif (tsresol_shift > 63) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Resolution is too high; 2^-{res}\n\t\t\t\t\t * won't fit in a 64-bit value.\n\t\t\t\t\t */\n\t\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Interface Description Block if_tsresol option resolution 2^-%u is too high\",\n\t\t\t\t\t    tsresol_shift);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\t*is_binary = 1;\n\t\t\t\t*tsresol = ((uint64_t)1) << tsresol_shift;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Resolution is negative power of 10.\n\t\t\t\t */\n\t\t\t\tif (tsresol_opt > 19) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Resolution is too high; 2^-{res}\n\t\t\t\t\t * won't fit in a 64-bit value (the\n\t\t\t\t\t * largest power of 10 that fits\n\t\t\t\t\t * in a 64-bit value is 10^19, as\n\t\t\t\t\t * the largest 64-bit unsigned\n\t\t\t\t\t * value is ~1.8*10^19).\n\t\t\t\t\t */\n\t\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Interface Description Block if_tsresol option resolution 10^-%u is too high\",\n\t\t\t\t\t    tsresol_opt);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\t*is_binary = 0;\n\t\t\t\t*tsresol = 1;\n\t\t\t\tfor (i = 0; i < tsresol_opt; i++)\n\t\t\t\t\t*tsresol *= 10;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IF_TSOFFSET:\n\t\t\tif (opthdr->option_length != 8) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has if_tsoffset option with length %u != 8\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (saw_tsoffset) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has more than one if_tsoffset option\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tsaw_tsoffset = 1;\n\t\t\tmemcpy(tsoffset, optvalue, sizeof(*tsoffset));\n\t\t\tif (p->swapped)\n\t\t\t\t*tsoffset = SWAPLL(*tsoffset);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\treturn (0);\n}\n\nstatic int\nadd_interface(pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct pcap_ng_sf *ps;\n\tuint64_t tsresol;\n\tuint64_t tsoffset;\n\tint is_binary;\n\n\tps = p->priv;\n\n\t/*\n\t * Count this interface.\n\t */\n\tps->ifcount++;\n\n\t/*\n\t * Grow the array of per-interface information as necessary.\n\t */\n\tif (ps->ifcount > ps->ifaces_size) {\n\t\t/*\n\t\t * We need to grow the array.\n\t\t */\n\t\tbpf_u_int32 new_ifaces_size;\n\t\tstruct pcap_ng_if *new_ifaces;\n\n\t\tif (ps->ifaces_size == 0) {\n\t\t\t/*\n\t\t\t * It's currently empty.\n\t\t\t *\n\t\t\t * (The Clang static analyzer doesn't do enough,\n\t\t\t * err, umm, dataflow *analysis* to realize that\n\t\t\t * ps->ifaces_size == 0 if ps->ifaces == NULL,\n\t\t\t * and so complains about a possible zero argument\n\t\t\t * to realloc(), so we check for the former\n\t\t\t * condition to shut it up.\n\t\t\t *\n\t\t\t * However, it doesn't complain that one of the\n\t\t\t * multiplications below could overflow, which is\n\t\t\t * a real, albeit extremely unlikely, problem (you'd\n\t\t\t * need a pcapng file with tens of millions of\n\t\t\t * interfaces).)\n\t\t\t */\n\t\t\tnew_ifaces_size = 1;\n\t\t\tnew_ifaces = malloc(sizeof (struct pcap_ng_if));\n\t\t} else {\n\t\t\t/*\n\t\t\t * It's not currently empty; double its size.\n\t\t\t * (Perhaps overkill once we have a lot of interfaces.)\n\t\t\t *\n\t\t\t * Check for overflow if we double it.\n\t\t\t */\n\t\t\tif (ps->ifaces_size * 2 < ps->ifaces_size) {\n\t\t\t\t/*\n\t\t\t\t * The maximum number of interfaces before\n\t\t\t\t * ps->ifaces_size overflows is the largest\n\t\t\t\t * possible 32-bit power of 2, as we do\n\t\t\t\t * size doubling.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"more than %u interfaces in the file\",\n\t\t\t\t    0x80000000U);\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ps->ifaces_size * 2 doesn't overflow, so it's\n\t\t\t * safe to multiply.\n\t\t\t */\n\t\t\tnew_ifaces_size = ps->ifaces_size * 2;\n\n\t\t\t/*\n\t\t\t * Now make sure that's not so big that it overflows\n\t\t\t * if we multiply by sizeof (struct pcap_ng_if).\n\t\t\t *\n\t\t\t * That can happen on 32-bit platforms, with a 32-bit\n\t\t\t * size_t; it shouldn't happen on 64-bit platforms,\n\t\t\t * with a 64-bit size_t, as new_ifaces_size is\n\t\t\t * 32 bits.\n\t\t\t */\n\t\t\tif (new_ifaces_size * sizeof (struct pcap_ng_if) < new_ifaces_size) {\n\t\t\t\t/*\n\t\t\t\t * As this fails only with 32-bit size_t,\n\t\t\t\t * the multiplication was 32x32->32, and\n\t\t\t\t * the largest 32-bit value that can safely\n\t\t\t\t * be multiplied by sizeof (struct pcap_ng_if)\n\t\t\t\t * without overflow is the largest 32-bit\n\t\t\t\t * (unsigned) value divided by\n\t\t\t\t * sizeof (struct pcap_ng_if).\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"more than %u interfaces in the file\",\n\t\t\t\t    0xFFFFFFFFU / ((u_int)sizeof (struct pcap_ng_if)));\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tnew_ifaces = realloc(ps->ifaces, new_ifaces_size * sizeof (struct pcap_ng_if));\n\t\t}\n\t\tif (new_ifaces == NULL) {\n\t\t\t/*\n\t\t\t * We ran out of memory.\n\t\t\t * Give up.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"out of memory for per-interface information (%u interfaces)\",\n\t\t\t    ps->ifcount);\n\t\t\treturn (0);\n\t\t}\n\t\tps->ifaces_size = new_ifaces_size;\n\t\tps->ifaces = new_ifaces;\n\t}\n\n\t/*\n\t * Set the default time stamp resolution and offset.\n\t */\n\ttsresol = 1000000;\t/* microsecond resolution */\n\tis_binary = 0;\t\t/* which is a power of 10 */\n\ttsoffset = 0;\t\t/* absolute timestamps */\n\n\t/*\n\t * Now look for various time stamp options, so we know\n\t * how to interpret the time stamps for this interface.\n\t */\n\tif (process_idb_options(p, cursor, &tsresol, &tsoffset, &is_binary,\n\t    errbuf) == -1)\n\t\treturn (0);\n\n\tps->ifaces[ps->ifcount - 1].tsresol = tsresol;\n\tps->ifaces[ps->ifcount - 1].tsoffset = tsoffset;\n\n\t/*\n\t * Determine whether we're scaling up or down or not\n\t * at all for this interface.\n\t */\n\tif (tsresol == ps->user_tsresol) {\n\t\t/*\n\t\t * The resolution is the resolution the user wants,\n\t\t * so we don't have to do scaling.\n\t\t */\n\t\tps->ifaces[ps->ifcount - 1].scale_type = PASS_THROUGH;\n\t} else if (tsresol > ps->user_tsresol) {\n\t\t/*\n\t\t * The resolution is greater than what the user wants,\n\t\t * so we have to scale the timestamps down.\n\t\t */\n\t\tif (is_binary)\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_BIN;\n\t\telse {\n\t\t\t/*\n\t\t\t * Calculate the scale factor.\n\t\t\t */\n\t\t\tps->ifaces[ps->ifcount - 1].scale_factor = tsresol/ps->user_tsresol;\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_DEC;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The resolution is less than what the user wants,\n\t\t * so we have to scale the timestamps up.\n\t\t */\n\t\tif (is_binary)\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_BIN;\n\t\telse {\n\t\t\t/*\n\t\t\t * Calculate the scale factor.\n\t\t\t */\n\t\t\tps->ifaces[ps->ifcount - 1].scale_factor = ps->user_tsresol/tsresol;\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_DEC;\n\t\t}\n\t}\n\treturn (1);\n}\n\n/*\n * Check whether this is a pcapng savefile and, if it is, extract the\n * relevant information from the header.\n */\npcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has a length of %u < %\" PRIsize,\n\t\t    total_length,\n\t\t    sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer));\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Make sure it's not too big.\n\t */\n\tif (total_length > INITIAL_MAX_BLOCKSIZE) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"pcapng block size %u > maximum %u\",\n\t\t    total_length, INITIAL_MAX_BLOCKSIZE);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}\n\nstatic void\npcap_ng_cleanup(pcap_t *p)\n{\n\tstruct pcap_ng_sf *ps = p->priv;\n\n\tfree(ps->ifaces);\n\tsf_cleanup(p);\n}\n\n/*\n * Read and return the next packet from the savefile.  Return the header\n * in hdr and a pointer to the contents in data.  Return 0 on success, 1\n * if there were no more packets, and -1 on an error.\n */\nstatic int\npcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)\n{\n\tstruct pcap_ng_sf *ps = p->priv;\n\tstruct block_cursor cursor;\n\tint status;\n\tstruct enhanced_packet_block *epbp;\n\tstruct simple_packet_block *spbp;\n\tstruct packet_block *pbp;\n\tbpf_u_int32 interface_id = 0xFFFFFFFF;\n\tstruct interface_description_block *idbp;\n\tstruct section_header_block *shbp;\n\tFILE *fp = p->rfile;\n\tuint64_t t, sec, frac;\n\n\t/*\n\t * Look for an Enhanced Packet Block, a Simple Packet Block,\n\t * or a Packet Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the block type and length; those are common\n\t\t * to all blocks.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, p->errbuf);\n\t\tif (status == 0)\n\t\t\treturn (1);\t/* EOF */\n\t\tif (status == -1)\n\t\t\treturn (-1);\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_EPB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * EPB.\n\t\t\t */\n\t\t\tepbp = get_from_block_data(&cursor, sizeof(*epbp),\n\t\t\t    p->errbuf);\n\t\t\tif (epbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\tinterface_id = SWAPLONG(epbp->interface_id);\n\t\t\t\thdr->caplen = SWAPLONG(epbp->caplen);\n\t\t\t\thdr->len = SWAPLONG(epbp->len);\n\t\t\t\tt = ((uint64_t)SWAPLONG(epbp->timestamp_high)) << 32 |\n\t\t\t\t    SWAPLONG(epbp->timestamp_low);\n\t\t\t} else {\n\t\t\t\tinterface_id = epbp->interface_id;\n\t\t\t\thdr->caplen = epbp->caplen;\n\t\t\t\thdr->len = epbp->len;\n\t\t\t\tt = ((uint64_t)epbp->timestamp_high) << 32 |\n\t\t\t\t    epbp->timestamp_low;\n\t\t\t}\n\t\t\tgoto found;\n\n\t\tcase BT_SPB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * SPB.\n\t\t\t */\n\t\t\tspbp = get_from_block_data(&cursor, sizeof(*spbp),\n\t\t\t    p->errbuf);\n\t\t\tif (spbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * SPB packets are assumed to have arrived on\n\t\t\t * the first interface.\n\t\t\t */\n\t\t\tinterface_id = 0;\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\thdr->len = SWAPLONG(spbp->len);\n\t\t\t} else\n\t\t\t\thdr->len = spbp->len;\n\n\t\t\t/*\n\t\t\t * The SPB doesn't give the captured length;\n\t\t\t * it's the minimum of the snapshot length\n\t\t\t * and the packet length.\n\t\t\t */\n\t\t\thdr->caplen = hdr->len;\n\t\t\tif (hdr->caplen > (bpf_u_int32)p->snapshot)\n\t\t\t\thdr->caplen = p->snapshot;\n\t\t\tt = 0;\t/* no time stamps */\n\t\t\tgoto found;\n\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * PB.\n\t\t\t */\n\t\t\tpbp = get_from_block_data(&cursor, sizeof(*pbp),\n\t\t\t    p->errbuf);\n\t\t\tif (pbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\tinterface_id = SWAPSHORT(pbp->interface_id);\n\t\t\t\thdr->caplen = SWAPLONG(pbp->caplen);\n\t\t\t\thdr->len = SWAPLONG(pbp->len);\n\t\t\t\tt = ((uint64_t)SWAPLONG(pbp->timestamp_high)) << 32 |\n\t\t\t\t    SWAPLONG(pbp->timestamp_low);\n\t\t\t} else {\n\t\t\t\tinterface_id = pbp->interface_id;\n\t\t\t\thdr->caplen = pbp->caplen;\n\t\t\t\thdr->len = pbp->len;\n\t\t\t\tt = ((uint64_t)pbp->timestamp_high) << 32 |\n\t\t\t\t    pbp->timestamp_low;\n\t\t\t}\n\t\t\tgoto found;\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Interface Description Block.  Get a pointer\n\t\t\t * to its fixed-length portion.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    p->errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the link-layer type or snapshot length\n\t\t\t * differ from the ones for the first IDB we\n\t\t\t * saw, quit.\n\t\t\t *\n\t\t\t * XXX - just discard packets from those\n\t\t\t * interfaces?\n\t\t\t */\n\t\t\tif (p->linktype != idbp->linktype) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"an interface has a type %u different from the type of the first interface\",\n\t\t\t\t    idbp->linktype);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check against the *adjusted* value of this IDB's\n\t\t\t * snapshot length.\n\t\t\t */\n\t\t\tif ((bpf_u_int32)p->snapshot !=\n\t\t\t    pcap_adjust_snapshot(p->linktype, idbp->snaplen)) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"an interface has a snapshot length %u different from the type of the first interface\",\n\t\t\t\t    idbp->snaplen);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, p->errbuf))\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\n\t\tcase BT_SHB:\n\t\t\t/*\n\t\t\t * Section Header Block.  Get a pointer\n\t\t\t * to its fixed-length portion.\n\t\t\t */\n\t\t\tshbp = get_from_block_data(&cursor, sizeof(*shbp),\n\t\t\t    p->errbuf);\n\t\t\tif (shbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Assume the byte order of this section is\n\t\t\t * the same as that of the previous section.\n\t\t\t * We'll check for that later.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tshbp->byte_order_magic =\n\t\t\t\t    SWAPLONG(shbp->byte_order_magic);\n\t\t\t\tshbp->major_version =\n\t\t\t\t    SWAPSHORT(shbp->major_version);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure the byte order doesn't change;\n\t\t\t * pcap_is_swapped() shouldn't change its\n\t\t\t * return value in the middle of reading a capture.\n\t\t\t */\n\t\t\tswitch (shbp->byte_order_magic) {\n\n\t\t\tcase BYTE_ORDER_MAGIC:\n\t\t\t\t/*\n\t\t\t\t * OK.\n\t\t\t\t */\n\t\t\t\tbreak;\n\n\t\t\tcase SWAPLONG(BYTE_ORDER_MAGIC):\n\t\t\t\t/*\n\t\t\t\t * Byte order changes.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"the file has sections with different byte orders\");\n\t\t\t\treturn (-1);\n\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Not a valid SHB.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"the file has a section with a bad byte order magic field\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure the major version is the version\n\t\t\t * we handle.\n\t\t\t */\n\t\t\tif (shbp->major_version != PCAP_NG_VERSION_MAJOR) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"unknown pcapng savefile major version number %u\",\n\t\t\t\t    shbp->major_version);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Reset the interface count; this section should\n\t\t\t * have its own set of IDBs.  If any of them\n\t\t\t * don't have the same interface type, snapshot\n\t\t\t * length, or resolution as the first interface\n\t\t\t * we saw, we'll fail.  (And if we don't see\n\t\t\t * any IDBs, we'll fail when we see a packet\n\t\t\t * block.)\n\t\t\t */\n\t\t\tps->ifcount = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Not a packet block, IDB, or SHB; ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\nfound:\n\t/*\n\t * Is the interface ID an interface we know?\n\t */\n\tif (interface_id >= ps->ifcount) {\n\t\t/*\n\t\t * Yes.  Fail.\n\t\t */\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"a packet arrived on interface %u, but there's no Interface Description Block for that interface\",\n\t\t    interface_id);\n\t\treturn (-1);\n\t}\n\n\tif (hdr->caplen > (bpf_u_int32)p->snapshot) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"invalid packet capture length %u, bigger than \"\n\t\t    \"snaplen of %d\", hdr->caplen, p->snapshot);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Convert the time stamp to seconds and fractions of a second,\n\t * with the fractions being in units of the file-supplied resolution.\n\t */\n\tsec = t / ps->ifaces[interface_id].tsresol + ps->ifaces[interface_id].tsoffset;\n\tfrac = t % ps->ifaces[interface_id].tsresol;\n\n\t/*\n\t * Convert the fractions from units of the file-supplied resolution\n\t * to units of the user-requested resolution.\n\t */\n\tswitch (ps->ifaces[interface_id].scale_type) {\n\n\tcase PASS_THROUGH:\n\t\t/*\n\t\t * The interface resolution is what the user wants,\n\t\t * so we're done.\n\t\t */\n\t\tbreak;\n\n\tcase SCALE_UP_DEC:\n\t\t/*\n\t\t * The interface resolution is less than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * Those resolutions are both powers of 10, and the user-\n\t\t * requested resolution is greater than the file-supplied\n\t\t * resolution, so the quotient in question is an integer.\n\t\t * We've calculated that quotient already, so we just\n\t\t * multiply by it.\n\t\t */\n\t\tfrac *= ps->ifaces[interface_id].scale_factor;\n\t\tbreak;\n\n\tcase SCALE_UP_BIN:\n\t\t/*\n\t\t * The interface resolution is less than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * The file-supplied resolution is a power of 2, so the\n\t\t * quotient is not an integer, so, in order to do this\n\t\t * entirely with integer arithmetic, we multiply by the\n\t\t * user-requested resolution and divide by the file-\n\t\t * supplied resolution.\n\t\t *\n\t\t * XXX - Is there something clever we could do here,\n\t\t * given that we know that the file-supplied resolution\n\t\t * is a power of 2?  Doing a multiplication followed by\n\t\t * a division runs the risk of overflowing, and involves\n\t\t * two non-simple arithmetic operations.\n\t\t */\n\t\tfrac *= ps->user_tsresol;\n\t\tfrac /= ps->ifaces[interface_id].tsresol;\n\t\tbreak;\n\n\tcase SCALE_DOWN_DEC:\n\t\t/*\n\t\t * The interface resolution is greater than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * Those resolutions are both powers of 10, and the user-\n\t\t * requested resolution is less than the file-supplied\n\t\t * resolution, so the quotient in question isn't an\n\t\t * integer, but its reciprocal is, and we can just divide\n\t\t * by the reciprocal of the quotient.  We've calculated\n\t\t * the reciprocal of that quotient already, so we must\n\t\t * divide by it.\n\t\t */\n\t\tfrac /= ps->ifaces[interface_id].scale_factor;\n\t\tbreak;\n\n\n\tcase SCALE_DOWN_BIN:\n\t\t/*\n\t\t * The interface resolution is greater than what the user\n\t\t * wants; convert the fractional part to units of the\n\t\t * resolution the user requested by multiplying by the\n\t\t * quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.  We do that by multiplying\n\t\t * by the user-requested resolution and dividing by the\n\t\t * file-supplied resolution, as the quotient might not\n\t\t * fit in an integer.\n\t\t *\n\t\t * The file-supplied resolution is a power of 2, so the\n\t\t * quotient is not an integer, and neither is its\n\t\t * reciprocal, so, in order to do this entirely with\n\t\t * integer arithmetic, we multiply by the user-requested\n\t\t * resolution and divide by the file-supplied resolution.\n\t\t *\n\t\t * XXX - Is there something clever we could do here,\n\t\t * given that we know that the file-supplied resolution\n\t\t * is a power of 2?  Doing a multiplication followed by\n\t\t * a division runs the risk of overflowing, and involves\n\t\t * two non-simple arithmetic operations.\n\t\t */\n\t\tfrac *= ps->user_tsresol;\n\t\tfrac /= ps->ifaces[interface_id].tsresol;\n\t\tbreak;\n\t}\n#ifdef _WIN32\n\t/*\n\t * tv_sec and tv_used in the Windows struct timeval are both\n\t * longs.\n\t */\n\thdr->ts.tv_sec = (long)sec;\n\thdr->ts.tv_usec = (long)frac;\n#else\n\t/*\n\t * tv_sec in the UN*X struct timeval is a time_t; tv_usec is\n\t * suseconds_t in UN*Xes that work the way the current Single\n\t * UNIX Standard specify - but not all older UN*Xes necessarily\n\t * support that type, so just cast to int.\n\t */\n\thdr->ts.tv_sec = (time_t)sec;\n\thdr->ts.tv_usec = (int)frac;\n#endif\n\n\t/*\n\t * Get a pointer to the packet data.\n\t */\n\t*data = get_from_block_data(&cursor, hdr->caplen, p->errbuf);\n\tif (*data == NULL)\n\t\treturn (-1);\n\n\tif (p->swapped)\n\t\tswap_pseudo_headers(p->linktype, hdr, *data);\n\n\treturn (0);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 1993, 1994, 1995, 1996, 1997\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that: (1) source code distributions\n * retain the above copyright notice and this paragraph in its entirety, (2)\n * distributions including binary code include the above copyright notice and\n * this paragraph in its entirety in the documentation or other materials\n * provided with the distribution, and (3) all advertising materials mentioning\n * features or use of this software display the following acknowledgement:\n * ``This product includes software developed by the University of California,\n * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of\n * the University nor the names of its contributors may be used to endorse\n * or promote products derived from this software without specific prior\n * written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n *\n * sf-pcapng.c - pcapng-file-format-specific code from savefile.c\n */\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include <pcap/pcap-inttypes.h>\n\n#include <errno.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"pcap-int.h\"\n\n#include \"pcap-common.h\"\n\n#ifdef HAVE_OS_PROTO_H\n#include \"os-proto.h\"\n#endif\n\n#include \"sf-pcapng.h\"\n\n/*\n * Block types.\n */\n\n/*\n * Common part at the beginning of all blocks.\n */\nstruct block_header {\n\tbpf_u_int32\tblock_type;\n\tbpf_u_int32\ttotal_length;\n};\n\n/*\n * Common trailer at the end of all blocks.\n */\nstruct block_trailer {\n\tbpf_u_int32\ttotal_length;\n};\n\n/*\n * Common options.\n */\n#define OPT_ENDOFOPT\t0\t/* end of options */\n#define OPT_COMMENT\t1\t/* comment string */\n\n/*\n * Option header.\n */\nstruct option_header {\n\tu_short\t\toption_code;\n\tu_short\t\toption_length;\n};\n\n/*\n * Structures for the part of each block type following the common\n * part.\n */\n\n/*\n * Section Header Block.\n */\n#define BT_SHB\t\t\t0x0A0D0D0A\n#define BT_SHB_INSANE_MAX       1024*1024*1  /* 1MB should be enough */\nstruct section_header_block {\n\tbpf_u_int32\tbyte_order_magic;\n\tu_short\t\tmajor_version;\n\tu_short\t\tminor_version;\n\tuint64_t\tsection_length;\n\t/* followed by options and trailer */\n};\n\n/*\n * Byte-order magic value.\n */\n#define BYTE_ORDER_MAGIC\t0x1A2B3C4D\n\n/*\n * Current version number.  If major_version isn't PCAP_NG_VERSION_MAJOR,\n * that means that this code can't read the file.\n */\n#define PCAP_NG_VERSION_MAJOR\t1\n#define PCAP_NG_VERSION_MINOR\t0\n\n/*\n * Interface Description Block.\n */\n#define BT_IDB\t\t\t0x00000001\n\nstruct interface_description_block {\n\tu_short\t\tlinktype;\n\tu_short\t\treserved;\n\tbpf_u_int32\tsnaplen;\n\t/* followed by options and trailer */\n};\n\n/*\n * Options in the IDB.\n */\n#define IF_NAME\t\t2\t/* interface name string */\n#define IF_DESCRIPTION\t3\t/* interface description string */\n#define IF_IPV4ADDR\t4\t/* interface's IPv4 address and netmask */\n#define IF_IPV6ADDR\t5\t/* interface's IPv6 address and prefix length */\n#define IF_MACADDR\t6\t/* interface's MAC address */\n#define IF_EUIADDR\t7\t/* interface's EUI address */\n#define IF_SPEED\t8\t/* interface's speed, in bits/s */\n#define IF_TSRESOL\t9\t/* interface's time stamp resolution */\n#define IF_TZONE\t10\t/* interface's time zone */\n#define IF_FILTER\t11\t/* filter used when capturing on interface */\n#define IF_OS\t\t12\t/* string OS on which capture on this interface was done */\n#define IF_FCSLEN\t13\t/* FCS length for this interface */\n#define IF_TSOFFSET\t14\t/* time stamp offset for this interface */\n\n/*\n * Enhanced Packet Block.\n */\n#define BT_EPB\t\t\t0x00000006\n\nstruct enhanced_packet_block {\n\tbpf_u_int32\tinterface_id;\n\tbpf_u_int32\ttimestamp_high;\n\tbpf_u_int32\ttimestamp_low;\n\tbpf_u_int32\tcaplen;\n\tbpf_u_int32\tlen;\n\t/* followed by packet data, options, and trailer */\n};\n\n/*\n * Simple Packet Block.\n */\n#define BT_SPB\t\t\t0x00000003\n\nstruct simple_packet_block {\n\tbpf_u_int32\tlen;\n\t/* followed by packet data and trailer */\n};\n\n/*\n * Packet Block.\n */\n#define BT_PB\t\t\t0x00000002\n\nstruct packet_block {\n\tu_short\t\tinterface_id;\n\tu_short\t\tdrops_count;\n\tbpf_u_int32\ttimestamp_high;\n\tbpf_u_int32\ttimestamp_low;\n\tbpf_u_int32\tcaplen;\n\tbpf_u_int32\tlen;\n\t/* followed by packet data, options, and trailer */\n};\n\n/*\n * Block cursor - used when processing the contents of a block.\n * Contains a pointer into the data being processed and a count\n * of bytes remaining in the block.\n */\nstruct block_cursor {\n\tu_char\t\t*data;\n\tsize_t\t\tdata_remaining;\n\tbpf_u_int32\tblock_type;\n};\n\ntypedef enum {\n\tPASS_THROUGH,\n\tSCALE_UP_DEC,\n\tSCALE_DOWN_DEC,\n\tSCALE_UP_BIN,\n\tSCALE_DOWN_BIN\n} tstamp_scale_type_t;\n\n/*\n * Per-interface information.\n */\nstruct pcap_ng_if {\n\tuint64_t tsresol;\t\t/* time stamp resolution */\n\ttstamp_scale_type_t scale_type;\t/* how to scale */\n\tuint64_t scale_factor;\t\t/* time stamp scale factor for power-of-10 tsresol */\n\tuint64_t tsoffset;\t\t/* time stamp offset */\n};\n\n/*\n * Per-pcap_t private data.\n *\n * max_blocksize is the maximum size of a block that we'll accept.  We\n * reject blocks bigger than this, so we don't consume too much memory\n * with a truly huge block.  It can change as we see IDBs with different\n * link-layer header types.  (Currently, we don't support IDBs with\n * different link-layer header types, but we will support it in the\n * future, when we offer file-reading APIs that support it.)\n *\n * XXX - that's an issue on ILP32 platforms, where the maximum block\n * size of 2^31-1 would eat all but one byte of the entire address space.\n * It's less of an issue on ILP64/LLP64 platforms, but the actual size\n * of the address space may be limited by 1) the number of *significant*\n * address bits (currently, x86-64 only supports 48 bits of address), 2)\n * any limitations imposed by the operating system; 3) any limitations\n * imposed by the amount of available backing store for anonymous pages,\n * so we impose a limit regardless of the size of a pointer.\n */\nstruct pcap_ng_sf {\n\tuint64_t user_tsresol;\t\t/* time stamp resolution requested by the user */\n\tu_int max_blocksize;\t\t/* don't grow buffer size past this */\n\tbpf_u_int32 ifcount;\t\t/* number of interfaces seen in this capture */\n\tbpf_u_int32 ifaces_size;\t/* size of array below */\n\tstruct pcap_ng_if *ifaces;\t/* array of interface information */\n};\n\n/*\n * The maximum block size we start with; we use an arbitrary value of\n * 16 MiB.\n */\n#define INITIAL_MAX_BLOCKSIZE\t(16*1024*1024)\n\n/*\n * Maximum block size for a given maximum snapshot length; we define it\n * as the size of an EPB with a max_snaplen-sized packet and 128KB of\n * options.\n */\n#define MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen) \\\n\t(sizeof (struct block_header) + \\\n\t sizeof (struct enhanced_packet_block) + \\\n\t (max_snaplen) + 131072 + \\\n\t sizeof (struct block_trailer))\n\nstatic void pcap_ng_cleanup(pcap_t *p);\nstatic int pcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr,\n    u_char **data);\n\nstatic int\nread_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,\n    char *errbuf)\n{\n\tsize_t amt_read;\n\n\tamt_read = fread(buf, 1, bytes_to_read, fp);\n\tif (amt_read != bytes_to_read) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t} else {\n\t\t\tif (amt_read == 0 && !fail_on_eof)\n\t\t\t\treturn (0);\t/* EOF */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"truncated pcapng dump file; tried to read %\" PRIsize \" bytes, only got %\" PRIsize,\n\t\t\t    bytes_to_read, amt_read);\n\t\t}\n\t\treturn (-1);\n\t}\n\treturn (1);\n}\n\nstatic int\nread_block(FILE *fp, pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_header bhdr;\n\tstruct block_trailer *btrlr;\n\tu_char *bdata;\n\tsize_t data_remaining;\n\n\tps = p->priv;\n\n\tstatus = read_bytes(fp, &bhdr, sizeof(bhdr), 0, errbuf);\n\tif (status <= 0)\n\t\treturn (status);\t/* error or EOF */\n\n\tif (p->swapped) {\n\t\tbhdr.block_type = SWAPLONG(bhdr.block_type);\n\t\tbhdr.total_length = SWAPLONG(bhdr.total_length);\n\t}\n\n\t/*\n\t * Is this block \"too small\" - i.e., is it shorter than a block\n\t * header plus a block trailer?\n\t */\n\tif (bhdr.total_length < sizeof(struct block_header) +\n\t    sizeof(struct block_trailer)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block in pcapng dump file has a length of %u < %\" PRIsize,\n\t\t    bhdr.total_length,\n\t\t    sizeof(struct block_header) + sizeof(struct block_trailer));\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Is the block total length a multiple of 4?\n\t */\n\tif ((bhdr.total_length % 4) != 0) {\n\t\t/*\n\t\t * No.  Report that as an error.\n\t\t */\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block in pcapng dump file has a length of %u that is not a multiple of 4\" PRIsize,\n\t\t    bhdr.total_length);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Is the buffer big enough?\n\t */\n\tif (p->bufsize < bhdr.total_length) {\n\t\t/*\n\t\t * No - make it big enough, unless it's too big, in\n\t\t * which case we fail.\n\t\t */\n\t\tvoid *bigger_buffer;\n\n\t\tif (bhdr.total_length > ps->max_blocksize) {\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"pcapng block size %u > maximum %u\", bhdr.total_length,\n\t\t\t    ps->max_blocksize);\n\t\t\treturn (-1);\n\t\t}\n\t\tbigger_buffer = realloc(p->buffer, bhdr.total_length);\n\t\tif (bigger_buffer == NULL) {\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\t\treturn (-1);\n\t\t}\n\t\tp->buffer = bigger_buffer;\n\t}\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the block.\n\t */\n\tmemcpy(p->buffer, &bhdr, sizeof(bhdr));\n\tbdata = (u_char *)p->buffer + sizeof(bhdr);\n\tdata_remaining = bhdr.total_length - sizeof(bhdr);\n\tif (read_bytes(fp, bdata, data_remaining, 1, errbuf) == -1)\n\t\treturn (-1);\n\n\t/*\n\t * Get the block size from the trailer.\n\t */\n\tbtrlr = (struct block_trailer *)(bdata + data_remaining - sizeof (struct block_trailer));\n\tif (p->swapped)\n\t\tbtrlr->total_length = SWAPLONG(btrlr->total_length);\n\n\t/*\n\t * Is the total length from the trailer the same as the total\n\t * length from the header?\n\t */\n\tif (bhdr.total_length != btrlr->total_length) {\n\t\t/*\n\t\t * No.\n\t\t */\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block total length in header and trailer don't match\");\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Initialize the cursor.\n\t */\n\tcursor->data = bdata;\n\tcursor->data_remaining = data_remaining - sizeof(struct block_trailer);\n\tcursor->block_type = bhdr.block_type;\n\treturn (1);\n}\n\nstatic void *\nget_from_block_data(struct block_cursor *cursor, size_t chunk_size,\n    char *errbuf)\n{\n\tvoid *data;\n\n\t/*\n\t * Make sure we have the specified amount of data remaining in\n\t * the block data.\n\t */\n\tif (cursor->data_remaining < chunk_size) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"block of type %u in pcapng dump file is too short\",\n\t\t    cursor->block_type);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Return the current pointer, and skip past the chunk.\n\t */\n\tdata = cursor->data;\n\tcursor->data += chunk_size;\n\tcursor->data_remaining -= chunk_size;\n\treturn (data);\n}\n\nstatic struct option_header *\nget_opthdr_from_block_data(pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct option_header *opthdr;\n\n\topthdr = get_from_block_data(cursor, sizeof(*opthdr), errbuf);\n\tif (opthdr == NULL) {\n\t\t/*\n\t\t * Option header is cut short.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Byte-swap it if necessary.\n\t */\n\tif (p->swapped) {\n\t\topthdr->option_code = SWAPSHORT(opthdr->option_code);\n\t\topthdr->option_length = SWAPSHORT(opthdr->option_length);\n\t}\n\n\treturn (opthdr);\n}\n\nstatic void *\nget_optvalue_from_block_data(struct block_cursor *cursor,\n    struct option_header *opthdr, char *errbuf)\n{\n\tsize_t padded_option_len;\n\tvoid *optvalue;\n\n\t/* Pad option length to 4-byte boundary */\n\tpadded_option_len = opthdr->option_length;\n\tpadded_option_len = ((padded_option_len + 3)/4)*4;\n\n\toptvalue = get_from_block_data(cursor, padded_option_len, errbuf);\n\tif (optvalue == NULL) {\n\t\t/*\n\t\t * Option value is cut short.\n\t\t */\n\t\treturn (NULL);\n\t}\n\n\treturn (optvalue);\n}\n\nstatic int\nprocess_idb_options(pcap_t *p, struct block_cursor *cursor, uint64_t *tsresol,\n    uint64_t *tsoffset, int *is_binary, char *errbuf)\n{\n\tstruct option_header *opthdr;\n\tvoid *optvalue;\n\tint saw_tsresol, saw_tsoffset;\n\tuint8_t tsresol_opt;\n\tu_int i;\n\n\tsaw_tsresol = 0;\n\tsaw_tsoffset = 0;\n\twhile (cursor->data_remaining != 0) {\n\t\t/*\n\t\t * Get the option header.\n\t\t */\n\t\topthdr = get_opthdr_from_block_data(p, cursor, errbuf);\n\t\tif (opthdr == NULL) {\n\t\t\t/*\n\t\t\t * Option header is cut short.\n\t\t\t */\n\t\t\treturn (-1);\n\t\t}\n\n\t\t/*\n\t\t * Get option value.\n\t\t */\n\t\toptvalue = get_optvalue_from_block_data(cursor, opthdr,\n\t\t    errbuf);\n\t\tif (optvalue == NULL) {\n\t\t\t/*\n\t\t\t * Option value is cut short.\n\t\t\t */\n\t\t\treturn (-1);\n\t\t}\n\n\t\tswitch (opthdr->option_code) {\n\n\t\tcase OPT_ENDOFOPT:\n\t\t\tif (opthdr->option_length != 0) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has opt_endofopt option with length %u != 0\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tgoto done;\n\n\t\tcase IF_TSRESOL:\n\t\t\tif (opthdr->option_length != 1) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has if_tsresol option with length %u != 1\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (saw_tsresol) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has more than one if_tsresol option\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tsaw_tsresol = 1;\n\t\t\tmemcpy(&tsresol_opt, optvalue, sizeof(tsresol_opt));\n\t\t\tif (tsresol_opt & 0x80) {\n\t\t\t\t/*\n\t\t\t\t * Resolution is negative power of 2.\n\t\t\t\t */\n\t\t\t\tuint8_t tsresol_shift = (tsresol_opt & 0x7F);\n\n\t\t\t\tif (tsresol_shift > 63) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Resolution is too high; 2^-{res}\n\t\t\t\t\t * won't fit in a 64-bit value.\n\t\t\t\t\t */\n\t\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Interface Description Block if_tsresol option resolution 2^-%u is too high\",\n\t\t\t\t\t    tsresol_shift);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\t*is_binary = 1;\n\t\t\t\t*tsresol = ((uint64_t)1) << tsresol_shift;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Resolution is negative power of 10.\n\t\t\t\t */\n\t\t\t\tif (tsresol_opt > 19) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Resolution is too high; 2^-{res}\n\t\t\t\t\t * won't fit in a 64-bit value (the\n\t\t\t\t\t * largest power of 10 that fits\n\t\t\t\t\t * in a 64-bit value is 10^19, as\n\t\t\t\t\t * the largest 64-bit unsigned\n\t\t\t\t\t * value is ~1.8*10^19).\n\t\t\t\t\t */\n\t\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t\t    \"Interface Description Block if_tsresol option resolution 10^-%u is too high\",\n\t\t\t\t\t    tsresol_opt);\n\t\t\t\t\treturn (-1);\n\t\t\t\t}\n\t\t\t\t*is_binary = 0;\n\t\t\t\t*tsresol = 1;\n\t\t\t\tfor (i = 0; i < tsresol_opt; i++)\n\t\t\t\t\t*tsresol *= 10;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IF_TSOFFSET:\n\t\t\tif (opthdr->option_length != 8) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has if_tsoffset option with length %u != 8\",\n\t\t\t\t    opthdr->option_length);\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (saw_tsoffset) {\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"Interface Description Block has more than one if_tsoffset option\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tsaw_tsoffset = 1;\n\t\t\tmemcpy(tsoffset, optvalue, sizeof(*tsoffset));\n\t\t\tif (p->swapped)\n\t\t\t\t*tsoffset = SWAPLL(*tsoffset);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\treturn (0);\n}\n\nstatic int\nadd_interface(pcap_t *p, struct block_cursor *cursor, char *errbuf)\n{\n\tstruct pcap_ng_sf *ps;\n\tuint64_t tsresol;\n\tuint64_t tsoffset;\n\tint is_binary;\n\n\tps = p->priv;\n\n\t/*\n\t * Count this interface.\n\t */\n\tps->ifcount++;\n\n\t/*\n\t * Grow the array of per-interface information as necessary.\n\t */\n\tif (ps->ifcount > ps->ifaces_size) {\n\t\t/*\n\t\t * We need to grow the array.\n\t\t */\n\t\tbpf_u_int32 new_ifaces_size;\n\t\tstruct pcap_ng_if *new_ifaces;\n\n\t\tif (ps->ifaces_size == 0) {\n\t\t\t/*\n\t\t\t * It's currently empty.\n\t\t\t *\n\t\t\t * (The Clang static analyzer doesn't do enough,\n\t\t\t * err, umm, dataflow *analysis* to realize that\n\t\t\t * ps->ifaces_size == 0 if ps->ifaces == NULL,\n\t\t\t * and so complains about a possible zero argument\n\t\t\t * to realloc(), so we check for the former\n\t\t\t * condition to shut it up.\n\t\t\t *\n\t\t\t * However, it doesn't complain that one of the\n\t\t\t * multiplications below could overflow, which is\n\t\t\t * a real, albeit extremely unlikely, problem (you'd\n\t\t\t * need a pcapng file with tens of millions of\n\t\t\t * interfaces).)\n\t\t\t */\n\t\t\tnew_ifaces_size = 1;\n\t\t\tnew_ifaces = malloc(sizeof (struct pcap_ng_if));\n\t\t} else {\n\t\t\t/*\n\t\t\t * It's not currently empty; double its size.\n\t\t\t * (Perhaps overkill once we have a lot of interfaces.)\n\t\t\t *\n\t\t\t * Check for overflow if we double it.\n\t\t\t */\n\t\t\tif (ps->ifaces_size * 2 < ps->ifaces_size) {\n\t\t\t\t/*\n\t\t\t\t * The maximum number of interfaces before\n\t\t\t\t * ps->ifaces_size overflows is the largest\n\t\t\t\t * possible 32-bit power of 2, as we do\n\t\t\t\t * size doubling.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"more than %u interfaces in the file\",\n\t\t\t\t    0x80000000U);\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * ps->ifaces_size * 2 doesn't overflow, so it's\n\t\t\t * safe to multiply.\n\t\t\t */\n\t\t\tnew_ifaces_size = ps->ifaces_size * 2;\n\n\t\t\t/*\n\t\t\t * Now make sure that's not so big that it overflows\n\t\t\t * if we multiply by sizeof (struct pcap_ng_if).\n\t\t\t *\n\t\t\t * That can happen on 32-bit platforms, with a 32-bit\n\t\t\t * size_t; it shouldn't happen on 64-bit platforms,\n\t\t\t * with a 64-bit size_t, as new_ifaces_size is\n\t\t\t * 32 bits.\n\t\t\t */\n\t\t\tif (new_ifaces_size * sizeof (struct pcap_ng_if) < new_ifaces_size) {\n\t\t\t\t/*\n\t\t\t\t * As this fails only with 32-bit size_t,\n\t\t\t\t * the multiplication was 32x32->32, and\n\t\t\t\t * the largest 32-bit value that can safely\n\t\t\t\t * be multiplied by sizeof (struct pcap_ng_if)\n\t\t\t\t * without overflow is the largest 32-bit\n\t\t\t\t * (unsigned) value divided by\n\t\t\t\t * sizeof (struct pcap_ng_if).\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"more than %u interfaces in the file\",\n\t\t\t\t    0xFFFFFFFFU / ((u_int)sizeof (struct pcap_ng_if)));\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tnew_ifaces = realloc(ps->ifaces, new_ifaces_size * sizeof (struct pcap_ng_if));\n\t\t}\n\t\tif (new_ifaces == NULL) {\n\t\t\t/*\n\t\t\t * We ran out of memory.\n\t\t\t * Give up.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"out of memory for per-interface information (%u interfaces)\",\n\t\t\t    ps->ifcount);\n\t\t\treturn (0);\n\t\t}\n\t\tps->ifaces_size = new_ifaces_size;\n\t\tps->ifaces = new_ifaces;\n\t}\n\n\t/*\n\t * Set the default time stamp resolution and offset.\n\t */\n\ttsresol = 1000000;\t/* microsecond resolution */\n\tis_binary = 0;\t\t/* which is a power of 10 */\n\ttsoffset = 0;\t\t/* absolute timestamps */\n\n\t/*\n\t * Now look for various time stamp options, so we know\n\t * how to interpret the time stamps for this interface.\n\t */\n\tif (process_idb_options(p, cursor, &tsresol, &tsoffset, &is_binary,\n\t    errbuf) == -1)\n\t\treturn (0);\n\n\tps->ifaces[ps->ifcount - 1].tsresol = tsresol;\n\tps->ifaces[ps->ifcount - 1].tsoffset = tsoffset;\n\n\t/*\n\t * Determine whether we're scaling up or down or not\n\t * at all for this interface.\n\t */\n\tif (tsresol == ps->user_tsresol) {\n\t\t/*\n\t\t * The resolution is the resolution the user wants,\n\t\t * so we don't have to do scaling.\n\t\t */\n\t\tps->ifaces[ps->ifcount - 1].scale_type = PASS_THROUGH;\n\t} else if (tsresol > ps->user_tsresol) {\n\t\t/*\n\t\t * The resolution is greater than what the user wants,\n\t\t * so we have to scale the timestamps down.\n\t\t */\n\t\tif (is_binary)\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_BIN;\n\t\telse {\n\t\t\t/*\n\t\t\t * Calculate the scale factor.\n\t\t\t */\n\t\t\tps->ifaces[ps->ifcount - 1].scale_factor = tsresol/ps->user_tsresol;\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_DOWN_DEC;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * The resolution is less than what the user wants,\n\t\t * so we have to scale the timestamps up.\n\t\t */\n\t\tif (is_binary)\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_BIN;\n\t\telse {\n\t\t\t/*\n\t\t\t * Calculate the scale factor.\n\t\t\t */\n\t\t\tps->ifaces[ps->ifcount - 1].scale_factor = ps->user_tsresol/tsresol;\n\t\t\tps->ifaces[ps->ifcount - 1].scale_type = SCALE_UP_DEC;\n\t\t}\n\t}\n\treturn (1);\n}\n\n/*\n * Check whether this is a pcapng savefile and, if it is, extract the\n * relevant information from the header.\n */\npcap_t *\npcap_ng_check_header(const uint8_t *magic, FILE *fp, u_int precision,\n    char *errbuf, int *err)\n{\n\tbpf_u_int32 magic_int;\n\tsize_t amt_read;\n\tbpf_u_int32 total_length;\n\tbpf_u_int32 byte_order_magic;\n\tstruct block_header *bhdrp;\n\tstruct section_header_block *shbp;\n\tpcap_t *p;\n\tint swapped = 0;\n\tstruct pcap_ng_sf *ps;\n\tint status;\n\tstruct block_cursor cursor;\n\tstruct interface_description_block *idbp;\n\n\t/*\n\t * Assume no read errors.\n\t */\n\t*err = 0;\n\n\t/*\n\t * Check whether the first 4 bytes of the file are the block\n\t * type for a pcapng savefile.\n\t */\n\tmemcpy(&magic_int, magic, sizeof(magic_int));\n\tif (magic_int != BT_SHB) {\n\t\t/*\n\t\t * XXX - check whether this looks like what the block\n\t\t * type would be after being munged by mapping between\n\t\t * UN*X and DOS/Windows text file format and, if it\n\t\t * does, look for the byte-order magic number in\n\t\t * the appropriate place and, if we find it, report\n\t\t * this as possibly being a pcapng file transferred\n\t\t * between UN*X and Windows in text file format?\n\t\t */\n\t\treturn (NULL);\t/* nope */\n\t}\n\n\t/*\n\t * OK, they are.  However, that's just \\n\\r\\r\\n, so it could,\n\t * conceivably, be an ordinary text file.\n\t *\n\t * It could not, however, conceivably be any other type of\n\t * capture file, so we can read the rest of the putative\n\t * Section Header Block; put the block type in the common\n\t * header, read the rest of the common header and the\n\t * fixed-length portion of the SHB, and look for the byte-order\n\t * magic value.\n\t */\n\tamt_read = fread(&total_length, 1, sizeof(total_length), fp);\n\tif (amt_read < sizeof(total_length)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tamt_read = fread(&byte_order_magic, 1, sizeof(byte_order_magic), fp);\n\tif (amt_read < sizeof(byte_order_magic)) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"error reading dump file\");\n\t\t\t*err = 1;\n\t\t\treturn (NULL);\t/* fail */\n\t\t}\n\n\t\t/*\n\t\t * Possibly a weird short text file, so just say\n\t\t * \"not pcapng\".\n\t\t */\n\t\treturn (NULL);\n\t}\n\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\tbyte_order_magic = SWAPLONG(byte_order_magic);\n\t\tif (byte_order_magic != BYTE_ORDER_MAGIC) {\n\t\t\t/*\n\t\t\t * Not a pcapng file.\n\t\t\t */\n\t\t\treturn (NULL);\n\t\t}\n\t\tswapped = 1;\n\t\ttotal_length = SWAPLONG(total_length);\n\t}\n\n\t/*\n\t * Check the sanity of the total length.\n\t */\n\tif (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||\n            (total_length > BT_SHB_INSANE_MAX)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"Section Header Block in pcapng dump file has invalid length %\" PRIsize \" < _%lu_ < %lu (BT_SHB_INSANE_MAX)\",\n                              sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer),\n                              total_length,\n                              BT_SHB_INSANE_MAX);\n\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\n\n\t/*\n\t * OK, this is a good pcapng file.\n\t * Allocate a pcap_t for it.\n\t */\n\tp = pcap_open_offline_common(errbuf, sizeof (struct pcap_ng_sf));\n\tif (p == NULL) {\n\t\t/* Allocation failed. */\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tp->swapped = swapped;\n\tps = p->priv;\n\n\t/*\n\t * What precision does the user want?\n\t */\n\tswitch (precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tps->user_tsresol = 1000000;\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tps->user_tsresol = 1000000000;\n\t\tbreak;\n\n\tdefault:\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unknown time stamp resolution %u\", precision);\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Allocate a buffer into which to read blocks.  We default to\n\t * the maximum of:\n\t *\n\t *\tthe total length of the SHB for which we read the header;\n\t *\n\t *\t2K, which should be more than large enough for an Enhanced\n\t *\tPacket Block containing a full-size Ethernet frame, and\n\t *\tleaving room for some options.\n\t *\n\t * If we find a bigger block, we reallocate the buffer, up to\n\t * the maximum size.  We start out with a maximum size of\n\t * INITIAL_MAX_BLOCKSIZE; if we see any link-layer header types\n\t * with a maximum snapshot that results in a larger maximum\n\t * block length, we boost the maximum.\n\t */\n\tp->bufsize = 2048;\n\tif (p->bufsize < total_length)\n\t\tp->bufsize = total_length;\n\tp->buffer = malloc(p->bufsize);\n\tif (p->buffer == NULL) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"out of memory\");\n\t\tfree(p);\n\t\t*err = 1;\n\t\treturn (NULL);\n\t}\n\tps->max_blocksize = INITIAL_MAX_BLOCKSIZE;\n\n\t/*\n\t * Copy the stuff we've read to the buffer, and read the rest\n\t * of the SHB.\n\t */\n\tbhdrp = (struct block_header *)p->buffer;\n\tshbp = (struct section_header_block *)((u_char *)p->buffer + sizeof(struct block_header));\n\tbhdrp->block_type = magic_int;\n\tbhdrp->total_length = total_length;\n\tshbp->byte_order_magic = byte_order_magic;\n\tif (read_bytes(fp,\n\t    (u_char *)p->buffer + (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    total_length - (sizeof(magic_int) + sizeof(total_length) + sizeof(byte_order_magic)),\n\t    1, errbuf) == -1)\n\t\tgoto fail;\n\n\tif (p->swapped) {\n\t\t/*\n\t\t * Byte-swap the fields we've read.\n\t\t */\n\t\tshbp->major_version = SWAPSHORT(shbp->major_version);\n\t\tshbp->minor_version = SWAPSHORT(shbp->minor_version);\n\n\t\t/*\n\t\t * XXX - we don't care about the section length.\n\t\t */\n\t}\n\t/* currently only SHB version 1.0 is supported */\n\tif (! (shbp->major_version == PCAP_NG_VERSION_MAJOR &&\n\t       shbp->minor_version == PCAP_NG_VERSION_MINOR)) {\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"unsupported pcapng savefile version %u.%u\",\n\t\t    shbp->major_version, shbp->minor_version);\n\t\tgoto fail;\n\t}\n\tp->version_major = shbp->major_version;\n\tp->version_minor = shbp->minor_version;\n\n\t/*\n\t * Save the time stamp resolution the user requested.\n\t */\n\tp->opt.tstamp_precision = precision;\n\n\t/*\n\t * Now start looking for an Interface Description Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the next block.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, errbuf);\n\t\tif (status == 0) {\n\t\t\t/* EOF - no IDB in this file */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has no Interface Description Blocks\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif (status == -1)\n\t\t\tgoto fail;\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * IDB.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\tgoto fail;\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, errbuf))\n\t\t\t\tgoto fail;\n\n\t\t\tgoto done;\n\n\t\tcase BT_EPB:\n\t\tcase BT_SPB:\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Saw a packet before we saw any IDBs.  That's\n\t\t\t * not valid, as we don't know what link-layer\n\t\t\t * encapsulation the packet has.\n\t\t\t */\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"the capture file has a packet block before any Interface Description Blocks\");\n\t\t\tgoto fail;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Just ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tp->tzoff = 0;\t/* XXX - not used in pcap */\n\tp->linktype = linktype_to_dlt(idbp->linktype);\n\tp->snapshot = pcap_adjust_snapshot(p->linktype, idbp->snaplen);\n\tp->linktype_ext = 0;\n\n\t/*\n\t * If the maximum block size for a packet with the maximum\n\t * snapshot length for this DLT_ is bigger than the current\n\t * maximum block size, increase the maximum.\n\t */\n\tif (MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype)) > ps->max_blocksize)\n\t\tps->max_blocksize = MAX_BLOCKSIZE_FOR_SNAPLEN(max_snaplen_for_dlt(p->linktype));\n\n\tp->next_packet_op = pcap_ng_next_packet;\n\tp->cleanup_op = pcap_ng_cleanup;\n\n\treturn (p);\n\nfail:\n\tfree(ps->ifaces);\n\tfree(p->buffer);\n\tfree(p);\n\t*err = 1;\n\treturn (NULL);\n}\n\nstatic void\npcap_ng_cleanup(pcap_t *p)\n{\n\tstruct pcap_ng_sf *ps = p->priv;\n\n\tfree(ps->ifaces);\n\tsf_cleanup(p);\n}\n\n/*\n * Read and return the next packet from the savefile.  Return the header\n * in hdr and a pointer to the contents in data.  Return 0 on success, 1\n * if there were no more packets, and -1 on an error.\n */\nstatic int\npcap_ng_next_packet(pcap_t *p, struct pcap_pkthdr *hdr, u_char **data)\n{\n\tstruct pcap_ng_sf *ps = p->priv;\n\tstruct block_cursor cursor;\n\tint status;\n\tstruct enhanced_packet_block *epbp;\n\tstruct simple_packet_block *spbp;\n\tstruct packet_block *pbp;\n\tbpf_u_int32 interface_id = 0xFFFFFFFF;\n\tstruct interface_description_block *idbp;\n\tstruct section_header_block *shbp;\n\tFILE *fp = p->rfile;\n\tuint64_t t, sec, frac;\n\n\t/*\n\t * Look for an Enhanced Packet Block, a Simple Packet Block,\n\t * or a Packet Block.\n\t */\n\tfor (;;) {\n\t\t/*\n\t\t * Read the block type and length; those are common\n\t\t * to all blocks.\n\t\t */\n\t\tstatus = read_block(fp, p, &cursor, p->errbuf);\n\t\tif (status == 0)\n\t\t\treturn (1);\t/* EOF */\n\t\tif (status == -1)\n\t\t\treturn (-1);\t/* error */\n\t\tswitch (cursor.block_type) {\n\n\t\tcase BT_EPB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * EPB.\n\t\t\t */\n\t\t\tepbp = get_from_block_data(&cursor, sizeof(*epbp),\n\t\t\t    p->errbuf);\n\t\t\tif (epbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\tinterface_id = SWAPLONG(epbp->interface_id);\n\t\t\t\thdr->caplen = SWAPLONG(epbp->caplen);\n\t\t\t\thdr->len = SWAPLONG(epbp->len);\n\t\t\t\tt = ((uint64_t)SWAPLONG(epbp->timestamp_high)) << 32 |\n\t\t\t\t    SWAPLONG(epbp->timestamp_low);\n\t\t\t} else {\n\t\t\t\tinterface_id = epbp->interface_id;\n\t\t\t\thdr->caplen = epbp->caplen;\n\t\t\t\thdr->len = epbp->len;\n\t\t\t\tt = ((uint64_t)epbp->timestamp_high) << 32 |\n\t\t\t\t    epbp->timestamp_low;\n\t\t\t}\n\t\t\tgoto found;\n\n\t\tcase BT_SPB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * SPB.\n\t\t\t */\n\t\t\tspbp = get_from_block_data(&cursor, sizeof(*spbp),\n\t\t\t    p->errbuf);\n\t\t\tif (spbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * SPB packets are assumed to have arrived on\n\t\t\t * the first interface.\n\t\t\t */\n\t\t\tinterface_id = 0;\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\thdr->len = SWAPLONG(spbp->len);\n\t\t\t} else\n\t\t\t\thdr->len = spbp->len;\n\n\t\t\t/*\n\t\t\t * The SPB doesn't give the captured length;\n\t\t\t * it's the minimum of the snapshot length\n\t\t\t * and the packet length.\n\t\t\t */\n\t\t\thdr->caplen = hdr->len;\n\t\t\tif (hdr->caplen > (bpf_u_int32)p->snapshot)\n\t\t\t\thdr->caplen = p->snapshot;\n\t\t\tt = 0;\t/* no time stamps */\n\t\t\tgoto found;\n\n\t\tcase BT_PB:\n\t\t\t/*\n\t\t\t * Get a pointer to the fixed-length portion of the\n\t\t\t * PB.\n\t\t\t */\n\t\t\tpbp = get_from_block_data(&cursor, sizeof(*pbp),\n\t\t\t    p->errbuf);\n\t\t\tif (pbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\t/* these were written in opposite byte order */\n\t\t\t\tinterface_id = SWAPSHORT(pbp->interface_id);\n\t\t\t\thdr->caplen = SWAPLONG(pbp->caplen);\n\t\t\t\thdr->len = SWAPLONG(pbp->len);\n\t\t\t\tt = ((uint64_t)SWAPLONG(pbp->timestamp_high)) << 32 |\n\t\t\t\t    SWAPLONG(pbp->timestamp_low);\n\t\t\t} else {\n\t\t\t\tinterface_id = pbp->interface_id;\n\t\t\t\thdr->caplen = pbp->caplen;\n\t\t\t\thdr->len = pbp->len;\n\t\t\t\tt = ((uint64_t)pbp->timestamp_high) << 32 |\n\t\t\t\t    pbp->timestamp_low;\n\t\t\t}\n\t\t\tgoto found;\n\n\t\tcase BT_IDB:\n\t\t\t/*\n\t\t\t * Interface Description Block.  Get a pointer\n\t\t\t * to its fixed-length portion.\n\t\t\t */\n\t\t\tidbp = get_from_block_data(&cursor, sizeof(*idbp),\n\t\t\t    p->errbuf);\n\t\t\tif (idbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Byte-swap it if necessary.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tidbp->linktype = SWAPSHORT(idbp->linktype);\n\t\t\t\tidbp->snaplen = SWAPLONG(idbp->snaplen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If the link-layer type or snapshot length\n\t\t\t * differ from the ones for the first IDB we\n\t\t\t * saw, quit.\n\t\t\t *\n\t\t\t * XXX - just discard packets from those\n\t\t\t * interfaces?\n\t\t\t */\n\t\t\tif (p->linktype != idbp->linktype) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"an interface has a type %u different from the type of the first interface\",\n\t\t\t\t    idbp->linktype);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check against the *adjusted* value of this IDB's\n\t\t\t * snapshot length.\n\t\t\t */\n\t\t\tif ((bpf_u_int32)p->snapshot !=\n\t\t\t    pcap_adjust_snapshot(p->linktype, idbp->snaplen)) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"an interface has a snapshot length %u different from the type of the first interface\",\n\t\t\t\t    idbp->snaplen);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try to add this interface.\n\t\t\t */\n\t\t\tif (!add_interface(p, &cursor, p->errbuf))\n\t\t\t\treturn (-1);\n\t\t\tbreak;\n\n\t\tcase BT_SHB:\n\t\t\t/*\n\t\t\t * Section Header Block.  Get a pointer\n\t\t\t * to its fixed-length portion.\n\t\t\t */\n\t\t\tshbp = get_from_block_data(&cursor, sizeof(*shbp),\n\t\t\t    p->errbuf);\n\t\t\tif (shbp == NULL)\n\t\t\t\treturn (-1);\t/* error */\n\n\t\t\t/*\n\t\t\t * Assume the byte order of this section is\n\t\t\t * the same as that of the previous section.\n\t\t\t * We'll check for that later.\n\t\t\t */\n\t\t\tif (p->swapped) {\n\t\t\t\tshbp->byte_order_magic =\n\t\t\t\t    SWAPLONG(shbp->byte_order_magic);\n\t\t\t\tshbp->major_version =\n\t\t\t\t    SWAPSHORT(shbp->major_version);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure the byte order doesn't change;\n\t\t\t * pcap_is_swapped() shouldn't change its\n\t\t\t * return value in the middle of reading a capture.\n\t\t\t */\n\t\t\tswitch (shbp->byte_order_magic) {\n\n\t\t\tcase BYTE_ORDER_MAGIC:\n\t\t\t\t/*\n\t\t\t\t * OK.\n\t\t\t\t */\n\t\t\t\tbreak;\n\n\t\t\tcase SWAPLONG(BYTE_ORDER_MAGIC):\n\t\t\t\t/*\n\t\t\t\t * Byte order changes.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"the file has sections with different byte orders\");\n\t\t\t\treturn (-1);\n\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * Not a valid SHB.\n\t\t\t\t */\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"the file has a section with a bad byte order magic field\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Make sure the major version is the version\n\t\t\t * we handle.\n\t\t\t */\n\t\t\tif (shbp->major_version != PCAP_NG_VERSION_MAJOR) {\n\t\t\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t\t    \"unknown pcapng savefile major version number %u\",\n\t\t\t\t    shbp->major_version);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Reset the interface count; this section should\n\t\t\t * have its own set of IDBs.  If any of them\n\t\t\t * don't have the same interface type, snapshot\n\t\t\t * length, or resolution as the first interface\n\t\t\t * we saw, we'll fail.  (And if we don't see\n\t\t\t * any IDBs, we'll fail when we see a packet\n\t\t\t * block.)\n\t\t\t */\n\t\t\tps->ifcount = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*\n\t\t\t * Not a packet block, IDB, or SHB; ignore it.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\nfound:\n\t/*\n\t * Is the interface ID an interface we know?\n\t */\n\tif (interface_id >= ps->ifcount) {\n\t\t/*\n\t\t * Yes.  Fail.\n\t\t */\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"a packet arrived on interface %u, but there's no Interface Description Block for that interface\",\n\t\t    interface_id);\n\t\treturn (-1);\n\t}\n\n\tif (hdr->caplen > (bpf_u_int32)p->snapshot) {\n\t\tpcap_snprintf(p->errbuf, PCAP_ERRBUF_SIZE,\n\t\t    \"invalid packet capture length %u, bigger than \"\n\t\t    \"snaplen of %d\", hdr->caplen, p->snapshot);\n\t\treturn (-1);\n\t}\n\n\t/*\n\t * Convert the time stamp to seconds and fractions of a second,\n\t * with the fractions being in units of the file-supplied resolution.\n\t */\n\tsec = t / ps->ifaces[interface_id].tsresol + ps->ifaces[interface_id].tsoffset;\n\tfrac = t % ps->ifaces[interface_id].tsresol;\n\n\t/*\n\t * Convert the fractions from units of the file-supplied resolution\n\t * to units of the user-requested resolution.\n\t */\n\tswitch (ps->ifaces[interface_id].scale_type) {\n\n\tcase PASS_THROUGH:\n\t\t/*\n\t\t * The interface resolution is what the user wants,\n\t\t * so we're done.\n\t\t */\n\t\tbreak;\n\n\tcase SCALE_UP_DEC:\n\t\t/*\n\t\t * The interface resolution is less than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * Those resolutions are both powers of 10, and the user-\n\t\t * requested resolution is greater than the file-supplied\n\t\t * resolution, so the quotient in question is an integer.\n\t\t * We've calculated that quotient already, so we just\n\t\t * multiply by it.\n\t\t */\n\t\tfrac *= ps->ifaces[interface_id].scale_factor;\n\t\tbreak;\n\n\tcase SCALE_UP_BIN:\n\t\t/*\n\t\t * The interface resolution is less than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * The file-supplied resolution is a power of 2, so the\n\t\t * quotient is not an integer, so, in order to do this\n\t\t * entirely with integer arithmetic, we multiply by the\n\t\t * user-requested resolution and divide by the file-\n\t\t * supplied resolution.\n\t\t *\n\t\t * XXX - Is there something clever we could do here,\n\t\t * given that we know that the file-supplied resolution\n\t\t * is a power of 2?  Doing a multiplication followed by\n\t\t * a division runs the risk of overflowing, and involves\n\t\t * two non-simple arithmetic operations.\n\t\t */\n\t\tfrac *= ps->user_tsresol;\n\t\tfrac /= ps->ifaces[interface_id].tsresol;\n\t\tbreak;\n\n\tcase SCALE_DOWN_DEC:\n\t\t/*\n\t\t * The interface resolution is greater than what the user\n\t\t * wants; scale the fractional part up to the units of\n\t\t * the resolution the user requested by multiplying by\n\t\t * the quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.\n\t\t *\n\t\t * Those resolutions are both powers of 10, and the user-\n\t\t * requested resolution is less than the file-supplied\n\t\t * resolution, so the quotient in question isn't an\n\t\t * integer, but its reciprocal is, and we can just divide\n\t\t * by the reciprocal of the quotient.  We've calculated\n\t\t * the reciprocal of that quotient already, so we must\n\t\t * divide by it.\n\t\t */\n\t\tfrac /= ps->ifaces[interface_id].scale_factor;\n\t\tbreak;\n\n\n\tcase SCALE_DOWN_BIN:\n\t\t/*\n\t\t * The interface resolution is greater than what the user\n\t\t * wants; convert the fractional part to units of the\n\t\t * resolution the user requested by multiplying by the\n\t\t * quotient of the user-requested resolution and the\n\t\t * file-supplied resolution.  We do that by multiplying\n\t\t * by the user-requested resolution and dividing by the\n\t\t * file-supplied resolution, as the quotient might not\n\t\t * fit in an integer.\n\t\t *\n\t\t * The file-supplied resolution is a power of 2, so the\n\t\t * quotient is not an integer, and neither is its\n\t\t * reciprocal, so, in order to do this entirely with\n\t\t * integer arithmetic, we multiply by the user-requested\n\t\t * resolution and divide by the file-supplied resolution.\n\t\t *\n\t\t * XXX - Is there something clever we could do here,\n\t\t * given that we know that the file-supplied resolution\n\t\t * is a power of 2?  Doing a multiplication followed by\n\t\t * a division runs the risk of overflowing, and involves\n\t\t * two non-simple arithmetic operations.\n\t\t */\n\t\tfrac *= ps->user_tsresol;\n\t\tfrac /= ps->ifaces[interface_id].tsresol;\n\t\tbreak;\n\t}\n#ifdef _WIN32\n\t/*\n\t * tv_sec and tv_used in the Windows struct timeval are both\n\t * longs.\n\t */\n\thdr->ts.tv_sec = (long)sec;\n\thdr->ts.tv_usec = (long)frac;\n#else\n\t/*\n\t * tv_sec in the UN*X struct timeval is a time_t; tv_usec is\n\t * suseconds_t in UN*Xes that work the way the current Single\n\t * UNIX Standard specify - but not all older UN*Xes necessarily\n\t * support that type, so just cast to int.\n\t */\n\thdr->ts.tv_sec = (time_t)sec;\n\thdr->ts.tv_usec = (int)frac;\n#endif\n\n\t/*\n\t * Get a pointer to the packet data.\n\t */\n\t*data = get_from_block_data(&cursor, hdr->caplen, p->errbuf);\n\tif (*data == NULL)\n\t\treturn (-1);\n\n\tif (p->swapped)\n\t\tswap_pseudo_headers(p->linktype, hdr, *data);\n\n\treturn (0);\n}\n"], "filenames": ["sf-pcapng.c"], "buggy_code_start_loc": [88], "buggy_code_end_loc": [878], "fixing_code_start_loc": [88], "fixing_code_end_loc": [872], "type": "CWE-770", "message": "sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory.", "other": {"cve": {"id": "CVE-2019-15165", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-03T19:15:09.473", "lastModified": "2022-04-08T13:27:03.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory."}, {"lang": "es", "value": "En el archivo sf-pcapng.c en libpcap versiones anteriores a 1.9.1, no comprueba apropiadamente la longitud del encabezado PHB antes de asignar la memoria."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tcpdump:libpcap:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.9.1", "matchCriteriaId": "11619557-69F9-455F-ADAA-86AC753BBC9C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "D52F557F-D0A0-43D3-85F1-F10B6EBFAEDF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "E3517A27-E6EE-497C-9996-F78171BBE90F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.1:*:*:*:*:*:*:*", "matchCriteriaId": "EF30C76E-7E58-4D76-89A8-53405685DA86"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.2:*:*:*:*:*:*:*", "matchCriteriaId": "F545DFC9-F331-4E1D-BACB-3D26873E5858"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_operations_monitor:4.3:*:*:*:*:*:*:*", "matchCriteriaId": "CBE1A019-7BB6-4226-8AC4-9D6927ADAEFA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:ipados:13.3:*:*:*:*:*:*:*", "matchCriteriaId": "C9B516A2-A1B4-404E-BAA9-5A128FEE9B1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:iphone_os:13.3:*:*:*:*:*:*:*", "matchCriteriaId": "2C7731F2-3CF7-4952-AFD0-4B4E51B6B11B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.13", "versionEndExcluding": "10.13.6", "matchCriteriaId": "760AE295-2E39-4DA3-A384-01A5D4A131AD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.13.6:security_update_2019-007:*:*:*:*:*:*", "matchCriteriaId": "8EA63C1C-1EEC-4961-A7B7-439D21293B99"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.14.6:security_update_2019-002:*:*:*:*:*:*", "matchCriteriaId": "26108BEF-0847-4AB0-BD98-35344DFA7835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:mac_os_x:10.15.2:*:*:*:*:*:*:*", "matchCriteriaId": "776702C3-EE91-4582-8AC5-1C38F06841DE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:tvos:13.3:*:*:*:*:*:*:*", "matchCriteriaId": "5057ABBD-5311-4148-8AC4-ADA66E29163C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:watchos:6.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "2DD615D7-FC0D-4C78-A96D-DA3026ED8CAE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-10/msg00051.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-10/msg00052.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2019/Dec/26", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/libpcap/blob/libpcap-1.9/CHANGES", "source": "cve@mitre.org", "tags": ["Product", "Release Notes"]}, {"url": "https://github.com/the-tcpdump-group/libpcap/commit/87d6bef033062f969e70fa40c43dfd945d5a20ab", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/libpcap/commit/a5a36d9e82dde7265e38fe1f87b7f11c461c29f6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00031.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/12/msg00014.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5P5K3DQ4TFSZBDB3XN4CZNJNQ3UIF3D3/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GBIEKWLNIR62KZ5GA7EDXZS52HU6OE5F/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UZTIPUWABYUE5KQOLCKAW65AUUSB7QO6/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Dec/23", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT210785", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT210788", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT210789", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT210790", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4221-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4221-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2020.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.tcpdump.org/public-cve-list.txt", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/the-tcpdump-group/libpcap/commit/87d6bef033062f969e70fa40c43dfd945d5a20ab"}}