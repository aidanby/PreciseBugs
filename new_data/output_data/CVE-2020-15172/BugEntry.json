{"buggy_code": ["import itertools\r\nimport random\r\nfrom typing import Union\r\n\r\nimport aiohttp\r\nimport discord\r\nimport inflection\r\nfrom redbot.core import Config, checks, commands\r\nfrom redbot.core.i18n import get_locale\r\nfrom redbot.core.utils.chat_formatting import italics\r\n\r\nfrom .helpers import *\r\n\r\n\r\nclass Act(commands.Cog):\r\n    \"\"\"\r\n    This cog makes all commands, e.g. [p]fluff, into valid commands if\r\n    you command the bot to act on a user, e.g. [p]fluff [botname].\r\n    \"\"\"\r\n\r\n    __author__ = \"Zephyrkul\"\r\n\r\n    async def red_get_data_for_user(self, *, user_id):\r\n        return {}  # No data to get\r\n\r\n    async def red_delete_data_for_user(self, *, requester, user_id):\r\n        pass  # No data to delete\r\n\r\n    def __init__(self, bot):\r\n        super().__init__()\r\n        self.bot = bot\r\n        self.config = Config.get_conf(self, identifier=2_113_674_295, force_registration=True)\r\n        self.config.register_global(custom={}, tenorkey=None)\r\n        self.config.register_guild(custom={})\r\n        self.try_after = None\r\n\r\n    async def initialize(self, bot):\r\n        # temporary backwards compatibility\r\n        key = await self.config.tenorkey()\r\n        if not key:\r\n            return\r\n        await bot.set_shared_api_tokens(\"tenor\", api_key=key)\r\n        await self.config.tenorkey.clear()\r\n\r\n    @commands.command(hidden=True)\r\n    async def act(self, ctx, *, target: Union[discord.Member, str] = None):\r\n        \"\"\"\r\n        Acts on the specified user.\r\n        \"\"\"\r\n        if not target or isinstance(target, str):\r\n            return  # no help text\r\n\r\n        try:\r\n            if not ctx.guild:\r\n                raise KeyError()\r\n            message = await self.config.guild(ctx.guild).get_raw(\"custom\", ctx.invoked_with)\r\n        except KeyError:\r\n            try:\r\n                message = await self.config.get_raw(\"custom\", ctx.invoked_with)\r\n            except KeyError:\r\n                message = NotImplemented\r\n\r\n        if message is None:  # ignored command\r\n            return\r\n        elif message is NotImplemented:  # default\r\n            # humanize action text\r\n            action = inflection.humanize(ctx.invoked_with).split()\r\n            iverb = -1\r\n\r\n            for cycle in range(2):\r\n                if iverb > -1:\r\n                    break\r\n                for i, act in enumerate(action):\r\n                    act = act.lower()\r\n                    if (\r\n                        act in NOLY_ADV\r\n                        or act in CONJ\r\n                        or (act.endswith(\"ly\") and act not in LY_VERBS)\r\n                        or (not cycle and act in SOFT_VERBS)\r\n                    ):\r\n                        continue\r\n                    action[i] = inflection.pluralize(action[i])\r\n                    iverb = max(iverb, i)\r\n\r\n            if iverb < 0:\r\n                return\r\n            action.insert(iverb + 1, target.mention)\r\n            message = italics(\" \".join(action))\r\n        else:\r\n            message = message.format(target, user=target)\r\n\r\n        # add reaction gif\r\n        if self.try_after and ctx.message.created_at < self.try_after:\r\n            return await ctx.send(message)\r\n        if not await ctx.embed_requested():\r\n            return await ctx.send(message)\r\n        key = (await ctx.bot.get_shared_api_tokens(\"tenor\")).get(\"api_key\")\r\n        if not key:\r\n            return await ctx.send(message)\r\n        async with aiohttp.request(\r\n            \"GET\",\r\n            \"https://api.tenor.com/v1/search\",\r\n            params={\r\n                \"q\": ctx.invoked_with,\r\n                \"key\": key,\r\n                \"anon_id\": str(ctx.author.id ^ ctx.me.id),\r\n                \"media_filter\": \"minimal\",\r\n                \"contentfilter\": \"off\" if getattr(ctx.channel, \"nsfw\", False) else \"low\",\r\n                \"ar_range\": \"wide\",\r\n                \"limit\": \"8\",\r\n                \"locale\": get_locale(),\r\n            },\r\n        ) as response:\r\n            json: dict\r\n            if response.status == 429:\r\n                self.try_after = ctx.message.created_at + 30\r\n                json = {}\r\n            elif response.status >= 400:\r\n                json = {}\r\n            else:\r\n                json = await response.json()\r\n        if not json.get(\"results\"):\r\n            return await ctx.send(message)\r\n        message = f\"{message}\\n\\n{random.choice(json['results'])['itemurl']}\"\r\n        await ctx.send(\r\n            message,\r\n            allowed_mentions=discord.AllowedMentions(\r\n                users=False if target in ctx.message.mentions else [target]\r\n            ),\r\n        )\r\n\r\n    @commands.group()\r\n    @checks.is_owner()\r\n    async def actset(self, ctx):\r\n        \"\"\"\r\n        Configure various settings for the act cog.\r\n        \"\"\"\r\n\r\n    @actset.group(aliases=[\"custom\"], invoke_without_command=True)\r\n    @checks.admin_or_permissions(manage_guild=True)\r\n    @commands.guild_only()\r\n    async def customize(self, ctx, command: str.lower, *, response: str = None):\r\n        \"\"\"\r\n        Customize the response to an action.\r\n\r\n        You can use {0} or {user} to dynamically replace with the specified target of the action.\r\n        Formats like {0.name} or {0.mention} can also be used.\r\n        \"\"\"\r\n        if not response:\r\n            await self.config.guild(ctx.guild).clear_raw(\"custom\", command)\r\n        else:\r\n            await self.config.guild(ctx.guild).set_raw(\"custom\", command, value=response)\r\n        await ctx.tick()\r\n\r\n    @customize.command(name=\"global\")\r\n    @checks.is_owner()\r\n    async def customize_global(self, ctx, command: str.lower, *, response: str = None):\r\n        \"\"\"\r\n        Globally customize the response to an action.\r\n\r\n        You can use {0} or {user} to dynamically replace with the specified target of the action.\r\n        Formats like {0.name} or {0.mention} can also be used.\r\n        \"\"\"\r\n        if not response:\r\n            await self.config.clear_raw(\"custom\", command)\r\n        else:\r\n            await self.config.set_raw(\"custom\", command, value=response)\r\n        await ctx.tick()\r\n\r\n    @actset.group(invoke_without_command=True)\r\n    @checks.admin_or_permissions(manage_guild=True)\r\n    @commands.guild_only()\r\n    async def ignore(self, ctx, command: str.lower):\r\n        \"\"\"\r\n        Ignore or unignore the specified action.\r\n\r\n        The bot will no longer respond to these actions.\r\n        \"\"\"\r\n        try:\r\n            custom = await self.config.guild(ctx.guild).get_raw(\"custom\", command)\r\n        except KeyError:\r\n            custom = NotImplemented\r\n        if custom is None:\r\n            await self.config.guild(ctx.guild).clear_raw(\"custom\", command)\r\n            await ctx.send(\"I will no longer ignore the {command} action\".format(command=command))\r\n        else:\r\n            await self.config.guild(ctx.guild).set_raw(\"custom\", command, value=None)\r\n            await ctx.send(\"I will now ignore the {command} action\".format(command=command))\r\n\r\n    @ignore.command(name=\"global\")\r\n    @checks.is_owner()\r\n    async def ignore_global(self, ctx, command: str.lower):\r\n        \"\"\"\r\n        Globally ignore or unignore the specified action.\r\n\r\n        The bot will no longer respond to these actions.\r\n        \"\"\"\r\n        try:\r\n            await self.config.get_raw(\"custom\", command)\r\n        except KeyError:\r\n            await self.config.set_raw(\"custom\", command, value=None)\r\n        else:\r\n            await self.config.clear_raw(\"custom\", command)\r\n        await ctx.tick()\r\n\r\n    @actset.command()\r\n    @checks.is_owner()\r\n    async def tenorkey(self, ctx):\r\n        \"\"\"\r\n        Sets a Tenor GIF API key to enable reaction gifs with act commands.\r\n\r\n        You can obtain a key from here: https://tenor.com/developer/dashboard\r\n        \"\"\"\r\n        instructions = [\r\n            \"Go to the Tenor developer dashboard: https://tenor.com/developer/dashboard\",\r\n            \"Log in or sign up if you haven't already.\",\r\n            \"Click `+ Create new app` and fill out the form.\",\r\n            \"Copy the key from the app you just created.\",\r\n            \"Give the key to Red with this command:\\n\"\r\n            f\"`{ctx.prefix}set api tenor api_key your_api_key`\\n\"\r\n            \"Replace `your_api_key` with the key you just got.\\n\"\r\n            \"Everything else should be the same.\",\r\n        ]\r\n        instructions = [f\"**{i}.** {v}\" for i, v in enumerate(instructions, 1)]\r\n        await ctx.maybe_send_embed(\"\\n\".join(instructions))\r\n\r\n    @commands.Cog.listener()\r\n    async def on_message(self, message):\r\n        if message.author.bot:\r\n            return\r\n\r\n        ctx = await self.bot.get_context(message)\r\n        if ctx.prefix is None or not ctx.invoked_with.replace(\"_\", \"\").isalpha():\r\n            return\r\n\r\n        if ctx.valid and ctx.command.enabled:\r\n            try:\r\n                if await ctx.command.can_run(ctx):\r\n                    return\r\n            except commands.errors.CheckFailure:\r\n                return\r\n\r\n        ctx.command = self.act\r\n        await self.bot.invoke(ctx)\r\n"], "fixing_code": ["import functools\r\nimport random\r\nimport re\r\nfrom typing import Union\r\n\r\nimport aiohttp\r\nimport discord\r\nimport inflection\r\nfrom redbot.core import bot, Config, checks, commands\r\nfrom redbot.core.i18n import get_locale\r\nfrom redbot.core.utils.chat_formatting import italics\r\n\r\nfrom .helpers import *\r\n\r\nfmt_re = re.compile(r\"{(?:0|user)(?:\\.([^\\{]+))?}\")\r\n\r\n\r\nclass Act(commands.Cog):\r\n    \"\"\"\r\n    This cog makes all commands, e.g. [p]fluff, into valid commands if\r\n    you command the bot to act on a user, e.g. [p]fluff [botname].\r\n    \"\"\"\r\n\r\n    __author__ = \"Zephyrkul\"\r\n\r\n    async def red_get_data_for_user(self, *, user_id):\r\n        return {}  # No data to get\r\n\r\n    async def red_delete_data_for_user(self, *, requester, user_id):\r\n        pass  # No data to delete\r\n\r\n    def __init__(self, bot: bot.Red):\r\n        super().__init__()\r\n        self.bot = bot\r\n        self.config = Config.get_conf(self, identifier=2_113_674_295, force_registration=True)\r\n        self.config.register_global(custom={}, tenorkey=None)\r\n        self.config.register_guild(custom={})\r\n        self.try_after = None\r\n\r\n    async def initialize(self, bot: bot.Red):\r\n        # temporary backwards compatibility\r\n        key = await self.config.tenorkey()\r\n        if not key:\r\n            return\r\n        await bot.set_shared_api_tokens(\"tenor\", api_key=key)\r\n        await self.config.tenorkey.clear()\r\n\r\n    @staticmethod\r\n    def repl(target: discord.Member, match: re.Match):\r\n        if attr := match.group(1):\r\n            print(attr)\r\n            if attr.startswith(\"_\") or \".\" in attr:\r\n                return str(target)\r\n            try:\r\n                return str(getattr(target, attr))\r\n            except AttributeError:\r\n                return str(target)\r\n        return str(target)\r\n\r\n    @commands.command(hidden=True)\r\n    async def act(self, ctx: commands.Context, *, target: Union[discord.Member, str] = None):\r\n        \"\"\"\r\n        Acts on the specified user.\r\n        \"\"\"\r\n        if not target or isinstance(target, str):\r\n            return  # no help text\r\n\r\n        try:\r\n            if not ctx.guild:\r\n                raise KeyError()\r\n            message = await self.config.guild(ctx.guild).get_raw(\"custom\", ctx.invoked_with)\r\n        except KeyError:\r\n            try:\r\n                message = await self.config.get_raw(\"custom\", ctx.invoked_with)\r\n            except KeyError:\r\n                message = NotImplemented\r\n\r\n        if message is None:  # ignored command\r\n            return\r\n        elif message is NotImplemented:  # default\r\n            # humanize action text\r\n            action = inflection.humanize(ctx.invoked_with).split()\r\n            iverb = -1\r\n\r\n            for cycle in range(2):\r\n                if iverb > -1:\r\n                    break\r\n                for i, act in enumerate(action):\r\n                    act = act.lower()\r\n                    if (\r\n                        act in NOLY_ADV\r\n                        or act in CONJ\r\n                        or (act.endswith(\"ly\") and act not in LY_VERBS)\r\n                        or (not cycle and act in SOFT_VERBS)\r\n                    ):\r\n                        continue\r\n                    action[i] = inflection.pluralize(action[i])\r\n                    iverb = max(iverb, i)\r\n\r\n            if iverb < 0:\r\n                return\r\n            action.insert(iverb + 1, target.mention)\r\n            message = italics(\" \".join(action))\r\n        else:\r\n            assert isinstance(message, str)\r\n            message = fmt_re.sub(functools.partial(self.repl, target), message)\r\n\r\n        # add reaction gif\r\n        if self.try_after and ctx.message.created_at < self.try_after:\r\n            return await ctx.send(message)\r\n        if not await ctx.embed_requested():\r\n            return await ctx.send(message)\r\n        key = (await ctx.bot.get_shared_api_tokens(\"tenor\")).get(\"api_key\")\r\n        if not key:\r\n            return await ctx.send(message)\r\n        async with aiohttp.request(\r\n            \"GET\",\r\n            \"https://api.tenor.com/v1/search\",\r\n            params={\r\n                \"q\": ctx.invoked_with,\r\n                \"key\": key,\r\n                \"anon_id\": str(ctx.author.id ^ ctx.me.id),\r\n                \"media_filter\": \"minimal\",\r\n                \"contentfilter\": \"off\" if getattr(ctx.channel, \"nsfw\", False) else \"low\",\r\n                \"ar_range\": \"wide\",\r\n                \"limit\": \"8\",\r\n                \"locale\": get_locale(),\r\n            },\r\n        ) as response:\r\n            json: dict\r\n            if response.status == 429:\r\n                self.try_after = ctx.message.created_at + 30\r\n                json = {}\r\n            elif response.status >= 400:\r\n                json = {}\r\n            else:\r\n                json = await response.json()\r\n        if not json.get(\"results\"):\r\n            return await ctx.send(message)\r\n        message = f\"{message}\\n\\n{random.choice(json['results'])['itemurl']}\"\r\n        await ctx.send(\r\n            message,\r\n            allowed_mentions=discord.AllowedMentions(\r\n                users=False if target in ctx.message.mentions else [target]\r\n            ),\r\n        )\r\n\r\n    @commands.group()\r\n    @checks.is_owner()\r\n    async def actset(self, ctx: commands.Context):\r\n        \"\"\"\r\n        Configure various settings for the act cog.\r\n        \"\"\"\r\n\r\n    @actset.group(aliases=[\"custom\"], invoke_without_command=True)\r\n    @checks.admin_or_permissions(manage_guild=True)\r\n    @commands.guild_only()\r\n    async def customize(self, ctx: commands.Context, command: str.lower, *, response: str = None):\r\n        \"\"\"\r\n        Customize the response to an action.\r\n\r\n        You can use {0} or {user} to dynamically replace with the specified target of the action.\r\n        Formats like {0.name} or {0.mention} can also be used.\r\n        \"\"\"\r\n        if not response:\r\n            await self.config.guild(ctx.guild).clear_raw(\"custom\", command)\r\n            await ctx.tick()\r\n        else:\r\n            await self.config.guild(ctx.guild).set_raw(\"custom\", command, value=response)\r\n            await ctx.send(\r\n                fmt_re.sub(functools.partial(self.repl, ctx.author), response),\r\n                allowed_mentions=discord.AllowedMentions(users=False),\r\n            )\r\n\r\n    @customize.command(name=\"global\")\r\n    @checks.is_owner()\r\n    async def customize_global(\r\n        self, ctx: commands.Context, command: str.lower, *, response: str = None\r\n    ):\r\n        \"\"\"\r\n        Globally customize the response to an action.\r\n\r\n        You can use {0} or {user} to dynamically replace with the specified target of the action.\r\n        Formats like {0.name} or {0.mention} can also be used.\r\n        \"\"\"\r\n        if not response:\r\n            await self.config.clear_raw(\"custom\", command)\r\n        else:\r\n            await self.config.set_raw(\"custom\", command, value=response)\r\n        await ctx.tick()\r\n\r\n    @actset.group(invoke_without_command=True)\r\n    @checks.admin_or_permissions(manage_guild=True)\r\n    @commands.guild_only()\r\n    async def ignore(self, ctx: commands.Context, command: str.lower):\r\n        \"\"\"\r\n        Ignore or unignore the specified action.\r\n\r\n        The bot will no longer respond to these actions.\r\n        \"\"\"\r\n        try:\r\n            custom = await self.config.guild(ctx.guild).get_raw(\"custom\", command)\r\n        except KeyError:\r\n            custom = NotImplemented\r\n        if custom is None:\r\n            await self.config.guild(ctx.guild).clear_raw(\"custom\", command)\r\n            await ctx.send(\"I will no longer ignore the {command} action\".format(command=command))\r\n        else:\r\n            await self.config.guild(ctx.guild).set_raw(\"custom\", command, value=None)\r\n            await ctx.send(\"I will now ignore the {command} action\".format(command=command))\r\n\r\n    @ignore.command(name=\"global\")\r\n    @checks.is_owner()\r\n    async def ignore_global(self, ctx: commands.Context, command: str.lower):\r\n        \"\"\"\r\n        Globally ignore or unignore the specified action.\r\n\r\n        The bot will no longer respond to these actions.\r\n        \"\"\"\r\n        try:\r\n            await self.config.get_raw(\"custom\", command)\r\n        except KeyError:\r\n            await self.config.set_raw(\"custom\", command, value=None)\r\n        else:\r\n            await self.config.clear_raw(\"custom\", command)\r\n        await ctx.tick()\r\n\r\n    @actset.command()\r\n    @checks.is_owner()\r\n    async def tenorkey(self, ctx: commands.Context):\r\n        \"\"\"\r\n        Sets a Tenor GIF API key to enable reaction gifs with act commands.\r\n\r\n        You can obtain a key from here: https://tenor.com/developer/dashboard\r\n        \"\"\"\r\n        instructions = [\r\n            \"Go to the Tenor developer dashboard: https://tenor.com/developer/dashboard\",\r\n            \"Log in or sign up if you haven't already.\",\r\n            \"Click `+ Create new app` and fill out the form.\",\r\n            \"Copy the key from the app you just created.\",\r\n            \"Give the key to Red with this command:\\n\"\r\n            f\"`{ctx.prefix}set api tenor api_key your_api_key`\\n\"\r\n            \"Replace `your_api_key` with the key you just got.\\n\"\r\n            \"Everything else should be the same.\",\r\n        ]\r\n        instructions = [f\"**{i}.** {v}\" for i, v in enumerate(instructions, 1)]\r\n        await ctx.maybe_send_embed(\"\\n\".join(instructions))\r\n\r\n    @commands.Cog.listener()\r\n    async def on_command_error(\r\n        self, ctx: commands.Context, error: commands.CommandError, unhandled_by_cog: bool = False\r\n    ):\r\n        if ctx.command == self.act:\r\n            return\r\n        if isinstance(error, commands.UserFeedbackCheckFailure):\r\n            # UserFeedbackCheckFailure inherits from CheckFailure\r\n            return\r\n        elif isinstance(error, (commands.CheckFailure, commands.CommandNotFound)):\r\n            ctx.command = self.act\r\n            await ctx.bot.invoke(ctx)\r\n"], "filenames": ["act/act.py"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [245], "fixing_code_start_loc": [1], "fixing_code_end_loc": [261], "type": "CWE-502", "message": "The Act module for Red Discord Bot before commit 6b9f3b86 is vulnerable to Remote Code Execution. With this exploit, Discord users can use specially crafted messages to perform destructive actions and/or access sensitive information. Unloading the Act module with `unload act` can render this exploit inaccessible.", "other": {"cve": {"id": "CVE-2020-15172", "sourceIdentifier": "security-advisories@github.com", "published": "2020-09-15T19:15:13.057", "lastModified": "2020-10-08T16:20:58.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Act module for Red Discord Bot before commit 6b9f3b86 is vulnerable to Remote Code Execution. With this exploit, Discord users can use specially crafted messages to perform destructive actions and/or access sensitive information. Unloading the Act module with `unload act` can render this exploit inaccessible."}, {"lang": "es", "value": "El m\u00f3dulo Act para Red Discord Bot antes del commit 6b9f3b86, es vulnerable a una Ejecuci\u00f3n de C\u00f3digo Remota.&#xa0;Con esta explotaci\u00f3n, los usuarios de Discord pueden utilizar mensajes especialmente dise\u00f1ados para llevar a cabo acciones destructivas y/o acceder a informaci\u00f3n confidencial.&#xa0;La descarga del m\u00f3dulo Act con \"unload act\" puede hacer que esta explotaci\u00f3n sea inaccesible"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.3, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fluffycogs_project:fluffycogs:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.38", "matchCriteriaId": "6CF14880-B43C-4314-BB06-C047E0831DE1"}]}]}], "references": [{"url": "https://github.com/zephyrkul/FluffyCogs/commit/6b9f3b862e1f0a5429c62f3090f814e53a242347", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/zephyrkul/FluffyCogs/security/advisories/GHSA-rm7m-j4xp-rv2p", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zephyrkul/FluffyCogs/commit/6b9f3b862e1f0a5429c62f3090f814e53a242347"}}