{"buggy_code": ["/*\n * OSQ audio decoder\n * Copyright (c) 2023 Paul B Mahol\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/internal.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"avcodec.h\"\n#include \"codec_internal.h\"\n#include \"decode.h\"\n#include \"internal.h\"\n#define BITSTREAM_READER_LE\n#include \"get_bits.h\"\n#include \"unary.h\"\n\n#define OFFSET 5\n\ntypedef struct OSQChannel {\n    unsigned prediction;\n    unsigned coding_mode;\n    unsigned residue_parameter;\n    unsigned residue_bits;\n    unsigned history[3];\n    unsigned pos, count;\n    double sum;\n    int32_t prev;\n} OSQChannel;\n\ntypedef struct OSQContext {\n    GetBitContext gb;\n    OSQChannel ch[2];\n\n    uint8_t *bitstream;\n    size_t max_framesize;\n    size_t bitstream_size;\n\n    int decorrelate;\n    int frame_samples;\n    int64_t nb_samples;\n\n    int32_t *decode_buffer[2];\n\n    AVPacket *pkt;\n    int pkt_offset;\n} OSQContext;\n\nstatic av_cold int osq_close(AVCodecContext *avctx)\n{\n    OSQContext *s = avctx->priv_data;\n\n    av_freep(&s->bitstream);\n    s->bitstream_size = 0;\n\n    for (int ch = 0; ch < FF_ARRAY_ELEMS(s->decode_buffer); ch++)\n        av_freep(&s->decode_buffer[ch]);\n\n    return 0;\n}\n\nstatic av_cold int osq_init(AVCodecContext *avctx)\n{\n    OSQContext *s = avctx->priv_data;\n\n    if (avctx->extradata_size < 48)\n        return AVERROR(EINVAL);\n\n    if (avctx->extradata[0] != 1) {\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported version.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avctx->sample_rate = AV_RL32(avctx->extradata + 4);\n    if (avctx->sample_rate < 1)\n        return AVERROR_INVALIDDATA;\n\n    av_channel_layout_uninit(&avctx->ch_layout);\n    avctx->ch_layout.order = AV_CHANNEL_ORDER_UNSPEC;\n    avctx->ch_layout.nb_channels = avctx->extradata[3];\n    if (avctx->ch_layout.nb_channels < 1)\n        return AVERROR_INVALIDDATA;\n    if (avctx->ch_layout.nb_channels > FF_ARRAY_ELEMS(s->decode_buffer))\n        return AVERROR_INVALIDDATA;\n\n    switch (avctx->extradata[2]) {\n    case  8: avctx->sample_fmt = AV_SAMPLE_FMT_U8P; break;\n    case 16: avctx->sample_fmt = AV_SAMPLE_FMT_S16P; break;\n    case 20:\n    case 24:\n    case 28:\n    case 32: avctx->sample_fmt = AV_SAMPLE_FMT_S32P; break;\n    default: return AVERROR_INVALIDDATA;\n    }\n\n    s->nb_samples = AV_RL64(avctx->extradata + 16);\n    s->frame_samples = AV_RL16(avctx->extradata + 8);\n    s->max_framesize = (s->frame_samples * 16 + 1024) * avctx->ch_layout.nb_channels;\n\n    s->bitstream = av_calloc(s->max_framesize + AV_INPUT_BUFFER_PADDING_SIZE, sizeof(*s->bitstream));\n    if (!s->bitstream)\n        return AVERROR(ENOMEM);\n\n    for (int ch = 0; ch < avctx->ch_layout.nb_channels; ch++) {\n        s->decode_buffer[ch] = av_calloc(s->frame_samples + OFFSET,\n                                         sizeof(*s->decode_buffer[ch]));\n        if (!s->decode_buffer[ch])\n            return AVERROR(ENOMEM);\n    }\n\n    s->pkt = avctx->internal->in_pkt;\n\n    return 0;\n}\n\nstatic void reset_stats(OSQChannel *cb)\n{\n    memset(cb->history, 0, sizeof(cb->history));\n    cb->pos = cb->count = cb->sum = 0;\n}\n\nstatic void update_stats(OSQChannel *cb, int val)\n{\n    cb->sum += FFABS(val) - cb->history[cb->pos];\n    cb->history[cb->pos] = FFABS(val);\n    cb->pos++;\n    cb->count++;\n    if (cb->pos >= FF_ARRAY_ELEMS(cb->history))\n        cb->pos = 0;\n}\n\nstatic int update_residue_parameter(OSQChannel *cb)\n{\n    double sum, x;\n    int rice_k;\n\n    sum = cb->sum;\n    x = sum / cb->count;\n    rice_k = av_ceil_log2(x);\n    if (rice_k >= 30) {\n        rice_k = floor(sum / 1.4426952 + 0.5);\n        if (rice_k < 1)\n            rice_k = 1;\n    }\n\n    return rice_k;\n}\n\nstatic uint32_t get_urice(GetBitContext *gb, int k)\n{\n    uint32_t z, x, b;\n\n    x = get_unary(gb, 1, 512);\n    b = get_bits_long(gb, k);\n    z = b | x << k;\n\n    return z;\n}\n\nstatic int32_t get_srice(GetBitContext *gb, int x)\n{\n    int32_t y = get_urice(gb, x);\n    return get_bits1(gb) ? -y : y;\n}\n\nstatic int osq_channel_parameters(AVCodecContext *avctx, int ch)\n{\n    OSQContext *s = avctx->priv_data;\n    OSQChannel *cb = &s->ch[ch];\n    GetBitContext *gb = &s->gb;\n\n    cb->prev = 0;\n    cb->prediction = get_urice(gb, 5);\n    cb->coding_mode = get_urice(gb, 3);\n    if (cb->prediction >= 15)\n        return AVERROR_INVALIDDATA;\n    if (cb->coding_mode > 0 && cb->coding_mode < 3) {\n        cb->residue_parameter = get_urice(gb, 4);\n        if (!cb->residue_parameter || cb->residue_parameter >= 31)\n            return AVERROR_INVALIDDATA;\n    } else if (cb->coding_mode == 3) {\n        cb->residue_bits = get_urice(gb, 4);\n        if (!cb->residue_bits || cb->residue_bits >= 31)\n            return AVERROR_INVALIDDATA;\n    } else if (cb->coding_mode) {\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (cb->coding_mode == 2)\n        reset_stats(cb);\n\n    return 0;\n}\n\n#define A (-1)\n#define B (-2)\n#define C (-3)\n#define D (-4)\n#define E (-5)\n#define P2 ((dst[A] + dst[A]) - dst[B])\n#define P3 ((dst[A] - dst[B]) * 3 + dst[C])\n\nstatic int do_decode(AVCodecContext *avctx, AVFrame *frame, int decorrelate, int downsample)\n{\n    OSQContext *s = avctx->priv_data;\n    const int nb_channels = avctx->ch_layout.nb_channels;\n    const int nb_samples = frame->nb_samples;\n    GetBitContext *gb = &s->gb;\n\n    for (int n = 0; n < nb_samples; n++) {\n        for (int ch = 0; ch < nb_channels; ch++) {\n            OSQChannel *cb = &s->ch[ch];\n            int32_t *dst = s->decode_buffer[ch] + OFFSET;\n            int32_t p, prev = cb->prev;\n\n            if (nb_channels == 2 && ch == 1 && decorrelate != s->decorrelate) {\n                if (!decorrelate) {\n                    s->decode_buffer[1][OFFSET+A] += s->decode_buffer[0][OFFSET+B];\n                    s->decode_buffer[1][OFFSET+B] += s->decode_buffer[0][OFFSET+C];\n                    s->decode_buffer[1][OFFSET+C] += s->decode_buffer[0][OFFSET+D];\n                    s->decode_buffer[1][OFFSET+D] += s->decode_buffer[0][OFFSET+E];\n                } else {\n                    s->decode_buffer[1][OFFSET+A] -= s->decode_buffer[0][OFFSET+B];\n                    s->decode_buffer[1][OFFSET+B] -= s->decode_buffer[0][OFFSET+C];\n                    s->decode_buffer[1][OFFSET+C] -= s->decode_buffer[0][OFFSET+D];\n                    s->decode_buffer[1][OFFSET+D] -= s->decode_buffer[0][OFFSET+E];\n                }\n                s->decorrelate = decorrelate;\n            }\n\n            if (!cb->coding_mode) {\n                dst[n] = 0;\n            } else if (cb->coding_mode == 3) {\n                dst[n] = get_sbits_long(gb, cb->residue_bits);\n            } else {\n                dst[n] = get_srice(gb, cb->residue_parameter);\n            }\n\n            if (get_bits_left(gb) < 0) {\n                av_log(avctx, AV_LOG_ERROR, \"overread!\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n\n            p = prev / 2;\n            prev = dst[n];\n\n            switch (cb->prediction) {\n            case 0:\n                break;\n            case 1:\n                dst[n] += dst[A];\n                break;\n            case 2:\n                dst[n] += dst[A] + p;\n                break;\n            case 3:\n                dst[n] += P2;\n                break;\n            case 4:\n                dst[n] += P2 + p;\n                break;\n            case 5:\n                dst[n] += P3;\n                break;\n            case 6:\n                dst[n] += P3 + p;\n                break;\n            case 7:\n                dst[n] += (P2 + P3) / 2 + p;\n                break;\n            case 8:\n                dst[n] += (P2 + P3) / 2;\n                break;\n            case 9:\n                dst[n] += (P2 * 2 + P3) / 3 + p;\n                break;\n            case 10:\n                dst[n] += (P2 + P3 * 2) / 3 + p;\n                break;\n            case 11:\n                dst[n] += (dst[A] + dst[B]) / 2;\n                break;\n            case 12:\n                dst[n] += dst[B];\n                break;\n            case 13:\n                dst[n] += (dst[D] + dst[B]) / 2;\n                break;\n            case 14:\n                dst[n] += (P2 + dst[A]) / 2 + p;\n                break;\n            default:\n                return AVERROR_INVALIDDATA;\n            }\n\n            cb->prev = prev;\n\n            if (downsample)\n                dst[n] *= 256;\n\n            dst[E] = dst[D];\n            dst[D] = dst[C];\n            dst[C] = dst[B];\n            dst[B] = dst[A];\n            dst[A] = dst[n];\n\n            if (cb->coding_mode == 2) {\n                update_stats(cb, dst[n]);\n                cb->residue_parameter = update_residue_parameter(cb);\n            }\n\n            if (nb_channels == 2 && ch == 1) {\n                if (decorrelate)\n                    dst[n] += s->decode_buffer[0][OFFSET+n];\n            }\n\n            if (downsample)\n                dst[A] /= 256;\n        }\n    }\n\n    return 0;\n}\n\nstatic int osq_decode_block(AVCodecContext *avctx, AVFrame *frame)\n{\n    const int nb_channels = avctx->ch_layout.nb_channels;\n    OSQContext *s = avctx->priv_data;\n    int ret, decorrelate, downsample;\n    GetBitContext *gb = &s->gb;\n\n    skip_bits1(gb);\n    decorrelate = get_bits1(gb);\n    downsample = get_bits1(gb);\n\n    for (int ch = 0; ch < nb_channels; ch++) {\n        if ((ret = osq_channel_parameters(avctx, ch)) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid channel parameters\\n\");\n            return ret;\n        }\n    }\n\n    if ((ret = do_decode(avctx, frame, decorrelate, downsample)) < 0)\n        return ret;\n\n    align_get_bits(gb);\n\n    switch (avctx->sample_fmt) {\n    case AV_SAMPLE_FMT_U8P:\n        for (int ch = 0; ch < nb_channels; ch++) {\n            uint8_t *dst = (uint8_t *)frame->extended_data[ch];\n            int32_t *src = s->decode_buffer[ch] + OFFSET;\n\n            for (int n = 0; n < frame->nb_samples; n++)\n                dst[n] = av_clip_uint8(src[n] + 0x80);\n        }\n        break;\n    case AV_SAMPLE_FMT_S16P:\n        for (int ch = 0; ch < nb_channels; ch++) {\n            int16_t *dst = (int16_t *)frame->extended_data[ch];\n            int32_t *src = s->decode_buffer[ch] + OFFSET;\n\n            for (int n = 0; n < frame->nb_samples; n++)\n                dst[n] = (int16_t)src[n];\n        }\n        break;\n    case AV_SAMPLE_FMT_S32P:\n        for (int ch = 0; ch < nb_channels; ch++) {\n            int32_t *dst = (int32_t *)frame->extended_data[ch];\n            int32_t *src = s->decode_buffer[ch] + OFFSET;\n\n            for (int n = 0; n < frame->nb_samples; n++)\n                dst[n] = src[n];\n        }\n        break;\n    default:\n        return AVERROR_BUG;\n    }\n\n    return 0;\n}\n\nstatic int osq_receive_frame(AVCodecContext *avctx, AVFrame *frame)\n{\n    OSQContext *s = avctx->priv_data;\n    GetBitContext *gb = &s->gb;\n    int ret, n;\n\n    while (s->bitstream_size < s->max_framesize) {\n        int size;\n\n        if (!s->pkt->data) {\n            ret = ff_decode_get_packet(avctx, s->pkt);\n            if (ret == AVERROR_EOF && s->bitstream_size > 0)\n                break;\n            if (ret < 0)\n                return ret;\n        }\n\n        size = FFMIN(s->pkt->size - s->pkt_offset, s->max_framesize - s->bitstream_size);\n        memcpy(s->bitstream + s->bitstream_size, s->pkt->data + s->pkt_offset, size);\n        s->bitstream_size += size;\n        s->pkt_offset += size;\n\n        if (s->pkt_offset == s->pkt->size) {\n            av_packet_unref(s->pkt);\n            s->pkt_offset = 0;\n        }\n    }\n\n    frame->nb_samples = FFMIN(s->frame_samples, s->nb_samples);\n    if (frame->nb_samples <= 0)\n        return AVERROR_EOF;\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        goto fail;\n\n    if ((ret = init_get_bits8(gb, s->bitstream, s->bitstream_size)) < 0)\n        goto fail;\n\n    if ((ret = osq_decode_block(avctx, frame)) < 0)\n        goto fail;\n\n    s->nb_samples -= frame->nb_samples;\n\n    n = get_bits_count(gb) / 8;\n    if (n > s->bitstream_size) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    memmove(s->bitstream, &s->bitstream[n], s->bitstream_size - n);\n    s->bitstream_size -= n;\n\n    return 0;\n\nfail:\n    s->bitstream_size = 0;\n    s->pkt_offset = 0;\n    av_packet_unref(s->pkt);\n\n    return ret;\n}\n\nconst FFCodec ff_osq_decoder = {\n    .p.name           = \"osq\",\n    CODEC_LONG_NAME(\"OSQ (Original Sound Quality)\"),\n    .p.type           = AVMEDIA_TYPE_AUDIO,\n    .p.id             = AV_CODEC_ID_OSQ,\n    .priv_data_size   = sizeof(OSQContext),\n    .init             = osq_init,\n    FF_CODEC_RECEIVE_FRAME_CB(osq_receive_frame),\n    .close            = osq_close,\n    .p.capabilities   = AV_CODEC_CAP_CHANNEL_CONF |\n                        AV_CODEC_CAP_DR1,\n    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,\n    .p.sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_U8P,\n                                                        AV_SAMPLE_FMT_S16P,\n                                                        AV_SAMPLE_FMT_S32P,\n                                                        AV_SAMPLE_FMT_NONE },\n};\n"], "fixing_code": ["/*\n * OSQ audio decoder\n * Copyright (c) 2023 Paul B Mahol\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/internal.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"avcodec.h\"\n#include \"codec_internal.h\"\n#include \"decode.h\"\n#include \"internal.h\"\n#define BITSTREAM_READER_LE\n#include \"get_bits.h\"\n#include \"unary.h\"\n\n#define OFFSET 5\n\ntypedef struct OSQChannel {\n    unsigned prediction;\n    unsigned coding_mode;\n    unsigned residue_parameter;\n    unsigned residue_bits;\n    unsigned history[3];\n    unsigned pos, count;\n    double sum;\n    int32_t prev;\n} OSQChannel;\n\ntypedef struct OSQContext {\n    GetBitContext gb;\n    OSQChannel ch[2];\n\n    uint8_t *bitstream;\n    size_t max_framesize;\n    size_t bitstream_size;\n\n    int decorrelate;\n    int frame_samples;\n    uint64_t nb_samples;\n\n    int32_t *decode_buffer[2];\n\n    AVPacket *pkt;\n    int pkt_offset;\n} OSQContext;\n\nstatic av_cold int osq_close(AVCodecContext *avctx)\n{\n    OSQContext *s = avctx->priv_data;\n\n    av_freep(&s->bitstream);\n    s->bitstream_size = 0;\n\n    for (int ch = 0; ch < FF_ARRAY_ELEMS(s->decode_buffer); ch++)\n        av_freep(&s->decode_buffer[ch]);\n\n    return 0;\n}\n\nstatic av_cold int osq_init(AVCodecContext *avctx)\n{\n    OSQContext *s = avctx->priv_data;\n\n    if (avctx->extradata_size < 48)\n        return AVERROR(EINVAL);\n\n    if (avctx->extradata[0] != 1) {\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported version.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avctx->sample_rate = AV_RL32(avctx->extradata + 4);\n    if (avctx->sample_rate < 1)\n        return AVERROR_INVALIDDATA;\n\n    av_channel_layout_uninit(&avctx->ch_layout);\n    avctx->ch_layout.order = AV_CHANNEL_ORDER_UNSPEC;\n    avctx->ch_layout.nb_channels = avctx->extradata[3];\n    if (avctx->ch_layout.nb_channels < 1)\n        return AVERROR_INVALIDDATA;\n    if (avctx->ch_layout.nb_channels > FF_ARRAY_ELEMS(s->decode_buffer))\n        return AVERROR_INVALIDDATA;\n\n    switch (avctx->extradata[2]) {\n    case  8: avctx->sample_fmt = AV_SAMPLE_FMT_U8P; break;\n    case 16: avctx->sample_fmt = AV_SAMPLE_FMT_S16P; break;\n    case 20:\n    case 24:\n    case 28:\n    case 32: avctx->sample_fmt = AV_SAMPLE_FMT_S32P; break;\n    default: return AVERROR_INVALIDDATA;\n    }\n\n    s->nb_samples = AV_RL64(avctx->extradata + 16);\n    s->frame_samples = AV_RL16(avctx->extradata + 8);\n    s->max_framesize = (s->frame_samples * 16 + 1024) * avctx->ch_layout.nb_channels;\n\n    s->bitstream = av_calloc(s->max_framesize + AV_INPUT_BUFFER_PADDING_SIZE, sizeof(*s->bitstream));\n    if (!s->bitstream)\n        return AVERROR(ENOMEM);\n\n    for (int ch = 0; ch < avctx->ch_layout.nb_channels; ch++) {\n        s->decode_buffer[ch] = av_calloc(s->frame_samples + OFFSET,\n                                         sizeof(*s->decode_buffer[ch]));\n        if (!s->decode_buffer[ch])\n            return AVERROR(ENOMEM);\n    }\n\n    s->pkt = avctx->internal->in_pkt;\n\n    return 0;\n}\n\nstatic void reset_stats(OSQChannel *cb)\n{\n    memset(cb->history, 0, sizeof(cb->history));\n    cb->pos = cb->count = cb->sum = 0;\n}\n\nstatic void update_stats(OSQChannel *cb, int val)\n{\n    cb->sum += FFABS(val) - cb->history[cb->pos];\n    cb->history[cb->pos] = FFABS(val);\n    cb->pos++;\n    cb->count++;\n    if (cb->pos >= FF_ARRAY_ELEMS(cb->history))\n        cb->pos = 0;\n}\n\nstatic int update_residue_parameter(OSQChannel *cb)\n{\n    double sum, x;\n    int rice_k;\n\n    sum = cb->sum;\n    x = sum / cb->count;\n    rice_k = av_ceil_log2(x);\n    if (rice_k >= 30) {\n        rice_k = floor(sum / 1.4426952 + 0.5);\n        if (rice_k < 1)\n            rice_k = 1;\n    }\n\n    return rice_k;\n}\n\nstatic uint32_t get_urice(GetBitContext *gb, int k)\n{\n    uint32_t z, x, b;\n\n    x = get_unary(gb, 1, 512);\n    b = get_bits_long(gb, k);\n    z = b | x << k;\n\n    return z;\n}\n\nstatic int32_t get_srice(GetBitContext *gb, int x)\n{\n    int32_t y = get_urice(gb, x);\n    return get_bits1(gb) ? -y : y;\n}\n\nstatic int osq_channel_parameters(AVCodecContext *avctx, int ch)\n{\n    OSQContext *s = avctx->priv_data;\n    OSQChannel *cb = &s->ch[ch];\n    GetBitContext *gb = &s->gb;\n\n    cb->prev = 0;\n    cb->prediction = get_urice(gb, 5);\n    cb->coding_mode = get_urice(gb, 3);\n    if (cb->prediction >= 15)\n        return AVERROR_INVALIDDATA;\n    if (cb->coding_mode > 0 && cb->coding_mode < 3) {\n        cb->residue_parameter = get_urice(gb, 4);\n        if (!cb->residue_parameter || cb->residue_parameter >= 31)\n            return AVERROR_INVALIDDATA;\n    } else if (cb->coding_mode == 3) {\n        cb->residue_bits = get_urice(gb, 4);\n        if (!cb->residue_bits || cb->residue_bits >= 31)\n            return AVERROR_INVALIDDATA;\n    } else if (cb->coding_mode) {\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (cb->coding_mode == 2)\n        reset_stats(cb);\n\n    return 0;\n}\n\n#define A (-1)\n#define B (-2)\n#define C (-3)\n#define D (-4)\n#define E (-5)\n#define P2 ((dst[A] + dst[A]) - dst[B])\n#define P3 ((dst[A] - dst[B]) * 3 + dst[C])\n\nstatic int do_decode(AVCodecContext *avctx, AVFrame *frame, int decorrelate, int downsample)\n{\n    OSQContext *s = avctx->priv_data;\n    const int nb_channels = avctx->ch_layout.nb_channels;\n    const int nb_samples = frame->nb_samples;\n    GetBitContext *gb = &s->gb;\n\n    for (int n = 0; n < nb_samples; n++) {\n        for (int ch = 0; ch < nb_channels; ch++) {\n            OSQChannel *cb = &s->ch[ch];\n            int32_t *dst = s->decode_buffer[ch] + OFFSET;\n            int32_t p, prev = cb->prev;\n\n            if (nb_channels == 2 && ch == 1 && decorrelate != s->decorrelate) {\n                if (!decorrelate) {\n                    s->decode_buffer[1][OFFSET+A] += s->decode_buffer[0][OFFSET+B];\n                    s->decode_buffer[1][OFFSET+B] += s->decode_buffer[0][OFFSET+C];\n                    s->decode_buffer[1][OFFSET+C] += s->decode_buffer[0][OFFSET+D];\n                    s->decode_buffer[1][OFFSET+D] += s->decode_buffer[0][OFFSET+E];\n                } else {\n                    s->decode_buffer[1][OFFSET+A] -= s->decode_buffer[0][OFFSET+B];\n                    s->decode_buffer[1][OFFSET+B] -= s->decode_buffer[0][OFFSET+C];\n                    s->decode_buffer[1][OFFSET+C] -= s->decode_buffer[0][OFFSET+D];\n                    s->decode_buffer[1][OFFSET+D] -= s->decode_buffer[0][OFFSET+E];\n                }\n                s->decorrelate = decorrelate;\n            }\n\n            if (!cb->coding_mode) {\n                dst[n] = 0;\n            } else if (cb->coding_mode == 3) {\n                dst[n] = get_sbits_long(gb, cb->residue_bits);\n            } else {\n                dst[n] = get_srice(gb, cb->residue_parameter);\n            }\n\n            if (get_bits_left(gb) < 0) {\n                av_log(avctx, AV_LOG_ERROR, \"overread!\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n\n            p = prev / 2;\n            prev = dst[n];\n\n            switch (cb->prediction) {\n            case 0:\n                break;\n            case 1:\n                dst[n] += dst[A];\n                break;\n            case 2:\n                dst[n] += dst[A] + p;\n                break;\n            case 3:\n                dst[n] += P2;\n                break;\n            case 4:\n                dst[n] += P2 + p;\n                break;\n            case 5:\n                dst[n] += P3;\n                break;\n            case 6:\n                dst[n] += P3 + p;\n                break;\n            case 7:\n                dst[n] += (P2 + P3) / 2 + p;\n                break;\n            case 8:\n                dst[n] += (P2 + P3) / 2;\n                break;\n            case 9:\n                dst[n] += (P2 * 2 + P3) / 3 + p;\n                break;\n            case 10:\n                dst[n] += (P2 + P3 * 2) / 3 + p;\n                break;\n            case 11:\n                dst[n] += (dst[A] + dst[B]) / 2;\n                break;\n            case 12:\n                dst[n] += dst[B];\n                break;\n            case 13:\n                dst[n] += (dst[D] + dst[B]) / 2;\n                break;\n            case 14:\n                dst[n] += (P2 + dst[A]) / 2 + p;\n                break;\n            default:\n                return AVERROR_INVALIDDATA;\n            }\n\n            cb->prev = prev;\n\n            if (downsample)\n                dst[n] *= 256;\n\n            dst[E] = dst[D];\n            dst[D] = dst[C];\n            dst[C] = dst[B];\n            dst[B] = dst[A];\n            dst[A] = dst[n];\n\n            if (cb->coding_mode == 2) {\n                update_stats(cb, dst[n]);\n                cb->residue_parameter = update_residue_parameter(cb);\n            }\n\n            if (nb_channels == 2 && ch == 1) {\n                if (decorrelate)\n                    dst[n] += s->decode_buffer[0][OFFSET+n];\n            }\n\n            if (downsample)\n                dst[A] /= 256;\n        }\n    }\n\n    return 0;\n}\n\nstatic int osq_decode_block(AVCodecContext *avctx, AVFrame *frame)\n{\n    const int nb_channels = avctx->ch_layout.nb_channels;\n    OSQContext *s = avctx->priv_data;\n    int ret, decorrelate, downsample;\n    GetBitContext *gb = &s->gb;\n\n    skip_bits1(gb);\n    decorrelate = get_bits1(gb);\n    downsample = get_bits1(gb);\n\n    for (int ch = 0; ch < nb_channels; ch++) {\n        if ((ret = osq_channel_parameters(avctx, ch)) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid channel parameters\\n\");\n            return ret;\n        }\n    }\n\n    if ((ret = do_decode(avctx, frame, decorrelate, downsample)) < 0)\n        return ret;\n\n    align_get_bits(gb);\n\n    switch (avctx->sample_fmt) {\n    case AV_SAMPLE_FMT_U8P:\n        for (int ch = 0; ch < nb_channels; ch++) {\n            uint8_t *dst = (uint8_t *)frame->extended_data[ch];\n            int32_t *src = s->decode_buffer[ch] + OFFSET;\n\n            for (int n = 0; n < frame->nb_samples; n++)\n                dst[n] = av_clip_uint8(src[n] + 0x80);\n        }\n        break;\n    case AV_SAMPLE_FMT_S16P:\n        for (int ch = 0; ch < nb_channels; ch++) {\n            int16_t *dst = (int16_t *)frame->extended_data[ch];\n            int32_t *src = s->decode_buffer[ch] + OFFSET;\n\n            for (int n = 0; n < frame->nb_samples; n++)\n                dst[n] = (int16_t)src[n];\n        }\n        break;\n    case AV_SAMPLE_FMT_S32P:\n        for (int ch = 0; ch < nb_channels; ch++) {\n            int32_t *dst = (int32_t *)frame->extended_data[ch];\n            int32_t *src = s->decode_buffer[ch] + OFFSET;\n\n            for (int n = 0; n < frame->nb_samples; n++)\n                dst[n] = src[n];\n        }\n        break;\n    default:\n        return AVERROR_BUG;\n    }\n\n    return 0;\n}\n\nstatic int osq_receive_frame(AVCodecContext *avctx, AVFrame *frame)\n{\n    OSQContext *s = avctx->priv_data;\n    GetBitContext *gb = &s->gb;\n    int ret, n;\n\n    while (s->bitstream_size < s->max_framesize) {\n        int size;\n\n        if (!s->pkt->data) {\n            ret = ff_decode_get_packet(avctx, s->pkt);\n            if (ret == AVERROR_EOF && s->bitstream_size > 0)\n                break;\n            if (ret < 0)\n                return ret;\n        }\n\n        size = FFMIN(s->pkt->size - s->pkt_offset, s->max_framesize - s->bitstream_size);\n        memcpy(s->bitstream + s->bitstream_size, s->pkt->data + s->pkt_offset, size);\n        s->bitstream_size += size;\n        s->pkt_offset += size;\n\n        if (s->pkt_offset == s->pkt->size) {\n            av_packet_unref(s->pkt);\n            s->pkt_offset = 0;\n        }\n    }\n\n    frame->nb_samples = FFMIN(s->frame_samples, s->nb_samples);\n    if (frame->nb_samples <= 0)\n        return AVERROR_EOF;\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        goto fail;\n\n    if ((ret = init_get_bits8(gb, s->bitstream, s->bitstream_size)) < 0)\n        goto fail;\n\n    if ((ret = osq_decode_block(avctx, frame)) < 0)\n        goto fail;\n\n    s->nb_samples -= frame->nb_samples;\n\n    n = get_bits_count(gb) / 8;\n    if (n > s->bitstream_size) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    memmove(s->bitstream, &s->bitstream[n], s->bitstream_size - n);\n    s->bitstream_size -= n;\n\n    return 0;\n\nfail:\n    s->bitstream_size = 0;\n    s->pkt_offset = 0;\n    av_packet_unref(s->pkt);\n\n    return ret;\n}\n\nconst FFCodec ff_osq_decoder = {\n    .p.name           = \"osq\",\n    CODEC_LONG_NAME(\"OSQ (Original Sound Quality)\"),\n    .p.type           = AVMEDIA_TYPE_AUDIO,\n    .p.id             = AV_CODEC_ID_OSQ,\n    .priv_data_size   = sizeof(OSQContext),\n    .init             = osq_init,\n    FF_CODEC_RECEIVE_FRAME_CB(osq_receive_frame),\n    .close            = osq_close,\n    .p.capabilities   = AV_CODEC_CAP_CHANNEL_CONF |\n                        AV_CODEC_CAP_DR1,\n    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,\n    .p.sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_U8P,\n                                                        AV_SAMPLE_FMT_S16P,\n                                                        AV_SAMPLE_FMT_S32P,\n                                                        AV_SAMPLE_FMT_NONE },\n};\n"], "filenames": ["libavcodec/osq.c"], "buggy_code_start_loc": [55], "buggy_code_end_loc": [56], "fixing_code_start_loc": [55], "fixing_code_end_loc": [56], "type": "CWE-190", "message": "Integer overflow vulnerability in FFmpeg before n6.1, allows attackers to cause a denial of service (DoS) via the avcodec/osq module.", "other": {"cve": {"id": "CVE-2024-22861", "sourceIdentifier": "cve@mitre.org", "published": "2024-01-27T07:15:07.603", "lastModified": "2024-02-02T23:38:20.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer overflow vulnerability in FFmpeg before n6.1, allows attackers to cause a denial of service (DoS) via the avcodec/osq module."}, {"lang": "es", "value": "Vulnerabilidad de desbordamiento de enteros en FFmpeg anterior a n6.1, permite a los atacantes provocar una denegaci\u00f3n de servicio (DoS) a trav\u00e9s del m\u00f3dulo avcodec/osq."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.1", "matchCriteriaId": "54E3D89D-E427-413B-A8E1-C9ED6D2409F3"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/87b8c1081959e45ffdcbabb3d53ac9882ef2b5ce", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/87b8c1081959e45ffdcbabb3d53ac9882ef2b5ce"}}