{"buggy_code": ["module Haml\n  # This module contains various helpful methods to make it easier to do various tasks.\n  # {Haml::Helpers} is automatically included in the context\n  # that a Haml template is parsed in, so all these methods are at your\n  # disposal from within the template.\n  module Helpers\n    # An object that raises an error when \\{#to\\_s} is called.\n    # It's used to raise an error when the return value of a helper is used\n    # when it shouldn't be.\n    class ErrorReturn\n      def initialize(method)\n        @message = <<MESSAGE\n#{method} outputs directly to the Haml template.\nDisregard its return value and use the - operator,\nor use capture_haml to get the value as a String.\nMESSAGE\n      end\n\n      # Raises an error.\n      #\n      # @raise [Haml::Error] The error\n      def to_s\n        raise Haml::Error.new(@message)\n      rescue Haml::Error => e\n        e.backtrace.shift\n\n        # If the ErrorReturn is used directly in the template,\n        # we don't want Haml's stuff to get into the backtrace,\n        # so we get rid of the format_script line.\n        #\n        # We also have to subtract one from the Haml line number\n        # since the value is passed to format_script the line after\n        # it's actually used.\n        if e.backtrace.first =~ /^\\(eval\\):\\d+:in `format_script/\n          e.backtrace.shift\n          e.backtrace.first.gsub!(/^\\(haml\\):(\\d+)/) {|s| \"(haml):#{$1.to_i - 1}\"}\n        end\n        raise e\n      end\n\n      # @return [String] A human-readable string representation\n      def inspect\n        \"Haml::Helpers::ErrorReturn(#{@message.inspect})\"\n      end\n    end\n\n    self.extend self\n\n    @@action_view_defined = false\n\n    # @return [Boolean] Whether or not ActionView is loaded\n    def self.action_view?\n      @@action_view_defined\n    end\n\n    # Note: this does **not** need to be called when using Haml helpers\n    # normally in Rails.\n    #\n    # Initializes the current object as though it were in the same context\n    # as a normal ActionView instance using Haml.\n    # This is useful if you want to use the helpers in a context\n    # other than the normal setup with ActionView.\n    # For example:\n    #\n    #     context = Object.new\n    #     class << context\n    #       include Haml::Helpers\n    #     end\n    #     context.init_haml_helpers\n    #     context.haml_tag :p, \"Stuff\"\n    #\n    def init_haml_helpers\n      @haml_buffer = Haml::Buffer.new(haml_buffer, Options.new.for_buffer)\n      nil\n    end\n\n    # Runs a block of code in a non-Haml context\n    # (i.e. \\{#is\\_haml?} will return false).\n    #\n    # This is mainly useful for rendering sub-templates such as partials in a non-Haml language,\n    # particularly where helpers may behave differently when run from Haml.\n    #\n    # Note that this is automatically applied to Rails partials.\n    #\n    # @yield A block which won't register as Haml\n    def non_haml\n      was_active = @haml_buffer.active?\n      @haml_buffer.active = false\n      yield\n    ensure\n      @haml_buffer.active = was_active\n    end\n\n    # Uses \\{#preserve} to convert any newlines inside whitespace-sensitive tags\n    # into the HTML entities for endlines.\n    #\n    # @param tags [Array<String>] Tags that should have newlines escaped\n    #\n    # @overload find_and_preserve(input, tags = haml_buffer.options[:preserve])\n    #   Escapes newlines within a string.\n    #\n    #   @param input [String] The string within which to escape newlines\n    # @overload find_and_preserve(tags = haml_buffer.options[:preserve])\n    #   Escapes newlines within a block of Haml code.\n    #\n    #   @yield The block within which to escape newlines\n    def find_and_preserve(input = nil, tags = haml_buffer.options[:preserve], &block)\n      return find_and_preserve(capture_haml(&block), input || tags) if block\n      tags = tags.each_with_object('') do |t, s|\n        s << '|' unless s.empty?\n        s << Regexp.escape(t)\n      end\n      re = /<(#{tags})([^>]*)>(.*?)(<\\/\\1>)/im\n      input.to_s.gsub(re) do |s|\n        s =~ re # Can't rely on $1, etc. existing since Rails' SafeBuffer#gsub is incompatible\n        \"<#{$1}#{$2}>#{preserve($3)}</#{$1}>\"\n      end\n    end\n\n    # Takes any string, finds all the newlines, and converts them to\n    # HTML entities so they'll render correctly in\n    # whitespace-sensitive tags without screwing up the indentation.\n    #\n    # @overload preserve(input)\n    #   Escapes newlines within a string.\n    #\n    #   @param input [String] The string within which to escape all newlines\n    # @overload preserve\n    #   Escapes newlines within a block of Haml code.\n    #\n    #   @yield The block within which to escape newlines\n    def preserve(input = nil, &block)\n      return preserve(capture_haml(&block)) if block\n      s = input.to_s.chomp(\"\\n\")\n      s.gsub!(/\\n/, '&#x000A;')\n      s.delete!(\"\\r\")\n      s\n    end\n    alias_method :flatten, :preserve\n\n    # Takes an `Enumerable` object and a block\n    # and iterates over the enum,\n    # yielding each element to a Haml block\n    # and putting the result into `<li>` elements.\n    # This creates a list of the results of the block.\n    # For example:\n    #\n    #     = list_of([['hello'], ['yall']]) do |i|\n    #       = i[0]\n    #\n    # Produces:\n    #\n    #     <li>hello</li>\n    #     <li>yall</li>\n    #\n    # And:\n    #\n    #     = list_of({:title => 'All the stuff', :description => 'A book about all the stuff.'}) do |key, val|\n    #       %h3= key.humanize\n    #       %p= val\n    #\n    # Produces:\n    #\n    #     <li>\n    #       <h3>Title</h3>\n    #       <p>All the stuff</p>\n    #     </li>\n    #     <li>\n    #       <h3>Description</h3>\n    #       <p>A book about all the stuff.</p>\n    #     </li>\n    #\n    # While:\n    #\n    #     = list_of([\"Home\", \"About\", \"Contact\", \"FAQ\"], {class: \"nav\", role: \"nav\"}) do |item|\n    #       %a{ href=\"#\" }= item\n    #\n    # Produces:\n    #\n    #     <li class='nav' role='nav'>\n    #       <a href='#'>Home</a>\n    #     </li>\n    #     <li class='nav' role='nav'>\n    #       <a href='#'>About</a>\n    #     </li>\n    #     <li class='nav' role='nav'>\n    #       <a href='#'>Contact</a>\n    #     </li>\n    #     <li class='nav' role='nav'>\n    #       <a href='#'>FAQ</a>\n    #     </li>\n    #\n    #  `[[class\", \"nav\"], [role\", \"nav\"]]` could have been used instead of `{class: \"nav\", role: \"nav\"}` (or any enumerable collection where each pair of items responds to #to_s)\n    #\n    # @param enum [Enumerable] The list of objects to iterate over\n    # @param [Enumerable<#to_s,#to_s>] opts Each key/value pair will become an attribute pair for each list item element.\n    # @yield [item] A block which contains Haml code that goes within list items\n    # @yieldparam item An element of `enum`\n    def list_of(enum, opts={}, &block)\n      opts_attributes = opts.each_with_object('') {|(k, v), s| s << \" #{k}='#{v}'\"}\n      enum.each_with_object('') do |i, ret|\n        result = capture_haml(i, &block)\n\n        if result.count(\"\\n\") > 1\n          result.gsub!(\"\\n\", \"\\n  \")\n          result = \"\\n  #{result.strip!}\\n\"\n        else\n          result.strip!\n        end\n\n        ret << \"\\n\" unless ret.empty?\n        ret << %Q!<li#{opts_attributes}>#{result}</li>!\n      end\n    end\n\n    # Returns a hash containing default assignments for the `xmlns`, `lang`, and `xml:lang`\n    # attributes of the `html` HTML element.\n    # For example,\n    #\n    #     %html{html_attrs}\n    #\n    # becomes\n    #\n    #     <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en-US' lang='en-US'>\n    #\n    # @param lang [String] The value of `xml:lang` and `lang`\n    # @return [{#to_s => String}] The attribute hash\n    def html_attrs(lang = 'en-US')\n      if haml_buffer.options[:format] == :xhtml\n        {:xmlns => \"http://www.w3.org/1999/xhtml\", 'xml:lang' => lang, :lang => lang}\n      else\n        {:lang => lang}\n      end\n    end\n\n    # Increments the number of tabs the buffer automatically adds\n    # to the lines of the template.\n    # For example:\n    #\n    #     %h1 foo\n    #     - tab_up\n    #     %p bar\n    #     - tab_down\n    #     %strong baz\n    #\n    # Produces:\n    #\n    #     <h1>foo</h1>\n    #       <p>bar</p>\n    #     <strong>baz</strong>\n    #\n    # @param i [Fixnum] The number of tabs by which to increase the indentation\n    # @see #tab_down\n    def tab_up(i = 1)\n      haml_buffer.tabulation += i\n    end\n\n    # Decrements the number of tabs the buffer automatically adds\n    # to the lines of the template.\n    #\n    # @param i [Fixnum] The number of tabs by which to decrease the indentation\n    # @see #tab_up\n    def tab_down(i = 1)\n      haml_buffer.tabulation -= i\n    end\n\n    # Sets the number of tabs the buffer automatically adds\n    # to the lines of the template,\n    # but only for the duration of the block.\n    # For example:\n    #\n    #     %h1 foo\n    #     - with_tabs(2) do\n    #       %p bar\n    #     %strong baz\n    #\n    # Produces:\n    #\n    #     <h1>foo</h1>\n    #         <p>bar</p>\n    #     <strong>baz</strong>\n    #\n    #\n    # @param i [Fixnum] The number of tabs to use\n    # @yield A block in which the indentation will be `i` spaces\n    def with_tabs(i)\n      old_tabs = haml_buffer.tabulation\n      haml_buffer.tabulation = i\n      yield\n    ensure\n      haml_buffer.tabulation = old_tabs\n    end\n\n    # Surrounds a block of Haml code with strings,\n    # with no whitespace in between.\n    # For example:\n    #\n    #     = surround '(', ')' do\n    #       %a{:href => \"food\"} chicken\n    #\n    # Produces:\n    #\n    #     (<a href='food'>chicken</a>)\n    #\n    # and\n    #\n    #     = surround '*' do\n    #       %strong angry\n    #\n    # Produces:\n    #\n    #     *<strong>angry</strong>*\n    #\n    # @param front [String] The string to add before the Haml\n    # @param back [String] The string to add after the Haml\n    # @yield A block of Haml to surround\n    def surround(front, back = front, &block)\n      output = capture_haml(&block)\n\n      \"#{front}#{output.chomp}#{back}\\n\"\n    end\n\n    # Prepends a string to the beginning of a Haml block,\n    # with no whitespace between.\n    # For example:\n    #\n    #     = precede '*' do\n    #       %span.small Not really\n    #\n    # Produces:\n    #\n    #     *<span class='small'>Not really</span>\n    #\n    # @param str [String] The string to add before the Haml\n    # @yield A block of Haml to prepend to\n    def precede(str, &block)\n      \"#{str}#{capture_haml(&block).chomp}\\n\"\n    end\n\n    # Appends a string to the end of a Haml block,\n    # with no whitespace between.\n    # For example:\n    #\n    #     click\n    #     = succeed '.' do\n    #       %a{:href=>\"thing\"} here\n    #\n    # Produces:\n    #\n    #     click\n    #     <a href='thing'>here</a>.\n    #\n    # @param str [String] The string to add after the Haml\n    # @yield A block of Haml to append to\n    def succeed(str, &block)\n      \"#{capture_haml(&block).chomp}#{str}\\n\"\n    end\n\n    # Captures the result of a block of Haml code,\n    # gets rid of the excess indentation,\n    # and returns it as a string.\n    # For example, after the following,\n    #\n    #     .foo\n    #       - foo = capture_haml(13) do |a|\n    #         %p= a\n    #\n    # the local variable `foo` would be assigned to `\"<p>13</p>\\n\"`.\n    #\n    # @param args [Array] Arguments to pass into the block\n    # @yield [args] A block of Haml code that will be converted to a string\n    # @yieldparam args [Array] `args`\n    def capture_haml(*args, &block)\n      buffer = eval('if defined? _hamlout then _hamlout else nil end', block.binding) || haml_buffer\n      with_haml_buffer(buffer) do\n        position = haml_buffer.buffer.length\n\n        haml_buffer.capture_position = position\n        value = block.call(*args)\n\n        captured = haml_buffer.buffer.slice!(position..-1)\n\n        if captured == '' and value != haml_buffer.buffer\n          captured = (value.is_a?(String) ? value : nil)\n        end\n\n        return nil if captured.nil?\n        return (haml_buffer.options[:ugly] ? captured : prettify(captured))\n      end\n    ensure\n      haml_buffer.capture_position = nil\n    end\n\n    # Outputs text directly to the Haml buffer, with the proper indentation.\n    #\n    # @param text [#to_s] The text to output\n    def haml_concat(text = \"\")\n      haml_internal_concat text\n      ErrorReturn.new(\"haml_concat\")\n    end\n\n    # Internal method to write directly to the buffer with control of\n    # whether the first line should be indented, and if there should be a\n    # final newline.\n    #\n    # Lines added will have the proper indentation. This can be controlled\n    # for the first line.\n    #\n    # Used by #haml_concat and #haml_tag.\n    #\n    # @param text [#to_s] The text to output\n    # @param newline [Boolean] Whether to add a newline after the text\n    # @param indent [Boolean] Whether to add indentation to the first line\n    def haml_internal_concat(text = \"\", newline = true, indent = true)\n      if haml_buffer.options[:ugly] || haml_buffer.tabulation == 0\n        haml_buffer.buffer << \"#{text}#{\"\\n\" if newline}\"\n      else\n        haml_buffer.buffer << %[#{haml_indent if indent}#{text.to_s.gsub(\"\\n\", \"\\n#{haml_indent}\")}#{\"\\n\" if newline}]\n      end\n    end\n    private :haml_internal_concat\n\n    # Allows writing raw content. `haml_internal_concat_raw` isn't\n    # effected by XSS mods. Used by #haml_tag to write the actual tags.\n    alias :haml_internal_concat_raw :haml_internal_concat\n\n    # @return [String] The indentation string for the current line\n    def haml_indent\n      '  ' * haml_buffer.tabulation\n    end\n\n    # Creates an HTML tag with the given name and optionally text and attributes.\n    # Can take a block that will run between the opening and closing tags.\n    # If the block is a Haml block or outputs text using \\{#haml\\_concat},\n    # the text will be properly indented.\n    #\n    # `name` can be a string using the standard Haml class/id shorthand\n    # (e.g. \"span#foo.bar\", \"#foo\").\n    # Just like standard Haml tags, these class and id values\n    # will be merged with manually-specified attributes.\n    #\n    # `flags` is a list of symbol flags\n    # like those that can be put at the end of a Haml tag\n    # (`:/`, `:<`, and `:>`).\n    # Currently, only `:/` and `:<` are supported.\n    #\n    # `haml_tag` outputs directly to the buffer;\n    # its return value should not be used.\n    # If you need to get the results as a string,\n    # use \\{#capture\\_haml\\}.\n    #\n    # For example,\n    #\n    #     haml_tag :table do\n    #       haml_tag :tr do\n    #         haml_tag 'td.cell' do\n    #           haml_tag :strong, \"strong!\"\n    #           haml_concat \"data\"\n    #         end\n    #         haml_tag :td do\n    #           haml_concat \"more_data\"\n    #         end\n    #       end\n    #     end\n    #\n    # outputs\n    #\n    #     <table>\n    #       <tr>\n    #         <td class='cell'>\n    #           <strong>\n    #             strong!\n    #           </strong>\n    #           data\n    #         </td>\n    #         <td>\n    #           more_data\n    #         </td>\n    #       </tr>\n    #     </table>\n    #\n    # @param name [#to_s] The name of the tag\n    #\n    # @overload haml_tag(name, *rest, attributes = {})\n    #   @yield The block of Haml code within the tag\n    # @overload haml_tag(name, text, *flags, attributes = {})\n    #   @param text [#to_s] The text within the tag\n    #   @param flags [Array<Symbol>] Haml end-of-tag flags\n    def haml_tag(name, *rest, &block)\n      ret = ErrorReturn.new(\"haml_tag\")\n\n      text = rest.shift.to_s unless [Symbol, Hash, NilClass].any? {|t| rest.first.is_a? t}\n      flags = []\n      flags << rest.shift while rest.first.is_a? Symbol\n      attrs = (rest.shift || {})\n      attrs.keys.each {|key| attrs[key.to_s] = attrs.delete(key)} unless attrs.empty?\n      name, attrs = merge_name_and_attributes(name.to_s, attrs)\n\n      attributes = Haml::AttributeBuilder.build_attributes(haml_buffer.html?,\n        haml_buffer.options[:attr_wrapper],\n        haml_buffer.options[:escape_attrs],\n        haml_buffer.options[:hyphenate_data_attrs],\n        attrs)\n\n      if text.nil? && block.nil? && (haml_buffer.options[:autoclose].include?(name) || flags.include?(:/))\n        haml_internal_concat_raw \"<#{name}#{attributes}#{' /' if haml_buffer.options[:format] == :xhtml}>\"\n        return ret\n      end\n\n      if flags.include?(:/)\n        raise Error.new(Error.message(:self_closing_content)) if text\n        raise Error.new(Error.message(:illegal_nesting_self_closing)) if block\n      end\n\n      tag = \"<#{name}#{attributes}>\"\n      end_tag = \"</#{name}>\"\n      if block.nil?\n        text = text.to_s\n        if text.include?(\"\\n\")\n          haml_internal_concat_raw tag\n          tab_up\n          haml_internal_concat text\n          tab_down\n          haml_internal_concat_raw end_tag\n        else\n          haml_internal_concat_raw tag, false\n          haml_internal_concat text, false, false\n          haml_internal_concat_raw end_tag, true, false\n        end\n        return ret\n      end\n\n      if text\n        raise Error.new(Error.message(:illegal_nesting_line, name))\n      end\n\n      if flags.include?(:<)\n        haml_internal_concat_raw tag, false\n        haml_internal_concat \"#{capture_haml(&block).strip}\", false, false\n        haml_internal_concat_raw end_tag, true, false\n        return ret\n      end\n\n      haml_internal_concat_raw tag\n      tab_up\n      block.call\n      tab_down\n      haml_internal_concat_raw end_tag\n\n      ret\n    end\n\n    # Conditionally wrap a block in an element. If `condition` is `true` then\n    # this method renders the tag described by the arguments in `tag` (using\n    # \\{#haml_tag}) with the given block inside, otherwise it just renders the block.\n    #\n    # For example,\n    #\n    #     - haml_tag_if important, '.important' do\n    #       %p\n    #         A (possibly) important paragraph.\n    #\n    # will produce\n    #\n    #     <div class='important'>\n    #       <p>\n    #         A (possibly) important paragraph.\n    #       </p>\n    #     </div>\n    #\n    # if `important` is truthy, and just\n    #\n    #     <p>\n    #       A (possibly) important paragraph.\n    #     </p>\n    #\n    # otherwise.\n    #\n    # Like \\{#haml_tag}, `haml_tag_if` outputs directly to the buffer and its\n    # return value should not be used. Use \\{#capture_haml} if you need to use\n    # its results as a string.\n    #\n    # @param condition The condition to test to determine whether to render\n    #   the enclosing tag\n    # @param tag Definition of the enclosing tag. See \\{#haml_tag} for details\n    #   (specifically the form that takes a block)\n    def haml_tag_if(condition, *tag)\n      if condition\n        haml_tag(*tag){ yield }\n      else\n        yield\n      end\n      ErrorReturn.new(\"haml_tag_if\")\n    end\n\n    # Characters that need to be escaped to HTML entities from user input\n    HTML_ESCAPE = { '&' => '&amp;', '<' => '&lt;', '>' => '&gt;', '\"' => '&quot;', \"'\" => '&#039;' }\n\n    HTML_ESCAPE_REGEX = /[\\\"><&]/\n\n    # Returns a copy of `text` with ampersands, angle brackets and quotes\n    # escaped into HTML entities.\n    #\n    # Note that if ActionView is loaded and XSS protection is enabled\n    # (as is the default for Rails 3.0+, and optional for version 2.3.5+),\n    # this won't escape text declared as \"safe\".\n    #\n    # @param text [String] The string to sanitize\n    # @return [String] The sanitized string\n    def html_escape(text)\n      text = text.to_s\n      text.gsub(HTML_ESCAPE_REGEX, HTML_ESCAPE)\n    end\n\n    HTML_ESCAPE_ONCE_REGEX = /[\\\"><]|&(?!(?:[a-zA-Z]+|#(?:\\d+|[xX][0-9a-fA-F]+));)/\n\n    # Escapes HTML entities in `text`, but without escaping an ampersand\n    # that is already part of an escaped entity.\n    #\n    # @param text [String] The string to sanitize\n    # @return [String] The sanitized string\n    def escape_once(text)\n      text = text.to_s\n      text.gsub(HTML_ESCAPE_ONCE_REGEX, HTML_ESCAPE)\n    end\n\n    # Returns whether or not the current template is a Haml template.\n    #\n    # This function, unlike other {Haml::Helpers} functions,\n    # also works in other `ActionView` templates,\n    # where it will always return false.\n    #\n    # @return [Boolean] Whether or not the current template is a Haml template\n    def is_haml?\n      !@haml_buffer.nil? && @haml_buffer.active?\n    end\n\n    # Returns whether or not `block` is defined directly in a Haml template.\n    #\n    # @param block [Proc] A Ruby block\n    # @return [Boolean] Whether or not `block` is defined directly in a Haml template\n    def block_is_haml?(block)\n      eval('!!defined?(_hamlout)', block.binding)\n    end\n\n    private\n\n    # Parses the tag name used for \\{#haml\\_tag}\n    # and merges it with the Ruby attributes hash.\n    def merge_name_and_attributes(name, attributes_hash = {})\n      # skip merging if no ids or classes found in name\n      return name, attributes_hash unless name =~ /^(.+?)?([\\.#].*)$/\n\n      return $1 || \"div\", AttributeBuilder.merge_attributes(\n        Haml::Parser.parse_class_and_id($2), attributes_hash)\n    end\n\n    # Runs a block of code with the given buffer as the currently active buffer.\n    #\n    # @param buffer [Haml::Buffer] The Haml buffer to use temporarily\n    # @yield A block in which the given buffer should be used\n    def with_haml_buffer(buffer)\n      @haml_buffer, old_buffer = buffer, @haml_buffer\n      old_buffer.active, old_was_active = false, old_buffer.active? if old_buffer\n      @haml_buffer.active, was_active = true, @haml_buffer.active?\n      yield\n    ensure\n      @haml_buffer.active = was_active\n      old_buffer.active = old_was_active if old_buffer\n      @haml_buffer = old_buffer\n    end\n\n    # The current {Haml::Buffer} object.\n    #\n    # @return [Haml::Buffer]\n    def haml_buffer\n      @haml_buffer if defined? @haml_buffer\n    end\n\n    # Gives a proc the same local `_hamlout` and `_erbout` variables\n    # that the current template has.\n    #\n    # @param proc [#call] The proc to bind\n    # @return [Proc] A new proc with the new variables bound\n    def haml_bind_proc(&proc)\n      _hamlout = haml_buffer\n      #double assignment is to avoid warnings\n      _erbout = _erbout = _hamlout.buffer\n      proc { |*args| proc.call(*args) }\n    end\n\n    def prettify(text)\n      text = text.split(/^/)\n      text.delete('')\n\n      min_tabs = nil\n      text.each do |line|\n        tabs = line.index(/[^ ]/) || line.length\n        min_tabs ||= tabs\n        min_tabs = min_tabs > tabs ? tabs : min_tabs\n      end\n\n      text.each_with_object('') do |line, str|\n        str << line.slice(min_tabs, line.length)\n      end\n    end\n  end\nend\n\n# @private\nclass Object\n  # Haml overrides various `ActionView` helpers,\n  # which call an \\{#is\\_haml?} method\n  # to determine whether or not the current context object\n  # is a proper Haml context.\n  # Because `ActionView` helpers may be included in non-`ActionView::Base` classes,\n  # it's a good idea to define \\{#is\\_haml?} for all objects.\n  def is_haml?\n    false\n  end\nend\n\n", "# -*- coding: utf-8 -*-\nrequire 'test_helper'\n\nclass EngineTest < Haml::TestCase\n  # A map of erroneous Haml documents to the error messages they should produce.\n  # The error messages may be arrays;\n  # if so, the second element should be the line number that should be reported for the error.\n  # If this isn't provided, the tests will assume the line number should be the last line of the document.\n  EXCEPTION_MAP = {\n    \"!!!\\n  a\"                                             => error(:illegal_nesting_header),\n    \"a\\n  b\"                                               => error(:illegal_nesting_plain),\n    \"/ a\\n  b\"                                             => error(:illegal_nesting_content),\n    \"% a\"                                                  => error(:invalid_tag, '% a'),\n    \"%p a\\n  b\"                                            => error(:illegal_nesting_line, 'p'),\n    \"%p=\"                                                  => error(:no_ruby_code, '='),\n    \"%p~\"                                                  => error(:no_ruby_code, '~'),\n    \"~\"                                                    => error(:no_ruby_code, '~'),\n    \"=\"                                                    => error(:no_ruby_code, '='),\n    \"%p/\\n  a\"                                             => error(:illegal_nesting_self_closing),\n    \":a\\n  b\"                                              => [error(:filter_not_defined, 'a'), 1],\n    \":a= b\"                                                => error(:invalid_filter_name, 'a= b'),\n    \".\"                                                    => error(:illegal_element),\n    \".#\"                                                   => error(:illegal_element),\n    \".{} a\"                                                => error(:illegal_element),\n    \".() a\"                                                => error(:illegal_element),\n    \".= a\"                                                 => error(:illegal_element),\n    \"%p..a\"                                                => error(:illegal_element),\n    \"%a/ b\"                                                => error(:self_closing_content),\n    \" %p foo\"                                              => error(:indenting_at_start),\n    \"  %p foo\"                                             => error(:indenting_at_start),\n    \"- end\"                                                => error(:no_end),\n    \"%p{:a => 'b',\\n:c => 'd'}/ e\"                         => [error(:self_closing_content), 2],\n    \"%p{:a => 'b',\\n:c => 'd'}=\"                           => [error(:no_ruby_code, '='), 2],\n    \"%p.{:a => 'b',\\n:c => 'd'} e\"                         => [error(:illegal_element), 1],\n    \"%p{:a => 'b',\\n:c => 'd',\\n:e => 'f'}\\n%p/ a\"         => [error(:self_closing_content), 4],\n    \"%p{:a => 'b',\\n:c => 'd',\\n:e => 'f'}\\n- raise 'foo'\" => [\"foo\", 4],\n    \"%p{:a => 'b',\\n:c => raise('foo'),\\n:e => 'f'}\"       => [\"foo\", 2],\n    \"%p{:a => 'b',\\n:c => 'd',\\n:e => raise('foo')}\"       => [\"foo\", 3],\n    \" \\n\\t\\n %p foo\"                                       => [error(:indenting_at_start), 3],\n    \"\\n\\n %p foo\"                                          => [error(:indenting_at_start), 3],\n    \"%p\\n  foo\\n foo\"                                      => [error(:inconsistent_indentation, \"1 space\", \"2 spaces\"), 3],\n    \"%p\\n  foo\\n%p\\n foo\"                                  => [error(:inconsistent_indentation, \"1 space\", \"2 spaces\"), 4],\n    \"%p\\n\\t\\tfoo\\n\\tfoo\"                                   => [error(:inconsistent_indentation, \"1 tab\", \"2 tabs\"), 3],\n    \"%p\\n  foo\\n   foo\"                                    => [error(:inconsistent_indentation, \"3 spaces\", \"2 spaces\"), 3],\n    \"%p\\n  foo\\n  %p\\n   bar\"                              => [error(:inconsistent_indentation, \"3 spaces\", \"2 spaces\"), 4],\n    \"%p\\n  :plain\\n     bar\\n   \\t  baz\"                   => [error(:inconsistent_indentation, '\"   \\t  \"', \"2 spaces\"), 4],\n    \"%p\\n  foo\\n%p\\n    bar\"                               => [error(:deeper_indenting, 2), 4],\n    \"%p\\n  foo\\n  %p\\n        bar\"                         => [error(:deeper_indenting, 3), 4],\n    \"%p\\n \\tfoo\"                                           => [error(:cant_use_tabs_and_spaces), 2],\n    \"%p(\"                                                  => error(:invalid_attribute_list, '\"(\"'),\n    \"%p(foo=)\"                                             => error(:invalid_attribute_list, '\"(foo=)\"'),\n    \"%p(foo 'bar')\"                                        => error(:invalid_attribute_list, '\"(foo \\'bar\\')\"'),\n    \"%p(foo=\\nbar)\"                                        => [error(:invalid_attribute_list, '\"(foo=\"'), 1],\n    \"%p(foo 'bar'\\nbaz='bang')\"                            => [error(:invalid_attribute_list, '\"(foo \\'bar\\'\"'), 1],\n    \"%p(foo='bar'\\nbaz 'bang'\\nbip='bop')\"                 => [error(:invalid_attribute_list, '\"(foo=\\'bar\\' baz \\'bang\\'\"'), 2],\n    \"%p{'foo' => 'bar' 'bar' => 'baz'}\"                    => :compile,\n    \"%p{:foo => }\"                                         => :compile,\n    \"%p{=> 'bar'}\"                                         => :compile,\n    \"%p{'foo => 'bar'}\"                                    => :compile,\n    \"%p{:foo => 'bar}\"                                     => :compile,\n    \"%p{:foo => 'bar\\\"}\"                                   => :compile,\n    # Regression tests\n    \"foo\\n\\n\\n  bar\"                                       => [error(:illegal_nesting_plain), 4],\n    \"%p/\\n\\n  bar\"                                         => [error(:illegal_nesting_self_closing), 3],\n    \"%p foo\\n\\n  bar\"                                      => [error(:illegal_nesting_line, 'p'), 3],\n    \"/ foo\\n\\n  bar\"                                       => [error(:illegal_nesting_content), 3],\n    \"!!!\\n\\n  bar\"                                         => [error(:illegal_nesting_header), 3],\n    \"- raise 'foo'\\n\\n\\n\\nbar\"                             => [\"foo\", 1],\n    \"= 'foo'\\n-raise 'foo'\"                                => [\"foo\", 2],\n    \"\\n\\n\\n- raise 'foo'\"                                  => [\"foo\", 4],\n    \"%p foo |\\n   bar |\\n   baz |\\nbop\\n- raise 'foo'\"     => [\"foo\", 5],\n    \"foo\\n:ruby\\n  1\\n  2\\n  3\\n- raise 'foo'\"             => [\"foo\", 6],\n    \"foo\\n:erb\\n  1\\n  2\\n  3\\n- raise 'foo'\"              => [\"foo\", 6],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\n- raise 'foo'\"            => [\"foo\", 6],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\n4\\n- raise 'foo'\"         => [\"foo\", 7],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\#{''}\\n- raise 'foo'\"      => [\"foo\", 6],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\#{''}\\n4\\n- raise 'foo'\"   => [\"foo\", 7],\n    \"foo\\n:plain\\n  1\\n  2\\n  \\#{raise 'foo'}\"             => [\"foo\", 5],\n    \"= raise 'foo'\\nfoo\\nbar\\nbaz\\nbang\"                   => [\"foo\", 1],\n    \"- case 1\\n\\n- when 1\\n  - raise 'foo'\"                => [\"foo\", 4],\n  }\n\n  User = Struct.new('User', :id)\n  class CustomHamlClass < Struct.new(:id)\n    def haml_object_ref\n      \"my_thing\"\n    end\n  end\n  CpkRecord = Struct.new('CpkRecord', :id) do\n    def to_key\n      [*self.id] unless id.nil?\n    end\n  end\n\n  def use_test_tracing(options)\n    unless options[:filename]\n      # use caller method name as fake filename. useful for debugging\n      i = -1\n      caller[i+=1] =~ /`(.+?)'/ until $1 and $1.index('test_') == 0\n      options[:filename] = \"(#{$1})\"\n    end\n    options\n  end\n\n  def render(text, options = {}, &block)\n    options = use_test_tracing(options)\n    options = options.merge(ugly: true)\n    super\n  end\n\n  def engine(text, options = {})\n    options = use_test_tracing(options)\n    Haml::Engine.new(text, options.merge(ugly: true))\n  end\n\n  def setup\n    @old_default_internal = Encoding.default_internal\n    silence_warnings{Encoding.default_internal = nil}\n  end\n\n  def teardown\n    silence_warnings{Encoding.default_internal = @old_default_internal}\n  end\n\n  def test_empty_render\n    assert_equal \"\", render(\"\")\n  end\n\n  def test_flexible_tabulation\n    assert_equal(\"<p>\\nfoo\\n</p>\\n<q>\\nbar\\n<a>\\nbaz\\n</a>\\n</q>\\n\",\n                 render(\"%p\\n foo\\n%q\\n bar\\n %a\\n  baz\"))\n    assert_equal(\"<p>\\nfoo\\n</p>\\n<q>\\nbar\\n<a>\\nbaz\\n</a>\\n</q>\\n\",\n                 render(\"%p\\n\\tfoo\\n%q\\n\\tbar\\n\\t%a\\n\\t\\tbaz\"))\n    assert_equal(\"<p>\\n    \\t \\t bar\\n baz\\n</p>\\n\",\n                 render(\"%p\\n  :plain\\n        \\t \\t bar\\n     baz\"))\n  end\n\n  def test_empty_render_should_remain_empty\n    assert_equal('', render(''))\n  end\n\n  def test_attributes_should_render_correctly\n    assert_equal(\"<div class='atlantis' style='ugly'></div>\", render(\".atlantis{:style => 'ugly'}\").chomp)\n  end\n\n  def test_css_id_as_attribute_should_be_appended_with_underscore\n    assert_equal(\"<div id='my_id_1'></div>\", render(\"#my_id{:id => '1'}\").chomp)\n    assert_equal(\"<div id='my_id_1'></div>\", render(\"#my_id{:id => 1}\").chomp)\n  end\n\n  def test_ruby_code_should_work_inside_attributes\n    assert_equal(\"<p class='3'>foo</p>\", render(\"%p{:class => 1+2} foo\").chomp)\n  end\n\n  def test_class_attr_with_array\n    assert_equal(\"<p class='a b'>foo</p>\\n\", render(\"%p{:class => %w[a b]} foo\")) # basic\n    assert_equal(\"<p class='a b css'>foo</p>\\n\", render(\"%p.css{:class => %w[a b]} foo\")) # merge with css\n    assert_equal(\"<p class='b css'>foo</p>\\n\", render(\"%p.css{:class => %w[css b]} foo\")) # merge uniquely\n    assert_equal(\"<p class='a b c d'>foo</p>\\n\", render(\"%p{:class => [%w[a b], %w[c d]]} foo\")) # flatten\n    assert_equal(\"<p class='a b'>foo</p>\\n\", render(\"%p{:class => [:a, :b] } foo\")) # stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:class => [nil, false] } foo\")) # strip falsey\n    assert_equal(\"<p class='a'>foo</p>\\n\", render(\"%p{:class => :a} foo\")) # single stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:class => false} foo\")) # single falsey\n    assert_equal(\"<p class='a b html'>foo</p>\\n\", render(\"%p(class='html'){:class => %w[a b]} foo\")) # html attrs\n  end\n\n  def test_id_attr_with_array\n    assert_equal(\"<p id='a_b'>foo</p>\\n\", render(\"%p{:id => %w[a b]} foo\")) # basic\n    assert_equal(\"<p id='css_a_b'>foo</p>\\n\", render(\"%p#css{:id => %w[a b]} foo\")) # merge with css\n    assert_equal(\"<p id='a_b_c_d'>foo</p>\\n\", render(\"%p{:id => [%w[a b], %w[c d]]} foo\")) # flatten\n    assert_equal(\"<p id='a_b'>foo</p>\\n\", render(\"%p{:id => [:a, :b] } foo\")) # stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:id => [nil, false] } foo\")) # strip falsey\n    assert_equal(\"<p id='a'>foo</p>\\n\", render(\"%p{:id => :a} foo\")) # single stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:id => false} foo\")) # single falsey\n    assert_equal(\"<p id='html_a_b'>foo</p>\\n\", render(\"%p(id='html'){:id => %w[a b]} foo\")) # html attrs\n  end\n\n  def test_colon_in_class_attr\n    assert_equal(\"<p class='foo:bar'>\\n\", render(\"%p.foo:bar/\"))\n  end\n\n  def test_colon_in_id_attr\n    assert_equal(\"<p id='foo:bar'>\\n\", render(\"%p#foo:bar/\"))\n  end\n\n  def test_dynamic_attributes_with_no_content\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n<a href='http://haml.info'></a>\n</p>\nHTML\n%p\n  %a{:href => \"http://\" + \"haml.info\"}\nHAML\n  end\n\n  def test_attributes_with_to_s\n    assert_equal(<<HTML, render(<<HAML))\n<p id='foo_2'></p>\n<p class='2 foo'></p>\n<p blaz='2'></p>\n<p 2='2'></p>\nHTML\n%p#foo{:id => 1+1}\n%p.foo{:class => 1+1}\n%p{:blaz => 1+1}\n%p{(1+1) => 1+1}\nHAML\n  end\n\n  def test_nil_should_render_empty_tag\n    assert_equal(\"<div class='no_attributes'></div>\",\n                 render(\".no_attributes{:nil => nil}\").chomp)\n  end\n\n  def test_strings_should_get_stripped_inside_tags\n    assert_equal(\"<div class='stripped'>This should have no spaces in front of it</div>\",\n                 render(\".stripped    This should have no spaces in front of it\").chomp)\n  end\n\n  def test_one_liner_should_be_one_line\n    assert_equal(\"<p>Hello</p>\", render('%p Hello').chomp)\n  end\n\n  def test_one_liner_with_newline_shouldnt_be_one_line\n    assert_equal(\"<p>foo\\nbar</p>\", render('%p= \"foo\\nbar\"').chomp)\n  end\n\n  def test_multi_render\n    engine = engine(\"%strong Hi there!\")\n    assert_equal(\"<strong>Hi there!</strong>\\n\", engine.to_html)\n    assert_equal(\"<strong>Hi there!</strong>\\n\", engine.to_html)\n    assert_equal(\"<strong>Hi there!</strong>\\n\", engine.to_html)\n  end\n\n  def test_interpolation\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #{who}', locals: {who: 'World'}, escape_html: false))\n    assert_equal(\"<p>\\nHello World\\n</p>\\n\", render(\"%p\\n  Hello \\#{who}\", locals: {who: 'World'}, escape_html: false))\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #{who}', locals: {who: 'World'}, escape_html: true))\n    assert_equal(\"<p>\\nHello World\\n</p>\\n\", render(\"%p\\n  Hello \\#{who}\", locals: {who: 'World'}, escape_html: true))\n  end\n\n  def test_interpolation_with_instance_var\n    scope = Object.new\n    scope.instance_variable_set(:@who, 'World')\n\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #@who', scope: scope, escape_html: false))\n    assert_equal(\"<p>\\nHello World\\n</p>\\n\", render(\"%p\\n  Hello \\#@who\", scope: scope, escape_html: false))\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #@who', scope: scope, escape_html: true))\n    assert_equal(\"<p>\\nHello World\\n</p>\\n\", render(\"%p\\n  Hello \\#@who\", scope: scope, escape_html: true))\n  end\n\n  def test_interpolation_with_global\n    $global_var_for_testing = 'World'\n\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #$global_var_for_testing', escape_html: false))\n    assert_equal(\"<p>\\nHello World\\n</p>\\n\", render(\"%p\\n  Hello \\#$global_var_for_testing\", escape_html: false))\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #$global_var_for_testing', escape_html: true))\n    assert_equal(\"<p>\\nHello World\\n</p>\\n\", render(\"%p\\n  Hello \\#$global_var_for_testing\", escape_html: true))\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_interpolation_in_the_middle_of_a_string\n    assert_equal(\"\\\"title 'Title'. \\\"\\n\",\n                 render(\"\\\"title '\\#{\\\"Title\\\"}'. \\\"\"))\n  end\n\n  def test_interpolation_with_instance_var_in_the_middle_of_a_string\n    scope = Object.new\n    scope.instance_variable_set(:@title, 'Title')\n\n    assert_equal(\"\\\"title 'Title'. \\\"\\n\",\n                 render(\"\\\"title '\\#@title'. \\\"\",  :scope => scope))\n  end\n\n  def test_interpolation_with_global_in_the_middle_of_a_string\n    $global_var_for_testing = 'Title'\n\n    assert_equal(\"\\\"title 'Title'. \\\"\\n\",\n                 render(\"\\\"title '\\#$global_var_for_testing'. \\\"\"))\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_interpolation_at_the_beginning_of_a_line\n    assert_equal(\"<p>2</p>\\n\", render('%p #{1 + 1}'))\n    assert_equal(\"<p>\\n2\\n</p>\\n\", render(\"%p\\n  \\#{1 + 1}\"))\n  end\n\n  def test_interpolation_with_instance_var_at_the_beginning_of_a_line\n    scope = Object.new\n    scope.instance_variable_set(:@foo, 2)\n\n    assert_equal(\"<p>2</p>\\n\", render('%p #@foo', :scope => scope))\n    assert_equal(\"<p>\\n2\\n</p>\\n\", render(\"%p\\n  \\#@foo\", :scope => scope))\n  end\n\n  def test_interpolation_with_global_at_the_beginning_of_a_line\n    $global_var_for_testing = 2\n\n    assert_equal(\"<p>2</p>\\n\", render('%p #$global_var_for_testing'))\n    assert_equal(\"<p>\\n2\\n</p>\\n\", render(\"%p\\n  \\#$global_var_for_testing\"))\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_escaped_interpolation\n    assert_equal(\"<p>Foo &amp; Bar & Baz</p>\\n\", render('%p& Foo #{\"&\"} Bar & Baz'))\n  end\n\n  def test_nil_tag_value_should_render_as_empty\n    assert_equal(\"<p></p>\\n\", render(\"%p= nil\"))\n  end\n\n  def test_tag_with_failed_if_should_render_as_empty\n    assert_equal(\"<p></p>\\n\", render(\"%p= 'Hello' if false\"))\n  end\n\n  def test_static_attributes_with_empty_attr\n    assert_equal(\"<img alt='' src='/foo.png'>\\n\", render(\"%img{:src => '/foo.png', :alt => ''}\"))\n  end\n\n  def test_dynamic_attributes_with_empty_attr\n    assert_equal(\"<img alt='' src='/foo.png'>\\n\", render(\"%img{:width => nil, :src => '/foo.png', :alt => String.new}\"))\n  end\n\n  def test_attribute_hash_with_newlines\n    assert_equal(\"<p a='b' c='d'>foop</p>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd'} foop\"))\n    assert_equal(\"<p a='b' c='d'>\\nfoop\\n</p>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd'}\\n  foop\"))\n    assert_equal(\"<p a='b' c='d'>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd'}/\"))\n    assert_equal(\"<p a='b' c='d' e='f'></p>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd',\\n   :e => 'f'}\"))\n  end\n\n  def test_attr_hashes_not_modified\n    hash = {:color => 'red'}\n    assert_equal(<<HTML, render(<<HAML, :locals => {:hash => hash}))\n<div color='red'></div>\n<div class='special' color='red'></div>\n<div color='red'></div>\nHTML\n%div{hash}\n.special{hash}\n%div{hash}\nHAML\n    assert_equal(hash, {:color => 'red'})\n  end\n\n  def test_ugly_semi_prerendered_tags\n    assert_equal(<<HTML, render(<<HAML, :ugly => true))\n<p a='2'></p>\n<p a='2'>foo</p>\n<p a='2'>\n<p a='2'>foo</p>\n<p a='2'>foo\nbar</p>\n<p a='2'>foo\nbar</p>\n<p a='2'>\nfoo\n</p>\nHTML\n%p{:a => 1 + 1}\n%p{:a => 1 + 1} foo\n%p{:a => 1 + 1}/\n%p{:a => 1 + 1}= \"foo\"\n%p{:a => 1 + 1}= \"foo\\\\nbar\"\n%p{:a => 1 + 1}~ \"foo\\\\nbar\"\n%p{:a => 1 + 1}\n  foo\nHAML\n  end\n\n  def test_end_of_file_multiline\n    assert_equal(\"<p>0</p>\\n<p>1</p>\\n<p>2</p>\\n\", render(\"- for i in (0...3)\\n  %p= |\\n   i |\"))\n  end\n\n  def test_cr_newline\n    assert_equal(\"<p>foo</p>\\n<p>bar</p>\\n<p>baz</p>\\n<p>boom</p>\\n\", render(\"%p foo\\r%p bar\\r\\n%p baz\\n\\r%p boom\"))\n  end\n\n  def test_textareas\n    assert_equal(\"<textarea>Foo\\n  bar\\n   baz</textarea>\\n\",\n                 render('%textarea= \"Foo\\n  bar\\n   baz\"'))\n\n    assert_equal(\"<pre>Foo\\n  bar\\n   baz</pre>\\n\",\n                 render('%pre= \"Foo\\n  bar\\n   baz\"'))\n\n    assert_equal(\"<textarea>#{'a' * 100}</textarea>\\n\",\n                 render(\"%textarea #{'a' * 100}\"))\n\n    assert_equal(\"<p>\\n<textarea>Foo\\nBar\\nBaz</textarea>\\n</p>\\n\", render(<<SOURCE))\n%p\n  %textarea\n    Foo\n    Bar\n    Baz\nSOURCE\n  end\n\n  def test_pre_code\n    assert_equal(<<HTML, render(<<HAML))\n<pre><code>Foo&#x000A;  bar&#x000A;    baz</code></pre>\nHTML\n%pre\n  %code\n    :preserve\n      Foo\n        bar\n          baz\nHAML\n  end\n\n  def test_boolean_attributes\n    assert_equal(\"<p bar baz='true' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => true, :baz => 'true'}\", :format => :html4))\n    assert_equal(\"<p bar='bar' baz='true' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => true, :baz => 'true'}\", :format => :xhtml))\n\n    assert_equal(\"<p baz='false' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => false, :baz => 'false'}\", :format => :html4))\n    assert_equal(\"<p baz='false' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => false, :baz => 'false'}\", :format => :xhtml))\n  end\n\n  def test_nuke_inner_whitespace_in_loops\n    assert_equal(<<HTML, render(<<HAML))\n<ul>foobarbaz</ul>\nHTML\n%ul<\n  - for str in %w[foo bar baz]\n    = str\nHAML\n  end\n\n  def test_both_whitespace_nukes_work_together\n    assert_equal(<<RESULT, render(<<SOURCE))\n<p><q>Foo\nBar</q></p>\nRESULT\n%p\n  %q><= \"Foo\\\\nBar\"\nSOURCE\n  end\n\n  def test_nil_option\n    assert_equal(\"<p foo='bar'></p>\\n\", render('%p{:foo => \"bar\"}', :attr_wrapper => nil))\n  end\n\n  def test_comment_with_crazy_nesting\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nbar\nHTML\nfoo\n-#\n  ul\n    %li{\n  foo\nbar\nHAML\n  end\n\n  # Regression tests\n\n  def test_indentation_after_dynamic_attr_hash\n    assert_equal(<<HTML, render(<<HAML))\n<html>\n<body>\n<img src='test'>\nfoo\nbar\n</body>\n</html>\nHTML\n%html\n  %body\n    %img{:src => 'te'+'st'}\n    = \"foo\\\\nbar\"\nHAML\n  end\n\n  def test_whitespace_nuke_with_both_newlines\n    assert_equal(\"<p>\\nfoo\\n</p>\\n\", render('%p<= \"\\nfoo\\n\"'))\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n<p>\nfoo\n</p>\n</p>\nHTML\n%p\n  %p<= \"\\\\nfoo\\\\n\"\nHAML\n  end\n\n  def test_whitespace_nuke_with_tags_and_else\n    assert_equal(<<HTML, render(<<HAML))\n<a>\n<b>foo</b>\n</a>\nHTML\n%a\n  %b<\n    - if false\n      = \"foo\"\n    - else\n      foo\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\n<a>\n<b>\nfoo\n</b>\n</a>\nHTML\n%a\n  %b\n    - if false\n      = \"foo\"\n    - else\n      foo\nHAML\n  end\n\n  def test_outer_whitespace_nuke_with_empty_script\n    assert_equal(<<HTML, render(<<HAML))\n<p>\nfoo  <a></a></p>\nHTML\n%p\n  foo\n  = \"  \"\n  %a>\nHAML\n  end\n\n  def test_both_case_indentation_work_with_deeply_nested_code\n    result = <<RESULT\n<h2>\nother\n</h2>\nRESULT\n    assert_equal(result, render(<<HAML))\n- case 'other'\n- when 'test'\n  %h2\n    hi\n- when 'other'\n  %h2\n    other\nHAML\n    assert_equal(result, render(<<HAML))\n- case 'other'\n  - when 'test'\n    %h2\n      hi\n  - when 'other'\n    %h2\n      other\nHAML\n  end\n\n  def test_equals_block_with_ugly\n    assert_equal(\"foo\\n\", render(<<HAML, :ugly => true))\n= capture_haml do\n  foo\nHAML\n  end\n\n  def test_plain_equals_with_ugly\n    assert_equal(\"foo\\nbar\\n\", render(<<HAML, :ugly => true))\n= \"foo\"\nbar\nHAML\n  end\n\n  def test_inline_if\n    assert_equal(<<HTML, render(<<HAML))\n<p>One</p>\n<p></p>\n<p>Three</p>\nHTML\n- for name in [\"One\", \"Two\", \"Three\"]\n  %p= name unless name == \"Two\"\nHAML\n  end\n\n  def test_end_with_method_call\n    assert_equal(\"2|3|4b-a-r\", render(<<HAML))\n= [1, 2, 3].map do |i|\n  - i + 1\n- end.join(\"|\")\n= \"bar\".gsub(/./) do |s|\n  - s + \"-\"\n- end.gsub(/-$/) do |s|\n  - ''\nHAML\n  end\n\n  def test_nested_end_with_method_call\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n2|3|4b-a-r</p>\nHTML\n%p\n  = [1, 2, 3].map do |i|\n    - i + 1\n  - end.join(\"|\")\n  = \"bar\".gsub(/./) do |s|\n    - s + \"-\"\n  - end.gsub(/-$/) do |s|\n    - ''\nHAML\n  end\n\n  def test_silent_end_with_stuff\n    assert_equal(<<HTML, render(<<HAML))\ne\nd\nc\nb\na\nHTML\n- str = \"abcde\"\n- if true\n  = str.slice!(-1).chr\n- end until str.empty?\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\n<p>hi!</p>\nHTML\n- if true\n  %p hi!\n- end if \"foo\".gsub(/f/) do\n  - \"z\"\n- end + \"bar\"\nHAML\n  end\n\n  def test_multiline_with_colon_after_filter\n    assert_equal(<<HTML, render(<<HAML))\nFoo\nBar\nHTML\n:plain\n  Foo\n= { :a => \"Bar\",      |\n    :b => \"Baz\" }[:a] |\nHAML\n    assert_equal(<<HTML, render(<<HAML))\n\nBar\nHTML\n:plain\n= { :a => \"Bar\",      |\n    :b => \"Baz\" }[:a] |\nHAML\n  end\n\n  def test_multiline_in_filter\n    assert_equal(<<HTML, render(<<HAML))\nFoo |\nBar |\nBaz\nHTML\n:plain\n  Foo |\n  Bar |\n  Baz\nHAML\n  end\n\n  def test_curly_brace\n    assert_equal(<<HTML, render(<<HAML))\nFoo { Bar\nHTML\n== Foo { Bar\nHAML\n  end\n\n  def test_escape_attrs_false\n    assert_equal(<<HTML, render(<<HAML, :escape_attrs => false))\n<div class='<?php echo \"&quot;\" ?>' id='foo'>\nbar\n</div>\nHTML\n#foo{:class => '<?php echo \"&quot;\" ?>'}\n  bar\nHAML\n  end\n\n  def test_escape_attrs_always\n    assert_equal(<<HTML, render(<<HAML, :escape_attrs => :always))\n<div class='\"&amp;lt;&amp;gt;&amp;amp;\"' id='foo'>\nbar\n</div>\nHTML\n#foo{:class => '\"&lt;&gt;&amp;\"'}\n  bar\nHAML\n  end\n\n  def test_escape_html\n    html = <<HTML\n&amp;\n&\n&amp;\nHTML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n&= \"&\"\n!= \"&\"\n= \"&\"\nHAML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n&~ \"&\"\n!~ \"&\"\n~ \"&\"\nHAML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n& \\#{\"&\"}\n! \\#{\"&\"}\n\\#{\"&\"}\nHAML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n&== \\#{\"&\"}\n!== \\#{\"&\"}\n== \\#{\"&\"}\nHAML\n\n    tag_html = <<HTML\n<p>&amp;</p>\n<p>&</p>\n<p>&amp;</p>\nHTML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p&= \"&\"\n%p!= \"&\"\n%p= \"&\"\nHAML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p&~ \"&\"\n%p!~ \"&\"\n%p~ \"&\"\nHAML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p& \\#{\"&\"}\n%p! \\#{\"&\"}\n%p \\#{\"&\"}\nHAML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p&== \\#{\"&\"}\n%p!== \\#{\"&\"}\n%p== \\#{\"&\"}\nHAML\n  end\n\n  def test_new_attrs_with_hash\n    assert_equal(\"<a href='#'></a>\\n\", render('%a(href=\"#\")'))\n  end\n\n  def test_silent_script_with_hyphen_case\n    assert_equal(\"\", render(\"- a = 'foo-case-bar-case'\"))\n  end\n\n  def test_silent_script_with_hyphen_end\n    assert_equal(\"\", render(\"- a = 'foo-end-bar-end'\"))\n  end\n\n  def test_silent_script_with_hyphen_end_and_block\n    silence_warnings do\n      assert_equal(<<HTML, render(<<HAML))\n<p>foo-end</p>\n<p>bar-end</p>\nHTML\n- (\"foo-end-bar-end\".gsub(/\\\\w+-end/) do |s|\n  %p= s\n- end; nil)\nHAML\n    end\n  end\n\n  def test_if_without_content_and_else\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- if false\n- else\n  foo\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- if true\n  - if false\n  - else\n    foo\nHAML\n  end\n\n  def test_html_attributes_with_hash\n    assert_equal(\"<a href='#' rel='top'>Foo</a>\\n\",\n      render('%a(href=\"#\" rel=\"top\") Foo'))\n    assert_equal(\"<a href='#'>Foo</a>\\n\",\n      render('%a(href=\"#\") #{\"Foo\"}'))\n\n    assert_equal(\"<a href='#\\\"'></a>\\n\", render('%a(href=\"#\\\\\"\")'))\n  end\n\n  def test_case_assigned_to_var\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- var = case 12\n- when 1; \"foo\"\n- when 12; \"bar\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- var = case 12\n- when 1\n  - \"foo\"\n- when 12\n  - \"bar\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- var = case 12\n  - when 1\n    - \"foo\"\n  - when 12\n    - \"bar\"\n= var\nHAML\n  end\n\n  def test_nested_case_assigned_to_var\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- if true\n  - var = case 12\n  - when 1; \"foo\"\n  - when 12; \"bar\"\n  = var\nHAML\n  end\n\n  def test_case_assigned_to_multiple_vars\n    assert_equal(<<HTML, render(<<HAML))\nbar\nbip\nHTML\n- var, vip = case 12\n- when 1; [\"foo\", \"baz\"]\n- when 12; [\"bar\", \"bip\"]\n= var\n= vip\nHAML\n  end\n\n  def test_if_assigned_to_var\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- var = if false\n- else\n  - \"foo\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- var = if false\n- elsif 12 == 12\n  - \"foo\"\n- elsif 14 == 14; \"bar\"\n- else\n  - \"baz\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- var = if false\n  - \"bar\"\n- else\n  - \"foo\"\n= var\nHAML\n  end\n\n  def test_case_with_newline_after_case\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- case 1\n\n  - when 1\n    foo\n  - when 2\n    bar\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- case 2\n\n- when 1\n  foo\n- when 2\n  bar\nHAML\n  end\n\n  def test_escape_html_with_interpolated_if_statement\n    assert_equal(<<HTML, render(<<HAML, :escape_html => true))\nfoo,\nHTML\nfoo\\#{\",\" if true}\nHAML\n  end\n\n  # HTML escaping tests\n\n  def test_ampersand_equals_should_escape\n    assert_equal(\"<p>\\nfoo &amp; bar\\n</p>\\n\", render(\"%p\\n  &= 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_ampersand_equals_inline_should_escape\n    assert_equal(\"<p>foo &amp; bar</p>\\n\", render(\"%p&= 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_ampersand_equals_should_escape_before_preserve\n    assert_equal(\"<textarea>foo\\nbar</textarea>\\n\", render('%textarea&= \"foo\\nbar\"', :escape_html => false))\n  end\n\n  def test_bang_equals_should_not_escape\n    assert_equal(\"<p>\\nfoo & bar\\n</p>\\n\", render(\"%p\\n  != 'foo & bar'\", :escape_html => true))\n  end\n\n  def test_bang_equals_inline_should_not_escape\n    assert_equal(\"<p>foo & bar</p>\\n\", render(\"%p!= 'foo & bar'\", :escape_html => true))\n  end\n\n  def test_static_attributes_should_be_escaped\n    assert_equal(\"<img class='atlantis' style='ugly&amp;stupid'>\\n\",\n                 render(\"%img.atlantis{:style => 'ugly&stupid'}\"))\n    assert_equal(\"<div class='atlantis' style='ugly&amp;stupid'>foo</div>\\n\",\n                 render(\".atlantis{:style => 'ugly&stupid'} foo\"))\n    assert_equal(\"<p class='atlantis' style='ugly&amp;stupid'>foo</p>\\n\",\n                render(\"%p.atlantis{:style => 'ugly&stupid'}= 'foo'\"))\n    assert_equal(\"<p class='atlantis' style='ugly&#x000A;stupid'></p>\\n\",\n                render(\"%p.atlantis{:style => \\\"ugly\\\\nstupid\\\"}\"))\n  end\n\n  def test_dynamic_attributes_should_be_escaped\n    assert_equal(\"<img alt='' src='&amp;foo.png'>\\n\",\n                 render(\"%img{:width => nil, :src => '&foo.png', :alt => String.new}\"))\n    assert_equal(\"<p alt='' src='&amp;foo.png'>foo</p>\\n\",\n                 render(\"%p{:width => nil, :src => '&foo.png', :alt => String.new} foo\"))\n    assert_equal(\"<div alt='' src='&amp;foo.png'>foo</div>\\n\",\n                 render(\"%div{:width => nil, :src => '&foo.png', :alt => String.new}= 'foo'\"))\n    assert_equal(\"<img alt='' src='foo&#x000A;.png'>\\n\",\n                 render(\"%img{:width => nil, :src => \\\"foo\\\\n.png\\\", :alt => String.new}\"))\n  end\n\n  def test_string_double_equals_should_be_esaped\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_inline_string_double_equals\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p&== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p&== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_inline_string_double_equals\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p!== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p!== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_string_double_equals\n    assert_equal(\"<p>\\n4&&lt;\\n</p>\\n\", render(\"%p\\n  &== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n4&&lt;\\n</p>\\n\", render(\"%p\\n  &== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_string_double_equals\n    assert_equal(\"<p>\\n4&<\\n</p>\\n\", render(\"%p\\n  !== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n4&<\\n</p>\\n\", render(\"%p\\n  !== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_string_interpolation_should_be_esaped\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_inline_string_interpolation\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p& \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p& \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_inline_string_interpolation\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p! \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p! \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_string_interpolation\n    assert_equal(\"<p>\\n4&&lt;\\n</p>\\n\", render(\"%p\\n  & \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n4&&lt;\\n</p>\\n\", render(\"%p\\n  & \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_string_interpolation_with_no_space\n    assert_equal(\"&lt;br&gt;\\n\", render('&#{\"<br>\"}'))\n    assert_equal(\"<span>&lt;br&gt;</span>\\n\", render('%span&#{\"<br>\"}'))\n  end\n\n  def test_unescaped_string_interpolation\n    assert_equal(\"<p>\\n4&<\\n</p>\\n\", render(\"%p\\n  ! \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n4&<\\n</p>\\n\", render(\"%p\\n  ! \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_string_interpolation_with_no_space\n    assert_equal(\"<br>\\n\", render('!#{\"<br>\"}'))\n    assert_equal(\"<span><br></span>\\n\", render('%span!#{\"<br>\"}'))\n  end\n\n  def test_scripts_should_respect_escape_html_option\n    assert_equal(\"<p>\\nfoo &amp; bar\\n</p>\\n\", render(\"%p\\n  = 'foo & bar'\", :escape_html => true))\n    assert_equal(\"<p>\\nfoo & bar\\n</p>\\n\", render(\"%p\\n  = 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_inline_scripts_should_respect_escape_html_option\n    assert_equal(\"<p>foo &amp; bar</p>\\n\", render(\"%p= 'foo & bar'\", :escape_html => true))\n    assert_equal(\"<p>foo & bar</p>\\n\", render(\"%p= 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_script_ending_in_comment_should_render_when_html_is_escaped\n    assert_equal(\"foo&amp;bar\\n\", render(\"= 'foo&bar' #comment\", :escape_html => true))\n  end\n\n  def test_script_with_if_shouldnt_output\n    assert_equal(<<HTML, render(<<HAML))\n<p>foo</p>\n<p></p>\nHTML\n%p= \"foo\"\n%p= \"bar\" if false\nHAML\n  end\n\n  # Options tests\n\n  def test_filename_and_line\n    begin\n      render(\"\\n\\n = abc\", :filename => 'test', :line => 2)\n    rescue Exception => e\n      assert_kind_of Haml::SyntaxError, e\n      assert_match(/test:4/, e.backtrace.first)\n    end\n\n    begin\n      render(\"\\n\\n= 123\\n\\n= nil[]\", :filename => 'test', :line => 2)\n    rescue Exception => e\n      assert_kind_of NoMethodError, e\n      backtrace = e.backtrace\n      backtrace.shift if rubinius?\n      assert_match(/test:6/, backtrace.first)\n    end\n  end\n\n  def test_stop_eval\n    assert_equal(\"\", render(\"= 'Hello'\", :suppress_eval => true))\n    assert_equal(\"\", render(\"- haml_concat 'foo'\", :suppress_eval => true))\n    assert_equal(\"<div id='foo' yes='no'>\\n\", render(\"#foo{:yes => 'no'}/\", :suppress_eval => true))\n    assert_equal(\"<div id='foo'>\\n\", render(\"#foo{:yes => 'no', :call => a_function() }/\", :suppress_eval => true))\n    assert_equal(\"<div>\\n\", render(\"%div[1]/\", :suppress_eval => true))\n    assert_equal(\"\", render(\":ruby\\n  Kernel.puts 'hello'\", :suppress_eval => true))\n  end\n\n  def test_doctypes\n    assert_equal('<!DOCTYPE html>',\n      render('!!!', :format => :html5).strip)\n    assert_equal('<!DOCTYPE html>', render('!!! 5').strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">',\n      render('!!! strict', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">',\n      render('!!! frameset', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\">',\n      render('!!! mobile', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">',\n      render('!!! basic', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">',\n      render('!!! transitional', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">',\n      render('!!!', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">',\n      render('!!! strict', :format => :html4).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">',\n      render('!!! frameset', :format => :html4).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">',\n      render('!!! transitional', :format => :html4).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">',\n      render('!!!', :format => :html4).strip)\n  end\n\n  def test_attr_wrapper\n    assert_equal(\"<p strange=*attrs*></p>\\n\", render(\"%p{ :strange => 'attrs'}\", :attr_wrapper => '*'))\n    assert_equal(\"<p escaped='quo\\\"te'></p>\\n\", render(\"%p{ :escaped => 'quo\\\"te'}\", :attr_wrapper => '\"'))\n    assert_equal(\"<p escaped=\\\"quo'te\\\"></p>\\n\", render(\"%p{ :escaped => 'quo\\\\'te'}\", :attr_wrapper => '\"'))\n    assert_equal(\"<p escaped=\\\"q'uo&#x0022;te\\\"></p>\\n\", render(\"%p{ :escaped => 'q\\\\'uo\\\"te'}\", :attr_wrapper => '\"'))\n    assert_equal(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\\n\", render(\"!!! XML\", :attr_wrapper => '\"', :format => :xhtml))\n  end\n\n  def test_autoclose_option\n    assert_equal(\"<flaz foo='bar'>\\n\", render(\"%flaz{:foo => 'bar'}\", :autoclose => [\"flaz\"]))\n    assert_equal(<<HTML, render(<<HAML, :autoclose => [/^flaz/]))\n<flaz>\n<flaznicate>\n<flan></flan>\nHTML\n%flaz\n%flaznicate\n%flan\nHAML\n  end\n\n  def test_attrs_parsed_correctly\n    assert_equal(\"<p boom=>biddly='bar =&gt; baz'></p>\\n\", render(\"%p{'boom=>biddly' => 'bar => baz'}\"))\n    assert_equal(\"<p foo,bar='baz, qux'></p>\\n\", render(\"%p{'foo,bar' => 'baz, qux'}\"))\n    assert_equal(\"<p escaped='quo&#x000A;te'></p>\\n\", render(\"%p{ :escaped => \\\"quo\\\\nte\\\"}\"))\n    assert_equal(\"<p escaped='quo4te'></p>\\n\", render(\"%p{ :escaped => \\\"quo\\#{2 + 2}te\\\"}\"))\n  end\n\n  def test_correct_parsing_with_brackets\n    assert_equal(\"<p class='foo'>{tada} foo</p>\\n\", render(\"%p{:class => 'foo'} {tada} foo\"))\n    assert_equal(\"<p class='foo'>deep {nested { things }}</p>\\n\", render(\"%p{:class => 'foo'} deep {nested { things }}\"))\n    assert_equal(\"<p class='bar foo'>{a { d</p>\\n\", render(\"%p{{:class => 'foo'}, :class => 'bar'} {a { d\"))\n    assert_equal(\"<p foo='bar'>a}</p>\\n\", render(\"%p{:foo => 'bar'} a}\"))\n\n    foo = []\n    foo[0] = Struct.new('Foo', :id).new\n    assert_equal(\"<p class='struct_foo' id='struct_foo_new'>New User]</p>\\n\",\n                 render(\"%p[foo[0]] New User]\", :locals => {:foo => foo}))\n    assert_equal(\"<p class='prefix_struct_foo' id='prefix_struct_foo_new'>New User]</p>\\n\",\n                 render(\"%p[foo[0], :prefix] New User]\", :locals => {:foo => foo}))\n\n    foo[0].id = 1\n    assert_equal(\"<p class='struct_foo' id='struct_foo_1'>New User]</p>\\n\",\n                 render(\"%p[foo[0]] New User]\", :locals => {:foo => foo}))\n    assert_equal(\"<p class='prefix_struct_foo' id='prefix_struct_foo_1'>New User]</p>\\n\",\n                 render(\"%p[foo[0], :prefix] New User]\", :locals => {:foo => foo}))\n  end\n\n  def test_empty_attrs\n    assert_equal(\"<p attr=''>empty</p>\\n\", render(\"%p{ :attr => '' } empty\"))\n    assert_equal(\"<p attr=''>empty</p>\\n\", render(\"%p{ :attr => x } empty\", :locals => {:x => ''}))\n  end\n\n  def test_nil_attrs\n    assert_equal(\"<p>nil</p>\\n\", render(\"%p{ :attr => nil } nil\"))\n    assert_equal(\"<p>nil</p>\\n\", render(\"%p{ :attr => x } nil\", :locals => {:x => nil}))\n  end\n\n  def test_nil_id_with_syntactic_id\n    assert_equal(\"<p id='foo'>nil</p>\\n\", render(\"%p#foo{:id => nil} nil\"))\n    assert_equal(\"<p id='foo_bar'>nil</p>\\n\", render(\"%p#foo{{:id => 'bar'}, :id => nil} nil\"))\n    assert_equal(\"<p id='foo_bar'>nil</p>\\n\", render(\"%p#foo{{:id => nil}, :id => 'bar'} nil\"))\n  end\n\n  def test_nil_class_with_syntactic_class\n    assert_equal(\"<p class='foo'>nil</p>\\n\", render(\"%p.foo{:class => nil} nil\"))\n    assert_equal(\"<p class='bar foo'>nil</p>\\n\", render(\"%p.bar.foo{:class => nil} nil\"))\n    assert_equal(\"<p class='bar foo'>nil</p>\\n\", render(\"%p.foo{{:class => 'bar'}, :class => nil} nil\"))\n    assert_equal(\"<p class='bar foo'>nil</p>\\n\", render(\"%p.foo{{:class => nil}, :class => 'bar'} nil\"))\n  end\n\n  def test_locals\n    assert_equal(\"<p>Paragraph!</p>\\n\", render(\"%p= text\", :locals => { :text => \"Paragraph!\" }))\n  end\n\n  def test_dynamic_attrs_shouldnt_register_as_literal_values\n    assert_equal(\"<p a='b2c'></p>\\n\", render('%p{:a => \"b#{1 + 1}c\"}'))\n    assert_equal(\"<p a='b2c'></p>\\n\", render(\"%p{:a => 'b' + (1 + 1).to_s + 'c'}\"))\n  end\n\n  def test_dynamic_attrs_with_self_closed_tag\n    assert_equal(\"<a b='2'>\\nc\\n\", render(\"%a{'b' => 1 + 1}/\\n= 'c'\\n\"))\n  end\n\n  EXCEPTION_MAP.each do |key, value|\n    define_method(\"test_exception (#{key.inspect})\") do\n      begin\n        silence_warnings do\n          render(key, :filename => \"(test_exception (#{key.inspect}))\")\n        end\n      rescue Exception => err\n        value = [value] unless value.is_a?(Array)\n        expected_message, line_no = value\n        line_no ||= key.split(\"\\n\").length\n\n\n        if expected_message == :compile\n          assert_match(/(compile error|syntax error|unterminated string|expecting)/, err.message, \"Line: #{key}\")\n        else\n          assert_equal(expected_message, err.message, \"Line: #{key}\")\n        end\n\n      else\n        assert(false, \"Exception not raised for\\n#{key}\")\n      end\n    end\n  end\n\n  def test_exception_line\n    render(\"a\\nb\\n!!!\\n  c\\nd\")\n  rescue Haml::SyntaxError => e\n    assert_equal(\"(test_exception_line):4\", e.backtrace[0])\n  else\n    assert(false, '\"a\\nb\\n!!!\\n  c\\nd\" doesn\\'t produce an exception')\n  end\n\n  def test_exception\n    render(\"%p\\n  hi\\n  %a= undefined\\n= 12\")\n  rescue Exception => e\n    backtrace = e.backtrace\n    backtrace.shift if rubinius?\n    assert_match(\"(test_exception):3\", backtrace[0])\n  else\n    # Test failed... should have raised an exception\n    assert(false)\n  end\n\n  def test_compile_error\n    render(\"a\\nb\\n- fee)\\nc\")\n  rescue Exception => e\n    assert_match(/\\(test_compile_error\\):3:/i, e.message)\n    assert_match(/(syntax error|expecting \\$end)/i, e.message)\n  else\n    assert(false, '\"a\\nb\\n- fee)\\nc\" doesn\\'t produce an exception!')\n  end\n\n  def test_unbalanced_brackets\n    render('foo #{1 + 5} foo #{6 + 7 bar #{8 + 9}')\n  rescue Haml::SyntaxError => e\n    assert_equal(Haml::Error.message(:unbalanced_brackets), e.message)\n  end\n\n  def test_single_line_comments_are_interpolated\n    assert_equal(\"<!-- Hello 2 -->\\n\",\n                 render('/ Hello #{1 + 1}'))\n  end\n\n  def test_single_line_comments_are_not_interpolated_with_suppress_eval\n    assert_equal(\"<!--  -->\\n\",\n                 render('/ Hello #{1 + 1}', :suppress_eval => true))\n  end\n\n  def test_single_line_comments_with_interpolation_dont_break_tabulation\n    assert_equal(\"<!-- Hello 2 -->\\nconcatted\\n\",\n                 render(\"/ Hello \\#{1 + 1}\\n- haml_concat 'concatted'\"))\n  end\n\n  def test_balanced_conditional_comments\n    assert_equal(\"<!--[if !(IE 6)|(IE 7)]> Bracket: ] <![endif]-->\\n\",\n                 render(\"/[if !(IE 6)|(IE 7)] Bracket: ]\"))\n  end\n\n  def test_downlevel_revealed_conditional_comments\n    assert_equal(\"<!--[if !IE]><!--> A comment <!--<![endif]-->\\n\",\n                  render(\"/![if !IE] A comment\"))\n  end\n\n  def test_downlevel_revealed_conditional_comments_block\n    assert_equal(\"<!--[if !IE]><!-->\\nA comment\\n<!--<![endif]-->\\n\",\n                  render(\"/![if !IE]\\n  A comment\"))\n  end\n\n  def test_local_assigns_dont_modify_class\n    assert_equal(\"bar\\n\", render(\"= foo\", :locals => {:foo => 'bar'}))\n    assert_nil(defined?(foo))\n  end\n\n  def test_object_ref_with_nil_id\n    user = User.new\n    assert_equal(\"<p class='struct_user' id='struct_user_new'>New User</p>\\n\",\n                 render(\"%p[user] New User\", :locals => {:user => user}))\n  end\n\n  def test_object_ref_before_attrs\n    user = User.new 42\n    assert_equal(\"<p class='struct_user' id='struct_user_42' style='width: 100px;'>New User</p>\\n\",\n                 render(\"%p[user]{:style => 'width: 100px;'} New User\", :locals => {:user => user}))\n  end\n\n  def test_object_ref_with_custom_haml_class\n    custom = CustomHamlClass.new 42\n    assert_equal(\"<p class='my_thing' id='my_thing_42' style='width: 100px;'>My Thing</p>\\n\",\n                 render(\"%p[custom]{:style => 'width: 100px;'} My Thing\", :locals => {:custom => custom}))\n  end\n\n  def test_object_ref_with_multiple_ids\n    cpk_record = CpkRecord.new([42,6,9])\n    assert_equal(\"<p class='struct_cpk_record' id='struct_cpk_record_42_6_9' style='width: 100px;'>CPK Record</p>\\n\",\n                 render(\"%p[cpk_record]{:style => 'width: 100px;'} CPK Record\", :locals => {:cpk_record => cpk_record}))\n  end\n\n  def test_non_literal_attributes\n    assert_equal(\"<p a1='foo' a2='bar' a3='baz'></p>\\n\",\n                 render(\"%p{a2, a1, :a3 => 'baz'}\",\n                        :locals => {:a1 => {:a1 => 'foo'}, :a2 => {:a2 => 'bar'}}))\n  end\n\n  def test_render_should_accept_a_binding_as_scope\n    string = \"This is a string!\"\n    string.instance_variable_set(:@var, \"Instance variable\")\n    b = string.instance_eval do\n      var = \"Local variable\"\n      # Silence unavoidable warning; Ruby doesn't know we're going to use this\n      # later.\n      nil if var\n      binding\n    end\n\n    assert_equal(\"<p>THIS IS A STRING!</p>\\n<p>Instance variable</p>\\n<p>Local variable</p>\\n\",\n                 render(\"%p= upcase\\n%p= @var\\n%p= var\", :scope => b))\n  end\n\n  def test_yield_should_work_with_binding\n    assert_equal(\"12\\nFOO\\n\", render(\"= yield\\n= upcase\", :scope => \"foo\".instance_eval{binding}) { 12 })\n  end\n\n  def test_yield_should_work_with_def_method\n    s = \"foo\"\n    engine(\"= yield\\n= upcase\").def_method(s, :render)\n    assert_equal(\"12\\nFOO\\n\", s.render { 12 })\n  end\n\n  def test_def_method_with_module\n    engine(\"= yield\\n= upcase\").def_method(String, :render_haml)\n    assert_equal(\"12\\nFOO\\n\", \"foo\".render_haml { 12 })\n  end\n\n  def test_def_method_locals\n    obj = Object.new\n    engine(\"%p= foo\\n.bar{:baz => baz}= boom\").def_method(obj, :render, :foo, :baz, :boom)\n    assert_equal(\"<p>1</p>\\n<div baz='2' class='bar'>3</div>\\n\", obj.render(:foo => 1, :baz => 2, :boom => 3))\n  end\n\n  def test_render_proc_locals\n    proc = engine(\"%p= foo\\n.bar{:baz => baz}= boom\").render_proc(Object.new, :foo, :baz, :boom)\n    assert_equal(\"<p>1</p>\\n<div baz='2' class='bar'>3</div>\\n\", proc[:foo => 1, :baz => 2, :boom => 3])\n  end\n\n  def test_render_proc_with_binding\n    assert_equal(\"FOO\\n\", engine(\"= upcase\").render_proc(\"foo\".instance_eval{binding}).call)\n  end\n\n  def test_haml_buffer_gets_reset_even_with_exception\n    scope = Object.new\n    render(\"- raise Haml::Error\", :scope => scope)\n    assert(false, \"Expected exception\")\n  rescue Exception\n    assert_nil(scope.send(:haml_buffer))\n  end\n\n  def test_def_method_haml_buffer_gets_reset_even_with_exception\n    scope = Object.new\n    engine(\"- raise Haml::Error\").def_method(scope, :render)\n    scope.render\n    assert(false, \"Expected exception\")\n  rescue Exception\n    assert_nil(scope.send(:haml_buffer))\n  end\n\n  def test_render_proc_haml_buffer_gets_reset_even_with_exception\n    scope = Object.new\n    proc = engine(\"- raise Haml::Error\").render_proc(scope)\n    proc.call\n    assert(false, \"Expected exception\")\n  rescue Exception\n    assert_nil(scope.send(:haml_buffer))\n  end\n\n  def test_render_proc_should_raise_haml_syntax_error_not_ruby_syntax_error\n    assert_raises(Haml::SyntaxError) do\n      Haml::Engine.new(\"%p{:foo => !}\").render_proc(Object.new, :foo).call\n    end\n  end\n\n  def test_render_should_raise_haml_syntax_error_not_ruby_syntax_error\n    assert_raises(Haml::SyntaxError) do\n      Haml::Engine.new(\"%p{:foo => !}\").render\n    end\n  end\n\n  def test_ugly_true\n    assert_equal(\"<div id='outer'>\\n<div id='inner'>\\n<p>hello world</p>\\n</div>\\n</div>\\n\",\n                 render(\"#outer\\n  #inner\\n    %p hello world\", :ugly => true))\n\n    assert_equal(\"<p>#{'s' * 75}</p>\\n\",\n                 render(\"%p #{'s' * 75}\", :ugly => true))\n\n    assert_equal(\"<p>#{'s' * 75}</p>\\n\",\n                 render(\"%p= 's' * 75\", :ugly => true))\n  end\n\n  def test_remove_whitespace_true\n    assert_equal(\"<div id='outer'><div id='inner'><p>hello world</p></div></div>\",\n                 render(\"#outer\\n  #inner\\n    %p hello world\", :remove_whitespace => true))\n    assert_equal(\"<p>hello world<pre>foo   bar\\nbaz</pre></p>\", render(<<HAML, :remove_whitespace => true))\n%p\n  hello world\n  %pre\n    foo   bar\n    baz\nHAML\n    assert_equal(\"<div><span>foo</span> <span>bar</span></div>\",\n                 render('%div <span>foo</span> <span>bar</span>', :remove_whitespace => true))\n  end\n\n  def test_auto_preserve\n    assert_equal(\"<pre>foo\\nbar</pre>\\n\", render('%pre=\"foo\\nbar\"', ugly: true))\n    assert_equal(\"<pre>foo\\nbar</pre>\\n\", render(\"%pre\\n  foo\\n  bar\", ugly: true))\n  end\n\n  def test_xhtml_output_option\n    assert_equal \"<p>\\n<br />\\n</p>\\n\", render(\"%p\\n  %br\", :format => :xhtml)\n    assert_equal \"<a />\\n\", render(\"%a/\", :format => :xhtml)\n  end\n\n  def test_arbitrary_output_option\n    assert_raises_message(Haml::Error, \"Invalid output format :html1\") do\n      engine(\"%br\", :format => :html1)\n    end\n  end\n\n  def test_static_hashes\n    assert_equal(\"<a b='a =&gt; b'></a>\\n\", render(\"%a{:b => 'a => b'}\", :suppress_eval => true))\n    assert_equal(\"<a b='a, b'></a>\\n\", render(\"%a{:b => 'a, b'}\", :suppress_eval => true))\n    assert_equal(\"<a b='a\\tb'></a>\\n\", render('%a{:b => \"a\\tb\"}', :suppress_eval => true))\n    assert_equal(\"<a b='a\\#{foo}b'></a>\\n\", render('%a{:b => \"a\\\\#{foo}b\"}', :suppress_eval => true))\n    assert_equal(\"<a b='#f00'></a>\\n\", render(\"%a{:b => '#f00'}\", :suppress_eval => true))\n  end\n\n  def test_dynamic_hashes_with_suppress_eval\n    assert_equal(\"<a></a>\\n\", render('%a{:b => \"a #{1 + 1} b\", :c => \"d\"}', :suppress_eval => true))\n  end\n\n  def test_interpolates_instance_vars_in_attribute_values\n    scope = Object.new\n    scope.instance_variable_set :@foo, 'bar'\n    assert_equal(\"<a b='a bar b'></a>\\n\", render('%a{:b => \"a #@foo b\"}', :scope => scope))\n  end\n\n  def test_interpolates_global_vars_in_attribute_values\n    # make sure the value isn't just interpolated in during template compilation\n    engine = Haml::Engine.new('%a{:b => \"a #$global_var_for_testing b\"}')\n    $global_var_for_testing = 'bar'\n    assert_equal(\"<a b='a bar b'></a>\\n\", engine.to_html)\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_utf8_attrs\n    assert_equal(\"<a href='h\u00e9llo'></a>\\n\", render(\"%a{:href => 'h\u00e9llo'}\"))\n    assert_equal(\"<a href='h\u00e9llo'></a>\\n\", render(\"%a(href='h\u00e9llo')\"))\n  end\n\n  # HTML 4.0\n\n  def test_html_has_no_self_closing_tags\n    assert_equal \"<p>\\n<br>\\n</p>\\n\", render(\"%p\\n  %br\", :format => :html4)\n    assert_equal \"<br>\\n\", render(\"%br/\", :format => :html4)\n  end\n\n  def test_html_renders_empty_node_with_closing_tag\n    assert_equal \"<div class='foo'></div>\\n\", render(\".foo\", :format => :html4)\n  end\n\n  def test_html_doesnt_add_slash_to_self_closing_tags\n    assert_equal \"<a>\\n\", render(\"%a/\", :format => :html4)\n    assert_equal \"<a foo='2'>\\n\", render(\"%a{:foo => 1 + 1}/\", :format => :html4)\n    assert_equal \"<meta>\\n\", render(\"%meta\", :format => :html4)\n    assert_equal \"<meta foo='2'>\\n\", render(\"%meta{:foo => 1 + 1}\", :format => :html4)\n  end\n\n  def test_html_ignores_xml_prolog_declaration\n    assert_equal \"\", render('!!! XML', :format => :html4)\n  end\n\n  def test_html_has_different_doctype\n    assert_equal %{<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\\n},\n    render('!!!', :format => :html4)\n  end\n\n  # because anything before the doctype triggers quirks mode in IE\n  def test_xml_prolog_and_doctype_dont_result_in_a_leading_whitespace_in_html\n    refute_match(/^\\s+/, render(\"!!! xml\\n!!!\", :format => :html4))\n  end\n\n  # HTML5\n  def test_html5_doctype\n    assert_equal %{<!DOCTYPE html>\\n}, render('!!!', :format => :html5)\n  end\n\n  # HTML5 custom data attributes\n  def test_html5_data_attributes_without_hyphenation\n    assert_equal(\"<div data-author_id='123' data-biz='baz' data-foo='bar'></div>\\n\",\n      render(\"%div{:data => {:author_id => 123, :foo => 'bar', :biz => 'baz'}}\",\n        :hyphenate_data_attrs => false))\n\n    assert_equal(\"<div data-one_plus_one='2'></div>\\n\",\n      render(\"%div{:data => {:one_plus_one => 1+1}}\",\n        :hyphenate_data_attrs => false))\n\n    assert_equal(\"<div data-foo='Here&#x0027;s a \\\"quoteful\\\" string.'></div>\\n\",\n      render(%{%div{:data => {:foo => %{Here's a \"quoteful\" string.}}}},\n        :hyphenate_data_attrs => false)) #'\n  end\n\n  def test_html5_data_attributes_with_hyphens\n    assert_equal(\"<div data-foo-bar='blip'></div>\\n\",\n      render(\"%div{:data => {:foo_bar => 'blip'}}\"))\n    assert_equal(\"<div data-baz='bang' data-foo-bar='blip'></div>\\n\",\n      render(\"%div{:data => {:foo_bar => 'blip', :baz => 'bang'}}\"))\n  end\n\n\tdef test_html5_arbitrary_hash_valued_attributes_with\n    assert_equal(\"<div aria-foo='blip'></div>\\n\",\n      render(\"%div{:aria => {:foo => 'blip'}}\"))\n    assert_equal(\"<div foo-baz='bang'></div>\\n\",\n      render(\"%div{:foo => {:baz => 'bang'}}\"))\n\tend\n\n  def test_arbitrary_attribute_hash_merging\n    assert_equal(%Q{<a aria-baz='qux' aria-foo='bar'></a>\\n}, render(<<-HAML))\n- h1 = {:aria => {:foo => :bar}}\n- h2 = {:baz => :qux}\n%a{h1, :aria => h2}\nHAML\n  end\n\n\n  def test_html5_data_attributes_with_nested_hash\n    assert_equal(\"<div data-a-b='c'></div>\\n\", render(<<-HAML))\n- hash = {:a => {:b => 'c'}}\n- hash[:d] = hash\n%div{:data => hash}\nHAML\n  end\n\n  def test_html5_data_attributes_with_nested_hash_and_without_hyphenation\n    assert_equal(\"<div data-a_b='c'></div>\\n\", render(<<-HAML, :hyphenate_data_attrs => false))\n- hash = {:a => {:b => 'c'}}\n- hash[:d] = hash\n%div{:data => hash}\nHAML\n  end\n\n  def test_html5_data_attributes_with_multiple_defs\n    # Should always use the more-explicit attribute\n    assert_equal(\"<div data-foo='second'></div>\\n\",\n      render(\"%div{:data => {:foo => 'first'}, 'data-foo' => 'second'}\"))\n    assert_equal(\"<div data-foo='first'></div>\\n\",\n      render(\"%div{'data-foo' => 'first', :data => {:foo => 'second'}}\"))\n  end\n\n  def test_html5_data_attributes_with_attr_method\n    obj = Object.new\n    def obj.data_hash\n      {:data => {:foo => \"bar\", :baz => \"bang\"}}\n    end\n\n    def obj.data_val\n      {:data => \"dat\"}\n    end\n\n    assert_equal(\"<div data-baz='bang' data-brat='wurst' data-foo='blip'></div>\\n\",\n      render(\"%div{data_hash, :data => {:foo => 'blip', :brat => 'wurst'}}\", scope: obj))\n    assert_equal(\"<div data-baz='bang' data-foo='blip'></div>\\n\",\n      render(\"%div{data_hash, 'data-foo' => 'blip'}\", scope: obj))\n    assert_equal(\"<div data-baz='bang' data-foo='bar' data='dat'></div>\\n\",\n      render(\"%div{data_hash, :data => 'dat'}\", scope: obj))\n    assert_equal(\"<div data-brat='wurst' data-foo='blip' data='dat'></div>\\n\",\n      render(\"%div{data_val, :data => {:foo => 'blip', :brat => 'wurst'}}\", scope: obj))\n  end\n\n  def test_html5_data_attributes_with_identical_attribute_values\n    assert_equal(\"<div data-x='50' data-y='50'></div>\\n\",\n      render(\"%div{:data => {:x => 50, :y => 50}}\"))\n  end\n\n  def test_xml_doc_using_html5_format_and_mime_type\n    assert_equal(<<XML, render(<<HAML, { :format => :html5, :mime_type => 'text/xml' }))\n<?xml version='1.0' encoding='utf-8' ?>\n<root>\n<element />\n<hr />\n</root>\nXML\n!!! XML\n%root\n  %element/\n  %hr\nHAML\n  end\n\n  def test_xml_doc_using_html4_format_and_mime_type\n    assert_equal(<<XML, render(<<HAML, { :format => :html4, :mime_type => 'text/xml' }))\n<?xml version='1.0' encoding='utf-8' ?>\n<root>\n<element />\n<hr />\n</root>\nXML\n!!! XML\n%root\n  %element/\n  %hr\nHAML\n  end\n\n  # New attributes\n\n  def test_basic_new_attributes\n    assert_equal(\"<a>bar</a>\\n\", render(\"%a() bar\"))\n    assert_equal(\"<a href='foo'>bar</a>\\n\", render(\"%a(href='foo') bar\"))\n    assert_equal(\"<a b='c' c='d' d='e'>baz</a>\\n\", render(%q{%a(b=\"c\" c='d' d=\"e\") baz}))\n  end\n\n  def test_new_attribute_ids\n    assert_equal(\"<div id='foo_bar'></div>\\n\", render(\"#foo(id='bar')\"))\n    assert_equal(\"<div id='foo_baz_bar'></div>\\n\", render(\"#foo{:id => 'bar'}(id='baz')\"))\n    assert_equal(\"<div id='foo_baz_bar'></div>\\n\", render(\"#foo(id='baz'){:id => 'bar'}\"))\n    foo = User.new(42)\n    assert_equal(\"<div class='struct_user' id='foo_baz_bar_struct_user_42'></div>\\n\",\n      render(\"#foo(id='baz'){:id => 'bar'}[foo]\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='struct_user' id='foo_baz_bar_struct_user_42'></div>\\n\",\n      render(\"#foo(id='baz')[foo]{:id => 'bar'}\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='struct_user' id='foo_baz_bar_struct_user_42'></div>\\n\",\n      render(\"#foo[foo](id='baz'){:id => 'bar'}\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='struct_user' id='foo_baz_bar_struct_user_42'></div>\\n\",\n      render(\"#foo[foo]{:id => 'bar'}(id='baz')\", :locals => {:foo => foo}))\n  end\n\n  def test_new_attribute_classes\n    assert_equal(\"<div class='bar foo'></div>\\n\", render(\".foo(class='bar')\"))\n    assert_equal(\"<div class='bar baz foo'></div>\\n\", render(\".foo{:class => 'bar'}(class='baz')\"))\n    assert_equal(\"<div class='bar baz foo'></div>\\n\", render(\".foo(class='baz'){:class => 'bar'}\"))\n    foo = User.new(42)\n    assert_equal(\"<div class='bar baz foo struct_user' id='struct_user_42'></div>\\n\",\n      render(\".foo(class='baz'){:class => 'bar'}[foo]\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='bar baz foo struct_user' id='struct_user_42'></div>\\n\",\n      render(\".foo[foo](class='baz'){:class => 'bar'}\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='bar baz foo struct_user' id='struct_user_42'></div>\\n\",\n      render(\".foo[foo]{:class => 'bar'}(class='baz')\", :locals => {:foo => foo}))\n  end\n\n  def test_dynamic_new_attributes\n    assert_equal(\"<a href='12'>bar</a>\\n\", render(\"%a(href=foo) bar\", :locals => {:foo => 12}))\n    assert_equal(\"<a b='12' c='13' d='14'>bar</a>\\n\", render(\"%a(b=b c='13' d=d) bar\", :locals => {:b => 12, :d => 14}))\n  end\n\n  def test_new_attribute_interpolation\n    assert_equal(\"<a href='12'>bar</a>\\n\", render('%a(href=\"1#{1 + 1}\") bar'))\n    assert_equal(\"<a href='2: 2, 3: 3'>bar</a>\\n\", render(%q{%a(href='2: #{1 + 1}, 3: #{foo}') bar}, :locals => {:foo => 3}))\n    assert_equal(%Q{<a href='1\\#{1 + 1}'>bar</a>\\n}, render('%a(href=\"1\\#{1 + 1}\") bar'))\n  end\n\n  def test_truthy_new_attributes\n    assert_equal(\"<a href='href'>bar</a>\\n\", render(\"%a(href) bar\", :format => :xhtml))\n    assert_equal(\"<a bar='baz' href>bar</a>\\n\", render(\"%a(href bar='baz') bar\", :format => :html5))\n    assert_equal(\"<a href>bar</a>\\n\", render(\"%a(href=true) bar\"))\n    assert_equal(\"<a>bar</a>\\n\", render(\"%a(href=false) bar\"))\n  end\n\n  def test_new_attribute_parsing\n    assert_equal(\"<a a2='b2'>bar</a>\\n\", render(\"%a(a2=b2) bar\", :locals => {:b2 => 'b2'}))\n    assert_equal(%Q{<a a='foo\"bar'>bar</a>\\n}, render(%q{%a(a=\"#{'foo\"bar'}\") bar})) #'\n    assert_equal(%Q{<a a=\"foo'bar\">bar</a>\\n}, render(%q{%a(a=\"#{\"foo'bar\"}\") bar})) #'\n    assert_equal(%Q{<a a='foo\"bar'>bar</a>\\n}, render(%q{%a(a='foo\"bar') bar}))\n    assert_equal(%Q{<a a=\"foo'bar\">bar</a>\\n}, render(%q{%a(a=\"foo'bar\") bar}))\n    assert_equal(\"<a a:b='foo'>bar</a>\\n\", render(\"%a(a:b='foo') bar\"))\n    assert_equal(\"<a a='foo' b='bar'>bar</a>\\n\", render(\"%a(a = 'foo' b = 'bar') bar\"))\n    assert_equal(\"<a a='foo' b='bar'>bar</a>\\n\", render(\"%a(a = foo b = bar) bar\", :locals => {:foo => 'foo', :bar => 'bar'}))\n    assert_equal(\"<a a='foo'>(b='bar')</a>\\n\", render(\"%a(a='foo')(b='bar')\"))\n    assert_equal(\"<a a='foo)bar'>baz</a>\\n\", render(\"%a(a='foo)bar') baz\"))\n    assert_equal(\"<a a='foo'>baz</a>\\n\", render(\"%a( a = 'foo' ) baz\"))\n  end\n\n  def test_new_attribute_escaping\n    assert_equal(%Q{<a a='foo \" bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\\" bar\") bar}))\n    assert_equal(%Q{<a a='foo \\\\\" bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\\\\\\\\\\" bar\") bar}))\n\n    assert_equal(%Q{<a a=\"foo ' bar\">bar</a>\\n}, render(%q{%a(a='foo \\' bar') bar}))\n    assert_equal(%Q{<a a=\"foo \\\\' bar\">bar</a>\\n}, render(%q{%a(a='foo \\\\\\\\\\' bar') bar}))\n\n    assert_equal(%Q{<a a='foo \\\\ bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\\\\\\\ bar\") bar}))\n    assert_equal(%Q{<a a='foo \\#{1 + 1} bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\#{1 + 1} bar\") bar}))\n  end\n\n  def test_multiline_new_attribute\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a(a='b'\\n  c='d') bar\"))\n    assert_equal(\"<a a='b' b='c' c='d' d='e' e='f' f='j'>bar</a>\\n\",\n      render(\"%a(a='b' b='c'\\n  c='d' d=e\\n  e='f' f='j') bar\", :locals => {:e => 'e'}))\n  end\n\n  def test_new_and_old_attributes\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a(a='b'){:c => 'd'} bar\"))\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a{:c => 'd'}(a='b') bar\"))\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a(c='d'){:a => 'b'} bar\"))\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a{:a => 'b'}(c='d') bar\"))\n\n    # Old-style always takes precedence over new-style,\n    # because theoretically old-style could have arbitrary end-of-method-call syntax.\n    assert_equal(\"<a a='b'>bar</a>\\n\", render(\"%a{:a => 'b'}(a='d') bar\"))\n    assert_equal(\"<a a='b'>bar</a>\\n\", render(\"%a(a='d'){:a => 'b'} bar\"))\n\n    assert_equal(\"<a a='b' b='c' c='d' d='e'>bar</a>\\n\",\n      render(\"%a{:a => 'b',\\n:b => 'c'}(c='d'\\nd='e') bar\"))\n\n    locals = {:b => 'b', :d => 'd'}\n    assert_equal(\"<p a='b' c='d'></p>\\n\", render(\"%p{:a => b}(c=d)\", :locals => locals))\n    assert_equal(\"<p a='b' c='d'></p>\\n\", render(\"%p(a=b){:c => d}\", :locals => locals))\n\n    assert_equal(\"<p id='b_d'></p>\\n<p id='b_d'></p>\\n\", render(\"%p(id=b){id:d}\\n%p(id=b){id:d}\", locals: locals))\n  end\n\n  # Ruby Multiline\n\n  def test_silent_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\nbar, baz, bang\n<p>foo</p>\nHTML\n- foo = [\"bar\",\n         \"baz\",\n         \"bang\"]\n= foo.join(\", \")\n%p foo\nHAML\n  end\n\n  def test_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\nbar, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n= [\"bar\",\n   \"baz\",\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_with_punctuated_methods_is_continuation\n    assert_equal(<<HTML, render(<<HAML))\nbar, , true, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n= [\"bar\",\n   \"  \".strip!,\n   \"\".empty?,\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_character_literals_are_not_continuation\n    html = \",\\n,\\n<p>foo</p>\\n\"\n    assert_equal(html, render(<<HAML))\n= ?,\n= ?\\,\n%p foo\nHAML\n  end\n\n  def test_escaped_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\nbar&lt;, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n&= [\"bar<\",\n    \"baz\",\n    \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_unescaped_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML, :escape_html => true))\nbar<, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n!= [\"bar<\",\n    \"baz\",\n    \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_flattened_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\n<pre>bar&#x000A;baz&#x000A;bang</pre>\n<p>foo</p>\n<p>bar</p>\nHTML\n~ \"<pre>\" + [\"bar\",\n             \"baz\",\n             \"bang\"].join(\"\\\\n\") + \"</pre>\"\n%p foo\n%p bar\nHAML\n  end\n\n  def test_loud_ruby_multiline_with_block\n    assert_equal(<<HTML, render(<<HAML))\n#{%w[far faz fang]}<p>foo</p>\n<p>bar</p>\nHTML\n= [\"bar\",\n   \"baz\",\n   \"bang\"].map do |str|\n  - str.gsub(\"ba\",\n             \"fa\")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_silent_ruby_multiline_with_block\n    assert_equal(<<HTML, render(<<HAML))\nfar\nfaz\nfang\n<p>foo</p>\n<p>bar</p>\nHTML\n- [\"bar\",\n   \"baz\",\n   \"bang\"].map do |str|\n  = str.gsub(\"ba\",\n             \"fa\")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_in_tag\n    assert_equal(<<HTML, render(<<HAML))\n<p>foo, bar, baz</p>\n<p>foo</p>\n<p>bar</p>\nHTML\n%p= [\"foo\",\n     \"bar\",\n     \"baz\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_escaped_ruby_multiline_in_tag\n    assert_equal(<<HTML, render(<<HAML))\n<p>foo&lt;, bar, baz</p>\n<p>foo</p>\n<p>bar</p>\nHTML\n%p&= [\"foo<\",\n      \"bar\",\n      \"baz\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_unescaped_ruby_multiline_in_tag\n    assert_equal(<<HTML, render(<<HAML, :escape_html => true))\n<p>foo<, bar, baz</p>\n<p>foo</p>\n<p>bar</p>\nHTML\n%p!= [\"foo<\",\n      \"bar\",\n      \"baz\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_with_normal_multiline\n    assert_equal(<<HTML, render(<<HAML))\nfoobarbar, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n= \"foo\" + |\n  \"bar\" + |\n  [\"bar\", |\n   \"baz\",\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_after_filter\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nbar\nbar, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n:plain\n  foo\n  bar\n= [\"bar\",\n   \"baz\",\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  # Encodings\n\n  def test_utf_8_bom\n    assert_equal <<HTML, render(<<HAML)\n<div class='foo'>\n<p>baz</p>\n</div>\nHTML\n\\xEF\\xBB\\xBF.foo\n  %p baz\nHAML\n  end\n\n  def test_default_encoding\n    assert_equal(Encoding.find(\"utf-8\"), render(<<HAML.encode(\"us-ascii\")).encoding)\n%p bar\n%p foo\nHAML\n  end\n\n  def test_fake_ascii_encoding\n    assert_encoded_equal(<<HTML.force_encoding(\"ascii-8bit\"), render(<<HAML, :encoding => \"ascii-8bit\"))\n<p>b\u00e2r</p>\n<p>f\u00f6\u00f6</p>\nHTML\n%p b\u00e2r\n%p f\u00f6\u00f6\nHAML\n  end\n\n  def test_convert_template_render_proc\n    assert_converts_template_properly {|e| e.render_proc.call}\n  end\n\n  def test_convert_template_render\n    assert_converts_template_properly {|e| e.render}\n  end\n\n  def test_convert_template_def_method\n    assert_converts_template_properly do |e|\n      o = Object.new\n      e.def_method(o, :render)\n      o.render\n    end\n  end\n\n  def test_encoding_error\n    render(\"foo\\nbar\\nb\\xFEaz\".force_encoding(\"utf-8\"))\n    assert(false, \"Expected exception\")\n  rescue Haml::Error => e\n    assert_equal(3, e.line)\n    assert_match(/Invalid .* character/, e.message)\n  end\n\n  def test_ascii_incompatible_encoding_error\n    template = \"foo\\nbar\\nb_z\".encode(\"utf-16le\")\n    template[9] = \"\\xFE\".force_encoding(\"utf-16le\")\n    render(template)\n    assert(false, \"Expected exception\")\n  rescue Haml::Error => e\n    assert_equal(3, e.line)\n    assert_match(/Invalid .* character/, e.message)\n  end\n\n  def test_same_coding_comment_as_encoding\n    assert_renders_encoded(<<HTML, <<HAML)\n<p>b\u00e2r</p>\n<p>f\u00f6\u00f6</p>\nHTML\n-# coding: utf-8\n%p b\u00e2r\n%p f\u00f6\u00f6\nHAML\n  end\n\n  def test_coding_comments\n    assert_valid_encoding_comment(\"-# coding: ibm866\")\n    assert_valid_encoding_comment(\"-# CodINg: IbM866\")\n    assert_valid_encoding_comment(\"-#coding:ibm866\")\n    assert_valid_encoding_comment(\"-# CodINg= ibm866\")\n    assert_valid_encoding_comment(\"-# foo BAR FAOJcoding: ibm866\")\n    assert_valid_encoding_comment(\"-# coding: ibm866 ASFJ (&(&#!$\")\n    assert_valid_encoding_comment(\"-# -*- coding: ibm866\")\n    assert_valid_encoding_comment(\"-# coding: ibm866 -*- coding: blah\")\n    assert_valid_encoding_comment(\"-# -*- coding: ibm866 -*-\")\n    assert_valid_encoding_comment(\"-# -*- encoding: ibm866 -*-\")\n    assert_valid_encoding_comment('-# -*- coding: \"ibm866\" -*-')\n    assert_valid_encoding_comment(\"-#-*-coding:ibm866-*-\")\n    assert_valid_encoding_comment(\"-#-*-coding:ibm866-*-\")\n    assert_valid_encoding_comment(\"-# -*- foo: bar; coding: ibm866; baz: bang -*-\")\n    assert_valid_encoding_comment(\"-# foo bar coding: baz -*- coding: ibm866 -*-\")\n    assert_valid_encoding_comment(\"-# -*- coding: ibm866 -*- foo bar coding: baz\")\n  end\n\n  def test_different_coding_than_system\n    assert_renders_encoded(<<HTML.encode(\"IBM866\"), <<HAML.encode(\"IBM866\"))\n<p>\u0442\u0410\u042c</p>\nHTML\n%p \u0442\u0410\u042c\nHAML\n  end\n\n  def test_block_spacing\n    begin\n      assert render(<<-HAML)\n- foo = [\"bar\", \"baz\", \"kni\"]\n- foo.each do | item |\n  = item\nHAML\n    rescue ::SyntaxError\n      flunk(\"Should not have raised syntax error\")\n    end\n  end\n\n  def test_tracing\n    result = render('%p{:class => \"hello\"}', :trace => true, :filename => 'foo').strip\n    assert_equal \"<p class='hello' data-trace='foo:1'></p>\", result\n  end\n\n  private\n\n  def assert_valid_encoding_comment(comment)\n    assert_renders_encoded(<<HTML.encode(\"IBM866\"), <<HAML.encode(\"IBM866\").force_encoding(\"UTF-8\"))\n<p>\u0416\u041b\u042b</p>\n<p>\u0442\u0410\u042c</p>\nHTML\n#{comment}\n%p \u0416\u041b\u042b\n%p \u0442\u0410\u042c\nHAML\n  end\n\n  def assert_converts_template_properly\n    engine = Haml::Engine.new(<<HAML.encode(\"iso-8859-1\"), :encoding => \"macRoman\")\n%p b\u00e2r\n%p f\u00f6\u00f6\nHAML\n    assert_encoded_equal(<<HTML.encode(\"macRoman\"), yield(engine))\n<p>b\u00e2r</p>\n<p>f\u00f6\u00f6</p>\nHTML\n  end\n\n  def assert_renders_encoded(html, haml)\n    result = render(haml)\n    assert_encoded_equal html, result\n  end\n\n  def assert_encoded_equal(expected, actual)\n    assert_equal expected.encoding, actual.encoding\n    assert_equal expected, actual\n  end\nend\n", "# -*- coding: utf-8 -*-\nrequire 'test_helper'\n\nclass PrettyEngineTest < Haml::TestCase\n  # A map of erroneous Haml documents to the error messages they should produce.\n  # The error messages may be arrays;\n  # if so, the second element should be the line number that should be reported for the error.\n  # If this isn't provided, the tests will assume the line number should be the last line of the document.\n  EXCEPTION_MAP = {\n    \"!!!\\n  a\"                                             => error(:illegal_nesting_header),\n    \"a\\n  b\"                                               => error(:illegal_nesting_plain),\n    \"/ a\\n  b\"                                             => error(:illegal_nesting_content),\n    \"% a\"                                                  => error(:invalid_tag, '% a'),\n    \"%p a\\n  b\"                                            => error(:illegal_nesting_line, 'p'),\n    \"%p=\"                                                  => error(:no_ruby_code, '='),\n    \"%p~\"                                                  => error(:no_ruby_code, '~'),\n    \"~\"                                                    => error(:no_ruby_code, '~'),\n    \"=\"                                                    => error(:no_ruby_code, '='),\n    \"%p/\\n  a\"                                             => error(:illegal_nesting_self_closing),\n    \":a\\n  b\"                                              => [error(:filter_not_defined, 'a'), 1],\n    \":a= b\"                                                => error(:invalid_filter_name, 'a= b'),\n    \".\"                                                    => error(:illegal_element),\n    \".#\"                                                   => error(:illegal_element),\n    \".{} a\"                                                => error(:illegal_element),\n    \".() a\"                                                => error(:illegal_element),\n    \".= a\"                                                 => error(:illegal_element),\n    \"%p..a\"                                                => error(:illegal_element),\n    \"%a/ b\"                                                => error(:self_closing_content),\n    \" %p foo\"                                              => error(:indenting_at_start),\n    \"  %p foo\"                                             => error(:indenting_at_start),\n    \"- end\"                                                => error(:no_end),\n    \"%p{:a => 'b',\\n:c => 'd'}/ e\"                         => [error(:self_closing_content), 2],\n    \"%p{:a => 'b',\\n:c => 'd'}=\"                           => [error(:no_ruby_code, '='), 2],\n    \"%p.{:a => 'b',\\n:c => 'd'} e\"                         => [error(:illegal_element), 1],\n    \"%p{:a => 'b',\\n:c => 'd',\\n:e => 'f'}\\n%p/ a\"         => [error(:self_closing_content), 4],\n    \"%p{:a => 'b',\\n:c => 'd',\\n:e => 'f'}\\n- raise 'foo'\" => [\"foo\", 4],\n    \"%p{:a => 'b',\\n:c => raise('foo'),\\n:e => 'f'}\"       => [\"foo\", 2],\n    \"%p{:a => 'b',\\n:c => 'd',\\n:e => raise('foo')}\"       => [\"foo\", 3],\n    \" \\n\\t\\n %p foo\"                                       => [error(:indenting_at_start), 3],\n    \"\\n\\n %p foo\"                                          => [error(:indenting_at_start), 3],\n    \"%p\\n  foo\\n foo\"                                      => [error(:inconsistent_indentation, \"1 space\", \"2 spaces\"), 3],\n    \"%p\\n  foo\\n%p\\n foo\"                                  => [error(:inconsistent_indentation, \"1 space\", \"2 spaces\"), 4],\n    \"%p\\n\\t\\tfoo\\n\\tfoo\"                                   => [error(:inconsistent_indentation, \"1 tab\", \"2 tabs\"), 3],\n    \"%p\\n  foo\\n   foo\"                                    => [error(:inconsistent_indentation, \"3 spaces\", \"2 spaces\"), 3],\n    \"%p\\n  foo\\n  %p\\n   bar\"                              => [error(:inconsistent_indentation, \"3 spaces\", \"2 spaces\"), 4],\n    \"%p\\n  :plain\\n     bar\\n   \\t  baz\"                   => [error(:inconsistent_indentation, '\"   \\t  \"', \"2 spaces\"), 4],\n    \"%p\\n  foo\\n%p\\n    bar\"                               => [error(:deeper_indenting, 2), 4],\n    \"%p\\n  foo\\n  %p\\n        bar\"                         => [error(:deeper_indenting, 3), 4],\n    \"%p\\n \\tfoo\"                                           => [error(:cant_use_tabs_and_spaces), 2],\n    \"%p(\"                                                  => error(:invalid_attribute_list, '\"(\"'),\n    \"%p(foo=)\"                                             => error(:invalid_attribute_list, '\"(foo=)\"'),\n    \"%p(foo 'bar')\"                                        => error(:invalid_attribute_list, '\"(foo \\'bar\\')\"'),\n    \"%p(foo=\\nbar)\"                                        => [error(:invalid_attribute_list, '\"(foo=\"'), 1],\n    \"%p(foo 'bar'\\nbaz='bang')\"                            => [error(:invalid_attribute_list, '\"(foo \\'bar\\'\"'), 1],\n    \"%p(foo='bar'\\nbaz 'bang'\\nbip='bop')\"                 => [error(:invalid_attribute_list, '\"(foo=\\'bar\\' baz \\'bang\\'\"'), 2],\n    \"%p{'foo' => 'bar' 'bar' => 'baz'}\"                    => :compile,\n    \"%p{:foo => }\"                                         => :compile,\n    \"%p{=> 'bar'}\"                                         => :compile,\n    \"%p{'foo => 'bar'}\"                                    => :compile,\n    \"%p{:foo => 'bar}\"                                     => :compile,\n    \"%p{:foo => 'bar\\\"}\"                                   => :compile,\n    # Regression tests\n    \"foo\\n\\n\\n  bar\"                                       => [error(:illegal_nesting_plain), 4],\n    \"%p/\\n\\n  bar\"                                         => [error(:illegal_nesting_self_closing), 3],\n    \"%p foo\\n\\n  bar\"                                      => [error(:illegal_nesting_line, 'p'), 3],\n    \"/ foo\\n\\n  bar\"                                       => [error(:illegal_nesting_content), 3],\n    \"!!!\\n\\n  bar\"                                         => [error(:illegal_nesting_header), 3],\n    \"- raise 'foo'\\n\\n\\n\\nbar\"                             => [\"foo\", 1],\n    \"= 'foo'\\n-raise 'foo'\"                                => [\"foo\", 2],\n    \"\\n\\n\\n- raise 'foo'\"                                  => [\"foo\", 4],\n    \"%p foo |\\n   bar |\\n   baz |\\nbop\\n- raise 'foo'\"     => [\"foo\", 5],\n    \"foo\\n:ruby\\n  1\\n  2\\n  3\\n- raise 'foo'\"             => [\"foo\", 6],\n    \"foo\\n:erb\\n  1\\n  2\\n  3\\n- raise 'foo'\"              => [\"foo\", 6],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\n- raise 'foo'\"            => [\"foo\", 6],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\n4\\n- raise 'foo'\"         => [\"foo\", 7],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\#{''}\\n- raise 'foo'\"      => [\"foo\", 6],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\#{''}\\n4\\n- raise 'foo'\"   => [\"foo\", 7],\n    \"foo\\n:plain\\n  1\\n  2\\n  \\#{raise 'foo'}\"             => [\"foo\", 5],\n    \"= raise 'foo'\\nfoo\\nbar\\nbaz\\nbang\"                   => [\"foo\", 1],\n    \"- case 1\\n\\n- when 1\\n  - raise 'foo'\"                => [\"foo\", 4],\n  }\n\n  PrettyUser = Struct.new('PrettyUser', :id)\n  class CustomHamlClass < Struct.new(:id)\n    def haml_object_ref\n      \"my_thing\"\n    end\n  end\n  PrettyCpkRecord = Struct.new('PrettyCpkRecord', :id) do\n    def to_key\n      [*self.id] unless id.nil?\n    end\n  end\n\n  def use_test_tracing(options)\n    unless options[:filename]\n      # use caller method name as fake filename. useful for debugging\n      i = -1\n      caller[i+=1] =~ /`(.+?)'/ until $1 and $1.index('test_') == 0\n      options[:filename] = \"(#{$1})\"\n    end\n    options\n  end\n\n  def render(text, options = {}, &block)\n    options = use_test_tracing(options)\n    super\n  end\n\n  def engine(text, options = {})\n    options = use_test_tracing(options)\n    Haml::Engine.new(text, options)\n  end\n\n  def setup\n    @old_default_internal = Encoding.default_internal\n    silence_warnings{Encoding.default_internal = nil}\n  end\n\n  def teardown\n    silence_warnings{Encoding.default_internal = @old_default_internal}\n  end\n\n  def test_empty_render\n    assert_equal \"\", render(\"\")\n  end\n\n  def test_flexible_tabulation\n    assert_equal(\"<p>\\n  foo\\n</p>\\n<q>\\n  bar\\n  <a>\\n    baz\\n  </a>\\n</q>\\n\",\n                 render(\"%p\\n foo\\n%q\\n bar\\n %a\\n  baz\"))\n    assert_equal(\"<p>\\n  foo\\n</p>\\n<q>\\n  bar\\n  <a>\\n    baz\\n  </a>\\n</q>\\n\",\n                 render(\"%p\\n\\tfoo\\n%q\\n\\tbar\\n\\t%a\\n\\t\\tbaz\"))\n    assert_equal(\"<p>\\n      \\t \\t bar\\n   baz\\n</p>\\n\",\n                 render(\"%p\\n  :plain\\n        \\t \\t bar\\n     baz\"))\n  end\n\n  def test_empty_render_should_remain_empty\n    assert_equal('', render(''))\n  end\n\n  def test_attributes_should_render_correctly\n    assert_equal(\"<div class='atlantis' style='ugly'></div>\", render(\".atlantis{:style => 'ugly'}\").chomp)\n  end\n\n  def test_css_id_as_attribute_should_be_appended_with_underscore\n    assert_equal(\"<div id='my_id_1'></div>\", render(\"#my_id{:id => '1'}\").chomp)\n    assert_equal(\"<div id='my_id_1'></div>\", render(\"#my_id{:id => 1}\").chomp)\n  end\n\n  def test_ruby_code_should_work_inside_attributes\n    assert_equal(\"<p class='3'>foo</p>\", render(\"%p{:class => 1+2} foo\").chomp)\n  end\n\n  def test_class_attr_with_array\n    assert_equal(\"<p class='a b'>foo</p>\\n\", render(\"%p{:class => %w[a b]} foo\")) # basic\n    assert_equal(\"<p class='a b css'>foo</p>\\n\", render(\"%p.css{:class => %w[a b]} foo\")) # merge with css\n    assert_equal(\"<p class='b css'>foo</p>\\n\", render(\"%p.css{:class => %w[css b]} foo\")) # merge uniquely\n    assert_equal(\"<p class='a b c d'>foo</p>\\n\", render(\"%p{:class => [%w[a b], %w[c d]]} foo\")) # flatten\n    assert_equal(\"<p class='a b'>foo</p>\\n\", render(\"%p{:class => [:a, :b] } foo\")) # stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:class => [nil, false] } foo\")) # strip falsey\n    assert_equal(\"<p class='a'>foo</p>\\n\", render(\"%p{:class => :a} foo\")) # single stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:class => false} foo\")) # single falsey\n    assert_equal(\"<p class='a b html'>foo</p>\\n\", render(\"%p(class='html'){:class => %w[a b]} foo\")) # html attrs\n  end\n\n  def test_id_attr_with_array\n    assert_equal(\"<p id='a_b'>foo</p>\\n\", render(\"%p{:id => %w[a b]} foo\")) # basic\n    assert_equal(\"<p id='css_a_b'>foo</p>\\n\", render(\"%p#css{:id => %w[a b]} foo\")) # merge with css\n    assert_equal(\"<p id='a_b_c_d'>foo</p>\\n\", render(\"%p{:id => [%w[a b], %w[c d]]} foo\")) # flatten\n    assert_equal(\"<p id='a_b'>foo</p>\\n\", render(\"%p{:id => [:a, :b] } foo\")) # stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:id => [nil, false] } foo\")) # strip falsey\n    assert_equal(\"<p id='a'>foo</p>\\n\", render(\"%p{:id => :a} foo\")) # single stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:id => false} foo\")) # single falsey\n    assert_equal(\"<p id='html_a_b'>foo</p>\\n\", render(\"%p(id='html'){:id => %w[a b]} foo\")) # html attrs\n  end\n\n  def test_colon_in_class_attr\n    assert_equal(\"<p class='foo:bar'>\\n\", render(\"%p.foo:bar/\"))\n  end\n\n  def test_colon_in_id_attr\n    assert_equal(\"<p id='foo:bar'>\\n\", render(\"%p#foo:bar/\"))\n  end\n\n  def test_dynamic_attributes_with_no_content\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n  <a href='http://haml.info'></a>\n</p>\nHTML\n%p\n  %a{:href => \"http://\" + \"haml.info\"}\nHAML\n  end\n\n  def test_attributes_with_to_s\n    assert_equal(<<HTML, render(<<HAML))\n<p id='foo_2'></p>\n<p class='2 foo'></p>\n<p blaz='2'></p>\n<p 2='2'></p>\nHTML\n%p#foo{:id => 1+1}\n%p.foo{:class => 1+1}\n%p{:blaz => 1+1}\n%p{(1+1) => 1+1}\nHAML\n  end\n\n  def test_nil_should_render_empty_tag\n    assert_equal(\"<div class='no_attributes'></div>\",\n                 render(\".no_attributes{:nil => nil}\").chomp)\n  end\n\n  def test_strings_should_get_stripped_inside_tags\n    assert_equal(\"<div class='stripped'>This should have no spaces in front of it</div>\",\n                 render(\".stripped    This should have no spaces in front of it\").chomp)\n  end\n\n  def test_one_liner_should_be_one_line\n    assert_equal(\"<p>Hello</p>\", render('%p Hello').chomp)\n  end\n\n  def test_one_liner_with_newline_shouldnt_be_one_line\n    assert_equal(\"<p>\\n  foo\\n  bar\\n</p>\", render('%p= \"foo\\nbar\"').chomp)\n  end\n\n  def test_multi_render\n    engine = engine(\"%strong Hi there!\")\n    assert_equal(\"<strong>Hi there!</strong>\\n\", engine.to_html)\n    assert_equal(\"<strong>Hi there!</strong>\\n\", engine.to_html)\n    assert_equal(\"<strong>Hi there!</strong>\\n\", engine.to_html)\n  end\n\n  def test_interpolation\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #{who}', locals: {who: 'World'}, escape_html: false))\n    assert_equal(\"<p>\\n  Hello World\\n</p>\\n\", render(\"%p\\n  Hello \\#{who}\", locals: {who: 'World'}, escape_html: false))\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #{who}', locals: {who: 'World'}, escape_html: true))\n    assert_equal(\"<p>\\n  Hello World\\n</p>\\n\", render(\"%p\\n  Hello \\#{who}\", locals: {who: 'World'}, escape_html: true))\n  end\n\n  def test_interpolation_with_instance_var\n    scope = Object.new\n    scope.instance_variable_set(:@who, 'World')\n\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #@who', scope: scope, escape_html: false))\n    assert_equal(\"<p>\\n  Hello World\\n</p>\\n\", render(\"%p\\n  Hello \\#@who\", scope: scope, escape_html: false))\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #@who', scope: scope, escape_html: true))\n    assert_equal(\"<p>\\n  Hello World\\n</p>\\n\", render(\"%p\\n  Hello \\#@who\", scope: scope, escape_html: true))\n  end\n\n  def test_interpolation_with_global\n    $global_var_for_testing = 'World'\n\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #$global_var_for_testing', escape_html: false))\n    assert_equal(\"<p>\\n  Hello World\\n</p>\\n\", render(\"%p\\n  Hello \\#$global_var_for_testing\", escape_html: false))\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #$global_var_for_testing', escape_html: true))\n    assert_equal(\"<p>\\n  Hello World\\n</p>\\n\", render(\"%p\\n  Hello \\#$global_var_for_testing\", escape_html: true))\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_interpolation_in_the_middle_of_a_string\n    assert_equal(\"\\\"title 'Title'. \\\"\\n\",\n                 render(\"\\\"title '\\#{\\\"Title\\\"}'. \\\"\"))\n  end\n\n  def test_interpolation_with_instance_var_in_the_middle_of_a_string\n    scope = Object.new\n    scope.instance_variable_set(:@title, 'Title')\n\n    assert_equal(\"\\\"title 'Title'. \\\"\\n\",\n                 render(\"\\\"title '\\#@title'. \\\"\",  :scope => scope))\n  end\n\n  def test_interpolation_with_global_in_the_middle_of_a_string\n    $global_var_for_testing = 'Title'\n\n    assert_equal(\"\\\"title 'Title'. \\\"\\n\",\n                 render(\"\\\"title '\\#$global_var_for_testing'. \\\"\"))\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_interpolation_at_the_beginning_of_a_line\n    assert_equal(\"<p>2</p>\\n\", render('%p #{1 + 1}'))\n    assert_equal(\"<p>\\n  2\\n</p>\\n\", render(\"%p\\n  \\#{1 + 1}\"))\n  end\n\n  def test_interpolation_with_instance_var_at_the_beginning_of_a_line\n    scope = Object.new\n    scope.instance_variable_set(:@foo, 2)\n\n    assert_equal(\"<p>2</p>\\n\", render('%p #@foo', :scope => scope))\n    assert_equal(\"<p>\\n  2\\n</p>\\n\", render(\"%p\\n  \\#@foo\", :scope => scope))\n  end\n\n  def test_interpolation_with_global_at_the_beginning_of_a_line\n    $global_var_for_testing = 2\n\n    assert_equal(\"<p>2</p>\\n\", render('%p #$global_var_for_testing'))\n    assert_equal(\"<p>\\n  2\\n</p>\\n\", render(\"%p\\n  \\#$global_var_for_testing\"))\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_escaped_interpolation\n    assert_equal(\"<p>Foo &amp; Bar & Baz</p>\\n\", render('%p& Foo #{\"&\"} Bar & Baz'))\n  end\n\n  def test_nil_tag_value_should_render_as_empty\n    assert_equal(\"<p></p>\\n\", render(\"%p= nil\"))\n  end\n\n  def test_tag_with_failed_if_should_render_as_empty\n    assert_equal(\"<p></p>\\n\", render(\"%p= 'Hello' if false\"))\n  end\n\n  def test_static_attributes_with_empty_attr\n    assert_equal(\"<img alt='' src='/foo.png'>\\n\", render(\"%img{:src => '/foo.png', :alt => ''}\"))\n  end\n\n  def test_dynamic_attributes_with_empty_attr\n    assert_equal(\"<img alt='' src='/foo.png'>\\n\", render(\"%img{:width => nil, :src => '/foo.png', :alt => String.new}\"))\n  end\n\n  def test_attribute_hash_with_newlines\n    assert_equal(\"<p a='b' c='d'>foop</p>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd'} foop\"))\n    assert_equal(\"<p a='b' c='d'>\\n  foop\\n</p>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd'}\\n  foop\"))\n    assert_equal(\"<p a='b' c='d'>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd'}/\"))\n    assert_equal(\"<p a='b' c='d' e='f'></p>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd',\\n   :e => 'f'}\"))\n  end\n\n  def test_attr_hashes_not_modified\n    hash = {:color => 'red'}\n    assert_equal(<<HTML, render(<<HAML, :locals => {:hash => hash}))\n<div color='red'></div>\n<div class='special' color='red'></div>\n<div color='red'></div>\nHTML\n%div{hash}\n.special{hash}\n%div{hash}\nHAML\n    assert_equal(hash, {:color => 'red'})\n  end\n\n  def test_ugly_semi_prerendered_tags\n    assert_equal(<<HTML, render(<<HAML, :ugly => true))\n<p a='2'></p>\n<p a='2'>foo</p>\n<p a='2'>\n<p a='2'>foo</p>\n<p a='2'>foo\nbar</p>\n<p a='2'>foo\nbar</p>\n<p a='2'>\nfoo\n</p>\nHTML\n%p{:a => 1 + 1}\n%p{:a => 1 + 1} foo\n%p{:a => 1 + 1}/\n%p{:a => 1 + 1}= \"foo\"\n%p{:a => 1 + 1}= \"foo\\\\nbar\"\n%p{:a => 1 + 1}~ \"foo\\\\nbar\"\n%p{:a => 1 + 1}\n  foo\nHAML\n  end\n\n  def test_end_of_file_multiline\n    assert_equal(\"<p>0</p>\\n<p>1</p>\\n<p>2</p>\\n\", render(\"- for i in (0...3)\\n  %p= |\\n   i |\"))\n  end\n\n  def test_cr_newline\n    assert_equal(\"<p>foo</p>\\n<p>bar</p>\\n<p>baz</p>\\n<p>boom</p>\\n\", render(\"%p foo\\r%p bar\\r\\n%p baz\\n\\r%p boom\"))\n  end\n\n  def test_textareas\n    assert_equal(\"<textarea>Foo&#x000A;  bar&#x000A;   baz</textarea>\\n\",\n                 render('%textarea= \"Foo\\n  bar\\n   baz\"'))\n\n    assert_equal(\"<pre>Foo&#x000A;  bar&#x000A;   baz</pre>\\n\",\n                 render('%pre= \"Foo\\n  bar\\n   baz\"'))\n\n    assert_equal(\"<textarea>#{'a' * 100}</textarea>\\n\",\n                 render(\"%textarea #{'a' * 100}\"))\n\n    assert_equal(\"<p>\\n  <textarea>Foo\\n  Bar\\n  Baz</textarea>\\n</p>\\n\", render(<<SOURCE))\n%p\n  %textarea\n    Foo\n    Bar\n    Baz\nSOURCE\n  end\n\n  def test_pre_code\n    assert_equal(<<HTML, render(<<HAML))\n<pre><code>Foo&#x000A;  bar&#x000A;    baz</code></pre>\nHTML\n%pre\n  %code\n    :preserve\n      Foo\n        bar\n          baz\nHAML\n  end\n\n  def test_boolean_attributes\n    assert_equal(\"<p bar baz='true' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => true, :baz => 'true'}\", :format => :html4))\n    assert_equal(\"<p bar='bar' baz='true' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => true, :baz => 'true'}\", :format => :xhtml))\n\n    assert_equal(\"<p baz='false' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => false, :baz => 'false'}\", :format => :html4))\n    assert_equal(\"<p baz='false' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => false, :baz => 'false'}\", :format => :xhtml))\n  end\n\n  def test_nuke_inner_whitespace_in_loops\n    assert_equal(<<HTML, render(<<HAML))\n<ul>foobarbaz</ul>\nHTML\n%ul<\n  - for str in %w[foo bar baz]\n    = str\nHAML\n  end\n\n  def test_both_whitespace_nukes_work_together\n    assert_equal(<<RESULT, render(<<SOURCE))\n<p><q>Foo\n  Bar</q></p>\nRESULT\n%p\n  %q><= \"Foo\\\\nBar\"\nSOURCE\n  end\n\n  def test_nil_option\n    assert_equal(\"<p foo='bar'></p>\\n\", render('%p{:foo => \"bar\"}', :attr_wrapper => nil))\n  end\n\n  def test_comment_with_crazy_nesting\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nbar\nHTML\nfoo\n-#\n  ul\n    %li{\n  foo\nbar\nHAML\n  end\n\n  # Regression tests\n\n  def test_indentation_after_dynamic_attr_hash\n    assert_equal(<<HTML, render(<<HAML))\n<html>\n  <body>\n    <img src='test'>\n    foo\n    bar\n  </body>\n</html>\nHTML\n%html\n  %body\n    %img{:src => 'te'+'st'}\n    = \"foo\\\\nbar\"\nHAML\n  end\n\n  def test_whitespace_nuke_with_both_newlines\n    assert_equal(\"<p>foo</p>\\n\", render('%p<= \"\\nfoo\\n\"'))\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n  <p>foo</p>\n</p>\nHTML\n%p\n  %p<= \"\\\\nfoo\\\\n\"\nHAML\n  end\n\n  def test_whitespace_nuke_with_tags_and_else\n    assert_equal(<<HTML, render(<<HAML))\n<a>\n  <b>foo</b>\n</a>\nHTML\n%a\n  %b<\n    - if false\n      = \"foo\"\n    - else\n      foo\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\n<a>\n  <b>\n    foo\n  </b>\n</a>\nHTML\n%a\n  %b\n    - if false\n      = \"foo\"\n    - else\n      foo\nHAML\n  end\n\n  def test_outer_whitespace_nuke_with_empty_script\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n  foo<a></a></p>\nHTML\n%p\n  foo\n  = \"  \"\n  %a>\nHAML\n  end\n\n  def test_both_case_indentation_work_with_deeply_nested_code\n    result = <<RESULT\n<h2>\n  other\n</h2>\nRESULT\n    assert_equal(result, render(<<HAML))\n- case 'other'\n- when 'test'\n  %h2\n    hi\n- when 'other'\n  %h2\n    other\nHAML\n    assert_equal(result, render(<<HAML))\n- case 'other'\n  - when 'test'\n    %h2\n      hi\n  - when 'other'\n    %h2\n      other\nHAML\n  end\n\n  def test_equals_block_with_ugly\n    assert_equal(\"foo\\n\", render(<<HAML, :ugly => true))\n= capture_haml do\n  foo\nHAML\n  end\n\n  def test_plain_equals_with_ugly\n    assert_equal(\"foo\\nbar\\n\", render(<<HAML, :ugly => true))\n= \"foo\"\nbar\nHAML\n  end\n\n  def test_inline_if\n    assert_equal(<<HTML, render(<<HAML))\n<p>One</p>\n<p></p>\n<p>Three</p>\nHTML\n- for name in [\"One\", \"Two\", \"Three\"]\n  %p= name unless name == \"Two\"\nHAML\n  end\n\n  def test_end_with_method_call\n    assert_equal(<<HTML, render(<<HAML))\n2|3|4\nb-a-r\nHTML\n= [1, 2, 3].map do |i|\n  - i + 1\n- end.join(\"|\")\n= \"bar\".gsub(/./) do |s|\n  - s + \"-\"\n- end.gsub(/-$/) do |s|\n  - ''\nHAML\n  end\n\n  def test_nested_end_with_method_call\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n  2|3|4\n  b-a-r\n</p>\nHTML\n%p\n  = [1, 2, 3].map do |i|\n    - i + 1\n  - end.join(\"|\")\n  = \"bar\".gsub(/./) do |s|\n    - s + \"-\"\n  - end.gsub(/-$/) do |s|\n    - ''\nHAML\n  end\n\n  def test_silent_end_with_stuff\n    assert_equal(<<HTML, render(<<HAML))\ne\nd\nc\nb\na\nHTML\n- str = \"abcde\"\n- if true\n  = str.slice!(-1).chr\n- end until str.empty?\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\n<p>hi!</p>\nHTML\n- if true\n  %p hi!\n- end if \"foo\".gsub(/f/) do\n  - \"z\"\n- end + \"bar\"\nHAML\n  end\n\n  def test_multiline_with_colon_after_filter\n    assert_equal(<<HTML, render(<<HAML))\nFoo\nBar\nHTML\n:plain\n  Foo\n= { :a => \"Bar\",      |\n    :b => \"Baz\" }[:a] |\nHAML\n    assert_equal(<<HTML, render(<<HAML))\n\nBar\nHTML\n:plain\n= { :a => \"Bar\",      |\n    :b => \"Baz\" }[:a] |\nHAML\n  end\n\n  def test_multiline_in_filter\n    assert_equal(<<HTML, render(<<HAML))\nFoo |\nBar |\nBaz\nHTML\n:plain\n  Foo |\n  Bar |\n  Baz\nHAML\n  end\n\n  def test_curly_brace\n    assert_equal(<<HTML, render(<<HAML))\nFoo { Bar\nHTML\n== Foo { Bar\nHAML\n  end\n\n  def test_escape_attrs_false\n    assert_equal(<<HTML, render(<<HAML, :escape_attrs => false))\n<div class='<?php echo \"&quot;\" ?>' id='foo'>\n  bar\n</div>\nHTML\n#foo{:class => '<?php echo \"&quot;\" ?>'}\n  bar\nHAML\n  end\n\n  def test_escape_attrs_always\n    assert_equal(<<HTML, render(<<HAML, :escape_attrs => :always))\n<div class='\"&amp;lt;&amp;gt;&amp;amp;\"' id='foo'>\n  bar\n</div>\nHTML\n#foo{:class => '\"&lt;&gt;&amp;\"'}\n  bar\nHAML\n  end\n\n  def test_escape_html\n    html = <<HTML\n&amp;\n&\n&amp;\nHTML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n&= \"&\"\n!= \"&\"\n= \"&\"\nHAML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n&~ \"&\"\n!~ \"&\"\n~ \"&\"\nHAML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n& \\#{\"&\"}\n! \\#{\"&\"}\n\\#{\"&\"}\nHAML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n&== \\#{\"&\"}\n!== \\#{\"&\"}\n== \\#{\"&\"}\nHAML\n\n    tag_html = <<HTML\n<p>&amp;</p>\n<p>&</p>\n<p>&amp;</p>\nHTML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p&= \"&\"\n%p!= \"&\"\n%p= \"&\"\nHAML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p&~ \"&\"\n%p!~ \"&\"\n%p~ \"&\"\nHAML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p& \\#{\"&\"}\n%p! \\#{\"&\"}\n%p \\#{\"&\"}\nHAML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p&== \\#{\"&\"}\n%p!== \\#{\"&\"}\n%p== \\#{\"&\"}\nHAML\n  end\n\n  def test_new_attrs_with_hash\n    assert_equal(\"<a href='#'></a>\\n\", render('%a(href=\"#\")'))\n  end\n\n  def test_silent_script_with_hyphen_case\n    assert_equal(\"\", render(\"- a = 'foo-case-bar-case'\"))\n  end\n\n  def test_silent_script_with_hyphen_end\n    assert_equal(\"\", render(\"- a = 'foo-end-bar-end'\"))\n  end\n\n  def test_silent_script_with_hyphen_end_and_block\n    silence_warnings do\n      assert_equal(<<HTML, render(<<HAML))\n<p>foo-end</p>\n<p>bar-end</p>\nHTML\n- (\"foo-end-bar-end\".gsub(/\\\\w+-end/) do |s|\n  %p= s\n- end; nil)\nHAML\n    end\n  end\n\n  def test_if_without_content_and_else\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- if false\n- else\n  foo\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- if true\n  - if false\n  - else\n    foo\nHAML\n  end\n\n  def test_html_attributes_with_hash\n    assert_equal(\"<a href='#' rel='top'>Foo</a>\\n\",\n      render('%a(href=\"#\" rel=\"top\") Foo'))\n    assert_equal(\"<a href='#'>Foo</a>\\n\",\n      render('%a(href=\"#\") #{\"Foo\"}'))\n\n    assert_equal(\"<a href='#\\\"'></a>\\n\", render('%a(href=\"#\\\\\"\")'))\n  end\n\n  def test_case_assigned_to_var\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- var = case 12\n- when 1; \"foo\"\n- when 12; \"bar\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- var = case 12\n- when 1\n  - \"foo\"\n- when 12\n  - \"bar\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- var = case 12\n  - when 1\n    - \"foo\"\n  - when 12\n    - \"bar\"\n= var\nHAML\n  end\n\n  def test_nested_case_assigned_to_var\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- if true\n  - var = case 12\n  - when 1; \"foo\"\n  - when 12; \"bar\"\n  = var\nHAML\n  end\n\n  def test_case_assigned_to_multiple_vars\n    assert_equal(<<HTML, render(<<HAML))\nbar\nbip\nHTML\n- var, vip = case 12\n- when 1; [\"foo\", \"baz\"]\n- when 12; [\"bar\", \"bip\"]\n= var\n= vip\nHAML\n  end\n\n  def test_if_assigned_to_var\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- var = if false\n- else\n  - \"foo\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- var = if false\n- elsif 12 == 12\n  - \"foo\"\n- elsif 14 == 14; \"bar\"\n- else\n  - \"baz\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- var = if false\n  - \"bar\"\n- else\n  - \"foo\"\n= var\nHAML\n  end\n\n  def test_case_with_newline_after_case\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- case 1\n\n  - when 1\n    foo\n  - when 2\n    bar\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- case 2\n\n- when 1\n  foo\n- when 2\n  bar\nHAML\n  end\n\n  def test_escape_html_with_interpolated_if_statement\n    assert_equal(<<HTML, render(<<HAML, :escape_html => true))\nfoo,\nHTML\nfoo\\#{\",\" if true}\nHAML\n  end\n\n  # HTML escaping tests\n\n  def test_ampersand_equals_should_escape\n    assert_equal(\"<p>\\n  foo &amp; bar\\n</p>\\n\", render(\"%p\\n  &= 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_ampersand_equals_inline_should_escape\n    assert_equal(\"<p>foo &amp; bar</p>\\n\", render(\"%p&= 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_ampersand_equals_should_escape_before_preserve\n    assert_equal(\"<textarea>foo&#x000A;bar</textarea>\\n\", render('%textarea&= \"foo\\nbar\"', :escape_html => false))\n  end\n\n  def test_bang_equals_should_not_escape\n    assert_equal(\"<p>\\n  foo & bar\\n</p>\\n\", render(\"%p\\n  != 'foo & bar'\", :escape_html => true))\n  end\n\n  def test_bang_equals_inline_should_not_escape\n    assert_equal(\"<p>foo & bar</p>\\n\", render(\"%p!= 'foo & bar'\", :escape_html => true))\n  end\n\n  def test_static_attributes_should_be_escaped\n    assert_equal(\"<img class='atlantis' style='ugly&amp;stupid'>\\n\",\n                 render(\"%img.atlantis{:style => 'ugly&stupid'}\"))\n    assert_equal(\"<div class='atlantis' style='ugly&amp;stupid'>foo</div>\\n\",\n                 render(\".atlantis{:style => 'ugly&stupid'} foo\"))\n    assert_equal(\"<p class='atlantis' style='ugly&amp;stupid'>foo</p>\\n\",\n                render(\"%p.atlantis{:style => 'ugly&stupid'}= 'foo'\"))\n    assert_equal(\"<p class='atlantis' style='ugly&#x000A;stupid'></p>\\n\",\n                render(\"%p.atlantis{:style => \\\"ugly\\\\nstupid\\\"}\"))\n  end\n\n  def test_dynamic_attributes_should_be_escaped\n    assert_equal(\"<img alt='' src='&amp;foo.png'>\\n\",\n                 render(\"%img{:width => nil, :src => '&foo.png', :alt => String.new}\"))\n    assert_equal(\"<p alt='' src='&amp;foo.png'>foo</p>\\n\",\n                 render(\"%p{:width => nil, :src => '&foo.png', :alt => String.new} foo\"))\n    assert_equal(\"<div alt='' src='&amp;foo.png'>foo</div>\\n\",\n                 render(\"%div{:width => nil, :src => '&foo.png', :alt => String.new}= 'foo'\"))\n    assert_equal(\"<img alt='' src='foo&#x000A;.png'>\\n\",\n                 render(\"%img{:width => nil, :src => \\\"foo\\\\n.png\\\", :alt => String.new}\"))\n  end\n\n  def test_string_double_equals_should_be_esaped\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_inline_string_double_equals\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p&== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p&== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_inline_string_double_equals\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p!== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p!== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_string_double_equals\n    assert_equal(\"<p>\\n  4&&lt;\\n</p>\\n\", render(\"%p\\n  &== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n  4&&lt;\\n</p>\\n\", render(\"%p\\n  &== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_string_double_equals\n    assert_equal(\"<p>\\n  4&<\\n</p>\\n\", render(\"%p\\n  !== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n  4&<\\n</p>\\n\", render(\"%p\\n  !== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_string_interpolation_should_be_esaped\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_inline_string_interpolation\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p& \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p& \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_inline_string_interpolation\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p! \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p! \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_string_interpolation\n    assert_equal(\"<p>\\n  4&&lt;\\n</p>\\n\", render(\"%p\\n  & \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n  4&&lt;\\n</p>\\n\", render(\"%p\\n  & \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_string_interpolation_with_no_space\n    assert_equal(\"&lt;br&gt;\\n\", render('&#{\"<br>\"}'))\n    assert_equal(\"<span>&lt;br&gt;</span>\\n\", render('%span&#{\"<br>\"}'))\n  end\n\n  def test_unescaped_string_interpolation\n    assert_equal(\"<p>\\n  4&<\\n</p>\\n\", render(\"%p\\n  ! \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n  4&<\\n</p>\\n\", render(\"%p\\n  ! \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_string_interpolation_with_no_space\n    assert_equal(\"<br>\\n\", render('!#{\"<br>\"}'))\n    assert_equal(\"<span><br></span>\\n\", render('%span!#{\"<br>\"}'))\n  end\n\n  def test_scripts_should_respect_escape_html_option\n    assert_equal(\"<p>\\n  foo &amp; bar\\n</p>\\n\", render(\"%p\\n  = 'foo & bar'\", :escape_html => true))\n    assert_equal(\"<p>\\n  foo & bar\\n</p>\\n\", render(\"%p\\n  = 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_inline_scripts_should_respect_escape_html_option\n    assert_equal(\"<p>foo &amp; bar</p>\\n\", render(\"%p= 'foo & bar'\", :escape_html => true))\n    assert_equal(\"<p>foo & bar</p>\\n\", render(\"%p= 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_script_ending_in_comment_should_render_when_html_is_escaped\n    assert_equal(\"foo&amp;bar\\n\", render(\"= 'foo&bar' #comment\", :escape_html => true))\n  end\n\n  def test_script_with_if_shouldnt_output\n    assert_equal(<<HTML, render(<<HAML))\n<p>foo</p>\n<p></p>\nHTML\n%p= \"foo\"\n%p= \"bar\" if false\nHAML\n  end\n\n  # Options tests\n\n  def test_filename_and_line\n    begin\n      render(\"\\n\\n = abc\", :filename => 'test', :line => 2)\n    rescue Exception => e\n      assert_kind_of Haml::SyntaxError, e\n      assert_match(/test:4/, e.backtrace.first)\n    end\n\n    begin\n      render(\"\\n\\n= 123\\n\\n= nil[]\", :filename => 'test', :line => 2)\n    rescue Exception => e\n      assert_kind_of NoMethodError, e\n      backtrace = e.backtrace\n      backtrace.shift if rubinius?\n      assert_match(/test:6/, backtrace.first)\n    end\n  end\n\n  def test_stop_eval\n    assert_equal(\"\", render(\"= 'Hello'\", :suppress_eval => true))\n    assert_equal(\"\", render(\"- haml_concat 'foo'\", :suppress_eval => true))\n    assert_equal(\"<div id='foo' yes='no'>\\n\", render(\"#foo{:yes => 'no'}/\", :suppress_eval => true))\n    assert_equal(\"<div id='foo'>\\n\", render(\"#foo{:yes => 'no', :call => a_function() }/\", :suppress_eval => true))\n    assert_equal(\"<div>\\n\", render(\"%div[1]/\", :suppress_eval => true))\n    assert_equal(\"\", render(\":ruby\\n  Kernel.puts 'hello'\", :suppress_eval => true))\n  end\n\n  def test_doctypes\n    assert_equal('<!DOCTYPE html>',\n      render('!!!', :format => :html5).strip)\n    assert_equal('<!DOCTYPE html>', render('!!! 5').strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">',\n      render('!!! strict', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">',\n      render('!!! frameset', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\">',\n      render('!!! mobile', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">',\n      render('!!! basic', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">',\n      render('!!! transitional', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">',\n      render('!!!', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">',\n      render('!!! strict', :format => :html4).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">',\n      render('!!! frameset', :format => :html4).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">',\n      render('!!! transitional', :format => :html4).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">',\n      render('!!!', :format => :html4).strip)\n  end\n\n  def test_attr_wrapper\n    assert_equal(\"<p strange=*attrs*></p>\\n\", render(\"%p{ :strange => 'attrs'}\", :attr_wrapper => '*'))\n    assert_equal(\"<p escaped='quo\\\"te'></p>\\n\", render(\"%p{ :escaped => 'quo\\\"te'}\", :attr_wrapper => '\"'))\n    assert_equal(\"<p escaped=\\\"quo'te\\\"></p>\\n\", render(\"%p{ :escaped => 'quo\\\\'te'}\", :attr_wrapper => '\"'))\n    assert_equal(\"<p escaped=\\\"q'uo&#x0022;te\\\"></p>\\n\", render(\"%p{ :escaped => 'q\\\\'uo\\\"te'}\", :attr_wrapper => '\"'))\n    assert_equal(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\\n\", render(\"!!! XML\", :attr_wrapper => '\"', :format => :xhtml))\n  end\n\n  def test_autoclose_option\n    assert_equal(\"<flaz foo='bar'>\\n\", render(\"%flaz{:foo => 'bar'}\", :autoclose => [\"flaz\"]))\n    assert_equal(<<HTML, render(<<HAML, :autoclose => [/^flaz/]))\n<flaz>\n<flaznicate>\n<flan></flan>\nHTML\n%flaz\n%flaznicate\n%flan\nHAML\n  end\n\n  def test_attrs_parsed_correctly\n    assert_equal(\"<p boom=>biddly='bar =&gt; baz'></p>\\n\", render(\"%p{'boom=>biddly' => 'bar => baz'}\"))\n    assert_equal(\"<p foo,bar='baz, qux'></p>\\n\", render(\"%p{'foo,bar' => 'baz, qux'}\"))\n    assert_equal(\"<p escaped='quo&#x000A;te'></p>\\n\", render(\"%p{ :escaped => \\\"quo\\\\nte\\\"}\"))\n    assert_equal(\"<p escaped='quo4te'></p>\\n\", render(\"%p{ :escaped => \\\"quo\\#{2 + 2}te\\\"}\"))\n  end\n\n  def test_correct_parsing_with_brackets\n    assert_equal(\"<p class='foo'>{tada} foo</p>\\n\", render(\"%p{:class => 'foo'} {tada} foo\"))\n    assert_equal(\"<p class='foo'>deep {nested { things }}</p>\\n\", render(\"%p{:class => 'foo'} deep {nested { things }}\"))\n    assert_equal(\"<p class='bar foo'>{a { d</p>\\n\", render(\"%p{{:class => 'foo'}, :class => 'bar'} {a { d\"))\n    assert_equal(\"<p foo='bar'>a}</p>\\n\", render(\"%p{:foo => 'bar'} a}\"))\n\n    foo = []\n    foo[0] = Struct.new('PrettyFoo', :id).new\n    assert_equal(\"<p class='struct_pretty_foo' id='struct_pretty_foo_new'>New User]</p>\\n\",\n                 render(\"%p[foo[0]] New User]\", :locals => {:foo => foo}))\n    assert_equal(\"<p class='prefix_struct_pretty_foo' id='prefix_struct_pretty_foo_new'>New User]</p>\\n\",\n                 render(\"%p[foo[0], :prefix] New User]\", :locals => {:foo => foo}))\n\n    foo[0].id = 1\n    assert_equal(\"<p class='struct_pretty_foo' id='struct_pretty_foo_1'>New User]</p>\\n\",\n                 render(\"%p[foo[0]] New User]\", :locals => {:foo => foo}))\n    assert_equal(\"<p class='prefix_struct_pretty_foo' id='prefix_struct_pretty_foo_1'>New User]</p>\\n\",\n                 render(\"%p[foo[0], :prefix] New User]\", :locals => {:foo => foo}))\n  end\n\n  def test_empty_attrs\n    assert_equal(\"<p attr=''>empty</p>\\n\", render(\"%p{ :attr => '' } empty\"))\n    assert_equal(\"<p attr=''>empty</p>\\n\", render(\"%p{ :attr => x } empty\", :locals => {:x => ''}))\n  end\n\n  def test_nil_attrs\n    assert_equal(\"<p>nil</p>\\n\", render(\"%p{ :attr => nil } nil\"))\n    assert_equal(\"<p>nil</p>\\n\", render(\"%p{ :attr => x } nil\", :locals => {:x => nil}))\n  end\n\n  def test_nil_id_with_syntactic_id\n    assert_equal(\"<p id='foo'>nil</p>\\n\", render(\"%p#foo{:id => nil} nil\"))\n    assert_equal(\"<p id='foo_bar'>nil</p>\\n\", render(\"%p#foo{{:id => 'bar'}, :id => nil} nil\"))\n    assert_equal(\"<p id='foo_bar'>nil</p>\\n\", render(\"%p#foo{{:id => nil}, :id => 'bar'} nil\"))\n  end\n\n  def test_nil_class_with_syntactic_class\n    assert_equal(\"<p class='foo'>nil</p>\\n\", render(\"%p.foo{:class => nil} nil\"))\n    assert_equal(\"<p class='bar foo'>nil</p>\\n\", render(\"%p.bar.foo{:class => nil} nil\"))\n    assert_equal(\"<p class='bar foo'>nil</p>\\n\", render(\"%p.foo{{:class => 'bar'}, :class => nil} nil\"))\n    assert_equal(\"<p class='bar foo'>nil</p>\\n\", render(\"%p.foo{{:class => nil}, :class => 'bar'} nil\"))\n  end\n\n  def test_locals\n    assert_equal(\"<p>Paragraph!</p>\\n\", render(\"%p= text\", :locals => { :text => \"Paragraph!\" }))\n  end\n\n  def test_dynamic_attrs_shouldnt_register_as_literal_values\n    assert_equal(\"<p a='b2c'></p>\\n\", render('%p{:a => \"b#{1 + 1}c\"}'))\n    assert_equal(\"<p a='b2c'></p>\\n\", render(\"%p{:a => 'b' + (1 + 1).to_s + 'c'}\"))\n  end\n\n  def test_dynamic_attrs_with_self_closed_tag\n    assert_equal(\"<a b='2'>\\nc\\n\", render(\"%a{'b' => 1 + 1}/\\n= 'c'\\n\"))\n  end\n\n  EXCEPTION_MAP.each do |key, value|\n    define_method(\"test_exception (#{key.inspect})\") do\n      begin\n        silence_warnings do\n          render(key, :filename => \"(test_exception (#{key.inspect}))\")\n        end\n      rescue Exception => err\n        value = [value] unless value.is_a?(Array)\n        expected_message, line_no = value\n        line_no ||= key.split(\"\\n\").length\n\n\n        if expected_message == :compile\n          assert_match(/(compile error|syntax error|unterminated string|expecting)/, err.message, \"Line: #{key}\")\n        else\n          assert_equal(expected_message, err.message, \"Line: #{key}\")\n        end\n\n      else\n        assert(false, \"Exception not raised for\\n#{key}\")\n      end\n    end\n  end\n\n  def test_exception_line\n    render(\"a\\nb\\n!!!\\n  c\\nd\")\n  rescue Haml::SyntaxError => e\n    assert_equal(\"(test_exception_line):4\", e.backtrace[0])\n  else\n    assert(false, '\"a\\nb\\n!!!\\n  c\\nd\" doesn\\'t produce an exception')\n  end\n\n  def test_exception\n    render(\"%p\\n  hi\\n  %a= undefined\\n= 12\")\n  rescue Exception => e\n    backtrace = e.backtrace\n    backtrace.shift if rubinius?\n    assert_match(\"(test_exception):3\", backtrace[0])\n  else\n    # Test failed... should have raised an exception\n    assert(false)\n  end\n\n  def test_compile_error\n    render(\"a\\nb\\n- fee)\\nc\")\n  rescue Exception => e\n    assert_match(/\\(test_compile_error\\):3:/i, e.message)\n    assert_match(/(syntax error|expecting \\$end)/i, e.message)\n  else\n    assert(false, '\"a\\nb\\n- fee)\\nc\" doesn\\'t produce an exception!')\n  end\n\n  def test_unbalanced_brackets\n    render('foo #{1 + 5} foo #{6 + 7 bar #{8 + 9}')\n  rescue Haml::SyntaxError => e\n    assert_equal(Haml::Error.message(:unbalanced_brackets), e.message)\n  end\n\n  def test_single_line_comments_are_interpolated\n    assert_equal(\"<!-- Hello 2 -->\\n\",\n                 render('/ Hello #{1 + 1}'))\n  end\n\n  def test_single_line_comments_are_not_interpolated_with_suppress_eval\n    assert_equal(\"<!--  -->\\n\",\n                 render('/ Hello #{1 + 1}', :suppress_eval => true))\n  end\n\n  def test_single_line_comments_with_interpolation_dont_break_tabulation\n    assert_equal(\"<!-- Hello 2 -->\\nconcatted\\n\",\n                 render(\"/ Hello \\#{1 + 1}\\n- haml_concat 'concatted'\"))\n  end\n\n  def test_balanced_conditional_comments\n    assert_equal(\"<!--[if !(IE 6)|(IE 7)]> Bracket: ] <![endif]-->\\n\",\n                 render(\"/[if !(IE 6)|(IE 7)] Bracket: ]\"))\n  end\n\n  def test_downlevel_revealed_conditional_comments\n    assert_equal(\"<!--[if !IE]><!--> A comment <!--<![endif]-->\\n\",\n                  render(\"/![if !IE] A comment\"))\n  end\n\n  def test_downlevel_revealed_conditional_comments_block\n    assert_equal(\"<!--[if !IE]><!-->\\n  A comment\\n<!--<![endif]-->\\n\",\n                  render(\"/![if !IE]\\n  A comment\"))\n  end\n\n  def test_local_assigns_dont_modify_class\n    assert_equal(\"bar\\n\", render(\"= foo\", :locals => {:foo => 'bar'}))\n    assert_nil(defined?(foo))\n  end\n\n  def test_object_ref_with_nil_id\n    user = PrettyUser.new\n    assert_equal(\"<p class='struct_pretty_user' id='struct_pretty_user_new'>New User</p>\\n\",\n                 render(\"%p[user] New User\", :locals => {:user => user}))\n  end\n\n  def test_object_ref_before_attrs\n    user = PrettyUser.new 42\n    assert_equal(\"<p class='struct_pretty_user' id='struct_pretty_user_42' style='width: 100px;'>New User</p>\\n\",\n                 render(\"%p[user]{:style => 'width: 100px;'} New User\", :locals => {:user => user}))\n  end\n\n  def test_object_ref_with_custom_haml_class\n    custom = CustomHamlClass.new 42\n    assert_equal(\"<p class='my_thing' id='my_thing_42' style='width: 100px;'>My Thing</p>\\n\",\n                 render(\"%p[custom]{:style => 'width: 100px;'} My Thing\", :locals => {:custom => custom}))\n  end\n\n  def test_object_ref_with_multiple_ids\n    cpk_record = PrettyCpkRecord.new([42,6,9])\n    assert_equal(\"<p class='struct_pretty_cpk_record' id='struct_pretty_cpk_record_42_6_9' style='width: 100px;'>CPK Record</p>\\n\",\n                 render(\"%p[cpk_record]{:style => 'width: 100px;'} CPK Record\", :locals => {:cpk_record => cpk_record}))\n  end\n\n  def test_non_literal_attributes\n    assert_equal(\"<p a1='foo' a2='bar' a3='baz'></p>\\n\",\n                 render(\"%p{a2, a1, :a3 => 'baz'}\",\n                        :locals => {:a1 => {:a1 => 'foo'}, :a2 => {:a2 => 'bar'}}))\n  end\n\n  def test_render_should_accept_a_binding_as_scope\n    string = \"This is a string!\"\n    string.instance_variable_set(:@var, \"Instance variable\")\n    b = string.instance_eval do\n      var = \"Local variable\"\n      # Silence unavoidable warning; Ruby doesn't know we're going to use this\n      # later.\n      nil if var\n      binding\n    end\n\n    assert_equal(\"<p>THIS IS A STRING!</p>\\n<p>Instance variable</p>\\n<p>Local variable</p>\\n\",\n                 render(\"%p= upcase\\n%p= @var\\n%p= var\", :scope => b))\n  end\n\n  def test_yield_should_work_with_binding\n    assert_equal(\"12\\nFOO\\n\", render(\"= yield\\n= upcase\", :scope => \"foo\".instance_eval{binding}) { 12 })\n  end\n\n  def test_yield_should_work_with_def_method\n    s = \"foo\"\n    engine(\"= yield\\n= upcase\").def_method(s, :render)\n    assert_equal(\"12\\nFOO\\n\", s.render { 12 })\n  end\n\n  def test_render_proc_locals\n    proc = engine(\"%p= foo\\n.bar{:baz => baz}= boom\").render_proc(Object.new, :foo, :baz, :boom)\n    assert_equal(\"<p>1</p>\\n<div baz='2' class='bar'>3</div>\\n\", proc[:foo => 1, :baz => 2, :boom => 3])\n  end\n\n  def test_render_proc_with_binding\n    assert_equal(\"FOO\\n\", engine(\"= upcase\").render_proc(\"foo\".instance_eval{binding}).call)\n  end\n\n  def test_haml_buffer_gets_reset_even_with_exception\n    scope = Object.new\n    render(\"- raise Haml::Error\", :scope => scope)\n    assert(false, \"Expected exception\")\n  rescue Exception\n    assert_nil(scope.send(:haml_buffer))\n  end\n\n  def test_def_method_haml_buffer_gets_reset_even_with_exception\n    scope = Object.new\n    engine(\"- raise Haml::Error\").def_method(scope, :render)\n    scope.render\n    assert(false, \"Expected exception\")\n  rescue Exception\n    assert_nil(scope.send(:haml_buffer))\n  end\n\n  def test_render_proc_haml_buffer_gets_reset_even_with_exception\n    scope = Object.new\n    proc = engine(\"- raise Haml::Error\").render_proc(scope)\n    proc.call\n    assert(false, \"Expected exception\")\n  rescue Exception\n    assert_nil(scope.send(:haml_buffer))\n  end\n\n  def test_render_proc_should_raise_haml_syntax_error_not_ruby_syntax_error\n    assert_raises(Haml::SyntaxError) do\n      Haml::Engine.new(\"%p{:foo => !}\").render_proc(Object.new, :foo).call\n    end\n  end\n\n  def test_render_should_raise_haml_syntax_error_not_ruby_syntax_error\n    assert_raises(Haml::SyntaxError) do\n      Haml::Engine.new(\"%p{:foo => !}\").render\n    end\n  end\n\n  def test_ugly_true\n    assert_equal(\"<div id='outer'>\\n<div id='inner'>\\n<p>hello world</p>\\n</div>\\n</div>\\n\",\n                 render(\"#outer\\n  #inner\\n    %p hello world\", :ugly => true))\n\n    assert_equal(\"<p>#{'s' * 75}</p>\\n\",\n                 render(\"%p #{'s' * 75}\", :ugly => true))\n\n    assert_equal(\"<p>#{'s' * 75}</p>\\n\",\n                 render(\"%p= 's' * 75\", :ugly => true))\n  end\n\n  def test_remove_whitespace_true\n    assert_equal(\"<div id='outer'><div id='inner'><p>hello world</p></div></div>\",\n                 render(\"#outer\\n  #inner\\n    %p hello world\", :remove_whitespace => true))\n    assert_equal(\"<p>hello world<pre>foo   bar\\nbaz</pre></p>\", render(<<HAML, :remove_whitespace => true))\n%p\n  hello world\n  %pre\n    foo   bar\n    baz\nHAML\n    assert_equal(\"<div><span>foo</span> <span>bar</span></div>\",\n                 render('%div <span>foo</span> <span>bar</span>', :remove_whitespace => true))\n  end\n\n  def test_auto_preserve_unless_ugly\n    assert_equal(\"<pre>foo&#x000A;bar</pre>\\n\", render('%pre=\"foo\\nbar\"'))\n    assert_equal(\"<pre>foo\\nbar</pre>\\n\", render(\"%pre\\n  foo\\n  bar\"))\n    assert_equal(\"<pre>foo\\nbar</pre>\\n\", render('%pre=\"foo\\nbar\"', :ugly => true))\n    assert_equal(\"<pre>foo\\nbar</pre>\\n\", render(\"%pre\\n  foo\\n  bar\", :ugly => true))\n  end\n\n  def test_xhtml_output_option\n    assert_equal \"<p>\\n  <br />\\n</p>\\n\", render(\"%p\\n  %br\", :format => :xhtml)\n    assert_equal \"<a />\\n\", render(\"%a/\", :format => :xhtml)\n  end\n\n  def test_arbitrary_output_option\n    assert_raises_message(Haml::Error, \"Invalid output format :html1\") do\n      engine(\"%br\", :format => :html1)\n    end\n  end\n\n  def test_static_hashes\n    assert_equal(\"<a b='a =&gt; b'></a>\\n\", render(\"%a{:b => 'a => b'}\", :suppress_eval => true))\n    assert_equal(\"<a b='a, b'></a>\\n\", render(\"%a{:b => 'a, b'}\", :suppress_eval => true))\n    assert_equal(\"<a b='a\\tb'></a>\\n\", render('%a{:b => \"a\\tb\"}', :suppress_eval => true))\n    assert_equal(\"<a b='a\\#{foo}b'></a>\\n\", render('%a{:b => \"a\\\\#{foo}b\"}', :suppress_eval => true))\n    assert_equal(\"<a b='#f00'></a>\\n\", render(\"%a{:b => '#f00'}\", :suppress_eval => true))\n  end\n\n  def test_dynamic_hashes_with_suppress_eval\n    assert_equal(\"<a></a>\\n\", render('%a{:b => \"a #{1 + 1} b\", :c => \"d\"}', :suppress_eval => true))\n  end\n\n  def test_interpolates_instance_vars_in_attribute_values\n    scope = Object.new\n    scope.instance_variable_set :@foo, 'bar'\n    assert_equal(\"<a b='a bar b'></a>\\n\", render('%a{:b => \"a #@foo b\"}', :scope => scope))\n  end\n\n  def test_interpolates_global_vars_in_attribute_values\n    # make sure the value isn't just interpolated in during template compilation\n    engine = Haml::Engine.new('%a{:b => \"a #$global_var_for_testing b\"}')\n    $global_var_for_testing = 'bar'\n    assert_equal(\"<a b='a bar b'></a>\\n\", engine.to_html)\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_utf8_attrs\n    assert_equal(\"<a href='h\u00e9llo'></a>\\n\", render(\"%a{:href => 'h\u00e9llo'}\"))\n    assert_equal(\"<a href='h\u00e9llo'></a>\\n\", render(\"%a(href='h\u00e9llo')\"))\n  end\n\n  # HTML 4.0\n\n  def test_html_has_no_self_closing_tags\n    assert_equal \"<p>\\n  <br>\\n</p>\\n\", render(\"%p\\n  %br\", :format => :html4)\n    assert_equal \"<br>\\n\", render(\"%br/\", :format => :html4)\n  end\n\n  def test_html_renders_empty_node_with_closing_tag\n    assert_equal \"<div class='foo'></div>\\n\", render(\".foo\", :format => :html4)\n  end\n\n  def test_html_doesnt_add_slash_to_self_closing_tags\n    assert_equal \"<a>\\n\", render(\"%a/\", :format => :html4)\n    assert_equal \"<a foo='2'>\\n\", render(\"%a{:foo => 1 + 1}/\", :format => :html4)\n    assert_equal \"<meta>\\n\", render(\"%meta\", :format => :html4)\n    assert_equal \"<meta foo='2'>\\n\", render(\"%meta{:foo => 1 + 1}\", :format => :html4)\n  end\n\n  def test_html_ignores_xml_prolog_declaration\n    assert_equal \"\", render('!!! XML', :format => :html4)\n  end\n\n  def test_html_has_different_doctype\n    assert_equal %{<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\\n},\n    render('!!!', :format => :html4)\n  end\n\n  # because anything before the doctype triggers quirks mode in IE\n  def test_xml_prolog_and_doctype_dont_result_in_a_leading_whitespace_in_html\n    refute_match(/^\\s+/, render(\"!!! xml\\n!!!\", :format => :html4))\n  end\n\n  # HTML5\n  def test_html5_doctype\n    assert_equal %{<!DOCTYPE html>\\n}, render('!!!', :format => :html5)\n  end\n\n  # HTML5 custom data attributes\n  def test_html5_data_attributes_without_hyphenation\n    assert_equal(\"<div data-author_id='123' data-biz='baz' data-foo='bar'></div>\\n\",\n      render(\"%div{:data => {:author_id => 123, :foo => 'bar', :biz => 'baz'}}\",\n        :hyphenate_data_attrs => false))\n\n    assert_equal(\"<div data-one_plus_one='2'></div>\\n\",\n      render(\"%div{:data => {:one_plus_one => 1+1}}\",\n        :hyphenate_data_attrs => false))\n\n    assert_equal(\"<div data-foo='Here&#x0027;s a \\\"quoteful\\\" string.'></div>\\n\",\n      render(%{%div{:data => {:foo => %{Here's a \"quoteful\" string.}}}},\n        :hyphenate_data_attrs => false)) #'\n  end\n\n  def test_html5_data_attributes_with_hyphens\n    assert_equal(\"<div data-foo-bar='blip'></div>\\n\",\n      render(\"%div{:data => {:foo_bar => 'blip'}}\"))\n    assert_equal(\"<div data-baz='bang' data-foo-bar='blip'></div>\\n\",\n      render(\"%div{:data => {:foo_bar => 'blip', :baz => 'bang'}}\"))\n  end\n\n\tdef test_html5_arbitrary_hash_valued_attributes_with\n    assert_equal(\"<div aria-foo='blip'></div>\\n\",\n      render(\"%div{:aria => {:foo => 'blip'}}\"))\n    assert_equal(\"<div foo-baz='bang'></div>\\n\",\n      render(\"%div{:foo => {:baz => 'bang'}}\"))\n\tend\n\n  def test_arbitrary_attribute_hash_merging\n    assert_equal(%Q{<a aria-baz='qux' aria-foo='bar'></a>\\n}, render(<<-HAML))\n- h1 = {:aria => {:foo => :bar}}\n- h2 = {:baz => :qux}\n%a{h1, :aria => h2}\nHAML\n  end\n\n\n  def test_html5_data_attributes_with_nested_hash\n    assert_equal(\"<div data-a-b='c'></div>\\n\", render(<<-HAML))\n- hash = {:a => {:b => 'c'}}\n- hash[:d] = hash\n%div{:data => hash}\nHAML\n  end\n\n  def test_html5_data_attributes_with_nested_hash_and_without_hyphenation\n    assert_equal(\"<div data-a_b='c'></div>\\n\", render(<<-HAML, :hyphenate_data_attrs => false))\n- hash = {:a => {:b => 'c'}}\n- hash[:d] = hash\n%div{:data => hash}\nHAML\n  end\n\n  def test_html5_data_attributes_with_multiple_defs\n    # Should always use the more-explicit attribute\n    assert_equal(\"<div data-foo='second'></div>\\n\",\n      render(\"%div{:data => {:foo => 'first'}, 'data-foo' => 'second'}\"))\n    assert_equal(\"<div data-foo='first'></div>\\n\",\n      render(\"%div{'data-foo' => 'first', :data => {:foo => 'second'}}\"))\n  end\n\n  def test_html5_data_attributes_with_attr_method\n    obj = Object.new\n    def obj.data_hash\n      {:data => {:foo => \"bar\", :baz => \"bang\"}}\n    end\n\n    def obj.data_val\n      {:data => \"dat\"}\n    end\n\n    assert_equal(\"<div data-baz='bang' data-brat='wurst' data-foo='blip'></div>\\n\",\n      render(\"%div{data_hash, :data => {:foo => 'blip', :brat => 'wurst'}}\", scope: obj))\n    assert_equal(\"<div data-baz='bang' data-foo='blip'></div>\\n\",\n      render(\"%div{data_hash, 'data-foo' => 'blip'}\", scope: obj))\n    assert_equal(\"<div data-baz='bang' data-foo='bar' data='dat'></div>\\n\",\n      render(\"%div{data_hash, :data => 'dat'}\", scope: obj))\n    assert_equal(\"<div data-brat='wurst' data-foo='blip' data='dat'></div>\\n\",\n      render(\"%div{data_val, :data => {:foo => 'blip', :brat => 'wurst'}}\", scope: obj))\n  end\n\n  def test_html5_data_attributes_with_identical_attribute_values\n    assert_equal(\"<div data-x='50' data-y='50'></div>\\n\",\n      render(\"%div{:data => {:x => 50, :y => 50}}\"))\n  end\n\n  def test_xml_doc_using_html5_format_and_mime_type\n    assert_equal(<<XML, render(<<HAML, { :format => :html5, :mime_type => 'text/xml' }))\n<?xml version='1.0' encoding='utf-8' ?>\n<root>\n  <element />\n  <hr />\n</root>\nXML\n!!! XML\n%root\n  %element/\n  %hr\nHAML\n  end\n\n  def test_xml_doc_using_html4_format_and_mime_type\n    assert_equal(<<XML, render(<<HAML, { :format => :html4, :mime_type => 'text/xml' }))\n<?xml version='1.0' encoding='utf-8' ?>\n<root>\n  <element />\n  <hr />\n</root>\nXML\n!!! XML\n%root\n  %element/\n  %hr\nHAML\n  end\n\n  # New attributes\n\n  def test_basic_new_attributes\n    assert_equal(\"<a>bar</a>\\n\", render(\"%a() bar\"))\n    assert_equal(\"<a href='foo'>bar</a>\\n\", render(\"%a(href='foo') bar\"))\n    assert_equal(\"<a b='c' c='d' d='e'>baz</a>\\n\", render(%q{%a(b=\"c\" c='d' d=\"e\") baz}))\n  end\n\n  def test_new_attribute_ids\n    assert_equal(\"<div id='foo_bar'></div>\\n\", render(\"#foo(id='bar')\"))\n    assert_equal(\"<div id='foo_baz_bar'></div>\\n\", render(\"#foo{:id => 'bar'}(id='baz')\"))\n    assert_equal(\"<div id='foo_baz_bar'></div>\\n\", render(\"#foo(id='baz'){:id => 'bar'}\"))\n    foo = PrettyUser.new(42)\n    assert_equal(\"<div class='struct_pretty_user' id='foo_baz_bar_struct_pretty_user_42'></div>\\n\",\n      render(\"#foo(id='baz'){:id => 'bar'}[foo]\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='struct_pretty_user' id='foo_baz_bar_struct_pretty_user_42'></div>\\n\",\n      render(\"#foo(id='baz')[foo]{:id => 'bar'}\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='struct_pretty_user' id='foo_baz_bar_struct_pretty_user_42'></div>\\n\",\n      render(\"#foo[foo](id='baz'){:id => 'bar'}\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='struct_pretty_user' id='foo_baz_bar_struct_pretty_user_42'></div>\\n\",\n      render(\"#foo[foo]{:id => 'bar'}(id='baz')\", :locals => {:foo => foo}))\n  end\n\n  def test_new_attribute_classes\n    assert_equal(\"<div class='bar foo'></div>\\n\", render(\".foo(class='bar')\"))\n    assert_equal(\"<div class='bar baz foo'></div>\\n\", render(\".foo{:class => 'bar'}(class='baz')\"))\n    assert_equal(\"<div class='bar baz foo'></div>\\n\", render(\".foo(class='baz'){:class => 'bar'}\"))\n    foo = PrettyUser.new(42)\n    assert_equal(\"<div class='bar baz foo struct_pretty_user' id='struct_pretty_user_42'></div>\\n\",\n      render(\".foo(class='baz'){:class => 'bar'}[foo]\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='bar baz foo struct_pretty_user' id='struct_pretty_user_42'></div>\\n\",\n      render(\".foo[foo](class='baz'){:class => 'bar'}\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='bar baz foo struct_pretty_user' id='struct_pretty_user_42'></div>\\n\",\n      render(\".foo[foo]{:class => 'bar'}(class='baz')\", :locals => {:foo => foo}))\n  end\n\n  def test_dynamic_new_attributes\n    assert_equal(\"<a href='12'>bar</a>\\n\", render(\"%a(href=foo) bar\", :locals => {:foo => 12}))\n    assert_equal(\"<a b='12' c='13' d='14'>bar</a>\\n\", render(\"%a(b=b c='13' d=d) bar\", :locals => {:b => 12, :d => 14}))\n  end\n\n  def test_new_attribute_interpolation\n    assert_equal(\"<a href='12'>bar</a>\\n\", render('%a(href=\"1#{1 + 1}\") bar'))\n    assert_equal(\"<a href='2: 2, 3: 3'>bar</a>\\n\", render(%q{%a(href='2: #{1 + 1}, 3: #{foo}') bar}, :locals => {:foo => 3}))\n    assert_equal(%Q{<a href='1\\#{1 + 1}'>bar</a>\\n}, render('%a(href=\"1\\#{1 + 1}\") bar'))\n  end\n\n  def test_truthy_new_attributes\n    assert_equal(\"<a href='href'>bar</a>\\n\", render(\"%a(href) bar\", :format => :xhtml))\n    assert_equal(\"<a bar='baz' href>bar</a>\\n\", render(\"%a(href bar='baz') bar\", :format => :html5))\n    assert_equal(\"<a href>bar</a>\\n\", render(\"%a(href=true) bar\"))\n    assert_equal(\"<a>bar</a>\\n\", render(\"%a(href=false) bar\"))\n  end\n\n  def test_new_attribute_parsing\n    assert_equal(\"<a a2='b2'>bar</a>\\n\", render(\"%a(a2=b2) bar\", :locals => {:b2 => 'b2'}))\n    assert_equal(%Q{<a a='foo\"bar'>bar</a>\\n}, render(%q{%a(a=\"#{'foo\"bar'}\") bar})) #'\n    assert_equal(%Q{<a a=\"foo'bar\">bar</a>\\n}, render(%q{%a(a=\"#{\"foo'bar\"}\") bar})) #'\n    assert_equal(%Q{<a a='foo\"bar'>bar</a>\\n}, render(%q{%a(a='foo\"bar') bar}))\n    assert_equal(%Q{<a a=\"foo'bar\">bar</a>\\n}, render(%q{%a(a=\"foo'bar\") bar}))\n    assert_equal(\"<a a:b='foo'>bar</a>\\n\", render(\"%a(a:b='foo') bar\"))\n    assert_equal(\"<a a='foo' b='bar'>bar</a>\\n\", render(\"%a(a = 'foo' b = 'bar') bar\"))\n    assert_equal(\"<a a='foo' b='bar'>bar</a>\\n\", render(\"%a(a = foo b = bar) bar\", :locals => {:foo => 'foo', :bar => 'bar'}))\n    assert_equal(\"<a a='foo'>(b='bar')</a>\\n\", render(\"%a(a='foo')(b='bar')\"))\n    assert_equal(\"<a a='foo)bar'>baz</a>\\n\", render(\"%a(a='foo)bar') baz\"))\n    assert_equal(\"<a a='foo'>baz</a>\\n\", render(\"%a( a = 'foo' ) baz\"))\n  end\n\n  def test_new_attribute_escaping\n    assert_equal(%Q{<a a='foo \" bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\\" bar\") bar}))\n    assert_equal(%Q{<a a='foo \\\\\" bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\\\\\\\\\\" bar\") bar}))\n\n    assert_equal(%Q{<a a=\"foo ' bar\">bar</a>\\n}, render(%q{%a(a='foo \\' bar') bar}))\n    assert_equal(%Q{<a a=\"foo \\\\' bar\">bar</a>\\n}, render(%q{%a(a='foo \\\\\\\\\\' bar') bar}))\n\n    assert_equal(%Q{<a a='foo \\\\ bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\\\\\\\ bar\") bar}))\n    assert_equal(%Q{<a a='foo \\#{1 + 1} bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\#{1 + 1} bar\") bar}))\n  end\n\n  def test_multiline_new_attribute\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a(a='b'\\n  c='d') bar\"))\n    assert_equal(\"<a a='b' b='c' c='d' d='e' e='f' f='j'>bar</a>\\n\",\n      render(\"%a(a='b' b='c'\\n  c='d' d=e\\n  e='f' f='j') bar\", :locals => {:e => 'e'}))\n  end\n\n  def test_new_and_old_attributes\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a(a='b'){:c => 'd'} bar\"))\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a{:c => 'd'}(a='b') bar\"))\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a(c='d'){:a => 'b'} bar\"))\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a{:a => 'b'}(c='d') bar\"))\n\n    # Old-style always takes precedence over new-style,\n    # because theoretically old-style could have arbitrary end-of-method-call syntax.\n    assert_equal(\"<a a='b'>bar</a>\\n\", render(\"%a{:a => 'b'}(a='d') bar\"))\n    assert_equal(\"<a a='b'>bar</a>\\n\", render(\"%a(a='d'){:a => 'b'} bar\"))\n\n    assert_equal(\"<a a='b' b='c' c='d' d='e'>bar</a>\\n\",\n      render(\"%a{:a => 'b',\\n:b => 'c'}(c='d'\\nd='e') bar\"))\n\n    locals = {:b => 'b', :d => 'd'}\n    assert_equal(\"<p a='b' c='d'></p>\\n\", render(\"%p{:a => b}(c=d)\", :locals => locals))\n    assert_equal(\"<p a='b' c='d'></p>\\n\", render(\"%p(a=b){:c => d}\", :locals => locals))\n  end\n\n  # Ruby Multiline\n\n  def test_silent_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\nbar, baz, bang\n<p>foo</p>\nHTML\n- foo = [\"bar\",\n         \"baz\",\n         \"bang\"]\n= foo.join(\", \")\n%p foo\nHAML\n  end\n\n  def test_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\nbar, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n= [\"bar\",\n   \"baz\",\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_with_punctuated_methods_is_continuation\n    assert_equal(<<HTML, render(<<HAML))\nbar, , true, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n= [\"bar\",\n   \"  \".strip!,\n   \"\".empty?,\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_character_literals_are_not_continuation\n    html = \",\\n,\\n<p>foo</p>\\n\"\n    assert_equal(html, render(<<HAML))\n= ?,\n= ?\\,\n%p foo\nHAML\n  end\n\n  def test_escaped_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\nbar&lt;, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n&= [\"bar<\",\n    \"baz\",\n    \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_unescaped_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML, :escape_html => true))\nbar<, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n!= [\"bar<\",\n    \"baz\",\n    \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_flattened_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\n<pre>bar&#x000A;baz&#x000A;bang</pre>\n<p>foo</p>\n<p>bar</p>\nHTML\n~ \"<pre>\" + [\"bar\",\n             \"baz\",\n             \"bang\"].join(\"\\\\n\") + \"</pre>\"\n%p foo\n%p bar\nHAML\n  end\n\n  def test_loud_ruby_multiline_with_block\n    assert_equal(<<HTML, render(<<HAML))\n#{%w[far faz fang]}\n<p>foo</p>\n<p>bar</p>\nHTML\n= [\"bar\",\n   \"baz\",\n   \"bang\"].map do |str|\n  - str.gsub(\"ba\",\n             \"fa\")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_silent_ruby_multiline_with_block\n    assert_equal(<<HTML, render(<<HAML))\nfar\nfaz\nfang\n<p>foo</p>\n<p>bar</p>\nHTML\n- [\"bar\",\n   \"baz\",\n   \"bang\"].map do |str|\n  = str.gsub(\"ba\",\n             \"fa\")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_in_tag\n    assert_equal(<<HTML, render(<<HAML))\n<p>foo, bar, baz</p>\n<p>foo</p>\n<p>bar</p>\nHTML\n%p= [\"foo\",\n     \"bar\",\n     \"baz\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_escaped_ruby_multiline_in_tag\n    assert_equal(<<HTML, render(<<HAML))\n<p>foo&lt;, bar, baz</p>\n<p>foo</p>\n<p>bar</p>\nHTML\n%p&= [\"foo<\",\n      \"bar\",\n      \"baz\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_unescaped_ruby_multiline_in_tag\n    assert_equal(<<HTML, render(<<HAML, :escape_html => true))\n<p>foo<, bar, baz</p>\n<p>foo</p>\n<p>bar</p>\nHTML\n%p!= [\"foo<\",\n      \"bar\",\n      \"baz\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_with_normal_multiline\n    assert_equal(<<HTML, render(<<HAML))\nfoobarbar, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n= \"foo\" + |\n  \"bar\" + |\n  [\"bar\", |\n   \"baz\",\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_after_filter\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nbar\nbar, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n:plain\n  foo\n  bar\n= [\"bar\",\n   \"baz\",\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  # Encodings\n\n  def test_utf_8_bom\n    assert_equal <<HTML, render(<<HAML)\n<div class='foo'>\n  <p>baz</p>\n</div>\nHTML\n\\xEF\\xBB\\xBF.foo\n  %p baz\nHAML\n  end\n\n  def test_default_encoding\n    assert_equal(Encoding.find(\"utf-8\"), render(<<HAML.encode(\"us-ascii\")).encoding)\n%p bar\n%p foo\nHAML\n  end\n\n  def test_fake_ascii_encoding\n    assert_encoded_equal(<<HTML.force_encoding(\"ascii-8bit\"), render(<<HAML, :encoding => \"ascii-8bit\"))\n<p>b\u00e2r</p>\n<p>f\u00f6\u00f6</p>\nHTML\n%p b\u00e2r\n%p f\u00f6\u00f6\nHAML\n  end\n\n  def test_convert_template_render_proc\n    assert_converts_template_properly {|e| e.render_proc.call}\n  end\n\n  def test_convert_template_render\n    assert_converts_template_properly {|e| e.render}\n  end\n\n  def test_convert_template_def_method\n    assert_converts_template_properly do |e|\n      o = Object.new\n      e.def_method(o, :render)\n      o.render\n    end\n  end\n\n  def test_encoding_error\n    render(\"foo\\nbar\\nb\\xFEaz\".force_encoding(\"utf-8\"))\n    assert(false, \"Expected exception\")\n  rescue Haml::Error => e\n    assert_equal(3, e.line)\n    assert_match(/Invalid .* character/, e.message)\n  end\n\n  def test_ascii_incompatible_encoding_error\n    template = \"foo\\nbar\\nb_z\".encode(\"utf-16le\")\n    template[9] = \"\\xFE\".force_encoding(\"utf-16le\")\n    render(template)\n    assert(false, \"Expected exception\")\n  rescue Haml::Error => e\n    assert_equal(3, e.line)\n    assert_match(/Invalid .* character/, e.message)\n  end\n\n  def test_same_coding_comment_as_encoding\n    assert_renders_encoded(<<HTML, <<HAML)\n<p>b\u00e2r</p>\n<p>f\u00f6\u00f6</p>\nHTML\n-# coding: utf-8\n%p b\u00e2r\n%p f\u00f6\u00f6\nHAML\n  end\n\n  def test_coding_comments\n    assert_valid_encoding_comment(\"-# coding: ibm866\")\n    assert_valid_encoding_comment(\"-# CodINg: IbM866\")\n    assert_valid_encoding_comment(\"-#coding:ibm866\")\n    assert_valid_encoding_comment(\"-# CodINg= ibm866\")\n    assert_valid_encoding_comment(\"-# foo BAR FAOJcoding: ibm866\")\n    assert_valid_encoding_comment(\"-# coding: ibm866 ASFJ (&(&#!$\")\n    assert_valid_encoding_comment(\"-# -*- coding: ibm866\")\n    assert_valid_encoding_comment(\"-# coding: ibm866 -*- coding: blah\")\n    assert_valid_encoding_comment(\"-# -*- coding: ibm866 -*-\")\n    assert_valid_encoding_comment(\"-# -*- encoding: ibm866 -*-\")\n    assert_valid_encoding_comment('-# -*- coding: \"ibm866\" -*-')\n    assert_valid_encoding_comment(\"-#-*-coding:ibm866-*-\")\n    assert_valid_encoding_comment(\"-#-*-coding:ibm866-*-\")\n    assert_valid_encoding_comment(\"-# -*- foo: bar; coding: ibm866; baz: bang -*-\")\n    assert_valid_encoding_comment(\"-# foo bar coding: baz -*- coding: ibm866 -*-\")\n    assert_valid_encoding_comment(\"-# -*- coding: ibm866 -*- foo bar coding: baz\")\n  end\n\n  def test_different_coding_than_system\n    assert_renders_encoded(<<HTML.encode(\"IBM866\"), <<HAML.encode(\"IBM866\"))\n<p>\u0442\u0410\u042c</p>\nHTML\n%p \u0442\u0410\u042c\nHAML\n  end\n\n  def test_block_spacing\n    begin\n      assert render(<<-HAML)\n- foo = [\"bar\", \"baz\", \"kni\"]\n- foo.each do | item |\n  = item\nHAML\n    rescue ::SyntaxError\n      flunk(\"Should not have raised syntax error\")\n    end\n  end\n\n  def test_tracing\n    result = render('%p{:class => \"hello\"}', :trace => true, :filename => 'foo').strip\n    assert_equal \"<p class='hello' data-trace='foo:1'></p>\", result\n  end\n\n  private\n\n  def assert_valid_encoding_comment(comment)\n    assert_renders_encoded(<<HTML.encode(\"IBM866\"), <<HAML.encode(\"IBM866\").force_encoding(\"UTF-8\"))\n<p>\u0416\u041b\u042b</p>\n<p>\u0442\u0410\u042c</p>\nHTML\n#{comment}\n%p \u0416\u041b\u042b\n%p \u0442\u0410\u042c\nHAML\n  end\n\n  def assert_converts_template_properly\n    engine = Haml::Engine.new(<<HAML.encode(\"iso-8859-1\"), :encoding => \"macRoman\")\n%p b\u00e2r\n%p f\u00f6\u00f6\nHAML\n    assert_encoded_equal(<<HTML.encode(\"macRoman\"), yield(engine))\n<p>b\u00e2r</p>\n<p>f\u00f6\u00f6</p>\nHTML\n  end\n\n  def assert_renders_encoded(html, haml)\n    result = render(haml)\n    assert_encoded_equal html, result\n  end\n\n  def assert_encoded_equal(expected, actual)\n    assert_equal expected.encoding, actual.encoding\n    assert_equal expected, actual\n  end\nend\n", "<?xml version='1.0' encoding='utf-8' ?>\n<?xml version='1.0' encoding='iso-8859-1' ?>\n<?xml version='1.0' encoding='utf-8' ?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">\n<strong apos=\"Foo's bar!\">Boo!</strong>\nEmbedded? false!\nEmbedded? true!\nEmbedded? true!\nEmbedded? twice! true!\nEmbedded? one af\"t\"er another!\n<p>Embedded? false!</p>\n<p>Embedded? true!</p>\n<p>Embedded? true!</p>\n<p>Embedded? twice! true!</p>\n<p>Embedded? one af\"t\"er another!</p>\nstuff followed by whitespace\n<strong>block with whitespace</strong>\n<p>\n  Escape\n  - character\n  %p foo\n  yee\\ha\n     don't lstrip me\n</p>\n<!-- Short comment -->\n<!--\n  This is a block comment\n  cool, huh?\n  <strong>there can even be sub-tags!</strong>\n  Or script!\n-->\n<p class=''>class attribute should appear!</p>\n<p>this attribute shouldn't appear</p>\n<!--[if lte IE6]> conditional comment! <![endif]-->\n<!--[if gte IE7]>\n  <p>Block conditional comment</p>\n  <div>\n    <h1>Cool, eh?</h1>\n  </div>\n<![endif]-->\n<!--[if gte IE5.2]>\n  Woah a period.\n<![endif]-->\ntesttest\n<br />\n<meta foo='bar' />\n<img />\n<hr />\n<link />\n<script>Inline content</script>\n<br>\n  Nested content\n</br>\n<p class='article bar foo' id='article_1'>Blah</p>\n<p class='article foo' id='article_1'>Blah</p>\n<p class='article bar baz foo' id='article_1'>Blah</p>\n<p class='article quux qux' id='article_1'>Blump</p>\n<p class='article' id='foo_bar_baz_article_1'>Whee</p>\nWoah inner quotes\n<p class='dynamic_quote' dyn='3' quotes=\"single '\"></p>\n<p class='dynamic_self_closing' dyn='3' />\n<body>\n  hello\n  <div>\n    <img />\n  </div>\n</body>\n", "<?xml version='1.0' encoding='utf-8' ?>\n<?xml version='1.0' encoding='iso-8859-1' ?>\n<?xml version='1.0' encoding='utf-8' ?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">\n<strong apos=\"Foo's bar!\">Boo!</strong>\nEmbedded? false!\nEmbedded? true!\nEmbedded? true!\nEmbedded? twice! true!\nEmbedded? one af\"t\"er another!\n<p>Embedded? false!</p>\n<p>Embedded? true!</p>\n<p>Embedded? true!</p>\n<p>Embedded? twice! true!</p>\n<p>Embedded? one af\"t\"er another!</p>\nstuff followed by whitespace\n<strong>block with whitespace</strong>\n<p>\nEscape\n- character\n%p foo\nyee\\ha\n   don't lstrip me\n</p>\n<!-- Short comment -->\n<!--\nThis is a block comment\ncool, huh?\n<strong>there can even be sub-tags!</strong>\nOr script!\n-->\n<p class=''>class attribute should appear!</p>\n<p>this attribute shouldn't appear</p>\n<!--[if lte IE6]> conditional comment! <![endif]-->\n<!--[if gte IE7]>\n<p>Block conditional comment</p>\n<div>\n<h1>Cool, eh?</h1>\n</div>\n<![endif]-->\n<!--[if gte IE5.2]>\nWoah a period.\n<![endif]-->\ntesttest\n<br />\n<meta foo='bar' />\n<img />\n<hr />\n<link />\n<script>Inline content</script>\n<br>\nNested content\n</br>\n<p class='article bar foo' id='article_1'>Blah</p>\n<p class='article foo' id='article_1'>Blah</p>\n<p class='article bar baz foo' id='article_1'>Blah</p>\n<p class='article quux qux' id='article_1'>Blump</p>\n<p class='article' id='foo_bar_baz_article_1'>Whee</p>\nWoah inner quotes\n<p class='dynamic_quote' dyn='3' quotes=\"single '\"></p>\n<p class='dynamic_self_closing' dyn='3' />\n<body>\nhello\n<div>\n<img />\n</div>\n</body>\n"], "fixing_code": ["module Haml\n  # This module contains various helpful methods to make it easier to do various tasks.\n  # {Haml::Helpers} is automatically included in the context\n  # that a Haml template is parsed in, so all these methods are at your\n  # disposal from within the template.\n  module Helpers\n    # An object that raises an error when \\{#to\\_s} is called.\n    # It's used to raise an error when the return value of a helper is used\n    # when it shouldn't be.\n    class ErrorReturn\n      def initialize(method)\n        @message = <<MESSAGE\n#{method} outputs directly to the Haml template.\nDisregard its return value and use the - operator,\nor use capture_haml to get the value as a String.\nMESSAGE\n      end\n\n      # Raises an error.\n      #\n      # @raise [Haml::Error] The error\n      def to_s\n        raise Haml::Error.new(@message)\n      rescue Haml::Error => e\n        e.backtrace.shift\n\n        # If the ErrorReturn is used directly in the template,\n        # we don't want Haml's stuff to get into the backtrace,\n        # so we get rid of the format_script line.\n        #\n        # We also have to subtract one from the Haml line number\n        # since the value is passed to format_script the line after\n        # it's actually used.\n        if e.backtrace.first =~ /^\\(eval\\):\\d+:in `format_script/\n          e.backtrace.shift\n          e.backtrace.first.gsub!(/^\\(haml\\):(\\d+)/) {|s| \"(haml):#{$1.to_i - 1}\"}\n        end\n        raise e\n      end\n\n      # @return [String] A human-readable string representation\n      def inspect\n        \"Haml::Helpers::ErrorReturn(#{@message.inspect})\"\n      end\n    end\n\n    self.extend self\n\n    @@action_view_defined = false\n\n    # @return [Boolean] Whether or not ActionView is loaded\n    def self.action_view?\n      @@action_view_defined\n    end\n\n    # Note: this does **not** need to be called when using Haml helpers\n    # normally in Rails.\n    #\n    # Initializes the current object as though it were in the same context\n    # as a normal ActionView instance using Haml.\n    # This is useful if you want to use the helpers in a context\n    # other than the normal setup with ActionView.\n    # For example:\n    #\n    #     context = Object.new\n    #     class << context\n    #       include Haml::Helpers\n    #     end\n    #     context.init_haml_helpers\n    #     context.haml_tag :p, \"Stuff\"\n    #\n    def init_haml_helpers\n      @haml_buffer = Haml::Buffer.new(haml_buffer, Options.new.for_buffer)\n      nil\n    end\n\n    # Runs a block of code in a non-Haml context\n    # (i.e. \\{#is\\_haml?} will return false).\n    #\n    # This is mainly useful for rendering sub-templates such as partials in a non-Haml language,\n    # particularly where helpers may behave differently when run from Haml.\n    #\n    # Note that this is automatically applied to Rails partials.\n    #\n    # @yield A block which won't register as Haml\n    def non_haml\n      was_active = @haml_buffer.active?\n      @haml_buffer.active = false\n      yield\n    ensure\n      @haml_buffer.active = was_active\n    end\n\n    # Uses \\{#preserve} to convert any newlines inside whitespace-sensitive tags\n    # into the HTML entities for endlines.\n    #\n    # @param tags [Array<String>] Tags that should have newlines escaped\n    #\n    # @overload find_and_preserve(input, tags = haml_buffer.options[:preserve])\n    #   Escapes newlines within a string.\n    #\n    #   @param input [String] The string within which to escape newlines\n    # @overload find_and_preserve(tags = haml_buffer.options[:preserve])\n    #   Escapes newlines within a block of Haml code.\n    #\n    #   @yield The block within which to escape newlines\n    def find_and_preserve(input = nil, tags = haml_buffer.options[:preserve], &block)\n      return find_and_preserve(capture_haml(&block), input || tags) if block\n      tags = tags.each_with_object('') do |t, s|\n        s << '|' unless s.empty?\n        s << Regexp.escape(t)\n      end\n      re = /<(#{tags})([^>]*)>(.*?)(<\\/\\1>)/im\n      input.to_s.gsub(re) do |s|\n        s =~ re # Can't rely on $1, etc. existing since Rails' SafeBuffer#gsub is incompatible\n        \"<#{$1}#{$2}>#{preserve($3)}</#{$1}>\"\n      end\n    end\n\n    # Takes any string, finds all the newlines, and converts them to\n    # HTML entities so they'll render correctly in\n    # whitespace-sensitive tags without screwing up the indentation.\n    #\n    # @overload preserve(input)\n    #   Escapes newlines within a string.\n    #\n    #   @param input [String] The string within which to escape all newlines\n    # @overload preserve\n    #   Escapes newlines within a block of Haml code.\n    #\n    #   @yield The block within which to escape newlines\n    def preserve(input = nil, &block)\n      return preserve(capture_haml(&block)) if block\n      s = input.to_s.chomp(\"\\n\")\n      s.gsub!(/\\n/, '&#x000A;')\n      s.delete!(\"\\r\")\n      s\n    end\n    alias_method :flatten, :preserve\n\n    # Takes an `Enumerable` object and a block\n    # and iterates over the enum,\n    # yielding each element to a Haml block\n    # and putting the result into `<li>` elements.\n    # This creates a list of the results of the block.\n    # For example:\n    #\n    #     = list_of([['hello'], ['yall']]) do |i|\n    #       = i[0]\n    #\n    # Produces:\n    #\n    #     <li>hello</li>\n    #     <li>yall</li>\n    #\n    # And:\n    #\n    #     = list_of({:title => 'All the stuff', :description => 'A book about all the stuff.'}) do |key, val|\n    #       %h3= key.humanize\n    #       %p= val\n    #\n    # Produces:\n    #\n    #     <li>\n    #       <h3>Title</h3>\n    #       <p>All the stuff</p>\n    #     </li>\n    #     <li>\n    #       <h3>Description</h3>\n    #       <p>A book about all the stuff.</p>\n    #     </li>\n    #\n    # While:\n    #\n    #     = list_of([\"Home\", \"About\", \"Contact\", \"FAQ\"], {class: \"nav\", role: \"nav\"}) do |item|\n    #       %a{ href=\"#\" }= item\n    #\n    # Produces:\n    #\n    #     <li class='nav' role='nav'>\n    #       <a href='#'>Home</a>\n    #     </li>\n    #     <li class='nav' role='nav'>\n    #       <a href='#'>About</a>\n    #     </li>\n    #     <li class='nav' role='nav'>\n    #       <a href='#'>Contact</a>\n    #     </li>\n    #     <li class='nav' role='nav'>\n    #       <a href='#'>FAQ</a>\n    #     </li>\n    #\n    #  `[[class\", \"nav\"], [role\", \"nav\"]]` could have been used instead of `{class: \"nav\", role: \"nav\"}` (or any enumerable collection where each pair of items responds to #to_s)\n    #\n    # @param enum [Enumerable] The list of objects to iterate over\n    # @param [Enumerable<#to_s,#to_s>] opts Each key/value pair will become an attribute pair for each list item element.\n    # @yield [item] A block which contains Haml code that goes within list items\n    # @yieldparam item An element of `enum`\n    def list_of(enum, opts={}, &block)\n      opts_attributes = opts.each_with_object('') {|(k, v), s| s << \" #{k}='#{v}'\"}\n      enum.each_with_object('') do |i, ret|\n        result = capture_haml(i, &block)\n\n        if result.count(\"\\n\") > 1\n          result.gsub!(\"\\n\", \"\\n  \")\n          result = \"\\n  #{result.strip!}\\n\"\n        else\n          result.strip!\n        end\n\n        ret << \"\\n\" unless ret.empty?\n        ret << %Q!<li#{opts_attributes}>#{result}</li>!\n      end\n    end\n\n    # Returns a hash containing default assignments for the `xmlns`, `lang`, and `xml:lang`\n    # attributes of the `html` HTML element.\n    # For example,\n    #\n    #     %html{html_attrs}\n    #\n    # becomes\n    #\n    #     <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en-US' lang='en-US'>\n    #\n    # @param lang [String] The value of `xml:lang` and `lang`\n    # @return [{#to_s => String}] The attribute hash\n    def html_attrs(lang = 'en-US')\n      if haml_buffer.options[:format] == :xhtml\n        {:xmlns => \"http://www.w3.org/1999/xhtml\", 'xml:lang' => lang, :lang => lang}\n      else\n        {:lang => lang}\n      end\n    end\n\n    # Increments the number of tabs the buffer automatically adds\n    # to the lines of the template.\n    # For example:\n    #\n    #     %h1 foo\n    #     - tab_up\n    #     %p bar\n    #     - tab_down\n    #     %strong baz\n    #\n    # Produces:\n    #\n    #     <h1>foo</h1>\n    #       <p>bar</p>\n    #     <strong>baz</strong>\n    #\n    # @param i [Fixnum] The number of tabs by which to increase the indentation\n    # @see #tab_down\n    def tab_up(i = 1)\n      haml_buffer.tabulation += i\n    end\n\n    # Decrements the number of tabs the buffer automatically adds\n    # to the lines of the template.\n    #\n    # @param i [Fixnum] The number of tabs by which to decrease the indentation\n    # @see #tab_up\n    def tab_down(i = 1)\n      haml_buffer.tabulation -= i\n    end\n\n    # Sets the number of tabs the buffer automatically adds\n    # to the lines of the template,\n    # but only for the duration of the block.\n    # For example:\n    #\n    #     %h1 foo\n    #     - with_tabs(2) do\n    #       %p bar\n    #     %strong baz\n    #\n    # Produces:\n    #\n    #     <h1>foo</h1>\n    #         <p>bar</p>\n    #     <strong>baz</strong>\n    #\n    #\n    # @param i [Fixnum] The number of tabs to use\n    # @yield A block in which the indentation will be `i` spaces\n    def with_tabs(i)\n      old_tabs = haml_buffer.tabulation\n      haml_buffer.tabulation = i\n      yield\n    ensure\n      haml_buffer.tabulation = old_tabs\n    end\n\n    # Surrounds a block of Haml code with strings,\n    # with no whitespace in between.\n    # For example:\n    #\n    #     = surround '(', ')' do\n    #       %a{:href => \"food\"} chicken\n    #\n    # Produces:\n    #\n    #     (<a href='food'>chicken</a>)\n    #\n    # and\n    #\n    #     = surround '*' do\n    #       %strong angry\n    #\n    # Produces:\n    #\n    #     *<strong>angry</strong>*\n    #\n    # @param front [String] The string to add before the Haml\n    # @param back [String] The string to add after the Haml\n    # @yield A block of Haml to surround\n    def surround(front, back = front, &block)\n      output = capture_haml(&block)\n\n      \"#{front}#{output.chomp}#{back}\\n\"\n    end\n\n    # Prepends a string to the beginning of a Haml block,\n    # with no whitespace between.\n    # For example:\n    #\n    #     = precede '*' do\n    #       %span.small Not really\n    #\n    # Produces:\n    #\n    #     *<span class='small'>Not really</span>\n    #\n    # @param str [String] The string to add before the Haml\n    # @yield A block of Haml to prepend to\n    def precede(str, &block)\n      \"#{str}#{capture_haml(&block).chomp}\\n\"\n    end\n\n    # Appends a string to the end of a Haml block,\n    # with no whitespace between.\n    # For example:\n    #\n    #     click\n    #     = succeed '.' do\n    #       %a{:href=>\"thing\"} here\n    #\n    # Produces:\n    #\n    #     click\n    #     <a href='thing'>here</a>.\n    #\n    # @param str [String] The string to add after the Haml\n    # @yield A block of Haml to append to\n    def succeed(str, &block)\n      \"#{capture_haml(&block).chomp}#{str}\\n\"\n    end\n\n    # Captures the result of a block of Haml code,\n    # gets rid of the excess indentation,\n    # and returns it as a string.\n    # For example, after the following,\n    #\n    #     .foo\n    #       - foo = capture_haml(13) do |a|\n    #         %p= a\n    #\n    # the local variable `foo` would be assigned to `\"<p>13</p>\\n\"`.\n    #\n    # @param args [Array] Arguments to pass into the block\n    # @yield [args] A block of Haml code that will be converted to a string\n    # @yieldparam args [Array] `args`\n    def capture_haml(*args, &block)\n      buffer = eval('if defined? _hamlout then _hamlout else nil end', block.binding) || haml_buffer\n      with_haml_buffer(buffer) do\n        position = haml_buffer.buffer.length\n\n        haml_buffer.capture_position = position\n        value = block.call(*args)\n\n        captured = haml_buffer.buffer.slice!(position..-1)\n\n        if captured == '' and value != haml_buffer.buffer\n          captured = (value.is_a?(String) ? value : nil)\n        end\n\n        return nil if captured.nil?\n        return (haml_buffer.options[:ugly] ? captured : prettify(captured))\n      end\n    ensure\n      haml_buffer.capture_position = nil\n    end\n\n    # Outputs text directly to the Haml buffer, with the proper indentation.\n    #\n    # @param text [#to_s] The text to output\n    def haml_concat(text = \"\")\n      haml_internal_concat text\n      ErrorReturn.new(\"haml_concat\")\n    end\n\n    # Internal method to write directly to the buffer with control of\n    # whether the first line should be indented, and if there should be a\n    # final newline.\n    #\n    # Lines added will have the proper indentation. This can be controlled\n    # for the first line.\n    #\n    # Used by #haml_concat and #haml_tag.\n    #\n    # @param text [#to_s] The text to output\n    # @param newline [Boolean] Whether to add a newline after the text\n    # @param indent [Boolean] Whether to add indentation to the first line\n    def haml_internal_concat(text = \"\", newline = true, indent = true)\n      if haml_buffer.options[:ugly] || haml_buffer.tabulation == 0\n        haml_buffer.buffer << \"#{text}#{\"\\n\" if newline}\"\n      else\n        haml_buffer.buffer << %[#{haml_indent if indent}#{text.to_s.gsub(\"\\n\", \"\\n#{haml_indent}\")}#{\"\\n\" if newline}]\n      end\n    end\n    private :haml_internal_concat\n\n    # Allows writing raw content. `haml_internal_concat_raw` isn't\n    # effected by XSS mods. Used by #haml_tag to write the actual tags.\n    alias :haml_internal_concat_raw :haml_internal_concat\n\n    # @return [String] The indentation string for the current line\n    def haml_indent\n      '  ' * haml_buffer.tabulation\n    end\n\n    # Creates an HTML tag with the given name and optionally text and attributes.\n    # Can take a block that will run between the opening and closing tags.\n    # If the block is a Haml block or outputs text using \\{#haml\\_concat},\n    # the text will be properly indented.\n    #\n    # `name` can be a string using the standard Haml class/id shorthand\n    # (e.g. \"span#foo.bar\", \"#foo\").\n    # Just like standard Haml tags, these class and id values\n    # will be merged with manually-specified attributes.\n    #\n    # `flags` is a list of symbol flags\n    # like those that can be put at the end of a Haml tag\n    # (`:/`, `:<`, and `:>`).\n    # Currently, only `:/` and `:<` are supported.\n    #\n    # `haml_tag` outputs directly to the buffer;\n    # its return value should not be used.\n    # If you need to get the results as a string,\n    # use \\{#capture\\_haml\\}.\n    #\n    # For example,\n    #\n    #     haml_tag :table do\n    #       haml_tag :tr do\n    #         haml_tag 'td.cell' do\n    #           haml_tag :strong, \"strong!\"\n    #           haml_concat \"data\"\n    #         end\n    #         haml_tag :td do\n    #           haml_concat \"more_data\"\n    #         end\n    #       end\n    #     end\n    #\n    # outputs\n    #\n    #     <table>\n    #       <tr>\n    #         <td class='cell'>\n    #           <strong>\n    #             strong!\n    #           </strong>\n    #           data\n    #         </td>\n    #         <td>\n    #           more_data\n    #         </td>\n    #       </tr>\n    #     </table>\n    #\n    # @param name [#to_s] The name of the tag\n    #\n    # @overload haml_tag(name, *rest, attributes = {})\n    #   @yield The block of Haml code within the tag\n    # @overload haml_tag(name, text, *flags, attributes = {})\n    #   @param text [#to_s] The text within the tag\n    #   @param flags [Array<Symbol>] Haml end-of-tag flags\n    def haml_tag(name, *rest, &block)\n      ret = ErrorReturn.new(\"haml_tag\")\n\n      text = rest.shift.to_s unless [Symbol, Hash, NilClass].any? {|t| rest.first.is_a? t}\n      flags = []\n      flags << rest.shift while rest.first.is_a? Symbol\n      attrs = (rest.shift || {})\n      attrs.keys.each {|key| attrs[key.to_s] = attrs.delete(key)} unless attrs.empty?\n      name, attrs = merge_name_and_attributes(name.to_s, attrs)\n\n      attributes = Haml::AttributeBuilder.build_attributes(haml_buffer.html?,\n        haml_buffer.options[:attr_wrapper],\n        haml_buffer.options[:escape_attrs],\n        haml_buffer.options[:hyphenate_data_attrs],\n        attrs)\n\n      if text.nil? && block.nil? && (haml_buffer.options[:autoclose].include?(name) || flags.include?(:/))\n        haml_internal_concat_raw \"<#{name}#{attributes}#{' /' if haml_buffer.options[:format] == :xhtml}>\"\n        return ret\n      end\n\n      if flags.include?(:/)\n        raise Error.new(Error.message(:self_closing_content)) if text\n        raise Error.new(Error.message(:illegal_nesting_self_closing)) if block\n      end\n\n      tag = \"<#{name}#{attributes}>\"\n      end_tag = \"</#{name}>\"\n      if block.nil?\n        text = text.to_s\n        if text.include?(\"\\n\")\n          haml_internal_concat_raw tag\n          tab_up\n          haml_internal_concat text\n          tab_down\n          haml_internal_concat_raw end_tag\n        else\n          haml_internal_concat_raw tag, false\n          haml_internal_concat text, false, false\n          haml_internal_concat_raw end_tag, true, false\n        end\n        return ret\n      end\n\n      if text\n        raise Error.new(Error.message(:illegal_nesting_line, name))\n      end\n\n      if flags.include?(:<)\n        haml_internal_concat_raw tag, false\n        haml_internal_concat \"#{capture_haml(&block).strip}\", false, false\n        haml_internal_concat_raw end_tag, true, false\n        return ret\n      end\n\n      haml_internal_concat_raw tag\n      tab_up\n      block.call\n      tab_down\n      haml_internal_concat_raw end_tag\n\n      ret\n    end\n\n    # Conditionally wrap a block in an element. If `condition` is `true` then\n    # this method renders the tag described by the arguments in `tag` (using\n    # \\{#haml_tag}) with the given block inside, otherwise it just renders the block.\n    #\n    # For example,\n    #\n    #     - haml_tag_if important, '.important' do\n    #       %p\n    #         A (possibly) important paragraph.\n    #\n    # will produce\n    #\n    #     <div class='important'>\n    #       <p>\n    #         A (possibly) important paragraph.\n    #       </p>\n    #     </div>\n    #\n    # if `important` is truthy, and just\n    #\n    #     <p>\n    #       A (possibly) important paragraph.\n    #     </p>\n    #\n    # otherwise.\n    #\n    # Like \\{#haml_tag}, `haml_tag_if` outputs directly to the buffer and its\n    # return value should not be used. Use \\{#capture_haml} if you need to use\n    # its results as a string.\n    #\n    # @param condition The condition to test to determine whether to render\n    #   the enclosing tag\n    # @param tag Definition of the enclosing tag. See \\{#haml_tag} for details\n    #   (specifically the form that takes a block)\n    def haml_tag_if(condition, *tag)\n      if condition\n        haml_tag(*tag){ yield }\n      else\n        yield\n      end\n      ErrorReturn.new(\"haml_tag_if\")\n    end\n\n    # Characters that need to be escaped to HTML entities from user input\n    HTML_ESCAPE = { '&' => '&amp;', '<' => '&lt;', '>' => '&gt;', '\"' => '&quot;', \"'\" => '&#039;' }\n\n    HTML_ESCAPE_REGEX = /['\"><&]/\n\n    # Returns a copy of `text` with ampersands, angle brackets and quotes\n    # escaped into HTML entities.\n    #\n    # Note that if ActionView is loaded and XSS protection is enabled\n    # (as is the default for Rails 3.0+, and optional for version 2.3.5+),\n    # this won't escape text declared as \"safe\".\n    #\n    # @param text [String] The string to sanitize\n    # @return [String] The sanitized string\n    def html_escape(text)\n      text = text.to_s\n      text.gsub(HTML_ESCAPE_REGEX, HTML_ESCAPE)\n    end\n\n    HTML_ESCAPE_ONCE_REGEX = /[\\\"><]|&(?!(?:[a-zA-Z]+|#(?:\\d+|[xX][0-9a-fA-F]+));)/\n\n    # Escapes HTML entities in `text`, but without escaping an ampersand\n    # that is already part of an escaped entity.\n    #\n    # @param text [String] The string to sanitize\n    # @return [String] The sanitized string\n    def escape_once(text)\n      text = text.to_s\n      text.gsub(HTML_ESCAPE_ONCE_REGEX, HTML_ESCAPE)\n    end\n\n    # Returns whether or not the current template is a Haml template.\n    #\n    # This function, unlike other {Haml::Helpers} functions,\n    # also works in other `ActionView` templates,\n    # where it will always return false.\n    #\n    # @return [Boolean] Whether or not the current template is a Haml template\n    def is_haml?\n      !@haml_buffer.nil? && @haml_buffer.active?\n    end\n\n    # Returns whether or not `block` is defined directly in a Haml template.\n    #\n    # @param block [Proc] A Ruby block\n    # @return [Boolean] Whether or not `block` is defined directly in a Haml template\n    def block_is_haml?(block)\n      eval('!!defined?(_hamlout)', block.binding)\n    end\n\n    private\n\n    # Parses the tag name used for \\{#haml\\_tag}\n    # and merges it with the Ruby attributes hash.\n    def merge_name_and_attributes(name, attributes_hash = {})\n      # skip merging if no ids or classes found in name\n      return name, attributes_hash unless name =~ /^(.+?)?([\\.#].*)$/\n\n      return $1 || \"div\", AttributeBuilder.merge_attributes(\n        Haml::Parser.parse_class_and_id($2), attributes_hash)\n    end\n\n    # Runs a block of code with the given buffer as the currently active buffer.\n    #\n    # @param buffer [Haml::Buffer] The Haml buffer to use temporarily\n    # @yield A block in which the given buffer should be used\n    def with_haml_buffer(buffer)\n      @haml_buffer, old_buffer = buffer, @haml_buffer\n      old_buffer.active, old_was_active = false, old_buffer.active? if old_buffer\n      @haml_buffer.active, was_active = true, @haml_buffer.active?\n      yield\n    ensure\n      @haml_buffer.active = was_active\n      old_buffer.active = old_was_active if old_buffer\n      @haml_buffer = old_buffer\n    end\n\n    # The current {Haml::Buffer} object.\n    #\n    # @return [Haml::Buffer]\n    def haml_buffer\n      @haml_buffer if defined? @haml_buffer\n    end\n\n    # Gives a proc the same local `_hamlout` and `_erbout` variables\n    # that the current template has.\n    #\n    # @param proc [#call] The proc to bind\n    # @return [Proc] A new proc with the new variables bound\n    def haml_bind_proc(&proc)\n      _hamlout = haml_buffer\n      #double assignment is to avoid warnings\n      _erbout = _erbout = _hamlout.buffer\n      proc { |*args| proc.call(*args) }\n    end\n\n    def prettify(text)\n      text = text.split(/^/)\n      text.delete('')\n\n      min_tabs = nil\n      text.each do |line|\n        tabs = line.index(/[^ ]/) || line.length\n        min_tabs ||= tabs\n        min_tabs = min_tabs > tabs ? tabs : min_tabs\n      end\n\n      text.each_with_object('') do |line, str|\n        str << line.slice(min_tabs, line.length)\n      end\n    end\n  end\nend\n\n# @private\nclass Object\n  # Haml overrides various `ActionView` helpers,\n  # which call an \\{#is\\_haml?} method\n  # to determine whether or not the current context object\n  # is a proper Haml context.\n  # Because `ActionView` helpers may be included in non-`ActionView::Base` classes,\n  # it's a good idea to define \\{#is\\_haml?} for all objects.\n  def is_haml?\n    false\n  end\nend\n\n", "# -*- coding: utf-8 -*-\nrequire 'test_helper'\n\nclass EngineTest < Haml::TestCase\n  # A map of erroneous Haml documents to the error messages they should produce.\n  # The error messages may be arrays;\n  # if so, the second element should be the line number that should be reported for the error.\n  # If this isn't provided, the tests will assume the line number should be the last line of the document.\n  EXCEPTION_MAP = {\n    \"!!!\\n  a\"                                             => error(:illegal_nesting_header),\n    \"a\\n  b\"                                               => error(:illegal_nesting_plain),\n    \"/ a\\n  b\"                                             => error(:illegal_nesting_content),\n    \"% a\"                                                  => error(:invalid_tag, '% a'),\n    \"%p a\\n  b\"                                            => error(:illegal_nesting_line, 'p'),\n    \"%p=\"                                                  => error(:no_ruby_code, '='),\n    \"%p~\"                                                  => error(:no_ruby_code, '~'),\n    \"~\"                                                    => error(:no_ruby_code, '~'),\n    \"=\"                                                    => error(:no_ruby_code, '='),\n    \"%p/\\n  a\"                                             => error(:illegal_nesting_self_closing),\n    \":a\\n  b\"                                              => [error(:filter_not_defined, 'a'), 1],\n    \":a= b\"                                                => error(:invalid_filter_name, 'a= b'),\n    \".\"                                                    => error(:illegal_element),\n    \".#\"                                                   => error(:illegal_element),\n    \".{} a\"                                                => error(:illegal_element),\n    \".() a\"                                                => error(:illegal_element),\n    \".= a\"                                                 => error(:illegal_element),\n    \"%p..a\"                                                => error(:illegal_element),\n    \"%a/ b\"                                                => error(:self_closing_content),\n    \" %p foo\"                                              => error(:indenting_at_start),\n    \"  %p foo\"                                             => error(:indenting_at_start),\n    \"- end\"                                                => error(:no_end),\n    \"%p{:a => 'b',\\n:c => 'd'}/ e\"                         => [error(:self_closing_content), 2],\n    \"%p{:a => 'b',\\n:c => 'd'}=\"                           => [error(:no_ruby_code, '='), 2],\n    \"%p.{:a => 'b',\\n:c => 'd'} e\"                         => [error(:illegal_element), 1],\n    \"%p{:a => 'b',\\n:c => 'd',\\n:e => 'f'}\\n%p/ a\"         => [error(:self_closing_content), 4],\n    \"%p{:a => 'b',\\n:c => 'd',\\n:e => 'f'}\\n- raise 'foo'\" => [\"foo\", 4],\n    \"%p{:a => 'b',\\n:c => raise('foo'),\\n:e => 'f'}\"       => [\"foo\", 2],\n    \"%p{:a => 'b',\\n:c => 'd',\\n:e => raise('foo')}\"       => [\"foo\", 3],\n    \" \\n\\t\\n %p foo\"                                       => [error(:indenting_at_start), 3],\n    \"\\n\\n %p foo\"                                          => [error(:indenting_at_start), 3],\n    \"%p\\n  foo\\n foo\"                                      => [error(:inconsistent_indentation, \"1 space\", \"2 spaces\"), 3],\n    \"%p\\n  foo\\n%p\\n foo\"                                  => [error(:inconsistent_indentation, \"1 space\", \"2 spaces\"), 4],\n    \"%p\\n\\t\\tfoo\\n\\tfoo\"                                   => [error(:inconsistent_indentation, \"1 tab\", \"2 tabs\"), 3],\n    \"%p\\n  foo\\n   foo\"                                    => [error(:inconsistent_indentation, \"3 spaces\", \"2 spaces\"), 3],\n    \"%p\\n  foo\\n  %p\\n   bar\"                              => [error(:inconsistent_indentation, \"3 spaces\", \"2 spaces\"), 4],\n    \"%p\\n  :plain\\n     bar\\n   \\t  baz\"                   => [error(:inconsistent_indentation, '\"   \\t  \"', \"2 spaces\"), 4],\n    \"%p\\n  foo\\n%p\\n    bar\"                               => [error(:deeper_indenting, 2), 4],\n    \"%p\\n  foo\\n  %p\\n        bar\"                         => [error(:deeper_indenting, 3), 4],\n    \"%p\\n \\tfoo\"                                           => [error(:cant_use_tabs_and_spaces), 2],\n    \"%p(\"                                                  => error(:invalid_attribute_list, '\"(\"'),\n    \"%p(foo=)\"                                             => error(:invalid_attribute_list, '\"(foo=)\"'),\n    \"%p(foo 'bar')\"                                        => error(:invalid_attribute_list, '\"(foo \\'bar\\')\"'),\n    \"%p(foo=\\nbar)\"                                        => [error(:invalid_attribute_list, '\"(foo=\"'), 1],\n    \"%p(foo 'bar'\\nbaz='bang')\"                            => [error(:invalid_attribute_list, '\"(foo \\'bar\\'\"'), 1],\n    \"%p(foo='bar'\\nbaz 'bang'\\nbip='bop')\"                 => [error(:invalid_attribute_list, '\"(foo=\\'bar\\' baz \\'bang\\'\"'), 2],\n    \"%p{'foo' => 'bar' 'bar' => 'baz'}\"                    => :compile,\n    \"%p{:foo => }\"                                         => :compile,\n    \"%p{=> 'bar'}\"                                         => :compile,\n    \"%p{'foo => 'bar'}\"                                    => :compile,\n    \"%p{:foo => 'bar}\"                                     => :compile,\n    \"%p{:foo => 'bar\\\"}\"                                   => :compile,\n    # Regression tests\n    \"foo\\n\\n\\n  bar\"                                       => [error(:illegal_nesting_plain), 4],\n    \"%p/\\n\\n  bar\"                                         => [error(:illegal_nesting_self_closing), 3],\n    \"%p foo\\n\\n  bar\"                                      => [error(:illegal_nesting_line, 'p'), 3],\n    \"/ foo\\n\\n  bar\"                                       => [error(:illegal_nesting_content), 3],\n    \"!!!\\n\\n  bar\"                                         => [error(:illegal_nesting_header), 3],\n    \"- raise 'foo'\\n\\n\\n\\nbar\"                             => [\"foo\", 1],\n    \"= 'foo'\\n-raise 'foo'\"                                => [\"foo\", 2],\n    \"\\n\\n\\n- raise 'foo'\"                                  => [\"foo\", 4],\n    \"%p foo |\\n   bar |\\n   baz |\\nbop\\n- raise 'foo'\"     => [\"foo\", 5],\n    \"foo\\n:ruby\\n  1\\n  2\\n  3\\n- raise 'foo'\"             => [\"foo\", 6],\n    \"foo\\n:erb\\n  1\\n  2\\n  3\\n- raise 'foo'\"              => [\"foo\", 6],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\n- raise 'foo'\"            => [\"foo\", 6],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\n4\\n- raise 'foo'\"         => [\"foo\", 7],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\#{''}\\n- raise 'foo'\"      => [\"foo\", 6],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\#{''}\\n4\\n- raise 'foo'\"   => [\"foo\", 7],\n    \"foo\\n:plain\\n  1\\n  2\\n  \\#{raise 'foo'}\"             => [\"foo\", 5],\n    \"= raise 'foo'\\nfoo\\nbar\\nbaz\\nbang\"                   => [\"foo\", 1],\n    \"- case 1\\n\\n- when 1\\n  - raise 'foo'\"                => [\"foo\", 4],\n  }\n\n  User = Struct.new('User', :id)\n  class CustomHamlClass < Struct.new(:id)\n    def haml_object_ref\n      \"my_thing\"\n    end\n  end\n  CpkRecord = Struct.new('CpkRecord', :id) do\n    def to_key\n      [*self.id] unless id.nil?\n    end\n  end\n\n  def use_test_tracing(options)\n    unless options[:filename]\n      # use caller method name as fake filename. useful for debugging\n      i = -1\n      caller[i+=1] =~ /`(.+?)'/ until $1 and $1.index('test_') == 0\n      options[:filename] = \"(#{$1})\"\n    end\n    options\n  end\n\n  def render(text, options = {}, &block)\n    options = use_test_tracing(options)\n    options = options.merge(ugly: true)\n    super\n  end\n\n  def engine(text, options = {})\n    options = use_test_tracing(options)\n    Haml::Engine.new(text, options.merge(ugly: true))\n  end\n\n  def setup\n    @old_default_internal = Encoding.default_internal\n    silence_warnings{Encoding.default_internal = nil}\n  end\n\n  def teardown\n    silence_warnings{Encoding.default_internal = @old_default_internal}\n  end\n\n  def test_empty_render\n    assert_equal \"\", render(\"\")\n  end\n\n  def test_flexible_tabulation\n    assert_equal(\"<p>\\nfoo\\n</p>\\n<q>\\nbar\\n<a>\\nbaz\\n</a>\\n</q>\\n\",\n                 render(\"%p\\n foo\\n%q\\n bar\\n %a\\n  baz\"))\n    assert_equal(\"<p>\\nfoo\\n</p>\\n<q>\\nbar\\n<a>\\nbaz\\n</a>\\n</q>\\n\",\n                 render(\"%p\\n\\tfoo\\n%q\\n\\tbar\\n\\t%a\\n\\t\\tbaz\"))\n    assert_equal(\"<p>\\n    \\t \\t bar\\n baz\\n</p>\\n\",\n                 render(\"%p\\n  :plain\\n        \\t \\t bar\\n     baz\"))\n  end\n\n  def test_empty_render_should_remain_empty\n    assert_equal('', render(''))\n  end\n\n  def test_attributes_should_render_correctly\n    assert_equal(\"<div class='atlantis' style='ugly'></div>\", render(\".atlantis{:style => 'ugly'}\").chomp)\n  end\n\n  def test_css_id_as_attribute_should_be_appended_with_underscore\n    assert_equal(\"<div id='my_id_1'></div>\", render(\"#my_id{:id => '1'}\").chomp)\n    assert_equal(\"<div id='my_id_1'></div>\", render(\"#my_id{:id => 1}\").chomp)\n  end\n\n  def test_ruby_code_should_work_inside_attributes\n    assert_equal(\"<p class='3'>foo</p>\", render(\"%p{:class => 1+2} foo\").chomp)\n  end\n\n  def test_class_attr_with_array\n    assert_equal(\"<p class='a b'>foo</p>\\n\", render(\"%p{:class => %w[a b]} foo\")) # basic\n    assert_equal(\"<p class='a b css'>foo</p>\\n\", render(\"%p.css{:class => %w[a b]} foo\")) # merge with css\n    assert_equal(\"<p class='b css'>foo</p>\\n\", render(\"%p.css{:class => %w[css b]} foo\")) # merge uniquely\n    assert_equal(\"<p class='a b c d'>foo</p>\\n\", render(\"%p{:class => [%w[a b], %w[c d]]} foo\")) # flatten\n    assert_equal(\"<p class='a b'>foo</p>\\n\", render(\"%p{:class => [:a, :b] } foo\")) # stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:class => [nil, false] } foo\")) # strip falsey\n    assert_equal(\"<p class='a'>foo</p>\\n\", render(\"%p{:class => :a} foo\")) # single stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:class => false} foo\")) # single falsey\n    assert_equal(\"<p class='a b html'>foo</p>\\n\", render(\"%p(class='html'){:class => %w[a b]} foo\")) # html attrs\n  end\n\n  def test_id_attr_with_array\n    assert_equal(\"<p id='a_b'>foo</p>\\n\", render(\"%p{:id => %w[a b]} foo\")) # basic\n    assert_equal(\"<p id='css_a_b'>foo</p>\\n\", render(\"%p#css{:id => %w[a b]} foo\")) # merge with css\n    assert_equal(\"<p id='a_b_c_d'>foo</p>\\n\", render(\"%p{:id => [%w[a b], %w[c d]]} foo\")) # flatten\n    assert_equal(\"<p id='a_b'>foo</p>\\n\", render(\"%p{:id => [:a, :b] } foo\")) # stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:id => [nil, false] } foo\")) # strip falsey\n    assert_equal(\"<p id='a'>foo</p>\\n\", render(\"%p{:id => :a} foo\")) # single stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:id => false} foo\")) # single falsey\n    assert_equal(\"<p id='html_a_b'>foo</p>\\n\", render(\"%p(id='html'){:id => %w[a b]} foo\")) # html attrs\n  end\n\n  def test_colon_in_class_attr\n    assert_equal(\"<p class='foo:bar'>\\n\", render(\"%p.foo:bar/\"))\n  end\n\n  def test_colon_in_id_attr\n    assert_equal(\"<p id='foo:bar'>\\n\", render(\"%p#foo:bar/\"))\n  end\n\n  def test_dynamic_attributes_with_no_content\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n<a href='http://haml.info'></a>\n</p>\nHTML\n%p\n  %a{:href => \"http://\" + \"haml.info\"}\nHAML\n  end\n\n  def test_attributes_with_to_s\n    assert_equal(<<HTML, render(<<HAML))\n<p id='foo_2'></p>\n<p class='2 foo'></p>\n<p blaz='2'></p>\n<p 2='2'></p>\nHTML\n%p#foo{:id => 1+1}\n%p.foo{:class => 1+1}\n%p{:blaz => 1+1}\n%p{(1+1) => 1+1}\nHAML\n  end\n\n  def test_nil_should_render_empty_tag\n    assert_equal(\"<div class='no_attributes'></div>\",\n                 render(\".no_attributes{:nil => nil}\").chomp)\n  end\n\n  def test_strings_should_get_stripped_inside_tags\n    assert_equal(\"<div class='stripped'>This should have no spaces in front of it</div>\",\n                 render(\".stripped    This should have no spaces in front of it\").chomp)\n  end\n\n  def test_one_liner_should_be_one_line\n    assert_equal(\"<p>Hello</p>\", render('%p Hello').chomp)\n  end\n\n  def test_one_liner_with_newline_shouldnt_be_one_line\n    assert_equal(\"<p>foo\\nbar</p>\", render('%p= \"foo\\nbar\"').chomp)\n  end\n\n  def test_multi_render\n    engine = engine(\"%strong Hi there!\")\n    assert_equal(\"<strong>Hi there!</strong>\\n\", engine.to_html)\n    assert_equal(\"<strong>Hi there!</strong>\\n\", engine.to_html)\n    assert_equal(\"<strong>Hi there!</strong>\\n\", engine.to_html)\n  end\n\n  def test_interpolation\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #{who}', locals: {who: 'World'}, escape_html: false))\n    assert_equal(\"<p>\\nHello World\\n</p>\\n\", render(\"%p\\n  Hello \\#{who}\", locals: {who: 'World'}, escape_html: false))\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #{who}', locals: {who: 'World'}, escape_html: true))\n    assert_equal(\"<p>\\nHello World\\n</p>\\n\", render(\"%p\\n  Hello \\#{who}\", locals: {who: 'World'}, escape_html: true))\n  end\n\n  def test_interpolation_with_instance_var\n    scope = Object.new\n    scope.instance_variable_set(:@who, 'World')\n\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #@who', scope: scope, escape_html: false))\n    assert_equal(\"<p>\\nHello World\\n</p>\\n\", render(\"%p\\n  Hello \\#@who\", scope: scope, escape_html: false))\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #@who', scope: scope, escape_html: true))\n    assert_equal(\"<p>\\nHello World\\n</p>\\n\", render(\"%p\\n  Hello \\#@who\", scope: scope, escape_html: true))\n  end\n\n  def test_interpolation_with_global\n    $global_var_for_testing = 'World'\n\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #$global_var_for_testing', escape_html: false))\n    assert_equal(\"<p>\\nHello World\\n</p>\\n\", render(\"%p\\n  Hello \\#$global_var_for_testing\", escape_html: false))\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #$global_var_for_testing', escape_html: true))\n    assert_equal(\"<p>\\nHello World\\n</p>\\n\", render(\"%p\\n  Hello \\#$global_var_for_testing\", escape_html: true))\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_interpolation_in_the_middle_of_a_string\n    assert_equal(\"\\\"title 'Title'. \\\"\\n\",\n                 render(\"\\\"title '\\#{\\\"Title\\\"}'. \\\"\"))\n  end\n\n  def test_interpolation_with_instance_var_in_the_middle_of_a_string\n    scope = Object.new\n    scope.instance_variable_set(:@title, 'Title')\n\n    assert_equal(\"\\\"title 'Title'. \\\"\\n\",\n                 render(\"\\\"title '\\#@title'. \\\"\",  :scope => scope))\n  end\n\n  def test_interpolation_with_global_in_the_middle_of_a_string\n    $global_var_for_testing = 'Title'\n\n    assert_equal(\"\\\"title 'Title'. \\\"\\n\",\n                 render(\"\\\"title '\\#$global_var_for_testing'. \\\"\"))\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_interpolation_at_the_beginning_of_a_line\n    assert_equal(\"<p>2</p>\\n\", render('%p #{1 + 1}'))\n    assert_equal(\"<p>\\n2\\n</p>\\n\", render(\"%p\\n  \\#{1 + 1}\"))\n  end\n\n  def test_interpolation_with_instance_var_at_the_beginning_of_a_line\n    scope = Object.new\n    scope.instance_variable_set(:@foo, 2)\n\n    assert_equal(\"<p>2</p>\\n\", render('%p #@foo', :scope => scope))\n    assert_equal(\"<p>\\n2\\n</p>\\n\", render(\"%p\\n  \\#@foo\", :scope => scope))\n  end\n\n  def test_interpolation_with_global_at_the_beginning_of_a_line\n    $global_var_for_testing = 2\n\n    assert_equal(\"<p>2</p>\\n\", render('%p #$global_var_for_testing'))\n    assert_equal(\"<p>\\n2\\n</p>\\n\", render(\"%p\\n  \\#$global_var_for_testing\"))\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_escaped_interpolation\n    assert_equal(\"<p>Foo &amp; Bar & Baz</p>\\n\", render('%p& Foo #{\"&\"} Bar & Baz'))\n  end\n\n  def test_nil_tag_value_should_render_as_empty\n    assert_equal(\"<p></p>\\n\", render(\"%p= nil\"))\n  end\n\n  def test_tag_with_failed_if_should_render_as_empty\n    assert_equal(\"<p></p>\\n\", render(\"%p= 'Hello' if false\"))\n  end\n\n  def test_static_attributes_with_empty_attr\n    assert_equal(\"<img alt='' src='/foo.png'>\\n\", render(\"%img{:src => '/foo.png', :alt => ''}\"))\n  end\n\n  def test_dynamic_attributes_with_empty_attr\n    assert_equal(\"<img alt='' src='/foo.png'>\\n\", render(\"%img{:width => nil, :src => '/foo.png', :alt => String.new}\"))\n  end\n\n  def test_attribute_hash_with_newlines\n    assert_equal(\"<p a='b' c='d'>foop</p>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd'} foop\"))\n    assert_equal(\"<p a='b' c='d'>\\nfoop\\n</p>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd'}\\n  foop\"))\n    assert_equal(\"<p a='b' c='d'>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd'}/\"))\n    assert_equal(\"<p a='b' c='d' e='f'></p>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd',\\n   :e => 'f'}\"))\n  end\n\n  def test_attr_hashes_not_modified\n    hash = {:color => 'red'}\n    assert_equal(<<HTML, render(<<HAML, :locals => {:hash => hash}))\n<div color='red'></div>\n<div class='special' color='red'></div>\n<div color='red'></div>\nHTML\n%div{hash}\n.special{hash}\n%div{hash}\nHAML\n    assert_equal(hash, {:color => 'red'})\n  end\n\n  def test_ugly_semi_prerendered_tags\n    assert_equal(<<HTML, render(<<HAML, :ugly => true))\n<p a='2'></p>\n<p a='2'>foo</p>\n<p a='2'>\n<p a='2'>foo</p>\n<p a='2'>foo\nbar</p>\n<p a='2'>foo\nbar</p>\n<p a='2'>\nfoo\n</p>\nHTML\n%p{:a => 1 + 1}\n%p{:a => 1 + 1} foo\n%p{:a => 1 + 1}/\n%p{:a => 1 + 1}= \"foo\"\n%p{:a => 1 + 1}= \"foo\\\\nbar\"\n%p{:a => 1 + 1}~ \"foo\\\\nbar\"\n%p{:a => 1 + 1}\n  foo\nHAML\n  end\n\n  def test_end_of_file_multiline\n    assert_equal(\"<p>0</p>\\n<p>1</p>\\n<p>2</p>\\n\", render(\"- for i in (0...3)\\n  %p= |\\n   i |\"))\n  end\n\n  def test_cr_newline\n    assert_equal(\"<p>foo</p>\\n<p>bar</p>\\n<p>baz</p>\\n<p>boom</p>\\n\", render(\"%p foo\\r%p bar\\r\\n%p baz\\n\\r%p boom\"))\n  end\n\n  def test_textareas\n    assert_equal(\"<textarea>Foo\\n  bar\\n   baz</textarea>\\n\",\n                 render('%textarea= \"Foo\\n  bar\\n   baz\"'))\n\n    assert_equal(\"<pre>Foo\\n  bar\\n   baz</pre>\\n\",\n                 render('%pre= \"Foo\\n  bar\\n   baz\"'))\n\n    assert_equal(\"<textarea>#{'a' * 100}</textarea>\\n\",\n                 render(\"%textarea #{'a' * 100}\"))\n\n    assert_equal(\"<p>\\n<textarea>Foo\\nBar\\nBaz</textarea>\\n</p>\\n\", render(<<SOURCE))\n%p\n  %textarea\n    Foo\n    Bar\n    Baz\nSOURCE\n  end\n\n  def test_pre_code\n    assert_equal(<<HTML, render(<<HAML))\n<pre><code>Foo&#x000A;  bar&#x000A;    baz</code></pre>\nHTML\n%pre\n  %code\n    :preserve\n      Foo\n        bar\n          baz\nHAML\n  end\n\n  def test_boolean_attributes\n    assert_equal(\"<p bar baz='true' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => true, :baz => 'true'}\", :format => :html4))\n    assert_equal(\"<p bar='bar' baz='true' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => true, :baz => 'true'}\", :format => :xhtml))\n\n    assert_equal(\"<p baz='false' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => false, :baz => 'false'}\", :format => :html4))\n    assert_equal(\"<p baz='false' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => false, :baz => 'false'}\", :format => :xhtml))\n  end\n\n  def test_nuke_inner_whitespace_in_loops\n    assert_equal(<<HTML, render(<<HAML))\n<ul>foobarbaz</ul>\nHTML\n%ul<\n  - for str in %w[foo bar baz]\n    = str\nHAML\n  end\n\n  def test_both_whitespace_nukes_work_together\n    assert_equal(<<RESULT, render(<<SOURCE))\n<p><q>Foo\nBar</q></p>\nRESULT\n%p\n  %q><= \"Foo\\\\nBar\"\nSOURCE\n  end\n\n  def test_nil_option\n    assert_equal(\"<p foo='bar'></p>\\n\", render('%p{:foo => \"bar\"}', :attr_wrapper => nil))\n  end\n\n  def test_comment_with_crazy_nesting\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nbar\nHTML\nfoo\n-#\n  ul\n    %li{\n  foo\nbar\nHAML\n  end\n\n  # Regression tests\n\n  def test_indentation_after_dynamic_attr_hash\n    assert_equal(<<HTML, render(<<HAML))\n<html>\n<body>\n<img src='test'>\nfoo\nbar\n</body>\n</html>\nHTML\n%html\n  %body\n    %img{:src => 'te'+'st'}\n    = \"foo\\\\nbar\"\nHAML\n  end\n\n  def test_whitespace_nuke_with_both_newlines\n    assert_equal(\"<p>\\nfoo\\n</p>\\n\", render('%p<= \"\\nfoo\\n\"'))\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n<p>\nfoo\n</p>\n</p>\nHTML\n%p\n  %p<= \"\\\\nfoo\\\\n\"\nHAML\n  end\n\n  def test_whitespace_nuke_with_tags_and_else\n    assert_equal(<<HTML, render(<<HAML))\n<a>\n<b>foo</b>\n</a>\nHTML\n%a\n  %b<\n    - if false\n      = \"foo\"\n    - else\n      foo\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\n<a>\n<b>\nfoo\n</b>\n</a>\nHTML\n%a\n  %b\n    - if false\n      = \"foo\"\n    - else\n      foo\nHAML\n  end\n\n  def test_outer_whitespace_nuke_with_empty_script\n    assert_equal(<<HTML, render(<<HAML))\n<p>\nfoo  <a></a></p>\nHTML\n%p\n  foo\n  = \"  \"\n  %a>\nHAML\n  end\n\n  def test_both_case_indentation_work_with_deeply_nested_code\n    result = <<RESULT\n<h2>\nother\n</h2>\nRESULT\n    assert_equal(result, render(<<HAML))\n- case 'other'\n- when 'test'\n  %h2\n    hi\n- when 'other'\n  %h2\n    other\nHAML\n    assert_equal(result, render(<<HAML))\n- case 'other'\n  - when 'test'\n    %h2\n      hi\n  - when 'other'\n    %h2\n      other\nHAML\n  end\n\n  def test_equals_block_with_ugly\n    assert_equal(\"foo\\n\", render(<<HAML, :ugly => true))\n= capture_haml do\n  foo\nHAML\n  end\n\n  def test_plain_equals_with_ugly\n    assert_equal(\"foo\\nbar\\n\", render(<<HAML, :ugly => true))\n= \"foo\"\nbar\nHAML\n  end\n\n  def test_inline_if\n    assert_equal(<<HTML, render(<<HAML))\n<p>One</p>\n<p></p>\n<p>Three</p>\nHTML\n- for name in [\"One\", \"Two\", \"Three\"]\n  %p= name unless name == \"Two\"\nHAML\n  end\n\n  def test_end_with_method_call\n    assert_equal(\"2|3|4b-a-r\", render(<<HAML))\n= [1, 2, 3].map do |i|\n  - i + 1\n- end.join(\"|\")\n= \"bar\".gsub(/./) do |s|\n  - s + \"-\"\n- end.gsub(/-$/) do |s|\n  - ''\nHAML\n  end\n\n  def test_nested_end_with_method_call\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n2|3|4b-a-r</p>\nHTML\n%p\n  = [1, 2, 3].map do |i|\n    - i + 1\n  - end.join(\"|\")\n  = \"bar\".gsub(/./) do |s|\n    - s + \"-\"\n  - end.gsub(/-$/) do |s|\n    - ''\nHAML\n  end\n\n  def test_silent_end_with_stuff\n    assert_equal(<<HTML, render(<<HAML))\ne\nd\nc\nb\na\nHTML\n- str = \"abcde\"\n- if true\n  = str.slice!(-1).chr\n- end until str.empty?\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\n<p>hi!</p>\nHTML\n- if true\n  %p hi!\n- end if \"foo\".gsub(/f/) do\n  - \"z\"\n- end + \"bar\"\nHAML\n  end\n\n  def test_multiline_with_colon_after_filter\n    assert_equal(<<HTML, render(<<HAML))\nFoo\nBar\nHTML\n:plain\n  Foo\n= { :a => \"Bar\",      |\n    :b => \"Baz\" }[:a] |\nHAML\n    assert_equal(<<HTML, render(<<HAML))\n\nBar\nHTML\n:plain\n= { :a => \"Bar\",      |\n    :b => \"Baz\" }[:a] |\nHAML\n  end\n\n  def test_multiline_in_filter\n    assert_equal(<<HTML, render(<<HAML))\nFoo |\nBar |\nBaz\nHTML\n:plain\n  Foo |\n  Bar |\n  Baz\nHAML\n  end\n\n  def test_curly_brace\n    assert_equal(<<HTML, render(<<HAML))\nFoo { Bar\nHTML\n== Foo { Bar\nHAML\n  end\n\n  def test_escape_attrs_false\n    assert_equal(<<HTML, render(<<HAML, :escape_attrs => false))\n<div class='<?php echo \"&quot;\" ?>' id='foo'>\nbar\n</div>\nHTML\n#foo{:class => '<?php echo \"&quot;\" ?>'}\n  bar\nHAML\n  end\n\n  def test_escape_attrs_always\n    assert_equal(<<HTML, render(<<HAML, :escape_attrs => :always))\n<div class='\"&amp;lt;&amp;gt;&amp;amp;\"' id='foo'>\nbar\n</div>\nHTML\n#foo{:class => '\"&lt;&gt;&amp;\"'}\n  bar\nHAML\n  end\n\n  def test_escape_html\n    html = <<HTML\n&amp;\n&\n&amp;\nHTML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n&= \"&\"\n!= \"&\"\n= \"&\"\nHAML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n&~ \"&\"\n!~ \"&\"\n~ \"&\"\nHAML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n& \\#{\"&\"}\n! \\#{\"&\"}\n\\#{\"&\"}\nHAML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n&== \\#{\"&\"}\n!== \\#{\"&\"}\n== \\#{\"&\"}\nHAML\n\n    tag_html = <<HTML\n<p>&amp;</p>\n<p>&</p>\n<p>&amp;</p>\nHTML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p&= \"&\"\n%p!= \"&\"\n%p= \"&\"\nHAML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p&~ \"&\"\n%p!~ \"&\"\n%p~ \"&\"\nHAML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p& \\#{\"&\"}\n%p! \\#{\"&\"}\n%p \\#{\"&\"}\nHAML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p&== \\#{\"&\"}\n%p!== \\#{\"&\"}\n%p== \\#{\"&\"}\nHAML\n  end\n\n  def test_new_attrs_with_hash\n    assert_equal(\"<a href='#'></a>\\n\", render('%a(href=\"#\")'))\n  end\n\n  def test_silent_script_with_hyphen_case\n    assert_equal(\"\", render(\"- a = 'foo-case-bar-case'\"))\n  end\n\n  def test_silent_script_with_hyphen_end\n    assert_equal(\"\", render(\"- a = 'foo-end-bar-end'\"))\n  end\n\n  def test_silent_script_with_hyphen_end_and_block\n    silence_warnings do\n      assert_equal(<<HTML, render(<<HAML))\n<p>foo-end</p>\n<p>bar-end</p>\nHTML\n- (\"foo-end-bar-end\".gsub(/\\\\w+-end/) do |s|\n  %p= s\n- end; nil)\nHAML\n    end\n  end\n\n  def test_if_without_content_and_else\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- if false\n- else\n  foo\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- if true\n  - if false\n  - else\n    foo\nHAML\n  end\n\n  def test_html_attributes_with_hash\n    assert_equal(\"<a href='#' rel='top'>Foo</a>\\n\",\n      render('%a(href=\"#\" rel=\"top\") Foo'))\n    assert_equal(\"<a href='#'>Foo</a>\\n\",\n      render('%a(href=\"#\") #{\"Foo\"}'))\n\n    assert_equal(\"<a href='#\\\"'></a>\\n\", render('%a(href=\"#\\\\\"\")'))\n  end\n\n  def test_case_assigned_to_var\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- var = case 12\n- when 1; \"foo\"\n- when 12; \"bar\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- var = case 12\n- when 1\n  - \"foo\"\n- when 12\n  - \"bar\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- var = case 12\n  - when 1\n    - \"foo\"\n  - when 12\n    - \"bar\"\n= var\nHAML\n  end\n\n  def test_nested_case_assigned_to_var\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- if true\n  - var = case 12\n  - when 1; \"foo\"\n  - when 12; \"bar\"\n  = var\nHAML\n  end\n\n  def test_case_assigned_to_multiple_vars\n    assert_equal(<<HTML, render(<<HAML))\nbar\nbip\nHTML\n- var, vip = case 12\n- when 1; [\"foo\", \"baz\"]\n- when 12; [\"bar\", \"bip\"]\n= var\n= vip\nHAML\n  end\n\n  def test_if_assigned_to_var\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- var = if false\n- else\n  - \"foo\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- var = if false\n- elsif 12 == 12\n  - \"foo\"\n- elsif 14 == 14; \"bar\"\n- else\n  - \"baz\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- var = if false\n  - \"bar\"\n- else\n  - \"foo\"\n= var\nHAML\n  end\n\n  def test_case_with_newline_after_case\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- case 1\n\n  - when 1\n    foo\n  - when 2\n    bar\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- case 2\n\n- when 1\n  foo\n- when 2\n  bar\nHAML\n  end\n\n  def test_escape_html_with_interpolated_if_statement\n    assert_equal(<<HTML, render(<<HAML, :escape_html => true))\nfoo,\nHTML\nfoo\\#{\",\" if true}\nHAML\n  end\n\n  # HTML escaping tests\n\n  def test_ampersand_equals_should_escape\n    assert_equal(\"<p>\\nfoo &amp; bar\\n</p>\\n\", render(\"%p\\n  &= 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_ampersand_equals_inline_should_escape\n    assert_equal(\"<p>foo &amp; bar</p>\\n\", render(\"%p&= 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_ampersand_equals_should_escape_before_preserve\n    assert_equal(\"<textarea>foo\\nbar</textarea>\\n\", render('%textarea&= \"foo\\nbar\"', :escape_html => false))\n  end\n\n  def test_bang_equals_should_not_escape\n    assert_equal(\"<p>\\nfoo & bar\\n</p>\\n\", render(\"%p\\n  != 'foo & bar'\", :escape_html => true))\n  end\n\n  def test_bang_equals_inline_should_not_escape\n    assert_equal(\"<p>foo & bar</p>\\n\", render(\"%p!= 'foo & bar'\", :escape_html => true))\n  end\n\n  def test_static_attributes_should_be_escaped\n    assert_equal(\"<img class='atlantis' style='ugly&amp;stupid'>\\n\",\n                 render(\"%img.atlantis{:style => 'ugly&stupid'}\"))\n    assert_equal(\"<div class='atlantis' style='ugly&amp;stupid'>foo</div>\\n\",\n                 render(\".atlantis{:style => 'ugly&stupid'} foo\"))\n    assert_equal(\"<p class='atlantis' style='ugly&amp;stupid'>foo</p>\\n\",\n                render(\"%p.atlantis{:style => 'ugly&stupid'}= 'foo'\"))\n    assert_equal(\"<p class='atlantis' style='ugly&#x000A;stupid'></p>\\n\",\n                render(\"%p.atlantis{:style => \\\"ugly\\\\nstupid\\\"}\"))\n  end\n\n  def test_dynamic_attributes_should_be_escaped\n    assert_equal(\"<img alt='' src='&amp;foo.png'>\\n\",\n                 render(\"%img{:width => nil, :src => '&foo.png', :alt => String.new}\"))\n    assert_equal(\"<p alt='' src='&amp;foo.png'>foo</p>\\n\",\n                 render(\"%p{:width => nil, :src => '&foo.png', :alt => String.new} foo\"))\n    assert_equal(\"<div alt='' src='&amp;foo.png'>foo</div>\\n\",\n                 render(\"%div{:width => nil, :src => '&foo.png', :alt => String.new}= 'foo'\"))\n    assert_equal(\"<img alt='' src='foo&#x000A;.png'>\\n\",\n                 render(\"%img{:width => nil, :src => \\\"foo\\\\n.png\\\", :alt => String.new}\"))\n  end\n\n  def test_string_double_equals_should_be_esaped\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_inline_string_double_equals\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p&== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p&== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_inline_string_double_equals\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p!== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p!== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_string_double_equals\n    assert_equal(\"<p>\\n4&&lt;\\n</p>\\n\", render(\"%p\\n  &== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n4&&lt;\\n</p>\\n\", render(\"%p\\n  &== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_string_double_equals\n    assert_equal(\"<p>\\n4&<\\n</p>\\n\", render(\"%p\\n  !== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n4&<\\n</p>\\n\", render(\"%p\\n  !== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_string_interpolation_should_be_esaped\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_inline_string_interpolation\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p& \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p& \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_inline_string_interpolation\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p! \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p! \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_string_interpolation\n    assert_equal(\"<p>\\n4&&lt;\\n</p>\\n\", render(\"%p\\n  & \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n4&&lt;\\n</p>\\n\", render(\"%p\\n  & \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_string_interpolation_with_no_space\n    assert_equal(\"&lt;br&gt;\\n\", render('&#{\"<br>\"}'))\n    assert_equal(\"<span>&lt;br&gt;</span>\\n\", render('%span&#{\"<br>\"}'))\n  end\n\n  def test_unescaped_string_interpolation\n    assert_equal(\"<p>\\n4&<\\n</p>\\n\", render(\"%p\\n  ! \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n4&<\\n</p>\\n\", render(\"%p\\n  ! \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_string_interpolation_with_no_space\n    assert_equal(\"<br>\\n\", render('!#{\"<br>\"}'))\n    assert_equal(\"<span><br></span>\\n\", render('%span!#{\"<br>\"}'))\n  end\n\n  def test_scripts_should_respect_escape_html_option\n    assert_equal(\"<p>\\nfoo &amp; bar\\n</p>\\n\", render(\"%p\\n  = 'foo & bar'\", :escape_html => true))\n    assert_equal(\"<p>\\nfoo & bar\\n</p>\\n\", render(\"%p\\n  = 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_inline_scripts_should_respect_escape_html_option\n    assert_equal(\"<p>foo &amp; bar</p>\\n\", render(\"%p= 'foo & bar'\", :escape_html => true))\n    assert_equal(\"<p>foo & bar</p>\\n\", render(\"%p= 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_script_ending_in_comment_should_render_when_html_is_escaped\n    assert_equal(\"foo&amp;bar\\n\", render(\"= 'foo&bar' #comment\", :escape_html => true))\n  end\n\n  def test_script_with_if_shouldnt_output\n    assert_equal(<<HTML, render(<<HAML))\n<p>foo</p>\n<p></p>\nHTML\n%p= \"foo\"\n%p= \"bar\" if false\nHAML\n  end\n\n  # Options tests\n\n  def test_filename_and_line\n    begin\n      render(\"\\n\\n = abc\", :filename => 'test', :line => 2)\n    rescue Exception => e\n      assert_kind_of Haml::SyntaxError, e\n      assert_match(/test:4/, e.backtrace.first)\n    end\n\n    begin\n      render(\"\\n\\n= 123\\n\\n= nil[]\", :filename => 'test', :line => 2)\n    rescue Exception => e\n      assert_kind_of NoMethodError, e\n      backtrace = e.backtrace\n      backtrace.shift if rubinius?\n      assert_match(/test:6/, backtrace.first)\n    end\n  end\n\n  def test_stop_eval\n    assert_equal(\"\", render(\"= 'Hello'\", :suppress_eval => true))\n    assert_equal(\"\", render(\"- haml_concat 'foo'\", :suppress_eval => true))\n    assert_equal(\"<div id='foo' yes='no'>\\n\", render(\"#foo{:yes => 'no'}/\", :suppress_eval => true))\n    assert_equal(\"<div id='foo'>\\n\", render(\"#foo{:yes => 'no', :call => a_function() }/\", :suppress_eval => true))\n    assert_equal(\"<div>\\n\", render(\"%div[1]/\", :suppress_eval => true))\n    assert_equal(\"\", render(\":ruby\\n  Kernel.puts 'hello'\", :suppress_eval => true))\n  end\n\n  def test_doctypes\n    assert_equal('<!DOCTYPE html>',\n      render('!!!', :format => :html5).strip)\n    assert_equal('<!DOCTYPE html>', render('!!! 5').strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">',\n      render('!!! strict', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">',\n      render('!!! frameset', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\">',\n      render('!!! mobile', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">',\n      render('!!! basic', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">',\n      render('!!! transitional', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">',\n      render('!!!', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">',\n      render('!!! strict', :format => :html4).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">',\n      render('!!! frameset', :format => :html4).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">',\n      render('!!! transitional', :format => :html4).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">',\n      render('!!!', :format => :html4).strip)\n  end\n\n  def test_attr_wrapper\n    assert_equal(\"<p strange=*attrs*></p>\\n\", render(\"%p{ :strange => 'attrs'}\", :attr_wrapper => '*'))\n    assert_equal(\"<p escaped='quo\\\"te'></p>\\n\", render(\"%p{ :escaped => 'quo\\\"te'}\", :attr_wrapper => '\"'))\n    assert_equal(\"<p escaped=\\\"quo&#039;te\\\"></p>\\n\", render(\"%p{ :escaped => 'quo\\\\'te'}\", :attr_wrapper => '\"'))\n    assert_equal(\"<p escaped='q&#039;uo\\\"te'></p>\\n\", render(\"%p{ :escaped => 'q\\\\'uo\\\"te'}\", :attr_wrapper => '\"'))\n    assert_equal(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\\n\", render(\"!!! XML\", :attr_wrapper => '\"', :format => :xhtml))\n  end\n\n  def test_autoclose_option\n    assert_equal(\"<flaz foo='bar'>\\n\", render(\"%flaz{:foo => 'bar'}\", :autoclose => [\"flaz\"]))\n    assert_equal(<<HTML, render(<<HAML, :autoclose => [/^flaz/]))\n<flaz>\n<flaznicate>\n<flan></flan>\nHTML\n%flaz\n%flaznicate\n%flan\nHAML\n  end\n\n  def test_attrs_parsed_correctly\n    assert_equal(\"<p boom=>biddly='bar =&gt; baz'></p>\\n\", render(\"%p{'boom=>biddly' => 'bar => baz'}\"))\n    assert_equal(\"<p foo,bar='baz, qux'></p>\\n\", render(\"%p{'foo,bar' => 'baz, qux'}\"))\n    assert_equal(\"<p escaped='quo&#x000A;te'></p>\\n\", render(\"%p{ :escaped => \\\"quo\\\\nte\\\"}\"))\n    assert_equal(\"<p escaped='quo4te'></p>\\n\", render(\"%p{ :escaped => \\\"quo\\#{2 + 2}te\\\"}\"))\n  end\n\n  def test_correct_parsing_with_brackets\n    assert_equal(\"<p class='foo'>{tada} foo</p>\\n\", render(\"%p{:class => 'foo'} {tada} foo\"))\n    assert_equal(\"<p class='foo'>deep {nested { things }}</p>\\n\", render(\"%p{:class => 'foo'} deep {nested { things }}\"))\n    assert_equal(\"<p class='bar foo'>{a { d</p>\\n\", render(\"%p{{:class => 'foo'}, :class => 'bar'} {a { d\"))\n    assert_equal(\"<p foo='bar'>a}</p>\\n\", render(\"%p{:foo => 'bar'} a}\"))\n\n    foo = []\n    foo[0] = Struct.new('Foo', :id).new\n    assert_equal(\"<p class='struct_foo' id='struct_foo_new'>New User]</p>\\n\",\n                 render(\"%p[foo[0]] New User]\", :locals => {:foo => foo}))\n    assert_equal(\"<p class='prefix_struct_foo' id='prefix_struct_foo_new'>New User]</p>\\n\",\n                 render(\"%p[foo[0], :prefix] New User]\", :locals => {:foo => foo}))\n\n    foo[0].id = 1\n    assert_equal(\"<p class='struct_foo' id='struct_foo_1'>New User]</p>\\n\",\n                 render(\"%p[foo[0]] New User]\", :locals => {:foo => foo}))\n    assert_equal(\"<p class='prefix_struct_foo' id='prefix_struct_foo_1'>New User]</p>\\n\",\n                 render(\"%p[foo[0], :prefix] New User]\", :locals => {:foo => foo}))\n  end\n\n  def test_empty_attrs\n    assert_equal(\"<p attr=''>empty</p>\\n\", render(\"%p{ :attr => '' } empty\"))\n    assert_equal(\"<p attr=''>empty</p>\\n\", render(\"%p{ :attr => x } empty\", :locals => {:x => ''}))\n  end\n\n  def test_nil_attrs\n    assert_equal(\"<p>nil</p>\\n\", render(\"%p{ :attr => nil } nil\"))\n    assert_equal(\"<p>nil</p>\\n\", render(\"%p{ :attr => x } nil\", :locals => {:x => nil}))\n  end\n\n  def test_nil_id_with_syntactic_id\n    assert_equal(\"<p id='foo'>nil</p>\\n\", render(\"%p#foo{:id => nil} nil\"))\n    assert_equal(\"<p id='foo_bar'>nil</p>\\n\", render(\"%p#foo{{:id => 'bar'}, :id => nil} nil\"))\n    assert_equal(\"<p id='foo_bar'>nil</p>\\n\", render(\"%p#foo{{:id => nil}, :id => 'bar'} nil\"))\n  end\n\n  def test_nil_class_with_syntactic_class\n    assert_equal(\"<p class='foo'>nil</p>\\n\", render(\"%p.foo{:class => nil} nil\"))\n    assert_equal(\"<p class='bar foo'>nil</p>\\n\", render(\"%p.bar.foo{:class => nil} nil\"))\n    assert_equal(\"<p class='bar foo'>nil</p>\\n\", render(\"%p.foo{{:class => 'bar'}, :class => nil} nil\"))\n    assert_equal(\"<p class='bar foo'>nil</p>\\n\", render(\"%p.foo{{:class => nil}, :class => 'bar'} nil\"))\n  end\n\n  def test_locals\n    assert_equal(\"<p>Paragraph!</p>\\n\", render(\"%p= text\", :locals => { :text => \"Paragraph!\" }))\n  end\n\n  def test_dynamic_attrs_shouldnt_register_as_literal_values\n    assert_equal(\"<p a='b2c'></p>\\n\", render('%p{:a => \"b#{1 + 1}c\"}'))\n    assert_equal(\"<p a='b2c'></p>\\n\", render(\"%p{:a => 'b' + (1 + 1).to_s + 'c'}\"))\n  end\n\n  def test_dynamic_attrs_with_self_closed_tag\n    assert_equal(\"<a b='2'>\\nc\\n\", render(\"%a{'b' => 1 + 1}/\\n= 'c'\\n\"))\n  end\n\n  EXCEPTION_MAP.each do |key, value|\n    define_method(\"test_exception (#{key.inspect})\") do\n      begin\n        silence_warnings do\n          render(key, :filename => \"(test_exception (#{key.inspect}))\")\n        end\n      rescue Exception => err\n        value = [value] unless value.is_a?(Array)\n        expected_message, line_no = value\n        line_no ||= key.split(\"\\n\").length\n\n\n        if expected_message == :compile\n          assert_match(/(compile error|syntax error|unterminated string|expecting)/, err.message, \"Line: #{key}\")\n        else\n          assert_equal(expected_message, err.message, \"Line: #{key}\")\n        end\n\n      else\n        assert(false, \"Exception not raised for\\n#{key}\")\n      end\n    end\n  end\n\n  def test_exception_line\n    render(\"a\\nb\\n!!!\\n  c\\nd\")\n  rescue Haml::SyntaxError => e\n    assert_equal(\"(test_exception_line):4\", e.backtrace[0])\n  else\n    assert(false, '\"a\\nb\\n!!!\\n  c\\nd\" doesn\\'t produce an exception')\n  end\n\n  def test_exception\n    render(\"%p\\n  hi\\n  %a= undefined\\n= 12\")\n  rescue Exception => e\n    backtrace = e.backtrace\n    backtrace.shift if rubinius?\n    assert_match(\"(test_exception):3\", backtrace[0])\n  else\n    # Test failed... should have raised an exception\n    assert(false)\n  end\n\n  def test_compile_error\n    render(\"a\\nb\\n- fee)\\nc\")\n  rescue Exception => e\n    assert_match(/\\(test_compile_error\\):3:/i, e.message)\n    assert_match(/(syntax error|expecting \\$end)/i, e.message)\n  else\n    assert(false, '\"a\\nb\\n- fee)\\nc\" doesn\\'t produce an exception!')\n  end\n\n  def test_unbalanced_brackets\n    render('foo #{1 + 5} foo #{6 + 7 bar #{8 + 9}')\n  rescue Haml::SyntaxError => e\n    assert_equal(Haml::Error.message(:unbalanced_brackets), e.message)\n  end\n\n  def test_single_line_comments_are_interpolated\n    assert_equal(\"<!-- Hello 2 -->\\n\",\n                 render('/ Hello #{1 + 1}'))\n  end\n\n  def test_single_line_comments_are_not_interpolated_with_suppress_eval\n    assert_equal(\"<!--  -->\\n\",\n                 render('/ Hello #{1 + 1}', :suppress_eval => true))\n  end\n\n  def test_single_line_comments_with_interpolation_dont_break_tabulation\n    assert_equal(\"<!-- Hello 2 -->\\nconcatted\\n\",\n                 render(\"/ Hello \\#{1 + 1}\\n- haml_concat 'concatted'\"))\n  end\n\n  def test_balanced_conditional_comments\n    assert_equal(\"<!--[if !(IE 6)|(IE 7)]> Bracket: ] <![endif]-->\\n\",\n                 render(\"/[if !(IE 6)|(IE 7)] Bracket: ]\"))\n  end\n\n  def test_downlevel_revealed_conditional_comments\n    assert_equal(\"<!--[if !IE]><!--> A comment <!--<![endif]-->\\n\",\n                  render(\"/![if !IE] A comment\"))\n  end\n\n  def test_downlevel_revealed_conditional_comments_block\n    assert_equal(\"<!--[if !IE]><!-->\\nA comment\\n<!--<![endif]-->\\n\",\n                  render(\"/![if !IE]\\n  A comment\"))\n  end\n\n  def test_local_assigns_dont_modify_class\n    assert_equal(\"bar\\n\", render(\"= foo\", :locals => {:foo => 'bar'}))\n    assert_nil(defined?(foo))\n  end\n\n  def test_object_ref_with_nil_id\n    user = User.new\n    assert_equal(\"<p class='struct_user' id='struct_user_new'>New User</p>\\n\",\n                 render(\"%p[user] New User\", :locals => {:user => user}))\n  end\n\n  def test_object_ref_before_attrs\n    user = User.new 42\n    assert_equal(\"<p class='struct_user' id='struct_user_42' style='width: 100px;'>New User</p>\\n\",\n                 render(\"%p[user]{:style => 'width: 100px;'} New User\", :locals => {:user => user}))\n  end\n\n  def test_object_ref_with_custom_haml_class\n    custom = CustomHamlClass.new 42\n    assert_equal(\"<p class='my_thing' id='my_thing_42' style='width: 100px;'>My Thing</p>\\n\",\n                 render(\"%p[custom]{:style => 'width: 100px;'} My Thing\", :locals => {:custom => custom}))\n  end\n\n  def test_object_ref_with_multiple_ids\n    cpk_record = CpkRecord.new([42,6,9])\n    assert_equal(\"<p class='struct_cpk_record' id='struct_cpk_record_42_6_9' style='width: 100px;'>CPK Record</p>\\n\",\n                 render(\"%p[cpk_record]{:style => 'width: 100px;'} CPK Record\", :locals => {:cpk_record => cpk_record}))\n  end\n\n  def test_non_literal_attributes\n    assert_equal(\"<p a1='foo' a2='bar' a3='baz'></p>\\n\",\n                 render(\"%p{a2, a1, :a3 => 'baz'}\",\n                        :locals => {:a1 => {:a1 => 'foo'}, :a2 => {:a2 => 'bar'}}))\n  end\n\n  def test_render_should_accept_a_binding_as_scope\n    string = \"This is a string!\"\n    string.instance_variable_set(:@var, \"Instance variable\")\n    b = string.instance_eval do\n      var = \"Local variable\"\n      # Silence unavoidable warning; Ruby doesn't know we're going to use this\n      # later.\n      nil if var\n      binding\n    end\n\n    assert_equal(\"<p>THIS IS A STRING!</p>\\n<p>Instance variable</p>\\n<p>Local variable</p>\\n\",\n                 render(\"%p= upcase\\n%p= @var\\n%p= var\", :scope => b))\n  end\n\n  def test_yield_should_work_with_binding\n    assert_equal(\"12\\nFOO\\n\", render(\"= yield\\n= upcase\", :scope => \"foo\".instance_eval{binding}) { 12 })\n  end\n\n  def test_yield_should_work_with_def_method\n    s = \"foo\"\n    engine(\"= yield\\n= upcase\").def_method(s, :render)\n    assert_equal(\"12\\nFOO\\n\", s.render { 12 })\n  end\n\n  def test_def_method_with_module\n    engine(\"= yield\\n= upcase\").def_method(String, :render_haml)\n    assert_equal(\"12\\nFOO\\n\", \"foo\".render_haml { 12 })\n  end\n\n  def test_def_method_locals\n    obj = Object.new\n    engine(\"%p= foo\\n.bar{:baz => baz}= boom\").def_method(obj, :render, :foo, :baz, :boom)\n    assert_equal(\"<p>1</p>\\n<div baz='2' class='bar'>3</div>\\n\", obj.render(:foo => 1, :baz => 2, :boom => 3))\n  end\n\n  def test_render_proc_locals\n    proc = engine(\"%p= foo\\n.bar{:baz => baz}= boom\").render_proc(Object.new, :foo, :baz, :boom)\n    assert_equal(\"<p>1</p>\\n<div baz='2' class='bar'>3</div>\\n\", proc[:foo => 1, :baz => 2, :boom => 3])\n  end\n\n  def test_render_proc_with_binding\n    assert_equal(\"FOO\\n\", engine(\"= upcase\").render_proc(\"foo\".instance_eval{binding}).call)\n  end\n\n  def test_haml_buffer_gets_reset_even_with_exception\n    scope = Object.new\n    render(\"- raise Haml::Error\", :scope => scope)\n    assert(false, \"Expected exception\")\n  rescue Exception\n    assert_nil(scope.send(:haml_buffer))\n  end\n\n  def test_def_method_haml_buffer_gets_reset_even_with_exception\n    scope = Object.new\n    engine(\"- raise Haml::Error\").def_method(scope, :render)\n    scope.render\n    assert(false, \"Expected exception\")\n  rescue Exception\n    assert_nil(scope.send(:haml_buffer))\n  end\n\n  def test_render_proc_haml_buffer_gets_reset_even_with_exception\n    scope = Object.new\n    proc = engine(\"- raise Haml::Error\").render_proc(scope)\n    proc.call\n    assert(false, \"Expected exception\")\n  rescue Exception\n    assert_nil(scope.send(:haml_buffer))\n  end\n\n  def test_render_proc_should_raise_haml_syntax_error_not_ruby_syntax_error\n    assert_raises(Haml::SyntaxError) do\n      Haml::Engine.new(\"%p{:foo => !}\").render_proc(Object.new, :foo).call\n    end\n  end\n\n  def test_render_should_raise_haml_syntax_error_not_ruby_syntax_error\n    assert_raises(Haml::SyntaxError) do\n      Haml::Engine.new(\"%p{:foo => !}\").render\n    end\n  end\n\n  def test_ugly_true\n    assert_equal(\"<div id='outer'>\\n<div id='inner'>\\n<p>hello world</p>\\n</div>\\n</div>\\n\",\n                 render(\"#outer\\n  #inner\\n    %p hello world\", :ugly => true))\n\n    assert_equal(\"<p>#{'s' * 75}</p>\\n\",\n                 render(\"%p #{'s' * 75}\", :ugly => true))\n\n    assert_equal(\"<p>#{'s' * 75}</p>\\n\",\n                 render(\"%p= 's' * 75\", :ugly => true))\n  end\n\n  def test_remove_whitespace_true\n    assert_equal(\"<div id='outer'><div id='inner'><p>hello world</p></div></div>\",\n                 render(\"#outer\\n  #inner\\n    %p hello world\", :remove_whitespace => true))\n    assert_equal(\"<p>hello world<pre>foo   bar\\nbaz</pre></p>\", render(<<HAML, :remove_whitespace => true))\n%p\n  hello world\n  %pre\n    foo   bar\n    baz\nHAML\n    assert_equal(\"<div><span>foo</span> <span>bar</span></div>\",\n                 render('%div <span>foo</span> <span>bar</span>', :remove_whitespace => true))\n  end\n\n  def test_auto_preserve\n    assert_equal(\"<pre>foo\\nbar</pre>\\n\", render('%pre=\"foo\\nbar\"', ugly: true))\n    assert_equal(\"<pre>foo\\nbar</pre>\\n\", render(\"%pre\\n  foo\\n  bar\", ugly: true))\n  end\n\n  def test_xhtml_output_option\n    assert_equal \"<p>\\n<br />\\n</p>\\n\", render(\"%p\\n  %br\", :format => :xhtml)\n    assert_equal \"<a />\\n\", render(\"%a/\", :format => :xhtml)\n  end\n\n  def test_arbitrary_output_option\n    assert_raises_message(Haml::Error, \"Invalid output format :html1\") do\n      engine(\"%br\", :format => :html1)\n    end\n  end\n\n  def test_static_hashes\n    assert_equal(\"<a b='a =&gt; b'></a>\\n\", render(\"%a{:b => 'a => b'}\", :suppress_eval => true))\n    assert_equal(\"<a b='a, b'></a>\\n\", render(\"%a{:b => 'a, b'}\", :suppress_eval => true))\n    assert_equal(\"<a b='a\\tb'></a>\\n\", render('%a{:b => \"a\\tb\"}', :suppress_eval => true))\n    assert_equal(\"<a b='a\\#{foo}b'></a>\\n\", render('%a{:b => \"a\\\\#{foo}b\"}', :suppress_eval => true))\n    assert_equal(\"<a b='#f00'></a>\\n\", render(\"%a{:b => '#f00'}\", :suppress_eval => true))\n  end\n\n  def test_dynamic_hashes_with_suppress_eval\n    assert_equal(\"<a></a>\\n\", render('%a{:b => \"a #{1 + 1} b\", :c => \"d\"}', :suppress_eval => true))\n  end\n\n  def test_interpolates_instance_vars_in_attribute_values\n    scope = Object.new\n    scope.instance_variable_set :@foo, 'bar'\n    assert_equal(\"<a b='a bar b'></a>\\n\", render('%a{:b => \"a #@foo b\"}', :scope => scope))\n  end\n\n  def test_interpolates_global_vars_in_attribute_values\n    # make sure the value isn't just interpolated in during template compilation\n    engine = Haml::Engine.new('%a{:b => \"a #$global_var_for_testing b\"}')\n    $global_var_for_testing = 'bar'\n    assert_equal(\"<a b='a bar b'></a>\\n\", engine.to_html)\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_utf8_attrs\n    assert_equal(\"<a href='h\u00e9llo'></a>\\n\", render(\"%a{:href => 'h\u00e9llo'}\"))\n    assert_equal(\"<a href='h\u00e9llo'></a>\\n\", render(\"%a(href='h\u00e9llo')\"))\n  end\n\n  # HTML 4.0\n\n  def test_html_has_no_self_closing_tags\n    assert_equal \"<p>\\n<br>\\n</p>\\n\", render(\"%p\\n  %br\", :format => :html4)\n    assert_equal \"<br>\\n\", render(\"%br/\", :format => :html4)\n  end\n\n  def test_html_renders_empty_node_with_closing_tag\n    assert_equal \"<div class='foo'></div>\\n\", render(\".foo\", :format => :html4)\n  end\n\n  def test_html_doesnt_add_slash_to_self_closing_tags\n    assert_equal \"<a>\\n\", render(\"%a/\", :format => :html4)\n    assert_equal \"<a foo='2'>\\n\", render(\"%a{:foo => 1 + 1}/\", :format => :html4)\n    assert_equal \"<meta>\\n\", render(\"%meta\", :format => :html4)\n    assert_equal \"<meta foo='2'>\\n\", render(\"%meta{:foo => 1 + 1}\", :format => :html4)\n  end\n\n  def test_html_ignores_xml_prolog_declaration\n    assert_equal \"\", render('!!! XML', :format => :html4)\n  end\n\n  def test_html_has_different_doctype\n    assert_equal %{<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\\n},\n    render('!!!', :format => :html4)\n  end\n\n  # because anything before the doctype triggers quirks mode in IE\n  def test_xml_prolog_and_doctype_dont_result_in_a_leading_whitespace_in_html\n    refute_match(/^\\s+/, render(\"!!! xml\\n!!!\", :format => :html4))\n  end\n\n  # HTML5\n  def test_html5_doctype\n    assert_equal %{<!DOCTYPE html>\\n}, render('!!!', :format => :html5)\n  end\n\n  # HTML5 custom data attributes\n  def test_html5_data_attributes_without_hyphenation\n    assert_equal(\"<div data-author_id='123' data-biz='baz' data-foo='bar'></div>\\n\",\n      render(\"%div{:data => {:author_id => 123, :foo => 'bar', :biz => 'baz'}}\",\n        :hyphenate_data_attrs => false))\n\n    assert_equal(\"<div data-one_plus_one='2'></div>\\n\",\n      render(\"%div{:data => {:one_plus_one => 1+1}}\",\n        :hyphenate_data_attrs => false))\n\n    assert_equal(\"<div data-foo='Here&#039;s a \\\"quoteful\\\" string.'></div>\\n\",\n      render(%{%div{:data => {:foo => %{Here's a \"quoteful\" string.}}}},\n        :hyphenate_data_attrs => false)) #'\n  end\n\n  def test_html5_data_attributes_with_hyphens\n    assert_equal(\"<div data-foo-bar='blip'></div>\\n\",\n      render(\"%div{:data => {:foo_bar => 'blip'}}\"))\n    assert_equal(\"<div data-baz='bang' data-foo-bar='blip'></div>\\n\",\n      render(\"%div{:data => {:foo_bar => 'blip', :baz => 'bang'}}\"))\n  end\n\n\tdef test_html5_arbitrary_hash_valued_attributes_with\n    assert_equal(\"<div aria-foo='blip'></div>\\n\",\n      render(\"%div{:aria => {:foo => 'blip'}}\"))\n    assert_equal(\"<div foo-baz='bang'></div>\\n\",\n      render(\"%div{:foo => {:baz => 'bang'}}\"))\n\tend\n\n  def test_arbitrary_attribute_hash_merging\n    assert_equal(%Q{<a aria-baz='qux' aria-foo='bar'></a>\\n}, render(<<-HAML))\n- h1 = {:aria => {:foo => :bar}}\n- h2 = {:baz => :qux}\n%a{h1, :aria => h2}\nHAML\n  end\n\n\n  def test_html5_data_attributes_with_nested_hash\n    assert_equal(\"<div data-a-b='c'></div>\\n\", render(<<-HAML))\n- hash = {:a => {:b => 'c'}}\n- hash[:d] = hash\n%div{:data => hash}\nHAML\n  end\n\n  def test_html5_data_attributes_with_nested_hash_and_without_hyphenation\n    assert_equal(\"<div data-a_b='c'></div>\\n\", render(<<-HAML, :hyphenate_data_attrs => false))\n- hash = {:a => {:b => 'c'}}\n- hash[:d] = hash\n%div{:data => hash}\nHAML\n  end\n\n  def test_html5_data_attributes_with_multiple_defs\n    # Should always use the more-explicit attribute\n    assert_equal(\"<div data-foo='second'></div>\\n\",\n      render(\"%div{:data => {:foo => 'first'}, 'data-foo' => 'second'}\"))\n    assert_equal(\"<div data-foo='first'></div>\\n\",\n      render(\"%div{'data-foo' => 'first', :data => {:foo => 'second'}}\"))\n  end\n\n  def test_html5_data_attributes_with_attr_method\n    obj = Object.new\n    def obj.data_hash\n      {:data => {:foo => \"bar\", :baz => \"bang\"}}\n    end\n\n    def obj.data_val\n      {:data => \"dat\"}\n    end\n\n    assert_equal(\"<div data-baz='bang' data-brat='wurst' data-foo='blip'></div>\\n\",\n      render(\"%div{data_hash, :data => {:foo => 'blip', :brat => 'wurst'}}\", scope: obj))\n    assert_equal(\"<div data-baz='bang' data-foo='blip'></div>\\n\",\n      render(\"%div{data_hash, 'data-foo' => 'blip'}\", scope: obj))\n    assert_equal(\"<div data-baz='bang' data-foo='bar' data='dat'></div>\\n\",\n      render(\"%div{data_hash, :data => 'dat'}\", scope: obj))\n    assert_equal(\"<div data-brat='wurst' data-foo='blip' data='dat'></div>\\n\",\n      render(\"%div{data_val, :data => {:foo => 'blip', :brat => 'wurst'}}\", scope: obj))\n  end\n\n  def test_html5_data_attributes_with_identical_attribute_values\n    assert_equal(\"<div data-x='50' data-y='50'></div>\\n\",\n      render(\"%div{:data => {:x => 50, :y => 50}}\"))\n  end\n\n  def test_xml_doc_using_html5_format_and_mime_type\n    assert_equal(<<XML, render(<<HAML, { :format => :html5, :mime_type => 'text/xml' }))\n<?xml version='1.0' encoding='utf-8' ?>\n<root>\n<element />\n<hr />\n</root>\nXML\n!!! XML\n%root\n  %element/\n  %hr\nHAML\n  end\n\n  def test_xml_doc_using_html4_format_and_mime_type\n    assert_equal(<<XML, render(<<HAML, { :format => :html4, :mime_type => 'text/xml' }))\n<?xml version='1.0' encoding='utf-8' ?>\n<root>\n<element />\n<hr />\n</root>\nXML\n!!! XML\n%root\n  %element/\n  %hr\nHAML\n  end\n\n  # New attributes\n\n  def test_basic_new_attributes\n    assert_equal(\"<a>bar</a>\\n\", render(\"%a() bar\"))\n    assert_equal(\"<a href='foo'>bar</a>\\n\", render(\"%a(href='foo') bar\"))\n    assert_equal(\"<a b='c' c='d' d='e'>baz</a>\\n\", render(%q{%a(b=\"c\" c='d' d=\"e\") baz}))\n  end\n\n  def test_new_attribute_ids\n    assert_equal(\"<div id='foo_bar'></div>\\n\", render(\"#foo(id='bar')\"))\n    assert_equal(\"<div id='foo_baz_bar'></div>\\n\", render(\"#foo{:id => 'bar'}(id='baz')\"))\n    assert_equal(\"<div id='foo_baz_bar'></div>\\n\", render(\"#foo(id='baz'){:id => 'bar'}\"))\n    foo = User.new(42)\n    assert_equal(\"<div class='struct_user' id='foo_baz_bar_struct_user_42'></div>\\n\",\n      render(\"#foo(id='baz'){:id => 'bar'}[foo]\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='struct_user' id='foo_baz_bar_struct_user_42'></div>\\n\",\n      render(\"#foo(id='baz')[foo]{:id => 'bar'}\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='struct_user' id='foo_baz_bar_struct_user_42'></div>\\n\",\n      render(\"#foo[foo](id='baz'){:id => 'bar'}\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='struct_user' id='foo_baz_bar_struct_user_42'></div>\\n\",\n      render(\"#foo[foo]{:id => 'bar'}(id='baz')\", :locals => {:foo => foo}))\n  end\n\n  def test_new_attribute_classes\n    assert_equal(\"<div class='bar foo'></div>\\n\", render(\".foo(class='bar')\"))\n    assert_equal(\"<div class='bar baz foo'></div>\\n\", render(\".foo{:class => 'bar'}(class='baz')\"))\n    assert_equal(\"<div class='bar baz foo'></div>\\n\", render(\".foo(class='baz'){:class => 'bar'}\"))\n    foo = User.new(42)\n    assert_equal(\"<div class='bar baz foo struct_user' id='struct_user_42'></div>\\n\",\n      render(\".foo(class='baz'){:class => 'bar'}[foo]\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='bar baz foo struct_user' id='struct_user_42'></div>\\n\",\n      render(\".foo[foo](class='baz'){:class => 'bar'}\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='bar baz foo struct_user' id='struct_user_42'></div>\\n\",\n      render(\".foo[foo]{:class => 'bar'}(class='baz')\", :locals => {:foo => foo}))\n  end\n\n  def test_dynamic_new_attributes\n    assert_equal(\"<a href='12'>bar</a>\\n\", render(\"%a(href=foo) bar\", :locals => {:foo => 12}))\n    assert_equal(\"<a b='12' c='13' d='14'>bar</a>\\n\", render(\"%a(b=b c='13' d=d) bar\", :locals => {:b => 12, :d => 14}))\n  end\n\n  def test_new_attribute_interpolation\n    assert_equal(\"<a href='12'>bar</a>\\n\", render('%a(href=\"1#{1 + 1}\") bar'))\n    assert_equal(\"<a href='2: 2, 3: 3'>bar</a>\\n\", render(%q{%a(href='2: #{1 + 1}, 3: #{foo}') bar}, :locals => {:foo => 3}))\n    assert_equal(%Q{<a href='1\\#{1 + 1}'>bar</a>\\n}, render('%a(href=\"1\\#{1 + 1}\") bar'))\n  end\n\n  def test_truthy_new_attributes\n    assert_equal(\"<a href='href'>bar</a>\\n\", render(\"%a(href) bar\", :format => :xhtml))\n    assert_equal(\"<a bar='baz' href>bar</a>\\n\", render(\"%a(href bar='baz') bar\", :format => :html5))\n    assert_equal(\"<a href>bar</a>\\n\", render(\"%a(href=true) bar\"))\n    assert_equal(\"<a>bar</a>\\n\", render(\"%a(href=false) bar\"))\n  end\n\n  def test_new_attribute_parsing\n    assert_equal(\"<a a2='b2'>bar</a>\\n\", render(\"%a(a2=b2) bar\", :locals => {:b2 => 'b2'}))\n    assert_equal(%Q{<a a='foo\"bar'>bar</a>\\n}, render(%q{%a(a=\"#{'foo\"bar'}\") bar})) #'\n    assert_equal(%Q{<a a='foo&#039;bar'>bar</a>\\n}, render(%q{%a(a=\"#{\"foo'bar\"}\") bar})) #'\n    assert_equal(%Q{<a a='foo\"bar'>bar</a>\\n}, render(%q{%a(a='foo\"bar') bar}))\n    assert_equal(%Q{<a a='foo&#039;bar'>bar</a>\\n}, render(%q{%a(a=\"foo'bar\") bar}))\n    assert_equal(\"<a a:b='foo'>bar</a>\\n\", render(\"%a(a:b='foo') bar\"))\n    assert_equal(\"<a a='foo' b='bar'>bar</a>\\n\", render(\"%a(a = 'foo' b = 'bar') bar\"))\n    assert_equal(\"<a a='foo' b='bar'>bar</a>\\n\", render(\"%a(a = foo b = bar) bar\", :locals => {:foo => 'foo', :bar => 'bar'}))\n    assert_equal(\"<a a='foo'>(b='bar')</a>\\n\", render(\"%a(a='foo')(b='bar')\"))\n    assert_equal(\"<a a='foo)bar'>baz</a>\\n\", render(\"%a(a='foo)bar') baz\"))\n    assert_equal(\"<a a='foo'>baz</a>\\n\", render(\"%a( a = 'foo' ) baz\"))\n  end\n\n  def test_new_attribute_escaping\n    assert_equal(%Q{<a a='foo \" bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\\" bar\") bar}))\n    assert_equal(%Q{<a a='foo \\\\\" bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\\\\\\\\\\" bar\") bar}))\n\n    assert_equal(%Q{<a a='foo &#039; bar'>bar</a>\\n}, render(%q{%a(a='foo \\' bar') bar}))\n    assert_equal(%Q{<a a='foo \\\\&#039; bar'>bar</a>\\n}, render(%q{%a(a='foo \\\\\\\\\\' bar') bar}))\n\n    assert_equal(%Q{<a a='foo \\\\ bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\\\\\\\ bar\") bar}))\n    assert_equal(%Q{<a a='foo \\#{1 + 1} bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\#{1 + 1} bar\") bar}))\n  end\n\n  def test_multiline_new_attribute\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a(a='b'\\n  c='d') bar\"))\n    assert_equal(\"<a a='b' b='c' c='d' d='e' e='f' f='j'>bar</a>\\n\",\n      render(\"%a(a='b' b='c'\\n  c='d' d=e\\n  e='f' f='j') bar\", :locals => {:e => 'e'}))\n  end\n\n  def test_new_and_old_attributes\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a(a='b'){:c => 'd'} bar\"))\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a{:c => 'd'}(a='b') bar\"))\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a(c='d'){:a => 'b'} bar\"))\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a{:a => 'b'}(c='d') bar\"))\n\n    # Old-style always takes precedence over new-style,\n    # because theoretically old-style could have arbitrary end-of-method-call syntax.\n    assert_equal(\"<a a='b'>bar</a>\\n\", render(\"%a{:a => 'b'}(a='d') bar\"))\n    assert_equal(\"<a a='b'>bar</a>\\n\", render(\"%a(a='d'){:a => 'b'} bar\"))\n\n    assert_equal(\"<a a='b' b='c' c='d' d='e'>bar</a>\\n\",\n      render(\"%a{:a => 'b',\\n:b => 'c'}(c='d'\\nd='e') bar\"))\n\n    locals = {:b => 'b', :d => 'd'}\n    assert_equal(\"<p a='b' c='d'></p>\\n\", render(\"%p{:a => b}(c=d)\", :locals => locals))\n    assert_equal(\"<p a='b' c='d'></p>\\n\", render(\"%p(a=b){:c => d}\", :locals => locals))\n\n    assert_equal(\"<p id='b_d'></p>\\n<p id='b_d'></p>\\n\", render(\"%p(id=b){id:d}\\n%p(id=b){id:d}\", locals: locals))\n  end\n\n  # Ruby Multiline\n\n  def test_silent_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\nbar, baz, bang\n<p>foo</p>\nHTML\n- foo = [\"bar\",\n         \"baz\",\n         \"bang\"]\n= foo.join(\", \")\n%p foo\nHAML\n  end\n\n  def test_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\nbar, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n= [\"bar\",\n   \"baz\",\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_with_punctuated_methods_is_continuation\n    assert_equal(<<HTML, render(<<HAML))\nbar, , true, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n= [\"bar\",\n   \"  \".strip!,\n   \"\".empty?,\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_character_literals_are_not_continuation\n    html = \",\\n,\\n<p>foo</p>\\n\"\n    assert_equal(html, render(<<HAML))\n= ?,\n= ?\\,\n%p foo\nHAML\n  end\n\n  def test_escaped_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\nbar&lt;, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n&= [\"bar<\",\n    \"baz\",\n    \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_unescaped_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML, :escape_html => true))\nbar<, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n!= [\"bar<\",\n    \"baz\",\n    \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_flattened_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\n<pre>bar&#x000A;baz&#x000A;bang</pre>\n<p>foo</p>\n<p>bar</p>\nHTML\n~ \"<pre>\" + [\"bar\",\n             \"baz\",\n             \"bang\"].join(\"\\\\n\") + \"</pre>\"\n%p foo\n%p bar\nHAML\n  end\n\n  def test_loud_ruby_multiline_with_block\n    assert_equal(<<HTML, render(<<HAML))\n#{%w[far faz fang]}<p>foo</p>\n<p>bar</p>\nHTML\n= [\"bar\",\n   \"baz\",\n   \"bang\"].map do |str|\n  - str.gsub(\"ba\",\n             \"fa\")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_silent_ruby_multiline_with_block\n    assert_equal(<<HTML, render(<<HAML))\nfar\nfaz\nfang\n<p>foo</p>\n<p>bar</p>\nHTML\n- [\"bar\",\n   \"baz\",\n   \"bang\"].map do |str|\n  = str.gsub(\"ba\",\n             \"fa\")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_in_tag\n    assert_equal(<<HTML, render(<<HAML))\n<p>foo, bar, baz</p>\n<p>foo</p>\n<p>bar</p>\nHTML\n%p= [\"foo\",\n     \"bar\",\n     \"baz\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_escaped_ruby_multiline_in_tag\n    assert_equal(<<HTML, render(<<HAML))\n<p>foo&lt;, bar, baz</p>\n<p>foo</p>\n<p>bar</p>\nHTML\n%p&= [\"foo<\",\n      \"bar\",\n      \"baz\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_unescaped_ruby_multiline_in_tag\n    assert_equal(<<HTML, render(<<HAML, :escape_html => true))\n<p>foo<, bar, baz</p>\n<p>foo</p>\n<p>bar</p>\nHTML\n%p!= [\"foo<\",\n      \"bar\",\n      \"baz\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_with_normal_multiline\n    assert_equal(<<HTML, render(<<HAML))\nfoobarbar, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n= \"foo\" + |\n  \"bar\" + |\n  [\"bar\", |\n   \"baz\",\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_after_filter\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nbar\nbar, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n:plain\n  foo\n  bar\n= [\"bar\",\n   \"baz\",\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  # Encodings\n\n  def test_utf_8_bom\n    assert_equal <<HTML, render(<<HAML)\n<div class='foo'>\n<p>baz</p>\n</div>\nHTML\n\\xEF\\xBB\\xBF.foo\n  %p baz\nHAML\n  end\n\n  def test_default_encoding\n    assert_equal(Encoding.find(\"utf-8\"), render(<<HAML.encode(\"us-ascii\")).encoding)\n%p bar\n%p foo\nHAML\n  end\n\n  def test_fake_ascii_encoding\n    assert_encoded_equal(<<HTML.force_encoding(\"ascii-8bit\"), render(<<HAML, :encoding => \"ascii-8bit\"))\n<p>b\u00e2r</p>\n<p>f\u00f6\u00f6</p>\nHTML\n%p b\u00e2r\n%p f\u00f6\u00f6\nHAML\n  end\n\n  def test_convert_template_render_proc\n    assert_converts_template_properly {|e| e.render_proc.call}\n  end\n\n  def test_convert_template_render\n    assert_converts_template_properly {|e| e.render}\n  end\n\n  def test_convert_template_def_method\n    assert_converts_template_properly do |e|\n      o = Object.new\n      e.def_method(o, :render)\n      o.render\n    end\n  end\n\n  def test_encoding_error\n    render(\"foo\\nbar\\nb\\xFEaz\".force_encoding(\"utf-8\"))\n    assert(false, \"Expected exception\")\n  rescue Haml::Error => e\n    assert_equal(3, e.line)\n    assert_match(/Invalid .* character/, e.message)\n  end\n\n  def test_ascii_incompatible_encoding_error\n    template = \"foo\\nbar\\nb_z\".encode(\"utf-16le\")\n    template[9] = \"\\xFE\".force_encoding(\"utf-16le\")\n    render(template)\n    assert(false, \"Expected exception\")\n  rescue Haml::Error => e\n    assert_equal(3, e.line)\n    assert_match(/Invalid .* character/, e.message)\n  end\n\n  def test_same_coding_comment_as_encoding\n    assert_renders_encoded(<<HTML, <<HAML)\n<p>b\u00e2r</p>\n<p>f\u00f6\u00f6</p>\nHTML\n-# coding: utf-8\n%p b\u00e2r\n%p f\u00f6\u00f6\nHAML\n  end\n\n  def test_coding_comments\n    assert_valid_encoding_comment(\"-# coding: ibm866\")\n    assert_valid_encoding_comment(\"-# CodINg: IbM866\")\n    assert_valid_encoding_comment(\"-#coding:ibm866\")\n    assert_valid_encoding_comment(\"-# CodINg= ibm866\")\n    assert_valid_encoding_comment(\"-# foo BAR FAOJcoding: ibm866\")\n    assert_valid_encoding_comment(\"-# coding: ibm866 ASFJ (&(&#!$\")\n    assert_valid_encoding_comment(\"-# -*- coding: ibm866\")\n    assert_valid_encoding_comment(\"-# coding: ibm866 -*- coding: blah\")\n    assert_valid_encoding_comment(\"-# -*- coding: ibm866 -*-\")\n    assert_valid_encoding_comment(\"-# -*- encoding: ibm866 -*-\")\n    assert_valid_encoding_comment('-# -*- coding: \"ibm866\" -*-')\n    assert_valid_encoding_comment(\"-#-*-coding:ibm866-*-\")\n    assert_valid_encoding_comment(\"-#-*-coding:ibm866-*-\")\n    assert_valid_encoding_comment(\"-# -*- foo: bar; coding: ibm866; baz: bang -*-\")\n    assert_valid_encoding_comment(\"-# foo bar coding: baz -*- coding: ibm866 -*-\")\n    assert_valid_encoding_comment(\"-# -*- coding: ibm866 -*- foo bar coding: baz\")\n  end\n\n  def test_different_coding_than_system\n    assert_renders_encoded(<<HTML.encode(\"IBM866\"), <<HAML.encode(\"IBM866\"))\n<p>\u0442\u0410\u042c</p>\nHTML\n%p \u0442\u0410\u042c\nHAML\n  end\n\n  def test_block_spacing\n    begin\n      assert render(<<-HAML)\n- foo = [\"bar\", \"baz\", \"kni\"]\n- foo.each do | item |\n  = item\nHAML\n    rescue ::SyntaxError\n      flunk(\"Should not have raised syntax error\")\n    end\n  end\n\n  def test_tracing\n    result = render('%p{:class => \"hello\"}', :trace => true, :filename => 'foo').strip\n    assert_equal \"<p class='hello' data-trace='foo:1'></p>\", result\n  end\n\n  private\n\n  def assert_valid_encoding_comment(comment)\n    assert_renders_encoded(<<HTML.encode(\"IBM866\"), <<HAML.encode(\"IBM866\").force_encoding(\"UTF-8\"))\n<p>\u0416\u041b\u042b</p>\n<p>\u0442\u0410\u042c</p>\nHTML\n#{comment}\n%p \u0416\u041b\u042b\n%p \u0442\u0410\u042c\nHAML\n  end\n\n  def assert_converts_template_properly\n    engine = Haml::Engine.new(<<HAML.encode(\"iso-8859-1\"), :encoding => \"macRoman\")\n%p b\u00e2r\n%p f\u00f6\u00f6\nHAML\n    assert_encoded_equal(<<HTML.encode(\"macRoman\"), yield(engine))\n<p>b\u00e2r</p>\n<p>f\u00f6\u00f6</p>\nHTML\n  end\n\n  def assert_renders_encoded(html, haml)\n    result = render(haml)\n    assert_encoded_equal html, result\n  end\n\n  def assert_encoded_equal(expected, actual)\n    assert_equal expected.encoding, actual.encoding\n    assert_equal expected, actual\n  end\nend\n", "# -*- coding: utf-8 -*-\nrequire 'test_helper'\n\nclass PrettyEngineTest < Haml::TestCase\n  # A map of erroneous Haml documents to the error messages they should produce.\n  # The error messages may be arrays;\n  # if so, the second element should be the line number that should be reported for the error.\n  # If this isn't provided, the tests will assume the line number should be the last line of the document.\n  EXCEPTION_MAP = {\n    \"!!!\\n  a\"                                             => error(:illegal_nesting_header),\n    \"a\\n  b\"                                               => error(:illegal_nesting_plain),\n    \"/ a\\n  b\"                                             => error(:illegal_nesting_content),\n    \"% a\"                                                  => error(:invalid_tag, '% a'),\n    \"%p a\\n  b\"                                            => error(:illegal_nesting_line, 'p'),\n    \"%p=\"                                                  => error(:no_ruby_code, '='),\n    \"%p~\"                                                  => error(:no_ruby_code, '~'),\n    \"~\"                                                    => error(:no_ruby_code, '~'),\n    \"=\"                                                    => error(:no_ruby_code, '='),\n    \"%p/\\n  a\"                                             => error(:illegal_nesting_self_closing),\n    \":a\\n  b\"                                              => [error(:filter_not_defined, 'a'), 1],\n    \":a= b\"                                                => error(:invalid_filter_name, 'a= b'),\n    \".\"                                                    => error(:illegal_element),\n    \".#\"                                                   => error(:illegal_element),\n    \".{} a\"                                                => error(:illegal_element),\n    \".() a\"                                                => error(:illegal_element),\n    \".= a\"                                                 => error(:illegal_element),\n    \"%p..a\"                                                => error(:illegal_element),\n    \"%a/ b\"                                                => error(:self_closing_content),\n    \" %p foo\"                                              => error(:indenting_at_start),\n    \"  %p foo\"                                             => error(:indenting_at_start),\n    \"- end\"                                                => error(:no_end),\n    \"%p{:a => 'b',\\n:c => 'd'}/ e\"                         => [error(:self_closing_content), 2],\n    \"%p{:a => 'b',\\n:c => 'd'}=\"                           => [error(:no_ruby_code, '='), 2],\n    \"%p.{:a => 'b',\\n:c => 'd'} e\"                         => [error(:illegal_element), 1],\n    \"%p{:a => 'b',\\n:c => 'd',\\n:e => 'f'}\\n%p/ a\"         => [error(:self_closing_content), 4],\n    \"%p{:a => 'b',\\n:c => 'd',\\n:e => 'f'}\\n- raise 'foo'\" => [\"foo\", 4],\n    \"%p{:a => 'b',\\n:c => raise('foo'),\\n:e => 'f'}\"       => [\"foo\", 2],\n    \"%p{:a => 'b',\\n:c => 'd',\\n:e => raise('foo')}\"       => [\"foo\", 3],\n    \" \\n\\t\\n %p foo\"                                       => [error(:indenting_at_start), 3],\n    \"\\n\\n %p foo\"                                          => [error(:indenting_at_start), 3],\n    \"%p\\n  foo\\n foo\"                                      => [error(:inconsistent_indentation, \"1 space\", \"2 spaces\"), 3],\n    \"%p\\n  foo\\n%p\\n foo\"                                  => [error(:inconsistent_indentation, \"1 space\", \"2 spaces\"), 4],\n    \"%p\\n\\t\\tfoo\\n\\tfoo\"                                   => [error(:inconsistent_indentation, \"1 tab\", \"2 tabs\"), 3],\n    \"%p\\n  foo\\n   foo\"                                    => [error(:inconsistent_indentation, \"3 spaces\", \"2 spaces\"), 3],\n    \"%p\\n  foo\\n  %p\\n   bar\"                              => [error(:inconsistent_indentation, \"3 spaces\", \"2 spaces\"), 4],\n    \"%p\\n  :plain\\n     bar\\n   \\t  baz\"                   => [error(:inconsistent_indentation, '\"   \\t  \"', \"2 spaces\"), 4],\n    \"%p\\n  foo\\n%p\\n    bar\"                               => [error(:deeper_indenting, 2), 4],\n    \"%p\\n  foo\\n  %p\\n        bar\"                         => [error(:deeper_indenting, 3), 4],\n    \"%p\\n \\tfoo\"                                           => [error(:cant_use_tabs_and_spaces), 2],\n    \"%p(\"                                                  => error(:invalid_attribute_list, '\"(\"'),\n    \"%p(foo=)\"                                             => error(:invalid_attribute_list, '\"(foo=)\"'),\n    \"%p(foo 'bar')\"                                        => error(:invalid_attribute_list, '\"(foo \\'bar\\')\"'),\n    \"%p(foo=\\nbar)\"                                        => [error(:invalid_attribute_list, '\"(foo=\"'), 1],\n    \"%p(foo 'bar'\\nbaz='bang')\"                            => [error(:invalid_attribute_list, '\"(foo \\'bar\\'\"'), 1],\n    \"%p(foo='bar'\\nbaz 'bang'\\nbip='bop')\"                 => [error(:invalid_attribute_list, '\"(foo=\\'bar\\' baz \\'bang\\'\"'), 2],\n    \"%p{'foo' => 'bar' 'bar' => 'baz'}\"                    => :compile,\n    \"%p{:foo => }\"                                         => :compile,\n    \"%p{=> 'bar'}\"                                         => :compile,\n    \"%p{'foo => 'bar'}\"                                    => :compile,\n    \"%p{:foo => 'bar}\"                                     => :compile,\n    \"%p{:foo => 'bar\\\"}\"                                   => :compile,\n    # Regression tests\n    \"foo\\n\\n\\n  bar\"                                       => [error(:illegal_nesting_plain), 4],\n    \"%p/\\n\\n  bar\"                                         => [error(:illegal_nesting_self_closing), 3],\n    \"%p foo\\n\\n  bar\"                                      => [error(:illegal_nesting_line, 'p'), 3],\n    \"/ foo\\n\\n  bar\"                                       => [error(:illegal_nesting_content), 3],\n    \"!!!\\n\\n  bar\"                                         => [error(:illegal_nesting_header), 3],\n    \"- raise 'foo'\\n\\n\\n\\nbar\"                             => [\"foo\", 1],\n    \"= 'foo'\\n-raise 'foo'\"                                => [\"foo\", 2],\n    \"\\n\\n\\n- raise 'foo'\"                                  => [\"foo\", 4],\n    \"%p foo |\\n   bar |\\n   baz |\\nbop\\n- raise 'foo'\"     => [\"foo\", 5],\n    \"foo\\n:ruby\\n  1\\n  2\\n  3\\n- raise 'foo'\"             => [\"foo\", 6],\n    \"foo\\n:erb\\n  1\\n  2\\n  3\\n- raise 'foo'\"              => [\"foo\", 6],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\n- raise 'foo'\"            => [\"foo\", 6],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\n4\\n- raise 'foo'\"         => [\"foo\", 7],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\#{''}\\n- raise 'foo'\"      => [\"foo\", 6],\n    \"foo\\n:plain\\n  1\\n  2\\n  3\\#{''}\\n4\\n- raise 'foo'\"   => [\"foo\", 7],\n    \"foo\\n:plain\\n  1\\n  2\\n  \\#{raise 'foo'}\"             => [\"foo\", 5],\n    \"= raise 'foo'\\nfoo\\nbar\\nbaz\\nbang\"                   => [\"foo\", 1],\n    \"- case 1\\n\\n- when 1\\n  - raise 'foo'\"                => [\"foo\", 4],\n  }\n\n  PrettyUser = Struct.new('PrettyUser', :id)\n  class CustomHamlClass < Struct.new(:id)\n    def haml_object_ref\n      \"my_thing\"\n    end\n  end\n  PrettyCpkRecord = Struct.new('PrettyCpkRecord', :id) do\n    def to_key\n      [*self.id] unless id.nil?\n    end\n  end\n\n  def use_test_tracing(options)\n    unless options[:filename]\n      # use caller method name as fake filename. useful for debugging\n      i = -1\n      caller[i+=1] =~ /`(.+?)'/ until $1 and $1.index('test_') == 0\n      options[:filename] = \"(#{$1})\"\n    end\n    options\n  end\n\n  def render(text, options = {}, &block)\n    options = use_test_tracing(options)\n    super\n  end\n\n  def engine(text, options = {})\n    options = use_test_tracing(options)\n    Haml::Engine.new(text, options)\n  end\n\n  def setup\n    @old_default_internal = Encoding.default_internal\n    silence_warnings{Encoding.default_internal = nil}\n  end\n\n  def teardown\n    silence_warnings{Encoding.default_internal = @old_default_internal}\n  end\n\n  def test_empty_render\n    assert_equal \"\", render(\"\")\n  end\n\n  def test_flexible_tabulation\n    assert_equal(\"<p>\\n  foo\\n</p>\\n<q>\\n  bar\\n  <a>\\n    baz\\n  </a>\\n</q>\\n\",\n                 render(\"%p\\n foo\\n%q\\n bar\\n %a\\n  baz\"))\n    assert_equal(\"<p>\\n  foo\\n</p>\\n<q>\\n  bar\\n  <a>\\n    baz\\n  </a>\\n</q>\\n\",\n                 render(\"%p\\n\\tfoo\\n%q\\n\\tbar\\n\\t%a\\n\\t\\tbaz\"))\n    assert_equal(\"<p>\\n      \\t \\t bar\\n   baz\\n</p>\\n\",\n                 render(\"%p\\n  :plain\\n        \\t \\t bar\\n     baz\"))\n  end\n\n  def test_empty_render_should_remain_empty\n    assert_equal('', render(''))\n  end\n\n  def test_attributes_should_render_correctly\n    assert_equal(\"<div class='atlantis' style='ugly'></div>\", render(\".atlantis{:style => 'ugly'}\").chomp)\n  end\n\n  def test_css_id_as_attribute_should_be_appended_with_underscore\n    assert_equal(\"<div id='my_id_1'></div>\", render(\"#my_id{:id => '1'}\").chomp)\n    assert_equal(\"<div id='my_id_1'></div>\", render(\"#my_id{:id => 1}\").chomp)\n  end\n\n  def test_ruby_code_should_work_inside_attributes\n    assert_equal(\"<p class='3'>foo</p>\", render(\"%p{:class => 1+2} foo\").chomp)\n  end\n\n  def test_class_attr_with_array\n    assert_equal(\"<p class='a b'>foo</p>\\n\", render(\"%p{:class => %w[a b]} foo\")) # basic\n    assert_equal(\"<p class='a b css'>foo</p>\\n\", render(\"%p.css{:class => %w[a b]} foo\")) # merge with css\n    assert_equal(\"<p class='b css'>foo</p>\\n\", render(\"%p.css{:class => %w[css b]} foo\")) # merge uniquely\n    assert_equal(\"<p class='a b c d'>foo</p>\\n\", render(\"%p{:class => [%w[a b], %w[c d]]} foo\")) # flatten\n    assert_equal(\"<p class='a b'>foo</p>\\n\", render(\"%p{:class => [:a, :b] } foo\")) # stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:class => [nil, false] } foo\")) # strip falsey\n    assert_equal(\"<p class='a'>foo</p>\\n\", render(\"%p{:class => :a} foo\")) # single stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:class => false} foo\")) # single falsey\n    assert_equal(\"<p class='a b html'>foo</p>\\n\", render(\"%p(class='html'){:class => %w[a b]} foo\")) # html attrs\n  end\n\n  def test_id_attr_with_array\n    assert_equal(\"<p id='a_b'>foo</p>\\n\", render(\"%p{:id => %w[a b]} foo\")) # basic\n    assert_equal(\"<p id='css_a_b'>foo</p>\\n\", render(\"%p#css{:id => %w[a b]} foo\")) # merge with css\n    assert_equal(\"<p id='a_b_c_d'>foo</p>\\n\", render(\"%p{:id => [%w[a b], %w[c d]]} foo\")) # flatten\n    assert_equal(\"<p id='a_b'>foo</p>\\n\", render(\"%p{:id => [:a, :b] } foo\")) # stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:id => [nil, false] } foo\")) # strip falsey\n    assert_equal(\"<p id='a'>foo</p>\\n\", render(\"%p{:id => :a} foo\")) # single stringify\n    assert_equal(\"<p>foo</p>\\n\", render(\"%p{:id => false} foo\")) # single falsey\n    assert_equal(\"<p id='html_a_b'>foo</p>\\n\", render(\"%p(id='html'){:id => %w[a b]} foo\")) # html attrs\n  end\n\n  def test_colon_in_class_attr\n    assert_equal(\"<p class='foo:bar'>\\n\", render(\"%p.foo:bar/\"))\n  end\n\n  def test_colon_in_id_attr\n    assert_equal(\"<p id='foo:bar'>\\n\", render(\"%p#foo:bar/\"))\n  end\n\n  def test_dynamic_attributes_with_no_content\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n  <a href='http://haml.info'></a>\n</p>\nHTML\n%p\n  %a{:href => \"http://\" + \"haml.info\"}\nHAML\n  end\n\n  def test_attributes_with_to_s\n    assert_equal(<<HTML, render(<<HAML))\n<p id='foo_2'></p>\n<p class='2 foo'></p>\n<p blaz='2'></p>\n<p 2='2'></p>\nHTML\n%p#foo{:id => 1+1}\n%p.foo{:class => 1+1}\n%p{:blaz => 1+1}\n%p{(1+1) => 1+1}\nHAML\n  end\n\n  def test_nil_should_render_empty_tag\n    assert_equal(\"<div class='no_attributes'></div>\",\n                 render(\".no_attributes{:nil => nil}\").chomp)\n  end\n\n  def test_strings_should_get_stripped_inside_tags\n    assert_equal(\"<div class='stripped'>This should have no spaces in front of it</div>\",\n                 render(\".stripped    This should have no spaces in front of it\").chomp)\n  end\n\n  def test_one_liner_should_be_one_line\n    assert_equal(\"<p>Hello</p>\", render('%p Hello').chomp)\n  end\n\n  def test_one_liner_with_newline_shouldnt_be_one_line\n    assert_equal(\"<p>\\n  foo\\n  bar\\n</p>\", render('%p= \"foo\\nbar\"').chomp)\n  end\n\n  def test_multi_render\n    engine = engine(\"%strong Hi there!\")\n    assert_equal(\"<strong>Hi there!</strong>\\n\", engine.to_html)\n    assert_equal(\"<strong>Hi there!</strong>\\n\", engine.to_html)\n    assert_equal(\"<strong>Hi there!</strong>\\n\", engine.to_html)\n  end\n\n  def test_interpolation\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #{who}', locals: {who: 'World'}, escape_html: false))\n    assert_equal(\"<p>\\n  Hello World\\n</p>\\n\", render(\"%p\\n  Hello \\#{who}\", locals: {who: 'World'}, escape_html: false))\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #{who}', locals: {who: 'World'}, escape_html: true))\n    assert_equal(\"<p>\\n  Hello World\\n</p>\\n\", render(\"%p\\n  Hello \\#{who}\", locals: {who: 'World'}, escape_html: true))\n  end\n\n  def test_interpolation_with_instance_var\n    scope = Object.new\n    scope.instance_variable_set(:@who, 'World')\n\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #@who', scope: scope, escape_html: false))\n    assert_equal(\"<p>\\n  Hello World\\n</p>\\n\", render(\"%p\\n  Hello \\#@who\", scope: scope, escape_html: false))\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #@who', scope: scope, escape_html: true))\n    assert_equal(\"<p>\\n  Hello World\\n</p>\\n\", render(\"%p\\n  Hello \\#@who\", scope: scope, escape_html: true))\n  end\n\n  def test_interpolation_with_global\n    $global_var_for_testing = 'World'\n\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #$global_var_for_testing', escape_html: false))\n    assert_equal(\"<p>\\n  Hello World\\n</p>\\n\", render(\"%p\\n  Hello \\#$global_var_for_testing\", escape_html: false))\n    assert_equal(\"<p>Hello World</p>\\n\", render('%p Hello #$global_var_for_testing', escape_html: true))\n    assert_equal(\"<p>\\n  Hello World\\n</p>\\n\", render(\"%p\\n  Hello \\#$global_var_for_testing\", escape_html: true))\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_interpolation_in_the_middle_of_a_string\n    assert_equal(\"\\\"title 'Title'. \\\"\\n\",\n                 render(\"\\\"title '\\#{\\\"Title\\\"}'. \\\"\"))\n  end\n\n  def test_interpolation_with_instance_var_in_the_middle_of_a_string\n    scope = Object.new\n    scope.instance_variable_set(:@title, 'Title')\n\n    assert_equal(\"\\\"title 'Title'. \\\"\\n\",\n                 render(\"\\\"title '\\#@title'. \\\"\",  :scope => scope))\n  end\n\n  def test_interpolation_with_global_in_the_middle_of_a_string\n    $global_var_for_testing = 'Title'\n\n    assert_equal(\"\\\"title 'Title'. \\\"\\n\",\n                 render(\"\\\"title '\\#$global_var_for_testing'. \\\"\"))\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_interpolation_at_the_beginning_of_a_line\n    assert_equal(\"<p>2</p>\\n\", render('%p #{1 + 1}'))\n    assert_equal(\"<p>\\n  2\\n</p>\\n\", render(\"%p\\n  \\#{1 + 1}\"))\n  end\n\n  def test_interpolation_with_instance_var_at_the_beginning_of_a_line\n    scope = Object.new\n    scope.instance_variable_set(:@foo, 2)\n\n    assert_equal(\"<p>2</p>\\n\", render('%p #@foo', :scope => scope))\n    assert_equal(\"<p>\\n  2\\n</p>\\n\", render(\"%p\\n  \\#@foo\", :scope => scope))\n  end\n\n  def test_interpolation_with_global_at_the_beginning_of_a_line\n    $global_var_for_testing = 2\n\n    assert_equal(\"<p>2</p>\\n\", render('%p #$global_var_for_testing'))\n    assert_equal(\"<p>\\n  2\\n</p>\\n\", render(\"%p\\n  \\#$global_var_for_testing\"))\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_escaped_interpolation\n    assert_equal(\"<p>Foo &amp; Bar & Baz</p>\\n\", render('%p& Foo #{\"&\"} Bar & Baz'))\n  end\n\n  def test_nil_tag_value_should_render_as_empty\n    assert_equal(\"<p></p>\\n\", render(\"%p= nil\"))\n  end\n\n  def test_tag_with_failed_if_should_render_as_empty\n    assert_equal(\"<p></p>\\n\", render(\"%p= 'Hello' if false\"))\n  end\n\n  def test_static_attributes_with_empty_attr\n    assert_equal(\"<img alt='' src='/foo.png'>\\n\", render(\"%img{:src => '/foo.png', :alt => ''}\"))\n  end\n\n  def test_dynamic_attributes_with_empty_attr\n    assert_equal(\"<img alt='' src='/foo.png'>\\n\", render(\"%img{:width => nil, :src => '/foo.png', :alt => String.new}\"))\n  end\n\n  def test_attribute_hash_with_newlines\n    assert_equal(\"<p a='b' c='d'>foop</p>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd'} foop\"))\n    assert_equal(\"<p a='b' c='d'>\\n  foop\\n</p>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd'}\\n  foop\"))\n    assert_equal(\"<p a='b' c='d'>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd'}/\"))\n    assert_equal(\"<p a='b' c='d' e='f'></p>\\n\", render(\"%p{:a => 'b',\\n   :c => 'd',\\n   :e => 'f'}\"))\n  end\n\n  def test_attr_hashes_not_modified\n    hash = {:color => 'red'}\n    assert_equal(<<HTML, render(<<HAML, :locals => {:hash => hash}))\n<div color='red'></div>\n<div class='special' color='red'></div>\n<div color='red'></div>\nHTML\n%div{hash}\n.special{hash}\n%div{hash}\nHAML\n    assert_equal(hash, {:color => 'red'})\n  end\n\n  def test_ugly_semi_prerendered_tags\n    assert_equal(<<HTML, render(<<HAML, :ugly => true))\n<p a='2'></p>\n<p a='2'>foo</p>\n<p a='2'>\n<p a='2'>foo</p>\n<p a='2'>foo\nbar</p>\n<p a='2'>foo\nbar</p>\n<p a='2'>\nfoo\n</p>\nHTML\n%p{:a => 1 + 1}\n%p{:a => 1 + 1} foo\n%p{:a => 1 + 1}/\n%p{:a => 1 + 1}= \"foo\"\n%p{:a => 1 + 1}= \"foo\\\\nbar\"\n%p{:a => 1 + 1}~ \"foo\\\\nbar\"\n%p{:a => 1 + 1}\n  foo\nHAML\n  end\n\n  def test_end_of_file_multiline\n    assert_equal(\"<p>0</p>\\n<p>1</p>\\n<p>2</p>\\n\", render(\"- for i in (0...3)\\n  %p= |\\n   i |\"))\n  end\n\n  def test_cr_newline\n    assert_equal(\"<p>foo</p>\\n<p>bar</p>\\n<p>baz</p>\\n<p>boom</p>\\n\", render(\"%p foo\\r%p bar\\r\\n%p baz\\n\\r%p boom\"))\n  end\n\n  def test_textareas\n    assert_equal(\"<textarea>Foo&#x000A;  bar&#x000A;   baz</textarea>\\n\",\n                 render('%textarea= \"Foo\\n  bar\\n   baz\"'))\n\n    assert_equal(\"<pre>Foo&#x000A;  bar&#x000A;   baz</pre>\\n\",\n                 render('%pre= \"Foo\\n  bar\\n   baz\"'))\n\n    assert_equal(\"<textarea>#{'a' * 100}</textarea>\\n\",\n                 render(\"%textarea #{'a' * 100}\"))\n\n    assert_equal(\"<p>\\n  <textarea>Foo\\n  Bar\\n  Baz</textarea>\\n</p>\\n\", render(<<SOURCE))\n%p\n  %textarea\n    Foo\n    Bar\n    Baz\nSOURCE\n  end\n\n  def test_pre_code\n    assert_equal(<<HTML, render(<<HAML))\n<pre><code>Foo&#x000A;  bar&#x000A;    baz</code></pre>\nHTML\n%pre\n  %code\n    :preserve\n      Foo\n        bar\n          baz\nHAML\n  end\n\n  def test_boolean_attributes\n    assert_equal(\"<p bar baz='true' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => true, :baz => 'true'}\", :format => :html4))\n    assert_equal(\"<p bar='bar' baz='true' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => true, :baz => 'true'}\", :format => :xhtml))\n\n    assert_equal(\"<p baz='false' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => false, :baz => 'false'}\", :format => :html4))\n    assert_equal(\"<p baz='false' foo='bar'></p>\\n\",\n                 render(\"%p{:foo => 'bar', :bar => false, :baz => 'false'}\", :format => :xhtml))\n  end\n\n  def test_nuke_inner_whitespace_in_loops\n    assert_equal(<<HTML, render(<<HAML))\n<ul>foobarbaz</ul>\nHTML\n%ul<\n  - for str in %w[foo bar baz]\n    = str\nHAML\n  end\n\n  def test_both_whitespace_nukes_work_together\n    assert_equal(<<RESULT, render(<<SOURCE))\n<p><q>Foo\n  Bar</q></p>\nRESULT\n%p\n  %q><= \"Foo\\\\nBar\"\nSOURCE\n  end\n\n  def test_nil_option\n    assert_equal(\"<p foo='bar'></p>\\n\", render('%p{:foo => \"bar\"}', :attr_wrapper => nil))\n  end\n\n  def test_comment_with_crazy_nesting\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nbar\nHTML\nfoo\n-#\n  ul\n    %li{\n  foo\nbar\nHAML\n  end\n\n  # Regression tests\n\n  def test_indentation_after_dynamic_attr_hash\n    assert_equal(<<HTML, render(<<HAML))\n<html>\n  <body>\n    <img src='test'>\n    foo\n    bar\n  </body>\n</html>\nHTML\n%html\n  %body\n    %img{:src => 'te'+'st'}\n    = \"foo\\\\nbar\"\nHAML\n  end\n\n  def test_whitespace_nuke_with_both_newlines\n    assert_equal(\"<p>foo</p>\\n\", render('%p<= \"\\nfoo\\n\"'))\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n  <p>foo</p>\n</p>\nHTML\n%p\n  %p<= \"\\\\nfoo\\\\n\"\nHAML\n  end\n\n  def test_whitespace_nuke_with_tags_and_else\n    assert_equal(<<HTML, render(<<HAML))\n<a>\n  <b>foo</b>\n</a>\nHTML\n%a\n  %b<\n    - if false\n      = \"foo\"\n    - else\n      foo\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\n<a>\n  <b>\n    foo\n  </b>\n</a>\nHTML\n%a\n  %b\n    - if false\n      = \"foo\"\n    - else\n      foo\nHAML\n  end\n\n  def test_outer_whitespace_nuke_with_empty_script\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n  foo<a></a></p>\nHTML\n%p\n  foo\n  = \"  \"\n  %a>\nHAML\n  end\n\n  def test_both_case_indentation_work_with_deeply_nested_code\n    result = <<RESULT\n<h2>\n  other\n</h2>\nRESULT\n    assert_equal(result, render(<<HAML))\n- case 'other'\n- when 'test'\n  %h2\n    hi\n- when 'other'\n  %h2\n    other\nHAML\n    assert_equal(result, render(<<HAML))\n- case 'other'\n  - when 'test'\n    %h2\n      hi\n  - when 'other'\n    %h2\n      other\nHAML\n  end\n\n  def test_equals_block_with_ugly\n    assert_equal(\"foo\\n\", render(<<HAML, :ugly => true))\n= capture_haml do\n  foo\nHAML\n  end\n\n  def test_plain_equals_with_ugly\n    assert_equal(\"foo\\nbar\\n\", render(<<HAML, :ugly => true))\n= \"foo\"\nbar\nHAML\n  end\n\n  def test_inline_if\n    assert_equal(<<HTML, render(<<HAML))\n<p>One</p>\n<p></p>\n<p>Three</p>\nHTML\n- for name in [\"One\", \"Two\", \"Three\"]\n  %p= name unless name == \"Two\"\nHAML\n  end\n\n  def test_end_with_method_call\n    assert_equal(<<HTML, render(<<HAML))\n2|3|4\nb-a-r\nHTML\n= [1, 2, 3].map do |i|\n  - i + 1\n- end.join(\"|\")\n= \"bar\".gsub(/./) do |s|\n  - s + \"-\"\n- end.gsub(/-$/) do |s|\n  - ''\nHAML\n  end\n\n  def test_nested_end_with_method_call\n    assert_equal(<<HTML, render(<<HAML))\n<p>\n  2|3|4\n  b-a-r\n</p>\nHTML\n%p\n  = [1, 2, 3].map do |i|\n    - i + 1\n  - end.join(\"|\")\n  = \"bar\".gsub(/./) do |s|\n    - s + \"-\"\n  - end.gsub(/-$/) do |s|\n    - ''\nHAML\n  end\n\n  def test_silent_end_with_stuff\n    assert_equal(<<HTML, render(<<HAML))\ne\nd\nc\nb\na\nHTML\n- str = \"abcde\"\n- if true\n  = str.slice!(-1).chr\n- end until str.empty?\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\n<p>hi!</p>\nHTML\n- if true\n  %p hi!\n- end if \"foo\".gsub(/f/) do\n  - \"z\"\n- end + \"bar\"\nHAML\n  end\n\n  def test_multiline_with_colon_after_filter\n    assert_equal(<<HTML, render(<<HAML))\nFoo\nBar\nHTML\n:plain\n  Foo\n= { :a => \"Bar\",      |\n    :b => \"Baz\" }[:a] |\nHAML\n    assert_equal(<<HTML, render(<<HAML))\n\nBar\nHTML\n:plain\n= { :a => \"Bar\",      |\n    :b => \"Baz\" }[:a] |\nHAML\n  end\n\n  def test_multiline_in_filter\n    assert_equal(<<HTML, render(<<HAML))\nFoo |\nBar |\nBaz\nHTML\n:plain\n  Foo |\n  Bar |\n  Baz\nHAML\n  end\n\n  def test_curly_brace\n    assert_equal(<<HTML, render(<<HAML))\nFoo { Bar\nHTML\n== Foo { Bar\nHAML\n  end\n\n  def test_escape_attrs_false\n    assert_equal(<<HTML, render(<<HAML, :escape_attrs => false))\n<div class='<?php echo \"&quot;\" ?>' id='foo'>\n  bar\n</div>\nHTML\n#foo{:class => '<?php echo \"&quot;\" ?>'}\n  bar\nHAML\n  end\n\n  def test_escape_attrs_always\n    assert_equal(<<HTML, render(<<HAML, :escape_attrs => :always))\n<div class='\"&amp;lt;&amp;gt;&amp;amp;\"' id='foo'>\n  bar\n</div>\nHTML\n#foo{:class => '\"&lt;&gt;&amp;\"'}\n  bar\nHAML\n  end\n\n  def test_escape_html\n    html = <<HTML\n&amp;\n&\n&amp;\nHTML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n&= \"&\"\n!= \"&\"\n= \"&\"\nHAML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n&~ \"&\"\n!~ \"&\"\n~ \"&\"\nHAML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n& \\#{\"&\"}\n! \\#{\"&\"}\n\\#{\"&\"}\nHAML\n\n    assert_equal(html, render(<<HAML, :escape_html => true))\n&== \\#{\"&\"}\n!== \\#{\"&\"}\n== \\#{\"&\"}\nHAML\n\n    tag_html = <<HTML\n<p>&amp;</p>\n<p>&</p>\n<p>&amp;</p>\nHTML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p&= \"&\"\n%p!= \"&\"\n%p= \"&\"\nHAML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p&~ \"&\"\n%p!~ \"&\"\n%p~ \"&\"\nHAML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p& \\#{\"&\"}\n%p! \\#{\"&\"}\n%p \\#{\"&\"}\nHAML\n\n    assert_equal(tag_html, render(<<HAML, :escape_html => true))\n%p&== \\#{\"&\"}\n%p!== \\#{\"&\"}\n%p== \\#{\"&\"}\nHAML\n  end\n\n  def test_new_attrs_with_hash\n    assert_equal(\"<a href='#'></a>\\n\", render('%a(href=\"#\")'))\n  end\n\n  def test_silent_script_with_hyphen_case\n    assert_equal(\"\", render(\"- a = 'foo-case-bar-case'\"))\n  end\n\n  def test_silent_script_with_hyphen_end\n    assert_equal(\"\", render(\"- a = 'foo-end-bar-end'\"))\n  end\n\n  def test_silent_script_with_hyphen_end_and_block\n    silence_warnings do\n      assert_equal(<<HTML, render(<<HAML))\n<p>foo-end</p>\n<p>bar-end</p>\nHTML\n- (\"foo-end-bar-end\".gsub(/\\\\w+-end/) do |s|\n  %p= s\n- end; nil)\nHAML\n    end\n  end\n\n  def test_if_without_content_and_else\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- if false\n- else\n  foo\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- if true\n  - if false\n  - else\n    foo\nHAML\n  end\n\n  def test_html_attributes_with_hash\n    assert_equal(\"<a href='#' rel='top'>Foo</a>\\n\",\n      render('%a(href=\"#\" rel=\"top\") Foo'))\n    assert_equal(\"<a href='#'>Foo</a>\\n\",\n      render('%a(href=\"#\") #{\"Foo\"}'))\n\n    assert_equal(\"<a href='#\\\"'></a>\\n\", render('%a(href=\"#\\\\\"\")'))\n  end\n\n  def test_case_assigned_to_var\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- var = case 12\n- when 1; \"foo\"\n- when 12; \"bar\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- var = case 12\n- when 1\n  - \"foo\"\n- when 12\n  - \"bar\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- var = case 12\n  - when 1\n    - \"foo\"\n  - when 12\n    - \"bar\"\n= var\nHAML\n  end\n\n  def test_nested_case_assigned_to_var\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- if true\n  - var = case 12\n  - when 1; \"foo\"\n  - when 12; \"bar\"\n  = var\nHAML\n  end\n\n  def test_case_assigned_to_multiple_vars\n    assert_equal(<<HTML, render(<<HAML))\nbar\nbip\nHTML\n- var, vip = case 12\n- when 1; [\"foo\", \"baz\"]\n- when 12; [\"bar\", \"bip\"]\n= var\n= vip\nHAML\n  end\n\n  def test_if_assigned_to_var\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- var = if false\n- else\n  - \"foo\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- var = if false\n- elsif 12 == 12\n  - \"foo\"\n- elsif 14 == 14; \"bar\"\n- else\n  - \"baz\"\n= var\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- var = if false\n  - \"bar\"\n- else\n  - \"foo\"\n= var\nHAML\n  end\n\n  def test_case_with_newline_after_case\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nHTML\n- case 1\n\n  - when 1\n    foo\n  - when 2\n    bar\nHAML\n\n    assert_equal(<<HTML, render(<<HAML))\nbar\nHTML\n- case 2\n\n- when 1\n  foo\n- when 2\n  bar\nHAML\n  end\n\n  def test_escape_html_with_interpolated_if_statement\n    assert_equal(<<HTML, render(<<HAML, :escape_html => true))\nfoo,\nHTML\nfoo\\#{\",\" if true}\nHAML\n  end\n\n  # HTML escaping tests\n\n  def test_ampersand_equals_should_escape\n    assert_equal(\"<p>\\n  foo &amp; bar\\n</p>\\n\", render(\"%p\\n  &= 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_ampersand_equals_inline_should_escape\n    assert_equal(\"<p>foo &amp; bar</p>\\n\", render(\"%p&= 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_ampersand_equals_should_escape_before_preserve\n    assert_equal(\"<textarea>foo&#x000A;bar</textarea>\\n\", render('%textarea&= \"foo\\nbar\"', :escape_html => false))\n  end\n\n  def test_bang_equals_should_not_escape\n    assert_equal(\"<p>\\n  foo & bar\\n</p>\\n\", render(\"%p\\n  != 'foo & bar'\", :escape_html => true))\n  end\n\n  def test_bang_equals_inline_should_not_escape\n    assert_equal(\"<p>foo & bar</p>\\n\", render(\"%p!= 'foo & bar'\", :escape_html => true))\n  end\n\n  def test_static_attributes_should_be_escaped\n    assert_equal(\"<img class='atlantis' style='ugly&amp;stupid'>\\n\",\n                 render(\"%img.atlantis{:style => 'ugly&stupid'}\"))\n    assert_equal(\"<div class='atlantis' style='ugly&amp;stupid'>foo</div>\\n\",\n                 render(\".atlantis{:style => 'ugly&stupid'} foo\"))\n    assert_equal(\"<p class='atlantis' style='ugly&amp;stupid'>foo</p>\\n\",\n                render(\"%p.atlantis{:style => 'ugly&stupid'}= 'foo'\"))\n    assert_equal(\"<p class='atlantis' style='ugly&#x000A;stupid'></p>\\n\",\n                render(\"%p.atlantis{:style => \\\"ugly\\\\nstupid\\\"}\"))\n  end\n\n  def test_dynamic_attributes_should_be_escaped\n    assert_equal(\"<img alt='' src='&amp;foo.png'>\\n\",\n                 render(\"%img{:width => nil, :src => '&foo.png', :alt => String.new}\"))\n    assert_equal(\"<p alt='' src='&amp;foo.png'>foo</p>\\n\",\n                 render(\"%p{:width => nil, :src => '&foo.png', :alt => String.new} foo\"))\n    assert_equal(\"<div alt='' src='&amp;foo.png'>foo</div>\\n\",\n                 render(\"%div{:width => nil, :src => '&foo.png', :alt => String.new}= 'foo'\"))\n    assert_equal(\"<img alt='' src='foo&#x000A;.png'>\\n\",\n                 render(\"%img{:width => nil, :src => \\\"foo\\\\n.png\\\", :alt => String.new}\"))\n  end\n\n  def test_string_double_equals_should_be_esaped\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_inline_string_double_equals\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p&== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p&== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_inline_string_double_equals\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p!== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p!== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_string_double_equals\n    assert_equal(\"<p>\\n  4&&lt;\\n</p>\\n\", render(\"%p\\n  &== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n  4&&lt;\\n</p>\\n\", render(\"%p\\n  &== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_string_double_equals\n    assert_equal(\"<p>\\n  4&<\\n</p>\\n\", render(\"%p\\n  !== \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n  4&<\\n</p>\\n\", render(\"%p\\n  !== \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_string_interpolation_should_be_esaped\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_inline_string_interpolation\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p& \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&&lt;</p>\\n\", render(\"%p& \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_inline_string_interpolation\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p! \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>4&<</p>\\n\", render(\"%p! \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_string_interpolation\n    assert_equal(\"<p>\\n  4&&lt;\\n</p>\\n\", render(\"%p\\n  & \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n  4&&lt;\\n</p>\\n\", render(\"%p\\n  & \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_escaped_string_interpolation_with_no_space\n    assert_equal(\"&lt;br&gt;\\n\", render('&#{\"<br>\"}'))\n    assert_equal(\"<span>&lt;br&gt;</span>\\n\", render('%span&#{\"<br>\"}'))\n  end\n\n  def test_unescaped_string_interpolation\n    assert_equal(\"<p>\\n  4&<\\n</p>\\n\", render(\"%p\\n  ! \\#{2+2}&\\#{'<'}\", :escape_html => true))\n    assert_equal(\"<p>\\n  4&<\\n</p>\\n\", render(\"%p\\n  ! \\#{2+2}&\\#{'<'}\", :escape_html => false))\n  end\n\n  def test_unescaped_string_interpolation_with_no_space\n    assert_equal(\"<br>\\n\", render('!#{\"<br>\"}'))\n    assert_equal(\"<span><br></span>\\n\", render('%span!#{\"<br>\"}'))\n  end\n\n  def test_scripts_should_respect_escape_html_option\n    assert_equal(\"<p>\\n  foo &amp; bar\\n</p>\\n\", render(\"%p\\n  = 'foo & bar'\", :escape_html => true))\n    assert_equal(\"<p>\\n  foo & bar\\n</p>\\n\", render(\"%p\\n  = 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_inline_scripts_should_respect_escape_html_option\n    assert_equal(\"<p>foo &amp; bar</p>\\n\", render(\"%p= 'foo & bar'\", :escape_html => true))\n    assert_equal(\"<p>foo & bar</p>\\n\", render(\"%p= 'foo & bar'\", :escape_html => false))\n  end\n\n  def test_script_ending_in_comment_should_render_when_html_is_escaped\n    assert_equal(\"foo&amp;bar\\n\", render(\"= 'foo&bar' #comment\", :escape_html => true))\n  end\n\n  def test_script_with_if_shouldnt_output\n    assert_equal(<<HTML, render(<<HAML))\n<p>foo</p>\n<p></p>\nHTML\n%p= \"foo\"\n%p= \"bar\" if false\nHAML\n  end\n\n  # Options tests\n\n  def test_filename_and_line\n    begin\n      render(\"\\n\\n = abc\", :filename => 'test', :line => 2)\n    rescue Exception => e\n      assert_kind_of Haml::SyntaxError, e\n      assert_match(/test:4/, e.backtrace.first)\n    end\n\n    begin\n      render(\"\\n\\n= 123\\n\\n= nil[]\", :filename => 'test', :line => 2)\n    rescue Exception => e\n      assert_kind_of NoMethodError, e\n      backtrace = e.backtrace\n      backtrace.shift if rubinius?\n      assert_match(/test:6/, backtrace.first)\n    end\n  end\n\n  def test_stop_eval\n    assert_equal(\"\", render(\"= 'Hello'\", :suppress_eval => true))\n    assert_equal(\"\", render(\"- haml_concat 'foo'\", :suppress_eval => true))\n    assert_equal(\"<div id='foo' yes='no'>\\n\", render(\"#foo{:yes => 'no'}/\", :suppress_eval => true))\n    assert_equal(\"<div id='foo'>\\n\", render(\"#foo{:yes => 'no', :call => a_function() }/\", :suppress_eval => true))\n    assert_equal(\"<div>\\n\", render(\"%div[1]/\", :suppress_eval => true))\n    assert_equal(\"\", render(\":ruby\\n  Kernel.puts 'hello'\", :suppress_eval => true))\n  end\n\n  def test_doctypes\n    assert_equal('<!DOCTYPE html>',\n      render('!!!', :format => :html5).strip)\n    assert_equal('<!DOCTYPE html>', render('!!! 5').strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">',\n      render('!!! strict', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">',\n      render('!!! frameset', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//WAPFORUM//DTD XHTML Mobile 1.2//EN\" \"http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd\">',\n      render('!!! mobile', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML Basic 1.1//EN\" \"http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd\">',\n      render('!!! basic', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">',\n      render('!!! transitional', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">',\n      render('!!!', :format => :xhtml).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">',\n      render('!!! strict', :format => :html4).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">',\n      render('!!! frameset', :format => :html4).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">',\n      render('!!! transitional', :format => :html4).strip)\n    assert_equal('<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">',\n      render('!!!', :format => :html4).strip)\n  end\n\n  def test_attr_wrapper\n    assert_equal(\"<p strange=*attrs*></p>\\n\", render(\"%p{ :strange => 'attrs'}\", :attr_wrapper => '*'))\n    assert_equal(\"<p escaped='quo\\\"te'></p>\\n\", render(\"%p{ :escaped => 'quo\\\"te'}\", :attr_wrapper => '\"'))\n    assert_equal(\"<p escaped=\\\"quo&#039;te\\\"></p>\\n\", render(\"%p{ :escaped => 'quo\\\\'te'}\", :attr_wrapper => '\"'))\n    assert_equal(\"<p escaped='q&#039;uo\\\"te'></p>\\n\", render(\"%p{ :escaped => 'q\\\\'uo\\\"te'}\", :attr_wrapper => '\"'))\n    assert_equal(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?>\\n\", render(\"!!! XML\", :attr_wrapper => '\"', :format => :xhtml))\n  end\n\n  def test_autoclose_option\n    assert_equal(\"<flaz foo='bar'>\\n\", render(\"%flaz{:foo => 'bar'}\", :autoclose => [\"flaz\"]))\n    assert_equal(<<HTML, render(<<HAML, :autoclose => [/^flaz/]))\n<flaz>\n<flaznicate>\n<flan></flan>\nHTML\n%flaz\n%flaznicate\n%flan\nHAML\n  end\n\n  def test_attrs_parsed_correctly\n    assert_equal(\"<p boom=>biddly='bar =&gt; baz'></p>\\n\", render(\"%p{'boom=>biddly' => 'bar => baz'}\"))\n    assert_equal(\"<p foo,bar='baz, qux'></p>\\n\", render(\"%p{'foo,bar' => 'baz, qux'}\"))\n    assert_equal(\"<p escaped='quo&#x000A;te'></p>\\n\", render(\"%p{ :escaped => \\\"quo\\\\nte\\\"}\"))\n    assert_equal(\"<p escaped='quo4te'></p>\\n\", render(\"%p{ :escaped => \\\"quo\\#{2 + 2}te\\\"}\"))\n  end\n\n  def test_correct_parsing_with_brackets\n    assert_equal(\"<p class='foo'>{tada} foo</p>\\n\", render(\"%p{:class => 'foo'} {tada} foo\"))\n    assert_equal(\"<p class='foo'>deep {nested { things }}</p>\\n\", render(\"%p{:class => 'foo'} deep {nested { things }}\"))\n    assert_equal(\"<p class='bar foo'>{a { d</p>\\n\", render(\"%p{{:class => 'foo'}, :class => 'bar'} {a { d\"))\n    assert_equal(\"<p foo='bar'>a}</p>\\n\", render(\"%p{:foo => 'bar'} a}\"))\n\n    foo = []\n    foo[0] = Struct.new('PrettyFoo', :id).new\n    assert_equal(\"<p class='struct_pretty_foo' id='struct_pretty_foo_new'>New User]</p>\\n\",\n                 render(\"%p[foo[0]] New User]\", :locals => {:foo => foo}))\n    assert_equal(\"<p class='prefix_struct_pretty_foo' id='prefix_struct_pretty_foo_new'>New User]</p>\\n\",\n                 render(\"%p[foo[0], :prefix] New User]\", :locals => {:foo => foo}))\n\n    foo[0].id = 1\n    assert_equal(\"<p class='struct_pretty_foo' id='struct_pretty_foo_1'>New User]</p>\\n\",\n                 render(\"%p[foo[0]] New User]\", :locals => {:foo => foo}))\n    assert_equal(\"<p class='prefix_struct_pretty_foo' id='prefix_struct_pretty_foo_1'>New User]</p>\\n\",\n                 render(\"%p[foo[0], :prefix] New User]\", :locals => {:foo => foo}))\n  end\n\n  def test_empty_attrs\n    assert_equal(\"<p attr=''>empty</p>\\n\", render(\"%p{ :attr => '' } empty\"))\n    assert_equal(\"<p attr=''>empty</p>\\n\", render(\"%p{ :attr => x } empty\", :locals => {:x => ''}))\n  end\n\n  def test_nil_attrs\n    assert_equal(\"<p>nil</p>\\n\", render(\"%p{ :attr => nil } nil\"))\n    assert_equal(\"<p>nil</p>\\n\", render(\"%p{ :attr => x } nil\", :locals => {:x => nil}))\n  end\n\n  def test_nil_id_with_syntactic_id\n    assert_equal(\"<p id='foo'>nil</p>\\n\", render(\"%p#foo{:id => nil} nil\"))\n    assert_equal(\"<p id='foo_bar'>nil</p>\\n\", render(\"%p#foo{{:id => 'bar'}, :id => nil} nil\"))\n    assert_equal(\"<p id='foo_bar'>nil</p>\\n\", render(\"%p#foo{{:id => nil}, :id => 'bar'} nil\"))\n  end\n\n  def test_nil_class_with_syntactic_class\n    assert_equal(\"<p class='foo'>nil</p>\\n\", render(\"%p.foo{:class => nil} nil\"))\n    assert_equal(\"<p class='bar foo'>nil</p>\\n\", render(\"%p.bar.foo{:class => nil} nil\"))\n    assert_equal(\"<p class='bar foo'>nil</p>\\n\", render(\"%p.foo{{:class => 'bar'}, :class => nil} nil\"))\n    assert_equal(\"<p class='bar foo'>nil</p>\\n\", render(\"%p.foo{{:class => nil}, :class => 'bar'} nil\"))\n  end\n\n  def test_locals\n    assert_equal(\"<p>Paragraph!</p>\\n\", render(\"%p= text\", :locals => { :text => \"Paragraph!\" }))\n  end\n\n  def test_dynamic_attrs_shouldnt_register_as_literal_values\n    assert_equal(\"<p a='b2c'></p>\\n\", render('%p{:a => \"b#{1 + 1}c\"}'))\n    assert_equal(\"<p a='b2c'></p>\\n\", render(\"%p{:a => 'b' + (1 + 1).to_s + 'c'}\"))\n  end\n\n  def test_dynamic_attrs_with_self_closed_tag\n    assert_equal(\"<a b='2'>\\nc\\n\", render(\"%a{'b' => 1 + 1}/\\n= 'c'\\n\"))\n  end\n\n  EXCEPTION_MAP.each do |key, value|\n    define_method(\"test_exception (#{key.inspect})\") do\n      begin\n        silence_warnings do\n          render(key, :filename => \"(test_exception (#{key.inspect}))\")\n        end\n      rescue Exception => err\n        value = [value] unless value.is_a?(Array)\n        expected_message, line_no = value\n        line_no ||= key.split(\"\\n\").length\n\n\n        if expected_message == :compile\n          assert_match(/(compile error|syntax error|unterminated string|expecting)/, err.message, \"Line: #{key}\")\n        else\n          assert_equal(expected_message, err.message, \"Line: #{key}\")\n        end\n\n      else\n        assert(false, \"Exception not raised for\\n#{key}\")\n      end\n    end\n  end\n\n  def test_exception_line\n    render(\"a\\nb\\n!!!\\n  c\\nd\")\n  rescue Haml::SyntaxError => e\n    assert_equal(\"(test_exception_line):4\", e.backtrace[0])\n  else\n    assert(false, '\"a\\nb\\n!!!\\n  c\\nd\" doesn\\'t produce an exception')\n  end\n\n  def test_exception\n    render(\"%p\\n  hi\\n  %a= undefined\\n= 12\")\n  rescue Exception => e\n    backtrace = e.backtrace\n    backtrace.shift if rubinius?\n    assert_match(\"(test_exception):3\", backtrace[0])\n  else\n    # Test failed... should have raised an exception\n    assert(false)\n  end\n\n  def test_compile_error\n    render(\"a\\nb\\n- fee)\\nc\")\n  rescue Exception => e\n    assert_match(/\\(test_compile_error\\):3:/i, e.message)\n    assert_match(/(syntax error|expecting \\$end)/i, e.message)\n  else\n    assert(false, '\"a\\nb\\n- fee)\\nc\" doesn\\'t produce an exception!')\n  end\n\n  def test_unbalanced_brackets\n    render('foo #{1 + 5} foo #{6 + 7 bar #{8 + 9}')\n  rescue Haml::SyntaxError => e\n    assert_equal(Haml::Error.message(:unbalanced_brackets), e.message)\n  end\n\n  def test_single_line_comments_are_interpolated\n    assert_equal(\"<!-- Hello 2 -->\\n\",\n                 render('/ Hello #{1 + 1}'))\n  end\n\n  def test_single_line_comments_are_not_interpolated_with_suppress_eval\n    assert_equal(\"<!--  -->\\n\",\n                 render('/ Hello #{1 + 1}', :suppress_eval => true))\n  end\n\n  def test_single_line_comments_with_interpolation_dont_break_tabulation\n    assert_equal(\"<!-- Hello 2 -->\\nconcatted\\n\",\n                 render(\"/ Hello \\#{1 + 1}\\n- haml_concat 'concatted'\"))\n  end\n\n  def test_balanced_conditional_comments\n    assert_equal(\"<!--[if !(IE 6)|(IE 7)]> Bracket: ] <![endif]-->\\n\",\n                 render(\"/[if !(IE 6)|(IE 7)] Bracket: ]\"))\n  end\n\n  def test_downlevel_revealed_conditional_comments\n    assert_equal(\"<!--[if !IE]><!--> A comment <!--<![endif]-->\\n\",\n                  render(\"/![if !IE] A comment\"))\n  end\n\n  def test_downlevel_revealed_conditional_comments_block\n    assert_equal(\"<!--[if !IE]><!-->\\n  A comment\\n<!--<![endif]-->\\n\",\n                  render(\"/![if !IE]\\n  A comment\"))\n  end\n\n  def test_local_assigns_dont_modify_class\n    assert_equal(\"bar\\n\", render(\"= foo\", :locals => {:foo => 'bar'}))\n    assert_nil(defined?(foo))\n  end\n\n  def test_object_ref_with_nil_id\n    user = PrettyUser.new\n    assert_equal(\"<p class='struct_pretty_user' id='struct_pretty_user_new'>New User</p>\\n\",\n                 render(\"%p[user] New User\", :locals => {:user => user}))\n  end\n\n  def test_object_ref_before_attrs\n    user = PrettyUser.new 42\n    assert_equal(\"<p class='struct_pretty_user' id='struct_pretty_user_42' style='width: 100px;'>New User</p>\\n\",\n                 render(\"%p[user]{:style => 'width: 100px;'} New User\", :locals => {:user => user}))\n  end\n\n  def test_object_ref_with_custom_haml_class\n    custom = CustomHamlClass.new 42\n    assert_equal(\"<p class='my_thing' id='my_thing_42' style='width: 100px;'>My Thing</p>\\n\",\n                 render(\"%p[custom]{:style => 'width: 100px;'} My Thing\", :locals => {:custom => custom}))\n  end\n\n  def test_object_ref_with_multiple_ids\n    cpk_record = PrettyCpkRecord.new([42,6,9])\n    assert_equal(\"<p class='struct_pretty_cpk_record' id='struct_pretty_cpk_record_42_6_9' style='width: 100px;'>CPK Record</p>\\n\",\n                 render(\"%p[cpk_record]{:style => 'width: 100px;'} CPK Record\", :locals => {:cpk_record => cpk_record}))\n  end\n\n  def test_non_literal_attributes\n    assert_equal(\"<p a1='foo' a2='bar' a3='baz'></p>\\n\",\n                 render(\"%p{a2, a1, :a3 => 'baz'}\",\n                        :locals => {:a1 => {:a1 => 'foo'}, :a2 => {:a2 => 'bar'}}))\n  end\n\n  def test_render_should_accept_a_binding_as_scope\n    string = \"This is a string!\"\n    string.instance_variable_set(:@var, \"Instance variable\")\n    b = string.instance_eval do\n      var = \"Local variable\"\n      # Silence unavoidable warning; Ruby doesn't know we're going to use this\n      # later.\n      nil if var\n      binding\n    end\n\n    assert_equal(\"<p>THIS IS A STRING!</p>\\n<p>Instance variable</p>\\n<p>Local variable</p>\\n\",\n                 render(\"%p= upcase\\n%p= @var\\n%p= var\", :scope => b))\n  end\n\n  def test_yield_should_work_with_binding\n    assert_equal(\"12\\nFOO\\n\", render(\"= yield\\n= upcase\", :scope => \"foo\".instance_eval{binding}) { 12 })\n  end\n\n  def test_yield_should_work_with_def_method\n    s = \"foo\"\n    engine(\"= yield\\n= upcase\").def_method(s, :render)\n    assert_equal(\"12\\nFOO\\n\", s.render { 12 })\n  end\n\n  def test_render_proc_locals\n    proc = engine(\"%p= foo\\n.bar{:baz => baz}= boom\").render_proc(Object.new, :foo, :baz, :boom)\n    assert_equal(\"<p>1</p>\\n<div baz='2' class='bar'>3</div>\\n\", proc[:foo => 1, :baz => 2, :boom => 3])\n  end\n\n  def test_render_proc_with_binding\n    assert_equal(\"FOO\\n\", engine(\"= upcase\").render_proc(\"foo\".instance_eval{binding}).call)\n  end\n\n  def test_haml_buffer_gets_reset_even_with_exception\n    scope = Object.new\n    render(\"- raise Haml::Error\", :scope => scope)\n    assert(false, \"Expected exception\")\n  rescue Exception\n    assert_nil(scope.send(:haml_buffer))\n  end\n\n  def test_def_method_haml_buffer_gets_reset_even_with_exception\n    scope = Object.new\n    engine(\"- raise Haml::Error\").def_method(scope, :render)\n    scope.render\n    assert(false, \"Expected exception\")\n  rescue Exception\n    assert_nil(scope.send(:haml_buffer))\n  end\n\n  def test_render_proc_haml_buffer_gets_reset_even_with_exception\n    scope = Object.new\n    proc = engine(\"- raise Haml::Error\").render_proc(scope)\n    proc.call\n    assert(false, \"Expected exception\")\n  rescue Exception\n    assert_nil(scope.send(:haml_buffer))\n  end\n\n  def test_render_proc_should_raise_haml_syntax_error_not_ruby_syntax_error\n    assert_raises(Haml::SyntaxError) do\n      Haml::Engine.new(\"%p{:foo => !}\").render_proc(Object.new, :foo).call\n    end\n  end\n\n  def test_render_should_raise_haml_syntax_error_not_ruby_syntax_error\n    assert_raises(Haml::SyntaxError) do\n      Haml::Engine.new(\"%p{:foo => !}\").render\n    end\n  end\n\n  def test_ugly_true\n    assert_equal(\"<div id='outer'>\\n<div id='inner'>\\n<p>hello world</p>\\n</div>\\n</div>\\n\",\n                 render(\"#outer\\n  #inner\\n    %p hello world\", :ugly => true))\n\n    assert_equal(\"<p>#{'s' * 75}</p>\\n\",\n                 render(\"%p #{'s' * 75}\", :ugly => true))\n\n    assert_equal(\"<p>#{'s' * 75}</p>\\n\",\n                 render(\"%p= 's' * 75\", :ugly => true))\n  end\n\n  def test_remove_whitespace_true\n    assert_equal(\"<div id='outer'><div id='inner'><p>hello world</p></div></div>\",\n                 render(\"#outer\\n  #inner\\n    %p hello world\", :remove_whitespace => true))\n    assert_equal(\"<p>hello world<pre>foo   bar\\nbaz</pre></p>\", render(<<HAML, :remove_whitespace => true))\n%p\n  hello world\n  %pre\n    foo   bar\n    baz\nHAML\n    assert_equal(\"<div><span>foo</span> <span>bar</span></div>\",\n                 render('%div <span>foo</span> <span>bar</span>', :remove_whitespace => true))\n  end\n\n  def test_auto_preserve_unless_ugly\n    assert_equal(\"<pre>foo&#x000A;bar</pre>\\n\", render('%pre=\"foo\\nbar\"'))\n    assert_equal(\"<pre>foo\\nbar</pre>\\n\", render(\"%pre\\n  foo\\n  bar\"))\n    assert_equal(\"<pre>foo\\nbar</pre>\\n\", render('%pre=\"foo\\nbar\"', :ugly => true))\n    assert_equal(\"<pre>foo\\nbar</pre>\\n\", render(\"%pre\\n  foo\\n  bar\", :ugly => true))\n  end\n\n  def test_xhtml_output_option\n    assert_equal \"<p>\\n  <br />\\n</p>\\n\", render(\"%p\\n  %br\", :format => :xhtml)\n    assert_equal \"<a />\\n\", render(\"%a/\", :format => :xhtml)\n  end\n\n  def test_arbitrary_output_option\n    assert_raises_message(Haml::Error, \"Invalid output format :html1\") do\n      engine(\"%br\", :format => :html1)\n    end\n  end\n\n  def test_static_hashes\n    assert_equal(\"<a b='a =&gt; b'></a>\\n\", render(\"%a{:b => 'a => b'}\", :suppress_eval => true))\n    assert_equal(\"<a b='a, b'></a>\\n\", render(\"%a{:b => 'a, b'}\", :suppress_eval => true))\n    assert_equal(\"<a b='a\\tb'></a>\\n\", render('%a{:b => \"a\\tb\"}', :suppress_eval => true))\n    assert_equal(\"<a b='a\\#{foo}b'></a>\\n\", render('%a{:b => \"a\\\\#{foo}b\"}', :suppress_eval => true))\n    assert_equal(\"<a b='#f00'></a>\\n\", render(\"%a{:b => '#f00'}\", :suppress_eval => true))\n  end\n\n  def test_dynamic_hashes_with_suppress_eval\n    assert_equal(\"<a></a>\\n\", render('%a{:b => \"a #{1 + 1} b\", :c => \"d\"}', :suppress_eval => true))\n  end\n\n  def test_interpolates_instance_vars_in_attribute_values\n    scope = Object.new\n    scope.instance_variable_set :@foo, 'bar'\n    assert_equal(\"<a b='a bar b'></a>\\n\", render('%a{:b => \"a #@foo b\"}', :scope => scope))\n  end\n\n  def test_interpolates_global_vars_in_attribute_values\n    # make sure the value isn't just interpolated in during template compilation\n    engine = Haml::Engine.new('%a{:b => \"a #$global_var_for_testing b\"}')\n    $global_var_for_testing = 'bar'\n    assert_equal(\"<a b='a bar b'></a>\\n\", engine.to_html)\n  ensure\n    $global_var_for_testing = nil\n  end\n\n  def test_utf8_attrs\n    assert_equal(\"<a href='h\u00e9llo'></a>\\n\", render(\"%a{:href => 'h\u00e9llo'}\"))\n    assert_equal(\"<a href='h\u00e9llo'></a>\\n\", render(\"%a(href='h\u00e9llo')\"))\n  end\n\n  # HTML 4.0\n\n  def test_html_has_no_self_closing_tags\n    assert_equal \"<p>\\n  <br>\\n</p>\\n\", render(\"%p\\n  %br\", :format => :html4)\n    assert_equal \"<br>\\n\", render(\"%br/\", :format => :html4)\n  end\n\n  def test_html_renders_empty_node_with_closing_tag\n    assert_equal \"<div class='foo'></div>\\n\", render(\".foo\", :format => :html4)\n  end\n\n  def test_html_doesnt_add_slash_to_self_closing_tags\n    assert_equal \"<a>\\n\", render(\"%a/\", :format => :html4)\n    assert_equal \"<a foo='2'>\\n\", render(\"%a{:foo => 1 + 1}/\", :format => :html4)\n    assert_equal \"<meta>\\n\", render(\"%meta\", :format => :html4)\n    assert_equal \"<meta foo='2'>\\n\", render(\"%meta{:foo => 1 + 1}\", :format => :html4)\n  end\n\n  def test_html_ignores_xml_prolog_declaration\n    assert_equal \"\", render('!!! XML', :format => :html4)\n  end\n\n  def test_html_has_different_doctype\n    assert_equal %{<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\\n},\n    render('!!!', :format => :html4)\n  end\n\n  # because anything before the doctype triggers quirks mode in IE\n  def test_xml_prolog_and_doctype_dont_result_in_a_leading_whitespace_in_html\n    refute_match(/^\\s+/, render(\"!!! xml\\n!!!\", :format => :html4))\n  end\n\n  # HTML5\n  def test_html5_doctype\n    assert_equal %{<!DOCTYPE html>\\n}, render('!!!', :format => :html5)\n  end\n\n  # HTML5 custom data attributes\n  def test_html5_data_attributes_without_hyphenation\n    assert_equal(\"<div data-author_id='123' data-biz='baz' data-foo='bar'></div>\\n\",\n      render(\"%div{:data => {:author_id => 123, :foo => 'bar', :biz => 'baz'}}\",\n        :hyphenate_data_attrs => false))\n\n    assert_equal(\"<div data-one_plus_one='2'></div>\\n\",\n      render(\"%div{:data => {:one_plus_one => 1+1}}\",\n        :hyphenate_data_attrs => false))\n\n    assert_equal(\"<div data-foo='Here&#039;s a \\\"quoteful\\\" string.'></div>\\n\",\n      render(%{%div{:data => {:foo => %{Here's a \"quoteful\" string.}}}},\n        :hyphenate_data_attrs => false)) #'\n  end\n\n  def test_html5_data_attributes_with_hyphens\n    assert_equal(\"<div data-foo-bar='blip'></div>\\n\",\n      render(\"%div{:data => {:foo_bar => 'blip'}}\"))\n    assert_equal(\"<div data-baz='bang' data-foo-bar='blip'></div>\\n\",\n      render(\"%div{:data => {:foo_bar => 'blip', :baz => 'bang'}}\"))\n  end\n\n\tdef test_html5_arbitrary_hash_valued_attributes_with\n    assert_equal(\"<div aria-foo='blip'></div>\\n\",\n      render(\"%div{:aria => {:foo => 'blip'}}\"))\n    assert_equal(\"<div foo-baz='bang'></div>\\n\",\n      render(\"%div{:foo => {:baz => 'bang'}}\"))\n\tend\n\n  def test_arbitrary_attribute_hash_merging\n    assert_equal(%Q{<a aria-baz='qux' aria-foo='bar'></a>\\n}, render(<<-HAML))\n- h1 = {:aria => {:foo => :bar}}\n- h2 = {:baz => :qux}\n%a{h1, :aria => h2}\nHAML\n  end\n\n\n  def test_html5_data_attributes_with_nested_hash\n    assert_equal(\"<div data-a-b='c'></div>\\n\", render(<<-HAML))\n- hash = {:a => {:b => 'c'}}\n- hash[:d] = hash\n%div{:data => hash}\nHAML\n  end\n\n  def test_html5_data_attributes_with_nested_hash_and_without_hyphenation\n    assert_equal(\"<div data-a_b='c'></div>\\n\", render(<<-HAML, :hyphenate_data_attrs => false))\n- hash = {:a => {:b => 'c'}}\n- hash[:d] = hash\n%div{:data => hash}\nHAML\n  end\n\n  def test_html5_data_attributes_with_multiple_defs\n    # Should always use the more-explicit attribute\n    assert_equal(\"<div data-foo='second'></div>\\n\",\n      render(\"%div{:data => {:foo => 'first'}, 'data-foo' => 'second'}\"))\n    assert_equal(\"<div data-foo='first'></div>\\n\",\n      render(\"%div{'data-foo' => 'first', :data => {:foo => 'second'}}\"))\n  end\n\n  def test_html5_data_attributes_with_attr_method\n    obj = Object.new\n    def obj.data_hash\n      {:data => {:foo => \"bar\", :baz => \"bang\"}}\n    end\n\n    def obj.data_val\n      {:data => \"dat\"}\n    end\n\n    assert_equal(\"<div data-baz='bang' data-brat='wurst' data-foo='blip'></div>\\n\",\n      render(\"%div{data_hash, :data => {:foo => 'blip', :brat => 'wurst'}}\", scope: obj))\n    assert_equal(\"<div data-baz='bang' data-foo='blip'></div>\\n\",\n      render(\"%div{data_hash, 'data-foo' => 'blip'}\", scope: obj))\n    assert_equal(\"<div data-baz='bang' data-foo='bar' data='dat'></div>\\n\",\n      render(\"%div{data_hash, :data => 'dat'}\", scope: obj))\n    assert_equal(\"<div data-brat='wurst' data-foo='blip' data='dat'></div>\\n\",\n      render(\"%div{data_val, :data => {:foo => 'blip', :brat => 'wurst'}}\", scope: obj))\n  end\n\n  def test_html5_data_attributes_with_identical_attribute_values\n    assert_equal(\"<div data-x='50' data-y='50'></div>\\n\",\n      render(\"%div{:data => {:x => 50, :y => 50}}\"))\n  end\n\n  def test_xml_doc_using_html5_format_and_mime_type\n    assert_equal(<<XML, render(<<HAML, { :format => :html5, :mime_type => 'text/xml' }))\n<?xml version='1.0' encoding='utf-8' ?>\n<root>\n  <element />\n  <hr />\n</root>\nXML\n!!! XML\n%root\n  %element/\n  %hr\nHAML\n  end\n\n  def test_xml_doc_using_html4_format_and_mime_type\n    assert_equal(<<XML, render(<<HAML, { :format => :html4, :mime_type => 'text/xml' }))\n<?xml version='1.0' encoding='utf-8' ?>\n<root>\n  <element />\n  <hr />\n</root>\nXML\n!!! XML\n%root\n  %element/\n  %hr\nHAML\n  end\n\n  # New attributes\n\n  def test_basic_new_attributes\n    assert_equal(\"<a>bar</a>\\n\", render(\"%a() bar\"))\n    assert_equal(\"<a href='foo'>bar</a>\\n\", render(\"%a(href='foo') bar\"))\n    assert_equal(\"<a b='c' c='d' d='e'>baz</a>\\n\", render(%q{%a(b=\"c\" c='d' d=\"e\") baz}))\n  end\n\n  def test_new_attribute_ids\n    assert_equal(\"<div id='foo_bar'></div>\\n\", render(\"#foo(id='bar')\"))\n    assert_equal(\"<div id='foo_baz_bar'></div>\\n\", render(\"#foo{:id => 'bar'}(id='baz')\"))\n    assert_equal(\"<div id='foo_baz_bar'></div>\\n\", render(\"#foo(id='baz'){:id => 'bar'}\"))\n    foo = PrettyUser.new(42)\n    assert_equal(\"<div class='struct_pretty_user' id='foo_baz_bar_struct_pretty_user_42'></div>\\n\",\n      render(\"#foo(id='baz'){:id => 'bar'}[foo]\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='struct_pretty_user' id='foo_baz_bar_struct_pretty_user_42'></div>\\n\",\n      render(\"#foo(id='baz')[foo]{:id => 'bar'}\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='struct_pretty_user' id='foo_baz_bar_struct_pretty_user_42'></div>\\n\",\n      render(\"#foo[foo](id='baz'){:id => 'bar'}\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='struct_pretty_user' id='foo_baz_bar_struct_pretty_user_42'></div>\\n\",\n      render(\"#foo[foo]{:id => 'bar'}(id='baz')\", :locals => {:foo => foo}))\n  end\n\n  def test_new_attribute_classes\n    assert_equal(\"<div class='bar foo'></div>\\n\", render(\".foo(class='bar')\"))\n    assert_equal(\"<div class='bar baz foo'></div>\\n\", render(\".foo{:class => 'bar'}(class='baz')\"))\n    assert_equal(\"<div class='bar baz foo'></div>\\n\", render(\".foo(class='baz'){:class => 'bar'}\"))\n    foo = PrettyUser.new(42)\n    assert_equal(\"<div class='bar baz foo struct_pretty_user' id='struct_pretty_user_42'></div>\\n\",\n      render(\".foo(class='baz'){:class => 'bar'}[foo]\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='bar baz foo struct_pretty_user' id='struct_pretty_user_42'></div>\\n\",\n      render(\".foo[foo](class='baz'){:class => 'bar'}\", :locals => {:foo => foo}))\n    assert_equal(\"<div class='bar baz foo struct_pretty_user' id='struct_pretty_user_42'></div>\\n\",\n      render(\".foo[foo]{:class => 'bar'}(class='baz')\", :locals => {:foo => foo}))\n  end\n\n  def test_dynamic_new_attributes\n    assert_equal(\"<a href='12'>bar</a>\\n\", render(\"%a(href=foo) bar\", :locals => {:foo => 12}))\n    assert_equal(\"<a b='12' c='13' d='14'>bar</a>\\n\", render(\"%a(b=b c='13' d=d) bar\", :locals => {:b => 12, :d => 14}))\n  end\n\n  def test_new_attribute_interpolation\n    assert_equal(\"<a href='12'>bar</a>\\n\", render('%a(href=\"1#{1 + 1}\") bar'))\n    assert_equal(\"<a href='2: 2, 3: 3'>bar</a>\\n\", render(%q{%a(href='2: #{1 + 1}, 3: #{foo}') bar}, :locals => {:foo => 3}))\n    assert_equal(%Q{<a href='1\\#{1 + 1}'>bar</a>\\n}, render('%a(href=\"1\\#{1 + 1}\") bar'))\n  end\n\n  def test_truthy_new_attributes\n    assert_equal(\"<a href='href'>bar</a>\\n\", render(\"%a(href) bar\", :format => :xhtml))\n    assert_equal(\"<a bar='baz' href>bar</a>\\n\", render(\"%a(href bar='baz') bar\", :format => :html5))\n    assert_equal(\"<a href>bar</a>\\n\", render(\"%a(href=true) bar\"))\n    assert_equal(\"<a>bar</a>\\n\", render(\"%a(href=false) bar\"))\n  end\n\n  def test_new_attribute_parsing\n    assert_equal(\"<a a2='b2'>bar</a>\\n\", render(\"%a(a2=b2) bar\", :locals => {:b2 => 'b2'}))\n    assert_equal(%Q{<a a='foo\"bar'>bar</a>\\n}, render(%q{%a(a=\"#{'foo\"bar'}\") bar})) #'\n    assert_equal(%Q{<a a='foo&#039;bar'>bar</a>\\n}, render(%q{%a(a=\"#{\"foo'bar\"}\") bar})) #'\n    assert_equal(%Q{<a a='foo\"bar'>bar</a>\\n}, render(%q{%a(a='foo\"bar') bar}))\n    assert_equal(%Q{<a a='foo&#039;bar'>bar</a>\\n}, render(%q{%a(a=\"foo'bar\") bar}))\n    assert_equal(\"<a a:b='foo'>bar</a>\\n\", render(\"%a(a:b='foo') bar\"))\n    assert_equal(\"<a a='foo' b='bar'>bar</a>\\n\", render(\"%a(a = 'foo' b = 'bar') bar\"))\n    assert_equal(\"<a a='foo' b='bar'>bar</a>\\n\", render(\"%a(a = foo b = bar) bar\", :locals => {:foo => 'foo', :bar => 'bar'}))\n    assert_equal(\"<a a='foo'>(b='bar')</a>\\n\", render(\"%a(a='foo')(b='bar')\"))\n    assert_equal(\"<a a='foo)bar'>baz</a>\\n\", render(\"%a(a='foo)bar') baz\"))\n    assert_equal(\"<a a='foo'>baz</a>\\n\", render(\"%a( a = 'foo' ) baz\"))\n  end\n\n  def test_new_attribute_escaping\n    assert_equal(%Q{<a a='foo \" bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\\" bar\") bar}))\n    assert_equal(%Q{<a a='foo \\\\\" bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\\\\\\\\\\" bar\") bar}))\n\n    assert_equal(%Q{<a a='foo &#039; bar'>bar</a>\\n}, render(%q{%a(a='foo \\' bar') bar}))\n    assert_equal(%Q{<a a='foo \\\\&#039; bar'>bar</a>\\n}, render(%q{%a(a='foo \\\\\\\\\\' bar') bar}))\n\n    assert_equal(%Q{<a a='foo \\\\ bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\\\\\\\ bar\") bar}))\n    assert_equal(%Q{<a a='foo \\#{1 + 1} bar'>bar</a>\\n}, render(%q{%a(a=\"foo \\#{1 + 1} bar\") bar}))\n  end\n\n  def test_multiline_new_attribute\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a(a='b'\\n  c='d') bar\"))\n    assert_equal(\"<a a='b' b='c' c='d' d='e' e='f' f='j'>bar</a>\\n\",\n      render(\"%a(a='b' b='c'\\n  c='d' d=e\\n  e='f' f='j') bar\", :locals => {:e => 'e'}))\n  end\n\n  def test_new_and_old_attributes\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a(a='b'){:c => 'd'} bar\"))\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a{:c => 'd'}(a='b') bar\"))\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a(c='d'){:a => 'b'} bar\"))\n    assert_equal(\"<a a='b' c='d'>bar</a>\\n\", render(\"%a{:a => 'b'}(c='d') bar\"))\n\n    # Old-style always takes precedence over new-style,\n    # because theoretically old-style could have arbitrary end-of-method-call syntax.\n    assert_equal(\"<a a='b'>bar</a>\\n\", render(\"%a{:a => 'b'}(a='d') bar\"))\n    assert_equal(\"<a a='b'>bar</a>\\n\", render(\"%a(a='d'){:a => 'b'} bar\"))\n\n    assert_equal(\"<a a='b' b='c' c='d' d='e'>bar</a>\\n\",\n      render(\"%a{:a => 'b',\\n:b => 'c'}(c='d'\\nd='e') bar\"))\n\n    locals = {:b => 'b', :d => 'd'}\n    assert_equal(\"<p a='b' c='d'></p>\\n\", render(\"%p{:a => b}(c=d)\", :locals => locals))\n    assert_equal(\"<p a='b' c='d'></p>\\n\", render(\"%p(a=b){:c => d}\", :locals => locals))\n  end\n\n  # Ruby Multiline\n\n  def test_silent_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\nbar, baz, bang\n<p>foo</p>\nHTML\n- foo = [\"bar\",\n         \"baz\",\n         \"bang\"]\n= foo.join(\", \")\n%p foo\nHAML\n  end\n\n  def test_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\nbar, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n= [\"bar\",\n   \"baz\",\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_with_punctuated_methods_is_continuation\n    assert_equal(<<HTML, render(<<HAML))\nbar, , true, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n= [\"bar\",\n   \"  \".strip!,\n   \"\".empty?,\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_character_literals_are_not_continuation\n    html = \",\\n,\\n<p>foo</p>\\n\"\n    assert_equal(html, render(<<HAML))\n= ?,\n= ?\\,\n%p foo\nHAML\n  end\n\n  def test_escaped_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\nbar&lt;, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n&= [\"bar<\",\n    \"baz\",\n    \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_unescaped_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML, :escape_html => true))\nbar<, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n!= [\"bar<\",\n    \"baz\",\n    \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_flattened_loud_ruby_multiline\n    assert_equal(<<HTML, render(<<HAML))\n<pre>bar&#x000A;baz&#x000A;bang</pre>\n<p>foo</p>\n<p>bar</p>\nHTML\n~ \"<pre>\" + [\"bar\",\n             \"baz\",\n             \"bang\"].join(\"\\\\n\") + \"</pre>\"\n%p foo\n%p bar\nHAML\n  end\n\n  def test_loud_ruby_multiline_with_block\n    assert_equal(<<HTML, render(<<HAML))\n#{%w[far faz fang]}\n<p>foo</p>\n<p>bar</p>\nHTML\n= [\"bar\",\n   \"baz\",\n   \"bang\"].map do |str|\n  - str.gsub(\"ba\",\n             \"fa\")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_silent_ruby_multiline_with_block\n    assert_equal(<<HTML, render(<<HAML))\nfar\nfaz\nfang\n<p>foo</p>\n<p>bar</p>\nHTML\n- [\"bar\",\n   \"baz\",\n   \"bang\"].map do |str|\n  = str.gsub(\"ba\",\n             \"fa\")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_in_tag\n    assert_equal(<<HTML, render(<<HAML))\n<p>foo, bar, baz</p>\n<p>foo</p>\n<p>bar</p>\nHTML\n%p= [\"foo\",\n     \"bar\",\n     \"baz\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_escaped_ruby_multiline_in_tag\n    assert_equal(<<HTML, render(<<HAML))\n<p>foo&lt;, bar, baz</p>\n<p>foo</p>\n<p>bar</p>\nHTML\n%p&= [\"foo<\",\n      \"bar\",\n      \"baz\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_unescaped_ruby_multiline_in_tag\n    assert_equal(<<HTML, render(<<HAML, :escape_html => true))\n<p>foo<, bar, baz</p>\n<p>foo</p>\n<p>bar</p>\nHTML\n%p!= [\"foo<\",\n      \"bar\",\n      \"baz\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_with_normal_multiline\n    assert_equal(<<HTML, render(<<HAML))\nfoobarbar, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n= \"foo\" + |\n  \"bar\" + |\n  [\"bar\", |\n   \"baz\",\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  def test_ruby_multiline_after_filter\n    assert_equal(<<HTML, render(<<HAML))\nfoo\nbar\nbar, baz, bang\n<p>foo</p>\n<p>bar</p>\nHTML\n:plain\n  foo\n  bar\n= [\"bar\",\n   \"baz\",\n   \"bang\"].join(\", \")\n%p foo\n%p bar\nHAML\n  end\n\n  # Encodings\n\n  def test_utf_8_bom\n    assert_equal <<HTML, render(<<HAML)\n<div class='foo'>\n  <p>baz</p>\n</div>\nHTML\n\\xEF\\xBB\\xBF.foo\n  %p baz\nHAML\n  end\n\n  def test_default_encoding\n    assert_equal(Encoding.find(\"utf-8\"), render(<<HAML.encode(\"us-ascii\")).encoding)\n%p bar\n%p foo\nHAML\n  end\n\n  def test_fake_ascii_encoding\n    assert_encoded_equal(<<HTML.force_encoding(\"ascii-8bit\"), render(<<HAML, :encoding => \"ascii-8bit\"))\n<p>b\u00e2r</p>\n<p>f\u00f6\u00f6</p>\nHTML\n%p b\u00e2r\n%p f\u00f6\u00f6\nHAML\n  end\n\n  def test_convert_template_render_proc\n    assert_converts_template_properly {|e| e.render_proc.call}\n  end\n\n  def test_convert_template_render\n    assert_converts_template_properly {|e| e.render}\n  end\n\n  def test_convert_template_def_method\n    assert_converts_template_properly do |e|\n      o = Object.new\n      e.def_method(o, :render)\n      o.render\n    end\n  end\n\n  def test_encoding_error\n    render(\"foo\\nbar\\nb\\xFEaz\".force_encoding(\"utf-8\"))\n    assert(false, \"Expected exception\")\n  rescue Haml::Error => e\n    assert_equal(3, e.line)\n    assert_match(/Invalid .* character/, e.message)\n  end\n\n  def test_ascii_incompatible_encoding_error\n    template = \"foo\\nbar\\nb_z\".encode(\"utf-16le\")\n    template[9] = \"\\xFE\".force_encoding(\"utf-16le\")\n    render(template)\n    assert(false, \"Expected exception\")\n  rescue Haml::Error => e\n    assert_equal(3, e.line)\n    assert_match(/Invalid .* character/, e.message)\n  end\n\n  def test_same_coding_comment_as_encoding\n    assert_renders_encoded(<<HTML, <<HAML)\n<p>b\u00e2r</p>\n<p>f\u00f6\u00f6</p>\nHTML\n-# coding: utf-8\n%p b\u00e2r\n%p f\u00f6\u00f6\nHAML\n  end\n\n  def test_coding_comments\n    assert_valid_encoding_comment(\"-# coding: ibm866\")\n    assert_valid_encoding_comment(\"-# CodINg: IbM866\")\n    assert_valid_encoding_comment(\"-#coding:ibm866\")\n    assert_valid_encoding_comment(\"-# CodINg= ibm866\")\n    assert_valid_encoding_comment(\"-# foo BAR FAOJcoding: ibm866\")\n    assert_valid_encoding_comment(\"-# coding: ibm866 ASFJ (&(&#!$\")\n    assert_valid_encoding_comment(\"-# -*- coding: ibm866\")\n    assert_valid_encoding_comment(\"-# coding: ibm866 -*- coding: blah\")\n    assert_valid_encoding_comment(\"-# -*- coding: ibm866 -*-\")\n    assert_valid_encoding_comment(\"-# -*- encoding: ibm866 -*-\")\n    assert_valid_encoding_comment('-# -*- coding: \"ibm866\" -*-')\n    assert_valid_encoding_comment(\"-#-*-coding:ibm866-*-\")\n    assert_valid_encoding_comment(\"-#-*-coding:ibm866-*-\")\n    assert_valid_encoding_comment(\"-# -*- foo: bar; coding: ibm866; baz: bang -*-\")\n    assert_valid_encoding_comment(\"-# foo bar coding: baz -*- coding: ibm866 -*-\")\n    assert_valid_encoding_comment(\"-# -*- coding: ibm866 -*- foo bar coding: baz\")\n  end\n\n  def test_different_coding_than_system\n    assert_renders_encoded(<<HTML.encode(\"IBM866\"), <<HAML.encode(\"IBM866\"))\n<p>\u0442\u0410\u042c</p>\nHTML\n%p \u0442\u0410\u042c\nHAML\n  end\n\n  def test_block_spacing\n    begin\n      assert render(<<-HAML)\n- foo = [\"bar\", \"baz\", \"kni\"]\n- foo.each do | item |\n  = item\nHAML\n    rescue ::SyntaxError\n      flunk(\"Should not have raised syntax error\")\n    end\n  end\n\n  def test_tracing\n    result = render('%p{:class => \"hello\"}', :trace => true, :filename => 'foo').strip\n    assert_equal \"<p class='hello' data-trace='foo:1'></p>\", result\n  end\n\n  private\n\n  def assert_valid_encoding_comment(comment)\n    assert_renders_encoded(<<HTML.encode(\"IBM866\"), <<HAML.encode(\"IBM866\").force_encoding(\"UTF-8\"))\n<p>\u0416\u041b\u042b</p>\n<p>\u0442\u0410\u042c</p>\nHTML\n#{comment}\n%p \u0416\u041b\u042b\n%p \u0442\u0410\u042c\nHAML\n  end\n\n  def assert_converts_template_properly\n    engine = Haml::Engine.new(<<HAML.encode(\"iso-8859-1\"), :encoding => \"macRoman\")\n%p b\u00e2r\n%p f\u00f6\u00f6\nHAML\n    assert_encoded_equal(<<HTML.encode(\"macRoman\"), yield(engine))\n<p>b\u00e2r</p>\n<p>f\u00f6\u00f6</p>\nHTML\n  end\n\n  def assert_renders_encoded(html, haml)\n    result = render(haml)\n    assert_encoded_equal html, result\n  end\n\n  def assert_encoded_equal(expected, actual)\n    assert_equal expected.encoding, actual.encoding\n    assert_equal expected, actual\n  end\nend\n", "<?xml version='1.0' encoding='utf-8' ?>\n<?xml version='1.0' encoding='iso-8859-1' ?>\n<?xml version='1.0' encoding='utf-8' ?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">\n<strong apos='Foo&#039;s bar!'>Boo!</strong>\nEmbedded? false!\nEmbedded? true!\nEmbedded? true!\nEmbedded? twice! true!\nEmbedded? one af\"t\"er another!\n<p>Embedded? false!</p>\n<p>Embedded? true!</p>\n<p>Embedded? true!</p>\n<p>Embedded? twice! true!</p>\n<p>Embedded? one af\"t\"er another!</p>\nstuff followed by whitespace\n<strong>block with whitespace</strong>\n<p>\n  Escape\n  - character\n  %p foo\n  yee\\ha\n     don't lstrip me\n</p>\n<!-- Short comment -->\n<!--\n  This is a block comment\n  cool, huh?\n  <strong>there can even be sub-tags!</strong>\n  Or script!\n-->\n<p class=''>class attribute should appear!</p>\n<p>this attribute shouldn't appear</p>\n<!--[if lte IE6]> conditional comment! <![endif]-->\n<!--[if gte IE7]>\n  <p>Block conditional comment</p>\n  <div>\n    <h1>Cool, eh?</h1>\n  </div>\n<![endif]-->\n<!--[if gte IE5.2]>\n  Woah a period.\n<![endif]-->\ntesttest\n<br />\n<meta foo='bar' />\n<img />\n<hr />\n<link />\n<script>Inline content</script>\n<br>\n  Nested content\n</br>\n<p class='article bar foo' id='article_1'>Blah</p>\n<p class='article foo' id='article_1'>Blah</p>\n<p class='article bar baz foo' id='article_1'>Blah</p>\n<p class='article quux qux' id='article_1'>Blump</p>\n<p class='article' id='foo_bar_baz_article_1'>Whee</p>\nWoah inner quotes\n<p class='dynamic_quote' dyn='3' quotes='single &#039;'></p>\n<p class='dynamic_self_closing' dyn='3' />\n<body>\n  hello\n  <div>\n    <img />\n  </div>\n</body>\n", "<?xml version='1.0' encoding='utf-8' ?>\n<?xml version='1.0' encoding='iso-8859-1' ?>\n<?xml version='1.0' encoding='utf-8' ?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\">\n<strong apos='Foo&#039;s bar!'>Boo!</strong>\nEmbedded? false!\nEmbedded? true!\nEmbedded? true!\nEmbedded? twice! true!\nEmbedded? one af\"t\"er another!\n<p>Embedded? false!</p>\n<p>Embedded? true!</p>\n<p>Embedded? true!</p>\n<p>Embedded? twice! true!</p>\n<p>Embedded? one af\"t\"er another!</p>\nstuff followed by whitespace\n<strong>block with whitespace</strong>\n<p>\nEscape\n- character\n%p foo\nyee\\ha\n   don't lstrip me\n</p>\n<!-- Short comment -->\n<!--\nThis is a block comment\ncool, huh?\n<strong>there can even be sub-tags!</strong>\nOr script!\n-->\n<p class=''>class attribute should appear!</p>\n<p>this attribute shouldn't appear</p>\n<!--[if lte IE6]> conditional comment! <![endif]-->\n<!--[if gte IE7]>\n<p>Block conditional comment</p>\n<div>\n<h1>Cool, eh?</h1>\n</div>\n<![endif]-->\n<!--[if gte IE5.2]>\nWoah a period.\n<![endif]-->\ntesttest\n<br />\n<meta foo='bar' />\n<img />\n<hr />\n<link />\n<script>Inline content</script>\n<br>\nNested content\n</br>\n<p class='article bar foo' id='article_1'>Blah</p>\n<p class='article foo' id='article_1'>Blah</p>\n<p class='article bar baz foo' id='article_1'>Blah</p>\n<p class='article quux qux' id='article_1'>Blump</p>\n<p class='article' id='foo_bar_baz_article_1'>Whee</p>\nWoah inner quotes\n<p class='dynamic_quote' dyn='3' quotes='single &#039;'></p>\n<p class='dynamic_self_closing' dyn='3' />\n<body>\nhello\n<div>\n<img />\n</div>\n</body>\n"], "filenames": ["lib/haml/helpers.rb", "test/engine_test.rb", "test/pretty_engine_test.rb", "test/pretty_results/just_stuff.xhtml", "test/results/just_stuff.xhtml"], "buggy_code_start_loc": [599, 1130, 1132, 9, 9], "buggy_code_end_loc": [600, 1718, 1711, 65, 65], "fixing_code_start_loc": [599, 1130, 1132, 9, 9], "fixing_code_end_loc": [600, 1718, 1711, 65, 65], "type": "CWE-79", "message": "In haml versions prior to version 5.0.0.beta.2, when using user input to perform tasks on the server, characters like < > \" ' must be escaped properly. In this case, the ' character was missed. An attacker can manipulate the input to introduce additional attributes, potentially executing code.", "other": {"cve": {"id": "CVE-2017-1002201", "sourceIdentifier": "josh@bress.net", "published": "2019-10-15T18:15:10.560", "lastModified": "2022-04-05T20:53:33.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In haml versions prior to version 5.0.0.beta.2, when using user input to perform tasks on the server, characters like < > \" ' must be escaped properly. In this case, the ' character was missed. An attacker can manipulate the input to introduce additional attributes, potentially executing code."}, {"lang": "es", "value": "En haml  versiones anteriores a la versi\u00f3n 5.0.0.beta.2, cuando se usa la entrada del usuario para realizar tareas en el servidor, los caracteres como ( ) \" ' necesitan escaparse apropiadamente. En este caso, el car\u00e1cter ' se perdi\u00f3. Un atacante puede manipular la entrada para introducir atributos adicionales, ejecutando potencialmente c\u00f3digo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:haml:haml:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "5.0.0", "matchCriteriaId": "BD7B8475-41D4-4A62-91BB-99A105EBA4F2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/haml/haml/commit/18576ae6e9bdcb4303fdbe6b3199869d289d67c2", "source": "josh@bress.net", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/11/msg00007.html", "source": "josh@bress.net", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/12/msg00028.html", "source": "josh@bress.net", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202007-27", "source": "josh@bress.net", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-RUBY-HAML-20362", "source": "josh@bress.net", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/haml/haml/commit/18576ae6e9bdcb4303fdbe6b3199869d289d67c2"}}