{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2016, Linaro Ltd.\n * Copyright (c) 2012, Michal Simek <monstr@monstr.eu>\n * Copyright (c) 2012, PetaLogix\n * Copyright (c) 2011, Texas Instruments, Inc.\n * Copyright (c) 2011, Google, Inc.\n *\n * Based on rpmsg performance statistics driver by Michal Simek, which in turn\n * was based on TI & Google OMX rpmsg driver.\n */\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/rpmsg.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/rpmsg.h>\n\n#include \"rpmsg_internal.h\"\n\n#define RPMSG_DEV_MAX\t(MINORMASK + 1)\n\nstatic dev_t rpmsg_major;\nstatic struct class *rpmsg_class;\n\nstatic DEFINE_IDA(rpmsg_ctrl_ida);\nstatic DEFINE_IDA(rpmsg_ept_ida);\nstatic DEFINE_IDA(rpmsg_minor_ida);\n\n#define dev_to_eptdev(dev) container_of(dev, struct rpmsg_eptdev, dev)\n#define cdev_to_eptdev(i_cdev) container_of(i_cdev, struct rpmsg_eptdev, cdev)\n\n#define dev_to_ctrldev(dev) container_of(dev, struct rpmsg_ctrldev, dev)\n#define cdev_to_ctrldev(i_cdev) container_of(i_cdev, struct rpmsg_ctrldev, cdev)\n\n/**\n * struct rpmsg_ctrldev - control device for instantiating endpoint devices\n * @rpdev:\tunderlaying rpmsg device\n * @cdev:\tcdev for the ctrl device\n * @dev:\tdevice for the ctrl device\n */\nstruct rpmsg_ctrldev {\n\tstruct rpmsg_device *rpdev;\n\tstruct cdev cdev;\n\tstruct device dev;\n};\n\n/**\n * struct rpmsg_eptdev - endpoint device context\n * @dev:\tendpoint device\n * @cdev:\tcdev for the endpoint device\n * @rpdev:\tunderlaying rpmsg device\n * @chinfo:\tinfo used to open the endpoint\n * @ept_lock:\tsynchronization of @ept modifications\n * @ept:\trpmsg endpoint reference, when open\n * @queue_lock:\tsynchronization of @queue operations\n * @queue:\tincoming message queue\n * @readq:\twait object for incoming queue\n */\nstruct rpmsg_eptdev {\n\tstruct device dev;\n\tstruct cdev cdev;\n\n\tstruct rpmsg_device *rpdev;\n\tstruct rpmsg_channel_info chinfo;\n\n\tstruct mutex ept_lock;\n\tstruct rpmsg_endpoint *ept;\n\n\tspinlock_t queue_lock;\n\tstruct sk_buff_head queue;\n\twait_queue_head_t readq;\n};\n\nstatic int rpmsg_eptdev_destroy(struct device *dev, void *data)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_to_eptdev(dev);\n\n\tmutex_lock(&eptdev->ept_lock);\n\tif (eptdev->ept) {\n\t\trpmsg_destroy_ept(eptdev->ept);\n\t\teptdev->ept = NULL;\n\t}\n\tmutex_unlock(&eptdev->ept_lock);\n\n\t/* wake up any blocked readers */\n\twake_up_interruptible(&eptdev->readq);\n\n\tdevice_del(&eptdev->dev);\n\tput_device(&eptdev->dev);\n\n\treturn 0;\n}\n\nstatic int rpmsg_ept_cb(struct rpmsg_device *rpdev, void *buf, int len,\n\t\t\tvoid *priv, u32 addr)\n{\n\tstruct rpmsg_eptdev *eptdev = priv;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, buf, len);\n\n\tspin_lock(&eptdev->queue_lock);\n\tskb_queue_tail(&eptdev->queue, skb);\n\tspin_unlock(&eptdev->queue_lock);\n\n\t/* wake up any blocking processes, waiting for new data */\n\twake_up_interruptible(&eptdev->readq);\n\n\treturn 0;\n}\n\nstatic int rpmsg_eptdev_open(struct inode *inode, struct file *filp)\n{\n\tstruct rpmsg_eptdev *eptdev = cdev_to_eptdev(inode->i_cdev);\n\tstruct rpmsg_endpoint *ept;\n\tstruct rpmsg_device *rpdev = eptdev->rpdev;\n\tstruct device *dev = &eptdev->dev;\n\n\tget_device(dev);\n\n\tept = rpmsg_create_ept(rpdev, rpmsg_ept_cb, eptdev, eptdev->chinfo);\n\tif (!ept) {\n\t\tdev_err(dev, \"failed to open %s\\n\", eptdev->chinfo.name);\n\t\tput_device(dev);\n\t\treturn -EINVAL;\n\t}\n\n\teptdev->ept = ept;\n\tfilp->private_data = eptdev;\n\n\treturn 0;\n}\n\nstatic int rpmsg_eptdev_release(struct inode *inode, struct file *filp)\n{\n\tstruct rpmsg_eptdev *eptdev = cdev_to_eptdev(inode->i_cdev);\n\tstruct device *dev = &eptdev->dev;\n\tstruct sk_buff *skb;\n\n\t/* Close the endpoint, if it's not already destroyed by the parent */\n\tmutex_lock(&eptdev->ept_lock);\n\tif (eptdev->ept) {\n\t\trpmsg_destroy_ept(eptdev->ept);\n\t\teptdev->ept = NULL;\n\t}\n\tmutex_unlock(&eptdev->ept_lock);\n\n\t/* Discard all SKBs */\n\twhile (!skb_queue_empty(&eptdev->queue)) {\n\t\tskb = skb_dequeue(&eptdev->queue);\n\t\tkfree_skb(skb);\n\t}\n\n\tput_device(dev);\n\n\treturn 0;\n}\n\nstatic ssize_t rpmsg_eptdev_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tint use;\n\n\tif (!eptdev->ept)\n\t\treturn -EPIPE;\n\n\tspin_lock_irqsave(&eptdev->queue_lock, flags);\n\n\t/* Wait for data in the queue */\n\tif (skb_queue_empty(&eptdev->queue)) {\n\t\tspin_unlock_irqrestore(&eptdev->queue_lock, flags);\n\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\t/* Wait until we get data or the endpoint goes away */\n\t\tif (wait_event_interruptible(eptdev->readq,\n\t\t\t\t\t     !skb_queue_empty(&eptdev->queue) ||\n\t\t\t\t\t     !eptdev->ept))\n\t\t\treturn -ERESTARTSYS;\n\n\t\t/* We lost the endpoint while waiting */\n\t\tif (!eptdev->ept)\n\t\t\treturn -EPIPE;\n\n\t\tspin_lock_irqsave(&eptdev->queue_lock, flags);\n\t}\n\n\tskb = skb_dequeue(&eptdev->queue);\n\tspin_unlock_irqrestore(&eptdev->queue_lock, flags);\n\tif (!skb)\n\t\treturn -EFAULT;\n\n\tuse = min_t(size_t, iov_iter_count(to), skb->len);\n\tif (copy_to_iter(skb->data, use, to) != use)\n\t\tuse = -EFAULT;\n\n\tkfree_skb(skb);\n\n\treturn use;\n}\n\nstatic ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\n\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\n\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}\n\nstatic __poll_t rpmsg_eptdev_poll(struct file *filp, poll_table *wait)\n{\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\t__poll_t mask = 0;\n\n\tif (!eptdev->ept)\n\t\treturn EPOLLERR;\n\n\tpoll_wait(filp, &eptdev->readq, wait);\n\n\tif (!skb_queue_empty(&eptdev->queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\tmask |= rpmsg_poll(eptdev->ept, filp, wait);\n\n\treturn mask;\n}\n\nstatic long rpmsg_eptdev_ioctl(struct file *fp, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tstruct rpmsg_eptdev *eptdev = fp->private_data;\n\n\tif (cmd != RPMSG_DESTROY_EPT_IOCTL)\n\t\treturn -EINVAL;\n\n\treturn rpmsg_eptdev_destroy(&eptdev->dev, NULL);\n}\n\nstatic const struct file_operations rpmsg_eptdev_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rpmsg_eptdev_open,\n\t.release = rpmsg_eptdev_release,\n\t.read_iter = rpmsg_eptdev_read_iter,\n\t.write_iter = rpmsg_eptdev_write_iter,\n\t.poll = rpmsg_eptdev_poll,\n\t.unlocked_ioctl = rpmsg_eptdev_ioctl,\n\t.compat_ioctl = rpmsg_eptdev_ioctl,\n};\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", eptdev->chinfo.name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t src_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", eptdev->chinfo.src);\n}\nstatic DEVICE_ATTR_RO(src);\n\nstatic ssize_t dst_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", eptdev->chinfo.dst);\n}\nstatic DEVICE_ATTR_RO(dst);\n\nstatic struct attribute *rpmsg_eptdev_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_src.attr,\n\t&dev_attr_dst.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(rpmsg_eptdev);\n\nstatic void rpmsg_eptdev_release_device(struct device *dev)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_to_eptdev(dev);\n\n\tida_simple_remove(&rpmsg_ept_ida, dev->id);\n\tida_simple_remove(&rpmsg_minor_ida, MINOR(eptdev->dev.devt));\n\tcdev_del(&eptdev->cdev);\n\tkfree(eptdev);\n}\n\nstatic int rpmsg_eptdev_create(struct rpmsg_ctrldev *ctrldev,\n\t\t\t       struct rpmsg_channel_info chinfo)\n{\n\tstruct rpmsg_device *rpdev = ctrldev->rpdev;\n\tstruct rpmsg_eptdev *eptdev;\n\tstruct device *dev;\n\tint ret;\n\n\teptdev = kzalloc(sizeof(*eptdev), GFP_KERNEL);\n\tif (!eptdev)\n\t\treturn -ENOMEM;\n\n\tdev = &eptdev->dev;\n\teptdev->rpdev = rpdev;\n\teptdev->chinfo = chinfo;\n\n\tmutex_init(&eptdev->ept_lock);\n\tspin_lock_init(&eptdev->queue_lock);\n\tskb_queue_head_init(&eptdev->queue);\n\tinit_waitqueue_head(&eptdev->readq);\n\n\tdevice_initialize(dev);\n\tdev->class = rpmsg_class;\n\tdev->parent = &ctrldev->dev;\n\tdev->groups = rpmsg_eptdev_groups;\n\tdev_set_drvdata(dev, eptdev);\n\n\tcdev_init(&eptdev->cdev, &rpmsg_eptdev_fops);\n\teptdev->cdev.owner = THIS_MODULE;\n\n\tret = ida_simple_get(&rpmsg_minor_ida, 0, RPMSG_DEV_MAX, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto free_eptdev;\n\tdev->devt = MKDEV(MAJOR(rpmsg_major), ret);\n\n\tret = ida_simple_get(&rpmsg_ept_ida, 0, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto free_minor_ida;\n\tdev->id = ret;\n\tdev_set_name(dev, \"rpmsg%d\", ret);\n\n\tret = cdev_add(&eptdev->cdev, dev->devt, 1);\n\tif (ret)\n\t\tgoto free_ept_ida;\n\n\t/* We can now rely on the release function for cleanup */\n\tdev->release = rpmsg_eptdev_release_device;\n\n\tret = device_add(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"device_add failed: %d\\n\", ret);\n\t\tput_device(dev);\n\t}\n\n\treturn ret;\n\nfree_ept_ida:\n\tida_simple_remove(&rpmsg_ept_ida, dev->id);\nfree_minor_ida:\n\tida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));\nfree_eptdev:\n\tput_device(dev);\n\tkfree(eptdev);\n\n\treturn ret;\n}\n\nstatic int rpmsg_ctrldev_open(struct inode *inode, struct file *filp)\n{\n\tstruct rpmsg_ctrldev *ctrldev = cdev_to_ctrldev(inode->i_cdev);\n\n\tget_device(&ctrldev->dev);\n\tfilp->private_data = ctrldev;\n\n\treturn 0;\n}\n\nstatic int rpmsg_ctrldev_release(struct inode *inode, struct file *filp)\n{\n\tstruct rpmsg_ctrldev *ctrldev = cdev_to_ctrldev(inode->i_cdev);\n\n\tput_device(&ctrldev->dev);\n\n\treturn 0;\n}\n\nstatic long rpmsg_ctrldev_ioctl(struct file *fp, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct rpmsg_ctrldev *ctrldev = fp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tstruct rpmsg_endpoint_info eptinfo;\n\tstruct rpmsg_channel_info chinfo;\n\n\tif (cmd != RPMSG_CREATE_EPT_IOCTL)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&eptinfo, argp, sizeof(eptinfo)))\n\t\treturn -EFAULT;\n\n\tmemcpy(chinfo.name, eptinfo.name, RPMSG_NAME_SIZE);\n\tchinfo.name[RPMSG_NAME_SIZE-1] = '\\0';\n\tchinfo.src = eptinfo.src;\n\tchinfo.dst = eptinfo.dst;\n\n\treturn rpmsg_eptdev_create(ctrldev, chinfo);\n};\n\nstatic const struct file_operations rpmsg_ctrldev_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rpmsg_ctrldev_open,\n\t.release = rpmsg_ctrldev_release,\n\t.unlocked_ioctl = rpmsg_ctrldev_ioctl,\n\t.compat_ioctl = rpmsg_ctrldev_ioctl,\n};\n\nstatic void rpmsg_ctrldev_release_device(struct device *dev)\n{\n\tstruct rpmsg_ctrldev *ctrldev = dev_to_ctrldev(dev);\n\n\tida_simple_remove(&rpmsg_ctrl_ida, dev->id);\n\tida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));\n\tcdev_del(&ctrldev->cdev);\n\tkfree(ctrldev);\n}\n\nstatic int rpmsg_chrdev_probe(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_ctrldev *ctrldev;\n\tstruct device *dev;\n\tint ret;\n\n\tctrldev = kzalloc(sizeof(*ctrldev), GFP_KERNEL);\n\tif (!ctrldev)\n\t\treturn -ENOMEM;\n\n\tctrldev->rpdev = rpdev;\n\n\tdev = &ctrldev->dev;\n\tdevice_initialize(dev);\n\tdev->parent = &rpdev->dev;\n\tdev->class = rpmsg_class;\n\n\tcdev_init(&ctrldev->cdev, &rpmsg_ctrldev_fops);\n\tctrldev->cdev.owner = THIS_MODULE;\n\n\tret = ida_simple_get(&rpmsg_minor_ida, 0, RPMSG_DEV_MAX, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto free_ctrldev;\n\tdev->devt = MKDEV(MAJOR(rpmsg_major), ret);\n\n\tret = ida_simple_get(&rpmsg_ctrl_ida, 0, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto free_minor_ida;\n\tdev->id = ret;\n\tdev_set_name(&ctrldev->dev, \"rpmsg_ctrl%d\", ret);\n\n\tret = cdev_add(&ctrldev->cdev, dev->devt, 1);\n\tif (ret)\n\t\tgoto free_ctrl_ida;\n\n\t/* We can now rely on the release function for cleanup */\n\tdev->release = rpmsg_ctrldev_release_device;\n\n\tret = device_add(dev);\n\tif (ret) {\n\t\tdev_err(&rpdev->dev, \"device_add failed: %d\\n\", ret);\n\t\tput_device(dev);\n\t}\n\n\tdev_set_drvdata(&rpdev->dev, ctrldev);\n\n\treturn ret;\n\nfree_ctrl_ida:\n\tida_simple_remove(&rpmsg_ctrl_ida, dev->id);\nfree_minor_ida:\n\tida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));\nfree_ctrldev:\n\tput_device(dev);\n\tkfree(ctrldev);\n\n\treturn ret;\n}\n\nstatic void rpmsg_chrdev_remove(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_ctrldev *ctrldev = dev_get_drvdata(&rpdev->dev);\n\tint ret;\n\n\t/* Destroy all endpoints */\n\tret = device_for_each_child(&ctrldev->dev, NULL, rpmsg_eptdev_destroy);\n\tif (ret)\n\t\tdev_warn(&rpdev->dev, \"failed to nuke endpoints: %d\\n\", ret);\n\n\tdevice_del(&ctrldev->dev);\n\tput_device(&ctrldev->dev);\n}\n\nstatic struct rpmsg_driver rpmsg_chrdev_driver = {\n\t.probe = rpmsg_chrdev_probe,\n\t.remove = rpmsg_chrdev_remove,\n\t.drv = {\n\t\t.name = \"rpmsg_chrdev\",\n\t},\n};\n\nstatic int rpmsg_char_init(void)\n{\n\tint ret;\n\n\tret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, \"rpmsg\");\n\tif (ret < 0) {\n\t\tpr_err(\"rpmsg: failed to allocate char dev region\\n\");\n\t\treturn ret;\n\t}\n\n\trpmsg_class = class_create(THIS_MODULE, \"rpmsg\");\n\tif (IS_ERR(rpmsg_class)) {\n\t\tpr_err(\"failed to create rpmsg class\\n\");\n\t\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n\t\treturn PTR_ERR(rpmsg_class);\n\t}\n\n\tret = register_rpmsg_driver(&rpmsg_chrdev_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"rpmsgchr: failed to register rpmsg driver\\n\");\n\t\tclass_destroy(rpmsg_class);\n\t\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n\t}\n\n\treturn ret;\n}\npostcore_initcall(rpmsg_char_init);\n\nstatic void rpmsg_chrdev_exit(void)\n{\n\tunregister_rpmsg_driver(&rpmsg_chrdev_driver);\n\tclass_destroy(rpmsg_class);\n\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n}\nmodule_exit(rpmsg_chrdev_exit);\n\nMODULE_ALIAS(\"rpmsg:rpmsg_chrdev\");\nMODULE_LICENSE(\"GPL v2\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2016, Linaro Ltd.\n * Copyright (c) 2012, Michal Simek <monstr@monstr.eu>\n * Copyright (c) 2012, PetaLogix\n * Copyright (c) 2011, Texas Instruments, Inc.\n * Copyright (c) 2011, Google, Inc.\n *\n * Based on rpmsg performance statistics driver by Michal Simek, which in turn\n * was based on TI & Google OMX rpmsg driver.\n */\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/rpmsg.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/rpmsg.h>\n\n#include \"rpmsg_internal.h\"\n\n#define RPMSG_DEV_MAX\t(MINORMASK + 1)\n\nstatic dev_t rpmsg_major;\nstatic struct class *rpmsg_class;\n\nstatic DEFINE_IDA(rpmsg_ctrl_ida);\nstatic DEFINE_IDA(rpmsg_ept_ida);\nstatic DEFINE_IDA(rpmsg_minor_ida);\n\n#define dev_to_eptdev(dev) container_of(dev, struct rpmsg_eptdev, dev)\n#define cdev_to_eptdev(i_cdev) container_of(i_cdev, struct rpmsg_eptdev, cdev)\n\n#define dev_to_ctrldev(dev) container_of(dev, struct rpmsg_ctrldev, dev)\n#define cdev_to_ctrldev(i_cdev) container_of(i_cdev, struct rpmsg_ctrldev, cdev)\n\n/**\n * struct rpmsg_ctrldev - control device for instantiating endpoint devices\n * @rpdev:\tunderlaying rpmsg device\n * @cdev:\tcdev for the ctrl device\n * @dev:\tdevice for the ctrl device\n */\nstruct rpmsg_ctrldev {\n\tstruct rpmsg_device *rpdev;\n\tstruct cdev cdev;\n\tstruct device dev;\n};\n\n/**\n * struct rpmsg_eptdev - endpoint device context\n * @dev:\tendpoint device\n * @cdev:\tcdev for the endpoint device\n * @rpdev:\tunderlaying rpmsg device\n * @chinfo:\tinfo used to open the endpoint\n * @ept_lock:\tsynchronization of @ept modifications\n * @ept:\trpmsg endpoint reference, when open\n * @queue_lock:\tsynchronization of @queue operations\n * @queue:\tincoming message queue\n * @readq:\twait object for incoming queue\n */\nstruct rpmsg_eptdev {\n\tstruct device dev;\n\tstruct cdev cdev;\n\n\tstruct rpmsg_device *rpdev;\n\tstruct rpmsg_channel_info chinfo;\n\n\tstruct mutex ept_lock;\n\tstruct rpmsg_endpoint *ept;\n\n\tspinlock_t queue_lock;\n\tstruct sk_buff_head queue;\n\twait_queue_head_t readq;\n};\n\nstatic int rpmsg_eptdev_destroy(struct device *dev, void *data)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_to_eptdev(dev);\n\n\tmutex_lock(&eptdev->ept_lock);\n\tif (eptdev->ept) {\n\t\trpmsg_destroy_ept(eptdev->ept);\n\t\teptdev->ept = NULL;\n\t}\n\tmutex_unlock(&eptdev->ept_lock);\n\n\t/* wake up any blocked readers */\n\twake_up_interruptible(&eptdev->readq);\n\n\tdevice_del(&eptdev->dev);\n\tput_device(&eptdev->dev);\n\n\treturn 0;\n}\n\nstatic int rpmsg_ept_cb(struct rpmsg_device *rpdev, void *buf, int len,\n\t\t\tvoid *priv, u32 addr)\n{\n\tstruct rpmsg_eptdev *eptdev = priv;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, buf, len);\n\n\tspin_lock(&eptdev->queue_lock);\n\tskb_queue_tail(&eptdev->queue, skb);\n\tspin_unlock(&eptdev->queue_lock);\n\n\t/* wake up any blocking processes, waiting for new data */\n\twake_up_interruptible(&eptdev->readq);\n\n\treturn 0;\n}\n\nstatic int rpmsg_eptdev_open(struct inode *inode, struct file *filp)\n{\n\tstruct rpmsg_eptdev *eptdev = cdev_to_eptdev(inode->i_cdev);\n\tstruct rpmsg_endpoint *ept;\n\tstruct rpmsg_device *rpdev = eptdev->rpdev;\n\tstruct device *dev = &eptdev->dev;\n\n\tget_device(dev);\n\n\tept = rpmsg_create_ept(rpdev, rpmsg_ept_cb, eptdev, eptdev->chinfo);\n\tif (!ept) {\n\t\tdev_err(dev, \"failed to open %s\\n\", eptdev->chinfo.name);\n\t\tput_device(dev);\n\t\treturn -EINVAL;\n\t}\n\n\teptdev->ept = ept;\n\tfilp->private_data = eptdev;\n\n\treturn 0;\n}\n\nstatic int rpmsg_eptdev_release(struct inode *inode, struct file *filp)\n{\n\tstruct rpmsg_eptdev *eptdev = cdev_to_eptdev(inode->i_cdev);\n\tstruct device *dev = &eptdev->dev;\n\tstruct sk_buff *skb;\n\n\t/* Close the endpoint, if it's not already destroyed by the parent */\n\tmutex_lock(&eptdev->ept_lock);\n\tif (eptdev->ept) {\n\t\trpmsg_destroy_ept(eptdev->ept);\n\t\teptdev->ept = NULL;\n\t}\n\tmutex_unlock(&eptdev->ept_lock);\n\n\t/* Discard all SKBs */\n\twhile (!skb_queue_empty(&eptdev->queue)) {\n\t\tskb = skb_dequeue(&eptdev->queue);\n\t\tkfree_skb(skb);\n\t}\n\n\tput_device(dev);\n\n\treturn 0;\n}\n\nstatic ssize_t rpmsg_eptdev_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tint use;\n\n\tif (!eptdev->ept)\n\t\treturn -EPIPE;\n\n\tspin_lock_irqsave(&eptdev->queue_lock, flags);\n\n\t/* Wait for data in the queue */\n\tif (skb_queue_empty(&eptdev->queue)) {\n\t\tspin_unlock_irqrestore(&eptdev->queue_lock, flags);\n\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\t/* Wait until we get data or the endpoint goes away */\n\t\tif (wait_event_interruptible(eptdev->readq,\n\t\t\t\t\t     !skb_queue_empty(&eptdev->queue) ||\n\t\t\t\t\t     !eptdev->ept))\n\t\t\treturn -ERESTARTSYS;\n\n\t\t/* We lost the endpoint while waiting */\n\t\tif (!eptdev->ept)\n\t\t\treturn -EPIPE;\n\n\t\tspin_lock_irqsave(&eptdev->queue_lock, flags);\n\t}\n\n\tskb = skb_dequeue(&eptdev->queue);\n\tspin_unlock_irqrestore(&eptdev->queue_lock, flags);\n\tif (!skb)\n\t\treturn -EFAULT;\n\n\tuse = min_t(size_t, iov_iter_count(to), skb->len);\n\tif (copy_to_iter(skb->data, use, to) != use)\n\t\tuse = -EFAULT;\n\n\tkfree_skb(skb);\n\n\treturn use;\n}\n\nstatic ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from)) {\n\t\tret = -EFAULT;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\n\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\n\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}\n\nstatic __poll_t rpmsg_eptdev_poll(struct file *filp, poll_table *wait)\n{\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\t__poll_t mask = 0;\n\n\tif (!eptdev->ept)\n\t\treturn EPOLLERR;\n\n\tpoll_wait(filp, &eptdev->readq, wait);\n\n\tif (!skb_queue_empty(&eptdev->queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\tmask |= rpmsg_poll(eptdev->ept, filp, wait);\n\n\treturn mask;\n}\n\nstatic long rpmsg_eptdev_ioctl(struct file *fp, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tstruct rpmsg_eptdev *eptdev = fp->private_data;\n\n\tif (cmd != RPMSG_DESTROY_EPT_IOCTL)\n\t\treturn -EINVAL;\n\n\treturn rpmsg_eptdev_destroy(&eptdev->dev, NULL);\n}\n\nstatic const struct file_operations rpmsg_eptdev_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rpmsg_eptdev_open,\n\t.release = rpmsg_eptdev_release,\n\t.read_iter = rpmsg_eptdev_read_iter,\n\t.write_iter = rpmsg_eptdev_write_iter,\n\t.poll = rpmsg_eptdev_poll,\n\t.unlocked_ioctl = rpmsg_eptdev_ioctl,\n\t.compat_ioctl = rpmsg_eptdev_ioctl,\n};\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", eptdev->chinfo.name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t src_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", eptdev->chinfo.src);\n}\nstatic DEVICE_ATTR_RO(src);\n\nstatic ssize_t dst_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", eptdev->chinfo.dst);\n}\nstatic DEVICE_ATTR_RO(dst);\n\nstatic struct attribute *rpmsg_eptdev_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_src.attr,\n\t&dev_attr_dst.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(rpmsg_eptdev);\n\nstatic void rpmsg_eptdev_release_device(struct device *dev)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_to_eptdev(dev);\n\n\tida_simple_remove(&rpmsg_ept_ida, dev->id);\n\tida_simple_remove(&rpmsg_minor_ida, MINOR(eptdev->dev.devt));\n\tcdev_del(&eptdev->cdev);\n\tkfree(eptdev);\n}\n\nstatic int rpmsg_eptdev_create(struct rpmsg_ctrldev *ctrldev,\n\t\t\t       struct rpmsg_channel_info chinfo)\n{\n\tstruct rpmsg_device *rpdev = ctrldev->rpdev;\n\tstruct rpmsg_eptdev *eptdev;\n\tstruct device *dev;\n\tint ret;\n\n\teptdev = kzalloc(sizeof(*eptdev), GFP_KERNEL);\n\tif (!eptdev)\n\t\treturn -ENOMEM;\n\n\tdev = &eptdev->dev;\n\teptdev->rpdev = rpdev;\n\teptdev->chinfo = chinfo;\n\n\tmutex_init(&eptdev->ept_lock);\n\tspin_lock_init(&eptdev->queue_lock);\n\tskb_queue_head_init(&eptdev->queue);\n\tinit_waitqueue_head(&eptdev->readq);\n\n\tdevice_initialize(dev);\n\tdev->class = rpmsg_class;\n\tdev->parent = &ctrldev->dev;\n\tdev->groups = rpmsg_eptdev_groups;\n\tdev_set_drvdata(dev, eptdev);\n\n\tcdev_init(&eptdev->cdev, &rpmsg_eptdev_fops);\n\teptdev->cdev.owner = THIS_MODULE;\n\n\tret = ida_simple_get(&rpmsg_minor_ida, 0, RPMSG_DEV_MAX, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto free_eptdev;\n\tdev->devt = MKDEV(MAJOR(rpmsg_major), ret);\n\n\tret = ida_simple_get(&rpmsg_ept_ida, 0, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto free_minor_ida;\n\tdev->id = ret;\n\tdev_set_name(dev, \"rpmsg%d\", ret);\n\n\tret = cdev_add(&eptdev->cdev, dev->devt, 1);\n\tif (ret)\n\t\tgoto free_ept_ida;\n\n\t/* We can now rely on the release function for cleanup */\n\tdev->release = rpmsg_eptdev_release_device;\n\n\tret = device_add(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"device_add failed: %d\\n\", ret);\n\t\tput_device(dev);\n\t}\n\n\treturn ret;\n\nfree_ept_ida:\n\tida_simple_remove(&rpmsg_ept_ida, dev->id);\nfree_minor_ida:\n\tida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));\nfree_eptdev:\n\tput_device(dev);\n\tkfree(eptdev);\n\n\treturn ret;\n}\n\nstatic int rpmsg_ctrldev_open(struct inode *inode, struct file *filp)\n{\n\tstruct rpmsg_ctrldev *ctrldev = cdev_to_ctrldev(inode->i_cdev);\n\n\tget_device(&ctrldev->dev);\n\tfilp->private_data = ctrldev;\n\n\treturn 0;\n}\n\nstatic int rpmsg_ctrldev_release(struct inode *inode, struct file *filp)\n{\n\tstruct rpmsg_ctrldev *ctrldev = cdev_to_ctrldev(inode->i_cdev);\n\n\tput_device(&ctrldev->dev);\n\n\treturn 0;\n}\n\nstatic long rpmsg_ctrldev_ioctl(struct file *fp, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct rpmsg_ctrldev *ctrldev = fp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tstruct rpmsg_endpoint_info eptinfo;\n\tstruct rpmsg_channel_info chinfo;\n\n\tif (cmd != RPMSG_CREATE_EPT_IOCTL)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&eptinfo, argp, sizeof(eptinfo)))\n\t\treturn -EFAULT;\n\n\tmemcpy(chinfo.name, eptinfo.name, RPMSG_NAME_SIZE);\n\tchinfo.name[RPMSG_NAME_SIZE-1] = '\\0';\n\tchinfo.src = eptinfo.src;\n\tchinfo.dst = eptinfo.dst;\n\n\treturn rpmsg_eptdev_create(ctrldev, chinfo);\n};\n\nstatic const struct file_operations rpmsg_ctrldev_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rpmsg_ctrldev_open,\n\t.release = rpmsg_ctrldev_release,\n\t.unlocked_ioctl = rpmsg_ctrldev_ioctl,\n\t.compat_ioctl = rpmsg_ctrldev_ioctl,\n};\n\nstatic void rpmsg_ctrldev_release_device(struct device *dev)\n{\n\tstruct rpmsg_ctrldev *ctrldev = dev_to_ctrldev(dev);\n\n\tida_simple_remove(&rpmsg_ctrl_ida, dev->id);\n\tida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));\n\tcdev_del(&ctrldev->cdev);\n\tkfree(ctrldev);\n}\n\nstatic int rpmsg_chrdev_probe(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_ctrldev *ctrldev;\n\tstruct device *dev;\n\tint ret;\n\n\tctrldev = kzalloc(sizeof(*ctrldev), GFP_KERNEL);\n\tif (!ctrldev)\n\t\treturn -ENOMEM;\n\n\tctrldev->rpdev = rpdev;\n\n\tdev = &ctrldev->dev;\n\tdevice_initialize(dev);\n\tdev->parent = &rpdev->dev;\n\tdev->class = rpmsg_class;\n\n\tcdev_init(&ctrldev->cdev, &rpmsg_ctrldev_fops);\n\tctrldev->cdev.owner = THIS_MODULE;\n\n\tret = ida_simple_get(&rpmsg_minor_ida, 0, RPMSG_DEV_MAX, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto free_ctrldev;\n\tdev->devt = MKDEV(MAJOR(rpmsg_major), ret);\n\n\tret = ida_simple_get(&rpmsg_ctrl_ida, 0, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto free_minor_ida;\n\tdev->id = ret;\n\tdev_set_name(&ctrldev->dev, \"rpmsg_ctrl%d\", ret);\n\n\tret = cdev_add(&ctrldev->cdev, dev->devt, 1);\n\tif (ret)\n\t\tgoto free_ctrl_ida;\n\n\t/* We can now rely on the release function for cleanup */\n\tdev->release = rpmsg_ctrldev_release_device;\n\n\tret = device_add(dev);\n\tif (ret) {\n\t\tdev_err(&rpdev->dev, \"device_add failed: %d\\n\", ret);\n\t\tput_device(dev);\n\t}\n\n\tdev_set_drvdata(&rpdev->dev, ctrldev);\n\n\treturn ret;\n\nfree_ctrl_ida:\n\tida_simple_remove(&rpmsg_ctrl_ida, dev->id);\nfree_minor_ida:\n\tida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));\nfree_ctrldev:\n\tput_device(dev);\n\tkfree(ctrldev);\n\n\treturn ret;\n}\n\nstatic void rpmsg_chrdev_remove(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_ctrldev *ctrldev = dev_get_drvdata(&rpdev->dev);\n\tint ret;\n\n\t/* Destroy all endpoints */\n\tret = device_for_each_child(&ctrldev->dev, NULL, rpmsg_eptdev_destroy);\n\tif (ret)\n\t\tdev_warn(&rpdev->dev, \"failed to nuke endpoints: %d\\n\", ret);\n\n\tdevice_del(&ctrldev->dev);\n\tput_device(&ctrldev->dev);\n}\n\nstatic struct rpmsg_driver rpmsg_chrdev_driver = {\n\t.probe = rpmsg_chrdev_probe,\n\t.remove = rpmsg_chrdev_remove,\n\t.drv = {\n\t\t.name = \"rpmsg_chrdev\",\n\t},\n};\n\nstatic int rpmsg_char_init(void)\n{\n\tint ret;\n\n\tret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, \"rpmsg\");\n\tif (ret < 0) {\n\t\tpr_err(\"rpmsg: failed to allocate char dev region\\n\");\n\t\treturn ret;\n\t}\n\n\trpmsg_class = class_create(THIS_MODULE, \"rpmsg\");\n\tif (IS_ERR(rpmsg_class)) {\n\t\tpr_err(\"failed to create rpmsg class\\n\");\n\t\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n\t\treturn PTR_ERR(rpmsg_class);\n\t}\n\n\tret = register_rpmsg_driver(&rpmsg_chrdev_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"rpmsgchr: failed to register rpmsg driver\\n\");\n\t\tclass_destroy(rpmsg_class);\n\t\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n\t}\n\n\treturn ret;\n}\npostcore_initcall(rpmsg_char_init);\n\nstatic void rpmsg_chrdev_exit(void)\n{\n\tunregister_rpmsg_driver(&rpmsg_chrdev_driver);\n\tclass_destroy(rpmsg_class);\n\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n}\nmodule_exit(rpmsg_chrdev_exit);\n\nMODULE_ALIAS(\"rpmsg:rpmsg_chrdev\");\nMODULE_LICENSE(\"GPL v2\");\n"], "filenames": ["drivers/rpmsg/rpmsg_char.c"], "buggy_code_start_loc": [230], "buggy_code_end_loc": [232], "fixing_code_start_loc": [230], "fixing_code_end_loc": [234], "type": "CWE-401", "message": "A memory leak in the rpmsg_eptdev_write_iter() function in drivers/rpmsg/rpmsg_char.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering copy_from_iter_full() failures, aka CID-bbe692e349e2.", "other": {"cve": {"id": "CVE-2019-19053", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:11.903", "lastModified": "2023-01-19T19:43:51.683", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the rpmsg_eptdev_write_iter() function in drivers/rpmsg/rpmsg_char.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering copy_from_iter_full() failures, aka CID-bbe692e349e2."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n rpmsg_eptdev_write_iter() en el archivo drivers/rpmsg/rpmsg_char.c en el kernel de Linux versiones hasta la versi\u00f3n 5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n copy_from_iter_full(), tambi\u00e9n se conoce como CID-bbe692e349e2."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.4.12", "matchCriteriaId": "81529934-E2E4-4EDA-8787-54E9CB8B046D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:aff_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C0ADE5D-F91D-4E0D-B6C5-3511B19665F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:data_availability_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "0EF46487-B64A-454E-AECC-D74B83170ACD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "8AFF1109-26F3-43A5-A4CB-0F169FDBC0DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "5AF71C49-ADEF-4EE2-802C-6159ADD51355"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.20:*:*:*:*:*:*:*", "matchCriteriaId": "B3BC6E59-2134-4A28-AAD2-77C8AE236BCF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.25:*:*:*:*:*:*:*", "matchCriteriaId": "24377899-5389-4BDC-AC82-0E4186F4DE53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.30:*:*:*:*:*:*:*", "matchCriteriaId": "23FE83DE-AE7C-4313-88E3-886110C31302"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.30.5r3:*:*:*:*:*:*:*", "matchCriteriaId": "490B327B-AC20-419B-BB76-8AB6971304BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40:*:*:*:*:*:*:*", "matchCriteriaId": "8DCE2754-7A9E-4B3B-91D1-DCF90C1BABE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40.3r2:*:*:*:*:*:*:*", "matchCriteriaId": "6CA74E8B-51E2-4A7C-8A98-0583D31134A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.40.5:*:*:*:*:*:*:*", "matchCriteriaId": "7B64AB37-A1D9-4163-A51B-4C780361F1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.1:*:*:*:*:*:*:*", "matchCriteriaId": "7BE9C9D7-9CED-4184-A190-1024A6FB8C82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.2:-:*:*:*:*:*:*", "matchCriteriaId": "B73D4C3C-A511-4E14-B19F-91F561ACB1B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.50.2:p1:*:*:*:*:*:*", "matchCriteriaId": "0C47D72C-9B6B-4E52-AF0E-56AD58E4A930"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60:*:*:*:*:*:*:*", "matchCriteriaId": "039C3790-5AA2-4895-AEAE-CC84A71DB907"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.0:*:*:*:*:*:*:*", "matchCriteriaId": "B4592238-D1F2-43D6-9BAB-2F63ECF9C965"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.1:*:*:*:*:*:*:*", "matchCriteriaId": "0BA78068-80E9-4E49-9056-88EAB7E3682C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.60.3:*:*:*:*:*:*:*", "matchCriteriaId": "092F366C-E8B0-4BE5-B106-0B7A73B08D34"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.70.1:*:*:*:*:*:*:*", "matchCriteriaId": "E7992E92-B159-4810-B895-01A9B944058A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:e-series_santricity_os_controller:11.70.2:*:*:*:*:*:*:*", "matchCriteriaId": "5BDD7AAB-2BF3-4E8C-BEE2-5217E2926C11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:fas\\/aff_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "66EEA3CA-8CC7-4F0B-8204-6132D4114873"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_baseboard_management_controller:h610s:*:*:*:*:*:*:*", "matchCriteriaId": "DE7C6010-F736-4BDA-9E3B-C4370BBFA149"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire\\,_enterprise_sds_\\&_hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "DAA3919C-B2B1-4CB5-BA76-7A079AAFFC52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_\\&_hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "D6D700C5-F67F-4FFB-BE69-D524592A3D2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:steelstore_cloud_integrated_storage:-:*:*:*:*:*:*:*", "matchCriteriaId": "E94F7F59-1785-493F-91A7-5F5EA5E87E4D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:broadcom:brocade_fabric_operating_system_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "B2748912-FC54-47F6-8C0C-B96784765B8E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:solidfire_baseboard_management_controller_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "FB9B8171-F6CA-427D-81E0-6536D3BBFA8D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:solidfire_baseboard_management_controller:-:*:*:*:*:*:*:*", "matchCriteriaId": "090AA6F4-4404-4E26-82AB-C3A22636F276"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_compute_node_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "F921BC85-568E-4B69-A3CD-CF75C76672F1"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/bbe692e349e2a1edf3fe0a29a0e05899c9c94d51", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4300-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4301-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/bbe692e349e2a1edf3fe0a29a0e05899c9c94d51"}}