{"buggy_code": ["/*\n * translate.c - translate between different pixel formats\n */\n\n/*\n *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.\n *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  \n *  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#include <rfb/rfb.h>\n#include <rfb/rfbregion.h>\n\nstatic void PrintPixelFormat(rfbPixelFormat *pf);\nstatic rfbBool rfbSetClientColourMapBGR233(rfbClientPtr cl);\n\nrfbBool rfbEconomicTranslate = FALSE;\n\n/*\n * Some standard pixel formats.\n */\n\nstatic const rfbPixelFormat BGR233Format = {\n    8, 8, 0, 1, 7, 7, 3, 0, 3, 6, 0, 0\n};\n\n\n/*\n * Macro to compare pixel formats.\n */\n\n#define PF_EQ(x,y)                                                      \\\n        ((x.bitsPerPixel == y.bitsPerPixel) &&                          \\\n         (x.depth == y.depth) &&                                        \\\n         ((x.bigEndian == y.bigEndian) || (x.bitsPerPixel == 8)) &&     \\\n         (x.trueColour == y.trueColour) &&                              \\\n         (!x.trueColour || ((x.redMax == y.redMax) &&                   \\\n                            (x.greenMax == y.greenMax) &&               \\\n                            (x.blueMax == y.blueMax) &&                 \\\n                            (x.redShift == y.redShift) &&               \\\n                            (x.greenShift == y.greenShift) &&           \\\n                            (x.blueShift == y.blueShift))))\n\n#define CONCAT2(a,b) a##b\n#define CONCAT2E(a,b) CONCAT2(a,b)\n#define CONCAT3(a,b,c) a##b##c\n#define CONCAT3E(a,b,c) CONCAT3(a,b,c)\n#define CONCAT4(a,b,c,d) a##b##c##d\n#define CONCAT4E(a,b,c,d) CONCAT4(a,b,c,d)\n\n#undef OUT\n#undef IN\n\n#define OUT 8\n#include \"tableinitcmtemplate.c\"\n#include \"tableinittctemplate.c\"\n#define IN 8\n#include \"tabletranstemplate.c\"\n#undef IN\n#define IN 16\n#include \"tabletranstemplate.c\"\n#undef IN\n#define IN 32\n#include \"tabletranstemplate.c\"\n#undef IN\n#undef OUT\n\n#define OUT 16\n#include \"tableinitcmtemplate.c\"\n#include \"tableinittctemplate.c\"\n#define IN 8\n#include \"tabletranstemplate.c\"\n#undef IN\n#define IN 16\n#include \"tabletranstemplate.c\"\n#undef IN\n#define IN 32\n#include \"tabletranstemplate.c\"\n#undef IN\n#undef OUT\n\n#define OUT 32\n#include \"tableinitcmtemplate.c\"\n#include \"tableinittctemplate.c\"\n#define IN 8\n#include \"tabletranstemplate.c\"\n#undef IN\n#define IN 16\n#include \"tabletranstemplate.c\"\n#undef IN\n#define IN 32\n#include \"tabletranstemplate.c\"\n#undef IN\n#undef OUT\n\n#ifdef LIBVNCSERVER_ALLOW24BPP\n#define COUNT_OFFSETS 4\n#define BPP2OFFSET(bpp) ((bpp)/8-1)\n#include \"tableinit24.c\"\n#define BPP 8\n#include \"tabletrans24template.c\"\n#undef BPP\n#define BPP 16\n#include \"tabletrans24template.c\"\n#undef BPP\n#define BPP 24\n#include \"tabletrans24template.c\"\n#undef BPP\n#define BPP 32\n#include \"tabletrans24template.c\"\n#undef BPP\n#else\n#define COUNT_OFFSETS 3\n#define BPP2OFFSET(bpp) ((int)(bpp)/16)\n#endif\n\ntypedef void (*rfbInitCMTableFnType)(char **table, rfbPixelFormat *in,\n                                   rfbPixelFormat *out,rfbColourMap* cm);\ntypedef void (*rfbInitTableFnType)(char **table, rfbPixelFormat *in,\n                                   rfbPixelFormat *out);\n\nstatic rfbInitCMTableFnType rfbInitColourMapSingleTableFns[COUNT_OFFSETS] = {\n    rfbInitColourMapSingleTable8,\n    rfbInitColourMapSingleTable16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n    rfbInitColourMapSingleTable24,\n#endif\n    rfbInitColourMapSingleTable32\n};\n\nstatic rfbInitTableFnType rfbInitTrueColourSingleTableFns[COUNT_OFFSETS] = {\n    rfbInitTrueColourSingleTable8,\n    rfbInitTrueColourSingleTable16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n    rfbInitTrueColourSingleTable24,\n#endif\n    rfbInitTrueColourSingleTable32\n};\n\nstatic rfbInitTableFnType rfbInitTrueColourRGBTablesFns[COUNT_OFFSETS] = {\n    rfbInitTrueColourRGBTables8,\n    rfbInitTrueColourRGBTables16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n    rfbInitTrueColourRGBTables24,\n#endif\n    rfbInitTrueColourRGBTables32\n};\n\nstatic rfbTranslateFnType rfbTranslateWithSingleTableFns[COUNT_OFFSETS][COUNT_OFFSETS] = {\n    { rfbTranslateWithSingleTable8to8,\n      rfbTranslateWithSingleTable8to16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n      rfbTranslateWithSingleTable8to24,\n#endif\n      rfbTranslateWithSingleTable8to32 },\n    { rfbTranslateWithSingleTable16to8,\n      rfbTranslateWithSingleTable16to16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n      rfbTranslateWithSingleTable16to24,\n#endif\n      rfbTranslateWithSingleTable16to32 },\n#ifdef LIBVNCSERVER_ALLOW24BPP\n    { rfbTranslateWithSingleTable24to8,\n      rfbTranslateWithSingleTable24to16,\n      rfbTranslateWithSingleTable24to24,\n      rfbTranslateWithSingleTable24to32 },\n#endif\n    { rfbTranslateWithSingleTable32to8,\n      rfbTranslateWithSingleTable32to16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n      rfbTranslateWithSingleTable32to24,\n#endif\n      rfbTranslateWithSingleTable32to32 }\n};\n\nstatic rfbTranslateFnType rfbTranslateWithRGBTablesFns[COUNT_OFFSETS][COUNT_OFFSETS] = {\n    { rfbTranslateWithRGBTables8to8,\n      rfbTranslateWithRGBTables8to16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n      rfbTranslateWithRGBTables8to24,\n#endif\n      rfbTranslateWithRGBTables8to32 },\n    { rfbTranslateWithRGBTables16to8,\n      rfbTranslateWithRGBTables16to16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n      rfbTranslateWithRGBTables16to24,\n#endif\n      rfbTranslateWithRGBTables16to32 },\n#ifdef LIBVNCSERVER_ALLOW24BPP\n    { rfbTranslateWithRGBTables24to8,\n      rfbTranslateWithRGBTables24to16,\n      rfbTranslateWithRGBTables24to24,\n      rfbTranslateWithRGBTables24to32 },\n#endif\n    { rfbTranslateWithRGBTables32to8,\n      rfbTranslateWithRGBTables32to16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n      rfbTranslateWithRGBTables32to24,\n#endif\n      rfbTranslateWithRGBTables32to32 }\n};\n\n\n\n/*\n * rfbTranslateNone is used when no translation is required.\n */\n\nvoid\nrfbTranslateNone(char *table, rfbPixelFormat *in, rfbPixelFormat *out,\n                 char *iptr, char *optr, int bytesBetweenInputLines,\n                 int width, int height)\n{\n    int bytesPerOutputLine = width * (out->bitsPerPixel / 8);\n\n    while (height > 0) {\n        memcpy(optr, iptr, bytesPerOutputLine);\n        iptr += bytesBetweenInputLines;\n        optr += bytesPerOutputLine;\n        height--;\n    }\n}\n\n\n/*\n * rfbSetTranslateFunction sets the translation function.\n */\n\nrfbBool\nrfbSetTranslateFunction(rfbClientPtr cl)\n{\n    rfbLog(\"Pixel format for client %s:\\n\",cl->host);\n    PrintPixelFormat(&cl->format);\n\n    /*\n     * Check that bits per pixel values are valid\n     */\n\n    if ((cl->screen->serverFormat.bitsPerPixel != 8) &&\n        (cl->screen->serverFormat.bitsPerPixel != 16) &&\n#ifdef LIBVNCSERVER_ALLOW24BPP\n\t(cl->screen->serverFormat.bitsPerPixel != 24) &&\n#endif\n        (cl->screen->serverFormat.bitsPerPixel != 32))\n    {\n        rfbErr(\"%s: server bits per pixel not 8, 16 or 32 (is %d)\\n\",\n\t       \"rfbSetTranslateFunction\", \n\t       cl->screen->serverFormat.bitsPerPixel);\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n\n    if ((cl->format.bitsPerPixel != 8) &&\n        (cl->format.bitsPerPixel != 16) &&\n#ifdef LIBVNCSERVER_ALLOW24BPP\n\t(cl->format.bitsPerPixel != 24) &&\n#endif\n        (cl->format.bitsPerPixel != 32))\n    {\n        rfbErr(\"%s: client bits per pixel not 8, 16 or 32\\n\",\n                \"rfbSetTranslateFunction\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n\n    if (!cl->format.trueColour && (cl->format.bitsPerPixel != 8)) {\n        rfbErr(\"rfbSetTranslateFunction: client has colour map \"\n                \"but %d-bit - can only cope with 8-bit colour maps\\n\",\n                cl->format.bitsPerPixel);\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n\n    /*\n     * bpp is valid, now work out how to translate\n     */\n\n    if (!cl->format.trueColour) {\n        /*\n         * truecolour -> colour map\n         *\n         * Set client's colour map to BGR233, then effectively it's\n         * truecolour as well\n         */\n\n        if (!rfbSetClientColourMapBGR233(cl))\n            return FALSE;\n\n        cl->format = BGR233Format;\n    }\n\n    /* truecolour -> truecolour */\n\n    if (PF_EQ(cl->format,cl->screen->serverFormat)) {\n\n        /* client & server the same */\n\n        rfbLog(\"no translation needed\\n\");\n        cl->translateFn = rfbTranslateNone;\n        return TRUE;\n    }\n\n    if ((cl->screen->serverFormat.bitsPerPixel < 16) ||\n        ((!cl->screen->serverFormat.trueColour || !rfbEconomicTranslate) &&\n\t   (cl->screen->serverFormat.bitsPerPixel == 16))) {\n\n        /* we can use a single lookup table for <= 16 bpp */\n\n        cl->translateFn = rfbTranslateWithSingleTableFns\n                              [BPP2OFFSET(cl->screen->serverFormat.bitsPerPixel)]\n                                  [BPP2OFFSET(cl->format.bitsPerPixel)];\n\n\tif(cl->screen->serverFormat.trueColour)\n\t  (*rfbInitTrueColourSingleTableFns\n\t   [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,\n\t\t\t\t\t\t   &(cl->screen->serverFormat), &cl->format);\n\telse\n\t  (*rfbInitColourMapSingleTableFns\n\t   [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,\n\t\t\t\t\t\t   &(cl->screen->serverFormat), &cl->format,&cl->screen->colourMap);\n\n    } else {\n\n        /* otherwise we use three separate tables for red, green and blue */\n\n        cl->translateFn = rfbTranslateWithRGBTablesFns\n                              [BPP2OFFSET(cl->screen->serverFormat.bitsPerPixel)]\n                                  [BPP2OFFSET(cl->format.bitsPerPixel)];\n\n        (*rfbInitTrueColourRGBTablesFns\n            [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,\n                                             &(cl->screen->serverFormat), &cl->format);\n    }\n\n    return TRUE;\n}\n\n\n\n/*\n * rfbSetClientColourMapBGR233 sets the client's colour map so that it's\n * just like an 8-bit BGR233 true colour client.\n */\n\nstatic rfbBool\nrfbSetClientColourMapBGR233(rfbClientPtr cl)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n    int i, len;\n    int r, g, b;\n\n    if (cl->format.bitsPerPixel != 8 ) {\n        rfbErr(\"%s: client not 8 bits per pixel\\n\",\n                \"rfbSetClientColourMapBGR233\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    \n    scme->type = rfbSetColourMapEntries;\n\n    scme->firstColour = Swap16IfLE(0);\n    scme->nColours = Swap16IfLE(256);\n\n    len = sz_rfbSetColourMapEntriesMsg;\n\n    i = 0;\n\n    for (b = 0; b < 4; b++) {\n        for (g = 0; g < 8; g++) {\n            for (r = 0; r < 8; r++) {\n                rgb[i++] = Swap16IfLE(r * 65535 / 7);\n                rgb[i++] = Swap16IfLE(g * 65535 / 7);\n                rgb[i++] = Swap16IfLE(b * 65535 / 3);\n            }\n        }\n    }\n\n    len += 256 * 3 * 2;\n\n    if (rfbWriteExact(cl, buf, len) < 0) {\n        rfbLogPerror(\"rfbSetClientColourMapBGR233: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    return TRUE;\n}\n\n/* this function is not called very often, so it needn't be\n   efficient. */\n\n/*\n * rfbSetClientColourMap is called to set the client's colour map.  If the\n * client is a true colour client, we simply update our own translation table\n * and mark the whole screen as having been modified.\n */\n\nrfbBool\nrfbSetClientColourMap(rfbClientPtr cl, int firstColour, int nColours)\n{\n    if (cl->screen->serverFormat.trueColour || !cl->readyForSetColourMapEntries) {\n\treturn TRUE;\n    }\n\n    if (nColours == 0) {\n\tnColours = cl->screen->colourMap.count;\n    }\n\n    if (cl->format.trueColour) {\n\tLOCK(cl->updateMutex);\n\t(*rfbInitColourMapSingleTableFns\n\t    [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,\n\t\t\t\t\t     &cl->screen->serverFormat, &cl->format,&cl->screen->colourMap);\n\n\tsraRgnDestroy(cl->modifiedRegion);\n\tcl->modifiedRegion =\n\t  sraRgnCreateRect(0,0,cl->screen->width,cl->screen->height);\n\tUNLOCK(cl->updateMutex);\n\n\treturn TRUE;\n    }\n\n    return rfbSendSetColourMapEntries(cl, firstColour, nColours);\n}\n\n\n/*\n * rfbSetClientColourMaps sets the colour map for each RFB client.\n */\n\nvoid\nrfbSetClientColourMaps(rfbScreenInfoPtr rfbScreen, int firstColour, int nColours)\n{\n    rfbClientIteratorPtr i;\n    rfbClientPtr cl;\n\n    i = rfbGetClientIterator(rfbScreen);\n    while((cl = rfbClientIteratorNext(i)))\n      rfbSetClientColourMap(cl, firstColour, nColours);\n    rfbReleaseClientIterator(i);\n}\n\nstatic void\nPrintPixelFormat(rfbPixelFormat *pf)\n{\n    if (pf->bitsPerPixel == 1) {\n        rfbLog(\"  1 bpp, %s sig bit in each byte is leftmost on the screen.\\n\",\n               (pf->bigEndian ? \"most\" : \"least\"));\n    } else {\n        rfbLog(\"  %d bpp, depth %d%s\\n\",pf->bitsPerPixel,pf->depth,\n               ((pf->bitsPerPixel == 8) ? \"\"\n                : (pf->bigEndian ? \", big endian\" : \", little endian\")));\n        if (pf->trueColour) {\n            rfbLog(\"  true colour: max r %d g %d b %d, shift r %d g %d b %d\\n\",\n                   pf->redMax, pf->greenMax, pf->blueMax,\n                   pf->redShift, pf->greenShift, pf->blueShift);\n        } else {\n            rfbLog(\"  uses a colour map (not true colour).\\n\");\n        }\n    }\n}\n"], "fixing_code": ["/*\n * translate.c - translate between different pixel formats\n */\n\n/*\n *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.\n *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  \n *  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#include <rfb/rfb.h>\n#include <rfb/rfbregion.h>\n\nstatic void PrintPixelFormat(rfbPixelFormat *pf);\nstatic rfbBool rfbSetClientColourMapBGR233(rfbClientPtr cl);\n\nrfbBool rfbEconomicTranslate = FALSE;\n\n/*\n * Some standard pixel formats.\n */\n\nstatic const rfbPixelFormat BGR233Format = {\n    8, 8, 0, 1, 7, 7, 3, 0, 3, 6, 0, 0\n};\n\n\n/*\n * Macro to compare pixel formats.\n */\n\n#define PF_EQ(x,y)                                                      \\\n        ((x.bitsPerPixel == y.bitsPerPixel) &&                          \\\n         (x.depth == y.depth) &&                                        \\\n         ((x.bigEndian == y.bigEndian) || (x.bitsPerPixel == 8)) &&     \\\n         (x.trueColour == y.trueColour) &&                              \\\n         (!x.trueColour || ((x.redMax == y.redMax) &&                   \\\n                            (x.greenMax == y.greenMax) &&               \\\n                            (x.blueMax == y.blueMax) &&                 \\\n                            (x.redShift == y.redShift) &&               \\\n                            (x.greenShift == y.greenShift) &&           \\\n                            (x.blueShift == y.blueShift))))\n\n#define CONCAT2(a,b) a##b\n#define CONCAT2E(a,b) CONCAT2(a,b)\n#define CONCAT3(a,b,c) a##b##c\n#define CONCAT3E(a,b,c) CONCAT3(a,b,c)\n#define CONCAT4(a,b,c,d) a##b##c##d\n#define CONCAT4E(a,b,c,d) CONCAT4(a,b,c,d)\n\n#undef OUT\n#undef IN\n\n#define OUT 8\n#include \"tableinitcmtemplate.c\"\n#include \"tableinittctemplate.c\"\n#define IN 8\n#include \"tabletranstemplate.c\"\n#undef IN\n#define IN 16\n#include \"tabletranstemplate.c\"\n#undef IN\n#define IN 32\n#include \"tabletranstemplate.c\"\n#undef IN\n#undef OUT\n\n#define OUT 16\n#include \"tableinitcmtemplate.c\"\n#include \"tableinittctemplate.c\"\n#define IN 8\n#include \"tabletranstemplate.c\"\n#undef IN\n#define IN 16\n#include \"tabletranstemplate.c\"\n#undef IN\n#define IN 32\n#include \"tabletranstemplate.c\"\n#undef IN\n#undef OUT\n\n#define OUT 32\n#include \"tableinitcmtemplate.c\"\n#include \"tableinittctemplate.c\"\n#define IN 8\n#include \"tabletranstemplate.c\"\n#undef IN\n#define IN 16\n#include \"tabletranstemplate.c\"\n#undef IN\n#define IN 32\n#include \"tabletranstemplate.c\"\n#undef IN\n#undef OUT\n\n#ifdef LIBVNCSERVER_ALLOW24BPP\n#define COUNT_OFFSETS 4\n#define BPP2OFFSET(bpp) ((bpp)/8-1)\n#include \"tableinit24.c\"\n#define BPP 8\n#include \"tabletrans24template.c\"\n#undef BPP\n#define BPP 16\n#include \"tabletrans24template.c\"\n#undef BPP\n#define BPP 24\n#include \"tabletrans24template.c\"\n#undef BPP\n#define BPP 32\n#include \"tabletrans24template.c\"\n#undef BPP\n#else\n#define COUNT_OFFSETS 3\n#define BPP2OFFSET(bpp) ((int)(bpp)/16)\n#endif\n\ntypedef void (*rfbInitCMTableFnType)(char **table, rfbPixelFormat *in,\n                                   rfbPixelFormat *out,rfbColourMap* cm);\ntypedef void (*rfbInitTableFnType)(char **table, rfbPixelFormat *in,\n                                   rfbPixelFormat *out);\n\nstatic rfbInitCMTableFnType rfbInitColourMapSingleTableFns[COUNT_OFFSETS] = {\n    rfbInitColourMapSingleTable8,\n    rfbInitColourMapSingleTable16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n    rfbInitColourMapSingleTable24,\n#endif\n    rfbInitColourMapSingleTable32\n};\n\nstatic rfbInitTableFnType rfbInitTrueColourSingleTableFns[COUNT_OFFSETS] = {\n    rfbInitTrueColourSingleTable8,\n    rfbInitTrueColourSingleTable16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n    rfbInitTrueColourSingleTable24,\n#endif\n    rfbInitTrueColourSingleTable32\n};\n\nstatic rfbInitTableFnType rfbInitTrueColourRGBTablesFns[COUNT_OFFSETS] = {\n    rfbInitTrueColourRGBTables8,\n    rfbInitTrueColourRGBTables16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n    rfbInitTrueColourRGBTables24,\n#endif\n    rfbInitTrueColourRGBTables32\n};\n\nstatic rfbTranslateFnType rfbTranslateWithSingleTableFns[COUNT_OFFSETS][COUNT_OFFSETS] = {\n    { rfbTranslateWithSingleTable8to8,\n      rfbTranslateWithSingleTable8to16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n      rfbTranslateWithSingleTable8to24,\n#endif\n      rfbTranslateWithSingleTable8to32 },\n    { rfbTranslateWithSingleTable16to8,\n      rfbTranslateWithSingleTable16to16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n      rfbTranslateWithSingleTable16to24,\n#endif\n      rfbTranslateWithSingleTable16to32 },\n#ifdef LIBVNCSERVER_ALLOW24BPP\n    { rfbTranslateWithSingleTable24to8,\n      rfbTranslateWithSingleTable24to16,\n      rfbTranslateWithSingleTable24to24,\n      rfbTranslateWithSingleTable24to32 },\n#endif\n    { rfbTranslateWithSingleTable32to8,\n      rfbTranslateWithSingleTable32to16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n      rfbTranslateWithSingleTable32to24,\n#endif\n      rfbTranslateWithSingleTable32to32 }\n};\n\nstatic rfbTranslateFnType rfbTranslateWithRGBTablesFns[COUNT_OFFSETS][COUNT_OFFSETS] = {\n    { rfbTranslateWithRGBTables8to8,\n      rfbTranslateWithRGBTables8to16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n      rfbTranslateWithRGBTables8to24,\n#endif\n      rfbTranslateWithRGBTables8to32 },\n    { rfbTranslateWithRGBTables16to8,\n      rfbTranslateWithRGBTables16to16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n      rfbTranslateWithRGBTables16to24,\n#endif\n      rfbTranslateWithRGBTables16to32 },\n#ifdef LIBVNCSERVER_ALLOW24BPP\n    { rfbTranslateWithRGBTables24to8,\n      rfbTranslateWithRGBTables24to16,\n      rfbTranslateWithRGBTables24to24,\n      rfbTranslateWithRGBTables24to32 },\n#endif\n    { rfbTranslateWithRGBTables32to8,\n      rfbTranslateWithRGBTables32to16,\n#ifdef LIBVNCSERVER_ALLOW24BPP\n      rfbTranslateWithRGBTables32to24,\n#endif\n      rfbTranslateWithRGBTables32to32 }\n};\n\n\n\n/*\n * rfbTranslateNone is used when no translation is required.\n */\n\nvoid\nrfbTranslateNone(char *table, rfbPixelFormat *in, rfbPixelFormat *out,\n                 char *iptr, char *optr, int bytesBetweenInputLines,\n                 int width, int height)\n{\n    int bytesPerOutputLine = width * (out->bitsPerPixel / 8);\n\n    while (height > 0) {\n        memcpy(optr, iptr, bytesPerOutputLine);\n        iptr += bytesBetweenInputLines;\n        optr += bytesPerOutputLine;\n        height--;\n    }\n}\n\n\n/*\n * rfbSetTranslateFunction sets the translation function.\n */\n\nrfbBool\nrfbSetTranslateFunction(rfbClientPtr cl)\n{\n    rfbLog(\"Pixel format for client %s:\\n\",cl->host);\n    PrintPixelFormat(&cl->format);\n\n    /*\n     * Check that bits per pixel values are valid\n     */\n\n    if ((cl->screen->serverFormat.bitsPerPixel != 8) &&\n        (cl->screen->serverFormat.bitsPerPixel != 16) &&\n#ifdef LIBVNCSERVER_ALLOW24BPP\n\t(cl->screen->serverFormat.bitsPerPixel != 24) &&\n#endif\n        (cl->screen->serverFormat.bitsPerPixel != 32))\n    {\n        rfbErr(\"%s: server bits per pixel not 8, 16 or 32 (is %d)\\n\",\n\t       \"rfbSetTranslateFunction\", \n\t       cl->screen->serverFormat.bitsPerPixel);\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n\n    if ((cl->format.bitsPerPixel != 8) &&\n        (cl->format.bitsPerPixel != 16) &&\n#ifdef LIBVNCSERVER_ALLOW24BPP\n\t(cl->format.bitsPerPixel != 24) &&\n#endif\n        (cl->format.bitsPerPixel != 32))\n    {\n        rfbErr(\"%s: client bits per pixel not 8, 16 or 32\\n\",\n                \"rfbSetTranslateFunction\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n\n    if (!cl->format.trueColour && (cl->format.bitsPerPixel != 8)) {\n        rfbErr(\"rfbSetTranslateFunction: client has colour map \"\n                \"but %d-bit - can only cope with 8-bit colour maps\\n\",\n                cl->format.bitsPerPixel);\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n\n    /*\n     * bpp is valid, now work out how to translate\n     */\n\n    if (!cl->format.trueColour) {\n        /*\n         * truecolour -> colour map\n         *\n         * Set client's colour map to BGR233, then effectively it's\n         * truecolour as well\n         */\n\n        if (!rfbSetClientColourMapBGR233(cl))\n            return FALSE;\n\n        cl->format = BGR233Format;\n    }\n\n    /* truecolour -> truecolour */\n\n    if (PF_EQ(cl->format,cl->screen->serverFormat)) {\n\n        /* client & server the same */\n\n        rfbLog(\"no translation needed\\n\");\n        cl->translateFn = rfbTranslateNone;\n        return TRUE;\n    }\n\n    if ((cl->screen->serverFormat.bitsPerPixel < 16) ||\n        ((!cl->screen->serverFormat.trueColour || !rfbEconomicTranslate) &&\n\t   (cl->screen->serverFormat.bitsPerPixel == 16))) {\n\n        /* we can use a single lookup table for <= 16 bpp */\n\n        cl->translateFn = rfbTranslateWithSingleTableFns\n                              [BPP2OFFSET(cl->screen->serverFormat.bitsPerPixel)]\n                                  [BPP2OFFSET(cl->format.bitsPerPixel)];\n\n\tif(cl->screen->serverFormat.trueColour)\n\t  (*rfbInitTrueColourSingleTableFns\n\t   [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,\n\t\t\t\t\t\t   &(cl->screen->serverFormat), &cl->format);\n\telse\n\t  (*rfbInitColourMapSingleTableFns\n\t   [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,\n\t\t\t\t\t\t   &(cl->screen->serverFormat), &cl->format,&cl->screen->colourMap);\n\n    } else {\n\n        /* otherwise we use three separate tables for red, green and blue */\n\n        cl->translateFn = rfbTranslateWithRGBTablesFns\n                              [BPP2OFFSET(cl->screen->serverFormat.bitsPerPixel)]\n                                  [BPP2OFFSET(cl->format.bitsPerPixel)];\n\n        (*rfbInitTrueColourRGBTablesFns\n            [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,\n                                             &(cl->screen->serverFormat), &cl->format);\n    }\n\n    return TRUE;\n}\n\n\n\n/*\n * rfbSetClientColourMapBGR233 sets the client's colour map so that it's\n * just like an 8-bit BGR233 true colour client.\n */\n\nstatic rfbBool\nrfbSetClientColourMapBGR233(rfbClientPtr cl)\n{\n    union {\n        char bytes[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n        rfbSetColourMapEntriesMsg msg;\n    } buf;\n    rfbSetColourMapEntriesMsg *scme = &buf.msg;\n    uint16_t *rgb = (uint16_t *)(&buf.bytes[sz_rfbSetColourMapEntriesMsg]);\n    int i, len;\n    int r, g, b;\n\n    if (cl->format.bitsPerPixel != 8 ) {\n        rfbErr(\"%s: client not 8 bits per pixel\\n\",\n                \"rfbSetClientColourMapBGR233\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    \n    scme->type = rfbSetColourMapEntries;\n\n    scme->firstColour = Swap16IfLE(0);\n    scme->nColours = Swap16IfLE(256);\n\n    len = sz_rfbSetColourMapEntriesMsg;\n\n    i = 0;\n\n    for (b = 0; b < 4; b++) {\n        for (g = 0; g < 8; g++) {\n            for (r = 0; r < 8; r++) {\n                rgb[i++] = Swap16IfLE(r * 65535 / 7);\n                rgb[i++] = Swap16IfLE(g * 65535 / 7);\n                rgb[i++] = Swap16IfLE(b * 65535 / 3);\n            }\n        }\n    }\n\n    len += 256 * 3 * 2;\n\n    if (rfbWriteExact(cl, buf.bytes, len) < 0) {\n        rfbLogPerror(\"rfbSetClientColourMapBGR233: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    return TRUE;\n}\n\n/* this function is not called very often, so it needn't be\n   efficient. */\n\n/*\n * rfbSetClientColourMap is called to set the client's colour map.  If the\n * client is a true colour client, we simply update our own translation table\n * and mark the whole screen as having been modified.\n */\n\nrfbBool\nrfbSetClientColourMap(rfbClientPtr cl, int firstColour, int nColours)\n{\n    if (cl->screen->serverFormat.trueColour || !cl->readyForSetColourMapEntries) {\n\treturn TRUE;\n    }\n\n    if (nColours == 0) {\n\tnColours = cl->screen->colourMap.count;\n    }\n\n    if (cl->format.trueColour) {\n\tLOCK(cl->updateMutex);\n\t(*rfbInitColourMapSingleTableFns\n\t    [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,\n\t\t\t\t\t     &cl->screen->serverFormat, &cl->format,&cl->screen->colourMap);\n\n\tsraRgnDestroy(cl->modifiedRegion);\n\tcl->modifiedRegion =\n\t  sraRgnCreateRect(0,0,cl->screen->width,cl->screen->height);\n\tUNLOCK(cl->updateMutex);\n\n\treturn TRUE;\n    }\n\n    return rfbSendSetColourMapEntries(cl, firstColour, nColours);\n}\n\n\n/*\n * rfbSetClientColourMaps sets the colour map for each RFB client.\n */\n\nvoid\nrfbSetClientColourMaps(rfbScreenInfoPtr rfbScreen, int firstColour, int nColours)\n{\n    rfbClientIteratorPtr i;\n    rfbClientPtr cl;\n\n    i = rfbGetClientIterator(rfbScreen);\n    while((cl = rfbClientIteratorNext(i)))\n      rfbSetClientColourMap(cl, firstColour, nColours);\n    rfbReleaseClientIterator(i);\n}\n\nstatic void\nPrintPixelFormat(rfbPixelFormat *pf)\n{\n    if (pf->bitsPerPixel == 1) {\n        rfbLog(\"  1 bpp, %s sig bit in each byte is leftmost on the screen.\\n\",\n               (pf->bigEndian ? \"most\" : \"least\"));\n    } else {\n        rfbLog(\"  %d bpp, depth %d%s\\n\",pf->bitsPerPixel,pf->depth,\n               ((pf->bitsPerPixel == 8) ? \"\"\n                : (pf->bigEndian ? \", big endian\" : \", little endian\")));\n        if (pf->trueColour) {\n            rfbLog(\"  true colour: max r %d g %d b %d, shift r %d g %d b %d\\n\",\n                   pf->redMax, pf->greenMax, pf->blueMax,\n                   pf->redShift, pf->greenShift, pf->blueShift);\n        } else {\n            rfbLog(\"  uses a colour map (not true colour).\\n\");\n        }\n    }\n}\n"], "filenames": ["libvncserver/translate.c"], "buggy_code_start_loc": [363], "buggy_code_end_loc": [398], "fixing_code_start_loc": [363], "fixing_code_end_loc": [401], "type": "NVD-CWE-Other", "message": "** DISPUTED ** An issue was discovered in LibVNCServer before 0.9.13. Byte-aligned data is accessed through uint16_t pointers in libvncserver/translate.c. NOTE: Third parties do not consider this to be a vulnerability as there is no known path of exploitation or cross of a trust boundary.", "other": {"cve": {"id": "CVE-2020-14400", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-17T16:15:11.993", "lastModified": "2023-02-27T18:14:13.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** An issue was discovered in LibVNCServer before 0.9.13. Byte-aligned data is accessed through uint16_t pointers in libvncserver/translate.c. NOTE: Third parties do not consider this to be a vulnerability as there is no known path of exploitation or cross of a trust boundary."}, {"lang": "es", "value": "** EN DISPUTA ** Se detect\u00f3 un problema en LibVNCServer versiones anteriores a 0.9.13. Los datos Byte-aligned son accedidos por medio de punteros uint16_t en la biblioteca libvncserver/translate.c. NOTA: Los terceros no consideran que se trate de una vulnerabilidad, ya que no se conoce el camino de la explotaci\u00f3n o el cruce de un l\u00edmite de confianza"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvncserver_project:libvncserver:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.13", "matchCriteriaId": "4F3C4EF0-4663-4832-8662-D1AB70E562E7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00033.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00055.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00066.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1860361", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/commit/53073c8d7e232151ea2ecd8a1243124121e10e2d", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/LibVNC/libvncserver/compare/LibVNCServer-0.9.12...LibVNCServer-0.9.13", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00035.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00045.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4434-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/libvncserver/commit/53073c8d7e232151ea2ecd8a1243124121e10e2d"}}