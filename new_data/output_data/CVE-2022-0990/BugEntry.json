{"buggy_code": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2012-2019  OzzieIsaacs\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\ntry:\n    from gevent import monkey\n    monkey.patch_all()\nexcept ImportError:\n    pass\n\nimport sys\nimport os\n\n\n# Insert local directories into path\nsys.path.append(os.path.dirname(os.path.abspath(__file__)))\nsys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), 'vendor'))\n\n\nfrom cps import create_app\nfrom cps import web_server\nfrom cps.opds import opds\nfrom cps.web import web\nfrom cps.jinjia import jinjia\nfrom cps.about import about\nfrom cps.shelf import shelf\nfrom cps.admin import admi\nfrom cps.gdrive import gdrive\nfrom cps.editbooks import editbook\nfrom cps.remotelogin import remotelogin\nfrom cps.search_metadata import meta\nfrom cps.error_handler import init_errorhandler\n\ntry:\n    from cps.kobo import kobo, get_kobo_activated\n    from cps.kobo_auth import kobo_auth\n    kobo_available = get_kobo_activated()\nexcept (ImportError, AttributeError):   # Catch also error for not installed flask-WTF (missing csrf decorator)\n    kobo_available = False\n\ntry:\n    from cps.oauth_bb import oauth\n    oauth_available = True\nexcept ImportError:\n    oauth_available = False\n\n\ndef main():\n    app = create_app()\n\n    init_errorhandler()\n\n    app.register_blueprint(web)\n    app.register_blueprint(opds)\n    app.register_blueprint(jinjia)\n    app.register_blueprint(about)\n    app.register_blueprint(shelf)\n    app.register_blueprint(admi)\n    app.register_blueprint(remotelogin)\n    app.register_blueprint(meta)\n    app.register_blueprint(gdrive)\n    app.register_blueprint(editbook)\n    if kobo_available:\n        app.register_blueprint(kobo)\n        app.register_blueprint(kobo_auth)\n    if oauth_available:\n        app.register_blueprint(oauth)\n    success = web_server.start()\n    sys.exit(0 if success else 1)\n\n\nif __name__ == '__main__':\n    main()\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n__package__ = \"cps\"\n\nimport sys\nimport os\nimport mimetypes\n\nfrom babel import Locale as LC\nfrom babel import negotiate_locale\nfrom babel.core import UnknownLocaleError\nfrom flask import Flask, request, g\nfrom .MyLoginManager import MyLoginManager\nfrom flask_babel import Babel\nfrom flask_principal import Principal\n\nfrom . import config_sql, logger, cache_buster, cli, ub, db\nfrom .reverseproxy import ReverseProxied\nfrom .server import WebServer\nfrom .dep_check import dependency_check\n\ntry:\n    import lxml\n    lxml_present = True\nexcept ImportError:\n    lxml_present = False\n\ntry:\n    from flask_wtf.csrf import CSRFProtect\n    wtf_present = True\nexcept ImportError:\n    wtf_present = False\n\nmimetypes.init()\nmimetypes.add_type('application/xhtml+xml', '.xhtml')\nmimetypes.add_type('application/epub+zip', '.epub')\nmimetypes.add_type('application/fb2+zip', '.fb2')\nmimetypes.add_type('application/x-mobipocket-ebook', '.mobi')\nmimetypes.add_type('application/x-mobipocket-ebook', '.prc')\nmimetypes.add_type('application/vnd.amazon.ebook', '.azw')\nmimetypes.add_type('application/x-mobi8-ebook', '.azw3')\nmimetypes.add_type('application/x-cbr', '.cbr')\nmimetypes.add_type('application/x-cbz', '.cbz')\nmimetypes.add_type('application/x-cbt', '.cbt')\nmimetypes.add_type('image/vnd.djvu', '.djvu')\nmimetypes.add_type('application/mpeg', '.mpeg')\nmimetypes.add_type('application/mpeg', '.mp3')\nmimetypes.add_type('application/mp4', '.m4a')\nmimetypes.add_type('application/mp4', '.m4b')\nmimetypes.add_type('application/ogg', '.ogg')\nmimetypes.add_type('application/ogg', '.oga')\nmimetypes.add_type('text/css', '.css')\nmimetypes.add_type('text/javascript; charset=UTF-8', '.js')\n\napp = Flask(__name__)\napp.config.update(\n    SESSION_COOKIE_HTTPONLY=True,\n    SESSION_COOKIE_SAMESITE='Lax',\n    REMEMBER_COOKIE_SAMESITE='Lax',  # will be available in flask-login 0.5.1 earliest\n    WTF_CSRF_SSL_STRICT=False\n)\n\n\nlm = MyLoginManager()\nlm.login_view = 'web.login'\nlm.anonymous_user = ub.Anonymous\nlm.session_protection = 'strong'\n\nif wtf_present:\n    csrf = CSRFProtect()\n    csrf.init_app(app)\nelse:\n    csrf = None\n\nub.init_db(cli.settingspath)\n# pylint: disable=no-member\nconfig = config_sql.load_configuration(ub.session)\n\nweb_server = WebServer()\n\nbabel = Babel()\n_BABEL_TRANSLATIONS = set()\n\nlog = logger.create()\n\n\nfrom . import services\n\ndb.CalibreDB.update_config(config)\ndb.CalibreDB.setup_db(config.config_calibre_dir, cli.settingspath)\n\n\ncalibre_db = db.CalibreDB()\n\ndef create_app():\n    if sys.version_info < (3, 0):\n        log.info(\n            '*** Python2 is EOL since end of 2019, this version of Calibre-Web is no longer supporting Python2, please update your installation to Python3 ***')\n        print(\n            '*** Python2 is EOL since end of 2019, this version of Calibre-Web is no longer supporting Python2, please update your installation to Python3 ***')\n        web_server.stop(True)\n        sys.exit(5)\n    if not lxml_present:\n        log.info('*** \"lxml\" is needed for calibre-web to run. Please install it using pip: \"pip install lxml\" ***')\n        print('*** \"lxml\" is needed for calibre-web to run. Please install it using pip: \"pip install lxml\" ***')\n        web_server.stop(True)\n        sys.exit(6)\n    if not wtf_present:\n        log.info('*** \"flask-WTF\" is needed for calibre-web to run. Please install it using pip: \"pip install flask-WTF\" ***')\n        print('*** \"flask-WTF\" is needed for calibre-web to run. Please install it using pip: \"pip install flask-WTF\" ***')\n        web_server.stop(True)\n        sys.exit(7)\n    for res in dependency_check() + dependency_check(True):\n        log.info('*** \"{}\" version does not fit the requirements. Should: {}, Found: {}, please consider installing required version ***'\n            .format(res['name'],\n                 res['target'],\n                 res['found']))\n    app.wsgi_app = ReverseProxied(app.wsgi_app)\n\n    if os.environ.get('FLASK_DEBUG'):\n        cache_buster.init_cache_busting(app)\n    log.info('Starting Calibre Web...')\n\n    Principal(app)\n    lm.init_app(app)\n    app.secret_key = os.getenv('SECRET_KEY', config_sql.get_flask_session_key(ub.session))\n\n    web_server.init_app(app, config)\n\n    babel.init_app(app)\n    _BABEL_TRANSLATIONS.update(str(item) for item in babel.list_translations())\n    _BABEL_TRANSLATIONS.add('en')\n\n    if services.ldap:\n        services.ldap.init_app(app, config)\n    if services.goodreads_support:\n        services.goodreads_support.connect(config.config_goodreads_api_key,\n                                           config.config_goodreads_api_secret,\n                                           config.config_use_goodreads)\n    config.store_calibre_uuid(calibre_db, db.Library_Id)\n    return app\n\n@babel.localeselector\ndef get_locale():\n    # if a user is logged in, use the locale from the user settings\n    user = getattr(g, 'user', None)\n    if user is not None and hasattr(user, \"locale\"):\n        if user.name != 'Guest':   # if the account is the guest account bypass the config lang settings\n            return user.locale\n\n    preferred = list()\n    if request.accept_languages:\n        for x in request.accept_languages.values():\n            try:\n                preferred.append(str(LC.parse(x.replace('-', '_'))))\n            except (UnknownLocaleError, ValueError) as e:\n                log.debug('Could not parse locale \"%s\": %s', x, e)\n\n    return negotiate_locale(preferred or ['en'], _BABEL_TRANSLATIONS)\n\n\n@babel.timezoneselector\ndef get_timezone():\n    user = getattr(g, 'user', None)\n    return user.timezone if user else None\n\n\nfrom .updater import Updater\nupdater_thread = Updater()\n\n# Perform dry run of updater and exit afterwards\nif cli.dry_run:\n    updater_thread.dry_run()\n    sys.exit(0)\nupdater_thread.start()\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler, GammaC0de, vuolter\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport re\nimport base64\nimport json\nimport time\nimport operator\nfrom datetime import datetime, timedelta\n\nfrom babel import Locale as LC\nfrom babel.dates import format_datetime\nfrom flask import Blueprint, flash, redirect, url_for, abort, request, make_response, send_from_directory, g, Response\nfrom flask_login import login_required, current_user, logout_user, confirm_login\nfrom flask_babel import gettext as _\nfrom flask import session as flask_session\nfrom sqlalchemy import and_\nfrom sqlalchemy.orm.attributes import flag_modified\nfrom sqlalchemy.exc import IntegrityError, OperationalError, InvalidRequestError\nfrom sqlalchemy.sql.expression import func, or_, text\n\nfrom . import constants, logger, helper, services, cli\nfrom . import db, calibre_db, ub, web_server, get_locale, config, updater_thread, babel, gdriveutils, kobo_sync_status\nfrom .helper import check_valid_domain, send_test_mail, reset_password, generate_password_hash, check_email, \\\n    valid_email, check_username\nfrom .gdriveutils import is_gdrive_ready, gdrive_support\nfrom .render_template import render_title_template, get_sidebar_config\nfrom . import debug_info, _BABEL_TRANSLATIONS\n\nfrom functools import wraps\n\nlog = logger.create()\n\nfeature_support = {\n        'ldap': bool(services.ldap),\n        'goodreads': bool(services.goodreads_support),\n        'kobo':  bool(services.kobo),\n        'updater': constants.UPDATER_AVAILABLE,\n        'gmail': bool(services.gmail)\n    }\n\ntry:\n    import rarfile  # pylint: disable=unused-import\n    feature_support['rar'] = True\nexcept (ImportError, SyntaxError):\n    feature_support['rar'] = False\n\ntry:\n    from .oauth_bb import oauth_check, oauthblueprints\n    feature_support['oauth'] = True\nexcept ImportError as err:\n    log.debug('Cannot import Flask-Dance, login with Oauth will not work: %s', err)\n    feature_support['oauth'] = False\n    oauthblueprints = []\n    oauth_check = {}\n\n\nfeature_support['gdrive'] = gdrive_support\nadmi = Blueprint('admin', __name__)\n\n\ndef admin_required(f):\n    \"\"\"\n    Checks if current_user.role == 1\n    \"\"\"\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_admin():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n\n@admi.before_app_request\ndef before_request():\n    # make remember me function work\n    if current_user.is_authenticated:\n        confirm_login()\n    if not ub.check_user_session(current_user.id, flask_session.get('_id')) and 'opds' not in request.path:\n        logout_user()\n    g.constants = constants\n    g.user = current_user\n    g.allow_registration = config.config_public_reg\n    g.allow_anonymous = config.config_anonbrowse\n    g.allow_upload = config.config_uploading\n    g.current_theme = config.config_theme\n    g.config_authors_max = config.config_authors_max\n    g.shelves_access = ub.session.query(ub.Shelf).filter(\n        or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == current_user.id)).order_by(ub.Shelf.name).all()\n    if '/static/' not in request.path and not config.db_configured and \\\n        request.endpoint not in ('admin.ajax_db_config',\n                                 'admin.simulatedbchange',\n                                 'admin.db_configuration',\n                                 'web.login',\n                                 'web.logout',\n                                 'admin.load_dialogtexts',\n                                 'admin.ajax_pathchooser'):\n        return redirect(url_for('admin.db_configuration'))\n\n\n@admi.route(\"/admin\")\n@login_required\ndef admin_forbidden():\n    abort(403)\n\n\n@admi.route(\"/shutdown\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef shutdown():\n    task = request.get_json().get('parameter', -1)\n    showtext = {}\n    if task in (0, 1):  # valid commandos received\n        # close all database connections\n        calibre_db.dispose()\n        ub.dispose()\n\n        if task == 0:\n            showtext['text'] = _(u'Server restarted, please reload page')\n        else:\n            showtext['text'] = _(u'Performing shutdown of server, please close window')\n        # stop gevent/tornado server\n        web_server.stop(task == 0)\n        return json.dumps(showtext)\n\n    if task == 2:\n        log.warning(\"reconnecting to calibre database\")\n        calibre_db.reconnect_db(config, ub.app_DB_path)\n        showtext['text'] = _(u'Reconnect successful')\n        return json.dumps(showtext)\n\n    showtext['text'] = _(u'Unknown command')\n    return json.dumps(showtext), 400\n\n\n# method is available without login and not protected by CSRF to make it easy reachable, is per default switched of\n# needed for docker applications, as changes on metadata.db from host are not visible to application\n@admi.route(\"/reconnect\", methods=['GET'])\ndef reconnect():\n    if cli.args.r:\n        calibre_db.reconnect_db(config, ub.app_DB_path)\n        return json.dumps({})\n    else:\n        log.debug(\"'/reconnect' was accessed but is not enabled\")\n        abort(404)\n\n\n@admi.route(\"/admin/view\")\n@login_required\n@admin_required\ndef admin():\n    version = updater_thread.get_current_version_info()\n    if version is False:\n        commit = _(u'Unknown')\n    else:\n        if 'datetime' in version:\n            commit = version['datetime']\n\n            tz = timedelta(seconds=time.timezone if (time.localtime().tm_isdst == 0) else time.altzone)\n            form_date = datetime.strptime(commit[:19], \"%Y-%m-%dT%H:%M:%S\")\n            if len(commit) > 19:    # check if string has timezone\n                if commit[19] == '+':\n                    form_date -= timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))\n                elif commit[19] == '-':\n                    form_date += timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))\n            commit = format_datetime(form_date - tz, format='short', locale=get_locale())\n        else:\n            commit = version['version']\n\n    allUser = ub.session.query(ub.User).all()\n    email_settings = config.get_mail_settings()\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    return render_title_template(\"admin.html\", allUser=allUser, email=email_settings, config=config, commit=commit,\n                                 feature_support=feature_support, kobo_support=kobo_support,\n                                 title=_(u\"Admin page\"), page=\"admin\")\n\n\n@admi.route(\"/admin/dbconfig\", methods=[\"GET\", \"POST\"])\n@login_required\n@admin_required\ndef db_configuration():\n    if request.method == \"POST\":\n        return _db_configuration_update_helper()\n    return _db_configuration_result()\n\n\n@admi.route(\"/admin/config\", methods=[\"GET\"])\n@login_required\n@admin_required\ndef configuration():\n    return render_title_template(\"config_edit.html\",\n                                 config=config,\n                                 provider=oauthblueprints,\n                                 feature_support=feature_support,\n                                 title=_(u\"Basic Configuration\"), page=\"config\")\n\n\n@admi.route(\"/admin/ajaxconfig\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef ajax_config():\n    return _configuration_update_helper()\n\n\n@admi.route(\"/admin/ajaxdbconfig\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef ajax_db_config():\n    return _db_configuration_update_helper()\n\n\n@admi.route(\"/admin/alive\", methods=[\"GET\"])\n@login_required\n@admin_required\ndef calibreweb_alive():\n    return \"\", 200\n\n\n@admi.route(\"/admin/viewconfig\")\n@login_required\n@admin_required\ndef view_configuration():\n    read_column = calibre_db.session.query(db.Custom_Columns)\\\n        .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all()\n    restrict_columns = calibre_db.session.query(db.Custom_Columns)\\\n        .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all()\n    languages = calibre_db.speaking_language()\n    translations = [LC('en')] + babel.list_translations()\n    return render_title_template(\"config_view_edit.html\", conf=config, readColumns=read_column,\n                                 restrictColumns=restrict_columns,\n                                 languages=languages,\n                                 translations=translations,\n                                 title=_(u\"UI Configuration\"), page=\"uiconfig\")\n\n\n@admi.route(\"/admin/usertable\")\n@login_required\n@admin_required\ndef edit_user_table():\n    visibility = current_user.view_settings.get('useredit', {})\n    languages = calibre_db.speaking_language()\n    translations = babel.list_translations() + [LC('en')]\n    allUser = ub.session.query(ub.User)\n    tags = calibre_db.session.query(db.Tags)\\\n        .join(db.books_tags_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_tags_link.tag'))\\\n        .order_by(db.Tags.name).all()\n    if config.config_restricted_column:\n        custom_values = calibre_db.session.query(db.cc_classes[config.config_restricted_column]).all()\n    else:\n        custom_values = []\n    if not config.config_anonbrowse:\n        allUser = allUser.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    return render_title_template(\"user_table.html\",\n                                 users=allUser.all(),\n                                 tags=tags,\n                                 custom_values=custom_values,\n                                 translations=translations,\n                                 languages=languages,\n                                 visiblility=visibility,\n                                 all_roles=constants.ALL_ROLES,\n                                 kobo_support=kobo_support,\n                                 sidebar_settings=constants.sidebar_settings,\n                                 title=_(u\"Edit Users\"),\n                                 page=\"usertable\")\n\n\n@admi.route(\"/ajax/listusers\")\n@login_required\n@admin_required\ndef list_users():\n    off = int(request.args.get(\"offset\") or 0)\n    limit = int(request.args.get(\"limit\") or 10)\n    search = request.args.get(\"search\")\n    sort = request.args.get(\"sort\", \"id\")\n    state = None\n    if sort == \"state\":\n        state = json.loads(request.args.get(\"state\", \"[]\"))\n    else:\n        if sort not in ub.User.__table__.columns.keys():\n            sort = \"id\"\n    order = request.args.get(\"order\", \"\").lower()\n\n    if sort != \"state\" and order:\n        order = text(sort + \" \" + order)\n    elif not state:\n        order = ub.User.id.asc()\n\n    all_user = ub.session.query(ub.User)\n    if not config.config_anonbrowse:\n        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)\n\n    total_count = filtered_count = all_user.count()\n\n    if search:\n        all_user = all_user.filter(or_(func.lower(ub.User.name).ilike(\"%\" + search + \"%\"),\n                                       func.lower(ub.User.kindle_mail).ilike(\"%\" + search + \"%\"),\n                                       func.lower(ub.User.email).ilike(\"%\" + search + \"%\")))\n    if state:\n        users = calibre_db.get_checkbox_sorted(all_user.all(), state, off, limit, request.args.get(\"order\", \"\").lower())\n    else:\n        users = all_user.order_by(order).offset(off).limit(limit).all()\n    if search:\n        filtered_count = len(users)\n\n    for user in users:\n        if user.default_language == \"all\":\n            user.default = _(\"All\")\n        else:\n            user.default = LC.parse(user.default_language).get_language_name(get_locale())\n\n    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": users}\n    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)\n    response = make_response(js_list)\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n\n@admi.route(\"/ajax/deleteuser\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_user():\n    user_ids = request.form.to_dict(flat=False)\n    users = None\n    message = \"\"\n    if \"userid[]\" in user_ids:\n        users = ub.session.query(ub.User).filter(ub.User.id.in_(user_ids['userid[]'])).all()\n    elif \"userid\" in user_ids:\n        users = ub.session.query(ub.User).filter(ub.User.id == user_ids['userid'][0]).all()\n    count = 0\n    errors = list()\n    success = list()\n    if not users:\n        log.error(\"User not found\")\n        return Response(json.dumps({'type': \"danger\", 'message': _(\"User not found\")}), mimetype='application/json')\n    for user in users:\n        try:\n            message = _delete_user(user)\n            count += 1\n        except Exception as ex:\n            log.error(ex)\n            errors.append({'type': \"danger\", 'message': str(ex)})\n\n    if count == 1:\n        log.info(\"User {} deleted\".format(user_ids))\n        success = [{'type': \"success\", 'message': message}]\n    elif count > 1:\n        log.info(\"Users {} deleted\".format(user_ids))\n        success = [{'type': \"success\", 'message': _(\"{} users deleted successfully\").format(count)}]\n    success.extend(errors)\n    return Response(json.dumps(success), mimetype='application/json')\n\n\n@admi.route(\"/ajax/getlocale\")\n@login_required\n@admin_required\ndef table_get_locale():\n    locale = babel.list_translations() + [LC('en')]\n    ret = list()\n    current_locale = get_locale()\n    for loc in locale:\n        ret.append({'value': str(loc), 'text': loc.get_language_name(current_locale)})\n    return json.dumps(ret)\n\n\n@admi.route(\"/ajax/getdefaultlanguage\")\n@login_required\n@admin_required\ndef table_get_default_lang():\n    languages = calibre_db.speaking_language()\n    ret = list()\n    ret.append({'value': 'all', 'text': _('Show All')})\n    for lang in languages:\n        ret.append({'value': lang.lang_code, 'text': lang.name})\n    return json.dumps(ret)\n\n\n@admi.route(\"/ajax/editlistusers/<param>\", methods=['POST'])\n@login_required\n@admin_required\ndef edit_list_user(param):\n    vals = request.form.to_dict(flat=False)\n    all_user = ub.session.query(ub.User)\n    if not config.config_anonbrowse:\n        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)\n    # only one user is posted\n    if \"pk\" in vals:\n        users = [all_user.filter(ub.User.id == vals['pk'][0]).one_or_none()]\n    else:\n        if \"pk[]\" in vals:\n            users = all_user.filter(ub.User.id.in_(vals['pk[]'])).all()\n        else:\n            return _(\"Malformed request\"), 400\n    if 'field_index' in vals:\n        vals['field_index'] = vals['field_index'][0]\n    if 'value' in vals:\n        vals['value'] = vals['value'][0]\n    elif not ('value[]' in vals):\n        return _(\"Malformed request\"), 400\n    for user in users:\n        try:\n            if param in ['denied_tags', 'allowed_tags', 'allowed_column_value', 'denied_column_value']:\n                if 'value[]' in vals:\n                    setattr(user, param, prepare_tags(user, vals['action'][0], param, vals['value[]']))\n                else:\n                    setattr(user, param, vals['value'].strip())\n            else:\n                vals['value'] = vals['value'].strip()\n                if param == 'name':\n                    if user.name == \"Guest\":\n                        raise Exception(_(\"Guest Name can't be changed\"))\n                    user.name = check_username(vals['value'])\n                elif param == 'email':\n                    user.email = check_email(vals['value'])\n                elif param == 'kobo_only_shelves_sync':\n                    user.kobo_only_shelves_sync = int(vals['value'] == 'true')\n                elif param == 'kindle_mail':\n                    user.kindle_mail = valid_email(vals['value']) if vals['value'] else \"\"\n                elif param.endswith('role'):\n                    value = int(vals['field_index'])\n                    if user.name == \"Guest\" and value in \\\n                                 [constants.ROLE_ADMIN, constants.ROLE_PASSWD, constants.ROLE_EDIT_SHELFS]:\n                        raise Exception(_(\"Guest can't have this role\"))\n                    # check for valid value, last on checks for power of 2 value\n                    if value > 0 and value <= constants.ROLE_VIEWER and (value & value-1 == 0 or value == 1):\n                        if vals['value'] == 'true':\n                            user.role |= value\n                        elif vals['value'] == 'false':\n                            if value == constants.ROLE_ADMIN:\n                                if not ub.session.query(ub.User).\\\n                                       filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,\n                                              ub.User.id != user.id).count():\n                                    return Response(\n                                        json.dumps([{'type': \"danger\",\n                                                     'message': _(u\"No admin user remaining, can't remove admin role\",\n                                                                  nick=user.name)}]), mimetype='application/json')\n                            user.role &= ~value\n                        else:\n                            raise Exception(_(\"Value has to be true or false\"))\n                    else:\n                        raise Exception(_(\"Invalid role\"))\n                elif param.startswith('sidebar'):\n                    value = int(vals['field_index'])\n                    if user.name == \"Guest\" and value == constants.SIDEBAR_READ_AND_UNREAD:\n                        raise Exception(_(\"Guest can't have this view\"))\n                    # check for valid value, last on checks for power of 2 value\n                    if value > 0 and value <= constants.SIDEBAR_LIST and (value & value-1 == 0 or value == 1):\n                        if vals['value'] == 'true':\n                            user.sidebar_view |= value\n                        elif vals['value'] == 'false':\n                            user.sidebar_view &= ~value\n                        else:\n                            raise Exception(_(\"Value has to be true or false\"))\n                    else:\n                        raise Exception(_(\"Invalid view\"))\n                elif param == 'locale':\n                    if user.name == \"Guest\":\n                        raise Exception(_(\"Guest's Locale is determined automatically and can't be set\"))\n                    if vals['value'] in _BABEL_TRANSLATIONS:\n                        user.locale = vals['value']\n                    else:\n                        raise Exception(_(\"No Valid Locale Given\"))\n                elif param == 'default_language':\n                    languages = calibre_db.session.query(db.Languages) \\\n                        .join(db.books_languages_link) \\\n                        .join(db.Books) \\\n                        .filter(calibre_db.common_filters()) \\\n                        .group_by(text('books_languages_link.lang_code')).all()\n                    lang_codes = [lang.lang_code for lang in languages] + [\"all\"]\n                    if vals['value'] in lang_codes:\n                        user.default_language = vals['value']\n                    else:\n                        raise Exception(_(\"No Valid Book Language Given\"))\n                else:\n                    return _(\"Parameter not found\"), 400\n        except Exception as ex:\n            log.error_or_exception(ex)\n            return str(ex), 400\n    ub.session_commit()\n    return \"\"\n\n\n@admi.route(\"/ajax/user_table_settings\", methods=['POST'])\n@login_required\n@admin_required\ndef update_table_settings():\n    current_user.view_settings['useredit'] = json.loads(request.data)\n    try:\n        try:\n            flag_modified(current_user, \"view_settings\")\n        except AttributeError:\n            pass\n        ub.session.commit()\n    except (InvalidRequestError, OperationalError):\n        log.error(\"Invalid request received: {}\".format(request))\n        return \"Invalid request\", 400\n    return \"\"\n\n\ndef check_valid_read_column(column):\n    if column != \"0\":\n        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\\n              .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all():\n            return False\n    return True\n\n\ndef check_valid_restricted_column(column):\n    if column != \"0\":\n        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\\n              .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all():\n            return False\n    return True\n\n\n@admi.route(\"/admin/viewconfig\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef update_view_configuration():\n    to_save = request.form.to_dict()\n\n    _config_string(to_save, \"config_calibre_web_title\")\n    _config_string(to_save, \"config_columns_to_ignore\")\n    if _config_string(to_save, \"config_title_regex\"):\n        calibre_db.update_title_sort(config)\n\n    if not check_valid_read_column(to_save.get(\"config_read_column\", \"0\")):\n        flash(_(u\"Invalid Read Column\"), category=\"error\")\n        log.debug(\"Invalid Read column\")\n        return view_configuration()\n    _config_int(to_save, \"config_read_column\")\n\n    if not check_valid_restricted_column(to_save.get(\"config_restricted_column\", \"0\")):\n        flash(_(u\"Invalid Restricted Column\"), category=\"error\")\n        log.debug(\"Invalid Restricted Column\")\n        return view_configuration()\n    _config_int(to_save, \"config_restricted_column\")\n\n    _config_int(to_save, \"config_theme\")\n    _config_int(to_save, \"config_random_books\")\n    _config_int(to_save, \"config_books_per_page\")\n    _config_int(to_save, \"config_authors_max\")\n    _config_string(to_save, \"config_default_language\")\n    _config_string(to_save, \"config_default_locale\")\n\n    config.config_default_role = constants.selected_roles(to_save)\n    config.config_default_role &= ~constants.ROLE_ANONYMOUS\n\n    config.config_default_show = sum(int(k[5:]) for k in to_save if k.startswith('show_'))\n    if \"Show_detail_random\" in to_save:\n        config.config_default_show |= constants.DETAIL_RANDOM\n\n    config.save()\n    flash(_(u\"Calibre-Web configuration updated\"), category=\"success\")\n    log.debug(\"Calibre-Web configuration updated\")\n    before_request()\n\n    return view_configuration()\n\n\n@admi.route(\"/ajax/loaddialogtexts/<element_id>\", methods=['POST'])\n@login_required\ndef load_dialogtexts(element_id):\n    texts = {\"header\": \"\", \"main\": \"\", \"valid\": 1}\n    if element_id == \"config_delete_kobo_token\":\n        texts[\"main\"] = _('Do you really want to delete the Kobo Token?')\n    elif element_id == \"btndeletedomain\":\n        texts[\"main\"] = _('Do you really want to delete this domain?')\n    elif element_id == \"btndeluser\":\n        texts[\"main\"] = _('Do you really want to delete this user?')\n    elif element_id == \"delete_shelf\":\n        texts[\"main\"] = _('Are you sure you want to delete this shelf?')\n    elif element_id == \"select_locale\":\n        texts[\"main\"] = _('Are you sure you want to change locales of selected user(s)?')\n    elif element_id == \"select_default_language\":\n        texts[\"main\"] = _('Are you sure you want to change visible book languages for selected user(s)?')\n    elif element_id == \"role\":\n        texts[\"main\"] = _('Are you sure you want to change the selected role for the selected user(s)?')\n    elif element_id == \"restrictions\":\n        texts[\"main\"] = _('Are you sure you want to change the selected restrictions for the selected user(s)?')\n    elif element_id == \"sidebar_view\":\n        texts[\"main\"] = _('Are you sure you want to change the selected visibility restrictions '\n                          'for the selected user(s)?')\n    elif element_id == \"kobo_only_shelves_sync\":\n        texts[\"main\"] = _('Are you sure you want to change shelf sync behavior for the selected user(s)?')\n    elif element_id == \"db_submit\":\n        texts[\"main\"] = _('Are you sure you want to change Calibre library location?')\n    elif element_id == \"btnfullsync\":\n        texts[\"main\"] = _(\"Are you sure you want delete Calibre-Web's sync database \"\n                          \"to force a full sync with your Kobo Reader?\")\n    return json.dumps(texts)\n\n\n@admi.route(\"/ajax/editdomain/<int:allow>\", methods=['POST'])\n@login_required\n@admin_required\ndef edit_domain(allow):\n    # POST /post\n    # name:  'username',  //name of field (column in db)\n    # pk:    1            //primary key (record id)\n    # value: 'superuser!' //new value\n    vals = request.form.to_dict()\n    answer = ub.session.query(ub.Registration).filter(ub.Registration.id == vals['pk']).first()\n    answer.domain = vals['value'].replace('*', '%').replace('?', '_').lower()\n    return ub.session_commit(\"Registering Domains edited {}\".format(answer.domain))\n\n\n@admi.route(\"/ajax/adddomain/<int:allow>\", methods=['POST'])\n@login_required\n@admin_required\ndef add_domain(allow):\n    domain_name = request.form.to_dict()['domainname'].replace('*', '%').replace('?', '_').lower()\n    check = ub.session.query(ub.Registration).filter(ub.Registration.domain == domain_name)\\\n        .filter(ub.Registration.allow == allow).first()\n    if not check:\n        new_domain = ub.Registration(domain=domain_name, allow=allow)\n        ub.session.add(new_domain)\n        ub.session_commit(\"Registering Domains added {}\".format(domain_name))\n    return \"\"\n\n\n@admi.route(\"/ajax/deletedomain\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_domain():\n    try:\n        domain_id = request.form.to_dict()['domainid'].replace('*', '%').replace('?', '_').lower()\n        ub.session.query(ub.Registration).filter(ub.Registration.id == domain_id).delete()\n        ub.session_commit(\"Registering Domains deleted {}\".format(domain_id))\n        # If last domain was deleted, add all domains by default\n        if not ub.session.query(ub.Registration).filter(ub.Registration.allow == 1).count():\n            new_domain = ub.Registration(domain=\"%.%\", allow=1)\n            ub.session.add(new_domain)\n            ub.session_commit(\"Last Registering Domain deleted, added *.* as default\")\n    except KeyError:\n        pass\n    return \"\"\n\n\n@admi.route(\"/ajax/domainlist/<int:allow>\")\n@login_required\n@admin_required\ndef list_domain(allow):\n    answer = ub.session.query(ub.Registration).filter(ub.Registration.allow == allow).all()\n    json_dumps = json.dumps([{\"domain\": r.domain.replace('%', '*').replace('_', '?'), \"id\": r.id} for r in answer])\n    js = json.dumps(json_dumps.replace('\"', \"'\")).lstrip('\"').strip('\"')\n    response = make_response(js.replace(\"'\", '\"'))\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n\n@admi.route(\"/ajax/editrestriction/<int:res_type>\", defaults={\"user_id\": 0}, methods=['POST'])\n@admi.route(\"/ajax/editrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])\n@login_required\n@admin_required\ndef edit_restriction(res_type, user_id):\n    element = request.form.to_dict()\n    if element['id'].startswith('a'):\n        if res_type == 0:  # Tags as template\n            elementlist = config.list_allowed_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_allowed_tags = ','.join(elementlist)\n            config.save()\n        if res_type == 1:  # CustomC\n            elementlist = config.list_allowed_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_allowed_column_value = ','.join(elementlist)\n            config.save()\n        if res_type == 2:  # Tags per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_allowed_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.allowed_tags = ','.join(elementlist)\n            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.allowed_tags))\n        if res_type == 3:  # CColumn per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_allowed_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.allowed_column_value = ','.join(elementlist)\n            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name, usr.allowed_column_value))\n    if element['id'].startswith('d'):\n        if res_type == 0:  # Tags as template\n            elementlist = config.list_denied_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_denied_tags = ','.join(elementlist)\n            config.save()\n        if res_type == 1:  # CustomC\n            elementlist = config.list_denied_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_denied_column_value = ','.join(elementlist)\n            config.save()\n        if res_type == 2:  # Tags per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_denied_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.denied_tags = ','.join(elementlist)\n            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.denied_tags))\n        if res_type == 3:  # CColumn per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_denied_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.denied_column_value = ','.join(elementlist)\n            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name, usr.denied_column_value))\n    return \"\"\n\n\ndef restriction_addition(element, list_func):\n    elementlist = list_func()\n    if elementlist == ['']:\n        elementlist = []\n    if not element['add_element'] in elementlist:\n        elementlist += [element['add_element']]\n    return ','.join(elementlist)\n\n\ndef restriction_deletion(element, list_func):\n    elementlist = list_func()\n    if element['Element'] in elementlist:\n        elementlist.remove(element['Element'])\n    return ','.join(elementlist)\n\n\ndef prepare_tags(user, action, tags_name, id_list):\n    if \"tags\" in tags_name:\n        tags = calibre_db.session.query(db.Tags).filter(db.Tags.id.in_(id_list)).all()\n        if not tags:\n            raise Exception(_(\"Tag not found\"))\n        new_tags_list = [x.name for x in tags]\n    else:\n        tags = calibre_db.session.query(db.cc_classes[config.config_restricted_column])\\\n            .filter(db.cc_classes[config.config_restricted_column].id.in_(id_list)).all()\n        new_tags_list = [x.value for x in tags]\n    saved_tags_list = user.__dict__[tags_name].split(\",\") if len(user.__dict__[tags_name]) else []\n    if action == \"remove\":\n        saved_tags_list = [x for x in saved_tags_list if x not in new_tags_list]\n    elif action == \"add\":\n        saved_tags_list.extend(x for x in new_tags_list if x not in saved_tags_list)\n    else:\n        raise Exception(_(\"Invalid Action\"))\n    return \",\".join(saved_tags_list)\n\n\n@admi.route(\"/ajax/addrestriction/<int:res_type>\", methods=['POST'])\n@login_required\n@admin_required\ndef add_user_0_restriction(res_type):\n    return add_restriction(res_type, 0)\n\n\n@admi.route(\"/ajax/addrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])\n@login_required\n@admin_required\ndef add_restriction(res_type, user_id):\n    element = request.form.to_dict()\n    if res_type == 0:  # Tags as template\n        if 'submit_allow' in element:\n            config.config_allowed_tags = restriction_addition(element, config.list_allowed_tags)\n            config.save()\n        elif 'submit_deny' in element:\n            config.config_denied_tags = restriction_addition(element, config.list_denied_tags)\n            config.save()\n    if res_type == 1:  # CCustom as template\n        if 'submit_allow' in element:\n            config.config_allowed_column_value = restriction_addition(element, config.list_denied_column_values)\n            config.save()\n        elif 'submit_deny' in element:\n            config.config_denied_column_value = restriction_addition(element, config.list_allowed_column_values)\n            config.save()\n    if res_type == 2:  # Tags per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if 'submit_allow' in element:\n            usr.allowed_tags = restriction_addition(element, usr.list_allowed_tags)\n            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.list_allowed_tags()))\n        elif 'submit_deny' in element:\n            usr.denied_tags = restriction_addition(element, usr.list_denied_tags)\n            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.list_denied_tags()))\n    if res_type == 3:  # CustomC per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if 'submit_allow' in element:\n            usr.allowed_column_value = restriction_addition(element, usr.list_allowed_column_values)\n            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name,\n                                                                                usr.list_allowed_column_values()))\n        elif 'submit_deny' in element:\n            usr.denied_column_value = restriction_addition(element, usr.list_denied_column_values)\n            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name,\n                                                                               usr.list_denied_column_values()))\n    return \"\"\n\n\n@admi.route(\"/ajax/deleterestriction/<int:res_type>\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_user_0_restriction(res_type):\n    return delete_restriction(res_type, 0)\n\n\n@admi.route(\"/ajax/deleterestriction/<int:res_type>/<int:user_id>\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_restriction(res_type, user_id):\n    element = request.form.to_dict()\n    if res_type == 0:  # Tags as template\n        if element['id'].startswith('a'):\n            config.config_allowed_tags = restriction_deletion(element, config.list_allowed_tags)\n            config.save()\n        elif element['id'].startswith('d'):\n            config.config_denied_tags = restriction_deletion(element, config.list_denied_tags)\n            config.save()\n    elif res_type == 1:  # CustomC as template\n        if element['id'].startswith('a'):\n            config.config_allowed_column_value = restriction_deletion(element, config.list_allowed_column_values)\n            config.save()\n        elif element['id'].startswith('d'):\n            config.config_denied_column_value = restriction_deletion(element, config.list_denied_column_values)\n            config.save()\n    elif res_type == 2:  # Tags per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if element['id'].startswith('a'):\n            usr.allowed_tags = restriction_deletion(element, usr.list_allowed_tags)\n            ub.session_commit(\"Deleted allowed tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))\n        elif element['id'].startswith('d'):\n            usr.denied_tags = restriction_deletion(element, usr.list_denied_tags)\n            ub.session_commit(\"Deleted denied tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))\n    elif res_type == 3:  # Columns per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if element['id'].startswith('a'):\n            usr.allowed_column_value = restriction_deletion(element, usr.list_allowed_column_values)\n            ub.session_commit(\"Deleted allowed columns of user {}: {}\".format(usr.name,\n                                                                              usr.list_allowed_column_values))\n\n        elif element['id'].startswith('d'):\n            usr.denied_column_value = restriction_deletion(element, usr.list_denied_column_values)\n            ub.session_commit(\"Deleted denied columns of user {}: {}\".format(usr.name,\n                                                                             usr.list_denied_column_values))\n    return \"\"\n\n\n@admi.route(\"/ajax/listrestriction/<int:res_type>\", defaults={\"user_id\": 0})\n@admi.route(\"/ajax/listrestriction/<int:res_type>/<int:user_id>\")\n@login_required\n@admin_required\ndef list_restriction(res_type, user_id):\n    if res_type == 0:   # Tags as template\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(config.list_denied_tags()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(config.list_allowed_tags()) if x != '']\n        json_dumps = restrict + allow\n    elif res_type == 1:  # CustomC as template\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(config.list_denied_column_values()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(config.list_allowed_column_values()) if x != '']\n        json_dumps = restrict + allow\n    elif res_type == 2:  # Tags per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n        else:\n            usr = current_user\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(usr.list_denied_tags()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(usr.list_allowed_tags()) if x != '']\n        json_dumps = restrict + allow\n    elif res_type == 3:  # CustomC per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n        else:\n            usr = current_user\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(usr.list_denied_column_values()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(usr.list_allowed_column_values()) if x != '']\n        json_dumps = restrict + allow\n    else:\n        json_dumps = \"\"\n    js = json.dumps(json_dumps)\n    response = make_response(js)\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n\n@admi.route(\"/ajax/fullsync\", methods=[\"POST\"])\n@login_required\ndef ajax_fullsync():\n    count = ub.session.query(ub.KoboSyncedBooks).filter(current_user.id == ub.KoboSyncedBooks.user_id).delete()\n    message = _(\"{} sync entries deleted\").format(count)\n    ub.session_commit(message)\n    return Response(json.dumps([{\"type\": \"success\", \"message\": message}]), mimetype='application/json')\n\n\n@admi.route(\"/ajax/pathchooser/\")\n@login_required\n@admin_required\ndef ajax_pathchooser():\n    return pathchooser()\n\n\ndef pathchooser():\n    browse_for = \"folder\"\n    folder_only = request.args.get('folder', False) == \"true\"\n    file_filter = request.args.get('filter', \"\")\n    path = os.path.normpath(request.args.get('path', \"\"))\n\n    if os.path.isfile(path):\n        oldfile = path\n        path = os.path.dirname(path)\n    else:\n        oldfile = \"\"\n\n    absolute = False\n\n    if os.path.isdir(path):\n        # if os.path.isabs(path):\n        cwd = os.path.realpath(path)\n        absolute = True\n        # else:\n        #    cwd = os.path.relpath(path)\n    else:\n        cwd = os.getcwd()\n\n    cwd = os.path.normpath(os.path.realpath(cwd))\n    parentdir = os.path.dirname(cwd)\n    if not absolute:\n        if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n            cwd = os.path.relpath(cwd)\n        else:\n            cwd = os.path.relpath(cwd) + os.path.sep\n        parentdir = os.path.relpath(parentdir) + os.path.sep\n\n    if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n        parentdir = \"\"\n\n    try:\n        folders = os.listdir(cwd)\n    except Exception:\n        folders = []\n\n    files = []\n    for f in folders:\n        try:\n            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}\n            data[\"sort\"] = data[\"fullpath\"].lower()\n        except Exception:\n            continue\n\n        if os.path.isfile(os.path.join(cwd, f)):\n            if folder_only:\n                continue\n            if file_filter != \"\" and file_filter != f:\n                continue\n            data[\"type\"] = \"file\"\n            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))\n\n            power = 0\n            while (data[\"size\"] >> 10) > 0.3:\n                power += 1\n                data[\"size\"] >>= 10\n            units = (\"\", \"K\", \"M\", \"G\", \"T\")\n            data[\"size\"] = str(data[\"size\"]) + \" \" + units[power] + \"Byte\"\n        else:\n            data[\"type\"] = \"dir\"\n            data[\"size\"] = \"\"\n\n        files.append(data)\n\n    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))\n\n    context = {\n        \"cwd\": cwd,\n        \"files\": files,\n        \"parentdir\": parentdir,\n        \"type\": browse_for,\n        \"oldfile\": oldfile,\n        \"absolute\": absolute,\n    }\n    return json.dumps(context)\n\n\ndef _config_int(to_save, x, func=int):\n    return config.set_from_dictionary(to_save, x, func)\n\n\ndef _config_checkbox(to_save, x):\n    return config.set_from_dictionary(to_save, x, lambda y: y == \"on\", False)\n\n\ndef _config_checkbox_int(to_save, x):\n    return config.set_from_dictionary(to_save, x, lambda y: 1 if (y == \"on\") else 0, 0)\n\n\ndef _config_string(to_save, x):\n    return config.set_from_dictionary(to_save, x, lambda y: y.strip() if y else y)\n\n\ndef _configuration_gdrive_helper(to_save):\n    gdrive_error = None\n    if to_save.get(\"config_use_google_drive\"):\n        gdrive_secrets = {}\n\n        if not os.path.isfile(gdriveutils.SETTINGS_YAML):\n            config.config_use_google_drive = False\n\n        if gdrive_support:\n            gdrive_error = gdriveutils.get_error_text(gdrive_secrets)\n        if \"config_use_google_drive\" in to_save and not config.config_use_google_drive and not gdrive_error:\n            with open(gdriveutils.CLIENT_SECRETS, 'r') as settings:\n                gdrive_secrets = json.load(settings)['web']\n            if not gdrive_secrets:\n                return _configuration_result(_('client_secrets.json Is Not Configured For Web Application'))\n            gdriveutils.update_settings(\n                                gdrive_secrets['client_id'],\n                                gdrive_secrets['client_secret'],\n                                gdrive_secrets['redirect_uris'][0]\n                            )\n\n    # always show google drive settings, but in case of error deny support\n    new_gdrive_value = (not gdrive_error) and (\"config_use_google_drive\" in to_save)\n    if config.config_use_google_drive and not new_gdrive_value:\n        config.config_google_drive_watch_changes_response = {}\n    config.config_use_google_drive = new_gdrive_value\n    if _config_string(to_save, \"config_google_drive_folder\"):\n        gdriveutils.deleteDatabaseOnChange()\n    return gdrive_error\n\n\ndef _configuration_oauth_helper(to_save):\n    active_oauths = 0\n    reboot_required = False\n    for element in oauthblueprints:\n        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] != element['oauth_client_id'] \\\n            or to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"] != element['oauth_client_secret']:\n            reboot_required = True\n            element['oauth_client_id'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"]\n            element['oauth_client_secret'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]\n        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] \\\n            and to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]:\n            active_oauths += 1\n            element[\"active\"] = 1\n        else:\n            element[\"active\"] = 0\n        ub.session.query(ub.OAuthProvider).filter(ub.OAuthProvider.id == element['id']).update(\n            {\"oauth_client_id\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"],\n             \"oauth_client_secret\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"],\n             \"active\": element[\"active\"]})\n    return reboot_required\n\n\ndef _configuration_logfile_helper(to_save):\n    reboot_required = False\n    reboot_required |= _config_int(to_save, \"config_log_level\")\n    reboot_required |= _config_string(to_save, \"config_logfile\")\n    if not logger.is_valid_logfile(config.config_logfile):\n        return reboot_required, \\\n               _configuration_result(_('Logfile Location is not Valid, Please Enter Correct Path'))\n\n    reboot_required |= _config_checkbox_int(to_save, \"config_access_log\")\n    reboot_required |= _config_string(to_save, \"config_access_logfile\")\n    if not logger.is_valid_logfile(config.config_access_logfile):\n        return reboot_required, \\\n               _configuration_result(_('Access Logfile Location is not Valid, Please Enter Correct Path'))\n    return reboot_required, None\n\n\ndef _configuration_ldap_helper(to_save):\n    reboot_required = False\n    reboot_required |= _config_string(to_save, \"config_ldap_provider_url\")\n    reboot_required |= _config_int(to_save, \"config_ldap_port\")\n    reboot_required |= _config_int(to_save, \"config_ldap_authentication\")\n    reboot_required |= _config_string(to_save, \"config_ldap_dn\")\n    reboot_required |= _config_string(to_save, \"config_ldap_serv_username\")\n    reboot_required |= _config_string(to_save, \"config_ldap_user_object\")\n    reboot_required |= _config_string(to_save, \"config_ldap_group_object_filter\")\n    reboot_required |= _config_string(to_save, \"config_ldap_group_members_field\")\n    reboot_required |= _config_string(to_save, \"config_ldap_member_user_object\")\n    reboot_required |= _config_checkbox(to_save, \"config_ldap_openldap\")\n    reboot_required |= _config_int(to_save, \"config_ldap_encryption\")\n    reboot_required |= _config_string(to_save, \"config_ldap_cacert_path\")\n    reboot_required |= _config_string(to_save, \"config_ldap_cert_path\")\n    reboot_required |= _config_string(to_save, \"config_ldap_key_path\")\n    _config_string(to_save, \"config_ldap_group_name\")\n    if to_save.get(\"config_ldap_serv_password\", \"\") != \"\":\n        reboot_required |= 1\n        config.set_from_dictionary(to_save, \"config_ldap_serv_password\", base64.b64encode, encode='UTF-8')\n    config.save()\n\n    if not config.config_ldap_provider_url \\\n        or not config.config_ldap_port \\\n        or not config.config_ldap_dn \\\n        or not config.config_ldap_user_object:\n        return reboot_required, _configuration_result(_('Please Enter a LDAP Provider, '\n                                                        'Port, DN and User Object Identifier'))\n\n    if config.config_ldap_authentication > constants.LDAP_AUTH_ANONYMOUS:\n        if config.config_ldap_authentication > constants.LDAP_AUTH_UNAUTHENTICATE:\n            if not config.config_ldap_serv_username or not bool(config.config_ldap_serv_password):\n                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account and Password'))\n        else:\n            if not config.config_ldap_serv_username:\n                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account'))\n\n    if config.config_ldap_group_object_filter:\n        if config.config_ldap_group_object_filter.count(\"%s\") != 1:\n            return reboot_required, \\\n                   _configuration_result(_('LDAP Group Object Filter Needs to Have One \"%s\" Format Identifier'))\n        if config.config_ldap_group_object_filter.count(\"(\") != config.config_ldap_group_object_filter.count(\")\"):\n            return reboot_required, _configuration_result(_('LDAP Group Object Filter Has Unmatched Parenthesis'))\n\n    if config.config_ldap_user_object.count(\"%s\") != 1:\n        return reboot_required, \\\n               _configuration_result(_('LDAP User Object Filter needs to Have One \"%s\" Format Identifier'))\n    if config.config_ldap_user_object.count(\"(\") != config.config_ldap_user_object.count(\")\"):\n        return reboot_required, _configuration_result(_('LDAP User Object Filter Has Unmatched Parenthesis'))\n\n    if to_save.get(\"ldap_import_user_filter\") == '0':\n        config.config_ldap_member_user_object = \"\"\n    else:\n        if config.config_ldap_member_user_object.count(\"%s\") != 1:\n            return reboot_required, \\\n                   _configuration_result(_('LDAP Member User Filter needs to Have One \"%s\" Format Identifier'))\n        if config.config_ldap_member_user_object.count(\"(\") != config.config_ldap_member_user_object.count(\")\"):\n            return reboot_required, _configuration_result(_('LDAP Member User Filter Has Unmatched Parenthesis'))\n\n    if config.config_ldap_cacert_path or config.config_ldap_cert_path or config.config_ldap_key_path:\n        if not (os.path.isfile(config.config_ldap_cacert_path) and\n                os.path.isfile(config.config_ldap_cert_path) and\n                os.path.isfile(config.config_ldap_key_path)):\n            return reboot_required, \\\n                   _configuration_result(_('LDAP CACertificate, Certificate or Key Location is not Valid, '\n                                           'Please Enter Correct Path'))\n    return reboot_required, None\n\n\n@admi.route(\"/ajax/simulatedbchange\", methods=['POST'])\n@login_required\n@admin_required\ndef simulatedbchange():\n    db_change, db_valid = _db_simulate_change()\n    return Response(json.dumps({\"change\": db_change, \"valid\": db_valid}), mimetype='application/json')\n\n\ndef _db_simulate_change():\n    param = request.form.to_dict()\n    to_save = dict()\n    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',\n                                           '',\n                                           param['config_calibre_dir'],\n                                           flags=re.IGNORECASE).strip()\n    db_valid, db_change = calibre_db.check_valid_db(to_save[\"config_calibre_dir\"],\n                                                    ub.app_DB_path,\n                                                    config.config_calibre_uuid)\n    db_change = bool(db_change and config.config_calibre_dir)\n    return db_change, db_valid\n\n\ndef _db_configuration_update_helper():\n    db_change = False\n    to_save = request.form.to_dict()\n    gdrive_error = None\n\n    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',\n                                           '',\n                                           to_save['config_calibre_dir'],\n                                           flags=re.IGNORECASE)\n    try:\n        db_change, db_valid = _db_simulate_change()\n\n        # gdrive_error drive setup\n        gdrive_error = _configuration_gdrive_helper(to_save)\n    except (OperationalError, InvalidRequestError) as e:\n        ub.session.rollback()\n        log.error_or_exception(\"Settings Database error: {}\".format(e))\n        _db_configuration_result(_(u\"Database error: %(error)s.\", error=e.orig), gdrive_error)\n    try:\n        metadata_db = os.path.join(to_save['config_calibre_dir'], \"metadata.db\")\n        if config.config_use_google_drive and is_gdrive_ready() and not os.path.exists(metadata_db):\n            gdriveutils.downloadFile(None, \"metadata.db\", metadata_db)\n            db_change = True\n    except Exception as ex:\n        return _db_configuration_result('{}'.format(ex), gdrive_error)\n\n    if db_change or not db_valid or not config.db_configured \\\n          or config.config_calibre_dir != to_save[\"config_calibre_dir\"]:\n        if not calibre_db.setup_db(to_save['config_calibre_dir'], ub.app_DB_path):\n            return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'),\n                                            gdrive_error)\n        config.store_calibre_uuid(calibre_db, db.Library_Id)\n        # if db changed -> delete shelfs, delete download books, delete read books, kobo sync...\n        if db_change:\n            log.info(\"Calibre Database changed, delete all Calibre-Web info related to old Database\")\n            ub.session.query(ub.Downloads).delete()\n            ub.session.query(ub.ArchivedBook).delete()\n            ub.session.query(ub.ReadBook).delete()\n            ub.session.query(ub.BookShelf).delete()\n            ub.session.query(ub.Bookmark).delete()\n            ub.session.query(ub.KoboReadingState).delete()\n            ub.session.query(ub.KoboStatistics).delete()\n            ub.session.query(ub.KoboSyncedBooks).delete()\n            ub.session_commit()\n        _config_string(to_save, \"config_calibre_dir\")\n        calibre_db.update_config(config)\n        if not os.access(os.path.join(config.config_calibre_dir, \"metadata.db\"), os.W_OK):\n            flash(_(u\"DB is not Writeable\"), category=\"warning\")\n    config.save()\n    return _db_configuration_result(None, gdrive_error)\n\n\ndef _configuration_update_helper():\n    reboot_required = False\n    to_save = request.form.to_dict()\n    try:\n        reboot_required |= _config_int(to_save, \"config_port\")\n        reboot_required |= _config_string(to_save, \"config_trustedhosts\")\n        reboot_required |= _config_string(to_save, \"config_keyfile\")\n        if config.config_keyfile and not os.path.isfile(config.config_keyfile):\n            return _configuration_result(_('Keyfile Location is not Valid, Please Enter Correct Path'))\n\n        reboot_required |= _config_string(to_save, \"config_certfile\")\n        if config.config_certfile and not os.path.isfile(config.config_certfile):\n            return _configuration_result(_('Certfile Location is not Valid, Please Enter Correct Path'))\n\n        _config_checkbox_int(to_save, \"config_uploading\")\n        _config_checkbox_int(to_save, \"config_unicode_filename\")\n        # Reboot on config_anonbrowse with enabled ldap, as decoraters are changed in this case\n        reboot_required |= (_config_checkbox_int(to_save, \"config_anonbrowse\")\n                             and config.config_login_type == constants.LOGIN_LDAP)\n        _config_checkbox_int(to_save, \"config_public_reg\")\n        _config_checkbox_int(to_save, \"config_register_email\")\n        reboot_required |= _config_checkbox_int(to_save, \"config_kobo_sync\")\n        _config_int(to_save, \"config_external_port\")\n        _config_checkbox_int(to_save, \"config_kobo_proxy\")\n\n        if \"config_upload_formats\" in to_save:\n            to_save[\"config_upload_formats\"] = ','.join(\n                helper.uniq([x.lstrip().rstrip().lower() for x in to_save[\"config_upload_formats\"].split(',')]))\n            _config_string(to_save, \"config_upload_formats\")\n            constants.EXTENSIONS_UPLOAD = config.config_upload_formats.split(',')\n\n        _config_string(to_save, \"config_calibre\")\n        _config_string(to_save, \"config_converterpath\")\n        _config_string(to_save, \"config_kepubifypath\")\n\n        reboot_required |= _config_int(to_save, \"config_login_type\")\n\n        # LDAP configurator\n        if config.config_login_type == constants.LOGIN_LDAP:\n            reboot, message = _configuration_ldap_helper(to_save)\n            if message:\n                return message\n            reboot_required |= reboot\n\n        # Remote login configuration\n        _config_checkbox(to_save, \"config_remote_login\")\n        if not config.config_remote_login:\n            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.token_type == 0).delete()\n\n        # Goodreads configuration\n        _config_checkbox(to_save, \"config_use_goodreads\")\n        _config_string(to_save, \"config_goodreads_api_key\")\n        _config_string(to_save, \"config_goodreads_api_secret\")\n        if services.goodreads_support:\n            services.goodreads_support.connect(config.config_goodreads_api_key,\n                                               config.config_goodreads_api_secret,\n                                               config.config_use_goodreads)\n\n        _config_int(to_save, \"config_updatechannel\")\n\n        # Reverse proxy login configuration\n        _config_checkbox(to_save, \"config_allow_reverse_proxy_header_login\")\n        _config_string(to_save, \"config_reverse_proxy_login_header_name\")\n\n        # OAuth configuration\n        if config.config_login_type == constants.LOGIN_OAUTH:\n            reboot_required |= _configuration_oauth_helper(to_save)\n\n        reboot, message = _configuration_logfile_helper(to_save)\n        if message:\n            return message\n        reboot_required |= reboot\n        # Rarfile Content configuration\n        _config_string(to_save, \"config_rarfile_location\")\n        if \"config_rarfile_location\" in to_save:\n            unrar_status = helper.check_unrar(config.config_rarfile_location)\n            if unrar_status:\n                return _configuration_result(unrar_status)\n    except (OperationalError, InvalidRequestError) as e:\n        ub.session.rollback()\n        log.error_or_exception(\"Settings Database error: {}\".format(e))\n        _configuration_result(_(u\"Database error: %(error)s.\", error=e.orig))\n\n    config.save()\n    if reboot_required:\n        web_server.stop(True)\n\n    return _configuration_result(None, reboot_required)\n\n\ndef _configuration_result(error_flash=None, reboot=False):\n    resp = {}\n    if error_flash:\n        log.error(error_flash)\n        config.load()\n        resp['result'] = [{'type': \"danger\", 'message': error_flash}]\n    else:\n        resp['result'] = [{'type': \"success\", 'message': _(u\"Calibre-Web configuration updated\")}]\n    resp['reboot'] = reboot\n    resp['config_upload'] = config.config_upload_formats\n    return Response(json.dumps(resp), mimetype='application/json')\n\n\ndef _db_configuration_result(error_flash=None, gdrive_error=None):\n    gdrive_authenticate = not is_gdrive_ready()\n    gdrivefolders = []\n    if not gdrive_error and config.config_use_google_drive:\n        gdrive_error = gdriveutils.get_error_text()\n    if gdrive_error and gdrive_support:\n        log.error(gdrive_error)\n        gdrive_error = _(gdrive_error)\n        flash(gdrive_error, category=\"error\")\n    else:\n        if not gdrive_authenticate and gdrive_support:\n            gdrivefolders = gdriveutils.listRootFolders()\n    if error_flash:\n        log.error(error_flash)\n        config.load()\n        flash(error_flash, category=\"error\")\n    elif request.method == \"POST\" and not gdrive_error:\n        flash(_(\"Database Settings updated\"), category=\"success\")\n\n    return render_title_template(\"config_db.html\",\n                                 config=config,\n                                 show_authenticate_google_drive=gdrive_authenticate,\n                                 gdriveError=gdrive_error,\n                                 gdrivefolders=gdrivefolders,\n                                 feature_support=feature_support,\n                                 title=_(u\"Database Configuration\"), page=\"dbconfig\")\n\n\ndef _handle_new_user(to_save, content, languages, translations, kobo_support):\n    content.default_language = to_save[\"default_language\"]\n    content.locale = to_save.get(\"locale\", content.locale)\n\n    content.sidebar_view = sum(int(key[5:]) for key in to_save if key.startswith('show_'))\n    if \"show_detail_random\" in to_save:\n        content.sidebar_view |= constants.DETAIL_RANDOM\n\n    content.role = constants.selected_roles(to_save)\n    content.password = generate_password_hash(to_save[\"password\"])\n    try:\n        if not to_save[\"name\"] or not to_save[\"email\"] or not to_save[\"password\"]:\n            log.info(\"Missing entries on new user\")\n            raise Exception(_(u\"Please fill out all fields!\"))\n        content.email = check_email(to_save[\"email\"])\n        # Query User name, if not existing, change\n        content.name = check_username(to_save[\"name\"])\n        if to_save.get(\"kindle_mail\"):\n            content.kindle_mail = valid_email(to_save[\"kindle_mail\"])\n        if config.config_public_reg and not check_valid_domain(content.email):\n            log.info(\"E-mail: {} for new user is not from valid domain\".format(content.email))\n            raise Exception(_(u\"E-mail is not from valid domain\"))\n    except Exception as ex:\n        flash(str(ex), category=\"error\")\n        return render_title_template(\"user_edit.html\", new_user=1, content=content,\n                                     config=config,\n                                     translations=translations,\n                                     languages=languages, title=_(u\"Add new user\"), page=\"newuser\",\n                                     kobo_support=kobo_support, registered_oauth=oauth_check)\n    try:\n        content.allowed_tags = config.config_allowed_tags\n        content.denied_tags = config.config_denied_tags\n        content.allowed_column_value = config.config_allowed_column_value\n        content.denied_column_value = config.config_denied_column_value\n        # No default value for kobo sync shelf setting\n        content.kobo_only_shelves_sync = to_save.get(\"kobo_only_shelves_sync\", 0) == \"on\"\n        ub.session.add(content)\n        ub.session.commit()\n        flash(_(u\"User '%(user)s' created\", user=content.name), category=\"success\")\n        log.debug(\"User {} created\".format(content.name))\n        return redirect(url_for('admin.admin'))\n    except IntegrityError:\n        ub.session.rollback()\n        log.error(\"Found an existing account for {} or {}\".format(content.name, content.email))\n        flash(_(\"Found an existing account for this e-mail address or name.\"), category=\"error\")\n    except OperationalError as e:\n        ub.session.rollback()\n        log.error_or_exception(\"Settings Database error: {}\".format(e))\n        flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")\n\n\ndef _delete_user(content):\n    if ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,\n                                        ub.User.id != content.id).count():\n        if content.name != \"Guest\":\n            # Delete all books in shelfs belonging to user, all shelfs of user, downloadstat of user, read status\n            # and user itself\n            ub.session.query(ub.ReadBook).filter(content.id == ub.ReadBook.user_id).delete()\n            ub.session.query(ub.Downloads).filter(content.id == ub.Downloads.user_id).delete()\n            for us in ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id):\n                ub.session.query(ub.BookShelf).filter(us.id == ub.BookShelf.shelf).delete()\n            ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id).delete()\n            ub.session.query(ub.Bookmark).filter(content.id == ub.Bookmark.user_id).delete()\n            ub.session.query(ub.User).filter(ub.User.id == content.id).delete()\n            ub.session.query(ub.ArchivedBook).filter(ub.ArchivedBook.user_id == content.id).delete()\n            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == content.id).delete()\n            ub.session.query(ub.User_Sessions).filter(ub.User_Sessions.user_id == content.id).delete()\n            ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.user_id == content.id).delete()\n            # delete KoboReadingState and all it's children\n            kobo_entries = ub.session.query(ub.KoboReadingState).filter(ub.KoboReadingState.user_id == content.id).all()\n            for kobo_entry in kobo_entries:\n                ub.session.delete(kobo_entry)\n            ub.session_commit()\n            log.info(\"User {} deleted\".format(content.name))\n            return _(\"User '%(nick)s' deleted\", nick=content.name)\n        else:\n            log.warning(_(\"Can't delete Guest User\"))\n            raise Exception(_(\"Can't delete Guest User\"))\n    else:\n        log.warning(\"No admin user remaining, can't delete user\")\n        raise Exception(_(\"No admin user remaining, can't delete user\"))\n\n\ndef _handle_edit_user(to_save, content, languages, translations, kobo_support):\n    if to_save.get(\"delete\"):\n        try:\n            flash(_delete_user(content), category=\"success\")\n        except Exception as ex:\n            log.error(ex)\n            flash(str(ex), category=\"error\")\n        return redirect(url_for('admin.admin'))\n    else:\n        if not ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,\n                                                ub.User.id != content.id).count() and 'admin_role' not in to_save:\n            log.warning(\"No admin user remaining, can't remove admin role from {}\".format(content.name))\n            flash(_(\"No admin user remaining, can't remove admin role\"), category=\"error\")\n            return redirect(url_for('admin.admin'))\n        if to_save.get(\"password\"):\n            content.password = generate_password_hash(to_save[\"password\"])\n        anonymous = content.is_anonymous\n        content.role = constants.selected_roles(to_save)\n        if anonymous:\n            content.role |= constants.ROLE_ANONYMOUS\n        else:\n            content.role &= ~constants.ROLE_ANONYMOUS\n\n        val = [int(k[5:]) for k in to_save if k.startswith('show_')]\n        sidebar = get_sidebar_config()\n        for element in sidebar:\n            value = element['visibility']\n            if value in val and not content.check_visibility(value):\n                content.sidebar_view |= value\n            elif value not in val and content.check_visibility(value):\n                content.sidebar_view &= ~value\n\n        if to_save.get(\"Show_detail_random\"):\n            content.sidebar_view |= constants.DETAIL_RANDOM\n        else:\n            content.sidebar_view &= ~constants.DETAIL_RANDOM\n\n        old_state = content.kobo_only_shelves_sync\n        content.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0\n        # 1 -> 0: nothing has to be done\n        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs\n        # which don't have to be synced have to be removed (added to Shelf archive)\n        if old_state == 0 and content.kobo_only_shelves_sync == 1:\n            kobo_sync_status.update_on_sync_shelfs(content.id)\n        if to_save.get(\"default_language\"):\n            content.default_language = to_save[\"default_language\"]\n        if to_save.get(\"locale\"):\n            content.locale = to_save[\"locale\"]\n        try:\n            if to_save.get(\"email\", content.email) != content.email:\n                content.email = check_email(to_save[\"email\"])\n            # Query User name, if not existing, change\n            if to_save.get(\"name\", content.name) != content.name:\n                if to_save.get(\"name\") == \"Guest\":\n                    raise Exception(_(\"Guest Name can't be changed\"))\n                content.name = check_username(to_save[\"name\"])\n            if to_save.get(\"kindle_mail\") != content.kindle_mail:\n                content.kindle_mail = valid_email(to_save[\"kindle_mail\"]) if to_save[\"kindle_mail\"] else \"\"\n        except Exception as ex:\n            log.error(ex)\n            flash(str(ex), category=\"error\")\n            return render_title_template(\"user_edit.html\",\n                                         translations=translations,\n                                         languages=languages,\n                                         mail_configured=config.get_mail_server_configured(),\n                                         kobo_support=kobo_support,\n                                         new_user=0,\n                                         content=content,\n                                         config=config,\n                                         registered_oauth=oauth_check,\n                                         title=_(u\"Edit User %(nick)s\", nick=content.name),\n                                         page=\"edituser\")\n    try:\n        ub.session_commit()\n        flash(_(u\"User '%(nick)s' updated\", nick=content.name), category=\"success\")\n    except IntegrityError as ex:\n        ub.session.rollback()\n        log.error(\"An unknown error occurred while changing user: {}\".format(str(ex)))\n        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n    except OperationalError as e:\n        ub.session.rollback()\n        log.error_or_exception(\"Settings Database error: {}\".format(e))\n        flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")\n    return \"\"\n\n\n@admi.route(\"/admin/user/new\", methods=[\"GET\", \"POST\"])\n@login_required\n@admin_required\ndef new_user():\n    content = ub.User()\n    languages = calibre_db.speaking_language()\n    translations = [LC('en')] + babel.list_translations()\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        _handle_new_user(to_save, content, languages, translations, kobo_support)\n    else:\n        content.role = config.config_default_role\n        content.sidebar_view = config.config_default_show\n        content.locale = config.config_default_locale\n        content.default_language = config.config_default_language\n    return render_title_template(\"user_edit.html\", new_user=1, content=content,\n                                 config=config, translations=translations,\n                                 languages=languages, title=_(u\"Add new user\"), page=\"newuser\",\n                                 kobo_support=kobo_support, registered_oauth=oauth_check)\n\n\n@admi.route(\"/admin/mailsettings\")\n@login_required\n@admin_required\ndef edit_mailsettings():\n    content = config.get_mail_settings()\n    return render_title_template(\"email_edit.html\", content=content, title=_(u\"Edit E-mail Server Settings\"),\n                                 page=\"mailset\", feature_support=feature_support)\n\n\n@admi.route(\"/admin/mailsettings\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef update_mailsettings():\n    to_save = request.form.to_dict()\n    _config_int(to_save, \"mail_server_type\")\n    if to_save.get(\"invalidate\"):\n        config.mail_gmail_token = {}\n        try:\n            flag_modified(config, \"mail_gmail_token\")\n        except AttributeError:\n            pass\n    elif to_save.get(\"gmail\"):\n        try:\n            config.mail_gmail_token = services.gmail.setup_gmail(config.mail_gmail_token)\n            flash(_(u\"Gmail Account Verification Successful\"), category=\"success\")\n        except Exception as ex:\n            flash(str(ex), category=\"error\")\n            log.error(ex)\n            return edit_mailsettings()\n\n    else:\n        _config_string(to_save, \"mail_server\")\n        _config_int(to_save, \"mail_port\")\n        _config_int(to_save, \"mail_use_ssl\")\n        _config_string(to_save, \"mail_login\")\n        _config_string(to_save, \"mail_password\")\n        _config_string(to_save, \"mail_from\")\n        _config_int(to_save, \"mail_size\", lambda y: int(y)*1024*1024)\n    try:\n        config.save()\n    except (OperationalError, InvalidRequestError) as e:\n        ub.session.rollback()\n        log.error_or_exception(\"Settings Database error: {}\".format(e))\n        flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")\n        return edit_mailsettings()\n\n    if to_save.get(\"test\"):\n        if current_user.email:\n            result = send_test_mail(current_user.email, current_user.name)\n            if result is None:\n                flash(_(u\"Test e-mail queued for sending to %(email)s, please check Tasks for result\",\n                        email=current_user.email), category=\"info\")\n            else:\n                flash(_(u\"There was an error sending the Test e-mail: %(res)s\", res=result), category=\"error\")\n        else:\n            flash(_(u\"Please configure your e-mail address first...\"), category=\"error\")\n    else:\n        flash(_(u\"E-mail server settings updated\"), category=\"success\")\n\n    return edit_mailsettings()\n\n\n@admi.route(\"/admin/user/<int:user_id>\", methods=[\"GET\", \"POST\"])\n@login_required\n@admin_required\ndef edit_user(user_id):\n    content = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()  # type: ub.User\n    if not content or (not config.config_anonbrowse and content.name == \"Guest\"):\n        flash(_(u\"User not found\"), category=\"error\")\n        return redirect(url_for('admin.admin'))\n    languages = calibre_db.speaking_language(return_all_languages=True)\n    translations = babel.list_translations() + [LC('en')]\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        resp = _handle_edit_user(to_save, content, languages, translations, kobo_support)\n        if resp:\n            return resp\n    return render_title_template(\"user_edit.html\",\n                                 translations=translations,\n                                 languages=languages,\n                                 new_user=0,\n                                 content=content,\n                                 config=config,\n                                 registered_oauth=oauth_check,\n                                 mail_configured=config.get_mail_server_configured(),\n                                 kobo_support=kobo_support,\n                                 title=_(u\"Edit User %(nick)s\", nick=content.name),\n                                 page=\"edituser\")\n\n\n@admi.route(\"/admin/resetpassword/<int:user_id>\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef reset_user_password(user_id):\n    if current_user is not None and current_user.is_authenticated:\n        ret, message = reset_password(user_id)\n        if ret == 1:\n            log.debug(u\"Password for user %s reset\", message)\n            flash(_(u\"Password for user %(user)s reset\", user=message), category=\"success\")\n        elif ret == 0:\n            log.error(u\"An unknown error occurred. Please try again later.\")\n            flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n        else:\n            log.error(u\"Please configure the SMTP mail settings first...\")\n            flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")\n    return redirect(url_for('admin.admin'))\n\n\n@admi.route(\"/admin/logfile\")\n@login_required\n@admin_required\ndef view_logfile():\n    logfiles = {0: logger.get_logfile(config.config_logfile),\n                1: logger.get_accesslogfile(config.config_access_logfile)}\n    return render_title_template(\"logviewer.html\",\n                                 title=_(u\"Logfile viewer\"),\n                                 accesslog_enable=config.config_access_log,\n                                 log_enable=bool(config.config_logfile != logger.LOG_TO_STDOUT),\n                                 logfiles=logfiles,\n                                 page=\"logfile\")\n\n\n@admi.route(\"/ajax/log/<int:logtype>\")\n@login_required\n@admin_required\ndef send_logfile(logtype):\n    if logtype == 1:\n        logfile = logger.get_accesslogfile(config.config_access_logfile)\n        return send_from_directory(os.path.dirname(logfile),\n                                   os.path.basename(logfile))\n    if logtype == 0:\n        logfile = logger.get_logfile(config.config_logfile)\n        return send_from_directory(os.path.dirname(logfile),\n                                   os.path.basename(logfile))\n    else:\n        return \"\"\n\n\n@admi.route(\"/admin/logdownload/<int:logtype>\")\n@login_required\n@admin_required\ndef download_log(logtype):\n    if logtype == 0:\n        file_name = logger.get_logfile(config.config_logfile)\n    elif logtype == 1:\n        file_name = logger.get_accesslogfile(config.config_access_logfile)\n    else:\n        abort(404)\n    if logger.is_valid_logfile(file_name):\n        return debug_info.assemble_logfiles(file_name)\n    abort(404)\n\n\n@admi.route(\"/admin/debug\")\n@login_required\n@admin_required\ndef download_debug():\n    return debug_info.send_debug()\n\n\n@admi.route(\"/get_update_status\", methods=['GET'])\n@login_required\n@admin_required\ndef get_update_status():\n    if feature_support['updater']:\n        log.info(u\"Update status requested\")\n        return updater_thread.get_available_updates(request.method, locale=get_locale())\n    else:\n        return ''\n\n\n@admi.route(\"/get_updater_status\", methods=['GET', 'POST'])\n@login_required\n@admin_required\ndef get_updater_status():\n    status = {}\n    if feature_support['updater']:\n        if request.method == \"POST\":\n            commit = request.form.to_dict()\n            if \"start\" in commit and commit['start'] == 'True':\n                txt = {\n                    \"1\": _(u'Requesting update package'),\n                    \"2\": _(u'Downloading update package'),\n                    \"3\": _(u'Unzipping update package'),\n                    \"4\": _(u'Replacing files'),\n                    \"5\": _(u'Database connections are closed'),\n                    \"6\": _(u'Stopping server'),\n                    \"7\": _(u'Update finished, please press okay and reload page'),\n                    \"8\": _(u'Update failed:') + u' ' + _(u'HTTP Error'),\n                    \"9\": _(u'Update failed:') + u' ' + _(u'Connection error'),\n                    \"10\": _(u'Update failed:') + u' ' + _(u'Timeout while establishing connection'),\n                    \"11\": _(u'Update failed:') + u' ' + _(u'General error'),\n                    \"12\": _(u'Update failed:') + u' ' + _(u'Update file could not be saved in temp dir'),\n                    \"13\": _(u'Update failed:') + u' ' + _(u'Files could not be replaced during update')\n                }\n                status['text'] = txt\n                updater_thread.status = 0\n                updater_thread.resume()\n                status['status'] = updater_thread.get_update_status()\n        elif request.method == \"GET\":\n            try:\n                status['status'] = updater_thread.get_update_status()\n                if status['status'] == -1:\n                    status['status'] = 7\n            except Exception:\n                status['status'] = 11\n        return json.dumps(status)\n    return ''\n\n\ndef ldap_import_create_user(user, user_data):\n    user_login_field = extract_dynamic_field_from_filter(user, config.config_ldap_user_object)\n\n    try:\n        username = user_data[user_login_field][0].decode('utf-8')\n    except KeyError as ex:\n        log.error(\"Failed to extract LDAP user: %s - %s\", user, ex)\n        message = _(u'Failed to extract at least One LDAP User')\n        return 0, message\n\n    # check for duplicate username\n    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first():\n        # if ub.session.query(ub.User).filter(ub.User.name == username).first():\n        log.warning(\"LDAP User  %s Already in Database\", user_data)\n        return 0, None\n\n    kindlemail = ''\n    if 'mail' in user_data:\n        useremail = user_data['mail'][0].decode('utf-8')\n        if len(user_data['mail']) > 1:\n            kindlemail = user_data['mail'][1].decode('utf-8')\n\n    else:\n        log.debug('No Mail Field Found in LDAP Response')\n        useremail = username + '@email.com'\n\n    try:\n        # check for duplicate email\n        useremail = check_email(useremail)\n    except Exception as ex:\n        log.warning(\"LDAP Email Error: {}, {}\".format(user_data, ex))\n        return 0, None\n    content = ub.User()\n    content.name = username\n    content.password = ''  # dummy password which will be replaced by ldap one\n    content.email = useremail\n    content.kindle_mail = kindlemail\n    content.default_language = config.config_default_language\n    content.locale = config.config_default_locale\n    content.role = config.config_default_role\n    content.sidebar_view = config.config_default_show\n    content.allowed_tags = config.config_allowed_tags\n    content.denied_tags = config.config_denied_tags\n    content.allowed_column_value = config.config_allowed_column_value\n    content.denied_column_value = config.config_denied_column_value\n    ub.session.add(content)\n    try:\n        ub.session.commit()\n        return 1, None    # increase no of users\n    except Exception as ex:\n        log.warning(\"Failed to create LDAP user: %s - %s\", user, ex)\n        ub.session.rollback()\n        message = _(u'Failed to Create at Least One LDAP User')\n        return 0, message\n\n\n@admi.route('/import_ldap_users', methods=[\"POST\"])\n@login_required\n@admin_required\ndef import_ldap_users():\n    showtext = {}\n    try:\n        new_users = services.ldap.get_group_members(config.config_ldap_group_name)\n    except (services.ldap.LDAPException, TypeError, AttributeError, KeyError) as e:\n        log.error_or_exception(e)\n        showtext['text'] = _(u'Error: %(ldaperror)s', ldaperror=e)\n        return json.dumps(showtext)\n    if not new_users:\n        log.debug('LDAP empty response')\n        showtext['text'] = _(u'Error: No user returned in response of LDAP server')\n        return json.dumps(showtext)\n\n    imported = 0\n    for username in new_users:\n        user = username.decode('utf-8')\n        if '=' in user:\n            # if member object field is empty take user object as filter\n            if config.config_ldap_member_user_object:\n                query_filter = config.config_ldap_member_user_object\n            else:\n                query_filter = config.config_ldap_user_object\n            try:\n                user_identifier = extract_user_identifier(user, query_filter)\n            except Exception as ex:\n                log.warning(ex)\n                continue\n        else:\n            user_identifier = user\n            query_filter = None\n        try:\n            user_data = services.ldap.get_object_details(user=user_identifier, query_filter=query_filter)\n        except AttributeError as ex:\n            log.error_or_exception(ex)\n            continue\n        if user_data:\n            user_count, message = ldap_import_create_user(user, user_data)\n            if message:\n                showtext['text'] = message\n            else:\n                imported += user_count\n        else:\n            log.warning(\"LDAP User: %s Not Found\", user)\n            showtext['text'] = _(u'At Least One LDAP User Not Found in Database')\n    if not showtext:\n        showtext['text'] = _(u'{} User Successfully Imported'.format(imported))\n    return json.dumps(showtext)\n\n\ndef extract_user_data_from_field(user, field):\n    match = re.search(field + r\"=([\\.\\d\\s\\w-]+)\", user, re.IGNORECASE | re.UNICODE)\n    if match:\n        return match.group(1)\n    else:\n        raise Exception(\"Could Not Parse LDAP User: {}\".format(user))\n\n\ndef extract_dynamic_field_from_filter(user, filtr):\n    match = re.search(\"([a-zA-Z0-9-]+)=%s\", filtr, re.IGNORECASE | re.UNICODE)\n    if match:\n        return match.group(1)\n    else:\n        raise Exception(\"Could Not Parse LDAP Userfield: {}\", user)\n\n\ndef extract_user_identifier(user, filtr):\n    dynamic_field = extract_dynamic_field_from_filter(user, filtr)\n    return extract_user_data_from_field(user, dynamic_field)\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2012-2019 mutschler, cervinko, ok11, jkrehm, nanu-c, Wineliva,\n#                            pjeby, elelay, idalin, Ozzieisaacs\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport copy\nimport os\nimport re\nimport ast\nimport json\nfrom datetime import datetime\nfrom urllib.parse import quote\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import Table, Column, ForeignKey, CheckConstraint\nfrom sqlalchemy import String, Integer, Boolean, TIMESTAMP, Float\nfrom sqlalchemy.orm import relationship, sessionmaker, scoped_session\nfrom sqlalchemy.orm.collections import InstrumentedList\nfrom sqlalchemy.ext.declarative import DeclarativeMeta\nfrom sqlalchemy.exc import OperationalError\ntry:\n    # Compatibility with sqlalchemy 2.0\n    from sqlalchemy.orm import declarative_base\nexcept ImportError:\n    from sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.pool import StaticPool\nfrom sqlalchemy.sql.expression import and_, true, false, text, func, or_\nfrom sqlalchemy.ext.associationproxy import association_proxy\nfrom flask_login import current_user\nfrom flask_babel import gettext as _\nfrom flask import flash\n\nfrom . import logger, ub, isoLanguages\nfrom .pagination import Pagination\n\nfrom weakref import WeakSet\n\ntry:\n    import unidecode\n    use_unidecode = True\nexcept ImportError:\n    use_unidecode = False\n\nlog = logger.create()\n\ncc_exceptions = ['composite', 'series']\ncc_classes = {}\n\nBase = declarative_base()\n\nbooks_authors_link = Table('books_authors_link', Base.metadata,\n                           Column('book', Integer, ForeignKey('books.id'), primary_key=True),\n                           Column('author', Integer, ForeignKey('authors.id'), primary_key=True)\n                           )\n\nbooks_tags_link = Table('books_tags_link', Base.metadata,\n                        Column('book', Integer, ForeignKey('books.id'), primary_key=True),\n                        Column('tag', Integer, ForeignKey('tags.id'), primary_key=True)\n                        )\n\nbooks_series_link = Table('books_series_link', Base.metadata,\n                          Column('book', Integer, ForeignKey('books.id'), primary_key=True),\n                          Column('series', Integer, ForeignKey('series.id'), primary_key=True)\n                          )\n\nbooks_ratings_link = Table('books_ratings_link', Base.metadata,\n                           Column('book', Integer, ForeignKey('books.id'), primary_key=True),\n                           Column('rating', Integer, ForeignKey('ratings.id'), primary_key=True)\n                           )\n\nbooks_languages_link = Table('books_languages_link', Base.metadata,\n                             Column('book', Integer, ForeignKey('books.id'), primary_key=True),\n                             Column('lang_code', Integer, ForeignKey('languages.id'), primary_key=True)\n                             )\n\nbooks_publishers_link = Table('books_publishers_link', Base.metadata,\n                              Column('book', Integer, ForeignKey('books.id'), primary_key=True),\n                              Column('publisher', Integer, ForeignKey('publishers.id'), primary_key=True)\n                              )\n\n\nclass Library_Id(Base):\n    __tablename__ = 'library_id'\n    id = Column(Integer, primary_key=True)\n    uuid = Column(String, nullable=False)\n\n\nclass Identifiers(Base):\n    __tablename__ = 'identifiers'\n\n    id = Column(Integer, primary_key=True)\n    type = Column(String(collation='NOCASE'), nullable=False, default=\"isbn\")\n    val = Column(String(collation='NOCASE'), nullable=False)\n    book = Column(Integer, ForeignKey('books.id'), nullable=False)\n\n    def __init__(self, val, id_type, book):\n        self.val = val\n        self.type = id_type\n        self.book = book\n\n    def formatType(self):\n        format_type = self.type.lower()\n        if format_type == 'amazon':\n            return u\"Amazon\"\n        elif format_type.startswith(\"amazon_\"):\n            return u\"Amazon.{0}\".format(format_type[7:])\n        elif format_type == \"isbn\":\n            return u\"ISBN\"\n        elif format_type == \"doi\":\n            return u\"DOI\"\n        elif format_type == \"douban\":\n            return u\"Douban\"\n        elif format_type == \"goodreads\":\n            return u\"Goodreads\"\n        elif format_type == \"babelio\":\n            return u\"Babelio\"\n        elif format_type == \"google\":\n            return u\"Google Books\"\n        elif format_type == \"kobo\":\n            return u\"Kobo\"\n        elif format_type == \"litres\":\n            return u\"\u041b\u0438\u0442\u0420\u0435\u0441\"\n        elif format_type == \"issn\":\n            return u\"ISSN\"\n        elif format_type == \"isfdb\":\n            return u\"ISFDB\"\n        if format_type == \"lubimyczytac\":\n            return u\"Lubimyczytac\"\n        else:\n            return self.type\n\n    def __repr__(self):\n        format_type = self.type.lower()\n        if format_type == \"amazon\" or format_type == \"asin\":\n            return u\"https://amazon.com/dp/{0}\".format(self.val)\n        elif format_type.startswith('amazon_'):\n            return u\"https://amazon.{0}/dp/{1}\".format(format_type[7:], self.val)\n        elif format_type == \"isbn\":\n            return u\"https://www.worldcat.org/isbn/{0}\".format(self.val)\n        elif format_type == \"doi\":\n            return u\"https://dx.doi.org/{0}\".format(self.val)\n        elif format_type == \"goodreads\":\n            return u\"https://www.goodreads.com/book/show/{0}\".format(self.val)\n        elif format_type == \"babelio\":\n            return u\"https://www.babelio.com/livres/titre/{0}\".format(self.val)\n        elif format_type == \"douban\":\n            return u\"https://book.douban.com/subject/{0}\".format(self.val)\n        elif format_type == \"google\":\n            return u\"https://books.google.com/books?id={0}\".format(self.val)\n        elif format_type == \"kobo\":\n            return u\"https://www.kobo.com/ebook/{0}\".format(self.val)\n        elif format_type == \"lubimyczytac\":\n            return u\"https://lubimyczytac.pl/ksiazka/{0}/ksiazka\".format(self.val)\n        elif format_type == \"litres\":\n            return u\"https://www.litres.ru/{0}\".format(self.val)\n        elif format_type == \"issn\":\n            return u\"https://portal.issn.org/resource/ISSN/{0}\".format(self.val)\n        elif format_type == \"isfdb\":\n            return u\"http://www.isfdb.org/cgi-bin/pl.cgi?{0}\".format(self.val)\n        elif self.val.lower().startswith(\"javascript:\"):\n            return quote(self.val)\n        else:\n            return u\"{0}\".format(self.val)\n\n\nclass Comments(Base):\n    __tablename__ = 'comments'\n\n    id = Column(Integer, primary_key=True)\n    book = Column(Integer, ForeignKey('books.id'), nullable=False, unique=True)\n    text = Column(String(collation='NOCASE'), nullable=False)\n\n    def __init__(self, text, book):\n        self.text = text\n        self.book = book\n\n    def get(self):\n        return self.text\n\n    def __repr__(self):\n        return u\"<Comments({0})>\".format(self.text)\n\n\nclass Tags(Base):\n    __tablename__ = 'tags'\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String(collation='NOCASE'), unique=True, nullable=False)\n\n    def __init__(self, name):\n        self.name = name\n\n    def get(self):\n        return self.name\n\n    def __repr__(self):\n        return u\"<Tags('{0})>\".format(self.name)\n\n\nclass Authors(Base):\n    __tablename__ = 'authors'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(collation='NOCASE'), unique=True, nullable=False)\n    sort = Column(String(collation='NOCASE'))\n    link = Column(String, nullable=False, default=\"\")\n\n    def __init__(self, name, sort, link):\n        self.name = name\n        self.sort = sort\n        self.link = link\n\n    def get(self):\n        return self.name\n\n    def __repr__(self):\n        return u\"<Authors('{0},{1}{2}')>\".format(self.name, self.sort, self.link)\n\n\nclass Series(Base):\n    __tablename__ = 'series'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(collation='NOCASE'), unique=True, nullable=False)\n    sort = Column(String(collation='NOCASE'))\n\n    def __init__(self, name, sort):\n        self.name = name\n        self.sort = sort\n\n    def get(self):\n        return self.name\n\n    def __repr__(self):\n        return u\"<Series('{0},{1}')>\".format(self.name, self.sort)\n\n\nclass Ratings(Base):\n    __tablename__ = 'ratings'\n\n    id = Column(Integer, primary_key=True)\n    rating = Column(Integer, CheckConstraint('rating>-1 AND rating<11'), unique=True)\n\n    def __init__(self, rating):\n        self.rating = rating\n\n    def get(self):\n        return self.rating\n\n    def __repr__(self):\n        return u\"<Ratings('{0}')>\".format(self.rating)\n\n\nclass Languages(Base):\n    __tablename__ = 'languages'\n\n    id = Column(Integer, primary_key=True)\n    lang_code = Column(String(collation='NOCASE'), nullable=False, unique=True)\n\n    def __init__(self, lang_code):\n        self.lang_code = lang_code\n\n    def get(self):\n        if self.language_name:\n            return self.language_name\n        else:\n            return self.lang_code\n\n    def __repr__(self):\n        return u\"<Languages('{0}')>\".format(self.lang_code)\n\n\nclass Publishers(Base):\n    __tablename__ = 'publishers'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(collation='NOCASE'), nullable=False, unique=True)\n    sort = Column(String(collation='NOCASE'))\n\n    def __init__(self, name, sort):\n        self.name = name\n        self.sort = sort\n\n    def get(self):\n        return self.name\n\n    def __repr__(self):\n        return u\"<Publishers('{0},{1}')>\".format(self.name, self.sort)\n\n\nclass Data(Base):\n    __tablename__ = 'data'\n    __table_args__ = {'schema': 'calibre'}\n\n    id = Column(Integer, primary_key=True)\n    book = Column(Integer, ForeignKey('books.id'), nullable=False)\n    format = Column(String(collation='NOCASE'), nullable=False)\n    uncompressed_size = Column(Integer, nullable=False)\n    name = Column(String, nullable=False)\n\n    def __init__(self, book, book_format, uncompressed_size, name):\n        self.book = book\n        self.format = book_format\n        self.uncompressed_size = uncompressed_size\n        self.name = name\n\n    # ToDo: Check\n    def get(self):\n        return self.name\n\n    def __repr__(self):\n        return u\"<Data('{0},{1}{2}{3}')>\".format(self.book, self.format, self.uncompressed_size, self.name)\n\n\nclass Books(Base):\n    __tablename__ = 'books'\n\n    DEFAULT_PUBDATE = datetime(101, 1, 1, 0, 0, 0, 0)  # (\"0101-01-01 00:00:00+00:00\")\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    title = Column(String(collation='NOCASE'), nullable=False, default='Unknown')\n    sort = Column(String(collation='NOCASE'))\n    author_sort = Column(String(collation='NOCASE'))\n    timestamp = Column(TIMESTAMP, default=datetime.utcnow)\n    pubdate = Column(TIMESTAMP, default=DEFAULT_PUBDATE)\n    series_index = Column(String, nullable=False, default=\"1.0\")\n    last_modified = Column(TIMESTAMP, default=datetime.utcnow)\n    path = Column(String, default=\"\", nullable=False)\n    has_cover = Column(Integer, default=0)\n    uuid = Column(String)\n    isbn = Column(String(collation='NOCASE'), default=\"\")\n    flags = Column(Integer, nullable=False, default=1)\n\n    authors = relationship(Authors, secondary=books_authors_link, backref='books')\n    tags = relationship(Tags, secondary=books_tags_link, backref='books', order_by=\"Tags.name\")\n    comments = relationship(Comments, backref='books')\n    data = relationship(Data, backref='books')\n    series = relationship(Series, secondary=books_series_link, backref='books')\n    ratings = relationship(Ratings, secondary=books_ratings_link, backref='books')\n    languages = relationship(Languages, secondary=books_languages_link, backref='books')\n    publishers = relationship(Publishers, secondary=books_publishers_link, backref='books')\n    identifiers = relationship(Identifiers, backref='books')\n\n    def __init__(self, title, sort, author_sort, timestamp, pubdate, series_index, last_modified, path, has_cover,\n                 authors, tags, languages=None):\n        self.title = title\n        self.sort = sort\n        self.author_sort = author_sort\n        self.timestamp = timestamp\n        self.pubdate = pubdate\n        self.series_index = series_index\n        self.last_modified = last_modified\n        self.path = path\n        self.has_cover = (has_cover != None)\n\n\n    def __repr__(self):\n        return u\"<Books('{0},{1}{2}{3}{4}{5}{6}{7}{8}')>\".format(self.title, self.sort, self.author_sort,\n                                                                 self.timestamp, self.pubdate, self.series_index,\n                                                                 self.last_modified, self.path, self.has_cover)\n\n    @property\n    def atom_timestamp(self):\n        return (self.timestamp.strftime('%Y-%m-%dT%H:%M:%S+00:00') or '')\n\n\nclass Custom_Columns(Base):\n    __tablename__ = 'custom_columns'\n\n    id = Column(Integer, primary_key=True)\n    label = Column(String)\n    name = Column(String)\n    datatype = Column(String)\n    mark_for_delete = Column(Boolean)\n    editable = Column(Boolean)\n    display = Column(String)\n    is_multiple = Column(Boolean)\n    normalized = Column(Boolean)\n\n    def get_display_dict(self):\n        display_dict = ast.literal_eval(self.display)\n        return display_dict\n\n\nclass AlchemyEncoder(json.JSONEncoder):\n\n    def default(self, o):\n        if isinstance(o.__class__, DeclarativeMeta):\n            # an SQLAlchemy class\n            fields = {}\n            for field in [x for x in dir(o) if not x.startswith('_') and x != 'metadata' and x != \"password\"]:\n                if field == 'books':\n                    continue\n                data = o.__getattribute__(field)\n                try:\n                    if isinstance(data, str):\n                        data = data.replace(\"'\", \"\\'\")\n                    elif isinstance(data, InstrumentedList):\n                        el = list()\n                        # ele = None\n                        for ele in data:\n                            if hasattr(ele, 'value'):       # converter for custom_column values\n                                el.append(str(ele.value))\n                            elif ele.get:\n                                el.append(ele.get())\n                            else:\n                                el.append(json.dumps(ele, cls=AlchemyEncoder))\n                        if field == 'authors':\n                            data = \" & \".join(el)\n                        else:\n                            data = \",\".join(el)\n                        if data == '[]':\n                            data = \"\"\n                    else:\n                        json.dumps(data)\n                    fields[field] = data\n                except Exception:\n                    fields[field] = \"\"\n            # a json-encodable dict\n            return fields\n\n        return json.JSONEncoder.default(self, o)\n\n\nclass CalibreDB():\n    _init = False\n    engine = None\n    config = None\n    session_factory = None\n    # This is a WeakSet so that references here don't keep other CalibreDB\n    # instances alive once they reach the end of their respective scopes\n    instances = WeakSet()\n\n    def __init__(self, expire_on_commit=True):\n        \"\"\" Initialize a new CalibreDB session\n        \"\"\"\n        self.session = None\n        if self._init:\n            self.initSession(expire_on_commit)\n\n        self.instances.add(self)\n\n    def initSession(self, expire_on_commit=True):\n        self.session = self.session_factory()\n        self.session.expire_on_commit = expire_on_commit\n        self.update_title_sort(self.config)\n\n    @classmethod\n    def setup_db_cc_classes(self, cc):\n        cc_ids = []\n        books_custom_column_links = {}\n        for row in cc:\n            if row.datatype not in cc_exceptions:\n                if row.datatype == 'series':\n                    dicttable = {'__tablename__': 'books_custom_column_' + str(row.id) + '_link',\n                                 'id': Column(Integer, primary_key=True),\n                                 'book': Column(Integer, ForeignKey('books.id'),\n                                                primary_key=True),\n                                 'map_value': Column('value', Integer,\n                                                     ForeignKey('custom_column_' +\n                                                                str(row.id) + '.id'),\n                                                     primary_key=True),\n                                 'extra': Column(Float),\n                                 'asoc': relationship('custom_column_' + str(row.id), uselist=False),\n                                 'value': association_proxy('asoc', 'value')\n                                 }\n                    books_custom_column_links[row.id] = type(str('books_custom_column_' + str(row.id) + '_link'),\n                                                             (Base,), dicttable)\n                if row.datatype in ['rating', 'text', 'enumeration']:\n                    books_custom_column_links[row.id] = Table('books_custom_column_' + str(row.id) + '_link',\n                                                              Base.metadata,\n                                                              Column('book', Integer, ForeignKey('books.id'),\n                                                                     primary_key=True),\n                                                              Column('value', Integer,\n                                                                     ForeignKey('custom_column_' +\n                                                                                str(row.id) + '.id'),\n                                                                     primary_key=True)\n                                                              )\n                cc_ids.append([row.id, row.datatype])\n\n                ccdict = {'__tablename__': 'custom_column_' + str(row.id),\n                          'id': Column(Integer, primary_key=True)}\n                if row.datatype == 'float':\n                    ccdict['value'] = Column(Float)\n                elif row.datatype == 'int':\n                    ccdict['value'] = Column(Integer)\n                elif row.datatype == 'datetime':\n                    ccdict['value'] = Column(TIMESTAMP)\n                elif row.datatype == 'bool':\n                    ccdict['value'] = Column(Boolean)\n                else:\n                    ccdict['value'] = Column(String)\n                if row.datatype in ['float', 'int', 'bool', 'datetime', 'comments']:\n                    ccdict['book'] = Column(Integer, ForeignKey('books.id'))\n                cc_classes[row.id] = type(str('custom_column_' + str(row.id)), (Base,), ccdict)\n\n        for cc_id in cc_ids:\n            if cc_id[1] in ['bool', 'int', 'float', 'datetime', 'comments']:\n                setattr(Books,\n                        'custom_column_' + str(cc_id[0]),\n                        relationship(cc_classes[cc_id[0]],\n                                     primaryjoin=(\n                                         Books.id == cc_classes[cc_id[0]].book),\n                                     backref='books'))\n            elif cc_id[1] == 'series':\n                setattr(Books,\n                        'custom_column_' + str(cc_id[0]),\n                        relationship(books_custom_column_links[cc_id[0]],\n                                     backref='books'))\n            else:\n                setattr(Books,\n                        'custom_column_' + str(cc_id[0]),\n                        relationship(cc_classes[cc_id[0]],\n                                     secondary=books_custom_column_links[cc_id[0]],\n                                     backref='books'))\n\n        return cc_classes\n\n    @classmethod\n    def check_valid_db(cls, config_calibre_dir, app_db_path, config_calibre_uuid):\n        if not config_calibre_dir:\n            return False, False\n        dbpath = os.path.join(config_calibre_dir, \"metadata.db\")\n        if not os.path.exists(dbpath):\n            return False, False\n        try:\n            check_engine = create_engine('sqlite://',\n                          echo=False,\n                          isolation_level=\"SERIALIZABLE\",\n                          connect_args={'check_same_thread': False},\n                          poolclass=StaticPool)\n            with check_engine.begin() as connection:\n                connection.execute(text(\"attach database '{}' as calibre;\".format(dbpath)))\n                connection.execute(text(\"attach database '{}' as app_settings;\".format(app_db_path)))\n                local_session = scoped_session(sessionmaker())\n                local_session.configure(bind=connection)\n                database_uuid = local_session().query(Library_Id).one_or_none()\n                # local_session.dispose()\n\n            check_engine.connect()\n            db_change = config_calibre_uuid != database_uuid.uuid\n        except Exception:\n            return False, False\n        return True, db_change\n\n    @classmethod\n    def update_config(cls, config):\n        cls.config = config\n\n    @classmethod\n    def setup_db(cls, config_calibre_dir, app_db_path):\n        cls.dispose()\n\n        if not config_calibre_dir:\n            cls.config.invalidate()\n            return False\n\n        dbpath = os.path.join(config_calibre_dir, \"metadata.db\")\n        if not os.path.exists(dbpath):\n            cls.config.invalidate()\n            return False\n\n        try:\n            cls.engine = create_engine('sqlite://',\n                                       echo=False,\n                                       isolation_level=\"SERIALIZABLE\",\n                                       connect_args={'check_same_thread': False},\n                                       poolclass=StaticPool)\n            with cls.engine.begin() as connection:\n                connection.execute(text(\"attach database '{}' as calibre;\".format(dbpath)))\n                connection.execute(text(\"attach database '{}' as app_settings;\".format(app_db_path)))\n\n            conn = cls.engine.connect()\n            # conn.text_factory = lambda b: b.decode(errors = 'ignore') possible fix for #1302\n        except Exception as ex:\n            cls.config.invalidate(ex)\n            return False\n\n        cls.config.db_configured = True\n\n        if not cc_classes:\n            try:\n                cc = conn.execute(text(\"SELECT id, datatype FROM custom_columns\"))\n                cls.setup_db_cc_classes(cc)\n            except OperationalError as e:\n                log.error_or_exception(e)\n\n        cls.session_factory = scoped_session(sessionmaker(autocommit=False,\n                                                          autoflush=True,\n                                                          bind=cls.engine))\n        for inst in cls.instances:\n            inst.initSession()\n\n        cls._init = True\n        return True\n\n    def get_book(self, book_id):\n        return self.session.query(Books).filter(Books.id == book_id).first()\n\n    def get_filtered_book(self, book_id, allow_show_archived=False):\n        return self.session.query(Books).filter(Books.id == book_id). \\\n            filter(self.common_filters(allow_show_archived)).first()\n\n    def get_book_read_archived(self, book_id, read_column, allow_show_archived=False):\n        if not read_column:\n            bd = (self.session.query(Books, ub.ReadBook.read_status, ub.ArchivedBook.is_archived).select_from(Books)\n                  .join(ub.ReadBook, and_(ub.ReadBook.user_id == int(current_user.id), ub.ReadBook.book_id == book_id),\n                  isouter=True))\n        else:\n            try:\n                read_column = cc_classes[read_column]\n                bd = (self.session.query(Books, read_column.value, ub.ArchivedBook.is_archived).select_from(Books)\n                      .join(read_column, read_column.book == book_id,\n                      isouter=True))\n            except (KeyError, AttributeError):\n                log.error(\"Custom Column No.%d is not existing in calibre database\", read_column)\n                # Skip linking read column and return None instead of read status\n                bd = self.session.query(Books, None, ub.ArchivedBook.is_archived)\n        return (bd.filter(Books.id == book_id)\n                .join(ub.ArchivedBook, and_(Books.id == ub.ArchivedBook.book_id,\n                                            int(current_user.id) == ub.ArchivedBook.user_id), isouter=True)\n                .filter(self.common_filters(allow_show_archived)).first())\n\n    def get_book_by_uuid(self, book_uuid):\n        return self.session.query(Books).filter(Books.uuid == book_uuid).first()\n\n    def get_book_format(self, book_id, file_format):\n        return self.session.query(Data).filter(Data.book == book_id).filter(Data.format == file_format).first()\n\n    # Language and content filters for displaying in the UI\n    def common_filters(self, allow_show_archived=False, return_all_languages=False):\n        if not allow_show_archived:\n            archived_books = (\n                ub.session.query(ub.ArchivedBook)\n                    .filter(ub.ArchivedBook.user_id == int(current_user.id))\n                    .filter(ub.ArchivedBook.is_archived == True)\n                    .all()\n            )\n            archived_book_ids = [archived_book.book_id for archived_book in archived_books]\n            archived_filter = Books.id.notin_(archived_book_ids)\n        else:\n            archived_filter = true()\n\n        if current_user.filter_language() == \"all\" or return_all_languages:\n            lang_filter = true()\n        else:\n            lang_filter = Books.languages.any(Languages.lang_code == current_user.filter_language())\n        negtags_list = current_user.list_denied_tags()\n        postags_list = current_user.list_allowed_tags()\n        neg_content_tags_filter = false() if negtags_list == [''] else Books.tags.any(Tags.name.in_(negtags_list))\n        pos_content_tags_filter = true() if postags_list == [''] else Books.tags.any(Tags.name.in_(postags_list))\n        if self.config.config_restricted_column:\n            try:\n                pos_cc_list = current_user.allowed_column_value.split(',')\n                pos_content_cc_filter = true() if pos_cc_list == [''] else \\\n                    getattr(Books, 'custom_column_' + str(self.config.config_restricted_column)). \\\n                        any(cc_classes[self.config.config_restricted_column].value.in_(pos_cc_list))\n                neg_cc_list = current_user.denied_column_value.split(',')\n                neg_content_cc_filter = false() if neg_cc_list == [''] else \\\n                    getattr(Books, 'custom_column_' + str(self.config.config_restricted_column)). \\\n                        any(cc_classes[self.config.config_restricted_column].value.in_(neg_cc_list))\n            except (KeyError, AttributeError):\n                pos_content_cc_filter = false()\n                neg_content_cc_filter = true()\n                log.error(u\"Custom Column No.%d is not existing in calibre database\",\n                          self.config.config_restricted_column)\n                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",\n                        column=self.config.config_restricted_column),\n                      category=\"error\")\n\n        else:\n            pos_content_cc_filter = true()\n            neg_content_cc_filter = false()\n        return and_(lang_filter, pos_content_tags_filter, ~neg_content_tags_filter,\n                    pos_content_cc_filter, ~neg_content_cc_filter, archived_filter)\n\n    @staticmethod\n    def get_checkbox_sorted(inputlist, state, offset, limit, order, combo=False):\n        outcome = list()\n        if combo:\n            elementlist = {ele[0].id: ele for ele in inputlist}\n        else:\n            elementlist = {ele.id: ele for ele in inputlist}\n        for entry in state:\n            try:\n                outcome.append(elementlist[entry])\n            except KeyError:\n                pass\n            del elementlist[entry]\n        for entry in elementlist:\n            outcome.append(elementlist[entry])\n        if order == \"asc\":\n            outcome.reverse()\n        return outcome[offset:offset + limit]\n\n    # Fill indexpage with all requested data from database\n    def fill_indexpage(self, page, pagesize, database, db_filter, order,\n                       join_archive_read=False, config_read_column=0, *join):\n        return self.fill_indexpage_with_archived_books(page, database, pagesize, db_filter, order, False,\n                                                       join_archive_read, config_read_column, *join)\n\n    def fill_indexpage_with_archived_books(self, page, database, pagesize, db_filter, order, allow_show_archived,\n                                           join_archive_read, config_read_column, *join):\n        pagesize = pagesize or self.config.config_books_per_page\n        if current_user.show_detail_random():\n            randm = self.session.query(Books) \\\n                .filter(self.common_filters(allow_show_archived)) \\\n                .order_by(func.random()) \\\n                .limit(self.config.config_random_books).all()\n        else:\n            randm = false()\n        if join_archive_read:\n            if not config_read_column:\n                query = (self.session.query(database, ub.ReadBook.read_status, ub.ArchivedBook.is_archived)\n                         .select_from(Books)\n                         .outerjoin(ub.ReadBook,\n                               and_(ub.ReadBook.user_id == int(current_user.id), ub.ReadBook.book_id == Books.id)))\n            else:\n                try:\n                    read_column = cc_classes[config_read_column]\n                    query = (self.session.query(database, read_column.value, ub.ArchivedBook.is_archived)\n                             .select_from(Books)\n                             .outerjoin(read_column, read_column.book == Books.id))\n                except (KeyError, AttributeError):\n                    log.error(\"Custom Column No.%d is not existing in calibre database\", read_column)\n                    # Skip linking read column and return None instead of read status\n                    query =self.session.query(database, None, ub.ArchivedBook.is_archived)\n            query = query.outerjoin(ub.ArchivedBook, and_(Books.id == ub.ArchivedBook.book_id,\n                                                          int(current_user.id) == ub.ArchivedBook.user_id))\n        else:\n            query = self.session.query(database)\n        off = int(int(pagesize) * (page - 1))\n\n        indx = len(join)\n        element = 0\n        while indx:\n            if indx >= 3:\n                query = query.outerjoin(join[element], join[element+1]).outerjoin(join[element+2])\n                indx -= 3\n                element += 3\n            elif indx == 2:\n                query = query.outerjoin(join[element], join[element+1])\n                indx -= 2\n                element += 2\n            elif indx == 1:\n                query = query.outerjoin(join[element])\n                indx -= 1\n                element += 1\n        query = query.filter(db_filter)\\\n            .filter(self.common_filters(allow_show_archived))\n        entries = list()\n        pagination = list()\n        try:\n            pagination = Pagination(page, pagesize,\n                                    len(query.all()))\n            entries = query.order_by(*order).offset(off).limit(pagesize).all()\n        except Exception as ex:\n            log.error_or_exception(ex)\n        # display authors in right order\n        entries = self.order_authors(entries, True, join_archive_read)\n        return entries, randm, pagination\n\n    # Orders all Authors in the list according to authors sort\n    def order_authors(self, entries, list_return=False, combined=False):\n        # entries_copy = copy.deepcopy(entries)\n        # entries_copy =[]\n        for entry in entries:\n            if combined:\n                sort_authors = entry.Books.author_sort.split('&')\n                ids = [a.id for a in entry.Books.authors]\n\n            else:\n                sort_authors = entry.author_sort.split('&')\n                ids = [a.id for a in entry.authors]\n            authors_ordered = list()\n            # error = False\n            for auth in sort_authors:\n                results = self.session.query(Authors).filter(Authors.sort == auth.lstrip().strip()).all()\n                # ToDo: How to handle not found author name\n                if not len(results):\n                    log.error(\"Author {} not found to display name in right order\".format(auth.strip()))\n                    # error = True\n                    break\n                for r in results:\n                    if r.id in ids:\n                        authors_ordered.append(r)\n                        ids.remove(r.id)\n            for author_id in ids:\n                result = self.session.query(Authors).filter(Authors.id == author_id).first()\n                authors_ordered.append(result)\n\n            if list_return:\n                if combined:\n                    entry.Books.authors = authors_ordered\n                else:\n                    entry.ordered_authors = authors_ordered\n            else:\n                return authors_ordered\n        return entries\n\n\n    def get_typeahead(self, database, query, replace=('', ''), tag_filter=true()):\n        query = query or ''\n        self.session.connection().connection.connection.create_function(\"lower\", 1, lcase)\n        entries = self.session.query(database).filter(tag_filter). \\\n            filter(func.lower(database.name).ilike(\"%\" + query + \"%\")).all()\n        # json_dumps = json.dumps([dict(name=escape(r.name.replace(*replace))) for r in entries])\n        json_dumps = json.dumps([dict(name=r.name.replace(*replace)) for r in entries])\n        return json_dumps\n\n    def check_exists_book(self, authr, title):\n        self.session.connection().connection.connection.create_function(\"lower\", 1, lcase)\n        q = list()\n        authorterms = re.split(r'\\s*&\\s*', authr)\n        for authorterm in authorterms:\n            q.append(Books.authors.any(func.lower(Authors.name).ilike(\"%\" + authorterm + \"%\")))\n\n        return self.session.query(Books) \\\n            .filter(and_(Books.authors.any(and_(*q)), func.lower(Books.title).ilike(\"%\" + title + \"%\"))).first()\n\n    def search_query(self, term, config_read_column, *join):\n        term.strip().lower()\n        self.session.connection().connection.connection.create_function(\"lower\", 1, lcase)\n        q = list()\n        authorterms = re.split(\"[, ]+\", term)\n        for authorterm in authorterms:\n            q.append(Books.authors.any(func.lower(Authors.name).ilike(\"%\" + authorterm + \"%\")))\n        if not config_read_column:\n            query = (self.session.query(Books, ub.ArchivedBook.is_archived, ub.ReadBook).select_from(Books)\n                     .outerjoin(ub.ReadBook, and_(Books.id == ub.ReadBook.book_id,\n                                                  int(current_user.id) == ub.ReadBook.user_id)))\n        else:\n            try:\n                read_column = cc_classes[config_read_column]\n                query = (self.session.query(Books, ub.ArchivedBook.is_archived, read_column.value).select_from(Books)\n                         .outerjoin(read_column, read_column.book == Books.id))\n            except (KeyError, AttributeError):\n                log.error(\"Custom Column No.%d is not existing in calibre database\", config_read_column)\n                # Skip linking read column\n                query = self.session.query(Books, ub.ArchivedBook.is_archived, None)\n        query = query.outerjoin(ub.ArchivedBook, and_(Books.id == ub.ArchivedBook.book_id,\n                                                      int(current_user.id) == ub.ArchivedBook.user_id))\n\n        if len(join) == 6:\n            query = query.outerjoin(join[0], join[1]).outerjoin(join[2]).outerjoin(join[3], join[4]).outerjoin(join[5])\n        if len(join) == 3:\n            query = query.outerjoin(join[0], join[1]).outerjoin(join[2])\n        elif len(join) == 2:\n            query = query.outerjoin(join[0], join[1])\n        elif len(join) == 1:\n            query = query.outerjoin(join[0])\n        return query.filter(self.common_filters(True)).filter(\n            or_(Books.tags.any(func.lower(Tags.name).ilike(\"%\" + term + \"%\")),\n                Books.series.any(func.lower(Series.name).ilike(\"%\" + term + \"%\")),\n                Books.authors.any(and_(*q)),\n                Books.publishers.any(func.lower(Publishers.name).ilike(\"%\" + term + \"%\")),\n                func.lower(Books.title).ilike(\"%\" + term + \"%\")\n                ))\n\n    # read search results from calibre-database and return it (function is used for feed and simple search\n    def get_search_results(self, term, offset=None, order=None, limit=None, allow_show_archived=False,\n                           config_read_column=False, *join):\n        order = order[0] if order else [Books.sort]\n        pagination = None\n        result = self.search_query(term, config_read_column, *join).order_by(*order).all()\n        result_count = len(result)\n        if offset != None and limit != None:\n            offset = int(offset)\n            limit_all = offset + int(limit)\n            pagination = Pagination((offset / (int(limit)) + 1), limit, result_count)\n        else:\n            offset = 0\n            limit_all = result_count\n\n        ub.store_combo_ids(result)\n        entries = self.order_authors(result[offset:limit_all], list_return=True, combined=True)\n\n        return entries, result_count, pagination\n\n    # Creates for all stored languages a translated speaking name in the array for the UI\n    def speaking_language(self, languages=None, return_all_languages=False, with_count=False, reverse_order=False):\n        from . import get_locale\n\n        if with_count:\n            if not languages:\n                languages = self.session.query(Languages, func.count('books_languages_link.book'))\\\n                    .join(books_languages_link).join(Books)\\\n                    .filter(self.common_filters(return_all_languages=return_all_languages)) \\\n                    .group_by(text('books_languages_link.lang_code')).all()\n            for lang in languages:\n                lang[0].name = isoLanguages.get_language_name(get_locale(), lang[0].lang_code)\n            return sorted(languages, key=lambda x: x[0].name, reverse=reverse_order)\n        else:\n            if not languages:\n                languages = self.session.query(Languages) \\\n                    .join(books_languages_link) \\\n                    .join(Books) \\\n                    .filter(self.common_filters(return_all_languages=return_all_languages)) \\\n                    .group_by(text('books_languages_link.lang_code')).all()\n            for lang in languages:\n                lang.name = isoLanguages.get_language_name(get_locale(), lang.lang_code)\n            return sorted(languages, key=lambda x: x.name, reverse=reverse_order)\n\n\n    def update_title_sort(self, config, conn=None):\n        # user defined sort function for calibre databases (Series, etc.)\n        def _title_sort(title):\n            # calibre sort stuff\n            title_pat = re.compile(config.config_title_regex, re.IGNORECASE)\n            match = title_pat.search(title)\n            if match:\n                prep = match.group(1)\n                title = title[len(prep):] + ', ' + prep\n            return title.strip()\n\n        conn = conn or self.session.connection().connection.connection\n        conn.create_function(\"title_sort\", 1, _title_sort)\n\n    @classmethod\n    def dispose(cls):\n        # global session\n\n        for inst in cls.instances:\n            old_session = inst.session\n            inst.session = None\n            if old_session:\n                try:\n                    old_session.close()\n                except Exception:\n                    pass\n                if old_session.bind:\n                    try:\n                        old_session.bind.dispose()\n                    except Exception:\n                        pass\n\n        for attr in list(Books.__dict__.keys()):\n            if attr.startswith(\"custom_column_\"):\n                setattr(Books, attr, None)\n\n        for db_class in cc_classes.values():\n            Base.metadata.remove(db_class.__table__)\n        cc_classes.clear()\n\n        for table in reversed(Base.metadata.sorted_tables):\n            name = table.key\n            if name.startswith(\"custom_column_\") or name.startswith(\"books_custom_column_\"):\n                if table is not None:\n                    Base.metadata.remove(table)\n\n    def reconnect_db(self, config, app_db_path):\n        self.dispose()\n        self.engine.dispose()\n        self.setup_db(config.config_calibre_dir, app_db_path)\n        self.update_config(config)\n\n\ndef lcase(s):\n    try:\n        return unidecode.unidecode(s.lower())\n    except Exception as ex:\n        log = logger.create()\n        log.error_or_exception(ex)\n        return s.lower()\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nfrom datetime import datetime\nimport json\nfrom shutil import copyfile\nfrom uuid import uuid4\nfrom markupsafe import escape\nfrom functools import wraps\n\ntry:\n    from lxml.html.clean import clean_html\nexcept ImportError:\n    pass\n\nfrom flask import Blueprint, request, flash, redirect, url_for, abort, Markup, Response\nfrom flask_babel import gettext as _\nfrom flask_login import current_user, login_required\nfrom sqlalchemy.exc import OperationalError, IntegrityError\nfrom sqlite3 import OperationalError as sqliteOperationalError\nfrom . import constants, logger, isoLanguages, gdriveutils, uploader, helper, kobo_sync_status\nfrom . import config, get_locale, ub, db\nfrom . import calibre_db\nfrom .services.worker import WorkerThread\nfrom .tasks.upload import TaskUpload\nfrom .render_template import render_title_template\nfrom .usermanagement import login_required_if_no_ano\nfrom .kobo_sync_status import change_archived_books\n\n\neditbook = Blueprint('editbook', __name__)\nlog = logger.create()\n\n\ndef upload_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_upload():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\ndef edit_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_edit() or current_user.role_admin():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\ndef search_objects_remove(db_book_object, db_type, input_elements):\n    del_elements = []\n    for c_elements in db_book_object:\n        found = False\n        if db_type == 'languages':\n            type_elements = c_elements.lang_code\n        elif db_type == 'custom':\n            type_elements = c_elements.value\n        else:\n            type_elements = c_elements.name\n        for inp_element in input_elements:\n            if inp_element.lower() == type_elements.lower():\n                found = True\n                break\n        # if the element was not found in the new list, add it to remove list\n        if not found:\n            del_elements.append(c_elements)\n    return del_elements\n\n\ndef search_objects_add(db_book_object, db_type, input_elements):\n    add_elements = []\n    for inp_element in input_elements:\n        found = False\n        for c_elements in db_book_object:\n            if db_type == 'languages':\n                type_elements = c_elements.lang_code\n            elif db_type == 'custom':\n                type_elements = c_elements.value\n            else:\n                type_elements = c_elements.name\n            if inp_element == type_elements:\n                found = True\n                break\n        if not found:\n            add_elements.append(inp_element)\n    return add_elements\n\n\ndef remove_objects(db_book_object, db_session, del_elements):\n    changed = False\n    if len(del_elements) > 0:\n        for del_element in del_elements:\n            db_book_object.remove(del_element)\n            changed = True\n            if len(del_element.books) == 0:\n                db_session.delete(del_element)\n    return changed\n\ndef add_objects(db_book_object, db_object, db_session, db_type, add_elements):\n    changed = False\n    if db_type == 'languages':\n        db_filter = db_object.lang_code\n    elif db_type == 'custom':\n        db_filter = db_object.value\n    else:\n        db_filter = db_object.name\n    for add_element in add_elements:\n        # check if a element with that name exists\n        db_element = db_session.query(db_object).filter(db_filter == add_element).first()\n        # if no element is found add it\n        if db_type == 'author':\n            new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")\n        elif db_type == 'series':\n            new_element = db_object(add_element, add_element)\n        elif db_type == 'custom':\n            new_element = db_object(value=add_element)\n        elif db_type == 'publisher':\n            new_element = db_object(add_element, None)\n        else:  # db_type should be tag or language\n            new_element = db_object(add_element)\n        if db_element is None:\n            changed = True\n            db_session.add(new_element)\n            db_book_object.append(new_element)\n        else:\n            db_element = create_objects_for_addition(db_element, add_element, db_type)\n            changed = True\n            # add element to book\n            changed = True\n            db_book_object.append(db_element)\n    return changed\n\n\ndef create_objects_for_addition(db_element, add_element, db_type):\n    if db_type == 'custom':\n        if db_element.value != add_element:\n            db_element.value = add_element\n    elif db_type == 'languages':\n        if db_element.lang_code != add_element:\n            db_element.lang_code = add_element\n    elif db_type == 'series':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = add_element\n    elif db_type == 'author':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = helper.get_sorted_author(add_element.replace('|', ','))\n    elif db_type == 'publisher':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = None\n    elif db_element.name != add_element:\n        db_element.name = add_element\n    return db_element\n\n\n# Modifies different Database objects, first check if elements if elements have to be deleted,\n# because they are no longer used, than check if elements have to be added to database\ndef modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):\n    # passing input_elements not as a list may lead to undesired results\n    if not isinstance(input_elements, list):\n        raise TypeError(str(input_elements) + \" should be passed as a list\")\n    input_elements = [x for x in input_elements if x != '']\n    # we have all input element (authors, series, tags) names now\n    # 1. search for elements to remove\n    del_elements = search_objects_remove(db_book_object, db_type, input_elements)\n    # 2. search for elements that need to be added\n    add_elements = search_objects_add(db_book_object, db_type, input_elements)\n    # if there are elements to remove, we remove them now\n    changed = remove_objects(db_book_object, db_session, del_elements)\n    # if there are elements to add, we add them now!\n    if len(add_elements) > 0:\n        changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)\n    return changed\n\n\ndef modify_identifiers(input_identifiers, db_identifiers, db_session):\n    \"\"\"Modify Identifiers to match input information.\n       input_identifiers is a list of read-to-persist Identifiers objects.\n       db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"\n    changed = False\n    error = False\n    input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])\n    if len(input_identifiers) != len(input_dict):\n        error = True\n    db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers ])\n    # delete db identifiers not present in input or modify them with input val\n    for identifier_type, identifier in db_dict.items():\n        if identifier_type not in input_dict.keys():\n            db_session.delete(identifier)\n            changed = True\n        else:\n            input_identifier = input_dict[identifier_type]\n            identifier.type = input_identifier.type\n            identifier.val = input_identifier.val\n    # add input identifiers not present in db\n    for identifier_type, identifier in input_dict.items():\n        if identifier_type not in db_dict.keys():\n            db_session.add(identifier)\n            changed = True\n    return changed, error\n\n@editbook.route(\"/ajax/delete/<int:book_id>\", methods=[\"POST\"])\n@login_required\ndef delete_book_from_details(book_id):\n    return Response(delete_book_from_table(book_id, \"\", True), mimetype='application/json')\n\n\n@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"}, methods=[\"POST\"])\n@editbook.route(\"/delete/<int:book_id>/<string:book_format>\", methods=[\"POST\"])\n@login_required\ndef delete_book_ajax(book_id, book_format):\n    return delete_book_from_table(book_id, book_format, False)\n\n\ndef delete_whole_book(book_id, book):\n    # delete book from Shelfs, Downloads, Read list\n    ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()\n    ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()\n    ub.delete_download(book_id)\n    ub.session_commit()\n\n    # check if only this book links to:\n    # author, language, series, tags, custom columns\n    modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')\n    modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')\n    modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')\n    modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')\n    modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')\n\n    cc = calibre_db.session.query(db.Custom_Columns). \\\n        filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    for c in cc:\n        cc_string = \"custom_column_\" + str(c.id)\n        if not c.is_multiple:\n            if len(getattr(book, cc_string)) > 0:\n                if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    log.debug('remove ' + str(c.id))\n                    calibre_db.session.delete(del_cc)\n                    calibre_db.session.commit()\n                elif c.datatype == 'rating':\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    if len(del_cc.books) == 0:\n                        log.debug('remove ' + str(c.id))\n                        calibre_db.session.delete(del_cc)\n                        calibre_db.session.commit()\n                else:\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    log.debug('remove ' + str(c.id))\n                    calibre_db.session.delete(del_cc)\n                    calibre_db.session.commit()\n        else:\n            modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],\n                                   calibre_db.session, 'custom')\n    calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()\n\n\ndef render_delete_book_result(book_format, jsonResponse, warning, book_id):\n    if book_format:\n        if jsonResponse:\n            return json.dumps([warning, {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                         \"type\": \"success\",\n                                         \"format\": book_format,\n                                         \"message\": _('Book Format Successfully Deleted')}])\n        else:\n            flash(_('Book Format Successfully Deleted'), category=\"success\")\n            return redirect(url_for('editbook.edit_book', book_id=book_id))\n    else:\n        if jsonResponse:\n            return json.dumps([warning, {\"location\": url_for('web.index'),\n                                         \"type\": \"success\",\n                                         \"format\": book_format,\n                                         \"message\": _('Book Successfully Deleted')}])\n        else:\n            flash(_('Book Successfully Deleted'), category=\"success\")\n            return redirect(url_for('web.index'))\n\n\ndef delete_book_from_table(book_id, book_format, jsonResponse):\n    warning = {}\n    if current_user.role_delete_books():\n        book = calibre_db.get_book(book_id)\n        if book:\n            try:\n                result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())\n                if not result:\n                    if jsonResponse:\n                        return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                           \"type\": \"danger\",\n                                           \"format\": \"\",\n                                           \"message\": error}])\n                    else:\n                        flash(error, category=\"error\")\n                        return redirect(url_for('editbook.edit_book', book_id=book_id))\n                if error:\n                    if jsonResponse:\n                        warning = {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                                \"type\": \"warning\",\n                                                \"format\": \"\",\n                                                \"message\": error}\n                    else:\n                        flash(error, category=\"warning\")\n                if not book_format:\n                    delete_whole_book(book_id, book)\n                else:\n                    calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\\n                        filter(db.Data.format == book_format).delete()\n                    if book_format.upper() in ['KEPUB', 'EPUB', 'EPUB3']:\n                        kobo_sync_status.remove_synced_book(book.id, True)\n                calibre_db.session.commit()\n            except Exception as ex:\n                log.error_or_exception(ex)\n                calibre_db.session.rollback()\n                if jsonResponse:\n                    return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                        \"type\": \"danger\",\n                                        \"format\": \"\",\n                                        \"message\": ex}])\n                else:\n                    flash(str(ex), category=\"error\")\n                    return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n        else:\n            # book not found\n            log.error('Book with id \"%s\" could not be deleted: not found', book_id)\n        return render_delete_book_result(book_format, jsonResponse, warning, book_id)\n    message = _(\"You are missing permissions to delete books\")\n    if jsonResponse:\n        return json.dumps({\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                           \"type\": \"danger\",\n                           \"format\": \"\",\n                           \"message\": message})\n    else:\n        flash(message, category=\"error\")\n        return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n\ndef render_edit_book(book_id):\n    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n    for lang in book.languages:\n        lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)\n\n    book.authors = calibre_db.order_authors([book])\n\n    author_names = []\n    for authr in book.authors:\n        author_names.append(authr.name.replace('|', ','))\n\n    # Option for showing convertbook button\n    valid_source_formats=list()\n    allowed_conversion_formats = list()\n    kepub_possible=None\n    if config.config_converterpath:\n        for file in book.data:\n            if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:\n                valid_source_formats.append(file.format.lower())\n    if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:\n        kepub_possible = True\n        if not config.config_converterpath:\n            valid_source_formats.append('epub')\n\n    # Determine what formats don't already exist\n    if config.config_converterpath:\n        allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]\n        for file in book.data:\n            if file.format.lower() in allowed_conversion_formats:\n                allowed_conversion_formats.remove(file.format.lower())\n    if kepub_possible:\n        allowed_conversion_formats.append('kepub')\n    return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,\n                                 title=_(u\"edit metadata\"), page=\"editbook\",\n                                 conversion_formats=allowed_conversion_formats,\n                                 config=config,\n                                 source_formats=valid_source_formats)\n\n\ndef edit_book_ratings(to_save, book):\n    changed = False\n    if to_save[\"rating\"].strip():\n        old_rating = False\n        if len(book.ratings) > 0:\n            old_rating = book.ratings[0].rating\n        ratingx2 = int(float(to_save[\"rating\"]) * 2)\n        if ratingx2 != old_rating:\n            changed = True\n            is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == ratingx2).first()\n            if is_rating:\n                book.ratings.append(is_rating)\n            else:\n                new_rating = db.Ratings(rating=ratingx2)\n                book.ratings.append(new_rating)\n            if old_rating:\n                book.ratings.remove(book.ratings[0])\n    else:\n        if len(book.ratings) > 0:\n            book.ratings.remove(book.ratings[0])\n            changed = True\n    return changed\n\ndef edit_book_tags(tags, book):\n    input_tags = tags.split(',')\n    input_tags = list(map(lambda it: it.strip(), input_tags))\n    # Remove duplicates\n    input_tags = helper.uniq(input_tags)\n    return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')\n\n\ndef edit_book_series(series, book):\n    input_series = [series.strip()]\n    input_series = [x for x in input_series if x != '']\n    return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')\n\n\ndef edit_book_series_index(series_index, book):\n    # Add default series_index to book\n    modif_date = False\n    series_index = series_index or '1'\n    if not series_index.replace('.', '', 1).isdigit():\n        flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")\n        return False\n    if str(book.series_index) != series_index:\n        book.series_index = series_index\n        modif_date = True\n    return modif_date\n\n\n# Handle book comments/description\ndef edit_book_comments(comments, book):\n    modif_date = False\n    if comments:\n        comments = clean_html(comments)\n    if len(book.comments):\n        if book.comments[0].text != comments:\n            book.comments[0].text = comments\n            modif_date = True\n    else:\n        if comments:\n            book.comments.append(db.Comments(text=comments, book=book.id))\n            modif_date = True\n    return modif_date\n\n\ndef edit_book_languages(languages, book, upload=False, invalid=None):\n    input_languages = languages.split(',')\n    unknown_languages = []\n    if not upload:\n        input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)\n    else:\n        input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)\n    for l in unknown_languages:\n        log.error(\"'%s' is not a valid language\", l)\n        if isinstance(invalid, list):\n            invalid.append(l)\n        else:\n            raise ValueError(_(u\"'%(langname)s' is not a valid language\", langname=l))\n    # ToDo: Not working correct\n    if upload and len(input_l) == 1:\n        # If the language of the file is excluded from the users view, it's not imported, to allow the user to view\n        # the book it's language is set to the filter language\n        if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":\n            input_l[0] = calibre_db.session.query(db.Languages). \\\n                filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code\n    # Remove duplicates\n    input_l = helper.uniq(input_l)\n    return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')\n\n\ndef edit_book_publisher(publishers, book):\n    changed = False\n    if publishers:\n        publisher = publishers.rstrip().strip()\n        if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):\n            changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,\n                                              'publisher')\n    elif len(book.publishers):\n        changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')\n    return changed\n\n\ndef edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):\n    changed = False\n    if to_save[cc_string] == 'None':\n        to_save[cc_string] = None\n    elif c.datatype == 'bool':\n        to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0\n    elif c.datatype == 'comments':\n        to_save[cc_string] = Markup(to_save[cc_string]).unescape()\n        if to_save[cc_string]:\n            to_save[cc_string] = clean_html(to_save[cc_string])\n    elif c.datatype == 'datetime':\n        try:\n            to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")\n        except ValueError:\n            to_save[cc_string] = db.Books.DEFAULT_PUBDATE\n\n    if to_save[cc_string] != cc_db_value:\n        if cc_db_value is not None:\n            if to_save[cc_string] is not None:\n                setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])\n                changed = True\n            else:\n                del_cc = getattr(book, cc_string)[0]\n                getattr(book, cc_string).remove(del_cc)\n                calibre_db.session.delete(del_cc)\n                changed = True\n        else:\n            cc_class = db.cc_classes[c.id]\n            new_cc = cc_class(value=to_save[cc_string], book=book_id)\n            calibre_db.session.add(new_cc)\n            changed = True\n    return changed, to_save\n\n\ndef edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):\n    changed = False\n    if c.datatype == 'rating':\n        to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))\n    if to_save[cc_string].strip() != cc_db_value:\n        if cc_db_value is not None:\n            # remove old cc_val\n            del_cc = getattr(book, cc_string)[0]\n            getattr(book, cc_string).remove(del_cc)\n            if len(del_cc.books) == 0:\n                calibre_db.session.delete(del_cc)\n                changed = True\n        cc_class = db.cc_classes[c.id]\n        new_cc = calibre_db.session.query(cc_class).filter(\n            cc_class.value == to_save[cc_string].strip()).first()\n        # if no cc val is found add it\n        if new_cc is None:\n            new_cc = cc_class(value=to_save[cc_string].strip())\n            calibre_db.session.add(new_cc)\n            changed = True\n            calibre_db.session.flush()\n            new_cc = calibre_db.session.query(cc_class).filter(\n                cc_class.value == to_save[cc_string].strip()).first()\n        # add cc value to book\n        getattr(book, cc_string).append(new_cc)\n    return changed, to_save\n\ndef edit_single_cc_data(book_id, book, column_id, to_save):\n    cc = (calibre_db.session.query(db.Custom_Columns)\n          .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions))\n          .filter(db.Custom_Columns.id == column_id)\n          .all())\n    return edit_cc_data(book_id, book, to_save, cc)\n\ndef edit_all_cc_data(book_id, book, to_save):\n    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    return edit_cc_data(book_id, book, to_save, cc)\n\ndef edit_cc_data(book_id, book, to_save, cc):\n    changed = False\n    for c in cc:\n        cc_string = \"custom_column_\" + str(c.id)\n        if not c.is_multiple:\n            if len(getattr(book, cc_string)) > 0:\n                cc_db_value = getattr(book, cc_string)[0].value\n            else:\n                cc_db_value = None\n            if to_save[cc_string].strip():\n                if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:\n                    changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)\n                else:\n                    changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)\n            else:\n                if cc_db_value is not None:\n                    # remove old cc_val\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    if not del_cc.books or len(del_cc.books) == 0:\n                        calibre_db.session.delete(del_cc)\n                        changed = True\n        else:\n            input_tags = to_save[cc_string].split(',')\n            input_tags = list(map(lambda it: it.strip(), input_tags))\n            changed |= modify_database_object(input_tags,\n                                              getattr(book, cc_string),\n                                              db.cc_classes[c.id],\n                                              calibre_db.session,\n                                              'custom')\n    return changed\n\ndef upload_single_file(request, book, book_id):\n    # Check and handle Uploaded file\n    if 'btn-upload-format' in request.files:\n        requested_file = request.files['btn-upload-format']\n        # check for empty request\n        if requested_file.filename != '':\n            if not current_user.role_upload():\n                abort(403)\n            if '.' in requested_file.filename:\n                file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()\n                if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:\n                    flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),\n                          category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n            else:\n                flash(_('File to be uploaded must have an extension'), category=\"error\")\n                return redirect(url_for('web.show_book', book_id=book.id))\n\n            file_name = book.path.rsplit('/', 1)[-1]\n            filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))\n            saved_filename = os.path.join(filepath, file_name + '.' + file_ext)\n\n            # check if file path exists, otherwise create it, copy file to calibre path and delete temp file\n            if not os.path.exists(filepath):\n                try:\n                    os.makedirs(filepath)\n                except OSError:\n                    flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n            try:\n                requested_file.save(saved_filename)\n            except OSError:\n                flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")\n                return redirect(url_for('web.show_book', book_id=book.id))\n\n            file_size = os.path.getsize(saved_filename)\n            is_format = calibre_db.get_book_format(book_id, file_ext.upper())\n\n            # Format entry already exists, no need to update the database\n            if is_format:\n                log.warning('Book format %s already existing', file_ext.upper())\n            else:\n                try:\n                    db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)\n                    calibre_db.session.add(db_format)\n                    calibre_db.session.commit()\n                    calibre_db.update_title_sort(config)\n                except (OperationalError, IntegrityError) as e:\n                    calibre_db.session.rollback()\n                    log.error_or_exception(\"Database error: {}\".format(e))\n                    flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n\n            # Queue uploader info\n            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))\n            uploadText=_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=link)\n            WorkerThread.add(current_user.name, TaskUpload(uploadText, escape(book.title)))\n\n            return uploader.process(\n                saved_filename, *os.path.splitext(requested_file.filename),\n                rarExecutable=config.config_rarfile_location)\n\n\ndef upload_cover(request, book):\n    if 'btn-upload-cover' in request.files:\n        requested_file = request.files['btn-upload-cover']\n        # check for empty request\n        if requested_file.filename != '':\n            if not current_user.role_upload():\n                abort(403)\n            ret, message = helper.save_cover(requested_file, book.path)\n            if ret is True:\n                return True\n            else:\n                flash(message, category=\"error\")\n                return False\n    return None\n\n\ndef handle_title_on_edit(book, book_title):\n    # handle book title\n    book_title = book_title.rstrip().strip()\n    if book.title != book_title:\n        if book_title == '':\n            book_title = _(u'Unknown')\n        book.title = book_title\n        return True\n    return False\n\n\ndef handle_author_on_edit(book, author_name, update_stored=True):\n    # handle author(s)\n    # renamed = False\n    input_authors = author_name.split('&')\n    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))\n    # Remove duplicates in authors list\n    input_authors = helper.uniq(input_authors)\n    # we have all author names now\n    if input_authors == ['']:\n        input_authors = [_(u'Unknown')]  # prevent empty Author\n\n    renamed = list()\n    for in_aut in input_authors:\n        renamed_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == in_aut).first()\n        if renamed_author and in_aut != renamed_author.name:\n            renamed.append(renamed_author.name)\n            all_books = calibre_db.session.query(db.Books) \\\n                .filter(db.Books.authors.any(db.Authors.name == renamed_author.name)).all()\n            sorted_renamed_author = helper.get_sorted_author(renamed_author.name)\n            sorted_old_author = helper.get_sorted_author(in_aut)\n            for one_book in all_books:\n                one_book.author_sort = one_book.author_sort.replace(sorted_renamed_author, sorted_old_author)\n\n    change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')\n\n    # Search for each author if author is in database, if not, author name and sorted author name is generated new\n    # everything then is assembled for sorted author field in database\n    sort_authors_list = list()\n    for inp in input_authors:\n        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()\n        if not stored_author:\n            stored_author = helper.get_sorted_author(inp)\n        else:\n            stored_author = stored_author.sort\n        sort_authors_list.append(helper.get_sorted_author(stored_author))\n    sort_authors = ' & '.join(sort_authors_list)\n    if book.author_sort != sort_authors and update_stored:\n        book.author_sort = sort_authors\n        change = True\n    return input_authors, change, renamed\n\n\n@editbook.route(\"/admin/book/<int:book_id>\", methods=['GET', 'POST'])\n@login_required_if_no_ano\n@edit_required\ndef edit_book(book_id):\n    modif_date = False\n\n    # create the function for sorting...\n    try:\n        calibre_db.update_title_sort(config)\n    except sqliteOperationalError as e:\n        log.error_or_exception(e)\n        calibre_db.session.rollback()\n\n    # Show form\n    if request.method != 'POST':\n        return render_edit_book(book_id)\n\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n\n    # Book not found\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n    meta = upload_single_file(request, book, book_id)\n    if upload_cover(request, book) is True:\n        book.has_cover = 1\n        modif_date = True\n    try:\n        to_save = request.form.to_dict()\n        merge_metadata(to_save, meta)\n        # Update book\n        edited_books_id = None\n\n        # handle book title\n        title_change = handle_title_on_edit(book, to_save[\"book_title\"])\n\n        input_authors, authorchange, renamed = handle_author_on_edit(book, to_save[\"author_name\"])\n        if authorchange or title_change:\n            edited_books_id = book.id\n            modif_date = True\n\n        if config.config_use_google_drive:\n            gdriveutils.updateGdriveCalibreFromLocal()\n\n        error = False\n        if edited_books_id:\n            error = helper.update_dir_structure(edited_books_id, config.config_calibre_dir, input_authors[0],\n                                               renamed_author=renamed)\n\n        if not error:\n            if \"cover_url\" in to_save:\n                if to_save[\"cover_url\"]:\n                    if not current_user.role_upload():\n                        calibre_db.session.rollback()\n                        return \"\", 403\n                    if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):\n                        book.has_cover = 0\n                    else:\n                        result, error = helper.save_cover_from_url(to_save[\"cover_url\"], book.path)\n                        if result is True:\n                            book.has_cover = 1\n                            modif_date = True\n                        else:\n                            flash(error, category=\"error\")\n\n            # Add default series_index to book\n            modif_date |= edit_book_series_index(to_save[\"series_index\"], book)\n            # Handle book comments/description\n            modif_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)\n            # Handle identifiers\n            input_identifiers = identifier_list(to_save, book)\n            modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)\n            if warning:\n                flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")\n            modif_date |= modification\n            # Handle book tags\n            modif_date |= edit_book_tags(to_save['tags'], book)\n            # Handle book series\n            modif_date |= edit_book_series(to_save[\"series\"], book)\n            # handle book publisher\n            modif_date |= edit_book_publisher(to_save['publisher'], book)\n            # handle book languages\n            modif_date |= edit_book_languages(to_save['languages'], book)\n            # handle book ratings\n            modif_date |= edit_book_ratings(to_save, book)\n            # handle cc data\n            modif_date |= edit_all_cc_data(book_id, book, to_save)\n\n            if to_save[\"pubdate\"]:\n                try:\n                    book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")\n                except ValueError:\n                    book.pubdate = db.Books.DEFAULT_PUBDATE\n            else:\n                book.pubdate = db.Books.DEFAULT_PUBDATE\n\n            if modif_date:\n                book.last_modified = datetime.utcnow()\n                kobo_sync_status.remove_synced_book(edited_books_id, all=True)\n\n            calibre_db.session.merge(book)\n            calibre_db.session.commit()\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n            if \"detail_view\" in to_save:\n                return redirect(url_for('web.show_book', book_id=book.id))\n            else:\n                flash(_(\"Metadata successfully updated\"), category=\"success\")\n                return render_edit_book(book_id)\n        else:\n            calibre_db.session.rollback()\n            flash(error, category=\"error\")\n            return render_edit_book(book_id)\n    except ValueError as e:\n        calibre_db.session.rollback()\n        flash(str(e), category=\"error\")\n        return redirect(url_for('web.show_book', book_id=book.id))\n    except (OperationalError, IntegrityError) as e:\n        log.error_or_exception(\"Database error: {}\".format(e))\n        calibre_db.session.rollback()\n        flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")\n        return redirect(url_for('web.show_book', book_id=book.id))\n    except Exception as ex:\n        log.error_or_exception(ex)\n        calibre_db.session.rollback()\n        flash(_(\"Error editing book, please check logfile for details\"), category=\"error\")\n        return redirect(url_for('web.show_book', book_id=book.id))\n\n\ndef merge_metadata(to_save, meta):\n    if to_save['author_name'] == _(u'Unknown'):\n        to_save['author_name'] = ''\n    if to_save['book_title'] == _(u'Unknown'):\n        to_save['book_title'] = ''\n    for s_field, m_field in [\n            ('tags', 'tags'), ('author_name', 'author'), ('series', 'series'),\n            ('series_index', 'series_id'), ('languages', 'languages'),\n            ('book_title', 'title')]:\n        to_save[s_field] = to_save[s_field] or getattr(meta, m_field, '')\n    to_save[\"description\"] = to_save[\"description\"] or Markup(\n        getattr(meta, 'description', '')).unescape()\n\n\ndef identifier_list(to_save, book):\n    \"\"\"Generate a list of Identifiers from form information\"\"\"\n    id_type_prefix = 'identifier-type-'\n    id_val_prefix = 'identifier-val-'\n    result = []\n    for type_key, type_value in to_save.items():\n        if not type_key.startswith(id_type_prefix):\n            continue\n        val_key = id_val_prefix + type_key[len(id_type_prefix):]\n        if val_key not in to_save.keys():\n            continue\n        result.append(db.Identifiers(to_save[val_key], type_value, book.id))\n    return result\n\n\ndef prepare_authors_on_upload(title, authr):\n    if title != _(u'Unknown') and authr != _(u'Unknown'):\n        entry = calibre_db.check_exists_book(authr, title)\n        if entry:\n            log.info(\"Uploaded book probably exists in library\")\n            flash(_(u\"Uploaded book probably exists in the library, consider to change before upload new: \")\n                  + Markup(render_title_template('book_exists_flash.html', entry=entry)), category=\"warning\")\n\n    # handle authors\n    input_authors = authr.split('&')\n    # handle_authors(input_authors)\n    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))\n    # Remove duplicates in authors list\n    input_authors = helper.uniq(input_authors)\n\n    # we have all author names now\n    if input_authors == ['']:\n        input_authors = [_(u'Unknown')]  # prevent empty Author\n\n    renamed = list()\n    for in_aut in input_authors:\n        renamed_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == in_aut).first()\n        if renamed_author and in_aut != renamed_author.name:\n            renamed.append(renamed_author.name)\n            all_books = calibre_db.session.query(db.Books) \\\n                .filter(db.Books.authors.any(db.Authors.name == renamed_author.name)).all()\n            sorted_renamed_author = helper.get_sorted_author(renamed_author.name)\n            sorted_old_author = helper.get_sorted_author(in_aut)\n            for one_book in all_books:\n                one_book.author_sort = one_book.author_sort.replace(sorted_renamed_author, sorted_old_author)\n\n    sort_authors_list = list()\n    db_author = None\n    for inp in input_authors:\n        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()\n        if not stored_author:\n            if not db_author:\n                db_author = db.Authors(inp, helper.get_sorted_author(inp), \"\")\n                calibre_db.session.add(db_author)\n                calibre_db.session.commit()\n            sort_author = helper.get_sorted_author(inp)\n        else:\n            if not db_author:\n                db_author = stored_author\n            sort_author = stored_author.sort\n        sort_authors_list.append(sort_author)\n    sort_authors = ' & '.join(sort_authors_list)\n    return sort_authors, input_authors, db_author, renamed\n\n\ndef create_book_on_upload(modif_date, meta):\n    title = meta.title\n    authr = meta.author\n    sort_authors, input_authors, db_author, renamed_authors = prepare_authors_on_upload(title, authr)\n\n    title_dir = helper.get_valid_filename(title, chars=96)\n    author_dir = helper.get_valid_filename(db_author.name, chars=96)\n\n    # combine path and normalize path from windows systems\n    path = os.path.join(author_dir, title_dir).replace('\\\\', '/')\n\n    # Calibre adds books with utc as timezone\n    db_book = db.Books(title, \"\", sort_authors, datetime.utcnow(), datetime(101, 1, 1),\n                       '1', datetime.utcnow(), path, meta.cover, db_author, [], \"\")\n\n    modif_date |= modify_database_object(input_authors, db_book.authors, db.Authors, calibre_db.session,\n                                         'author')\n\n    # Add series_index to book\n    modif_date |= edit_book_series_index(meta.series_id, db_book)\n\n    # add languages\n    invalid=[]\n    modif_date |= edit_book_languages(meta.languages, db_book, upload=True, invalid=invalid)\n    if invalid:\n        for l in invalid:\n            flash(_(u\"'%(langname)s' is not a valid language\", langname=l), category=\"warning\")\n\n    # handle tags\n    modif_date |= edit_book_tags(meta.tags, db_book)\n\n    # handle publisher\n    modif_date |= edit_book_publisher(meta.publisher, db_book)\n\n    # handle series\n    modif_date |= edit_book_series(meta.series, db_book)\n\n    # Add file to book\n    file_size = os.path.getsize(meta.file_path)\n    db_data = db.Data(db_book, meta.extension.upper()[1:], file_size, title_dir)\n    db_book.data.append(db_data)\n    calibre_db.session.add(db_book)\n\n    # flush content, get db_book.id available\n    calibre_db.session.flush()\n    return db_book, input_authors, title_dir, renamed_authors\n\ndef file_handling_on_upload(requested_file):\n    # check if file extension is correct\n    if '.' in requested_file.filename:\n        file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()\n        if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:\n            flash(\n                _(\"File extension '%(ext)s' is not allowed to be uploaded to this server\",\n                  ext=file_ext), category=\"error\")\n            return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n    else:\n        flash(_('File to be uploaded must have an extension'), category=\"error\")\n        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n\n    # extract metadata from file\n    try:\n        meta = uploader.upload(requested_file, config.config_rarfile_location)\n    except (IOError, OSError):\n        log.error(\"File %s could not saved to temp dir\", requested_file.filename)\n        flash(_(u\"File %(filename)s could not saved to temp dir\",\n                filename=requested_file.filename), category=\"error\")\n        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n    return meta, None\n\n\ndef move_coverfile(meta, db_book):\n    # move cover to final directory, including book id\n    if meta.cover:\n        coverfile = meta.cover\n    else:\n        coverfile = os.path.join(constants.STATIC_DIR, 'generic_cover.jpg')\n    new_coverpath = os.path.join(config.config_calibre_dir, db_book.path)\n    try:\n        os.makedirs(new_coverpath, exist_ok=True)\n        copyfile(coverfile, os.path.join(new_coverpath, \"cover.jpg\"))\n        if meta.cover:\n            os.unlink(meta.cover)\n    except OSError as e:\n        log.error(\"Failed to move cover file %s: %s\", new_coverpath, e)\n        flash(_(u\"Failed to Move Cover File %(file)s: %(error)s\", file=new_coverpath,\n                error=e),\n              category=\"error\")\n\n\n@editbook.route(\"/upload\", methods=[\"POST\"])\n@login_required_if_no_ano\n@upload_required\ndef upload():\n    if not config.config_uploading:\n        abort(404)\n    if request.method == 'POST' and 'btn-upload' in request.files:\n        for requested_file in request.files.getlist(\"btn-upload\"):\n            try:\n                modif_date = False\n                # create the function for sorting...\n                calibre_db.update_title_sort(config)\n                calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))\n\n                meta, error = file_handling_on_upload(requested_file)\n                if error:\n                    return error\n\n                db_book, input_authors, title_dir, renamed_authors = create_book_on_upload(modif_date, meta)\n\n                # Comments needs book id therefore only possible after flush\n                modif_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)\n\n                book_id = db_book.id\n                title = db_book.title\n                if config.config_use_google_drive:\n                    helper.upload_new_file_gdrive(book_id,\n                                                  input_authors[0],\n                                                  renamed_authors,\n                                                  title,\n                                                  title_dir,\n                                                  meta.file_path,\n                                                  meta.extension.lower())\n                else:\n                    error = helper.update_dir_structure(book_id,\n                                                        config.config_calibre_dir,\n                                                        input_authors[0],\n                                                        meta.file_path,\n                                                        title_dir + meta.extension.lower(),\n                                                        renamed_author=renamed_authors)\n\n                move_coverfile(meta, db_book)\n\n                # save data to database, reread data\n                calibre_db.session.commit()\n\n                if config.config_use_google_drive:\n                    gdriveutils.updateGdriveCalibreFromLocal()\n                if error:\n                    flash(error, category=\"error\")\n                link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(title))\n                uploadText = _(u\"File %(file)s uploaded\", file=link)\n                WorkerThread.add(current_user.name, TaskUpload(uploadText, escape(title)))\n\n                if len(request.files.getlist(\"btn-upload\")) < 2:\n                    if current_user.role_edit() or current_user.role_admin():\n                        resp = {\"location\": url_for('editbook.edit_book', book_id=book_id)}\n                        return Response(json.dumps(resp), mimetype='application/json')\n                    else:\n                        resp = {\"location\": url_for('web.show_book', book_id=book_id)}\n                        return Response(json.dumps(resp), mimetype='application/json')\n            except (OperationalError, IntegrityError) as e:\n                calibre_db.session.rollback()\n                log.error_or_exception(\"Database error: {}\".format(e))\n                flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")\n        return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n\n\n@editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])\n@login_required_if_no_ano\n@edit_required\ndef convert_bookformat(book_id):\n    # check to see if we have form fields to work with -  if not send user back\n    book_format_from = request.form.get('book_format_from', None)\n    book_format_to = request.form.get('book_format_to', None)\n\n    if (book_format_from is None) or (book_format_to is None):\n        flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")\n        return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n    log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)\n    rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),\n                                     book_format_to.upper(), current_user.name)\n\n    if rtn is None:\n        flash(_(u\"Book successfully queued for converting to %(book_format)s\",\n                    book_format=book_format_to),\n                    category=\"success\")\n    else:\n        flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")\n    return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n@editbook.route(\"/ajax/getcustomenum/<int:c_id>\")\n@login_required\ndef table_get_custom_enum(c_id):\n    ret = list()\n    cc = (calibre_db.session.query(db.Custom_Columns)\n              .filter(db.Custom_Columns.id == c_id)\n              .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).one_or_none())\n    ret.append({'value': \"\", 'text': \"\"})\n    for idx, en in enumerate(cc.get_display_dict()['enum_values']):\n        ret.append({'value': en, 'text': en})\n    return json.dumps(ret)\n\n\n@editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])\n@login_required_if_no_ano\n@edit_required\ndef edit_list_book(param):\n    vals = request.form.to_dict()\n    book = calibre_db.get_book(vals['pk'])\n    # ret = \"\"\n    try:\n        if param == 'series_index':\n            edit_book_series_index(vals['value'], book)\n            ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')\n        elif param == 'tags':\n            edit_book_tags(vals['value'], book)\n            ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),\n                           mimetype='application/json')\n        elif param == 'series':\n            edit_book_series(vals['value'], book)\n            ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),\n                           mimetype='application/json')\n        elif param == 'publishers':\n            edit_book_publisher(vals['value'], book)\n            ret = Response(json.dumps({'success': True,\n                                        'newValue': ', '.join([publisher.name for publisher in book.publishers])}),\n                           mimetype='application/json')\n        elif param == 'languages':\n            invalid = list()\n            edit_book_languages(vals['value'], book, invalid=invalid)\n            if invalid:\n                ret = Response(json.dumps({'success': False,\n                                           'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),\n                               mimetype='application/json')\n            else:\n                lang_names = list()\n                for lang in book.languages:\n                    lang_names.append(isoLanguages.get_language_name(get_locale(), lang.lang_code))\n                ret = Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),\n                                mimetype='application/json')\n        elif param == 'author_sort':\n            book.author_sort = vals['value']\n            ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),\n                           mimetype='application/json')\n        elif param == 'title':\n            sort = book.sort\n            handle_title_on_edit(book, vals.get('value', \"\"))\n            helper.update_dir_structure(book.id, config.config_calibre_dir)\n            ret = Response(json.dumps({'success': True, 'newValue':  book.title}),\n                           mimetype='application/json')\n        elif param == 'sort':\n            book.sort = vals['value']\n            ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),\n                           mimetype='application/json')\n        elif param == 'comments':\n            edit_book_comments(vals['value'], book)\n            ret = Response(json.dumps({'success': True, 'newValue':  book.comments[0].text}),\n                           mimetype='application/json')\n        elif param == 'authors':\n            input_authors, __, renamed = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")\n            helper.update_dir_structure(book.id, config.config_calibre_dir, input_authors[0], renamed_author=renamed)\n            ret = Response(json.dumps({'success': True,\n                                       'newValue':  ' & '.join([author.replace('|',',') for author in input_authors])}),\n                           mimetype='application/json')\n        elif param == 'is_archived':\n            is_archived = change_archived_books(book.id, vals['value'] == \"True\",\n                                                message=\"Book {} archivebit set to: {}\".format(book.id, vals['value']))\n            if is_archived:\n                kobo_sync_status.remove_synced_book(book.id)\n            return \"\"\n        elif param == 'read_status':\n            ret = helper.edit_book_read_status(book.id, vals['value'] == \"True\")\n            if ret:\n                return ret, 400\n        elif param.startswith(\"custom_column_\"):\n            new_val = dict()\n            new_val[param] = vals['value']\n            edit_single_cc_data(book.id, book, param[14:], new_val)\n            # ToDo: Very hacky find better solution\n            if vals['value'] in [\"True\", \"False\"]:\n                ret = \"\"\n            else:\n                ret = Response(json.dumps({'success': True, 'newValue': vals['value']}),\n                               mimetype='application/json')\n        else:\n            return _(\"Parameter not found\"), 400\n        book.last_modified = datetime.utcnow()\n\n        calibre_db.session.commit()\n        # revert change for sort if automatic fields link is deactivated\n        if param == 'title' and vals.get('checkT') == \"false\":\n            book.sort = sort\n            calibre_db.session.commit()\n    except (OperationalError, IntegrityError) as e:\n        calibre_db.session.rollback()\n        log.error_or_exception(\"Database error: {}\".format(e))\n        ret = Response(json.dumps({'success': False,\n                                   'msg': 'Database error: {}'.format(e.orig)}),\n                       mimetype='application/json')\n    return ret\n\n\n@editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")\n@login_required\ndef get_sorted_entry(field, bookid):\n    if field in ['title', 'authors', 'sort', 'author_sort']:\n        book = calibre_db.get_filtered_book(bookid)\n        if book:\n            if field == 'title':\n                return json.dumps({'sort': book.sort})\n            elif field == 'authors':\n                return json.dumps({'author_sort': book.author_sort})\n            if field == 'sort':\n                return json.dumps({'sort': book.title})\n            if field == 'author_sort':\n                return json.dumps({'author_sort': book.author})\n    return \"\"\n\n\n@editbook.route(\"/ajax/simulatemerge\", methods=['POST'])\n@login_required\n@edit_required\ndef simulate_merge_list_book():\n    vals = request.get_json().get('Merge_books')\n    if vals:\n        to_book = calibre_db.get_book(vals[0]).title\n        vals.pop(0)\n        if to_book:\n            from_book = []\n            for book_id in vals:\n                from_book.append(calibre_db.get_book(book_id).title)\n            return json.dumps({'to': to_book, 'from': from_book})\n    return \"\"\n\n\n@editbook.route(\"/ajax/mergebooks\", methods=['POST'])\n@login_required\n@edit_required\ndef merge_list_book():\n    vals = request.get_json().get('Merge_books')\n    to_file = list()\n    if vals:\n        # load all formats from target book\n        to_book = calibre_db.get_book(vals[0])\n        vals.pop(0)\n        if to_book:\n            for file in to_book.data:\n                to_file.append(file.format)\n            to_name = helper.get_valid_filename(to_book.title, chars=96) + ' - ' + \\\n                      helper.get_valid_filename(to_book.authors[0].name, chars=96)\n            for book_id in vals:\n                from_book = calibre_db.get_book(book_id)\n                if from_book:\n                    for element in from_book.data:\n                        if element.format not in to_file:\n                            # create new data entry with: book_id, book_format, uncompressed_size, name\n                            filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,\n                                                                         to_book.path,\n                                                                         to_name + \".\" + element.format.lower()))\n                            filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,\n                                                                         from_book.path,\n                                                                         element.name + \".\" + element.format.lower()))\n                            copyfile(filepath_old, filepath_new)\n                            to_book.data.append(db.Data(to_book.id,\n                                                        element.format,\n                                                        element.uncompressed_size,\n                                                        to_name))\n                    delete_book_from_table(from_book.id,\"\", True)\n                    return json.dumps({'success': True})\n    return \"\"\n\n\n@editbook.route(\"/ajax/xchange\", methods=['POST'])\n@login_required\n@edit_required\ndef table_xchange_author_title():\n    vals = request.get_json().get('xchange')\n    if vals:\n        for val in vals:\n            modif_date = False\n            book = calibre_db.get_book(val)\n            authors = book.title\n            book.authors = calibre_db.order_authors([book])\n            author_names = []\n            for authr in book.authors:\n                author_names.append(authr.name.replace('|', ','))\n\n            title_change = handle_title_on_edit(book, \" \".join(author_names))\n            input_authors, authorchange, renamed = handle_author_on_edit(book, authors)\n            if authorchange or title_change:\n                edited_books_id = book.id\n                modif_date = True\n\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n\n            if edited_books_id:\n                helper.update_dir_structure(edited_books_id, config.config_calibre_dir, input_authors[0],\n                                           renamed_author=renamed)\n            if modif_date:\n                book.last_modified = datetime.utcnow()\n            try:\n                calibre_db.session.commit()\n            except (OperationalError, IntegrityError) as e:\n                calibre_db.session.rollback()\n                log.error_or_exception(\"Database error: %s\", e)\n                return json.dumps({'success': False})\n\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n        return json.dumps({'success': True})\n    return \"\"\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018 lemmsh, Kennyl, Kyosfonica, matthazinski\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport zipfile\nfrom lxml import etree\n\nfrom . import isoLanguages, cover\nfrom .helper import split_authors\nfrom .constants import BookMeta\n\n\ndef _extract_cover(zip_file, cover_file, cover_path, tmp_file_name):\n    if cover_file is None:\n        return None\n    else:\n        cf = extension = None\n        zip_cover_path = os.path.join(cover_path, cover_file).replace('\\\\', '/')\n\n        prefix = os.path.splitext(tmp_file_name)[0]\n        tmp_cover_name = prefix + '.' + os.path.basename(zip_cover_path)\n        ext = os.path.splitext(tmp_cover_name)\n        if len(ext) > 1:\n            extension = ext[1].lower()\n        if extension in cover.COVER_EXTENSIONS:\n            cf = zip_file.read(zip_cover_path)\n        return cover.cover_processing(tmp_file_name, cf, extension)\n\n\ndef get_epub_info(tmp_file_path, original_file_name, original_file_extension):\n    ns = {\n        'n': 'urn:oasis:names:tc:opendocument:xmlns:container',\n        'pkg': 'http://www.idpf.org/2007/opf',\n        'dc': 'http://purl.org/dc/elements/1.1/'\n    }\n\n    epub_zip = zipfile.ZipFile(tmp_file_path)\n\n    txt = epub_zip.read('META-INF/container.xml')\n    tree = etree.fromstring(txt)\n    cfname = tree.xpath('n:rootfiles/n:rootfile/@full-path', namespaces=ns)[0]\n    cf = epub_zip.read(cfname)\n    tree = etree.fromstring(cf)\n\n    coverpath = os.path.dirname(cfname)\n\n    p = tree.xpath('/pkg:package/pkg:metadata', namespaces=ns)[0]\n\n    epub_metadata = {}\n\n    for s in ['title', 'description', 'creator', 'language', 'subject']:\n        tmp = p.xpath('dc:%s/text()' % s, namespaces=ns)\n        if len(tmp) > 0:\n            if s == 'creator':\n                epub_metadata[s] = ' & '.join(split_authors(tmp))\n            elif s == 'subject':\n                epub_metadata[s] = ', '.join(tmp)\n            else:\n                epub_metadata[s] = tmp[0]\n        else:\n            epub_metadata[s] = 'Unknown'\n\n    if epub_metadata['subject'] == 'Unknown':\n        epub_metadata['subject'] = ''\n\n    if epub_metadata['description'] == u'Unknown':\n        description = tree.xpath(\"//*[local-name() = 'description']/text()\")\n        if len(description) > 0:\n            epub_metadata['description'] = description\n        else:\n            epub_metadata['description'] = \"\"\n\n    lang = epub_metadata['language'].split('-', 1)[0].lower()\n    epub_metadata['language'] = isoLanguages.get_lang3(lang)\n\n    epub_metadata = parse_epub_series(ns, tree, epub_metadata)\n\n    cover_file = parse_epub_cover(ns, tree, epub_zip, coverpath, tmp_file_path)\n\n    if not epub_metadata['title']:\n        title = original_file_name\n    else:\n        title = epub_metadata['title']\n\n    return BookMeta(\n        file_path=tmp_file_path,\n        extension=original_file_extension,\n        title=title.encode('utf-8').decode('utf-8'),\n        author=epub_metadata['creator'].encode('utf-8').decode('utf-8'),\n        cover=cover_file,\n        description=epub_metadata['description'],\n        tags=epub_metadata['subject'].encode('utf-8').decode('utf-8'),\n        series=epub_metadata['series'].encode('utf-8').decode('utf-8'),\n        series_id=epub_metadata['series_id'].encode('utf-8').decode('utf-8'),\n        languages=epub_metadata['language'],\n        publisher=\"\")\n\n\ndef parse_epub_cover(ns, tree, epub_zip, cover_path, tmp_file_path):\n    cover_section = tree.xpath(\"/pkg:package/pkg:manifest/pkg:item[@id='cover-image']/@href\", namespaces=ns)\n    cover_file = None\n    if len(cover_section) > 0:\n        cover_file = _extract_cover(epub_zip, cover_section[0], cover_path, tmp_file_path)\n    else:\n        meta_cover = tree.xpath(\"/pkg:package/pkg:metadata/pkg:meta[@name='cover']/@content\", namespaces=ns)\n        if len(meta_cover) > 0:\n            cover_section = tree.xpath(\n                \"/pkg:package/pkg:manifest/pkg:item[@id='\"+meta_cover[0]+\"']/@href\", namespaces=ns)\n            if not cover_section:\n                cover_section = tree.xpath(\n                    \"/pkg:package/pkg:manifest/pkg:item[@properties='\" + meta_cover[0] + \"']/@href\", namespaces=ns)\n        else:\n            cover_section = tree.xpath(\"/pkg:package/pkg:guide/pkg:reference/@href\", namespaces=ns)\n        for cs in cover_section:\n            filetype = cs.rsplit('.', 1)[-1]\n            if filetype == \"xhtml\" or filetype == \"html\":  # if cover is (x)html format\n                markup = epub_zip.read(os.path.join(cover_path, cs))\n                markup_tree = etree.fromstring(markup)\n                # no matter xhtml or html with no namespace\n                img_src = markup_tree.xpath(\"//*[local-name() = 'img']/@src\")\n                # Alternative image source\n                if not len(img_src):\n                    img_src = markup_tree.xpath(\"//attribute::*[contains(local-name(), 'href')]\")\n                if len(img_src):\n                    # img_src maybe start with \"../\"\" so fullpath join then relpath to cwd\n                    filename = os.path.relpath(os.path.join(os.path.dirname(os.path.join(cover_path, cover_section[0])),\n                                                            img_src[0]))\n                    cover_file = _extract_cover(epub_zip, filename, \"\", tmp_file_path)\n            else:\n                cover_file = _extract_cover(epub_zip, cs, cover_path, tmp_file_path)\n            if cover_file:\n                break\n    return cover_file\n\n\ndef parse_epub_series(ns, tree, epub_metadata):\n    series = tree.xpath(\"/pkg:package/pkg:metadata/pkg:meta[@name='calibre:series']/@content\", namespaces=ns)\n    if len(series) > 0:\n        epub_metadata['series'] = series[0]\n    else:\n        epub_metadata['series'] = ''\n\n    series_id = tree.xpath(\"/pkg:package/pkg:metadata/pkg:meta[@name='calibre:series_index']/@content\", namespaces=ns)\n    if len(series_id) > 0:\n        epub_metadata['series_id'] = series_id[0]\n    else:\n        epub_metadata['series_id'] = '1'\n    return epub_metadata\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2012-2019 cervinko, idalin, SiphonSquirrel, ouzklcn, akushsky,\n#                            OzzieIsaacs, bodybybuddha, jkrehm, matthazinski, janeczku\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport io\nimport mimetypes\nimport re\nimport shutil\nimport socket\nimport unicodedata\nfrom datetime import datetime, timedelta\nfrom tempfile import gettempdir\nfrom urllib.parse import urlparse\nimport requests\n\nfrom babel.dates import format_datetime\nfrom babel.units import format_unit\nfrom flask import send_from_directory, make_response, redirect, abort, url_for\nfrom flask_babel import gettext as _\nfrom flask_login import current_user\nfrom sqlalchemy.sql.expression import true, false, and_, text, func\nfrom sqlalchemy.exc import InvalidRequestError, OperationalError\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import generate_password_hash\nfrom markupsafe import escape\nfrom urllib.parse import quote\n\ntry:\n    import unidecode\n    use_unidecode = True\nexcept ImportError:\n    use_unidecode = False\n\nfrom . import calibre_db, cli\nfrom .tasks.convert import TaskConvert\nfrom . import logger, config, get_locale, db, ub, kobo_sync_status\nfrom . import gdriveutils as gd\nfrom .constants import STATIC_DIR as _STATIC_DIR\nfrom .subproc_wrapper import process_wait\nfrom .services.worker import WorkerThread, STAT_WAITING, STAT_FAIL, STAT_STARTED, STAT_FINISH_SUCCESS\nfrom .tasks.mail import TaskEmail\n\nlog = logger.create()\n\ntry:\n    from wand.image import Image\n    from wand.exceptions import MissingDelegateError, BlobError\n    use_IM = True\nexcept (ImportError, RuntimeError) as e:\n    log.debug('Cannot import Image, generating covers from non jpg files will not work: %s', e)\n    use_IM = False\n    MissingDelegateError = BaseException\n\n\n# Convert existing book entry to new format\ndef convert_book_format(book_id, calibrepath, old_book_format, new_book_format, user_id, kindle_mail=None):\n    book = calibre_db.get_book(book_id)\n    data = calibre_db.get_book_format(book.id, old_book_format)\n    file_path = os.path.join(calibrepath, book.path, data.name)\n    if not data:\n        error_message = _(u\"%(format)s format not found for book id: %(book)d\", format=old_book_format, book=book_id)\n        log.error(\"convert_book_format: %s\", error_message)\n        return error_message\n    if config.config_use_google_drive:\n        if not gd.getFileFromEbooksFolder(book.path, data.name + \".\" + old_book_format.lower()):\n            error_message = _(u\"%(format)s not found on Google Drive: %(fn)s\",\n                              format=old_book_format, fn=data.name + \".\" + old_book_format.lower())\n            return error_message\n    else:\n        if not os.path.exists(file_path + \".\" + old_book_format.lower()):\n            error_message = _(u\"%(format)s not found: %(fn)s\",\n                              format=old_book_format, fn=data.name + \".\" + old_book_format.lower())\n            return error_message\n    # read settings and append converter task to queue\n    if kindle_mail:\n        settings = config.get_mail_settings()\n        settings['subject'] = _('Send to Kindle')  # pretranslate Subject for e-mail\n        settings['body'] = _(u'This e-mail has been sent via Calibre-Web.')\n    else:\n        settings = dict()\n    link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))  # prevent xss\n    txt = u\"{} -> {}: {}\".format(\n           old_book_format.upper(),\n           new_book_format.upper(),\n           link)\n    settings['old_book_format'] = old_book_format\n    settings['new_book_format'] = new_book_format\n    WorkerThread.add(user_id, TaskConvert(file_path, book.id, txt, settings, kindle_mail, user_id))\n    return None\n\n\ndef send_test_mail(kindle_mail, user_name):\n    WorkerThread.add(user_name, TaskEmail(_(u'Calibre-Web test e-mail'), None, None,\n                     config.get_mail_settings(), kindle_mail, _(u\"Test e-mail\"),\n                                          _(u'This e-mail has been sent via Calibre-Web.')))\n    return\n\n\n# Send registration email or password reset email, depending on parameter resend (False means welcome email)\ndef send_registration_mail(e_mail, user_name, default_password, resend=False):\n    txt = \"Hello %s!\\r\\n\" % user_name\n    if not resend:\n        txt += \"Your new account at Calibre-Web has been created. Thanks for joining us!\\r\\n\"\n    txt += \"Please log in to your account using the following informations:\\r\\n\"\n    txt += \"User name: %s\\r\\n\" % user_name\n    txt += \"Password: %s\\r\\n\" % default_password\n    txt += \"Don't forget to change your password after first login.\\r\\n\"\n    txt += \"Sincerely\\r\\n\\r\\n\"\n    txt += \"Your Calibre-Web team\"\n    WorkerThread.add(None, TaskEmail(\n        subject=_(u'Get Started with Calibre-Web'),\n        filepath=None,\n        attachment=None,\n        settings=config.get_mail_settings(),\n        recipient=e_mail,\n        taskMessage=_(u\"Registration e-mail for user: %(name)s\", name=user_name),\n        text=txt\n    ))\n    return\n\n\ndef check_send_to_kindle_with_converter(formats):\n    bookformats = list()\n    if 'EPUB' in formats and 'MOBI' not in formats:\n        bookformats.append({'format': 'Mobi',\n                            'convert': 1,\n                            'text': _('Convert %(orig)s to %(format)s and send to Kindle',\n                                      orig='Epub',\n                                      format='Mobi')})\n    if 'AZW3' in formats and not 'MOBI' in formats:\n        bookformats.append({'format': 'Mobi',\n                            'convert': 2,\n                            'text': _('Convert %(orig)s to %(format)s and send to Kindle',\n                                      orig='Azw3',\n                                      format='Mobi')})\n    return bookformats\n\n\ndef check_send_to_kindle(entry):\n    \"\"\"\n        returns all available book formats for sending to Kindle\n    \"\"\"\n    formats = list()\n    bookformats = list()\n    if len(entry.data):\n        for ele in iter(entry.data):\n            if ele.uncompressed_size < config.mail_size:\n                formats.append(ele.format)\n        if 'MOBI' in formats:\n            bookformats.append({'format': 'Mobi',\n                                'convert': 0,\n                                'text': _('Send %(format)s to Kindle', format='Mobi')})\n        if 'PDF' in formats:\n            bookformats.append({'format': 'Pdf',\n                                'convert': 0,\n                                'text': _('Send %(format)s to Kindle', format='Pdf')})\n        if 'AZW' in formats:\n            bookformats.append({'format': 'Azw',\n                                'convert': 0,\n                                'text': _('Send %(format)s to Kindle', format='Azw')})\n        if config.config_converterpath:\n            bookformats.extend(check_send_to_kindle_with_converter(formats))\n        return bookformats\n    else:\n        log.error(u'Cannot find book entry %d', entry.id)\n        return None\n\n\n# Check if a reader is existing for any of the book formats, if not, return empty list, otherwise return\n# list with supported formats\ndef check_read_formats(entry):\n    EXTENSIONS_READER = {'TXT', 'PDF', 'EPUB', 'CBZ', 'CBT', 'CBR', 'DJVU'}\n    bookformats = list()\n    if len(entry.data):\n        for ele in iter(entry.data):\n            if ele.format.upper() in EXTENSIONS_READER:\n                bookformats.append(ele.format.lower())\n    return bookformats\n\n\n# Files are processed in the following order/priority:\n# 1: If Mobi file is existing, it's directly send to kindle email,\n# 2: If Epub file is existing, it's converted and send to kindle email,\n# 3: If Pdf file is existing, it's directly send to kindle email\ndef send_mail(book_id, book_format, convert, kindle_mail, calibrepath, user_id):\n    \"\"\"Send email with attachments\"\"\"\n    book = calibre_db.get_book(book_id)\n\n    if convert == 1:\n        # returns None if success, otherwise errormessage\n        return convert_book_format(book_id, calibrepath, u'epub', book_format.lower(), user_id, kindle_mail)\n    if convert == 2:\n        # returns None if success, otherwise errormessage\n        return convert_book_format(book_id, calibrepath, u'azw3', book_format.lower(), user_id, kindle_mail)\n\n    for entry in iter(book.data):\n        if entry.format.upper() == book_format.upper():\n            converted_file_name = entry.name + '.' + book_format.lower()\n            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(book.title))\n            EmailText = _(u\"%(book)s send to Kindle\", book=link)\n            WorkerThread.add(user_id, TaskEmail(_(u\"Send to Kindle\"), book.path, converted_file_name,\n                             config.get_mail_settings(), kindle_mail,\n                             EmailText, _(u'This e-mail has been sent via Calibre-Web.')))\n            return\n    return _(u\"The requested file could not be read. Maybe wrong permissions?\")\n\n\ndef get_valid_filename(value, replace_whitespace=True, chars=128):\n    \"\"\"\n    Returns the given string converted to a string that can be used for a clean\n    filename. Limits num characters to 128 max.\n    \"\"\"\n    if value[-1:] == u'.':\n        value = value[:-1]+u'_'\n    value = value.replace(\"/\", \"_\").replace(\":\", \"_\").strip('\\0')\n    if use_unidecode:\n        if config.config_unicode_filename:\n            value = (unidecode.unidecode(value))\n    else:\n        value = value.replace(u'\u00a7', u'SS')\n        value = value.replace(u'\u00df', u'ss')\n        value = unicodedata.normalize('NFKD', value)\n        re_slugify = re.compile(r'[\\W\\s-]', re.UNICODE)\n        value = re_slugify.sub('', value)\n    if replace_whitespace:\n        #  *+:\\\"/<>? are replaced by _\n        value = re.sub(r'[*+:\\\\\\\"/<>?]+', u'_', value, flags=re.U)\n        # pipe has to be replaced with comma\n        value = re.sub(r'[|]+', u',', value, flags=re.U)\n    value = value[:chars].strip()\n    if not value:\n        raise ValueError(\"Filename cannot be empty\")\n    return value\n\n\ndef split_authors(values):\n    authors_list = []\n    for value in values:\n        authors = re.split('[&;]', value)\n        for author in authors:\n            commas = author.count(',')\n            if commas == 1:\n                author_split = author.split(',')\n                authors_list.append(author_split[1].strip() + ' ' + author_split[0].strip())\n            elif commas > 1:\n                authors_list.extend([x.strip() for x in author.split(',')])\n            else:\n                authors_list.append(author.strip())\n    return authors_list\n\n\ndef get_sorted_author(value):\n    try:\n        if ',' not in value:\n            regexes = [r\"^(JR|SR)\\.?$\", r\"^I{1,3}\\.?$\", r\"^IV\\.?$\"]\n            combined = \"(\" + \")|(\".join(regexes) + \")\"\n            value = value.split(\" \")\n            if re.match(combined, value[-1].upper()):\n                if len(value) > 1:\n                    value2 = value[-2] + \", \" + \" \".join(value[:-2]) + \" \" + value[-1]\n                else:\n                    value2 = value[0]\n            elif len(value) == 1:\n                value2 = value[0]\n            else:\n                value2 = value[-1] + \", \" + \" \".join(value[:-1])\n        else:\n            value2 = value\n    except Exception as ex:\n        log.error(\"Sorting author %s failed: %s\", value, ex)\n        if isinstance(list, value2):\n            value2 = value[0]\n        else:\n            value2 = value\n    return value2\n\ndef edit_book_read_status(book_id, read_status=None):\n    if not config.config_read_column:\n        book = ub.session.query(ub.ReadBook).filter(and_(ub.ReadBook.user_id == int(current_user.id),\n                                                         ub.ReadBook.book_id == book_id)).first()\n        if book:\n            if read_status is None:\n                if book.read_status == ub.ReadBook.STATUS_FINISHED:\n                    book.read_status = ub.ReadBook.STATUS_UNREAD\n                else:\n                    book.read_status = ub.ReadBook.STATUS_FINISHED\n            else:\n                book.read_status = ub.ReadBook.STATUS_FINISHED if read_status else ub.ReadBook.STATUS_UNREAD\n        else:\n            readBook = ub.ReadBook(user_id=current_user.id, book_id = book_id)\n            readBook.read_status = ub.ReadBook.STATUS_FINISHED\n            book = readBook\n        if not book.kobo_reading_state:\n            kobo_reading_state = ub.KoboReadingState(user_id=current_user.id, book_id=book_id)\n            kobo_reading_state.current_bookmark = ub.KoboBookmark()\n            kobo_reading_state.statistics = ub.KoboStatistics()\n            book.kobo_reading_state = kobo_reading_state\n        ub.session.merge(book)\n        ub.session_commit(\"Book {} readbit toggled\".format(book_id))\n    else:\n        try:\n            calibre_db.update_title_sort(config)\n            book = calibre_db.get_filtered_book(book_id)\n            read_status = getattr(book, 'custom_column_' + str(config.config_read_column))\n            if len(read_status):\n                if read_status is None:\n                    read_status[0].value = not read_status[0].value\n                else:\n                    read_status[0].value = read_status is True\n                calibre_db.session.commit()\n            else:\n                cc_class = db.cc_classes[config.config_read_column]\n                new_cc = cc_class(value=read_status or 1, book=book_id)\n                calibre_db.session.add(new_cc)\n                calibre_db.session.commit()\n        except (KeyError, AttributeError):\n            log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n            return \"Custom Column No.{} is not existing in calibre database\".format(config.config_read_column)\n        except (OperationalError, InvalidRequestError) as e:\n            calibre_db.session.rollback()\n            log.error(u\"Read status could not set: {}\".format(e))\n            return _(\"Read status could not set: {}\".format(e.orig))\n    return \"\"\n\n# Deletes a book fro the local filestorage, returns True if deleting is successfull, otherwise false\ndef delete_book_file(book, calibrepath, book_format=None):\n    # check that path is 2 elements deep, check that target path has no subfolders\n    if book.path.count('/') == 1:\n        path = os.path.join(calibrepath, book.path)\n        if book_format:\n            for file in os.listdir(path):\n                if file.upper().endswith(\".\"+book_format):\n                    os.remove(os.path.join(path, file))\n            return True, None\n        else:\n            if os.path.isdir(path):\n                try:\n                    for root, folders, files in os.walk(path):\n                        for f in files:\n                            os.unlink(os.path.join(root, f))\n                        if len(folders):\n                            log.warning(\"Deleting book {} failed, path {} has subfolders: {}\".format(book.id,\n                                        book.path, folders))\n                            return True, _(\"Deleting bookfolder for book %(id)s failed, path has subfolders: %(path)s\",\n                                           id=book.id,\n                                           path=book.path)\n                    shutil.rmtree(path)\n                except (IOError, OSError) as e:\n                    log.error(\"Deleting book %s failed: %s\", book.id, e)\n                    return False, _(\"Deleting book %(id)s failed: %(message)s\", id=book.id, message=e)\n                authorpath = os.path.join(calibrepath, os.path.split(book.path)[0])\n                if not os.listdir(authorpath):\n                    try:\n                        shutil.rmtree(authorpath)\n                    except (IOError, OSError) as e:\n                        log.error(\"Deleting authorpath for book %s failed: %s\", book.id, e)\n                return True, None\n\n    log.error(\"Deleting book %s from database only, book path in database not valid: %s\",\n              book.id, book.path)\n    return True, _(\"Deleting book %(id)s from database only, book path in database not valid: %(path)s\",\n                   id=book.id,\n                   path=book.path)\n\n\ndef clean_author_database(renamed_author, calibre_path=\"\", local_book=None, gdrive=None):\n    valid_filename_authors = [get_valid_filename(r, chars=96) for r in renamed_author]\n    for r in renamed_author:\n        if local_book:\n            all_books = [local_book]\n        else:\n            all_books = calibre_db.session.query(db.Books) \\\n                .filter(db.Books.authors.any(db.Authors.name == r)).all()\n        for book in all_books:\n            book_author_path = book.path.split('/')[0]\n            if book_author_path in valid_filename_authors or local_book:\n                new_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == r).first()\n                all_new_authordir = get_valid_filename(new_author.name, chars=96)\n                all_titledir = book.path.split('/')[1]\n                all_new_path = os.path.join(calibre_path, all_new_authordir, all_titledir)\n                all_new_name = get_valid_filename(book.title, chars=42) + ' - ' \\\n                               + get_valid_filename(new_author.name, chars=42)\n                # change location in database to new author/title path\n                book.path = os.path.join(all_new_authordir, all_titledir).replace('\\\\', '/')\n                for file_format in book.data:\n                    if not gdrive:\n                        shutil.move(os.path.normcase(os.path.join(all_new_path,\n                                                                  file_format.name + '.' + file_format.format.lower())),\n                            os.path.normcase(os.path.join(all_new_path,\n                                                          all_new_name + '.' + file_format.format.lower())))\n                    else:\n                        gFile = gd.getFileFromEbooksFolder(all_new_path,\n                                                           file_format.name + '.' + file_format.format.lower())\n                        if gFile:\n                            gd.moveGdriveFileRemote(gFile, all_new_name + u'.' + file_format.format.lower())\n                            gd.updateDatabaseOnEdit(gFile['id'], all_new_name + u'.' + file_format.format.lower())\n                        else:\n                            log.error(\"File {} not found on gdrive\"\n                                      .format(all_new_path, file_format.name + '.' + file_format.format.lower()))\n                    file_format.name = all_new_name\n\n\ndef rename_all_authors(first_author, renamed_author, calibre_path=\"\", localbook=None, gdrive=False):\n    # Create new_author_dir from parameter or from database\n    # Create new title_dir from database and add id\n    if first_author:\n        new_authordir = get_valid_filename(first_author, chars=96)\n        for r in renamed_author:\n            new_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == r).first()\n            old_author_dir = get_valid_filename(r, chars=96)\n            new_author_rename_dir = get_valid_filename(new_author.name, chars=96)\n            if gdrive:\n                gFile = gd.getFileFromEbooksFolder(None, old_author_dir)\n                if gFile:\n                    gd.moveGdriveFolderRemote(gFile, new_author_rename_dir)\n            else:\n                if os.path.isdir(os.path.join(calibre_path, old_author_dir)):\n                    try:\n                        old_author_path = os.path.join(calibre_path, old_author_dir)\n                        new_author_path = os.path.join(calibre_path, new_author_rename_dir)\n                        shutil.move(os.path.normcase(old_author_path), os.path.normcase(new_author_path))\n                    except (OSError) as ex:\n                        log.error(\"Rename author from: %s to %s: %s\", old_author_path, new_author_path, ex)\n                        log.debug(ex, exc_info=True)\n                        return _(\"Rename author from: '%(src)s' to '%(dest)s' failed with error: %(error)s\",\n                                 src=old_author_path, dest=new_author_path, error=str(ex))\n    else:\n        new_authordir = get_valid_filename(localbook.authors[0].name, chars=96)\n    return new_authordir\n\n# Moves files in file storage during author/title rename, or from temp dir to file storage\ndef update_dir_structure_file(book_id, calibre_path, first_author, original_filepath, db_filename, renamed_author):\n    # get book database entry from id, if original path overwrite source with original_filepath\n    localbook = calibre_db.get_book(book_id)\n    if original_filepath:\n        path = original_filepath\n    else:\n        path = os.path.join(calibre_path, localbook.path)\n\n    # Create (current) authordir and titledir from database\n    authordir = localbook.path.split('/')[0]\n    titledir = localbook.path.split('/')[1]\n\n    # Create new_authordir from parameter or from database\n    # Create new titledir from database and add id\n    new_authordir = rename_all_authors(first_author, renamed_author, calibre_path, localbook)\n    if first_author:\n        if first_author.lower() in [r.lower() for r in renamed_author]:\n            if os.path.isdir(os.path.join(calibre_path, new_authordir)):\n                path = os.path.join(calibre_path, new_authordir, titledir)\n\n    new_titledir = get_valid_filename(localbook.title, chars=96) + \" (\" + str(book_id) + \")\"\n\n    if titledir != new_titledir or authordir != new_authordir or original_filepath:\n        error = move_files_on_change(calibre_path,\n                                     new_authordir,\n                                     new_titledir,\n                                     localbook,\n                                     db_filename,\n                                     original_filepath,\n                                     path)\n        if error:\n            return error\n\n    # Rename all files from old names to new names\n    return rename_files_on_change(first_author, renamed_author, localbook, original_filepath, path, calibre_path)\n\n\ndef upload_new_file_gdrive(book_id, first_author, renamed_author, title, title_dir, original_filepath, filename_ext):\n    error = False\n    book = calibre_db.get_book(book_id)\n    file_name = get_valid_filename(title, chars=42) + ' - ' + \\\n                get_valid_filename(first_author, chars=42) + \\\n                filename_ext\n    rename_all_authors(first_author, renamed_author, gdrive=True)\n    gdrive_path = os.path.join(get_valid_filename(first_author, chars=96),\n                               title_dir + \" (\" + str(book_id) + \")\")\n    book.path = gdrive_path.replace(\"\\\\\", \"/\")\n    gd.uploadFileToEbooksFolder(os.path.join(gdrive_path, file_name).replace(\"\\\\\", \"/\"), original_filepath)\n    return rename_files_on_change(first_author, renamed_author, localbook=book, gdrive=True)\n\n\ndef update_dir_structure_gdrive(book_id, first_author, renamed_author):\n    book = calibre_db.get_book(book_id)\n\n    authordir = book.path.split('/')[0]\n    titledir = book.path.split('/')[1]\n    new_authordir = rename_all_authors(first_author, renamed_author, gdrive=True)\n    new_titledir = get_valid_filename(book.title, chars=96) + u\" (\" + str(book_id) + u\")\"\n\n    if titledir != new_titledir:\n        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), titledir)\n        if gFile:\n            gd.moveGdriveFileRemote(gFile, new_titledir)\n            book.path = book.path.split('/')[0] + u'/' + new_titledir\n            gd.updateDatabaseOnEdit(gFile['id'], book.path)     # only child folder affected\n        else:\n            return _(u'File %(file)s not found on Google Drive', file=book.path)  # file not found\n\n    if authordir != new_authordir and authordir not in renamed_author:\n        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), new_titledir)\n        if gFile:\n            gd.moveGdriveFolderRemote(gFile, new_authordir)\n            book.path = new_authordir + u'/' + book.path.split('/')[1]\n            gd.updateDatabaseOnEdit(gFile['id'], book.path)\n        else:\n            return _(u'File %(file)s not found on Google Drive', file=authordir)  # file not found\n\n    # change location in database to new author/title path\n    book.path = os.path.join(new_authordir, new_titledir).replace('\\\\', '/')\n    return rename_files_on_change(first_author, renamed_author, book, gdrive=True)\n\n\ndef move_files_on_change(calibre_path, new_authordir, new_titledir, localbook, db_filename, original_filepath, path):\n    new_path = os.path.join(calibre_path, new_authordir, new_titledir)\n    new_name = get_valid_filename(localbook.title, chars=96) + ' - ' + new_authordir\n    try:\n        if original_filepath:\n            if not os.path.isdir(new_path):\n                os.makedirs(new_path)\n            shutil.move(os.path.normcase(original_filepath), os.path.normcase(os.path.join(new_path, db_filename)))\n            log.debug(\"Moving title: %s to %s/%s\", original_filepath, new_path, new_name)\n        else:\n            # Check new path is not valid path\n            if not os.path.exists(new_path):\n                # move original path to new path\n                log.debug(\"Moving title: %s to %s\", path, new_path)\n                shutil.move(os.path.normcase(path), os.path.normcase(new_path))\n            else: # path is valid copy only files to new location (merge)\n                log.info(\"Moving title: %s into existing: %s\", path, new_path)\n                # Take all files and subfolder from old path (strange command)\n                for dir_name, __, file_list in os.walk(path):\n                    for file in file_list:\n                        shutil.move(os.path.normcase(os.path.join(dir_name, file)),\n                                        os.path.normcase(os.path.join(new_path + dir_name[len(path):], file)))\n        # change location in database to new author/title path\n        localbook.path = os.path.join(new_authordir, new_titledir).replace('\\\\','/')\n    except OSError as ex:\n        log.error(\"Rename title from: %s to %s: %s\", path, new_path, ex)\n        log.debug(ex, exc_info=True)\n        return _(\"Rename title from: '%(src)s' to '%(dest)s' failed with error: %(error)s\",\n                 src=path, dest=new_path, error=str(ex))\n    return False\n\n\ndef rename_files_on_change(first_author,\n                           renamed_author,\n                           localbook,\n                           orignal_filepath=\"\",\n                           path=\"\",\n                           calibre_path=\"\",\n                           gdrive=False):\n    # Rename all files from old names to new names\n    try:\n        clean_author_database(renamed_author, calibre_path, gdrive=gdrive)\n        if first_author and first_author not in renamed_author:\n            clean_author_database([first_author], calibre_path, localbook, gdrive)\n        if not gdrive and not renamed_author and not orignal_filepath and len(os.listdir(os.path.dirname(path))) == 0:\n            shutil.rmtree(os.path.dirname(path))\n    except (OSError, FileNotFoundError) as ex:\n        log.error(\"Error in rename file in path %s\", ex)\n        log.debug(ex, exc_info=True)\n        return _(\"Error in rename file in path: %(error)s\", error=str(ex))\n    return False\n\n\ndef delete_book_gdrive(book, book_format):\n    error = None\n    if book_format:\n        name = ''\n        for entry in book.data:\n            if entry.format.upper() == book_format:\n                name = entry.name + '.' + book_format\n        gFile = gd.getFileFromEbooksFolder(book.path, name)\n    else:\n        gFile = gd.getFileFromEbooksFolder(os.path.dirname(book.path), book.path.split('/')[1])\n    if gFile:\n        gd.deleteDatabaseEntry(gFile['id'])\n        gFile.Trash()\n    else:\n        error = _(u'Book path %(path)s not found on Google Drive', path=book.path)  # file not found\n\n    return error is None, error\n\n\ndef reset_password(user_id):\n    existing_user = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n    if not existing_user:\n        return 0, None\n    if not config.get_mail_server_configured():\n        return 2, None\n    try:\n        password = generate_random_password()\n        existing_user.password = generate_password_hash(password)\n        ub.session.commit()\n        send_registration_mail(existing_user.email, existing_user.name, password, True)\n        return 1, existing_user.name\n    except Exception:\n        ub.session.rollback()\n        return 0, None\n\n\ndef generate_random_password():\n    s = \"abcdefghijklmnopqrstuvwxyz01234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%&*()?\"\n    passlen = 8\n    return \"\".join(s[c % len(s)] for c in os.urandom(passlen))\n\n\ndef uniq(inpt):\n    output = []\n    inpt = [ \" \".join(inp.split()) for inp in inpt]\n    for x in inpt:\n        if x not in output:\n            output.append(x)\n    return output\n\ndef check_email(email):\n    email = valid_email(email)\n    if ub.session.query(ub.User).filter(func.lower(ub.User.email) == email.lower()).first():\n        log.error(u\"Found an existing account for this e-mail address\")\n        raise Exception(_(u\"Found an existing account for this e-mail address\"))\n    return email\n\n\ndef check_username(username):\n    username = username.strip()\n    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).scalar():\n        log.error(u\"This username is already taken\")\n        raise Exception (_(u\"This username is already taken\"))\n    return username\n\n\ndef valid_email(email):\n    email = email.strip()\n    # Regex according to https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#validation\n    if not re.search(r\"^[\\w.!#$%&'*+\\\\/=?^_`{|}~-]+@[\\w](?:[\\w-]{0,61}[\\w])?(?:\\.[\\w](?:[\\w-]{0,61}[\\w])?)*$\",\n                     email):\n        log.error(u\"Invalid e-mail address format\")\n        raise Exception(_(u\"Invalid e-mail address format\"))\n    return email\n\n# ################################# External interface #################################\n\n\ndef update_dir_structure(book_id,\n                         calibre_path,\n                         first_author=None,     # change author of book to this author\n                         original_filepath=None,\n                         db_filename=None,\n                         renamed_author=None):\n    renamed_author = renamed_author or []\n    if config.config_use_google_drive:\n        return update_dir_structure_gdrive(book_id, first_author, renamed_author)\n    else:\n        return update_dir_structure_file(book_id,\n                                         calibre_path,\n                                         first_author,\n                                         original_filepath,\n                                         db_filename, renamed_author)\n\n\ndef delete_book(book, calibrepath, book_format):\n    if config.config_use_google_drive:\n        return delete_book_gdrive(book, book_format)\n    else:\n        return delete_book_file(book, calibrepath, book_format)\n\n\ndef get_cover_on_failure(use_generic_cover):\n    if use_generic_cover:\n        return send_from_directory(_STATIC_DIR, \"generic_cover.jpg\")\n    else:\n        return None\n\n\ndef get_book_cover(book_id):\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    return get_book_cover_internal(book, use_generic_cover_on_failure=True)\n\n\ndef get_book_cover_with_uuid(book_uuid,\n                             use_generic_cover_on_failure=True):\n    book = calibre_db.get_book_by_uuid(book_uuid)\n    return get_book_cover_internal(book, use_generic_cover_on_failure)\n\n\ndef get_book_cover_internal(book, use_generic_cover_on_failure):\n    if book and book.has_cover:\n        if config.config_use_google_drive:\n            try:\n                if not gd.is_gdrive_ready():\n                    return get_cover_on_failure(use_generic_cover_on_failure)\n                path = gd.get_cover_via_gdrive(book.path)\n                if path:\n                    return redirect(path)\n                else:\n                    log.error('%s/cover.jpg not found on Google Drive', book.path)\n                    return get_cover_on_failure(use_generic_cover_on_failure)\n            except Exception as ex:\n                log.error_or_exception(ex)\n                return get_cover_on_failure(use_generic_cover_on_failure)\n        else:\n            cover_file_path = os.path.join(config.config_calibre_dir, book.path)\n            if os.path.isfile(os.path.join(cover_file_path, \"cover.jpg\")):\n                return send_from_directory(cover_file_path, \"cover.jpg\")\n            else:\n                return get_cover_on_failure(use_generic_cover_on_failure)\n    else:\n        return get_cover_on_failure(use_generic_cover_on_failure)\n\n\n# saves book cover from url\ndef save_cover_from_url(url, book_path):\n    try:\n        if not cli.allow_localhost:\n            # 127.0.x.x, localhost, [::1], [::ffff:7f00:1]\n            ip = socket.getaddrinfo(urlparse(url).hostname, 0)[0][4][0]\n            if ip.startswith(\"127.\") or ip.startswith('::ffff:7f') or ip == \"::1\" or ip == \"0.0.0.0\" or ip == \"::\":\n                log.error(\"Localhost was accessed for cover upload\")\n                return False, _(\"You are not allowed to access localhost for cover uploads\")\n        img = requests.get(url, timeout=(10, 200), allow_redirects=False)      # ToDo: Error Handling\n        img.raise_for_status()\n        return save_cover(img, book_path)\n    except (socket.gaierror,\n            requests.exceptions.HTTPError,\n            requests.exceptions.ConnectionError,\n            requests.exceptions.Timeout) as ex:\n        log.info(u'Cover Download Error %s', ex)\n        return False, _(\"Error Downloading Cover\")\n    except MissingDelegateError as ex:\n        log.info(u'File Format Error %s', ex)\n        return False, _(\"Cover Format Error\")\n\n\ndef save_cover_from_filestorage(filepath, saved_filename, img):\n    # check if file path exists, otherwise create it, copy file to calibre path and delete temp file\n    if not os.path.exists(filepath):\n        try:\n            os.makedirs(filepath)\n        except OSError:\n            log.error(u\"Failed to create path for cover\")\n            return False, _(u\"Failed to create path for cover\")\n    try:\n        # upload of jgp file without wand\n        if isinstance(img, requests.Response):\n            with open(os.path.join(filepath, saved_filename), 'wb') as f:\n                f.write(img.content)\n        else:\n            if hasattr(img, \"metadata\"):\n                # upload of jpg/png... via url\n                img.save(filename=os.path.join(filepath, saved_filename))\n                img.close()\n            else:\n                # upload of jpg/png... from hdd\n                img.save(os.path.join(filepath, saved_filename))\n    except (IOError, OSError):\n        log.error(u\"Cover-file is not a valid image file, or could not be stored\")\n        return False, _(u\"Cover-file is not a valid image file, or could not be stored\")\n    return True, None\n\n\n# saves book cover to gdrive or locally\ndef save_cover(img, book_path):\n    content_type = img.headers.get('content-type')\n\n    if use_IM:\n        if content_type not in ('image/jpeg', 'image/png', 'image/webp', 'image/bmp'):\n            log.error(\"Only jpg/jpeg/png/webp/bmp files are supported as coverfile\")\n            return False, _(\"Only jpg/jpeg/png/webp/bmp files are supported as coverfile\")\n        # convert to jpg because calibre only supports jpg\n        if content_type != 'image/jpg':\n            try:\n                if hasattr(img, 'stream'):\n                    imgc = Image(blob=img.stream)\n                else:\n                    imgc = Image(blob=io.BytesIO(img.content))\n                imgc.format = 'jpeg'\n                imgc.transform_colorspace(\"rgb\")\n                img = imgc\n            except (BlobError, MissingDelegateError):\n                log.error(\"Invalid cover file content\")\n                return False, _(\"Invalid cover file content\")\n    else:\n        if content_type not in 'image/jpeg':\n            log.error(\"Only jpg/jpeg files are supported as coverfile\")\n            return False, _(\"Only jpg/jpeg files are supported as coverfile\")\n\n    if config.config_use_google_drive:\n        tmp_dir = os.path.join(gettempdir(), 'calibre_web')\n\n        if not os.path.isdir(tmp_dir):\n            os.mkdir(tmp_dir)\n        ret, message = save_cover_from_filestorage(tmp_dir, \"uploaded_cover.jpg\", img)\n        if ret is True:\n            gd.uploadFileToEbooksFolder(os.path.join(book_path, 'cover.jpg').replace(\"\\\\\",\"/\"),\n                                        os.path.join(tmp_dir, \"uploaded_cover.jpg\"))\n            log.info(\"Cover is saved on Google Drive\")\n            return True, None\n        else:\n            return False, message\n    else:\n        return save_cover_from_filestorage(os.path.join(config.config_calibre_dir, book_path), \"cover.jpg\", img)\n\n\ndef do_download_file(book, book_format, client, data, headers):\n    if config.config_use_google_drive:\n        #startTime = time.time()\n        df = gd.getFileFromEbooksFolder(book.path, data.name + \".\" + book_format)\n        #log.debug('%s', time.time() - startTime)\n        if df:\n            return gd.do_gdrive_download(df, headers)\n        else:\n            abort(404)\n    else:\n        filename = os.path.join(config.config_calibre_dir, book.path)\n        if not os.path.isfile(os.path.join(filename, data.name + \".\" + book_format)):\n            # ToDo: improve error handling\n            log.error('File not found: %s', os.path.join(filename, data.name + \".\" + book_format))\n\n        if client == \"kobo\" and book_format == \"kepub\":\n            headers[\"Content-Disposition\"] = headers[\"Content-Disposition\"].replace(\".kepub\", \".kepub.epub\")\n\n        response = make_response(send_from_directory(filename, data.name + \".\" + book_format))\n        # ToDo Check headers parameter\n        for element in headers:\n            response.headers[element[0]] = element[1]\n        log.info('Downloading file: {}'.format(os.path.join(filename, data.name + \".\" + book_format)))\n        return response\n\n##################################\n\n\ndef check_unrar(unrarLocation):\n    if not unrarLocation:\n        return\n\n    if not os.path.exists(unrarLocation):\n        return _('Unrar binary file not found')\n\n    try:\n        unrarLocation = [unrarLocation]\n        value = process_wait(unrarLocation, pattern='UNRAR (.*) freeware')\n        if value:\n            version = value.group(1)\n            log.debug(\"unrar version %s\", version)\n\n    except (OSError, UnicodeDecodeError) as err:\n        log.error_or_exception(err)\n        return _('Error excecuting UnRar')\n\n\ndef json_serial(obj):\n    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"\n\n    if isinstance(obj, datetime):\n        return obj.isoformat()\n    if isinstance(obj, timedelta):\n        return {\n            '__type__': 'timedelta',\n            'days': obj.days,\n            'seconds': obj.seconds,\n            'microseconds': obj.microseconds,\n        }\n    raise TypeError(\"Type %s not serializable\" % type(obj))\n\n\n# helper function for displaying the runtime of tasks\ndef format_runtime(runtime):\n    retVal = \"\"\n    if runtime.days:\n        retVal = format_unit(runtime.days, 'duration-day', length=\"long\", locale=get_locale()) + ', '\n    mins, seconds = divmod(runtime.seconds, 60)\n    hours, minutes = divmod(mins, 60)\n    # ToDo: locale.number_symbols._data['timeSeparator'] -> localize time separator ?\n    if hours:\n        retVal += '{:d}:{:02d}:{:02d}s'.format(hours, minutes, seconds)\n    elif minutes:\n        retVal += '{:2d}:{:02d}s'.format(minutes, seconds)\n    else:\n        retVal += '{:2d}s'.format(seconds)\n    return retVal\n\n\n# helper function to apply localize status information in tasklist entries\ndef render_task_status(tasklist):\n    renderedtasklist = list()\n    for __, user, __, task in tasklist:\n        if user == current_user.name or current_user.role_admin():\n            ret = {}\n            if task.start_time:\n                ret['starttime'] = format_datetime(task.start_time, format='short', locale=get_locale())\n                ret['runtime'] = format_runtime(task.runtime)\n\n            # localize the task status\n            if isinstance(task.stat, int):\n                if task.stat == STAT_WAITING:\n                    ret['status'] = _(u'Waiting')\n                elif task.stat == STAT_FAIL:\n                    ret['status'] = _(u'Failed')\n                elif task.stat == STAT_STARTED:\n                    ret['status'] = _(u'Started')\n                elif task.stat == STAT_FINISH_SUCCESS:\n                    ret['status'] = _(u'Finished')\n                else:\n                    ret['status'] = _(u'Unknown Status')\n\n            ret['taskMessage'] = \"{}: {}\".format(_(task.name), task.message)\n            ret['progress'] = \"{} %\".format(int(task.progress * 100))\n            ret['user'] = escape(user)  # prevent xss\n            renderedtasklist.append(ret)\n\n    return renderedtasklist\n\n\ndef tags_filters():\n    negtags_list = current_user.list_denied_tags()\n    postags_list = current_user.list_allowed_tags()\n    neg_content_tags_filter = false() if negtags_list == [''] else db.Tags.name.in_(negtags_list)\n    pos_content_tags_filter = true() if postags_list == [''] else db.Tags.name.in_(postags_list)\n    return and_(pos_content_tags_filter, ~neg_content_tags_filter)\n\n\n# checks if domain is in database (including wildcards)\n# example SELECT * FROM @TABLE WHERE  'abcdefg' LIKE Name;\n# from https://code.luasoftware.com/tutorials/flask/execute-raw-sql-in-flask-sqlalchemy/\n# in all calls the email address is checked for validity\ndef check_valid_domain(domain_text):\n    sql = \"SELECT * FROM registration WHERE (:domain LIKE domain and allow = 1);\"\n    result = ub.session.query(ub.Registration).from_statement(text(sql)).params(domain=domain_text).all()\n    if not len(result):\n        return False\n    sql = \"SELECT * FROM registration WHERE (:domain LIKE domain and allow = 0);\"\n    result = ub.session.query(ub.Registration).from_statement(text(sql)).params(domain=domain_text).all()\n    return not len(result)\n\n\ndef get_cc_columns(filter_config_custom_read=False):\n    tmpcc = calibre_db.session.query(db.Custom_Columns)\\\n        .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    cc = []\n    r = None\n    if config.config_columns_to_ignore:\n        r = re.compile(config.config_columns_to_ignore)\n\n    for col in tmpcc:\n        if filter_config_custom_read and config.config_read_column and config.config_read_column == col.id:\n            continue\n        if r and r.match(col.name):\n            continue\n        cc.append(col)\n\n    return cc\n\n\ndef get_download_link(book_id, book_format, client):\n    book_format = book_format.split(\".\")[0]\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    if book:\n        data1 = calibre_db.get_book_format(book.id, book_format.upper())\n    else:\n        log.error(\"Book id {} not found for downloading\".format(book_id))\n        abort(404)\n    if data1:\n        # collect downloaded books only for registered user and not for anonymous user\n        if current_user.is_authenticated:\n            ub.update_download(book_id, int(current_user.id))\n        file_name = book.title\n        if len(book.authors) > 0:\n            file_name = file_name + ' - ' + book.authors[0].name\n        file_name = get_valid_filename(file_name, replace_whitespace=False)\n        headers = Headers()\n        headers[\"Content-Type\"] = mimetypes.types_map.get('.' + book_format, \"application/octet-stream\")\n        headers[\"Content-Disposition\"] = \"attachment; filename=%s.%s; filename*=UTF-8''%s.%s\" % (\n            quote(file_name.encode('utf-8')), book_format, quote(file_name.encode('utf-8')), book_format)\n        return do_download_file(book, book_format, client, data1, headers)\n    else:\n        abort(404)\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport datetime\nfrom urllib.parse import unquote_plus\nfrom functools import wraps\n\nfrom flask import Blueprint, request, render_template, Response, g, make_response, abort\nfrom flask_login import current_user\nfrom sqlalchemy.sql.expression import func, text, or_, and_, true\nfrom werkzeug.security import check_password_hash\nfrom tornado.httputil import HTTPServerRequest\nfrom . import constants, logger, config, db, calibre_db, ub, services, get_locale, isoLanguages\nfrom .helper import get_download_link, get_book_cover\nfrom .pagination import Pagination\nfrom .web import render_read_books\nfrom .usermanagement import load_user_from_request\nfrom flask_babel import gettext as _\n\nopds = Blueprint('opds', __name__)\n\nlog = logger.create()\n\n\ndef requires_basic_auth_if_no_ano(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        auth = request.authorization\n        if config.config_anonbrowse != 1:\n            if not auth or auth.type != 'basic' or not check_auth(auth.username, auth.password):\n                return authenticate()\n        return f(*args, **kwargs)\n    if config.config_login_type == constants.LOGIN_LDAP and services.ldap and config.config_anonbrowse != 1:\n        return services.ldap.basic_auth_required(f)\n    return decorated\n\n\nclass FeedObject:\n    def __init__(self, rating_id, rating_name):\n        self.rating_id = rating_id\n        self.rating_name = rating_name\n\n    @property\n    def id(self):\n        return self.rating_id\n\n    @property\n    def name(self):\n        return self.rating_name\n\n\n@opds.route(\"/opds/\")\n@opds.route(\"/opds\")\n@requires_basic_auth_if_no_ano\ndef feed_index():\n    return render_xml_template('index.xml')\n\n\n@opds.route(\"/opds/osd\")\n@requires_basic_auth_if_no_ano\ndef feed_osd():\n    return render_xml_template('osd.xml', lang='en-EN')\n\n\n@opds.route(\"/opds/search\", defaults={'query': \"\"})\n@opds.route(\"/opds/search/<path:query>\")\n@requires_basic_auth_if_no_ano\ndef feed_cc_search(query):\n    # Handle strange query from Libera Reader with + instead of spaces\n    plus_query = unquote_plus(request.base_url.split('/opds/search/')[1]).strip()\n    return feed_search(plus_query)\n\n\n@opds.route(\"/opds/search\", methods=[\"GET\"])\n@requires_basic_auth_if_no_ano\ndef feed_normal_search():\n    return feed_search(request.args.get(\"query\", \"\").strip())\n\n\n@opds.route(\"/opds/books\")\n@requires_basic_auth_if_no_ano\ndef feed_booksindex():\n    shift = 0\n    off = int(request.args.get(\"offset\") or 0)\n    entries = calibre_db.session.query(func.upper(func.substr(db.Books.sort, 1, 1)).label('id'))\\\n        .filter(calibre_db.common_filters()).group_by(func.upper(func.substr(db.Books.sort, 1, 1))).all()\n\n    elements = []\n    if off == 0:\n        elements.append({'id': \"00\", 'name':_(\"All\")})\n        shift = 1\n    for entry in entries[\n                 off + shift - 1:\n                 int(off + int(config.config_books_per_page) - shift)]:\n        elements.append({'id': entry.id, 'name': entry.id})\n\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(entries) + 1)\n    return render_xml_template('feed.xml',\n                               letterelements=elements,\n                               folder='opds.feed_letter_books',\n                               pagination=pagination)\n\n\n@opds.route(\"/opds/books/letter/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_letter_books(book_id):\n    off = request.args.get(\"offset\") or 0\n    letter = true() if book_id == \"00\" else func.upper(db.Books.sort).startswith(book_id)\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        letter,\n                                                        [db.Books.sort])\n\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/new\")\n@requires_basic_auth_if_no_ano\ndef feed_new():\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books, True, [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/discover\")\n@requires_basic_auth_if_no_ano\ndef feed_discover():\n    entries = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()).order_by(func.random())\\\n        .limit(config.config_books_per_page)\n    pagination = Pagination(1, config.config_books_per_page, int(config.config_books_per_page))\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/rated\")\n@requires_basic_auth_if_no_ano\ndef feed_best_rated():\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books, db.Books.ratings.any(db.Ratings.rating > 9),\n                                                        [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/hot\")\n@requires_basic_auth_if_no_ano\ndef feed_hot():\n    off = request.args.get(\"offset\") or 0\n    all_books = ub.session.query(ub.Downloads, func.count(ub.Downloads.book_id)).order_by(\n        func.count(ub.Downloads.book_id).desc()).group_by(ub.Downloads.book_id)\n    hot_books = all_books.offset(off).limit(config.config_books_per_page)\n    entries = list()\n    for book in hot_books:\n        downloadBook = calibre_db.get_book(book.Downloads.book_id)\n        if downloadBook:\n            entries.append(\n                calibre_db.get_filtered_book(book.Downloads.book_id)\n            )\n        else:\n            ub.delete_download(book.Downloads.book_id)\n    numBooks = entries.__len__()\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1),\n                            config.config_books_per_page, numBooks)\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/author\")\n@requires_basic_auth_if_no_ano\ndef feed_authorindex():\n    shift = 0\n    off = int(request.args.get(\"offset\") or 0)\n    entries = calibre_db.session.query(func.upper(func.substr(db.Authors.sort, 1, 1)).label('id'))\\\n        .join(db.books_authors_link).join(db.Books).filter(calibre_db.common_filters())\\\n        .group_by(func.upper(func.substr(db.Authors.sort, 1, 1))).all()\n\n    elements = []\n    if off == 0:\n        elements.append({'id': \"00\", 'name':_(\"All\")})\n        shift = 1\n    for entry in entries[\n                 off + shift - 1:\n                 int(off + int(config.config_books_per_page) - shift)]:\n        elements.append({'id': entry.id, 'name': entry.id})\n\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(entries) + 1)\n    return render_xml_template('feed.xml',\n                               letterelements=elements,\n                               folder='opds.feed_letter_author',\n                               pagination=pagination)\n\n\n@opds.route(\"/opds/author/letter/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_letter_author(book_id):\n    off = request.args.get(\"offset\") or 0\n    letter = true() if book_id == \"00\" else func.upper(db.Authors.sort).startswith(book_id)\n    entries = calibre_db.session.query(db.Authors).join(db.books_authors_link).join(db.Books)\\\n        .filter(calibre_db.common_filters()).filter(letter)\\\n        .group_by(text('books_authors_link.author'))\\\n        .order_by(db.Authors.sort)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            entries.count())\n    entries = entries.limit(config.config_books_per_page).offset(off).all()\n    return render_xml_template('feed.xml', listelements=entries, folder='opds.feed_author', pagination=pagination)\n\n\n@opds.route(\"/opds/author/<int:book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_author(book_id):\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        db.Books.authors.any(db.Authors.id == book_id),\n                                                        [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/publisher\")\n@requires_basic_auth_if_no_ano\ndef feed_publisherindex():\n    off = request.args.get(\"offset\") or 0\n    entries = calibre_db.session.query(db.Publishers)\\\n        .join(db.books_publishers_link)\\\n        .join(db.Books).filter(calibre_db.common_filters())\\\n        .group_by(text('books_publishers_link.publisher'))\\\n        .order_by(db.Publishers.sort)\\\n        .limit(config.config_books_per_page).offset(off)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(calibre_db.session.query(db.Publishers).all()))\n    return render_xml_template('feed.xml', listelements=entries, folder='opds.feed_publisher', pagination=pagination)\n\n\n@opds.route(\"/opds/publisher/<int:book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_publisher(book_id):\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        db.Books.publishers.any(db.Publishers.id == book_id),\n                                                        [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/category\")\n@requires_basic_auth_if_no_ano\ndef feed_categoryindex():\n    shift = 0\n    off = int(request.args.get(\"offset\") or 0)\n    entries = calibre_db.session.query(func.upper(func.substr(db.Tags.name, 1, 1)).label('id'))\\\n        .join(db.books_tags_link).join(db.Books).filter(calibre_db.common_filters())\\\n        .group_by(func.upper(func.substr(db.Tags.name, 1, 1))).all()\n    elements = []\n    if off == 0:\n        elements.append({'id': \"00\", 'name':_(\"All\")})\n        shift = 1\n    for entry in entries[\n                 off + shift - 1:\n                 int(off + int(config.config_books_per_page) - shift)]:\n        elements.append({'id': entry.id, 'name': entry.id})\n\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(entries) + 1)\n    return render_xml_template('feed.xml',\n                               letterelements=elements,\n                               folder='opds.feed_letter_category',\n                               pagination=pagination)\n\n@opds.route(\"/opds/category/letter/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_letter_category(book_id):\n    off = request.args.get(\"offset\") or 0\n    letter = true() if book_id == \"00\" else func.upper(db.Tags.name).startswith(book_id)\n    entries = calibre_db.session.query(db.Tags)\\\n        .join(db.books_tags_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()).filter(letter)\\\n        .group_by(text('books_tags_link.tag'))\\\n        .order_by(db.Tags.name)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            entries.count())\n    entries = entries.offset(off).limit(config.config_books_per_page).all()\n    return render_xml_template('feed.xml', listelements=entries, folder='opds.feed_category', pagination=pagination)\n\n\n@opds.route(\"/opds/category/<int:book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_category(book_id):\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        db.Books.tags.any(db.Tags.id == book_id),\n                                                        [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/series\")\n@requires_basic_auth_if_no_ano\ndef feed_seriesindex():\n    shift = 0\n    off = int(request.args.get(\"offset\") or 0)\n    entries = calibre_db.session.query(func.upper(func.substr(db.Series.sort, 1, 1)).label('id'))\\\n        .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters())\\\n        .group_by(func.upper(func.substr(db.Series.sort, 1, 1))).all()\n    elements = []\n    if off == 0:\n        elements.append({'id': \"00\", 'name':_(\"All\")})\n        shift = 1\n    for entry in entries[\n                 off + shift - 1:\n                 int(off + int(config.config_books_per_page) - shift)]:\n        elements.append({'id': entry.id, 'name': entry.id})\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(entries) + 1)\n    return render_xml_template('feed.xml',\n                               letterelements=elements,\n                               folder='opds.feed_letter_series',\n                               pagination=pagination)\n\n@opds.route(\"/opds/series/letter/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_letter_series(book_id):\n    off = request.args.get(\"offset\") or 0\n    letter = true() if book_id == \"00\" else func.upper(db.Series.sort).startswith(book_id)\n    entries = calibre_db.session.query(db.Series)\\\n        .join(db.books_series_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()).filter(letter)\\\n        .group_by(text('books_series_link.series'))\\\n        .order_by(db.Series.sort)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            entries.count())\n    entries = entries.offset(off).limit(config.config_books_per_page).all()\n    return render_xml_template('feed.xml', listelements=entries, folder='opds.feed_series', pagination=pagination)\n\n\n@opds.route(\"/opds/series/<int:book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_series(book_id):\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        db.Books.series.any(db.Series.id == book_id),\n                                                        [db.Books.series_index])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/ratings\")\n@requires_basic_auth_if_no_ano\ndef feed_ratingindex():\n    off = request.args.get(\"offset\") or 0\n    entries = calibre_db.session.query(db.Ratings, func.count('books_ratings_link.book').label('count'),\n                               (db.Ratings.rating / 2).label('name')) \\\n        .join(db.books_ratings_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_ratings_link.rating'))\\\n        .order_by(db.Ratings.rating).all()\n\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(entries))\n    element = list()\n    for entry in entries:\n        element.append(FeedObject(entry[0].id, _(\"{} Stars\").format(entry.name)))\n    return render_xml_template('feed.xml', listelements=element, folder='opds.feed_ratings', pagination=pagination)\n\n\n@opds.route(\"/opds/ratings/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_ratings(book_id):\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        db.Books.ratings.any(db.Ratings.id == book_id),\n                                                        [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/formats\")\n@requires_basic_auth_if_no_ano\ndef feed_formatindex():\n    off = request.args.get(\"offset\") or 0\n    entries = calibre_db.session.query(db.Data).join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(db.Data.format)\\\n        .order_by(db.Data.format).all()\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(entries))\n\n    element = list()\n    for entry in entries:\n        element.append(FeedObject(entry.format, entry.format))\n    return render_xml_template('feed.xml', listelements=element, folder='opds.feed_format', pagination=pagination)\n\n\n@opds.route(\"/opds/formats/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_format(book_id):\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        db.Books.data.any(db.Data.format == book_id.upper()),\n                                                        [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/language\")\n@opds.route(\"/opds/language/\")\n@requires_basic_auth_if_no_ano\ndef feed_languagesindex():\n    off = request.args.get(\"offset\") or 0\n    if current_user.filter_language() == u\"all\":\n        languages = calibre_db.speaking_language()\n    else:\n        languages = calibre_db.session.query(db.Languages).filter(\n            db.Languages.lang_code == current_user.filter_language()).all()\n        languages[0].name = isoLanguages.get_language_name(get_locale(), languages[0].lang_code)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(languages))\n    return render_xml_template('feed.xml', listelements=languages, folder='opds.feed_languages', pagination=pagination)\n\n\n@opds.route(\"/opds/language/<int:book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_languages(book_id):\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        db.Books.languages.any(db.Languages.id == book_id),\n                                                        [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/shelfindex\")\n@requires_basic_auth_if_no_ano\ndef feed_shelfindex():\n    off = request.args.get(\"offset\") or 0\n    shelf = g.shelves_access\n    number = len(shelf)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            number)\n    return render_xml_template('feed.xml', listelements=shelf, folder='opds.feed_shelf', pagination=pagination)\n\n\n@opds.route(\"/opds/shelf/<int:book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_shelf(book_id):\n    off = request.args.get(\"offset\") or 0\n    if current_user.is_anonymous:\n        shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.is_public == 1,\n                                                  ub.Shelf.id == book_id).first()\n    else:\n        shelf = ub.session.query(ub.Shelf).filter(or_(and_(ub.Shelf.user_id == int(current_user.id),\n                                                           ub.Shelf.id == book_id),\n                                                      and_(ub.Shelf.is_public == 1,\n                                                           ub.Shelf.id == book_id))).first()\n    result = list()\n    # user is allowed to access shelf\n    if shelf:\n        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == book_id).order_by(\n            ub.BookShelf.order.asc()).all()\n        for book in books_in_shelf:\n            cur_book = calibre_db.get_book(book.book_id)\n            result.append(cur_book)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(result))\n    return render_xml_template('feed.xml', entries=result, pagination=pagination)\n\n\n@opds.route(\"/opds/download/<book_id>/<book_format>/\")\n@requires_basic_auth_if_no_ano\ndef opds_download_link(book_id, book_format):\n    # I gave up with this: With enabled ldap login, the user doesn't get logged in, therefore it's always guest\n    # workaround, loading the user from the request and checking it's download rights here\n    # in case of anonymous browsing user is None\n    user = load_user_from_request(request) or current_user\n    if not user.role_download():\n        return abort(403)\n    if \"Kobo\" in request.headers.get('User-Agent'):\n        client = \"kobo\"\n    else:\n        client = \"\"\n    return get_download_link(book_id, book_format.lower(), client)\n\n\n@opds.route(\"/ajax/book/<string:uuid>/<library>\")\n@opds.route(\"/ajax/book/<string:uuid>\", defaults={'library': \"\"})\n@requires_basic_auth_if_no_ano\ndef get_metadata_calibre_companion(uuid, library):\n    entry = calibre_db.session.query(db.Books).filter(db.Books.uuid.like(\"%\" + uuid + \"%\")).first()\n    if entry is not None:\n        js = render_template('json.txt', entry=entry)\n        response = make_response(js)\n        response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n        return response\n    else:\n        return \"\"\n\n\ndef feed_search(term):\n    if term:\n        entries, __, ___ = calibre_db.get_search_results(term, config_read_column=config.config_read_column)\n        entries_count = len(entries) if len(entries) > 0 else 1\n        pagination = Pagination(1, entries_count, entries_count)\n        items = [entry[0] for entry in entries]\n        return render_xml_template('feed.xml', searchterm=term, entries=items, pagination=pagination)\n    else:\n        return render_xml_template('feed.xml', searchterm=\"\")\n\n\ndef check_auth(username, password):\n    try:\n        username = username.encode('windows-1252')\n    except UnicodeEncodeError:\n        username = username.encode('utf-8')\n    user = ub.session.query(ub.User).filter(func.lower(ub.User.name) ==\n                                            username.decode('utf-8').lower()).first()\n    if bool(user and check_password_hash(str(user.password), password)):\n        return True\n    else:\n        ip_Address = request.headers.get('X-Forwarded-For', request.remote_addr)\n        log.warning('OPDS Login failed for user \"%s\" IP-address: %s', username.decode('utf-8'), ip_Address)\n        return False\n\n\ndef authenticate():\n    return Response(\n        'Could not verify your access level for that URL.\\n'\n        'You have to login with proper credentials', 401,\n        {'WWW-Authenticate': 'Basic realm=\"Login Required\"'})\n\n\ndef render_xml_template(*args, **kwargs):\n    # ToDo: return time in current timezone similar to %z\n    currtime = datetime.datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S+00:00\")\n    xml = render_template(current_time=currtime, instance=config.config_calibre_web_title, *args, **kwargs)\n    response = make_response(xml)\n    response.headers[\"Content-Type\"] = \"application/atom+xml; charset=utf-8\"\n    return response\n\n\n@opds.route(\"/opds/thumb_240_240/<book_id>\")\n@opds.route(\"/opds/cover_240_240/<book_id>\")\n@opds.route(\"/opds/cover_90_90/<book_id>\")\n@opds.route(\"/opds/cover/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_get_cover(book_id):\n    return get_book_cover(book_id)\n\n\n@opds.route(\"/opds/readbooks\")\n@requires_basic_auth_if_no_ano\ndef feed_read_books():\n    off = request.args.get(\"offset\") or 0\n    result, pagination = render_read_books(int(off) / (int(config.config_books_per_page)) + 1, True, True)\n    return render_xml_template('feed.xml', entries=result, pagination=pagination)\n\n\n@opds.route(\"/opds/unreadbooks\")\n@requires_basic_auth_if_no_ano\ndef feed_unread_books():\n    off = request.args.get(\"offset\") or 0\n    result, pagination = render_read_books(int(off) / (int(config.config_books_per_page)) + 1, False, True)\n    return render_xml_template('feed.xml', entries=result, pagination=pagination)\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nfrom math import ceil\n\n\n# simple pagination for the feed\nclass Pagination(object):\n    def __init__(self, page, per_page, total_count):\n        self.page = int(page)\n        self.per_page = int(per_page)\n        self.total_count = int(total_count)\n\n    @property\n    def next_offset(self):\n        return int(self.page * self.per_page)\n\n    @property\n    def previous_offset(self):\n        return int((self.page - 2) * self.per_page)\n\n    @property\n    def last_offset(self):\n        last = int(self.total_count) - int(self.per_page)\n        if last < 0:\n            last = 0\n        return int(last)\n\n    @property\n    def pages(self):\n        return int(ceil(self.total_count / float(self.per_page)))\n\n    @property\n    def has_prev(self):\n        return self.page > 1\n\n    @property\n    def has_next(self):\n        return self.page < self.pages\n\n    # right_edge: last right_edges count of all pages are shown as number, means, if 10 pages are paginated -> 9,10 shwn\n    # left_edge: first left_edges count of all pages are shown as number                                    -> 1,2 shwn\n    # left_current: left_current count below current page are shown as number, means if current page 5      -> 3,4 shwn\n    # left_current: right_current count above current page are shown as number, means if current page 5     -> 6,7 shwn\n    def iter_pages(self, left_edge=2, left_current=2,\n                   right_current=4, right_edge=2):\n        last = 0\n        left_current = self.page - left_current - 1\n        right_current = self.page + right_current + 1\n        right_edge = self.pages - right_edge\n        for num in range(1, (self.pages + 1)):\n            if num <= left_edge or (left_current < num < right_current) or num > right_edge:\n                if last + 1 != num:\n                    yield None\n                yield num\n                last = num\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport json\nfrom datetime import datetime\n\nfrom flask import Blueprint, request, make_response, abort, url_for, flash, redirect\nfrom flask_login import login_required, current_user, login_user\nfrom flask_babel import gettext as _\nfrom sqlalchemy.sql.expression import true\n\nfrom . import config, logger, ub\nfrom .render_template import render_title_template\n\ntry:\n    from functools import wraps\nexcept ImportError:\n    pass  # We're not using Python 3\n\nremotelogin = Blueprint('remotelogin', __name__)\nlog = logger.create()\n\n\ndef remote_login_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if config.config_remote_login:\n            return f(*args, **kwargs)\n        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':\n            data = {'status': 'error', 'message': 'Forbidden'}\n            response = make_response(json.dumps(data, ensure_ascii=False))\n            response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n            return response, 403\n        abort(403)\n\n    return inner\n\n@remotelogin.route('/remote/login')\n@remote_login_required\ndef remote_login():\n    auth_token = ub.RemoteAuthToken()\n    ub.session.add(auth_token)\n    ub.session_commit()\n    verify_url = url_for('remotelogin.verify_token', token=auth_token.auth_token, _external=true)\n    log.debug(u\"Remot Login request with token: %s\", auth_token.auth_token)\n    return render_title_template('remote_login.html', title=_(u\"Login\"), token=auth_token.auth_token,\n                                 verify_url=verify_url, page=\"remotelogin\")\n\n\n@remotelogin.route('/verify/<token>')\n@remote_login_required\n@login_required\ndef verify_token(token):\n    auth_token = ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.auth_token == token).first()\n\n    # Token not found\n    if auth_token is None:\n        flash(_(u\"Token not found\"), category=\"error\")\n        log.error(u\"Remote Login token not found\")\n        return redirect(url_for('web.index'))\n\n    # Token expired\n    elif datetime.now() > auth_token.expiration:\n        ub.session.delete(auth_token)\n        ub.session_commit()\n\n        flash(_(u\"Token has expired\"), category=\"error\")\n        log.error(u\"Remote Login token expired\")\n        return redirect(url_for('web.index'))\n\n    # Update token with user information\n    auth_token.user_id = current_user.id\n    auth_token.verified = True\n    ub.session_commit()\n\n    flash(_(u\"Success! Please return to your device\"), category=\"success\")\n    log.debug(u\"Remote Login token for userid %s verified\", auth_token.user_id)\n    return redirect(url_for('web.index'))\n\n\n@remotelogin.route('/ajax/verify_token', methods=['POST'])\n@remote_login_required\ndef token_verified():\n    token = request.form['token']\n    auth_token = ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.auth_token == token).first()\n\n    data = {}\n\n    # Token not found\n    if auth_token is None:\n        data['status'] = 'error'\n        data['message'] = _(u\"Token not found\")\n\n    # Token expired\n    elif datetime.now() > auth_token.expiration:\n        ub.session.delete(auth_token)\n        ub.session_commit()\n\n        data['status'] = 'error'\n        data['message'] = _(u\"Token has expired\")\n\n    elif not auth_token.verified:\n        data['status'] = 'not_verified'\n\n    else:\n        user = ub.session.query(ub.User).filter(ub.User.id == auth_token.user_id).first()\n        login_user(user)\n\n        ub.session.delete(auth_token)\n        ub.session_commit(\"User {} logged in via remotelogin, token deleted\".format(user.name))\n\n        data['status'] = 'success'\n        log.debug(u\"Remote Login for userid %s succeded\", user.id)\n        flash(_(u\"you are now logged in as: '%(nickname)s'\", nickname=user.name), category=\"success\")\n\n    response = make_response(json.dumps(data, ensure_ascii=False))\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n\n    return response\n", "{% extends \"layout.html\" %}\n{% block body %}\n{% if book %}\n  <div class=\"col-sm-3 col-lg-3 col-xs-12\">\n    <div class=\"cover\">\n        <img id=\"detailcover\" title=\"{{book.title}}\" src=\"{{ url_for('web.get_cover', book_id=book.id, edit=1|uuidfilter)  }}\" alt=\"{{ book.title }}\"/>\n    </div>\n{% if g.user.role_delete_books() %}\n    <div class=\"text-center\">\n      <button type=\"button\" class=\"btn btn-danger\" id=\"delete\" data-toggle=\"modal\" data-delete-id=\"{{ book.id }}\" data-target=\"#deleteModal\">{{_(\"Delete Book\")}}</button>\n    </div>\n    {% if book.data|length > 1 %}\n      <div class=\"text-center more-stuff\"><h4>{{_('Delete formats:')}}</h4>\n      {% for file in book.data %}\n        <div class=\"form-group\">\n          <button type=\"button\" class=\"btn btn-danger\" id=\"delete_format\" data-toggle=\"modal\" data-delete-id=\"{{ book.id }}\" data-delete-format=\"{{ file.format }}\" data-target=\"#deleteModal\">{{_('Delete')}} - {{file.format}}</button>\n        </div>\n      {% endfor %}\n      </div>\n    {% endif %}\n{% endif %}\n\n{%  if source_formats|length > 0 and conversion_formats|length > 0 %}\n  <div class=\"text-center more-stuff\"><h4>{{_('Convert book format:')}}</h4>\n      <form class=\"padded-bottom\" action=\"{{ url_for('editbook.convert_bookformat', book_id=book.id) }}\" method=\"post\" id=\"book_convert_frm\">\n          <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n          <div class=\"form-group\">\n              <div class=\"text-left\">\n                  <label class=\"control-label\" for=\"book_format_from\">{{_('Convert from:')}}</label>\n                  <select class=\"form-control\" name=\"book_format_from\" id=\"book_format_from\">\n                    <option disabled selected value>-- {{_('select an option')}} --</option>\n                    {% for format in source_formats %}\n                    <option>{{format|upper}}</option>\n                    {% endfor %}\n                  </select>\n                  <label class=\"control-label\" for=\"book_format_to\">{{_('Convert to:')}}</label>\n                  <select class=\"form-control\" name=\"book_format_to\" id=\"book_format_to\">\n                    <option disabled selected value>-- {{_('select an option')}} --</option>\n                    {% for format in conversion_formats %}\n                    <option>{{format|upper}}</option>\n                    {% endfor %}\n                  </select>\n              </div>\n          </div>\n          <button type=\"submit\" class=\"btn btn-primary\" id=\"btn-book-convert\" name=\"btn-book-convert\"><span class=\"glyphicon glyphicon-duplicate\"></span> {{_('Convert book')}}</button>\n      </form>\n  </div>\n{% endif %}\n\n  </div>\n<form role=\"form\" action=\"{{ url_for('editbook.edit_book', book_id=book.id) }}\" method=\"post\" enctype=\"multipart/form-data\" id=\"book_edit_frm\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n  <div class=\"col-sm-9 col-xs-12\">\n    <div class=\"form-group\">\n      <label for=\"book_title\">{{_('Book Title')}}</label>\n      <input type=\"text\" class=\"form-control\" name=\"book_title\" id=\"book_title\" value=\"{{book.title}}\">\n    </div>\n    <div class=\"text-center\">\n        <button type=\"button\" class=\"btn btn-default\" id=\"xchange\" ><span class=\"glyphicon glyphicon-arrow-up\"></span><span class=\"glyphicon glyphicon-arrow-down\"></span></button>\n    </div>\n    <div id=\"author_div\" class=\"form-group\">\n      <label for=\"bookAuthor\">{{_('Author')}}</label>\n      <input type=\"text\" class=\"form-control typeahead\" name=\"author_name\" id=\"bookAuthor\" value=\"{{' & '.join(authors)}}\" autocomplete=\"off\">\n    </div>\n\n    <div class=\"form-group\">\n      <label for=\"description\">{{_('Description')}}</label>\n      <textarea class=\"form-control\" name=\"description\" id=\"description\" rows=\"7\">{% if book.comments %}{{book.comments[0].text}}{%endif%}</textarea>\n    </div>\n\n    <div class=\"form-group\">\n      <label>{{_('Identifiers')}}</label>\n      <table class=\"table\" id=\"identifier-table\">\n\t{% for identifier in book.identifiers %}\n\t<tr>\n      <td><input type=\"text\" class=\"form-control\" name=\"identifier-type-{{identifier.type}}\" value=\"{{identifier.type}}\" required=\"required\" placeholder=\"{{_('Identifier Type')}}\"></td>\n\t  <td><input type=\"text\" class=\"form-control\" name=\"identifier-val-{{identifier.type}}\" value=\"{{identifier.val}}\" required=\"required\" placeholder=\"{{_('Identifier Value')}}\"></td>\n\t  <td><a class=\"btn btn-default\" onclick=\"removeIdentifierLine(this)\">{{_('Remove')}}</a></td>\n\t</tr>\n\t{% endfor %}\n      </table>\n      <a id=\"add-identifier-line\" class=\"btn btn-default\">{{_('Add Identifier')}}</a>\n    </div>\n\n    <div class=\"form-group\">\n      <label for=\"tags\">{{_('Tags')}}</label>\n      <input type=\"text\" class=\"form-control typeahead\" name=\"tags\" id=\"tags\" value=\"{% for tag in book.tags %}{{tag.name.strip()}}{% if not loop.last %}, {% endif %}{% endfor %}\">\n    </div>\n    <div class=\"form-group\">\n      <label for=\"series\">{{_('Series')}}</label>\n      <input type=\"text\" class=\"form-control typeahead\" name=\"series\" id=\"series\" value=\"{% if book.series %}{{book.series[0].name}}{% endif %}\">\n    </div>\n    <div class=\"form-group\">\n      <label for=\"series_index\">{{_('Series ID')}}</label>\n      <input type=\"number\" step=\"0.01\" min=\"0\" placeholder=\"1\" class=\"form-control\" name=\"series_index\" id=\"series_index\" value=\"{{book.series_index}}\">\n    </div>\n    <div class=\"form-group\">\n      <label for=\"rating\">{{_('Rating')}}</label>\n      <input type=\"number\"  name=\"rating\" id=\"rating\" class=\"rating input-lg\" data-clearable=\"\" value=\"{% if book.ratings %}{{(book.ratings[0].rating / 2)|int}}{% endif %}\">\n    </div>\n    {% if g.user.role_upload() and g.allow_upload %}\n    <div class=\"form-group\">\n      <label for=\"cover_url\">{{_('Fetch Cover from URL (JPEG - Image will be downloaded and stored in database)')}}</label>\n      <input type=\"text\" class=\"form-control\" name=\"cover_url\" id=\"cover_url\" value=\"\">\n    </div>\n      <div class=\"form-group\" aria-label=\"Upload cover from local drive\">\n        <label class=\"btn btn-primary btn-file\" for=\"btn-upload-cover\">{{ _('Upload Cover from Local Disk') }}</label>\n        <div class=\"upload-cover-input-text\" id=\"upload-cover\"></div>\n        <input id=\"btn-upload-cover\" name=\"btn-upload-cover\" type=\"file\" accept=\".jpg, .jpeg, .png, .webp\">\n      </div>\n    {% endif %}\n    <label for=\"pubdate\">{{_('Published Date')}}</label>\n    <div class=\"form-group input-group\">\n       <input type=\"text\" class=\"datepicker form-control\" name=\"pubdate\" id=\"pubdate\" value=\"{% if book.pubdate %}{{book.pubdate|formatdateinput}}{% endif %}\">\n       <input type=\"text\" class=\"form-control fake-input hidden\" id=\"fake_pubdate\" value=\"{% if book.pubdate %}{{book.pubdate|formatdate}}{% endif %}\">\n      <span class=\"input-group-btn\">\n        <button type=\"button\" id=\"pubdate_delete\" class=\"datepicker_delete btn btn-default\"><span class=\"glyphicon glyphicon-remove-circle\"></span></button>\n      </span>\n    </div>\n    <div class=\"form-group\">\n      <label for=\"publisher\">{{_('Publisher')}}</label>\n      <input type=\"text\" class=\"form-control typeahead\" name=\"publisher\" id=\"publisher\" value=\"{% if book.publishers|length > 0 %}{{book.publishers[0].name}}{% endif %}\">\n    </div>\n    <div class=\"form-group\">\n      <label for=\"languages\">{{_('Language')}}</label>\n      <input type=\"text\" class=\"form-control typeahead\" name=\"languages\" id=\"languages\" value=\"{% for language in book.languages %}{{language.language_name.strip()}}{% if not loop.last %}, {% endif %}{% endfor %}\">\n    </div>\n      {% if cc|length > 0 %}\n        {% for c in cc %}\n          <div class=\"form-group\">\n            <label for=\"{{ 'custom_column_' ~ c.id }}\">{{ c.name }}</label>\n            {% if c.datatype == 'bool' %}\n              <select name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\" class=\"form-control\">\n                <option value=\"None\" {% if book['custom_column_' ~ c.id]|length == 0 %} selected {% endif %}></option>\n                <option value=\"True\"  {% if book['custom_column_' ~ c.id]|length > 0 %}{% if book['custom_column_' ~ c.id][0].value ==true %}selected{% endif %}{% endif %} >{{_('Yes')}}</option>\n                <option value=\"False\"  {% if book['custom_column_' ~ c.id]|length > 0 %}{% if book['custom_column_' ~ c.id][0].value ==false %}selected{% endif %}{% endif %}>{{_('No')}}</option>\n              </select>\n            {% endif %}\n\n            {% if c.datatype == 'int' or c.datatype == 'float' %}\n\t    <input type=\"number\" step=\"{% if c.datatype == 'float' %}0.01{% else %}1{% endif %}\" class=\"form-control\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\" value=\"{% if book['custom_column_' ~ c.id]|length > 0 %}{{ book['custom_column_' ~ c.id][0].value }}{% endif %}\">\n            {% endif %}\n\n            {% if c.datatype == 'text' %}\n              <input type=\"text\" class=\"form-control\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\"\n              {% if book['custom_column_' ~ c.id]|length > 0 %}\n              value=\"{% for column in book['custom_column_' ~ c.id] %}{{ column.value.strip() }}{% if not loop.last %}, {% endif %}{% endfor %}\"{% endif %}>\n            {% endif %}\n\n            {% if c.datatype == 'series' %}\n              <input type=\"text\" class=\"form-control\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\"\n              {% if book['custom_column_' ~ c.id]|length > 0 %}\n                value=\"{% for column in book['custom_column_' ~ c.id] %} {{ '%s [%s]' % (book['custom_column_' ~ c.id][0].value, book['custom_column_' ~ c.id][0].extra|formatfloat(2)) }}{% if not loop.last %}, {% endif %}{% endfor %}\"\n              {% endif %}>\n            {% endif %}\n\n            {% if c.datatype == 'datetime' %}\n              <div class=\"input-group\">\n                <input type=\"text\" class=\"datepicker form-control\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\"\n                  {% if book['custom_column_' ~ c.id]|length > 0 %}\n                    value=\"{% if book['custom_column_' ~ c.id][0].value  %}{{ book['custom_column_' ~ c.id][0].value|formatdateinput}}{% endif %}\"\n                  {% endif %}>\n                <input type=\"text\" class=\"fake_custom_column_{{ c.id }} form-control fake-input hidden\" id=\"fake_pubdate_{{ c.id }}\"\n                  {% if book['custom_column_' ~ c.id]|length > 0 %}\n                    value=\"{% if book['custom_column_' ~ c.id][0].value %}{{book['custom_column_' ~ c.id][0].value|formatdate}}{% endif %}\"\n                  {% endif %}>\n                <span class=\"input-group-btn\">\n                  <button type=\"button\" id=\"{{ 'custom_column_' ~ c.id }}_delete\" class=\"datepicker_delete btn btn-default\"><span class=\"glyphicon glyphicon-remove-circle\"></span></button>\n                </span>\n              </div>\n            {% endif %}\n\n            {% if c.datatype == 'comments' %}\n              <textarea class=\"form-control tiny_editor\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\" rows=\"7\">{% if book['custom_column_' ~ c.id]|length > 0 %}{{book['custom_column_' ~ c.id][0].value}}{%endif%}</textarea>\n            {% endif %}\n            {% if c.datatype == 'enumeration' %}\n              <select class=\"form-control\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\">\n                  <option></option>\n                  {% for opt in c.get_display_dict().enum_values %}\n                    <option\n                      {% if book['custom_column_' ~ c.id]|length > 0 %}\n                        {% if book['custom_column_' ~ c.id][0].value == opt %}selected=\"selected\"{% endif %}\n                      {% endif %}\n                      >{{ opt }}</option>\n                  {% endfor %}\n              </select>\n            {% endif %}\n\n            {% if c.datatype == 'rating' %}\n              <input type=\"number\" min=\"1\" max=\"5\" step=\"0.5\" class=\"form-control\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\"\n                {% if book['custom_column_' ~ c.id]|length > 0 %}\n                    value=\"{{ '%.1f' %  (book['custom_column_' ~ c.id][0].value / 2) }}\"\n                {% endif %}>\n            {% endif %}\n          </div>\n        {% endfor %}\n      {% endif %}\n      {% if g.user.role_upload() and g.allow_upload %}\n          <div role=\"group\" aria-label=\"Upload new book format\">\n            <label class=\"btn btn-primary btn-file\" for=\"btn-upload-format\">{{ _('Upload Format') }}</label>\n            <div class=\"upload-format-input-text\" id=\"upload-format\"></div>\n            <input id=\"btn-upload-format\" name=\"btn-upload-format\" type=\"file\">\n          </div>\n      {% endif %}\n\n    <div class=\"checkbox\">\n      <label>\n        <input name=\"detail_view\" type=\"checkbox\" checked> {{_('View Book on Save')}}\n      </label>\n    </div>\n    <a href=\"#\" id=\"get_meta\" class=\"btn btn-default\" data-toggle=\"modal\" data-target=\"#metaModal\">{{_('Fetch Metadata')}}</a>\n    <button type=\"submit\" id=\"submit\" class=\"btn btn-default\">{{_('Save')}}</button>\n    <a href=\"{{ url_for('web.show_book', book_id=book.id) }}\" id=\"edit_cancel\" class=\"btn btn-default\">{{_('Cancel')}}</a>\n  </div>\n</form>\n\n{% endif %}\n{% endblock %}\n\n{% block modal %}\n{{ delete_book() }}\n{{ delete_confirm_modal() }}\n\n<div class=\"modal fade\" id=\"metaModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"metaModalLabel\">\n  <div class=\"modal-dialog modal-lg\" role=\"document\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\n        <h4 class=\"modal-title text-center\" id=\"metaModalLabel\">{{_('Fetch Metadata')}}</h4>\n        <form class=\"padded-bottom\" id=\"meta-search\">\n          <div class=\"input-group\">\n            <label class=\"sr-only\" for=\"keyword\">{{_('Keyword')}}</label>\n            <input type=\"text\" class=\"form-control\" id=\"keyword\" name=\"keyword\" placeholder=\"{{_(\"Search keyword\")}}\">\n            <span class=\"input-group-btn\">\n              <button type=\"submit\" class=\"btn btn-primary\" id=\"do-search\">{{_(\"Search\")}}</button>\n            </span>\n          </div>\n        </form>\n        <div class=\"text-center\"><strong>{{_('Click the cover to load metadata to the form')}}</strong></div>\n      </div>\n      <div class=\"modal-body\">\n        <div class=\"text-center padded-bottom\" id=\"metadata_provider\">\n        </div>\n\n        <div id=\"meta-info\">\n          {{_(\"Loading...\")}}\n        </div>\n      </div>\n      <div class=\"modal-footer\">\n        <button id=\"meta_close\" type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">{{_('Close')}}</button>\n      </div>\n    </div>\n  </div>\n</div>\n{% endblock %}\n\n{% block js %}\n<script type=\"text/template\" id=\"template-book-result\">\n  <li class=\"media\" data-related=\"<%= source.id %>\">\n    <img class=\"pull-left img-responsive\"\n         data-toggle=\"modal\"\n         data-target=\"#metaModal\"\n         src=\"<%= cover || \"{{ url_for('static', filename='img/academicpaper.svg') }}\" %>\"\n         alt=\"Cover\"\n    >\n    <div class=\"media-body\">\n      <h4 class=\"media-heading\">\n        <a class=\"meta_title\" href=\"<%= url %>\" target=\"_blank\" rel=\"noopener\"><%= title %></a>\n      </h4>\n      <p class=\"meta_author\">{{_('Author')}}\uff1a<%= authors.join(\" & \") %></p>\n      <% if (publisher) { %>\n        <p class=\"meta_publisher\">{{_('Publisher')}}\uff1a<%= publisher %></p>\n      <% } %>\n      <% if (description) { %>\n        <p class=\"meta_description\">{{_('Description')}}: <%= description %></p>\n      <% } %>\n      <p>{{_('Source')}}:\n        <a class=\"meta_source\" href=\"<%= source.link %>\" target=\"_blank\" rel=\"noopener\"><%= source.description %></a>\n      </p>\n    </div>\n  </li>\n</script>\n<script>\n  var i18nMsg = {\n    'loading': {{_('Loading...')|safe|tojson}},\n    'search_error': {{_('Search error!')|safe|tojson}},\n    'no_result': {{_('No Result(s) found! Please try another keyword.')|safe|tojson}},\n    'author': {{_('Author')|safe|tojson}},\n    'publisher': {{_('Publisher')|safe|tojson}},\n    'description': {{_('Description')|safe|tojson}},\n    'source': {{_('Source')|safe|tojson}},\n  };\n  var language = '{{ g.user.locale }}';\n\n  $(\"#add-identifier-line\").click(function() {\n    // create a random identifier type to have a valid name in form. This will not be used when dealing with the form\n    var rand_id = Math.floor(Math.random() * 1000000).toString();\n    var line = '<tr>';\n    line += '<td><input type=\"text\" class=\"form-control\" name=\"identifier-type-'+ rand_id +'\" required=\"required\" placeholder={{_('Identifier Type')|safe|tojson}}></td>';\n    line += '<td><input type=\"text\" class=\"form-control\" name=\"identifier-val-'+ rand_id +'\" required=\"required\" placeholder={{_('Identifier Value')|safe|tojson}}></td>';\n    line += '<td><a class=\"btn btn-default\" onclick=\"removeIdentifierLine(this)\">{{_('Remove')}}</a></td>';\n    line += '</tr>';\n    $(\"#identifier-table\").append(line);\n  });\n  function removeIdentifierLine(el) {\n    $(el).parent().parent().remove();\n  }\n\n</script>\n<script src=\"{{ url_for('static', filename='js/libs/typeahead.bundle.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-rating-input.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/get_meta.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/tinymce/tinymce.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-datepicker/bootstrap-datepicker.min.js') }}\"></script>\n{% if not g.user.locale == 'en' %}\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-datepicker/locales/bootstrap-datepicker.' + g.user.locale + '.min.js') }}\" charset=\"UTF-8\"></script>\n{% endif %}\n<script src=\"{{ url_for('static', filename='js/edit_books.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/fullscreen.js') }}\"></script>\n{% endblock %}\n{% block header %}\n<meta name=\"referrer\" content=\"never\">\n<link href=\"{{ url_for('static', filename='css/libs/typeahead.css') }}\" rel=\"stylesheet\" media=\"screen\">\n<link href=\"{{ url_for('static', filename='css/libs/bootstrap-datepicker3.min.css') }}\" rel=\"stylesheet\" media=\"screen\">\n{% endblock %}\n", "{% extends \"layout.html\" %}\n{% macro text_table_row(parameter, edit_text, show_text, validate, sort) -%}\n<th data-field=\"{{ parameter }}\" id=\"{{ parameter }}\"\n    {% if sort %}data-sortable=\"true\" {% endif %}\n    data-visible = \"{{visiblility.get(parameter)}}\"\n    data-escape=\"true\"\n    {% if g.user.role_edit() %}\n        data-editable-type=\"text\"\n        data-editable-url=\"{{ url_for('editbook.edit_list_book', param=parameter)}}\"\n        data-editable-title=\"{{ edit_text }}\"\n        data-edit=\"true\"\n        {% if validate %}data-edit-validate=\"{{ _('This Field is Required') }}\" {% endif %}\n    {% endif %}\n>{{ show_text }}</th>\n{%- endmacro %}\n\n{% macro book_checkbox_row(parameter, show_text, sort) -%}\n<th data-name=\"{{parameter}}\" data-field=\"{{parameter}}\"\n    {% if sort %}data-sortable=\"true\" {% endif %}\n    data-visible=\"{{visiblility.get(parameter)}}\"\n    data-formatter=\"bookCheckboxFormatter\">\n    {{show_text}}\n</th>\n{%- endmacro %}\n\n\n{% block header %}\n<link href=\"{{ url_for('static', filename='css/libs/bootstrap-table.min.css') }}\" rel=\"stylesheet\">\n<link href=\"{{ url_for('static', filename='css/libs/bootstrap-editable.css') }}\" rel=\"stylesheet\">\n<link href=\"{{ url_for('static', filename='css/libs/bootstrap-wysihtml5-0.0.3.css') }}\" rel=\"stylesheet\">\n{% endblock %}\n{% block body %}\n<h2 class=\"{{page}}\">{{_(title)}}</h2>\n      <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n      <div class=\"col-xs-12 col-sm-6\">\n        <div class=\"row form-group\">\n          <div class=\"btn btn-default disabled\" id=\"merge_books\" aria-disabled=\"true\">{{_('Merge selected books')}}</div>\n          <div class=\"btn btn-default disabled\" id=\"delete_selection\" aria-disabled=\"true\">{{_('Remove Selections')}}</div>\n        </div>\n        <div class=\"row form-group\">\n            <div class=\"btn btn-default disabled\" id=\"table_xchange\" ><span class=\"glyphicon glyphicon-arrow-up\"></span><span class=\"glyphicon glyphicon-arrow-down\"></span>{{_('Exchange author and title')}}</div>\n        </div>\n      </div>\n     <div class=\"filterheader col-xs-12 col-sm-6\">\n      <div class=\"row form-group\">\n        <input type=\"checkbox\" id=\"autoupdate_titlesort\" name=\"autoupdate_titlesort\" checked>\n        <label for=\"autoupdate_titlesort\">{{_('Update Title Sort automatically')}}</label>\n      </div>\n      <div class=\"row form-group\">\n        <input type=\"checkbox\" id=\"autoupdate_authorsort\" name=\"autoupdate_authorsort\" checked>\n        <label for=\"autoupdate_authorsort\">{{_('Update Author Sort automatically')}}</label>\n      </div>\n    </div>\n\n    <table id=\"books-table\" class=\"table table-no-bordered table-striped\"\n           data-url=\"{{url_for('web.list_books')}}\" data-locale=\"{{ g.user.locale }}\">\n      <thead>\n        <tr>\n          {% if g.user.role_edit() %}\n            <th data-field=\"state\" data-checkbox=\"true\" data-sortable=\"true\"></th>\n          {% endif %}\n            <th data-field=\"id\" id=\"id\" data-visible=\"false\" data-switchable=\"false\"></th>\n            {{ text_table_row('title', _('Enter Title'),_('Title'), true, true) }}\n            {{ text_table_row('sort', _('Enter Title Sort'),_('Title Sort'), false, true) }}\n            {{ text_table_row('author_sort', _('Enter Author Sort'),_('Author Sort'), false, true) }}\n            {{ text_table_row('authors', _('Enter Authors'),_('Authors'), true, true) }}\n            {{ text_table_row('tags', _('Enter Categories'),_('Categories'), false, true) }}\n            {{ text_table_row('series', _('Enter Series'),_('Series'), false, true) }}\n            <th data-field=\"series_index\" id=\"series_index\" data-visible=\"{{visiblility.get('series_index')}}\" data-edit-validate=\"{{ _('This Field is Required') }}\" data-sortable=\"true\" {% if g.user.role_edit() %} data-editable-type=\"number\" data-editable-placeholder=\"1\" data-editable-step=\"0.01\" data-editable-min=\"0\" data-editable-url=\"{{ url_for('editbook.edit_list_book', param='series_index')}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter Title')}}\"{% endif %}>{{_('Series Index')}}</th>\n            {{ text_table_row('languages', _('Enter Languages'),_('Languages'), false, true) }}\n            <!--th data-field=\"pubdate\" data-type=\"date\" data-visible=\"{{visiblility.get('pubdate')}}\" data-viewformat=\"dd.mm.yyyy\" id=\"pubdate\" data-sortable=\"true\">{{_('Publishing Date')}}</th-->\n            {{ text_table_row('publishers', _('Enter Publishers'),_('Publishers'), false, true) }}\n            <th data-field=\"comments\" id=\"comments\" data-escape=\"true\" data-editable-mode=\"popup\"  data-visible=\"{{visiblility.get('comments')}}\" data-sortable=\"false\" {% if g.user.role_edit() %} data-editable-type=\"wysihtml5\" data-editable-url=\"{{ url_for('editbook.edit_list_book', param='comments')}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter comments')}}\"{% endif %}>{{_('Comments')}}</th>\n            {% if g.user.check_visibility(32768) %}\n                {{ book_checkbox_row('is_archived', _('Archiv Status'), false)}}\n            {%  endif %}\n            {{ book_checkbox_row('read_status', _('Read Status'), false)}}\n            {% for c in cc %}\n              {% if c.datatype == \"int\" %}\n                <th data-field=\"custom_column_{{ c.id|string }}\" id=\"custom_column_{{ c.id|string }}\" data-visible=\"{{visiblility.get('custom_column_'+ c.id|string)}}\" data-sortable=\"false\" {% if g.user.role_edit() %} data-editable-type=\"number\" data-editable-placeholder=\"1\" data-editable-step=\"1\" data-editable-url=\"{{ url_for('editbook.edit_list_book', param='custom_column_'+ c.id|string)}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter ') + c.name}}\"{% endif %}>{{c.name}}</th>\n              {% elif c.datatype == \"rating\" %}\n                <th data-field=\"custom_column_{{ c.id|string }}\" id=\"custom_column_{{ c.id|string }}\" data-formatter=\"ratingFormatter\" data-visible=\"{{visiblility.get('custom_column_'+ c.id|string)}}\" data-sortable=\"false\" {% if g.user.role_edit() %} data-editable-type=\"number\" data-editable-placeholder=\"1\" data-editable-step=\"0.5\" data-editable-step=\"1\" data-editable-min=\"1\" data-editable-max=\"5\" data-editable-url=\"{{ url_for('editbook.edit_list_book', param='custom_column_'+ c.id|string)}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter ') + c.name}}\"{% endif %}>{{c.name}}</th>\n              {% elif c.datatype == \"float\" %}\n                <th data-field=\"custom_column_{{ c.id|string }}\" id=\"custom_column_{{ c.id|string }}\" data-visible=\"{{visiblility.get('custom_column_'+ c.id|string)}}\" data-sortable=\"false\" {% if g.user.role_edit() %} data-editable-type=\"number\" data-editable-placeholder=\"1\" data-editable-step=\"0.01\" data-editable-url=\"{{ url_for('editbook.edit_list_book', param='custom_column_'+ c.id|string)}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter ') + c.name}}\"{% endif %}>{{c.name}}</th>\n              {% elif c.datatype == \"enumeration\" %}\n                <th data-field=\"custom_column_{{ c.id|string }}\" id=\"custom_column_{{ c.id|string }}\" data-visible=\"{{visiblility.get('custom_column_'+ c.id|string)}}\" data-sortable=\"false\" {% if g.user.role_edit() %} data-editable-type=\"select\" data-editable-source={{ url_for('editbook.table_get_custom_enum', c_id=c.id)  }} data-editable-url=\"{{ url_for('editbook.edit_list_book', param='custom_column_'+ c.id|string)}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter ') + c.name}}\"{% endif %}>{{c.name}}</th>\n              {% elif c.datatype in [\"datetime\"] %}\n                  <!-- missing -->\n              {% elif c.datatype == \"text\" %}\n                 {{ text_table_row('custom_column_' + c.id|string, _('Enter ') + c.name, c.name, false, false) }}\n              {% elif c.datatype == \"comments\" %}\n                  <th data-field=\"custom_column_{{ c.id|string }}\" id=\"custom_column_{{ c.id|string }}\" data-escape=\"true\" data-editable-mode=\"popup\"  data-visible=\"{{visiblility.get('custom_column_'+ c.id|string)}}\" data-sortable=\"false\" {% if g.user.role_edit() %} data-editable-type=\"wysihtml5\" data-editable-url=\"{{ url_for('editbook.edit_list_book', param='custom_column_'+ c.id|string)}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter ') + c.name}}\"{% endif %}>{{c.name}}</th>\n              {% elif c.datatype == \"bool\" %}\n                  {{ book_checkbox_row('custom_column_' + c.id|string, c.name, false)}}\n              {% else %}\n                <!--{{ text_table_row('custom_column_' + c.id|string, _('Enter ') + c.name, c.name, false, false) }} -->\n              {% endif %}\n            {% endfor %}\n          {% if g.user.role_delete_books() and g.user.role_edit()%}\n            <th data-align=\"right\" data-formatter=\"EbookActions\" data-switchable=\"false\">{{_('Delete')}}</th>\n          {% endif %}\n        </tr>\n      </thead>\n    </table>\n{% endblock %}\n{% block modal %}\n{{ delete_book() }}\n{% if g.user.role_edit() %}\n<div class=\"modal fade\" id=\"mergeModal\" role=\"dialog\" aria-labelledby=\"metaMergeLabel\">\n  <div class=\"modal-dialog\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header bg-danger text-center\">\n          <span>{{_('Are you really sure?')}}</span>\n      </div>\n        <div class=\"modal-body\">\n          <p></p>\n            <div class=\"text-left\">{{_('Books with Title will be merged from:')}}</div>\n          <p></p>\n            <div class=\"text-left\" id=\"merge_from\"></div>\n          <p></p>\n            <div class=\"text-left\">{{_('Into Book with Title:')}}</div>\n          <p></p>\n            <div class=\"text-left\" id=\"merge_to\"></div>\n        </div>\n      <div class=\"modal-footer\">\n        <input id=\"merge_confirm\"  type=\"button\" class=\"btn btn-danger\" value=\"{{_('Merge')}}\" name=\"merge_confirm\" id=\"merge_confirm\" data-dismiss=\"modal\">\n        <button id=\"merge_abort\" type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">{{_('Cancel')}}</button>\n      </div>\n    </div>\n  </div>\n</div>\n{% endif %}\n\n{% endblock %}\n{% block js %}\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-table/bootstrap-table.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-table/bootstrap-table-locale-all.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-table/bootstrap-table-editable.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-table/bootstrap-editable.min.js') }}\"></script>\n{% if not g.user.locale == 'en' %}\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-table/locale/bootstrap-table-' + g.user.locale + '.min.js') }}\" charset=\"UTF-8\"></script>\n{% endif %}\n<script src=\"{{ url_for('static', filename='js/libs/wysihtml5-0.3.0.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-wysihtml5-0.0.3.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/wysihtml5-0.0.3.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/table.js') }}\"></script>\n{% endblock %}\n", "{% extends is_xhr|yesno(\"fragment.html\", \"layout.html\") %}\n{% block body %}\n<div class=\"single\">\n  <div class=\"row\">\n    <div class=\"col-sm-3 col-lg-3 col-xs-5\">\n      <div class=\"cover\">\n          <img id=\"detailcover\" title=\"{{entry.title}}\" src=\"{{ url_for('web.get_cover', book_id=entry.id, edit=1|uuidfilter) }}\" alt=\"{{ entry.title }}\" />\n      </div>\n    </div>\n    <div class=\"col-sm-9 col-lg-9 book-meta\">\n      <div class=\"btn-toolbar\" role=\"toolbar\">\n        <div class=\"btn-group\" role=\"group\" aria-label=\"Download, send to Kindle, reading\">\n          {% if g.user.role_download() %}\n            {% if entry.data|length %}\n            <div class=\"btn-group\" role=\"group\">\n                {% if entry.data|length < 2 %}\n                  <button id=\"Download\" type=\"button\" class=\"btn btn-primary\">\n                    {{_('Download')}} :\n                  </button>\n                  {% for format in entry.data %}\n                  <a href=\"{{ url_for('web.download_link', book_id=entry.id, book_format=format.format|lower, anyname=entry.id|string+'.'+format.format|lower) }}\" id=\"btnGroupDrop1{{format.format|lower}}\" class=\"btn btn-primary\" role=\"button\">\n                    <span class=\"glyphicon glyphicon-download\"></span>{{format.format}} ({{ format.uncompressed_size|filesizeformat }})\n                  </a>\n                  {% endfor %}\n                {% else %}\n                  <button id=\"btnGroupDrop1\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"glyphicon glyphicon-download\"></span> {{_('Download')}}\n                    <span class=\"caret\"></span>\n                  </button>\n                  <ul class=\"dropdown-menu\" aria-labelledby=\"btnGroupDrop1\">\n                  {% for format in entry.data %}\n                    <li><a href=\"{{ url_for('web.download_link', book_id=entry.id, book_format=format.format|lower, anyname=entry.id|string+'.'+format.format|lower) }}\">{{format.format}} ({{ format.uncompressed_size|filesizeformat }})</a></li>\n                  {% endfor %}\n                  </ul>\n                {% endif %}\n            </div>\n            {% endif %}\n          {% endif %}\n            {% if g.user.kindle_mail and entry.kindle_list %}\n              {% if entry.kindle_list.__len__() == 1 %}\n                <div id=\"sendbtn\" data-action=\"{{url_for('web.send_to_kindle', book_id=entry.id, book_format=entry.kindle_list[0]['format'], convert=entry.kindle_list[0]['convert'])}}\" data-text=\"{{_('Send to Kindle')}}\" class=\"btn btn-primary postAction\" role=\"button\"><span class=\"glyphicon glyphicon-send\"></span> {{entry.kindle_list[0]['text']}}</div>\n              {% else %}\n                <div class=\"btn-group\" role=\"group\">\n                  <button id=\"sendbtn2\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"glyphicon glyphicon-send\"></span>{{_('Send to Kindle')}}\n                    <span class=\"caret\"></span>\n                  </button>\n                    <ul class=\"dropdown-menu\" aria-labelledby=\"send-to-kindle\">\n                    {% for format in entry.kindle_list %}\n                      <li><a class=\"postAction\" data-action=\"{{url_for('web.send_to_kindle', book_id=entry.id, book_format=format['format'], convert=format['convert'])}}\">{{format['text']}}</a></li>\n                    {%endfor%}\n                    </ul>\n                </div>\n              {% endif %}\n            {% endif %}\n          {% if entry.reader_list and g.user.role_viewer() %}\n              <div class=\"btn-group\" role=\"group\">\n              {% if entry.reader_list|length > 1 %}\n                <button id=\"read-in-browser\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                  <span class=\"glyphicon glyphicon-book\"></span> {{_('Read in Browser')}}\n                  <span class=\"caret\"></span>\n                </button>\n                    <ul class=\"dropdown-menu\" aria-labelledby=\"read-in-browser\">\n                    {% for format in entry.reader_list %}\n                      <li><a target=\"_blank\" href=\"{{ url_for('web.read_book', book_id=entry.id, book_format=format) }}\">{{format}}</a></li>\n                    {%endfor%}\n                    </ul>\n                {% else %}\n                  <a target=\"_blank\" href=\"{{url_for('web.read_book', book_id=entry.id, book_format=entry.reader_list[0])}}\" id=\"readbtn\" class=\"btn btn-primary\" role=\"button\"><span class=\"glyphicon glyphicon-book\"></span> {{_('Read in Browser')}} - {{entry.reader_list[0]}}</a>\n                {% endif %}\n              </div>\n            {% endif %}\n            {% if entry.audioentries|length > 0 and g.user.role_viewer() %}\n              <div class=\"btn-group\" role=\"group\">\n              {% if entry.audioentries|length > 1 %}\n                <button id=\"listen-in-browser\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                  <span class=\"glyphicon glyphicon-music\"></span> {{_('Listen in Browser')}}\n                  <span class=\"caret\"></span>\n                </button>\n                    <ul class=\"dropdown-menu\" aria-labelledby=\"listen-in-browser\">\n                    {% for format in entry.reader_list %}\n                      <li><a target=\"_blank\" href=\"{{ url_for('web.read_book', book_id=entry.id, book_format=format) }}\">{{format}}</a></li>\n                    {%endfor%}\n                    </ul>\n                  <ul class=\"dropdown-menu\" aria-labelledby=\"listen-in-browser\">\n\n              {% for format in entry.data %}\n                  {% if format.format|lower in entry.audioentries %}\n                    <li><a target=\"_blank\" href=\"{{ url_for('web.read_book', book_id=entry.id, book_format=format.format|lower) }}\">{{format.format|lower }}</a></li>\n                    {% endif %}\n              {% endfor %}\n                  </ul>\n                {% else %}\n                  <a target=\"_blank\" href=\"{{url_for('web.read_book', book_id=entry.id, book_format=entry.audioentries[0])}}\" id=\"listenbtn\" class=\"btn btn-primary\" role=\"button\"><span class=\"glyphicon glyphicon-music\"></span> {{_('Listen in Browser')}} - {{entry.audioentries[0]}}</a>\n                {% endif %}\n              </div>\n            {% endif %}\n        </div>\n      </div>\n      <h2 id=\"title\">{{entry.title}}</h2>\n      <p class=\"author\">\n          {% for author in entry.ordered_authors %}\n            <a href=\"{{url_for('web.books_list',  data='author', sort_param='stored', book_id=author.id ) }}\">{{author.name.replace('|',',')}}</a>\n            {% if not loop.last %}\n              &amp;\n            {% endif %}\n          {% endfor %}\n        </p>\n      {% if entry.ratings.__len__() > 0 %}\n        <div class=\"rating\">\n        <p>\n          {% for number in range((entry.ratings[0].rating/2)|int(2)) %}\n            <span class=\"glyphicon glyphicon-star good\"></span>\n            {% if loop.last and loop.index < 5 %}\n              {% for numer in range(5 - loop.index) %}\n                <span class=\"glyphicon glyphicon-star-empty\"></span>\n              {% endfor %}\n            {% endif %}\n          {% endfor %}\n        </p>\n        </div>\n      {% endif %}\n      {% if entry.series|length > 0 %}\n          <p>{{_(\"Book %(index)s of %(range)s\", index=entry.series_index | formatfloat(2), range=(url_for('web.books_list', data='series', sort_param='stored', book_id=entry.series[0].id)|escapedlink(entry.series[0].name))|safe)}}</p>\n\n      {% endif %}\n\n      {% if entry.languages.__len__() > 0 %}\n       <div class=\"languages\">\n       <p>\n      <span class=\"label label-default\">{{_('Language')}}: {% for language in entry.languages %}{{language.language_name}}{% if not loop.last %}, {% endif %}{% endfor %}</span>\n      </p>\n      </div>\n      {% endif %}\n\n      {% if entry.identifiers|length > 0 %}\n      <div class=\"identifiers\">\n        <p>\n        <span class=\"glyphicon glyphicon-link\"></span>\n        {% for identifier in entry.identifiers %}\n          <a href=\"{{identifier}}\" target=\"_blank\" class=\"btn btn-xs btn-success\" role=\"button\">{{identifier.formatType()}}</a>\n        {%endfor%}\n      </p>\n      </div>\n      {% endif %}\n\n      {% if entry.tags|length > 0 %}\n\n      <div class=\"tags\">\n      <p>\n        <span class=\"glyphicon glyphicon-tags\"></span>\n\n        {% for tag in entry.tags %}\n          <a href=\"{{ url_for('web.books_list', data='category', sort_param='stored', book_id=tag.id) }}\" class=\"btn btn-xs btn-info\" role=\"button\">{{tag.name}}</a>\n        {%endfor%}\n      </p>\n\n      </div>\n      {% endif %}\n\n      {% if entry.publishers|length > 0 %}\n      <div class=\"publishers\">\n        <p>\n          <span>{{_('Publisher')}}:\n              <a href=\"{{url_for('web.books_list', data='publisher', sort_param='stored', book_id=entry.publishers[0].id ) }}\">{{entry.publishers[0].name}}</a>\n          </span>\n        </p>\n      </div>\n      {% endif %}\n\n      {% if (entry.pubdate|string)[:10] != '0101-01-01' %}\n      <div class=\"publishing-date\">\n        <p>{{_('Published')}}: {{entry.pubdate|formatdate}} </p>\n      </div>\n      {% endif %}\n      {% if cc|length > 0 %}\n\n\n        {% for c in cc %}\n        <div class=\"real_custom_columns\">\n          {% if entry['custom_column_' ~ c.id]|length > 0 %}\n            {{ c.name }}:\n            {% for column in entry['custom_column_' ~ c.id] %}\n              {% if c.datatype == 'rating' %}\n                {{ (column.value / 2)|formatfloat }}\n              {% else %}\n                {% if c.datatype == 'bool' %}\n                  {% if column.value == true %}\n                    <span class=\"glyphicon glyphicon-ok\"></span>\n                  {% else %}\n                    <span class=\"glyphicon glyphicon-remove\"></span>\n                  {% endif %}\n                {% else %}\n                {% if c.datatype == 'float' %}\n                  {{ column.value|formatfloat(2) }}\n                {% elif c.datatype == 'datetime' %}\n                  {{ column.value|formatdate }}\n                {% elif c.datatype == 'comments' %}\n                  {{column.value|safe}}\n                {% elif c.datatype == 'series' %}\n                  {{ '%s [%s]' % (column.value, column.extra|formatfloat(2)) }}\n                {% elif c.datatype == 'text' %}\n                    {{ column.value.strip() }}{% if not loop.last %}, {% endif %}\n                {% else %}\n                  {{ column.value }}\n                {% endif %}\n                {% endif %}\n              {% endif %}\n            {% endfor %}\n          {% endif %}\n        </div>\n        {% endfor %}\n      {% endif %}\n      {% if not g.user.is_anonymous %}\n\n        <div class=\"custom_columns\">\n          <p>\n          <form id=\"have_read_form\" action=\"{{ url_for('web.toggle_read', book_id=entry.id)}}\" method=\"POST\">\n            <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n            <label class=\"block-label\">\n              <input id=\"have_read_cb\" data-checked=\"{{_('Mark As Unread')}}\" data-unchecked=\"{{_('Mark As Read')}}\" type=\"checkbox\" {% if entry.read_status %}checked{% endif %} >\n              <span>{{_('Read')}}</span>\n            </label>\n          </form>\n          </p>\n          {% if g.user.check_visibility(32768) %}\n          <p>\n            <form id=\"archived_form\" action=\"{{ url_for('web.toggle_archived', book_id=entry.id)}}\" method=\"POST\">\n              <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n              <label class=\"block-label\">\n                <input id=\"archived_cb\" data-checked=\"{{_('Restore from archive')}}\" data-unchecked=\"{{_('Add to archive')}}\" type=\"checkbox\" {% if entry.is_archived %}checked{% endif %} >\n                <span>{{_('Archived')}}</span>\n              </label>\n            </form>\n          </p>\n          {% endif %}\n        </div>\n      {% endif %}\n\n\n      {% if entry.comments|length > 0 and entry.comments[0].text|length > 0%}\n        <div class=\"comments\">\n            <h3 id=\"decription\">{{_('Description:')}}</h3>\n            {{entry.comments[0].text|safe}}\n        </div>\n      {% endif %}\n\n\n      <div class=\"more-stuff\">\n\n      {% if g.user.is_authenticated %}\n      {% if g.user.shelf.all() or g.shelves_access %}\n      <div id=\"shelf-actions\" class=\"btn-toolbar\" role=\"toolbar\">\n        <div class=\"btn-group\" role=\"group\" aria-label=\"Add to shelves\">\n          <button id=\"add-to-shelf\" type=\"button\" class=\"btn btn-primary btn-sm dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            <span class=\"glyphicon glyphicon-list\"></span> {{_('Add to shelf')}}\n            <span class=\"caret\"></span>\n          </button>\n          <ul id=\"add-to-shelves\" class=\"dropdown-menu\" aria-labelledby=\"add-to-shelf\">\n            {% for shelf in g.shelves_access %}\n              {% if not shelf.id in books_shelfs and ( not shelf.is_public or g.user.role_edit_shelfs() ) %}\n                <li>\n                  <a data-href=\"{{ url_for('shelf.add_to_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                     data-remove-href=\"{{ url_for('shelf.remove_from_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                     data-shelf-action=\"add\"\n                  >\n                    {{shelf.name}}{% if shelf.is_public == 1 %} {{_('(Public)')}}{% endif %}\n                  </a>\n                </li>\n              {% endif %}\n            {%endfor%}\n          </ul>\n        </div>\n        <div id=\"remove-from-shelves\" class=\"btn-group\" role=\"group\" aria-label=\"Remove from shelves\">\n          {% if books_shelfs %}\n            {% for shelf in g.shelves_access %}\n              {% if shelf.id in books_shelfs %}\n                <a data-href=\"{{ url_for('shelf.remove_from_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                   data-add-href=\"{{ url_for('shelf.add_to_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                   class=\"btn btn-sm btn-default\" role=\"button\" data-shelf-action=\"remove\"\n                >\n                  <span {% if not shelf.is_public or g.user.role_edit_shelfs() %}\n                        class=\"glyphicon glyphicon-remove\"\n                        {% endif %}></span> {{shelf.name}}{% if shelf.is_public == 1 %} {{_('(Public)')}}{% endif %}\n                </a>\n              {% endif %}\n            {%endfor%}\n          {% endif %}\n        </div>\n        <div id=\"shelf-action-errors\" class=\"pull-left\" role=\"alert\"></div>\n      </div>\n      {% endif %}\n\n      {% endif %}\n      {% if g.user.role_edit() %}\n      <div class=\"btn-toolbar\" role=\"toolbar\">\n        <div class=\"btn-group\" role=\"group\" aria-label=\"Edit/Delete book\">\n          <a href=\"{{ url_for('editbook.edit_book', book_id=entry.id) }}\" class=\"btn btn-sm btn-primary\" id=\"edit_book\" role=\"button\"><span class=\"glyphicon glyphicon-edit\"></span> {{_('Edit Metadata')}}</a>\n        </div>\n      </div>\n      {% endif %}\n      </div>\n\n    </div>\n  </div>\n</div>\n{% endblock %}\n\n{% block js %}\n<script type=\"text/template\" id=\"template-shelf-add\">\n  <li>\n    <a data-href=\"<%= add %>\" data-remove-href=\"<%= remove %>\" data-shelf-action=\"add\">\n      <%= content %>\n    </a>\n  </li>\n</script>\n<script type=\"text/template\" id=\"template-shelf-remove\">\n  <a data-href=\"<%= remove %>\" data-add-href=\"<%= add %>\" class=\"btn btn-sm btn-default\" data-shelf-action=\"remove\">\n    <span class=\"glyphicon glyphicon-remove\"></span> <%= content %>\n  </a>\n</script>\n<script src=\"{{ url_for('static', filename='js/details.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/fullscreen.js') }}\"></script>\n{% endblock %}\n", "{% from 'modal_dialogs.html' import restrict_modal, delete_book, filechooser_modal, delete_confirm_modal, change_confirm_modal %}\n<!DOCTYPE html>\n<html lang=\"{{ g.user.locale }}\">\n  <head>\n    <title>{{instance}} | {{title}}</title>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n\n    <!-- Bootstrap -->\n    <link rel=\"apple-touch-icon\" sizes=\"140x140\" href=\"{{ url_for('static', filename='favicon.ico') }}\">\n    <link rel=\"shortcut icon\" href=\"{{ url_for('static', filename='favicon.ico') }}\">\n    <link href=\"{{ url_for('static', filename='css/libs/bootstrap.min.css') }}\" rel=\"stylesheet\" media=\"screen\">\n    {% block header %}{% endblock %}\n    <link href=\"{{ url_for('static', filename='css/style.css') }}\" rel=\"stylesheet\" media=\"screen\">\n    <link href=\"{{ url_for('static', filename='css/upload.css') }}\" rel=\"stylesheet\" media=\"screen\">\n    {% if g.current_theme == 1 %}\n       <link href=\"{{ url_for('static', filename='css/caliBlur.css') }}\" rel=\"stylesheet\" media=\"screen\">\n       <link href=\"{{ url_for('static', filename='css/caliBlur_override.css') }}\" rel=\"stylesheet\" media=\"screen\">\n    {% endif %}\n    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->\n    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->\n    <!--[if lt IE 9]>\n      <script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"></script>\n      <script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"></script>\n    <![endif]-->\n  </head>\n  <body class=\"{{ page }} {{ bodyClass }}\" data-text=\"{{_('Home')}}\" data-textback=\"{{_('Back')}}\">\n    <!-- Static navbar -->\n    <div class=\"navbar navbar-default navbar-static-top\" role=\"navigation\">\n      <div class=\"container-fluid\">\n        <div class=\"navbar-header\">\n          <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\">\n            <span class=\"sr-only\">{{_('Toggle Navigation')}}</span>\n            <span class=\"icon-bar\"></span>\n            <span class=\"icon-bar\"></span>\n            <span class=\"icon-bar\"></span>\n          </button>\n          <a class=\"navbar-brand\" href=\"{{url_for('web.index')}}\">{{instance}}</a>\n        </div>\n        {% if g.user.is_authenticated or g.allow_anonymous %}\n          <form class=\"navbar-form navbar-left\" role=\"search\" action=\"{{url_for('web.search')}}\" method=\"GET\">\n            <div class=\"form-group input-group input-group-sm\">\n              <label for=\"query\" class=\"sr-only\">{{_('Search')}}</label>\n              <input type=\"text\" class=\"form-control\" id=\"query\" name=\"query\" placeholder=\"{{_('Search Library')}}\" value=\"{{searchterm}}\">\n              <span class=\"input-group-btn\">\n                <button type=\"submit\" id=\"query_submit\" class=\"btn btn-default\">{{_('Search')}}</button>\n              </span>\n            </div>\n          </form>\n        {% endif %}\n        <div class=\"navbar-collapse collapse\">\n          {% if g.user.is_authenticated or g.allow_anonymous %}\n          <ul class=\"nav navbar-nav \">\n            <li><a href=\"{{url_for('web.advanced_search')}}\" id=\"advanced_search\"><span class=\"glyphicon glyphicon-search\"></span><span class=\"hidden-sm\"> {{_('Advanced Search')}}</span></a></li>\n          </ul>\n          {% endif %}\n          <ul class=\"nav navbar-nav navbar-right\" id=\"main-nav\">\n            {% if g.user.is_authenticated or g.allow_anonymous %}\n              {% if g.user.role_upload() and g.allow_upload %}\n                  <li>\n                    <form id=\"form-upload\" class=\"navbar-form\" action=\"{{ url_for('editbook.upload') }}\" data-title=\"{{_('Uploading...')}}\" data-footer=\"{{_('Close')}}\" data-failed=\"{{_('Error')}}\" data-message=\"{{_('Upload done, processing, please wait...')}}\" method=\"post\" enctype=\"multipart/form-data\">\n                      <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n                      <div class=\"form-group\">\n                        <span class=\"btn btn-default btn-file\">{{_('Upload')}}<input id=\"btn-upload\" name=\"btn-upload\"\n                        type=\"file\" accept=\"{% for format in accept %}.{% if format != ''%}{{format}}{% else %}*{% endif %}{{ ',' if not loop.last }}{% endfor %}\" multiple></span>\n                      </div>\n                    </form>\n                  </li>\n              {% endif %}\n              {% if not g.user.is_anonymous %}\n                <li><a id=\"top_tasks\" href=\"{{url_for('web.get_tasks_status')}}\"><span class=\"glyphicon glyphicon-tasks\"></span> <span class=\"hidden-sm\">{{_('Tasks')}}</span></a></li>\n              {% endif %}\n              {% if g.user.role_admin() %}\n                <li><a id=\"top_admin\" data-text=\"{{_('Settings')}}\" href=\"{{url_for('admin.admin')}}\"><span class=\"glyphicon glyphicon-dashboard\"></span> <span class=\"hidden-sm\">{{_('Admin')}}</span></a></li>\n              {% endif %}\n              <li><a id=\"top_user\" data-text=\"{{_('Account')}}\" href=\"{{url_for('web.profile')}}\"><span class=\"glyphicon glyphicon-user\"></span> <span class=\"hidden-sm\">{{g.user.name}}</span></a></li>\n              {% if not g.user.is_anonymous %}\n              <li><a id=\"logout\" href=\"{{url_for('web.logout')}}\"><span class=\"glyphicon glyphicon-log-out\"></span> <span class=\"hidden-sm\">{{_('Logout')}}</span></a></li>\n              {% endif %}\n            {% endif %}\n            {% if g.allow_registration and not g.user.is_authenticated %}\n            <li><a id=\"login\" href=\"{{url_for('web.login')}}\"><span class=\"glyphicon glyphicon-log-in\"></span> {{_('Login')}}</a></li>\n            <li><a id=\"register\" href=\"{{url_for('web.register')}}\"><span class=\"glyphicon glyphicon-user\"></span> {{_('Register')}}</a></li>\n            {% endif %}\n          </ul>\n        </div><!--/.nav-collapse -->\n      </div>\n    </div>\n    {% for message in get_flashed_messages(with_categories=True) %}\n      {%if message[0] == \"error\" %}\n      <div class=\"row-fluid text-center\" >\n        <div id=\"flash_danger\" class=\"alert alert-danger\">{{ message[1] }}</div>\n      </div>\n      {%endif%}\n      {%if message[0] == \"info\" %}\n      <div class=\"row-fluid text-center\">\n        <div id=\"flash_info\" class=\"alert alert-info\">{{ message[1] }}</div>\n      </div>\n      {%endif%}\n      {%if message[0] == \"warning\" %}\n      <div class=\"row-fluid text-center\">\n        <div id=\"flash_warning\" class=\"alert alert-warning\">{{ message[1] }}</div>\n      </div>\n      {%endif%}\n      {%if message[0] == \"success\" %}\n      <div class=\"row-fluid text-center\">\n        <div id=\"flash_success\" class=\"alert alert-success\">{{ message[1] }}</div>\n      </div>\n      {%endif%}\n    {% endfor %}\n    {% block flash %}{% endblock %}\n    {% if g.current_theme == 1 %}\n      <div id=\"loader\" hidden=\"true\">\n        <center>\n          <h3>{{_('Uploading...')}}</h3>\n          <span>{{_(\"Please do not refresh the page\")}}</span>.\n        </center>\n      </div>\n    {%endif%}\n    <div class=\"container-fluid\">\n      <div class=\"row-fluid\">\n        {% if g.user.is_authenticated or g.allow_anonymous %}\n        <div class=\"col-sm-2\">\n          <nav class=\"navigation\">\n            <ul class=\"list-unstyled\" id=\"scnd-nav\" intent in-standard-append=\"nav.navigation\" in-mobile-after=\"#main-nav\" in-mobile-class=\"nav navbar-nav\">\n              <li class=\"nav-head hidden-xs\">{{_('Browse')}}</li>\n              {% for element in sidebar %}\n                {% if g.user.check_visibility(element['visibility']) and element['public'] %}\n                    <li id=\"nav_{{element['id']}}\" {% if page == element['page'] %}class=\"active\"{% endif %}><a href=\"{{url_for(element['link'], data=element['page'], sort_param='stored')}}\"><span class=\"glyphicon {{element['glyph']}}\"></span> {{_(element['text'])}}</a></li>\n                {% endif %}\n              {% endfor %}\n              {% if g.user.is_authenticated or g.allow_anonymous %}\n                <li class=\"nav-head hidden-xs public-shelves\">{{_('Shelves')}}</li>\n                {% for shelf in g.shelves_access %}\n                  <li><a href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id)}}\"><span class=\"glyphicon glyphicon-list shelf\"></span> {{shelf.name|shortentitle(40)}}{% if shelf.is_public == 1 %} {{_('(Public)')}}{% endif %}</a></li>\n                {% endfor %}\n              {% if not g.user.is_anonymous %}\n                <li id=\"nav_createshelf\" class=\"create-shelf\"><a href=\"{{url_for('shelf.create_shelf')}}\">{{_('Create a Shelf')}}</a></li>\n                <li id=\"nav_about\" {% if page == 'stat' %}class=\"active\"{% endif %}><a href=\"{{url_for('about.stats')}}\"><span class=\"glyphicon glyphicon-info-sign\"></span> {{_('About')}}</a></li>\n              {% endif %}\n              {% endif %}\n\n            </ul>\n          </nav>\n        </div>\n        {% endif %}\n        <div class=\"col-sm-10\">\n          {% block body %}{% endblock %}\n          {% if pagination and (pagination.has_next or pagination.has_prev) %}\n            <div class=\"pagination\">\n              {% if pagination.has_prev %}\n              <li class=\"page-item page-previous\"><a class=\"page-link\" aria-label=\"next page\" href=\"{{ (pagination.page - 1)|url_for_other_page\n                }}\">&laquo; {{_('Previous')}}</a></li>\n              {% endif %}\n            {% for page in pagination.iter_pages() %}\n              {% if page %}\n                {% if page != pagination.page %}\n                  <li class=\"page-item\"><a class=\"page-link\" aria-label=\"to page {{ page }}\" href=\"{{ (page)|url_for_other_page }}\">{{ page }}</a></li>\n                {% else %}\n                  <li class=\"page-item active\"><a class=\"page-link\" aria-label=\"to page {{ page }}\" href=\"{{ (page)|url_for_other_page }}\">{{ page }}</a></li>\n                {% endif %}\n              {% else %}\n                <li class=\"page-item page-last-separator disabled\"><a class=\"page-link\" aria-label=\"\">\u2026</a></li>\n              {% endif %}\n            {% endfor %}\n            {% if pagination.has_next %}\n              <li class=\"page-item page-next\"><a class=\"page-link next\" aria-label=\"next page\" href=\"{{ (pagination.page + 1)|url_for_other_page\n                }}\">{{_('Next')}} &raquo;</a></li>\n            {% endif %}\n            </div>\n          {% endif %}\n      </div>\n    </div>\n  </div>\n    <div class=\"modal fade\" id=\"bookDetailsModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"bookDetailsModalLabel\">\n      <div class=\"modal-dialog modal-lg\" role=\"document\">\n        <div class=\"modal-content\">\n          <div class=\"modal-header\">\n            <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\n            <h4 class=\"modal-title\" id=\"bookDetailsModalLabel\">{{_('Book Details')}}</h4>\n          </div>\n          <div class=\"modal-body\">...</div>\n          <div class=\"modal-footer\">\n            <button type=\"button\" id=\"details_close\" class=\"btn btn-default\" data-dismiss=\"modal\">{{_('Close')}}</button>\n          </div>\n        </div>\n      </div>\n    </div>\n    {% block modal %}{% endblock %}\n    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->\n    <script src=\"{{ url_for('static', filename='js/libs/jquery.min.js') }}\"></script>\n    <!-- Include all compiled plugins (below), or include individual files as needed -->\n    <script src=\"{{ url_for('static', filename='js/libs/bootstrap.min.js') }}\"></script>\n    <script src=\"{{ url_for('static', filename='js/libs/underscore-umd-min.js') }}\"></script>\n    <script src=\"{{ url_for('static', filename='js/libs/intention.min.js') }}\"></script>\n    <script src=\"{{ url_for('static', filename='js/libs/context.min.js') }}\"></script>\n    <script src=\"{{ url_for('static', filename='js/libs/plugins.js') }}\"></script>\n    <script src=\"{{ url_for('static', filename='js/libs/jquery.form.min.js') }}\"></script>\n    <script src=\"{{ url_for('static', filename='js/uploadprogress.js') }}\"> </script>\n    <script src=\"{{ url_for('static', filename='js/main.js') }}\"></script>\n    {% if g.current_theme == 1 %}\n      <script src=\"{{ url_for('static', filename='js/libs/jquery.visible.min.js') }}\"></script>\n      <script src=\"{{ url_for('static', filename='js/libs/compromise.min.js') }}\"></script>\n      <script src=\"{{ url_for('static', filename='js/libs/readmore.min.js') }}\"></script>\n      <script src=\"{{ url_for('static', filename='js/caliBlur.js') }}\"></script>\n    {% endif %}\n    {% block js %}{% endblock %}\n  </body>\n</html>\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2020 OzzieIsaacs\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport base64\nimport binascii\n\nfrom sqlalchemy.sql.expression import func\nfrom werkzeug.security import check_password_hash\nfrom flask_login import login_required, login_user\n\nfrom . import lm, ub, config, constants, services\n\ntry:\n    from functools import wraps\nexcept ImportError:\n    pass  # We're not using Python 3\n\ndef login_required_if_no_ano(func):\n    @wraps(func)\n    def decorated_view(*args, **kwargs):\n        if config.config_anonbrowse == 1:\n            return func(*args, **kwargs)\n        return login_required(func)(*args, **kwargs)\n\n    return decorated_view\n\n\ndef _fetch_user_by_name(username):\n    return ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first()\n\n\n@lm.user_loader\ndef load_user(user_id):\n    return ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n\n\n@lm.request_loader\ndef load_user_from_request(request):\n    if config.config_allow_reverse_proxy_header_login:\n        rp_header_name = config.config_reverse_proxy_login_header_name\n        if rp_header_name:\n            rp_header_username = request.headers.get(rp_header_name)\n            if rp_header_username:\n                user = _fetch_user_by_name(rp_header_username)\n                if user:\n                    login_user(user)\n                    return user\n\n    auth_header = request.headers.get(\"Authorization\")\n    if auth_header:\n        user = load_user_from_auth_header(auth_header)\n        if user:\n            return user\n\n    return\n\n\ndef load_user_from_auth_header(header_val):\n    if header_val.startswith('Basic '):\n        header_val = header_val.replace('Basic ', '', 1)\n    basic_username = basic_password = ''  # nosec\n    try:\n        header_val = base64.b64decode(header_val).decode('utf-8')\n        # Users with colon are invalid: rfc7617 page 4\n        basic_username = header_val.split(':', 1)[0]\n        basic_password = header_val.split(':', 1)[1]\n    except (TypeError, UnicodeDecodeError, binascii.Error):\n        pass\n    user = _fetch_user_by_name(basic_username)\n    if user and config.config_login_type == constants.LOGIN_LDAP and services.ldap:\n        if services.ldap.bind_user(str(user.password), basic_password):\n            return user\n    if user and check_password_hash(str(user.password), basic_password):\n        return user\n    return\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nfrom datetime import datetime\nimport json\nimport mimetypes\nimport chardet  # dependency of requests\nimport copy\nfrom functools import wraps\n\nfrom babel.dates import format_date\nfrom babel import Locale as LC\nfrom flask import Blueprint, jsonify\nfrom flask import request, redirect, send_from_directory, make_response, flash, abort, url_for\nfrom flask import session as flask_session\nfrom flask_babel import gettext as _\nfrom flask_login import login_user, logout_user, login_required, current_user\nfrom sqlalchemy.exc import IntegrityError, InvalidRequestError, OperationalError\nfrom sqlalchemy.sql.expression import text, func, false, not_, and_, or_\nfrom sqlalchemy.orm.attributes import flag_modified\nfrom sqlalchemy.sql.functions import coalesce\n\nfrom .services.worker import WorkerThread\n\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\nfrom . import constants, logger, isoLanguages, services\nfrom . import babel, db, ub, config, get_locale, app\nfrom . import calibre_db, kobo_sync_status\nfrom .gdriveutils import getFileFromEbooksFolder, do_gdrive_download\nfrom .helper import check_valid_domain, render_task_status, check_email, check_username, \\\n    get_cc_columns, get_book_cover, get_download_link, send_mail, generate_random_password, \\\n    send_registration_mail, check_send_to_kindle, check_read_formats, tags_filters, reset_password, valid_email, \\\n    edit_book_read_status\nfrom .pagination import Pagination\nfrom .redirect import redirect_back\nfrom .usermanagement import login_required_if_no_ano\nfrom .kobo_sync_status import remove_synced_book\nfrom .render_template import render_title_template\nfrom .kobo_sync_status import change_archived_books\n\n\nfeature_support = {\n    'ldap': bool(services.ldap),\n    'goodreads': bool(services.goodreads_support),\n    'kobo': bool(services.kobo)\n}\n\ntry:\n    from .oauth_bb import oauth_check, register_user_with_oauth, logout_oauth_user, get_oauth_status\n    feature_support['oauth'] = True\nexcept ImportError:\n    feature_support['oauth'] = False\n    oauth_check = {}\n\ntry:\n    from natsort import natsorted as sort\nexcept ImportError:\n    sort = sorted  # Just use regular sort then, may cause issues with badly named pages in cbz/cbr files\n\n\n@app.after_request\ndef add_security_headers(resp):\n    resp.headers['Content-Security-Policy'] = \"default-src 'self'\" + ''.join([' '+host for host in config.config_trustedhosts.strip().split(',')]) + \" 'unsafe-inline' 'unsafe-eval'; font-src 'self' data:; img-src 'self' data:\"\n    if request.endpoint == \"editbook.edit_book\" or config.config_use_google_drive:\n        resp.headers['Content-Security-Policy'] += \" *\"\n    elif request.endpoint == \"web.read_book\":\n        resp.headers['Content-Security-Policy'] += \" blob:;style-src-elem 'self' blob: 'unsafe-inline';\"\n    resp.headers['X-Content-Type-Options'] = 'nosniff'\n    resp.headers['X-Frame-Options'] = 'SAMEORIGIN'\n    resp.headers['X-XSS-Protection'] = '1; mode=block'\n    resp.headers['Strict-Transport-Security'] = 'max-age=31536000;'\n    return resp\n\nweb = Blueprint('web', __name__)\nlog = logger.create()\n\n\n# ################################### Login logic and rights management ###############################################\n\n\ndef download_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_download():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n\ndef viewer_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_viewer():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n# ################################### data provider functions #########################################################\n\n\n@web.route(\"/ajax/emailstat\")\n@login_required\ndef get_email_status_json():\n    tasks = WorkerThread.getInstance().tasks\n    return jsonify(render_task_status(tasks))\n\n\n@web.route(\"/ajax/bookmark/<int:book_id>/<book_format>\", methods=['POST'])\n@login_required\ndef set_bookmark(book_id, book_format):\n    bookmark_key = request.form[\"bookmark\"]\n    ub.session.query(ub.Bookmark).filter(and_(ub.Bookmark.user_id == int(current_user.id),\n                                              ub.Bookmark.book_id == book_id,\n                                              ub.Bookmark.format == book_format)).delete()\n    if not bookmark_key:\n        ub.session_commit()\n        return \"\", 204\n\n    lbookmark = ub.Bookmark(user_id=current_user.id,\n                            book_id=book_id,\n                            format=book_format,\n                            bookmark_key=bookmark_key)\n    ub.session.merge(lbookmark)\n    ub.session_commit(\"Bookmark for user {} in book {} created\".format(current_user.id, book_id))\n    return \"\", 201\n\n\n@web.route(\"/ajax/toggleread/<int:book_id>\", methods=['POST'])\n@login_required\ndef toggle_read(book_id):\n    message = edit_book_read_status(book_id)\n    if message:\n        return message, 400\n    else:\n        return message\n\n\n@web.route(\"/ajax/togglearchived/<int:book_id>\", methods=['POST'])\n@login_required\ndef toggle_archived(book_id):\n    is_archived = change_archived_books(book_id, message=\"Book {} archivebit toggled\".format(book_id))\n    if is_archived:\n        remove_synced_book(book_id)\n    return \"\"\n\n\n@web.route(\"/ajax/view\", methods=[\"POST\"])\n@login_required_if_no_ano\ndef update_view():\n    to_save = request.get_json()\n    try:\n        for element in to_save:\n            for param in to_save[element]:\n                current_user.set_view_property(element, param, to_save[element][param])\n    except Exception as ex:\n        log.error(\"Could not save view_settings: %r %r: %e\", request, to_save, ex)\n        return \"Invalid request\", 400\n    return \"1\", 200\n\n\n'''\n@web.route(\"/ajax/getcomic/<int:book_id>/<book_format>/<int:page>\")\n@login_required\ndef get_comic_book(book_id, book_format, page):\n    book = calibre_db.get_book(book_id)\n    if not book:\n        return \"\", 204\n    else:\n        for bookformat in book.data:\n            if bookformat.format.lower() == book_format.lower():\n                cbr_file = os.path.join(config.config_calibre_dir, book.path, bookformat.name) + \".\" + book_format\n                if book_format in (\"cbr\", \"rar\"):\n                    if feature_support['rar'] == True:\n                        rarfile.UNRAR_TOOL = config.config_rarfile_location\n                        try:\n                            rf = rarfile.RarFile(cbr_file)\n                            names = sort(rf.namelist())\n                            extract = lambda page: rf.read(names[page])\n                        except:\n                            # rarfile not valid\n                            log.error('Unrar binary not found, or unable to decompress file %s', cbr_file)\n                            return \"\", 204\n                    else:\n                        log.info('Unrar is not supported please install python rarfile extension')\n                        # no support means return nothing\n                        return \"\", 204\n                elif book_format in (\"cbz\", \"zip\"):\n                    zf = zipfile.ZipFile(cbr_file)\n                    names=sort(zf.namelist())\n                    extract = lambda page: zf.read(names[page])\n                elif book_format in (\"cbt\", \"tar\"):\n                    tf = tarfile.TarFile(cbr_file)\n                    names=sort(tf.getnames())\n                    extract = lambda page: tf.extractfile(names[page]).read()\n                else:\n                    log.error('unsupported comic format')\n                    return \"\", 204\n\n                b64 = codecs.encode(extract(page), 'base64').decode()\n                ext = names[page].rpartition('.')[-1]\n                if ext not in ('png', 'gif', 'jpg', 'jpeg', 'webp'):\n                    ext = 'png'\n                extractedfile=\"data:image/\" + ext + \";base64,\" + b64\n                fileData={\"name\": names[page], \"page\":page, \"last\":len(names)-1, \"content\": extractedfile}\n                return make_response(json.dumps(fileData))\n        return \"\", 204\n'''\n\n# ################################### Typeahead ##################################################################\n\n\n@web.route(\"/get_authors_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_authors_json():\n    return calibre_db.get_typeahead(db.Authors, request.args.get('q'), ('|', ','))\n\n\n@web.route(\"/get_publishers_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_publishers_json():\n    return calibre_db.get_typeahead(db.Publishers, request.args.get('q'), ('|', ','))\n\n\n@web.route(\"/get_tags_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_tags_json():\n    return calibre_db.get_typeahead(db.Tags, request.args.get('q'), tag_filter=tags_filters())\n\n\n@web.route(\"/get_series_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_series_json():\n    return calibre_db.get_typeahead(db.Series, request.args.get('q'))\n\n\n@web.route(\"/get_languages_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_languages_json():\n    query = (request.args.get('q') or '').lower()\n    language_names = isoLanguages.get_language_names(get_locale())\n    entries_start = [s for key, s in language_names.items() if s.lower().startswith(query.lower())]\n    if len(entries_start) < 5:\n        entries = [s for key, s in language_names.items() if query in s.lower()]\n        entries_start.extend(entries[0:(5 - len(entries_start))])\n        entries_start = list(set(entries_start))\n    json_dumps = json.dumps([dict(name=r) for r in entries_start[0:5]])\n    return json_dumps\n\n\n@web.route(\"/get_matching_tags\", methods=['GET'])\n@login_required_if_no_ano\ndef get_matching_tags():\n    tag_dict = {'tags': []}\n    q = calibre_db.session.query(db.Books).filter(calibre_db.common_filters(True))\n    calibre_db.session.connection().connection.connection.create_function(\"lower\", 1, db.lcase)\n    author_input = request.args.get('author_name') or ''\n    title_input = request.args.get('book_title') or ''\n    include_tag_inputs = request.args.getlist('include_tag') or ''\n    exclude_tag_inputs = request.args.getlist('exclude_tag') or ''\n    q = q.filter(db.Books.authors.any(func.lower(db.Authors.name).ilike(\"%\" + author_input + \"%\")),\n                 func.lower(db.Books.title).ilike(\"%\" + title_input + \"%\"))\n    if len(include_tag_inputs) > 0:\n        for tag in include_tag_inputs:\n            q = q.filter(db.Books.tags.any(db.Tags.id == tag))\n    if len(exclude_tag_inputs) > 0:\n        for tag in exclude_tag_inputs:\n            q = q.filter(not_(db.Books.tags.any(db.Tags.id == tag)))\n    for book in q:\n        for tag in book.tags:\n            if tag.id not in tag_dict['tags']:\n                tag_dict['tags'].append(tag.id)\n    json_dumps = json.dumps(tag_dict)\n    return json_dumps\n\n\ndef get_sort_function(sort_param, data):\n    order = [db.Books.timestamp.desc()]\n    if sort_param == 'stored':\n        sort_param = current_user.get_view_property(data, 'stored')\n    else:\n        current_user.set_view_property(data, 'stored', sort_param)\n    if sort_param == 'pubnew':\n        order = [db.Books.pubdate.desc()]\n    if sort_param == 'pubold':\n        order = [db.Books.pubdate]\n    if sort_param == 'abc':\n        order = [db.Books.sort]\n    if sort_param == 'zyx':\n        order = [db.Books.sort.desc()]\n    if sort_param == 'new':\n        order = [db.Books.timestamp.desc()]\n    if sort_param == 'old':\n        order = [db.Books.timestamp]\n    if sort_param == 'authaz':\n        order = [db.Books.author_sort.asc(), db.Series.name, db.Books.series_index]\n    if sort_param == 'authza':\n        order = [db.Books.author_sort.desc(), db.Series.name.desc(), db.Books.series_index.desc()]\n    if sort_param == 'seriesasc':\n        order = [db.Books.series_index.asc()]\n    if sort_param == 'seriesdesc':\n        order = [db.Books.series_index.desc()]\n    if sort_param == 'hotdesc':\n        order = [func.count(ub.Downloads.book_id).desc()]\n    if sort_param == 'hotasc':\n        order = [func.count(ub.Downloads.book_id).asc()]\n    if sort_param is None:\n        sort_param = \"new\"\n    return order, sort_param\n\n\ndef render_books_list(data, sort_param, book_id, page):\n    order = get_sort_function(sort_param, data)\n    if data == \"rated\":\n        return render_rated_books(page, book_id, order=order)\n    elif data == \"discover\":\n        return render_discover_books(page, book_id)\n    elif data == \"unread\":\n        return render_read_books(page, False, order=order)\n    elif data == \"read\":\n        return render_read_books(page, True, order=order)\n    elif data == \"hot\":\n        return render_hot_books(page, order)\n    elif data == \"download\":\n        return render_downloaded_books(page, order, book_id)\n    elif data == \"author\":\n        return render_author_books(page, book_id, order)\n    elif data == \"publisher\":\n        return render_publisher_books(page, book_id, order)\n    elif data == \"series\":\n        return render_series_books(page, book_id, order)\n    elif data == \"ratings\":\n        return render_ratings_books(page, book_id, order)\n    elif data == \"formats\":\n        return render_formats_books(page, book_id, order)\n    elif data == \"category\":\n        return render_category_books(page, book_id, order)\n    elif data == \"language\":\n        return render_language_books(page, book_id, order)\n    elif data == \"archived\":\n        return render_archived_books(page, order)\n    elif data == \"search\":\n        term = (request.args.get('query') or '')\n        offset = int(int(config.config_books_per_page) * (page - 1))\n        return render_search_results(term, offset, order, config.config_books_per_page)\n    elif data == \"advsearch\":\n        term = json.loads(flask_session['query'])\n        offset = int(int(config.config_books_per_page) * (page - 1))\n        return render_adv_search_results(term, offset, order, config.config_books_per_page)\n    else:\n        website = data or \"newest\"\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0, db.Books, True, order[0],\n        \t\t\t\t\t\t\t\t\t\t\t\t\t\tFalse, 0,\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     title=_(u\"Books\"), page=website, order=order[1])\n\n\ndef render_rated_books(page, book_id, order):\n    if current_user.check_visibility(constants.SIDEBAR_BEST_RATED):\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.ratings.any(db.Ratings.rating > 9),\n                                                                order[0],\n                                                                False, 0,\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     id=book_id, title=_(u\"Top Rated Books\"), page=\"rated\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_discover_books(page, book_id):\n    if current_user.check_visibility(constants.SIDEBAR_RANDOM):\n        entries, __, pagination = calibre_db.fill_indexpage(page, 0, db.Books, True, [func.randomblob(2)])\n        pagination = Pagination(1, config.config_books_per_page, config.config_books_per_page)\n        return render_title_template('discover.html', entries=entries, pagination=pagination, id=book_id,\n                                     title=_(u\"Discover (Random Books)\"), page=\"discover\")\n    else:\n        abort(404)\n\ndef render_hot_books(page, order):\n    if current_user.check_visibility(constants.SIDEBAR_HOT):\n        if order[1] not in ['hotasc', 'hotdesc']:\n        # Unary expression comparsion only working (for this expression) in sqlalchemy 1.4+\n        #if not (order[0][0].compare(func.count(ub.Downloads.book_id).desc()) or\n        #        order[0][0].compare(func.count(ub.Downloads.book_id).asc())):\n            order = [func.count(ub.Downloads.book_id).desc()], 'hotdesc'\n        if current_user.show_detail_random():\n            random = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\\n                .order_by(func.random()).limit(config.config_random_books)\n        else:\n            random = false()\n        off = int(int(config.config_books_per_page) * (page - 1))\n        all_books = ub.session.query(ub.Downloads, func.count(ub.Downloads.book_id))\\\n            .order_by(*order[0]).group_by(ub.Downloads.book_id)\n        hot_books = all_books.offset(off).limit(config.config_books_per_page)\n        entries = list()\n        for book in hot_books:\n            downloadBook = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()).filter(\n                db.Books.id == book.Downloads.book_id).first()\n            if downloadBook:\n                entries.append(downloadBook)\n            else:\n                ub.delete_download(book.Downloads.book_id)\n        numBooks = entries.__len__()\n        pagination = Pagination(page, config.config_books_per_page, numBooks)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     title=_(u\"Hot Books (Most Downloaded)\"), page=\"hot\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_downloaded_books(page, order, user_id):\n    if current_user.role_admin():\n        user_id = int(user_id)\n    else:\n        user_id = current_user.id\n    if current_user.check_visibility(constants.SIDEBAR_DOWNLOAD):\n        if current_user.show_detail_random():\n            random = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\\n                .order_by(func.random()).limit(config.config_random_books)\n        else:\n            random = false()\n\n        entries, __, pagination = calibre_db.fill_indexpage(page,\n                                                            0,\n                                                            db.Books,\n                                                            ub.Downloads.user_id == user_id,\n                                                            order[0],\n                                                            False, 0,\n                                                            db.books_series_link,\n                                                            db.Books.id == db.books_series_link.c.book,\n                                                            db.Series,\n                                                            ub.Downloads, db.Books.id == ub.Downloads.book_id)\n        for book in entries:\n            if not calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\\n                             .filter(db.Books.id == book.id).first():\n                ub.delete_download(book.id)\n        user = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n        return render_title_template('index.html',\n                                     random=random,\n                                     entries=entries,\n                                     pagination=pagination,\n                                     id=user_id,\n                                     title=_(u\"Downloaded books by %(user)s\",user=user.name),\n                                     page=\"download\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_author_books(page, author_id, order):\n    entries, __, pagination = calibre_db.fill_indexpage(page, 0,\n                                                        db.Books,\n                                                        db.Books.authors.any(db.Authors.id == author_id),\n                                                        [order[0][0], db.Series.name, db.Books.series_index],\n                                                        False, 0,\n                                                        db.books_series_link,\n                                                        db.Books.id == db.books_series_link.c.book,\n                                                        db.Series)\n    if entries is None or not len(entries):\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),\n              category=\"error\")\n        return redirect(url_for(\"web.index\"))\n    if constants.sqlalchemy_version2:\n        author = calibre_db.session.get(db.Authors, author_id)\n    else:\n        author = calibre_db.session.query(db.Authors).get(author_id)\n    author_name = author.name.replace('|', ',')\n\n    author_info = None\n    other_books = []\n    if services.goodreads_support and config.config_use_goodreads:\n        author_info = services.goodreads_support.get_author_info(author_name)\n        other_books = services.goodreads_support.get_other_books(author_info, entries)\n    return render_title_template('author.html', entries=entries, pagination=pagination, id=author_id,\n                                 title=_(u\"Author: %(name)s\", name=author_name), author=author_info,\n                                 other_books=other_books, page=\"author\", order=order[1])\n\n\ndef render_publisher_books(page, book_id, order):\n    publisher = calibre_db.session.query(db.Publishers).filter(db.Publishers.id == book_id).first()\n    if publisher:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.publishers.any(db.Publishers.id == book_id),\n                                                                [db.Series.name, order[0][0], db.Books.series_index],\n                                                                False, 0,\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=book_id,\n                                     title=_(u\"Publisher: %(name)s\", name=publisher.name),\n                                     page=\"publisher\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_series_books(page, book_id, order):\n    name = calibre_db.session.query(db.Series).filter(db.Series.id == book_id).first()\n    if name:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.series.any(db.Series.id == book_id),\n                                                                [order[0][0]])\n        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,\n                                     title=_(u\"Series: %(serie)s\", serie=name.name), page=\"series\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_ratings_books(page, book_id, order):\n    name = calibre_db.session.query(db.Ratings).filter(db.Ratings.id == book_id).first()\n    entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                            db.Books,\n                                                            db.Books.ratings.any(db.Ratings.id == book_id),\n                                                            [order[0][0]])\n    if name and name.rating <= 10:\n        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,\n                                     title=_(u\"Rating: %(rating)s stars\", rating=int(name.rating / 2)),\n                                     page=\"ratings\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_formats_books(page, book_id, order):\n    name = calibre_db.session.query(db.Data).filter(db.Data.format == book_id.upper()).first()\n    if name:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.data.any(db.Data.format == book_id.upper()),\n                                                                [order[0][0]])\n        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,\n                                     title=_(u\"File format: %(format)s\", format=name.format),\n                                     page=\"formats\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_category_books(page, book_id, order):\n    name = calibre_db.session.query(db.Tags).filter(db.Tags.id == book_id).first()\n    if name:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.tags.any(db.Tags.id == book_id),\n                                                                [order[0][0], db.Series.name, db.Books.series_index],\n                                                                False, 0,\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=book_id,\n                                     title=_(u\"Category: %(name)s\", name=name.name), page=\"category\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_language_books(page, name, order):\n    try:\n        lang_name = isoLanguages.get_language_name(get_locale(), name)\n    except KeyError:\n        abort(404)\n\n    entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                            db.Books,\n                                                            db.Books.languages.any(db.Languages.lang_code == name),\n                                                            [order[0][0]])\n    return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=name,\n                                 title=_(u\"Language: %(name)s\", name=lang_name), page=\"language\", order=order[1])\n\n\ndef render_read_books(page, are_read, as_xml=False, order=None):\n    sort_param = order[0] if order else []\n    if not config.config_read_column:\n        if are_read:\n            db_filter = and_(ub.ReadBook.user_id == int(current_user.id),\n                             ub.ReadBook.read_status == ub.ReadBook.STATUS_FINISHED)\n        else:\n            db_filter = coalesce(ub.ReadBook.read_status, 0) != ub.ReadBook.STATUS_FINISHED\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db_filter,\n                                                                sort_param,\n                                                                False, 0,\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series,\n                                                                ub.ReadBook, db.Books.id == ub.ReadBook.book_id)\n    else:\n        try:\n            if are_read:\n                db_filter = db.cc_classes[config.config_read_column].value == True\n            else:\n                db_filter = coalesce(db.cc_classes[config.config_read_column].value, False) != True\n            entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                    db.Books,\n                                                                    db_filter,\n                                                                    sort_param,\n                                                                    False, 0,\n                                                                    db.books_series_link,\n                                                                    db.Books.id == db.books_series_link.c.book,\n                                                                    db.Series,\n                                                                    db.cc_classes[config.config_read_column])\n        except (KeyError, AttributeError):\n            log.error(\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n            if not as_xml:\n                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",\n                        column=config.config_read_column),\n                      category=\"error\")\n                return redirect(url_for(\"web.index\"))\n            return [] # ToDo: Handle error Case for opds\n\n    if as_xml:\n        return entries, pagination\n    else:\n        if are_read:\n            name = _(u'Read Books') + ' (' + str(pagination.total_count) + ')'\n            pagename = \"read\"\n        else:\n            name = _(u'Unread Books') + ' (' + str(pagination.total_count) + ')'\n            pagename = \"unread\"\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     title=name, page=pagename, order=order[1])\n\n\ndef render_archived_books(page, sort_param):\n    order = sort_param[0] or []\n    archived_books = (\n        ub.session.query(ub.ArchivedBook)\n        .filter(ub.ArchivedBook.user_id == int(current_user.id))\n        .filter(ub.ArchivedBook.is_archived == True)\n        .all()\n    )\n    archived_book_ids = [archived_book.book_id for archived_book in archived_books]\n\n    archived_filter = db.Books.id.in_(archived_book_ids)\n\n    entries, random, pagination = calibre_db.fill_indexpage_with_archived_books(page, db.Books,\n                                                                                0,\n                                                                                archived_filter,\n                                                                                order,\n                                                                                True,\n                                                                                False, 0)\n\n    name = _(u'Archived Books') + ' (' + str(len(archived_book_ids)) + ')'\n    pagename = \"archived\"\n    return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                 title=name, page=pagename, order=sort_param[1])\n\n\ndef render_prepare_search_form(cc):\n    # prepare data for search-form\n    tags = calibre_db.session.query(db.Tags)\\\n        .join(db.books_tags_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_tags_link.tag'))\\\n        .order_by(db.Tags.name).all()\n    series = calibre_db.session.query(db.Series)\\\n        .join(db.books_series_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_series_link.series'))\\\n        .order_by(db.Series.name)\\\n        .filter(calibre_db.common_filters()).all()\n    shelves = ub.session.query(ub.Shelf)\\\n        .filter(or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == int(current_user.id)))\\\n        .order_by(ub.Shelf.name).all()\n    extensions = calibre_db.session.query(db.Data)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(db.Data.format)\\\n        .order_by(db.Data.format).all()\n    if current_user.filter_language() == u\"all\":\n        languages = calibre_db.speaking_language()\n    else:\n        languages = None\n    return render_title_template('search_form.html', tags=tags, languages=languages, extensions=extensions,\n                                 series=series,shelves=shelves, title=_(u\"Advanced Search\"), cc=cc, page=\"advsearch\")\n\n\ndef render_search_results(term, offset=None, order=None, limit=None):\n    join = db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series\n    entries, result_count, pagination = calibre_db.get_search_results(term,\n                                                                      offset,\n                                                                      order,\n                                                                      limit,\n                                                                      False,\n                                                                      config.config_read_column,\n                                                                      *join)\n    return render_title_template('search.html',\n                                 searchterm=term,\n                                 pagination=pagination,\n                                 query=term,\n                                 adv_searchterm=term,\n                                 entries=entries,\n                                 result_count=result_count,\n                                 title=_(u\"Search\"),\n                                 page=\"search\",\n                                 order=order[1])\n\n\n# ################################### View Books list ##################################################################\n\n\n@web.route(\"/\", defaults={'page': 1})\n@web.route('/page/<int:page>')\n@login_required_if_no_ano\ndef index(page):\n    sort_param = (request.args.get('sort') or 'stored').lower()\n    return render_books_list(\"newest\", sort_param, 1, page)\n\n\n@web.route('/<data>/<sort_param>', defaults={'page': 1, 'book_id': 1})\n@web.route('/<data>/<sort_param>/', defaults={'page': 1, 'book_id': 1})\n@web.route('/<data>/<sort_param>/<book_id>', defaults={'page': 1})\n@web.route('/<data>/<sort_param>/<book_id>/<int:page>')\n@login_required_if_no_ano\ndef books_list(data, sort_param, book_id, page):\n    return render_books_list(data, sort_param, book_id, page)\n\n\n@web.route(\"/table\")\n@login_required\ndef books_table():\n    visibility = current_user.view_settings.get('table', {})\n    cc = get_cc_columns(filter_config_custom_read=True)\n    return render_title_template('book_table.html', title=_(u\"Books List\"), cc=cc, page=\"book_table\",\n                                 visiblility=visibility)\n\n@web.route(\"/ajax/listbooks\")\n@login_required\ndef list_books():\n    off = int(request.args.get(\"offset\") or 0)\n    limit = int(request.args.get(\"limit\") or config.config_books_per_page)\n    search = request.args.get(\"search\")\n    sort_param = request.args.get(\"sort\", \"id\")\n    order = request.args.get(\"order\", \"\").lower()\n    state = None\n    join = tuple()\n\n    if sort_param == \"state\":\n        state = json.loads(request.args.get(\"state\", \"[]\"))\n    elif sort_param == \"tags\":\n        order = [db.Tags.name.asc()] if order == \"asc\" else [db.Tags.name.desc()]\n        join = db.books_tags_link, db.Books.id == db.books_tags_link.c.book, db.Tags\n    elif sort_param == \"series\":\n        order = [db.Series.name.asc()] if order == \"asc\" else [db.Series.name.desc()]\n        join = db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series\n    elif sort_param == \"publishers\":\n        order = [db.Publishers.name.asc()] if order == \"asc\" else [db.Publishers.name.desc()]\n        join = db.books_publishers_link, db.Books.id == db.books_publishers_link.c.book, db.Publishers\n    elif sort_param == \"authors\":\n        order = [db.Authors.name.asc(), db.Series.name, db.Books.series_index] if order == \"asc\" \\\n            else [db.Authors.name.desc(), db.Series.name.desc(), db.Books.series_index.desc()]\n        join = db.books_authors_link, db.Books.id == db.books_authors_link.c.book, db.Authors, \\\n               db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series\n    elif sort_param == \"languages\":\n        order = [db.Languages.lang_code.asc()] if order == \"asc\" else [db.Languages.lang_code.desc()]\n        join = db.books_languages_link, db.Books.id == db.books_languages_link.c.book, db.Languages\n    elif order and sort_param in [\"sort\", \"title\", \"authors_sort\", \"series_index\"]:\n        order = [text(sort_param + \" \" + order)]\n    elif not state:\n        order = [db.Books.timestamp.desc()]\n\n    total_count = filtered_count = calibre_db.session.query(db.Books).filter(calibre_db.common_filters(allow_show_archived=True)).count()\n    if state is not None:\n        if search:\n            books = calibre_db.search_query(search, config.config_read_column).all()\n            filtered_count = len(books)\n        else:\n            if not config.config_read_column:\n                books = (calibre_db.session.query(db.Books, ub.ReadBook.read_status, ub.ArchivedBook.is_archived)\n                         .select_from(db.Books)\n                         .outerjoin(ub.ReadBook,\n                                    and_(ub.ReadBook.user_id == int(current_user.id),\n                                         ub.ReadBook.book_id == db.Books.id)))\n            else:\n                read_column = \"\"\n                try:\n                    read_column = db.cc_classes[config.config_read_column]\n                    books = (calibre_db.session.query(db.Books, read_column.value, ub.ArchivedBook.is_archived)\n                             .select_from(db.Books)\n                             .outerjoin(read_column, read_column.book == db.Books.id))\n                except (KeyError, AttributeError):\n                    log.error(\"Custom Column No.%d is not existing in calibre database\", read_column)\n                    # Skip linking read column and return None instead of read status\n                    books = calibre_db.session.query(db.Books, None, ub.ArchivedBook.is_archived)\n            books = (books.outerjoin(ub.ArchivedBook, and_(db.Books.id == ub.ArchivedBook.book_id,\n                                                          int(current_user.id) == ub.ArchivedBook.user_id))\n                     .filter(calibre_db.common_filters(allow_show_archived=True)).all())\n        entries = calibre_db.get_checkbox_sorted(books, state, off, limit, order, True)\n    elif search:\n        entries, filtered_count, __ = calibre_db.get_search_results(search,\n                                                                    off,\n                                                                    [order,''],\n                                                                    limit,\n                                                                    True,\n                                                                    config.config_read_column,\n                                                                    *join)\n    else:\n        entries, __, __ = calibre_db.fill_indexpage_with_archived_books((int(off) / (int(limit)) + 1),\n                                                                        db.Books,\n                                                                        limit,\n                                                                        True,\n                                                                        order,\n                                                                        True,\n                                                                        True,\n                                                                        config.config_read_column,\n                                                                        *join)\n\n    result = list()\n    for entry in entries:\n        val = entry[0]\n        val.read_status = entry[1] == ub.ReadBook.STATUS_FINISHED\n        val.is_archived = entry[2] is True\n        for index in range(0, len(val.languages)):\n            val.languages[index].language_name = isoLanguages.get_language_name(get_locale(), val.languages[\n                index].lang_code)\n        result.append(val)\n\n    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": result}\n    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)\n\n    response = make_response(js_list)\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n@web.route(\"/ajax/table_settings\", methods=['POST'])\n@login_required\ndef update_table_settings():\n    current_user.view_settings['table'] = json.loads(request.data)\n    try:\n        try:\n            flag_modified(current_user, \"view_settings\")\n        except AttributeError:\n            pass\n        ub.session.commit()\n    except (InvalidRequestError, OperationalError):\n        log.error(\"Invalid request received: %r \", request, )\n        return \"Invalid request\", 400\n    return \"\"\n\n\n@web.route(\"/author\")\n@login_required_if_no_ano\ndef author_list():\n    if current_user.check_visibility(constants.SIDEBAR_AUTHOR):\n        if current_user.get_view_property('author', 'dir') == 'desc':\n            order = db.Authors.sort.desc()\n            order_no = 0\n        else:\n            order = db.Authors.sort.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Authors, func.count('books_authors_link.book').label('count')) \\\n            .join(db.books_authors_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_authors_link.author')).order_by(order).all()\n        charlist = calibre_db.session.query(func.upper(func.substr(db.Authors.sort, 1, 1)).label('char')) \\\n            .join(db.books_authors_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(func.upper(func.substr(db.Authors.sort, 1, 1))).all()\n        # If not creating a copy, readonly databases can not display authornames with \"|\" in it as changing the name\n        # starts a change session\n        autor_copy = copy.deepcopy(entries)\n        for entry in autor_copy:\n            entry.Authors.name = entry.Authors.name.replace('|', ',')\n        return render_title_template('list.html', entries=autor_copy, folder='web.books_list', charlist=charlist,\n                                     title=u\"Authors\", page=\"authorlist\", data='author', order=order_no)\n    else:\n        abort(404)\n\n@web.route(\"/downloadlist\")\n@login_required_if_no_ano\ndef download_list():\n    if current_user.get_view_property('download', 'dir') == 'desc':\n        order = ub.User.name.desc()\n        order_no = 0\n    else:\n        order = ub.User.name.asc()\n        order_no = 1\n    if current_user.check_visibility(constants.SIDEBAR_DOWNLOAD) and current_user.role_admin():\n        entries = ub.session.query(ub.User, func.count(ub.Downloads.book_id).label('count'))\\\n            .join(ub.Downloads).group_by(ub.Downloads.user_id).order_by(order).all()\n        charlist = ub.session.query(func.upper(func.substr(ub.User.name, 1, 1)).label('char')) \\\n            .filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS) \\\n            .group_by(func.upper(func.substr(ub.User.name, 1, 1))).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                     title=_(u\"Downloads\"), page=\"downloadlist\", data=\"download\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/publisher\")\n@login_required_if_no_ano\ndef publisher_list():\n    if current_user.get_view_property('publisher', 'dir') == 'desc':\n        order = db.Publishers.name.desc()\n        order_no = 0\n    else:\n        order = db.Publishers.name.asc()\n        order_no = 1\n    if current_user.check_visibility(constants.SIDEBAR_PUBLISHER):\n        entries = calibre_db.session.query(db.Publishers, func.count('books_publishers_link.book').label('count')) \\\n            .join(db.books_publishers_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_publishers_link.publisher')).order_by(order).all()\n        charlist = calibre_db.session.query(func.upper(func.substr(db.Publishers.name, 1, 1)).label('char')) \\\n            .join(db.books_publishers_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(func.upper(func.substr(db.Publishers.name, 1, 1))).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                     title=_(u\"Publishers\"), page=\"publisherlist\", data=\"publisher\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/series\")\n@login_required_if_no_ano\ndef series_list():\n    if current_user.check_visibility(constants.SIDEBAR_SERIES):\n        if current_user.get_view_property('series', 'dir') == 'desc':\n            order = db.Series.sort.desc()\n            order_no = 0\n        else:\n            order = db.Series.sort.asc()\n            order_no = 1\n        if current_user.get_view_property('series', 'series_view') == 'list':\n            entries = calibre_db.session.query(db.Series, func.count('books_series_link.book').label('count')) \\\n                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\\n                .group_by(text('books_series_link.series')).order_by(order).all()\n            charlist = calibre_db.session.query(func.upper(func.substr(db.Series.sort, 1, 1)).label('char')) \\\n                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\\n                .group_by(func.upper(func.substr(db.Series.sort, 1, 1))).all()\n            return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                         title=_(u\"Series\"), page=\"serieslist\", data=\"series\", order=order_no)\n        else:\n            entries = calibre_db.session.query(db.Books, func.count('books_series_link').label('count'),\n                                               func.max(db.Books.series_index), db.Books.id) \\\n                .join(db.books_series_link).join(db.Series).filter(calibre_db.common_filters())\\\n                .group_by(text('books_series_link.series')).order_by(order).all()\n            charlist = calibre_db.session.query(func.upper(func.substr(db.Series.sort, 1, 1)).label('char')) \\\n                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\\n                .group_by(func.upper(func.substr(db.Series.sort, 1, 1))).all()\n\n            return render_title_template('grid.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                         title=_(u\"Series\"), page=\"serieslist\", data=\"series\", bodyClass=\"grid-view\",\n                                         order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/ratings\")\n@login_required_if_no_ano\ndef ratings_list():\n    if current_user.check_visibility(constants.SIDEBAR_RATING):\n        if current_user.get_view_property('ratings', 'dir') == 'desc':\n            order = db.Ratings.rating.desc()\n            order_no = 0\n        else:\n            order = db.Ratings.rating.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Ratings, func.count('books_ratings_link.book').label('count'),\n                                   (db.Ratings.rating / 2).label('name')) \\\n            .join(db.books_ratings_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_ratings_link.rating')).order_by(order).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=list(),\n                                     title=_(u\"Ratings list\"), page=\"ratingslist\", data=\"ratings\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/formats\")\n@login_required_if_no_ano\ndef formats_list():\n    if current_user.check_visibility(constants.SIDEBAR_FORMAT):\n        if current_user.get_view_property('ratings', 'dir') == 'desc':\n            order = db.Data.format.desc()\n            order_no = 0\n        else:\n            order = db.Data.format.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Data,\n                                           func.count('data.book').label('count'),\n                                           db.Data.format.label('format')) \\\n            .join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(db.Data.format).order_by(order).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=list(),\n                                     title=_(u\"File formats list\"), page=\"formatslist\", data=\"formats\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/language\")\n@login_required_if_no_ano\ndef language_overview():\n    if current_user.check_visibility(constants.SIDEBAR_LANGUAGE) and current_user.filter_language() == u\"all\":\n        order_no = 0 if current_user.get_view_property('language', 'dir') == 'desc' else 1\n        charlist = list()\n        languages = calibre_db.speaking_language(reverse_order=not order_no, with_count=True)\n        for lang in languages:\n            upper_lang = lang[0].name[0].upper()\n            if upper_lang not in charlist:\n                charlist.append(upper_lang)\n        return render_title_template('languages.html', languages=languages,\n                                     charlist=charlist, title=_(u\"Languages\"), page=\"langlist\",\n                                     data=\"language\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/category\")\n@login_required_if_no_ano\ndef category_list():\n    if current_user.check_visibility(constants.SIDEBAR_CATEGORY):\n        if current_user.get_view_property('category', 'dir') == 'desc':\n            order = db.Tags.name.desc()\n            order_no = 0\n        else:\n            order = db.Tags.name.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Tags, func.count('books_tags_link.book').label('count')) \\\n            .join(db.books_tags_link).join(db.Books).order_by(order).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_tags_link.tag')).all()\n        charlist = calibre_db.session.query(func.upper(func.substr(db.Tags.name, 1, 1)).label('char')) \\\n            .join(db.books_tags_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(func.upper(func.substr(db.Tags.name, 1, 1))).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                     title=_(u\"Categories\"), page=\"catlist\", data=\"category\", order=order_no)\n    else:\n        abort(404)\n\n\n# ################################### Task functions ################################################################\n\n\n@web.route(\"/tasks\")\n@login_required\ndef get_tasks_status():\n    # if current user admin, show all email, otherwise only own emails\n    tasks = WorkerThread.getInstance().tasks\n    answer = render_task_status(tasks)\n    return render_title_template('tasks.html', entries=answer, title=_(u\"Tasks\"), page=\"tasks\")\n\n\n# ################################### Search functions ################################################################\n\n@web.route(\"/search\", methods=[\"GET\"])\n@login_required_if_no_ano\ndef search():\n    term = request.args.get(\"query\")\n    if term:\n        return redirect(url_for('web.books_list', data=\"search\", sort_param='stored', query=term.strip()))\n    else:\n        return render_title_template('search.html',\n                                     searchterm=\"\",\n                                     result_count=0,\n                                     title=_(u\"Search\"),\n                                     page=\"search\")\n\n\n@web.route(\"/advsearch\", methods=['POST'])\n@login_required_if_no_ano\ndef advanced_search():\n    values = dict(request.form)\n    params = ['include_tag', 'exclude_tag', 'include_serie', 'exclude_serie', 'include_shelf', 'exclude_shelf',\n              'include_language', 'exclude_language', 'include_extension', 'exclude_extension']\n    for param in params:\n        values[param] = list(request.form.getlist(param))\n    flask_session['query'] = json.dumps(values)\n    return redirect(url_for('web.books_list', data=\"advsearch\", sort_param='stored', query=\"\"))\n\n\ndef adv_search_custom_columns(cc, term, q):\n    for c in cc:\n        if c.datatype == \"datetime\":\n            custom_start = term.get('custom_column_' + str(c.id) + '_start')\n            custom_end = term.get('custom_column_' + str(c.id) + '_end')\n            if custom_start:\n                q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                    func.datetime(db.cc_classes[c.id].value) >= func.datetime(custom_start)))\n            if custom_end:\n                q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                    func.datetime(db.cc_classes[c.id].value) <= func.datetime(custom_end)))\n        else:\n            custom_query = term.get('custom_column_' + str(c.id))\n            if custom_query != '' and custom_query is not None:\n                if c.datatype == 'bool':\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        db.cc_classes[c.id].value == (custom_query == \"True\")))\n                elif c.datatype == 'int' or c.datatype == 'float':\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        db.cc_classes[c.id].value == custom_query))\n                elif c.datatype == 'rating':\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        db.cc_classes[c.id].value == int(float(custom_query) * 2)))\n                else:\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        func.lower(db.cc_classes[c.id].value).ilike(\"%\" + custom_query + \"%\")))\n    return q\n\n\ndef adv_search_language(q, include_languages_inputs, exclude_languages_inputs):\n    if current_user.filter_language() != \"all\":\n        q = q.filter(db.Books.languages.any(db.Languages.lang_code == current_user.filter_language()))\n    else:\n        for language in include_languages_inputs:\n            q = q.filter(db.Books.languages.any(db.Languages.id == language))\n        for language in exclude_languages_inputs:\n            q = q.filter(not_(db.Books.series.any(db.Languages.id == language)))\n    return q\n\n\ndef adv_search_ratings(q, rating_high, rating_low):\n    if rating_high:\n        rating_high = int(rating_high) * 2\n        q = q.filter(db.Books.ratings.any(db.Ratings.rating <= rating_high))\n    if rating_low:\n        rating_low = int(rating_low) * 2\n        q = q.filter(db.Books.ratings.any(db.Ratings.rating >= rating_low))\n    return q\n\n\ndef adv_search_read_status(q, read_status):\n    if read_status:\n        if config.config_read_column:\n            try:\n                if read_status == \"True\":\n                    q = q.join(db.cc_classes[config.config_read_column], isouter=True) \\\n                        .filter(db.cc_classes[config.config_read_column].value == True)\n                else:\n                    q = q.join(db.cc_classes[config.config_read_column], isouter=True) \\\n                        .filter(coalesce(db.cc_classes[config.config_read_column].value, False) != True)\n            except (KeyError, AttributeError):\n                log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",\n                        column=config.config_read_column),\n                      category=\"error\")\n                return q\n        else:\n            if read_status == \"True\":\n                q = q.join(ub.ReadBook, db.Books.id == ub.ReadBook.book_id, isouter=True) \\\n                    .filter(ub.ReadBook.user_id == int(current_user.id),\n                            ub.ReadBook.read_status == ub.ReadBook.STATUS_FINISHED)\n            else:\n                q = q.join(ub.ReadBook, db.Books.id == ub.ReadBook.book_id, isouter=True) \\\n                    .filter(ub.ReadBook.user_id == int(current_user.id),\n                            coalesce(ub.ReadBook.read_status, 0) != ub.ReadBook.STATUS_FINISHED)\n    return q\n\n\ndef adv_search_extension(q, include_extension_inputs, exclude_extension_inputs):\n    for extension in include_extension_inputs:\n        q = q.filter(db.Books.data.any(db.Data.format == extension))\n    for extension in exclude_extension_inputs:\n        q = q.filter(not_(db.Books.data.any(db.Data.format == extension)))\n    return q\n\n\ndef adv_search_tag(q, include_tag_inputs, exclude_tag_inputs):\n    for tag in include_tag_inputs:\n        q = q.filter(db.Books.tags.any(db.Tags.id == tag))\n    for tag in exclude_tag_inputs:\n        q = q.filter(not_(db.Books.tags.any(db.Tags.id == tag)))\n    return q\n\n\ndef adv_search_serie(q, include_series_inputs, exclude_series_inputs):\n    for serie in include_series_inputs:\n        q = q.filter(db.Books.series.any(db.Series.id == serie))\n    for serie in exclude_series_inputs:\n        q = q.filter(not_(db.Books.series.any(db.Series.id == serie)))\n    return q\n\ndef adv_search_shelf(q, include_shelf_inputs, exclude_shelf_inputs):\n    q = q.outerjoin(ub.BookShelf, db.Books.id == ub.BookShelf.book_id)\\\n        .filter(or_(ub.BookShelf.shelf == None, ub.BookShelf.shelf.notin_(exclude_shelf_inputs)))\n    if len(include_shelf_inputs) > 0:\n        q = q.filter(ub.BookShelf.shelf.in_(include_shelf_inputs))\n    return q\n\ndef extend_search_term(searchterm,\n                       author_name,\n                       book_title,\n                       publisher,\n                       pub_start,\n                       pub_end,\n                       tags,\n                       rating_high,\n                       rating_low,\n                       read_status,\n                       ):\n    searchterm.extend((author_name.replace('|', ','), book_title, publisher))\n    if pub_start:\n        try:\n            searchterm.extend([_(u\"Published after \") +\n                               format_date(datetime.strptime(pub_start, \"%Y-%m-%d\"),\n                                           format='medium', locale=get_locale())])\n        except ValueError:\n            pub_start = u\"\"\n    if pub_end:\n        try:\n            searchterm.extend([_(u\"Published before \") +\n                               format_date(datetime.strptime(pub_end, \"%Y-%m-%d\"),\n                                           format='medium', locale=get_locale())])\n        except ValueError:\n            pub_end = u\"\"\n    elements = {'tag': db.Tags, 'serie':db.Series, 'shelf':ub.Shelf}\n    for key, db_element in elements.items():\n        tag_names = calibre_db.session.query(db_element).filter(db_element.id.in_(tags['include_' + key])).all()\n        searchterm.extend(tag.name for tag in tag_names)\n        tag_names = calibre_db.session.query(db_element).filter(db_element.id.in_(tags['exclude_' + key])).all()\n        searchterm.extend(tag.name for tag in tag_names)\n    language_names = calibre_db.session.query(db.Languages). \\\n        filter(db.Languages.id.in_(tags['include_language'])).all()\n    if language_names:\n        language_names = calibre_db.speaking_language(language_names)\n    searchterm.extend(language.name for language in language_names)\n    language_names = calibre_db.session.query(db.Languages). \\\n        filter(db.Languages.id.in_(tags['exclude_language'])).all()\n    if language_names:\n        language_names = calibre_db.speaking_language(language_names)\n    searchterm.extend(language.name for language in language_names)\n    if rating_high:\n        searchterm.extend([_(u\"Rating <= %(rating)s\", rating=rating_high)])\n    if rating_low:\n        searchterm.extend([_(u\"Rating >= %(rating)s\", rating=rating_low)])\n    if read_status:\n        searchterm.extend([_(u\"Read Status = %(status)s\", status=read_status)])\n    searchterm.extend(ext for ext in tags['include_extension'])\n    searchterm.extend(ext for ext in tags['exclude_extension'])\n    # handle custom columns\n    searchterm = \" + \".join(filter(None, searchterm))\n    return searchterm, pub_start, pub_end\n\n\ndef render_adv_search_results(term, offset=None, order=None, limit=None):\n    sort_param = order[0] if order else [db.Books.sort]\n    pagination = None\n\n    cc = get_cc_columns(filter_config_custom_read=True)\n    calibre_db.session.connection().connection.connection.create_function(\"lower\", 1, db.lcase)\n    if not config.config_read_column:\n        query = (calibre_db.session.query(db.Books, ub.ArchivedBook.is_archived, ub.ReadBook).select_from(db.Books)\n                 .outerjoin(ub.ReadBook, and_(db.Books.id == ub.ReadBook.book_id,\n                                              int(current_user.id) == ub.ReadBook.user_id)))\n    else:\n        try:\n            read_column = cc[config.config_read_column]\n            query = (calibre_db.session.query(db.Books, ub.ArchivedBook.is_archived, read_column.value)\n                     .select_from(db.Books)\n                     .outerjoin(read_column, read_column.book == db.Books.id))\n        except (KeyError, AttributeError):\n            log.error(\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n            # Skip linking read column\n            query = calibre_db.session.query(db.Books, ub.ArchivedBook.is_archived, None)\n    query = query.outerjoin(ub.ArchivedBook, and_(db.Books.id == ub.ArchivedBook.book_id,\n                                                  int(current_user.id) == ub.ArchivedBook.user_id))\n\n    q = query.outerjoin(db.books_series_link, db.Books.id == db.books_series_link.c.book)\\\n        .outerjoin(db.Series)\\\n        .filter(calibre_db.common_filters(True))\n\n    # parse multiselects to a complete dict\n    tags = dict()\n    elements = ['tag', 'serie', 'shelf', 'language', 'extension']\n    for element in elements:\n        tags['include_' + element] = term.get('include_' + element)\n        tags['exclude_' + element] = term.get('exclude_' + element)\n\n    author_name = term.get(\"author_name\")\n    book_title = term.get(\"book_title\")\n    publisher = term.get(\"publisher\")\n    pub_start = term.get(\"publishstart\")\n    pub_end = term.get(\"publishend\")\n    rating_low = term.get(\"ratinghigh\")\n    rating_high = term.get(\"ratinglow\")\n    description = term.get(\"comment\")\n    read_status = term.get(\"read_status\")\n    if author_name:\n        author_name = author_name.strip().lower().replace(',', '|')\n    if book_title:\n        book_title = book_title.strip().lower()\n    if publisher:\n        publisher = publisher.strip().lower()\n\n    searchterm = []\n    cc_present = False\n    for c in cc:\n        if c.datatype == \"datetime\":\n            column_start = term.get('custom_column_' + str(c.id) + '_start')\n            column_end = term.get('custom_column_' + str(c.id) + '_end')\n            if column_start:\n                searchterm.extend([u\"{} >= {}\".format(c.name,\n                                                      format_date(datetime.strptime(column_start, \"%Y-%m-%d\").date(),\n                                                                      format='medium',\n                                                                      locale=get_locale())\n                                                      )])\n                cc_present = True\n            if column_end:\n                searchterm.extend([u\"{} <= {}\".format(c.name,\n                                                      format_date(datetime.strptime(column_end, \"%Y-%m-%d\").date(),\n                                                                      format='medium',\n                                                                      locale=get_locale())\n                                                      )])\n                cc_present = True\n        elif term.get('custom_column_' + str(c.id)):\n            searchterm.extend([(u\"{}: {}\".format(c.name, term.get('custom_column_' + str(c.id))))])\n            cc_present = True\n\n\n    if any(tags.values()) or author_name or book_title or publisher or pub_start or pub_end or rating_low \\\n       or rating_high or description or cc_present or read_status:\n        searchterm, pub_start, pub_end = extend_search_term(searchterm,\n                                                            author_name,\n                                                            book_title,\n                                                            publisher,\n                                                            pub_start,\n                                                            pub_end,\n                                                            tags,\n                                                            rating_high,\n                                                            rating_low,\n                                                            read_status)\n        # q = q.filter()\n        if author_name:\n            q = q.filter(db.Books.authors.any(func.lower(db.Authors.name).ilike(\"%\" + author_name + \"%\")))\n        if book_title:\n            q = q.filter(func.lower(db.Books.title).ilike(\"%\" + book_title + \"%\"))\n        if pub_start:\n            q = q.filter(func.datetime(db.Books.pubdate) > func.datetime(pub_start))\n        if pub_end:\n            q = q.filter(func.datetime(db.Books.pubdate) < func.datetime(pub_end))\n        q = adv_search_read_status(q, read_status)\n        if publisher:\n            q = q.filter(db.Books.publishers.any(func.lower(db.Publishers.name).ilike(\"%\" + publisher + \"%\")))\n        q = adv_search_tag(q, tags['include_tag'], tags['exclude_tag'])\n        q = adv_search_serie(q, tags['include_serie'], tags['exclude_serie'])\n        q = adv_search_shelf(q, tags['include_shelf'], tags['exclude_shelf'])\n        q = adv_search_extension(q, tags['include_extension'], tags['exclude_extension'])\n        q = adv_search_language(q, tags['include_language'], tags['exclude_language'])\n        q = adv_search_ratings(q, rating_high, rating_low)\n\n        if description:\n            q = q.filter(db.Books.comments.any(func.lower(db.Comments.text).ilike(\"%\" + description + \"%\")))\n\n        # search custom culumns\n        try:\n            q = adv_search_custom_columns(cc, term, q)\n        except AttributeError as ex:\n            log.error_or_exception(ex)\n            flash(_(\"Error on search for custom columns, please restart Calibre-Web\"), category=\"error\")\n\n    q = q.order_by(*sort_param).all()\n    flask_session['query'] = json.dumps(term)\n    ub.store_combo_ids(q)\n    result_count = len(q)\n    if offset is not None and limit is not None:\n        offset = int(offset)\n        limit_all = offset + int(limit)\n        pagination = Pagination((offset / (int(limit)) + 1), limit, result_count)\n    else:\n        offset = 0\n        limit_all = result_count\n    entries = calibre_db.order_authors(q[offset:limit_all], list_return=True, combined=True)\n    return render_title_template('search.html',\n                                 adv_searchterm=searchterm,\n                                 pagination=pagination,\n                                 entries=entries,\n                                 result_count=result_count,\n                                 title=_(u\"Advanced Search\"), page=\"advsearch\",\n                                 order=order[1])\n\n\n@web.route(\"/advsearch\", methods=['GET'])\n@login_required_if_no_ano\ndef advanced_search_form():\n    # Build custom columns names\n    cc = get_cc_columns(filter_config_custom_read=True)\n    return render_prepare_search_form(cc)\n\n\n# ################################### Download/Send ##################################################################\n\n\n@web.route(\"/cover/<int:book_id>\")\n@login_required_if_no_ano\ndef get_cover(book_id):\n    return get_book_cover(book_id)\n\n@web.route(\"/robots.txt\")\ndef get_robots():\n    return send_from_directory(constants.STATIC_DIR, \"robots.txt\")\n\n@web.route(\"/show/<int:book_id>/<book_format>\", defaults={'anyname': 'None'})\n@web.route(\"/show/<int:book_id>/<book_format>/<anyname>\")\n@login_required_if_no_ano\n@viewer_required\ndef serve_book(book_id, book_format, anyname):\n    book_format = book_format.split(\".\")[0]\n    book = calibre_db.get_book(book_id)\n    data = calibre_db.get_book_format(book_id, book_format.upper())\n    if not data:\n        return \"File not in Database\"\n    log.info('Serving book: %s', data.name)\n    if config.config_use_google_drive:\n        try:\n            headers = Headers()\n            headers[\"Content-Type\"] = mimetypes.types_map.get('.' + book_format, \"application/octet-stream\")\n            df = getFileFromEbooksFolder(book.path, data.name + \".\" + book_format)\n            return do_gdrive_download(df, headers, (book_format.upper() == 'TXT'))\n        except AttributeError as ex:\n            log.error_or_exception(ex)\n            return \"File Not Found\"\n    else:\n        if book_format.upper() == 'TXT':\n            try:\n                rawdata = open(os.path.join(config.config_calibre_dir, book.path, data.name + \".\" + book_format),\n                               \"rb\").read()\n                result = chardet.detect(rawdata)\n                return make_response(\n                    rawdata.decode(result['encoding'], 'surrogatepass').encode('utf-8', 'surrogatepass'))\n            except FileNotFoundError:\n                log.error(\"File Not Found\")\n                return \"File Not Found\"\n        return send_from_directory(os.path.join(config.config_calibre_dir, book.path), data.name + \".\" + book_format)\n\n\n@web.route(\"/download/<int:book_id>/<book_format>\", defaults={'anyname': 'None'})\n@web.route(\"/download/<int:book_id>/<book_format>/<anyname>\")\n@login_required_if_no_ano\n@download_required\ndef download_link(book_id, book_format, anyname):\n    client = \"kobo\" if \"Kobo\" in request.headers.get('User-Agent') else \"\"\n    return get_download_link(book_id, book_format, client)\n\n\n@web.route('/send/<int:book_id>/<book_format>/<int:convert>', methods=[\"POST\"])\n@login_required\n@download_required\ndef send_to_kindle(book_id, book_format, convert):\n    if not config.get_mail_server_configured():\n        flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")\n    elif current_user.kindle_mail:\n        result = send_mail(book_id, book_format, convert, current_user.kindle_mail, config.config_calibre_dir,\n                           current_user.name)\n        if result is None:\n            flash(_(u\"Book successfully queued for sending to %(kindlemail)s\", kindlemail=current_user.kindle_mail),\n                  category=\"success\")\n            ub.update_download(book_id, int(current_user.id))\n        else:\n            flash(_(u\"Oops! There was an error sending this book: %(res)s\", res=result), category=\"error\")\n    else:\n        flash(_(u\"Please update your profile with a valid Send to Kindle E-mail Address.\"), category=\"error\")\n    if \"HTTP_REFERER\" in request.environ:\n        return redirect(request.environ[\"HTTP_REFERER\"])\n    else:\n        return redirect(url_for('web.index'))\n\n\n# ################################### Login Logout ##################################################################\n\n\n@web.route('/register', methods=['GET', 'POST'])\ndef register():\n    if not config.config_public_reg:\n        abort(404)\n    if current_user is not None and current_user.is_authenticated:\n        return redirect(url_for('web.index'))\n    if not config.get_mail_server_configured():\n        flash(_(u\"E-Mail server is not configured, please contact your administrator!\"), category=\"error\")\n        return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        nickname = to_save[\"email\"].strip() if config.config_register_email else to_save.get('name')\n        if not nickname or not to_save.get(\"email\"):\n            flash(_(u\"Please fill out all fields!\"), category=\"error\")\n            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n        try:\n            nickname = check_username(nickname)\n            email = check_email(to_save[\"email\"])\n        except Exception as ex:\n            flash(str(ex), category=\"error\")\n            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n\n        content = ub.User()\n        if check_valid_domain(email):\n            content.name = nickname\n            content.email = email\n            password = generate_random_password()\n            content.password = generate_password_hash(password)\n            content.role = config.config_default_role\n            content.sidebar_view = config.config_default_show\n            try:\n                ub.session.add(content)\n                ub.session.commit()\n                if feature_support['oauth']:\n                    register_user_with_oauth(content)\n                send_registration_mail(to_save[\"email\"].strip(), nickname, password)\n            except Exception:\n                ub.session.rollback()\n                flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n                return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n        else:\n            flash(_(u\"Your e-mail is not allowed to register\"), category=\"error\")\n            log.warning('Registering failed for user \"%s\" e-mail address: %s', nickname, to_save[\"email\"])\n            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n        flash(_(u\"Confirmation e-mail was send to your e-mail account.\"), category=\"success\")\n        return redirect(url_for('web.login'))\n\n    if feature_support['oauth']:\n        register_user_with_oauth()\n    return render_title_template('register.html', config=config, title=_(\"Register\"), page=\"register\")\n\n\n@web.route('/login', methods=['GET', 'POST'])\ndef login():\n    if current_user is not None and current_user.is_authenticated:\n        return redirect(url_for('web.index'))\n    if config.config_login_type == constants.LOGIN_LDAP and not services.ldap:\n        log.error(u\"Cannot activate LDAP authentication\")\n        flash(_(u\"Cannot activate LDAP authentication\"), category=\"error\")\n    if request.method == \"POST\":\n        form = request.form.to_dict()\n        user = ub.session.query(ub.User).filter(func.lower(ub.User.name) == form['username'].strip().lower()) \\\n            .first()\n        if config.config_login_type == constants.LOGIN_LDAP and services.ldap and user and form['password'] != \"\":\n            login_result, error = services.ldap.bind_user(form['username'], form['password'])\n            if login_result:\n                login_user(user, remember=bool(form.get('remember_me')))\n                ub.store_user_session()\n                log.debug(u\"You are now logged in as: '%s'\", user.name)\n                flash(_(u\"you are now logged in as: '%(nickname)s'\", nickname=user.name),\n                      category=\"success\")\n                return redirect_back(url_for(\"web.index\"))\n            elif login_result is None and user and check_password_hash(str(user.password), form['password']) \\\n                and user.name != \"Guest\":\n                login_user(user, remember=bool(form.get('remember_me')))\n                ub.store_user_session()\n                log.info(\"Local Fallback Login as: '%s'\", user.name)\n                flash(_(u\"Fallback Login as: '%(nickname)s', LDAP Server not reachable, or user not known\",\n                        nickname=user.name),\n                      category=\"warning\")\n                return redirect_back(url_for(\"web.index\"))\n            elif login_result is None:\n                log.info(error)\n                flash(_(u\"Could not login: %(message)s\", message=error), category=\"error\")\n            else:\n                ip_Address = request.headers.get('X-Forwarded-For', request.remote_addr)\n                log.warning('LDAP Login failed for user \"%s\" IP-address: %s', form['username'], ip_Address)\n                flash(_(u\"Wrong Username or Password\"), category=\"error\")\n        else:\n            ip_Address = request.headers.get('X-Forwarded-For', request.remote_addr)\n            if 'forgot' in form and form['forgot'] == 'forgot':\n                if user is not None and user.name != \"Guest\":\n                    ret, __ = reset_password(user.id)\n                    if ret == 1:\n                        flash(_(u\"New Password was send to your email address\"), category=\"info\")\n                        log.info('Password reset for user \"%s\" IP-address: %s', form['username'], ip_Address)\n                    else:\n                        log.error(u\"An unknown error occurred. Please try again later\")\n                        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n                else:\n                    flash(_(u\"Please enter valid username to reset password\"), category=\"error\")\n                    log.warning('Username missing for password reset IP-address: %s', ip_Address)\n            else:\n                if user and check_password_hash(str(user.password), form['password']) and user.name != \"Guest\":\n                    login_user(user, remember=bool(form.get('remember_me')))\n                    ub.store_user_session()\n                    log.debug(u\"You are now logged in as: '%s'\", user.name)\n                    flash(_(u\"You are now logged in as: '%(nickname)s'\", nickname=user.name), category=\"success\")\n                    config.config_is_initial = False\n                    return redirect_back(url_for(\"web.index\"))\n                else:\n                    log.warning('Login failed for user \"%s\" IP-address: %s', form['username'], ip_Address)\n                    flash(_(u\"Wrong Username or Password\"), category=\"error\")\n\n    next_url = request.args.get('next', default=url_for(\"web.index\"), type=str)\n    if url_for(\"web.logout\") == next_url:\n        next_url = url_for(\"web.index\")\n    return render_title_template('login.html',\n                                 title=_(u\"Login\"),\n                                 next_url=next_url,\n                                 config=config,\n                                 oauth_check=oauth_check,\n                                 mail=config.get_mail_server_configured(), page=\"login\")\n\n\n@web.route('/logout')\n@login_required\ndef logout():\n    if current_user is not None and current_user.is_authenticated:\n        ub.delete_user_session(current_user.id, flask_session.get('_id',\"\"))\n        logout_user()\n        if feature_support['oauth'] and (config.config_login_type == 2 or config.config_login_type == 3):\n            logout_oauth_user()\n    log.debug(u\"User logged out\")\n    return redirect(url_for('web.login'))\n\n\n# ################################### Users own configuration #########################################################\ndef change_profile(kobo_support, local_oauth_check, oauth_status, translations, languages):\n    to_save = request.form.to_dict()\n    current_user.random_books = 0\n    if current_user.role_passwd() or current_user.role_admin():\n        if to_save.get(\"password\"):\n            current_user.password = generate_password_hash(to_save[\"password\"])\n    try:\n        if to_save.get(\"kindle_mail\", current_user.kindle_mail) != current_user.kindle_mail:\n            current_user.kindle_mail = valid_email(to_save[\"kindle_mail\"])\n        if to_save.get(\"email\", current_user.email) != current_user.email:\n            current_user.email = check_email(to_save[\"email\"])\n        if current_user.role_admin():\n            if to_save.get(\"name\", current_user.name) != current_user.name:\n                # Query User name, if not existing, change\n                current_user.name = check_username(to_save[\"name\"])\n        current_user.random_books = 1 if to_save.get(\"show_random\") == \"on\" else 0\n        if to_save.get(\"default_language\"):\n            current_user.default_language = to_save[\"default_language\"]\n        if to_save.get(\"locale\"):\n            current_user.locale = to_save[\"locale\"]\n        old_state = current_user.kobo_only_shelves_sync\n        # 1 -> 0: nothing has to be done\n        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs which\n        # don't have to be synced have to be removed (added to Shelf archive)\n        current_user.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0\n        if old_state == 0 and current_user.kobo_only_shelves_sync == 1:\n            kobo_sync_status.update_on_sync_shelfs(current_user.id)\n\n    except Exception as ex:\n        flash(str(ex), category=\"error\")\n        return render_title_template(\"user_edit.html\",\n                                     content=current_user,\n                                     translations=translations,\n                                     profile=1,\n                                     languages=languages,\n                                     title=_(u\"%(name)s's profile\", name=current_user.name),\n                                     page=\"me\",\n                                     kobo_support=kobo_support,\n                                     registered_oauth=local_oauth_check,\n                                     oauth_status=oauth_status)\n\n    val = 0\n    for key, __ in to_save.items():\n        if key.startswith('show'):\n            val += int(key[5:])\n    current_user.sidebar_view = val\n    if to_save.get(\"Show_detail_random\"):\n        current_user.sidebar_view += constants.DETAIL_RANDOM\n\n    try:\n        ub.session.commit()\n        flash(_(u\"Profile updated\"), category=\"success\")\n        log.debug(u\"Profile updated\")\n    except IntegrityError:\n        ub.session.rollback()\n        flash(_(u\"Found an existing account for this e-mail address\"), category=\"error\")\n        log.debug(u\"Found an existing account for this e-mail address\")\n    except OperationalError as e:\n        ub.session.rollback()\n        log.error(\"Database error: %s\", e)\n        flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")\n\n\n@web.route(\"/me\", methods=[\"GET\", \"POST\"])\n@login_required\ndef profile():\n    languages = calibre_db.speaking_language()\n    translations = babel.list_translations() + [LC('en')]\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    if feature_support['oauth'] and config.config_login_type == 2:\n        oauth_status = get_oauth_status()\n        local_oauth_check = oauth_check\n    else:\n        oauth_status = None\n        local_oauth_check = {}\n\n    if request.method == \"POST\":\n        change_profile(kobo_support, local_oauth_check, oauth_status, translations, languages)\n    return render_title_template(\"user_edit.html\",\n                                 translations=translations,\n                                 profile=1,\n                                 languages=languages,\n                                 content=current_user,\n                                 kobo_support=kobo_support,\n                                 title=_(u\"%(name)s's profile\", name=current_user.name),\n                                 page=\"me\",\n                                 registered_oauth=local_oauth_check,\n                                 oauth_status=oauth_status)\n\n\n# ###################################Show single book ##################################################################\n\n\n@web.route(\"/read/<int:book_id>/<book_format>\")\n@login_required_if_no_ano\n@viewer_required\ndef read_book(book_id, book_format):\n    book = calibre_db.get_filtered_book(book_id)\n    book.ordered_authors = calibre_db.order_authors([book], False)\n\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")\n        return redirect(url_for(\"web.index\"))\n\n    # check if book has a bookmark\n    bookmark = None\n    if current_user.is_authenticated:\n        bookmark = ub.session.query(ub.Bookmark).filter(and_(ub.Bookmark.user_id == int(current_user.id),\n                                                             ub.Bookmark.book_id == book_id,\n                                                             ub.Bookmark.format == book_format.upper())).first()\n    if book_format.lower() == \"epub\":\n        log.debug(u\"Start epub reader for %d\", book_id)\n        return render_title_template('read.html', bookid=book_id, title=book.title, bookmark=bookmark)\n    elif book_format.lower() == \"pdf\":\n        log.debug(u\"Start pdf reader for %d\", book_id)\n        return render_title_template('readpdf.html', pdffile=book_id, title=book.title)\n    elif book_format.lower() == \"txt\":\n        log.debug(u\"Start txt reader for %d\", book_id)\n        return render_title_template('readtxt.html', txtfile=book_id, title=book.title)\n    elif book_format.lower() == \"djvu\":\n        log.debug(u\"Start djvu reader for %d\", book_id)\n        return render_title_template('readdjvu.html', djvufile=book_id, title=book.title)\n    else:\n        for fileExt in constants.EXTENSIONS_AUDIO:\n            if book_format.lower() == fileExt:\n                entries = calibre_db.get_filtered_book(book_id)\n                log.debug(u\"Start mp3 listening for %d\", book_id)\n                return render_title_template('listenmp3.html', mp3file=book_id, audioformat=book_format.lower(),\n                                             entry=entries, bookmark=bookmark)\n        for fileExt in [\"cbr\", \"cbt\", \"cbz\"]:\n            if book_format.lower() == fileExt:\n                all_name = str(book_id)\n                title = book.title\n                if len(book.series):\n                    title = title + \" - \" + book.series[0].name\n                    if book.series_index:\n                        title = title + \" #\" + '{0:.2f}'.format(book.series_index).rstrip('0').rstrip('.')\n                log.debug(u\"Start comic reader for %d\", book_id)\n                return render_title_template('readcbr.html', comicfile=all_name, title=title,\n                                             extension=fileExt)\n        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n\n@web.route(\"/book/<int:book_id>\")\n@login_required_if_no_ano\ndef show_book(book_id):\n    entries = calibre_db.get_book_read_archived(book_id, config.config_read_column, allow_show_archived=True)\n    if entries:\n        read_book = entries[1]\n        archived_book = entries[2]\n        entry = entries[0]\n        entry.read_status = read_book == ub.ReadBook.STATUS_FINISHED\n        entry.is_archived = archived_book\n        for index in range(0, len(entry.languages)):\n            entry.languages[index].language_name = isoLanguages.get_language_name(get_locale(), entry.languages[\n                index].lang_code)\n        cc = get_cc_columns(filter_config_custom_read=True)\n        book_in_shelfs = []\n        shelfs = ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).all()\n        for sh in shelfs:\n            book_in_shelfs.append(sh.shelf)\n\n        entry.tags = sort(entry.tags, key=lambda tag: tag.name)\n\n        entry.ordered_authors = calibre_db.order_authors([entry])\n\n        entry.kindle_list = check_send_to_kindle(entry)\n        entry.reader_list = check_read_formats(entry)\n\n        entry.audioentries = []\n        for media_format in entry.data:\n            if media_format.format.lower() in constants.EXTENSIONS_AUDIO:\n                entry.audioentries.append(media_format.format.lower())\n\n        return render_title_template('detail.html',\n                                     entry=entry,\n                                     cc=cc,\n                                     is_xhr=request.headers.get('X-Requested-With')=='XMLHttpRequest',\n                                     title=entry.title,\n                                     books_shelfs=book_in_shelfs,\n                                     page=\"book\")\n    else:\n        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),\n              category=\"error\")\n        return redirect(url_for(\"web.index\"))\n", "# GDrive Integration\ngoogle-api-python-client>=1.7.11,<2.37.0\ngevent>20.6.0,<22.0.0\ngreenlet>=0.4.17,<1.2.0\nhttplib2>=0.9.2,<0.21.0\noauth2client>=4.0.0,<4.1.4\nuritemplate>=3.0.0,<4.2.0\npyasn1-modules>=0.0.8,<0.3.0\npyasn1>=0.1.9,<0.5.0\nPyDrive2>=1.3.1,<1.11.0\nPyYAML>=3.12\nrsa>=3.4.2,<4.9.0\n\n# Gmail\ngoogle-auth-oauthlib>=0.4.3,<0.5.0\ngoogle-api-python-client>=1.7.11,<2.37.0\n\n# goodreads\ngoodreads>=0.3.2,<0.4.0\npython-Levenshtein>=0.12.0,<0.13.0\n\n# ldap login\npython-ldap>=3.0.0,<3.5.0\nFlask-SimpleLDAP>=1.4.0,<1.5.0\n\n# oauth\nFlask-Dance>=2.0.0,<5.2.0\nSQLAlchemy-Utils>=0.33.5,<0.39.0\n\n# metadata extraction\nrarfile>=3.2\nscholarly>=1.2.0,<1.6\nmarkdown2>=2.0.0,<2.5.0\nhtml2text>=2020.1.16,<2022.1.1\npython-dateutil>=2.1,<2.9.0\nbeautifulsoup4>=4.0.1,<4.11.0\ncchardet>=2.0.0,<2.2.0\n\n# Comics\nnatsort>=2.2.0,<8.2.0\ncomicapi>=2.2.0,<2.3.0\n\n# Kobo integration\njsonschema>=3.2.0,<4.5.0\n", "Babel>=1.3,<3.0\nFlask-Babel>=0.11.1,<2.1.0\nFlask-Login>=0.3.2,<0.5.1\nFlask-Principal>=0.3.2,<0.5.1\nbackports_abc>=0.4\nFlask>=1.0.2,<2.1.0\niso-639>=0.4.5,<0.5.0\nPyPDF3>=1.0.0,<1.0.7\npytz>=2016.10\nrequests>=2.11.1,<2.28.0\nSQLAlchemy>=1.3.0,<1.5.0\ntornado>=4.1,<6.2\nWand>=0.4.4,<0.7.0\nunidecode>=0.04.19,<1.4.0\nlxml>=3.8.0,<4.8.0\nflask-wtf>=0.14.2,<1.1.0\nchardet>=3.0.0,<4.1.0\n"], "fixing_code": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2012-2019  OzzieIsaacs\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\ntry:\n    from gevent import monkey\n    monkey.patch_all()\nexcept ImportError:\n    pass\n\nimport sys\nimport os\n\n\n# Insert local directories into path\nsys.path.append(os.path.dirname(os.path.abspath(__file__)))\nsys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), 'vendor'))\n\n\nfrom cps import create_app\nfrom cps import web_server\nfrom cps.opds import opds\nfrom cps.web import web\nfrom cps.jinjia import jinjia\nfrom cps.about import about\nfrom cps.shelf import shelf\nfrom cps.admin import admi\nfrom cps.gdrive import gdrive\nfrom cps.editbooks import EditBook\nfrom cps.remotelogin import remotelogin\nfrom cps.search_metadata import meta\nfrom cps.error_handler import init_errorhandler\n\ntry:\n    from cps.kobo import kobo, get_kobo_activated\n    from cps.kobo_auth import kobo_auth\n    kobo_available = get_kobo_activated()\nexcept (ImportError, AttributeError):   # Catch also error for not installed flask-WTF (missing csrf decorator)\n    kobo_available = False\n\ntry:\n    from cps.oauth_bb import oauth\n    oauth_available = True\nexcept ImportError:\n    oauth_available = False\n\n\ndef main():\n    app = create_app()\n\n    init_errorhandler()\n\n    app.register_blueprint(web)\n    app.register_blueprint(opds)\n    app.register_blueprint(jinjia)\n    app.register_blueprint(about)\n    app.register_blueprint(shelf)\n    app.register_blueprint(admi)\n    app.register_blueprint(remotelogin)\n    app.register_blueprint(meta)\n    app.register_blueprint(gdrive)\n    app.register_blueprint(EditBook)\n    if kobo_available:\n        app.register_blueprint(kobo)\n        app.register_blueprint(kobo_auth)\n    if oauth_available:\n        app.register_blueprint(oauth)\n    success = web_server.start()\n    sys.exit(0 if success else 1)\n\n\nif __name__ == '__main__':\n    main()\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n__package__ = \"cps\"\n\nimport sys\nimport os\nimport mimetypes\n\nfrom babel import Locale as LC\nfrom babel import negotiate_locale\nfrom babel.core import UnknownLocaleError\nfrom flask import Flask, request, g\nfrom .MyLoginManager import MyLoginManager\nfrom flask_babel import Babel\nfrom flask_principal import Principal\n\nfrom . import config_sql, logger, cache_buster, cli, ub, db\nfrom .reverseproxy import ReverseProxied\nfrom .server import WebServer\nfrom .dep_check import dependency_check\n\ntry:\n    import lxml\n    lxml_present = True\nexcept ImportError:\n    lxml_present = False\n\ntry:\n    from flask_wtf.csrf import CSRFProtect\n    wtf_present = True\nexcept ImportError:\n    wtf_present = False\n\nmimetypes.init()\nmimetypes.add_type('application/xhtml+xml', '.xhtml')\nmimetypes.add_type('application/epub+zip', '.epub')\nmimetypes.add_type('application/fb2+zip', '.fb2')\nmimetypes.add_type('application/x-mobipocket-ebook', '.mobi')\nmimetypes.add_type('application/x-mobipocket-ebook', '.prc')\nmimetypes.add_type('application/vnd.amazon.ebook', '.azw')\nmimetypes.add_type('application/x-mobi8-ebook', '.azw3')\nmimetypes.add_type('application/x-cbr', '.cbr')\nmimetypes.add_type('application/x-cbz', '.cbz')\nmimetypes.add_type('application/x-cbt', '.cbt')\nmimetypes.add_type('image/vnd.djvu', '.djvu')\nmimetypes.add_type('application/mpeg', '.mpeg')\nmimetypes.add_type('application/mpeg', '.mp3')\nmimetypes.add_type('application/mp4', '.m4a')\nmimetypes.add_type('application/mp4', '.m4b')\nmimetypes.add_type('application/ogg', '.ogg')\nmimetypes.add_type('application/ogg', '.oga')\nmimetypes.add_type('text/css', '.css')\nmimetypes.add_type('text/javascript; charset=UTF-8', '.js')\n\napp = Flask(__name__)\napp.config.update(\n    SESSION_COOKIE_HTTPONLY=True,\n    SESSION_COOKIE_SAMESITE='Lax',\n    REMEMBER_COOKIE_SAMESITE='Lax',  # will be available in flask-login 0.5.1 earliest\n    WTF_CSRF_SSL_STRICT=False\n)\n\n\nlm = MyLoginManager()\nlm.login_view = 'web.login'\nlm.anonymous_user = ub.Anonymous\nlm.session_protection = 'strong'\n\nif wtf_present:\n    csrf = CSRFProtect()\n    csrf.init_app(app)\nelse:\n    csrf = None\n\nub.init_db(cli.settingspath)\n# pylint: disable=no-member\nconfig = config_sql.load_configuration(ub.session)\n\nweb_server = WebServer()\n\nbabel = Babel()\n_BABEL_TRANSLATIONS = set()\n\nlog = logger.create()\n\n\nfrom . import services\n\ndb.CalibreDB.update_config(config)\ndb.CalibreDB.setup_db(config.config_calibre_dir, cli.settingspath)\n\n\ncalibre_db = db.CalibreDB()\n\ndef create_app():\n    if sys.version_info < (3, 0):\n        log.info(\n            '*** Python2 is EOL since end of 2019, this version of Calibre-Web is no longer supporting Python2, please update your installation to Python3 ***')\n        print(\n            '*** Python2 is EOL since end of 2019, this version of Calibre-Web is no longer supporting Python2, please update your installation to Python3 ***')\n        web_server.stop(True)\n        sys.exit(5)\n    if not lxml_present:\n        log.info('*** \"lxml\" is needed for calibre-web to run. Please install it using pip: \"pip install lxml\" ***')\n        print('*** \"lxml\" is needed for calibre-web to run. Please install it using pip: \"pip install lxml\" ***')\n        web_server.stop(True)\n        sys.exit(6)\n    if not wtf_present:\n        log.info('*** \"flask-WTF\" is needed for calibre-web to run. Please install it using pip: \"pip install flask-WTF\" ***')\n        print('*** \"flask-WTF\" is needed for calibre-web to run. Please install it using pip: \"pip install flask-WTF\" ***')\n        web_server.stop(True)\n        sys.exit(7)\n    for res in dependency_check() + dependency_check(True):\n        log.info('*** \"{}\" version does not fit the requirements. Should: {}, Found: {}, please consider installing required version ***'\n            .format(res['name'],\n                 res['target'],\n                 res['found']))\n    app.wsgi_app = ReverseProxied(app.wsgi_app)\n\n    if os.environ.get('FLASK_DEBUG'):\n        cache_buster.init_cache_busting(app)\n    log.info('Starting Calibre Web...')\n\n    Principal(app)\n    lm.init_app(app)\n    app.secret_key = os.getenv('SECRET_KEY', config_sql.get_flask_session_key(ub.session))\n\n    web_server.init_app(app, config)\n\n    babel.init_app(app)\n    _BABEL_TRANSLATIONS.update(str(item) for item in babel.list_translations())\n    _BABEL_TRANSLATIONS.add('en')\n\n    if services.ldap:\n        services.ldap.init_app(app, config)\n    if services.goodreads_support:\n        services.goodreads_support.connect(config.config_goodreads_api_key,\n                                           config.config_goodreads_api_secret,\n                                           config.config_use_goodreads)\n    config.store_calibre_uuid(calibre_db, db.LibraryId)\n    return app\n\n@babel.localeselector\ndef get_locale():\n    # if a user is logged in, use the locale from the user settings\n    user = getattr(g, 'user', None)\n    if user is not None and hasattr(user, \"locale\"):\n        if user.name != 'Guest':   # if the account is the guest account bypass the config lang settings\n            return user.locale\n\n    preferred = list()\n    if request.accept_languages:\n        for x in request.accept_languages.values():\n            try:\n                preferred.append(str(LC.parse(x.replace('-', '_'))))\n            except (UnknownLocaleError, ValueError) as e:\n                log.debug('Could not parse locale \"%s\": %s', x, e)\n\n    return negotiate_locale(preferred or ['en'], _BABEL_TRANSLATIONS)\n\n\n@babel.timezoneselector\ndef get_timezone():\n    user = getattr(g, 'user', None)\n    return user.timezone if user else None\n\n\nfrom .updater import Updater\nupdater_thread = Updater()\n\n# Perform dry run of updater and exit afterwards\nif cli.dry_run:\n    updater_thread.dry_run()\n    sys.exit(0)\nupdater_thread.start()\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler, GammaC0de, vuolter\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport re\nimport base64\nimport json\nimport time\nimport operator\nfrom datetime import datetime, timedelta\nfrom functools import wraps\n\nfrom babel import Locale\nfrom babel.dates import format_datetime\nfrom flask import Blueprint, flash, redirect, url_for, abort, request, make_response, send_from_directory, g, Response\nfrom flask_login import login_required, current_user, logout_user, confirm_login\nfrom flask_babel import gettext as _\nfrom flask import session as flask_session\nfrom sqlalchemy import and_\nfrom sqlalchemy.orm.attributes import flag_modified\nfrom sqlalchemy.exc import IntegrityError, OperationalError, InvalidRequestError\nfrom sqlalchemy.sql.expression import func, or_, text\n\nfrom . import constants, logger, helper, services, cli\nfrom . import db, calibre_db, ub, web_server, get_locale, config, updater_thread, babel, gdriveutils, kobo_sync_status\nfrom .helper import check_valid_domain, send_test_mail, reset_password, generate_password_hash, check_email, \\\n    valid_email, check_username\nfrom .gdriveutils import is_gdrive_ready, gdrive_support\nfrom .render_template import render_title_template, get_sidebar_config\nfrom . import debug_info, _BABEL_TRANSLATIONS\n\n\nlog = logger.create()\n\nfeature_support = {\n        'ldap': bool(services.ldap),\n        'goodreads': bool(services.goodreads_support),\n        'kobo':  bool(services.kobo),\n        'updater': constants.UPDATER_AVAILABLE,\n        'gmail': bool(services.gmail)\n    }\n\ntry:\n    import rarfile  # pylint: disable=unused-import\n    feature_support['rar'] = True\nexcept (ImportError, SyntaxError):\n    feature_support['rar'] = False\n\ntry:\n    from .oauth_bb import oauth_check, oauthblueprints\n    feature_support['oauth'] = True\nexcept ImportError as err:\n    log.debug('Cannot import Flask-Dance, login with Oauth will not work: %s', err)\n    feature_support['oauth'] = False\n    oauthblueprints = []\n    oauth_check = {}\n\n\nfeature_support['gdrive'] = gdrive_support\nadmi = Blueprint('admin', __name__)\n\n\ndef admin_required(f):\n    \"\"\"\n    Checks if current_user.role == 1\n    \"\"\"\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_admin():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n\n@admi.before_app_request\ndef before_request():\n    # make remember me function work\n    if current_user.is_authenticated:\n        confirm_login()\n    if not ub.check_user_session(current_user.id, flask_session.get('_id')) and 'opds' not in request.path:\n        logout_user()\n    g.constants = constants\n    g.user = current_user\n    g.allow_registration = config.config_public_reg\n    g.allow_anonymous = config.config_anonbrowse\n    g.allow_upload = config.config_uploading\n    g.current_theme = config.config_theme\n    g.config_authors_max = config.config_authors_max\n    g.shelves_access = ub.session.query(ub.Shelf).filter(\n        or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == current_user.id)).order_by(ub.Shelf.name).all()\n    if '/static/' not in request.path and not config.db_configured and \\\n        request.endpoint not in ('admin.ajax_db_config',\n                                 'admin.simulatedbchange',\n                                 'admin.db_configuration',\n                                 'web.login',\n                                 'web.logout',\n                                 'admin.load_dialogtexts',\n                                 'admin.ajax_pathchooser'):\n        return redirect(url_for('admin.db_configuration'))\n\n\n@admi.route(\"/admin\")\n@login_required\ndef admin_forbidden():\n    abort(403)\n\n\n@admi.route(\"/shutdown\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef shutdown():\n    task = request.get_json().get('parameter', -1)\n    showtext = {}\n    if task in (0, 1):  # valid commandos received\n        # close all database connections\n        calibre_db.dispose()\n        ub.dispose()\n\n        if task == 0:\n            showtext['text'] = _(u'Server restarted, please reload page')\n        else:\n            showtext['text'] = _(u'Performing shutdown of server, please close window')\n        # stop gevent/tornado server\n        web_server.stop(task == 0)\n        return json.dumps(showtext)\n\n    if task == 2:\n        log.warning(\"reconnecting to calibre database\")\n        calibre_db.reconnect_db(config, ub.app_DB_path)\n        showtext['text'] = _(u'Reconnect successful')\n        return json.dumps(showtext)\n\n    showtext['text'] = _(u'Unknown command')\n    return json.dumps(showtext), 400\n\n\n# method is available without login and not protected by CSRF to make it easy reachable, is per default switched of\n# needed for docker applications, as changes on metadata.db from host are not visible to application\n@admi.route(\"/reconnect\", methods=['GET'])\ndef reconnect():\n    if cli.args.r:\n        calibre_db.reconnect_db(config, ub.app_DB_path)\n        return json.dumps({})\n    else:\n        log.debug(\"'/reconnect' was accessed but is not enabled\")\n        abort(404)\n\n\n@admi.route(\"/admin/view\")\n@login_required\n@admin_required\ndef admin():\n    version = updater_thread.get_current_version_info()\n    if version is False:\n        commit = _(u'Unknown')\n    else:\n        if 'datetime' in version:\n            commit = version['datetime']\n\n            tz = timedelta(seconds=time.timezone if (time.localtime().tm_isdst == 0) else time.altzone)\n            form_date = datetime.strptime(commit[:19], \"%Y-%m-%dT%H:%M:%S\")\n            if len(commit) > 19:    # check if string has timezone\n                if commit[19] == '+':\n                    form_date -= timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))\n                elif commit[19] == '-':\n                    form_date += timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))\n            commit = format_datetime(form_date - tz, format='short', locale=get_locale())\n        else:\n            commit = version['version']\n\n    all_user = ub.session.query(ub.User).all()\n    email_settings = config.get_mail_settings()\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    return render_title_template(\"admin.html\", allUser=all_user, email=email_settings, config=config, commit=commit,\n                                 feature_support=feature_support, kobo_support=kobo_support,\n                                 title=_(u\"Admin page\"), page=\"admin\")\n\n\n@admi.route(\"/admin/dbconfig\", methods=[\"GET\", \"POST\"])\n@login_required\n@admin_required\ndef db_configuration():\n    if request.method == \"POST\":\n        return _db_configuration_update_helper()\n    return _db_configuration_result()\n\n\n@admi.route(\"/admin/config\", methods=[\"GET\"])\n@login_required\n@admin_required\ndef configuration():\n    return render_title_template(\"config_edit.html\",\n                                 config=config,\n                                 provider=oauthblueprints,\n                                 feature_support=feature_support,\n                                 title=_(u\"Basic Configuration\"), page=\"config\")\n\n\n@admi.route(\"/admin/ajaxconfig\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef ajax_config():\n    return _configuration_update_helper()\n\n\n@admi.route(\"/admin/ajaxdbconfig\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef ajax_db_config():\n    return _db_configuration_update_helper()\n\n\n@admi.route(\"/admin/alive\", methods=[\"GET\"])\n@login_required\n@admin_required\ndef calibreweb_alive():\n    return \"\", 200\n\n\n@admi.route(\"/admin/viewconfig\")\n@login_required\n@admin_required\ndef view_configuration():\n    read_column = calibre_db.session.query(db.CustomColumns)\\\n        .filter(and_(db.CustomColumns.datatype == 'bool', db.CustomColumns.mark_for_delete == 0)).all()\n    restrict_columns = calibre_db.session.query(db.CustomColumns)\\\n        .filter(and_(db.CustomColumns.datatype == 'text', db.CustomColumns.mark_for_delete == 0)).all()\n    languages = calibre_db.speaking_language()\n    translations = [Locale('en')] + babel.list_translations()\n    return render_title_template(\"config_view_edit.html\", conf=config, readColumns=read_column,\n                                 restrictColumns=restrict_columns,\n                                 languages=languages,\n                                 translations=translations,\n                                 title=_(u\"UI Configuration\"), page=\"uiconfig\")\n\n\n@admi.route(\"/admin/usertable\")\n@login_required\n@admin_required\ndef edit_user_table():\n    visibility = current_user.view_settings.get('useredit', {})\n    languages = calibre_db.speaking_language()\n    translations = babel.list_translations() + [Locale('en')]\n    all_user = ub.session.query(ub.User)\n    tags = calibre_db.session.query(db.Tags)\\\n        .join(db.books_tags_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_tags_link.tag'))\\\n        .order_by(db.Tags.name).all()\n    if config.config_restricted_column:\n        custom_values = calibre_db.session.query(db.cc_classes[config.config_restricted_column]).all()\n    else:\n        custom_values = []\n    if not config.config_anonbrowse:\n        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    return render_title_template(\"user_table.html\",\n                                 users=all_user.all(),\n                                 tags=tags,\n                                 custom_values=custom_values,\n                                 translations=translations,\n                                 languages=languages,\n                                 visiblility=visibility,\n                                 all_roles=constants.ALL_ROLES,\n                                 kobo_support=kobo_support,\n                                 sidebar_settings=constants.sidebar_settings,\n                                 title=_(u\"Edit Users\"),\n                                 page=\"usertable\")\n\n\n@admi.route(\"/ajax/listusers\")\n@login_required\n@admin_required\ndef list_users():\n    off = int(request.args.get(\"offset\") or 0)\n    limit = int(request.args.get(\"limit\") or 10)\n    search = request.args.get(\"search\")\n    sort = request.args.get(\"sort\", \"id\")\n    state = None\n    if sort == \"state\":\n        state = json.loads(request.args.get(\"state\", \"[]\"))\n    else:\n        if sort not in ub.User.__table__.columns.keys():\n            sort = \"id\"\n    order = request.args.get(\"order\", \"\").lower()\n\n    if sort != \"state\" and order:\n        order = text(sort + \" \" + order)\n    elif not state:\n        order = ub.User.id.asc()\n\n    all_user = ub.session.query(ub.User)\n    if not config.config_anonbrowse:\n        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)\n\n    total_count = filtered_count = all_user.count()\n\n    if search:\n        all_user = all_user.filter(or_(func.lower(ub.User.name).ilike(\"%\" + search + \"%\"),\n                                       func.lower(ub.User.kindle_mail).ilike(\"%\" + search + \"%\"),\n                                       func.lower(ub.User.email).ilike(\"%\" + search + \"%\")))\n    if state:\n        users = calibre_db.get_checkbox_sorted(all_user.all(), state, off, limit, request.args.get(\"order\", \"\").lower())\n    else:\n        users = all_user.order_by(order).offset(off).limit(limit).all()\n    if search:\n        filtered_count = len(users)\n\n    for user in users:\n        if user.default_language == \"all\":\n            user.default = _(\"All\")\n        else:\n            user.default = Locale.parse(user.default_language).get_language_name(get_locale())\n\n    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": users}\n    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)\n    response = make_response(js_list)\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n\n@admi.route(\"/ajax/deleteuser\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_user():\n    user_ids = request.form.to_dict(flat=False)\n    users = None\n    message = \"\"\n    if \"userid[]\" in user_ids:\n        users = ub.session.query(ub.User).filter(ub.User.id.in_(user_ids['userid[]'])).all()\n    elif \"userid\" in user_ids:\n        users = ub.session.query(ub.User).filter(ub.User.id == user_ids['userid'][0]).all()\n    count = 0\n    errors = list()\n    success = list()\n    if not users:\n        log.error(\"User not found\")\n        return Response(json.dumps({'type': \"danger\", 'message': _(\"User not found\")}), mimetype='application/json')\n    for user in users:\n        try:\n            message = _delete_user(user)\n            count += 1\n        except Exception as ex:\n            log.error(ex)\n            errors.append({'type': \"danger\", 'message': str(ex)})\n\n    if count == 1:\n        log.info(\"User {} deleted\".format(user_ids))\n        success = [{'type': \"success\", 'message': message}]\n    elif count > 1:\n        log.info(\"Users {} deleted\".format(user_ids))\n        success = [{'type': \"success\", 'message': _(\"{} users deleted successfully\").format(count)}]\n    success.extend(errors)\n    return Response(json.dumps(success), mimetype='application/json')\n\n\n@admi.route(\"/ajax/getlocale\")\n@login_required\n@admin_required\ndef table_get_locale():\n    locale = babel.list_translations() + [Locale('en')]\n    ret = list()\n    current_locale = get_locale()\n    for loc in locale:\n        ret.append({'value': str(loc), 'text': loc.get_language_name(current_locale)})\n    return json.dumps(ret)\n\n\n@admi.route(\"/ajax/getdefaultlanguage\")\n@login_required\n@admin_required\ndef table_get_default_lang():\n    languages = calibre_db.speaking_language()\n    ret = list()\n    ret.append({'value': 'all', 'text': _('Show All')})\n    for lang in languages:\n        ret.append({'value': lang.lang_code, 'text': lang.name})\n    return json.dumps(ret)\n\n\n@admi.route(\"/ajax/editlistusers/<param>\", methods=['POST'])\n@login_required\n@admin_required\ndef edit_list_user(param):\n    vals = request.form.to_dict(flat=False)\n    all_user = ub.session.query(ub.User)\n    if not config.config_anonbrowse:\n        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)\n    # only one user is posted\n    if \"pk\" in vals:\n        users = [all_user.filter(ub.User.id == vals['pk'][0]).one_or_none()]\n    else:\n        if \"pk[]\" in vals:\n            users = all_user.filter(ub.User.id.in_(vals['pk[]'])).all()\n        else:\n            return _(\"Malformed request\"), 400\n    if 'field_index' in vals:\n        vals['field_index'] = vals['field_index'][0]\n    if 'value' in vals:\n        vals['value'] = vals['value'][0]\n    elif not ('value[]' in vals):\n        return _(\"Malformed request\"), 400\n    for user in users:\n        try:\n            if param in ['denied_tags', 'allowed_tags', 'allowed_column_value', 'denied_column_value']:\n                if 'value[]' in vals:\n                    setattr(user, param, prepare_tags(user, vals['action'][0], param, vals['value[]']))\n                else:\n                    setattr(user, param, vals['value'].strip())\n            else:\n                vals['value'] = vals['value'].strip()\n                if param == 'name':\n                    if user.name == \"Guest\":\n                        raise Exception(_(\"Guest Name can't be changed\"))\n                    user.name = check_username(vals['value'])\n                elif param == 'email':\n                    user.email = check_email(vals['value'])\n                elif param == 'kobo_only_shelves_sync':\n                    user.kobo_only_shelves_sync = int(vals['value'] == 'true')\n                elif param == 'kindle_mail':\n                    user.kindle_mail = valid_email(vals['value']) if vals['value'] else \"\"\n                elif param.endswith('role'):\n                    value = int(vals['field_index'])\n                    if user.name == \"Guest\" and value in \\\n                            [constants.ROLE_ADMIN, constants.ROLE_PASSWD, constants.ROLE_EDIT_SHELFS]:\n                        raise Exception(_(\"Guest can't have this role\"))\n                    # check for valid value, last on checks for power of 2 value\n                    if value > 0 and value <= constants.ROLE_VIEWER and (value & value-1 == 0 or value == 1):\n                        if vals['value'] == 'true':\n                            user.role |= value\n                        elif vals['value'] == 'false':\n                            if value == constants.ROLE_ADMIN:\n                                if not ub.session.query(ub.User).\\\n                                       filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,\n                                              ub.User.id != user.id).count():\n                                    return Response(\n                                        json.dumps([{'type': \"danger\",\n                                                     'message': _(u\"No admin user remaining, can't remove admin role\",\n                                                                  nick=user.name)}]), mimetype='application/json')\n                            user.role &= ~value\n                        else:\n                            raise Exception(_(\"Value has to be true or false\"))\n                    else:\n                        raise Exception(_(\"Invalid role\"))\n                elif param.startswith('sidebar'):\n                    value = int(vals['field_index'])\n                    if user.name == \"Guest\" and value == constants.SIDEBAR_READ_AND_UNREAD:\n                        raise Exception(_(\"Guest can't have this view\"))\n                    # check for valid value, last on checks for power of 2 value\n                    if value > 0 and value <= constants.SIDEBAR_LIST and (value & value-1 == 0 or value == 1):\n                        if vals['value'] == 'true':\n                            user.sidebar_view |= value\n                        elif vals['value'] == 'false':\n                            user.sidebar_view &= ~value\n                        else:\n                            raise Exception(_(\"Value has to be true or false\"))\n                    else:\n                        raise Exception(_(\"Invalid view\"))\n                elif param == 'locale':\n                    if user.name == \"Guest\":\n                        raise Exception(_(\"Guest's Locale is determined automatically and can't be set\"))\n                    if vals['value'] in _BABEL_TRANSLATIONS:\n                        user.locale = vals['value']\n                    else:\n                        raise Exception(_(\"No Valid Locale Given\"))\n                elif param == 'default_language':\n                    languages = calibre_db.session.query(db.Languages) \\\n                        .join(db.books_languages_link) \\\n                        .join(db.Books) \\\n                        .filter(calibre_db.common_filters()) \\\n                        .group_by(text('books_languages_link.lang_code')).all()\n                    lang_codes = [lang.lang_code for lang in languages] + [\"all\"]\n                    if vals['value'] in lang_codes:\n                        user.default_language = vals['value']\n                    else:\n                        raise Exception(_(\"No Valid Book Language Given\"))\n                else:\n                    return _(\"Parameter not found\"), 400\n        except Exception as ex:\n            log.error_or_exception(ex)\n            return str(ex), 400\n    ub.session_commit()\n    return \"\"\n\n\n@admi.route(\"/ajax/user_table_settings\", methods=['POST'])\n@login_required\n@admin_required\ndef update_table_settings():\n    current_user.view_settings['useredit'] = json.loads(request.data)\n    try:\n        try:\n            flag_modified(current_user, \"view_settings\")\n        except AttributeError:\n            pass\n        ub.session.commit()\n    except (InvalidRequestError, OperationalError):\n        log.error(\"Invalid request received: {}\".format(request))\n        return \"Invalid request\", 400\n    return \"\"\n\n\ndef check_valid_read_column(column):\n    if column != \"0\":\n        if not calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.id == column) \\\n              .filter(and_(db.CustomColumns.datatype == 'bool', db.CustomColumns.mark_for_delete == 0)).all():\n            return False\n    return True\n\n\ndef check_valid_restricted_column(column):\n    if column != \"0\":\n        if not calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.id == column) \\\n              .filter(and_(db.CustomColumns.datatype == 'text', db.CustomColumns.mark_for_delete == 0)).all():\n            return False\n    return True\n\n\n@admi.route(\"/admin/viewconfig\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef update_view_configuration():\n    to_save = request.form.to_dict()\n\n    _config_string(to_save, \"config_calibre_web_title\")\n    _config_string(to_save, \"config_columns_to_ignore\")\n    if _config_string(to_save, \"config_title_regex\"):\n        calibre_db.update_title_sort(config)\n\n    if not check_valid_read_column(to_save.get(\"config_read_column\", \"0\")):\n        flash(_(u\"Invalid Read Column\"), category=\"error\")\n        log.debug(\"Invalid Read column\")\n        return view_configuration()\n    _config_int(to_save, \"config_read_column\")\n\n    if not check_valid_restricted_column(to_save.get(\"config_restricted_column\", \"0\")):\n        flash(_(u\"Invalid Restricted Column\"), category=\"error\")\n        log.debug(\"Invalid Restricted Column\")\n        return view_configuration()\n    _config_int(to_save, \"config_restricted_column\")\n\n    _config_int(to_save, \"config_theme\")\n    _config_int(to_save, \"config_random_books\")\n    _config_int(to_save, \"config_books_per_page\")\n    _config_int(to_save, \"config_authors_max\")\n    _config_string(to_save, \"config_default_language\")\n    _config_string(to_save, \"config_default_locale\")\n\n    config.config_default_role = constants.selected_roles(to_save)\n    config.config_default_role &= ~constants.ROLE_ANONYMOUS\n\n    config.config_default_show = sum(int(k[5:]) for k in to_save if k.startswith('show_'))\n    if \"Show_detail_random\" in to_save:\n        config.config_default_show |= constants.DETAIL_RANDOM\n\n    config.save()\n    flash(_(u\"Calibre-Web configuration updated\"), category=\"success\")\n    log.debug(\"Calibre-Web configuration updated\")\n    before_request()\n\n    return view_configuration()\n\n\n@admi.route(\"/ajax/loaddialogtexts/<element_id>\", methods=['POST'])\n@login_required\ndef load_dialogtexts(element_id):\n    texts = {\"header\": \"\", \"main\": \"\", \"valid\": 1}\n    if element_id == \"config_delete_kobo_token\":\n        texts[\"main\"] = _('Do you really want to delete the Kobo Token?')\n    elif element_id == \"btndeletedomain\":\n        texts[\"main\"] = _('Do you really want to delete this domain?')\n    elif element_id == \"btndeluser\":\n        texts[\"main\"] = _('Do you really want to delete this user?')\n    elif element_id == \"delete_shelf\":\n        texts[\"main\"] = _('Are you sure you want to delete this shelf?')\n    elif element_id == \"select_locale\":\n        texts[\"main\"] = _('Are you sure you want to change locales of selected user(s)?')\n    elif element_id == \"select_default_language\":\n        texts[\"main\"] = _('Are you sure you want to change visible book languages for selected user(s)?')\n    elif element_id == \"role\":\n        texts[\"main\"] = _('Are you sure you want to change the selected role for the selected user(s)?')\n    elif element_id == \"restrictions\":\n        texts[\"main\"] = _('Are you sure you want to change the selected restrictions for the selected user(s)?')\n    elif element_id == \"sidebar_view\":\n        texts[\"main\"] = _('Are you sure you want to change the selected visibility restrictions '\n                          'for the selected user(s)?')\n    elif element_id == \"kobo_only_shelves_sync\":\n        texts[\"main\"] = _('Are you sure you want to change shelf sync behavior for the selected user(s)?')\n    elif element_id == \"db_submit\":\n        texts[\"main\"] = _('Are you sure you want to change Calibre library location?')\n    elif element_id == \"btnfullsync\":\n        texts[\"main\"] = _(\"Are you sure you want delete Calibre-Web's sync database \"\n                          \"to force a full sync with your Kobo Reader?\")\n    return json.dumps(texts)\n\n\n@admi.route(\"/ajax/editdomain/<int:allow>\", methods=['POST'])\n@login_required\n@admin_required\ndef edit_domain(allow):\n    # POST /post\n    # name:  'username',  //name of field (column in db)\n    # pk:    1            //primary key (record id)\n    # value: 'superuser!' //new value\n    vals = request.form.to_dict()\n    answer = ub.session.query(ub.Registration).filter(ub.Registration.id == vals['pk']).first()\n    answer.domain = vals['value'].replace('*', '%').replace('?', '_').lower()\n    return ub.session_commit(\"Registering Domains edited {}\".format(answer.domain))\n\n\n@admi.route(\"/ajax/adddomain/<int:allow>\", methods=['POST'])\n@login_required\n@admin_required\ndef add_domain(allow):\n    domain_name = request.form.to_dict()['domainname'].replace('*', '%').replace('?', '_').lower()\n    check = ub.session.query(ub.Registration).filter(ub.Registration.domain == domain_name)\\\n        .filter(ub.Registration.allow == allow).first()\n    if not check:\n        new_domain = ub.Registration(domain=domain_name, allow=allow)\n        ub.session.add(new_domain)\n        ub.session_commit(\"Registering Domains added {}\".format(domain_name))\n    return \"\"\n\n\n@admi.route(\"/ajax/deletedomain\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_domain():\n    try:\n        domain_id = request.form.to_dict()['domainid'].replace('*', '%').replace('?', '_').lower()\n        ub.session.query(ub.Registration).filter(ub.Registration.id == domain_id).delete()\n        ub.session_commit(\"Registering Domains deleted {}\".format(domain_id))\n        # If last domain was deleted, add all domains by default\n        if not ub.session.query(ub.Registration).filter(ub.Registration.allow == 1).count():\n            new_domain = ub.Registration(domain=\"%.%\", allow=1)\n            ub.session.add(new_domain)\n            ub.session_commit(\"Last Registering Domain deleted, added *.* as default\")\n    except KeyError:\n        pass\n    return \"\"\n\n\n@admi.route(\"/ajax/domainlist/<int:allow>\")\n@login_required\n@admin_required\ndef list_domain(allow):\n    answer = ub.session.query(ub.Registration).filter(ub.Registration.allow == allow).all()\n    json_dumps = json.dumps([{\"domain\": r.domain.replace('%', '*').replace('_', '?'), \"id\": r.id} for r in answer])\n    js = json.dumps(json_dumps.replace('\"', \"'\")).lstrip('\"').strip('\"')\n    response = make_response(js.replace(\"'\", '\"'))\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n\n@admi.route(\"/ajax/editrestriction/<int:res_type>\", defaults={\"user_id\": 0}, methods=['POST'])\n@admi.route(\"/ajax/editrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])\n@login_required\n@admin_required\ndef edit_restriction(res_type, user_id):\n    element = request.form.to_dict()\n    if element['id'].startswith('a'):\n        if res_type == 0:  # Tags as template\n            elementlist = config.list_allowed_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_allowed_tags = ','.join(elementlist)\n            config.save()\n        if res_type == 1:  # CustomC\n            elementlist = config.list_allowed_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_allowed_column_value = ','.join(elementlist)\n            config.save()\n        if res_type == 2:  # Tags per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_allowed_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.allowed_tags = ','.join(elementlist)\n            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.allowed_tags))\n        if res_type == 3:  # CColumn per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_allowed_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.allowed_column_value = ','.join(elementlist)\n            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name, usr.allowed_column_value))\n    if element['id'].startswith('d'):\n        if res_type == 0:  # Tags as template\n            elementlist = config.list_denied_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_denied_tags = ','.join(elementlist)\n            config.save()\n        if res_type == 1:  # CustomC\n            elementlist = config.list_denied_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_denied_column_value = ','.join(elementlist)\n            config.save()\n        if res_type == 2:  # Tags per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_denied_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.denied_tags = ','.join(elementlist)\n            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.denied_tags))\n        if res_type == 3:  # CColumn per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_denied_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.denied_column_value = ','.join(elementlist)\n            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name, usr.denied_column_value))\n    return \"\"\n\n\ndef restriction_addition(element, list_func):\n    elementlist = list_func()\n    if elementlist == ['']:\n        elementlist = []\n    if not element['add_element'] in elementlist:\n        elementlist += [element['add_element']]\n    return ','.join(elementlist)\n\n\ndef restriction_deletion(element, list_func):\n    elementlist = list_func()\n    if element['Element'] in elementlist:\n        elementlist.remove(element['Element'])\n    return ','.join(elementlist)\n\n\ndef prepare_tags(user, action, tags_name, id_list):\n    if \"tags\" in tags_name:\n        tags = calibre_db.session.query(db.Tags).filter(db.Tags.id.in_(id_list)).all()\n        if not tags:\n            raise Exception(_(\"Tag not found\"))\n        new_tags_list = [x.name for x in tags]\n    else:\n        tags = calibre_db.session.query(db.cc_classes[config.config_restricted_column])\\\n            .filter(db.cc_classes[config.config_restricted_column].id.in_(id_list)).all()\n        new_tags_list = [x.value for x in tags]\n    saved_tags_list = user.__dict__[tags_name].split(\",\") if len(user.__dict__[tags_name]) else []\n    if action == \"remove\":\n        saved_tags_list = [x for x in saved_tags_list if x not in new_tags_list]\n    elif action == \"add\":\n        saved_tags_list.extend(x for x in new_tags_list if x not in saved_tags_list)\n    else:\n        raise Exception(_(\"Invalid Action\"))\n    return \",\".join(saved_tags_list)\n\n\n@admi.route(\"/ajax/addrestriction/<int:res_type>\", methods=['POST'])\n@login_required\n@admin_required\ndef add_user_0_restriction(res_type):\n    return add_restriction(res_type, 0)\n\n\n@admi.route(\"/ajax/addrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])\n@login_required\n@admin_required\ndef add_restriction(res_type, user_id):\n    element = request.form.to_dict()\n    if res_type == 0:  # Tags as template\n        if 'submit_allow' in element:\n            config.config_allowed_tags = restriction_addition(element, config.list_allowed_tags)\n            config.save()\n        elif 'submit_deny' in element:\n            config.config_denied_tags = restriction_addition(element, config.list_denied_tags)\n            config.save()\n    if res_type == 1:  # CCustom as template\n        if 'submit_allow' in element:\n            config.config_allowed_column_value = restriction_addition(element, config.list_denied_column_values)\n            config.save()\n        elif 'submit_deny' in element:\n            config.config_denied_column_value = restriction_addition(element, config.list_allowed_column_values)\n            config.save()\n    if res_type == 2:  # Tags per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if 'submit_allow' in element:\n            usr.allowed_tags = restriction_addition(element, usr.list_allowed_tags)\n            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.list_allowed_tags()))\n        elif 'submit_deny' in element:\n            usr.denied_tags = restriction_addition(element, usr.list_denied_tags)\n            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.list_denied_tags()))\n    if res_type == 3:  # CustomC per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if 'submit_allow' in element:\n            usr.allowed_column_value = restriction_addition(element, usr.list_allowed_column_values)\n            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name,\n                                                                                usr.list_allowed_column_values()))\n        elif 'submit_deny' in element:\n            usr.denied_column_value = restriction_addition(element, usr.list_denied_column_values)\n            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name,\n                                                                               usr.list_denied_column_values()))\n    return \"\"\n\n\n@admi.route(\"/ajax/deleterestriction/<int:res_type>\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_user_0_restriction(res_type):\n    return delete_restriction(res_type, 0)\n\n\n@admi.route(\"/ajax/deleterestriction/<int:res_type>/<int:user_id>\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_restriction(res_type, user_id):\n    element = request.form.to_dict()\n    if res_type == 0:  # Tags as template\n        if element['id'].startswith('a'):\n            config.config_allowed_tags = restriction_deletion(element, config.list_allowed_tags)\n            config.save()\n        elif element['id'].startswith('d'):\n            config.config_denied_tags = restriction_deletion(element, config.list_denied_tags)\n            config.save()\n    elif res_type == 1:  # CustomC as template\n        if element['id'].startswith('a'):\n            config.config_allowed_column_value = restriction_deletion(element, config.list_allowed_column_values)\n            config.save()\n        elif element['id'].startswith('d'):\n            config.config_denied_column_value = restriction_deletion(element, config.list_denied_column_values)\n            config.save()\n    elif res_type == 2:  # Tags per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if element['id'].startswith('a'):\n            usr.allowed_tags = restriction_deletion(element, usr.list_allowed_tags)\n            ub.session_commit(\"Deleted allowed tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))\n        elif element['id'].startswith('d'):\n            usr.denied_tags = restriction_deletion(element, usr.list_denied_tags)\n            ub.session_commit(\"Deleted denied tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))\n    elif res_type == 3:  # Columns per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if element['id'].startswith('a'):\n            usr.allowed_column_value = restriction_deletion(element, usr.list_allowed_column_values)\n            ub.session_commit(\"Deleted allowed columns of user {}: {}\".format(usr.name,\n                                                                              usr.list_allowed_column_values))\n\n        elif element['id'].startswith('d'):\n            usr.denied_column_value = restriction_deletion(element, usr.list_denied_column_values)\n            ub.session_commit(\"Deleted denied columns of user {}: {}\".format(usr.name,\n                                                                             usr.list_denied_column_values))\n    return \"\"\n\n\n@admi.route(\"/ajax/listrestriction/<int:res_type>\", defaults={\"user_id\": 0})\n@admi.route(\"/ajax/listrestriction/<int:res_type>/<int:user_id>\")\n@login_required\n@admin_required\ndef list_restriction(res_type, user_id):\n    if res_type == 0:   # Tags as template\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(config.list_denied_tags()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(config.list_allowed_tags()) if x != '']\n        json_dumps = restrict + allow\n    elif res_type == 1:  # CustomC as template\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(config.list_denied_column_values()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(config.list_allowed_column_values()) if x != '']\n        json_dumps = restrict + allow\n    elif res_type == 2:  # Tags per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n        else:\n            usr = current_user\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(usr.list_denied_tags()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(usr.list_allowed_tags()) if x != '']\n        json_dumps = restrict + allow\n    elif res_type == 3:  # CustomC per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n        else:\n            usr = current_user\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(usr.list_denied_column_values()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(usr.list_allowed_column_values()) if x != '']\n        json_dumps = restrict + allow\n    else:\n        json_dumps = \"\"\n    js = json.dumps(json_dumps)\n    response = make_response(js)\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n\n@admi.route(\"/ajax/fullsync\", methods=[\"POST\"])\n@login_required\ndef ajax_fullsync():\n    count = ub.session.query(ub.KoboSyncedBooks).filter(current_user.id == ub.KoboSyncedBooks.user_id).delete()\n    message = _(\"{} sync entries deleted\").format(count)\n    ub.session_commit(message)\n    return Response(json.dumps([{\"type\": \"success\", \"message\": message}]), mimetype='application/json')\n\n\n@admi.route(\"/ajax/pathchooser/\")\n@login_required\n@admin_required\ndef ajax_pathchooser():\n    return pathchooser()\n\n\ndef pathchooser():\n    browse_for = \"folder\"\n    folder_only = request.args.get('folder', False) == \"true\"\n    file_filter = request.args.get('filter', \"\")\n    path = os.path.normpath(request.args.get('path', \"\"))\n\n    if os.path.isfile(path):\n        oldfile = path\n        path = os.path.dirname(path)\n    else:\n        oldfile = \"\"\n\n    absolute = False\n\n    if os.path.isdir(path):\n        # if os.path.isabs(path):\n        cwd = os.path.realpath(path)\n        absolute = True\n        # else:\n        #    cwd = os.path.relpath(path)\n    else:\n        cwd = os.getcwd()\n\n    cwd = os.path.normpath(os.path.realpath(cwd))\n    parentdir = os.path.dirname(cwd)\n    if not absolute:\n        if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n            cwd = os.path.relpath(cwd)\n        else:\n            cwd = os.path.relpath(cwd) + os.path.sep\n        parentdir = os.path.relpath(parentdir) + os.path.sep\n\n    if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n        parentdir = \"\"\n\n    try:\n        folders = os.listdir(cwd)\n    except Exception:\n        folders = []\n\n    files = []\n    for f in folders:\n        try:\n            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}\n            data[\"sort\"] = data[\"fullpath\"].lower()\n        except Exception:\n            continue\n\n        if os.path.isfile(os.path.join(cwd, f)):\n            if folder_only:\n                continue\n            if file_filter != \"\" and file_filter != f:\n                continue\n            data[\"type\"] = \"file\"\n            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))\n\n            power = 0\n            while (data[\"size\"] >> 10) > 0.3:\n                power += 1\n                data[\"size\"] >>= 10\n            units = (\"\", \"K\", \"M\", \"G\", \"T\")\n            data[\"size\"] = str(data[\"size\"]) + \" \" + units[power] + \"Byte\"\n        else:\n            data[\"type\"] = \"dir\"\n            data[\"size\"] = \"\"\n\n        files.append(data)\n\n    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))\n\n    context = {\n        \"cwd\": cwd,\n        \"files\": files,\n        \"parentdir\": parentdir,\n        \"type\": browse_for,\n        \"oldfile\": oldfile,\n        \"absolute\": absolute,\n    }\n    return json.dumps(context)\n\n\ndef _config_int(to_save, x, func=int):\n    return config.set_from_dictionary(to_save, x, func)\n\n\ndef _config_checkbox(to_save, x):\n    return config.set_from_dictionary(to_save, x, lambda y: y == \"on\", False)\n\n\ndef _config_checkbox_int(to_save, x):\n    return config.set_from_dictionary(to_save, x, lambda y: 1 if (y == \"on\") else 0, 0)\n\n\ndef _config_string(to_save, x):\n    return config.set_from_dictionary(to_save, x, lambda y: y.strip() if y else y)\n\n\ndef _configuration_gdrive_helper(to_save):\n    gdrive_error = None\n    if to_save.get(\"config_use_google_drive\"):\n        gdrive_secrets = {}\n\n        if not os.path.isfile(gdriveutils.SETTINGS_YAML):\n            config.config_use_google_drive = False\n\n        if gdrive_support:\n            gdrive_error = gdriveutils.get_error_text(gdrive_secrets)\n        if \"config_use_google_drive\" in to_save and not config.config_use_google_drive and not gdrive_error:\n            with open(gdriveutils.CLIENT_SECRETS, 'r') as settings:\n                gdrive_secrets = json.load(settings)['web']\n            if not gdrive_secrets:\n                return _configuration_result(_('client_secrets.json Is Not Configured For Web Application'))\n            gdriveutils.update_settings(\n                                gdrive_secrets['client_id'],\n                                gdrive_secrets['client_secret'],\n                                gdrive_secrets['redirect_uris'][0]\n                            )\n\n    # always show google drive settings, but in case of error deny support\n    new_gdrive_value = (not gdrive_error) and (\"config_use_google_drive\" in to_save)\n    if config.config_use_google_drive and not new_gdrive_value:\n        config.config_google_drive_watch_changes_response = {}\n    config.config_use_google_drive = new_gdrive_value\n    if _config_string(to_save, \"config_google_drive_folder\"):\n        gdriveutils.deleteDatabaseOnChange()\n    return gdrive_error\n\n\ndef _configuration_oauth_helper(to_save):\n    active_oauths = 0\n    reboot_required = False\n    for element in oauthblueprints:\n        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] != element['oauth_client_id'] \\\n                or to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"] != element['oauth_client_secret']:\n            reboot_required = True\n            element['oauth_client_id'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"]\n            element['oauth_client_secret'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]\n        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] \\\n                and to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]:\n            active_oauths += 1\n            element[\"active\"] = 1\n        else:\n            element[\"active\"] = 0\n        ub.session.query(ub.OAuthProvider).filter(ub.OAuthProvider.id == element['id']).update(\n            {\"oauth_client_id\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"],\n             \"oauth_client_secret\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"],\n             \"active\": element[\"active\"]})\n    return reboot_required\n\n\ndef _configuration_logfile_helper(to_save):\n    reboot_required = False\n    reboot_required |= _config_int(to_save, \"config_log_level\")\n    reboot_required |= _config_string(to_save, \"config_logfile\")\n    if not logger.is_valid_logfile(config.config_logfile):\n        return reboot_required, \\\n               _configuration_result(_('Logfile Location is not Valid, Please Enter Correct Path'))\n\n    reboot_required |= _config_checkbox_int(to_save, \"config_access_log\")\n    reboot_required |= _config_string(to_save, \"config_access_logfile\")\n    if not logger.is_valid_logfile(config.config_access_logfile):\n        return reboot_required, \\\n               _configuration_result(_('Access Logfile Location is not Valid, Please Enter Correct Path'))\n    return reboot_required, None\n\n\ndef _configuration_ldap_helper(to_save):\n    reboot_required = False\n    reboot_required |= _config_string(to_save, \"config_ldap_provider_url\")\n    reboot_required |= _config_int(to_save, \"config_ldap_port\")\n    reboot_required |= _config_int(to_save, \"config_ldap_authentication\")\n    reboot_required |= _config_string(to_save, \"config_ldap_dn\")\n    reboot_required |= _config_string(to_save, \"config_ldap_serv_username\")\n    reboot_required |= _config_string(to_save, \"config_ldap_user_object\")\n    reboot_required |= _config_string(to_save, \"config_ldap_group_object_filter\")\n    reboot_required |= _config_string(to_save, \"config_ldap_group_members_field\")\n    reboot_required |= _config_string(to_save, \"config_ldap_member_user_object\")\n    reboot_required |= _config_checkbox(to_save, \"config_ldap_openldap\")\n    reboot_required |= _config_int(to_save, \"config_ldap_encryption\")\n    reboot_required |= _config_string(to_save, \"config_ldap_cacert_path\")\n    reboot_required |= _config_string(to_save, \"config_ldap_cert_path\")\n    reboot_required |= _config_string(to_save, \"config_ldap_key_path\")\n    _config_string(to_save, \"config_ldap_group_name\")\n    if to_save.get(\"config_ldap_serv_password\", \"\") != \"\":\n        reboot_required |= 1\n        config.set_from_dictionary(to_save, \"config_ldap_serv_password\", base64.b64encode, encode='UTF-8')\n    config.save()\n\n    if not config.config_ldap_provider_url \\\n        or not config.config_ldap_port \\\n        or not config.config_ldap_dn \\\n            or not config.config_ldap_user_object:\n        return reboot_required, _configuration_result(_('Please Enter a LDAP Provider, '\n                                                        'Port, DN and User Object Identifier'))\n\n    if config.config_ldap_authentication > constants.LDAP_AUTH_ANONYMOUS:\n        if config.config_ldap_authentication > constants.LDAP_AUTH_UNAUTHENTICATE:\n            if not config.config_ldap_serv_username or not bool(config.config_ldap_serv_password):\n                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account and Password'))\n        else:\n            if not config.config_ldap_serv_username:\n                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account'))\n\n    if config.config_ldap_group_object_filter:\n        if config.config_ldap_group_object_filter.count(\"%s\") != 1:\n            return reboot_required, \\\n                   _configuration_result(_('LDAP Group Object Filter Needs to Have One \"%s\" Format Identifier'))\n        if config.config_ldap_group_object_filter.count(\"(\") != config.config_ldap_group_object_filter.count(\")\"):\n            return reboot_required, _configuration_result(_('LDAP Group Object Filter Has Unmatched Parenthesis'))\n\n    if config.config_ldap_user_object.count(\"%s\") != 1:\n        return reboot_required, \\\n               _configuration_result(_('LDAP User Object Filter needs to Have One \"%s\" Format Identifier'))\n    if config.config_ldap_user_object.count(\"(\") != config.config_ldap_user_object.count(\")\"):\n        return reboot_required, _configuration_result(_('LDAP User Object Filter Has Unmatched Parenthesis'))\n\n    if to_save.get(\"ldap_import_user_filter\") == '0':\n        config.config_ldap_member_user_object = \"\"\n    else:\n        if config.config_ldap_member_user_object.count(\"%s\") != 1:\n            return reboot_required, \\\n                   _configuration_result(_('LDAP Member User Filter needs to Have One \"%s\" Format Identifier'))\n        if config.config_ldap_member_user_object.count(\"(\") != config.config_ldap_member_user_object.count(\")\"):\n            return reboot_required, _configuration_result(_('LDAP Member User Filter Has Unmatched Parenthesis'))\n\n    if config.config_ldap_cacert_path or config.config_ldap_cert_path or config.config_ldap_key_path:\n        if not (os.path.isfile(config.config_ldap_cacert_path) and\n                os.path.isfile(config.config_ldap_cert_path) and\n                os.path.isfile(config.config_ldap_key_path)):\n            return reboot_required, \\\n                   _configuration_result(_('LDAP CACertificate, Certificate or Key Location is not Valid, '\n                                           'Please Enter Correct Path'))\n    return reboot_required, None\n\n\n@admi.route(\"/ajax/simulatedbchange\", methods=['POST'])\n@login_required\n@admin_required\ndef simulatedbchange():\n    db_change, db_valid = _db_simulate_change()\n    return Response(json.dumps({\"change\": db_change, \"valid\": db_valid}), mimetype='application/json')\n\n\ndef _db_simulate_change():\n    param = request.form.to_dict()\n    to_save = dict()\n    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',\n                                           '',\n                                           param['config_calibre_dir'],\n                                           flags=re.IGNORECASE).strip()\n    db_valid, db_change = calibre_db.check_valid_db(to_save[\"config_calibre_dir\"],\n                                                    ub.app_DB_path,\n                                                    config.config_calibre_uuid)\n    db_change = bool(db_change and config.config_calibre_dir)\n    return db_change, db_valid\n\n\ndef _db_configuration_update_helper():\n    db_change = False\n    to_save = request.form.to_dict()\n    gdrive_error = None\n\n    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',\n                                           '',\n                                           to_save['config_calibre_dir'],\n                                           flags=re.IGNORECASE)\n    db_valid = False\n    try:\n        db_change, db_valid = _db_simulate_change()\n\n        # gdrive_error drive setup\n        gdrive_error = _configuration_gdrive_helper(to_save)\n    except (OperationalError, InvalidRequestError) as e:\n        ub.session.rollback()\n        log.error_or_exception(\"Settings Database error: {}\".format(e))\n        _db_configuration_result(_(u\"Database error: %(error)s.\", error=e.orig), gdrive_error)\n    try:\n        metadata_db = os.path.join(to_save['config_calibre_dir'], \"metadata.db\")\n        if config.config_use_google_drive and is_gdrive_ready() and not os.path.exists(metadata_db):\n            gdriveutils.downloadFile(None, \"metadata.db\", metadata_db)\n            db_change = True\n    except Exception as ex:\n        return _db_configuration_result('{}'.format(ex), gdrive_error)\n\n    if db_change or not db_valid or not config.db_configured \\\n            or config.config_calibre_dir != to_save[\"config_calibre_dir\"]:\n        if not calibre_db.setup_db(to_save['config_calibre_dir'], ub.app_DB_path):\n            return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'),\n                                            gdrive_error)\n        config.store_calibre_uuid(calibre_db, db.LibraryId)\n        # if db changed -> delete shelfs, delete download books, delete read books, kobo sync...\n        if db_change:\n            log.info(\"Calibre Database changed, delete all Calibre-Web info related to old Database\")\n            ub.session.query(ub.Downloads).delete()\n            ub.session.query(ub.ArchivedBook).delete()\n            ub.session.query(ub.ReadBook).delete()\n            ub.session.query(ub.BookShelf).delete()\n            ub.session.query(ub.Bookmark).delete()\n            ub.session.query(ub.KoboReadingState).delete()\n            ub.session.query(ub.KoboStatistics).delete()\n            ub.session.query(ub.KoboSyncedBooks).delete()\n            ub.session_commit()\n        _config_string(to_save, \"config_calibre_dir\")\n        calibre_db.update_config(config)\n        if not os.access(os.path.join(config.config_calibre_dir, \"metadata.db\"), os.W_OK):\n            flash(_(u\"DB is not Writeable\"), category=\"warning\")\n    config.save()\n    return _db_configuration_result(None, gdrive_error)\n\n\ndef _configuration_update_helper():\n    reboot_required = False\n    to_save = request.form.to_dict()\n    try:\n        reboot_required |= _config_int(to_save, \"config_port\")\n        reboot_required |= _config_string(to_save, \"config_trustedhosts\")\n        reboot_required |= _config_string(to_save, \"config_keyfile\")\n        if config.config_keyfile and not os.path.isfile(config.config_keyfile):\n            return _configuration_result(_('Keyfile Location is not Valid, Please Enter Correct Path'))\n\n        reboot_required |= _config_string(to_save, \"config_certfile\")\n        if config.config_certfile and not os.path.isfile(config.config_certfile):\n            return _configuration_result(_('Certfile Location is not Valid, Please Enter Correct Path'))\n\n        _config_checkbox_int(to_save, \"config_uploading\")\n        _config_checkbox_int(to_save, \"config_unicode_filename\")\n        # Reboot on config_anonbrowse with enabled ldap, as decoraters are changed in this case\n        reboot_required |= (_config_checkbox_int(to_save, \"config_anonbrowse\")\n                            and config.config_login_type == constants.LOGIN_LDAP)\n        _config_checkbox_int(to_save, \"config_public_reg\")\n        _config_checkbox_int(to_save, \"config_register_email\")\n        reboot_required |= _config_checkbox_int(to_save, \"config_kobo_sync\")\n        _config_int(to_save, \"config_external_port\")\n        _config_checkbox_int(to_save, \"config_kobo_proxy\")\n\n        if \"config_upload_formats\" in to_save:\n            to_save[\"config_upload_formats\"] = ','.join(\n                helper.uniq([x.lstrip().rstrip().lower() for x in to_save[\"config_upload_formats\"].split(',')]))\n            _config_string(to_save, \"config_upload_formats\")\n            constants.EXTENSIONS_UPLOAD = config.config_upload_formats.split(',')\n\n        _config_string(to_save, \"config_calibre\")\n        _config_string(to_save, \"config_converterpath\")\n        _config_string(to_save, \"config_kepubifypath\")\n\n        reboot_required |= _config_int(to_save, \"config_login_type\")\n\n        # LDAP configurator\n        if config.config_login_type == constants.LOGIN_LDAP:\n            reboot, message = _configuration_ldap_helper(to_save)\n            if message:\n                return message\n            reboot_required |= reboot\n\n        # Remote login configuration\n        _config_checkbox(to_save, \"config_remote_login\")\n        if not config.config_remote_login:\n            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.token_type == 0).delete()\n\n        # Goodreads configuration\n        _config_checkbox(to_save, \"config_use_goodreads\")\n        _config_string(to_save, \"config_goodreads_api_key\")\n        _config_string(to_save, \"config_goodreads_api_secret\")\n        if services.goodreads_support:\n            services.goodreads_support.connect(config.config_goodreads_api_key,\n                                               config.config_goodreads_api_secret,\n                                               config.config_use_goodreads)\n\n        _config_int(to_save, \"config_updatechannel\")\n\n        # Reverse proxy login configuration\n        _config_checkbox(to_save, \"config_allow_reverse_proxy_header_login\")\n        _config_string(to_save, \"config_reverse_proxy_login_header_name\")\n\n        # OAuth configuration\n        if config.config_login_type == constants.LOGIN_OAUTH:\n            reboot_required |= _configuration_oauth_helper(to_save)\n\n        reboot, message = _configuration_logfile_helper(to_save)\n        if message:\n            return message\n        reboot_required |= reboot\n        # Rarfile Content configuration\n        _config_string(to_save, \"config_rarfile_location\")\n        if \"config_rarfile_location\" in to_save:\n            unrar_status = helper.check_unrar(config.config_rarfile_location)\n            if unrar_status:\n                return _configuration_result(unrar_status)\n    except (OperationalError, InvalidRequestError) as e:\n        ub.session.rollback()\n        log.error_or_exception(\"Settings Database error: {}\".format(e))\n        _configuration_result(_(u\"Database error: %(error)s.\", error=e.orig))\n\n    config.save()\n    if reboot_required:\n        web_server.stop(True)\n\n    return _configuration_result(None, reboot_required)\n\n\ndef _configuration_result(error_flash=None, reboot=False):\n    resp = {}\n    if error_flash:\n        log.error(error_flash)\n        config.load()\n        resp['result'] = [{'type': \"danger\", 'message': error_flash}]\n    else:\n        resp['result'] = [{'type': \"success\", 'message': _(u\"Calibre-Web configuration updated\")}]\n    resp['reboot'] = reboot\n    resp['config_upload'] = config.config_upload_formats\n    return Response(json.dumps(resp), mimetype='application/json')\n\n\ndef _db_configuration_result(error_flash=None, gdrive_error=None):\n    gdrive_authenticate = not is_gdrive_ready()\n    gdrivefolders = []\n    if not gdrive_error and config.config_use_google_drive:\n        gdrive_error = gdriveutils.get_error_text()\n    if gdrive_error and gdrive_support:\n        log.error(gdrive_error)\n        gdrive_error = _(gdrive_error)\n        flash(gdrive_error, category=\"error\")\n    else:\n        if not gdrive_authenticate and gdrive_support:\n            gdrivefolders = gdriveutils.listRootFolders()\n    if error_flash:\n        log.error(error_flash)\n        config.load()\n        flash(error_flash, category=\"error\")\n    elif request.method == \"POST\" and not gdrive_error:\n        flash(_(\"Database Settings updated\"), category=\"success\")\n\n    return render_title_template(\"config_db.html\",\n                                 config=config,\n                                 show_authenticate_google_drive=gdrive_authenticate,\n                                 gdriveError=gdrive_error,\n                                 gdrivefolders=gdrivefolders,\n                                 feature_support=feature_support,\n                                 title=_(u\"Database Configuration\"), page=\"dbconfig\")\n\n\ndef _handle_new_user(to_save, content, languages, translations, kobo_support):\n    content.default_language = to_save[\"default_language\"]\n    content.locale = to_save.get(\"locale\", content.locale)\n\n    content.sidebar_view = sum(int(key[5:]) for key in to_save if key.startswith('show_'))\n    if \"show_detail_random\" in to_save:\n        content.sidebar_view |= constants.DETAIL_RANDOM\n\n    content.role = constants.selected_roles(to_save)\n    content.password = generate_password_hash(to_save[\"password\"])\n    try:\n        if not to_save[\"name\"] or not to_save[\"email\"] or not to_save[\"password\"]:\n            log.info(\"Missing entries on new user\")\n            raise Exception(_(u\"Please fill out all fields!\"))\n        content.email = check_email(to_save[\"email\"])\n        # Query User name, if not existing, change\n        content.name = check_username(to_save[\"name\"])\n        if to_save.get(\"kindle_mail\"):\n            content.kindle_mail = valid_email(to_save[\"kindle_mail\"])\n        if config.config_public_reg and not check_valid_domain(content.email):\n            log.info(\"E-mail: {} for new user is not from valid domain\".format(content.email))\n            raise Exception(_(u\"E-mail is not from valid domain\"))\n    except Exception as ex:\n        flash(str(ex), category=\"error\")\n        return render_title_template(\"user_edit.html\", new_user=1, content=content,\n                                     config=config,\n                                     translations=translations,\n                                     languages=languages, title=_(u\"Add new user\"), page=\"newuser\",\n                                     kobo_support=kobo_support, registered_oauth=oauth_check)\n    try:\n        content.allowed_tags = config.config_allowed_tags\n        content.denied_tags = config.config_denied_tags\n        content.allowed_column_value = config.config_allowed_column_value\n        content.denied_column_value = config.config_denied_column_value\n        # No default value for kobo sync shelf setting\n        content.kobo_only_shelves_sync = to_save.get(\"kobo_only_shelves_sync\", 0) == \"on\"\n        ub.session.add(content)\n        ub.session.commit()\n        flash(_(u\"User '%(user)s' created\", user=content.name), category=\"success\")\n        log.debug(\"User {} created\".format(content.name))\n        return redirect(url_for('admin.admin'))\n    except IntegrityError:\n        ub.session.rollback()\n        log.error(\"Found an existing account for {} or {}\".format(content.name, content.email))\n        flash(_(\"Found an existing account for this e-mail address or name.\"), category=\"error\")\n    except OperationalError as e:\n        ub.session.rollback()\n        log.error_or_exception(\"Settings Database error: {}\".format(e))\n        flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")\n\n\ndef _delete_user(content):\n    if ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,\n                                        ub.User.id != content.id).count():\n        if content.name != \"Guest\":\n            # Delete all books in shelfs belonging to user, all shelfs of user, downloadstat of user, read status\n            # and user itself\n            ub.session.query(ub.ReadBook).filter(content.id == ub.ReadBook.user_id).delete()\n            ub.session.query(ub.Downloads).filter(content.id == ub.Downloads.user_id).delete()\n            for us in ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id):\n                ub.session.query(ub.BookShelf).filter(us.id == ub.BookShelf.shelf).delete()\n            ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id).delete()\n            ub.session.query(ub.Bookmark).filter(content.id == ub.Bookmark.user_id).delete()\n            ub.session.query(ub.User).filter(ub.User.id == content.id).delete()\n            ub.session.query(ub.ArchivedBook).filter(ub.ArchivedBook.user_id == content.id).delete()\n            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == content.id).delete()\n            ub.session.query(ub.User_Sessions).filter(ub.User_Sessions.user_id == content.id).delete()\n            ub.session.query(ub.KoboSyncedBooks).filter(ub.KoboSyncedBooks.user_id == content.id).delete()\n            # delete KoboReadingState and all it's children\n            kobo_entries = ub.session.query(ub.KoboReadingState).filter(ub.KoboReadingState.user_id == content.id).all()\n            for kobo_entry in kobo_entries:\n                ub.session.delete(kobo_entry)\n            ub.session_commit()\n            log.info(\"User {} deleted\".format(content.name))\n            return _(\"User '%(nick)s' deleted\", nick=content.name)\n        else:\n            log.warning(_(\"Can't delete Guest User\"))\n            raise Exception(_(\"Can't delete Guest User\"))\n    else:\n        log.warning(\"No admin user remaining, can't delete user\")\n        raise Exception(_(\"No admin user remaining, can't delete user\"))\n\n\ndef _handle_edit_user(to_save, content, languages, translations, kobo_support):\n    if to_save.get(\"delete\"):\n        try:\n            flash(_delete_user(content), category=\"success\")\n        except Exception as ex:\n            log.error(ex)\n            flash(str(ex), category=\"error\")\n        return redirect(url_for('admin.admin'))\n    else:\n        if not ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,\n                                                ub.User.id != content.id).count() and 'admin_role' not in to_save:\n            log.warning(\"No admin user remaining, can't remove admin role from {}\".format(content.name))\n            flash(_(\"No admin user remaining, can't remove admin role\"), category=\"error\")\n            return redirect(url_for('admin.admin'))\n        if to_save.get(\"password\"):\n            content.password = generate_password_hash(to_save[\"password\"])\n        anonymous = content.is_anonymous\n        content.role = constants.selected_roles(to_save)\n        if anonymous:\n            content.role |= constants.ROLE_ANONYMOUS\n        else:\n            content.role &= ~constants.ROLE_ANONYMOUS\n\n        val = [int(k[5:]) for k in to_save if k.startswith('show_')]\n        sidebar = get_sidebar_config()\n        for element in sidebar:\n            value = element['visibility']\n            if value in val and not content.check_visibility(value):\n                content.sidebar_view |= value\n            elif value not in val and content.check_visibility(value):\n                content.sidebar_view &= ~value\n\n        if to_save.get(\"Show_detail_random\"):\n            content.sidebar_view |= constants.DETAIL_RANDOM\n        else:\n            content.sidebar_view &= ~constants.DETAIL_RANDOM\n\n        old_state = content.kobo_only_shelves_sync\n        content.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0\n        # 1 -> 0: nothing has to be done\n        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs\n        # which don't have to be synced have to be removed (added to Shelf archive)\n        if old_state == 0 and content.kobo_only_shelves_sync == 1:\n            kobo_sync_status.update_on_sync_shelfs(content.id)\n        if to_save.get(\"default_language\"):\n            content.default_language = to_save[\"default_language\"]\n        if to_save.get(\"locale\"):\n            content.locale = to_save[\"locale\"]\n        try:\n            if to_save.get(\"email\", content.email) != content.email:\n                content.email = check_email(to_save[\"email\"])\n            # Query User name, if not existing, change\n            if to_save.get(\"name\", content.name) != content.name:\n                if to_save.get(\"name\") == \"Guest\":\n                    raise Exception(_(\"Guest Name can't be changed\"))\n                content.name = check_username(to_save[\"name\"])\n            if to_save.get(\"kindle_mail\") != content.kindle_mail:\n                content.kindle_mail = valid_email(to_save[\"kindle_mail\"]) if to_save[\"kindle_mail\"] else \"\"\n        except Exception as ex:\n            log.error(ex)\n            flash(str(ex), category=\"error\")\n            return render_title_template(\"user_edit.html\",\n                                         translations=translations,\n                                         languages=languages,\n                                         mail_configured=config.get_mail_server_configured(),\n                                         kobo_support=kobo_support,\n                                         new_user=0,\n                                         content=content,\n                                         config=config,\n                                         registered_oauth=oauth_check,\n                                         title=_(u\"Edit User %(nick)s\", nick=content.name),\n                                         page=\"edituser\")\n    try:\n        ub.session_commit()\n        flash(_(u\"User '%(nick)s' updated\", nick=content.name), category=\"success\")\n    except IntegrityError as ex:\n        ub.session.rollback()\n        log.error(\"An unknown error occurred while changing user: {}\".format(str(ex)))\n        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n    except OperationalError as e:\n        ub.session.rollback()\n        log.error_or_exception(\"Settings Database error: {}\".format(e))\n        flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")\n    return \"\"\n\n\n@admi.route(\"/admin/user/new\", methods=[\"GET\", \"POST\"])\n@login_required\n@admin_required\ndef new_user():\n    content = ub.User()\n    languages = calibre_db.speaking_language()\n    translations = [Locale('en')] + babel.list_translations()\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        _handle_new_user(to_save, content, languages, translations, kobo_support)\n    else:\n        content.role = config.config_default_role\n        content.sidebar_view = config.config_default_show\n        content.locale = config.config_default_locale\n        content.default_language = config.config_default_language\n    return render_title_template(\"user_edit.html\", new_user=1, content=content,\n                                 config=config, translations=translations,\n                                 languages=languages, title=_(u\"Add new user\"), page=\"newuser\",\n                                 kobo_support=kobo_support, registered_oauth=oauth_check)\n\n\n@admi.route(\"/admin/mailsettings\")\n@login_required\n@admin_required\ndef edit_mailsettings():\n    content = config.get_mail_settings()\n    return render_title_template(\"email_edit.html\", content=content, title=_(u\"Edit E-mail Server Settings\"),\n                                 page=\"mailset\", feature_support=feature_support)\n\n\n@admi.route(\"/admin/mailsettings\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef update_mailsettings():\n    to_save = request.form.to_dict()\n    _config_int(to_save, \"mail_server_type\")\n    if to_save.get(\"invalidate\"):\n        config.mail_gmail_token = {}\n        try:\n            flag_modified(config, \"mail_gmail_token\")\n        except AttributeError:\n            pass\n    elif to_save.get(\"gmail\"):\n        try:\n            config.mail_gmail_token = services.gmail.setup_gmail(config.mail_gmail_token)\n            flash(_(u\"Gmail Account Verification Successful\"), category=\"success\")\n        except Exception as ex:\n            flash(str(ex), category=\"error\")\n            log.error(ex)\n            return edit_mailsettings()\n\n    else:\n        _config_string(to_save, \"mail_server\")\n        _config_int(to_save, \"mail_port\")\n        _config_int(to_save, \"mail_use_ssl\")\n        _config_string(to_save, \"mail_login\")\n        _config_string(to_save, \"mail_password\")\n        _config_string(to_save, \"mail_from\")\n        _config_int(to_save, \"mail_size\", lambda y: int(y)*1024*1024)\n    try:\n        config.save()\n    except (OperationalError, InvalidRequestError) as e:\n        ub.session.rollback()\n        log.error_or_exception(\"Settings Database error: {}\".format(e))\n        flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")\n        return edit_mailsettings()\n\n    if to_save.get(\"test\"):\n        if current_user.email:\n            result = send_test_mail(current_user.email, current_user.name)\n            if result is None:\n                flash(_(u\"Test e-mail queued for sending to %(email)s, please check Tasks for result\",\n                        email=current_user.email), category=\"info\")\n            else:\n                flash(_(u\"There was an error sending the Test e-mail: %(res)s\", res=result), category=\"error\")\n        else:\n            flash(_(u\"Please configure your e-mail address first...\"), category=\"error\")\n    else:\n        flash(_(u\"E-mail server settings updated\"), category=\"success\")\n\n    return edit_mailsettings()\n\n\n@admi.route(\"/admin/user/<int:user_id>\", methods=[\"GET\", \"POST\"])\n@login_required\n@admin_required\ndef edit_user(user_id):\n    content = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()  # type: ub.User\n    if not content or (not config.config_anonbrowse and content.name == \"Guest\"):\n        flash(_(u\"User not found\"), category=\"error\")\n        return redirect(url_for('admin.admin'))\n    languages = calibre_db.speaking_language(return_all_languages=True)\n    translations = babel.list_translations() + [Locale('en')]\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        resp = _handle_edit_user(to_save, content, languages, translations, kobo_support)\n        if resp:\n            return resp\n    return render_title_template(\"user_edit.html\",\n                                 translations=translations,\n                                 languages=languages,\n                                 new_user=0,\n                                 content=content,\n                                 config=config,\n                                 registered_oauth=oauth_check,\n                                 mail_configured=config.get_mail_server_configured(),\n                                 kobo_support=kobo_support,\n                                 title=_(u\"Edit User %(nick)s\", nick=content.name),\n                                 page=\"edituser\")\n\n\n@admi.route(\"/admin/resetpassword/<int:user_id>\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef reset_user_password(user_id):\n    if current_user is not None and current_user.is_authenticated:\n        ret, message = reset_password(user_id)\n        if ret == 1:\n            log.debug(u\"Password for user %s reset\", message)\n            flash(_(u\"Password for user %(user)s reset\", user=message), category=\"success\")\n        elif ret == 0:\n            log.error(u\"An unknown error occurred. Please try again later.\")\n            flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n        else:\n            log.error(u\"Please configure the SMTP mail settings first...\")\n            flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")\n    return redirect(url_for('admin.admin'))\n\n\n@admi.route(\"/admin/logfile\")\n@login_required\n@admin_required\ndef view_logfile():\n    logfiles = {0: logger.get_logfile(config.config_logfile),\n                1: logger.get_accesslogfile(config.config_access_logfile)}\n    return render_title_template(\"logviewer.html\",\n                                 title=_(u\"Logfile viewer\"),\n                                 accesslog_enable=config.config_access_log,\n                                 log_enable=bool(config.config_logfile != logger.LOG_TO_STDOUT),\n                                 logfiles=logfiles,\n                                 page=\"logfile\")\n\n\n@admi.route(\"/ajax/log/<int:logtype>\")\n@login_required\n@admin_required\ndef send_logfile(logtype):\n    if logtype == 1:\n        logfile = logger.get_accesslogfile(config.config_access_logfile)\n        return send_from_directory(os.path.dirname(logfile),\n                                   os.path.basename(logfile))\n    if logtype == 0:\n        logfile = logger.get_logfile(config.config_logfile)\n        return send_from_directory(os.path.dirname(logfile),\n                                   os.path.basename(logfile))\n    else:\n        return \"\"\n\n\n@admi.route(\"/admin/logdownload/<int:logtype>\")\n@login_required\n@admin_required\ndef download_log(logtype):\n    if logtype == 0:\n        file_name = logger.get_logfile(config.config_logfile)\n    elif logtype == 1:\n        file_name = logger.get_accesslogfile(config.config_access_logfile)\n    else:\n        abort(404)\n    if logger.is_valid_logfile(file_name):\n        return debug_info.assemble_logfiles(file_name)\n    abort(404)\n\n\n@admi.route(\"/admin/debug\")\n@login_required\n@admin_required\ndef download_debug():\n    return debug_info.send_debug()\n\n\n@admi.route(\"/get_update_status\", methods=['GET'])\n@login_required\n@admin_required\ndef get_update_status():\n    if feature_support['updater']:\n        log.info(u\"Update status requested\")\n        return updater_thread.get_available_updates(request.method, locale=get_locale())\n    else:\n        return ''\n\n\n@admi.route(\"/get_updater_status\", methods=['GET', 'POST'])\n@login_required\n@admin_required\ndef get_updater_status():\n    status = {}\n    if feature_support['updater']:\n        if request.method == \"POST\":\n            commit = request.form.to_dict()\n            if \"start\" in commit and commit['start'] == 'True':\n                txt = {\n                    \"1\": _(u'Requesting update package'),\n                    \"2\": _(u'Downloading update package'),\n                    \"3\": _(u'Unzipping update package'),\n                    \"4\": _(u'Replacing files'),\n                    \"5\": _(u'Database connections are closed'),\n                    \"6\": _(u'Stopping server'),\n                    \"7\": _(u'Update finished, please press okay and reload page'),\n                    \"8\": _(u'Update failed:') + u' ' + _(u'HTTP Error'),\n                    \"9\": _(u'Update failed:') + u' ' + _(u'Connection error'),\n                    \"10\": _(u'Update failed:') + u' ' + _(u'Timeout while establishing connection'),\n                    \"11\": _(u'Update failed:') + u' ' + _(u'General error'),\n                    \"12\": _(u'Update failed:') + u' ' + _(u'Update file could not be saved in temp dir'),\n                    \"13\": _(u'Update failed:') + u' ' + _(u'Files could not be replaced during update')\n                }\n                status['text'] = txt\n                updater_thread.status = 0\n                updater_thread.resume()\n                status['status'] = updater_thread.get_update_status()\n        elif request.method == \"GET\":\n            try:\n                status['status'] = updater_thread.get_update_status()\n                if status['status'] == -1:\n                    status['status'] = 7\n            except Exception:\n                status['status'] = 11\n        return json.dumps(status)\n    return ''\n\n\ndef ldap_import_create_user(user, user_data):\n    user_login_field = extract_dynamic_field_from_filter(user, config.config_ldap_user_object)\n\n    try:\n        username = user_data[user_login_field][0].decode('utf-8')\n    except KeyError as ex:\n        log.error(\"Failed to extract LDAP user: %s - %s\", user, ex)\n        message = _(u'Failed to extract at least One LDAP User')\n        return 0, message\n\n    # check for duplicate username\n    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first():\n        # if ub.session.query(ub.User).filter(ub.User.name == username).first():\n        log.warning(\"LDAP User  %s Already in Database\", user_data)\n        return 0, None\n\n    kindlemail = ''\n    if 'mail' in user_data:\n        useremail = user_data['mail'][0].decode('utf-8')\n        if len(user_data['mail']) > 1:\n            kindlemail = user_data['mail'][1].decode('utf-8')\n\n    else:\n        log.debug('No Mail Field Found in LDAP Response')\n        useremail = username + '@email.com'\n\n    try:\n        # check for duplicate email\n        useremail = check_email(useremail)\n    except Exception as ex:\n        log.warning(\"LDAP Email Error: {}, {}\".format(user_data, ex))\n        return 0, None\n    content = ub.User()\n    content.name = username\n    content.password = ''  # dummy password which will be replaced by ldap one\n    content.email = useremail\n    content.kindle_mail = kindlemail\n    content.default_language = config.config_default_language\n    content.locale = config.config_default_locale\n    content.role = config.config_default_role\n    content.sidebar_view = config.config_default_show\n    content.allowed_tags = config.config_allowed_tags\n    content.denied_tags = config.config_denied_tags\n    content.allowed_column_value = config.config_allowed_column_value\n    content.denied_column_value = config.config_denied_column_value\n    ub.session.add(content)\n    try:\n        ub.session.commit()\n        return 1, None    # increase no of users\n    except Exception as ex:\n        log.warning(\"Failed to create LDAP user: %s - %s\", user, ex)\n        ub.session.rollback()\n        message = _(u'Failed to Create at Least One LDAP User')\n        return 0, message\n\n\n@admi.route('/import_ldap_users', methods=[\"POST\"])\n@login_required\n@admin_required\ndef import_ldap_users():\n    showtext = {}\n    try:\n        new_users = services.ldap.get_group_members(config.config_ldap_group_name)\n    except (services.ldap.LDAPException, TypeError, AttributeError, KeyError) as e:\n        log.error_or_exception(e)\n        showtext['text'] = _(u'Error: %(ldaperror)s', ldaperror=e)\n        return json.dumps(showtext)\n    if not new_users:\n        log.debug('LDAP empty response')\n        showtext['text'] = _(u'Error: No user returned in response of LDAP server')\n        return json.dumps(showtext)\n\n    imported = 0\n    for username in new_users:\n        user = username.decode('utf-8')\n        if '=' in user:\n            # if member object field is empty take user object as filter\n            if config.config_ldap_member_user_object:\n                query_filter = config.config_ldap_member_user_object\n            else:\n                query_filter = config.config_ldap_user_object\n            try:\n                user_identifier = extract_user_identifier(user, query_filter)\n            except Exception as ex:\n                log.warning(ex)\n                continue\n        else:\n            user_identifier = user\n            query_filter = None\n        try:\n            user_data = services.ldap.get_object_details(user=user_identifier, query_filter=query_filter)\n        except AttributeError as ex:\n            log.error_or_exception(ex)\n            continue\n        if user_data:\n            user_count, message = ldap_import_create_user(user, user_data)\n            if message:\n                showtext['text'] = message\n            else:\n                imported += user_count\n        else:\n            log.warning(\"LDAP User: %s Not Found\", user)\n            showtext['text'] = _(u'At Least One LDAP User Not Found in Database')\n    if not showtext:\n        showtext['text'] = _(u'{} User Successfully Imported'.format(imported))\n    return json.dumps(showtext)\n\n\ndef extract_user_data_from_field(user, field):\n    match = re.search(field + r\"=([\\.\\d\\s\\w-]+)\", user, re.IGNORECASE | re.UNICODE)\n    if match:\n        return match.group(1)\n    else:\n        raise Exception(\"Could Not Parse LDAP User: {}\".format(user))\n\n\ndef extract_dynamic_field_from_filter(user, filtr):\n    match = re.search(\"([a-zA-Z0-9-]+)=%s\", filtr, re.IGNORECASE | re.UNICODE)\n    if match:\n        return match.group(1)\n    else:\n        raise Exception(\"Could Not Parse LDAP Userfield: {}\", user)\n\n\ndef extract_user_identifier(user, filtr):\n    dynamic_field = extract_dynamic_field_from_filter(user, filtr)\n    return extract_user_data_from_field(user, dynamic_field)\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2012-2019 mutschler, cervinko, ok11, jkrehm, nanu-c, Wineliva,\n#                            pjeby, elelay, idalin, Ozzieisaacs\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport re\nimport ast\nimport json\nfrom datetime import datetime\nfrom urllib.parse import quote\nimport unidecode\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import Table, Column, ForeignKey, CheckConstraint\nfrom sqlalchemy import String, Integer, Boolean, TIMESTAMP, Float\nfrom sqlalchemy.orm import relationship, sessionmaker, scoped_session\nfrom sqlalchemy.orm.collections import InstrumentedList\nfrom sqlalchemy.ext.declarative import DeclarativeMeta\nfrom sqlalchemy.exc import OperationalError\ntry:\n    # Compatibility with sqlalchemy 2.0\n    from sqlalchemy.orm import declarative_base\nexcept ImportError:\n    from sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.pool import StaticPool\nfrom sqlalchemy.sql.expression import and_, true, false, text, func, or_\nfrom sqlalchemy.ext.associationproxy import association_proxy\nfrom flask_login import current_user\nfrom flask_babel import gettext as _\nfrom flask import flash\n\nfrom . import logger, ub, isoLanguages\nfrom .pagination import Pagination\n\nfrom weakref import WeakSet\n\n\nlog = logger.create()\n\ncc_exceptions = ['composite', 'series']\ncc_classes = {}\n\nBase = declarative_base()\n\nbooks_authors_link = Table('books_authors_link', Base.metadata,\n                           Column('book', Integer, ForeignKey('books.id'), primary_key=True),\n                           Column('author', Integer, ForeignKey('authors.id'), primary_key=True)\n                           )\n\nbooks_tags_link = Table('books_tags_link', Base.metadata,\n                        Column('book', Integer, ForeignKey('books.id'), primary_key=True),\n                        Column('tag', Integer, ForeignKey('tags.id'), primary_key=True)\n                        )\n\nbooks_series_link = Table('books_series_link', Base.metadata,\n                          Column('book', Integer, ForeignKey('books.id'), primary_key=True),\n                          Column('series', Integer, ForeignKey('series.id'), primary_key=True)\n                          )\n\nbooks_ratings_link = Table('books_ratings_link', Base.metadata,\n                           Column('book', Integer, ForeignKey('books.id'), primary_key=True),\n                           Column('rating', Integer, ForeignKey('ratings.id'), primary_key=True)\n                           )\n\nbooks_languages_link = Table('books_languages_link', Base.metadata,\n                             Column('book', Integer, ForeignKey('books.id'), primary_key=True),\n                             Column('lang_code', Integer, ForeignKey('languages.id'), primary_key=True)\n                             )\n\nbooks_publishers_link = Table('books_publishers_link', Base.metadata,\n                              Column('book', Integer, ForeignKey('books.id'), primary_key=True),\n                              Column('publisher', Integer, ForeignKey('publishers.id'), primary_key=True)\n                              )\n\n\nclass LibraryId(Base):\n    __tablename__ = 'library_id'\n    id = Column(Integer, primary_key=True)\n    uuid = Column(String, nullable=False)\n\n\nclass Identifiers(Base):\n    __tablename__ = 'identifiers'\n\n    id = Column(Integer, primary_key=True)\n    type = Column(String(collation='NOCASE'), nullable=False, default=\"isbn\")\n    val = Column(String(collation='NOCASE'), nullable=False)\n    book = Column(Integer, ForeignKey('books.id'), nullable=False)\n\n    def __init__(self, val, id_type, book):\n        self.val = val\n        self.type = id_type\n        self.book = book\n\n    def format_type(self):\n        format_type = self.type.lower()\n        if format_type == 'amazon':\n            return u\"Amazon\"\n        elif format_type.startswith(\"amazon_\"):\n            return u\"Amazon.{0}\".format(format_type[7:])\n        elif format_type == \"isbn\":\n            return u\"ISBN\"\n        elif format_type == \"doi\":\n            return u\"DOI\"\n        elif format_type == \"douban\":\n            return u\"Douban\"\n        elif format_type == \"goodreads\":\n            return u\"Goodreads\"\n        elif format_type == \"babelio\":\n            return u\"Babelio\"\n        elif format_type == \"google\":\n            return u\"Google Books\"\n        elif format_type == \"kobo\":\n            return u\"Kobo\"\n        elif format_type == \"litres\":\n            return u\"\u041b\u0438\u0442\u0420\u0435\u0441\"\n        elif format_type == \"issn\":\n            return u\"ISSN\"\n        elif format_type == \"isfdb\":\n            return u\"ISFDB\"\n        if format_type == \"lubimyczytac\":\n            return u\"Lubimyczytac\"\n        else:\n            return self.type\n\n    def __repr__(self):\n        format_type = self.type.lower()\n        if format_type == \"amazon\" or format_type == \"asin\":\n            return u\"https://amazon.com/dp/{0}\".format(self.val)\n        elif format_type.startswith('amazon_'):\n            return u\"https://amazon.{0}/dp/{1}\".format(format_type[7:], self.val)\n        elif format_type == \"isbn\":\n            return u\"https://www.worldcat.org/isbn/{0}\".format(self.val)\n        elif format_type == \"doi\":\n            return u\"https://dx.doi.org/{0}\".format(self.val)\n        elif format_type == \"goodreads\":\n            return u\"https://www.goodreads.com/book/show/{0}\".format(self.val)\n        elif format_type == \"babelio\":\n            return u\"https://www.babelio.com/livres/titre/{0}\".format(self.val)\n        elif format_type == \"douban\":\n            return u\"https://book.douban.com/subject/{0}\".format(self.val)\n        elif format_type == \"google\":\n            return u\"https://books.google.com/books?id={0}\".format(self.val)\n        elif format_type == \"kobo\":\n            return u\"https://www.kobo.com/ebook/{0}\".format(self.val)\n        elif format_type == \"lubimyczytac\":\n            return u\"https://lubimyczytac.pl/ksiazka/{0}/ksiazka\".format(self.val)\n        elif format_type == \"litres\":\n            return u\"https://www.litres.ru/{0}\".format(self.val)\n        elif format_type == \"issn\":\n            return u\"https://portal.issn.org/resource/ISSN/{0}\".format(self.val)\n        elif format_type == \"isfdb\":\n            return u\"http://www.isfdb.org/cgi-bin/pl.cgi?{0}\".format(self.val)\n        elif self.val.lower().startswith(\"javascript:\"):\n            return quote(self.val)\n        else:\n            return u\"{0}\".format(self.val)\n\n\nclass Comments(Base):\n    __tablename__ = 'comments'\n\n    id = Column(Integer, primary_key=True)\n    book = Column(Integer, ForeignKey('books.id'), nullable=False, unique=True)\n    text = Column(String(collation='NOCASE'), nullable=False)\n\n    def __init__(self, comment, book):\n        self.text = comment\n        self.book = book\n\n    def get(self):\n        return self.text\n\n    def __repr__(self):\n        return u\"<Comments({0})>\".format(self.text)\n\n\nclass Tags(Base):\n    __tablename__ = 'tags'\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    name = Column(String(collation='NOCASE'), unique=True, nullable=False)\n\n    def __init__(self, name):\n        self.name = name\n\n    def get(self):\n        return self.name\n\n    def __repr__(self):\n        return u\"<Tags('{0})>\".format(self.name)\n\n\nclass Authors(Base):\n    __tablename__ = 'authors'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(collation='NOCASE'), unique=True, nullable=False)\n    sort = Column(String(collation='NOCASE'))\n    link = Column(String, nullable=False, default=\"\")\n\n    def __init__(self, name, sort, link):\n        self.name = name\n        self.sort = sort\n        self.link = link\n\n    def get(self):\n        return self.name\n\n    def __repr__(self):\n        return u\"<Authors('{0},{1}{2}')>\".format(self.name, self.sort, self.link)\n\n\nclass Series(Base):\n    __tablename__ = 'series'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(collation='NOCASE'), unique=True, nullable=False)\n    sort = Column(String(collation='NOCASE'))\n\n    def __init__(self, name, sort):\n        self.name = name\n        self.sort = sort\n\n    def get(self):\n        return self.name\n\n    def __repr__(self):\n        return u\"<Series('{0},{1}')>\".format(self.name, self.sort)\n\n\nclass Ratings(Base):\n    __tablename__ = 'ratings'\n\n    id = Column(Integer, primary_key=True)\n    rating = Column(Integer, CheckConstraint('rating>-1 AND rating<11'), unique=True)\n\n    def __init__(self, rating):\n        self.rating = rating\n\n    def get(self):\n        return self.rating\n\n    def __repr__(self):\n        return u\"<Ratings('{0}')>\".format(self.rating)\n\n\nclass Languages(Base):\n    __tablename__ = 'languages'\n\n    id = Column(Integer, primary_key=True)\n    lang_code = Column(String(collation='NOCASE'), nullable=False, unique=True)\n\n    def __init__(self, lang_code):\n        self.lang_code = lang_code\n\n    def get(self):\n        if self.language_name:\n            return self.language_name\n        else:\n            return self.lang_code\n\n    def __repr__(self):\n        return u\"<Languages('{0}')>\".format(self.lang_code)\n\n\nclass Publishers(Base):\n    __tablename__ = 'publishers'\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(collation='NOCASE'), nullable=False, unique=True)\n    sort = Column(String(collation='NOCASE'))\n\n    def __init__(self, name, sort):\n        self.name = name\n        self.sort = sort\n\n    def get(self):\n        return self.name\n\n    def __repr__(self):\n        return u\"<Publishers('{0},{1}')>\".format(self.name, self.sort)\n\n\nclass Data(Base):\n    __tablename__ = 'data'\n    __table_args__ = {'schema': 'calibre'}\n\n    id = Column(Integer, primary_key=True)\n    book = Column(Integer, ForeignKey('books.id'), nullable=False)\n    format = Column(String(collation='NOCASE'), nullable=False)\n    uncompressed_size = Column(Integer, nullable=False)\n    name = Column(String, nullable=False)\n\n    def __init__(self, book, book_format, uncompressed_size, name):\n        self.book = book\n        self.format = book_format\n        self.uncompressed_size = uncompressed_size\n        self.name = name\n\n    # ToDo: Check\n    def get(self):\n        return self.name\n\n    def __repr__(self):\n        return u\"<Data('{0},{1}{2}{3}')>\".format(self.book, self.format, self.uncompressed_size, self.name)\n\n\nclass Books(Base):\n    __tablename__ = 'books'\n\n    DEFAULT_PUBDATE = datetime(101, 1, 1, 0, 0, 0, 0)  # (\"0101-01-01 00:00:00+00:00\")\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    title = Column(String(collation='NOCASE'), nullable=False, default='Unknown')\n    sort = Column(String(collation='NOCASE'))\n    author_sort = Column(String(collation='NOCASE'))\n    timestamp = Column(TIMESTAMP, default=datetime.utcnow)\n    pubdate = Column(TIMESTAMP, default=DEFAULT_PUBDATE)\n    series_index = Column(String, nullable=False, default=\"1.0\")\n    last_modified = Column(TIMESTAMP, default=datetime.utcnow)\n    path = Column(String, default=\"\", nullable=False)\n    has_cover = Column(Integer, default=0)\n    uuid = Column(String)\n    isbn = Column(String(collation='NOCASE'), default=\"\")\n    flags = Column(Integer, nullable=False, default=1)\n\n    authors = relationship(Authors, secondary=books_authors_link, backref='books')\n    tags = relationship(Tags, secondary=books_tags_link, backref='books', order_by=\"Tags.name\")\n    comments = relationship(Comments, backref='books')\n    data = relationship(Data, backref='books')\n    series = relationship(Series, secondary=books_series_link, backref='books')\n    ratings = relationship(Ratings, secondary=books_ratings_link, backref='books')\n    languages = relationship(Languages, secondary=books_languages_link, backref='books')\n    publishers = relationship(Publishers, secondary=books_publishers_link, backref='books')\n    identifiers = relationship(Identifiers, backref='books')\n\n    def __init__(self, title, sort, author_sort, timestamp, pubdate, series_index, last_modified, path, has_cover,\n                 authors, tags, languages=None):\n        self.title = title\n        self.sort = sort\n        self.author_sort = author_sort\n        self.timestamp = timestamp\n        self.pubdate = pubdate\n        self.series_index = series_index\n        self.last_modified = last_modified\n        self.path = path\n        self.has_cover = (has_cover != None)\n\n    def __repr__(self):\n        return u\"<Books('{0},{1}{2}{3}{4}{5}{6}{7}{8}')>\".format(self.title, self.sort, self.author_sort,\n                                                                 self.timestamp, self.pubdate, self.series_index,\n                                                                 self.last_modified, self.path, self.has_cover)\n\n    @property\n    def atom_timestamp(self):\n        return self.timestamp.strftime('%Y-%m-%dT%H:%M:%S+00:00') or ''\n\n\nclass CustomColumns(Base):\n    __tablename__ = 'custom_columns'\n\n    id = Column(Integer, primary_key=True)\n    label = Column(String)\n    name = Column(String)\n    datatype = Column(String)\n    mark_for_delete = Column(Boolean)\n    editable = Column(Boolean)\n    display = Column(String)\n    is_multiple = Column(Boolean)\n    normalized = Column(Boolean)\n\n    def get_display_dict(self):\n        display_dict = ast.literal_eval(self.display)\n        return display_dict\n\n\nclass AlchemyEncoder(json.JSONEncoder):\n\n    def default(self, o):\n        if isinstance(o.__class__, DeclarativeMeta):\n            # an SQLAlchemy class\n            fields = {}\n            for field in [x for x in dir(o) if not x.startswith('_') and x != 'metadata' and x != \"password\"]:\n                if field == 'books':\n                    continue\n                data = o.__getattribute__(field)\n                try:\n                    if isinstance(data, str):\n                        data = data.replace(\"'\", \"\\'\")\n                    elif isinstance(data, InstrumentedList):\n                        el = list()\n                        # ele = None\n                        for ele in data:\n                            if hasattr(ele, 'value'):       # converter for custom_column values\n                                el.append(str(ele.value))\n                            elif ele.get:\n                                el.append(ele.get())\n                            else:\n                                el.append(json.dumps(ele, cls=AlchemyEncoder))\n                        if field == 'authors':\n                            data = \" & \".join(el)\n                        else:\n                            data = \",\".join(el)\n                        if data == '[]':\n                            data = \"\"\n                    else:\n                        json.dumps(data)\n                    fields[field] = data\n                except Exception:\n                    fields[field] = \"\"\n            # a json-encodable dict\n            return fields\n\n        return json.JSONEncoder.default(self, o)\n\n\nclass CalibreDB:\n    _init = False\n    engine = None\n    config = None\n    session_factory = None\n    # This is a WeakSet so that references here don't keep other CalibreDB\n    # instances alive once they reach the end of their respective scopes\n    instances = WeakSet()\n\n    def __init__(self, expire_on_commit=True):\n        \"\"\" Initialize a new CalibreDB session\n        \"\"\"\n        self.session = None\n        if self._init:\n            self.init_session(expire_on_commit)\n\n        self.instances.add(self)\n\n    def init_session(self, expire_on_commit=True):\n        self.session = self.session_factory()\n        self.session.expire_on_commit = expire_on_commit\n        self.update_title_sort(self.config)\n\n    @classmethod\n    def setup_db_cc_classes(cls, cc):\n        cc_ids = []\n        books_custom_column_links = {}\n        for row in cc:\n            if row.datatype not in cc_exceptions:\n                if row.datatype == 'series':\n                    dicttable = {'__tablename__': 'books_custom_column_' + str(row.id) + '_link',\n                                 'id': Column(Integer, primary_key=True),\n                                 'book': Column(Integer, ForeignKey('books.id'),\n                                                primary_key=True),\n                                 'map_value': Column('value', Integer,\n                                                     ForeignKey('custom_column_' +\n                                                                str(row.id) + '.id'),\n                                                     primary_key=True),\n                                 'extra': Column(Float),\n                                 'asoc': relationship('custom_column_' + str(row.id), uselist=False),\n                                 'value': association_proxy('asoc', 'value')\n                                 }\n                    books_custom_column_links[row.id] = type(str('books_custom_column_' + str(row.id) + '_link'),\n                                                             (Base,), dicttable)\n                if row.datatype in ['rating', 'text', 'enumeration']:\n                    books_custom_column_links[row.id] = Table('books_custom_column_' + str(row.id) + '_link',\n                                                              Base.metadata,\n                                                              Column('book', Integer, ForeignKey('books.id'),\n                                                                     primary_key=True),\n                                                              Column('value', Integer,\n                                                                     ForeignKey('custom_column_' +\n                                                                                str(row.id) + '.id'),\n                                                                     primary_key=True)\n                                                              )\n                cc_ids.append([row.id, row.datatype])\n\n                ccdict = {'__tablename__': 'custom_column_' + str(row.id),\n                          'id': Column(Integer, primary_key=True)}\n                if row.datatype == 'float':\n                    ccdict['value'] = Column(Float)\n                elif row.datatype == 'int':\n                    ccdict['value'] = Column(Integer)\n                elif row.datatype == 'datetime':\n                    ccdict['value'] = Column(TIMESTAMP)\n                elif row.datatype == 'bool':\n                    ccdict['value'] = Column(Boolean)\n                else:\n                    ccdict['value'] = Column(String)\n                if row.datatype in ['float', 'int', 'bool', 'datetime', 'comments']:\n                    ccdict['book'] = Column(Integer, ForeignKey('books.id'))\n                cc_classes[row.id] = type(str('custom_column_' + str(row.id)), (Base,), ccdict)\n\n        for cc_id in cc_ids:\n            if cc_id[1] in ['bool', 'int', 'float', 'datetime', 'comments']:\n                setattr(Books,\n                        'custom_column_' + str(cc_id[0]),\n                        relationship(cc_classes[cc_id[0]],\n                                     primaryjoin=(\n                                         Books.id == cc_classes[cc_id[0]].book),\n                                     backref='books'))\n            elif cc_id[1] == 'series':\n                setattr(Books,\n                        'custom_column_' + str(cc_id[0]),\n                        relationship(books_custom_column_links[cc_id[0]],\n                                     backref='books'))\n            else:\n                setattr(Books,\n                        'custom_column_' + str(cc_id[0]),\n                        relationship(cc_classes[cc_id[0]],\n                                     secondary=books_custom_column_links[cc_id[0]],\n                                     backref='books'))\n\n        return cc_classes\n\n    @classmethod\n    def check_valid_db(cls, config_calibre_dir, app_db_path, config_calibre_uuid):\n        if not config_calibre_dir:\n            return False, False\n        dbpath = os.path.join(config_calibre_dir, \"metadata.db\")\n        if not os.path.exists(dbpath):\n            return False, False\n        try:\n            check_engine = create_engine('sqlite://',\n                                         echo=False,\n                                         isolation_level=\"SERIALIZABLE\",\n                                         connect_args={'check_same_thread': False},\n                                         poolclass=StaticPool)\n            with check_engine.begin() as connection:\n                connection.execute(text(\"attach database '{}' as calibre;\".format(dbpath)))\n                connection.execute(text(\"attach database '{}' as app_settings;\".format(app_db_path)))\n                local_session = scoped_session(sessionmaker())\n                local_session.configure(bind=connection)\n                database_uuid = local_session().query(LibraryId).one_or_none()\n                # local_session.dispose()\n\n            check_engine.connect()\n            db_change = config_calibre_uuid != database_uuid.uuid\n        except Exception:\n            return False, False\n        return True, db_change\n\n    @classmethod\n    def update_config(cls, config):\n        cls.config = config\n\n    @classmethod\n    def setup_db(cls, config_calibre_dir, app_db_path):\n        cls.dispose()\n\n        if not config_calibre_dir:\n            cls.config.invalidate()\n            return False\n\n        dbpath = os.path.join(config_calibre_dir, \"metadata.db\")\n        if not os.path.exists(dbpath):\n            cls.config.invalidate()\n            return False\n\n        try:\n            cls.engine = create_engine('sqlite://',\n                                       echo=False,\n                                       isolation_level=\"SERIALIZABLE\",\n                                       connect_args={'check_same_thread': False},\n                                       poolclass=StaticPool)\n            with cls.engine.begin() as connection:\n                connection.execute(text(\"attach database '{}' as calibre;\".format(dbpath)))\n                connection.execute(text(\"attach database '{}' as app_settings;\".format(app_db_path)))\n\n            conn = cls.engine.connect()\n            # conn.text_factory = lambda b: b.decode(errors = 'ignore') possible fix for #1302\n        except Exception as ex:\n            cls.config.invalidate(ex)\n            return False\n\n        cls.config.db_configured = True\n\n        if not cc_classes:\n            try:\n                cc = conn.execute(text(\"SELECT id, datatype FROM custom_columns\"))\n                cls.setup_db_cc_classes(cc)\n            except OperationalError as e:\n                log.error_or_exception(e)\n\n        cls.session_factory = scoped_session(sessionmaker(autocommit=False,\n                                                          autoflush=True,\n                                                          bind=cls.engine))\n        for inst in cls.instances:\n            inst.init_session()\n\n        cls._init = True\n        return True\n\n    def get_book(self, book_id):\n        return self.session.query(Books).filter(Books.id == book_id).first()\n\n    def get_filtered_book(self, book_id, allow_show_archived=False):\n        return self.session.query(Books).filter(Books.id == book_id). \\\n            filter(self.common_filters(allow_show_archived)).first()\n\n    def get_book_read_archived(self, book_id, read_column, allow_show_archived=False):\n        if not read_column:\n            bd = (self.session.query(Books, ub.ReadBook.read_status, ub.ArchivedBook.is_archived).select_from(Books)\n                  .join(ub.ReadBook, and_(ub.ReadBook.user_id == int(current_user.id), ub.ReadBook.book_id == book_id),\n                  isouter=True))\n        else:\n            try:\n                read_column = cc_classes[read_column]\n                bd = (self.session.query(Books, read_column.value, ub.ArchivedBook.is_archived).select_from(Books)\n                      .join(read_column, read_column.book == book_id,\n                      isouter=True))\n            except (KeyError, AttributeError):\n                log.error(\"Custom Column No.%d is not existing in calibre database\", read_column)\n                # Skip linking read column and return None instead of read status\n                bd = self.session.query(Books, None, ub.ArchivedBook.is_archived)\n        return (bd.filter(Books.id == book_id)\n                .join(ub.ArchivedBook, and_(Books.id == ub.ArchivedBook.book_id,\n                                            int(current_user.id) == ub.ArchivedBook.user_id), isouter=True)\n                .filter(self.common_filters(allow_show_archived)).first())\n\n    def get_book_by_uuid(self, book_uuid):\n        return self.session.query(Books).filter(Books.uuid == book_uuid).first()\n\n    def get_book_format(self, book_id, file_format):\n        return self.session.query(Data).filter(Data.book == book_id).filter(Data.format == file_format).first()\n\n    # Language and content filters for displaying in the UI\n    def common_filters(self, allow_show_archived=False, return_all_languages=False):\n        if not allow_show_archived:\n            archived_books = (ub.session.query(ub.ArchivedBook)\n                              .filter(ub.ArchivedBook.user_id == int(current_user.id))\n                              .filter(ub.ArchivedBook.is_archived == True)\n                              .all())\n            archived_book_ids = [archived_book.book_id for archived_book in archived_books]\n            archived_filter = Books.id.notin_(archived_book_ids)\n        else:\n            archived_filter = true()\n\n        if current_user.filter_language() == \"all\" or return_all_languages:\n            lang_filter = true()\n        else:\n            lang_filter = Books.languages.any(Languages.lang_code == current_user.filter_language())\n        negtags_list = current_user.list_denied_tags()\n        postags_list = current_user.list_allowed_tags()\n        neg_content_tags_filter = false() if negtags_list == [''] else Books.tags.any(Tags.name.in_(negtags_list))\n        pos_content_tags_filter = true() if postags_list == [''] else Books.tags.any(Tags.name.in_(postags_list))\n        if self.config.config_restricted_column:\n            try:\n                pos_cc_list = current_user.allowed_column_value.split(',')\n                pos_content_cc_filter = true() if pos_cc_list == [''] else \\\n                    getattr(Books, 'custom_column_' + str(self.config.config_restricted_column)). \\\n                    any(cc_classes[self.config.config_restricted_column].value.in_(pos_cc_list))\n                neg_cc_list = current_user.denied_column_value.split(',')\n                neg_content_cc_filter = false() if neg_cc_list == [''] else \\\n                    getattr(Books, 'custom_column_' + str(self.config.config_restricted_column)). \\\n                    any(cc_classes[self.config.config_restricted_column].value.in_(neg_cc_list))\n            except (KeyError, AttributeError):\n                pos_content_cc_filter = false()\n                neg_content_cc_filter = true()\n                log.error(u\"Custom Column No.%d is not existing in calibre database\",\n                          self.config.config_restricted_column)\n                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",\n                        column=self.config.config_restricted_column),\n                      category=\"error\")\n\n        else:\n            pos_content_cc_filter = true()\n            neg_content_cc_filter = false()\n        return and_(lang_filter, pos_content_tags_filter, ~neg_content_tags_filter,\n                    pos_content_cc_filter, ~neg_content_cc_filter, archived_filter)\n\n    @staticmethod\n    def get_checkbox_sorted(inputlist, state, offset, limit, order, combo=False):\n        outcome = list()\n        if combo:\n            elementlist = {ele[0].id: ele for ele in inputlist}\n        else:\n            elementlist = {ele.id: ele for ele in inputlist}\n        for entry in state:\n            try:\n                outcome.append(elementlist[entry])\n            except KeyError:\n                pass\n            del elementlist[entry]\n        for entry in elementlist:\n            outcome.append(elementlist[entry])\n        if order == \"asc\":\n            outcome.reverse()\n        return outcome[offset:offset + limit]\n\n    # Fill indexpage with all requested data from database\n    def fill_indexpage(self, page, pagesize, database, db_filter, order,\n                       join_archive_read=False, config_read_column=0, *join):\n        return self.fill_indexpage_with_archived_books(page, database, pagesize, db_filter, order, False,\n                                                       join_archive_read, config_read_column, *join)\n\n    def fill_indexpage_with_archived_books(self, page, database, pagesize, db_filter, order, allow_show_archived,\n                                           join_archive_read, config_read_column, *join):\n        pagesize = pagesize or self.config.config_books_per_page\n        if current_user.show_detail_random():\n            randm = self.session.query(Books) \\\n                .filter(self.common_filters(allow_show_archived)) \\\n                .order_by(func.random()) \\\n                .limit(self.config.config_random_books).all()\n        else:\n            randm = false()\n        if join_archive_read:\n            if not config_read_column:\n                query = (self.session.query(database, ub.ReadBook.read_status, ub.ArchivedBook.is_archived)\n                         .select_from(Books)\n                         .outerjoin(ub.ReadBook,\n                                    and_(ub.ReadBook.user_id == int(current_user.id), ub.ReadBook.book_id == Books.id)))\n            else:\n                try:\n                    read_column = cc_classes[config_read_column]\n                    query = (self.session.query(database, read_column.value, ub.ArchivedBook.is_archived)\n                             .select_from(Books)\n                             .outerjoin(read_column, read_column.book == Books.id))\n                except (KeyError, AttributeError):\n                    log.error(\"Custom Column No.%d is not existing in calibre database\", read_column)\n                    # Skip linking read column and return None instead of read status\n                    query = self.session.query(database, None, ub.ArchivedBook.is_archived)\n            query = query.outerjoin(ub.ArchivedBook, and_(Books.id == ub.ArchivedBook.book_id,\n                                                          int(current_user.id) == ub.ArchivedBook.user_id))\n        else:\n            query = self.session.query(database)\n        off = int(int(pagesize) * (page - 1))\n\n        indx = len(join)\n        element = 0\n        while indx:\n            if indx >= 3:\n                query = query.outerjoin(join[element], join[element+1]).outerjoin(join[element+2])\n                indx -= 3\n                element += 3\n            elif indx == 2:\n                query = query.outerjoin(join[element], join[element+1])\n                indx -= 2\n                element += 2\n            elif indx == 1:\n                query = query.outerjoin(join[element])\n                indx -= 1\n                element += 1\n        query = query.filter(db_filter)\\\n            .filter(self.common_filters(allow_show_archived))\n        entries = list()\n        pagination = list()\n        try:\n            pagination = Pagination(page, pagesize,\n                                    len(query.all()))\n            entries = query.order_by(*order).offset(off).limit(pagesize).all()\n        except Exception as ex:\n            log.error_or_exception(ex)\n        # display authors in right order\n        entries = self.order_authors(entries, True, join_archive_read)\n        return entries, randm, pagination\n\n    # Orders all Authors in the list according to authors sort\n    def order_authors(self, entries, list_return=False, combined=False):\n        # entries_copy = copy.deepcopy(entries)\n        # entries_copy =[]\n        for entry in entries:\n            if combined:\n                sort_authors = entry.Books.author_sort.split('&')\n                ids = [a.id for a in entry.Books.authors]\n\n            else:\n                sort_authors = entry.author_sort.split('&')\n                ids = [a.id for a in entry.authors]\n            authors_ordered = list()\n            # error = False\n            for auth in sort_authors:\n                results = self.session.query(Authors).filter(Authors.sort == auth.lstrip().strip()).all()\n                # ToDo: How to handle not found author name\n                if not len(results):\n                    log.error(\"Author {} not found to display name in right order\".format(auth.strip()))\n                    # error = True\n                    break\n                for r in results:\n                    if r.id in ids:\n                        authors_ordered.append(r)\n                        ids.remove(r.id)\n            for author_id in ids:\n                result = self.session.query(Authors).filter(Authors.id == author_id).first()\n                authors_ordered.append(result)\n\n            if list_return:\n                if combined:\n                    entry.Books.authors = authors_ordered\n                else:\n                    entry.ordered_authors = authors_ordered\n            else:\n                return authors_ordered\n        return entries\n\n    def get_typeahead(self, database, query, replace=('', ''), tag_filter=true()):\n        query = query or ''\n        self.session.connection().connection.connection.create_function(\"lower\", 1, lcase)\n        entries = self.session.query(database).filter(tag_filter). \\\n            filter(func.lower(database.name).ilike(\"%\" + query + \"%\")).all()\n        # json_dumps = json.dumps([dict(name=escape(r.name.replace(*replace))) for r in entries])\n        json_dumps = json.dumps([dict(name=r.name.replace(*replace)) for r in entries])\n        return json_dumps\n\n    def check_exists_book(self, authr, title):\n        self.session.connection().connection.connection.create_function(\"lower\", 1, lcase)\n        q = list()\n        authorterms = re.split(r'\\s*&\\s*', authr)\n        for authorterm in authorterms:\n            q.append(Books.authors.any(func.lower(Authors.name).ilike(\"%\" + authorterm + \"%\")))\n\n        return self.session.query(Books) \\\n            .filter(and_(Books.authors.any(and_(*q)), func.lower(Books.title).ilike(\"%\" + title + \"%\"))).first()\n\n    def search_query(self, term, config_read_column, *join):\n        term.strip().lower()\n        self.session.connection().connection.connection.create_function(\"lower\", 1, lcase)\n        q = list()\n        authorterms = re.split(\"[, ]+\", term)\n        for authorterm in authorterms:\n            q.append(Books.authors.any(func.lower(Authors.name).ilike(\"%\" + authorterm + \"%\")))\n        if not config_read_column:\n            query = (self.session.query(Books, ub.ArchivedBook.is_archived, ub.ReadBook).select_from(Books)\n                     .outerjoin(ub.ReadBook, and_(Books.id == ub.ReadBook.book_id,\n                                                  int(current_user.id) == ub.ReadBook.user_id)))\n        else:\n            try:\n                read_column = cc_classes[config_read_column]\n                query = (self.session.query(Books, ub.ArchivedBook.is_archived, read_column.value).select_from(Books)\n                         .outerjoin(read_column, read_column.book == Books.id))\n            except (KeyError, AttributeError):\n                log.error(\"Custom Column No.%d is not existing in calibre database\", config_read_column)\n                # Skip linking read column\n                query = self.session.query(Books, ub.ArchivedBook.is_archived, None)\n        query = query.outerjoin(ub.ArchivedBook, and_(Books.id == ub.ArchivedBook.book_id,\n                                                      int(current_user.id) == ub.ArchivedBook.user_id))\n\n        if len(join) == 6:\n            query = query.outerjoin(join[0], join[1]).outerjoin(join[2]).outerjoin(join[3], join[4]).outerjoin(join[5])\n        if len(join) == 3:\n            query = query.outerjoin(join[0], join[1]).outerjoin(join[2])\n        elif len(join) == 2:\n            query = query.outerjoin(join[0], join[1])\n        elif len(join) == 1:\n            query = query.outerjoin(join[0])\n        return query.filter(self.common_filters(True)).filter(\n            or_(Books.tags.any(func.lower(Tags.name).ilike(\"%\" + term + \"%\")),\n                Books.series.any(func.lower(Series.name).ilike(\"%\" + term + \"%\")),\n                Books.authors.any(and_(*q)),\n                Books.publishers.any(func.lower(Publishers.name).ilike(\"%\" + term + \"%\")),\n                func.lower(Books.title).ilike(\"%\" + term + \"%\")\n                ))\n\n    # read search results from calibre-database and return it (function is used for feed and simple search\n    def get_search_results(self, term, offset=None, order=None, limit=None,\n                           config_read_column=False, *join):\n        order = order[0] if order else [Books.sort]\n        pagination = None\n        result = self.search_query(term, config_read_column, *join).order_by(*order).all()\n        result_count = len(result)\n        if offset != None and limit != None:\n            offset = int(offset)\n            limit_all = offset + int(limit)\n            pagination = Pagination((offset / (int(limit)) + 1), limit, result_count)\n        else:\n            offset = 0\n            limit_all = result_count\n\n        ub.store_combo_ids(result)\n        entries = self.order_authors(result[offset:limit_all], list_return=True, combined=True)\n\n        return entries, result_count, pagination\n\n    # Creates for all stored languages a translated speaking name in the array for the UI\n    def speaking_language(self, languages=None, return_all_languages=False, with_count=False, reverse_order=False):\n        from . import get_locale\n\n        if with_count:\n            if not languages:\n                languages = self.session.query(Languages, func.count('books_languages_link.book'))\\\n                    .join(books_languages_link).join(Books)\\\n                    .filter(self.common_filters(return_all_languages=return_all_languages)) \\\n                    .group_by(text('books_languages_link.lang_code')).all()\n            for lang in languages:\n                lang[0].name = isoLanguages.get_language_name(get_locale(), lang[0].lang_code)\n            return sorted(languages, key=lambda x: x[0].name, reverse=reverse_order)\n        else:\n            if not languages:\n                languages = self.session.query(Languages) \\\n                    .join(books_languages_link) \\\n                    .join(Books) \\\n                    .filter(self.common_filters(return_all_languages=return_all_languages)) \\\n                    .group_by(text('books_languages_link.lang_code')).all()\n            for lang in languages:\n                lang.name = isoLanguages.get_language_name(get_locale(), lang.lang_code)\n            return sorted(languages, key=lambda x: x.name, reverse=reverse_order)\n\n    def update_title_sort(self, config, conn=None):\n        # user defined sort function for calibre databases (Series, etc.)\n        def _title_sort(title):\n            # calibre sort stuff\n            title_pat = re.compile(config.config_title_regex, re.IGNORECASE)\n            match = title_pat.search(title)\n            if match:\n                prep = match.group(1)\n                title = title[len(prep):] + ', ' + prep\n            return title.strip()\n\n        conn = conn or self.session.connection().connection.connection\n        conn.create_function(\"title_sort\", 1, _title_sort)\n\n    @classmethod\n    def dispose(cls):\n        # global session\n\n        for inst in cls.instances:\n            old_session = inst.session\n            inst.session = None\n            if old_session:\n                try:\n                    old_session.close()\n                except Exception:\n                    pass\n                if old_session.bind:\n                    try:\n                        old_session.bind.dispose()\n                    except Exception:\n                        pass\n\n        for attr in list(Books.__dict__.keys()):\n            if attr.startswith(\"custom_column_\"):\n                setattr(Books, attr, None)\n\n        for db_class in cc_classes.values():\n            Base.metadata.remove(db_class.__table__)\n        cc_classes.clear()\n\n        for table in reversed(Base.metadata.sorted_tables):\n            name = table.key\n            if name.startswith(\"custom_column_\") or name.startswith(\"books_custom_column_\"):\n                if table is not None:\n                    Base.metadata.remove(table)\n\n    def reconnect_db(self, config, app_db_path):\n        self.dispose()\n        self.engine.dispose()\n        self.setup_db(config.config_calibre_dir, app_db_path)\n        self.update_config(config)\n\n\ndef lcase(s):\n    try:\n        return unidecode.unidecode(s.lower())\n    except Exception as ex:\n        _log = logger.create()\n        _log.error_or_exception(ex)\n        return s.lower()\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nfrom datetime import datetime\nimport json\nfrom shutil import copyfile\nfrom uuid import uuid4\nfrom markupsafe import escape\nfrom functools import wraps\n\ntry:\n    from lxml.html.clean import clean_html\nexcept ImportError:\n    clean_html = None\n\nfrom flask import Blueprint, request, flash, redirect, url_for, abort, Markup, Response\nfrom flask_babel import gettext as _\nfrom flask_login import current_user, login_required\nfrom sqlalchemy.exc import OperationalError, IntegrityError\nfrom sqlite3 import OperationalError as sqliteOperationalError\nfrom . import constants, logger, isoLanguages, gdriveutils, uploader, helper, kobo_sync_status\nfrom . import config, get_locale, ub, db\nfrom . import calibre_db\nfrom .services.worker import WorkerThread\nfrom .tasks.upload import TaskUpload\nfrom .render_template import render_title_template\nfrom .usermanagement import login_required_if_no_ano\nfrom .kobo_sync_status import change_archived_books\n\n\nEditBook = Blueprint('edit-book', __name__)\nlog = logger.create()\n\n\ndef upload_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_upload():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n\ndef edit_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_edit() or current_user.role_admin():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n\ndef search_objects_remove(db_book_object, db_type, input_elements):\n    del_elements = []\n    for c_elements in db_book_object:\n        found = False\n        if db_type == 'languages':\n            type_elements = c_elements.lang_code\n        elif db_type == 'custom':\n            type_elements = c_elements.value\n        else:\n            type_elements = c_elements.name\n        for inp_element in input_elements:\n            if inp_element.lower() == type_elements.lower():\n                found = True\n                break\n        # if the element was not found in the new list, add it to remove list\n        if not found:\n            del_elements.append(c_elements)\n    return del_elements\n\n\ndef search_objects_add(db_book_object, db_type, input_elements):\n    add_elements = []\n    for inp_element in input_elements:\n        found = False\n        for c_elements in db_book_object:\n            if db_type == 'languages':\n                type_elements = c_elements.lang_code\n            elif db_type == 'custom':\n                type_elements = c_elements.value\n            else:\n                type_elements = c_elements.name\n            if inp_element == type_elements:\n                found = True\n                break\n        if not found:\n            add_elements.append(inp_element)\n    return add_elements\n\n\ndef remove_objects(db_book_object, db_session, del_elements):\n    changed = False\n    if len(del_elements) > 0:\n        for del_element in del_elements:\n            db_book_object.remove(del_element)\n            changed = True\n            if len(del_element.books) == 0:\n                db_session.delete(del_element)\n    return changed\n\n\ndef add_objects(db_book_object, db_object, db_session, db_type, add_elements):\n    changed = False\n    if db_type == 'languages':\n        db_filter = db_object.lang_code\n    elif db_type == 'custom':\n        db_filter = db_object.value\n    else:\n        db_filter = db_object.name\n    for add_element in add_elements:\n        # check if an element with that name exists\n        db_element = db_session.query(db_object).filter(db_filter == add_element).first()\n        # if no element is found add it\n        if db_type == 'author':\n            new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")\n        elif db_type == 'series':\n            new_element = db_object(add_element, add_element)\n        elif db_type == 'custom':\n            new_element = db_object(value=add_element)\n        elif db_type == 'publisher':\n            new_element = db_object(add_element, None)\n        else:  # db_type should be tag or language\n            new_element = db_object(add_element)\n        if db_element is None:\n            changed = True\n            db_session.add(new_element)\n            db_book_object.append(new_element)\n        else:\n            db_element = create_objects_for_addition(db_element, add_element, db_type)\n            # add element to book\n            changed = True\n            db_book_object.append(db_element)\n    return changed\n\n\ndef create_objects_for_addition(db_element, add_element, db_type):\n    if db_type == 'custom':\n        if db_element.value != add_element:\n            db_element.value = add_element\n    elif db_type == 'languages':\n        if db_element.lang_code != add_element:\n            db_element.lang_code = add_element\n    elif db_type == 'series':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = add_element\n    elif db_type == 'author':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = helper.get_sorted_author(add_element.replace('|', ','))\n    elif db_type == 'publisher':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = None\n    elif db_element.name != add_element:\n        db_element.name = add_element\n    return db_element\n\n\n# Modifies different Database objects, first check if elements have to be deleted,\n# because they are no longer used, than check if elements have to be added to database\ndef modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):\n    # passing input_elements not as a list may lead to undesired results\n    if not isinstance(input_elements, list):\n        raise TypeError(str(input_elements) + \" should be passed as a list\")\n    input_elements = [x for x in input_elements if x != '']\n    # we have all input element (authors, series, tags) names now\n    # 1. search for elements to remove\n    del_elements = search_objects_remove(db_book_object, db_type, input_elements)\n    # 2. search for elements that need to be added\n    add_elements = search_objects_add(db_book_object, db_type, input_elements)\n    # if there are elements to remove, we remove them now\n    changed = remove_objects(db_book_object, db_session, del_elements)\n    # if there are elements to add, we add them now!\n    if len(add_elements) > 0:\n        changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)\n    return changed\n\n\ndef modify_identifiers(input_identifiers, db_identifiers, db_session):\n    \"\"\"Modify Identifiers to match input information.\n       input_identifiers is a list of read-to-persist Identifiers objects.\n       db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"\n    changed = False\n    error = False\n    input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])\n    if len(input_identifiers) != len(input_dict):\n        error = True\n    db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers])\n    # delete db identifiers not present in input or modify them with input val\n    for identifier_type, identifier in db_dict.items():\n        if identifier_type not in input_dict.keys():\n            db_session.delete(identifier)\n            changed = True\n        else:\n            input_identifier = input_dict[identifier_type]\n            identifier.type = input_identifier.type\n            identifier.val = input_identifier.val\n    # add input identifiers not present in db\n    for identifier_type, identifier in input_dict.items():\n        if identifier_type not in db_dict.keys():\n            db_session.add(identifier)\n            changed = True\n    return changed, error\n\n\n@EditBook.route(\"/ajax/delete/<int:book_id>\", methods=[\"POST\"])\n@login_required\ndef delete_book_from_details(book_id):\n    return Response(delete_book_from_table(book_id, \"\", True), mimetype='application/json')\n\n\n@EditBook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"}, methods=[\"POST\"])\n@EditBook.route(\"/delete/<int:book_id>/<string:book_format>\", methods=[\"POST\"])\n@login_required\ndef delete_book_ajax(book_id, book_format):\n    return delete_book_from_table(book_id, book_format, False)\n\n\ndef delete_whole_book(book_id, book):\n    # delete book from Shelfs, Downloads, Read list\n    ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()\n    ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()\n    ub.delete_download(book_id)\n    ub.session_commit()\n\n    # check if only this book links to:\n    # author, language, series, tags, custom columns\n    modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')\n    modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')\n    modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')\n    modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')\n    modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')\n\n    cc = calibre_db.session.query(db.CustomColumns). \\\n        filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).all()\n    for c in cc:\n        cc_string = \"custom_column_\" + str(c.id)\n        if not c.is_multiple:\n            if len(getattr(book, cc_string)) > 0:\n                if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    log.debug('remove ' + str(c.id))\n                    calibre_db.session.delete(del_cc)\n                    calibre_db.session.commit()\n                elif c.datatype == 'rating':\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    if len(del_cc.books) == 0:\n                        log.debug('remove ' + str(c.id))\n                        calibre_db.session.delete(del_cc)\n                        calibre_db.session.commit()\n                else:\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    log.debug('remove ' + str(c.id))\n                    calibre_db.session.delete(del_cc)\n                    calibre_db.session.commit()\n        else:\n            modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],\n                                   calibre_db.session, 'custom')\n    calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()\n\n\ndef render_delete_book_result(book_format, json_response, warning, book_id):\n    if book_format:\n        if json_response:\n            return json.dumps([warning, {\"location\": url_for(\"edit-book.edit_book\", book_id=book_id),\n                                         \"type\": \"success\",\n                                         \"format\": book_format,\n                                         \"message\": _('Book Format Successfully Deleted')}])\n        else:\n            flash(_('Book Format Successfully Deleted'), category=\"success\")\n            return redirect(url_for('edit-book.edit_book', book_id=book_id))\n    else:\n        if json_response:\n            return json.dumps([warning, {\"location\": url_for('web.index'),\n                                         \"type\": \"success\",\n                                         \"format\": book_format,\n                                         \"message\": _('Book Successfully Deleted')}])\n        else:\n            flash(_('Book Successfully Deleted'), category=\"success\")\n            return redirect(url_for('web.index'))\n\n\ndef delete_book_from_table(book_id, book_format, json_response):\n    warning = {}\n    if current_user.role_delete_books():\n        book = calibre_db.get_book(book_id)\n        if book:\n            try:\n                result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())\n                if not result:\n                    if json_response:\n                        return json.dumps([{\"location\": url_for(\"edit-book.edit_book\", book_id=book_id),\n                                            \"type\": \"danger\",\n                                            \"format\": \"\",\n                                            \"message\": error}])\n                    else:\n                        flash(error, category=\"error\")\n                        return redirect(url_for('edit-book.edit_book', book_id=book_id))\n                if error:\n                    if json_response:\n                        warning = {\"location\": url_for(\"edit-book.edit_book\", book_id=book_id),\n                                   \"type\": \"warning\",\n                                   \"format\": \"\",\n                                   \"message\": error}\n                    else:\n                        flash(error, category=\"warning\")\n                if not book_format:\n                    delete_whole_book(book_id, book)\n                else:\n                    calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\\n                        filter(db.Data.format == book_format).delete()\n                    if book_format.upper() in ['KEPUB', 'EPUB', 'EPUB3']:\n                        kobo_sync_status.remove_synced_book(book.id, True)\n                calibre_db.session.commit()\n            except Exception as ex:\n                log.error_or_exception(ex)\n                calibre_db.session.rollback()\n                if json_response:\n                    return json.dumps([{\"location\": url_for(\"edit-book.edit_book\", book_id=book_id),\n                                        \"type\": \"danger\",\n                                        \"format\": \"\",\n                                        \"message\": ex}])\n                else:\n                    flash(str(ex), category=\"error\")\n                    return redirect(url_for('edit-book.edit_book', book_id=book_id))\n\n        else:\n            # book not found\n            log.error('Book with id \"%s\" could not be deleted: not found', book_id)\n        return render_delete_book_result(book_format, json_response, warning, book_id)\n    message = _(\"You are missing permissions to delete books\")\n    if json_response:\n        return json.dumps({\"location\": url_for(\"edit-book.edit_book\", book_id=book_id),\n                           \"type\": \"danger\",\n                           \"format\": \"\",\n                           \"message\": message})\n    else:\n        flash(message, category=\"error\")\n        return redirect(url_for('edit-book.edit_book', book_id=book_id))\n\n\ndef render_edit_book(book_id):\n    cc = calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).all()\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),\n              category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n    for lang in book.languages:\n        lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)\n\n    book.authors = calibre_db.order_authors([book])\n\n    author_names = []\n    for authr in book.authors:\n        author_names.append(authr.name.replace('|', ','))\n\n    # Option for showing convertbook button\n    valid_source_formats = list()\n    allowed_conversion_formats = list()\n    kepub_possible = None\n    if config.config_converterpath:\n        for file in book.data:\n            if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:\n                valid_source_formats.append(file.format.lower())\n    if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:\n        kepub_possible = True\n        if not config.config_converterpath:\n            valid_source_formats.append('epub')\n\n    # Determine what formats don't already exist\n    if config.config_converterpath:\n        allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]\n        for file in book.data:\n            if file.format.lower() in allowed_conversion_formats:\n                allowed_conversion_formats.remove(file.format.lower())\n    if kepub_possible:\n        allowed_conversion_formats.append('kepub')\n    return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,\n                                 title=_(u\"edit metadata\"), page=\"editbook\",\n                                 conversion_formats=allowed_conversion_formats,\n                                 config=config,\n                                 source_formats=valid_source_formats)\n\n\ndef edit_book_ratings(to_save, book):\n    changed = False\n    if to_save[\"rating\"].strip():\n        old_rating = False\n        if len(book.ratings) > 0:\n            old_rating = book.ratings[0].rating\n        ratingx2 = int(float(to_save[\"rating\"]) * 2)\n        if ratingx2 != old_rating:\n            changed = True\n            is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == ratingx2).first()\n            if is_rating:\n                book.ratings.append(is_rating)\n            else:\n                new_rating = db.Ratings(rating=ratingx2)\n                book.ratings.append(new_rating)\n            if old_rating:\n                book.ratings.remove(book.ratings[0])\n    else:\n        if len(book.ratings) > 0:\n            book.ratings.remove(book.ratings[0])\n            changed = True\n    return changed\n\n\ndef edit_book_tags(tags, book):\n    input_tags = tags.split(',')\n    input_tags = list(map(lambda it: it.strip(), input_tags))\n    # Remove duplicates\n    input_tags = helper.uniq(input_tags)\n    return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')\n\n\ndef edit_book_series(series, book):\n    input_series = [series.strip()]\n    input_series = [x for x in input_series if x != '']\n    return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')\n\n\ndef edit_book_series_index(series_index, book):\n    # Add default series_index to book\n    modify_date = False\n    series_index = series_index or '1'\n    if not series_index.replace('.', '', 1).isdigit():\n        flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")\n        return False\n    if str(book.series_index) != series_index:\n        book.series_index = series_index\n        modify_date = True\n    return modify_date\n\n\n# Handle book comments/description\ndef edit_book_comments(comments, book):\n    modify_date = False\n    if comments:\n        comments = clean_html(comments)\n    if len(book.comments):\n        if book.comments[0].text != comments:\n            book.comments[0].text = comments\n            modify_date = True\n    else:\n        if comments:\n            book.comments.append(db.Comments(comment=comments, book=book.id))\n            modify_date = True\n    return modify_date\n\n\ndef edit_book_languages(languages, book, upload_mode=False, invalid=None):\n    input_languages = languages.split(',')\n    unknown_languages = []\n    if not upload_mode:\n        input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)\n    else:\n        input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)\n    for lang in unknown_languages:\n        log.error(\"'%s' is not a valid language\", lang)\n        if isinstance(invalid, list):\n            invalid.append(lang)\n        else:\n            raise ValueError(_(u\"'%(langname)s' is not a valid language\", langname=lang))\n    # ToDo: Not working correct\n    if upload_mode and len(input_l) == 1:\n        # If the language of the file is excluded from the users view, it's not imported, to allow the user to view\n        # the book it's language is set to the filter language\n        if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":\n            input_l[0] = calibre_db.session.query(db.Languages). \\\n                filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code\n    # Remove duplicates\n    input_l = helper.uniq(input_l)\n    return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')\n\n\ndef edit_book_publisher(publishers, book):\n    changed = False\n    if publishers:\n        publisher = publishers.rstrip().strip()\n        if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):\n            changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,\n                                              'publisher')\n    elif len(book.publishers):\n        changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')\n    return changed\n\n\ndef edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):\n    changed = False\n    if to_save[cc_string] == 'None':\n        to_save[cc_string] = None\n    elif c.datatype == 'bool':\n        to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0\n    elif c.datatype == 'comments':\n        to_save[cc_string] = Markup(to_save[cc_string]).unescape()\n        if to_save[cc_string]:\n            to_save[cc_string] = clean_html(to_save[cc_string])\n    elif c.datatype == 'datetime':\n        try:\n            to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")\n        except ValueError:\n            to_save[cc_string] = db.Books.DEFAULT_PUBDATE\n\n    if to_save[cc_string] != cc_db_value:\n        if cc_db_value is not None:\n            if to_save[cc_string] is not None:\n                setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])\n                changed = True\n            else:\n                del_cc = getattr(book, cc_string)[0]\n                getattr(book, cc_string).remove(del_cc)\n                calibre_db.session.delete(del_cc)\n                changed = True\n        else:\n            cc_class = db.cc_classes[c.id]\n            new_cc = cc_class(value=to_save[cc_string], book=book_id)\n            calibre_db.session.add(new_cc)\n            changed = True\n    return changed, to_save\n\n\ndef edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):\n    changed = False\n    if c.datatype == 'rating':\n        to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))\n    if to_save[cc_string].strip() != cc_db_value:\n        if cc_db_value is not None:\n            # remove old cc_val\n            del_cc = getattr(book, cc_string)[0]\n            getattr(book, cc_string).remove(del_cc)\n            if len(del_cc.books) == 0:\n                calibre_db.session.delete(del_cc)\n                changed = True\n        cc_class = db.cc_classes[c.id]\n        new_cc = calibre_db.session.query(cc_class).filter(\n            cc_class.value == to_save[cc_string].strip()).first()\n        # if no cc val is found add it\n        if new_cc is None:\n            new_cc = cc_class(value=to_save[cc_string].strip())\n            calibre_db.session.add(new_cc)\n            changed = True\n            calibre_db.session.flush()\n            new_cc = calibre_db.session.query(cc_class).filter(\n                cc_class.value == to_save[cc_string].strip()).first()\n        # add cc value to book\n        getattr(book, cc_string).append(new_cc)\n    return changed, to_save\n\n\ndef edit_single_cc_data(book_id, book, column_id, to_save):\n    cc = (calibre_db.session.query(db.CustomColumns)\n          .filter(db.CustomColumns.datatype.notin_(db.cc_exceptions))\n          .filter(db.CustomColumns.id == column_id)\n          .all())\n    return edit_cc_data(book_id, book, to_save, cc)\n\n\ndef edit_all_cc_data(book_id, book, to_save):\n    cc = calibre_db.session.query(db.CustomColumns).filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).all()\n    return edit_cc_data(book_id, book, to_save, cc)\n\n\ndef edit_cc_data(book_id, book, to_save, cc):\n    changed = False\n    for c in cc:\n        cc_string = \"custom_column_\" + str(c.id)\n        if not c.is_multiple:\n            if len(getattr(book, cc_string)) > 0:\n                cc_db_value = getattr(book, cc_string)[0].value\n            else:\n                cc_db_value = None\n            if to_save[cc_string].strip():\n                if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:\n                    changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)\n                else:\n                    changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)\n            else:\n                if cc_db_value is not None:\n                    # remove old cc_val\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    if not del_cc.books or len(del_cc.books) == 0:\n                        calibre_db.session.delete(del_cc)\n                        changed = True\n        else:\n            input_tags = to_save[cc_string].split(',')\n            input_tags = list(map(lambda it: it.strip(), input_tags))\n            changed |= modify_database_object(input_tags,\n                                              getattr(book, cc_string),\n                                              db.cc_classes[c.id],\n                                              calibre_db.session,\n                                              'custom')\n    return changed\n\n\ndef upload_single_file(file_request, book, book_id):\n    # Check and handle Uploaded file\n    if 'btn-upload-format' in file_request.files:\n        requested_file = file_request.files['btn-upload-format']\n        # check for empty request\n        if requested_file.filename != '':\n            if not current_user.role_upload():\n                abort(403)\n            if '.' in requested_file.filename:\n                file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()\n                if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:\n                    flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),\n                          category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n            else:\n                flash(_('File to be uploaded must have an extension'), category=\"error\")\n                return redirect(url_for('web.show_book', book_id=book.id))\n\n            file_name = book.path.rsplit('/', 1)[-1]\n            filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))\n            saved_filename = os.path.join(filepath, file_name + '.' + file_ext)\n\n            # check if file path exists, otherwise create it, copy file to calibre path and delete temp file\n            if not os.path.exists(filepath):\n                try:\n                    os.makedirs(filepath)\n                except OSError:\n                    flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n            try:\n                requested_file.save(saved_filename)\n            except OSError:\n                flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")\n                return redirect(url_for('web.show_book', book_id=book.id))\n\n            file_size = os.path.getsize(saved_filename)\n            is_format = calibre_db.get_book_format(book_id, file_ext.upper())\n\n            # Format entry already exists, no need to update the database\n            if is_format:\n                log.warning('Book format %s already existing', file_ext.upper())\n            else:\n                try:\n                    db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)\n                    calibre_db.session.add(db_format)\n                    calibre_db.session.commit()\n                    calibre_db.update_title_sort(config)\n                except (OperationalError, IntegrityError) as e:\n                    calibre_db.session.rollback()\n                    log.error_or_exception(\"Database error: {}\".format(e))\n                    flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n\n            # Queue uploader info\n            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))\n            upload_text = _(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=link)\n            WorkerThread.add(current_user.name, TaskUpload(upload_text, escape(book.title)))\n\n            return uploader.process(\n                saved_filename, *os.path.splitext(requested_file.filename),\n                rarExecutable=config.config_rarfile_location)\n\n\ndef upload_cover(cover_request, book):\n    if 'btn-upload-cover' in cover_request.files:\n        requested_file = cover_request.files['btn-upload-cover']\n        # check for empty request\n        if requested_file.filename != '':\n            if not current_user.role_upload():\n                abort(403)\n            ret, message = helper.save_cover(requested_file, book.path)\n            if ret is True:\n                return True\n            else:\n                flash(message, category=\"error\")\n                return False\n    return None\n\n\ndef handle_title_on_edit(book, book_title):\n    # handle book title\n    book_title = book_title.rstrip().strip()\n    if book.title != book_title:\n        if book_title == '':\n            book_title = _(u'Unknown')\n        book.title = book_title\n        return True\n    return False\n\n\ndef handle_author_on_edit(book, author_name, update_stored=True):\n    # handle author(s)\n    input_authors, renamed = prepare_authors(author_name)\n    '''input_authors = author_name.split('&')\n    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))\n    # Remove duplicates in authors list\n    input_authors = helper.uniq(input_authors)\n    # we have all author names now\n    if input_authors == ['']:\n        input_authors = [_(u'Unknown')]  # prevent empty Author\n\n    renamed = list()\n    for in_aut in input_authors:\n        renamed_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == in_aut).first()\n        if renamed_author and in_aut != renamed_author.name:\n            renamed.append(renamed_author.name)\n            all_books = calibre_db.session.query(db.Books) \\\n                .filter(db.Books.authors.any(db.Authors.name == renamed_author.name)).all()\n            sorted_renamed_author = helper.get_sorted_author(renamed_author.name)\n            sorted_old_author = helper.get_sorted_author(in_aut)\n            for one_book in all_books:\n                one_book.author_sort = one_book.author_sort.replace(sorted_renamed_author, sorted_old_author)'''\n\n    change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')\n\n    # Search for each author if author is in database, if not, author name and sorted author name is generated new\n    # everything then is assembled for sorted author field in database\n    sort_authors_list = list()\n    for inp in input_authors:\n        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()\n        if not stored_author:\n            stored_author = helper.get_sorted_author(inp)\n        else:\n            stored_author = stored_author.sort\n        sort_authors_list.append(helper.get_sorted_author(stored_author))\n    sort_authors = ' & '.join(sort_authors_list)\n    if book.author_sort != sort_authors and update_stored:\n        book.author_sort = sort_authors\n        change = True\n    return input_authors, change, renamed\n\n\n@EditBook.route(\"/admin/book/<int:book_id>\", methods=['GET', 'POST'])\n@login_required_if_no_ano\n@edit_required\ndef edit_book(book_id):\n    modify_date = False\n\n    # create the function for sorting...\n    try:\n        calibre_db.update_title_sort(config)\n    except sqliteOperationalError as e:\n        log.error_or_exception(e)\n        calibre_db.session.rollback()\n\n    # Show form\n    if request.method != 'POST':\n        return render_edit_book(book_id)\n\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n\n    # Book not found\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),\n              category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n    meta = upload_single_file(request, book, book_id)\n    if upload_cover(request, book) is True:\n        book.has_cover = 1\n        modify_date = True\n    try:\n        to_save = request.form.to_dict()\n        merge_metadata(to_save, meta)\n        # Update book\n        edited_books_id = None\n\n        # handle book title\n        title_change = handle_title_on_edit(book, to_save[\"book_title\"])\n\n        input_authors, authorchange, renamed = handle_author_on_edit(book, to_save[\"author_name\"])\n        if authorchange or title_change:\n            edited_books_id = book.id\n            modify_date = True\n\n        if config.config_use_google_drive:\n            gdriveutils.updateGdriveCalibreFromLocal()\n\n        error = \"\"\n        if edited_books_id:\n            error = helper.update_dir_structure(edited_books_id, config.config_calibre_dir, input_authors[0],\n                                                renamed_author=renamed)\n\n        if not error:\n            if \"cover_url\" in to_save:\n                if to_save[\"cover_url\"]:\n                    if not current_user.role_upload():\n                        calibre_db.session.rollback()\n                        return \"\", 403\n                    if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):\n                        book.has_cover = 0\n                    else:\n                        result, error = helper.save_cover_from_url(to_save[\"cover_url\"], book.path)\n                        if result is True:\n                            book.has_cover = 1\n                            modify_date = True\n                        else:\n                            flash(error, category=\"error\")\n\n            # Add default series_index to book\n            modify_date |= edit_book_series_index(to_save[\"series_index\"], book)\n            # Handle book comments/description\n            modify_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)\n            # Handle identifiers\n            input_identifiers = identifier_list(to_save, book)\n            modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)\n            if warning:\n                flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")\n            modify_date |= modification\n            # Handle book tags\n            modify_date |= edit_book_tags(to_save['tags'], book)\n            # Handle book series\n            modify_date |= edit_book_series(to_save[\"series\"], book)\n            # handle book publisher\n            modify_date |= edit_book_publisher(to_save['publisher'], book)\n            # handle book languages\n            modify_date |= edit_book_languages(to_save['languages'], book)\n            # handle book ratings\n            modify_date |= edit_book_ratings(to_save, book)\n            # handle cc data\n            modify_date |= edit_all_cc_data(book_id, book, to_save)\n\n            if to_save[\"pubdate\"]:\n                try:\n                    book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")\n                except ValueError:\n                    book.pubdate = db.Books.DEFAULT_PUBDATE\n            else:\n                book.pubdate = db.Books.DEFAULT_PUBDATE\n\n            if modify_date:\n                book.last_modified = datetime.utcnow()\n                kobo_sync_status.remove_synced_book(edited_books_id, all=True)\n\n            calibre_db.session.merge(book)\n            calibre_db.session.commit()\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n            if \"detail_view\" in to_save:\n                return redirect(url_for('web.show_book', book_id=book.id))\n            else:\n                flash(_(\"Metadata successfully updated\"), category=\"success\")\n                return render_edit_book(book_id)\n        else:\n            calibre_db.session.rollback()\n            flash(error, category=\"error\")\n            return render_edit_book(book_id)\n    except ValueError as e:\n        calibre_db.session.rollback()\n        flash(str(e), category=\"error\")\n        return redirect(url_for('web.show_book', book_id=book.id))\n    except (OperationalError, IntegrityError) as e:\n        log.error_or_exception(\"Database error: {}\".format(e))\n        calibre_db.session.rollback()\n        flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")\n        return redirect(url_for('web.show_book', book_id=book.id))\n    except Exception as ex:\n        log.error_or_exception(ex)\n        calibre_db.session.rollback()\n        flash(_(\"Error editing book, please check logfile for details\"), category=\"error\")\n        return redirect(url_for('web.show_book', book_id=book.id))\n\n\ndef merge_metadata(to_save, meta):\n    if to_save['author_name'] == _(u'Unknown'):\n        to_save['author_name'] = ''\n    if to_save['book_title'] == _(u'Unknown'):\n        to_save['book_title'] = ''\n    for s_field, m_field in [\n            ('tags', 'tags'), ('author_name', 'author'), ('series', 'series'),\n            ('series_index', 'series_id'), ('languages', 'languages'),\n            ('book_title', 'title')]:\n        to_save[s_field] = to_save[s_field] or getattr(meta, m_field, '')\n    to_save[\"description\"] = to_save[\"description\"] or Markup(\n        getattr(meta, 'description', '')).unescape()\n\n\ndef identifier_list(to_save, book):\n    \"\"\"Generate a list of Identifiers from form information\"\"\"\n    id_type_prefix = 'identifier-type-'\n    id_val_prefix = 'identifier-val-'\n    result = []\n    for type_key, type_value in to_save.items():\n        if not type_key.startswith(id_type_prefix):\n            continue\n        val_key = id_val_prefix + type_key[len(id_type_prefix):]\n        if val_key not in to_save.keys():\n            continue\n        result.append(db.Identifiers(to_save[val_key], type_value, book.id))\n    return result\n\n\ndef prepare_authors(authr):\n    # handle authors\n    input_authors = authr.split('&')\n    # handle_authors(input_authors)\n    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))\n    # Remove duplicates in authors list\n    input_authors = helper.uniq(input_authors)\n\n    # we have all author names now\n    if input_authors == ['']:\n        input_authors = [_(u'Unknown')]  # prevent empty Author\n\n    renamed = list()\n    for in_aut in input_authors:\n        renamed_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == in_aut).first()\n        if renamed_author and in_aut != renamed_author.name:\n            renamed.append(renamed_author.name)\n            all_books = calibre_db.session.query(db.Books) \\\n                .filter(db.Books.authors.any(db.Authors.name == renamed_author.name)).all()\n            sorted_renamed_author = helper.get_sorted_author(renamed_author.name)\n            sorted_old_author = helper.get_sorted_author(in_aut)\n            for one_book in all_books:\n                one_book.author_sort = one_book.author_sort.replace(sorted_renamed_author, sorted_old_author)\n    return input_authors, renamed\n\n\ndef prepare_authors_on_upload(title, authr):\n    if title != _(u'Unknown') and authr != _(u'Unknown'):\n        entry = calibre_db.check_exists_book(authr, title)\n        if entry:\n            log.info(\"Uploaded book probably exists in library\")\n            flash(_(u\"Uploaded book probably exists in the library, consider to change before upload new: \")\n                  + Markup(render_title_template('book_exists_flash.html', entry=entry)), category=\"warning\")\n\n    input_authors, renamed = prepare_authors(authr)\n\n    sort_authors_list = list()\n    db_author = None\n    for inp in input_authors:\n        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()\n        if not stored_author:\n            if not db_author:\n                db_author = db.Authors(inp, helper.get_sorted_author(inp), \"\")\n                calibre_db.session.add(db_author)\n                calibre_db.session.commit()\n            sort_author = helper.get_sorted_author(inp)\n        else:\n            if not db_author:\n                db_author = stored_author\n            sort_author = stored_author.sort\n        sort_authors_list.append(sort_author)\n    sort_authors = ' & '.join(sort_authors_list)\n    return sort_authors, input_authors, db_author, renamed\n\n\ndef create_book_on_upload(modify_date, meta):\n    title = meta.title\n    authr = meta.author\n    sort_authors, input_authors, db_author, renamed_authors = prepare_authors_on_upload(title, authr)\n\n    title_dir = helper.get_valid_filename(title, chars=96)\n    author_dir = helper.get_valid_filename(db_author.name, chars=96)\n\n    # combine path and normalize path from Windows systems\n    path = os.path.join(author_dir, title_dir).replace('\\\\', '/')\n\n    # Calibre adds books with utc as timezone\n    db_book = db.Books(title, \"\", sort_authors, datetime.utcnow(), datetime(101, 1, 1),\n                       '1', datetime.utcnow(), path, meta.cover, db_author, [], \"\")\n\n    modify_date |= modify_database_object(input_authors, db_book.authors, db.Authors, calibre_db.session,\n                                          'author')\n\n    # Add series_index to book\n    modify_date |= edit_book_series_index(meta.series_id, db_book)\n\n    # add languages\n    invalid = []\n    modify_date |= edit_book_languages(meta.languages, db_book, upload_mode=True, invalid=invalid)\n    if invalid:\n        for lang in invalid:\n            flash(_(u\"'%(langname)s' is not a valid language\", langname=lang), category=\"warning\")\n\n    # handle tags\n    modify_date |= edit_book_tags(meta.tags, db_book)\n\n    # handle publisher\n    modify_date |= edit_book_publisher(meta.publisher, db_book)\n\n    # handle series\n    modify_date |= edit_book_series(meta.series, db_book)\n\n    # Add file to book\n    file_size = os.path.getsize(meta.file_path)\n    db_data = db.Data(db_book, meta.extension.upper()[1:], file_size, title_dir)\n    db_book.data.append(db_data)\n    calibre_db.session.add(db_book)\n\n    # flush content, get db_book.id available\n    calibre_db.session.flush()\n    return db_book, input_authors, title_dir, renamed_authors\n\n\ndef file_handling_on_upload(requested_file):\n    # check if file extension is correct\n    if '.' in requested_file.filename:\n        file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()\n        if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:\n            flash(\n                _(\"File extension '%(ext)s' is not allowed to be uploaded to this server\",\n                  ext=file_ext), category=\"error\")\n            return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n    else:\n        flash(_('File to be uploaded must have an extension'), category=\"error\")\n        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n\n    # extract metadata from file\n    try:\n        meta = uploader.upload(requested_file, config.config_rarfile_location)\n    except (IOError, OSError):\n        log.error(\"File %s could not saved to temp dir\", requested_file.filename)\n        flash(_(u\"File %(filename)s could not saved to temp dir\",\n                filename=requested_file.filename), category=\"error\")\n        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n    return meta, None\n\n\ndef move_coverfile(meta, db_book):\n    # move cover to final directory, including book id\n    if meta.cover:\n        coverfile = meta.cover\n    else:\n        coverfile = os.path.join(constants.STATIC_DIR, 'generic_cover.jpg')\n    new_coverpath = os.path.join(config.config_calibre_dir, db_book.path)\n    try:\n        os.makedirs(new_coverpath, exist_ok=True)\n        copyfile(coverfile, os.path.join(new_coverpath, \"cover.jpg\"))\n        if meta.cover:\n            os.unlink(meta.cover)\n    except OSError as e:\n        log.error(\"Failed to move cover file %s: %s\", new_coverpath, e)\n        flash(_(u\"Failed to Move Cover File %(file)s: %(error)s\", file=new_coverpath,\n                error=e),\n              category=\"error\")\n\n\n@EditBook.route(\"/upload\", methods=[\"POST\"])\n@login_required_if_no_ano\n@upload_required\ndef upload():\n    if not config.config_uploading:\n        abort(404)\n    if request.method == 'POST' and 'btn-upload' in request.files:\n        for requested_file in request.files.getlist(\"btn-upload\"):\n            try:\n                modify_date = False\n                # create the function for sorting...\n                calibre_db.update_title_sort(config)\n                calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))\n\n                meta, error = file_handling_on_upload(requested_file)\n                if error:\n                    return error\n\n                db_book, input_authors, title_dir, renamed_authors = create_book_on_upload(modify_date, meta)\n\n                # Comments need book id therefore only possible after flush\n                modify_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)\n\n                book_id = db_book.id\n                title = db_book.title\n                if config.config_use_google_drive:\n                    helper.upload_new_file_gdrive(book_id,\n                                                  input_authors[0],\n                                                  renamed_authors,\n                                                  title,\n                                                  title_dir,\n                                                  meta.file_path,\n                                                  meta.extension.lower())\n                else:\n                    error = helper.update_dir_structure(book_id,\n                                                        config.config_calibre_dir,\n                                                        input_authors[0],\n                                                        meta.file_path,\n                                                        title_dir + meta.extension.lower(),\n                                                        renamed_author=renamed_authors)\n\n                move_coverfile(meta, db_book)\n\n                # save data to database, reread data\n                calibre_db.session.commit()\n\n                if config.config_use_google_drive:\n                    gdriveutils.updateGdriveCalibreFromLocal()\n                if error:\n                    flash(error, category=\"error\")\n                link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(title))\n                upload_text = _(u\"File %(file)s uploaded\", file=link)\n                WorkerThread.add(current_user.name, TaskUpload(upload_text, escape(title)))\n\n                if len(request.files.getlist(\"btn-upload\")) < 2:\n                    if current_user.role_edit() or current_user.role_admin():\n                        resp = {\"location\": url_for('edit-book.edit_book', book_id=book_id)}\n                        return Response(json.dumps(resp), mimetype='application/json')\n                    else:\n                        resp = {\"location\": url_for('web.show_book', book_id=book_id)}\n                        return Response(json.dumps(resp), mimetype='application/json')\n            except (OperationalError, IntegrityError) as e:\n                calibre_db.session.rollback()\n                log.error_or_exception(\"Database error: {}\".format(e))\n                flash(_(u\"Database error: %(error)s.\", error=e.orig), category=\"error\")\n        return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n\n\n@EditBook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])\n@login_required_if_no_ano\n@edit_required\ndef convert_bookformat(book_id):\n    # check to see if we have form fields to work with -  if not send user back\n    book_format_from = request.form.get('book_format_from', None)\n    book_format_to = request.form.get('book_format_to', None)\n\n    if (book_format_from is None) or (book_format_to is None):\n        flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")\n        return redirect(url_for('edit-book.edit_book', book_id=book_id))\n\n    log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)\n    rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),\n                                     book_format_to.upper(), current_user.name)\n\n    if rtn is None:\n        flash(_(u\"Book successfully queued for converting to %(book_format)s\",\n                book_format=book_format_to),\n              category=\"success\")\n    else:\n        flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")\n    return redirect(url_for('edit-book.edit_book', book_id=book_id))\n\n\n@EditBook.route(\"/ajax/getcustomenum/<int:c_id>\")\n@login_required\ndef table_get_custom_enum(c_id):\n    ret = list()\n    cc = (calibre_db.session.query(db.CustomColumns)\n          .filter(db.CustomColumns.id == c_id)\n          .filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).one_or_none())\n    ret.append({'value': \"\", 'text': \"\"})\n    for idx, en in enumerate(cc.get_display_dict()['enum_values']):\n        ret.append({'value': en, 'text': en})\n    return json.dumps(ret)\n\n\n@EditBook.route(\"/ajax/editbooks/<param>\", methods=['POST'])\n@login_required_if_no_ano\n@edit_required\ndef edit_list_book(param):\n    vals = request.form.to_dict()\n    book = calibre_db.get_book(vals['pk'])\n    sort_param = \"\"\n    # ret = \"\"\n    try:\n        if param == 'series_index':\n            edit_book_series_index(vals['value'], book)\n            ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')\n        elif param == 'tags':\n            edit_book_tags(vals['value'], book)\n            ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),\n                           mimetype='application/json')\n        elif param == 'series':\n            edit_book_series(vals['value'], book)\n            ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),\n                           mimetype='application/json')\n        elif param == 'publishers':\n            edit_book_publisher(vals['value'], book)\n            ret = Response(json.dumps({'success': True,\n                                       'newValue': ', '.join([publisher.name for publisher in book.publishers])}),\n                           mimetype='application/json')\n        elif param == 'languages':\n            invalid = list()\n            edit_book_languages(vals['value'], book, invalid=invalid)\n            if invalid:\n                ret = Response(json.dumps({'success': False,\n                                           'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),\n                               mimetype='application/json')\n            else:\n                lang_names = list()\n                for lang in book.languages:\n                    lang_names.append(isoLanguages.get_language_name(get_locale(), lang.lang_code))\n                ret = Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),\n                               mimetype='application/json')\n        elif param == 'author_sort':\n            book.author_sort = vals['value']\n            ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),\n                           mimetype='application/json')\n        elif param == 'title':\n            sort_param = book.sort\n            handle_title_on_edit(book, vals.get('value', \"\"))\n            helper.update_dir_structure(book.id, config.config_calibre_dir)\n            ret = Response(json.dumps({'success': True, 'newValue':  book.title}),\n                           mimetype='application/json')\n        elif param == 'sort':\n            book.sort = vals['value']\n            ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),\n                           mimetype='application/json')\n        elif param == 'comments':\n            edit_book_comments(vals['value'], book)\n            ret = Response(json.dumps({'success': True, 'newValue':  book.comments[0].text}),\n                           mimetype='application/json')\n        elif param == 'authors':\n            input_authors, __, renamed = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")\n            helper.update_dir_structure(book.id, config.config_calibre_dir, input_authors[0], renamed_author=renamed)\n            ret = Response(json.dumps({\n                'success': True,\n                'newValue':  ' & '.join([author.replace('|', ',') for author in input_authors])}),\n                mimetype='application/json')\n        elif param == 'is_archived':\n            is_archived = change_archived_books(book.id, vals['value'] == \"True\",\n                                                message=\"Book {} archive bit set to: {}\".format(book.id, vals['value']))\n            if is_archived:\n                kobo_sync_status.remove_synced_book(book.id)\n            return \"\"\n        elif param == 'read_status':\n            ret = helper.edit_book_read_status(book.id, vals['value'] == \"True\")\n            if ret:\n                return ret, 400\n        elif param.startswith(\"custom_column_\"):\n            new_val = dict()\n            new_val[param] = vals['value']\n            edit_single_cc_data(book.id, book, param[14:], new_val)\n            # ToDo: Very hacky find better solution\n            if vals['value'] in [\"True\", \"False\"]:\n                ret = \"\"\n            else:\n                ret = Response(json.dumps({'success': True, 'newValue': vals['value']}),\n                               mimetype='application/json')\n        else:\n            return _(\"Parameter not found\"), 400\n        book.last_modified = datetime.utcnow()\n\n        calibre_db.session.commit()\n        # revert change for sort if automatic fields link is deactivated\n        if param == 'title' and vals.get('checkT') == \"false\":\n            book.sort = sort_param\n            calibre_db.session.commit()\n    except (OperationalError, IntegrityError) as e:\n        calibre_db.session.rollback()\n        log.error_or_exception(\"Database error: {}\".format(e))\n        ret = Response(json.dumps({'success': False,\n                                   'msg': 'Database error: {}'.format(e.orig)}),\n                       mimetype='application/json')\n    return ret\n\n\n@EditBook.route(\"/ajax/sort_value/<field>/<int:bookid>\")\n@login_required\ndef get_sorted_entry(field, bookid):\n    if field in ['title', 'authors', 'sort', 'author_sort']:\n        book = calibre_db.get_filtered_book(bookid)\n        if book:\n            if field == 'title':\n                return json.dumps({'sort': book.sort})\n            elif field == 'authors':\n                return json.dumps({'author_sort': book.author_sort})\n            if field == 'sort':\n                return json.dumps({'sort': book.title})\n            if field == 'author_sort':\n                return json.dumps({'author_sort': book.author})\n    return \"\"\n\n\n@EditBook.route(\"/ajax/simulatemerge\", methods=['POST'])\n@login_required\n@edit_required\ndef simulate_merge_list_book():\n    vals = request.get_json().get('Merge_books')\n    if vals:\n        to_book = calibre_db.get_book(vals[0]).title\n        vals.pop(0)\n        if to_book:\n            from_book = []\n            for book_id in vals:\n                from_book.append(calibre_db.get_book(book_id).title)\n            return json.dumps({'to': to_book, 'from': from_book})\n    return \"\"\n\n\n@EditBook.route(\"/ajax/mergebooks\", methods=['POST'])\n@login_required\n@edit_required\ndef merge_list_book():\n    vals = request.get_json().get('Merge_books')\n    to_file = list()\n    if vals:\n        # load all formats from target book\n        to_book = calibre_db.get_book(vals[0])\n        vals.pop(0)\n        if to_book:\n            for file in to_book.data:\n                to_file.append(file.format)\n            to_name = helper.get_valid_filename(to_book.title,\n                                                chars=96) + ' - ' + helper.get_valid_filename(to_book.authors[0].name,\n                                                                                              chars=96)\n            for book_id in vals:\n                from_book = calibre_db.get_book(book_id)\n                if from_book:\n                    for element in from_book.data:\n                        if element.format not in to_file:\n                            # create new data entry with: book_id, book_format, uncompressed_size, name\n                            filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,\n                                                                         to_book.path,\n                                                                         to_name + \".\" + element.format.lower()))\n                            filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,\n                                                                         from_book.path,\n                                                                         element.name + \".\" + element.format.lower()))\n                            copyfile(filepath_old, filepath_new)\n                            to_book.data.append(db.Data(to_book.id,\n                                                        element.format,\n                                                        element.uncompressed_size,\n                                                        to_name))\n                    delete_book_from_table(from_book.id, \"\", True)\n                    return json.dumps({'success': True})\n    return \"\"\n\n\n@EditBook.route(\"/ajax/xchange\", methods=['POST'])\n@login_required\n@edit_required\ndef table_xchange_author_title():\n    vals = request.get_json().get('xchange')\n    edited_books_id = False\n    if vals:\n        for val in vals:\n            modify_date = False\n            book = calibre_db.get_book(val)\n            authors = book.title\n            book.authors = calibre_db.order_authors([book])\n            author_names = []\n            for authr in book.authors:\n                author_names.append(authr.name.replace('|', ','))\n\n            title_change = handle_title_on_edit(book, \" \".join(author_names))\n            input_authors, authorchange, renamed = handle_author_on_edit(book, authors)\n            if authorchange or title_change:\n                edited_books_id = book.id\n                modify_date = True\n\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n\n            if edited_books_id:\n                helper.update_dir_structure(edited_books_id, config.config_calibre_dir, input_authors[0],\n                                            renamed_author=renamed)\n            if modify_date:\n                book.last_modified = datetime.utcnow()\n            try:\n                calibre_db.session.commit()\n            except (OperationalError, IntegrityError) as e:\n                calibre_db.session.rollback()\n                log.error_or_exception(\"Database error: %s\", e)\n                return json.dumps({'success': False})\n\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n        return json.dumps({'success': True})\n    return \"\"\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018 lemmsh, Kennyl, Kyosfonica, matthazinski\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport zipfile\nfrom lxml import etree\n\nfrom . import isoLanguages, cover\nfrom .helper import split_authors\nfrom .constants import BookMeta\n\n\ndef _extract_cover(zip_file, cover_file, cover_path, tmp_file_name):\n    if cover_file is None:\n        return None\n    else:\n        cf = extension = None\n        zip_cover_path = os.path.join(cover_path, cover_file).replace('\\\\', '/')\n\n        prefix = os.path.splitext(tmp_file_name)[0]\n        tmp_cover_name = prefix + '.' + os.path.basename(zip_cover_path)\n        ext = os.path.splitext(tmp_cover_name)\n        if len(ext) > 1:\n            extension = ext[1].lower()\n        if extension in cover.COVER_EXTENSIONS:\n            cf = zip_file.read(zip_cover_path)\n        return cover.cover_processing(tmp_file_name, cf, extension)\n\n\ndef get_epub_info(tmp_file_path, original_file_name, original_file_extension):\n    ns = {\n        'n': 'urn:oasis:names:tc:opendocument:xmlns:container',\n        'pkg': 'http://www.idpf.org/2007/opf',\n        'dc': 'http://purl.org/dc/elements/1.1/'\n    }\n\n    epub_zip = zipfile.ZipFile(tmp_file_path)\n\n    txt = epub_zip.read('META-INF/container.xml')\n    tree = etree.fromstring(txt)\n    cf_name = tree.xpath('n:rootfiles/n:rootfile/@full-path', namespaces=ns)[0]\n    cf = epub_zip.read(cf_name)\n    tree = etree.fromstring(cf)\n\n    cover_path = os.path.dirname(cf_name)\n\n    p = tree.xpath('/pkg:package/pkg:metadata', namespaces=ns)[0]\n\n    epub_metadata = {}\n\n    for s in ['title', 'description', 'creator', 'language', 'subject']:\n        tmp = p.xpath('dc:%s/text()' % s, namespaces=ns)\n        if len(tmp) > 0:\n            if s == 'creator':\n                epub_metadata[s] = ' & '.join(split_authors(tmp))\n            elif s == 'subject':\n                epub_metadata[s] = ', '.join(tmp)\n            else:\n                epub_metadata[s] = tmp[0]\n        else:\n            epub_metadata[s] = 'Unknown'\n\n    if epub_metadata['subject'] == 'Unknown':\n        epub_metadata['subject'] = ''\n\n    if epub_metadata['description'] == u'Unknown':\n        description = tree.xpath(\"//*[local-name() = 'description']/text()\")\n        if len(description) > 0:\n            epub_metadata['description'] = description\n        else:\n            epub_metadata['description'] = \"\"\n\n    lang = epub_metadata['language'].split('-', 1)[0].lower()\n    epub_metadata['language'] = isoLanguages.get_lang3(lang)\n\n    epub_metadata = parse_epub_series(ns, tree, epub_metadata)\n\n    cover_file = parse_epub_cover(ns, tree, epub_zip, cover_path, tmp_file_path)\n\n    if not epub_metadata['title']:\n        title = original_file_name\n    else:\n        title = epub_metadata['title']\n\n    return BookMeta(\n        file_path=tmp_file_path,\n        extension=original_file_extension,\n        title=title.encode('utf-8').decode('utf-8'),\n        author=epub_metadata['creator'].encode('utf-8').decode('utf-8'),\n        cover=cover_file,\n        description=epub_metadata['description'],\n        tags=epub_metadata['subject'].encode('utf-8').decode('utf-8'),\n        series=epub_metadata['series'].encode('utf-8').decode('utf-8'),\n        series_id=epub_metadata['series_id'].encode('utf-8').decode('utf-8'),\n        languages=epub_metadata['language'],\n        publisher=\"\")\n\n\ndef parse_epub_cover(ns, tree, epub_zip, cover_path, tmp_file_path):\n    cover_section = tree.xpath(\"/pkg:package/pkg:manifest/pkg:item[@id='cover-image']/@href\", namespaces=ns)\n    cover_file = None\n    # if len(cover_section) > 0:\n    for cs in cover_section:\n        cover_file = _extract_cover(epub_zip, cs, cover_path, tmp_file_path)\n        if cover_file:\n            break\n    if not cover_file:\n        meta_cover = tree.xpath(\"/pkg:package/pkg:metadata/pkg:meta[@name='cover']/@content\", namespaces=ns)\n        if len(meta_cover) > 0:\n            cover_section = tree.xpath(\n                \"/pkg:package/pkg:manifest/pkg:item[@id='\"+meta_cover[0]+\"']/@href\", namespaces=ns)\n            if not cover_section:\n                cover_section = tree.xpath(\n                    \"/pkg:package/pkg:manifest/pkg:item[@properties='\" + meta_cover[0] + \"']/@href\", namespaces=ns)\n        else:\n            cover_section = tree.xpath(\"/pkg:package/pkg:guide/pkg:reference/@href\", namespaces=ns)\n        for cs in cover_section:\n            filetype = cs.rsplit('.', 1)[-1]\n            if filetype == \"xhtml\" or filetype == \"html\":  # if cover is (x)html format\n                markup = epub_zip.read(os.path.join(cover_path, cs))\n                markup_tree = etree.fromstring(markup)\n                # no matter xhtml or html with no namespace\n                img_src = markup_tree.xpath(\"//*[local-name() = 'img']/@src\")\n                # Alternative image source\n                if not len(img_src):\n                    img_src = markup_tree.xpath(\"//attribute::*[contains(local-name(), 'href')]\")\n                if len(img_src):\n                    # img_src maybe start with \"../\"\" so fullpath join then relpath to cwd\n                    filename = os.path.relpath(os.path.join(os.path.dirname(os.path.join(cover_path, cover_section[0])),\n                                                            img_src[0]))\n                    cover_file = _extract_cover(epub_zip, filename, \"\", tmp_file_path)\n            else:\n                cover_file = _extract_cover(epub_zip, cs, cover_path, tmp_file_path)\n            if cover_file: break\n    return cover_file\n\n\ndef parse_epub_series(ns, tree, epub_metadata):\n    series = tree.xpath(\"/pkg:package/pkg:metadata/pkg:meta[@name='calibre:series']/@content\", namespaces=ns)\n    if len(series) > 0:\n        epub_metadata['series'] = series[0]\n    else:\n        epub_metadata['series'] = ''\n\n    series_id = tree.xpath(\"/pkg:package/pkg:metadata/pkg:meta[@name='calibre:series_index']/@content\", namespaces=ns)\n    if len(series_id) > 0:\n        epub_metadata['series_id'] = series_id[0]\n    else:\n        epub_metadata['series_id'] = '1'\n    return epub_metadata\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2012-2019 cervinko, idalin, SiphonSquirrel, ouzklcn, akushsky,\n#                            OzzieIsaacs, bodybybuddha, jkrehm, matthazinski, janeczku\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport io\nimport mimetypes\nimport re\nimport shutil\nimport socket\nfrom datetime import datetime, timedelta\nfrom tempfile import gettempdir\nimport requests\nimport unidecode\n\nfrom babel.dates import format_datetime\nfrom babel.units import format_unit\nfrom flask import send_from_directory, make_response, redirect, abort, url_for\nfrom flask_babel import gettext as _\nfrom flask_login import current_user\nfrom sqlalchemy.sql.expression import true, false, and_, text, func\nfrom sqlalchemy.exc import InvalidRequestError, OperationalError\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import generate_password_hash\nfrom markupsafe import escape\nfrom urllib.parse import quote\n\n\ntry:\n    import advocate\n    from advocate.exceptions import UnacceptableAddressException\n    use_advocate = True\nexcept ImportError:\n    use_advocate = False\n    advocate = requests\n    UnacceptableAddressException = MissingSchema = BaseException\n\nfrom . import calibre_db, cli\nfrom .tasks.convert import TaskConvert\nfrom . import logger, config, get_locale, db, ub\nfrom . import gdriveutils as gd\nfrom .constants import STATIC_DIR as _STATIC_DIR\nfrom .subproc_wrapper import process_wait\nfrom .services.worker import WorkerThread, STAT_WAITING, STAT_FAIL, STAT_STARTED, STAT_FINISH_SUCCESS\nfrom .tasks.mail import TaskEmail\n\nlog = logger.create()\n\ntry:\n    from wand.image import Image\n    from wand.exceptions import MissingDelegateError, BlobError\n    use_IM = True\nexcept (ImportError, RuntimeError) as e:\n    log.debug('Cannot import Image, generating covers from non jpg files will not work: %s', e)\n    use_IM = False\n    MissingDelegateError = BaseException\n\n\n# Convert existing book entry to new format\ndef convert_book_format(book_id, calibrepath, old_book_format, new_book_format, user_id, kindle_mail=None):\n    book = calibre_db.get_book(book_id)\n    data = calibre_db.get_book_format(book.id, old_book_format)\n    file_path = os.path.join(calibrepath, book.path, data.name)\n    if not data:\n        error_message = _(u\"%(format)s format not found for book id: %(book)d\", format=old_book_format, book=book_id)\n        log.error(\"convert_book_format: %s\", error_message)\n        return error_message\n    if config.config_use_google_drive:\n        if not gd.getFileFromEbooksFolder(book.path, data.name + \".\" + old_book_format.lower()):\n            error_message = _(u\"%(format)s not found on Google Drive: %(fn)s\",\n                              format=old_book_format, fn=data.name + \".\" + old_book_format.lower())\n            return error_message\n    else:\n        if not os.path.exists(file_path + \".\" + old_book_format.lower()):\n            error_message = _(u\"%(format)s not found: %(fn)s\",\n                              format=old_book_format, fn=data.name + \".\" + old_book_format.lower())\n            return error_message\n    # read settings and append converter task to queue\n    if kindle_mail:\n        settings = config.get_mail_settings()\n        settings['subject'] = _('Send to Kindle')  # pretranslate Subject for e-mail\n        settings['body'] = _(u'This e-mail has been sent via Calibre-Web.')\n    else:\n        settings = dict()\n    link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))  # prevent xss\n    txt = u\"{} -> {}: {}\".format(\n           old_book_format.upper(),\n           new_book_format.upper(),\n           link)\n    settings['old_book_format'] = old_book_format\n    settings['new_book_format'] = new_book_format\n    WorkerThread.add(user_id, TaskConvert(file_path, book.id, txt, settings, kindle_mail, user_id))\n    return None\n\n\ndef send_test_mail(kindle_mail, user_name):\n    WorkerThread.add(user_name, TaskEmail(_(u'Calibre-Web test e-mail'), None, None,\n                     config.get_mail_settings(), kindle_mail, _(u\"Test e-mail\"),\n                                          _(u'This e-mail has been sent via Calibre-Web.')))\n    return\n\n\n# Send registration email or password reset email, depending on parameter resend (False means welcome email)\ndef send_registration_mail(e_mail, user_name, default_password, resend=False):\n    txt = \"Hello %s!\\r\\n\" % user_name\n    if not resend:\n        txt += \"Your new account at Calibre-Web has been created. Thanks for joining us!\\r\\n\"\n    txt += \"Please log in to your account using the following informations:\\r\\n\"\n    txt += \"User name: %s\\r\\n\" % user_name\n    txt += \"Password: %s\\r\\n\" % default_password\n    txt += \"Don't forget to change your password after first login.\\r\\n\"\n    txt += \"Sincerely\\r\\n\\r\\n\"\n    txt += \"Your Calibre-Web team\"\n    WorkerThread.add(None, TaskEmail(\n        subject=_(u'Get Started with Calibre-Web'),\n        filepath=None,\n        attachment=None,\n        settings=config.get_mail_settings(),\n        recipient=e_mail,\n        taskMessage=_(u\"Registration e-mail for user: %(name)s\", name=user_name),\n        text=txt\n    ))\n    return\n\n\ndef check_send_to_kindle_with_converter(formats):\n    bookformats = list()\n    if 'EPUB' in formats and 'MOBI' not in formats:\n        bookformats.append({'format': 'Mobi',\n                            'convert': 1,\n                            'text': _('Convert %(orig)s to %(format)s and send to Kindle',\n                                      orig='Epub',\n                                      format='Mobi')})\n    if 'AZW3' in formats and 'MOBI' not in formats:\n        bookformats.append({'format': 'Mobi',\n                            'convert': 2,\n                            'text': _('Convert %(orig)s to %(format)s and send to Kindle',\n                                      orig='Azw3',\n                                      format='Mobi')})\n    return bookformats\n\n\ndef check_send_to_kindle(entry):\n    \"\"\"\n        returns all available book formats for sending to Kindle\n    \"\"\"\n    formats = list()\n    bookformats = list()\n    if len(entry.data):\n        for ele in iter(entry.data):\n            if ele.uncompressed_size < config.mail_size:\n                formats.append(ele.format)\n        if 'MOBI' in formats:\n            bookformats.append({'format': 'Mobi',\n                                'convert': 0,\n                                'text': _('Send %(format)s to Kindle', format='Mobi')})\n        if 'PDF' in formats:\n            bookformats.append({'format': 'Pdf',\n                                'convert': 0,\n                                'text': _('Send %(format)s to Kindle', format='Pdf')})\n        if 'AZW' in formats:\n            bookformats.append({'format': 'Azw',\n                                'convert': 0,\n                                'text': _('Send %(format)s to Kindle', format='Azw')})\n        if config.config_converterpath:\n            bookformats.extend(check_send_to_kindle_with_converter(formats))\n        return bookformats\n    else:\n        log.error(u'Cannot find book entry %d', entry.id)\n        return None\n\n\n# Check if a reader is existing for any of the book formats, if not, return empty list, otherwise return\n# list with supported formats\ndef check_read_formats(entry):\n    extensions_reader = {'TXT', 'PDF', 'EPUB', 'CBZ', 'CBT', 'CBR', 'DJVU'}\n    bookformats = list()\n    if len(entry.data):\n        for ele in iter(entry.data):\n            if ele.format.upper() in extensions_reader:\n                bookformats.append(ele.format.lower())\n    return bookformats\n\n\n# Files are processed in the following order/priority:\n# 1: If Mobi file is existing, it's directly send to kindle email,\n# 2: If Epub file is existing, it's converted and send to kindle email,\n# 3: If Pdf file is existing, it's directly send to kindle email\ndef send_mail(book_id, book_format, convert, kindle_mail, calibrepath, user_id):\n    \"\"\"Send email with attachments\"\"\"\n    book = calibre_db.get_book(book_id)\n\n    if convert == 1:\n        # returns None if success, otherwise errormessage\n        return convert_book_format(book_id, calibrepath, u'epub', book_format.lower(), user_id, kindle_mail)\n    if convert == 2:\n        # returns None if success, otherwise errormessage\n        return convert_book_format(book_id, calibrepath, u'azw3', book_format.lower(), user_id, kindle_mail)\n\n    for entry in iter(book.data):\n        if entry.format.upper() == book_format.upper():\n            converted_file_name = entry.name + '.' + book_format.lower()\n            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(book.title))\n            email_text = _(u\"%(book)s send to Kindle\", book=link)\n            WorkerThread.add(user_id, TaskEmail(_(u\"Send to Kindle\"), book.path, converted_file_name,\n                             config.get_mail_settings(), kindle_mail,\n                             email_text, _(u'This e-mail has been sent via Calibre-Web.')))\n            return\n    return _(u\"The requested file could not be read. Maybe wrong permissions?\")\n\n\ndef get_valid_filename(value, replace_whitespace=True, chars=128):\n    \"\"\"\n    Returns the given string converted to a string that can be used for a clean\n    filename. Limits num characters to 128 max.\n    \"\"\"\n    if value[-1:] == u'.':\n        value = value[:-1]+u'_'\n    value = value.replace(\"/\", \"_\").replace(\":\", \"_\").strip('\\0')\n    if config.config_unicode_filename:\n        value = (unidecode.unidecode(value))\n    if replace_whitespace:\n        #  *+:\\\"/<>? are replaced by _\n        value = re.sub(r'[*+:\\\\\\\"/<>?]+', u'_', value, flags=re.U)\n        # pipe has to be replaced with comma\n        value = re.sub(r'[|]+', u',', value, flags=re.U)\n    value = value[:chars].strip()\n    if not value:\n        raise ValueError(\"Filename cannot be empty\")\n    return value\n\n\ndef split_authors(values):\n    authors_list = []\n    for value in values:\n        authors = re.split('[&;]', value)\n        for author in authors:\n            commas = author.count(',')\n            if commas == 1:\n                author_split = author.split(',')\n                authors_list.append(author_split[1].strip() + ' ' + author_split[0].strip())\n            elif commas > 1:\n                authors_list.extend([x.strip() for x in author.split(',')])\n            else:\n                authors_list.append(author.strip())\n    return authors_list\n\n\ndef get_sorted_author(value):\n    value2 = None\n    try:\n        if ',' not in value:\n            regexes = [r\"^(JR|SR)\\.?$\", r\"^I{1,3}\\.?$\", r\"^IV\\.?$\"]\n            combined = \"(\" + \")|(\".join(regexes) + \")\"\n            value = value.split(\" \")\n            if re.match(combined, value[-1].upper()):\n                if len(value) > 1:\n                    value2 = value[-2] + \", \" + \" \".join(value[:-2]) + \" \" + value[-1]\n                else:\n                    value2 = value[0]\n            elif len(value) == 1:\n                value2 = value[0]\n            else:\n                value2 = value[-1] + \", \" + \" \".join(value[:-1])\n        else:\n            value2 = value\n    except Exception as ex:\n        log.error(\"Sorting author %s failed: %s\", value, ex)\n        if isinstance(list, value2):\n            value2 = value[0]\n        else:\n            value2 = value\n    return value2\n\n\ndef edit_book_read_status(book_id, read_status=None):\n    if not config.config_read_column:\n        book = ub.session.query(ub.ReadBook).filter(and_(ub.ReadBook.user_id == int(current_user.id),\n                                                         ub.ReadBook.book_id == book_id)).first()\n        if book:\n            if read_status is None:\n                if book.read_status == ub.ReadBook.STATUS_FINISHED:\n                    book.read_status = ub.ReadBook.STATUS_UNREAD\n                else:\n                    book.read_status = ub.ReadBook.STATUS_FINISHED\n            else:\n                book.read_status = ub.ReadBook.STATUS_FINISHED if read_status else ub.ReadBook.STATUS_UNREAD\n        else:\n            read_book = ub.ReadBook(user_id=current_user.id, book_id=book_id)\n            read_book.read_status = ub.ReadBook.STATUS_FINISHED\n            book = read_book\n        if not book.kobo_reading_state:\n            kobo_reading_state = ub.KoboReadingState(user_id=current_user.id, book_id=book_id)\n            kobo_reading_state.current_bookmark = ub.KoboBookmark()\n            kobo_reading_state.statistics = ub.KoboStatistics()\n            book.kobo_reading_state = kobo_reading_state\n        ub.session.merge(book)\n        ub.session_commit(\"Book {} readbit toggled\".format(book_id))\n    else:\n        try:\n            calibre_db.update_title_sort(config)\n            book = calibre_db.get_filtered_book(book_id)\n            read_status = getattr(book, 'custom_column_' + str(config.config_read_column))\n            if len(read_status):\n                if read_status is None:\n                    read_status[0].value = not read_status[0].value\n                else:\n                    read_status[0].value = read_status is True\n                calibre_db.session.commit()\n            else:\n                cc_class = db.cc_classes[config.config_read_column]\n                new_cc = cc_class(value=read_status or 1, book=book_id)\n                calibre_db.session.add(new_cc)\n                calibre_db.session.commit()\n        except (KeyError, AttributeError):\n            log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n            return \"Custom Column No.{} is not existing in calibre database\".format(config.config_read_column)\n        except (OperationalError, InvalidRequestError) as ex:\n            calibre_db.session.rollback()\n            log.error(u\"Read status could not set: {}\".format(ex))\n            return _(\"Read status could not set: {}\".format(ex.orig))\n    return \"\"\n\n\n# Deletes a book fro the local filestorage, returns True if deleting is successfull, otherwise false\ndef delete_book_file(book, calibrepath, book_format=None):\n    # check that path is 2 elements deep, check that target path has no subfolders\n    if book.path.count('/') == 1:\n        path = os.path.join(calibrepath, book.path)\n        if book_format:\n            for file in os.listdir(path):\n                if file.upper().endswith(\".\"+book_format):\n                    os.remove(os.path.join(path, file))\n            return True, None\n        else:\n            if os.path.isdir(path):\n                try:\n                    for root, folders, files in os.walk(path):\n                        for f in files:\n                            os.unlink(os.path.join(root, f))\n                        if len(folders):\n                            log.warning(\"Deleting book {} failed, path {} has subfolders: {}\".format(book.id,\n                                        book.path, folders))\n                            return True, _(\"Deleting bookfolder for book %(id)s failed, path has subfolders: %(path)s\",\n                                           id=book.id,\n                                           path=book.path)\n                    shutil.rmtree(path)\n                except (IOError, OSError) as ex:\n                    log.error(\"Deleting book %s failed: %s\", book.id, ex)\n                    return False, _(\"Deleting book %(id)s failed: %(message)s\", id=book.id, message=ex)\n                authorpath = os.path.join(calibrepath, os.path.split(book.path)[0])\n                if not os.listdir(authorpath):\n                    try:\n                        shutil.rmtree(authorpath)\n                    except (IOError, OSError) as ex:\n                        log.error(\"Deleting authorpath for book %s failed: %s\", book.id, ex)\n                return True, None\n\n    log.error(\"Deleting book %s from database only, book path in database not valid: %s\",\n              book.id, book.path)\n    return True, _(\"Deleting book %(id)s from database only, book path in database not valid: %(path)s\",\n                   id=book.id,\n                   path=book.path)\n\n\ndef clean_author_database(renamed_author, calibre_path=\"\", local_book=None, gdrive=None):\n    valid_filename_authors = [get_valid_filename(r, chars=96) for r in renamed_author]\n    for r in renamed_author:\n        if local_book:\n            all_books = [local_book]\n        else:\n            all_books = calibre_db.session.query(db.Books) \\\n                .filter(db.Books.authors.any(db.Authors.name == r)).all()\n        for book in all_books:\n            book_author_path = book.path.split('/')[0]\n            if book_author_path in valid_filename_authors or local_book:\n                new_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == r).first()\n                all_new_authordir = get_valid_filename(new_author.name, chars=96)\n                all_titledir = book.path.split('/')[1]\n                all_new_path = os.path.join(calibre_path, all_new_authordir, all_titledir)\n                all_new_name = get_valid_filename(book.title, chars=42) + ' - ' \\\n                    + get_valid_filename(new_author.name, chars=42)\n                # change location in database to new author/title path\n                book.path = os.path.join(all_new_authordir, all_titledir).replace('\\\\', '/')\n                for file_format in book.data:\n                    if not gdrive:\n                        shutil.move(os.path.normcase(os.path.join(all_new_path,\n                                                                  file_format.name + '.' + file_format.format.lower())),\n                                    os.path.normcase(os.path.join(all_new_path,\n                                                                  all_new_name + '.' + file_format.format.lower())))\n                    else:\n                        g_file = gd.getFileFromEbooksFolder(all_new_path,\n                                                            file_format.name + '.' + file_format.format.lower())\n                        if g_file:\n                            gd.moveGdriveFileRemote(g_file, all_new_name + u'.' + file_format.format.lower())\n                            gd.updateDatabaseOnEdit(g_file['id'], all_new_name + u'.' + file_format.format.lower())\n                        else:\n                            log.error(\"File {} not found on gdrive\"\n                                      .format(all_new_path, file_format.name + '.' + file_format.format.lower()))\n                    file_format.name = all_new_name\n\n\ndef rename_all_authors(first_author, renamed_author, calibre_path=\"\", localbook=None, gdrive=False):\n    # Create new_author_dir from parameter or from database\n    # Create new title_dir from database and add id\n    if first_author:\n        new_authordir = get_valid_filename(first_author, chars=96)\n        for r in renamed_author:\n            new_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == r).first()\n            old_author_dir = get_valid_filename(r, chars=96)\n            new_author_rename_dir = get_valid_filename(new_author.name, chars=96)\n            if gdrive:\n                g_file = gd.getFileFromEbooksFolder(None, old_author_dir)\n                if g_file:\n                    gd.moveGdriveFolderRemote(g_file, new_author_rename_dir)\n            else:\n                if os.path.isdir(os.path.join(calibre_path, old_author_dir)):\n                    try:\n                        old_author_path = os.path.join(calibre_path, old_author_dir)\n                        new_author_path = os.path.join(calibre_path, new_author_rename_dir)\n                        shutil.move(os.path.normcase(old_author_path), os.path.normcase(new_author_path))\n                    except OSError as ex:\n                        log.error(\"Rename author from: %s to %s: %s\", old_author_path, new_author_path, ex)\n                        log.debug(ex, exc_info=True)\n                        return _(\"Rename author from: '%(src)s' to '%(dest)s' failed with error: %(error)s\",\n                                 src=old_author_path, dest=new_author_path, error=str(ex))\n    else:\n        new_authordir = get_valid_filename(localbook.authors[0].name, chars=96)\n    return new_authordir\n\n\n# Moves files in file storage during author/title rename, or from temp dir to file storage\ndef update_dir_structure_file(book_id, calibre_path, first_author, original_filepath, db_filename, renamed_author):\n    # get book database entry from id, if original path overwrite source with original_filepath\n    localbook = calibre_db.get_book(book_id)\n    if original_filepath:\n        path = original_filepath\n    else:\n        path = os.path.join(calibre_path, localbook.path)\n\n    # Create (current) authordir and titledir from database\n    authordir = localbook.path.split('/')[0]\n    titledir = localbook.path.split('/')[1]\n\n    # Create new_authordir from parameter or from database\n    # Create new titledir from database and add id\n    new_authordir = rename_all_authors(first_author, renamed_author, calibre_path, localbook)\n    if first_author:\n        if first_author.lower() in [r.lower() for r in renamed_author]:\n            if os.path.isdir(os.path.join(calibre_path, new_authordir)):\n                path = os.path.join(calibre_path, new_authordir, titledir)\n\n    new_titledir = get_valid_filename(localbook.title, chars=96) + \" (\" + str(book_id) + \")\"\n\n    if titledir != new_titledir or authordir != new_authordir or original_filepath:\n        error = move_files_on_change(calibre_path,\n                                     new_authordir,\n                                     new_titledir,\n                                     localbook,\n                                     db_filename,\n                                     original_filepath,\n                                     path)\n        if error:\n            return error\n\n    # Rename all files from old names to new names\n    return rename_files_on_change(first_author, renamed_author, localbook, original_filepath, path, calibre_path)\n\n\ndef upload_new_file_gdrive(book_id, first_author, renamed_author, title, title_dir, original_filepath, filename_ext):\n    book = calibre_db.get_book(book_id)\n    file_name = get_valid_filename(title, chars=42) + ' - ' + \\\n        get_valid_filename(first_author, chars=42) + filename_ext\n    rename_all_authors(first_author, renamed_author, gdrive=True)\n    gdrive_path = os.path.join(get_valid_filename(first_author, chars=96),\n                               title_dir + \" (\" + str(book_id) + \")\")\n    book.path = gdrive_path.replace(\"\\\\\", \"/\")\n    gd.uploadFileToEbooksFolder(os.path.join(gdrive_path, file_name).replace(\"\\\\\", \"/\"), original_filepath)\n    return rename_files_on_change(first_author, renamed_author, localbook=book, gdrive=True)\n\n\ndef update_dir_structure_gdrive(book_id, first_author, renamed_author):\n    book = calibre_db.get_book(book_id)\n\n    authordir = book.path.split('/')[0]\n    titledir = book.path.split('/')[1]\n    new_authordir = rename_all_authors(first_author, renamed_author, gdrive=True)\n    new_titledir = get_valid_filename(book.title, chars=96) + u\" (\" + str(book_id) + u\")\"\n\n    if titledir != new_titledir:\n        g_file = gd.getFileFromEbooksFolder(os.path.dirname(book.path), titledir)\n        if g_file:\n            gd.moveGdriveFileRemote(g_file, new_titledir)\n            book.path = book.path.split('/')[0] + u'/' + new_titledir\n            gd.updateDatabaseOnEdit(g_file['id'], book.path)     # only child folder affected\n        else:\n            return _(u'File %(file)s not found on Google Drive', file=book.path)  # file not found\n\n    if authordir != new_authordir and authordir not in renamed_author:\n        g_file = gd.getFileFromEbooksFolder(os.path.dirname(book.path), new_titledir)\n        if g_file:\n            gd.moveGdriveFolderRemote(g_file, new_authordir)\n            book.path = new_authordir + u'/' + book.path.split('/')[1]\n            gd.updateDatabaseOnEdit(g_file['id'], book.path)\n        else:\n            return _(u'File %(file)s not found on Google Drive', file=authordir)  # file not found\n\n    # change location in database to new author/title path\n    book.path = os.path.join(new_authordir, new_titledir).replace('\\\\', '/')\n    return rename_files_on_change(first_author, renamed_author, book, gdrive=True)\n\n\ndef move_files_on_change(calibre_path, new_authordir, new_titledir, localbook, db_filename, original_filepath, path):\n    new_path = os.path.join(calibre_path, new_authordir, new_titledir)\n    new_name = get_valid_filename(localbook.title, chars=96) + ' - ' + new_authordir\n    try:\n        if original_filepath:\n            if not os.path.isdir(new_path):\n                os.makedirs(new_path)\n            shutil.move(os.path.normcase(original_filepath), os.path.normcase(os.path.join(new_path, db_filename)))\n            log.debug(\"Moving title: %s to %s/%s\", original_filepath, new_path, new_name)\n        else:\n            # Check new path is not valid path\n            if not os.path.exists(new_path):\n                # move original path to new path\n                log.debug(\"Moving title: %s to %s\", path, new_path)\n                shutil.move(os.path.normcase(path), os.path.normcase(new_path))\n            else:  # path is valid copy only files to new location (merge)\n                log.info(\"Moving title: %s into existing: %s\", path, new_path)\n                # Take all files and subfolder from old path (strange command)\n                for dir_name, __, file_list in os.walk(path):\n                    for file in file_list:\n                        shutil.move(os.path.normcase(os.path.join(dir_name, file)),\n                                    os.path.normcase(os.path.join(new_path + dir_name[len(path):], file)))\n        # change location in database to new author/title path\n        localbook.path = os.path.join(new_authordir, new_titledir).replace('\\\\', '/')\n    except OSError as ex:\n        log.error(\"Rename title from: %s to %s: %s\", path, new_path, ex)\n        log.debug(ex, exc_info=True)\n        return _(\"Rename title from: '%(src)s' to '%(dest)s' failed with error: %(error)s\",\n                 src=path, dest=new_path, error=str(ex))\n    return False\n\n\ndef rename_files_on_change(first_author,\n                           renamed_author,\n                           localbook,\n                           orignal_filepath=\"\",\n                           path=\"\",\n                           calibre_path=\"\",\n                           gdrive=False):\n    # Rename all files from old names to new names\n    try:\n        clean_author_database(renamed_author, calibre_path, gdrive=gdrive)\n        if first_author and first_author not in renamed_author:\n            clean_author_database([first_author], calibre_path, localbook, gdrive)\n        if not gdrive and not renamed_author and not orignal_filepath and len(os.listdir(os.path.dirname(path))) == 0:\n            shutil.rmtree(os.path.dirname(path))\n    except (OSError, FileNotFoundError) as ex:\n        log.error(\"Error in rename file in path %s\", ex)\n        log.debug(ex, exc_info=True)\n        return _(\"Error in rename file in path: %(error)s\", error=str(ex))\n    return False\n\n\ndef delete_book_gdrive(book, book_format):\n    error = None\n    if book_format:\n        name = ''\n        for entry in book.data:\n            if entry.format.upper() == book_format:\n                name = entry.name + '.' + book_format\n        g_file = gd.getFileFromEbooksFolder(book.path, name)\n    else:\n        g_file = gd.getFileFromEbooksFolder(os.path.dirname(book.path), book.path.split('/')[1])\n    if g_file:\n        gd.deleteDatabaseEntry(g_file['id'])\n        g_file.Trash()\n    else:\n        error = _(u'Book path %(path)s not found on Google Drive', path=book.path)  # file not found\n\n    return error is None, error\n\n\ndef reset_password(user_id):\n    existing_user = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n    if not existing_user:\n        return 0, None\n    if not config.get_mail_server_configured():\n        return 2, None\n    try:\n        password = generate_random_password()\n        existing_user.password = generate_password_hash(password)\n        ub.session.commit()\n        send_registration_mail(existing_user.email, existing_user.name, password, True)\n        return 1, existing_user.name\n    except Exception:\n        ub.session.rollback()\n        return 0, None\n\n\ndef generate_random_password():\n    s = \"abcdefghijklmnopqrstuvwxyz01234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%&*()?\"\n    passlen = 8\n    return \"\".join(s[c % len(s)] for c in os.urandom(passlen))\n\n\ndef uniq(inpt):\n    output = []\n    inpt = [\" \".join(inp.split()) for inp in inpt]\n    for x in inpt:\n        if x not in output:\n            output.append(x)\n    return output\n\n\ndef check_email(email):\n    email = valid_email(email)\n    if ub.session.query(ub.User).filter(func.lower(ub.User.email) == email.lower()).first():\n        log.error(u\"Found an existing account for this e-mail address\")\n        raise Exception(_(u\"Found an existing account for this e-mail address\"))\n    return email\n\n\ndef check_username(username):\n    username = username.strip()\n    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).scalar():\n        log.error(u\"This username is already taken\")\n        raise Exception(_(u\"This username is already taken\"))\n    return username\n\n\ndef valid_email(email):\n    email = email.strip()\n    # Regex according to https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#validation\n    if not re.search(r\"^[\\w.!#$%&'*+\\\\/=?^_`{|}~-]+@[\\w](?:[\\w-]{0,61}[\\w])?(?:\\.[\\w](?:[\\w-]{0,61}[\\w])?)*$\",\n                     email):\n        log.error(u\"Invalid e-mail address format\")\n        raise Exception(_(u\"Invalid e-mail address format\"))\n    return email\n\n# ################################# External interface #################################\n\n\ndef update_dir_structure(book_id,\n                         calibre_path,\n                         first_author=None,     # change author of book to this author\n                         original_filepath=None,\n                         db_filename=None,\n                         renamed_author=None):\n    renamed_author = renamed_author or []\n    if config.config_use_google_drive:\n        return update_dir_structure_gdrive(book_id, first_author, renamed_author)\n    else:\n        return update_dir_structure_file(book_id,\n                                         calibre_path,\n                                         first_author,\n                                         original_filepath,\n                                         db_filename, renamed_author)\n\n\ndef delete_book(book, calibrepath, book_format):\n    if config.config_use_google_drive:\n        return delete_book_gdrive(book, book_format)\n    else:\n        return delete_book_file(book, calibrepath, book_format)\n\n\ndef get_cover_on_failure(use_generic_cover):\n    if use_generic_cover:\n        return send_from_directory(_STATIC_DIR, \"generic_cover.jpg\")\n    else:\n        return None\n\n\ndef get_book_cover(book_id):\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    return get_book_cover_internal(book, use_generic_cover_on_failure=True)\n\n\ndef get_book_cover_with_uuid(book_uuid,\n                             use_generic_cover_on_failure=True):\n    book = calibre_db.get_book_by_uuid(book_uuid)\n    return get_book_cover_internal(book, use_generic_cover_on_failure)\n\n\ndef get_book_cover_internal(book, use_generic_cover_on_failure):\n    if book and book.has_cover:\n        if config.config_use_google_drive:\n            try:\n                if not gd.is_gdrive_ready():\n                    return get_cover_on_failure(use_generic_cover_on_failure)\n                path = gd.get_cover_via_gdrive(book.path)\n                if path:\n                    return redirect(path)\n                else:\n                    log.error('%s/cover.jpg not found on Google Drive', book.path)\n                    return get_cover_on_failure(use_generic_cover_on_failure)\n            except Exception as ex:\n                log.error_or_exception(ex)\n                return get_cover_on_failure(use_generic_cover_on_failure)\n        else:\n            cover_file_path = os.path.join(config.config_calibre_dir, book.path)\n            if os.path.isfile(os.path.join(cover_file_path, \"cover.jpg\")):\n                return send_from_directory(cover_file_path, \"cover.jpg\")\n            else:\n                return get_cover_on_failure(use_generic_cover_on_failure)\n    else:\n        return get_cover_on_failure(use_generic_cover_on_failure)\n\n\n# saves book cover from url\ndef save_cover_from_url(url, book_path):\n    try:\n        if cli.allow_localhost:\n            img = requests.get(url, timeout=(10, 200), allow_redirects=False)  # ToDo: Error Handling\n        elif use_advocate:\n            img = advocate.get(url, timeout=(10, 200), allow_redirects=False)      # ToDo: Error Handling\n        else:\n            log.error(\"python modul advocate is not installed but is needed\")\n            return False, _(\"Python modul 'advocate' is not installed but is needed for cover downloads\")\n        img.raise_for_status()\n        return save_cover(img, book_path)\n    except (socket.gaierror,\n            requests.exceptions.HTTPError,\n            requests.exceptions.ConnectionError,\n            requests.exceptions.Timeout) as ex:\n        log.info(u'Cover Download Error %s', ex)\n        return False, _(\"Error Downloading Cover\")\n    except MissingDelegateError as ex:\n        log.info(u'File Format Error %s', ex)\n        return False, _(\"Cover Format Error\")\n    except UnacceptableAddressException:\n        log.error(\"Localhost was accessed for cover upload\")\n        return False, _(\"You are not allowed to access localhost for cover uploads\")\n\n\ndef save_cover_from_filestorage(filepath, saved_filename, img):\n    # check if file path exists, otherwise create it, copy file to calibre path and delete temp file\n    if not os.path.exists(filepath):\n        try:\n            os.makedirs(filepath)\n        except OSError:\n            log.error(u\"Failed to create path for cover\")\n            return False, _(u\"Failed to create path for cover\")\n    try:\n        # upload of jgp file without wand\n        if isinstance(img, requests.Response):\n            with open(os.path.join(filepath, saved_filename), 'wb') as f:\n                f.write(img.content)\n        else:\n            if hasattr(img, \"metadata\"):\n                # upload of jpg/png... via url\n                img.save(filename=os.path.join(filepath, saved_filename))\n                img.close()\n            else:\n                # upload of jpg/png... from hdd\n                img.save(os.path.join(filepath, saved_filename))\n    except (IOError, OSError):\n        log.error(u\"Cover-file is not a valid image file, or could not be stored\")\n        return False, _(u\"Cover-file is not a valid image file, or could not be stored\")\n    return True, None\n\n\n# saves book cover to gdrive or locally\ndef save_cover(img, book_path):\n    content_type = img.headers.get('content-type')\n\n    if use_IM:\n        if content_type not in ('image/jpeg', 'image/png', 'image/webp', 'image/bmp'):\n            log.error(\"Only jpg/jpeg/png/webp/bmp files are supported as coverfile\")\n            return False, _(\"Only jpg/jpeg/png/webp/bmp files are supported as coverfile\")\n        # convert to jpg because calibre only supports jpg\n        if content_type != 'image/jpg':\n            try:\n                if hasattr(img, 'stream'):\n                    imgc = Image(blob=img.stream)\n                else:\n                    imgc = Image(blob=io.BytesIO(img.content))\n                imgc.format = 'jpeg'\n                imgc.transform_colorspace(\"rgb\")\n                img = imgc\n            except (BlobError, MissingDelegateError):\n                log.error(\"Invalid cover file content\")\n                return False, _(\"Invalid cover file content\")\n    else:\n        if content_type not in 'image/jpeg':\n            log.error(\"Only jpg/jpeg files are supported as coverfile\")\n            return False, _(\"Only jpg/jpeg files are supported as coverfile\")\n\n    if config.config_use_google_drive:\n        tmp_dir = os.path.join(gettempdir(), 'calibre_web')\n\n        if not os.path.isdir(tmp_dir):\n            os.mkdir(tmp_dir)\n        ret, message = save_cover_from_filestorage(tmp_dir, \"uploaded_cover.jpg\", img)\n        if ret is True:\n            gd.uploadFileToEbooksFolder(os.path.join(book_path, 'cover.jpg').replace(\"\\\\\", \"/\"),\n                                        os.path.join(tmp_dir, \"uploaded_cover.jpg\"))\n            log.info(\"Cover is saved on Google Drive\")\n            return True, None\n        else:\n            return False, message\n    else:\n        return save_cover_from_filestorage(os.path.join(config.config_calibre_dir, book_path), \"cover.jpg\", img)\n\n\ndef do_download_file(book, book_format, client, data, headers):\n    if config.config_use_google_drive:\n        # startTime = time.time()\n        df = gd.getFileFromEbooksFolder(book.path, data.name + \".\" + book_format)\n        # log.debug('%s', time.time() - startTime)\n        if df:\n            return gd.do_gdrive_download(df, headers)\n        else:\n            abort(404)\n    else:\n        filename = os.path.join(config.config_calibre_dir, book.path)\n        if not os.path.isfile(os.path.join(filename, data.name + \".\" + book_format)):\n            # ToDo: improve error handling\n            log.error('File not found: %s', os.path.join(filename, data.name + \".\" + book_format))\n\n        if client == \"kobo\" and book_format == \"kepub\":\n            headers[\"Content-Disposition\"] = headers[\"Content-Disposition\"].replace(\".kepub\", \".kepub.epub\")\n\n        response = make_response(send_from_directory(filename, data.name + \".\" + book_format))\n        # ToDo Check headers parameter\n        for element in headers:\n            response.headers[element[0]] = element[1]\n        log.info('Downloading file: {}'.format(os.path.join(filename, data.name + \".\" + book_format)))\n        return response\n\n##################################\n\n\ndef check_unrar(unrar_location):\n    if not unrar_location:\n        return\n\n    if not os.path.exists(unrar_location):\n        return _('Unrar binary file not found')\n\n    try:\n        unrar_location = [unrar_location]\n        value = process_wait(unrar_location, pattern='UNRAR (.*) freeware')\n        if value:\n            version = value.group(1)\n            log.debug(\"unrar version %s\", version)\n\n    except (OSError, UnicodeDecodeError) as err:\n        log.error_or_exception(err)\n        return _('Error excecuting UnRar')\n\n\ndef json_serial(obj):\n    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"\n\n    if isinstance(obj, datetime):\n        return obj.isoformat()\n    if isinstance(obj, timedelta):\n        return {\n            '__type__': 'timedelta',\n            'days': obj.days,\n            'seconds': obj.seconds,\n            'microseconds': obj.microseconds,\n        }\n    raise TypeError(\"Type %s not serializable\" % type(obj))\n\n\n# helper function for displaying the runtime of tasks\ndef format_runtime(runtime):\n    ret_val = \"\"\n    if runtime.days:\n        ret_val = format_unit(runtime.days, 'duration-day', length=\"long\", locale=get_locale()) + ', '\n    mins, seconds = divmod(runtime.seconds, 60)\n    hours, minutes = divmod(mins, 60)\n    # ToDo: locale.number_symbols._data['timeSeparator'] -> localize time separator ?\n    if hours:\n        ret_val += '{:d}:{:02d}:{:02d}s'.format(hours, minutes, seconds)\n    elif minutes:\n        ret_val += '{:2d}:{:02d}s'.format(minutes, seconds)\n    else:\n        ret_val += '{:2d}s'.format(seconds)\n    return ret_val\n\n\n# helper function to apply localize status information in tasklist entries\ndef render_task_status(tasklist):\n    renderedtasklist = list()\n    for __, user, __, task in tasklist:\n        if user == current_user.name or current_user.role_admin():\n            ret = {}\n            if task.start_time:\n                ret['starttime'] = format_datetime(task.start_time, format='short', locale=get_locale())\n                ret['runtime'] = format_runtime(task.runtime)\n\n            # localize the task status\n            if isinstance(task.stat, int):\n                if task.stat == STAT_WAITING:\n                    ret['status'] = _(u'Waiting')\n                elif task.stat == STAT_FAIL:\n                    ret['status'] = _(u'Failed')\n                elif task.stat == STAT_STARTED:\n                    ret['status'] = _(u'Started')\n                elif task.stat == STAT_FINISH_SUCCESS:\n                    ret['status'] = _(u'Finished')\n                else:\n                    ret['status'] = _(u'Unknown Status')\n\n            ret['taskMessage'] = \"{}: {}\".format(_(task.name), task.message)\n            ret['progress'] = \"{} %\".format(int(task.progress * 100))\n            ret['user'] = escape(user)  # prevent xss\n            renderedtasklist.append(ret)\n\n    return renderedtasklist\n\n\ndef tags_filters():\n    negtags_list = current_user.list_denied_tags()\n    postags_list = current_user.list_allowed_tags()\n    neg_content_tags_filter = false() if negtags_list == [''] else db.Tags.name.in_(negtags_list)\n    pos_content_tags_filter = true() if postags_list == [''] else db.Tags.name.in_(postags_list)\n    return and_(pos_content_tags_filter, ~neg_content_tags_filter)\n\n\n# checks if domain is in database (including wildcards)\n# example SELECT * FROM @TABLE WHERE  'abcdefg' LIKE Name;\n# from https://code.luasoftware.com/tutorials/flask/execute-raw-sql-in-flask-sqlalchemy/\n# in all calls the email address is checked for validity\ndef check_valid_domain(domain_text):\n    sql = \"SELECT * FROM registration WHERE (:domain LIKE domain and allow = 1);\"\n    result = ub.session.query(ub.Registration).from_statement(text(sql)).params(domain=domain_text).all()\n    if not len(result):\n        return False\n    sql = \"SELECT * FROM registration WHERE (:domain LIKE domain and allow = 0);\"\n    result = ub.session.query(ub.Registration).from_statement(text(sql)).params(domain=domain_text).all()\n    return not len(result)\n\n\ndef get_cc_columns(filter_config_custom_read=False):\n    tmpcc = calibre_db.session.query(db.CustomColumns)\\\n        .filter(db.CustomColumns.datatype.notin_(db.cc_exceptions)).all()\n    cc = []\n    r = None\n    if config.config_columns_to_ignore:\n        r = re.compile(config.config_columns_to_ignore)\n\n    for col in tmpcc:\n        if filter_config_custom_read and config.config_read_column and config.config_read_column == col.id:\n            continue\n        if r and r.match(col.name):\n            continue\n        cc.append(col)\n\n    return cc\n\n\ndef get_download_link(book_id, book_format, client):\n    book_format = book_format.split(\".\")[0]\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    data1= \"\"\n    if book:\n        data1 = calibre_db.get_book_format(book.id, book_format.upper())\n    else:\n        log.error(\"Book id {} not found for downloading\".format(book_id))\n        abort(404)\n    if data1:\n        # collect downloaded books only for registered user and not for anonymous user\n        if current_user.is_authenticated:\n            ub.update_download(book_id, int(current_user.id))\n        file_name = book.title\n        if len(book.authors) > 0:\n            file_name = file_name + ' - ' + book.authors[0].name\n        file_name = get_valid_filename(file_name, replace_whitespace=False)\n        headers = Headers()\n        headers[\"Content-Type\"] = mimetypes.types_map.get('.' + book_format, \"application/octet-stream\")\n        headers[\"Content-Disposition\"] = \"attachment; filename=%s.%s; filename*=UTF-8''%s.%s\" % (\n            quote(file_name.encode('utf-8')), book_format, quote(file_name.encode('utf-8')), book_format)\n        return do_download_file(book, book_format, client, data1, headers)\n    else:\n        abort(404)\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport datetime\nfrom urllib.parse import unquote_plus\nfrom functools import wraps\n\nfrom flask import Blueprint, request, render_template, Response, g, make_response, abort\nfrom flask_login import current_user\nfrom sqlalchemy.sql.expression import func, text, or_, and_, true\nfrom werkzeug.security import check_password_hash\nfrom . import constants, logger, config, db, calibre_db, ub, services, get_locale, isoLanguages\nfrom .helper import get_download_link, get_book_cover\nfrom .pagination import Pagination\nfrom .web import render_read_books\nfrom .usermanagement import load_user_from_request\nfrom flask_babel import gettext as _\n\nopds = Blueprint('opds', __name__)\n\nlog = logger.create()\n\n\ndef requires_basic_auth_if_no_ano(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        auth = request.authorization\n        if config.config_anonbrowse != 1:\n            if not auth or auth.type != 'basic' or not check_auth(auth.username, auth.password):\n                return authenticate()\n        return f(*args, **kwargs)\n    if config.config_login_type == constants.LOGIN_LDAP and services.ldap and config.config_anonbrowse != 1:\n        return services.ldap.basic_auth_required(f)\n    return decorated\n\n\nclass FeedObject:\n    def __init__(self, rating_id, rating_name):\n        self.rating_id = rating_id\n        self.rating_name = rating_name\n\n    @property\n    def id(self):\n        return self.rating_id\n\n    @property\n    def name(self):\n        return self.rating_name\n\n\n@opds.route(\"/opds/\")\n@opds.route(\"/opds\")\n@requires_basic_auth_if_no_ano\ndef feed_index():\n    return render_xml_template('index.xml')\n\n\n@opds.route(\"/opds/osd\")\n@requires_basic_auth_if_no_ano\ndef feed_osd():\n    return render_xml_template('osd.xml', lang='en-EN')\n\n\n@opds.route(\"/opds/search\", defaults={'query': \"\"})\n@opds.route(\"/opds/search/<path:query>\")\n@requires_basic_auth_if_no_ano\ndef feed_cc_search(query):\n    # Handle strange query from Libera Reader with + instead of spaces\n    plus_query = unquote_plus(request.base_url.split('/opds/search/')[1]).strip()\n    return feed_search(plus_query)\n\n\n@opds.route(\"/opds/search\", methods=[\"GET\"])\n@requires_basic_auth_if_no_ano\ndef feed_normal_search():\n    return feed_search(request.args.get(\"query\", \"\").strip())\n\n\n@opds.route(\"/opds/books\")\n@requires_basic_auth_if_no_ano\ndef feed_booksindex():\n    return render_element_index(db.Books.sort, None, 'opds.feed_letter_books')\n\n\n@opds.route(\"/opds/books/letter/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_letter_books(book_id):\n    off = request.args.get(\"offset\") or 0\n    letter = true() if book_id == \"00\" else func.upper(db.Books.sort).startswith(book_id)\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        letter,\n                                                        [db.Books.sort])\n\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/new\")\n@requires_basic_auth_if_no_ano\ndef feed_new():\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books, True, [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/discover\")\n@requires_basic_auth_if_no_ano\ndef feed_discover():\n    entries = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()).order_by(func.random())\\\n        .limit(config.config_books_per_page)\n    pagination = Pagination(1, config.config_books_per_page, int(config.config_books_per_page))\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/rated\")\n@requires_basic_auth_if_no_ano\ndef feed_best_rated():\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books, db.Books.ratings.any(db.Ratings.rating > 9),\n                                                        [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/hot\")\n@requires_basic_auth_if_no_ano\ndef feed_hot():\n    off = request.args.get(\"offset\") or 0\n    all_books = ub.session.query(ub.Downloads, func.count(ub.Downloads.book_id)).order_by(\n        func.count(ub.Downloads.book_id).desc()).group_by(ub.Downloads.book_id)\n    hot_books = all_books.offset(off).limit(config.config_books_per_page)\n    entries = list()\n    for book in hot_books:\n        download_book = calibre_db.get_book(book.Downloads.book_id)\n        if download_book:\n            entries.append(\n                calibre_db.get_filtered_book(book.Downloads.book_id)\n            )\n        else:\n            ub.delete_download(book.Downloads.book_id)\n    num_books = entries.__len__()\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1),\n                            config.config_books_per_page, num_books)\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/author\")\n@requires_basic_auth_if_no_ano\ndef feed_authorindex():\n    return render_element_index(db.Authors.sort, db.books_authors_link, 'opds.feed_letter_author')\n\n\n@opds.route(\"/opds/author/letter/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_letter_author(book_id):\n    off = request.args.get(\"offset\") or 0\n    letter = true() if book_id == \"00\" else func.upper(db.Authors.sort).startswith(book_id)\n    entries = calibre_db.session.query(db.Authors).join(db.books_authors_link).join(db.Books)\\\n        .filter(calibre_db.common_filters()).filter(letter)\\\n        .group_by(text('books_authors_link.author'))\\\n        .order_by(db.Authors.sort)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            entries.count())\n    entries = entries.limit(config.config_books_per_page).offset(off).all()\n    return render_xml_template('feed.xml', listelements=entries, folder='opds.feed_author', pagination=pagination)\n\n\n@opds.route(\"/opds/author/<int:book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_author(book_id):\n    return render_xml_dataset(db.Authors, book_id)\n\n\n@opds.route(\"/opds/publisher\")\n@requires_basic_auth_if_no_ano\ndef feed_publisherindex():\n    off = request.args.get(\"offset\") or 0\n    entries = calibre_db.session.query(db.Publishers)\\\n        .join(db.books_publishers_link)\\\n        .join(db.Books).filter(calibre_db.common_filters())\\\n        .group_by(text('books_publishers_link.publisher'))\\\n        .order_by(db.Publishers.sort)\\\n        .limit(config.config_books_per_page).offset(off)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(calibre_db.session.query(db.Publishers).all()))\n    return render_xml_template('feed.xml', listelements=entries, folder='opds.feed_publisher', pagination=pagination)\n\n\n@opds.route(\"/opds/publisher/<int:book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_publisher(book_id):\n    return render_xml_dataset(db.Publishers, book_id)\n\n\n@opds.route(\"/opds/category\")\n@requires_basic_auth_if_no_ano\ndef feed_categoryindex():\n    return render_element_index(db.Tags.name, db.books_tags_link, 'opds.feed_letter_category')\n\n\n@opds.route(\"/opds/category/letter/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_letter_category(book_id):\n    off = request.args.get(\"offset\") or 0\n    letter = true() if book_id == \"00\" else func.upper(db.Tags.name).startswith(book_id)\n    entries = calibre_db.session.query(db.Tags)\\\n        .join(db.books_tags_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()).filter(letter)\\\n        .group_by(text('books_tags_link.tag'))\\\n        .order_by(db.Tags.name)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            entries.count())\n    entries = entries.offset(off).limit(config.config_books_per_page).all()\n    return render_xml_template('feed.xml', listelements=entries, folder='opds.feed_category', pagination=pagination)\n\n\n@opds.route(\"/opds/category/<int:book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_category(book_id):\n    return render_xml_dataset(db.Tags, book_id)\n\n\n@opds.route(\"/opds/series\")\n@requires_basic_auth_if_no_ano\ndef feed_seriesindex():\n    return render_element_index(db.Series.sort, db.books_series_link, 'opds.feed_letter_series')\n\n\n@opds.route(\"/opds/series/letter/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_letter_series(book_id):\n    off = request.args.get(\"offset\") or 0\n    letter = true() if book_id == \"00\" else func.upper(db.Series.sort).startswith(book_id)\n    entries = calibre_db.session.query(db.Series)\\\n        .join(db.books_series_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()).filter(letter)\\\n        .group_by(text('books_series_link.series'))\\\n        .order_by(db.Series.sort)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            entries.count())\n    entries = entries.offset(off).limit(config.config_books_per_page).all()\n    return render_xml_template('feed.xml', listelements=entries, folder='opds.feed_series', pagination=pagination)\n\n\n@opds.route(\"/opds/series/<int:book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_series(book_id):\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        db.Books.series.any(db.Series.id == book_id),\n                                                        [db.Books.series_index])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/ratings\")\n@requires_basic_auth_if_no_ano\ndef feed_ratingindex():\n    off = request.args.get(\"offset\") or 0\n    entries = calibre_db.session.query(db.Ratings, func.count('books_ratings_link.book').label('count'),\n                                       (db.Ratings.rating / 2).label('name')) \\\n        .join(db.books_ratings_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_ratings_link.rating'))\\\n        .order_by(db.Ratings.rating).all()\n\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(entries))\n    element = list()\n    for entry in entries:\n        element.append(FeedObject(entry[0].id, _(\"{} Stars\").format(entry.name)))\n    return render_xml_template('feed.xml', listelements=element, folder='opds.feed_ratings', pagination=pagination)\n\n\n@opds.route(\"/opds/ratings/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_ratings(book_id):\n    return render_xml_dataset(db.Tags, book_id)\n\n\n@opds.route(\"/opds/formats\")\n@requires_basic_auth_if_no_ano\ndef feed_formatindex():\n    off = request.args.get(\"offset\") or 0\n    entries = calibre_db.session.query(db.Data).join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(db.Data.format)\\\n        .order_by(db.Data.format).all()\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(entries))\n\n    element = list()\n    for entry in entries:\n        element.append(FeedObject(entry.format, entry.format))\n    return render_xml_template('feed.xml', listelements=element, folder='opds.feed_format', pagination=pagination)\n\n\n@opds.route(\"/opds/formats/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_format(book_id):\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        db.Books.data.any(db.Data.format == book_id.upper()),\n                                                        [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/language\")\n@opds.route(\"/opds/language/\")\n@requires_basic_auth_if_no_ano\ndef feed_languagesindex():\n    off = request.args.get(\"offset\") or 0\n    if current_user.filter_language() == u\"all\":\n        languages = calibre_db.speaking_language()\n    else:\n        languages = calibre_db.session.query(db.Languages).filter(\n            db.Languages.lang_code == current_user.filter_language()).all()\n        languages[0].name = isoLanguages.get_language_name(get_locale(), languages[0].lang_code)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(languages))\n    return render_xml_template('feed.xml', listelements=languages, folder='opds.feed_languages', pagination=pagination)\n\n\n@opds.route(\"/opds/language/<int:book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_languages(book_id):\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        db.Books.languages.any(db.Languages.id == book_id),\n                                                        [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\n@opds.route(\"/opds/shelfindex\")\n@requires_basic_auth_if_no_ano\ndef feed_shelfindex():\n    off = request.args.get(\"offset\") or 0\n    shelf = g.shelves_access\n    number = len(shelf)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            number)\n    return render_xml_template('feed.xml', listelements=shelf, folder='opds.feed_shelf', pagination=pagination)\n\n\n@opds.route(\"/opds/shelf/<int:book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_shelf(book_id):\n    off = request.args.get(\"offset\") or 0\n    if current_user.is_anonymous:\n        shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.is_public == 1,\n                                                  ub.Shelf.id == book_id).first()\n    else:\n        shelf = ub.session.query(ub.Shelf).filter(or_(and_(ub.Shelf.user_id == int(current_user.id),\n                                                           ub.Shelf.id == book_id),\n                                                      and_(ub.Shelf.is_public == 1,\n                                                           ub.Shelf.id == book_id))).first()\n    result = list()\n    # user is allowed to access shelf\n    if shelf:\n        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == book_id).order_by(\n            ub.BookShelf.order.asc()).all()\n        for book in books_in_shelf:\n            cur_book = calibre_db.get_book(book.book_id)\n            result.append(cur_book)\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(result))\n    return render_xml_template('feed.xml', entries=result, pagination=pagination)\n\n\n@opds.route(\"/opds/download/<book_id>/<book_format>/\")\n@requires_basic_auth_if_no_ano\ndef opds_download_link(book_id, book_format):\n    # I gave up with this: With enabled ldap login, the user doesn't get logged in, therefore it's always guest\n    # workaround, loading the user from the request and checking its download rights here\n    # in case of anonymous browsing user is None\n    user = load_user_from_request(request) or current_user\n    if not user.role_download():\n        return abort(403)\n    if \"Kobo\" in request.headers.get('User-Agent'):\n        client = \"kobo\"\n    else:\n        client = \"\"\n    return get_download_link(book_id, book_format.lower(), client)\n\n\n@opds.route(\"/ajax/book/<string:uuid>/<library>\")\n@opds.route(\"/ajax/book/<string:uuid>\", defaults={'library': \"\"})\n@requires_basic_auth_if_no_ano\ndef get_metadata_calibre_companion(uuid, library):\n    entry = calibre_db.session.query(db.Books).filter(db.Books.uuid.like(\"%\" + uuid + \"%\")).first()\n    if entry is not None:\n        js = render_template('json.txt', entry=entry)\n        response = make_response(js)\n        response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n        return response\n    else:\n        return \"\"\n\n\n@opds.route(\"/opds/thumb_240_240/<book_id>\")\n@opds.route(\"/opds/cover_240_240/<book_id>\")\n@opds.route(\"/opds/cover_90_90/<book_id>\")\n@opds.route(\"/opds/cover/<book_id>\")\n@requires_basic_auth_if_no_ano\ndef feed_get_cover(book_id):\n    return get_book_cover(book_id)\n\n\n@opds.route(\"/opds/readbooks\")\n@requires_basic_auth_if_no_ano\ndef feed_read_books():\n    off = request.args.get(\"offset\") or 0\n    result, pagination = render_read_books(int(off) / (int(config.config_books_per_page)) + 1, True, True)\n    return render_xml_template('feed.xml', entries=result, pagination=pagination)\n\n\n@opds.route(\"/opds/unreadbooks\")\n@requires_basic_auth_if_no_ano\ndef feed_unread_books():\n    off = request.args.get(\"offset\") or 0\n    result, pagination = render_read_books(int(off) / (int(config.config_books_per_page)) + 1, False, True)\n    return render_xml_template('feed.xml', entries=result, pagination=pagination)\n\n\ndef feed_search(term):\n    if term:\n        entries, __, ___ = calibre_db.get_search_results(term, config_read_column=config.config_read_column)\n        entries_count = len(entries) if len(entries) > 0 else 1\n        pagination = Pagination(1, entries_count, entries_count)\n        items = [entry[0] for entry in entries]\n        return render_xml_template('feed.xml', searchterm=term, entries=items, pagination=pagination)\n    else:\n        return render_xml_template('feed.xml', searchterm=\"\")\n\n\ndef check_auth(username, password):\n    try:\n        username = username.encode('windows-1252')\n    except UnicodeEncodeError:\n        username = username.encode('utf-8')\n    user = ub.session.query(ub.User).filter(func.lower(ub.User.name) ==\n                                            username.decode('utf-8').lower()).first()\n    if bool(user and check_password_hash(str(user.password), password)):\n        return True\n    else:\n        ip_address = request.headers.get('X-Forwarded-For', request.remote_addr)\n        log.warning('OPDS Login failed for user \"%s\" IP-address: %s', username.decode('utf-8'), ip_address)\n        return False\n\n\ndef authenticate():\n    return Response(\n        'Could not verify your access level for that URL.\\n'\n        'You have to login with proper credentials', 401,\n        {'WWW-Authenticate': 'Basic realm=\"Login Required\"'})\n\n\ndef render_xml_template(*args, **kwargs):\n    # ToDo: return time in current timezone similar to %z\n    currtime = datetime.datetime.now().strftime(\"%Y-%m-%dT%H:%M:%S+00:00\")\n    xml = render_template(current_time=currtime, instance=config.config_calibre_web_title, *args, **kwargs)\n    response = make_response(xml)\n    response.headers[\"Content-Type\"] = \"application/atom+xml; charset=utf-8\"\n    return response\n\n\ndef render_xml_dataset(data_table, book_id):\n    off = request.args.get(\"offset\") or 0\n    entries, __, pagination = calibre_db.fill_indexpage((int(off) / (int(config.config_books_per_page)) + 1), 0,\n                                                        db.Books,\n                                                        data_table.any(data_table.id == book_id),\n                                                        [db.Books.timestamp.desc()])\n    return render_xml_template('feed.xml', entries=entries, pagination=pagination)\n\n\ndef render_element_index(database_column, linked_table, folder):\n    shift = 0\n    off = int(request.args.get(\"offset\") or 0)\n    entries = calibre_db.session.query(func.upper(func.substr(database_column, 1, 1)).label('id'))\n    if linked_table:\n        entries = entries.join(linked_table).join(db.Books)\n    entries = entries.filter(calibre_db.common_filters()).group_by(func.upper(func.substr(database_column, 1, 1))).all()\n    elements = []\n    if off == 0:\n        elements.append({'id': \"00\", 'name': _(\"All\")})\n        shift = 1\n    for entry in entries[\n                 off + shift - 1:\n                 int(off + int(config.config_books_per_page) - shift)]:\n        elements.append({'id': entry.id, 'name': entry.id})\n    pagination = Pagination((int(off) / (int(config.config_books_per_page)) + 1), config.config_books_per_page,\n                            len(entries) + 1)\n    return render_xml_template('feed.xml',\n                               letterelements=elements,\n                               folder=folder,\n                               pagination=pagination)\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nfrom math import ceil\n\n\n# simple pagination for the feed\nclass Pagination(object):\n    def __init__(self, page, per_page, total_count):\n        self.page = int(page)\n        self.per_page = int(per_page)\n        self.total_count = int(total_count)\n\n    @property\n    def next_offset(self):\n        return int(self.page * self.per_page)\n\n    @property\n    def previous_offset(self):\n        return int((self.page - 2) * self.per_page)\n\n    @property\n    def last_offset(self):\n        last = int(self.total_count) - int(self.per_page)\n        if last < 0:\n            last = 0\n        return int(last)\n\n    @property\n    def pages(self):\n        return int(ceil(self.total_count / float(self.per_page)))\n\n    @property\n    def has_prev(self):\n        return self.page > 1\n\n    @property\n    def has_next(self):\n        return self.page < self.pages\n\n    # right_edge: last right_edges count of all pages are shown as number, means, if 10 pages are paginated -> 9,10 shown\n    # left_edge: first left_edges count of all pages are shown as number                                    -> 1,2 shown\n    # left_current: left_current count below current page are shown as number, means if current page 5      -> 3,4 shown\n    # left_current: right_current count above current page are shown as number, means if current page 5     -> 6,7 shown\n    def iter_pages(self, left_edge=2, left_current=2,\n                   right_current=4, right_edge=2):\n        last = 0\n        left_current = self.page - left_current - 1\n        right_current = self.page + right_current + 1\n        right_edge = self.pages - right_edge\n        for num in range(1, (self.pages + 1)):\n            if num <= left_edge or (left_current < num < right_current) or num > right_edge:\n                if last + 1 != num:\n                    yield None\n                yield num\n                last = num\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport json\nfrom datetime import datetime\nfrom functools import wraps\n\nfrom flask import Blueprint, request, make_response, abort, url_for, flash, redirect\nfrom flask_login import login_required, current_user, login_user\nfrom flask_babel import gettext as _\nfrom sqlalchemy.sql.expression import true\n\nfrom . import config, logger, ub\nfrom .render_template import render_title_template\n\n\nremotelogin = Blueprint('remotelogin', __name__)\nlog = logger.create()\n\n\ndef remote_login_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if config.config_remote_login:\n            return f(*args, **kwargs)\n        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':\n            data = {'status': 'error', 'message': 'Forbidden'}\n            response = make_response(json.dumps(data, ensure_ascii=False))\n            response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n            return response, 403\n        abort(403)\n\n    return inner\n\n@remotelogin.route('/remote/login')\n@remote_login_required\ndef remote_login():\n    auth_token = ub.RemoteAuthToken()\n    ub.session.add(auth_token)\n    ub.session_commit()\n    verify_url = url_for('remotelogin.verify_token', token=auth_token.auth_token, _external=true)\n    log.debug(u\"Remot Login request with token: %s\", auth_token.auth_token)\n    return render_title_template('remote_login.html', title=_(u\"Login\"), token=auth_token.auth_token,\n                                 verify_url=verify_url, page=\"remotelogin\")\n\n\n@remotelogin.route('/verify/<token>')\n@remote_login_required\n@login_required\ndef verify_token(token):\n    auth_token = ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.auth_token == token).first()\n\n    # Token not found\n    if auth_token is None:\n        flash(_(u\"Token not found\"), category=\"error\")\n        log.error(u\"Remote Login token not found\")\n        return redirect(url_for('web.index'))\n\n    # Token expired\n    elif datetime.now() > auth_token.expiration:\n        ub.session.delete(auth_token)\n        ub.session_commit()\n\n        flash(_(u\"Token has expired\"), category=\"error\")\n        log.error(u\"Remote Login token expired\")\n        return redirect(url_for('web.index'))\n\n    # Update token with user information\n    auth_token.user_id = current_user.id\n    auth_token.verified = True\n    ub.session_commit()\n\n    flash(_(u\"Success! Please return to your device\"), category=\"success\")\n    log.debug(u\"Remote Login token for userid %s verified\", auth_token.user_id)\n    return redirect(url_for('web.index'))\n\n\n@remotelogin.route('/ajax/verify_token', methods=['POST'])\n@remote_login_required\ndef token_verified():\n    token = request.form['token']\n    auth_token = ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.auth_token == token).first()\n\n    data = {}\n\n    # Token not found\n    if auth_token is None:\n        data['status'] = 'error'\n        data['message'] = _(u\"Token not found\")\n\n    # Token expired\n    elif datetime.now() > auth_token.expiration:\n        ub.session.delete(auth_token)\n        ub.session_commit()\n\n        data['status'] = 'error'\n        data['message'] = _(u\"Token has expired\")\n\n    elif not auth_token.verified:\n        data['status'] = 'not_verified'\n\n    else:\n        user = ub.session.query(ub.User).filter(ub.User.id == auth_token.user_id).first()\n        login_user(user)\n\n        ub.session.delete(auth_token)\n        ub.session_commit(\"User {} logged in via remotelogin, token deleted\".format(user.name))\n\n        data['status'] = 'success'\n        log.debug(u\"Remote Login for userid %s succeded\", user.id)\n        flash(_(u\"you are now logged in as: '%(nickname)s'\", nickname=user.name), category=\"success\")\n\n    response = make_response(json.dumps(data, ensure_ascii=False))\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n\n    return response\n", "{% extends \"layout.html\" %}\n{% block body %}\n{% if book %}\n  <div class=\"col-sm-3 col-lg-3 col-xs-12\">\n    <div class=\"cover\">\n        <img id=\"detailcover\" title=\"{{book.title}}\" src=\"{{ url_for('web.get_cover', book_id=book.id, edit=1|uuidfilter)  }}\" alt=\"{{ book.title }}\"/>\n    </div>\n{% if g.user.role_delete_books() %}\n    <div class=\"text-center\">\n      <button type=\"button\" class=\"btn btn-danger\" id=\"delete\" data-toggle=\"modal\" data-delete-id=\"{{ book.id }}\" data-target=\"#deleteModal\">{{_(\"Delete Book\")}}</button>\n    </div>\n    {% if book.data|length > 1 %}\n      <div class=\"text-center more-stuff\"><h4>{{_('Delete formats:')}}</h4>\n      {% for file in book.data %}\n        <div class=\"form-group\">\n          <button type=\"button\" class=\"btn btn-danger\" id=\"delete_format\" data-toggle=\"modal\" data-delete-id=\"{{ book.id }}\" data-delete-format=\"{{ file.format }}\" data-target=\"#deleteModal\">{{_('Delete')}} - {{file.format}}</button>\n        </div>\n      {% endfor %}\n      </div>\n    {% endif %}\n{% endif %}\n\n{%  if source_formats|length > 0 and conversion_formats|length > 0 %}\n  <div class=\"text-center more-stuff\"><h4>{{_('Convert book format:')}}</h4>\n      <form class=\"padded-bottom\" action=\"{{ url_for('edit-book.convert_bookformat', book_id=book.id) }}\" method=\"post\" id=\"book_convert_frm\">\n          <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n          <div class=\"form-group\">\n              <div class=\"text-left\">\n                  <label class=\"control-label\" for=\"book_format_from\">{{_('Convert from:')}}</label>\n                  <select class=\"form-control\" name=\"book_format_from\" id=\"book_format_from\">\n                    <option disabled selected value>-- {{_('select an option')}} --</option>\n                    {% for format in source_formats %}\n                    <option>{{format|upper}}</option>\n                    {% endfor %}\n                  </select>\n                  <label class=\"control-label\" for=\"book_format_to\">{{_('Convert to:')}}</label>\n                  <select class=\"form-control\" name=\"book_format_to\" id=\"book_format_to\">\n                    <option disabled selected value>-- {{_('select an option')}} --</option>\n                    {% for format in conversion_formats %}\n                    <option>{{format|upper}}</option>\n                    {% endfor %}\n                  </select>\n              </div>\n          </div>\n          <button type=\"submit\" class=\"btn btn-primary\" id=\"btn-book-convert\" name=\"btn-book-convert\"><span class=\"glyphicon glyphicon-duplicate\"></span> {{_('Convert book')}}</button>\n      </form>\n  </div>\n{% endif %}\n\n  </div>\n<form role=\"form\" action=\"{{ url_for('edit-book.edit_book', book_id=book.id) }}\" method=\"post\" enctype=\"multipart/form-data\" id=\"book_edit_frm\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n  <div class=\"col-sm-9 col-xs-12\">\n    <div class=\"form-group\">\n      <label for=\"book_title\">{{_('Book Title')}}</label>\n      <input type=\"text\" class=\"form-control\" name=\"book_title\" id=\"book_title\" value=\"{{book.title}}\">\n    </div>\n    <div class=\"text-center\">\n        <button type=\"button\" class=\"btn btn-default\" id=\"xchange\" ><span class=\"glyphicon glyphicon-arrow-up\"></span><span class=\"glyphicon glyphicon-arrow-down\"></span></button>\n    </div>\n    <div id=\"author_div\" class=\"form-group\">\n      <label for=\"bookAuthor\">{{_('Author')}}</label>\n      <input type=\"text\" class=\"form-control typeahead\" name=\"author_name\" id=\"bookAuthor\" value=\"{{' & '.join(authors)}}\" autocomplete=\"off\">\n    </div>\n\n    <div class=\"form-group\">\n      <label for=\"description\">{{_('Description')}}</label>\n      <textarea class=\"form-control\" name=\"description\" id=\"description\" rows=\"7\">{% if book.comments %}{{book.comments[0].text}}{%endif%}</textarea>\n    </div>\n\n    <div class=\"form-group\">\n      <label>{{_('Identifiers')}}</label>\n      <table class=\"table\" id=\"identifier-table\">\n\t{% for identifier in book.identifiers %}\n\t<tr>\n      <td><input type=\"text\" class=\"form-control\" name=\"identifier-type-{{identifier.type}}\" value=\"{{identifier.type}}\" required=\"required\" placeholder=\"{{_('Identifier Type')}}\"></td>\n\t  <td><input type=\"text\" class=\"form-control\" name=\"identifier-val-{{identifier.type}}\" value=\"{{identifier.val}}\" required=\"required\" placeholder=\"{{_('Identifier Value')}}\"></td>\n\t  <td><a class=\"btn btn-default\" onclick=\"removeIdentifierLine(this)\">{{_('Remove')}}</a></td>\n\t</tr>\n\t{% endfor %}\n      </table>\n      <a id=\"add-identifier-line\" class=\"btn btn-default\">{{_('Add Identifier')}}</a>\n    </div>\n\n    <div class=\"form-group\">\n      <label for=\"tags\">{{_('Tags')}}</label>\n      <input type=\"text\" class=\"form-control typeahead\" name=\"tags\" id=\"tags\" value=\"{% for tag in book.tags %}{{tag.name.strip()}}{% if not loop.last %}, {% endif %}{% endfor %}\">\n    </div>\n    <div class=\"form-group\">\n      <label for=\"series\">{{_('Series')}}</label>\n      <input type=\"text\" class=\"form-control typeahead\" name=\"series\" id=\"series\" value=\"{% if book.series %}{{book.series[0].name}}{% endif %}\">\n    </div>\n    <div class=\"form-group\">\n      <label for=\"series_index\">{{_('Series ID')}}</label>\n      <input type=\"number\" step=\"0.01\" min=\"0\" placeholder=\"1\" class=\"form-control\" name=\"series_index\" id=\"series_index\" value=\"{{book.series_index}}\">\n    </div>\n    <div class=\"form-group\">\n      <label for=\"rating\">{{_('Rating')}}</label>\n      <input type=\"number\"  name=\"rating\" id=\"rating\" class=\"rating input-lg\" data-clearable=\"\" value=\"{% if book.ratings %}{{(book.ratings[0].rating / 2)|int}}{% endif %}\">\n    </div>\n    {% if g.user.role_upload() and g.allow_upload %}\n    <div class=\"form-group\">\n      <label for=\"cover_url\">{{_('Fetch Cover from URL (JPEG - Image will be downloaded and stored in database)')}}</label>\n      <input type=\"text\" class=\"form-control\" name=\"cover_url\" id=\"cover_url\" value=\"\">\n    </div>\n      <div class=\"form-group\" aria-label=\"Upload cover from local drive\">\n        <label class=\"btn btn-primary btn-file\" for=\"btn-upload-cover\">{{ _('Upload Cover from Local Disk') }}</label>\n        <div class=\"upload-cover-input-text\" id=\"upload-cover\"></div>\n        <input id=\"btn-upload-cover\" name=\"btn-upload-cover\" type=\"file\" accept=\".jpg, .jpeg, .png, .webp\">\n      </div>\n    {% endif %}\n    <label for=\"pubdate\">{{_('Published Date')}}</label>\n    <div class=\"form-group input-group\">\n       <input type=\"text\" class=\"datepicker form-control\" name=\"pubdate\" id=\"pubdate\" value=\"{% if book.pubdate %}{{book.pubdate|formatdateinput}}{% endif %}\">\n       <input type=\"text\" class=\"form-control fake-input hidden\" id=\"fake_pubdate\" value=\"{% if book.pubdate %}{{book.pubdate|formatdate}}{% endif %}\">\n      <span class=\"input-group-btn\">\n        <button type=\"button\" id=\"pubdate_delete\" class=\"datepicker_delete btn btn-default\"><span class=\"glyphicon glyphicon-remove-circle\"></span></button>\n      </span>\n    </div>\n    <div class=\"form-group\">\n      <label for=\"publisher\">{{_('Publisher')}}</label>\n      <input type=\"text\" class=\"form-control typeahead\" name=\"publisher\" id=\"publisher\" value=\"{% if book.publishers|length > 0 %}{{book.publishers[0].name}}{% endif %}\">\n    </div>\n    <div class=\"form-group\">\n      <label for=\"languages\">{{_('Language')}}</label>\n      <input type=\"text\" class=\"form-control typeahead\" name=\"languages\" id=\"languages\" value=\"{% for language in book.languages %}{{language.language_name.strip()}}{% if not loop.last %}, {% endif %}{% endfor %}\">\n    </div>\n      {% if cc|length > 0 %}\n        {% for c in cc %}\n          <div class=\"form-group\">\n            <label for=\"{{ 'custom_column_' ~ c.id }}\">{{ c.name }}</label>\n            {% if c.datatype == 'bool' %}\n              <select name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\" class=\"form-control\">\n                <option value=\"None\" {% if book['custom_column_' ~ c.id]|length == 0 %} selected {% endif %}></option>\n                <option value=\"True\"  {% if book['custom_column_' ~ c.id]|length > 0 %}{% if book['custom_column_' ~ c.id][0].value ==true %}selected{% endif %}{% endif %} >{{_('Yes')}}</option>\n                <option value=\"False\"  {% if book['custom_column_' ~ c.id]|length > 0 %}{% if book['custom_column_' ~ c.id][0].value ==false %}selected{% endif %}{% endif %}>{{_('No')}}</option>\n              </select>\n            {% endif %}\n\n            {% if c.datatype == 'int' or c.datatype == 'float' %}\n\t    <input type=\"number\" step=\"{% if c.datatype == 'float' %}0.01{% else %}1{% endif %}\" class=\"form-control\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\" value=\"{% if book['custom_column_' ~ c.id]|length > 0 %}{{ book['custom_column_' ~ c.id][0].value }}{% endif %}\">\n            {% endif %}\n\n            {% if c.datatype == 'text' %}\n              <input type=\"text\" class=\"form-control\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\"\n              {% if book['custom_column_' ~ c.id]|length > 0 %}\n              value=\"{% for column in book['custom_column_' ~ c.id] %}{{ column.value.strip() }}{% if not loop.last %}, {% endif %}{% endfor %}\"{% endif %}>\n            {% endif %}\n\n            {% if c.datatype == 'series' %}\n              <input type=\"text\" class=\"form-control\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\"\n              {% if book['custom_column_' ~ c.id]|length > 0 %}\n                value=\"{% for column in book['custom_column_' ~ c.id] %} {{ '%s [%s]' % (book['custom_column_' ~ c.id][0].value, book['custom_column_' ~ c.id][0].extra|formatfloat(2)) }}{% if not loop.last %}, {% endif %}{% endfor %}\"\n              {% endif %}>\n            {% endif %}\n\n            {% if c.datatype == 'datetime' %}\n              <div class=\"input-group\">\n                <input type=\"text\" class=\"datepicker form-control\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\"\n                  {% if book['custom_column_' ~ c.id]|length > 0 %}\n                    value=\"{% if book['custom_column_' ~ c.id][0].value  %}{{ book['custom_column_' ~ c.id][0].value|formatdateinput}}{% endif %}\"\n                  {% endif %}>\n                <input type=\"text\" class=\"fake_custom_column_{{ c.id }} form-control fake-input hidden\" id=\"fake_pubdate_{{ c.id }}\"\n                  {% if book['custom_column_' ~ c.id]|length > 0 %}\n                    value=\"{% if book['custom_column_' ~ c.id][0].value %}{{book['custom_column_' ~ c.id][0].value|formatdate}}{% endif %}\"\n                  {% endif %}>\n                <span class=\"input-group-btn\">\n                  <button type=\"button\" id=\"{{ 'custom_column_' ~ c.id }}_delete\" class=\"datepicker_delete btn btn-default\"><span class=\"glyphicon glyphicon-remove-circle\"></span></button>\n                </span>\n              </div>\n            {% endif %}\n\n            {% if c.datatype == 'comments' %}\n              <textarea class=\"form-control tiny_editor\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\" rows=\"7\">{% if book['custom_column_' ~ c.id]|length > 0 %}{{book['custom_column_' ~ c.id][0].value}}{%endif%}</textarea>\n            {% endif %}\n            {% if c.datatype == 'enumeration' %}\n              <select class=\"form-control\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\">\n                  <option></option>\n                  {% for opt in c.get_display_dict().enum_values %}\n                    <option\n                      {% if book['custom_column_' ~ c.id]|length > 0 %}\n                        {% if book['custom_column_' ~ c.id][0].value == opt %}selected=\"selected\"{% endif %}\n                      {% endif %}\n                      >{{ opt }}</option>\n                  {% endfor %}\n              </select>\n            {% endif %}\n\n            {% if c.datatype == 'rating' %}\n              <input type=\"number\" min=\"1\" max=\"5\" step=\"0.5\" class=\"form-control\" name=\"{{ 'custom_column_' ~ c.id }}\" id=\"{{ 'custom_column_' ~ c.id }}\"\n                {% if book['custom_column_' ~ c.id]|length > 0 %}\n                    value=\"{{ '%.1f' %  (book['custom_column_' ~ c.id][0].value / 2) }}\"\n                {% endif %}>\n            {% endif %}\n          </div>\n        {% endfor %}\n      {% endif %}\n      {% if g.user.role_upload() and g.allow_upload %}\n          <div role=\"group\" aria-label=\"Upload new book format\">\n            <label class=\"btn btn-primary btn-file\" for=\"btn-upload-format\">{{ _('Upload Format') }}</label>\n            <div class=\"upload-format-input-text\" id=\"upload-format\"></div>\n            <input id=\"btn-upload-format\" name=\"btn-upload-format\" type=\"file\">\n          </div>\n      {% endif %}\n\n    <div class=\"checkbox\">\n      <label>\n        <input name=\"detail_view\" type=\"checkbox\" checked> {{_('View Book on Save')}}\n      </label>\n    </div>\n    <a href=\"#\" id=\"get_meta\" class=\"btn btn-default\" data-toggle=\"modal\" data-target=\"#metaModal\">{{_('Fetch Metadata')}}</a>\n    <button type=\"submit\" id=\"submit\" class=\"btn btn-default\">{{_('Save')}}</button>\n    <a href=\"{{ url_for('web.show_book', book_id=book.id) }}\" id=\"edit_cancel\" class=\"btn btn-default\">{{_('Cancel')}}</a>\n  </div>\n</form>\n\n{% endif %}\n{% endblock %}\n\n{% block modal %}\n{{ delete_book() }}\n{{ delete_confirm_modal() }}\n\n<div class=\"modal fade\" id=\"metaModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"metaModalLabel\">\n  <div class=\"modal-dialog modal-lg\" role=\"document\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\n        <h4 class=\"modal-title text-center\" id=\"metaModalLabel\">{{_('Fetch Metadata')}}</h4>\n        <form class=\"padded-bottom\" id=\"meta-search\">\n          <div class=\"input-group\">\n            <label class=\"sr-only\" for=\"keyword\">{{_('Keyword')}}</label>\n            <input type=\"text\" class=\"form-control\" id=\"keyword\" name=\"keyword\" placeholder=\"{{_(\"Search keyword\")}}\">\n            <span class=\"input-group-btn\">\n              <button type=\"submit\" class=\"btn btn-primary\" id=\"do-search\">{{_(\"Search\")}}</button>\n            </span>\n          </div>\n        </form>\n        <div class=\"text-center\"><strong>{{_('Click the cover to load metadata to the form')}}</strong></div>\n      </div>\n      <div class=\"modal-body\">\n        <div class=\"text-center padded-bottom\" id=\"metadata_provider\">\n        </div>\n\n        <div id=\"meta-info\">\n          {{_(\"Loading...\")}}\n        </div>\n      </div>\n      <div class=\"modal-footer\">\n        <button id=\"meta_close\" type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">{{_('Close')}}</button>\n      </div>\n    </div>\n  </div>\n</div>\n{% endblock %}\n\n{% block js %}\n<script type=\"text/template\" id=\"template-book-result\">\n  <li class=\"media\" data-related=\"<%= source.id %>\">\n    <img class=\"pull-left img-responsive\"\n         data-toggle=\"modal\"\n         data-target=\"#metaModal\"\n         src=\"<%= cover || \"{{ url_for('static', filename='img/academicpaper.svg') }}\" %>\"\n         alt=\"Cover\"\n    >\n    <div class=\"media-body\">\n      <h4 class=\"media-heading\">\n        <a class=\"meta_title\" href=\"<%= url %>\" target=\"_blank\" rel=\"noopener\"><%= title %></a>\n      </h4>\n      <p class=\"meta_author\">{{_('Author')}}\uff1a<%= authors.join(\" & \") %></p>\n      <% if (publisher) { %>\n        <p class=\"meta_publisher\">{{_('Publisher')}}\uff1a<%= publisher %></p>\n      <% } %>\n      <% if (description) { %>\n        <p class=\"meta_description\">{{_('Description')}}: <%= description %></p>\n      <% } %>\n      <p>{{_('Source')}}:\n        <a class=\"meta_source\" href=\"<%= source.link %>\" target=\"_blank\" rel=\"noopener\"><%= source.description %></a>\n      </p>\n    </div>\n  </li>\n</script>\n<script>\n  var i18nMsg = {\n    'loading': {{_('Loading...')|safe|tojson}},\n    'search_error': {{_('Search error!')|safe|tojson}},\n    'no_result': {{_('No Result(s) found! Please try another keyword.')|safe|tojson}},\n    'author': {{_('Author')|safe|tojson}},\n    'publisher': {{_('Publisher')|safe|tojson}},\n    'description': {{_('Description')|safe|tojson}},\n    'source': {{_('Source')|safe|tojson}},\n  };\n  var language = '{{ g.user.locale }}';\n\n  $(\"#add-identifier-line\").click(function() {\n    // create a random identifier type to have a valid name in form. This will not be used when dealing with the form\n    var rand_id = Math.floor(Math.random() * 1000000).toString();\n    var line = '<tr>';\n    line += '<td><input type=\"text\" class=\"form-control\" name=\"identifier-type-'+ rand_id +'\" required=\"required\" placeholder={{_('Identifier Type')|safe|tojson}}></td>';\n    line += '<td><input type=\"text\" class=\"form-control\" name=\"identifier-val-'+ rand_id +'\" required=\"required\" placeholder={{_('Identifier Value')|safe|tojson}}></td>';\n    line += '<td><a class=\"btn btn-default\" onclick=\"removeIdentifierLine(this)\">{{_('Remove')}}</a></td>';\n    line += '</tr>';\n    $(\"#identifier-table\").append(line);\n  });\n  function removeIdentifierLine(el) {\n    $(el).parent().parent().remove();\n  }\n\n</script>\n<script src=\"{{ url_for('static', filename='js/libs/typeahead.bundle.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-rating-input.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/get_meta.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/tinymce/tinymce.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-datepicker/bootstrap-datepicker.min.js') }}\"></script>\n{% if not g.user.locale == 'en' %}\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-datepicker/locales/bootstrap-datepicker.' + g.user.locale + '.min.js') }}\" charset=\"UTF-8\"></script>\n{% endif %}\n<script src=\"{{ url_for('static', filename='js/edit_books.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/fullscreen.js') }}\"></script>\n{% endblock %}\n{% block header %}\n<meta name=\"referrer\" content=\"never\">\n<link href=\"{{ url_for('static', filename='css/libs/typeahead.css') }}\" rel=\"stylesheet\" media=\"screen\">\n<link href=\"{{ url_for('static', filename='css/libs/bootstrap-datepicker3.min.css') }}\" rel=\"stylesheet\" media=\"screen\">\n{% endblock %}\n", "{% extends \"layout.html\" %}\n{% macro text_table_row(parameter, edit_text, show_text, validate, sort) -%}\n<th data-field=\"{{ parameter }}\" id=\"{{ parameter }}\"\n    {% if sort %}data-sortable=\"true\" {% endif %}\n    data-visible = \"{{visiblility.get(parameter)}}\"\n    data-escape=\"true\"\n    {% if g.user.role_edit() %}\n        data-editable-type=\"text\"\n        data-editable-url=\"{{ url_for('edit-book.edit_list_book', param=parameter)}}\"\n        data-editable-title=\"{{ edit_text }}\"\n        data-edit=\"true\"\n        {% if validate %}data-edit-validate=\"{{ _('This Field is Required') }}\" {% endif %}\n    {% endif %}\n>{{ show_text }}</th>\n{%- endmacro %}\n\n{% macro book_checkbox_row(parameter, show_text, sort) -%}\n<th data-name=\"{{parameter}}\" data-field=\"{{parameter}}\"\n    {% if sort %}data-sortable=\"true\" {% endif %}\n    data-visible=\"{{visiblility.get(parameter)}}\"\n    data-formatter=\"bookCheckboxFormatter\">\n    {{show_text}}\n</th>\n{%- endmacro %}\n\n\n{% block header %}\n<link href=\"{{ url_for('static', filename='css/libs/bootstrap-table.min.css') }}\" rel=\"stylesheet\">\n<link href=\"{{ url_for('static', filename='css/libs/bootstrap-editable.css') }}\" rel=\"stylesheet\">\n<link href=\"{{ url_for('static', filename='css/libs/bootstrap-wysihtml5-0.0.3.css') }}\" rel=\"stylesheet\">\n{% endblock %}\n{% block body %}\n<h2 class=\"{{page}}\">{{_(title)}}</h2>\n      <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n      <div class=\"col-xs-12 col-sm-6\">\n        <div class=\"row form-group\">\n          <div class=\"btn btn-default disabled\" id=\"merge_books\" aria-disabled=\"true\">{{_('Merge selected books')}}</div>\n          <div class=\"btn btn-default disabled\" id=\"delete_selection\" aria-disabled=\"true\">{{_('Remove Selections')}}</div>\n        </div>\n        <div class=\"row form-group\">\n            <div class=\"btn btn-default disabled\" id=\"table_xchange\" ><span class=\"glyphicon glyphicon-arrow-up\"></span><span class=\"glyphicon glyphicon-arrow-down\"></span>{{_('Exchange author and title')}}</div>\n        </div>\n      </div>\n     <div class=\"filterheader col-xs-12 col-sm-6\">\n      <div class=\"row form-group\">\n        <input type=\"checkbox\" id=\"autoupdate_titlesort\" name=\"autoupdate_titlesort\" checked>\n        <label for=\"autoupdate_titlesort\">{{_('Update Title Sort automatically')}}</label>\n      </div>\n      <div class=\"row form-group\">\n        <input type=\"checkbox\" id=\"autoupdate_authorsort\" name=\"autoupdate_authorsort\" checked>\n        <label for=\"autoupdate_authorsort\">{{_('Update Author Sort automatically')}}</label>\n      </div>\n    </div>\n\n    <table id=\"books-table\" class=\"table table-no-bordered table-striped\"\n           data-url=\"{{url_for('web.list_books')}}\" data-locale=\"{{ g.user.locale }}\">\n      <thead>\n        <tr>\n          {% if g.user.role_edit() %}\n            <th data-field=\"state\" data-checkbox=\"true\" data-sortable=\"true\"></th>\n          {% endif %}\n            <th data-field=\"id\" id=\"id\" data-visible=\"false\" data-switchable=\"false\"></th>\n            {{ text_table_row('title', _('Enter Title'),_('Title'), true, true) }}\n            {{ text_table_row('sort', _('Enter Title Sort'),_('Title Sort'), false, true) }}\n            {{ text_table_row('author_sort', _('Enter Author Sort'),_('Author Sort'), false, true) }}\n            {{ text_table_row('authors', _('Enter Authors'),_('Authors'), true, true) }}\n            {{ text_table_row('tags', _('Enter Categories'),_('Categories'), false, true) }}\n            {{ text_table_row('series', _('Enter Series'),_('Series'), false, true) }}\n            <th data-field=\"series_index\" id=\"series_index\" data-visible=\"{{visiblility.get('series_index')}}\" data-edit-validate=\"{{ _('This Field is Required') }}\" data-sortable=\"true\" {% if g.user.role_edit() %} data-editable-type=\"number\" data-editable-placeholder=\"1\" data-editable-step=\"0.01\" data-editable-min=\"0\" data-editable-url=\"{{ url_for('edit-book.edit_list_book', param='series_index')}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter Title')}}\"{% endif %}>{{_('Series Index')}}</th>\n            {{ text_table_row('languages', _('Enter Languages'),_('Languages'), false, true) }}\n            <!--th data-field=\"pubdate\" data-type=\"date\" data-visible=\"{{visiblility.get('pubdate')}}\" data-viewformat=\"dd.mm.yyyy\" id=\"pubdate\" data-sortable=\"true\">{{_('Publishing Date')}}</th-->\n            {{ text_table_row('publishers', _('Enter Publishers'),_('Publishers'), false, true) }}\n            <th data-field=\"comments\" id=\"comments\" data-escape=\"true\" data-editable-mode=\"popup\"  data-visible=\"{{visiblility.get('comments')}}\" data-sortable=\"false\" {% if g.user.role_edit() %} data-editable-type=\"wysihtml5\" data-editable-url=\"{{ url_for('edit-book.edit_list_book', param='comments')}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter comments')}}\"{% endif %}>{{_('Comments')}}</th>\n            {% if g.user.check_visibility(32768) %}\n                {{ book_checkbox_row('is_archived', _('Archiv Status'), false)}}\n            {%  endif %}\n            {{ book_checkbox_row('read_status', _('Read Status'), false)}}\n            {% for c in cc %}\n              {% if c.datatype == \"int\" %}\n                <th data-field=\"custom_column_{{ c.id|string }}\" id=\"custom_column_{{ c.id|string }}\" data-visible=\"{{visiblility.get('custom_column_'+ c.id|string)}}\" data-sortable=\"false\" {% if g.user.role_edit() %} data-editable-type=\"number\" data-editable-placeholder=\"1\" data-editable-step=\"1\" data-editable-url=\"{{ url_for('edit-book.edit_list_book', param='custom_column_'+ c.id|string)}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter ') + c.name}}\"{% endif %}>{{c.name}}</th>\n              {% elif c.datatype == \"rating\" %}\n                <th data-field=\"custom_column_{{ c.id|string }}\" id=\"custom_column_{{ c.id|string }}\" data-formatter=\"ratingFormatter\" data-visible=\"{{visiblility.get('custom_column_'+ c.id|string)}}\" data-sortable=\"false\" {% if g.user.role_edit() %} data-editable-type=\"number\" data-editable-placeholder=\"1\" data-editable-step=\"0.5\" data-editable-step=\"1\" data-editable-min=\"1\" data-editable-max=\"5\" data-editable-url=\"{{ url_for('edit-book.edit_list_book', param='custom_column_'+ c.id|string)}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter ') + c.name}}\"{% endif %}>{{c.name}}</th>\n              {% elif c.datatype == \"float\" %}\n                <th data-field=\"custom_column_{{ c.id|string }}\" id=\"custom_column_{{ c.id|string }}\" data-visible=\"{{visiblility.get('custom_column_'+ c.id|string)}}\" data-sortable=\"false\" {% if g.user.role_edit() %} data-editable-type=\"number\" data-editable-placeholder=\"1\" data-editable-step=\"0.01\" data-editable-url=\"{{ url_for('edit-book.edit_list_book', param='custom_column_'+ c.id|string)}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter ') + c.name}}\"{% endif %}>{{c.name}}</th>\n              {% elif c.datatype == \"enumeration\" %}\n                <th data-field=\"custom_column_{{ c.id|string }}\" id=\"custom_column_{{ c.id|string }}\" data-visible=\"{{visiblility.get('custom_column_'+ c.id|string)}}\" data-sortable=\"false\" {% if g.user.role_edit() %} data-editable-type=\"select\" data-editable-source={{ url_for('edit-book.table_get_custom_enum', c_id=c.id)  }} data-editable-url=\"{{ url_for('edit-book.edit_list_book', param='custom_column_'+ c.id|string)}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter ') + c.name}}\"{% endif %}>{{c.name}}</th>\n              {% elif c.datatype in [\"datetime\"] %}\n                  <!-- missing -->\n              {% elif c.datatype == \"text\" %}\n                 {{ text_table_row('custom_column_' + c.id|string, _('Enter ') + c.name, c.name, false, false) }}\n              {% elif c.datatype == \"comments\" %}\n                  <th data-field=\"custom_column_{{ c.id|string }}\" id=\"custom_column_{{ c.id|string }}\" data-escape=\"true\" data-editable-mode=\"popup\"  data-visible=\"{{visiblility.get('custom_column_'+ c.id|string)}}\" data-sortable=\"false\" {% if g.user.role_edit() %} data-editable-type=\"wysihtml5\" data-editable-url=\"{{ url_for('edit-book.edit_list_book', param='custom_column_'+ c.id|string)}}\" data-edit=\"true\" data-editable-title=\"{{_('Enter ') + c.name}}\"{% endif %}>{{c.name}}</th>\n              {% elif c.datatype == \"bool\" %}\n                  {{ book_checkbox_row('custom_column_' + c.id|string, c.name, false)}}\n              {% else %}\n                <!--{{ text_table_row('custom_column_' + c.id|string, _('Enter ') + c.name, c.name, false, false) }} -->\n              {% endif %}\n            {% endfor %}\n          {% if g.user.role_delete_books() and g.user.role_edit()%}\n            <th data-align=\"right\" data-formatter=\"EbookActions\" data-switchable=\"false\">{{_('Delete')}}</th>\n          {% endif %}\n        </tr>\n      </thead>\n    </table>\n{% endblock %}\n{% block modal %}\n{{ delete_book() }}\n{% if g.user.role_edit() %}\n<div class=\"modal fade\" id=\"mergeModal\" role=\"dialog\" aria-labelledby=\"metaMergeLabel\">\n  <div class=\"modal-dialog\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header bg-danger text-center\">\n          <span>{{_('Are you really sure?')}}</span>\n      </div>\n        <div class=\"modal-body\">\n          <p></p>\n            <div class=\"text-left\">{{_('Books with Title will be merged from:')}}</div>\n          <p></p>\n            <div class=\"text-left\" id=\"merge_from\"></div>\n          <p></p>\n            <div class=\"text-left\">{{_('Into Book with Title:')}}</div>\n          <p></p>\n            <div class=\"text-left\" id=\"merge_to\"></div>\n        </div>\n      <div class=\"modal-footer\">\n        <input id=\"merge_confirm\"  type=\"button\" class=\"btn btn-danger\" value=\"{{_('Merge')}}\" name=\"merge_confirm\" id=\"merge_confirm\" data-dismiss=\"modal\">\n        <button id=\"merge_abort\" type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">{{_('Cancel')}}</button>\n      </div>\n    </div>\n  </div>\n</div>\n{% endif %}\n\n{% endblock %}\n{% block js %}\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-table/bootstrap-table.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-table/bootstrap-table-locale-all.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-table/bootstrap-table-editable.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-table/bootstrap-editable.min.js') }}\"></script>\n{% if not g.user.locale == 'en' %}\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-table/locale/bootstrap-table-' + g.user.locale + '.min.js') }}\" charset=\"UTF-8\"></script>\n{% endif %}\n<script src=\"{{ url_for('static', filename='js/libs/wysihtml5-0.3.0.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/bootstrap-wysihtml5-0.0.3.min.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/libs/wysihtml5-0.0.3.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/table.js') }}\"></script>\n{% endblock %}\n", "{% extends is_xhr|yesno(\"fragment.html\", \"layout.html\") %}\n{% block body %}\n<div class=\"single\">\n  <div class=\"row\">\n    <div class=\"col-sm-3 col-lg-3 col-xs-5\">\n      <div class=\"cover\">\n          <img id=\"detailcover\" title=\"{{entry.title}}\" src=\"{{ url_for('web.get_cover', book_id=entry.id, edit=1|uuidfilter) }}\" alt=\"{{ entry.title }}\" />\n      </div>\n    </div>\n    <div class=\"col-sm-9 col-lg-9 book-meta\">\n      <div class=\"btn-toolbar\" role=\"toolbar\">\n        <div class=\"btn-group\" role=\"group\" aria-label=\"Download, send to Kindle, reading\">\n          {% if g.user.role_download() %}\n            {% if entry.data|length %}\n            <div class=\"btn-group\" role=\"group\">\n                {% if entry.data|length < 2 %}\n                  <button id=\"Download\" type=\"button\" class=\"btn btn-primary\">\n                    {{_('Download')}} :\n                  </button>\n                  {% for format in entry.data %}\n                  <a href=\"{{ url_for('web.download_link', book_id=entry.id, book_format=format.format|lower, anyname=entry.id|string+'.'+format.format|lower) }}\" id=\"btnGroupDrop1{{format.format|lower}}\" class=\"btn btn-primary\" role=\"button\">\n                    <span class=\"glyphicon glyphicon-download\"></span>{{format.format}} ({{ format.uncompressed_size|filesizeformat }})\n                  </a>\n                  {% endfor %}\n                {% else %}\n                  <button id=\"btnGroupDrop1\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"glyphicon glyphicon-download\"></span> {{_('Download')}}\n                    <span class=\"caret\"></span>\n                  </button>\n                  <ul class=\"dropdown-menu\" aria-labelledby=\"btnGroupDrop1\">\n                  {% for format in entry.data %}\n                    <li><a href=\"{{ url_for('web.download_link', book_id=entry.id, book_format=format.format|lower, anyname=entry.id|string+'.'+format.format|lower) }}\">{{format.format}} ({{ format.uncompressed_size|filesizeformat }})</a></li>\n                  {% endfor %}\n                  </ul>\n                {% endif %}\n            </div>\n            {% endif %}\n          {% endif %}\n            {% if g.user.kindle_mail and entry.kindle_list %}\n              {% if entry.kindle_list.__len__() == 1 %}\n                <div id=\"sendbtn\" data-action=\"{{url_for('web.send_to_kindle', book_id=entry.id, book_format=entry.kindle_list[0]['format'], convert=entry.kindle_list[0]['convert'])}}\" data-text=\"{{_('Send to Kindle')}}\" class=\"btn btn-primary postAction\" role=\"button\"><span class=\"glyphicon glyphicon-send\"></span> {{entry.kindle_list[0]['text']}}</div>\n              {% else %}\n                <div class=\"btn-group\" role=\"group\">\n                  <button id=\"sendbtn2\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                    <span class=\"glyphicon glyphicon-send\"></span>{{_('Send to Kindle')}}\n                    <span class=\"caret\"></span>\n                  </button>\n                    <ul class=\"dropdown-menu\" aria-labelledby=\"send-to-kindle\">\n                    {% for format in entry.kindle_list %}\n                      <li><a class=\"postAction\" data-action=\"{{url_for('web.send_to_kindle', book_id=entry.id, book_format=format['format'], convert=format['convert'])}}\">{{format['text']}}</a></li>\n                    {%endfor%}\n                    </ul>\n                </div>\n              {% endif %}\n            {% endif %}\n          {% if entry.reader_list and g.user.role_viewer() %}\n              <div class=\"btn-group\" role=\"group\">\n              {% if entry.reader_list|length > 1 %}\n                <button id=\"read-in-browser\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                  <span class=\"glyphicon glyphicon-book\"></span> {{_('Read in Browser')}}\n                  <span class=\"caret\"></span>\n                </button>\n                    <ul class=\"dropdown-menu\" aria-labelledby=\"read-in-browser\">\n                    {% for format in entry.reader_list %}\n                      <li><a target=\"_blank\" href=\"{{ url_for('web.read_book', book_id=entry.id, book_format=format) }}\">{{format}}</a></li>\n                    {%endfor%}\n                    </ul>\n                {% else %}\n                  <a target=\"_blank\" href=\"{{url_for('web.read_book', book_id=entry.id, book_format=entry.reader_list[0])}}\" id=\"readbtn\" class=\"btn btn-primary\" role=\"button\"><span class=\"glyphicon glyphicon-book\"></span> {{_('Read in Browser')}} - {{entry.reader_list[0]}}</a>\n                {% endif %}\n              </div>\n            {% endif %}\n            {% if entry.audioentries|length > 0 and g.user.role_viewer() %}\n              <div class=\"btn-group\" role=\"group\">\n              {% if entry.audioentries|length > 1 %}\n                <button id=\"listen-in-browser\" type=\"button\" class=\"btn btn-primary dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                  <span class=\"glyphicon glyphicon-music\"></span> {{_('Listen in Browser')}}\n                  <span class=\"caret\"></span>\n                </button>\n                    <ul class=\"dropdown-menu\" aria-labelledby=\"listen-in-browser\">\n                    {% for format in entry.reader_list %}\n                      <li><a target=\"_blank\" href=\"{{ url_for('web.read_book', book_id=entry.id, book_format=format) }}\">{{format}}</a></li>\n                    {%endfor%}\n                    </ul>\n                  <ul class=\"dropdown-menu\" aria-labelledby=\"listen-in-browser\">\n\n              {% for format in entry.data %}\n                  {% if format.format|lower in entry.audioentries %}\n                    <li><a target=\"_blank\" href=\"{{ url_for('web.read_book', book_id=entry.id, book_format=format.format|lower) }}\">{{format.format|lower }}</a></li>\n                    {% endif %}\n              {% endfor %}\n                  </ul>\n                {% else %}\n                  <a target=\"_blank\" href=\"{{url_for('web.read_book', book_id=entry.id, book_format=entry.audioentries[0])}}\" id=\"listenbtn\" class=\"btn btn-primary\" role=\"button\"><span class=\"glyphicon glyphicon-music\"></span> {{_('Listen in Browser')}} - {{entry.audioentries[0]}}</a>\n                {% endif %}\n              </div>\n            {% endif %}\n        </div>\n      </div>\n      <h2 id=\"title\">{{entry.title}}</h2>\n      <p class=\"author\">\n          {% for author in entry.ordered_authors %}\n            <a href=\"{{url_for('web.books_list',  data='author', sort_param='stored', book_id=author.id ) }}\">{{author.name.replace('|',',')}}</a>\n            {% if not loop.last %}\n              &amp;\n            {% endif %}\n          {% endfor %}\n        </p>\n      {% if entry.ratings.__len__() > 0 %}\n        <div class=\"rating\">\n        <p>\n          {% for number in range((entry.ratings[0].rating/2)|int(2)) %}\n            <span class=\"glyphicon glyphicon-star good\"></span>\n            {% if loop.last and loop.index < 5 %}\n              {% for numer in range(5 - loop.index) %}\n                <span class=\"glyphicon glyphicon-star-empty\"></span>\n              {% endfor %}\n            {% endif %}\n          {% endfor %}\n        </p>\n        </div>\n      {% endif %}\n      {% if entry.series|length > 0 %}\n          <p>{{_(\"Book %(index)s of %(range)s\", index=entry.series_index | formatfloat(2), range=(url_for('web.books_list', data='series', sort_param='stored', book_id=entry.series[0].id)|escapedlink(entry.series[0].name))|safe)}}</p>\n\n      {% endif %}\n\n      {% if entry.languages.__len__() > 0 %}\n       <div class=\"languages\">\n       <p>\n      <span class=\"label label-default\">{{_('Language')}}: {% for language in entry.languages %}{{language.language_name}}{% if not loop.last %}, {% endif %}{% endfor %}</span>\n      </p>\n      </div>\n      {% endif %}\n\n      {% if entry.identifiers|length > 0 %}\n      <div class=\"identifiers\">\n        <p>\n        <span class=\"glyphicon glyphicon-link\"></span>\n        {% for identifier in entry.identifiers %}\n          <a href=\"{{identifier}}\" target=\"_blank\" class=\"btn btn-xs btn-success\" role=\"button\">{{identifier.format_type()}}</a>\n        {%endfor%}\n      </p>\n      </div>\n      {% endif %}\n\n      {% if entry.tags|length > 0 %}\n\n      <div class=\"tags\">\n      <p>\n        <span class=\"glyphicon glyphicon-tags\"></span>\n\n        {% for tag in entry.tags %}\n          <a href=\"{{ url_for('web.books_list', data='category', sort_param='stored', book_id=tag.id) }}\" class=\"btn btn-xs btn-info\" role=\"button\">{{tag.name}}</a>\n        {%endfor%}\n      </p>\n\n      </div>\n      {% endif %}\n\n      {% if entry.publishers|length > 0 %}\n      <div class=\"publishers\">\n        <p>\n          <span>{{_('Publisher')}}:\n              <a href=\"{{url_for('web.books_list', data='publisher', sort_param='stored', book_id=entry.publishers[0].id ) }}\">{{entry.publishers[0].name}}</a>\n          </span>\n        </p>\n      </div>\n      {% endif %}\n\n      {% if (entry.pubdate|string)[:10] != '0101-01-01' %}\n      <div class=\"publishing-date\">\n        <p>{{_('Published')}}: {{entry.pubdate|formatdate}} </p>\n      </div>\n      {% endif %}\n      {% if cc|length > 0 %}\n\n\n        {% for c in cc %}\n        <div class=\"real_custom_columns\">\n          {% if entry['custom_column_' ~ c.id]|length > 0 %}\n            {{ c.name }}:\n            {% for column in entry['custom_column_' ~ c.id] %}\n              {% if c.datatype == 'rating' %}\n                {{ (column.value / 2)|formatfloat }}\n              {% else %}\n                {% if c.datatype == 'bool' %}\n                  {% if column.value == true %}\n                    <span class=\"glyphicon glyphicon-ok\"></span>\n                  {% else %}\n                    <span class=\"glyphicon glyphicon-remove\"></span>\n                  {% endif %}\n                {% else %}\n                {% if c.datatype == 'float' %}\n                  {{ column.value|formatfloat(2) }}\n                {% elif c.datatype == 'datetime' %}\n                  {{ column.value|formatdate }}\n                {% elif c.datatype == 'comments' %}\n                  {{column.value|safe}}\n                {% elif c.datatype == 'series' %}\n                  {{ '%s [%s]' % (column.value, column.extra|formatfloat(2)) }}\n                {% elif c.datatype == 'text' %}\n                    {{ column.value.strip() }}{% if not loop.last %}, {% endif %}\n                {% else %}\n                  {{ column.value }}\n                {% endif %}\n                {% endif %}\n              {% endif %}\n            {% endfor %}\n          {% endif %}\n        </div>\n        {% endfor %}\n      {% endif %}\n      {% if not g.user.is_anonymous %}\n\n        <div class=\"custom_columns\">\n          <p>\n          <form id=\"have_read_form\" action=\"{{ url_for('web.toggle_read', book_id=entry.id)}}\" method=\"POST\">\n            <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n            <label class=\"block-label\">\n              <input id=\"have_read_cb\" data-checked=\"{{_('Mark As Unread')}}\" data-unchecked=\"{{_('Mark As Read')}}\" type=\"checkbox\" {% if entry.read_status %}checked{% endif %} >\n              <span>{{_('Read')}}</span>\n            </label>\n          </form>\n          </p>\n          {% if g.user.check_visibility(32768) %}\n          <p>\n            <form id=\"archived_form\" action=\"{{ url_for('web.toggle_archived', book_id=entry.id)}}\" method=\"POST\">\n              <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n              <label class=\"block-label\">\n                <input id=\"archived_cb\" data-checked=\"{{_('Restore from archive')}}\" data-unchecked=\"{{_('Add to archive')}}\" type=\"checkbox\" {% if entry.is_archived %}checked{% endif %} >\n                <span>{{_('Archived')}}</span>\n              </label>\n            </form>\n          </p>\n          {% endif %}\n        </div>\n      {% endif %}\n\n\n      {% if entry.comments|length > 0 and entry.comments[0].text|length > 0%}\n        <div class=\"comments\">\n            <h3 id=\"decription\">{{_('Description:')}}</h3>\n            {{entry.comments[0].text|safe}}\n        </div>\n      {% endif %}\n\n\n      <div class=\"more-stuff\">\n\n      {% if g.user.is_authenticated %}\n      {% if g.user.shelf.all() or g.shelves_access %}\n      <div id=\"shelf-actions\" class=\"btn-toolbar\" role=\"toolbar\">\n        <div class=\"btn-group\" role=\"group\" aria-label=\"Add to shelves\">\n          <button id=\"add-to-shelf\" type=\"button\" class=\"btn btn-primary btn-sm dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">\n            <span class=\"glyphicon glyphicon-list\"></span> {{_('Add to shelf')}}\n            <span class=\"caret\"></span>\n          </button>\n          <ul id=\"add-to-shelves\" class=\"dropdown-menu\" aria-labelledby=\"add-to-shelf\">\n            {% for shelf in g.shelves_access %}\n              {% if not shelf.id in books_shelfs and ( not shelf.is_public or g.user.role_edit_shelfs() ) %}\n                <li>\n                  <a data-href=\"{{ url_for('shelf.add_to_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                     data-remove-href=\"{{ url_for('shelf.remove_from_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                     data-shelf-action=\"add\"\n                  >\n                    {{shelf.name}}{% if shelf.is_public == 1 %} {{_('(Public)')}}{% endif %}\n                  </a>\n                </li>\n              {% endif %}\n            {%endfor%}\n          </ul>\n        </div>\n        <div id=\"remove-from-shelves\" class=\"btn-group\" role=\"group\" aria-label=\"Remove from shelves\">\n          {% if books_shelfs %}\n            {% for shelf in g.shelves_access %}\n              {% if shelf.id in books_shelfs %}\n                <a data-href=\"{{ url_for('shelf.remove_from_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                   data-add-href=\"{{ url_for('shelf.add_to_shelf', book_id=entry.id, shelf_id=shelf.id) }}\"\n                   class=\"btn btn-sm btn-default\" role=\"button\" data-shelf-action=\"remove\"\n                >\n                  <span {% if not shelf.is_public or g.user.role_edit_shelfs() %}\n                        class=\"glyphicon glyphicon-remove\"\n                        {% endif %}></span> {{shelf.name}}{% if shelf.is_public == 1 %} {{_('(Public)')}}{% endif %}\n                </a>\n              {% endif %}\n            {%endfor%}\n          {% endif %}\n        </div>\n        <div id=\"shelf-action-errors\" class=\"pull-left\" role=\"alert\"></div>\n      </div>\n      {% endif %}\n\n      {% endif %}\n      {% if g.user.role_edit() %}\n      <div class=\"btn-toolbar\" role=\"toolbar\">\n        <div class=\"btn-group\" role=\"group\" aria-label=\"Edit/Delete book\">\n          <a href=\"{{ url_for('edit-book.edit_book', book_id=entry.id) }}\" class=\"btn btn-sm btn-primary\" id=\"edit_book\" role=\"button\"><span class=\"glyphicon glyphicon-edit\"></span> {{_('Edit Metadata')}}</a>\n        </div>\n      </div>\n      {% endif %}\n      </div>\n\n    </div>\n  </div>\n</div>\n{% endblock %}\n\n{% block js %}\n<script type=\"text/template\" id=\"template-shelf-add\">\n  <li>\n    <a data-href=\"<%= add %>\" data-remove-href=\"<%= remove %>\" data-shelf-action=\"add\">\n      <%= content %>\n    </a>\n  </li>\n</script>\n<script type=\"text/template\" id=\"template-shelf-remove\">\n  <a data-href=\"<%= remove %>\" data-add-href=\"<%= add %>\" class=\"btn btn-sm btn-default\" data-shelf-action=\"remove\">\n    <span class=\"glyphicon glyphicon-remove\"></span> <%= content %>\n  </a>\n</script>\n<script src=\"{{ url_for('static', filename='js/details.js') }}\"></script>\n<script src=\"{{ url_for('static', filename='js/fullscreen.js') }}\"></script>\n{% endblock %}\n", "{% from 'modal_dialogs.html' import restrict_modal, delete_book, filechooser_modal, delete_confirm_modal, change_confirm_modal %}\n<!DOCTYPE html>\n<html lang=\"{{ g.user.locale }}\">\n  <head>\n    <title>{{instance}} | {{title}}</title>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n\n    <!-- Bootstrap -->\n    <link rel=\"apple-touch-icon\" sizes=\"140x140\" href=\"{{ url_for('static', filename='favicon.ico') }}\">\n    <link rel=\"shortcut icon\" href=\"{{ url_for('static', filename='favicon.ico') }}\">\n    <link href=\"{{ url_for('static', filename='css/libs/bootstrap.min.css') }}\" rel=\"stylesheet\" media=\"screen\">\n    {% block header %}{% endblock %}\n    <link href=\"{{ url_for('static', filename='css/style.css') }}\" rel=\"stylesheet\" media=\"screen\">\n    <link href=\"{{ url_for('static', filename='css/upload.css') }}\" rel=\"stylesheet\" media=\"screen\">\n    {% if g.current_theme == 1 %}\n       <link href=\"{{ url_for('static', filename='css/caliBlur.css') }}\" rel=\"stylesheet\" media=\"screen\">\n       <link href=\"{{ url_for('static', filename='css/caliBlur_override.css') }}\" rel=\"stylesheet\" media=\"screen\">\n    {% endif %}\n    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->\n    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->\n    <!--[if lt IE 9]>\n      <script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"></script>\n      <script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"></script>\n    <![endif]-->\n  </head>\n  <body class=\"{{ page }} {{ bodyClass }}\" data-text=\"{{_('Home')}}\" data-textback=\"{{_('Back')}}\">\n    <!-- Static navbar -->\n    <div class=\"navbar navbar-default navbar-static-top\" role=\"navigation\">\n      <div class=\"container-fluid\">\n        <div class=\"navbar-header\">\n          <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\">\n            <span class=\"sr-only\">{{_('Toggle Navigation')}}</span>\n            <span class=\"icon-bar\"></span>\n            <span class=\"icon-bar\"></span>\n            <span class=\"icon-bar\"></span>\n          </button>\n          <a class=\"navbar-brand\" href=\"{{url_for('web.index')}}\">{{instance}}</a>\n        </div>\n        {% if g.user.is_authenticated or g.allow_anonymous %}\n          <form class=\"navbar-form navbar-left\" role=\"search\" action=\"{{url_for('web.search')}}\" method=\"GET\">\n            <div class=\"form-group input-group input-group-sm\">\n              <label for=\"query\" class=\"sr-only\">{{_('Search')}}</label>\n              <input type=\"text\" class=\"form-control\" id=\"query\" name=\"query\" placeholder=\"{{_('Search Library')}}\" value=\"{{searchterm}}\">\n              <span class=\"input-group-btn\">\n                <button type=\"submit\" id=\"query_submit\" class=\"btn btn-default\">{{_('Search')}}</button>\n              </span>\n            </div>\n          </form>\n        {% endif %}\n        <div class=\"navbar-collapse collapse\">\n          {% if g.user.is_authenticated or g.allow_anonymous %}\n          <ul class=\"nav navbar-nav \">\n            <li><a href=\"{{url_for('web.advanced_search')}}\" id=\"advanced_search\"><span class=\"glyphicon glyphicon-search\"></span><span class=\"hidden-sm\"> {{_('Advanced Search')}}</span></a></li>\n          </ul>\n          {% endif %}\n          <ul class=\"nav navbar-nav navbar-right\" id=\"main-nav\">\n            {% if g.user.is_authenticated or g.allow_anonymous %}\n              {% if g.user.role_upload() and g.allow_upload %}\n                  <li>\n                    <form id=\"form-upload\" class=\"navbar-form\" action=\"{{ url_for('edit-book.upload') }}\" data-title=\"{{_('Uploading...')}}\" data-footer=\"{{_('Close')}}\" data-failed=\"{{_('Error')}}\" data-message=\"{{_('Upload done, processing, please wait...')}}\" method=\"post\" enctype=\"multipart/form-data\">\n                      <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n                      <div class=\"form-group\">\n                        <span class=\"btn btn-default btn-file\">{{_('Upload')}}<input id=\"btn-upload\" name=\"btn-upload\"\n                        type=\"file\" accept=\"{% for format in accept %}.{% if format != ''%}{{format}}{% else %}*{% endif %}{{ ',' if not loop.last }}{% endfor %}\" multiple></span>\n                      </div>\n                    </form>\n                  </li>\n              {% endif %}\n              {% if not g.user.is_anonymous %}\n                <li><a id=\"top_tasks\" href=\"{{url_for('web.get_tasks_status')}}\"><span class=\"glyphicon glyphicon-tasks\"></span> <span class=\"hidden-sm\">{{_('Tasks')}}</span></a></li>\n              {% endif %}\n              {% if g.user.role_admin() %}\n                <li><a id=\"top_admin\" data-text=\"{{_('Settings')}}\" href=\"{{url_for('admin.admin')}}\"><span class=\"glyphicon glyphicon-dashboard\"></span> <span class=\"hidden-sm\">{{_('Admin')}}</span></a></li>\n              {% endif %}\n              <li><a id=\"top_user\" data-text=\"{{_('Account')}}\" href=\"{{url_for('web.profile')}}\"><span class=\"glyphicon glyphicon-user\"></span> <span class=\"hidden-sm\">{{g.user.name}}</span></a></li>\n              {% if not g.user.is_anonymous %}\n              <li><a id=\"logout\" href=\"{{url_for('web.logout')}}\"><span class=\"glyphicon glyphicon-log-out\"></span> <span class=\"hidden-sm\">{{_('Logout')}}</span></a></li>\n              {% endif %}\n            {% endif %}\n            {% if g.allow_registration and not g.user.is_authenticated %}\n            <li><a id=\"login\" href=\"{{url_for('web.login')}}\"><span class=\"glyphicon glyphicon-log-in\"></span> {{_('Login')}}</a></li>\n            <li><a id=\"register\" href=\"{{url_for('web.register')}}\"><span class=\"glyphicon glyphicon-user\"></span> {{_('Register')}}</a></li>\n            {% endif %}\n          </ul>\n        </div><!--/.nav-collapse -->\n      </div>\n    </div>\n    {% for message in get_flashed_messages(with_categories=True) %}\n      {%if message[0] == \"error\" %}\n      <div class=\"row-fluid text-center\" >\n        <div id=\"flash_danger\" class=\"alert alert-danger\">{{ message[1] }}</div>\n      </div>\n      {%endif%}\n      {%if message[0] == \"info\" %}\n      <div class=\"row-fluid text-center\">\n        <div id=\"flash_info\" class=\"alert alert-info\">{{ message[1] }}</div>\n      </div>\n      {%endif%}\n      {%if message[0] == \"warning\" %}\n      <div class=\"row-fluid text-center\">\n        <div id=\"flash_warning\" class=\"alert alert-warning\">{{ message[1] }}</div>\n      </div>\n      {%endif%}\n      {%if message[0] == \"success\" %}\n      <div class=\"row-fluid text-center\">\n        <div id=\"flash_success\" class=\"alert alert-success\">{{ message[1] }}</div>\n      </div>\n      {%endif%}\n    {% endfor %}\n    {% block flash %}{% endblock %}\n    {% if g.current_theme == 1 %}\n      <div id=\"loader\" hidden=\"true\">\n        <center>\n          <h3>{{_('Uploading...')}}</h3>\n          <span>{{_(\"Please do not refresh the page\")}}</span>.\n        </center>\n      </div>\n    {%endif%}\n    <div class=\"container-fluid\">\n      <div class=\"row-fluid\">\n        {% if g.user.is_authenticated or g.allow_anonymous %}\n        <div class=\"col-sm-2\">\n          <nav class=\"navigation\">\n            <ul class=\"list-unstyled\" id=\"scnd-nav\" intent in-standard-append=\"nav.navigation\" in-mobile-after=\"#main-nav\" in-mobile-class=\"nav navbar-nav\">\n              <li class=\"nav-head hidden-xs\">{{_('Browse')}}</li>\n              {% for element in sidebar %}\n                {% if g.user.check_visibility(element['visibility']) and element['public'] %}\n                    <li id=\"nav_{{element['id']}}\" {% if page == element['page'] %}class=\"active\"{% endif %}><a href=\"{{url_for(element['link'], data=element['page'], sort_param='stored')}}\"><span class=\"glyphicon {{element['glyph']}}\"></span> {{_(element['text'])}}</a></li>\n                {% endif %}\n              {% endfor %}\n              {% if g.user.is_authenticated or g.allow_anonymous %}\n                <li class=\"nav-head hidden-xs public-shelves\">{{_('Shelves')}}</li>\n                {% for shelf in g.shelves_access %}\n                  <li><a href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id)}}\"><span class=\"glyphicon glyphicon-list shelf\"></span> {{shelf.name|shortentitle(40)}}{% if shelf.is_public == 1 %} {{_('(Public)')}}{% endif %}</a></li>\n                {% endfor %}\n              {% if not g.user.is_anonymous %}\n                <li id=\"nav_createshelf\" class=\"create-shelf\"><a href=\"{{url_for('shelf.create_shelf')}}\">{{_('Create a Shelf')}}</a></li>\n                <li id=\"nav_about\" {% if page == 'stat' %}class=\"active\"{% endif %}><a href=\"{{url_for('about.stats')}}\"><span class=\"glyphicon glyphicon-info-sign\"></span> {{_('About')}}</a></li>\n              {% endif %}\n              {% endif %}\n\n            </ul>\n          </nav>\n        </div>\n        {% endif %}\n        <div class=\"col-sm-10\">\n          {% block body %}{% endblock %}\n          {% if pagination and (pagination.has_next or pagination.has_prev) %}\n            <div class=\"pagination\">\n              {% if pagination.has_prev %}\n              <li class=\"page-item page-previous\"><a class=\"page-link\" aria-label=\"next page\" href=\"{{ (pagination.page - 1)|url_for_other_page\n                }}\">&laquo; {{_('Previous')}}</a></li>\n              {% endif %}\n            {% for page in pagination.iter_pages() %}\n              {% if page %}\n                {% if page != pagination.page %}\n                  <li class=\"page-item\"><a class=\"page-link\" aria-label=\"to page {{ page }}\" href=\"{{ (page)|url_for_other_page }}\">{{ page }}</a></li>\n                {% else %}\n                  <li class=\"page-item active\"><a class=\"page-link\" aria-label=\"to page {{ page }}\" href=\"{{ (page)|url_for_other_page }}\">{{ page }}</a></li>\n                {% endif %}\n              {% else %}\n                <li class=\"page-item page-last-separator disabled\"><a class=\"page-link\" aria-label=\"\">\u2026</a></li>\n              {% endif %}\n            {% endfor %}\n            {% if pagination.has_next %}\n              <li class=\"page-item page-next\"><a class=\"page-link next\" aria-label=\"next page\" href=\"{{ (pagination.page + 1)|url_for_other_page\n                }}\">{{_('Next')}} &raquo;</a></li>\n            {% endif %}\n            </div>\n          {% endif %}\n      </div>\n    </div>\n  </div>\n    <div class=\"modal fade\" id=\"bookDetailsModal\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"bookDetailsModalLabel\">\n      <div class=\"modal-dialog modal-lg\" role=\"document\">\n        <div class=\"modal-content\">\n          <div class=\"modal-header\">\n            <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>\n            <h4 class=\"modal-title\" id=\"bookDetailsModalLabel\">{{_('Book Details')}}</h4>\n          </div>\n          <div class=\"modal-body\">...</div>\n          <div class=\"modal-footer\">\n            <button type=\"button\" id=\"details_close\" class=\"btn btn-default\" data-dismiss=\"modal\">{{_('Close')}}</button>\n          </div>\n        </div>\n      </div>\n    </div>\n    {% block modal %}{% endblock %}\n    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->\n    <script src=\"{{ url_for('static', filename='js/libs/jquery.min.js') }}\"></script>\n    <!-- Include all compiled plugins (below), or include individual files as needed -->\n    <script src=\"{{ url_for('static', filename='js/libs/bootstrap.min.js') }}\"></script>\n    <script src=\"{{ url_for('static', filename='js/libs/underscore-umd-min.js') }}\"></script>\n    <script src=\"{{ url_for('static', filename='js/libs/intention.min.js') }}\"></script>\n    <script src=\"{{ url_for('static', filename='js/libs/context.min.js') }}\"></script>\n    <script src=\"{{ url_for('static', filename='js/libs/plugins.js') }}\"></script>\n    <script src=\"{{ url_for('static', filename='js/libs/jquery.form.min.js') }}\"></script>\n    <script src=\"{{ url_for('static', filename='js/uploadprogress.js') }}\"> </script>\n    <script src=\"{{ url_for('static', filename='js/main.js') }}\"></script>\n    {% if g.current_theme == 1 %}\n      <script src=\"{{ url_for('static', filename='js/libs/jquery.visible.min.js') }}\"></script>\n      <script src=\"{{ url_for('static', filename='js/libs/compromise.min.js') }}\"></script>\n      <script src=\"{{ url_for('static', filename='js/libs/readmore.min.js') }}\"></script>\n      <script src=\"{{ url_for('static', filename='js/caliBlur.js') }}\"></script>\n    {% endif %}\n    {% block js %}{% endblock %}\n  </body>\n</html>\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2020 OzzieIsaacs\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport base64\nimport binascii\nfrom functools import wraps\n\nfrom sqlalchemy.sql.expression import func\nfrom werkzeug.security import check_password_hash\nfrom flask_login import login_required, login_user\n\nfrom . import lm, ub, config, constants, services\n\n\ndef login_required_if_no_ano(func):\n    @wraps(func)\n    def decorated_view(*args, **kwargs):\n        if config.config_anonbrowse == 1:\n            return func(*args, **kwargs)\n        return login_required(func)(*args, **kwargs)\n\n    return decorated_view\n\n\ndef _fetch_user_by_name(username):\n    return ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first()\n\n\n@lm.user_loader\ndef load_user(user_id):\n    return ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n\n\n@lm.request_loader\ndef load_user_from_request(request):\n    if config.config_allow_reverse_proxy_header_login:\n        rp_header_name = config.config_reverse_proxy_login_header_name\n        if rp_header_name:\n            rp_header_username = request.headers.get(rp_header_name)\n            if rp_header_username:\n                user = _fetch_user_by_name(rp_header_username)\n                if user:\n                    login_user(user)\n                    return user\n\n    auth_header = request.headers.get(\"Authorization\")\n    if auth_header:\n        user = load_user_from_auth_header(auth_header)\n        if user:\n            return user\n\n    return\n\n\ndef load_user_from_auth_header(header_val):\n    if header_val.startswith('Basic '):\n        header_val = header_val.replace('Basic ', '', 1)\n    basic_username = basic_password = ''  # nosec\n    try:\n        header_val = base64.b64decode(header_val).decode('utf-8')\n        # Users with colon are invalid: rfc7617 page 4\n        basic_username = header_val.split(':', 1)[0]\n        basic_password = header_val.split(':', 1)[1]\n    except (TypeError, UnicodeDecodeError, binascii.Error):\n        pass\n    user = _fetch_user_by_name(basic_username)\n    if user and config.config_login_type == constants.LOGIN_LDAP and services.ldap:\n        if services.ldap.bind_user(str(user.password), basic_password):\n            return user\n    if user and check_password_hash(str(user.password), basic_password):\n        return user\n    return\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nfrom datetime import datetime\nimport json\nimport mimetypes\nimport chardet  # dependency of requests\nimport copy\nfrom functools import wraps\n\nfrom babel.dates import format_date\nfrom babel import Locale\nfrom flask import Blueprint, jsonify\nfrom flask import request, redirect, send_from_directory, make_response, flash, abort, url_for\nfrom flask import session as flask_session\nfrom flask_babel import gettext as _\nfrom flask_login import login_user, logout_user, login_required, current_user\nfrom sqlalchemy.exc import IntegrityError, InvalidRequestError, OperationalError\nfrom sqlalchemy.sql.expression import text, func, false, not_, and_, or_\nfrom sqlalchemy.orm.attributes import flag_modified\nfrom sqlalchemy.sql.functions import coalesce\n\nfrom .services.worker import WorkerThread\n\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\nfrom . import constants, logger, isoLanguages, services\nfrom . import babel, db, ub, config, get_locale, app\nfrom . import calibre_db, kobo_sync_status\nfrom .gdriveutils import getFileFromEbooksFolder, do_gdrive_download\nfrom .helper import check_valid_domain, render_task_status, check_email, check_username, \\\n    get_cc_columns, get_book_cover, get_download_link, send_mail, generate_random_password, \\\n    send_registration_mail, check_send_to_kindle, check_read_formats, tags_filters, reset_password, valid_email, \\\n    edit_book_read_status\nfrom .pagination import Pagination\nfrom .redirect import redirect_back\nfrom .usermanagement import login_required_if_no_ano\nfrom .kobo_sync_status import remove_synced_book\nfrom .render_template import render_title_template\nfrom .kobo_sync_status import change_archived_books\n\nfeature_support = {\n    'ldap': bool(services.ldap),\n    'goodreads': bool(services.goodreads_support),\n    'kobo': bool(services.kobo)\n}\n\ntry:\n    from .oauth_bb import oauth_check, register_user_with_oauth, logout_oauth_user, get_oauth_status\n\n    feature_support['oauth'] = True\nexcept ImportError:\n    feature_support['oauth'] = False\n    oauth_check = {}\n    register_user_with_oauth = logout_oauth_user = get_oauth_status = None\n\ntry:\n    from natsort import natsorted as sort\nexcept ImportError:\n    sort = sorted  # Just use regular sort then, may cause issues with badly named pages in cbz/cbr files\n\n\n@app.after_request\ndef add_security_headers(resp):\n    csp = \"default-src 'self'\"\n    csp += ''.join([' ' + host for host in config.config_trustedhosts.strip().split(',')])\n    csp += \" 'unsafe-inline' 'unsafe-eval'; font-src 'self' data:; img-src 'self' data:\"\n    resp.headers['Content-Security-Policy'] = csp\n    if request.endpoint == \"edit-book.edit_book\" or config.config_use_google_drive:\n        resp.headers['Content-Security-Policy'] += \" *\"\n    elif request.endpoint == \"web.read_book\":\n        resp.headers['Content-Security-Policy'] += \" blob:;style-src-elem 'self' blob: 'unsafe-inline';\"\n    resp.headers['X-Content-Type-Options'] = 'nosniff'\n    resp.headers['X-Frame-Options'] = 'SAMEORIGIN'\n    resp.headers['X-XSS-Protection'] = '1; mode=block'\n    resp.headers['Strict-Transport-Security'] = 'max-age=31536000;'\n    return resp\n\n\nweb = Blueprint('web', __name__)\nlog = logger.create()\n\n\n# ################################### Login logic and rights management ###############################################\n\n\ndef download_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_download():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n\ndef viewer_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_viewer():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n\n# ################################### data provider functions #########################################################\n\n\n@web.route(\"/ajax/emailstat\")\n@login_required\ndef get_email_status_json():\n    tasks = WorkerThread.getInstance().tasks\n    return jsonify(render_task_status(tasks))\n\n\n@web.route(\"/ajax/bookmark/<int:book_id>/<book_format>\", methods=['POST'])\n@login_required\ndef set_bookmark(book_id, book_format):\n    bookmark_key = request.form[\"bookmark\"]\n    ub.session.query(ub.Bookmark).filter(and_(ub.Bookmark.user_id == int(current_user.id),\n                                              ub.Bookmark.book_id == book_id,\n                                              ub.Bookmark.format == book_format)).delete()\n    if not bookmark_key:\n        ub.session_commit()\n        return \"\", 204\n\n    l_bookmark = ub.Bookmark(user_id=current_user.id,\n                             book_id=book_id,\n                             format=book_format,\n                             bookmark_key=bookmark_key)\n    ub.session.merge(l_bookmark)\n    ub.session_commit(\"Bookmark for user {} in book {} created\".format(current_user.id, book_id))\n    return \"\", 201\n\n\n@web.route(\"/ajax/toggleread/<int:book_id>\", methods=['POST'])\n@login_required\ndef toggle_read(book_id):\n    message = edit_book_read_status(book_id)\n    if message:\n        return message, 400\n    else:\n        return message\n\n\n@web.route(\"/ajax/togglearchived/<int:book_id>\", methods=['POST'])\n@login_required\ndef toggle_archived(book_id):\n    is_archived = change_archived_books(book_id, message=\"Book {} archive bit toggled\".format(book_id))\n    if is_archived:\n        remove_synced_book(book_id)\n    return \"\"\n\n\n@web.route(\"/ajax/view\", methods=[\"POST\"])\n@login_required_if_no_ano\ndef update_view():\n    to_save = request.get_json()\n    try:\n        for element in to_save:\n            for param in to_save[element]:\n                current_user.set_view_property(element, param, to_save[element][param])\n    except Exception as ex:\n        log.error(\"Could not save view_settings: %r %r: %e\", request, to_save, ex)\n        return \"Invalid request\", 400\n    return \"1\", 200\n\n\n'''\n@web.route(\"/ajax/getcomic/<int:book_id>/<book_format>/<int:page>\")\n@login_required\ndef get_comic_book(book_id, book_format, page):\n    book = calibre_db.get_book(book_id)\n    if not book:\n        return \"\", 204\n    else:\n        for bookformat in book.data:\n            if bookformat.format.lower() == book_format.lower():\n                cbr_file = os.path.join(config.config_calibre_dir, book.path, bookformat.name) + \".\" + book_format\n                if book_format in (\"cbr\", \"rar\"):\n                    if feature_support['rar'] == True:\n                        rarfile.UNRAR_TOOL = config.config_rarfile_location\n                        try:\n                            rf = rarfile.RarFile(cbr_file)\n                            names = sort(rf.namelist())\n                            extract = lambda page: rf.read(names[page])\n                        except:\n                            # rarfile not valid\n                            log.error('Unrar binary not found, or unable to decompress file %s', cbr_file)\n                            return \"\", 204\n                    else:\n                        log.info('Unrar is not supported please install python rarfile extension')\n                        # no support means return nothing\n                        return \"\", 204\n                elif book_format in (\"cbz\", \"zip\"):\n                    zf = zipfile.ZipFile(cbr_file)\n                    names=sort(zf.namelist())\n                    extract = lambda page: zf.read(names[page])\n                elif book_format in (\"cbt\", \"tar\"):\n                    tf = tarfile.TarFile(cbr_file)\n                    names=sort(tf.getnames())\n                    extract = lambda page: tf.extractfile(names[page]).read()\n                else:\n                    log.error('unsupported comic format')\n                    return \"\", 204\n\n                b64 = codecs.encode(extract(page), 'base64').decode()\n                ext = names[page].rpartition('.')[-1]\n                if ext not in ('png', 'gif', 'jpg', 'jpeg', 'webp'):\n                    ext = 'png'\n                extractedfile=\"data:image/\" + ext + \";base64,\" + b64\n                fileData={\"name\": names[page], \"page\":page, \"last\":len(names)-1, \"content\": extractedfile}\n                return make_response(json.dumps(fileData))\n        return \"\", 204\n'''\n\n\n# ################################### Typeahead ##################################################################\n\n\n@web.route(\"/get_authors_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_authors_json():\n    return calibre_db.get_typeahead(db.Authors, request.args.get('q'), ('|', ','))\n\n\n@web.route(\"/get_publishers_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_publishers_json():\n    return calibre_db.get_typeahead(db.Publishers, request.args.get('q'), ('|', ','))\n\n\n@web.route(\"/get_tags_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_tags_json():\n    return calibre_db.get_typeahead(db.Tags, request.args.get('q'), tag_filter=tags_filters())\n\n\n@web.route(\"/get_series_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_series_json():\n    return calibre_db.get_typeahead(db.Series, request.args.get('q'))\n\n\n@web.route(\"/get_languages_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_languages_json():\n    query = (request.args.get('q') or '').lower()\n    language_names = isoLanguages.get_language_names(get_locale())\n    entries_start = [s for key, s in language_names.items() if s.lower().startswith(query.lower())]\n    if len(entries_start) < 5:\n        entries = [s for key, s in language_names.items() if query in s.lower()]\n        entries_start.extend(entries[0:(5 - len(entries_start))])\n        entries_start = list(set(entries_start))\n    json_dumps = json.dumps([dict(name=r) for r in entries_start[0:5]])\n    return json_dumps\n\n\n@web.route(\"/get_matching_tags\", methods=['GET'])\n@login_required_if_no_ano\ndef get_matching_tags():\n    tag_dict = {'tags': []}\n    q = calibre_db.session.query(db.Books).filter(calibre_db.common_filters(True))\n    calibre_db.session.connection().connection.connection.create_function(\"lower\", 1, db.lcase)\n    author_input = request.args.get('author_name') or ''\n    title_input = request.args.get('book_title') or ''\n    include_tag_inputs = request.args.getlist('include_tag') or ''\n    exclude_tag_inputs = request.args.getlist('exclude_tag') or ''\n    q = q.filter(db.Books.authors.any(func.lower(db.Authors.name).ilike(\"%\" + author_input + \"%\")),\n                 func.lower(db.Books.title).ilike(\"%\" + title_input + \"%\"))\n    if len(include_tag_inputs) > 0:\n        for tag in include_tag_inputs:\n            q = q.filter(db.Books.tags.any(db.Tags.id == tag))\n    if len(exclude_tag_inputs) > 0:\n        for tag in exclude_tag_inputs:\n            q = q.filter(not_(db.Books.tags.any(db.Tags.id == tag)))\n    for book in q:\n        for tag in book.tags:\n            if tag.id not in tag_dict['tags']:\n                tag_dict['tags'].append(tag.id)\n    json_dumps = json.dumps(tag_dict)\n    return json_dumps\n\n\ndef generate_char_list(data_colum, db_link):\n    return (calibre_db.session.query(func.upper(func.substr(data_colum, 1, 1)).label('char'))\n            .join(db_link).join(db.Books).filter(calibre_db.common_filters())\n            .group_by(func.upper(func.substr(data_colum, 1, 1))).all())\n\n\ndef get_sort_function(sort_param, data):\n    order = [db.Books.timestamp.desc()]\n    if sort_param == 'stored':\n        sort_param = current_user.get_view_property(data, 'stored')\n    else:\n        current_user.set_view_property(data, 'stored', sort_param)\n    if sort_param == 'pubnew':\n        order = [db.Books.pubdate.desc()]\n    if sort_param == 'pubold':\n        order = [db.Books.pubdate]\n    if sort_param == 'abc':\n        order = [db.Books.sort]\n    if sort_param == 'zyx':\n        order = [db.Books.sort.desc()]\n    if sort_param == 'new':\n        order = [db.Books.timestamp.desc()]\n    if sort_param == 'old':\n        order = [db.Books.timestamp]\n    if sort_param == 'authaz':\n        order = [db.Books.author_sort.asc(), db.Series.name, db.Books.series_index]\n    if sort_param == 'authza':\n        order = [db.Books.author_sort.desc(), db.Series.name.desc(), db.Books.series_index.desc()]\n    if sort_param == 'seriesasc':\n        order = [db.Books.series_index.asc()]\n    if sort_param == 'seriesdesc':\n        order = [db.Books.series_index.desc()]\n    if sort_param == 'hotdesc':\n        order = [func.count(ub.Downloads.book_id).desc()]\n    if sort_param == 'hotasc':\n        order = [func.count(ub.Downloads.book_id).asc()]\n    if sort_param is None:\n        sort_param = \"new\"\n    return order, sort_param\n\n\ndef render_books_list(data, sort_param, book_id, page):\n    order = get_sort_function(sort_param, data)\n    if data == \"rated\":\n        return render_rated_books(page, book_id, order=order)\n    elif data == \"discover\":\n        return render_discover_books(page, book_id)\n    elif data == \"unread\":\n        return render_read_books(page, False, order=order)\n    elif data == \"read\":\n        return render_read_books(page, True, order=order)\n    elif data == \"hot\":\n        return render_hot_books(page, order)\n    elif data == \"download\":\n        return render_downloaded_books(page, order, book_id)\n    elif data == \"author\":\n        return render_author_books(page, book_id, order)\n    elif data == \"publisher\":\n        return render_publisher_books(page, book_id, order)\n    elif data == \"series\":\n        return render_series_books(page, book_id, order)\n    elif data == \"ratings\":\n        return render_ratings_books(page, book_id, order)\n    elif data == \"formats\":\n        return render_formats_books(page, book_id, order)\n    elif data == \"category\":\n        return render_category_books(page, book_id, order)\n    elif data == \"language\":\n        return render_language_books(page, book_id, order)\n    elif data == \"archived\":\n        return render_archived_books(page, order)\n    elif data == \"search\":\n        term = (request.args.get('query') or '')\n        offset = int(int(config.config_books_per_page) * (page - 1))\n        return render_search_results(term, offset, order, config.config_books_per_page)\n    elif data == \"advsearch\":\n        term = json.loads(flask_session['query'])\n        offset = int(int(config.config_books_per_page) * (page - 1))\n        return render_adv_search_results(term, offset, order, config.config_books_per_page)\n    else:\n        website = data or \"newest\"\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0, db.Books, True, order[0],\n                                                                False, 0,\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     title=_(u\"Books\"), page=website, order=order[1])\n\n\ndef render_rated_books(page, book_id, order):\n    if current_user.check_visibility(constants.SIDEBAR_BEST_RATED):\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.ratings.any(db.Ratings.rating > 9),\n                                                                order[0],\n                                                                False, 0,\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     id=book_id, title=_(u\"Top Rated Books\"), page=\"rated\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_discover_books(page, book_id):\n    if current_user.check_visibility(constants.SIDEBAR_RANDOM):\n        entries, __, pagination = calibre_db.fill_indexpage(page, 0, db.Books, True, [func.randomblob(2)])\n        pagination = Pagination(1, config.config_books_per_page, config.config_books_per_page)\n        return render_title_template('discover.html', entries=entries, pagination=pagination, id=book_id,\n                                     title=_(u\"Discover (Random Books)\"), page=\"discover\")\n    else:\n        abort(404)\n\n\ndef render_hot_books(page, order):\n    if current_user.check_visibility(constants.SIDEBAR_HOT):\n        if order[1] not in ['hotasc', 'hotdesc']:\n            # Unary expression comparsion only working (for this expression) in sqlalchemy 1.4+\n            # if not (order[0][0].compare(func.count(ub.Downloads.book_id).desc()) or\n            #        order[0][0].compare(func.count(ub.Downloads.book_id).asc())):\n            order = [func.count(ub.Downloads.book_id).desc()], 'hotdesc'\n        if current_user.show_detail_random():\n            random = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\\n                .order_by(func.random()).limit(config.config_random_books)\n        else:\n            random = false()\n        off = int(int(config.config_books_per_page) * (page - 1))\n        all_books = ub.session.query(ub.Downloads, func.count(ub.Downloads.book_id)) \\\n            .order_by(*order[0]).group_by(ub.Downloads.book_id)\n        hot_books = all_books.offset(off).limit(config.config_books_per_page)\n        entries = list()\n        for book in hot_books:\n            download_book = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()).filter(\n                db.Books.id == book.Downloads.book_id).first()\n            if download_book:\n                entries.append(download_book)\n            else:\n                ub.delete_download(book.Downloads.book_id)\n        num_books = entries.__len__()\n        pagination = Pagination(page, config.config_books_per_page, num_books)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     title=_(u\"Hot Books (Most Downloaded)\"), page=\"hot\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_downloaded_books(page, order, user_id):\n    if current_user.role_admin():\n        user_id = int(user_id)\n    else:\n        user_id = current_user.id\n    if current_user.check_visibility(constants.SIDEBAR_DOWNLOAD):\n        if current_user.show_detail_random():\n            random = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\\n                .order_by(func.random()).limit(config.config_random_books)\n        else:\n            random = false()\n\n        entries, __, pagination = calibre_db.fill_indexpage(page,\n                                                            0,\n                                                            db.Books,\n                                                            ub.Downloads.user_id == user_id,\n                                                            order[0],\n                                                            False, 0,\n                                                            db.books_series_link,\n                                                            db.Books.id == db.books_series_link.c.book,\n                                                            db.Series,\n                                                            ub.Downloads, db.Books.id == ub.Downloads.book_id)\n        for book in entries:\n            if not calibre_db.session.query(db.Books).\\\n                                            filter(calibre_db.common_filters()).filter(db.Books.id == book.id).first():\n                ub.delete_download(book.id)\n        user = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n        return render_title_template('index.html',\n                                     random=random,\n                                     entries=entries,\n                                     pagination=pagination,\n                                     id=user_id,\n                                     title=_(u\"Downloaded books by %(user)s\", user=user.name),\n                                     page=\"download\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_author_books(page, author_id, order):\n    entries, __, pagination = calibre_db.fill_indexpage(page, 0,\n                                                        db.Books,\n                                                        db.Books.authors.any(db.Authors.id == author_id),\n                                                        [order[0][0], db.Series.name, db.Books.series_index],\n                                                        False, 0,\n                                                        db.books_series_link,\n                                                        db.Books.id == db.books_series_link.c.book,\n                                                        db.Series)\n    if entries is None or not len(entries):\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),\n              category=\"error\")\n        return redirect(url_for(\"web.index\"))\n    if constants.sqlalchemy_version2:\n        author = calibre_db.session.get(db.Authors, author_id)\n    else:\n        author = calibre_db.session.query(db.Authors).get(author_id)\n    author_name = author.name.replace('|', ',')\n\n    author_info = None\n    other_books = []\n    if services.goodreads_support and config.config_use_goodreads:\n        author_info = services.goodreads_support.get_author_info(author_name)\n        other_books = services.goodreads_support.get_other_books(author_info, entries)\n    return render_title_template('author.html', entries=entries, pagination=pagination, id=author_id,\n                                 title=_(u\"Author: %(name)s\", name=author_name), author=author_info,\n                                 other_books=other_books, page=\"author\", order=order[1])\n\n\ndef render_publisher_books(page, book_id, order):\n    publisher = calibre_db.session.query(db.Publishers).filter(db.Publishers.id == book_id).first()\n    if publisher:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.publishers.any(db.Publishers.id == book_id),\n                                                                [db.Series.name, order[0][0], db.Books.series_index],\n                                                                False, 0,\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=book_id,\n                                     title=_(u\"Publisher: %(name)s\", name=publisher.name),\n                                     page=\"publisher\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_series_books(page, book_id, order):\n    name = calibre_db.session.query(db.Series).filter(db.Series.id == book_id).first()\n    if name:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.series.any(db.Series.id == book_id),\n                                                                [order[0][0]])\n        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,\n                                     title=_(u\"Series: %(serie)s\", serie=name.name), page=\"series\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_ratings_books(page, book_id, order):\n    name = calibre_db.session.query(db.Ratings).filter(db.Ratings.id == book_id).first()\n    entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                            db.Books,\n                                                            db.Books.ratings.any(db.Ratings.id == book_id),\n                                                            [order[0][0]])\n    if name and name.rating <= 10:\n        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,\n                                     title=_(u\"Rating: %(rating)s stars\", rating=int(name.rating / 2)),\n                                     page=\"ratings\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_formats_books(page, book_id, order):\n    name = calibre_db.session.query(db.Data).filter(db.Data.format == book_id.upper()).first()\n    if name:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.data.any(db.Data.format == book_id.upper()),\n                                                                [order[0][0]])\n        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,\n                                     title=_(u\"File format: %(format)s\", format=name.format),\n                                     page=\"formats\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_category_books(page, book_id, order):\n    name = calibre_db.session.query(db.Tags).filter(db.Tags.id == book_id).first()\n    if name:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.tags.any(db.Tags.id == book_id),\n                                                                [order[0][0], db.Series.name, db.Books.series_index],\n                                                                False, 0,\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=book_id,\n                                     title=_(u\"Category: %(name)s\", name=name.name), page=\"category\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_language_books(page, name, order):\n    try:\n        lang_name = isoLanguages.get_language_name(get_locale(), name)\n    except KeyError:\n        abort(404)\n\n    entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                            db.Books,\n                                                            db.Books.languages.any(db.Languages.lang_code == name),\n                                                            [order[0][0]])\n    return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=name,\n                                 title=_(u\"Language: %(name)s\", name=lang_name), page=\"language\", order=order[1])\n\n\ndef render_read_books(page, are_read, as_xml=False, order=None):\n    sort_param = order[0] if order else []\n    if not config.config_read_column:\n        if are_read:\n            db_filter = and_(ub.ReadBook.user_id == int(current_user.id),\n                             ub.ReadBook.read_status == ub.ReadBook.STATUS_FINISHED)\n        else:\n            db_filter = coalesce(ub.ReadBook.read_status, 0) != ub.ReadBook.STATUS_FINISHED\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db_filter,\n                                                                sort_param,\n                                                                False, 0,\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series,\n                                                                ub.ReadBook, db.Books.id == ub.ReadBook.book_id)\n    else:\n        try:\n            if are_read:\n                db_filter = db.cc_classes[config.config_read_column].value == True\n            else:\n                db_filter = coalesce(db.cc_classes[config.config_read_column].value, False) != True\n            entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                    db.Books,\n                                                                    db_filter,\n                                                                    sort_param,\n                                                                    False, 0,\n                                                                    db.books_series_link,\n                                                                    db.Books.id == db.books_series_link.c.book,\n                                                                    db.Series,\n                                                                    db.cc_classes[config.config_read_column])\n        except (KeyError, AttributeError):\n            log.error(\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n            if not as_xml:\n                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",\n                        column=config.config_read_column),\n                      category=\"error\")\n                return redirect(url_for(\"web.index\"))\n            return []  # ToDo: Handle error Case for opds\n\n    if as_xml:\n        return entries, pagination\n    else:\n        if are_read:\n            name = _(u'Read Books') + ' (' + str(pagination.total_count) + ')'\n            page_name = \"read\"\n        else:\n            name = _(u'Unread Books') + ' (' + str(pagination.total_count) + ')'\n            page_name = \"unread\"\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     title=name, page=page_name, order=order[1])\n\n\ndef render_archived_books(page, sort_param):\n    order = sort_param[0] or []\n    archived_books = (ub.session.query(ub.ArchivedBook)\n                      .filter(ub.ArchivedBook.user_id == int(current_user.id))\n                      .filter(ub.ArchivedBook.is_archived == True)\n                      .all())\n    archived_book_ids = [archived_book.book_id for archived_book in archived_books]\n\n    archived_filter = db.Books.id.in_(archived_book_ids)\n\n    entries, random, pagination = calibre_db.fill_indexpage_with_archived_books(page, db.Books,\n                                                                                0,\n                                                                                archived_filter,\n                                                                                order,\n                                                                                True,\n                                                                                False, 0)\n\n    name = _(u'Archived Books') + ' (' + str(len(archived_book_ids)) + ')'\n    page_name = \"archived\"\n    return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                 title=name, page=page_name, order=sort_param[1])\n\n\ndef render_prepare_search_form(cc):\n    # prepare data for search-form\n    tags = calibre_db.session.query(db.Tags) \\\n        .join(db.books_tags_link) \\\n        .join(db.Books) \\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_tags_link.tag')) \\\n        .order_by(db.Tags.name).all()\n    series = calibre_db.session.query(db.Series) \\\n        .join(db.books_series_link) \\\n        .join(db.Books) \\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_series_link.series')) \\\n        .order_by(db.Series.name) \\\n        .filter(calibre_db.common_filters()).all()\n    shelves = ub.session.query(ub.Shelf) \\\n        .filter(or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == int(current_user.id))) \\\n        .order_by(ub.Shelf.name).all()\n    extensions = calibre_db.session.query(db.Data) \\\n        .join(db.Books) \\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(db.Data.format) \\\n        .order_by(db.Data.format).all()\n    if current_user.filter_language() == u\"all\":\n        languages = calibre_db.speaking_language()\n    else:\n        languages = None\n    return render_title_template('search_form.html', tags=tags, languages=languages, extensions=extensions,\n                                 series=series, shelves=shelves, title=_(u\"Advanced Search\"), cc=cc, page=\"advsearch\")\n\n\ndef render_search_results(term, offset=None, order=None, limit=None):\n    join = db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series\n    entries, result_count, pagination = calibre_db.get_search_results(term,\n                                                                      offset,\n                                                                      order,\n                                                                      limit,\n                                                                      config.config_read_column,\n                                                                      *join)\n    return render_title_template('search.html',\n                                 searchterm=term,\n                                 pagination=pagination,\n                                 query=term,\n                                 adv_searchterm=term,\n                                 entries=entries,\n                                 result_count=result_count,\n                                 title=_(u\"Search\"),\n                                 page=\"search\",\n                                 order=order[1])\n\n\n# ################################### View Books list ##################################################################\n\n\n@web.route(\"/\", defaults={'page': 1})\n@web.route('/page/<int:page>')\n@login_required_if_no_ano\ndef index(page):\n    sort_param = (request.args.get('sort') or 'stored').lower()\n    return render_books_list(\"newest\", sort_param, 1, page)\n\n\n@web.route('/<data>/<sort_param>', defaults={'page': 1, 'book_id': 1})\n@web.route('/<data>/<sort_param>/', defaults={'page': 1, 'book_id': 1})\n@web.route('/<data>/<sort_param>/<book_id>', defaults={'page': 1})\n@web.route('/<data>/<sort_param>/<book_id>/<int:page>')\n@login_required_if_no_ano\ndef books_list(data, sort_param, book_id, page):\n    return render_books_list(data, sort_param, book_id, page)\n\n\n@web.route(\"/table\")\n@login_required\ndef books_table():\n    visibility = current_user.view_settings.get('table', {})\n    cc = get_cc_columns(filter_config_custom_read=True)\n    return render_title_template('book_table.html', title=_(u\"Books List\"), cc=cc, page=\"book_table\",\n                                 visiblility=visibility)\n\n\n@web.route(\"/ajax/listbooks\")\n@login_required\ndef list_books():\n    off = int(request.args.get(\"offset\") or 0)\n    limit = int(request.args.get(\"limit\") or config.config_books_per_page)\n    search_param = request.args.get(\"search\")\n    sort_param = request.args.get(\"sort\", \"id\")\n    order = request.args.get(\"order\", \"\").lower()\n    state = None\n    join = tuple()\n\n    if sort_param == \"state\":\n        state = json.loads(request.args.get(\"state\", \"[]\"))\n    elif sort_param == \"tags\":\n        order = [db.Tags.name.asc()] if order == \"asc\" else [db.Tags.name.desc()]\n        join = db.books_tags_link, db.Books.id == db.books_tags_link.c.book, db.Tags\n    elif sort_param == \"series\":\n        order = [db.Series.name.asc()] if order == \"asc\" else [db.Series.name.desc()]\n        join = db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series\n    elif sort_param == \"publishers\":\n        order = [db.Publishers.name.asc()] if order == \"asc\" else [db.Publishers.name.desc()]\n        join = db.books_publishers_link, db.Books.id == db.books_publishers_link.c.book, db.Publishers\n    elif sort_param == \"authors\":\n        order = [db.Authors.name.asc(), db.Series.name, db.Books.series_index] if order == \"asc\" \\\n            else [db.Authors.name.desc(), db.Series.name.desc(), db.Books.series_index.desc()]\n        join = db.books_authors_link, db.Books.id == db.books_authors_link.c.book, db.Authors, db.books_series_link, \\\n            db.Books.id == db.books_series_link.c.book, db.Series\n    elif sort_param == \"languages\":\n        order = [db.Languages.lang_code.asc()] if order == \"asc\" else [db.Languages.lang_code.desc()]\n        join = db.books_languages_link, db.Books.id == db.books_languages_link.c.book, db.Languages\n    elif order and sort_param in [\"sort\", \"title\", \"authors_sort\", \"series_index\"]:\n        order = [text(sort_param + \" \" + order)]\n    elif not state:\n        order = [db.Books.timestamp.desc()]\n\n    total_count = filtered_count = calibre_db.session.query(db.Books).filter(\n        calibre_db.common_filters(allow_show_archived=True)).count()\n    if state is not None:\n        if search_param:\n            books = calibre_db.search_query(search_param, config.config_read_column).all()\n            filtered_count = len(books)\n        else:\n            if not config.config_read_column:\n                books = (calibre_db.session.query(db.Books, ub.ReadBook.read_status, ub.ArchivedBook.is_archived)\n                         .select_from(db.Books)\n                         .outerjoin(ub.ReadBook,\n                                    and_(ub.ReadBook.user_id == int(current_user.id),\n                                         ub.ReadBook.book_id == db.Books.id)))\n            else:\n                read_column = \"\"\n                try:\n                    read_column = db.cc_classes[config.config_read_column]\n                    books = (calibre_db.session.query(db.Books, read_column.value, ub.ArchivedBook.is_archived)\n                             .select_from(db.Books)\n                             .outerjoin(read_column, read_column.book == db.Books.id))\n                except (KeyError, AttributeError):\n                    log.error(\"Custom Column No.%d is not existing in calibre database\", read_column)\n                    # Skip linking read column and return None instead of read status\n                    books = calibre_db.session.query(db.Books, None, ub.ArchivedBook.is_archived)\n            books = (books.outerjoin(ub.ArchivedBook, and_(db.Books.id == ub.ArchivedBook.book_id,\n                                                           int(current_user.id) == ub.ArchivedBook.user_id))\n                     .filter(calibre_db.common_filters(allow_show_archived=True)).all())\n        entries = calibre_db.get_checkbox_sorted(books, state, off, limit, order, True)\n    elif search_param:\n        entries, filtered_count, __ = calibre_db.get_search_results(search_param,\n                                                                    off,\n                                                                    [order, ''],\n                                                                    limit,\n                                                                    config.config_read_column,\n                                                                    *join)\n    else:\n        entries, __, __ = calibre_db.fill_indexpage_with_archived_books((int(off) / (int(limit)) + 1),\n                                                                        db.Books,\n                                                                        limit,\n                                                                        True,\n                                                                        order,\n                                                                        True,\n                                                                        True,\n                                                                        config.config_read_column,\n                                                                        *join)\n\n    result = list()\n    for entry in entries:\n        val = entry[0]\n        val.read_status = entry[1] == ub.ReadBook.STATUS_FINISHED\n        val.is_archived = entry[2] is True\n        for lang_index in range(0, len(val.languages)):\n            val.languages[lang_index].language_name = isoLanguages.get_language_name(get_locale(), val.languages[\n                lang_index].lang_code)\n        result.append(val)\n\n    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": result}\n    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)\n\n    response = make_response(js_list)\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n\n@web.route(\"/ajax/table_settings\", methods=['POST'])\n@login_required\ndef update_table_settings():\n    current_user.view_settings['table'] = json.loads(request.data)\n    try:\n        try:\n            flag_modified(current_user, \"view_settings\")\n        except AttributeError:\n            pass\n        ub.session.commit()\n    except (InvalidRequestError, OperationalError):\n        log.error(\"Invalid request received: %r \", request, )\n        return \"Invalid request\", 400\n    return \"\"\n\n\n@web.route(\"/author\")\n@login_required_if_no_ano\ndef author_list():\n    if current_user.check_visibility(constants.SIDEBAR_AUTHOR):\n        if current_user.get_view_property('author', 'dir') == 'desc':\n            order = db.Authors.sort.desc()\n            order_no = 0\n        else:\n            order = db.Authors.sort.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Authors, func.count('books_authors_link.book').label('count')) \\\n            .join(db.books_authors_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_authors_link.author')).order_by(order).all()\n        char_list = generate_char_list(db.Authors.sort, db.books_authors_link)\n        # If not creating a copy, readonly databases can not display authornames with \"|\" in it as changing the name\n        # starts a change session\n        author_copy = copy.deepcopy(entries)\n        for entry in author_copy:\n            entry.Authors.name = entry.Authors.name.replace('|', ',')\n        return render_title_template('list.html', entries=author_copy, folder='web.books_list', charlist=char_list,\n                                     title=u\"Authors\", page=\"authorlist\", data='author', order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/downloadlist\")\n@login_required_if_no_ano\ndef download_list():\n    if current_user.get_view_property('download', 'dir') == 'desc':\n        order = ub.User.name.desc()\n        order_no = 0\n    else:\n        order = ub.User.name.asc()\n        order_no = 1\n    if current_user.check_visibility(constants.SIDEBAR_DOWNLOAD) and current_user.role_admin():\n        entries = ub.session.query(ub.User, func.count(ub.Downloads.book_id).label('count')) \\\n            .join(ub.Downloads).group_by(ub.Downloads.user_id).order_by(order).all()\n        char_list = ub.session.query(func.upper(func.substr(ub.User.name, 1, 1)).label('char')) \\\n            .filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS) \\\n            .group_by(func.upper(func.substr(ub.User.name, 1, 1))).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=char_list,\n                                     title=_(u\"Downloads\"), page=\"downloadlist\", data=\"download\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/publisher\")\n@login_required_if_no_ano\ndef publisher_list():\n    if current_user.get_view_property('publisher', 'dir') == 'desc':\n        order = db.Publishers.name.desc()\n        order_no = 0\n    else:\n        order = db.Publishers.name.asc()\n        order_no = 1\n    if current_user.check_visibility(constants.SIDEBAR_PUBLISHER):\n        entries = calibre_db.session.query(db.Publishers, func.count('books_publishers_link.book').label('count')) \\\n            .join(db.books_publishers_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_publishers_link.publisher')).order_by(order).all()\n        char_list = generate_char_list(db.Publishers.name, db.books_publishers_link)\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=char_list,\n                                     title=_(u\"Publishers\"), page=\"publisherlist\", data=\"publisher\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/series\")\n@login_required_if_no_ano\ndef series_list():\n    if current_user.check_visibility(constants.SIDEBAR_SERIES):\n        if current_user.get_view_property('series', 'dir') == 'desc':\n            order = db.Series.sort.desc()\n            order_no = 0\n        else:\n            order = db.Series.sort.asc()\n            order_no = 1\n        char_list = generate_char_list(db.Series.sort, db.books_series_link)\n        if current_user.get_view_property('series', 'series_view') == 'list':\n            entries = calibre_db.session.query(db.Series, func.count('books_series_link.book').label('count')) \\\n                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\\n                .group_by(text('books_series_link.series')).order_by(order).all()\n            return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=char_list,\n                                         title=_(u\"Series\"), page=\"serieslist\", data=\"series\", order=order_no)\n        else:\n            entries = calibre_db.session.query(db.Books, func.count('books_series_link').label('count'),\n                                               func.max(db.Books.series_index), db.Books.id) \\\n                .join(db.books_series_link).join(db.Series).filter(calibre_db.common_filters()) \\\n                .group_by(text('books_series_link.series')).order_by(order).all()\n            return render_title_template('grid.html', entries=entries, folder='web.books_list', charlist=char_list,\n                                         title=_(u\"Series\"), page=\"serieslist\", data=\"series\", bodyClass=\"grid-view\",\n                                         order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/ratings\")\n@login_required_if_no_ano\ndef ratings_list():\n    if current_user.check_visibility(constants.SIDEBAR_RATING):\n        if current_user.get_view_property('ratings', 'dir') == 'desc':\n            order = db.Ratings.rating.desc()\n            order_no = 0\n        else:\n            order = db.Ratings.rating.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Ratings, func.count('books_ratings_link.book').label('count'),\n                                           (db.Ratings.rating / 2).label('name')) \\\n            .join(db.books_ratings_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_ratings_link.rating')).order_by(order).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=list(),\n                                     title=_(u\"Ratings list\"), page=\"ratingslist\", data=\"ratings\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/formats\")\n@login_required_if_no_ano\ndef formats_list():\n    if current_user.check_visibility(constants.SIDEBAR_FORMAT):\n        if current_user.get_view_property('ratings', 'dir') == 'desc':\n            order = db.Data.format.desc()\n            order_no = 0\n        else:\n            order = db.Data.format.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Data,\n                                           func.count('data.book').label('count'),\n                                           db.Data.format.label('format')) \\\n            .join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(db.Data.format).order_by(order).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=list(),\n                                     title=_(u\"File formats list\"), page=\"formatslist\", data=\"formats\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/language\")\n@login_required_if_no_ano\ndef language_overview():\n    if current_user.check_visibility(constants.SIDEBAR_LANGUAGE) and current_user.filter_language() == u\"all\":\n        order_no = 0 if current_user.get_view_property('language', 'dir') == 'desc' else 1\n        char_list = list()\n        languages = calibre_db.speaking_language(reverse_order=not order_no, with_count=True)\n        for lang in languages:\n            upper_lang = lang[0].name[0].upper()\n            if upper_lang not in char_list:\n                char_list.append(upper_lang)\n        return render_title_template('languages.html', languages=languages,\n                                     charlist=char_list, title=_(u\"Languages\"), page=\"langlist\",\n                                     data=\"language\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/category\")\n@login_required_if_no_ano\ndef category_list():\n    if current_user.check_visibility(constants.SIDEBAR_CATEGORY):\n        if current_user.get_view_property('category', 'dir') == 'desc':\n            order = db.Tags.name.desc()\n            order_no = 0\n        else:\n            order = db.Tags.name.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Tags, func.count('books_tags_link.book').label('count')) \\\n            .join(db.books_tags_link).join(db.Books).order_by(order).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_tags_link.tag')).all()\n        char_list = generate_char_list(db.Tags.name, db.books_tags_link)\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=char_list,\n                                     title=_(u\"Categories\"), page=\"catlist\", data=\"category\", order=order_no)\n    else:\n        abort(404)\n\n\n# ################################### Task functions ################################################################\n\n\n@web.route(\"/tasks\")\n@login_required\ndef get_tasks_status():\n    # if current user admin, show all email, otherwise only own emails\n    tasks = WorkerThread.getInstance().tasks\n    answer = render_task_status(tasks)\n    return render_title_template('tasks.html', entries=answer, title=_(u\"Tasks\"), page=\"tasks\")\n\n\n# ################################### Search functions ################################################################\n\n@web.route(\"/search\", methods=[\"GET\"])\n@login_required_if_no_ano\ndef search():\n    term = request.args.get(\"query\")\n    if term:\n        return redirect(url_for('web.books_list', data=\"search\", sort_param='stored', query=term.strip()))\n    else:\n        return render_title_template('search.html',\n                                     searchterm=\"\",\n                                     result_count=0,\n                                     title=_(u\"Search\"),\n                                     page=\"search\")\n\n\n@web.route(\"/advsearch\", methods=['POST'])\n@login_required_if_no_ano\ndef advanced_search():\n    values = dict(request.form)\n    params = ['include_tag', 'exclude_tag', 'include_serie', 'exclude_serie', 'include_shelf', 'exclude_shelf',\n              'include_language', 'exclude_language', 'include_extension', 'exclude_extension']\n    for param in params:\n        values[param] = list(request.form.getlist(param))\n    flask_session['query'] = json.dumps(values)\n    return redirect(url_for('web.books_list', data=\"advsearch\", sort_param='stored', query=\"\"))\n\n\ndef adv_search_custom_columns(cc, term, q):\n    for c in cc:\n        if c.datatype == \"datetime\":\n            custom_start = term.get('custom_column_' + str(c.id) + '_start')\n            custom_end = term.get('custom_column_' + str(c.id) + '_end')\n            if custom_start:\n                q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                    func.datetime(db.cc_classes[c.id].value) >= func.datetime(custom_start)))\n            if custom_end:\n                q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                    func.datetime(db.cc_classes[c.id].value) <= func.datetime(custom_end)))\n        else:\n            custom_query = term.get('custom_column_' + str(c.id))\n            if custom_query != '' and custom_query is not None:\n                if c.datatype == 'bool':\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        db.cc_classes[c.id].value == (custom_query == \"True\")))\n                elif c.datatype == 'int' or c.datatype == 'float':\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        db.cc_classes[c.id].value == custom_query))\n                elif c.datatype == 'rating':\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        db.cc_classes[c.id].value == int(float(custom_query) * 2)))\n                else:\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        func.lower(db.cc_classes[c.id].value).ilike(\"%\" + custom_query + \"%\")))\n    return q\n\n\ndef adv_search_language(q, include_languages_inputs, exclude_languages_inputs):\n    if current_user.filter_language() != \"all\":\n        q = q.filter(db.Books.languages.any(db.Languages.lang_code == current_user.filter_language()))\n    else:\n        for language in include_languages_inputs:\n            q = q.filter(db.Books.languages.any(db.Languages.id == language))\n        for language in exclude_languages_inputs:\n            q = q.filter(not_(db.Books.series.any(db.Languages.id == language)))\n    return q\n\n\ndef adv_search_ratings(q, rating_high, rating_low):\n    if rating_high:\n        rating_high = int(rating_high) * 2\n        q = q.filter(db.Books.ratings.any(db.Ratings.rating <= rating_high))\n    if rating_low:\n        rating_low = int(rating_low) * 2\n        q = q.filter(db.Books.ratings.any(db.Ratings.rating >= rating_low))\n    return q\n\n\ndef adv_search_read_status(q, read_status):\n    if read_status:\n        if config.config_read_column:\n            try:\n                if read_status == \"True\":\n                    q = q.join(db.cc_classes[config.config_read_column], isouter=True) \\\n                        .filter(db.cc_classes[config.config_read_column].value == True)\n                else:\n                    q = q.join(db.cc_classes[config.config_read_column], isouter=True) \\\n                        .filter(coalesce(db.cc_classes[config.config_read_column].value, False) != True)\n            except (KeyError, AttributeError):\n                log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",\n                        column=config.config_read_column),\n                      category=\"error\")\n                return q\n        else:\n            if read_status == \"True\":\n                q = q.join(ub.ReadBook, db.Books.id == ub.ReadBook.book_id, isouter=True) \\\n                    .filter(ub.ReadBook.user_id == int(current_user.id),\n                            ub.ReadBook.read_status == ub.ReadBook.STATUS_FINISHED)\n            else:\n                q = q.join(ub.ReadBook, db.Books.id == ub.ReadBook.book_id, isouter=True) \\\n                    .filter(ub.ReadBook.user_id == int(current_user.id),\n                            coalesce(ub.ReadBook.read_status, 0) != ub.ReadBook.STATUS_FINISHED)\n    return q\n\n\ndef adv_search_text(q, include_inputs, exclude_inputs, data_value):\n    for inp in include_inputs:\n        q = q.filter(db.Books.data.any(data_value == inp))\n    for excl in exclude_inputs:\n        q = q.filter(not_(db.Books.data.any(data_value == excl)))\n    return q\n\n\n'''def adv_search_extension(q, include_extension_inputs, exclude_extension_inputs):\n    for extension in include_extension_inputs:\n        q = q.filter(db.Books.data.any(db.Data.format == extension))\n    for extension in exclude_extension_inputs:\n        q = q.filter(not_(db.Books.data.any(db.Data.format == extension)))\n    return q\n\n\ndef adv_search_tag(q, include_tag_inputs, exclude_tag_inputs):\n    for tag in include_tag_inputs:\n        q = q.filter(db.Books.tags.any(db.Tags.id == tag))\n    for tag in exclude_tag_inputs:\n        q = q.filter(not_(db.Books.tags.any(db.Tags.id == tag)))\n    return q\n\n\ndef adv_search_serie(q, include_series_inputs, exclude_series_inputs):\n    for serie in include_series_inputs:\n        q = q.filter(db.Books.series.any(db.Series.id == serie))\n    for serie in exclude_series_inputs:\n        q = q.filter(not_(db.Books.series.any(db.Series.id == serie)))\n    return q'''\n\n\ndef adv_search_shelf(q, include_shelf_inputs, exclude_shelf_inputs):\n    q = q.outerjoin(ub.BookShelf, db.Books.id == ub.BookShelf.book_id) \\\n        .filter(or_(ub.BookShelf.shelf == None, ub.BookShelf.shelf.notin_(exclude_shelf_inputs)))\n    if len(include_shelf_inputs) > 0:\n        q = q.filter(ub.BookShelf.shelf.in_(include_shelf_inputs))\n    return q\n\n\ndef extend_search_term(searchterm,\n                       author_name,\n                       book_title,\n                       publisher,\n                       pub_start,\n                       pub_end,\n                       tags,\n                       rating_high,\n                       rating_low,\n                       read_status,\n                       ):\n    searchterm.extend((author_name.replace('|', ','), book_title, publisher))\n    if pub_start:\n        try:\n            searchterm.extend([_(u\"Published after \") +\n                               format_date(datetime.strptime(pub_start, \"%Y-%m-%d\"),\n                                           format='medium', locale=get_locale())])\n        except ValueError:\n            pub_start = u\"\"\n    if pub_end:\n        try:\n            searchterm.extend([_(u\"Published before \") +\n                               format_date(datetime.strptime(pub_end, \"%Y-%m-%d\"),\n                                           format='medium', locale=get_locale())])\n        except ValueError:\n            pub_end = u\"\"\n    elements = {'tag': db.Tags, 'serie': db.Series, 'shelf': ub.Shelf}\n    for key, db_element in elements.items():\n        tag_names = calibre_db.session.query(db_element).filter(db_element.id.in_(tags['include_' + key])).all()\n        searchterm.extend(tag.name for tag in tag_names)\n        tag_names = calibre_db.session.query(db_element).filter(db_element.id.in_(tags['exclude_' + key])).all()\n        searchterm.extend(tag.name for tag in tag_names)\n    language_names = calibre_db.session.query(db.Languages). \\\n        filter(db.Languages.id.in_(tags['include_language'])).all()\n    if language_names:\n        language_names = calibre_db.speaking_language(language_names)\n    searchterm.extend(language.name for language in language_names)\n    language_names = calibre_db.session.query(db.Languages). \\\n        filter(db.Languages.id.in_(tags['exclude_language'])).all()\n    if language_names:\n        language_names = calibre_db.speaking_language(language_names)\n    searchterm.extend(language.name for language in language_names)\n    if rating_high:\n        searchterm.extend([_(u\"Rating <= %(rating)s\", rating=rating_high)])\n    if rating_low:\n        searchterm.extend([_(u\"Rating >= %(rating)s\", rating=rating_low)])\n    if read_status:\n        searchterm.extend([_(u\"Read Status = %(status)s\", status=read_status)])\n    searchterm.extend(ext for ext in tags['include_extension'])\n    searchterm.extend(ext for ext in tags['exclude_extension'])\n    # handle custom columns\n    searchterm = \" + \".join(filter(None, searchterm))\n    return searchterm, pub_start, pub_end\n\n\ndef render_adv_search_results(term, offset=None, order=None, limit=None):\n    sort_param = order[0] if order else [db.Books.sort]\n    pagination = None\n\n    cc = get_cc_columns(filter_config_custom_read=True)\n    calibre_db.session.connection().connection.connection.create_function(\"lower\", 1, db.lcase)\n    if not config.config_read_column:\n        query = (calibre_db.session.query(db.Books, ub.ArchivedBook.is_archived, ub.ReadBook).select_from(db.Books)\n                 .outerjoin(ub.ReadBook, and_(db.Books.id == ub.ReadBook.book_id,\n                                              int(current_user.id) == ub.ReadBook.user_id)))\n    else:\n        try:\n            read_column = cc[config.config_read_column]\n            query = (calibre_db.session.query(db.Books, ub.ArchivedBook.is_archived, read_column.value)\n                     .select_from(db.Books)\n                     .outerjoin(read_column, read_column.book == db.Books.id))\n        except (KeyError, AttributeError):\n            log.error(\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n            # Skip linking read column\n            query = calibre_db.session.query(db.Books, ub.ArchivedBook.is_archived, None)\n    query = query.outerjoin(ub.ArchivedBook, and_(db.Books.id == ub.ArchivedBook.book_id,\n                                                  int(current_user.id) == ub.ArchivedBook.user_id))\n\n    q = query.outerjoin(db.books_series_link, db.Books.id == db.books_series_link.c.book) \\\n        .outerjoin(db.Series) \\\n        .filter(calibre_db.common_filters(True))\n\n    # parse multiselects to a complete dict\n    tags = dict()\n    elements = ['tag', 'serie', 'shelf', 'language', 'extension']\n    for element in elements:\n        tags['include_' + element] = term.get('include_' + element)\n        tags['exclude_' + element] = term.get('exclude_' + element)\n\n    author_name = term.get(\"author_name\")\n    book_title = term.get(\"book_title\")\n    publisher = term.get(\"publisher\")\n    pub_start = term.get(\"publishstart\")\n    pub_end = term.get(\"publishend\")\n    rating_low = term.get(\"ratinghigh\")\n    rating_high = term.get(\"ratinglow\")\n    description = term.get(\"comment\")\n    read_status = term.get(\"read_status\")\n    if author_name:\n        author_name = author_name.strip().lower().replace(',', '|')\n    if book_title:\n        book_title = book_title.strip().lower()\n    if publisher:\n        publisher = publisher.strip().lower()\n\n    search_term = []\n    cc_present = False\n    for c in cc:\n        if c.datatype == \"datetime\":\n            column_start = term.get('custom_column_' + str(c.id) + '_start')\n            column_end = term.get('custom_column_' + str(c.id) + '_end')\n            if column_start:\n                search_term.extend([u\"{} >= {}\".format(c.name,\n                                                       format_date(datetime.strptime(column_start, \"%Y-%m-%d\").date(),\n                                                                   format='medium',\n                                                                   locale=get_locale())\n                                                       )])\n                cc_present = True\n            if column_end:\n                search_term.extend([u\"{} <= {}\".format(c.name,\n                                                       format_date(datetime.strptime(column_end, \"%Y-%m-%d\").date(),\n                                                                   format='medium',\n                                                                   locale=get_locale())\n                                                       )])\n                cc_present = True\n        elif term.get('custom_column_' + str(c.id)):\n            search_term.extend([(u\"{}: {}\".format(c.name, term.get('custom_column_' + str(c.id))))])\n            cc_present = True\n\n    if any(tags.values()) or author_name or book_title or \\\n        publisher or pub_start or pub_end or rating_low or rating_high \\\n            or description or cc_present or read_status:\n        search_term, pub_start, pub_end = extend_search_term(search_term,\n                                                             author_name,\n                                                             book_title,\n                                                             publisher,\n                                                             pub_start,\n                                                             pub_end,\n                                                             tags,\n                                                             rating_high,\n                                                             rating_low,\n                                                             read_status)\n        # q = q.filter()\n        if author_name:\n            q = q.filter(db.Books.authors.any(func.lower(db.Authors.name).ilike(\"%\" + author_name + \"%\")))\n        if book_title:\n            q = q.filter(func.lower(db.Books.title).ilike(\"%\" + book_title + \"%\"))\n        if pub_start:\n            q = q.filter(func.datetime(db.Books.pubdate) > func.datetime(pub_start))\n        if pub_end:\n            q = q.filter(func.datetime(db.Books.pubdate) < func.datetime(pub_end))\n        q = adv_search_read_status(q, read_status)\n        if publisher:\n            q = q.filter(db.Books.publishers.any(func.lower(db.Publishers.name).ilike(\"%\" + publisher + \"%\")))\n        q = adv_search_text(q, tags['include_tag'], tags['exclude_tag'], db.Tags.id)\n        q = adv_search_text(q, tags['include_serie'], tags['exclude_serie'], db.Series.id)\n        q = adv_search_text(q, tags['include_extension'], tags['exclude_extension'], db.Data.format)\n        q = adv_search_shelf(q, tags['include_shelf'], tags['exclude_shelf'])\n        q = adv_search_language(q, tags['include_language'], tags['exclude_language'], )\n        q = adv_search_ratings(q, rating_high, rating_low, )\n\n        if description:\n            q = q.filter(db.Books.comments.any(func.lower(db.Comments.text).ilike(\"%\" + description + \"%\")))\n\n        # search custom culumns\n        try:\n            q = adv_search_custom_columns(cc, term, q)\n        except AttributeError as ex:\n            log.error_or_exception(ex)\n            flash(_(\"Error on search for custom columns, please restart Calibre-Web\"), category=\"error\")\n\n    q = q.order_by(*sort_param).all()\n    flask_session['query'] = json.dumps(term)\n    ub.store_combo_ids(q)\n    result_count = len(q)\n    if offset is not None and limit is not None:\n        offset = int(offset)\n        limit_all = offset + int(limit)\n        pagination = Pagination((offset / (int(limit)) + 1), limit, result_count)\n    else:\n        offset = 0\n        limit_all = result_count\n    entries = calibre_db.order_authors(q[offset:limit_all], list_return=True, combined=True)\n    return render_title_template('search.html',\n                                 adv_searchterm=search_term,\n                                 pagination=pagination,\n                                 entries=entries,\n                                 result_count=result_count,\n                                 title=_(u\"Advanced Search\"), page=\"advsearch\",\n                                 order=order[1])\n\n\n@web.route(\"/advsearch\", methods=['GET'])\n@login_required_if_no_ano\ndef advanced_search_form():\n    # Build custom columns names\n    cc = get_cc_columns(filter_config_custom_read=True)\n    return render_prepare_search_form(cc)\n\n\n# ################################### Download/Send ##################################################################\n\n\n@web.route(\"/cover/<int:book_id>\")\n@login_required_if_no_ano\ndef get_cover(book_id):\n    return get_book_cover(book_id)\n\n\n@web.route(\"/robots.txt\")\ndef get_robots():\n    return send_from_directory(constants.STATIC_DIR, \"robots.txt\")\n\n\n@web.route(\"/show/<int:book_id>/<book_format>\", defaults={'anyname': 'None'})\n@web.route(\"/show/<int:book_id>/<book_format>/<anyname>\")\n@login_required_if_no_ano\n@viewer_required\ndef serve_book(book_id, book_format, anyname):\n    book_format = book_format.split(\".\")[0]\n    book = calibre_db.get_book(book_id)\n    data = calibre_db.get_book_format(book_id, book_format.upper())\n    if not data:\n        return \"File not in Database\"\n    log.info('Serving book: %s', data.name)\n    if config.config_use_google_drive:\n        try:\n            headers = Headers()\n            headers[\"Content-Type\"] = mimetypes.types_map.get('.' + book_format, \"application/octet-stream\")\n            df = getFileFromEbooksFolder(book.path, data.name + \".\" + book_format)\n            return do_gdrive_download(df, headers, (book_format.upper() == 'TXT'))\n        except AttributeError as ex:\n            log.error_or_exception(ex)\n            return \"File Not Found\"\n    else:\n        if book_format.upper() == 'TXT':\n            try:\n                rawdata = open(os.path.join(config.config_calibre_dir, book.path, data.name + \".\" + book_format),\n                               \"rb\").read()\n                result = chardet.detect(rawdata)\n                return make_response(\n                    rawdata.decode(result['encoding'], 'surrogatepass').encode('utf-8', 'surrogatepass'))\n            except FileNotFoundError:\n                log.error(\"File Not Found\")\n                return \"File Not Found\"\n        return send_from_directory(os.path.join(config.config_calibre_dir, book.path), data.name + \".\" + book_format)\n\n\n@web.route(\"/download/<int:book_id>/<book_format>\", defaults={'anyname': 'None'})\n@web.route(\"/download/<int:book_id>/<book_format>/<anyname>\")\n@login_required_if_no_ano\n@download_required\ndef download_link(book_id, book_format, anyname):\n    client = \"kobo\" if \"Kobo\" in request.headers.get('User-Agent') else \"\"\n    return get_download_link(book_id, book_format, client)\n\n\n@web.route('/send/<int:book_id>/<book_format>/<int:convert>', methods=[\"POST\"])\n@login_required\n@download_required\ndef send_to_kindle(book_id, book_format, convert):\n    if not config.get_mail_server_configured():\n        flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")\n    elif current_user.kindle_mail:\n        result = send_mail(book_id, book_format, convert, current_user.kindle_mail, config.config_calibre_dir,\n                           current_user.name)\n        if result is None:\n            flash(_(u\"Book successfully queued for sending to %(kindlemail)s\", kindlemail=current_user.kindle_mail),\n                  category=\"success\")\n            ub.update_download(book_id, int(current_user.id))\n        else:\n            flash(_(u\"Oops! There was an error sending this book: %(res)s\", res=result), category=\"error\")\n    else:\n        flash(_(u\"Please update your profile with a valid Send to Kindle E-mail Address.\"), category=\"error\")\n    if \"HTTP_REFERER\" in request.environ:\n        return redirect(request.environ[\"HTTP_REFERER\"])\n    else:\n        return redirect(url_for('web.index'))\n\n\n# ################################### Login Logout ##################################################################\n\n\n@web.route('/register', methods=['GET', 'POST'])\ndef register():\n    if not config.config_public_reg:\n        abort(404)\n    if current_user is not None and current_user.is_authenticated:\n        return redirect(url_for('web.index'))\n    if not config.get_mail_server_configured():\n        flash(_(u\"E-Mail server is not configured, please contact your administrator!\"), category=\"error\")\n        return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        nickname = to_save[\"email\"].strip() if config.config_register_email else to_save.get('name')\n        if not nickname or not to_save.get(\"email\"):\n            flash(_(u\"Please fill out all fields!\"), category=\"error\")\n            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n        try:\n            nickname = check_username(nickname)\n            email = check_email(to_save[\"email\"])\n        except Exception as ex:\n            flash(str(ex), category=\"error\")\n            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n\n        content = ub.User()\n        if check_valid_domain(email):\n            content.name = nickname\n            content.email = email\n            password = generate_random_password()\n            content.password = generate_password_hash(password)\n            content.role = config.config_default_role\n            content.sidebar_view = config.config_default_show\n            try:\n                ub.session.add(content)\n                ub.session.commit()\n                if feature_support['oauth']:\n                    register_user_with_oauth(content)\n                send_registration_mail(to_save[\"email\"].strip(), nickname, password)\n            except Exception:\n                ub.session.rollback()\n                flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n                return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n        else:\n            flash(_(u\"Your e-mail is not allowed to register\"), category=\"error\")\n            log.warning('Registering failed for user \"%s\" e-mail address: %s', nickname, to_save[\"email\"])\n            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n        flash(_(u\"Confirmation e-mail was send to your e-mail account.\"), category=\"success\")\n        return redirect(url_for('web.login'))\n\n    if feature_support['oauth']:\n        register_user_with_oauth()\n    return render_title_template('register.html', config=config, title=_(\"Register\"), page=\"register\")\n\n\n@web.route('/login', methods=['GET', 'POST'])\ndef login():\n    if current_user is not None and current_user.is_authenticated:\n        return redirect(url_for('web.index'))\n    if config.config_login_type == constants.LOGIN_LDAP and not services.ldap:\n        log.error(u\"Cannot activate LDAP authentication\")\n        flash(_(u\"Cannot activate LDAP authentication\"), category=\"error\")\n    if request.method == \"POST\":\n        form = request.form.to_dict()\n        user = ub.session.query(ub.User).filter(func.lower(ub.User.name) == form['username'].strip().lower()) \\\n            .first()\n        if config.config_login_type == constants.LOGIN_LDAP and services.ldap and user and form['password'] != \"\":\n            login_result, error = services.ldap.bind_user(form['username'], form['password'])\n            if login_result:\n                login_user(user, remember=bool(form.get('remember_me')))\n                ub.store_user_session()\n                log.debug(u\"You are now logged in as: '%s'\", user.name)\n                flash(_(u\"you are now logged in as: '%(nickname)s'\", nickname=user.name),\n                      category=\"success\")\n                return redirect_back(url_for(\"web.index\"))\n            elif login_result is None and user and check_password_hash(str(user.password), form['password']) \\\n                    and user.name != \"Guest\":\n                login_user(user, remember=bool(form.get('remember_me')))\n                ub.store_user_session()\n                log.info(\"Local Fallback Login as: '%s'\", user.name)\n                flash(_(u\"Fallback Login as: '%(nickname)s', LDAP Server not reachable, or user not known\",\n                        nickname=user.name),\n                      category=\"warning\")\n                return redirect_back(url_for(\"web.index\"))\n            elif login_result is None:\n                log.info(error)\n                flash(_(u\"Could not login: %(message)s\", message=error), category=\"error\")\n            else:\n                ip_address = request.headers.get('X-Forwarded-For', request.remote_addr)\n                log.warning('LDAP Login failed for user \"%s\" IP-address: %s', form['username'], ip_address)\n                flash(_(u\"Wrong Username or Password\"), category=\"error\")\n        else:\n            ip_address = request.headers.get('X-Forwarded-For', request.remote_addr)\n            if 'forgot' in form and form['forgot'] == 'forgot':\n                if user is not None and user.name != \"Guest\":\n                    ret, __ = reset_password(user.id)\n                    if ret == 1:\n                        flash(_(u\"New Password was send to your email address\"), category=\"info\")\n                        log.info('Password reset for user \"%s\" IP-address: %s', form['username'], ip_address)\n                    else:\n                        log.error(u\"An unknown error occurred. Please try again later\")\n                        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n                else:\n                    flash(_(u\"Please enter valid username to reset password\"), category=\"error\")\n                    log.warning('Username missing for password reset IP-address: %s', ip_address)\n            else:\n                if user and check_password_hash(str(user.password), form['password']) and user.name != \"Guest\":\n                    login_user(user, remember=bool(form.get('remember_me')))\n                    ub.store_user_session()\n                    log.debug(u\"You are now logged in as: '%s'\", user.name)\n                    flash(_(u\"You are now logged in as: '%(nickname)s'\", nickname=user.name), category=\"success\")\n                    config.config_is_initial = False\n                    return redirect_back(url_for(\"web.index\"))\n                else:\n                    log.warning('Login failed for user \"%s\" IP-address: %s', form['username'], ip_address)\n                    flash(_(u\"Wrong Username or Password\"), category=\"error\")\n\n    next_url = request.args.get('next', default=url_for(\"web.index\"), type=str)\n    if url_for(\"web.logout\") == next_url:\n        next_url = url_for(\"web.index\")\n    return render_title_template('login.html',\n                                 title=_(u\"Login\"),\n                                 next_url=next_url,\n                                 config=config,\n                                 oauth_check=oauth_check,\n                                 mail=config.get_mail_server_configured(), page=\"login\")\n\n\n@web.route('/logout')\n@login_required\ndef logout():\n    if current_user is not None and current_user.is_authenticated:\n        ub.delete_user_session(current_user.id, flask_session.get('_id', \"\"))\n        logout_user()\n        if feature_support['oauth'] and (config.config_login_type == 2 or config.config_login_type == 3):\n            logout_oauth_user()\n    log.debug(u\"User logged out\")\n    return redirect(url_for('web.login'))\n\n\n# ################################### Users own configuration #########################################################\ndef change_profile(kobo_support, local_oauth_check, oauth_status, translations, languages):\n    to_save = request.form.to_dict()\n    current_user.random_books = 0\n    if current_user.role_passwd() or current_user.role_admin():\n        if to_save.get(\"password\"):\n            current_user.password = generate_password_hash(to_save[\"password\"])\n    try:\n        if to_save.get(\"kindle_mail\", current_user.kindle_mail) != current_user.kindle_mail:\n            current_user.kindle_mail = valid_email(to_save[\"kindle_mail\"])\n        if to_save.get(\"email\", current_user.email) != current_user.email:\n            current_user.email = check_email(to_save[\"email\"])\n        if current_user.role_admin():\n            if to_save.get(\"name\", current_user.name) != current_user.name:\n                # Query username, if not existing, change\n                current_user.name = check_username(to_save[\"name\"])\n        current_user.random_books = 1 if to_save.get(\"show_random\") == \"on\" else 0\n        if to_save.get(\"default_language\"):\n            current_user.default_language = to_save[\"default_language\"]\n        if to_save.get(\"locale\"):\n            current_user.locale = to_save[\"locale\"]\n        old_state = current_user.kobo_only_shelves_sync\n        # 1 -> 0: nothing has to be done\n        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs which\n        # don't have to be synced have to be removed (added to Shelf archive)\n        current_user.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0\n        if old_state == 0 and current_user.kobo_only_shelves_sync == 1:\n            kobo_sync_status.update_on_sync_shelfs(current_user.id)\n\n    except Exception as ex:\n        flash(str(ex), category=\"error\")\n        return render_title_template(\"user_edit.html\",\n                                     content=current_user,\n                                     translations=translations,\n                                     profile=1,\n                                     languages=languages,\n                                     title=_(u\"%(name)s's profile\", name=current_user.name),\n                                     page=\"me\",\n                                     kobo_support=kobo_support,\n                                     registered_oauth=local_oauth_check,\n                                     oauth_status=oauth_status)\n\n    val = 0\n    for key, __ in to_save.items():\n        if key.startswith('show'):\n            val += int(key[5:])\n    current_user.sidebar_view = val\n    if to_save.get(\"Show_detail_random\"):\n        current_user.sidebar_view += constants.DETAIL_RANDOM\n\n    try:\n        ub.session.commit()\n        flash(_(u\"Profile updated\"), category=\"success\")\n        log.debug(u\"Profile updated\")\n    except IntegrityError:\n        ub.session.rollback()\n        flash(_(u\"Found an existing account for this e-mail address\"), category=\"error\")\n        log.debug(u\"Found an existing account for this e-mail address\")\n    except OperationalError as e:\n        ub.session.rollback()\n        log.error(\"Database error: %s\", e)\n        flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")\n\n\n@web.route(\"/me\", methods=[\"GET\", \"POST\"])\n@login_required\ndef profile():\n    languages = calibre_db.speaking_language()\n    translations = babel.list_translations() + [Locale('en')]\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    if feature_support['oauth'] and config.config_login_type == 2:\n        oauth_status = get_oauth_status()\n        local_oauth_check = oauth_check\n    else:\n        oauth_status = None\n        local_oauth_check = {}\n\n    if request.method == \"POST\":\n        change_profile(kobo_support, local_oauth_check, oauth_status, translations, languages)\n    return render_title_template(\"user_edit.html\",\n                                 translations=translations,\n                                 profile=1,\n                                 languages=languages,\n                                 content=current_user,\n                                 kobo_support=kobo_support,\n                                 title=_(u\"%(name)s's profile\", name=current_user.name),\n                                 page=\"me\",\n                                 registered_oauth=local_oauth_check,\n                                 oauth_status=oauth_status)\n\n\n# ###################################Show single book ##################################################################\n\n\n@web.route(\"/read/<int:book_id>/<book_format>\")\n@login_required_if_no_ano\n@viewer_required\ndef read_book(book_id, book_format):\n    book = calibre_db.get_filtered_book(book_id)\n    book.ordered_authors = calibre_db.order_authors([book], False)\n\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),\n              category=\"error\")\n        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")\n        return redirect(url_for(\"web.index\"))\n\n    # check if book has a bookmark\n    bookmark = None\n    if current_user.is_authenticated:\n        bookmark = ub.session.query(ub.Bookmark).filter(and_(ub.Bookmark.user_id == int(current_user.id),\n                                                             ub.Bookmark.book_id == book_id,\n                                                             ub.Bookmark.format == book_format.upper())).first()\n    if book_format.lower() == \"epub\":\n        log.debug(u\"Start epub reader for %d\", book_id)\n        return render_title_template('read.html', bookid=book_id, title=book.title, bookmark=bookmark)\n    elif book_format.lower() == \"pdf\":\n        log.debug(u\"Start pdf reader for %d\", book_id)\n        return render_title_template('readpdf.html', pdffile=book_id, title=book.title)\n    elif book_format.lower() == \"txt\":\n        log.debug(u\"Start txt reader for %d\", book_id)\n        return render_title_template('readtxt.html', txtfile=book_id, title=book.title)\n    elif book_format.lower() == \"djvu\":\n        log.debug(u\"Start djvu reader for %d\", book_id)\n        return render_title_template('readdjvu.html', djvufile=book_id, title=book.title)\n    else:\n        for fileExt in constants.EXTENSIONS_AUDIO:\n            if book_format.lower() == fileExt:\n                entries = calibre_db.get_filtered_book(book_id)\n                log.debug(u\"Start mp3 listening for %d\", book_id)\n                return render_title_template('listenmp3.html', mp3file=book_id, audioformat=book_format.lower(),\n                                             entry=entries, bookmark=bookmark)\n        for fileExt in [\"cbr\", \"cbt\", \"cbz\"]:\n            if book_format.lower() == fileExt:\n                all_name = str(book_id)\n                title = book.title\n                if len(book.series):\n                    title = title + \" - \" + book.series[0].name\n                    if book.series_index:\n                        title = title + \" #\" + '{0:.2f}'.format(book.series_index).rstrip('0').rstrip('.')\n                log.debug(u\"Start comic reader for %d\", book_id)\n                return render_title_template('readcbr.html', comicfile=all_name, title=title,\n                                             extension=fileExt)\n        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),\n              category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n\n@web.route(\"/book/<int:book_id>\")\n@login_required_if_no_ano\ndef show_book(book_id):\n    entries = calibre_db.get_book_read_archived(book_id, config.config_read_column, allow_show_archived=True)\n    if entries:\n        read_book = entries[1]\n        archived_book = entries[2]\n        entry = entries[0]\n        entry.read_status = read_book == ub.ReadBook.STATUS_FINISHED\n        entry.is_archived = archived_book\n        for lang_index in range(0, len(entry.languages)):\n            entry.languages[lang_index].language_name = isoLanguages.get_language_name(get_locale(), entry.languages[\n                lang_index].lang_code)\n        cc = get_cc_columns(filter_config_custom_read=True)\n        book_in_shelves = []\n        shelfs = ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).all()\n        for sh in shelfs:\n            book_in_shelves.append(sh.shelf)\n\n        entry.tags = sort(entry.tags, key=lambda tag: tag.name)\n\n        entry.ordered_authors = calibre_db.order_authors([entry])\n\n        entry.kindle_list = check_send_to_kindle(entry)\n        entry.reader_list = check_read_formats(entry)\n\n        entry.audioentries = []\n        for media_format in entry.data:\n            if media_format.format.lower() in constants.EXTENSIONS_AUDIO:\n                entry.audioentries.append(media_format.format.lower())\n\n        return render_title_template('detail.html',\n                                     entry=entry,\n                                     cc=cc,\n                                     is_xhr=request.headers.get('X-Requested-With') == 'XMLHttpRequest',\n                                     title=entry.title,\n                                     books_shelfs=book_in_shelves,\n                                     page=\"book\")\n    else:\n        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),\n              category=\"error\")\n        return redirect(url_for(\"web.index\"))\n", "# GDrive Integration\ngoogle-api-python-client>=1.7.11,<2.41.0\ngevent>20.6.0,<22.0.0\ngreenlet>=0.4.17,<1.2.0\nhttplib2>=0.9.2,<0.21.0\noauth2client>=4.0.0,<4.1.4\nuritemplate>=3.0.0,<4.2.0\npyasn1-modules>=0.0.8,<0.3.0\npyasn1>=0.1.9,<0.5.0\nPyDrive2>=1.3.1,<1.11.0\nPyYAML>=3.12\nrsa>=3.4.2,<4.9.0\n\n# Gmail\ngoogle-auth-oauthlib>=0.4.3,<0.6.0\ngoogle-api-python-client>=1.7.11,<2.41.0\n\n# goodreads\ngoodreads>=0.3.2,<0.4.0\npython-Levenshtein>=0.12.0,<0.13.0\n\n# ldap login\npython-ldap>=3.0.0,<3.5.0\nFlask-SimpleLDAP>=1.4.0,<1.5.0\n\n# oauth\nFlask-Dance>=2.0.0,<5.2.0\nSQLAlchemy-Utils>=0.33.5,<0.39.0\n\n# metadata extraction\nrarfile>=3.2\nscholarly>=1.2.0,<1.7\nmarkdown2>=2.0.0,<2.5.0\nhtml2text>=2020.1.16,<2022.1.1\npython-dateutil>=2.1,<2.9.0\nbeautifulsoup4>=4.0.1,<4.11.0\ncchardet>=2.0.0,<2.2.0\n\n# Comics\nnatsort>=2.2.0,<8.2.0\ncomicapi>=2.2.0,<2.3.0\n\n# Kobo integration\njsonschema>=3.2.0,<4.5.0\n", "Babel>=1.3,<3.0\nFlask-Babel>=0.11.1,<2.1.0\nFlask-Login>=0.3.2,<0.5.1\nFlask-Principal>=0.3.2,<0.5.1\nbackports_abc>=0.4\nFlask>=1.0.2,<2.1.0\niso-639>=0.4.5,<0.5.0\nPyPDF3>=1.0.0,<1.0.7\npytz>=2016.10\nrequests>=2.11.1,<2.28.0\nSQLAlchemy>=1.3.0,<1.5.0\ntornado>=4.1,<6.2\nWand>=0.4.4,<0.7.0\nunidecode>=0.04.19,<1.4.0\nlxml>=3.8.0,<4.9.0\nflask-wtf>=0.14.2,<1.1.0\nchardet>=3.0.0,<4.1.0\nadvocate>=1.0.0,<1.1.0\n"], "filenames": ["cps.py", "cps/__init__.py", "cps/admin.py", "cps/db.py", "cps/editbooks.py", "cps/epub.py", "cps/helper.py", "cps/opds.py", "cps/pagination.py", "cps/remotelogin.py", "cps/templates/book_edit.html", "cps/templates/book_table.html", "cps/templates/detail.html", "cps/templates/layout.html", "cps/usermanagement.py", "cps/web.py", "optional-requirements.txt", "requirements.txt"], "buggy_code_start_loc": [43, 159, 30, 20, 34, 56, 26, 31, 60, 24, 25, 9, 141, 63, 20, 32, 2, 15], "buggy_code_end_loc": [77, 160, 1651, 978, 1350, 148, 973, 585, 64, 38, 52, 93, 299, 64, 32, 1812, 33, 17], "fixing_code_start_loc": [43, 159, 30, 19, 34, 56, 25, 30, 60, 25, 25, 9, 141, 63, 21, 32, 2, 15], "fixing_code_end_loc": [77, 160, 1652, 968, 1371, 150, 977, 522, 64, 34, 52, 93, 299, 64, 28, 1828, 33, 19], "type": "CWE-918", "message": "Server-Side Request Forgery (SSRF) in GitHub repository janeczku/calibre-web prior to 0.6.18.", "other": {"cve": {"id": "CVE-2022-0990", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-04T18:15:07.817", "lastModified": "2022-04-12T09:24:40.387", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Server-Side Request Forgery (SSRF) in GitHub repository janeczku/calibre-web prior to 0.6.18."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Server-Side Request Forgery (SSRF) en el repositorio de GitHub janeczku/calibre-web versiones anteriores a 0.6.18"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:calibre-web_project:calibre-web:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.18", "matchCriteriaId": "A4296881-9A6D-4E56-A33D-CB8A280F949D"}]}]}], "references": [{"url": "https://github.com/janeczku/calibre-web/commit/4545f4a20d9ff90b99bbd4e3e34b6de4441d6367", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/31649903-c19c-4dae-aee0-a04b095855c5", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/janeczku/calibre-web/commit/4545f4a20d9ff90b99bbd4e3e34b6de4441d6367"}}