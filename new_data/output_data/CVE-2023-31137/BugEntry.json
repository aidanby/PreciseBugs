{"buggy_code": ["/* Copyright (c) 2002-2006 Sam Trenholme\n *\n * TERMS\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * This software is provided 'as is' with no guarantees of correctness or\n * fitness for purpose.\n */\n\n#include <stdio.h>\n#include \"../MaraDns.h\"\n#include \"../server/timestamp.h\"\n#include \"Compress_rrs.h\"\n#include \"Compress_rrdescs.h\" /* The description of RRs to decompress */\n#include \"functions_dns.h\"\n\n/* Some definitions */\n#define MAX_DLABEL_LEN 256\n#define MAX_RR_SECTIONS 16\n\n/* The hash that stores RRs */\nrrdesc **rr_formats;\n\n/* Whether to show verbose messages */\nint dlog_level = -1; /* -1 means uninitialized */\n\n/* decomp_message: Show, if needed, a message to the user.\n\n   Input: null-terminated string with the message, minimum log level\n          before which we will show the message\n\n   Output: JS_SUCCESS\n\n*/\n\nint decomp_message(char *message, int min_log_level) {\n    if(dlog_level >= min_log_level) {\n        show_timestamp();\n        printf(\"%s\\n\",message);\n        }\n    return JS_SUCCESS;\n    }\n\n/* decomp_get_label:  Uncompress a dlabel from a compressed string,\n   generating a js_string object which will store the decompressed\n   dlabel.\n\n   Input:\n   compressed: The compressed string\n   compressed_offset: The offset from the beginning of the string\n   where the compressed dlabel begins\n\n   Output:\n   The output of this function is a newly created js_string object\n   which contains the decompressed dlabel.  If there was any problem\n   decompressing the dlabel in question, this routine will return a 0.\n*/\n\njs_string *decomp_get_label(js_string *compressed,\n                            unsigned int compressed_offset) {\n    js_string *ret; /* The string we return */\n    int counter, cplace, cplace_save, dplace, limit;\n\n    decomp_message(\"Performing sanity checks on compressed string...\",5);\n\n    /* Sanity checks */\n    if(compressed == 0)\n        return 0;\n    if(compressed->unit_size != 1)\n        return 0;\n    if(compressed->unit_count > compressed->max_count)\n        return 0;\n    if(compressed_offset > compressed->unit_count)\n        return 0;\n\n    decomp_message(\"Compressed string is sane.  Initializing variables...\",5);\n\n    /* Initialize the variables */\n    cplace = compressed_offset;\n    cplace_save = cplace;\n    dplace = 0;\n    counter = 0;\n    limit = 0;\n    if((ret = js_create(MAX_DLABEL_LEN + 3,1)) == 0)\n        return 0;\n\n    decomp_message(\"Variables initalized.\",5);\n\n    /* Decompress and copy */\n    do {\n        if(cplace >= compressed->unit_count) {\n            js_destroy(ret);\n            return 0;\n        }\n        limit++;\n        counter = *(compressed->string + cplace);\n        /* We do not allow invalid length values */\n        if(counter > 63 && counter < 0xC0) {\n            decomp_message(\"Invalid length value in compressed string\",4);\n            js_destroy(ret);\n            return 0;\n            }\n        else if(counter >= 0xC0) { /* Compression pointer */\n            /* Make sure we have two bytes for the compression pointer */\n            if(cplace + 1 >= compressed->unit_count) {\n                decomp_message(\"Compression pointer isn't fitting\",4);\n                js_destroy(ret);\n                return 0;\n                }\n            /* Get the compression pointer */\n            cplace_save = cplace;\n            cplace = ((counter & 0x3F) << 8);\n            cplace |= *(compressed->string + cplace_save + 1);\n            /* All compression labels must go backwards */\n            if(cplace >= cplace_save) {\n                decomp_message(\"Compressed pointer goes forward\",4);\n                js_destroy(ret);\n                return 0;\n                }\n            /* All compression lables must start past the header */\n            if(cplace < 12) {\n                decomp_message(\"Compressed pointer points to header\",4);\n                js_destroy(ret);\n                return 0;\n                }\n            }\n        /* Normal length dlabel */\n        else if(counter > 0 && counter <= 63) {\n            counter++;\n            if(dplace + counter >= ret->max_count) {\n                decomp_message(\"Pointing past end of ret string\",4);\n                js_destroy(ret);\n                return 0;\n                }\n            if(cplace + counter >= compressed->unit_count) {\n                decomp_message(\"Pointing past end of compressed string\",4);\n                js_destroy(ret);\n                return 0;\n                }\n            while(counter > 0) {\n                *(ret->string + dplace) = *(compressed->string + cplace);\n                ret->unit_count++;\n                dplace++;\n                cplace++;\n                counter--;\n                }\n            counter = 100; /* So we don't break out of loop */\n            }\n        else if(counter == 0) {\n            if(dplace + counter >= ret->max_count) {\n                decomp_message(\"Pointing past end of the compressed string\",4);\n                js_destroy(ret);\n                return 0;\n                }\n            *(ret->string + dplace) = 0;\n            ret->unit_count++;\n            }\n        else { /* Should never happen */\n            decomp_message(\"This, folks, should never happen\",4);\n            js_destroy(ret);\n            return 0;\n            }\n        } while(counter > 0 && limit < 256);\n\n    if(limit >= 256) {\n        decomp_message(\"Limit exceeded when decompressing dlabel\",4);\n        js_destroy(ret);\n        return 0;\n        }\n\n    /* Force core dump */\n    /**(ret->string + 1000000) = 0;*/\n    return ret;\n    }\n\n/* decomp_append_dlabel: Get a dlabel from the compressed string,\n   appending the uncompressed dlabel to the uncompressed string.\n\n   Input:\n\n   compressed: The compressed string\n   uncompressed: The partially decompressed string\n   compressed_offset: Where in the string to look (0 is the top of the\n                      string, 1 is the second byte of the string, etc.)\n\n   Output:\n\n   The length of the compressed dlabel; JS_ERROR if there was an\n   error decompressing\n\n */\n\nint decomp_append_dlabel(js_string *compressed, js_string *uncompressed,\n                         unsigned int compressed_offset) {\n\n    js_string *dlabel;\n    int length = 0;\n\n    /* Sanity checks */\n    if(js_has_sanity(compressed) != JS_SUCCESS) {\n        return JS_ERROR;\n        }\n    if(js_has_sanity(uncompressed) != JS_SUCCESS) {\n        return JS_ERROR;\n        }\n     if(compressed->unit_size != 1) {\n        return JS_ERROR;\n        }\n     if(uncompressed->unit_size != 1) {\n        return JS_ERROR;\n        }\n     if(compressed_offset >= compressed->unit_count) {\n        return JS_ERROR;\n        }\n\n    /* Get and process the actual compressed dname to append */\n    dlabel = decomp_get_label(compressed, compressed_offset);\n    if(dlabel == 0) {\n        return JS_ERROR;\n        }\n    length = dlabel_length(compressed,compressed_offset);\n    if(length == JS_ERROR) {\n        js_destroy(dlabel);\n        return JS_ERROR;\n        }\n\n    /* Append the label in question */\n    if(js_append(dlabel,uncompressed) == JS_ERROR) {\n        js_destroy(dlabel);\n        return JS_ERROR;\n        }\n\n    /* Success! */\n    js_destroy(dlabel);\n    return length;\n    }\n\n/* decomp_append_bytes:\n\n   Given the user-specified substring of one js_string object, append\n   that data to another js_string (this is used a lot with the\n   decompression code)\n\n   Input\n\n   compressed:        The string we will be appending from\n   uncompressed:      The string we will be appending to\n   compressed_offset: The offset to start the appending from\n   length:            The number of bytes to append\n\n   Output\n\n   JS_ERROR on error\n   JS_SUCCESS on success\n\n   Note\n\n   This really should eventually become a JsStr primitive\n\n */\n\nint decomp_append_bytes(js_string *compressed, js_string *uncompressed,\n                        unsigned int compressed_offset, int length) {\n\n    js_string *temp;\n    if((temp = js_create(length + 2,1)) == 0) {\n        return JS_ERROR;\n        }\n\n    if(compressed->unit_count < compressed_offset + length) {\n        js_destroy(temp);\n        return JS_ERROR;\n        }\n\n    if(js_substr(compressed,temp,compressed_offset,length) != JS_SUCCESS) {\n        js_destroy(temp);\n        return JS_ERROR;\n        }\n\n    if(js_append(temp,uncompressed) == JS_ERROR) {\n        js_destroy(temp);\n        return JS_ERROR;\n        }\n\n    js_destroy(temp);\n    return JS_SUCCESS;\n    }\n\n/* decomp_get_type_etc:\n\n   Get the resource record type (and some other data: The class and TTL, which\n   do not matter as far as decompressing a string are concerned) from the\n   compressed string, and copy the data over to the uncompressed string.\n\n   Input\n\n   compressed: The compressed string\n   uncompressed: The partially decompressed string\n   compressed_offset: Where in the string to look (0 is the top of the\n                      string, 1 is the second byte of the string, etc.)\n\n   Output\n\n   JS_ERROR on error;  RR type (0-65536) on success\n\n   Increase offset by eight bytes after running this.\n\n */\n\nint decomp_get_type_etc(js_string *compressed, js_string\n                        *uncompressed, unsigned int compressed_offset) {\n\n    int type;\n\n    type = js_readuint16(compressed,compressed_offset);\n\n    if(decomp_append_bytes(compressed,uncompressed,compressed_offset,8) !=\n       JS_SUCCESS) {\n        return JS_ERROR;\n        }\n\n    return type;\n\n    }\n\n/* decomp_get_rdlength\n\n   Get the resource record rdlength from the compressed string.\n   Note that this is how long the rddata is *compressed*, the\n   length can very well change when it is uncompreseed.\n\n   Input\n\n   compressed: The compressed string\n   compressed_offset: Where in the string to look (0 is the top of\n                      the string, 1 is the second byte of the string,\n                      etc.)\n\n   Output\n\n   JS_ERROR on error, RDLENGTH (0-65536) on success\n\n */\n\nint decomp_get_rdlength(js_string *compressed,\n                        unsigned int compressed_offset) {\n\n    int rdlength;\n\n    rdlength = js_readuint16(compressed,compressed_offset);\n\n    return rdlength;\n\n    }\n\n/* decomp_get_header\n\n   Get the 12 byte header for a DNS packet; making sure that qdcount\n   (bytes 5 and 6 in big endian format) is 0 or one; and that there are\n   no answers if qdcount is 0.\n\n   Input\n\n   compressed: The compressed string\n   uncompressed: The empty uncompressed string (returns error if string\n                 is not empty)\n\n   Output\n\n   The total number of answers; -2 if there are no questions and no\n   answers; JS_ERROR (-1) on error; -3 if there are no questions and\n   one answer (yes, some DNS servers do this with zone files)\n\n */\n\nint decomp_get_header(js_string *compressed, js_string *uncompressed) {\n    int qdcount, ancount, nscount, arcount, total;\n\n    /* Sanity checks */\n    if(js_has_sanity(compressed) == JS_ERROR) {\n        return JS_ERROR;\n        }\n    if(js_has_sanity(uncompressed) == JS_ERROR) {\n        return JS_ERROR;\n        }\n    if(compressed->unit_count < 12) {\n        return JS_ERROR;\n        }\n    if(uncompressed->unit_count != 0) {\n        return JS_ERROR;\n        }\n\n    /* Get the number of questions */\n    qdcount = js_readuint16(compressed,4);\n    if(qdcount < 0 || qdcount > 1)\n        return JS_ERROR;\n\n    /* Get the number of answers */\n    ancount = js_readuint16(compressed,6);\n    if(ancount < 0 || ancount > 65535)\n        return JS_ERROR;\n    nscount = js_readuint16(compressed,8);\n    if(nscount < 0 || nscount > 65535)\n        return JS_ERROR;\n    arcount = js_readuint16(compressed,10);\n    if(arcount < 0 || arcount > 65535)\n        return JS_ERROR;\n\n    total = ancount + nscount + arcount;\n\n    /* Copy the data over */\n    if(decomp_append_bytes(compressed,uncompressed,0,12) != JS_SUCCESS)\n        return JS_ERROR;\n\n    /* Yes, some zone servers do this */\n    if(qdcount == 0 && total >= 1)\n        return -2 - total;\n\n    /* And return the number of answers */\n    if(qdcount == 0)\n        return -2;\n\n    return total;\n\n    }\n\n/* decomp_get_question\n\n   Get the question from the DNS packet; it is assumed that the question\n   starts on the 13th byte.\n\n   Input\n\n   compressed: The compressed string\n   uncompressed:  The compressed string with only 12 bytes in it (returns\n                  error if string does not have 12 bytes)\n\n   Output\n\n   The length of the question; JS_ERROR on fatal error parsing question.\n\n */\n\nint decomp_get_question(js_string *compressed, js_string *uncompressed) {\n    int length;\n\n    /* Sanity checks */\n    if(compressed->unit_count < 12) {\n        return JS_ERROR;\n        }\n\n    if(uncompressed->unit_count != 12) {\n        return JS_ERROR;\n        }\n\n    /* Append the dlabel to the uncompressed string */\n    length = decomp_append_dlabel(compressed,uncompressed,12);\n    if(length < 1) {\n        return JS_ERROR;\n        }\n\n    /* Append the type and class to the uncompressed string */\n    if(decomp_append_bytes(compressed,uncompressed,12 + length,4)\n       != JS_SUCCESS) {\n        return JS_ERROR;\n        }\n\n    length += 4;\n\n    return length;\n\n    }\n\n/* decomp_init_rrdesc:\n\n   Initialize the rr_formats hash\n\n   Input\n\n   None\n\n   Output\n\n   JS_ERROR on error\n   JS_SUCCESS\n\n   Global variables affected\n\n   rr_formats\n\n */\n\nint decomp_init_rrdesc() {\n    int counter;\n\n    if((rr_formats = js_alloc(RR_HASH_SIZE,sizeof(rrdesc *))) == 0)\n        return JS_ERROR;\n\n    /* Zero out the hash table */\n    for(counter = 0; counter < RR_HASH_SIZE; counter++)\n        rr_formats[counter] = 0;\n\n    return JS_SUCCESS;\n\n    }\n\n/* decomp_add_rrdesc:\n\n   Add a description of a RR to the rr_formats hash\n\n   Input\n\n   A js_string which describes the record in question\n\n   Output\n\n   JS_ERROR on error\n   JS_SUCCESS on success\n   -2 for error in field 2, -3 for error in field 3, -4 for error in\n      field 4, and -5 for error in field 5.\n\n   Global variables used\n\n   rr_formats\n\n */\n\nint decomp_add_rrdesc(js_string *desc) {\n    int rtype, place, counter, fieldnum, subfieldnum;\n    unsigned char c;\n    rrdesc *new, *point;\n\n    /* Sanity checks */\n    if(js_has_sanity(desc) != JS_SUCCESS)\n        return JS_ERROR;\n    js_set_encode(desc,JS_US_ASCII); /* So js_atoi works */\n\n    /* Determine where to place this record in the hash */\n    if((new = js_alloc(1,sizeof(rrdesc))) == 0) {\n        return JS_ERROR;\n        }\n\n    /* Set up the description.  This is a format where the description\n       of each section of the RR is converted in to a single number */\n    if((new->description = js_alloc(MAX_RR_SECTIONS,1)) == 0) {\n        js_dealloc(new);\n        return JS_ERROR;\n        }\n    /* Clear out the new->description array */\n    for(counter = 0; counter < MAX_RR_SECTIONS - 1; counter++) {\n        new->description[counter] = 0;\n        }\n\n    /* Initialize the \"tocompress\" field to uninitialized; this is\n       a positive number under 127 because some versions of GCC on\n       some architectures consider 'char' without 'unsigned' an\n       unsigned value. */\n    new->tocompress = 79;\n\n    /* Now, parse the string describing the message */\n    fieldnum = subfieldnum = 1;\n    rtype = -1;\n    for(counter = 0; counter < desc->unit_count ; counter++) {\n        c = *(desc->string + counter);\n        if(fieldnum == 1) { /* RR number field */\n            if(subfieldnum == 1) /* Before first colon */ {\n                if(c == ':') {\n                    subfieldnum++;\n                    }\n                }\n            else if(subfieldnum == 2) /* Number immediately after colon */ {\n                if(rtype == -1) {\n                    rtype = js_atoi(desc,counter);\n                    if(rtype <= 0 || rtype > 65535) {\n                        js_dealloc(new->description);\n                        js_dealloc(new);\n                        return JS_ERROR;\n                        }\n                    new->rr_num = rtype;\n                    }\n                if(c == '|') {\n                    subfieldnum = 1;\n                    fieldnum = 2;\n                    }\n                }\n            }\n        else if(fieldnum == 2) { /* RR name field */\n            if(c == '|') {\n                subfieldnum = 1;\n                fieldnum = 3;\n                }\n            }\n        else if(fieldnum == 3) { /* The description of the RRs themselves */\n            /* Bounds check */\n            if(subfieldnum > MAX_RR_SECTIONS - 2) {\n                js_dealloc(new->description);\n                js_dealloc(new);\n                return JS_ERROR;\n                }\n            /* Process the RR subfield; this code only supports one-character\n               labels (quick and dirty; but I want to get 1.0 out the door)\n             */\n            if(new->description[subfieldnum - 1] == 0) {\n                if(c >= '1' && c <= '9') {\n                    new->description[subfieldnum - 1] = c - '0';\n                    }\n                else if(c == 'D') {\n                    new->description[subfieldnum - 1] = RRSUB_DLABEL;\n                    }\n                else if(c == 'T') {\n                    new->description[subfieldnum - 1] = RRSUB_TEXT;\n                    }\n                else if(c == 'V') {\n                    new->description[subfieldnum - 1] = RRSUB_VARIABLE;\n                    }\n                else { /* Unknown type */\n                    js_dealloc(new->description);\n                    js_dealloc(new);\n                    return JS_ERROR;\n                    }\n                }\n             else if(c != ';' && c != '|') { /* Multi-char description */\n                 js_dealloc(new->description);\n                 js_dealloc(new);\n                 return JS_ERROR;\n                 }\n             else if(c == ';') {\n                 /* Variable ('V') *must* be the last subfield */\n                 if(new->description[subfieldnum - 1] == RRSUB_VARIABLE) {\n                    js_dealloc(new->description);\n                    js_dealloc(new);\n                    return JS_ERROR;\n                    }\n                 subfieldnum++;\n                 }\n             else if(c == '|') {\n                 subfieldnum = 1;\n                 fieldnum = 4;\n                 }\n             else { /* Should never happen */\n                 js_dealloc(new->description);\n                 js_dealloc(new);\n                 return JS_ERROR;\n                 }\n             }\n         else if(fieldnum == 4) { /* Whether we can compress this field\n                                     or not; currently ignored */\n             if(c == 'C' && new->tocompress == 79) {\n                new->tocompress = 1;\n                }\n             else if(c == 'N' && new->tocompress == 79) {\n                new->tocompress = 0;\n                }\n             else if(c == '|' && new->tocompress != 79) {\n                subfieldnum = 1;\n                fieldnum = 5;\n                }\n             else { /* Invalid for field num */\n                js_dealloc(new->description);\n                js_dealloc(new);\n                return -4;\n                }\n             }\n         else if(fieldnum == 5) { /* Description of field; currently\n                                     ignored */\n             /* XXX: We really want something here which makes sure we\n                     have at least three subfields and considers a colon\n                     the start of a new RR */\n             break;\n             }\n         }\n\n     /* Now that the new field is set up, add the new element to the\n        hash of rr descriptions */\n\n     place = rtype % RR_HASH_SIZE;\n     if(rr_formats == 0) {\n        js_dealloc(new->description);\n        js_dealloc(new);\n        return JS_ERROR;\n        }\n     point = rr_formats[place];\n     if(point == 0) {\n         rr_formats[place] = new;\n         }\n     else {\n         while(point->next != 0)\n             point = point->next;\n         point->next = new;\n         }\n\n     new->next = 0;\n\n     /* OK, we're done (finally!) */\n     return JS_SUCCESS;\n     }\n\n/* decomp_init\n\n   Initialize the decompression code; set up the RRs, and set the\n   log_level global variable in the decompression code.\n\n   Input\n\n   The desired log_level for all of the decompression code\n\n   Output\n\n   JS_SUCCESS on success\n   JS_ERROR on error\n\n   Global variables affected\n\n   rr_formats (indirectly via decomp_add_rrdesc)\n   log_level\n\n */\n\nint decomp_init(int alog_level) {\n    js_string *temp; /* Used for storing the indivual RR descriptions */\n    int counter;\n\n    /* Create the string */\n    if((temp = js_create(256,1)) == 0) {\n        return JS_ERROR;\n        }\n\n    /* Add the records to the big hash */\n    decomp_init_rrdesc();\n    for(counter = 0 ; counter < RR_COUNT ; counter++) {\n        if(js_qstr2js(temp,rr_descs[counter]) != JS_SUCCESS) {\n            js_destroy(temp);\n            return JS_ERROR;\n            }\n        if(decomp_add_rrdesc(temp) != JS_SUCCESS) {\n            js_destroy(temp);\n            return JS_ERROR;\n            }\n        }\n\n    /* Set the log level */\n    dlog_level = alog_level;\n\n    js_destroy(temp);\n    return JS_SUCCESS;\n\n    }\n\n/* decomp_get_rddesc\n\n   Given the rtype (rr_num) (e.g. The resource record number where 1 is A,\n   etc.), give them a pointer to a null-terminated string which\n   contains the compiled rr description\n\n   Input\n\n   The number RR they wish\n\n   Output\n\n   A pointer to the compiled rr description.  0 if there was any\n   problem getting that\n\n   Global variables used\n\n   The \"rr_formats\" hash\n\n   Notes\n\n   This string can not be changed; if it is bad things can happen\n\n */\n\nchar *decomp_get_rrdesc(int rr_num) {\n    rrdesc *point;\n\n    if(rr_formats == 0)\n        return 0;\n\n    point = rr_formats[rr_num % RR_HASH_SIZE];\n    if(point == 0)\n        return 0;\n\n    while(point->rr_num != rr_num) {\n        point = point->next;\n        if(point == 0)\n            return 0;\n        }\n\n    return point->description;\n\n    }\n\n/* decomp_get_rddata\n\n   Get the rddata from the compressed string, decompressing any dlabels\n   as needed, and append the data to the uncompressed string.\n\n   Input\n\n   compressed: The compressed string\n   out: A js_string object to place the output in\n   compressed_offset: Where in the string to look (0 is the top of the\n     string, 1 is the second byte of the string, etc.)\n   type: The type of resource record (1 for A, 2 for NS, etc.)\n   rdlength: The rdlength this resource record should have\n\n   Output\n\n   JS_ERROR on error, JS_SUCCESS if there was no problem processing\n\n */\n\nint decomp_get_rddata(js_string *compressed, js_string *out,\n                      unsigned int compressed_offset, int type, int rdlength) {\n\n    char *desc;\n    int subtype, total, len;\n\n    desc = decomp_get_rrdesc(type);\n\n    if(desc == 0) { /* Unknown RR type */\n        if(rdlength == 0) {\n            return JS_SUCCESS;\n            }\n        if(decomp_append_bytes(compressed,out,compressed_offset,\n                               rdlength) != JS_SUCCESS) {\n            return JS_ERROR;\n            }\n        else {\n            return JS_SUCCESS;\n            }\n        }\n    else {\n        subtype = *desc;\n        total = 0;\n        /* Handle the various types of data we can get in the RR RDDATA */\n        while(subtype != 0) {\n            /* Fix-length data fields */\n            if(subtype > 0 && subtype < 64) {\n                if(decomp_append_bytes(compressed,out,\n                   compressed_offset,subtype) != JS_SUCCESS) {\n                       return JS_ERROR;\n                       }\n                total += subtype;\n                compressed_offset += subtype;\n                }\n            /* Dlabels (which may be compressed) */\n            else if(subtype == RRSUB_DLABEL) {\n                len = decomp_append_dlabel(compressed,out,\n                        compressed_offset);\n                if(len == JS_ERROR) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            /* Text data fields */\n            else if(subtype == RRSUB_TEXT) {\n                /* Data abstraction violation */\n                len = *(compressed->string + compressed_offset);\n                len += 1; /* To account for the one byte which\n                             describes the length */\n                if(len < 0 || len > 256) {\n                    return JS_ERROR;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) !=\n                   JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            /* Variable length data (length determined by rdlength) */\n            else if(subtype == RRSUB_VARIABLE) {\n                len = rdlength - total;\n                if(len == 0) {\n                    break;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) != JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else { /* Should never happen */\n                return JS_ERROR;\n                }\n            desc++;\n            /* RRSUB_VARIABLE must be the last subtype */\n            if(subtype != RRSUB_VARIABLE)\n                subtype = *desc;\n            else\n                subtype = 0; /* break the loop */\n            }\n        /* Sanity check; make sure that rdlength panned out */\n        if(rdlength != total) {\n            return JS_ERROR;\n            }\n        }\n\n    /* The record's rddata was sucessfully decompressed */\n    return JS_SUCCESS;\n    }\n\n/* decomp_decompress_packet\n\n   Uncompressed a query (or reply) compressed with the RFC1035 compression\n   alogrithm (see RFC1035  4.1.4)\n\n   Input\n\n   Pointer to compressed DNS packet\n   Pointer to uncompressed DNS packet\n\n   Output\n\n   JS_ERROR on error\n   JS_SUCCESS on success\n\n */\n\nint decomp_decompress_packet(js_string *compressed, js_string *uncompressed) {\n\n    int answers; /* Number of answers */\n    int type, rdlength; /* As per RFC1035  3.2.1 */\n    int offset,length;\n    js_string *rddata;\n\n    /* Sanity checks */\n\n    if(js_has_sanity(compressed) == JS_ERROR)\n        return JS_ERROR;\n    if(js_has_sanity(uncompressed) == JS_ERROR)\n        return JS_ERROR;\n    if(compressed->unit_size != 1 || uncompressed->unit_size != 1)\n        return JS_ERROR;\n    if(uncompressed->unit_count != 0)\n        return JS_ERROR;\n\n    /* Create the string for storing the rddata */\n#ifndef AUTHONLY\n    if((rddata = js_create(512,1)) == 0) {\n        return JS_ERROR;\n        }\n#else\n    if((rddata = js_create(4512,1)) == 0) {\n        return JS_ERROR;\n        }\n#endif\n    /* Read the header */\n\n    answers = decomp_get_header(compressed,uncompressed);\n    if(answers == -2) { /* No questions and no answers */\n        js_destroy(rddata);\n        return JS_SUCCESS;\n        }\n    else if(answers == JS_ERROR) {\n        js_destroy(rddata);\n        return JS_ERROR;\n        }\n\n    /* Process the question (if applicable) */\n    if(answers <= -3) {\n        answers = -2 - answers; /* So -3 becomes 1 answer, -4 becomes\n                                   2 answers, etc. */\n        length = 0;\n        }\n    else {\n        length = decomp_get_question(compressed,uncompressed);\n        if(length < 1) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        }\n\n    offset = 12 + length;\n\n    /* Process the answers */\n    while(answers > 0) {\n        length = decomp_append_dlabel(compressed,uncompressed,offset);\n        if(length < 1) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        offset += length;\n        type = decomp_get_type_etc(compressed,uncompressed,offset);\n        if(type == JS_ERROR) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        offset += 8;\n        rdlength = decomp_get_rdlength(compressed,offset);\n        if(rdlength == JS_ERROR) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        offset += 2;\n        /* Hack: zero out the rddata string */\n        rddata->unit_count = 0;\n        if(decomp_get_rddata(compressed,rddata,offset,type,rdlength)\n           != JS_SUCCESS) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        /* Add the decompressed rdlength */\n        if(js_adduint16(uncompressed,rddata->unit_count) == JS_ERROR) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        /* And the decompressed rddata */\n        if(js_append(rddata,uncompressed) == JS_ERROR) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        offset += rdlength; /* The compressed rdlength */\n        answers--;\n        }\n\n    js_destroy(rddata);\n    return JS_SUCCESS;\n    }\n\n/* decompress_data\n\n   This and the decomp_init function are the only functions which should\n   be visible to other code; the only \"public methods\" so to speak\n\n   Input\n\n   compressed string, uncompressed string\n\n   Output\n\n   JS_ERROR on error, JS_SUCCESS on success\n\n */\n\nint decompress_data(js_string *compressed, js_string *uncompressed) {\n    /* zero-out the uncompressed string */\n    uncompressed->unit_count = 0;\n\n    if(dlog_level >= 5) {\n       printf(\"About to decompress packet: \");\n       show_esc_stdout(compressed);\n       printf(\"\\n\");\n       }\n\n    if(dlog_level == -1) { /* Uninitialized, return error */\n        return JS_ERROR;\n        }\n    else {\n        return decomp_decompress_packet(compressed,uncompressed);\n        }\n\n    /* We should never end up here */\n    return JS_ERROR;\n    }\n\n/* Since the compression code needs to use the same rr_formats database,\n   this bit of code exports the rr_formats hash so that the compression\n   code can use it */\n\nrrdesc **decomp_export_rrformats() {\n    return rr_formats;\n    }\n\n"], "fixing_code": ["/* Copyright (c) 2002-2023 Sam Trenholme\n *\n * TERMS\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * This software is provided 'as is' with no guarantees of correctness or\n * fitness for purpose.\n */\n\n#include <stdio.h>\n#include \"../MaraDns.h\"\n#include \"../server/timestamp.h\"\n#include \"Compress_rrs.h\"\n#include \"Compress_rrdescs.h\" /* The description of RRs to decompress */\n#include \"functions_dns.h\"\n\n/* Some definitions */\n#define MAX_DLABEL_LEN 256\n#define MAX_RR_SECTIONS 16\n\n/* The hash that stores RRs */\nrrdesc **rr_formats;\n\n/* Whether to show verbose messages */\nint dlog_level = -1; /* -1 means uninitialized */\n\n/* decomp_message: Show, if needed, a message to the user.\n\n   Input: null-terminated string with the message, minimum log level\n          before which we will show the message\n\n   Output: JS_SUCCESS\n\n*/\n\nint decomp_message(char *message, int min_log_level) {\n    if(dlog_level >= min_log_level) {\n        show_timestamp();\n        printf(\"%s\\n\",message);\n        }\n    return JS_SUCCESS;\n    }\n\n/* decomp_get_label:  Uncompress a dlabel from a compressed string,\n   generating a js_string object which will store the decompressed\n   dlabel.\n\n   Input:\n   compressed: The compressed string\n   compressed_offset: The offset from the beginning of the string\n   where the compressed dlabel begins\n\n   Output:\n   The output of this function is a newly created js_string object\n   which contains the decompressed dlabel.  If there was any problem\n   decompressing the dlabel in question, this routine will return a 0.\n*/\n\njs_string *decomp_get_label(js_string *compressed,\n                            unsigned int compressed_offset) {\n    js_string *ret; /* The string we return */\n    int counter, cplace, cplace_save, dplace, limit;\n\n    decomp_message(\"Performing sanity checks on compressed string...\",5);\n\n    /* Sanity checks */\n    if(compressed == 0)\n        return 0;\n    if(compressed->unit_size != 1)\n        return 0;\n    if(compressed->unit_count > compressed->max_count)\n        return 0;\n    if(compressed_offset > compressed->unit_count)\n        return 0;\n\n    decomp_message(\"Compressed string is sane.  Initializing variables...\",5);\n\n    /* Initialize the variables */\n    cplace = compressed_offset;\n    cplace_save = cplace;\n    dplace = 0;\n    counter = 0;\n    limit = 0;\n    if((ret = js_create(MAX_DLABEL_LEN + 3,1)) == 0)\n        return 0;\n\n    decomp_message(\"Variables initalized.\",5);\n\n    /* Decompress and copy */\n    do {\n        if(cplace >= compressed->unit_count) {\n            js_destroy(ret);\n            return 0;\n        }\n        limit++;\n        counter = *(compressed->string + cplace);\n        /* We do not allow invalid length values */\n        if(counter > 63 && counter < 0xC0) {\n            decomp_message(\"Invalid length value in compressed string\",4);\n            js_destroy(ret);\n            return 0;\n            }\n        else if(counter >= 0xC0) { /* Compression pointer */\n            /* Make sure we have two bytes for the compression pointer */\n            if(cplace + 1 >= compressed->unit_count) {\n                decomp_message(\"Compression pointer isn't fitting\",4);\n                js_destroy(ret);\n                return 0;\n                }\n            /* Get the compression pointer */\n            cplace_save = cplace;\n            cplace = ((counter & 0x3F) << 8);\n            cplace |= *(compressed->string + cplace_save + 1);\n            /* All compression labels must go backwards */\n            if(cplace >= cplace_save) {\n                decomp_message(\"Compressed pointer goes forward\",4);\n                js_destroy(ret);\n                return 0;\n                }\n            /* All compression lables must start past the header */\n            if(cplace < 12) {\n                decomp_message(\"Compressed pointer points to header\",4);\n                js_destroy(ret);\n                return 0;\n                }\n            }\n        /* Normal length dlabel */\n        else if(counter > 0 && counter <= 63) {\n            counter++;\n            if(dplace + counter >= ret->max_count) {\n                decomp_message(\"Pointing past end of ret string\",4);\n                js_destroy(ret);\n                return 0;\n                }\n            if(cplace + counter >= compressed->unit_count) {\n                decomp_message(\"Pointing past end of compressed string\",4);\n                js_destroy(ret);\n                return 0;\n                }\n            while(counter > 0) {\n                *(ret->string + dplace) = *(compressed->string + cplace);\n                ret->unit_count++;\n                dplace++;\n                cplace++;\n                counter--;\n                }\n            counter = 100; /* So we don't break out of loop */\n            }\n        else if(counter == 0) {\n            if(dplace + counter >= ret->max_count) {\n                decomp_message(\"Pointing past end of the compressed string\",4);\n                js_destroy(ret);\n                return 0;\n                }\n            *(ret->string + dplace) = 0;\n            ret->unit_count++;\n            }\n        else { /* Should never happen */\n            decomp_message(\"This, folks, should never happen\",4);\n            js_destroy(ret);\n            return 0;\n            }\n        } while(counter > 0 && limit < 256);\n\n    if(limit >= 256) {\n        decomp_message(\"Limit exceeded when decompressing dlabel\",4);\n        js_destroy(ret);\n        return 0;\n        }\n\n    /* Force core dump */\n    /**(ret->string + 1000000) = 0;*/\n    return ret;\n    }\n\n/* decomp_append_dlabel: Get a dlabel from the compressed string,\n   appending the uncompressed dlabel to the uncompressed string.\n\n   Input:\n\n   compressed: The compressed string\n   uncompressed: The partially decompressed string\n   compressed_offset: Where in the string to look (0 is the top of the\n                      string, 1 is the second byte of the string, etc.)\n\n   Output:\n\n   The length of the compressed dlabel; JS_ERROR if there was an\n   error decompressing\n\n */\n\nint decomp_append_dlabel(js_string *compressed, js_string *uncompressed,\n                         unsigned int compressed_offset) {\n\n    js_string *dlabel;\n    int length = 0;\n\n    /* Sanity checks */\n    if(js_has_sanity(compressed) != JS_SUCCESS) {\n        return JS_ERROR;\n        }\n    if(js_has_sanity(uncompressed) != JS_SUCCESS) {\n        return JS_ERROR;\n        }\n     if(compressed->unit_size != 1) {\n        return JS_ERROR;\n        }\n     if(uncompressed->unit_size != 1) {\n        return JS_ERROR;\n        }\n     if(compressed_offset >= compressed->unit_count) {\n        return JS_ERROR;\n        }\n\n    /* Get and process the actual compressed dname to append */\n    dlabel = decomp_get_label(compressed, compressed_offset);\n    if(dlabel == 0) {\n        return JS_ERROR;\n        }\n    length = dlabel_length(compressed,compressed_offset);\n    if(length == JS_ERROR) {\n        js_destroy(dlabel);\n        return JS_ERROR;\n        }\n\n    /* Append the label in question */\n    if(js_append(dlabel,uncompressed) == JS_ERROR) {\n        js_destroy(dlabel);\n        return JS_ERROR;\n        }\n\n    /* Success! */\n    js_destroy(dlabel);\n    return length;\n    }\n\n/* decomp_append_bytes:\n\n   Given the user-specified substring of one js_string object, append\n   that data to another js_string (this is used a lot with the\n   decompression code)\n\n   Input\n\n   compressed:        The string we will be appending from\n   uncompressed:      The string we will be appending to\n   compressed_offset: The offset to start the appending from\n   length:            The number of bytes to append\n\n   Output\n\n   JS_ERROR on error\n   JS_SUCCESS on success\n\n   Note\n\n   This really should eventually become a JsStr primitive\n\n */\n\nint decomp_append_bytes(js_string *compressed, js_string *uncompressed,\n                        unsigned int compressed_offset, int length) {\n\n    js_string *temp;\n    if((temp = js_create(length + 2,1)) == 0) {\n        return JS_ERROR;\n        }\n\n    if(compressed->unit_count < compressed_offset + length) {\n        js_destroy(temp);\n        return JS_ERROR;\n        }\n\n    if(js_substr(compressed,temp,compressed_offset,length) != JS_SUCCESS) {\n        js_destroy(temp);\n        return JS_ERROR;\n        }\n\n    if(js_append(temp,uncompressed) == JS_ERROR) {\n        js_destroy(temp);\n        return JS_ERROR;\n        }\n\n    js_destroy(temp);\n    return JS_SUCCESS;\n    }\n\n/* decomp_get_type_etc:\n\n   Get the resource record type (and some other data: The class and TTL, which\n   do not matter as far as decompressing a string are concerned) from the\n   compressed string, and copy the data over to the uncompressed string.\n\n   Input\n\n   compressed: The compressed string\n   uncompressed: The partially decompressed string\n   compressed_offset: Where in the string to look (0 is the top of the\n                      string, 1 is the second byte of the string, etc.)\n\n   Output\n\n   JS_ERROR on error;  RR type (0-65536) on success\n\n   Increase offset by eight bytes after running this.\n\n */\n\nint decomp_get_type_etc(js_string *compressed, js_string\n                        *uncompressed, unsigned int compressed_offset) {\n\n    int type;\n\n    type = js_readuint16(compressed,compressed_offset);\n\n    if(decomp_append_bytes(compressed,uncompressed,compressed_offset,8) !=\n       JS_SUCCESS) {\n        return JS_ERROR;\n        }\n\n    return type;\n\n    }\n\n/* decomp_get_rdlength\n\n   Get the resource record rdlength from the compressed string.\n   Note that this is how long the rddata is *compressed*, the\n   length can very well change when it is uncompreseed.\n\n   Input\n\n   compressed: The compressed string\n   compressed_offset: Where in the string to look (0 is the top of\n                      the string, 1 is the second byte of the string,\n                      etc.)\n\n   Output\n\n   JS_ERROR on error, RDLENGTH (0-65536) on success\n\n */\n\nint decomp_get_rdlength(js_string *compressed,\n                        unsigned int compressed_offset) {\n\n    int rdlength;\n\n    rdlength = js_readuint16(compressed,compressed_offset);\n\n    return rdlength;\n\n    }\n\n/* decomp_get_header\n\n   Get the 12 byte header for a DNS packet; making sure that qdcount\n   (bytes 5 and 6 in big endian format) is 0 or one; and that there are\n   no answers if qdcount is 0.\n\n   Input\n\n   compressed: The compressed string\n   uncompressed: The empty uncompressed string (returns error if string\n                 is not empty)\n\n   Output\n\n   The total number of answers; -2 if there are no questions and no\n   answers; JS_ERROR (-1) on error; -3 if there are no questions and\n   one answer (yes, some DNS servers do this with zone files)\n\n */\n\nint decomp_get_header(js_string *compressed, js_string *uncompressed) {\n    int qdcount, ancount, nscount, arcount, total;\n\n    /* Sanity checks */\n    if(js_has_sanity(compressed) == JS_ERROR) {\n        return JS_ERROR;\n        }\n    if(js_has_sanity(uncompressed) == JS_ERROR) {\n        return JS_ERROR;\n        }\n    if(compressed->unit_count < 12) {\n        return JS_ERROR;\n        }\n    if(uncompressed->unit_count != 0) {\n        return JS_ERROR;\n        }\n\n    /* Get the number of questions */\n    qdcount = js_readuint16(compressed,4);\n    if(qdcount < 0 || qdcount > 1)\n        return JS_ERROR;\n\n    /* Get the number of answers */\n    ancount = js_readuint16(compressed,6);\n    if(ancount < 0 || ancount > 65535)\n        return JS_ERROR;\n    nscount = js_readuint16(compressed,8);\n    if(nscount < 0 || nscount > 65535)\n        return JS_ERROR;\n    arcount = js_readuint16(compressed,10);\n    if(arcount < 0 || arcount > 65535)\n        return JS_ERROR;\n\n    total = ancount + nscount + arcount;\n\n    /* Copy the data over */\n    if(decomp_append_bytes(compressed,uncompressed,0,12) != JS_SUCCESS)\n        return JS_ERROR;\n\n    /* Yes, some zone servers do this */\n    if(qdcount == 0 && total >= 1)\n        return -2 - total;\n\n    /* And return the number of answers */\n    if(qdcount == 0)\n        return -2;\n\n    return total;\n\n    }\n\n/* decomp_get_question\n\n   Get the question from the DNS packet; it is assumed that the question\n   starts on the 13th byte.\n\n   Input\n\n   compressed: The compressed string\n   uncompressed:  The compressed string with only 12 bytes in it (returns\n                  error if string does not have 12 bytes)\n\n   Output\n\n   The length of the question; JS_ERROR on fatal error parsing question.\n\n */\n\nint decomp_get_question(js_string *compressed, js_string *uncompressed) {\n    int length;\n\n    /* Sanity checks */\n    if(compressed->unit_count < 12) {\n        return JS_ERROR;\n        }\n\n    if(uncompressed->unit_count != 12) {\n        return JS_ERROR;\n        }\n\n    /* Append the dlabel to the uncompressed string */\n    length = decomp_append_dlabel(compressed,uncompressed,12);\n    if(length < 1) {\n        return JS_ERROR;\n        }\n\n    /* Append the type and class to the uncompressed string */\n    if(decomp_append_bytes(compressed,uncompressed,12 + length,4)\n       != JS_SUCCESS) {\n        return JS_ERROR;\n        }\n\n    length += 4;\n\n    return length;\n\n    }\n\n/* decomp_init_rrdesc:\n\n   Initialize the rr_formats hash\n\n   Input\n\n   None\n\n   Output\n\n   JS_ERROR on error\n   JS_SUCCESS\n\n   Global variables affected\n\n   rr_formats\n\n */\n\nint decomp_init_rrdesc() {\n    int counter;\n\n    if((rr_formats = js_alloc(RR_HASH_SIZE,sizeof(rrdesc *))) == 0)\n        return JS_ERROR;\n\n    /* Zero out the hash table */\n    for(counter = 0; counter < RR_HASH_SIZE; counter++)\n        rr_formats[counter] = 0;\n\n    return JS_SUCCESS;\n\n    }\n\n/* decomp_add_rrdesc:\n\n   Add a description of a RR to the rr_formats hash\n\n   Input\n\n   A js_string which describes the record in question\n\n   Output\n\n   JS_ERROR on error\n   JS_SUCCESS on success\n   -2 for error in field 2, -3 for error in field 3, -4 for error in\n      field 4, and -5 for error in field 5.\n\n   Global variables used\n\n   rr_formats\n\n */\n\nint decomp_add_rrdesc(js_string *desc) {\n    int rtype, place, counter, fieldnum, subfieldnum;\n    unsigned char c;\n    rrdesc *new, *point;\n\n    /* Sanity checks */\n    if(js_has_sanity(desc) != JS_SUCCESS)\n        return JS_ERROR;\n    js_set_encode(desc,JS_US_ASCII); /* So js_atoi works */\n\n    /* Determine where to place this record in the hash */\n    if((new = js_alloc(1,sizeof(rrdesc))) == 0) {\n        return JS_ERROR;\n        }\n\n    /* Set up the description.  This is a format where the description\n       of each section of the RR is converted in to a single number */\n    if((new->description = js_alloc(MAX_RR_SECTIONS,1)) == 0) {\n        js_dealloc(new);\n        return JS_ERROR;\n        }\n    /* Clear out the new->description array */\n    for(counter = 0; counter < MAX_RR_SECTIONS - 1; counter++) {\n        new->description[counter] = 0;\n        }\n\n    /* Initialize the \"tocompress\" field to uninitialized; this is\n       a positive number under 127 because some versions of GCC on\n       some architectures consider 'char' without 'unsigned' an\n       unsigned value. */\n    new->tocompress = 79;\n\n    /* Now, parse the string describing the message */\n    fieldnum = subfieldnum = 1;\n    rtype = -1;\n    for(counter = 0; counter < desc->unit_count ; counter++) {\n        c = *(desc->string + counter);\n        if(fieldnum == 1) { /* RR number field */\n            if(subfieldnum == 1) /* Before first colon */ {\n                if(c == ':') {\n                    subfieldnum++;\n                    }\n                }\n            else if(subfieldnum == 2) /* Number immediately after colon */ {\n                if(rtype == -1) {\n                    rtype = js_atoi(desc,counter);\n                    if(rtype <= 0 || rtype > 65535) {\n                        js_dealloc(new->description);\n                        js_dealloc(new);\n                        return JS_ERROR;\n                        }\n                    new->rr_num = rtype;\n                    }\n                if(c == '|') {\n                    subfieldnum = 1;\n                    fieldnum = 2;\n                    }\n                }\n            }\n        else if(fieldnum == 2) { /* RR name field */\n            if(c == '|') {\n                subfieldnum = 1;\n                fieldnum = 3;\n                }\n            }\n        else if(fieldnum == 3) { /* The description of the RRs themselves */\n            /* Bounds check */\n            if(subfieldnum > MAX_RR_SECTIONS - 2) {\n                js_dealloc(new->description);\n                js_dealloc(new);\n                return JS_ERROR;\n                }\n            /* Process the RR subfield; this code only supports one-character\n               labels (quick and dirty; but I want to get 1.0 out the door)\n             */\n            if(new->description[subfieldnum - 1] == 0) {\n                if(c >= '1' && c <= '9') {\n                    new->description[subfieldnum - 1] = c - '0';\n                    }\n                else if(c == 'D') {\n                    new->description[subfieldnum - 1] = RRSUB_DLABEL;\n                    }\n                else if(c == 'T') {\n                    new->description[subfieldnum - 1] = RRSUB_TEXT;\n                    }\n                else if(c == 'V') {\n                    new->description[subfieldnum - 1] = RRSUB_VARIABLE;\n                    }\n                else { /* Unknown type */\n                    js_dealloc(new->description);\n                    js_dealloc(new);\n                    return JS_ERROR;\n                    }\n                }\n             else if(c != ';' && c != '|') { /* Multi-char description */\n                 js_dealloc(new->description);\n                 js_dealloc(new);\n                 return JS_ERROR;\n                 }\n             else if(c == ';') {\n                 /* Variable ('V') *must* be the last subfield */\n                 if(new->description[subfieldnum - 1] == RRSUB_VARIABLE) {\n                    js_dealloc(new->description);\n                    js_dealloc(new);\n                    return JS_ERROR;\n                    }\n                 subfieldnum++;\n                 }\n             else if(c == '|') {\n                 subfieldnum = 1;\n                 fieldnum = 4;\n                 }\n             else { /* Should never happen */\n                 js_dealloc(new->description);\n                 js_dealloc(new);\n                 return JS_ERROR;\n                 }\n             }\n         else if(fieldnum == 4) { /* Whether we can compress this field\n                                     or not; currently ignored */\n             if(c == 'C' && new->tocompress == 79) {\n                new->tocompress = 1;\n                }\n             else if(c == 'N' && new->tocompress == 79) {\n                new->tocompress = 0;\n                }\n             else if(c == '|' && new->tocompress != 79) {\n                subfieldnum = 1;\n                fieldnum = 5;\n                }\n             else { /* Invalid for field num */\n                js_dealloc(new->description);\n                js_dealloc(new);\n                return -4;\n                }\n             }\n         else if(fieldnum == 5) { /* Description of field; currently\n                                     ignored */\n             /* XXX: We really want something here which makes sure we\n                     have at least three subfields and considers a colon\n                     the start of a new RR */\n             break;\n             }\n         }\n\n     /* Now that the new field is set up, add the new element to the\n        hash of rr descriptions */\n\n     place = rtype % RR_HASH_SIZE;\n     if(rr_formats == 0) {\n        js_dealloc(new->description);\n        js_dealloc(new);\n        return JS_ERROR;\n        }\n     point = rr_formats[place];\n     if(point == 0) {\n         rr_formats[place] = new;\n         }\n     else {\n         while(point->next != 0)\n             point = point->next;\n         point->next = new;\n         }\n\n     new->next = 0;\n\n     /* OK, we're done (finally!) */\n     return JS_SUCCESS;\n     }\n\n/* decomp_init\n\n   Initialize the decompression code; set up the RRs, and set the\n   log_level global variable in the decompression code.\n\n   Input\n\n   The desired log_level for all of the decompression code\n\n   Output\n\n   JS_SUCCESS on success\n   JS_ERROR on error\n\n   Global variables affected\n\n   rr_formats (indirectly via decomp_add_rrdesc)\n   log_level\n\n */\n\nint decomp_init(int alog_level) {\n    js_string *temp; /* Used for storing the indivual RR descriptions */\n    int counter;\n\n    /* Create the string */\n    if((temp = js_create(256,1)) == 0) {\n        return JS_ERROR;\n        }\n\n    /* Add the records to the big hash */\n    decomp_init_rrdesc();\n    for(counter = 0 ; counter < RR_COUNT ; counter++) {\n        if(js_qstr2js(temp,rr_descs[counter]) != JS_SUCCESS) {\n            js_destroy(temp);\n            return JS_ERROR;\n            }\n        if(decomp_add_rrdesc(temp) != JS_SUCCESS) {\n            js_destroy(temp);\n            return JS_ERROR;\n            }\n        }\n\n    /* Set the log level */\n    dlog_level = alog_level;\n\n    js_destroy(temp);\n    return JS_SUCCESS;\n\n    }\n\n/* decomp_get_rddesc\n\n   Given the rtype (rr_num) (e.g. The resource record number where 1 is A,\n   etc.), give them a pointer to a null-terminated string which\n   contains the compiled rr description\n\n   Input\n\n   The number RR they wish\n\n   Output\n\n   A pointer to the compiled rr description.  0 if there was any\n   problem getting that\n\n   Global variables used\n\n   The \"rr_formats\" hash\n\n   Notes\n\n   This string can not be changed; if it is bad things can happen\n\n */\n\nchar *decomp_get_rrdesc(int rr_num) {\n    rrdesc *point;\n\n    if(rr_formats == 0)\n        return 0;\n\n    point = rr_formats[rr_num % RR_HASH_SIZE];\n    if(point == 0)\n        return 0;\n\n    while(point->rr_num != rr_num) {\n        point = point->next;\n        if(point == 0)\n            return 0;\n        }\n\n    return point->description;\n\n    }\n\n/* decomp_get_rddata\n\n   Get the rddata from the compressed string, decompressing any dlabels\n   as needed, and append the data to the uncompressed string.\n\n   Input\n\n   compressed: The compressed string\n   out: A js_string object to place the output in\n   compressed_offset: Where in the string to look (0 is the top of the\n     string, 1 is the second byte of the string, etc.)\n   type: The type of resource record (1 for A, 2 for NS, etc.)\n   rdlength: The rdlength this resource record should have\n\n   Output\n\n   JS_ERROR on error, JS_SUCCESS if there was no problem processing\n\n */\n\nint decomp_get_rddata(js_string *compressed, js_string *out,\n                      unsigned int compressed_offset, int type, int rdlength) {\n\n    char *desc;\n    int subtype, total, len;\n\n    desc = decomp_get_rrdesc(type);\n\n    if(desc == 0) { /* Unknown RR type */\n        if(rdlength == 0) {\n            return JS_SUCCESS;\n            }\n        if(decomp_append_bytes(compressed,out,compressed_offset,\n                               rdlength) != JS_SUCCESS) {\n            return JS_ERROR;\n            }\n        else {\n            return JS_SUCCESS;\n            }\n        }\n    else {\n        subtype = *desc;\n        total = 0;\n        /* Handle the various types of data we can get in the RR RDDATA */\n        while(subtype != 0) {\n            /* Fix-length data fields */\n            if(subtype > 0 && subtype < 64) {\n                if(decomp_append_bytes(compressed,out,\n                   compressed_offset,subtype) != JS_SUCCESS) {\n                       return JS_ERROR;\n                       }\n                total += subtype;\n                compressed_offset += subtype;\n                }\n            /* Dlabels (which may be compressed) */\n            else if(subtype == RRSUB_DLABEL) {\n                len = decomp_append_dlabel(compressed,out,\n                        compressed_offset);\n                if(len == JS_ERROR) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            /* Text data fields */\n            else if(subtype == RRSUB_TEXT) {\n                /* Data abstraction violation */\n                len = *(compressed->string + compressed_offset);\n                len += 1; /* To account for the one byte which\n                             describes the length */\n                if(len < 0 || len > 256) {\n                    return JS_ERROR;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) !=\n                   JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            /* Variable length data (length determined by rdlength) */\n            else if(subtype == RRSUB_VARIABLE) {\n                len = rdlength - total;\n                if(len <= 0) {\n                    break;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) != JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else { /* Should never happen */\n                return JS_ERROR;\n                }\n            desc++;\n            /* RRSUB_VARIABLE must be the last subtype */\n            if(subtype != RRSUB_VARIABLE)\n                subtype = *desc;\n            else\n                subtype = 0; /* break the loop */\n            }\n        /* Sanity check; make sure that rdlength panned out */\n        if(rdlength != total) {\n            return JS_ERROR;\n            }\n        }\n\n    /* The record's rddata was sucessfully decompressed */\n    return JS_SUCCESS;\n    }\n\n/* decomp_decompress_packet\n\n   Uncompressed a query (or reply) compressed with the RFC1035 compression\n   alogrithm (see RFC1035  4.1.4)\n\n   Input\n\n   Pointer to compressed DNS packet\n   Pointer to uncompressed DNS packet\n\n   Output\n\n   JS_ERROR on error\n   JS_SUCCESS on success\n\n */\n\nint decomp_decompress_packet(js_string *compressed, js_string *uncompressed) {\n\n    int answers; /* Number of answers */\n    int type, rdlength; /* As per RFC1035  3.2.1 */\n    int offset,length;\n    js_string *rddata;\n\n    /* Sanity checks */\n\n    if(js_has_sanity(compressed) == JS_ERROR)\n        return JS_ERROR;\n    if(js_has_sanity(uncompressed) == JS_ERROR)\n        return JS_ERROR;\n    if(compressed->unit_size != 1 || uncompressed->unit_size != 1)\n        return JS_ERROR;\n    if(uncompressed->unit_count != 0)\n        return JS_ERROR;\n\n    /* Create the string for storing the rddata */\n#ifndef AUTHONLY\n    if((rddata = js_create(512,1)) == 0) {\n        return JS_ERROR;\n        }\n#else\n    if((rddata = js_create(4512,1)) == 0) {\n        return JS_ERROR;\n        }\n#endif\n    /* Read the header */\n\n    answers = decomp_get_header(compressed,uncompressed);\n    if(answers == -2) { /* No questions and no answers */\n        js_destroy(rddata);\n        return JS_SUCCESS;\n        }\n    else if(answers == JS_ERROR) {\n        js_destroy(rddata);\n        return JS_ERROR;\n        }\n\n    /* Process the question (if applicable) */\n    if(answers <= -3) {\n        answers = -2 - answers; /* So -3 becomes 1 answer, -4 becomes\n                                   2 answers, etc. */\n        length = 0;\n        }\n    else {\n        length = decomp_get_question(compressed,uncompressed);\n        if(length < 1) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        }\n\n    offset = 12 + length;\n\n    /* Process the answers */\n    while(answers > 0) {\n        length = decomp_append_dlabel(compressed,uncompressed,offset);\n        if(length < 1) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        offset += length;\n        type = decomp_get_type_etc(compressed,uncompressed,offset);\n        if(type == JS_ERROR) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        offset += 8;\n        rdlength = decomp_get_rdlength(compressed,offset);\n        if(rdlength == JS_ERROR) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        offset += 2;\n        /* Hack: zero out the rddata string */\n        rddata->unit_count = 0;\n        if(decomp_get_rddata(compressed,rddata,offset,type,rdlength)\n           != JS_SUCCESS) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        /* Add the decompressed rdlength */\n        if(js_adduint16(uncompressed,rddata->unit_count) == JS_ERROR) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        /* And the decompressed rddata */\n        if(js_append(rddata,uncompressed) == JS_ERROR) {\n            js_destroy(rddata);\n            return JS_ERROR;\n            }\n        offset += rdlength; /* The compressed rdlength */\n        answers--;\n        }\n\n    js_destroy(rddata);\n    return JS_SUCCESS;\n    }\n\n/* decompress_data\n\n   This and the decomp_init function are the only functions which should\n   be visible to other code; the only \"public methods\" so to speak\n\n   Input\n\n   compressed string, uncompressed string\n\n   Output\n\n   JS_ERROR on error, JS_SUCCESS on success\n\n */\n\nint decompress_data(js_string *compressed, js_string *uncompressed) {\n    /* zero-out the uncompressed string */\n    uncompressed->unit_count = 0;\n\n    if(dlog_level >= 5) {\n       printf(\"About to decompress packet: \");\n       show_esc_stdout(compressed);\n       printf(\"\\n\");\n       }\n\n    if(dlog_level == -1) { /* Uninitialized, return error */\n        return JS_ERROR;\n        }\n    else {\n        return decomp_decompress_packet(compressed,uncompressed);\n        }\n\n    /* We should never end up here */\n    return JS_ERROR;\n    }\n\n/* Since the compression code needs to use the same rr_formats database,\n   this bit of code exports the rr_formats hash so that the compression\n   code can use it */\n\nrrdesc **decomp_export_rrformats() {\n    return rr_formats;\n    }\n\n"], "filenames": ["dns/Decompress.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [888], "fixing_code_start_loc": [1], "fixing_code_end_loc": [888], "type": "CWE-191", "message": "MaraDNS is open-source software that implements the Domain Name System (DNS). In version 3.5.0024 and prior, a remotely exploitable integer underflow vulnerability in the DNS packet decompression function allows an attacker to cause a Denial of Service by triggering an abnormal program termination.\n\nThe vulnerability exists in the `decomp_get_rddata` function within the `Decompress.c` file. When handling a DNS packet with an Answer RR of qtype 16 (TXT record) and any qclass, if the `rdlength` is smaller than `rdata`, the result of the line `Decompress.c:886` is a negative number `len = rdlength - total;`. This value is then passed to the `decomp_append_bytes` function without proper validation, causing the program to attempt to allocate a massive chunk of memory that is impossible to allocate. Consequently, the program exits with an error code of 64, causing a Denial of Service.\n\nOne proposed fix for this vulnerability is to patch `Decompress.c:887` by breaking `if(len <= 0)`, which has been incorporated in version 3.5.0036 via commit bab062bde40b2ae8a91eecd522e84d8b993bab58.", "other": {"cve": {"id": "CVE-2023-31137", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-09T14:15:13.607", "lastModified": "2023-05-25T04:15:10.313", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "MaraDNS is open-source software that implements the Domain Name System (DNS). In version 3.5.0024 and prior, a remotely exploitable integer underflow vulnerability in the DNS packet decompression function allows an attacker to cause a Denial of Service by triggering an abnormal program termination.\n\nThe vulnerability exists in the `decomp_get_rddata` function within the `Decompress.c` file. When handling a DNS packet with an Answer RR of qtype 16 (TXT record) and any qclass, if the `rdlength` is smaller than `rdata`, the result of the line `Decompress.c:886` is a negative number `len = rdlength - total;`. This value is then passed to the `decomp_append_bytes` function without proper validation, causing the program to attempt to allocate a massive chunk of memory that is impossible to allocate. Consequently, the program exits with an error code of 64, causing a Denial of Service.\n\nOne proposed fix for this vulnerability is to patch `Decompress.c:887` by breaking `if(len <= 0)`, which has been incorporated in version 3.5.0036 via commit bab062bde40b2ae8a91eecd522e84d8b993bab58."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-191"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:maradns:maradns:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.5.0024", "matchCriteriaId": "7CE5BE73-8D74-4618-AECC-3D28D3E70521"}]}]}], "references": [{"url": "https://github.com/samboy/MaraDNS/blob/08b21ea20d80cedcb74aa8f14979ec7c61846663/dns/Decompress.c#L886", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/samboy/MaraDNS/commit/bab062bde40b2ae8a91eecd522e84d8b993bab58", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/samboy/MaraDNS/security/advisories/GHSA-58m7-826v-9c3c", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3VSMLJX25MXGQ6A7UPOGK7VPUVDESPHL/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NB7LDZM5AGWC5BHHQHW6CP5OFNBBKFOQ/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/samboy/MaraDNS/commit/bab062bde40b2ae8a91eecd522e84d8b993bab58"}}