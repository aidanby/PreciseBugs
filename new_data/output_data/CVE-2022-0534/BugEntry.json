{"buggy_code": ["/*\n * Image handling routines for HTMLDOC, a HTML document processing program.\n *\n * Copyright \u00a9\u00a02011-2022 by Michael R Sweet.\n * Copyright \u00a9\u00a01997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#include \"htmldoc.h\"\n#include <setjmp.h>\n\n#ifdef HAVE_LIBJPEG\nextern \"C\" {\t\t/* Workaround for JPEG header problems... */\n#  include <jpeglib.h>\t/* JPEG/JFIF image definitions */\n}\n#endif // HAVE_JPEG\n\n#ifdef HAVE_LIBPNG\n#  include <png.h>\t/* Portable Network Graphics (PNG) definitions */\n#endif // HAVE_LIBPNG\n\n\n/*\n * GIF definitions...\n */\n\n#define GIF_INTERLACE\t0x40\n#define GIF_COLORMAP\t0x80\n\ntypedef uchar\tgif_cmap_t[256][3];\n\n\n/*\n * BMP definitions...\n */\n\n#ifndef BI_RGB\n#  define BI_RGB       0             /* No compression - straight BGR data */\n#  define BI_RLE8      1             /* 8-bit run-length compression */\n#  define BI_RLE4      2             /* 4-bit run-length compression */\n#  define BI_BITFIELDS 3             /* RGB bitmap with RGB masks */\n#endif /* !BI_RGB */\n\n\n/*\n * Local globals...\n */\n\nstatic size_t\tnum_images = 0,\t\t/* Number of images in cache */\n\t\talloc_images = 0;\t/* Allocated images */\nstatic image_t\t**images = NULL;\t/* Images in cache */\nstatic int\tgif_eof = 0;\t\t/* Did we hit EOF? */\n\n\n/*\n * Local functions...\n */\n\nstatic int\tgif_read_cmap(FILE *fp, int ncolors, gif_cmap_t cmap,\n\t\t              int *gray);\nstatic int\tgif_get_block(FILE *fp, uchar *buffer);\nstatic int\tgif_get_code (FILE *fp, int code_size, int first_time);\nstatic int\tgif_read_image(FILE *fp, image_t *img, gif_cmap_t cmap,\n\t\t               int interlace, int transparent);\nstatic int\tgif_read_lzw(FILE *fp, int first_time, int input_code_size);\n\nstatic int\timage_compare(image_t **img1, image_t **img2);\nstatic int\timage_load_bmp(image_t *img, FILE *fp, int gray, int load_data);\nstatic int\timage_load_gif(image_t *img, FILE *fp, int gray, int load_data);\n\n#ifdef HAVE_LIBJPEG\nstatic int\timage_load_jpeg(image_t *img, FILE *fp, int gray, int load_data);\nstatic void\tjpeg_error_handler(j_common_ptr);\n#endif // HAVE_LIBJPEG\n\n#ifdef HAVE_LIBPNG\nstatic int\timage_load_png(image_t *img, FILE *fp, int gray, int load_data);\n#endif // HAVE_LIBPNG\n\nstatic void\timage_need_mask(image_t *img, int scaling = 1);\nstatic void\timage_set_mask(image_t *img, int x, int y, uchar alpha = 0);\n\nstatic int\t\tread_long(FILE *fp);\nstatic unsigned short\tread_word(FILE *fp);\nstatic unsigned int\tread_dword(FILE *fp);\n\n\n/*\n * 'gif_read_cmap()' - Read the colormap from a GIF file...\n */\n\nstatic int\t\t\t\t/* O  - 0 on success, -1 on error */\ngif_read_cmap(FILE       *fp,\t\t/* I  - File to read from */\n  \t      int        ncolors,\t/* I  - Number of colors */\n\t      gif_cmap_t cmap,\t\t/* IO - Colormap array */\n\t      int        *gray)\t\t/* IO - 1 = grayscale */\n{\n  int\ti;\t\t\t\t/* Looping var */\n\n\n /*\n  * Read the colormap...\n  */\n\n  if (fread(cmap, 3, (size_t)ncolors, fp) < (size_t)ncolors)\n  {\n    progress_error(HD_ERROR_READ_ERROR,\n                   \"Unable to read GIF colormap: %s\", strerror(errno));\n    return (-1);\n  }\n\n /*\n  * Check to see if the colormap is a grayscale ramp...\n  */\n\n  for (i = 0; i < ncolors; i ++)\n    if (cmap[i][0] != cmap[i][1] || cmap[i][1] != cmap[i][2])\n      break;\n\n  if (i == ncolors)\n  {\n    *gray = 1;\n    return (0);\n  }\n\n /*\n  * If this needs to be a grayscale image, convert the RGB values to\n  * luminance values...\n  */\n\n  if (*gray)\n    for (i = 0; i < ncolors; i ++)\n      cmap[i][0] = (cmap[i][0] * 31 + cmap[i][1] * 61 + cmap[i][2] * 8) / 100;\n\n  return (0);\n}\n\n\n/*\n * 'gif_get_block()' - Read a GIF data block...\n */\n\nstatic int\t\t\t/* O - Number characters read */\ngif_get_block(FILE  *fp,\t/* I - File to read from */\n\t      uchar *buf)\t/* I - Input buffer */\n{\n  int\tcount;\t\t\t/* Number of character to read */\n\n\n /*\n  * Read the count byte followed by the data from the file...\n  */\n\n  if ((count = getc(fp)) == EOF)\n  {\n    gif_eof = 1;\n    return (-1);\n  }\n  else if (count == 0)\n    gif_eof = 1;\n  else if (fread(buf, 1, (size_t)count, fp) < (size_t)count)\n  {\n    progress_error(HD_ERROR_READ_ERROR,\n                   \"Unable to read GIF block of %d bytes: %s\", count,\n                   strerror(errno));\n    gif_eof = 1;\n    return (-1);\n  }\n  else\n    gif_eof = 0;\n\n  return (count);\n}\n\n\n/*\n * 'gif_get_code()' - Get a LZW code from the file...\n */\n\nstatic int\t\t\t/* O - LZW code */\ngif_get_code(FILE *fp,\t\t/* I - File to read from */\n\t     int  code_size,\t/* I - Size of code in bits */\n\t     int  first_time)\t/* I - 1 = first time, 0 = not first time */\n{\n  unsigned\t\ti, j,\t\t/* Looping vars */\n\t\t\tret;\t\t/* Return value */\n  int\t\t\tcount;\t\t/* Number of bytes read */\n  static uchar\t\tbuf[280];\t/* Input buffer */\n  static unsigned\tcurbit,\t\t/* Current bit */\n\t\t\tlastbit,\t/* Last bit in buffer */\n\t\t\tdone,\t\t/* Done with this buffer? */\n\t\t\tlast_byte;\t/* Last byte in buffer */\n  static unsigned\tbits[8] =\t/* Bit masks for codes */\n\t\t\t{\n\t\t\t  0x01, 0x02, 0x04, 0x08,\n\t\t\t  0x10, 0x20, 0x40, 0x80\n\t\t\t};\n\n\n  if (first_time)\n  {\n   /*\n    * Just initialize the input buffer...\n    */\n\n    curbit    = 0;\n    lastbit   = 0;\n    last_byte = 0;\n    done      = 0;\n\n    return (0);\n  }\n\n  if ((curbit + (unsigned)code_size) >= lastbit)\n  {\n   /*\n    * Don't have enough bits to hold the code...\n    */\n\n    if (done)\n    {\n      progress_error(HD_ERROR_READ_ERROR, \"Not enough data left to read GIF compression code.\");\n      return (-1);\t/* Sorry, no more... */\n    }\n\n   /*\n    * Move last two bytes to front of buffer...\n    */\n\n    if (last_byte > 1)\n    {\n      buf[0]    = buf[last_byte - 2];\n      buf[1]    = buf[last_byte - 1];\n      last_byte = 2;\n    }\n    else if (last_byte == 1)\n    {\n      buf[0]    = buf[last_byte - 1];\n      last_byte = 1;\n    }\n\n   /*\n    * Read in another buffer...\n    */\n\n    if ((count = gif_get_block(fp, buf + last_byte)) <= 0)\n    {\n     /*\n      * Whoops, no more data!\n      */\n\n      done = 1;\n      return (-1);\n    }\n\n   /*\n    * Update buffer state...\n    */\n\n    curbit    = curbit + 8 * last_byte - lastbit;\n    last_byte += (unsigned)count;\n    lastbit   = last_byte * 8;\n  }\n\n  for (ret = 0, i = curbit + (unsigned)code_size - 1, j = (unsigned)code_size;\n       j > 0;\n       i --, j --)\n    ret = (ret << 1) | ((buf[i / 8] & bits[i & 7]) != 0);\n\n  curbit += (unsigned)code_size;\n\n  return (int)ret;\n}\n\n\n/*\n * 'gif_read_image()' - Read a GIF image stream...\n */\n\nstatic int\t\t\t\t/* I - 0 = success, -1 = failure */\ngif_read_image(FILE       *fp,\t\t/* I - Input file */\n\t       image_t    *img,\t\t/* I - Image pointer */\n\t       gif_cmap_t cmap,\t\t/* I - Colormap */\n\t       int        interlace,\t/* I - Non-zero = interlaced image */\n\t       int        transparent)\t/* I - Transparent color */\n{\n  uchar\t\tcode_size,\t\t/* Code size */\n\t\t*temp;\t\t\t/* Current pixel */\n  int\t\txpos,\t\t\t/* Current X position */\n\t\typos,\t\t\t/* Current Y position */\n\t\tpass;\t\t\t/* Current pass */\n  int\t\tpixel;\t\t\t/* Current pixel */\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n\n\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n\n  temp = img->pixels;\n\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n\n    if (ypos >= img->height)\n      break;\n  }\n\n  return (0);\n}\n\n\n/*\n * 'gif_read_lzw()' - Read a byte from the LZW stream...\n */\n\nstatic int\t\t\t\t/* I - Byte from stream */\ngif_read_lzw(FILE *fp,\t\t\t/* I - File to read from */\n\t     int  first_time,\t\t/* I - 1 = first time, 0 = not first time */\n \t     int  input_code_size)\t/* I - Code size in bits */\n{\n  int\t\ti,\t\t\t/* Looping var */\n\t\tcode,\t\t\t/* Current code */\n\t\tincode;\t\t\t/* Input code */\n  static short\tfresh = 0,\t\t/* 1 = empty buffers */\n\t\tcode_size = 0,\t\t/* Current code size */\n\t\tset_code_size = 0,\t/* Initial code size set */\n\t\tmax_code = 0,\t\t/* Maximum code used */\n\t\tmax_code_size = 0,\t/* Maximum code size */\n\t\tfirstcode = 0,\t\t/* First code read */\n\t\toldcode = 0,\t\t/* Last code read */\n\t\tclear_code = 0,\t\t/* Clear code for LZW input */\n\t\tend_code = 0,\t\t/* End code for LZW input */\n\t\ttable[2][4096],\t\t/* String table */\n\t\tstack[8192],\t\t/* Output stack */\n\t\t*sp = stack;\t\t/* Current stack pointer */\n\n\n  if (first_time)\n  {\n   /*\n    * Setup LZW state...\n    */\n\n    set_code_size = (short)input_code_size;\n    code_size     = set_code_size + 1;\n    clear_code    = (short)(1 << set_code_size);\n    end_code      = clear_code + 1;\n    max_code_size = 2 * clear_code;\n    max_code      = clear_code + 2;\n\n   /*\n    * Initialize input buffers...\n    */\n\n    gif_get_code(fp, 0, 1);\n\n   /*\n    * Wipe the decompressor table...\n    */\n\n    fresh = 1;\n\n    for (i = 0; i < clear_code; i ++)\n    {\n      table[0][i] = 0;\n      table[1][i] = (short)i;\n    }\n\n    for (; i < 4096; i ++)\n      table[0][i] = table[1][0] = 0;\n\n    sp = stack;\n\n    return (0);\n  }\n  else if (fresh)\n  {\n    fresh = 0;\n\n    do\n      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);\n    while (firstcode == clear_code);\n\n    return (firstcode);\n  }\n\n  if (sp > stack)\n    return (*--sp);\n\n  while ((code = gif_get_code (fp, code_size, 0)) >= 0)\n  {\n    if (code == clear_code)\n    {\n      for (i = 0; i < clear_code; i ++)\n      {\n\ttable[0][i] = 0;\n\ttable[1][i] = (short)i;\n      }\n\n      for (; i < 4096; i ++)\n\ttable[0][i] = table[1][i] = 0;\n\n      code_size     = set_code_size + 1;\n      max_code_size = 2 * clear_code;\n      max_code      = clear_code + 2;\n\n      sp = stack;\n\n      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);\n\n      return (firstcode);\n    }\n    else if (code == end_code)\n    {\n      uchar\tbuf[260];\n\n\n      if (!gif_eof)\n        while (gif_get_block(fp, buf) > 0);\n\n      return (-2);\n    }\n\n    incode = code;\n\n    if (code >= max_code)\n    {\n      *sp++ = firstcode;\n      code  = oldcode;\n    }\n\n    while (code >= clear_code)\n    {\n      *sp++ = table[1][code];\n      if (code == table[0][code])\n\treturn (255);\n\n      code = table[0][code];\n    }\n\n    *sp++ = firstcode = table[1][code];\n    code  = max_code;\n\n    if (code < 4096)\n    {\n      table[0][code] = oldcode;\n      table[1][code] = firstcode;\n      max_code ++;\n\n      if (max_code >= max_code_size && max_code_size < 4096)\n      {\n\tmax_code_size *= 2;\n\tcode_size ++;\n      }\n    }\n\n    oldcode = (short)incode;\n\n    if (sp > stack)\n      return (*--sp);\n  }\n\n  return (code);\n}\n\n\n/*\n * 'image_compare()' - Compare two image filenames...\n */\n\nstatic int\t\t\t/* O - Result of comparison */\nimage_compare(image_t **img1,\t/* I - First image */\n              image_t **img2)\t/* I - Second image */\n{\n#ifdef WIN32\n  return (strcasecmp((*img1)->filename, (*img2)->filename));\n#else\n  return (strcmp((*img1)->filename, (*img2)->filename));\n#endif /* WIN32 */\n}\n\n\n/*\n * 'image_copy()' - Copy image files to the destination directory...\n */\n\nvoid\nimage_copy(const char *src,\t\t/* I - Source file */\n           const char *realsrc,\t\t/* I - Real source file */\n           const char *destpath)\t/* I - Destination path */\n{\n  char\t\tdest[255];\t\t/* Destination file */\n  FILE\t\t*in, *out;\t\t/* Input/output files */\n  uchar\t\tbuffer[8192];\t\t/* Data buffer */\n  int\t\tnbytes;\t\t\t/* Number of bytes in buffer */\n\n\n  if (!src || !realsrc || !destpath)\n    return;\n\n /*\n  * Figure out the destination filename...\n  */\n\n  if (!strcmp(destpath, \".\"))\n    strlcpy(dest, file_basename(src), sizeof(dest));\n  else\n    snprintf(dest, sizeof(dest), \"%s/%s\", destpath, file_basename(src));\n\n  if (!strcmp(dest, realsrc))\n    return;\n\n /*\n  * Open files and copy...\n  */\n\n  if ((in = fopen(realsrc, \"rb\")) == NULL)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Unable to open \\\"%s\\\" - %s\",\n                   realsrc, strerror(errno));\n    return;\n  }\n\n  if ((out = fopen(dest, \"wb\")) == NULL)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Unable to create \\\"%s\\\" - %s\",\n                   dest, strerror(errno));\n    fclose(in);\n    return;\n  }\n\n  while ((nbytes = fread(buffer, 1, sizeof(buffer), in)) > 0)\n    fwrite(buffer, 1, (size_t)nbytes, out);\n\n  progress_error(HD_ERROR_NONE, \"BYTES: %ld\", ftell(out));\n\n  fclose(in);\n  fclose(out);\n}\n\n\n/*\n * 'image_find()' - Find an image file in memory...\n */\n\nimage_t *\t\t\t/* O - Pointer to image */\nimage_find(const char *filename,/* I - Name of image file */\n           int        load_data)/* I - 1 = load image data */\n{\n  image_t\tkey,\t\t/* Search key... */\n\t\t*keyptr,\t/* Pointer to search key... */\n\t\t**match;\t/* Matching image */\n\n\n /*\n  * Range check...\n  */\n\n  if (filename == NULL)\n    return (NULL);\n\n  if (filename[0] == '\\0')\t/* Microsoft VC++ runtime bug workaround... */\n    return (NULL);\n\n /*\n  * See if we've already loaded it...\n  */\n\n  if (num_images > 0)\n  {\n    strlcpy(key.filename, filename, sizeof(key.filename));\n    keyptr = &key;\n\n    match = (image_t **)bsearch(&keyptr, images, (size_t)num_images, sizeof(image_t *),\n                                (int (*)(const void *, const void *))image_compare);\n    if (match != NULL)\n    {\n      if (load_data && !(*match)->pixels)\n        return (image_load((*match)->filename, (*match)->depth == 1, 1));\n      else\n        return (*match);\n    }\n  }\n\n  return (NULL);\n}\n\n\n/*\n * 'image_flush_cache()' - Flush the image cache...\n */\n\nvoid\nimage_flush_cache(void)\n{\n  size_t\ti;\t\t\t/* Looping var */\n\n\n /*\n  * Free the memory used by each image...\n  */\n\n  for (i = 0; i < num_images; i ++)\n  {\n    if (images[i]->mask)\n      free(images[i]->mask);\n\n    if (images[i]->pixels)\n      free(images[i]->pixels);\n\n    free(images[i]);\n  }\n\n  if (alloc_images)\n  {\n    free(images);\n\n    alloc_images = 0;\n  }\n\n  num_images = 0;\n}\n\n\n/*\n * 'image_getlist()' - Get the list of images that are loaded.\n */\n\nint\t\t\t\t/* O - Number of images in array */\nimage_getlist(image_t ***ptrs)\t/* O - Pointer to images array */\n{\n  *ptrs = images;\n  return (num_images);\n}\n\n\n/*\n * 'image_load()' - Load an image file from disk...\n */\n\nimage_t *\t\t\t/* O - Pointer to image */\nimage_load(const char *filename,/* I - Name of image file */\n           int        gray,\t/* I - 0 = color, 1 = grayscale */\n           int        load_data)/* I - 1 = load image data, 0 = just info */\n{\n#ifdef DEBUG\n  int\t\ti;\t\t/* Looping var */\n#endif // DEBUG\n  FILE\t\t*fp;\t\t/* File pointer */\n  uchar\t\theader[16];\t/* First 16 bytes of file */\n  image_t\t*img,\t\t/* New image buffer */\n\t\tkey,\t\t/* Search key... */\n\t\t*keyptr,\t/* Pointer to search key... */\n\t\t**match,\t/* Matching image */\n\t\t**temp;\t\t/* Temporary array pointer */\n  int\t\tstatus;\t\t/* Status of load... */\n  const char\t*realname;\t/* Real filename */\n\n\n /*\n  * Range check...\n  */\n\n  if (filename == NULL)\n    return (NULL);\n\n  if (filename[0] == '\\0')\t/* Microsoft VC++ runtime bug workaround... */\n    return (NULL);\n\n  DEBUG_printf((\"image_load(filename=\\\"%s\\\", gray=%d, load_data=%d)\\n\",\n                filename, gray, load_data));\n  DEBUG_printf((\"Path = \\\"%s\\\"\\n\", Path));\n\n /*\n  * See if we've already loaded it...\n  */\n\n  if (num_images > 0)\n  {\n    strlcpy(key.filename, filename, sizeof(key.filename));\n    keyptr = &key;\n\n    match = (image_t **)bsearch(&keyptr, images, (size_t)num_images, sizeof(image_t *),\n                                (int (*)(const void *, const void *))image_compare);\n    if (match != NULL && (!load_data || (*match)->pixels))\n    {\n      (*match)->use ++;\n      return (*match);\n    }\n  }\n  else\n    match = NULL;\n\n /*\n  * Figure out the file type...\n  */\n\n  if ((realname = file_find(Path, filename)) == NULL)\n  {\n    progress_error(HD_ERROR_FILE_NOT_FOUND,\n                   \"Unable to find image file \\\"%s\\\"!\", filename);\n    return (NULL);\n  }\n\n  if ((fp = fopen(realname, \"rb\")) == NULL)\n  {\n    progress_error(HD_ERROR_FILE_NOT_FOUND,\n                   \"Unable to open image file \\\"%s\\\" (%s) for reading!\",\n\t\t   filename, realname);\n    return (NULL);\n  }\n\n  if (fread(header, 1, sizeof(header), fp) == 0)\n  {\n    progress_error(HD_ERROR_READ_ERROR,\n                   \"Unable to read image file \\\"%s\\\"!\", filename);\n    fclose(fp);\n    return (NULL);\n  }\n\n#ifdef DEBUG\n  printf(\"Header for \\\"%s\\\" (%s): \\\"\", filename, realname);\n\n  for (i = 0; i < (int)sizeof(header); i ++)\n    if (header[i] < ' ' || header[i] >= 127)\n      printf(\"\\\\x%02X\", header[i]);\n    else\n      putchar(header[i]);\n\n  puts(\"\\\"\\n\");\n\n  printf(\"match = %p\\n\", (void *)match);\n#endif // DEBUG\n\n  rewind(fp);\n\n  // See if the images array needs to be resized...\n  if (!match)\n  {\n    if (num_images >= alloc_images)\n    {\n      // Yes...\n      alloc_images += ALLOC_FILES;\n\n      if (num_images == 0)\n\ttemp = (image_t **)malloc(sizeof(image_t *) * alloc_images);\n      else\n\ttemp = (image_t **)realloc(images, sizeof(image_t *) * alloc_images);\n\n      if (temp == NULL)\n      {\n\tprogress_error(HD_ERROR_OUT_OF_MEMORY,\n\t               \"Unable to allocate memory for %d images - %s\",\n                       (int)alloc_images, strerror(errno));\n\tfclose(fp);\n\treturn (NULL);\n      }\n\n      images = temp;\n    }\n\n    // Allocate memory...\n    img = (image_t *)calloc(sizeof(image_t), 1);\n\n    if (img == NULL)\n    {\n      progress_error(HD_ERROR_READ_ERROR, \"Unable to allocate memory for \\\"%s\\\"\",\n                     filename);\n      fclose(fp);\n      return (NULL);\n    }\n\n    images[num_images] = img;\n\n    strlcpy(img->filename, filename, sizeof(img->filename));\n    img->use = 1;\n  }\n  else\n    img = *match;\n\n  // Load the image as appropriate...\n  if (memcmp(header, \"GIF87a\", 6) == 0 ||\n      memcmp(header, \"GIF89a\", 6) == 0)\n    status = image_load_gif(img,  fp, gray, load_data);\n  else if (memcmp(header, \"BM\", 2) == 0)\n    status = image_load_bmp(img, fp, gray, load_data);\n#ifdef HAVE_LIBPNG\n  else if (memcmp(header, \"\\211PNG\", 4) == 0)\n    status = image_load_png(img, fp, gray, load_data);\n#endif // HAVE_LIBPNG\n#ifdef HAVE_LIBJPEG\n  else if (memcmp(header, \"\\377\\330\\377\", 3) == 0)\n    status = image_load_jpeg(img, fp, gray, load_data);\n#endif // HAVE_LIBJPEG\n  else\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"Unknown image file format for \\\"%s\\\".\",\n                   file_rlookup(filename));\n    fclose(fp);\n    free(img);\n    return (NULL);\n  }\n\n  fclose(fp);\n\n  if (status)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Unable to load image file \\\"%s\\\"!\",\n                   file_rlookup(filename));\n    if (!match)\n      free(img);\n    return (NULL);\n  }\n\n  if (!match)\n  {\n    num_images ++;\n    if (num_images > 1)\n      qsort(images, num_images, sizeof(image_t *),\n            (int (*)(const void *, const void *))image_compare);\n  }\n\n  return (img);\n}\n\n\n/*\n * 'image_load_bmp()' - Read a BMP image file.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_bmp(image_t *img,\t/* I - Image to load into */\n               FILE    *fp,\t/* I - File to read from */\n\t       int     gray,\t/* I - Grayscale image? */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  int\t\tinfo_size,\t/* Size of info header */\n\t\tdepth,\t\t/* Depth of image (bits) */\n\t\tcompression,\t/* Type of compression */\n\t\tcolors_used,\t/* Number of colors used */\n\t\tx, y,\t\t/* Looping vars */\n\t\tcolor,\t\t/* Color of RLE pixel */\n\t\tcount,\t\t/* Number of times to repeat */\n\t\ttemp,\t\t/* Temporary color */\n\t\talign;\t\t/* Alignment bytes */\n  uchar\t\tbit,\t\t/* Bit in image */\n\t\tbyte;\t\t/* Byte in image */\n  uchar\t\t*ptr;\t\t/* Pointer into pixels */\n  uchar\t\tcolormap[256][4];/* Colormap */\n\n\n  // Get the header...\n  getc(fp);\t\t\t/* Skip \"BM\" sync chars */\n  getc(fp);\n  read_dword(fp);\t\t/* Skip size */\n  read_word(fp);\t\t/* Skip reserved stuff */\n  read_word(fp);\n  read_dword(fp);\n\n  // Then the bitmap information...\n  info_size        = (int)read_dword(fp);\n  img->width       = read_long(fp);\n  img->height      = read_long(fp);\n  read_word(fp);\n  depth            = read_word(fp);\n  compression      = (int)read_dword(fp);\n  read_dword(fp);\n  read_long(fp);\n  read_long(fp);\n  colors_used      = (int)read_dword(fp);\n  read_dword(fp);\n\n  if (img->width <= 0 || img->width > 8192 || img->height <= 0 || img->height > 8192 || info_size < 0)\n    return (-1);\n\n  if (info_size > 40)\n  {\n    for (info_size -= 40; info_size > 0; info_size --)\n      getc(fp);\n  }\n\n  // Get colormap...\n  if (colors_used == 0 && depth <= 8)\n    colors_used = 1 << depth;\n  else if (colors_used < 0 || colors_used > 256)\n    return (-1);\n\n  fread(colormap, (size_t)colors_used, 4, fp);\n\n  // Setup image and buffers...\n  img->depth = gray ? 1 : 3;\n\n  // If this image is indexed and we are writing an encrypted PDF file, bump the use count so\n  // we create an image object (Acrobat 6 bug workaround)\n  if (depth <= 8 && Encryption)\n    img->use ++;\n\n  // Return now if we only need the dimensions...\n  if (!load_data)\n    return (0);\n\n  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n  if (img->pixels == NULL)\n    return (-1);\n\n  if (gray && depth <= 8)\n  {\n    // Convert colormap to grayscale...\n    for (color = colors_used - 1; color >= 0; color --)\n      colormap[color][0] = (colormap[color][2] * 31 +\n                            colormap[color][1] * 61 +\n                            colormap[color][0] * 8) / 100;\n  }\n\n  // Read the image data...\n  color = 0;\n  count = 0;\n  align = 0;\n  byte  = 0;\n  temp  = 0;\n\n  for (y = img->height - 1; y >= 0; y --)\n  {\n    ptr = img->pixels + y * img->width * img->depth;\n\n    switch (depth)\n    {\n      case 1 : /* Bitmap */\n          for (x = img->width, bit = 128; x > 0; x --)\n\t  {\n\t    if (bit == 128)\n\t      byte = (uchar)getc(fp);\n\n\t    if (byte & bit)\n\t    {\n\t      if (!gray)\n\t      {\n\t\t*ptr++ = colormap[1][2];\n\t\t*ptr++ = colormap[1][1];\n              }\n\n\t      *ptr++ = colormap[1][0];\n\t    }\n\t    else\n\t    {\n\t      if (!gray)\n\t      {\n\t\t*ptr++ = colormap[0][2];\n\t\t*ptr++ = colormap[0][1];\n\t      }\n\n\t      *ptr++ = colormap[0][0];\n\t    }\n\n\t    if (bit > 1)\n\t      bit >>= 1;\n\t    else\n\t      bit = 128;\n\t  }\n\n         /*\n\t  * Read remaining bytes to align to 32 bits...\n\t  */\n\n\t  for (temp = (img->width + 7) / 8; temp & 3; temp ++)\n\t    getc(fp);\n          break;\n\n      case 4 : /* 16-color */\n          for (x = img->width, bit = 0xf0; x > 0; x --)\n\t  {\n\t   /*\n\t    * Get a new count as needed...\n\t    */\n\n            if (compression != BI_RLE4 && count == 0)\n\t    {\n\t      count = 2;\n\t      color = -1;\n            }\n\n\t    if (count == 0)\n\t    {\n\t      while (align > 0)\n\t      {\n\t        align --;\n\t\tgetc(fp);\n              }\n\n\t      if ((count = getc(fp)) == 0)\n\t      {\n\t\tif ((count = getc(fp)) == 0)\n\t\t{\n\t\t /*\n\t\t  * End of line...\n\t\t  */\n\n                  x ++;\n\t\t  continue;\n\t\t}\n\t\telse if (count == 1)\n\t\t{\n\t\t /*\n\t\t  * End of image...\n\t\t  */\n\n\t\t  break;\n\t\t}\n\t\telse if (count == 2)\n\t\t{\n\t\t /*\n\t\t  * Delta...\n\t\t  */\n\n\t\t  count = getc(fp) * getc(fp) * img->width;\n\t\t  color = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t /*\n\t\t  * Absolute...\n\t\t  */\n\n\t\t  color = -1;\n\t\t  align = ((4 - (count & 3)) / 2) & 1;\n\t\t}\n\t      }\n\t      else\n\t        color = getc(fp);\n            }\n\n           /*\n\t    * Get a new color as needed...\n\t    */\n\n\t    count --;\n\n            if (bit == 0xf0)\n\t    {\n              if (color < 0)\n\t\ttemp = getc(fp) & 255;\n\t      else\n\t\ttemp = color;\n\n             /*\n\t      * Copy the color value...\n\t      */\n\n              if (!gray)\n\t      {\n\t\t*ptr++ = colormap[temp >> 4][2];\n\t\t*ptr++ = colormap[temp >> 4][1];\n              }\n\n\t      *ptr++ = colormap[temp >> 4][0];\n\t      bit    = 0x0f;\n            }\n\t    else\n\t    {\n             /*\n\t      * Copy the color value...\n\t      */\n\n\t      if (!gray)\n\t      {\n\t        *ptr++ = colormap[temp & 15][2];\n\t        *ptr++ = colormap[temp & 15][1];\n\t      }\n\n\t      *ptr++ = colormap[temp & 15][0];\n\t      bit    = 0xf0;\n\t    }\n\t  }\n          break;\n\n      case 8 : /* 256-color */\n          for (x = img->width; x > 0; x --)\n\t  {\n\t   /*\n\t    * Get a new count as needed...\n\t    */\n\n            if (compression != BI_RLE8)\n\t    {\n\t      count = 1;\n\t      color = -1;\n            }\n\n\t    if (count == 0)\n\t    {\n\t      while (align > 0)\n\t      {\n\t        align --;\n\t\tgetc(fp);\n              }\n\n\t      if ((count = getc(fp)) == 0)\n\t      {\n\t\tif ((count = getc(fp)) == 0)\n\t\t{\n\t\t /*\n\t\t  * End of line...\n\t\t  */\n\n                  x ++;\n\t\t  continue;\n\t\t}\n\t\telse if (count == 1)\n\t\t{\n\t\t /*\n\t\t  * End of image...\n\t\t  */\n\n\t\t  break;\n\t\t}\n\t\telse if (count == 2)\n\t\t{\n\t\t /*\n\t\t  * Delta...\n\t\t  */\n\n\t\t  count = getc(fp) * getc(fp) * img->width;\n\t\t  color = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t /*\n\t\t  * Absolute...\n\t\t  */\n\n\t\t  color = -1;\n\t\t  align = (2 - (count & 1)) & 1;\n\t\t}\n\t      }\n\t      else\n\t        color = getc(fp);\n            }\n\n           /*\n\t    * Get a new color as needed...\n\t    */\n\n            if (color < 0)\n\t      temp = getc(fp);\n\t    else\n\t      temp = color;\n\n            count --;\n\n           /*\n\t    * Copy the color value...\n\t    */\n\n            if (!gray)\n\t    {\n\t      *ptr++ = colormap[temp][2];\n\t      *ptr++ = colormap[temp][1];\n\t    }\n\n\t    *ptr++ = colormap[temp][0];\n\t  }\n          break;\n\n      case 24 : /* 24-bit RGB */\n          if (gray)\n\t  {\n            for (x = img->width; x > 0; x --)\n\t    {\n\t      temp = getc(fp) * 8;\n\t      temp += getc(fp) * 61;\n\t      temp += getc(fp) * 31;\n\t      *ptr++ = (uchar)(temp / 100);\n\t    }\n\t  }\n\t  else\n\t  {\n            for (x = img->width; x > 0; x --, ptr += 3)\n\t    {\n\t      ptr[2] = (uchar)getc(fp);\n\t      ptr[1] = (uchar)getc(fp);\n\t      ptr[0] = (uchar)getc(fp);\n\t    }\n          }\n\n         /*\n\t  * Read remaining bytes to align to 32 bits...\n\t  */\n\n\t  for (temp = img->width * 3; temp & 3; temp ++)\n\t    getc(fp);\n          break;\n    }\n  }\n\n  return (0);\n}\n\n\n/*\n * 'image_load_gif()' - Load a GIF image file...\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_gif(image_t *img,\t/* I - Image pointer */\n               FILE    *fp,\t/* I - File to load from */\n               int     gray,\t/* I - 0 = color, 1 = grayscale */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  uchar\t\tbuf[1024];\t/* Input buffer */\n  gif_cmap_t\tcmap;\t\t/* Colormap */\n  int\t\tncolors,\t/* Bits per pixel */\n\t\ttransparent;\t/* Transparent color index */\n\n\n /*\n  * Read the header; we already know it is a GIF file...\n  */\n\n  fread(buf, 13, 1, fp);\n\n  img->width  = (buf[7] << 8) | buf[6];\n  img->height = (buf[9] << 8) | buf[8];\n  ncolors     = 2 << (buf[10] & 0x07);\n\n  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)\n    return (-1);\n\n  // If we are writing an encrypted PDF file, bump the use count so we create\n  // an image object (Acrobat 6 bug workaround)\n  if (Encryption)\n    img->use ++;\n\n  if (buf[10] & GIF_COLORMAP)\n    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n      return (-1);\n\n  transparent = -1;\n\n  while (1)\n  {\n    switch (getc(fp))\n    {\n      case ';' :\t/* End of image */\n          return (-1);\t\t/* Early end of file */\n\n      case '!' :\t/* Extension record */\n          buf[0] = (uchar)getc(fp);\n          if (buf[0] == 0xf9)\t/* Graphic Control Extension */\n          {\n            gif_get_block(fp, buf);\n            if (buf[0] & 1)\t/* Get transparent color index */\n              transparent = buf[3];\n          }\n\n          while (gif_get_block(fp, buf) != 0);\n          break;\n\n      case ',' :\t/* Image data */\n          fread(buf, 9, 1, fp);\n\n          if (buf[8] & GIF_COLORMAP)\n          {\n            ncolors = 2 << (buf[8] & 0x07);\n\n\t    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n\t      return (-1);\n\t  }\n\n          img->width  = (buf[5] << 8) | buf[4];\n          img->height = (buf[7] << 8) | buf[6];\n          img->depth  = gray ? 1 : 3;\n\n\t  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)\n\t    return (-1);\n\n          if (transparent >= 0)\n          {\n           /*\n            * Map transparent color to background color...\n            */\n\n            if (BodyColor[0])\n\t    {\n\t      float rgb[3]; /* RGB color */\n\n\n\t      get_color((uchar *)BodyColor, rgb);\n\n\t      cmap[transparent][0] = (uchar)(rgb[0] * 255.0f + 0.5f);\n\t      cmap[transparent][1] = (uchar)(rgb[1] * 255.0f + 0.5f);\n\t      cmap[transparent][2] = (uchar)(rgb[2] * 255.0f + 0.5f);\n\t    }\n\t    else\n\t    {\n\t      cmap[transparent][0] = 255;\n              cmap[transparent][1] = 255;\n              cmap[transparent][2] = 255;\n\t    }\n\n           /*\n\t    * Allocate a mask image...\n\t    */\n\n            image_need_mask(img);\n\t  }\n\n\t  if (!load_data)\n\t    return (0);\n\n          img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n          if (img->pixels == NULL)\n            return (-1);\n\n\t  return (gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE, transparent));\n    }\n  }\n}\n\n\n#ifdef HAVE_LIBJPEG\ntypedef struct hd_jpeg_err_s\t// JPEG error manager extension\n{\n  struct jpeg_error_mgr\tjerr;\t// JPEG error manager information\n  jmp_buf\tretbuf;\t\t// setjmp() return buffer\n  char\t\tmessage[JMSG_LENGTH_MAX];\n\t\t\t\t// Last error message\n} hd_jpeg_err_t;\n\n\n/*\n * 'image_load_jpeg()' - Load a JPEG image file.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_jpeg(image_t *img,\t/* I - Image pointer */\n                FILE    *fp,\t/* I - File to load from */\n                int     gray,\t/* I - 0 = color, 1 = grayscale */\n                int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  struct jpeg_decompress_struct\tcinfo;\t\t/* Decompressor info */\n  hd_jpeg_err_t\t\t\tjerr;\t\t// JPEG error handler\nJSAMPROW\t\t\trow;\t\t/* Sample row pointer */\n\n\n  jpeg_std_error(&jerr.jerr);\n  jerr.jerr.error_exit = jpeg_error_handler;\n\n  if (setjmp(jerr.retbuf))\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"%s (%s)\", jerr.message,  file_rlookup(img->filename));\n    jpeg_destroy_decompress(&cinfo);\n    return (-1);\n  }\n\n  cinfo.err = (struct jpeg_error_mgr *)&jerr;\n  jpeg_create_decompress(&cinfo);\n  jpeg_stdio_src(&cinfo, fp);\n  jpeg_read_header(&cinfo, (boolean)1);\n\n  cinfo.quantize_colors = FALSE;\n\n  if (gray || cinfo.num_components == 1)\n  {\n    cinfo.out_color_space      = JCS_GRAYSCALE;\n    cinfo.out_color_components = 1;\n    cinfo.output_components    = 1;\n  }\n  else if (cinfo.num_components != 3)\n  {\n    jpeg_destroy_decompress(&cinfo);\n\n    progress_error(HD_ERROR_BAD_FORMAT,\n                   \"CMYK JPEG files are not supported! (%s)\",\n\t\t   file_rlookup(img->filename));\n    return (-1);\n  }\n  else\n  {\n    cinfo.out_color_space      = JCS_RGB;\n    cinfo.out_color_components = 3;\n    cinfo.output_components    = 3;\n  }\n\n  jpeg_calc_output_dimensions(&cinfo);\n\n  img->width  = (int)cinfo.output_width;\n  img->height = (int)cinfo.output_height;\n  img->depth  = (int)cinfo.output_components;\n\n  if (!load_data)\n  {\n    jpeg_destroy_decompress(&cinfo);\n    return (0);\n  }\n\n  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n\n  if (img->pixels == NULL)\n  {\n    jpeg_destroy_decompress(&cinfo);\n    return (-1);\n  }\n\n  jpeg_start_decompress(&cinfo);\n\n  while (cinfo.output_scanline < cinfo.output_height)\n  {\n    row = (JSAMPROW)(img->pixels + (size_t)cinfo.output_scanline * (size_t)cinfo.output_width * (size_t)cinfo.output_components);\n    jpeg_read_scanlines(&cinfo, &row, (JDIMENSION)1);\n  }\n\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n\n  return (0);\n}\n#endif // HAVE_LIBJPEG\n\n\n#ifdef HAVE_LIBPNG\n/*\n * 'image_load_png()' - Load a PNG image file.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_png(image_t *img,\t/* I - Image pointer */\n               FILE    *fp,\t/* I - File to read from */\n               int     gray,\t/* I - 0 = color, 1 = grayscale */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  int\t\ti, j;\t\t/* Looping vars */\n  png_structp\tpp;\t\t/* PNG read pointer */\n  png_infop\tinfo;\t\t/* PNG info pointers */\n  int\t\tdepth;\t\t/* Input image depth */\n  png_bytep\t*rows = NULL;\t/* PNG row pointers */\n  uchar\t\t*inptr,\t\t/* Input pixels */\n\t\t*outptr;\t/* Output pixels */\n  int\t\tcolor_type,\t/* PNG color mode */\n\t\tbit_depth;\t/* PNG bit depth */\n\n\n /*\n  * Setup the PNG data structures...\n  */\n\n  pp = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n  if (!pp)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY, \"Unable to allocate memory for PNG file: %s\",\n                   strerror(errno));\n    return (-1);\n  }\n\n  info = png_create_info_struct(pp);\n  if (!info)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY, \"Unable to allocate memory for PNG info: %s\",\n                   strerror(errno));\n\n    png_destroy_read_struct(&pp, NULL, NULL);\n\n    return (-1);\n  }\n\n  if (setjmp(png_jmpbuf(pp)))\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"PNG file contains errors!\");\n\n    png_destroy_read_struct(&pp, &info, NULL);\n\n    if (img != NULL)\n    {\n      free(img->pixels);\n      img->pixels = NULL;\n    }\n\n    free(rows);\n    rows = NULL;\n\n    return (-1);\n  }\n\n /*\n  * Initialize the PNG read \"engine\"...\n  */\n\n  png_init_io(pp, fp);\n\n#  if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n  // Don't throw errors with \"invalid\" sRGB profiles produced by Adobe apps.\n  png_set_option(pp, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#  endif // PNG_SKIP_sRGB_CHECK_PROFILE && PNG_SET_OPTION_SUPPORTED\n\n /*\n  * Get the image dimensions and convert to grayscale or RGB...\n  */\n\n  png_read_info(pp, info);\n\n  bit_depth  = png_get_bit_depth(pp, info);\n  color_type = png_get_color_type(pp, info);\n\n  if (png_get_valid(pp, info, PNG_INFO_tRNS))\n  {\n    png_set_tRNS_to_alpha(pp);\n    color_type |= PNG_COLOR_MASK_ALPHA;\n  }\n\n  if (color_type & PNG_COLOR_MASK_PALETTE)\n  {\n    png_set_palette_to_rgb(pp);\n\n    // If we are writing an encrypted PDF file, bump the use count so we create\n    // an image object (Acrobat 6 bug workaround)\n    if (Encryption)\n      img->use ++;\n  }\n  else if (!(color_type & PNG_COLOR_MASK_COLOR) && bit_depth < 8)\n  {\n    png_set_expand_gray_1_2_4_to_8(pp);\n  }\n  else if (bit_depth == 16)\n  {\n#  if PNG_LIBPNG_VER >= 10504\n    png_set_scale_16(pp);\n#  else\n    png_set_strip_16(pp);\n#  endif // PNG_LIBPNG_VER >= 10504\n  }\n\n  if (color_type & PNG_COLOR_MASK_COLOR)\n  {\n    depth      = 3;\n    img->depth = gray ? 1 : 3;\n  }\n  else\n  {\n    depth      = 1;\n    img->depth = 1;\n  }\n\n  img->width  = (int)png_get_image_width(pp, info);\n  img->height = (int)png_get_image_height(pp, info);\n\n  if (color_type & PNG_COLOR_MASK_ALPHA)\n  {\n    if ((PSLevel == 0 && PDFVersion >= 14) || PSLevel == 3)\n      image_need_mask(img, 8);\n    else if (PSLevel == 0 && PDFVersion == 13)\n      image_need_mask(img, 2);\n    else\n      image_need_mask(img);\n\n    depth ++;\n  }\n\n#  ifdef DEBUG\n  printf(\"bit_depth=%d, color_type=0x%04x, depth=%d, img->width=%d, img->height=%d, img->depth=%d\\n\", bit_depth, color_type, depth, img->width, img->height, img->depth);\n  if (color_type & PNG_COLOR_MASK_COLOR)\n    puts(\"    COLOR\");\n  else\n    puts(\"    GRAYSCALE\");\n  if (color_type & PNG_COLOR_MASK_ALPHA)\n    puts(\"    ALPHA\");\n  if (color_type & PNG_COLOR_MASK_PALETTE)\n    puts(\"    PALETTE\");\n#  endif // DEBUG\n\n  if (!load_data)\n  {\n    png_destroy_read_struct(&pp, &info, NULL);\n    return (0);\n  }\n\n  img->pixels = (uchar *)calloc(1, (size_t)(img->width * img->height * depth));\n\n /*\n  * Allocate pointers...\n  */\n\n  rows = (png_bytep *)calloc(png_get_image_height(pp, info), sizeof(png_bytep));\n\n  for (i = 0; i < (int)png_get_image_height(pp, info); i ++)\n    rows[i] = img->pixels + i * img->width * depth;\n\n /*\n  * Read the image, handling interlacing as needed...\n  */\n\n  for (i = png_set_interlace_handling(pp); i > 0; i --)\n    png_read_rows(pp, rows, NULL, (png_uint_32)img->height);\n\n /*\n  * Generate the alpha mask as necessary...\n  */\n\n  if (color_type & PNG_COLOR_MASK_ALPHA)\n  {\n#  ifdef DEBUG\n    for (inptr = img->pixels, i = 0; i < img->height; i ++)\n    {\n      for (j = 0; j < img->width; j ++, inptr += depth)\n        switch (depth)\n\t{\n\t  case 2 :\n\t      printf(\" %02X%02X\", inptr[0], inptr[1]);\n\t      break;\n\t  case 4 :\n\t      printf(\" %02X%02X%02X%02X\", inptr[0], inptr[1], inptr[2], inptr[3]);\n\t      break;\n\t}\n\n      putchar('\\n');\n    }\n#  endif // DEBUG\n\n    for (inptr = img->pixels + depth - 1, i = 0; i < img->height; i ++)\n      for (j = 0; j < img->width; j ++, inptr += depth)\n        image_set_mask(img, j, i, *inptr);\n  }\n\n /*\n  * Reformat the data as necessary for the reader...\n  */\n\n  if (gray && (color_type & PNG_COLOR_MASK_COLOR))\n  {\n   /*\n    * Grayscale output needed...\n    */\n\n    for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;\n         i > 0;\n         inptr += depth, outptr ++, i --)\n      *outptr = (31 * inptr[0] + 61 * inptr[1] + 8 * inptr[2]) / 100;\n  }\n  else if (img->depth != depth)\n  {\n   /*\n    * Remove alpha from final array...\n    */\n\n    if (depth == 4)\n    {\n      for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;\n           i > 0;\n           inptr ++, i --)\n      {\n        *outptr++ = *inptr++;\n        *outptr++ = *inptr++;\n        *outptr++ = *inptr++;\n      }\n    }\n    else\n    {\n      for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;\n           i > 0;\n           inptr ++, i --)\n        *outptr++ = *inptr++;\n    }\n  }\n\n /*\n  * Free memory and return...\n  */\n\n  png_read_end(pp, info);\n  png_destroy_read_struct(&pp, &info, NULL);\n\n  free(rows);\n\n  return (0);\n}\n#endif // HAVE_LIBPNG\n\n\n/*\n * 'image_need_mask()' - Allocate memory for the image mask...\n */\n\nstatic void\nimage_need_mask(image_t *img,\t\t/* I - Image to add mask to */\n                int     scaling)\t/* I - Scaling for mask image */\n{\n  size_t\tsize;\t\t\t/* Byte size of mask image */\n\n\n  if (img == NULL || img->mask != NULL)\n    return;\n\n /*\n  * Figure out the size of the mask image, and then allocate and set all the\n  * bits needed...\n  */\n\n  img->maskscale = scaling;\n\n  if (scaling == 8)\n  {\n    // Alpha image\n    img->maskwidth = img->width;\n    size           = (size_t)(img->width * img->height);\n  }\n  else\n  {\n    // Alpha mask\n    img->maskwidth = (img->width * scaling + 7) / 8;\n    size           = (size_t)(img->maskwidth * img->height * scaling + 1);\n  }\n\n  img->mask = (uchar *)calloc(size, 1);\n}\n\n\n/*\n * 'image_set_mask()' - Set a bit in the image mask.\n */\n\nstatic void\nimage_set_mask(image_t *img,\t/* I - Image to operate on */\n               int     x,\t/* I - X coordinate */\n               int     y,\t/* I - Y coordinate */\n\t       uchar   alpha)\t/* I - Alpha value */\n{\n  int\t\ti, j;\t\t/* Looping vars */\n  uchar\t\t*maskptr;\t/* Pointer into mask image */\n  static uchar\tmasks[8] =\t/* Masks for each bit */\n\t\t{\n\t\t  0x80, 0x40, 0x20, 0x10,\n\t\t  0x08, 0x04, 0x02, 0x01\n\t\t};\n  static uchar\tdither[4][4] = // Simple 4x4 clustered-dot dither\n\t\t{\n\t\t  { 0,  2,  15, 6 },\n\t\t  { 4,  12, 9,  11 },\n\t\t  { 14, 7,  1,  3 },\n\t\t  { 8,  10, 5,  13 }\n\t        };\n\n\n  if (img == NULL || img->mask == NULL || x < 0 || x >= img->width ||\n      y < 0 || y >= img->height)\n    return;\n\n  if (img->maskscale == 8)\n  {\n    // Store the alpha value directly...\n    if (PSLevel)\n      img->mask[y * img->maskwidth + x] = 255 - alpha;\n    else\n      img->mask[y * img->maskwidth + x] = alpha;\n  }\n  else\n  {\n    // Store an alpha mask...\n    x *= img->maskscale;\n    y *= img->maskscale;\n    alpha >>= 4;\n\n    for (i = 0; i < img->maskscale; i ++, y ++, x -= img->maskscale)\n      for (j = 0; j < img->maskscale; j ++, x ++)\n      {\n\tmaskptr  = img->mask + y * img->maskwidth + x / 8;\n\tif (alpha <= dither[x & 3][y & 3])\n\t  *maskptr |= masks[x & 7];\n      }\n  }\n}\n\n\n/*\n * 'image_unload()' - Unload an image from memory.\n */\n\nvoid\nimage_unload(image_t *img)\t// I - Image\n{\n  if (!img)\n    return;\n\n  if (!img->use || !img->pixels)\n    return;\n\n  if (img->obj)\n    img->use = 0;\n  else\n    img->use --;\n\n  if (img->use)\n    return;\n\n  free(img->pixels);\n  img->pixels = NULL;\n}\n\n\n#ifdef HAVE_LIBJPEG\n/*\n * 'jpeg_error_handler()' - Handle JPEG errors by not exiting.\n */\n\nstatic void\njpeg_error_handler(j_common_ptr p)\t// Common JPEG data\n{\n  hd_jpeg_err_t\t*jerr = (hd_jpeg_err_t *)p->err;\n\t\t\t\t\t// JPEG error handler\n\n\n  // Save the error message in the string buffer...\n  (jerr->jerr.format_message)(p, jerr->message);\n\n  // Return to the point we called setjmp()...\n  longjmp(jerr->retbuf, 1);\n}\n#endif // HAVE_LIBJPEG\n\n\n/*\n * 'read_word()' - Read a 16-bit unsigned integer.\n */\n\nstatic unsigned short     /* O - 16-bit unsigned integer */\nread_word(FILE *fp)       /* I - File to read from */\n{\n  unsigned char b0, b1; /* Bytes from file */\n\n  b0 = (uchar)getc(fp);\n  b1 = (uchar)getc(fp);\n\n  return (unsigned short)((b1 << 8) | b0);\n}\n\n\n/*\n * 'read_dword()' - Read a 32-bit unsigned integer.\n */\n\nstatic unsigned int               /* O - 32-bit unsigned integer */\nread_dword(FILE *fp)              /* I - File to read from */\n{\n  unsigned char b0, b1, b2, b3; /* Bytes from file */\n\n  b0 = (uchar)getc(fp);\n  b1 = (uchar)getc(fp);\n  b2 = (uchar)getc(fp);\n  b3 = (uchar)getc(fp);\n\n  return (unsigned)((((((b3 << 8) | b2) << 8) | b1) << 8) | b0);\n}\n\n\n/*\n * 'read_long()' - Read a 32-bit signed integer.\n */\n\nstatic int                        /* O - 32-bit signed integer */\nread_long(FILE *fp)               /* I - File to read from */\n{\n  unsigned char b0, b1, b2, b3; /* Bytes from file */\n\n  b0 = (uchar)getc(fp);\n  b1 = (uchar)getc(fp);\n  b2 = (uchar)getc(fp);\n  b3 = (uchar)getc(fp);\n\n  return ((int)(((((b3 << 8) | b2) << 8) | b1) << 8) | b0);\n}\n"], "fixing_code": ["/*\n * Image handling routines for HTMLDOC, a HTML document processing program.\n *\n * Copyright \u00a9\u00a02011-2022 by Michael R Sweet.\n * Copyright \u00a9\u00a01997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#include \"htmldoc.h\"\n#include <setjmp.h>\n\n#ifdef HAVE_LIBJPEG\nextern \"C\" {\t\t/* Workaround for JPEG header problems... */\n#  include <jpeglib.h>\t/* JPEG/JFIF image definitions */\n}\n#endif // HAVE_JPEG\n\n#ifdef HAVE_LIBPNG\n#  include <png.h>\t/* Portable Network Graphics (PNG) definitions */\n#endif // HAVE_LIBPNG\n\n\n/*\n * GIF definitions...\n */\n\n#define GIF_INTERLACE\t0x40\n#define GIF_COLORMAP\t0x80\n\ntypedef uchar\tgif_cmap_t[256][3];\n\n\n/*\n * BMP definitions...\n */\n\n#ifndef BI_RGB\n#  define BI_RGB       0             /* No compression - straight BGR data */\n#  define BI_RLE8      1             /* 8-bit run-length compression */\n#  define BI_RLE4      2             /* 4-bit run-length compression */\n#  define BI_BITFIELDS 3             /* RGB bitmap with RGB masks */\n#endif /* !BI_RGB */\n\n\n/*\n * Local globals...\n */\n\nstatic size_t\tnum_images = 0,\t\t/* Number of images in cache */\n\t\talloc_images = 0;\t/* Allocated images */\nstatic image_t\t**images = NULL;\t/* Images in cache */\nstatic int\tgif_eof = 0;\t\t/* Did we hit EOF? */\n\n\n/*\n * Local functions...\n */\n\nstatic int\tgif_read_cmap(FILE *fp, int ncolors, gif_cmap_t cmap,\n\t\t              int *gray);\nstatic int\tgif_get_block(FILE *fp, uchar *buffer);\nstatic int\tgif_get_code (FILE *fp, int code_size, int first_time);\nstatic int\tgif_read_image(FILE *fp, image_t *img, gif_cmap_t cmap,\n\t\t               int interlace, int transparent);\nstatic int\tgif_read_lzw(FILE *fp, int first_time, int input_code_size);\n\nstatic int\timage_compare(image_t **img1, image_t **img2);\nstatic int\timage_load_bmp(image_t *img, FILE *fp, int gray, int load_data);\nstatic int\timage_load_gif(image_t *img, FILE *fp, int gray, int load_data);\n\n#ifdef HAVE_LIBJPEG\nstatic int\timage_load_jpeg(image_t *img, FILE *fp, int gray, int load_data);\nstatic void\tjpeg_error_handler(j_common_ptr);\n#endif // HAVE_LIBJPEG\n\n#ifdef HAVE_LIBPNG\nstatic int\timage_load_png(image_t *img, FILE *fp, int gray, int load_data);\n#endif // HAVE_LIBPNG\n\nstatic void\timage_need_mask(image_t *img, int scaling = 1);\nstatic void\timage_set_mask(image_t *img, int x, int y, uchar alpha = 0);\n\nstatic int\t\tread_long(FILE *fp);\nstatic unsigned short\tread_word(FILE *fp);\nstatic unsigned int\tread_dword(FILE *fp);\n\n\n/*\n * 'gif_read_cmap()' - Read the colormap from a GIF file...\n */\n\nstatic int\t\t\t\t/* O  - 0 on success, -1 on error */\ngif_read_cmap(FILE       *fp,\t\t/* I  - File to read from */\n  \t      int        ncolors,\t/* I  - Number of colors */\n\t      gif_cmap_t cmap,\t\t/* IO - Colormap array */\n\t      int        *gray)\t\t/* IO - 1 = grayscale */\n{\n  int\ti;\t\t\t\t/* Looping var */\n\n\n /*\n  * Read the colormap...\n  */\n\n  if (fread(cmap, 3, (size_t)ncolors, fp) < (size_t)ncolors)\n  {\n    progress_error(HD_ERROR_READ_ERROR,\n                   \"Unable to read GIF colormap: %s\", strerror(errno));\n    return (-1);\n  }\n\n /*\n  * Check to see if the colormap is a grayscale ramp...\n  */\n\n  for (i = 0; i < ncolors; i ++)\n    if (cmap[i][0] != cmap[i][1] || cmap[i][1] != cmap[i][2])\n      break;\n\n  if (i == ncolors)\n  {\n    *gray = 1;\n    return (0);\n  }\n\n /*\n  * If this needs to be a grayscale image, convert the RGB values to\n  * luminance values...\n  */\n\n  if (*gray)\n    for (i = 0; i < ncolors; i ++)\n      cmap[i][0] = (cmap[i][0] * 31 + cmap[i][1] * 61 + cmap[i][2] * 8) / 100;\n\n  return (0);\n}\n\n\n/*\n * 'gif_get_block()' - Read a GIF data block...\n */\n\nstatic int\t\t\t/* O - Number characters read */\ngif_get_block(FILE  *fp,\t/* I - File to read from */\n\t      uchar *buf)\t/* I - Input buffer */\n{\n  int\tcount;\t\t\t/* Number of character to read */\n\n\n /*\n  * Read the count byte followed by the data from the file...\n  */\n\n  if ((count = getc(fp)) == EOF)\n  {\n    gif_eof = 1;\n    return (-1);\n  }\n  else if (count == 0)\n    gif_eof = 1;\n  else if (fread(buf, 1, (size_t)count, fp) < (size_t)count)\n  {\n    progress_error(HD_ERROR_READ_ERROR,\n                   \"Unable to read GIF block of %d bytes: %s\", count,\n                   strerror(errno));\n    gif_eof = 1;\n    return (-1);\n  }\n  else\n    gif_eof = 0;\n\n  return (count);\n}\n\n\n/*\n * 'gif_get_code()' - Get a LZW code from the file...\n */\n\nstatic int\t\t\t/* O - LZW code */\ngif_get_code(FILE *fp,\t\t/* I - File to read from */\n\t     int  code_size,\t/* I - Size of code in bits */\n\t     int  first_time)\t/* I - 1 = first time, 0 = not first time */\n{\n  unsigned\t\ti, j,\t\t/* Looping vars */\n\t\t\tret;\t\t/* Return value */\n  int\t\t\tcount;\t\t/* Number of bytes read */\n  static uchar\t\tbuf[280];\t/* Input buffer */\n  static unsigned\tcurbit,\t\t/* Current bit */\n\t\t\tlastbit,\t/* Last bit in buffer */\n\t\t\tdone,\t\t/* Done with this buffer? */\n\t\t\tlast_byte;\t/* Last byte in buffer */\n  static unsigned\tbits[8] =\t/* Bit masks for codes */\n\t\t\t{\n\t\t\t  0x01, 0x02, 0x04, 0x08,\n\t\t\t  0x10, 0x20, 0x40, 0x80\n\t\t\t};\n\n\n  if (first_time)\n  {\n   /*\n    * Just initialize the input buffer...\n    */\n\n    curbit    = 0;\n    lastbit   = 0;\n    last_byte = 0;\n    done      = 0;\n\n    return (0);\n  }\n\n  if ((curbit + (unsigned)code_size) >= lastbit)\n  {\n   /*\n    * Don't have enough bits to hold the code...\n    */\n\n    if (done)\n    {\n      progress_error(HD_ERROR_READ_ERROR, \"Not enough data left to read GIF compression code.\");\n      return (-1);\t/* Sorry, no more... */\n    }\n\n   /*\n    * Move last two bytes to front of buffer...\n    */\n\n    if (last_byte > 1)\n    {\n      buf[0]    = buf[last_byte - 2];\n      buf[1]    = buf[last_byte - 1];\n      last_byte = 2;\n    }\n    else if (last_byte == 1)\n    {\n      buf[0]    = buf[last_byte - 1];\n      last_byte = 1;\n    }\n\n   /*\n    * Read in another buffer...\n    */\n\n    if ((count = gif_get_block(fp, buf + last_byte)) <= 0)\n    {\n     /*\n      * Whoops, no more data!\n      */\n\n      done = 1;\n      return (-1);\n    }\n\n   /*\n    * Update buffer state...\n    */\n\n    curbit    = curbit + 8 * last_byte - lastbit;\n    last_byte += (unsigned)count;\n    lastbit   = last_byte * 8;\n  }\n\n  for (ret = 0, i = curbit + (unsigned)code_size - 1, j = (unsigned)code_size;\n       j > 0;\n       i --, j --)\n    ret = (ret << 1) | ((buf[i / 8] & bits[i & 7]) != 0);\n\n  curbit += (unsigned)code_size;\n\n  return (int)ret;\n}\n\n\n/*\n * 'gif_read_image()' - Read a GIF image stream...\n */\n\nstatic int\t\t\t\t/* I - 0 = success, -1 = failure */\ngif_read_image(FILE       *fp,\t\t/* I - Input file */\n\t       image_t    *img,\t\t/* I - Image pointer */\n\t       gif_cmap_t cmap,\t\t/* I - Colormap */\n\t       int        interlace,\t/* I - Non-zero = interlaced image */\n\t       int        transparent)\t/* I - Transparent color */\n{\n  uchar\t\tcode_size,\t\t/* Code size */\n\t\t*temp;\t\t\t/* Current pixel */\n  int\t\txpos,\t\t\t/* Current X position */\n\t\typos,\t\t\t/* Current Y position */\n\t\tpass;\t\t\t/* Current pass */\n  int\t\tpixel;\t\t\t/* Current pixel */\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n\n\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n\n  if (code_size > 12)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Bad GIF file \\\"%s\\\" - invalid code size %d.\", img->filename, code_size);\n    return (-1);\n  }\n\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n\n  temp = img->pixels;\n\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n\n    if (ypos >= img->height)\n      break;\n  }\n\n  return (0);\n}\n\n\n/*\n * 'gif_read_lzw()' - Read a byte from the LZW stream...\n */\n\nstatic int\t\t\t\t/* I - Byte from stream */\ngif_read_lzw(FILE *fp,\t\t\t/* I - File to read from */\n\t     int  first_time,\t\t/* I - 1 = first time, 0 = not first time */\n \t     int  input_code_size)\t/* I - Code size in bits */\n{\n  int\t\ti,\t\t\t/* Looping var */\n\t\tcode,\t\t\t/* Current code */\n\t\tincode;\t\t\t/* Input code */\n  static short\tfresh = 0,\t\t/* 1 = empty buffers */\n\t\tcode_size = 0,\t\t/* Current code size */\n\t\tset_code_size = 0,\t/* Initial code size set */\n\t\tmax_code = 0,\t\t/* Maximum code used */\n\t\tmax_code_size = 0,\t/* Maximum code size */\n\t\tfirstcode = 0,\t\t/* First code read */\n\t\toldcode = 0,\t\t/* Last code read */\n\t\tclear_code = 0,\t\t/* Clear code for LZW input */\n\t\tend_code = 0,\t\t/* End code for LZW input */\n\t\ttable[2][4096],\t\t/* String table */\n\t\tstack[8192],\t\t/* Output stack */\n\t\t*sp = stack;\t\t/* Current stack pointer */\n\n\n  if (first_time)\n  {\n   /*\n    * Setup LZW state...\n    */\n\n    set_code_size = (short)input_code_size;\n    code_size     = set_code_size + 1;\n    clear_code    = (short)(1 << set_code_size);\n    end_code      = clear_code + 1;\n    max_code_size = 2 * clear_code;\n    max_code      = clear_code + 2;\n\n   /*\n    * Initialize input buffers...\n    */\n\n    gif_get_code(fp, 0, 1);\n\n   /*\n    * Wipe the decompressor table...\n    */\n\n    fresh = 1;\n\n    for (i = 0; i < clear_code; i ++)\n    {\n      table[0][i] = 0;\n      table[1][i] = (short)i;\n    }\n\n    for (; i < 4096; i ++)\n      table[0][i] = table[1][0] = 0;\n\n    sp = stack;\n\n    return (0);\n  }\n  else if (fresh)\n  {\n    fresh = 0;\n\n    do\n      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);\n    while (firstcode == clear_code);\n\n    return (firstcode);\n  }\n\n  if (sp > stack)\n    return (*--sp);\n\n  while ((code = gif_get_code(fp, code_size, 0)) >= 0)\n  {\n    if (code == clear_code)\n    {\n      for (i = 0; i < clear_code; i ++)\n      {\n\ttable[0][i] = 0;\n\ttable[1][i] = (short)i;\n      }\n\n      for (; i < 4096; i ++)\n\ttable[0][i] = table[1][i] = 0;\n\n      code_size     = set_code_size + 1;\n      max_code_size = 2 * clear_code;\n      max_code      = clear_code + 2;\n\n      sp = stack;\n\n      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);\n\n      return (firstcode);\n    }\n    else if (code == end_code)\n    {\n      uchar\tbuf[260];\n\n\n      if (!gif_eof)\n        while (gif_get_block(fp, buf) > 0);\n\n      return (-2);\n    }\n\n    incode = code;\n\n    if (code >= max_code)\n    {\n      *sp++ = firstcode;\n      code  = oldcode;\n    }\n\n    while (code >= clear_code)\n    {\n      *sp++ = table[1][code];\n      if (code == table[0][code])\n\treturn (255);\n\n      code = table[0][code];\n    }\n\n    *sp++ = firstcode = table[1][code];\n    code  = max_code;\n\n    if (code < 4096)\n    {\n      table[0][code] = oldcode;\n      table[1][code] = firstcode;\n      max_code ++;\n\n      if (max_code >= max_code_size && max_code_size < 4096)\n      {\n\tmax_code_size *= 2;\n\tcode_size ++;\n      }\n    }\n\n    oldcode = (short)incode;\n\n    if (sp > stack)\n      return (*--sp);\n  }\n\n  return (code);\n}\n\n\n/*\n * 'image_compare()' - Compare two image filenames...\n */\n\nstatic int\t\t\t/* O - Result of comparison */\nimage_compare(image_t **img1,\t/* I - First image */\n              image_t **img2)\t/* I - Second image */\n{\n#ifdef WIN32\n  return (strcasecmp((*img1)->filename, (*img2)->filename));\n#else\n  return (strcmp((*img1)->filename, (*img2)->filename));\n#endif /* WIN32 */\n}\n\n\n/*\n * 'image_copy()' - Copy image files to the destination directory...\n */\n\nvoid\nimage_copy(const char *src,\t\t/* I - Source file */\n           const char *realsrc,\t\t/* I - Real source file */\n           const char *destpath)\t/* I - Destination path */\n{\n  char\t\tdest[255];\t\t/* Destination file */\n  FILE\t\t*in, *out;\t\t/* Input/output files */\n  uchar\t\tbuffer[8192];\t\t/* Data buffer */\n  int\t\tnbytes;\t\t\t/* Number of bytes in buffer */\n\n\n  if (!src || !realsrc || !destpath)\n    return;\n\n /*\n  * Figure out the destination filename...\n  */\n\n  if (!strcmp(destpath, \".\"))\n    strlcpy(dest, file_basename(src), sizeof(dest));\n  else\n    snprintf(dest, sizeof(dest), \"%s/%s\", destpath, file_basename(src));\n\n  if (!strcmp(dest, realsrc))\n    return;\n\n /*\n  * Open files and copy...\n  */\n\n  if ((in = fopen(realsrc, \"rb\")) == NULL)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Unable to open \\\"%s\\\" - %s\",\n                   realsrc, strerror(errno));\n    return;\n  }\n\n  if ((out = fopen(dest, \"wb\")) == NULL)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Unable to create \\\"%s\\\" - %s\",\n                   dest, strerror(errno));\n    fclose(in);\n    return;\n  }\n\n  while ((nbytes = fread(buffer, 1, sizeof(buffer), in)) > 0)\n    fwrite(buffer, 1, (size_t)nbytes, out);\n\n  progress_error(HD_ERROR_NONE, \"BYTES: %ld\", ftell(out));\n\n  fclose(in);\n  fclose(out);\n}\n\n\n/*\n * 'image_find()' - Find an image file in memory...\n */\n\nimage_t *\t\t\t/* O - Pointer to image */\nimage_find(const char *filename,/* I - Name of image file */\n           int        load_data)/* I - 1 = load image data */\n{\n  image_t\tkey,\t\t/* Search key... */\n\t\t*keyptr,\t/* Pointer to search key... */\n\t\t**match;\t/* Matching image */\n\n\n /*\n  * Range check...\n  */\n\n  if (filename == NULL)\n    return (NULL);\n\n  if (filename[0] == '\\0')\t/* Microsoft VC++ runtime bug workaround... */\n    return (NULL);\n\n /*\n  * See if we've already loaded it...\n  */\n\n  if (num_images > 0)\n  {\n    strlcpy(key.filename, filename, sizeof(key.filename));\n    keyptr = &key;\n\n    match = (image_t **)bsearch(&keyptr, images, (size_t)num_images, sizeof(image_t *),\n                                (int (*)(const void *, const void *))image_compare);\n    if (match != NULL)\n    {\n      if (load_data && !(*match)->pixels)\n        return (image_load((*match)->filename, (*match)->depth == 1, 1));\n      else\n        return (*match);\n    }\n  }\n\n  return (NULL);\n}\n\n\n/*\n * 'image_flush_cache()' - Flush the image cache...\n */\n\nvoid\nimage_flush_cache(void)\n{\n  size_t\ti;\t\t\t/* Looping var */\n\n\n /*\n  * Free the memory used by each image...\n  */\n\n  for (i = 0; i < num_images; i ++)\n  {\n    if (images[i]->mask)\n      free(images[i]->mask);\n\n    if (images[i]->pixels)\n      free(images[i]->pixels);\n\n    free(images[i]);\n  }\n\n  if (alloc_images)\n  {\n    free(images);\n\n    alloc_images = 0;\n  }\n\n  num_images = 0;\n}\n\n\n/*\n * 'image_getlist()' - Get the list of images that are loaded.\n */\n\nint\t\t\t\t/* O - Number of images in array */\nimage_getlist(image_t ***ptrs)\t/* O - Pointer to images array */\n{\n  *ptrs = images;\n  return (num_images);\n}\n\n\n/*\n * 'image_load()' - Load an image file from disk...\n */\n\nimage_t *\t\t\t/* O - Pointer to image */\nimage_load(const char *filename,/* I - Name of image file */\n           int        gray,\t/* I - 0 = color, 1 = grayscale */\n           int        load_data)/* I - 1 = load image data, 0 = just info */\n{\n#ifdef DEBUG\n  int\t\ti;\t\t/* Looping var */\n#endif // DEBUG\n  FILE\t\t*fp;\t\t/* File pointer */\n  uchar\t\theader[16];\t/* First 16 bytes of file */\n  image_t\t*img,\t\t/* New image buffer */\n\t\tkey,\t\t/* Search key... */\n\t\t*keyptr,\t/* Pointer to search key... */\n\t\t**match,\t/* Matching image */\n\t\t**temp;\t\t/* Temporary array pointer */\n  int\t\tstatus;\t\t/* Status of load... */\n  const char\t*realname;\t/* Real filename */\n\n\n /*\n  * Range check...\n  */\n\n  if (filename == NULL)\n    return (NULL);\n\n  if (filename[0] == '\\0')\t/* Microsoft VC++ runtime bug workaround... */\n    return (NULL);\n\n  DEBUG_printf((\"image_load(filename=\\\"%s\\\", gray=%d, load_data=%d)\\n\",\n                filename, gray, load_data));\n  DEBUG_printf((\"Path = \\\"%s\\\"\\n\", Path));\n\n /*\n  * See if we've already loaded it...\n  */\n\n  if (num_images > 0)\n  {\n    strlcpy(key.filename, filename, sizeof(key.filename));\n    keyptr = &key;\n\n    match = (image_t **)bsearch(&keyptr, images, (size_t)num_images, sizeof(image_t *),\n                                (int (*)(const void *, const void *))image_compare);\n    if (match != NULL && (!load_data || (*match)->pixels))\n    {\n      (*match)->use ++;\n      return (*match);\n    }\n  }\n  else\n    match = NULL;\n\n /*\n  * Figure out the file type...\n  */\n\n  if ((realname = file_find(Path, filename)) == NULL)\n  {\n    progress_error(HD_ERROR_FILE_NOT_FOUND,\n                   \"Unable to find image file \\\"%s\\\"!\", filename);\n    return (NULL);\n  }\n\n  if ((fp = fopen(realname, \"rb\")) == NULL)\n  {\n    progress_error(HD_ERROR_FILE_NOT_FOUND,\n                   \"Unable to open image file \\\"%s\\\" (%s) for reading!\",\n\t\t   filename, realname);\n    return (NULL);\n  }\n\n  if (fread(header, 1, sizeof(header), fp) == 0)\n  {\n    progress_error(HD_ERROR_READ_ERROR,\n                   \"Unable to read image file \\\"%s\\\"!\", filename);\n    fclose(fp);\n    return (NULL);\n  }\n\n#ifdef DEBUG\n  printf(\"Header for \\\"%s\\\" (%s): \\\"\", filename, realname);\n\n  for (i = 0; i < (int)sizeof(header); i ++)\n    if (header[i] < ' ' || header[i] >= 127)\n      printf(\"\\\\x%02X\", header[i]);\n    else\n      putchar(header[i]);\n\n  puts(\"\\\"\\n\");\n\n  printf(\"match = %p\\n\", (void *)match);\n#endif // DEBUG\n\n  rewind(fp);\n\n  // See if the images array needs to be resized...\n  if (!match)\n  {\n    if (num_images >= alloc_images)\n    {\n      // Yes...\n      alloc_images += ALLOC_FILES;\n\n      if (num_images == 0)\n\ttemp = (image_t **)malloc(sizeof(image_t *) * alloc_images);\n      else\n\ttemp = (image_t **)realloc(images, sizeof(image_t *) * alloc_images);\n\n      if (temp == NULL)\n      {\n\tprogress_error(HD_ERROR_OUT_OF_MEMORY,\n\t               \"Unable to allocate memory for %d images - %s\",\n                       (int)alloc_images, strerror(errno));\n\tfclose(fp);\n\treturn (NULL);\n      }\n\n      images = temp;\n    }\n\n    // Allocate memory...\n    img = (image_t *)calloc(sizeof(image_t), 1);\n\n    if (img == NULL)\n    {\n      progress_error(HD_ERROR_READ_ERROR, \"Unable to allocate memory for \\\"%s\\\"\",\n                     filename);\n      fclose(fp);\n      return (NULL);\n    }\n\n    images[num_images] = img;\n\n    strlcpy(img->filename, filename, sizeof(img->filename));\n    img->use = 1;\n  }\n  else\n    img = *match;\n\n  // Load the image as appropriate...\n  if (memcmp(header, \"GIF87a\", 6) == 0 ||\n      memcmp(header, \"GIF89a\", 6) == 0)\n    status = image_load_gif(img,  fp, gray, load_data);\n  else if (memcmp(header, \"BM\", 2) == 0)\n    status = image_load_bmp(img, fp, gray, load_data);\n#ifdef HAVE_LIBPNG\n  else if (memcmp(header, \"\\211PNG\", 4) == 0)\n    status = image_load_png(img, fp, gray, load_data);\n#endif // HAVE_LIBPNG\n#ifdef HAVE_LIBJPEG\n  else if (memcmp(header, \"\\377\\330\\377\", 3) == 0)\n    status = image_load_jpeg(img, fp, gray, load_data);\n#endif // HAVE_LIBJPEG\n  else\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"Unknown image file format for \\\"%s\\\".\",\n                   file_rlookup(filename));\n    fclose(fp);\n    free(img);\n    return (NULL);\n  }\n\n  fclose(fp);\n\n  if (status)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Unable to load image file \\\"%s\\\"!\",\n                   file_rlookup(filename));\n    if (!match)\n      free(img);\n    return (NULL);\n  }\n\n  if (!match)\n  {\n    num_images ++;\n    if (num_images > 1)\n      qsort(images, num_images, sizeof(image_t *),\n            (int (*)(const void *, const void *))image_compare);\n  }\n\n  return (img);\n}\n\n\n/*\n * 'image_load_bmp()' - Read a BMP image file.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_bmp(image_t *img,\t/* I - Image to load into */\n               FILE    *fp,\t/* I - File to read from */\n\t       int     gray,\t/* I - Grayscale image? */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  int\t\tinfo_size,\t/* Size of info header */\n\t\tdepth,\t\t/* Depth of image (bits) */\n\t\tcompression,\t/* Type of compression */\n\t\tcolors_used,\t/* Number of colors used */\n\t\tx, y,\t\t/* Looping vars */\n\t\tcolor,\t\t/* Color of RLE pixel */\n\t\tcount,\t\t/* Number of times to repeat */\n\t\ttemp,\t\t/* Temporary color */\n\t\talign;\t\t/* Alignment bytes */\n  uchar\t\tbit,\t\t/* Bit in image */\n\t\tbyte;\t\t/* Byte in image */\n  uchar\t\t*ptr;\t\t/* Pointer into pixels */\n  uchar\t\tcolormap[256][4];/* Colormap */\n\n\n  // Get the header...\n  getc(fp);\t\t\t/* Skip \"BM\" sync chars */\n  getc(fp);\n  read_dword(fp);\t\t/* Skip size */\n  read_word(fp);\t\t/* Skip reserved stuff */\n  read_word(fp);\n  read_dword(fp);\n\n  // Then the bitmap information...\n  info_size        = (int)read_dword(fp);\n  img->width       = read_long(fp);\n  img->height      = read_long(fp);\n  read_word(fp);\n  depth            = read_word(fp);\n  compression      = (int)read_dword(fp);\n  read_dword(fp);\n  read_long(fp);\n  read_long(fp);\n  colors_used      = (int)read_dword(fp);\n  read_dword(fp);\n\n  if (img->width <= 0 || img->width > 8192 || img->height <= 0 || img->height > 8192 || info_size < 0)\n    return (-1);\n\n  if (info_size > 40)\n  {\n    for (info_size -= 40; info_size > 0; info_size --)\n      getc(fp);\n  }\n\n  // Get colormap...\n  if (colors_used == 0 && depth <= 8)\n    colors_used = 1 << depth;\n  else if (colors_used < 0 || colors_used > 256)\n    return (-1);\n\n  fread(colormap, (size_t)colors_used, 4, fp);\n\n  // Setup image and buffers...\n  img->depth = gray ? 1 : 3;\n\n  // If this image is indexed and we are writing an encrypted PDF file, bump the use count so\n  // we create an image object (Acrobat 6 bug workaround)\n  if (depth <= 8 && Encryption)\n    img->use ++;\n\n  // Return now if we only need the dimensions...\n  if (!load_data)\n    return (0);\n\n  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n  if (img->pixels == NULL)\n    return (-1);\n\n  if (gray && depth <= 8)\n  {\n    // Convert colormap to grayscale...\n    for (color = colors_used - 1; color >= 0; color --)\n      colormap[color][0] = (colormap[color][2] * 31 +\n                            colormap[color][1] * 61 +\n                            colormap[color][0] * 8) / 100;\n  }\n\n  // Read the image data...\n  color = 0;\n  count = 0;\n  align = 0;\n  byte  = 0;\n  temp  = 0;\n\n  for (y = img->height - 1; y >= 0; y --)\n  {\n    ptr = img->pixels + y * img->width * img->depth;\n\n    switch (depth)\n    {\n      case 1 : /* Bitmap */\n          for (x = img->width, bit = 128; x > 0; x --)\n\t  {\n\t    if (bit == 128)\n\t      byte = (uchar)getc(fp);\n\n\t    if (byte & bit)\n\t    {\n\t      if (!gray)\n\t      {\n\t\t*ptr++ = colormap[1][2];\n\t\t*ptr++ = colormap[1][1];\n              }\n\n\t      *ptr++ = colormap[1][0];\n\t    }\n\t    else\n\t    {\n\t      if (!gray)\n\t      {\n\t\t*ptr++ = colormap[0][2];\n\t\t*ptr++ = colormap[0][1];\n\t      }\n\n\t      *ptr++ = colormap[0][0];\n\t    }\n\n\t    if (bit > 1)\n\t      bit >>= 1;\n\t    else\n\t      bit = 128;\n\t  }\n\n         /*\n\t  * Read remaining bytes to align to 32 bits...\n\t  */\n\n\t  for (temp = (img->width + 7) / 8; temp & 3; temp ++)\n\t    getc(fp);\n          break;\n\n      case 4 : /* 16-color */\n          for (x = img->width, bit = 0xf0; x > 0; x --)\n\t  {\n\t   /*\n\t    * Get a new count as needed...\n\t    */\n\n            if (compression != BI_RLE4 && count == 0)\n\t    {\n\t      count = 2;\n\t      color = -1;\n            }\n\n\t    if (count == 0)\n\t    {\n\t      while (align > 0)\n\t      {\n\t        align --;\n\t\tgetc(fp);\n              }\n\n\t      if ((count = getc(fp)) == 0)\n\t      {\n\t\tif ((count = getc(fp)) == 0)\n\t\t{\n\t\t /*\n\t\t  * End of line...\n\t\t  */\n\n                  x ++;\n\t\t  continue;\n\t\t}\n\t\telse if (count == 1)\n\t\t{\n\t\t /*\n\t\t  * End of image...\n\t\t  */\n\n\t\t  break;\n\t\t}\n\t\telse if (count == 2)\n\t\t{\n\t\t /*\n\t\t  * Delta...\n\t\t  */\n\n\t\t  count = getc(fp) * getc(fp) * img->width;\n\t\t  color = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t /*\n\t\t  * Absolute...\n\t\t  */\n\n\t\t  color = -1;\n\t\t  align = ((4 - (count & 3)) / 2) & 1;\n\t\t}\n\t      }\n\t      else\n\t        color = getc(fp);\n            }\n\n           /*\n\t    * Get a new color as needed...\n\t    */\n\n\t    count --;\n\n            if (bit == 0xf0)\n\t    {\n              if (color < 0)\n\t\ttemp = getc(fp) & 255;\n\t      else\n\t\ttemp = color;\n\n             /*\n\t      * Copy the color value...\n\t      */\n\n              if (!gray)\n\t      {\n\t\t*ptr++ = colormap[temp >> 4][2];\n\t\t*ptr++ = colormap[temp >> 4][1];\n              }\n\n\t      *ptr++ = colormap[temp >> 4][0];\n\t      bit    = 0x0f;\n            }\n\t    else\n\t    {\n             /*\n\t      * Copy the color value...\n\t      */\n\n\t      if (!gray)\n\t      {\n\t        *ptr++ = colormap[temp & 15][2];\n\t        *ptr++ = colormap[temp & 15][1];\n\t      }\n\n\t      *ptr++ = colormap[temp & 15][0];\n\t      bit    = 0xf0;\n\t    }\n\t  }\n          break;\n\n      case 8 : /* 256-color */\n          for (x = img->width; x > 0; x --)\n\t  {\n\t   /*\n\t    * Get a new count as needed...\n\t    */\n\n            if (compression != BI_RLE8)\n\t    {\n\t      count = 1;\n\t      color = -1;\n            }\n\n\t    if (count == 0)\n\t    {\n\t      while (align > 0)\n\t      {\n\t        align --;\n\t\tgetc(fp);\n              }\n\n\t      if ((count = getc(fp)) == 0)\n\t      {\n\t\tif ((count = getc(fp)) == 0)\n\t\t{\n\t\t /*\n\t\t  * End of line...\n\t\t  */\n\n                  x ++;\n\t\t  continue;\n\t\t}\n\t\telse if (count == 1)\n\t\t{\n\t\t /*\n\t\t  * End of image...\n\t\t  */\n\n\t\t  break;\n\t\t}\n\t\telse if (count == 2)\n\t\t{\n\t\t /*\n\t\t  * Delta...\n\t\t  */\n\n\t\t  count = getc(fp) * getc(fp) * img->width;\n\t\t  color = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t /*\n\t\t  * Absolute...\n\t\t  */\n\n\t\t  color = -1;\n\t\t  align = (2 - (count & 1)) & 1;\n\t\t}\n\t      }\n\t      else\n\t        color = getc(fp);\n            }\n\n           /*\n\t    * Get a new color as needed...\n\t    */\n\n            if (color < 0)\n\t      temp = getc(fp);\n\t    else\n\t      temp = color;\n\n            count --;\n\n           /*\n\t    * Copy the color value...\n\t    */\n\n            if (!gray)\n\t    {\n\t      *ptr++ = colormap[temp][2];\n\t      *ptr++ = colormap[temp][1];\n\t    }\n\n\t    *ptr++ = colormap[temp][0];\n\t  }\n          break;\n\n      case 24 : /* 24-bit RGB */\n          if (gray)\n\t  {\n            for (x = img->width; x > 0; x --)\n\t    {\n\t      temp = getc(fp) * 8;\n\t      temp += getc(fp) * 61;\n\t      temp += getc(fp) * 31;\n\t      *ptr++ = (uchar)(temp / 100);\n\t    }\n\t  }\n\t  else\n\t  {\n            for (x = img->width; x > 0; x --, ptr += 3)\n\t    {\n\t      ptr[2] = (uchar)getc(fp);\n\t      ptr[1] = (uchar)getc(fp);\n\t      ptr[0] = (uchar)getc(fp);\n\t    }\n          }\n\n         /*\n\t  * Read remaining bytes to align to 32 bits...\n\t  */\n\n\t  for (temp = img->width * 3; temp & 3; temp ++)\n\t    getc(fp);\n          break;\n    }\n  }\n\n  return (0);\n}\n\n\n/*\n * 'image_load_gif()' - Load a GIF image file...\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_gif(image_t *img,\t/* I - Image pointer */\n               FILE    *fp,\t/* I - File to load from */\n               int     gray,\t/* I - 0 = color, 1 = grayscale */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  uchar\t\tbuf[1024];\t/* Input buffer */\n  gif_cmap_t\tcmap;\t\t/* Colormap */\n  int\t\tncolors,\t/* Bits per pixel */\n\t\ttransparent;\t/* Transparent color index */\n\n\n /*\n  * Read the header; we already know it is a GIF file...\n  */\n\n  fread(buf, 13, 1, fp);\n\n  img->width  = (buf[7] << 8) | buf[6];\n  img->height = (buf[9] << 8) | buf[8];\n  ncolors     = 2 << (buf[10] & 0x07);\n\n  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)\n    return (-1);\n\n  // If we are writing an encrypted PDF file, bump the use count so we create\n  // an image object (Acrobat 6 bug workaround)\n  if (Encryption)\n    img->use ++;\n\n  if (buf[10] & GIF_COLORMAP)\n    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n      return (-1);\n\n  transparent = -1;\n\n  while (1)\n  {\n    switch (getc(fp))\n    {\n      case ';' :\t/* End of image */\n          return (-1);\t\t/* Early end of file */\n\n      case '!' :\t/* Extension record */\n          buf[0] = (uchar)getc(fp);\n          if (buf[0] == 0xf9)\t/* Graphic Control Extension */\n          {\n            gif_get_block(fp, buf);\n            if (buf[0] & 1)\t/* Get transparent color index */\n              transparent = buf[3];\n          }\n\n          while (gif_get_block(fp, buf) != 0);\n          break;\n\n      case ',' :\t/* Image data */\n          fread(buf, 9, 1, fp);\n\n          if (buf[8] & GIF_COLORMAP)\n          {\n            ncolors = 2 << (buf[8] & 0x07);\n\n\t    if (gif_read_cmap(fp, ncolors, cmap, &gray))\n\t      return (-1);\n\t  }\n\n          img->width  = (buf[5] << 8) | buf[4];\n          img->height = (buf[7] << 8) | buf[6];\n          img->depth  = gray ? 1 : 3;\n\n\t  if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)\n\t    return (-1);\n\n          if (transparent >= 0)\n          {\n           /*\n            * Map transparent color to background color...\n            */\n\n            if (BodyColor[0])\n\t    {\n\t      float rgb[3]; /* RGB color */\n\n\n\t      get_color((uchar *)BodyColor, rgb);\n\n\t      cmap[transparent][0] = (uchar)(rgb[0] * 255.0f + 0.5f);\n\t      cmap[transparent][1] = (uchar)(rgb[1] * 255.0f + 0.5f);\n\t      cmap[transparent][2] = (uchar)(rgb[2] * 255.0f + 0.5f);\n\t    }\n\t    else\n\t    {\n\t      cmap[transparent][0] = 255;\n              cmap[transparent][1] = 255;\n              cmap[transparent][2] = 255;\n\t    }\n\n           /*\n\t    * Allocate a mask image...\n\t    */\n\n            image_need_mask(img);\n\t  }\n\n\t  if (!load_data)\n\t    return (0);\n\n          img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n          if (img->pixels == NULL)\n            return (-1);\n\n\t  return (gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE, transparent));\n    }\n  }\n}\n\n\n#ifdef HAVE_LIBJPEG\ntypedef struct hd_jpeg_err_s\t// JPEG error manager extension\n{\n  struct jpeg_error_mgr\tjerr;\t// JPEG error manager information\n  jmp_buf\tretbuf;\t\t// setjmp() return buffer\n  char\t\tmessage[JMSG_LENGTH_MAX];\n\t\t\t\t// Last error message\n} hd_jpeg_err_t;\n\n\n/*\n * 'image_load_jpeg()' - Load a JPEG image file.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_jpeg(image_t *img,\t/* I - Image pointer */\n                FILE    *fp,\t/* I - File to load from */\n                int     gray,\t/* I - 0 = color, 1 = grayscale */\n                int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  struct jpeg_decompress_struct\tcinfo;\t\t/* Decompressor info */\n  hd_jpeg_err_t\t\t\tjerr;\t\t// JPEG error handler\nJSAMPROW\t\t\trow;\t\t/* Sample row pointer */\n\n\n  jpeg_std_error(&jerr.jerr);\n  jerr.jerr.error_exit = jpeg_error_handler;\n\n  if (setjmp(jerr.retbuf))\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"%s (%s)\", jerr.message,  file_rlookup(img->filename));\n    jpeg_destroy_decompress(&cinfo);\n    return (-1);\n  }\n\n  cinfo.err = (struct jpeg_error_mgr *)&jerr;\n  jpeg_create_decompress(&cinfo);\n  jpeg_stdio_src(&cinfo, fp);\n  jpeg_read_header(&cinfo, (boolean)1);\n\n  cinfo.quantize_colors = FALSE;\n\n  if (gray || cinfo.num_components == 1)\n  {\n    cinfo.out_color_space      = JCS_GRAYSCALE;\n    cinfo.out_color_components = 1;\n    cinfo.output_components    = 1;\n  }\n  else if (cinfo.num_components != 3)\n  {\n    jpeg_destroy_decompress(&cinfo);\n\n    progress_error(HD_ERROR_BAD_FORMAT,\n                   \"CMYK JPEG files are not supported! (%s)\",\n\t\t   file_rlookup(img->filename));\n    return (-1);\n  }\n  else\n  {\n    cinfo.out_color_space      = JCS_RGB;\n    cinfo.out_color_components = 3;\n    cinfo.output_components    = 3;\n  }\n\n  jpeg_calc_output_dimensions(&cinfo);\n\n  img->width  = (int)cinfo.output_width;\n  img->height = (int)cinfo.output_height;\n  img->depth  = (int)cinfo.output_components;\n\n  if (!load_data)\n  {\n    jpeg_destroy_decompress(&cinfo);\n    return (0);\n  }\n\n  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n\n  if (img->pixels == NULL)\n  {\n    jpeg_destroy_decompress(&cinfo);\n    return (-1);\n  }\n\n  jpeg_start_decompress(&cinfo);\n\n  while (cinfo.output_scanline < cinfo.output_height)\n  {\n    row = (JSAMPROW)(img->pixels + (size_t)cinfo.output_scanline * (size_t)cinfo.output_width * (size_t)cinfo.output_components);\n    jpeg_read_scanlines(&cinfo, &row, (JDIMENSION)1);\n  }\n\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n\n  return (0);\n}\n#endif // HAVE_LIBJPEG\n\n\n#ifdef HAVE_LIBPNG\n/*\n * 'image_load_png()' - Load a PNG image file.\n */\n\nstatic int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_png(image_t *img,\t/* I - Image pointer */\n               FILE    *fp,\t/* I - File to read from */\n               int     gray,\t/* I - 0 = color, 1 = grayscale */\n               int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  int\t\ti, j;\t\t/* Looping vars */\n  png_structp\tpp;\t\t/* PNG read pointer */\n  png_infop\tinfo;\t\t/* PNG info pointers */\n  int\t\tdepth;\t\t/* Input image depth */\n  png_bytep\t*rows = NULL;\t/* PNG row pointers */\n  uchar\t\t*inptr,\t\t/* Input pixels */\n\t\t*outptr;\t/* Output pixels */\n  int\t\tcolor_type,\t/* PNG color mode */\n\t\tbit_depth;\t/* PNG bit depth */\n\n\n /*\n  * Setup the PNG data structures...\n  */\n\n  pp = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n  if (!pp)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY, \"Unable to allocate memory for PNG file: %s\",\n                   strerror(errno));\n    return (-1);\n  }\n\n  info = png_create_info_struct(pp);\n  if (!info)\n  {\n    progress_error(HD_ERROR_OUT_OF_MEMORY, \"Unable to allocate memory for PNG info: %s\",\n                   strerror(errno));\n\n    png_destroy_read_struct(&pp, NULL, NULL);\n\n    return (-1);\n  }\n\n  if (setjmp(png_jmpbuf(pp)))\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"PNG file contains errors!\");\n\n    png_destroy_read_struct(&pp, &info, NULL);\n\n    if (img != NULL)\n    {\n      free(img->pixels);\n      img->pixels = NULL;\n    }\n\n    free(rows);\n    rows = NULL;\n\n    return (-1);\n  }\n\n /*\n  * Initialize the PNG read \"engine\"...\n  */\n\n  png_init_io(pp, fp);\n\n#  if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED)\n  // Don't throw errors with \"invalid\" sRGB profiles produced by Adobe apps.\n  png_set_option(pp, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON);\n#  endif // PNG_SKIP_sRGB_CHECK_PROFILE && PNG_SET_OPTION_SUPPORTED\n\n /*\n  * Get the image dimensions and convert to grayscale or RGB...\n  */\n\n  png_read_info(pp, info);\n\n  bit_depth  = png_get_bit_depth(pp, info);\n  color_type = png_get_color_type(pp, info);\n\n  if (png_get_valid(pp, info, PNG_INFO_tRNS))\n  {\n    png_set_tRNS_to_alpha(pp);\n    color_type |= PNG_COLOR_MASK_ALPHA;\n  }\n\n  if (color_type & PNG_COLOR_MASK_PALETTE)\n  {\n    png_set_palette_to_rgb(pp);\n\n    // If we are writing an encrypted PDF file, bump the use count so we create\n    // an image object (Acrobat 6 bug workaround)\n    if (Encryption)\n      img->use ++;\n  }\n  else if (!(color_type & PNG_COLOR_MASK_COLOR) && bit_depth < 8)\n  {\n    png_set_expand_gray_1_2_4_to_8(pp);\n  }\n  else if (bit_depth == 16)\n  {\n#  if PNG_LIBPNG_VER >= 10504\n    png_set_scale_16(pp);\n#  else\n    png_set_strip_16(pp);\n#  endif // PNG_LIBPNG_VER >= 10504\n  }\n\n  if (color_type & PNG_COLOR_MASK_COLOR)\n  {\n    depth      = 3;\n    img->depth = gray ? 1 : 3;\n  }\n  else\n  {\n    depth      = 1;\n    img->depth = 1;\n  }\n\n  img->width  = (int)png_get_image_width(pp, info);\n  img->height = (int)png_get_image_height(pp, info);\n\n  if (color_type & PNG_COLOR_MASK_ALPHA)\n  {\n    if ((PSLevel == 0 && PDFVersion >= 14) || PSLevel == 3)\n      image_need_mask(img, 8);\n    else if (PSLevel == 0 && PDFVersion == 13)\n      image_need_mask(img, 2);\n    else\n      image_need_mask(img);\n\n    depth ++;\n  }\n\n#  ifdef DEBUG\n  printf(\"bit_depth=%d, color_type=0x%04x, depth=%d, img->width=%d, img->height=%d, img->depth=%d\\n\", bit_depth, color_type, depth, img->width, img->height, img->depth);\n  if (color_type & PNG_COLOR_MASK_COLOR)\n    puts(\"    COLOR\");\n  else\n    puts(\"    GRAYSCALE\");\n  if (color_type & PNG_COLOR_MASK_ALPHA)\n    puts(\"    ALPHA\");\n  if (color_type & PNG_COLOR_MASK_PALETTE)\n    puts(\"    PALETTE\");\n#  endif // DEBUG\n\n  if (!load_data)\n  {\n    png_destroy_read_struct(&pp, &info, NULL);\n    return (0);\n  }\n\n  img->pixels = (uchar *)calloc(1, (size_t)(img->width * img->height * depth));\n\n /*\n  * Allocate pointers...\n  */\n\n  rows = (png_bytep *)calloc(png_get_image_height(pp, info), sizeof(png_bytep));\n\n  for (i = 0; i < (int)png_get_image_height(pp, info); i ++)\n    rows[i] = img->pixels + i * img->width * depth;\n\n /*\n  * Read the image, handling interlacing as needed...\n  */\n\n  for (i = png_set_interlace_handling(pp); i > 0; i --)\n    png_read_rows(pp, rows, NULL, (png_uint_32)img->height);\n\n /*\n  * Generate the alpha mask as necessary...\n  */\n\n  if (color_type & PNG_COLOR_MASK_ALPHA)\n  {\n#  ifdef DEBUG\n    for (inptr = img->pixels, i = 0; i < img->height; i ++)\n    {\n      for (j = 0; j < img->width; j ++, inptr += depth)\n        switch (depth)\n\t{\n\t  case 2 :\n\t      printf(\" %02X%02X\", inptr[0], inptr[1]);\n\t      break;\n\t  case 4 :\n\t      printf(\" %02X%02X%02X%02X\", inptr[0], inptr[1], inptr[2], inptr[3]);\n\t      break;\n\t}\n\n      putchar('\\n');\n    }\n#  endif // DEBUG\n\n    for (inptr = img->pixels + depth - 1, i = 0; i < img->height; i ++)\n      for (j = 0; j < img->width; j ++, inptr += depth)\n        image_set_mask(img, j, i, *inptr);\n  }\n\n /*\n  * Reformat the data as necessary for the reader...\n  */\n\n  if (gray && (color_type & PNG_COLOR_MASK_COLOR))\n  {\n   /*\n    * Grayscale output needed...\n    */\n\n    for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;\n         i > 0;\n         inptr += depth, outptr ++, i --)\n      *outptr = (31 * inptr[0] + 61 * inptr[1] + 8 * inptr[2]) / 100;\n  }\n  else if (img->depth != depth)\n  {\n   /*\n    * Remove alpha from final array...\n    */\n\n    if (depth == 4)\n    {\n      for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;\n           i > 0;\n           inptr ++, i --)\n      {\n        *outptr++ = *inptr++;\n        *outptr++ = *inptr++;\n        *outptr++ = *inptr++;\n      }\n    }\n    else\n    {\n      for (inptr = img->pixels, outptr = img->pixels, i = img->width * img->height;\n           i > 0;\n           inptr ++, i --)\n        *outptr++ = *inptr++;\n    }\n  }\n\n /*\n  * Free memory and return...\n  */\n\n  png_read_end(pp, info);\n  png_destroy_read_struct(&pp, &info, NULL);\n\n  free(rows);\n\n  return (0);\n}\n#endif // HAVE_LIBPNG\n\n\n/*\n * 'image_need_mask()' - Allocate memory for the image mask...\n */\n\nstatic void\nimage_need_mask(image_t *img,\t\t/* I - Image to add mask to */\n                int     scaling)\t/* I - Scaling for mask image */\n{\n  size_t\tsize;\t\t\t/* Byte size of mask image */\n\n\n  if (img == NULL || img->mask != NULL)\n    return;\n\n /*\n  * Figure out the size of the mask image, and then allocate and set all the\n  * bits needed...\n  */\n\n  img->maskscale = scaling;\n\n  if (scaling == 8)\n  {\n    // Alpha image\n    img->maskwidth = img->width;\n    size           = (size_t)(img->width * img->height);\n  }\n  else\n  {\n    // Alpha mask\n    img->maskwidth = (img->width * scaling + 7) / 8;\n    size           = (size_t)(img->maskwidth * img->height * scaling + 1);\n  }\n\n  img->mask = (uchar *)calloc(size, 1);\n}\n\n\n/*\n * 'image_set_mask()' - Set a bit in the image mask.\n */\n\nstatic void\nimage_set_mask(image_t *img,\t/* I - Image to operate on */\n               int     x,\t/* I - X coordinate */\n               int     y,\t/* I - Y coordinate */\n\t       uchar   alpha)\t/* I - Alpha value */\n{\n  int\t\ti, j;\t\t/* Looping vars */\n  uchar\t\t*maskptr;\t/* Pointer into mask image */\n  static uchar\tmasks[8] =\t/* Masks for each bit */\n\t\t{\n\t\t  0x80, 0x40, 0x20, 0x10,\n\t\t  0x08, 0x04, 0x02, 0x01\n\t\t};\n  static uchar\tdither[4][4] = // Simple 4x4 clustered-dot dither\n\t\t{\n\t\t  { 0,  2,  15, 6 },\n\t\t  { 4,  12, 9,  11 },\n\t\t  { 14, 7,  1,  3 },\n\t\t  { 8,  10, 5,  13 }\n\t        };\n\n\n  if (img == NULL || img->mask == NULL || x < 0 || x >= img->width ||\n      y < 0 || y >= img->height)\n    return;\n\n  if (img->maskscale == 8)\n  {\n    // Store the alpha value directly...\n    if (PSLevel)\n      img->mask[y * img->maskwidth + x] = 255 - alpha;\n    else\n      img->mask[y * img->maskwidth + x] = alpha;\n  }\n  else\n  {\n    // Store an alpha mask...\n    x *= img->maskscale;\n    y *= img->maskscale;\n    alpha >>= 4;\n\n    for (i = 0; i < img->maskscale; i ++, y ++, x -= img->maskscale)\n      for (j = 0; j < img->maskscale; j ++, x ++)\n      {\n\tmaskptr  = img->mask + y * img->maskwidth + x / 8;\n\tif (alpha <= dither[x & 3][y & 3])\n\t  *maskptr |= masks[x & 7];\n      }\n  }\n}\n\n\n/*\n * 'image_unload()' - Unload an image from memory.\n */\n\nvoid\nimage_unload(image_t *img)\t// I - Image\n{\n  if (!img)\n    return;\n\n  if (!img->use || !img->pixels)\n    return;\n\n  if (img->obj)\n    img->use = 0;\n  else\n    img->use --;\n\n  if (img->use)\n    return;\n\n  free(img->pixels);\n  img->pixels = NULL;\n}\n\n\n#ifdef HAVE_LIBJPEG\n/*\n * 'jpeg_error_handler()' - Handle JPEG errors by not exiting.\n */\n\nstatic void\njpeg_error_handler(j_common_ptr p)\t// Common JPEG data\n{\n  hd_jpeg_err_t\t*jerr = (hd_jpeg_err_t *)p->err;\n\t\t\t\t\t// JPEG error handler\n\n\n  // Save the error message in the string buffer...\n  (jerr->jerr.format_message)(p, jerr->message);\n\n  // Return to the point we called setjmp()...\n  longjmp(jerr->retbuf, 1);\n}\n#endif // HAVE_LIBJPEG\n\n\n/*\n * 'read_word()' - Read a 16-bit unsigned integer.\n */\n\nstatic unsigned short     /* O - 16-bit unsigned integer */\nread_word(FILE *fp)       /* I - File to read from */\n{\n  unsigned char b0, b1; /* Bytes from file */\n\n  b0 = (uchar)getc(fp);\n  b1 = (uchar)getc(fp);\n\n  return (unsigned short)((b1 << 8) | b0);\n}\n\n\n/*\n * 'read_dword()' - Read a 32-bit unsigned integer.\n */\n\nstatic unsigned int               /* O - 32-bit unsigned integer */\nread_dword(FILE *fp)              /* I - File to read from */\n{\n  unsigned char b0, b1, b2, b3; /* Bytes from file */\n\n  b0 = (uchar)getc(fp);\n  b1 = (uchar)getc(fp);\n  b2 = (uchar)getc(fp);\n  b3 = (uchar)getc(fp);\n\n  return (unsigned)((((((b3 << 8) | b2) << 8) | b1) << 8) | b0);\n}\n\n\n/*\n * 'read_long()' - Read a 32-bit signed integer.\n */\n\nstatic int                        /* O - 32-bit signed integer */\nread_long(FILE *fp)               /* I - File to read from */\n{\n  unsigned char b0, b1, b2, b3; /* Bytes from file */\n\n  b0 = (uchar)getc(fp);\n  b1 = (uchar)getc(fp);\n  b2 = (uchar)getc(fp);\n  b3 = (uchar)getc(fp);\n\n  return ((int)(((((b3 << 8) | b2) << 8) | b1) << 8) | b0);\n}\n"], "filenames": ["htmldoc/image.cxx"], "buggy_code_start_loc": [306], "buggy_code_end_loc": [436], "fixing_code_start_loc": [307], "fixing_code_end_loc": [442], "type": "CWE-125", "message": "A vulnerability was found in htmldoc version 1.9.15 where the stack out-of-bounds read takes place in gif_get_code() and occurs when opening a malicious GIF file, which can result in a crash (segmentation fault).", "other": {"cve": {"id": "CVE-2022-0534", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2022-02-09T23:15:16.767", "lastModified": "2022-12-21T15:01:19.963", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in htmldoc version 1.9.15 where the stack out-of-bounds read takes place in gif_get_code() and occurs when opening a malicious GIF file, which can result in a crash (segmentation fault)."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad en htmldoc versi\u00f3n 1.9.15, en la que una lectura fuera de l\u00edmites de la pila se presenta en la funci\u00f3n gif_get_code() y es producido cuando es abierto un archivo GIF malicioso, lo que puede resultar en un bloqueo (fallo de segmentaci\u00f3n)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:htmldoc_project:htmldoc:1.9.15:*:*:*:*:*:*:*", "matchCriteriaId": "7FA48CA3-3C4E-46CA-8B5E-FDBF99FDD55F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/michaelrsweet/htmldoc/commit/312f0f9c12f26fbe015cd0e6cefa40e4b99017d9", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/michaelrsweet/htmldoc/issues/463", "source": "patrick@puiterwijk.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/02/msg00022.html", "source": "patrick@puiterwijk.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/michaelrsweet/htmldoc/commit/312f0f9c12f26fbe015cd0e6cefa40e4b99017d9"}}