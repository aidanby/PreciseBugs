{"buggy_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi, David Calavera, Seiji Sogabe\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.security;\n\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport hudson.Extension;\nimport hudson.Util;\nimport hudson.diagnosis.OldDataMonitor;\nimport hudson.model.Descriptor;\nimport jenkins.model.Jenkins;\nimport hudson.model.ManagementLink;\nimport hudson.model.ModelObject;\nimport hudson.model.User;\nimport hudson.model.UserProperty;\nimport hudson.model.UserPropertyDescriptor;\nimport hudson.security.FederatedLoginService.FederatedIdentity;\nimport hudson.security.captcha.CaptchaSupport;\nimport hudson.util.PluginServletFilter;\nimport hudson.util.Protector;\nimport hudson.util.Scrambler;\nimport hudson.util.XStream2;\nimport net.sf.json.JSONObject;\nimport org.acegisecurity.Authentication;\nimport org.acegisecurity.AuthenticationException;\nimport org.acegisecurity.BadCredentialsException;\nimport org.acegisecurity.GrantedAuthority;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.acegisecurity.providers.UsernamePasswordAuthenticationToken;\nimport org.acegisecurity.providers.encoding.PasswordEncoder;\nimport org.acegisecurity.providers.encoding.ShaPasswordEncoder;\nimport org.acegisecurity.userdetails.UserDetails;\nimport org.acegisecurity.userdetails.UsernameNotFoundException;\nimport org.apache.tools.ant.taskdefs.email.Mailer;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.ForwardToView;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.mindrot.jbcrypt.BCrypt;\nimport org.springframework.dao.DataAccessException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport static javax.servlet.http.HttpServletResponse.SC_UNAUTHORIZED;\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.security.SecureRandom;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * {@link SecurityRealm} that performs authentication by looking up {@link User}.\n *\n * <p>\n * Implements {@link AccessControlled} to satisfy view rendering, but in reality the access control\n * is done against the {@link jenkins.model.Jenkins} object.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class HudsonPrivateSecurityRealm extends AbstractPasswordBasedSecurityRealm implements ModelObject, AccessControlled {\n    /**\n     * If true, sign up is not allowed.\n     * <p>\n     * This is a negative switch so that the default value 'false' remains compatible with older installations. \n     */\n    private final boolean disableSignup;\n\n    /**\n     * If true, captcha will be enabled.\n     */\n    private final boolean enableCaptcha;\n\n    @Deprecated\n    public HudsonPrivateSecurityRealm(boolean allowsSignup) {\n        this(allowsSignup, false, (CaptchaSupport) null);\n    }\n\n    @DataBoundConstructor\n    public HudsonPrivateSecurityRealm(boolean allowsSignup, boolean enableCaptcha, CaptchaSupport captchaSupport) {\n        this.disableSignup = !allowsSignup;\n        this.enableCaptcha = enableCaptcha;\n        setCaptchaSupport(captchaSupport);\n        if(!allowsSignup && !hasSomeUser()) {\n            // if Hudson is newly set up with the security realm and there's no user account created yet,\n            // insert a filter that asks the user to create one\n            try {\n                PluginServletFilter.addFilter(CREATE_FIRST_USER_FILTER);\n            } catch (ServletException e) {\n                throw new AssertionError(e); // never happen because our Filter.init is no-op\n            }\n        }\n    }\n\n    @Override\n    public boolean allowsSignup() {\n        return !disableSignup;\n    }\n\n    /**\n     * Checks if captcha is enabled on user signup.\n     *\n     * @return true if captcha is enabled on signup.\n     */\n    public boolean isEnableCaptcha() {\n        return enableCaptcha;\n    }\n\n    /**\n     * Computes if this Hudson has some user accounts configured.\n     *\n     * <p>\n     * This is used to check for the initial\n     */\n    private static boolean hasSomeUser() {\n        for (User u : User.getAll())\n            if(u.getProperty(Details.class)!=null)\n                return true;\n        return false;\n    }\n\n    /**\n     * This implementation doesn't support groups.\n     */\n    @Override\n    public GroupDetails loadGroupByGroupname(String groupname) throws UsernameNotFoundException, DataAccessException {\n        throw new UsernameNotFoundException(groupname);\n    }\n\n    @Override\n    public Details loadUserByUsername(String username) throws UsernameNotFoundException, DataAccessException {\n        User u = User.get(username,false);\n        Details p = u!=null ? u.getProperty(Details.class) : null;\n        if(p==null)\n            throw new UsernameNotFoundException(\"Password is not set: \"+username);\n        if(p.getUser()==null)\n            throw new AssertionError();\n        return p;\n    }\n\n    @Override\n    protected Details authenticate(String username, String password) throws AuthenticationException {\n        Details u = loadUserByUsername(username);\n        if (!u.isPasswordCorrect(password))\n            throw new BadCredentialsException(\"Failed to login as \"+username);\n        return u;\n    }\n\n    /**\n     * Show the sign up page with the data from the identity.\n     */\n    @Override\n    public HttpResponse commenceSignup(final FederatedIdentity identity) {\n        // store the identity in the session so that we can use this later\n        Stapler.getCurrentRequest().getSession().setAttribute(FEDERATED_IDENTITY_SESSION_KEY,identity);\n        return new ForwardToView(this,\"signupWithFederatedIdentity.jelly\") {\n            @Override\n            public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {\n                SignupInfo si = new SignupInfo(identity);\n                si.errorMessage = Messages.HudsonPrivateSecurityRealm_WouldYouLikeToSignUp(identity.getPronoun(),identity.getIdentifier());\n                req.setAttribute(\"data\", si);\n                super.generateResponse(req, rsp, node);\n            }\n        };\n    }\n\n    /**\n     * Creates an account and associates that with the given identity. Used in conjunction\n     * with {@link #commenceSignup(FederatedIdentity)}.\n     */\n    public User doCreateAccountWithFederatedIdentity(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        User u = _doCreateAccount(req,rsp,\"signupWithFederatedIdentity.jelly\");\n        if (u!=null)\n            ((FederatedIdentity)req.getSession().getAttribute(FEDERATED_IDENTITY_SESSION_KEY)).addTo(u);\n        return u;\n    }\n\n    private static final String FEDERATED_IDENTITY_SESSION_KEY = HudsonPrivateSecurityRealm.class.getName()+\".federatedIdentity\";\n\n    /**\n     * Creates an user account. Used for self-registration.\n     */\n    public User doCreateAccount(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        return _doCreateAccount(req, rsp, \"signup.jelly\");\n    }\n\n    private User _doCreateAccount(StaplerRequest req, StaplerResponse rsp, String formView) throws ServletException, IOException {\n        if(!allowsSignup())\n            throw HttpResponses.error(SC_UNAUTHORIZED,new Exception(\"User sign up is prohibited\"));\n\n        boolean firstUser = !hasSomeUser();\n        User u = createAccount(req, rsp, enableCaptcha, formView);\n        if(u!=null) {\n            if(firstUser)\n                tryToMakeAdmin(u);  // the first user should be admin, or else there's a risk of lock out\n            loginAndTakeBack(req, rsp, u);\n        }\n        return u;\n    }\n\n    /**\n     * Lets the current user silently login as the given user and report back accordingly.\n     */\n    private void loginAndTakeBack(StaplerRequest req, StaplerResponse rsp, User u) throws ServletException, IOException {\n        // ... and let him login\n        Authentication a = new UsernamePasswordAuthenticationToken(u.getId(),req.getParameter(\"password1\"));\n        a = this.getSecurityComponents().manager.authenticate(a);\n        SecurityContextHolder.getContext().setAuthentication(a);\n\n        // then back to top\n        req.getView(this,\"success.jelly\").forward(req,rsp);\n    }\n\n    /**\n     * Creates an user account. Used by admins.\n     *\n     * This version behaves differently from {@link #doCreateAccount(StaplerRequest, StaplerResponse)} in that\n     * this is someone creating another user.\n     */\n    public void doCreateAccountByAdmin(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(Jenkins.ADMINISTER);\n        if(createAccount(req, rsp, false, \"addUser.jelly\")!=null) {\n            rsp.sendRedirect(\".\");  // send the user back to the listing page\n        }\n    }\n\n    /**\n     * Creates a first admin user account.\n     *\n     * <p>\n     * This can be run by anyone, but only to create the very first user account.\n     */\n    public void doCreateFirstAccount(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        if(hasSomeUser()) {\n            rsp.sendError(SC_UNAUTHORIZED,\"First user was already created\");\n            return;\n        }\n        User u = createAccount(req, rsp, false, \"firstUser.jelly\");\n        if (u!=null) {\n            tryToMakeAdmin(u);\n            loginAndTakeBack(req, rsp, u);\n        }\n    }\n\n    /**\n     * Try to make this user a super-user\n     */\n    private void tryToMakeAdmin(User u) {\n        AuthorizationStrategy as = Jenkins.getInstance().getAuthorizationStrategy();\n        if (as instanceof GlobalMatrixAuthorizationStrategy) {\n            GlobalMatrixAuthorizationStrategy ma = (GlobalMatrixAuthorizationStrategy) as;\n            ma.add(Jenkins.ADMINISTER,u.getId());\n        }\n    }\n\n    /**\n     * @return\n     *      null if failed. The browser is already redirected to retry by the time this method returns.\n     *      a valid {@link User} object if the user creation was successful.\n     */\n    private User createAccount(StaplerRequest req, StaplerResponse rsp, boolean selfRegistration, String formView) throws ServletException, IOException {\n        // form field validation\n        // this pattern needs to be generalized and moved to stapler\n        SignupInfo si = new SignupInfo(req);\n\n        if(selfRegistration && !validateCaptcha(si.captcha))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage();\n\n        if(si.password1 != null && !si.password1.equals(si.password2))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch();\n\n        if(!(si.password1 != null && si.password1.length() != 0))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired();\n\n        if(si.username==null || si.username.length()==0)\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired();\n        else {\n            User user = User.get(si.username, false);\n            if (null != user)\n                si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken();\n        }\n\n        if(si.fullname==null || si.fullname.length()==0)\n            si.fullname = si.username;\n\n        if(si.email==null || !si.email.contains(\"@\"))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress();\n\n        if(si.errorMessage!=null) {\n            // failed. ask the user to try again.\n            req.setAttribute(\"data\",si);\n            req.getView(this, formView).forward(req,rsp);\n            return null;\n        }\n\n        // register the user\n        User user = createAccount(si.username,si.password1);\n        user.setFullName(si.fullname);\n        try {\n            // legacy hack. mail support has moved out to a separate plugin\n            Class<?> up = Jenkins.getInstance().pluginManager.uberClassLoader.loadClass(\"hudson.tasks.Mailer$UserProperty\");\n            Constructor<?> c = up.getDeclaredConstructor(String.class);\n            user.addProperty((UserProperty)c.newInstance(si.email));\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            LOGGER.log(Level.WARNING, \"Failed to set the e-mail address\",e);\n        }\n        user.save();\n        return user;\n    }\n\n    /**\n     * Creates a new user account by registering a password to the user.\n     */\n    public User createAccount(String userName, String password) throws IOException {\n        User user = User.get(userName);\n        user.addProperty(Details.fromPlainPassword(password));\n        return user;\n    }\n\n    /**\n     * This is used primarily when the object is listed in the breadcrumb, in the user management screen.\n     */\n    public String getDisplayName() {\n        return \"User Database\";\n    }\n\n    public ACL getACL() {\n        return Jenkins.getInstance().getACL();\n    }\n\n    public void checkPermission(Permission permission) {\n        Jenkins.getInstance().checkPermission(permission);\n    }\n\n    public boolean hasPermission(Permission permission) {\n        return Jenkins.getInstance().hasPermission(permission);\n    }\n\n\n    /**\n     * All users who can login to the system.\n     */\n    public List<User> getAllUsers() {\n        List<User> r = new ArrayList<User>();\n        for (User u : User.getAll()) {\n            if(u.getProperty(Details.class)!=null)\n                r.add(u);\n        }\n        Collections.sort(r);\n        return r;\n    }\n\n    /**\n     * This is to map users under the security realm URL.\n     * This in turn helps us set up the right navigation breadcrumb.\n     */\n    public User getUser(String id) {\n        return User.get(id);\n    }\n\n    // TODO\n    private static final GrantedAuthority[] TEST_AUTHORITY = {AUTHENTICATED_AUTHORITY};\n\n    public static final class SignupInfo {\n        public String username,password1,password2,fullname,email,captcha;\n\n        /**\n         * To display an error message, set it here.\n         */\n        public String errorMessage;\n\n        public SignupInfo() {\n        }\n\n        public SignupInfo(StaplerRequest req) {\n            req.bindParameters(this);\n        }\n\n        public SignupInfo(FederatedIdentity i) {\n            this.username = i.getNickname();\n            this.fullname = i.getFullName();\n            this.email = i.getEmailAddress();\n        }\n    }\n\n    /**\n     * {@link UserProperty} that provides the {@link UserDetails} view of the User object.\n     *\n     * <p>\n     * When a {@link User} object has this property on it, it means the user is configured\n     * for log-in.\n     *\n     * <p>\n     * When a {@link User} object is re-configured via the UI, the password\n     * is sent to the hidden input field by using {@link Protector}, so that\n     * the same password can be retained but without leaking information to the browser.\n     */\n    public static final class Details extends UserProperty implements InvalidatableUserDetails {\n        /**\n         * Hashed password.\n         */\n        private /*almost final*/ String passwordHash;\n\n        /**\n         * @deprecated Scrambled password.\n         * Field kept here to load old (pre 1.283) user records,\n         * but now marked transient so field is no longer saved.\n         */\n        private transient String password;\n\n        private Details(String passwordHash) {\n            this.passwordHash = passwordHash;\n        }\n\n        static Details fromHashedPassword(String hashed) {\n            return new Details(hashed);\n        }\n\n        static Details fromPlainPassword(String rawPassword) {\n            return new Details(PASSWORD_ENCODER.encodePassword(rawPassword,null));\n        }\n\n        public GrantedAuthority[] getAuthorities() {\n            // TODO\n            return TEST_AUTHORITY;\n        }\n\n        public String getPassword() {\n            return passwordHash;\n        }\n\n        public boolean isPasswordCorrect(String candidate) {\n            return PASSWORD_ENCODER.isPasswordValid(getPassword(),candidate,null);\n        }\n\n        public String getProtectedPassword() {\n            // put session Id in it to prevent a replay attack.\n            return Protector.protect(Stapler.getCurrentRequest().getSession().getId()+':'+getPassword());\n        }\n\n        public String getUsername() {\n            return user.getId();\n        }\n\n        /*package*/ User getUser() {\n            return user;\n        }\n\n        public boolean isAccountNonExpired() {\n            return true;\n        }\n\n        public boolean isAccountNonLocked() {\n            return true;\n        }\n\n        public boolean isCredentialsNonExpired() {\n            return true;\n        }\n\n        public boolean isEnabled() {\n            return true;\n        }\n\n        public boolean isInvalid() {\n            return user==null;\n        }\n\n        public static class ConverterImpl extends XStream2.PassthruConverter<Details> {\n            public ConverterImpl(XStream2 xstream) { super(xstream); }\n            @Override protected void callback(Details d, UnmarshallingContext context) {\n                // Convert to hashed password and report to monitor if we load old data\n                if (d.password!=null && d.passwordHash==null) {\n                    d.passwordHash = PASSWORD_ENCODER.encodePassword(Scrambler.descramble(d.password),null);\n                    OldDataMonitor.report(context, \"1.283\");\n                }\n            }\n        }\n\n        @Extension\n        public static final class DescriptorImpl extends UserPropertyDescriptor {\n            public String getDisplayName() {\n                // this feature is only when HudsonPrivateSecurityRealm is enabled\n                if(isEnabled())\n                    return Messages.HudsonPrivateSecurityRealm_Details_DisplayName();\n                else\n                    return null;\n            }\n\n            @Override\n            public Details newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n                String pwd = Util.fixEmpty(req.getParameter(\"user.password\"));\n                String pwd2= Util.fixEmpty(req.getParameter(\"user.password2\"));\n\n                if(!Util.fixNull(pwd).equals(Util.fixNull(pwd2)))\n                    throw new FormException(\"Please confirm the password by typing it twice\",\"user.password2\");\n\n                String data = Protector.unprotect(pwd);\n                if(data!=null) {\n                    String prefix = Stapler.getCurrentRequest().getSession().getId() + ':';\n                    if(data.startsWith(prefix))\n                        return Details.fromHashedPassword(data.substring(prefix.length()));\n                }\n                return Details.fromPlainPassword(Util.fixNull(pwd));\n            }\n\n            @Override\n            public boolean isEnabled() {\n                return Jenkins.getInstance().getSecurityRealm() instanceof HudsonPrivateSecurityRealm;\n            }\n\n            public UserProperty newInstance(User user) {\n                return null;\n            }\n        }\n    }\n\n    /**\n     * Displays \"manage users\" link in the system config if {@link HudsonPrivateSecurityRealm}\n     * is in effect.\n     */\n    @Extension\n    public static final class ManageUserLinks extends ManagementLink {\n        public String getIconFileName() {\n            if(Jenkins.getInstance().getSecurityRealm() instanceof HudsonPrivateSecurityRealm)\n                return \"user.png\";\n            else\n                return null;    // not applicable now\n        }\n\n        public String getUrlName() {\n            return \"securityRealm/\";\n        }\n\n        public String getDisplayName() {\n            return Messages.HudsonPrivateSecurityRealm_ManageUserLinks_DisplayName();\n        }\n\n        @Override\n        public String getDescription() {\n            return Messages.HudsonPrivateSecurityRealm_ManageUserLinks_Description();\n        }\n    }\n\n    /**\n     * {@link PasswordEncoder} based on SHA-256 and random salt generation.\n     *\n     * <p>\n     * The salt is prepended to the hashed password and returned. So the encoded password is of the form\n     * <tt>SALT ':' hash(PASSWORD,SALT)</tt>.\n     *\n     * <p>\n     * This abbreviates the need to store the salt separately, which in turn allows us to hide the salt handling\n     * in this little class. The rest of the Acegi thinks that we are not using salt.\n     */\n    /*package*/ static final PasswordEncoder CLASSIC = new PasswordEncoder() {\n        private final PasswordEncoder passwordEncoder = new ShaPasswordEncoder(256);\n\n        public String encodePassword(String rawPass, Object _) throws DataAccessException {\n            return hash(rawPass);\n        }\n\n        public boolean isPasswordValid(String encPass, String rawPass, Object _) throws DataAccessException {\n            // pull out the sale from the encoded password\n            int i = encPass.indexOf(':');\n            if(i<0) return false;\n            String salt = encPass.substring(0,i);\n            return encPass.substring(i+1).equals(passwordEncoder.encodePassword(rawPass,salt));\n        }\n\n        /**\n         * Creates a hashed password by generating a random salt.\n         */\n        private String hash(String password) {\n            String salt = generateSalt();\n            return salt+':'+passwordEncoder.encodePassword(password,salt);\n        }\n\n        /**\n         * Generates random salt.\n         */\n        private String generateSalt() {\n            StringBuilder buf = new StringBuilder();\n            SecureRandom sr = new SecureRandom();\n            for( int i=0; i<6; i++ ) {// log2(52^6)=34.20... so, this is about 32bit strong.\n                boolean upper = sr.nextBoolean();\n                char ch = (char)(sr.nextInt(26) + 'a');\n                if(upper)   ch=Character.toUpperCase(ch);\n                buf.append(ch);\n            }\n            return buf.toString();\n        }\n    };\n\n    /**\n     * {@link PasswordEncoder} that uses jBCrypt.\n     */\n    private static final PasswordEncoder JBCRYPT_ENCODER = new PasswordEncoder() {\n        public String encodePassword(String rawPass, Object _) throws DataAccessException {\n            return BCrypt.hashpw(rawPass,BCrypt.gensalt());\n        }\n\n        public boolean isPasswordValid(String encPass, String rawPass, Object _) throws DataAccessException {\n            return BCrypt.checkpw(rawPass,encPass);\n        }\n    };\n\n    /**\n     * Combines {@link #JBCRYPT_ENCODER} and {@link #CLASSIC} into one so that we can continue\n     * to accept {@link #CLASSIC} format but new encoding will always done via {@link #JBCRYPT_ENCODER}.\n     */\n    public static final PasswordEncoder PASSWORD_ENCODER = new PasswordEncoder() {\n        /*\n            CLASSIC encoder outputs \"salt:hash\" where salt is [a-z]+, so we use unique prefix '#jbcyrpt\"\n            to designate JBCRYPT-format hash.\n\n            '#' is neither in base64 nor hex, which makes it a good choice.\n         */\n        public String encodePassword(String rawPass, Object salt) throws DataAccessException {\n            return JBCRYPT_HEADER+JBCRYPT_ENCODER.encodePassword(rawPass,salt);\n        }\n\n        public boolean isPasswordValid(String encPass, String rawPass, Object salt) throws DataAccessException {\n            if (encPass.startsWith(JBCRYPT_HEADER))\n                return JBCRYPT_ENCODER.isPasswordValid(encPass.substring(JBCRYPT_HEADER.length()),rawPass,salt);\n            else\n                return CLASSIC.isPasswordValid(encPass,rawPass,salt);\n        }\n\n        private static final String JBCRYPT_HEADER = \"#jbcrypt:\";\n    };\n\n    @Extension\n    public static final class DescriptorImpl extends Descriptor<SecurityRealm> {\n        public String getDisplayName() {\n            return Messages.HudsonPrivateSecurityRealm_DisplayName();\n        }\n\n        @Override\n        public String getHelpFile() {\n            return \"/help/security/private-realm.html\"; \n        }\n    }\n\n    private static final Filter CREATE_FIRST_USER_FILTER = new Filter() {\n        public void init(FilterConfig config) throws ServletException {\n        }\n\n        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n            HttpServletRequest req = (HttpServletRequest) request;\n\n            if(req.getRequestURI().equals(req.getContextPath()+\"/\")) {\n                if (needsToCreateFirstUser()) {\n                    ((HttpServletResponse)response).sendRedirect(\"securityRealm/firstUser\");\n                } else {// the first user already created. the role of this filter is over.\n                    PluginServletFilter.removeFilter(this);\n                    chain.doFilter(request,response);\n                }\n            } else\n                chain.doFilter(request,response);\n        }\n\n        private boolean needsToCreateFirstUser() {\n            return !hasSomeUser()\n                && Jenkins.getInstance().getSecurityRealm() instanceof HudsonPrivateSecurityRealm;\n        }\n\n        public void destroy() {\n        }\n    };\n\n    private static final Logger LOGGER = Logger.getLogger(HudsonPrivateSecurityRealm.class.getName());\n}\n"], "fixing_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi, David Calavera, Seiji Sogabe\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.security;\n\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport hudson.Extension;\nimport hudson.Util;\nimport hudson.diagnosis.OldDataMonitor;\nimport hudson.model.Descriptor;\nimport jenkins.model.Jenkins;\nimport hudson.model.ManagementLink;\nimport hudson.model.ModelObject;\nimport hudson.model.User;\nimport hudson.model.UserProperty;\nimport hudson.model.UserPropertyDescriptor;\nimport hudson.security.FederatedLoginService.FederatedIdentity;\nimport hudson.security.captcha.CaptchaSupport;\nimport hudson.util.PluginServletFilter;\nimport hudson.util.Protector;\nimport hudson.util.Scrambler;\nimport hudson.util.XStream2;\nimport net.sf.json.JSONObject;\nimport org.acegisecurity.Authentication;\nimport org.acegisecurity.AuthenticationException;\nimport org.acegisecurity.BadCredentialsException;\nimport org.acegisecurity.GrantedAuthority;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.acegisecurity.providers.UsernamePasswordAuthenticationToken;\nimport org.acegisecurity.providers.encoding.PasswordEncoder;\nimport org.acegisecurity.providers.encoding.ShaPasswordEncoder;\nimport org.acegisecurity.userdetails.UserDetails;\nimport org.acegisecurity.userdetails.UsernameNotFoundException;\nimport org.apache.tools.ant.taskdefs.email.Mailer;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.ForwardToView;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.mindrot.jbcrypt.BCrypt;\nimport org.springframework.dao.DataAccessException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport static javax.servlet.http.HttpServletResponse.SC_UNAUTHORIZED;\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.security.SecureRandom;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * {@link SecurityRealm} that performs authentication by looking up {@link User}.\n *\n * <p>\n * Implements {@link AccessControlled} to satisfy view rendering, but in reality the access control\n * is done against the {@link jenkins.model.Jenkins} object.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class HudsonPrivateSecurityRealm extends AbstractPasswordBasedSecurityRealm implements ModelObject, AccessControlled {\n    /**\n     * If true, sign up is not allowed.\n     * <p>\n     * This is a negative switch so that the default value 'false' remains compatible with older installations. \n     */\n    private final boolean disableSignup;\n\n    /**\n     * If true, captcha will be enabled.\n     */\n    private final boolean enableCaptcha;\n\n    @Deprecated\n    public HudsonPrivateSecurityRealm(boolean allowsSignup) {\n        this(allowsSignup, false, (CaptchaSupport) null);\n    }\n\n    @DataBoundConstructor\n    public HudsonPrivateSecurityRealm(boolean allowsSignup, boolean enableCaptcha, CaptchaSupport captchaSupport) {\n        this.disableSignup = !allowsSignup;\n        this.enableCaptcha = enableCaptcha;\n        setCaptchaSupport(captchaSupport);\n        if(!allowsSignup && !hasSomeUser()) {\n            // if Hudson is newly set up with the security realm and there's no user account created yet,\n            // insert a filter that asks the user to create one\n            try {\n                PluginServletFilter.addFilter(CREATE_FIRST_USER_FILTER);\n            } catch (ServletException e) {\n                throw new AssertionError(e); // never happen because our Filter.init is no-op\n            }\n        }\n    }\n\n    @Override\n    public boolean allowsSignup() {\n        return !disableSignup;\n    }\n\n    /**\n     * Checks if captcha is enabled on user signup.\n     *\n     * @return true if captcha is enabled on signup.\n     */\n    public boolean isEnableCaptcha() {\n        return enableCaptcha;\n    }\n\n    /**\n     * Computes if this Hudson has some user accounts configured.\n     *\n     * <p>\n     * This is used to check for the initial\n     */\n    private static boolean hasSomeUser() {\n        for (User u : User.getAll())\n            if(u.getProperty(Details.class)!=null)\n                return true;\n        return false;\n    }\n\n    /**\n     * This implementation doesn't support groups.\n     */\n    @Override\n    public GroupDetails loadGroupByGroupname(String groupname) throws UsernameNotFoundException, DataAccessException {\n        throw new UsernameNotFoundException(groupname);\n    }\n\n    @Override\n    public Details loadUserByUsername(String username) throws UsernameNotFoundException, DataAccessException {\n        User u = User.get(username,false);\n        Details p = u!=null ? u.getProperty(Details.class) : null;\n        if(p==null)\n            throw new UsernameNotFoundException(\"Password is not set: \"+username);\n        if(p.getUser()==null)\n            throw new AssertionError();\n        return p;\n    }\n\n    @Override\n    protected Details authenticate(String username, String password) throws AuthenticationException {\n        Details u = loadUserByUsername(username);\n        if (!u.isPasswordCorrect(password)) {\n            String message;\n            try {\n                message = ResourceBundle.getBundle(\"org.acegisecurity.messages\").getString(\"AbstractUserDetailsAuthenticationProvider.badCredentials\");\n            } catch (MissingResourceException x) {\n                message = \"Bad credentials\";\n            }\n            throw new BadCredentialsException(message);\n        }\n        return u;\n    }\n\n    /**\n     * Show the sign up page with the data from the identity.\n     */\n    @Override\n    public HttpResponse commenceSignup(final FederatedIdentity identity) {\n        // store the identity in the session so that we can use this later\n        Stapler.getCurrentRequest().getSession().setAttribute(FEDERATED_IDENTITY_SESSION_KEY,identity);\n        return new ForwardToView(this,\"signupWithFederatedIdentity.jelly\") {\n            @Override\n            public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {\n                SignupInfo si = new SignupInfo(identity);\n                si.errorMessage = Messages.HudsonPrivateSecurityRealm_WouldYouLikeToSignUp(identity.getPronoun(),identity.getIdentifier());\n                req.setAttribute(\"data\", si);\n                super.generateResponse(req, rsp, node);\n            }\n        };\n    }\n\n    /**\n     * Creates an account and associates that with the given identity. Used in conjunction\n     * with {@link #commenceSignup(FederatedIdentity)}.\n     */\n    public User doCreateAccountWithFederatedIdentity(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        User u = _doCreateAccount(req,rsp,\"signupWithFederatedIdentity.jelly\");\n        if (u!=null)\n            ((FederatedIdentity)req.getSession().getAttribute(FEDERATED_IDENTITY_SESSION_KEY)).addTo(u);\n        return u;\n    }\n\n    private static final String FEDERATED_IDENTITY_SESSION_KEY = HudsonPrivateSecurityRealm.class.getName()+\".federatedIdentity\";\n\n    /**\n     * Creates an user account. Used for self-registration.\n     */\n    public User doCreateAccount(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        return _doCreateAccount(req, rsp, \"signup.jelly\");\n    }\n\n    private User _doCreateAccount(StaplerRequest req, StaplerResponse rsp, String formView) throws ServletException, IOException {\n        if(!allowsSignup())\n            throw HttpResponses.error(SC_UNAUTHORIZED,new Exception(\"User sign up is prohibited\"));\n\n        boolean firstUser = !hasSomeUser();\n        User u = createAccount(req, rsp, enableCaptcha, formView);\n        if(u!=null) {\n            if(firstUser)\n                tryToMakeAdmin(u);  // the first user should be admin, or else there's a risk of lock out\n            loginAndTakeBack(req, rsp, u);\n        }\n        return u;\n    }\n\n    /**\n     * Lets the current user silently login as the given user and report back accordingly.\n     */\n    private void loginAndTakeBack(StaplerRequest req, StaplerResponse rsp, User u) throws ServletException, IOException {\n        // ... and let him login\n        Authentication a = new UsernamePasswordAuthenticationToken(u.getId(),req.getParameter(\"password1\"));\n        a = this.getSecurityComponents().manager.authenticate(a);\n        SecurityContextHolder.getContext().setAuthentication(a);\n\n        // then back to top\n        req.getView(this,\"success.jelly\").forward(req,rsp);\n    }\n\n    /**\n     * Creates an user account. Used by admins.\n     *\n     * This version behaves differently from {@link #doCreateAccount(StaplerRequest, StaplerResponse)} in that\n     * this is someone creating another user.\n     */\n    public void doCreateAccountByAdmin(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(Jenkins.ADMINISTER);\n        if(createAccount(req, rsp, false, \"addUser.jelly\")!=null) {\n            rsp.sendRedirect(\".\");  // send the user back to the listing page\n        }\n    }\n\n    /**\n     * Creates a first admin user account.\n     *\n     * <p>\n     * This can be run by anyone, but only to create the very first user account.\n     */\n    public void doCreateFirstAccount(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        if(hasSomeUser()) {\n            rsp.sendError(SC_UNAUTHORIZED,\"First user was already created\");\n            return;\n        }\n        User u = createAccount(req, rsp, false, \"firstUser.jelly\");\n        if (u!=null) {\n            tryToMakeAdmin(u);\n            loginAndTakeBack(req, rsp, u);\n        }\n    }\n\n    /**\n     * Try to make this user a super-user\n     */\n    private void tryToMakeAdmin(User u) {\n        AuthorizationStrategy as = Jenkins.getInstance().getAuthorizationStrategy();\n        if (as instanceof GlobalMatrixAuthorizationStrategy) {\n            GlobalMatrixAuthorizationStrategy ma = (GlobalMatrixAuthorizationStrategy) as;\n            ma.add(Jenkins.ADMINISTER,u.getId());\n        }\n    }\n\n    /**\n     * @return\n     *      null if failed. The browser is already redirected to retry by the time this method returns.\n     *      a valid {@link User} object if the user creation was successful.\n     */\n    private User createAccount(StaplerRequest req, StaplerResponse rsp, boolean selfRegistration, String formView) throws ServletException, IOException {\n        // form field validation\n        // this pattern needs to be generalized and moved to stapler\n        SignupInfo si = new SignupInfo(req);\n\n        if(selfRegistration && !validateCaptcha(si.captcha))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_TextNotMatchWordInImage();\n\n        if(si.password1 != null && !si.password1.equals(si.password2))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordNotMatch();\n\n        if(!(si.password1 != null && si.password1.length() != 0))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_PasswordRequired();\n\n        if(si.username==null || si.username.length()==0)\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameRequired();\n        else {\n            User user = User.get(si.username, false);\n            if (null != user)\n                si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_UserNameAlreadyTaken();\n        }\n\n        if(si.fullname==null || si.fullname.length()==0)\n            si.fullname = si.username;\n\n        if(si.email==null || !si.email.contains(\"@\"))\n            si.errorMessage = Messages.HudsonPrivateSecurityRealm_CreateAccount_InvalidEmailAddress();\n\n        if(si.errorMessage!=null) {\n            // failed. ask the user to try again.\n            req.setAttribute(\"data\",si);\n            req.getView(this, formView).forward(req,rsp);\n            return null;\n        }\n\n        // register the user\n        User user = createAccount(si.username,si.password1);\n        user.setFullName(si.fullname);\n        try {\n            // legacy hack. mail support has moved out to a separate plugin\n            Class<?> up = Jenkins.getInstance().pluginManager.uberClassLoader.loadClass(\"hudson.tasks.Mailer$UserProperty\");\n            Constructor<?> c = up.getDeclaredConstructor(String.class);\n            user.addProperty((UserProperty)c.newInstance(si.email));\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            LOGGER.log(Level.WARNING, \"Failed to set the e-mail address\",e);\n        }\n        user.save();\n        return user;\n    }\n\n    /**\n     * Creates a new user account by registering a password to the user.\n     */\n    public User createAccount(String userName, String password) throws IOException {\n        User user = User.get(userName);\n        user.addProperty(Details.fromPlainPassword(password));\n        return user;\n    }\n\n    /**\n     * This is used primarily when the object is listed in the breadcrumb, in the user management screen.\n     */\n    public String getDisplayName() {\n        return \"User Database\";\n    }\n\n    public ACL getACL() {\n        return Jenkins.getInstance().getACL();\n    }\n\n    public void checkPermission(Permission permission) {\n        Jenkins.getInstance().checkPermission(permission);\n    }\n\n    public boolean hasPermission(Permission permission) {\n        return Jenkins.getInstance().hasPermission(permission);\n    }\n\n\n    /**\n     * All users who can login to the system.\n     */\n    public List<User> getAllUsers() {\n        List<User> r = new ArrayList<User>();\n        for (User u : User.getAll()) {\n            if(u.getProperty(Details.class)!=null)\n                r.add(u);\n        }\n        Collections.sort(r);\n        return r;\n    }\n\n    /**\n     * This is to map users under the security realm URL.\n     * This in turn helps us set up the right navigation breadcrumb.\n     */\n    public User getUser(String id) {\n        return User.get(id);\n    }\n\n    // TODO\n    private static final GrantedAuthority[] TEST_AUTHORITY = {AUTHENTICATED_AUTHORITY};\n\n    public static final class SignupInfo {\n        public String username,password1,password2,fullname,email,captcha;\n\n        /**\n         * To display an error message, set it here.\n         */\n        public String errorMessage;\n\n        public SignupInfo() {\n        }\n\n        public SignupInfo(StaplerRequest req) {\n            req.bindParameters(this);\n        }\n\n        public SignupInfo(FederatedIdentity i) {\n            this.username = i.getNickname();\n            this.fullname = i.getFullName();\n            this.email = i.getEmailAddress();\n        }\n    }\n\n    /**\n     * {@link UserProperty} that provides the {@link UserDetails} view of the User object.\n     *\n     * <p>\n     * When a {@link User} object has this property on it, it means the user is configured\n     * for log-in.\n     *\n     * <p>\n     * When a {@link User} object is re-configured via the UI, the password\n     * is sent to the hidden input field by using {@link Protector}, so that\n     * the same password can be retained but without leaking information to the browser.\n     */\n    public static final class Details extends UserProperty implements InvalidatableUserDetails {\n        /**\n         * Hashed password.\n         */\n        private /*almost final*/ String passwordHash;\n\n        /**\n         * @deprecated Scrambled password.\n         * Field kept here to load old (pre 1.283) user records,\n         * but now marked transient so field is no longer saved.\n         */\n        private transient String password;\n\n        private Details(String passwordHash) {\n            this.passwordHash = passwordHash;\n        }\n\n        static Details fromHashedPassword(String hashed) {\n            return new Details(hashed);\n        }\n\n        static Details fromPlainPassword(String rawPassword) {\n            return new Details(PASSWORD_ENCODER.encodePassword(rawPassword,null));\n        }\n\n        public GrantedAuthority[] getAuthorities() {\n            // TODO\n            return TEST_AUTHORITY;\n        }\n\n        public String getPassword() {\n            return passwordHash;\n        }\n\n        public boolean isPasswordCorrect(String candidate) {\n            return PASSWORD_ENCODER.isPasswordValid(getPassword(),candidate,null);\n        }\n\n        public String getProtectedPassword() {\n            // put session Id in it to prevent a replay attack.\n            return Protector.protect(Stapler.getCurrentRequest().getSession().getId()+':'+getPassword());\n        }\n\n        public String getUsername() {\n            return user.getId();\n        }\n\n        /*package*/ User getUser() {\n            return user;\n        }\n\n        public boolean isAccountNonExpired() {\n            return true;\n        }\n\n        public boolean isAccountNonLocked() {\n            return true;\n        }\n\n        public boolean isCredentialsNonExpired() {\n            return true;\n        }\n\n        public boolean isEnabled() {\n            return true;\n        }\n\n        public boolean isInvalid() {\n            return user==null;\n        }\n\n        public static class ConverterImpl extends XStream2.PassthruConverter<Details> {\n            public ConverterImpl(XStream2 xstream) { super(xstream); }\n            @Override protected void callback(Details d, UnmarshallingContext context) {\n                // Convert to hashed password and report to monitor if we load old data\n                if (d.password!=null && d.passwordHash==null) {\n                    d.passwordHash = PASSWORD_ENCODER.encodePassword(Scrambler.descramble(d.password),null);\n                    OldDataMonitor.report(context, \"1.283\");\n                }\n            }\n        }\n\n        @Extension\n        public static final class DescriptorImpl extends UserPropertyDescriptor {\n            public String getDisplayName() {\n                // this feature is only when HudsonPrivateSecurityRealm is enabled\n                if(isEnabled())\n                    return Messages.HudsonPrivateSecurityRealm_Details_DisplayName();\n                else\n                    return null;\n            }\n\n            @Override\n            public Details newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n                String pwd = Util.fixEmpty(req.getParameter(\"user.password\"));\n                String pwd2= Util.fixEmpty(req.getParameter(\"user.password2\"));\n\n                if(!Util.fixNull(pwd).equals(Util.fixNull(pwd2)))\n                    throw new FormException(\"Please confirm the password by typing it twice\",\"user.password2\");\n\n                String data = Protector.unprotect(pwd);\n                if(data!=null) {\n                    String prefix = Stapler.getCurrentRequest().getSession().getId() + ':';\n                    if(data.startsWith(prefix))\n                        return Details.fromHashedPassword(data.substring(prefix.length()));\n                }\n                return Details.fromPlainPassword(Util.fixNull(pwd));\n            }\n\n            @Override\n            public boolean isEnabled() {\n                return Jenkins.getInstance().getSecurityRealm() instanceof HudsonPrivateSecurityRealm;\n            }\n\n            public UserProperty newInstance(User user) {\n                return null;\n            }\n        }\n    }\n\n    /**\n     * Displays \"manage users\" link in the system config if {@link HudsonPrivateSecurityRealm}\n     * is in effect.\n     */\n    @Extension\n    public static final class ManageUserLinks extends ManagementLink {\n        public String getIconFileName() {\n            if(Jenkins.getInstance().getSecurityRealm() instanceof HudsonPrivateSecurityRealm)\n                return \"user.png\";\n            else\n                return null;    // not applicable now\n        }\n\n        public String getUrlName() {\n            return \"securityRealm/\";\n        }\n\n        public String getDisplayName() {\n            return Messages.HudsonPrivateSecurityRealm_ManageUserLinks_DisplayName();\n        }\n\n        @Override\n        public String getDescription() {\n            return Messages.HudsonPrivateSecurityRealm_ManageUserLinks_Description();\n        }\n    }\n\n    /**\n     * {@link PasswordEncoder} based on SHA-256 and random salt generation.\n     *\n     * <p>\n     * The salt is prepended to the hashed password and returned. So the encoded password is of the form\n     * <tt>SALT ':' hash(PASSWORD,SALT)</tt>.\n     *\n     * <p>\n     * This abbreviates the need to store the salt separately, which in turn allows us to hide the salt handling\n     * in this little class. The rest of the Acegi thinks that we are not using salt.\n     */\n    /*package*/ static final PasswordEncoder CLASSIC = new PasswordEncoder() {\n        private final PasswordEncoder passwordEncoder = new ShaPasswordEncoder(256);\n\n        public String encodePassword(String rawPass, Object _) throws DataAccessException {\n            return hash(rawPass);\n        }\n\n        public boolean isPasswordValid(String encPass, String rawPass, Object _) throws DataAccessException {\n            // pull out the sale from the encoded password\n            int i = encPass.indexOf(':');\n            if(i<0) return false;\n            String salt = encPass.substring(0,i);\n            return encPass.substring(i+1).equals(passwordEncoder.encodePassword(rawPass,salt));\n        }\n\n        /**\n         * Creates a hashed password by generating a random salt.\n         */\n        private String hash(String password) {\n            String salt = generateSalt();\n            return salt+':'+passwordEncoder.encodePassword(password,salt);\n        }\n\n        /**\n         * Generates random salt.\n         */\n        private String generateSalt() {\n            StringBuilder buf = new StringBuilder();\n            SecureRandom sr = new SecureRandom();\n            for( int i=0; i<6; i++ ) {// log2(52^6)=34.20... so, this is about 32bit strong.\n                boolean upper = sr.nextBoolean();\n                char ch = (char)(sr.nextInt(26) + 'a');\n                if(upper)   ch=Character.toUpperCase(ch);\n                buf.append(ch);\n            }\n            return buf.toString();\n        }\n    };\n\n    /**\n     * {@link PasswordEncoder} that uses jBCrypt.\n     */\n    private static final PasswordEncoder JBCRYPT_ENCODER = new PasswordEncoder() {\n        public String encodePassword(String rawPass, Object _) throws DataAccessException {\n            return BCrypt.hashpw(rawPass,BCrypt.gensalt());\n        }\n\n        public boolean isPasswordValid(String encPass, String rawPass, Object _) throws DataAccessException {\n            return BCrypt.checkpw(rawPass,encPass);\n        }\n    };\n\n    /**\n     * Combines {@link #JBCRYPT_ENCODER} and {@link #CLASSIC} into one so that we can continue\n     * to accept {@link #CLASSIC} format but new encoding will always done via {@link #JBCRYPT_ENCODER}.\n     */\n    public static final PasswordEncoder PASSWORD_ENCODER = new PasswordEncoder() {\n        /*\n            CLASSIC encoder outputs \"salt:hash\" where salt is [a-z]+, so we use unique prefix '#jbcyrpt\"\n            to designate JBCRYPT-format hash.\n\n            '#' is neither in base64 nor hex, which makes it a good choice.\n         */\n        public String encodePassword(String rawPass, Object salt) throws DataAccessException {\n            return JBCRYPT_HEADER+JBCRYPT_ENCODER.encodePassword(rawPass,salt);\n        }\n\n        public boolean isPasswordValid(String encPass, String rawPass, Object salt) throws DataAccessException {\n            if (encPass.startsWith(JBCRYPT_HEADER))\n                return JBCRYPT_ENCODER.isPasswordValid(encPass.substring(JBCRYPT_HEADER.length()),rawPass,salt);\n            else\n                return CLASSIC.isPasswordValid(encPass,rawPass,salt);\n        }\n\n        private static final String JBCRYPT_HEADER = \"#jbcrypt:\";\n    };\n\n    @Extension\n    public static final class DescriptorImpl extends Descriptor<SecurityRealm> {\n        public String getDisplayName() {\n            return Messages.HudsonPrivateSecurityRealm_DisplayName();\n        }\n\n        @Override\n        public String getHelpFile() {\n            return \"/help/security/private-realm.html\"; \n        }\n    }\n\n    private static final Filter CREATE_FIRST_USER_FILTER = new Filter() {\n        public void init(FilterConfig config) throws ServletException {\n        }\n\n        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n            HttpServletRequest req = (HttpServletRequest) request;\n\n            if(req.getRequestURI().equals(req.getContextPath()+\"/\")) {\n                if (needsToCreateFirstUser()) {\n                    ((HttpServletResponse)response).sendRedirect(\"securityRealm/firstUser\");\n                } else {// the first user already created. the role of this filter is over.\n                    PluginServletFilter.removeFilter(this);\n                    chain.doFilter(request,response);\n                }\n            } else\n                chain.doFilter(request,response);\n        }\n\n        private boolean needsToCreateFirstUser() {\n            return !hasSomeUser()\n                && Jenkins.getInstance().getSecurityRealm() instanceof HudsonPrivateSecurityRealm;\n        }\n\n        public void destroy() {\n        }\n    };\n\n    private static final Logger LOGGER = Logger.getLogger(HudsonPrivateSecurityRealm.class.getName());\n}\n"], "filenames": ["core/src/main/java/hudson/security/HudsonPrivateSecurityRealm.java"], "buggy_code_start_loc": [80], "buggy_code_end_loc": [178], "fixing_code_start_loc": [81], "fixing_code_end_loc": [187], "type": "CWE-200", "message": "The loadUserByUsername function in hudson/security/HudsonPrivateSecurityRealm.java in Jenkins before 1.551 and LTS before 1.532.2 allows remote attackers to determine whether a user exists via vectors related to failed login attempts.", "other": {"cve": {"id": "CVE-2014-2064", "sourceIdentifier": "security@debian.org", "published": "2014-10-17T15:55:05.727", "lastModified": "2016-06-13T23:38:15.677", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The loadUserByUsername function in hudson/security/HudsonPrivateSecurityRealm.java in Jenkins before 1.551 and LTS before 1.532.2 allows remote attackers to determine whether a user exists via vectors related to failed login attempts."}, {"lang": "es", "value": "La funci\u00f3n loadUserByUsername en hudson/security/HudsonPrivateSecurityRealm.java en Jenkins en versiones anteriores a 1.551 y LTS en versiones anteriores a 1.532.2 permite a atacantes remotos determinar si existe un usuario relacionado con los intentos de acceso fallidos."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:lts:*:*:*", "versionEndIncluding": "1.532.1", "matchCriteriaId": "F5EDE52E-F7BE-457D-8E56-F24800F02241"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.550", "matchCriteriaId": "07E4FEB5-A7D9-49FE-839A-0D650CC19C42"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2014/02/21/2", "source": "security@debian.org"}, {"url": "https://github.com/jenkinsci/jenkins/commit/fbf96734470caba9364f04e0b77b0bae7293a1ec", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2014-02-14", "source": "security@debian.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jenkinsci/jenkins/commit/fbf96734470caba9364f04e0b77b0bae7293a1ec"}}