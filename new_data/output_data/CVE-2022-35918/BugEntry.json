{"buggy_code": ["# Copyright 2018-2022 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport json\nimport mimetypes\nimport os\nimport threading\nfrom typing import Any, Dict, Optional, Type, Union\n\nimport tornado.web\nfrom streamlit.scriptrunner import get_script_run_ctx\n\nimport streamlit.server.routes\nfrom streamlit import type_util\nfrom streamlit.elements.form import current_form_id\nfrom streamlit import util\nfrom streamlit.errors import StreamlitAPIException\nfrom streamlit.logger import get_logger\nfrom streamlit.proto.Components_pb2 import SpecialArg, ArrowTable as ArrowTableProto\nfrom streamlit.proto.Element_pb2 import Element\nfrom streamlit.state import NoValue, register_widget\nfrom streamlit.type_util import to_bytes\n\nLOGGER = get_logger(__name__)\n\n\nclass MarshallComponentException(StreamlitAPIException):\n    \"\"\"Class for exceptions generated during custom component marshalling.\"\"\"\n\n    pass\n\n\nclass CustomComponent:\n    \"\"\"A Custom Component declaration.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        path: Optional[str] = None,\n        url: Optional[str] = None,\n    ):\n        if (path is None and url is None) or (path is not None and url is not None):\n            raise StreamlitAPIException(\n                \"Either 'path' or 'url' must be set, but not both.\"\n            )\n\n        self.name = name\n        self.path = path\n        self.url = url\n\n    def __repr__(self) -> str:\n        return util.repr_(self)\n\n    @property\n    def abspath(self) -> Optional[str]:\n        \"\"\"The absolute path that the component is served from.\"\"\"\n        if self.path is None:\n            return None\n        return os.path.abspath(self.path)\n\n    def __call__(\n        self,\n        *args,\n        default: Any = None,\n        key: Optional[str] = None,\n        **kwargs,\n    ) -> Any:\n        \"\"\"An alias for create_instance.\"\"\"\n        return self.create_instance(*args, default=default, key=key, **kwargs)\n\n    def create_instance(\n        self,\n        *args,\n        default: Any = None,\n        key: Optional[str] = None,\n        **kwargs,\n    ) -> Any:\n        \"\"\"Create a new instance of the component.\n\n        Parameters\n        ----------\n        *args\n            Must be empty; all args must be named. (This parameter exists to\n            enforce correct use of the function.)\n        default: any or None\n            The default return value for the component. This is returned when\n            the component's frontend hasn't yet specified a value with\n            `setComponentValue`.\n        key: str or None\n            If not None, this is the user key we use to generate the\n            component's \"widget ID\".\n        **kwargs\n            Keyword args to pass to the component.\n\n        Returns\n        -------\n        any or None\n            The component's widget value.\n\n        \"\"\"\n        if len(args) > 0:\n            raise MarshallComponentException(f\"Argument '{args[0]}' needs a label\")\n\n        try:\n            import pyarrow\n            from streamlit.components.v1 import component_arrow\n        except ImportError:\n            raise StreamlitAPIException(\n                \"\"\"To use Custom Components in Streamlit, you need to install\nPyArrow. To do so locally:\n\n`pip install pyarrow`\n\nAnd if you're using Streamlit Cloud, add \"pyarrow\" to your requirements.txt.\"\"\"\n            )\n\n        # In addition to the custom kwargs passed to the component, we also\n        # send the special 'default' and 'key' params to the component\n        # frontend.\n        all_args = dict(kwargs, **{\"default\": default, \"key\": key})\n\n        json_args = {}\n        special_args = []\n        for arg_name, arg_val in all_args.items():\n            if type_util.is_bytes_like(arg_val):\n                bytes_arg = SpecialArg()\n                bytes_arg.key = arg_name\n                bytes_arg.bytes = to_bytes(arg_val)\n                special_args.append(bytes_arg)\n            elif type_util.is_dataframe_like(arg_val):\n                dataframe_arg = SpecialArg()\n                dataframe_arg.key = arg_name\n                component_arrow.marshall(dataframe_arg.arrow_dataframe.data, arg_val)\n                special_args.append(dataframe_arg)\n            else:\n                json_args[arg_name] = arg_val\n\n        try:\n            serialized_json_args = json.dumps(json_args)\n        except BaseException as e:\n            raise MarshallComponentException(\n                \"Could not convert component args to JSON\", e\n            )\n\n        def marshall_component(dg, element: Element) -> Union[Any, Type[NoValue]]:\n            element.component_instance.component_name = self.name\n            element.component_instance.form_id = current_form_id(dg)\n            if self.url is not None:\n                element.component_instance.url = self.url\n\n            # Normally, a widget's element_hash (which determines\n            # its identity across multiple runs of an app) is computed\n            # by hashing the entirety of its protobuf. This means that,\n            # if any of the arguments to the widget are changed, Streamlit\n            # considers it a new widget instance and it loses its previous\n            # state.\n            #\n            # However! If a *component* has a `key` argument, then the\n            # component's hash identity is determined by entirely by\n            # `component_name + url + key`. This means that, when `key`\n            # exists, the component will maintain its identity even when its\n            # other arguments change, and the component's iframe won't be\n            # remounted on the frontend.\n            #\n            # So: if `key` is None, we marshall the element's arguments\n            # *before* computing its widget_ui_value (which creates its hash).\n            # If `key` is not None, we marshall the arguments *after*.\n\n            def marshall_element_args():\n                element.component_instance.json_args = serialized_json_args\n                element.component_instance.special_args.extend(special_args)\n\n            if key is None:\n                marshall_element_args()\n\n            def deserialize_component(ui_value, widget_id=\"\"):\n                # ui_value is an object from json, an ArrowTable proto, or a bytearray\n                return ui_value\n\n            ctx = get_script_run_ctx()\n            component_state = register_widget(\n                element_type=\"component_instance\",\n                element_proto=element.component_instance,\n                user_key=key,\n                widget_func_name=self.name,\n                deserializer=deserialize_component,\n                serializer=lambda x: x,\n                ctx=ctx,\n            )\n            widget_value = component_state.value\n\n            if key is not None:\n                marshall_element_args()\n\n            if widget_value is None:\n                widget_value = default\n            elif isinstance(widget_value, ArrowTableProto):\n                widget_value = component_arrow.arrow_proto_to_dataframe(widget_value)\n\n            # widget_value will be either None or whatever the component's most\n            # recent setWidgetValue value is. We coerce None -> NoValue,\n            # because that's what DeltaGenerator._enqueue expects.\n            return widget_value if widget_value is not None else NoValue\n\n        # We currently only support writing to st._main, but this will change\n        # when we settle on an improved API in a post-layout world.\n        dg = streamlit._main\n\n        element = Element()\n        return_value = marshall_component(dg, element)\n        result = dg._enqueue(\n            \"component_instance\", element.component_instance, return_value\n        )\n\n        return result\n\n    def __eq__(self, other) -> bool:\n        \"\"\"Equality operator.\"\"\"\n        return (\n            isinstance(other, CustomComponent)\n            and self.name == other.name\n            and self.path == other.path\n            and self.url == other.url\n        )\n\n    def __ne__(self, other) -> bool:\n        \"\"\"Inequality operator.\"\"\"\n        return not self == other\n\n    def __str__(self) -> str:\n        return f\"'{self.name}': {self.path if self.path is not None else self.url}\"\n\n\ndef declare_component(\n    name: str,\n    path: Optional[str] = None,\n    url: Optional[str] = None,\n) -> CustomComponent:\n    \"\"\"Create and register a custom component.\n\n    Parameters\n    ----------\n    name: str\n        A short, descriptive name for the component. Like, \"slider\".\n    path: str or None\n        The path to serve the component's frontend files from. Either\n        `path` or `url` must be specified, but not both.\n    url: str or None\n        The URL that the component is served from. Either `path` or `url`\n        must be specified, but not both.\n\n    Returns\n    -------\n    CustomComponent\n        A CustomComponent that can be called like a function.\n        Calling the component will create a new instance of the component\n        in the Streamlit app.\n\n    \"\"\"\n\n    # Get our stack frame.\n    current_frame = inspect.currentframe()\n    assert current_frame is not None\n\n    # Get the stack frame of our calling function.\n    caller_frame = current_frame.f_back\n    assert caller_frame is not None\n\n    # Get the caller's module name. `__name__` gives us the module's\n    # fully-qualified name, which includes its package.\n    module = inspect.getmodule(caller_frame)\n    assert module is not None\n    module_name = module.__name__\n\n    # If the caller was the main module that was executed (that is, if the\n    # user executed `python my_component.py`), then this name will be\n    # \"__main__\" instead of the actual package name. In this case, we use\n    # the main module's filename, sans `.py` extension, as the component name.\n    if module_name == \"__main__\":\n        file_path = inspect.getfile(caller_frame)\n        filename = os.path.basename(file_path)\n        module_name, _ = os.path.splitext(filename)\n\n    # Build the component name.\n    component_name = f\"{module_name}.{name}\"\n\n    # Create our component object, and register it.\n    component = CustomComponent(name=component_name, path=path, url=url)\n    ComponentRegistry.instance().register_component(component)\n\n    return component\n\n\nclass ComponentRequestHandler(tornado.web.RequestHandler):\n    def initialize(self, registry: \"ComponentRegistry\"):\n        self._registry = registry\n\n    def get(self, path: str) -> None:\n        parts = path.split(\"/\")\n        component_name = parts[0]\n        component_root = self._registry.get_component_path(component_name)\n        if component_root is None:\n            self.write(\"not found\")\n            self.set_status(404)\n            return\n\n        filename = \"/\".join(parts[1:])\n        abspath = os.path.join(component_root, filename)\n\n        LOGGER.debug(\"ComponentRequestHandler: GET: %s -> %s\", path, abspath)\n\n        try:\n            with open(abspath, \"rb\") as file:\n                contents = file.read()\n        except (OSError) as e:\n            LOGGER.error(f\"ComponentRequestHandler: GET {path} read error\", exc_info=e)\n            self.write(\"read error\")\n            self.set_status(404)\n            return\n\n        self.write(contents)\n        self.set_header(\"Content-Type\", self.get_content_type(abspath))\n\n        self.set_extra_headers(path)\n\n    def set_extra_headers(self, path) -> None:\n        \"\"\"Disable cache for HTML files.\n\n        Other assets like JS and CSS are suffixed with their hash, so they can\n        be cached indefinitely.\n        \"\"\"\n        is_index_url = len(path) == 0\n\n        if is_index_url or path.endswith(\".html\"):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n        else:\n            self.set_header(\"Cache-Control\", \"public\")\n\n    def set_default_headers(self) -> None:\n        if streamlit.server.routes.allow_cross_origin_requests():\n            self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n    def options(self) -> None:\n        \"\"\"/OPTIONS handler for preflight CORS checks.\"\"\"\n        self.set_status(204)\n        self.finish()\n\n    @staticmethod\n    def get_content_type(abspath) -> str:\n        \"\"\"Returns the ``Content-Type`` header to be used for this request.\n        From tornado.web.StaticFileHandler.\n        \"\"\"\n        mime_type, encoding = mimetypes.guess_type(abspath)\n        # per RFC 6713, use the appropriate type for a gzip compressed file\n        if encoding == \"gzip\":\n            return \"application/gzip\"\n        # As of 2015-07-21 there is no bzip2 encoding defined at\n        # http://www.iana.org/assignments/media-types/media-types.xhtml\n        # So for that (and any other encoding), use octet-stream.\n        elif encoding is not None:\n            return \"application/octet-stream\"\n        elif mime_type is not None:\n            return mime_type\n        # if mime_type not detected, use application/octet-stream\n        else:\n            return \"application/octet-stream\"\n\n    @staticmethod\n    def get_url(file_id: str) -> str:\n        \"\"\"Return the URL for a component file with the given ID.\"\"\"\n        return \"components/{}\".format(file_id)\n\n\nclass ComponentRegistry:\n    _instance_lock: threading.Lock = threading.Lock()\n    _instance: Optional[\"ComponentRegistry\"] = None\n\n    @classmethod\n    def instance(cls) -> \"ComponentRegistry\":\n        \"\"\"Returns the singleton ComponentRegistry\"\"\"\n        # We use a double-checked locking optimization to avoid the overhead\n        # of acquiring the lock in the common case:\n        # https://en.wikipedia.org/wiki/Double-checked_locking\n        if cls._instance is None:\n            with cls._instance_lock:\n                if cls._instance is None:\n                    cls._instance = ComponentRegistry()\n        return cls._instance\n\n    def __init__(self):\n        self._components = {}  # type: Dict[str, CustomComponent]\n        self._lock = threading.Lock()\n\n    def __repr__(self) -> str:\n        return util.repr_(self)\n\n    def register_component(self, component: CustomComponent) -> None:\n        \"\"\"Register a CustomComponent.\n\n        Parameters\n        ----------\n        component : CustomComponent\n            The component to register.\n        \"\"\"\n\n        # Validate the component's path\n        abspath = component.abspath\n        if abspath is not None and not os.path.isdir(abspath):\n            raise StreamlitAPIException(f\"No such component directory: '{abspath}'\")\n\n        with self._lock:\n            existing = self._components.get(component.name)\n            self._components[component.name] = component\n\n        if existing is not None and component != existing:\n            LOGGER.warning(\n                \"%s overriding previously-registered %s\",\n                component,\n                existing,\n            )\n\n        LOGGER.debug(\"Registered component %s\", component)\n\n    def get_component_path(self, name: str) -> Optional[str]:\n        \"\"\"Return the filesystem path for the component with the given name.\n\n        If no such component is registered, or if the component exists but is\n        being served from a URL, return None instead.\n        \"\"\"\n        component = self._components.get(name, None)\n        return component.abspath if component is not None else None\n", "# Copyright 2018-2022 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\nimport unittest\nfrom typing import Any\nfrom unittest import mock\nfrom unittest.mock import patch\n\nimport pandas as pd\nimport pytest\nimport tornado.testing\nimport tornado.web\n\nfrom streamlit import StreamlitAPIException\nfrom streamlit.components.v1 import component_arrow\nfrom streamlit.components.v1.components import (\n    ComponentRegistry,\n    ComponentRequestHandler,\n    CustomComponent,\n    declare_component,\n)\nimport streamlit.components.v1 as components\nfrom streamlit.errors import DuplicateWidgetID\nfrom streamlit.proto.Components_pb2 import SpecialArg\nfrom streamlit.type_util import to_bytes\nfrom tests import testutil\nfrom tests.testutil import DeltaGeneratorTestCase\nimport streamlit as st\n\nURL = \"http://not.a.real.url:3001\"\nPATH = \"not/a/real/path\"\n\n\ndef _serialize_dataframe_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    component_arrow.marshall(special_arg.arrow_dataframe.data, value)\n    return special_arg\n\n\ndef _serialize_bytes_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    special_arg.bytes = to_bytes(value)\n    return special_arg\n\n\nclass DeclareComponentTest(unittest.TestCase):\n    \"\"\"Test component declaration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_name(self):\n        \"\"\"Test component name generation\"\"\"\n        # Test a component defined in a module with no package\n        component = components.declare_component(\"foo\", url=URL)\n        self.assertEqual(\"components_test.foo\", component.name)\n\n        # Test a component defined in __init__.py\n        from component_test_data import component as init_component\n\n        self.assertEqual(\n            \"component_test_data.foo\",\n            init_component.name,\n        )\n\n        # Test a component defined in a module within a package\n        from component_test_data.outer_module import component as outer_module_component\n\n        self.assertEqual(\n            \"component_test_data.outer_module.foo\",\n            outer_module_component.name,\n        )\n\n        # Test a component defined in module within a nested package\n        from component_test_data.nested.inner_module import (\n            component as inner_module_component,\n        )\n\n        self.assertEqual(\n            \"component_test_data.nested.inner_module.foo\",\n            inner_module_component.name,\n        )\n\n    def test_only_path(self):\n        \"\"\"Succeed when a path is provided.\"\"\"\n\n        def isdir(path):\n            return path == PATH or path == os.path.abspath(PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            component = components.declare_component(\"test\", path=PATH)\n\n        self.assertEqual(PATH, component.path)\n        self.assertIsNone(component.url)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(component.name),\n            component.abspath,\n        )\n\n    def test_only_url(self):\n        \"\"\"Succeed when a URL is provided.\"\"\"\n        component = components.declare_component(\"test\", url=URL)\n        self.assertEqual(URL, component.url)\n        self.assertIsNone(component.path)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(\"components_test\"),\n            component.abspath,\n        )\n\n    def test_path_and_url(self):\n        \"\"\"Fail if path AND url are provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=PATH, url=URL)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n    def test_no_path_and_no_url(self):\n        \"\"\"Fail if neither path nor url is provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=None, url=None)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n\nclass ComponentRegistryTest(unittest.TestCase):\n    \"\"\"Test component registration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_register_component_with_path(self):\n        \"\"\"Registering a component should associate it with its path.\"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        def isdir(path):\n            return path == test_path\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(\n                CustomComponent(\"test_component\", path=test_path)\n            )\n\n        self.assertEqual(test_path, registry.get_component_path(\"test_component\"))\n\n    def test_register_component_no_path(self):\n        \"\"\"It's not an error to register a component without a path.\"\"\"\n        registry = ComponentRegistry.instance()\n\n        # Return None when the component hasn't been registered\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n        # And also return None when the component doesn't have a path\n        registry.register_component(\n            CustomComponent(\"test_component\", url=\"http://not.a.url\")\n        )\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n    def test_register_invalid_path(self):\n        \"\"\"We raise an exception if a component is registered with a\n        non-existent path.\n        \"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        registry = ComponentRegistry.instance()\n        with self.assertRaises(StreamlitAPIException) as ctx:\n            registry.register_component(CustomComponent(\"test_component\", test_path))\n            self.assertIn(\"No such component directory\", ctx.exception)\n\n    def test_register_duplicate_path(self):\n        \"\"\"It's not an error to re-register a component.\n        (This can happen during development).\n        \"\"\"\n        test_path_1 = \"/a/test/component/directory\"\n        test_path_2 = \"/another/test/component/directory\"\n\n        def isdir(path):\n            return path in (test_path_1, test_path_2)\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            self.assertEqual(test_path_1, registry.get_component_path(\"test_component\"))\n\n            registry.register_component(CustomComponent(\"test_component\", test_path_2))\n            self.assertEqual(test_path_2, registry.get_component_path(\"test_component\"))\n\n\nclass InvokeComponentTest(DeltaGeneratorTestCase):\n    \"\"\"Test invocation of a custom component object.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.test_component = components.declare_component(\"test\", url=URL)\n\n    def test_only_json_args(self):\n        \"\"\"Test that component with only json args is marshalled correctly.\"\"\"\n        self.test_component(foo=\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"foo\": \"bar\", \"key\": None, \"default\": None}, proto.json_args\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_only_df_args(self):\n        \"\"\"Test that component with only dataframe args is marshalled correctly.\"\"\"\n        raw_data = {\n            \"First Name\": [\"Jason\", \"Molly\"],\n            \"Last Name\": [\"Miller\", \"Jacobson\"],\n            \"Age\": [42, 52],\n        }\n        df = pd.DataFrame(raw_data, columns=[\"First Name\", \"Last Name\", \"Age\"])\n        self.test_component(df=df)\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(1, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df\", df), proto.special_args[0])\n\n    def test_only_list_args(self):\n        \"\"\"Test that component with only list args is marshalled correctly.\"\"\"\n        self.test_component(data=[\"foo\", \"bar\", \"baz\"])\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual(\n            {\"data\": [\"foo\", \"bar\", \"baz\"], \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_no_args(self):\n        \"\"\"Test that component with no args is marshalled correctly.\"\"\"\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_bytes_args(self):\n        self.test_component(foo=b\"foo\", bar=b\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(\n            _serialize_bytes_arg(\"foo\", b\"foo\"),\n            proto.special_args[0],\n        )\n        self.assertEqual(\n            _serialize_bytes_arg(\"bar\", b\"bar\"),\n            proto.special_args[1],\n        )\n\n    def test_mixed_args(self):\n        \"\"\"Test marshalling of a component with varied arg types.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        self.test_component(string_arg=\"string\", df_arg=df, bytes_arg=b\"bytes\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"string_arg\": \"string\", \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df_arg\", df), proto.special_args[0])\n        self.assertEqual(\n            _serialize_bytes_arg(\"bytes_arg\", b\"bytes\"), proto.special_args[1]\n        )\n\n    def test_duplicate_key(self):\n        \"\"\"Two components with the same `key` should throw DuplicateWidgetID exception\"\"\"\n        self.test_component(foo=\"bar\", key=\"baz\")\n\n        with self.assertRaises(DuplicateWidgetID):\n            self.test_component(key=\"baz\")\n\n    def test_key_sent_to_frontend(self):\n        \"\"\"We send the 'key' param to the frontend (even if it's None).\"\"\"\n        # Test a string key\n        self.test_component(key=\"baz\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": \"baz\", \"default\": None}, proto.json_args)\n\n        # Test an empty key\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n\n    def test_simple_default(self):\n        \"\"\"Test the 'default' param with a JSON value.\"\"\"\n        return_value = self.test_component(default=\"baz\")\n        self.assertEqual(\"baz\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": \"baz\"}, proto.json_args)\n\n    def test_bytes_default(self):\n        \"\"\"Test the 'default' param with a bytes value.\"\"\"\n        return_value = self.test_component(default=b\"bytes\")\n        self.assertEqual(b\"bytes\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_bytes_arg(\"default\", b\"bytes\"),\n            proto.special_args[0],\n        )\n\n    def test_df_default(self):\n        \"\"\"Test the 'default' param with a DataFrame value.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        return_value = self.test_component(default=df)\n        self.assertTrue(df.equals(return_value), \"df != return_value\")\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_dataframe_arg(\"default\", df),\n            proto.special_args[0],\n        )\n\n    def assertJSONEqual(self, a, b):\n        \"\"\"Asserts that two JSON dicts are equal. If either arg is a string,\n        it will be first converted to a dict with json.loads().\"\"\"\n        # Ensure both objects are dicts.\n        dict_a = a if isinstance(a, dict) else json.loads(a)\n        dict_b = b if isinstance(b, dict) else json.loads(b)\n        self.assertEqual(dict_a, dict_b)\n\n    def test_outside_form(self):\n        \"\"\"Test that form id is marshalled correctly outside of a form.\"\"\"\n\n        self.test_component()\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertEqual(proto.form_id, \"\")\n\n    @patch(\"streamlit._is_running_with_streamlit\", new=True)\n    def test_inside_form(self):\n        \"\"\"Test that form id is marshalled correctly inside of a form.\"\"\"\n\n        with st.form(\"foo\"):\n            self.test_component()\n\n        # 2 elements will be created: form block, widget\n        self.assertEqual(len(self.get_all_deltas_from_queue()), 2)\n\n        form_proto = self.get_delta_from_queue(0).add_block\n        component_instance_proto = self.get_delta_from_queue(\n            1\n        ).new_element.component_instance\n        self.assertEqual(component_instance_proto.form_id, form_proto.form.form_id)\n\n\nclass ComponentRequestHandlerTest(tornado.testing.AsyncHTTPTestCase):\n    \"\"\"Test /component endpoint.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def get_app(self):\n        self.registry = ComponentRegistry()\n        return tornado.web.Application(\n            [\n                (\n                    \"/component/(.*)\",\n                    ComponentRequestHandler,\n                    dict(registry=self.registry.instance()),\n                )\n            ]\n        )\n\n    def _request_component(self, path):\n        return self.fetch(\"/component/%s\" % path, method=\"GET\")\n\n    def test_success_request(self):\n        \"\"\"Test request success when valid parameters are provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.open\",\n            mock.mock_open(read_data=\"Test Content\"),\n        ):\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(b\"Test Content\", response.body)\n\n    def test_invalid_component_request(self):\n        \"\"\"Test request failure when invalid component name is provided.\"\"\"\n\n        response = self._request_component(\"invalid_component\")\n        self.assertEqual(404, response.code)\n        self.assertEqual(b\"not found\", response.body)\n\n    def test_invalid_content_request(self):\n        \"\"\"Test request failure when invalid content (file) is provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.side_effect = OSError(\"Invalid content\")\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(404, response.code)\n        self.assertEqual(\n            b\"read error\",\n            response.body,\n        )\n\n    def test_support_binary_files_request(self):\n        \"\"\"Test support for binary files reads.\"\"\"\n\n        def _open_read(m, payload):\n            is_binary = False\n            args, kwargs = m.call_args\n            if len(args) > 1:\n                if \"b\" in args[1]:\n                    is_binary = True\n            encoding = \"utf-8\"\n            if \"encoding\" in kwargs:\n                encoding = kwargs[\"encoding\"]\n\n            if is_binary:\n                from io import BytesIO\n\n                return BytesIO(payload)\n            else:\n                from io import TextIOWrapper\n\n                return TextIOWrapper(str(payload, encoding=encoding))\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        payload = b\"\\x00\\x01\\x00\\x00\\x00\\x0D\\x00\\x80\"  # binary non utf-8 payload\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.return_value.__enter__ = lambda _: _open_read(m, payload)\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(\n            payload,\n            response.body,\n        )\n\n\nclass IFrameTest(testutil.DeltaGeneratorTestCase):\n    def test_iframe(self):\n        \"\"\"Test components.iframe\"\"\"\n        components.iframe(\"http://not.a.url\", width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"http://not.a.url\")\n        self.assertEqual(el.iframe.srcdoc, \"\")\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n\n    def test_html(self):\n        \"\"\"Test components.html\"\"\"\n        html = r\"<html><body>An HTML string!</body></html>\"\n        components.html(html, width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"\")\n        self.assertEqual(el.iframe.srcdoc, html)\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n"], "fixing_code": ["# Copyright 2018-2022 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport json\nimport mimetypes\nimport os\nimport threading\nfrom typing import Any, Dict, Optional, Type, Union\n\nimport tornado.web\nfrom streamlit.scriptrunner import get_script_run_ctx\n\nimport streamlit.server.routes\nfrom streamlit import type_util\nfrom streamlit.elements.form import current_form_id\nfrom streamlit import util\nfrom streamlit.errors import StreamlitAPIException\nfrom streamlit.logger import get_logger\nfrom streamlit.proto.Components_pb2 import SpecialArg, ArrowTable as ArrowTableProto\nfrom streamlit.proto.Element_pb2 import Element\nfrom streamlit.state import NoValue, register_widget\nfrom streamlit.type_util import to_bytes\n\nLOGGER = get_logger(__name__)\n\n\nclass MarshallComponentException(StreamlitAPIException):\n    \"\"\"Class for exceptions generated during custom component marshalling.\"\"\"\n\n    pass\n\n\nclass CustomComponent:\n    \"\"\"A Custom Component declaration.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        path: Optional[str] = None,\n        url: Optional[str] = None,\n    ):\n        if (path is None and url is None) or (path is not None and url is not None):\n            raise StreamlitAPIException(\n                \"Either 'path' or 'url' must be set, but not both.\"\n            )\n\n        self.name = name\n        self.path = path\n        self.url = url\n\n    def __repr__(self) -> str:\n        return util.repr_(self)\n\n    @property\n    def abspath(self) -> Optional[str]:\n        \"\"\"The absolute path that the component is served from.\"\"\"\n        if self.path is None:\n            return None\n        return os.path.abspath(self.path)\n\n    def __call__(\n        self,\n        *args,\n        default: Any = None,\n        key: Optional[str] = None,\n        **kwargs,\n    ) -> Any:\n        \"\"\"An alias for create_instance.\"\"\"\n        return self.create_instance(*args, default=default, key=key, **kwargs)\n\n    def create_instance(\n        self,\n        *args,\n        default: Any = None,\n        key: Optional[str] = None,\n        **kwargs,\n    ) -> Any:\n        \"\"\"Create a new instance of the component.\n\n        Parameters\n        ----------\n        *args\n            Must be empty; all args must be named. (This parameter exists to\n            enforce correct use of the function.)\n        default: any or None\n            The default return value for the component. This is returned when\n            the component's frontend hasn't yet specified a value with\n            `setComponentValue`.\n        key: str or None\n            If not None, this is the user key we use to generate the\n            component's \"widget ID\".\n        **kwargs\n            Keyword args to pass to the component.\n\n        Returns\n        -------\n        any or None\n            The component's widget value.\n\n        \"\"\"\n        if len(args) > 0:\n            raise MarshallComponentException(f\"Argument '{args[0]}' needs a label\")\n\n        try:\n            import pyarrow\n            from streamlit.components.v1 import component_arrow\n        except ImportError:\n            raise StreamlitAPIException(\n                \"\"\"To use Custom Components in Streamlit, you need to install\nPyArrow. To do so locally:\n\n`pip install pyarrow`\n\nAnd if you're using Streamlit Cloud, add \"pyarrow\" to your requirements.txt.\"\"\"\n            )\n\n        # In addition to the custom kwargs passed to the component, we also\n        # send the special 'default' and 'key' params to the component\n        # frontend.\n        all_args = dict(kwargs, **{\"default\": default, \"key\": key})\n\n        json_args = {}\n        special_args = []\n        for arg_name, arg_val in all_args.items():\n            if type_util.is_bytes_like(arg_val):\n                bytes_arg = SpecialArg()\n                bytes_arg.key = arg_name\n                bytes_arg.bytes = to_bytes(arg_val)\n                special_args.append(bytes_arg)\n            elif type_util.is_dataframe_like(arg_val):\n                dataframe_arg = SpecialArg()\n                dataframe_arg.key = arg_name\n                component_arrow.marshall(dataframe_arg.arrow_dataframe.data, arg_val)\n                special_args.append(dataframe_arg)\n            else:\n                json_args[arg_name] = arg_val\n\n        try:\n            serialized_json_args = json.dumps(json_args)\n        except BaseException as e:\n            raise MarshallComponentException(\n                \"Could not convert component args to JSON\", e\n            )\n\n        def marshall_component(dg, element: Element) -> Union[Any, Type[NoValue]]:\n            element.component_instance.component_name = self.name\n            element.component_instance.form_id = current_form_id(dg)\n            if self.url is not None:\n                element.component_instance.url = self.url\n\n            # Normally, a widget's element_hash (which determines\n            # its identity across multiple runs of an app) is computed\n            # by hashing the entirety of its protobuf. This means that,\n            # if any of the arguments to the widget are changed, Streamlit\n            # considers it a new widget instance and it loses its previous\n            # state.\n            #\n            # However! If a *component* has a `key` argument, then the\n            # component's hash identity is determined by entirely by\n            # `component_name + url + key`. This means that, when `key`\n            # exists, the component will maintain its identity even when its\n            # other arguments change, and the component's iframe won't be\n            # remounted on the frontend.\n            #\n            # So: if `key` is None, we marshall the element's arguments\n            # *before* computing its widget_ui_value (which creates its hash).\n            # If `key` is not None, we marshall the arguments *after*.\n\n            def marshall_element_args():\n                element.component_instance.json_args = serialized_json_args\n                element.component_instance.special_args.extend(special_args)\n\n            if key is None:\n                marshall_element_args()\n\n            def deserialize_component(ui_value, widget_id=\"\"):\n                # ui_value is an object from json, an ArrowTable proto, or a bytearray\n                return ui_value\n\n            ctx = get_script_run_ctx()\n            component_state = register_widget(\n                element_type=\"component_instance\",\n                element_proto=element.component_instance,\n                user_key=key,\n                widget_func_name=self.name,\n                deserializer=deserialize_component,\n                serializer=lambda x: x,\n                ctx=ctx,\n            )\n            widget_value = component_state.value\n\n            if key is not None:\n                marshall_element_args()\n\n            if widget_value is None:\n                widget_value = default\n            elif isinstance(widget_value, ArrowTableProto):\n                widget_value = component_arrow.arrow_proto_to_dataframe(widget_value)\n\n            # widget_value will be either None or whatever the component's most\n            # recent setWidgetValue value is. We coerce None -> NoValue,\n            # because that's what DeltaGenerator._enqueue expects.\n            return widget_value if widget_value is not None else NoValue\n\n        # We currently only support writing to st._main, but this will change\n        # when we settle on an improved API in a post-layout world.\n        dg = streamlit._main\n\n        element = Element()\n        return_value = marshall_component(dg, element)\n        result = dg._enqueue(\n            \"component_instance\", element.component_instance, return_value\n        )\n\n        return result\n\n    def __eq__(self, other) -> bool:\n        \"\"\"Equality operator.\"\"\"\n        return (\n            isinstance(other, CustomComponent)\n            and self.name == other.name\n            and self.path == other.path\n            and self.url == other.url\n        )\n\n    def __ne__(self, other) -> bool:\n        \"\"\"Inequality operator.\"\"\"\n        return not self == other\n\n    def __str__(self) -> str:\n        return f\"'{self.name}': {self.path if self.path is not None else self.url}\"\n\n\ndef declare_component(\n    name: str,\n    path: Optional[str] = None,\n    url: Optional[str] = None,\n) -> CustomComponent:\n    \"\"\"Create and register a custom component.\n\n    Parameters\n    ----------\n    name: str\n        A short, descriptive name for the component. Like, \"slider\".\n    path: str or None\n        The path to serve the component's frontend files from. Either\n        `path` or `url` must be specified, but not both.\n    url: str or None\n        The URL that the component is served from. Either `path` or `url`\n        must be specified, but not both.\n\n    Returns\n    -------\n    CustomComponent\n        A CustomComponent that can be called like a function.\n        Calling the component will create a new instance of the component\n        in the Streamlit app.\n\n    \"\"\"\n\n    # Get our stack frame.\n    current_frame = inspect.currentframe()\n    assert current_frame is not None\n\n    # Get the stack frame of our calling function.\n    caller_frame = current_frame.f_back\n    assert caller_frame is not None\n\n    # Get the caller's module name. `__name__` gives us the module's\n    # fully-qualified name, which includes its package.\n    module = inspect.getmodule(caller_frame)\n    assert module is not None\n    module_name = module.__name__\n\n    # If the caller was the main module that was executed (that is, if the\n    # user executed `python my_component.py`), then this name will be\n    # \"__main__\" instead of the actual package name. In this case, we use\n    # the main module's filename, sans `.py` extension, as the component name.\n    if module_name == \"__main__\":\n        file_path = inspect.getfile(caller_frame)\n        filename = os.path.basename(file_path)\n        module_name, _ = os.path.splitext(filename)\n\n    # Build the component name.\n    component_name = f\"{module_name}.{name}\"\n\n    # Create our component object, and register it.\n    component = CustomComponent(name=component_name, path=path, url=url)\n    ComponentRegistry.instance().register_component(component)\n\n    return component\n\n\nclass ComponentRequestHandler(tornado.web.RequestHandler):\n    def initialize(self, registry: \"ComponentRegistry\"):\n        self._registry = registry\n\n    def get(self, path: str) -> None:\n        parts = path.split(\"/\")\n        component_name = parts[0]\n        component_root = self._registry.get_component_path(component_name)\n        if component_root is None:\n            self.write(\"not found\")\n            self.set_status(404)\n            return\n\n        # follow symlinks to get an accurate normalized path\n        component_root = os.path.realpath(component_root)\n        filename = \"/\".join(parts[1:])\n        abspath = os.path.realpath(os.path.join(component_root, filename))\n\n        # Do NOT expose anything outside of the component root.\n        if os.path.commonprefix([component_root, abspath]) != component_root:\n            self.write(\"forbidden\")\n            self.set_status(403)\n            return\n\n        LOGGER.debug(\"ComponentRequestHandler: GET: %s -> %s\", path, abspath)\n\n        try:\n            with open(abspath, \"rb\") as file:\n                contents = file.read()\n        except (OSError) as e:\n            LOGGER.error(f\"ComponentRequestHandler: GET {path} read error\", exc_info=e)\n            self.write(\"read error\")\n            self.set_status(404)\n            return\n\n        self.write(contents)\n        self.set_header(\"Content-Type\", self.get_content_type(abspath))\n\n        self.set_extra_headers(path)\n\n    def set_extra_headers(self, path) -> None:\n        \"\"\"Disable cache for HTML files.\n\n        Other assets like JS and CSS are suffixed with their hash, so they can\n        be cached indefinitely.\n        \"\"\"\n        is_index_url = len(path) == 0\n\n        if is_index_url or path.endswith(\".html\"):\n            self.set_header(\"Cache-Control\", \"no-cache\")\n        else:\n            self.set_header(\"Cache-Control\", \"public\")\n\n    def set_default_headers(self) -> None:\n        if streamlit.server.routes.allow_cross_origin_requests():\n            self.set_header(\"Access-Control-Allow-Origin\", \"*\")\n\n    def options(self) -> None:\n        \"\"\"/OPTIONS handler for preflight CORS checks.\"\"\"\n        self.set_status(204)\n        self.finish()\n\n    @staticmethod\n    def get_content_type(abspath) -> str:\n        \"\"\"Returns the ``Content-Type`` header to be used for this request.\n        From tornado.web.StaticFileHandler.\n        \"\"\"\n        mime_type, encoding = mimetypes.guess_type(abspath)\n        # per RFC 6713, use the appropriate type for a gzip compressed file\n        if encoding == \"gzip\":\n            return \"application/gzip\"\n        # As of 2015-07-21 there is no bzip2 encoding defined at\n        # http://www.iana.org/assignments/media-types/media-types.xhtml\n        # So for that (and any other encoding), use octet-stream.\n        elif encoding is not None:\n            return \"application/octet-stream\"\n        elif mime_type is not None:\n            return mime_type\n        # if mime_type not detected, use application/octet-stream\n        else:\n            return \"application/octet-stream\"\n\n    @staticmethod\n    def get_url(file_id: str) -> str:\n        \"\"\"Return the URL for a component file with the given ID.\"\"\"\n        return \"components/{}\".format(file_id)\n\n\nclass ComponentRegistry:\n    _instance_lock: threading.Lock = threading.Lock()\n    _instance: Optional[\"ComponentRegistry\"] = None\n\n    @classmethod\n    def instance(cls) -> \"ComponentRegistry\":\n        \"\"\"Returns the singleton ComponentRegistry\"\"\"\n        # We use a double-checked locking optimization to avoid the overhead\n        # of acquiring the lock in the common case:\n        # https://en.wikipedia.org/wiki/Double-checked_locking\n        if cls._instance is None:\n            with cls._instance_lock:\n                if cls._instance is None:\n                    cls._instance = ComponentRegistry()\n        return cls._instance\n\n    def __init__(self):\n        self._components = {}  # type: Dict[str, CustomComponent]\n        self._lock = threading.Lock()\n\n    def __repr__(self) -> str:\n        return util.repr_(self)\n\n    def register_component(self, component: CustomComponent) -> None:\n        \"\"\"Register a CustomComponent.\n\n        Parameters\n        ----------\n        component : CustomComponent\n            The component to register.\n        \"\"\"\n\n        # Validate the component's path\n        abspath = component.abspath\n        if abspath is not None and not os.path.isdir(abspath):\n            raise StreamlitAPIException(f\"No such component directory: '{abspath}'\")\n\n        with self._lock:\n            existing = self._components.get(component.name)\n            self._components[component.name] = component\n\n        if existing is not None and component != existing:\n            LOGGER.warning(\n                \"%s overriding previously-registered %s\",\n                component,\n                existing,\n            )\n\n        LOGGER.debug(\"Registered component %s\", component)\n\n    def get_component_path(self, name: str) -> Optional[str]:\n        \"\"\"Return the filesystem path for the component with the given name.\n\n        If no such component is registered, or if the component exists but is\n        being served from a URL, return None instead.\n        \"\"\"\n        component = self._components.get(name, None)\n        return component.abspath if component is not None else None\n", "# Copyright 2018-2022 Streamlit Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\nimport unittest\nfrom typing import Any\nfrom unittest import mock\nfrom unittest.mock import patch\n\nimport pandas as pd\nimport pytest\nimport tornado.testing\nimport tornado.web\n\nfrom streamlit import StreamlitAPIException\nfrom streamlit.components.v1 import component_arrow\nfrom streamlit.components.v1.components import (\n    ComponentRegistry,\n    ComponentRequestHandler,\n    CustomComponent,\n    declare_component,\n)\nimport streamlit.components.v1 as components\nfrom streamlit.errors import DuplicateWidgetID\nfrom streamlit.proto.Components_pb2 import SpecialArg\nfrom streamlit.type_util import to_bytes\nfrom tests import testutil\nfrom tests.testutil import DeltaGeneratorTestCase\nimport streamlit as st\n\nURL = \"http://not.a.real.url:3001\"\nPATH = \"not/a/real/path\"\n\n\ndef _serialize_dataframe_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    component_arrow.marshall(special_arg.arrow_dataframe.data, value)\n    return special_arg\n\n\ndef _serialize_bytes_arg(key: str, value: Any) -> SpecialArg:\n    special_arg = SpecialArg()\n    special_arg.key = key\n    special_arg.bytes = to_bytes(value)\n    return special_arg\n\n\nclass DeclareComponentTest(unittest.TestCase):\n    \"\"\"Test component declaration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_name(self):\n        \"\"\"Test component name generation\"\"\"\n        # Test a component defined in a module with no package\n        component = components.declare_component(\"foo\", url=URL)\n        self.assertEqual(\"components_test.foo\", component.name)\n\n        # Test a component defined in __init__.py\n        from component_test_data import component as init_component\n\n        self.assertEqual(\n            \"component_test_data.foo\",\n            init_component.name,\n        )\n\n        # Test a component defined in a module within a package\n        from component_test_data.outer_module import component as outer_module_component\n\n        self.assertEqual(\n            \"component_test_data.outer_module.foo\",\n            outer_module_component.name,\n        )\n\n        # Test a component defined in module within a nested package\n        from component_test_data.nested.inner_module import (\n            component as inner_module_component,\n        )\n\n        self.assertEqual(\n            \"component_test_data.nested.inner_module.foo\",\n            inner_module_component.name,\n        )\n\n    def test_only_path(self):\n        \"\"\"Succeed when a path is provided.\"\"\"\n\n        def isdir(path):\n            return path == PATH or path == os.path.abspath(PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            component = components.declare_component(\"test\", path=PATH)\n\n        self.assertEqual(PATH, component.path)\n        self.assertIsNone(component.url)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(component.name),\n            component.abspath,\n        )\n\n    def test_only_url(self):\n        \"\"\"Succeed when a URL is provided.\"\"\"\n        component = components.declare_component(\"test\", url=URL)\n        self.assertEqual(URL, component.url)\n        self.assertIsNone(component.path)\n\n        self.assertEqual(\n            ComponentRegistry.instance().get_component_path(\"components_test\"),\n            component.abspath,\n        )\n\n    def test_path_and_url(self):\n        \"\"\"Fail if path AND url are provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=PATH, url=URL)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n    def test_no_path_and_no_url(self):\n        \"\"\"Fail if neither path nor url is provided.\"\"\"\n        with pytest.raises(StreamlitAPIException) as exception_message:\n            components.declare_component(\"test\", path=None, url=None)\n        self.assertEqual(\n            \"Either 'path' or 'url' must be set, but not both.\",\n            str(exception_message.value),\n        )\n\n\nclass ComponentRegistryTest(unittest.TestCase):\n    \"\"\"Test component registration.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def test_register_component_with_path(self):\n        \"\"\"Registering a component should associate it with its path.\"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        def isdir(path):\n            return path == test_path\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(\n                CustomComponent(\"test_component\", path=test_path)\n            )\n\n        self.assertEqual(test_path, registry.get_component_path(\"test_component\"))\n\n    def test_register_component_no_path(self):\n        \"\"\"It's not an error to register a component without a path.\"\"\"\n        registry = ComponentRegistry.instance()\n\n        # Return None when the component hasn't been registered\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n        # And also return None when the component doesn't have a path\n        registry.register_component(\n            CustomComponent(\"test_component\", url=\"http://not.a.url\")\n        )\n        self.assertIsNone(registry.get_component_path(\"test_component\"))\n\n    def test_register_invalid_path(self):\n        \"\"\"We raise an exception if a component is registered with a\n        non-existent path.\n        \"\"\"\n        test_path = \"/a/test/component/directory\"\n\n        registry = ComponentRegistry.instance()\n        with self.assertRaises(StreamlitAPIException) as ctx:\n            registry.register_component(CustomComponent(\"test_component\", test_path))\n            self.assertIn(\"No such component directory\", ctx.exception)\n\n    def test_register_duplicate_path(self):\n        \"\"\"It's not an error to re-register a component.\n        (This can happen during development).\n        \"\"\"\n        test_path_1 = \"/a/test/component/directory\"\n        test_path_2 = \"/another/test/component/directory\"\n\n        def isdir(path):\n            return path in (test_path_1, test_path_2)\n\n        registry = ComponentRegistry.instance()\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.isdir\", side_effect=isdir\n        ):\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            registry.register_component(CustomComponent(\"test_component\", test_path_1))\n            self.assertEqual(test_path_1, registry.get_component_path(\"test_component\"))\n\n            registry.register_component(CustomComponent(\"test_component\", test_path_2))\n            self.assertEqual(test_path_2, registry.get_component_path(\"test_component\"))\n\n\nclass InvokeComponentTest(DeltaGeneratorTestCase):\n    \"\"\"Test invocation of a custom component object.\"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.test_component = components.declare_component(\"test\", url=URL)\n\n    def test_only_json_args(self):\n        \"\"\"Test that component with only json args is marshalled correctly.\"\"\"\n        self.test_component(foo=\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"foo\": \"bar\", \"key\": None, \"default\": None}, proto.json_args\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_only_df_args(self):\n        \"\"\"Test that component with only dataframe args is marshalled correctly.\"\"\"\n        raw_data = {\n            \"First Name\": [\"Jason\", \"Molly\"],\n            \"Last Name\": [\"Miller\", \"Jacobson\"],\n            \"Age\": [42, 52],\n        }\n        df = pd.DataFrame(raw_data, columns=[\"First Name\", \"Last Name\", \"Age\"])\n        self.test_component(df=df)\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(1, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df\", df), proto.special_args[0])\n\n    def test_only_list_args(self):\n        \"\"\"Test that component with only list args is marshalled correctly.\"\"\"\n        self.test_component(data=[\"foo\", \"bar\", \"baz\"])\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual(\n            {\"data\": [\"foo\", \"bar\", \"baz\"], \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_no_args(self):\n        \"\"\"Test that component with no args is marshalled correctly.\"\"\"\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(\"[]\", str(proto.special_args))\n\n    def test_bytes_args(self):\n        self.test_component(foo=b\"foo\", bar=b\"bar\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(\n            _serialize_bytes_arg(\"foo\", b\"foo\"),\n            proto.special_args[0],\n        )\n        self.assertEqual(\n            _serialize_bytes_arg(\"bar\", b\"bar\"),\n            proto.special_args[1],\n        )\n\n    def test_mixed_args(self):\n        \"\"\"Test marshalling of a component with varied arg types.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        self.test_component(string_arg=\"string\", df_arg=df, bytes_arg=b\"bytes\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n\n        self.assertEqual(self.test_component.name, proto.component_name)\n        self.assertJSONEqual(\n            {\"string_arg\": \"string\", \"key\": None, \"default\": None},\n            proto.json_args,\n        )\n        self.assertEqual(2, len(proto.special_args))\n        self.assertEqual(_serialize_dataframe_arg(\"df_arg\", df), proto.special_args[0])\n        self.assertEqual(\n            _serialize_bytes_arg(\"bytes_arg\", b\"bytes\"), proto.special_args[1]\n        )\n\n    def test_duplicate_key(self):\n        \"\"\"Two components with the same `key` should throw DuplicateWidgetID exception\"\"\"\n        self.test_component(foo=\"bar\", key=\"baz\")\n\n        with self.assertRaises(DuplicateWidgetID):\n            self.test_component(key=\"baz\")\n\n    def test_key_sent_to_frontend(self):\n        \"\"\"We send the 'key' param to the frontend (even if it's None).\"\"\"\n        # Test a string key\n        self.test_component(key=\"baz\")\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": \"baz\", \"default\": None}, proto.json_args)\n\n        # Test an empty key\n        self.test_component()\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": None}, proto.json_args)\n\n    def test_simple_default(self):\n        \"\"\"Test the 'default' param with a JSON value.\"\"\"\n        return_value = self.test_component(default=\"baz\")\n        self.assertEqual(\"baz\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None, \"default\": \"baz\"}, proto.json_args)\n\n    def test_bytes_default(self):\n        \"\"\"Test the 'default' param with a bytes value.\"\"\"\n        return_value = self.test_component(default=b\"bytes\")\n        self.assertEqual(b\"bytes\", return_value)\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_bytes_arg(\"default\", b\"bytes\"),\n            proto.special_args[0],\n        )\n\n    def test_df_default(self):\n        \"\"\"Test the 'default' param with a DataFrame value.\"\"\"\n        df = pd.DataFrame(\n            {\n                \"First Name\": [\"Jason\", \"Molly\"],\n                \"Last Name\": [\"Miller\", \"Jacobson\"],\n                \"Age\": [42, 52],\n            },\n            columns=[\"First Name\", \"Last Name\", \"Age\"],\n        )\n        return_value = self.test_component(default=df)\n        self.assertTrue(df.equals(return_value), \"df != return_value\")\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertJSONEqual({\"key\": None}, proto.json_args)\n        self.assertEqual(\n            _serialize_dataframe_arg(\"default\", df),\n            proto.special_args[0],\n        )\n\n    def assertJSONEqual(self, a, b):\n        \"\"\"Asserts that two JSON dicts are equal. If either arg is a string,\n        it will be first converted to a dict with json.loads().\"\"\"\n        # Ensure both objects are dicts.\n        dict_a = a if isinstance(a, dict) else json.loads(a)\n        dict_b = b if isinstance(b, dict) else json.loads(b)\n        self.assertEqual(dict_a, dict_b)\n\n    def test_outside_form(self):\n        \"\"\"Test that form id is marshalled correctly outside of a form.\"\"\"\n\n        self.test_component()\n\n        proto = self.get_delta_from_queue().new_element.component_instance\n        self.assertEqual(proto.form_id, \"\")\n\n    @patch(\"streamlit._is_running_with_streamlit\", new=True)\n    def test_inside_form(self):\n        \"\"\"Test that form id is marshalled correctly inside of a form.\"\"\"\n\n        with st.form(\"foo\"):\n            self.test_component()\n\n        # 2 elements will be created: form block, widget\n        self.assertEqual(len(self.get_all_deltas_from_queue()), 2)\n\n        form_proto = self.get_delta_from_queue(0).add_block\n        component_instance_proto = self.get_delta_from_queue(\n            1\n        ).new_element.component_instance\n        self.assertEqual(component_instance_proto.form_id, form_proto.form.form_id)\n\n\nclass ComponentRequestHandlerTest(tornado.testing.AsyncHTTPTestCase):\n    \"\"\"Test /component endpoint.\"\"\"\n\n    def tearDown(self) -> None:\n        ComponentRegistry._instance = None\n\n    def get_app(self):\n        self.registry = ComponentRegistry()\n        return tornado.web.Application(\n            [\n                (\n                    \"/component/(.*)\",\n                    ComponentRequestHandler,\n                    dict(registry=self.registry.instance()),\n                )\n            ]\n        )\n\n    def _request_component(self, path):\n        return self.fetch(\"/component/%s\" % path, method=\"GET\")\n\n    def test_success_request(self):\n        \"\"\"Test request success when valid parameters are provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.open\",\n            mock.mock_open(read_data=\"Test Content\"),\n        ):\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(b\"Test Content\", response.body)\n\n    def test_outside_component_root_request(self):\n        \"\"\"Tests to ensure a path based on the root directory (and therefore\n        outside of the component root) is disallowed.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        response = self._request_component(\n            \"components_test.test//etc/hosts\"\n        )\n\n        self.assertEqual(403, response.code)\n        self.assertEqual(b\"forbidden\", response.body)\n\n    def test_relative_outside_component_root_request(self):\n        \"\"\"Tests to ensure a path relative to the component root directory\n        (and specifically outside of the component root) is disallowed.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        response = self._request_component(\n            \"components_test.test/../foo\"\n        )\n\n        self.assertEqual(403, response.code)\n        self.assertEqual(b\"forbidden\", response.body)\n\n    def test_symlink_outside_component_root_request(self):\n        \"\"\"Tests to ensure a path symlinked to a file outside the component\n        root directory is disallowed.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            # We don't need the return value in this case.\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\n            \"streamlit.components.v1.components.os.path.realpath\",\n            side_effect=[PATH, \"/etc/hosts\"],\n        ):\n            response = self._request_component(\n                \"components_test.test\"\n            )\n\n        self.assertEqual(403, response.code)\n        self.assertEqual(b\"forbidden\", response.body)\n\n    def test_invalid_component_request(self):\n        \"\"\"Test request failure when invalid component name is provided.\"\"\"\n\n        response = self._request_component(\"invalid_component\")\n        self.assertEqual(404, response.code)\n        self.assertEqual(b\"not found\", response.body)\n\n    def test_invalid_content_request(self):\n        \"\"\"Test request failure when invalid content (file) is provided.\"\"\"\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.side_effect = OSError(\"Invalid content\")\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(404, response.code)\n        self.assertEqual(\n            b\"read error\",\n            response.body,\n        )\n\n    def test_support_binary_files_request(self):\n        \"\"\"Test support for binary files reads.\"\"\"\n\n        def _open_read(m, payload):\n            is_binary = False\n            args, kwargs = m.call_args\n            if len(args) > 1:\n                if \"b\" in args[1]:\n                    is_binary = True\n            encoding = \"utf-8\"\n            if \"encoding\" in kwargs:\n                encoding = kwargs[\"encoding\"]\n\n            if is_binary:\n                from io import BytesIO\n\n                return BytesIO(payload)\n            else:\n                from io import TextIOWrapper\n\n                return TextIOWrapper(str(payload, encoding=encoding))\n\n        with mock.patch(\"streamlit.components.v1.components.os.path.isdir\"):\n            declare_component(\"test\", path=PATH)\n\n        payload = b\"\\x00\\x01\\x00\\x00\\x00\\x0D\\x00\\x80\"  # binary non utf-8 payload\n\n        with mock.patch(\"streamlit.components.v1.components.open\") as m:\n            m.return_value.__enter__ = lambda _: _open_read(m, payload)\n            response = self._request_component(\"components_test.test\")\n\n        self.assertEqual(200, response.code)\n        self.assertEqual(\n            payload,\n            response.body,\n        )\n\n\nclass IFrameTest(testutil.DeltaGeneratorTestCase):\n    def test_iframe(self):\n        \"\"\"Test components.iframe\"\"\"\n        components.iframe(\"http://not.a.url\", width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"http://not.a.url\")\n        self.assertEqual(el.iframe.srcdoc, \"\")\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n\n    def test_html(self):\n        \"\"\"Test components.html\"\"\"\n        html = r\"<html><body>An HTML string!</body></html>\"\n        components.html(html, width=200, scrolling=True)\n\n        el = self.get_delta_from_queue().new_element\n        self.assertEqual(el.iframe.src, \"\")\n        self.assertEqual(el.iframe.srcdoc, html)\n        self.assertEqual(el.iframe.width, 200)\n        self.assertTrue(el.iframe.has_width)\n        self.assertTrue(el.iframe.scrolling)\n"], "filenames": ["lib/streamlit/components/v1/components.py", "lib/tests/streamlit/components_test.py"], "buggy_code_start_loc": [318, 436], "buggy_code_end_loc": [321, 436], "fixing_code_start_loc": [319, 437], "fixing_code_end_loc": [329, 486], "type": "CWE-22", "message": "Streamlit is a data oriented application development framework for python. Users hosting Streamlit app(s) that use custom components are vulnerable to a directory traversal attack that could leak data from their web server file-system such as: server logs, world readable files, and potentially other sensitive information. An attacker can craft a malicious URL with file paths and the streamlit server would process that URL and return the contents of that file. This issue has been resolved in version 1.11.1. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-35918", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-01T22:15:10.223", "lastModified": "2022-10-29T02:53:22.297", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Streamlit is a data oriented application development framework for python. Users hosting Streamlit app(s) that use custom components are vulnerable to a directory traversal attack that could leak data from their web server file-system such as: server logs, world readable files, and potentially other sensitive information. An attacker can craft a malicious URL with file paths and the streamlit server would process that URL and return the contents of that file. This issue has been resolved in version 1.11.1. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "Streamlit es un marco de desarrollo de aplicaciones orientado a datos para python. Los usuarios que alojan aplicaciones Streamlit que usan componentes personalizados son vulnerables a un ataque de salto de directorio que podr\u00eda filtrar datos de su sistema de archivos del servidor web, como por ejemplo: registros del servidor, archivos legibles a nivel mundial y, potencialmente, otra informaci\u00f3n confidencial. Un atacante puede dise\u00f1ar una URL maliciosa con rutas de archivos y el servidor streamlit procesar\u00eda esa URL y devolver\u00eda el contenido de ese archivo o sobrescribir\u00eda los archivos existentes en el servidor web. Este problema ha sido resuelto en versi\u00f3n 1.11.1. Se recomienda a los usuarios que actualicen. No hay soluciones alternativas conocidas para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:streamlit:streamlit:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.63.0", "versionEndExcluding": "1.11.1", "matchCriteriaId": "E7D7D21F-C83B-474E-B4B4-F9BB944F84F4"}]}]}], "references": [{"url": "https://github.com/streamlit/streamlit/commit/80d9979d5f4a00217743d607078a1d867fad8acf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/streamlit/streamlit/security/advisories/GHSA-v4hr-4jpx-56gc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/streamlit/streamlit/commit/80d9979d5f4a00217743d607078a1d867fad8acf"}}