{"buggy_code": ["<?php\n/**\n * Copyright since 2007 PrestaShop SA and Contributors\n * PrestaShop is an International Registered Trademark & Property of PrestaShop SA\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Open Software License (OSL 3.0)\n * that is bundled with this package in the file LICENSE.md.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/OSL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to https://devdocs.prestashop.com/ for more information.\n *\n * @author    PrestaShop SA and Contributors <contact@prestashop.com>\n * @copyright Since 2007 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/OSL-3.0 Open Software License (OSL 3.0)\n */\n\ndeclare(strict_types=1);\n\nnamespace PrestaShop\\PrestaShop\\Adapter\\Product\\Repository;\n\nuse Doctrine\\DBAL\\Connection;\nuse Doctrine\\DBAL\\Driver\\Exception;\nuse Doctrine\\DBAL\\Exception as ExceptionAlias;\nuse Doctrine\\DBAL\\FetchMode;\nuse Doctrine\\DBAL\\Query\\QueryBuilder;\nuse ObjectModel;\nuse PrestaShop\\PrestaShop\\Adapter\\Category\\Repository\\CategoryRepository;\nuse PrestaShop\\PrestaShop\\Adapter\\Manufacturer\\Repository\\ManufacturerRepository;\nuse PrestaShop\\PrestaShop\\Adapter\\Product\\Validate\\ProductValidator;\nuse PrestaShop\\PrestaShop\\Adapter\\TaxRulesGroup\\Repository\\TaxRulesGroupRepository;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\AttributeGroup\\Attribute\\ValueObject\\AttributeId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\AttributeGroup\\ValueObject\\AttributeGroupId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Carrier\\ValueObject\\CarrierReferenceId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Category\\ValueObject\\CategoryId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Language\\ValueObject\\LanguageId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Manufacturer\\Exception\\ManufacturerException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Manufacturer\\ValueObject\\ManufacturerId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Manufacturer\\ValueObject\\NoManufacturerId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\CannotAddProductException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\CannotDeleteProductException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\CannotUpdateProductException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\ProductConstraintException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\ProductException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\ProductNotFoundException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\ProductShopAssociationNotFoundException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Pack\\Exception\\ProductPackConstraintException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\ProductTaxRulesGroupSettings;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Stock\\Exception\\ProductStockConstraintException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\ValueObject\\ProductId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\ValueObject\\ProductType;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Shop\\Exception\\ShopAssociationNotFound;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Shop\\Exception\\ShopGroupAssociationNotFound;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Shop\\ValueObject\\ShopConstraint;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Shop\\ValueObject\\ShopGroupId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Shop\\ValueObject\\ShopId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\TaxRulesGroup\\Exception\\TaxRulesGroupException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\TaxRulesGroup\\ValueObject\\TaxRulesGroupId;\nuse PrestaShop\\PrestaShop\\Core\\Exception\\CoreException;\nuse PrestaShop\\PrestaShop\\Core\\Repository\\AbstractMultiShopObjectModelRepository;\nuse PrestaShopException;\nuse Product;\n\nclass ProductRepository extends AbstractMultiShopObjectModelRepository\n{\n    /**\n     * @var Connection\n     */\n    private $connection;\n\n    /**\n     * @var string\n     */\n    private $dbPrefix;\n\n    /**\n     * @var ProductValidator\n     */\n    private $productValidator;\n\n    /**\n     * @var TaxRulesGroupRepository\n     */\n    private $taxRulesGroupRepository;\n\n    /**\n     * @var ManufacturerRepository\n     */\n    private $manufacturerRepository;\n\n    /**\n     * @var CategoryRepository\n     */\n    private $categoryRepository;\n\n    /**\n     * @param Connection $connection\n     * @param string $dbPrefix\n     * @param ProductValidator $productValidator\n     * @param TaxRulesGroupRepository $taxRulesGroupRepository\n     * @param ManufacturerRepository $manufacturerRepository\n     * @param CategoryRepository $categoryRepository\n     */\n    public function __construct(\n        Connection $connection,\n        string $dbPrefix,\n        ProductValidator $productValidator,\n        TaxRulesGroupRepository $taxRulesGroupRepository,\n        ManufacturerRepository $manufacturerRepository,\n        CategoryRepository $categoryRepository\n    ) {\n        $this->connection = $connection;\n        $this->dbPrefix = $dbPrefix;\n        $this->productValidator = $productValidator;\n        $this->taxRulesGroupRepository = $taxRulesGroupRepository;\n        $this->manufacturerRepository = $manufacturerRepository;\n        $this->categoryRepository = $categoryRepository;\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopId $shopId\n     *\n     * @return Product\n     *\n     * @throws CoreException\n     */\n    public function get(ProductId $productId, ShopId $shopId): Product\n    {\n        return $this->getProductByShopId($productId, $shopId);\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return ShopId\n     *\n     * @throws ProductNotFoundException\n     */\n    public function getProductDefaultShopId(ProductId $productId): ShopId\n    {\n        $qb = $this->connection->createQueryBuilder();\n        $qb\n            ->select('id_shop_default')\n            ->from($this->dbPrefix . 'product')\n            ->where('id_product = :productId')\n            ->setParameter('productId', $productId->getValue())\n        ;\n\n        $result = $qb->execute()->fetchAssociative();\n        if (empty($result['id_shop_default'])) {\n            throw new ProductNotFoundException(sprintf(\n                'Could not find Product with id %d',\n                $productId->getValue()\n            ));\n        }\n\n        return new ShopId((int) $result['id_shop_default']);\n    }\n\n    /**\n     * Returns the default shop of a product among a group, if the product's default shop is in the group it will\n     * naturally be returned. In the other case the first shop associated to the product in the group is returned.\n     *\n     * @param ProductId $productId\n     * @param ShopGroupId $shopGroupId\n     *\n     * @return ShopId\n     */\n    public function getProductDefaultShopIdForGroup(ProductId $productId, ShopGroupId $shopGroupId): ShopId\n    {\n        $qb = $this->connection->createQueryBuilder();\n        $qb\n            ->select('p.id_shop_default, s.id_shop')\n            ->from($this->dbPrefix . 'product', 'p')\n            ->innerJoin(\n                'p',\n                $this->dbPrefix . 'product_shop',\n                'ps',\n                'ps.id_product = p.id_product'\n            )\n            ->innerJoin(\n                'ps',\n                $this->dbPrefix . 'shop',\n                's',\n                's.id_shop = ps.id_shop'\n            )\n            ->where('p.id_product = :productId')\n            ->andWhere('s.id_shop_group = :shopGroupId')\n            ->addOrderBy('s.id_shop', 'ASC')\n            ->setParameter('shopGroupId', $shopGroupId->getValue())\n            ->setParameter('productId', $productId->getValue())\n        ;\n\n        $result = $qb->execute()->fetchAllAssociative();\n        if (empty($result)) {\n            throw new ShopGroupAssociationNotFound(sprintf(\n                'Could not find association between Product %d and Shop group %d',\n                $productId->getValue(),\n                $shopGroupId->getValue()\n            ));\n        }\n\n        // By default, the first shop from the group is considered the default one\n        $defaultShopId = (int) $result[0]['id_shop'];\n        foreach ($result as $productShop) {\n            // If one of the shops from the group is the actual product's default shop it takes priority\n            if ((int) $productShop['id_shop_default'] === (int) $productShop['id_shop']) {\n                $defaultShopId = (int) $productShop['id_shop_default'];\n                break;\n            }\n        }\n\n        return new ShopId($defaultShopId);\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopConstraint $shopConstraint\n     *\n     * @return Product\n     *\n     * @throws CoreException\n     */\n    public function getByShopConstraint(ProductId $productId, ShopConstraint $shopConstraint): Product\n    {\n        if ($shopConstraint->getShopGroupId()) {\n            return $this->getProductByShopGroup($productId, $shopConstraint->getShopGroupId());\n        }\n\n        if ($shopConstraint->forAllShops()) {\n            return $this->getProductByDefaultShop($productId);\n        }\n\n        return $this->getProductByShopId($productId, $shopConstraint->getShopId());\n    }\n\n    /**\n     * @param array<int, string> $localizedNames\n     * @param array<int, string> $localizedLinkRewrites\n     * @param string $productType\n     * @param ShopId $shopId\n     *\n     * @return Product\n     *\n     * @throws CoreException\n     */\n    public function create(\n        array $localizedNames,\n        array $localizedLinkRewrites,\n        string $productType,\n        ShopId $shopId\n    ): Product {\n        $defaultCategoryId = $this->categoryRepository->getShopDefaultCategory($shopId);\n\n        $product = new Product(null, false, null, $shopId->getValue());\n        $product->active = false;\n        $product->id_category_default = $defaultCategoryId->getValue();\n        $product->is_virtual = ProductType::TYPE_VIRTUAL === $productType;\n        $product->cache_is_pack = ProductType::TYPE_PACK === $productType;\n        $product->product_type = $productType;\n        $product->id_shop_default = $shopId->getValue();\n        $product->name = $localizedNames;\n        $product->link_rewrite = $localizedLinkRewrites;\n\n        $this->productValidator->validateCreation($product);\n        $this->addObjectModelToShops($product, [$shopId], CannotAddProductException::class);\n        $this->categoryRepository->addProductAssociations(\n            new ProductId((int) $product->id),\n            [$defaultCategoryId]\n        );\n\n        return $product;\n    }\n\n    /**\n     * @param Product $product\n     * @param array $propertiesToUpdate\n     * @param ShopConstraint $shopConstraint\n     * @param int $errorCode\n     */\n    public function partialUpdate(Product $product, array $propertiesToUpdate, ShopConstraint $shopConstraint, int $errorCode): void\n    {\n        $this->validateProduct($product, $propertiesToUpdate);\n        $shopIds = $this->getShopIdsByConstraint(new ProductId((int) $product->id), $shopConstraint);\n\n        $this->partiallyUpdateObjectModelForShops(\n            $product,\n            $propertiesToUpdate,\n            $shopIds,\n            CannotUpdateProductException::class,\n            $errorCode\n        );\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param CarrierReferenceId[] $carrierReferenceIds\n     * @param ShopConstraint $shopConstraint\n     */\n    public function setCarrierReferences(ProductId $productId, array $carrierReferenceIds, ShopConstraint $shopConstraint): void\n    {\n        $shopIds = array_map(function (ShopId $shopId): int {\n            return $shopId->getValue();\n        }, $this->getShopIdsByConstraint($productId, $shopConstraint));\n\n        $productIdValue = $productId->getValue();\n\n        $deleteQb = $this->connection->createQueryBuilder();\n        $deleteQb->delete($this->dbPrefix . 'product_carrier')\n            ->where('id_product = :productId')\n            ->andWhere($deleteQb->expr()->in('id_shop', ':shopIds'))\n            ->setParameter('productId', $productIdValue)\n            ->setParameter('shopIds', $shopIds, Connection::PARAM_INT_ARRAY)\n            ->execute()\n        ;\n\n        $insertValues = [];\n        foreach ($carrierReferenceIds as $referenceId) {\n            foreach ($shopIds as $shopId) {\n                $insertValues[] = sprintf(\n                    '(%d, %d, %d)',\n                    $productIdValue,\n                    $referenceId->getValue(),\n                    $shopId\n                );\n            }\n        }\n\n        if (empty($insertValues)) {\n            return;\n        }\n\n        $stmt = '\n            INSERT INTO ' . $this->dbPrefix . 'product_carrier (\n                id_product,\n                id_carrier_reference,\n                id_shop\n            )\n            VALUES ' . implode(',', $insertValues) . '\n        ';\n\n        $this->connection->executeStatement($stmt);\n    }\n\n    /**\n     * @param Product $product\n     * @param ShopConstraint $shopConstraint\n     * @param int $errorCode\n     */\n    public function update(Product $product, ShopConstraint $shopConstraint, int $errorCode): void\n    {\n        $this->validateProduct($product);\n        $this->updateObjectModelForShops(\n            $product,\n            $this->getShopIdsByConstraint(new ProductId((int) $product->id), $shopConstraint),\n            CannotUpdateProductException::class,\n            $errorCode\n        );\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return ShopId[]\n     */\n    public function getAssociatedShopIds(ProductId $productId): array\n    {\n        $qb = $this->connection->createQueryBuilder();\n        $qb\n            ->select('id_shop')\n            ->from($this->dbPrefix . 'product_shop')\n            ->where('id_product = :productId')\n            ->setParameter('productId', $productId->getValue())\n        ;\n\n        return array_map(static function (array $shop) {\n            return new ShopId((int) $shop['id_shop']);\n        }, $qb->execute()->fetchAllAssociative());\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopGroupId $shopGroupId\n     *\n     * @return ShopId[]\n     */\n    public function getAssociatedShopIdsFromGroup(ProductId $productId, ShopGroupId $shopGroupId): array\n    {\n        $qb = $this->connection->createQueryBuilder();\n        $qb\n            ->select('ps.id_shop')\n            ->from($this->dbPrefix . 'product_shop', 'ps')\n            ->innerJoin(\n                'ps',\n                $this->dbPrefix . 'shop',\n                's',\n                's.id_shop = ps.id_shop'\n            )\n            ->where('ps.id_product = :productId')\n            ->andWhere('s.id_shop_group = :shopGroupId')\n            ->setParameter('shopGroupId', $shopGroupId->getValue())\n            ->setParameter('productId', $productId->getValue())\n        ;\n\n        return array_map(static function (array $shop) {\n            return new ShopId((int) $shop['id_shop']);\n        }, $qb->execute()->fetchAllAssociative());\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopId[] $shopIds\n     *\n     * @throws CannotDeleteProductException\n     * @throws ShopAssociationNotFound\n     */\n    public function deleteFromShops(ProductId $productId, array $shopIds): void\n    {\n        if (empty($shopIds)) {\n            return;\n        }\n\n        foreach ($shopIds as $shopId) {\n            $this->checkShopAssociation($productId->getValue(), Product::class, $shopId);\n        }\n\n        // We fetch the product from its default shop, the values don't matter anyway we just need a Product instance\n        $product = $this->getProductByDefaultShop($productId);\n\n        $this->deleteObjectModelFromShops($product, $shopIds, CannotDeleteProductException::class);\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopConstraint $shopConstraint\n     */\n    public function deleteByShopConstraint(ProductId $productId, ShopConstraint $shopConstraint): void\n    {\n        // We fetch the product from its default shop, the values don't matter anyway we just need a Product instance\n        $product = $this->getProductByDefaultShop($productId);\n        $shopIds = $this->getShopIdsByConstraint($productId, $shopConstraint);\n        $this->deleteObjectModelFromShops($product, $shopIds, CannotDeleteProductException::class);\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return bool\n     */\n    public function hasCombinations(ProductId $productId): bool\n    {\n        $result = $this->connection->createQueryBuilder()\n            ->select('pa.id_product_attribute')\n            ->from($this->dbPrefix . 'product_attribute', 'pa')\n            ->where('pa.id_product = :productId')\n            ->setParameter('productId', $productId->getValue())\n            ->execute()\n            ->fetchOne()\n        ;\n\n        return !empty($result);\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return AttributeGroupId[]\n     */\n    public function getProductAttributesGroupIds(ProductId $productId, ShopConstraint $shopConstraint): array\n    {\n        $shopIds = array_map(static function (ShopId $shopId): int {\n            return $shopId->getValue();\n        }, $this->getShopIdsByConstraint($productId, $shopConstraint));\n\n        $qb = $this->connection->createQueryBuilder();\n        $qb->select('a.id_attribute_group')\n            ->from($this->dbPrefix . 'attribute', 'a')\n            ->innerJoin(\n                'a',\n                $this->dbPrefix . 'product_attribute_combination',\n                'pac',\n                'a.id_attribute = pac.id_attribute'\n            )\n            ->innerJoin(\n                'pac',\n                $this->dbPrefix . 'product_attribute_shop',\n                'pas',\n                'pas.id_product_attribute = pac.id_product_attribute'\n            )\n            ->where('pas.id_product = :productId')\n            ->andWhere($qb->expr()->in('pas.id_shop', ':shopIds'))\n            ->setParameter('shopIds', $shopIds, Connection::PARAM_INT_ARRAY)\n            ->setParameter('productId', $productId->getValue())\n            ->groupBy('a.id_attribute_group')\n        ;\n\n        $results = $qb->execute()->fetchAll(FetchMode::COLUMN);\n\n        return array_map(static function (string $id): AttributeGroupId {\n            return new AttributeGroupId((int) $id);\n        }, $results);\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return AttributeId[]\n     */\n    public function getProductAttributesIds(ProductId $productId, ShopConstraint $shopConstraint): array\n    {\n        $shopIds = array_map(static function (ShopId $shopId): int {\n            return $shopId->getValue();\n        }, $this->getShopIdsByConstraint($productId, $shopConstraint));\n\n        $qb = $this->connection->createQueryBuilder();\n        $qb->select('pac.id_attribute')\n            ->from($this->dbPrefix . 'product_attribute_combination', 'pac')\n            ->innerJoin(\n                'pac',\n                $this->dbPrefix . 'product_attribute_shop',\n                'pas',\n                'pac.id_product_attribute = pas.id_product_attribute'\n            )\n            ->where('pas.id_product = :productId')\n            ->andWhere($qb->expr()->in('pas.id_shop', ':shopIds'))\n            ->setParameter('shopIds', $shopIds, Connection::PARAM_INT_ARRAY)\n            ->setParameter('productId', $productId->getValue())\n            ->groupBy('pac.id_attribute')\n        ;\n\n        $results = $qb->execute()->fetchAll(FetchMode::COLUMN);\n\n        return array_map(static function (string $id): AttributeId {\n            return new AttributeId((int) $id);\n        }, $results);\n    }\n\n    /**\n     * Updates the Product's cache default attribute by selecting appropriate value from combination tables\n     *\n     * @param ProductId $productId\n     */\n    public function updateCachedDefaultCombination(ProductId $productId, ShopConstraint $shopConstraint): void\n    {\n        $shopIds = array_map(function (ShopId $shopId): int {\n            return $shopId->getValue();\n        }, $this->getShopIdsByConstraint($productId, $shopConstraint));\n\n        $defaultShopId = $this->getProductDefaultShopId($productId)->getValue();\n        $defaultCombinations = $this->connection->fetchAllAssociative(\n            sprintf('\n                SELECT id_product_attribute, id_shop\n                FROM %sproduct_attribute_shop\n                WHERE id_product = %d\n                AND id_shop IN (%s)\n                AND default_on = 1\n                ORDER BY id_shop ASC\n            ',\n                $this->dbPrefix,\n                $productId->getValue(),\n                implode(',', $shopIds)\n            )\n        );\n\n        $productShopTable = sprintf('%sproduct_shop', $this->dbPrefix);\n        $combinationIdForDefaultShop = null;\n        $combinationShopIds = [];\n\n        foreach ($defaultCombinations as $defaultCombination) {\n            $combinationId = (int) $defaultCombination['id_product_attribute'];\n            $combinationShopId = (int) $defaultCombination['id_shop'];\n            $combinationShopIds[] = $combinationShopId;\n\n            if ($defaultShopId === $combinationShopId) {\n                $combinationIdForDefaultShop = $combinationId;\n            }\n\n            $this->connection->executeStatement(sprintf(\n                'UPDATE %s SET cache_default_attribute = %d WHERE id_product = %d AND id_shop = %d',\n                $productShopTable,\n                $combinationId,\n                $productId->getValue(),\n                $combinationShopId\n            ));\n        }\n\n        $this->connection->executeStatement(sprintf(\n            'UPDATE %sproduct SET cache_default_attribute = %d WHERE id_product = %d',\n            $this->dbPrefix,\n            $combinationIdForDefaultShop,\n            $productId->getValue()\n        ));\n\n        $unhandledShopIds = array_diff($shopIds, $combinationShopIds);\n        foreach ($unhandledShopIds as $shopId) {\n            // reset default combination to 0 to all shop ids which have no combinations\n            $this->connection->executeStatement(sprintf(\n                'UPDATE %s SET cache_default_attribute = %d WHERE id_product = %d AND id_shop = %d',\n                $productShopTable,\n                0,\n                $productId->getValue(),\n                $shopId\n            ));\n        }\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return ProductType\n     *\n     * @throws ProductNotFoundException\n     */\n    public function getProductType(ProductId $productId): ProductType\n    {\n        $result = $this->connection->createQueryBuilder()\n            ->select('p.product_type')\n            ->from($this->dbPrefix . 'product', 'p')\n            ->where('p.id_product = :productId')\n            ->setParameter('productId', $productId->getValue())\n            ->execute()\n            ->fetchAssociative()\n        ;\n\n        if (empty($result)) {\n            throw new ProductNotFoundException(sprintf(\n                'Cannot find product type for product %d because it does not exist',\n                $productId->getValue()\n            ));\n        }\n\n        if (!empty($result['product_type'])) {\n            return new ProductType($result['product_type']);\n        }\n\n        // Older products that were created before product page v2, might have no type, so we determine it dynamically\n        return new ProductType($this->getProductByDefaultShop($productId)->getDynamicProductType());\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return Product\n     *\n     * @throws ProductNotFoundException\n     */\n    public function getProductByDefaultShop(ProductId $productId): Product\n    {\n        $defaultShopId = $this->getProductDefaultShopId($productId);\n\n        return $this->getProductByShopId($productId, $defaultShopId);\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopId $shopId\n     *\n     * @throws ShopAssociationNotFound\n     */\n    public function assertProductIsAssociatedToShop(ProductId $productId, ShopId $shopId): void\n    {\n        $this->checkShopAssociation(\n            $productId->getValue(),\n            Product::class,\n            $shopId\n        );\n    }\n\n    /**\n     * Gets position product position in category\n     *\n     * @param ProductId $productId\n     * @param CategoryId $categoryId\n     *\n     * @return int|null\n     */\n    public function getPositionInCategory(ProductId $productId, CategoryId $categoryId): ?int\n    {\n        $qb = $this->connection->createQueryBuilder();\n        $qb->select('position')\n            ->from($this->dbPrefix . 'category_product')\n            ->where('id_product = :productId')\n            ->andWhere('id_category = :categoryId')\n            ->setParameter('productId', $productId->getValue())\n            ->setParameter('categoryId', $categoryId->getValue())\n        ;\n\n        $position = $qb->execute()->fetchOne();\n\n        if (!$position) {\n            return null;\n        }\n\n        return (int) $position;\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param LanguageId $languageId\n     *\n     * @return array<array<string, string>>\n     *                                      e.g [\n     *                                      ['id_product' => '1', 'name' => 'Product name', 'reference' => 'demo15'],\n     *                                      ['id_product' => '2', 'name' => 'Product name2', 'reference' => 'demo16'],\n     *                                      ]\n     *\n     * @throws CoreException\n     */\n    public function getRelatedProducts(ProductId $productId, LanguageId $languageId): array\n    {\n        $this->assertProductExists($productId);\n        $productIdValue = $productId->getValue();\n\n        try {\n            $accessories = Product::getAccessoriesLight($languageId->getValue(), $productIdValue);\n        } catch (PrestaShopException $e) {\n            throw new CoreException(sprintf(\n                'Error occurred when fetching related products for product #%d',\n                $productIdValue\n            ));\n        }\n\n        return $accessories;\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @throws ProductNotFoundException\n     */\n    public function assertProductExists(ProductId $productId): void\n    {\n        $this->assertObjectModelExists($productId->getValue(), 'product', ProductNotFoundException::class);\n    }\n\n    /**\n     * @param ProductId[] $productIds\n     *\n     * @throws ProductNotFoundException\n     */\n    public function assertAllProductsExists(array $productIds): void\n    {\n        //@todo: no shop association. Should it be checked here?\n        $ids = array_map(function (ProductId $productId): int {\n            return $productId->getValue();\n        }, $productIds);\n        $ids = array_unique($ids);\n\n        $qb = $this->connection->createQueryBuilder();\n        $qb->select('COUNT(id_product) as product_count')\n            ->from($this->dbPrefix . 'product')\n            ->where('id_product IN (:productIds)')\n            ->setParameter('productIds', $ids, Connection::PARAM_INT_ARRAY)\n        ;\n\n        $results = $qb->execute()->fetch();\n\n        if (!$results || (int) $results['product_count'] !== count($ids)) {\n            throw new ProductNotFoundException(\n                sprintf(\n                    'Some of these products do not exist: %s',\n                    implode(',', $ids)\n                )\n            );\n        }\n    }\n\n    /**\n     * @param string $searchPhrase\n     * @param LanguageId $languageId\n     * @param ShopId $shopId\n     * @param int|null $limit\n     *\n     * @return array<int, array<string, int|string>>\n     */\n    public function searchProducts(string $searchPhrase, LanguageId $languageId, ShopId $shopId, ?int $limit = null): array\n    {\n        $qb = $this->getSearchQueryBuilder(\n            $searchPhrase,\n            $languageId,\n            $shopId,\n            [],\n            $limit);\n        $qb\n            ->addSelect('p.id_product, pl.name, p.reference, i.id_image')\n            ->addGroupBy('p.id_product')\n            ->addOrderBy('pl.name', 'ASC')\n            ->addOrderBy('p.id_product', 'ASC')\n        ;\n\n        return $qb->execute()->fetchAllAssociative();\n    }\n\n    /**\n     * @param string $searchPhrase\n     * @param LanguageId $languageId\n     * @param ShopId $shopId\n     * @param array $filters\n     * @param int|null $limit\n     *\n     * @return array<int, array<string, int|string>>\n     *\n     * @throws Exception\n     * @throws ExceptionAlias\n     */\n    public function searchCombinations(\n        string $searchPhrase,\n        LanguageId $languageId,\n        ShopId $shopId,\n        array $filters = [],\n        ?int $limit = null\n    ): array {\n        $qb = $this->getSearchQueryBuilder(\n            $searchPhrase,\n            $languageId,\n            $shopId,\n            $filters,\n            $limit\n        );\n        $qb\n            ->addSelect('p.id_product, pa.id_product_attribute, pl.name, i.id_image')\n            ->addSelect('p.reference as product_reference')\n            ->addSelect('pa.reference as combination_reference')\n            ->addSelect('ai.id_image as combination_image_id')\n            ->leftJoin('p', $this->dbPrefix . 'product_attribute_image', 'ai', 'ai.id_product_attribute = pa.id_product_attribute')\n            ->addGroupBy('p.id_product, pa.id_product_attribute')\n            ->addOrderBy('pl.name', 'ASC')\n            ->addOrderBy('p.id_product', 'ASC')\n            ->addOrderBy('pa.id_product_attribute', 'ASC')\n        ;\n\n        return $qb->execute()->fetchAllAssociative();\n    }\n\n    public function getProductTaxRulesGroupId(ProductId $productId, ShopId $shopId): TaxRulesGroupId\n    {\n        $result = $this->connection->createQueryBuilder()\n            ->addSelect('p_shop.id_tax_rules_group')\n            ->from($this->dbPrefix . 'product_shop', 'p_shop')\n            ->where('p_shop.id_product = :productId')\n            ->andWhere('p_shop.id_shop = :shopId')\n            ->setParameter('shopId', $shopId->getValue())\n            ->setParameter('productId', $productId->getValue())\n            ->execute()\n            ->fetchOne()\n        ;\n\n        return new TaxRulesGroupId((int) $result);\n    }\n\n    /**\n     * @param string $searchPhrase\n     * @param LanguageId $languageId\n     * @param ShopId $shopId\n     * @param array $filters\n     * @param int|null $limit\n     *\n     * @return QueryBuilder\n     */\n    protected function getSearchQueryBuilder(\n        string $searchPhrase,\n        LanguageId $languageId,\n        ShopId $shopId,\n        array $filters = [],\n        ?int $limit = null\n    ): QueryBuilder {\n        $qb = $this->connection->createQueryBuilder();\n        $qb\n            ->addSelect('p.id_product, pl.name, p.reference, i.id_image')\n            ->from($this->dbPrefix . 'product', 'p')\n            ->join('p', $this->dbPrefix . 'product_shop', 'ps', 'ps.id_product = p.id_product AND ps.id_shop = :shopId')\n            ->leftJoin('p', $this->dbPrefix . 'product_lang', 'pl', 'pl.id_product = p.id_product AND pl.id_lang = :languageId')\n            ->leftJoin('p', $this->dbPrefix . 'image_shop', 'i', 'i.id_product = p.id_product AND i.id_shop = :shopId AND i.cover = 1')\n            ->leftJoin('p', $this->dbPrefix . 'product_supplier', 'psu', 'psu.id_product = p.id_product')\n            ->leftJoin('p', $this->dbPrefix . 'product_attribute', 'pa', 'pa.id_product = p.id_product')\n            ->setParameter('shopId', $shopId->getValue())\n            ->setParameter('languageId', $languageId->getValue())\n            ->addOrderBy('pl.name', 'ASC')\n            ->addGroupBy('p.id_product')\n        ;\n\n        $dbSearchPhrase = sprintf('\"%%%s%%\"', $searchPhrase);\n        $qb->where($qb->expr()->or(\n            $qb->expr()->like('pl.name', $dbSearchPhrase),\n\n            // Product references\n            $qb->expr()->like('p.isbn', $dbSearchPhrase),\n            $qb->expr()->like('p.upc', $dbSearchPhrase),\n            $qb->expr()->like('p.mpn', $dbSearchPhrase),\n            $qb->expr()->like('p.reference', $dbSearchPhrase),\n            $qb->expr()->like('p.ean13', $dbSearchPhrase),\n            $qb->expr()->like('p.supplier_reference', $dbSearchPhrase),\n\n            // Combination attributes\n            $qb->expr()->like('pa.isbn', $dbSearchPhrase),\n            $qb->expr()->like('pa.upc', $dbSearchPhrase),\n            $qb->expr()->like('pa.mpn', $dbSearchPhrase),\n            $qb->expr()->like('pa.reference', $dbSearchPhrase),\n            $qb->expr()->like('pa.ean13', $dbSearchPhrase),\n            $qb->expr()->like('pa.supplier_reference', $dbSearchPhrase)\n        ));\n\n        if (!empty($filters)) {\n            foreach ($filters as $type => $filter) {\n                switch ($type) {\n                    case 'filteredTypes':\n                        $qb->andWhere('p.product_type not in(:filter)')\n                            ->setParameter('filter', implode(', ', $filter));\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n\n        if (!empty($limit)) {\n            $qb->setMaxResults($limit);\n        }\n\n        return $qb;\n    }\n\n    private function getProductByShopGroup(ProductId $productId, ShopGroupId $shopGroupId): Product\n    {\n        $groupDefaultShopId = $this->getProductDefaultShopIdForGroup($productId, $shopGroupId);\n\n        return $this->getProductByShopId($productId, $groupDefaultShopId);\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopId $shopId\n     *\n     * @return Product\n     *\n     * @throws CoreException\n     */\n    private function getProductByShopId(ProductId $productId, ShopId $shopId): Product\n    {\n        /** @var Product $product */\n        $product = $this->getObjectModelForShop(\n            $productId->getValue(),\n            Product::class,\n            ProductNotFoundException::class,\n            $shopId,\n            ProductShopAssociationNotFoundException::class\n        );\n\n        return $this->loadProduct($product);\n    }\n\n    /**\n     * Returns a single shop ID when the constraint is a single shop, and the list of shops associated to the product\n     * when the constraint is for all shops (shop group constraint is forbidden)\n     *\n     * @param ProductId $productId\n     * @param ShopConstraint $shopConstraint\n     *\n     * @return ShopId[]\n     */\n    public function getShopIdsByConstraint(ProductId $productId, ShopConstraint $shopConstraint): array\n    {\n        if ($shopConstraint->getShopGroupId()) {\n            return $this->getAssociatedShopIdsFromGroup($productId, $shopConstraint->getShopGroupId());\n        }\n\n        if ($shopConstraint->forAllShops()) {\n            return $this->getAssociatedShopIds($productId);\n        }\n\n        return [$shopConstraint->getShopId()];\n    }\n\n    /**\n     * @todo: this should be removable soon once the deprecated stock properties have been removed see PR #26682\n     *\n     * @param Product $product\n     *\n     * @return Product\n     *\n     * @throws CoreException\n     */\n    private function loadProduct(Product $product): Product\n    {\n        try {\n            $product->loadStockData();\n        } catch (PrestaShopException $e) {\n            throw new CoreException(\n                sprintf('Error occurred when trying to load Product stock #%d', $product->id),\n                0,\n                $e\n            );\n        }\n\n        return $product;\n    }\n\n    /**\n     * @param Product $product\n     * @param array $propertiesToUpdate\n     *\n     * @throws CoreException\n     * @throws ProductConstraintException\n     * @throws ProductException\n     * @throws ProductPackConstraintException\n     * @throws ProductStockConstraintException\n     * @throws ManufacturerException\n     * @throws TaxRulesGroupException\n     */\n    private function validateProduct(Product $product, array $propertiesToUpdate = []): void\n    {\n        $taxRulesGroupIdIsBeingUpdated = empty($propertiesToUpdate) || in_array('id_tax_rules_group', $propertiesToUpdate, true);\n        $taxRulesGroupId = (int) $product->id_tax_rules_group;\n        $manufacturerIdIsBeingUpdated = empty($propertiesToUpdate) || in_array('id_manufacturer', $propertiesToUpdate, true);\n        $manufacturerId = (int) $product->id_manufacturer;\n\n        if ($taxRulesGroupIdIsBeingUpdated && $taxRulesGroupId !== ProductTaxRulesGroupSettings::NONE_APPLIED) {\n            $this->taxRulesGroupRepository->assertTaxRulesGroupExists(new TaxRulesGroupId($taxRulesGroupId));\n        }\n        if ($manufacturerIdIsBeingUpdated && $manufacturerId !== NoManufacturerId::NO_MANUFACTURER_ID) {\n            $this->manufacturerRepository->assertManufacturerExists(new ManufacturerId($manufacturerId));\n        }\n\n        $this->productValidator->validate($product);\n    }\n\n    /**\n     * This override was needed because of the extra parameter in product constructor\n     *\n     * {@inheritDoc}\n     */\n    protected function constructObjectModel(int $id, string $objectModelClass, ?int $shopId): ObjectModel\n    {\n        return new Product($id, false, null, $shopId);\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * Copyright since 2007 PrestaShop SA and Contributors\n * PrestaShop is an International Registered Trademark & Property of PrestaShop SA\n *\n * NOTICE OF LICENSE\n *\n * This source file is subject to the Open Software License (OSL 3.0)\n * that is bundled with this package in the file LICENSE.md.\n * It is also available through the world-wide-web at this URL:\n * https://opensource.org/licenses/OSL-3.0\n * If you did not receive a copy of the license and are unable to\n * obtain it through the world-wide-web, please send an email\n * to license@prestashop.com so we can send you a copy immediately.\n *\n * DISCLAIMER\n *\n * Do not edit or add to this file if you wish to upgrade PrestaShop to newer\n * versions in the future. If you wish to customize PrestaShop for your\n * needs please refer to https://devdocs.prestashop.com/ for more information.\n *\n * @author    PrestaShop SA and Contributors <contact@prestashop.com>\n * @copyright Since 2007 PrestaShop SA and Contributors\n * @license   https://opensource.org/licenses/OSL-3.0 Open Software License (OSL 3.0)\n */\n\ndeclare(strict_types=1);\n\nnamespace PrestaShop\\PrestaShop\\Adapter\\Product\\Repository;\n\nuse Doctrine\\DBAL\\Connection;\nuse Doctrine\\DBAL\\Driver\\Exception;\nuse Doctrine\\DBAL\\Exception as ExceptionAlias;\nuse Doctrine\\DBAL\\FetchMode;\nuse Doctrine\\DBAL\\Query\\QueryBuilder;\nuse ObjectModel;\nuse PrestaShop\\PrestaShop\\Adapter\\Category\\Repository\\CategoryRepository;\nuse PrestaShop\\PrestaShop\\Adapter\\Manufacturer\\Repository\\ManufacturerRepository;\nuse PrestaShop\\PrestaShop\\Adapter\\Product\\Validate\\ProductValidator;\nuse PrestaShop\\PrestaShop\\Adapter\\TaxRulesGroup\\Repository\\TaxRulesGroupRepository;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\AttributeGroup\\Attribute\\ValueObject\\AttributeId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\AttributeGroup\\ValueObject\\AttributeGroupId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Carrier\\ValueObject\\CarrierReferenceId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Category\\ValueObject\\CategoryId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Language\\ValueObject\\LanguageId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Manufacturer\\Exception\\ManufacturerException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Manufacturer\\ValueObject\\ManufacturerId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Manufacturer\\ValueObject\\NoManufacturerId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\CannotAddProductException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\CannotDeleteProductException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\CannotUpdateProductException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\ProductConstraintException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\ProductException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\ProductNotFoundException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Exception\\ProductShopAssociationNotFoundException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Pack\\Exception\\ProductPackConstraintException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\ProductTaxRulesGroupSettings;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\Stock\\Exception\\ProductStockConstraintException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\ValueObject\\ProductId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Product\\ValueObject\\ProductType;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Shop\\Exception\\ShopAssociationNotFound;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Shop\\Exception\\ShopGroupAssociationNotFound;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Shop\\ValueObject\\ShopConstraint;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Shop\\ValueObject\\ShopGroupId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\Shop\\ValueObject\\ShopId;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\TaxRulesGroup\\Exception\\TaxRulesGroupException;\nuse PrestaShop\\PrestaShop\\Core\\Domain\\TaxRulesGroup\\ValueObject\\TaxRulesGroupId;\nuse PrestaShop\\PrestaShop\\Core\\Exception\\CoreException;\nuse PrestaShop\\PrestaShop\\Core\\Repository\\AbstractMultiShopObjectModelRepository;\nuse PrestaShopException;\nuse Product;\n\nclass ProductRepository extends AbstractMultiShopObjectModelRepository\n{\n    /**\n     * @var Connection\n     */\n    private $connection;\n\n    /**\n     * @var string\n     */\n    private $dbPrefix;\n\n    /**\n     * @var ProductValidator\n     */\n    private $productValidator;\n\n    /**\n     * @var TaxRulesGroupRepository\n     */\n    private $taxRulesGroupRepository;\n\n    /**\n     * @var ManufacturerRepository\n     */\n    private $manufacturerRepository;\n\n    /**\n     * @var CategoryRepository\n     */\n    private $categoryRepository;\n\n    /**\n     * @param Connection $connection\n     * @param string $dbPrefix\n     * @param ProductValidator $productValidator\n     * @param TaxRulesGroupRepository $taxRulesGroupRepository\n     * @param ManufacturerRepository $manufacturerRepository\n     * @param CategoryRepository $categoryRepository\n     */\n    public function __construct(\n        Connection $connection,\n        string $dbPrefix,\n        ProductValidator $productValidator,\n        TaxRulesGroupRepository $taxRulesGroupRepository,\n        ManufacturerRepository $manufacturerRepository,\n        CategoryRepository $categoryRepository\n    ) {\n        $this->connection = $connection;\n        $this->dbPrefix = $dbPrefix;\n        $this->productValidator = $productValidator;\n        $this->taxRulesGroupRepository = $taxRulesGroupRepository;\n        $this->manufacturerRepository = $manufacturerRepository;\n        $this->categoryRepository = $categoryRepository;\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopId $shopId\n     *\n     * @return Product\n     *\n     * @throws CoreException\n     */\n    public function get(ProductId $productId, ShopId $shopId): Product\n    {\n        return $this->getProductByShopId($productId, $shopId);\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return ShopId\n     *\n     * @throws ProductNotFoundException\n     */\n    public function getProductDefaultShopId(ProductId $productId): ShopId\n    {\n        $qb = $this->connection->createQueryBuilder();\n        $qb\n            ->select('id_shop_default')\n            ->from($this->dbPrefix . 'product')\n            ->where('id_product = :productId')\n            ->setParameter('productId', $productId->getValue())\n        ;\n\n        $result = $qb->execute()->fetchAssociative();\n        if (empty($result['id_shop_default'])) {\n            throw new ProductNotFoundException(sprintf(\n                'Could not find Product with id %d',\n                $productId->getValue()\n            ));\n        }\n\n        return new ShopId((int) $result['id_shop_default']);\n    }\n\n    /**\n     * Returns the default shop of a product among a group, if the product's default shop is in the group it will\n     * naturally be returned. In the other case the first shop associated to the product in the group is returned.\n     *\n     * @param ProductId $productId\n     * @param ShopGroupId $shopGroupId\n     *\n     * @return ShopId\n     */\n    public function getProductDefaultShopIdForGroup(ProductId $productId, ShopGroupId $shopGroupId): ShopId\n    {\n        $qb = $this->connection->createQueryBuilder();\n        $qb\n            ->select('p.id_shop_default, s.id_shop')\n            ->from($this->dbPrefix . 'product', 'p')\n            ->innerJoin(\n                'p',\n                $this->dbPrefix . 'product_shop',\n                'ps',\n                'ps.id_product = p.id_product'\n            )\n            ->innerJoin(\n                'ps',\n                $this->dbPrefix . 'shop',\n                's',\n                's.id_shop = ps.id_shop'\n            )\n            ->where('p.id_product = :productId')\n            ->andWhere('s.id_shop_group = :shopGroupId')\n            ->addOrderBy('s.id_shop', 'ASC')\n            ->setParameter('shopGroupId', $shopGroupId->getValue())\n            ->setParameter('productId', $productId->getValue())\n        ;\n\n        $result = $qb->execute()->fetchAllAssociative();\n        if (empty($result)) {\n            throw new ShopGroupAssociationNotFound(sprintf(\n                'Could not find association between Product %d and Shop group %d',\n                $productId->getValue(),\n                $shopGroupId->getValue()\n            ));\n        }\n\n        // By default, the first shop from the group is considered the default one\n        $defaultShopId = (int) $result[0]['id_shop'];\n        foreach ($result as $productShop) {\n            // If one of the shops from the group is the actual product's default shop it takes priority\n            if ((int) $productShop['id_shop_default'] === (int) $productShop['id_shop']) {\n                $defaultShopId = (int) $productShop['id_shop_default'];\n                break;\n            }\n        }\n\n        return new ShopId($defaultShopId);\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopConstraint $shopConstraint\n     *\n     * @return Product\n     *\n     * @throws CoreException\n     */\n    public function getByShopConstraint(ProductId $productId, ShopConstraint $shopConstraint): Product\n    {\n        if ($shopConstraint->getShopGroupId()) {\n            return $this->getProductByShopGroup($productId, $shopConstraint->getShopGroupId());\n        }\n\n        if ($shopConstraint->forAllShops()) {\n            return $this->getProductByDefaultShop($productId);\n        }\n\n        return $this->getProductByShopId($productId, $shopConstraint->getShopId());\n    }\n\n    /**\n     * @param array<int, string> $localizedNames\n     * @param array<int, string> $localizedLinkRewrites\n     * @param string $productType\n     * @param ShopId $shopId\n     *\n     * @return Product\n     *\n     * @throws CoreException\n     */\n    public function create(\n        array $localizedNames,\n        array $localizedLinkRewrites,\n        string $productType,\n        ShopId $shopId\n    ): Product {\n        $defaultCategoryId = $this->categoryRepository->getShopDefaultCategory($shopId);\n\n        $product = new Product(null, false, null, $shopId->getValue());\n        $product->active = false;\n        $product->id_category_default = $defaultCategoryId->getValue();\n        $product->is_virtual = ProductType::TYPE_VIRTUAL === $productType;\n        $product->cache_is_pack = ProductType::TYPE_PACK === $productType;\n        $product->product_type = $productType;\n        $product->id_shop_default = $shopId->getValue();\n        $product->name = $localizedNames;\n        $product->link_rewrite = $localizedLinkRewrites;\n\n        $this->productValidator->validateCreation($product);\n        $this->addObjectModelToShops($product, [$shopId], CannotAddProductException::class);\n        $this->categoryRepository->addProductAssociations(\n            new ProductId((int) $product->id),\n            [$defaultCategoryId]\n        );\n\n        return $product;\n    }\n\n    /**\n     * @param Product $product\n     * @param array $propertiesToUpdate\n     * @param ShopConstraint $shopConstraint\n     * @param int $errorCode\n     */\n    public function partialUpdate(Product $product, array $propertiesToUpdate, ShopConstraint $shopConstraint, int $errorCode): void\n    {\n        $this->validateProduct($product, $propertiesToUpdate);\n        $shopIds = $this->getShopIdsByConstraint(new ProductId((int) $product->id), $shopConstraint);\n\n        $this->partiallyUpdateObjectModelForShops(\n            $product,\n            $propertiesToUpdate,\n            $shopIds,\n            CannotUpdateProductException::class,\n            $errorCode\n        );\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param CarrierReferenceId[] $carrierReferenceIds\n     * @param ShopConstraint $shopConstraint\n     */\n    public function setCarrierReferences(ProductId $productId, array $carrierReferenceIds, ShopConstraint $shopConstraint): void\n    {\n        $shopIds = array_map(function (ShopId $shopId): int {\n            return $shopId->getValue();\n        }, $this->getShopIdsByConstraint($productId, $shopConstraint));\n\n        $productIdValue = $productId->getValue();\n\n        $deleteQb = $this->connection->createQueryBuilder();\n        $deleteQb->delete($this->dbPrefix . 'product_carrier')\n            ->where('id_product = :productId')\n            ->andWhere($deleteQb->expr()->in('id_shop', ':shopIds'))\n            ->setParameter('productId', $productIdValue)\n            ->setParameter('shopIds', $shopIds, Connection::PARAM_INT_ARRAY)\n            ->execute()\n        ;\n\n        $insertValues = [];\n        foreach ($carrierReferenceIds as $referenceId) {\n            foreach ($shopIds as $shopId) {\n                $insertValues[] = sprintf(\n                    '(%d, %d, %d)',\n                    $productIdValue,\n                    $referenceId->getValue(),\n                    $shopId\n                );\n            }\n        }\n\n        if (empty($insertValues)) {\n            return;\n        }\n\n        $stmt = '\n            INSERT INTO ' . $this->dbPrefix . 'product_carrier (\n                id_product,\n                id_carrier_reference,\n                id_shop\n            )\n            VALUES ' . implode(',', $insertValues) . '\n        ';\n\n        $this->connection->executeStatement($stmt);\n    }\n\n    /**\n     * @param Product $product\n     * @param ShopConstraint $shopConstraint\n     * @param int $errorCode\n     */\n    public function update(Product $product, ShopConstraint $shopConstraint, int $errorCode): void\n    {\n        $this->validateProduct($product);\n        $this->updateObjectModelForShops(\n            $product,\n            $this->getShopIdsByConstraint(new ProductId((int) $product->id), $shopConstraint),\n            CannotUpdateProductException::class,\n            $errorCode\n        );\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return ShopId[]\n     */\n    public function getAssociatedShopIds(ProductId $productId): array\n    {\n        $qb = $this->connection->createQueryBuilder();\n        $qb\n            ->select('id_shop')\n            ->from($this->dbPrefix . 'product_shop')\n            ->where('id_product = :productId')\n            ->setParameter('productId', $productId->getValue())\n        ;\n\n        return array_map(static function (array $shop) {\n            return new ShopId((int) $shop['id_shop']);\n        }, $qb->execute()->fetchAllAssociative());\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopGroupId $shopGroupId\n     *\n     * @return ShopId[]\n     */\n    public function getAssociatedShopIdsFromGroup(ProductId $productId, ShopGroupId $shopGroupId): array\n    {\n        $qb = $this->connection->createQueryBuilder();\n        $qb\n            ->select('ps.id_shop')\n            ->from($this->dbPrefix . 'product_shop', 'ps')\n            ->innerJoin(\n                'ps',\n                $this->dbPrefix . 'shop',\n                's',\n                's.id_shop = ps.id_shop'\n            )\n            ->where('ps.id_product = :productId')\n            ->andWhere('s.id_shop_group = :shopGroupId')\n            ->setParameter('shopGroupId', $shopGroupId->getValue())\n            ->setParameter('productId', $productId->getValue())\n        ;\n\n        return array_map(static function (array $shop) {\n            return new ShopId((int) $shop['id_shop']);\n        }, $qb->execute()->fetchAllAssociative());\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopId[] $shopIds\n     *\n     * @throws CannotDeleteProductException\n     * @throws ShopAssociationNotFound\n     */\n    public function deleteFromShops(ProductId $productId, array $shopIds): void\n    {\n        if (empty($shopIds)) {\n            return;\n        }\n\n        foreach ($shopIds as $shopId) {\n            $this->checkShopAssociation($productId->getValue(), Product::class, $shopId);\n        }\n\n        // We fetch the product from its default shop, the values don't matter anyway we just need a Product instance\n        $product = $this->getProductByDefaultShop($productId);\n\n        $this->deleteObjectModelFromShops($product, $shopIds, CannotDeleteProductException::class);\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopConstraint $shopConstraint\n     */\n    public function deleteByShopConstraint(ProductId $productId, ShopConstraint $shopConstraint): void\n    {\n        // We fetch the product from its default shop, the values don't matter anyway we just need a Product instance\n        $product = $this->getProductByDefaultShop($productId);\n        $shopIds = $this->getShopIdsByConstraint($productId, $shopConstraint);\n        $this->deleteObjectModelFromShops($product, $shopIds, CannotDeleteProductException::class);\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return bool\n     */\n    public function hasCombinations(ProductId $productId): bool\n    {\n        $result = $this->connection->createQueryBuilder()\n            ->select('pa.id_product_attribute')\n            ->from($this->dbPrefix . 'product_attribute', 'pa')\n            ->where('pa.id_product = :productId')\n            ->setParameter('productId', $productId->getValue())\n            ->execute()\n            ->fetchOne()\n        ;\n\n        return !empty($result);\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return AttributeGroupId[]\n     */\n    public function getProductAttributesGroupIds(ProductId $productId, ShopConstraint $shopConstraint): array\n    {\n        $shopIds = array_map(static function (ShopId $shopId): int {\n            return $shopId->getValue();\n        }, $this->getShopIdsByConstraint($productId, $shopConstraint));\n\n        $qb = $this->connection->createQueryBuilder();\n        $qb->select('a.id_attribute_group')\n            ->from($this->dbPrefix . 'attribute', 'a')\n            ->innerJoin(\n                'a',\n                $this->dbPrefix . 'product_attribute_combination',\n                'pac',\n                'a.id_attribute = pac.id_attribute'\n            )\n            ->innerJoin(\n                'pac',\n                $this->dbPrefix . 'product_attribute_shop',\n                'pas',\n                'pas.id_product_attribute = pac.id_product_attribute'\n            )\n            ->where('pas.id_product = :productId')\n            ->andWhere($qb->expr()->in('pas.id_shop', ':shopIds'))\n            ->setParameter('shopIds', $shopIds, Connection::PARAM_INT_ARRAY)\n            ->setParameter('productId', $productId->getValue())\n            ->groupBy('a.id_attribute_group')\n        ;\n\n        $results = $qb->execute()->fetchAll(FetchMode::COLUMN);\n\n        return array_map(static function (string $id): AttributeGroupId {\n            return new AttributeGroupId((int) $id);\n        }, $results);\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return AttributeId[]\n     */\n    public function getProductAttributesIds(ProductId $productId, ShopConstraint $shopConstraint): array\n    {\n        $shopIds = array_map(static function (ShopId $shopId): int {\n            return $shopId->getValue();\n        }, $this->getShopIdsByConstraint($productId, $shopConstraint));\n\n        $qb = $this->connection->createQueryBuilder();\n        $qb->select('pac.id_attribute')\n            ->from($this->dbPrefix . 'product_attribute_combination', 'pac')\n            ->innerJoin(\n                'pac',\n                $this->dbPrefix . 'product_attribute_shop',\n                'pas',\n                'pac.id_product_attribute = pas.id_product_attribute'\n            )\n            ->where('pas.id_product = :productId')\n            ->andWhere($qb->expr()->in('pas.id_shop', ':shopIds'))\n            ->setParameter('shopIds', $shopIds, Connection::PARAM_INT_ARRAY)\n            ->setParameter('productId', $productId->getValue())\n            ->groupBy('pac.id_attribute')\n        ;\n\n        $results = $qb->execute()->fetchAll(FetchMode::COLUMN);\n\n        return array_map(static function (string $id): AttributeId {\n            return new AttributeId((int) $id);\n        }, $results);\n    }\n\n    /**\n     * Updates the Product's cache default attribute by selecting appropriate value from combination tables\n     *\n     * @param ProductId $productId\n     */\n    public function updateCachedDefaultCombination(ProductId $productId, ShopConstraint $shopConstraint): void\n    {\n        $shopIds = array_map(function (ShopId $shopId): int {\n            return $shopId->getValue();\n        }, $this->getShopIdsByConstraint($productId, $shopConstraint));\n\n        $defaultShopId = $this->getProductDefaultShopId($productId)->getValue();\n        $defaultCombinations = $this->connection->fetchAllAssociative(\n            sprintf('\n                SELECT id_product_attribute, id_shop\n                FROM %sproduct_attribute_shop\n                WHERE id_product = %d\n                AND id_shop IN (%s)\n                AND default_on = 1\n                ORDER BY id_shop ASC\n            ',\n                $this->dbPrefix,\n                $productId->getValue(),\n                implode(',', $shopIds)\n            )\n        );\n\n        $productShopTable = sprintf('%sproduct_shop', $this->dbPrefix);\n        $combinationIdForDefaultShop = null;\n        $combinationShopIds = [];\n\n        foreach ($defaultCombinations as $defaultCombination) {\n            $combinationId = (int) $defaultCombination['id_product_attribute'];\n            $combinationShopId = (int) $defaultCombination['id_shop'];\n            $combinationShopIds[] = $combinationShopId;\n\n            if ($defaultShopId === $combinationShopId) {\n                $combinationIdForDefaultShop = $combinationId;\n            }\n\n            $this->connection->executeStatement(sprintf(\n                'UPDATE %s SET cache_default_attribute = %d WHERE id_product = %d AND id_shop = %d',\n                $productShopTable,\n                $combinationId,\n                $productId->getValue(),\n                $combinationShopId\n            ));\n        }\n\n        $this->connection->executeStatement(sprintf(\n            'UPDATE %sproduct SET cache_default_attribute = %d WHERE id_product = %d',\n            $this->dbPrefix,\n            $combinationIdForDefaultShop,\n            $productId->getValue()\n        ));\n\n        $unhandledShopIds = array_diff($shopIds, $combinationShopIds);\n        foreach ($unhandledShopIds as $shopId) {\n            // reset default combination to 0 to all shop ids which have no combinations\n            $this->connection->executeStatement(sprintf(\n                'UPDATE %s SET cache_default_attribute = %d WHERE id_product = %d AND id_shop = %d',\n                $productShopTable,\n                0,\n                $productId->getValue(),\n                $shopId\n            ));\n        }\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return ProductType\n     *\n     * @throws ProductNotFoundException\n     */\n    public function getProductType(ProductId $productId): ProductType\n    {\n        $result = $this->connection->createQueryBuilder()\n            ->select('p.product_type')\n            ->from($this->dbPrefix . 'product', 'p')\n            ->where('p.id_product = :productId')\n            ->setParameter('productId', $productId->getValue())\n            ->execute()\n            ->fetchAssociative()\n        ;\n\n        if (empty($result)) {\n            throw new ProductNotFoundException(sprintf(\n                'Cannot find product type for product %d because it does not exist',\n                $productId->getValue()\n            ));\n        }\n\n        if (!empty($result['product_type'])) {\n            return new ProductType($result['product_type']);\n        }\n\n        // Older products that were created before product page v2, might have no type, so we determine it dynamically\n        return new ProductType($this->getProductByDefaultShop($productId)->getDynamicProductType());\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @return Product\n     *\n     * @throws ProductNotFoundException\n     */\n    public function getProductByDefaultShop(ProductId $productId): Product\n    {\n        $defaultShopId = $this->getProductDefaultShopId($productId);\n\n        return $this->getProductByShopId($productId, $defaultShopId);\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopId $shopId\n     *\n     * @throws ShopAssociationNotFound\n     */\n    public function assertProductIsAssociatedToShop(ProductId $productId, ShopId $shopId): void\n    {\n        $this->checkShopAssociation(\n            $productId->getValue(),\n            Product::class,\n            $shopId\n        );\n    }\n\n    /**\n     * Gets position product position in category\n     *\n     * @param ProductId $productId\n     * @param CategoryId $categoryId\n     *\n     * @return int|null\n     */\n    public function getPositionInCategory(ProductId $productId, CategoryId $categoryId): ?int\n    {\n        $qb = $this->connection->createQueryBuilder();\n        $qb->select('position')\n            ->from($this->dbPrefix . 'category_product')\n            ->where('id_product = :productId')\n            ->andWhere('id_category = :categoryId')\n            ->setParameter('productId', $productId->getValue())\n            ->setParameter('categoryId', $categoryId->getValue())\n        ;\n\n        $position = $qb->execute()->fetchOne();\n\n        if (!$position) {\n            return null;\n        }\n\n        return (int) $position;\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param LanguageId $languageId\n     *\n     * @return array<array<string, string>>\n     *                                      e.g [\n     *                                      ['id_product' => '1', 'name' => 'Product name', 'reference' => 'demo15'],\n     *                                      ['id_product' => '2', 'name' => 'Product name2', 'reference' => 'demo16'],\n     *                                      ]\n     *\n     * @throws CoreException\n     */\n    public function getRelatedProducts(ProductId $productId, LanguageId $languageId): array\n    {\n        $this->assertProductExists($productId);\n        $productIdValue = $productId->getValue();\n\n        try {\n            $accessories = Product::getAccessoriesLight($languageId->getValue(), $productIdValue);\n        } catch (PrestaShopException $e) {\n            throw new CoreException(sprintf(\n                'Error occurred when fetching related products for product #%d',\n                $productIdValue\n            ));\n        }\n\n        return $accessories;\n    }\n\n    /**\n     * @param ProductId $productId\n     *\n     * @throws ProductNotFoundException\n     */\n    public function assertProductExists(ProductId $productId): void\n    {\n        $this->assertObjectModelExists($productId->getValue(), 'product', ProductNotFoundException::class);\n    }\n\n    /**\n     * @param ProductId[] $productIds\n     *\n     * @throws ProductNotFoundException\n     */\n    public function assertAllProductsExists(array $productIds): void\n    {\n        //@todo: no shop association. Should it be checked here?\n        $ids = array_map(function (ProductId $productId): int {\n            return $productId->getValue();\n        }, $productIds);\n        $ids = array_unique($ids);\n\n        $qb = $this->connection->createQueryBuilder();\n        $qb->select('COUNT(id_product) as product_count')\n            ->from($this->dbPrefix . 'product')\n            ->where('id_product IN (:productIds)')\n            ->setParameter('productIds', $ids, Connection::PARAM_INT_ARRAY)\n        ;\n\n        $results = $qb->execute()->fetch();\n\n        if (!$results || (int) $results['product_count'] !== count($ids)) {\n            throw new ProductNotFoundException(\n                sprintf(\n                    'Some of these products do not exist: %s',\n                    implode(',', $ids)\n                )\n            );\n        }\n    }\n\n    /**\n     * @param string $searchPhrase\n     * @param LanguageId $languageId\n     * @param ShopId $shopId\n     * @param int|null $limit\n     *\n     * @return array<int, array<string, int|string>>\n     */\n    public function searchProducts(string $searchPhrase, LanguageId $languageId, ShopId $shopId, ?int $limit = null): array\n    {\n        $qb = $this->getSearchQueryBuilder(\n            $searchPhrase,\n            $languageId,\n            $shopId,\n            [],\n            $limit);\n        $qb\n            ->addSelect('p.id_product, pl.name, p.reference, i.id_image')\n            ->addGroupBy('p.id_product')\n            ->addOrderBy('pl.name', 'ASC')\n            ->addOrderBy('p.id_product', 'ASC')\n        ;\n\n        return $qb->execute()->fetchAllAssociative();\n    }\n\n    /**\n     * @param string $searchPhrase\n     * @param LanguageId $languageId\n     * @param ShopId $shopId\n     * @param array $filters\n     * @param int|null $limit\n     *\n     * @return array<int, array<string, int|string>>\n     *\n     * @throws Exception\n     * @throws ExceptionAlias\n     */\n    public function searchCombinations(\n        string $searchPhrase,\n        LanguageId $languageId,\n        ShopId $shopId,\n        array $filters = [],\n        ?int $limit = null\n    ): array {\n        $qb = $this->getSearchQueryBuilder(\n            $searchPhrase,\n            $languageId,\n            $shopId,\n            $filters,\n            $limit\n        );\n        $qb\n            ->addSelect('p.id_product, pa.id_product_attribute, pl.name, i.id_image')\n            ->addSelect('p.reference as product_reference')\n            ->addSelect('pa.reference as combination_reference')\n            ->addSelect('ai.id_image as combination_image_id')\n            ->leftJoin('p', $this->dbPrefix . 'product_attribute_image', 'ai', 'ai.id_product_attribute = pa.id_product_attribute')\n            ->addGroupBy('p.id_product, pa.id_product_attribute')\n            ->addOrderBy('pl.name', 'ASC')\n            ->addOrderBy('p.id_product', 'ASC')\n            ->addOrderBy('pa.id_product_attribute', 'ASC')\n        ;\n\n        return $qb->execute()->fetchAllAssociative();\n    }\n\n    public function getProductTaxRulesGroupId(ProductId $productId, ShopId $shopId): TaxRulesGroupId\n    {\n        $result = $this->connection->createQueryBuilder()\n            ->addSelect('p_shop.id_tax_rules_group')\n            ->from($this->dbPrefix . 'product_shop', 'p_shop')\n            ->where('p_shop.id_product = :productId')\n            ->andWhere('p_shop.id_shop = :shopId')\n            ->setParameter('shopId', $shopId->getValue())\n            ->setParameter('productId', $productId->getValue())\n            ->execute()\n            ->fetchOne()\n        ;\n\n        return new TaxRulesGroupId((int) $result);\n    }\n\n    /**\n     * @param string $searchPhrase\n     * @param LanguageId $languageId\n     * @param ShopId $shopId\n     * @param array $filters\n     * @param int|null $limit\n     *\n     * @return QueryBuilder\n     */\n    protected function getSearchQueryBuilder(\n        string $searchPhrase,\n        LanguageId $languageId,\n        ShopId $shopId,\n        array $filters = [],\n        ?int $limit = null\n    ): QueryBuilder {\n        $qb = $this->connection->createQueryBuilder();\n        $qb\n            ->addSelect('p.id_product, pl.name, p.reference, i.id_image')\n            ->from($this->dbPrefix . 'product', 'p')\n            ->join('p', $this->dbPrefix . 'product_shop', 'ps', 'ps.id_product = p.id_product AND ps.id_shop = :shopId')\n            ->leftJoin('p', $this->dbPrefix . 'product_lang', 'pl', 'pl.id_product = p.id_product AND pl.id_lang = :languageId')\n            ->leftJoin('p', $this->dbPrefix . 'image_shop', 'i', 'i.id_product = p.id_product AND i.id_shop = :shopId AND i.cover = 1')\n            ->leftJoin('p', $this->dbPrefix . 'product_supplier', 'psu', 'psu.id_product = p.id_product')\n            ->leftJoin('p', $this->dbPrefix . 'product_attribute', 'pa', 'pa.id_product = p.id_product')\n            ->setParameter('shopId', $shopId->getValue())\n            ->setParameter('languageId', $languageId->getValue())\n            ->addOrderBy('pl.name', 'ASC')\n            ->addGroupBy('p.id_product')\n        ;\n\n        $dbSearchPhrase = sprintf('\"%%%s%%\"', pSQL($searchPhrase));\n        $qb->where($qb->expr()->or(\n            $qb->expr()->like('pl.name', $dbSearchPhrase),\n\n            // Product references\n            $qb->expr()->like('p.isbn', $dbSearchPhrase),\n            $qb->expr()->like('p.upc', $dbSearchPhrase),\n            $qb->expr()->like('p.mpn', $dbSearchPhrase),\n            $qb->expr()->like('p.reference', $dbSearchPhrase),\n            $qb->expr()->like('p.ean13', $dbSearchPhrase),\n            $qb->expr()->like('p.supplier_reference', $dbSearchPhrase),\n\n            // Combination attributes\n            $qb->expr()->like('pa.isbn', $dbSearchPhrase),\n            $qb->expr()->like('pa.upc', $dbSearchPhrase),\n            $qb->expr()->like('pa.mpn', $dbSearchPhrase),\n            $qb->expr()->like('pa.reference', $dbSearchPhrase),\n            $qb->expr()->like('pa.ean13', $dbSearchPhrase),\n            $qb->expr()->like('pa.supplier_reference', $dbSearchPhrase)\n        ));\n\n        if (!empty($filters)) {\n            foreach ($filters as $type => $filter) {\n                switch ($type) {\n                    case 'filteredTypes':\n                        $qb->andWhere('p.product_type not in(:filter)')\n                            ->setParameter('filter', implode(', ', $filter));\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n\n        if (!empty($limit)) {\n            $qb->setMaxResults($limit);\n        }\n\n        return $qb;\n    }\n\n    private function getProductByShopGroup(ProductId $productId, ShopGroupId $shopGroupId): Product\n    {\n        $groupDefaultShopId = $this->getProductDefaultShopIdForGroup($productId, $shopGroupId);\n\n        return $this->getProductByShopId($productId, $groupDefaultShopId);\n    }\n\n    /**\n     * @param ProductId $productId\n     * @param ShopId $shopId\n     *\n     * @return Product\n     *\n     * @throws CoreException\n     */\n    private function getProductByShopId(ProductId $productId, ShopId $shopId): Product\n    {\n        /** @var Product $product */\n        $product = $this->getObjectModelForShop(\n            $productId->getValue(),\n            Product::class,\n            ProductNotFoundException::class,\n            $shopId,\n            ProductShopAssociationNotFoundException::class\n        );\n\n        return $this->loadProduct($product);\n    }\n\n    /**\n     * Returns a single shop ID when the constraint is a single shop, and the list of shops associated to the product\n     * when the constraint is for all shops (shop group constraint is forbidden)\n     *\n     * @param ProductId $productId\n     * @param ShopConstraint $shopConstraint\n     *\n     * @return ShopId[]\n     */\n    public function getShopIdsByConstraint(ProductId $productId, ShopConstraint $shopConstraint): array\n    {\n        if ($shopConstraint->getShopGroupId()) {\n            return $this->getAssociatedShopIdsFromGroup($productId, $shopConstraint->getShopGroupId());\n        }\n\n        if ($shopConstraint->forAllShops()) {\n            return $this->getAssociatedShopIds($productId);\n        }\n\n        return [$shopConstraint->getShopId()];\n    }\n\n    /**\n     * @todo: this should be removable soon once the deprecated stock properties have been removed see PR #26682\n     *\n     * @param Product $product\n     *\n     * @return Product\n     *\n     * @throws CoreException\n     */\n    private function loadProduct(Product $product): Product\n    {\n        try {\n            $product->loadStockData();\n        } catch (PrestaShopException $e) {\n            throw new CoreException(\n                sprintf('Error occurred when trying to load Product stock #%d', $product->id),\n                0,\n                $e\n            );\n        }\n\n        return $product;\n    }\n\n    /**\n     * @param Product $product\n     * @param array $propertiesToUpdate\n     *\n     * @throws CoreException\n     * @throws ProductConstraintException\n     * @throws ProductException\n     * @throws ProductPackConstraintException\n     * @throws ProductStockConstraintException\n     * @throws ManufacturerException\n     * @throws TaxRulesGroupException\n     */\n    private function validateProduct(Product $product, array $propertiesToUpdate = []): void\n    {\n        $taxRulesGroupIdIsBeingUpdated = empty($propertiesToUpdate) || in_array('id_tax_rules_group', $propertiesToUpdate, true);\n        $taxRulesGroupId = (int) $product->id_tax_rules_group;\n        $manufacturerIdIsBeingUpdated = empty($propertiesToUpdate) || in_array('id_manufacturer', $propertiesToUpdate, true);\n        $manufacturerId = (int) $product->id_manufacturer;\n\n        if ($taxRulesGroupIdIsBeingUpdated && $taxRulesGroupId !== ProductTaxRulesGroupSettings::NONE_APPLIED) {\n            $this->taxRulesGroupRepository->assertTaxRulesGroupExists(new TaxRulesGroupId($taxRulesGroupId));\n        }\n        if ($manufacturerIdIsBeingUpdated && $manufacturerId !== NoManufacturerId::NO_MANUFACTURER_ID) {\n            $this->manufacturerRepository->assertManufacturerExists(new ManufacturerId($manufacturerId));\n        }\n\n        $this->productValidator->validate($product);\n    }\n\n    /**\n     * This override was needed because of the extra parameter in product constructor\n     *\n     * {@inheritDoc}\n     */\n    protected function constructObjectModel(int $id, string $objectModelClass, ?int $shopId): ObjectModel\n    {\n        return new Product($id, false, null, $shopId);\n    }\n}\n"], "filenames": ["src/Adapter/Product/Repository/ProductRepository.php"], "buggy_code_start_loc": [892], "buggy_code_end_loc": [893], "fixing_code_start_loc": [892], "fixing_code_end_loc": [893], "type": "CWE-89", "message": "PrestaShop is an open source e-commerce web application. Prior to version 8.1.1, SQL injection possible in the product search field, in BO's product page. Version 8.1.1 contains a patch for this issue. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-39524", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-07T20:15:10.107", "lastModified": "2023-08-10T16:58:44.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PrestaShop is an open source e-commerce web application. Prior to version 8.1.1, SQL injection possible in the product search field, in BO's product page. Version 8.1.1 contains a patch for this issue. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 5.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:prestashop:prestashop:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.1.1", "matchCriteriaId": "705A3EBE-48E5-4E3B-A8D8-471098F8B56E"}]}]}], "references": [{"url": "https://github.com/PrestaShop/PrestaShop/commit/2047d4c053043102bc46a37d383b392704bf14d7", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/PrestaShop/PrestaShop/security/advisories/GHSA-75p5-jwx4-qw9h", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/PrestaShop/PrestaShop/commit/2047d4c053043102bc46a37d383b392704bf14d7"}}