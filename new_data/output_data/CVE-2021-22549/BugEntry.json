{"buggy_code": ["/*\n *\n * Copyright 2019 Asylo authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include \"asylo/platform/primitives/sgx/trusted_sgx.h\"\n\n#include <errno.h>\n#include <signal.h>\n#include <sys/types.h>\n\n#include <vector>\n\n#include \"absl/strings/str_cat.h\"\n#include \"asylo/enclave.pb.h\"\n#include \"asylo/util/logging.h\"\n#include \"asylo/platform/posix/signal/signal_manager.h\"\n#include \"asylo/platform/posix/threading/thread_manager.h\"\n#include \"asylo/platform/primitives/extent.h\"\n#include \"asylo/platform/primitives/primitive_status.h\"\n#include \"asylo/platform/primitives/primitives.h\"\n#include \"asylo/platform/primitives/sgx/generated_bridge_t.h\"\n#include \"asylo/platform/primitives/sgx/sgx_error_space.h\"\n#include \"asylo/platform/primitives/sgx/sgx_params.h\"\n#include \"asylo/platform/primitives/sgx/untrusted_cache_malloc.h\"\n#include \"asylo/platform/primitives/trusted_primitives.h\"\n#include \"asylo/platform/primitives/trusted_runtime.h\"\n#include \"asylo/platform/primitives/util/message.h\"\n#include \"asylo/platform/primitives/util/trusted_memory.h\"\n#include \"asylo/platform/primitives/util/trusted_runtime_helper.h\"\n#include \"asylo/platform/system_call/type_conversions/types_functions.h\"\n#include \"asylo/util/cleanup.h\"\n#include \"asylo/util/status.h\"\n#include \"asylo/util/status_macros.h\"\n#include \"include/sgx_trts.h\"\n\n#define CHECK_OCALL(status)                                                  \\\n  do {                                                                       \\\n    sgx_status_t sgx_status = status;                                        \\\n    if (sgx_status != SGX_SUCCESS) {                                         \\\n      TrustedPrimitives::BestEffortAbort(                                    \\\n          absl::StrCat(__FILE__, \":\", __LINE__, \": \",                        \\\n                       asylo::Status(sgx_status, \"ocall failed\").ToString()) \\\n              .c_str());                                                     \\\n    }                                                                        \\\n  } while (0)\n\nnamespace asylo {\nnamespace primitives {\n\nint RegisterSignalHandler(int signum,\n                          void (*klinux_sigaction)(int, klinux_siginfo_t *,\n                                                   void *),\n                          const sigset_t mask, int flags) {\n  int klinux_signum = TokLinuxSignalNumber(signum);\n  if (klinux_signum < 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  klinux_sigset_t klinux_mask;\n  TokLinuxSigset(&mask, &klinux_mask);\n  int ret;\n  CHECK_OCALL(ocall_enc_untrusted_register_signal_handler(\n      &ret, klinux_signum, reinterpret_cast<void *>(klinux_sigaction),\n      reinterpret_cast<void *>(&klinux_mask), sizeof(klinux_mask),\n      TokLinuxSignalFlag(flags)));\n  return ret;\n}\n\nint DeliverSignal(int linux_signum, int linux_sigcode) {\n  int signum = FromkLinuxSignalNumber(linux_signum);\n  if (signum < 0) {\n    return 1;\n  }\n  siginfo_t info;\n  info.si_signo = signum;\n  info.si_code = linux_sigcode;\n  SignalManager *signal_manager = SignalManager::GetInstance();\n  const sigset_t mask = signal_manager->GetSignalMask();\n\n  // If the signal is blocked and still passed into the enclave. The signal\n  // masks inside the enclave is out of sync with the untrusted signal mask.\n  if (sigismember(&mask, signum)) {\n    return -1;\n  }\n  signal_manager->HandleSignal(signum, &info, /*ucontext=*/nullptr);\n  return 0;\n}\n\npid_t InvokeFork(const char *enclave_name, bool restore_snapshot) {\n  int32_t ret;\n  sgx_status_t status =\n      ocall_enc_untrusted_fork(&ret, enclave_name, restore_snapshot);\n  if (status != SGX_SUCCESS) {\n    errno = EINTR;\n    return -1;\n  }\n  return ret;\n}\n\n// Entry handler installed by the runtime to finalize the enclave at the time it\n// is destroyed.\nPrimitiveStatus FinalizeEnclave(void *context, MessageReader *in,\n                                MessageWriter *out) {\n  if (in) {\n    ASYLO_RETURN_IF_READER_NOT_EMPTY(*in);\n  }\n  // Delete instance of the global memory pool singleton freeing all memory held\n  // by the pool.\n  delete UntrustedCacheMalloc::Instance();\n  return asylo_enclave_fini();\n}\n\n// Entry handler installed by the runtime to start the created thread.\nPrimitiveStatus DonateThread(void *context, MessageReader *in,\n                             MessageWriter *out) {\n  if (in) {\n    ASYLO_RETURN_IF_INCORRECT_READER_ARGUMENTS(*in, 1);\n  }\n  int result = 0;\n  try {\n    ThreadManager *thread_manager = ThreadManager::GetInstance();\n    result = thread_manager->StartThread(in->next<pid_t>());\n  } catch (...) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Uncaught exception in enclave entry handler: DonateThread. Failed to \"\n        \"get ThreadManager instance or start the thread.\");\n  }\n  return PrimitiveStatus(result);\n}\n\n// Registers internal handlers, including entry handlers.\nvoid RegisterInternalHandlers() {\n  // Register the enclave donate thread entry handler.\n  if (!TrustedPrimitives::RegisterEntryHandler(kSelectorAsyloDonateThread,\n                                               EntryHandler{DonateThread})\n           .ok()) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Could not register entry handler: DonateThread.\");\n  }\n\n  // Register the enclave finalization entry handler.\n  if (!TrustedPrimitives::RegisterEntryHandler(kSelectorAsyloFini,\n                                               EntryHandler{FinalizeEnclave})\n           .ok()) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Could not register entry handler: FinalizeEnclave\");\n  }\n}\n\nvoid TrustedPrimitives::BestEffortAbort(const char *message) {\n  DebugPuts(message);\n  delete UntrustedCacheMalloc::Instance();\n  enc_reject_entries();\n  MarkEnclaveAborted();\n  abort();\n}\n\nPrimitiveStatus TrustedPrimitives::RegisterEntryHandler(\n    uint64_t selector, const EntryHandler &handler) {\n  return asylo::primitives::RegisterEntryHandler(selector, handler);\n}\n\nint asylo_enclave_call(uint64_t selector, void *buffer) {\n  SgxParams *const sgx_params = reinterpret_cast<SgxParams *>(buffer);\n  if (!IsValidUntrustedAddress(sgx_params)) {\n    PrimitiveStatus status{primitives::AbslStatusCode::kInvalidArgument,\n                           \"input should lie within untrusted memory.\"};\n    return status.error_code();\n  }\n\n  const void *input = sgx_params->input;\n  size_t input_size = sgx_params->input_size;\n  size_t output_size = 0;\n\n  MessageReader in;\n  MessageWriter out;\n  // Copy untrusted input to a trusted buffer before deserializing to prevent\n  // TOC/TOU attacks.\n  auto trusted_input = CopyFromUntrusted(input, input_size);\n  if (trusted_input) {\n    in.Deserialize(trusted_input.get(), input_size);\n  }\n\n  PrimitiveStatus status = InvokeEntryHandler(selector, &in, &out);\n\n  // Serialize |out| to untrusted memory and pass that as output. The untrusted\n  // caller is still responsible for freeing |*output|, which now points to\n  // untrusted memory.\n  output_size = out.MessageSize();\n  if (out.MessageSize() > 0) {\n    // Serialize to a trusted output buffer first to prevent TOC/TOU attacks.\n    std::unique_ptr<char[]> trusted_output(new char[output_size]);\n    out.Serialize(trusted_output.get());\n    sgx_params->output = CopyToUntrusted(trusted_output.get(), output_size);\n  }\n  sgx_params->output_size = static_cast<uint64_t>(output_size);\n  return status.error_code();\n}\n\n// For SGX, UntrustedLocalAlloc uses malloc() on the untrusted host to\n// allocate memory.\nvoid *TrustedPrimitives::UntrustedLocalAlloc(size_t size) noexcept {\n  void *result;\n  CHECK_OCALL(\n      ocall_untrusted_local_alloc(&result, static_cast<uint64_t>(size)));\n  if (result && !IsOutsideEnclave(result, static_cast<uint64_t>(size))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Allocated memory not found to be outside the enclave.\");\n  }\n\n  // On error, malloc returns nullptr and sets errno to ENOMEM.\n  if (!result) {\n    errno = ENOMEM;\n    TrustedPrimitives::DebugPuts(\"UntrustedLocalAlloc on SGX failed.\");\n  }\n  return result;\n}\n\n// For SGX, UntrustedLocalFree uses free() on the untrusted host to free the\n// memory allocated by UntrustedLocalAlloc.\nvoid TrustedPrimitives::UntrustedLocalFree(void *ptr) noexcept {\n  CHECK_OCALL(ocall_untrusted_local_free(ptr));\n}\n\n// Since untrusted memory is directly accessible in SGX, we perform no pointer\n// validation before copying the memory.\nvoid *TrustedPrimitives::UntrustedLocalMemcpy(void *dest, const void *src,\n                                              size_t size) noexcept {\n  return memcpy(dest, src, size);\n}\n\nbool TrustedPrimitives::IsInsideEnclave(const void *addr, size_t size) {\n  return sgx_is_within_enclave(addr, size) == 1;\n}\n\nbool TrustedPrimitives::IsOutsideEnclave(const void *addr, size_t size) {\n  return sgx_is_outside_enclave(addr, size) == 1;\n}\n\nvoid TrustedPrimitives::DebugPuts(const char *message) {\n  int result;\n  CHECK_OCALL(ocall_untrusted_debug_puts(&result, message));\n  if (result < 0) {\n    errno = EOF;\n  }\n}\n\nPrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      // Allocate and copy data to |input_buffer|.\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->input,\n                                               sgx_params->input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->output,\n                                           sgx_params->output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    // For the results obtained in |output_buffer|, copy them to |output|\n    // before freeing the buffer.\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}\n\n// For SGX, CreateThread() needs to exit the enclave by making an UntrustedCall\n// to CreateThreadHandler, which makes an EnclaveCall to enter the enclave with\n// the new thread and register it with the thread manager and execute the\n// intended callback.\nint TrustedPrimitives::CreateThread() {\n  MessageWriter input;\n  MessageReader output;\n  PrimitiveStatus status =\n      UntrustedCall(kSelectorCreateThread, &input, &output);\n  if (!status.ok()) {\n    DebugPuts(\"CreateThread failed.\");\n    return -1;\n  }\n  if (output.size() != 1) {\n    TrustedPrimitives::BestEffortAbort(\n        \"CreateThread error: unexpected output size received.\");\n  }\n  return output.next<int>();\n}\n\nvoid **AllocateUntrustedBuffers(size_t count, size_t size) {\n  void **buffers;\n  CHECK_OCALL(ocall_enc_untrusted_allocate_buffers(\n      &buffers, static_cast<uint64_t>(count), static_cast<uint64_t>(size)));\n  if (!buffers || !TrustedPrimitives::IsOutsideEnclave(buffers, size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"allocated buffers (for use by UntrustedCacheMalloc) found to not be \"\n        \"in untrusted memory.\");\n  }\n  return buffers;\n}\n\nvoid DeAllocateUntrustedBuffers(void **free_list, size_t count) {\n  if (!IsValidUntrustedAddress(free_list)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"free_list expected to be in untrusted memory.\");\n  }\n  CHECK_OCALL(ocall_enc_untrusted_deallocate_free_list(\n      free_list, static_cast<uint64_t>(count)));\n}\n\nuint32_t enc_untrusted_ql_set_quote_config(const sgx_ql_config_t *config) {\n  uint32_t result;\n  CHECK_OCALL(ocall_enc_untrusted_ql_set_quote_config(\n      &result, config, config->cert_data_size, config->p_cert_data));\n  return result;\n}\n\nuint32_t enc_untrusted_qe_get_target_info(sgx_target_info_t *qe_target_info) {\n  uint32_t result;\n  CHECK_OCALL(ocall_enc_untrusted_qe_get_target_info(&result, qe_target_info));\n  return result;\n}\n\nuint32_t enc_untrusted_qe_get_quote_size(uint32_t *quote_size) {\n  uint32_t result;\n  CHECK_OCALL(ocall_enc_untrusted_qe_get_quote_size(&result, quote_size));\n  return result;\n}\n\nuint32_t enc_untrusted_qe_get_quote(const sgx_report_t *app_report,\n                                    uint32_t quote_size, uint8_t *quote) {\n  uint32_t result;\n  CHECK_OCALL(\n      ocall_enc_untrusted_qe_get_quote(&result, app_report, quote_size, quote));\n  return result;\n}\n\n}  // namespace primitives\n}  // namespace asylo\n"], "fixing_code": ["/*\n *\n * Copyright 2019 Asylo authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include \"asylo/platform/primitives/sgx/trusted_sgx.h\"\n\n#include <errno.h>\n#include <signal.h>\n#include <sys/types.h>\n\n#include <vector>\n\n#include \"absl/strings/str_cat.h\"\n#include \"asylo/enclave.pb.h\"\n#include \"asylo/util/logging.h\"\n#include \"asylo/platform/posix/signal/signal_manager.h\"\n#include \"asylo/platform/posix/threading/thread_manager.h\"\n#include \"asylo/platform/primitives/extent.h\"\n#include \"asylo/platform/primitives/primitive_status.h\"\n#include \"asylo/platform/primitives/primitives.h\"\n#include \"asylo/platform/primitives/sgx/generated_bridge_t.h\"\n#include \"asylo/platform/primitives/sgx/sgx_error_space.h\"\n#include \"asylo/platform/primitives/sgx/sgx_params.h\"\n#include \"asylo/platform/primitives/sgx/untrusted_cache_malloc.h\"\n#include \"asylo/platform/primitives/trusted_primitives.h\"\n#include \"asylo/platform/primitives/trusted_runtime.h\"\n#include \"asylo/platform/primitives/util/message.h\"\n#include \"asylo/platform/primitives/util/trusted_memory.h\"\n#include \"asylo/platform/primitives/util/trusted_runtime_helper.h\"\n#include \"asylo/platform/system_call/type_conversions/types_functions.h\"\n#include \"asylo/util/cleanup.h\"\n#include \"asylo/util/status.h\"\n#include \"asylo/util/status_macros.h\"\n#include \"include/sgx_trts.h\"\n\n#define CHECK_OCALL(status)                                                  \\\n  do {                                                                       \\\n    sgx_status_t sgx_status = status;                                        \\\n    if (sgx_status != SGX_SUCCESS) {                                         \\\n      TrustedPrimitives::BestEffortAbort(                                    \\\n          absl::StrCat(__FILE__, \":\", __LINE__, \": \",                        \\\n                       asylo::Status(sgx_status, \"ocall failed\").ToString()) \\\n              .c_str());                                                     \\\n    }                                                                        \\\n  } while (0)\n\nnamespace asylo {\nnamespace primitives {\n\nint RegisterSignalHandler(int signum,\n                          void (*klinux_sigaction)(int, klinux_siginfo_t *,\n                                                   void *),\n                          const sigset_t mask, int flags) {\n  int klinux_signum = TokLinuxSignalNumber(signum);\n  if (klinux_signum < 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  klinux_sigset_t klinux_mask;\n  TokLinuxSigset(&mask, &klinux_mask);\n  int ret;\n  CHECK_OCALL(ocall_enc_untrusted_register_signal_handler(\n      &ret, klinux_signum, reinterpret_cast<void *>(klinux_sigaction),\n      reinterpret_cast<void *>(&klinux_mask), sizeof(klinux_mask),\n      TokLinuxSignalFlag(flags)));\n  return ret;\n}\n\nint DeliverSignal(int linux_signum, int linux_sigcode) {\n  int signum = FromkLinuxSignalNumber(linux_signum);\n  if (signum < 0) {\n    return 1;\n  }\n  siginfo_t info;\n  info.si_signo = signum;\n  info.si_code = linux_sigcode;\n  SignalManager *signal_manager = SignalManager::GetInstance();\n  const sigset_t mask = signal_manager->GetSignalMask();\n\n  // If the signal is blocked and still passed into the enclave. The signal\n  // masks inside the enclave is out of sync with the untrusted signal mask.\n  if (sigismember(&mask, signum)) {\n    return -1;\n  }\n  signal_manager->HandleSignal(signum, &info, /*ucontext=*/nullptr);\n  return 0;\n}\n\npid_t InvokeFork(const char *enclave_name, bool restore_snapshot) {\n  int32_t ret;\n  sgx_status_t status =\n      ocall_enc_untrusted_fork(&ret, enclave_name, restore_snapshot);\n  if (status != SGX_SUCCESS) {\n    errno = EINTR;\n    return -1;\n  }\n  return ret;\n}\n\n// Entry handler installed by the runtime to finalize the enclave at the time it\n// is destroyed.\nPrimitiveStatus FinalizeEnclave(void *context, MessageReader *in,\n                                MessageWriter *out) {\n  if (in) {\n    ASYLO_RETURN_IF_READER_NOT_EMPTY(*in);\n  }\n  // Delete instance of the global memory pool singleton freeing all memory held\n  // by the pool.\n  delete UntrustedCacheMalloc::Instance();\n  return asylo_enclave_fini();\n}\n\n// Entry handler installed by the runtime to start the created thread.\nPrimitiveStatus DonateThread(void *context, MessageReader *in,\n                             MessageWriter *out) {\n  if (in) {\n    ASYLO_RETURN_IF_INCORRECT_READER_ARGUMENTS(*in, 1);\n  }\n  int result = 0;\n  try {\n    ThreadManager *thread_manager = ThreadManager::GetInstance();\n    result = thread_manager->StartThread(in->next<pid_t>());\n  } catch (...) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Uncaught exception in enclave entry handler: DonateThread. Failed to \"\n        \"get ThreadManager instance or start the thread.\");\n  }\n  return PrimitiveStatus(result);\n}\n\n// Registers internal handlers, including entry handlers.\nvoid RegisterInternalHandlers() {\n  // Register the enclave donate thread entry handler.\n  if (!TrustedPrimitives::RegisterEntryHandler(kSelectorAsyloDonateThread,\n                                               EntryHandler{DonateThread})\n           .ok()) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Could not register entry handler: DonateThread.\");\n  }\n\n  // Register the enclave finalization entry handler.\n  if (!TrustedPrimitives::RegisterEntryHandler(kSelectorAsyloFini,\n                                               EntryHandler{FinalizeEnclave})\n           .ok()) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Could not register entry handler: FinalizeEnclave\");\n  }\n}\n\nvoid TrustedPrimitives::BestEffortAbort(const char *message) {\n  DebugPuts(message);\n  delete UntrustedCacheMalloc::Instance();\n  enc_reject_entries();\n  MarkEnclaveAborted();\n  abort();\n}\n\nPrimitiveStatus TrustedPrimitives::RegisterEntryHandler(\n    uint64_t selector, const EntryHandler &handler) {\n  return asylo::primitives::RegisterEntryHandler(selector, handler);\n}\n\nint asylo_enclave_call(uint64_t selector, void *buffer) {\n  SgxParams *const sgx_params = reinterpret_cast<SgxParams *>(buffer);\n  if (!IsValidUntrustedAddress(sgx_params)) {\n    PrimitiveStatus status{primitives::AbslStatusCode::kInvalidArgument,\n                           \"input should lie within untrusted memory.\"};\n    return status.error_code();\n  }\n\n  const void *input = sgx_params->input;\n  size_t input_size = sgx_params->input_size;\n  size_t output_size = 0;\n\n  MessageReader in;\n  MessageWriter out;\n  // Copy untrusted input to a trusted buffer before deserializing to prevent\n  // TOC/TOU attacks.\n  auto trusted_input = CopyFromUntrusted(input, input_size);\n  if (trusted_input) {\n    in.Deserialize(trusted_input.get(), input_size);\n  }\n\n  PrimitiveStatus status = InvokeEntryHandler(selector, &in, &out);\n\n  // Serialize |out| to untrusted memory and pass that as output. The untrusted\n  // caller is still responsible for freeing |*output|, which now points to\n  // untrusted memory.\n  output_size = out.MessageSize();\n  if (out.MessageSize() > 0) {\n    // Serialize to a trusted output buffer first to prevent TOC/TOU attacks.\n    std::unique_ptr<char[]> trusted_output(new char[output_size]);\n    out.Serialize(trusted_output.get());\n    sgx_params->output = CopyToUntrusted(trusted_output.get(), output_size);\n  }\n  sgx_params->output_size = static_cast<uint64_t>(output_size);\n  return status.error_code();\n}\n\n// For SGX, UntrustedLocalAlloc uses malloc() on the untrusted host to\n// allocate memory.\nvoid *TrustedPrimitives::UntrustedLocalAlloc(size_t size) noexcept {\n  void *result;\n  CHECK_OCALL(\n      ocall_untrusted_local_alloc(&result, static_cast<uint64_t>(size)));\n  if (result && !IsOutsideEnclave(result, static_cast<uint64_t>(size))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Allocated memory not found to be outside the enclave.\");\n  }\n\n  // On error, malloc returns nullptr and sets errno to ENOMEM.\n  if (!result) {\n    errno = ENOMEM;\n    TrustedPrimitives::DebugPuts(\"UntrustedLocalAlloc on SGX failed.\");\n  }\n  return result;\n}\n\n// For SGX, UntrustedLocalFree uses free() on the untrusted host to free the\n// memory allocated by UntrustedLocalAlloc.\nvoid TrustedPrimitives::UntrustedLocalFree(void *ptr) noexcept {\n  CHECK_OCALL(ocall_untrusted_local_free(ptr));\n}\n\n// Since untrusted memory is directly accessible in SGX, we perform no pointer\n// validation before copying the memory.\nvoid *TrustedPrimitives::UntrustedLocalMemcpy(void *dest, const void *src,\n                                              size_t size) noexcept {\n  return memcpy(dest, src, size);\n}\n\nbool TrustedPrimitives::IsInsideEnclave(const void *addr, size_t size) {\n  return sgx_is_within_enclave(addr, size) == 1;\n}\n\nbool TrustedPrimitives::IsOutsideEnclave(const void *addr, size_t size) {\n  return sgx_is_outside_enclave(addr, size) == 1;\n}\n\nvoid TrustedPrimitives::DebugPuts(const char *message) {\n  int result;\n  CHECK_OCALL(ocall_untrusted_debug_puts(&result, message));\n  if (result < 0) {\n    errno = EOF;\n  }\n}\n\nPrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      // Allocate and copy data to |input_buffer|.\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      const void *input_pointer = sgx_params->input;\n      uint64_t input_size = sgx_params->input_size;\n      if (!TrustedPrimitives::IsOutsideEnclave(input_pointer, input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(input_pointer));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->output,\n                                           sgx_params->output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    // For the results obtained in |output_buffer|, copy them to |output|\n    // before freeing the buffer.\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}\n\n// For SGX, CreateThread() needs to exit the enclave by making an UntrustedCall\n// to CreateThreadHandler, which makes an EnclaveCall to enter the enclave with\n// the new thread and register it with the thread manager and execute the\n// intended callback.\nint TrustedPrimitives::CreateThread() {\n  MessageWriter input;\n  MessageReader output;\n  PrimitiveStatus status =\n      UntrustedCall(kSelectorCreateThread, &input, &output);\n  if (!status.ok()) {\n    DebugPuts(\"CreateThread failed.\");\n    return -1;\n  }\n  if (output.size() != 1) {\n    TrustedPrimitives::BestEffortAbort(\n        \"CreateThread error: unexpected output size received.\");\n  }\n  return output.next<int>();\n}\n\nvoid **AllocateUntrustedBuffers(size_t count, size_t size) {\n  void **buffers;\n  CHECK_OCALL(ocall_enc_untrusted_allocate_buffers(\n      &buffers, static_cast<uint64_t>(count), static_cast<uint64_t>(size)));\n  if (!buffers || !TrustedPrimitives::IsOutsideEnclave(buffers, size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"allocated buffers (for use by UntrustedCacheMalloc) found to not be \"\n        \"in untrusted memory.\");\n  }\n  return buffers;\n}\n\nvoid DeAllocateUntrustedBuffers(void **free_list, size_t count) {\n  if (!IsValidUntrustedAddress(free_list)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"free_list expected to be in untrusted memory.\");\n  }\n  CHECK_OCALL(ocall_enc_untrusted_deallocate_free_list(\n      free_list, static_cast<uint64_t>(count)));\n}\n\nuint32_t enc_untrusted_ql_set_quote_config(const sgx_ql_config_t *config) {\n  uint32_t result;\n  CHECK_OCALL(ocall_enc_untrusted_ql_set_quote_config(\n      &result, config, config->cert_data_size, config->p_cert_data));\n  return result;\n}\n\nuint32_t enc_untrusted_qe_get_target_info(sgx_target_info_t *qe_target_info) {\n  uint32_t result;\n  CHECK_OCALL(ocall_enc_untrusted_qe_get_target_info(&result, qe_target_info));\n  return result;\n}\n\nuint32_t enc_untrusted_qe_get_quote_size(uint32_t *quote_size) {\n  uint32_t result;\n  CHECK_OCALL(ocall_enc_untrusted_qe_get_quote_size(&result, quote_size));\n  return result;\n}\n\nuint32_t enc_untrusted_qe_get_quote(const sgx_report_t *app_report,\n                                    uint32_t quote_size, uint8_t *quote) {\n  uint32_t result;\n  CHECK_OCALL(\n      ocall_enc_untrusted_qe_get_quote(&result, app_report, quote_size, quote));\n  return result;\n}\n\n}  // namespace primitives\n}  // namespace asylo\n"], "filenames": ["asylo/platform/primitives/sgx/trusted_sgx.cc"], "buggy_code_start_loc": [284], "buggy_code_end_loc": [290], "fixing_code_start_loc": [284], "fixing_code_end_loc": [291], "type": "CWE-668", "message": "An attacker can modify the address to point to trusted memory to overwrite arbitrary trusted memory. It is recommended to update past 0.6.2 or git commit https://github.com/google/asylo/commit/53ed5d8fd8118ced1466e509606dd2f473707a5c", "other": {"cve": {"id": "CVE-2021-22549", "sourceIdentifier": "cve-coordination@google.com", "published": "2021-06-08T14:15:07.747", "lastModified": "2022-10-25T16:16:17.173", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An attacker can modify the address to point to trusted memory to overwrite arbitrary trusted memory. It is recommended to update past 0.6.2 or git commit https://github.com/google/asylo/commit/53ed5d8fd8118ced1466e509606dd2f473707a5c"}, {"lang": "es", "value": "Un atacante puede modificar la direcci\u00f3n para que apunte a la memoria confiable para sobrescribir la memoria confiable arbitraria. Se recomienda actualizar a partir de la versi\u00f3n 0.6.2 o del commit de git https://github.com/google/asylo/commit/53ed5d8fd8118ced1466e509606dd2f473707a5c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-823"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:asylo:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.2", "matchCriteriaId": "2615C1EA-2906-4CF3-ADD5-D4719F441060"}]}]}], "references": [{"url": "https://github.com/google/asylo/commit/ecfcd0008b6f8f63c6fa3cc1b62fcd4a52f2c0ad", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/google/asylo/commit/ecfcd0008b6f8f63c6fa3cc1b62fcd4a52f2c0ad"}}