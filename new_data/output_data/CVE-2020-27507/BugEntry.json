{"buggy_code": ["/*\n * message printing\n *\n * Copyright (C) 2001-2003 FhG Fokus\n *\n * This file is part of Kamailio, a free SIP server.\n *\n * Kamailio is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * Kamailio is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n\n#ifdef EXTRA_DEBUG\n#include <assert.h>\n#endif\n#include \"../../core/comp_defs.h\"\n#include \"../../core/hash_func.h\"\n#include \"../../core/globals.h\"\n#include \"t_funcs.h\"\n#include \"../../core/dprint.h\"\n#include \"../../core/config.h\"\n#include \"../../core/parser/parser_f.h\"\n#include \"../../core/parser/parse_to.h\"\n#include \"../../core/ut.h\"\n#include \"../../core/srapi.h\"\n#include \"../../core/parser/msg_parser.h\"\n#include \"../../core/parser/contact/parse_contact.h\"\n#include \"lw_parser.h\"\n#include \"t_msgbuilder.h\"\n#include \"uac.h\"\n#ifdef USE_DNS_FAILOVER\n#include \"../../core/dns_cache.h\"\n#include \"../../core/cfg_core.h\" /* cfg_get(core, core_cfg, use_dns_failover) */\n#endif\n\n\n/* convenience macros */\n#define memapp(_d,_s,_len) \\\n\tdo{\\\n\t\tmemcpy((_d),(_s),(_len));\\\n\t\t(_d) += (_len);\\\n\t}while(0)\n\n\n/* Build a local request based on a previous request; main\n * customers of this function are local ACK and local CANCEL\n */\nchar *build_local(struct cell *Trans,unsigned int branch,\n\tunsigned int *len, char *method, int method_len, str *to\n\t, struct cancel_reason* reason\n\t)\n{\n\tchar                *cancel_buf, *p, *via;\n\tunsigned int         via_len;\n\tstruct hdr_field    *hdr;\n\tchar branch_buf[MAX_BRANCH_PARAM_LEN];\n\tint branch_len;\n\tstr branch_str;\n\tstr via_id;\n\tstruct hostport hp;\n\tint reason_len, code_len;\n\tstruct hdr_field *reas1, *reas_last;\n\n\t/* init */\n\tvia_id.s=0;\n\tvia_id.len=0;\n\n\t/* method, separators, version: \"CANCEL sip:p2@iptel.org SIP/2.0\" */\n\t*len=SIP_VERSION_LEN + method_len + 2 /* spaces */ + CRLF_LEN;\n\t*len+=Trans->uac[branch].uri.len;\n\n\t/*via*/\n\tif (!t_calc_branch(Trans,  branch,\n\t\tbranch_buf, &branch_len ))\n\t\tgoto error;\n\tbranch_str.s=branch_buf;\n\tbranch_str.len=branch_len;\n\tset_hostport(&hp, (is_local(Trans))?0:(Trans->uas.request));\n#ifdef USE_TCP\n\tif (!is_local(Trans) && ((Trans->uas.request->rcv.proto==PROTO_TCP)\n#ifdef USE_TLS\n\t\t\t\t|| (Trans->uas.request->rcv.proto==PROTO_TLS)\n#endif /* USE_TLS */\n\t\t)){\n\t\tif ((via_id.s=id_builder(Trans->uas.request,\n\t\t\t\t\t\t\t\t\t(unsigned int*)&via_id.len))==0){\n\t\t\tLM_ERR(\"id builder failed\\n\");\n\t\t\t/* try to continue without id */\n\t\t}\n\t}\n#endif /* USE_TCP */\n\tvia=via_builder(&via_len, NULL, &Trans->uac[branch].request.dst,\n\t\t&branch_str, via_id.s?&via_id:0 , &hp );\n\n\t/* via_id.s not needed anylonger => free it */\n\tif (via_id.s) {\n\t\tpkg_free(via_id.s);\n\t\tvia_id.s=0;\n\t\tvia_id.len=0;\n\t}\n\n\tif (!via) {\n\t\tLM_ERR(\"no via header got from builder\\n\");\n\t\tgoto error;\n\t}\n\t*len+= via_len;\n\t/*headers*/\n\t*len+=Trans->from.len+Trans->callid.len+to->len+\n\t\t+Trans->cseq_n.len+1+method_len+CRLF_LEN+MAXFWD_HEADER_LEN;\n\n\n\t/* copy'n'paste Route headers */\n\tif (!is_local(Trans)) {\n\t\tfor ( hdr=Trans->uas.request->headers ; hdr ; hdr=hdr->next )\n\t\t\tif (hdr->type==HDR_ROUTE_T)\n\t\t\t\t*len+=hdr->len;\n\t}\n\n\t/* User Agent */\n\tif (server_signature) {\n\t\t*len += user_agent_hdr.len + CRLF_LEN;\n\t}\n\t/* Content Length, EoM */\n\t*len+=CONTENT_LENGTH_LEN+1 + CRLF_LEN;\n\treason_len = 0;\n\treas1 = 0;\n\treas_last = 0;\n\t/* compute reason size (if no reason or disabled => reason_len == 0)*/\n\tif (reason && reason->cause != CANCEL_REAS_UNKNOWN){\n\t\tif (likely(reason->cause > 0 &&\n\t\t\t\t\tcfg_get(tm, tm_cfg, local_cancel_reason))){\n\t\t\t/* Reason: SIP;cause=<reason->cause>[;text=<reason->u.text.s>] */\n\t\t\treason_len = REASON_PREFIX_LEN + USHORT2SBUF_MAX_LEN +\n\t\t\t\t(reason->u.text.s?\n\t\t\t\t\tREASON_TEXT_LEN + 1 + reason->u.text.len + 1 : 0) +\n\t\t\t\tCRLF_LEN;\n\t\t} else if (likely(reason->cause == CANCEL_REAS_PACKED_HDRS &&\n\t\t\t\t\t!(Trans->flags & T_NO_E2E_CANCEL_REASON))) {\n\t\t\treason_len = reason->u.packed_hdrs.len;\n\t\t} else if (reason->cause == CANCEL_REAS_RCVD_CANCEL &&\n\t\t\t\t\treason->u.e2e_cancel &&\n\t\t\t\t\t!(Trans->flags & T_NO_E2E_CANCEL_REASON)) {\n\t\t\t/* parse the entire cancel, to get all the Reason headers */\n\t\t\tif(parse_headers(reason->u.e2e_cancel, HDR_EOH_F, 0)<0) {\n\t\t\t\tLM_WARN(\"failed to parse headers\\n\");\n\t\t\t}\n\t\t\tfor(hdr=get_hdr(reason->u.e2e_cancel, HDR_REASON_T), reas1=hdr;\n\t\t\t\t\thdr; hdr=next_sibling_hdr(hdr)) {\n\t\t\t\t/* hdr->len includes CRLF */\n\t\t\t\treason_len += hdr->len;\n\t\t\t\treas_last=hdr;\n\t\t\t}\n\t\t} else if (unlikely(reason->cause < CANCEL_REAS_MIN))\n\t\t\tLM_BUG(\"unhandled reason cause %d\\n\", reason->cause);\n\t}\n\t*len+= reason_len;\n\t*len+= CRLF_LEN; /* end of msg. */\n\n\tcancel_buf=shm_malloc( *len+1 );\n\tif (!cancel_buf) {\n\t\tSHM_MEM_ERROR;\n\t\tgoto error01;\n\t}\n\tp = cancel_buf;\n\n\tappend_str( p, method, method_len );\n\tappend_str( p, \" \", 1 );\n\tappend_str( p, Trans->uac[branch].uri.s, Trans->uac[branch].uri.len);\n\tappend_str( p, \" \" SIP_VERSION CRLF, 1+SIP_VERSION_LEN+CRLF_LEN );\n\n\t/* insert our via */\n\tappend_str(p,via,via_len);\n\n\t/*other headers*/\n\tappend_str( p, Trans->from.s, Trans->from.len );\n\tappend_str( p, Trans->callid.s, Trans->callid.len );\n\tappend_str( p, to->s, to->len );\n\n\tappend_str( p, Trans->cseq_n.s, Trans->cseq_n.len );\n\tappend_str( p, \" \", 1 );\n\tappend_str( p, method, method_len );\n\tappend_str( p, CRLF, CRLF_LEN );\n\tappend_str( p, MAXFWD_HEADER, MAXFWD_HEADER_LEN );\n\n\tif (!is_local(Trans))  {\n\t\tfor ( hdr=Trans->uas.request->headers ; hdr ; hdr=hdr->next )\n\t\t\tif(hdr->type==HDR_ROUTE_T) {\n\t\t\t\tappend_str(p, hdr->name.s, hdr->len );\n\t\t\t}\n\t}\n\n\t/* User Agent header */\n\tif (server_signature) {\n\t\tappend_str(p, user_agent_hdr.s, user_agent_hdr.len );\n\t\tappend_str(p, CRLF, CRLF_LEN );\n\t}\n\t/* Content Length */\n\tappend_str(p, CONTENT_LENGTH \"0\" CRLF, CONTENT_LENGTH_LEN + 1 + CRLF_LEN);\n\t/* add reason if needed */\n\tif (reason_len) {\n\t\tif (likely(reason->cause > 0)) {\n\t\t\tappend_str(p, REASON_PREFIX, REASON_PREFIX_LEN);\n\t\t\tcode_len=ushort2sbuf(reason->cause, p,\n\t\t\t\t\t\t\t\t\t*len-(int)(p-cancel_buf));\n\t\t\tif (unlikely(code_len==0))\n\t\t\t\tLM_BUG(\"not enough space to write reason code\");\n\t\t\tp+=code_len;\n\t\t\tif (reason->u.text.s){\n\t\t\t\tappend_str(p, REASON_TEXT, REASON_TEXT_LEN);\n\t\t\t\t*p='\"'; p++;\n\t\t\t\tappend_str(p, reason->u.text.s, reason->u.text.len);\n\t\t\t\t*p='\"'; p++;\n\t\t\t}\n\t\t\tappend_str(p, CRLF, CRLF_LEN);\n\t\t} else if (likely(reason->cause == CANCEL_REAS_PACKED_HDRS)) {\n\t\t\tappend_str(p, reason->u.packed_hdrs.s, reason->u.packed_hdrs.len);\n\t\t} else if (reason->cause == CANCEL_REAS_RCVD_CANCEL) {\n\t\t\tfor(hdr=reas1; hdr; hdr=next_sibling_hdr(hdr)) {\n\t\t\t\t/* hdr->len includes CRLF */\n\t\t\t\tappend_str(p, hdr->name.s, hdr->len);\n\t\t\t\tif (likely(hdr==reas_last))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tappend_str(p, CRLF, CRLF_LEN); /* msg. end */\n\t*p=0;\n\n\tpkg_free(via);\n\treturn cancel_buf;\nerror01:\n\tpkg_free(via);\nerror:\n\treturn NULL;\n}\n\n/* Re-parsing version of build_local() function:\n * it builds a local CANCEL or ACK (for non-200 response) request based on\n * the previous INVITE which was sent out.\n *\n * Can not be used to build other type of requests!\n */\nchar *build_local_reparse(tm_cell_t *Trans,unsigned int branch,\n\tunsigned int *len, char *method, int method_len, str *to\n\t, struct cancel_reason *reason\n\t)\n{\n\tchar\t*invite_buf, *invite_buf_end;\n\tchar\t*cancel_buf;\n\tchar\t*s, *s1, *d;\t/* source and destination buffers */\n\tshort\tinvite_len;\n\tenum _hdr_types_t\thf_type;\n\tint\tfirst_via, to_len;\n\tint cancel_buf_len;\n\tint reason_len, code_len;\n\tstruct hdr_field *reas1, *reas_last, *hdr;\n\tint hadded = 0;\n\tsr_cfgenv_t *cenv = NULL;\n\n\tinvite_buf = Trans->uac[branch].request.buffer;\n\tinvite_len = Trans->uac[branch].request.buffer_len;\n\n\tif (!invite_buf || invite_len<=0) {\n\t\tLM_ERR(\"INVITE is missing\\n\");\n\t\tgoto error;\n\t}\n\tif ((*invite_buf != 'I') && (*invite_buf != 'i')) {\n\t\tLM_ERR(\"trying to build with local reparse\"\n\t\t\t\t\t\" for a non-INVITE request?\\n\");\n\t\tgoto error;\n\t}\n\n\treason_len = 0;\n\treas1 = 0;\n\treas_last = 0;\n\t/* compute reason size (if no reason or disabled => reason_len == 0)*/\n\tif (reason && reason->cause != CANCEL_REAS_UNKNOWN){\n\t\tif (likely(reason->cause > 0 &&\n\t\t\t\t\tcfg_get(tm, tm_cfg, local_cancel_reason))){\n\t\t\t/* Reason: SIP;cause=<reason->cause>[;text=<reason->u.text.s>] */\n\t\t\treason_len = REASON_PREFIX_LEN + USHORT2SBUF_MAX_LEN +\n\t\t\t\t(reason->u.text.s?\n\t\t\t\t\tREASON_TEXT_LEN + 1 + reason->u.text.len + 1 : 0) +\n\t\t\t\tCRLF_LEN;\n\t\t} else if (likely(reason->cause == CANCEL_REAS_PACKED_HDRS &&\n\t\t\t\t\t!(Trans->flags & T_NO_E2E_CANCEL_REASON))) {\n\t\t\treason_len = reason->u.packed_hdrs.len;\n\t\t} else if (reason->cause == CANCEL_REAS_RCVD_CANCEL &&\n\t\t\t\t\treason->u.e2e_cancel &&\n\t\t\t\t\t!(Trans->flags & T_NO_E2E_CANCEL_REASON)) {\n\t\t\t/* parse the entire cancel, to get all the Reason headers */\n\t\t\tif(parse_headers(reason->u.e2e_cancel, HDR_EOH_F, 0)<0) {\n\t\t\t\tLM_WARN(\"failed to parse headers\\n\");\n\t\t\t}\n\t\t\tfor(hdr=get_hdr(reason->u.e2e_cancel, HDR_REASON_T), reas1=hdr;\n\t\t\t\t\thdr; hdr=next_sibling_hdr(hdr)) {\n\t\t\t\t/* hdr->len includes CRLF */\n\t\t\t\treason_len += hdr->len;\n\t\t\t\treas_last=hdr;\n\t\t\t}\n\t\t} else if (unlikely(reason->cause < CANCEL_REAS_MIN))\n\t\t\tLM_BUG(\"unhandled reason cause %d\\n\", reason->cause);\n\t}\n\n\tinvite_buf_end = invite_buf + invite_len;\n\ts = invite_buf;\n\n\t/* Allocate memory for the new message.\n\tThe new request will be smaller than the INVITE, so the same size is enough.\n\tI just extend it with the length of new To HF to be sure.\n\tUgly, but we avoid lots of checks and memory allocations this way */\n\tto_len = to ? to->len : 0;\n\tcancel_buf_len = invite_len + to_len + reason_len;\n\n\tcancel_buf = shm_malloc(sizeof(char)*cancel_buf_len);\n\tif (!cancel_buf)\n\t{\n\t\tSHM_MEM_ERROR;\n\t\tgoto error;\n\t}\n\td = cancel_buf;\n\n\t/* method name + space */\n\tappend_str(d, method, method_len);\n\t*d = ' ';\n\td++;\n\t/* skip \"INVITE \" and copy the rest of the line including CRLF */\n\ts += 7;\n\ts1 = s;\n\ts = eat_line(s, invite_buf_end - s);\n\tappend_str(d, s1, s - s1);\n\n\tcenv = sr_cfgenv_get();\n\n\t/* check every header field name,\n\twe must exclude and modify some of the headers */\n\tfirst_via = 1;\n\twhile (s < invite_buf_end) {\n\t\ts1 = s;\n\t\tif ((*s == '\\n') || (*s == '\\r')) {\n\t\t\t/* end of SIP msg */\n\t\t\thf_type = HDR_EOH_T;\n\t\t} else {\n\t\t\t/* parse HF name */\n\t\t\ts = lw_get_hf_name(s, invite_buf_end,\n\t\t\t\t\t\t&hf_type);\n\t\t}\n\n\t\tswitch(hf_type) {\n\t\t\tcase HDR_CSEQ_T:\n\t\t\t\t/* find the method name and replace it */\n\t\t\t\twhile ((s < invite_buf_end)\n\t\t\t\t\t&& ((*s == ':') || (*s == ' ') || (*s == '\\t') ||\n\t\t\t\t\t\t((*s >= '0') && (*s <= '9')))\n\t\t\t\t\t) s++;\n\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\tappend_str(d, method, method_len);\n\t\t\t\tappend_str(d, CRLF, CRLF_LEN);\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\tbreak;\n\n\t\t\tcase HDR_VIA_T:\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\tif (first_via) {\n\t\t\t\t\t/* copy hf */\n\t\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\t\tfirst_via = 0;\n\t\t\t\t} /* else skip this line, we need olny the first via */\n\t\t\t\tbreak;\n\n\t\t\tcase HDR_TO_T:\n\t\t\t\tif (to_len == 0) {\n\t\t\t\t\t/* there is no To tag required, just copy paste\n\t\t\t\t\t * the header */\n\t\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\t} else {\n\t\t\t\t\t/* use the given To HF instead of the original one */\n\t\t\t\t\tappend_str(d, to->s, to->len);\n\t\t\t\t\t/* move the pointer to the next line */\n\t\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase HDR_FROM_T:\n\t\t\tcase HDR_CALLID_T:\n\t\t\tcase HDR_ROUTE_T:\n\t\t\tcase HDR_MAXFORWARDS_T:\n\t\t\t\t/* copy hf */\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\tbreak;\n\n\t\t\tcase HDR_REQUIRE_T:\n\t\t\tcase HDR_PROXYREQUIRE_T:\n\t\t\t\t/* skip this line */\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\tbreak;\n\n\t\t\tcase HDR_CONTENTLENGTH_T:\n\t\t\t\t/* copy hf name with 0 value */\n\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\tappend_str(d, \": 0\" CRLF, 3 + CRLF_LEN);\n\t\t\t\t/* move the pointer to the next line */\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\tbreak;\n\n\t\t\tcase HDR_EOH_T:\n\t\t\t\t/* end of SIP message found */\n\t\t\t\t/* add reason if needed */\n\t\t\t\tif (reason_len) {\n\t\t\t\t\t/* if reason_len !=0, no need for any reason enabled\n\t\t\t\t\t * checks */\n\t\t\t\t\tif (likely(reason->cause > 0)) {\n\t\t\t\t\t\tappend_str(d, REASON_PREFIX, REASON_PREFIX_LEN);\n\t\t\t\t\t\tcode_len=ushort2sbuf(reason->cause, d,\n\t\t\t\t\t\t\t\t\t\tcancel_buf_len-(int)(d-cancel_buf));\n\t\t\t\t\t\tif (unlikely(code_len==0))\n\t\t\t\t\t\t\tLM_BUG(\"not enough space to write reason code\");\n\t\t\t\t\t\td+=code_len;\n\t\t\t\t\t\tif (reason->u.text.s){\n\t\t\t\t\t\t\tappend_str(d, REASON_TEXT, REASON_TEXT_LEN);\n\t\t\t\t\t\t\t*d='\"'; d++;\n\t\t\t\t\t\t\tappend_str(d, reason->u.text.s,\n\t\t\t\t\t\t\t\t\t\t\treason->u.text.len);\n\t\t\t\t\t\t\t*d='\"'; d++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tappend_str(d, CRLF, CRLF_LEN);\n\t\t\t\t\t} else if (likely(reason->cause ==\n\t\t\t\t\t\t\t\t\t\tCANCEL_REAS_PACKED_HDRS)) {\n\t\t\t\t\t\t\tappend_str(d, reason->u.packed_hdrs.s,\n\t\t\t\t\t\t\t\t\t\t\treason->u.packed_hdrs.len);\n\t\t\t\t\t} else if (reason->cause == CANCEL_REAS_RCVD_CANCEL) {\n\t\t\t\t\t\tfor(hdr=reas1; hdr; hdr=next_sibling_hdr(hdr)) {\n\t\t\t\t\t\t\t/* hdr->len includes CRLF */\n\t\t\t\t\t\t\tappend_str(d, hdr->name.s, hdr->len);\n\t\t\t\t\t\t\tif (likely(hdr==reas_last))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* final (end-of-headers) CRLF */\n\t\t\t\tappend_str(d, CRLF, CRLF_LEN);\n\t\t\t\t*len = d - cancel_buf;\n\t\t\t\t/* LOG(L_DBG, \"DBG: build_local: %.*s\\n\", *len, cancel_buf); */\n\t\t\t\treturn cancel_buf;\n\n\t\t\tdefault:\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\thadded = 0;\n\n\t\t\t\t/* uac auth headers */\n\t\t\t\tif(Trans->uas.request &&\n\t\t\t\t\t\t(Trans->uas.request->msg_flags & FL_UAC_AUTH)) {\n\t\t\t\t\tif(s1 + cenv->uac_cseq_auth.len + 2 < invite_buf_end) {\n\t\t\t\t\t\tif(s1[cenv->uac_cseq_auth.len]==':'\n\t\t\t\t\t\t\t\t&& strncmp(s1, cenv->uac_cseq_auth.s,\n\t\t\t\t\t\t\t\t\tcenv->uac_cseq_auth.len)==0) {\n\t\t\t\t\t\t\thadded = 1;\n\t\t\t\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\t\t\t} else if(s1[cenv->uac_cseq_refresh.len]==':'\n\t\t\t\t\t\t\t\t&& strncmp(s1, cenv->uac_cseq_refresh.s,\n\t\t\t\t\t\t\t\t\tcenv->uac_cseq_refresh.len)==0) {\n\t\t\t\t\t\t\thadded = 1;\n\t\t\t\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(likely(hadded==0)) {\n\t\t\t\t\tif (cfg_get(tm, tm_cfg, ac_extra_hdrs).len\n\t\t\t\t\t\t\t&& (s1 + cfg_get(tm, tm_cfg, ac_extra_hdrs).len < invite_buf_end)\n\t\t\t\t\t\t\t&& (strncasecmp(s1,\n\t\t\t\t\t\t\t\t\tcfg_get(tm, tm_cfg, ac_extra_hdrs).s,\n\t\t\t\t\t\t\t\t\tcfg_get(tm, tm_cfg, ac_extra_hdrs).len) == 0)) {\n\t\t\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* HDR_EOH_T was not found in the buffer, the message is corrupt */\n\tLM_ERR(\"HDR_EOH_T was not found\\n\");\n\n\tshm_free(cancel_buf);\nerror:\n\tLM_ERR(\"cannot build %.*s request\\n\", method_len, method);\n\treturn NULL;\n\n}\n\n\ntypedef struct rte {\n\trr_t* ptr;\n\t/* 'ptr' above doesn't point to a mem chunk linked to a sip_msg, so it\n\t * won't be free'd along with it => it must be free'd \"manually\" */\n\tint free_rr;\n\tstruct rte* next;\n} rte_t;\n\n\nstatic inline void free_rte_list(struct rte* list)\n{\n\tstruct rte* ptr;\n\n\twhile(list) {\n\t\tptr = list;\n\t\tlist = list->next;\n\t\tif (ptr->free_rr)\n\t\t\tfree_rr(&ptr->ptr);\n\t\tpkg_free(ptr);\n\t}\n}\n\n\nstatic inline int calc_routeset_len(struct rte* list, str* contact)\n{\n\tstruct rte* ptr;\n\tint ret;\n\n\tif (list || contact) {\n\t\tret = ROUTE_PREFIX_LEN + CRLF_LEN;\n\t} else {\n\t\treturn 0;\n\t}\n\n\tptr = list;\n\twhile(ptr) {\n\t\tif (ptr != list) {\n\t\t\tret += ROUTE_SEPARATOR_LEN;\n\t\t}\n\t\tret += ptr->ptr->len;\n\t\tptr = ptr->next;\n\t}\n\n\tif (contact) {\n\t\tif (list) ret += ROUTE_SEPARATOR_LEN;\n\t\tret += 2 + contact->len;\n\t}\n\n\treturn ret;\n}\n\n\n/*\n * Print the route set\n */\nstatic inline char* print_rs(char* p, struct rte* list, str* contact)\n{\n\tstruct rte* ptr;\n\n\tif (list || contact) {\n\t\tmemapp(p, ROUTE_PREFIX, ROUTE_PREFIX_LEN);\n\t} else {\n\t\treturn p;\n\t}\n\n\tptr = list;\n\twhile(ptr) {\n\t\tif (ptr != list) {\n\t\t\tmemapp(p, ROUTE_SEPARATOR, ROUTE_SEPARATOR_LEN);\n\t\t}\n\n\t\tmemapp(p, ptr->ptr->nameaddr.name.s, ptr->ptr->len);\n\t\tptr = ptr->next;\n\t}\n\n\tif (contact) {\n\t\tif (list) memapp(p, ROUTE_SEPARATOR, ROUTE_SEPARATOR_LEN);\n\t\t*p++ = '<';\n\t\tappend_str(p, contact->s, contact->len);\n\t\t*p++ = '>';\n\t}\n\n\tmemapp(p, CRLF, CRLF_LEN);\n\treturn p;\n}\n\n\n/*\n * Parse Contact header field body and extract URI\n * Does not parse headers !\n */\nstatic inline int get_contact_uri(struct sip_msg* msg, str* uri)\n{\n\tcontact_t* c;\n\n\turi->len = 0;\n\tif (!msg->contact) return 1;\n\n\tif (parse_contact(msg->contact) < 0) {\n\t\tLM_ERR(\"error while parsing Contact body\\n\");\n\t\treturn -1;\n\t}\n\n\tc = ((contact_body_t*)msg->contact->parsed)->contacts;\n\n\tif (!c) {\n\t\tLM_ERR(\"empty body or * contact\\n\");\n\t\treturn -2;\n\t}\n\n\t*uri = c->uri;\n\treturn 0;\n}\n\n/**\n * Extract route set from the message (out of Record-Route, if reply, OR\n * Route, if request).\n * The route set is returned into the \"UAC-format\" (keep order for Rs, reverse\n * RRs).\n */\nstatic inline int get_uac_rs(sip_msg_t *msg, int is_req, struct rte **rtset)\n{\n\tstruct hdr_field* ptr;\n\trr_t *p, *new_p;\n\tstruct rte *t, *head, *old_head;\n\n\thead = 0;\n\tfor (ptr = is_req ? msg->route : msg->record_route; ptr; ptr = ptr->next) {\n\t\tswitch (ptr->type) {\n\t\t\tcase HDR_RECORDROUTE_T:\n\t\t\t\tif (is_req)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tcase HDR_ROUTE_T:\n\t\t\t\tif (! is_req)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (parse_rr(ptr) < 0) {\n\t\t\tLM_ERR(\"failed to parse Record-/Route HF (%d).\\n\", ptr->type);\n\t\t\tgoto err;\n\t\t}\n\n\t\tp = (rr_t*)ptr->parsed;\n\t\twhile(p) {\n\t\t\tif (! (t = pkg_malloc(sizeof(struct rte)))) {\n\t\t\t\tPKG_MEM_ERROR_FMT(\"(asked for: %d).\\n\",\n\t\t\t\t\t\t(int)sizeof(struct rte));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (is_req) {\n\t\t\t\t/* in case of requests, the sip_msg structure is free'd before\n\t\t\t\t * rte list is evaluated => must do a copy of it */\n\t\t\t\tif (duplicate_rr(&new_p, p) < 0) {\n\t\t\t\t\tpkg_free(t);\n\t\t\t\t\tLM_ERR(\"failed to duplicate RR\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tt->ptr = new_p;\n\t\t\t} else {\n\t\t\t\tt->ptr = p;\n\t\t\t}\n\t\t\tt->free_rr = is_req;\n\t\t\tt->next = head;\n\t\t\thead = t;\n\t\t\tp = p->next;\n\t\t}\n\t}\n\n\tif (is_req) {\n\t\t/* harvesting the R/RR HF above inserts at head, which suites RRs (as\n\t\t * they must be reversed, anyway), but not Rs => reverse once more */\n\t\told_head = head;\n\t\thead = 0;\n\t\twhile (old_head) {\n\t\t\tt = old_head;\n\t\t\told_head = old_head->next;\n\t\t\tt->next = head;\n\t\t\thead = t;\n\t\t}\n\t}\n\n\t*rtset = head;\n\treturn 0;\nerr:\n\tfree_rte_list(head);\n\treturn -1;\n}\n\n\nstatic inline unsigned short uri2port(const struct sip_uri *puri)\n{\n\tif (puri->port.s) {\n\t\treturn puri->port_no;\n\t} else switch (puri->type) {\n\t\tcase SIP_URI_T:\n\t\tcase TEL_URI_T:\n\t\t\tif (puri->transport_val.len == sizeof(\"TLS\") - 1) {\n\t\t\t\tunsigned trans;\n\t\t\t\ttrans = puri->transport_val.s[0] | 0x20; trans <<= 8;\n\t\t\t\ttrans |= puri->transport_val.s[1] | 0x20; trans <<= 8;\n\t\t\t\ttrans |= puri->transport_val.s[2] | 0x20;\n\t\t\t\tif (trans == 0x746C73) /* t l s */\n\t\t\t\t\treturn SIPS_PORT;\n\t\t\t}\n\t\t\treturn SIP_PORT;\n\t\tcase SIPS_URI_T:\n\t\tcase TELS_URI_T:\n\t\t\treturn SIPS_PORT;\n\t\tdefault:\n\t\t\tLM_BUG(\"unexpected URI type %d.\\n\", puri->type);\n\t}\n\treturn 0;\n}\n\n/**\n * Evaluate if next hop is a strict or loose router, by looking at the\n * retr. buffer of the original INVITE.\n * Assumes:\n * \torig_inv is a parsed SIP message;\n * \trtset is not NULL.\n * @return:\n * \tF_RB_NH_LOOSE : next hop was loose router;\n * \tF_RB_NH_STRICT: nh is strict;\n * \t0 on error.\n */\nstatic unsigned long nhop_type(sip_msg_t *orig_inv, rte_t *rtset,\n\t\tconst struct dest_info *dst_inv, str *contact)\n{\n\tstruct sip_uri puri, topr_uri, lastr_uri, inv_ruri, cont_uri;\n\tstruct ip_addr *uri_ia;\n\tunion sockaddr_union uri_sau;\n\tunsigned int uri_port, dst_port, inv_port, cont_port, lastr_port;\n\trte_t *last_r;\n#ifdef TM_LOC_ACK_DO_REV_DNS\n\tstruct ip_addr ia;\n\tstruct hostent *he;\n\tchar **alias;\n#endif\n\n#define PARSE_URI(_str_, _uri_) \\\n\tdo { \\\n\t\t/* parse_uri() 0z the puri */ \\\n\t\tif (parse_uri((_str_)->s, \\\n\t\t\t\t(_str_)->len, _uri_) < 0) { \\\n\t\t\tLM_ERR(\"failed to parse route body '%.*s'.\\n\", STR_FMT(_str_)); \\\n\t\t\treturn 0; \\\n\t\t} \\\n\t} while (0)\n\n#define HAS_LR(_rte_) \\\n\t({ \\\n\t\tPARSE_URI(&(_rte_)->ptr->nameaddr.uri, &puri); \\\n\t\tpuri.lr.s; \\\n\t})\n\n#define URI_PORT(_puri_, _port) \\\n\tdo { \\\n\t\tif (! (_port = uri2port(_puri_))) \\\n\t\t\treturn 0; \\\n\t} while (0)\n\n\t/* examine the easy/fast & positive cases foremost */\n\n\t/* [1] check if 1st route lacks ;lr */\n\tLM_DBG(\"checking lack of ';lr' in 1st route.\\n\");\n\tif (! HAS_LR(rtset))\n\t\treturn F_RB_NH_STRICT;\n\ttopr_uri = puri; /* save 1st route's URI */\n\n\t/* [2] check if last route shows ;lr */\n\tLM_DBG(\"checking presence of ';lr' in last route.\\n\");\n\tfor (last_r = rtset; last_r->next; last_r = last_r->next)\n\t\t/* scroll down to last route */\n\t\t;\n\tif (HAS_LR(last_r))\n\t\treturn F_RB_NH_LOOSE;\n\n\t/* [3] 1st route has ;lr -> check if the destination of original INV\n\t * equals the address provided by this route; if does -> loose */\n\tLM_DBG(\"checking INVITE's destination against its first route.\\n\");\n\tURI_PORT(&topr_uri, uri_port);\n\tif (! (dst_port = su_getport(&dst_inv->to)))\n\t\treturn 0; /* not really expected */\n\tif (dst_port != uri_port)\n\t\treturn F_RB_NH_STRICT;\n\t/* if 1st route contains an IP address, comparing it against .dst */\n\tif ((uri_ia = str2ip(&topr_uri.host))\n\t\t\t|| (uri_ia = str2ip6(&topr_uri.host))\n\t\t\t) {\n\t\t/* we have an IP address in route -> comparison can go swiftly */\n\t\tif (init_su(&uri_sau, uri_ia, uri_port) < 0)\n\t\t\treturn 0; /* not really expected */\n\t\tif (su_cmp(&uri_sau, &dst_inv->to))\n\t\t\t/* ;lr and sent there */\n\t\t\treturn F_RB_NH_LOOSE;\n\t\telse\n\t\t\t/* ;lr and NOT sent there (probably sent to RURI address) */\n\t\t\treturn F_RB_NH_STRICT;\n\t} else {\n\t\t/*if 1st route contains a name, rev resolve the .dst and compare*/\n\t\tLM_INFO(\"Failed to decode string '%.*s' in route set element as IP\"\n\t\t\t\t\" address. Trying name resolution.\\n\",STR_FMT(&topr_uri.host));\n\n\t/* TODO: alternatively, rev name and compare against dest. IP.  */\n#ifdef TM_LOC_ACK_DO_REV_DNS\n\t\tia.af = 0;\n\t\tsu2ip_addr(&ia, (void *)&dst_inv->to);\n\t\tif (! ia.af)\n\t\t\treturn 0; /* not really expected */\n\t\tif ((he = rev_resolvehost(&ia))) {\n\t\t\tif ((strlen(he->h_name) == topr_uri.host.len) &&\n\t\t\t\t\t(memcmp(he->h_name, topr_uri.host.s,\n\t\t\t\t\t\t\ttopr_uri.host.len) == 0))\n\t\t\t\treturn F_RB_NH_LOOSE;\n\t\t\tfor (alias = he->h_aliases; *alias; alias ++)\n\t\t\t\tif ((strlen(*alias) == topr_uri.host.len) &&\n\t\t\t\t\t\t(memcmp(*alias, topr_uri.host.s,\n\t\t\t\t\t\t\t\ttopr_uri.host.len) == 0))\n\t\t\t\t\treturn F_RB_NH_LOOSE;\n\t\t\treturn F_RB_NH_STRICT;\n\t\t} else {\n\t\t\tLM_INFO(\"failed to resolve address '%s' to a name.\\n\",\n\t\t\t\t\tip_addr2a(&ia));\n\t\t}\n#endif\n\t}\n\n\tLM_WARN(\"failed to establish with certainty the type of next hop;\"\n\t\t\t\" trying an educated guess.\\n\");\n\n\t/* [4] compare (possibly updated) remote target to original RURI; if\n\t * equal, a strict router's address wasn't filled in as RURI -> loose */\n\tLM_DBG(\"checking remote target against INVITE's RURI.\\n\");\n\tPARSE_URI(contact, &cont_uri);\n\tPARSE_URI(GET_RURI(orig_inv), &inv_ruri);\n\tURI_PORT(&cont_uri, cont_port);\n\tURI_PORT(&inv_ruri, inv_port);\n\tif ((cont_port == inv_port) && (cont_uri.host.len == inv_ruri.host.len) &&\n\t\t\t(memcmp(cont_uri.host.s, inv_ruri.host.s, cont_uri.host.len) == 0))\n\t\treturn F_RB_NH_LOOSE;\n\n\t/* [5] compare (possibly updated) remote target to last route; if equal,\n\t * strict router's address might have been filled as RURI and remote\n\t * target appended to route set -> strict */\n\tLM_DBG(\"checking remote target against INVITE's last route.\\n\");\n\tPARSE_URI(&last_r->ptr->nameaddr.uri, &lastr_uri);\n\tURI_PORT(&lastr_uri, lastr_port);\n\tif ((cont_port == lastr_port) &&\n\t\t\t(cont_uri.host.len == lastr_uri.host.len) &&\n\t\t\t(memcmp(cont_uri.host.s, lastr_uri.host.s,\n\t\t\t\t\tlastr_uri.host.len) == 0))\n\t\treturn F_RB_NH_STRICT;\n\n\tLM_WARN(\"failed to establish the type of next hop;\"\n\t\t\t\" assuming loose router.\\n\");\n\treturn F_RB_NH_LOOSE;\n\n#undef PARSE_URI\n#undef HAS_LR\n#undef URI_PORT\n}\n\n/**\n * Evaluates the routing elements in locally originated request or reply to\n * locally originated request.\n * If original INVITE was in-dialog (had to-tag), it uses the\n * routes present there (b/c the 2xx for it does not have a RR set, normally).\n * Otherwise, use the reply (b/c the INVITE does not have yet the complete\n * route set).\n *\n * @return: negative for failure; out params:\n *  - list: route set;\n *  - ruri: RURI to be used in ACK;\n *  - nexthop: where to first send the ACK.\n *\n *  NOTE: assumes rpl's parsed to EOF!\n *\n */\nstatic int eval_uac_routing(sip_msg_t *rpl, const struct retr_buf *inv_rb,\n\t\tstr* contact, struct rte **list, str *ruri, str *next_hop)\n{\n\tsip_msg_t orig_inv, *sipmsg; /* reparse original INVITE */\n\trte_t *t, *prev_t, *rtset = NULL;\n\tint is_req;\n\tstruct sip_uri puri;\n\tstatic size_t chklen;\n\n\t/* parse the retr. buffer */\n\tmemset(&orig_inv, 0, sizeof(struct sip_msg));\n\torig_inv.buf = inv_rb->buffer;\n\torig_inv.len = inv_rb->buffer_len;\n\tLM_DBG(\"reparsing retransmission buffer of original INVITE:\\n%.*s\\n\",\n\t\t\t(int)orig_inv.len, orig_inv.buf);\n\tif (parse_msg(orig_inv.buf, orig_inv.len, &orig_inv) != 0) {\n\t\tLM_ERR(\"failed to parse retr buffer (weird!): \\n%.*s\\n\",\n\t\t\t\t(int)orig_inv.len, orig_inv.buf);\n\t\treturn -1;\n\t}\n\n\t/* check if we need to look at request or reply */\n\tif ((parse_headers(&orig_inv, HDR_TO_F, 0) < 0) || (! orig_inv.to)) {\n\t\t/* the bug is at message assembly */\n\t\tLM_BUG(\"failed to parse INVITE retr. buffer and/or extract 'To' HF:\"\n\t\t\t\t\"\\n%.*s\\n\", (int)orig_inv.len, orig_inv.buf);\n\t\tgoto error;\n\t}\n\tif (((struct to_body *)orig_inv.to->parsed)->tag_value.len) {\n\t\tLM_DBG(\"building ACK for in-dialog INVITE (using RS in orig. INV.)\\n\");\n\t\tif (parse_headers(&orig_inv, HDR_EOH_F, 0) < 0) {\n\t\t\tLM_BUG(\"failed to parse INVITE retr. buffer to EOH:\"\n\t\t\t\t\t\"\\n%.*s\\n\", (int)orig_inv.len, orig_inv.buf);\n\t\t\tgoto error;\n\t\t}\n\t\tsipmsg = &orig_inv;\n\t\tis_req = 1;\n\t} else {\n\t\tLM_DBG(\"building ACK for out-of-dialog INVITE (using RS in RR set).\\n\");\n\t\tsipmsg = rpl;\n\t\tis_req = 0;\n\t}\n\n\t/* extract the route set */\n\tif (get_uac_rs(sipmsg, is_req, &rtset) < 0) {\n\t\tLM_ERR(\"failed to extract route set.\\n\");\n\t\tgoto error;\n\t}\n\n\tif (! rtset) { /* No routes */\n\t\t*ruri = *contact;\n\t\t*next_hop = *contact;\n\t} else if (! is_req) { /* out of dialog req. */\n\t\tif (parse_uri(rtset->ptr->nameaddr.uri.s, rtset->ptr->nameaddr.uri.len,\n\t\t\t\t&puri) < 0) {\n\t\t\tLM_ERR(\"failed to parse first route in set.\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (puri.lr.s) { /* Next hop is loose router */\n\t\t\t*ruri = *contact;\n\t\t\t*next_hop = rtset->ptr->nameaddr.uri;\n\t\t} else { /* Next hop is strict router */\n\t\t\t*ruri = rtset->ptr->nameaddr.uri;\n\t\t\t*next_hop = *ruri;\n\t\t\t/* consume first route, b/c it will be put in RURI */\n\t\t\tt = rtset;\n\t\t\trtset = rtset->next;\n\t\t\tpkg_free(t);\n\t\t}\n\t} else {\n\t\tunsigned long route_flags = inv_rb->flags;\n\t\tLM_DBG(\"UAC rb flags: 0x%x.\\n\", (unsigned int)route_flags);\neval_flags:\n\t\tswitch (route_flags & (F_RB_NH_LOOSE|F_RB_NH_STRICT)) {\n\t\tcase 0:\n\t\t\tLM_WARN(\"calculate_hooks() not called when built the local UAC of \"\n\t\t\t\t\t\"in-dialog request, or called with empty route set.\\n\");\n\t\t\t/* try to figure out what kind of hop is the next one\n\t\t\t * (strict/loose) by reading the original invite */\n\t\t\tif ((route_flags = nhop_type(&orig_inv, rtset, &inv_rb->dst,\n\t\t\t\t\tcontact))) {\n\t\t\t\tLM_DBG(\"original request's next hop type evaluated to: 0x%x.\\n\",\n\t\t\t\t\t\t(unsigned int)route_flags);\n\t\t\t\tgoto eval_flags;\n\t\t\t} else {\n\t\t\t\tLM_ERR(\"failed to establish what kind of router the next \"\n\t\t\t\t\t\t\"hop is.\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase F_RB_NH_LOOSE:\n\t\t\t*ruri = *contact;\n\t\t\t*next_hop = rtset->ptr->nameaddr.uri;\n\t\t\tbreak;\n\t\tcase F_RB_NH_STRICT:\n\t\t\t/* find ptr to last route body that contains the (possibly) old\n\t\t\t * remote target\n\t\t\t */\n\t\t\tfor (t = rtset, prev_t = NULL; t->next; prev_t = t, t = t->next)\n\t\t\t\t;\n\t\t\tif ((t->ptr->len == contact->len) &&\n\t\t\t\t\t(memcmp(t->ptr->nameaddr.name.s, contact->s,\n\t\t\t\t\t\t\tcontact->len) == 0)){\n\t\t\t\t/* the remote target didn't update -> keep the whole route set,\n\t\t\t\t * including the last entry */\n\t\t\t\t/* do nothing */\n\t\t\t} else {\n\t\t\t\t/* trash last entry and replace with new remote target */\n\t\t\t\tfree_rte_list(t);\n\t\t\t\t/* compact the rr_t struct along with rte. this way, free'ing\n\t\t\t\t * it can be done along with rte chunk, independent of Route\n\t\t\t\t * header parser's allocator (using pkg/shm) */\n\t\t\t\tchklen = sizeof(struct rte) + sizeof(rr_t);\n\t\t\t\tif (! (t = pkg_malloc(chklen))) {\n\t\t\t\t\tPKG_MEM_ERROR_FMT(\"(%d required)\\n\", (int)chklen);\n\t\t\t\t\t/* last element was freed, unlink it */\n\t\t\t\t\tif(prev_t == NULL) {\n\t\t\t\t\t\t/* there is only one elem in route set: the remote target */\n\t\t\t\t\t\trtset = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprev_t->next = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\t/* this way, .free_rr is also set to 0 (!!!) */\n\t\t\t\tmemset(t, 0, chklen);\n\t\t\t\t((rr_t *)&t[1])->nameaddr.name = *contact;\n\t\t\t\t((rr_t *)&t[1])->len = contact->len;\n\t\t\t\t/* chain the new route elem in set */\n\t\t\t\tif (prev_t == NULL)\n\t\t\t\t\t/* there is only one elem in route set: the remote target */\n\t\t\t\t\trtset = t;\n\t\t\t\telse\n\t\t\t\t\tprev_t->next = t;\n\t\t\t}\n\n\t\t\t*ruri = *GET_RURI(&orig_inv); /* reuse original RURI */\n\t\t\t*next_hop = *ruri;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* probably a mem corruption */\n\t\t\tLM_BUG(\"next hop of original request marked as both loose\"\n\t\t\t\t\t\" and strict router (buffer: %.*s).\\n\",\n\t\t\t\t\tinv_rb->buffer_len, inv_rb->buffer);\n#ifdef EXTRA_DEBUG\n\t\t\tabort();\n#else\n\t\t\tgoto error;\n#endif\n\t\t}\n\t}\n\n\t*list = rtset;\n\tfree_sip_msg(&orig_inv);\n\t/* all went well */\n\treturn 0;\n\nerror:\n\tfree_sip_msg(&orig_inv);\n\tif (rtset)\n\t\tfree_rte_list(rtset);\n\treturn -1;\n}\n\n/*\n * The function creates an ACK to 200 OK. Route set will be created\n * and parsed and the dst parameter will contain the destination to which\n * the request should be send. The function is used by tm when it\n * generates local ACK to 200 OK (on behalf of applications using uac)\n */\nchar *build_dlg_ack(struct sip_msg* rpl, struct cell *Trans,\n\t\t\t\t\tunsigned int branch, str *hdrs, str *body,\n\t\t\t\t\tunsigned int *len, struct dest_info* dst)\n{\n\tchar *req_buf, *p, *via;\n\tunsigned int via_len;\n\tchar branch_buf[MAX_BRANCH_PARAM_LEN];\n\tint branch_len;\n\tstr branch_str;\n\tstruct hostport hp;\n\tstruct rte* list;\n\tstr contact, ruri, *cont;\n\tstr next_hop;\n\tstr body_len;\n\tstr _to, *to = &_to;\n#ifdef USE_DNS_FAILOVER\n\tstruct dns_srv_handle dns_h;\n#endif\n\t/* With AS support, TM allows for external modules to generate building of\n\t * the ACK; in this case, the ACK's retransmission buffer is built once\n\t * and kept in memory (to help when retransmitted 2xx are received and ACK\n\t * must be resent).\n\t * Allocation of the string raw buffer that holds the ACK is piggy-backed\n\t * with allocation of the retransmission buffer (since both have the same\n\t * life-cycle): both the string buffer and retransm. buffer are placed\n\t * into the same allocated chunk of memory (retr. buffer first, string\n\t * buffer follows).In this case, the 'len' param is used as in-out\n\t * parameter: 'in' to give the extra space needed by the retr. buffer,\n\t * 'out' to return the length of the allocated string buffer.\n\t */\n\tunsigned offset = *len;\n\n\tif (parse_headers(rpl, HDR_EOH_F, 0) == -1 || !rpl->to) {\n\t\tLM_ERR(\"Error while parsing headers.\\n\");\n\t\treturn 0;\n\t} else {\n\t\t_to.s = rpl->to->name.s;\n\t\t_to.len = rpl->to->len;\n\t}\n\n\tif (get_contact_uri(rpl, &contact) < 0) {\n\t\treturn 0;\n\t}\n\n\tif (eval_uac_routing(rpl, &Trans->uac[branch].request, &contact,\n\t\t\t&list, &ruri, &next_hop) < 0) {\n\t\tLM_ERR(\"failed to evaluate routing elements.\\n\");\n\t\treturn 0;\n\t}\n\tLM_DBG(\"ACK RURI: `%.*s', NH: `%.*s'.\\n\", STR_FMT(&ruri),\n\t\t\tSTR_FMT(&next_hop));\n\n\tif ((contact.s != ruri.s) || (contact.len != ruri.len)) {\n\t\t/* contact != ruri means that the next\n\t\t * hop is a strict router, cont will be non-zero\n\t\t * and print_routeset will append it at the end\n\t\t * of the route set\n\t\t */\n\t\tcont = &contact;\n\t} else {\n\t\t/* Next hop is a loose router, nothing to append */\n\t\tcont = 0;\n\t}\n\n\t/* method, separators, version: \"ACK sip:p2@iptel.org SIP/2.0\" */\n\t*len = SIP_VERSION_LEN + ACK_LEN + 2 /* spaces */ + CRLF_LEN;\n\t*len += ruri.len;\n\n\t/* dst */\n\tswitch(cfg_get(tm, tm_cfg, local_ack_mode)){\n\t\tcase 1:\n\t\t\t/* send the local 200 ack to the same dst as the corresp. invite*/\n\t\t\t*dst=Trans->uac[branch].request.dst;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* send the local 200 ack to the same dst as the 200 reply source*/\n\t\t\tinit_dst_from_rcv(dst, &rpl->rcv);\n\t\t\tdst->send_flags=rpl->fwd_send_flags;\n\t\t\tbreak;\n\t\tcase 0:\n\t\tdefault:\n\t\t\t/* rfc conformant behaviour: use the next_hop determined from the\n\t\t\t * contact and the route set */\n#ifdef USE_DNS_FAILOVER\n\t\tif (cfg_get(core, core_cfg, use_dns_failover)){\n\t\t\tdns_srv_handle_init(&dns_h);\n\t\t\tif ((uri2dst(&dns_h , dst, rpl, &next_hop, PROTO_NONE)==0) ||\n\t\t\t\t\t(dst->send_sock==0)){\n\t\t\t\tdns_srv_handle_put(&dns_h);\n\t\t\t\tLM_ERR(\"no socket found\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tdns_srv_handle_put(&dns_h); /* not needed any more */\n\t\t}else{\n\t\t\tif ((uri2dst(0 , dst, rpl, &next_hop, PROTO_NONE)==0) ||\n\t\t\t\t\t(dst->send_sock==0)){\n\t\t\t\tLM_ERR(\"no socket found\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n#else /* USE_DNS_FAILOVER */\n\t\tif ( (uri2dst( dst, rpl, &next_hop, PROTO_NONE)==0) ||\n\t\t\t\t(dst->send_sock==0)){\n\t\t\tLM_ERR(\"no socket found\\n\");\n\t\t\tgoto error;\n\t\t}\n#endif /* USE_DNS_FAILOVER */\n\t\tbreak;\n\t}\n\n\t/* via */\n\tif (!t_calc_branch(Trans,  branch, branch_buf, &branch_len)) goto error;\n\tbranch_str.s = branch_buf;\n\tbranch_str.len = branch_len;\n\tset_hostport(&hp, 0);\n\tvia = via_builder(&via_len, NULL, dst, &branch_str, 0, &hp);\n\tif (!via) {\n\t\tLM_ERR(\"No via header got from builder\\n\");\n\t\tgoto error;\n\t}\n\t*len+= via_len;\n\n\t/* headers */\n\t*len += Trans->from.len + Trans->callid.len + to->len + Trans->cseq_n.len + 1 + ACK_LEN + CRLF_LEN;\n\n\t/* copy'n'paste Route headers */\n\n\t*len += calc_routeset_len(list, cont);\n\n\t/* User Agent */\n\tif (server_signature) *len += user_agent_hdr.len + CRLF_LEN;\n\t/* extra headers */\n\tif (hdrs)\n\t\t*len += hdrs->len;\n\t/* body */\n\tif (body) {\n\t\tbody_len.s = int2str(body->len, &body_len.len);\n\t\t*len += body->len;\n\t} else {\n\t\tbody_len.len = 0;\n\t\tbody_len.s = NULL; /*4gcc*/\n\t\t*len += 1; /* for the (Cont-Len:) `0' */\n\t}\n\t/* Content Length, EoM */\n\t*len += CONTENT_LENGTH_LEN + body_len.len + CRLF_LEN + CRLF_LEN;\n\n\treq_buf = shm_malloc(offset + *len + 1);\n\treq_buf += offset;\n\tif (!req_buf) {\n\t\tSHM_MEM_ERROR_FMT(\"required (%u+1)\\n\", *len);\n\t\tgoto error01;\n\t}\n\tp = req_buf;\n\n\tappend_str( p, ACK, ACK_LEN );\n\tappend_str( p, \" \", 1 );\n\tappend_str(p, ruri.s, ruri.len);\n\tappend_str( p, \" \" SIP_VERSION CRLF, 1 + SIP_VERSION_LEN + CRLF_LEN);\n\n\t/* insert our via */\n\tappend_str(p, via, via_len);\n\n\t/*other headers*/\n\tappend_str(p, Trans->from.s, Trans->from.len);\n\tappend_str(p, Trans->callid.s, Trans->callid.len);\n\tappend_str(p, to->s, to->len);\n\n\tappend_str(p, Trans->cseq_n.s, Trans->cseq_n.len);\n\tappend_str( p, \" \", 1 );\n\tappend_str( p, ACK, ACK_LEN);\n\tappend_str(p, CRLF, CRLF_LEN);\n\n\t/* Routeset */\n\tp = print_rs(p, list, cont);\n\n\t/* User Agent header */\n\tif (server_signature) {\n\t\tappend_str(p, user_agent_hdr.s, user_agent_hdr.len);\n\t\tappend_str(p, CRLF, CRLF_LEN);\n\t}\n\n\t/* extra headers */\n\tif (hdrs)\n\t\tappend_str(p, hdrs->s, hdrs->len);\n\n\t/* Content Length, EoH, (body) */\n\tif (body) {\n\t\tappend_str(p, CONTENT_LENGTH, CONTENT_LENGTH_LEN);\n\t\tappend_str(p, body_len.s, body_len.len);\n\t\tappend_str(p, /*end crr. header*/CRLF /*EoH*/CRLF, CRLF_LEN +\n\t\t\t\tCRLF_LEN);\n\t\tappend_str(p, body->s, body->len);\n\t} else {\n\t\tappend_str(p, CONTENT_LENGTH \"0\" CRLF CRLF,\n\t\t\t\tCONTENT_LENGTH_LEN + 1 + CRLF_LEN + CRLF_LEN);\n\t}\n\n\t/* EoM */\n\t*p = 0;\n\n\tpkg_free(via);\n\tfree_rte_list(list);\n\treturn req_buf;\n\nerror01:\n\tpkg_free(via);\nerror:\n\tfree_rte_list(list);\n\treturn 0;\n}\n\n\n/*\n * Convert length of body into asciiz\n */\nstatic inline int print_content_length(str* dest, str* body)\n{\n\tstatic char content_length[10];\n\tint len;\n\tint b_len;\n\tchar* tmp;\n\n\t/* Print Content-Length */\n\tb_len=body?body->len:0;\n\ttmp = int2str(b_len, &len);\n\tif (len >= sizeof(content_length)) {\n\t\tLM_ERR(\"content_len too big\\n\");\n\t\tdest->s = 0;\n\t\tdest->len = 0;\n\t\treturn -1;\n\t}\n\tmemcpy(content_length, tmp, len);\n\tdest->s = content_length;\n\tdest->len = len;\n\treturn 0;\n}\n\n\n/*\n * Convert CSeq number into asciiz\n */\nstatic inline int print_cseq_num(str* _s, dlg_t* _d)\n{\n\tstatic char cseq[INT2STR_MAX_LEN];\n\tchar* tmp;\n\tint len;\n\n\ttmp = int2str(_d->loc_seq.value, &len);\n\tif (len > sizeof(cseq)) {\n\t\tLM_ERR(\"cseq too big\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(cseq, tmp, len);\n\t_s->s = cseq;\n\t_s->len = len;\n\treturn 0;\n}\n\n\n/*\n * Create Via header\n */\nstatic inline int assemble_via(str* dest, struct cell* t,\n\t\t\t\t\t\t\t\tstruct dest_info* dst, int branch)\n{\n\tstatic char branch_buf[MAX_BRANCH_PARAM_LEN];\n\tchar* via;\n\tint len;\n\tunsigned int via_len;\n\tstr branch_str;\n\tstruct hostport hp;\n\n\tif (!t_calc_branch(t, branch, branch_buf, &len)) {\n\t\tLM_ERR(\"branch calculation failed\\n\");\n\t\treturn -1;\n\t}\n\n\tbranch_str.s = branch_buf;\n\tbranch_str.len = len;\n\n#ifdef XL_DEBUG\n\tprintf(\"!!!proto: %d\\n\", sock->proto);\n#endif\n\n\tset_hostport(&hp, 0);\n\tvia = via_builder(&via_len, NULL, dst, &branch_str, 0, &hp);\n\tif (!via) {\n\t\tLM_ERR(\"via building failed\\n\");\n\t\treturn -2;\n\t}\n\n\tdest->s = via;\n\tdest->len = via_len;\n\treturn 0;\n}\n\n\n/*\n * Print Request-URI\n */\nstatic inline char* print_request_uri(char* w, str* method, dlg_t* dialog,\n\t\tstruct cell* t, int branch)\n{\n\tmemapp(w, method->s, method->len);\n\tmemapp(w, \" \", 1);\n\n\tt->uac[branch].uri.s = w;\n\tt->uac[branch].uri.len = dialog->hooks.request_uri->len;\n\n\tmemapp(w, dialog->hooks.request_uri->s, dialog->hooks.request_uri->len);\n\tmemapp(w, \" \" SIP_VERSION CRLF, 1 + SIP_VERSION_LEN + CRLF_LEN);\n\n\treturn w;\n}\n\n\n/*\n * Print To header field\n */\nstatic inline char* print_to(char* w, dlg_t* dialog, struct cell* t, int bracket)\n{\n\tt->to.s = w;\n\tt->to.len = TO_LEN + dialog->rem_uri.len + CRLF_LEN\n\t\t+ (((dialog->rem_uri.s[dialog->rem_uri.len - 1]!='>'))?2:0);\n\n\tmemapp(w, TO, TO_LEN);\n\tif(bracket) memapp(w, \"<\", 1);\n\tmemapp(w, dialog->rem_uri.s, dialog->rem_uri.len);\n\tif(bracket) memapp(w, \">\", 1);\n\n\tif (dialog->id.rem_tag.len) {\n\t\tt->to.len += TOTAG_LEN + dialog->id.rem_tag.len ;\n\t\tmemapp(w, TOTAG, TOTAG_LEN);\n\t\tmemapp(w, dialog->id.rem_tag.s, dialog->id.rem_tag.len);\n\t}\n\n\tmemapp(w, CRLF, CRLF_LEN);\n\treturn w;\n}\n\n\n/*\n * Print From header field\n */\nstatic inline char* print_from(char* w, dlg_t* dialog, struct cell* t, int bracket)\n{\n\tt->from.s = w;\n\tt->from.len = FROM_LEN + dialog->loc_uri.len + CRLF_LEN\n\t\t+ ((dialog->loc_uri.s[dialog->loc_uri.len - 1]!='>')?2:0);\n\n\tmemapp(w, FROM, FROM_LEN);\n\tif(bracket) memapp(w, \"<\", 1);\n\tmemapp(w, dialog->loc_uri.s, dialog->loc_uri.len);\n\tif(bracket) memapp(w, \">\", 1);\n\n\tif (dialog->id.loc_tag.len) {\n\t\tt->from.len += FROMTAG_LEN + dialog->id.loc_tag.len;\n\t\tmemapp(w, FROMTAG, FROMTAG_LEN);\n\t\tmemapp(w, dialog->id.loc_tag.s, dialog->id.loc_tag.len);\n\t}\n\n\tmemapp(w, CRLF, CRLF_LEN);\n\treturn w;\n}\n\n\n/*\n * Print CSeq header field\n */\nchar* print_cseq_mini(char* target, str* cseq, str* method) {\n\tmemapp(target, CSEQ, CSEQ_LEN);\n\tmemapp(target, cseq->s, cseq->len);\n\tmemapp(target, \" \", 1);\n\tmemapp(target, method->s, method->len);\n\treturn target;\n}\n\nstatic inline char* print_cseq(char* w, str* cseq, str* method, struct cell* t)\n{\n\tt->cseq_n.s = w;\n\t/* don't include method name and CRLF -- subsequent\n\t * local requests ACK/CANCEL will add their own */\n\tt->cseq_n.len = CSEQ_LEN + cseq->len;\n\tw = print_cseq_mini(w, cseq, method);\n\treturn w;\n}\n\n/*\n * Print Call-ID header field\n * created an extra function for pure header field creation,\n * that is used by t_cancel for t_uac_cancel FIFO function.\n */\nchar* print_callid_mini(char* target, str callid) {\n\tmemapp(target, CALLID, CALLID_LEN);\n\tmemapp(target, callid.s, callid.len);\n\tmemapp(target, CRLF, CRLF_LEN);\n\treturn target;\n}\n\nstatic inline char* print_callid(char* w, dlg_t* dialog, struct cell* t)\n{\n\t/* begins with CRLF, not included in t->callid, don`t know why...?!? */\n\tmemapp(w, CRLF, CRLF_LEN);\n\tt->callid.s = w;\n\tt->callid.len = CALLID_LEN + dialog->id.call_id.len + CRLF_LEN;\n\n\tw = print_callid_mini(w, dialog->id.call_id);\n\treturn w;\n}\n\n\n/*\n * Create a request\n */\nchar* build_uac_req(str* method, str* headers, str* body, dlg_t* dialog,\n\t\tint branch, struct cell *t, int* len, struct dest_info* dst)\n{\n\tchar* buf, *w, *p;\n\tstr content_length, cseq, via;\n\tunsigned int maxfwd_len;\n\tint tbracket, fbracket;\n\tstr fromtag = STR_NULL;\n\tstr loc_tag = STR_NULL;\n\n\tif (!method || !dialog) {\n\t\tLM_ERR(\"invalid parameter value\\n\");\n\t\treturn 0;\n\t}\n\n\tif (dialog->id.loc_tag.len<=0) {\n\t\t/* From Tag is mandatory in RFC3261 - generate one if not provided */\n\t\tgenerate_fromtag(&fromtag, &dialog->id.call_id, &(dialog->rem_uri));\n\t\tloc_tag = dialog->id.loc_tag;\n\t\tdialog->id.loc_tag = fromtag;\n\t}\n\tif (print_content_length(&content_length, body) < 0) {\n\t\tLM_ERR(\"error while printing content-length\\n\");\n\t\treturn 0;\n\t}\n\tif (print_cseq_num(&cseq, dialog) < 0) {\n\t\tLM_ERR(\"error while printing CSeq number\\n\");\n\t\treturn 0;\n\t}\n\n\tif(headers==NULL || headers->len<15\n\t\t\t|| _strnstr(headers->s, \"Max-Forwards:\", headers->len)==NULL) {\n\t\tmaxfwd_len = MAXFWD_HEADER_LEN;\n\t} else {\n\t\tmaxfwd_len = 0;\n\t}\n\n\t*len = method->len + 1 + dialog->hooks.request_uri->len + 1\n\t\t+ SIP_VERSION_LEN + CRLF_LEN;\n\n\tif (assemble_via(&via, t, dst, branch) < 0) {\n\t\tLM_ERR(\"error while assembling Via\\n\");\n\t\treturn 0;\n\t}\n\t*len += via.len;\n\n\tif((p=q_memrchr(dialog->rem_uri.s, '>', dialog->rem_uri.len))!=NULL) {\n\t\tif((p==dialog->rem_uri.s + dialog->rem_uri.len - 1)\n\t\t\t\t|| *(p+1)==';') {\n\t\t\ttbracket = 0;\n\t\t} else {\n\t\t\ttbracket = 1;\n\t\t}\n\t} else {\n\t\ttbracket = 1;\n\t}\n\tif((p=q_memrchr(dialog->loc_uri.s, '>', dialog->loc_uri.len))!=NULL) {\n\t\tif((p==dialog->loc_uri.s + dialog->loc_uri.len - 1)\n\t\t\t\t|| *(p+1)==';') {\n\t\t\tfbracket = 0;\n\t\t} else {\n\t\t\tfbracket = 1;\n\t\t}\n\t} else {\n\t\tfbracket = 1;\n\t}\n\n\t*len += TO_LEN + dialog->rem_uri.len\n\t\t+ (dialog->id.rem_tag.len ? (TOTAG_LEN + dialog->id.rem_tag.len) : 0)\n\t\t+ CRLF_LEN;    /* To */\n\tif(tbracket) *len += 2; /* To-URI < > */\n\t*len += FROM_LEN + dialog->loc_uri.len\n\t\t+ (dialog->id.loc_tag.len ? (FROMTAG_LEN + dialog->id.loc_tag.len) : 0)\n\t\t+ CRLF_LEN;  /* From */\n\tif(fbracket) *len += 2; /* From-URI < > */\n\t*len += CALLID_LEN + dialog->id.call_id.len + CRLF_LEN;   /* Call-ID */\n\t*len += CSEQ_LEN + cseq.len + 1 + method->len + CRLF_LEN; /* CSeq */\n\t*len += calculate_routeset_length(dialog);                /* Route set */\n\t*len += maxfwd_len;                                       /* Max-forwards */\n\t*len += CONTENT_LENGTH_LEN + content_length.len\n\t\t\t\t\t\t\t\t\t\t\t+ CRLF_LEN; /* Content-Length */\n\t*len += ((server_signature && user_agent_hdr.len>0)\n\t\t\t\t\t\t? (user_agent_hdr.len + CRLF_LEN) : 0);\t/* Signature */\n\tif(headers && headers->len>2) {\n\t\t/* Additional headers */\n\t\t*len += headers->len;\n\t\t/* End of header if missing */\n\t\tif(headers->s[headers->len - 1] != '\\n')\n\t\t\t*len += CRLF_LEN;\n\t}\n\t*len += (body ? body->len : 0);                         /* Message body */\n\t*len += CRLF_LEN;                                       /* End of Header */\n\n\tbuf = shm_malloc(*len + 1);\n\tif (!buf) {\n\t\tSHM_MEM_ERROR_FMT(\"required (%d)\\n\", *len);\n\t\tgoto error;\n\t}\n\n\tw = buf;\n\n\tw = print_request_uri(w, method, dialog, t, branch);  /* Request-URI */\n\tmemapp(w, via.s, via.len);                            /* Top-most Via */\n\tw = print_to(w, dialog, t, tbracket);                 /* To */\n\tw = print_from(w, dialog, t, fbracket);               /* From */\n\tif(fromtag.len>0) {\n\t\tdialog->id.loc_tag = loc_tag;\n\t}\n\tw = print_cseq(w, &cseq, method, t);                  /* CSeq */\n\tw = print_callid(w, dialog, t);                       /* Call-ID */\n\tw = print_routeset(w, dialog);                        /* Route set */\n\n\tif(maxfwd_len>0)\n\t\tmemapp(w, MAXFWD_HEADER, MAXFWD_HEADER_LEN);      /* Max-forwards */\n\n\t/* Content-Length */\n\tmemapp(w, CONTENT_LENGTH, CONTENT_LENGTH_LEN);\n\tmemapp(w, content_length.s, content_length.len);\n\tmemapp(w, CRLF, CRLF_LEN);\n\n\t/* Server signature */\n\tif (server_signature && user_agent_hdr.len>0) {\n\t\tmemapp(w, user_agent_hdr.s, user_agent_hdr.len);\n\t\tmemapp(w, CRLF, CRLF_LEN);\n\t}\n\tif(headers && headers->len>2) {\n\t\tmemapp(w, headers->s, headers->len);\n\t\tif(headers->s[headers->len - 1] != '\\n')\n\t\t\tmemapp(w, CRLF, CRLF_LEN);\n\t}\n\tmemapp(w, CRLF, CRLF_LEN);\n\tif (body) memapp(w, body->s, body->len);\n\n#ifdef EXTRA_DEBUG\n\tassert(w-buf == *len);\n#endif\n\n\tmemapp(w, \"\\0\", 1);\n\n\tpkg_free(via.s);\n\treturn buf;\n\nerror:\n\tpkg_free(via.s);\n\treturn 0;\n}\n\n\nint t_calc_branch(struct cell *t,\n\tint b, char *branch, int *branch_len)\n{\n\treturn branch_builder( t->hash_index,\n\t\t\t0, t->md5,\n\t\t\tb, branch, branch_len );\n}\n\n/**\n * build CANCEL from UAC side\n */\nchar *build_uac_cancel(str *headers,str *body,struct cell *cancelledT,\n\t\tunsigned int branch, unsigned int *len, struct dest_info* dst)\n{\n\tchar *cancel_buf, *p;\n\tchar branch_buf[MAX_BRANCH_PARAM_LEN];\n\tstr branch_str;\n\tstruct hostport hp;\n\tstr content_length, via;\n\n\tLM_DBG(\"sing FROM=<%.*s>, TO=<%.*s>, CSEQ_N=<%.*s>\\n\",\n\t\tcancelledT->from.len, cancelledT->from.s, cancelledT->to.len,\n\t\tcancelledT->to.s, cancelledT->cseq_n.len, cancelledT->cseq_n.s);\n\n\tbranch_str.s=branch_buf;\n\tif (!t_calc_branch(cancelledT,  branch, branch_str.s, &branch_str.len )){\n\t\tLM_ERR(\"failed to create branch !\\n\");\n\t\tgoto error;\n\t}\n\tset_hostport(&hp,0);\n\n\tif (assemble_via(&via, cancelledT, dst, branch) < 0) {\n\t\tLM_ERR(\"Error while assembling Via\\n\");\n\t\treturn 0;\n\t}\n\n\t/* method, separators, version  */\n\t*len=CANCEL_LEN + 2 /* spaces */ +SIP_VERSION_LEN + CRLF_LEN;\n\t*len+=cancelledT->uac[branch].uri.len;\n\t/*via*/\n\t*len+= via.len;\n\t/*From*/\n\t*len+=cancelledT->from.len;\n\t/*To*/\n\t*len+=cancelledT->to.len;\n\t/*CallId*/\n\t*len+=cancelledT->callid.len;\n\t/*CSeq*/\n\t*len+=cancelledT->cseq_n.len+1+CANCEL_LEN+CRLF_LEN;\n\t/* User Agent */\n\tif (server_signature) {\n\t\t*len += USER_AGENT_LEN + CRLF_LEN;\n\t}\n\t/* Content Length  */\n\tif (print_content_length(&content_length, body) < 0) {\n\t\tLM_ERR(\"failed to print content-length\\n\");\n\t\treturn 0;\n\t}\n\t/* Content-Length */\n\t*len += (body ? (CONTENT_LENGTH_LEN + content_length.len + CRLF_LEN) : 0);\n\t/*Additional headers*/\n\t*len += (headers ? headers->len : 0);\n\t/*EoM*/\n\t*len+= CRLF_LEN;\n\t/* Message body */\n\t*len += (body ? body->len : 0);\n\n\tcancel_buf=shm_malloc( *len+1 );\n\tif (!cancel_buf)\n\t{\n\t\tSHM_MEM_ERROR;\n\t\tgoto error01;\n\t}\n\tp = cancel_buf;\n\n\tmemapp( p, CANCEL, CANCEL_LEN );\n\n\t*(p++) = ' ';\n\tmemapp( p, cancelledT->uac[branch].uri.s,\n\t\tcancelledT->uac[branch].uri.len);\n\tmemapp( p, \" \" SIP_VERSION CRLF, 1+SIP_VERSION_LEN+CRLF_LEN );\n\n\t/* insert our via */\n\tmemapp(p,via.s,via.len);\n\n\t/*other headers*/\n\tmemapp( p, cancelledT->from.s, cancelledT->from.len );\n\tmemapp( p, cancelledT->callid.s, cancelledT->callid.len );\n\tmemapp( p, cancelledT->to.s, cancelledT->to.len );\n\n\tmemapp( p, cancelledT->cseq_n.s, cancelledT->cseq_n.len );\n\t*(p++) = ' ';\n\tmemapp( p, CANCEL, CANCEL_LEN );\n\tmemapp( p, CRLF, CRLF_LEN );\n\n\t/* User Agent header */\n\tif (server_signature) {\n\t\tmemapp(p,USER_AGENT CRLF, USER_AGENT_LEN+CRLF_LEN );\n\t}\n\t/* Content Length*/\n\tif (body) {\n\t\tmemapp(p, CONTENT_LENGTH, CONTENT_LENGTH_LEN);\n\t\tmemapp(p, content_length.s, content_length.len);\n\t\tmemapp(p, CRLF, CRLF_LEN);\n\t}\n\tif(headers && headers->len){\n\t\tmemapp(p,headers->s,headers->len);\n\t}\n\t/*EoM*/\n\tmemapp(p,CRLF,CRLF_LEN);\n\tif(body && body->len){\n\t\tmemapp(p,body->s,body->len);\n\t}\n\t*p=0;\n\tpkg_free(via.s);\n\treturn cancel_buf;\nerror01:\n\tpkg_free(via.s);\nerror:\n\treturn NULL;\n}\n\n"], "fixing_code": ["/*\n * message printing\n *\n * Copyright (C) 2001-2003 FhG Fokus\n *\n * This file is part of Kamailio, a free SIP server.\n *\n * Kamailio is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * Kamailio is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n *\n */\n\n\n#ifdef EXTRA_DEBUG\n#include <assert.h>\n#endif\n#include \"../../core/comp_defs.h\"\n#include \"../../core/hash_func.h\"\n#include \"../../core/globals.h\"\n#include \"t_funcs.h\"\n#include \"../../core/dprint.h\"\n#include \"../../core/config.h\"\n#include \"../../core/parser/parser_f.h\"\n#include \"../../core/parser/parse_to.h\"\n#include \"../../core/ut.h\"\n#include \"../../core/srapi.h\"\n#include \"../../core/parser/msg_parser.h\"\n#include \"../../core/parser/contact/parse_contact.h\"\n#include \"lw_parser.h\"\n#include \"t_msgbuilder.h\"\n#include \"uac.h\"\n#ifdef USE_DNS_FAILOVER\n#include \"../../core/dns_cache.h\"\n#include \"../../core/cfg_core.h\" /* cfg_get(core, core_cfg, use_dns_failover) */\n#endif\n\n\n/* convenience macros */\n#define memapp(_d,_s,_len) \\\n\tdo{\\\n\t\tmemcpy((_d),(_s),(_len));\\\n\t\t(_d) += (_len);\\\n\t}while(0)\n\n\n/* Build a local request based on a previous request; main\n * customers of this function are local ACK and local CANCEL\n */\nchar *build_local(struct cell *Trans,unsigned int branch,\n\tunsigned int *len, char *method, int method_len, str *to\n\t, struct cancel_reason* reason\n\t)\n{\n\tchar                *cancel_buf, *p, *via;\n\tunsigned int         via_len;\n\tstruct hdr_field    *hdr;\n\tchar branch_buf[MAX_BRANCH_PARAM_LEN];\n\tint branch_len;\n\tstr branch_str;\n\tstr via_id;\n\tstruct hostport hp;\n\tint reason_len, code_len;\n\tstruct hdr_field *reas1, *reas_last;\n\n\t/* init */\n\tvia_id.s=0;\n\tvia_id.len=0;\n\n\t/* method, separators, version: \"CANCEL sip:p2@iptel.org SIP/2.0\" */\n\t*len=SIP_VERSION_LEN + method_len + 2 /* spaces */ + CRLF_LEN;\n\t*len+=Trans->uac[branch].uri.len;\n\n\t/*via*/\n\tif (!t_calc_branch(Trans,  branch,\n\t\tbranch_buf, &branch_len ))\n\t\tgoto error;\n\tbranch_str.s=branch_buf;\n\tbranch_str.len=branch_len;\n\tset_hostport(&hp, (is_local(Trans))?0:(Trans->uas.request));\n#ifdef USE_TCP\n\tif (!is_local(Trans) && ((Trans->uas.request->rcv.proto==PROTO_TCP)\n#ifdef USE_TLS\n\t\t\t\t|| (Trans->uas.request->rcv.proto==PROTO_TLS)\n#endif /* USE_TLS */\n\t\t)){\n\t\tif ((via_id.s=id_builder(Trans->uas.request,\n\t\t\t\t\t\t\t\t\t(unsigned int*)&via_id.len))==0){\n\t\t\tLM_ERR(\"id builder failed\\n\");\n\t\t\t/* try to continue without id */\n\t\t}\n\t}\n#endif /* USE_TCP */\n\tvia=via_builder(&via_len, NULL, &Trans->uac[branch].request.dst,\n\t\t&branch_str, via_id.s?&via_id:0 , &hp );\n\n\t/* via_id.s not needed anylonger => free it */\n\tif (via_id.s) {\n\t\tpkg_free(via_id.s);\n\t\tvia_id.s=0;\n\t\tvia_id.len=0;\n\t}\n\n\tif (!via) {\n\t\tLM_ERR(\"no via header got from builder\\n\");\n\t\tgoto error;\n\t}\n\t*len+= via_len;\n\t/*headers*/\n\t*len+=Trans->from.len+Trans->callid.len+to->len+\n\t\t+Trans->cseq_n.len+1+method_len+CRLF_LEN+MAXFWD_HEADER_LEN;\n\n\n\t/* copy'n'paste Route headers */\n\tif (!is_local(Trans)) {\n\t\tfor ( hdr=Trans->uas.request->headers ; hdr ; hdr=hdr->next )\n\t\t\tif (hdr->type==HDR_ROUTE_T)\n\t\t\t\t*len+=hdr->len;\n\t}\n\n\t/* User Agent */\n\tif (server_signature) {\n\t\t*len += user_agent_hdr.len + CRLF_LEN;\n\t}\n\t/* Content Length, EoM */\n\t*len+=CONTENT_LENGTH_LEN+1 + CRLF_LEN;\n\treason_len = 0;\n\treas1 = 0;\n\treas_last = 0;\n\t/* compute reason size (if no reason or disabled => reason_len == 0)*/\n\tif (reason && reason->cause != CANCEL_REAS_UNKNOWN){\n\t\tif (likely(reason->cause > 0 &&\n\t\t\t\t\tcfg_get(tm, tm_cfg, local_cancel_reason))){\n\t\t\t/* Reason: SIP;cause=<reason->cause>[;text=<reason->u.text.s>] */\n\t\t\treason_len = REASON_PREFIX_LEN + USHORT2SBUF_MAX_LEN +\n\t\t\t\t(reason->u.text.s?\n\t\t\t\t\tREASON_TEXT_LEN + 1 + reason->u.text.len + 1 : 0) +\n\t\t\t\tCRLF_LEN;\n\t\t} else if (likely(reason->cause == CANCEL_REAS_PACKED_HDRS &&\n\t\t\t\t\t!(Trans->flags & T_NO_E2E_CANCEL_REASON))) {\n\t\t\treason_len = reason->u.packed_hdrs.len;\n\t\t} else if (reason->cause == CANCEL_REAS_RCVD_CANCEL &&\n\t\t\t\t\treason->u.e2e_cancel &&\n\t\t\t\t\t!(Trans->flags & T_NO_E2E_CANCEL_REASON)) {\n\t\t\t/* parse the entire cancel, to get all the Reason headers */\n\t\t\tif(parse_headers(reason->u.e2e_cancel, HDR_EOH_F, 0)<0) {\n\t\t\t\tLM_WARN(\"failed to parse headers\\n\");\n\t\t\t}\n\t\t\tfor(hdr=get_hdr(reason->u.e2e_cancel, HDR_REASON_T), reas1=hdr;\n\t\t\t\t\thdr; hdr=next_sibling_hdr(hdr)) {\n\t\t\t\t/* hdr->len includes CRLF */\n\t\t\t\treason_len += hdr->len;\n\t\t\t\treas_last=hdr;\n\t\t\t}\n\t\t} else if (unlikely(reason->cause < CANCEL_REAS_MIN))\n\t\t\tLM_BUG(\"unhandled reason cause %d\\n\", reason->cause);\n\t}\n\t*len+= reason_len;\n\t*len+= CRLF_LEN; /* end of msg. */\n\n\tcancel_buf=shm_malloc( *len+1 );\n\tif (!cancel_buf) {\n\t\tSHM_MEM_ERROR;\n\t\tgoto error01;\n\t}\n\tp = cancel_buf;\n\n\tappend_str( p, method, method_len );\n\tappend_str( p, \" \", 1 );\n\tappend_str( p, Trans->uac[branch].uri.s, Trans->uac[branch].uri.len);\n\tappend_str( p, \" \" SIP_VERSION CRLF, 1+SIP_VERSION_LEN+CRLF_LEN );\n\n\t/* insert our via */\n\tappend_str(p,via,via_len);\n\n\t/*other headers*/\n\tappend_str( p, Trans->from.s, Trans->from.len );\n\tappend_str( p, Trans->callid.s, Trans->callid.len );\n\tappend_str( p, to->s, to->len );\n\n\tappend_str( p, Trans->cseq_n.s, Trans->cseq_n.len );\n\tappend_str( p, \" \", 1 );\n\tappend_str( p, method, method_len );\n\tappend_str( p, CRLF, CRLF_LEN );\n\tappend_str( p, MAXFWD_HEADER, MAXFWD_HEADER_LEN );\n\n\tif (!is_local(Trans))  {\n\t\tfor ( hdr=Trans->uas.request->headers ; hdr ; hdr=hdr->next )\n\t\t\tif(hdr->type==HDR_ROUTE_T) {\n\t\t\t\tappend_str(p, hdr->name.s, hdr->len );\n\t\t\t}\n\t}\n\n\t/* User Agent header */\n\tif (server_signature) {\n\t\tappend_str(p, user_agent_hdr.s, user_agent_hdr.len );\n\t\tappend_str(p, CRLF, CRLF_LEN );\n\t}\n\t/* Content Length */\n\tappend_str(p, CONTENT_LENGTH \"0\" CRLF, CONTENT_LENGTH_LEN + 1 + CRLF_LEN);\n\t/* add reason if needed */\n\tif (reason_len) {\n\t\tif (likely(reason->cause > 0)) {\n\t\t\tappend_str(p, REASON_PREFIX, REASON_PREFIX_LEN);\n\t\t\tcode_len=ushort2sbuf(reason->cause, p,\n\t\t\t\t\t\t\t\t\t*len-(int)(p-cancel_buf));\n\t\t\tif (unlikely(code_len==0))\n\t\t\t\tLM_BUG(\"not enough space to write reason code\");\n\t\t\tp+=code_len;\n\t\t\tif (reason->u.text.s){\n\t\t\t\tappend_str(p, REASON_TEXT, REASON_TEXT_LEN);\n\t\t\t\t*p='\"'; p++;\n\t\t\t\tappend_str(p, reason->u.text.s, reason->u.text.len);\n\t\t\t\t*p='\"'; p++;\n\t\t\t}\n\t\t\tappend_str(p, CRLF, CRLF_LEN);\n\t\t} else if (likely(reason->cause == CANCEL_REAS_PACKED_HDRS)) {\n\t\t\tappend_str(p, reason->u.packed_hdrs.s, reason->u.packed_hdrs.len);\n\t\t} else if (reason->cause == CANCEL_REAS_RCVD_CANCEL) {\n\t\t\tfor(hdr=reas1; hdr; hdr=next_sibling_hdr(hdr)) {\n\t\t\t\t/* hdr->len includes CRLF */\n\t\t\t\tappend_str(p, hdr->name.s, hdr->len);\n\t\t\t\tif (likely(hdr==reas_last))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tappend_str(p, CRLF, CRLF_LEN); /* msg. end */\n\t*p=0;\n\n\tpkg_free(via);\n\treturn cancel_buf;\nerror01:\n\tpkg_free(via);\nerror:\n\treturn NULL;\n}\n\n/* Re-parsing version of build_local() function:\n * it builds a local CANCEL or ACK (for non-200 response) request based on\n * the previous INVITE which was sent out.\n *\n * Can not be used to build other type of requests!\n */\nchar *build_local_reparse(tm_cell_t *Trans,unsigned int branch,\n\tunsigned int *len, char *method, int method_len, str *to\n\t, struct cancel_reason *reason\n\t)\n{\n\tchar\t*invite_buf, *invite_buf_end;\n\tchar\t*cancel_buf;\n\tchar\t*s, *s1, *d;\t/* source and destination buffers */\n\tshort\tinvite_len;\n\tenum _hdr_types_t\thf_type;\n\tint\tfirst_via, to_len;\n\tint cancel_buf_len;\n\tint reason_len, code_len;\n\tstruct hdr_field *reas1, *reas_last, *hdr;\n\tint hadded = 0;\n\tsr_cfgenv_t *cenv = NULL;\n\thdr_flags_t hdr_flags = 0;\n\n\tinvite_buf = Trans->uac[branch].request.buffer;\n\tinvite_len = Trans->uac[branch].request.buffer_len;\n\n\tif (!invite_buf || invite_len<=0) {\n\t\tLM_ERR(\"INVITE is missing\\n\");\n\t\tgoto error;\n\t}\n\tif ((*invite_buf != 'I') && (*invite_buf != 'i')) {\n\t\tLM_ERR(\"trying to build with local reparse\"\n\t\t\t\t\t\" for a non-INVITE request?\\n\");\n\t\tgoto error;\n\t}\n\n\treason_len = 0;\n\treas1 = 0;\n\treas_last = 0;\n\t/* compute reason size (if no reason or disabled => reason_len == 0)*/\n\tif (reason && reason->cause != CANCEL_REAS_UNKNOWN){\n\t\tif (likely(reason->cause > 0 &&\n\t\t\t\t\tcfg_get(tm, tm_cfg, local_cancel_reason))){\n\t\t\t/* Reason: SIP;cause=<reason->cause>[;text=<reason->u.text.s>] */\n\t\t\treason_len = REASON_PREFIX_LEN + USHORT2SBUF_MAX_LEN +\n\t\t\t\t(reason->u.text.s?\n\t\t\t\t\tREASON_TEXT_LEN + 1 + reason->u.text.len + 1 : 0) +\n\t\t\t\tCRLF_LEN;\n\t\t} else if (likely(reason->cause == CANCEL_REAS_PACKED_HDRS &&\n\t\t\t\t\t!(Trans->flags & T_NO_E2E_CANCEL_REASON))) {\n\t\t\treason_len = reason->u.packed_hdrs.len;\n\t\t} else if (reason->cause == CANCEL_REAS_RCVD_CANCEL &&\n\t\t\t\t\treason->u.e2e_cancel &&\n\t\t\t\t\t!(Trans->flags & T_NO_E2E_CANCEL_REASON)) {\n\t\t\t/* parse the entire cancel, to get all the Reason headers */\n\t\t\tif(parse_headers(reason->u.e2e_cancel, HDR_EOH_F, 0)<0) {\n\t\t\t\tLM_WARN(\"failed to parse headers\\n\");\n\t\t\t}\n\t\t\tfor(hdr=get_hdr(reason->u.e2e_cancel, HDR_REASON_T), reas1=hdr;\n\t\t\t\t\thdr; hdr=next_sibling_hdr(hdr)) {\n\t\t\t\t/* hdr->len includes CRLF */\n\t\t\t\treason_len += hdr->len;\n\t\t\t\treas_last=hdr;\n\t\t\t}\n\t\t} else if (unlikely(reason->cause < CANCEL_REAS_MIN))\n\t\t\tLM_BUG(\"unhandled reason cause %d\\n\", reason->cause);\n\t}\n\n\tinvite_buf_end = invite_buf + invite_len;\n\ts = invite_buf;\n\n\t/* Allocate memory for the new message.\n\tThe new request will be smaller than the INVITE, so the same size is enough.\n\tI just extend it with the length of new To HF to be sure.\n\tUgly, but we avoid lots of checks and memory allocations this way */\n\tto_len = to ? to->len : 0;\n\tcancel_buf_len = invite_len + to_len + reason_len;\n\n\tcancel_buf = shm_malloc(sizeof(char)*cancel_buf_len);\n\tif (!cancel_buf)\n\t{\n\t\tSHM_MEM_ERROR;\n\t\tgoto error;\n\t}\n\td = cancel_buf;\n\n\t/* method name + space */\n\tappend_str(d, method, method_len);\n\t*d = ' ';\n\td++;\n\t/* skip \"INVITE \" and copy the rest of the line including CRLF */\n\ts += 7;\n\ts1 = s;\n\ts = eat_line(s, invite_buf_end - s);\n\tappend_str(d, s1, s - s1);\n\n\tcenv = sr_cfgenv_get();\n\n\t/* check every header field name,\n\twe must exclude and modify some of the headers */\n\tfirst_via = 1;\n\twhile (s < invite_buf_end) {\n\t\ts1 = s;\n\t\tif ((*s == '\\n') || (*s == '\\r')) {\n\t\t\t/* end of SIP msg */\n\t\t\thf_type = HDR_EOH_T;\n\t\t} else {\n\t\t\t/* parse HF name */\n\t\t\ts = lw_get_hf_name(s, invite_buf_end,\n\t\t\t\t\t\t&hf_type);\n\t\t}\n\n\t\tswitch(hf_type) {\n\t\t\tcase HDR_CSEQ_T:\n\t\t\t\t/* find the method name and replace it */\n\t\t\t\tif(hdr_flags &  HDR_CSEQ_F) {\n\t\t\t\t\tLM_DBG(\"duplicate CSeq header\\n\");\n\t\t\t\t\tgoto errorhdr;\n\t\t\t\t}\n\t\t\t\thdr_flags |=  HDR_CSEQ_F;\n\t\t\t\twhile ((s < invite_buf_end)\n\t\t\t\t\t&& ((*s == ':') || (*s == ' ') || (*s == '\\t') ||\n\t\t\t\t\t\t((*s >= '0') && (*s <= '9')))\n\t\t\t\t\t) s++;\n\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\tappend_str(d, method, method_len);\n\t\t\t\tappend_str(d, CRLF, CRLF_LEN);\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\tbreak;\n\n\t\t\tcase HDR_VIA_T:\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\tif (first_via) {\n\t\t\t\t\t/* copy hf */\n\t\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\t\tfirst_via = 0;\n\t\t\t\t} /* else skip this line, we need olny the first via */\n\t\t\t\tbreak;\n\n\t\t\tcase HDR_TO_T:\n\t\t\t\tif(hdr_flags &  HDR_TO_F) {\n\t\t\t\t\tLM_DBG(\"duplicate To header\\n\");\n\t\t\t\t\tgoto errorhdr;\n\t\t\t\t}\n\t\t\t\thdr_flags |=  HDR_TO_F;\n\n\t\t\t\tif (to_len == 0) {\n\t\t\t\t\t/* there is no To tag required, just copy paste\n\t\t\t\t\t * the header */\n\t\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\t} else {\n\t\t\t\t\t/* use the given To HF instead of the original one */\n\t\t\t\t\tappend_str(d, to->s, to->len);\n\t\t\t\t\t/* move the pointer to the next line */\n\t\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase HDR_FROM_T:\n\t\t\t\t/* copy hf */\n\t\t\t\tif(hdr_flags &  HDR_FROM_F) {\n\t\t\t\t\tLM_DBG(\"duplicate From header\\n\");\n\t\t\t\t\tgoto errorhdr;\n\t\t\t\t}\n\t\t\t\thdr_flags |=  HDR_FROM_F;\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\tbreak;\n\t\t\tcase HDR_CALLID_T:\n\t\t\t\t/* copy hf */\n\t\t\t\tif(hdr_flags &  HDR_CALLID_F) {\n\t\t\t\t\tLM_DBG(\"duplicate Call-Id header\\n\");\n\t\t\t\t\tgoto errorhdr;\n\t\t\t\t}\n\t\t\t\thdr_flags |=  HDR_CALLID_F;\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\tbreak;\n\t\t\tcase HDR_ROUTE_T:\n\t\t\tcase HDR_MAXFORWARDS_T:\n\t\t\t\t/* copy hf */\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\tbreak;\n\n\t\t\tcase HDR_REQUIRE_T:\n\t\t\tcase HDR_PROXYREQUIRE_T:\n\t\t\t\t/* skip this line */\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\tbreak;\n\n\t\t\tcase HDR_CONTENTLENGTH_T:\n\t\t\t\t/* copy hf name with 0 value */\n\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\tappend_str(d, \": 0\" CRLF, 3 + CRLF_LEN);\n\t\t\t\t/* move the pointer to the next line */\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\tbreak;\n\n\t\t\tcase HDR_EOH_T:\n\t\t\t\t/* end of SIP message found */\n\t\t\t\t/* add reason if needed */\n\t\t\t\tif (reason_len) {\n\t\t\t\t\t/* if reason_len !=0, no need for any reason enabled\n\t\t\t\t\t * checks */\n\t\t\t\t\tif (likely(reason->cause > 0)) {\n\t\t\t\t\t\tappend_str(d, REASON_PREFIX, REASON_PREFIX_LEN);\n\t\t\t\t\t\tcode_len=ushort2sbuf(reason->cause, d,\n\t\t\t\t\t\t\t\t\t\tcancel_buf_len-(int)(d-cancel_buf));\n\t\t\t\t\t\tif (unlikely(code_len==0))\n\t\t\t\t\t\t\tLM_BUG(\"not enough space to write reason code\");\n\t\t\t\t\t\td+=code_len;\n\t\t\t\t\t\tif (reason->u.text.s){\n\t\t\t\t\t\t\tappend_str(d, REASON_TEXT, REASON_TEXT_LEN);\n\t\t\t\t\t\t\t*d='\"'; d++;\n\t\t\t\t\t\t\tappend_str(d, reason->u.text.s,\n\t\t\t\t\t\t\t\t\t\t\treason->u.text.len);\n\t\t\t\t\t\t\t*d='\"'; d++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tappend_str(d, CRLF, CRLF_LEN);\n\t\t\t\t\t} else if (likely(reason->cause ==\n\t\t\t\t\t\t\t\t\t\tCANCEL_REAS_PACKED_HDRS)) {\n\t\t\t\t\t\t\tappend_str(d, reason->u.packed_hdrs.s,\n\t\t\t\t\t\t\t\t\t\t\treason->u.packed_hdrs.len);\n\t\t\t\t\t} else if (reason->cause == CANCEL_REAS_RCVD_CANCEL) {\n\t\t\t\t\t\tfor(hdr=reas1; hdr; hdr=next_sibling_hdr(hdr)) {\n\t\t\t\t\t\t\t/* hdr->len includes CRLF */\n\t\t\t\t\t\t\tappend_str(d, hdr->name.s, hdr->len);\n\t\t\t\t\t\t\tif (likely(hdr==reas_last))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* final (end-of-headers) CRLF */\n\t\t\t\tappend_str(d, CRLF, CRLF_LEN);\n\t\t\t\t*len = d - cancel_buf;\n\t\t\t\t/* LOG(L_DBG, \"DBG: build_local: %.*s\\n\", *len, cancel_buf); */\n\t\t\t\treturn cancel_buf;\n\n\t\t\tdefault:\n\t\t\t\ts = lw_next_line(s, invite_buf_end);\n\t\t\t\thadded = 0;\n\n\t\t\t\t/* uac auth headers */\n\t\t\t\tif(Trans->uas.request &&\n\t\t\t\t\t\t(Trans->uas.request->msg_flags & FL_UAC_AUTH)) {\n\t\t\t\t\tif(s1 + cenv->uac_cseq_auth.len + 2 < invite_buf_end) {\n\t\t\t\t\t\tif(s1[cenv->uac_cseq_auth.len]==':'\n\t\t\t\t\t\t\t\t&& strncmp(s1, cenv->uac_cseq_auth.s,\n\t\t\t\t\t\t\t\t\tcenv->uac_cseq_auth.len)==0) {\n\t\t\t\t\t\t\thadded = 1;\n\t\t\t\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\t\t\t} else if(s1[cenv->uac_cseq_refresh.len]==':'\n\t\t\t\t\t\t\t\t&& strncmp(s1, cenv->uac_cseq_refresh.s,\n\t\t\t\t\t\t\t\t\tcenv->uac_cseq_refresh.len)==0) {\n\t\t\t\t\t\t\thadded = 1;\n\t\t\t\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(likely(hadded==0)) {\n\t\t\t\t\tif (cfg_get(tm, tm_cfg, ac_extra_hdrs).len\n\t\t\t\t\t\t\t&& (s1 + cfg_get(tm, tm_cfg, ac_extra_hdrs).len < invite_buf_end)\n\t\t\t\t\t\t\t&& (strncasecmp(s1,\n\t\t\t\t\t\t\t\t\tcfg_get(tm, tm_cfg, ac_extra_hdrs).s,\n\t\t\t\t\t\t\t\t\tcfg_get(tm, tm_cfg, ac_extra_hdrs).len) == 0)) {\n\t\t\t\t\t\tappend_str(d, s1, s - s1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* HDR_EOH_T was not found in the buffer, the message is corrupt */\n\tLM_ERR(\"HDR_EOH_T was not found\\n\");\n\nerrorhdr:\n\tshm_free(cancel_buf);\nerror:\n\tLM_ERR(\"cannot build %.*s request\\n\", method_len, method);\n\treturn NULL;\n\n}\n\n\ntypedef struct rte {\n\trr_t* ptr;\n\t/* 'ptr' above doesn't point to a mem chunk linked to a sip_msg, so it\n\t * won't be free'd along with it => it must be free'd \"manually\" */\n\tint free_rr;\n\tstruct rte* next;\n} rte_t;\n\n\nstatic inline void free_rte_list(struct rte* list)\n{\n\tstruct rte* ptr;\n\n\twhile(list) {\n\t\tptr = list;\n\t\tlist = list->next;\n\t\tif (ptr->free_rr)\n\t\t\tfree_rr(&ptr->ptr);\n\t\tpkg_free(ptr);\n\t}\n}\n\n\nstatic inline int calc_routeset_len(struct rte* list, str* contact)\n{\n\tstruct rte* ptr;\n\tint ret;\n\n\tif (list || contact) {\n\t\tret = ROUTE_PREFIX_LEN + CRLF_LEN;\n\t} else {\n\t\treturn 0;\n\t}\n\n\tptr = list;\n\twhile(ptr) {\n\t\tif (ptr != list) {\n\t\t\tret += ROUTE_SEPARATOR_LEN;\n\t\t}\n\t\tret += ptr->ptr->len;\n\t\tptr = ptr->next;\n\t}\n\n\tif (contact) {\n\t\tif (list) ret += ROUTE_SEPARATOR_LEN;\n\t\tret += 2 + contact->len;\n\t}\n\n\treturn ret;\n}\n\n\n/*\n * Print the route set\n */\nstatic inline char* print_rs(char* p, struct rte* list, str* contact)\n{\n\tstruct rte* ptr;\n\n\tif (list || contact) {\n\t\tmemapp(p, ROUTE_PREFIX, ROUTE_PREFIX_LEN);\n\t} else {\n\t\treturn p;\n\t}\n\n\tptr = list;\n\twhile(ptr) {\n\t\tif (ptr != list) {\n\t\t\tmemapp(p, ROUTE_SEPARATOR, ROUTE_SEPARATOR_LEN);\n\t\t}\n\n\t\tmemapp(p, ptr->ptr->nameaddr.name.s, ptr->ptr->len);\n\t\tptr = ptr->next;\n\t}\n\n\tif (contact) {\n\t\tif (list) memapp(p, ROUTE_SEPARATOR, ROUTE_SEPARATOR_LEN);\n\t\t*p++ = '<';\n\t\tappend_str(p, contact->s, contact->len);\n\t\t*p++ = '>';\n\t}\n\n\tmemapp(p, CRLF, CRLF_LEN);\n\treturn p;\n}\n\n\n/*\n * Parse Contact header field body and extract URI\n * Does not parse headers !\n */\nstatic inline int get_contact_uri(struct sip_msg* msg, str* uri)\n{\n\tcontact_t* c;\n\n\turi->len = 0;\n\tif (!msg->contact) return 1;\n\n\tif (parse_contact(msg->contact) < 0) {\n\t\tLM_ERR(\"error while parsing Contact body\\n\");\n\t\treturn -1;\n\t}\n\n\tc = ((contact_body_t*)msg->contact->parsed)->contacts;\n\n\tif (!c) {\n\t\tLM_ERR(\"empty body or * contact\\n\");\n\t\treturn -2;\n\t}\n\n\t*uri = c->uri;\n\treturn 0;\n}\n\n/**\n * Extract route set from the message (out of Record-Route, if reply, OR\n * Route, if request).\n * The route set is returned into the \"UAC-format\" (keep order for Rs, reverse\n * RRs).\n */\nstatic inline int get_uac_rs(sip_msg_t *msg, int is_req, struct rte **rtset)\n{\n\tstruct hdr_field* ptr;\n\trr_t *p, *new_p;\n\tstruct rte *t, *head, *old_head;\n\n\thead = 0;\n\tfor (ptr = is_req ? msg->route : msg->record_route; ptr; ptr = ptr->next) {\n\t\tswitch (ptr->type) {\n\t\t\tcase HDR_RECORDROUTE_T:\n\t\t\t\tif (is_req)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tcase HDR_ROUTE_T:\n\t\t\t\tif (! is_req)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (parse_rr(ptr) < 0) {\n\t\t\tLM_ERR(\"failed to parse Record-/Route HF (%d).\\n\", ptr->type);\n\t\t\tgoto err;\n\t\t}\n\n\t\tp = (rr_t*)ptr->parsed;\n\t\twhile(p) {\n\t\t\tif (! (t = pkg_malloc(sizeof(struct rte)))) {\n\t\t\t\tPKG_MEM_ERROR_FMT(\"(asked for: %d).\\n\",\n\t\t\t\t\t\t(int)sizeof(struct rte));\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (is_req) {\n\t\t\t\t/* in case of requests, the sip_msg structure is free'd before\n\t\t\t\t * rte list is evaluated => must do a copy of it */\n\t\t\t\tif (duplicate_rr(&new_p, p) < 0) {\n\t\t\t\t\tpkg_free(t);\n\t\t\t\t\tLM_ERR(\"failed to duplicate RR\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tt->ptr = new_p;\n\t\t\t} else {\n\t\t\t\tt->ptr = p;\n\t\t\t}\n\t\t\tt->free_rr = is_req;\n\t\t\tt->next = head;\n\t\t\thead = t;\n\t\t\tp = p->next;\n\t\t}\n\t}\n\n\tif (is_req) {\n\t\t/* harvesting the R/RR HF above inserts at head, which suites RRs (as\n\t\t * they must be reversed, anyway), but not Rs => reverse once more */\n\t\told_head = head;\n\t\thead = 0;\n\t\twhile (old_head) {\n\t\t\tt = old_head;\n\t\t\told_head = old_head->next;\n\t\t\tt->next = head;\n\t\t\thead = t;\n\t\t}\n\t}\n\n\t*rtset = head;\n\treturn 0;\nerr:\n\tfree_rte_list(head);\n\treturn -1;\n}\n\n\nstatic inline unsigned short uri2port(const struct sip_uri *puri)\n{\n\tif (puri->port.s) {\n\t\treturn puri->port_no;\n\t} else switch (puri->type) {\n\t\tcase SIP_URI_T:\n\t\tcase TEL_URI_T:\n\t\t\tif (puri->transport_val.len == sizeof(\"TLS\") - 1) {\n\t\t\t\tunsigned trans;\n\t\t\t\ttrans = puri->transport_val.s[0] | 0x20; trans <<= 8;\n\t\t\t\ttrans |= puri->transport_val.s[1] | 0x20; trans <<= 8;\n\t\t\t\ttrans |= puri->transport_val.s[2] | 0x20;\n\t\t\t\tif (trans == 0x746C73) /* t l s */\n\t\t\t\t\treturn SIPS_PORT;\n\t\t\t}\n\t\t\treturn SIP_PORT;\n\t\tcase SIPS_URI_T:\n\t\tcase TELS_URI_T:\n\t\t\treturn SIPS_PORT;\n\t\tdefault:\n\t\t\tLM_BUG(\"unexpected URI type %d.\\n\", puri->type);\n\t}\n\treturn 0;\n}\n\n/**\n * Evaluate if next hop is a strict or loose router, by looking at the\n * retr. buffer of the original INVITE.\n * Assumes:\n * \torig_inv is a parsed SIP message;\n * \trtset is not NULL.\n * @return:\n * \tF_RB_NH_LOOSE : next hop was loose router;\n * \tF_RB_NH_STRICT: nh is strict;\n * \t0 on error.\n */\nstatic unsigned long nhop_type(sip_msg_t *orig_inv, rte_t *rtset,\n\t\tconst struct dest_info *dst_inv, str *contact)\n{\n\tstruct sip_uri puri, topr_uri, lastr_uri, inv_ruri, cont_uri;\n\tstruct ip_addr *uri_ia;\n\tunion sockaddr_union uri_sau;\n\tunsigned int uri_port, dst_port, inv_port, cont_port, lastr_port;\n\trte_t *last_r;\n#ifdef TM_LOC_ACK_DO_REV_DNS\n\tstruct ip_addr ia;\n\tstruct hostent *he;\n\tchar **alias;\n#endif\n\n#define PARSE_URI(_str_, _uri_) \\\n\tdo { \\\n\t\t/* parse_uri() 0z the puri */ \\\n\t\tif (parse_uri((_str_)->s, \\\n\t\t\t\t(_str_)->len, _uri_) < 0) { \\\n\t\t\tLM_ERR(\"failed to parse route body '%.*s'.\\n\", STR_FMT(_str_)); \\\n\t\t\treturn 0; \\\n\t\t} \\\n\t} while (0)\n\n#define HAS_LR(_rte_) \\\n\t({ \\\n\t\tPARSE_URI(&(_rte_)->ptr->nameaddr.uri, &puri); \\\n\t\tpuri.lr.s; \\\n\t})\n\n#define URI_PORT(_puri_, _port) \\\n\tdo { \\\n\t\tif (! (_port = uri2port(_puri_))) \\\n\t\t\treturn 0; \\\n\t} while (0)\n\n\t/* examine the easy/fast & positive cases foremost */\n\n\t/* [1] check if 1st route lacks ;lr */\n\tLM_DBG(\"checking lack of ';lr' in 1st route.\\n\");\n\tif (! HAS_LR(rtset))\n\t\treturn F_RB_NH_STRICT;\n\ttopr_uri = puri; /* save 1st route's URI */\n\n\t/* [2] check if last route shows ;lr */\n\tLM_DBG(\"checking presence of ';lr' in last route.\\n\");\n\tfor (last_r = rtset; last_r->next; last_r = last_r->next)\n\t\t/* scroll down to last route */\n\t\t;\n\tif (HAS_LR(last_r))\n\t\treturn F_RB_NH_LOOSE;\n\n\t/* [3] 1st route has ;lr -> check if the destination of original INV\n\t * equals the address provided by this route; if does -> loose */\n\tLM_DBG(\"checking INVITE's destination against its first route.\\n\");\n\tURI_PORT(&topr_uri, uri_port);\n\tif (! (dst_port = su_getport(&dst_inv->to)))\n\t\treturn 0; /* not really expected */\n\tif (dst_port != uri_port)\n\t\treturn F_RB_NH_STRICT;\n\t/* if 1st route contains an IP address, comparing it against .dst */\n\tif ((uri_ia = str2ip(&topr_uri.host))\n\t\t\t|| (uri_ia = str2ip6(&topr_uri.host))\n\t\t\t) {\n\t\t/* we have an IP address in route -> comparison can go swiftly */\n\t\tif (init_su(&uri_sau, uri_ia, uri_port) < 0)\n\t\t\treturn 0; /* not really expected */\n\t\tif (su_cmp(&uri_sau, &dst_inv->to))\n\t\t\t/* ;lr and sent there */\n\t\t\treturn F_RB_NH_LOOSE;\n\t\telse\n\t\t\t/* ;lr and NOT sent there (probably sent to RURI address) */\n\t\t\treturn F_RB_NH_STRICT;\n\t} else {\n\t\t/*if 1st route contains a name, rev resolve the .dst and compare*/\n\t\tLM_INFO(\"Failed to decode string '%.*s' in route set element as IP\"\n\t\t\t\t\" address. Trying name resolution.\\n\",STR_FMT(&topr_uri.host));\n\n\t/* TODO: alternatively, rev name and compare against dest. IP.  */\n#ifdef TM_LOC_ACK_DO_REV_DNS\n\t\tia.af = 0;\n\t\tsu2ip_addr(&ia, (void *)&dst_inv->to);\n\t\tif (! ia.af)\n\t\t\treturn 0; /* not really expected */\n\t\tif ((he = rev_resolvehost(&ia))) {\n\t\t\tif ((strlen(he->h_name) == topr_uri.host.len) &&\n\t\t\t\t\t(memcmp(he->h_name, topr_uri.host.s,\n\t\t\t\t\t\t\ttopr_uri.host.len) == 0))\n\t\t\t\treturn F_RB_NH_LOOSE;\n\t\t\tfor (alias = he->h_aliases; *alias; alias ++)\n\t\t\t\tif ((strlen(*alias) == topr_uri.host.len) &&\n\t\t\t\t\t\t(memcmp(*alias, topr_uri.host.s,\n\t\t\t\t\t\t\t\ttopr_uri.host.len) == 0))\n\t\t\t\t\treturn F_RB_NH_LOOSE;\n\t\t\treturn F_RB_NH_STRICT;\n\t\t} else {\n\t\t\tLM_INFO(\"failed to resolve address '%s' to a name.\\n\",\n\t\t\t\t\tip_addr2a(&ia));\n\t\t}\n#endif\n\t}\n\n\tLM_WARN(\"failed to establish with certainty the type of next hop;\"\n\t\t\t\" trying an educated guess.\\n\");\n\n\t/* [4] compare (possibly updated) remote target to original RURI; if\n\t * equal, a strict router's address wasn't filled in as RURI -> loose */\n\tLM_DBG(\"checking remote target against INVITE's RURI.\\n\");\n\tPARSE_URI(contact, &cont_uri);\n\tPARSE_URI(GET_RURI(orig_inv), &inv_ruri);\n\tURI_PORT(&cont_uri, cont_port);\n\tURI_PORT(&inv_ruri, inv_port);\n\tif ((cont_port == inv_port) && (cont_uri.host.len == inv_ruri.host.len) &&\n\t\t\t(memcmp(cont_uri.host.s, inv_ruri.host.s, cont_uri.host.len) == 0))\n\t\treturn F_RB_NH_LOOSE;\n\n\t/* [5] compare (possibly updated) remote target to last route; if equal,\n\t * strict router's address might have been filled as RURI and remote\n\t * target appended to route set -> strict */\n\tLM_DBG(\"checking remote target against INVITE's last route.\\n\");\n\tPARSE_URI(&last_r->ptr->nameaddr.uri, &lastr_uri);\n\tURI_PORT(&lastr_uri, lastr_port);\n\tif ((cont_port == lastr_port) &&\n\t\t\t(cont_uri.host.len == lastr_uri.host.len) &&\n\t\t\t(memcmp(cont_uri.host.s, lastr_uri.host.s,\n\t\t\t\t\tlastr_uri.host.len) == 0))\n\t\treturn F_RB_NH_STRICT;\n\n\tLM_WARN(\"failed to establish the type of next hop;\"\n\t\t\t\" assuming loose router.\\n\");\n\treturn F_RB_NH_LOOSE;\n\n#undef PARSE_URI\n#undef HAS_LR\n#undef URI_PORT\n}\n\n/**\n * Evaluates the routing elements in locally originated request or reply to\n * locally originated request.\n * If original INVITE was in-dialog (had to-tag), it uses the\n * routes present there (b/c the 2xx for it does not have a RR set, normally).\n * Otherwise, use the reply (b/c the INVITE does not have yet the complete\n * route set).\n *\n * @return: negative for failure; out params:\n *  - list: route set;\n *  - ruri: RURI to be used in ACK;\n *  - nexthop: where to first send the ACK.\n *\n *  NOTE: assumes rpl's parsed to EOF!\n *\n */\nstatic int eval_uac_routing(sip_msg_t *rpl, const struct retr_buf *inv_rb,\n\t\tstr* contact, struct rte **list, str *ruri, str *next_hop)\n{\n\tsip_msg_t orig_inv, *sipmsg; /* reparse original INVITE */\n\trte_t *t, *prev_t, *rtset = NULL;\n\tint is_req;\n\tstruct sip_uri puri;\n\tstatic size_t chklen;\n\n\t/* parse the retr. buffer */\n\tmemset(&orig_inv, 0, sizeof(struct sip_msg));\n\torig_inv.buf = inv_rb->buffer;\n\torig_inv.len = inv_rb->buffer_len;\n\tLM_DBG(\"reparsing retransmission buffer of original INVITE:\\n%.*s\\n\",\n\t\t\t(int)orig_inv.len, orig_inv.buf);\n\tif (parse_msg(orig_inv.buf, orig_inv.len, &orig_inv) != 0) {\n\t\tLM_ERR(\"failed to parse retr buffer (weird!): \\n%.*s\\n\",\n\t\t\t\t(int)orig_inv.len, orig_inv.buf);\n\t\treturn -1;\n\t}\n\n\t/* check if we need to look at request or reply */\n\tif ((parse_headers(&orig_inv, HDR_TO_F, 0) < 0) || (! orig_inv.to)) {\n\t\t/* the bug is at message assembly */\n\t\tLM_BUG(\"failed to parse INVITE retr. buffer and/or extract 'To' HF:\"\n\t\t\t\t\"\\n%.*s\\n\", (int)orig_inv.len, orig_inv.buf);\n\t\tgoto error;\n\t}\n\tif (((struct to_body *)orig_inv.to->parsed)->tag_value.len) {\n\t\tLM_DBG(\"building ACK for in-dialog INVITE (using RS in orig. INV.)\\n\");\n\t\tif (parse_headers(&orig_inv, HDR_EOH_F, 0) < 0) {\n\t\t\tLM_BUG(\"failed to parse INVITE retr. buffer to EOH:\"\n\t\t\t\t\t\"\\n%.*s\\n\", (int)orig_inv.len, orig_inv.buf);\n\t\t\tgoto error;\n\t\t}\n\t\tsipmsg = &orig_inv;\n\t\tis_req = 1;\n\t} else {\n\t\tLM_DBG(\"building ACK for out-of-dialog INVITE (using RS in RR set).\\n\");\n\t\tsipmsg = rpl;\n\t\tis_req = 0;\n\t}\n\n\t/* extract the route set */\n\tif (get_uac_rs(sipmsg, is_req, &rtset) < 0) {\n\t\tLM_ERR(\"failed to extract route set.\\n\");\n\t\tgoto error;\n\t}\n\n\tif (! rtset) { /* No routes */\n\t\t*ruri = *contact;\n\t\t*next_hop = *contact;\n\t} else if (! is_req) { /* out of dialog req. */\n\t\tif (parse_uri(rtset->ptr->nameaddr.uri.s, rtset->ptr->nameaddr.uri.len,\n\t\t\t\t&puri) < 0) {\n\t\t\tLM_ERR(\"failed to parse first route in set.\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (puri.lr.s) { /* Next hop is loose router */\n\t\t\t*ruri = *contact;\n\t\t\t*next_hop = rtset->ptr->nameaddr.uri;\n\t\t} else { /* Next hop is strict router */\n\t\t\t*ruri = rtset->ptr->nameaddr.uri;\n\t\t\t*next_hop = *ruri;\n\t\t\t/* consume first route, b/c it will be put in RURI */\n\t\t\tt = rtset;\n\t\t\trtset = rtset->next;\n\t\t\tpkg_free(t);\n\t\t}\n\t} else {\n\t\tunsigned long route_flags = inv_rb->flags;\n\t\tLM_DBG(\"UAC rb flags: 0x%x.\\n\", (unsigned int)route_flags);\neval_flags:\n\t\tswitch (route_flags & (F_RB_NH_LOOSE|F_RB_NH_STRICT)) {\n\t\tcase 0:\n\t\t\tLM_WARN(\"calculate_hooks() not called when built the local UAC of \"\n\t\t\t\t\t\"in-dialog request, or called with empty route set.\\n\");\n\t\t\t/* try to figure out what kind of hop is the next one\n\t\t\t * (strict/loose) by reading the original invite */\n\t\t\tif ((route_flags = nhop_type(&orig_inv, rtset, &inv_rb->dst,\n\t\t\t\t\tcontact))) {\n\t\t\t\tLM_DBG(\"original request's next hop type evaluated to: 0x%x.\\n\",\n\t\t\t\t\t\t(unsigned int)route_flags);\n\t\t\t\tgoto eval_flags;\n\t\t\t} else {\n\t\t\t\tLM_ERR(\"failed to establish what kind of router the next \"\n\t\t\t\t\t\t\"hop is.\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase F_RB_NH_LOOSE:\n\t\t\t*ruri = *contact;\n\t\t\t*next_hop = rtset->ptr->nameaddr.uri;\n\t\t\tbreak;\n\t\tcase F_RB_NH_STRICT:\n\t\t\t/* find ptr to last route body that contains the (possibly) old\n\t\t\t * remote target\n\t\t\t */\n\t\t\tfor (t = rtset, prev_t = NULL; t->next; prev_t = t, t = t->next)\n\t\t\t\t;\n\t\t\tif ((t->ptr->len == contact->len) &&\n\t\t\t\t\t(memcmp(t->ptr->nameaddr.name.s, contact->s,\n\t\t\t\t\t\t\tcontact->len) == 0)){\n\t\t\t\t/* the remote target didn't update -> keep the whole route set,\n\t\t\t\t * including the last entry */\n\t\t\t\t/* do nothing */\n\t\t\t} else {\n\t\t\t\t/* trash last entry and replace with new remote target */\n\t\t\t\tfree_rte_list(t);\n\t\t\t\t/* compact the rr_t struct along with rte. this way, free'ing\n\t\t\t\t * it can be done along with rte chunk, independent of Route\n\t\t\t\t * header parser's allocator (using pkg/shm) */\n\t\t\t\tchklen = sizeof(struct rte) + sizeof(rr_t);\n\t\t\t\tif (! (t = pkg_malloc(chklen))) {\n\t\t\t\t\tPKG_MEM_ERROR_FMT(\"(%d required)\\n\", (int)chklen);\n\t\t\t\t\t/* last element was freed, unlink it */\n\t\t\t\t\tif(prev_t == NULL) {\n\t\t\t\t\t\t/* there is only one elem in route set: the remote target */\n\t\t\t\t\t\trtset = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprev_t->next = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\t/* this way, .free_rr is also set to 0 (!!!) */\n\t\t\t\tmemset(t, 0, chklen);\n\t\t\t\t((rr_t *)&t[1])->nameaddr.name = *contact;\n\t\t\t\t((rr_t *)&t[1])->len = contact->len;\n\t\t\t\t/* chain the new route elem in set */\n\t\t\t\tif (prev_t == NULL)\n\t\t\t\t\t/* there is only one elem in route set: the remote target */\n\t\t\t\t\trtset = t;\n\t\t\t\telse\n\t\t\t\t\tprev_t->next = t;\n\t\t\t}\n\n\t\t\t*ruri = *GET_RURI(&orig_inv); /* reuse original RURI */\n\t\t\t*next_hop = *ruri;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* probably a mem corruption */\n\t\t\tLM_BUG(\"next hop of original request marked as both loose\"\n\t\t\t\t\t\" and strict router (buffer: %.*s).\\n\",\n\t\t\t\t\tinv_rb->buffer_len, inv_rb->buffer);\n#ifdef EXTRA_DEBUG\n\t\t\tabort();\n#else\n\t\t\tgoto error;\n#endif\n\t\t}\n\t}\n\n\t*list = rtset;\n\tfree_sip_msg(&orig_inv);\n\t/* all went well */\n\treturn 0;\n\nerror:\n\tfree_sip_msg(&orig_inv);\n\tif (rtset)\n\t\tfree_rte_list(rtset);\n\treturn -1;\n}\n\n/*\n * The function creates an ACK to 200 OK. Route set will be created\n * and parsed and the dst parameter will contain the destination to which\n * the request should be send. The function is used by tm when it\n * generates local ACK to 200 OK (on behalf of applications using uac)\n */\nchar *build_dlg_ack(struct sip_msg* rpl, struct cell *Trans,\n\t\t\t\t\tunsigned int branch, str *hdrs, str *body,\n\t\t\t\t\tunsigned int *len, struct dest_info* dst)\n{\n\tchar *req_buf, *p, *via;\n\tunsigned int via_len;\n\tchar branch_buf[MAX_BRANCH_PARAM_LEN];\n\tint branch_len;\n\tstr branch_str;\n\tstruct hostport hp;\n\tstruct rte* list;\n\tstr contact, ruri, *cont;\n\tstr next_hop;\n\tstr body_len;\n\tstr _to, *to = &_to;\n#ifdef USE_DNS_FAILOVER\n\tstruct dns_srv_handle dns_h;\n#endif\n\t/* With AS support, TM allows for external modules to generate building of\n\t * the ACK; in this case, the ACK's retransmission buffer is built once\n\t * and kept in memory (to help when retransmitted 2xx are received and ACK\n\t * must be resent).\n\t * Allocation of the string raw buffer that holds the ACK is piggy-backed\n\t * with allocation of the retransmission buffer (since both have the same\n\t * life-cycle): both the string buffer and retransm. buffer are placed\n\t * into the same allocated chunk of memory (retr. buffer first, string\n\t * buffer follows).In this case, the 'len' param is used as in-out\n\t * parameter: 'in' to give the extra space needed by the retr. buffer,\n\t * 'out' to return the length of the allocated string buffer.\n\t */\n\tunsigned offset = *len;\n\n\tif (parse_headers(rpl, HDR_EOH_F, 0) == -1 || !rpl->to) {\n\t\tLM_ERR(\"Error while parsing headers.\\n\");\n\t\treturn 0;\n\t} else {\n\t\t_to.s = rpl->to->name.s;\n\t\t_to.len = rpl->to->len;\n\t}\n\n\tif (get_contact_uri(rpl, &contact) < 0) {\n\t\treturn 0;\n\t}\n\n\tif (eval_uac_routing(rpl, &Trans->uac[branch].request, &contact,\n\t\t\t&list, &ruri, &next_hop) < 0) {\n\t\tLM_ERR(\"failed to evaluate routing elements.\\n\");\n\t\treturn 0;\n\t}\n\tLM_DBG(\"ACK RURI: `%.*s', NH: `%.*s'.\\n\", STR_FMT(&ruri),\n\t\t\tSTR_FMT(&next_hop));\n\n\tif ((contact.s != ruri.s) || (contact.len != ruri.len)) {\n\t\t/* contact != ruri means that the next\n\t\t * hop is a strict router, cont will be non-zero\n\t\t * and print_routeset will append it at the end\n\t\t * of the route set\n\t\t */\n\t\tcont = &contact;\n\t} else {\n\t\t/* Next hop is a loose router, nothing to append */\n\t\tcont = 0;\n\t}\n\n\t/* method, separators, version: \"ACK sip:p2@iptel.org SIP/2.0\" */\n\t*len = SIP_VERSION_LEN + ACK_LEN + 2 /* spaces */ + CRLF_LEN;\n\t*len += ruri.len;\n\n\t/* dst */\n\tswitch(cfg_get(tm, tm_cfg, local_ack_mode)){\n\t\tcase 1:\n\t\t\t/* send the local 200 ack to the same dst as the corresp. invite*/\n\t\t\t*dst=Trans->uac[branch].request.dst;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t/* send the local 200 ack to the same dst as the 200 reply source*/\n\t\t\tinit_dst_from_rcv(dst, &rpl->rcv);\n\t\t\tdst->send_flags=rpl->fwd_send_flags;\n\t\t\tbreak;\n\t\tcase 0:\n\t\tdefault:\n\t\t\t/* rfc conformant behaviour: use the next_hop determined from the\n\t\t\t * contact and the route set */\n#ifdef USE_DNS_FAILOVER\n\t\tif (cfg_get(core, core_cfg, use_dns_failover)){\n\t\t\tdns_srv_handle_init(&dns_h);\n\t\t\tif ((uri2dst(&dns_h , dst, rpl, &next_hop, PROTO_NONE)==0) ||\n\t\t\t\t\t(dst->send_sock==0)){\n\t\t\t\tdns_srv_handle_put(&dns_h);\n\t\t\t\tLM_ERR(\"no socket found\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tdns_srv_handle_put(&dns_h); /* not needed any more */\n\t\t}else{\n\t\t\tif ((uri2dst(0 , dst, rpl, &next_hop, PROTO_NONE)==0) ||\n\t\t\t\t\t(dst->send_sock==0)){\n\t\t\t\tLM_ERR(\"no socket found\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n#else /* USE_DNS_FAILOVER */\n\t\tif ( (uri2dst( dst, rpl, &next_hop, PROTO_NONE)==0) ||\n\t\t\t\t(dst->send_sock==0)){\n\t\t\tLM_ERR(\"no socket found\\n\");\n\t\t\tgoto error;\n\t\t}\n#endif /* USE_DNS_FAILOVER */\n\t\tbreak;\n\t}\n\n\t/* via */\n\tif (!t_calc_branch(Trans,  branch, branch_buf, &branch_len)) goto error;\n\tbranch_str.s = branch_buf;\n\tbranch_str.len = branch_len;\n\tset_hostport(&hp, 0);\n\tvia = via_builder(&via_len, NULL, dst, &branch_str, 0, &hp);\n\tif (!via) {\n\t\tLM_ERR(\"No via header got from builder\\n\");\n\t\tgoto error;\n\t}\n\t*len+= via_len;\n\n\t/* headers */\n\t*len += Trans->from.len + Trans->callid.len + to->len + Trans->cseq_n.len + 1 + ACK_LEN + CRLF_LEN;\n\n\t/* copy'n'paste Route headers */\n\n\t*len += calc_routeset_len(list, cont);\n\n\t/* User Agent */\n\tif (server_signature) *len += user_agent_hdr.len + CRLF_LEN;\n\t/* extra headers */\n\tif (hdrs)\n\t\t*len += hdrs->len;\n\t/* body */\n\tif (body) {\n\t\tbody_len.s = int2str(body->len, &body_len.len);\n\t\t*len += body->len;\n\t} else {\n\t\tbody_len.len = 0;\n\t\tbody_len.s = NULL; /*4gcc*/\n\t\t*len += 1; /* for the (Cont-Len:) `0' */\n\t}\n\t/* Content Length, EoM */\n\t*len += CONTENT_LENGTH_LEN + body_len.len + CRLF_LEN + CRLF_LEN;\n\n\treq_buf = shm_malloc(offset + *len + 1);\n\treq_buf += offset;\n\tif (!req_buf) {\n\t\tSHM_MEM_ERROR_FMT(\"required (%u+1)\\n\", *len);\n\t\tgoto error01;\n\t}\n\tp = req_buf;\n\n\tappend_str( p, ACK, ACK_LEN );\n\tappend_str( p, \" \", 1 );\n\tappend_str(p, ruri.s, ruri.len);\n\tappend_str( p, \" \" SIP_VERSION CRLF, 1 + SIP_VERSION_LEN + CRLF_LEN);\n\n\t/* insert our via */\n\tappend_str(p, via, via_len);\n\n\t/*other headers*/\n\tappend_str(p, Trans->from.s, Trans->from.len);\n\tappend_str(p, Trans->callid.s, Trans->callid.len);\n\tappend_str(p, to->s, to->len);\n\n\tappend_str(p, Trans->cseq_n.s, Trans->cseq_n.len);\n\tappend_str( p, \" \", 1 );\n\tappend_str( p, ACK, ACK_LEN);\n\tappend_str(p, CRLF, CRLF_LEN);\n\n\t/* Routeset */\n\tp = print_rs(p, list, cont);\n\n\t/* User Agent header */\n\tif (server_signature) {\n\t\tappend_str(p, user_agent_hdr.s, user_agent_hdr.len);\n\t\tappend_str(p, CRLF, CRLF_LEN);\n\t}\n\n\t/* extra headers */\n\tif (hdrs)\n\t\tappend_str(p, hdrs->s, hdrs->len);\n\n\t/* Content Length, EoH, (body) */\n\tif (body) {\n\t\tappend_str(p, CONTENT_LENGTH, CONTENT_LENGTH_LEN);\n\t\tappend_str(p, body_len.s, body_len.len);\n\t\tappend_str(p, /*end crr. header*/CRLF /*EoH*/CRLF, CRLF_LEN +\n\t\t\t\tCRLF_LEN);\n\t\tappend_str(p, body->s, body->len);\n\t} else {\n\t\tappend_str(p, CONTENT_LENGTH \"0\" CRLF CRLF,\n\t\t\t\tCONTENT_LENGTH_LEN + 1 + CRLF_LEN + CRLF_LEN);\n\t}\n\n\t/* EoM */\n\t*p = 0;\n\n\tpkg_free(via);\n\tfree_rte_list(list);\n\treturn req_buf;\n\nerror01:\n\tpkg_free(via);\nerror:\n\tfree_rte_list(list);\n\treturn 0;\n}\n\n\n/*\n * Convert length of body into asciiz\n */\nstatic inline int print_content_length(str* dest, str* body)\n{\n\tstatic char content_length[10];\n\tint len;\n\tint b_len;\n\tchar* tmp;\n\n\t/* Print Content-Length */\n\tb_len=body?body->len:0;\n\ttmp = int2str(b_len, &len);\n\tif (len >= sizeof(content_length)) {\n\t\tLM_ERR(\"content_len too big\\n\");\n\t\tdest->s = 0;\n\t\tdest->len = 0;\n\t\treturn -1;\n\t}\n\tmemcpy(content_length, tmp, len);\n\tdest->s = content_length;\n\tdest->len = len;\n\treturn 0;\n}\n\n\n/*\n * Convert CSeq number into asciiz\n */\nstatic inline int print_cseq_num(str* _s, dlg_t* _d)\n{\n\tstatic char cseq[INT2STR_MAX_LEN];\n\tchar* tmp;\n\tint len;\n\n\ttmp = int2str(_d->loc_seq.value, &len);\n\tif (len > sizeof(cseq)) {\n\t\tLM_ERR(\"cseq too big\\n\");\n\t\treturn -1;\n\t}\n\n\tmemcpy(cseq, tmp, len);\n\t_s->s = cseq;\n\t_s->len = len;\n\treturn 0;\n}\n\n\n/*\n * Create Via header\n */\nstatic inline int assemble_via(str* dest, struct cell* t,\n\t\t\t\t\t\t\t\tstruct dest_info* dst, int branch)\n{\n\tstatic char branch_buf[MAX_BRANCH_PARAM_LEN];\n\tchar* via;\n\tint len;\n\tunsigned int via_len;\n\tstr branch_str;\n\tstruct hostport hp;\n\n\tif (!t_calc_branch(t, branch, branch_buf, &len)) {\n\t\tLM_ERR(\"branch calculation failed\\n\");\n\t\treturn -1;\n\t}\n\n\tbranch_str.s = branch_buf;\n\tbranch_str.len = len;\n\n#ifdef XL_DEBUG\n\tprintf(\"!!!proto: %d\\n\", sock->proto);\n#endif\n\n\tset_hostport(&hp, 0);\n\tvia = via_builder(&via_len, NULL, dst, &branch_str, 0, &hp);\n\tif (!via) {\n\t\tLM_ERR(\"via building failed\\n\");\n\t\treturn -2;\n\t}\n\n\tdest->s = via;\n\tdest->len = via_len;\n\treturn 0;\n}\n\n\n/*\n * Print Request-URI\n */\nstatic inline char* print_request_uri(char* w, str* method, dlg_t* dialog,\n\t\tstruct cell* t, int branch)\n{\n\tmemapp(w, method->s, method->len);\n\tmemapp(w, \" \", 1);\n\n\tt->uac[branch].uri.s = w;\n\tt->uac[branch].uri.len = dialog->hooks.request_uri->len;\n\n\tmemapp(w, dialog->hooks.request_uri->s, dialog->hooks.request_uri->len);\n\tmemapp(w, \" \" SIP_VERSION CRLF, 1 + SIP_VERSION_LEN + CRLF_LEN);\n\n\treturn w;\n}\n\n\n/*\n * Print To header field\n */\nstatic inline char* print_to(char* w, dlg_t* dialog, struct cell* t, int bracket)\n{\n\tt->to.s = w;\n\tt->to.len = TO_LEN + dialog->rem_uri.len + CRLF_LEN\n\t\t+ (((dialog->rem_uri.s[dialog->rem_uri.len - 1]!='>'))?2:0);\n\n\tmemapp(w, TO, TO_LEN);\n\tif(bracket) memapp(w, \"<\", 1);\n\tmemapp(w, dialog->rem_uri.s, dialog->rem_uri.len);\n\tif(bracket) memapp(w, \">\", 1);\n\n\tif (dialog->id.rem_tag.len) {\n\t\tt->to.len += TOTAG_LEN + dialog->id.rem_tag.len ;\n\t\tmemapp(w, TOTAG, TOTAG_LEN);\n\t\tmemapp(w, dialog->id.rem_tag.s, dialog->id.rem_tag.len);\n\t}\n\n\tmemapp(w, CRLF, CRLF_LEN);\n\treturn w;\n}\n\n\n/*\n * Print From header field\n */\nstatic inline char* print_from(char* w, dlg_t* dialog, struct cell* t, int bracket)\n{\n\tt->from.s = w;\n\tt->from.len = FROM_LEN + dialog->loc_uri.len + CRLF_LEN\n\t\t+ ((dialog->loc_uri.s[dialog->loc_uri.len - 1]!='>')?2:0);\n\n\tmemapp(w, FROM, FROM_LEN);\n\tif(bracket) memapp(w, \"<\", 1);\n\tmemapp(w, dialog->loc_uri.s, dialog->loc_uri.len);\n\tif(bracket) memapp(w, \">\", 1);\n\n\tif (dialog->id.loc_tag.len) {\n\t\tt->from.len += FROMTAG_LEN + dialog->id.loc_tag.len;\n\t\tmemapp(w, FROMTAG, FROMTAG_LEN);\n\t\tmemapp(w, dialog->id.loc_tag.s, dialog->id.loc_tag.len);\n\t}\n\n\tmemapp(w, CRLF, CRLF_LEN);\n\treturn w;\n}\n\n\n/*\n * Print CSeq header field\n */\nchar* print_cseq_mini(char* target, str* cseq, str* method) {\n\tmemapp(target, CSEQ, CSEQ_LEN);\n\tmemapp(target, cseq->s, cseq->len);\n\tmemapp(target, \" \", 1);\n\tmemapp(target, method->s, method->len);\n\treturn target;\n}\n\nstatic inline char* print_cseq(char* w, str* cseq, str* method, struct cell* t)\n{\n\tt->cseq_n.s = w;\n\t/* don't include method name and CRLF -- subsequent\n\t * local requests ACK/CANCEL will add their own */\n\tt->cseq_n.len = CSEQ_LEN + cseq->len;\n\tw = print_cseq_mini(w, cseq, method);\n\treturn w;\n}\n\n/*\n * Print Call-ID header field\n * created an extra function for pure header field creation,\n * that is used by t_cancel for t_uac_cancel FIFO function.\n */\nchar* print_callid_mini(char* target, str callid) {\n\tmemapp(target, CALLID, CALLID_LEN);\n\tmemapp(target, callid.s, callid.len);\n\tmemapp(target, CRLF, CRLF_LEN);\n\treturn target;\n}\n\nstatic inline char* print_callid(char* w, dlg_t* dialog, struct cell* t)\n{\n\t/* begins with CRLF, not included in t->callid, don`t know why...?!? */\n\tmemapp(w, CRLF, CRLF_LEN);\n\tt->callid.s = w;\n\tt->callid.len = CALLID_LEN + dialog->id.call_id.len + CRLF_LEN;\n\n\tw = print_callid_mini(w, dialog->id.call_id);\n\treturn w;\n}\n\n\n/*\n * Create a request\n */\nchar* build_uac_req(str* method, str* headers, str* body, dlg_t* dialog,\n\t\tint branch, struct cell *t, int* len, struct dest_info* dst)\n{\n\tchar* buf, *w, *p;\n\tstr content_length, cseq, via;\n\tunsigned int maxfwd_len;\n\tint tbracket, fbracket;\n\tstr fromtag = STR_NULL;\n\tstr loc_tag = STR_NULL;\n\n\tif (!method || !dialog) {\n\t\tLM_ERR(\"invalid parameter value\\n\");\n\t\treturn 0;\n\t}\n\n\tif (dialog->id.loc_tag.len<=0) {\n\t\t/* From Tag is mandatory in RFC3261 - generate one if not provided */\n\t\tgenerate_fromtag(&fromtag, &dialog->id.call_id, &(dialog->rem_uri));\n\t\tloc_tag = dialog->id.loc_tag;\n\t\tdialog->id.loc_tag = fromtag;\n\t}\n\tif (print_content_length(&content_length, body) < 0) {\n\t\tLM_ERR(\"error while printing content-length\\n\");\n\t\treturn 0;\n\t}\n\tif (print_cseq_num(&cseq, dialog) < 0) {\n\t\tLM_ERR(\"error while printing CSeq number\\n\");\n\t\treturn 0;\n\t}\n\n\tif(headers==NULL || headers->len<15\n\t\t\t|| _strnstr(headers->s, \"Max-Forwards:\", headers->len)==NULL) {\n\t\tmaxfwd_len = MAXFWD_HEADER_LEN;\n\t} else {\n\t\tmaxfwd_len = 0;\n\t}\n\n\t*len = method->len + 1 + dialog->hooks.request_uri->len + 1\n\t\t+ SIP_VERSION_LEN + CRLF_LEN;\n\n\tif (assemble_via(&via, t, dst, branch) < 0) {\n\t\tLM_ERR(\"error while assembling Via\\n\");\n\t\treturn 0;\n\t}\n\t*len += via.len;\n\n\tif((p=q_memrchr(dialog->rem_uri.s, '>', dialog->rem_uri.len))!=NULL) {\n\t\tif((p==dialog->rem_uri.s + dialog->rem_uri.len - 1)\n\t\t\t\t|| *(p+1)==';') {\n\t\t\ttbracket = 0;\n\t\t} else {\n\t\t\ttbracket = 1;\n\t\t}\n\t} else {\n\t\ttbracket = 1;\n\t}\n\tif((p=q_memrchr(dialog->loc_uri.s, '>', dialog->loc_uri.len))!=NULL) {\n\t\tif((p==dialog->loc_uri.s + dialog->loc_uri.len - 1)\n\t\t\t\t|| *(p+1)==';') {\n\t\t\tfbracket = 0;\n\t\t} else {\n\t\t\tfbracket = 1;\n\t\t}\n\t} else {\n\t\tfbracket = 1;\n\t}\n\n\t*len += TO_LEN + dialog->rem_uri.len\n\t\t+ (dialog->id.rem_tag.len ? (TOTAG_LEN + dialog->id.rem_tag.len) : 0)\n\t\t+ CRLF_LEN;    /* To */\n\tif(tbracket) *len += 2; /* To-URI < > */\n\t*len += FROM_LEN + dialog->loc_uri.len\n\t\t+ (dialog->id.loc_tag.len ? (FROMTAG_LEN + dialog->id.loc_tag.len) : 0)\n\t\t+ CRLF_LEN;  /* From */\n\tif(fbracket) *len += 2; /* From-URI < > */\n\t*len += CALLID_LEN + dialog->id.call_id.len + CRLF_LEN;   /* Call-ID */\n\t*len += CSEQ_LEN + cseq.len + 1 + method->len + CRLF_LEN; /* CSeq */\n\t*len += calculate_routeset_length(dialog);                /* Route set */\n\t*len += maxfwd_len;                                       /* Max-forwards */\n\t*len += CONTENT_LENGTH_LEN + content_length.len\n\t\t\t\t\t\t\t\t\t\t\t+ CRLF_LEN; /* Content-Length */\n\t*len += ((server_signature && user_agent_hdr.len>0)\n\t\t\t\t\t\t? (user_agent_hdr.len + CRLF_LEN) : 0);\t/* Signature */\n\tif(headers && headers->len>2) {\n\t\t/* Additional headers */\n\t\t*len += headers->len;\n\t\t/* End of header if missing */\n\t\tif(headers->s[headers->len - 1] != '\\n')\n\t\t\t*len += CRLF_LEN;\n\t}\n\t*len += (body ? body->len : 0);                         /* Message body */\n\t*len += CRLF_LEN;                                       /* End of Header */\n\n\tbuf = shm_malloc(*len + 1);\n\tif (!buf) {\n\t\tSHM_MEM_ERROR_FMT(\"required (%d)\\n\", *len);\n\t\tgoto error;\n\t}\n\n\tw = buf;\n\n\tw = print_request_uri(w, method, dialog, t, branch);  /* Request-URI */\n\tmemapp(w, via.s, via.len);                            /* Top-most Via */\n\tw = print_to(w, dialog, t, tbracket);                 /* To */\n\tw = print_from(w, dialog, t, fbracket);               /* From */\n\tif(fromtag.len>0) {\n\t\tdialog->id.loc_tag = loc_tag;\n\t}\n\tw = print_cseq(w, &cseq, method, t);                  /* CSeq */\n\tw = print_callid(w, dialog, t);                       /* Call-ID */\n\tw = print_routeset(w, dialog);                        /* Route set */\n\n\tif(maxfwd_len>0)\n\t\tmemapp(w, MAXFWD_HEADER, MAXFWD_HEADER_LEN);      /* Max-forwards */\n\n\t/* Content-Length */\n\tmemapp(w, CONTENT_LENGTH, CONTENT_LENGTH_LEN);\n\tmemapp(w, content_length.s, content_length.len);\n\tmemapp(w, CRLF, CRLF_LEN);\n\n\t/* Server signature */\n\tif (server_signature && user_agent_hdr.len>0) {\n\t\tmemapp(w, user_agent_hdr.s, user_agent_hdr.len);\n\t\tmemapp(w, CRLF, CRLF_LEN);\n\t}\n\tif(headers && headers->len>2) {\n\t\tmemapp(w, headers->s, headers->len);\n\t\tif(headers->s[headers->len - 1] != '\\n')\n\t\t\tmemapp(w, CRLF, CRLF_LEN);\n\t}\n\tmemapp(w, CRLF, CRLF_LEN);\n\tif (body) memapp(w, body->s, body->len);\n\n#ifdef EXTRA_DEBUG\n\tassert(w-buf == *len);\n#endif\n\n\tmemapp(w, \"\\0\", 1);\n\n\tpkg_free(via.s);\n\treturn buf;\n\nerror:\n\tpkg_free(via.s);\n\treturn 0;\n}\n\n\nint t_calc_branch(struct cell *t,\n\tint b, char *branch, int *branch_len)\n{\n\treturn branch_builder( t->hash_index,\n\t\t\t0, t->md5,\n\t\t\tb, branch, branch_len );\n}\n\n/**\n * build CANCEL from UAC side\n */\nchar *build_uac_cancel(str *headers,str *body,struct cell *cancelledT,\n\t\tunsigned int branch, unsigned int *len, struct dest_info* dst)\n{\n\tchar *cancel_buf, *p;\n\tchar branch_buf[MAX_BRANCH_PARAM_LEN];\n\tstr branch_str;\n\tstruct hostport hp;\n\tstr content_length, via;\n\n\tLM_DBG(\"sing FROM=<%.*s>, TO=<%.*s>, CSEQ_N=<%.*s>\\n\",\n\t\tcancelledT->from.len, cancelledT->from.s, cancelledT->to.len,\n\t\tcancelledT->to.s, cancelledT->cseq_n.len, cancelledT->cseq_n.s);\n\n\tbranch_str.s=branch_buf;\n\tif (!t_calc_branch(cancelledT,  branch, branch_str.s, &branch_str.len )){\n\t\tLM_ERR(\"failed to create branch !\\n\");\n\t\tgoto error;\n\t}\n\tset_hostport(&hp,0);\n\n\tif (assemble_via(&via, cancelledT, dst, branch) < 0) {\n\t\tLM_ERR(\"Error while assembling Via\\n\");\n\t\treturn 0;\n\t}\n\n\t/* method, separators, version  */\n\t*len=CANCEL_LEN + 2 /* spaces */ +SIP_VERSION_LEN + CRLF_LEN;\n\t*len+=cancelledT->uac[branch].uri.len;\n\t/*via*/\n\t*len+= via.len;\n\t/*From*/\n\t*len+=cancelledT->from.len;\n\t/*To*/\n\t*len+=cancelledT->to.len;\n\t/*CallId*/\n\t*len+=cancelledT->callid.len;\n\t/*CSeq*/\n\t*len+=cancelledT->cseq_n.len+1+CANCEL_LEN+CRLF_LEN;\n\t/* User Agent */\n\tif (server_signature) {\n\t\t*len += USER_AGENT_LEN + CRLF_LEN;\n\t}\n\t/* Content Length  */\n\tif (print_content_length(&content_length, body) < 0) {\n\t\tLM_ERR(\"failed to print content-length\\n\");\n\t\treturn 0;\n\t}\n\t/* Content-Length */\n\t*len += (body ? (CONTENT_LENGTH_LEN + content_length.len + CRLF_LEN) : 0);\n\t/*Additional headers*/\n\t*len += (headers ? headers->len : 0);\n\t/*EoM*/\n\t*len+= CRLF_LEN;\n\t/* Message body */\n\t*len += (body ? body->len : 0);\n\n\tcancel_buf=shm_malloc( *len+1 );\n\tif (!cancel_buf)\n\t{\n\t\tSHM_MEM_ERROR;\n\t\tgoto error01;\n\t}\n\tp = cancel_buf;\n\n\tmemapp( p, CANCEL, CANCEL_LEN );\n\n\t*(p++) = ' ';\n\tmemapp( p, cancelledT->uac[branch].uri.s,\n\t\tcancelledT->uac[branch].uri.len);\n\tmemapp( p, \" \" SIP_VERSION CRLF, 1+SIP_VERSION_LEN+CRLF_LEN );\n\n\t/* insert our via */\n\tmemapp(p,via.s,via.len);\n\n\t/*other headers*/\n\tmemapp( p, cancelledT->from.s, cancelledT->from.len );\n\tmemapp( p, cancelledT->callid.s, cancelledT->callid.len );\n\tmemapp( p, cancelledT->to.s, cancelledT->to.len );\n\n\tmemapp( p, cancelledT->cseq_n.s, cancelledT->cseq_n.len );\n\t*(p++) = ' ';\n\tmemapp( p, CANCEL, CANCEL_LEN );\n\tmemapp( p, CRLF, CRLF_LEN );\n\n\t/* User Agent header */\n\tif (server_signature) {\n\t\tmemapp(p,USER_AGENT CRLF, USER_AGENT_LEN+CRLF_LEN );\n\t}\n\t/* Content Length*/\n\tif (body) {\n\t\tmemapp(p, CONTENT_LENGTH, CONTENT_LENGTH_LEN);\n\t\tmemapp(p, content_length.s, content_length.len);\n\t\tmemapp(p, CRLF, CRLF_LEN);\n\t}\n\tif(headers && headers->len){\n\t\tmemapp(p,headers->s,headers->len);\n\t}\n\t/*EoM*/\n\tmemapp(p,CRLF,CRLF_LEN);\n\tif(body && body->len){\n\t\tmemapp(p,body->s,body->len);\n\t}\n\t*p=0;\n\tpkg_free(via.s);\n\treturn cancel_buf;\nerror01:\n\tpkg_free(via.s);\nerror:\n\treturn NULL;\n}\n\n"], "filenames": ["src/modules/tm/t_msgbuilder.c"], "buggy_code_start_loc": [270], "buggy_code_end_loc": [497], "fixing_code_start_loc": [271], "fixing_code_end_loc": [529], "type": "CWE-120", "message": "The Kamailio SIP before 5.5.0 server mishandles INVITE requests with duplicated fields and overlength tag, leading to a buffer overflow that crashes the server or possibly have unspecified other impact.", "other": {"cve": {"id": "CVE-2020-27507", "sourceIdentifier": "cve@mitre.org", "published": "2023-03-15T20:15:10.283", "lastModified": "2023-05-30T19:15:09.483", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The Kamailio SIP before 5.5.0 server mishandles INVITE requests with duplicated fields and overlength tag, leading to a buffer overflow that crashes the server or possibly have unspecified other impact."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kamailio:kamailio:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.5.0", "matchCriteriaId": "A19355E8-CCDE-477C-A7F6-B5AAB6140C3B"}]}]}], "references": [{"url": "https://github.com/kamailio/kamailio/commit/ada3701d22b1fd579f06b4f54fa695fa988e685f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/kamailio/kamailio/issues/2503", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/05/msg00030.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/kamailio/kamailio/commit/ada3701d22b1fd579f06b4f54fa695fa988e685f"}}