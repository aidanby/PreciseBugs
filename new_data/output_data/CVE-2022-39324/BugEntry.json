{"buggy_code": ["import { css, cx } from '@emotion/css';\nimport React, { useEffect, useRef, useState } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\n\nimport { HorizontalGroup, Input } from '..';\nimport { useStyles2 } from '../../themes';\nimport { IconName } from '../../types/icon';\nimport { Button, ButtonVariant } from '../Button';\nimport { Modal } from '../Modal/Modal';\n\nexport interface ConfirmModalProps {\n  /** Toggle modal's open/closed state */\n  isOpen: boolean;\n  /** Title for the modal header */\n  title: string;\n  /** Modal content */\n  body: React.ReactNode;\n  /** Modal description */\n  description?: React.ReactNode;\n  /** Text for confirm button */\n  confirmText: string;\n  /** Text for dismiss button */\n  dismissText?: string;\n  /** Icon for the modal header */\n  icon?: IconName;\n  /** Additional styling for modal container */\n  modalClass?: string;\n  /** Text user needs to fill in before confirming */\n  confirmationText?: string;\n  /** Text for alternative button */\n  alternativeText?: string;\n  /** Confirm button variant */\n  confirmButtonVariant?: ButtonVariant;\n  /** Confirm action callback */\n  onConfirm(): void;\n  /** Dismiss action callback */\n  onDismiss(): void;\n  /** Alternative action callback */\n  onAlternative?(): void;\n}\n\nexport const ConfirmModal = ({\n  isOpen,\n  title,\n  body,\n  description,\n  confirmText,\n  confirmationText,\n  dismissText = 'Cancel',\n  alternativeText,\n  modalClass,\n  icon = 'exclamation-triangle',\n  onConfirm,\n  onDismiss,\n  onAlternative,\n  confirmButtonVariant = 'destructive',\n}: ConfirmModalProps): JSX.Element => {\n  const [disabled, setDisabled] = useState(Boolean(confirmationText));\n  const styles = useStyles2(getStyles);\n  const buttonRef = useRef<HTMLButtonElement>(null);\n  const onConfirmationTextChange = (event: React.FormEvent<HTMLInputElement>) => {\n    setDisabled(confirmationText?.localeCompare(event.currentTarget.value) !== 0);\n  };\n\n  useEffect(() => {\n    // for some reason autoFocus property did no work on this button, but this does\n    if (isOpen) {\n      buttonRef.current?.focus();\n    }\n  }, [isOpen]);\n\n  return (\n    <Modal className={cx(styles.modal, modalClass)} title={title} icon={icon} isOpen={isOpen} onDismiss={onDismiss}>\n      <div className={styles.modalText}>\n        {body}\n        {description ? <div className={styles.modalDescription}>{description}</div> : null}\n        {confirmationText ? (\n          <div className={styles.modalConfirmationInput}>\n            <HorizontalGroup>\n              <Input placeholder={`Type ${confirmationText} to confirm`} onChange={onConfirmationTextChange} />\n            </HorizontalGroup>\n          </div>\n        ) : null}\n      </div>\n      <Modal.ButtonRow>\n        <Button variant=\"secondary\" onClick={onDismiss} fill=\"outline\">\n          {dismissText}\n        </Button>\n        <Button\n          variant={confirmButtonVariant}\n          onClick={onConfirm}\n          disabled={disabled}\n          ref={buttonRef}\n          aria-label={selectors.pages.ConfirmModal.delete}\n        >\n          {confirmText}\n        </Button>\n        {onAlternative ? (\n          <Button variant=\"primary\" onClick={onAlternative}>\n            {alternativeText}\n          </Button>\n        ) : null}\n      </Modal.ButtonRow>\n    </Modal>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  modal: css`\n    width: 500px;\n  `,\n  modalText: css({\n    fontSize: theme.typography.h5.fontSize,\n    color: theme.colors.text.primary,\n  }),\n  modalDescription: css({\n    fontSize: theme.typography.body.fontSize,\n  }),\n  modalConfirmationInput: css({\n    paddingTop: theme.spacing(1),\n  }),\n});\n", "package api\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n\t\"github.com/grafana/grafana/pkg/infra/metrics\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/services/dashboards\"\n\t\"github.com/grafana/grafana/pkg/services/dashboardsnapshots\"\n\t\"github.com/grafana/grafana/pkg/services/guardian\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nvar client = &http.Client{\n\tTimeout:   time.Second * 5,\n\tTransport: &http.Transport{Proxy: http.ProxyFromEnvironment},\n}\n\n// swagger:route GET /snapshot/shared-options snapshots getSharingOptions\n//\n// Get snapshot sharing settings.\n//\n// Responses:\n// 200: getSharingOptionsResponse\n// 401: unauthorisedError\nfunc GetSharingOptions(c *models.ReqContext) {\n\tc.JSON(http.StatusOK, util.DynMap{\n\t\t\"externalSnapshotURL\":  setting.ExternalSnapshotUrl,\n\t\t\"externalSnapshotName\": setting.ExternalSnapshotName,\n\t\t\"externalEnabled\":      setting.ExternalEnabled,\n\t})\n}\n\ntype CreateExternalSnapshotResponse struct {\n\tKey       string `json:\"key\"`\n\tDeleteKey string `json:\"deleteKey\"`\n\tUrl       string `json:\"url\"`\n\tDeleteUrl string `json:\"deleteUrl\"`\n}\n\nfunc createExternalDashboardSnapshot(cmd dashboardsnapshots.CreateDashboardSnapshotCommand) (*CreateExternalSnapshotResponse, error) {\n\tvar createSnapshotResponse CreateExternalSnapshotResponse\n\tmessage := map[string]interface{}{\n\t\t\"name\":      cmd.Name,\n\t\t\"expires\":   cmd.Expires,\n\t\t\"dashboard\": cmd.Dashboard,\n\t\t\"key\":       cmd.Key,\n\t\t\"deleteKey\": cmd.DeleteKey,\n\t}\n\n\tmessageBytes, err := simplejson.NewFromAny(message).Encode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse, err := client.Post(setting.ExternalSnapshotUrl+\"/api/snapshots\", \"application/json\", bytes.NewBuffer(messageBytes))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() {\n\t\tif err := response.Body.Close(); err != nil {\n\t\t\tplog.Warn(\"Failed to close response body\", \"err\", err)\n\t\t}\n\t}()\n\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"create external snapshot response status code %d\", response.StatusCode)\n\t}\n\n\tif err := json.NewDecoder(response.Body).Decode(&createSnapshotResponse); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &createSnapshotResponse, nil\n}\n\n// swagger:route POST /snapshots snapshots createDashboardSnapshot\n//\n// When creating a snapshot using the API, you have to provide the full dashboard payload including the snapshot data. This endpoint is designed for the Grafana UI.\n//\n// Snapshot public mode should be enabled or authentication is required.\n//\n// Responses:\n// 200: createDashboardSnapshotResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) CreateDashboardSnapshot(c *models.ReqContext) response.Response {\n\tcmd := dashboardsnapshots.CreateDashboardSnapshotCommand{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tif cmd.Name == \"\" {\n\t\tcmd.Name = \"Unnamed snapshot\"\n\t}\n\n\tvar url string\n\tcmd.ExternalUrl = \"\"\n\tcmd.OrgId = c.OrgID\n\tcmd.UserId = c.UserID\n\n\tif cmd.External {\n\t\tif !setting.ExternalEnabled {\n\t\t\tc.JsonApiErr(http.StatusForbidden, \"External dashboard creation is disabled\", nil)\n\t\t\treturn nil\n\t\t}\n\n\t\tresponse, err := createExternalDashboardSnapshot(cmd)\n\t\tif err != nil {\n\t\t\tc.JsonApiErr(http.StatusInternalServerError, \"Failed to create external snapshot\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\turl = response.Url\n\t\tcmd.Key = response.Key\n\t\tcmd.DeleteKey = response.DeleteKey\n\t\tcmd.ExternalUrl = response.Url\n\t\tcmd.ExternalDeleteUrl = response.DeleteUrl\n\t\tcmd.Dashboard = simplejson.New()\n\n\t\tmetrics.MApiDashboardSnapshotExternal.Inc()\n\t} else {\n\t\tif cmd.Key == \"\" {\n\t\t\tvar err error\n\t\t\tcmd.Key, err = util.GetRandomString(32)\n\t\t\tif err != nil {\n\t\t\t\tc.JsonApiErr(http.StatusInternalServerError, \"Could not generate random string\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tif cmd.DeleteKey == \"\" {\n\t\t\tvar err error\n\t\t\tcmd.DeleteKey, err = util.GetRandomString(32)\n\t\t\tif err != nil {\n\t\t\t\tc.JsonApiErr(http.StatusInternalServerError, \"Could not generate random string\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\turl = setting.ToAbsUrl(\"dashboard/snapshot/\" + cmd.Key)\n\n\t\tmetrics.MApiDashboardSnapshotCreate.Inc()\n\t}\n\n\tif err := hs.dashboardsnapshotsService.CreateDashboardSnapshot(c.Req.Context(), &cmd); err != nil {\n\t\tc.JsonApiErr(http.StatusInternalServerError, \"Failed to create snapshot\", err)\n\t\treturn nil\n\t}\n\n\tc.JSON(http.StatusOK, util.DynMap{\n\t\t\"key\":       cmd.Key,\n\t\t\"deleteKey\": cmd.DeleteKey,\n\t\t\"url\":       url,\n\t\t\"deleteUrl\": setting.ToAbsUrl(\"api/snapshots-delete/\" + cmd.DeleteKey),\n\t\t\"id\":        cmd.Result.Id,\n\t})\n\treturn nil\n}\n\n// GET /api/snapshots/:key\n// swagger:route GET /snapshots/{key} snapshots getDashboardSnapshot\n//\n// Get Snapshot by Key.\n//\n// Responses:\n// 200: getDashboardSnapshotResponse\n// 400: badRequestError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) GetDashboardSnapshot(c *models.ReqContext) response.Response {\n\tkey := web.Params(c.Req)[\":key\"]\n\tif len(key) == 0 {\n\t\treturn response.Error(http.StatusBadRequest, \"Empty snapshot key\", nil)\n\t}\n\n\tquery := &dashboardsnapshots.GetDashboardSnapshotQuery{Key: key}\n\n\terr := hs.dashboardsnapshotsService.GetDashboardSnapshot(c.Req.Context(), query)\n\tif err != nil {\n\t\treturn response.Err(err)\n\t}\n\n\tsnapshot := query.Result\n\n\t// expired snapshots should also be removed from db\n\tif snapshot.Expires.Before(time.Now()) {\n\t\treturn response.Error(404, \"Dashboard snapshot not found\", err)\n\t}\n\n\tdto := dtos.DashboardFullWithMeta{\n\t\tDashboard: snapshot.Dashboard,\n\t\tMeta: dtos.DashboardMeta{\n\t\t\tType:       models.DashTypeSnapshot,\n\t\t\tIsSnapshot: true,\n\t\t\tCreated:    snapshot.Created,\n\t\t\tExpires:    snapshot.Expires,\n\t\t},\n\t}\n\n\tmetrics.MApiDashboardSnapshotGet.Inc()\n\n\treturn response.JSON(http.StatusOK, dto).SetHeader(\"Cache-Control\", \"public, max-age=3600\")\n}\n\nfunc deleteExternalDashboardSnapshot(externalUrl string) error {\n\tresponse, err := client.Get(externalUrl)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tif err := response.Body.Close(); err != nil {\n\t\t\tplog.Warn(\"Failed to close response body\", \"err\", err)\n\t\t}\n\t}()\n\n\tif response.StatusCode == 200 {\n\t\treturn nil\n\t}\n\n\t// Gracefully ignore \"snapshot not found\" errors as they could have already\n\t// been removed either via the cleanup script or by request.\n\tif response.StatusCode == 500 {\n\t\tvar respJson map[string]interface{}\n\t\tif err := json.NewDecoder(response.Body).Decode(&respJson); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif respJson[\"message\"] == \"Failed to get dashboard snapshot\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"unexpected response when deleting external snapshot, status code: %d\", response.StatusCode)\n}\n\n// swagger:route GET /snapshots-delete/{deleteKey} snapshots deleteDashboardSnapshotByDeleteKey\n//\n// Delete Snapshot by deleteKey.\n//\n// Snapshot public mode should be enabled or authentication is required.\n//\n// Responses:\n// 200: okResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) DeleteDashboardSnapshotByDeleteKey(c *models.ReqContext) response.Response {\n\tkey := web.Params(c.Req)[\":deleteKey\"]\n\tif len(key) == 0 {\n\t\treturn response.Error(404, \"Snapshot not found\", nil)\n\t}\n\n\tquery := &dashboardsnapshots.GetDashboardSnapshotQuery{DeleteKey: key}\n\terr := hs.dashboardsnapshotsService.GetDashboardSnapshot(c.Req.Context(), query)\n\tif err != nil {\n\t\treturn response.Err(err)\n\t}\n\n\tif query.Result.External {\n\t\terr := deleteExternalDashboardSnapshot(query.Result.ExternalDeleteUrl)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to delete external dashboard\", err)\n\t\t}\n\t}\n\n\tcmd := &dashboardsnapshots.DeleteDashboardSnapshotCommand{DeleteKey: query.Result.DeleteKey}\n\n\tif err := hs.dashboardsnapshotsService.DeleteDashboardSnapshot(c.Req.Context(), cmd); err != nil {\n\t\treturn response.Error(500, \"Failed to delete dashboard snapshot\", err)\n\t}\n\n\treturn response.JSON(http.StatusOK, util.DynMap{\n\t\t\"message\": \"Snapshot deleted. It might take an hour before it's cleared from any CDN caches.\",\n\t\t\"id\":      query.Result.Id,\n\t})\n}\n\n// swagger:route DELETE /snapshots/{key} snapshots deleteDashboardSnapshot\n//\n// Delete Snapshot by Key.\n//\n// Responses:\n// 200: okResponse\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) DeleteDashboardSnapshot(c *models.ReqContext) response.Response {\n\tkey := web.Params(c.Req)[\":key\"]\n\tif len(key) == 0 {\n\t\treturn response.Error(http.StatusNotFound, \"Snapshot not found\", nil)\n\t}\n\n\tquery := &dashboardsnapshots.GetDashboardSnapshotQuery{Key: key}\n\n\terr := hs.dashboardsnapshotsService.GetDashboardSnapshot(c.Req.Context(), query)\n\tif err != nil {\n\t\treturn response.Err(err)\n\t}\n\tif query.Result == nil {\n\t\treturn response.Error(http.StatusNotFound, \"Failed to get dashboard snapshot\", nil)\n\t}\n\n\tif query.Result.External {\n\t\terr := deleteExternalDashboardSnapshot(query.Result.ExternalDeleteUrl)\n\t\tif err != nil {\n\t\t\treturn response.Error(http.StatusInternalServerError, \"Failed to delete external dashboard\", err)\n\t\t}\n\t}\n\n\t// Dashboard can be empty (creation error or external snapshot). This means that the mustInt here returns a 0,\n\t// which before RBAC would result in a dashboard which has no ACL. A dashboard without an ACL would fallback\n\t// to the user\u2019s org role, which for editors and admins would essentially always be allowed here. With RBAC,\n\t// all permissions must be explicit, so the lack of a rule for dashboard 0 means the guardian will reject.\n\tdashboardID := query.Result.Dashboard.Get(\"id\").MustInt64()\n\n\tif dashboardID != 0 {\n\t\tguardian := guardian.New(c.Req.Context(), dashboardID, c.OrgID, c.SignedInUser)\n\t\tcanEdit, err := guardian.CanEdit()\n\t\t// check for permissions only if the dashboard is found\n\t\tif err != nil && !errors.Is(err, dashboards.ErrDashboardNotFound) {\n\t\t\treturn response.Error(http.StatusInternalServerError, \"Error while checking permissions for snapshot\", err)\n\t\t}\n\n\t\tif !canEdit && query.Result.UserId != c.SignedInUser.UserID && !errors.Is(err, dashboards.ErrDashboardNotFound) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Access denied to this snapshot\", nil)\n\t\t}\n\t}\n\n\tcmd := &dashboardsnapshots.DeleteDashboardSnapshotCommand{DeleteKey: query.Result.DeleteKey}\n\n\tif err := hs.dashboardsnapshotsService.DeleteDashboardSnapshot(c.Req.Context(), cmd); err != nil {\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to delete dashboard snapshot\", err)\n\t}\n\n\treturn response.JSON(http.StatusOK, util.DynMap{\n\t\t\"message\": \"Snapshot deleted. It might take an hour before it's cleared from any CDN caches.\",\n\t\t\"id\":      query.Result.Id,\n\t})\n}\n\n// swagger:route GET /dashboard/snapshots snapshots searchDashboardSnapshots\n//\n// List snapshots.\n//\n// Responses:\n// 200: searchDashboardSnapshotsResponse\n// 500: internalServerError\nfunc (hs *HTTPServer) SearchDashboardSnapshots(c *models.ReqContext) response.Response {\n\tquery := c.Query(\"query\")\n\tlimit := c.QueryInt(\"limit\")\n\n\tif limit == 0 {\n\t\tlimit = 1000\n\t}\n\n\tsearchQuery := dashboardsnapshots.GetDashboardSnapshotsQuery{\n\t\tName:         query,\n\t\tLimit:        limit,\n\t\tOrgId:        c.OrgID,\n\t\tSignedInUser: c.SignedInUser,\n\t}\n\n\terr := hs.dashboardsnapshotsService.SearchDashboardSnapshots(c.Req.Context(), &searchQuery)\n\tif err != nil {\n\t\treturn response.Error(500, \"Search failed\", err)\n\t}\n\n\tdtos := make([]*dashboardsnapshots.DashboardSnapshotDTO, len(searchQuery.Result))\n\tfor i, snapshot := range searchQuery.Result {\n\t\tdtos[i] = &dashboardsnapshots.DashboardSnapshotDTO{\n\t\t\tId:          snapshot.Id,\n\t\t\tName:        snapshot.Name,\n\t\t\tKey:         snapshot.Key,\n\t\t\tOrgId:       snapshot.OrgId,\n\t\t\tUserId:      snapshot.UserId,\n\t\t\tExternal:    snapshot.External,\n\t\t\tExternalUrl: snapshot.ExternalUrl,\n\t\t\tExpires:     snapshot.Expires,\n\t\t\tCreated:     snapshot.Created,\n\t\t\tUpdated:     snapshot.Updated,\n\t\t}\n\t}\n\n\treturn response.JSON(http.StatusOK, dtos)\n}\n\n// swagger:parameters createDashboardSnapshot\ntype CreateSnapshotParams struct {\n\t// in:body\n\t// required:true\n\tBody dashboardsnapshots.CreateDashboardSnapshotCommand `json:\"body\"`\n}\n\n// swagger:parameters searchDashboardSnapshots\ntype GetSnapshotsParams struct {\n\t// Search Query\n\t// in:query\n\tQuery string `json:\"query\"`\n\t// Limit the number of returned results\n\t// in:query\n\t// default:1000\n\tLimit int64 `json:\"limit\"`\n}\n\n// swagger:parameters getDashboardSnapshot\ntype GetDashboardSnapshotParams struct {\n\t// in:path\n\tKey string `json:\"key\"`\n}\n\n// swagger:parameters deleteDashboardSnapshot\ntype DeleteDashboardSnapshotParams struct {\n\t// in:path\n\tKey string `json:\"key\"`\n}\n\n// swagger:parameters deleteDashboardSnapshotByDeleteKey\ntype DeleteSnapshotByDeleteKeyParams struct {\n\t// in:path\n\tDeleteKey string `json:\"deleteKey\"`\n}\n\n// swagger:response createDashboardSnapshotResponse\ntype CreateSnapshotResponse struct {\n\t// in:body\n\tBody struct {\n\t\t// Unique key\n\t\tKey string `json:\"key\"`\n\t\t// Unique key used to delete the snapshot. It is different from the key so that only the creator can delete the snapshot.\n\t\tDeleteKey string `json:\"deleteKey\"`\n\t\tURL       string `json:\"url\"`\n\t\tDeleteUrl string `json:\"deleteUrl\"`\n\t\t// Snapshot id\n\t\tID int64 `json:\"id\"`\n\t} `json:\"body\"`\n}\n\n// swagger:response searchDashboardSnapshotsResponse\ntype SearchDashboardSnapshotsResponse struct {\n\t// in:body\n\tBody []*dashboardsnapshots.DashboardSnapshotDTO `json:\"body\"`\n}\n\n// swagger:response getDashboardSnapshotResponse\ntype GetDashboardSnapshotResponse DashboardResponse\n\n// swagger:response getSharingOptionsResponse\ntype GetSharingOptionsResponse struct {\n\t// in:body\n\tBody struct {\n\t\tExternalSnapshotURL  string `json:\"externalSnapshotURL\"`\n\t\tExternalSnapshotName string `json:\"externalSnapshotName\"`\n\t\tExternalEnabled      bool   `json:\"externalEnabled\"`\n\t} `json:\"body\"`\n}\n", "import React, { FC, ReactNode, useContext, useEffect } from 'react';\nimport { connect, ConnectedProps } from 'react-redux';\nimport { useLocation } from 'react-router-dom';\n\nimport { locationUtil, textUtil } from '@grafana/data';\nimport { selectors as e2eSelectors } from '@grafana/e2e-selectors/src';\nimport { locationService } from '@grafana/runtime';\nimport {\n  ButtonGroup,\n  ModalsController,\n  ToolbarButton,\n  PageToolbar,\n  useForceUpdate,\n  Tag,\n  ToolbarButtonRow,\n  ModalsContext,\n} from '@grafana/ui';\nimport { AppChromeUpdate } from 'app/core/components/AppChrome/AppChromeUpdate';\nimport { NavToolbarSeparator } from 'app/core/components/AppChrome/NavToolbarSeparator';\nimport config from 'app/core/config';\nimport { useGrafana } from 'app/core/context/GrafanaContext';\nimport { useBusEvent } from 'app/core/hooks/useBusEvent';\nimport { t, Trans } from 'app/core/internationalization';\nimport { DashboardCommentsModal } from 'app/features/dashboard/components/DashboardComments/DashboardCommentsModal';\nimport { SaveDashboardDrawer } from 'app/features/dashboard/components/SaveDashboard/SaveDashboardDrawer';\nimport { ShareModal } from 'app/features/dashboard/components/ShareModal';\nimport { playlistSrv } from 'app/features/playlist/PlaylistSrv';\nimport { updateTimeZoneForSession } from 'app/features/profile/state/reducers';\nimport { KioskMode } from 'app/types';\nimport { DashboardMetaChangedEvent } from 'app/types/events';\n\nimport { setStarred } from '../../../../core/reducers/navBarTree';\nimport { getDashboardSrv } from '../../services/DashboardSrv';\nimport { DashboardModel } from '../../state';\n\nimport { DashNavButton } from './DashNavButton';\nimport { DashNavTimeControls } from './DashNavTimeControls';\n\nconst mapDispatchToProps = {\n  setStarred,\n  updateTimeZoneForSession,\n};\n\nconst connector = connect(null, mapDispatchToProps);\n\nconst selectors = e2eSelectors.pages.Dashboard.DashNav;\n\nexport interface OwnProps {\n  dashboard: DashboardModel;\n  isFullscreen: boolean;\n  kioskMode?: KioskMode | null;\n  hideTimePicker: boolean;\n  folderTitle?: string;\n  title: string;\n  shareModalActiveTab?: string;\n  onAddPanel: () => void;\n}\n\ninterface DashNavButtonModel {\n  show: (props: Props) => boolean;\n  component: FC<Partial<Props>>;\n  index?: number | 'end';\n}\n\nconst customLeftActions: DashNavButtonModel[] = [];\nconst customRightActions: DashNavButtonModel[] = [];\n\nexport function addCustomLeftAction(content: DashNavButtonModel) {\n  customLeftActions.push(content);\n}\n\nexport function addCustomRightAction(content: DashNavButtonModel) {\n  customRightActions.push(content);\n}\n\ntype Props = OwnProps & ConnectedProps<typeof connector>;\n\nexport const DashNav = React.memo<Props>((props) => {\n  const forceUpdate = useForceUpdate();\n  const { chrome } = useGrafana();\n  const { showModal, hideModal } = useContext(ModalsContext);\n\n  // We don't really care about the event payload here only that it triggeres a re-render of this component\n  useBusEvent(props.dashboard.events, DashboardMetaChangedEvent);\n\n  const onStarDashboard = () => {\n    const dashboardSrv = getDashboardSrv();\n    const { dashboard, setStarred } = props;\n\n    dashboardSrv.starDashboard(dashboard.id, Boolean(dashboard.meta.isStarred)).then((newState) => {\n      setStarred({ id: dashboard.uid, title: dashboard.title, url: dashboard.meta.url ?? '', isStarred: newState });\n      dashboard.meta.isStarred = newState;\n      forceUpdate();\n    });\n  };\n\n  const onClose = () => {\n    locationService.partial({ viewPanel: null });\n  };\n\n  const onToggleTVMode = () => {\n    chrome.onToggleKioskMode();\n  };\n\n  const onOpenSettings = () => {\n    locationService.partial({ editview: 'settings' });\n  };\n\n  const onPlaylistPrev = () => {\n    playlistSrv.prev();\n  };\n\n  const onPlaylistNext = () => {\n    playlistSrv.next();\n  };\n\n  const onPlaylistStop = () => {\n    playlistSrv.stop();\n    forceUpdate();\n  };\n\n  const addCustomContent = (actions: DashNavButtonModel[], buttons: ReactNode[]) => {\n    actions.map((action, index) => {\n      const Component = action.component;\n      const element = <Component {...props} key={`button-custom-${index}`} />;\n      typeof action.index === 'number' ? buttons.splice(action.index, 0, element) : buttons.push(element);\n    });\n  };\n\n  const isPlaylistRunning = () => {\n    return playlistSrv.isPlaying;\n  };\n\n  // Open/Close\n  useEffect(() => {\n    const dashboard = props.dashboard;\n    const shareModalActiveTab = props.shareModalActiveTab;\n    const { canShare } = dashboard.meta;\n\n    if (canShare && shareModalActiveTab) {\n      // automagically open modal\n      showModal(ShareModal, {\n        dashboard,\n        onDismiss: hideModal,\n        activeTab: shareModalActiveTab,\n      });\n    }\n    return () => {\n      hideModal();\n    };\n  }, [showModal, hideModal, props.dashboard, props.shareModalActiveTab]);\n\n  const renderLeftActions = () => {\n    const { dashboard, kioskMode } = props;\n    const { canStar, canShare, isStarred } = dashboard.meta;\n    const buttons: ReactNode[] = [];\n\n    if (kioskMode || isPlaylistRunning()) {\n      return [];\n    }\n\n    if (canStar) {\n      let desc = isStarred\n        ? t('dashboard.toolbar.unmark-favorite', 'Unmark as favorite')\n        : t('dashboard.toolbar.mark-favorite', 'Mark as favorite');\n      buttons.push(\n        <DashNavButton\n          tooltip={desc}\n          icon={isStarred ? 'favorite' : 'star'}\n          iconType={isStarred ? 'mono' : 'default'}\n          iconSize=\"lg\"\n          onClick={onStarDashboard}\n          key=\"button-star\"\n        />\n      );\n    }\n\n    if (canShare) {\n      buttons.push(\n        <ModalsController key=\"button-share\">\n          {({ showModal, hideModal }) => (\n            <DashNavButton\n              tooltip={t('dashboard.toolbar.share', 'Share dashboard or panel')}\n              icon=\"share-alt\"\n              iconSize=\"lg\"\n              onClick={() => {\n                showModal(ShareModal, {\n                  dashboard,\n                  onDismiss: hideModal,\n                });\n              }}\n            />\n          )}\n        </ModalsController>\n      );\n    }\n\n    if (dashboard.meta.publicDashboardEnabled) {\n      buttons.push(\n        <Tag key=\"public-dashboard\" name=\"Public\" colorIndex={5} data-testid={selectors.publicDashboardTag}></Tag>\n      );\n    }\n\n    if (dashboard.uid && config.featureToggles.dashboardComments) {\n      buttons.push(\n        <ModalsController key=\"button-dashboard-comments\">\n          {({ showModal, hideModal }) => (\n            <DashNavButton\n              tooltip={t('dashboard.toolbar.comments-show', 'Show dashboard comments')}\n              icon=\"comment-alt-message\"\n              iconSize=\"lg\"\n              onClick={() => {\n                showModal(DashboardCommentsModal, {\n                  dashboard,\n                  onDismiss: hideModal,\n                });\n              }}\n            />\n          )}\n        </ModalsController>\n      );\n    }\n\n    addCustomContent(customLeftActions, buttons);\n    return buttons;\n  };\n\n  const renderPlaylistControls = () => {\n    return (\n      <ButtonGroup key=\"playlist-buttons\">\n        <ToolbarButton\n          tooltip={t('dashboard.toolbar.playlist-previous', 'Go to previous dashboard')}\n          icon=\"backward\"\n          onClick={onPlaylistPrev}\n          narrow\n        />\n        <ToolbarButton onClick={onPlaylistStop}>\n          <Trans i18nKey=\"dashboard.toolbar.playlist-stop\">Stop playlist</Trans>\n        </ToolbarButton>\n        <ToolbarButton\n          tooltip={t('dashboard.toolbar.playlist-next', 'Go to next dashboard')}\n          icon=\"forward\"\n          onClick={onPlaylistNext}\n          narrow\n        />\n      </ButtonGroup>\n    );\n  };\n\n  const renderTimeControls = () => {\n    const { dashboard, updateTimeZoneForSession, hideTimePicker } = props;\n\n    if (hideTimePicker) {\n      return null;\n    }\n\n    return (\n      <DashNavTimeControls dashboard={dashboard} onChangeTimeZone={updateTimeZoneForSession} key=\"time-controls\" />\n    );\n  };\n\n  const renderRightActions = () => {\n    const { dashboard, onAddPanel, isFullscreen, kioskMode } = props;\n    const { canSave, canEdit, showSettings } = dashboard.meta;\n    const { snapshot } = dashboard;\n    const snapshotUrl = snapshot && snapshot.originalUrl;\n    const buttons: ReactNode[] = [];\n    const tvButton = config.featureToggles.topnav ? null : (\n      <ToolbarButton\n        tooltip={t('dashboard.toolbar.tv-button', 'Cycle view mode')}\n        icon=\"monitor\"\n        onClick={onToggleTVMode}\n        key=\"tv-button\"\n      />\n    );\n\n    if (isPlaylistRunning()) {\n      return [renderPlaylistControls(), renderTimeControls()];\n    }\n\n    if (kioskMode === KioskMode.TV) {\n      return [renderTimeControls(), tvButton];\n    }\n\n    if (canEdit && !isFullscreen) {\n      buttons.push(\n        <ToolbarButton\n          tooltip={t('dashboard.toolbar.add-panel', 'Add panel')}\n          icon=\"panel-add\"\n          onClick={onAddPanel}\n          key=\"button-panel-add\"\n        />\n      );\n    }\n\n    if (canSave && !isFullscreen) {\n      buttons.push(\n        <ModalsController key=\"button-save\">\n          {({ showModal, hideModal }) => (\n            <ToolbarButton\n              tooltip={t('dashboard.toolbar.save', 'Save dashboard')}\n              icon=\"save\"\n              onClick={() => {\n                showModal(SaveDashboardDrawer, {\n                  dashboard,\n                  onDismiss: hideModal,\n                });\n              }}\n            />\n          )}\n        </ModalsController>\n      );\n    }\n\n    if (snapshotUrl) {\n      buttons.push(\n        <ToolbarButton\n          tooltip={t('dashboard.toolbar.open-original', 'Open original dashboard')}\n          onClick={() => gotoSnapshotOrigin(snapshotUrl)}\n          icon=\"link\"\n          key=\"button-snapshot\"\n        />\n      );\n    }\n\n    if (showSettings) {\n      buttons.push(\n        <ToolbarButton\n          tooltip={t('dashboard.toolbar.settings', 'Dashboard settings')}\n          icon=\"cog\"\n          onClick={onOpenSettings}\n          key=\"button-settings\"\n        />\n      );\n    }\n\n    addCustomContent(customRightActions, buttons);\n\n    buttons.push(renderTimeControls());\n    buttons.push(tvButton);\n\n    if (config.featureToggles.scenes) {\n      buttons.push(\n        <ToolbarButton\n          key=\"button-scenes\"\n          tooltip={'View as Scene'}\n          icon=\"apps\"\n          onClick={() => locationService.push(`/scenes/dashboard/${dashboard.uid}`)}\n        />\n      );\n    }\n    return buttons;\n  };\n\n  const gotoSnapshotOrigin = (snapshotUrl: string) => {\n    window.location.href = textUtil.sanitizeUrl(snapshotUrl);\n  };\n\n  const { isFullscreen, title, folderTitle } = props;\n  // this ensures the component rerenders when the location changes\n  const location = useLocation();\n  const titleHref = locationUtil.getUrlForPartial(location, { search: 'open' });\n  const parentHref = locationUtil.getUrlForPartial(location, { search: 'open', query: 'folder:current' });\n  const onGoBack = isFullscreen ? onClose : undefined;\n\n  if (config.featureToggles.topnav) {\n    return (\n      <AppChromeUpdate\n        actions={\n          <>\n            {renderLeftActions()}\n            <NavToolbarSeparator leftActionsSeparator />\n            <ToolbarButtonRow alignment=\"right\">{renderRightActions()}</ToolbarButtonRow>\n          </>\n        }\n      />\n    );\n  }\n\n  return (\n    <PageToolbar\n      pageIcon={isFullscreen ? undefined : 'apps'}\n      title={title}\n      parent={folderTitle}\n      titleHref={titleHref}\n      parentHref={parentHref}\n      onGoBack={onGoBack}\n      leftItems={renderLeftActions()}\n    >\n      {renderRightActions()}\n    </PageToolbar>\n  );\n});\n\nDashNav.displayName = 'DashNav';\n\nexport default connector(DashNav);\n", "import React, { PureComponent } from 'react';\n\nimport { SelectableValue } from '@grafana/data';\nimport { getBackendSrv, reportInteraction } from '@grafana/runtime';\nimport { Button, ClipboardButton, Field, Input, LinkButton, Modal, Select, Spinner } from '@grafana/ui';\nimport { t, Trans } from 'app/core/internationalization';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { DashboardModel, PanelModel } from 'app/features/dashboard/state';\n\nimport { VariableRefresh } from '../../../variables/types';\n\nimport { ShareModalTabProps } from './types';\n\nconst snapshotApiUrl = '/api/snapshots';\n\ninterface Props extends ShareModalTabProps {}\n\ninterface State {\n  isLoading: boolean;\n  step: number;\n  snapshotName: string;\n  selectedExpireOption: SelectableValue<number>;\n  snapshotExpires?: number;\n  snapshotUrl: string;\n  deleteUrl: string;\n  timeoutSeconds: number;\n  externalEnabled: boolean;\n  sharingButtonText: string;\n}\n\nexport class ShareSnapshot extends PureComponent<Props, State> {\n  private dashboard: DashboardModel;\n  private expireOptions: Array<SelectableValue<number>>;\n\n  constructor(props: Props) {\n    super(props);\n    this.dashboard = props.dashboard;\n    this.expireOptions = [\n      {\n        label: t('share-modal.snapshot.expire-never', `Never`),\n        value: 0,\n      },\n      {\n        label: t('share-modal.snapshot.expire-hour', `1 Hour`),\n        value: 60 * 60,\n      },\n      {\n        label: t('share-modal.snapshot.expire-day', `1 Day`),\n        value: 60 * 60 * 24,\n      },\n      {\n        label: t('share-modal.snapshot.expire-week', `7 Days`),\n        value: 60 * 60 * 24 * 7,\n      },\n    ];\n    this.state = {\n      isLoading: false,\n      step: 1,\n      selectedExpireOption: this.expireOptions[0],\n      snapshotExpires: this.expireOptions[0].value,\n      snapshotName: props.dashboard.title,\n      timeoutSeconds: 4,\n      snapshotUrl: '',\n      deleteUrl: '',\n      externalEnabled: false,\n      sharingButtonText: '',\n    };\n  }\n\n  componentDidMount() {\n    reportInteraction('grafana_dashboards_snapshot_share_viewed');\n    this.getSnaphotShareOptions();\n  }\n\n  async getSnaphotShareOptions() {\n    const shareOptions = await getBackendSrv().get('/api/snapshot/shared-options');\n    this.setState({\n      sharingButtonText: shareOptions['externalSnapshotName'],\n      externalEnabled: shareOptions['externalEnabled'],\n    });\n  }\n\n  createSnapshot = (external?: boolean) => () => {\n    const { timeoutSeconds } = this.state;\n    this.dashboard.snapshot = {\n      timestamp: new Date(),\n    };\n\n    if (!external) {\n      this.dashboard.snapshot.originalUrl = window.location.href;\n    }\n\n    this.setState({ isLoading: true });\n    this.dashboard.startRefresh();\n\n    setTimeout(() => {\n      this.saveSnapshot(this.dashboard, external);\n    }, timeoutSeconds * 1000);\n  };\n\n  saveSnapshot = async (dashboard: DashboardModel, external?: boolean) => {\n    const { snapshotExpires } = this.state;\n    const dash = this.dashboard.getSaveModelClone();\n    this.scrubDashboard(dash);\n\n    const cmdData = {\n      dashboard: dash,\n      name: dash.title,\n      expires: snapshotExpires,\n      external: external,\n    };\n\n    try {\n      const results: { deleteUrl: string; url: string } = await getBackendSrv().post(snapshotApiUrl, cmdData);\n      this.setState({\n        deleteUrl: results.deleteUrl,\n        snapshotUrl: results.url,\n        step: 2,\n      });\n    } finally {\n      reportInteraction('grafana_dashboards_snapshot_created', {\n        location: external ? 'raintank' : 'local',\n      });\n      this.setState({ isLoading: false });\n    }\n  };\n\n  scrubDashboard = (dash: DashboardModel) => {\n    const { panel } = this.props;\n    const { snapshotName } = this.state;\n    // change title\n    dash.title = snapshotName;\n\n    // make relative times absolute\n    dash.time = getTimeSrv().timeRange();\n\n    // Remove links\n    dash.links = [];\n\n    // remove panel queries & links\n    dash.panels.forEach((panel) => {\n      panel.targets = [];\n      panel.links = [];\n      panel.datasource = null;\n    });\n\n    // remove annotation queries\n    const annotations = dash.annotations.list.filter((annotation) => annotation.enable);\n    dash.annotations.list = annotations.map((annotation) => {\n      return {\n        name: annotation.name,\n        enable: annotation.enable,\n        iconColor: annotation.iconColor,\n        snapshotData: annotation.snapshotData,\n        type: annotation.type,\n        builtIn: annotation.builtIn,\n        hide: annotation.hide,\n      };\n    });\n\n    // remove template queries\n    dash.getVariables().forEach((variable: any) => {\n      variable.query = '';\n      variable.options = variable.current ? [variable.current] : [];\n      variable.refresh = VariableRefresh.never;\n    });\n\n    // snapshot single panel\n    if (panel) {\n      const singlePanel = panel.getSaveModel();\n      singlePanel.gridPos.w = 24;\n      singlePanel.gridPos.x = 0;\n      singlePanel.gridPos.y = 0;\n      singlePanel.gridPos.h = 20;\n      dash.panels = [singlePanel];\n    }\n\n    // cleanup snapshotData\n    delete this.dashboard.snapshot;\n    this.dashboard.forEachPanel((panel: PanelModel) => {\n      delete panel.snapshotData;\n    });\n    this.dashboard.annotations.list.forEach((annotation) => {\n      delete annotation.snapshotData;\n    });\n  };\n\n  deleteSnapshot = async () => {\n    const { deleteUrl } = this.state;\n    await getBackendSrv().get(deleteUrl);\n    this.setState({ step: 3 });\n  };\n\n  getSnapshotUrl = () => {\n    return this.state.snapshotUrl;\n  };\n\n  onSnapshotNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    this.setState({ snapshotName: event.target.value });\n  };\n\n  onTimeoutChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    this.setState({ timeoutSeconds: Number(event.target.value) });\n  };\n\n  onExpireChange = (option: SelectableValue<number>) => {\n    this.setState({\n      selectedExpireOption: option,\n      snapshotExpires: option.value,\n    });\n  };\n\n  renderStep1() {\n    const { onDismiss } = this.props;\n    const { snapshotName, selectedExpireOption, timeoutSeconds, isLoading, sharingButtonText, externalEnabled } =\n      this.state;\n\n    const snapshotNameTranslation = t('share-modal.snapshot.name', `Snapshot name`);\n    const expireTranslation = t('share-modal.snapshot.expire', `Expire`);\n    const timeoutTranslation = t('share-modal.snapshot.timeout', `Timeout (seconds)`);\n    const timeoutDescriptionTranslation = t(\n      'share-modal.snapshot.timeout-description',\n      `You might need to configure the timeout value if it takes a long time to collect your dashboard metrics.`\n    );\n\n    return (\n      <>\n        <div>\n          <p className=\"share-modal-info-text\">\n            <Trans i18nKey=\"share-modal.snapshot.info-text-1\">\n              A snapshot is an instant way to share an interactive dashboard publicly. When created, we strip sensitive\n              data like queries (metric, template, and annotation) and panel links, leaving only the visible metric data\n              and series names embedded in your dashboard.\n            </Trans>\n          </p>\n          <p className=\"share-modal-info-text\">\n            <Trans i18nKey=\"share-modal.snapshot.info-text-2\">\n              Keep in mind, your snapshot <em>can be viewed by anyone</em> that has the link and can access the URL.\n              Share wisely.\n            </Trans>\n          </p>\n        </div>\n        <Field label={snapshotNameTranslation}>\n          <Input id=\"snapshot-name-input\" width={30} value={snapshotName} onChange={this.onSnapshotNameChange} />\n        </Field>\n        <Field label={expireTranslation}>\n          <Select\n            inputId=\"expire-select-input\"\n            width={30}\n            options={this.expireOptions}\n            value={selectedExpireOption}\n            onChange={this.onExpireChange}\n          />\n        </Field>\n        <Field label={timeoutTranslation} description={timeoutDescriptionTranslation}>\n          <Input id=\"timeout-input\" type=\"number\" width={21} value={timeoutSeconds} onChange={this.onTimeoutChange} />\n        </Field>\n\n        <Modal.ButtonRow>\n          <Button variant=\"secondary\" onClick={onDismiss} fill=\"outline\">\n            <Trans i18nKey=\"share-modal.snapshot.cancel-button\">Cancel</Trans>\n          </Button>\n          {externalEnabled && (\n            <Button variant=\"secondary\" disabled={isLoading} onClick={this.createSnapshot(true)}>\n              {sharingButtonText}\n            </Button>\n          )}\n          <Button variant=\"primary\" disabled={isLoading} onClick={this.createSnapshot()}>\n            <Trans i18nKey=\"share-modal.snapshot.local-button\">Local Snapshot</Trans>\n          </Button>\n        </Modal.ButtonRow>\n      </>\n    );\n  }\n\n  renderStep2() {\n    const { snapshotUrl } = this.state;\n\n    return (\n      <>\n        <Field label={t('share-modal.snapshot.url-label', 'Snapshot URL')}>\n          <Input\n            id=\"snapshot-url-input\"\n            value={snapshotUrl}\n            readOnly\n            addonAfter={\n              <ClipboardButton icon=\"copy\" variant=\"primary\" getText={this.getSnapshotUrl}>\n                <Trans i18nKey=\"share-modal.snapshot.copy-link-button\">Copy</Trans>\n              </ClipboardButton>\n            }\n          />\n        </Field>\n\n        <div className=\"pull-right\" style={{ padding: '5px' }}>\n          <Trans i18nKey=\"share-modal.snapshot.mistake-message\">Did you make a mistake? </Trans>&nbsp;\n          <LinkButton fill=\"text\" target=\"_blank\" onClick={this.deleteSnapshot}>\n            <Trans i18nKey=\"share-modal.snapshot.delete-button\">Delete snapshot.</Trans>\n          </LinkButton>\n        </div>\n      </>\n    );\n  }\n\n  renderStep3() {\n    return (\n      <div className=\"share-modal-header\">\n        <p className=\"share-modal-info-text\">\n          <Trans i18nKey=\"share-modal.snapshot.deleted-message\">\n            The snapshot has been deleted. If you have already accessed it once, then it might take up to an hour before\n            before it is removed from browser caches or CDN caches.\n          </Trans>\n        </p>\n      </div>\n    );\n  }\n\n  render() {\n    const { isLoading, step } = this.state;\n\n    return (\n      <>\n        {step === 1 && this.renderStep1()}\n        {step === 2 && this.renderStep2()}\n        {step === 3 && this.renderStep3()}\n        {isLoading && <Spinner inline={true} />}\n      </>\n    );\n  }\n}\n"], "fixing_code": ["import { css, cx } from '@emotion/css';\nimport React, { useEffect, useRef, useState } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\n\nimport { HorizontalGroup, Input } from '..';\nimport { useStyles2 } from '../../themes';\nimport { IconName } from '../../types/icon';\nimport { Button, ButtonVariant } from '../Button';\nimport { Modal } from '../Modal/Modal';\n\nexport interface ConfirmModalProps {\n  /** Toggle modal's open/closed state */\n  isOpen: boolean;\n  /** Title for the modal header */\n  title: string;\n  /** Modal content */\n  body: React.ReactNode;\n  /** Modal description */\n  description?: React.ReactNode;\n  /** Text for confirm button */\n  confirmText: string;\n  /** Variant for confirm button */\n  confirmVariant?: ButtonVariant;\n  /** Text for dismiss button */\n  dismissText?: string;\n  /** Variant for dismiss button */\n  dismissVariant?: ButtonVariant;\n  /** Icon for the modal header */\n  icon?: IconName;\n  /** Additional styling for modal container */\n  modalClass?: string;\n  /** Text user needs to fill in before confirming */\n  confirmationText?: string;\n  /** Text for alternative button */\n  alternativeText?: string;\n  /** Confirm button variant */\n  confirmButtonVariant?: ButtonVariant;\n  /** Confirm action callback */\n  onConfirm(): void;\n  /** Dismiss action callback */\n  onDismiss(): void;\n  /** Alternative action callback */\n  onAlternative?(): void;\n}\n\nexport const ConfirmModal = ({\n  isOpen,\n  title,\n  body,\n  description,\n  confirmText,\n  confirmVariant = 'destructive',\n  confirmationText,\n  dismissText = 'Cancel',\n  dismissVariant = 'secondary',\n  alternativeText,\n  modalClass,\n  icon = 'exclamation-triangle',\n  onConfirm,\n  onDismiss,\n  onAlternative,\n  confirmButtonVariant = 'destructive',\n}: ConfirmModalProps): JSX.Element => {\n  const [disabled, setDisabled] = useState(Boolean(confirmationText));\n  const styles = useStyles2(getStyles);\n  const buttonRef = useRef<HTMLButtonElement>(null);\n  const onConfirmationTextChange = (event: React.FormEvent<HTMLInputElement>) => {\n    setDisabled(confirmationText?.localeCompare(event.currentTarget.value) !== 0);\n  };\n\n  useEffect(() => {\n    // for some reason autoFocus property did no work on this button, but this does\n    if (isOpen) {\n      buttonRef.current?.focus();\n    }\n  }, [isOpen]);\n\n  return (\n    <Modal className={cx(styles.modal, modalClass)} title={title} icon={icon} isOpen={isOpen} onDismiss={onDismiss}>\n      <div className={styles.modalText}>\n        {body}\n        {description ? <div className={styles.modalDescription}>{description}</div> : null}\n        {confirmationText ? (\n          <div className={styles.modalConfirmationInput}>\n            <HorizontalGroup>\n              <Input placeholder={`Type ${confirmationText} to confirm`} onChange={onConfirmationTextChange} />\n            </HorizontalGroup>\n          </div>\n        ) : null}\n      </div>\n      <Modal.ButtonRow>\n        <Button variant={dismissVariant} onClick={onDismiss} fill=\"outline\">\n          {dismissText}\n        </Button>\n        <Button\n          variant={confirmButtonVariant}\n          onClick={onConfirm}\n          disabled={disabled}\n          ref={buttonRef}\n          aria-label={selectors.pages.ConfirmModal.delete}\n        >\n          {confirmText}\n        </Button>\n        {onAlternative ? (\n          <Button variant=\"primary\" onClick={onAlternative}>\n            {alternativeText}\n          </Button>\n        ) : null}\n      </Modal.ButtonRow>\n    </Modal>\n  );\n};\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  modal: css`\n    width: 500px;\n  `,\n  modalText: css({\n    fontSize: theme.typography.h5.fontSize,\n    color: theme.colors.text.primary,\n  }),\n  modalDescription: css({\n    fontSize: theme.typography.body.fontSize,\n  }),\n  modalConfirmationInput: css({\n    paddingTop: theme.spacing(1),\n  }),\n});\n", "package api\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/grafana/grafana/pkg/api/dtos\"\n\t\"github.com/grafana/grafana/pkg/api/response\"\n\t\"github.com/grafana/grafana/pkg/components/simplejson\"\n\t\"github.com/grafana/grafana/pkg/infra/metrics\"\n\t\"github.com/grafana/grafana/pkg/models\"\n\t\"github.com/grafana/grafana/pkg/services/dashboards\"\n\t\"github.com/grafana/grafana/pkg/services/dashboardsnapshots\"\n\t\"github.com/grafana/grafana/pkg/services/guardian\"\n\t\"github.com/grafana/grafana/pkg/setting\"\n\t\"github.com/grafana/grafana/pkg/util\"\n\t\"github.com/grafana/grafana/pkg/web\"\n)\n\nvar client = &http.Client{\n\tTimeout:   time.Second * 5,\n\tTransport: &http.Transport{Proxy: http.ProxyFromEnvironment},\n}\n\n// swagger:route GET /snapshot/shared-options snapshots getSharingOptions\n//\n// Get snapshot sharing settings.\n//\n// Responses:\n// 200: getSharingOptionsResponse\n// 401: unauthorisedError\nfunc GetSharingOptions(c *models.ReqContext) {\n\tc.JSON(http.StatusOK, util.DynMap{\n\t\t\"externalSnapshotURL\":  setting.ExternalSnapshotUrl,\n\t\t\"externalSnapshotName\": setting.ExternalSnapshotName,\n\t\t\"externalEnabled\":      setting.ExternalEnabled,\n\t})\n}\n\ntype CreateExternalSnapshotResponse struct {\n\tKey       string `json:\"key\"`\n\tDeleteKey string `json:\"deleteKey\"`\n\tUrl       string `json:\"url\"`\n\tDeleteUrl string `json:\"deleteUrl\"`\n}\n\nfunc createExternalDashboardSnapshot(cmd dashboardsnapshots.CreateDashboardSnapshotCommand) (*CreateExternalSnapshotResponse, error) {\n\tvar createSnapshotResponse CreateExternalSnapshotResponse\n\tmessage := map[string]interface{}{\n\t\t\"name\":      cmd.Name,\n\t\t\"expires\":   cmd.Expires,\n\t\t\"dashboard\": cmd.Dashboard,\n\t\t\"key\":       cmd.Key,\n\t\t\"deleteKey\": cmd.DeleteKey,\n\t}\n\n\tmessageBytes, err := simplejson.NewFromAny(message).Encode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresponse, err := client.Post(setting.ExternalSnapshotUrl+\"/api/snapshots\", \"application/json\", bytes.NewBuffer(messageBytes))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer func() {\n\t\tif err := response.Body.Close(); err != nil {\n\t\t\tplog.Warn(\"Failed to close response body\", \"err\", err)\n\t\t}\n\t}()\n\n\tif response.StatusCode != 200 {\n\t\treturn nil, fmt.Errorf(\"create external snapshot response status code %d\", response.StatusCode)\n\t}\n\n\tif err := json.NewDecoder(response.Body).Decode(&createSnapshotResponse); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &createSnapshotResponse, nil\n}\n\nfunc createOriginalDashboardURL(appURL string, cmd *dashboardsnapshots.CreateDashboardSnapshotCommand) (string, error) {\n\tdashUID := cmd.Dashboard.Get(\"uid\").MustString(\"\")\n\tif ok := util.IsValidShortUID(dashUID); !ok {\n\t\treturn \"\", fmt.Errorf(\"invalid dashboard UID\")\n\t}\n\n\treturn fmt.Sprintf(\"/d/%v\", dashUID), nil\n}\n\n// swagger:route POST /snapshots snapshots createDashboardSnapshot\n//\n// When creating a snapshot using the API, you have to provide the full dashboard payload including the snapshot data. This endpoint is designed for the Grafana UI.\n//\n// Snapshot public mode should be enabled or authentication is required.\n//\n// Responses:\n// 200: createDashboardSnapshotResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 500: internalServerError\nfunc (hs *HTTPServer) CreateDashboardSnapshot(c *models.ReqContext) response.Response {\n\tcmd := dashboardsnapshots.CreateDashboardSnapshotCommand{}\n\tif err := web.Bind(c.Req, &cmd); err != nil {\n\t\treturn response.Error(http.StatusBadRequest, \"bad request data\", err)\n\t}\n\tif cmd.Name == \"\" {\n\t\tcmd.Name = \"Unnamed snapshot\"\n\t}\n\n\tvar snapshotUrl string\n\tcmd.ExternalUrl = \"\"\n\tcmd.OrgId = c.OrgID\n\tcmd.UserId = c.UserID\n\toriginalDashboardURL, err := createOriginalDashboardURL(hs.Cfg.AppURL, &cmd)\n\tif err != nil {\n\t\treturn response.Error(http.StatusInternalServerError, \"Invalid app URL\", err)\n\t}\n\n\tif cmd.External {\n\t\tif !setting.ExternalEnabled {\n\t\t\tc.JsonApiErr(http.StatusForbidden, \"External dashboard creation is disabled\", nil)\n\t\t\treturn nil\n\t\t}\n\n\t\tresponse, err := createExternalDashboardSnapshot(cmd)\n\t\tif err != nil {\n\t\t\tc.JsonApiErr(http.StatusInternalServerError, \"Failed to create external snapshot\", err)\n\t\t\treturn nil\n\t\t}\n\n\t\tsnapshotUrl = response.Url\n\t\tcmd.Key = response.Key\n\t\tcmd.DeleteKey = response.DeleteKey\n\t\tcmd.ExternalUrl = response.Url\n\t\tcmd.ExternalDeleteUrl = response.DeleteUrl\n\t\tcmd.Dashboard = simplejson.New()\n\n\t\tmetrics.MApiDashboardSnapshotExternal.Inc()\n\t} else {\n\t\tcmd.Dashboard.SetPath([]string{\"snapshot\", \"originalUrl\"}, originalDashboardURL)\n\n\t\tif cmd.Key == \"\" {\n\t\t\tvar err error\n\t\t\tcmd.Key, err = util.GetRandomString(32)\n\t\t\tif err != nil {\n\t\t\t\tc.JsonApiErr(http.StatusInternalServerError, \"Could not generate random string\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tif cmd.DeleteKey == \"\" {\n\t\t\tvar err error\n\t\t\tcmd.DeleteKey, err = util.GetRandomString(32)\n\t\t\tif err != nil {\n\t\t\t\tc.JsonApiErr(http.StatusInternalServerError, \"Could not generate random string\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tsnapshotUrl = setting.ToAbsUrl(\"dashboard/snapshot/\" + cmd.Key)\n\n\t\tmetrics.MApiDashboardSnapshotCreate.Inc()\n\t}\n\n\tif err := hs.dashboardsnapshotsService.CreateDashboardSnapshot(c.Req.Context(), &cmd); err != nil {\n\t\tc.JsonApiErr(http.StatusInternalServerError, \"Failed to create snapshot\", err)\n\t\treturn nil\n\t}\n\n\tc.JSON(http.StatusOK, util.DynMap{\n\t\t\"key\":       cmd.Key,\n\t\t\"deleteKey\": cmd.DeleteKey,\n\t\t\"url\":       snapshotUrl,\n\t\t\"deleteUrl\": setting.ToAbsUrl(\"api/snapshots-delete/\" + cmd.DeleteKey),\n\t\t\"id\":        cmd.Result.Id,\n\t})\n\treturn nil\n}\n\n// GET /api/snapshots/:key\n// swagger:route GET /snapshots/{key} snapshots getDashboardSnapshot\n//\n// Get Snapshot by Key.\n//\n// Responses:\n// 200: getDashboardSnapshotResponse\n// 400: badRequestError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) GetDashboardSnapshot(c *models.ReqContext) response.Response {\n\tkey := web.Params(c.Req)[\":key\"]\n\tif len(key) == 0 {\n\t\treturn response.Error(http.StatusBadRequest, \"Empty snapshot key\", nil)\n\t}\n\n\tquery := &dashboardsnapshots.GetDashboardSnapshotQuery{Key: key}\n\n\terr := hs.dashboardsnapshotsService.GetDashboardSnapshot(c.Req.Context(), query)\n\tif err != nil {\n\t\treturn response.Err(err)\n\t}\n\n\tsnapshot := query.Result\n\n\t// expired snapshots should also be removed from db\n\tif snapshot.Expires.Before(time.Now()) {\n\t\treturn response.Error(404, \"Dashboard snapshot not found\", err)\n\t}\n\n\tdto := dtos.DashboardFullWithMeta{\n\t\tDashboard: snapshot.Dashboard,\n\t\tMeta: dtos.DashboardMeta{\n\t\t\tType:       models.DashTypeSnapshot,\n\t\t\tIsSnapshot: true,\n\t\t\tCreated:    snapshot.Created,\n\t\t\tExpires:    snapshot.Expires,\n\t\t},\n\t}\n\n\tmetrics.MApiDashboardSnapshotGet.Inc()\n\n\treturn response.JSON(http.StatusOK, dto).SetHeader(\"Cache-Control\", \"public, max-age=3600\")\n}\n\nfunc deleteExternalDashboardSnapshot(externalUrl string) error {\n\tresponse, err := client.Get(externalUrl)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tif err := response.Body.Close(); err != nil {\n\t\t\tplog.Warn(\"Failed to close response body\", \"err\", err)\n\t\t}\n\t}()\n\n\tif response.StatusCode == 200 {\n\t\treturn nil\n\t}\n\n\t// Gracefully ignore \"snapshot not found\" errors as they could have already\n\t// been removed either via the cleanup script or by request.\n\tif response.StatusCode == 500 {\n\t\tvar respJson map[string]interface{}\n\t\tif err := json.NewDecoder(response.Body).Decode(&respJson); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif respJson[\"message\"] == \"Failed to get dashboard snapshot\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"unexpected response when deleting external snapshot, status code: %d\", response.StatusCode)\n}\n\n// swagger:route GET /snapshots-delete/{deleteKey} snapshots deleteDashboardSnapshotByDeleteKey\n//\n// Delete Snapshot by deleteKey.\n//\n// Snapshot public mode should be enabled or authentication is required.\n//\n// Responses:\n// 200: okResponse\n// 401: unauthorisedError\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) DeleteDashboardSnapshotByDeleteKey(c *models.ReqContext) response.Response {\n\tkey := web.Params(c.Req)[\":deleteKey\"]\n\tif len(key) == 0 {\n\t\treturn response.Error(404, \"Snapshot not found\", nil)\n\t}\n\n\tquery := &dashboardsnapshots.GetDashboardSnapshotQuery{DeleteKey: key}\n\terr := hs.dashboardsnapshotsService.GetDashboardSnapshot(c.Req.Context(), query)\n\tif err != nil {\n\t\treturn response.Err(err)\n\t}\n\n\tif query.Result.External {\n\t\terr := deleteExternalDashboardSnapshot(query.Result.ExternalDeleteUrl)\n\t\tif err != nil {\n\t\t\treturn response.Error(500, \"Failed to delete external dashboard\", err)\n\t\t}\n\t}\n\n\tcmd := &dashboardsnapshots.DeleteDashboardSnapshotCommand{DeleteKey: query.Result.DeleteKey}\n\n\tif err := hs.dashboardsnapshotsService.DeleteDashboardSnapshot(c.Req.Context(), cmd); err != nil {\n\t\treturn response.Error(500, \"Failed to delete dashboard snapshot\", err)\n\t}\n\n\treturn response.JSON(http.StatusOK, util.DynMap{\n\t\t\"message\": \"Snapshot deleted. It might take an hour before it's cleared from any CDN caches.\",\n\t\t\"id\":      query.Result.Id,\n\t})\n}\n\n// swagger:route DELETE /snapshots/{key} snapshots deleteDashboardSnapshot\n//\n// Delete Snapshot by Key.\n//\n// Responses:\n// 200: okResponse\n// 403: forbiddenError\n// 404: notFoundError\n// 500: internalServerError\nfunc (hs *HTTPServer) DeleteDashboardSnapshot(c *models.ReqContext) response.Response {\n\tkey := web.Params(c.Req)[\":key\"]\n\tif len(key) == 0 {\n\t\treturn response.Error(http.StatusNotFound, \"Snapshot not found\", nil)\n\t}\n\n\tquery := &dashboardsnapshots.GetDashboardSnapshotQuery{Key: key}\n\n\terr := hs.dashboardsnapshotsService.GetDashboardSnapshot(c.Req.Context(), query)\n\tif err != nil {\n\t\treturn response.Err(err)\n\t}\n\tif query.Result == nil {\n\t\treturn response.Error(http.StatusNotFound, \"Failed to get dashboard snapshot\", nil)\n\t}\n\n\tif query.Result.External {\n\t\terr := deleteExternalDashboardSnapshot(query.Result.ExternalDeleteUrl)\n\t\tif err != nil {\n\t\t\treturn response.Error(http.StatusInternalServerError, \"Failed to delete external dashboard\", err)\n\t\t}\n\t}\n\n\t// Dashboard can be empty (creation error or external snapshot). This means that the mustInt here returns a 0,\n\t// which before RBAC would result in a dashboard which has no ACL. A dashboard without an ACL would fallback\n\t// to the user\u2019s org role, which for editors and admins would essentially always be allowed here. With RBAC,\n\t// all permissions must be explicit, so the lack of a rule for dashboard 0 means the guardian will reject.\n\tdashboardID := query.Result.Dashboard.Get(\"id\").MustInt64()\n\n\tif dashboardID != 0 {\n\t\tguardian := guardian.New(c.Req.Context(), dashboardID, c.OrgID, c.SignedInUser)\n\t\tcanEdit, err := guardian.CanEdit()\n\t\t// check for permissions only if the dashboard is found\n\t\tif err != nil && !errors.Is(err, dashboards.ErrDashboardNotFound) {\n\t\t\treturn response.Error(http.StatusInternalServerError, \"Error while checking permissions for snapshot\", err)\n\t\t}\n\n\t\tif !canEdit && query.Result.UserId != c.SignedInUser.UserID && !errors.Is(err, dashboards.ErrDashboardNotFound) {\n\t\t\treturn response.Error(http.StatusForbidden, \"Access denied to this snapshot\", nil)\n\t\t}\n\t}\n\n\tcmd := &dashboardsnapshots.DeleteDashboardSnapshotCommand{DeleteKey: query.Result.DeleteKey}\n\n\tif err := hs.dashboardsnapshotsService.DeleteDashboardSnapshot(c.Req.Context(), cmd); err != nil {\n\t\treturn response.Error(http.StatusInternalServerError, \"Failed to delete dashboard snapshot\", err)\n\t}\n\n\treturn response.JSON(http.StatusOK, util.DynMap{\n\t\t\"message\": \"Snapshot deleted. It might take an hour before it's cleared from any CDN caches.\",\n\t\t\"id\":      query.Result.Id,\n\t})\n}\n\n// swagger:route GET /dashboard/snapshots snapshots searchDashboardSnapshots\n//\n// List snapshots.\n//\n// Responses:\n// 200: searchDashboardSnapshotsResponse\n// 500: internalServerError\nfunc (hs *HTTPServer) SearchDashboardSnapshots(c *models.ReqContext) response.Response {\n\tquery := c.Query(\"query\")\n\tlimit := c.QueryInt(\"limit\")\n\n\tif limit == 0 {\n\t\tlimit = 1000\n\t}\n\n\tsearchQuery := dashboardsnapshots.GetDashboardSnapshotsQuery{\n\t\tName:         query,\n\t\tLimit:        limit,\n\t\tOrgId:        c.OrgID,\n\t\tSignedInUser: c.SignedInUser,\n\t}\n\n\terr := hs.dashboardsnapshotsService.SearchDashboardSnapshots(c.Req.Context(), &searchQuery)\n\tif err != nil {\n\t\treturn response.Error(500, \"Search failed\", err)\n\t}\n\n\tdtos := make([]*dashboardsnapshots.DashboardSnapshotDTO, len(searchQuery.Result))\n\tfor i, snapshot := range searchQuery.Result {\n\t\tdtos[i] = &dashboardsnapshots.DashboardSnapshotDTO{\n\t\t\tId:          snapshot.Id,\n\t\t\tName:        snapshot.Name,\n\t\t\tKey:         snapshot.Key,\n\t\t\tOrgId:       snapshot.OrgId,\n\t\t\tUserId:      snapshot.UserId,\n\t\t\tExternal:    snapshot.External,\n\t\t\tExternalUrl: snapshot.ExternalUrl,\n\t\t\tExpires:     snapshot.Expires,\n\t\t\tCreated:     snapshot.Created,\n\t\t\tUpdated:     snapshot.Updated,\n\t\t}\n\t}\n\n\treturn response.JSON(http.StatusOK, dtos)\n}\n\n// swagger:parameters createDashboardSnapshot\ntype CreateSnapshotParams struct {\n\t// in:body\n\t// required:true\n\tBody dashboardsnapshots.CreateDashboardSnapshotCommand `json:\"body\"`\n}\n\n// swagger:parameters searchDashboardSnapshots\ntype GetSnapshotsParams struct {\n\t// Search Query\n\t// in:query\n\tQuery string `json:\"query\"`\n\t// Limit the number of returned results\n\t// in:query\n\t// default:1000\n\tLimit int64 `json:\"limit\"`\n}\n\n// swagger:parameters getDashboardSnapshot\ntype GetDashboardSnapshotParams struct {\n\t// in:path\n\tKey string `json:\"key\"`\n}\n\n// swagger:parameters deleteDashboardSnapshot\ntype DeleteDashboardSnapshotParams struct {\n\t// in:path\n\tKey string `json:\"key\"`\n}\n\n// swagger:parameters deleteDashboardSnapshotByDeleteKey\ntype DeleteSnapshotByDeleteKeyParams struct {\n\t// in:path\n\tDeleteKey string `json:\"deleteKey\"`\n}\n\n// swagger:response createDashboardSnapshotResponse\ntype CreateSnapshotResponse struct {\n\t// in:body\n\tBody struct {\n\t\t// Unique key\n\t\tKey string `json:\"key\"`\n\t\t// Unique key used to delete the snapshot. It is different from the key so that only the creator can delete the snapshot.\n\t\tDeleteKey string `json:\"deleteKey\"`\n\t\tURL       string `json:\"url\"`\n\t\tDeleteUrl string `json:\"deleteUrl\"`\n\t\t// Snapshot id\n\t\tID int64 `json:\"id\"`\n\t} `json:\"body\"`\n}\n\n// swagger:response searchDashboardSnapshotsResponse\ntype SearchDashboardSnapshotsResponse struct {\n\t// in:body\n\tBody []*dashboardsnapshots.DashboardSnapshotDTO `json:\"body\"`\n}\n\n// swagger:response getDashboardSnapshotResponse\ntype GetDashboardSnapshotResponse DashboardResponse\n\n// swagger:response getSharingOptionsResponse\ntype GetSharingOptionsResponse struct {\n\t// in:body\n\tBody struct {\n\t\tExternalSnapshotURL  string `json:\"externalSnapshotURL\"`\n\t\tExternalSnapshotName string `json:\"externalSnapshotName\"`\n\t\tExternalEnabled      bool   `json:\"externalEnabled\"`\n\t} `json:\"body\"`\n}\n", "import { css } from '@emotion/css';\nimport React, { FC, ReactNode, useContext, useEffect } from 'react';\nimport { connect, ConnectedProps } from 'react-redux';\nimport { useLocation } from 'react-router-dom';\n\nimport { locationUtil, textUtil } from '@grafana/data';\nimport { selectors as e2eSelectors } from '@grafana/e2e-selectors/src';\nimport { locationService } from '@grafana/runtime';\nimport {\n  ButtonGroup,\n  ModalsController,\n  ToolbarButton,\n  PageToolbar,\n  useForceUpdate,\n  Tag,\n  ToolbarButtonRow,\n  ModalsContext,\n  ConfirmModal,\n} from '@grafana/ui';\nimport { AppChromeUpdate } from 'app/core/components/AppChrome/AppChromeUpdate';\nimport { NavToolbarSeparator } from 'app/core/components/AppChrome/NavToolbarSeparator';\nimport config from 'app/core/config';\nimport { useGrafana } from 'app/core/context/GrafanaContext';\nimport { useAppNotification } from 'app/core/copy/appNotification';\nimport { appEvents } from 'app/core/core';\nimport { useBusEvent } from 'app/core/hooks/useBusEvent';\nimport { t, Trans } from 'app/core/internationalization';\nimport { DashboardCommentsModal } from 'app/features/dashboard/components/DashboardComments/DashboardCommentsModal';\nimport { SaveDashboardDrawer } from 'app/features/dashboard/components/SaveDashboard/SaveDashboardDrawer';\nimport { ShareModal } from 'app/features/dashboard/components/ShareModal';\nimport { playlistSrv } from 'app/features/playlist/PlaylistSrv';\nimport { updateTimeZoneForSession } from 'app/features/profile/state/reducers';\nimport { KioskMode } from 'app/types';\nimport { DashboardMetaChangedEvent, ShowModalReactEvent } from 'app/types/events';\n\nimport { setStarred } from '../../../../core/reducers/navBarTree';\nimport { getDashboardSrv } from '../../services/DashboardSrv';\nimport { DashboardModel } from '../../state';\n\nimport { DashNavButton } from './DashNavButton';\nimport { DashNavTimeControls } from './DashNavTimeControls';\n\nconst mapDispatchToProps = {\n  setStarred,\n  updateTimeZoneForSession,\n};\n\nconst connector = connect(null, mapDispatchToProps);\n\nconst selectors = e2eSelectors.pages.Dashboard.DashNav;\n\nexport interface OwnProps {\n  dashboard: DashboardModel;\n  isFullscreen: boolean;\n  kioskMode?: KioskMode | null;\n  hideTimePicker: boolean;\n  folderTitle?: string;\n  title: string;\n  shareModalActiveTab?: string;\n  onAddPanel: () => void;\n}\n\ninterface DashNavButtonModel {\n  show: (props: Props) => boolean;\n  component: FC<Partial<Props>>;\n  index?: number | 'end';\n}\n\nconst customLeftActions: DashNavButtonModel[] = [];\nconst customRightActions: DashNavButtonModel[] = [];\n\nexport function addCustomLeftAction(content: DashNavButtonModel) {\n  customLeftActions.push(content);\n}\n\nexport function addCustomRightAction(content: DashNavButtonModel) {\n  customRightActions.push(content);\n}\n\ntype Props = OwnProps & ConnectedProps<typeof connector>;\n\nexport const DashNav = React.memo<Props>((props) => {\n  const forceUpdate = useForceUpdate();\n  const { chrome } = useGrafana();\n  const { showModal, hideModal } = useContext(ModalsContext);\n\n  // We don't really care about the event payload here only that it triggeres a re-render of this component\n  useBusEvent(props.dashboard.events, DashboardMetaChangedEvent);\n\n  const originalUrl = props.dashboard.snapshot?.originalUrl ?? '';\n  const gotoSnapshotOrigin = () => {\n    window.location.href = textUtil.sanitizeUrl(props.dashboard.snapshot.originalUrl);\n  };\n\n  const notifyApp = useAppNotification();\n  const onOpenSnapshotOriginal = () => {\n    try {\n      const sanitizedUrl = new URL(textUtil.sanitizeUrl(originalUrl), config.appUrl);\n      const appUrl = new URL(config.appUrl);\n      if (sanitizedUrl.host !== appUrl.host) {\n        appEvents.publish(\n          new ShowModalReactEvent({\n            component: ConfirmModal,\n            props: {\n              title: 'Proceed to external site?',\n              modalClass: modalStyles,\n              body: (\n                <>\n                  <p>\n                    {`This link connects to an external website at`} <code>{originalUrl}</code>\n                  </p>\n                  <p>{\"Are you sure you'd like to proceed?\"}</p>\n                </>\n              ),\n              confirmVariant: 'primary',\n              confirmText: 'Proceed',\n              onConfirm: gotoSnapshotOrigin,\n            },\n          })\n        );\n      } else {\n        gotoSnapshotOrigin();\n      }\n    } catch (err) {\n      notifyApp.error('Invalid URL', err instanceof Error ? err.message : undefined);\n    }\n  };\n\n  const onStarDashboard = () => {\n    const dashboardSrv = getDashboardSrv();\n    const { dashboard, setStarred } = props;\n\n    dashboardSrv.starDashboard(dashboard.id, Boolean(dashboard.meta.isStarred)).then((newState) => {\n      setStarred({ id: dashboard.uid, title: dashboard.title, url: dashboard.meta.url ?? '', isStarred: newState });\n      dashboard.meta.isStarred = newState;\n      forceUpdate();\n    });\n  };\n\n  const onClose = () => {\n    locationService.partial({ viewPanel: null });\n  };\n\n  const onToggleTVMode = () => {\n    chrome.onToggleKioskMode();\n  };\n\n  const onOpenSettings = () => {\n    locationService.partial({ editview: 'settings' });\n  };\n\n  const onPlaylistPrev = () => {\n    playlistSrv.prev();\n  };\n\n  const onPlaylistNext = () => {\n    playlistSrv.next();\n  };\n\n  const onPlaylistStop = () => {\n    playlistSrv.stop();\n    forceUpdate();\n  };\n\n  const addCustomContent = (actions: DashNavButtonModel[], buttons: ReactNode[]) => {\n    actions.map((action, index) => {\n      const Component = action.component;\n      const element = <Component {...props} key={`button-custom-${index}`} />;\n      typeof action.index === 'number' ? buttons.splice(action.index, 0, element) : buttons.push(element);\n    });\n  };\n\n  const isPlaylistRunning = () => {\n    return playlistSrv.isPlaying;\n  };\n\n  // Open/Close\n  useEffect(() => {\n    const dashboard = props.dashboard;\n    const shareModalActiveTab = props.shareModalActiveTab;\n    const { canShare } = dashboard.meta;\n\n    if (canShare && shareModalActiveTab) {\n      // automagically open modal\n      showModal(ShareModal, {\n        dashboard,\n        onDismiss: hideModal,\n        activeTab: shareModalActiveTab,\n      });\n    }\n    return () => {\n      hideModal();\n    };\n  }, [showModal, hideModal, props.dashboard, props.shareModalActiveTab]);\n\n  const renderLeftActions = () => {\n    const { dashboard, kioskMode } = props;\n    const { canStar, canShare, isStarred } = dashboard.meta;\n    const buttons: ReactNode[] = [];\n\n    if (kioskMode || isPlaylistRunning()) {\n      return [];\n    }\n\n    if (canStar) {\n      let desc = isStarred\n        ? t('dashboard.toolbar.unmark-favorite', 'Unmark as favorite')\n        : t('dashboard.toolbar.mark-favorite', 'Mark as favorite');\n      buttons.push(\n        <DashNavButton\n          tooltip={desc}\n          icon={isStarred ? 'favorite' : 'star'}\n          iconType={isStarred ? 'mono' : 'default'}\n          iconSize=\"lg\"\n          onClick={onStarDashboard}\n          key=\"button-star\"\n        />\n      );\n    }\n\n    if (canShare) {\n      buttons.push(\n        <ModalsController key=\"button-share\">\n          {({ showModal, hideModal }) => (\n            <DashNavButton\n              tooltip={t('dashboard.toolbar.share', 'Share dashboard or panel')}\n              icon=\"share-alt\"\n              iconSize=\"lg\"\n              onClick={() => {\n                showModal(ShareModal, {\n                  dashboard,\n                  onDismiss: hideModal,\n                });\n              }}\n            />\n          )}\n        </ModalsController>\n      );\n    }\n\n    if (dashboard.meta.publicDashboardEnabled) {\n      buttons.push(\n        <Tag key=\"public-dashboard\" name=\"Public\" colorIndex={5} data-testid={selectors.publicDashboardTag}></Tag>\n      );\n    }\n\n    if (dashboard.uid && config.featureToggles.dashboardComments) {\n      buttons.push(\n        <ModalsController key=\"button-dashboard-comments\">\n          {({ showModal, hideModal }) => (\n            <DashNavButton\n              tooltip={t('dashboard.toolbar.comments-show', 'Show dashboard comments')}\n              icon=\"comment-alt-message\"\n              iconSize=\"lg\"\n              onClick={() => {\n                showModal(DashboardCommentsModal, {\n                  dashboard,\n                  onDismiss: hideModal,\n                });\n              }}\n            />\n          )}\n        </ModalsController>\n      );\n    }\n\n    addCustomContent(customLeftActions, buttons);\n    return buttons;\n  };\n\n  const renderPlaylistControls = () => {\n    return (\n      <ButtonGroup key=\"playlist-buttons\">\n        <ToolbarButton\n          tooltip={t('dashboard.toolbar.playlist-previous', 'Go to previous dashboard')}\n          icon=\"backward\"\n          onClick={onPlaylistPrev}\n          narrow\n        />\n        <ToolbarButton onClick={onPlaylistStop}>\n          <Trans i18nKey=\"dashboard.toolbar.playlist-stop\">Stop playlist</Trans>\n        </ToolbarButton>\n        <ToolbarButton\n          tooltip={t('dashboard.toolbar.playlist-next', 'Go to next dashboard')}\n          icon=\"forward\"\n          onClick={onPlaylistNext}\n          narrow\n        />\n      </ButtonGroup>\n    );\n  };\n\n  const renderTimeControls = () => {\n    const { dashboard, updateTimeZoneForSession, hideTimePicker } = props;\n\n    if (hideTimePicker) {\n      return null;\n    }\n\n    return (\n      <DashNavTimeControls dashboard={dashboard} onChangeTimeZone={updateTimeZoneForSession} key=\"time-controls\" />\n    );\n  };\n\n  const renderRightActions = () => {\n    const { dashboard, onAddPanel, isFullscreen, kioskMode } = props;\n    const { canSave, canEdit, showSettings } = dashboard.meta;\n    const { snapshot } = dashboard;\n    const snapshotUrl = snapshot && snapshot.originalUrl;\n    const buttons: ReactNode[] = [];\n    const tvButton = config.featureToggles.topnav ? null : (\n      <ToolbarButton\n        tooltip={t('dashboard.toolbar.tv-button', 'Cycle view mode')}\n        icon=\"monitor\"\n        onClick={onToggleTVMode}\n        key=\"tv-button\"\n      />\n    );\n\n    if (isPlaylistRunning()) {\n      return [renderPlaylistControls(), renderTimeControls()];\n    }\n\n    if (kioskMode === KioskMode.TV) {\n      return [renderTimeControls(), tvButton];\n    }\n\n    if (canEdit && !isFullscreen) {\n      buttons.push(\n        <ToolbarButton\n          tooltip={t('dashboard.toolbar.add-panel', 'Add panel')}\n          icon=\"panel-add\"\n          onClick={onAddPanel}\n          key=\"button-panel-add\"\n        />\n      );\n    }\n\n    if (canSave && !isFullscreen) {\n      buttons.push(\n        <ModalsController key=\"button-save\">\n          {({ showModal, hideModal }) => (\n            <ToolbarButton\n              tooltip={t('dashboard.toolbar.save', 'Save dashboard')}\n              icon=\"save\"\n              onClick={() => {\n                showModal(SaveDashboardDrawer, {\n                  dashboard,\n                  onDismiss: hideModal,\n                });\n              }}\n            />\n          )}\n        </ModalsController>\n      );\n    }\n\n    if (snapshotUrl) {\n      buttons.push(\n        <ToolbarButton\n          tooltip={t('dashboard.toolbar.open-original', 'Open original dashboard')}\n          onClick={onOpenSnapshotOriginal}\n          icon=\"link\"\n          key=\"button-snapshot\"\n        />\n      );\n    }\n\n    if (showSettings) {\n      buttons.push(\n        <ToolbarButton\n          tooltip={t('dashboard.toolbar.settings', 'Dashboard settings')}\n          icon=\"cog\"\n          onClick={onOpenSettings}\n          key=\"button-settings\"\n        />\n      );\n    }\n\n    addCustomContent(customRightActions, buttons);\n\n    buttons.push(renderTimeControls());\n    buttons.push(tvButton);\n\n    if (config.featureToggles.scenes) {\n      buttons.push(\n        <ToolbarButton\n          key=\"button-scenes\"\n          tooltip={'View as Scene'}\n          icon=\"apps\"\n          onClick={() => locationService.push(`/scenes/dashboard/${dashboard.uid}`)}\n        />\n      );\n    }\n    return buttons;\n  };\n\n  const { isFullscreen, title, folderTitle } = props;\n  // this ensures the component rerenders when the location changes\n  const location = useLocation();\n  const titleHref = locationUtil.getUrlForPartial(location, { search: 'open' });\n  const parentHref = locationUtil.getUrlForPartial(location, { search: 'open', query: 'folder:current' });\n  const onGoBack = isFullscreen ? onClose : undefined;\n\n  if (config.featureToggles.topnav) {\n    return (\n      <AppChromeUpdate\n        actions={\n          <>\n            {renderLeftActions()}\n            <NavToolbarSeparator leftActionsSeparator />\n            <ToolbarButtonRow alignment=\"right\">{renderRightActions()}</ToolbarButtonRow>\n          </>\n        }\n      />\n    );\n  }\n\n  return (\n    <PageToolbar\n      pageIcon={isFullscreen ? undefined : 'apps'}\n      title={title}\n      parent={folderTitle}\n      titleHref={titleHref}\n      parentHref={parentHref}\n      onGoBack={onGoBack}\n      leftItems={renderLeftActions()}\n    >\n      {renderRightActions()}\n    </PageToolbar>\n  );\n});\n\nDashNav.displayName = 'DashNav';\n\nexport default connector(DashNav);\n\nconst modalStyles = css({\n  width: 'max-content',\n  maxWidth: '80vw',\n});\n", "import React, { PureComponent } from 'react';\n\nimport { SelectableValue } from '@grafana/data';\nimport { getBackendSrv, reportInteraction } from '@grafana/runtime';\nimport { Button, ClipboardButton, Field, Input, LinkButton, Modal, Select, Spinner } from '@grafana/ui';\nimport { t, Trans } from 'app/core/internationalization';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { DashboardModel, PanelModel } from 'app/features/dashboard/state';\n\nimport { VariableRefresh } from '../../../variables/types';\n\nimport { ShareModalTabProps } from './types';\n\nconst snapshotApiUrl = '/api/snapshots';\n\ninterface Props extends ShareModalTabProps {}\n\ninterface State {\n  isLoading: boolean;\n  step: number;\n  snapshotName: string;\n  selectedExpireOption: SelectableValue<number>;\n  snapshotExpires?: number;\n  snapshotUrl: string;\n  deleteUrl: string;\n  timeoutSeconds: number;\n  externalEnabled: boolean;\n  sharingButtonText: string;\n}\n\nexport class ShareSnapshot extends PureComponent<Props, State> {\n  private dashboard: DashboardModel;\n  private expireOptions: Array<SelectableValue<number>>;\n\n  constructor(props: Props) {\n    super(props);\n    this.dashboard = props.dashboard;\n    this.expireOptions = [\n      {\n        label: t('share-modal.snapshot.expire-never', `Never`),\n        value: 0,\n      },\n      {\n        label: t('share-modal.snapshot.expire-hour', `1 Hour`),\n        value: 60 * 60,\n      },\n      {\n        label: t('share-modal.snapshot.expire-day', `1 Day`),\n        value: 60 * 60 * 24,\n      },\n      {\n        label: t('share-modal.snapshot.expire-week', `7 Days`),\n        value: 60 * 60 * 24 * 7,\n      },\n    ];\n    this.state = {\n      isLoading: false,\n      step: 1,\n      selectedExpireOption: this.expireOptions[0],\n      snapshotExpires: this.expireOptions[0].value,\n      snapshotName: props.dashboard.title,\n      timeoutSeconds: 4,\n      snapshotUrl: '',\n      deleteUrl: '',\n      externalEnabled: false,\n      sharingButtonText: '',\n    };\n  }\n\n  componentDidMount() {\n    reportInteraction('grafana_dashboards_snapshot_share_viewed');\n    this.getSnaphotShareOptions();\n  }\n\n  async getSnaphotShareOptions() {\n    const shareOptions = await getBackendSrv().get('/api/snapshot/shared-options');\n    this.setState({\n      sharingButtonText: shareOptions['externalSnapshotName'],\n      externalEnabled: shareOptions['externalEnabled'],\n    });\n  }\n\n  createSnapshot = (external?: boolean) => () => {\n    const { timeoutSeconds } = this.state;\n    this.dashboard.snapshot = {\n      timestamp: new Date(),\n    };\n\n    this.setState({ isLoading: true });\n    this.dashboard.startRefresh();\n\n    setTimeout(() => {\n      this.saveSnapshot(this.dashboard, external);\n    }, timeoutSeconds * 1000);\n  };\n\n  saveSnapshot = async (dashboard: DashboardModel, external?: boolean) => {\n    const { snapshotExpires } = this.state;\n    const dash = this.dashboard.getSaveModelClone();\n    this.scrubDashboard(dash);\n\n    const cmdData = {\n      dashboard: dash,\n      name: dash.title,\n      expires: snapshotExpires,\n      external: external,\n    };\n\n    try {\n      const results: { deleteUrl: string; url: string } = await getBackendSrv().post(snapshotApiUrl, cmdData);\n      this.setState({\n        deleteUrl: results.deleteUrl,\n        snapshotUrl: results.url,\n        step: 2,\n      });\n    } finally {\n      reportInteraction('grafana_dashboards_snapshot_created', {\n        location: external ? 'raintank' : 'local',\n      });\n      this.setState({ isLoading: false });\n    }\n  };\n\n  scrubDashboard = (dash: DashboardModel) => {\n    const { panel } = this.props;\n    const { snapshotName } = this.state;\n    // change title\n    dash.title = snapshotName;\n\n    // make relative times absolute\n    dash.time = getTimeSrv().timeRange();\n\n    // Remove links\n    dash.links = [];\n\n    // remove panel queries & links\n    dash.panels.forEach((panel) => {\n      panel.targets = [];\n      panel.links = [];\n      panel.datasource = null;\n    });\n\n    // remove annotation queries\n    const annotations = dash.annotations.list.filter((annotation) => annotation.enable);\n    dash.annotations.list = annotations.map((annotation) => {\n      return {\n        name: annotation.name,\n        enable: annotation.enable,\n        iconColor: annotation.iconColor,\n        snapshotData: annotation.snapshotData,\n        type: annotation.type,\n        builtIn: annotation.builtIn,\n        hide: annotation.hide,\n      };\n    });\n\n    // remove template queries\n    dash.getVariables().forEach((variable: any) => {\n      variable.query = '';\n      variable.options = variable.current ? [variable.current] : [];\n      variable.refresh = VariableRefresh.never;\n    });\n\n    // snapshot single panel\n    if (panel) {\n      const singlePanel = panel.getSaveModel();\n      singlePanel.gridPos.w = 24;\n      singlePanel.gridPos.x = 0;\n      singlePanel.gridPos.y = 0;\n      singlePanel.gridPos.h = 20;\n      dash.panels = [singlePanel];\n    }\n\n    // cleanup snapshotData\n    delete this.dashboard.snapshot;\n    this.dashboard.forEachPanel((panel: PanelModel) => {\n      delete panel.snapshotData;\n    });\n    this.dashboard.annotations.list.forEach((annotation) => {\n      delete annotation.snapshotData;\n    });\n  };\n\n  deleteSnapshot = async () => {\n    const { deleteUrl } = this.state;\n    await getBackendSrv().get(deleteUrl);\n    this.setState({ step: 3 });\n  };\n\n  getSnapshotUrl = () => {\n    return this.state.snapshotUrl;\n  };\n\n  onSnapshotNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    this.setState({ snapshotName: event.target.value });\n  };\n\n  onTimeoutChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    this.setState({ timeoutSeconds: Number(event.target.value) });\n  };\n\n  onExpireChange = (option: SelectableValue<number>) => {\n    this.setState({\n      selectedExpireOption: option,\n      snapshotExpires: option.value,\n    });\n  };\n\n  renderStep1() {\n    const { onDismiss } = this.props;\n    const { snapshotName, selectedExpireOption, timeoutSeconds, isLoading, sharingButtonText, externalEnabled } =\n      this.state;\n\n    const snapshotNameTranslation = t('share-modal.snapshot.name', `Snapshot name`);\n    const expireTranslation = t('share-modal.snapshot.expire', `Expire`);\n    const timeoutTranslation = t('share-modal.snapshot.timeout', `Timeout (seconds)`);\n    const timeoutDescriptionTranslation = t(\n      'share-modal.snapshot.timeout-description',\n      `You might need to configure the timeout value if it takes a long time to collect your dashboard metrics.`\n    );\n\n    return (\n      <>\n        <div>\n          <p className=\"share-modal-info-text\">\n            <Trans i18nKey=\"share-modal.snapshot.info-text-1\">\n              A snapshot is an instant way to share an interactive dashboard publicly. When created, we strip sensitive\n              data like queries (metric, template, and annotation) and panel links, leaving only the visible metric data\n              and series names embedded in your dashboard.\n            </Trans>\n          </p>\n          <p className=\"share-modal-info-text\">\n            <Trans i18nKey=\"share-modal.snapshot.info-text-2\">\n              Keep in mind, your snapshot <em>can be viewed by anyone</em> that has the link and can access the URL.\n              Share wisely.\n            </Trans>\n          </p>\n        </div>\n        <Field label={snapshotNameTranslation}>\n          <Input id=\"snapshot-name-input\" width={30} value={snapshotName} onChange={this.onSnapshotNameChange} />\n        </Field>\n        <Field label={expireTranslation}>\n          <Select\n            inputId=\"expire-select-input\"\n            width={30}\n            options={this.expireOptions}\n            value={selectedExpireOption}\n            onChange={this.onExpireChange}\n          />\n        </Field>\n        <Field label={timeoutTranslation} description={timeoutDescriptionTranslation}>\n          <Input id=\"timeout-input\" type=\"number\" width={21} value={timeoutSeconds} onChange={this.onTimeoutChange} />\n        </Field>\n\n        <Modal.ButtonRow>\n          <Button variant=\"secondary\" onClick={onDismiss} fill=\"outline\">\n            <Trans i18nKey=\"share-modal.snapshot.cancel-button\">Cancel</Trans>\n          </Button>\n          {externalEnabled && (\n            <Button variant=\"secondary\" disabled={isLoading} onClick={this.createSnapshot(true)}>\n              {sharingButtonText}\n            </Button>\n          )}\n          <Button variant=\"primary\" disabled={isLoading} onClick={this.createSnapshot()}>\n            <Trans i18nKey=\"share-modal.snapshot.local-button\">Local Snapshot</Trans>\n          </Button>\n        </Modal.ButtonRow>\n      </>\n    );\n  }\n\n  renderStep2() {\n    const { snapshotUrl } = this.state;\n\n    return (\n      <>\n        <Field label={t('share-modal.snapshot.url-label', 'Snapshot URL')}>\n          <Input\n            id=\"snapshot-url-input\"\n            value={snapshotUrl}\n            readOnly\n            addonAfter={\n              <ClipboardButton icon=\"copy\" variant=\"primary\" getText={this.getSnapshotUrl}>\n                <Trans i18nKey=\"share-modal.snapshot.copy-link-button\">Copy</Trans>\n              </ClipboardButton>\n            }\n          />\n        </Field>\n\n        <div className=\"pull-right\" style={{ padding: '5px' }}>\n          <Trans i18nKey=\"share-modal.snapshot.mistake-message\">Did you make a mistake? </Trans>&nbsp;\n          <LinkButton fill=\"text\" target=\"_blank\" onClick={this.deleteSnapshot}>\n            <Trans i18nKey=\"share-modal.snapshot.delete-button\">Delete snapshot.</Trans>\n          </LinkButton>\n        </div>\n      </>\n    );\n  }\n\n  renderStep3() {\n    return (\n      <div className=\"share-modal-header\">\n        <p className=\"share-modal-info-text\">\n          <Trans i18nKey=\"share-modal.snapshot.deleted-message\">\n            The snapshot has been deleted. If you have already accessed it once, then it might take up to an hour before\n            before it is removed from browser caches or CDN caches.\n          </Trans>\n        </p>\n      </div>\n    );\n  }\n\n  render() {\n    const { isLoading, step } = this.state;\n\n    return (\n      <>\n        {step === 1 && this.renderStep1()}\n        {step === 2 && this.renderStep2()}\n        {step === 3 && this.renderStep3()}\n        {isLoading && <Spinner inline={true} />}\n      </>\n    );\n  }\n}\n"], "filenames": ["packages/grafana-ui/src/components/ConfirmModal/ConfirmModal.tsx", "pkg/api/dashboard_snapshot.go", "public/app/features/dashboard/components/DashNav/DashNav.tsx", "public/app/features/dashboard/components/ShareModal/ShareSnapshot.tsx"], "buggy_code_start_loc": [23, 86, 0, 89], "buggy_code_end_loc": [89, 165, 397, 93], "fixing_code_start_loc": [24, 87, 1, 88], "fixing_code_end_loc": [95, 180, 442, 88], "type": "CWE-79", "message": "Grafana is an open-source platform for monitoring and observability. Prior to versions 8.5.16 and 9.2.8, malicious user can create a snapshot and arbitrarily choose the `originalUrl` parameter by editing the query, thanks to a web proxy. When another user opens the URL of the snapshot, they will be presented with the regular web interface delivered by the trusted Grafana server. The `Open original dashboard` button no longer points to the to the real original dashboard but to the attacker\u2019s injected URL. This issue is fixed in versions 8.5.16 and 9.2.8.", "other": {"cve": {"id": "CVE-2022-39324", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-27T23:15:08.723", "lastModified": "2023-02-07T20:17:46.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Grafana is an open-source platform for monitoring and observability. Prior to versions 8.5.16 and 9.2.8, malicious user can create a snapshot and arbitrarily choose the `originalUrl` parameter by editing the query, thanks to a web proxy. When another user opens the URL of the snapshot, they will be presented with the regular web interface delivered by the trusted Grafana server. The `Open original dashboard` button no longer points to the to the real original dashboard but to the attacker\u2019s injected URL. This issue is fixed in versions 8.5.16 and 9.2.8."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 5.5}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.5.16", "matchCriteriaId": "777B6454-25E4-4999-8CD8-650913FF7566"}, {"vulnerable": true, "criteria": "cpe:2.3:a:grafana:grafana:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.0.0", "versionEndExcluding": "9.2.8", "matchCriteriaId": "0A9BAE29-AD6B-44E0-9FCE-2857E432FE2A"}]}]}], "references": [{"url": "https://github.com/grafana/grafana/commit/239888f22983010576bb3a9135a7294e88c0c74a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/commit/d7dcea71ea763780dc286792a0afd560bff2985c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/pull/60232", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/pull/60256", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/grafana/grafana/security/advisories/GHSA-4724-7jwc-3fpw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/grafana/grafana/commit/239888f22983010576bb3a9135a7294e88c0c74a"}}