{"buggy_code": ["/********************************************************************\\\n * This program is free software; you can redistribute it and/or    *\n * modify it under the terms of the GNU General Public License as   *\n * published by the Free Software Foundation; either version 2 of   *\n * the License, or (at your option) any later version.              *\n *                                                                  *\n * This program is distributed in the hope that it will be useful,  *\n * but WITHOUT ANY WARRANTY; without even the implied warranty of   *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    *\n * GNU General Public License for more details.                     *\n *                                                                  *\n * You should have received a copy of the GNU General Public License*\n * along with this program; if not, contact:                        *\n *                                                                  *\n * Free Software Foundation           Voice:  +1-617-542-5942       *\n * 59 Temple Place - Suite 330        Fax:    +1-617-542-2652       *\n * Boston, MA  02111-1307,  USA       gnu@gnu.org                   *\n *                                                                  *\n \\********************************************************************/\n\n/** @file client_list.c\n  @brief Client List Functions\n  @author Copyright (C) 2004 Alexandre Carmel-Veillex <acv@acv.ca>\n  @author Copyright (C) 2007 Paul Kube <nodogsplash@kokoro.ucsd.edu>\n  @author Copyright (C) 2015-2023 Modifications and additions by BlueWave Projects and Services <opennds@blue-wave.net>\n */\n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <syslog.h>\n#include <errno.h>\n#include <pthread.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"safe.h\"\n#include \"debug.h\"\n#include \"conf.h\"\n#include \"common.h\"\n#include \"client_list.h\"\n#include \"http_microhttpd.h\"\n#include \"fw_iptables.h\"\n#include \"util.h\"\n\n\n// Client counter\nstatic int client_count = 0;\nstatic int client_id = 1;\n\n// Global mutex to protect access to the client list\npthread_mutex_t client_list_mutex = PTHREAD_MUTEX_INITIALIZER;\n\n/** @internal\n * Holds a pointer to the first element of the list\n */\nstatic t_client *firstclient = NULL;\n\n// Return current length of the client list\nint\nget_client_list_length()\n{\n\treturn client_count;\n}\n\n// Get the first element of the client list\nt_client *\nclient_get_first_client(void)\n{\n\treturn firstclient;\n}\n\n// Initialize the list of connected clients\nvoid\nclient_list_init(void)\n{\n\tfirstclient = NULL;\n\tclient_count = 0;\n}\n\n/** @internal\n * Given IP, MAC, and client token, appends a new entry\n * to the end of the client list and returns a pointer to the new entry.\n * All the memory allocation for a list entry is done here.\n * Checks for number of current clients.\n * Does not check for duplicate entries; so check before calling.\n * @param ip IP address\n * @param mac MAC address\n * @param token Token\n * @return Pointer to the client we just created\n */\nstatic t_client *\n_client_list_append(const char mac[], const char ip[])\n{\n\tt_client *client, *prevclient;\n\ts_config *config;\n\n\tconfig = config_get_config();\n\tif (client_count >= config->maxclients) {\n\t\tdebug(LOG_NOTICE, \"Already list %d clients, cannot add %s %s\", client_count, ip, mac);\n\t\treturn NULL;\n\t}\n\n\tprevclient = NULL;\n\tclient = firstclient;\n\n\twhile (client != NULL) {\n\t\tprevclient = client;\n\t\tclient = client->next;\n\t}\n\n\tclient = safe_calloc(sizeof(t_client));\n\n\tclient->mac = safe_strdup(mac);\n\tclient->ip = safe_strdup(ip);\n\n\t// Reset volatile fields and create new token\n\tclient_reset(client);\n\n\t// Trusted client does not trigger the splash page.\n\tif (is_trusted_mac(mac)) {\n\t\tclient->fw_connection_state = FW_MARK_TRUSTED;\n\t} else {\n\t\tclient->fw_connection_state = FW_MARK_PREAUTHENTICATED;\n\t}\n\n\tclient->id = client_id;\n\tclient->out_packet_limit = 0;\n\tclient->inc_packet_limit = 0;\n\n\tdebug(LOG_NOTICE, \"Adding %s %s token %s to client list\",\n\t\tclient->ip, client->mac, client->token ? client->token : \"none\");\n\n\tif (prevclient == NULL) {\n\t\tfirstclient = client;\n\t} else {\n\t\tprevclient->next = client;\n\t}\n\n\tclient_id++;\n\tclient_count++;\n\n\treturn client;\n}\n\n/** @internal\n *  Reset volatile fields\n */\nvoid client_reset(t_client *client)\n{\n\tchar *hash;\n\tchar *msg;\n\tchar *cidinfo;\n\n\tdebug(LOG_DEBUG, \"Resetting client [%s]\", client->mac);\n\t// Reset traffic counters\n\tclient->counters.incoming = 0;\n\tclient->counters.outgoing = 0;\n\tclient->counters.last_updated = time(NULL);\n\n\t// Reset session time\n\tclient->session_start = 0;\n\tclient->session_end = 0;\n\n\t// Reset token and hid\n\thash = safe_calloc(STATUS_BUF);\n\tclient->token = safe_calloc(STATUS_BUF);\n\tsafe_snprintf(client->token, STATUS_BUF, \"%04hx%04hx\", rand16(), rand16());\n\thash_str(hash, STATUS_BUF, client->token);\n\tclient->hid = safe_strdup(hash);\n\tfree(hash);\n\n\t// Reset custom and client_type\n\tclient->custom = safe_calloc(MID_BUF);\n\tclient->client_type = safe_calloc(STATUS_BUF);\n\n\t//Reset cid and remove cidfile using rmcid\n\tif (client->cid) {\n\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\n\t\tclient->cid = safe_calloc(SMALL_BUF);\n\t}\n\n}\n\n/**\n *  Given an IP address, add a client corresponding to that IP to client list.\n *  Return a pointer to the new client list entry, or to an existing entry\n *  if one with the given IP already exists.\n *  Return NULL if no new client entry can be created.\n */\nt_client *\nclient_list_add_client(const char mac[], const char ip[])\n{\n\tt_client *client;\n\n\tint rc = -1;\n\tchar *libcmd;\n\tchar *msg;\n\n\tif (!check_mac_format(mac)) {\n\t\t// Inappropriate format in IP address\n\t\tdebug(LOG_NOTICE, \"Illegal MAC format [%s]\", mac);\n\t\treturn NULL;\n\t}\n\n\tif (!check_ip_format(ip)) {\n\t\t// Inappropriate format in IP address\n\t\tdebug(LOG_NOTICE, \"Illegal IP format [%s]\", ip);\n\t\treturn NULL;\n\t}\n\n\t// check if client ip was allocated by dhcp\n\tlibcmd = safe_calloc(SMALL_BUF);\n\tsafe_snprintf(libcmd, SMALL_BUF, \"/usr/lib/opennds/libopennds.sh dhcpcheck \\\"%s\\\"\", ip);\n\tmsg = safe_calloc(SMALL_BUF);\n\trc = execute_ret_url_encoded(msg, SMALL_BUF, libcmd);\n\tfree(libcmd);\n\tfree(msg);\n\n\tif (rc > 0) {\n\t\t// IP address is not in the dhcp database\n\t\tdebug(LOG_NOTICE, \"IP not allocated by dhcp [%s]\", ip);\n\t\treturn NULL;\n\t}\n\n\tclient = client_list_find(mac, ip);\n\n\tif (!client) {\n\t\t// add the client\n\t\tclient = _client_list_append(mac, ip);\n\t} else {\n\t\tdebug(LOG_INFO, \"Client %s %s token %s already on client list\", ip, mac, client->token);\n\t}\n\n\treturn client;\n}\n\n/** Finds a client by its token, IP or MAC.\n * A found client is guaranteed to be unique.\n * @param ip IP we are looking for in the linked list\n * @param mac MAC we are looking for in the linked list\n * @return Pointer to the client, or NULL if not found\n */\nt_client *\nclient_list_find_by_any(const char mac[], const char ip[], const char token[])\n{\n\tt_client *client = NULL;\n\n\tif (!client && token) {\n\t\tclient = client_list_find_by_token(token);\n\t}\n\n\tif (!client && ip) {\n\t\tclient = client_list_find_by_ip(ip);\n\t}\n\n\tif (!client && mac) {\n\t\tclient = client_list_find_by_mac(mac);\n\t}\n\n\treturn client;\n}\n\nt_client *\nclient_list_find(const char mac[], const char ip[])\n{\n\tt_client *ptr;\n\n\tptr = firstclient;\n\twhile (ptr) {\n\t\tif (!strcmp(ptr->mac, mac) && !strcmp(ptr->ip, ip)) {\n\t\t\treturn ptr;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Finds a client by its IP address. Returns NULL if\n * the client could not be found.\n * @return Pointer to the client, or NULL if not found\n */\nt_client *\nclient_list_find_by_id(const unsigned id)\n{\n\tt_client *ptr;\n\n\tptr = firstclient;\n\twhile (ptr) {\n\t\tif (ptr->id == id) {\n\t\t\treturn ptr;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Finds a client by its IP address. Returns NULL if\n * the client could not be found.\n * @return Pointer to the client, or NULL if not found\n */\nt_client *\nclient_list_find_by_ip(const char ip[])\n{\n\tt_client *ptr;\n\n\tptr = firstclient;\n\twhile (ptr) {\n\t\tif (!strcmp(ptr->ip, ip)) {\n\t\t\treturn ptr;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Finds a client by its MAC address. Returns NULL if\n * the client could not be found.\n * @return Pointer to the client, or NULL if not found\n */\nt_client *\nclient_list_find_by_mac(const char mac[])\n{\n\tt_client *ptr;\n\n\tptr = firstclient;\n\twhile (ptr) {\n\t\tif (!strcmp(ptr->mac, mac)) {\n\t\t\treturn ptr;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Finds a client by token. Returns NULL if\n * the client could not be found.\n * @return Pointer to the client, or NULL if not found\n */\nt_client *\nclient_list_find_by_token(const char token[])\n{\n\tt_client *ptr;\n\ts_config *config;\n\tconfig = config_get_config();\n\tchar *rhid;\n\tchar *rhidraw = NULL;\n\n\tptr = firstclient;\n\n\twhile (ptr) {\n\t\t//Check if token (tok) or hash_id (hid) mode\n\t\tif (strlen(token) > 8) {\n\t\t\t// hid mode\n\t\t\trhidraw = safe_calloc(SMALL_BUF);\n\t\t\tsafe_snprintf(rhidraw, SMALL_BUF, \"%s%s\", ptr->hid, config->fas_key);\n\n\t\t\trhid = safe_calloc(SMALL_BUF);\n\t\t\thash_str(rhid, SMALL_BUF, rhidraw);\n\n\t\t\tfree(rhidraw);\n\n\t\t\tif (token && !strcmp(rhid, token)) {\n\t\t\t\t// rhid is valid\n\t\t\t\tfree (rhid);\n\t\t\t\treturn ptr;\n\t\t\t}\n\n\t\t\tfree(rhid);\n\n\t\t} else {\n\t\t\t// tok mode\n\t\t\tif (token && !strcmp(ptr->token, token)) {\n\t\t\t\t// Token is valid\n\t\t\t\treturn ptr;\n\t\t\t}\n\t\t}\n\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}\n\n/** @internal\n * @brief Frees the memory used by a t_client structure\n * This function frees the memory used by the t_client structure in the\n * proper order.\n * @param client Points to the client to be freed\n */\nstatic void\n_client_list_free_node(t_client *client)\n{\n\n\tchar *msg;\n\tchar *cidinfo;\n\n\tif (client->cid) {\n\n\t\t// Remove any existing cidfile:\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t}\n\n\tfree(client);\n}\n\n/**\n * @brief Deletes a client from the client list\n *\n * Removes the specified client from the client list and then calls\n * the function _client_list_free_node to free the memory taken by the client.\n * @param client Points to the client to be deleted\n */\nvoid\nclient_list_delete(t_client *client)\n{\n\tt_client *ptr;\n\n\tptr = firstclient;\n\n\tif (ptr == NULL) {\n\t\tdebug(LOG_ERR, \"Node list empty!\");\n\t} else if (ptr == client) {\n\t\tdebug(LOG_NOTICE, \"Deleting %s %s token %s from client list\",\n\t\t\t  client->ip, client->mac, client->token ? client->token : \"none\");\n\t\tfirstclient = ptr->next;\n\t\t_client_list_free_node(client);\n\t\tclient_count--;\n\t} else {\n\t\t// Loop forward until we reach our point in the list.\n\t\twhile (ptr->next != NULL && ptr->next != client) {\n\t\t\tptr = ptr->next;\n\t\t}\n\t\t// If we reach the end before finding out element, complain.\n\t\tif (ptr->next == NULL) {\n\t\t\tdebug(LOG_ERR, \"Node to delete could not be found.\");\n\t\t} else {\n\t\t\t// Free element.\n\t\t\tdebug(LOG_NOTICE, \"Deleting %s %s token %s from client list\",\n\t\t\t\t  client->ip, client->mac, client->token ? client->token : \"none\");\n\t\t\tptr->next = client->next;\n\t\t\t_client_list_free_node(client);\n\t\t\tclient_count--;\n\t\t}\n\t}\n}\n", "/************************************************************************\\\n * This program is free software; you can redistribute it and/or\t*\n * modify it under the terms of the GNU General Public License as\t*\n * published by the Free:Software Foundation; either version 2 of\t*\n * the License, or (at your option) any later version.\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n * This program is distributed in the hope that it will be useful,\t*\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\t*\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t\t*\n * See the GNU General Public License for more details.\t\t*\n\\************************************************************************/\n\n/** @internal\n * @file http_microhttpd.c\n * @brief a httpd implementation using libmicrohttpd\n * @author Copyright (C) 2015 Alexander Couzens <lynxis@fe80.eu>\n * @author Copyright (C) 2015-2023 The openNDS contributors <opennds@blue-wave.net>\n * @author Copyright (C) 2015-2023 Modifications and additions by BlueWave Projects and Services <opennds@blue-wave.net>\n */\n\n\n#include <microhttpd.h>\n#include <syslog.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <pthread.h>\n#include <linux/limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include \"client_list.h\"\n#include \"conf.h\"\n#include \"common.h\"\n#include \"debug.h\"\n#include \"auth.h\"\n#include \"http_microhttpd.h\"\n#include \"http_microhttpd_utils.h\"\n#include \"fw_iptables.h\"\n#include \"mimetypes.h\"\n#include \"safe.h\"\n#include \"util.h\"\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n\n// Max length of a query string QUERYMAXLEN in bytes defined in common.h\n\n// Max dynamic html page size HTMLMAXSIZE in bytes defined in common.h\n\n\nstatic t_client *add_client(const char mac[], const char ip[]);\nstatic int authenticated(struct MHD_Connection *connection, const char *url, t_client *client);\nstatic int preauthenticated(struct MHD_Connection *connection, const char *url, t_client *client);\nstatic int authenticate_client(struct MHD_Connection *connection, const char *redirect_url, t_client *client);\nstatic enum MHD_Result get_host_value_callback(void *cls, enum MHD_ValueKind kind, const char *key, const char *value);\nstatic enum MHD_Result get_user_agent_callback(void *cls, enum MHD_ValueKind kind, const char *key, const char *value);\nstatic enum MHD_Result get_accept_callback(void *cls, enum MHD_ValueKind kind, const char *key, const char *value);\nstatic int serve_file(struct MHD_Connection *connection, t_client *client, const char *url);\nstatic int show_preauthpage(struct MHD_Connection *connection, const char *query);\nstatic int send_json(struct MHD_Connection *connection, const char *json);\nstatic int encode_and_redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *originurl, const char *querystr);\nstatic int redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *host, const char *url);\nstatic int send_error(struct MHD_Connection *connection, int error);\nstatic int send_redirect_temp(struct MHD_Connection *connection, t_client *client, const char *url);\nstatic int is_foreign_hosts(struct MHD_Connection *connection, const char *host);\nstatic int get_query(struct MHD_Connection *connection, char **collect_query, const char *separator);\nstatic char *construct_querystring(struct MHD_Connection *connection, t_client *client, char *originurl, char *querystr);\nstatic const char *lookup_mimetype(const char *filename);\n\nstruct MHD_Daemon * webserver = NULL;\n\nvoid stop_mhd(void)\n{\n\tdebug(LOG_INFO, \"Calling MHD_stop_daemon [%lu]\", webserver);\n\tMHD_stop_daemon(webserver);\n}\n\nvoid start_mhd(void)\n{\n\t// Initializes the web server\n\ts_config *config;\n\tconfig = config_get_config();\n\n\tif ((webserver = MHD_start_daemon(\n\t\tMHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_THREAD_PER_CONNECTION | MHD_USE_TCP_FASTOPEN,\n\t\tconfig->gw_port,\n\t\tNULL,\n\t\tNULL,\n\t\tlibmicrohttpd_cb,\n\t\tNULL,\n\t\tMHD_OPTION_CONNECTION_LIMIT, (unsigned int) 100,\n\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 10,\n\t\tMHD_OPTION_PER_IP_CONNECTION_LIMIT, (unsigned int) 10,\n\t\tMHD_OPTION_END)) == NULL) {\n\n\t\tdebug(LOG_ERR, \"Could not create web server: %s\", strerror(errno));\n\t\texit(1);\n\n\t}\n\n\tdebug(LOG_INFO, \"MHD Handle [%lu]\", webserver);\n}\n\n\n/* Call the BinAuth script or program with output and input arguments.\n * Output arguments to BinAuth:\n * We will send client->mac, username_enc, password_enc, redirect_url_enc_buf, enc_user_agent, client->ip, client->token, custom_enc.\n * The BinAuth script will return &seconds, &upload_rate, &download_rate, &upload_quota, &download_quota\n *\n * Input arguments from BinAuth:\n * BinAuth will return values for Session length, rates and quotas.\n * It is the responsibility of the script to obtain/calculate/generate these values.\n*/\n\nstatic int do_binauth(\n\tstruct MHD_Connection *connection,\n\tconst char *binauth,\n\tt_client *client,\n\tint *seconds_ret,\n\tunsigned long long int *upload_rate_ret,\n\tunsigned long long int *download_rate_ret,\n\tunsigned long long int *upload_quota_ret,\n\tunsigned long long int *download_quota_ret,\n\tconst char *redirect_url\n\t)\n{\n\n\tchar *redirect_url_enc_buf;\n\tconst char *custom;\n\tchar *custom_enc;\n\tchar *msg;\n\tchar *argv = NULL;\n\tconst char *user_agent;\n\tchar *enc_user_agent;\n\tint seconds;\n\tunsigned long long int upload_rate;\n\tunsigned long long int download_rate;\n\tunsigned long long int upload_quota;\n\tunsigned long long int download_quota;\n\tint rc =1;\n\n\t// Get the client user agent\n\tuser_agent = safe_calloc(USER_AGENT);\n\n\tMHD_get_connection_values(connection, MHD_HEADER_KIND, get_user_agent_callback, &user_agent);\n\n\tif (user_agent == NULL) {\n\t\treturn send_error(connection, 403);\n\t}\n\n\tdebug(LOG_DEBUG, \"BinAuth: User Agent is [ %s ]\", user_agent);\n\n\t// Get custom data string as passed in the query string\n\tcustom = safe_calloc(CUSTOM);\n\n\tcustom = MHD_lookup_connection_value(connection, MHD_GET_ARGUMENT_KIND, \"custom\");\n\n\tif (!custom || strlen(custom) == 0) {\n\t\tcustom=\"bmE=\";\n\t}\n\n\tcustom_enc = safe_calloc(CUSTOM_ENC);\n\tuh_urlencode(custom_enc, CUSTOM_ENC, custom, strlen(custom));\n\n\tdebug(LOG_DEBUG, \"BinAuth: custom data [ %s ]\", custom_enc);\n\n\tredirect_url_enc_buf = safe_calloc(REDIRECT_URL_ENC_BUF);\n\tuh_urlencode(redirect_url_enc_buf, REDIRECT_URL_ENC_BUF, redirect_url, strlen(redirect_url));\n\n\tdebug(LOG_DEBUG, \"BinAuth: Redirect URL is [ %s ]\", redirect_url_enc_buf);\n\n\tenc_user_agent = safe_calloc(ENC_USER_AGENT);\n\tuh_urlencode(enc_user_agent, ENC_USER_AGENT, user_agent, strlen(user_agent));\n\n\tdebug(LOG_DEBUG, \"BinAuth: User Agent is [ %s ]\", enc_user_agent);\n\n\t// Note: username, password and user_agent may contain spaces so argument should be quoted\n\targv = safe_calloc(REDIRECT_URL_ENC_BUF + CUSTOM_ENC);\n\tsafe_snprintf(argv, REDIRECT_URL_ENC_BUF + CUSTOM_ENC, \"%s auth_client '%s' '%s' '%s' '%s' '%s' '%s'\",\n\t\tbinauth,\n\t\tclient->mac,\n\t\tredirect_url_enc_buf,\n\t\tenc_user_agent,\n\t\tclient->ip,\n\t\tclient->token,\n\t\tcustom_enc\n\t);\n\n\tdebug(LOG_DEBUG, \"BinAuth argv: %s\", argv);\n\n\t// ndsctl will deadlock if run within the BinAuth script so lock it\n\tmsg = safe_calloc(SMALL_BUF);\n\n\tif(ndsctl_lock() == 0) {\n\t\t// execute the script\n\t\trc = execute_ret_url_encoded(msg, SMALL_BUF, argv);\n\t\tdebug(LOG_DEBUG, \"BinAuth returned arguments: %s\", msg);\n\n\t\t// unlock ndsctl\n\t\tndsctl_unlock();\n\t}\n\n\tfree(custom_enc);\n\tfree(redirect_url_enc_buf);\n\tfree(enc_user_agent);\n\tfree(argv);\n\n\n\tif (rc != 0) {\n\t\tdebug(LOG_DEBUG, \"BinAuth script failed to execute\");\n\t\tfree(msg);\n\t\treturn 0;\n\t}\n\n\trc = sscanf(msg, \"%d %llu %llu %llu %llu\", &seconds, &upload_rate, &download_rate, &upload_quota, &download_quota);\n\tdebug(LOG_DEBUG, \"BinAuth returned session length: %d\", seconds);\n\tfree(msg);\n\n\t// store assigned parameters\n\tswitch (rc) {\n\t\tcase 5:\n\t\t\t*download_quota_ret = MAX(download_quota, 0);\n\t\tcase 4:\n\t\t\t*upload_quota_ret = MAX(upload_quota, 0);\n\t\tcase 3:\n\t\t\t*download_rate_ret = MAX(download_rate, 0);\n\t\tcase 2:\n\t\t\t*upload_rate_ret = MAX(upload_rate, 0);\n\t\tcase 1:\n\t\t\t*seconds_ret = MAX(seconds, 0);\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstruct collect_query {\n\tint i;\n\tchar **elements;\n};\n\nstatic enum MHD_Result collect_query_string(void *cls, enum MHD_ValueKind kind, const char *key, const char * value)\n{\n\t// what happens when '?=foo' supplied?\n\tstruct collect_query *collect_query = cls;\n\tif (key && !value) {\n\t\tcollect_query->elements[collect_query->i] = safe_strdup(key);\n\t} else if (key && value) {\n\t\tsafe_asprintf(&(collect_query->elements[collect_query->i]), \"%s=%s\", key, value);\n\t}\n\tcollect_query->i++;\n\treturn MHD_YES;\n}\n\n// a dump iterator required for counting all elements\nstatic enum MHD_Result counter_iterator(void *cls, enum MHD_ValueKind kind, const char *key, const char *value)\n{\n\treturn MHD_YES;\n}\n\nstatic int is_foreign_hosts(struct MHD_Connection *connection, const char *host)\n{\n\tchar our_host[MAX_HOSTPORTLEN];\n\ts_config *config = config_get_config();\n\tsnprintf(our_host, MAX_HOSTPORTLEN, \"%s\", config->gw_address);\n\tdebug(LOG_DEBUG, \"Our host: %s Requested host: %s\", our_host, host);\n\n\n\t// we serve all request without a host entry as well we serve all request going to our gw_address\n\tif (host == NULL)\n\t\treturn 0;\n\n\tif (!strcmp(host, our_host))\n\t\treturn 0;\n\n\tif (!strcmp(host, config->gw_ip))\n\t\treturn 0;\n\n\tif (config->gw_fqdn) {\n\t\tif (!strcmp(host, config->gw_fqdn))\n\t\t\treturn 0;\n\t}\n\n\t// port 80 is special, because the hostname doesn't need a port\n\tif (config->gw_port == 80 && !strcmp(host, config->gw_ip))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n// @brief Get client mac by ip address from neighbor cache\nint\nget_client_mac(char mac[18], const char req_ip[])\n{\n\tchar line[255] = {0};\n\tchar ip[64];\n\tFILE *stream;\n\tint len;\n\n\tlen = strlen(req_ip);\n\n\tif ((len + 2) > sizeof(ip)) {\n\t\treturn -1;\n\t}\n\n\t// Extend search string by one space\n\tmemcpy(ip, req_ip, len);\n\tip[len] = ' ';\n\tip[len+1] = '\\0';\n\n\tstream = popen(\"ip neigh show\", \"r\");\n\tif (!stream) {\n\t\treturn -1;\n\t}\n\n\twhile (fgets(line, sizeof(line) - 1, stream) != NULL) {\n\t\tif (0 == strncmp(line, ip, len + 1)) {\n\t\t\tif (1 == sscanf(line, \"%*s %*s %*s %*s %17[A-Fa-f0-9:] \", mac)) {\n\t\t\t\tpclose(stream);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpclose(stream);\n\n\treturn -1;\n}\n\n/**\n * @brief get_client_ip\n * @param connection\n * @return ip address - must be freed by caller\n */\nstatic int\nget_client_ip(char ip_addr[INET6_ADDRSTRLEN], struct MHD_Connection *connection)\n{\n\tconst union MHD_ConnectionInfo *connection_info;\n\tconst struct sockaddr *client_addr;\n\tconst struct sockaddr_in *addrin;\n\tconst struct sockaddr_in6 *addrin6;\n\n\tif (!(connection_info = MHD_get_connection_info(connection, MHD_CONNECTION_INFO_CLIENT_ADDRESS))) {\n\t\treturn -1;\n\t}\n\n\t// cast required for legacy MHD API < 0.9.6\n\tclient_addr = (const struct sockaddr *) connection_info->client_addr;\n\taddrin = (const struct sockaddr_in *) client_addr;\n\taddrin6 = (const struct sockaddr_in6 *) client_addr;\n\n\tswitch (client_addr->sa_family) {\n\tcase AF_INET:\n\t\tif (inet_ntop(AF_INET, &addrin->sin_addr, ip_addr, INET_ADDRSTRLEN)) {\n\t\tdebug(LOG_DEBUG, \"client ip address is [ %s ]\", ip_addr);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\tif (inet_ntop(AF_INET6, &addrin6->sin6_addr, ip_addr, INET6_ADDRSTRLEN)) {\n\t\tdebug(LOG_DEBUG, \"client ip address is [ %s ]\", ip_addr);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\n/**\n * @brief libmicrohttpd_cb called when the client does a request to this server\n * @param cls unused\n * @param connection - client connection\n * @param url - which url was called\n * @param method - POST / GET / ...\n * @param version http 1.0 or 1.1\n * @param upload_data - unused\n * @param upload_data_size - unused\n * @param ptr - unused\n * @return\n */\nenum MHD_Result libmicrohttpd_cb(\n\tvoid *cls,\n\tstruct MHD_Connection *connection,\n\tconst char *url,\n\tconst char *method,\n\tconst char *version,\n\tconst char *upload_data,\n\tsize_t *upload_data_size,\n\tvoid **ptr) {\n\n\tt_client *client;\n\tchar ip[INET6_ADDRSTRLEN+1];\n\tchar mac[18];\n\tconst char *dds = \"../\";\n\tconst char *mhdstatus = \"/mhdstatus\";\n\tint rc = 0;\n\tchar *msg;\n\tchar *testcmd;\n\ts_config *config;\n\n\tconfig = config_get_config();\n\n\tdebug(LOG_DEBUG, \"client access: %s %s\", method, url);\n\n\t// only allow get\n\tif (0 != strcmp(method, \"GET\")) {\n\t\tdebug(LOG_DEBUG, \"Unsupported http method %s, Network Authentication required (Error 511)\", method);\n\t\treturn send_error(connection, 511);\n\t}\n\n\t// block path traversal\n\tif (strstr(url, dds) != NULL) {\n\t\tdebug(LOG_WARNING, \"Probable Path Traversal Attack Detected - %s\", url);\n\t\treturn send_error(connection, 403);\n\t}\n\n\t// check for mhdstatus request\n\tif (strstr(url, mhdstatus) != NULL) {\n\t\tdebug(LOG_DEBUG, \"MHD Status Request - %s\", url);\n\t\treturn send_error(connection, 200);\n\t}\n\n\n\t/* switch between preauth, authenticated\n\t * - always - set caching headers\n\t * a) possible implementation - redirect first and serve them using a tempo redirect\n\t * b) serve direct\n\t * should all requests redirected? even those to .css, .js, ... or respond with 404/503/...\n\t */\n\n\trc = get_client_ip(ip, connection);\n\tif (rc != 0) {\n\t\treturn send_error(connection, 503);\n\t}\n\n\n\t// check if client ip is on our subnet\n\ttestcmd = safe_calloc(SMALL_BUF);\n\tsafe_snprintf(testcmd, SMALL_BUF, \"/usr/lib/opennds/libopennds.sh get_interface_by_ip \\\"%s\\\"\", ip);\n\tmsg = safe_calloc(SMALL_BUF);\n\trc = execute_ret_url_encoded(msg, SMALL_BUF, testcmd);\n\tfree(testcmd);\n\n\tif (rc == 0) {\n\t\tdebug(LOG_DEBUG, \"Interface used to route ip [%s] is [%s]\", ip, msg);\n\t\tdebug(LOG_DEBUG, \"Gateway Interface is [%s]\", config->gw_interface);\n\n\t\tif (strcmp(config->gw_interface, msg) == 0) {\n\t\t\tdebug(LOG_DEBUG, \"Client ip address [%s] is on our subnet using interface [%s]\", ip, msg);\n\t\t} else {\n\t\t\tdebug(LOG_NOTICE, \"Client ip address [%s] is  NOT on our subnet and is using interface [%s]\", ip, msg);\n\t\t\treturn send_error(connection, 403);\n\t\t}\n\t} else {\n\t\tdebug(LOG_DEBUG, \"ip subnet test failed: Continuing...\");\n\t}\n\n\tfree (msg);\n\n\trc = get_client_mac(mac, ip);\n\tif (rc != 0) {\n\t\treturn send_error(connection, 503);\n\t}\n\n\tclient = client_list_find(mac, ip);\n\tif (!client) {\n\t\tclient = add_client(mac, ip);\n\t\tif (!client) {\n\t\t\treturn send_error(connection, 403);\n\t\t}\n\t}\n\n\tif (client && (client->fw_connection_state == FW_MARK_AUTHENTICATED ||\n\t\t\tclient->fw_connection_state == FW_MARK_TRUSTED)) {\n\t\t// client is already authenticated, maybe they clicked/tapped \"back\" on the CPD browser or maybe they want the info page.\n\t\treturn authenticated(connection, url, client);\n\t}\n\n\treturn preauthenticated(connection, url, client);\n}\n\n/**\n * @brief check if url contains authdir\n * @param url\n * @param authdir\n * @return\n *\n * url must look (\"/%s/\", authdir) to match this\n */\nstatic int check_authdir_match(const char *url, const char *authdir)\n{\n\tdebug(LOG_DEBUG, \"url is [ %s ], checking for [ %s ]\", url, authdir);\n\n\tif (strlen(url) != (2 + strlen(authdir)))\n\t\treturn 0;\n\n\tif (strncmp(url + 1, authdir, strlen(authdir)))\n\t\treturn 0;\n\n\t// match\n\treturn 1;\n}\n\n/**\n * @brief try_to_authenticate\n * @param connection\n * @param client\n * @param host\n * @param url\n * @return\n */\nstatic int try_to_authenticate(struct MHD_Connection *connection, t_client *client, const char *host, const char *url)\n{\n\ts_config *config;\n\tconst char *tok;\n\tchar *rhid;\n\tchar *rhidraw;\n\n\tconfig = config_get_config();\n\n\t// Check for authdir\n\tif (check_authdir_match(url, config->authdir)) {\n\t\ttok = MHD_lookup_connection_value(connection, MHD_GET_ARGUMENT_KIND, \"tok\");\n\n\t\tif (tok == NULL) {\n\t\t\treturn send_error(connection, 403);\n\t\t}\n\n\t\tdebug(LOG_DEBUG, \"client->token=%s tok=%s \", client->token, tok );\n\n\t\t//Check if token (tok) or hash_id (hid) mode\n\t\tif (strlen(tok) > 8) {\n\t\t\t// hid mode\n\t\t\trhidraw = safe_calloc(SMALL_BUF);\n\t\t\tsafe_snprintf(rhidraw, SMALL_BUF, \"%s%s\", client->hid, config->fas_key);\n\t\t\trhid = safe_calloc(STATUS_BUF);\n\t\t\thash_str(rhid, STATUS_BUF, rhidraw);\n\t\t\tfree (rhidraw);\n\t\t\tif (tok && !strcmp(rhid, tok)) {\n\t\t\t\t// rhid is valid\n\t\t\t\tfree(rhid);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(rhid);\n\t\t} else {\n\t\t\t// tok mode\n\t\t\tif (tok && !strcmp(client->token, tok)) {\n\t\t\t\t// Token is valid\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(LOG_WARNING, \"Token is invalid\" );\n\n/*\t//TODO: do we need denydir?\n\tif (check_authdir_match(url, config->denydir)) {\n\t\t// matched to deauth\n\t\treturn 0;\n\t}\n*/\n\n\treturn 0;\n}\n\n/**\n * @brief authenticate the client and redirect them\n * @param connection\n * @param ip_addr - needs to be freed\n * @param mac - needs to be freed\n * @param redirect_url - redirect the client to this url\n * @return\n */\nstatic int authenticate_client(struct MHD_Connection *connection,\n\t\t\t\t\t\t\tconst char *redirect_url,\n\t\t\t\t\t\t\tt_client *client)\n{\n\ts_config *config = config_get_config();\n\ttime_t now = time(NULL);\n\tint seconds = 60 * config->session_timeout;\n\tunsigned long long int uploadrate = 0;\n\tunsigned long long int downloadrate = 0;\n\tunsigned long long int uploadquota = 0;\n\tunsigned long long int downloadquota = 0;\n\tint rc;\n\tint ret;\n\tchar *redirect_url_enc;\n\tchar *querystr;\n\tconst char *custom;\n\n\tclient->window_counter = 0;\n\tclient->rate_exceeded = 0;\n\tclient->initial_loop = 0;\n\tclient->upload_limiting = 0;\n\tclient->download_limiting = 0;\n\tclient->upload_rate = 0;\n\tclient->download_rate = 0;\n\tclient->uprate = 0;\n\tclient->downrate = 0;\n\tclient->upload_quota = 0;\n\tclient->download_quota = 0;\n\tclient->download_bucket_size = 0;\n\tclient->upload_bucket_size = 0;\n\tclient->inc_packet_limit = 0;\n\tclient->out_packet_limit = 0;\n\n\tclient->session_start = now;\n\n\tif (seconds > 0) {\n\t\tclient->session_end = now + seconds;\n\t} else {\n\t\tclient->session_end = 0;\n\t}\n\n\tdebug(LOG_DEBUG, \"redirect_url is [ %s ]\", redirect_url);\n\n\t// get custom string\n\tcustom = MHD_lookup_connection_value(connection, MHD_GET_ARGUMENT_KIND, \"custom\");\n\n\tif (!custom || strlen(custom) == 0) {\n\t\tcustom=\"bmE=\";\n\t}\n\n\tif (config->binauth) {\n\t\trc = do_binauth(\n\t\t\tconnection,\n\t\t\tconfig->binauth,\n\t\t\tclient,\n\t\t\t&seconds,\n\t\t\t&uploadrate,\n\t\t\t&downloadrate,\n\t\t\t&uploadquota,\n\t\t\t&downloadquota,\n\t\t\tredirect_url\n\t\t);\n\n\t\tif (rc != 0) {\n\t\t\t/*BinAuth denies access so redirect client back to login/splash page where they can try again.\n\t\t\t\tIf FAS is enabled, this will cause nesting of the contents of redirect_url,\n\t\t\t\tFAS should account for this if used with BinAuth.\n\t\t\t*/\n\n\t\t\tredirect_url_enc = safe_calloc(REDIRECT_URL_ENC_BUF);\n\t\t\tuh_urlencode(redirect_url_enc, REDIRECT_URL_ENC_BUF, redirect_url, strlen(redirect_url));\n\n\t\t\tdebug(LOG_DEBUG, \"redirect_url after binauth deny: %s\", redirect_url);\n\t\t\tdebug(LOG_DEBUG, \"redirect_url_enc after binauth deny: %s\", redirect_url_enc);\n\n\t\t\tquerystr = safe_calloc(QUERYMAXLEN);\n\t\t\tquerystr=construct_querystring(connection, client, redirect_url_enc, querystr);\n\t\t\tret = encode_and_redirect_to_splashpage(connection, client, redirect_url_enc, querystr);\n\t\t\tfree(querystr);\n\t\t\tfree(redirect_url_enc);\n\t\t\treturn ret;\n\t\t}\n\t\trc = auth_client_auth(client->id, \"client_auth\", custom);\n\t} else {\n\t\trc = auth_client_auth(client->id, NULL, custom);\n\t}\n\n\t// override remaining client values that might have been set by binauth\n\n\tif (seconds == 0) {\n\t\tseconds = (60 * config->session_timeout);\n\t}\n\n\tdebug(LOG_DEBUG, \"timeout seconds: %d\", seconds);\n\n\tif (seconds != (60 * config->session_timeout)) {\n\t\tclient->session_end = (client->session_start + seconds);\n\t}\n\n\tif (downloadrate > 0) {\n\t\tclient->download_rate = downloadrate;\n\t}\n\tif (uploadrate > 0) {\n\t\tclient->upload_rate = uploadrate;\n\t}\n\n\tif (downloadquota > 0) {\n\t\tclient->download_quota = downloadquota;\n\t}\n\tif (uploadquota > 0) {\n\t\tclient->upload_quota = uploadquota;\n\t}\n\n\n\t// error checking\n\tif (rc != 0) {\n\t\treturn send_error(connection, 503);\n\t}\n\n\tif (redirect_url) {\n\t\treturn send_redirect_temp(connection, client, redirect_url);\n\t} else {\n\t\treturn send_error(connection, 200);\n\t}\n\n\tdebug(LOG_DEBUG, \"authenticate: Session Start - %lu Session End - %lu\", client->session_start, client->session_end);\n}\n\n/**\n * @brief authenticated - called for all request from authenticated clients.\n * @param connection\n * @param ip_addr\n * @param mac\n * @param url\n * @param client\n * @return\n *\n * It's unsual to received request from clients which are already authenticated.\n * Happens when the user:\n * - clicked in multiple windows on \"accept\" -> redirect to origin - no checking\n * - when the user reloaded a splashpage -> redirect to origin\n * - when a user calls deny url -> deauth it\n */\nstatic int authenticated(struct MHD_Connection *connection,\n\t\t\t\t\t\tconst char *url,\n\t\t\t\t\t\tt_client *client)\n{\n\ts_config *config = config_get_config();\n\tconst char *host = config->gw_address;\n\tchar *redirect_to_us = NULL;\n\tchar *fasurl;\n\tchar *query;\n\tchar *msg;\n\tchar *clientif;\n\tconst char *accept;\n\tchar *originurl_raw = NULL;\n\tchar *captive_json = NULL;\n\tchar *buff;\n\tint rc;\n\tint ret;\n\tstruct MHD_Response *response;\n\n\tret = MHD_get_connection_values(connection, MHD_HEADER_KIND, get_host_value_callback, &host);\n\n\tif (ret < 1) {\n\t\tdebug(LOG_ERR, \"authenticated: Error getting host\");\n\t\treturn MHD_NO;\n\t} else {\n\t\tdebug(LOG_DEBUG, \"An authenticated client is requesting: host [%s] url [%s]\", host, url);\n\t}\n\n\tif (host == NULL) {\n\t\tdebug(LOG_ERR, \"authenticated: Error getting host\");\n\t\thost = config->gw_address;\n\t}\n\n\t// Is it an RFC8908 type request? - check Accept: header\n\n\taccept = safe_calloc(SMALL_BUF);\n\tret = MHD_get_connection_values(connection, MHD_HEADER_KIND, get_accept_callback, &accept);\n\n\tif (ret < 1) {\n\t\tdebug(LOG_ERR, \"authenticated: Error getting Accept header\");\n\t\treturn MHD_NO;\n\t}\n\n\tif (accept && strcmp(accept, \"application/captive+json\") == 0) {\n\t\tdebug(LOG_NOTICE, \"authenticated: Accept header [%s]\", accept);\n\t\tdebug(LOG_NOTICE, \"authenticated: RFC 8908 captive+json request received\");\n\n\t\toriginurl_raw = safe_calloc(SMALL_BUF);\n\t\tcaptive_json = safe_calloc(SMALL_BUF);\n\n\t\tif (strcmp(config->gw_fqdn, \"disable\") == 0 || strcmp(config->gw_fqdn, \"disabled\") == 0) {\n\t\t\tsafe_snprintf(originurl_raw, SMALL_BUF, \"http://%s\", config->gw_ip);\n\t\t} else {\n\t\t\tsafe_snprintf(originurl_raw, SMALL_BUF, \"http://%s\", config->gw_fqdn);\n\t\t}\n\n\t\tsafe_snprintf(captive_json, SMALL_BUF,\n\t\t\t\"{ \\\"captive\\\": false, \\\"user-portal-url\\\": \\\"%s\\\", \\\"venue-info-url\\\": \\\"%s\\\", \\\"can-extend-session\\\": false }\",\n\t\t\toriginurl_raw,\n\t\t\toriginurl_raw\n\t\t);\n\n\t\tdebug(LOG_DEBUG, \"captive_json [%s]\", captive_json);\n\t\tret = send_json(connection, captive_json);\n\n\t\tfree(originurl_raw);\n\t\tfree(captive_json);\n\t\treturn ret;\n\t}\n\n\t/* check if this is a late request, meaning the user tries to get the internet, but ended up here,\n\t * because the nftables rule came too late\n\t */\n\tif (is_foreign_hosts(connection, host)) {\n\t\t// might happen if the firewall rule isn't yet installed\n\t\t\treturn send_error(connection, 511);\n\t}\n\n\tif (check_authdir_match(url, config->denydir)) {\n\t\tdebug(LOG_NOTICE, \"Deauthentication request - client  [%s]\", client->mac);\n\t\tauth_client_deauth(client->id, \"client_deauth\");\n\t\tdebug(LOG_DEBUG, \"Post deauth redirection [%s]\", config->gw_address);\n\n\t\tredirect_to_us = safe_calloc(QUERYMAXLEN);\n\n\t\tif (!redirect_to_us) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(redirect_to_us);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsafe_snprintf(redirect_to_us, QUERYMAXLEN, \"http://%s/\", config->gw_address);\n\n\t\tret = send_redirect_temp(connection, client, redirect_to_us);\n\t\tfree (redirect_to_us);\n\t\treturn ret;\n\t}\n\n\tif (check_authdir_match(url, config->authdir)) {\n\t\tclientif = safe_calloc(STATUS_BUF);\n\t\tget_client_interface(clientif, STATUS_BUF, client->mac);\n\n\t\tif (config->fas_port && !config->preauth) {\n\t\t\tquery = safe_calloc(QUERYMAXLEN);\n\n\t\t\tif (!query) {\n\t\t\t\tret = send_error(connection, 503);\n\t\t\t\tfree(query);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tfasurl = safe_calloc(QUERYMAXLEN);\n\n\t\t\tif (!fasurl) {\n\t\t\t\tret = send_error(connection, 503);\n\t\t\t\tfree(fasurl);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tget_query(connection, &query, HTMLQUERYSEPARATOR);\n\n\t\t\tsafe_snprintf(fasurl, QUERYMAXLEN, \"%s%s%sstatus=authenticated\",\n\t\t\t\tconfig->fas_url,\n\t\t\t\tquery,\n\t\t\t\tHTMLQUERYSEPARATOR\n\t\t\t);\n\t\t\tdebug(LOG_DEBUG, \"fasurl [%s]\", fasurl);\n\t\t\tdebug(LOG_DEBUG, \"query [%s]\", query);\n\t\t\tret = send_redirect_temp(connection, client, fasurl);\n\t\t\tfree(clientif);\n\t\t\tfree(query);\n\t\t\tfree(fasurl);\n\t\t\treturn ret;\n\t\t} else if (config->fas_port && config->preauth) {\n\t\t\tfasurl = safe_calloc(QUERYMAXLEN);\n\t\t\tsafe_snprintf(fasurl, QUERYMAXLEN, \"?clientip=%s%sgatewayname=%s%sgatewayaddress=%s%sclientif=%s%sstatus=authenticated\",\n\t\t\t\tclient->ip,\n\t\t\t\tQUERYSEPARATOR,\n\t\t\t\tconfig->url_encoded_gw_name,\n\t\t\t\tQUERYSEPARATOR,\n\t\t\t\tconfig->gw_address,\n\t\t\t\tQUERYSEPARATOR,\n\t\t\t\tclientif,\n\t\t\t\tQUERYSEPARATOR\n\t\t\t);\n\t\t\tdebug(LOG_DEBUG, \"fasurl %s\", fasurl);\n\t\t\tret = show_preauthpage(connection, fasurl);\n\t\t\tfree(fasurl);\n\t\t\tfree(clientif);\n\t\t\treturn ret;\t\n\t\t}\n\t\tfree(clientif);\n\t}\n\n\tif (check_authdir_match(url, config->preauthdir)) {\n\n\t\tif (config->fas_port) {\n\t\t\tquery = safe_calloc(QUERYMAXLEN);\n\t\t\tfasurl = safe_calloc(QUERYMAXLEN);\n\n\t\t\tif (!query) {\n\t\t\t\tret = send_error(connection, 503);\n\t\t\t\tfree(query);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tget_query(connection, &query, QUERYSEPARATOR);\n\n\t\t\tsafe_snprintf(fasurl, QUERYMAXLEN, \"%s%sstatus=authenticated\",\n\t\t\t\tquery,\n\t\t\t\tQUERYSEPARATOR\n\t\t\t);\n\n\t\t\tdebug(LOG_DEBUG, \"preauthdir: fasurl %s\", fasurl);\n\t\t\tret = show_preauthpage(connection, fasurl);\n\t\t\tfree(query);\n\t\t\tfree(fasurl);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t// User just entered gatewayaddress:gatewayport so give them the info page\n\tif (strcmp(url, \"/\") == 0 || strcmp(url, \"/login\") == 0) {\n\t\tquery = safe_calloc(QUERYMAXLEN);\n\n\t\tif (!query) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(query);\n\t\t\treturn ret;\n\t\t}\n\n\t\tget_query(connection, &query, QUERYSEPARATOR);\n\t\tdebug(LOG_DEBUG, \"status_query=[%s]\", query);\n\n\t\tbuff = safe_calloc(MID_BUF);\n\n\t\tif (!buff) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(buff);\n\t\t\treturn ret;\n\t\t}\n\n\t\tb64_encode(buff, MID_BUF, query, strlen(query));\n\n\t\tdebug(LOG_DEBUG, \"b64_status_query=[%s]\", buff);\n\n\t\tmsg = safe_calloc(HTMLMAXSIZE);\n\n\t\tif (!msg) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(msg);\n\t\t\treturn ret;\n\t\t}\n\n\t\trc = execute_ret(msg, HTMLMAXSIZE - 1, \"%s status '%s' '%s'\", config->status_path, client->ip, buff);\n\n\t\tif (rc != 0) {\n\t\t\tdebug(LOG_WARNING, \"Script: %s - failed to execute\", config->status_path);\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(msg);\n\t\t\treturn ret;\n\t\t}\n\n\t\t// serve the script output (in msg)\n\t\tresponse = MHD_create_response_from_buffer(strlen(msg), (char *)msg, MHD_RESPMEM_MUST_FREE);\n\n\t\tif (!response) {\n\t\t\treturn send_error(connection, 503);\n\t\t}\n\n\t\tMHD_add_response_header(response, \"Content-Type\", \"text/html; charset=utf-8\");\n\t\tret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n\t\tMHD_destroy_response(response);\n\t\treturn ret;\n\t}\n\n\t// Client wants a specific file eg /images/splash.jpg etc.:\n\treturn serve_file(connection, client, url);\n}\n\n/**\n * @brief show_preauthpage - run preauth script and serve output.\n */\nstatic int show_preauthpage(struct MHD_Connection *connection, const char *query)\n{\n\ts_config *config = config_get_config();\n\n\tchar *msg;\n\tconst char *user_agent;\n\tchar *enc_user_agent;\n\tchar *preauthpath;\n\tchar *cmd;\n\tchar *enc_query;\n\n\tint rc;\n\tint ret;\n\tstruct MHD_Response *response;\n\n\tif ( strlen(query) < 1 ) {\n\t\t// query string is blank, too long or corrupt\n\t\treturn send_error(connection, 511);\n\t} else {\t\n\t\tpreauthpath = safe_calloc(SMALL_BUF);\n\t\tsafe_snprintf(preauthpath, SMALL_BUF, \"/%s/\", config->preauthdir);\n\n\t\tif (strcmp(preauthpath, config->fas_path) == 0) {\n\t\t\tfree (preauthpath);\n\n\t\t\tuser_agent = safe_calloc(USER_AGENT);\n\t\t\tdebug(LOG_DEBUG, \"PreAuth: User Agent ptr is [ %llu ]\", &user_agent);\n\t\t\tenc_user_agent = safe_calloc(ENC_USER_AGENT);\n\n\t\t\tMHD_get_connection_values(connection, MHD_HEADER_KIND, get_user_agent_callback, &user_agent);\n\t\t\tdebug(LOG_DEBUG, \"PreAuth: MHD User Agent ptr is [ %llu ]\", &user_agent);\n\n\t\t\tif (user_agent == NULL) {\n\t\t\t\treturn send_error(connection, 403);\n\t\t\t}\n\n\t\t\tuh_urlencode(enc_user_agent, ENC_USER_AGENT, user_agent, strlen(user_agent));\n\t\t\tdebug(LOG_DEBUG, \"PreAuth: Encoded User Agent is [ %s ]\", enc_user_agent);\n\n\t\t\tenc_query = safe_calloc(ENC_QUERYSTR);\n\t\t\tuh_urlencode(enc_query, ENC_QUERYSTR, query, strlen(query));\n\t\t\tdebug(LOG_DEBUG, \"PreAuth: Encoded query: %s\", enc_query);\n\n\t\t\tmsg = safe_calloc(HTMLMAXSIZE);\n\n\t\t\tif (!msg) {\n\t\t\t\tret = send_error(connection, 503);\n\t\t\t\tfree(msg);\n\t\t\t\tfree(enc_user_agent);\n\t\t\t\tfree(enc_query);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tcmd = safe_calloc(QUERYMAXLEN);\n\t\t\tsafe_snprintf(cmd, QUERYMAXLEN, \"%s '%s' '%s' '%d' '%s'\", config->preauth, enc_query, enc_user_agent, config->login_option_enabled, config->themespec_path);\n\t\t\trc = execute_ret_url_encoded(msg, HTMLMAXSIZE - 1, cmd);\n\t\t\tfree(cmd);\n\n\t\t\tif (rc != 0) {\n\t\t\t\tdebug(LOG_WARNING, \"Preauth script - failed to execute: %s, Query[%s]\", config->preauth, query);\n\t\t\t\tfree(msg);\n\t\t\t\tfree(enc_user_agent);\n\t\t\t\tfree(enc_query);\n\n\t\t\t\treturn send_error(connection, 511);\n\t\t\t}\n\n\t\t\t// serve the script output (in msg)\n\t\t\tresponse = MHD_create_response_from_buffer(strlen(msg), (char *)msg, MHD_RESPMEM_MUST_FREE);\n\n\t\t\tif (!response) {\n\t\t\t\tfree(msg);\n\t\t\t\tfree(enc_user_agent);\n\t\t\t\tfree(enc_query);\n\n\t\t\t\treturn send_error(connection, 503);\n\t\t\t}\n\n\t\t\tMHD_add_response_header(response, \"Content-Type\", \"text/html; charset=utf-8\");\n\t\t\tret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n\t\t\tMHD_destroy_response(response);\n\n\t\t\t// MHD will free(msg) when it has finished with it ( ie MHD_RESPMEM_MUST_FREE). Do not free here or MHD will page fault.\n\t\t\tfree(enc_user_agent);\n\t\t\tfree(enc_query);\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tfree (preauthpath);\n\t\t\treturn send_error(connection, 404);\n\t\t}\n\t}\n}\n\n/**\n * @brief send_json - send the rfc8908 json response.\n */\nstatic int send_json(struct MHD_Connection *connection, const char *json)\n{\n\tchar *msg;\n\tint ret;\n\tstruct MHD_Response *response;\n\n\tmsg = safe_calloc(SMALL_BUF * 2);\n\n\tif (!msg) {\n\t\tret = send_error(connection, 503);\n\t\tfree(msg);\n\t\treturn ret;\n\t}\n\n\tsafe_snprintf(msg, SMALL_BUF * 2, \"%s\", json);\n\n\tdebug(LOG_DEBUG, \"json string [%s],  buffer [%s]\", json, msg);\n\n\tresponse = MHD_create_response_from_buffer(strlen(msg), (char *)msg, MHD_RESPMEM_MUST_FREE);\n\n\tif (!response) {\n\t\tfree(msg);\n\t\tret = send_error(connection, 503);\n\t\treturn ret;\n\t}\n\n\tMHD_add_response_header(response, \"Cache-Control\", \"private\");\n\tMHD_add_response_header(response, \"Content-Type\", \"application/captive+json\");\n\tret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n\tMHD_destroy_response(response);\n\tfree(msg);\n\treturn ret;\n\n}\n\n/**\n * @brief preauthenticated - called for all request of a client in this state.\n * @param connection\n * @param ip_addr\n * @param mac\n * @return\n */\nstatic int preauthenticated(struct MHD_Connection *connection, const char *url, t_client *client)\n{\n\ts_config *config = config_get_config();\n\tconst char *host = config->gw_address;\n\tconst char *accept = NULL;\n\tconst char *redirect_url;\n\tchar *query;\n\tchar *querystr;\n\tchar *originurl;\n\tchar *originurl_raw = NULL;\n\tchar *captive_json = NULL;\n\n\tint ret;\n\n\tret = MHD_get_connection_values(connection, MHD_HEADER_KIND, get_host_value_callback, &host);\n\n\tif (ret < 1) {\n\t\tdebug(LOG_ERR, \"preauthenticated: Error getting host\");\n\t\treturn MHD_NO;\n\t}\n\n\tdebug(LOG_DEBUG, \"preauthenticated: host [%s] url [%s]\", host, url);\n\n\tif (host == NULL) {\n\t\tdebug(LOG_ERR, \"preauthenticated: Error getting host\");\n\t\thost = config->gw_address;\n\t}\n\n\t// check if this is an RFC8910 login request\n\tif (strcmp(url, \"/login\") == 0) {\n\t\tdebug(LOG_INFO, \"preauthenticated: RFC8910 login request received from client at [%s] [%s]\", client->ip, client->mac);\n\t\tclient->client_type = \"cpi_url\";\n\t\treturn redirect_to_splashpage(connection, client, host, \"/login\");\n\t}\n\n\t// Is it an RFC8908 type request? - check Accept: header\n\tret = MHD_get_connection_values(connection, MHD_HEADER_KIND, get_accept_callback, &accept);\n\n\tif (ret < 1) {\n\t\tdebug(LOG_ERR, \"preauthenticated: Error getting Accept header\");\n\t\treturn MHD_NO;\n\t}\n\n\tif (accept && strcmp(accept, \"application/captive+json\") == 0) {\n\t\tdebug(LOG_DEBUG, \"preauthenticated: Accept header [%s]\", accept);\n\t\tdebug(LOG_NOTICE, \"preauthenticated: RFC 8908 captive+json request received from client at [%s] [%s]\", client->ip, client->mac);\n\n\t\tclient->client_type = \"cpi_api\";\n\n\t\toriginurl_raw = safe_calloc(REDIRECT_URL);\n\n\t\tif (strcmp(config->gw_fqdn, \"disable\") == 0 || strcmp(config->gw_fqdn, \"disabled\") == 0) {\n\t\t\tsafe_snprintf(originurl_raw, REDIRECT_URL, \"http://%s\", config->gw_ip);\n\t\t} else {\n\t\t\tsafe_snprintf(originurl_raw, REDIRECT_URL, \"http://%s\", config->gw_fqdn);\n\t\t}\n\n\t\toriginurl = safe_calloc(REDIRECT_URL_ENC_BUF);\n\t\tuh_urlencode(originurl, REDIRECT_URL_ENC_BUF, originurl_raw, strlen(originurl_raw));\n\t\tdebug(LOG_DEBUG, \"originurl: %s\", originurl);\n\n\t\tquerystr = safe_calloc(QUERYMAXLEN);\n\n\t\tif (!querystr) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(originurl);\n\t\t\tfree(originurl_raw);\n\t\t\tfree(querystr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tquerystr=construct_querystring(connection, client, originurl, querystr);\n\t\tdebug(LOG_DEBUG, \"Constructed query string [%s]\", querystr);\n\t\tdebug(LOG_DEBUG, \"FAS url [%s]\", config->fas_url);\n\n\t\tcaptive_json = safe_calloc(QUERYMAXLEN);\n\n\t\tif (!captive_json) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(originurl);\n\t\t\tfree(originurl_raw);\n\t\t\tfree(querystr);\n\t\t\tfree(captive_json);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsafe_snprintf(captive_json, QUERYMAXLEN, \"{ \\\"captive\\\": true, \\\"user-portal-url\\\": \\\"%s%s\\\" }\", config->fas_url, querystr);\n\n\t\tdebug(LOG_DEBUG, \"captive_json [%s]\", captive_json);\n\t\tret = send_json(connection, captive_json);\n\n\t\tfree(originurl);\n\t\tfree(originurl_raw);\n\t\tfree(querystr);\n\t\tfree(captive_json);\n\t\treturn ret;\n\t}\n\n\t// Did user just access gatewayaddress:gatewayport directly or by redirect\n\tif (strcmp(url, \"/\") == 0) {\n\t\tif (strcmp(host, config->gw_address) == 0 || strcmp(host, config->gw_ip) == 0 || strcmp(host, config->gw_fqdn) == 0) {\n\t\t\treturn send_error(connection, 511);\n\t\t}\n\t}\n\n\t// Check for preauthdir\n\tif (check_authdir_match(url, config->preauthdir)) {\n\n\t\tdebug(LOG_DEBUG, \"preauthdir url detected: %s\", url);\n\t\tquery = safe_calloc(QUERYMAXLEN);\n\n\t\tif (!query) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(query);\n\t\t\treturn ret;\n\t\t}\n\n\t\tget_query(connection, &query, QUERYSEPARATOR);\n\t\tdebug(LOG_DEBUG, \"preauthenticated: show_preauthpage [%s]\", query);\n\t\tret = show_preauthpage(connection, query);\n\t\tfree(query);\n\t\treturn ret;\n\t}\n\n\t// Check for denydir\n\tif (check_authdir_match(url, config->denydir)) {\n\t\tdebug(LOG_DEBUG, \"denydir url detected: %s\", url);\n\t\treturn send_error(connection, 511);\n\t}\n\n\tdebug(LOG_DEBUG, \"preauthenticated: Requested Host is [ %s ], url is [%s]\", host, url);\n\n\t// check if this is a redirect query with a foreign host as target\n\tif (is_foreign_hosts(connection, host)) {\n\t\tdebug(LOG_DEBUG, \"preauthenticated: foreign host [%s] detected\", host);\n\t\treturn redirect_to_splashpage(connection, client, host, url);\n\t}\n\n\t// request is directed to us, check if client wants to be authenticated\n\tif (check_authdir_match(url, config->authdir)) {\n\t\tdebug(LOG_DEBUG, \"authdir url detected: %s\", url);\n\n\t\tredirect_url = safe_calloc(REDIRECT_URL);\n\n\t\tredirect_url = MHD_lookup_connection_value(connection, MHD_GET_ARGUMENT_KIND, \"redir\");\n\n\t\tif (redirect_url == NULL) {\n\t\t\treturn send_error(connection, 403);\n\t\t}\n\n\t\tif (!try_to_authenticate(connection, client, host, url)) {\n\t\t\t// user used an invalid token, redirect to splashpage but hold query \"redir\" intact\n\t\t\toriginurl = safe_calloc(REDIRECT_URL_ENC_BUF);\n\t\t\tuh_urlencode(originurl, REDIRECT_URL_ENC_BUF, redirect_url, strlen(redirect_url));\n\n\t\t\tquerystr = safe_calloc(QUERYMAXLEN);\n\n\t\t\tif (!querystr) {\n\t\t\t\tret = send_error(connection, 503);\n\t\t\t\tfree(originurl);\n\t\t\t\tfree(querystr);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tquerystr = construct_querystring(connection, client, originurl, querystr);\n\n\t\t\tret = encode_and_redirect_to_splashpage(connection, client, originurl, querystr);\n\t\t\tfree(originurl);\n\t\t\tfree(querystr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = authenticate_client(connection, redirect_url, client);\n\t\treturn ret;\n\t}\n\n\t// no special handling left - try to serve static content to the user\n\treturn serve_file(connection, client, url);\n}\n\n/**\n * @brief encode originurl and redirect the client to the splash page\n * @param connection\n * @param client\n * @param originurl\n * @return\n */\nstatic int encode_and_redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *originurl, const char *querystr)\n{\n\tchar *splashpageurl = NULL;\n\ts_config *config;\n\tint ret;\n\n\tconfig = config_get_config();\n\tsplashpageurl = safe_calloc(QUERYMAXLEN);\n\n\tif (config->fas_port) {\n\t\t// Generate secure query string or authaction url\n\t\t// Note: config->fas_path contains a leading / as it is the path from the FAS web root.\n\t\tif (config->fas_secure_enabled == 0) {\n\t\t\tsafe_snprintf(splashpageurl, QUERYMAXLEN, \"%s?authaction=http://%s/%s/%s\",\n\t\t\t\tconfig->fas_url, config->gw_address, config->authdir, querystr);\n\t\t} else if (config->fas_secure_enabled >= 1) {\n\t\t\t\tsafe_snprintf(splashpageurl, QUERYMAXLEN, \"%s%s\",\n\t\t\t\t\tconfig->fas_url, querystr);\n\t\t} else {\n\t\t\tsafe_snprintf(splashpageurl, QUERYMAXLEN, \"%s?%s\",\n\t\t\t\tconfig->fas_url, querystr);\n\t\t}\n\t}\n\n\tdebug(LOG_DEBUG, \"splashpageurl: %s\", splashpageurl);\n\n\tret = send_redirect_temp(connection, client, splashpageurl);\n\tfree(splashpageurl);\n\treturn ret;\n}\n\n/**\n * @brief redirect_to_splashpage\n * @param connection\n * @param client\n * @param host\n * @param url\n * @return\n */\nstatic int redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *host, const char *url)\n{\n\tchar *originurl_raw;\n\tchar *originurl;\n\tchar *query;\n\tint ret = 0;\n\tconst char *separator = \"&\";\n\tchar *querystr;\n\n\tquery = safe_calloc(QUERYMAXLEN);\n\n\tif (!query) {\n\t\tret = send_error(connection, 503);\n\t\tfree(query);\n\t\treturn ret;\n\t}\n\n\tquerystr = safe_calloc(QUERYMAXLEN);\n\n\tif (!querystr) {\n\t\tret = send_error(connection, 503);\n\t\tfree(querystr);\n\t\treturn ret;\n\t}\n\n\toriginurl_raw = safe_calloc(MID_BUF);\n\n\tif (!originurl_raw) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl_raw);\n\t\treturn ret;\n\t}\n\n\toriginurl = safe_calloc(CUSTOM_ENC);\n\n\tif (!originurl) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl);\n\t\treturn ret;\n\t}\n\n\tget_query(connection, &query, separator);\n\n\tif (!query) {\n\t\tdebug(LOG_DEBUG, \"Unable to get query string - error 503\");\n\t\tfree(query);\n\t\t// probably no mem\n\t\treturn send_error(connection, 503);\n\t}\n\n\tdebug(LOG_DEBUG, \"Query string is [ %s ]\", query);\n\n\tsafe_asprintf(&originurl_raw, \"http://%s%s%s\", host, url, query);\n\tuh_urlencode(originurl, CUSTOM_ENC, originurl_raw, strlen(originurl_raw));\n\n\tif (strcmp(url, \"/login\") == 0) {\n\t\tclient->cpi_query = safe_strdup(originurl);\n\t\tdebug(LOG_DEBUG, \"RFC8910 request: %s\", client->cpi_query);\n\t} else {\n\t\tclient->cpi_query = \"none\";\n\t}\n\n\tdebug(LOG_DEBUG, \"originurl_raw: %s\", originurl_raw);\n\tdebug(LOG_DEBUG, \"originurl: %s\", originurl);\n\n\tquerystr=construct_querystring(connection, client, originurl, querystr);\n\tret = encode_and_redirect_to_splashpage(connection, client, originurl, querystr);\n\tfree(originurl_raw);\n\tfree(originurl);\n\tfree(query);\n\tfree(querystr);\n\treturn ret;\n}\n\n/**\n * @brief construct_querystring\n * @return the querystring\n */\nstatic char *construct_querystring(struct MHD_Connection *connection, t_client *client, char *originurl, char *querystr ) {\n\n\tchar cid[87] = {0};\n\tchar *clienttype;\n\tchar *clientif;\n\tchar *query_str;\n\tchar *query_str_b64;\n\tchar *msg;\n\tchar *cidinfo;\n\tchar *cidfile;\n\tchar *gw_url_raw;\n\tchar *gw_url;\n\tchar *phpcmd;\n\tint cidgood = 0;\n\n\ts_config *config = config_get_config();\n\n\tgw_url_raw = safe_calloc(REDIRECT_URL);\n\n\tif (strcmp(config->gw_fqdn, \"disable\") == 0 || strcmp(config->gw_fqdn, \"disabled\") == 0) {\n\t\tsafe_snprintf(gw_url_raw, REDIRECT_URL, \"http://%s\", config->gw_ip);\n\t} else {\n\t\tsafe_snprintf(gw_url_raw, REDIRECT_URL, \"http://%s\", config->gw_fqdn);\n\t}\n\n\tgw_url = safe_calloc(REDIRECT_URL_ENC_BUF);\n\tuh_urlencode(gw_url, REDIRECT_URL_ENC_BUF, gw_url_raw, strlen(gw_url_raw));\n\tdebug(LOG_DEBUG, \"gw_url: %s\", gw_url);\n\tfree (gw_url_raw);\n\n\tclienttype = safe_calloc(STATUS_BUF);\n\n\tif (!client->client_type || strlen(client->client_type) == 0) {\n\t\tclienttype = safe_strdup(\"cpd_can\");\n\t} else {\n\t\tclienttype = safe_strdup(client->client_type);\n\t}\n\n\tif (config->fas_secure_enabled == 0) {\n\t\tsnprintf(querystr, QUERYMAXLEN, \"?clientip=%s&gatewayname=%s&tok=%s&redir=%s\",\n\t\t\tclient->ip,\n\t\t\tconfig->url_encoded_gw_name,\n\t\t\tclient->token,\n\t\t\toriginurl\n\t\t);\n\n\t} else if (config->fas_secure_enabled == 1) {\n\n\t\t\tif (config->fas_hid) {\n\t\t\t\tdebug(LOG_DEBUG, \"hid=%s\", client->hid);\n\n\t\t\t\tclientif = safe_calloc(STATUS_BUF);\n\n\t\t\t\tget_client_interface(clientif, STATUS_BUF, client->mac);\n\t\t\t\tdebug(LOG_DEBUG, \"clientif: [%s] url_encoded_gw_name: [%s]\", clientif, config->url_encoded_gw_name);\n\n\t\t\t\tquery_str = safe_calloc(QUERYMAXLEN);\n\n\t\t\t\tsnprintf(query_str, QUERYMAXLEN,\n\t\t\t\t\t\"hid=%s%sclientip=%s%sclientmac=%s%sclient_type=%s%scpi_query=%s%sgatewayname=%s%sgatewayurl=%s%sversion=%s%sgatewayaddress=%s%sgatewaymac=%s%soriginurl=%s%sclientif=%s%sthemespec=%s%s%s%s%s%s\",\n\t\t\t\t\tclient->hid, QUERYSEPARATOR,\n\t\t\t\t\tclient->ip, QUERYSEPARATOR,\n\t\t\t\t\tclient->mac, QUERYSEPARATOR,\n\t\t\t\t\tclienttype, QUERYSEPARATOR,\n\t\t\t\t\tclient->cpi_query, QUERYSEPARATOR,\n\t\t\t\t\tconfig->url_encoded_gw_name, QUERYSEPARATOR,\n\t\t\t\t\tgw_url, QUERYSEPARATOR,\n\t\t\t\t\tVERSION, QUERYSEPARATOR,\n\t\t\t\t\tconfig->gw_address, QUERYSEPARATOR,\n\t\t\t\t\tconfig->gw_mac, QUERYSEPARATOR,\n\t\t\t\t\toriginurl, QUERYSEPARATOR,\n\t\t\t\t\tclientif, QUERYSEPARATOR,\n\t\t\t\t\tconfig->themespec_path, QUERYSEPARATOR,\n\t\t\t\t\tconfig->custom_params,\n\t\t\t\t\tconfig->custom_vars,\n\t\t\t\t\tconfig->custom_images,\n\t\t\t\t\tconfig->custom_files\n\t\t\t\t);\n\n\t\t\t\tquery_str_b64 = safe_calloc(ENC_QUERYSTR);\n\n\t\t\t\tb64_encode(query_str_b64, ENC_QUERYSTR, query_str, strlen(query_str));\n\n\t\t\t\tsnprintf(querystr, ENC_QUERYSTR,\n\t\t\t\t\t\"?fas=%s\",\n\t\t\t\t\tquery_str_b64\n\t\t\t\t);\n\n\t\t\t\tif (config->login_option_enabled >=1) {\n\t\t\t\t\tif (client->cid) {\n\t\t\t\t\t\tcidgood = 1;\n\t\t\t\t\t\tcidfile = safe_calloc(SMALL_BUF);\n\t\t\t\t\t\tsafe_snprintf(cidfile, SMALL_BUF, \"%s/ndscids/%s\", config->tmpfsmountpoint, client->cid);\n\n\t\t\t\t\t\t// Check if cidfile exists\n\t\t\t\t\t\tif(access(cidfile, F_OK) != 0) {\n\t\t\t\t\t\t\t// does not exist\n\t\t\t\t\t\t\tcidgood=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(cidfile);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cidgood == 0) {\n\t\t\t\t\t\tstrncpy(cid, query_str_b64+5, 86);\n\t\t\t\t\t\tclient->cid = safe_strdup(cid);\n\n\t\t\t\t\t\t// Write the new cidfile:\n\t\t\t\t\t\tmsg = safe_calloc(STATUS_BUF);\n\t\t\t\t\t\tcidinfo = safe_calloc(SMALL_BUF);\n\t\t\t\t\t\tdebug(LOG_DEBUG, \"writing cid file [%s]\", cid);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"hid=\\\"%s\\\"\\0\", client->hid);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"clientip=\\\"%s\\\"\\0\", client->ip);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"clientmac=\\\"%s\\\"\\0\", client->mac);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"cpi_query=\\\"%s\\\"\\0\", client->cpi_query);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"client_type=\\\"%s\\\"\\0\", clienttype);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"gatewayname=\\\"%s\\\"\\0\", config->http_encoded_gw_name);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"gatewayurl=\\\"%s\\\"\\0\", gw_url);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"version=\\\"%s\\\"\\0\", VERSION);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"gatewayaddress=\\\"%s\\\"\\0\", config->gw_address);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"gatewaymac=\\\"%s\\\"\\0\", config->gw_mac);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"originurl=\\\"%s\\\"\\0\", originurl);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"clientif=\\\"%s\\\"\\0\", clientif);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tif (config->themespec_path) {\n\t\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"themespec=\\\"%s\\\"\\0\", config->themespec_path);\n\t\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (config->custom_params) {\n\t\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"%s\\0\", config->custom_params);\n\t\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"parse\", cid, cidinfo);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (config->custom_vars) {\n\t\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"%s\\0\", config->custom_vars);\n\t\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"parse\", cid, cidinfo);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (config->custom_images) {\n\t\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"%s\\0\", config->custom_images);\n\t\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"parse\", cid, cidinfo);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (config->custom_files) {\n\t\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"%s\\0\", config->custom_files);\n\t\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"parse\", cid, cidinfo);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfree(msg);\n\t\t\t\t\t\tfree(cidinfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfree(query_str);\n\t\t\t\tfree(query_str_b64);\n\t\t\t\tfree(clientif);\n\n\t\t\t} else {\n\t\t\t\tsnprintf(querystr, QUERYMAXLEN,\n\t\t\t\t\t\"?clientip=%s&gatewayname=%s&redir=%s\",\n\t\t\t\t\tclient->ip,\n\t\t\t\t\tconfig->url_encoded_gw_name,\n\t\t\t\t\toriginurl\n\t\t\t\t);\n\t\t\t}\n\n\t} else if (config->fas_secure_enabled == 2 || config->fas_secure_enabled == 3) {\n\n\t\tdebug(LOG_DEBUG, \"hid=%s\", client->hid);\n\n\t\tclientif = safe_calloc(STATUS_BUF);\n\t\tget_client_interface(clientif, STATUS_BUF, client->mac);\n\t\tdebug(LOG_DEBUG, \"clientif: [%s]\", clientif);\n\t\tsnprintf(querystr, QUERYMAXLEN,\n\t\t\t\"hid=%s%sclientip=%s%sclientmac=%s%sclient_type=%s%scpi_query=%s%sgatewayname=%s%sgatewayurl=%s%sversion=%s%sgatewayaddress=%s%sgatewaymac=%s%sauthdir=%s%soriginurl=%s%sclientif=%s%sthemespec=%s%s%s%s%s%s\",\n\t\t\tclient->hid, QUERYSEPARATOR,\n\t\t\tclient->ip, QUERYSEPARATOR,\n\t\t\tclient->mac, QUERYSEPARATOR,\n\t\t\tclienttype, QUERYSEPARATOR,\n\t\t\tclient->cpi_query, QUERYSEPARATOR,\n\t\t\tconfig->url_encoded_gw_name, QUERYSEPARATOR,\n\t\t\tgw_url, QUERYSEPARATOR,\n\t\t\tVERSION, QUERYSEPARATOR,\n\t\t\tconfig->gw_address, QUERYSEPARATOR,\n\t\t\tconfig->gw_mac, QUERYSEPARATOR,\n\t\t\tconfig->authdir, QUERYSEPARATOR,\n\t\t\toriginurl, QUERYSEPARATOR,\n\t\t\tclientif, QUERYSEPARATOR,\n\t\t\tconfig->themespec_path, QUERYSEPARATOR,\n\t\t\tconfig->custom_params,\n\t\t\tconfig->custom_vars,\n\t\t\tconfig->custom_images,\n\t\t\tconfig->custom_files\n\t\t);\n\n\t\tphpcmd = safe_calloc(QUERYMAXLEN);\n\t\tsafe_snprintf(phpcmd, QUERYMAXLEN,\n\t\t\t\"echo '<?php \\n\"\n\t\t\t\"$key=\\\"%s\\\";\\n\"\n\t\t\t\"$string=\\\"%s\\\";\\n\"\n\t\t\t\"$cipher=\\\"aes-256-cbc\\\";\\n\"\n\n\t\t\t\"if (in_array($cipher, openssl_get_cipher_methods())) {\\n\"\n\t\t\t\t\"$secret_iv = base64_encode(openssl_random_pseudo_bytes(\\\"8\\\"));\\n\"\n\t\t\t\t\"$iv = substr(openssl_digest($secret_iv, \\\"sha256\\\"), 0, 16 );\\n\"\n\t\t\t\t\"$string = base64_encode( openssl_encrypt( $string, $cipher, $key, 0, $iv ) );\\n\"\n\t\t\t\t\"echo \\\"?fas=\\\".$string.\\\"&iv=\\\".$iv;\\n\"\n\t\t\t\"}\\n\"\n\t\t\t\" ?>' \"\n\t\t\t\" | %s\\n\",\n\t\t\tconfig->fas_key,\n\t\t\tquerystr,\n\t\t\tconfig->fas_ssl\n\t\t);\n\n\t\tdebug(LOG_DEBUG, \"phpcmd: %s\", phpcmd);\n\n\t\tmsg = safe_calloc(QUERYMAXLEN);\n\n\t\tif (!msg) {\n\t\t\tsend_error(connection, 503);\n\t\t\tfree(msg);\n\t\t} else {\n\n\t\t\tif (! execute_ret_url_encoded(msg, QUERYMAXLEN - 1, phpcmd) == 0) {\n\t\t\t\tdebug(LOG_ERR, \"Error encrypting query string. %s\", msg);\n\t\t\t}\n\n\t\t\tsnprintf(querystr, QUERYMAXLEN, \"%s\", msg);\n\n\t\t\tfree(msg);\n\t\t\tfree(phpcmd);\n\t\t}\n\t\tfree(clientif);\n\n\t} else {\n\t\tsnprintf(querystr, QUERYMAXLEN, \"?clientip=%s&gatewayname=%s\", client->ip, config->url_encoded_gw_name);\n\t}\n\n\tdebug(LOG_DEBUG, \"Constructed Query String [%s]\", querystr);\n\tfree(clienttype);\n\tfree(gw_url);\n\treturn querystr;\n}\n\n/**\n *\tAdd client making a request to client list.\n *\tReturn pointer to the client list entry for this client.\n *\n *\tN.B.: This does not authenticate the client; it only makes\n *\ttheir information available on the client list.\n */\nstatic t_client *\nadd_client(const char *mac, const char *ip)\n{\n\tt_client *client;\n\n\tLOCK_CLIENT_LIST();\n\tclient = client_list_add_client(mac, ip);\n\tUNLOCK_CLIENT_LIST();\n\n\treturn client;\n}\n\nint send_redirect_temp(struct MHD_Connection *connection, t_client *client, const char *url)\n{\n\t// Warning - *client will be undefined if not authenticated\n\tstruct MHD_Response *response;\n\tint ret;\n\tchar *redirect;\n\n\tredirect = safe_calloc(SMALL_BUF);\n\n\tsafe_snprintf(redirect, SMALL_BUF, \"<html><head></head><body><a href='%s'>Click here to continue to<br>%s</a></body></html\", url, url);\n\n\tdebug(LOG_DEBUG, \"send_redirect_temp: MHD_create_response_from_buffer. url [%s]\", url);\n\tdebug(LOG_DEBUG, \"send_redirect_temp: Redirect to [%s]\", redirect);\n\n\tresponse = MHD_create_response_from_buffer(SMALL_BUF, redirect, MHD_RESPMEM_MUST_FREE);\n\n\tif (!response) {\n\t\tdebug(LOG_DEBUG, \"send_redirect_temp: Failed to create response....\");\n\t\treturn send_error(connection, 503);\n\t} else {\n\t\tdebug(LOG_DEBUG, \"send_redirect_temp: Response created\");\n\t}\n\n\tret = MHD_add_response_header(response, \"Location\", url);\n\n\tif (ret == MHD_NO) {\n\t\tdebug(LOG_ERR, \"send_redirect_temp: Error adding Location header to redirection page\");\n\t} else {\n\t\tdebug(LOG_DEBUG, \"send_redirect_temp: Location header added to redirection page\");\n\t}\n\n\tret = MHD_add_response_header(response, \"Connection\", \"close\");\n\n\tif (ret == MHD_NO) {\n\t\tdebug(LOG_ERR, \"send_redirect_temp: Error adding Connection header to redirection page\");\n\t} else {\n\t\tdebug(LOG_DEBUG, \"send_redirect_temp: Connection header added to redirection page\");\n\t}\n\n\tdebug(LOG_DEBUG, \"send_redirect_temp: Queueing response\");\n\n\tret = MHD_queue_response(connection, MHD_HTTP_TEMPORARY_REDIRECT, response);\n\n\tif (ret == MHD_NO) {\n\t\tdebug(LOG_ERR, \"send_redirect_temp: Error queueing response\");\n\t} else {\n\t\tdebug(LOG_DEBUG, \"send_redirect_temp: Response is Queued\");\n\t}\n\n\tMHD_destroy_response(response);\n\n\treturn ret;\n}\n\n// save the query or empty string into **query.\nstatic int get_query(struct MHD_Connection *connection, char **query, const char *separator)\n{\n\tint element_counter;\n\tchar **elements;\n\tchar *query_str;\n\tstruct collect_query collect_query;\n\tint i;\n\tint j = 4;\n\tint length = 0;\n\n\tdebug(LOG_DEBUG, \" Getting query, separator is [%s].\", separator);\n\n\telement_counter = MHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, counter_iterator, NULL);\n\tif (element_counter < 0) {\n\t\t*query = safe_strdup(\"\");\n\t\treturn MHD_NO;\n\t}\n\telements = calloc(element_counter, sizeof(char *));\n\tif (elements == NULL) {\n\t\treturn MHD_NO;\n\t}\n\tcollect_query.i = 0;\n\tcollect_query.elements = elements;\n\n\t// Collect the arguments of the query string from MHD\n\tMHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, collect_query_string, &collect_query);\n\n\tfor (i = 0; i < element_counter; i++) {\n\t\tif (!elements[i])\n\t\t\tcontinue;\n\t\tlength += strlen(elements[i]);\n\n\t\tif (i > 0) // q=foo&o=bar the '&' need also some space\n\t\t\tlength++;\n\n\t\tdebug(LOG_DEBUG, \" cumulative element length is [%d]\", length);\n\t}\n\n\t// don't miss the zero terminator\n\tif (*query == NULL) {\n\t\tfor (i = 0; i < element_counter; i++) {\n\t\t\tfree(elements[i]);\n\t\t}\n\t\tfree(elements);\n\t\treturn 0;\n\t}\n\n\tquery_str = safe_calloc(QUERYMAXLEN);\n\n\tfor (i = 0, j = 0; i < element_counter; i++) {\n\t\tif (!elements[i]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdebug(LOG_DEBUG, \" element [%d] is [%s]\", i, elements[i]);\n\n\t\tif (length + j < QUERYMAXLEN) {\n\n\t\t\tstrncpy(*query + j, elements[i], length - j);\n\n\t\t\tif (i == 0) {\n\t\t\t\t// query_str is empty when i = 0 so safe to copy a single char into it\n\t\t\t\tstrcpy(query_str, \"?\");\n\t\t\t} else {\n\t\t\t\tif (QUERYMAXLEN - strlen(query_str) > length - j + 1) {\n\t\t\t\t\tstrncat(query_str, separator, QUERYMAXLEN - strlen(query_str));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstrncat(query_str, *query, QUERYMAXLEN - strlen(query_str));\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \" Query string is too long, invalid or corrupt so is ignored.\");\n\t\t}\n\n\t\tfree(elements[i]);\n\t}\n\n\tdebug(LOG_DEBUG, \" query is [%s]\", query_str);\n\tstrncpy(*query, query_str, QUERYMAXLEN);\n\tfree(query_str);\n\tfree(elements);\n\treturn 0;\n}\n\nstatic int send_error(struct MHD_Connection *connection, int error)\n{\n\tstruct MHD_Response *response = NULL;\n\n\t/* cannot automate since cannot translate automagically between error number and MHD's status codes\n\t * -- and cannot rely on MHD_HTTP_ values to provide an upper bound for an array\n\t */\n\tconst char *page_200 = \"<br>OK<br>\";\n\tconst char *page_400 = \"<html><head><title>Error 400</title></head><body><h1>Error 400 - Bad Request</h1></body></html>\";\n\tconst char *page_403 = \"<html><head><title>Error 403</title></head><body><h1>Error 403 - Forbidden - Access Denied to this Client!</h1></body></html>\";\n\tconst char *page_404 = \"<html><head><title>Error 404</title></head><body><h1>Error 404 - Not Found</h1></body></html>\";\n\tconst char *page_500 = \"<html><head><title>Error 500</title></head><body><h1>Error 500 - Internal Server Error: Oh No!</h1></body></html>\";\n\tconst char *page_501 = \"<html><head><title>Error 501</title></head><body><h1>Error 501 - Not Implemented</h1></body></html>\";\n\tconst char *page_503 = \"<html><head><title>Error 503</title></head><body><h1>Error 503 - Service Unavailable. This may be a temporary condition.\"\n\t\t\"</h1></body></html>\";\n\tchar *page_511;\n\tchar *cmd;\n\tconst char *mimetype = lookup_mimetype(\"foo.html\");\n\tchar ip[INET6_ADDRSTRLEN+1];\n\n\tint ret = MHD_NO;\n\ts_config *config = config_get_config();\n\n\tswitch (error) {\n\tcase 200:\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_200), (char *)page_200, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, error, response);\n\t\tbreak;\n\n\tcase 400:\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_400), (char *)page_400, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, MHD_HTTP_BAD_REQUEST, response);\n\t\tbreak;\n\n\tcase 403:\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_403), (char *)page_403, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, MHD_HTTP_FORBIDDEN, response);\n\t\tbreak;\n\n\tcase 404:\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_404), (char *)page_404, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, MHD_HTTP_NOT_FOUND, response);\n\t\tbreak;\n\n\tcase 500:\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_500), (char *)page_500, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, MHD_HTTP_INTERNAL_SERVER_ERROR, response);\n\t\tbreak;\n\n\tcase 501:\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_501), (char *)page_501, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, MHD_HTTP_NOT_IMPLEMENTED, response);\n\t\tbreak;\n\tcase 503:\n\t\tdebug(LOG_INFO, \"503: [%s] \", (char *)page_503);\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_503), (char *)page_503, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, MHD_HTTP_SERVICE_UNAVAILABLE, response);\n\t\tbreak;\n\tcase 511:\n\t\tget_client_ip(ip, connection);\n\n\t\tpage_511 = safe_calloc(HTMLMAXSIZE);\n\n\t\tif (!page_511) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(page_511);\n\t\t\tbreak;\n\t\t}\n\n\t\tcmd = safe_calloc(SMALL_BUF);\n\t\tsafe_snprintf(cmd, SMALL_BUF, \"%s err511 '%s'\", config->status_path, ip);\n\n\t\tif (execute_ret_url_encoded(page_511, HTMLMAXSIZE - 1, cmd) == 0) {\n\t\t\tdebug(LOG_INFO, \"Network Authentication Required - page_511 html generated for [%s]\", ip);\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \"Script: %s - failed to execute\", config->status_path);\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(cmd);\n\t\t\tfree(page_511);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfree(cmd);\n\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_511), (char *)page_511, MHD_RESPMEM_MUST_FREE);\n\n\t\tif (response) {\n\t\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\t\tMHD_add_response_header(response, MHD_HTTP_HEADER_CONNECTION, \"close\");\n\t\t\tret = MHD_queue_response(connection, MHD_HTTP_NETWORK_AUTHENTICATION_REQUIRED, response);\n\n\t\t\tif (ret == MHD_NO) {\n\t\t\t\tdebug(LOG_ERR, \"send_error 511: Error queueing response\");\n\t\t\t} else {\n\t\t\t\tdebug(LOG_DEBUG, \"send_error 511: Response is Queued\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdebug(LOG_ERR, \"send_error 511: Error queueing response\");\n\t\tbreak;\n\t}\n\n\tif (response)\n\t\tMHD_destroy_response(response);\n\treturn ret;\n}\n\n/**\n * @brief get_host_value_callback safe Host into cls which is a char**\n * @param cls - a char ** pointer to our target buffer. This buffer will be alloc in this function.\n * @param kind - see doc of\tMHD_KeyValueIterator's\n * @param key\n * @param value\n * @return MHD_YES or MHD_NO. MHD_NO means we found our item and this callback will not called again.\n */\nstatic enum MHD_Result get_host_value_callback(void *cls, enum MHD_ValueKind kind, const char *key, const char *value)\n{\n\tconst char **host = (const char **)cls;\n\n\tif (MHD_HEADER_KIND != kind) {\n\t\t*host = NULL;\n\t\treturn MHD_NO;\n\t}\n\n\tif (!strcmp(\"Host\", key)) {\n\t\t*host = value;\n\t\treturn MHD_NO;\n\t}\n\tif (key && value) {\n\n\t\tif (!strcmp(\"Host\", key)) {\n\t\t\t*host = value;\n\t\t\treturn MHD_NO;\n\t\t}\n\t}\n\n\treturn MHD_YES;\n}\n\n/**\n * @brief get_user_agent_callback save User-Agent into cls which is a char**\n * @param cls - a char ** pointer to our target buffer. This buffer will be alloc in this function.\n * @param kind - see doc of\tMHD_KeyValueIterator's\n * @param key\n * @param value\n * @return MHD_YES or MHD_NO. MHD_NO means we found our item and this callback will not called again.\n */\nstatic enum MHD_Result get_user_agent_callback(void *cls, enum MHD_ValueKind kind, const char *key, const char *value)\n{\n\tconst char **user_agent = (const char **)cls;\n\n\tif (MHD_HEADER_KIND != kind) {\n\t\t*user_agent = NULL;\n\t\treturn MHD_NO;\n\t}\n\n\tif (key && value) {\n\n\t\tif (!strcmp(\"User-Agent\", key)) {\n\t\t\t*user_agent = value;\n\t\t\treturn MHD_NO;\n\t\t}\n\t}\n\n\treturn MHD_YES;\n}\n\n/**\n * @brief get_accept_callback save Accept: into cls which is a char**\n * @param cls - a char ** pointer to our target buffer. This buffer will be alloc in this function.\n * @param kind - see doc of\tMHD_KeyValueIterator's\n * @param key\n * @param value\n * @return MHD_YES or MHD_NO. MHD_NO means we found our item and this callback will not called again.\n */\nstatic enum MHD_Result get_accept_callback(void *cls, enum MHD_ValueKind kind, const char *key, const char *value)\n{\n\tconst char **accept = (const char **)cls;\n\n\tif (MHD_HEADER_KIND != kind) {\n\t\t*accept = NULL;\n\t\treturn MHD_NO;\n\t}\n\n\tif (key && value) {\n\n\t\tif (!strcmp(\"Accept\", key)) {\n\t\t\t*accept = value;\n\t\t\treturn MHD_NO;\n\t\t}\n\t}\n\n\treturn MHD_YES;\n}\n\n/**\n * @brief return an extension like `csv` if file = '/bar/foobar.csv'.\n * @param filename\n * @return a pointer within file is returned. NULL can be returned as well as\n */\nconst char *get_extension(const char *filename)\n{\n\tint pos = strlen(filename);\n\twhile (pos > 0) {\n\t\tpos--;\n\t\tswitch (filename[pos]) {\n\t\tcase '/':\n\t\t\treturn NULL;\n\t\tcase '.':\n\t\t\treturn (filename+pos+1);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n#define DEFAULT_MIME_TYPE \"application/octet-stream\"\n\nconst char *lookup_mimetype(const char *filename)\n{\n\tint i;\n\tconst char *extension;\n\n\tif (!filename) {\n\t\treturn NULL;\n\t}\n\n\textension = get_extension(filename);\n\tif (!extension)\n\t\treturn DEFAULT_MIME_TYPE;\n\n\tfor (i = 0; i< ARRAY_SIZE(uh_mime_types); i++) {\n\t\tif (strcmp(extension, uh_mime_types[i].extn) == 0) {\n\t\t\treturn uh_mime_types[i].mime;\n\t\t}\n\t}\n\n\tdebug(LOG_ERR, \"Could not find corresponding mimetype for %s extension\", extension);\n\n\treturn DEFAULT_MIME_TYPE;\n}\n\n/**\n * @brief serve_file try to serve a request via filesystem. Using webroot as root.\n * @param connection\n * @param client\n * @return\n */\nstatic int serve_file(struct MHD_Connection *connection, t_client *client, const char *url)\n{\n\tstruct stat stat_buf;\n\ts_config *config = config_get_config();\n\tstruct MHD_Response *response;\n\tchar filename[PATH_MAX];\n\tint ret = MHD_NO;\n\tconst char *mimetype = NULL;\n\toff_t size;\n\n\tsnprintf(filename, PATH_MAX, \"%s/%s\", config->webroot, url);\n\n\t// check if file exists and is not a directory\n\tret = stat(filename, &stat_buf);\n\tif (ret) {\n\t\t// stat failed\n\t\tdebug(LOG_DEBUG, \"File %s could not be found\", filename);\n\t\treturn send_error(connection, 404);\n\t}\n\n\tif (!S_ISREG(stat_buf.st_mode)) {\n#ifdef S_ISLNK\n\t\t// ignore links\n\t\tif (!S_ISLNK(stat_buf.st_mode))\n#endif // S_ISLNK\n\t\treturn send_error(connection, 404);\n\t}\n\n\tint fd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\treturn send_error(connection, 404);\n\n\tmimetype = lookup_mimetype(filename);\n\n\t// serving file and creating response\n\tsize = lseek(fd, 0, SEEK_END);\n\tif (size < 0)\n\t\treturn send_error(connection, 404);\n\n\tresponse = MHD_create_response_from_fd(size, fd);\n\tif (!response)\n\t\treturn send_error(connection, 503);\n\n\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\tret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n\tMHD_destroy_response(response);\n\n\treturn ret;\n}\n\n"], "fixing_code": ["/********************************************************************\\\n * This program is free software; you can redistribute it and/or    *\n * modify it under the terms of the GNU General Public License as   *\n * published by the Free Software Foundation; either version 2 of   *\n * the License, or (at your option) any later version.              *\n *                                                                  *\n * This program is distributed in the hope that it will be useful,  *\n * but WITHOUT ANY WARRANTY; without even the implied warranty of   *\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    *\n * GNU General Public License for more details.                     *\n *                                                                  *\n * You should have received a copy of the GNU General Public License*\n * along with this program; if not, contact:                        *\n *                                                                  *\n * Free Software Foundation           Voice:  +1-617-542-5942       *\n * 59 Temple Place - Suite 330        Fax:    +1-617-542-2652       *\n * Boston, MA  02111-1307,  USA       gnu@gnu.org                   *\n *                                                                  *\n \\********************************************************************/\n\n/** @file client_list.c\n  @brief Client List Functions\n  @author Copyright (C) 2004 Alexandre Carmel-Veillex <acv@acv.ca>\n  @author Copyright (C) 2007 Paul Kube <nodogsplash@kokoro.ucsd.edu>\n  @author Copyright (C) 2015-2023 Modifications and additions by BlueWave Projects and Services <opennds@blue-wave.net>\n */\n\n#define _GNU_SOURCE\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <syslog.h>\n#include <errno.h>\n#include <pthread.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n\n#include <string.h>\n\n#include \"safe.h\"\n#include \"debug.h\"\n#include \"conf.h\"\n#include \"common.h\"\n#include \"client_list.h\"\n#include \"http_microhttpd.h\"\n#include \"fw_iptables.h\"\n#include \"util.h\"\n\n\n// Client counter\nstatic int client_count = 0;\nstatic int client_id = 1;\n\n// Global mutex to protect access to the client list\npthread_mutex_t client_list_mutex = PTHREAD_MUTEX_INITIALIZER;\n\n/** @internal\n * Holds a pointer to the first element of the list\n */\nstatic t_client *firstclient = NULL;\n\n// Return current length of the client list\nint\nget_client_list_length()\n{\n\treturn client_count;\n}\n\n// Get the first element of the client list\nt_client *\nclient_get_first_client(void)\n{\n\treturn firstclient;\n}\n\n// Initialize the list of connected clients\nvoid\nclient_list_init(void)\n{\n\tfirstclient = NULL;\n\tclient_count = 0;\n}\n\n/** @internal\n * Given IP, MAC, and client token, appends a new entry\n * to the end of the client list and returns a pointer to the new entry.\n * All the memory allocation for a list entry is done here.\n * Checks for number of current clients.\n * Does not check for duplicate entries; so check before calling.\n * @param ip IP address\n * @param mac MAC address\n * @param token Token\n * @return Pointer to the client we just created\n */\nstatic t_client *\n_client_list_append(const char mac[], const char ip[])\n{\n\tt_client *client, *prevclient;\n\ts_config *config;\n\n\tconfig = config_get_config();\n\tif (client_count >= config->maxclients) {\n\t\tdebug(LOG_NOTICE, \"Already list %d clients, cannot add %s %s\", client_count, ip, mac);\n\t\treturn NULL;\n\t}\n\n\tprevclient = NULL;\n\tclient = firstclient;\n\n\twhile (client != NULL) {\n\t\tprevclient = client;\n\t\tclient = client->next;\n\t}\n\n\tclient = safe_calloc(sizeof(t_client));\n\n\tclient->mac = safe_strdup(mac);\n\tclient->ip = safe_strdup(ip);\n\n\t// Reset volatile fields and create new token\n\tclient_reset(client);\n\n\t// Trusted client does not trigger the splash page.\n\tif (is_trusted_mac(mac)) {\n\t\tclient->fw_connection_state = FW_MARK_TRUSTED;\n\t} else {\n\t\tclient->fw_connection_state = FW_MARK_PREAUTHENTICATED;\n\t}\n\n\tclient->id = client_id;\n\tclient->out_packet_limit = 0;\n\tclient->inc_packet_limit = 0;\n\n\tdebug(LOG_NOTICE, \"Adding %s %s token %s to client list\",\n\t\tclient->ip, client->mac, client->token ? client->token : \"none\");\n\n\tif (prevclient == NULL) {\n\t\tfirstclient = client;\n\t} else {\n\t\tprevclient->next = client;\n\t}\n\n\tclient_id++;\n\tclient_count++;\n\n\treturn client;\n}\n\n/** @internal\n *  Reset volatile fields\n */\nvoid client_reset(t_client *client)\n{\n\tchar *hash;\n\tchar *msg;\n\tchar *cidinfo;\n\n\tdebug(LOG_DEBUG, \"Resetting client [%s]\", client->mac);\n\t// Reset traffic counters\n\tclient->counters.incoming = 0;\n\tclient->counters.outgoing = 0;\n\tclient->counters.last_updated = time(NULL);\n\n\t// Reset session time\n\tclient->session_start = 0;\n\tclient->session_end = 0;\n\n\t// Reset token and hid\n\thash = safe_calloc(STATUS_BUF);\n\tclient->token = safe_calloc(STATUS_BUF);\n\tsafe_snprintf(client->token, STATUS_BUF, \"%04hx%04hx\", rand16(), rand16());\n\thash_str(hash, STATUS_BUF, client->token);\n\tclient->hid = safe_strdup(hash);\n\tfree(hash);\n\n\t// Reset custom, client_type and cpi_query\n\tclient->custom = safe_calloc(MID_BUF);\n\tclient->client_type = safe_calloc(STATUS_BUF);\n\n\tif (!client->cpi_query) {\n\t\tclient->cpi_query = safe_calloc(STATUS_BUF);\n\t}\n\n\t//Reset cid and remove cidfile using rmcid\n\tif (client->cid) {\n\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t}\n\n\tclient->cid = safe_calloc(SMALL_BUF);\n\n}\n\n/**\n *  Given an IP address, add a client corresponding to that IP to client list.\n *  Return a pointer to the new client list entry, or to an existing entry\n *  if one with the given IP already exists.\n *  Return NULL if no new client entry can be created.\n */\nt_client *\nclient_list_add_client(const char mac[], const char ip[])\n{\n\tt_client *client;\n\n\tint rc = -1;\n\tchar *libcmd;\n\tchar *msg;\n\n\tif (!check_mac_format(mac)) {\n\t\t// Inappropriate format in IP address\n\t\tdebug(LOG_NOTICE, \"Illegal MAC format [%s]\", mac);\n\t\treturn NULL;\n\t}\n\n\tif (!check_ip_format(ip)) {\n\t\t// Inappropriate format in IP address\n\t\tdebug(LOG_NOTICE, \"Illegal IP format [%s]\", ip);\n\t\treturn NULL;\n\t}\n\n\t// check if client ip was allocated by dhcp\n\tlibcmd = safe_calloc(SMALL_BUF);\n\tsafe_snprintf(libcmd, SMALL_BUF, \"/usr/lib/opennds/libopennds.sh dhcpcheck \\\"%s\\\"\", ip);\n\tmsg = safe_calloc(SMALL_BUF);\n\trc = execute_ret_url_encoded(msg, SMALL_BUF, libcmd);\n\tfree(libcmd);\n\tfree(msg);\n\n\tif (rc > 0) {\n\t\t// IP address is not in the dhcp database\n\t\tdebug(LOG_NOTICE, \"IP not allocated by dhcp [%s]\", ip);\n\t\treturn NULL;\n\t}\n\n\tclient = client_list_find(mac, ip);\n\n\tif (!client) {\n\t\t// add the client\n\t\tclient = _client_list_append(mac, ip);\n\t} else {\n\t\tdebug(LOG_INFO, \"Client %s %s token %s already on client list\", ip, mac, client->token);\n\t}\n\n\treturn client;\n}\n\n/** Finds a client by its token, IP or MAC.\n * A found client is guaranteed to be unique.\n * @param ip IP we are looking for in the linked list\n * @param mac MAC we are looking for in the linked list\n * @return Pointer to the client, or NULL if not found\n */\nt_client *\nclient_list_find_by_any(const char mac[], const char ip[], const char token[])\n{\n\tt_client *client = NULL;\n\n\tif (!client && token) {\n\t\tclient = client_list_find_by_token(token);\n\t}\n\n\tif (!client && ip) {\n\t\tclient = client_list_find_by_ip(ip);\n\t}\n\n\tif (!client && mac) {\n\t\tclient = client_list_find_by_mac(mac);\n\t}\n\n\treturn client;\n}\n\nt_client *\nclient_list_find(const char mac[], const char ip[])\n{\n\tt_client *ptr;\n\n\tptr = firstclient;\n\twhile (ptr) {\n\t\tif (!strcmp(ptr->mac, mac) && !strcmp(ptr->ip, ip)) {\n\t\t\treturn ptr;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Finds a client by its IP address. Returns NULL if\n * the client could not be found.\n * @return Pointer to the client, or NULL if not found\n */\nt_client *\nclient_list_find_by_id(const unsigned id)\n{\n\tt_client *ptr;\n\n\tptr = firstclient;\n\twhile (ptr) {\n\t\tif (ptr->id == id) {\n\t\t\treturn ptr;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Finds a client by its IP address. Returns NULL if\n * the client could not be found.\n * @return Pointer to the client, or NULL if not found\n */\nt_client *\nclient_list_find_by_ip(const char ip[])\n{\n\tt_client *ptr;\n\n\tptr = firstclient;\n\twhile (ptr) {\n\t\tif (!strcmp(ptr->ip, ip)) {\n\t\t\treturn ptr;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Finds a client by its MAC address. Returns NULL if\n * the client could not be found.\n * @return Pointer to the client, or NULL if not found\n */\nt_client *\nclient_list_find_by_mac(const char mac[])\n{\n\tt_client *ptr;\n\n\tptr = firstclient;\n\twhile (ptr) {\n\t\tif (!strcmp(ptr->mac, mac)) {\n\t\t\treturn ptr;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * Finds a client by token. Returns NULL if\n * the client could not be found.\n * @return Pointer to the client, or NULL if not found\n */\nt_client *\nclient_list_find_by_token(const char token[])\n{\n\tt_client *ptr;\n\ts_config *config;\n\tconfig = config_get_config();\n\tchar *rhid;\n\tchar *rhidraw = NULL;\n\n\tptr = firstclient;\n\n\twhile (ptr) {\n\t\t//Check if token (tok) or hash_id (hid) mode\n\t\tif (strlen(token) > 8) {\n\t\t\t// hid mode\n\t\t\trhidraw = safe_calloc(SMALL_BUF);\n\t\t\tsafe_snprintf(rhidraw, SMALL_BUF, \"%s%s\", ptr->hid, config->fas_key);\n\n\t\t\trhid = safe_calloc(SMALL_BUF);\n\t\t\thash_str(rhid, SMALL_BUF, rhidraw);\n\n\t\t\tfree(rhidraw);\n\n\t\t\tif (token && !strcmp(rhid, token)) {\n\t\t\t\t// rhid is valid\n\t\t\t\tfree (rhid);\n\t\t\t\treturn ptr;\n\t\t\t}\n\n\t\t\tfree(rhid);\n\n\t\t} else {\n\t\t\t// tok mode\n\t\t\tif (token && !strcmp(ptr->token, token)) {\n\t\t\t\t// Token is valid\n\t\t\t\treturn ptr;\n\t\t\t}\n\t\t}\n\n\t\tptr = ptr->next;\n\t}\n\n\treturn NULL;\n}\n\n/** @internal\n * @brief Frees the memory used by a t_client structure\n * This function frees the memory used by the t_client structure in the\n * proper order.\n * @param client Points to the client to be freed\n */\nstatic void\n_client_list_free_node(t_client *client)\n{\n\n\tchar *msg;\n\tchar *cidinfo;\n\n\tif (client->cid) {\n\n\t\t// Remove any existing cidfile:\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t}\n\n\tfree(client->token);\n\tfree(client->hid);\n\tfree(client->custom);\n\tfree(client->client_type);\n\tfree(client->cid);\n\n\tif (strcmp(client->cpi_query, \"\") == 0) {\n\t\tfree(client->cpi_query);\n\t}\n\n\tfree(client);\n}\n\n/**\n * @brief Deletes a client from the client list\n *\n * Removes the specified client from the client list and then calls\n * the function _client_list_free_node to free the memory taken by the client.\n * @param client Points to the client to be deleted\n */\nvoid\nclient_list_delete(t_client *client)\n{\n\tt_client *ptr;\n\n\tptr = firstclient;\n\n\tif (ptr == NULL) {\n\t\tdebug(LOG_ERR, \"Node list empty!\");\n\t} else if (ptr == client) {\n\t\tdebug(LOG_NOTICE, \"Deleting %s %s token %s from client list\",\n\t\t\t  client->ip, client->mac, client->token ? client->token : \"none\");\n\t\tfirstclient = ptr->next;\n\t\t_client_list_free_node(client);\n\t\tclient_count--;\n\t} else {\n\t\t// Loop forward until we reach our point in the list.\n\t\twhile (ptr->next != NULL && ptr->next != client) {\n\t\t\tptr = ptr->next;\n\t\t}\n\t\t// If we reach the end before finding out element, complain.\n\t\tif (ptr->next == NULL) {\n\t\t\tdebug(LOG_ERR, \"Node to delete could not be found.\");\n\t\t} else {\n\t\t\t// Free element.\n\t\t\tdebug(LOG_NOTICE, \"Deleting %s %s token %s from client list\",\n\t\t\t\t  client->ip, client->mac, client->token ? client->token : \"none\");\n\t\t\tptr->next = client->next;\n\t\t\t_client_list_free_node(client);\n\t\t\tclient_count--;\n\t\t}\n\t}\n}\n", "/************************************************************************\\\n * This program is free software; you can redistribute it and/or\t*\n * modify it under the terms of the GNU General Public License as\t*\n * published by the Free:Software Foundation; either version 2 of\t*\n * the License, or (at your option) any later version.\t\t\t*\n *\t\t\t\t\t\t\t\t\t*\n * This program is distributed in the hope that it will be useful,\t*\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\t*\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t\t*\n * See the GNU General Public License for more details.\t\t*\n\\************************************************************************/\n\n/** @internal\n * @file http_microhttpd.c\n * @brief a httpd implementation using libmicrohttpd\n * @author Copyright (C) 2015 Alexander Couzens <lynxis@fe80.eu>\n * @author Copyright (C) 2015-2023 The openNDS contributors <opennds@blue-wave.net>\n * @author Copyright (C) 2015-2023 Modifications and additions by BlueWave Projects and Services <opennds@blue-wave.net>\n */\n\n\n#include <microhttpd.h>\n#include <syslog.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <pthread.h>\n#include <linux/limits.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#include \"client_list.h\"\n#include \"conf.h\"\n#include \"common.h\"\n#include \"debug.h\"\n#include \"auth.h\"\n#include \"http_microhttpd.h\"\n#include \"http_microhttpd_utils.h\"\n#include \"fw_iptables.h\"\n#include \"mimetypes.h\"\n#include \"safe.h\"\n#include \"util.h\"\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n\n// Max length of a query string QUERYMAXLEN in bytes defined in common.h\n\n// Max dynamic html page size HTMLMAXSIZE in bytes defined in common.h\n\n\nstatic t_client *add_client(const char mac[], const char ip[]);\nstatic int authenticated(struct MHD_Connection *connection, const char *url, t_client *client);\nstatic int preauthenticated(struct MHD_Connection *connection, const char *url, t_client *client);\nstatic int authenticate_client(struct MHD_Connection *connection, const char *redirect_url, t_client *client);\nstatic enum MHD_Result get_host_value_callback(void *cls, enum MHD_ValueKind kind, const char *key, const char *value);\nstatic enum MHD_Result get_user_agent_callback(void *cls, enum MHD_ValueKind kind, const char *key, const char *value);\nstatic enum MHD_Result get_accept_callback(void *cls, enum MHD_ValueKind kind, const char *key, const char *value);\nstatic int serve_file(struct MHD_Connection *connection, t_client *client, const char *url);\nstatic int show_preauthpage(struct MHD_Connection *connection, const char *query);\nstatic int send_json(struct MHD_Connection *connection, const char *json);\nstatic int encode_and_redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *originurl, const char *querystr);\nstatic int redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *host, const char *url);\nstatic int send_error(struct MHD_Connection *connection, int error);\nstatic int send_redirect_temp(struct MHD_Connection *connection, t_client *client, const char *url);\nstatic int is_foreign_hosts(struct MHD_Connection *connection, const char *host);\nstatic int get_query(struct MHD_Connection *connection, char **collect_query, const char *separator);\nstatic char *construct_querystring(struct MHD_Connection *connection, t_client *client, char *originurl, char *querystr);\nstatic const char *lookup_mimetype(const char *filename);\n\nstruct MHD_Daemon * webserver = NULL;\n\nvoid stop_mhd(void)\n{\n\tdebug(LOG_INFO, \"Calling MHD_stop_daemon [%lu]\", webserver);\n\tMHD_stop_daemon(webserver);\n}\n\nvoid start_mhd(void)\n{\n\t// Initializes the web server\n\ts_config *config;\n\tconfig = config_get_config();\n\n\tif ((webserver = MHD_start_daemon(\n\t\tMHD_USE_INTERNAL_POLLING_THREAD | MHD_USE_THREAD_PER_CONNECTION | MHD_USE_TCP_FASTOPEN,\n\t\tconfig->gw_port,\n\t\tNULL,\n\t\tNULL,\n\t\tlibmicrohttpd_cb,\n\t\tNULL,\n\t\tMHD_OPTION_CONNECTION_LIMIT, (unsigned int) 100,\n\t\tMHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 10,\n\t\tMHD_OPTION_PER_IP_CONNECTION_LIMIT, (unsigned int) 10,\n\t\tMHD_OPTION_END)) == NULL) {\n\n\t\tdebug(LOG_ERR, \"Could not create web server: %s\", strerror(errno));\n\t\texit(1);\n\n\t}\n\n\tdebug(LOG_INFO, \"MHD Handle [%lu]\", webserver);\n}\n\n\n/* Call the BinAuth script or program with output and input arguments.\n * Output arguments to BinAuth:\n * We will send client->mac, username_enc, password_enc, redirect_url_enc_buf, enc_user_agent, client->ip, client->token, custom_enc.\n * The BinAuth script will return &seconds, &upload_rate, &download_rate, &upload_quota, &download_quota\n *\n * Input arguments from BinAuth:\n * BinAuth will return values for Session length, rates and quotas.\n * It is the responsibility of the script to obtain/calculate/generate these values.\n*/\n\nstatic int do_binauth(\n\tstruct MHD_Connection *connection,\n\tconst char *binauth,\n\tt_client *client,\n\tint *seconds_ret,\n\tunsigned long long int *upload_rate_ret,\n\tunsigned long long int *download_rate_ret,\n\tunsigned long long int *upload_quota_ret,\n\tunsigned long long int *download_quota_ret,\n\tconst char *redirect_url\n\t)\n{\n\n\tchar *redirect_url_enc_buf;\n\tconst char *custom;\n\tchar *custom_enc;\n\tchar *msg;\n\tchar *argv = NULL;\n\tconst char *user_agent;\n\tchar *enc_user_agent;\n\tint seconds;\n\tunsigned long long int upload_rate;\n\tunsigned long long int download_rate;\n\tunsigned long long int upload_quota;\n\tunsigned long long int download_quota;\n\tint rc =1;\n\n\t// Get the client user agent\n\tuser_agent = safe_calloc(USER_AGENT);\n\n\tMHD_get_connection_values(connection, MHD_HEADER_KIND, get_user_agent_callback, &user_agent);\n\n\tif (user_agent == NULL) {\n\t\treturn send_error(connection, 403);\n\t}\n\n\tdebug(LOG_DEBUG, \"BinAuth: User Agent is [ %s ]\", user_agent);\n\n\t// Get custom data string as passed in the query string\n\tcustom = safe_calloc(CUSTOM);\n\n\tcustom = MHD_lookup_connection_value(connection, MHD_GET_ARGUMENT_KIND, \"custom\");\n\n\tif (!custom || strlen(custom) == 0) {\n\t\tcustom=\"bmE=\";\n\t}\n\n\tcustom_enc = safe_calloc(CUSTOM_ENC);\n\tuh_urlencode(custom_enc, CUSTOM_ENC, custom, strlen(custom));\n\n\tdebug(LOG_DEBUG, \"BinAuth: custom data [ %s ]\", custom_enc);\n\n\tredirect_url_enc_buf = safe_calloc(REDIRECT_URL_ENC_BUF);\n\tuh_urlencode(redirect_url_enc_buf, REDIRECT_URL_ENC_BUF, redirect_url, strlen(redirect_url));\n\n\tdebug(LOG_DEBUG, \"BinAuth: Redirect URL is [ %s ]\", redirect_url_enc_buf);\n\n\tenc_user_agent = safe_calloc(ENC_USER_AGENT);\n\tuh_urlencode(enc_user_agent, ENC_USER_AGENT, user_agent, strlen(user_agent));\n\n\tdebug(LOG_DEBUG, \"BinAuth: User Agent is [ %s ]\", enc_user_agent);\n\n\t// Note: username, password and user_agent may contain spaces so argument should be quoted\n\targv = safe_calloc(REDIRECT_URL_ENC_BUF + CUSTOM_ENC);\n\tsafe_snprintf(argv, REDIRECT_URL_ENC_BUF + CUSTOM_ENC, \"%s auth_client '%s' '%s' '%s' '%s' '%s' '%s'\",\n\t\tbinauth,\n\t\tclient->mac,\n\t\tredirect_url_enc_buf,\n\t\tenc_user_agent,\n\t\tclient->ip,\n\t\tclient->token,\n\t\tcustom_enc\n\t);\n\n\tdebug(LOG_DEBUG, \"BinAuth argv: %s\", argv);\n\n\t// ndsctl will deadlock if run within the BinAuth script so lock it\n\tmsg = safe_calloc(SMALL_BUF);\n\n\tif(ndsctl_lock() == 0) {\n\t\t// execute the script\n\t\trc = execute_ret_url_encoded(msg, SMALL_BUF, argv);\n\t\tdebug(LOG_DEBUG, \"BinAuth returned arguments: %s\", msg);\n\n\t\t// unlock ndsctl\n\t\tndsctl_unlock();\n\t}\n\n\tfree(custom_enc);\n\tfree(redirect_url_enc_buf);\n\tfree(enc_user_agent);\n\tfree(argv);\n\n\n\tif (rc != 0) {\n\t\tdebug(LOG_DEBUG, \"BinAuth script failed to execute\");\n\t\tfree(msg);\n\t\treturn 0;\n\t}\n\n\trc = sscanf(msg, \"%d %llu %llu %llu %llu\", &seconds, &upload_rate, &download_rate, &upload_quota, &download_quota);\n\tdebug(LOG_DEBUG, \"BinAuth returned session length: %d\", seconds);\n\tfree(msg);\n\n\t// store assigned parameters\n\tswitch (rc) {\n\t\tcase 5:\n\t\t\t*download_quota_ret = MAX(download_quota, 0);\n\t\tcase 4:\n\t\t\t*upload_quota_ret = MAX(upload_quota, 0);\n\t\tcase 3:\n\t\t\t*download_rate_ret = MAX(download_rate, 0);\n\t\tcase 2:\n\t\t\t*upload_rate_ret = MAX(upload_rate, 0);\n\t\tcase 1:\n\t\t\t*seconds_ret = MAX(seconds, 0);\n\t\tcase 0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstruct collect_query {\n\tint i;\n\tchar **elements;\n};\n\nstatic enum MHD_Result collect_query_string(void *cls, enum MHD_ValueKind kind, const char *key, const char * value)\n{\n\t// what happens when '?=foo' supplied?\n\tstruct collect_query *collect_query = cls;\n\tif (key && !value) {\n\t\tcollect_query->elements[collect_query->i] = safe_strdup(key);\n\t} else if (key && value) {\n\t\tsafe_asprintf(&(collect_query->elements[collect_query->i]), \"%s=%s\", key, value);\n\t}\n\tcollect_query->i++;\n\treturn MHD_YES;\n}\n\n// a dump iterator required for counting all elements\nstatic enum MHD_Result counter_iterator(void *cls, enum MHD_ValueKind kind, const char *key, const char *value)\n{\n\treturn MHD_YES;\n}\n\nstatic int is_foreign_hosts(struct MHD_Connection *connection, const char *host)\n{\n\tchar our_host[MAX_HOSTPORTLEN];\n\ts_config *config = config_get_config();\n\tsnprintf(our_host, MAX_HOSTPORTLEN, \"%s\", config->gw_address);\n\tdebug(LOG_DEBUG, \"Our host: %s Requested host: %s\", our_host, host);\n\n\n\t// we serve all request without a host entry as well we serve all request going to our gw_address\n\tif (host == NULL)\n\t\treturn 0;\n\n\tif (!strcmp(host, our_host))\n\t\treturn 0;\n\n\tif (!strcmp(host, config->gw_ip))\n\t\treturn 0;\n\n\tif (config->gw_fqdn) {\n\t\tif (!strcmp(host, config->gw_fqdn))\n\t\t\treturn 0;\n\t}\n\n\t// port 80 is special, because the hostname doesn't need a port\n\tif (config->gw_port == 80 && !strcmp(host, config->gw_ip))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n// @brief Get client mac by ip address from neighbor cache\nint\nget_client_mac(char mac[18], const char req_ip[])\n{\n\tchar line[255] = {0};\n\tchar ip[64];\n\tFILE *stream;\n\tint len;\n\n\tlen = strlen(req_ip);\n\n\tif ((len + 2) > sizeof(ip)) {\n\t\treturn -1;\n\t}\n\n\t// Extend search string by one space\n\tmemcpy(ip, req_ip, len);\n\tip[len] = ' ';\n\tip[len+1] = '\\0';\n\n\tstream = popen(\"ip neigh show\", \"r\");\n\tif (!stream) {\n\t\treturn -1;\n\t}\n\n\twhile (fgets(line, sizeof(line) - 1, stream) != NULL) {\n\t\tif (0 == strncmp(line, ip, len + 1)) {\n\t\t\tif (1 == sscanf(line, \"%*s %*s %*s %*s %17[A-Fa-f0-9:] \", mac)) {\n\t\t\t\tpclose(stream);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tpclose(stream);\n\n\treturn -1;\n}\n\n/**\n * @brief get_client_ip\n * @param connection\n * @return ip address - must be freed by caller\n */\nstatic int\nget_client_ip(char ip_addr[INET6_ADDRSTRLEN], struct MHD_Connection *connection)\n{\n\tconst union MHD_ConnectionInfo *connection_info;\n\tconst struct sockaddr *client_addr;\n\tconst struct sockaddr_in *addrin;\n\tconst struct sockaddr_in6 *addrin6;\n\n\tif (!(connection_info = MHD_get_connection_info(connection, MHD_CONNECTION_INFO_CLIENT_ADDRESS))) {\n\t\treturn -1;\n\t}\n\n\t// cast required for legacy MHD API < 0.9.6\n\tclient_addr = (const struct sockaddr *) connection_info->client_addr;\n\taddrin = (const struct sockaddr_in *) client_addr;\n\taddrin6 = (const struct sockaddr_in6 *) client_addr;\n\n\tswitch (client_addr->sa_family) {\n\tcase AF_INET:\n\t\tif (inet_ntop(AF_INET, &addrin->sin_addr, ip_addr, INET_ADDRSTRLEN)) {\n\t\tdebug(LOG_DEBUG, \"client ip address is [ %s ]\", ip_addr);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\n\tcase AF_INET6:\n\t\tif (inet_ntop(AF_INET6, &addrin6->sin6_addr, ip_addr, INET6_ADDRSTRLEN)) {\n\t\tdebug(LOG_DEBUG, \"client ip address is [ %s ]\", ip_addr);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\n/**\n * @brief libmicrohttpd_cb called when the client does a request to this server\n * @param cls unused\n * @param connection - client connection\n * @param url - which url was called\n * @param method - POST / GET / ...\n * @param version http 1.0 or 1.1\n * @param upload_data - unused\n * @param upload_data_size - unused\n * @param ptr - unused\n * @return\n */\nenum MHD_Result libmicrohttpd_cb(\n\tvoid *cls,\n\tstruct MHD_Connection *connection,\n\tconst char *url,\n\tconst char *method,\n\tconst char *version,\n\tconst char *upload_data,\n\tsize_t *upload_data_size,\n\tvoid **ptr) {\n\n\tt_client *client;\n\tchar ip[INET6_ADDRSTRLEN+1];\n\tchar mac[18];\n\tconst char *dds = \"../\";\n\tconst char *mhdstatus = \"/mhdstatus\";\n\tint rc = 0;\n\tchar *msg;\n\tchar *testcmd;\n\ts_config *config;\n\n\tconfig = config_get_config();\n\n\tdebug(LOG_DEBUG, \"client access: %s %s\", method, url);\n\n\t// only allow get\n\tif (0 != strcmp(method, \"GET\")) {\n\t\tdebug(LOG_DEBUG, \"Unsupported http method %s, Network Authentication required (Error 511)\", method);\n\t\treturn send_error(connection, 511);\n\t}\n\n\t// block path traversal\n\tif (strstr(url, dds) != NULL) {\n\t\tdebug(LOG_WARNING, \"Probable Path Traversal Attack Detected - %s\", url);\n\t\treturn send_error(connection, 403);\n\t}\n\n\t// check for mhdstatus request\n\tif (strstr(url, mhdstatus) != NULL) {\n\t\tdebug(LOG_DEBUG, \"MHD Status Request - %s\", url);\n\t\treturn send_error(connection, 200);\n\t}\n\n\n\t/* switch between preauth, authenticated\n\t * - always - set caching headers\n\t * a) possible implementation - redirect first and serve them using a tempo redirect\n\t * b) serve direct\n\t * should all requests redirected? even those to .css, .js, ... or respond with 404/503/...\n\t */\n\n\trc = get_client_ip(ip, connection);\n\tif (rc != 0) {\n\t\treturn send_error(connection, 503);\n\t}\n\n\n\t// check if client ip is on our subnet\n\ttestcmd = safe_calloc(SMALL_BUF);\n\tsafe_snprintf(testcmd, SMALL_BUF, \"/usr/lib/opennds/libopennds.sh get_interface_by_ip \\\"%s\\\"\", ip);\n\tmsg = safe_calloc(SMALL_BUF);\n\trc = execute_ret_url_encoded(msg, SMALL_BUF, testcmd);\n\tfree(testcmd);\n\n\tif (rc == 0) {\n\t\tdebug(LOG_DEBUG, \"Interface used to route ip [%s] is [%s]\", ip, msg);\n\t\tdebug(LOG_DEBUG, \"Gateway Interface is [%s]\", config->gw_interface);\n\n\t\tif (strcmp(config->gw_interface, msg) == 0) {\n\t\t\tdebug(LOG_DEBUG, \"Client ip address [%s] is on our subnet using interface [%s]\", ip, msg);\n\t\t} else {\n\t\t\tdebug(LOG_NOTICE, \"Client ip address [%s] is  NOT on our subnet and is using interface [%s]\", ip, msg);\n\t\t\treturn send_error(connection, 403);\n\t\t}\n\t} else {\n\t\tdebug(LOG_DEBUG, \"ip subnet test failed: Continuing...\");\n\t}\n\n\tfree (msg);\n\n\trc = get_client_mac(mac, ip);\n\tif (rc != 0) {\n\t\treturn send_error(connection, 503);\n\t}\n\n\tclient = client_list_find(mac, ip);\n\tif (!client) {\n\t\tclient = add_client(mac, ip);\n\t\tif (!client) {\n\t\t\treturn send_error(connection, 403);\n\t\t}\n\t}\n\n\tif (client && (client->fw_connection_state == FW_MARK_AUTHENTICATED ||\n\t\t\tclient->fw_connection_state == FW_MARK_TRUSTED)) {\n\t\t// client is already authenticated, maybe they clicked/tapped \"back\" on the CPD browser or maybe they want the info page.\n\t\treturn authenticated(connection, url, client);\n\t}\n\n\treturn preauthenticated(connection, url, client);\n}\n\n/**\n * @brief check if url contains authdir\n * @param url\n * @param authdir\n * @return\n *\n * url must look (\"/%s/\", authdir) to match this\n */\nstatic int check_authdir_match(const char *url, const char *authdir)\n{\n\tdebug(LOG_DEBUG, \"url is [ %s ], checking for [ %s ]\", url, authdir);\n\n\tif (strlen(url) != (2 + strlen(authdir)))\n\t\treturn 0;\n\n\tif (strncmp(url + 1, authdir, strlen(authdir)))\n\t\treturn 0;\n\n\t// match\n\treturn 1;\n}\n\n/**\n * @brief try_to_authenticate\n * @param connection\n * @param client\n * @param host\n * @param url\n * @return\n */\nstatic int try_to_authenticate(struct MHD_Connection *connection, t_client *client, const char *host, const char *url)\n{\n\ts_config *config;\n\tconst char *tok;\n\tchar *rhid;\n\tchar *rhidraw;\n\n\tconfig = config_get_config();\n\n\t// Check for authdir\n\tif (check_authdir_match(url, config->authdir)) {\n\t\ttok = MHD_lookup_connection_value(connection, MHD_GET_ARGUMENT_KIND, \"tok\");\n\n\t\tif (tok == NULL) {\n\t\t\treturn send_error(connection, 403);\n\t\t}\n\n\t\tdebug(LOG_DEBUG, \"client->token=%s tok=%s \", client->token, tok );\n\n\t\t//Check if token (tok) or hash_id (hid) mode\n\t\tif (strlen(tok) > 8) {\n\t\t\t// hid mode\n\t\t\trhidraw = safe_calloc(SMALL_BUF);\n\t\t\tsafe_snprintf(rhidraw, SMALL_BUF, \"%s%s\", client->hid, config->fas_key);\n\t\t\trhid = safe_calloc(STATUS_BUF);\n\t\t\thash_str(rhid, STATUS_BUF, rhidraw);\n\t\t\tfree (rhidraw);\n\t\t\tif (tok && !strcmp(rhid, tok)) {\n\t\t\t\t// rhid is valid\n\t\t\t\tfree(rhid);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tfree(rhid);\n\t\t} else {\n\t\t\t// tok mode\n\t\t\tif (tok && !strcmp(client->token, tok)) {\n\t\t\t\t// Token is valid\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tdebug(LOG_WARNING, \"Token is invalid\" );\n\n/*\t//TODO: do we need denydir?\n\tif (check_authdir_match(url, config->denydir)) {\n\t\t// matched to deauth\n\t\treturn 0;\n\t}\n*/\n\n\treturn 0;\n}\n\n/**\n * @brief authenticate the client and redirect them\n * @param connection\n * @param ip_addr - needs to be freed\n * @param mac - needs to be freed\n * @param redirect_url - redirect the client to this url\n * @return\n */\nstatic int authenticate_client(struct MHD_Connection *connection,\n\t\t\t\t\t\t\tconst char *redirect_url,\n\t\t\t\t\t\t\tt_client *client)\n{\n\ts_config *config = config_get_config();\n\ttime_t now = time(NULL);\n\tint seconds = 60 * config->session_timeout;\n\tunsigned long long int uploadrate = 0;\n\tunsigned long long int downloadrate = 0;\n\tunsigned long long int uploadquota = 0;\n\tunsigned long long int downloadquota = 0;\n\tint rc;\n\tint ret;\n\tchar *redirect_url_enc;\n\tchar *querystr;\n\tconst char *custom;\n\n\tclient->window_counter = 0;\n\tclient->rate_exceeded = 0;\n\tclient->initial_loop = 0;\n\tclient->upload_limiting = 0;\n\tclient->download_limiting = 0;\n\tclient->upload_rate = 0;\n\tclient->download_rate = 0;\n\tclient->uprate = 0;\n\tclient->downrate = 0;\n\tclient->upload_quota = 0;\n\tclient->download_quota = 0;\n\tclient->download_bucket_size = 0;\n\tclient->upload_bucket_size = 0;\n\tclient->inc_packet_limit = 0;\n\tclient->out_packet_limit = 0;\n\n\tclient->session_start = now;\n\n\tif (seconds > 0) {\n\t\tclient->session_end = now + seconds;\n\t} else {\n\t\tclient->session_end = 0;\n\t}\n\n\tdebug(LOG_DEBUG, \"redirect_url is [ %s ]\", redirect_url);\n\n\t// get custom string\n\tcustom = MHD_lookup_connection_value(connection, MHD_GET_ARGUMENT_KIND, \"custom\");\n\n\tif (!custom || strlen(custom) == 0) {\n\t\tcustom=\"bmE=\";\n\t}\n\n\tif (config->binauth) {\n\t\trc = do_binauth(\n\t\t\tconnection,\n\t\t\tconfig->binauth,\n\t\t\tclient,\n\t\t\t&seconds,\n\t\t\t&uploadrate,\n\t\t\t&downloadrate,\n\t\t\t&uploadquota,\n\t\t\t&downloadquota,\n\t\t\tredirect_url\n\t\t);\n\n\t\tif (rc != 0) {\n\t\t\t/*BinAuth denies access so redirect client back to login/splash page where they can try again.\n\t\t\t\tIf FAS is enabled, this will cause nesting of the contents of redirect_url,\n\t\t\t\tFAS should account for this if used with BinAuth.\n\t\t\t*/\n\n\t\t\tredirect_url_enc = safe_calloc(REDIRECT_URL_ENC_BUF);\n\t\t\tuh_urlencode(redirect_url_enc, REDIRECT_URL_ENC_BUF, redirect_url, strlen(redirect_url));\n\n\t\t\tdebug(LOG_DEBUG, \"redirect_url after binauth deny: %s\", redirect_url);\n\t\t\tdebug(LOG_DEBUG, \"redirect_url_enc after binauth deny: %s\", redirect_url_enc);\n\n\t\t\tquerystr = safe_calloc(QUERYMAXLEN);\n\t\t\tquerystr=construct_querystring(connection, client, redirect_url_enc, querystr);\n\t\t\tret = encode_and_redirect_to_splashpage(connection, client, redirect_url_enc, querystr);\n\t\t\tfree(querystr);\n\t\t\tfree(redirect_url_enc);\n\t\t\treturn ret;\n\t\t}\n\t\trc = auth_client_auth(client->id, \"client_auth\", custom);\n\t} else {\n\t\trc = auth_client_auth(client->id, NULL, custom);\n\t}\n\n\t// override remaining client values that might have been set by binauth\n\n\tif (seconds == 0) {\n\t\tseconds = (60 * config->session_timeout);\n\t}\n\n\tdebug(LOG_DEBUG, \"timeout seconds: %d\", seconds);\n\n\tif (seconds != (60 * config->session_timeout)) {\n\t\tclient->session_end = (client->session_start + seconds);\n\t}\n\n\tif (downloadrate > 0) {\n\t\tclient->download_rate = downloadrate;\n\t}\n\tif (uploadrate > 0) {\n\t\tclient->upload_rate = uploadrate;\n\t}\n\n\tif (downloadquota > 0) {\n\t\tclient->download_quota = downloadquota;\n\t}\n\tif (uploadquota > 0) {\n\t\tclient->upload_quota = uploadquota;\n\t}\n\n\n\t// error checking\n\tif (rc != 0) {\n\t\treturn send_error(connection, 503);\n\t}\n\n\tif (redirect_url) {\n\t\treturn send_redirect_temp(connection, client, redirect_url);\n\t} else {\n\t\treturn send_error(connection, 200);\n\t}\n\n\tdebug(LOG_DEBUG, \"authenticate: Session Start - %lu Session End - %lu\", client->session_start, client->session_end);\n}\n\n/**\n * @brief authenticated - called for all request from authenticated clients.\n * @param connection\n * @param ip_addr\n * @param mac\n * @param url\n * @param client\n * @return\n *\n * It's unsual to received request from clients which are already authenticated.\n * Happens when the user:\n * - clicked in multiple windows on \"accept\" -> redirect to origin - no checking\n * - when the user reloaded a splashpage -> redirect to origin\n * - when a user calls deny url -> deauth it\n */\nstatic int authenticated(struct MHD_Connection *connection,\n\t\t\t\t\t\tconst char *url,\n\t\t\t\t\t\tt_client *client)\n{\n\ts_config *config = config_get_config();\n\tconst char *host = config->gw_address;\n\tchar *redirect_to_us = NULL;\n\tchar *fasurl;\n\tchar *query;\n\tchar *msg;\n\tchar *clientif;\n\tconst char *accept;\n\tchar *originurl_raw = NULL;\n\tchar *captive_json = NULL;\n\tchar *buff;\n\tint rc;\n\tint ret;\n\tstruct MHD_Response *response;\n\n\tret = MHD_get_connection_values(connection, MHD_HEADER_KIND, get_host_value_callback, &host);\n\n\tif (ret < 1) {\n\t\tdebug(LOG_ERR, \"authenticated: Error getting host\");\n\t\treturn MHD_NO;\n\t} else {\n\t\tdebug(LOG_DEBUG, \"An authenticated client is requesting: host [%s] url [%s]\", host, url);\n\t}\n\n\tif (host == NULL) {\n\t\tdebug(LOG_ERR, \"authenticated: Error getting host\");\n\t\thost = config->gw_address;\n\t}\n\n\t// Is it an RFC8908 type request? - check Accept: header\n\n\taccept = safe_calloc(SMALL_BUF);\n\tret = MHD_get_connection_values(connection, MHD_HEADER_KIND, get_accept_callback, &accept);\n\n\tif (ret < 1) {\n\t\tdebug(LOG_ERR, \"authenticated: Error getting Accept header\");\n\t\treturn MHD_NO;\n\t}\n\n\tif (accept && strcmp(accept, \"application/captive+json\") == 0) {\n\t\tdebug(LOG_NOTICE, \"authenticated: Accept header [%s]\", accept);\n\t\tdebug(LOG_NOTICE, \"authenticated: RFC 8908 captive+json request received\");\n\n\t\toriginurl_raw = safe_calloc(SMALL_BUF);\n\t\tcaptive_json = safe_calloc(SMALL_BUF);\n\n\t\tif (strcmp(config->gw_fqdn, \"disable\") == 0 || strcmp(config->gw_fqdn, \"disabled\") == 0) {\n\t\t\tsafe_snprintf(originurl_raw, SMALL_BUF, \"http://%s\", config->gw_ip);\n\t\t} else {\n\t\t\tsafe_snprintf(originurl_raw, SMALL_BUF, \"http://%s\", config->gw_fqdn);\n\t\t}\n\n\t\tsafe_snprintf(captive_json, SMALL_BUF,\n\t\t\t\"{ \\\"captive\\\": false, \\\"user-portal-url\\\": \\\"%s\\\", \\\"venue-info-url\\\": \\\"%s\\\", \\\"can-extend-session\\\": false }\",\n\t\t\toriginurl_raw,\n\t\t\toriginurl_raw\n\t\t);\n\n\t\tdebug(LOG_DEBUG, \"captive_json [%s]\", captive_json);\n\t\tret = send_json(connection, captive_json);\n\n\t\tfree(originurl_raw);\n\t\tfree(captive_json);\n\t\treturn ret;\n\t}\n\n\t/* check if this is a late request, meaning the user tries to get the internet, but ended up here,\n\t * because the nftables rule came too late\n\t */\n\tif (is_foreign_hosts(connection, host)) {\n\t\t// might happen if the firewall rule isn't yet installed\n\t\t\treturn send_error(connection, 511);\n\t}\n\n\tif (check_authdir_match(url, config->denydir)) {\n\t\tdebug(LOG_NOTICE, \"Deauthentication request - client  [%s]\", client->mac);\n\t\tauth_client_deauth(client->id, \"client_deauth\");\n\t\tdebug(LOG_DEBUG, \"Post deauth redirection [%s]\", config->gw_address);\n\n\t\tredirect_to_us = safe_calloc(QUERYMAXLEN);\n\n\t\tif (!redirect_to_us) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(redirect_to_us);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsafe_snprintf(redirect_to_us, QUERYMAXLEN, \"http://%s/\", config->gw_address);\n\n\t\tret = send_redirect_temp(connection, client, redirect_to_us);\n\t\tfree (redirect_to_us);\n\t\treturn ret;\n\t}\n\n\tif (check_authdir_match(url, config->authdir)) {\n\t\tclientif = safe_calloc(STATUS_BUF);\n\t\tget_client_interface(clientif, STATUS_BUF, client->mac);\n\n\t\tif (config->fas_port && !config->preauth) {\n\t\t\tquery = safe_calloc(QUERYMAXLEN);\n\n\t\t\tif (!query) {\n\t\t\t\tret = send_error(connection, 503);\n\t\t\t\tfree(query);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tfasurl = safe_calloc(QUERYMAXLEN);\n\n\t\t\tif (!fasurl) {\n\t\t\t\tret = send_error(connection, 503);\n\t\t\t\tfree(fasurl);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tget_query(connection, &query, HTMLQUERYSEPARATOR);\n\n\t\t\tsafe_snprintf(fasurl, QUERYMAXLEN, \"%s%s%sstatus=authenticated\",\n\t\t\t\tconfig->fas_url,\n\t\t\t\tquery,\n\t\t\t\tHTMLQUERYSEPARATOR\n\t\t\t);\n\t\t\tdebug(LOG_DEBUG, \"fasurl [%s]\", fasurl);\n\t\t\tdebug(LOG_DEBUG, \"query [%s]\", query);\n\t\t\tret = send_redirect_temp(connection, client, fasurl);\n\t\t\tfree(clientif);\n\t\t\tfree(query);\n\t\t\tfree(fasurl);\n\t\t\treturn ret;\n\t\t} else if (config->fas_port && config->preauth) {\n\t\t\tfasurl = safe_calloc(QUERYMAXLEN);\n\t\t\tsafe_snprintf(fasurl, QUERYMAXLEN, \"?clientip=%s%sgatewayname=%s%sgatewayaddress=%s%sclientif=%s%sstatus=authenticated\",\n\t\t\t\tclient->ip,\n\t\t\t\tQUERYSEPARATOR,\n\t\t\t\tconfig->url_encoded_gw_name,\n\t\t\t\tQUERYSEPARATOR,\n\t\t\t\tconfig->gw_address,\n\t\t\t\tQUERYSEPARATOR,\n\t\t\t\tclientif,\n\t\t\t\tQUERYSEPARATOR\n\t\t\t);\n\t\t\tdebug(LOG_DEBUG, \"fasurl %s\", fasurl);\n\t\t\tret = show_preauthpage(connection, fasurl);\n\t\t\tfree(fasurl);\n\t\t\tfree(clientif);\n\t\t\treturn ret;\t\n\t\t}\n\t\tfree(clientif);\n\t}\n\n\tif (check_authdir_match(url, config->preauthdir)) {\n\n\t\tif (config->fas_port) {\n\t\t\tquery = safe_calloc(QUERYMAXLEN);\n\t\t\tfasurl = safe_calloc(QUERYMAXLEN);\n\n\t\t\tif (!query) {\n\t\t\t\tret = send_error(connection, 503);\n\t\t\t\tfree(query);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tget_query(connection, &query, QUERYSEPARATOR);\n\n\t\t\tsafe_snprintf(fasurl, QUERYMAXLEN, \"%s%sstatus=authenticated\",\n\t\t\t\tquery,\n\t\t\t\tQUERYSEPARATOR\n\t\t\t);\n\n\t\t\tdebug(LOG_DEBUG, \"preauthdir: fasurl %s\", fasurl);\n\t\t\tret = show_preauthpage(connection, fasurl);\n\t\t\tfree(query);\n\t\t\tfree(fasurl);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t// User just entered gatewayaddress:gatewayport so give them the info page\n\tif (strcmp(url, \"/\") == 0 || strcmp(url, \"/login\") == 0) {\n\t\tquery = safe_calloc(QUERYMAXLEN);\n\n\t\tif (!query) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(query);\n\t\t\treturn ret;\n\t\t}\n\n\t\tget_query(connection, &query, QUERYSEPARATOR);\n\t\tdebug(LOG_DEBUG, \"status_query=[%s]\", query);\n\n\t\tbuff = safe_calloc(MID_BUF);\n\n\t\tif (!buff) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(buff);\n\t\t\treturn ret;\n\t\t}\n\n\t\tb64_encode(buff, MID_BUF, query, strlen(query));\n\n\t\tdebug(LOG_DEBUG, \"b64_status_query=[%s]\", buff);\n\n\t\tmsg = safe_calloc(HTMLMAXSIZE);\n\n\t\tif (!msg) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(msg);\n\t\t\treturn ret;\n\t\t}\n\n\t\trc = execute_ret(msg, HTMLMAXSIZE - 1, \"%s status '%s' '%s'\", config->status_path, client->ip, buff);\n\n\t\tif (rc != 0) {\n\t\t\tdebug(LOG_WARNING, \"Script: %s - failed to execute\", config->status_path);\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(msg);\n\t\t\treturn ret;\n\t\t}\n\n\t\t// serve the script output (in msg)\n\t\tresponse = MHD_create_response_from_buffer(strlen(msg), (char *)msg, MHD_RESPMEM_MUST_FREE);\n\n\t\tif (!response) {\n\t\t\treturn send_error(connection, 503);\n\t\t}\n\n\t\tMHD_add_response_header(response, \"Content-Type\", \"text/html; charset=utf-8\");\n\t\tret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n\t\tMHD_destroy_response(response);\n\t\treturn ret;\n\t}\n\n\t// Client wants a specific file eg /images/splash.jpg etc.:\n\treturn serve_file(connection, client, url);\n}\n\n/**\n * @brief show_preauthpage - run preauth script and serve output.\n */\nstatic int show_preauthpage(struct MHD_Connection *connection, const char *query)\n{\n\ts_config *config = config_get_config();\n\n\tchar *msg;\n\tconst char *user_agent;\n\tchar *enc_user_agent;\n\tchar *preauthpath;\n\tchar *cmd;\n\tchar *enc_query;\n\n\tint rc;\n\tint ret;\n\tstruct MHD_Response *response;\n\n\tif ( strlen(query) < 1 ) {\n\t\t// query string is blank, too long or corrupt\n\t\treturn send_error(connection, 511);\n\t} else {\t\n\t\tpreauthpath = safe_calloc(SMALL_BUF);\n\t\tsafe_snprintf(preauthpath, SMALL_BUF, \"/%s/\", config->preauthdir);\n\n\t\tif (strcmp(preauthpath, config->fas_path) == 0) {\n\t\t\tfree (preauthpath);\n\n\t\t\tuser_agent = safe_calloc(USER_AGENT);\n\t\t\tdebug(LOG_DEBUG, \"PreAuth: User Agent ptr is [ %llu ]\", &user_agent);\n\t\t\tenc_user_agent = safe_calloc(ENC_USER_AGENT);\n\n\t\t\tMHD_get_connection_values(connection, MHD_HEADER_KIND, get_user_agent_callback, &user_agent);\n\t\t\tdebug(LOG_DEBUG, \"PreAuth: MHD User Agent ptr is [ %llu ]\", &user_agent);\n\n\t\t\tif (user_agent == NULL) {\n\t\t\t\treturn send_error(connection, 403);\n\t\t\t}\n\n\t\t\tuh_urlencode(enc_user_agent, ENC_USER_AGENT, user_agent, strlen(user_agent));\n\t\t\tdebug(LOG_DEBUG, \"PreAuth: Encoded User Agent is [ %s ]\", enc_user_agent);\n\n\t\t\tenc_query = safe_calloc(ENC_QUERYSTR);\n\t\t\tuh_urlencode(enc_query, ENC_QUERYSTR, query, strlen(query));\n\t\t\tdebug(LOG_DEBUG, \"PreAuth: Encoded query: %s\", enc_query);\n\n\t\t\tmsg = safe_calloc(HTMLMAXSIZE);\n\n\t\t\tif (!msg) {\n\t\t\t\tret = send_error(connection, 503);\n\t\t\t\tfree(msg);\n\t\t\t\tfree(enc_user_agent);\n\t\t\t\tfree(enc_query);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tcmd = safe_calloc(QUERYMAXLEN);\n\t\t\tsafe_snprintf(cmd, QUERYMAXLEN, \"%s '%s' '%s' '%d' '%s'\", config->preauth, enc_query, enc_user_agent, config->login_option_enabled, config->themespec_path);\n\t\t\trc = execute_ret_url_encoded(msg, HTMLMAXSIZE - 1, cmd);\n\t\t\tfree(cmd);\n\n\t\t\tif (rc != 0) {\n\t\t\t\tdebug(LOG_WARNING, \"Preauth script - failed to execute: %s, Query[%s]\", config->preauth, query);\n\t\t\t\tfree(msg);\n\t\t\t\tfree(enc_user_agent);\n\t\t\t\tfree(enc_query);\n\n\t\t\t\treturn send_error(connection, 511);\n\t\t\t}\n\n\t\t\t// serve the script output (in msg)\n\t\t\tresponse = MHD_create_response_from_buffer(strlen(msg), (char *)msg, MHD_RESPMEM_MUST_FREE);\n\n\t\t\tif (!response) {\n\t\t\t\tfree(msg);\n\t\t\t\tfree(enc_user_agent);\n\t\t\t\tfree(enc_query);\n\n\t\t\t\treturn send_error(connection, 503);\n\t\t\t}\n\n\t\t\tMHD_add_response_header(response, \"Content-Type\", \"text/html; charset=utf-8\");\n\t\t\tret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n\t\t\tMHD_destroy_response(response);\n\n\t\t\t// MHD will free(msg) when it has finished with it ( ie MHD_RESPMEM_MUST_FREE). Do not free here or MHD will page fault.\n\t\t\tfree(enc_user_agent);\n\t\t\tfree(enc_query);\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tfree (preauthpath);\n\t\t\treturn send_error(connection, 404);\n\t\t}\n\t}\n}\n\n/**\n * @brief send_json - send the rfc8908 json response.\n */\nstatic int send_json(struct MHD_Connection *connection, const char *json)\n{\n\tchar *msg;\n\tint ret;\n\tstruct MHD_Response *response;\n\n\tmsg = safe_calloc(SMALL_BUF * 2);\n\n\tif (!msg) {\n\t\tret = send_error(connection, 503);\n\t\tfree(msg);\n\t\treturn ret;\n\t}\n\n\tsafe_snprintf(msg, SMALL_BUF * 2, \"%s\", json);\n\n\tdebug(LOG_DEBUG, \"json string [%s],  buffer [%s]\", json, msg);\n\n\tresponse = MHD_create_response_from_buffer(strlen(msg), (char *)msg, MHD_RESPMEM_MUST_FREE);\n\n\tif (!response) {\n\t\tfree(msg);\n\t\tret = send_error(connection, 503);\n\t\treturn ret;\n\t}\n\n\tMHD_add_response_header(response, \"Cache-Control\", \"private\");\n\tMHD_add_response_header(response, \"Content-Type\", \"application/captive+json\");\n\tret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n\tMHD_destroy_response(response);\n\tfree(msg);\n\treturn ret;\n\n}\n\n/**\n * @brief preauthenticated - called for all request of a client in this state.\n * @param connection\n * @param ip_addr\n * @param mac\n * @return\n */\nstatic int preauthenticated(struct MHD_Connection *connection, const char *url, t_client *client)\n{\n\ts_config *config = config_get_config();\n\tconst char *host = config->gw_address;\n\tconst char *accept = NULL;\n\tconst char *redirect_url;\n\tchar *query;\n\tchar *querystr;\n\tchar *originurl;\n\tchar *originurl_raw = NULL;\n\tchar *captive_json = NULL;\n\n\tint ret;\n\n\tret = MHD_get_connection_values(connection, MHD_HEADER_KIND, get_host_value_callback, &host);\n\n\tif (ret < 1) {\n\t\tdebug(LOG_ERR, \"preauthenticated: Error getting host\");\n\t\treturn MHD_NO;\n\t}\n\n\tdebug(LOG_DEBUG, \"preauthenticated: host [%s] url [%s]\", host, url);\n\n\tif (host == NULL) {\n\t\tdebug(LOG_ERR, \"preauthenticated: Error getting host\");\n\t\thost = config->gw_address;\n\t}\n\n\t// check if this is an RFC8910 login request\n\tif (strcmp(url, \"/login\") == 0) {\n\t\tdebug(LOG_INFO, \"preauthenticated: RFC8910 login request received from client at [%s] [%s]\", client->ip, client->mac);\n\t\tclient->client_type = \"cpi_url\";\n\t\treturn redirect_to_splashpage(connection, client, host, \"/login\");\n\t}\n\n\t// Is it an RFC8908 type request? - check Accept: header\n\tret = MHD_get_connection_values(connection, MHD_HEADER_KIND, get_accept_callback, &accept);\n\n\tif (ret < 1) {\n\t\tdebug(LOG_ERR, \"preauthenticated: Error getting Accept header\");\n\t\treturn MHD_NO;\n\t}\n\n\tif (accept && strcmp(accept, \"application/captive+json\") == 0) {\n\t\tdebug(LOG_DEBUG, \"preauthenticated: Accept header [%s]\", accept);\n\t\tdebug(LOG_NOTICE, \"preauthenticated: RFC 8908 captive+json request received from client at [%s] [%s]\", client->ip, client->mac);\n\n\t\tclient->client_type = \"cpi_api\";\n\n\t\toriginurl_raw = safe_calloc(REDIRECT_URL);\n\n\t\tif (strcmp(config->gw_fqdn, \"disable\") == 0 || strcmp(config->gw_fqdn, \"disabled\") == 0) {\n\t\t\tsafe_snprintf(originurl_raw, REDIRECT_URL, \"http://%s\", config->gw_ip);\n\t\t} else {\n\t\t\tsafe_snprintf(originurl_raw, REDIRECT_URL, \"http://%s\", config->gw_fqdn);\n\t\t}\n\n\t\toriginurl = safe_calloc(REDIRECT_URL_ENC_BUF);\n\t\tuh_urlencode(originurl, REDIRECT_URL_ENC_BUF, originurl_raw, strlen(originurl_raw));\n\t\tdebug(LOG_DEBUG, \"originurl: %s\", originurl);\n\n\t\tquerystr = safe_calloc(QUERYMAXLEN);\n\n\t\tif (!querystr) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(originurl);\n\t\t\tfree(originurl_raw);\n\t\t\tfree(querystr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tquerystr=construct_querystring(connection, client, originurl, querystr);\n\t\tdebug(LOG_DEBUG, \"Constructed query string [%s]\", querystr);\n\t\tdebug(LOG_DEBUG, \"FAS url [%s]\", config->fas_url);\n\n\t\tcaptive_json = safe_calloc(QUERYMAXLEN);\n\n\t\tif (!captive_json) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(originurl);\n\t\t\tfree(originurl_raw);\n\t\t\tfree(querystr);\n\t\t\tfree(captive_json);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsafe_snprintf(captive_json, QUERYMAXLEN, \"{ \\\"captive\\\": true, \\\"user-portal-url\\\": \\\"%s%s\\\" }\", config->fas_url, querystr);\n\n\t\tdebug(LOG_DEBUG, \"captive_json [%s]\", captive_json);\n\t\tret = send_json(connection, captive_json);\n\n\t\tfree(originurl);\n\t\tfree(originurl_raw);\n\t\tfree(querystr);\n\t\tfree(captive_json);\n\t\treturn ret;\n\t}\n\n\t// Did user just access gatewayaddress:gatewayport directly or by redirect\n\tif (strcmp(url, \"/\") == 0) {\n\t\tif (strcmp(host, config->gw_address) == 0 || strcmp(host, config->gw_ip) == 0 || strcmp(host, config->gw_fqdn) == 0) {\n\t\t\treturn send_error(connection, 511);\n\t\t}\n\t}\n\n\t// Check for preauthdir\n\tif (check_authdir_match(url, config->preauthdir)) {\n\n\t\tdebug(LOG_DEBUG, \"preauthdir url detected: %s\", url);\n\t\tquery = safe_calloc(QUERYMAXLEN);\n\n\t\tif (!query) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(query);\n\t\t\treturn ret;\n\t\t}\n\n\t\tget_query(connection, &query, QUERYSEPARATOR);\n\t\tdebug(LOG_DEBUG, \"preauthenticated: show_preauthpage [%s]\", query);\n\t\tret = show_preauthpage(connection, query);\n\t\tfree(query);\n\t\treturn ret;\n\t}\n\n\t// Check for denydir\n\tif (check_authdir_match(url, config->denydir)) {\n\t\tdebug(LOG_DEBUG, \"denydir url detected: %s\", url);\n\t\treturn send_error(connection, 511);\n\t}\n\n\tdebug(LOG_DEBUG, \"preauthenticated: Requested Host is [ %s ], url is [%s]\", host, url);\n\n\t// check if this is a redirect query with a foreign host as target\n\tif (is_foreign_hosts(connection, host)) {\n\t\tdebug(LOG_DEBUG, \"preauthenticated: foreign host [%s] detected\", host);\n\t\treturn redirect_to_splashpage(connection, client, host, url);\n\t}\n\n\t// request is directed to us, check if client wants to be authenticated\n\tif (check_authdir_match(url, config->authdir)) {\n\t\tdebug(LOG_DEBUG, \"authdir url detected: %s\", url);\n\n\t\tredirect_url = safe_calloc(REDIRECT_URL);\n\n\t\tredirect_url = MHD_lookup_connection_value(connection, MHD_GET_ARGUMENT_KIND, \"redir\");\n\n\t\tif (redirect_url == NULL) {\n\t\t\treturn send_error(connection, 403);\n\t\t}\n\n\t\tif (!try_to_authenticate(connection, client, host, url)) {\n\t\t\t// user used an invalid token, redirect to splashpage but hold query \"redir\" intact\n\t\t\toriginurl = safe_calloc(REDIRECT_URL_ENC_BUF);\n\t\t\tuh_urlencode(originurl, REDIRECT_URL_ENC_BUF, redirect_url, strlen(redirect_url));\n\n\t\t\tquerystr = safe_calloc(QUERYMAXLEN);\n\n\t\t\tif (!querystr) {\n\t\t\t\tret = send_error(connection, 503);\n\t\t\t\tfree(originurl);\n\t\t\t\tfree(querystr);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tquerystr = construct_querystring(connection, client, originurl, querystr);\n\n\t\t\tret = encode_and_redirect_to_splashpage(connection, client, originurl, querystr);\n\t\t\tfree(originurl);\n\t\t\tfree(querystr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = authenticate_client(connection, redirect_url, client);\n\t\treturn ret;\n\t}\n\n\t// no special handling left - try to serve static content to the user\n\treturn serve_file(connection, client, url);\n}\n\n/**\n * @brief encode originurl and redirect the client to the splash page\n * @param connection\n * @param client\n * @param originurl\n * @return\n */\nstatic int encode_and_redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *originurl, const char *querystr)\n{\n\tchar *splashpageurl = NULL;\n\ts_config *config;\n\tint ret;\n\n\tconfig = config_get_config();\n\tsplashpageurl = safe_calloc(QUERYMAXLEN);\n\n\tif (config->fas_port) {\n\t\t// Generate secure query string or authaction url\n\t\t// Note: config->fas_path contains a leading / as it is the path from the FAS web root.\n\t\tif (config->fas_secure_enabled == 0) {\n\t\t\tsafe_snprintf(splashpageurl, QUERYMAXLEN, \"%s?authaction=http://%s/%s/%s\",\n\t\t\t\tconfig->fas_url, config->gw_address, config->authdir, querystr);\n\t\t} else if (config->fas_secure_enabled >= 1) {\n\t\t\t\tsafe_snprintf(splashpageurl, QUERYMAXLEN, \"%s%s\",\n\t\t\t\t\tconfig->fas_url, querystr);\n\t\t} else {\n\t\t\tsafe_snprintf(splashpageurl, QUERYMAXLEN, \"%s?%s\",\n\t\t\t\tconfig->fas_url, querystr);\n\t\t}\n\t}\n\n\tdebug(LOG_DEBUG, \"splashpageurl: %s\", splashpageurl);\n\n\tret = send_redirect_temp(connection, client, splashpageurl);\n\tfree(splashpageurl);\n\treturn ret;\n}\n\n/**\n * @brief redirect_to_splashpage\n * @param connection\n * @param client\n * @param host\n * @param url\n * @return\n */\nstatic int redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *host, const char *url)\n{\n\tchar *originurl_raw;\n\tchar *originurl;\n\tchar *query;\n\tint ret = 0;\n\tconst char *separator = \"&\";\n\tchar *querystr;\n\n\tquery = safe_calloc(QUERYMAXLEN);\n\n\tif (!query) {\n\t\tret = send_error(connection, 503);\n\t\tfree(query);\n\t\treturn ret;\n\t}\n\n\tquerystr = safe_calloc(QUERYMAXLEN);\n\n\tif (!querystr) {\n\t\tret = send_error(connection, 503);\n\t\tfree(querystr);\n\t\treturn ret;\n\t}\n\n\toriginurl_raw = safe_calloc(MID_BUF);\n\n\tif (!originurl_raw) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl_raw);\n\t\treturn ret;\n\t}\n\n\toriginurl = safe_calloc(CUSTOM_ENC);\n\n\tif (!originurl) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl);\n\t\treturn ret;\n\t}\n\n\tget_query(connection, &query, separator);\n\n\tif (!query) {\n\t\tdebug(LOG_DEBUG, \"Unable to get query string - error 503\");\n\t\tfree(query);\n\t\t// probably no mem\n\t\treturn send_error(connection, 503);\n\t}\n\n\tdebug(LOG_DEBUG, \"Query string is [ %s ]\", query);\n\n\tsafe_asprintf(&originurl_raw, \"http://%s%s%s\", host, url, query);\n\tuh_urlencode(originurl, CUSTOM_ENC, originurl_raw, strlen(originurl_raw));\n\n\tif (strcmp(url, \"/login\") == 0) {\n\t\tclient->cpi_query = safe_strdup(originurl);\n\t\tdebug(LOG_DEBUG, \"RFC8910 request: %s\", client->cpi_query);\n\t}\n\n\tdebug(LOG_DEBUG, \"originurl_raw: %s\", originurl_raw);\n\tdebug(LOG_DEBUG, \"originurl: %s\", originurl);\n\n\tquerystr=construct_querystring(connection, client, originurl, querystr);\n\tret = encode_and_redirect_to_splashpage(connection, client, originurl, querystr);\n\tfree(originurl_raw);\n\tfree(originurl);\n\tfree(query);\n\tfree(querystr);\n\treturn ret;\n}\n\n/**\n * @brief construct_querystring\n * @return the querystring\n */\nstatic char *construct_querystring(struct MHD_Connection *connection, t_client *client, char *originurl, char *querystr ) {\n\n\tchar cid[87] = {0};\n\tchar *clienttype;\n\tchar *clientif;\n\tchar *query_str;\n\tchar *query_str_b64;\n\tchar *msg;\n\tchar *cidinfo;\n\tchar *cidfile;\n\tchar *gw_url_raw;\n\tchar *gw_url;\n\tchar *phpcmd;\n\tint cidgood = 0;\n\n\ts_config *config = config_get_config();\n\n\tgw_url_raw = safe_calloc(REDIRECT_URL);\n\n\tif (strcmp(config->gw_fqdn, \"disable\") == 0 || strcmp(config->gw_fqdn, \"disabled\") == 0) {\n\t\tsafe_snprintf(gw_url_raw, REDIRECT_URL, \"http://%s\", config->gw_ip);\n\t} else {\n\t\tsafe_snprintf(gw_url_raw, REDIRECT_URL, \"http://%s\", config->gw_fqdn);\n\t}\n\n\tgw_url = safe_calloc(REDIRECT_URL_ENC_BUF);\n\tuh_urlencode(gw_url, REDIRECT_URL_ENC_BUF, gw_url_raw, strlen(gw_url_raw));\n\tdebug(LOG_DEBUG, \"gw_url: %s\", gw_url);\n\tfree (gw_url_raw);\n\n\tclienttype = safe_calloc(STATUS_BUF);\n\n\tif (!client->client_type || strlen(client->client_type) == 0) {\n\t\tclienttype = safe_strdup(\"cpd_can\");\n\t} else {\n\t\tclienttype = safe_strdup(client->client_type);\n\t}\n\n\tif (config->fas_secure_enabled == 0) {\n\t\tsnprintf(querystr, QUERYMAXLEN, \"?clientip=%s&gatewayname=%s&tok=%s&redir=%s\",\n\t\t\tclient->ip,\n\t\t\tconfig->url_encoded_gw_name,\n\t\t\tclient->token,\n\t\t\toriginurl\n\t\t);\n\n\t} else if (config->fas_secure_enabled == 1) {\n\n\t\t\tif (config->fas_hid) {\n\t\t\t\tdebug(LOG_DEBUG, \"hid=%s\", client->hid);\n\n\t\t\t\tclientif = safe_calloc(STATUS_BUF);\n\n\t\t\t\tget_client_interface(clientif, STATUS_BUF, client->mac);\n\t\t\t\tdebug(LOG_DEBUG, \"clientif: [%s] url_encoded_gw_name: [%s]\", clientif, config->url_encoded_gw_name);\n\n\t\t\t\tquery_str = safe_calloc(QUERYMAXLEN);\n\n\t\t\t\tsnprintf(query_str, QUERYMAXLEN,\n\t\t\t\t\t\"hid=%s%sclientip=%s%sclientmac=%s%sclient_type=%s%scpi_query=%s%sgatewayname=%s%sgatewayurl=%s%sversion=%s%sgatewayaddress=%s%sgatewaymac=%s%soriginurl=%s%sclientif=%s%sthemespec=%s%s%s%s%s%s\",\n\t\t\t\t\tclient->hid, QUERYSEPARATOR,\n\t\t\t\t\tclient->ip, QUERYSEPARATOR,\n\t\t\t\t\tclient->mac, QUERYSEPARATOR,\n\t\t\t\t\tclienttype, QUERYSEPARATOR,\n\t\t\t\t\tclient->cpi_query, QUERYSEPARATOR,\n\t\t\t\t\tconfig->url_encoded_gw_name, QUERYSEPARATOR,\n\t\t\t\t\tgw_url, QUERYSEPARATOR,\n\t\t\t\t\tVERSION, QUERYSEPARATOR,\n\t\t\t\t\tconfig->gw_address, QUERYSEPARATOR,\n\t\t\t\t\tconfig->gw_mac, QUERYSEPARATOR,\n\t\t\t\t\toriginurl, QUERYSEPARATOR,\n\t\t\t\t\tclientif, QUERYSEPARATOR,\n\t\t\t\t\tconfig->themespec_path, QUERYSEPARATOR,\n\t\t\t\t\tconfig->custom_params,\n\t\t\t\t\tconfig->custom_vars,\n\t\t\t\t\tconfig->custom_images,\n\t\t\t\t\tconfig->custom_files\n\t\t\t\t);\n\n\t\t\t\tquery_str_b64 = safe_calloc(ENC_QUERYSTR);\n\n\t\t\t\tb64_encode(query_str_b64, ENC_QUERYSTR, query_str, strlen(query_str));\n\n\t\t\t\tsnprintf(querystr, ENC_QUERYSTR,\n\t\t\t\t\t\"?fas=%s\",\n\t\t\t\t\tquery_str_b64\n\t\t\t\t);\n\n\t\t\t\tif (config->login_option_enabled >=1) {\n\t\t\t\t\tif (client->cid) {\n\t\t\t\t\t\tcidgood = 1;\n\t\t\t\t\t\tcidfile = safe_calloc(SMALL_BUF);\n\t\t\t\t\t\tsafe_snprintf(cidfile, SMALL_BUF, \"%s/ndscids/%s\", config->tmpfsmountpoint, client->cid);\n\n\t\t\t\t\t\t// Check if cidfile exists\n\t\t\t\t\t\tif(access(cidfile, F_OK) != 0) {\n\t\t\t\t\t\t\t// does not exist\n\t\t\t\t\t\t\tcidgood=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree(cidfile);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cidgood == 0) {\n\t\t\t\t\t\tstrncpy(cid, query_str_b64+5, 86);\n\t\t\t\t\t\tclient->cid = safe_strdup(cid);\n\n\t\t\t\t\t\t// Write the new cidfile:\n\t\t\t\t\t\tmsg = safe_calloc(STATUS_BUF);\n\t\t\t\t\t\tcidinfo = safe_calloc(SMALL_BUF);\n\t\t\t\t\t\tdebug(LOG_DEBUG, \"writing cid file [%s]\", cid);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"hid=\\\"%s\\\"\\0\", client->hid);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"clientip=\\\"%s\\\"\\0\", client->ip);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"clientmac=\\\"%s\\\"\\0\", client->mac);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"cpi_query=\\\"%s\\\"\\0\", client->cpi_query);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"client_type=\\\"%s\\\"\\0\", clienttype);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"gatewayname=\\\"%s\\\"\\0\", config->http_encoded_gw_name);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"gatewayurl=\\\"%s\\\"\\0\", gw_url);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"version=\\\"%s\\\"\\0\", VERSION);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"gatewayaddress=\\\"%s\\\"\\0\", config->gw_address);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"gatewaymac=\\\"%s\\\"\\0\", config->gw_mac);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"originurl=\\\"%s\\\"\\0\", originurl);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"clientif=\\\"%s\\\"\\0\", clientif);\n\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\n\t\t\t\t\t\tif (config->themespec_path) {\n\t\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"themespec=\\\"%s\\\"\\0\", config->themespec_path);\n\t\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"write\", cid, cidinfo);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (config->custom_params) {\n\t\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"%s\\0\", config->custom_params);\n\t\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"parse\", cid, cidinfo);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (config->custom_vars) {\n\t\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"%s\\0\", config->custom_vars);\n\t\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"parse\", cid, cidinfo);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (config->custom_images) {\n\t\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"%s\\0\", config->custom_images);\n\t\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"parse\", cid, cidinfo);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (config->custom_files) {\n\t\t\t\t\t\t\tsafe_snprintf(cidinfo, SMALL_BUF, \"%s\\0\", config->custom_files);\n\t\t\t\t\t\t\twrite_client_info(msg, STATUS_BUF, \"parse\", cid, cidinfo);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfree(msg);\n\t\t\t\t\t\tfree(cidinfo);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfree(query_str);\n\t\t\t\tfree(query_str_b64);\n\t\t\t\tfree(clientif);\n\n\t\t\t} else {\n\t\t\t\tsnprintf(querystr, QUERYMAXLEN,\n\t\t\t\t\t\"?clientip=%s&gatewayname=%s&redir=%s\",\n\t\t\t\t\tclient->ip,\n\t\t\t\t\tconfig->url_encoded_gw_name,\n\t\t\t\t\toriginurl\n\t\t\t\t);\n\t\t\t}\n\n\t} else if (config->fas_secure_enabled == 2 || config->fas_secure_enabled == 3) {\n\n\t\tdebug(LOG_DEBUG, \"hid=%s\", client->hid);\n\n\t\tclientif = safe_calloc(STATUS_BUF);\n\t\tget_client_interface(clientif, STATUS_BUF, client->mac);\n\t\tdebug(LOG_DEBUG, \"clientif: [%s]\", clientif);\n\t\tsnprintf(querystr, QUERYMAXLEN,\n\t\t\t\"hid=%s%sclientip=%s%sclientmac=%s%sclient_type=%s%scpi_query=%s%sgatewayname=%s%sgatewayurl=%s%sversion=%s%sgatewayaddress=%s%sgatewaymac=%s%sauthdir=%s%soriginurl=%s%sclientif=%s%sthemespec=%s%s%s%s%s%s\",\n\t\t\tclient->hid, QUERYSEPARATOR,\n\t\t\tclient->ip, QUERYSEPARATOR,\n\t\t\tclient->mac, QUERYSEPARATOR,\n\t\t\tclienttype, QUERYSEPARATOR,\n\t\t\tclient->cpi_query, QUERYSEPARATOR,\n\t\t\tconfig->url_encoded_gw_name, QUERYSEPARATOR,\n\t\t\tgw_url, QUERYSEPARATOR,\n\t\t\tVERSION, QUERYSEPARATOR,\n\t\t\tconfig->gw_address, QUERYSEPARATOR,\n\t\t\tconfig->gw_mac, QUERYSEPARATOR,\n\t\t\tconfig->authdir, QUERYSEPARATOR,\n\t\t\toriginurl, QUERYSEPARATOR,\n\t\t\tclientif, QUERYSEPARATOR,\n\t\t\tconfig->themespec_path, QUERYSEPARATOR,\n\t\t\tconfig->custom_params,\n\t\t\tconfig->custom_vars,\n\t\t\tconfig->custom_images,\n\t\t\tconfig->custom_files\n\t\t);\n\n\t\tphpcmd = safe_calloc(QUERYMAXLEN);\n\t\tsafe_snprintf(phpcmd, QUERYMAXLEN,\n\t\t\t\"echo '<?php \\n\"\n\t\t\t\"$key=\\\"%s\\\";\\n\"\n\t\t\t\"$string=\\\"%s\\\";\\n\"\n\t\t\t\"$cipher=\\\"aes-256-cbc\\\";\\n\"\n\n\t\t\t\"if (in_array($cipher, openssl_get_cipher_methods())) {\\n\"\n\t\t\t\t\"$secret_iv = base64_encode(openssl_random_pseudo_bytes(\\\"8\\\"));\\n\"\n\t\t\t\t\"$iv = substr(openssl_digest($secret_iv, \\\"sha256\\\"), 0, 16 );\\n\"\n\t\t\t\t\"$string = base64_encode( openssl_encrypt( $string, $cipher, $key, 0, $iv ) );\\n\"\n\t\t\t\t\"echo \\\"?fas=\\\".$string.\\\"&iv=\\\".$iv;\\n\"\n\t\t\t\"}\\n\"\n\t\t\t\" ?>' \"\n\t\t\t\" | %s\\n\",\n\t\t\tconfig->fas_key,\n\t\t\tquerystr,\n\t\t\tconfig->fas_ssl\n\t\t);\n\n\t\tdebug(LOG_DEBUG, \"phpcmd: %s\", phpcmd);\n\n\t\tmsg = safe_calloc(QUERYMAXLEN);\n\n\t\tif (!msg) {\n\t\t\tsend_error(connection, 503);\n\t\t\tfree(msg);\n\t\t} else {\n\n\t\t\tif (! execute_ret_url_encoded(msg, QUERYMAXLEN - 1, phpcmd) == 0) {\n\t\t\t\tdebug(LOG_ERR, \"Error encrypting query string. %s\", msg);\n\t\t\t}\n\n\t\t\tsnprintf(querystr, QUERYMAXLEN, \"%s\", msg);\n\n\t\t\tfree(msg);\n\t\t\tfree(phpcmd);\n\t\t}\n\t\tfree(clientif);\n\n\t} else {\n\t\tsnprintf(querystr, QUERYMAXLEN, \"?clientip=%s&gatewayname=%s\", client->ip, config->url_encoded_gw_name);\n\t}\n\n\tdebug(LOG_DEBUG, \"Constructed Query String [%s]\", querystr);\n\tfree(clienttype);\n\tfree(gw_url);\n\treturn querystr;\n}\n\n/**\n *\tAdd client making a request to client list.\n *\tReturn pointer to the client list entry for this client.\n *\n *\tN.B.: This does not authenticate the client; it only makes\n *\ttheir information available on the client list.\n */\nstatic t_client *\nadd_client(const char *mac, const char *ip)\n{\n\tt_client *client;\n\n\tLOCK_CLIENT_LIST();\n\tclient = client_list_add_client(mac, ip);\n\tUNLOCK_CLIENT_LIST();\n\n\treturn client;\n}\n\nint send_redirect_temp(struct MHD_Connection *connection, t_client *client, const char *url)\n{\n\t// Warning - *client will be undefined if not authenticated\n\tstruct MHD_Response *response;\n\tint ret;\n\tchar *redirect;\n\n\tredirect = safe_calloc(SMALL_BUF);\n\n\tsafe_snprintf(redirect, SMALL_BUF, \"<html><head></head><body><a href='%s'>Click here to continue to<br>%s</a></body></html\", url, url);\n\n\tdebug(LOG_DEBUG, \"send_redirect_temp: MHD_create_response_from_buffer. url [%s]\", url);\n\tdebug(LOG_DEBUG, \"send_redirect_temp: Redirect to [%s]\", redirect);\n\n\tresponse = MHD_create_response_from_buffer(SMALL_BUF, redirect, MHD_RESPMEM_MUST_FREE);\n\n\tif (!response) {\n\t\tdebug(LOG_DEBUG, \"send_redirect_temp: Failed to create response....\");\n\t\treturn send_error(connection, 503);\n\t} else {\n\t\tdebug(LOG_DEBUG, \"send_redirect_temp: Response created\");\n\t}\n\n\tret = MHD_add_response_header(response, \"Location\", url);\n\n\tif (ret == MHD_NO) {\n\t\tdebug(LOG_ERR, \"send_redirect_temp: Error adding Location header to redirection page\");\n\t} else {\n\t\tdebug(LOG_DEBUG, \"send_redirect_temp: Location header added to redirection page\");\n\t}\n\n\tret = MHD_add_response_header(response, \"Connection\", \"close\");\n\n\tif (ret == MHD_NO) {\n\t\tdebug(LOG_ERR, \"send_redirect_temp: Error adding Connection header to redirection page\");\n\t} else {\n\t\tdebug(LOG_DEBUG, \"send_redirect_temp: Connection header added to redirection page\");\n\t}\n\n\tdebug(LOG_DEBUG, \"send_redirect_temp: Queueing response\");\n\n\tret = MHD_queue_response(connection, MHD_HTTP_TEMPORARY_REDIRECT, response);\n\n\tif (ret == MHD_NO) {\n\t\tdebug(LOG_ERR, \"send_redirect_temp: Error queueing response\");\n\t} else {\n\t\tdebug(LOG_DEBUG, \"send_redirect_temp: Response is Queued\");\n\t}\n\n\tMHD_destroy_response(response);\n\n\treturn ret;\n}\n\n// save the query or empty string into **query.\nstatic int get_query(struct MHD_Connection *connection, char **query, const char *separator)\n{\n\tint element_counter;\n\tchar **elements;\n\tchar *query_str;\n\tstruct collect_query collect_query;\n\tint i;\n\tint j = 4;\n\tint length = 0;\n\n\tdebug(LOG_DEBUG, \" Getting query, separator is [%s].\", separator);\n\n\telement_counter = MHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, counter_iterator, NULL);\n\tif (element_counter < 0) {\n\t\t*query = safe_strdup(\"\");\n\t\treturn MHD_NO;\n\t}\n\telements = calloc(element_counter, sizeof(char *));\n\tif (elements == NULL) {\n\t\treturn MHD_NO;\n\t}\n\tcollect_query.i = 0;\n\tcollect_query.elements = elements;\n\n\t// Collect the arguments of the query string from MHD\n\tMHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, collect_query_string, &collect_query);\n\n\tfor (i = 0; i < element_counter; i++) {\n\t\tif (!elements[i])\n\t\t\tcontinue;\n\t\tlength += strlen(elements[i]);\n\n\t\tif (i > 0) // q=foo&o=bar the '&' need also some space\n\t\t\tlength++;\n\n\t\tdebug(LOG_DEBUG, \" cumulative element length is [%d]\", length);\n\t}\n\n\t// don't miss the zero terminator\n\tif (*query == NULL) {\n\t\tfor (i = 0; i < element_counter; i++) {\n\t\t\tfree(elements[i]);\n\t\t}\n\t\tfree(elements);\n\t\treturn 0;\n\t}\n\n\tquery_str = safe_calloc(QUERYMAXLEN);\n\n\tfor (i = 0, j = 0; i < element_counter; i++) {\n\t\tif (!elements[i]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdebug(LOG_DEBUG, \" element [%d] is [%s]\", i, elements[i]);\n\n\t\tif (length + j < QUERYMAXLEN) {\n\n\t\t\tstrncpy(*query + j, elements[i], length - j);\n\n\t\t\tif (i == 0) {\n\t\t\t\t// query_str is empty when i = 0 so safe to copy a single char into it\n\t\t\t\tstrcpy(query_str, \"?\");\n\t\t\t} else {\n\t\t\t\tif (QUERYMAXLEN - strlen(query_str) > length - j + 1) {\n\t\t\t\t\tstrncat(query_str, separator, QUERYMAXLEN - strlen(query_str));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstrncat(query_str, *query, QUERYMAXLEN - strlen(query_str));\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \" Query string is too long, invalid or corrupt so is ignored.\");\n\t\t}\n\n\t\tfree(elements[i]);\n\t}\n\n\tdebug(LOG_DEBUG, \" query is [%s]\", query_str);\n\tstrncpy(*query, query_str, QUERYMAXLEN);\n\tfree(query_str);\n\tfree(elements);\n\treturn 0;\n}\n\nstatic int send_error(struct MHD_Connection *connection, int error)\n{\n\tstruct MHD_Response *response = NULL;\n\n\t/* cannot automate since cannot translate automagically between error number and MHD's status codes\n\t * -- and cannot rely on MHD_HTTP_ values to provide an upper bound for an array\n\t */\n\tconst char *page_200 = \"<br>OK<br>\";\n\tconst char *page_400 = \"<html><head><title>Error 400</title></head><body><h1>Error 400 - Bad Request</h1></body></html>\";\n\tconst char *page_403 = \"<html><head><title>Error 403</title></head><body><h1>Error 403 - Forbidden - Access Denied to this Client!</h1></body></html>\";\n\tconst char *page_404 = \"<html><head><title>Error 404</title></head><body><h1>Error 404 - Not Found</h1></body></html>\";\n\tconst char *page_500 = \"<html><head><title>Error 500</title></head><body><h1>Error 500 - Internal Server Error: Oh No!</h1></body></html>\";\n\tconst char *page_501 = \"<html><head><title>Error 501</title></head><body><h1>Error 501 - Not Implemented</h1></body></html>\";\n\tconst char *page_503 = \"<html><head><title>Error 503</title></head><body><h1>Error 503 - Service Unavailable. This may be a temporary condition.\"\n\t\t\"</h1></body></html>\";\n\tchar *page_511;\n\tchar *cmd;\n\tconst char *mimetype = lookup_mimetype(\"foo.html\");\n\tchar ip[INET6_ADDRSTRLEN+1];\n\n\tint ret = MHD_NO;\n\ts_config *config = config_get_config();\n\n\tswitch (error) {\n\tcase 200:\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_200), (char *)page_200, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, error, response);\n\t\tbreak;\n\n\tcase 400:\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_400), (char *)page_400, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, MHD_HTTP_BAD_REQUEST, response);\n\t\tbreak;\n\n\tcase 403:\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_403), (char *)page_403, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, MHD_HTTP_FORBIDDEN, response);\n\t\tbreak;\n\n\tcase 404:\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_404), (char *)page_404, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, MHD_HTTP_NOT_FOUND, response);\n\t\tbreak;\n\n\tcase 500:\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_500), (char *)page_500, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, MHD_HTTP_INTERNAL_SERVER_ERROR, response);\n\t\tbreak;\n\n\tcase 501:\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_501), (char *)page_501, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, MHD_HTTP_NOT_IMPLEMENTED, response);\n\t\tbreak;\n\tcase 503:\n\t\tdebug(LOG_INFO, \"503: [%s] \", (char *)page_503);\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_503), (char *)page_503, MHD_RESPMEM_MUST_COPY);\n\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\tret = MHD_queue_response(connection, MHD_HTTP_SERVICE_UNAVAILABLE, response);\n\t\tbreak;\n\tcase 511:\n\t\tget_client_ip(ip, connection);\n\n\t\tpage_511 = safe_calloc(HTMLMAXSIZE);\n\n\t\tif (!page_511) {\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(page_511);\n\t\t\tbreak;\n\t\t}\n\n\t\tcmd = safe_calloc(SMALL_BUF);\n\t\tsafe_snprintf(cmd, SMALL_BUF, \"%s err511 '%s'\", config->status_path, ip);\n\n\t\tif (execute_ret_url_encoded(page_511, HTMLMAXSIZE - 1, cmd) == 0) {\n\t\t\tdebug(LOG_INFO, \"Network Authentication Required - page_511 html generated for [%s]\", ip);\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \"Script: %s - failed to execute\", config->status_path);\n\t\t\tret = send_error(connection, 503);\n\t\t\tfree(cmd);\n\t\t\tfree(page_511);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfree(cmd);\n\n\t\tresponse = MHD_create_response_from_buffer(strlen(page_511), (char *)page_511, MHD_RESPMEM_MUST_FREE);\n\n\t\tif (response) {\n\t\t\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\t\t\tMHD_add_response_header(response, MHD_HTTP_HEADER_CONNECTION, \"close\");\n\t\t\tret = MHD_queue_response(connection, MHD_HTTP_NETWORK_AUTHENTICATION_REQUIRED, response);\n\n\t\t\tif (ret == MHD_NO) {\n\t\t\t\tdebug(LOG_ERR, \"send_error 511: Error queueing response\");\n\t\t\t} else {\n\t\t\t\tdebug(LOG_DEBUG, \"send_error 511: Response is Queued\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdebug(LOG_ERR, \"send_error 511: Error queueing response\");\n\t\tbreak;\n\t}\n\n\tif (response)\n\t\tMHD_destroy_response(response);\n\treturn ret;\n}\n\n/**\n * @brief get_host_value_callback safe Host into cls which is a char**\n * @param cls - a char ** pointer to our target buffer. This buffer will be alloc in this function.\n * @param kind - see doc of\tMHD_KeyValueIterator's\n * @param key\n * @param value\n * @return MHD_YES or MHD_NO. MHD_NO means we found our item and this callback will not called again.\n */\nstatic enum MHD_Result get_host_value_callback(void *cls, enum MHD_ValueKind kind, const char *key, const char *value)\n{\n\tconst char **host = (const char **)cls;\n\n\tif (MHD_HEADER_KIND != kind) {\n\t\t*host = NULL;\n\t\treturn MHD_NO;\n\t}\n\n\tif (!strcmp(\"Host\", key)) {\n\t\t*host = value;\n\t\treturn MHD_NO;\n\t}\n\tif (key && value) {\n\n\t\tif (!strcmp(\"Host\", key)) {\n\t\t\t*host = value;\n\t\t\treturn MHD_NO;\n\t\t}\n\t}\n\n\treturn MHD_YES;\n}\n\n/**\n * @brief get_user_agent_callback save User-Agent into cls which is a char**\n * @param cls - a char ** pointer to our target buffer. This buffer will be alloc in this function.\n * @param kind - see doc of\tMHD_KeyValueIterator's\n * @param key\n * @param value\n * @return MHD_YES or MHD_NO. MHD_NO means we found our item and this callback will not called again.\n */\nstatic enum MHD_Result get_user_agent_callback(void *cls, enum MHD_ValueKind kind, const char *key, const char *value)\n{\n\tconst char **user_agent = (const char **)cls;\n\n\tif (MHD_HEADER_KIND != kind) {\n\t\t*user_agent = NULL;\n\t\treturn MHD_NO;\n\t}\n\n\tif (key && value) {\n\n\t\tif (!strcmp(\"User-Agent\", key)) {\n\t\t\t*user_agent = value;\n\t\t\treturn MHD_NO;\n\t\t}\n\t}\n\n\treturn MHD_YES;\n}\n\n/**\n * @brief get_accept_callback save Accept: into cls which is a char**\n * @param cls - a char ** pointer to our target buffer. This buffer will be alloc in this function.\n * @param kind - see doc of\tMHD_KeyValueIterator's\n * @param key\n * @param value\n * @return MHD_YES or MHD_NO. MHD_NO means we found our item and this callback will not called again.\n */\nstatic enum MHD_Result get_accept_callback(void *cls, enum MHD_ValueKind kind, const char *key, const char *value)\n{\n\tconst char **accept = (const char **)cls;\n\n\tif (MHD_HEADER_KIND != kind) {\n\t\t*accept = NULL;\n\t\treturn MHD_NO;\n\t}\n\n\tif (key && value) {\n\n\t\tif (!strcmp(\"Accept\", key)) {\n\t\t\t*accept = value;\n\t\t\treturn MHD_NO;\n\t\t}\n\t}\n\n\treturn MHD_YES;\n}\n\n/**\n * @brief return an extension like `csv` if file = '/bar/foobar.csv'.\n * @param filename\n * @return a pointer within file is returned. NULL can be returned as well as\n */\nconst char *get_extension(const char *filename)\n{\n\tint pos = strlen(filename);\n\twhile (pos > 0) {\n\t\tpos--;\n\t\tswitch (filename[pos]) {\n\t\tcase '/':\n\t\t\treturn NULL;\n\t\tcase '.':\n\t\t\treturn (filename+pos+1);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n#define DEFAULT_MIME_TYPE \"application/octet-stream\"\n\nconst char *lookup_mimetype(const char *filename)\n{\n\tint i;\n\tconst char *extension;\n\n\tif (!filename) {\n\t\treturn NULL;\n\t}\n\n\textension = get_extension(filename);\n\tif (!extension)\n\t\treturn DEFAULT_MIME_TYPE;\n\n\tfor (i = 0; i< ARRAY_SIZE(uh_mime_types); i++) {\n\t\tif (strcmp(extension, uh_mime_types[i].extn) == 0) {\n\t\t\treturn uh_mime_types[i].mime;\n\t\t}\n\t}\n\n\tdebug(LOG_ERR, \"Could not find corresponding mimetype for %s extension\", extension);\n\n\treturn DEFAULT_MIME_TYPE;\n}\n\n/**\n * @brief serve_file try to serve a request via filesystem. Using webroot as root.\n * @param connection\n * @param client\n * @return\n */\nstatic int serve_file(struct MHD_Connection *connection, t_client *client, const char *url)\n{\n\tstruct stat stat_buf;\n\ts_config *config = config_get_config();\n\tstruct MHD_Response *response;\n\tchar filename[PATH_MAX];\n\tint ret = MHD_NO;\n\tconst char *mimetype = NULL;\n\toff_t size;\n\n\tsnprintf(filename, PATH_MAX, \"%s/%s\", config->webroot, url);\n\n\t// check if file exists and is not a directory\n\tret = stat(filename, &stat_buf);\n\tif (ret) {\n\t\t// stat failed\n\t\tdebug(LOG_DEBUG, \"File %s could not be found\", filename);\n\t\treturn send_error(connection, 404);\n\t}\n\n\tif (!S_ISREG(stat_buf.st_mode)) {\n#ifdef S_ISLNK\n\t\t// ignore links\n\t\tif (!S_ISLNK(stat_buf.st_mode))\n#endif // S_ISLNK\n\t\treturn send_error(connection, 404);\n\t}\n\n\tint fd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\treturn send_error(connection, 404);\n\n\tmimetype = lookup_mimetype(filename);\n\n\t// serving file and creating response\n\tsize = lseek(fd, 0, SEEK_END);\n\tif (size < 0)\n\t\treturn send_error(connection, 404);\n\n\tresponse = MHD_create_response_from_fd(size, fd);\n\tif (!response)\n\t\treturn send_error(connection, 503);\n\n\tMHD_add_response_header(response, \"Content-Type\", mimetype);\n\tret = MHD_queue_response(connection, MHD_HTTP_OK, response);\n\tMHD_destroy_response(response);\n\n\treturn ret;\n}\n\n"], "filenames": ["src/client_list.c", "src/http_microhttpd.c"], "buggy_code_start_loc": [176, 1388], "buggy_code_end_loc": [428, 1390], "fixing_code_start_loc": [176, 1387], "fixing_code_end_loc": [443, 1387], "type": "CWE-401", "message": "An issue was discovered in the captive portal in OpenNDS before version 10.1.3. It has multiple memory leaks due to not freeing up allocated memory. This may lead to a Denial-of-Service condition due to the consumption of all available memory.", "other": {"cve": {"id": "CVE-2023-41102", "sourceIdentifier": "cve@mitre.org", "published": "2023-11-17T06:15:34.180", "lastModified": "2023-11-25T02:15:05.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the captive portal in OpenNDS before version 10.1.3. It has multiple memory leaks due to not freeing up allocated memory. This may lead to a Denial-of-Service condition due to the consumption of all available memory."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en el portal cautivo en OpenNDS antes de la versi\u00f3n 10.1.3. Tiene m\u00faltiples p\u00e9rdidas de memoria debido a que no libera la memoria asignada. Esto puede provocar una condici\u00f3n de denegaci\u00f3n de servicio debido al consumo de toda la memoria disponible."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opennds:opennds:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.1.3", "matchCriteriaId": "2E74807D-B515-4E44-A5E4-EF82D24F4AE1"}]}]}], "references": [{"url": "https://github.com/openNDS/openNDS/commit/31dbf4aa069c5bb39a7926d86036ce3b04312b51", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/openNDS/openNDS/releases/tag/v10.1.3", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/openNDS/openNDS/commit/31dbf4aa069c5bb39a7926d86036ce3b04312b51"}}