{"buggy_code": ["<?php\n\n/**\n * -------------------------------------------------------------------------\n * Fields plugin for GLPI\n * -------------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of Fields.\n *\n * Fields is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Fields is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Fields. If not, see <http://www.gnu.org/licenses/>.\n * -------------------------------------------------------------------------\n * @copyright Copyright (C) 2013-2022 by Fields plugin team.\n * @license   GPLv2 https://www.gnu.org/licenses/gpl-2.0.html\n * @link      https://github.com/pluginsGLPI/fields\n * -------------------------------------------------------------------------\n */\n\ninclude(\"../../../inc/includes.php\");\n\nif (empty($_GET[\"id\"])) {\n    $_GET[\"id\"] = \"\";\n}\n\n$container = new PluginFieldsContainer();\n\nif (isset($_POST[\"add\"])) {\n    $container->check(-1, CREATE, $_POST);\n    $newID = $container->add($_POST);\n    Html::redirect(PLUGINFIELDS_WEB_DIR . \"/front/container.form.php?id=$newID\");\n} else if (isset($_POST[\"delete\"])) {\n    $container->check($_POST['id'], DELETE);\n    $ok = $container->delete($_POST);\n    Html::redirect(PLUGINFIELDS_WEB_DIR . \"/front/container.php\");\n} else if (isset($_REQUEST[\"purge\"])) {\n    $container->check($_REQUEST['id'], PURGE);\n    $container->delete($_REQUEST, 1);\n    Html::redirect(PLUGINFIELDS_WEB_DIR . \"/front/container.php\");\n} else if (isset($_POST[\"update\"])) {\n    $container->check($_POST['id'], UPDATE);\n    $container->update($_POST);\n    Html::back();\n} else if (isset($_POST[\"update_fields_values\"])) {\n    $container->updateFieldsValues($_REQUEST, $_REQUEST['itemtype'], false);\n    Html::back();\n} else {\n    Html::header(\n        __(\"Additional fields\", \"fields\"),\n        $_SERVER['PHP_SELF'],\n        \"config\",\n        \"pluginfieldsmenu\",\n        \"fieldscontainer\"\n    );\n    $container->display(['id' => $_GET[\"id\"]]);\n    Html::footer();\n}\n", "<?php\n\n/**\n * -------------------------------------------------------------------------\n * Fields plugin for GLPI\n * -------------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of Fields.\n *\n * Fields is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Fields is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Fields. If not, see <http://www.gnu.org/licenses/>.\n * -------------------------------------------------------------------------\n * @copyright Copyright (C) 2013-2022 by Fields plugin team.\n * @license   GPLv2 https://www.gnu.org/licenses/gpl-2.0.html\n * @link      https://github.com/pluginsGLPI/fields\n * -------------------------------------------------------------------------\n */\n\nuse Glpi\\Toolbox\\Sanitizer;\n\nclass PluginFieldsContainer extends CommonDBTM\n{\n    use Glpi\\Features\\Clonable;\n\n    public static $rightname = 'config';\n\n    public static function canCreate()\n    {\n        return self::canUpdate();\n    }\n\n    public static function canPurge()\n    {\n        return self::canUpdate();\n    }\n\n    public static function titleList()\n    {\n        echo \"<div class='center'><a class='vsubmit' href='regenerate_files.php'><i class='pointer fa fa-refresh'></i>&nbsp;\" .\n            __(\"Regenerate container files\", \"fields\") . \"</a>&nbsp;&nbsp;<a class='vsubmit' href='export_to_yaml.php'><i class='pointer fa fa-refresh'></i>&nbsp;\" .\n            __(\"Export to YAML\", \"fields\") . \"</a></div><br>\";\n    }\n\n    /**\n     * Install or update plugin base data.\n     *\n     * @param Migration $migration Migration instance\n     * @param string    $version   Plugin current version\n     *\n     * @return boolean\n     */\n    public static function installBaseData(Migration $migration, $version)\n    {\n        global $DB;\n\n        $default_charset = DBConnection::getDefaultCharset();\n        $default_collation = DBConnection::getDefaultCollation();\n        $default_key_sign = DBConnection::getDefaultPrimaryKeySignOption();\n\n        $table = self::getTable();\n\n        if (!$DB->tableExists($table)) {\n            $migration->displayMessage(sprintf(__(\"Installing %s\"), $table));\n\n            $query = \"CREATE TABLE IF NOT EXISTS `$table` (\n                  `id`           INT            {$default_key_sign} NOT NULL auto_increment,\n                  `name`         VARCHAR(255)   DEFAULT NULL,\n                  `label`        VARCHAR(255)   DEFAULT NULL,\n                  `itemtypes`    LONGTEXT       DEFAULT NULL,\n                  `type`         VARCHAR(255)   DEFAULT NULL,\n                  `subtype`      VARCHAR(255)   DEFAULT NULL,\n                  `entities_id`  INT            {$default_key_sign} NOT NULL DEFAULT '0',\n                  `is_recursive` TINYINT        NOT NULL DEFAULT '0',\n                  `is_active`    TINYINT        NOT NULL DEFAULT '0',\n                  PRIMARY KEY    (`id`),\n                  KEY            `entities_id`  (`entities_id`)\n               ) ENGINE=InnoDB DEFAULT CHARSET={$default_charset} COLLATE={$default_collation} ROW_FORMAT=DYNAMIC;\";\n            $DB->query($query) or die($DB->error());\n        }\n\n        // multiple itemtype for one container\n        if (!$DB->fieldExists($table, \"itemtypes\")) {\n            $migration->changeField($table, 'itemtype', 'itemtypes', 'longtext');\n            $migration->migrationOneTable($table);\n\n            $query = \"UPDATE `$table` SET `itemtypes` = CONCAT('[\\\"', `itemtypes`, '\\\"]')\";\n            $DB->query($query) or die($DB->error());\n        }\n\n        //add display preferences for this class\n        $d_pref = new DisplayPreference();\n        $found  = $d_pref->find(['itemtype' => __CLASS__]);\n        if (count($found) === 0) {\n            for ($i = 2; $i <= 5; $i++) {\n                $DB->updateOrInsert(\n                    DisplayPreference::getTable(),\n                    [\n                        'itemtype' => __CLASS__,\n                        'num'      => $i,\n                        'rank'     => $i - 1,\n                        'users_id' => 0\n                    ],\n                    [\n                        'itemtype' => __CLASS__,\n                        'num'      => $i,\n                        'users_id' => 0\n                    ]\n                );\n            }\n        }\n\n        if (!$DB->fieldExists($table, \"subtype\")) {\n            $migration->addField($table, 'subtype', 'VARCHAR(255) DEFAULT NULL', ['after' => 'type']);\n            $migration->migrationOneTable($table);\n        }\n\n        return true;\n    }\n\n    /**\n     * Install or update user data.\n     *\n     * @param Migration $migration Migration instance\n     * @param string    $version   Plugin current version\n     *\n     * @return boolean\n     */\n    public static function installUserData(Migration $migration, $version)\n    {\n        global $DB;\n\n        // -> 0.90-1.3: generated class moved\n        // Drop them, they will be regenerated\n        $obj        = new self();\n        $containers = $obj->find();\n        foreach ($containers as $container) {\n            $itemtypes = !empty($container['itemtypes'])\n                ? json_decode($container['itemtypes'], true)\n                : [];\n\n            foreach ($itemtypes as $itemtype) {\n                $sysname = self::getSystemName($itemtype, $container['name']);\n                $class_filename = $sysname . \".class.php\";\n                if (file_exists(PLUGINFIELDS_DIR . \"/inc/$class_filename\")) {\n                    unlink(PLUGINFIELDS_DIR . \"/inc/$class_filename\");\n                }\n\n                $injclass_filename = $sysname . \"injection.class.php\";\n                if (file_exists(PLUGINFIELDS_DIR . \"/inc/$injclass_filename\")) {\n                    unlink(PLUGINFIELDS_DIR . \"/inc/$injclass_filename\");\n                }\n            }\n        }\n\n        // Regenerate container classes to ensure they can be used\n        $migration->displayMessage(__(\"Regenerate containers files\", \"fields\"));\n        $obj        = new self();\n        $containers = $obj->find();\n        foreach ($containers as $container) {\n            self::generateTemplate($container);\n        }\n\n        // Fix containers names that were generated prior to Fields 1.9.2.\n        $bad_named_containers = $DB->request(\n            [\n                'FROM' => self::getTable(),\n                'WHERE' => [\n                    'name' => [\n                        'REGEXP',\n                        $DB->escape('\\d+')\n                    ],\n                ],\n            ]\n        );\n\n        if ($bad_named_containers->count() > 0) {\n            $migration->displayMessage(__(\"Fix container names\", \"fields\"));\n\n            $toolbox = new PluginFieldsToolbox();\n\n            foreach ($bad_named_containers as $container) {\n                $old_name = $container['name'];\n\n                // Update container name\n                $new_name = $toolbox->getSystemNameFromLabel($container['label']);\n                foreach (json_decode($container['itemtypes']) as $itemtype) {\n                    while (strlen(getTableForItemType(self::getClassname($itemtype, $new_name))) > 64) {\n                        // limit tables names to 64 chars (MySQL limit)\n                        $new_name = substr($new_name, 0, -1);\n                    }\n                }\n                $container['name'] = $new_name;\n                $container_obj = new PluginFieldsContainer();\n                $container_obj->update(\n                    $container,\n                    false\n                );\n\n                // Rename container tables and itemtype if needed\n                foreach (json_decode($container['itemtypes']) as $itemtype) {\n                    $migration->renameItemtype(\n                        self::getClassname($itemtype, $old_name),\n                        self::getClassname($itemtype, $new_name)\n                    );\n                }\n            }\n        }\n\n        //Computer OS tab is no longer part of computer object. Moving to main\n        $ostab = self::findContainer(Computer::getType(), 'domtab', Computer::getType() . '$1');\n        if ($ostab) {\n            //check if we already have a container on Computer main tab\n            $comptab = self::findContainer(Computer::getType(), 'dom');\n            if ($comptab) {\n                $oscontainer = new PluginFieldsContainer();\n                $oscontainer->getFromDB($ostab);\n\n                $compcontainer = new PluginFieldsContainer();\n                $compcontainer->getFromDB($comptab);\n\n                $fields = new PluginFieldsField();\n                $fields = $fields->find(['plugin_fields_containers_id' => $ostab]);\n\n                $classname = self::getClassname(Computer::getType(), $oscontainer->fields['name']);\n                $osdata = new $classname();\n                $classname = self::getClassname(Computer::getType(), $compcontainer->fields['name']);\n                $compdata = new $classname();\n\n                $fieldnames = [];\n                //add fields to compcontainer\n                foreach ($fields as $field) {\n                    $newname = $field['name'];\n                    $compfields = $fields->find(['plugin_fields_containers_id' => $comptab, 'name' => $newname]);\n                    if ($compfields) {\n                        $newname = $newname . '_os';\n                        $DB->query(\"UPDATE glpi_plugin_fields_fields SET name='$newname' WHERE name='{$field['name']}' AND plugin_fields_containers_id='$ostab'\");\n                    }\n                    $compdata::addField($newname, $field['type']);\n                    $fieldnames[$field['name']] = $newname;\n                }\n\n                $sql = \"UPDATE glpi_plugin_fields_fields SET plugin_fields_containers_id='$comptab' WHERE plugin_fields_containers_id='$ostab'\";\n                $DB->query($sql);\n                $DB->query(\"DELETE FROM glpi_plugin_fields_containers WHERE id='$ostab'\");\n\n                //migrate existing data\n                $existings = $osdata->find();\n                foreach ($existings as $existing) {\n                    $data = [];\n                    foreach ($fieldnames as $oldname => $newname) {\n                        $data[$newname] = $existing[$oldname];\n                    }\n                    $compdata->add($data);\n                }\n\n                //drop old table\n                $DB->query(\"DROP TABLE \" . $osdata::getTable());\n            } else {\n                $sql = \"UPDATE glpi_plugin_fields_containers SET type='dom', subtype=NULL WHERE id='$ostab'\";\n                $comptab = $ostab;\n                $DB->query($sql);\n            }\n        }\n\n        // Ensure data is update before regenerating files.\n        $migration->executeMigration();\n\n        // Regenerate files and install missing tables\n        $migration->displayMessage(__(\"Updating generated containers files\", \"fields\"));\n        $obj        = new self();\n        $containers = $obj->find();\n        foreach ($containers as $container) {\n            self::create($container);\n        }\n\n        return true;\n    }\n\n    public static function uninstall()\n    {\n        global $DB;\n\n        //uninstall container table and class\n        $obj = new self();\n        $containers = $obj->find();\n        foreach ($containers as $container) {\n            $obj->delete(['id' => $container['id']]);\n        }\n\n        //drop global container table\n        $DB->query(\"DROP TABLE IF EXISTS `\" . self::getTable() . \"`\");\n\n        //delete display preferences for this item\n        $pref = new DisplayPreference();\n        $pref->deleteByCriteria([\n            'itemtype' => __CLASS__\n        ]);\n\n        return true;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function post_getEmpty()\n    {\n        $this->fields['is_active']    = 1;\n        $this->fields['is_recursive'] = 1;\n    }\n\n    public function rawSearchOptions()\n    {\n        $tab = [];\n\n        $tab[] = [\n            'id'            => 1,\n            'table'         => self::getTable(),\n            'field'         => 'name',\n            'name'          => __(\"Name\"),\n            'datatype'      => 'itemlink',\n            'itemlink_type' => self::getType(),\n            'massiveaction' => false,\n        ];\n\n        $tab[] = [\n            'id'            => 2,\n            'table'         => self::getTable(),\n            'field'         => 'label',\n            'name'          => __(\"Label\"),\n            'massiveaction' => false,\n            'autocomplete'  => true,\n        ];\n\n        $tab[] = [\n            'id'            => 3,\n            'table'         => self::getTable(),\n            'field'         => 'itemtypes',\n            'name'          => __(\"Associated item type\"),\n            'datatype'      => 'specific',\n            'massiveaction' => false,\n            'nosearch'      => true,\n        ];\n\n        $tab[] = [\n            'id'            => 4,\n            'table'         => self::getTable(),\n            'field'         => 'type',\n            'name'          => __(\"Type\"),\n            'searchtype'    => ['equals', 'notequals'],\n            'massiveaction' => false,\n        ];\n\n        $tab[] = [\n            'id'            => 5,\n            'table'         => self::getTable(),\n            'field'         => 'is_active',\n            'name'          => __(\"Active\"),\n            'datatype'      => 'bool',\n            'searchtype'    => ['equals', 'notequals'],\n        ];\n\n        $tab[] = [\n            'id'            => 6,\n            'table'         => 'glpi_entities',\n            'field'         => 'completename',\n            'name'          => __(\"Entity\"),\n            'massiveaction' => false,\n            'datatype'      => 'dropdown',\n        ];\n\n        $tab[] = [\n            'id'            => 7,\n            'table'         => self::getTable(),\n            'field'         => 'is_recursive',\n            'name'          => __(\"Child entities\"),\n            'massiveaction' => false,\n            'datatype'      => 'bool',\n        ];\n\n        $tab[] = [\n            'id'            => 8,\n            'table'         => self::getTable(),\n            'field'         => 'id',\n            'name'          => __(\"ID\"),\n            'datatype'      => 'number',\n            'massiveaction' => false,\n        ];\n\n        return $tab;\n    }\n\n    public static function getSpecificValueToDisplay($field, $values, array $options = [])\n    {\n        if (!is_array($values)) {\n            $values = [$field => $values];\n        }\n        switch ($field) {\n            case 'type':\n                $types = self::getTypes();\n                return $types[$values[$field]];\n            case 'itemtypes':\n                $types = json_decode($values[$field]);\n                $obj   = '';\n                $count = count($types);\n                $i     = 1;\n                foreach ($types as $type) {\n                    // prevent usage of plugin class if not loaded\n                    if (!class_exists($type)) {\n                        continue;\n                    }\n                    $name_type = getItemForItemtype($type);\n                    $obj .= $name_type->getTypeName(2);\n                    if ($count > $i) {\n                        $obj .= \", \";\n                    }\n                    $i++;\n                }\n                return $obj;\n        }\n    }\n\n\n    public function getValueToSelect($field_id_or_search_options, $name = '', $values = '', $options = [])\n    {\n\n        switch ($field_id_or_search_options['table'] . '.' . $field_id_or_search_options['field']) {\n            // For searchoption \"Type\"\n            case $this->getTable() . '.type':\n                $options['display'] = false;\n                return Dropdown::showFromArray($name, self::getTypes(), $options);\n            case $this->getTable() . '.itemtypes':\n                $options['display'] = false;\n                return Dropdown::showFromArray($name, self::getItemtypes(), $options);\n        }\n\n        return parent::getValueToSelect($field_id_or_search_options, $name, $values, $options);\n    }\n\n    public function defineTabs($options = [])\n    {\n        $ong = [];\n        $this->addDefaultFormTab($ong);\n        $this->addStandardTab('PluginFieldsField', $ong, $options);\n        $this->addStandardTab('PluginFieldsStatusOverride', $ong, $options);\n        $this->addStandardTab('PluginFieldsProfile', $ong, $options);\n        $this->addStandardTab('PluginFieldsContainerDisplayCondition', $ong, $options);\n        $this->addStandardTab('PluginFieldsLabelTranslation', $ong, $options);\n\n        return $ong;\n    }\n\n    public function prepareInputForAdd($input)\n    {\n        if (!isset($input['itemtypes'])) {\n            Session::AddMessageAfterRedirect(\n                __(\n                    \"You cannot add block without associated element type\",\n                    \"fields\"\n                ),\n                false,\n                ERROR\n            );\n            return false;\n        }\n\n        if (!is_array($input['itemtypes'])) {\n            $input['itemtypes'] = [$input['itemtypes']];\n        }\n\n        if ($input['type'] === \"dom\") {\n            //check for already exist dom container with this itemtype\n            $found = $this->find(['type' => 'dom']);\n            if (count($found) > 0) {\n                foreach (array_column($found, 'itemtypes') as $founditemtypes) {\n                    foreach (json_decode($founditemtypes) as $founditemtype) {\n                        if (in_array($founditemtype, $input['itemtypes'])) {\n                             Session::AddMessageAfterRedirect(__(\"You cannot add several blocks with type 'Insertion in the form' on same object\", \"fields\"), false, ERROR);\n                             return false;\n                        }\n                    }\n                }\n            }\n        }\n\n        if ($input['type'] === \"domtab\") {\n            //check for already exist domtab container with this itemtype on this tab\n            $found = $this->find(['type' => 'domtab', 'subtype' => $input['subtype']]);\n            if (count($found) > 0) {\n                foreach (array_column($found, 'itemtypes') as $founditemtypes) {\n                    foreach (json_decode($founditemtypes) as $founditemtype) {\n                        if (in_array($founditemtype, $input['itemtypes'])) {\n                             Session::AddMessageAfterRedirect(__(\"You cannot add several blocks with type 'Insertion in the form of a specific tab' on same object tab\", \"fields\"), false, ERROR);\n                             return false;\n                        }\n                    }\n                }\n            }\n        }\n\n        $toolbox = new PluginFieldsToolbox();\n        $input['name'] = $toolbox->getSystemNameFromLabel($input['label']);\n\n        //reject adding when container name is too long for mysql table name\n        foreach ($input['itemtypes'] as $itemtype) {\n            $tmp = getTableForItemType(self::getClassname($itemtype, $input['name']));\n            if (strlen($tmp) > 64) {\n                Session::AddMessageAfterRedirect(\n                    __(\"Container name is too long for database (digits in name are replaced by characters, try to remove them)\", 'fields'),\n                    false,\n                    ERROR\n                );\n                return false;\n            }\n        }\n\n        //check for already existing container with same name\n        $found = $this->find(['name' => $input['name']]);\n        if (count($found) > 0) {\n            foreach (array_column($found, 'itemtypes') as $founditemtypes) {\n                foreach (json_decode($founditemtypes) as $founditemtype) {\n                    if (in_array($founditemtype, $input['itemtypes'])) {\n                        Session::AddMessageAfterRedirect(__(\"You cannot add several blocs with identical name on same object\", \"fields\"), false, ERROR);\n                        return false;\n                    }\n                }\n            }\n        }\n\n        $input['itemtypes'] = isset($input['itemtypes'])\n            ? Sanitizer::dbEscape(json_encode($input['itemtypes']))\n            : null;\n\n        return $input;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function post_addItem()\n    {\n\n        if (!isset($this->input['clone']) || !$this->input['clone']) {\n            //create profiles associated to this container\n            PluginFieldsProfile::createForContainer($this);\n            //Create label translation\n            PluginFieldsLabelTranslation::createForItem($this);\n        }\n\n        self::create($this->fields);\n    }\n\n    public static function create($fields)\n    {\n        //create class file\n        if (!self::generateTemplate($fields)) {\n            return false;\n        }\n\n        foreach (json_decode($fields['itemtypes']) as $itemtype) {\n            //install table for receive field\n            $classname = self::getClassname($itemtype, $fields['name']);\n            $classname::install();\n        }\n    }\n\n    public static function generateTemplate($fields)\n    {\n        $itemtypes = strlen($fields['itemtypes']) > 0\n            ? json_decode($fields['itemtypes'], true)\n            : [];\n        foreach ($itemtypes as $itemtype) {\n            // prevent usage of plugin class if not loaded\n            if (!class_exists($itemtype)) {\n                continue;\n            }\n\n            $sysname   = self::getSystemName($itemtype, $fields['name']);\n            $classname = self::getClassname($itemtype, $fields['name']);\n\n            $template_class = file_get_contents(PLUGINFIELDS_DIR . \"/templates/container.class.tpl\");\n            $template_class = str_replace(\"%%CLASSNAME%%\", $classname, $template_class);\n            $template_class = str_replace(\"%%ITEMTYPE%%\", $itemtype, $template_class);\n            $template_class = str_replace(\"%%CONTAINER%%\", $fields['id'], $template_class);\n            $template_class = str_replace(\"%%ITEMTYPE_RIGHT%%\", $itemtype::$rightname, $template_class);\n            $class_filename = $sysname . \".class.php\";\n            if (file_put_contents(PLUGINFIELDS_CLASS_PATH . \"/$class_filename\", $template_class) === false) {\n                Toolbox::logDebug(\"Error : class file creation - $class_filename\");\n                return false;\n            }\n\n            // Generate Datainjection files\n            $template_class = file_get_contents(PLUGINFIELDS_DIR . \"/templates/injection.class.tpl\");\n            $template_class = str_replace(\"%%CLASSNAME%%\", $classname, $template_class);\n            $template_class = str_replace(\"%%ITEMTYPE%%\", $itemtype, $template_class);\n            $template_class = str_replace(\"%%CONTAINER_ID%%\", $fields['id'], $template_class);\n            $template_class = str_replace(\"%%CONTAINER_NAME%%\", $fields['label'], $template_class);\n            $class_filename = $sysname . \"injection.class.php\";\n            if (file_put_contents(PLUGINFIELDS_CLASS_PATH . \"/$class_filename\", $template_class) === false) {\n                Toolbox::logDebug(\"Error : datainjection class file creation - $class_filename\");\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function pre_deleteItem()\n    {\n        global $DB;\n\n        $_SESSION['delete_container'] = true;\n\n        foreach (json_decode($this->fields['itemtypes']) as $itemtype) {\n            $classname          = self::getClassname($itemtype, $this->fields['name']);\n            $sysname          = self::getSystemName($itemtype, $this->fields['name']);\n            $class_filename     = $sysname . \".class.php\";\n            $injection_filename = $sysname . \"injection.class.php\";\n\n            //delete fields\n            $field_obj = new PluginFieldsField();\n            $field_obj->deleteByCriteria([\n                'plugin_fields_containers_id' => $this->fields['id']\n            ]);\n\n            //delete display condition\n            $field_obj = new PluginFieldsContainerDisplayCondition();\n            $field_obj->deleteByCriteria([\n                'plugin_fields_containers_id' => $this->fields['id']\n            ]);\n\n            //delete profiles\n            $profile_obj = new PluginFieldsProfile();\n            $profile_obj->deleteByCriteria([\n                'plugin_fields_containers_id' => $this->fields['id']\n            ]);\n\n            //delete label translations\n            $translation_obj = new PluginFieldsLabelTranslation();\n            $translation_obj->deleteByCriteria([\n                'itemtype' => self::getType(),\n                'items_id' => $this->fields['id']\n            ]);\n\n            //delete table\n            if (class_exists($classname)) {\n                 $classname::uninstall();\n            } else {\n                //class does not exists; try to remove any existing table\n                $tablename = getTableForItemType($classname);\n                $DB->query(\"DROP TABLE IF EXISTS `$tablename`\");\n            }\n\n            //clean session\n            unset($_SESSION['delete_container']);\n\n            //remove file\n            if (file_exists(PLUGINFIELDS_CLASS_PATH . \"/$class_filename\")) {\n                unlink(PLUGINFIELDS_CLASS_PATH . \"/$class_filename\");\n            }\n\n            if (file_exists(PLUGINFIELDS_CLASS_PATH . \"/$injection_filename\")) {\n                unlink(PLUGINFIELDS_CLASS_PATH . \"/$injection_filename\");\n            }\n        }\n\n        return true;\n    }\n\n    public static function preItemPurge($item)\n    {\n        $itemtype = get_class($item);\n        $containers = new self();\n        $founded_containers = $containers->find();\n        foreach ($founded_containers as $container) {\n            $itemtypes = json_decode($container['itemtypes']);\n            if (in_array($itemtype, $itemtypes)) {\n                $classname = 'PluginFields' . $itemtype . getSingular($container['name']);\n                $fields = new $classname();\n                $fields->deleteByCriteria(['items_id' => $item->fields['id']], true);\n            }\n        }\n        return true;\n    }\n\n    public static function getTypeName($nb = 0)\n    {\n        return __(\"Block\", \"fields\");\n    }\n\n    public function showForm($ID, $options = [])\n    {\n\n        $this->initForm($ID, $options);\n\n        if (!$this->isNewID($ID)) {\n            $btn_url   = Plugin::getWebDir('fields') . '/front/export_to_yaml.php?id=' . $ID;\n            $btn_label = __(\"Export to YAML\", \"fields\");\n            $export_btn = <<<HTML\n                <a href=\"{$btn_url}\" class=\"btn btn-ghost-secondary\"\n                   title=\"{$btn_label}\"\n                   data-bs-toggle=\"tooltip\" data-bs-placement=\"bottom\">\n                    <i class=\"fas fa-file-export fa-lg\"></i>\n                </a>\nHTML;\n            $options['header_toolbar'] = [$export_btn];\n        }\n\n        $this->showFormHeader($options);\n        $rand = mt_rand();\n\n        echo \"<tr>\";\n        echo \"<td width='20%'>\" . __(\"Label\") . \" : </td>\";\n        echo \"<td width='30%'>\";\n        echo Html::input(\n            'label',\n            [\n                'value' => $this->fields['label'],\n            ]\n        );\n        echo \"</td>\";\n        echo \"<td width='20%'>&nbsp;</td>\";\n        echo \"<td width='30%'>&nbsp;</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr>\";\n        echo \"<td>\" . __(\"Type\") . \" : </td>\";\n        echo \"<td>\";\n        if ($ID > 0) {\n            $types = self::getTypes();\n            echo $types[$this->fields[\"type\"]];\n        } else {\n            Dropdown::showFromArray(\n                'type',\n                self::getTypes(),\n                [\n                    'value' => $this->fields[\"type\"],\n                    'rand'  => $rand\n                ]\n            );\n            Ajax::updateItemOnSelectEvent(\n                \"dropdown_type$rand\",\n                \"itemtypes_$rand\",\n                \"../ajax/container_itemtypes_dropdown.php\",\n                [\n                    'type'     => '__VALUE__',\n                    'itemtype' => $this->fields[\"itemtypes\"],\n                    'subtype'  => $this->fields['subtype'],\n                    'rand'     => $rand\n                ]\n            );\n        }\n        echo \"</td>\";\n        echo \"<td>\" . __(\"Associated item type\") . \" : </td>\";\n        echo \"<td>\";\n        if ($ID > 0) {\n            $types = json_decode($this->fields['itemtypes']);\n            $obj = '';\n            $count = count($types);\n            $i = 1;\n            foreach ($types as $type) {\n                // prevent usage of plugin class if not loaded\n                if (!class_exists($type)) {\n                    continue;\n                }\n\n                $name_type = getItemForItemtype($type);\n                $obj .= $name_type->getTypeName(2);\n                if ($count > $i) {\n                    $obj .= \", \";\n                }\n                $i++;\n            }\n            echo $obj;\n        } else {\n            echo \"&nbsp;<span id='itemtypes_$rand'>\";\n            self::showFormItemtype([\n                'rand'    => $rand,\n                'subtype' => $this->fields['subtype']\n            ]);\n            echo \"</span>\";\n        }\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        $display = \"style='display:none'\";\n        if (!empty($this->fields[\"subtype\"])) {\n            $display = \"\";\n        }\n        echo \"<tr id='tab_tr' $display>\";\n        echo \"<td colspan='2'></td>\";\n        echo \"<td>\" . __(\"Tab\", \"fields\") . \" : </td>\";\n        echo \"<td>\";\n        echo \"&nbsp;<span id='subtype_$rand'></span>\";\n        if ($ID > 0 && !empty($this->fields[\"subtype\"])) {\n            $itemtypes = json_decode($this->fields[\"itemtypes\"], true);\n            $itemtype = array_shift($itemtypes);\n            $item = new $itemtype();\n            $item->getEmpty();\n            $tabs = self::getSubtypes($item);\n            echo $tabs[$this->fields[\"subtype\"]];\n        }\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr>\";\n        echo \"<td>\" . __(\"Active\") . \" : </td>\";\n        echo \"<td>\";\n        Dropdown::showYesNo(\"is_active\", $this->fields[\"is_active\"]);\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        $this->showFormButtons($options);\n\n        return true;\n    }\n\n    public static function showFormItemtype($params = [])\n    {\n        $is_domtab = isset($params['type']) && $params['type'] == 'domtab';\n\n        $rand = $params['rand'];\n        Dropdown::showFromArray(\n            \"itemtypes\",\n            self::getItemtypes($is_domtab),\n            [\n                'rand'                => $rand,\n                'multiple'            => !$is_domtab,\n                'width'               => 200,\n                'display_emptychoice' => $is_domtab\n            ]\n        );\n\n        if ($is_domtab) {\n            Ajax::updateItemOnSelectEvent(\n                [\"dropdown_type$rand\", \"dropdown_itemtypes$rand\"],\n                \"subtype_$rand\",\n                \"../ajax/container_subtype_dropdown.php\",\n                [\n                    'type'     => '__VALUE0__',\n                    'itemtype' => '__VALUE1__',\n                    'subtype'  => $params[\"subtype\"],\n                    'rand'     => $rand\n                ]\n            );\n        }\n    }\n\n    /**\n     * Show subtype selection form\n     *\n     * @param array   $params  Parameters\n     * @param boolean $display Whether to display or not; defaults to false\n     *\n     * @return string|void\n     */\n    public static function showFormSubtype($params, $display = false)\n    {\n        $out = \"<script type='text/javascript'>jQuery('#tab_tr').hide();</script>\";\n        if (isset($params['type']) && $params['type'] == \"domtab\") {\n            if (class_exists($params['itemtype'])) {\n                $item = new $params['itemtype']();\n                $item->getEmpty();\n\n                $tabs = self::getSubtypes($item);\n\n                if (count($tabs)) {\n                    // delete Log of array (don't work with this tab)\n                    $tabs_to_remove = ['Log$1', 'Document_Item$1'];\n                    foreach ($tabs_to_remove as $tab_to_remove) {\n                        if (isset($tabs[$tab_to_remove])) {\n                            unset($tabs[$tab_to_remove]);\n                        }\n                    }\n\n                    // For delete <sup class='tab_nb'>number</sup> :\n                    foreach ($tabs as &$value) {\n                        $results = [];\n                        if (preg_match_all('#<sup.*>(.+)</sup>#', $value, $results)) {\n                             $value = str_replace($results[0][0], \"\", $value);\n                        }\n                    }\n\n                    if (!isset($params['subtype'])) {\n                        $params['subtype'] = null;\n                    }\n\n                    $out .= Dropdown::showFromArray(\n                        'subtype',\n                        $tabs,\n                        ['value'   => $params['subtype'],\n                            'width'   => '100%',\n                            'display' => false\n                        ]\n                    );\n                    $out .= \"<script type='text/javascript'>jQuery('#tab_tr').show();</script>\";\n                }\n            }\n        }\n        if ($display === false) {\n            return $out;\n        } else {\n            echo $out;\n        }\n    }\n\n    /**\n     * Get supported item types\n     *\n     * @param boolean $is_domtab Domtab or not\n     *\n     * @return array\n     */\n    public static function getItemtypes($is_domtab)\n    {\n        $all_itemtypes = PluginFieldsToolbox::getGlpiItemtypes();\n\n        if ($is_domtab) {\n            // Filter items that do not have tab handled\n            foreach ($all_itemtypes as $section => $itemtypes) {\n                $all_itemtypes[$section] = array_filter(\n                    $itemtypes,\n                    function ($itemtype) {\n                        return count(self::getSubtypes($itemtype)) > 0;\n                    },\n                    ARRAY_FILTER_USE_KEY\n                );\n            }\n\n            // Filter groupts that do not have items handled\n            $all_itemtypes = array_filter($all_itemtypes);\n        }\n\n        return $all_itemtypes;\n    }\n\n    public static function getTypes()\n    {\n        return [\n            'tab'    => __(\"Add tab\", \"fields\"),\n            'dom'    => __(\"Insertion in the form (before save button)\", \"fields\"),\n            'domtab' => __(\"Insertion in the form of a specific tab (before save button)\", \"fields\")\n        ];\n    }\n\n    public static function getEntries($type = 'tab', $full = false)\n    {\n        global $DB;\n\n        $condition = [\n            'is_active' => 1,\n        ];\n        if ($type !== \"all\") {\n            $condition[] = ['type' => $type];\n        }\n\n        if (!$DB->tableExists(self::getTable())) {\n            return false;\n        }\n\n        $itemtypes = [];\n        $container = new self();\n        $profile   = new PluginFieldsProfile();\n        $found     = $container->find($condition, 'label');\n        foreach ($found as $item) {\n            //entities restriction\n            if (!in_array($item['entities_id'], $_SESSION['glpiactiveentities'])) {\n                if ($item['is_recursive'] == 1) {\n                    $entities = getSonsOf(\"glpi_entities\", $item['entities_id']);\n                    if (count(array_intersect($entities, $_SESSION['glpiactiveentities'])) == 0) {\n                        continue;\n                    }\n                } else {\n                    continue;\n                }\n            }\n\n            if (Session::isCron() || !isset($_SESSION['glpiactiveprofile']['id'])) {\n                continue;\n            }\n            //profiles restriction\n            $found = $profile->find(['profiles_id' => $_SESSION['glpiactiveprofile']['id'],\n                'plugin_fields_containers_id' => $item['id'],\n                'right' => ['>=', READ]\n            ]);\n            $first_found = array_shift($found);\n            if (!$first_found || $first_found['right'] == null || $first_found['right'] == 0) {\n                continue;\n            }\n\n            $jsonitemtypes = json_decode($item['itemtypes']);\n            //show more info or not\n            foreach ($jsonitemtypes as $v) {\n                if ($full) {\n                    //check for translation\n                    $item['itemtype'] = self::getType();\n                    $label = PluginFieldsLabelTranslation::getLabelFor($item);\n                    $itemtypes[$v][$item['name']] = $label;\n                } else {\n                    $itemtypes[] = $v;\n                }\n            }\n        }\n        return $itemtypes;\n    }\n\n    public static function getUsedItemtypes($type = 'all', $must_be_active = false)\n    {\n        global $DB;\n        $itemtypes = [];\n        $where = $type == 'all' ? '1=1' : ('type = \"' . $type . '\"');\n        if ($must_be_active) {\n            $where .= ' AND is_active = 1';\n        }\n\n        $query = 'SELECT DISTINCT `itemtypes` FROM `glpi_plugin_fields_containers` WHERE ' . $where;\n        $result = $DB->query($query);\n        while (list($data) = $DB->fetchArray($result)) {\n            $jsonitemtype = json_decode($data);\n            $itemtypes    = array_merge($itemtypes, $jsonitemtype);\n        }\n\n        return $itemtypes;\n    }\n\n    public function getTabNameForItem(CommonGLPI $item, $withtemplate = 0)\n    {\n        $itemtypes = self::getEntries('tab', true);\n        if (isset($itemtypes[$item->getType()])) {\n            $tabs_entries = [];\n            $container    = new self();\n            foreach ($itemtypes[$item->getType()] as $tab_name => $tab_label) {\n                // needs to check if entity of item is in hierachy of $tab_name\n                foreach ($container->find(['is_active' => 1, 'name' => $tab_name]) as $data) {\n                    $dataitemtypes = json_decode($data['itemtypes']);\n                    if (in_array(get_class($item), $dataitemtypes) != false) {\n                        $entities = [$data['entities_id']];\n                        if ($data['is_recursive']) {\n                            $entities = getSonsOf(getTableForItemType('Entity'), $data['entities_id']);\n                        }\n\n                        if (!$item->isEntityAssign() || in_array($item->fields['entities_id'], $entities)) {\n                            $display_condition = new PluginFieldsContainerDisplayCondition();\n                            if ($display_condition->computeDisplayContainer($item, $data['id'])) {\n                                $tabs_entries[$tab_name] = $tab_label;\n                            }\n                        }\n                    }\n                }\n            }\n            return $tabs_entries;\n        }\n    }\n\n\n    public static function displayTabContentForItem(CommonGLPI $item, $tabnum = 1, $withtemplate = 0)\n    {\n        if ($withtemplate) {\n            //Do not display tab from template or from item created from template\n            return [];\n        }\n\n        //retrieve container for current tab\n        $container = new self();\n        $found_c   = $container->find(['type' => 'tab', 'name' => $tabnum, 'is_active' => 1]);\n        foreach ($found_c as $data) {\n            $dataitemtypes = json_decode($data['itemtypes']);\n            if (in_array(get_class($item), $dataitemtypes) != false) {\n                return PluginFieldsField::showForTabContainer($data['id'], $item);\n            }\n        }\n    }\n\n    /**\n     * Insert values submited by fields container\n     *\n     * @param array   $data          data posted\n     * @param string  $itemtype      Item type\n     * @param boolean $massiveaction Is a massive action\n     *\n     * @return boolean\n     */\n    public function updateFieldsValues($data, $itemtype, $massiveaction = false)\n    {\n        if (self::validateValues($data, $itemtype, $massiveaction) === false) {\n            return false;\n        }\n\n        // Normalize values\n        foreach ($data as $key => $value) {\n            if (is_array($value)) {\n                // Convert \"multiple\" values into a JSON string\n                $data[$key] = json_encode($value);\n            }\n        }\n\n        $container_obj = new PluginFieldsContainer();\n        $container_obj->getFromDB($data['plugin_fields_containers_id']);\n\n        $items_id  = $data['items_id'];\n        $classname = self::getClassname($itemtype, $container_obj->fields['name']);\n\n        //check if data already inserted\n        $obj   = new $classname();\n        $found = $obj->find(['items_id' => $items_id]);\n        if (empty($found)) {\n            // add fields data\n            $obj->add($data);\n\n            //construct history on itemtype object (Historical tab)\n            self::constructHistory(\n                $data['plugin_fields_containers_id'],\n                $items_id,\n                $itemtype,\n                $data\n            );\n        } else {\n            $first_found = array_pop($found);\n            $data['id'] = $first_found['id'];\n            $obj->update($data);\n\n            //construct history on itemtype object (Historical tab)\n            self::constructHistory(\n                $data['plugin_fields_containers_id'],\n                $items_id,\n                $itemtype,\n                $data,\n                $first_found\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Add log in \"itemtype\" object on fields values update\n     * @param  int    $containers_id container id\n     * @param  int    $items_id      item id\n     * @param  string $itemtype      item type\n     * @param  array  $data          values send by update form\n     * @param  array  $old_values    old values, if empty -> values add\n     * @return void\n     */\n    public static function constructHistory(\n        $containers_id,\n        $items_id,\n        $itemtype,\n        $data,\n        $old_values = []\n    ) {\n        // Don't log few itemtypes\n        $obj = new $itemtype();\n        if ($obj->dohistory == false) {\n            return;\n        }\n\n        //get searchoptions\n        $searchoptions = self::getAddSearchOptions($itemtype, $containers_id);\n\n        //define non-data keys\n        $blacklist_k = [\n            'plugin_fields_containers_id' => 0,\n            'items_id'                    => 0,\n            'itemtype'                    => $itemtype,\n            'update_fields_values'        => 0,\n            '_glpi_csrf_token'            => 0\n        ];\n\n        //remove non-data keys\n        $data = array_diff_key($data, $blacklist_k);\n\n        //add/update values condition\n        if (empty($old_values)) {\n            // -- add new item --\n\n            foreach ($data as $key => $value) {\n                //log only not empty values\n                if (!empty($value)) {\n                    //prepare log\n                    $changes = [0, \"N/A\", $value];\n\n                    //find searchoption\n                    foreach ($searchoptions as $id_search_option => $searchoption) {\n                        if ($searchoption['linkfield'] == $key) {\n                             $changes[0] = $id_search_option;\n\n                            if ($searchoption['datatype'] === 'dropdown') {\n                                //manage dropdown values\n                                $changes = [$id_search_option,\n                                    \"\",\n                                    Dropdown::getDropdownName($searchoption['table'], $value)\n                                ];\n                            } elseif ($searchoption['datatype'] === 'bool') {\n                                //manage bool values\n                                $changes = [$id_search_option, \"\", Dropdown::getYesNo($value)];\n                            } elseif ($searchoption['datatype'] === 'specific') {\n                                //manage specific values\n                                $changes = [\n                                    $id_search_option,\n                                    \"\",\n                                    PluginFieldsAbstractContainerInstance::getSpecificValueToDisplay(\n                                        $key,\n                                        $value,\n                                        [\n                                            'searchopt' => $searchoption,\n                                            'separator' => ', ',\n                                        ]\n                                    )\n                                ];\n                            }\n                        }\n                    }\n\n                    //add log\n                    Log::history($items_id, $itemtype, $changes);\n                }\n            }\n        } else {\n            // -- update existing item --\n\n            //find changes\n            $updates = [];\n            foreach ($old_values as $key => $old_value) {\n                if (\n                    !isset($data[$key])\n                    || empty($old_value) && empty($data[$key])\n                    || $old_value !== '' && $data[$key] == 'NULL'\n                ) {\n                    continue;\n                }\n\n                if ($data[$key] !== $old_value) {\n                    $updates[$key] = [0, $old_value ?? '', $data[$key]];\n                }\n            }\n\n            //for all change find searchoption\n            foreach ($updates as $key => $changes) {\n                foreach ($searchoptions as $id_search_option => $searchoption) {\n                    if ($searchoption['linkfield'] == $key) {\n                        $changes[0] = $id_search_option;\n\n                        if ($searchoption['datatype'] === 'dropdown') {\n                            //manage dropdown values\n                            $changes[1] = Dropdown::getDropdownName($searchoption['table'], $changes[1]);\n                            $changes[2] = Dropdown::getDropdownName($searchoption['table'], $changes[2]);\n                        } elseif ($searchoption['datatype'] === 'bool') {\n                            //manage bool values\n                            $changes[1] = Dropdown::getYesNo($changes[1]);\n                            $changes[2] = Dropdown::getYesNo($changes[2]);\n                        } elseif ($searchoption['datatype'] === 'specific') {\n                            //manage specific values\n                            $changes[1] = PluginFieldsAbstractContainerInstance::getSpecificValueToDisplay(\n                                $key,\n                                $changes[1],\n                                [\n                                    'searchopt' => $searchoption,\n                                    'separator' => ', ',\n                                ]\n                            );\n                            $changes[2] = PluginFieldsAbstractContainerInstance::getSpecificValueToDisplay(\n                                $key,\n                                $changes[2],\n                                [\n                                    'searchopt' => $searchoption,\n                                    'separator' => ', ',\n                                ]\n                            );\n                        }\n                    }\n                }\n\n                //add log\n                Log::history($items_id, $itemtype, $changes);\n            }\n        }\n    }\n\n    /**\n     * check data inserted\n     * display a message when not ok\n     *\n     * @param array   $data          Data send by form\n     * @param string  $itemtype      Item type\n     * @param boolean $massiveaction ?\n     *\n     * @return boolean\n     */\n    public static function validateValues($data, $itemtype, $massiveaction)\n    {\n        global $DB;\n\n        $valid         = true;\n        $empty_errors  = [];\n        $number_errors = [];\n\n        $container = new self();\n        $container->getFromDB($data['plugin_fields_containers_id']);\n\n        $field_obj = new PluginFieldsField();\n        $fields = $field_obj->find([\n            'plugin_fields_containers_id' => $data['plugin_fields_containers_id']\n        ]);\n\n        // Apply status overrides\n        $status_field_name = PluginFieldsStatusOverride::getStatusFieldName($itemtype);\n        $status_overrides = array_key_exists($status_field_name, $data) && $data[$status_field_name] !== null\n            ? PluginFieldsStatusOverride::getOverridesForItemtypeAndStatus($container->getID(), $itemtype, $data[$status_field_name])\n            : [];\n        foreach ($status_overrides as $status_override) {\n            if (isset($fields[$status_override['plugin_fields_fields_id']])) {\n                $fields[$status_override['plugin_fields_fields_id']]['is_readonly'] = $status_override['is_readonly'];\n                $fields[$status_override['plugin_fields_fields_id']]['mandatory'] = $status_override['mandatory'];\n            }\n        }\n\n        foreach ($fields as $field) {\n            if (!$field['is_active']) {\n                continue;\n            }\n\n            if ($field['type'] == \"yesno\" || $field['type'] == \"header\") {\n                continue;\n            }\n\n            $name  = $field['name'];\n            $value = null;\n\n            if ($field['type'] == \"glpi_item\") {\n                $itemtype_key = sprintf('itemtype_%s', $name);\n                $items_id_key = sprintf('items_id_%s', $name);\n\n                if (\n                    isset($data[$itemtype_key], $data[$items_id_key])\n                    && is_a($data[$itemtype_key], CommonDBTM::class, true)\n                    && $data[$items_id_key] > 0\n                ) {\n                    $glpi_item = new $data[$itemtype_key]();\n                    $value = $glpi_item->getFromDB($data[$items_id_key]) ? $data[$items_id_key] : null;\n                }\n            } elseif (isset($data[$name])) {\n                $value = $data[$name];\n            } else if (isset($data['plugin_fields_' . $name . 'dropdowns_id'])) {\n                $value = $data['plugin_fields_' . $name . 'dropdowns_id'];\n            } else if ($field['mandatory'] == 1 && isset($data['items_id'])) {\n                $tablename = getTableForItemType(self::getClassname($itemtype, $container->fields['name']));\n\n                $query = \"SELECT * FROM `$tablename` WHERE\n                    `itemtype`='$itemtype'\n                    AND `items_id`='{$data['items_id']}'\n                    AND `plugin_fields_containers_id`='{$data['plugin_fields_containers_id']}'\";\n\n                $db_result = [];\n                if ($result = $DB->query($query)) {\n                    $db_result = $DB->fetchAssoc($result);\n                    if (isset($db_result['plugin_fields_' . $name . 'dropdowns_id'])) {\n                        $value = $db_result['plugin_fields_' . $name . 'dropdowns_id'];\n                    } else if (isset($db_result[$name])) {\n                        $value = $db_result[$name];\n                    }\n                }\n            } else {\n                if ($massiveaction) {\n                    continue;\n                }\n            }\n\n            //translate label\n            $field['itemtype'] = PluginFieldsField::getType();\n            $field['label'] = PluginFieldsLabelTranslation::getLabelFor($field);\n\n            // Check mandatory fields\n            if (\n                $field['mandatory'] == 1\n                && (\n                    $value === null\n                    || $value === ''\n                    || (($field['type'] === 'dropdown' || preg_match('/^dropdown-.+/i', $field['type'])) && $value == 0)\n                    || ($field['type'] === 'glpi_item' && $value === null)\n                    || (in_array($field['type'], ['date', 'datetime']) && $value == 'NULL')\n                )\n            ) {\n                $empty_errors[] = $field['label'];\n                $valid = false;\n            } else if ($field['type'] == 'number' && !empty($value) && !is_numeric($value)) {\n                // Check number fields\n                $number_errors[] = $field['label'];\n                $valid = false;\n            } else if ($field['type'] == 'url' && !empty($value)) {\n                if (filter_var($value, FILTER_VALIDATE_URL) === false) {\n                    $url_errors[] = $field['label'];\n                    $valid = false;\n                }\n            }\n        }\n\n        if (!empty($empty_errors)) {\n            Session::AddMessageAfterRedirect(__(\"Some mandatory fields are empty\", \"fields\") .\n                                          \" : \" . implode(', ', $empty_errors), false, ERROR);\n        }\n\n        if (!empty($number_errors)) {\n            Session::AddMessageAfterRedirect(__(\"Some numeric fields contains non numeric values\", \"fields\") .\n                                          \" : \" . implode(', ', $number_errors), false, ERROR);\n        }\n\n        if (!empty($url_errors)) {\n            Session::AddMessageAfterRedirect(__(\"Some URL fields contains invalid links\", \"fields\") .\n                                          \" : \" . implode(', ', $url_errors), false, ERROR);\n        }\n\n        return $valid;\n    }\n\n\n    public static function findContainer($itemtype, $type = 'tab', $subtype = '')\n    {\n\n        $condition = [\n            'is_active' => 1,\n            ['type' => $type],\n        ];\n\n        $entity = isset($_SESSION['glpiactiveentities'])\n                  ? $_SESSION['glpiactiveentities']\n                  : 0;\n        $condition += getEntitiesRestrictCriteria(\"\", \"\", $entity, true, true);\n\n        if ($subtype != '') {\n            if ($subtype == $itemtype . '$main') {\n                $condition[] = ['type' => 'dom'];\n            } else {\n                $condition[] = ['type' => ['!=', 'dom']];\n                $condition['subtype'] = $subtype;\n            }\n        }\n\n        $container = new PluginFieldsContainer();\n        $itemtypes = $container->find($condition);\n        $id = 0;\n        if (count($itemtypes) < 1) {\n            return false;\n        }\n\n        foreach ($itemtypes as $data) {\n            $dataitemtypes = json_decode($data['itemtypes']);\n            if (in_array($itemtype, $dataitemtypes) != false) {\n                $id = $data['id'];\n            }\n        }\n\n        //profiles restriction\n        if (isset($_SESSION['glpiactiveprofile']['id'])) {\n            $profile = new PluginFieldsProfile();\n            if (isset($id)) {\n                $found = $profile->find(['profiles_id' => $_SESSION['glpiactiveprofile']['id'],\n                    'plugin_fields_containers_id' => $id\n                ]);\n                $first_found = array_shift($found);\n                if ($first_found === null || $first_found['right'] == null || $first_found['right'] == 0) {\n                     return false;\n                }\n            }\n        }\n\n        return $id;\n    }\n\n    /**\n     * Post item hook for add\n     * Do store data in db\n     *\n     * @param CommonDBTM $item Item instance\n     *\n     * @return CommonDBTM|true\n     */\n    public static function postItemAdd(CommonDBTM $item)\n    {\n        if (property_exists($item, 'plugin_fields_data')) {\n            $data = $item->plugin_fields_data;\n            $data['items_id'] = $item->getID();\n            //update data\n            $container = new self();\n            if ($container->updateFieldsValues($data, $item->getType(), isset($_REQUEST['massiveaction']))) {\n                return true;\n            }\n            return $item->input = [];\n        }\n    }\n\n    /**\n     * Pre item hook for update\n     * Do store data in db\n     *\n     * @param CommonDBTM $item Item instance\n     *\n     * @return boolean\n     */\n    public static function preItemUpdate(CommonDBTM $item)\n    {\n        self::preItem($item);\n        if (property_exists($item, 'plugin_fields_data')) {\n            $data = $item->plugin_fields_data;\n            //update data\n            $container = new self();\n            if (\n                count($data) == 0\n                || $container->updateFieldsValues($data, $item->getType(), isset($_REQUEST['massiveaction']))\n            ) {\n                return true;\n            }\n            return $item->input = [];\n        }\n    }\n\n\n    /**\n     * Pre item hook for add and update\n     * Validates and store plugin data in item object\n     *\n     * @param CommonDBTM $item Item instance\n     *\n     * @return boolean\n     */\n    public static function preItem(CommonDBTM $item)\n    {\n        //find container (if not exist, do nothing)\n        if (isset($_REQUEST['c_id'])) {\n            $c_id = $_REQUEST['c_id'];\n        } else {\n            $type = 'dom';\n            if (isset($_REQUEST['_plugin_fields_type'])) {\n                $type = $_REQUEST['_plugin_fields_type'];\n            }\n            $subtype = '';\n            if ($type == 'domtab') {\n                $subtype = $_REQUEST['_plugin_fields_subtype'];\n            }\n            if (false === ($c_id = self::findContainer(get_Class($item), $type, $subtype))) {\n                // tries for 'tab'\n                if (false === ($c_id = self::findContainer(get_Class($item)))) {\n                    return false;\n                }\n            }\n        }\n\n        //need to check if container is usable on this object entity\n        $loc_c = new PluginFieldsContainer();\n        $loc_c->getFromDB($c_id);\n        $entities = [$loc_c->fields['entities_id']];\n        if ($loc_c->fields['is_recursive']) {\n            $entities = getSonsOf(getTableForItemType('Entity'), $loc_c->fields['entities_id']);\n        }\n\n        //workaround: when a ticket is created from readdonly profile,\n        //it is not initialized; see https://github.com/glpi-project/glpi/issues/1438\n        if (!isset($item->fields) || count($item->fields) == 0) {\n            $item->fields = $item->input;\n        }\n\n        if ($item->isEntityAssign() && !in_array($item->getEntityID(), $entities)) {\n            return false;\n        }\n\n        if (false !== ($data = self::populateData($c_id, $item))) {\n            if (self::validateValues($data, $item::getType(), isset($_REQUEST['massiveaction'])) === false) {\n                return $item->input = [];\n            }\n            return $item->plugin_fields_data = $data;\n        }\n\n        return;\n    }\n\n    /**\n     * Populates fields data from item\n     *\n     * @param integer    $c_id Container ID\n     * @param CommonDBTM $item Item instance\n     *\n     * @return array|false\n     */\n    private static function populateData($c_id, CommonDBTM $item)\n    {\n       //find fields associated to found container\n        $field_obj = new PluginFieldsField();\n        $fields = $field_obj->find(\n            [\n                'plugin_fields_containers_id' => $c_id,\n                'type' => ['!=', 'header']\n            ],\n            \"ranking\"\n        );\n\n       //prepare data to update\n        $data = ['plugin_fields_containers_id' => $c_id];\n        if (!$item->isNewItem()) {\n           //no ID yet while creating\n            $data['items_id'] = $item->getID();\n        }\n\n        // Add status so it can be used with status overrides\n        $status_field_name = PluginFieldsStatusOverride::getStatusFieldName($item->getType());\n        $data[$status_field_name] = null;\n        if (array_key_exists($status_field_name, $item->input) && $item->input[$status_field_name] !== '') {\n            $data[$status_field_name] = (int)$item->input[$status_field_name];\n        } elseif (array_key_exists($status_field_name, $item->fields) && $item->fields[$status_field_name] !== '') {\n            $data[$status_field_name] = (int)$item->fields[$status_field_name];\n        }\n\n        $has_fields = false;\n        foreach ($fields as $field) {\n            if ($field['type'] == 'glpi_item') {\n                $itemtype_key = sprintf('itemtype_%s', $field['name']);\n                $items_id_key = sprintf('items_id_%s', $field['name']);\n\n                if (!isset($item->input[$itemtype_key], $item->input[$items_id_key])) {\n                    continue; // not a valid input\n                }\n\n                $has_fields = true;\n                $data[$itemtype_key] = $item->input[$itemtype_key];\n                $data[$items_id_key] = $item->input[$items_id_key];\n\n                continue; // bypass unique field handling\n            }\n\n            if (isset($item->input[$field['name']])) {\n               //standard field\n                $input = $field['name'];\n            } else {\n               //dropdown field\n                $input = \"plugin_fields_\" . $field['name'] . \"dropdowns_id\";\n            }\n            if (isset($item->input[$input])) {\n                $has_fields = true;\n               // Before is_number check, help user to have a number correct, during a massive action of a number field\n                if ($field['type'] == 'number') {\n                    $item->input[$input] = str_replace(\",\", \".\", $item->input[$input]);\n                }\n                $data[$input] = $item->input[$input];\n            }\n        }\n\n        if ($has_fields === true) {\n            return $data;\n        } else {\n            return false;\n        }\n    }\n\n    public static function getAddSearchOptions($itemtype, $containers_id = false)\n    {\n        global $DB;\n\n        $opt = [];\n\n        // itemtype is stored in a JSON array, so entry is surrounded by double quotes\n        $search_string = json_encode($itemtype);\n        // Backslashes must be doubled in LIKE clause, according to MySQL documentation:\n        // > To search for \\, specify it as \\\\\\\\; this is because the backslashes are stripped\n        // > once by the parser and again when the pattern match is made,\n        // > leaving a single backslash to be matched against.\n        $search_string = str_replace('\\\\', '\\\\\\\\', $search_string);\n\n        $request = [\n            'SELECT' => [\n                'glpi_plugin_fields_fields.id AS field_id',\n                'glpi_plugin_fields_fields.name AS field_name',\n                'glpi_plugin_fields_fields.label AS field_label',\n                'glpi_plugin_fields_fields.type',\n                'glpi_plugin_fields_fields.is_readonly',\n                'glpi_plugin_fields_fields.allowed_values',\n                'glpi_plugin_fields_fields.multiple',\n                'glpi_plugin_fields_containers.id AS container_id',\n                'glpi_plugin_fields_containers.name AS container_name',\n                'glpi_plugin_fields_containers.label AS container_label',\n                (\n                    Session::isCron()\n                        ? new QueryExpression(sprintf('%s AS %s', READ + CREATE, $DB->quoteName('right')))\n                        : 'glpi_plugin_fields_profiles.right'\n                )\n            ],\n            'DISTINCT' => true,\n            'FROM' => 'glpi_plugin_fields_fields',\n            'INNER JOIN' => [\n                'glpi_plugin_fields_containers' => [\n                    'FKEY' => [\n                        'glpi_plugin_fields_containers' => 'id',\n                        'glpi_plugin_fields_fields'     => 'plugin_fields_containers_id',\n                    ]\n                ],\n                'glpi_plugin_fields_profiles' => [\n                    'FKEY' => [\n                        'glpi_plugin_fields_containers' => 'id',\n                        'glpi_plugin_fields_profiles'   => 'plugin_fields_containers_id',\n                    ]\n                ],\n            ],\n            'WHERE' => [\n                'glpi_plugin_fields_containers.is_active'   => 1,\n                'glpi_plugin_fields_containers.itemtypes'   => ['LIKE', '%' . $DB->escape($search_string) . '%'],\n                'glpi_plugin_fields_profiles.right'         => ['>', 0],\n                'glpi_plugin_fields_fields.is_active'       => 1,\n                ['NOT' => ['glpi_plugin_fields_fields.type' => 'header']],\n            ],\n            'ORDERBY'      => [\n                'glpi_plugin_fields_fields.id',\n            ],\n        ];\n        if ($containers_id !== false) {\n            $request['WHERE'][] = ['glpi_plugin_fields_containers.id' => $containers_id];\n        }\n        if (!Session::isCron()) {\n            $request['WHERE'][] = ['glpi_plugin_fields_profiles.profiles_id' => (int)$_SESSION['glpiactiveprofile']['id']];\n        }\n\n        $iterator = $DB->request($request);\n        foreach ($iterator as $data) {\n            $i = PluginFieldsField::SEARCH_OPTION_STARTING_INDEX + $data['field_id'];\n\n            $tablename = getTableForItemType(self::getClassname($itemtype, $data['container_name']));\n\n            //get translations\n            $container = [\n                'itemtype' => PluginFieldsContainer::getType(),\n                'id'       => $data['container_id'],\n                'label'    => $data['container_label']\n            ];\n            $data['container_label'] = PluginFieldsLabelTranslation::getLabelFor($container);\n\n            $field = [\n                'itemtype' => PluginFieldsField::getType(),\n                'id'       => $data['field_id'],\n                'label'    => $data['field_label']\n            ];\n            $data['field_label'] = PluginFieldsLabelTranslation::getLabelFor($field);\n\n            // Default SO params\n            $opt[$i]['table']         = $tablename;\n            $opt[$i]['field']         = $data['field_name'];\n            $opt[$i]['name']          = $data['container_label'] . \" - \" . $data['field_label'];\n            $opt[$i]['linkfield']     = $data['field_name'];\n            $opt[$i]['joinparams']['jointype'] = \"itemtype_item\";\n\n            $opt[$i]['pfields_type']      = $data['type'];\n            $opt[$i]['pfields_fields_id'] = $data['field_id'];\n\n            if ($data['is_readonly']) {\n                $opt[$i]['massiveaction'] = false;\n            }\n            switch ($data['type']) {\n                case 'yesno':\n                    $opt[$i]['datatype'] = \"bool\";\n                    break;\n                case 'textarea':\n                case 'number':\n                    $opt[$i]['datatype'] = \"text\";\n                    break;\n                case 'date':\n                case 'datetime':\n                    $opt[$i]['datatype'] = $data['type'];\n                    break;\n                case 'url':\n                    $opt[$i]['datatype'] = 'weblink';\n                    break;\n                default:\n                    $opt[$i]['datatype'] = \"string\";\n            }\n\n            $dropdown_matches     = [];\n            if ($data['type'] === \"dropdown\") {\n                $field_name = \"plugin_fields_\" . $data['field_name'] . \"dropdowns_id\";\n\n                if ($data['multiple']) {\n                    $opt[$i]['table']      = $tablename;\n                    $opt[$i]['field']      = $field_name;\n                    $opt[$i]['datatype']   = 'specific';\n                } else {\n                    $opt[$i]['table']      = 'glpi_plugin_fields_' . $data['field_name'] . 'dropdowns';\n                    $opt[$i]['field']      = 'completename';\n                    $opt[$i]['linkfield']  = $field_name;\n                    $opt[$i]['datatype']   = \"dropdown\";\n\n                    $opt[$i]['forcegroupby'] = true;\n\n                    $opt[$i]['joinparams']['jointype'] = \"\";\n                    $opt[$i]['joinparams']['beforejoin']['table'] = $tablename;\n                    $opt[$i]['joinparams']['beforejoin']['joinparams']['jointype'] = \"itemtype_item\";\n                }\n            } elseif (\n                preg_match('/^dropdown-(?<class>.+)$/i', $data['type'], $dropdown_matches)\n                && class_exists($dropdown_matches['class'])\n            ) {\n                if ($data['multiple']) {\n                    $opt[$i]['datatype']   = 'specific';\n                } else {\n                    $opt[$i]['table']      = CommonDBTM::getTable($dropdown_matches['class']);\n                    $opt[$i]['field']      = 'name';\n                    $opt[$i]['right']      = 'all';\n                    $opt[$i]['datatype']   = \"dropdown\";\n\n                    $opt[$i]['forcegroupby'] = true;\n\n                    $opt[$i]['joinparams']['jointype'] = \"\";\n                    $opt[$i]['joinparams']['beforejoin']['table'] = $tablename;\n                    $opt[$i]['joinparams']['beforejoin']['joinparams']['jointype'] = \"itemtype_item\";\n                }\n            } elseif ($data['type'] === \"glpi_item\") {\n                $itemtype_field = sprintf('itemtype_%s', $data['field_name']);\n                $items_id_field = sprintf('items_id_%s', $data['field_name']);\n\n                $opt[$i]['table']              = $tablename;\n                $opt[$i]['field']              = $itemtype_field;\n                $opt[$i]['linkfield']          = $itemtype_field;\n                $opt[$i]['name']               = $data['container_label'] . \" - \" . $data['field_label'] . ' - ' . _n('Associated item type', 'Associated item types', Session::getPluralNumber());\n                $opt[$i]['datatype']           = 'itemtypename';\n                $opt[$i]['types']              = !empty($data['allowed_values']) ? json_decode($data['allowed_values']) : [];\n                $opt[$i]['additionalfields']   = ['itemtype'];\n                $opt[$i]['joinparams']['jointype'] = 'itemtype_item';\n                $opt[$i]['forcegroupby']       = true;\n                $opt[$i]['massiveaction']      = false;\n                $i++;\n\n                $opt[$i]['table']              = $tablename;\n                $opt[$i]['field']              = $items_id_field;\n                $opt[$i]['linkfield']          = $items_id_field;\n                $opt[$i]['name']               = $data['container_label'] . \" - \" . $data['field_label'] . ' - ' . __('Associated item ID');\n                $opt[$i]['massiveaction']      = false;\n                $opt[$i]['joinparams']['jointype'] = 'itemtype_item';\n                $opt[$i]['datatype']           = 'text';\n                $opt[$i]['additionalfields']   = ['itemtype'];\n            }\n        }\n\n        return $opt;\n    }\n\n    /**\n     * Get subtypes for specified itemtype.\n     * Was previously retrieved using $item::defineTabs() but\n     * this is not relevant with actual core.\n     *\n     * @param CommonDBTM $item Item instance\n     *\n     * @return array\n     */\n    private static function getSubtypes($item)\n    {\n        $tabs = [];\n        switch ($item::getType()) {\n            case Ticket::getType():\n            case Problem::getType():\n                $tabs = [\n                    $item::getType() . '$2' => __('Solution')\n                ];\n                break;\n            case Change::getType():\n                $tabs = [\n                    'Change$1' => __('Analysis'),\n                    'Change$2' => __('Solution'),\n                    'Change$3' => __('Plans')\n                ];\n                break;\n            case Entity::getType():\n                $tabs = [\n                    'Entity$2' => __('Address'),\n                    'Entity$3' => __('Advanced information'),\n                    'Entity$4' => __('Notifications'),\n                    'Entity$5' => __('Assistance'),\n                    'Entity$6' => __('Assets')\n                ];\n                break;\n            default:\n                //Toolbox::logDebug('Item type ' . $item::getType() . ' does not have any preconfigured subtypes!');\n                /* For debug purposes\n                $tabs = $item->defineTabs();\n                list($id, ) = each($tabs);\n                // delete first element of array ($main)\n                unset($tabs[$id]);*/\n                break;\n        }\n\n        return $tabs;\n    }\n\n    /**\n     * Retrieve the class name corresponding to an itemtype for given container.\n     *\n     * @param string $itemtype       Name of associated itemtype\n     * @param string $container_name Name of container\n     * @param string $suffix         Suffix to add\n     *\n     * @return string\n     */\n    public static function getClassname(string $itemtype, string $container_name, string $suffix = ''): string\n    {\n        return sprintf(\n            'PluginFields%s%s',\n            ucfirst(self::getSystemName($itemtype, $container_name)),\n            $suffix\n        );\n    }\n\n    /**\n     * Retrieve the system name corresponding to an itemtype for given container.\n     *\n     * @param string $itemtype       Name of associated itemtype\n     * @param string $container_name Name of container\n     *\n     * @return string\n     */\n    protected static function getSystemName(string $itemtype, string $container_name): string\n    {\n        return strtolower(str_replace('\\\\', '', $itemtype) . preg_replace('/s$/', '', $container_name));\n    }\n\n\n    public static function getIcon()\n    {\n        return \"fas fa-tasks\";\n    }\n\n    public static function getNameField()\n    {\n        return 'label';\n    }\n\n    public function prepareInputForClone($input)\n    {\n        if (array_key_exists('itemtypes', $input) && !empty($input['itemtypes'])) {\n            // $input has been transformed with `Toolbox::addslashes_deep()`, and `self::prepareInputForAdd()`\n            // is expecting an array, so it have to be unslashed then json decoded.\n            $input['itemtypes'] = json_decode(Sanitizer::dbUnescape($input['itemtypes']));\n        } else {\n            unset($input['itemtypes']);\n        }\n\n        return $input;\n    }\n\n    public function getCloneRelations(): array\n    {\n        return [\n            PluginFieldsContainerDisplayCondition::class,\n            PluginFieldsField::class,\n            PluginFieldsLabelTranslation::class,\n            PluginFieldsProfile::class,\n        ];\n    }\n}\n", "<?php\n\n/**\n * -------------------------------------------------------------------------\n * Fields plugin for GLPI\n * -------------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of Fields.\n *\n * Fields is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Fields is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Fields. If not, see <http://www.gnu.org/licenses/>.\n * -------------------------------------------------------------------------\n * @copyright Copyright (C) 2013-2022 by Fields plugin team.\n * @license   GPLv2 https://www.gnu.org/licenses/gpl-2.0.html\n * @link      https://github.com/pluginsGLPI/fields\n * -------------------------------------------------------------------------\n */\n\nuse Glpi\\Application\\View\\TemplateRenderer;\nuse Glpi\\Toolbox\\Sanitizer;\n\nclass PluginFieldsField extends CommonDBChild\n{\n    use Glpi\\Features\\Clonable;\n\n    /**\n     * Starting index for search options.\n     * @var integer\n     */\n    public const SEARCH_OPTION_STARTING_INDEX = 76665;\n\n    public static $itemtype = PluginFieldsContainer::class;\n    public static $items_id = 'plugin_fields_containers_id';\n\n    /**\n     * Install or update plugin base data.\n     *\n     * @param Migration $migration Migration instance\n     * @param string    $version   Plugin current version\n     *\n     * @return boolean\n     */\n    public static function installBaseData(Migration $migration, $version)\n    {\n        global $DB;\n\n        $default_charset = DBConnection::getDefaultCharset();\n        $default_collation = DBConnection::getDefaultCollation();\n        $default_key_sign = DBConnection::getDefaultPrimaryKeySignOption();\n\n        $table = self::getTable();\n\n        if (!$DB->tableExists($table)) {\n            $migration->displayMessage(sprintf(__(\"Installing %s\"), $table));\n\n            $query = \"CREATE TABLE IF NOT EXISTS `$table` (\n                  `id`                                INT            {$default_key_sign} NOT NULL auto_increment,\n                  `name`                              VARCHAR(255)   DEFAULT NULL,\n                  `label`                             VARCHAR(255)   DEFAULT NULL,\n                  `type`                              VARCHAR(255)   DEFAULT NULL,\n                  `plugin_fields_containers_id`       INT            {$default_key_sign} NOT NULL DEFAULT '0',\n                  `ranking`                           INT            NOT NULL DEFAULT '0',\n                  `default_value`                     LONGTEXT       ,\n                  `is_active`                         TINYINT        NOT NULL DEFAULT '1',\n                  `is_readonly`                       TINYINT        NOT NULL DEFAULT '1',\n                  `mandatory`                         TINYINT        NOT NULL DEFAULT '0',\n                  `multiple`                          TINYINT        NOT NULL DEFAULT '0',\n                  `allowed_values`                    TEXT           ,\n                  PRIMARY KEY                         (`id`),\n                  KEY `plugin_fields_containers_id`   (`plugin_fields_containers_id`),\n                  KEY `is_active`                     (`is_active`),\n                  KEY `is_readonly`                   (`is_readonly`)\n               ) ENGINE=InnoDB DEFAULT CHARSET={$default_charset} COLLATE={$default_collation} ROW_FORMAT=DYNAMIC;\";\n            $DB->query($query) or die($DB->error());\n        }\n\n        $migration->displayMessage(\"Updating $table\");\n\n        if (!$DB->fieldExists($table, 'is_active')) {\n            $migration->addField($table, 'is_active', 'bool', ['value' => 1]);\n            $migration->addKey($table, 'is_active', 'is_active');\n        }\n        if (!$DB->fieldExists($table, 'is_readonly')) {\n            $migration->addField($table, 'is_readonly', 'bool', ['default' => false]);\n            $migration->addKey($table, 'is_readonly', 'is_readonly');\n        }\n        if (!$DB->fieldExists($table, 'mandatory')) {\n            $migration->addField($table, 'mandatory', 'bool', ['value' => 0]);\n        }\n        if (!$DB->fieldExists($table, 'multiple')) {\n            $migration->addField($table, 'multiple', 'bool', ['value' => 0]);\n        }\n\n        //increase the size of column 'type' (25 to 255)\n        $migration->changeField($table, 'type', 'type', 'string');\n\n        if (!$DB->fieldExists($table, 'allowed_values')) {\n            $migration->addField($table, 'allowed_values', 'text');\n        }\n\n        // change default_value from varchar to longtext\n        $migration->changeField($table, 'default_value', 'default_value', 'longtext');\n\n        $toolbox = new PluginFieldsToolbox();\n        $toolbox->fixFieldsNames($migration, ['NOT' => ['type' => 'dropdown']]);\n\n        //move old types to new format\n        $migration->addPostQuery(\n            $DB->buildUpdate(\n                PluginFieldsField::getTable(),\n                ['type' => 'dropdown-User'],\n                ['type' => 'dropdownuser']\n            )\n        );\n\n        $migration->addPostQuery(\n            $DB->buildUpdate(\n                PluginFieldsField::getTable(),\n                ['type' => 'dropdown-OperatingSystem'],\n                ['type' => 'dropdownoperatingsystems']\n            )\n        );\n\n        // 1.18.3 Make search options ID stable over time ad constant across profiles\n        if (Config::getConfigurationValue('plugin:fields', 'stable_search_options') !== 'yes') {\n            self::migrateToStableSO($migration);\n            $migration->addConfig(['stable_search_options' => 'yes'], 'plugin:fields');\n        }\n\n        return true;\n    }\n\n    /**\n     * Migrate search options ID stored in DB to their new stable ID.\n     *\n     * Prior to 1.18.3, search options ID were built using a simple increment and filtered using current profile rights,\n     * resulting in following behaviours:\n     * - when a container was activated/deactivated/removed, SO ID were potentially changed;\n     * - when a field was removed, SO ID were potentially changed;\n     * - in a sessionless context (e.g. CLI command/crontask), no SO were available;\n     * - when user added a SO in its display preference from a A profile, this SO was sometimes targetting a completely different field on a B profile.\n     * All of these behaviours were resulting in unstable display preferences and saved searches.\n     *\n     * Producing an exact mapping between previous unstable SO ID and new stable SO ID is almost impossible in many cases, due to\n     * previously described behaviours. Basically, we cannot know if the current SO ID in database is still correct\n     * and what were the profile rights when it was generated.\n     *\n     * @param Migration $migration\n     */\n    private static function migrateToStableSO(Migration $migration): void\n    {\n        global $DB;\n\n        // Flatten itemtype list\n        $itemtypes = array_keys(array_merge([], ...array_values(PluginFieldsToolbox::getGlpiItemtypes())));\n\n        foreach ($itemtypes as $itemtype) {\n            // itemtype is stored in a JSON array, so entry is surrounded by double quotes\n            $search_string = json_encode($itemtype);\n            // Backslashes must be doubled in LIKE clause, according to MySQL documentation:\n            // > To search for \\, specify it as \\\\\\\\; this is because the backslashes are stripped\n            // > once by the parser and again when the pattern match is made,\n            // > leaving a single backslash to be matched against.\n            $search_string = str_replace('\\\\', '\\\\\\\\', $search_string);\n\n            $fields = $DB->request(\n                [\n                    'SELECT'     => [\n                        'glpi_plugin_fields_fields.id',\n                    ],\n                    'FROM'       => 'glpi_plugin_fields_fields',\n                    'INNER JOIN' => [\n                        'glpi_plugin_fields_containers' => [\n                            'FKEY' => [\n                                'glpi_plugin_fields_containers' => 'id',\n                                'glpi_plugin_fields_fields'     => 'plugin_fields_containers_id',\n                                [\n                                    'AND' => [\n                                        'glpi_plugin_fields_containers.is_active' => 1,\n                                    ]\n                                ]\n                            ]\n                        ],\n                    ],\n                    'WHERE' => [\n                        'glpi_plugin_fields_containers.itemtypes' => ['LIKE', '%' . $DB->escape($search_string) . '%'],\n                        ['NOT' => ['glpi_plugin_fields_fields.type' => 'header']],\n                    ],\n                    'ORDERBY'      => [\n                        'glpi_plugin_fields_fields.id',\n                    ],\n                ]\n            );\n\n            $i = PluginFieldsField::SEARCH_OPTION_STARTING_INDEX;\n\n            foreach ($fields as $field_data) {\n                $migration->changeSearchOption(\n                    $itemtype,\n                    $i,\n                    PluginFieldsField::SEARCH_OPTION_STARTING_INDEX + $field_data['id']\n                );\n\n                $i++;\n            }\n        }\n    }\n\n    public static function uninstall()\n    {\n        global $DB;\n\n        $DB->query(\"DROP TABLE IF EXISTS `\" . self::getTable() . \"`\");\n\n        return true;\n    }\n\n    public static function getTypeName($nb = 0)\n    {\n        return __(\"Field\", \"fields\");\n    }\n\n\n    public function prepareInputForAdd($input)\n    {\n        //parse name\n        $input['name'] = $this->prepareName($input);\n\n        if ($input['multiple'] ?? false) {\n            $input['default_value'] = json_encode($input['default_value'] ?? []);\n        }\n\n        //reject adding when field name is too long for mysql\n        if (strlen($input['name']) > 64) {\n            Session::AddMessageAfterRedirect(\n                __(\"Field name is too long for database (digits in name are replaced by characters, try to remove them)\", 'fields'),\n                false,\n                ERROR\n            );\n            return false;\n        }\n\n        if ($input['type'] === \"dropdown\") {\n            //search if dropdown already exist in this container\n            $found = $this->find(\n                [\n                    'name' => $input['name'],\n                    'plugin_fields_containers_id' => $input['plugin_fields_containers_id'],\n                ]\n            );\n\n            //reject adding for same dropdown on same bloc\n            if (!empty($found)) {\n                Session::AddMessageAfterRedirect(__(\"You cannot add same field 'dropdown' on same bloc\", 'fields', false, ERROR));\n                return false;\n            }\n\n            //reject adding when dropdown name is too long for mysql table name\n            if (strlen(getTableForItemType(PluginFieldsDropdown::getClassname($input['name']))) > 64) {\n                Session::AddMessageAfterRedirect(\n                    __(\"Field name is too long for database (digits in name are replaced by characters, try to remove them)\", 'fields'),\n                    false,\n                    ERROR\n                );\n                return false;\n            }\n        }\n\n        // Before adding, add the ranking of the new field\n        if (empty($input[\"ranking\"])) {\n            $input[\"ranking\"] = $this->getNextRanking();\n        }\n\n        //add field to container table\n        if ($input['type'] !== \"header\") {\n            $container_obj = new PluginFieldsContainer();\n            $container_obj->getFromDB($input['plugin_fields_containers_id']);\n            foreach (json_decode($container_obj->fields['itemtypes']) as $itemtype) {\n                $classname = PluginFieldsContainer::getClassname($itemtype, $container_obj->fields['name']);\n                $classname::addField(\n                    $input['name'],\n                    $input['type'],\n                    [\n                        'multiple' => (bool)($input['multiple'] ?? false)\n                    ]\n                );\n            }\n        }\n\n        if (isset($input['allowed_values'])) {\n            $input['allowed_values'] = Sanitizer::dbEscape(json_encode($input['allowed_values']));\n        }\n\n        return $input;\n    }\n\n\n    public function prepareInputForUpdate($input)\n    {\n        if (\n            array_key_exists('default_value', $input)\n            && $this->fields['multiple']\n        ) {\n            $input['default_value'] = json_encode($input['default_value'] ?: []);\n        }\n\n        return $input;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function pre_deleteItem()\n    {\n        //remove field in container table\n        if (\n            $this->fields['type'] !== \"header\"\n            && !isset($_SESSION['uninstall_fields'])\n            && !isset($_SESSION['delete_container'])\n        ) {\n            $container_obj = new PluginFieldsContainer();\n            $container_obj->getFromDB($this->fields['plugin_fields_containers_id']);\n            foreach (json_decode($container_obj->fields['itemtypes']) as $itemtype) {\n                $classname = PluginFieldsContainer::getClassname($itemtype, $container_obj->fields['name']);\n                $classname::removeField($this->fields['name'], $this->fields['type']);\n            }\n        }\n\n        //delete label translations\n        $translation_obj = new PluginFieldsLabelTranslation();\n        $translation_obj->deleteByCriteria([\n            'itemtype' => self::getType(),\n            'items_id' => $this->fields['id']\n        ]);\n\n        if ($this->fields['type'] === \"dropdown\") {\n            return PluginFieldsDropdown::destroy($this->fields['name']);\n        }\n        return true;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function post_purgeItem()\n    {\n        global $DB;\n\n        $table         = getTableForItemType(__CLASS__);\n        $old_container = $this->fields['plugin_fields_containers_id'];\n        $old_ranking   = $this->fields['ranking'];\n\n        $query = \"UPDATE $table SET\n                ranking = ranking-1\n                WHERE plugin_fields_containers_id = $old_container\n                AND ranking > $old_ranking\";\n        $DB->query($query);\n\n        return true;\n    }\n\n\n    /**\n     * parse name for avoid non alphanumeric char in it and conflict with other fields\n     * @param  array $input the field form input\n     * @return string  the parsed name\n     */\n    public function prepareName($input, bool $prevent_duplicated = true)\n    {\n        $toolbox = new PluginFieldsToolbox();\n\n        //contruct field name by processing label (remove non alphanumeric char)\n        if (empty($input['name'])) {\n            $input['name'] = $toolbox->getSystemNameFromLabel($input['label']) . 'field';\n        }\n\n        //for dropdown, if already exists, link to it\n        if (isset($input['type']) && $input['type'] === \"dropdown\") {\n            $found = $this->find(['name' => $input['name']]);\n            if (!empty($found)) {\n                return $input['name'];\n            }\n        }\n\n        // for dropdowns like dropdown-User, dropdown-Computer, etc...\n        $match = [];\n        if (isset($input['type']) && preg_match('/^dropdown-(?<type>.+)$/', $input['type'], $match) === 1) {\n            $input['name'] = getForeignKeyFieldForItemType($match['type']) . '_' . $input['name'];\n        }\n\n        //check if field name not already exist and not in conflict with itemtype fields name\n        $container = new PluginFieldsContainer();\n        $container->getFromDB($input['plugin_fields_containers_id']);\n\n        $field      = new self();\n        $field_name = $input['name'];\n\n        if ($prevent_duplicated) {\n            $i = 2;\n            while (count($field->find(['name' => $field_name])) > 0) {\n                $field_name = $toolbox->getIncrementedSystemName($input['name'], $i);\n                $i++;\n            }\n        }\n\n        // if it's too long then use a random postfix\n        // MySQL/MariaDB official limit for a column name is 64 chars,\n        // but there is a bug when trying to drop the column and the real max len is 53 chars\n        // FIXME: see: https://bugs.mysql.com/bug.php?id=107165\n        if (strlen($field_name) > 52) {\n            $rand = rand();\n            $field_name = substr($field_name, 0, 52 - strlen($rand)) . $rand;\n        }\n\n        return $field_name;\n    }\n\n    /**\n     * Get the next ranking for a specified field\n     *\n     * @return integer\n     */\n    public function getNextRanking()\n    {\n        global $DB;\n\n        $sql = \"SELECT max(`ranking`) AS `rank`\n              FROM `\" . self::getTable() . \"`\n              WHERE `plugin_fields_containers_id` = '\" .\n                  $this->fields['plugin_fields_containers_id'] . \"'\";\n        $result = $DB->query($sql);\n\n        if ($DB->numrows($result) > 0) {\n            $data = $DB->fetchAssoc($result);\n            return $data[\"rank\"] + 1;\n        }\n        return 0;\n    }\n\n    public function getTabNameForItem(CommonGLPI $item, $withtemplate = 0)\n    {\n        if (!$withtemplate) {\n            switch ($item->getType()) {\n                case __CLASS__:\n                    $ong[1] = $this->getTypeName(1);\n                    return $ong;\n            }\n        }\n\n        return self::createTabEntry(\n            __(\"Fields\", \"fields\"),\n            countElementsInTable(\n                self::getTable(),\n                ['plugin_fields_containers_id' => $item->getID()]\n            )\n        );\n    }\n\n    public static function displayTabContentForItem(CommonGLPI $item, $tabnum = 1, $withtemplate = 0)\n    {\n        $fup = new self();\n        $fup->showSummary($item);\n        return true;\n    }\n\n    public function defineTabs($options = [])\n    {\n        $ong = [];\n        $this->addDefaultFormTab($ong);\n        $this->addStandardTab('PluginFieldsLabelTranslation', $ong, $options);\n\n        return $ong;\n    }\n\n    public function showSummary($container)\n    {\n        global $DB, $CFG_GLPI;\n\n        $cID = $container->fields['id'];\n\n        // Display existing Fields\n        $query  = \"SELECT `id`, `label`\n                FROM `\" . $this->getTable() . \"`\n                WHERE `plugin_fields_containers_id` = '$cID'\n                ORDER BY `ranking` ASC\";\n        $result = $DB->query($query);\n\n        $rand   = mt_rand();\n\n        echo \"<div id='viewField$cID$rand'></div>\";\n\n        $ajax_params = [\n            'type'                        => __CLASS__,\n            'parenttype'                  => PluginFieldsContainer::class,\n            'plugin_fields_containers_id' => $cID,\n            'id'                          => -1\n        ];\n        echo Html::scriptBlock('\n            viewAddField' . $cID . $rand . ' = function() {\n                $(\"#viewField' . $cID . $rand . '\").load(\n                    \"' . $CFG_GLPI['root_doc'] . '/ajax/viewsubitem.php\",\n                    ' . json_encode($ajax_params) . '\n                );\n            };\n        ');\n\n        echo \"<div class='center'>\" .\n           \"<a href='javascript:viewAddField$cID$rand();'>\";\n        echo __(\"Add a new field\", \"fields\") . \"</a></div><br>\";\n\n        if ($DB->numrows($result) == 0) {\n            echo \"<table class='tab_cadre_fixe'><tr class='tab_bg_2'>\";\n            echo \"<th class='b'>\" . __(\"No field for this block\", \"fields\") . \"</th></tr></table>\";\n        } else {\n            echo '<div id=\"drag\">';\n            echo Html::hidden(\"_plugin_fields_containers_id\", ['value' => $cID,\n                'id'    => 'plugin_fields_containers_id'\n            ]);\n            echo \"<table class='tab_cadre_fixehov'>\";\n            echo \"<tr>\";\n            echo \"<th>\" . __(\"Label\")              . \"</th>\";\n            echo \"<th>\" . __(\"Type\")               . \"</th>\";\n            echo \"<th>\" . __(\"Default values\")     . \"</th>\";\n            echo \"<th>\" . __(\"Mandatory field\")    . \"</th>\";\n            echo \"<th>\" . __(\"Active\")             . \"</th>\";\n            echo \"<th>\" . __(\"Read only\", \"fields\") . \"</th>\";\n            echo \"<th width='16'>&nbsp;</th>\";\n            echo \"</tr>\";\n\n            $fields_type = self::getTypes();\n\n            Session::initNavigateListItems('PluginFieldsField', __('Fields list'));\n\n            while ($data = $DB->fetchArray($result)) {\n                if ($this->getFromDB($data['id'])) {\n                    echo \"<tr class='tab_bg_2' style='cursor:pointer'>\";\n\n                    echo \"<td>\";\n                    echo \"<a href='\" . Plugin::getWebDir('fields') . \"/front/field.form.php?id={$this->getID()}'>{$this->fields['label']}</a>\";\n                    echo \"</td>\";\n                    echo \"<td>\" . $fields_type[$this->fields['type']] . \"</td>\";\n                    echo \"<td>\" ;\n                    $dropdown_matches = [];\n                    if (\n                        preg_match('/^dropdown-(?<class>.+)$/', $this->fields['type'], $dropdown_matches) === 1\n                        && !empty($this->fields['default_value'])\n                    ) {\n                        $itemtype = $dropdown_matches['class'];\n                        // Itemtype may not exists (for instance for a deactivated plugin)\n                        if (is_a($itemtype, CommonDBTM::class, true)) {\n                            $item = new $itemtype();\n                            if ($this->fields['multiple']) {\n                                $values = json_decode($this->fields['default_value']);\n\n                                $names = [];\n                                foreach ($values as $value) {\n                                    if ($item->getFromDB($value)) {\n                                        $names[] = $item->getName();\n                                    }\n                                }\n\n                                echo implode(', ', $names);\n                            } else {\n                                if ($item->getFromDB($this->fields['default_value'])) {\n                                    echo $item->getName();\n                                }\n                            }\n                        }\n                    } elseif ($this->fields['type'] === 'dropdown' && !empty($this->fields['default_value'])) {\n                        $table = getTableForItemType(PluginFieldsDropdown::getClassname($this->fields['name']));\n                        if ($this->fields['multiple']) {\n                            echo implode(\n                                ', ',\n                                Dropdown::getDropdownArrayNames($table, json_decode($this->fields['default_value']))\n                            );\n                        } else {\n                            echo Dropdown::getDropdownName($table, $this->fields['default_value']);\n                        }\n                    } else {\n                        echo $this->fields['default_value'];\n                    }\n                    echo \"</td>\";\n                    echo \"<td align='center'>\" . Dropdown::getYesNo($this->fields[\"mandatory\"]) . \"</td>\";\n                    echo \"<td align='center'>\";\n                    echo ($this->isActive())\n                     ? __('Yes')\n                     : '<b class=\"red\">' . __('No') . '</b>';\n                    echo \"</td>\";\n\n                    echo \"<td>\";\n                    echo Dropdown::getYesNo($this->fields[\"is_readonly\"]);\n                    echo \"</td>\";\n\n                    echo '<td class=\"rowhandler control center\">';\n                    echo '<div class=\"drag row\" style=\"cursor:move; border: 0;\">';\n                    echo '<i class=\"ti ti-grip-horizontal\" title=\"' . __('Move') . '\">';\n                    echo '</div>';\n                    echo '</td>';\n                    echo \"</tr>\";\n                }\n            }\n        }\n        echo '</table>';\n        echo '</div>';\n        echo Html::scriptBlock('$(document).ready(function() {\n            redipsInit()\n        });');\n    }\n\n\n    public function showForm($ID, $options = [])\n    {\n        $rand = mt_rand();\n\n        if (isset($options['parent_id']) && !empty($options['parent_id'])) {\n            $container = new PluginFieldsContainer();\n            $container->getFromDB($options['parent_id']);\n        } else if (\n            isset($options['parent'])\n                 && $options['parent'] instanceof CommonDBTM\n        ) {\n            $container = $options['parent'];\n        }\n\n        if ($ID > 0) {\n            $attrs = ['readonly' => 'readonly'];\n            $edit = true;\n        } else {\n            $attrs = [];\n            // Create item\n            $edit = false;\n            $options['plugin_fields_containers_id'] = $container->getField('id');\n        }\n\n        $this->initForm($ID, $options);\n        $this->showFormHeader($ID, $options);\n\n        echo \"<tr>\";\n        echo \"<td>\" . __(\"Label\") . \" : </td>\";\n        echo \"<td colspan='3'>\";\n        echo Html::hidden('plugin_fields_containers_id', ['value' => $container->getField('id')]);\n        echo Html::input(\n            'label',\n            [\n                'value' => $this->fields['label'],\n            ] + $attrs\n        );\n        echo \"</td>\";\n\n        echo \"</tr>\";\n        echo \"<tr>\";\n        echo \"<td>\" . __(\"Type\") . \" : </td>\";\n        echo \"<td colspan='3'>\";\n        if ($edit) {\n            echo self::getTypes(true)[$this->fields['type']];\n        } else {\n            Dropdown::showFromArray(\n                'type',\n                self::getTypes(false),\n                [\n                    'value' => $this->fields['type'],\n                    'rand'  => $rand,\n                ]\n            );\n        }\n\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo '<tr id=\"plugin_fields_specific_fields_' . $rand . '\" style=\"line-height: 46px;\">';\n        echo '<td>';\n        Ajax::updateItemOnSelectEvent(\n            \"dropdown_type$rand\",\n            \"plugin_fields_specific_fields_$rand\",\n            \"../ajax/field_specific_fields.php\",\n            [\n                'id'   => $ID,\n                'type' => '__VALUE__',\n                'rand' => $rand,\n            ]\n        );\n        Ajax::updateItem(\n            \"plugin_fields_specific_fields_$rand\",\n            \"../ajax/field_specific_fields.php\",\n            [\n                'id'   => $ID,\n                'type' => $this->fields['type'] ?? '',\n                'rand' => $rand,\n            ]\n        );\n        echo '</td>';\n        echo '</tr>';\n\n        echo \"<tr>\";\n        echo \"<td>\" . __('Active') . \" :</td>\";\n        echo \"<td>\";\n        Dropdown::showYesNo('is_active', $this->fields[\"is_active\"]);\n        echo \"</td>\";\n        echo \"<td>\" . __(\"Mandatory field\") . \" : </td>\";\n        echo \"<td>\";\n        Dropdown::showYesNo(\"mandatory\", $this->fields[\"mandatory\"]);\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr>\";\n        echo \"<td>\" . __(\"Read only\", \"fields\") . \" :</td>\";\n        echo \"<td colspan='3'>\";\n        Dropdown::showYesNo(\"is_readonly\", $this->fields[\"is_readonly\"]);\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        $this->showFormButtons($options);\n    }\n\n    public static function showForTabContainer($c_id, $item)\n    {\n        //profile restriction (for reading profile)\n        $profile = new PluginFieldsProfile();\n        $found = $profile->find(['profiles_id' => $_SESSION['glpiactiveprofile']['id'],\n            'plugin_fields_containers_id' => $c_id\n        ]);\n        $first_found = array_shift($found);\n        $canedit = ($first_found['right'] == CREATE);\n\n        //get fields for this container\n        $field_obj = new self();\n        $fields = $field_obj->find(['plugin_fields_containers_id' => $c_id, 'is_active' => 1], \"ranking\");\n        echo \"<form method='POST' action='\" . Plugin::getWebDir('fields') . \"/front/container.form.php'>\";\n        echo Html::hidden('plugin_fields_containers_id', ['value' => $c_id]);\n        echo Html::hidden('items_id', ['value' => $item->getID()]);\n        echo Html::hidden('itemtype', ['value' => $item->getType()]);\n        echo \"<table class='tab_cadre_fixe'>\";\n        echo self::prepareHtmlFields($fields, $item, $canedit);\n\n        if ($canedit) {\n            echo \"<tr><td class='tab_bg_2 center' colspan='4'>\";\n            echo \"<input class='btn btn-primary' type='submit' name='update_fields_values' value=\\\"\" .\n            _sx(\"button\", \"Save\") . \"\\\" class='submit'>\";\n            echo \"</td></tr>\";\n        }\n\n        echo \"</table>\";\n        Html::closeForm();\n\n        return true;\n    }\n\n    /**\n     * Display dom container\n     *\n     * @param int         $id       Container's ID\n     * @param CommonDBTM  $item     Item\n     * @param string      $type     Type (either 'dom' or 'domtab'\n     * @param string      $subtype  Requested subtype (used for domtab only)\n     *\n     * @return void\n     */\n    public static function showDomContainer($id, $item, $type = \"dom\", $subtype = \"\")\n    {\n\n        if ($id !== false) {\n            //get fields for this container\n            $field_obj = new self();\n            $fields = $field_obj->find(\n                [\n                    'plugin_fields_containers_id' => $id,\n                    'is_active' => 1,\n                ],\n                \"ranking\"\n            );\n        } else {\n            $fields = [];\n        }\n\n        echo Html::hidden('_plugin_fields_type', ['value' => $type]);\n        echo Html::hidden('_plugin_fields_subtype', ['value' => $subtype]);\n        echo self::prepareHtmlFields($fields, $item);\n    }\n\n    /**\n     * Display fields in any existing tab\n     *\n     * @param array $params [item, options]\n     *\n     * @return void\n     */\n    public static function showForTab($params)\n    {\n        Html::requireJs('tinymce');\n\n        $item = $params['item'];\n\n        $functions = array_column(debug_backtrace(), 'function');\n\n        $subtype = isset($_SESSION['glpi_tabs'][strtolower($item::getType())]) ? $_SESSION['glpi_tabs'][strtolower($item::getType())] : \"\";\n        $type = substr($subtype, -strlen('$main')) === '$main'\n            || in_array('showForm', $functions)\n            || in_array('showPrimaryForm', $functions)\n            || in_array('showFormHelpdesk', $functions)\n                ? 'dom'\n                : 'domtab';\n        if ($subtype == -1) {\n            $type = 'dom';\n        }\n        // if we are in 'dom' or 'tab' type, no need for subtype ('domtab' specific)\n        if ($type != 'domtab') {\n            $subtype = \"\";\n        }\n        //find container (if not exist, do nothing)\n        if (isset($_REQUEST['c_id'])) {\n            $c_id = $_REQUEST['c_id'];\n        } else if (!$c_id = PluginFieldsContainer::findContainer(get_Class($item), $type, $subtype)) {\n            return false;\n        }\n\n        //need to check if container is usable on this object entity\n        $loc_c = new PluginFieldsContainer();\n        $loc_c->getFromDB($c_id);\n        $entities = [$loc_c->fields['entities_id']];\n        if ($loc_c->fields['is_recursive']) {\n            $entities = getSonsOf(getTableForItemType('Entity'), $loc_c->fields['entities_id']);\n        }\n\n        if ($item->isEntityAssign()) {\n            $current_entity = $item->getEntityID();\n            if (!in_array($current_entity, $entities)) {\n                return false;\n            }\n        }\n\n        //parse REQUEST_URI\n        if (!isset($_SERVER['REQUEST_URI'])) {\n            return false;\n        }\n        $current_url = $_SERVER['REQUEST_URI'];\n        if (\n            strpos($current_url, \".form.php\") === false\n            && strpos($current_url, \".injector.php\") === false\n            && strpos($current_url, \".public.php\") === false\n        ) {\n            return false;\n        }\n\n        //Retrieve dom container\n        $itemtypes = PluginFieldsContainer::getUsedItemtypes($type, true);\n\n        //if no dom containers defined for this itemtype, do nothing (in_array case insensitive)\n        if (!in_array(strtolower($item::getType()), array_map('strtolower', $itemtypes))) {\n            return false;\n        }\n\n        $html_id = 'plugin_fields_container_' . mt_rand();\n        echo \"<div id='{$html_id}'>\";\n        $display_condition = new PluginFieldsContainerDisplayCondition();\n        if ($display_condition->computeDisplayContainer($item, $c_id)) {\n            self::showDomContainer(\n                $c_id,\n                $item,\n                $type,\n                $subtype\n            );\n        }\n        echo \"</div>\";\n\n        //JS to trigger any change and check if container need to be display or not\n        $ajax_url   = Plugin::getWebDir('fields') . '/ajax/container.php';\n        $items_id = !$item->isNewItem() ? $item->getID() : 0;\n        echo Html::scriptBlock(<<<JAVASCRIPT\n            function refreshContainer() {\n                const data = $('#{$html_id}').closest('form').serializeArray().reduce(\n                    function(obj, item) {\n                        obj[item.name] = item.value;\n                        return obj;\n                    },\n                    {}\n                );\n\n                $.ajax(\n                    {\n                        url: '{$ajax_url}',\n                        type: 'GET',\n                        data: {\n                            action:   'get_fields_html',\n                            id:       {$c_id},\n                            itemtype: '{$item::getType()}',\n                            items_id: {$items_id},\n                            type:     '{$type}',\n                            subtype:  '{$subtype}',\n                            input:    data\n                        },\n                        success: function(data) {\n                            // Close open select2 dropdown that will be replaced\n                            $('#{$html_id}').find('.select2-hidden-accessible').select2('close');\n                            // Refresh fields HTML\n                            $('#{$html_id}').html(data);\n                        }\n                    }\n                );\n            }\n            $(\n                function () {\n                    const form = $('#{$html_id}').closest('form');\n                    form.on(\n                        'change',\n                        'input, select, textarea',\n                        function(evt) {\n                            if (evt.target.name == \"itilcategories_id\") {\n                                // Do not refresh tab container when form is reloaded\n                                // to prevent issues diues to duplicated calls\n                                return;\n                            }\n                            if ($(evt.target).closest('#{$html_id}').length > 0) {\n                                return; // Do nothing if element is inside fields container\n                            }\n                            refreshContainer();\n                        }\n                    );\n\n                    var refresh_timeout = null;\n                    form.find('textarea').each(\n                        function () {\n                            const editor = tinymce.get(this.id);\n                            if (editor !== null) {\n                                editor.on(\n                                    'change',\n                                    function(evt) {\n                                        if ($(evt.target.targetElm).closest('#{$html_id}').length > 0) {\n                                            return; // Do nothing if element is inside fields container\n                                        }\n\n                                        if (refresh_timeout !== null) {\n                                            window.clearTimeout(refresh_timeout);\n                                        }\n                                        refresh_timeout = window.setTimeout(refreshContainer, 1000);\n                                    }\n                                );\n                            }\n                        }\n                    );\n                }\n            );\nJAVASCRIPT\n        );\n    }\n\n    public static function prepareHtmlFields(\n        $fields,\n        $item,\n        $canedit = true,\n        $show_table = true,\n        $massiveaction = false\n    ) {\n\n        if (empty($fields)) {\n            return false;\n        }\n\n        //get object associated with this fields\n        $tmp = $fields;\n        $first_field = array_shift($tmp);\n        $container_obj = new PluginFieldsContainer();\n        $container_obj->getFromDB($first_field['plugin_fields_containers_id']);\n\n        // Fill status overrides if needed\n        if (in_array($item->getType(), PluginFieldsStatusOverride::getStatusItemtypes())) {\n            $status_overrides = PluginFieldsStatusOverride::getOverridesForItem($container_obj->getID(), $item);\n            foreach ($status_overrides as $status_override) {\n                if (isset($fields[$status_override['plugin_fields_fields_id']])) {\n                    $fields[$status_override['plugin_fields_fields_id']]['is_readonly'] = $status_override['is_readonly'];\n                    $fields[$status_override['plugin_fields_fields_id']]['mandatory'] = $status_override['mandatory'];\n                }\n            }\n        }\n\n        $found_v = null;\n        if (!$item->isNewItem()) {\n            //find row for this object with the items_id\n            $classname = PluginFieldsContainer::getClassname($item->getType(), $container_obj->fields['name']);\n            $obj = new $classname();\n            $found_values = $obj->find(\n                [\n                    'plugin_fields_containers_id' => $first_field['plugin_fields_containers_id'],\n                    'items_id' => $item->getID(),\n                ]\n            );\n            $found_v = array_shift($found_values);\n        }\n\n        // find profiles (to check if current profile can edit fields)\n        $fprofile = new PluginFieldsProfile();\n        $found_p = $fprofile->find(\n            [\n                'profiles_id' => $_SESSION['glpiactiveprofile']['id'],\n                'plugin_fields_containers_id' => $first_field['plugin_fields_containers_id'],\n            ]\n        );\n        $first_found_p = array_shift($found_p);\n\n        // test status for \"CommonITILObject\" objects\n        if ($item instanceof CommonITILObject) {\n            $status = $item->fields['status'] ?? null;\n            if (\n                ($status !== null && in_array($status, $item->getClosedStatusArray()))\n                || $first_found_p['right'] != CREATE\n            ) {\n                $canedit = false;\n            }\n        } else {\n            if ($first_found_p['right'] != CREATE) {\n                $canedit = false;\n            }\n        }\n\n        //show all fields\n        foreach ($fields as &$field) {\n            $field['itemtype'] = self::getType();\n            $field['label'] = PluginFieldsLabelTranslation::getLabelFor($field);\n\n            $field['allowed_values'] = !empty($field['allowed_values']) ? json_decode($field['allowed_values']) : [];\n            if ($field['type'] === 'glpi_item') {\n               // Convert allowed values to [$itemtype_class => $itemtype_name] format\n                $allowed_itemtypes = [];\n                foreach ($field['allowed_values'] as $allowed_itemtype) {\n                    if (is_a($allowed_itemtype, CommonDBTM::class, true)) {\n                        $allowed_itemtypes[$allowed_itemtype] = $allowed_itemtype::getTypeName(Session::getPluralNumber());\n                    }\n                }\n                $field['allowed_values'] = $allowed_itemtypes;\n            }\n\n            //compute classname for 'dropdown-XXXXXX' field\n            $dropdown_matches = [];\n            if (\n                preg_match('/^dropdown-(?<class>.+)$/i', $field['type'], $dropdown_matches)\n                && class_exists($dropdown_matches['class'])\n            ) {\n                $dropdown_class = $dropdown_matches['class'];\n\n                $field['dropdown_class'] = $dropdown_class;\n                $field['dropdown_condition'] = [];\n\n                $object = new $dropdown_class();\n                if ($object->maybeDeleted()) {\n                    $field['dropdown_condition']['is_deleted'] = false;\n                }\n                if ($object->maybeActive()) {\n                    $field['dropdown_condition']['is_active'] = true;\n                }\n            }\n\n            //get value\n            $value = null;\n            if (is_array($found_v)) {\n                if ($field['type'] == \"dropdown\") {\n                    $value = $found_v[\"plugin_fields_\" . $field['name'] . \"dropdowns_id\"];\n                } else if ($field['type'] == \"glpi_item\") {\n                    $itemtype_key = sprintf('itemtype_%s', $field['name']);\n                    $items_id_key = sprintf('items_id_%s', $field['name']);\n                    $value = [\n                        'itemtype' => $found_v[$itemtype_key],\n                        'items_id' => $found_v[$items_id_key],\n                    ];\n                } else {\n                    $value = $found_v[$field['name']] ?? \"\";\n                }\n            }\n\n            if (!$field['is_readonly']) {\n                if ($field['type'] == \"dropdown\") {\n                    $field_name = sprintf('plugin_fields_%sdropdowns_id', $field['name']);\n                    if (isset($_SESSION['plugin']['fields']['values_sent'][$field_name])) {\n                        $value = $_SESSION['plugin']['fields']['values_sent'][$field_name];\n                    } elseif (isset($item->input[$field_name])) {\n                        // find from $item->input due to ajax refresh container\n                        $value = $item->input[$field_name];\n                    }\n                } else {\n                    if (isset($_SESSION['plugin']['fields']['values_sent'][$field['name']])) {\n                        $value = $_SESSION['plugin']['fields']['values_sent'][$field['name']];\n                    } elseif (isset($item->input[$field['name']])) {\n                        // find from $item->input due to ajax refresh container\n                        $value = $item->input[$field['name']];\n                    }\n                }\n            }\n\n            //get default value\n            if ($value === null) {\n                if ($field['type'] === 'dropdown' && $field['default_value'] === '') {\n                    $value = 0;\n                } else if ($field['default_value'] !== \"\") {\n                    $value = $field['default_value'];\n\n                    // shortcut for date/datetime\n                    if (\n                        in_array($field['type'], ['date', 'datetime'])\n                        && $value == 'now'\n                    ) {\n                        $value = $_SESSION[\"glpi_currenttime\"];\n                    }\n                }\n            }\n\n            if ($field['multiple']) {\n                $value = json_decode($value);\n            }\n\n            $field['value'] = $value;\n        }\n\n        $html = TemplateRenderer::getInstance()->render('@fields/fields.html.twig', [\n            'item'           => $item,\n            'fields'         => $fields,\n            'canedit'        => $canedit,\n            'massiveaction'  => $massiveaction,\n            'container'      => $container_obj,\n        ]);\n\n        unset($_SESSION['plugin']['fields']['values_sent']);\n\n        return $html;\n    }\n\n    public static function showSingle($itemtype, $searchOption, $massiveaction = false)\n    {\n        global $DB;\n\n        //clean dropdown [pre/su]fix if exists\n        $cleaned_linkfield = preg_replace(\n            \"/plugin_fields_(.*)dropdowns_id/\",\n            \"$1\",\n            $searchOption['linkfield']\n        );\n\n        //find field\n        $query = \"SELECT fields.plugin_fields_containers_id, fields.is_readonly, fields.multiple, fields.default_value\n                FROM glpi_plugin_fields_fields fields\n                LEFT JOIN glpi_plugin_fields_containers containers\n                  ON containers.id = fields.plugin_fields_containers_id\n                  AND containers.itemtypes LIKE '%$itemtype%'\n               WHERE fields.name = '$cleaned_linkfield'\";\n        $res = $DB->query($query);\n        if ($DB->numrows($res) == 0) {\n            return false;\n        }\n\n        $data = $DB->fetchAssoc($res);\n\n        //display an hidden post field to store container id\n        echo Html::hidden('c_id', ['value' => $data['plugin_fields_containers_id']]);\n\n        //prepare array for function prepareHtmlFields\n        $fields = [[\n            'id'                          => 0,\n            'type'                        => $searchOption['pfields_type'],\n            'plugin_fields_containers_id' => $data['plugin_fields_containers_id'],\n            'name'                        => $cleaned_linkfield,\n            'is_readonly'                 => $data['is_readonly'],\n            'default_value'               => $data['default_value'],\n            'multiple'                    => $data['multiple']\n        ]\n        ];\n\n        //show field\n        $item = new $itemtype();\n        $item->getEmpty();\n\n        echo self::prepareHtmlFields($fields, $item, true, false, $massiveaction);\n\n        return true;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function post_getEmpty()\n    {\n        $this->fields['is_active'] = 1;\n        $this->fields['type']      = 'text';\n    }\n\n    public static function getTypes(bool $flat_list = true)\n    {\n        $common_types = [\n            'header'       => __(\"Header\", \"fields\"),\n            'text'         => __(\"Text (single line)\", \"fields\"),\n            'textarea'     => __(\"Text (multiples lines)\", \"fields\"),\n            'number'       => __(\"Number\", \"fields\"),\n            'url'          => __(\"URL\", \"fields\"),\n            'dropdown'     => __(\"Dropdown\", \"fields\"),\n            'yesno'        => __(\"Yes/No\", \"fields\"),\n            'date'         => __(\"Date\", \"fields\"),\n            'datetime'     => __(\"Date & time\", \"fields\"),\n            'glpi_item'    => __(\"GLPI item\", \"fields\"),\n        ];\n\n        $all_types = [\n            __('Common') => $common_types,\n        ];\n\n        foreach (PluginFieldsToolbox::getGlpiItemtypes() as $section => $itemtypes) {\n            $all_types[$section] = [];\n            foreach ($itemtypes as $itemtype => $itemtype_name) {\n                $all_types[$section]['dropdown-' . $itemtype] = $itemtype_name;\n            }\n        }\n\n        return $flat_list ? array_merge([], ...array_values($all_types)) : $all_types;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function post_addItem()\n    {\n        $input = $this->fields;\n\n        //dropdowns : create files\n        if ($input['type'] === \"dropdown\") {\n            //search if dropdown already exist in other container\n            $found = $this->find(['id' => ['!=', $input['id']], 'name' => $input['name']]);\n            //for dropdown, if already exist, don't create files\n            if (empty($found)) {\n                PluginFieldsDropdown::create($input);\n            }\n        }\n\n        //Create label translation\n        if (!isset($this->input['clone']) || !$this->input['clone']) {\n            PluginFieldsLabelTranslation::createForItem($this);\n        }\n    }\n\n    public function rawSearchOptions()\n    {\n        $tab = [];\n\n        $tab[] = [\n            'id'            => 2,\n            'table'         => self::getTable(),\n            'field'         => 'label',\n            'name'          => __('Label'),\n            'massiveaction' => false,\n            'autocomplete'  => true,\n        ];\n\n        $tab[] = [\n            'id'            => 3,\n            'table'         => self::getTable(),\n            'field'         => 'default_value',\n            'name'          => __('Default values'),\n            'massiveaction' => false,\n            'autocomplete'  => true,\n        ];\n\n        return $tab;\n    }\n\n    public function prepareInputForClone($input)\n    {\n        if (array_key_exists('allowed_values', $input) && !empty($input['allowed_values'])) {\n            // $input has been transformed with `Toolbox::addslashes_deep()`, and `self::prepareInputForAdd()`\n            // is expecting an array, so it have to be unslashed then json decoded.\n            $input['allowed_values'] = json_decode(Sanitizer::dbUnescape($input['allowed_values']));\n        } else {\n            unset($input['allowed_values']);\n        }\n\n        return $input;\n    }\n\n    public function getCloneRelations(): array\n    {\n        return [\n            PluginFieldsStatusOverride::class,\n            PluginFieldsLabelTranslation::class,\n        ];\n    }\n}\n", "<?php\n\n/**\n * -------------------------------------------------------------------------\n * Fields plugin for GLPI\n * -------------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of Fields.\n *\n * Fields is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Fields is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Fields. If not, see <http://www.gnu.org/licenses/>.\n * -------------------------------------------------------------------------\n * @copyright Copyright (C) 2013-2022 by Fields plugin team.\n * @license   GPLv2 https://www.gnu.org/licenses/gpl-2.0.html\n * @link      https://github.com/pluginsGLPI/fields\n * -------------------------------------------------------------------------\n */\n\nclass PluginFieldsProfile extends CommonDBRelation\n{\n    use Glpi\\Features\\Clonable;\n\n    public static $itemtype_1 = PluginFieldsContainer::class;\n    public static $items_id_1 = 'plugin_fields_containers_id';\n    public static $itemtype_2 = Profile::class;\n    public static $items_id_2 = 'profiles_id';\n\n    /**\n     * Install or update plugin base data.\n     *\n     * @param Migration $migration Migration instance\n     * @param string    $version   Plugin current version\n     *\n     * @return boolean\n     */\n    public static function installBaseData(Migration $migration, $version)\n    {\n        global $DB;\n\n        $default_charset = DBConnection::getDefaultCharset();\n        $default_collation = DBConnection::getDefaultCollation();\n        $default_key_sign = DBConnection::getDefaultPrimaryKeySignOption();\n\n        $table = self::getTable();\n\n        if (!$DB->tableExists($table)) {\n            $migration->displayMessage(sprintf(__(\"Installing %s\"), $table));\n\n            $query = \"CREATE TABLE IF NOT EXISTS `$table` (\n                  `id`                                INT {$default_key_sign} NOT NULL auto_increment,\n                  `profiles_id`                       INT {$default_key_sign} NOT NULL DEFAULT '0',\n                  `plugin_fields_containers_id`       INT {$default_key_sign} NOT NULL DEFAULT '0',\n                  `right`                             CHAR(1)  DEFAULT NULL,\n                  PRIMARY KEY                         (`id`),\n                  KEY `profiles_id`                   (`profiles_id`),\n                  KEY `plugin_fields_containers_id`   (`plugin_fields_containers_id`)\n               ) ENGINE=InnoDB DEFAULT CHARSET={$default_charset} COLLATE={$default_collation} ROW_FORMAT=DYNAMIC;\";\n            $DB->query($query) or die($DB->error());\n        }\n\n        return true;\n    }\n\n    public static function uninstall()\n    {\n        global $DB;\n\n        $DB->query(\"DROP TABLE IF EXISTS `\" . self::getTable() . \"`\");\n\n        return true;\n    }\n\n\n    public function getTabNameForItem(CommonGLPI $item, $withtemplate = 0)\n    {\n        return self::createTabEntry(_n(\"Profile\", \"Profiles\", 2));\n    }\n\n    public static function displayTabContentForItem(CommonGLPI $item, $tabnum = 1, $withtemplate = 0)\n    {\n        $profile = new Profile();\n        $found_profiles = $profile->find();\n\n        $fields_profile = new self();\n        echo \"<form name='form' method='post' action='\" . $fields_profile->getFormURL() . \"'>\";\n        echo \"<div class='spaced' id='tabsbody'>\";\n        echo \"<table class='tab_cadre_fixe'>\";\n\n        echo \"<tr><th colspan='2'>\" . _n(\"Profile\", \"Profiles\", 2) . \"</th></tr>\";\n        foreach ($found_profiles as $profile_item) {\n            //get right for current profile\n            $found = $fields_profile->find([\n                'profiles_id' => $profile_item['id'],\n                'plugin_fields_containers_id' => $item->fields['id']\n            ]);\n            $first_found = array_shift($found);\n\n            //display right\n            echo \"<tr>\";\n            echo \"<td>\" . $profile_item['name'] . \"</td>\";\n            echo \"<td>\";\n            Profile::dropdownRight(\n                \"rights[\" . $profile_item['id'] . \"]\",\n                ['value' => $first_found['right']]\n            );\n            echo \"</td>\";\n            echo \"<tr>\";\n        }\n        echo \"<ul>\";\n        echo \"<tr><td class='tab_bg_2 center' colspan='2'>\";\n        echo \"<input type='hidden' name='plugin_fields_containers_id' value='\" . $item->fields['id'] . \"' />\";\n        echo \"<input type='submit' name='update' value=\\\"\" . _sx(\"button\", \"Save\") . \"\\\" class='submit'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n        echo \"</table></div>\";\n        Html::closeForm();\n    }\n\n    public static function updateProfile($input)\n    {\n        $fields_profile = new self();\n        foreach ($input['rights'] as $profiles_id => $right) {\n            $found = $fields_profile->find(\n                [\n                    'profiles_id' => $profiles_id,\n                    'plugin_fields_containers_id' => $input['plugin_fields_containers_id']\n                ]\n            );\n            if (count($found) > 0) {\n                 $first_found = array_shift($found);\n\n                 $fields_profile->update([\n                     'id'                          => $first_found['id'],\n                     'profiles_id'                 => $profiles_id,\n                     'plugin_fields_containers_id' => $input['plugin_fields_containers_id'],\n                     'right'                       => $right\n                 ]);\n            } else {\n                $fields_profile->add([\n                    'profiles_id'                 => $profiles_id,\n                    'plugin_fields_containers_id' => $input['plugin_fields_containers_id'],\n                    'right'                       => $right\n                ]);\n            }\n        }\n\n        return true;\n    }\n\n    public static function createForContainer(PluginFieldsContainer $container)\n    {\n        $profile = new Profile();\n        $found_profiles = $profile->find();\n\n        $fields_profile = new self();\n        foreach ($found_profiles as $profile_item) {\n            $fields_profile->add([\n                'profiles_id'                 => $profile_item['id'],\n                'plugin_fields_containers_id' => $container->fields['id'],\n                'right'                       => CREATE\n            ]);\n        }\n        return true;\n    }\n\n    public static function addNewProfile(Profile $profile)\n    {\n        $containers = new PluginFieldsContainer();\n        $found_containers = $containers->find();\n\n        $fields_profile = new self();\n        foreach ($found_containers as $container) {\n            $fields_profile->add([\n                'profiles_id'                 => $profile->fields['id'],\n                'plugin_fields_containers_id' => $container['id']\n            ]);\n        }\n        return true;\n    }\n\n    public static function deleteProfile(Profile $profile)\n    {\n        $fields_profile = new self();\n        $fields_profile->deleteByCriteria(['profiles_id' => $profile->fields['id']]);\n        return true;\n    }\n}\n"], "fixing_code": ["<?php\n\n/**\n * -------------------------------------------------------------------------\n * Fields plugin for GLPI\n * -------------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of Fields.\n *\n * Fields is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Fields is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Fields. If not, see <http://www.gnu.org/licenses/>.\n * -------------------------------------------------------------------------\n * @copyright Copyright (C) 2013-2022 by Fields plugin team.\n * @license   GPLv2 https://www.gnu.org/licenses/gpl-2.0.html\n * @link      https://github.com/pluginsGLPI/fields\n * -------------------------------------------------------------------------\n */\n\ninclude(\"../../../inc/includes.php\");\n\nif (empty($_GET[\"id\"])) {\n    $_GET[\"id\"] = \"\";\n}\n\n$container = new PluginFieldsContainer();\n\nif (isset($_POST[\"add\"])) {\n    $container->check(-1, CREATE, $_POST);\n    $newID = $container->add($_POST);\n    Html::redirect(PLUGINFIELDS_WEB_DIR . \"/front/container.form.php?id=$newID\");\n} else if (isset($_POST[\"delete\"])) {\n    $container->check($_POST['id'], DELETE);\n    $ok = $container->delete($_POST);\n    Html::redirect(PLUGINFIELDS_WEB_DIR . \"/front/container.php\");\n} else if (isset($_REQUEST[\"purge\"])) {\n    $container->check($_REQUEST['id'], PURGE);\n    $container->delete($_REQUEST, 1);\n    Html::redirect(PLUGINFIELDS_WEB_DIR . \"/front/container.php\");\n} else if (isset($_POST[\"update\"])) {\n    $container->check($_POST['id'], UPDATE);\n    $container->update($_POST);\n    Html::back();\n} else if (isset($_POST[\"update_fields_values\"])) {\n    $right = PluginFieldsProfile::getRightOnContainer($_SESSION['glpiactiveprofile']['id'], $_POST['plugin_fields_containers_id']);\n    if ($right > READ) {\n        $container->updateFieldsValues($_REQUEST, $_REQUEST['itemtype'], false);\n    }\n    Html::back();\n} else {\n    Html::header(\n        __(\"Additional fields\", \"fields\"),\n        $_SERVER['PHP_SELF'],\n        \"config\",\n        \"pluginfieldsmenu\",\n        \"fieldscontainer\"\n    );\n    $container->display(['id' => $_GET[\"id\"]]);\n    Html::footer();\n}\n", "<?php\n\n/**\n * -------------------------------------------------------------------------\n * Fields plugin for GLPI\n * -------------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of Fields.\n *\n * Fields is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Fields is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Fields. If not, see <http://www.gnu.org/licenses/>.\n * -------------------------------------------------------------------------\n * @copyright Copyright (C) 2013-2022 by Fields plugin team.\n * @license   GPLv2 https://www.gnu.org/licenses/gpl-2.0.html\n * @link      https://github.com/pluginsGLPI/fields\n * -------------------------------------------------------------------------\n */\n\nuse Glpi\\Toolbox\\Sanitizer;\n\nclass PluginFieldsContainer extends CommonDBTM\n{\n    use Glpi\\Features\\Clonable;\n\n    public static $rightname = 'config';\n\n    public static function canCreate()\n    {\n        return self::canUpdate();\n    }\n\n    public static function canPurge()\n    {\n        return self::canUpdate();\n    }\n\n    public static function titleList()\n    {\n        echo \"<div class='center'><a class='vsubmit' href='regenerate_files.php'><i class='pointer fa fa-refresh'></i>&nbsp;\" .\n            __(\"Regenerate container files\", \"fields\") . \"</a>&nbsp;&nbsp;<a class='vsubmit' href='export_to_yaml.php'><i class='pointer fa fa-refresh'></i>&nbsp;\" .\n            __(\"Export to YAML\", \"fields\") . \"</a></div><br>\";\n    }\n\n    /**\n     * Install or update plugin base data.\n     *\n     * @param Migration $migration Migration instance\n     * @param string    $version   Plugin current version\n     *\n     * @return boolean\n     */\n    public static function installBaseData(Migration $migration, $version)\n    {\n        global $DB;\n\n        $default_charset = DBConnection::getDefaultCharset();\n        $default_collation = DBConnection::getDefaultCollation();\n        $default_key_sign = DBConnection::getDefaultPrimaryKeySignOption();\n\n        $table = self::getTable();\n\n        if (!$DB->tableExists($table)) {\n            $migration->displayMessage(sprintf(__(\"Installing %s\"), $table));\n\n            $query = \"CREATE TABLE IF NOT EXISTS `$table` (\n                  `id`           INT            {$default_key_sign} NOT NULL auto_increment,\n                  `name`         VARCHAR(255)   DEFAULT NULL,\n                  `label`        VARCHAR(255)   DEFAULT NULL,\n                  `itemtypes`    LONGTEXT       DEFAULT NULL,\n                  `type`         VARCHAR(255)   DEFAULT NULL,\n                  `subtype`      VARCHAR(255)   DEFAULT NULL,\n                  `entities_id`  INT            {$default_key_sign} NOT NULL DEFAULT '0',\n                  `is_recursive` TINYINT        NOT NULL DEFAULT '0',\n                  `is_active`    TINYINT        NOT NULL DEFAULT '0',\n                  PRIMARY KEY    (`id`),\n                  KEY            `entities_id`  (`entities_id`)\n               ) ENGINE=InnoDB DEFAULT CHARSET={$default_charset} COLLATE={$default_collation} ROW_FORMAT=DYNAMIC;\";\n            $DB->query($query) or die($DB->error());\n        }\n\n        // multiple itemtype for one container\n        if (!$DB->fieldExists($table, \"itemtypes\")) {\n            $migration->changeField($table, 'itemtype', 'itemtypes', 'longtext');\n            $migration->migrationOneTable($table);\n\n            $query = \"UPDATE `$table` SET `itemtypes` = CONCAT('[\\\"', `itemtypes`, '\\\"]')\";\n            $DB->query($query) or die($DB->error());\n        }\n\n        //add display preferences for this class\n        $d_pref = new DisplayPreference();\n        $found  = $d_pref->find(['itemtype' => __CLASS__]);\n        if (count($found) === 0) {\n            for ($i = 2; $i <= 5; $i++) {\n                $DB->updateOrInsert(\n                    DisplayPreference::getTable(),\n                    [\n                        'itemtype' => __CLASS__,\n                        'num'      => $i,\n                        'rank'     => $i - 1,\n                        'users_id' => 0\n                    ],\n                    [\n                        'itemtype' => __CLASS__,\n                        'num'      => $i,\n                        'users_id' => 0\n                    ]\n                );\n            }\n        }\n\n        if (!$DB->fieldExists($table, \"subtype\")) {\n            $migration->addField($table, 'subtype', 'VARCHAR(255) DEFAULT NULL', ['after' => 'type']);\n            $migration->migrationOneTable($table);\n        }\n\n        return true;\n    }\n\n    /**\n     * Install or update user data.\n     *\n     * @param Migration $migration Migration instance\n     * @param string    $version   Plugin current version\n     *\n     * @return boolean\n     */\n    public static function installUserData(Migration $migration, $version)\n    {\n        global $DB;\n\n        // -> 0.90-1.3: generated class moved\n        // Drop them, they will be regenerated\n        $obj        = new self();\n        $containers = $obj->find();\n        foreach ($containers as $container) {\n            $itemtypes = !empty($container['itemtypes'])\n                ? json_decode($container['itemtypes'], true)\n                : [];\n\n            foreach ($itemtypes as $itemtype) {\n                $sysname = self::getSystemName($itemtype, $container['name']);\n                $class_filename = $sysname . \".class.php\";\n                if (file_exists(PLUGINFIELDS_DIR . \"/inc/$class_filename\")) {\n                    unlink(PLUGINFIELDS_DIR . \"/inc/$class_filename\");\n                }\n\n                $injclass_filename = $sysname . \"injection.class.php\";\n                if (file_exists(PLUGINFIELDS_DIR . \"/inc/$injclass_filename\")) {\n                    unlink(PLUGINFIELDS_DIR . \"/inc/$injclass_filename\");\n                }\n            }\n        }\n\n        // Regenerate container classes to ensure they can be used\n        $migration->displayMessage(__(\"Regenerate containers files\", \"fields\"));\n        $obj        = new self();\n        $containers = $obj->find();\n        foreach ($containers as $container) {\n            self::generateTemplate($container);\n        }\n\n        // Fix containers names that were generated prior to Fields 1.9.2.\n        $bad_named_containers = $DB->request(\n            [\n                'FROM' => self::getTable(),\n                'WHERE' => [\n                    'name' => [\n                        'REGEXP',\n                        $DB->escape('\\d+')\n                    ],\n                ],\n            ]\n        );\n\n        if ($bad_named_containers->count() > 0) {\n            $migration->displayMessage(__(\"Fix container names\", \"fields\"));\n\n            $toolbox = new PluginFieldsToolbox();\n\n            foreach ($bad_named_containers as $container) {\n                $old_name = $container['name'];\n\n                // Update container name\n                $new_name = $toolbox->getSystemNameFromLabel($container['label']);\n                foreach (json_decode($container['itemtypes']) as $itemtype) {\n                    while (strlen(getTableForItemType(self::getClassname($itemtype, $new_name))) > 64) {\n                        // limit tables names to 64 chars (MySQL limit)\n                        $new_name = substr($new_name, 0, -1);\n                    }\n                }\n                $container['name'] = $new_name;\n                $container_obj = new PluginFieldsContainer();\n                $container_obj->update(\n                    $container,\n                    false\n                );\n\n                // Rename container tables and itemtype if needed\n                foreach (json_decode($container['itemtypes']) as $itemtype) {\n                    $migration->renameItemtype(\n                        self::getClassname($itemtype, $old_name),\n                        self::getClassname($itemtype, $new_name)\n                    );\n                }\n            }\n        }\n\n        //Computer OS tab is no longer part of computer object. Moving to main\n        $ostab = self::findContainer(Computer::getType(), 'domtab', Computer::getType() . '$1');\n        if ($ostab) {\n            //check if we already have a container on Computer main tab\n            $comptab = self::findContainer(Computer::getType(), 'dom');\n            if ($comptab) {\n                $oscontainer = new PluginFieldsContainer();\n                $oscontainer->getFromDB($ostab);\n\n                $compcontainer = new PluginFieldsContainer();\n                $compcontainer->getFromDB($comptab);\n\n                $fields = new PluginFieldsField();\n                $fields = $fields->find(['plugin_fields_containers_id' => $ostab]);\n\n                $classname = self::getClassname(Computer::getType(), $oscontainer->fields['name']);\n                $osdata = new $classname();\n                $classname = self::getClassname(Computer::getType(), $compcontainer->fields['name']);\n                $compdata = new $classname();\n\n                $fieldnames = [];\n                //add fields to compcontainer\n                foreach ($fields as $field) {\n                    $newname = $field['name'];\n                    $compfields = $fields->find(['plugin_fields_containers_id' => $comptab, 'name' => $newname]);\n                    if ($compfields) {\n                        $newname = $newname . '_os';\n                        $DB->query(\"UPDATE glpi_plugin_fields_fields SET name='$newname' WHERE name='{$field['name']}' AND plugin_fields_containers_id='$ostab'\");\n                    }\n                    $compdata::addField($newname, $field['type']);\n                    $fieldnames[$field['name']] = $newname;\n                }\n\n                $sql = \"UPDATE glpi_plugin_fields_fields SET plugin_fields_containers_id='$comptab' WHERE plugin_fields_containers_id='$ostab'\";\n                $DB->query($sql);\n                $DB->query(\"DELETE FROM glpi_plugin_fields_containers WHERE id='$ostab'\");\n\n                //migrate existing data\n                $existings = $osdata->find();\n                foreach ($existings as $existing) {\n                    $data = [];\n                    foreach ($fieldnames as $oldname => $newname) {\n                        $data[$newname] = $existing[$oldname];\n                    }\n                    $compdata->add($data);\n                }\n\n                //drop old table\n                $DB->query(\"DROP TABLE \" . $osdata::getTable());\n            } else {\n                $sql = \"UPDATE glpi_plugin_fields_containers SET type='dom', subtype=NULL WHERE id='$ostab'\";\n                $comptab = $ostab;\n                $DB->query($sql);\n            }\n        }\n\n        // Ensure data is update before regenerating files.\n        $migration->executeMigration();\n\n        // Regenerate files and install missing tables\n        $migration->displayMessage(__(\"Updating generated containers files\", \"fields\"));\n        $obj        = new self();\n        $containers = $obj->find();\n        foreach ($containers as $container) {\n            self::create($container);\n        }\n\n        return true;\n    }\n\n    public static function uninstall()\n    {\n        global $DB;\n\n        //uninstall container table and class\n        $obj = new self();\n        $containers = $obj->find();\n        foreach ($containers as $container) {\n            $obj->delete(['id' => $container['id']]);\n        }\n\n        //drop global container table\n        $DB->query(\"DROP TABLE IF EXISTS `\" . self::getTable() . \"`\");\n\n        //delete display preferences for this item\n        $pref = new DisplayPreference();\n        $pref->deleteByCriteria([\n            'itemtype' => __CLASS__\n        ]);\n\n        return true;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function post_getEmpty()\n    {\n        $this->fields['is_active']    = 1;\n        $this->fields['is_recursive'] = 1;\n    }\n\n    public function rawSearchOptions()\n    {\n        $tab = [];\n\n        $tab[] = [\n            'id'            => 1,\n            'table'         => self::getTable(),\n            'field'         => 'name',\n            'name'          => __(\"Name\"),\n            'datatype'      => 'itemlink',\n            'itemlink_type' => self::getType(),\n            'massiveaction' => false,\n        ];\n\n        $tab[] = [\n            'id'            => 2,\n            'table'         => self::getTable(),\n            'field'         => 'label',\n            'name'          => __(\"Label\"),\n            'massiveaction' => false,\n            'autocomplete'  => true,\n        ];\n\n        $tab[] = [\n            'id'            => 3,\n            'table'         => self::getTable(),\n            'field'         => 'itemtypes',\n            'name'          => __(\"Associated item type\"),\n            'datatype'      => 'specific',\n            'massiveaction' => false,\n            'nosearch'      => true,\n        ];\n\n        $tab[] = [\n            'id'            => 4,\n            'table'         => self::getTable(),\n            'field'         => 'type',\n            'name'          => __(\"Type\"),\n            'searchtype'    => ['equals', 'notequals'],\n            'massiveaction' => false,\n        ];\n\n        $tab[] = [\n            'id'            => 5,\n            'table'         => self::getTable(),\n            'field'         => 'is_active',\n            'name'          => __(\"Active\"),\n            'datatype'      => 'bool',\n            'searchtype'    => ['equals', 'notequals'],\n        ];\n\n        $tab[] = [\n            'id'            => 6,\n            'table'         => 'glpi_entities',\n            'field'         => 'completename',\n            'name'          => __(\"Entity\"),\n            'massiveaction' => false,\n            'datatype'      => 'dropdown',\n        ];\n\n        $tab[] = [\n            'id'            => 7,\n            'table'         => self::getTable(),\n            'field'         => 'is_recursive',\n            'name'          => __(\"Child entities\"),\n            'massiveaction' => false,\n            'datatype'      => 'bool',\n        ];\n\n        $tab[] = [\n            'id'            => 8,\n            'table'         => self::getTable(),\n            'field'         => 'id',\n            'name'          => __(\"ID\"),\n            'datatype'      => 'number',\n            'massiveaction' => false,\n        ];\n\n        return $tab;\n    }\n\n    public static function getSpecificValueToDisplay($field, $values, array $options = [])\n    {\n        if (!is_array($values)) {\n            $values = [$field => $values];\n        }\n        switch ($field) {\n            case 'type':\n                $types = self::getTypes();\n                return $types[$values[$field]];\n            case 'itemtypes':\n                $types = json_decode($values[$field]);\n                $obj   = '';\n                $count = count($types);\n                $i     = 1;\n                foreach ($types as $type) {\n                    // prevent usage of plugin class if not loaded\n                    if (!class_exists($type)) {\n                        continue;\n                    }\n                    $name_type = getItemForItemtype($type);\n                    $obj .= $name_type->getTypeName(2);\n                    if ($count > $i) {\n                        $obj .= \", \";\n                    }\n                    $i++;\n                }\n                return $obj;\n        }\n    }\n\n\n    public function getValueToSelect($field_id_or_search_options, $name = '', $values = '', $options = [])\n    {\n\n        switch ($field_id_or_search_options['table'] . '.' . $field_id_or_search_options['field']) {\n            // For searchoption \"Type\"\n            case $this->getTable() . '.type':\n                $options['display'] = false;\n                return Dropdown::showFromArray($name, self::getTypes(), $options);\n            case $this->getTable() . '.itemtypes':\n                $options['display'] = false;\n                return Dropdown::showFromArray($name, self::getItemtypes(), $options);\n        }\n\n        return parent::getValueToSelect($field_id_or_search_options, $name, $values, $options);\n    }\n\n    public function defineTabs($options = [])\n    {\n        $ong = [];\n        $this->addDefaultFormTab($ong);\n        $this->addStandardTab('PluginFieldsField', $ong, $options);\n        $this->addStandardTab('PluginFieldsStatusOverride', $ong, $options);\n        $this->addStandardTab('PluginFieldsProfile', $ong, $options);\n        $this->addStandardTab('PluginFieldsContainerDisplayCondition', $ong, $options);\n        $this->addStandardTab('PluginFieldsLabelTranslation', $ong, $options);\n\n        return $ong;\n    }\n\n    public function prepareInputForAdd($input)\n    {\n        if (!isset($input['itemtypes'])) {\n            Session::AddMessageAfterRedirect(\n                __(\n                    \"You cannot add block without associated element type\",\n                    \"fields\"\n                ),\n                false,\n                ERROR\n            );\n            return false;\n        }\n\n        if (!is_array($input['itemtypes'])) {\n            $input['itemtypes'] = [$input['itemtypes']];\n        }\n\n        if ($input['type'] === \"dom\") {\n            //check for already exist dom container with this itemtype\n            $found = $this->find(['type' => 'dom']);\n            if (count($found) > 0) {\n                foreach (array_column($found, 'itemtypes') as $founditemtypes) {\n                    foreach (json_decode($founditemtypes) as $founditemtype) {\n                        if (in_array($founditemtype, $input['itemtypes'])) {\n                             Session::AddMessageAfterRedirect(__(\"You cannot add several blocks with type 'Insertion in the form' on same object\", \"fields\"), false, ERROR);\n                             return false;\n                        }\n                    }\n                }\n            }\n        }\n\n        if ($input['type'] === \"domtab\") {\n            //check for already exist domtab container with this itemtype on this tab\n            $found = $this->find(['type' => 'domtab', 'subtype' => $input['subtype']]);\n            if (count($found) > 0) {\n                foreach (array_column($found, 'itemtypes') as $founditemtypes) {\n                    foreach (json_decode($founditemtypes) as $founditemtype) {\n                        if (in_array($founditemtype, $input['itemtypes'])) {\n                             Session::AddMessageAfterRedirect(__(\"You cannot add several blocks with type 'Insertion in the form of a specific tab' on same object tab\", \"fields\"), false, ERROR);\n                             return false;\n                        }\n                    }\n                }\n            }\n        }\n\n        $toolbox = new PluginFieldsToolbox();\n        $input['name'] = $toolbox->getSystemNameFromLabel($input['label']);\n\n        //reject adding when container name is too long for mysql table name\n        foreach ($input['itemtypes'] as $itemtype) {\n            $tmp = getTableForItemType(self::getClassname($itemtype, $input['name']));\n            if (strlen($tmp) > 64) {\n                Session::AddMessageAfterRedirect(\n                    __(\"Container name is too long for database (digits in name are replaced by characters, try to remove them)\", 'fields'),\n                    false,\n                    ERROR\n                );\n                return false;\n            }\n        }\n\n        //check for already existing container with same name\n        $found = $this->find(['name' => $input['name']]);\n        if (count($found) > 0) {\n            foreach (array_column($found, 'itemtypes') as $founditemtypes) {\n                foreach (json_decode($founditemtypes) as $founditemtype) {\n                    if (in_array($founditemtype, $input['itemtypes'])) {\n                        Session::AddMessageAfterRedirect(__(\"You cannot add several blocs with identical name on same object\", \"fields\"), false, ERROR);\n                        return false;\n                    }\n                }\n            }\n        }\n\n        $input['itemtypes'] = isset($input['itemtypes'])\n            ? Sanitizer::dbEscape(json_encode($input['itemtypes']))\n            : null;\n\n        return $input;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function post_addItem()\n    {\n\n        if (!isset($this->input['clone']) || !$this->input['clone']) {\n            //create profiles associated to this container\n            PluginFieldsProfile::createForContainer($this);\n            //Create label translation\n            PluginFieldsLabelTranslation::createForItem($this);\n        }\n\n        self::create($this->fields);\n    }\n\n    public static function create($fields)\n    {\n        //create class file\n        if (!self::generateTemplate($fields)) {\n            return false;\n        }\n\n        foreach (json_decode($fields['itemtypes']) as $itemtype) {\n            //install table for receive field\n            $classname = self::getClassname($itemtype, $fields['name']);\n            $classname::install();\n        }\n    }\n\n    public static function generateTemplate($fields)\n    {\n        $itemtypes = strlen($fields['itemtypes']) > 0\n            ? json_decode($fields['itemtypes'], true)\n            : [];\n        foreach ($itemtypes as $itemtype) {\n            // prevent usage of plugin class if not loaded\n            if (!class_exists($itemtype)) {\n                continue;\n            }\n\n            $sysname   = self::getSystemName($itemtype, $fields['name']);\n            $classname = self::getClassname($itemtype, $fields['name']);\n\n            $template_class = file_get_contents(PLUGINFIELDS_DIR . \"/templates/container.class.tpl\");\n            $template_class = str_replace(\"%%CLASSNAME%%\", $classname, $template_class);\n            $template_class = str_replace(\"%%ITEMTYPE%%\", $itemtype, $template_class);\n            $template_class = str_replace(\"%%CONTAINER%%\", $fields['id'], $template_class);\n            $template_class = str_replace(\"%%ITEMTYPE_RIGHT%%\", $itemtype::$rightname, $template_class);\n            $class_filename = $sysname . \".class.php\";\n            if (file_put_contents(PLUGINFIELDS_CLASS_PATH . \"/$class_filename\", $template_class) === false) {\n                Toolbox::logDebug(\"Error : class file creation - $class_filename\");\n                return false;\n            }\n\n            // Generate Datainjection files\n            $template_class = file_get_contents(PLUGINFIELDS_DIR . \"/templates/injection.class.tpl\");\n            $template_class = str_replace(\"%%CLASSNAME%%\", $classname, $template_class);\n            $template_class = str_replace(\"%%ITEMTYPE%%\", $itemtype, $template_class);\n            $template_class = str_replace(\"%%CONTAINER_ID%%\", $fields['id'], $template_class);\n            $template_class = str_replace(\"%%CONTAINER_NAME%%\", $fields['label'], $template_class);\n            $class_filename = $sysname . \"injection.class.php\";\n            if (file_put_contents(PLUGINFIELDS_CLASS_PATH . \"/$class_filename\", $template_class) === false) {\n                Toolbox::logDebug(\"Error : datainjection class file creation - $class_filename\");\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function pre_deleteItem()\n    {\n        global $DB;\n\n        $_SESSION['delete_container'] = true;\n\n        foreach (json_decode($this->fields['itemtypes']) as $itemtype) {\n            $classname          = self::getClassname($itemtype, $this->fields['name']);\n            $sysname          = self::getSystemName($itemtype, $this->fields['name']);\n            $class_filename     = $sysname . \".class.php\";\n            $injection_filename = $sysname . \"injection.class.php\";\n\n            //delete fields\n            $field_obj = new PluginFieldsField();\n            $field_obj->deleteByCriteria([\n                'plugin_fields_containers_id' => $this->fields['id']\n            ]);\n\n            //delete display condition\n            $field_obj = new PluginFieldsContainerDisplayCondition();\n            $field_obj->deleteByCriteria([\n                'plugin_fields_containers_id' => $this->fields['id']\n            ]);\n\n            //delete profiles\n            $profile_obj = new PluginFieldsProfile();\n            $profile_obj->deleteByCriteria([\n                'plugin_fields_containers_id' => $this->fields['id']\n            ]);\n\n            //delete label translations\n            $translation_obj = new PluginFieldsLabelTranslation();\n            $translation_obj->deleteByCriteria([\n                'itemtype' => self::getType(),\n                'items_id' => $this->fields['id']\n            ]);\n\n            //delete table\n            if (class_exists($classname)) {\n                 $classname::uninstall();\n            } else {\n                //class does not exists; try to remove any existing table\n                $tablename = getTableForItemType($classname);\n                $DB->query(\"DROP TABLE IF EXISTS `$tablename`\");\n            }\n\n            //clean session\n            unset($_SESSION['delete_container']);\n\n            //remove file\n            if (file_exists(PLUGINFIELDS_CLASS_PATH . \"/$class_filename\")) {\n                unlink(PLUGINFIELDS_CLASS_PATH . \"/$class_filename\");\n            }\n\n            if (file_exists(PLUGINFIELDS_CLASS_PATH . \"/$injection_filename\")) {\n                unlink(PLUGINFIELDS_CLASS_PATH . \"/$injection_filename\");\n            }\n        }\n\n        return true;\n    }\n\n    public static function preItemPurge($item)\n    {\n        $itemtype = get_class($item);\n        $containers = new self();\n        $founded_containers = $containers->find();\n        foreach ($founded_containers as $container) {\n            $itemtypes = json_decode($container['itemtypes']);\n            if (in_array($itemtype, $itemtypes)) {\n                $classname = 'PluginFields' . $itemtype . getSingular($container['name']);\n                $fields = new $classname();\n                $fields->deleteByCriteria(['items_id' => $item->fields['id']], true);\n            }\n        }\n        return true;\n    }\n\n    public static function getTypeName($nb = 0)\n    {\n        return __(\"Block\", \"fields\");\n    }\n\n    public function showForm($ID, $options = [])\n    {\n\n        $this->initForm($ID, $options);\n\n        if (!$this->isNewID($ID)) {\n            $btn_url   = Plugin::getWebDir('fields') . '/front/export_to_yaml.php?id=' . $ID;\n            $btn_label = __(\"Export to YAML\", \"fields\");\n            $export_btn = <<<HTML\n                <a href=\"{$btn_url}\" class=\"btn btn-ghost-secondary\"\n                   title=\"{$btn_label}\"\n                   data-bs-toggle=\"tooltip\" data-bs-placement=\"bottom\">\n                    <i class=\"fas fa-file-export fa-lg\"></i>\n                </a>\nHTML;\n            $options['header_toolbar'] = [$export_btn];\n        }\n\n        $this->showFormHeader($options);\n        $rand = mt_rand();\n\n        echo \"<tr>\";\n        echo \"<td width='20%'>\" . __(\"Label\") . \" : </td>\";\n        echo \"<td width='30%'>\";\n        echo Html::input(\n            'label',\n            [\n                'value' => $this->fields['label'],\n            ]\n        );\n        echo \"</td>\";\n        echo \"<td width='20%'>&nbsp;</td>\";\n        echo \"<td width='30%'>&nbsp;</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr>\";\n        echo \"<td>\" . __(\"Type\") . \" : </td>\";\n        echo \"<td>\";\n        if ($ID > 0) {\n            $types = self::getTypes();\n            echo $types[$this->fields[\"type\"]];\n        } else {\n            Dropdown::showFromArray(\n                'type',\n                self::getTypes(),\n                [\n                    'value' => $this->fields[\"type\"],\n                    'rand'  => $rand\n                ]\n            );\n            Ajax::updateItemOnSelectEvent(\n                \"dropdown_type$rand\",\n                \"itemtypes_$rand\",\n                \"../ajax/container_itemtypes_dropdown.php\",\n                [\n                    'type'     => '__VALUE__',\n                    'itemtype' => $this->fields[\"itemtypes\"],\n                    'subtype'  => $this->fields['subtype'],\n                    'rand'     => $rand\n                ]\n            );\n        }\n        echo \"</td>\";\n        echo \"<td>\" . __(\"Associated item type\") . \" : </td>\";\n        echo \"<td>\";\n        if ($ID > 0) {\n            $types = json_decode($this->fields['itemtypes']);\n            $obj = '';\n            $count = count($types);\n            $i = 1;\n            foreach ($types as $type) {\n                // prevent usage of plugin class if not loaded\n                if (!class_exists($type)) {\n                    continue;\n                }\n\n                $name_type = getItemForItemtype($type);\n                $obj .= $name_type->getTypeName(2);\n                if ($count > $i) {\n                    $obj .= \", \";\n                }\n                $i++;\n            }\n            echo $obj;\n        } else {\n            echo \"&nbsp;<span id='itemtypes_$rand'>\";\n            self::showFormItemtype([\n                'rand'    => $rand,\n                'subtype' => $this->fields['subtype']\n            ]);\n            echo \"</span>\";\n        }\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        $display = \"style='display:none'\";\n        if (!empty($this->fields[\"subtype\"])) {\n            $display = \"\";\n        }\n        echo \"<tr id='tab_tr' $display>\";\n        echo \"<td colspan='2'></td>\";\n        echo \"<td>\" . __(\"Tab\", \"fields\") . \" : </td>\";\n        echo \"<td>\";\n        echo \"&nbsp;<span id='subtype_$rand'></span>\";\n        if ($ID > 0 && !empty($this->fields[\"subtype\"])) {\n            $itemtypes = json_decode($this->fields[\"itemtypes\"], true);\n            $itemtype = array_shift($itemtypes);\n            $item = new $itemtype();\n            $item->getEmpty();\n            $tabs = self::getSubtypes($item);\n            echo $tabs[$this->fields[\"subtype\"]];\n        }\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr>\";\n        echo \"<td>\" . __(\"Active\") . \" : </td>\";\n        echo \"<td>\";\n        Dropdown::showYesNo(\"is_active\", $this->fields[\"is_active\"]);\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        $this->showFormButtons($options);\n\n        return true;\n    }\n\n    public static function showFormItemtype($params = [])\n    {\n        $is_domtab = isset($params['type']) && $params['type'] == 'domtab';\n\n        $rand = $params['rand'];\n        Dropdown::showFromArray(\n            \"itemtypes\",\n            self::getItemtypes($is_domtab),\n            [\n                'rand'                => $rand,\n                'multiple'            => !$is_domtab,\n                'width'               => 200,\n                'display_emptychoice' => $is_domtab\n            ]\n        );\n\n        if ($is_domtab) {\n            Ajax::updateItemOnSelectEvent(\n                [\"dropdown_type$rand\", \"dropdown_itemtypes$rand\"],\n                \"subtype_$rand\",\n                \"../ajax/container_subtype_dropdown.php\",\n                [\n                    'type'     => '__VALUE0__',\n                    'itemtype' => '__VALUE1__',\n                    'subtype'  => $params[\"subtype\"],\n                    'rand'     => $rand\n                ]\n            );\n        }\n    }\n\n    /**\n     * Show subtype selection form\n     *\n     * @param array   $params  Parameters\n     * @param boolean $display Whether to display or not; defaults to false\n     *\n     * @return string|void\n     */\n    public static function showFormSubtype($params, $display = false)\n    {\n        $out = \"<script type='text/javascript'>jQuery('#tab_tr').hide();</script>\";\n        if (isset($params['type']) && $params['type'] == \"domtab\") {\n            if (class_exists($params['itemtype'])) {\n                $item = new $params['itemtype']();\n                $item->getEmpty();\n\n                $tabs = self::getSubtypes($item);\n\n                if (count($tabs)) {\n                    // delete Log of array (don't work with this tab)\n                    $tabs_to_remove = ['Log$1', 'Document_Item$1'];\n                    foreach ($tabs_to_remove as $tab_to_remove) {\n                        if (isset($tabs[$tab_to_remove])) {\n                            unset($tabs[$tab_to_remove]);\n                        }\n                    }\n\n                    // For delete <sup class='tab_nb'>number</sup> :\n                    foreach ($tabs as &$value) {\n                        $results = [];\n                        if (preg_match_all('#<sup.*>(.+)</sup>#', $value, $results)) {\n                             $value = str_replace($results[0][0], \"\", $value);\n                        }\n                    }\n\n                    if (!isset($params['subtype'])) {\n                        $params['subtype'] = null;\n                    }\n\n                    $out .= Dropdown::showFromArray(\n                        'subtype',\n                        $tabs,\n                        ['value'   => $params['subtype'],\n                            'width'   => '100%',\n                            'display' => false\n                        ]\n                    );\n                    $out .= \"<script type='text/javascript'>jQuery('#tab_tr').show();</script>\";\n                }\n            }\n        }\n        if ($display === false) {\n            return $out;\n        } else {\n            echo $out;\n        }\n    }\n\n    /**\n     * Get supported item types\n     *\n     * @param boolean $is_domtab Domtab or not\n     *\n     * @return array\n     */\n    public static function getItemtypes($is_domtab)\n    {\n        $all_itemtypes = PluginFieldsToolbox::getGlpiItemtypes();\n\n        if ($is_domtab) {\n            // Filter items that do not have tab handled\n            foreach ($all_itemtypes as $section => $itemtypes) {\n                $all_itemtypes[$section] = array_filter(\n                    $itemtypes,\n                    function ($itemtype) {\n                        return count(self::getSubtypes($itemtype)) > 0;\n                    },\n                    ARRAY_FILTER_USE_KEY\n                );\n            }\n\n            // Filter groupts that do not have items handled\n            $all_itemtypes = array_filter($all_itemtypes);\n        }\n\n        return $all_itemtypes;\n    }\n\n    public static function getTypes()\n    {\n        return [\n            'tab'    => __(\"Add tab\", \"fields\"),\n            'dom'    => __(\"Insertion in the form (before save button)\", \"fields\"),\n            'domtab' => __(\"Insertion in the form of a specific tab (before save button)\", \"fields\")\n        ];\n    }\n\n    public static function getEntries($type = 'tab', $full = false)\n    {\n        global $DB;\n\n        $condition = [\n            'is_active' => 1,\n        ];\n        if ($type !== \"all\") {\n            $condition[] = ['type' => $type];\n        }\n\n        if (!$DB->tableExists(self::getTable())) {\n            return false;\n        }\n\n        $itemtypes = [];\n        $container = new self();\n        $found     = $container->find($condition, 'label');\n        foreach ($found as $item) {\n            //entities restriction\n            if (!in_array($item['entities_id'], $_SESSION['glpiactiveentities'])) {\n                if ($item['is_recursive'] == 1) {\n                    $entities = getSonsOf(\"glpi_entities\", $item['entities_id']);\n                    if (count(array_intersect($entities, $_SESSION['glpiactiveentities'])) == 0) {\n                        continue;\n                    }\n                } else {\n                    continue;\n                }\n            }\n\n            if (Session::isCron() || !isset($_SESSION['glpiactiveprofile']['id'])) {\n                continue;\n            }\n            //profiles restriction\n            $right = PluginFieldsProfile::getRightOnContainer($_SESSION['glpiactiveprofile']['id'], $item['id']);\n            if ($right < READ) {\n                continue;\n            }\n\n            $jsonitemtypes = json_decode($item['itemtypes']);\n            //show more info or not\n            foreach ($jsonitemtypes as $v) {\n                if ($full) {\n                    //check for translation\n                    $item['itemtype'] = self::getType();\n                    $label = PluginFieldsLabelTranslation::getLabelFor($item);\n                    $itemtypes[$v][$item['name']] = $label;\n                } else {\n                    $itemtypes[] = $v;\n                }\n            }\n        }\n        return $itemtypes;\n    }\n\n    public static function getUsedItemtypes($type = 'all', $must_be_active = false)\n    {\n        global $DB;\n        $itemtypes = [];\n        $where = $type == 'all' ? '1=1' : ('type = \"' . $type . '\"');\n        if ($must_be_active) {\n            $where .= ' AND is_active = 1';\n        }\n\n        $query = 'SELECT DISTINCT `itemtypes` FROM `glpi_plugin_fields_containers` WHERE ' . $where;\n        $result = $DB->query($query);\n        while (list($data) = $DB->fetchArray($result)) {\n            $jsonitemtype = json_decode($data);\n            $itemtypes    = array_merge($itemtypes, $jsonitemtype);\n        }\n\n        return $itemtypes;\n    }\n\n    public function getTabNameForItem(CommonGLPI $item, $withtemplate = 0)\n    {\n        $itemtypes = self::getEntries('tab', true);\n        if (isset($itemtypes[$item->getType()])) {\n            $tabs_entries = [];\n            $container    = new self();\n            foreach ($itemtypes[$item->getType()] as $tab_name => $tab_label) {\n                // needs to check if entity of item is in hierachy of $tab_name\n                foreach ($container->find(['is_active' => 1, 'name' => $tab_name]) as $data) {\n                    $dataitemtypes = json_decode($data['itemtypes']);\n                    if (in_array(get_class($item), $dataitemtypes) != false) {\n                        $entities = [$data['entities_id']];\n                        if ($data['is_recursive']) {\n                            $entities = getSonsOf(getTableForItemType('Entity'), $data['entities_id']);\n                        }\n\n                        if (!$item->isEntityAssign() || in_array($item->fields['entities_id'], $entities)) {\n                            $display_condition = new PluginFieldsContainerDisplayCondition();\n                            if ($display_condition->computeDisplayContainer($item, $data['id'])) {\n                                $tabs_entries[$tab_name] = $tab_label;\n                            }\n                        }\n                    }\n                }\n            }\n            return $tabs_entries;\n        }\n    }\n\n\n    public static function displayTabContentForItem(CommonGLPI $item, $tabnum = 1, $withtemplate = 0)\n    {\n        if ($withtemplate) {\n            //Do not display tab from template or from item created from template\n            return [];\n        }\n\n        //retrieve container for current tab\n        $container = new self();\n        $found_c   = $container->find(['type' => 'tab', 'name' => $tabnum, 'is_active' => 1]);\n        foreach ($found_c as $data) {\n            $dataitemtypes = json_decode($data['itemtypes']);\n            if (in_array(get_class($item), $dataitemtypes) != false) {\n                return PluginFieldsField::showForTabContainer($data['id'], $item);\n            }\n        }\n    }\n\n    /**\n     * Insert values submited by fields container\n     *\n     * @param array   $data          data posted\n     * @param string  $itemtype      Item type\n     * @param boolean $massiveaction Is a massive action\n     *\n     * @return boolean\n     */\n    public function updateFieldsValues($data, $itemtype, $massiveaction = false)\n    {\n        if (self::validateValues($data, $itemtype, $massiveaction) === false) {\n            return false;\n        }\n\n        // Normalize values\n        foreach ($data as $key => $value) {\n            if (is_array($value)) {\n                // Convert \"multiple\" values into a JSON string\n                $data[$key] = json_encode($value);\n            }\n        }\n\n        $container_obj = new PluginFieldsContainer();\n        $container_obj->getFromDB($data['plugin_fields_containers_id']);\n\n        $items_id  = $data['items_id'];\n        $classname = self::getClassname($itemtype, $container_obj->fields['name']);\n\n        //check if data already inserted\n        $obj   = new $classname();\n        $found = $obj->find(['items_id' => $items_id]);\n        if (empty($found)) {\n            // add fields data\n            $obj->add($data);\n\n            //construct history on itemtype object (Historical tab)\n            self::constructHistory(\n                $data['plugin_fields_containers_id'],\n                $items_id,\n                $itemtype,\n                $data\n            );\n        } else {\n            $first_found = array_pop($found);\n            $data['id'] = $first_found['id'];\n            $obj->update($data);\n\n            //construct history on itemtype object (Historical tab)\n            self::constructHistory(\n                $data['plugin_fields_containers_id'],\n                $items_id,\n                $itemtype,\n                $data,\n                $first_found\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Add log in \"itemtype\" object on fields values update\n     * @param  int    $containers_id container id\n     * @param  int    $items_id      item id\n     * @param  string $itemtype      item type\n     * @param  array  $data          values send by update form\n     * @param  array  $old_values    old values, if empty -> values add\n     * @return void\n     */\n    public static function constructHistory(\n        $containers_id,\n        $items_id,\n        $itemtype,\n        $data,\n        $old_values = []\n    ) {\n        // Don't log few itemtypes\n        $obj = new $itemtype();\n        if ($obj->dohistory == false) {\n            return;\n        }\n\n        //get searchoptions\n        $searchoptions = self::getAddSearchOptions($itemtype, $containers_id);\n\n        //define non-data keys\n        $blacklist_k = [\n            'plugin_fields_containers_id' => 0,\n            'items_id'                    => 0,\n            'itemtype'                    => $itemtype,\n            'update_fields_values'        => 0,\n            '_glpi_csrf_token'            => 0\n        ];\n\n        //remove non-data keys\n        $data = array_diff_key($data, $blacklist_k);\n\n        //add/update values condition\n        if (empty($old_values)) {\n            // -- add new item --\n\n            foreach ($data as $key => $value) {\n                //log only not empty values\n                if (!empty($value)) {\n                    //prepare log\n                    $changes = [0, \"N/A\", $value];\n\n                    //find searchoption\n                    foreach ($searchoptions as $id_search_option => $searchoption) {\n                        if ($searchoption['linkfield'] == $key) {\n                             $changes[0] = $id_search_option;\n\n                            if ($searchoption['datatype'] === 'dropdown') {\n                                //manage dropdown values\n                                $changes = [$id_search_option,\n                                    \"\",\n                                    Dropdown::getDropdownName($searchoption['table'], $value)\n                                ];\n                            } elseif ($searchoption['datatype'] === 'bool') {\n                                //manage bool values\n                                $changes = [$id_search_option, \"\", Dropdown::getYesNo($value)];\n                            } elseif ($searchoption['datatype'] === 'specific') {\n                                //manage specific values\n                                $changes = [\n                                    $id_search_option,\n                                    \"\",\n                                    PluginFieldsAbstractContainerInstance::getSpecificValueToDisplay(\n                                        $key,\n                                        $value,\n                                        [\n                                            'searchopt' => $searchoption,\n                                            'separator' => ', ',\n                                        ]\n                                    )\n                                ];\n                            }\n                        }\n                    }\n\n                    //add log\n                    Log::history($items_id, $itemtype, $changes);\n                }\n            }\n        } else {\n            // -- update existing item --\n\n            //find changes\n            $updates = [];\n            foreach ($old_values as $key => $old_value) {\n                if (\n                    !isset($data[$key])\n                    || empty($old_value) && empty($data[$key])\n                    || $old_value !== '' && $data[$key] == 'NULL'\n                ) {\n                    continue;\n                }\n\n                if ($data[$key] !== $old_value) {\n                    $updates[$key] = [0, $old_value ?? '', $data[$key]];\n                }\n            }\n\n            //for all change find searchoption\n            foreach ($updates as $key => $changes) {\n                foreach ($searchoptions as $id_search_option => $searchoption) {\n                    if ($searchoption['linkfield'] == $key) {\n                        $changes[0] = $id_search_option;\n\n                        if ($searchoption['datatype'] === 'dropdown') {\n                            //manage dropdown values\n                            $changes[1] = Dropdown::getDropdownName($searchoption['table'], $changes[1]);\n                            $changes[2] = Dropdown::getDropdownName($searchoption['table'], $changes[2]);\n                        } elseif ($searchoption['datatype'] === 'bool') {\n                            //manage bool values\n                            $changes[1] = Dropdown::getYesNo($changes[1]);\n                            $changes[2] = Dropdown::getYesNo($changes[2]);\n                        } elseif ($searchoption['datatype'] === 'specific') {\n                            //manage specific values\n                            $changes[1] = PluginFieldsAbstractContainerInstance::getSpecificValueToDisplay(\n                                $key,\n                                $changes[1],\n                                [\n                                    'searchopt' => $searchoption,\n                                    'separator' => ', ',\n                                ]\n                            );\n                            $changes[2] = PluginFieldsAbstractContainerInstance::getSpecificValueToDisplay(\n                                $key,\n                                $changes[2],\n                                [\n                                    'searchopt' => $searchoption,\n                                    'separator' => ', ',\n                                ]\n                            );\n                        }\n                    }\n                }\n\n                //add log\n                Log::history($items_id, $itemtype, $changes);\n            }\n        }\n    }\n\n    /**\n     * check data inserted\n     * display a message when not ok\n     *\n     * @param array   $data          Data send by form\n     * @param string  $itemtype      Item type\n     * @param boolean $massiveaction ?\n     *\n     * @return boolean\n     */\n    public static function validateValues($data, $itemtype, $massiveaction)\n    {\n        global $DB;\n\n        $valid         = true;\n        $empty_errors  = [];\n        $number_errors = [];\n\n        $container = new self();\n        $container->getFromDB($data['plugin_fields_containers_id']);\n\n        $field_obj = new PluginFieldsField();\n        $fields = $field_obj->find([\n            'plugin_fields_containers_id' => $data['plugin_fields_containers_id']\n        ]);\n\n        // Apply status overrides\n        $status_field_name = PluginFieldsStatusOverride::getStatusFieldName($itemtype);\n        $status_overrides = array_key_exists($status_field_name, $data) && $data[$status_field_name] !== null\n            ? PluginFieldsStatusOverride::getOverridesForItemtypeAndStatus($container->getID(), $itemtype, $data[$status_field_name])\n            : [];\n        foreach ($status_overrides as $status_override) {\n            if (isset($fields[$status_override['plugin_fields_fields_id']])) {\n                $fields[$status_override['plugin_fields_fields_id']]['is_readonly'] = $status_override['is_readonly'];\n                $fields[$status_override['plugin_fields_fields_id']]['mandatory'] = $status_override['mandatory'];\n            }\n        }\n\n        foreach ($fields as $field) {\n            if (!$field['is_active']) {\n                continue;\n            }\n\n            if ($field['type'] == \"yesno\" || $field['type'] == \"header\") {\n                continue;\n            }\n\n            $name  = $field['name'];\n            $value = null;\n\n            if ($field['type'] == \"glpi_item\") {\n                $itemtype_key = sprintf('itemtype_%s', $name);\n                $items_id_key = sprintf('items_id_%s', $name);\n\n                if (\n                    isset($data[$itemtype_key], $data[$items_id_key])\n                    && is_a($data[$itemtype_key], CommonDBTM::class, true)\n                    && $data[$items_id_key] > 0\n                ) {\n                    $glpi_item = new $data[$itemtype_key]();\n                    $value = $glpi_item->getFromDB($data[$items_id_key]) ? $data[$items_id_key] : null;\n                }\n            } elseif (isset($data[$name])) {\n                $value = $data[$name];\n            } else if (isset($data['plugin_fields_' . $name . 'dropdowns_id'])) {\n                $value = $data['plugin_fields_' . $name . 'dropdowns_id'];\n            } else if ($field['mandatory'] == 1 && isset($data['items_id'])) {\n                $tablename = getTableForItemType(self::getClassname($itemtype, $container->fields['name']));\n\n                $query = \"SELECT * FROM `$tablename` WHERE\n                    `itemtype`='$itemtype'\n                    AND `items_id`='{$data['items_id']}'\n                    AND `plugin_fields_containers_id`='{$data['plugin_fields_containers_id']}'\";\n\n                $db_result = [];\n                if ($result = $DB->query($query)) {\n                    $db_result = $DB->fetchAssoc($result);\n                    if (isset($db_result['plugin_fields_' . $name . 'dropdowns_id'])) {\n                        $value = $db_result['plugin_fields_' . $name . 'dropdowns_id'];\n                    } else if (isset($db_result[$name])) {\n                        $value = $db_result[$name];\n                    }\n                }\n            } else {\n                if ($massiveaction) {\n                    continue;\n                }\n            }\n\n            //translate label\n            $field['itemtype'] = PluginFieldsField::getType();\n            $field['label'] = PluginFieldsLabelTranslation::getLabelFor($field);\n\n            // Check mandatory fields\n            if (\n                $field['mandatory'] == 1\n                && (\n                    $value === null\n                    || $value === ''\n                    || (($field['type'] === 'dropdown' || preg_match('/^dropdown-.+/i', $field['type'])) && $value == 0)\n                    || ($field['type'] === 'glpi_item' && $value === null)\n                    || (in_array($field['type'], ['date', 'datetime']) && $value == 'NULL')\n                )\n            ) {\n                $empty_errors[] = $field['label'];\n                $valid = false;\n            } else if ($field['type'] == 'number' && !empty($value) && !is_numeric($value)) {\n                // Check number fields\n                $number_errors[] = $field['label'];\n                $valid = false;\n            } else if ($field['type'] == 'url' && !empty($value)) {\n                if (filter_var($value, FILTER_VALIDATE_URL) === false) {\n                    $url_errors[] = $field['label'];\n                    $valid = false;\n                }\n            }\n        }\n\n        if (!empty($empty_errors)) {\n            Session::AddMessageAfterRedirect(__(\"Some mandatory fields are empty\", \"fields\") .\n                                          \" : \" . implode(', ', $empty_errors), false, ERROR);\n        }\n\n        if (!empty($number_errors)) {\n            Session::AddMessageAfterRedirect(__(\"Some numeric fields contains non numeric values\", \"fields\") .\n                                          \" : \" . implode(', ', $number_errors), false, ERROR);\n        }\n\n        if (!empty($url_errors)) {\n            Session::AddMessageAfterRedirect(__(\"Some URL fields contains invalid links\", \"fields\") .\n                                          \" : \" . implode(', ', $url_errors), false, ERROR);\n        }\n\n        return $valid;\n    }\n\n\n    public static function findContainer($itemtype, $type = 'tab', $subtype = '')\n    {\n\n        $condition = [\n            'is_active' => 1,\n            ['type' => $type],\n        ];\n\n        $entity = isset($_SESSION['glpiactiveentities'])\n                  ? $_SESSION['glpiactiveentities']\n                  : 0;\n        $condition += getEntitiesRestrictCriteria(\"\", \"\", $entity, true, true);\n\n        if ($subtype != '') {\n            if ($subtype == $itemtype . '$main') {\n                $condition[] = ['type' => 'dom'];\n            } else {\n                $condition[] = ['type' => ['!=', 'dom']];\n                $condition['subtype'] = $subtype;\n            }\n        }\n\n        $container = new PluginFieldsContainer();\n        $itemtypes = $container->find($condition);\n        $id = 0;\n        if (count($itemtypes) < 1) {\n            return false;\n        }\n\n        foreach ($itemtypes as $data) {\n            $dataitemtypes = json_decode($data['itemtypes']);\n            if (in_array($itemtype, $dataitemtypes) != false) {\n                $id = $data['id'];\n            }\n        }\n\n        //profiles restriction\n        if (isset($_SESSION['glpiactiveprofile']['id']) && $id > 0) {\n            $right = PluginFieldsProfile::getRightOnContainer($_SESSION['glpiactiveprofile']['id'], $id);\n            if ($right < READ) {\n                return false;\n            }\n        }\n\n        return $id;\n    }\n\n    /**\n     * Post item hook for add\n     * Do store data in db\n     *\n     * @param CommonDBTM $item Item instance\n     *\n     * @return CommonDBTM|true\n     */\n    public static function postItemAdd(CommonDBTM $item)\n    {\n        if (property_exists($item, 'plugin_fields_data')) {\n            $data = $item->plugin_fields_data;\n            $data['items_id'] = $item->getID();\n            //update data\n            $container = new self();\n            if ($container->updateFieldsValues($data, $item->getType(), isset($_REQUEST['massiveaction']))) {\n                return true;\n            }\n            return $item->input = [];\n        }\n    }\n\n    /**\n     * Pre item hook for update\n     * Do store data in db\n     *\n     * @param CommonDBTM $item Item instance\n     *\n     * @return boolean\n     */\n    public static function preItemUpdate(CommonDBTM $item)\n    {\n        self::preItem($item);\n        if (property_exists($item, 'plugin_fields_data')) {\n            $data = $item->plugin_fields_data;\n            //update data\n            $container = new self();\n            if (\n                count($data) == 0\n                || $container->updateFieldsValues($data, $item->getType(), isset($_REQUEST['massiveaction']))\n            ) {\n                return true;\n            }\n            return $item->input = [];\n        }\n    }\n\n\n    /**\n     * Pre item hook for add and update\n     * Validates and store plugin data in item object\n     *\n     * @param CommonDBTM $item Item instance\n     *\n     * @return boolean\n     */\n    public static function preItem(CommonDBTM $item)\n    {\n        //find container (if not exist, do nothing)\n        if (isset($_REQUEST['c_id'])) {\n            $c_id = $_REQUEST['c_id'];\n        } else {\n            $type = 'dom';\n            if (isset($_REQUEST['_plugin_fields_type'])) {\n                $type = $_REQUEST['_plugin_fields_type'];\n            }\n            $subtype = '';\n            if ($type == 'domtab') {\n                $subtype = $_REQUEST['_plugin_fields_subtype'];\n            }\n            if (false === ($c_id = self::findContainer(get_Class($item), $type, $subtype))) {\n                // tries for 'tab'\n                if (false === ($c_id = self::findContainer(get_Class($item)))) {\n                    return false;\n                }\n            }\n        }\n\n        $loc_c = new PluginFieldsContainer();\n        $loc_c->getFromDB($c_id);\n\n        // check rights on $c_id\n        $right = PluginFieldsProfile::getRightOnContainer($_SESSION['glpiactiveprofile']['id'], $c_id);\n        if (($right > READ) === false) {\n            return;\n        }\n\n        // need to check if container is usable on this object entity\n        $entities = [$loc_c->fields['entities_id']];\n        if ($loc_c->fields['is_recursive']) {\n            $entities = getSonsOf(getTableForItemType('Entity'), $loc_c->fields['entities_id']);\n        }\n\n        //workaround: when a ticket is created from readdonly profile,\n        //it is not initialized; see https://github.com/glpi-project/glpi/issues/1438\n        if (!isset($item->fields) || count($item->fields) == 0) {\n            $item->fields = $item->input;\n        }\n\n        if ($item->isEntityAssign() && !in_array($item->getEntityID(), $entities)) {\n            return false;\n        }\n\n        if (false !== ($data = self::populateData($c_id, $item))) {\n            if (self::validateValues($data, $item::getType(), isset($_REQUEST['massiveaction'])) === false) {\n                return $item->input = [];\n            }\n            return $item->plugin_fields_data = $data;\n        }\n\n        return;\n    }\n\n    /**\n     * Populates fields data from item\n     *\n     * @param integer    $c_id Container ID\n     * @param CommonDBTM $item Item instance\n     *\n     * @return array|false\n     */\n    private static function populateData($c_id, CommonDBTM $item)\n    {\n       //find fields associated to found container\n        $field_obj = new PluginFieldsField();\n        $fields = $field_obj->find(\n            [\n                'plugin_fields_containers_id' => $c_id,\n                'type' => ['!=', 'header']\n            ],\n            \"ranking\"\n        );\n\n       //prepare data to update\n        $data = ['plugin_fields_containers_id' => $c_id];\n        if (!$item->isNewItem()) {\n           //no ID yet while creating\n            $data['items_id'] = $item->getID();\n        }\n\n        // Add status so it can be used with status overrides\n        $status_field_name = PluginFieldsStatusOverride::getStatusFieldName($item->getType());\n        $data[$status_field_name] = null;\n        if (array_key_exists($status_field_name, $item->input) && $item->input[$status_field_name] !== '') {\n            $data[$status_field_name] = (int)$item->input[$status_field_name];\n        } elseif (array_key_exists($status_field_name, $item->fields) && $item->fields[$status_field_name] !== '') {\n            $data[$status_field_name] = (int)$item->fields[$status_field_name];\n        }\n\n        $has_fields = false;\n        foreach ($fields as $field) {\n            if ($field['type'] == 'glpi_item') {\n                $itemtype_key = sprintf('itemtype_%s', $field['name']);\n                $items_id_key = sprintf('items_id_%s', $field['name']);\n\n                if (!isset($item->input[$itemtype_key], $item->input[$items_id_key])) {\n                    continue; // not a valid input\n                }\n\n                $has_fields = true;\n                $data[$itemtype_key] = $item->input[$itemtype_key];\n                $data[$items_id_key] = $item->input[$items_id_key];\n\n                continue; // bypass unique field handling\n            }\n\n            if (isset($item->input[$field['name']])) {\n               //standard field\n                $input = $field['name'];\n            } else {\n               //dropdown field\n                $input = \"plugin_fields_\" . $field['name'] . \"dropdowns_id\";\n            }\n            if (isset($item->input[$input])) {\n                $has_fields = true;\n               // Before is_number check, help user to have a number correct, during a massive action of a number field\n                if ($field['type'] == 'number') {\n                    $item->input[$input] = str_replace(\",\", \".\", $item->input[$input]);\n                }\n                $data[$input] = $item->input[$input];\n            }\n        }\n\n        if ($has_fields === true) {\n            return $data;\n        } else {\n            return false;\n        }\n    }\n\n    public static function getAddSearchOptions($itemtype, $containers_id = false)\n    {\n        global $DB;\n\n        $opt = [];\n\n        // itemtype is stored in a JSON array, so entry is surrounded by double quotes\n        $search_string = json_encode($itemtype);\n        // Backslashes must be doubled in LIKE clause, according to MySQL documentation:\n        // > To search for \\, specify it as \\\\\\\\; this is because the backslashes are stripped\n        // > once by the parser and again when the pattern match is made,\n        // > leaving a single backslash to be matched against.\n        $search_string = str_replace('\\\\', '\\\\\\\\', $search_string);\n\n        $request = [\n            'SELECT' => [\n                'glpi_plugin_fields_fields.id AS field_id',\n                'glpi_plugin_fields_fields.name AS field_name',\n                'glpi_plugin_fields_fields.label AS field_label',\n                'glpi_plugin_fields_fields.type',\n                'glpi_plugin_fields_fields.is_readonly',\n                'glpi_plugin_fields_fields.allowed_values',\n                'glpi_plugin_fields_fields.multiple',\n                'glpi_plugin_fields_containers.id AS container_id',\n                'glpi_plugin_fields_containers.name AS container_name',\n                'glpi_plugin_fields_containers.label AS container_label',\n                (\n                    Session::isCron()\n                        ? new QueryExpression(sprintf('%s AS %s', READ + CREATE, $DB->quoteName('right')))\n                        : 'glpi_plugin_fields_profiles.right'\n                )\n            ],\n            'DISTINCT' => true,\n            'FROM' => 'glpi_plugin_fields_fields',\n            'INNER JOIN' => [\n                'glpi_plugin_fields_containers' => [\n                    'FKEY' => [\n                        'glpi_plugin_fields_containers' => 'id',\n                        'glpi_plugin_fields_fields'     => 'plugin_fields_containers_id',\n                    ]\n                ],\n                'glpi_plugin_fields_profiles' => [\n                    'FKEY' => [\n                        'glpi_plugin_fields_containers' => 'id',\n                        'glpi_plugin_fields_profiles'   => 'plugin_fields_containers_id',\n                    ]\n                ],\n            ],\n            'WHERE' => [\n                'glpi_plugin_fields_containers.is_active'   => 1,\n                'glpi_plugin_fields_containers.itemtypes'   => ['LIKE', '%' . $DB->escape($search_string) . '%'],\n                'glpi_plugin_fields_profiles.right'         => ['>', 0],\n                'glpi_plugin_fields_fields.is_active'       => 1,\n                ['NOT' => ['glpi_plugin_fields_fields.type' => 'header']],\n            ],\n            'ORDERBY'      => [\n                'glpi_plugin_fields_fields.id',\n            ],\n        ];\n        if ($containers_id !== false) {\n            $request['WHERE'][] = ['glpi_plugin_fields_containers.id' => $containers_id];\n        }\n        if (!Session::isCron()) {\n            $request['WHERE'][] = ['glpi_plugin_fields_profiles.profiles_id' => (int)$_SESSION['glpiactiveprofile']['id']];\n        }\n\n        $iterator = $DB->request($request);\n        foreach ($iterator as $data) {\n            $i = PluginFieldsField::SEARCH_OPTION_STARTING_INDEX + $data['field_id'];\n\n            $tablename = getTableForItemType(self::getClassname($itemtype, $data['container_name']));\n\n            //get translations\n            $container = [\n                'itemtype' => PluginFieldsContainer::getType(),\n                'id'       => $data['container_id'],\n                'label'    => $data['container_label']\n            ];\n            $data['container_label'] = PluginFieldsLabelTranslation::getLabelFor($container);\n\n            $field = [\n                'itemtype' => PluginFieldsField::getType(),\n                'id'       => $data['field_id'],\n                'label'    => $data['field_label']\n            ];\n            $data['field_label'] = PluginFieldsLabelTranslation::getLabelFor($field);\n\n            // Default SO params\n            $opt[$i]['table']         = $tablename;\n            $opt[$i]['field']         = $data['field_name'];\n            $opt[$i]['name']          = $data['container_label'] . \" - \" . $data['field_label'];\n            $opt[$i]['linkfield']     = $data['field_name'];\n            $opt[$i]['joinparams']['jointype'] = \"itemtype_item\";\n\n            $opt[$i]['pfields_type']      = $data['type'];\n            $opt[$i]['pfields_fields_id'] = $data['field_id'];\n\n            if ($data['is_readonly']) {\n                $opt[$i]['massiveaction'] = false;\n            }\n            switch ($data['type']) {\n                case 'yesno':\n                    $opt[$i]['datatype'] = \"bool\";\n                    break;\n                case 'textarea':\n                case 'number':\n                    $opt[$i]['datatype'] = \"text\";\n                    break;\n                case 'date':\n                case 'datetime':\n                    $opt[$i]['datatype'] = $data['type'];\n                    break;\n                case 'url':\n                    $opt[$i]['datatype'] = 'weblink';\n                    break;\n                default:\n                    $opt[$i]['datatype'] = \"string\";\n            }\n\n            $dropdown_matches     = [];\n            if ($data['type'] === \"dropdown\") {\n                $field_name = \"plugin_fields_\" . $data['field_name'] . \"dropdowns_id\";\n\n                if ($data['multiple']) {\n                    $opt[$i]['table']      = $tablename;\n                    $opt[$i]['field']      = $field_name;\n                    $opt[$i]['datatype']   = 'specific';\n                } else {\n                    $opt[$i]['table']      = 'glpi_plugin_fields_' . $data['field_name'] . 'dropdowns';\n                    $opt[$i]['field']      = 'completename';\n                    $opt[$i]['linkfield']  = $field_name;\n                    $opt[$i]['datatype']   = \"dropdown\";\n\n                    $opt[$i]['forcegroupby'] = true;\n\n                    $opt[$i]['joinparams']['jointype'] = \"\";\n                    $opt[$i]['joinparams']['beforejoin']['table'] = $tablename;\n                    $opt[$i]['joinparams']['beforejoin']['joinparams']['jointype'] = \"itemtype_item\";\n                }\n            } elseif (\n                preg_match('/^dropdown-(?<class>.+)$/i', $data['type'], $dropdown_matches)\n                && class_exists($dropdown_matches['class'])\n            ) {\n                if ($data['multiple']) {\n                    $opt[$i]['datatype']   = 'specific';\n                } else {\n                    $opt[$i]['table']      = CommonDBTM::getTable($dropdown_matches['class']);\n                    $opt[$i]['field']      = 'name';\n                    $opt[$i]['right']      = 'all';\n                    $opt[$i]['datatype']   = \"dropdown\";\n\n                    $opt[$i]['forcegroupby'] = true;\n\n                    $opt[$i]['joinparams']['jointype'] = \"\";\n                    $opt[$i]['joinparams']['beforejoin']['table'] = $tablename;\n                    $opt[$i]['joinparams']['beforejoin']['joinparams']['jointype'] = \"itemtype_item\";\n                }\n            } elseif ($data['type'] === \"glpi_item\") {\n                $itemtype_field = sprintf('itemtype_%s', $data['field_name']);\n                $items_id_field = sprintf('items_id_%s', $data['field_name']);\n\n                $opt[$i]['table']              = $tablename;\n                $opt[$i]['field']              = $itemtype_field;\n                $opt[$i]['linkfield']          = $itemtype_field;\n                $opt[$i]['name']               = $data['container_label'] . \" - \" . $data['field_label'] . ' - ' . _n('Associated item type', 'Associated item types', Session::getPluralNumber());\n                $opt[$i]['datatype']           = 'itemtypename';\n                $opt[$i]['types']              = !empty($data['allowed_values']) ? json_decode($data['allowed_values']) : [];\n                $opt[$i]['additionalfields']   = ['itemtype'];\n                $opt[$i]['joinparams']['jointype'] = 'itemtype_item';\n                $opt[$i]['forcegroupby']       = true;\n                $opt[$i]['massiveaction']      = false;\n                $i++;\n\n                $opt[$i]['table']              = $tablename;\n                $opt[$i]['field']              = $items_id_field;\n                $opt[$i]['linkfield']          = $items_id_field;\n                $opt[$i]['name']               = $data['container_label'] . \" - \" . $data['field_label'] . ' - ' . __('Associated item ID');\n                $opt[$i]['massiveaction']      = false;\n                $opt[$i]['joinparams']['jointype'] = 'itemtype_item';\n                $opt[$i]['datatype']           = 'text';\n                $opt[$i]['additionalfields']   = ['itemtype'];\n            }\n        }\n\n        return $opt;\n    }\n\n    /**\n     * Get subtypes for specified itemtype.\n     * Was previously retrieved using $item::defineTabs() but\n     * this is not relevant with actual core.\n     *\n     * @param CommonDBTM $item Item instance\n     *\n     * @return array\n     */\n    private static function getSubtypes($item)\n    {\n        $tabs = [];\n        switch ($item::getType()) {\n            case Ticket::getType():\n            case Problem::getType():\n                $tabs = [\n                    $item::getType() . '$2' => __('Solution')\n                ];\n                break;\n            case Change::getType():\n                $tabs = [\n                    'Change$1' => __('Analysis'),\n                    'Change$2' => __('Solution'),\n                    'Change$3' => __('Plans')\n                ];\n                break;\n            case Entity::getType():\n                $tabs = [\n                    'Entity$2' => __('Address'),\n                    'Entity$3' => __('Advanced information'),\n                    'Entity$4' => __('Notifications'),\n                    'Entity$5' => __('Assistance'),\n                    'Entity$6' => __('Assets')\n                ];\n                break;\n            default:\n                //Toolbox::logDebug('Item type ' . $item::getType() . ' does not have any preconfigured subtypes!');\n                /* For debug purposes\n                $tabs = $item->defineTabs();\n                list($id, ) = each($tabs);\n                // delete first element of array ($main)\n                unset($tabs[$id]);*/\n                break;\n        }\n\n        return $tabs;\n    }\n\n    /**\n     * Retrieve the class name corresponding to an itemtype for given container.\n     *\n     * @param string $itemtype       Name of associated itemtype\n     * @param string $container_name Name of container\n     * @param string $suffix         Suffix to add\n     *\n     * @return string\n     */\n    public static function getClassname(string $itemtype, string $container_name, string $suffix = ''): string\n    {\n        return sprintf(\n            'PluginFields%s%s',\n            ucfirst(self::getSystemName($itemtype, $container_name)),\n            $suffix\n        );\n    }\n\n    /**\n     * Retrieve the system name corresponding to an itemtype for given container.\n     *\n     * @param string $itemtype       Name of associated itemtype\n     * @param string $container_name Name of container\n     *\n     * @return string\n     */\n    protected static function getSystemName(string $itemtype, string $container_name): string\n    {\n        return strtolower(str_replace('\\\\', '', $itemtype) . preg_replace('/s$/', '', $container_name));\n    }\n\n\n    public static function getIcon()\n    {\n        return \"fas fa-tasks\";\n    }\n\n    public static function getNameField()\n    {\n        return 'label';\n    }\n\n    public function prepareInputForClone($input)\n    {\n        if (array_key_exists('itemtypes', $input) && !empty($input['itemtypes'])) {\n            // $input has been transformed with `Toolbox::addslashes_deep()`, and `self::prepareInputForAdd()`\n            // is expecting an array, so it have to be unslashed then json decoded.\n            $input['itemtypes'] = json_decode(Sanitizer::dbUnescape($input['itemtypes']));\n        } else {\n            unset($input['itemtypes']);\n        }\n\n        return $input;\n    }\n\n    public function getCloneRelations(): array\n    {\n        return [\n            PluginFieldsContainerDisplayCondition::class,\n            PluginFieldsField::class,\n            PluginFieldsLabelTranslation::class,\n            PluginFieldsProfile::class,\n        ];\n    }\n}\n", "<?php\n\n/**\n * -------------------------------------------------------------------------\n * Fields plugin for GLPI\n * -------------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of Fields.\n *\n * Fields is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Fields is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Fields. If not, see <http://www.gnu.org/licenses/>.\n * -------------------------------------------------------------------------\n * @copyright Copyright (C) 2013-2022 by Fields plugin team.\n * @license   GPLv2 https://www.gnu.org/licenses/gpl-2.0.html\n * @link      https://github.com/pluginsGLPI/fields\n * -------------------------------------------------------------------------\n */\n\nuse Glpi\\Application\\View\\TemplateRenderer;\nuse Glpi\\Toolbox\\Sanitizer;\n\nclass PluginFieldsField extends CommonDBChild\n{\n    use Glpi\\Features\\Clonable;\n\n    /**\n     * Starting index for search options.\n     * @var integer\n     */\n    public const SEARCH_OPTION_STARTING_INDEX = 76665;\n\n    public static $itemtype = PluginFieldsContainer::class;\n    public static $items_id = 'plugin_fields_containers_id';\n\n    /**\n     * Install or update plugin base data.\n     *\n     * @param Migration $migration Migration instance\n     * @param string    $version   Plugin current version\n     *\n     * @return boolean\n     */\n    public static function installBaseData(Migration $migration, $version)\n    {\n        global $DB;\n\n        $default_charset = DBConnection::getDefaultCharset();\n        $default_collation = DBConnection::getDefaultCollation();\n        $default_key_sign = DBConnection::getDefaultPrimaryKeySignOption();\n\n        $table = self::getTable();\n\n        if (!$DB->tableExists($table)) {\n            $migration->displayMessage(sprintf(__(\"Installing %s\"), $table));\n\n            $query = \"CREATE TABLE IF NOT EXISTS `$table` (\n                  `id`                                INT            {$default_key_sign} NOT NULL auto_increment,\n                  `name`                              VARCHAR(255)   DEFAULT NULL,\n                  `label`                             VARCHAR(255)   DEFAULT NULL,\n                  `type`                              VARCHAR(255)   DEFAULT NULL,\n                  `plugin_fields_containers_id`       INT            {$default_key_sign} NOT NULL DEFAULT '0',\n                  `ranking`                           INT            NOT NULL DEFAULT '0',\n                  `default_value`                     LONGTEXT       ,\n                  `is_active`                         TINYINT        NOT NULL DEFAULT '1',\n                  `is_readonly`                       TINYINT        NOT NULL DEFAULT '1',\n                  `mandatory`                         TINYINT        NOT NULL DEFAULT '0',\n                  `multiple`                          TINYINT        NOT NULL DEFAULT '0',\n                  `allowed_values`                    TEXT           ,\n                  PRIMARY KEY                         (`id`),\n                  KEY `plugin_fields_containers_id`   (`plugin_fields_containers_id`),\n                  KEY `is_active`                     (`is_active`),\n                  KEY `is_readonly`                   (`is_readonly`)\n               ) ENGINE=InnoDB DEFAULT CHARSET={$default_charset} COLLATE={$default_collation} ROW_FORMAT=DYNAMIC;\";\n            $DB->query($query) or die($DB->error());\n        }\n\n        $migration->displayMessage(\"Updating $table\");\n\n        if (!$DB->fieldExists($table, 'is_active')) {\n            $migration->addField($table, 'is_active', 'bool', ['value' => 1]);\n            $migration->addKey($table, 'is_active', 'is_active');\n        }\n        if (!$DB->fieldExists($table, 'is_readonly')) {\n            $migration->addField($table, 'is_readonly', 'bool', ['default' => false]);\n            $migration->addKey($table, 'is_readonly', 'is_readonly');\n        }\n        if (!$DB->fieldExists($table, 'mandatory')) {\n            $migration->addField($table, 'mandatory', 'bool', ['value' => 0]);\n        }\n        if (!$DB->fieldExists($table, 'multiple')) {\n            $migration->addField($table, 'multiple', 'bool', ['value' => 0]);\n        }\n\n        //increase the size of column 'type' (25 to 255)\n        $migration->changeField($table, 'type', 'type', 'string');\n\n        if (!$DB->fieldExists($table, 'allowed_values')) {\n            $migration->addField($table, 'allowed_values', 'text');\n        }\n\n        // change default_value from varchar to longtext\n        $migration->changeField($table, 'default_value', 'default_value', 'longtext');\n\n        $toolbox = new PluginFieldsToolbox();\n        $toolbox->fixFieldsNames($migration, ['NOT' => ['type' => 'dropdown']]);\n\n        //move old types to new format\n        $migration->addPostQuery(\n            $DB->buildUpdate(\n                PluginFieldsField::getTable(),\n                ['type' => 'dropdown-User'],\n                ['type' => 'dropdownuser']\n            )\n        );\n\n        $migration->addPostQuery(\n            $DB->buildUpdate(\n                PluginFieldsField::getTable(),\n                ['type' => 'dropdown-OperatingSystem'],\n                ['type' => 'dropdownoperatingsystems']\n            )\n        );\n\n        // 1.18.3 Make search options ID stable over time ad constant across profiles\n        if (Config::getConfigurationValue('plugin:fields', 'stable_search_options') !== 'yes') {\n            self::migrateToStableSO($migration);\n            $migration->addConfig(['stable_search_options' => 'yes'], 'plugin:fields');\n        }\n\n        return true;\n    }\n\n    /**\n     * Migrate search options ID stored in DB to their new stable ID.\n     *\n     * Prior to 1.18.3, search options ID were built using a simple increment and filtered using current profile rights,\n     * resulting in following behaviours:\n     * - when a container was activated/deactivated/removed, SO ID were potentially changed;\n     * - when a field was removed, SO ID were potentially changed;\n     * - in a sessionless context (e.g. CLI command/crontask), no SO were available;\n     * - when user added a SO in its display preference from a A profile, this SO was sometimes targetting a completely different field on a B profile.\n     * All of these behaviours were resulting in unstable display preferences and saved searches.\n     *\n     * Producing an exact mapping between previous unstable SO ID and new stable SO ID is almost impossible in many cases, due to\n     * previously described behaviours. Basically, we cannot know if the current SO ID in database is still correct\n     * and what were the profile rights when it was generated.\n     *\n     * @param Migration $migration\n     */\n    private static function migrateToStableSO(Migration $migration): void\n    {\n        global $DB;\n\n        // Flatten itemtype list\n        $itemtypes = array_keys(array_merge([], ...array_values(PluginFieldsToolbox::getGlpiItemtypes())));\n\n        foreach ($itemtypes as $itemtype) {\n            // itemtype is stored in a JSON array, so entry is surrounded by double quotes\n            $search_string = json_encode($itemtype);\n            // Backslashes must be doubled in LIKE clause, according to MySQL documentation:\n            // > To search for \\, specify it as \\\\\\\\; this is because the backslashes are stripped\n            // > once by the parser and again when the pattern match is made,\n            // > leaving a single backslash to be matched against.\n            $search_string = str_replace('\\\\', '\\\\\\\\', $search_string);\n\n            $fields = $DB->request(\n                [\n                    'SELECT'     => [\n                        'glpi_plugin_fields_fields.id',\n                    ],\n                    'FROM'       => 'glpi_plugin_fields_fields',\n                    'INNER JOIN' => [\n                        'glpi_plugin_fields_containers' => [\n                            'FKEY' => [\n                                'glpi_plugin_fields_containers' => 'id',\n                                'glpi_plugin_fields_fields'     => 'plugin_fields_containers_id',\n                                [\n                                    'AND' => [\n                                        'glpi_plugin_fields_containers.is_active' => 1,\n                                    ]\n                                ]\n                            ]\n                        ],\n                    ],\n                    'WHERE' => [\n                        'glpi_plugin_fields_containers.itemtypes' => ['LIKE', '%' . $DB->escape($search_string) . '%'],\n                        ['NOT' => ['glpi_plugin_fields_fields.type' => 'header']],\n                    ],\n                    'ORDERBY'      => [\n                        'glpi_plugin_fields_fields.id',\n                    ],\n                ]\n            );\n\n            $i = PluginFieldsField::SEARCH_OPTION_STARTING_INDEX;\n\n            foreach ($fields as $field_data) {\n                $migration->changeSearchOption(\n                    $itemtype,\n                    $i,\n                    PluginFieldsField::SEARCH_OPTION_STARTING_INDEX + $field_data['id']\n                );\n\n                $i++;\n            }\n        }\n    }\n\n    public static function uninstall()\n    {\n        global $DB;\n\n        $DB->query(\"DROP TABLE IF EXISTS `\" . self::getTable() . \"`\");\n\n        return true;\n    }\n\n    public static function getTypeName($nb = 0)\n    {\n        return __(\"Field\", \"fields\");\n    }\n\n\n    public function prepareInputForAdd($input)\n    {\n        //parse name\n        $input['name'] = $this->prepareName($input);\n\n        if ($input['multiple'] ?? false) {\n            $input['default_value'] = json_encode($input['default_value'] ?? []);\n        }\n\n        //reject adding when field name is too long for mysql\n        if (strlen($input['name']) > 64) {\n            Session::AddMessageAfterRedirect(\n                __(\"Field name is too long for database (digits in name are replaced by characters, try to remove them)\", 'fields'),\n                false,\n                ERROR\n            );\n            return false;\n        }\n\n        if ($input['type'] === \"dropdown\") {\n            //search if dropdown already exist in this container\n            $found = $this->find(\n                [\n                    'name' => $input['name'],\n                    'plugin_fields_containers_id' => $input['plugin_fields_containers_id'],\n                ]\n            );\n\n            //reject adding for same dropdown on same bloc\n            if (!empty($found)) {\n                Session::AddMessageAfterRedirect(__(\"You cannot add same field 'dropdown' on same bloc\", 'fields', false, ERROR));\n                return false;\n            }\n\n            //reject adding when dropdown name is too long for mysql table name\n            if (strlen(getTableForItemType(PluginFieldsDropdown::getClassname($input['name']))) > 64) {\n                Session::AddMessageAfterRedirect(\n                    __(\"Field name is too long for database (digits in name are replaced by characters, try to remove them)\", 'fields'),\n                    false,\n                    ERROR\n                );\n                return false;\n            }\n        }\n\n        // Before adding, add the ranking of the new field\n        if (empty($input[\"ranking\"])) {\n            $input[\"ranking\"] = $this->getNextRanking();\n        }\n\n        //add field to container table\n        if ($input['type'] !== \"header\") {\n            $container_obj = new PluginFieldsContainer();\n            $container_obj->getFromDB($input['plugin_fields_containers_id']);\n            foreach (json_decode($container_obj->fields['itemtypes']) as $itemtype) {\n                $classname = PluginFieldsContainer::getClassname($itemtype, $container_obj->fields['name']);\n                $classname::addField(\n                    $input['name'],\n                    $input['type'],\n                    [\n                        'multiple' => (bool)($input['multiple'] ?? false)\n                    ]\n                );\n            }\n        }\n\n        if (isset($input['allowed_values'])) {\n            $input['allowed_values'] = Sanitizer::dbEscape(json_encode($input['allowed_values']));\n        }\n\n        return $input;\n    }\n\n\n    public function prepareInputForUpdate($input)\n    {\n        if (\n            array_key_exists('default_value', $input)\n            && $this->fields['multiple']\n        ) {\n            $input['default_value'] = json_encode($input['default_value'] ?: []);\n        }\n\n        return $input;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function pre_deleteItem()\n    {\n        //remove field in container table\n        if (\n            $this->fields['type'] !== \"header\"\n            && !isset($_SESSION['uninstall_fields'])\n            && !isset($_SESSION['delete_container'])\n        ) {\n            $container_obj = new PluginFieldsContainer();\n            $container_obj->getFromDB($this->fields['plugin_fields_containers_id']);\n            foreach (json_decode($container_obj->fields['itemtypes']) as $itemtype) {\n                $classname = PluginFieldsContainer::getClassname($itemtype, $container_obj->fields['name']);\n                $classname::removeField($this->fields['name'], $this->fields['type']);\n            }\n        }\n\n        //delete label translations\n        $translation_obj = new PluginFieldsLabelTranslation();\n        $translation_obj->deleteByCriteria([\n            'itemtype' => self::getType(),\n            'items_id' => $this->fields['id']\n        ]);\n\n        if ($this->fields['type'] === \"dropdown\") {\n            return PluginFieldsDropdown::destroy($this->fields['name']);\n        }\n        return true;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function post_purgeItem()\n    {\n        global $DB;\n\n        $table         = getTableForItemType(__CLASS__);\n        $old_container = $this->fields['plugin_fields_containers_id'];\n        $old_ranking   = $this->fields['ranking'];\n\n        $query = \"UPDATE $table SET\n                ranking = ranking-1\n                WHERE plugin_fields_containers_id = $old_container\n                AND ranking > $old_ranking\";\n        $DB->query($query);\n\n        return true;\n    }\n\n\n    /**\n     * parse name for avoid non alphanumeric char in it and conflict with other fields\n     * @param  array $input the field form input\n     * @return string  the parsed name\n     */\n    public function prepareName($input, bool $prevent_duplicated = true)\n    {\n        $toolbox = new PluginFieldsToolbox();\n\n        //contruct field name by processing label (remove non alphanumeric char)\n        if (empty($input['name'])) {\n            $input['name'] = $toolbox->getSystemNameFromLabel($input['label']) . 'field';\n        }\n\n        //for dropdown, if already exists, link to it\n        if (isset($input['type']) && $input['type'] === \"dropdown\") {\n            $found = $this->find(['name' => $input['name']]);\n            if (!empty($found)) {\n                return $input['name'];\n            }\n        }\n\n        // for dropdowns like dropdown-User, dropdown-Computer, etc...\n        $match = [];\n        if (isset($input['type']) && preg_match('/^dropdown-(?<type>.+)$/', $input['type'], $match) === 1) {\n            $input['name'] = getForeignKeyFieldForItemType($match['type']) . '_' . $input['name'];\n        }\n\n        //check if field name not already exist and not in conflict with itemtype fields name\n        $container = new PluginFieldsContainer();\n        $container->getFromDB($input['plugin_fields_containers_id']);\n\n        $field      = new self();\n        $field_name = $input['name'];\n\n        if ($prevent_duplicated) {\n            $i = 2;\n            while (count($field->find(['name' => $field_name])) > 0) {\n                $field_name = $toolbox->getIncrementedSystemName($input['name'], $i);\n                $i++;\n            }\n        }\n\n        // if it's too long then use a random postfix\n        // MySQL/MariaDB official limit for a column name is 64 chars,\n        // but there is a bug when trying to drop the column and the real max len is 53 chars\n        // FIXME: see: https://bugs.mysql.com/bug.php?id=107165\n        if (strlen($field_name) > 52) {\n            $rand = rand();\n            $field_name = substr($field_name, 0, 52 - strlen($rand)) . $rand;\n        }\n\n        return $field_name;\n    }\n\n    /**\n     * Get the next ranking for a specified field\n     *\n     * @return integer\n     */\n    public function getNextRanking()\n    {\n        global $DB;\n\n        $sql = \"SELECT max(`ranking`) AS `rank`\n              FROM `\" . self::getTable() . \"`\n              WHERE `plugin_fields_containers_id` = '\" .\n                  $this->fields['plugin_fields_containers_id'] . \"'\";\n        $result = $DB->query($sql);\n\n        if ($DB->numrows($result) > 0) {\n            $data = $DB->fetchAssoc($result);\n            return $data[\"rank\"] + 1;\n        }\n        return 0;\n    }\n\n    public function getTabNameForItem(CommonGLPI $item, $withtemplate = 0)\n    {\n        if (!$withtemplate) {\n            switch ($item->getType()) {\n                case __CLASS__:\n                    $ong[1] = $this->getTypeName(1);\n                    return $ong;\n            }\n        }\n\n        return self::createTabEntry(\n            __(\"Fields\", \"fields\"),\n            countElementsInTable(\n                self::getTable(),\n                ['plugin_fields_containers_id' => $item->getID()]\n            )\n        );\n    }\n\n    public static function displayTabContentForItem(CommonGLPI $item, $tabnum = 1, $withtemplate = 0)\n    {\n        $fup = new self();\n        $fup->showSummary($item);\n        return true;\n    }\n\n    public function defineTabs($options = [])\n    {\n        $ong = [];\n        $this->addDefaultFormTab($ong);\n        $this->addStandardTab('PluginFieldsLabelTranslation', $ong, $options);\n\n        return $ong;\n    }\n\n    public function showSummary($container)\n    {\n        global $DB, $CFG_GLPI;\n\n        $cID = $container->fields['id'];\n\n        // Display existing Fields\n        $query  = \"SELECT `id`, `label`\n                FROM `\" . $this->getTable() . \"`\n                WHERE `plugin_fields_containers_id` = '$cID'\n                ORDER BY `ranking` ASC\";\n        $result = $DB->query($query);\n\n        $rand   = mt_rand();\n\n        echo \"<div id='viewField$cID$rand'></div>\";\n\n        $ajax_params = [\n            'type'                        => __CLASS__,\n            'parenttype'                  => PluginFieldsContainer::class,\n            'plugin_fields_containers_id' => $cID,\n            'id'                          => -1\n        ];\n        echo Html::scriptBlock('\n            viewAddField' . $cID . $rand . ' = function() {\n                $(\"#viewField' . $cID . $rand . '\").load(\n                    \"' . $CFG_GLPI['root_doc'] . '/ajax/viewsubitem.php\",\n                    ' . json_encode($ajax_params) . '\n                );\n            };\n        ');\n\n        echo \"<div class='center'>\" .\n           \"<a href='javascript:viewAddField$cID$rand();'>\";\n        echo __(\"Add a new field\", \"fields\") . \"</a></div><br>\";\n\n        if ($DB->numrows($result) == 0) {\n            echo \"<table class='tab_cadre_fixe'><tr class='tab_bg_2'>\";\n            echo \"<th class='b'>\" . __(\"No field for this block\", \"fields\") . \"</th></tr></table>\";\n        } else {\n            echo '<div id=\"drag\">';\n            echo Html::hidden(\"_plugin_fields_containers_id\", ['value' => $cID,\n                'id'    => 'plugin_fields_containers_id'\n            ]);\n            echo \"<table class='tab_cadre_fixehov'>\";\n            echo \"<tr>\";\n            echo \"<th>\" . __(\"Label\")              . \"</th>\";\n            echo \"<th>\" . __(\"Type\")               . \"</th>\";\n            echo \"<th>\" . __(\"Default values\")     . \"</th>\";\n            echo \"<th>\" . __(\"Mandatory field\")    . \"</th>\";\n            echo \"<th>\" . __(\"Active\")             . \"</th>\";\n            echo \"<th>\" . __(\"Read only\", \"fields\") . \"</th>\";\n            echo \"<th width='16'>&nbsp;</th>\";\n            echo \"</tr>\";\n\n            $fields_type = self::getTypes();\n\n            Session::initNavigateListItems('PluginFieldsField', __('Fields list'));\n\n            while ($data = $DB->fetchArray($result)) {\n                if ($this->getFromDB($data['id'])) {\n                    echo \"<tr class='tab_bg_2' style='cursor:pointer'>\";\n\n                    echo \"<td>\";\n                    echo \"<a href='\" . Plugin::getWebDir('fields') . \"/front/field.form.php?id={$this->getID()}'>{$this->fields['label']}</a>\";\n                    echo \"</td>\";\n                    echo \"<td>\" . $fields_type[$this->fields['type']] . \"</td>\";\n                    echo \"<td>\" ;\n                    $dropdown_matches = [];\n                    if (\n                        preg_match('/^dropdown-(?<class>.+)$/', $this->fields['type'], $dropdown_matches) === 1\n                        && !empty($this->fields['default_value'])\n                    ) {\n                        $itemtype = $dropdown_matches['class'];\n                        // Itemtype may not exists (for instance for a deactivated plugin)\n                        if (is_a($itemtype, CommonDBTM::class, true)) {\n                            $item = new $itemtype();\n                            if ($this->fields['multiple']) {\n                                $values = json_decode($this->fields['default_value']);\n\n                                $names = [];\n                                foreach ($values as $value) {\n                                    if ($item->getFromDB($value)) {\n                                        $names[] = $item->getName();\n                                    }\n                                }\n\n                                echo implode(', ', $names);\n                            } else {\n                                if ($item->getFromDB($this->fields['default_value'])) {\n                                    echo $item->getName();\n                                }\n                            }\n                        }\n                    } elseif ($this->fields['type'] === 'dropdown' && !empty($this->fields['default_value'])) {\n                        $table = getTableForItemType(PluginFieldsDropdown::getClassname($this->fields['name']));\n                        if ($this->fields['multiple']) {\n                            echo implode(\n                                ', ',\n                                Dropdown::getDropdownArrayNames($table, json_decode($this->fields['default_value']))\n                            );\n                        } else {\n                            echo Dropdown::getDropdownName($table, $this->fields['default_value']);\n                        }\n                    } else {\n                        echo $this->fields['default_value'];\n                    }\n                    echo \"</td>\";\n                    echo \"<td align='center'>\" . Dropdown::getYesNo($this->fields[\"mandatory\"]) . \"</td>\";\n                    echo \"<td align='center'>\";\n                    echo ($this->isActive())\n                     ? __('Yes')\n                     : '<b class=\"red\">' . __('No') . '</b>';\n                    echo \"</td>\";\n\n                    echo \"<td>\";\n                    echo Dropdown::getYesNo($this->fields[\"is_readonly\"]);\n                    echo \"</td>\";\n\n                    echo '<td class=\"rowhandler control center\">';\n                    echo '<div class=\"drag row\" style=\"cursor:move; border: 0;\">';\n                    echo '<i class=\"ti ti-grip-horizontal\" title=\"' . __('Move') . '\">';\n                    echo '</div>';\n                    echo '</td>';\n                    echo \"</tr>\";\n                }\n            }\n        }\n        echo '</table>';\n        echo '</div>';\n        echo Html::scriptBlock('$(document).ready(function() {\n            redipsInit()\n        });');\n    }\n\n\n    public function showForm($ID, $options = [])\n    {\n        $rand = mt_rand();\n\n        if (isset($options['parent_id']) && !empty($options['parent_id'])) {\n            $container = new PluginFieldsContainer();\n            $container->getFromDB($options['parent_id']);\n        } else if (\n            isset($options['parent'])\n                 && $options['parent'] instanceof CommonDBTM\n        ) {\n            $container = $options['parent'];\n        }\n\n        if ($ID > 0) {\n            $attrs = ['readonly' => 'readonly'];\n            $edit = true;\n        } else {\n            $attrs = [];\n            // Create item\n            $edit = false;\n            $options['plugin_fields_containers_id'] = $container->getField('id');\n        }\n\n        $this->initForm($ID, $options);\n        $this->showFormHeader($ID, $options);\n\n        echo \"<tr>\";\n        echo \"<td>\" . __(\"Label\") . \" : </td>\";\n        echo \"<td colspan='3'>\";\n        echo Html::hidden('plugin_fields_containers_id', ['value' => $container->getField('id')]);\n        echo Html::input(\n            'label',\n            [\n                'value' => $this->fields['label'],\n            ] + $attrs\n        );\n        echo \"</td>\";\n\n        echo \"</tr>\";\n        echo \"<tr>\";\n        echo \"<td>\" . __(\"Type\") . \" : </td>\";\n        echo \"<td colspan='3'>\";\n        if ($edit) {\n            echo self::getTypes(true)[$this->fields['type']];\n        } else {\n            Dropdown::showFromArray(\n                'type',\n                self::getTypes(false),\n                [\n                    'value' => $this->fields['type'],\n                    'rand'  => $rand,\n                ]\n            );\n        }\n\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo '<tr id=\"plugin_fields_specific_fields_' . $rand . '\" style=\"line-height: 46px;\">';\n        echo '<td>';\n        Ajax::updateItemOnSelectEvent(\n            \"dropdown_type$rand\",\n            \"plugin_fields_specific_fields_$rand\",\n            \"../ajax/field_specific_fields.php\",\n            [\n                'id'   => $ID,\n                'type' => '__VALUE__',\n                'rand' => $rand,\n            ]\n        );\n        Ajax::updateItem(\n            \"plugin_fields_specific_fields_$rand\",\n            \"../ajax/field_specific_fields.php\",\n            [\n                'id'   => $ID,\n                'type' => $this->fields['type'] ?? '',\n                'rand' => $rand,\n            ]\n        );\n        echo '</td>';\n        echo '</tr>';\n\n        echo \"<tr>\";\n        echo \"<td>\" . __('Active') . \" :</td>\";\n        echo \"<td>\";\n        Dropdown::showYesNo('is_active', $this->fields[\"is_active\"]);\n        echo \"</td>\";\n        echo \"<td>\" . __(\"Mandatory field\") . \" : </td>\";\n        echo \"<td>\";\n        Dropdown::showYesNo(\"mandatory\", $this->fields[\"mandatory\"]);\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        echo \"<tr>\";\n        echo \"<td>\" . __(\"Read only\", \"fields\") . \" :</td>\";\n        echo \"<td colspan='3'>\";\n        Dropdown::showYesNo(\"is_readonly\", $this->fields[\"is_readonly\"]);\n        echo \"</td>\";\n        echo \"</tr>\";\n\n        $this->showFormButtons($options);\n    }\n\n    public static function showForTabContainer($c_id, $item)\n    {\n        //profile restriction\n        $right = PluginFieldsProfile::getRightOnContainer($_SESSION['glpiactiveprofile']['id'], $c_id);\n        if ($right < READ) {\n            return;\n        }\n        $canedit = $right > READ;\n\n        //get fields for this container\n        $field_obj = new self();\n        $fields = $field_obj->find(['plugin_fields_containers_id' => $c_id, 'is_active' => 1], \"ranking\");\n        echo \"<form method='POST' action='\" . Plugin::getWebDir('fields') . \"/front/container.form.php'>\";\n        echo Html::hidden('plugin_fields_containers_id', ['value' => $c_id]);\n        echo Html::hidden('items_id', ['value' => $item->getID()]);\n        echo Html::hidden('itemtype', ['value' => $item->getType()]);\n        echo \"<table class='tab_cadre_fixe'>\";\n        echo self::prepareHtmlFields($fields, $item, $canedit);\n\n        if ($canedit) {\n            echo \"<tr><td class='tab_bg_2 center' colspan='4'>\";\n            echo \"<input class='btn btn-primary' type='submit' name='update_fields_values' value=\\\"\" .\n            _sx(\"button\", \"Save\") . \"\\\" class='submit'>\";\n            echo \"</td></tr>\";\n        }\n\n        echo \"</table>\";\n        Html::closeForm();\n\n        return true;\n    }\n\n    /**\n     * Display dom container\n     *\n     * @param int         $id       Container's ID\n     * @param CommonDBTM  $item     Item\n     * @param string      $type     Type (either 'dom' or 'domtab'\n     * @param string      $subtype  Requested subtype (used for domtab only)\n     *\n     * @return void\n     */\n    public static function showDomContainer($id, $item, $type = \"dom\", $subtype = \"\")\n    {\n\n        if ($id !== false) {\n            //get fields for this container\n            $field_obj = new self();\n            $fields = $field_obj->find(\n                [\n                    'plugin_fields_containers_id' => $id,\n                    'is_active' => 1,\n                ],\n                \"ranking\"\n            );\n        } else {\n            $fields = [];\n        }\n\n        echo Html::hidden('_plugin_fields_type', ['value' => $type]);\n        echo Html::hidden('_plugin_fields_subtype', ['value' => $subtype]);\n        echo self::prepareHtmlFields($fields, $item);\n    }\n\n    /**\n     * Display fields in any existing tab\n     *\n     * @param array $params [item, options]\n     *\n     * @return void\n     */\n    public static function showForTab($params)\n    {\n        $item = $params['item'];\n\n        $functions = array_column(debug_backtrace(), 'function');\n\n        $subtype = isset($_SESSION['glpi_tabs'][strtolower($item::getType())]) ? $_SESSION['glpi_tabs'][strtolower($item::getType())] : \"\";\n        $type = substr($subtype, -strlen('$main')) === '$main'\n            || in_array('showForm', $functions)\n            || in_array('showPrimaryForm', $functions)\n            || in_array('showFormHelpdesk', $functions)\n                ? 'dom'\n                : 'domtab';\n        if ($subtype == -1) {\n            $type = 'dom';\n        }\n        // if we are in 'dom' or 'tab' type, no need for subtype ('domtab' specific)\n        if ($type != 'domtab') {\n            $subtype = \"\";\n        }\n\n        //find container (if not exist, do nothing)\n        if (isset($_REQUEST['c_id'])) {\n            $c_id = $_REQUEST['c_id'];\n        } else if (!$c_id = PluginFieldsContainer::findContainer(get_Class($item), $type, $subtype)) {\n            return false;\n        }\n\n        $right = PluginFieldsProfile::getRightOnContainer($_SESSION['glpiactiveprofile']['id'], $c_id);\n        if ($right < READ) {\n            return;\n        }\n\n        Html::requireJs('tinymce');\n\n        //need to check if container is usable on this object entity\n        $loc_c = new PluginFieldsContainer();\n        $loc_c->getFromDB($c_id);\n        $entities = [$loc_c->fields['entities_id']];\n        if ($loc_c->fields['is_recursive']) {\n            $entities = getSonsOf(getTableForItemType('Entity'), $loc_c->fields['entities_id']);\n        }\n\n        if ($item->isEntityAssign()) {\n            $current_entity = $item->getEntityID();\n            if (!in_array($current_entity, $entities)) {\n                return false;\n            }\n        }\n\n        //parse REQUEST_URI\n        if (!isset($_SERVER['REQUEST_URI'])) {\n            return false;\n        }\n        $current_url = $_SERVER['REQUEST_URI'];\n        if (\n            strpos($current_url, \".form.php\") === false\n            && strpos($current_url, \".injector.php\") === false\n            && strpos($current_url, \".public.php\") === false\n        ) {\n            return false;\n        }\n\n        //Retrieve dom container\n        $itemtypes = PluginFieldsContainer::getUsedItemtypes($type, true);\n\n        //if no dom containers defined for this itemtype, do nothing (in_array case insensitive)\n        if (!in_array(strtolower($item::getType()), array_map('strtolower', $itemtypes))) {\n            return false;\n        }\n\n        $html_id = 'plugin_fields_container_' . mt_rand();\n        echo \"<div id='{$html_id}'>\";\n        $display_condition = new PluginFieldsContainerDisplayCondition();\n        if ($display_condition->computeDisplayContainer($item, $c_id)) {\n            self::showDomContainer(\n                $c_id,\n                $item,\n                $type,\n                $subtype\n            );\n        }\n        echo \"</div>\";\n\n        //JS to trigger any change and check if container need to be display or not\n        $ajax_url   = Plugin::getWebDir('fields') . '/ajax/container.php';\n        $items_id = !$item->isNewItem() ? $item->getID() : 0;\n        echo Html::scriptBlock(<<<JAVASCRIPT\n            function refreshContainer() {\n                const data = $('#{$html_id}').closest('form').serializeArray().reduce(\n                    function(obj, item) {\n                        obj[item.name] = item.value;\n                        return obj;\n                    },\n                    {}\n                );\n\n                $.ajax(\n                    {\n                        url: '{$ajax_url}',\n                        type: 'GET',\n                        data: {\n                            action:   'get_fields_html',\n                            id:       {$c_id},\n                            itemtype: '{$item::getType()}',\n                            items_id: {$items_id},\n                            type:     '{$type}',\n                            subtype:  '{$subtype}',\n                            input:    data\n                        },\n                        success: function(data) {\n                            // Close open select2 dropdown that will be replaced\n                            $('#{$html_id}').find('.select2-hidden-accessible').select2('close');\n                            // Refresh fields HTML\n                            $('#{$html_id}').html(data);\n                        }\n                    }\n                );\n            }\n            $(\n                function () {\n                    const form = $('#{$html_id}').closest('form');\n                    form.on(\n                        'change',\n                        'input, select, textarea',\n                        function(evt) {\n                            if (evt.target.name == \"itilcategories_id\") {\n                                // Do not refresh tab container when form is reloaded\n                                // to prevent issues diues to duplicated calls\n                                return;\n                            }\n                            if ($(evt.target).closest('#{$html_id}').length > 0) {\n                                return; // Do nothing if element is inside fields container\n                            }\n                            refreshContainer();\n                        }\n                    );\n\n                    var refresh_timeout = null;\n                    form.find('textarea').each(\n                        function () {\n                            const editor = tinymce.get(this.id);\n                            if (editor !== null) {\n                                editor.on(\n                                    'change',\n                                    function(evt) {\n                                        if ($(evt.target.targetElm).closest('#{$html_id}').length > 0) {\n                                            return; // Do nothing if element is inside fields container\n                                        }\n\n                                        if (refresh_timeout !== null) {\n                                            window.clearTimeout(refresh_timeout);\n                                        }\n                                        refresh_timeout = window.setTimeout(refreshContainer, 1000);\n                                    }\n                                );\n                            }\n                        }\n                    );\n                }\n            );\nJAVASCRIPT\n        );\n    }\n\n    public static function prepareHtmlFields(\n        $fields,\n        $item,\n        $canedit = true,\n        $show_table = true,\n        $massiveaction = false\n    ) {\n\n        if (empty($fields)) {\n            return false;\n        }\n\n        //get object associated with this fields\n        $first_field = reset($fields);\n        $container_obj = new PluginFieldsContainer();\n        if (!$container_obj->getFromDB($first_field['plugin_fields_containers_id'])) {\n            return false;\n        }\n\n        // check if current profile can edit fields\n        $right = PluginFieldsProfile::getRightOnContainer($_SESSION['glpiactiveprofile']['id'], $container_obj->getID());\n        if ($right < READ) {\n            return;\n        }\n        $canedit = $right > READ;\n\n        // Fill status overrides if needed\n        if (in_array($item->getType(), PluginFieldsStatusOverride::getStatusItemtypes())) {\n            $status_overrides = PluginFieldsStatusOverride::getOverridesForItem($container_obj->getID(), $item);\n            foreach ($status_overrides as $status_override) {\n                if (isset($fields[$status_override['plugin_fields_fields_id']])) {\n                    $fields[$status_override['plugin_fields_fields_id']]['is_readonly'] = $status_override['is_readonly'];\n                    $fields[$status_override['plugin_fields_fields_id']]['mandatory'] = $status_override['mandatory'];\n                }\n            }\n        }\n\n        $found_v = null;\n        if (!$item->isNewItem()) {\n            //find row for this object with the items_id\n            $classname = PluginFieldsContainer::getClassname($item->getType(), $container_obj->fields['name']);\n            $obj = new $classname();\n            $found_values = $obj->find(\n                [\n                    'plugin_fields_containers_id' => $first_field['plugin_fields_containers_id'],\n                    'items_id' => $item->getID(),\n                ]\n            );\n            $found_v = array_shift($found_values);\n        }\n\n        // test status for \"CommonITILObject\" objects\n        if ($item instanceof CommonITILObject && in_array($item->fields['status'] ?? null, $item->getClosedStatusArray())) {\n            $canedit = false;\n        }\n\n        //show all fields\n        foreach ($fields as &$field) {\n            $field['itemtype'] = self::getType();\n            $field['label'] = PluginFieldsLabelTranslation::getLabelFor($field);\n\n            $field['allowed_values'] = !empty($field['allowed_values']) ? json_decode($field['allowed_values']) : [];\n            if ($field['type'] === 'glpi_item') {\n               // Convert allowed values to [$itemtype_class => $itemtype_name] format\n                $allowed_itemtypes = [];\n                foreach ($field['allowed_values'] as $allowed_itemtype) {\n                    if (is_a($allowed_itemtype, CommonDBTM::class, true)) {\n                        $allowed_itemtypes[$allowed_itemtype] = $allowed_itemtype::getTypeName(Session::getPluralNumber());\n                    }\n                }\n                $field['allowed_values'] = $allowed_itemtypes;\n            }\n\n            //compute classname for 'dropdown-XXXXXX' field\n            $dropdown_matches = [];\n            if (\n                preg_match('/^dropdown-(?<class>.+)$/i', $field['type'], $dropdown_matches)\n                && class_exists($dropdown_matches['class'])\n            ) {\n                $dropdown_class = $dropdown_matches['class'];\n\n                $field['dropdown_class'] = $dropdown_class;\n                $field['dropdown_condition'] = [];\n\n                $object = new $dropdown_class();\n                if ($object->maybeDeleted()) {\n                    $field['dropdown_condition']['is_deleted'] = false;\n                }\n                if ($object->maybeActive()) {\n                    $field['dropdown_condition']['is_active'] = true;\n                }\n            }\n\n            //get value\n            $value = null;\n            if (is_array($found_v)) {\n                if ($field['type'] == \"dropdown\") {\n                    $value = $found_v[\"plugin_fields_\" . $field['name'] . \"dropdowns_id\"];\n                } else if ($field['type'] == \"glpi_item\") {\n                    $itemtype_key = sprintf('itemtype_%s', $field['name']);\n                    $items_id_key = sprintf('items_id_%s', $field['name']);\n                    $value = [\n                        'itemtype' => $found_v[$itemtype_key],\n                        'items_id' => $found_v[$items_id_key],\n                    ];\n                } else {\n                    $value = $found_v[$field['name']] ?? \"\";\n                }\n            }\n\n            if (!$field['is_readonly']) {\n                if ($field['type'] == \"dropdown\") {\n                    $field_name = sprintf('plugin_fields_%sdropdowns_id', $field['name']);\n                    if (isset($_SESSION['plugin']['fields']['values_sent'][$field_name])) {\n                        $value = $_SESSION['plugin']['fields']['values_sent'][$field_name];\n                    } elseif (isset($item->input[$field_name])) {\n                        // find from $item->input due to ajax refresh container\n                        $value = $item->input[$field_name];\n                    }\n                } else {\n                    if (isset($_SESSION['plugin']['fields']['values_sent'][$field['name']])) {\n                        $value = $_SESSION['plugin']['fields']['values_sent'][$field['name']];\n                    } elseif (isset($item->input[$field['name']])) {\n                        // find from $item->input due to ajax refresh container\n                        $value = $item->input[$field['name']];\n                    }\n                }\n            }\n\n            //get default value\n            if ($value === null) {\n                if ($field['type'] === 'dropdown' && $field['default_value'] === '') {\n                    $value = 0;\n                } else if ($field['default_value'] !== \"\") {\n                    $value = $field['default_value'];\n\n                    // shortcut for date/datetime\n                    if (\n                        in_array($field['type'], ['date', 'datetime'])\n                        && $value == 'now'\n                    ) {\n                        $value = $_SESSION[\"glpi_currenttime\"];\n                    }\n                }\n            }\n\n            if ($field['multiple']) {\n                $value = json_decode($value);\n            }\n\n            $field['value'] = $value;\n        }\n\n        $html = TemplateRenderer::getInstance()->render('@fields/fields.html.twig', [\n            'item'           => $item,\n            'fields'         => $fields,\n            'canedit'        => $canedit,\n            'massiveaction'  => $massiveaction,\n            'container'      => $container_obj,\n        ]);\n\n        unset($_SESSION['plugin']['fields']['values_sent']);\n\n        return $html;\n    }\n\n    public static function showSingle($itemtype, $searchOption, $massiveaction = false)\n    {\n        global $DB;\n\n        //clean dropdown [pre/su]fix if exists\n        $cleaned_linkfield = preg_replace(\n            \"/plugin_fields_(.*)dropdowns_id/\",\n            \"$1\",\n            $searchOption['linkfield']\n        );\n\n        //find field\n        $query = \"SELECT fields.plugin_fields_containers_id, fields.is_readonly, fields.multiple, fields.default_value\n                FROM glpi_plugin_fields_fields fields\n                LEFT JOIN glpi_plugin_fields_containers containers\n                  ON containers.id = fields.plugin_fields_containers_id\n                  AND containers.itemtypes LIKE '%$itemtype%'\n               WHERE fields.name = '$cleaned_linkfield'\";\n        $res = $DB->query($query);\n        if ($DB->numrows($res) == 0) {\n            return false;\n        }\n\n        $data = $DB->fetchAssoc($res);\n\n        //display an hidden post field to store container id\n        echo Html::hidden('c_id', ['value' => $data['plugin_fields_containers_id']]);\n\n        //prepare array for function prepareHtmlFields\n        $fields = [[\n            'id'                          => 0,\n            'type'                        => $searchOption['pfields_type'],\n            'plugin_fields_containers_id' => $data['plugin_fields_containers_id'],\n            'name'                        => $cleaned_linkfield,\n            'is_readonly'                 => $data['is_readonly'],\n            'default_value'               => $data['default_value'],\n            'multiple'                    => $data['multiple']\n        ]\n        ];\n\n        //show field\n        $item = new $itemtype();\n        $item->getEmpty();\n\n        echo self::prepareHtmlFields($fields, $item, true, false, $massiveaction);\n\n        return true;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function post_getEmpty()\n    {\n        $this->fields['is_active'] = 1;\n        $this->fields['type']      = 'text';\n    }\n\n    public static function getTypes(bool $flat_list = true)\n    {\n        $common_types = [\n            'header'       => __(\"Header\", \"fields\"),\n            'text'         => __(\"Text (single line)\", \"fields\"),\n            'textarea'     => __(\"Text (multiples lines)\", \"fields\"),\n            'number'       => __(\"Number\", \"fields\"),\n            'url'          => __(\"URL\", \"fields\"),\n            'dropdown'     => __(\"Dropdown\", \"fields\"),\n            'yesno'        => __(\"Yes/No\", \"fields\"),\n            'date'         => __(\"Date\", \"fields\"),\n            'datetime'     => __(\"Date & time\", \"fields\"),\n            'glpi_item'    => __(\"GLPI item\", \"fields\"),\n        ];\n\n        $all_types = [\n            __('Common') => $common_types,\n        ];\n\n        foreach (PluginFieldsToolbox::getGlpiItemtypes() as $section => $itemtypes) {\n            $all_types[$section] = [];\n            foreach ($itemtypes as $itemtype => $itemtype_name) {\n                $all_types[$section]['dropdown-' . $itemtype] = $itemtype_name;\n            }\n        }\n\n        return $flat_list ? array_merge([], ...array_values($all_types)) : $all_types;\n    }\n\n    // phpcs:ignore PSR1.Methods.CamelCapsMethodName\n    public function post_addItem()\n    {\n        $input = $this->fields;\n\n        //dropdowns : create files\n        if ($input['type'] === \"dropdown\") {\n            //search if dropdown already exist in other container\n            $found = $this->find(['id' => ['!=', $input['id']], 'name' => $input['name']]);\n            //for dropdown, if already exist, don't create files\n            if (empty($found)) {\n                PluginFieldsDropdown::create($input);\n            }\n        }\n\n        //Create label translation\n        if (!isset($this->input['clone']) || !$this->input['clone']) {\n            PluginFieldsLabelTranslation::createForItem($this);\n        }\n    }\n\n    public function rawSearchOptions()\n    {\n        $tab = [];\n\n        $tab[] = [\n            'id'            => 2,\n            'table'         => self::getTable(),\n            'field'         => 'label',\n            'name'          => __('Label'),\n            'massiveaction' => false,\n            'autocomplete'  => true,\n        ];\n\n        $tab[] = [\n            'id'            => 3,\n            'table'         => self::getTable(),\n            'field'         => 'default_value',\n            'name'          => __('Default values'),\n            'massiveaction' => false,\n            'autocomplete'  => true,\n        ];\n\n        return $tab;\n    }\n\n    public function prepareInputForClone($input)\n    {\n        if (array_key_exists('allowed_values', $input) && !empty($input['allowed_values'])) {\n            // $input has been transformed with `Toolbox::addslashes_deep()`, and `self::prepareInputForAdd()`\n            // is expecting an array, so it have to be unslashed then json decoded.\n            $input['allowed_values'] = json_decode(Sanitizer::dbUnescape($input['allowed_values']));\n        } else {\n            unset($input['allowed_values']);\n        }\n\n        return $input;\n    }\n\n    public function getCloneRelations(): array\n    {\n        return [\n            PluginFieldsStatusOverride::class,\n            PluginFieldsLabelTranslation::class,\n        ];\n    }\n}\n", "<?php\n\n/**\n * -------------------------------------------------------------------------\n * Fields plugin for GLPI\n * -------------------------------------------------------------------------\n *\n * LICENSE\n *\n * This file is part of Fields.\n *\n * Fields is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Fields is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Fields. If not, see <http://www.gnu.org/licenses/>.\n * -------------------------------------------------------------------------\n * @copyright Copyright (C) 2013-2022 by Fields plugin team.\n * @license   GPLv2 https://www.gnu.org/licenses/gpl-2.0.html\n * @link      https://github.com/pluginsGLPI/fields\n * -------------------------------------------------------------------------\n */\n\nclass PluginFieldsProfile extends CommonDBRelation\n{\n    use Glpi\\Features\\Clonable;\n\n    public static $itemtype_1 = PluginFieldsContainer::class;\n    public static $items_id_1 = 'plugin_fields_containers_id';\n    public static $itemtype_2 = Profile::class;\n    public static $items_id_2 = 'profiles_id';\n\n    /**\n     * Install or update plugin base data.\n     *\n     * @param Migration $migration Migration instance\n     * @param string    $version   Plugin current version\n     *\n     * @return boolean\n     */\n    public static function installBaseData(Migration $migration, $version)\n    {\n        global $DB;\n\n        $default_charset = DBConnection::getDefaultCharset();\n        $default_collation = DBConnection::getDefaultCollation();\n        $default_key_sign = DBConnection::getDefaultPrimaryKeySignOption();\n\n        $table = self::getTable();\n\n        if (!$DB->tableExists($table)) {\n            $migration->displayMessage(sprintf(__(\"Installing %s\"), $table));\n\n            $query = \"CREATE TABLE IF NOT EXISTS `$table` (\n                  `id`                                INT {$default_key_sign} NOT NULL auto_increment,\n                  `profiles_id`                       INT {$default_key_sign} NOT NULL DEFAULT '0',\n                  `plugin_fields_containers_id`       INT {$default_key_sign} NOT NULL DEFAULT '0',\n                  `right`                             CHAR(1)  DEFAULT NULL,\n                  PRIMARY KEY                         (`id`),\n                  KEY `profiles_id`                   (`profiles_id`),\n                  KEY `plugin_fields_containers_id`   (`plugin_fields_containers_id`)\n               ) ENGINE=InnoDB DEFAULT CHARSET={$default_charset} COLLATE={$default_collation} ROW_FORMAT=DYNAMIC;\";\n            $DB->query($query) or die($DB->error());\n        }\n\n        return true;\n    }\n\n    public static function uninstall()\n    {\n        global $DB;\n\n        $DB->query(\"DROP TABLE IF EXISTS `\" . self::getTable() . \"`\");\n\n        return true;\n    }\n\n\n    public function getTabNameForItem(CommonGLPI $item, $withtemplate = 0)\n    {\n        return self::createTabEntry(_n(\"Profile\", \"Profiles\", 2));\n    }\n\n    public static function displayTabContentForItem(CommonGLPI $item, $tabnum = 1, $withtemplate = 0)\n    {\n        $profile = new Profile();\n        $found_profiles = $profile->find();\n\n        $fields_profile = new self();\n        echo \"<form name='form' method='post' action='\" . $fields_profile->getFormURL() . \"'>\";\n        echo \"<div class='spaced' id='tabsbody'>\";\n        echo \"<table class='tab_cadre_fixe'>\";\n\n        echo \"<tr><th colspan='2'>\" . _n(\"Profile\", \"Profiles\", 2) . \"</th></tr>\";\n        foreach ($found_profiles as $profile_item) {\n            //get right for current profile\n            $found = $fields_profile->find([\n                'profiles_id' => $profile_item['id'],\n                'plugin_fields_containers_id' => $item->fields['id']\n            ]);\n            $first_found = array_shift($found);\n\n            //display right\n            echo \"<tr>\";\n            echo \"<td>\" . $profile_item['name'] . \"</td>\";\n            echo \"<td>\";\n            Profile::dropdownRight(\n                \"rights[\" . $profile_item['id'] . \"]\",\n                ['value' => $first_found['right']]\n            );\n            echo \"</td>\";\n            echo \"<tr>\";\n        }\n        echo \"<ul>\";\n        echo \"<tr><td class='tab_bg_2 center' colspan='2'>\";\n        echo \"<input type='hidden' name='plugin_fields_containers_id' value='\" . $item->fields['id'] . \"' />\";\n        echo \"<input type='submit' name='update' value=\\\"\" . _sx(\"button\", \"Save\") . \"\\\" class='submit'>\";\n        echo \"</td>\";\n        echo \"</tr>\";\n        echo \"</table></div>\";\n        Html::closeForm();\n    }\n\n    public static function updateProfile($input)\n    {\n        $fields_profile = new self();\n        foreach ($input['rights'] as $profiles_id => $right) {\n            $found = $fields_profile->find(\n                [\n                    'profiles_id' => $profiles_id,\n                    'plugin_fields_containers_id' => $input['plugin_fields_containers_id']\n                ]\n            );\n            if (count($found) > 0) {\n                 $first_found = array_shift($found);\n\n                 $fields_profile->update([\n                     'id'                          => $first_found['id'],\n                     'profiles_id'                 => $profiles_id,\n                     'plugin_fields_containers_id' => $input['plugin_fields_containers_id'],\n                     'right'                       => $right\n                 ]);\n            } else {\n                $fields_profile->add([\n                    'profiles_id'                 => $profiles_id,\n                    'plugin_fields_containers_id' => $input['plugin_fields_containers_id'],\n                    'right'                       => $right\n                ]);\n            }\n        }\n\n        return true;\n    }\n\n    public static function createForContainer(PluginFieldsContainer $container)\n    {\n        $profile = new Profile();\n        $found_profiles = $profile->find();\n\n        $fields_profile = new self();\n        foreach ($found_profiles as $profile_item) {\n            $fields_profile->add([\n                'profiles_id'                 => $profile_item['id'],\n                'plugin_fields_containers_id' => $container->fields['id'],\n                'right'                       => CREATE\n            ]);\n        }\n        return true;\n    }\n\n    public static function addNewProfile(Profile $profile)\n    {\n        $containers = new PluginFieldsContainer();\n        $found_containers = $containers->find();\n\n        $fields_profile = new self();\n        foreach ($found_containers as $container) {\n            $fields_profile->add([\n                'profiles_id'                 => $profile->fields['id'],\n                'plugin_fields_containers_id' => $container['id']\n            ]);\n        }\n        return true;\n    }\n\n    public static function deleteProfile(Profile $profile)\n    {\n        $fields_profile = new self();\n        $fields_profile->deleteByCriteria(['profiles_id' => $profile->fields['id']]);\n        return true;\n    }\n\n    public static function getRightOnContainer(int $profile_id, int $container_id): int\n    {\n        global $DB;\n\n        $container_profile = $DB->request(\n            [\n                'SELECT'  => ['MAX' => 'right AS right'],\n                'FROM'    => self::getTable(),\n                'WHERE'   => [\n                    'profiles_id' => $profile_id,\n                    'plugin_fields_containers_id' => $container_id,\n                ],\n            ]\n        );\n\n        return (int)$container_profile->current()['right'];\n    }\n}\n"], "filenames": ["front/container.form.php", "inc/container.class.php", "inc/field.class.php", "inc/profile.class.php"], "buggy_code_start_loc": [56, 970, 725, 198], "buggy_code_end_loc": [57, 1556, 1020, 198], "fixing_code_start_loc": [56, 969, 725, 199], "fixing_code_end_loc": [60, 1553, 1013, 217], "type": "CWE-269", "message": "Fields is a GLPI plugin that allows users to add custom fields on GLPI items forms. Prior to versions 1.13.1 and 1.20.4, lack of access control check allows any authenticated user to write data to any fields container, including those to which they have no configured access. Versions 1.13.1 and 1.20.4 contain a patch for this issue.", "other": {"cve": {"id": "CVE-2023-28855", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-05T18:15:08.583", "lastModified": "2023-04-12T16:38:39.363", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Fields is a GLPI plugin that allows users to add custom fields on GLPI items forms. Prior to versions 1.13.1 and 1.20.4, lack of access control check allows any authenticated user to write data to any fields container, including those to which they have no configured access. Versions 1.13.1 and 1.20.4 contain a patch for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teclib-edition:fields:*:*:*:*:*:glpi:*:*", "versionEndExcluding": "1.13.1", "matchCriteriaId": "89C87DD6-157A-4B3B-8C3D-F6AFC6FB2C3E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:teclib-edition:fields:*:*:*:*:*:glpi:*:*", "versionStartIncluding": "1.20.0", "versionEndExcluding": "1.20.4", "matchCriteriaId": "FE8E4B2B-DB2A-4D0F-96AA-651FB7BEE330"}]}]}], "references": [{"url": "https://github.com/pluginsGLPI/fields/commit/784260be7db185bb1e7d66b299997238c4c0205d", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pluginsGLPI/fields/releases/tag/1.13.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/pluginsGLPI/fields/releases/tag/1.20.4", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/pluginsGLPI/fields/security/advisories/GHSA-52vv-hm4x-8584", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/pluginsGLPI/fields/commit/784260be7db185bb1e7d66b299997238c4c0205d"}}