{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                              CCC  U   U  TTTTT                              %\n%                             C     U   U    T                                %\n%                             C     U   U    T                                %\n%                             C     U   U    T                                %\n%                              CCC   UUU     T                                %\n%                                                                             %\n%                                                                             %\n%                         Read DR Halo Image Format                           %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                 June 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Permission is hereby granted, free of charge, to any person obtaining a    %\n%  copy of this software and associated documentation files (\"ImageMagick\"),  %\n%  to deal in ImageMagick without restriction, including without limitation   %\n%  the rights to use, copy, modify, merge, publish, distribute, sublicense,   %\n%  and/or sell copies of ImageMagick, and to permit persons to whom the       %\n%  ImageMagick is furnished to do so, subject to the following conditions:    %\n%                                                                             %\n%  The above copyright notice and this permission notice shall be included in %\n%  all copies or substantial portions of ImageMagick.                         %\n%                                                                             %\n%  The software is provided \"as is\", without warranty of any kind, express or %\n%  implied, including but not limited to the warranties of merchantability,   %\n%  fitness for a particular purpose and noninfringement.  In no event shall   %\n%  ImageMagick Studio be liable for any claim, damages or other liability,    %\n%  whether in an action of contract, tort or otherwise, arising from, out of  %\n%  or in connection with ImageMagick or the use or other dealings in          %\n%  ImageMagick.                                                               %\n%                                                                             %\n%  Except as contained in this notice, the name of the ImageMagick Studio     %\n%  shall not be used in advertising or otherwise to promote the sale, use or  %\n%  other dealings in ImageMagick without prior written authorization from the %\n%  ImageMagick Studio.                                                        %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n\f\ntypedef struct\n{\n  unsigned Width;\n  unsigned Height;\n  unsigned Reserved;\n} CUTHeader;\n\ntypedef struct\n{\n  char FileId[2];\n  unsigned Version;\n  unsigned Size;\n  char FileType;\n  char SubType;\n  unsigned BoardID;\n  unsigned GraphicsMode;\n  unsigned MaxIndex;\n  unsigned MaxRed;\n  unsigned MaxGreen;\n  unsigned MaxBlue;\n  char PaletteId[20];\n} CUTPalHeader;\n\n\f\nstatic MagickBooleanType InsertRow(Image *image,ssize_t bpp,unsigned char *p,\n  ssize_t y,ExceptionInfo *exception)\n{\n  int\n    bit;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return(MagickFalse);\n  switch (bpp)\n    {\n    case 1:  /* Convert bitmap scanline. */\n      {\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n            {\n              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n              SetPixelIndex(image,index,q);\n              if (index < image->colors)\n                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        break;\n      }\n    case 2:  /* Convert PseudoColor scanline. */\n      {\n        for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n        {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            p++;\n        }\n       if ((image->columns % 4) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            if ((image->columns % 4) > 1)\n              {\n                index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n                SetPixelIndex(image,index,q);\n                if (index < image->colors)\n                  SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n                q+=GetPixelChannels(image);\n                if ((image->columns % 4) > 2)\n                  {\n                    index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,\n                      exception);\n                    SetPixelIndex(image,index,q);\n                    if (index < image->colors)\n                      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n                        index,q);\n                    q+=GetPixelChannels(image);\n                  }\n              }\n            p++;\n          }\n        break;\n      }\n\n    case 4:  /* Convert PseudoColor scanline. */\n      {\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        break;\n      }\n    case 8: /* Convert PseudoColor scanline. */\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,*p,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n      }\n      break;\n\n    case 24:     /*  Convert DirectColor scanline.  */\n      for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n          q+=GetPixelChannels(image);\n        }\n      break;\n    }\n  if (!SyncAuthenticPixels(image,exception))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\n/*\n   Compute the number of colors in Grayed R[i]=G[i]=B[i] image\n*/\nstatic int GetCutColors(Image *image,ExceptionInfo *exception)\n{\n  Quantum\n    intensity,\n    scale_intensity;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    x,\n    y;\n\n  intensity=0;\n  scale_intensity=ScaleCharToQuantum(16);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (intensity < GetPixelRed(image,q))\n        intensity=GetPixelRed(image,q);\n      if (intensity >= scale_intensity)\n        return(255);\n      q+=GetPixelChannels(image);\n    }\n  }\n  if (intensity < ScaleCharToQuantum(2))\n    return(2);\n  if (intensity < ScaleCharToQuantum(16))\n    return(16);\n  return((int) intensity);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d C U T I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadCUTImage() reads an CUT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadCUTImage method is:\n%\n%      Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowCUTReaderException(severity,tag) \\\n{ \\\n  if (palette != NULL) \\\n    palette=DestroyImage(palette); \\\n  if (clone_info != NULL) \\\n    clone_info=DestroyImageInfo(clone_info); \\\n  ThrowReaderException(severity,tag); \\\n}\n\n  Image *image,*palette;\n  ImageInfo *clone_info;\n  MagickBooleanType status;\n\n  MagickOffsetType\n    offset;\n\n  size_t EncodedByte;\n  unsigned char RunCount,RunValue,RunCountMasked;\n  CUTHeader  Header;\n  CUTPalHeader PalHeader;\n  ssize_t depth;\n  ssize_t i,j;\n  ssize_t ldblk;\n  unsigned char *BImgBuff=NULL,*ptrB;\n  register Quantum *q;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CUT image.\n  */\n  palette=NULL;\n  clone_info=NULL;\n  Header.Width=ReadBlobLSBShort(image);\n  Header.Height=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.Width==0 || Header.Height==0 || Header.Reserved!=0)\n    CUT_KO:  ThrowCUTReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*---This code checks first line of image---*/\n  EncodedByte=ReadBlobLSBShort(image);\n  RunCount=(unsigned char) ReadBlobByte(image);\n  RunCountMasked=RunCount & 0x7F;\n  ldblk=0;\n  while((int) RunCountMasked!=0)  /*end of line?*/\n    {\n      i=1;\n      if((int) RunCount<0x80) i=(ssize_t) RunCountMasked;\n      offset=SeekBlob(image,TellBlob(image)+i,SEEK_SET);\n      if (offset < 0)\n        ThrowCUTReaderException(CorruptImageError,\"ImproperImageHeader\");\n      if(EOFBlob(image) != MagickFalse) goto CUT_KO;  /*wrong data*/\n      EncodedByte-=i+1;\n      ldblk+=(ssize_t) RunCountMasked;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      if(EOFBlob(image) != MagickFalse)  goto CUT_KO;  /*wrong data: unexpected eof in line*/\n      RunCountMasked=RunCount & 0x7F;\n    }\n  if(EncodedByte!=1) goto CUT_KO;  /*wrong data: size incorrect*/\n  i=0;        /*guess a number of bit planes*/\n  if(ldblk==(int) Header.Width)   i=8;\n  if(2*ldblk==(int) Header.Width) i=4;\n  if(8*ldblk==(int) Header.Width) i=1;\n  if(i==0) goto CUT_KO;    /*wrong data: incorrect bit planes*/\n  depth=i;\n\n  image->columns=Header.Width;\n  image->rows=Header.Height;\n  image->depth=8;\n  image->colors=(size_t) (GetQuantumRange(1UL*i)+1);\n\n  if (image_info->ping != MagickFalse) goto Finish;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  /* ----- Do something with palette ----- */\n  if ((clone_info=CloneImageInfo(image_info)) == NULL) goto NoPalette;\n\n\n  i=(ssize_t) strlen(clone_info->filename);\n  j=i;\n  while(--i>0)\n    {\n      if(clone_info->filename[i]=='.')\n        {\n          break;\n        }\n      if(clone_info->filename[i]=='/' || clone_info->filename[i]=='\\\\' ||\n         clone_info->filename[i]==':' )\n        {\n          i=j;\n          break;\n        }\n    }\n\n  (void) CopyMagickString(clone_info->filename+i,\".PAL\",(size_t)\n    (MagickPathExtent-i));\n  if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n    {\n      (void) CopyMagickString(clone_info->filename+i,\".pal\",(size_t)\n        (MagickPathExtent-i));\n      if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n        {\n          clone_info->filename[i]='\\0';\n          if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n            {\n              clone_info=DestroyImageInfo(clone_info);\n              clone_info=NULL;\n              goto NoPalette;\n            }\n        }\n    }\n\n  if( (palette=AcquireImage(clone_info,exception))==NULL ) goto NoPalette;\n  status=OpenBlob(clone_info,palette,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n    ErasePalette:\n      palette=DestroyImage(palette);\n      palette=NULL;\n      goto NoPalette;\n    }\n\n\n  if(palette!=NULL)\n    {\n      (void) ReadBlob(palette,2,(unsigned char *) PalHeader.FileId);\n      if(strncmp(PalHeader.FileId,\"AH\",2) != 0) goto ErasePalette;\n      PalHeader.Version=ReadBlobLSBShort(palette);\n      PalHeader.Size=ReadBlobLSBShort(palette);\n      PalHeader.FileType=(char) ReadBlobByte(palette);\n      PalHeader.SubType=(char) ReadBlobByte(palette);\n      PalHeader.BoardID=ReadBlobLSBShort(palette);\n      PalHeader.GraphicsMode=ReadBlobLSBShort(palette);\n      PalHeader.MaxIndex=ReadBlobLSBShort(palette);\n      PalHeader.MaxRed=ReadBlobLSBShort(palette);\n      PalHeader.MaxGreen=ReadBlobLSBShort(palette);\n      PalHeader.MaxBlue=ReadBlobLSBShort(palette);\n      (void) ReadBlob(palette,20,(unsigned char *) PalHeader.PaletteId);\n      if (EOFBlob(image))\n        ThrowCUTReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n\n      if(PalHeader.MaxIndex<1) goto ErasePalette;\n      image->colors=PalHeader.MaxIndex+1;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) goto NoMemory;\n\n      if(PalHeader.MaxRed==0) PalHeader.MaxRed=(unsigned int) QuantumRange;  /*avoid division by 0*/\n      if(PalHeader.MaxGreen==0) PalHeader.MaxGreen=(unsigned int) QuantumRange;\n      if(PalHeader.MaxBlue==0) PalHeader.MaxBlue=(unsigned int) QuantumRange;\n\n      for(i=0;i<=(int) PalHeader.MaxIndex;i++)\n        {      /*this may be wrong- I don't know why is palette such strange*/\n          j=(ssize_t) TellBlob(palette);\n          if((j % 512)>512-6)\n            {\n              j=((j / 512)+1)*512;\n              offset=SeekBlob(palette,j,SEEK_SET);\n              if (offset < 0)\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          image->colormap[i].red=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxRed)\n            {\n              image->colormap[i].red=ClampToQuantum(((double)\n                image->colormap[i].red*QuantumRange+(PalHeader.MaxRed>>1))/\n                PalHeader.MaxRed);\n            }\n          image->colormap[i].green=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxGreen)\n            {\n              image->colormap[i].green=ClampToQuantum\n                (((double) image->colormap[i].green*QuantumRange+(PalHeader.MaxGreen>>1))/PalHeader.MaxGreen);\n            }\n          image->colormap[i].blue=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxBlue)\n            {\n              image->colormap[i].blue=ClampToQuantum\n                (((double)image->colormap[i].blue*QuantumRange+(PalHeader.MaxBlue>>1))/PalHeader.MaxBlue);\n            }\n\n        }\n      if (EOFBlob(image))\n        ThrowCUTReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n\n\n\n NoPalette:\n  if(palette==NULL)\n    {\n\n      image->colors=256;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        {\n        NoMemory:\n          ThrowCUTReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n\n      for (i=0; i < (ssize_t)image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n        }\n    }\n\n\n  /* ----- Load RLE compressed raster ----- */\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    sizeof(*BImgBuff));  /*Ldblk was set in the check phase*/\n  if(BImgBuff==NULL) goto NoMemory;\n\n  offset=SeekBlob(image,6 /*sizeof(Header)*/,SEEK_SET);\n  if (offset < 0)\n    {\n      if (palette != NULL)\n        palette=DestroyImage(palette);\n      if (clone_info != NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  for (i=0; i < (int) Header.Height; i++)\n  {\n      EncodedByte=ReadBlobLSBShort(image);\n\n      ptrB=BImgBuff;\n      j=ldblk;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      RunCountMasked=RunCount & 0x7F;\n\n      while ((int) RunCountMasked != 0)\n      {\n          if((ssize_t) RunCountMasked>j)\n            {    /*Wrong Data*/\n              RunCountMasked=(unsigned char) j;\n              if(j==0)\n                {\n                  break;\n                }\n            }\n\n          if((int) RunCount>0x80)\n            {\n              RunValue=(unsigned char) ReadBlobByte(image);\n              (void) memset(ptrB,(int) RunValue,(size_t) RunCountMasked);\n            }\n          else {\n            (void) ReadBlob(image,(size_t) RunCountMasked,ptrB);\n          }\n\n          ptrB+=(int) RunCountMasked;\n          j-=(int) RunCountMasked;\n\n          if (EOFBlob(image) != MagickFalse) goto Finish;  /* wrong data: unexpected eof in line */\n          RunCount=(unsigned char) ReadBlobByte(image);\n          RunCountMasked=RunCount & 0x7F;\n        }\n\n      InsertRow(image,depth,BImgBuff,i,exception);\n    }\n  (void) SyncImage(image,exception);\n\n\n  /*detect monochrome image*/\n\n  if(palette==NULL)\n    {    /*attempt to detect binary (black&white) images*/\n      if ((image->storage_class == PseudoClass) &&\n          (SetImageGray(image,exception) != MagickFalse))\n        {\n          if(GetCutColors(image,exception)==2)\n            {\n              for (i=0; i < (ssize_t)image->colors; i++)\n                {\n                  register Quantum\n                    sample;\n                  sample=ScaleCharToQuantum((unsigned char) i);\n                  if(image->colormap[i].red!=sample) goto Finish;\n                  if(image->colormap[i].green!=sample) goto Finish;\n                  if(image->colormap[i].blue!=sample) goto Finish;\n                }\n\n              image->colormap[1].red=image->colormap[1].green=\n                image->colormap[1].blue=QuantumRange;\n              for (i=0; i < (ssize_t)image->rows; i++)\n                {\n                  q=QueueAuthenticPixels(image,0,i,image->columns,1,exception);\n                  if (q == (Quantum *) NULL)\n                    break;\n                  for (j=0; j < (ssize_t)image->columns; j++)\n                    {\n                      if (GetPixelRed(image,q) == ScaleCharToQuantum(1))\n                        {\n                          SetPixelRed(image,QuantumRange,q);\n                          SetPixelGreen(image,QuantumRange,q);\n                          SetPixelBlue(image,QuantumRange,q);\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse) goto Finish;\n                }\n            }\n        }\n    }\n\n Finish:\n  if (BImgBuff != NULL)\n    BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  if (palette != NULL)\n    palette=DestroyImage(palette);\n  if (clone_info != NULL)\n    clone_info=DestroyImageInfo(clone_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r C U T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterCUTImage() adds attributes for the CUT image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterCUTImage method is:\n%\n%      size_t RegisterCUTImage(void)\n%\n*/\nModuleExport size_t RegisterCUTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"CUT\",\"CUT\",\"DR Halo\");\n  entry->decoder=(DecodeImageHandler *) ReadCUTImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r C U T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterCUTImage() removes format registrations made by the\n%  CUT module from the list of supported formats.\n%\n%  The format of the UnregisterCUTImage method is:\n%\n%      UnregisterCUTImage(void)\n%\n*/\nModuleExport void UnregisterCUTImage(void)\n{\n  (void) UnregisterMagickInfo(\"CUT\");\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                              CCC  U   U  TTTTT                              %\n%                             C     U   U    T                                %\n%                             C     U   U    T                                %\n%                             C     U   U    T                                %\n%                              CCC   UUU     T                                %\n%                                                                             %\n%                                                                             %\n%                         Read DR Halo Image Format                           %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                 June 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Permission is hereby granted, free of charge, to any person obtaining a    %\n%  copy of this software and associated documentation files (\"ImageMagick\"),  %\n%  to deal in ImageMagick without restriction, including without limitation   %\n%  the rights to use, copy, modify, merge, publish, distribute, sublicense,   %\n%  and/or sell copies of ImageMagick, and to permit persons to whom the       %\n%  ImageMagick is furnished to do so, subject to the following conditions:    %\n%                                                                             %\n%  The above copyright notice and this permission notice shall be included in %\n%  all copies or substantial portions of ImageMagick.                         %\n%                                                                             %\n%  The software is provided \"as is\", without warranty of any kind, express or %\n%  implied, including but not limited to the warranties of merchantability,   %\n%  fitness for a particular purpose and noninfringement.  In no event shall   %\n%  ImageMagick Studio be liable for any claim, damages or other liability,    %\n%  whether in an action of contract, tort or otherwise, arising from, out of  %\n%  or in connection with ImageMagick or the use or other dealings in          %\n%  ImageMagick.                                                               %\n%                                                                             %\n%  Except as contained in this notice, the name of the ImageMagick Studio     %\n%  shall not be used in advertising or otherwise to promote the sale, use or  %\n%  other dealings in ImageMagick without prior written authorization from the %\n%  ImageMagick Studio.                                                        %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n\f\ntypedef struct\n{\n  unsigned Width;\n  unsigned Height;\n  unsigned Reserved;\n} CUTHeader;\n\ntypedef struct\n{\n  char FileId[2];\n  unsigned Version;\n  unsigned Size;\n  char FileType;\n  char SubType;\n  unsigned BoardID;\n  unsigned GraphicsMode;\n  unsigned MaxIndex;\n  unsigned MaxRed;\n  unsigned MaxGreen;\n  unsigned MaxBlue;\n  char PaletteId[20];\n} CUTPalHeader;\n\n\f\nstatic MagickBooleanType InsertRow(Image *image,ssize_t bpp,unsigned char *p,\n  ssize_t y,ExceptionInfo *exception)\n{\n  int\n    bit;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return(MagickFalse);\n  switch (bpp)\n    {\n    case 1:  /* Convert bitmap scanline. */\n      {\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n            {\n              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n              SetPixelIndex(image,index,q);\n              if (index < image->colors)\n                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        break;\n      }\n    case 2:  /* Convert PseudoColor scanline. */\n      {\n        for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n        {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            p++;\n        }\n       if ((image->columns % 4) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            if ((image->columns % 4) > 1)\n              {\n                index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n                SetPixelIndex(image,index,q);\n                if (index < image->colors)\n                  SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n                q+=GetPixelChannels(image);\n                if ((image->columns % 4) > 2)\n                  {\n                    index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,\n                      exception);\n                    SetPixelIndex(image,index,q);\n                    if (index < image->colors)\n                      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n                        index,q);\n                    q+=GetPixelChannels(image);\n                  }\n              }\n            p++;\n          }\n        break;\n      }\n\n    case 4:  /* Convert PseudoColor scanline. */\n      {\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        break;\n      }\n    case 8: /* Convert PseudoColor scanline. */\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,*p,exception);\n            SetPixelIndex(image,index,q);\n            if (index < image->colors)\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n      }\n      break;\n\n    case 24:     /*  Convert DirectColor scanline.  */\n      for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n          q+=GetPixelChannels(image);\n        }\n      break;\n    }\n  if (!SyncAuthenticPixels(image,exception))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\n/*\n   Compute the number of colors in Grayed R[i]=G[i]=B[i] image\n*/\nstatic int GetCutColors(Image *image,ExceptionInfo *exception)\n{\n  Quantum\n    intensity,\n    scale_intensity;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    x,\n    y;\n\n  intensity=0;\n  scale_intensity=ScaleCharToQuantum(16);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (intensity < GetPixelRed(image,q))\n        intensity=GetPixelRed(image,q);\n      if (intensity >= scale_intensity)\n        return(255);\n      q+=GetPixelChannels(image);\n    }\n  }\n  if (intensity < ScaleCharToQuantum(2))\n    return(2);\n  if (intensity < ScaleCharToQuantum(16))\n    return(16);\n  return((int) intensity);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d C U T I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadCUTImage() reads an CUT X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadCUTImage method is:\n%\n%      Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowCUTReaderException(severity,tag) \\\n{ \\\n  if (palette != NULL) \\\n    palette=DestroyImage(palette); \\\n  if (clone_info != NULL) \\\n    clone_info=DestroyImageInfo(clone_info); \\\n  ThrowReaderException(severity,tag); \\\n}\n\n  Image *image,*palette;\n  ImageInfo *clone_info;\n  MagickBooleanType status;\n\n  MagickOffsetType\n    offset;\n\n  size_t EncodedByte;\n  unsigned char RunCount,RunValue,RunCountMasked;\n  CUTHeader  Header;\n  CUTPalHeader PalHeader;\n  ssize_t depth;\n  ssize_t i,j;\n  ssize_t ldblk;\n  unsigned char *BImgBuff=NULL,*ptrB;\n  register Quantum *q;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CUT image.\n  */\n  palette=NULL;\n  clone_info=NULL;\n  Header.Width=ReadBlobLSBShort(image);\n  Header.Height=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.Width==0 || Header.Height==0 || Header.Reserved!=0)\n    CUT_KO:  ThrowCUTReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  /*---This code checks first line of image---*/\n  EncodedByte=ReadBlobLSBShort(image);\n  RunCount=(unsigned char) ReadBlobByte(image);\n  RunCountMasked=RunCount & 0x7F;\n  ldblk=0;\n  while((int) RunCountMasked!=0)  /*end of line?*/\n    {\n      i=1;\n      if((int) RunCount<0x80) i=(ssize_t) RunCountMasked;\n      offset=SeekBlob(image,TellBlob(image)+i,SEEK_SET);\n      if (offset < 0)\n        ThrowCUTReaderException(CorruptImageError,\"ImproperImageHeader\");\n      if(EOFBlob(image) != MagickFalse) goto CUT_KO;  /*wrong data*/\n      EncodedByte-=i+1;\n      ldblk+=(ssize_t) RunCountMasked;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      if(EOFBlob(image) != MagickFalse)  goto CUT_KO;  /*wrong data: unexpected eof in line*/\n      RunCountMasked=RunCount & 0x7F;\n    }\n  if(EncodedByte!=1) goto CUT_KO;  /*wrong data: size incorrect*/\n  i=0;        /*guess a number of bit planes*/\n  if(ldblk==(int) Header.Width)   i=8;\n  if(2*ldblk==(int) Header.Width) i=4;\n  if(8*ldblk==(int) Header.Width) i=1;\n  if(i==0) goto CUT_KO;    /*wrong data: incorrect bit planes*/\n  depth=i;\n\n  image->columns=Header.Width;\n  image->rows=Header.Height;\n  image->depth=8;\n  image->colors=(size_t) (GetQuantumRange(1UL*i)+1);\n\n  if (image_info->ping != MagickFalse) goto Finish;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  /* ----- Do something with palette ----- */\n  if ((clone_info=CloneImageInfo(image_info)) == NULL) goto NoPalette;\n\n\n  i=(ssize_t) strlen(clone_info->filename);\n  j=i;\n  while(--i>0)\n    {\n      if(clone_info->filename[i]=='.')\n        {\n          break;\n        }\n      if(clone_info->filename[i]=='/' || clone_info->filename[i]=='\\\\' ||\n         clone_info->filename[i]==':' )\n        {\n          i=j;\n          break;\n        }\n    }\n\n  (void) CopyMagickString(clone_info->filename+i,\".PAL\",(size_t)\n    (MagickPathExtent-i));\n  if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n    {\n      (void) CopyMagickString(clone_info->filename+i,\".pal\",(size_t)\n        (MagickPathExtent-i));\n      if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n        {\n          clone_info->filename[i]='\\0';\n          if((clone_info->file=fopen_utf8(clone_info->filename,\"rb\"))==NULL)\n            {\n              clone_info=DestroyImageInfo(clone_info);\n              clone_info=NULL;\n              goto NoPalette;\n            }\n        }\n    }\n\n  if( (palette=AcquireImage(clone_info,exception))==NULL ) goto NoPalette;\n  status=OpenBlob(clone_info,palette,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n    ErasePalette:\n      palette=DestroyImage(palette);\n      palette=NULL;\n      goto NoPalette;\n    }\n\n\n  if(palette!=NULL)\n    {\n      (void) ReadBlob(palette,2,(unsigned char *) PalHeader.FileId);\n      if(strncmp(PalHeader.FileId,\"AH\",2) != 0) goto ErasePalette;\n      PalHeader.Version=ReadBlobLSBShort(palette);\n      PalHeader.Size=ReadBlobLSBShort(palette);\n      PalHeader.FileType=(char) ReadBlobByte(palette);\n      PalHeader.SubType=(char) ReadBlobByte(palette);\n      PalHeader.BoardID=ReadBlobLSBShort(palette);\n      PalHeader.GraphicsMode=ReadBlobLSBShort(palette);\n      PalHeader.MaxIndex=ReadBlobLSBShort(palette);\n      PalHeader.MaxRed=ReadBlobLSBShort(palette);\n      PalHeader.MaxGreen=ReadBlobLSBShort(palette);\n      PalHeader.MaxBlue=ReadBlobLSBShort(palette);\n      (void) ReadBlob(palette,20,(unsigned char *) PalHeader.PaletteId);\n      if (EOFBlob(image))\n        ThrowCUTReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n\n      if(PalHeader.MaxIndex<1) goto ErasePalette;\n      image->colors=PalHeader.MaxIndex+1;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) goto NoMemory;\n\n      if(PalHeader.MaxRed==0) PalHeader.MaxRed=(unsigned int) QuantumRange;  /*avoid division by 0*/\n      if(PalHeader.MaxGreen==0) PalHeader.MaxGreen=(unsigned int) QuantumRange;\n      if(PalHeader.MaxBlue==0) PalHeader.MaxBlue=(unsigned int) QuantumRange;\n\n      for(i=0;i<=(int) PalHeader.MaxIndex;i++)\n        {      /*this may be wrong- I don't know why is palette such strange*/\n          j=(ssize_t) TellBlob(palette);\n          if((j % 512)>512-6)\n            {\n              j=((j / 512)+1)*512;\n              offset=SeekBlob(palette,j,SEEK_SET);\n              if (offset < 0)\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            }\n          image->colormap[i].red=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxRed)\n            {\n              image->colormap[i].red=ClampToQuantum(((double)\n                image->colormap[i].red*QuantumRange+(PalHeader.MaxRed>>1))/\n                PalHeader.MaxRed);\n            }\n          image->colormap[i].green=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxGreen)\n            {\n              image->colormap[i].green=ClampToQuantum\n                (((double) image->colormap[i].green*QuantumRange+(PalHeader.MaxGreen>>1))/PalHeader.MaxGreen);\n            }\n          image->colormap[i].blue=(Quantum) ReadBlobLSBShort(palette);\n          if (QuantumRange != (Quantum) PalHeader.MaxBlue)\n            {\n              image->colormap[i].blue=ClampToQuantum\n                (((double)image->colormap[i].blue*QuantumRange+(PalHeader.MaxBlue>>1))/PalHeader.MaxBlue);\n            }\n\n        }\n      if (EOFBlob(image))\n        ThrowCUTReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n\n\n\n NoPalette:\n  if(palette==NULL)\n    {\n\n      image->colors=256;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        {\n        NoMemory:\n          ThrowCUTReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n\n      for (i=0; i < (ssize_t)image->colors; i++)\n        {\n          image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);\n          image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);\n        }\n    }\n\n\n  /* ----- Load RLE compressed raster ----- */\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    sizeof(*BImgBuff));  /*Ldblk was set in the check phase*/\n  if(BImgBuff==NULL) goto NoMemory;\n  (void) memset(BImgBuff,0,(size_t) ldblk*sizeof(*BImgBuff));\n\n  offset=SeekBlob(image,6 /*sizeof(Header)*/,SEEK_SET);\n  if (offset < 0)\n    {\n      if (palette != NULL)\n        palette=DestroyImage(palette);\n      if (clone_info != NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  for (i=0; i < (int) Header.Height; i++)\n  {\n      EncodedByte=ReadBlobLSBShort(image);\n\n      ptrB=BImgBuff;\n      j=ldblk;\n\n      RunCount=(unsigned char) ReadBlobByte(image);\n      RunCountMasked=RunCount & 0x7F;\n\n      while ((int) RunCountMasked != 0)\n      {\n          if((ssize_t) RunCountMasked>j)\n            {    /*Wrong Data*/\n              RunCountMasked=(unsigned char) j;\n              if(j==0)\n                {\n                  break;\n                }\n            }\n\n          if((int) RunCount>0x80)\n            {\n              RunValue=(unsigned char) ReadBlobByte(image);\n              (void) memset(ptrB,(int) RunValue,(size_t) RunCountMasked);\n            }\n          else {\n            (void) ReadBlob(image,(size_t) RunCountMasked,ptrB);\n          }\n\n          ptrB+=(int) RunCountMasked;\n          j-=(int) RunCountMasked;\n\n          if (EOFBlob(image) != MagickFalse) goto Finish;  /* wrong data: unexpected eof in line */\n          RunCount=(unsigned char) ReadBlobByte(image);\n          RunCountMasked=RunCount & 0x7F;\n        }\n\n      InsertRow(image,depth,BImgBuff,i,exception);\n    }\n  (void) SyncImage(image,exception);\n\n\n  /*detect monochrome image*/\n\n  if(palette==NULL)\n    {    /*attempt to detect binary (black&white) images*/\n      if ((image->storage_class == PseudoClass) &&\n          (SetImageGray(image,exception) != MagickFalse))\n        {\n          if(GetCutColors(image,exception)==2)\n            {\n              for (i=0; i < (ssize_t)image->colors; i++)\n                {\n                  register Quantum\n                    sample;\n                  sample=ScaleCharToQuantum((unsigned char) i);\n                  if(image->colormap[i].red!=sample) goto Finish;\n                  if(image->colormap[i].green!=sample) goto Finish;\n                  if(image->colormap[i].blue!=sample) goto Finish;\n                }\n\n              image->colormap[1].red=image->colormap[1].green=\n                image->colormap[1].blue=QuantumRange;\n              for (i=0; i < (ssize_t)image->rows; i++)\n                {\n                  q=QueueAuthenticPixels(image,0,i,image->columns,1,exception);\n                  if (q == (Quantum *) NULL)\n                    break;\n                  for (j=0; j < (ssize_t)image->columns; j++)\n                    {\n                      if (GetPixelRed(image,q) == ScaleCharToQuantum(1))\n                        {\n                          SetPixelRed(image,QuantumRange,q);\n                          SetPixelGreen(image,QuantumRange,q);\n                          SetPixelBlue(image,QuantumRange,q);\n                        }\n                      q+=GetPixelChannels(image);\n                    }\n                  if (SyncAuthenticPixels(image,exception) == MagickFalse) goto Finish;\n                }\n            }\n        }\n    }\n\n Finish:\n  if (BImgBuff != NULL)\n    BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  if (palette != NULL)\n    palette=DestroyImage(palette);\n  if (clone_info != NULL)\n    clone_info=DestroyImageInfo(clone_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r C U T I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterCUTImage() adds attributes for the CUT image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterCUTImage method is:\n%\n%      size_t RegisterCUTImage(void)\n%\n*/\nModuleExport size_t RegisterCUTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"CUT\",\"CUT\",\"DR Halo\");\n  entry->decoder=(DecodeImageHandler *) ReadCUTImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r C U T I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterCUTImage() removes format registrations made by the\n%  CUT module from the list of supported formats.\n%\n%  The format of the UnregisterCUTImage method is:\n%\n%      UnregisterCUTImage(void)\n%\n*/\nModuleExport void UnregisterCUTImage(void)\n{\n  (void) UnregisterMagickInfo(\"CUT\");\n}\n"], "filenames": ["coders/cut.c"], "buggy_code_start_loc": [558], "buggy_code_end_loc": [558], "fixing_code_start_loc": [559], "fixing_code_end_loc": [560], "type": "CWE-908", "message": "ImageMagick before 7.0.8-50 has a \"use of uninitialized value\" vulnerability in the function ReadCUTImage in coders/cut.c.", "other": {"cve": {"id": "CVE-2019-13135", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-01T20:15:11.337", "lastModified": "2021-04-28T18:22:26.220", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick before 7.0.8-50 has a \"use of uninitialized value\" vulnerability in the function ReadCUTImage in coders/cut.c."}, {"lang": "es", "value": "ImageMagick en versiones anteriores a la 7.0.8-50 tiene una vulnerabilidad de \"use of uninitialized value\" en la funci\u00f3n ReadCUTImage in coders/cut.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.10-50", "matchCriteriaId": "BF97F7CB-3E80-4DBB-8854-FF5C012BA0FA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.8-50", "matchCriteriaId": "F8AB2B06-598F-4F38-813C-B1E3E1E7EEE5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.5.2", "versionEndExcluding": "11.6.5.2", "matchCriteriaId": "35364557-83E3-4807-8D93-84BF17E01075"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.1.0", "versionEndExcluding": "12.1.5.2", "matchCriteriaId": "5D3F7911-FB00-4612-9109-9E7A407BC7B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.1.0", "versionEndExcluding": "13.1.3.4", "matchCriteriaId": "B547F46F-5563-4E7F-8B69-3D25C6C58521"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.2.5", "matchCriteriaId": "1261AE74-41AF-4848-9AD9-46918C46845B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.3", "matchCriteriaId": "1549C41F-9467-42C6-AF4B-644900495590"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.1.0", "versionEndExcluding": "15.1.0.2", "matchCriteriaId": "45920B7E-10A6-4066-87AB-60D584689891"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.5.2", "versionEndExcluding": "11.6.5.2", "matchCriteriaId": "DC9ED27E-9096-4A7D-96A7-E3F47E747D73"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.1.0", "versionEndExcluding": "12.1.5.2", "matchCriteriaId": "02CB8916-A9ED-4935-BFBD-5C9E8D45379E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:*:*:*:*:*:*:*:*", "versionStartIncluding": "13.1.0", "versionEndExcluding": "13.1.3.4", "matchCriteriaId": "5853A161-2F92-4298-A70A-03A66DED157C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0.0", "versionEndExcluding": "14.1.2.5", "matchCriteriaId": "E0C65C13-C852-4A12-BFC0-A4DB201FFCAF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.0.0", "versionEndExcluding": "15.0.1.3", "matchCriteriaId": "CDE4FB3F-887D-48FC-B5F7-E06FA8AAEF30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:*:*:*:*:*:*:*:*", "versionStartIncluding": "15.1.0", "versionEndExcluding": "15.1.0.2", "matchCriteriaId": "0064DE79-D6D6-4AE0-BF10-BF91FF9158DF"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/cdb383749ef7b68a38891440af8cc23e0115306d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1599", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/1e59b29e520d2beab73e8c78aacd5f1c0d76196d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/08/msg00021.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/09/msg00007.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K20336394", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K20336394?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4192-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/cdb383749ef7b68a38891440af8cc23e0115306d"}}