{"buggy_code": ["/* Copyright 1998 by the Massachusetts Institute of Technology.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of M.I.T. not be used in\n * advertising or publicity pertaining to distribution of the\n * software without specific, written prior permission.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\"\n * without express or implied warranty.\n */\n\n\n#include <sys/types.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ares.h\"\n#include \"ares_dns.h\"\n#include \"ares_private.h\"\n\n#ifndef WIN32\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#ifndef __CYGWIN__\n#  include <arpa/nameser.h>\n#endif\n#include <netdb.h>\n#endif\n\nint ares_parse_a_reply(const unsigned char *abuf, int alen,\n\t\t       struct hostent **host)\n{\n  unsigned int qdcount, ancount;\n  int status, i, rr_type, rr_class, rr_len, naddrs;\n  long int len;\n  int naliases;\n  const unsigned char *aptr;\n  char *hostname, *rr_name, *rr_data, **aliases;\n  struct in_addr *addrs;\n  struct hostent *hostent;\n\n  /* Set *host to NULL for all failure cases. */\n  *host = NULL;\n\n  /* Give up if abuf doesn't have room for a header. */\n  if (alen < HFIXEDSZ)\n    return ARES_EBADRESP;\n\n  /* Fetch the question and answer count from the header. */\n  qdcount = DNS_HEADER_QDCOUNT(abuf);\n  ancount = DNS_HEADER_ANCOUNT(abuf);\n  if (qdcount != 1)\n    return ARES_EBADRESP;\n\n  /* Expand the name from the question, and skip past the question. */\n  aptr = abuf + HFIXEDSZ;\n  status = ares_expand_name(aptr, abuf, alen, &hostname, &len);\n  if (status != ARES_SUCCESS)\n    return status;\n  if (aptr + len + QFIXEDSZ > abuf + alen)\n    {\n      free(hostname);\n      return ARES_EBADRESP;\n    }\n  aptr += len + QFIXEDSZ;\n\n  /* Allocate addresses and aliases; ancount gives an upper bound for both. */\n  addrs = malloc(ancount * sizeof(struct in_addr));\n  if (!addrs)\n    {\n      free(hostname);\n      return ARES_ENOMEM;\n    }\n  aliases = malloc((ancount + 1) * sizeof(char *));\n  if (!aliases)\n    {\n      free(hostname);\n      free(addrs);\n      return ARES_ENOMEM;\n    }\n  naddrs = 0;\n  naliases = 0;\n\n  /* Examine each answer resource record (RR) in turn. */\n  for (i = 0; i < (int)ancount; i++)\n    {\n      /* Decode the RR up to the data field. */\n      status = ares_expand_name(aptr, abuf, alen, &rr_name, &len);\n      if (status != ARES_SUCCESS)\n\tbreak;\n      aptr += len;\n      if (aptr + RRFIXEDSZ > abuf + alen)\n\t{\n\t  free(rr_name);\n\t  status = ARES_EBADRESP;\n\t  break;\n\t}\n      rr_type = DNS_RR_TYPE(aptr);\n      rr_class = DNS_RR_CLASS(aptr);\n      rr_len = DNS_RR_LEN(aptr);\n      aptr += RRFIXEDSZ;\n\n      if (rr_class == C_IN && rr_type == T_A\n\t  && rr_len == sizeof(struct in_addr)\n\t  && strcasecmp(rr_name, hostname) == 0)\n\t{\n\t  memcpy(&addrs[naddrs], aptr, sizeof(struct in_addr));\n\t  naddrs++;\n\t  status = ARES_SUCCESS;\n\t}\n\n      if (rr_class == C_IN && rr_type == T_CNAME)\n\t{\n\t  /* Record the RR name as an alias. */\n\t  aliases[naliases] = rr_name;\n\t  naliases++;\n\n\t  /* Decode the RR data and replace the hostname with it. */\n\t  status = ares_expand_name(aptr, abuf, alen, &rr_data, &len);\n\t  if (status != ARES_SUCCESS)\n\t    break;\n\t  free(hostname);\n\t  hostname = rr_data;\n\t}\n      else\n\tfree(rr_name);\n\n      aptr += rr_len;\n      if (aptr > abuf + alen)\n\t{\n\t  status = ARES_EBADRESP;\n\t  break;\n\t}\n    }\n\n  if (status == ARES_SUCCESS && naddrs == 0)\n    status = ARES_ENODATA;\n  if (status == ARES_SUCCESS)\n    {\n      /* We got our answer.  Allocate memory to build the host entry. */\n      aliases[naliases] = NULL;\n      hostent = malloc(sizeof(struct hostent));\n      if (hostent)\n\t{\n\t  hostent->h_addr_list = malloc((naddrs + 1) * sizeof(char *));\n\t  if (hostent->h_addr_list)\n\t    {\n\t      /* Fill in the hostent and return successfully. */\n\t      hostent->h_name = hostname;\n\t      hostent->h_aliases = aliases;\n\t      hostent->h_addrtype = AF_INET;\n\t      hostent->h_length = sizeof(struct in_addr);\n\t      for (i = 0; i < naddrs; i++)\n\t\thostent->h_addr_list[i] = (char *) &addrs[i];\n\t      hostent->h_addr_list[naddrs] = NULL;\n\t      *host = hostent;\n\t      return ARES_SUCCESS;\n\t    }\n\t  free(hostent);\n\t}\n      status = ARES_ENOMEM;\n    }\n  for (i = 0; i < naliases; i++)\n    free(aliases[i]);\n  free(aliases);\n  free(addrs);\n  free(hostname);\n  return status;\n}\n"], "fixing_code": ["/* Copyright 1998 by the Massachusetts Institute of Technology.\n *\n * Permission to use, copy, modify, and distribute this\n * software and its documentation for any purpose and without\n * fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright\n * notice and this permission notice appear in supporting\n * documentation, and that the name of M.I.T. not be used in\n * advertising or publicity pertaining to distribution of the\n * software without specific, written prior permission.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\"\n * without express or implied warranty.\n */\n\n\n#include <sys/types.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"ares.h\"\n#include \"ares_dns.h\"\n#include \"ares_private.h\"\n\n#ifndef WIN32\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#ifndef __CYGWIN__\n#  include <arpa/nameser.h>\n#endif\n#include <netdb.h>\n#endif\n\nint ares_parse_a_reply(const unsigned char *abuf, int alen,\n\t\t       struct hostent **host)\n{\n  unsigned int qdcount, ancount;\n  int status, i, rr_type, rr_class, rr_len, naddrs;\n  long int len;\n  int naliases;\n  const unsigned char *aptr;\n  char *hostname, *rr_name, *rr_data, **aliases;\n  struct in_addr *addrs;\n  struct hostent *hostent;\n\n  /* Set *host to NULL for all failure cases. */\n  *host = NULL;\n\n  /* Give up if abuf doesn't have room for a header. */\n  if (alen < HFIXEDSZ)\n    return ARES_EBADRESP;\n\n  /* Fetch the question and answer count from the header. */\n  qdcount = DNS_HEADER_QDCOUNT(abuf);\n  ancount = DNS_HEADER_ANCOUNT(abuf);\n  if (qdcount != 1)\n    return ARES_EBADRESP;\n\n  /* Expand the name from the question, and skip past the question. */\n  aptr = abuf + HFIXEDSZ;\n  status = ares_expand_name(aptr, abuf, alen, &hostname, &len);\n  if (status != ARES_SUCCESS)\n    return status;\n  if (aptr + len + QFIXEDSZ > abuf + alen)\n    {\n      free(hostname);\n      return ARES_EBADRESP;\n    }\n  aptr += len + QFIXEDSZ;\n\n  /* Allocate addresses and aliases; ancount gives an upper bound for both. */\n  addrs = malloc(ancount * sizeof(struct in_addr));\n  if (!addrs)\n    {\n      free(hostname);\n      return ARES_ENOMEM;\n    }\n  aliases = malloc((ancount + 1) * sizeof(char *));\n  if (!aliases)\n    {\n      free(hostname);\n      free(addrs);\n      return ARES_ENOMEM;\n    }\n  naddrs = 0;\n  naliases = 0;\n\n  /* Examine each answer resource record (RR) in turn. */\n  for (i = 0; i < (int)ancount; i++)\n    {\n      /* Decode the RR up to the data field. */\n      status = ares_expand_name(aptr, abuf, alen, &rr_name, &len);\n      if (status != ARES_SUCCESS)\n\tbreak;\n      aptr += len;\n      if (aptr + RRFIXEDSZ > abuf + alen)\n\t{\n\t  free(rr_name);\n\t  status = ARES_EBADRESP;\n\t  break;\n\t}\n      rr_type = DNS_RR_TYPE(aptr);\n      rr_class = DNS_RR_CLASS(aptr);\n      rr_len = DNS_RR_LEN(aptr);\n      aptr += RRFIXEDSZ;\n      if (aptr + rr_len > abuf + alen)\n\t{\n\t  free(rr_name);\n\t  status = ARES_EBADRESP;\n\t  break;\n\t}\n\n      if (rr_class == C_IN && rr_type == T_A\n\t  && rr_len == sizeof(struct in_addr)\n\t  && strcasecmp(rr_name, hostname) == 0)\n\t{\n\t  memcpy(&addrs[naddrs], aptr, sizeof(struct in_addr));\n\t  naddrs++;\n\t  status = ARES_SUCCESS;\n\t}\n\n      if (rr_class == C_IN && rr_type == T_CNAME)\n\t{\n\t  /* Record the RR name as an alias. */\n\t  aliases[naliases] = rr_name;\n\t  naliases++;\n\n\t  /* Decode the RR data and replace the hostname with it. */\n\t  status = ares_expand_name(aptr, abuf, alen, &rr_data, &len);\n\t  if (status != ARES_SUCCESS)\n\t    break;\n\t  free(hostname);\n\t  hostname = rr_data;\n\t}\n      else\n\tfree(rr_name);\n\n      aptr += rr_len;\n      if (aptr > abuf + alen)\n\t{\n\t  status = ARES_EBADRESP;\n\t  break;\n\t}\n    }\n\n  if (status == ARES_SUCCESS && naddrs == 0)\n    status = ARES_ENODATA;\n  if (status == ARES_SUCCESS)\n    {\n      /* We got our answer.  Allocate memory to build the host entry. */\n      aliases[naliases] = NULL;\n      hostent = malloc(sizeof(struct hostent));\n      if (hostent)\n\t{\n\t  hostent->h_addr_list = malloc((naddrs + 1) * sizeof(char *));\n\t  if (hostent->h_addr_list)\n\t    {\n\t      /* Fill in the hostent and return successfully. */\n\t      hostent->h_name = hostname;\n\t      hostent->h_aliases = aliases;\n\t      hostent->h_addrtype = AF_INET;\n\t      hostent->h_length = sizeof(struct in_addr);\n\t      for (i = 0; i < naddrs; i++)\n\t\thostent->h_addr_list[i] = (char *) &addrs[i];\n\t      hostent->h_addr_list[naddrs] = NULL;\n\t      *host = hostent;\n\t      return ARES_SUCCESS;\n\t    }\n\t  free(hostent);\n\t}\n      status = ARES_ENOMEM;\n    }\n  for (i = 0; i < naliases; i++)\n    free(aliases[i]);\n  free(aliases);\n  free(addrs);\n  free(hostname);\n  return status;\n}\n"], "filenames": ["rutil/dns/ares/ares_parse_a_reply.c"], "buggy_code_start_loc": [105], "buggy_code_end_loc": [105], "fixing_code_start_loc": [106], "fixing_code_end_loc": [112], "type": "CWE-125", "message": "Buffer overflow in the ares_parse_a_reply function in the embedded ares library in ReSIProcate before 1.12.0 allows remote attackers to cause a denial of service (out-of-bounds-read) via a crafted DNS response.", "other": {"cve": {"id": "CVE-2017-9454", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-18T14:29:00.843", "lastModified": "2019-12-11T22:14:59.490", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer overflow in the ares_parse_a_reply function in the embedded ares library in ReSIProcate before 1.12.0 allows remote attackers to cause a denial of service (out-of-bounds-read) via a crafted DNS response."}, {"lang": "es", "value": "Un desbordamiento de b\u00fafer en la funci\u00f3n ares_parse_a_reply en la biblioteca embebida ares en ReSIProcate en versiones anteriores a la 1.12.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites) mediante una respuesta DNS manipulada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.10.2", "matchCriteriaId": "D7A9B784-2E65-4DD9-A2BF-37E9423059E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "EBC4049D-A7EE-4E51-82F1-3431B4571C55"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:alpha10:*:*:*:*:*:*", "matchCriteriaId": "2A32D09D-AFFE-407D-908F-8191D2973C27"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:alpha11:*:*:*:*:*:*", "matchCriteriaId": "3885433A-D1DE-4970-84AF-A7D6DFAF1B57"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:alpha2:*:*:*:*:*:*", "matchCriteriaId": "7A6DE94C-6DCB-4668-A326-9E001283C822"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:alpha3:*:*:*:*:*:*", "matchCriteriaId": "888FA5FD-51E9-4185-ADA1-D668997EB4D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:alpha4:*:*:*:*:*:*", "matchCriteriaId": "4402C7AC-9011-4D24-A480-4345E53CCDB1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:alpha5:*:*:*:*:*:*", "matchCriteriaId": "887E4C3A-421B-45FA-B15A-B28C5441690D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:alpha6:*:*:*:*:*:*", "matchCriteriaId": "3DF27A62-D822-4EC6-B9B0-8B649E4D1945"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:alpha7:*:*:*:*:*:*", "matchCriteriaId": "A56BD5AA-5147-46E7-8A9C-D7659910F47E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:alpha8:*:*:*:*:*:*", "matchCriteriaId": "2C0618F8-A8A1-424E-99C2-9BD5EC1D0107"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:alpha9:*:*:*:*:*:*", "matchCriteriaId": "1D69BFE3-1049-4A6A-B0C6-DD19C42841D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "245EB59F-6C85-4ADB-9CF8-BC14BCA0F95A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "2730BF92-BCE5-4AAE-BE01-247DC88E1930"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "0AEF426E-6BC3-430A-A6CB-A191878336F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "AB2FA8BF-3C02-4D2C-87FF-AC5AF93969BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.11.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "8A99CFB3-19B9-4795-918C-3EBA7CCEEEF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.12.0:alpha1:*:*:*:*:*:*", "matchCriteriaId": "B8041C24-A94D-4608-95DC-6C88205E6396"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.12.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "39317578-B144-4B3A-86CE-DEF08381B0AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.12.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "D281F50A-901C-40C5-B00C-0DBD091660E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.12.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "7A3801C8-13A4-4FF6-B37A-F470776C7BC6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.12.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "CED56E7C-2C14-412B-98E5-1800FE7BC7F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.12.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "608290B9-AA27-439A-AA69-2EA1FAF8D9BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.12.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "64FF1CA1-79CB-4626-AE4C-A565872798C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.12.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "C4A69805-93E3-49ED-8BBC-FDE1C2704B2D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.12.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "917E083C-B1A3-4F5A-93D1-D8FB4FC2B313"}, {"vulnerable": true, "criteria": "cpe:2.3:a:resiprocate:resiprocate:1.12.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "791BA3D2-D50A-4ABA-BC4A-44469C09EA6A"}]}]}], "references": [{"url": "https://github.com/resiprocate/resiprocate/commit/d67a9ca6fd06ca65d23e313bdbad1ef4dd3aa0df", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://list.resiprocate.org/archive/resiprocate-users/msg02700.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/resiprocate/resiprocate/commit/d67a9ca6fd06ca65d23e313bdbad1ef4dd3aa0df"}}