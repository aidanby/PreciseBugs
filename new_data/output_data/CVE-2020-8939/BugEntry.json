{"buggy_code": ["/*\n *\n * Copyright 2019 Asylo authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include \"asylo/platform/host_call/trusted/host_calls.h\"\n\n#include <errno.h>\n#include <ifaddrs.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <signal.h>\n#include <sys/statfs.h>\n\n#include <algorithm>\n\n#include \"asylo/platform/host_call/exit_handler_constants.h\"\n#include \"asylo/platform/host_call/serializer_functions.h\"\n#include \"asylo/platform/primitives/trusted_primitives.h\"\n#include \"asylo/platform/system_call/type_conversions/types_functions.h\"\n\nusing ::asylo::host_call::NonSystemCallDispatcher;\nusing ::asylo::primitives::Extent;\nusing ::asylo::primitives::MessageReader;\nusing ::asylo::primitives::MessageWriter;\nusing ::asylo::primitives::TrustedPrimitives;\n\nvoid CheckStatusAndParamCount(const asylo::primitives::PrimitiveStatus &status,\n                              const MessageReader &output, const char *name,\n                              int expected_params, bool match_exact_params) {\n  if (!status.ok()) {\n    std::string message = absl::StrCat(\"Host call '\", name, \"' failed.\");\n    TrustedPrimitives::BestEffortAbort(message.c_str());\n  }\n\n  if (!match_exact_params) {\n    if (output.size() < expected_params) {\n      std::string message = absl::StrCat(\n          \"Host call '\", name, \"': Expected at least \", expected_params,\n          \" parameters on the MessageReader, found \", output.size());\n      TrustedPrimitives::BestEffortAbort(message.c_str());\n    }\n  } else {\n    if (output.size() != expected_params) {\n      std::string message = absl::StrCat(\n          \"Host call '\", name, \"': Expected \", expected_params,\n          \" parameters on the MessageReader, found \", output.size());\n      TrustedPrimitives::BestEffortAbort(message.c_str());\n    }\n  }\n}\n\nnamespace {\n\n// A global passwd struct. The address of it is used as the return value of\n// getpwuid.\nstruct passwd global_passwd;\n\nsize_t CalculateTotalMessageSize(const struct msghdr *msg) {\n  size_t total_message_size = 0;\n  for (int i = 0; i < msg->msg_iovlen; ++i) {\n    total_message_size += msg->msg_iov[i].iov_len;\n  }\n  return total_message_size;\n}\n\n#define PASSWD_HOLDER_FIELD_LENGTH 1024\n\n// Struct for storing the buffers needed by struct passwd members.\nstruct passwd_holder {\n  char pw_name[PASSWD_HOLDER_FIELD_LENGTH];\n  char pw_passwd[PASSWD_HOLDER_FIELD_LENGTH];\n  uid_t pw_uid;\n  gid_t pw_gid;\n  char pw_gecos[PASSWD_HOLDER_FIELD_LENGTH];\n  char pw_dir[PASSWD_HOLDER_FIELD_LENGTH];\n  char pw_shell[PASSWD_HOLDER_FIELD_LENGTH];\n};\n\nbool DeserializePasswd(MessageReader *reader,\n                       struct passwd_holder *passwd_buffers) {\n  if (!reader || !passwd_buffers) {\n    return false;\n  }\n  if (reader->size() < 7) {\n    return false;\n  }\n\n  auto pw_name_buf = reader->next();\n  auto pw_passwd_buf = reader->next();\n  auto pw_uid = reader->next<uid_t>();\n  auto pw_gid = reader->next<gid_t>();\n  auto pw_gecos_buf = reader->next();\n  auto pw_dir_buf = reader->next();\n  auto pw_shell_buf = reader->next();\n\n  strncpy(passwd_buffers->pw_name, pw_name_buf.As<char>(),\n          std::min(sizeof(passwd_buffers->pw_name), pw_name_buf.size()));\n  strncpy(passwd_buffers->pw_passwd, pw_passwd_buf.As<char>(),\n          std::min(sizeof(passwd_buffers->pw_passwd), pw_passwd_buf.size()));\n  passwd_buffers->pw_uid = pw_uid;\n  passwd_buffers->pw_gid = pw_gid;\n  strncpy(passwd_buffers->pw_gecos, pw_gecos_buf.As<char>(),\n          std::min(sizeof(passwd_buffers->pw_gecos), pw_gecos_buf.size()));\n  strncpy(passwd_buffers->pw_dir, pw_dir_buf.As<char>(),\n          std::min(sizeof(passwd_buffers->pw_dir), pw_dir_buf.size()));\n  strncpy(passwd_buffers->pw_shell, pw_shell_buf.As<char>(),\n          std::min(sizeof(passwd_buffers->pw_shell), pw_shell_buf.size()));\n  return true;\n}\n\nbool PasswdHolderToPasswd(struct passwd_holder *passwd_in,\n                          struct passwd *passwd_out) {\n  if (!passwd_in || !passwd_out) {\n    return false;\n  }\n\n  passwd_out->pw_name = passwd_in->pw_name;\n  passwd_out->pw_passwd = passwd_in->pw_passwd;\n  passwd_out->pw_uid = passwd_in->pw_uid;\n  passwd_out->pw_gid = passwd_in->pw_gid;\n  passwd_out->pw_gecos = passwd_in->pw_gecos;\n  passwd_out->pw_dir = passwd_in->pw_dir;\n  passwd_out->pw_shell = passwd_in->pw_shell;\n  return true;\n}\n\n}  // namespace\n\nextern \"C\" {\n\nint enc_untrusted_access(const char *path_name, int mode) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_access,\n                                             path_name, mode);\n}\n\npid_t enc_untrusted_getpid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_getpid);\n}\n\npid_t enc_untrusted_getppid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_getppid);\n}\n\npid_t enc_untrusted_setsid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_setsid);\n}\n\nuid_t enc_untrusted_getuid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_getuid);\n}\n\ngid_t enc_untrusted_getgid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_getgid);\n}\n\nuid_t enc_untrusted_geteuid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_geteuid);\n}\n\ngid_t enc_untrusted_getegid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_getegid);\n}\n\nint enc_untrusted_kill(pid_t pid, int sig) {\n  int klinux_sig = TokLinuxSignalNumber(sig);\n  if (klinux_sig < 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_kill, pid,\n                                             klinux_sig);\n}\n\nint enc_untrusted_link(const char *oldpath, const char *newpath) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_link,\n                                             oldpath, newpath);\n}\n\noff_t enc_untrusted_lseek(int fd, off_t offset, int whence) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_lseek, fd,\n                                             offset, whence);\n}\n\nint enc_untrusted_mkdir(const char *pathname, mode_t mode) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_mkdir,\n                                             pathname, mode);\n}\n\nint enc_untrusted_open(const char *pathname, int flags, ...) {\n  int mode = 0;\n  if (flags & O_CREAT) {\n    va_list ap;\n    va_start(ap, flags);\n    mode = va_arg(ap, mode_t);\n    va_end(ap);\n  }\n\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_open, pathname, TokLinuxFileStatusFlag(flags),\n      TokLinuxFileModeFlag(mode));\n}\n\nint enc_untrusted_unlink(const char *pathname) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_unlink,\n                                             pathname);\n}\n\nint enc_untrusted_rename(const char *oldpath, const char *newpath) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_rename,\n                                             oldpath, newpath);\n}\n\nssize_t enc_untrusted_read(int fd, void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_read, fd, buf, count));\n}\n\nssize_t enc_untrusted_write(int fd, const void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_write, fd, buf, count));\n}\n\nint enc_untrusted_symlink(const char *target, const char *linkpath) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_symlink,\n                                             target, linkpath);\n}\n\nssize_t enc_untrusted_readlink(const char *pathname, char *buf, size_t bufsiz) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_readlink, pathname, buf, bufsiz));\n}\n\nint enc_untrusted_truncate(const char *path, off_t length) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_truncate,\n                                             path, length);\n}\n\nint enc_untrusted_ftruncate(int fd, off_t length) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_ftruncate,\n                                             fd, length);\n}\n\nint enc_untrusted_rmdir(const char *path) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_rmdir,\n                                             path);\n}\n\nint enc_untrusted_pipe2(int pipefd[2], int flags) {\n  if (flags & ~(O_CLOEXEC | O_DIRECT | O_NONBLOCK)) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_pipe2, pipefd, TokLinuxFileStatusFlag(flags));\n}\n\nint enc_untrusted_socket(int domain, int type, int protocol) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_socket, TokLinuxAfFamily(domain),\n      TokLinuxSocketType(type), protocol);\n}\n\nint enc_untrusted_listen(int sockfd, int backlog) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_listen,\n                                             sockfd, backlog);\n}\n\nint enc_untrusted_shutdown(int sockfd, int how) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_shutdown,\n                                             sockfd, how);\n}\n\nssize_t enc_untrusted_send(int sockfd, const void *buf, size_t len, int flags) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_sendto,\n                                             sockfd, buf, len, flags,\n                                             /*dest_addr=*/nullptr,\n                                             /*addrlen=*/0);\n}\n\nint enc_untrusted_fcntl(int fd, int cmd, ... /* arg */) {\n  // We do not currently support file locks in Asylo, so arg is not expected to\n  // be a pointer to struct flock.\n  int64_t arg = 0;\n  va_list ap;\n  va_start(ap, cmd);\n  arg = va_arg(ap, int64_t);\n  va_end(ap);\n\n  int klinux_cmd = TokLinuxFcntlCommand(cmd);\n  if (klinux_cmd == -1) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  int intarg = arg;\n  switch (cmd) {\n    case F_SETFL: {\n      return EnsureInitializedAndDispatchSyscall(\n          asylo::system_call::kSYS_fcntl, fd, klinux_cmd,\n          TokLinuxFileStatusFlag(intarg));\n    }\n    case F_SETFD: {\n      return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fcntl,\n                                                 fd, klinux_cmd,\n                                                 TokLinuxFDFlag(intarg));\n    }\n    case F_GETFL: {\n      int retval = EnsureInitializedAndDispatchSyscall(\n          asylo::system_call::kSYS_fcntl, fd, klinux_cmd, arg);\n      if (retval != -1) {\n        retval = FromkLinuxFileStatusFlag(retval);\n      }\n\n      return retval;\n    }\n    case F_GETFD: {\n      int retval = EnsureInitializedAndDispatchSyscall(\n          asylo::system_call::kSYS_fcntl, fd, klinux_cmd, arg);\n      if (retval != -1) {\n        retval = FromkLinuxFDFlag(retval);\n      }\n      return retval;\n    }\n    case F_GETPIPE_SZ:\n    case F_SETPIPE_SZ: {\n      return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fcntl,\n                                                 fd, klinux_cmd, arg);\n    }\n    // We do not handle the case for F_DUPFD. It is expected to be handled at\n    // a higher abstraction, as we need not exit the enclave for duplicating\n    // the file descriptor.\n    default: {\n      errno = EINVAL;\n      return -1;\n    }\n  }\n}\n\nint enc_untrusted_chown(const char *pathname, uid_t owner, gid_t group) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_chown,\n                                             pathname, owner, group);\n}\n\nint enc_untrusted_fchown(int fd, uid_t owner, gid_t group) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fchown,\n                                             fd, owner, group);\n}\n\nint enc_untrusted_setsockopt(int sockfd, int level, int optname,\n                             const void *optval, socklen_t optlen) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_setsockopt, sockfd, level,\n      TokLinuxOptionName(level, optname), optval, optlen);\n}\n\nint enc_untrusted_flock(int fd, int operation) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_flock, fd,\n                                             TokLinuxFLockOperation(operation));\n}\n\nint enc_untrusted_wait(int *wstatus) {\n  int klinux_wstatus;\n  pid_t ret = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_wait4, /*wpid=*/-1, &klinux_wstatus,\n      /*options=*/0,\n      /*rusage=*/nullptr);\n  *wstatus = FromkLinuxToNewlibWstatus(klinux_wstatus);\n  return ret;\n}\n\nint enc_untrusted_inotify_init1(int flags) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_inotify_init1, TokLinuxInotifyFlag(flags));\n}\n\nint enc_untrusted_inotify_add_watch(int fd, const char *pathname,\n                                    uint32_t mask) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_inotify_add_watch, fd, pathname,\n      TokLinuxInotifyEventMask(mask));\n}\n\nint enc_untrusted_inotify_rm_watch(int fd, int wd) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_inotify_rm_watch, fd, wd);\n}\n\nmode_t enc_untrusted_umask(mode_t mask) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_umask,\n                                             mask);\n}\n\nint enc_untrusted_chmod(const char *path_name, mode_t mode) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_chmod,\n                                             path_name, mode);\n}\n\nint enc_untrusted_fchmod(int fd, mode_t mode) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fchmod,\n                                             fd, mode);\n}\n\nint enc_untrusted_sched_yield() {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_sched_yield);\n}\n\nint enc_untrusted_sched_getaffinity(pid_t pid, size_t cpusetsize,\n                                    cpu_set_t *mask) {\n  klinux_cpu_set_t klinux_mask{};\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_sched_getaffinity, pid,\n      static_cast<uint64_t>(cpusetsize), &klinux_mask);\n  // On success, the raw getaffinity syscall returns the size of the cpumask_t\n  // data type, To mimic the glibc behavior, we return 0 on success and -1 on\n  // failure. See https://linux.die.net/man/2/sched_getaffinity, under \"notes\".\n  if (result < 0) {\n    return -1;\n  }\n  if (!FromkLinuxCpuSet(&klinux_mask, mask)) {\n    errno = EFAULT;\n    return -1;\n  }\n  return 0;\n}\n\nint enc_untrusted_pread64(int fd, void *buf, size_t count, off_t offset) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_pread64,\n                                             fd, buf, count, offset);\n}\n\nint enc_untrusted_pwrite64(int fd, const void *buf, size_t count,\n                           off_t offset) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_pwrite64,\n                                             fd, buf, count, offset);\n}\n\nint enc_untrusted_isatty(int fd) {\n  MessageWriter input;\n  input.Push(fd);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kIsAttyHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_isatty\", 2);\n\n  int result = output.next<int>();\n\n  // isatty() returns 1 if fd is an open file descriptor referring to a\n  // terminal; otherwise 0 is returned, and errno is set to indicate the error.\n  if (result == 0) {\n    int klinux_errno = output.next<int>();\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n\nint enc_untrusted_usleep(useconds_t usec) {\n  MessageWriter input;\n  input.Push(usec);\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kUSleepHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_usleep\", 2);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n\n  // usleep() returns 0 on success. On error, -1 is returned, with errno set to\n  // indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n\n  return result;\n}\n\nint enc_untrusted_fstat(int fd, struct stat *statbuf) {\n  struct klinux_stat stat_kernel;\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_fstat, fd, &stat_kernel);\n\n  if (FromkLinuxStat(&stat_kernel, statbuf)) {\n    statbuf->st_mode = FromkLinuxFileModeFlag(stat_kernel.klinux_st_mode);\n  }\n  return result;\n}\n\nint enc_untrusted_fstatfs(int fd, struct statfs *statbuf) {\n  struct klinux_statfs statfs_kernel;\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_fstatfs, fd, &statfs_kernel);\n\n  if (FromkLinuxStatFs(&statfs_kernel, statbuf)) {\n    statbuf->f_flags = FromkLinuxStatFsFlags(statfs_kernel.klinux_f_flags);\n  }\n  return result;\n}\n\nint enc_untrusted_lstat(const char *pathname, struct stat *statbuf) {\n  struct klinux_stat stat_kernel;\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_lstat, pathname, &stat_kernel);\n\n  if (FromkLinuxStat(&stat_kernel, statbuf)) {\n    statbuf->st_mode = FromkLinuxFileModeFlag(stat_kernel.klinux_st_mode);\n  }\n  return result;\n}\n\nint enc_untrusted_stat(const char *pathname, struct stat *statbuf) {\n  struct klinux_stat stat_kernel;\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_stat, pathname, &stat_kernel);\n  if (FromkLinuxStat(&stat_kernel, statbuf)) {\n    statbuf->st_mode = FromkLinuxFileModeFlag(stat_kernel.klinux_st_mode);\n  }\n  return result;\n}\n\nint enc_untrusted_statfs(const char *pathname, struct statfs *statbuf) {\n  struct klinux_statfs statfs_kernel;\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_statfs, pathname, &statfs_kernel);\n\n  if (FromkLinuxStatFs(&statfs_kernel, statbuf)) {\n    statbuf->f_flags = FromkLinuxStatFsFlags(statfs_kernel.klinux_f_flags);\n  }\n  return result;\n}\n\nssize_t enc_untrusted_getxattr(const char *path, const char *name, void *value,\n                               size_t size) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_getxattr,\n                                             path, name, value, size);\n}\n\nssize_t enc_untrusted_lgetxattr(const char *path, const char *name, void *value,\n                                size_t size) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_lgetxattr,\n                                             path, name, value, size);\n}\n\nssize_t enc_untrusted_fgetxattr(int fd, const char *name, void *value,\n                                size_t size) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fgetxattr,\n                                             fd, name, value, size);\n}\n\nint enc_untrusted_setxattr(const char *path, const char *name,\n                           const void *value, size_t size, int flags) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_setxattr,\n                                             path, name, value, size, flags);\n}\n\nint enc_untrusted_lsetxattr(const char *path, const char *name,\n                            const void *value, size_t size, int flags) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_lsetxattr,\n                                             path, name, value, size, flags);\n}\n\nint enc_untrusted_fsetxattr(int fd, const char *name, const void *value,\n                            size_t size, int flags) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fsetxattr,\n                                             fd, name, value, size, flags);\n}\n\nssize_t enc_untrusted_listxattr(const char *path, char *list, size_t size) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_listxattr,\n                                             path, list, size);\n}\n\nssize_t enc_untrusted_llistxattr(const char *path, char *list, size_t size) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_llistxattr, path, list, size);\n}\n\nssize_t enc_untrusted_flistxattr(int fd, char *list, size_t size) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_flistxattr, fd, list, size);\n}\n\nint64_t enc_untrusted_sysconf(int name) {\n  int kLinux_name = TokLinuxSysconfConstant(name);\n  if (kLinux_name == -1) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push(kLinux_name);\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kSysconfHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_sysconf\", 2);\n\n  int64_t result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n\n  return result;\n}\n\nint enc_untrusted_close(int fd) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_close,\n                                             fd);\n}\n\nvoid *enc_untrusted_realloc(void *ptr, size_t size) {\n  MessageWriter input;\n  input.Push(reinterpret_cast<uint64_t>(ptr));\n  input.Push(static_cast<uint64_t>(size));\n\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kReallocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_realloc\", 2);\n\n  void *result = output.next<void *>();\n  int klinux_errno = output.next<int>();\n\n  // realloc only sets the errno (ENOMEM) when output pointer is null and a\n  // non-zero |size| is provided.\n  if (!result && size != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n\n  if (!::asylo::primitives::TrustedPrimitives::IsOutsideEnclave(result, size)) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_realloc: realloc result should be in untrusted \"\n        \"memory\");\n  }\n  return result;\n}\n\nuint32_t enc_untrusted_sleep(uint32_t seconds) {\n  MessageWriter input;\n  input.Push<uint32_t>(seconds);\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,\n                                                &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_sleep\", 2);\n\n  // Returns sleep's return value directly since it doesn't set errno.\n  return output.next<uint32_t>();\n}\n\nint enc_untrusted_nanosleep(const struct timespec *req, struct timespec *rem) {\n  struct kLinux_timespec klinux_req;\n  if (!TokLinuxtimespec(req, &klinux_req)) {\n    errno = EINVAL;\n    return -1;\n  }\n  struct kLinux_timespec klinux_rem;\n\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_nanosleep, &klinux_req, &klinux_rem);\n  FromkLinuxtimespec(&klinux_rem, rem);\n  return result;\n}\n\nint enc_untrusted_clock_gettime(clockid_t clk_id, struct timespec *tp) {\n  clockid_t klinux_clk_id = TokLinuxClockId(clk_id);\n  if (klinux_clk_id == -1) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int64_t>(klinux_clk_id);\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kClockGettimeHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_clock_gettime\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  struct kLinux_timespec klinux_tp = output.next<struct kLinux_timespec>();\n\n  // clock_gettime returns -1 on error and sets the errno.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  FromkLinuxtimespec(&klinux_tp, tp);\n  return result;\n}\n\nint enc_untrusted_clock_getcpuclockid(pid_t pid, clockid_t *clock_id) {\n  MessageWriter input;\n  input.Push<uint32_t>(pid);\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kGetCpuClockIdHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getcpuclockid\", 2);\n\n  // clock_getcpuclockid returns an errno value directly, without setting errno.\n  // The value must still be translated in order to be interpreted.\n  int klinux_errno_result = output.next<int32_t>();\n  if (klinux_errno_result != 0) {\n    return FromkLinuxErrorNumber(klinux_errno_result);\n  }\n\n  clockid_t klinux_clk_id = output.next<uint64_t>();\n  *clock_id = FromkLinuxClockId(klinux_clk_id);\n  return 0;\n}\n\nint enc_untrusted_bind(int sockfd, const struct sockaddr *addr,\n                       socklen_t addrlen) {\n  socklen_t klinux_sock_len =\n      std::max(std::max(sizeof(klinux_sockaddr_un), sizeof(klinux_sockaddr_in)),\n               sizeof(klinux_sockaddr_in6));\n  auto klinux_sock = absl::make_unique<char[]>(klinux_sock_len);\n\n  if (!TokLinuxSockAddr(addr, addrlen,\n                        reinterpret_cast<klinux_sockaddr *>(klinux_sock.get()),\n                        &klinux_sock_len, TrustedPrimitives::BestEffortAbort)) {\n    errno = EINVAL;\n    return -1;\n  }\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_bind,\n                                             sockfd, klinux_sock.get(),\n                                             klinux_sock_len);\n}\n\nint enc_untrusted_connect(int sockfd, const struct sockaddr *addr,\n                          socklen_t addrlen) {\n  socklen_t klinux_sock_len =\n      std::max(std::max(sizeof(klinux_sockaddr_un), sizeof(klinux_sockaddr_in)),\n               sizeof(klinux_sockaddr_in6));\n  auto klinux_sock = absl::make_unique<char[]>(klinux_sock_len);\n\n  if (!TokLinuxSockAddr(addr, addrlen,\n                        reinterpret_cast<klinux_sockaddr *>(klinux_sock.get()),\n                        &klinux_sock_len, TrustedPrimitives::BestEffortAbort)) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_connect,\n                                             sockfd, klinux_sock.get(),\n                                             klinux_sock_len);\n}\n\nssize_t enc_untrusted_sendmsg(int sockfd, const struct msghdr *msg, int flags) {\n  size_t total_message_size = CalculateTotalMessageSize(msg);\n  std::unique_ptr<char[]> msg_iov_buffer(new char[total_message_size]);\n  size_t copied_bytes = 0;\n  for (int i = 0; i < msg->msg_iovlen; ++i) {\n    memcpy(msg_iov_buffer.get() + copied_bytes, msg->msg_iov[i].iov_base,\n           msg->msg_iov[i].iov_len);\n    copied_bytes += msg->msg_iov[i].iov_len;\n  }\n\n  MessageWriter input;\n  input.Push(sockfd);\n  input.PushByReference(Extent{msg->msg_name, msg->msg_namelen});\n  input.PushByReference(Extent{msg_iov_buffer.get(), total_message_size});\n  input.PushByReference(Extent{msg->msg_control, msg->msg_controllen});\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kSendMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_sendmsg\", 2);\n\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n  // sendmsg() returns the number of characters sent. On error, -1 is returned,\n  // with errno set to indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n\nssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  size_t total_buffer_size = CalculateTotalMessageSize(msg);\n\n  MessageWriter input;\n  input.Push(sockfd);\n  input.Push<uint64_t>(msg->msg_namelen);\n  input.Push<uint64_t>(total_buffer_size);\n  input.Push<uint64_t>(msg->msg_controllen);\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,\n                           /*match_exact_params=*/false);\n\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n\n  // recvmsg() returns the number of characters received. On error, -1 is\n  // returned, with errno set to indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  if (result > total_buffer_size) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_recvmsg: result exceeds requested\");\n  }\n\n  auto msg_name_extent = output.next();\n  // The returned |msg_namelen| should not exceed the buffer size.\n  if (msg_name_extent.size() <= msg->msg_namelen) {\n    msg->msg_namelen = msg_name_extent.size();\n  }\n  memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);\n\n  // A single buffer is passed from the untrusted side, copy it into the\n  // scattered buffers inside the enclave.\n  auto msg_iov_extent = output.next();\n  size_t total_bytes = msg_iov_extent.size();\n  size_t bytes_copied = 0;\n  for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {\n    size_t bytes_to_copy =\n        std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);\n    memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,\n           bytes_to_copy);\n    bytes_copied += bytes_to_copy;\n  }\n\n  auto msg_control_extent = output.next();\n  // The returned |msg_controllen| should not exceed the buffer size.\n  if (msg_control_extent.size() <= msg->msg_controllen) {\n    msg->msg_controllen = msg_control_extent.size();\n  }\n  memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);\n\n  return result;\n}\n\nint enc_untrusted_getsockname(int sockfd, struct sockaddr *addr,\n                              socklen_t *addrlen) {\n  if (!addr || !addrlen) {\n    errno = EFAULT;\n    return -1;\n  }\n  // Guard against -1 being passed as addrlen even though it's unsigned.\n  if (*addrlen == 0 || *addrlen > INT32_MAX) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kGetSocknameHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getsockname\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n\n  // getsockname() returns 0 on success. On error, -1 is returned, with errno\n  // set to indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto klinux_sockaddr_buf = output.next();\n  const struct klinux_sockaddr *klinux_addr =\n      klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n  if (!FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), addr,\n                          addrlen, TrustedPrimitives::BestEffortAbort)) {\n    errno = EFAULT;\n    return -1;\n  }\n  return result;\n}\n\nint enc_untrusted_accept(int sockfd, struct sockaddr *addr,\n                         socklen_t *addrlen) {\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kAcceptHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_accept\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n\n  // accept() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto klinux_sockaddr_buf = output.next();\n  const struct klinux_sockaddr *klinux_addr =\n      klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n  FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), addr, addrlen,\n                     TrustedPrimitives::BestEffortAbort);\n  return result;\n}\n\nint enc_untrusted_getpeername(int sockfd, struct sockaddr *addr,\n                              socklen_t *addrlen) {\n  if (!addr || !addrlen) {\n    errno = EFAULT;\n    return -1;\n  }\n  // Guard against -1 being passed as addrlen even though it's unsigned.\n  if (*addrlen == 0 || *addrlen > INT32_MAX) {\n    errno = EINVAL;\n    return -1;\n  }\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kGetPeernameHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getpeername\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n\n  // getpeername() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto klinux_sockaddr_buf = output.next();\n  const struct klinux_sockaddr *klinux_addr =\n      klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n  FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), addr, addrlen,\n                     TrustedPrimitives::BestEffortAbort);\n  return result;\n}\n\nssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  // recvfrom() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  if (result > len) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_recvfrom: result exceeds requested\");\n  }\n\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), std::min(len, buffer_received.size()));\n\n  // If |src_addr| is not NULL, and the underlying protocol provides the source\n  // address, this source address is filled in. When |src_addr| is NULL, nothing\n  // is filled in; in this case, |addrlen| is not used, and should also be NULL.\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n\n  return result;\n}\n\nint enc_untrusted_select(int nfds, fd_set *readfds, fd_set *writefds,\n                         fd_set *exceptfds, struct timeval *timeout) {\n  struct klinux_fd_set klinux_readfds, klinux_writefds, klinux_exceptfds;\n  struct kLinux_timeval klinux_timeout;\n\n  TokLinuxFdSet(readfds, &klinux_readfds);\n  TokLinuxFdSet(writefds, &klinux_writefds);\n  TokLinuxFdSet(exceptfds, &klinux_exceptfds);\n  TokLinuxtimeval(timeout, &klinux_timeout);\n\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_select, nfds, &klinux_readfds, &klinux_writefds,\n      &klinux_exceptfds, &klinux_timeout);\n\n  FromkLinuxFdSet(&klinux_readfds, readfds);\n  FromkLinuxFdSet(&klinux_writefds, writefds);\n  FromkLinuxFdSet(&klinux_exceptfds, exceptfds);\n  return result;\n}\n\nint enc_untrusted_gettimeofday(struct timeval *tv, struct timezone *tz) {\n  struct kLinux_timeval ktv;\n  TokLinuxtimeval(tv, &ktv);\n\n  // We do not convert timezone to a klinux value since this struct is expected\n  // to be identical across enclave boundary. Besides, the use of the timezone\n  // structure is obsolete; the tz argument should normally be specified as\n  // NULL.\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_gettimeofday, &ktv, tz);\n  FromkLinuxtimeval(&ktv, tv);\n  return result;\n}\n\nint enc_untrusted_fsync(int fd) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fsync,\n                                             fd);\n}\n\nint enc_untrusted_raise(int sig) {\n  int klinux_sig = TokLinuxSignalNumber(sig);\n  if (klinux_sig < 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(klinux_sig);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(::asylo::host_call::kRaiseHandler,\n                                              &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_raise\", 2);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n\nint enc_untrusted_getsockopt(int sockfd, int level, int optname, void *optval,\n                             socklen_t *optlen) {\n  if (!optval || !optlen || *optlen == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<int>(level);\n  input.Push<int>(TokLinuxOptionName(level, optname));\n  input.PushByReference(Extent{reinterpret_cast<char *>(optval), *optlen});\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kGetSockOptHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getsockopt\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  Extent opt_received = output.next();\n\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  // The returned |optlen| should not exceed the buffer size.\n  if (opt_received.size() <= *optlen) {\n    *optlen = opt_received.size();\n  }\n  memcpy(optval, opt_received.data(), *optlen);\n  return result;\n}\n\nint enc_untrusted_getitimer(int which, struct itimerval *curr_value) {\n  struct klinux_itimerval klinux_curr_value {};\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_getitimer, TokLinuxItimerType(which),\n      &klinux_curr_value);\n\n  if (!curr_value || !FromkLinuxItimerval(&klinux_curr_value, curr_value)) {\n    errno = EFAULT;\n    return -1;\n  }\n  return result;\n}\n\nint enc_untrusted_setitimer(int which, const struct itimerval *new_value,\n                            struct itimerval *old_value) {\n  struct klinux_itimerval klinux_new_value {};\n  struct klinux_itimerval klinux_old_value {};\n  if (!TokLinuxItimerval(new_value, &klinux_new_value)) {\n    errno = EFAULT;\n    return -1;\n  }\n\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_setitimer, TokLinuxItimerType(which),\n      &klinux_new_value, &klinux_old_value);\n\n  if (old_value != nullptr &&\n      !FromkLinuxItimerval(&klinux_old_value, old_value)) {\n    errno = EFAULT;\n    return -1;\n  }\n  return result;\n}\n\nclock_t enc_untrusted_times(struct tms *buf) {\n  struct kLinux_tms klinux_buf {};\n  int64_t result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_times, &klinux_buf);\n\n  if (!FromkLinuxtms(&klinux_buf, buf)) {\n    errno = EFAULT;\n    return -1;\n  }\n  return static_cast<clock_t>(result);\n}\n\nint enc_untrusted_getaddrinfo(const char *node, const char *service,\n                              const struct addrinfo *hints,\n                              struct addrinfo **res) {\n  MessageWriter input;\n  input.PushByReference(Extent{node, (node != nullptr) ? strlen(node) + 1 : 0});\n  input.PushByReference(\n      Extent{service, (service != nullptr) ? strlen(service) + 1 : 0});\n  if (hints != nullptr) {\n    input.Push<int>(TokLinuxAddressInfoFlag(hints->ai_flags));\n    input.Push<int>(TokLinuxAfFamily(hints->ai_family));\n    input.Push<int>(TokLinuxSocketType(hints->ai_socktype));\n    input.Push<int>(hints->ai_protocol);\n  }\n\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kGetAddrInfoHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getaddrinfo\", 3,\n                           /*match_exact_params=*/false);\n\n  int klinux_ret = output.next<int>();\n  int klinux_errno = output.next<int>();\n\n  int ret = FromkLinuxAddressInfoError(klinux_ret);\n  if (ret != 0) {\n    if (ret == EAI_SYSTEM) {\n      errno = FromkLinuxErrorNumber(klinux_errno);\n    }\n    return ret;\n  }\n\n  if (!asylo::host_call::DeserializeAddrinfo(\n          &output, res, TrustedPrimitives::BestEffortAbort)) {\n    TrustedPrimitives::DebugPuts(\n        \"enc_untrusted_getaddrinfo: Invalid addrinfo in response.\");\n    return -1;\n  }\n  return 0;\n}\n\nvoid enc_freeaddrinfo(struct addrinfo *res) {\n  struct addrinfo *prev_info = nullptr;\n  for (struct addrinfo *info = res; info != nullptr; info = info->ai_next) {\n    if (prev_info) free(prev_info);\n    if (info->ai_addr) free(info->ai_addr);\n    if (info->ai_canonname) free(info->ai_canonname);\n    prev_info = info;\n  }\n  if (prev_info) free(prev_info);\n}\n\nint enc_untrusted_poll(struct pollfd *fds, nfds_t nfds, int timeout) {\n  auto klinux_fds = absl::make_unique<struct klinux_pollfd[]>(nfds);\n  for (int i = 0; i < nfds; ++i) {\n    if (!TokLinuxPollfd(&fds[i], &klinux_fds[i])) {\n      errno = EFAULT;\n      return -1;\n    }\n  }\n\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_poll, klinux_fds.get(),\n      static_cast<uint64_t>(nfds), timeout);\n\n  if (result < 0) {\n    return result;\n  }\n\n  for (int i = 0; i < nfds; ++i) {\n    if (!FromkLinuxPollfd(&klinux_fds[i], &fds[i])) {\n      errno = EFAULT;\n      return -1;\n    }\n  }\n  return result;\n}\n\nint enc_untrusted_epoll_create(int size) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_epoll_create, size);\n}\n\nint enc_untrusted_utimes(const char *filename, const struct timeval times[2]) {\n  struct kLinux_timeval klinux_times[2];\n  if (!TokLinuxtimeval(&times[0], &klinux_times[0]) ||\n      !TokLinuxtimeval(&times[1], &klinux_times[1])) {\n    errno = EBADE;\n    return -1;\n  }\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_utimes,\n                                             filename, klinux_times);\n}\n\nint enc_untrusted_utime(const char *filename, const struct utimbuf *times) {\n  struct kLinux_utimbuf klinux_times {};\n\n  // We do not check the return value of the conversion function since utimbuf\n  // is allowed to be null.\n  TokLinuxutimbuf(times, &klinux_times);\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_utime,\n                                             filename, &klinux_times);\n}\n\nint enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}\n\nconst char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,\n                                    socklen_t size) {\n  if (!src || !dst) {\n    errno = EFAULT;\n    return nullptr;\n  }\n  size_t src_size = 0;\n  if (af == AF_INET) {\n    src_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    src_size = sizeof(struct in6_addr);\n  } else {\n    errno = EAFNOSUPPORT;\n    return nullptr;\n  }\n\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});\n  input.Push(size);\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetNtopHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_ntop\", 2);\n\n  auto result = output.next();\n  int klinux_errno = output.next<int>();\n  if (result.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n\n  memcpy(dst, result.data(),\n         std::min(static_cast<size_t>(size),\n                  static_cast<size_t>(INET6_ADDRSTRLEN)));\n  return dst;\n}\n\nint enc_untrusted_sigprocmask(int how, const sigset_t *set, sigset_t *oldset) {\n  klinux_sigset_t klinux_set;\n  if (!TokLinuxSigset(set, &klinux_set)) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  int klinux_how = TokLinuxSigMaskAction(how);\n  if (klinux_how == -1) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(klinux_how);\n  input.Push<klinux_sigset_t>(klinux_set);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kSigprocmaskHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_sigprocmask\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  // sigprocmask() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  klinux_sigset_t klinux_oldset = output.next<klinux_sigset_t>();\n  if (oldset != nullptr) {\n    if (!FromkLinuxSigset(&klinux_oldset, oldset)) {\n      errno = EINVAL;\n      return -1;\n    }\n  }\n  return result;\n}\n\nunsigned int enc_untrusted_if_nametoindex(const char *ifname) {\n  MessageWriter input;\n  input.PushString(ifname);\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kIfNameToIndexHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_nametoindex\", 2);\n\n  auto result = output.next<unsigned int>();\n  int klinux_errno = output.next<int>();\n  if (result == 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n\nchar *enc_untrusted_if_indextoname(unsigned int ifindex, char *ifname) {\n  if (!ifname) {\n    return nullptr;\n  }\n\n  MessageWriter input;\n  input.Push(ifindex);\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kIfIndexToNameHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_indextoname\", 2);\n\n  Extent ifname_buffer = output.next();\n  memcpy(ifname, ifname_buffer.As<char>(),\n         std::min(ifname_buffer.size(), static_cast<size_t>(IF_NAMESIZE)));\n  int klinux_errno = output.next<int>();\n  if (ifname_buffer.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return ifname;\n}\n\nint enc_untrusted_epoll_ctl(int epfd, int op, int fd,\n                            struct epoll_event *event) {\n  struct klinux_epoll_event klinux_event_tmp {};\n  if (event != nullptr && !TokLinuxEpollEvent(event, &klinux_event_tmp)) {\n    errno = EINVAL;\n    return -1;\n  }\n  int klinux_op = TokLinuxEpollCtlOp(op);\n  if (klinux_op == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  struct klinux_epoll_event *klinux_event =\n      (event != nullptr) ? &klinux_event_tmp : nullptr;\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_epoll_ctl,\n                                             epfd, klinux_op, fd, klinux_event);\n}\n\nint enc_untrusted_epoll_wait(int epfd, struct epoll_event *events,\n                             int maxevents, int timeout) {\n  if (maxevents <= 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  auto klinux_events =\n      absl::make_unique<struct klinux_epoll_event[]>(maxevents);\n\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_epoll_wait, epfd, klinux_events.get(), maxevents,\n      timeout);\n\n  // Only process epoll events if syscall was successful.\n  if (result == -1) {\n    // errno is already set by the system_call library at this point for a\n    // return value of -1.\n    return result;\n  }\n  if (result > maxevents) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_epoll_wait: result found to be greater than maxevents \"\n        \"supplied.\");\n  }\n\n  for (int i = 0; i < result; i++) {\n    if (!FromkLinuxEpollEvent(&klinux_events.get()[i], &events[i])) {\n      errno = EBADE;\n      return -1;\n    }\n  }\n  return result;\n}\n\nint enc_untrusted_getifaddrs(struct ifaddrs **ifap) {\n  MessageWriter input;\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kGetIfAddrsHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getifaddrs\", 3,\n                           /*match_exact_params=*/false);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  if (!asylo::host_call::DeserializeIfAddrs(\n          &output, ifap, TrustedPrimitives::BestEffortAbort)) {\n    TrustedPrimitives::DebugPuts(\n        \"enc_untrusted_getifaddrs: Invalid ifaddrs in response.\");\n    return -1;\n  }\n  return 0;\n}\n\nvoid enc_freeifaddrs(struct ifaddrs *ifa) {\n  asylo::host_call::FreeDeserializedIfAddrs(ifa);\n}\n\nint enc_untrusted_getrusage(int who, struct rusage *usage) {\n  struct klinux_rusage klinux_usage {};\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_getrusage, TokLinuxRusageTarget(who),\n      &klinux_usage);\n\n  if (result != -1) {\n    if (!FromkLinuxRusage(&klinux_usage, usage)) {\n      errno = EINVAL;\n      return -1;\n    }\n  }\n  return result;\n}\n\npid_t enc_untrusted_wait3(int *status, int options, struct rusage *rusage) {\n  int klinux_status;\n  struct klinux_rusage klinux_usage;\n  pid_t result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_wait4, /*pid=*/-1, &klinux_status,\n      TokLinuxWaitOption(options), &klinux_usage);\n\n  if (status) {\n    *status = FromkLinuxToNewlibWstatus(klinux_status);\n  }\n  if (rusage) {\n    if (!FromkLinuxRusage(&klinux_usage, rusage)) {\n      errno = EINVAL;\n      return -1;\n    }\n  }\n  return result;\n}\n\npid_t enc_untrusted_waitpid(pid_t pid, int *status, int options) {\n  int klinux_status;\n  pid_t result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_wait4, pid, &klinux_status,\n      TokLinuxWaitOption(options), /*rusage=*/nullptr);\n\n  if (status) {\n    *status = FromkLinuxToNewlibWstatus(klinux_status);\n  }\n  return result;\n}\n\nint enc_untrusted_uname(struct utsname *buf) {\n  struct klinux_utsname klinux_buf {};\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_uname, &klinux_buf);\n  if (result != 0) {\n    return result;\n  }\n\n  if (!FromkLinuxUtsName(&klinux_buf, buf)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_uname: Returned an ill-formed utsname.\");\n  }\n  return 0;\n}\n\nstruct passwd *enc_untrusted_getpwuid(uid_t uid) {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uid_t>(uid);\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kGetPwUidHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getpwuid\", 1,\n                           /*match_exact_params=*/false);\n\n  int klinux_errno = output.next<int>();\n  if (output.size() == 1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n\n  // Store the struct passwd members in a static passwd_holder, and direct the\n  // pointers in global_passwd to those members.\n  static struct passwd_holder passwd_buffers;\n  if (!DeserializePasswd(&output, &passwd_buffers) ||\n      !PasswdHolderToPasswd(&passwd_buffers, &global_passwd)) {\n    errno = EFAULT;\n    return nullptr;\n  }\n\n  return &global_passwd;\n}\n\nvoid enc_untrusted_hex_dump(const void *buf, size_t nbytes) {\n  MessageWriter input;\n  MessageReader output;\n  input.PushByReference(Extent{reinterpret_cast<const char *>(buf), nbytes});\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kHexDumpHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_hex_dump\", 2);\n}\n\nvoid enc_untrusted_syslog(int priority, const char *message, int len) {\n  EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_syslog,\n                                      TokLinuxSyslogPriority(priority), message,\n                                      len);\n}\n\nvoid enc_untrusted_openlog(const char *ident, int option, int facility) {\n  MessageWriter input;\n  MessageReader output;\n  input.PushString(ident);\n  input.Push<int>(TokLinuxSyslogOption(option));\n  input.Push<int>(TokLinuxSyslogFacility(facility));\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kOpenLogHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_openlog\", 1);\n}\n\nint enc_untrusted_inotify_read(int fd, size_t count, char **serialized_events,\n                               size_t *serialized_events_len) {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<int>(fd);\n  input.Push<uint64_t>(count);\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInotifyReadHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inotify_read\", 2,\n                           /*match_exact_params=*/false);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  Extent serialized_buf = output.next();\n  *serialized_events_len = serialized_buf.size();\n\n  // The caller to this host call owns memory pointed by |*serialized_events|.\n  *serialized_events = reinterpret_cast<char *>(malloc(*serialized_events_len));\n  if (!serialized_events) {\n    errno = ENOMEM;\n    return -1;\n  }\n  memcpy(*serialized_events, serialized_buf.As<char>(), *serialized_events_len);\n  return result;\n}\n\nint enc_untrusted_ioctl1(int fd, uint64_t request) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_ioctl, fd,\n                                             request);\n}\n\n}  // extern \"C\"\n"], "fixing_code": ["/*\n *\n * Copyright 2019 Asylo authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n#include \"asylo/platform/host_call/trusted/host_calls.h\"\n\n#include <errno.h>\n#include <ifaddrs.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <signal.h>\n#include <sys/statfs.h>\n\n#include <algorithm>\n\n#include \"asylo/platform/host_call/exit_handler_constants.h\"\n#include \"asylo/platform/host_call/serializer_functions.h\"\n#include \"asylo/platform/primitives/trusted_primitives.h\"\n#include \"asylo/platform/system_call/type_conversions/types_functions.h\"\n\nusing ::asylo::host_call::NonSystemCallDispatcher;\nusing ::asylo::primitives::Extent;\nusing ::asylo::primitives::MessageReader;\nusing ::asylo::primitives::MessageWriter;\nusing ::asylo::primitives::TrustedPrimitives;\n\nvoid CheckStatusAndParamCount(const asylo::primitives::PrimitiveStatus &status,\n                              const MessageReader &output, const char *name,\n                              int expected_params, bool match_exact_params) {\n  if (!status.ok()) {\n    std::string message = absl::StrCat(\"Host call '\", name, \"' failed.\");\n    TrustedPrimitives::BestEffortAbort(message.c_str());\n  }\n\n  if (!match_exact_params) {\n    if (output.size() < expected_params) {\n      std::string message = absl::StrCat(\n          \"Host call '\", name, \"': Expected at least \", expected_params,\n          \" parameters on the MessageReader, found \", output.size());\n      TrustedPrimitives::BestEffortAbort(message.c_str());\n    }\n  } else {\n    if (output.size() != expected_params) {\n      std::string message = absl::StrCat(\n          \"Host call '\", name, \"': Expected \", expected_params,\n          \" parameters on the MessageReader, found \", output.size());\n      TrustedPrimitives::BestEffortAbort(message.c_str());\n    }\n  }\n}\n\nnamespace {\n\n// A global passwd struct. The address of it is used as the return value of\n// getpwuid.\nstruct passwd global_passwd;\n\nsize_t CalculateTotalMessageSize(const struct msghdr *msg) {\n  size_t total_message_size = 0;\n  for (int i = 0; i < msg->msg_iovlen; ++i) {\n    total_message_size += msg->msg_iov[i].iov_len;\n  }\n  return total_message_size;\n}\n\n#define PASSWD_HOLDER_FIELD_LENGTH 1024\n\n// Struct for storing the buffers needed by struct passwd members.\nstruct passwd_holder {\n  char pw_name[PASSWD_HOLDER_FIELD_LENGTH];\n  char pw_passwd[PASSWD_HOLDER_FIELD_LENGTH];\n  uid_t pw_uid;\n  gid_t pw_gid;\n  char pw_gecos[PASSWD_HOLDER_FIELD_LENGTH];\n  char pw_dir[PASSWD_HOLDER_FIELD_LENGTH];\n  char pw_shell[PASSWD_HOLDER_FIELD_LENGTH];\n};\n\nbool DeserializePasswd(MessageReader *reader,\n                       struct passwd_holder *passwd_buffers) {\n  if (!reader || !passwd_buffers) {\n    return false;\n  }\n  if (reader->size() < 7) {\n    return false;\n  }\n\n  auto pw_name_buf = reader->next();\n  auto pw_passwd_buf = reader->next();\n  auto pw_uid = reader->next<uid_t>();\n  auto pw_gid = reader->next<gid_t>();\n  auto pw_gecos_buf = reader->next();\n  auto pw_dir_buf = reader->next();\n  auto pw_shell_buf = reader->next();\n\n  strncpy(passwd_buffers->pw_name, pw_name_buf.As<char>(),\n          std::min(sizeof(passwd_buffers->pw_name), pw_name_buf.size()));\n  strncpy(passwd_buffers->pw_passwd, pw_passwd_buf.As<char>(),\n          std::min(sizeof(passwd_buffers->pw_passwd), pw_passwd_buf.size()));\n  passwd_buffers->pw_uid = pw_uid;\n  passwd_buffers->pw_gid = pw_gid;\n  strncpy(passwd_buffers->pw_gecos, pw_gecos_buf.As<char>(),\n          std::min(sizeof(passwd_buffers->pw_gecos), pw_gecos_buf.size()));\n  strncpy(passwd_buffers->pw_dir, pw_dir_buf.As<char>(),\n          std::min(sizeof(passwd_buffers->pw_dir), pw_dir_buf.size()));\n  strncpy(passwd_buffers->pw_shell, pw_shell_buf.As<char>(),\n          std::min(sizeof(passwd_buffers->pw_shell), pw_shell_buf.size()));\n  return true;\n}\n\nbool PasswdHolderToPasswd(struct passwd_holder *passwd_in,\n                          struct passwd *passwd_out) {\n  if (!passwd_in || !passwd_out) {\n    return false;\n  }\n\n  passwd_out->pw_name = passwd_in->pw_name;\n  passwd_out->pw_passwd = passwd_in->pw_passwd;\n  passwd_out->pw_uid = passwd_in->pw_uid;\n  passwd_out->pw_gid = passwd_in->pw_gid;\n  passwd_out->pw_gecos = passwd_in->pw_gecos;\n  passwd_out->pw_dir = passwd_in->pw_dir;\n  passwd_out->pw_shell = passwd_in->pw_shell;\n  return true;\n}\n\n}  // namespace\n\nextern \"C\" {\n\nint enc_untrusted_access(const char *path_name, int mode) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_access,\n                                             path_name, mode);\n}\n\npid_t enc_untrusted_getpid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_getpid);\n}\n\npid_t enc_untrusted_getppid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_getppid);\n}\n\npid_t enc_untrusted_setsid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_setsid);\n}\n\nuid_t enc_untrusted_getuid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_getuid);\n}\n\ngid_t enc_untrusted_getgid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_getgid);\n}\n\nuid_t enc_untrusted_geteuid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_geteuid);\n}\n\ngid_t enc_untrusted_getegid() {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_getegid);\n}\n\nint enc_untrusted_kill(pid_t pid, int sig) {\n  int klinux_sig = TokLinuxSignalNumber(sig);\n  if (klinux_sig < 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_kill, pid,\n                                             klinux_sig);\n}\n\nint enc_untrusted_link(const char *oldpath, const char *newpath) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_link,\n                                             oldpath, newpath);\n}\n\noff_t enc_untrusted_lseek(int fd, off_t offset, int whence) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_lseek, fd,\n                                             offset, whence);\n}\n\nint enc_untrusted_mkdir(const char *pathname, mode_t mode) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_mkdir,\n                                             pathname, mode);\n}\n\nint enc_untrusted_open(const char *pathname, int flags, ...) {\n  int mode = 0;\n  if (flags & O_CREAT) {\n    va_list ap;\n    va_start(ap, flags);\n    mode = va_arg(ap, mode_t);\n    va_end(ap);\n  }\n\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_open, pathname, TokLinuxFileStatusFlag(flags),\n      TokLinuxFileModeFlag(mode));\n}\n\nint enc_untrusted_unlink(const char *pathname) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_unlink,\n                                             pathname);\n}\n\nint enc_untrusted_rename(const char *oldpath, const char *newpath) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_rename,\n                                             oldpath, newpath);\n}\n\nssize_t enc_untrusted_read(int fd, void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_read, fd, buf, count));\n}\n\nssize_t enc_untrusted_write(int fd, const void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_write, fd, buf, count));\n}\n\nint enc_untrusted_symlink(const char *target, const char *linkpath) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_symlink,\n                                             target, linkpath);\n}\n\nssize_t enc_untrusted_readlink(const char *pathname, char *buf, size_t bufsiz) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_readlink, pathname, buf, bufsiz));\n}\n\nint enc_untrusted_truncate(const char *path, off_t length) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_truncate,\n                                             path, length);\n}\n\nint enc_untrusted_ftruncate(int fd, off_t length) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_ftruncate,\n                                             fd, length);\n}\n\nint enc_untrusted_rmdir(const char *path) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_rmdir,\n                                             path);\n}\n\nint enc_untrusted_pipe2(int pipefd[2], int flags) {\n  if (flags & ~(O_CLOEXEC | O_DIRECT | O_NONBLOCK)) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_pipe2, pipefd, TokLinuxFileStatusFlag(flags));\n}\n\nint enc_untrusted_socket(int domain, int type, int protocol) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_socket, TokLinuxAfFamily(domain),\n      TokLinuxSocketType(type), protocol);\n}\n\nint enc_untrusted_listen(int sockfd, int backlog) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_listen,\n                                             sockfd, backlog);\n}\n\nint enc_untrusted_shutdown(int sockfd, int how) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_shutdown,\n                                             sockfd, how);\n}\n\nssize_t enc_untrusted_send(int sockfd, const void *buf, size_t len, int flags) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_sendto,\n                                             sockfd, buf, len, flags,\n                                             /*dest_addr=*/nullptr,\n                                             /*addrlen=*/0);\n}\n\nint enc_untrusted_fcntl(int fd, int cmd, ... /* arg */) {\n  // We do not currently support file locks in Asylo, so arg is not expected to\n  // be a pointer to struct flock.\n  int64_t arg = 0;\n  va_list ap;\n  va_start(ap, cmd);\n  arg = va_arg(ap, int64_t);\n  va_end(ap);\n\n  int klinux_cmd = TokLinuxFcntlCommand(cmd);\n  if (klinux_cmd == -1) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  int intarg = arg;\n  switch (cmd) {\n    case F_SETFL: {\n      return EnsureInitializedAndDispatchSyscall(\n          asylo::system_call::kSYS_fcntl, fd, klinux_cmd,\n          TokLinuxFileStatusFlag(intarg));\n    }\n    case F_SETFD: {\n      return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fcntl,\n                                                 fd, klinux_cmd,\n                                                 TokLinuxFDFlag(intarg));\n    }\n    case F_GETFL: {\n      int retval = EnsureInitializedAndDispatchSyscall(\n          asylo::system_call::kSYS_fcntl, fd, klinux_cmd, arg);\n      if (retval != -1) {\n        retval = FromkLinuxFileStatusFlag(retval);\n      }\n\n      return retval;\n    }\n    case F_GETFD: {\n      int retval = EnsureInitializedAndDispatchSyscall(\n          asylo::system_call::kSYS_fcntl, fd, klinux_cmd, arg);\n      if (retval != -1) {\n        retval = FromkLinuxFDFlag(retval);\n      }\n      return retval;\n    }\n    case F_GETPIPE_SZ:\n    case F_SETPIPE_SZ: {\n      return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fcntl,\n                                                 fd, klinux_cmd, arg);\n    }\n    // We do not handle the case for F_DUPFD. It is expected to be handled at\n    // a higher abstraction, as we need not exit the enclave for duplicating\n    // the file descriptor.\n    default: {\n      errno = EINVAL;\n      return -1;\n    }\n  }\n}\n\nint enc_untrusted_chown(const char *pathname, uid_t owner, gid_t group) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_chown,\n                                             pathname, owner, group);\n}\n\nint enc_untrusted_fchown(int fd, uid_t owner, gid_t group) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fchown,\n                                             fd, owner, group);\n}\n\nint enc_untrusted_setsockopt(int sockfd, int level, int optname,\n                             const void *optval, socklen_t optlen) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_setsockopt, sockfd, level,\n      TokLinuxOptionName(level, optname), optval, optlen);\n}\n\nint enc_untrusted_flock(int fd, int operation) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_flock, fd,\n                                             TokLinuxFLockOperation(operation));\n}\n\nint enc_untrusted_wait(int *wstatus) {\n  int klinux_wstatus;\n  pid_t ret = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_wait4, /*wpid=*/-1, &klinux_wstatus,\n      /*options=*/0,\n      /*rusage=*/nullptr);\n  *wstatus = FromkLinuxToNewlibWstatus(klinux_wstatus);\n  return ret;\n}\n\nint enc_untrusted_inotify_init1(int flags) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_inotify_init1, TokLinuxInotifyFlag(flags));\n}\n\nint enc_untrusted_inotify_add_watch(int fd, const char *pathname,\n                                    uint32_t mask) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_inotify_add_watch, fd, pathname,\n      TokLinuxInotifyEventMask(mask));\n}\n\nint enc_untrusted_inotify_rm_watch(int fd, int wd) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_inotify_rm_watch, fd, wd);\n}\n\nmode_t enc_untrusted_umask(mode_t mask) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_umask,\n                                             mask);\n}\n\nint enc_untrusted_chmod(const char *path_name, mode_t mode) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_chmod,\n                                             path_name, mode);\n}\n\nint enc_untrusted_fchmod(int fd, mode_t mode) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fchmod,\n                                             fd, mode);\n}\n\nint enc_untrusted_sched_yield() {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_sched_yield);\n}\n\nint enc_untrusted_sched_getaffinity(pid_t pid, size_t cpusetsize,\n                                    cpu_set_t *mask) {\n  klinux_cpu_set_t klinux_mask{};\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_sched_getaffinity, pid,\n      static_cast<uint64_t>(cpusetsize), &klinux_mask);\n  // On success, the raw getaffinity syscall returns the size of the cpumask_t\n  // data type, To mimic the glibc behavior, we return 0 on success and -1 on\n  // failure. See https://linux.die.net/man/2/sched_getaffinity, under \"notes\".\n  if (result < 0) {\n    return -1;\n  }\n  if (!FromkLinuxCpuSet(&klinux_mask, mask)) {\n    errno = EFAULT;\n    return -1;\n  }\n  return 0;\n}\n\nint enc_untrusted_pread64(int fd, void *buf, size_t count, off_t offset) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_pread64,\n                                             fd, buf, count, offset);\n}\n\nint enc_untrusted_pwrite64(int fd, const void *buf, size_t count,\n                           off_t offset) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_pwrite64,\n                                             fd, buf, count, offset);\n}\n\nint enc_untrusted_isatty(int fd) {\n  MessageWriter input;\n  input.Push(fd);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kIsAttyHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_isatty\", 2);\n\n  int result = output.next<int>();\n\n  // isatty() returns 1 if fd is an open file descriptor referring to a\n  // terminal; otherwise 0 is returned, and errno is set to indicate the error.\n  if (result == 0) {\n    int klinux_errno = output.next<int>();\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n\nint enc_untrusted_usleep(useconds_t usec) {\n  MessageWriter input;\n  input.Push(usec);\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kUSleepHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_usleep\", 2);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n\n  // usleep() returns 0 on success. On error, -1 is returned, with errno set to\n  // indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n\n  return result;\n}\n\nint enc_untrusted_fstat(int fd, struct stat *statbuf) {\n  struct klinux_stat stat_kernel;\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_fstat, fd, &stat_kernel);\n\n  if (FromkLinuxStat(&stat_kernel, statbuf)) {\n    statbuf->st_mode = FromkLinuxFileModeFlag(stat_kernel.klinux_st_mode);\n  }\n  return result;\n}\n\nint enc_untrusted_fstatfs(int fd, struct statfs *statbuf) {\n  struct klinux_statfs statfs_kernel;\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_fstatfs, fd, &statfs_kernel);\n\n  if (FromkLinuxStatFs(&statfs_kernel, statbuf)) {\n    statbuf->f_flags = FromkLinuxStatFsFlags(statfs_kernel.klinux_f_flags);\n  }\n  return result;\n}\n\nint enc_untrusted_lstat(const char *pathname, struct stat *statbuf) {\n  struct klinux_stat stat_kernel;\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_lstat, pathname, &stat_kernel);\n\n  if (FromkLinuxStat(&stat_kernel, statbuf)) {\n    statbuf->st_mode = FromkLinuxFileModeFlag(stat_kernel.klinux_st_mode);\n  }\n  return result;\n}\n\nint enc_untrusted_stat(const char *pathname, struct stat *statbuf) {\n  struct klinux_stat stat_kernel;\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_stat, pathname, &stat_kernel);\n  if (FromkLinuxStat(&stat_kernel, statbuf)) {\n    statbuf->st_mode = FromkLinuxFileModeFlag(stat_kernel.klinux_st_mode);\n  }\n  return result;\n}\n\nint enc_untrusted_statfs(const char *pathname, struct statfs *statbuf) {\n  struct klinux_statfs statfs_kernel;\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_statfs, pathname, &statfs_kernel);\n\n  if (FromkLinuxStatFs(&statfs_kernel, statbuf)) {\n    statbuf->f_flags = FromkLinuxStatFsFlags(statfs_kernel.klinux_f_flags);\n  }\n  return result;\n}\n\nssize_t enc_untrusted_getxattr(const char *path, const char *name, void *value,\n                               size_t size) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_getxattr,\n                                             path, name, value, size);\n}\n\nssize_t enc_untrusted_lgetxattr(const char *path, const char *name, void *value,\n                                size_t size) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_lgetxattr,\n                                             path, name, value, size);\n}\n\nssize_t enc_untrusted_fgetxattr(int fd, const char *name, void *value,\n                                size_t size) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fgetxattr,\n                                             fd, name, value, size);\n}\n\nint enc_untrusted_setxattr(const char *path, const char *name,\n                           const void *value, size_t size, int flags) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_setxattr,\n                                             path, name, value, size, flags);\n}\n\nint enc_untrusted_lsetxattr(const char *path, const char *name,\n                            const void *value, size_t size, int flags) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_lsetxattr,\n                                             path, name, value, size, flags);\n}\n\nint enc_untrusted_fsetxattr(int fd, const char *name, const void *value,\n                            size_t size, int flags) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fsetxattr,\n                                             fd, name, value, size, flags);\n}\n\nssize_t enc_untrusted_listxattr(const char *path, char *list, size_t size) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_listxattr,\n                                             path, list, size);\n}\n\nssize_t enc_untrusted_llistxattr(const char *path, char *list, size_t size) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_llistxattr, path, list, size);\n}\n\nssize_t enc_untrusted_flistxattr(int fd, char *list, size_t size) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_flistxattr, fd, list, size);\n}\n\nint64_t enc_untrusted_sysconf(int name) {\n  int kLinux_name = TokLinuxSysconfConstant(name);\n  if (kLinux_name == -1) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push(kLinux_name);\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kSysconfHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_sysconf\", 2);\n\n  int64_t result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n\n  return result;\n}\n\nint enc_untrusted_close(int fd) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_close,\n                                             fd);\n}\n\nvoid *enc_untrusted_realloc(void *ptr, size_t size) {\n  MessageWriter input;\n  input.Push(reinterpret_cast<uint64_t>(ptr));\n  input.Push(static_cast<uint64_t>(size));\n\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kReallocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_realloc\", 2);\n\n  void *result = output.next<void *>();\n  int klinux_errno = output.next<int>();\n\n  // realloc only sets the errno (ENOMEM) when output pointer is null and a\n  // non-zero |size| is provided.\n  if (!result && size != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n\n  if (!::asylo::primitives::TrustedPrimitives::IsOutsideEnclave(result, size)) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_realloc: realloc result should be in untrusted \"\n        \"memory\");\n  }\n  return result;\n}\n\nuint32_t enc_untrusted_sleep(uint32_t seconds) {\n  MessageWriter input;\n  input.Push<uint32_t>(seconds);\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,\n                                                &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_sleep\", 2);\n\n  // Returns sleep's return value directly since it doesn't set errno.\n  return output.next<uint32_t>();\n}\n\nint enc_untrusted_nanosleep(const struct timespec *req, struct timespec *rem) {\n  struct kLinux_timespec klinux_req;\n  if (!TokLinuxtimespec(req, &klinux_req)) {\n    errno = EINVAL;\n    return -1;\n  }\n  struct kLinux_timespec klinux_rem;\n\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_nanosleep, &klinux_req, &klinux_rem);\n  FromkLinuxtimespec(&klinux_rem, rem);\n  return result;\n}\n\nint enc_untrusted_clock_gettime(clockid_t clk_id, struct timespec *tp) {\n  clockid_t klinux_clk_id = TokLinuxClockId(clk_id);\n  if (klinux_clk_id == -1) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int64_t>(klinux_clk_id);\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kClockGettimeHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_clock_gettime\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  struct kLinux_timespec klinux_tp = output.next<struct kLinux_timespec>();\n\n  // clock_gettime returns -1 on error and sets the errno.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  FromkLinuxtimespec(&klinux_tp, tp);\n  return result;\n}\n\nint enc_untrusted_clock_getcpuclockid(pid_t pid, clockid_t *clock_id) {\n  MessageWriter input;\n  input.Push<uint32_t>(pid);\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kGetCpuClockIdHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getcpuclockid\", 2);\n\n  // clock_getcpuclockid returns an errno value directly, without setting errno.\n  // The value must still be translated in order to be interpreted.\n  int klinux_errno_result = output.next<int32_t>();\n  if (klinux_errno_result != 0) {\n    return FromkLinuxErrorNumber(klinux_errno_result);\n  }\n\n  clockid_t klinux_clk_id = output.next<uint64_t>();\n  *clock_id = FromkLinuxClockId(klinux_clk_id);\n  return 0;\n}\n\nint enc_untrusted_bind(int sockfd, const struct sockaddr *addr,\n                       socklen_t addrlen) {\n  socklen_t klinux_sock_len =\n      std::max(std::max(sizeof(klinux_sockaddr_un), sizeof(klinux_sockaddr_in)),\n               sizeof(klinux_sockaddr_in6));\n  auto klinux_sock = absl::make_unique<char[]>(klinux_sock_len);\n\n  if (!TokLinuxSockAddr(addr, addrlen,\n                        reinterpret_cast<klinux_sockaddr *>(klinux_sock.get()),\n                        &klinux_sock_len, TrustedPrimitives::BestEffortAbort)) {\n    errno = EINVAL;\n    return -1;\n  }\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_bind,\n                                             sockfd, klinux_sock.get(),\n                                             klinux_sock_len);\n}\n\nint enc_untrusted_connect(int sockfd, const struct sockaddr *addr,\n                          socklen_t addrlen) {\n  socklen_t klinux_sock_len =\n      std::max(std::max(sizeof(klinux_sockaddr_un), sizeof(klinux_sockaddr_in)),\n               sizeof(klinux_sockaddr_in6));\n  auto klinux_sock = absl::make_unique<char[]>(klinux_sock_len);\n\n  if (!TokLinuxSockAddr(addr, addrlen,\n                        reinterpret_cast<klinux_sockaddr *>(klinux_sock.get()),\n                        &klinux_sock_len, TrustedPrimitives::BestEffortAbort)) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_connect,\n                                             sockfd, klinux_sock.get(),\n                                             klinux_sock_len);\n}\n\nssize_t enc_untrusted_sendmsg(int sockfd, const struct msghdr *msg, int flags) {\n  size_t total_message_size = CalculateTotalMessageSize(msg);\n  std::unique_ptr<char[]> msg_iov_buffer(new char[total_message_size]);\n  size_t copied_bytes = 0;\n  for (int i = 0; i < msg->msg_iovlen; ++i) {\n    memcpy(msg_iov_buffer.get() + copied_bytes, msg->msg_iov[i].iov_base,\n           msg->msg_iov[i].iov_len);\n    copied_bytes += msg->msg_iov[i].iov_len;\n  }\n\n  MessageWriter input;\n  input.Push(sockfd);\n  input.PushByReference(Extent{msg->msg_name, msg->msg_namelen});\n  input.PushByReference(Extent{msg_iov_buffer.get(), total_message_size});\n  input.PushByReference(Extent{msg->msg_control, msg->msg_controllen});\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kSendMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_sendmsg\", 2);\n\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n  // sendmsg() returns the number of characters sent. On error, -1 is returned,\n  // with errno set to indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n\nssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  size_t total_buffer_size = CalculateTotalMessageSize(msg);\n\n  MessageWriter input;\n  input.Push(sockfd);\n  input.Push<uint64_t>(msg->msg_namelen);\n  input.Push<uint64_t>(total_buffer_size);\n  input.Push<uint64_t>(msg->msg_controllen);\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,\n                           /*match_exact_params=*/false);\n\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n\n  // recvmsg() returns the number of characters received. On error, -1 is\n  // returned, with errno set to indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  if (result > total_buffer_size) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_recvmsg: result exceeds requested\");\n  }\n\n  auto msg_name_extent = output.next();\n  // The returned |msg_namelen| should not exceed the buffer size.\n  if (msg_name_extent.size() <= msg->msg_namelen) {\n    msg->msg_namelen = msg_name_extent.size();\n  }\n  memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);\n\n  // A single buffer is passed from the untrusted side, copy it into the\n  // scattered buffers inside the enclave.\n  auto msg_iov_extent = output.next();\n  size_t total_bytes = msg_iov_extent.size();\n  size_t bytes_copied = 0;\n  for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {\n    size_t bytes_to_copy =\n        std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);\n    memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,\n           bytes_to_copy);\n    bytes_copied += bytes_to_copy;\n  }\n\n  auto msg_control_extent = output.next();\n  // The returned |msg_controllen| should not exceed the buffer size.\n  if (msg_control_extent.size() <= msg->msg_controllen) {\n    msg->msg_controllen = msg_control_extent.size();\n  }\n  memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);\n\n  return result;\n}\n\nint enc_untrusted_getsockname(int sockfd, struct sockaddr *addr,\n                              socklen_t *addrlen) {\n  if (!addr || !addrlen) {\n    errno = EFAULT;\n    return -1;\n  }\n  // Guard against -1 being passed as addrlen even though it's unsigned.\n  if (*addrlen == 0 || *addrlen > INT32_MAX) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kGetSocknameHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getsockname\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n\n  // getsockname() returns 0 on success. On error, -1 is returned, with errno\n  // set to indicate the cause of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto klinux_sockaddr_buf = output.next();\n  const struct klinux_sockaddr *klinux_addr =\n      klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n  if (!FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), addr,\n                          addrlen, TrustedPrimitives::BestEffortAbort)) {\n    errno = EFAULT;\n    return -1;\n  }\n  return result;\n}\n\nint enc_untrusted_accept(int sockfd, struct sockaddr *addr,\n                         socklen_t *addrlen) {\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kAcceptHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_accept\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n\n  // accept() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto klinux_sockaddr_buf = output.next();\n  const struct klinux_sockaddr *klinux_addr =\n      klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n  FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), addr, addrlen,\n                     TrustedPrimitives::BestEffortAbort);\n  return result;\n}\n\nint enc_untrusted_getpeername(int sockfd, struct sockaddr *addr,\n                              socklen_t *addrlen) {\n  if (!addr || !addrlen) {\n    errno = EFAULT;\n    return -1;\n  }\n  // Guard against -1 being passed as addrlen even though it's unsigned.\n  if (*addrlen == 0 || *addrlen > INT32_MAX) {\n    errno = EINVAL;\n    return -1;\n  }\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kGetPeernameHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getpeername\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n\n  // getpeername() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  auto klinux_sockaddr_buf = output.next();\n  const struct klinux_sockaddr *klinux_addr =\n      klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n  FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), addr, addrlen,\n                     TrustedPrimitives::BestEffortAbort);\n  return result;\n}\n\nssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  // recvfrom() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  if (result > len) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_recvfrom: result exceeds requested\");\n  }\n\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), std::min(len, buffer_received.size()));\n\n  // If |src_addr| is not NULL, and the underlying protocol provides the source\n  // address, this source address is filled in. When |src_addr| is NULL, nothing\n  // is filled in; in this case, |addrlen| is not used, and should also be NULL.\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n\n  return result;\n}\n\nint enc_untrusted_select(int nfds, fd_set *readfds, fd_set *writefds,\n                         fd_set *exceptfds, struct timeval *timeout) {\n  struct klinux_fd_set klinux_readfds, klinux_writefds, klinux_exceptfds;\n  struct kLinux_timeval klinux_timeout;\n\n  TokLinuxFdSet(readfds, &klinux_readfds);\n  TokLinuxFdSet(writefds, &klinux_writefds);\n  TokLinuxFdSet(exceptfds, &klinux_exceptfds);\n  TokLinuxtimeval(timeout, &klinux_timeout);\n\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_select, nfds, &klinux_readfds, &klinux_writefds,\n      &klinux_exceptfds, &klinux_timeout);\n\n  FromkLinuxFdSet(&klinux_readfds, readfds);\n  FromkLinuxFdSet(&klinux_writefds, writefds);\n  FromkLinuxFdSet(&klinux_exceptfds, exceptfds);\n  return result;\n}\n\nint enc_untrusted_gettimeofday(struct timeval *tv, struct timezone *tz) {\n  struct kLinux_timeval ktv;\n  TokLinuxtimeval(tv, &ktv);\n\n  // We do not convert timezone to a klinux value since this struct is expected\n  // to be identical across enclave boundary. Besides, the use of the timezone\n  // structure is obsolete; the tz argument should normally be specified as\n  // NULL.\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_gettimeofday, &ktv, tz);\n  FromkLinuxtimeval(&ktv, tv);\n  return result;\n}\n\nint enc_untrusted_fsync(int fd) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_fsync,\n                                             fd);\n}\n\nint enc_untrusted_raise(int sig) {\n  int klinux_sig = TokLinuxSignalNumber(sig);\n  if (klinux_sig < 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(klinux_sig);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(::asylo::host_call::kRaiseHandler,\n                                              &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_raise\", 2);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n\nint enc_untrusted_getsockopt(int sockfd, int level, int optname, void *optval,\n                             socklen_t *optlen) {\n  if (!optval || !optlen || *optlen == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<int>(level);\n  input.Push<int>(TokLinuxOptionName(level, optname));\n  input.PushByReference(Extent{reinterpret_cast<char *>(optval), *optlen});\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kGetSockOptHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getsockopt\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  Extent opt_received = output.next();\n\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  // The returned |optlen| should not exceed the buffer size.\n  if (opt_received.size() <= *optlen) {\n    *optlen = opt_received.size();\n  }\n  memcpy(optval, opt_received.data(), *optlen);\n  return result;\n}\n\nint enc_untrusted_getitimer(int which, struct itimerval *curr_value) {\n  struct klinux_itimerval klinux_curr_value {};\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_getitimer, TokLinuxItimerType(which),\n      &klinux_curr_value);\n\n  if (!curr_value || !FromkLinuxItimerval(&klinux_curr_value, curr_value)) {\n    errno = EFAULT;\n    return -1;\n  }\n  return result;\n}\n\nint enc_untrusted_setitimer(int which, const struct itimerval *new_value,\n                            struct itimerval *old_value) {\n  struct klinux_itimerval klinux_new_value {};\n  struct klinux_itimerval klinux_old_value {};\n  if (!TokLinuxItimerval(new_value, &klinux_new_value)) {\n    errno = EFAULT;\n    return -1;\n  }\n\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_setitimer, TokLinuxItimerType(which),\n      &klinux_new_value, &klinux_old_value);\n\n  if (old_value != nullptr &&\n      !FromkLinuxItimerval(&klinux_old_value, old_value)) {\n    errno = EFAULT;\n    return -1;\n  }\n  return result;\n}\n\nclock_t enc_untrusted_times(struct tms *buf) {\n  struct kLinux_tms klinux_buf {};\n  int64_t result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_times, &klinux_buf);\n\n  if (!FromkLinuxtms(&klinux_buf, buf)) {\n    errno = EFAULT;\n    return -1;\n  }\n  return static_cast<clock_t>(result);\n}\n\nint enc_untrusted_getaddrinfo(const char *node, const char *service,\n                              const struct addrinfo *hints,\n                              struct addrinfo **res) {\n  MessageWriter input;\n  input.PushByReference(Extent{node, (node != nullptr) ? strlen(node) + 1 : 0});\n  input.PushByReference(\n      Extent{service, (service != nullptr) ? strlen(service) + 1 : 0});\n  if (hints != nullptr) {\n    input.Push<int>(TokLinuxAddressInfoFlag(hints->ai_flags));\n    input.Push<int>(TokLinuxAfFamily(hints->ai_family));\n    input.Push<int>(TokLinuxSocketType(hints->ai_socktype));\n    input.Push<int>(hints->ai_protocol);\n  }\n\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kGetAddrInfoHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getaddrinfo\", 3,\n                           /*match_exact_params=*/false);\n\n  int klinux_ret = output.next<int>();\n  int klinux_errno = output.next<int>();\n\n  int ret = FromkLinuxAddressInfoError(klinux_ret);\n  if (ret != 0) {\n    if (ret == EAI_SYSTEM) {\n      errno = FromkLinuxErrorNumber(klinux_errno);\n    }\n    return ret;\n  }\n\n  if (!asylo::host_call::DeserializeAddrinfo(\n          &output, res, TrustedPrimitives::BestEffortAbort)) {\n    TrustedPrimitives::DebugPuts(\n        \"enc_untrusted_getaddrinfo: Invalid addrinfo in response.\");\n    return -1;\n  }\n  return 0;\n}\n\nvoid enc_freeaddrinfo(struct addrinfo *res) {\n  struct addrinfo *prev_info = nullptr;\n  for (struct addrinfo *info = res; info != nullptr; info = info->ai_next) {\n    if (prev_info) free(prev_info);\n    if (info->ai_addr) free(info->ai_addr);\n    if (info->ai_canonname) free(info->ai_canonname);\n    prev_info = info;\n  }\n  if (prev_info) free(prev_info);\n}\n\nint enc_untrusted_poll(struct pollfd *fds, nfds_t nfds, int timeout) {\n  auto klinux_fds = absl::make_unique<struct klinux_pollfd[]>(nfds);\n  for (int i = 0; i < nfds; ++i) {\n    if (!TokLinuxPollfd(&fds[i], &klinux_fds[i])) {\n      errno = EFAULT;\n      return -1;\n    }\n  }\n\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_poll, klinux_fds.get(),\n      static_cast<uint64_t>(nfds), timeout);\n\n  if (result < 0) {\n    return result;\n  }\n\n  for (int i = 0; i < nfds; ++i) {\n    if (!FromkLinuxPollfd(&klinux_fds[i], &fds[i])) {\n      errno = EFAULT;\n      return -1;\n    }\n  }\n  return result;\n}\n\nint enc_untrusted_epoll_create(int size) {\n  return EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_epoll_create, size);\n}\n\nint enc_untrusted_utimes(const char *filename, const struct timeval times[2]) {\n  struct kLinux_timeval klinux_times[2];\n  if (!TokLinuxtimeval(&times[0], &klinux_times[0]) ||\n      !TokLinuxtimeval(&times[1], &klinux_times[1])) {\n    errno = EBADE;\n    return -1;\n  }\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_utimes,\n                                             filename, klinux_times);\n}\n\nint enc_untrusted_utime(const char *filename, const struct utimbuf *times) {\n  struct kLinux_utimbuf klinux_times {};\n\n  // We do not check the return value of the conversion function since utimbuf\n  // is allowed to be null.\n  TokLinuxutimbuf(times, &klinux_times);\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_utime,\n                                             filename, &klinux_times);\n}\n\nint enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}\n\nconst char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,\n                                    socklen_t size) {\n  if (!src || !dst) {\n    errno = EFAULT;\n    return nullptr;\n  }\n  size_t src_size = 0;\n  if (af == AF_INET) {\n    src_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    src_size = sizeof(struct in6_addr);\n  } else {\n    errno = EAFNOSUPPORT;\n    return nullptr;\n  }\n\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});\n  input.Push(size);\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetNtopHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_ntop\", 2);\n\n  auto result = output.next();\n  int klinux_errno = output.next<int>();\n  if (result.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n\n  memcpy(\n      dst, result.data(),\n      std::min({static_cast<size_t>(size), static_cast<size_t>(result.size()),\n                static_cast<size_t>(INET6_ADDRSTRLEN)}));\n  return dst;\n}\n\nint enc_untrusted_sigprocmask(int how, const sigset_t *set, sigset_t *oldset) {\n  klinux_sigset_t klinux_set;\n  if (!TokLinuxSigset(set, &klinux_set)) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  int klinux_how = TokLinuxSigMaskAction(how);\n  if (klinux_how == -1) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  MessageWriter input;\n  input.Push<int>(klinux_how);\n  input.Push<klinux_sigset_t>(klinux_set);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kSigprocmaskHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_sigprocmask\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  // sigprocmask() returns -1 on failure, with errno set to indicate the cause\n  // of the error.\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  klinux_sigset_t klinux_oldset = output.next<klinux_sigset_t>();\n  if (oldset != nullptr) {\n    if (!FromkLinuxSigset(&klinux_oldset, oldset)) {\n      errno = EINVAL;\n      return -1;\n    }\n  }\n  return result;\n}\n\nunsigned int enc_untrusted_if_nametoindex(const char *ifname) {\n  MessageWriter input;\n  input.PushString(ifname);\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kIfNameToIndexHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_nametoindex\", 2);\n\n  auto result = output.next<unsigned int>();\n  int klinux_errno = output.next<int>();\n  if (result == 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}\n\nchar *enc_untrusted_if_indextoname(unsigned int ifindex, char *ifname) {\n  if (!ifname) {\n    return nullptr;\n  }\n\n  MessageWriter input;\n  input.Push(ifindex);\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kIfIndexToNameHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_indextoname\", 2);\n\n  Extent ifname_buffer = output.next();\n  memcpy(ifname, ifname_buffer.As<char>(),\n         std::min(ifname_buffer.size(), static_cast<size_t>(IF_NAMESIZE)));\n  int klinux_errno = output.next<int>();\n  if (ifname_buffer.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return ifname;\n}\n\nint enc_untrusted_epoll_ctl(int epfd, int op, int fd,\n                            struct epoll_event *event) {\n  struct klinux_epoll_event klinux_event_tmp {};\n  if (event != nullptr && !TokLinuxEpollEvent(event, &klinux_event_tmp)) {\n    errno = EINVAL;\n    return -1;\n  }\n  int klinux_op = TokLinuxEpollCtlOp(op);\n  if (klinux_op == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  struct klinux_epoll_event *klinux_event =\n      (event != nullptr) ? &klinux_event_tmp : nullptr;\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_epoll_ctl,\n                                             epfd, klinux_op, fd, klinux_event);\n}\n\nint enc_untrusted_epoll_wait(int epfd, struct epoll_event *events,\n                             int maxevents, int timeout) {\n  if (maxevents <= 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  auto klinux_events =\n      absl::make_unique<struct klinux_epoll_event[]>(maxevents);\n\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_epoll_wait, epfd, klinux_events.get(), maxevents,\n      timeout);\n\n  // Only process epoll events if syscall was successful.\n  if (result == -1) {\n    // errno is already set by the system_call library at this point for a\n    // return value of -1.\n    return result;\n  }\n  if (result > maxevents) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_epoll_wait: result found to be greater than maxevents \"\n        \"supplied.\");\n  }\n\n  for (int i = 0; i < result; i++) {\n    if (!FromkLinuxEpollEvent(&klinux_events.get()[i], &events[i])) {\n      errno = EBADE;\n      return -1;\n    }\n  }\n  return result;\n}\n\nint enc_untrusted_getifaddrs(struct ifaddrs **ifap) {\n  MessageWriter input;\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kGetIfAddrsHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getifaddrs\", 3,\n                           /*match_exact_params=*/false);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n\n  if (!asylo::host_call::DeserializeIfAddrs(\n          &output, ifap, TrustedPrimitives::BestEffortAbort)) {\n    TrustedPrimitives::DebugPuts(\n        \"enc_untrusted_getifaddrs: Invalid ifaddrs in response.\");\n    return -1;\n  }\n  return 0;\n}\n\nvoid enc_freeifaddrs(struct ifaddrs *ifa) {\n  asylo::host_call::FreeDeserializedIfAddrs(ifa);\n}\n\nint enc_untrusted_getrusage(int who, struct rusage *usage) {\n  struct klinux_rusage klinux_usage {};\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_getrusage, TokLinuxRusageTarget(who),\n      &klinux_usage);\n\n  if (result != -1) {\n    if (!FromkLinuxRusage(&klinux_usage, usage)) {\n      errno = EINVAL;\n      return -1;\n    }\n  }\n  return result;\n}\n\npid_t enc_untrusted_wait3(int *status, int options, struct rusage *rusage) {\n  int klinux_status;\n  struct klinux_rusage klinux_usage;\n  pid_t result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_wait4, /*pid=*/-1, &klinux_status,\n      TokLinuxWaitOption(options), &klinux_usage);\n\n  if (status) {\n    *status = FromkLinuxToNewlibWstatus(klinux_status);\n  }\n  if (rusage) {\n    if (!FromkLinuxRusage(&klinux_usage, rusage)) {\n      errno = EINVAL;\n      return -1;\n    }\n  }\n  return result;\n}\n\npid_t enc_untrusted_waitpid(pid_t pid, int *status, int options) {\n  int klinux_status;\n  pid_t result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_wait4, pid, &klinux_status,\n      TokLinuxWaitOption(options), /*rusage=*/nullptr);\n\n  if (status) {\n    *status = FromkLinuxToNewlibWstatus(klinux_status);\n  }\n  return result;\n}\n\nint enc_untrusted_uname(struct utsname *buf) {\n  struct klinux_utsname klinux_buf {};\n  int result = EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_uname, &klinux_buf);\n  if (result != 0) {\n    return result;\n  }\n\n  if (!FromkLinuxUtsName(&klinux_buf, buf)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_uname: Returned an ill-formed utsname.\");\n  }\n  return 0;\n}\n\nstruct passwd *enc_untrusted_getpwuid(uid_t uid) {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uid_t>(uid);\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kGetPwUidHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_getpwuid\", 1,\n                           /*match_exact_params=*/false);\n\n  int klinux_errno = output.next<int>();\n  if (output.size() == 1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n\n  // Store the struct passwd members in a static passwd_holder, and direct the\n  // pointers in global_passwd to those members.\n  static struct passwd_holder passwd_buffers;\n  if (!DeserializePasswd(&output, &passwd_buffers) ||\n      !PasswdHolderToPasswd(&passwd_buffers, &global_passwd)) {\n    errno = EFAULT;\n    return nullptr;\n  }\n\n  return &global_passwd;\n}\n\nvoid enc_untrusted_hex_dump(const void *buf, size_t nbytes) {\n  MessageWriter input;\n  MessageReader output;\n  input.PushByReference(Extent{reinterpret_cast<const char *>(buf), nbytes});\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kHexDumpHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_hex_dump\", 2);\n}\n\nvoid enc_untrusted_syslog(int priority, const char *message, int len) {\n  EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_syslog,\n                                      TokLinuxSyslogPriority(priority), message,\n                                      len);\n}\n\nvoid enc_untrusted_openlog(const char *ident, int option, int facility) {\n  MessageWriter input;\n  MessageReader output;\n  input.PushString(ident);\n  input.Push<int>(TokLinuxSyslogOption(option));\n  input.Push<int>(TokLinuxSyslogFacility(facility));\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kOpenLogHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_openlog\", 1);\n}\n\nint enc_untrusted_inotify_read(int fd, size_t count, char **serialized_events,\n                               size_t *serialized_events_len) {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<int>(fd);\n  input.Push<uint64_t>(count);\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInotifyReadHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inotify_read\", 2,\n                           /*match_exact_params=*/false);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  Extent serialized_buf = output.next();\n  *serialized_events_len = serialized_buf.size();\n\n  // The caller to this host call owns memory pointed by |*serialized_events|.\n  *serialized_events = reinterpret_cast<char *>(malloc(*serialized_events_len));\n  if (!serialized_events) {\n    errno = ENOMEM;\n    return -1;\n  }\n  memcpy(*serialized_events, serialized_buf.As<char>(), *serialized_events_len);\n  return result;\n}\n\nint enc_untrusted_ioctl1(int fd, uint64_t request) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_ioctl, fd,\n                                             request);\n}\n\n}  // extern \"C\"\n"], "filenames": ["asylo/platform/host_call/trusted/host_calls.cc"], "buggy_code_start_loc": [1328], "buggy_code_end_loc": [1331], "fixing_code_start_loc": [1328], "fixing_code_end_loc": [1332], "type": "CWE-125", "message": "An out of bounds read on the enc_untrusted_inet_ntop function allows an attack to extend the result size that is used by memcpy() to read memory from within the enclave heap. We recommend upgrading past commit 6ff3b77ffe110a33a2f93848a6333f33616f02c4", "other": {"cve": {"id": "CVE-2020-8939", "sourceIdentifier": "cve-coordination@google.com", "published": "2020-12-15T15:15:13.363", "lastModified": "2020-12-17T14:04:23.890", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An out of bounds read on the enc_untrusted_inet_ntop function allows an attack to extend the result size that is used by memcpy() to read memory from within the enclave heap. We recommend upgrading past commit 6ff3b77ffe110a33a2f93848a6333f33616f02c4"}, {"lang": "es", "value": "Una lectura fuera de l\u00edmites en la funci\u00f3n enc_untrusted_inet_ntop permite que un ataque extienda el tama\u00f1o del resultado que usa la funci\u00f3n memcpy() para leer la memoria desde dentro de la pila del enclave.&#xa0;Recomendamos actualizar m\u00e1s all\u00e1 del commit 6ff3b77ffe110a33a2f93848a6333f33616f02c4"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:asylo:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.6.0", "matchCriteriaId": "D4356338-A28E-442E-BD14-1A927E3824E9"}]}]}], "references": [{"url": "https://github.com/google/asylo/commit/6ff3b77ffe110a33a2f93848a6333f33616f02c4", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/google/asylo/commit/6ff3b77ffe110a33a2f93848a6333f33616f02c4"}}