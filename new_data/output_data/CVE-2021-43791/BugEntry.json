{"buggy_code": ["# Copyright: (c) 2008, Jarek Zgoda <jarek.zgoda@gmail.com>\n\n__revision__ = \"$Id: models.py 28 2009-10-22 15:03:02Z jarek.zgoda $\"\nimport datetime\nimport secrets\nfrom base64 import b32encode\nfrom typing import Mapping, Optional, Union\nfrom urllib.parse import urljoin\n\nfrom django.conf import settings\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.db import models\nfrom django.db.models import CASCADE\nfrom django.http import HttpRequest, HttpResponse\nfrom django.shortcuts import render\nfrom django.urls import reverse\nfrom django.utils.timezone import now as timezone_now\nfrom typing_extensions import Protocol\n\nfrom zerver.models import EmailChangeStatus, MultiuseInvite, PreregistrationUser, Realm, UserProfile\n\n\nclass HasRealmObject(Protocol):\n    realm: Realm\n\n\nclass OptionalHasRealmObject(Protocol):\n    realm: Optional[Realm]\n\n\nclass ConfirmationKeyException(Exception):\n    WRONG_LENGTH = 1\n    EXPIRED = 2\n    DOES_NOT_EXIST = 3\n\n    def __init__(self, error_type: int) -> None:\n        super().__init__()\n        self.error_type = error_type\n\n\ndef render_confirmation_key_error(\n    request: HttpRequest, exception: ConfirmationKeyException\n) -> HttpResponse:\n    if exception.error_type == ConfirmationKeyException.WRONG_LENGTH:\n        return render(request, \"confirmation/link_malformed.html\", status=404)\n    if exception.error_type == ConfirmationKeyException.EXPIRED:\n        return render(request, \"confirmation/link_expired.html\", status=404)\n    return render(request, \"confirmation/link_does_not_exist.html\", status=404)\n\n\ndef generate_key() -> str:\n    # 24 characters * 5 bits of entropy/character = 120 bits of entropy\n    return b32encode(secrets.token_bytes(15)).decode().lower()\n\n\nConfirmationObjT = Union[MultiuseInvite, PreregistrationUser, EmailChangeStatus]\n\n\ndef get_object_from_key(\n    confirmation_key: str, confirmation_type: int, activate_object: bool = True\n) -> ConfirmationObjT:\n    # Confirmation keys used to be 40 characters\n    if len(confirmation_key) not in (24, 40):\n        raise ConfirmationKeyException(ConfirmationKeyException.WRONG_LENGTH)\n    try:\n        confirmation = Confirmation.objects.get(\n            confirmation_key=confirmation_key, type=confirmation_type\n        )\n    except Confirmation.DoesNotExist:\n        raise ConfirmationKeyException(ConfirmationKeyException.DOES_NOT_EXIST)\n\n    if timezone_now() > confirmation.expiry_date:\n        raise ConfirmationKeyException(ConfirmationKeyException.EXPIRED)\n\n    obj = confirmation.content_object\n    assert obj is not None\n    if activate_object and hasattr(obj, \"status\"):\n        obj.status = getattr(settings, \"STATUS_ACTIVE\", 1)\n        obj.save(update_fields=[\"status\"])\n    return obj\n\n\ndef create_confirmation_link(\n    obj: Union[Realm, HasRealmObject, OptionalHasRealmObject],\n    confirmation_type: int,\n    *,\n    validity_in_days: Optional[int] = None,\n    url_args: Mapping[str, str] = {},\n) -> str:\n    # validity_in_days is an override for the default values which are\n    # determined by the confirmation_type - its main purpose is for use\n    # in tests which may want to have control over the exact expiration time.\n    key = generate_key()\n    realm = None\n    if isinstance(obj, Realm):\n        realm = obj\n    elif hasattr(obj, \"realm\"):\n        realm = obj.realm\n\n    current_time = timezone_now()\n    expiry_date = None\n    if validity_in_days:\n        expiry_date = current_time + datetime.timedelta(days=validity_in_days)\n    else:\n        expiry_date = current_time + datetime.timedelta(\n            days=_properties[confirmation_type].validity_in_days\n        )\n\n    Confirmation.objects.create(\n        content_object=obj,\n        date_sent=current_time,\n        confirmation_key=key,\n        realm=realm,\n        expiry_date=expiry_date,\n        type=confirmation_type,\n    )\n    return confirmation_url(key, realm, confirmation_type, url_args)\n\n\ndef confirmation_url(\n    confirmation_key: str,\n    realm: Optional[Realm],\n    confirmation_type: int,\n    url_args: Mapping[str, str] = {},\n) -> str:\n    url_args = dict(url_args)\n    url_args[\"confirmation_key\"] = confirmation_key\n    return urljoin(\n        settings.ROOT_DOMAIN_URI if realm is None else realm.uri,\n        reverse(_properties[confirmation_type].url_name, kwargs=url_args),\n    )\n\n\nclass Confirmation(models.Model):\n    content_type = models.ForeignKey(ContentType, on_delete=CASCADE)\n    object_id: int = models.PositiveIntegerField(db_index=True)\n    content_object = GenericForeignKey(\"content_type\", \"object_id\")\n    date_sent: datetime.datetime = models.DateTimeField(db_index=True)\n    confirmation_key: str = models.CharField(max_length=40, db_index=True)\n    expiry_date: datetime.datetime = models.DateTimeField(db_index=True)\n    realm: Optional[Realm] = models.ForeignKey(Realm, null=True, on_delete=CASCADE)\n\n    # The following list is the set of valid types\n    USER_REGISTRATION = 1\n    INVITATION = 2\n    EMAIL_CHANGE = 3\n    UNSUBSCRIBE = 4\n    SERVER_REGISTRATION = 5\n    MULTIUSE_INVITE = 6\n    REALM_CREATION = 7\n    REALM_REACTIVATION = 8\n    type: int = models.PositiveSmallIntegerField()\n\n    def __str__(self) -> str:\n        return f\"<Confirmation: {self.content_object}>\"\n\n    class Meta:\n        unique_together = (\"type\", \"confirmation_key\")\n\n\nclass ConfirmationType:\n    def __init__(\n        self,\n        url_name: str,\n        validity_in_days: int = settings.CONFIRMATION_LINK_DEFAULT_VALIDITY_DAYS,\n    ) -> None:\n        self.url_name = url_name\n        self.validity_in_days = validity_in_days\n\n\n_properties = {\n    Confirmation.USER_REGISTRATION: ConfirmationType(\"check_prereg_key_and_redirect\"),\n    Confirmation.INVITATION: ConfirmationType(\n        \"check_prereg_key_and_redirect\", validity_in_days=settings.INVITATION_LINK_VALIDITY_DAYS\n    ),\n    Confirmation.EMAIL_CHANGE: ConfirmationType(\"confirm_email_change\"),\n    Confirmation.UNSUBSCRIBE: ConfirmationType(\n        \"unsubscribe\",\n        validity_in_days=1000000,  # should never expire\n    ),\n    Confirmation.MULTIUSE_INVITE: ConfirmationType(\n        \"join\", validity_in_days=settings.INVITATION_LINK_VALIDITY_DAYS\n    ),\n    Confirmation.REALM_CREATION: ConfirmationType(\"check_prereg_key_and_redirect\"),\n    Confirmation.REALM_REACTIVATION: ConfirmationType(\"realm_reactivation\"),\n}\n\n\ndef one_click_unsubscribe_link(user_profile: UserProfile, email_type: str) -> str:\n    \"\"\"\n    Generate a unique link that a logged-out user can visit to unsubscribe from\n    Zulip e-mails without having to first log in.\n    \"\"\"\n    return create_confirmation_link(\n        user_profile, Confirmation.UNSUBSCRIBE, url_args={\"email_type\": email_type}\n    )\n\n\n# Functions related to links generated by the generate_realm_creation_link.py\n# management command.\n# Note that being validated here will just allow the user to access the create_realm\n# form, where they will enter their email and go through the regular\n# Confirmation.REALM_CREATION pathway.\n# Arguably RealmCreationKey should just be another ConfirmationObjT and we should\n# add another Confirmation.type for this; it's this way for historical reasons.\n\n\ndef validate_key(creation_key: Optional[str]) -> Optional[\"RealmCreationKey\"]:\n    \"\"\"Get the record for this key, raising InvalidCreationKey if non-None but invalid.\"\"\"\n    if creation_key is None:\n        return None\n    try:\n        key_record = RealmCreationKey.objects.get(creation_key=creation_key)\n    except RealmCreationKey.DoesNotExist:\n        raise RealmCreationKey.Invalid()\n    time_elapsed = timezone_now() - key_record.date_created\n    if time_elapsed.total_seconds() > settings.REALM_CREATION_LINK_VALIDITY_DAYS * 24 * 3600:\n        raise RealmCreationKey.Invalid()\n    return key_record\n\n\ndef generate_realm_creation_url(by_admin: bool = False) -> str:\n    key = generate_key()\n    RealmCreationKey.objects.create(\n        creation_key=key, date_created=timezone_now(), presume_email_valid=by_admin\n    )\n    return urljoin(\n        settings.ROOT_DOMAIN_URI,\n        reverse(\"create_realm\", kwargs={\"creation_key\": key}),\n    )\n\n\nclass RealmCreationKey(models.Model):\n    creation_key = models.CharField(\"activation key\", db_index=True, max_length=40)\n    date_created = models.DateTimeField(\"created\", default=timezone_now)\n\n    # True just if we should presume the email address the user enters\n    # is theirs, and skip sending mail to it to confirm that.\n    presume_email_valid: bool = models.BooleanField(default=False)\n\n    class Invalid(Exception):\n        pass\n", "import datetime\nimport re\nimport time\nimport urllib\nfrom typing import Any, Dict, List, Optional, Sequence, Union\nfrom unittest.mock import MagicMock, patch\nfrom urllib.parse import urlencode\n\nimport orjson\nfrom django.conf import settings\nfrom django.contrib.auth.views import PasswordResetConfirmView\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ValidationError\nfrom django.http import HttpResponse\nfrom django.test import Client, override_settings\nfrom django.urls import reverse\nfrom django.utils.timezone import now as timezone_now\n\nfrom confirmation import settings as confirmation_settings\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyException,\n    create_confirmation_link,\n    get_object_from_key,\n    one_click_unsubscribe_link,\n)\nfrom corporate.lib.stripe import get_latest_seat_count\nfrom zerver.context_processors import common_context\nfrom zerver.decorator import do_two_factor_login\nfrom zerver.forms import HomepageForm, check_subdomain_available\nfrom zerver.lib.actions import (\n    add_new_user_history,\n    change_user_is_active,\n    do_add_default_stream,\n    do_change_full_name,\n    do_change_realm_subdomain,\n    do_change_user_role,\n    do_create_default_stream_group,\n    do_create_multiuse_invite_link,\n    do_create_realm,\n    do_create_user,\n    do_deactivate_realm,\n    do_deactivate_user,\n    do_get_user_invites,\n    do_invite_users,\n    do_set_realm_property,\n    do_set_realm_user_default_setting,\n    get_default_streams_for_realm,\n)\nfrom zerver.lib.email_notifications import enqueue_welcome_emails, followup_day2_email_delay\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.mobile_auth_otp import (\n    ascii_to_hex,\n    hex_to_ascii,\n    is_valid_otp,\n    otp_decrypt_api_key,\n    otp_encrypt_api_key,\n    xor_hex_strings,\n)\nfrom zerver.lib.name_restrictions import is_disposable_domain\nfrom zerver.lib.rate_limiter import add_ratelimit_rule, remove_ratelimit_rule\nfrom zerver.lib.send_email import (\n    EmailNotDeliveredException,\n    FromAddress,\n    deliver_scheduled_emails,\n    send_future_email,\n)\nfrom zerver.lib.stream_subscription import get_stream_subscriptions_for_user\nfrom zerver.lib.streams import create_stream_if_needed\nfrom zerver.lib.subdomains import is_root_domain_available\nfrom zerver.lib.test_classes import ZulipTestCase\nfrom zerver.lib.test_helpers import (\n    avatar_disk_path,\n    cache_tries_captured,\n    find_key_by_email,\n    get_test_image_file,\n    load_subdomain_token,\n    message_stream_count,\n    most_recent_message,\n    most_recent_usermessage,\n    queries_captured,\n    reset_emails_in_zulip_realm,\n)\nfrom zerver.models import (\n    CustomProfileField,\n    CustomProfileFieldValue,\n    DefaultStream,\n    Message,\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    RealmAuditLog,\n    RealmUserDefault,\n    Recipient,\n    ScheduledEmail,\n    Stream,\n    Subscription,\n    UserMessage,\n    UserProfile,\n    flush_per_request_caches,\n    get_realm,\n    get_stream,\n    get_system_bot,\n    get_user,\n    get_user_by_delivery_email,\n)\nfrom zerver.views.auth import redirect_and_log_into_subdomain, start_two_factor_auth\nfrom zerver.views.development.registration import confirmation_key\nfrom zerver.views.invite import get_invitee_emails_set\nfrom zproject.backends import ExternalAuthDataDict, ExternalAuthResult\n\n\nclass RedirectAndLogIntoSubdomainTestCase(ZulipTestCase):\n    def test_data(self) -> None:\n        realm = get_realm(\"zulip\")\n        user_profile = self.example_user(\"hamlet\")\n        name = user_profile.full_name\n        email = user_profile.delivery_email\n        response = redirect_and_log_into_subdomain(ExternalAuthResult(user_profile=user_profile))\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\"full_name\": name, \"email\": email, \"subdomain\": realm.subdomain, \"is_signup\": False},\n        )\n\n        data_dict = ExternalAuthDataDict(is_signup=True, multiuse_object_key=\"key\")\n        response = redirect_and_log_into_subdomain(\n            ExternalAuthResult(user_profile=user_profile, data_dict=data_dict)\n        )\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\n                \"full_name\": name,\n                \"email\": email,\n                \"subdomain\": realm.subdomain,\n                # the email has an account at the subdomain,\n                # so is_signup get overridden to False:\n                \"is_signup\": False,\n                \"multiuse_object_key\": \"key\",\n            },\n        )\n\n        data_dict = ExternalAuthDataDict(\n            email=self.nonreg_email(\"alice\"),\n            full_name=\"Alice\",\n            subdomain=realm.subdomain,\n            is_signup=True,\n            full_name_validated=True,\n            multiuse_object_key=\"key\",\n        )\n        response = redirect_and_log_into_subdomain(ExternalAuthResult(data_dict=data_dict))\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\n                \"full_name\": \"Alice\",\n                \"email\": self.nonreg_email(\"alice\"),\n                \"full_name_validated\": True,\n                \"subdomain\": realm.subdomain,\n                \"is_signup\": True,\n                \"multiuse_object_key\": \"key\",\n            },\n        )\n\n\nclass DeactivationNoticeTestCase(ZulipTestCase):\n    def test_redirection_for_deactivated_realm(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        for url in (\"/register/\", \"/login/\"):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"deactivated\", result.url)\n\n    def test_redirection_for_active_realm(self) -> None:\n        for url in (\"/register/\", \"/login/\"):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 200)\n\n    def test_deactivation_notice_when_realm_is_active(self) -> None:\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result.url)\n\n    def test_deactivation_notice_when_deactivated(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\"Zulip Dev, has been deactivated.\", result.content.decode())\n        self.assertNotIn(\"It has moved to\", result.content.decode())\n\n    def test_deactivation_notice_when_deactivated_and_deactivated_redirect_is_set(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.deactivated_redirect = \"http://example.zulipchat.com\"\n        realm.save(update_fields=[\"deactivated\", \"deactivated_redirect\"])\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://example.zulipchat.com\">http://example.zulipchat.com</a>.',\n            result.content.decode(),\n        )\n\n    def test_deactivation_notice_when_realm_subdomain_is_changed(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-subdomain-name\", acting_user=None)\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://new-subdomain-name.testserver\">http://new-subdomain-name.testserver</a>.',\n            result.content.decode(),\n        )\n\n    def test_deactivated_redirect_field_of_placeholder_realms_are_modified_on_changing_subdomain_multiple_times(\n        self,\n    ) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-name-1\", acting_user=None)\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://new-name-1.testserver\">http://new-name-1.testserver</a>.',\n            result.content.decode(),\n        )\n\n        realm = get_realm(\"new-name-1\")\n        do_change_realm_subdomain(realm, \"new-name-2\", acting_user=None)\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://new-name-2.testserver\">http://new-name-2.testserver</a>.',\n            result.content.decode(),\n        )\n\n\nclass AddNewUserHistoryTest(ZulipTestCase):\n    def test_add_new_user_history_race(self) -> None:\n        \"\"\"Sends a message during user creation\"\"\"\n        # Create a user who hasn't had historical messages added\n        realm = get_realm(\"zulip\")\n        stream = Stream.objects.get(realm=realm, name=\"Denmark\")\n        DefaultStream.objects.create(stream=stream, realm=realm)\n        # Make sure at least 3 messages are sent to Denmark and it's a default stream.\n        message_id = self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 1\")\n        self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 2\")\n        self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 3\")\n\n        with patch(\"zerver.lib.actions.add_new_user_history\"):\n            self.register(self.nonreg_email(\"test\"), \"test\")\n        user_profile = self.nonreg_user(\"test\")\n        subs = Subscription.objects.select_related(\"recipient\").filter(\n            user_profile=user_profile, recipient__type=Recipient.STREAM\n        )\n        streams = Stream.objects.filter(id__in=[sub.recipient.type_id for sub in subs])\n\n        # Sent a message afterwards to trigger a race between message\n        # sending and `add_new_user_history`.\n        race_message_id = self.send_stream_message(\n            self.example_user(\"hamlet\"), streams[0].name, \"test\"\n        )\n\n        # Overwrite ONBOARDING_UNREAD_MESSAGES to 2\n        ONBOARDING_UNREAD_MESSAGES = 2\n        with patch(\"zerver.lib.actions.ONBOARDING_UNREAD_MESSAGES\", ONBOARDING_UNREAD_MESSAGES):\n            add_new_user_history(user_profile, streams)\n\n        # Our first message is in the user's history\n        self.assertTrue(\n            UserMessage.objects.filter(user_profile=user_profile, message_id=message_id).exists()\n        )\n        # The race message is in the user's history and marked unread.\n        self.assertTrue(\n            UserMessage.objects.filter(\n                user_profile=user_profile, message_id=race_message_id\n            ).exists()\n        )\n        self.assertFalse(\n            UserMessage.objects.get(\n                user_profile=user_profile, message_id=race_message_id\n            ).flags.read.is_set\n        )\n\n        # Verify that the ONBOARDING_UNREAD_MESSAGES latest messages\n        # that weren't the race message are marked as unread.\n        latest_messages = (\n            UserMessage.objects.filter(\n                user_profile=user_profile,\n                message__recipient__type=Recipient.STREAM,\n            )\n            .exclude(message_id=race_message_id)\n            .order_by(\"-message_id\")[0:ONBOARDING_UNREAD_MESSAGES]\n        )\n        self.assert_length(latest_messages, 2)\n        for msg in latest_messages:\n            self.assertFalse(msg.flags.read.is_set)\n\n        # Verify that older messages are correctly marked as read.\n        older_messages = (\n            UserMessage.objects.filter(\n                user_profile=user_profile,\n                message__recipient__type=Recipient.STREAM,\n            )\n            .exclude(message_id=race_message_id)\n            .order_by(\"-message_id\")[ONBOARDING_UNREAD_MESSAGES : ONBOARDING_UNREAD_MESSAGES + 1]\n        )\n        self.assertGreater(len(older_messages), 0)\n        for msg in older_messages:\n            self.assertTrue(msg.flags.read.is_set)\n\n    def test_auto_subbed_to_personals(self) -> None:\n        \"\"\"\n        Newly created users are auto-subbed to the ability to receive\n        personals.\n        \"\"\"\n        test_email = self.nonreg_email(\"test\")\n        self.register(test_email, \"test\")\n        user_profile = self.nonreg_user(\"test\")\n        old_messages_count = message_stream_count(user_profile)\n        self.send_personal_message(user_profile, user_profile)\n        new_messages_count = message_stream_count(user_profile)\n        self.assertEqual(new_messages_count, old_messages_count + 1)\n\n        recipient = Recipient.objects.get(type_id=user_profile.id, type=Recipient.PERSONAL)\n        message = most_recent_message(user_profile)\n        self.assertEqual(message.recipient, recipient)\n\n        with patch(\"zerver.models.get_display_recipient\", return_value=\"recip\"):\n            self.assertEqual(\n                str(message),\n                \"<Message: recip /  / \"\n                \"<UserProfile: {} {}>>\".format(user_profile.email, user_profile.realm),\n            )\n\n            user_message = most_recent_usermessage(user_profile)\n            self.assertEqual(\n                str(user_message),\n                f\"<UserMessage: recip / {user_profile.email} ([])>\",\n            )\n\n\nclass InitialPasswordTest(ZulipTestCase):\n    def test_none_initial_password_salt(self) -> None:\n        with self.settings(INITIAL_PASSWORD_SALT=None):\n            self.assertIsNone(initial_password(\"test@test.com\"))\n\n\nclass PasswordResetTest(ZulipTestCase):\n    \"\"\"\n    Log in, reset password, log out, log in with new password.\n    \"\"\"\n\n    def get_reset_mail_body(self, subdomain: str = \"zulip\") -> str:\n        from django.core.mail import outbox\n\n        [message] = outbox\n        self.assertEqual(self.email_envelope_from(message), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertRegex(\n            self.email_display_from(message),\n            fr\"^Zulip Account Security <{self.TOKENIZED_NOREPLY_REGEX}>\\Z\",\n        )\n        self.assertIn(f\"{subdomain}.testserver\", message.extra_headers[\"List-Id\"])\n\n        return message.body\n\n    def test_password_reset(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.delivery_email\n        old_password = initial_password(email)\n        assert old_password is not None\n\n        self.login_user(user)\n\n        # test password reset template\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assert_in_response(\"Reset your password\", result)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"reset your password\", body)\n\n        # Visit the password reset link.\n        password_reset_url = self.get_confirmation_url_from_outbox(\n            email, url_pattern=settings.EXTERNAL_HOST + r\"(\\S\\S+)\"\n        )\n        result = self.client_get(password_reset_url)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.endswith(f\"/{PasswordResetConfirmView.reset_url_token}/\"))\n\n        final_reset_url = result.url\n        result = self.client_get(final_reset_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Reset your password\n        with self.settings(PASSWORD_MIN_LENGTH=3, PASSWORD_MIN_GUESSES=1000):\n            # Verify weak passwords don't work.\n            result = self.client_post(\n                final_reset_url, {\"new_password1\": \"easy\", \"new_password2\": \"easy\"}\n            )\n            self.assert_in_response(\"The password is too weak.\", result)\n\n            result = self.client_post(\n                final_reset_url, {\"new_password1\": \"f657gdGGk9\", \"new_password2\": \"f657gdGGk9\"}\n            )\n            # password reset succeeded\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/password/done/\"))\n\n            # log back in with new password\n            self.login_by_email(email, password=\"f657gdGGk9\")\n            user_profile = self.example_user(\"hamlet\")\n            self.assert_logged_in_user_id(user_profile.id)\n\n            # make sure old password no longer works\n            self.assert_login_failure(email, password=old_password)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_redirects_for_root_alias_when_root_domain_landing_page_is_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"alias.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True, ROOT_SUBDOMAIN_ALIASES=[\"alias\"]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n        ):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_redirects_for_root_domain_when_root_domain_landing_page_is_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n        mock_get_host.return_value = \"www.testserver.com\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n            EXTERNAL_HOST=\"www.testserver.com\",\n        ):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_for_root_alias_when_root_domain_landing_page_is_not_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"alias.testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"alias\"]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"www.testserver\"\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_for_root_domain_when_root_domain_landing_page_is_not_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"testserver\"\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"www.testserver.com\"\n        with self.settings(EXTERNAL_HOST=\"www.testserver.com\", ROOT_SUBDOMAIN_ALIASES=[]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_always_for_subdomains(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"lear.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n    def test_password_reset_for_non_existent_user(self) -> None:\n        email = \"nonexisting@mars.com\"\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"You do not have an account\", body)\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"deactivated\", body)\n\n    def test_password_reset_for_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        do_deactivate_user(user_profile, acting_user=None)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"has been deactivated\", body)\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"not have an account\", body)\n\n    def test_password_reset_with_deactivated_realm(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        do_deactivate_realm(user_profile.realm, acting_user=None)\n\n        # start the password reset process by supplying an email address\n        with self.assertLogs(level=\"INFO\") as m:\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(m.output, [\"INFO:root:Realm is deactivated\"])\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(RATE_LIMITING=True)\n    def test_rate_limiting(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        from django.core.mail import outbox\n\n        add_ratelimit_rule(10, 2, domain=\"password_reset_form_by_email\")\n        start_time = time.time()\n        with patch(\"time.time\", return_value=start_time):\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assert_length(outbox, 2)\n\n            # Too many password reset emails sent to the address, we won't send more.\n            with self.assertLogs(level=\"INFO\") as info_logs:\n                self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(\n                info_logs.output,\n                [\n                    \"INFO:root:Too many password reset attempts for email hamlet@zulip.com from 127.0.0.1\"\n                ],\n            )\n            self.assert_length(outbox, 2)\n\n            # Resetting for a different address works though.\n            self.client_post(\"/accounts/password/reset/\", {\"email\": self.example_email(\"othello\")})\n            self.assert_length(outbox, 3)\n            self.client_post(\"/accounts/password/reset/\", {\"email\": self.example_email(\"othello\")})\n            self.assert_length(outbox, 4)\n\n        # After time, password reset emails can be sent again.\n        with patch(\"time.time\", return_value=start_time + 11):\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assert_length(outbox, 6)\n\n        remove_ratelimit_rule(10, 2, domain=\"password_reset_form_by_email\")\n\n    def test_wrong_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email}, subdomain=\"zephyr\")\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        body = self.get_reset_mail_body(\"zephyr\")\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"You do not have an account\", body)\n        self.assertIn(\n            \"active accounts in the following organization(s).\\nhttp://zulip.testserver\", body\n        )\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"deactivated\", body)\n\n    def test_invalid_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\n            \"/accounts/password/reset/\", {\"email\": email}, subdomain=\"invalid\"\n        )\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_auth_only(self) -> None:\n        \"\"\"If the email auth backend is not enabled, password reset should do nothing\"\"\"\n        email = self.example_email(\"hamlet\")\n        with self.assertLogs(level=\"INFO\") as m:\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(\n                m.output,\n                [\n                    \"INFO:root:Password reset attempted for hamlet@zulip.com even though password auth is disabled.\"\n                ],\n            )\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_and_email_auth(self) -> None:\n        \"\"\"If both email and LDAP auth backends are enabled, limit password\n        reset to users outside the LDAP domain\"\"\"\n        # If the domain matches, we don't generate an email\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            email = self.example_email(\"hamlet\")\n            with self.assertLogs(level=\"INFO\") as m:\n                result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n                self.assertEqual(\n                    m.output, [\"INFO:root:Password reset not allowed for user in LDAP domain\"]\n                )\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n        # If the domain doesn't match, we do generate an email\n        with self.settings(LDAP_APPEND_DOMAIN=\"example.com\"):\n            email = self.example_email(\"hamlet\")\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n            result = self.client_get(result[\"Location\"])\n\n        body = self.get_reset_mail_body()\n        self.assertIn(\"reset your password\", body)\n\n    def test_redirect_endpoints(self) -> None:\n        \"\"\"\n        These tests are mostly designed to give us 100% URL coverage\n        in our URL coverage reports.  Our mechanism for finding URL\n        coverage doesn't handle redirects, so we just have a few quick\n        tests here.\n        \"\"\"\n        result = self.client_get(\"/accounts/password/reset/done/\")\n        self.assert_in_success_response([\"Check your email\"], result)\n\n        result = self.client_get(\"/accounts/password/done/\")\n        self.assert_in_success_response([\"We've reset your password!\"], result)\n\n        result = self.client_get(\"/accounts/send_confirm/alice@example.com\")\n        self.assert_in_success_response([\"/accounts/home/\"], result)\n\n        result = self.client_get(\"/accounts/new/send_confirm/alice@example.com\")\n        self.assert_in_success_response([\"/new/\"], result)\n\n\nclass LoginTest(ZulipTestCase):\n    \"\"\"\n    Logging in, registration, and logging out.\n    \"\"\"\n\n    def test_login(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        do_deactivate_user(user_profile, acting_user=None)\n        result = self.login_with_return(user_profile.delivery_email, \"xxx\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            f\"Your account {user_profile.delivery_email} has been deactivated.\", result\n        )\n        self.assert_logged_in_user_id(None)\n\n    def test_login_bad_password(self) -> None:\n        user = self.example_user(\"hamlet\")\n        password: Optional[str] = \"wrongpassword\"\n        result = self.login_with_return(user.delivery_email, password=password)\n        self.assert_in_success_response([user.delivery_email], result)\n        self.assert_logged_in_user_id(None)\n\n        # Parallel test to confirm that the right password works using the\n        # same login code, which verifies our failing test isn't broken\n        # for some other reason.\n        password = initial_password(user.delivery_email)\n        result = self.login_with_return(user.delivery_email, password=password)\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user.id)\n\n    @override_settings(RATE_LIMITING_AUTHENTICATE=True)\n    def test_login_bad_password_rate_limiter(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        add_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n        start_time = time.time()\n        with patch(\"time.time\", return_value=start_time):\n            self.login_with_return(email, password=\"wrongpassword\")\n            self.assert_logged_in_user_id(None)\n            self.login_with_return(email, password=\"wrongpassword\")\n            self.assert_logged_in_user_id(None)\n\n            # We're over the allowed limit, so the next attempt, even with the correct\n            # password, will get blocked.\n            result = self.login_with_return(email)\n            self.assert_in_success_response([\"Try again in 10 seconds\"], result)\n\n        # After time passes, we should be able to log in.\n        with patch(\"time.time\", return_value=start_time + 11):\n            self.login_with_return(email)\n            self.assert_logged_in_user_id(user_profile.id)\n\n        remove_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n    def test_login_with_old_weak_password_after_hasher_change(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"a_password_of_22_chars\"\n\n        with self.settings(PASSWORD_HASHERS=(\"django.contrib.auth.hashers.SHA1PasswordHasher\",)):\n            user_profile.set_password(password)\n            user_profile.save()\n\n        with self.settings(\n            PASSWORD_HASHERS=(\n                \"django.contrib.auth.hashers.MD5PasswordHasher\",\n                \"django.contrib.auth.hashers.SHA1PasswordHasher\",\n            ),\n            PASSWORD_MIN_LENGTH=30,\n        ), self.assertLogs(\"zulip.auth.email\", level=\"INFO\"):\n            result = self.login_with_return(self.example_email(\"hamlet\"), password)\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\n                \"Your password has been disabled because it is too weak.\", result\n            )\n            self.assert_logged_in_user_id(None)\n\n    def test_login_nonexist_user(self) -> None:\n        result = self.login_with_return(\"xxx@zulip.com\", \"xxx\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Please enter a correct email and password\", result)\n        self.assert_logged_in_user_id(None)\n\n    def test_login_wrong_subdomain(self) -> None:\n        email = self.mit_email(\"sipbtest\")\n        with self.assertLogs(level=\"WARNING\") as m:\n            result = self.login_with_return(email, \"xxx\")\n            self.assertEqual(\n                m.output,\n                [\n                    \"WARNING:root:User sipbtest@mit.edu attempted password login to wrong subdomain zulip\"\n                ],\n            )\n        self.assertEqual(result.status_code, 200)\n        expected_error = (\n            f\"Your Zulip account {email} is not a member of the \"\n            + \"organization associated with this subdomain.\"\n        )\n        self.assert_in_response(expected_error, result)\n        self.assert_logged_in_user_id(None)\n\n    def test_login_invalid_subdomain(self) -> None:\n        result = self.login_with_return(self.example_email(\"hamlet\"), \"xxx\", subdomain=\"invalid\")\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n        self.assert_logged_in_user_id(None)\n\n    def test_register(self) -> None:\n        reset_emails_in_zulip_realm()\n\n        realm = get_realm(\"zulip\")\n        stream_names = [f\"stream_{i}\" for i in range(40)]\n        for stream_name in stream_names:\n            stream = self.make_stream(stream_name, realm=realm)\n            DefaultStream.objects.create(stream=stream, realm=realm)\n\n        # Clear all the caches.\n        flush_per_request_caches()\n        ContentType.objects.clear_cache()\n\n        with queries_captured() as queries, cache_tries_captured() as cache_tries:\n            self.register(self.nonreg_email(\"test\"), \"test\")\n        # Ensure the number of queries we make is not O(streams)\n        self.assert_length(queries, 89)\n\n        # We can probably avoid a couple cache hits here, but there doesn't\n        # seem to be any O(N) behavior.  Some of the cache hits are related\n        # to sending messages, such as getting the welcome bot, looking up\n        # the alert words for a realm, etc.\n        self.assert_length(cache_tries, 21)\n\n        user_profile = self.nonreg_user(\"test\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.assertFalse(user_profile.enable_stream_desktop_notifications)\n\n    def test_register_deactivated(self) -> None:\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_post(\n            \"/accounts/home/\", {\"email\": self.nonreg_email(\"test\")}, subdomain=\"zulip\"\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result.url)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user(\"test\")\n\n    def test_register_with_invalid_email(self) -> None:\n        \"\"\"\n        If you try to register with invalid email, you get an invalid email\n        page\n        \"\"\"\n        invalid_email = \"foo\\x00bar\"\n        result = self.client_post(\"/accounts/home/\", {\"email\": invalid_email}, subdomain=\"zulip\")\n\n        self.assertEqual(result.status_code, 200)\n        self.assertContains(result, \"Enter a valid email address\")\n\n    def test_register_deactivated_partway_through(self) -> None:\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        email = self.nonreg_email(\"test\")\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertNotIn(\"deactivated\", result.url)\n\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.submit_reg_form_for_user(email, \"abcd1234\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result.url)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user(\"test\")\n\n    def test_login_deactivated_realm(self) -> None:\n        \"\"\"\n        If you try to log in to a deactivated realm, you get a clear error page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.login_with_return(self.example_email(\"hamlet\"), subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result.url)\n\n    def test_logout(self) -> None:\n        self.login(\"hamlet\")\n        # We use the logout API, not self.logout, to make sure we test\n        # the actual logout code path.\n        self.client_post(\"/accounts/logout/\")\n        self.assert_logged_in_user_id(None)\n\n    def test_non_ascii_login(self) -> None:\n        \"\"\"\n        You can log in even if your password contain non-ASCII characters.\n        \"\"\"\n        email = self.nonreg_email(\"test\")\n        password = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Registering succeeds.\n        self.register(email, password)\n        user_profile = self.nonreg_user(\"test\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.logout()\n        self.assert_logged_in_user_id(None)\n\n        # Logging in succeeds.\n        self.logout()\n        self.login_by_email(email, password)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TWO_FACTOR_AUTHENTICATION_ENABLED=False)\n    def test_login_page_redirects_logged_in_user(self) -> None:\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        self.login(\"cordelia\")\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\n    def test_options_request_to_login_page(self) -> None:\n        response = self.client_options(\"/login/\")\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(TWO_FACTOR_AUTHENTICATION_ENABLED=True)\n    def test_login_page_redirects_logged_in_user_under_2fa(self) -> None:\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        user_profile = self.example_user(\"cordelia\")\n        self.create_default_device(user_profile)\n\n        self.login(\"cordelia\")\n        self.login_2fa(user_profile)\n\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\n    def test_start_two_factor_auth(self) -> None:\n        request = MagicMock(POST={})\n        with patch(\"zerver.views.auth.TwoFactorLoginView\") as mock_view:\n            mock_view.as_view.return_value = lambda *a, **k: HttpResponse()\n            response = start_two_factor_auth(request)\n            self.assertTrue(isinstance(response, HttpResponse))\n\n    def test_do_two_factor_login(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.create_default_device(user_profile)\n        request = MagicMock()\n        with patch(\"zerver.decorator.django_otp.login\") as mock_login:\n            do_two_factor_login(request, user_profile)\n            mock_login.assert_called_once()\n\n    def test_zulip_default_context_does_not_load_inline_previews(self) -> None:\n        realm = get_realm(\"zulip\")\n        description = \"https://www.google.com/images/srpr/logo4w.png\"\n        realm.description = description\n        realm.save(update_fields=[\"description\"])\n        response = self.client_get(\"/login/\")\n        expected_response = \"\"\"<p><a href=\"https://www.google.com/images/srpr/logo4w.png\">\\\nhttps://www.google.com/images/srpr/logo4w.png</a></p>\"\"\"\n        self.assertEqual(response.context_data[\"realm_description\"], expected_response)\n        self.assertEqual(response.status_code, 200)\n\n\nclass InviteUserBase(ZulipTestCase):\n    def check_sent_emails(self, correct_recipients: List[str]) -> None:\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, len(correct_recipients))\n        email_recipients = [email.recipients()[0] for email in outbox]\n        self.assertEqual(sorted(email_recipients), sorted(correct_recipients))\n        if len(outbox) == 0:\n            return\n\n        self.assertIn(\"Zulip\", self.email_display_from(outbox[0]))\n\n        self.assertEqual(self.email_envelope_from(outbox[0]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertRegex(\n            self.email_display_from(outbox[0]), fr\" <{self.TOKENIZED_NOREPLY_REGEX}>\\Z\"\n        )\n\n        self.assertEqual(outbox[0].extra_headers[\"List-Id\"], \"Zulip Dev <zulip.testserver>\")\n\n    def invite(\n        self,\n        invitee_emails: str,\n        stream_names: Sequence[str],\n        invite_expires_in_days: int = settings.INVITATION_LINK_VALIDITY_DAYS,\n        body: str = \"\",\n        invite_as: int = PreregistrationUser.INVITE_AS[\"MEMBER\"],\n    ) -> HttpResponse:\n        \"\"\"\n        Invites the specified users to Zulip with the specified streams.\n\n        users should be a string containing the users to invite, comma or\n            newline separated.\n\n        streams should be a list of strings.\n        \"\"\"\n        stream_ids = []\n        for stream_name in stream_names:\n            stream_ids.append(self.get_stream_id(stream_name))\n        return self.client_post(\n            \"/json/invites\",\n            {\n                \"invitee_emails\": invitee_emails,\n                \"invite_expires_in_days\": invite_expires_in_days,\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_as\": invite_as,\n            },\n        )\n\n\nclass InviteUserTest(InviteUserBase):\n    def test_successful_invite_user(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n    def test_newbie_restrictions(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        stream_name = \"Denmark\"\n\n        self.login_user(user_profile)\n\n        result = self.invite(invitee, [stream_name])\n        self.assert_json_success(result)\n\n        user_profile.date_joined = timezone_now() - datetime.timedelta(days=10)\n        user_profile.save()\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=5):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_success(result)\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=15):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_error_contains(result, \"Your account is too new\")\n\n    def test_invite_limits(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        realm = user_profile.realm\n        stream_name = \"Denmark\"\n\n        # These constants only need to be in descending order\n        # for this test to trigger an InvitationError based\n        # on max daily counts.\n        site_max = 50\n        realm_max = 40\n        num_invitees = 30\n        max_daily_count = 20\n\n        daily_counts = [(1, max_daily_count)]\n\n        invite_emails = [f\"foo-{i:02}@zulip.com\" for i in range(num_invitees)]\n        invitees = \",\".join(invite_emails)\n\n        self.login_user(user_profile)\n\n        realm.max_invites = realm_max\n        realm.date_created = timezone_now()\n        realm.save()\n\n        def try_invite() -> HttpResponse:\n            with self.settings(\n                OPEN_REALM_CREATION=True,\n                INVITES_DEFAULT_REALM_DAILY_MAX=site_max,\n                INVITES_NEW_REALM_LIMIT_DAYS=daily_counts,\n            ):\n                result = self.invite(invitees, [stream_name])\n                return result\n\n        result = try_invite()\n        self.assert_json_error_contains(result, \"reached the limit\")\n\n        # Next show that aggregate limits expire once the realm is old\n        # enough.\n\n        realm.date_created = timezone_now() - datetime.timedelta(days=8)\n        realm.save()\n\n        with queries_captured() as queries:\n            with cache_tries_captured() as cache_tries:\n                result = try_invite()\n\n        self.assert_json_success(result)\n\n        # TODO: Fix large query count here.\n        #\n        # TODO: There is some test OTHER than this one\n        #       that is leaking some kind of state change\n        #       that throws off the query count here.  It\n        #       is hard to investigate currently (due to\n        #       the large number of queries), so I just\n        #       use an approximate equality check.\n        actual_count = len(queries)\n        expected_count = 251\n        if abs(actual_count - expected_count) > 1:\n            raise AssertionError(\n                f\"\"\"\n                Unexpected number of queries:\n\n                expected query count: {expected_count}\n                actual: {actual_count}\n                \"\"\"\n            )\n\n        # Almost all of these cache hits are to re-fetch each one of the\n        # invitees.  These happen inside our queue processor for sending\n        # confirmation emails, so they are somewhat difficult to avoid.\n        #\n        # TODO: Mock the call to queue_json_publish, so we can measure the\n        # queue impact separately from the user-perceived impact.\n        self.assert_length(cache_tries, 32)\n\n        # Next get line coverage on bumping a realm's max_invites.\n        realm.date_created = timezone_now()\n        realm.max_invites = site_max + 10\n        realm.save()\n\n        result = try_invite()\n        self.assert_json_success(result)\n\n        # Finally get coverage on the case that OPEN_REALM_CREATION is False.\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            result = self.invite(invitees, [stream_name])\n\n        self.assert_json_success(result)\n\n    def test_invite_user_to_realm_on_manual_license_plan(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(\n            user.realm, 50, 50\n        )\n\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"alice\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses_at_next_renewal = 5\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses = get_latest_seat_count(user.realm) + 1\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            invitee_emails = self.nonreg_email(\"bob\") + \",\" + self.nonreg_email(\"alice\")\n            result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"Your organization does not have enough unused Zulip licenses to invite 2 users\"\n        )\n\n        ledger.licenses = get_latest_seat_count(user.realm)\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"All Zulip licenses for this organization are currently in use\"\n        )\n\n    def test_cross_realm_bot(self) -> None:\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        cross_realm_bot_email = \"emailgateway@zulip.com\"\n        legit_new_email = \"fred@zulip.com\"\n        invitee_emails = \",\".join([cross_realm_bot_email, legit_new_email])\n\n        result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error(\n            result,\n            \"Some of those addresses are already using Zulip,\"\n            + \" so we didn't send them an invitation.\"\n            + \" We did send invitations to everyone else!\",\n        )\n\n    def test_invite_mirror_dummy_user(self) -> None:\n        \"\"\"\n        A mirror dummy account is a temporary account\n        that we keep in our system if we are mirroring\n        data from something like Zephyr or IRC.\n\n        We want users to eventually just sign up or\n        register for Zulip, in which case we will just\n        fully \"activate\" the account.\n\n        Here we test that you can invite a person who\n        has a mirror dummy account.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        mirror_user = self.example_user(\"cordelia\")\n        mirror_user.is_mirror_dummy = True\n        mirror_user.save()\n        change_user_is_active(mirror_user, False)\n\n        self.assertEqual(\n            PreregistrationUser.objects.filter(email=mirror_user.email).count(),\n            0,\n        )\n\n        result = self.invite(mirror_user.email, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=mirror_user.email)\n        assert prereg_user.referred_by is not None and inviter is not None\n        self.assertEqual(\n            prereg_user.referred_by.email,\n            inviter.email,\n        )\n\n    def test_successful_invite_user_as_owner_from_owner_account(self) -> None:\n        self.login(\"desdemona\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n\n    def test_invite_user_as_owner_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_error(response, \"Must be an organization owner\")\n\n    def test_successful_invite_user_as_admin_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_admin)\n        self.assertFalse(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n\n    def test_invite_user_as_admin_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_successful_invite_user_as_moderator_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_moderator)\n        self.assertFalse(invitee_profile.is_guest)\n\n    def test_invite_user_as_moderator_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_moderator_from_moderator_account(self) -> None:\n        self.login(\"shiva\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_invalid_type(self) -> None:\n        \"\"\"\n        Test inviting a user as invalid type of user i.e. type of invite_as\n        is not in PreregistrationUser.INVITE_AS\n        \"\"\"\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(invitee, [\"Denmark\"], invite_as=10)\n        self.assert_json_error(response, \"Must be invited as an valid type of user\")\n\n    def test_successful_invite_user_as_guest_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n\n    def test_successful_invite_user_as_guest_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n\n    def test_successful_invite_user_with_name(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.check_sent_emails([email])\n\n    def test_successful_invite_user_with_name_and_normal_one(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_can_invite_others_to_realm(self) -> None:\n        def validation_func(user_profile: UserProfile) -> bool:\n            user_profile.refresh_from_db()\n            return user_profile.can_invite_others_to_realm()\n\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        desdemona = self.example_user(\"desdemona\")\n        self.assertFalse(validation_func(desdemona))\n\n        self.check_has_permission_policies(\"invite_to_realm_policy\", validation_func)\n\n    def test_invite_others_to_realm_setting(self) -> None:\n        \"\"\"\n        The invite_to_realm_policy realm setting works properly.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        self.login(\"desdemona\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        # Now verify an administrator can do it\n        self.login(\"iago\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n\n        self.check_sent_emails([email, email2])\n\n        from django.core import mail\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MODERATORS_ONLY, acting_user=None\n        )\n        self.login(\"hamlet\")\n        email = \"carol-test@zulip.com\"\n        email2 = \"earl-test@zulip.com\"\n        invitee = f\"Carol Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n\n        self.login(\"polonius\")\n        email = \"dave-test@zulip.com\"\n        email2 = \"mark-test@zulip.com\"\n        invitee = f\"Dave Test <{email}>, {email2}\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n\n        self.login(\"hamlet\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_FULL_MEMBERS_ONLY, acting_user=None\n        )\n        do_set_realm_property(realm, \"waiting_period_threshold\", 1000, acting_user=None)\n\n        hamlet = self.example_user(\"hamlet\")\n        hamlet.date_joined = timezone_now() - datetime.timedelta(\n            days=(realm.waiting_period_threshold - 1)\n        )\n\n        email = \"issac-test@zulip.com\"\n        email2 = \"steven-test@zulip.com\"\n        invitee = f\"Issac Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(realm, \"waiting_period_threshold\", 0, acting_user=None)\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_invite_user_signup_initial_history(self) -> None:\n        \"\"\"\n        Test that a new user invited to a stream receives some initial\n        history but only from public streams.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        private_stream_name = \"Secret\"\n        self.make_stream(private_stream_name, invite_only=True)\n        self.subscribe(user_profile, private_stream_name)\n        public_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            \"Denmark\",\n            topic_name=\"Public topic\",\n            content=\"Public message\",\n        )\n        secret_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            private_stream_name,\n            topic_name=\"Secret topic\",\n            content=\"Secret message\",\n        )\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee, [private_stream_name, \"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        invitee_msg_ids = [\n            um.message_id for um in UserMessage.objects.filter(user_profile=invitee_profile)\n        ]\n        self.assertTrue(public_msg_id in invitee_msg_ids)\n        self.assertFalse(secret_msg_id in invitee_msg_ids)\n        self.assertFalse(invitee_profile.is_realm_admin)\n\n        invitee_msg, signups_stream_msg, inviter_msg, secret_msg = Message.objects.all().order_by(\n            \"-id\"\n        )[0:4]\n\n        self.assertEqual(secret_msg.id, secret_msg_id)\n\n        self.assertEqual(inviter_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            inviter_msg.content.startswith(\n                f\"alice_zulip.com <`{invitee_profile.email}`> accepted your\",\n            )\n        )\n\n        self.assertEqual(signups_stream_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            signups_stream_msg.content.startswith(\n                f\"@_**alice_zulip.com|{invitee_profile.id}** just signed up\",\n            )\n        )\n\n        self.assertEqual(invitee_msg.sender.email, \"welcome-bot@zulip.com\")\n        self.assertTrue(invitee_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", invitee_msg.content)\n\n    def test_multi_user_invite(self) -> None:\n        \"\"\"\n        Invites multiple users with a variety of delimiters.\n        \"\"\"\n        self.login(\"hamlet\")\n        # Intentionally use a weird string.\n        self.assert_json_success(\n            self.invite(\n                \"\"\"bob-test@zulip.com,     carol-test@zulip.com,\n            dave-test@zulip.com\n\n\nearl-test@zulip.com\"\"\",\n                [\"Denmark\"],\n            )\n        )\n        for user in (\"bob\", \"carol\", \"dave\", \"earl\"):\n            self.assertTrue(find_key_by_email(f\"{user}-test@zulip.com\"))\n        self.check_sent_emails(\n            [\n                \"bob-test@zulip.com\",\n                \"carol-test@zulip.com\",\n                \"dave-test@zulip.com\",\n                \"earl-test@zulip.com\",\n            ]\n        )\n\n    def test_max_invites_model(self) -> None:\n        realm = get_realm(\"zulip\")\n        self.assertEqual(realm.max_invites, settings.INVITES_DEFAULT_REALM_DAILY_MAX)\n        realm.max_invites = 3\n        realm.save()\n        self.assertEqual(get_realm(\"zulip\").max_invites, 3)\n        realm.max_invites = settings.INVITES_DEFAULT_REALM_DAILY_MAX\n        realm.save()\n\n    def test_invite_too_many_users(self) -> None:\n        # Only a light test of this pathway; e.g. doesn't test that\n        # the limit gets reset after 24 hours\n        self.login(\"iago\")\n        invitee_emails = \"1@zulip.com, 2@zulip.com\"\n        self.invite(invitee_emails, [\"Denmark\"])\n        invitee_emails = \", \".join(str(i) for i in range(get_realm(\"zulip\").max_invites - 1))\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"To protect users, Zulip limits the number of invitations you can send in one day. Because you have reached the limit, no invitations were sent.\",\n        )\n\n    def test_missing_or_invalid_params(self) -> None:\n        \"\"\"\n        Tests inviting with various missing or invalid parameters.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        self.login(\"hamlet\")\n        invitee_emails = \"foo@zulip.com\"\n        self.assert_json_error(\n            self.invite(invitee_emails, []),\n            \"You must specify at least one stream for invitees to join.\",\n        )\n\n        for address in (\"noatsign.com\", \"outsideyourdomain@example.net\"):\n            self.assert_json_error(\n                self.invite(address, [\"Denmark\"]),\n                \"Some emails did not validate, so we didn't send any invitations.\",\n            )\n        self.check_sent_emails([])\n\n        self.assert_json_error(\n            self.invite(\"\", [\"Denmark\"]), \"You must specify at least one email address.\"\n        )\n        self.check_sent_emails([])\n\n    def test_guest_user_invitation(self) -> None:\n        \"\"\"\n        Guest user can't invite new users\n        \"\"\"\n        self.login(\"polonius\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n        self.assertEqual(find_key_by_email(invitee), None)\n        self.check_sent_emails([])\n\n    def test_invalid_stream(self) -> None:\n        \"\"\"\n        Tests inviting to a non-existent stream.\n        \"\"\"\n        self.login(\"hamlet\")\n        self.assert_json_error(\n            self.invite(\"iago-test@zulip.com\", [\"NotARealStream\"]),\n            f\"Stream does not exist with id: {self.INVALID_STREAM_ID}. No invites were sent.\",\n        )\n        self.check_sent_emails([])\n\n    def test_invite_existing_user(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        self.login(\"hamlet\")\n\n        hamlet_email = \"hAmLeT@zUlIp.com\"\n        result = self.invite(hamlet_email, [\"Denmark\"])\n        self.assert_json_error(result, \"We weren't able to invite anyone.\")\n\n        self.assertFalse(\n            PreregistrationUser.objects.filter(email__iexact=hamlet_email).exists(),\n        )\n        self.check_sent_emails([])\n\n    def normalize_string(self, s: str) -> str:\n        s = s.strip()\n        return re.sub(r\"\\s+\", \" \", s)\n\n    def test_invite_links_in_name(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        # Test we properly handle links in user full names\n        do_change_full_name(hamlet, \"</a> https://www.google.com\", hamlet)\n\n        result = self.invite(\"newuser@zulip.com\", [\"Denmark\"])\n        self.assert_json_success(result)\n        self.check_sent_emails([\"newuser@zulip.com\"])\n        from django.core.mail import outbox\n\n        body = self.normalize_string(outbox[0].alternatives[0][0])\n\n        # Verify that one can't get Zulip to send invitation emails\n        # that third-party products will linkify using the full_name\n        # field, because we've included that field inside the mailto:\n        # link for the sender.\n        self.assertIn(\n            '<a href=\"mailto:hamlet@zulip.com\" style=\"color:#5f5ec7; text-decoration:underline\">&lt;/a&gt; https://www.google.com (hamlet@zulip.com)</a> wants',\n            body,\n        )\n\n        # TODO: Ideally, this test would also test the Invitation\n        # Reminder email generated, but the test setup for that is\n        # annoying.\n\n    def test_invite_some_existing_some_new(self) -> None:\n        \"\"\"\n        If you invite a mix of already existing and new users, invitations are\n        only sent to the new users.\n        \"\"\"\n        self.login(\"hamlet\")\n        existing = [self.example_email(\"hamlet\"), \"othello@zulip.com\"]\n        new = [\"foo-test@zulip.com\", \"bar-test@zulip.com\"]\n        invitee_emails = \"\\n\".join(existing + new)\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"Some of those addresses are already using Zulip, \\\nso we didn't send them an invitation. We did send invitations to everyone else!\",\n        )\n\n        # We only created accounts for the new users.\n        for email in existing:\n            self.assertRaises(\n                PreregistrationUser.DoesNotExist,\n                lambda: PreregistrationUser.objects.get(email=email),\n            )\n        for email in new:\n            self.assertTrue(PreregistrationUser.objects.get(email=email))\n\n        # We only sent emails to the new users.\n        self.check_sent_emails(new)\n\n        prereg_user = PreregistrationUser.objects.get(email=\"foo-test@zulip.com\")\n        self.assertEqual(prereg_user.email, \"foo-test@zulip.com\")\n\n    def test_invite_outside_domain_in_closed_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = True`, you can't invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_using_disposable_email(self) -> None:\n        \"\"\"\n        In a realm with `disallow_disposable_email_addresses = True`, you can't invite\n        people with a disposable domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_outside_domain_in_open_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = False`, you can invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n    def test_invite_outside_domain_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a different domain from that of the realm\n        when `emails_restricted_to_domains = False`, but `emails_restricted_to_domains` later\n        changes to true, the invitation should succeed but the invitee's signup\n        attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@example.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"only allows users with email addresses\", result)\n\n    def test_disposable_emails_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a disposable email when\n        `disallow_disposable_email_addresses = False`, but\n        later changes to true, the invitation should succeed\n        but the invitee's signup attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@mailnator.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Please sign up using a real email address.\", result)\n\n    def test_invite_with_email_containing_plus_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with an email containing plus when\n        `emails_restricted_to_domains = False`, but later change\n        `emails_restricted_to_domains = True`, the invitation should\n        succeed but the invitee's signup attempt should fail as\n        users are not allowed to sign up using email containing +\n        when the realm is restricted to domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo+label@zulip.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(external_address, \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            \"Zulip Dev, does not allow signups using emails\\n        that contains +\", result\n        )\n\n    def test_invalid_email_check_after_confirming_email(self) -> None:\n        self.login(\"hamlet\")\n        email = \"test@zulip.com\"\n\n        self.assert_json_success(self.invite(email, [\"Denmark\"]))\n\n        obj = Confirmation.objects.get(confirmation_key=find_key_by_email(email))\n        prereg_user = obj.content_object\n        assert prereg_user is not None\n        prereg_user.email = \"invalid.email\"\n        prereg_user.save()\n\n        result = self.submit_reg_form_for_user(email, \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            \"The email address you are trying to sign up with is not valid\", result\n        )\n\n    def test_invite_with_non_ascii_streams(self) -> None:\n        \"\"\"\n        Inviting someone to streams with non-ASCII characters succeeds.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n\n        stream_name = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Make sure we're subscribed before inviting someone.\n        self.subscribe(self.example_user(\"hamlet\"), stream_name)\n\n        self.assert_json_success(self.invite(invitee, [stream_name]))\n\n    def test_invitation_reminder_email(self) -> None:\n        from django.core.mail import outbox\n\n        # All users belong to zulip realm\n        referrer_name = \"hamlet\"\n        current_user = self.example_user(referrer_name)\n        self.login_user(current_user)\n        invitee_email = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee_email, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee_email))\n        self.check_sent_emails([invitee_email])\n\n        data = {\"email\": invitee_email, \"referrer_email\": current_user.email}\n        invitee = PreregistrationUser.objects.get(email=data[\"email\"])\n        referrer = self.example_user(referrer_name)\n        validity_in_days = 2\n        link = create_confirmation_link(\n            invitee, Confirmation.INVITATION, validity_in_days=validity_in_days\n        )\n        context = common_context(referrer)\n        context.update(\n            activate_url=link,\n            referrer_name=referrer.full_name,\n            referrer_email=referrer.email,\n            referrer_realm_name=referrer.realm.name,\n        )\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now()\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n        email_count = len(outbox)\n        for job in email_jobs_to_deliver:\n            deliver_scheduled_emails(job)\n        self.assert_length(outbox, email_count + 1)\n        self.assertEqual(self.email_envelope_from(outbox[-1]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertIn(FromAddress.NOREPLY, self.email_display_from(outbox[-1]))\n\n        # Now verify that signing up clears invite_reminder emails\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n\n        self.register(invitee_email, \"test\")\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 0)\n\n    def test_no_invitation_reminder_when_link_expires_quickly(self) -> None:\n        self.login(\"hamlet\")\n        # Check invitation reminder email is scheduled with 4 day link expiry\n        self.invite(\"alice@zulip.com\", [\"Denmark\"], invite_expires_in_days=4)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(type=ScheduledEmail.INVITATION_REMINDER).count(), 1\n        )\n        # Check invitation reminder email is not scheduled with 3 day link expiry\n        self.invite(\"bob@zulip.com\", [\"Denmark\"], invite_expires_in_days=3)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(type=ScheduledEmail.INVITATION_REMINDER).count(), 1\n        )\n\n    # make sure users can't take a valid confirmation key from another\n    # pathway and use it with the invitation URL route\n    def test_confirmation_key_of_wrong_type(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = url.split(\"/\")[-1]\n\n        # Mainly a test of get_object_from_key, rather than of the invitation pathway\n        with self.assertRaises(ConfirmationKeyException) as cm:\n            get_object_from_key(registration_key, Confirmation.INVITATION)\n        self.assertEqual(cm.exception.error_type, ConfirmationKeyException.DOES_NOT_EXIST)\n\n        # Verify that using the wrong type doesn't work in the main confirm code path\n        email_change_url = create_confirmation_link(prereg_user, Confirmation.EMAIL_CHANGE)\n        email_change_key = email_change_url.split(\"/\")[-1]\n        url = \"/accounts/do_confirm/\" + email_change_key\n        result = self.client_get(url)\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n    def test_confirmation_expired(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        date_sent = timezone_now() - datetime.timedelta(weeks=3)\n        with patch(\"confirmation.models.timezone_now\", return_value=date_sent):\n            url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        target_url = \"/\" + url.split(\"/\", 3)[3]\n        result = self.client_get(target_url)\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_send_more_than_one_invite_to_same_user(self) -> None:\n        self.user_profile = self.example_user(\"iago\")\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, self.user_profile.realm))\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        prereg_user = PreregistrationUser.objects.get(email=\"foo@zulip.com\")\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n\n        # Also send an invite from a different realm.\n        lear = get_realm(\"lear\")\n        lear_user = self.lear_user(\"cordelia\")\n        do_invite_users(\n            lear_user, [\"foo@zulip.com\"], [], invite_expires_in_days=invite_expires_in_days\n        )\n\n        invites = PreregistrationUser.objects.filter(email__iexact=\"foo@zulip.com\")\n        self.assert_length(invites, 4)\n\n        do_create_user(\n            \"foo@zulip.com\",\n            \"password\",\n            self.user_profile.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n        accepted_invite = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_ACTIVE\n        )\n        revoked_invites = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_REVOKED\n        )\n        # If a user was invited more than once, when it accepts one invite and register\n        # the others must be canceled.\n        self.assert_length(accepted_invite, 1)\n        self.assertEqual(accepted_invite[0].id, prereg_user.id)\n\n        expected_revoked_invites = set(invites.exclude(id=prereg_user.id).exclude(realm=lear))\n        self.assertEqual(set(revoked_invites), expected_revoked_invites)\n\n        self.assertEqual(\n            PreregistrationUser.objects.get(email__iexact=\"foo@zulip.com\", realm=lear).status, 0\n        )\n\n    def test_confirmation_obj_not_exist_error(self) -> None:\n        \"\"\"Since the key is a param input by the user to the registration endpoint,\n        if it inserts an invalid value, the confirmation object won't be found. This\n        tests if, in that scenario, we handle the exception by redirecting the user to\n        the confirmation_link_expired_error page.\n        \"\"\"\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        registration_key = \"invalid_confirmation_key\"\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_nme\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 404)\n        self.assert_in_response(\"The registration link has expired or is not valid.\", response)\n\n        registration_key = confirmation_link.split(\"/\")[-1]\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_nme\": \"alice\"}\n        )\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], response)\n        response = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(response.status_code, 302)\n\n    def test_validate_email_not_already_in_realm(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.submit_reg_form_for_user(email, password, key=registration_key)\n\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(\n            response.url,\n            reverse(\"login\") + \"?\" + urlencode({\"email\": email, \"already_registered\": 1}),\n        )\n\n    def test_confirmation_link_in_manual_license_plan(self) -> None:\n        inviter = self.example_user(\"iago\")\n        realm = get_realm(\"zulip\")\n\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(response.url, \"http://zulip.testserver/\")\n\n        self.subscribe_realm_to_monthly_plan_on_manual_license_management(realm, 5, 5)\n\n        email = self.nonreg_email(\"bob\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"bob\"})\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assert_in_success_response(\n            [\"New members cannot join this organization because all Zulip licenses are\"], response\n        )\n\n\nclass InvitationsTestCase(InviteUserBase):\n    def test_do_get_user_invites(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_invite_users(\n            user_profile,\n            [\"TestTwo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_invite_users(\n            hamlet, [\"TestThree@zulip.com\"], streams, invite_expires_in_days=invite_expires_in_days\n        )\n        do_invite_users(\n            othello, [\"TestFour@zulip.com\"], streams, invite_expires_in_days=invite_expires_in_days\n        )\n        do_invite_users(\n            self.mit_user(\"sipbtest\"),\n            [\"TestOne@mit.edu\"],\n            [],\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_create_multiuse_invite_link(\n            user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_days\n        )\n        self.assert_length(do_get_user_invites(user_profile), 5)\n        self.assert_length(do_get_user_invites(hamlet), 1)\n        self.assert_length(do_get_user_invites(othello), 1)\n\n    def test_successful_get_open_invitations(self) -> None:\n        \"\"\"\n        A GET call to /json/invites returns all unexpired invitations.\n        \"\"\"\n        active_value = getattr(confirmation_settings, \"STATUS_ACTIVE\", \"Wrong\")\n        self.assertNotEqual(active_value, \"Wrong\")\n\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n\n        with patch(\n            \"confirmation.models.timezone_now\",\n            return_value=timezone_now() - datetime.timedelta(days=invite_expires_in_days + 1),\n        ):\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_days=invite_expires_in_days,\n            )\n            do_create_multiuse_invite_link(\n                othello, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_days\n            )\n\n        prereg_user_three = PreregistrationUser(\n            email=\"TestThree@zulip.com\", referred_by=user_profile, status=active_value\n        )\n        prereg_user_three.save()\n        create_confirmation_link(\n            prereg_user_three, Confirmation.INVITATION, validity_in_days=invite_expires_in_days\n        )\n\n        do_create_multiuse_invite_link(\n            hamlet, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_days\n        )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], hamlet.id)\n\n    def test_successful_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        self.login(\"iago\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify that the scheduled email exists.\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_successful_member_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call from member account to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n\n        # Verify that the scheduled email exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify another non-admin can't delete\n        result = self.api_delete(\n            self.example_user(\"othello\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        # Verify that the scheduled email still exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify deletion works.\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n        owner = self.example_user(\"desdemona\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        result = self.api_delete(\n            self.example_user(\"iago\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_success(result)\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_multiuse_invite(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/multiuse<ID> should delete the\n        multiuse_invite.\n        \"\"\"\n        self.login(\"iago\")\n\n        zulip_realm = get_realm(\"zulip\")\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"hamlet\"), realm=zulip_realm\n        )\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assertEqual(result.status_code, 200)\n        self.assertIsNone(MultiuseInvite.objects.filter(id=multiuse_invite.id).first())\n        # Test that trying to double-delete fails\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        # Test deleting owner mutiuse_invite.\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"desdemona\"),\n            realm=zulip_realm,\n            invited_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"],\n        )\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_success(result)\n        self.assertIsNone(MultiuseInvite.objects.filter(id=multiuse_invite.id).first())\n\n        # Test deleting multiuse invite from another realm\n        mit_realm = get_realm(\"zephyr\")\n        multiuse_invite_in_mit = MultiuseInvite.objects.create(\n            referred_by=self.mit_user(\"sipbtest\"), realm=mit_realm\n        )\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_invite_in_mit, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        error_result = self.client_delete(\n            \"/json/invites/multiuse/\" + str(multiuse_invite_in_mit.id)\n        )\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_successful_resend_invitation(self) -> None:\n        \"\"\"\n        A POST call to /json/invites/<ID>/resend should send an invitation reminder email\n        and delete any scheduled invitation reminder email.\n        \"\"\"\n        self.login(\"iago\")\n        invitee = \"resend_me@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n    def test_successful_member_resend_invitation(self) -> None:\n        \"\"\"A POST call from member a account to /json/invites/<ID>/resend\n        should send an invitation reminder email and delete any\n        scheduled invitation reminder email if they send the invite.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"resend_me@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        # Verify hamlet has only one invitation (Member can resend invitations only sent by him).\n        invitation = PreregistrationUser.objects.filter(referred_by=user_profile)\n        self.assert_length(invitation, 1)\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n        self.logout()\n        self.login(\"othello\")\n        invitee = \"TestOne@zulip.com\"\n        prereg_user_one = PreregistrationUser(email=invitee, referred_by=user_profile)\n        prereg_user_one.save()\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization administrator\")\n\n    def test_resend_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n\n        invitee = \"resend_owner@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        self.check_sent_emails([invitee])\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Test only organization owners can resend owner invitation.\n        self.login(\"iago\")\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n    def test_accessing_invites_in_another_realm(self) -> None:\n        inviter = UserProfile.objects.exclude(realm=get_realm(\"zulip\")).first()\n        assert inviter is not None\n        prereg_user = PreregistrationUser.objects.create(\n            email=\"email\", referred_by=inviter, realm=inviter.realm\n        )\n        self.login(\"iago\")\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_prereg_user_status(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n\n        inviter = UserProfile.objects.filter(realm=realm).first()\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": registration_key, \"from_confirmation\": \"1\", \"full_name\": \"alice\"},\n        )\n        self.assertEqual(result.status_code, 200)\n        confirmation = Confirmation.objects.get(confirmation_key=registration_key)\n        assert confirmation.content_object is not None\n        prereg_user = confirmation.content_object\n        self.assertEqual(prereg_user.status, 0)\n\n        result = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(result.status_code, 302)\n        prereg_user = PreregistrationUser.objects.get(email=email, referred_by=inviter, realm=realm)\n        self.assertEqual(prereg_user.status, confirmation_settings.STATUS_ACTIVE)\n        user = get_user_by_delivery_email(email, realm)\n        self.assertIsNotNone(user)\n        self.assertEqual(user.delivery_email, email)\n\n\nclass InviteeEmailsParserTests(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.email1 = \"email1@zulip.com\"\n        self.email2 = \"email2@zulip.com\"\n        self.email3 = \"email3@zulip.com\"\n\n    def test_if_emails_separated_by_commas_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1} ,{self.email2}, {self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_separated_by_newlines_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1}\\n {self.email2}\\n {self.email3} \"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_from_email_client_separated_by_newlines_are_parsed_correctly(self) -> None:\n        emails_raw = (\n            f\"Email One <{self.email1}>\\nEmailTwo<{self.email2}>\\nEmail Three<{self.email3}>\"\n        )\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_in_mixed_style_are_parsed_correctly(self) -> None:\n        emails_raw = f\"Email One <{self.email1}>,EmailTwo<{self.email2}>\\n{self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n\nclass MultiuseInviteTest(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.realm = get_realm(\"zulip\")\n        self.realm.invite_required = True\n        self.realm.save()\n\n    def generate_multiuse_invite_link(\n        self, streams: Optional[List[Stream]] = None, date_sent: Optional[datetime.datetime] = None\n    ) -> str:\n        invite = MultiuseInvite(realm=self.realm, referred_by=self.example_user(\"iago\"))\n        invite.save()\n\n        if streams is not None:\n            invite.streams.set(streams)\n\n        if date_sent is None:\n            date_sent = timezone_now()\n        validity_in_days = 2\n        with patch(\"confirmation.models.timezone_now\", return_value=date_sent):\n            return create_confirmation_link(\n                invite, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n            )\n\n    def check_user_able_to_register(self, email: str, invite_link: str) -> None:\n        password = \"password\"\n\n        result = self.client_post(invite_link, {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_valid_multiuse_link(self) -> None:\n        email1 = self.nonreg_email(\"test\")\n        email2 = self.nonreg_email(\"test1\")\n        email3 = self.nonreg_email(\"alice\")\n\n        validity_in_days = 2\n        date_sent = timezone_now() - datetime.timedelta(days=validity_in_days - 1)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_able_to_register(email3, invite_link)\n\n    def test_expired_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        date_sent = timezone_now() - datetime.timedelta(\n            days=settings.INVITATION_LINK_VALIDITY_DAYS + 1\n        )\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"The confirmation link has expired or been deactivated.\", result)\n\n    def test_invalid_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"Whoops. The confirmation link is malformed.\", result)\n\n    def test_invalid_multiuse_link_in_open_realm(self) -> None:\n        self.realm.invite_required = False\n        self.realm.save()\n\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n\n        with patch(\"zerver.views.registration.get_realm_from_request\", return_value=self.realm):\n            with patch(\"zerver.views.registration.get_realm\", return_value=self.realm):\n                self.check_user_able_to_register(email, invite_link)\n\n    def test_multiuse_link_with_specified_streams(self) -> None:\n        name1 = \"newuser\"\n        name2 = \"bob\"\n        email1 = self.nonreg_email(name1)\n        email2 = self.nonreg_email(name2)\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_subscribed_only_to_streams(name1, streams)\n\n        stream_names = [\"Rome\", \"Verona\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_subscribed_only_to_streams(name2, streams)\n\n    def test_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n\n        result = self.client_post(\"/json/invites/multiuse\", {\"invite_expires_in_days\": 2})\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_with_specified_streams_api_call(self) -> None:\n        self.login(\"iago\")\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        stream_ids = [stream.id for stream in streams]\n\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\"stream_ids\": orjson.dumps(stream_ids).decode(), \"invite_expires_in_days\": 2},\n        )\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n        self.check_user_subscribed_only_to_streams(\"test\", streams)\n\n    def test_only_admin_can_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n        # Only admins should be able to create multiuse invites even if\n        # invite_to_realm_policy is set to Realm.POLICY_MEMBERS_ONLY.\n        self.realm.invite_to_realm_policy = Realm.POLICY_MEMBERS_ONLY\n        self.realm.save()\n\n        result = self.client_post(\"/json/invites/multiuse\", {\"invite_expires_in_days\": 2})\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n        self.login(\"hamlet\")\n        result = self.client_post(\"/json/invites/multiuse\")\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_multiuse_link_for_inviting_as_owner(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_days\": 2,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_days\": 2,\n            },\n        )\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_invalid_stream_api_call(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\"stream_ids\": orjson.dumps([54321]).decode(), \"invite_expires_in_days\": 2},\n        )\n        self.assert_json_error(result, \"Invalid stream id 54321. No invites were sent.\")\n\n\nclass EmailUnsubscribeTests(ZulipTestCase):\n    def test_error_unsubscribe(self) -> None:\n\n        # An invalid unsubscribe token \"test123\" produces an error.\n        result = self.client_get(\"/accounts/unsubscribe/missed_messages/test123\")\n        self.assert_in_response(\"Unknown email unsubscribe request\", result)\n\n        # An unknown message type \"fake\" produces an error.\n        user_profile = self.example_user(\"hamlet\")\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"fake\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assert_in_response(\"Unknown email unsubscribe request\", result)\n\n    def test_message_notification_emails_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in message notification emails\n        that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.enable_offline_email_notifications = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"missed_messages\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_offline_email_notifications)\n\n    def test_welcome_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in welcome e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        # Simulate a new user signing up, which enqueues 2 welcome e-mails.\n        enqueue_welcome_emails(user_profile)\n        self.assertEqual(2, ScheduledEmail.objects.filter(users=user_profile).count())\n\n        # Simulate unsubscribing from the welcome e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"welcome\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The welcome email jobs are no longer scheduled.\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(0, ScheduledEmail.objects.filter(users=user_profile).count())\n\n    def test_digest_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in digest e-mails that you can\n        click even when logged out to stop receiving them.\n\n        Unsubscribing from these emails also dequeues any digest email jobs that\n        have been queued.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_digest_emails)\n\n        # Enqueue a fake digest email.\n        context = {\n            \"name\": \"\",\n            \"realm_uri\": \"\",\n            \"unread_pms\": [],\n            \"hot_conversations\": [],\n            \"new_users\": [],\n            \"new_streams\": {\"plain\": []},\n            \"unsubscribe_link\": \"\",\n        }\n        send_future_email(\n            \"zerver/emails/digest\",\n            user_profile.realm,\n            to_user_ids=[user_profile.id],\n            context=context,\n        )\n\n        self.assertEqual(1, ScheduledEmail.objects.filter(users=user_profile).count())\n\n        # Simulate unsubscribing from digest e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"digest\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The setting is toggled off, and scheduled jobs have been removed.\n        self.assertEqual(result.status_code, 200)\n        # Circumvent user_profile caching.\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_digest_emails)\n        self.assertEqual(0, ScheduledEmail.objects.filter(users=user_profile).count())\n\n    def test_login_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in login\n        e-mails that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.enable_login_emails = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"login\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_login_emails)\n\n    def test_marketing_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in marketing e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_marketing_emails)\n\n        # Simulate unsubscribing from marketing e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"marketing\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assertEqual(result.status_code, 200)\n\n        # Circumvent user_profile caching.\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_marketing_emails)\n\n    def test_marketing_unsubscribe_post(self) -> None:\n        \"\"\"\n        The List-Unsubscribe-Post header lets email clients trigger an\n        automatic unsubscription request via POST (see RFC 8058), so\n        test that too.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_marketing_emails)\n\n        # Simulate unsubscribing from marketing e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"marketing\")\n        client = Client(enforce_csrf_checks=True)\n        result = client.post(\n            urllib.parse.urlparse(unsubscribe_link).path, {\"List-Unsubscribe\": \"One-Click\"}\n        )\n        self.assertEqual(result.status_code, 200)\n\n        # Circumvent user_profile caching.\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_marketing_emails)\n\n\nclass RealmCreationTest(ZulipTestCase):\n    @override_settings(OPEN_REALM_CREATION=True)\n    def check_able_to_create_realm(self, email: str, password: str = \"test\") -> None:\n        internal_realm = get_realm(settings.SYSTEM_BOT_REALM)\n        notification_bot = get_system_bot(settings.NOTIFICATION_BOT, internal_realm.id)\n        signups_stream, _ = create_stream_if_needed(notification_bot.realm, \"signups\")\n\n        string_id = \"zuliptest\"\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Check confirmation email has the correct subject and body, extract\n        # confirmation link and visit it\n        confirmation_url = self.get_confirmation_url_from_outbox(\n            email,\n            email_subject_contains=\"Create your Zulip organization\",\n            email_body_contains=\"You have requested a new Zulip organization\",\n        )\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password, realm_subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(\"http://zuliptest.testserver/accounts/login/subdomain/\")\n        )\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n\n        # Check that user is the owner.\n        self.assertEqual(user.role, UserProfile.ROLE_REALM_OWNER)\n\n        # Check defaults\n        self.assertEqual(realm.org_type, Realm.ORG_TYPES[\"business\"][\"id\"])\n        self.assertEqual(realm.emails_restricted_to_domains, False)\n        self.assertEqual(realm.invite_required, True)\n\n        # Check welcome messages\n        for stream_name, text, message_count in [\n            (Realm.DEFAULT_NOTIFICATION_STREAM_NAME, \"with the topic\", 3),\n            (Realm.INITIAL_PRIVATE_STREAM_NAME, \"private stream\", 1),\n        ]:\n            stream = get_stream(stream_name, realm)\n            recipient = stream.recipient\n            messages = Message.objects.filter(recipient=recipient).order_by(\"date_sent\")\n            self.assert_length(messages, message_count)\n            self.assertIn(text, messages[0].content)\n\n        # Check signup messages\n        recipient = signups_stream.recipient\n        messages = Message.objects.filter(recipient=recipient).order_by(\"id\")\n        self.assert_length(messages, 2)\n        self.assertIn(\"Signups enabled\", messages[0].content)\n        self.assertIn(\"signed up\", messages[1].content)\n        self.assertEqual(\"zuliptest\", messages[1].topic_name())\n\n        realm_creation_audit_log = RealmAuditLog.objects.get(\n            realm=realm, event_type=RealmAuditLog.REALM_CREATED\n        )\n        self.assertEqual(realm_creation_audit_log.acting_user, user)\n        self.assertEqual(realm_creation_audit_log.event_time, realm.date_created)\n\n        # Piggyback a little check for how we handle\n        # empty string_ids.\n        realm.string_id = \"\"\n        self.assertEqual(realm.display_subdomain, \".\")\n\n    def test_create_realm_non_existing_email(self) -> None:\n        self.check_able_to_create_realm(\"user1@test.com\")\n\n    def test_create_realm_existing_email(self) -> None:\n        self.check_able_to_create_realm(\"hamlet@zulip.com\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_create_realm_ldap_email(self) -> None:\n        self.init_default_ldap_database()\n\n        with self.settings(LDAP_EMAIL_ATTR=\"mail\"):\n            self.check_able_to_create_realm(\n                \"newuser_email@zulip.com\", self.ldap_password(\"newuser_with_email\")\n            )\n\n    def test_create_realm_as_system_bot(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"notification-bot@zulip.com\"})\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"notification-bot@zulip.com is reserved for system bots\", result)\n\n    def test_create_realm_no_creation_key(self) -> None:\n        \"\"\"\n        Trying to create a realm without a creation_key should fail when\n        OPEN_REALM_CREATION is false.\n        \"\"\"\n        email = \"user1@test.com\"\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            # Create new realm with the email, but no creation key.\n            result = self.client_post(\"/new/\", {\"email\": email})\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\"New organization creation disabled\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_subdomain(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=string_id, realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_marketing_emails_enabled(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=True,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertTrue(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_marketing_emails_disabled(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertFalse(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_regular_realm_welcome_bot_pm(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the correct Welcome Bot PM is sent\n        welcome_msg = Message.objects.filter(\n            sender__email=\"welcome-bot@zulip.com\", recipient__type=Recipient.PERSONAL\n        ).latest(\"id\")\n        self.assertTrue(welcome_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", welcome_msg.content)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_demo_realm_welcome_bot_pm(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n            is_demo_organization=True,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the correct Welcome Bot PM is sent\n        welcome_msg = Message.objects.filter(\n            sender__email=\"welcome-bot@zulip.com\", recipient__type=Recipient.PERSONAL\n        ).latest(\"id\")\n        self.assertTrue(welcome_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertIn(\"demo organization\", welcome_msg.content)\n\n    @override_settings(OPEN_REALM_CREATION=True, FREE_TRIAL_DAYS=30)\n    def test_create_realm_during_free_trial(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=string_id, realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.url, \"http://zuliptest.testserver/upgrade/?onboarding=true\")\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assert_in_success_response([\"Not ready to start your trial?\"], result)\n\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_two_realms(self) -> None:\n        \"\"\"\n        Verify correct behavior and PreregistrationUser handling when using\n        two pre-generated realm creation links to create two different realms.\n        \"\"\"\n        password = \"test\"\n        first_string_id = \"zuliptest\"\n        second_string_id = \"zuliptest2\"\n        email = \"user1@test.com\"\n        first_realm_name = \"Test\"\n        second_realm_name = \"Test\"\n\n        # Make sure the realms do not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(first_string_id)\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(second_string_id)\n\n        # Now we pre-generate two realm creation links\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        first_confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 1)\n\n        # Get a second realm creation link.\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        second_confirmation_url = self.get_confirmation_url_from_outbox(email)\n\n        self.assertNotEqual(first_confirmation_url, second_confirmation_url)\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 2)\n\n        # Create and verify the first realm\n        result = self.client_get(first_confirmation_url)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=first_string_id,\n            realm_name=first_realm_name,\n            key=first_confirmation_url.split(\"/\")[-1],\n        )\n        self.assertEqual(result.status_code, 302)\n        # Make sure the realm is created\n        realm = get_realm(first_string_id)\n        self.assertEqual(realm.string_id, first_string_id)\n        self.assertEqual(realm.name, first_realm_name)\n\n        # One of the PreregistrationUsers should have been used up:\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 1)\n\n        # Create and verify the second realm\n        result = self.client_get(second_confirmation_url)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=second_string_id,\n            realm_name=second_realm_name,\n            key=second_confirmation_url.split(\"/\")[-1],\n        )\n        self.assertEqual(result.status_code, 302)\n        # Make sure the realm is created\n        realm = get_realm(second_string_id)\n        self.assertEqual(realm.string_id, second_string_id)\n        self.assertEqual(realm.name, second_realm_name)\n\n        # The remaining PreregistrationUser should have been used up:\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 0)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_mailinator_signup(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"hi@mailinator.com\"})\n        self.assert_in_response(\"Please use your real email address.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        errors = {\n            \"id\": \"length 3 or greater\",\n            \"-id\": \"cannot start or end with a\",\n            \"string-ID\": \"lowercase letters\",\n            \"string_id\": \"lowercase letters\",\n            \"stream\": \"unavailable\",\n            \"streams\": \"unavailable\",\n            \"about\": \"unavailable\",\n            \"abouts\": \"unavailable\",\n            \"zephyr\": \"unavailable\",\n        }\n        for string_id, error_msg in errors.items():\n            result = self.submit_reg_form_for_user(\n                email, password, realm_subdomain=string_id, realm_name=realm_name\n            )\n            self.assert_in_response(error_msg, result)\n\n        # test valid subdomain\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"a-0\", realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.startswith(\"http://a-0.testserver/accounts/login/subdomain/\"))\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_using_old_subdomain_of_a_realm(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-name\", acting_user=None)\n\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"zulip\", realm_name=realm_name\n        )\n        self.assert_in_response(\"Subdomain unavailable. Please choose a different one.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(\n                email, password, realm_subdomain=\"\", realm_name=realm_name\n            )\n            self.assert_in_response(\"unavailable\", result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"\", realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.startswith(\"http://testserver/accounts/login/subdomain/\"))\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain_option(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                realm_subdomain=\"abcdef\",\n                realm_in_root_domain=\"true\",\n                realm_name=realm_name,\n            )\n            self.assert_in_response(\"unavailable\", result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=\"abcdef\",\n            realm_in_root_domain=\"true\",\n            realm_name=realm_name,\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.startswith(\"http://testserver/accounts/login/subdomain/\"))\n\n    def test_is_root_domain_available(self) -> None:\n        self.assertTrue(is_root_domain_available())\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            self.assertFalse(is_root_domain_available())\n        realm = get_realm(\"zulip\")\n        realm.string_id = Realm.SUBDOMAIN_FOR_ROOT_DOMAIN\n        realm.save()\n        self.assertFalse(is_root_domain_available())\n\n    def test_subdomain_check_api(self) -> None:\n        result = self.client_get(\"/json/realm/subdomain/zulip\")\n        self.assert_in_success_response(\n            [\"Subdomain unavailable. Please choose a different one.\"], result\n        )\n\n        result = self.client_get(\"/json/realm/subdomain/zu_lip\")\n        self.assert_in_success_response(\n            [\"Subdomain can only have lowercase letters, numbers, and '-'s.\"], result\n        )\n\n        with self.settings(SOCIAL_AUTH_SUBDOMAIN=\"zulipauth\"):\n            result = self.client_get(\"/json/realm/subdomain/zulipauth\")\n            self.assert_in_success_response(\n                [\"Subdomain unavailable. Please choose a different one.\"], result\n            )\n\n        result = self.client_get(\"/json/realm/subdomain/hufflepuff\")\n        self.assert_in_success_response([\"available\"], result)\n        self.assert_not_in_success_response([\"unavailable\"], result)\n\n    def test_subdomain_check_management_command(self) -> None:\n        # Short names should not work, even with the flag\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"aa\")\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"aa\", allow_reserved_subdomain=True)\n\n        # Malformed names should never work\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"-ba_d-\")\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"-ba_d-\", allow_reserved_subdomain=True)\n\n        with patch(\"zerver.lib.name_restrictions.is_reserved_subdomain\", return_value=False):\n            # Existing realms should never work even if they are not reserved keywords\n            with self.assertRaises(ValidationError):\n                check_subdomain_available(\"zulip\")\n            with self.assertRaises(ValidationError):\n                check_subdomain_available(\"zulip\", allow_reserved_subdomain=True)\n\n        # Reserved ones should only work with the flag\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"stream\")\n        check_subdomain_available(\"stream\", allow_reserved_subdomain=True)\n\n\nclass UserSignUpTest(InviteUserBase):\n    def _assert_redirected_to(self, result: HttpResponse, url: str) -> None:\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"LOCATION\"], url)\n\n    def verify_signup(\n        self,\n        *,\n        email: str = \"newguy@zulip.com\",\n        password: Optional[str] = \"newpassword\",\n        full_name: str = \"New user's name\",\n        realm: Optional[Realm] = None,\n        subdomain: Optional[str] = None,\n    ) -> Union[UserProfile, HttpResponse]:\n        \"\"\"Common test function for signup tests.  It is a goal to use this\n        common function for all signup tests to avoid code duplication; doing\n        so will likely require adding new parameters.\"\"\"\n\n        if realm is None:  # nocoverage\n            realm = get_realm(\"zulip\")\n\n        client_kwargs: Dict[str, Any] = {}\n        if subdomain:\n            client_kwargs[\"subdomain\"] = subdomain\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, **client_kwargs)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"], **client_kwargs)\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, **client_kwargs)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS. This should create our\n        # account, log us in, and redirect to the app.\n        result = self.submit_reg_form_for_user(\n            email, password, full_name=full_name, **client_kwargs\n        )\n\n        if result.status_code == 200:\n            # This usually indicated an error returned when submitting the form.\n            # Return the result for the caller to deal with reacting to this, since\n            # in many tests this is expected and the caller wants to assert the content\n            # of the error.\n            return result\n\n        # Verify that we were served a redirect to the app.\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"{realm.uri}/\")\n\n        # Verify that we successfully logged in.\n        user_profile = get_user_by_delivery_email(email, realm)\n        self.assert_logged_in_user_id(user_profile.id)\n        return user_profile\n\n    def test_bad_email_configuration_for_accounts_home(self) -> None:\n        \"\"\"\n        Make sure we redirect for EmailNotDeliveredException.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n\n        smtp_mock = patch(\n            \"zerver.views.registration.send_confirm_registration_email\",\n            side_effect=EmailNotDeliveredException,\n        )\n\n        with smtp_mock, self.assertLogs(level=\"ERROR\") as m:\n            result = self.client_post(\"/accounts/home/\", {\"email\": email})\n\n        self._assert_redirected_to(result, \"/config-error/smtp\")\n        self.assertEqual(m.output, [\"ERROR:root:Error in accounts_home\"])\n\n    def test_bad_email_configuration_for_create_realm(self) -> None:\n        \"\"\"\n        Make sure we redirect for EmailNotDeliveredException.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n\n        smtp_mock = patch(\n            \"zerver.views.registration.send_confirm_registration_email\",\n            side_effect=EmailNotDeliveredException,\n        )\n\n        with smtp_mock, self.assertLogs(level=\"ERROR\") as m:\n            result = self.client_post(\"/new/\", {\"email\": email})\n\n        self._assert_redirected_to(result, \"/config-error/smtp\")\n        self.assertEqual(m.output, [\"ERROR:root:Error in create_realm\"])\n\n    def test_user_default_language_and_timezone(self) -> None:\n        \"\"\"\n        Check if the default language of new user is the default language\n        of the realm.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        timezone = \"US/Mountain\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"default_language\", \"de\", acting_user=None)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, timezone=timezone)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        self.assertEqual(user_profile.default_language, realm.default_language)\n        self.assertEqual(user_profile.timezone, timezone)\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_default_twenty_four_hour_time(self) -> None:\n        \"\"\"\n        Check if the default twenty_four_hour_time setting of new user\n        is the default twenty_four_hour_time of the realm.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        do_set_realm_user_default_setting(\n            realm_user_default, \"twenty_four_hour_time\", True, acting_user=None\n        )\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        self.assertEqual(\n            user_profile.twenty_four_hour_time, realm_user_default.twenty_four_hour_time\n        )\n\n    def test_signup_already_active(self) -> None:\n        \"\"\"\n        Check if signing up with an active email redirects to a login page.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result[\"Location\"])\n        result = self.client_get(result.url)\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_system_bot(self) -> None:\n        email = \"notification-bot@zulip.com\"\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=\"lear\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result[\"Location\"])\n        result = self.client_get(result.url)\n\n        # This is not really the right error message, but at least it's an error.\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_existing_email(self) -> None:\n        \"\"\"\n        Check if signing up with an email used in another realm succeeds.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        self.verify_signup(email=email, realm=get_realm(\"lear\"), subdomain=\"lear\")\n        self.assertEqual(UserProfile.objects.filter(delivery_email=email).count(), 2)\n\n    def test_signup_invalid_name(self) -> None:\n        \"\"\"\n        Check if an invalid name during signup is handled properly.\n        \"\"\"\n\n        result = self.verify_signup(full_name=\"<invalid>\")\n        self.assert_in_success_response([\"Invalid characters in name!\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response([\"id_password\", \"id_full_name\"], result)\n\n    def test_signup_without_password(self) -> None:\n        \"\"\"\n        Check if signing up without a password works properly when\n        password_auth_enabled is False.\n        \"\"\"\n        email = self.nonreg_email(\"newuser\")\n        with patch(\"zerver.views.registration.password_auth_enabled\", return_value=False):\n            user_profile = self.verify_signup(email=email, password=None)\n\n        assert isinstance(user_profile, UserProfile)\n        # User should now be logged in.\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_signup_without_full_name(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n        result = self.verify_signup(email=email, password=password, full_name=\"\")\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response([\"id_password\", \"id_full_name\"], result)\n\n    def test_signup_email_message_contains_org_header(self) -> None:\n        email = \"newguy@zulip.com\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        from django.core.mail import outbox\n\n        self.assertEqual(outbox[0].extra_headers[\"List-Id\"], \"Zulip Dev <zulip.testserver>\")\n\n    def test_signup_with_full_name(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": password,\n                \"key\": find_key_by_email(email),\n                \"terms\": True,\n                \"full_name\": \"New Guy\",\n                \"from_confirmation\": \"1\",\n            },\n        )\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n    def test_signup_with_weak_password(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        with self.settings(PASSWORD_MIN_LENGTH=6, PASSWORD_MIN_GUESSES=1000):\n            result = self.client_post(\n                \"/accounts/register/\",\n                {\n                    \"password\": \"easy\",\n                    \"key\": find_key_by_email(email),\n                    \"terms\": True,\n                    \"full_name\": \"New Guy\",\n                    \"from_confirmation\": \"1\",\n                },\n            )\n            self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n            result = self.submit_reg_form_for_user(email, \"easy\", full_name=\"New Guy\")\n            self.assert_in_success_response([\"The password is too weak.\"], result)\n            with self.assertRaises(UserProfile.DoesNotExist):\n                # Account wasn't created.\n                get_user(email, get_realm(\"zulip\"))\n\n    def test_signup_with_default_stream_group(self) -> None:\n        # Check if user is subscribed to the streams of default\n        # stream group as well as default streams.\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        default_streams = []\n\n        existing_default_streams = DefaultStream.objects.filter(realm=realm)\n        self.assert_length(existing_default_streams, 1)\n        self.assertEqual(existing_default_streams[0].stream.name, \"Verona\")\n        default_streams.append(existing_default_streams[0].stream)\n\n        for stream_name in [\"venice\", \"rome\"]:\n            stream = get_stream(stream_name, realm)\n            do_add_default_stream(stream)\n            default_streams.append(stream)\n\n        group1_streams = []\n        for stream_name in [\"scotland\", \"denmark\"]:\n            stream = get_stream(stream_name, realm)\n            group1_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 1\", \"group 1 description\", group1_streams)\n\n        result = self.submit_reg_form_for_user(email, password, default_stream_groups=[\"group 1\"])\n        self.check_user_subscribed_only_to_streams(\"newguy\", default_streams + group1_streams)\n\n    def test_signup_two_confirmation_links(self) -> None:\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n        first_confirmation_url = self.get_confirmation_url_from_outbox(email)\n        first_confirmation_key = find_key_by_email(email)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n        second_confirmation_url = self.get_confirmation_url_from_outbox(email)\n\n        # Sanity check:\n        self.assertNotEqual(first_confirmation_url, second_confirmation_url)\n\n        # Register the account (this will use the second confirmation url):\n        result = self.submit_reg_form_for_user(\n            email, password, full_name=\"New Guy\", from_confirmation=\"1\"\n        )\n        self.assert_in_success_response(\n            [\"We just need you to do one last thing.\", \"New Guy\", email], result\n        )\n        result = self.submit_reg_form_for_user(email, password, full_name=\"New Guy\")\n        user_profile = UserProfile.objects.get(delivery_email=email)\n        self.assertEqual(user_profile.delivery_email, email)\n\n        # Now try to to register using the first confirmation url:\n        result = self.client_get(first_confirmation_url)\n        self.assertEqual(result.status_code, 404)\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": password,\n                \"key\": first_confirmation_key,\n                \"terms\": True,\n                \"full_name\": \"New Guy\",\n                \"from_confirmation\": \"1\",\n            },\n        )\n        # Error page should be displayed\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"The registration link has expired or is not valid.\", result)\n\n    def test_signup_with_multiple_default_stream_groups(self) -> None:\n        # Check if user is subscribed to the streams of default\n        # stream groups as well as default streams.\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        DefaultStream.objects.filter(realm=realm).delete()\n        default_streams = []\n        for stream_name in [\"venice\", \"verona\"]:\n            stream = get_stream(stream_name, realm)\n            do_add_default_stream(stream)\n            default_streams.append(stream)\n\n        group1_streams = []\n        for stream_name in [\"scotland\", \"denmark\"]:\n            stream = get_stream(stream_name, realm)\n            group1_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 1\", \"group 1 description\", group1_streams)\n\n        group2_streams = []\n        for stream_name in [\"scotland\", \"rome\"]:\n            stream = get_stream(stream_name, realm)\n            group2_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 2\", \"group 2 description\", group2_streams)\n\n        result = self.submit_reg_form_for_user(\n            email, password, default_stream_groups=[\"group 1\", \"group 2\"]\n        )\n        self.check_user_subscribed_only_to_streams(\n            \"newguy\", list(set(default_streams + group1_streams + group2_streams))\n        )\n\n    def test_signup_without_user_settings_from_another_realm(self) -> None:\n        hamlet_in_zulip = self.example_user(\"hamlet\")\n        email = hamlet_in_zulip.delivery_email\n        password = \"newpassword\"\n        subdomain = \"lear\"\n        realm = get_realm(\"lear\")\n\n        # Make an account in the Zulip realm, but we're not copying from there.\n        hamlet_in_zulip.left_side_userlist = True\n        hamlet_in_zulip.default_language = \"de\"\n        hamlet_in_zulip.emojiset = \"twitter\"\n        hamlet_in_zulip.high_contrast_mode = True\n        hamlet_in_zulip.enter_sends = True\n        hamlet_in_zulip.tutorial_status = UserProfile.TUTORIAL_FINISHED\n        hamlet_in_zulip.save()\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=subdomain)\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"], subdomain=subdomain)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, subdomain=subdomain)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email, password, source_realm_id=\"\", HTTP_HOST=subdomain + \".testserver\"\n        )\n\n        hamlet = get_user(self.example_email(\"hamlet\"), realm)\n        self.assertEqual(hamlet.left_side_userlist, False)\n        self.assertEqual(hamlet.default_language, \"en\")\n        self.assertEqual(hamlet.emojiset, \"google\")\n        self.assertEqual(hamlet.high_contrast_mode, False)\n        self.assertEqual(hamlet.enable_stream_audible_notifications, False)\n        self.assertEqual(hamlet.enter_sends, False)\n        self.assertEqual(hamlet.tutorial_status, UserProfile.TUTORIAL_WAITING)\n\n    def test_signup_with_user_settings_from_another_realm(self) -> None:\n        hamlet_in_zulip = self.example_user(\"hamlet\")\n        email = hamlet_in_zulip.delivery_email\n        password = \"newpassword\"\n        subdomain = \"lear\"\n        lear_realm = get_realm(\"lear\")\n\n        self.login(\"hamlet\")\n        with get_test_image_file(\"img.png\") as image_file:\n            self.client_post(\"/json/users/me/avatar\", {\"file\": image_file})\n        hamlet_in_zulip.refresh_from_db()\n        hamlet_in_zulip.left_side_userlist = True\n        hamlet_in_zulip.default_language = \"de\"\n        hamlet_in_zulip.emojiset = \"twitter\"\n        hamlet_in_zulip.high_contrast_mode = True\n        hamlet_in_zulip.enter_sends = True\n        hamlet_in_zulip.tutorial_status = UserProfile.TUTORIAL_FINISHED\n        hamlet_in_zulip.save()\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=subdomain)\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"], subdomain=subdomain)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, subdomain=subdomain)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"password\": password, \"key\": find_key_by_email(email), \"from_confirmation\": \"1\"},\n            subdomain=subdomain,\n        )\n        self.assert_in_success_response(\n            [\n                \"Import settings from existing Zulip account\",\n                \"selected >\\n                            Zulip Dev\",\n                \"We just need you to do one last thing.\",\n            ],\n            result,\n        )\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            source_realm_id=str(hamlet_in_zulip.realm.id),\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n\n        hamlet_in_lear = get_user(email, lear_realm)\n        self.assertEqual(hamlet_in_lear.left_side_userlist, True)\n        self.assertEqual(hamlet_in_lear.default_language, \"de\")\n        self.assertEqual(hamlet_in_lear.emojiset, \"twitter\")\n        self.assertEqual(hamlet_in_lear.high_contrast_mode, True)\n        self.assertEqual(hamlet_in_lear.enter_sends, True)\n        self.assertEqual(hamlet_in_lear.enable_stream_audible_notifications, False)\n        self.assertEqual(hamlet_in_lear.tutorial_status, UserProfile.TUTORIAL_FINISHED)\n\n        zulip_path_id = avatar_disk_path(hamlet_in_zulip)\n        lear_path_id = avatar_disk_path(hamlet_in_lear)\n        with open(zulip_path_id, \"rb\") as f:\n            zulip_avatar_bits = f.read()\n        with open(lear_path_id, \"rb\") as f:\n            lear_avatar_bits = f.read()\n\n        self.assertGreater(len(zulip_avatar_bits), 500)\n        self.assertEqual(zulip_avatar_bits, lear_avatar_bits)\n\n    def test_signup_invalid_subdomain(self) -> None:\n        \"\"\"\n        Check if attempting to authenticate to the wrong subdomain logs an\n        error and redirects.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        def invalid_subdomain(**kwargs: Any) -> Any:\n            return_data = kwargs.get(\"return_data\", {})\n            return_data[\"invalid_subdomain\"] = True\n\n        with patch(\"zerver.views.registration.authenticate\", side_effect=invalid_subdomain):\n            with self.assertLogs(level=\"ERROR\") as m:\n                result = self.client_post(\n                    \"/accounts/register/\",\n                    {\n                        \"password\": password,\n                        \"full_name\": \"New User\",\n                        \"key\": find_key_by_email(email),\n                        \"terms\": True,\n                    },\n                )\n                self.assertEqual(\n                    m.output,\n                    [\"ERROR:root:Subdomain mismatch in registration zulip: newuser@zulip.com\"],\n                )\n        self.assertEqual(result.status_code, 302)\n\n    def test_signup_using_invalid_subdomain_preserves_state_of_form(self) -> None:\n        \"\"\"\n        Check that when we give invalid subdomain and submit the registration form\n        all the values in the form are preserved.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n\n        password = \"test\"\n        email = self.example_email(\"iago\")\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            # Subdomain is already used, by construction.\n            realm_subdomain=realm.string_id,\n            realm_name=realm_name,\n            source_realm_id=str(realm.id),\n        )\n        self.assert_in_success_response(\n            [\n                \"Subdomain unavailable. Please choose a different one.\",\n                \"Zulip Dev\\n\",\n                'value=\"test\"',\n                'name=\"realm_name\"',\n            ],\n            result,\n        )\n\n    def test_replace_subdomain_in_confirmation_link(self) -> None:\n        \"\"\"\n        Check that manually changing the subdomain in a registration\n        confirmation link doesn't allow you to register to a different realm.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        self.client_post(\"/accounts/home/\", {\"email\": email})\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": \"password\",\n                \"key\": find_key_by_email(email),\n                \"terms\": True,\n                \"full_name\": \"New User\",\n                \"from_confirmation\": \"1\",\n            },\n            subdomain=\"zephyr\",\n        )\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"We couldn't find your confirmation link\", result)\n\n    def test_signup_to_realm_on_manual_license_plan(self) -> None:\n        realm = get_realm(\"zulip\")\n        denmark_stream = get_stream(\"Denmark\", realm)\n        realm.signup_notifications_stream = denmark_stream\n        realm.save(update_fields=[\"signup_notifications_stream\"])\n\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(realm, 5, 5)\n\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertIn(\n                \"New members cannot join this organization because all Zulip licenses\",\n                form.errors[\"email\"][0],\n            )\n            last_message = Message.objects.last()\n            assert last_message is not None\n            self.assertIn(\n                f\"A new member ({self.nonreg_email('test')}) was unable to join your organization because all Zulip\",\n                last_message.content,\n            )\n            self.assertEqual(last_message.recipient.type_id, denmark_stream.id)\n\n        ledger.licenses_at_next_renewal = 50\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertIn(\n                \"New members cannot join this organization because all Zulip licenses\",\n                form.errors[\"email\"][0],\n            )\n\n        ledger.licenses = 50\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertEqual(form.errors, {})\n\n    def test_failed_signup_due_to_restricted_domain(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"invite_required\", False, acting_user=None)\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        email = \"user@acme.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\n            f\"Your email address, {email}, is not in one of the domains\", form.errors[\"email\"][0]\n        )\n\n    def test_failed_signup_due_to_disposable_email(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.emails_restricted_to_domains = False\n        realm.disallow_disposable_email_addresses = True\n        realm.save()\n\n        email = \"abc@mailnator.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\"Please use your real email address\", form.errors[\"email\"][0])\n\n    def test_failed_signup_due_to_email_containing_plus(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.emails_restricted_to_domains = True\n        realm.save()\n\n        email = \"iago+label@zulip.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\n            \"Email addresses containing + are not allowed in this organization.\",\n            form.errors[\"email\"][0],\n        )\n\n    def test_failed_signup_due_to_invite_required(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n        email = \"user@zulip.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(f\"Please request an invite for {email} from\", form.errors[\"email\"][0])\n\n    def test_failed_signup_due_to_nonexistent_realm(self) -> None:\n        email = \"user@acme.com\"\n        form = HomepageForm({\"email\": email}, realm=None)\n        self.assertIn(\n            f\"organization you are trying to join using {email} does not exist\",\n            form.errors[\"email\"][0],\n        )\n\n    def test_access_signup_page_in_root_domain_without_realm(self) -> None:\n        result = self.client_get(\"/register\", subdomain=\"\", follow=True)\n        self.assert_in_success_response([\"Find your Zulip accounts\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_from_confirmation(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\n                    \"We just need you to do one last thing.\",\n                    \"New LDAP fullname\",\n                    \"newuser@zulip.com\",\n                ],\n                result,\n            )\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response([\"id_full_name\"], result)\n            # Verify that user is asked for its LDAP/Active Directory password.\n            self.assert_in_success_response(\n                [\"Enter your LDAP/Active Directory password.\", \"ldap-password\"], result\n            )\n            self.assert_not_in_success_response([\"id_password\"], result)\n\n            # Test the TypeError exception handler\n            with patch(\n                \"zproject.backends.ZulipLDAPAuthBackendBase.get_mapped_name\", side_effect=TypeError\n            ):\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", \"newuser@zulip.com\"], result\n            )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipLDAPUserPopulator\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_populate_only_registration_from_confirmation(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_BIND_PASSWORD=\"\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTH_LDAP_USER_DN_TEMPLATE=\"uid=%(user)s,ou=users,dc=zulip,dc=com\",\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\n                    \"We just need you to do one last thing.\",\n                    \"New LDAP fullname\",\n                    \"newuser@zulip.com\",\n                ],\n                result,\n            )\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response([\"id_full_name\"], result)\n            # Verify that user is NOT asked for its LDAP/Active Directory password.\n            # LDAP is not configured for authentication in this test.\n            self.assert_not_in_success_response(\n                [\"Enter your LDAP/Active Directory password.\", \"ldap-password\"], result\n            )\n            # If we were using e.g. the SAML auth backend, there\n            # shouldn't be a password prompt, but since it uses the\n            # EmailAuthBackend, there should be password field here.\n            self.assert_in_success_response([\"id_password\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_end_to_end(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        full_name = \"New LDAP fullname\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            # Full name should be set from LDAP\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", full_name, \"newuser@zulip.com\"], result\n            )\n\n            # Submit the final form with the wrong password.\n            result = self.submit_reg_form_for_user(\n                email,\n                \"wrongpassword\",\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            # Didn't create an account\n            with self.assertRaises(UserProfile.DoesNotExist):\n                user_profile = UserProfile.objects.get(delivery_email=email)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n\n            # Submit the final form with the correct password.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_split_full_name_mapping(self) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"first_name\": \"sn\", \"last_name\": \"cn\"}\n\n        subdomain = \"zulip\"\n        email = \"newuser_splitname@zulip.com\"\n        password = self.ldap_password(\"newuser_splitname\")\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            # Test split name mapping.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, \"First Last\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_auto_registration_on_login(self) -> None:\n        \"\"\"The most common way for LDAP authentication to be used is with a\n        server that doesn't have a terms-of-service required, in which\n        case we offer a complete single-sign-on experience (where the\n        user just enters their LDAP username and password, and their\n        account is created if it doesn't already exist).\n\n        This test verifies that flow.\n        \"\"\"\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\n            \"full_name\": \"cn\",\n            \"custom_profile_field__phone_number\": \"homePhone\",\n        }\n        full_name = \"New LDAP fullname\"\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n            # Test custom profile fields are properly synced.\n            phone_number_field = CustomProfileField.objects.get(\n                realm=user_profile.realm, name=\"Phone number\"\n            )\n            phone_number_field_value = CustomProfileFieldValue.objects.get(\n                user_profile=user_profile, field=phone_number_field\n            )\n            self.assertEqual(phone_number_field_value.value, \"a-new-number\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_auto_registration_on_login_invalid_email_in_directory(self) -> None:\n        password = self.ldap_password(\"newuser_with_email\")\n        username = \"newuser_with_email\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n\n        self.change_ldap_user_attr(\"newuser_with_email\", \"mail\", \"thisisnotavalidemail\")\n\n        with self.settings(\n            LDAP_EMAIL_ATTR=\"mail\",\n        ), self.assertLogs(\"zulip.auth.ldap\", \"WARNING\") as mock_log:\n            original_user_count = UserProfile.objects.count()\n            self.login_with_return(username, password, HTTP_HOST=subdomain + \".testserver\")\n            # Verify that the process failed as intended - no UserProfile is created.\n            self.assertEqual(UserProfile.objects.count(), original_user_count)\n            self.assertEqual(\n                mock_log.output,\n                [\"WARNING:zulip.auth.ldap:thisisnotavalidemail is not a valid email address.\"],\n            )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_registration_multiple_realms(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\n            \"full_name\": \"cn\",\n        }\n        do_create_realm(\"test\", \"test\", emails_restricted_to_domains=False)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            subdomain = \"zulip\"\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email, realm=get_realm(\"zulip\"))\n            self.logout()\n\n            # Test registration in another realm works.\n            subdomain = \"test\"\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email, realm=get_realm(\"test\"))\n            self.assertEqual(user_profile.delivery_email, email)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_when_names_changes_are_disabled(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link. This will 'authenticated_full_name'\n            # session variable which will be used to set the fullname of\n            # the user.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            with patch(\"zerver.views.registration.name_changes_disabled\", return_value=True):\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from LDAP session.\n            self.assertEqual(user_profile.full_name, \"New LDAP fullname\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_signup_with_ldap_and_email_enabled_using_email_with_ldap_append_domain(self) -> None:\n        password = \"nonldappassword\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # If the user's email is inside the LDAP directory and we just\n        # have a wrong password, then we refuse to create an account\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because password was wrong\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n\n        # For the rest of the test we delete the user from ldap.\n        del self.mock_ldap.directory[\"uid=newuser,ou=users,dc=zulip,dc=com\"]\n\n        # If the user's email is not in the LDAP directory, but fits LDAP_APPEND_DOMAIN,\n        # we refuse to create the account.\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ), self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because emails matching LDAP_APPEND_DOMAIN,\n            # aren't allowed to create non-LDAP accounts.\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: newuser. Input username: newuser@zulip.com\"\n                ],\n            )\n\n        # If the email is outside of LDAP_APPEND_DOMAIN, we successfully create a non-LDAP account,\n        # with the password managed in the Zulip database.\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"example.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(level=\"WARNING\") as m:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(result.status_code, 200)\n            self.assertEqual(\n                m.output,\n                [\"WARNING:root:New account email newuser@zulip.com could not be found in LDAP\"],\n            )\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    full_name=\"Non-LDAP Full Name\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: Email newuser@zulip.com does not match LDAP domain example.com.\"\n                ],\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"http://zulip.testserver/\")\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from the POST request, not LDAP\n            self.assertEqual(user_profile.full_name, \"Non-LDAP Full Name\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_signup_with_ldap_and_email_enabled_using_email_with_ldap_email_search(self) -> None:\n        # If the user's email is inside the LDAP directory and we just\n        # have a wrong password, then we refuse to create an account\n        password = \"nonldappassword\"\n        email = \"newuser_email@zulip.com\"  # belongs to user uid=newuser_with_email in the test directory\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because password was wrong\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser_email%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n\n        # If the user's email is not in the LDAP directory , though, we\n        # successfully create an account with a password in the Zulip\n        # database.\n        password = \"nonldappassword\"\n        email = \"nonexistent@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(level=\"WARNING\") as m:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n                self.assertEqual(result.status_code, 200)\n                self.assertEqual(\n                    m.output,\n                    [\n                        \"WARNING:root:New account email nonexistent@zulip.com could not be found in LDAP\"\n                    ],\n                )\n\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    full_name=\"Non-LDAP Full Name\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: nonexistent@zulip.com. Input username: nonexistent@zulip.com\"\n                ],\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"http://zulip.testserver/\")\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from the POST request, not LDAP\n            self.assertEqual(user_profile.full_name, \"Non-LDAP Full Name\")\n\n    def ldap_invite_and_signup_as(\n        self, invite_as: int, streams: Sequence[str] = [\"Denmark\"]\n    ) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        subdomain = \"zulip\"\n        email = \"newuser@zulip.com\"\n        password = self.ldap_password(\"newuser\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                # Invite user.\n                self.login(\"iago\")\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: iago. Input username: iago@zulip.com\"\n                ],\n            )\n            response = self.invite(\n                invitee_emails=\"newuser@zulip.com\", stream_names=streams, invite_as=invite_as\n            )\n            self.assert_json_success(response)\n            self.logout()\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_user_as_admin(self) -> None:\n        self.ldap_invite_and_signup_as(PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"])\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_realm_admin)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_user_as_guest(self) -> None:\n        self.ldap_invite_and_signup_as(PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_guest)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_streams(self) -> None:\n        stream_name = \"Rome\"\n        realm = get_realm(\"zulip\")\n        stream = get_stream(stream_name, realm)\n        default_streams = get_default_streams_for_realm(realm.id)\n        default_streams_name = [stream.name for stream in default_streams]\n        self.assertNotIn(stream_name, default_streams_name)\n\n        # Invite user.\n        self.ldap_invite_and_signup_as(\n            PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"], streams=[stream_name]\n        )\n\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_realm_admin)\n        sub = get_stream_subscriptions_for_user(user_profile).filter(recipient__type_id=stream.id)\n        self.assert_length(sub, 1)\n\n    def test_registration_when_name_changes_are_disabled(self) -> None:\n        \"\"\"\n        Test `name_changes_disabled` when we are not running under LDAP.\n        \"\"\"\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with patch(\"zerver.views.registration.name_changes_disabled\", return_value=True):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"New Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # 'New Name' comes from POST data; not from LDAP session.\n            self.assertEqual(user_profile.full_name, \"New Name\")\n\n    def test_realm_creation_through_ldap(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n            TERMS_OF_SERVICE=False,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            key = find_key_by_email(email)\n            confirmation = Confirmation.objects.get(confirmation_key=key)\n            prereg_user = confirmation.content_object\n            assert prereg_user is not None\n            prereg_user.realm_creation = True\n            prereg_user.save()\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                realm_name=realm_name,\n                realm_subdomain=subdomain,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", \"newuser@zulip.com\"], result\n            )\n\n    @patch(\n        \"DNS.dnslookup\",\n        return_value=[[\"sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh\"]],\n    )\n    def test_registration_of_mirror_dummy_user(self, ignored: Any) -> None:\n        password = \"test\"\n        subdomain = \"zephyr\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        user_profile.is_mirror_dummy = True\n        user_profile.save()\n        change_user_is_active(user_profile, False)\n\n        result = self.client_post(\"/register/\", {\"email\": email}, subdomain=\"zephyr\")\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"], subdomain=\"zephyr\")\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url, subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 200)\n\n        # If the mirror dummy user is already active, attempting to\n        # submit the registration form should raise an AssertionError\n        # (this is an invalid state, so it's a bug we got here):\n        change_user_is_active(user_profile, True)\n\n        with self.assertRaisesRegex(\n            AssertionError, \"Mirror dummy user is already active!\"\n        ), self.assertLogs(\"django.request\", \"ERROR\") as error_log:\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n        self.assertTrue(\n            \"ERROR:django.request:Internal Server Error: /accounts/register/\" in error_log.output[0]\n        )\n        self.assertTrue(\n            'raise AssertionError(\"Mirror dummy user is already active!' in error_log.output[0]\n        )\n        self.assertTrue(\n            \"AssertionError: Mirror dummy user is already active!\" in error_log.output[0]\n        )\n\n        change_user_is_active(user_profile, False)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            from_confirmation=\"1\",\n            # Pass HTTP_HOST for the target subdomain\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            # Pass HTTP_HOST for the target subdomain\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @patch(\n        \"DNS.dnslookup\",\n        return_value=[[\"sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh\"]],\n    )\n    def test_registration_of_active_mirror_dummy_user(self, ignored: Any) -> None:\n        \"\"\"\n        Trying to activate an already-active mirror dummy user should\n        raise an AssertionError.\n        \"\"\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        user_profile.is_mirror_dummy = True\n        user_profile.save()\n        change_user_is_active(user_profile, True)\n\n        with self.assertRaisesRegex(\n            AssertionError, \"Mirror dummy user is already active!\"\n        ), self.assertLogs(\"django.request\", \"ERROR\") as error_log:\n            self.client_post(\"/register/\", {\"email\": email}, subdomain=\"zephyr\")\n        self.assertTrue(\n            \"ERROR:django.request:Internal Server Error: /register/\" in error_log.output[0]\n        )\n        self.assertTrue(\n            'raise AssertionError(\"Mirror dummy user is already active!' in error_log.output[0]\n        )\n        self.assertTrue(\n            \"AssertionError: Mirror dummy user is already active!\" in error_log.output[0]\n        )\n\n    @override_settings(TERMS_OF_SERVICE=False)\n    def test_dev_user_registration(self) -> None:\n        \"\"\"Verify that /devtools/register_user creates a new user, logs them\n        in, and redirects to the logged-in app.\"\"\"\n        count = UserProfile.objects.count()\n        email = f\"user-{count}@zulip.com\"\n\n        result = self.client_post(\"/devtools/register_user/\")\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(user_profile.delivery_email, email)\n        self.assertEqual(result[\"Location\"], \"http://zulip.testserver/\")\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TERMS_OF_SERVICE=False)\n    def test_dev_user_registration_create_realm(self) -> None:\n        count = UserProfile.objects.count()\n        string_id = f\"realm-{count}\"\n\n        result = self.client_post(\"/devtools/register_realm/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(f\"http://{string_id}.testserver/accounts/login/subdomain\")\n        )\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"http://{string_id}.testserver\")\n\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TERMS_OF_SERVICE=False)\n    def test_dev_user_registration_create_demo_realm(self) -> None:\n        result = self.client_post(\"/devtools/register_demo_realm/\")\n        self.assertEqual(result.status_code, 302)\n\n        realm = Realm.objects.latest(\"date_created\")\n        self.assertTrue(\n            result[\"Location\"].startswith(\n                f\"http://{realm.string_id}.testserver/accounts/login/subdomain\"\n            )\n        )\n        result = self.client_get(result[\"Location\"], subdomain=realm.string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"http://{realm.string_id}.testserver\")\n\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n        self.assert_logged_in_user_id(user_profile.id)\n\n        expected_deletion_date = realm.date_created + datetime.timedelta(\n            days=settings.DEMO_ORG_DEADLINE_DAYS\n        )\n        self.assertEqual(realm.demo_organization_scheduled_deletion_date, expected_deletion_date)\n\n\nclass DeactivateUserTest(ZulipTestCase):\n    def test_deactivate_user(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.email\n        self.login_user(user)\n        self.assertTrue(user.is_active)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        user = self.example_user(\"hamlet\")\n        self.assertFalse(user.is_active)\n        password = initial_password(email)\n        assert password is not None\n        self.assert_login_failure(email, password=password)\n\n    def test_do_not_deactivate_final_owner(self) -> None:\n        user = self.example_user(\"desdemona\")\n        user_2 = self.example_user(\"iago\")\n        self.login_user(user)\n        self.assertTrue(user.is_active)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_error(result, \"Cannot deactivate the only organization owner.\")\n        user = self.example_user(\"desdemona\")\n        self.assertTrue(user.is_active)\n        self.assertTrue(user.is_realm_owner)\n        do_change_user_role(user_2, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n        self.assertTrue(user_2.is_realm_owner)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        do_change_user_role(user, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n\n    def test_do_not_deactivate_final_user(self) -> None:\n        realm = get_realm(\"zulip\")\n        for user_profile in UserProfile.objects.filter(realm=realm).exclude(\n            role=UserProfile.ROLE_REALM_OWNER\n        ):\n            do_deactivate_user(user_profile, acting_user=None)\n        user = self.example_user(\"desdemona\")\n        self.login_user(user)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_error(result, \"Cannot deactivate the only user.\")\n\n\nclass TestLoginPage(ZulipTestCase):\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_redirects_for_root_alias(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Fupgrade%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_redirects_for_root_domain(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Fupgrade%2F\")\n\n        mock_get_host.return_value = \"www.testserver.com\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n            EXTERNAL_HOST=\"www.testserver.com\",\n            ROOT_SUBDOMAIN_ALIASES=[\"test\"],\n        ):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Fupgrade%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_works_without_subdomains(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"www\"]):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"www\"]):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n    def test_login_page_registration_hint(self) -> None:\n        response = self.client_get(\"/login/\")\n        self.assert_not_in_success_response(\n            [\"Don't have an account yet? You need to be invited to join this organization.\"],\n            response,\n        )\n\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save(update_fields=[\"invite_required\"])\n        response = self.client_get(\"/login/\")\n        self.assert_in_success_response(\n            [\"Don't have an account yet? You need to be invited to join this organization.\"],\n            response,\n        )\n\n    @patch(\"django.http.HttpRequest.get_host\", return_value=\"auth.testserver\")\n    def test_social_auth_subdomain_login_page(self, mock_get_host: MagicMock) -> None:\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Authentication subdomain\", result)\n\n        zulip_realm = get_realm(\"zulip\")\n        session = self.client.session\n        session[\"subdomain\"] = \"zulip\"\n        session.save()\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, zulip_realm.uri)\n\n        session = self.client.session\n        session[\"subdomain\"] = \"invalid\"\n        session.save()\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Authentication subdomain\", result)\n\n    def test_login_page_is_deactivated_validation(self) -> None:\n        with patch(\"zerver.views.auth.logging.info\") as mock_info:\n            result = self.client_get(\"/login/?is_deactivated=invalid_email\")\n            mock_info.assert_called_once()\n            self.assert_not_in_success_response([\"invalid_email\"], result)\n\n\nclass TestFindMyTeam(ZulipTestCase):\n    def test_template(self) -> None:\n        result = self.client_get(\"/accounts/find/\")\n        self.assertIn(\"Find your Zulip accounts\", result.content.decode())\n\n    def test_result(self) -> None:\n        # We capitalize a letter in cordelia's email to test that the search is case-insensitive.\n        result = self.client_post(\n            \"/accounts/find/\", dict(emails=\"iago@zulip.com,cordeliA@zulip.com\")\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\n            result.url, \"/accounts/find/?emails=iago%40zulip.com%2CcordeliA%40zulip.com\"\n        )\n        result = self.client_get(result.url)\n        content = result.content.decode()\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(\"iago@zulip.com\", content)\n        self.assertIn(\"cordeliA@zulip.com\", content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 2)\n        iago_message = outbox[1]\n        cordelia_message = outbox[0]\n        self.assertIn(\"Zulip Dev\", iago_message.body)\n        self.assertNotIn(\"Lear & Co\", iago_message.body)\n        self.assertIn(\"Zulip Dev\", cordelia_message.body)\n        self.assertIn(\"Lear & Co\", cordelia_message.body)\n\n    def test_find_team_ignore_invalid_email(self) -> None:\n        result = self.client_post(\n            \"/accounts/find/\", dict(emails=\"iago@zulip.com,invalid_email@zulip.com\")\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\n            result.url, \"/accounts/find/?emails=iago%40zulip.com%2Cinvalid_email%40zulip.com\"\n        )\n        result = self.client_get(result.url)\n        content = result.content.decode()\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertIn(\"invalid_email@\", content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 1)\n\n    def test_find_team_reject_invalid_email(self) -> None:\n        result = self.client_post(\"/accounts/find/\", dict(emails=\"invalid_string\"))\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(b\"Enter a valid email\", result.content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n        # Just for coverage on perhaps-unnecessary validation code.\n        result = self.client_get(\"/accounts/find/\", {\"emails\": \"invalid\"})\n        self.assertEqual(result.status_code, 200)\n\n    def test_find_team_zero_emails(self) -> None:\n        data = {\"emails\": \"\"}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertIn(\"This field is required\", result.content.decode())\n        self.assertEqual(result.status_code, 200)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_one_email(self) -> None:\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 1)\n\n    def test_find_team_deactivated_user(self) -> None:\n        do_deactivate_user(self.example_user(\"hamlet\"), acting_user=None)\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_deactivated_realm(self) -> None:\n        do_deactivate_realm(get_realm(\"zulip\"), acting_user=None)\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_bot_email(self) -> None:\n        data = {\"emails\": self.example_email(\"webhook_bot\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=webhook-bot%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_more_than_ten_emails(self) -> None:\n        data = {\"emails\": \",\".join(f\"hamlet-{i}@zulip.com\" for i in range(11))}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(\"Please enter at most 10\", result.content.decode())\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n\nclass ConfirmationKeyTest(ZulipTestCase):\n    def test_confirmation_key(self) -> None:\n        request = MagicMock()\n        request.session = {\n            \"confirmation_key\": {\"confirmation_key\": \"xyzzy\"},\n        }\n        result = confirmation_key(request)\n        self.assert_json_success(result)\n        self.assert_in_response(\"xyzzy\", result)\n\n\nclass MobileAuthOTPTest(ZulipTestCase):\n    def test_xor_hex_strings(self) -> None:\n        self.assertEqual(xor_hex_strings(\"1237c81ab\", \"18989fd12\"), \"0aaf57cb9\")\n        with self.assertRaises(AssertionError):\n            xor_hex_strings(\"1\", \"31\")\n\n    def test_is_valid_otp(self) -> None:\n        self.assertEqual(is_valid_otp(\"1234\"), False)\n        self.assertEqual(is_valid_otp(\"1234abcd\" * 8), True)\n        self.assertEqual(is_valid_otp(\"1234abcZ\" * 8), False)\n\n    def test_ascii_to_hex(self) -> None:\n        self.assertEqual(ascii_to_hex(\"ZcdR1234\"), \"5a63645231323334\")\n        self.assertEqual(hex_to_ascii(\"5a63645231323334\"), \"ZcdR1234\")\n\n    def test_otp_encrypt_api_key(self) -> None:\n        api_key = \"12ac\" * 8\n        otp = \"7be38894\" * 8\n        result = otp_encrypt_api_key(api_key, otp)\n        self.assertEqual(result, \"4ad1e9f7\" * 8)\n\n        decryped = otp_decrypt_api_key(result, otp)\n        self.assertEqual(decryped, api_key)\n\n\nclass FollowupEmailTest(ZulipTestCase):\n    def test_followup_day2_email(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        # Test date_joined == Sunday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 7, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=2, hours=-1)\n        )\n        # Test date_joined == Tuesday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 2, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=2, hours=-1)\n        )\n        # Test date_joined == Thursday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 4, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=1, hours=-1)\n        )\n        # Test date_joined == Friday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 5, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=3, hours=-1)\n        )\n\n        # Time offset of America/Phoenix is -07:00\n        user_profile.timezone = \"America/Phoenix\"\n        # Test date_joined == Friday in UTC, but Thursday in the user's timezone\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 5, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=1, hours=-1)\n        )\n\n\nclass NoReplyEmailTest(ZulipTestCase):\n    def test_noreply_email_address(self) -> None:\n        self.assertTrue(\n            re.search(self.TOKENIZED_NOREPLY_REGEX, FromAddress.tokenized_no_reply_address())\n        )\n\n        with self.settings(ADD_TOKENS_TO_NOREPLY_ADDRESS=False):\n            self.assertEqual(FromAddress.tokenized_no_reply_address(), \"noreply@testserver\")\n\n\nclass TwoFactorAuthTest(ZulipTestCase):\n    @patch(\"two_factor.models.totp\")\n    def test_two_factor_login(self, mock_totp: MagicMock) -> None:\n        token = 123456\n        email = self.example_email(\"hamlet\")\n        password = self.ldap_password(\"hamlet\")\n\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.set_password(password)\n        user_profile.save()\n        self.create_default_device(user_profile)\n\n        def totp(*args: Any, **kwargs: Any) -> int:\n            return token\n\n        mock_totp.side_effect = totp\n\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.EmailAuthBackend\",),\n            TWO_FACTOR_CALL_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_SMS_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_AUTHENTICATION_ENABLED=True,\n        ):\n\n            first_step_data = {\n                \"username\": email,\n                \"password\": password,\n                \"two_factor_login_view-current_step\": \"auth\",\n            }\n            with self.assertLogs(\"two_factor.gateways.fake\", \"INFO\") as info_logs:\n                result = self.client_post(\"/accounts/login/\", first_step_data)\n            self.assertEqual(\n                info_logs.output,\n                ['INFO:two_factor.gateways.fake:Fake SMS to +12125550100: \"Your token is: 123456\"'],\n            )\n            self.assertEqual(result.status_code, 200)\n\n            second_step_data = {\n                \"token-otp_token\": str(token),\n                \"two_factor_login_view-current_step\": \"token\",\n            }\n            result = self.client_post(\"/accounts/login/\", second_step_data)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n            # Going to login page should redirect to '/' if user is already\n            # logged in.\n            result = self.client_get(\"/accounts/login/\")\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n\nclass NameRestrictionsTest(ZulipTestCase):\n    def test_whitelisted_disposable_domains(self) -> None:\n        self.assertFalse(is_disposable_domain(\"OPayQ.com\"))\n\n\nclass RealmRedirectTest(ZulipTestCase):\n    def test_realm_redirect_without_next_param(self) -> None:\n        result = self.client_get(\"/accounts/go/\")\n        self.assert_in_success_response([\"Enter your organization's Zulip URL\"], result)\n\n        result = self.client_post(\"/accounts/go/\", {\"subdomain\": \"zephyr\"})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zephyr.testserver\")\n\n        result = self.client_post(\"/accounts/go/\", {\"subdomain\": \"invalid\"})\n        self.assert_in_success_response([\"We couldn&#39;t find that Zulip organization.\"], result)\n\n    def test_realm_redirect_with_next_param(self) -> None:\n        result = self.client_get(\"/accounts/go/\", {\"next\": \"billing\"})\n        self.assert_in_success_response(\n            [\"Enter your organization's Zulip URL\", 'action=\"/accounts/go/?next=billing\"'], result\n        )\n\n        result = self.client_post(\"/accounts/go/?next=billing\", {\"subdomain\": \"lear\"})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://lear.testserver/billing\")\n", "import logging\nimport urllib\nfrom typing import Any, Dict, List, Optional\nfrom urllib.parse import urlencode\n\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate, get_backends\nfrom django.core import validators\nfrom django.core.exceptions import ValidationError\nfrom django.db.models import Q\nfrom django.http import HttpRequest, HttpResponse, HttpResponseRedirect\nfrom django.shortcuts import redirect, render\nfrom django.urls import reverse\nfrom django.utils.translation import gettext as _\nfrom django_auth_ldap.backend import LDAPBackend, _LDAPUser\n\nfrom confirmation import settings as confirmation_settings\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyException,\n    RealmCreationKey,\n    create_confirmation_link,\n    get_object_from_key,\n    render_confirmation_key_error,\n    validate_key,\n)\nfrom zerver.context_processors import get_realm_from_request, login_context\nfrom zerver.decorator import do_login, rate_limit_request_by_ip, require_post\nfrom zerver.forms import (\n    FindMyTeamForm,\n    HomepageForm,\n    RealmCreationForm,\n    RealmRedirectForm,\n    RegistrationForm,\n)\nfrom zerver.lib.actions import (\n    bulk_add_subscriptions,\n    do_activate_mirror_dummy_user,\n    do_change_full_name,\n    do_change_password,\n    do_change_user_setting,\n    do_create_realm,\n    do_create_user,\n    lookup_default_stream_groups,\n)\nfrom zerver.lib.email_validation import email_allowed_for_realm, validate_email_not_already_in_realm\nfrom zerver.lib.exceptions import RateLimited\nfrom zerver.lib.onboarding import send_initial_realm_messages, setup_realm_internal_bots\nfrom zerver.lib.pysa import mark_sanitized\nfrom zerver.lib.request import REQ, has_request_variables\nfrom zerver.lib.send_email import EmailNotDeliveredException, FromAddress, send_email\nfrom zerver.lib.sessions import get_expirable_session_var\nfrom zerver.lib.subdomains import get_subdomain, is_root_domain_available\nfrom zerver.lib.url_encoding import append_url_query_string\nfrom zerver.lib.users import get_accounts_for_email\nfrom zerver.lib.validator import to_converted_or_fallback, to_non_negative_int, to_timezone_or_empty\nfrom zerver.lib.zephyr import compute_mit_user_fullname\nfrom zerver.models import (\n    DisposableEmailError,\n    DomainNotAllowedForRealmError,\n    EmailContainsPlusError,\n    MultiuseInvite,\n    Realm,\n    Stream,\n    UserProfile,\n    get_default_stream_groups,\n    get_realm,\n    get_source_profile,\n    get_user_by_delivery_email,\n    name_changes_disabled,\n)\nfrom zerver.views.auth import (\n    create_preregistration_user,\n    finish_desktop_flow,\n    finish_mobile_flow,\n    get_safe_redirect_to,\n    redirect_and_log_into_subdomain,\n    redirect_to_deactivation_notice,\n)\nfrom zproject.backends import (\n    ExternalAuthResult,\n    ZulipLDAPAuthBackend,\n    ZulipLDAPExceptionNoMatchingLDAPUser,\n    email_auth_enabled,\n    email_belongs_to_ldap,\n    get_external_method_dicts,\n    ldap_auth_enabled,\n    password_auth_enabled,\n)\n\nif settings.BILLING_ENABLED:\n    from corporate.lib.registration import check_spare_licenses_available_for_registering_new_user\n    from corporate.lib.stripe import LicenseLimitError\n\n\n@has_request_variables\ndef check_prereg_key_and_redirect(\n    request: HttpRequest, confirmation_key: str, full_name: Optional[str] = REQ(default=None)\n) -> HttpResponse:\n    confirmation = Confirmation.objects.filter(confirmation_key=confirmation_key).first()\n    if confirmation is None or confirmation.type not in [\n        Confirmation.USER_REGISTRATION,\n        Confirmation.INVITATION,\n        Confirmation.REALM_CREATION,\n    ]:\n        return render_confirmation_key_error(\n            request, ConfirmationKeyException(ConfirmationKeyException.DOES_NOT_EXIST)\n        )\n\n    prereg_user = confirmation.content_object\n    assert prereg_user is not None\n    if prereg_user.status == confirmation_settings.STATUS_REVOKED:\n        return render(request, \"zerver/confirmation_link_expired_error.html\", status=404)\n\n    try:\n        get_object_from_key(confirmation_key, confirmation.type, activate_object=False)\n    except ConfirmationKeyException as exception:\n        return render_confirmation_key_error(request, exception)\n\n    # confirm_preregistrationuser.html just extracts the confirmation_key\n    # (and GET parameters) and redirects to /accounts/register, so that the\n    # user can enter their information on a cleaner URL.\n    return render(\n        request,\n        \"confirmation/confirm_preregistrationuser.html\",\n        context={\"key\": confirmation_key, \"full_name\": full_name},\n    )\n\n\n@require_post\n@has_request_variables\ndef accounts_register(\n    request: HttpRequest,\n    key: str = REQ(default=\"\"),\n    timezone: str = REQ(default=\"\", converter=to_timezone_or_empty),\n    from_confirmation: Optional[str] = REQ(default=None),\n    form_full_name: Optional[str] = REQ(\"full_name\", default=None),\n    source_realm_id: Optional[int] = REQ(\n        default=None, converter=to_converted_or_fallback(to_non_negative_int, None)\n    ),\n) -> HttpResponse:\n    try:\n        confirmation = Confirmation.objects.get(confirmation_key=key)\n    except Confirmation.DoesNotExist:\n        return render(request, \"zerver/confirmation_link_expired_error.html\", status=404)\n\n    prereg_user = confirmation.content_object\n    assert prereg_user is not None\n    if prereg_user.status == confirmation_settings.STATUS_REVOKED:\n        return render(request, \"zerver/confirmation_link_expired_error.html\", status=404)\n    email = prereg_user.email\n    realm_creation = prereg_user.realm_creation\n    password_required = prereg_user.password_required\n\n    role = prereg_user.invited_as\n    if realm_creation:\n        role = UserProfile.ROLE_REALM_OWNER\n\n    try:\n        validators.validate_email(email)\n    except ValidationError:\n        return render(request, \"zerver/invalid_email.html\", context={\"invalid_email\": True})\n\n    if realm_creation:\n        # For creating a new realm, there is no existing realm or domain\n        realm = None\n    else:\n        if get_subdomain(request) != prereg_user.realm.string_id:\n            return render_confirmation_key_error(\n                request, ConfirmationKeyException(ConfirmationKeyException.DOES_NOT_EXIST)\n            )\n        realm = prereg_user.realm\n        try:\n            email_allowed_for_realm(email, realm)\n        except DomainNotAllowedForRealmError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"closed_domain\": True},\n            )\n        except DisposableEmailError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"disposable_emails_not_allowed\": True},\n            )\n        except EmailContainsPlusError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"email_contains_plus\": True},\n            )\n\n        if realm.deactivated:\n            # The user is trying to register for a deactivated realm. Advise them to\n            # contact support.\n            return redirect_to_deactivation_notice()\n\n        try:\n            validate_email_not_already_in_realm(realm, email)\n        except ValidationError:\n            return redirect_to_email_login_url(email)\n\n        if settings.BILLING_ENABLED:\n            try:\n                check_spare_licenses_available_for_registering_new_user(realm, email)\n            except LicenseLimitError:\n                return render(request, \"zerver/no_spare_licenses.html\")\n\n    name_validated = False\n    require_ldap_password = False\n\n    if from_confirmation:\n        try:\n            del request.session[\"authenticated_full_name\"]\n        except KeyError:\n            pass\n\n        ldap_full_name = None\n        if settings.POPULATE_PROFILE_VIA_LDAP:\n            # If the user can be found in LDAP, we'll take the full name from the directory,\n            # and further down create a form pre-filled with it.\n            for backend in get_backends():\n                if isinstance(backend, LDAPBackend):\n                    try:\n                        ldap_username = backend.django_to_ldap_username(email)\n                    except ZulipLDAPExceptionNoMatchingLDAPUser:\n                        logging.warning(\"New account email %s could not be found in LDAP\", email)\n                        break\n\n                    # Note that this `ldap_user` object is not a\n                    # `ZulipLDAPUser` with a `Realm` attached, so\n                    # calling `.populate_user()` on it will crash.\n                    # This is OK, since we're just accessing this user\n                    # to extract its name.\n                    #\n                    # TODO: We should potentially be accessing this\n                    # user to sync its initial avatar and custom\n                    # profile fields as well, if we indeed end up\n                    # creating a user account through this flow,\n                    # rather than waiting until `manage.py\n                    # sync_ldap_user_data` runs to populate it.\n                    ldap_user = _LDAPUser(backend, ldap_username)\n\n                    try:\n                        ldap_full_name = backend.get_mapped_name(ldap_user)\n                    except TypeError:\n                        break\n\n                    # Check whether this is ZulipLDAPAuthBackend,\n                    # which is responsible for authentication and\n                    # requires that LDAP accounts enter their LDAP\n                    # password to register, or ZulipLDAPUserPopulator,\n                    # which just populates UserProfile fields (no auth).\n                    require_ldap_password = isinstance(backend, ZulipLDAPAuthBackend)\n                    break\n\n        if ldap_full_name:\n            # We don't use initial= here, because if the form is\n            # complete (that is, no additional fields need to be\n            # filled out by the user) we want the form to validate,\n            # so they can be directly registered without having to\n            # go through this interstitial.\n            form = RegistrationForm({\"full_name\": ldap_full_name}, realm_creation=realm_creation)\n            request.session[\"authenticated_full_name\"] = ldap_full_name\n            name_validated = True\n        elif realm is not None and realm.is_zephyr_mirror_realm:\n            # For MIT users, we can get an authoritative name from Hesiod.\n            # Technically we should check that this is actually an MIT\n            # realm, but we can cross that bridge if we ever get a non-MIT\n            # zephyr mirroring realm.\n            hesiod_name = compute_mit_user_fullname(email)\n            form = RegistrationForm(\n                initial={\"full_name\": hesiod_name if \"@\" not in hesiod_name else \"\"},\n                realm_creation=realm_creation,\n            )\n            name_validated = True\n        elif prereg_user.full_name:\n            if prereg_user.full_name_validated:\n                request.session[\"authenticated_full_name\"] = prereg_user.full_name\n                name_validated = True\n                form = RegistrationForm(\n                    {\"full_name\": prereg_user.full_name}, realm_creation=realm_creation\n                )\n            else:\n                form = RegistrationForm(\n                    initial={\"full_name\": prereg_user.full_name}, realm_creation=realm_creation\n                )\n        elif form_full_name is not None:\n            form = RegistrationForm(\n                initial={\"full_name\": form_full_name},\n                realm_creation=realm_creation,\n            )\n        else:\n            form = RegistrationForm(realm_creation=realm_creation)\n    else:\n        postdata = request.POST.copy()\n        if name_changes_disabled(realm):\n            # If we populate profile information via LDAP and we have a\n            # verified name from you on file, use that. Otherwise, fall\n            # back to the full name in the request.\n            try:\n                postdata.update(full_name=request.session[\"authenticated_full_name\"])\n                name_validated = True\n            except KeyError:\n                pass\n        form = RegistrationForm(postdata, realm_creation=realm_creation)\n\n    if not (password_auth_enabled(realm) and password_required):\n        form[\"password\"].field.required = False\n\n    if form.is_valid():\n        if password_auth_enabled(realm) and form[\"password\"].field.required:\n            password = form.cleaned_data[\"password\"]\n        else:\n            # If the user wasn't prompted for a password when\n            # completing the authentication form (because they're\n            # signing up with SSO and no password is required), set\n            # the password field to `None` (Which causes Django to\n            # create an unusable password).\n            password = None\n\n        if realm_creation:\n            string_id = form.cleaned_data[\"realm_subdomain\"]\n            realm_name = form.cleaned_data[\"realm_name\"]\n            realm_type = form.cleaned_data[\"realm_type\"]\n            is_demo_org = form.cleaned_data[\"is_demo_organization\"]\n            realm = do_create_realm(\n                string_id, realm_name, org_type=realm_type, is_demo_organization=is_demo_org\n            )\n            setup_realm_internal_bots(realm)\n        assert realm is not None\n\n        full_name = form.cleaned_data[\"full_name\"]\n        enable_marketing_emails = form.cleaned_data[\"enable_marketing_emails\"]\n        default_stream_group_names = request.POST.getlist(\"default_stream_group\")\n        default_stream_groups = lookup_default_stream_groups(default_stream_group_names, realm)\n\n        if source_realm_id is not None:\n            # Non-integer realm_id values like \"string\" are treated\n            # like the \"Do not import\" value of \"\".\n            source_profile: Optional[UserProfile] = get_source_profile(email, source_realm_id)\n        else:\n            source_profile = None\n\n        if not realm_creation:\n            try:\n                existing_user_profile: Optional[UserProfile] = get_user_by_delivery_email(\n                    email, realm\n                )\n            except UserProfile.DoesNotExist:\n                existing_user_profile = None\n        else:\n            existing_user_profile = None\n\n        user_profile: Optional[UserProfile] = None\n        return_data: Dict[str, bool] = {}\n        if ldap_auth_enabled(realm):\n            # If the user was authenticated using an external SSO\n            # mechanism like Google or GitHub auth, then authentication\n            # will have already been done before creating the\n            # PreregistrationUser object with password_required=False, and\n            # so we don't need to worry about passwords.\n            #\n            # If instead the realm is using EmailAuthBackend, we will\n            # set their password above.\n            #\n            # But if the realm is using LDAPAuthBackend, we need to verify\n            # their LDAP password (which will, as a side effect, create\n            # the user account) here using authenticate.\n            # pregeg_user.realm_creation carries the information about whether\n            # we're in realm creation mode, and the ldap flow will handle\n            # that and create the user with the appropriate parameters.\n            user_profile = authenticate(\n                request=request,\n                username=email,\n                password=password,\n                realm=realm,\n                prereg_user=prereg_user,\n                return_data=return_data,\n            )\n            if user_profile is None:\n                can_use_different_backend = email_auth_enabled(realm) or (\n                    len(get_external_method_dicts(realm)) > 0\n                )\n                if settings.LDAP_APPEND_DOMAIN:\n                    # In LDAP_APPEND_DOMAIN configurations, we don't allow making a non-LDAP account\n                    # if the email matches the ldap domain.\n                    can_use_different_backend = can_use_different_backend and (\n                        not email_belongs_to_ldap(realm, email)\n                    )\n                if return_data.get(\"no_matching_ldap_user\") and can_use_different_backend:\n                    # If both the LDAP and Email or Social auth backends are\n                    # enabled, and there's no matching user in the LDAP\n                    # directory then the intent is to create a user in the\n                    # realm with their email outside the LDAP organization\n                    # (with e.g. a password stored in the Zulip database,\n                    # not LDAP).  So we fall through and create the new\n                    # account.\n                    pass\n                else:\n                    # TODO: This probably isn't going to give a\n                    # user-friendly error message, but it doesn't\n                    # particularly matter, because the registration form\n                    # is hidden for most users.\n                    view_url = reverse(\"login\")\n                    query = urlencode({\"email\": email})\n                    redirect_url = append_url_query_string(view_url, query)\n                    return HttpResponseRedirect(redirect_url)\n            elif not realm_creation:\n                # Since we'll have created a user, we now just log them in.\n                return login_and_go_to_home(request, user_profile)\n            else:\n                # With realm_creation=True, we're going to return further down,\n                # after finishing up the creation process.\n                pass\n\n        if existing_user_profile is not None and existing_user_profile.is_mirror_dummy:\n            user_profile = existing_user_profile\n            do_activate_mirror_dummy_user(user_profile, acting_user=user_profile)\n            do_change_password(user_profile, password)\n            do_change_full_name(user_profile, full_name, user_profile)\n            do_change_user_setting(user_profile, \"timezone\", timezone, acting_user=user_profile)\n            # TODO: When we clean up the `do_activate_mirror_dummy_user` code path,\n            # make it respect invited_as_admin / is_realm_admin.\n\n        if user_profile is None:\n            user_profile = do_create_user(\n                email,\n                password,\n                realm,\n                full_name,\n                prereg_user=prereg_user,\n                role=role,\n                tos_version=settings.TOS_VERSION,\n                timezone=timezone,\n                default_stream_groups=default_stream_groups,\n                source_profile=source_profile,\n                realm_creation=realm_creation,\n                acting_user=None,\n                enable_marketing_emails=enable_marketing_emails,\n            )\n\n        if realm_creation:\n            bulk_add_subscriptions(\n                realm, [realm.signup_notifications_stream], [user_profile], acting_user=None\n            )\n            send_initial_realm_messages(realm)\n\n            # Because for realm creation, registration happens on the\n            # root domain, we need to log them into the subdomain for\n            # their new realm.\n            return redirect_and_log_into_subdomain(\n                ExternalAuthResult(user_profile=user_profile, data_dict={\"is_realm_creation\": True})\n            )\n\n        # This dummy_backend check below confirms the user is\n        # authenticating to the correct subdomain.\n        auth_result = authenticate(\n            username=user_profile.delivery_email,\n            realm=realm,\n            return_data=return_data,\n            use_dummy_backend=True,\n        )\n        if return_data.get(\"invalid_subdomain\"):\n            # By construction, this should never happen.\n            logging.error(\n                \"Subdomain mismatch in registration %s: %s\",\n                realm.subdomain,\n                user_profile.delivery_email,\n            )\n            return redirect(\"/\")\n\n        return login_and_go_to_home(request, auth_result)\n\n    return render(\n        request,\n        \"zerver/register.html\",\n        context={\n            \"form\": form,\n            \"email\": email,\n            \"key\": key,\n            \"full_name\": request.session.get(\"authenticated_full_name\", None),\n            \"lock_name\": name_validated and name_changes_disabled(realm),\n            # password_auth_enabled is normally set via our context processor,\n            # but for the registration form, there is no logged in user yet, so\n            # we have to set it here.\n            \"creating_new_team\": realm_creation,\n            \"password_required\": password_auth_enabled(realm) and password_required,\n            \"require_ldap_password\": require_ldap_password,\n            \"password_auth_enabled\": password_auth_enabled(realm),\n            \"root_domain_available\": is_root_domain_available(),\n            \"default_stream_groups\": [] if realm is None else get_default_stream_groups(realm),\n            \"accounts\": get_accounts_for_email(email),\n            \"MAX_REALM_NAME_LENGTH\": str(Realm.MAX_REALM_NAME_LENGTH),\n            \"MAX_NAME_LENGTH\": str(UserProfile.MAX_NAME_LENGTH),\n            \"MAX_PASSWORD_LENGTH\": str(form.MAX_PASSWORD_LENGTH),\n            \"MAX_REALM_SUBDOMAIN_LENGTH\": str(Realm.MAX_REALM_SUBDOMAIN_LENGTH),\n            \"sorted_realm_types\": sorted(\n                Realm.ORG_TYPES.values(), key=lambda d: d[\"display_order\"]\n            ),\n        },\n    )\n\n\ndef login_and_go_to_home(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    mobile_flow_otp = get_expirable_session_var(\n        request.session, \"registration_mobile_flow_otp\", delete=True\n    )\n    desktop_flow_otp = get_expirable_session_var(\n        request.session, \"registration_desktop_flow_otp\", delete=True\n    )\n    if mobile_flow_otp is not None:\n        return finish_mobile_flow(request, user_profile, mobile_flow_otp)\n    elif desktop_flow_otp is not None:\n        return finish_desktop_flow(request, user_profile, desktop_flow_otp)\n\n    do_login(request, user_profile)\n    # Using 'mark_sanitized' to work around false positive where Pysa thinks\n    # that 'user_profile' is user-controlled\n    return HttpResponseRedirect(mark_sanitized(user_profile.realm.uri) + reverse(\"home\"))\n\n\ndef prepare_activation_url(\n    email: str,\n    request: HttpRequest,\n    realm_creation: bool = False,\n    streams: Optional[List[Stream]] = None,\n    invited_as: Optional[int] = None,\n) -> str:\n    \"\"\"\n    Send an email with a confirmation link to the provided e-mail so the user\n    can complete their registration.\n    \"\"\"\n    prereg_user = create_preregistration_user(email, request, realm_creation)\n\n    if streams is not None:\n        prereg_user.streams.set(streams)\n\n    if invited_as is not None:\n        prereg_user.invited_as = invited_as\n        prereg_user.save()\n\n    confirmation_type = Confirmation.USER_REGISTRATION\n    if realm_creation:\n        confirmation_type = Confirmation.REALM_CREATION\n\n    activation_url = create_confirmation_link(prereg_user, confirmation_type)\n    if settings.DEVELOPMENT and realm_creation:\n        request.session[\"confirmation_key\"] = {\"confirmation_key\": activation_url.split(\"/\")[-1]}\n    return activation_url\n\n\ndef send_confirm_registration_email(\n    email: str,\n    activation_url: str,\n    *,\n    realm: Optional[Realm] = None,\n    request: Optional[HttpRequest] = None,\n) -> None:\n    send_email(\n        \"zerver/emails/confirm_registration\",\n        to_emails=[email],\n        from_address=FromAddress.tokenized_no_reply_address(),\n        language=request.LANGUAGE_CODE if request is not None else None,\n        context={\n            \"create_realm\": (realm is None),\n            \"activate_url\": activation_url,\n        },\n        realm=realm,\n        request=request,\n    )\n\n\ndef redirect_to_email_login_url(email: str) -> HttpResponseRedirect:\n    login_url = reverse(\"login\")\n    redirect_url = append_url_query_string(\n        login_url, urlencode({\"email\": email, \"already_registered\": 1})\n    )\n    return HttpResponseRedirect(redirect_url)\n\n\ndef create_realm(request: HttpRequest, creation_key: Optional[str] = None) -> HttpResponse:\n    try:\n        key_record = validate_key(creation_key)\n    except RealmCreationKey.Invalid:\n        return render(\n            request,\n            \"zerver/realm_creation_failed.html\",\n            context={\n                \"message\": _(\"The organization creation link has expired\" \" or is not valid.\")\n            },\n        )\n    if not settings.OPEN_REALM_CREATION:\n        if key_record is None:\n            return render(\n                request,\n                \"zerver/realm_creation_failed.html\",\n                context={\"message\": _(\"New organization creation disabled\")},\n            )\n\n    # When settings.OPEN_REALM_CREATION is enabled, anyone can create a new realm,\n    # with a few restrictions on their email address.\n    if request.method == \"POST\":\n        form = RealmCreationForm(request.POST)\n        if form.is_valid():\n            try:\n                rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n            except RateLimited as e:\n                assert e.secs_to_freedom is not None\n                return render(\n                    request,\n                    \"zerver/rate_limit_exceeded.html\",\n                    context={\"retry_after\": int(e.secs_to_freedom)},\n                    status=429,\n                )\n\n            email = form.cleaned_data[\"email\"]\n            activation_url = prepare_activation_url(email, request, realm_creation=True)\n            if key_record is not None and key_record.presume_email_valid:\n                # The user has a token created from the server command line;\n                # skip confirming the email is theirs, taking their word for it.\n                # This is essential on first install if the admin hasn't stopped\n                # to configure outbound email up front, or it isn't working yet.\n                key_record.delete()\n                return HttpResponseRedirect(activation_url)\n\n            try:\n                send_confirm_registration_email(email, activation_url, request=request)\n            except EmailNotDeliveredException:\n                logging.error(\"Error in create_realm\")\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            if key_record is not None:\n                key_record.delete()\n            return HttpResponseRedirect(reverse(\"new_realm_send_confirm\", kwargs={\"email\": email}))\n    else:\n        form = RealmCreationForm()\n    return render(\n        request,\n        \"zerver/create_realm.html\",\n        context={\"form\": form, \"current_url\": request.get_full_path},\n    )\n\n\ndef accounts_home(\n    request: HttpRequest,\n    multiuse_object_key: str = \"\",\n    multiuse_object: Optional[MultiuseInvite] = None,\n) -> HttpResponse:\n    try:\n        realm = get_realm(get_subdomain(request))\n    except Realm.DoesNotExist:\n        return HttpResponseRedirect(reverse(find_account))\n    if realm.deactivated:\n        return redirect_to_deactivation_notice()\n\n    from_multiuse_invite = False\n    streams_to_subscribe = None\n    invited_as = None\n\n    if multiuse_object:\n        realm = multiuse_object.realm\n        streams_to_subscribe = multiuse_object.streams.all()\n        from_multiuse_invite = True\n        invited_as = multiuse_object.invited_as\n\n    if request.method == \"POST\":\n        form = HomepageForm(request.POST, realm=realm, from_multiuse_invite=from_multiuse_invite)\n        if form.is_valid():\n            try:\n                rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n            except RateLimited as e:\n                assert e.secs_to_freedom is not None\n                return render(\n                    request,\n                    \"zerver/rate_limit_exceeded.html\",\n                    context={\"retry_after\": int(e.secs_to_freedom)},\n                    status=429,\n                )\n\n            email = form.cleaned_data[\"email\"]\n\n            try:\n                validate_email_not_already_in_realm(realm, email)\n            except ValidationError:\n                return redirect_to_email_login_url(email)\n\n            activation_url = prepare_activation_url(\n                email, request, streams=streams_to_subscribe, invited_as=invited_as\n            )\n            try:\n                send_confirm_registration_email(email, activation_url, request=request, realm=realm)\n            except EmailNotDeliveredException:\n                logging.error(\"Error in accounts_home\")\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            return HttpResponseRedirect(reverse(\"signup_send_confirm\", kwargs={\"email\": email}))\n\n    else:\n        form = HomepageForm(realm=realm)\n    context = login_context(request)\n    context.update(\n        form=form,\n        current_url=request.get_full_path,\n        multiuse_object_key=multiuse_object_key,\n        from_multiuse_invite=from_multiuse_invite,\n    )\n    return render(request, \"zerver/accounts_home.html\", context=context)\n\n\ndef accounts_home_from_multiuse_invite(request: HttpRequest, confirmation_key: str) -> HttpResponse:\n    multiuse_object = None\n    try:\n        multiuse_object = get_object_from_key(confirmation_key, Confirmation.MULTIUSE_INVITE)\n        # Required for OAuth 2\n    except ConfirmationKeyException as exception:\n        realm = get_realm_from_request(request)\n        if realm is None or realm.invite_required:\n            return render_confirmation_key_error(request, exception)\n    return accounts_home(\n        request, multiuse_object_key=confirmation_key, multiuse_object=multiuse_object\n    )\n\n\n@has_request_variables\ndef find_account(\n    request: HttpRequest, raw_emails: Optional[str] = REQ(\"emails\", default=None)\n) -> HttpResponse:\n    url = reverse(\"find_account\")\n\n    emails: List[str] = []\n    if request.method == \"POST\":\n        form = FindMyTeamForm(request.POST)\n        if form.is_valid():\n            emails = form.cleaned_data[\"emails\"]\n            for i in range(len(emails)):\n                try:\n                    rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n                except RateLimited as e:\n                    assert e.secs_to_freedom is not None\n                    return render(\n                        request,\n                        \"zerver/rate_limit_exceeded.html\",\n                        context={\"retry_after\": int(e.secs_to_freedom)},\n                        status=429,\n                    )\n\n            # Django doesn't support __iexact__in lookup with EmailField, so we have\n            # to use Qs to get around that without needing to do multiple queries.\n            emails_q = Q()\n            for email in emails:\n                emails_q |= Q(delivery_email__iexact=email)\n\n            user_profiles = UserProfile.objects.filter(\n                emails_q, is_active=True, is_bot=False, realm__deactivated=False\n            )\n\n            # We organize the data in preparation for sending exactly\n            # one outgoing email per provided email address, with each\n            # email listing all of the accounts that email address has\n            # with the current Zulip server.\n            context: Dict[str, Dict[str, Any]] = {}\n            for user in user_profiles:\n                key = user.delivery_email.lower()\n                context.setdefault(key, {})\n                context[key].setdefault(\"realms\", [])\n                context[key][\"realms\"].append(user.realm)\n                context[key][\"external_host\"] = settings.EXTERNAL_HOST\n                # This value will end up being the last user ID among\n                # matching accounts; since it's only used for minor\n                # details like language, that arbitrary choice is OK.\n                context[key][\"to_user_id\"] = user.id\n\n            for delivery_email, realm_context in context.items():\n                realm_context[\"email\"] = delivery_email\n                send_email(\n                    \"zerver/emails/find_team\",\n                    to_user_ids=[realm_context[\"to_user_id\"]],\n                    context=realm_context,\n                    from_address=FromAddress.SUPPORT,\n                    request=request,\n                )\n\n            # Note: Show all the emails in the result otherwise this\n            # feature can be used to ascertain which email addresses\n            # are associated with Zulip.\n            data = urllib.parse.urlencode({\"emails\": \",\".join(emails)})\n            return redirect(append_url_query_string(url, data))\n    else:\n        form = FindMyTeamForm()\n        # The below validation is perhaps unnecessary, in that we\n        # shouldn't get able to get here with an invalid email unless\n        # the user hand-edits the URLs.\n        if raw_emails:\n            for email in raw_emails.split(\",\"):\n                try:\n                    validators.validate_email(email)\n                    emails.append(email)\n                except ValidationError:\n                    pass\n\n    return render(\n        request,\n        \"zerver/find_account.html\",\n        context={\"form\": form, \"current_url\": lambda: url, \"emails\": emails},\n    )\n\n\n@has_request_variables\ndef realm_redirect(request: HttpRequest, next: str = REQ(default=\"\")) -> HttpResponse:\n    if request.method == \"POST\":\n        form = RealmRedirectForm(request.POST)\n        if form.is_valid():\n            subdomain = form.cleaned_data[\"subdomain\"]\n            realm = get_realm(subdomain)\n            redirect_to = get_safe_redirect_to(next, realm.uri)\n            return HttpResponseRedirect(redirect_to)\n    else:\n        form = RealmRedirectForm()\n\n    return render(request, \"zerver/realm_redirect.html\", context={\"form\": form})\n", "import os\nfrom typing import List, Union\n\nfrom django.conf import settings\nfrom django.conf.urls import include\nfrom django.conf.urls.i18n import i18n_patterns\nfrom django.contrib.auth.views import (\n    LoginView,\n    PasswordResetCompleteView,\n    PasswordResetConfirmView,\n    PasswordResetDoneView,\n)\nfrom django.urls import path, re_path\nfrom django.urls.resolvers import URLPattern, URLResolver\nfrom django.utils.module_loading import import_string\nfrom django.views.generic import RedirectView, TemplateView\n\nfrom zerver.forms import LoggingSetPasswordForm\nfrom zerver.lib.integrations import WEBHOOK_INTEGRATIONS\nfrom zerver.lib.rest import rest_path\nfrom zerver.tornado.views import cleanup_event_queue, get_events, get_events_internal, notify\nfrom zerver.views.alert_words import add_alert_words, list_alert_words, remove_alert_words\nfrom zerver.views.attachments import list_by_user, remove\nfrom zerver.views.auth import (\n    api_fetch_api_key,\n    api_get_server_settings,\n    json_fetch_api_key,\n    log_into_subdomain,\n    login_page,\n    logout_then_login,\n    password_reset,\n    remote_user_jwt,\n    remote_user_sso,\n    saml_sp_metadata,\n    show_deactivation_notice,\n    start_remote_user_sso,\n    start_social_login,\n    start_social_signup,\n)\nfrom zerver.views.compatibility import check_global_compatibility\nfrom zerver.views.custom_profile_fields import (\n    create_realm_custom_profile_field,\n    delete_realm_custom_profile_field,\n    list_realm_custom_profile_fields,\n    remove_user_custom_profile_data,\n    reorder_realm_custom_profile_fields,\n    update_realm_custom_profile_field,\n    update_user_custom_profile_data,\n)\nfrom zerver.views.digest import digest_page\nfrom zerver.views.documentation import IntegrationView, MarkdownDirectoryView, integration_doc\nfrom zerver.views.drafts import create_drafts, delete_draft, edit_draft, fetch_drafts\nfrom zerver.views.email_mirror import email_mirror_message\nfrom zerver.views.events_register import events_register_backend\nfrom zerver.views.home import accounts_accept_terms, desktop_home, home\nfrom zerver.views.hotspots import mark_hotspot_as_read\nfrom zerver.views.invite import (\n    generate_multiuse_invite_backend,\n    get_user_invites,\n    invite_users_backend,\n    resend_user_invite_email,\n    revoke_multiuse_invite,\n    revoke_user_invite,\n)\nfrom zerver.views.message_edit import (\n    delete_message_backend,\n    get_message_edit_history,\n    json_fetch_raw_message,\n    update_message_backend,\n)\nfrom zerver.views.message_fetch import get_messages_backend, messages_in_narrow_backend\nfrom zerver.views.message_flags import (\n    mark_all_as_read,\n    mark_stream_as_read,\n    mark_topic_as_read,\n    update_message_flags,\n)\nfrom zerver.views.message_send import render_message_backend, send_message_backend, zcommand_backend\nfrom zerver.views.muting import mute_user, unmute_user, update_muted_topic\nfrom zerver.views.portico import (\n    app_download_link_redirect,\n    apps_view,\n    hello_view,\n    landing_view,\n    plans_view,\n    privacy_view,\n    team_view,\n    terms_view,\n)\nfrom zerver.views.presence import (\n    get_presence_backend,\n    get_statuses_for_realm,\n    update_active_status_backend,\n    update_user_status_backend,\n)\nfrom zerver.views.push_notifications import (\n    add_android_reg_id,\n    add_apns_device_token,\n    remove_android_reg_id,\n    remove_apns_device_token,\n)\nfrom zerver.views.reactions import add_reaction, remove_reaction\nfrom zerver.views.realm import (\n    check_subdomain_available,\n    deactivate_realm,\n    realm_reactivation,\n    update_realm,\n    update_realm_user_settings_defaults,\n)\nfrom zerver.views.realm_domains import (\n    create_realm_domain,\n    delete_realm_domain,\n    list_realm_domains,\n    patch_realm_domain,\n)\nfrom zerver.views.realm_emoji import delete_emoji, list_emoji, upload_emoji\nfrom zerver.views.realm_export import delete_realm_export, export_realm, get_realm_exports\nfrom zerver.views.realm_icon import delete_icon_backend, get_icon_backend, upload_icon\nfrom zerver.views.realm_linkifiers import (\n    create_linkifier,\n    delete_linkifier,\n    list_linkifiers,\n    update_linkifier,\n)\nfrom zerver.views.realm_logo import delete_logo_backend, get_logo_backend, upload_logo\nfrom zerver.views.realm_playgrounds import add_realm_playground, delete_realm_playground\nfrom zerver.views.registration import (\n    accounts_home,\n    accounts_home_from_multiuse_invite,\n    accounts_register,\n    check_prereg_key_and_redirect,\n    create_realm,\n    find_account,\n    realm_redirect,\n)\nfrom zerver.views.report import (\n    report_csp_violations,\n    report_error,\n    report_narrow_times,\n    report_send_times,\n    report_unnarrow_times,\n)\nfrom zerver.views.storage import get_storage, remove_storage, update_storage\nfrom zerver.views.streams import (\n    add_default_stream,\n    add_subscriptions_backend,\n    create_default_stream_group,\n    deactivate_stream_backend,\n    delete_in_topic,\n    get_streams_backend,\n    get_subscribers_backend,\n    get_topics_backend,\n    json_get_stream_id,\n    list_subscriptions_backend,\n    remove_default_stream,\n    remove_default_stream_group,\n    remove_subscriptions_backend,\n    update_default_stream_group_info,\n    update_default_stream_group_streams,\n    update_stream_backend,\n    update_subscription_properties_backend,\n    update_subscriptions_backend,\n    update_subscriptions_property,\n)\nfrom zerver.views.submessage import process_submessage\nfrom zerver.views.thumbnail import backend_serve_thumbnail\nfrom zerver.views.tutorial import set_tutorial_status\nfrom zerver.views.typing import send_notification_backend\nfrom zerver.views.unsubscribe import email_unsubscribe\nfrom zerver.views.upload import (\n    serve_file_backend,\n    serve_file_url_backend,\n    serve_local_file_unauthed,\n    upload_file_backend,\n)\nfrom zerver.views.user_groups import (\n    add_user_group,\n    delete_user_group,\n    edit_user_group,\n    get_user_group,\n    update_user_group_backend,\n)\nfrom zerver.views.user_settings import (\n    confirm_email_change,\n    delete_avatar_backend,\n    json_change_settings,\n    regenerate_api_key,\n    set_avatar_backend,\n)\nfrom zerver.views.users import (\n    add_bot_backend,\n    avatar,\n    create_user_backend,\n    deactivate_bot_backend,\n    deactivate_user_backend,\n    deactivate_user_own_backend,\n    get_bots_backend,\n    get_members_backend,\n    get_profile_backend,\n    get_subscription_backend,\n    get_user_by_email,\n    patch_bot_backend,\n    reactivate_user_backend,\n    regenerate_bot_api_key,\n    update_user_backend,\n)\nfrom zerver.views.video_calls import (\n    complete_zoom_user,\n    deauthorize_zoom_user,\n    get_bigbluebutton_url,\n    join_bigbluebutton,\n    make_zoom_video_call,\n    register_zoom_user,\n)\nfrom zerver.views.zephyr import webathena_kerberos_login\nfrom zproject import dev_urls\nfrom zproject.legacy_urls import legacy_urls\n\nif settings.TWO_FACTOR_AUTHENTICATION_ENABLED:\n    from two_factor.gateways.twilio.urls import urlpatterns as tf_twilio_urls\n    from two_factor.urls import urlpatterns as tf_urls\n\n# NB: There are several other pieces of code which route requests by URL:\n#\n#   - legacy_urls.py contains API endpoint written before the redesign\n#     and should not be added to.\n#\n#   - runtornado.py has its own URL list for Tornado views.  See the\n#     invocation of web.Application in that file.\n#\n#   - The Nginx config knows which URLs to route to Django or Tornado.\n#\n#   - Likewise for the local dev server in tools/run-dev.py.\n\n# These endpoints constitute the currently designed API (V1), which uses:\n# * REST verbs\n# * Basic auth (username:password is email:apiKey)\n# * Take and return json-formatted data\n#\n# If you're adding a new endpoint to the code that requires authentication,\n# please add it here.\n# See rest_dispatch in zerver.lib.rest for an explanation of auth methods used\n#\n# All of these paths are accessed by either a /json or /api/v1 prefix;\n# e.g. `PATCH /json/realm` or `PATCH /api/v1/realm`.\nv1_api_and_json_patterns = [\n    # realm-level calls\n    rest_path(\"realm\", PATCH=update_realm),\n    rest_path(\"realm/user_settings_defaults\", PATCH=update_realm_user_settings_defaults),\n    path(\"realm/subdomain/<subdomain>\", check_subdomain_available),\n    # realm/domains -> zerver.views.realm_domains\n    rest_path(\"realm/domains\", GET=list_realm_domains, POST=create_realm_domain),\n    rest_path(\"realm/domains/<domain>\", PATCH=patch_realm_domain, DELETE=delete_realm_domain),\n    # realm/emoji -> zerver.views.realm_emoji\n    rest_path(\"realm/emoji\", GET=list_emoji),\n    rest_path(\n        \"realm/emoji/<emoji_name>\",\n        POST=upload_emoji,\n        DELETE=(delete_emoji, {\"intentionally_undocumented\"}),\n    ),\n    # this endpoint throws a status code 400 JsonableError when it should be a 404.\n    # realm/icon -> zerver.views.realm_icon\n    rest_path(\"realm/icon\", POST=upload_icon, DELETE=delete_icon_backend, GET=get_icon_backend),\n    # realm/logo -> zerver.views.realm_logo\n    rest_path(\"realm/logo\", POST=upload_logo, DELETE=delete_logo_backend, GET=get_logo_backend),\n    # realm/filters and realm/linkifiers -> zerver.views.realm_linkifiers\n    rest_path(\"realm/linkifiers\", GET=list_linkifiers),\n    rest_path(\"realm/filters\", POST=create_linkifier),\n    rest_path(\"realm/filters/<int:filter_id>\", DELETE=delete_linkifier, PATCH=update_linkifier),\n    # realm/playgrounds -> zerver.views.realm_playgrounds\n    rest_path(\"realm/playgrounds\", POST=add_realm_playground),\n    rest_path(\"realm/playgrounds/<int:playground_id>\", DELETE=delete_realm_playground),\n    # realm/profile_fields -> zerver.views.custom_profile_fields\n    rest_path(\n        \"realm/profile_fields\",\n        GET=list_realm_custom_profile_fields,\n        PATCH=reorder_realm_custom_profile_fields,\n        POST=create_realm_custom_profile_field,\n    ),\n    rest_path(\n        \"realm/profile_fields/<int:field_id>\",\n        PATCH=update_realm_custom_profile_field,\n        DELETE=delete_realm_custom_profile_field,\n    ),\n    # realm/deactivate -> zerver.views.deactivate_realm\n    rest_path(\"realm/deactivate\", POST=deactivate_realm),\n    # users -> zerver.views.users\n    rest_path(\"users\", GET=get_members_backend, POST=create_user_backend),\n    rest_path(\"users/me\", GET=get_profile_backend, DELETE=deactivate_user_own_backend),\n    rest_path(\"users/<int:user_id>/reactivate\", POST=reactivate_user_backend),\n    rest_path(\n        \"users/<int:user_id>\",\n        GET=get_members_backend,\n        PATCH=update_user_backend,\n        DELETE=deactivate_user_backend,\n    ),\n    rest_path(\"users/<int:user_id>/subscriptions/<int:stream_id>\", GET=get_subscription_backend),\n    rest_path(\"users/<email>\", GET=get_user_by_email),\n    rest_path(\"bots\", GET=get_bots_backend, POST=add_bot_backend),\n    rest_path(\"bots/<int:bot_id>/api_key/regenerate\", POST=regenerate_bot_api_key),\n    rest_path(\"bots/<int:bot_id>\", PATCH=patch_bot_backend, DELETE=deactivate_bot_backend),\n    # invites -> zerver.views.invite\n    rest_path(\"invites\", GET=get_user_invites, POST=invite_users_backend),\n    rest_path(\"invites/<int:prereg_id>\", DELETE=revoke_user_invite),\n    rest_path(\"invites/<int:prereg_id>/resend\", POST=resend_user_invite_email),\n    # invites/multiuse -> zerver.views.invite\n    rest_path(\"invites/multiuse\", POST=generate_multiuse_invite_backend),\n    # invites/multiuse -> zerver.views.invite\n    rest_path(\"invites/multiuse/<int:invite_id>\", DELETE=revoke_multiuse_invite),\n    # mark messages as read (in bulk)\n    rest_path(\"mark_all_as_read\", POST=mark_all_as_read),\n    rest_path(\"mark_stream_as_read\", POST=mark_stream_as_read),\n    rest_path(\"mark_topic_as_read\", POST=mark_topic_as_read),\n    rest_path(\"zcommand\", POST=zcommand_backend),\n    # Endpoints for syncing drafts.\n    rest_path(\"drafts\", GET=fetch_drafts, POST=create_drafts),\n    rest_path(\"drafts/<int:draft_id>\", PATCH=edit_draft, DELETE=delete_draft),\n    # messages -> zerver.views.message*\n    # GET returns messages, possibly filtered, POST sends a message\n    rest_path(\n        \"messages\",\n        GET=(get_messages_backend, {\"allow_anonymous_user_web\"}),\n        POST=(send_message_backend, {\"allow_incoming_webhooks\"}),\n    ),\n    rest_path(\n        \"messages/<int:message_id>\",\n        GET=(json_fetch_raw_message, {\"allow_anonymous_user_web\"}),\n        PATCH=update_message_backend,\n        DELETE=delete_message_backend,\n    ),\n    rest_path(\"messages/render\", POST=render_message_backend),\n    rest_path(\"messages/flags\", POST=update_message_flags),\n    rest_path(\"messages/<int:message_id>/history\", GET=get_message_edit_history),\n    rest_path(\"messages/matches_narrow\", GET=messages_in_narrow_backend),\n    rest_path(\"users/me/subscriptions/properties\", POST=update_subscription_properties_backend),\n    rest_path(\"users/me/subscriptions/<int:stream_id>\", PATCH=update_subscriptions_property),\n    rest_path(\"submessage\", POST=process_submessage),\n    # New endpoint for handling reactions.\n    # reactions -> zerver.view.reactions\n    # POST adds a reaction to a message\n    # DELETE removes a reaction from a message\n    rest_path(\"messages/<int:message_id>/reactions\", POST=add_reaction, DELETE=remove_reaction),\n    # attachments -> zerver.views.attachments\n    rest_path(\"attachments\", GET=list_by_user),\n    rest_path(\"attachments/<int:attachment_id>\", DELETE=remove),\n    # typing -> zerver.views.typing\n    # POST sends a typing notification event to recipients\n    rest_path(\"typing\", POST=send_notification_backend),\n    # user_uploads -> zerver.views.upload\n    rest_path(\"user_uploads\", POST=upload_file_backend),\n    rest_path(\n        \"user_uploads/<realm_id_str>/<path:filename>\",\n        GET=(serve_file_url_backend, {\"override_api_url_scheme\"}),\n    ),\n    # bot_storage -> zerver.views.storage\n    rest_path(\"bot_storage\", PUT=update_storage, GET=get_storage, DELETE=remove_storage),\n    # Endpoint used by mobile devices to register their push\n    # notification credentials\n    rest_path(\n        \"users/me/apns_device_token\", POST=add_apns_device_token, DELETE=remove_apns_device_token\n    ),\n    rest_path(\"users/me/android_gcm_reg_id\", POST=add_android_reg_id, DELETE=remove_android_reg_id),\n    # users/*/presnece => zerver.views.presence.\n    rest_path(\"users/me/presence\", POST=update_active_status_backend),\n    # It's important that this sit after users/me/presence so that\n    # Django's URL resolution order doesn't break the\n    # /users/me/presence endpoint.\n    rest_path(\"users/<user_id_or_email>/presence\", GET=get_presence_backend),\n    rest_path(\"realm/presence\", GET=get_statuses_for_realm),\n    rest_path(\"users/me/status\", POST=update_user_status_backend),\n    # user_groups -> zerver.views.user_groups\n    rest_path(\"user_groups\", GET=get_user_group),\n    rest_path(\"user_groups/create\", POST=add_user_group),\n    rest_path(\"user_groups/<int:user_group_id>\", PATCH=edit_user_group, DELETE=delete_user_group),\n    rest_path(\"user_groups/<int:user_group_id>/members\", POST=update_user_group_backend),\n    # users/me -> zerver.views.user_settings\n    rest_path(\"users/me/api_key/regenerate\", POST=regenerate_api_key),\n    rest_path(\"users/me/avatar\", POST=set_avatar_backend, DELETE=delete_avatar_backend),\n    # users/me/hotspots -> zerver.views.hotspots\n    rest_path(\n        \"users/me/hotspots\",\n        POST=(\n            mark_hotspot_as_read,\n            # This endpoint is low priority for documentation as\n            # it is part of the web app-specific tutorial.\n            {\"intentionally_undocumented\"},\n        ),\n    ),\n    # users/me/tutorial_status -> zerver.views.tutorial\n    rest_path(\n        \"users/me/tutorial_status\",\n        POST=(\n            set_tutorial_status,\n            # This is a relic of an old Zulip tutorial model and\n            # should be deleted.\n            {\"intentionally_undocumented\"},\n        ),\n    ),\n    # settings -> zerver.views.user_settings\n    rest_path(\"settings\", PATCH=json_change_settings),\n    # These next two are legacy aliases for /settings, from before\n    # we merged the endpoints. They are documented in the `/json/settings`\n    # documentation, rather than having dedicated pages.\n    rest_path(\"settings/display\", PATCH=(json_change_settings, {\"intentionally_undocumented\"})),\n    rest_path(\n        \"settings/notifications\", PATCH=(json_change_settings, {\"intentionally_undocumented\"})\n    ),\n    # users/me/alert_words -> zerver.views.alert_words\n    rest_path(\n        \"users/me/alert_words\",\n        GET=list_alert_words,\n        POST=add_alert_words,\n        DELETE=remove_alert_words,\n    ),\n    # users/me/custom_profile_data -> zerver.views.custom_profile_data\n    rest_path(\n        \"users/me/profile_data\",\n        PATCH=update_user_custom_profile_data,\n        DELETE=remove_user_custom_profile_data,\n    ),\n    rest_path(\n        \"users/me/<int:stream_id>/topics\", GET=(get_topics_backend, {\"allow_anonymous_user_web\"})\n    ),\n    # streams -> zerver.views.streams\n    # (this API is only used externally)\n    rest_path(\"streams\", GET=get_streams_backend),\n    # GET returns `stream_id`, stream name should be encoded in the URL query (in `stream` param)\n    rest_path(\"get_stream_id\", GET=json_get_stream_id),\n    # GET returns \"stream info\" (undefined currently?), HEAD returns whether stream exists (200 or 404)\n    rest_path(\"streams/<int:stream_id>/members\", GET=get_subscribers_backend),\n    rest_path(\n        \"streams/<int:stream_id>\", PATCH=update_stream_backend, DELETE=deactivate_stream_backend\n    ),\n    # Delete topic in stream\n    rest_path(\"streams/<int:stream_id>/delete_topic\", POST=delete_in_topic),\n    rest_path(\"default_streams\", POST=add_default_stream, DELETE=remove_default_stream),\n    rest_path(\"default_stream_groups/create\", POST=create_default_stream_group),\n    rest_path(\n        \"default_stream_groups/<int:group_id>\",\n        PATCH=update_default_stream_group_info,\n        DELETE=remove_default_stream_group,\n    ),\n    rest_path(\n        \"default_stream_groups/<int:group_id>/streams\", PATCH=update_default_stream_group_streams\n    ),\n    # GET lists your streams, POST bulk adds, PATCH bulk modifies/removes\n    rest_path(\n        \"users/me/subscriptions\",\n        GET=list_subscriptions_backend,\n        POST=add_subscriptions_backend,\n        PATCH=update_subscriptions_backend,\n        DELETE=remove_subscriptions_backend,\n    ),\n    # muting -> zerver.views.muting\n    rest_path(\"users/me/subscriptions/muted_topics\", PATCH=update_muted_topic),\n    rest_path(\"users/me/muted_users/<int:muted_user_id>\", POST=mute_user, DELETE=unmute_user),\n    # used to register for an event queue in tornado\n    rest_path(\"register\", POST=events_register_backend),\n    # events -> zerver.tornado.views\n    rest_path(\"events\", GET=get_events, DELETE=cleanup_event_queue),\n    # report -> zerver.views.report\n    #\n    # These endpoints are for internal error/performance reporting\n    # from the browser to the web app, and we don't expect to ever\n    # include in our API documentation.\n    rest_path(\n        \"report/error\",\n        # Logged-out browsers can hit this endpoint, for portico page JS exceptions.\n        POST=(report_error, {\"allow_anonymous_user_web\", \"intentionally_undocumented\"}),\n    ),\n    rest_path(\"report/send_times\", POST=(report_send_times, {\"intentionally_undocumented\"})),\n    rest_path(\n        \"report/narrow_times\",\n        POST=(report_narrow_times, {\"allow_anonymous_user_web\", \"intentionally_undocumented\"}),\n    ),\n    rest_path(\n        \"report/unnarrow_times\",\n        POST=(report_unnarrow_times, {\"allow_anonymous_user_web\", \"intentionally_undocumented\"}),\n    ),\n    # Used to generate a Zoom video call URL\n    rest_path(\"calls/zoom/create\", POST=make_zoom_video_call),\n    # Used to generate a BigBlueButton video call URL\n    rest_path(\"calls/bigbluebutton/create\", GET=get_bigbluebutton_url),\n    # export/realm -> zerver.views.realm_export\n    rest_path(\"export/realm\", POST=export_realm, GET=get_realm_exports),\n    rest_path(\"export/realm/<int:export_id>\", DELETE=delete_realm_export),\n]\n\nintegrations_view = IntegrationView.as_view()\n\n# These views serve pages (HTML). As such, their internationalization\n# must depend on the URL.\n#\n# If you're adding a new page to the website (as opposed to a new\n# endpoint for use by code), you should add it here.\ni18n_urls = [\n    path(\"\", home, name=\"home\"),\n    # We have a desktop-specific landing page in case we change our /\n    # to not log in in the future. We don't want to require a new\n    # desktop app build for everyone in that case\n    path(\"desktop_home/\", desktop_home),\n    # Backwards-compatibility (legacy) Google auth URL for the mobile\n    # apps; see https://github.com/zulip/zulip/issues/13081 for\n    # background.  We can remove this once older versions of the\n    # mobile app are no longer present in the wild.\n    path(\"accounts/login/google/\", start_social_login, {\"backend\": \"google\"}),\n    path(\"accounts/login/start/sso/\", start_remote_user_sso, name=\"start-login-sso\"),\n    path(\"accounts/login/sso/\", remote_user_sso, name=\"login-sso\"),\n    path(\"accounts/login/jwt/\", remote_user_jwt),\n    path(\"accounts/login/social/<backend>\", start_social_login, name=\"login-social\"),\n    path(\"accounts/login/social/<backend>/<extra_arg>\", start_social_login, name=\"login-social\"),\n    path(\"accounts/register/social/<backend>\", start_social_signup, name=\"signup-social\"),\n    path(\n        \"accounts/register/social/<backend>/<extra_arg>\", start_social_signup, name=\"signup-social\"\n    ),\n    path(\"accounts/login/subdomain/<token>\", log_into_subdomain),\n    # We have two entries for accounts/login; only the first one is\n    # used for URL resolution.  The second here is to allow\n    # reverse(\"login\") in templates to\n    # return `/accounts/login/`.\n    path(\"accounts/login/\", login_page, {\"template_name\": \"zerver/login.html\"}, name=\"login_page\"),\n    path(\"accounts/login/\", LoginView.as_view(template_name=\"zerver/login.html\"), name=\"login\"),\n    path(\"accounts/logout/\", logout_then_login),\n    path(\"accounts/webathena_kerberos_login/\", webathena_kerberos_login),\n    path(\"accounts/password/reset/\", password_reset, name=\"password_reset\"),\n    path(\n        \"accounts/password/reset/done/\",\n        PasswordResetDoneView.as_view(template_name=\"zerver/reset_emailed.html\"),\n    ),\n    path(\n        \"accounts/password/reset/<uidb64>/<token>/\",\n        PasswordResetConfirmView.as_view(\n            success_url=\"/accounts/password/done/\",\n            template_name=\"zerver/reset_confirm.html\",\n            form_class=LoggingSetPasswordForm,\n        ),\n        name=\"password_reset_confirm\",\n    ),\n    path(\n        \"accounts/password/done/\",\n        PasswordResetCompleteView.as_view(template_name=\"zerver/reset_done.html\"),\n    ),\n    path(\"accounts/deactivated/\", show_deactivation_notice),\n    # Displays digest email content in browser.\n    path(\"digest/\", digest_page),\n    # Registration views, require a confirmation ID.\n    path(\"accounts/home/\", accounts_home),\n    path(\n        \"accounts/send_confirm/<email>\",\n        TemplateView.as_view(template_name=\"zerver/accounts_send_confirm.html\"),\n        name=\"signup_send_confirm\",\n    ),\n    path(\n        \"accounts/new/send_confirm/<email>\",\n        TemplateView.as_view(template_name=\"zerver/accounts_send_confirm.html\"),\n        {\"realm_creation\": True},\n        name=\"new_realm_send_confirm\",\n    ),\n    path(\"accounts/register/\", accounts_register, name=\"accounts_register\"),\n    path(\n        \"accounts/do_confirm/<confirmation_key>\",\n        check_prereg_key_and_redirect,\n        name=\"check_prereg_key_and_redirect\",\n    ),\n    path(\n        \"accounts/confirm_new_email/<confirmation_key>\",\n        confirm_email_change,\n        name=\"confirm_email_change\",\n    ),\n    # Email unsubscription endpoint. Allows for unsubscribing from various types of emails,\n    # including the welcome emails (day 1 & 2), missed PMs, etc.\n    path(\n        \"accounts/unsubscribe/<email_type>/<confirmation_key>\",\n        email_unsubscribe,\n        name=\"unsubscribe\",\n    ),\n    # Portico-styled page used to provide email confirmation of terms acceptance.\n    path(\"accounts/accept_terms/\", accounts_accept_terms, name=\"accept_terms\"),\n    # Find your account\n    path(\"accounts/find/\", find_account, name=\"find_account\"),\n    # Go to organization subdomain\n    path(\"accounts/go/\", realm_redirect, name=\"realm_redirect\"),\n    # Realm creation\n    path(\"new/\", create_realm),\n    path(\"new/<creation_key>\", create_realm, name=\"create_realm\"),\n    # Realm reactivation\n    path(\"reactivate/<confirmation_key>\", realm_reactivation, name=\"realm_reactivation\"),\n    # Login/registration\n    path(\"register/\", accounts_home, name=\"register\"),\n    path(\"login/\", login_page, {\"template_name\": \"zerver/login.html\"}, name=\"login_page\"),\n    path(\"join/<confirmation_key>/\", accounts_home_from_multiuse_invite, name=\"join\"),\n    # Used to generate a Zoom video call URL\n    path(\"calls/zoom/register\", register_zoom_user),\n    path(\"calls/zoom/complete\", complete_zoom_user),\n    path(\"calls/zoom/deauthorize\", deauthorize_zoom_user),\n    # Used to join a BigBlueButton video call\n    path(\"calls/bigbluebutton/join\", join_bigbluebutton),\n    # API and integrations documentation\n    path(\"integrations/doc-html/<integration_name>\", integration_doc),\n    path(\"integrations/\", integrations_view),\n    path(\"integrations/<path:path>\", integrations_view),\n    # Landing page, features pages, signup form, etc.\n    path(\"hello/\", hello_view),\n    path(\"new-user/\", RedirectView.as_view(url=\"/hello\", permanent=True)),\n    path(\"features/\", landing_view, {\"template_name\": \"zerver/features.html\"}),\n    path(\"plans/\", plans_view, name=\"plans\"),\n    path(\"apps/\", apps_view),\n    path(\"apps/download/<platform>\", app_download_link_redirect),\n    path(\"apps/<platform>\", apps_view),\n    path(\n        \"development-community/\",\n        landing_view,\n        {\"template_name\": \"zerver/development-community.html\"},\n    ),\n    path(\"attribution/\", landing_view, {\"template_name\": \"zerver/attribution.html\"}),\n    path(\"team/\", team_view),\n    path(\"history/\", landing_view, {\"template_name\": \"zerver/history.html\"}),\n    path(\"why-zulip/\", landing_view, {\"template_name\": \"zerver/why-zulip.html\"}),\n    path(\"for/education/\", landing_view, {\"template_name\": \"zerver/for-education.html\"}),\n    path(\"for/events/\", landing_view, {\"template_name\": \"zerver/for-events.html\"}),\n    path(\"for/open-source/\", landing_view, {\"template_name\": \"zerver/for-open-source.html\"}),\n    path(\"for/research/\", landing_view, {\"template_name\": \"zerver/for-research.html\"}),\n    path(\"for/companies/\", landing_view, {\"template_name\": \"zerver/for-companies.html\"}),\n    path(\"case-studies/tum/\", landing_view, {\"template_name\": \"zerver/tum-case-study.html\"}),\n    path(\"case-studies/ucsd/\", landing_view, {\"template_name\": \"zerver/ucsd-case-study.html\"}),\n    path(\"case-studies/rust/\", landing_view, {\"template_name\": \"zerver/rust-case-study.html\"}),\n    path(\"case-studies/lean/\", landing_view, {\"template_name\": \"zerver/lean-case-study.html\"}),\n    path(\n        \"for/communities/\",\n        landing_view,\n        {\"template_name\": \"zerver/for-communities.html\"},\n    ),\n    # We merged this into /for/communities.\n    path(\n        \"for/working-groups-and-communities/\",\n        RedirectView.as_view(url=\"/for/communities/\", permanent=True),\n    ),\n    path(\"security/\", landing_view, {\"template_name\": \"zerver/security.html\"}),\n    # Terms of Service and privacy pages.\n    path(\"terms/\", terms_view),\n    path(\"privacy/\", privacy_view),\n    path(\n        \"developer-community/\", RedirectView.as_view(url=\"/development-community/\", permanent=True)\n    ),\n]\n\n# Make a copy of i18n_urls so that they appear without prefix for english\nurls: List[Union[URLPattern, URLResolver]] = list(i18n_urls)\n\n# Include the dual-use patterns twice\nurls += [\n    path(\"api/v1/\", include(v1_api_and_json_patterns)),\n    path(\"json/\", include(v1_api_and_json_patterns)),\n]\n\n# user_uploads -> zerver.views.upload.serve_file_backend\n#\n# This URL is an exception to the URL naming schemes for endpoints. It\n# supports both API and session cookie authentication, using a single\n# URL for both (not 'api/v1/' or 'json/' prefix). This is required to\n# easily support the mobile apps fetching uploaded files without\n# having to rewrite URLs, and is implemented using the\n# 'override_api_url_scheme' flag passed to rest_dispatch\nurls += [\n    path(\n        \"user_uploads/temporary/<token>/<filename>\",\n        serve_local_file_unauthed,\n        name=\"local_file_unauthed\",\n    ),\n    rest_path(\n        \"user_uploads/<realm_id_str>/<path:filename>\",\n        GET=(serve_file_backend, {\"override_api_url_scheme\"}),\n    ),\n    # This endpoint redirects to camo; it requires an exception for the\n    # same reason.\n    rest_path(\"thumbnail\", GET=(backend_serve_thumbnail, {\"override_api_url_scheme\"})),\n    # Avatars have the same constraint because their URLs are included\n    # in API data structures used by both the mobile and web clients.\n    rest_path(\n        \"avatar/<email_or_id>\",\n        GET=(avatar, {\"override_api_url_scheme\", \"allow_anonymous_user_web\"}),\n    ),\n    rest_path(\n        \"avatar/<email_or_id>/medium\",\n        {\"medium\": True},\n        GET=(avatar, {\"override_api_url_scheme\", \"allow_anonymous_user_web\"}),\n    ),\n]\n\n# This URL serves as a way to receive CSP violation reports from the users.\n# We use this endpoint to just log these reports.\nurls += [\n    path(\"report/csp_violations\", report_csp_violations),\n]\n\n# Incoming webhook URLs\n# We don't create URLs for particular Git integrations here\n# because of generic one below\nfor incoming_webhook in WEBHOOK_INTEGRATIONS:\n    if incoming_webhook.url_object:\n        urls.append(incoming_webhook.url_object)\n\n# Desktop-specific authentication URLs\nurls += [\n    rest_path(\"json/fetch_api_key\", POST=json_fetch_api_key),\n]\n\n# Mobile-specific authentication URLs\nurls += [\n    # Used as a global check by all mobile clients, which currently send\n    # requests to https://zulip.com/compatibility almost immediately after\n    # starting up.\n    path(\"compatibility\", check_global_compatibility),\n]\n\nv1_api_mobile_patterns = [\n    # This json format view used by the mobile apps lists which\n    # authentication backends the server allows as well as details\n    # like the requested subdomains'd realm icon (if known) and\n    # server-specific compatibility.\n    path(\"server_settings\", api_get_server_settings),\n    # This json format view used by the mobile apps accepts a username\n    # password/pair and returns an API key.\n    path(\"fetch_api_key\", api_fetch_api_key),\n]\n\n# View for uploading messages from email mirror\nurls += [\n    path(\"email_mirror_message\", email_mirror_message),\n]\n\n# Include URL configuration files for site-specified extra installed\n# Django apps\nfor app_name in settings.EXTRA_INSTALLED_APPS:\n    app_dir = os.path.join(settings.DEPLOY_ROOT, app_name)\n    if os.path.exists(os.path.join(app_dir, \"urls.py\")):\n        urls += [path(\"\", include(f\"{app_name}.urls\"))]\n        i18n_urls += import_string(f\"{app_name}.urls.i18n_urlpatterns\")\n\n# Tornado views\nurls += [\n    # Used internally for communication between Django and Tornado processes\n    #\n    # Since these views don't use rest_dispatch, they cannot have\n    # asynchronous Tornado behavior.\n    path(\"notify_tornado\", notify),\n    path(\"api/v1/events/internal\", get_events_internal),\n]\n\n# Python Social Auth\n\nurls += [path(\"\", include(\"social_django.urls\", namespace=\"social\"))]\nurls += [path(\"saml/metadata.xml\", saml_sp_metadata)]\n\n# SCIM2\n\nfrom zerver.lib.scim import (\n    ZulipSCIMSearchView,\n    ZulipSCIMUserSearchView,\n    ZulipSCIMUsersView,\n    ZulipSCIMView,\n)\n\nurls += [\n    # We have to register all the SCIM URL patterns first, because we override\n    # all the SCIM View classes and we need Django to use them instead of\n    # the django-scim2 Views that the app will register.\n    re_path(r\"^scim/v2/$\", ZulipSCIMView.as_view(implemented=False)),\n    re_path(r\"^scim/v2/.search$\", ZulipSCIMSearchView.as_view(implemented=False)),\n    re_path(r\"^scim/v2/Users/.search$\", ZulipSCIMUserSearchView.as_view()),\n    re_path(r\"^scim/v2/Users(?:/(?P<uuid>[^/]+))?$\", ZulipSCIMUsersView.as_view()),\n    # Everything below here are features that we don't yet support and we want\n    # to explicitly mark them to return \"Not Implemented\" rather than running\n    # the django-scim2 code for them.\n    re_path(\n        r\"^scim/v2/Groups/.search$\",\n        ZulipSCIMView.as_view(implemented=False),\n    ),\n    re_path(\n        r\"^scim/v2/Groups(?:/(?P<uuid>[^/]+))?$\",\n        ZulipSCIMView.as_view(implemented=False),\n    ),\n    re_path(r\"^scim/v2/Me$\", ZulipSCIMView.as_view(implemented=False)),\n    re_path(\n        r\"^scim/v2/ServiceProviderConfig$\",\n        ZulipSCIMView.as_view(implemented=False),\n    ),\n    re_path(\n        r\"^scim/v2/ResourceTypes(?:/(?P<uuid>[^/]+))?$\",\n        ZulipSCIMView.as_view(implemented=False),\n    ),\n    re_path(r\"^scim/v2/Schemas(?:/(?P<uuid>[^/]+))?$\", ZulipSCIMView.as_view(implemented=False)),\n    re_path(r\"^scim/v2/Bulk$\", ZulipSCIMView.as_view(implemented=False)),\n    # At the end we still register the django-scim2 url patterns (even though we override them all above)\n    # so that reverse(\"scim:viewname\") still works like the internal library code expects.\n    path(\"scim/v2/\", include(\"django_scim.urls\", namespace=\"scim\")),\n]\n\n# User documentation site\nhelp_documentation_view = MarkdownDirectoryView.as_view(\n    template_name=\"zerver/documentation_main.html\", path_template=\"/zerver/help/%s.md\"\n)\napi_documentation_view = MarkdownDirectoryView.as_view(\n    template_name=\"zerver/documentation_main.html\", path_template=\"/zerver/api/%s.md\"\n)\nurls += [\n    # Redirects due to us having moved the docs:\n    path(\n        \"help/delete-a-stream\", RedirectView.as_view(url=\"/help/archive-a-stream\", permanent=True)\n    ),\n    path(\"api/delete-stream\", RedirectView.as_view(url=\"/api/archive-stream\", permanent=True)),\n    path(\n        \"help/change-the-topic-of-a-message\",\n        RedirectView.as_view(url=\"/help/rename-a-topic\", permanent=True),\n    ),\n    path(\n        \"help/configure-missed-message-emails\",\n        RedirectView.as_view(url=\"/help/email-notifications\", permanent=True),\n    ),\n    path(\n        \"help/add-an-alert-word\",\n        RedirectView.as_view(\n            url=\"/help/pm-mention-alert-notifications#alert-words\", permanent=True\n        ),\n    ),\n    path(\n        \"help/test-mobile-notifications\",\n        RedirectView.as_view(url=\"/help/mobile-notifications\", permanent=True),\n    ),\n    path(\n        \"help/troubleshooting-desktop-notifications\",\n        RedirectView.as_view(\n            url=\"/help/desktop-notifications#troubleshooting-desktop-notifications\", permanent=True\n        ),\n    ),\n    path(\n        \"help/change-notification-sound\",\n        RedirectView.as_view(\n            url=\"/help/desktop-notifications#change-notification-sound\", permanent=True\n        ),\n    ),\n    path(\n        \"help/configure-message-notification-emails\",\n        RedirectView.as_view(url=\"/help/email-notifications\", permanent=True),\n    ),\n    path(\n        \"help/disable-new-login-emails\",\n        RedirectView.as_view(url=\"/help/email-notifications#new-login-emails\", permanent=True),\n    ),\n    # This redirect is particularly important, because the old URL\n    # appears in links from Welcome Bot messages.\n    path(\n        \"help/about-streams-and-topics\",\n        RedirectView.as_view(url=\"/help/streams-and-topics\", permanent=True),\n    ),\n    path(\n        \"help/community-topic-edits\",\n        RedirectView.as_view(url=\"/help/configure-who-can-edit-topics\", permanent=True),\n    ),\n    path(\n        \"help/only-allow-admins-to-add-emoji\",\n        RedirectView.as_view(\n            url=\"/help/custom-emoji#change-who-can-add-custom-emoji\", permanent=True\n        ),\n    ),\n    path(\n        \"help/configure-who-can-add-custom-emoji\",\n        RedirectView.as_view(\n            url=\"/help/custom-emoji#change-who-can-add-custom-emoji\", permanent=True\n        ),\n    ),\n    path(\n        \"help/add-custom-emoji\",\n        RedirectView.as_view(url=\"/help/custom-emoji\", permanent=True),\n    ),\n    path(\n        \"help/night-mode\",\n        RedirectView.as_view(url=\"/help/dark-theme\", permanent=True),\n    ),\n    path(\"help/\", help_documentation_view),\n    path(\"help/<path:article>\", help_documentation_view),\n    path(\"api/\", api_documentation_view),\n    path(\"api/<slug:article>\", api_documentation_view),\n]\n\n# Two-factor URLs\nif settings.TWO_FACTOR_AUTHENTICATION_ENABLED:\n    urls += [path(\"\", include(tf_urls)), path(\"\", include(tf_twilio_urls))]\n\nif settings.DEVELOPMENT:\n    urls += dev_urls.urls\n    i18n_urls += dev_urls.i18n_urls\n    v1_api_mobile_patterns += dev_urls.v1_api_mobile_patterns\n\nurls += [\n    path(\"api/v1/\", include(v1_api_mobile_patterns)),\n]\n\n# The sequence is important; if i18n URLs don't come first then\n# reverse URL mapping points to i18n URLs which causes the frontend\n# tests to fail\nurlpatterns = i18n_patterns(*i18n_urls) + urls + legacy_urls\n"], "fixing_code": ["# Copyright: (c) 2008, Jarek Zgoda <jarek.zgoda@gmail.com>\n\n__revision__ = \"$Id: models.py 28 2009-10-22 15:03:02Z jarek.zgoda $\"\nimport datetime\nimport secrets\nfrom base64 import b32encode\nfrom typing import Mapping, Optional, Union\nfrom urllib.parse import urljoin\n\nfrom django.conf import settings\nfrom django.contrib.contenttypes.fields import GenericForeignKey\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.db import models\nfrom django.db.models import CASCADE\nfrom django.http import HttpRequest, HttpResponse\nfrom django.shortcuts import render\nfrom django.urls import reverse\nfrom django.utils.timezone import now as timezone_now\nfrom typing_extensions import Protocol\n\nfrom zerver.models import EmailChangeStatus, MultiuseInvite, PreregistrationUser, Realm, UserProfile\n\n\nclass HasRealmObject(Protocol):\n    realm: Realm\n\n\nclass OptionalHasRealmObject(Protocol):\n    realm: Optional[Realm]\n\n\nclass ConfirmationKeyException(Exception):\n    WRONG_LENGTH = 1\n    EXPIRED = 2\n    DOES_NOT_EXIST = 3\n\n    def __init__(self, error_type: int) -> None:\n        super().__init__()\n        self.error_type = error_type\n\n\ndef render_confirmation_key_error(\n    request: HttpRequest, exception: ConfirmationKeyException\n) -> HttpResponse:\n    if exception.error_type == ConfirmationKeyException.WRONG_LENGTH:\n        return render(request, \"confirmation/link_malformed.html\", status=404)\n    if exception.error_type == ConfirmationKeyException.EXPIRED:\n        return render(request, \"confirmation/link_expired.html\", status=404)\n    return render(request, \"confirmation/link_does_not_exist.html\", status=404)\n\n\ndef generate_key() -> str:\n    # 24 characters * 5 bits of entropy/character = 120 bits of entropy\n    return b32encode(secrets.token_bytes(15)).decode().lower()\n\n\nConfirmationObjT = Union[MultiuseInvite, PreregistrationUser, EmailChangeStatus]\n\n\ndef get_object_from_key(\n    confirmation_key: str, confirmation_type: int, activate_object: bool = True\n) -> ConfirmationObjT:\n    # Confirmation keys used to be 40 characters\n    if len(confirmation_key) not in (24, 40):\n        raise ConfirmationKeyException(ConfirmationKeyException.WRONG_LENGTH)\n    try:\n        confirmation = Confirmation.objects.get(\n            confirmation_key=confirmation_key, type=confirmation_type\n        )\n    except Confirmation.DoesNotExist:\n        raise ConfirmationKeyException(ConfirmationKeyException.DOES_NOT_EXIST)\n\n    if timezone_now() > confirmation.expiry_date:\n        raise ConfirmationKeyException(ConfirmationKeyException.EXPIRED)\n\n    obj = confirmation.content_object\n    assert obj is not None\n    if activate_object and hasattr(obj, \"status\"):\n        obj.status = getattr(settings, \"STATUS_ACTIVE\", 1)\n        obj.save(update_fields=[\"status\"])\n    return obj\n\n\ndef create_confirmation_link(\n    obj: Union[Realm, HasRealmObject, OptionalHasRealmObject],\n    confirmation_type: int,\n    *,\n    validity_in_days: Optional[int] = None,\n    url_args: Mapping[str, str] = {},\n) -> str:\n    # validity_in_days is an override for the default values which are\n    # determined by the confirmation_type - its main purpose is for use\n    # in tests which may want to have control over the exact expiration time.\n    key = generate_key()\n    realm = None\n    if isinstance(obj, Realm):\n        realm = obj\n    elif hasattr(obj, \"realm\"):\n        realm = obj.realm\n\n    current_time = timezone_now()\n    expiry_date = None\n    if validity_in_days:\n        expiry_date = current_time + datetime.timedelta(days=validity_in_days)\n    else:\n        expiry_date = current_time + datetime.timedelta(\n            days=_properties[confirmation_type].validity_in_days\n        )\n\n    Confirmation.objects.create(\n        content_object=obj,\n        date_sent=current_time,\n        confirmation_key=key,\n        realm=realm,\n        expiry_date=expiry_date,\n        type=confirmation_type,\n    )\n    return confirmation_url(key, realm, confirmation_type, url_args)\n\n\ndef confirmation_url(\n    confirmation_key: str,\n    realm: Optional[Realm],\n    confirmation_type: int,\n    url_args: Mapping[str, str] = {},\n) -> str:\n    url_args = dict(url_args)\n    url_args[\"confirmation_key\"] = confirmation_key\n    return urljoin(\n        settings.ROOT_DOMAIN_URI if realm is None else realm.uri,\n        reverse(_properties[confirmation_type].url_name, kwargs=url_args),\n    )\n\n\nclass Confirmation(models.Model):\n    content_type = models.ForeignKey(ContentType, on_delete=CASCADE)\n    object_id: int = models.PositiveIntegerField(db_index=True)\n    content_object = GenericForeignKey(\"content_type\", \"object_id\")\n    date_sent: datetime.datetime = models.DateTimeField(db_index=True)\n    confirmation_key: str = models.CharField(max_length=40, db_index=True)\n    expiry_date: datetime.datetime = models.DateTimeField(db_index=True)\n    realm: Optional[Realm] = models.ForeignKey(Realm, null=True, on_delete=CASCADE)\n\n    # The following list is the set of valid types\n    USER_REGISTRATION = 1\n    INVITATION = 2\n    EMAIL_CHANGE = 3\n    UNSUBSCRIBE = 4\n    SERVER_REGISTRATION = 5\n    MULTIUSE_INVITE = 6\n    REALM_CREATION = 7\n    REALM_REACTIVATION = 8\n    type: int = models.PositiveSmallIntegerField()\n\n    def __str__(self) -> str:\n        return f\"<Confirmation: {self.content_object}>\"\n\n    class Meta:\n        unique_together = (\"type\", \"confirmation_key\")\n\n\nclass ConfirmationType:\n    def __init__(\n        self,\n        url_name: str,\n        validity_in_days: int = settings.CONFIRMATION_LINK_DEFAULT_VALIDITY_DAYS,\n    ) -> None:\n        self.url_name = url_name\n        self.validity_in_days = validity_in_days\n\n\n_properties = {\n    Confirmation.USER_REGISTRATION: ConfirmationType(\"get_prereg_key_and_redirect\"),\n    Confirmation.INVITATION: ConfirmationType(\n        \"get_prereg_key_and_redirect\", validity_in_days=settings.INVITATION_LINK_VALIDITY_DAYS\n    ),\n    Confirmation.EMAIL_CHANGE: ConfirmationType(\"confirm_email_change\"),\n    Confirmation.UNSUBSCRIBE: ConfirmationType(\n        \"unsubscribe\",\n        validity_in_days=1000000,  # should never expire\n    ),\n    Confirmation.MULTIUSE_INVITE: ConfirmationType(\n        \"join\", validity_in_days=settings.INVITATION_LINK_VALIDITY_DAYS\n    ),\n    Confirmation.REALM_CREATION: ConfirmationType(\"get_prereg_key_and_redirect\"),\n    Confirmation.REALM_REACTIVATION: ConfirmationType(\"realm_reactivation\"),\n}\n\n\ndef one_click_unsubscribe_link(user_profile: UserProfile, email_type: str) -> str:\n    \"\"\"\n    Generate a unique link that a logged-out user can visit to unsubscribe from\n    Zulip e-mails without having to first log in.\n    \"\"\"\n    return create_confirmation_link(\n        user_profile, Confirmation.UNSUBSCRIBE, url_args={\"email_type\": email_type}\n    )\n\n\n# Functions related to links generated by the generate_realm_creation_link.py\n# management command.\n# Note that being validated here will just allow the user to access the create_realm\n# form, where they will enter their email and go through the regular\n# Confirmation.REALM_CREATION pathway.\n# Arguably RealmCreationKey should just be another ConfirmationObjT and we should\n# add another Confirmation.type for this; it's this way for historical reasons.\n\n\ndef validate_key(creation_key: Optional[str]) -> Optional[\"RealmCreationKey\"]:\n    \"\"\"Get the record for this key, raising InvalidCreationKey if non-None but invalid.\"\"\"\n    if creation_key is None:\n        return None\n    try:\n        key_record = RealmCreationKey.objects.get(creation_key=creation_key)\n    except RealmCreationKey.DoesNotExist:\n        raise RealmCreationKey.Invalid()\n    time_elapsed = timezone_now() - key_record.date_created\n    if time_elapsed.total_seconds() > settings.REALM_CREATION_LINK_VALIDITY_DAYS * 24 * 3600:\n        raise RealmCreationKey.Invalid()\n    return key_record\n\n\ndef generate_realm_creation_url(by_admin: bool = False) -> str:\n    key = generate_key()\n    RealmCreationKey.objects.create(\n        creation_key=key, date_created=timezone_now(), presume_email_valid=by_admin\n    )\n    return urljoin(\n        settings.ROOT_DOMAIN_URI,\n        reverse(\"create_realm\", kwargs={\"creation_key\": key}),\n    )\n\n\nclass RealmCreationKey(models.Model):\n    creation_key = models.CharField(\"activation key\", db_index=True, max_length=40)\n    date_created = models.DateTimeField(\"created\", default=timezone_now)\n\n    # True just if we should presume the email address the user enters\n    # is theirs, and skip sending mail to it to confirm that.\n    presume_email_valid: bool = models.BooleanField(default=False)\n\n    class Invalid(Exception):\n        pass\n", "import datetime\nimport re\nimport time\nimport urllib\nfrom typing import Any, Dict, List, Optional, Sequence, Union\nfrom unittest.mock import MagicMock, patch\nfrom urllib.parse import urlencode\n\nimport orjson\nfrom django.conf import settings\nfrom django.contrib.auth.views import PasswordResetConfirmView\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.core.exceptions import ValidationError\nfrom django.http import HttpResponse\nfrom django.test import Client, override_settings\nfrom django.urls import reverse\nfrom django.utils.timezone import now as timezone_now\n\nfrom confirmation import settings as confirmation_settings\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyException,\n    create_confirmation_link,\n    get_object_from_key,\n    one_click_unsubscribe_link,\n)\nfrom corporate.lib.stripe import get_latest_seat_count\nfrom zerver.context_processors import common_context\nfrom zerver.decorator import do_two_factor_login\nfrom zerver.forms import HomepageForm, check_subdomain_available\nfrom zerver.lib.actions import (\n    add_new_user_history,\n    change_user_is_active,\n    do_add_default_stream,\n    do_change_full_name,\n    do_change_realm_subdomain,\n    do_change_user_role,\n    do_create_default_stream_group,\n    do_create_multiuse_invite_link,\n    do_create_realm,\n    do_create_user,\n    do_deactivate_realm,\n    do_deactivate_user,\n    do_get_user_invites,\n    do_invite_users,\n    do_set_realm_property,\n    do_set_realm_user_default_setting,\n    get_default_streams_for_realm,\n)\nfrom zerver.lib.email_notifications import enqueue_welcome_emails, followup_day2_email_delay\nfrom zerver.lib.initial_password import initial_password\nfrom zerver.lib.mobile_auth_otp import (\n    ascii_to_hex,\n    hex_to_ascii,\n    is_valid_otp,\n    otp_decrypt_api_key,\n    otp_encrypt_api_key,\n    xor_hex_strings,\n)\nfrom zerver.lib.name_restrictions import is_disposable_domain\nfrom zerver.lib.rate_limiter import add_ratelimit_rule, remove_ratelimit_rule\nfrom zerver.lib.send_email import (\n    EmailNotDeliveredException,\n    FromAddress,\n    deliver_scheduled_emails,\n    send_future_email,\n)\nfrom zerver.lib.stream_subscription import get_stream_subscriptions_for_user\nfrom zerver.lib.streams import create_stream_if_needed\nfrom zerver.lib.subdomains import is_root_domain_available\nfrom zerver.lib.test_classes import ZulipTestCase\nfrom zerver.lib.test_helpers import (\n    avatar_disk_path,\n    cache_tries_captured,\n    find_key_by_email,\n    get_test_image_file,\n    load_subdomain_token,\n    message_stream_count,\n    most_recent_message,\n    most_recent_usermessage,\n    queries_captured,\n    reset_emails_in_zulip_realm,\n)\nfrom zerver.models import (\n    CustomProfileField,\n    CustomProfileFieldValue,\n    DefaultStream,\n    Message,\n    MultiuseInvite,\n    PreregistrationUser,\n    Realm,\n    RealmAuditLog,\n    RealmUserDefault,\n    Recipient,\n    ScheduledEmail,\n    Stream,\n    Subscription,\n    UserMessage,\n    UserProfile,\n    flush_per_request_caches,\n    get_realm,\n    get_stream,\n    get_system_bot,\n    get_user,\n    get_user_by_delivery_email,\n)\nfrom zerver.views.auth import redirect_and_log_into_subdomain, start_two_factor_auth\nfrom zerver.views.development.registration import confirmation_key\nfrom zerver.views.invite import get_invitee_emails_set\nfrom zproject.backends import ExternalAuthDataDict, ExternalAuthResult\n\n\nclass RedirectAndLogIntoSubdomainTestCase(ZulipTestCase):\n    def test_data(self) -> None:\n        realm = get_realm(\"zulip\")\n        user_profile = self.example_user(\"hamlet\")\n        name = user_profile.full_name\n        email = user_profile.delivery_email\n        response = redirect_and_log_into_subdomain(ExternalAuthResult(user_profile=user_profile))\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\"full_name\": name, \"email\": email, \"subdomain\": realm.subdomain, \"is_signup\": False},\n        )\n\n        data_dict = ExternalAuthDataDict(is_signup=True, multiuse_object_key=\"key\")\n        response = redirect_and_log_into_subdomain(\n            ExternalAuthResult(user_profile=user_profile, data_dict=data_dict)\n        )\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\n                \"full_name\": name,\n                \"email\": email,\n                \"subdomain\": realm.subdomain,\n                # the email has an account at the subdomain,\n                # so is_signup get overridden to False:\n                \"is_signup\": False,\n                \"multiuse_object_key\": \"key\",\n            },\n        )\n\n        data_dict = ExternalAuthDataDict(\n            email=self.nonreg_email(\"alice\"),\n            full_name=\"Alice\",\n            subdomain=realm.subdomain,\n            is_signup=True,\n            full_name_validated=True,\n            multiuse_object_key=\"key\",\n        )\n        response = redirect_and_log_into_subdomain(ExternalAuthResult(data_dict=data_dict))\n        data = load_subdomain_token(response)\n        self.assertDictEqual(\n            data,\n            {\n                \"full_name\": \"Alice\",\n                \"email\": self.nonreg_email(\"alice\"),\n                \"full_name_validated\": True,\n                \"subdomain\": realm.subdomain,\n                \"is_signup\": True,\n                \"multiuse_object_key\": \"key\",\n            },\n        )\n\n\nclass DeactivationNoticeTestCase(ZulipTestCase):\n    def test_redirection_for_deactivated_realm(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        for url in (\"/register/\", \"/login/\"):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 302)\n            self.assertIn(\"deactivated\", result.url)\n\n    def test_redirection_for_active_realm(self) -> None:\n        for url in (\"/register/\", \"/login/\"):\n            result = self.client_get(url)\n            self.assertEqual(result.status_code, 200)\n\n    def test_deactivation_notice_when_realm_is_active(self) -> None:\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result.url)\n\n    def test_deactivation_notice_when_deactivated(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\"Zulip Dev, has been deactivated.\", result.content.decode())\n        self.assertNotIn(\"It has moved to\", result.content.decode())\n\n    def test_deactivation_notice_when_deactivated_and_deactivated_redirect_is_set(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.deactivated_redirect = \"http://example.zulipchat.com\"\n        realm.save(update_fields=[\"deactivated\", \"deactivated_redirect\"])\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://example.zulipchat.com\">http://example.zulipchat.com</a>.',\n            result.content.decode(),\n        )\n\n    def test_deactivation_notice_when_realm_subdomain_is_changed(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-subdomain-name\", acting_user=None)\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://new-subdomain-name.testserver\">http://new-subdomain-name.testserver</a>.',\n            result.content.decode(),\n        )\n\n    def test_deactivated_redirect_field_of_placeholder_realms_are_modified_on_changing_subdomain_multiple_times(\n        self,\n    ) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-name-1\", acting_user=None)\n\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://new-name-1.testserver\">http://new-name-1.testserver</a>.',\n            result.content.decode(),\n        )\n\n        realm = get_realm(\"new-name-1\")\n        do_change_realm_subdomain(realm, \"new-name-2\", acting_user=None)\n        result = self.client_get(\"/accounts/deactivated/\")\n        self.assertIn(\n            'It has moved to <a href=\"http://new-name-2.testserver\">http://new-name-2.testserver</a>.',\n            result.content.decode(),\n        )\n\n\nclass AddNewUserHistoryTest(ZulipTestCase):\n    def test_add_new_user_history_race(self) -> None:\n        \"\"\"Sends a message during user creation\"\"\"\n        # Create a user who hasn't had historical messages added\n        realm = get_realm(\"zulip\")\n        stream = Stream.objects.get(realm=realm, name=\"Denmark\")\n        DefaultStream.objects.create(stream=stream, realm=realm)\n        # Make sure at least 3 messages are sent to Denmark and it's a default stream.\n        message_id = self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 1\")\n        self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 2\")\n        self.send_stream_message(self.example_user(\"hamlet\"), stream.name, \"test 3\")\n\n        with patch(\"zerver.lib.actions.add_new_user_history\"):\n            self.register(self.nonreg_email(\"test\"), \"test\")\n        user_profile = self.nonreg_user(\"test\")\n        subs = Subscription.objects.select_related(\"recipient\").filter(\n            user_profile=user_profile, recipient__type=Recipient.STREAM\n        )\n        streams = Stream.objects.filter(id__in=[sub.recipient.type_id for sub in subs])\n\n        # Sent a message afterwards to trigger a race between message\n        # sending and `add_new_user_history`.\n        race_message_id = self.send_stream_message(\n            self.example_user(\"hamlet\"), streams[0].name, \"test\"\n        )\n\n        # Overwrite ONBOARDING_UNREAD_MESSAGES to 2\n        ONBOARDING_UNREAD_MESSAGES = 2\n        with patch(\"zerver.lib.actions.ONBOARDING_UNREAD_MESSAGES\", ONBOARDING_UNREAD_MESSAGES):\n            add_new_user_history(user_profile, streams)\n\n        # Our first message is in the user's history\n        self.assertTrue(\n            UserMessage.objects.filter(user_profile=user_profile, message_id=message_id).exists()\n        )\n        # The race message is in the user's history and marked unread.\n        self.assertTrue(\n            UserMessage.objects.filter(\n                user_profile=user_profile, message_id=race_message_id\n            ).exists()\n        )\n        self.assertFalse(\n            UserMessage.objects.get(\n                user_profile=user_profile, message_id=race_message_id\n            ).flags.read.is_set\n        )\n\n        # Verify that the ONBOARDING_UNREAD_MESSAGES latest messages\n        # that weren't the race message are marked as unread.\n        latest_messages = (\n            UserMessage.objects.filter(\n                user_profile=user_profile,\n                message__recipient__type=Recipient.STREAM,\n            )\n            .exclude(message_id=race_message_id)\n            .order_by(\"-message_id\")[0:ONBOARDING_UNREAD_MESSAGES]\n        )\n        self.assert_length(latest_messages, 2)\n        for msg in latest_messages:\n            self.assertFalse(msg.flags.read.is_set)\n\n        # Verify that older messages are correctly marked as read.\n        older_messages = (\n            UserMessage.objects.filter(\n                user_profile=user_profile,\n                message__recipient__type=Recipient.STREAM,\n            )\n            .exclude(message_id=race_message_id)\n            .order_by(\"-message_id\")[ONBOARDING_UNREAD_MESSAGES : ONBOARDING_UNREAD_MESSAGES + 1]\n        )\n        self.assertGreater(len(older_messages), 0)\n        for msg in older_messages:\n            self.assertTrue(msg.flags.read.is_set)\n\n    def test_auto_subbed_to_personals(self) -> None:\n        \"\"\"\n        Newly created users are auto-subbed to the ability to receive\n        personals.\n        \"\"\"\n        test_email = self.nonreg_email(\"test\")\n        self.register(test_email, \"test\")\n        user_profile = self.nonreg_user(\"test\")\n        old_messages_count = message_stream_count(user_profile)\n        self.send_personal_message(user_profile, user_profile)\n        new_messages_count = message_stream_count(user_profile)\n        self.assertEqual(new_messages_count, old_messages_count + 1)\n\n        recipient = Recipient.objects.get(type_id=user_profile.id, type=Recipient.PERSONAL)\n        message = most_recent_message(user_profile)\n        self.assertEqual(message.recipient, recipient)\n\n        with patch(\"zerver.models.get_display_recipient\", return_value=\"recip\"):\n            self.assertEqual(\n                str(message),\n                \"<Message: recip /  / \"\n                \"<UserProfile: {} {}>>\".format(user_profile.email, user_profile.realm),\n            )\n\n            user_message = most_recent_usermessage(user_profile)\n            self.assertEqual(\n                str(user_message),\n                f\"<UserMessage: recip / {user_profile.email} ([])>\",\n            )\n\n\nclass InitialPasswordTest(ZulipTestCase):\n    def test_none_initial_password_salt(self) -> None:\n        with self.settings(INITIAL_PASSWORD_SALT=None):\n            self.assertIsNone(initial_password(\"test@test.com\"))\n\n\nclass PasswordResetTest(ZulipTestCase):\n    \"\"\"\n    Log in, reset password, log out, log in with new password.\n    \"\"\"\n\n    def get_reset_mail_body(self, subdomain: str = \"zulip\") -> str:\n        from django.core.mail import outbox\n\n        [message] = outbox\n        self.assertEqual(self.email_envelope_from(message), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertRegex(\n            self.email_display_from(message),\n            fr\"^Zulip Account Security <{self.TOKENIZED_NOREPLY_REGEX}>\\Z\",\n        )\n        self.assertIn(f\"{subdomain}.testserver\", message.extra_headers[\"List-Id\"])\n\n        return message.body\n\n    def test_password_reset(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.delivery_email\n        old_password = initial_password(email)\n        assert old_password is not None\n\n        self.login_user(user)\n\n        # test password reset template\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assert_in_response(\"Reset your password\", result)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"reset your password\", body)\n\n        # Visit the password reset link.\n        password_reset_url = self.get_confirmation_url_from_outbox(\n            email, url_pattern=settings.EXTERNAL_HOST + r\"(\\S\\S+)\"\n        )\n        result = self.client_get(password_reset_url)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.endswith(f\"/{PasswordResetConfirmView.reset_url_token}/\"))\n\n        final_reset_url = result.url\n        result = self.client_get(final_reset_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Reset your password\n        with self.settings(PASSWORD_MIN_LENGTH=3, PASSWORD_MIN_GUESSES=1000):\n            # Verify weak passwords don't work.\n            result = self.client_post(\n                final_reset_url, {\"new_password1\": \"easy\", \"new_password2\": \"easy\"}\n            )\n            self.assert_in_response(\"The password is too weak.\", result)\n\n            result = self.client_post(\n                final_reset_url, {\"new_password1\": \"f657gdGGk9\", \"new_password2\": \"f657gdGGk9\"}\n            )\n            # password reset succeeded\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/password/done/\"))\n\n            # log back in with new password\n            self.login_by_email(email, password=\"f657gdGGk9\")\n            user_profile = self.example_user(\"hamlet\")\n            self.assert_logged_in_user_id(user_profile.id)\n\n            # make sure old password no longer works\n            self.assert_login_failure(email, password=old_password)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_redirects_for_root_alias_when_root_domain_landing_page_is_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"alias.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True, ROOT_SUBDOMAIN_ALIASES=[\"alias\"]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n        ):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_redirects_for_root_domain_when_root_domain_landing_page_is_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n        mock_get_host.return_value = \"www.testserver.com\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n            EXTERNAL_HOST=\"www.testserver.com\",\n        ):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Faccounts%2Fpassword%2Freset%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_for_root_alias_when_root_domain_landing_page_is_not_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"alias.testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"alias\"]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"www.testserver\"\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_for_root_domain_when_root_domain_landing_page_is_not_enabled(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"testserver\"\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"www.testserver.com\"\n        with self.settings(EXTERNAL_HOST=\"www.testserver.com\", ROOT_SUBDOMAIN_ALIASES=[]):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_password_reset_page_works_always_for_subdomains(\n        self, mock_get_host: MagicMock\n    ) -> None:\n        mock_get_host.return_value = \"lear.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/accounts/password/reset/\")\n            self.assertEqual(result.status_code, 200)\n\n        result = self.client_get(\"/accounts/password/reset/\")\n        self.assertEqual(result.status_code, 200)\n\n    def test_password_reset_for_non_existent_user(self) -> None:\n        email = \"nonexisting@mars.com\"\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"You do not have an account\", body)\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"deactivated\", body)\n\n    def test_password_reset_for_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        do_deactivate_user(user_profile, acting_user=None)\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        body = self.get_reset_mail_body()\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"has been deactivated\", body)\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"not have an account\", body)\n\n    def test_password_reset_with_deactivated_realm(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        do_deactivate_realm(user_profile.realm, acting_user=None)\n\n        # start the password reset process by supplying an email address\n        with self.assertLogs(level=\"INFO\") as m:\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(m.output, [\"INFO:root:Realm is deactivated\"])\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        # Check that the password reset email is from a noreply address.\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(RATE_LIMITING=True)\n    def test_rate_limiting(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        from django.core.mail import outbox\n\n        add_ratelimit_rule(10, 2, domain=\"password_reset_form_by_email\")\n        start_time = time.time()\n        with patch(\"time.time\", return_value=start_time):\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assert_length(outbox, 2)\n\n            # Too many password reset emails sent to the address, we won't send more.\n            with self.assertLogs(level=\"INFO\") as info_logs:\n                self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(\n                info_logs.output,\n                [\n                    \"INFO:root:Too many password reset attempts for email hamlet@zulip.com from 127.0.0.1\"\n                ],\n            )\n            self.assert_length(outbox, 2)\n\n            # Resetting for a different address works though.\n            self.client_post(\"/accounts/password/reset/\", {\"email\": self.example_email(\"othello\")})\n            self.assert_length(outbox, 3)\n            self.client_post(\"/accounts/password/reset/\", {\"email\": self.example_email(\"othello\")})\n            self.assert_length(outbox, 4)\n\n        # After time, password reset emails can be sent again.\n        with patch(\"time.time\", return_value=start_time + 11):\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assert_length(outbox, 6)\n\n        remove_ratelimit_rule(10, 2, domain=\"password_reset_form_by_email\")\n\n    def test_wrong_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\"/accounts/password/reset/\", {\"email\": email}, subdomain=\"zephyr\")\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        body = self.get_reset_mail_body(\"zephyr\")\n        self.assertIn(\"Somebody (possibly you) requested a new password\", body)\n        self.assertIn(\"You do not have an account\", body)\n        self.assertIn(\n            \"active accounts in the following organization(s).\\nhttp://zulip.testserver\", body\n        )\n        self.assertIn(\"safely ignore\", body)\n        self.assertNotIn(\"reset your password\", body)\n        self.assertNotIn(\"deactivated\", body)\n\n    def test_invalid_subdomain(self) -> None:\n        email = self.example_email(\"hamlet\")\n\n        # start the password reset process by supplying an email address\n        result = self.client_post(\n            \"/accounts/password/reset/\", {\"email\": email}, subdomain=\"invalid\"\n        )\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_auth_only(self) -> None:\n        \"\"\"If the email auth backend is not enabled, password reset should do nothing\"\"\"\n        email = self.example_email(\"hamlet\")\n        with self.assertLogs(level=\"INFO\") as m:\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(\n                m.output,\n                [\n                    \"INFO:root:Password reset attempted for hamlet@zulip.com even though password auth is disabled.\"\n                ],\n            )\n\n        # check the redirect link telling you to check mail for password reset link\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n        result = self.client_get(result[\"Location\"])\n\n        self.assert_in_response(\"Check your email in a few minutes to finish the process.\", result)\n\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_and_email_auth(self) -> None:\n        \"\"\"If both email and LDAP auth backends are enabled, limit password\n        reset to users outside the LDAP domain\"\"\"\n        # If the domain matches, we don't generate an email\n        with self.settings(LDAP_APPEND_DOMAIN=\"zulip.com\"):\n            email = self.example_email(\"hamlet\")\n            with self.assertLogs(level=\"INFO\") as m:\n                result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n                self.assertEqual(\n                    m.output, [\"INFO:root:Password reset not allowed for user in LDAP domain\"]\n                )\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n        # If the domain doesn't match, we do generate an email\n        with self.settings(LDAP_APPEND_DOMAIN=\"example.com\"):\n            email = self.example_email(\"hamlet\")\n            result = self.client_post(\"/accounts/password/reset/\", {\"email\": email})\n            self.assertEqual(result.status_code, 302)\n            self.assertTrue(result[\"Location\"].endswith(\"/accounts/password/reset/done/\"))\n            result = self.client_get(result[\"Location\"])\n\n        body = self.get_reset_mail_body()\n        self.assertIn(\"reset your password\", body)\n\n    def test_redirect_endpoints(self) -> None:\n        \"\"\"\n        These tests are mostly designed to give us 100% URL coverage\n        in our URL coverage reports.  Our mechanism for finding URL\n        coverage doesn't handle redirects, so we just have a few quick\n        tests here.\n        \"\"\"\n        result = self.client_get(\"/accounts/password/reset/done/\")\n        self.assert_in_success_response([\"Check your email\"], result)\n\n        result = self.client_get(\"/accounts/password/done/\")\n        self.assert_in_success_response([\"We've reset your password!\"], result)\n\n        result = self.client_get(\"/accounts/send_confirm/alice@example.com\")\n        self.assert_in_success_response([\"/accounts/home/\"], result)\n\n        result = self.client_get(\"/accounts/new/send_confirm/alice@example.com\")\n        self.assert_in_success_response([\"/new/\"], result)\n\n\nclass LoginTest(ZulipTestCase):\n    \"\"\"\n    Logging in, registration, and logging out.\n    \"\"\"\n\n    def test_login(self) -> None:\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_login_deactivated_user(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        do_deactivate_user(user_profile, acting_user=None)\n        result = self.login_with_return(user_profile.delivery_email, \"xxx\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            f\"Your account {user_profile.delivery_email} has been deactivated.\", result\n        )\n        self.assert_logged_in_user_id(None)\n\n    def test_login_bad_password(self) -> None:\n        user = self.example_user(\"hamlet\")\n        password: Optional[str] = \"wrongpassword\"\n        result = self.login_with_return(user.delivery_email, password=password)\n        self.assert_in_success_response([user.delivery_email], result)\n        self.assert_logged_in_user_id(None)\n\n        # Parallel test to confirm that the right password works using the\n        # same login code, which verifies our failing test isn't broken\n        # for some other reason.\n        password = initial_password(user.delivery_email)\n        result = self.login_with_return(user.delivery_email, password=password)\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user.id)\n\n    @override_settings(RATE_LIMITING_AUTHENTICATE=True)\n    def test_login_bad_password_rate_limiter(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        email = user_profile.delivery_email\n        add_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n        start_time = time.time()\n        with patch(\"time.time\", return_value=start_time):\n            self.login_with_return(email, password=\"wrongpassword\")\n            self.assert_logged_in_user_id(None)\n            self.login_with_return(email, password=\"wrongpassword\")\n            self.assert_logged_in_user_id(None)\n\n            # We're over the allowed limit, so the next attempt, even with the correct\n            # password, will get blocked.\n            result = self.login_with_return(email)\n            self.assert_in_success_response([\"Try again in 10 seconds\"], result)\n\n        # After time passes, we should be able to log in.\n        with patch(\"time.time\", return_value=start_time + 11):\n            self.login_with_return(email)\n            self.assert_logged_in_user_id(user_profile.id)\n\n        remove_ratelimit_rule(10, 2, domain=\"authenticate_by_username\")\n\n    def test_login_with_old_weak_password_after_hasher_change(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        password = \"a_password_of_22_chars\"\n\n        with self.settings(PASSWORD_HASHERS=(\"django.contrib.auth.hashers.SHA1PasswordHasher\",)):\n            user_profile.set_password(password)\n            user_profile.save()\n\n        with self.settings(\n            PASSWORD_HASHERS=(\n                \"django.contrib.auth.hashers.MD5PasswordHasher\",\n                \"django.contrib.auth.hashers.SHA1PasswordHasher\",\n            ),\n            PASSWORD_MIN_LENGTH=30,\n        ), self.assertLogs(\"zulip.auth.email\", level=\"INFO\"):\n            result = self.login_with_return(self.example_email(\"hamlet\"), password)\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\n                \"Your password has been disabled because it is too weak.\", result\n            )\n            self.assert_logged_in_user_id(None)\n\n    def test_login_nonexist_user(self) -> None:\n        result = self.login_with_return(\"xxx@zulip.com\", \"xxx\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Please enter a correct email and password\", result)\n        self.assert_logged_in_user_id(None)\n\n    def test_login_wrong_subdomain(self) -> None:\n        email = self.mit_email(\"sipbtest\")\n        with self.assertLogs(level=\"WARNING\") as m:\n            result = self.login_with_return(email, \"xxx\")\n            self.assertEqual(\n                m.output,\n                [\n                    \"WARNING:root:User sipbtest@mit.edu attempted password login to wrong subdomain zulip\"\n                ],\n            )\n        self.assertEqual(result.status_code, 200)\n        expected_error = (\n            f\"Your Zulip account {email} is not a member of the \"\n            + \"organization associated with this subdomain.\"\n        )\n        self.assert_in_response(expected_error, result)\n        self.assert_logged_in_user_id(None)\n\n    def test_login_invalid_subdomain(self) -> None:\n        result = self.login_with_return(self.example_email(\"hamlet\"), \"xxx\", subdomain=\"invalid\")\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"There is no Zulip organization hosted at this subdomain.\", result)\n        self.assert_logged_in_user_id(None)\n\n    def test_register(self) -> None:\n        reset_emails_in_zulip_realm()\n\n        realm = get_realm(\"zulip\")\n        stream_names = [f\"stream_{i}\" for i in range(40)]\n        for stream_name in stream_names:\n            stream = self.make_stream(stream_name, realm=realm)\n            DefaultStream.objects.create(stream=stream, realm=realm)\n\n        # Clear all the caches.\n        flush_per_request_caches()\n        ContentType.objects.clear_cache()\n\n        with queries_captured() as queries, cache_tries_captured() as cache_tries:\n            self.register(self.nonreg_email(\"test\"), \"test\")\n        # Ensure the number of queries we make is not O(streams)\n        self.assert_length(queries, 91)\n\n        # We can probably avoid a couple cache hits here, but there doesn't\n        # seem to be any O(N) behavior.  Some of the cache hits are related\n        # to sending messages, such as getting the welcome bot, looking up\n        # the alert words for a realm, etc.\n        self.assert_length(cache_tries, 21)\n\n        user_profile = self.nonreg_user(\"test\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.assertFalse(user_profile.enable_stream_desktop_notifications)\n\n    def test_register_deactivated(self) -> None:\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.client_post(\n            \"/accounts/home/\", {\"email\": self.nonreg_email(\"test\")}, subdomain=\"zulip\"\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result.url)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user(\"test\")\n\n    def test_register_with_invalid_email(self) -> None:\n        \"\"\"\n        If you try to register with invalid email, you get an invalid email\n        page\n        \"\"\"\n        invalid_email = \"foo\\x00bar\"\n        result = self.client_post(\"/accounts/home/\", {\"email\": invalid_email}, subdomain=\"zulip\")\n\n        self.assertEqual(result.status_code, 200)\n        self.assertContains(result, \"Enter a valid email address\")\n\n    def test_register_deactivated_partway_through(self) -> None:\n        \"\"\"\n        If you try to register for a deactivated realm, you get a clear error\n        page.\n        \"\"\"\n        email = self.nonreg_email(\"test\")\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertNotIn(\"deactivated\", result.url)\n\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.submit_reg_form_for_user(email, \"abcd1234\", subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result.url)\n\n        with self.assertRaises(UserProfile.DoesNotExist):\n            self.nonreg_user(\"test\")\n\n    def test_login_deactivated_realm(self) -> None:\n        \"\"\"\n        If you try to log in to a deactivated realm, you get a clear error page.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        realm.deactivated = True\n        realm.save(update_fields=[\"deactivated\"])\n\n        result = self.login_with_return(self.example_email(\"hamlet\"), subdomain=\"zulip\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\"/accounts/deactivated/\", result.url)\n\n    def test_logout(self) -> None:\n        self.login(\"hamlet\")\n        # We use the logout API, not self.logout, to make sure we test\n        # the actual logout code path.\n        self.client_post(\"/accounts/logout/\")\n        self.assert_logged_in_user_id(None)\n\n    def test_non_ascii_login(self) -> None:\n        \"\"\"\n        You can log in even if your password contain non-ASCII characters.\n        \"\"\"\n        email = self.nonreg_email(\"test\")\n        password = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Registering succeeds.\n        self.register(email, password)\n        user_profile = self.nonreg_user(\"test\")\n        self.assert_logged_in_user_id(user_profile.id)\n        self.logout()\n        self.assert_logged_in_user_id(None)\n\n        # Logging in succeeds.\n        self.logout()\n        self.login_by_email(email, password)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TWO_FACTOR_AUTHENTICATION_ENABLED=False)\n    def test_login_page_redirects_logged_in_user(self) -> None:\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        self.login(\"cordelia\")\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\n    def test_options_request_to_login_page(self) -> None:\n        response = self.client_options(\"/login/\")\n        self.assertEqual(response.status_code, 200)\n\n    @override_settings(TWO_FACTOR_AUTHENTICATION_ENABLED=True)\n    def test_login_page_redirects_logged_in_user_under_2fa(self) -> None:\n        \"\"\"You will be redirected to the app's main page if you land on the\n        login page when already logged in.\n        \"\"\"\n        user_profile = self.example_user(\"cordelia\")\n        self.create_default_device(user_profile)\n\n        self.login(\"cordelia\")\n        self.login_2fa(user_profile)\n\n        response = self.client_get(\"/login/\")\n        self.assertEqual(response[\"Location\"], \"http://zulip.testserver\")\n\n    def test_start_two_factor_auth(self) -> None:\n        request = MagicMock(POST={})\n        with patch(\"zerver.views.auth.TwoFactorLoginView\") as mock_view:\n            mock_view.as_view.return_value = lambda *a, **k: HttpResponse()\n            response = start_two_factor_auth(request)\n            self.assertTrue(isinstance(response, HttpResponse))\n\n    def test_do_two_factor_login(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        self.create_default_device(user_profile)\n        request = MagicMock()\n        with patch(\"zerver.decorator.django_otp.login\") as mock_login:\n            do_two_factor_login(request, user_profile)\n            mock_login.assert_called_once()\n\n    def test_zulip_default_context_does_not_load_inline_previews(self) -> None:\n        realm = get_realm(\"zulip\")\n        description = \"https://www.google.com/images/srpr/logo4w.png\"\n        realm.description = description\n        realm.save(update_fields=[\"description\"])\n        response = self.client_get(\"/login/\")\n        expected_response = \"\"\"<p><a href=\"https://www.google.com/images/srpr/logo4w.png\">\\\nhttps://www.google.com/images/srpr/logo4w.png</a></p>\"\"\"\n        self.assertEqual(response.context_data[\"realm_description\"], expected_response)\n        self.assertEqual(response.status_code, 200)\n\n\nclass InviteUserBase(ZulipTestCase):\n    def check_sent_emails(self, correct_recipients: List[str]) -> None:\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, len(correct_recipients))\n        email_recipients = [email.recipients()[0] for email in outbox]\n        self.assertEqual(sorted(email_recipients), sorted(correct_recipients))\n        if len(outbox) == 0:\n            return\n\n        self.assertIn(\"Zulip\", self.email_display_from(outbox[0]))\n\n        self.assertEqual(self.email_envelope_from(outbox[0]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertRegex(\n            self.email_display_from(outbox[0]), fr\" <{self.TOKENIZED_NOREPLY_REGEX}>\\Z\"\n        )\n\n        self.assertEqual(outbox[0].extra_headers[\"List-Id\"], \"Zulip Dev <zulip.testserver>\")\n\n    def invite(\n        self,\n        invitee_emails: str,\n        stream_names: Sequence[str],\n        invite_expires_in_days: int = settings.INVITATION_LINK_VALIDITY_DAYS,\n        body: str = \"\",\n        invite_as: int = PreregistrationUser.INVITE_AS[\"MEMBER\"],\n    ) -> HttpResponse:\n        \"\"\"\n        Invites the specified users to Zulip with the specified streams.\n\n        users should be a string containing the users to invite, comma or\n            newline separated.\n\n        streams should be a list of strings.\n        \"\"\"\n        stream_ids = []\n        for stream_name in stream_names:\n            stream_ids.append(self.get_stream_id(stream_name))\n        return self.client_post(\n            \"/json/invites\",\n            {\n                \"invitee_emails\": invitee_emails,\n                \"invite_expires_in_days\": invite_expires_in_days,\n                \"stream_ids\": orjson.dumps(stream_ids).decode(),\n                \"invite_as\": invite_as,\n            },\n        )\n\n\nclass InviteUserTest(InviteUserBase):\n    def test_successful_invite_user(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n        self.check_sent_emails([invitee])\n\n    def test_newbie_restrictions(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n        stream_name = \"Denmark\"\n\n        self.login_user(user_profile)\n\n        result = self.invite(invitee, [stream_name])\n        self.assert_json_success(result)\n\n        user_profile.date_joined = timezone_now() - datetime.timedelta(days=10)\n        user_profile.save()\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=5):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_success(result)\n\n        with self.settings(INVITES_MIN_USER_AGE_DAYS=15):\n            result = self.invite(invitee, [stream_name])\n            self.assert_json_error_contains(result, \"Your account is too new\")\n\n    def test_invite_limits(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        realm = user_profile.realm\n        stream_name = \"Denmark\"\n\n        # These constants only need to be in descending order\n        # for this test to trigger an InvitationError based\n        # on max daily counts.\n        site_max = 50\n        realm_max = 40\n        num_invitees = 30\n        max_daily_count = 20\n\n        daily_counts = [(1, max_daily_count)]\n\n        invite_emails = [f\"foo-{i:02}@zulip.com\" for i in range(num_invitees)]\n        invitees = \",\".join(invite_emails)\n\n        self.login_user(user_profile)\n\n        realm.max_invites = realm_max\n        realm.date_created = timezone_now()\n        realm.save()\n\n        def try_invite() -> HttpResponse:\n            with self.settings(\n                OPEN_REALM_CREATION=True,\n                INVITES_DEFAULT_REALM_DAILY_MAX=site_max,\n                INVITES_NEW_REALM_LIMIT_DAYS=daily_counts,\n            ):\n                result = self.invite(invitees, [stream_name])\n                return result\n\n        result = try_invite()\n        self.assert_json_error_contains(result, \"reached the limit\")\n\n        # Next show that aggregate limits expire once the realm is old\n        # enough.\n\n        realm.date_created = timezone_now() - datetime.timedelta(days=8)\n        realm.save()\n\n        with queries_captured() as queries:\n            with cache_tries_captured() as cache_tries:\n                result = try_invite()\n\n        self.assert_json_success(result)\n\n        # TODO: Fix large query count here.\n        #\n        # TODO: There is some test OTHER than this one\n        #       that is leaking some kind of state change\n        #       that throws off the query count here.  It\n        #       is hard to investigate currently (due to\n        #       the large number of queries), so I just\n        #       use an approximate equality check.\n        actual_count = len(queries)\n        expected_count = 251\n        if abs(actual_count - expected_count) > 1:\n            raise AssertionError(\n                f\"\"\"\n                Unexpected number of queries:\n\n                expected query count: {expected_count}\n                actual: {actual_count}\n                \"\"\"\n            )\n\n        # Almost all of these cache hits are to re-fetch each one of the\n        # invitees.  These happen inside our queue processor for sending\n        # confirmation emails, so they are somewhat difficult to avoid.\n        #\n        # TODO: Mock the call to queue_json_publish, so we can measure the\n        # queue impact separately from the user-perceived impact.\n        self.assert_length(cache_tries, 32)\n\n        # Next get line coverage on bumping a realm's max_invites.\n        realm.date_created = timezone_now()\n        realm.max_invites = site_max + 10\n        realm.save()\n\n        result = try_invite()\n        self.assert_json_success(result)\n\n        # Finally get coverage on the case that OPEN_REALM_CREATION is False.\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            result = self.invite(invitees, [stream_name])\n\n        self.assert_json_success(result)\n\n    def test_invite_user_to_realm_on_manual_license_plan(self) -> None:\n        user = self.example_user(\"hamlet\")\n        self.login_user(user)\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(\n            user.realm, 50, 50\n        )\n\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"alice\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses_at_next_renewal = 5\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_success(result)\n\n        ledger.licenses = get_latest_seat_count(user.realm) + 1\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            invitee_emails = self.nonreg_email(\"bob\") + \",\" + self.nonreg_email(\"alice\")\n            result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"Your organization does not have enough unused Zulip licenses to invite 2 users\"\n        )\n\n        ledger.licenses = get_latest_seat_count(user.realm)\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            result = self.invite(self.nonreg_email(\"bob\"), [\"Denmark\"])\n        self.assert_json_error_contains(\n            result, \"All Zulip licenses for this organization are currently in use\"\n        )\n\n    def test_cross_realm_bot(self) -> None:\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        cross_realm_bot_email = \"emailgateway@zulip.com\"\n        legit_new_email = \"fred@zulip.com\"\n        invitee_emails = \",\".join([cross_realm_bot_email, legit_new_email])\n\n        result = self.invite(invitee_emails, [\"Denmark\"])\n        self.assert_json_error(\n            result,\n            \"Some of those addresses are already using Zulip,\"\n            + \" so we didn't send them an invitation.\"\n            + \" We did send invitations to everyone else!\",\n        )\n\n    def test_invite_mirror_dummy_user(self) -> None:\n        \"\"\"\n        A mirror dummy account is a temporary account\n        that we keep in our system if we are mirroring\n        data from something like Zephyr or IRC.\n\n        We want users to eventually just sign up or\n        register for Zulip, in which case we will just\n        fully \"activate\" the account.\n\n        Here we test that you can invite a person who\n        has a mirror dummy account.\n        \"\"\"\n        inviter = self.example_user(\"hamlet\")\n        self.login_user(inviter)\n\n        mirror_user = self.example_user(\"cordelia\")\n        mirror_user.is_mirror_dummy = True\n        mirror_user.save()\n        change_user_is_active(mirror_user, False)\n\n        self.assertEqual(\n            PreregistrationUser.objects.filter(email=mirror_user.email).count(),\n            0,\n        )\n\n        result = self.invite(mirror_user.email, [\"Denmark\"])\n        self.assert_json_success(result)\n\n        prereg_user = PreregistrationUser.objects.get(email=mirror_user.email)\n        assert prereg_user.referred_by is not None and inviter is not None\n        self.assertEqual(\n            prereg_user.referred_by.email,\n            inviter.email,\n        )\n\n    def test_successful_invite_user_as_owner_from_owner_account(self) -> None:\n        self.login(\"desdemona\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n\n    def test_invite_user_as_owner_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n        )\n        self.assert_json_error(response, \"Must be an organization owner\")\n\n    def test_successful_invite_user_as_admin_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertTrue(invitee_profile.is_realm_admin)\n        self.assertFalse(invitee_profile.is_realm_owner)\n        self.assertFalse(invitee_profile.is_guest)\n\n    def test_invite_user_as_admin_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_successful_invite_user_as_moderator_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        result = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_success(result)\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_moderator)\n        self.assertFalse(invitee_profile.is_guest)\n\n    def test_invite_user_as_moderator_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_moderator_from_moderator_account(self) -> None:\n        self.login(\"shiva\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(\n            invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"MODERATOR\"]\n        )\n        self.assert_json_error(response, \"Must be an organization administrator\")\n\n    def test_invite_user_as_invalid_type(self) -> None:\n        \"\"\"\n        Test inviting a user as invalid type of user i.e. type of invite_as\n        is not in PreregistrationUser.INVITE_AS\n        \"\"\"\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        response = self.invite(invitee, [\"Denmark\"], invite_as=10)\n        self.assert_json_error(response, \"Must be invited as an valid type of user\")\n\n    def test_successful_invite_user_as_guest_from_normal_account(self) -> None:\n        self.login(\"hamlet\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n\n    def test_successful_invite_user_as_guest_from_admin_account(self) -> None:\n        self.login(\"iago\")\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(\n            self.invite(invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        )\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        self.assertFalse(invitee_profile.is_realm_admin)\n        self.assertTrue(invitee_profile.is_guest)\n\n    def test_successful_invite_user_with_name(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.check_sent_emails([email])\n\n    def test_successful_invite_user_with_name_and_normal_one(self) -> None:\n        \"\"\"\n        A call to /json/invites with valid parameters causes an invitation\n        email to be sent.\n        \"\"\"\n        self.login(\"hamlet\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_can_invite_others_to_realm(self) -> None:\n        def validation_func(user_profile: UserProfile) -> bool:\n            user_profile.refresh_from_db()\n            return user_profile.can_invite_others_to_realm()\n\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        desdemona = self.example_user(\"desdemona\")\n        self.assertFalse(validation_func(desdemona))\n\n        self.check_has_permission_policies(\"invite_to_realm_policy\", validation_func)\n\n    def test_invite_others_to_realm_setting(self) -> None:\n        \"\"\"\n        The invite_to_realm_policy realm setting works properly.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_NOBODY, acting_user=None\n        )\n        self.login(\"desdemona\")\n        email = \"alice-test@zulip.com\"\n        email2 = \"bob-test@zulip.com\"\n        invitee = f\"Alice Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_ADMINS_ONLY, acting_user=None\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        # Now verify an administrator can do it\n        self.login(\"iago\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n\n        self.check_sent_emails([email, email2])\n\n        from django.core import mail\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MODERATORS_ONLY, acting_user=None\n        )\n        self.login(\"hamlet\")\n        email = \"carol-test@zulip.com\"\n        email2 = \"earl-test@zulip.com\"\n        invitee = f\"Carol Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        self.login(\"shiva\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_MEMBERS_ONLY, acting_user=None\n        )\n\n        self.login(\"polonius\")\n        email = \"dave-test@zulip.com\"\n        email2 = \"mark-test@zulip.com\"\n        invitee = f\"Dave Test <{email}>, {email2}\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n\n        self.login(\"hamlet\")\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n        mail.outbox = []\n\n        do_set_realm_property(\n            realm, \"invite_to_realm_policy\", Realm.POLICY_FULL_MEMBERS_ONLY, acting_user=None\n        )\n        do_set_realm_property(realm, \"waiting_period_threshold\", 1000, acting_user=None)\n\n        hamlet = self.example_user(\"hamlet\")\n        hamlet.date_joined = timezone_now() - datetime.timedelta(\n            days=(realm.waiting_period_threshold - 1)\n        )\n\n        email = \"issac-test@zulip.com\"\n        email2 = \"steven-test@zulip.com\"\n        invitee = f\"Issac Test <{email}>, {email2}\"\n        self.assert_json_error(\n            self.invite(invitee, [\"Denmark\"]),\n            \"Insufficient permission\",\n        )\n\n        do_set_realm_property(realm, \"waiting_period_threshold\", 0, acting_user=None)\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(email))\n        self.assertTrue(find_key_by_email(email2))\n        self.check_sent_emails([email, email2])\n\n    def test_invite_user_signup_initial_history(self) -> None:\n        \"\"\"\n        Test that a new user invited to a stream receives some initial\n        history but only from public streams.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        private_stream_name = \"Secret\"\n        self.make_stream(private_stream_name, invite_only=True)\n        self.subscribe(user_profile, private_stream_name)\n        public_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            \"Denmark\",\n            topic_name=\"Public topic\",\n            content=\"Public message\",\n        )\n        secret_msg_id = self.send_stream_message(\n            self.example_user(\"hamlet\"),\n            private_stream_name,\n            topic_name=\"Secret topic\",\n            content=\"Secret message\",\n        )\n        invitee = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee, [private_stream_name, \"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee))\n\n        self.submit_reg_form_for_user(invitee, \"password\")\n        invitee_profile = self.nonreg_user(\"alice\")\n        invitee_msg_ids = [\n            um.message_id for um in UserMessage.objects.filter(user_profile=invitee_profile)\n        ]\n        self.assertTrue(public_msg_id in invitee_msg_ids)\n        self.assertFalse(secret_msg_id in invitee_msg_ids)\n        self.assertFalse(invitee_profile.is_realm_admin)\n\n        invitee_msg, signups_stream_msg, inviter_msg, secret_msg = Message.objects.all().order_by(\n            \"-id\"\n        )[0:4]\n\n        self.assertEqual(secret_msg.id, secret_msg_id)\n\n        self.assertEqual(inviter_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            inviter_msg.content.startswith(\n                f\"alice_zulip.com <`{invitee_profile.email}`> accepted your\",\n            )\n        )\n\n        self.assertEqual(signups_stream_msg.sender.email, \"notification-bot@zulip.com\")\n        self.assertTrue(\n            signups_stream_msg.content.startswith(\n                f\"@_**alice_zulip.com|{invitee_profile.id}** just signed up\",\n            )\n        )\n\n        self.assertEqual(invitee_msg.sender.email, \"welcome-bot@zulip.com\")\n        self.assertTrue(invitee_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", invitee_msg.content)\n\n    def test_multi_user_invite(self) -> None:\n        \"\"\"\n        Invites multiple users with a variety of delimiters.\n        \"\"\"\n        self.login(\"hamlet\")\n        # Intentionally use a weird string.\n        self.assert_json_success(\n            self.invite(\n                \"\"\"bob-test@zulip.com,     carol-test@zulip.com,\n            dave-test@zulip.com\n\n\nearl-test@zulip.com\"\"\",\n                [\"Denmark\"],\n            )\n        )\n        for user in (\"bob\", \"carol\", \"dave\", \"earl\"):\n            self.assertTrue(find_key_by_email(f\"{user}-test@zulip.com\"))\n        self.check_sent_emails(\n            [\n                \"bob-test@zulip.com\",\n                \"carol-test@zulip.com\",\n                \"dave-test@zulip.com\",\n                \"earl-test@zulip.com\",\n            ]\n        )\n\n    def test_max_invites_model(self) -> None:\n        realm = get_realm(\"zulip\")\n        self.assertEqual(realm.max_invites, settings.INVITES_DEFAULT_REALM_DAILY_MAX)\n        realm.max_invites = 3\n        realm.save()\n        self.assertEqual(get_realm(\"zulip\").max_invites, 3)\n        realm.max_invites = settings.INVITES_DEFAULT_REALM_DAILY_MAX\n        realm.save()\n\n    def test_invite_too_many_users(self) -> None:\n        # Only a light test of this pathway; e.g. doesn't test that\n        # the limit gets reset after 24 hours\n        self.login(\"iago\")\n        invitee_emails = \"1@zulip.com, 2@zulip.com\"\n        self.invite(invitee_emails, [\"Denmark\"])\n        invitee_emails = \", \".join(str(i) for i in range(get_realm(\"zulip\").max_invites - 1))\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"To protect users, Zulip limits the number of invitations you can send in one day. Because you have reached the limit, no invitations were sent.\",\n        )\n\n    def test_missing_or_invalid_params(self) -> None:\n        \"\"\"\n        Tests inviting with various missing or invalid parameters.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        self.login(\"hamlet\")\n        invitee_emails = \"foo@zulip.com\"\n        self.assert_json_error(\n            self.invite(invitee_emails, []),\n            \"You must specify at least one stream for invitees to join.\",\n        )\n\n        for address in (\"noatsign.com\", \"outsideyourdomain@example.net\"):\n            self.assert_json_error(\n                self.invite(address, [\"Denmark\"]),\n                \"Some emails did not validate, so we didn't send any invitations.\",\n            )\n        self.check_sent_emails([])\n\n        self.assert_json_error(\n            self.invite(\"\", [\"Denmark\"]), \"You must specify at least one email address.\"\n        )\n        self.check_sent_emails([])\n\n    def test_guest_user_invitation(self) -> None:\n        \"\"\"\n        Guest user can't invite new users\n        \"\"\"\n        self.login(\"polonius\")\n        invitee = \"alice-test@zulip.com\"\n        self.assert_json_error(self.invite(invitee, [\"Denmark\"]), \"Not allowed for guest users\")\n        self.assertEqual(find_key_by_email(invitee), None)\n        self.check_sent_emails([])\n\n    def test_invalid_stream(self) -> None:\n        \"\"\"\n        Tests inviting to a non-existent stream.\n        \"\"\"\n        self.login(\"hamlet\")\n        self.assert_json_error(\n            self.invite(\"iago-test@zulip.com\", [\"NotARealStream\"]),\n            f\"Stream does not exist with id: {self.INVALID_STREAM_ID}. No invites were sent.\",\n        )\n        self.check_sent_emails([])\n\n    def test_invite_existing_user(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        self.login(\"hamlet\")\n\n        hamlet_email = \"hAmLeT@zUlIp.com\"\n        result = self.invite(hamlet_email, [\"Denmark\"])\n        self.assert_json_error(result, \"We weren't able to invite anyone.\")\n\n        self.assertFalse(\n            PreregistrationUser.objects.filter(email__iexact=hamlet_email).exists(),\n        )\n        self.check_sent_emails([])\n\n    def normalize_string(self, s: str) -> str:\n        s = s.strip()\n        return re.sub(r\"\\s+\", \" \", s)\n\n    def test_invite_links_in_name(self) -> None:\n        \"\"\"\n        If you invite an address already using Zulip, no invitation is sent.\n        \"\"\"\n        hamlet = self.example_user(\"hamlet\")\n        self.login_user(hamlet)\n        # Test we properly handle links in user full names\n        do_change_full_name(hamlet, \"</a> https://www.google.com\", hamlet)\n\n        result = self.invite(\"newuser@zulip.com\", [\"Denmark\"])\n        self.assert_json_success(result)\n        self.check_sent_emails([\"newuser@zulip.com\"])\n        from django.core.mail import outbox\n\n        body = self.normalize_string(outbox[0].alternatives[0][0])\n\n        # Verify that one can't get Zulip to send invitation emails\n        # that third-party products will linkify using the full_name\n        # field, because we've included that field inside the mailto:\n        # link for the sender.\n        self.assertIn(\n            '<a href=\"mailto:hamlet@zulip.com\" style=\"color:#5f5ec7; text-decoration:underline\">&lt;/a&gt; https://www.google.com (hamlet@zulip.com)</a> wants',\n            body,\n        )\n\n        # TODO: Ideally, this test would also test the Invitation\n        # Reminder email generated, but the test setup for that is\n        # annoying.\n\n    def test_invite_some_existing_some_new(self) -> None:\n        \"\"\"\n        If you invite a mix of already existing and new users, invitations are\n        only sent to the new users.\n        \"\"\"\n        self.login(\"hamlet\")\n        existing = [self.example_email(\"hamlet\"), \"othello@zulip.com\"]\n        new = [\"foo-test@zulip.com\", \"bar-test@zulip.com\"]\n        invitee_emails = \"\\n\".join(existing + new)\n        self.assert_json_error(\n            self.invite(invitee_emails, [\"Denmark\"]),\n            \"Some of those addresses are already using Zulip, \\\nso we didn't send them an invitation. We did send invitations to everyone else!\",\n        )\n\n        # We only created accounts for the new users.\n        for email in existing:\n            self.assertRaises(\n                PreregistrationUser.DoesNotExist,\n                lambda: PreregistrationUser.objects.get(email=email),\n            )\n        for email in new:\n            self.assertTrue(PreregistrationUser.objects.get(email=email))\n\n        # We only sent emails to the new users.\n        self.check_sent_emails(new)\n\n        prereg_user = PreregistrationUser.objects.get(email=\"foo-test@zulip.com\")\n        self.assertEqual(prereg_user.email, \"foo-test@zulip.com\")\n\n    def test_invite_outside_domain_in_closed_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = True`, you can't invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_using_disposable_email(self) -> None:\n        \"\"\"\n        In a realm with `disallow_disposable_email_addresses = True`, you can't invite\n        people with a disposable domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_error(\n            self.invite(external_address, [\"Denmark\"]),\n            \"Some emails did not validate, so we didn't send any invitations.\",\n        )\n\n    def test_invite_outside_domain_in_open_realm(self) -> None:\n        \"\"\"\n        In a realm with `emails_restricted_to_domains = False`, you can invite people\n        with a different domain from that of the realm or your e-mail address.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n    def test_invite_outside_domain_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a different domain from that of the realm\n        when `emails_restricted_to_domains = False`, but `emails_restricted_to_domains` later\n        changes to true, the invitation should succeed but the invitee's signup\n        attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@example.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@example.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"only allows users with email addresses\", result)\n\n    def test_disposable_emails_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with a disposable email when\n        `disallow_disposable_email_addresses = False`, but\n        later changes to true, the invitation should succeed\n        but the invitee's signup attempt should fail.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.disallow_disposable_email_addresses = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo@mailnator.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.disallow_disposable_email_addresses = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(\"foo@mailnator.com\", \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"Please sign up using a real email address.\", result)\n\n    def test_invite_with_email_containing_plus_before_closing(self) -> None:\n        \"\"\"\n        If you invite someone with an email containing plus when\n        `emails_restricted_to_domains = False`, but later change\n        `emails_restricted_to_domains = True`, the invitation should\n        succeed but the invitee's signup attempt should fail as\n        users are not allowed to sign up using email containing +\n        when the realm is restricted to domain.\n        \"\"\"\n        zulip_realm = get_realm(\"zulip\")\n        zulip_realm.emails_restricted_to_domains = False\n        zulip_realm.save()\n\n        self.login(\"hamlet\")\n        external_address = \"foo+label@zulip.com\"\n\n        self.assert_json_success(self.invite(external_address, [\"Denmark\"]))\n        self.check_sent_emails([external_address])\n\n        zulip_realm.emails_restricted_to_domains = True\n        zulip_realm.save()\n\n        result = self.submit_reg_form_for_user(external_address, \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            \"Zulip Dev, does not allow signups using emails\\n        that contains +\", result\n        )\n\n    def test_invalid_email_check_after_confirming_email(self) -> None:\n        self.login(\"hamlet\")\n        email = \"test@zulip.com\"\n\n        self.assert_json_success(self.invite(email, [\"Denmark\"]))\n\n        obj = Confirmation.objects.get(confirmation_key=find_key_by_email(email))\n        prereg_user = obj.content_object\n        assert prereg_user is not None\n        prereg_user.email = \"invalid.email\"\n        prereg_user.save()\n\n        result = self.submit_reg_form_for_user(email, \"password\")\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\n            \"The email address you are trying to sign up with is not valid\", result\n        )\n\n    def test_invite_with_non_ascii_streams(self) -> None:\n        \"\"\"\n        Inviting someone to streams with non-ASCII characters succeeds.\n        \"\"\"\n        self.login(\"hamlet\")\n        invitee = \"alice-test@zulip.com\"\n\n        stream_name = \"h\u00c3\u00bcmb\u00c3\u00bc\u00c7\u00b5\"\n\n        # Make sure we're subscribed before inviting someone.\n        self.subscribe(self.example_user(\"hamlet\"), stream_name)\n\n        self.assert_json_success(self.invite(invitee, [stream_name]))\n\n    def test_invitation_reminder_email(self) -> None:\n        from django.core.mail import outbox\n\n        # All users belong to zulip realm\n        referrer_name = \"hamlet\"\n        current_user = self.example_user(referrer_name)\n        self.login_user(current_user)\n        invitee_email = self.nonreg_email(\"alice\")\n        self.assert_json_success(self.invite(invitee_email, [\"Denmark\"]))\n        self.assertTrue(find_key_by_email(invitee_email))\n        self.check_sent_emails([invitee_email])\n\n        data = {\"email\": invitee_email, \"referrer_email\": current_user.email}\n        invitee = PreregistrationUser.objects.get(email=data[\"email\"])\n        referrer = self.example_user(referrer_name)\n        validity_in_days = 2\n        link = create_confirmation_link(\n            invitee, Confirmation.INVITATION, validity_in_days=validity_in_days\n        )\n        context = common_context(referrer)\n        context.update(\n            activate_url=link,\n            referrer_name=referrer.full_name,\n            referrer_email=referrer.email,\n            referrer_realm_name=referrer.realm.name,\n        )\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now()\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n        email_count = len(outbox)\n        for job in email_jobs_to_deliver:\n            deliver_scheduled_emails(job)\n        self.assert_length(outbox, email_count + 1)\n        self.assertEqual(self.email_envelope_from(outbox[-1]), settings.NOREPLY_EMAIL_ADDRESS)\n        self.assertIn(FromAddress.NOREPLY, self.email_display_from(outbox[-1]))\n\n        # Now verify that signing up clears invite_reminder emails\n        with self.settings(EMAIL_BACKEND=\"django.core.mail.backends.console.EmailBackend\"):\n            email = data[\"email\"]\n            send_future_email(\n                \"zerver/emails/invitation_reminder\",\n                referrer.realm,\n                to_emails=[email],\n                from_address=FromAddress.no_reply_placeholder,\n                context=context,\n            )\n\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 1)\n\n        self.register(invitee_email, \"test\")\n        email_jobs_to_deliver = ScheduledEmail.objects.filter(\n            scheduled_timestamp__lte=timezone_now(), type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assert_length(email_jobs_to_deliver, 0)\n\n    def test_no_invitation_reminder_when_link_expires_quickly(self) -> None:\n        self.login(\"hamlet\")\n        # Check invitation reminder email is scheduled with 4 day link expiry\n        self.invite(\"alice@zulip.com\", [\"Denmark\"], invite_expires_in_days=4)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(type=ScheduledEmail.INVITATION_REMINDER).count(), 1\n        )\n        # Check invitation reminder email is not scheduled with 3 day link expiry\n        self.invite(\"bob@zulip.com\", [\"Denmark\"], invite_expires_in_days=3)\n        self.assertEqual(\n            ScheduledEmail.objects.filter(type=ScheduledEmail.INVITATION_REMINDER).count(), 1\n        )\n\n    # make sure users can't take a valid confirmation key from another\n    # pathway and use it with the invitation URL route\n    def test_confirmation_key_of_wrong_type(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = url.split(\"/\")[-1]\n\n        # Mainly a test of get_object_from_key, rather than of the invitation pathway\n        with self.assertRaises(ConfirmationKeyException) as cm:\n            get_object_from_key(registration_key, Confirmation.INVITATION)\n        self.assertEqual(cm.exception.error_type, ConfirmationKeyException.DOES_NOT_EXIST)\n\n        # Verify that using the wrong type doesn't work in the main confirm code path\n        email_change_url = create_confirmation_link(prereg_user, Confirmation.EMAIL_CHANGE)\n        email_change_key = email_change_url.split(\"/\")[-1]\n        result = self.client_post(\"/accounts/register/\", {\"key\": email_change_key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", result\n        )\n\n    def test_confirmation_expired(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        date_sent = timezone_now() - datetime.timedelta(weeks=3)\n        with patch(\"confirmation.models.timezone_now\", return_value=date_sent):\n            url = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        key = url.split(\"/\")[-1]\n        confirmation_link_path = \"/\" + url.split(\"/\", 3)[3]\n        # Both the confirmation link and submitting the key to the registration endpoint\n        # directly will return the appropriate error.\n        result = self.client_get(confirmation_link_path)\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n        result = self.client_post(\"/accounts/register/\", {\"key\": key})\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. The confirmation link has expired or been deactivated.\", result\n        )\n\n    def test_send_more_than_one_invite_to_same_user(self) -> None:\n        self.user_profile = self.example_user(\"iago\")\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, self.user_profile.realm))\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        prereg_user = PreregistrationUser.objects.get(email=\"foo@zulip.com\")\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_invite_users(\n            self.user_profile,\n            [\"foo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n\n        # Also send an invite from a different realm.\n        lear = get_realm(\"lear\")\n        lear_user = self.lear_user(\"cordelia\")\n        do_invite_users(\n            lear_user, [\"foo@zulip.com\"], [], invite_expires_in_days=invite_expires_in_days\n        )\n\n        invites = PreregistrationUser.objects.filter(email__iexact=\"foo@zulip.com\")\n        self.assert_length(invites, 4)\n\n        do_create_user(\n            \"foo@zulip.com\",\n            \"password\",\n            self.user_profile.realm,\n            \"full name\",\n            prereg_user=prereg_user,\n            acting_user=None,\n        )\n\n        accepted_invite = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_ACTIVE\n        )\n        revoked_invites = PreregistrationUser.objects.filter(\n            email__iexact=\"foo@zulip.com\", status=confirmation_settings.STATUS_REVOKED\n        )\n        # If a user was invited more than once, when it accepts one invite and register\n        # the others must be canceled.\n        self.assert_length(accepted_invite, 1)\n        self.assertEqual(accepted_invite[0].id, prereg_user.id)\n\n        expected_revoked_invites = set(invites.exclude(id=prereg_user.id).exclude(realm=lear))\n        self.assertEqual(set(revoked_invites), expected_revoked_invites)\n\n        self.assertEqual(\n            PreregistrationUser.objects.get(email__iexact=\"foo@zulip.com\", realm=lear).status, 0\n        )\n\n    def test_confirmation_obj_not_exist_error(self) -> None:\n        \"\"\"Since the key is a param input by the user to the registration endpoint,\n        if it inserts an invalid value, the confirmation object won't be found. This\n        tests if, in that scenario, we handle the exception by redirecting the user to\n        the confirmation_link_expired_error page.\n        \"\"\"\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n\n        registration_key = \"invalid_confirmation_key\"\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_nme\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 404)\n        self.assert_in_response(\n            \"Whoops. We couldn't find your confirmation link in the system.\", response\n        )\n\n        registration_key = confirmation_link.split(\"/\")[-1]\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_nme\": \"alice\"}\n        )\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], response)\n        response = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(response.status_code, 302)\n\n    def test_validate_email_not_already_in_realm(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n        inviter = self.example_user(\"iago\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.submit_reg_form_for_user(email, password, key=registration_key)\n\n        url = \"/accounts/register/\"\n        response = self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(\n            response.url,\n            reverse(\"login\") + \"?\" + urlencode({\"email\": email, \"already_registered\": 1}),\n        )\n\n    def test_confirmation_link_in_manual_license_plan(self) -> None:\n        inviter = self.example_user(\"iago\")\n        realm = get_realm(\"zulip\")\n\n        email = self.nonreg_email(\"alice\")\n        realm = get_realm(\"zulip\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(\n            url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"alice\"}\n        )\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assertEqual(response.status_code, 302)\n        self.assertEqual(response.url, \"http://zulip.testserver/\")\n\n        self.subscribe_realm_to_monthly_plan_on_manual_license_management(realm, 5, 5)\n\n        email = self.nonreg_email(\"bob\")\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n        url = \"/accounts/register/\"\n        self.client_post(url, {\"key\": registration_key, \"from_confirmation\": 1, \"full_name\": \"bob\"})\n        response = self.submit_reg_form_for_user(email, \"password\", key=registration_key)\n        self.assert_in_success_response(\n            [\"New members cannot join this organization because all Zulip licenses are\"], response\n        )\n\n\nclass InvitationsTestCase(InviteUserBase):\n    def test_do_get_user_invites(self) -> None:\n        user_profile = self.example_user(\"iago\")\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_invite_users(\n            user_profile,\n            [\"TestTwo@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_invite_users(\n            hamlet, [\"TestThree@zulip.com\"], streams, invite_expires_in_days=invite_expires_in_days\n        )\n        do_invite_users(\n            othello, [\"TestFour@zulip.com\"], streams, invite_expires_in_days=invite_expires_in_days\n        )\n        do_invite_users(\n            self.mit_user(\"sipbtest\"),\n            [\"TestOne@mit.edu\"],\n            [],\n            invite_expires_in_days=invite_expires_in_days,\n        )\n        do_create_multiuse_invite_link(\n            user_profile, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_days\n        )\n        self.assert_length(do_get_user_invites(user_profile), 5)\n        self.assert_length(do_get_user_invites(hamlet), 1)\n        self.assert_length(do_get_user_invites(othello), 1)\n\n    def test_successful_get_open_invitations(self) -> None:\n        \"\"\"\n        A GET call to /json/invites returns all unexpired invitations.\n        \"\"\"\n        active_value = getattr(confirmation_settings, \"STATUS_ACTIVE\", \"Wrong\")\n        self.assertNotEqual(active_value, \"Wrong\")\n\n        self.login(\"iago\")\n        user_profile = self.example_user(\"iago\")\n        self.login_user(user_profile)\n\n        hamlet = self.example_user(\"hamlet\")\n        othello = self.example_user(\"othello\")\n\n        streams = []\n        for stream_name in [\"Denmark\", \"Scotland\"]:\n            streams.append(get_stream(stream_name, user_profile.realm))\n\n        invite_expires_in_days = 2\n        do_invite_users(\n            user_profile,\n            [\"TestOne@zulip.com\"],\n            streams,\n            invite_expires_in_days=invite_expires_in_days,\n        )\n\n        with patch(\n            \"confirmation.models.timezone_now\",\n            return_value=timezone_now() - datetime.timedelta(days=invite_expires_in_days + 1),\n        ):\n            do_invite_users(\n                user_profile,\n                [\"TestTwo@zulip.com\"],\n                streams,\n                invite_expires_in_days=invite_expires_in_days,\n            )\n            do_create_multiuse_invite_link(\n                othello, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_days\n            )\n\n        prereg_user_three = PreregistrationUser(\n            email=\"TestThree@zulip.com\", referred_by=user_profile, status=active_value\n        )\n        prereg_user_three.save()\n        create_confirmation_link(\n            prereg_user_three, Confirmation.INVITATION, validity_in_days=invite_expires_in_days\n        )\n\n        do_create_multiuse_invite_link(\n            hamlet, PreregistrationUser.INVITE_AS[\"MEMBER\"], invite_expires_in_days\n        )\n\n        result = self.client_get(\"/json/invites\")\n        self.assertEqual(result.status_code, 200)\n        invites = orjson.loads(result.content)[\"invites\"]\n        self.assert_length(invites, 2)\n\n        self.assertFalse(invites[0][\"is_multiuse\"])\n        self.assertEqual(invites[0][\"email\"], \"TestOne@zulip.com\")\n        self.assertTrue(invites[1][\"is_multiuse\"])\n        self.assertEqual(invites[1][\"invited_by_user_id\"], hamlet.id)\n\n    def test_successful_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        self.login(\"iago\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify that the scheduled email exists.\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_successful_member_delete_invitation(self) -> None:\n        \"\"\"\n        A DELETE call from member account to /json/invites/<ID> should delete the invite and\n        any scheduled invitation reminder emails.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.login_user(user_profile)\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n\n        # Verify that the scheduled email exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify another non-admin can't delete\n        result = self.api_delete(\n            self.example_user(\"othello\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n        # Verify that the scheduled email still exists.\n        prereg_user = PreregistrationUser.objects.get(email=invitee, referred_by=user_profile)\n        ScheduledEmail.objects.get(address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER)\n\n        # Verify deletion works.\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assertEqual(result.status_code, 200)\n\n        result = self.api_delete(user_profile, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n        owner = self.example_user(\"desdemona\")\n\n        invitee = \"DeleteMe@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        result = self.api_delete(\n            self.example_user(\"iago\"), \"/api/v1/invites/\" + str(prereg_user.id)\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_success(result)\n        result = self.api_delete(owner, \"/api/v1/invites/\" + str(prereg_user.id))\n        self.assert_json_error(result, \"No such invitation\")\n        self.assertRaises(\n            ScheduledEmail.DoesNotExist,\n            lambda: ScheduledEmail.objects.get(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ),\n        )\n\n    def test_delete_multiuse_invite(self) -> None:\n        \"\"\"\n        A DELETE call to /json/invites/multiuse<ID> should delete the\n        multiuse_invite.\n        \"\"\"\n        self.login(\"iago\")\n\n        zulip_realm = get_realm(\"zulip\")\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"hamlet\"), realm=zulip_realm\n        )\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assertEqual(result.status_code, 200)\n        self.assertIsNone(MultiuseInvite.objects.filter(id=multiuse_invite.id).first())\n        # Test that trying to double-delete fails\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        # Test deleting owner mutiuse_invite.\n        multiuse_invite = MultiuseInvite.objects.create(\n            referred_by=self.example_user(\"desdemona\"),\n            realm=zulip_realm,\n            invited_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"],\n        )\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_invite, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        error_result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_delete(\"/json/invites/multiuse/\" + str(multiuse_invite.id))\n        self.assert_json_success(result)\n        self.assertIsNone(MultiuseInvite.objects.filter(id=multiuse_invite.id).first())\n\n        # Test deleting multiuse invite from another realm\n        mit_realm = get_realm(\"zephyr\")\n        multiuse_invite_in_mit = MultiuseInvite.objects.create(\n            referred_by=self.mit_user(\"sipbtest\"), realm=mit_realm\n        )\n        validity_in_days = 2\n        create_confirmation_link(\n            multiuse_invite_in_mit, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n        )\n        error_result = self.client_delete(\n            \"/json/invites/multiuse/\" + str(multiuse_invite_in_mit.id)\n        )\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_successful_resend_invitation(self) -> None:\n        \"\"\"\n        A POST call to /json/invites/<ID>/resend should send an invitation reminder email\n        and delete any scheduled invitation reminder email.\n        \"\"\"\n        self.login(\"iago\")\n        invitee = \"resend_me@zulip.com\"\n\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n    def test_successful_member_resend_invitation(self) -> None:\n        \"\"\"A POST call from member a account to /json/invites/<ID>/resend\n        should send an invitation reminder email and delete any\n        scheduled invitation reminder email if they send the invite.\n        \"\"\"\n        self.login(\"hamlet\")\n        user_profile = self.example_user(\"hamlet\")\n        invitee = \"resend_me@zulip.com\"\n        self.assert_json_success(self.invite(invitee, [\"Denmark\"]))\n        # Verify hamlet has only one invitation (Member can resend invitations only sent by him).\n        invitation = PreregistrationUser.objects.filter(referred_by=user_profile)\n        self.assert_length(invitation, 1)\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n\n        # Verify and then clear from the outbox the original invite email\n        self.check_sent_emails([invitee])\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n        # Verify that the scheduled email exists.\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Resend invite\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n        self.assertEqual(result.status_code, 200)\n        error_result = self.client_post(\"/json/invites/\" + str(9999) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n\n        self.check_sent_emails([invitee])\n\n        self.logout()\n        self.login(\"othello\")\n        invitee = \"TestOne@zulip.com\"\n        prereg_user_one = PreregistrationUser(email=invitee, referred_by=user_profile)\n        prereg_user_one.save()\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization administrator\")\n\n    def test_resend_owner_invitation(self) -> None:\n        self.login(\"desdemona\")\n\n        invitee = \"resend_owner@zulip.com\"\n        self.assert_json_success(\n            self.invite(\n                invitee, [\"Denmark\"], invite_as=PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]\n            )\n        )\n        self.check_sent_emails([invitee])\n        scheduledemail_filter = ScheduledEmail.objects.filter(\n            address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n        )\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        original_timestamp = scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n\n        # Test only organization owners can resend owner invitation.\n        self.login(\"iago\")\n        prereg_user = PreregistrationUser.objects.get(email=invitee)\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_success(result)\n\n        self.assertEqual(\n            ScheduledEmail.objects.filter(\n                address__iexact=invitee, type=ScheduledEmail.INVITATION_REMINDER\n            ).count(),\n            1,\n        )\n\n        # Check that we have exactly one scheduled email, and that it is different\n        self.assertEqual(scheduledemail_filter.count(), 1)\n        self.assertNotEqual(\n            original_timestamp, scheduledemail_filter.values_list(\"scheduled_timestamp\", flat=True)\n        )\n\n    def test_accessing_invites_in_another_realm(self) -> None:\n        inviter = UserProfile.objects.exclude(realm=get_realm(\"zulip\")).first()\n        assert inviter is not None\n        prereg_user = PreregistrationUser.objects.create(\n            email=\"email\", referred_by=inviter, realm=inviter.realm\n        )\n        self.login(\"iago\")\n        error_result = self.client_post(\"/json/invites/\" + str(prereg_user.id) + \"/resend\")\n        self.assert_json_error(error_result, \"No such invitation\")\n        error_result = self.client_delete(\"/json/invites/\" + str(prereg_user.id))\n        self.assert_json_error(error_result, \"No such invitation\")\n\n    def test_prereg_user_status(self) -> None:\n        email = self.nonreg_email(\"alice\")\n        password = \"password\"\n        realm = get_realm(\"zulip\")\n\n        inviter = UserProfile.objects.filter(realm=realm).first()\n        prereg_user = PreregistrationUser.objects.create(\n            email=email, referred_by=inviter, realm=realm\n        )\n\n        confirmation_link = create_confirmation_link(prereg_user, Confirmation.USER_REGISTRATION)\n        registration_key = confirmation_link.split(\"/\")[-1]\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"key\": registration_key, \"from_confirmation\": \"1\", \"full_name\": \"alice\"},\n        )\n        self.assertEqual(result.status_code, 200)\n        confirmation = Confirmation.objects.get(confirmation_key=registration_key)\n        assert confirmation.content_object is not None\n        prereg_user = confirmation.content_object\n        self.assertEqual(prereg_user.status, 0)\n\n        result = self.submit_reg_form_for_user(email, password, key=registration_key)\n        self.assertEqual(result.status_code, 302)\n        prereg_user = PreregistrationUser.objects.get(email=email, referred_by=inviter, realm=realm)\n        self.assertEqual(prereg_user.status, confirmation_settings.STATUS_ACTIVE)\n        user = get_user_by_delivery_email(email, realm)\n        self.assertIsNotNone(user)\n        self.assertEqual(user.delivery_email, email)\n\n\nclass InviteeEmailsParserTests(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.email1 = \"email1@zulip.com\"\n        self.email2 = \"email2@zulip.com\"\n        self.email3 = \"email3@zulip.com\"\n\n    def test_if_emails_separated_by_commas_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1} ,{self.email2}, {self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_separated_by_newlines_are_parsed_and_striped_correctly(self) -> None:\n        emails_raw = f\"{self.email1}\\n {self.email2}\\n {self.email3} \"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_from_email_client_separated_by_newlines_are_parsed_correctly(self) -> None:\n        emails_raw = (\n            f\"Email One <{self.email1}>\\nEmailTwo<{self.email2}>\\nEmail Three<{self.email3}>\"\n        )\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n    def test_if_emails_in_mixed_style_are_parsed_correctly(self) -> None:\n        emails_raw = f\"Email One <{self.email1}>,EmailTwo<{self.email2}>\\n{self.email3}\"\n        expected_set = {self.email1, self.email2, self.email3}\n        self.assertEqual(get_invitee_emails_set(emails_raw), expected_set)\n\n\nclass MultiuseInviteTest(ZulipTestCase):\n    def setUp(self) -> None:\n        super().setUp()\n        self.realm = get_realm(\"zulip\")\n        self.realm.invite_required = True\n        self.realm.save()\n\n    def generate_multiuse_invite_link(\n        self, streams: Optional[List[Stream]] = None, date_sent: Optional[datetime.datetime] = None\n    ) -> str:\n        invite = MultiuseInvite(realm=self.realm, referred_by=self.example_user(\"iago\"))\n        invite.save()\n\n        if streams is not None:\n            invite.streams.set(streams)\n\n        if date_sent is None:\n            date_sent = timezone_now()\n        validity_in_days = 2\n        with patch(\"confirmation.models.timezone_now\", return_value=date_sent):\n            return create_confirmation_link(\n                invite, Confirmation.MULTIUSE_INVITE, validity_in_days=validity_in_days\n            )\n\n    def check_user_able_to_register(self, email: str, invite_link: str) -> None:\n        password = \"password\"\n\n        result = self.client_post(invite_link, {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_valid_multiuse_link(self) -> None:\n        email1 = self.nonreg_email(\"test\")\n        email2 = self.nonreg_email(\"test1\")\n        email3 = self.nonreg_email(\"alice\")\n\n        validity_in_days = 2\n        date_sent = timezone_now() - datetime.timedelta(days=validity_in_days - 1)\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_able_to_register(email3, invite_link)\n\n    def test_expired_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        date_sent = timezone_now() - datetime.timedelta(\n            days=settings.INVITATION_LINK_VALIDITY_DAYS + 1\n        )\n        invite_link = self.generate_multiuse_invite_link(date_sent=date_sent)\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"The confirmation link has expired or been deactivated.\", result)\n\n    def test_invalid_multiuse_link(self) -> None:\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n        result = self.client_post(invite_link, {\"email\": email})\n\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"Whoops. The confirmation link is malformed.\", result)\n\n    def test_invalid_multiuse_link_in_open_realm(self) -> None:\n        self.realm.invite_required = False\n        self.realm.save()\n\n        email = self.nonreg_email(\"newuser\")\n        invite_link = \"/join/invalid_key/\"\n\n        with patch(\"zerver.views.registration.get_realm_from_request\", return_value=self.realm):\n            with patch(\"zerver.views.registration.get_realm\", return_value=self.realm):\n                self.check_user_able_to_register(email, invite_link)\n\n    def test_multiuse_link_with_specified_streams(self) -> None:\n        name1 = \"newuser\"\n        name2 = \"bob\"\n        email1 = self.nonreg_email(name1)\n        email2 = self.nonreg_email(name2)\n\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email1, invite_link)\n        self.check_user_subscribed_only_to_streams(name1, streams)\n\n        stream_names = [\"Rome\", \"Verona\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        invite_link = self.generate_multiuse_invite_link(streams=streams)\n        self.check_user_able_to_register(email2, invite_link)\n        self.check_user_subscribed_only_to_streams(name2, streams)\n\n    def test_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n\n        result = self.client_post(\"/json/invites/multiuse\", {\"invite_expires_in_days\": 2})\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_with_specified_streams_api_call(self) -> None:\n        self.login(\"iago\")\n        stream_names = [\"Rome\", \"Scotland\", \"Venice\"]\n        streams = [get_stream(stream_name, self.realm) for stream_name in stream_names]\n        stream_ids = [stream.id for stream in streams]\n\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\"stream_ids\": orjson.dumps(stream_ids).decode(), \"invite_expires_in_days\": 2},\n        )\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n        self.check_user_subscribed_only_to_streams(\"test\", streams)\n\n    def test_only_admin_can_create_multiuse_link_api_call(self) -> None:\n        self.login(\"iago\")\n        # Only admins should be able to create multiuse invites even if\n        # invite_to_realm_policy is set to Realm.POLICY_MEMBERS_ONLY.\n        self.realm.invite_to_realm_policy = Realm.POLICY_MEMBERS_ONLY\n        self.realm.save()\n\n        result = self.client_post(\"/json/invites/multiuse\", {\"invite_expires_in_days\": 2})\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n        self.login(\"hamlet\")\n        result = self.client_post(\"/json/invites/multiuse\")\n        self.assert_json_error(result, \"Must be an organization administrator\")\n\n    def test_multiuse_link_for_inviting_as_owner(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_days\": 2,\n            },\n        )\n        self.assert_json_error(result, \"Must be an organization owner\")\n\n        self.login(\"desdemona\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\n                \"invite_as\": orjson.dumps(PreregistrationUser.INVITE_AS[\"REALM_OWNER\"]).decode(),\n                \"invite_expires_in_days\": 2,\n            },\n        )\n        self.assert_json_success(result)\n\n        invite_link = result.json()[\"invite_link\"]\n        self.check_user_able_to_register(self.nonreg_email(\"test\"), invite_link)\n\n    def test_create_multiuse_link_invalid_stream_api_call(self) -> None:\n        self.login(\"iago\")\n        result = self.client_post(\n            \"/json/invites/multiuse\",\n            {\"stream_ids\": orjson.dumps([54321]).decode(), \"invite_expires_in_days\": 2},\n        )\n        self.assert_json_error(result, \"Invalid stream id 54321. No invites were sent.\")\n\n\nclass EmailUnsubscribeTests(ZulipTestCase):\n    def test_error_unsubscribe(self) -> None:\n\n        # An invalid unsubscribe token \"test123\" produces an error.\n        result = self.client_get(\"/accounts/unsubscribe/missed_messages/test123\")\n        self.assert_in_response(\"Unknown email unsubscribe request\", result)\n\n        # An unknown message type \"fake\" produces an error.\n        user_profile = self.example_user(\"hamlet\")\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"fake\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assert_in_response(\"Unknown email unsubscribe request\", result)\n\n    def test_message_notification_emails_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in message notification emails\n        that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.enable_offline_email_notifications = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"missed_messages\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_offline_email_notifications)\n\n    def test_welcome_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in welcome e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        # Simulate a new user signing up, which enqueues 2 welcome e-mails.\n        enqueue_welcome_emails(user_profile)\n        self.assertEqual(2, ScheduledEmail.objects.filter(users=user_profile).count())\n\n        # Simulate unsubscribing from the welcome e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"welcome\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The welcome email jobs are no longer scheduled.\n        self.assertEqual(result.status_code, 200)\n        self.assertEqual(0, ScheduledEmail.objects.filter(users=user_profile).count())\n\n    def test_digest_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in digest e-mails that you can\n        click even when logged out to stop receiving them.\n\n        Unsubscribing from these emails also dequeues any digest email jobs that\n        have been queued.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_digest_emails)\n\n        # Enqueue a fake digest email.\n        context = {\n            \"name\": \"\",\n            \"realm_uri\": \"\",\n            \"unread_pms\": [],\n            \"hot_conversations\": [],\n            \"new_users\": [],\n            \"new_streams\": {\"plain\": []},\n            \"unsubscribe_link\": \"\",\n        }\n        send_future_email(\n            \"zerver/emails/digest\",\n            user_profile.realm,\n            to_user_ids=[user_profile.id],\n            context=context,\n        )\n\n        self.assertEqual(1, ScheduledEmail.objects.filter(users=user_profile).count())\n\n        # Simulate unsubscribing from digest e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"digest\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        # The setting is toggled off, and scheduled jobs have been removed.\n        self.assertEqual(result.status_code, 200)\n        # Circumvent user_profile caching.\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_digest_emails)\n        self.assertEqual(0, ScheduledEmail.objects.filter(users=user_profile).count())\n\n    def test_login_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in login\n        e-mails that you can click even when logged out to update your\n        email notification settings.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.enable_login_emails = True\n        user_profile.save()\n\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"login\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n\n        self.assertEqual(result.status_code, 200)\n\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_login_emails)\n\n    def test_marketing_unsubscribe(self) -> None:\n        \"\"\"\n        We provide one-click unsubscribe links in marketing e-mails that you can\n        click even when logged out to stop receiving them.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_marketing_emails)\n\n        # Simulate unsubscribing from marketing e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"marketing\")\n        result = self.client_get(urllib.parse.urlparse(unsubscribe_link).path)\n        self.assertEqual(result.status_code, 200)\n\n        # Circumvent user_profile caching.\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_marketing_emails)\n\n    def test_marketing_unsubscribe_post(self) -> None:\n        \"\"\"\n        The List-Unsubscribe-Post header lets email clients trigger an\n        automatic unsubscription request via POST (see RFC 8058), so\n        test that too.\n        \"\"\"\n        user_profile = self.example_user(\"hamlet\")\n        self.assertTrue(user_profile.enable_marketing_emails)\n\n        # Simulate unsubscribing from marketing e-mails.\n        unsubscribe_link = one_click_unsubscribe_link(user_profile, \"marketing\")\n        client = Client(enforce_csrf_checks=True)\n        result = client.post(\n            urllib.parse.urlparse(unsubscribe_link).path, {\"List-Unsubscribe\": \"One-Click\"}\n        )\n        self.assertEqual(result.status_code, 200)\n\n        # Circumvent user_profile caching.\n        user_profile.refresh_from_db()\n        self.assertFalse(user_profile.enable_marketing_emails)\n\n\nclass RealmCreationTest(ZulipTestCase):\n    @override_settings(OPEN_REALM_CREATION=True)\n    def check_able_to_create_realm(self, email: str, password: str = \"test\") -> None:\n        internal_realm = get_realm(settings.SYSTEM_BOT_REALM)\n        notification_bot = get_system_bot(settings.NOTIFICATION_BOT, internal_realm.id)\n        signups_stream, _ = create_stream_if_needed(notification_bot.realm, \"signups\")\n\n        string_id = \"zuliptest\"\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Check confirmation email has the correct subject and body, extract\n        # confirmation link and visit it\n        confirmation_url = self.get_confirmation_url_from_outbox(\n            email,\n            email_subject_contains=\"Create your Zulip organization\",\n            email_body_contains=\"You have requested a new Zulip organization\",\n        )\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password, realm_subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(\"http://zuliptest.testserver/accounts/login/subdomain/\")\n        )\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n\n        # Check that user is the owner.\n        self.assertEqual(user.role, UserProfile.ROLE_REALM_OWNER)\n\n        # Check defaults\n        self.assertEqual(realm.org_type, Realm.ORG_TYPES[\"business\"][\"id\"])\n        self.assertEqual(realm.emails_restricted_to_domains, False)\n        self.assertEqual(realm.invite_required, True)\n\n        # Check welcome messages\n        for stream_name, text, message_count in [\n            (Realm.DEFAULT_NOTIFICATION_STREAM_NAME, \"with the topic\", 3),\n            (Realm.INITIAL_PRIVATE_STREAM_NAME, \"private stream\", 1),\n        ]:\n            stream = get_stream(stream_name, realm)\n            recipient = stream.recipient\n            messages = Message.objects.filter(recipient=recipient).order_by(\"date_sent\")\n            self.assert_length(messages, message_count)\n            self.assertIn(text, messages[0].content)\n\n        # Check signup messages\n        recipient = signups_stream.recipient\n        messages = Message.objects.filter(recipient=recipient).order_by(\"id\")\n        self.assert_length(messages, 2)\n        self.assertIn(\"Signups enabled\", messages[0].content)\n        self.assertIn(\"signed up\", messages[1].content)\n        self.assertEqual(\"zuliptest\", messages[1].topic_name())\n\n        realm_creation_audit_log = RealmAuditLog.objects.get(\n            realm=realm, event_type=RealmAuditLog.REALM_CREATED\n        )\n        self.assertEqual(realm_creation_audit_log.acting_user, user)\n        self.assertEqual(realm_creation_audit_log.event_time, realm.date_created)\n\n        # Piggyback a little check for how we handle\n        # empty string_ids.\n        realm.string_id = \"\"\n        self.assertEqual(realm.display_subdomain, \".\")\n\n    def test_create_realm_non_existing_email(self) -> None:\n        self.check_able_to_create_realm(\"user1@test.com\")\n\n    def test_create_realm_existing_email(self) -> None:\n        self.check_able_to_create_realm(\"hamlet@zulip.com\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_create_realm_ldap_email(self) -> None:\n        self.init_default_ldap_database()\n\n        with self.settings(LDAP_EMAIL_ATTR=\"mail\"):\n            self.check_able_to_create_realm(\n                \"newuser_email@zulip.com\", self.ldap_password(\"newuser_with_email\")\n            )\n\n    def test_create_realm_as_system_bot(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"notification-bot@zulip.com\"})\n        self.assertEqual(result.status_code, 200)\n        self.assert_in_response(\"notification-bot@zulip.com is reserved for system bots\", result)\n\n    def test_create_realm_no_creation_key(self) -> None:\n        \"\"\"\n        Trying to create a realm without a creation_key should fail when\n        OPEN_REALM_CREATION is false.\n        \"\"\"\n        email = \"user1@test.com\"\n\n        with self.settings(OPEN_REALM_CREATION=False):\n            # Create new realm with the email, but no creation key.\n            result = self.client_post(\"/new/\", {\"email\": email})\n            self.assertEqual(result.status_code, 200)\n            self.assert_in_response(\"New organization creation disabled\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_subdomain(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=string_id, realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_marketing_emails_enabled(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=True,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertTrue(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_with_marketing_emails_disabled(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Make sure the realm does not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"http://zuliptest.testserver\")\n\n        # Make sure the realm is created\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        user = get_user(email, realm)\n        self.assertEqual(user.realm, realm)\n        self.assertFalse(user.enable_marketing_emails)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_regular_realm_welcome_bot_pm(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the correct Welcome Bot PM is sent\n        welcome_msg = Message.objects.filter(\n            sender__email=\"welcome-bot@zulip.com\", recipient__type=Recipient.PERSONAL\n        ).latest(\"id\")\n        self.assertTrue(welcome_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertNotIn(\"demo organization\", welcome_msg.content)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_demo_realm_welcome_bot_pm(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        # Create new realm with the email\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=string_id,\n            realm_name=realm_name,\n            enable_marketing_emails=False,\n            is_demo_organization=True,\n        )\n        self.assertEqual(result.status_code, 302)\n\n        # Make sure the correct Welcome Bot PM is sent\n        welcome_msg = Message.objects.filter(\n            sender__email=\"welcome-bot@zulip.com\", recipient__type=Recipient.PERSONAL\n        ).latest(\"id\")\n        self.assertTrue(welcome_msg.content.startswith(\"Hello, and welcome to Zulip!\"))\n        self.assertIn(\"demo organization\", welcome_msg.content)\n\n    @override_settings(OPEN_REALM_CREATION=True, FREE_TRIAL_DAYS=30)\n    def test_create_realm_during_free_trial(self) -> None:\n        password = \"test\"\n        string_id = \"zuliptest\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(string_id)\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=string_id, realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assertEqual(result.url, \"http://zuliptest.testserver/upgrade/?onboarding=true\")\n\n        result = self.client_get(result.url, subdomain=string_id)\n        self.assert_in_success_response([\"Not ready to start your trial?\"], result)\n\n        realm = get_realm(string_id)\n        self.assertEqual(realm.string_id, string_id)\n        self.assertEqual(get_user(email, realm).realm, realm)\n\n        self.assertEqual(realm.name, realm_name)\n        self.assertEqual(realm.subdomain, string_id)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_two_realms(self) -> None:\n        \"\"\"\n        Verify correct behavior and PreregistrationUser handling when using\n        two pre-generated realm creation links to create two different realms.\n        \"\"\"\n        password = \"test\"\n        first_string_id = \"zuliptest\"\n        second_string_id = \"zuliptest2\"\n        email = \"user1@test.com\"\n        first_realm_name = \"Test\"\n        second_realm_name = \"Test\"\n\n        # Make sure the realms do not exist\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(first_string_id)\n        with self.assertRaises(Realm.DoesNotExist):\n            get_realm(second_string_id)\n\n        # Now we pre-generate two realm creation links\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        first_confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 1)\n\n        # Get a second realm creation link.\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/new/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        second_confirmation_url = self.get_confirmation_url_from_outbox(email)\n\n        self.assertNotEqual(first_confirmation_url, second_confirmation_url)\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 2)\n\n        # Create and verify the first realm\n        result = self.client_get(first_confirmation_url)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=first_string_id,\n            realm_name=first_realm_name,\n            key=first_confirmation_url.split(\"/\")[-1],\n        )\n        self.assertEqual(result.status_code, 302)\n        # Make sure the realm is created\n        realm = get_realm(first_string_id)\n        self.assertEqual(realm.string_id, first_string_id)\n        self.assertEqual(realm.name, first_realm_name)\n\n        # One of the PreregistrationUsers should have been used up:\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 1)\n\n        # Create and verify the second realm\n        result = self.client_get(second_confirmation_url)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=second_string_id,\n            realm_name=second_realm_name,\n            key=second_confirmation_url.split(\"/\")[-1],\n        )\n        self.assertEqual(result.status_code, 302)\n        # Make sure the realm is created\n        realm = get_realm(second_string_id)\n        self.assertEqual(realm.string_id, second_string_id)\n        self.assertEqual(realm.name, second_realm_name)\n\n        # The remaining PreregistrationUser should have been used up:\n        self.assertEqual(PreregistrationUser.objects.filter(email=email, status=0).count(), 0)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_mailinator_signup(self) -> None:\n        result = self.client_post(\"/new/\", {\"email\": \"hi@mailinator.com\"})\n        self.assert_in_response(\"Please use your real email address.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        errors = {\n            \"id\": \"length 3 or greater\",\n            \"-id\": \"cannot start or end with a\",\n            \"string-ID\": \"lowercase letters\",\n            \"string_id\": \"lowercase letters\",\n            \"stream\": \"unavailable\",\n            \"streams\": \"unavailable\",\n            \"about\": \"unavailable\",\n            \"abouts\": \"unavailable\",\n            \"zephyr\": \"unavailable\",\n        }\n        for string_id, error_msg in errors.items():\n            result = self.submit_reg_form_for_user(\n                email, password, realm_subdomain=string_id, realm_name=realm_name\n            )\n            self.assert_in_response(error_msg, result)\n\n        # test valid subdomain\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"a-0\", realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.startswith(\"http://a-0.testserver/accounts/login/subdomain/\"))\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_create_realm_using_old_subdomain_of_a_realm(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_change_realm_subdomain(realm, \"new-name\", acting_user=None)\n\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"zulip\", realm_name=realm_name\n        )\n        self.assert_in_response(\"Subdomain unavailable. Please choose a different one.\", result)\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(\n                email, password, realm_subdomain=\"\", realm_name=realm_name\n            )\n            self.assert_in_response(\"unavailable\", result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(\n            email, password, realm_subdomain=\"\", realm_name=realm_name\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.startswith(\"http://testserver/accounts/login/subdomain/\"))\n\n    @override_settings(OPEN_REALM_CREATION=True)\n    def test_subdomain_restrictions_root_domain_option(self) -> None:\n        password = \"test\"\n        email = \"user1@test.com\"\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n\n        # test root domain will fail with ROOT_DOMAIN_LANDING_PAGE\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                realm_subdomain=\"abcdef\",\n                realm_in_root_domain=\"true\",\n                realm_name=realm_name,\n            )\n            self.assert_in_response(\"unavailable\", result)\n\n        # test valid use of root domain\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            realm_subdomain=\"abcdef\",\n            realm_in_root_domain=\"true\",\n            realm_name=realm_name,\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result.url.startswith(\"http://testserver/accounts/login/subdomain/\"))\n\n    def test_is_root_domain_available(self) -> None:\n        self.assertTrue(is_root_domain_available())\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            self.assertFalse(is_root_domain_available())\n        realm = get_realm(\"zulip\")\n        realm.string_id = Realm.SUBDOMAIN_FOR_ROOT_DOMAIN\n        realm.save()\n        self.assertFalse(is_root_domain_available())\n\n    def test_subdomain_check_api(self) -> None:\n        result = self.client_get(\"/json/realm/subdomain/zulip\")\n        self.assert_in_success_response(\n            [\"Subdomain unavailable. Please choose a different one.\"], result\n        )\n\n        result = self.client_get(\"/json/realm/subdomain/zu_lip\")\n        self.assert_in_success_response(\n            [\"Subdomain can only have lowercase letters, numbers, and '-'s.\"], result\n        )\n\n        with self.settings(SOCIAL_AUTH_SUBDOMAIN=\"zulipauth\"):\n            result = self.client_get(\"/json/realm/subdomain/zulipauth\")\n            self.assert_in_success_response(\n                [\"Subdomain unavailable. Please choose a different one.\"], result\n            )\n\n        result = self.client_get(\"/json/realm/subdomain/hufflepuff\")\n        self.assert_in_success_response([\"available\"], result)\n        self.assert_not_in_success_response([\"unavailable\"], result)\n\n    def test_subdomain_check_management_command(self) -> None:\n        # Short names should not work, even with the flag\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"aa\")\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"aa\", allow_reserved_subdomain=True)\n\n        # Malformed names should never work\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"-ba_d-\")\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"-ba_d-\", allow_reserved_subdomain=True)\n\n        with patch(\"zerver.lib.name_restrictions.is_reserved_subdomain\", return_value=False):\n            # Existing realms should never work even if they are not reserved keywords\n            with self.assertRaises(ValidationError):\n                check_subdomain_available(\"zulip\")\n            with self.assertRaises(ValidationError):\n                check_subdomain_available(\"zulip\", allow_reserved_subdomain=True)\n\n        # Reserved ones should only work with the flag\n        with self.assertRaises(ValidationError):\n            check_subdomain_available(\"stream\")\n        check_subdomain_available(\"stream\", allow_reserved_subdomain=True)\n\n\nclass UserSignUpTest(InviteUserBase):\n    def _assert_redirected_to(self, result: HttpResponse, url: str) -> None:\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"LOCATION\"], url)\n\n    def verify_signup(\n        self,\n        *,\n        email: str = \"newguy@zulip.com\",\n        password: Optional[str] = \"newpassword\",\n        full_name: str = \"New user's name\",\n        realm: Optional[Realm] = None,\n        subdomain: Optional[str] = None,\n    ) -> Union[UserProfile, HttpResponse]:\n        \"\"\"Common test function for signup tests.  It is a goal to use this\n        common function for all signup tests to avoid code duplication; doing\n        so will likely require adding new parameters.\"\"\"\n\n        if realm is None:  # nocoverage\n            realm = get_realm(\"zulip\")\n\n        client_kwargs: Dict[str, Any] = {}\n        if subdomain:\n            client_kwargs[\"subdomain\"] = subdomain\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, **client_kwargs)\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"], **client_kwargs)\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, **client_kwargs)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS. This should create our\n        # account, log us in, and redirect to the app.\n        result = self.submit_reg_form_for_user(\n            email, password, full_name=full_name, **client_kwargs\n        )\n\n        if result.status_code == 200:\n            # This usually indicated an error returned when submitting the form.\n            # Return the result for the caller to deal with reacting to this, since\n            # in many tests this is expected and the caller wants to assert the content\n            # of the error.\n            return result\n\n        # Verify that we were served a redirect to the app.\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"{realm.uri}/\")\n\n        # Verify that we successfully logged in.\n        user_profile = get_user_by_delivery_email(email, realm)\n        self.assert_logged_in_user_id(user_profile.id)\n        return user_profile\n\n    def test_bad_email_configuration_for_accounts_home(self) -> None:\n        \"\"\"\n        Make sure we redirect for EmailNotDeliveredException.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n\n        smtp_mock = patch(\n            \"zerver.views.registration.send_confirm_registration_email\",\n            side_effect=EmailNotDeliveredException,\n        )\n\n        with smtp_mock, self.assertLogs(level=\"ERROR\") as m:\n            result = self.client_post(\"/accounts/home/\", {\"email\": email})\n\n        self._assert_redirected_to(result, \"/config-error/smtp\")\n        self.assertEqual(m.output, [\"ERROR:root:Error in accounts_home\"])\n\n    def test_bad_email_configuration_for_create_realm(self) -> None:\n        \"\"\"\n        Make sure we redirect for EmailNotDeliveredException.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n\n        smtp_mock = patch(\n            \"zerver.views.registration.send_confirm_registration_email\",\n            side_effect=EmailNotDeliveredException,\n        )\n\n        with smtp_mock, self.assertLogs(level=\"ERROR\") as m:\n            result = self.client_post(\"/new/\", {\"email\": email})\n\n        self._assert_redirected_to(result, \"/config-error/smtp\")\n        self.assertEqual(m.output, [\"ERROR:root:Error in create_realm\"])\n\n    def test_user_default_language_and_timezone(self) -> None:\n        \"\"\"\n        Check if the default language of new user is the default language\n        of the realm.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        timezone = \"US/Mountain\"\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"default_language\", \"de\", acting_user=None)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        # Pick a password and agree to the ToS.\n        result = self.submit_reg_form_for_user(email, password, timezone=timezone)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        self.assertEqual(user_profile.default_language, realm.default_language)\n        self.assertEqual(user_profile.timezone, timezone)\n        from django.core.mail import outbox\n\n        outbox.pop()\n\n    def test_default_twenty_four_hour_time(self) -> None:\n        \"\"\"\n        Check if the default twenty_four_hour_time setting of new user\n        is the default twenty_four_hour_time of the realm.\n        \"\"\"\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        do_set_realm_user_default_setting(\n            realm_user_default, \"twenty_four_hour_time\", True, acting_user=None\n        )\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.submit_reg_form_for_user(email, password)\n        self.assertEqual(result.status_code, 302)\n\n        user_profile = self.nonreg_user(\"newguy\")\n        realm_user_default = RealmUserDefault.objects.get(realm=realm)\n        self.assertEqual(\n            user_profile.twenty_four_hour_time, realm_user_default.twenty_four_hour_time\n        )\n\n    def test_signup_already_active(self) -> None:\n        \"\"\"\n        Check if signing up with an active email redirects to a login page.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result[\"Location\"])\n        result = self.client_get(result.url)\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_system_bot(self) -> None:\n        email = \"notification-bot@zulip.com\"\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=\"lear\")\n        self.assertEqual(result.status_code, 302)\n        self.assertIn(\"login\", result[\"Location\"])\n        result = self.client_get(result.url)\n\n        # This is not really the right error message, but at least it's an error.\n        self.assert_in_response(\"You've already registered\", result)\n\n    def test_signup_existing_email(self) -> None:\n        \"\"\"\n        Check if signing up with an email used in another realm succeeds.\n        \"\"\"\n        email = self.example_email(\"hamlet\")\n        self.verify_signup(email=email, realm=get_realm(\"lear\"), subdomain=\"lear\")\n        self.assertEqual(UserProfile.objects.filter(delivery_email=email).count(), 2)\n\n    def test_signup_invalid_name(self) -> None:\n        \"\"\"\n        Check if an invalid name during signup is handled properly.\n        \"\"\"\n\n        result = self.verify_signup(full_name=\"<invalid>\")\n        self.assert_in_success_response([\"Invalid characters in name!\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response([\"id_password\", \"id_full_name\"], result)\n\n    def test_signup_without_password(self) -> None:\n        \"\"\"\n        Check if signing up without a password works properly when\n        password_auth_enabled is False.\n        \"\"\"\n        email = self.nonreg_email(\"newuser\")\n        with patch(\"zerver.views.registration.password_auth_enabled\", return_value=False):\n            user_profile = self.verify_signup(email=email, password=None)\n\n        assert isinstance(user_profile, UserProfile)\n        # User should now be logged in.\n        self.assert_logged_in_user_id(user_profile.id)\n\n    def test_signup_without_full_name(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n        result = self.verify_signup(email=email, password=password, full_name=\"\")\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n        # Verify that the user is asked for name and password\n        self.assert_in_success_response([\"id_password\", \"id_full_name\"], result)\n\n    def test_signup_email_message_contains_org_header(self) -> None:\n        email = \"newguy@zulip.com\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        from django.core.mail import outbox\n\n        self.assertEqual(outbox[0].extra_headers[\"List-Id\"], \"Zulip Dev <zulip.testserver>\")\n\n    def test_signup_with_full_name(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": password,\n                \"key\": find_key_by_email(email),\n                \"terms\": True,\n                \"full_name\": \"New Guy\",\n                \"from_confirmation\": \"1\",\n            },\n        )\n        self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n    def test_signup_with_weak_password(self) -> None:\n        \"\"\"\n        Check if signing up without a full name redirects to a registration\n        form.\n        \"\"\"\n        email = \"newguy@zulip.com\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        with self.settings(PASSWORD_MIN_LENGTH=6, PASSWORD_MIN_GUESSES=1000):\n            result = self.client_post(\n                \"/accounts/register/\",\n                {\n                    \"password\": \"easy\",\n                    \"key\": find_key_by_email(email),\n                    \"terms\": True,\n                    \"full_name\": \"New Guy\",\n                    \"from_confirmation\": \"1\",\n                },\n            )\n            self.assert_in_success_response([\"We just need you to do one last thing.\"], result)\n\n            result = self.submit_reg_form_for_user(email, \"easy\", full_name=\"New Guy\")\n            self.assert_in_success_response([\"The password is too weak.\"], result)\n            with self.assertRaises(UserProfile.DoesNotExist):\n                # Account wasn't created.\n                get_user(email, get_realm(\"zulip\"))\n\n    def test_signup_with_default_stream_group(self) -> None:\n        # Check if user is subscribed to the streams of default\n        # stream group as well as default streams.\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        default_streams = []\n\n        existing_default_streams = DefaultStream.objects.filter(realm=realm)\n        self.assert_length(existing_default_streams, 1)\n        self.assertEqual(existing_default_streams[0].stream.name, \"Verona\")\n        default_streams.append(existing_default_streams[0].stream)\n\n        for stream_name in [\"venice\", \"rome\"]:\n            stream = get_stream(stream_name, realm)\n            do_add_default_stream(stream)\n            default_streams.append(stream)\n\n        group1_streams = []\n        for stream_name in [\"scotland\", \"denmark\"]:\n            stream = get_stream(stream_name, realm)\n            group1_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 1\", \"group 1 description\", group1_streams)\n\n        result = self.submit_reg_form_for_user(email, password, default_stream_groups=[\"group 1\"])\n        self.check_user_subscribed_only_to_streams(\"newguy\", default_streams + group1_streams)\n\n    def test_signup_two_confirmation_links(self) -> None:\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n        first_confirmation_url = self.get_confirmation_url_from_outbox(email)\n        first_confirmation_key = find_key_by_email(email)\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n        second_confirmation_url = self.get_confirmation_url_from_outbox(email)\n\n        # Sanity check:\n        self.assertNotEqual(first_confirmation_url, second_confirmation_url)\n\n        # Register the account (this will use the second confirmation url):\n        result = self.submit_reg_form_for_user(\n            email, password, full_name=\"New Guy\", from_confirmation=\"1\"\n        )\n        self.assert_in_success_response(\n            [\"We just need you to do one last thing.\", \"New Guy\", email], result\n        )\n        result = self.submit_reg_form_for_user(email, password, full_name=\"New Guy\")\n        user_profile = UserProfile.objects.get(delivery_email=email)\n        self.assertEqual(user_profile.delivery_email, email)\n\n        # Now try to to register using the first confirmation url:\n        result = self.client_get(first_confirmation_url)\n        self.assertEqual(result.status_code, 404)\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": password,\n                \"key\": first_confirmation_key,\n                \"terms\": True,\n                \"full_name\": \"New Guy\",\n                \"from_confirmation\": \"1\",\n            },\n        )\n        # Error page should be displayed\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"The registration link has expired or is not valid.\", result)\n\n    def test_signup_with_multiple_default_stream_groups(self) -> None:\n        # Check if user is subscribed to the streams of default\n        # stream groups as well as default streams.\n        email = self.nonreg_email(\"newguy\")\n        password = \"newpassword\"\n        realm = get_realm(\"zulip\")\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"])\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        DefaultStream.objects.filter(realm=realm).delete()\n        default_streams = []\n        for stream_name in [\"venice\", \"verona\"]:\n            stream = get_stream(stream_name, realm)\n            do_add_default_stream(stream)\n            default_streams.append(stream)\n\n        group1_streams = []\n        for stream_name in [\"scotland\", \"denmark\"]:\n            stream = get_stream(stream_name, realm)\n            group1_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 1\", \"group 1 description\", group1_streams)\n\n        group2_streams = []\n        for stream_name in [\"scotland\", \"rome\"]:\n            stream = get_stream(stream_name, realm)\n            group2_streams.append(stream)\n        do_create_default_stream_group(realm, \"group 2\", \"group 2 description\", group2_streams)\n\n        result = self.submit_reg_form_for_user(\n            email, password, default_stream_groups=[\"group 1\", \"group 2\"]\n        )\n        self.check_user_subscribed_only_to_streams(\n            \"newguy\", list(set(default_streams + group1_streams + group2_streams))\n        )\n\n    def test_signup_without_user_settings_from_another_realm(self) -> None:\n        hamlet_in_zulip = self.example_user(\"hamlet\")\n        email = hamlet_in_zulip.delivery_email\n        password = \"newpassword\"\n        subdomain = \"lear\"\n        realm = get_realm(\"lear\")\n\n        # Make an account in the Zulip realm, but we're not copying from there.\n        hamlet_in_zulip.left_side_userlist = True\n        hamlet_in_zulip.default_language = \"de\"\n        hamlet_in_zulip.emojiset = \"twitter\"\n        hamlet_in_zulip.high_contrast_mode = True\n        hamlet_in_zulip.enter_sends = True\n        hamlet_in_zulip.tutorial_status = UserProfile.TUTORIAL_FINISHED\n        hamlet_in_zulip.save()\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=subdomain)\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"], subdomain=subdomain)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, subdomain=subdomain)\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email, password, source_realm_id=\"\", HTTP_HOST=subdomain + \".testserver\"\n        )\n\n        hamlet = get_user(self.example_email(\"hamlet\"), realm)\n        self.assertEqual(hamlet.left_side_userlist, False)\n        self.assertEqual(hamlet.default_language, \"en\")\n        self.assertEqual(hamlet.emojiset, \"google\")\n        self.assertEqual(hamlet.high_contrast_mode, False)\n        self.assertEqual(hamlet.enable_stream_audible_notifications, False)\n        self.assertEqual(hamlet.enter_sends, False)\n        self.assertEqual(hamlet.tutorial_status, UserProfile.TUTORIAL_WAITING)\n\n    def test_signup_with_user_settings_from_another_realm(self) -> None:\n        hamlet_in_zulip = self.example_user(\"hamlet\")\n        email = hamlet_in_zulip.delivery_email\n        password = \"newpassword\"\n        subdomain = \"lear\"\n        lear_realm = get_realm(\"lear\")\n\n        self.login(\"hamlet\")\n        with get_test_image_file(\"img.png\") as image_file:\n            self.client_post(\"/json/users/me/avatar\", {\"file\": image_file})\n        hamlet_in_zulip.refresh_from_db()\n        hamlet_in_zulip.left_side_userlist = True\n        hamlet_in_zulip.default_language = \"de\"\n        hamlet_in_zulip.emojiset = \"twitter\"\n        hamlet_in_zulip.high_contrast_mode = True\n        hamlet_in_zulip.enter_sends = True\n        hamlet_in_zulip.tutorial_status = UserProfile.TUTORIAL_FINISHED\n        hamlet_in_zulip.save()\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email}, subdomain=subdomain)\n        self.assertEqual(result.status_code, 302)\n        result = self.client_get(result[\"Location\"], subdomain=subdomain)\n\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url, subdomain=subdomain)\n        self.assertEqual(result.status_code, 200)\n\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\"password\": password, \"key\": find_key_by_email(email), \"from_confirmation\": \"1\"},\n            subdomain=subdomain,\n        )\n        self.assert_in_success_response(\n            [\n                \"Import settings from existing Zulip account\",\n                \"selected >\\n                            Zulip Dev\",\n                \"We just need you to do one last thing.\",\n            ],\n            result,\n        )\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            source_realm_id=str(hamlet_in_zulip.realm.id),\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n\n        hamlet_in_lear = get_user(email, lear_realm)\n        self.assertEqual(hamlet_in_lear.left_side_userlist, True)\n        self.assertEqual(hamlet_in_lear.default_language, \"de\")\n        self.assertEqual(hamlet_in_lear.emojiset, \"twitter\")\n        self.assertEqual(hamlet_in_lear.high_contrast_mode, True)\n        self.assertEqual(hamlet_in_lear.enter_sends, True)\n        self.assertEqual(hamlet_in_lear.enable_stream_audible_notifications, False)\n        self.assertEqual(hamlet_in_lear.tutorial_status, UserProfile.TUTORIAL_FINISHED)\n\n        zulip_path_id = avatar_disk_path(hamlet_in_zulip)\n        lear_path_id = avatar_disk_path(hamlet_in_lear)\n        with open(zulip_path_id, \"rb\") as f:\n            zulip_avatar_bits = f.read()\n        with open(lear_path_id, \"rb\") as f:\n            lear_avatar_bits = f.read()\n\n        self.assertGreater(len(zulip_avatar_bits), 500)\n        self.assertEqual(zulip_avatar_bits, lear_avatar_bits)\n\n    def test_signup_invalid_subdomain(self) -> None:\n        \"\"\"\n        Check if attempting to authenticate to the wrong subdomain logs an\n        error and redirects.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        password = \"newpassword\"\n\n        result = self.client_post(\"/accounts/home/\", {\"email\": email})\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # Visit the confirmation link.\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        result = self.client_get(confirmation_url)\n        self.assertEqual(result.status_code, 200)\n\n        def invalid_subdomain(**kwargs: Any) -> Any:\n            return_data = kwargs.get(\"return_data\", {})\n            return_data[\"invalid_subdomain\"] = True\n\n        with patch(\"zerver.views.registration.authenticate\", side_effect=invalid_subdomain):\n            with self.assertLogs(level=\"ERROR\") as m:\n                result = self.client_post(\n                    \"/accounts/register/\",\n                    {\n                        \"password\": password,\n                        \"full_name\": \"New User\",\n                        \"key\": find_key_by_email(email),\n                        \"terms\": True,\n                    },\n                )\n                self.assertEqual(\n                    m.output,\n                    [\"ERROR:root:Subdomain mismatch in registration zulip: newuser@zulip.com\"],\n                )\n        self.assertEqual(result.status_code, 302)\n\n    def test_signup_using_invalid_subdomain_preserves_state_of_form(self) -> None:\n        \"\"\"\n        Check that when we give invalid subdomain and submit the registration form\n        all the values in the form are preserved.\n        \"\"\"\n        realm = get_realm(\"zulip\")\n\n        password = \"test\"\n        email = self.example_email(\"iago\")\n        realm_name = \"Test\"\n\n        result = self.client_post(\"/new/\", {\"email\": email})\n        self.client_get(result[\"Location\"])\n        confirmation_url = self.get_confirmation_url_from_outbox(email)\n        self.client_get(confirmation_url)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            # Subdomain is already used, by construction.\n            realm_subdomain=realm.string_id,\n            realm_name=realm_name,\n            source_realm_id=str(realm.id),\n        )\n        self.assert_in_success_response(\n            [\n                \"Subdomain unavailable. Please choose a different one.\",\n                \"Zulip Dev\\n\",\n                'value=\"test\"',\n                'name=\"realm_name\"',\n            ],\n            result,\n        )\n\n    def test_replace_subdomain_in_confirmation_link(self) -> None:\n        \"\"\"\n        Check that manually changing the subdomain in a registration\n        confirmation link doesn't allow you to register to a different realm.\n        \"\"\"\n        email = \"newuser@zulip.com\"\n        self.client_post(\"/accounts/home/\", {\"email\": email})\n        result = self.client_post(\n            \"/accounts/register/\",\n            {\n                \"password\": \"password\",\n                \"key\": find_key_by_email(email),\n                \"terms\": True,\n                \"full_name\": \"New User\",\n                \"from_confirmation\": \"1\",\n            },\n            subdomain=\"zephyr\",\n        )\n        self.assertEqual(result.status_code, 404)\n        self.assert_in_response(\"We couldn't find your confirmation link\", result)\n\n    def test_signup_to_realm_on_manual_license_plan(self) -> None:\n        realm = get_realm(\"zulip\")\n        denmark_stream = get_stream(\"Denmark\", realm)\n        realm.signup_notifications_stream = denmark_stream\n        realm.save(update_fields=[\"signup_notifications_stream\"])\n\n        _, ledger = self.subscribe_realm_to_monthly_plan_on_manual_license_management(realm, 5, 5)\n\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertIn(\n                \"New members cannot join this organization because all Zulip licenses\",\n                form.errors[\"email\"][0],\n            )\n            last_message = Message.objects.last()\n            assert last_message is not None\n            self.assertIn(\n                f\"A new member ({self.nonreg_email('test')}) was unable to join your organization because all Zulip\",\n                last_message.content,\n            )\n            self.assertEqual(last_message.recipient.type_id, denmark_stream.id)\n\n        ledger.licenses_at_next_renewal = 50\n        ledger.save(update_fields=[\"licenses_at_next_renewal\"])\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertIn(\n                \"New members cannot join this organization because all Zulip licenses\",\n                form.errors[\"email\"][0],\n            )\n\n        ledger.licenses = 50\n        ledger.save(update_fields=[\"licenses\"])\n        with self.settings(BILLING_ENABLED=True):\n            form = HomepageForm({\"email\": self.nonreg_email(\"test\")}, realm=realm)\n            self.assertEqual(form.errors, {})\n\n    def test_failed_signup_due_to_restricted_domain(self) -> None:\n        realm = get_realm(\"zulip\")\n        do_set_realm_property(realm, \"invite_required\", False, acting_user=None)\n        do_set_realm_property(realm, \"emails_restricted_to_domains\", True, acting_user=None)\n\n        email = \"user@acme.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\n            f\"Your email address, {email}, is not in one of the domains\", form.errors[\"email\"][0]\n        )\n\n    def test_failed_signup_due_to_disposable_email(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.emails_restricted_to_domains = False\n        realm.disallow_disposable_email_addresses = True\n        realm.save()\n\n        email = \"abc@mailnator.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\"Please use your real email address\", form.errors[\"email\"][0])\n\n    def test_failed_signup_due_to_email_containing_plus(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.emails_restricted_to_domains = True\n        realm.save()\n\n        email = \"iago+label@zulip.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(\n            \"Email addresses containing + are not allowed in this organization.\",\n            form.errors[\"email\"][0],\n        )\n\n    def test_failed_signup_due_to_invite_required(self) -> None:\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save()\n        email = \"user@zulip.com\"\n        form = HomepageForm({\"email\": email}, realm=realm)\n        self.assertIn(f\"Please request an invite for {email} from\", form.errors[\"email\"][0])\n\n    def test_failed_signup_due_to_nonexistent_realm(self) -> None:\n        email = \"user@acme.com\"\n        form = HomepageForm({\"email\": email}, realm=None)\n        self.assertIn(\n            f\"organization you are trying to join using {email} does not exist\",\n            form.errors[\"email\"][0],\n        )\n\n    def test_access_signup_page_in_root_domain_without_realm(self) -> None:\n        result = self.client_get(\"/register\", subdomain=\"\", follow=True)\n        self.assert_in_success_response([\"Find your Zulip accounts\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_from_confirmation(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\n                    \"We just need you to do one last thing.\",\n                    \"New LDAP fullname\",\n                    \"newuser@zulip.com\",\n                ],\n                result,\n            )\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response([\"id_full_name\"], result)\n            # Verify that user is asked for its LDAP/Active Directory password.\n            self.assert_in_success_response(\n                [\"Enter your LDAP/Active Directory password.\", \"ldap-password\"], result\n            )\n            self.assert_not_in_success_response([\"id_password\"], result)\n\n            # Test the TypeError exception handler\n            with patch(\n                \"zproject.backends.ZulipLDAPAuthBackendBase.get_mapped_name\", side_effect=TypeError\n            ):\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", \"newuser@zulip.com\"], result\n            )\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipLDAPUserPopulator\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_populate_only_registration_from_confirmation(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_BIND_PASSWORD=\"\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTH_LDAP_USER_DN_TEMPLATE=\"uid=%(user)s,ou=users,dc=zulip,dc=com\",\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            # Full name should be set from LDAP\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            self.assert_in_success_response(\n                [\n                    \"We just need you to do one last thing.\",\n                    \"New LDAP fullname\",\n                    \"newuser@zulip.com\",\n                ],\n                result,\n            )\n\n            # Verify that the user is asked for name\n            self.assert_in_success_response([\"id_full_name\"], result)\n            # Verify that user is NOT asked for its LDAP/Active Directory password.\n            # LDAP is not configured for authentication in this test.\n            self.assert_not_in_success_response(\n                [\"Enter your LDAP/Active Directory password.\", \"ldap-password\"], result\n            )\n            # If we were using e.g. the SAML auth backend, there\n            # shouldn't be a password prompt, but since it uses the\n            # EmailAuthBackend, there should be password field here.\n            self.assert_in_success_response([\"id_password\"], result)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_end_to_end(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n        full_name = \"New LDAP fullname\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            # Full name should be set from LDAP\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", full_name, \"newuser@zulip.com\"], result\n            )\n\n            # Submit the final form with the wrong password.\n            result = self.submit_reg_form_for_user(\n                email,\n                \"wrongpassword\",\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            # Didn't create an account\n            with self.assertRaises(UserProfile.DoesNotExist):\n                user_profile = UserProfile.objects.get(delivery_email=email)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n\n            # Submit the final form with the correct password.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=full_name,\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_split_full_name_mapping(self) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"first_name\": \"sn\", \"last_name\": \"cn\"}\n\n        subdomain = \"zulip\"\n        email = \"newuser_splitname@zulip.com\"\n        password = self.ldap_password(\"newuser_splitname\")\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            # Test split name mapping.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, \"First Last\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_auto_registration_on_login(self) -> None:\n        \"\"\"The most common way for LDAP authentication to be used is with a\n        server that doesn't have a terms-of-service required, in which\n        case we offer a complete single-sign-on experience (where the\n        user just enters their LDAP username and password, and their\n        account is created if it doesn't already exist).\n\n        This test verifies that flow.\n        \"\"\"\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\n            \"full_name\": \"cn\",\n            \"custom_profile_field__phone_number\": \"homePhone\",\n        }\n        full_name = \"New LDAP fullname\"\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from form which was set by LDAP.\n            self.assertEqual(user_profile.full_name, full_name)\n\n            # Test custom profile fields are properly synced.\n            phone_number_field = CustomProfileField.objects.get(\n                realm=user_profile.realm, name=\"Phone number\"\n            )\n            phone_number_field_value = CustomProfileFieldValue.objects.get(\n                user_profile=user_profile, field=phone_number_field\n            )\n            self.assertEqual(phone_number_field_value.value, \"a-new-number\")\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_auto_registration_on_login_invalid_email_in_directory(self) -> None:\n        password = self.ldap_password(\"newuser_with_email\")\n        username = \"newuser_with_email\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n\n        self.change_ldap_user_attr(\"newuser_with_email\", \"mail\", \"thisisnotavalidemail\")\n\n        with self.settings(\n            LDAP_EMAIL_ATTR=\"mail\",\n        ), self.assertLogs(\"zulip.auth.ldap\", \"WARNING\") as mock_log:\n            original_user_count = UserProfile.objects.count()\n            self.login_with_return(username, password, HTTP_HOST=subdomain + \".testserver\")\n            # Verify that the process failed as intended - no UserProfile is created.\n            self.assertEqual(UserProfile.objects.count(), original_user_count)\n            self.assertEqual(\n                mock_log.output,\n                [\"WARNING:zulip.auth.ldap:thisisnotavalidemail is not a valid email address.\"],\n            )\n\n    @override_settings(AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",))\n    def test_ldap_registration_multiple_realms(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\n            \"full_name\": \"cn\",\n        }\n        do_create_realm(\"test\", \"test\", emails_restricted_to_domains=False)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            subdomain = \"zulip\"\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email, realm=get_realm(\"zulip\"))\n            self.logout()\n\n            # Test registration in another realm works.\n            subdomain = \"test\"\n            self.login_with_return(email, password, HTTP_HOST=subdomain + \".testserver\")\n\n            user_profile = UserProfile.objects.get(delivery_email=email, realm=get_realm(\"test\"))\n            self.assertEqual(user_profile.delivery_email, email)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_ldap_registration_when_names_changes_are_disabled(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            # Click confirmation link. This will 'authenticated_full_name'\n            # session variable which will be used to set the fullname of\n            # the user.\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n\n            with patch(\"zerver.views.registration.name_changes_disabled\", return_value=True):\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from LDAP session.\n            self.assertEqual(user_profile.full_name, \"New LDAP fullname\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_signup_with_ldap_and_email_enabled_using_email_with_ldap_append_domain(self) -> None:\n        password = \"nonldappassword\"\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        # If the user's email is inside the LDAP directory and we just\n        # have a wrong password, then we refuse to create an account\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because password was wrong\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n\n        # For the rest of the test we delete the user from ldap.\n        del self.mock_ldap.directory[\"uid=newuser,ou=users,dc=zulip,dc=com\"]\n\n        # If the user's email is not in the LDAP directory, but fits LDAP_APPEND_DOMAIN,\n        # we refuse to create the account.\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ), self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because emails matching LDAP_APPEND_DOMAIN,\n            # aren't allowed to create non-LDAP accounts.\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: newuser. Input username: newuser@zulip.com\"\n                ],\n            )\n\n        # If the email is outside of LDAP_APPEND_DOMAIN, we successfully create a non-LDAP account,\n        # with the password managed in the Zulip database.\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"example.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(level=\"WARNING\") as m:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(result.status_code, 200)\n            self.assertEqual(\n                m.output,\n                [\"WARNING:root:New account email newuser@zulip.com could not be found in LDAP\"],\n            )\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    full_name=\"Non-LDAP Full Name\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: Email newuser@zulip.com does not match LDAP domain example.com.\"\n                ],\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"http://zulip.testserver/\")\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from the POST request, not LDAP\n            self.assertEqual(user_profile.full_name, \"Non-LDAP Full Name\")\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n            \"zproject.backends.ZulipDummyBackend\",\n        )\n    )\n    def test_signup_with_ldap_and_email_enabled_using_email_with_ldap_email_search(self) -> None:\n        # If the user's email is inside the LDAP directory and we just\n        # have a wrong password, then we refuse to create an account\n        password = \"nonldappassword\"\n        email = \"newuser_email@zulip.com\"  # belongs to user uid=newuser_with_email in the test directory\n        subdomain = \"zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Non-LDAP Full Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n            # We get redirected back to the login page because password was wrong\n            self.assertEqual(result.url, \"/accounts/login/?email=newuser_email%40zulip.com\")\n            self.assertFalse(UserProfile.objects.filter(delivery_email=email).exists())\n\n        # If the user's email is not in the LDAP directory , though, we\n        # successfully create an account with a password in the Zulip\n        # database.\n        password = \"nonldappassword\"\n        email = \"nonexistent@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_EMAIL_ATTR=\"mail\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(level=\"WARNING\") as m:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    from_confirmation=\"1\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n                self.assertEqual(result.status_code, 200)\n                self.assertEqual(\n                    m.output,\n                    [\n                        \"WARNING:root:New account email nonexistent@zulip.com could not be found in LDAP\"\n                    ],\n                )\n\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                result = self.submit_reg_form_for_user(\n                    email,\n                    password,\n                    full_name=\"Non-LDAP Full Name\",\n                    # Pass HTTP_HOST for the target subdomain\n                    HTTP_HOST=subdomain + \".testserver\",\n                )\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: nonexistent@zulip.com. Input username: nonexistent@zulip.com\"\n                ],\n            )\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"http://zulip.testserver/\")\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # Name comes from the POST request, not LDAP\n            self.assertEqual(user_profile.full_name, \"Non-LDAP Full Name\")\n\n    def ldap_invite_and_signup_as(\n        self, invite_as: int, streams: Sequence[str] = [\"Denmark\"]\n    ) -> None:\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        subdomain = \"zulip\"\n        email = \"newuser@zulip.com\"\n        password = self.ldap_password(\"newuser\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n        ):\n            with self.assertLogs(\"zulip.ldap\", \"DEBUG\") as debug_log:\n                # Invite user.\n                self.login(\"iago\")\n            self.assertEqual(\n                debug_log.output,\n                [\n                    \"DEBUG:zulip.ldap:ZulipLDAPAuthBackend: No LDAP user matching django_to_ldap_username result: iago. Input username: iago@zulip.com\"\n                ],\n            )\n            response = self.invite(\n                invitee_emails=\"newuser@zulip.com\", stream_names=streams, invite_as=invite_as\n            )\n            self.assert_json_success(response)\n            self.logout()\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 200)\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"Ignore\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assertEqual(result.status_code, 302)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_user_as_admin(self) -> None:\n        self.ldap_invite_and_signup_as(PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"])\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_realm_admin)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_user_as_guest(self) -> None:\n        self.ldap_invite_and_signup_as(PreregistrationUser.INVITE_AS[\"GUEST_USER\"])\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_guest)\n\n    @override_settings(\n        AUTHENTICATION_BACKENDS=(\n            \"zproject.backends.ZulipLDAPAuthBackend\",\n            \"zproject.backends.EmailAuthBackend\",\n        )\n    )\n    def test_ldap_invite_streams(self) -> None:\n        stream_name = \"Rome\"\n        realm = get_realm(\"zulip\")\n        stream = get_stream(stream_name, realm)\n        default_streams = get_default_streams_for_realm(realm.id)\n        default_streams_name = [stream.name for stream in default_streams]\n        self.assertNotIn(stream_name, default_streams_name)\n\n        # Invite user.\n        self.ldap_invite_and_signup_as(\n            PreregistrationUser.INVITE_AS[\"REALM_ADMIN\"], streams=[stream_name]\n        )\n\n        user_profile = UserProfile.objects.get(delivery_email=self.nonreg_email(\"newuser\"))\n        self.assertTrue(user_profile.is_realm_admin)\n        sub = get_stream_subscriptions_for_user(user_profile).filter(recipient__type_id=stream.id)\n        self.assert_length(sub, 1)\n\n    def test_registration_when_name_changes_are_disabled(self) -> None:\n        \"\"\"\n        Test `name_changes_disabled` when we are not running under LDAP.\n        \"\"\"\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n\n        with patch(\"zerver.views.registration.name_changes_disabled\", return_value=True):\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                full_name=\"New Name\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            user_profile = UserProfile.objects.get(delivery_email=email)\n            # 'New Name' comes from POST data; not from LDAP session.\n            self.assertEqual(user_profile.full_name, \"New Name\")\n\n    def test_realm_creation_through_ldap(self) -> None:\n        password = self.ldap_password(\"newuser\")\n        email = \"newuser@zulip.com\"\n        subdomain = \"zulip\"\n        realm_name = \"Zulip\"\n\n        self.init_default_ldap_database()\n        ldap_user_attr_map = {\"full_name\": \"cn\"}\n\n        with patch(\"zerver.views.registration.get_subdomain\", return_value=subdomain):\n            result = self.client_post(\"/register/\", {\"email\": email})\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"])\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        with self.settings(\n            POPULATE_PROFILE_VIA_LDAP=True,\n            LDAP_APPEND_DOMAIN=\"zulip.com\",\n            AUTH_LDAP_USER_ATTR_MAP=ldap_user_attr_map,\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.ZulipLDAPAuthBackend\",),\n            TERMS_OF_SERVICE=False,\n        ):\n            result = self.client_get(confirmation_url)\n            self.assertEqual(result.status_code, 200)\n\n            key = find_key_by_email(email)\n            confirmation = Confirmation.objects.get(confirmation_key=key)\n            prereg_user = confirmation.content_object\n            assert prereg_user is not None\n            prereg_user.realm_creation = True\n            prereg_user.save()\n\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                realm_name=realm_name,\n                realm_subdomain=subdomain,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n            self.assert_in_success_response(\n                [\"We just need you to do one last thing.\", \"newuser@zulip.com\"], result\n            )\n\n    @patch(\n        \"DNS.dnslookup\",\n        return_value=[[\"sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh\"]],\n    )\n    def test_registration_of_mirror_dummy_user(self, ignored: Any) -> None:\n        password = \"test\"\n        subdomain = \"zephyr\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        user_profile.is_mirror_dummy = True\n        user_profile.save()\n        change_user_is_active(user_profile, False)\n\n        result = self.client_post(\"/register/\", {\"email\": email}, subdomain=\"zephyr\")\n\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(result[\"Location\"].endswith(f\"/accounts/send_confirm/{email}\"))\n        result = self.client_get(result[\"Location\"], subdomain=\"zephyr\")\n        self.assert_in_response(\"Check your email so we can get started.\", result)\n        # Visit the confirmation link.\n        from django.core.mail import outbox\n\n        for message in reversed(outbox):\n            if email in message.to:\n                match = re.search(settings.EXTERNAL_HOST + r\"(\\S+)>\", message.body)\n                assert match is not None\n                [confirmation_url] = match.groups()\n                break\n        else:\n            raise AssertionError(\"Couldn't find a confirmation email.\")\n\n        result = self.client_get(confirmation_url, subdomain=\"zephyr\")\n        self.assertEqual(result.status_code, 200)\n\n        # If the mirror dummy user is already active, attempting to\n        # submit the registration form should raise an AssertionError\n        # (this is an invalid state, so it's a bug we got here):\n        change_user_is_active(user_profile, True)\n\n        with self.assertRaisesRegex(\n            AssertionError, \"Mirror dummy user is already active!\"\n        ), self.assertLogs(\"django.request\", \"ERROR\") as error_log:\n            result = self.submit_reg_form_for_user(\n                email,\n                password,\n                from_confirmation=\"1\",\n                # Pass HTTP_HOST for the target subdomain\n                HTTP_HOST=subdomain + \".testserver\",\n            )\n        self.assertTrue(\n            \"ERROR:django.request:Internal Server Error: /accounts/register/\" in error_log.output[0]\n        )\n        self.assertTrue(\n            'raise AssertionError(\"Mirror dummy user is already active!' in error_log.output[0]\n        )\n        self.assertTrue(\n            \"AssertionError: Mirror dummy user is already active!\" in error_log.output[0]\n        )\n\n        change_user_is_active(user_profile, False)\n\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            from_confirmation=\"1\",\n            # Pass HTTP_HOST for the target subdomain\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n        self.assertEqual(result.status_code, 200)\n        result = self.submit_reg_form_for_user(\n            email,\n            password,\n            # Pass HTTP_HOST for the target subdomain\n            HTTP_HOST=subdomain + \".testserver\",\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @patch(\n        \"DNS.dnslookup\",\n        return_value=[[\"sipbtest:*:20922:101:Fred Sipb,,,:/mit/sipbtest:/bin/athena/tcsh\"]],\n    )\n    def test_registration_of_active_mirror_dummy_user(self, ignored: Any) -> None:\n        \"\"\"\n        Trying to activate an already-active mirror dummy user should\n        raise an AssertionError.\n        \"\"\"\n        user_profile = self.mit_user(\"sipbtest\")\n        email = user_profile.delivery_email\n        user_profile.is_mirror_dummy = True\n        user_profile.save()\n        change_user_is_active(user_profile, True)\n\n        with self.assertRaisesRegex(\n            AssertionError, \"Mirror dummy user is already active!\"\n        ), self.assertLogs(\"django.request\", \"ERROR\") as error_log:\n            self.client_post(\"/register/\", {\"email\": email}, subdomain=\"zephyr\")\n        self.assertTrue(\n            \"ERROR:django.request:Internal Server Error: /register/\" in error_log.output[0]\n        )\n        self.assertTrue(\n            'raise AssertionError(\"Mirror dummy user is already active!' in error_log.output[0]\n        )\n        self.assertTrue(\n            \"AssertionError: Mirror dummy user is already active!\" in error_log.output[0]\n        )\n\n    @override_settings(TERMS_OF_SERVICE=False)\n    def test_dev_user_registration(self) -> None:\n        \"\"\"Verify that /devtools/register_user creates a new user, logs them\n        in, and redirects to the logged-in app.\"\"\"\n        count = UserProfile.objects.count()\n        email = f\"user-{count}@zulip.com\"\n\n        result = self.client_post(\"/devtools/register_user/\")\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(user_profile.delivery_email, email)\n        self.assertEqual(result[\"Location\"], \"http://zulip.testserver/\")\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TERMS_OF_SERVICE=False)\n    def test_dev_user_registration_create_realm(self) -> None:\n        count = UserProfile.objects.count()\n        string_id = f\"realm-{count}\"\n\n        result = self.client_post(\"/devtools/register_realm/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertTrue(\n            result[\"Location\"].startswith(f\"http://{string_id}.testserver/accounts/login/subdomain\")\n        )\n        result = self.client_get(result[\"Location\"], subdomain=string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"http://{string_id}.testserver\")\n\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n        self.assert_logged_in_user_id(user_profile.id)\n\n    @override_settings(TERMS_OF_SERVICE=False)\n    def test_dev_user_registration_create_demo_realm(self) -> None:\n        result = self.client_post(\"/devtools/register_demo_realm/\")\n        self.assertEqual(result.status_code, 302)\n\n        realm = Realm.objects.latest(\"date_created\")\n        self.assertTrue(\n            result[\"Location\"].startswith(\n                f\"http://{realm.string_id}.testserver/accounts/login/subdomain\"\n            )\n        )\n        result = self.client_get(result[\"Location\"], subdomain=realm.string_id)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], f\"http://{realm.string_id}.testserver\")\n\n        user_profile = UserProfile.objects.all().order_by(\"id\").last()\n        assert user_profile is not None\n        self.assert_logged_in_user_id(user_profile.id)\n\n        expected_deletion_date = realm.date_created + datetime.timedelta(\n            days=settings.DEMO_ORG_DEADLINE_DAYS\n        )\n        self.assertEqual(realm.demo_organization_scheduled_deletion_date, expected_deletion_date)\n\n\nclass DeactivateUserTest(ZulipTestCase):\n    def test_deactivate_user(self) -> None:\n        user = self.example_user(\"hamlet\")\n        email = user.email\n        self.login_user(user)\n        self.assertTrue(user.is_active)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        user = self.example_user(\"hamlet\")\n        self.assertFalse(user.is_active)\n        password = initial_password(email)\n        assert password is not None\n        self.assert_login_failure(email, password=password)\n\n    def test_do_not_deactivate_final_owner(self) -> None:\n        user = self.example_user(\"desdemona\")\n        user_2 = self.example_user(\"iago\")\n        self.login_user(user)\n        self.assertTrue(user.is_active)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_error(result, \"Cannot deactivate the only organization owner.\")\n        user = self.example_user(\"desdemona\")\n        self.assertTrue(user.is_active)\n        self.assertTrue(user.is_realm_owner)\n        do_change_user_role(user_2, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n        self.assertTrue(user_2.is_realm_owner)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_success(result)\n        do_change_user_role(user, UserProfile.ROLE_REALM_OWNER, acting_user=None)\n\n    def test_do_not_deactivate_final_user(self) -> None:\n        realm = get_realm(\"zulip\")\n        for user_profile in UserProfile.objects.filter(realm=realm).exclude(\n            role=UserProfile.ROLE_REALM_OWNER\n        ):\n            do_deactivate_user(user_profile, acting_user=None)\n        user = self.example_user(\"desdemona\")\n        self.login_user(user)\n        result = self.client_delete(\"/json/users/me\")\n        self.assert_json_error(result, \"Cannot deactivate the only user.\")\n\n\nclass TestLoginPage(ZulipTestCase):\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_redirects_for_root_alias(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Fupgrade%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_redirects_for_root_domain(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_DOMAIN_LANDING_PAGE=True):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Fupgrade%2F\")\n\n        mock_get_host.return_value = \"www.testserver.com\"\n        with self.settings(\n            ROOT_DOMAIN_LANDING_PAGE=True,\n            EXTERNAL_HOST=\"www.testserver.com\",\n            ROOT_SUBDOMAIN_ALIASES=[\"test\"],\n        ):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/\")\n\n            result = self.client_get(\"/en/login/\", {\"next\": \"/upgrade/\"})\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result.url, \"/accounts/go/?next=%2Fupgrade%2F\")\n\n    @patch(\"django.http.HttpRequest.get_host\")\n    def test_login_page_works_without_subdomains(self, mock_get_host: MagicMock) -> None:\n        mock_get_host.return_value = \"www.testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"www\"]):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n        mock_get_host.return_value = \"testserver\"\n        with self.settings(ROOT_SUBDOMAIN_ALIASES=[\"www\"]):\n            result = self.client_get(\"/en/login/\")\n            self.assertEqual(result.status_code, 200)\n\n    def test_login_page_registration_hint(self) -> None:\n        response = self.client_get(\"/login/\")\n        self.assert_not_in_success_response(\n            [\"Don't have an account yet? You need to be invited to join this organization.\"],\n            response,\n        )\n\n        realm = get_realm(\"zulip\")\n        realm.invite_required = True\n        realm.save(update_fields=[\"invite_required\"])\n        response = self.client_get(\"/login/\")\n        self.assert_in_success_response(\n            [\"Don't have an account yet? You need to be invited to join this organization.\"],\n            response,\n        )\n\n    @patch(\"django.http.HttpRequest.get_host\", return_value=\"auth.testserver\")\n    def test_social_auth_subdomain_login_page(self, mock_get_host: MagicMock) -> None:\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Authentication subdomain\", result)\n\n        zulip_realm = get_realm(\"zulip\")\n        session = self.client.session\n        session[\"subdomain\"] = \"zulip\"\n        session.save()\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, zulip_realm.uri)\n\n        session = self.client.session\n        session[\"subdomain\"] = \"invalid\"\n        session.save()\n        result = self.client_get(\"http://auth.testserver/login/\")\n        self.assertEqual(result.status_code, 400)\n        self.assert_in_response(\"Authentication subdomain\", result)\n\n    def test_login_page_is_deactivated_validation(self) -> None:\n        with patch(\"zerver.views.auth.logging.info\") as mock_info:\n            result = self.client_get(\"/login/?is_deactivated=invalid_email\")\n            mock_info.assert_called_once()\n            self.assert_not_in_success_response([\"invalid_email\"], result)\n\n\nclass TestFindMyTeam(ZulipTestCase):\n    def test_template(self) -> None:\n        result = self.client_get(\"/accounts/find/\")\n        self.assertIn(\"Find your Zulip accounts\", result.content.decode())\n\n    def test_result(self) -> None:\n        # We capitalize a letter in cordelia's email to test that the search is case-insensitive.\n        result = self.client_post(\n            \"/accounts/find/\", dict(emails=\"iago@zulip.com,cordeliA@zulip.com\")\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\n            result.url, \"/accounts/find/?emails=iago%40zulip.com%2CcordeliA%40zulip.com\"\n        )\n        result = self.client_get(result.url)\n        content = result.content.decode()\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(\"iago@zulip.com\", content)\n        self.assertIn(\"cordeliA@zulip.com\", content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 2)\n        iago_message = outbox[1]\n        cordelia_message = outbox[0]\n        self.assertIn(\"Zulip Dev\", iago_message.body)\n        self.assertNotIn(\"Lear & Co\", iago_message.body)\n        self.assertIn(\"Zulip Dev\", cordelia_message.body)\n        self.assertIn(\"Lear & Co\", cordelia_message.body)\n\n    def test_find_team_ignore_invalid_email(self) -> None:\n        result = self.client_post(\n            \"/accounts/find/\", dict(emails=\"iago@zulip.com,invalid_email@zulip.com\")\n        )\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(\n            result.url, \"/accounts/find/?emails=iago%40zulip.com%2Cinvalid_email%40zulip.com\"\n        )\n        result = self.client_get(result.url)\n        content = result.content.decode()\n        self.assertIn(\"Emails sent! You will only receive emails\", content)\n        self.assertIn(self.example_email(\"iago\"), content)\n        self.assertIn(\"invalid_email@\", content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 1)\n\n    def test_find_team_reject_invalid_email(self) -> None:\n        result = self.client_post(\"/accounts/find/\", dict(emails=\"invalid_string\"))\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(b\"Enter a valid email\", result.content)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n        # Just for coverage on perhaps-unnecessary validation code.\n        result = self.client_get(\"/accounts/find/\", {\"emails\": \"invalid\"})\n        self.assertEqual(result.status_code, 200)\n\n    def test_find_team_zero_emails(self) -> None:\n        data = {\"emails\": \"\"}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertIn(\"This field is required\", result.content.decode())\n        self.assertEqual(result.status_code, 200)\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_one_email(self) -> None:\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 1)\n\n    def test_find_team_deactivated_user(self) -> None:\n        do_deactivate_user(self.example_user(\"hamlet\"), acting_user=None)\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_deactivated_realm(self) -> None:\n        do_deactivate_realm(get_realm(\"zulip\"), acting_user=None)\n        data = {\"emails\": self.example_email(\"hamlet\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=hamlet%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_bot_email(self) -> None:\n        data = {\"emails\": self.example_email(\"webhook_bot\")}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result.url, \"/accounts/find/?emails=webhook-bot%40zulip.com\")\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n    def test_find_team_more_than_ten_emails(self) -> None:\n        data = {\"emails\": \",\".join(f\"hamlet-{i}@zulip.com\" for i in range(11))}\n        result = self.client_post(\"/accounts/find/\", data)\n        self.assertEqual(result.status_code, 200)\n        self.assertIn(\"Please enter at most 10\", result.content.decode())\n        from django.core.mail import outbox\n\n        self.assert_length(outbox, 0)\n\n\nclass ConfirmationKeyTest(ZulipTestCase):\n    def test_confirmation_key(self) -> None:\n        request = MagicMock()\n        request.session = {\n            \"confirmation_key\": {\"confirmation_key\": \"xyzzy\"},\n        }\n        result = confirmation_key(request)\n        self.assert_json_success(result)\n        self.assert_in_response(\"xyzzy\", result)\n\n\nclass MobileAuthOTPTest(ZulipTestCase):\n    def test_xor_hex_strings(self) -> None:\n        self.assertEqual(xor_hex_strings(\"1237c81ab\", \"18989fd12\"), \"0aaf57cb9\")\n        with self.assertRaises(AssertionError):\n            xor_hex_strings(\"1\", \"31\")\n\n    def test_is_valid_otp(self) -> None:\n        self.assertEqual(is_valid_otp(\"1234\"), False)\n        self.assertEqual(is_valid_otp(\"1234abcd\" * 8), True)\n        self.assertEqual(is_valid_otp(\"1234abcZ\" * 8), False)\n\n    def test_ascii_to_hex(self) -> None:\n        self.assertEqual(ascii_to_hex(\"ZcdR1234\"), \"5a63645231323334\")\n        self.assertEqual(hex_to_ascii(\"5a63645231323334\"), \"ZcdR1234\")\n\n    def test_otp_encrypt_api_key(self) -> None:\n        api_key = \"12ac\" * 8\n        otp = \"7be38894\" * 8\n        result = otp_encrypt_api_key(api_key, otp)\n        self.assertEqual(result, \"4ad1e9f7\" * 8)\n\n        decryped = otp_decrypt_api_key(result, otp)\n        self.assertEqual(decryped, api_key)\n\n\nclass FollowupEmailTest(ZulipTestCase):\n    def test_followup_day2_email(self) -> None:\n        user_profile = self.example_user(\"hamlet\")\n        # Test date_joined == Sunday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 7, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=2, hours=-1)\n        )\n        # Test date_joined == Tuesday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 2, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=2, hours=-1)\n        )\n        # Test date_joined == Thursday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 4, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=1, hours=-1)\n        )\n        # Test date_joined == Friday\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 5, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=3, hours=-1)\n        )\n\n        # Time offset of America/Phoenix is -07:00\n        user_profile.timezone = \"America/Phoenix\"\n        # Test date_joined == Friday in UTC, but Thursday in the user's timezone\n        user_profile.date_joined = datetime.datetime(\n            2018, 1, 5, 1, 0, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        self.assertEqual(\n            followup_day2_email_delay(user_profile), datetime.timedelta(days=1, hours=-1)\n        )\n\n\nclass NoReplyEmailTest(ZulipTestCase):\n    def test_noreply_email_address(self) -> None:\n        self.assertTrue(\n            re.search(self.TOKENIZED_NOREPLY_REGEX, FromAddress.tokenized_no_reply_address())\n        )\n\n        with self.settings(ADD_TOKENS_TO_NOREPLY_ADDRESS=False):\n            self.assertEqual(FromAddress.tokenized_no_reply_address(), \"noreply@testserver\")\n\n\nclass TwoFactorAuthTest(ZulipTestCase):\n    @patch(\"two_factor.models.totp\")\n    def test_two_factor_login(self, mock_totp: MagicMock) -> None:\n        token = 123456\n        email = self.example_email(\"hamlet\")\n        password = self.ldap_password(\"hamlet\")\n\n        user_profile = self.example_user(\"hamlet\")\n        user_profile.set_password(password)\n        user_profile.save()\n        self.create_default_device(user_profile)\n\n        def totp(*args: Any, **kwargs: Any) -> int:\n            return token\n\n        mock_totp.side_effect = totp\n\n        with self.settings(\n            AUTHENTICATION_BACKENDS=(\"zproject.backends.EmailAuthBackend\",),\n            TWO_FACTOR_CALL_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_SMS_GATEWAY=\"two_factor.gateways.fake.Fake\",\n            TWO_FACTOR_AUTHENTICATION_ENABLED=True,\n        ):\n\n            first_step_data = {\n                \"username\": email,\n                \"password\": password,\n                \"two_factor_login_view-current_step\": \"auth\",\n            }\n            with self.assertLogs(\"two_factor.gateways.fake\", \"INFO\") as info_logs:\n                result = self.client_post(\"/accounts/login/\", first_step_data)\n            self.assertEqual(\n                info_logs.output,\n                ['INFO:two_factor.gateways.fake:Fake SMS to +12125550100: \"Your token is: 123456\"'],\n            )\n            self.assertEqual(result.status_code, 200)\n\n            second_step_data = {\n                \"token-otp_token\": str(token),\n                \"two_factor_login_view-current_step\": \"token\",\n            }\n            result = self.client_post(\"/accounts/login/\", second_step_data)\n            self.assertEqual(result.status_code, 302)\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n            # Going to login page should redirect to '/' if user is already\n            # logged in.\n            result = self.client_get(\"/accounts/login/\")\n            self.assertEqual(result[\"Location\"], \"http://zulip.testserver\")\n\n\nclass NameRestrictionsTest(ZulipTestCase):\n    def test_whitelisted_disposable_domains(self) -> None:\n        self.assertFalse(is_disposable_domain(\"OPayQ.com\"))\n\n\nclass RealmRedirectTest(ZulipTestCase):\n    def test_realm_redirect_without_next_param(self) -> None:\n        result = self.client_get(\"/accounts/go/\")\n        self.assert_in_success_response([\"Enter your organization's Zulip URL\"], result)\n\n        result = self.client_post(\"/accounts/go/\", {\"subdomain\": \"zephyr\"})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://zephyr.testserver\")\n\n        result = self.client_post(\"/accounts/go/\", {\"subdomain\": \"invalid\"})\n        self.assert_in_success_response([\"We couldn&#39;t find that Zulip organization.\"], result)\n\n    def test_realm_redirect_with_next_param(self) -> None:\n        result = self.client_get(\"/accounts/go/\", {\"next\": \"billing\"})\n        self.assert_in_success_response(\n            [\"Enter your organization's Zulip URL\", 'action=\"/accounts/go/?next=billing\"'], result\n        )\n\n        result = self.client_post(\"/accounts/go/?next=billing\", {\"subdomain\": \"lear\"})\n        self.assertEqual(result.status_code, 302)\n        self.assertEqual(result[\"Location\"], \"http://lear.testserver/billing\")\n", "import logging\nimport urllib\nfrom typing import Any, Dict, List, Optional, Union\nfrom urllib.parse import urlencode\n\nfrom django.conf import settings\nfrom django.contrib.auth import authenticate, get_backends\nfrom django.core import validators\nfrom django.core.exceptions import ValidationError\nfrom django.db.models import Q\nfrom django.http import HttpRequest, HttpResponse, HttpResponseRedirect\nfrom django.shortcuts import redirect, render\nfrom django.urls import reverse\nfrom django.utils.translation import gettext as _\nfrom django_auth_ldap.backend import LDAPBackend, _LDAPUser\n\nfrom confirmation import settings as confirmation_settings\nfrom confirmation.models import (\n    Confirmation,\n    ConfirmationKeyException,\n    RealmCreationKey,\n    create_confirmation_link,\n    get_object_from_key,\n    render_confirmation_key_error,\n    validate_key,\n)\nfrom zerver.context_processors import get_realm_from_request, login_context\nfrom zerver.decorator import do_login, rate_limit_request_by_ip, require_post\nfrom zerver.forms import (\n    FindMyTeamForm,\n    HomepageForm,\n    RealmCreationForm,\n    RealmRedirectForm,\n    RegistrationForm,\n)\nfrom zerver.lib.actions import (\n    bulk_add_subscriptions,\n    do_activate_mirror_dummy_user,\n    do_change_full_name,\n    do_change_password,\n    do_change_user_setting,\n    do_create_realm,\n    do_create_user,\n    lookup_default_stream_groups,\n)\nfrom zerver.lib.email_validation import email_allowed_for_realm, validate_email_not_already_in_realm\nfrom zerver.lib.exceptions import RateLimited\nfrom zerver.lib.onboarding import send_initial_realm_messages, setup_realm_internal_bots\nfrom zerver.lib.pysa import mark_sanitized\nfrom zerver.lib.request import REQ, has_request_variables\nfrom zerver.lib.send_email import EmailNotDeliveredException, FromAddress, send_email\nfrom zerver.lib.sessions import get_expirable_session_var\nfrom zerver.lib.subdomains import get_subdomain, is_root_domain_available\nfrom zerver.lib.url_encoding import append_url_query_string\nfrom zerver.lib.users import get_accounts_for_email\nfrom zerver.lib.validator import to_converted_or_fallback, to_non_negative_int, to_timezone_or_empty\nfrom zerver.lib.zephyr import compute_mit_user_fullname\nfrom zerver.models import (\n    DisposableEmailError,\n    DomainNotAllowedForRealmError,\n    EmailContainsPlusError,\n    MultiuseInvite,\n    Realm,\n    Stream,\n    UserProfile,\n    get_default_stream_groups,\n    get_realm,\n    get_source_profile,\n    get_user_by_delivery_email,\n    name_changes_disabled,\n)\nfrom zerver.views.auth import (\n    create_preregistration_user,\n    finish_desktop_flow,\n    finish_mobile_flow,\n    get_safe_redirect_to,\n    redirect_and_log_into_subdomain,\n    redirect_to_deactivation_notice,\n)\nfrom zproject.backends import (\n    ExternalAuthResult,\n    ZulipLDAPAuthBackend,\n    ZulipLDAPExceptionNoMatchingLDAPUser,\n    email_auth_enabled,\n    email_belongs_to_ldap,\n    get_external_method_dicts,\n    ldap_auth_enabled,\n    password_auth_enabled,\n)\n\nif settings.BILLING_ENABLED:\n    from corporate.lib.registration import check_spare_licenses_available_for_registering_new_user\n    from corporate.lib.stripe import LicenseLimitError\n\n\n@has_request_variables\ndef get_prereg_key_and_redirect(\n    request: HttpRequest, confirmation_key: str, full_name: Optional[str] = REQ(default=None)\n) -> HttpResponse:\n    key_check_result = check_prereg_key(request, confirmation_key)\n    if isinstance(key_check_result, HttpResponse):\n        return key_check_result\n    # confirm_preregistrationuser.html just extracts the confirmation_key\n    # (and GET parameters) and redirects to /accounts/register, so that the\n    # user can enter their information on a cleaner URL.\n    return render(\n        request,\n        \"confirmation/confirm_preregistrationuser.html\",\n        context={\"key\": confirmation_key, \"full_name\": full_name},\n    )\n\n\ndef check_prereg_key(\n    request: HttpRequest, confirmation_key: str\n) -> Union[Confirmation, HttpResponse]:\n    \"\"\"\n    Checks if the Confirmation key is valid, returning the Confirmation object in case of success\n    and an appropriate error page otherwise.\n    \"\"\"\n    try:\n        confirmation: Optional[Confirmation] = Confirmation.objects.get(\n            confirmation_key=confirmation_key\n        )\n    except Confirmation.DoesNotExist:\n        confirmation = None\n\n    if confirmation is None or confirmation.type not in [\n        Confirmation.USER_REGISTRATION,\n        Confirmation.INVITATION,\n        Confirmation.REALM_CREATION,\n    ]:\n        return render_confirmation_key_error(\n            request, ConfirmationKeyException(ConfirmationKeyException.DOES_NOT_EXIST)\n        )\n\n    prereg_user = confirmation.content_object\n    assert prereg_user is not None\n    if prereg_user.status == confirmation_settings.STATUS_REVOKED:\n        return render(request, \"zerver/confirmation_link_expired_error.html\", status=404)\n\n    try:\n        get_object_from_key(confirmation_key, confirmation.type, activate_object=False)\n    except ConfirmationKeyException as exception:\n        return render_confirmation_key_error(request, exception)\n\n    return confirmation\n\n\n@require_post\n@has_request_variables\ndef accounts_register(\n    request: HttpRequest,\n    key: str = REQ(default=\"\"),\n    timezone: str = REQ(default=\"\", converter=to_timezone_or_empty),\n    from_confirmation: Optional[str] = REQ(default=None),\n    form_full_name: Optional[str] = REQ(\"full_name\", default=None),\n    source_realm_id: Optional[int] = REQ(\n        default=None, converter=to_converted_or_fallback(to_non_negative_int, None)\n    ),\n) -> HttpResponse:\n    key_check_result = check_prereg_key(request, key)\n    if isinstance(key_check_result, HttpResponse):\n        return key_check_result\n\n    prereg_user = key_check_result.content_object\n    assert prereg_user is not None\n    email = prereg_user.email\n    realm_creation = prereg_user.realm_creation\n    password_required = prereg_user.password_required\n\n    role = prereg_user.invited_as\n    if realm_creation:\n        role = UserProfile.ROLE_REALM_OWNER\n\n    try:\n        validators.validate_email(email)\n    except ValidationError:\n        return render(request, \"zerver/invalid_email.html\", context={\"invalid_email\": True})\n\n    if realm_creation:\n        # For creating a new realm, there is no existing realm or domain\n        realm = None\n    else:\n        if get_subdomain(request) != prereg_user.realm.string_id:\n            return render_confirmation_key_error(\n                request, ConfirmationKeyException(ConfirmationKeyException.DOES_NOT_EXIST)\n            )\n        realm = prereg_user.realm\n        try:\n            email_allowed_for_realm(email, realm)\n        except DomainNotAllowedForRealmError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"closed_domain\": True},\n            )\n        except DisposableEmailError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"disposable_emails_not_allowed\": True},\n            )\n        except EmailContainsPlusError:\n            return render(\n                request,\n                \"zerver/invalid_email.html\",\n                context={\"realm_name\": realm.name, \"email_contains_plus\": True},\n            )\n\n        if realm.deactivated:\n            # The user is trying to register for a deactivated realm. Advise them to\n            # contact support.\n            return redirect_to_deactivation_notice()\n\n        try:\n            validate_email_not_already_in_realm(realm, email)\n        except ValidationError:\n            return redirect_to_email_login_url(email)\n\n        if settings.BILLING_ENABLED:\n            try:\n                check_spare_licenses_available_for_registering_new_user(realm, email)\n            except LicenseLimitError:\n                return render(request, \"zerver/no_spare_licenses.html\")\n\n    name_validated = False\n    require_ldap_password = False\n\n    if from_confirmation:\n        try:\n            del request.session[\"authenticated_full_name\"]\n        except KeyError:\n            pass\n\n        ldap_full_name = None\n        if settings.POPULATE_PROFILE_VIA_LDAP:\n            # If the user can be found in LDAP, we'll take the full name from the directory,\n            # and further down create a form pre-filled with it.\n            for backend in get_backends():\n                if isinstance(backend, LDAPBackend):\n                    try:\n                        ldap_username = backend.django_to_ldap_username(email)\n                    except ZulipLDAPExceptionNoMatchingLDAPUser:\n                        logging.warning(\"New account email %s could not be found in LDAP\", email)\n                        break\n\n                    # Note that this `ldap_user` object is not a\n                    # `ZulipLDAPUser` with a `Realm` attached, so\n                    # calling `.populate_user()` on it will crash.\n                    # This is OK, since we're just accessing this user\n                    # to extract its name.\n                    #\n                    # TODO: We should potentially be accessing this\n                    # user to sync its initial avatar and custom\n                    # profile fields as well, if we indeed end up\n                    # creating a user account through this flow,\n                    # rather than waiting until `manage.py\n                    # sync_ldap_user_data` runs to populate it.\n                    ldap_user = _LDAPUser(backend, ldap_username)\n\n                    try:\n                        ldap_full_name = backend.get_mapped_name(ldap_user)\n                    except TypeError:\n                        break\n\n                    # Check whether this is ZulipLDAPAuthBackend,\n                    # which is responsible for authentication and\n                    # requires that LDAP accounts enter their LDAP\n                    # password to register, or ZulipLDAPUserPopulator,\n                    # which just populates UserProfile fields (no auth).\n                    require_ldap_password = isinstance(backend, ZulipLDAPAuthBackend)\n                    break\n\n        if ldap_full_name:\n            # We don't use initial= here, because if the form is\n            # complete (that is, no additional fields need to be\n            # filled out by the user) we want the form to validate,\n            # so they can be directly registered without having to\n            # go through this interstitial.\n            form = RegistrationForm({\"full_name\": ldap_full_name}, realm_creation=realm_creation)\n            request.session[\"authenticated_full_name\"] = ldap_full_name\n            name_validated = True\n        elif realm is not None and realm.is_zephyr_mirror_realm:\n            # For MIT users, we can get an authoritative name from Hesiod.\n            # Technically we should check that this is actually an MIT\n            # realm, but we can cross that bridge if we ever get a non-MIT\n            # zephyr mirroring realm.\n            hesiod_name = compute_mit_user_fullname(email)\n            form = RegistrationForm(\n                initial={\"full_name\": hesiod_name if \"@\" not in hesiod_name else \"\"},\n                realm_creation=realm_creation,\n            )\n            name_validated = True\n        elif prereg_user.full_name:\n            if prereg_user.full_name_validated:\n                request.session[\"authenticated_full_name\"] = prereg_user.full_name\n                name_validated = True\n                form = RegistrationForm(\n                    {\"full_name\": prereg_user.full_name}, realm_creation=realm_creation\n                )\n            else:\n                form = RegistrationForm(\n                    initial={\"full_name\": prereg_user.full_name}, realm_creation=realm_creation\n                )\n        elif form_full_name is not None:\n            form = RegistrationForm(\n                initial={\"full_name\": form_full_name},\n                realm_creation=realm_creation,\n            )\n        else:\n            form = RegistrationForm(realm_creation=realm_creation)\n    else:\n        postdata = request.POST.copy()\n        if name_changes_disabled(realm):\n            # If we populate profile information via LDAP and we have a\n            # verified name from you on file, use that. Otherwise, fall\n            # back to the full name in the request.\n            try:\n                postdata.update(full_name=request.session[\"authenticated_full_name\"])\n                name_validated = True\n            except KeyError:\n                pass\n        form = RegistrationForm(postdata, realm_creation=realm_creation)\n\n    if not (password_auth_enabled(realm) and password_required):\n        form[\"password\"].field.required = False\n\n    if form.is_valid():\n        if password_auth_enabled(realm) and form[\"password\"].field.required:\n            password = form.cleaned_data[\"password\"]\n        else:\n            # If the user wasn't prompted for a password when\n            # completing the authentication form (because they're\n            # signing up with SSO and no password is required), set\n            # the password field to `None` (Which causes Django to\n            # create an unusable password).\n            password = None\n\n        if realm_creation:\n            string_id = form.cleaned_data[\"realm_subdomain\"]\n            realm_name = form.cleaned_data[\"realm_name\"]\n            realm_type = form.cleaned_data[\"realm_type\"]\n            is_demo_org = form.cleaned_data[\"is_demo_organization\"]\n            realm = do_create_realm(\n                string_id, realm_name, org_type=realm_type, is_demo_organization=is_demo_org\n            )\n            setup_realm_internal_bots(realm)\n        assert realm is not None\n\n        full_name = form.cleaned_data[\"full_name\"]\n        enable_marketing_emails = form.cleaned_data[\"enable_marketing_emails\"]\n        default_stream_group_names = request.POST.getlist(\"default_stream_group\")\n        default_stream_groups = lookup_default_stream_groups(default_stream_group_names, realm)\n\n        if source_realm_id is not None:\n            # Non-integer realm_id values like \"string\" are treated\n            # like the \"Do not import\" value of \"\".\n            source_profile: Optional[UserProfile] = get_source_profile(email, source_realm_id)\n        else:\n            source_profile = None\n\n        if not realm_creation:\n            try:\n                existing_user_profile: Optional[UserProfile] = get_user_by_delivery_email(\n                    email, realm\n                )\n            except UserProfile.DoesNotExist:\n                existing_user_profile = None\n        else:\n            existing_user_profile = None\n\n        user_profile: Optional[UserProfile] = None\n        return_data: Dict[str, bool] = {}\n        if ldap_auth_enabled(realm):\n            # If the user was authenticated using an external SSO\n            # mechanism like Google or GitHub auth, then authentication\n            # will have already been done before creating the\n            # PreregistrationUser object with password_required=False, and\n            # so we don't need to worry about passwords.\n            #\n            # If instead the realm is using EmailAuthBackend, we will\n            # set their password above.\n            #\n            # But if the realm is using LDAPAuthBackend, we need to verify\n            # their LDAP password (which will, as a side effect, create\n            # the user account) here using authenticate.\n            # pregeg_user.realm_creation carries the information about whether\n            # we're in realm creation mode, and the ldap flow will handle\n            # that and create the user with the appropriate parameters.\n            user_profile = authenticate(\n                request=request,\n                username=email,\n                password=password,\n                realm=realm,\n                prereg_user=prereg_user,\n                return_data=return_data,\n            )\n            if user_profile is None:\n                can_use_different_backend = email_auth_enabled(realm) or (\n                    len(get_external_method_dicts(realm)) > 0\n                )\n                if settings.LDAP_APPEND_DOMAIN:\n                    # In LDAP_APPEND_DOMAIN configurations, we don't allow making a non-LDAP account\n                    # if the email matches the ldap domain.\n                    can_use_different_backend = can_use_different_backend and (\n                        not email_belongs_to_ldap(realm, email)\n                    )\n                if return_data.get(\"no_matching_ldap_user\") and can_use_different_backend:\n                    # If both the LDAP and Email or Social auth backends are\n                    # enabled, and there's no matching user in the LDAP\n                    # directory then the intent is to create a user in the\n                    # realm with their email outside the LDAP organization\n                    # (with e.g. a password stored in the Zulip database,\n                    # not LDAP).  So we fall through and create the new\n                    # account.\n                    pass\n                else:\n                    # TODO: This probably isn't going to give a\n                    # user-friendly error message, but it doesn't\n                    # particularly matter, because the registration form\n                    # is hidden for most users.\n                    view_url = reverse(\"login\")\n                    query = urlencode({\"email\": email})\n                    redirect_url = append_url_query_string(view_url, query)\n                    return HttpResponseRedirect(redirect_url)\n            elif not realm_creation:\n                # Since we'll have created a user, we now just log them in.\n                return login_and_go_to_home(request, user_profile)\n            else:\n                # With realm_creation=True, we're going to return further down,\n                # after finishing up the creation process.\n                pass\n\n        if existing_user_profile is not None and existing_user_profile.is_mirror_dummy:\n            user_profile = existing_user_profile\n            do_activate_mirror_dummy_user(user_profile, acting_user=user_profile)\n            do_change_password(user_profile, password)\n            do_change_full_name(user_profile, full_name, user_profile)\n            do_change_user_setting(user_profile, \"timezone\", timezone, acting_user=user_profile)\n            # TODO: When we clean up the `do_activate_mirror_dummy_user` code path,\n            # make it respect invited_as_admin / is_realm_admin.\n\n        if user_profile is None:\n            user_profile = do_create_user(\n                email,\n                password,\n                realm,\n                full_name,\n                prereg_user=prereg_user,\n                role=role,\n                tos_version=settings.TOS_VERSION,\n                timezone=timezone,\n                default_stream_groups=default_stream_groups,\n                source_profile=source_profile,\n                realm_creation=realm_creation,\n                acting_user=None,\n                enable_marketing_emails=enable_marketing_emails,\n            )\n\n        if realm_creation:\n            bulk_add_subscriptions(\n                realm, [realm.signup_notifications_stream], [user_profile], acting_user=None\n            )\n            send_initial_realm_messages(realm)\n\n            # Because for realm creation, registration happens on the\n            # root domain, we need to log them into the subdomain for\n            # their new realm.\n            return redirect_and_log_into_subdomain(\n                ExternalAuthResult(user_profile=user_profile, data_dict={\"is_realm_creation\": True})\n            )\n\n        # This dummy_backend check below confirms the user is\n        # authenticating to the correct subdomain.\n        auth_result = authenticate(\n            username=user_profile.delivery_email,\n            realm=realm,\n            return_data=return_data,\n            use_dummy_backend=True,\n        )\n        if return_data.get(\"invalid_subdomain\"):\n            # By construction, this should never happen.\n            logging.error(\n                \"Subdomain mismatch in registration %s: %s\",\n                realm.subdomain,\n                user_profile.delivery_email,\n            )\n            return redirect(\"/\")\n\n        return login_and_go_to_home(request, auth_result)\n\n    return render(\n        request,\n        \"zerver/register.html\",\n        context={\n            \"form\": form,\n            \"email\": email,\n            \"key\": key,\n            \"full_name\": request.session.get(\"authenticated_full_name\", None),\n            \"lock_name\": name_validated and name_changes_disabled(realm),\n            # password_auth_enabled is normally set via our context processor,\n            # but for the registration form, there is no logged in user yet, so\n            # we have to set it here.\n            \"creating_new_team\": realm_creation,\n            \"password_required\": password_auth_enabled(realm) and password_required,\n            \"require_ldap_password\": require_ldap_password,\n            \"password_auth_enabled\": password_auth_enabled(realm),\n            \"root_domain_available\": is_root_domain_available(),\n            \"default_stream_groups\": [] if realm is None else get_default_stream_groups(realm),\n            \"accounts\": get_accounts_for_email(email),\n            \"MAX_REALM_NAME_LENGTH\": str(Realm.MAX_REALM_NAME_LENGTH),\n            \"MAX_NAME_LENGTH\": str(UserProfile.MAX_NAME_LENGTH),\n            \"MAX_PASSWORD_LENGTH\": str(form.MAX_PASSWORD_LENGTH),\n            \"MAX_REALM_SUBDOMAIN_LENGTH\": str(Realm.MAX_REALM_SUBDOMAIN_LENGTH),\n            \"sorted_realm_types\": sorted(\n                Realm.ORG_TYPES.values(), key=lambda d: d[\"display_order\"]\n            ),\n        },\n    )\n\n\ndef login_and_go_to_home(request: HttpRequest, user_profile: UserProfile) -> HttpResponse:\n    mobile_flow_otp = get_expirable_session_var(\n        request.session, \"registration_mobile_flow_otp\", delete=True\n    )\n    desktop_flow_otp = get_expirable_session_var(\n        request.session, \"registration_desktop_flow_otp\", delete=True\n    )\n    if mobile_flow_otp is not None:\n        return finish_mobile_flow(request, user_profile, mobile_flow_otp)\n    elif desktop_flow_otp is not None:\n        return finish_desktop_flow(request, user_profile, desktop_flow_otp)\n\n    do_login(request, user_profile)\n    # Using 'mark_sanitized' to work around false positive where Pysa thinks\n    # that 'user_profile' is user-controlled\n    return HttpResponseRedirect(mark_sanitized(user_profile.realm.uri) + reverse(\"home\"))\n\n\ndef prepare_activation_url(\n    email: str,\n    request: HttpRequest,\n    realm_creation: bool = False,\n    streams: Optional[List[Stream]] = None,\n    invited_as: Optional[int] = None,\n) -> str:\n    \"\"\"\n    Send an email with a confirmation link to the provided e-mail so the user\n    can complete their registration.\n    \"\"\"\n    prereg_user = create_preregistration_user(email, request, realm_creation)\n\n    if streams is not None:\n        prereg_user.streams.set(streams)\n\n    if invited_as is not None:\n        prereg_user.invited_as = invited_as\n        prereg_user.save()\n\n    confirmation_type = Confirmation.USER_REGISTRATION\n    if realm_creation:\n        confirmation_type = Confirmation.REALM_CREATION\n\n    activation_url = create_confirmation_link(prereg_user, confirmation_type)\n    if settings.DEVELOPMENT and realm_creation:\n        request.session[\"confirmation_key\"] = {\"confirmation_key\": activation_url.split(\"/\")[-1]}\n    return activation_url\n\n\ndef send_confirm_registration_email(\n    email: str,\n    activation_url: str,\n    *,\n    realm: Optional[Realm] = None,\n    request: Optional[HttpRequest] = None,\n) -> None:\n    send_email(\n        \"zerver/emails/confirm_registration\",\n        to_emails=[email],\n        from_address=FromAddress.tokenized_no_reply_address(),\n        language=request.LANGUAGE_CODE if request is not None else None,\n        context={\n            \"create_realm\": (realm is None),\n            \"activate_url\": activation_url,\n        },\n        realm=realm,\n        request=request,\n    )\n\n\ndef redirect_to_email_login_url(email: str) -> HttpResponseRedirect:\n    login_url = reverse(\"login\")\n    redirect_url = append_url_query_string(\n        login_url, urlencode({\"email\": email, \"already_registered\": 1})\n    )\n    return HttpResponseRedirect(redirect_url)\n\n\ndef create_realm(request: HttpRequest, creation_key: Optional[str] = None) -> HttpResponse:\n    try:\n        key_record = validate_key(creation_key)\n    except RealmCreationKey.Invalid:\n        return render(\n            request,\n            \"zerver/realm_creation_failed.html\",\n            context={\n                \"message\": _(\"The organization creation link has expired\" \" or is not valid.\")\n            },\n        )\n    if not settings.OPEN_REALM_CREATION:\n        if key_record is None:\n            return render(\n                request,\n                \"zerver/realm_creation_failed.html\",\n                context={\"message\": _(\"New organization creation disabled\")},\n            )\n\n    # When settings.OPEN_REALM_CREATION is enabled, anyone can create a new realm,\n    # with a few restrictions on their email address.\n    if request.method == \"POST\":\n        form = RealmCreationForm(request.POST)\n        if form.is_valid():\n            try:\n                rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n            except RateLimited as e:\n                assert e.secs_to_freedom is not None\n                return render(\n                    request,\n                    \"zerver/rate_limit_exceeded.html\",\n                    context={\"retry_after\": int(e.secs_to_freedom)},\n                    status=429,\n                )\n\n            email = form.cleaned_data[\"email\"]\n            activation_url = prepare_activation_url(email, request, realm_creation=True)\n            if key_record is not None and key_record.presume_email_valid:\n                # The user has a token created from the server command line;\n                # skip confirming the email is theirs, taking their word for it.\n                # This is essential on first install if the admin hasn't stopped\n                # to configure outbound email up front, or it isn't working yet.\n                key_record.delete()\n                return HttpResponseRedirect(activation_url)\n\n            try:\n                send_confirm_registration_email(email, activation_url, request=request)\n            except EmailNotDeliveredException:\n                logging.error(\"Error in create_realm\")\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            if key_record is not None:\n                key_record.delete()\n            return HttpResponseRedirect(reverse(\"new_realm_send_confirm\", kwargs={\"email\": email}))\n    else:\n        form = RealmCreationForm()\n    return render(\n        request,\n        \"zerver/create_realm.html\",\n        context={\"form\": form, \"current_url\": request.get_full_path},\n    )\n\n\ndef accounts_home(\n    request: HttpRequest,\n    multiuse_object_key: str = \"\",\n    multiuse_object: Optional[MultiuseInvite] = None,\n) -> HttpResponse:\n    try:\n        realm = get_realm(get_subdomain(request))\n    except Realm.DoesNotExist:\n        return HttpResponseRedirect(reverse(find_account))\n    if realm.deactivated:\n        return redirect_to_deactivation_notice()\n\n    from_multiuse_invite = False\n    streams_to_subscribe = None\n    invited_as = None\n\n    if multiuse_object:\n        realm = multiuse_object.realm\n        streams_to_subscribe = multiuse_object.streams.all()\n        from_multiuse_invite = True\n        invited_as = multiuse_object.invited_as\n\n    if request.method == \"POST\":\n        form = HomepageForm(request.POST, realm=realm, from_multiuse_invite=from_multiuse_invite)\n        if form.is_valid():\n            try:\n                rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n            except RateLimited as e:\n                assert e.secs_to_freedom is not None\n                return render(\n                    request,\n                    \"zerver/rate_limit_exceeded.html\",\n                    context={\"retry_after\": int(e.secs_to_freedom)},\n                    status=429,\n                )\n\n            email = form.cleaned_data[\"email\"]\n\n            try:\n                validate_email_not_already_in_realm(realm, email)\n            except ValidationError:\n                return redirect_to_email_login_url(email)\n\n            activation_url = prepare_activation_url(\n                email, request, streams=streams_to_subscribe, invited_as=invited_as\n            )\n            try:\n                send_confirm_registration_email(email, activation_url, request=request, realm=realm)\n            except EmailNotDeliveredException:\n                logging.error(\"Error in accounts_home\")\n                return HttpResponseRedirect(\"/config-error/smtp\")\n\n            return HttpResponseRedirect(reverse(\"signup_send_confirm\", kwargs={\"email\": email}))\n\n    else:\n        form = HomepageForm(realm=realm)\n    context = login_context(request)\n    context.update(\n        form=form,\n        current_url=request.get_full_path,\n        multiuse_object_key=multiuse_object_key,\n        from_multiuse_invite=from_multiuse_invite,\n    )\n    return render(request, \"zerver/accounts_home.html\", context=context)\n\n\ndef accounts_home_from_multiuse_invite(request: HttpRequest, confirmation_key: str) -> HttpResponse:\n    multiuse_object = None\n    try:\n        multiuse_object = get_object_from_key(confirmation_key, Confirmation.MULTIUSE_INVITE)\n        # Required for OAuth 2\n    except ConfirmationKeyException as exception:\n        realm = get_realm_from_request(request)\n        if realm is None or realm.invite_required:\n            return render_confirmation_key_error(request, exception)\n    return accounts_home(\n        request, multiuse_object_key=confirmation_key, multiuse_object=multiuse_object\n    )\n\n\n@has_request_variables\ndef find_account(\n    request: HttpRequest, raw_emails: Optional[str] = REQ(\"emails\", default=None)\n) -> HttpResponse:\n    url = reverse(\"find_account\")\n\n    emails: List[str] = []\n    if request.method == \"POST\":\n        form = FindMyTeamForm(request.POST)\n        if form.is_valid():\n            emails = form.cleaned_data[\"emails\"]\n            for i in range(len(emails)):\n                try:\n                    rate_limit_request_by_ip(request, domain=\"sends_email_by_ip\")\n                except RateLimited as e:\n                    assert e.secs_to_freedom is not None\n                    return render(\n                        request,\n                        \"zerver/rate_limit_exceeded.html\",\n                        context={\"retry_after\": int(e.secs_to_freedom)},\n                        status=429,\n                    )\n\n            # Django doesn't support __iexact__in lookup with EmailField, so we have\n            # to use Qs to get around that without needing to do multiple queries.\n            emails_q = Q()\n            for email in emails:\n                emails_q |= Q(delivery_email__iexact=email)\n\n            user_profiles = UserProfile.objects.filter(\n                emails_q, is_active=True, is_bot=False, realm__deactivated=False\n            )\n\n            # We organize the data in preparation for sending exactly\n            # one outgoing email per provided email address, with each\n            # email listing all of the accounts that email address has\n            # with the current Zulip server.\n            context: Dict[str, Dict[str, Any]] = {}\n            for user in user_profiles:\n                key = user.delivery_email.lower()\n                context.setdefault(key, {})\n                context[key].setdefault(\"realms\", [])\n                context[key][\"realms\"].append(user.realm)\n                context[key][\"external_host\"] = settings.EXTERNAL_HOST\n                # This value will end up being the last user ID among\n                # matching accounts; since it's only used for minor\n                # details like language, that arbitrary choice is OK.\n                context[key][\"to_user_id\"] = user.id\n\n            for delivery_email, realm_context in context.items():\n                realm_context[\"email\"] = delivery_email\n                send_email(\n                    \"zerver/emails/find_team\",\n                    to_user_ids=[realm_context[\"to_user_id\"]],\n                    context=realm_context,\n                    from_address=FromAddress.SUPPORT,\n                    request=request,\n                )\n\n            # Note: Show all the emails in the result otherwise this\n            # feature can be used to ascertain which email addresses\n            # are associated with Zulip.\n            data = urllib.parse.urlencode({\"emails\": \",\".join(emails)})\n            return redirect(append_url_query_string(url, data))\n    else:\n        form = FindMyTeamForm()\n        # The below validation is perhaps unnecessary, in that we\n        # shouldn't get able to get here with an invalid email unless\n        # the user hand-edits the URLs.\n        if raw_emails:\n            for email in raw_emails.split(\",\"):\n                try:\n                    validators.validate_email(email)\n                    emails.append(email)\n                except ValidationError:\n                    pass\n\n    return render(\n        request,\n        \"zerver/find_account.html\",\n        context={\"form\": form, \"current_url\": lambda: url, \"emails\": emails},\n    )\n\n\n@has_request_variables\ndef realm_redirect(request: HttpRequest, next: str = REQ(default=\"\")) -> HttpResponse:\n    if request.method == \"POST\":\n        form = RealmRedirectForm(request.POST)\n        if form.is_valid():\n            subdomain = form.cleaned_data[\"subdomain\"]\n            realm = get_realm(subdomain)\n            redirect_to = get_safe_redirect_to(next, realm.uri)\n            return HttpResponseRedirect(redirect_to)\n    else:\n        form = RealmRedirectForm()\n\n    return render(request, \"zerver/realm_redirect.html\", context={\"form\": form})\n", "import os\nfrom typing import List, Union\n\nfrom django.conf import settings\nfrom django.conf.urls import include\nfrom django.conf.urls.i18n import i18n_patterns\nfrom django.contrib.auth.views import (\n    LoginView,\n    PasswordResetCompleteView,\n    PasswordResetConfirmView,\n    PasswordResetDoneView,\n)\nfrom django.urls import path, re_path\nfrom django.urls.resolvers import URLPattern, URLResolver\nfrom django.utils.module_loading import import_string\nfrom django.views.generic import RedirectView, TemplateView\n\nfrom zerver.forms import LoggingSetPasswordForm\nfrom zerver.lib.integrations import WEBHOOK_INTEGRATIONS\nfrom zerver.lib.rest import rest_path\nfrom zerver.tornado.views import cleanup_event_queue, get_events, get_events_internal, notify\nfrom zerver.views.alert_words import add_alert_words, list_alert_words, remove_alert_words\nfrom zerver.views.attachments import list_by_user, remove\nfrom zerver.views.auth import (\n    api_fetch_api_key,\n    api_get_server_settings,\n    json_fetch_api_key,\n    log_into_subdomain,\n    login_page,\n    logout_then_login,\n    password_reset,\n    remote_user_jwt,\n    remote_user_sso,\n    saml_sp_metadata,\n    show_deactivation_notice,\n    start_remote_user_sso,\n    start_social_login,\n    start_social_signup,\n)\nfrom zerver.views.compatibility import check_global_compatibility\nfrom zerver.views.custom_profile_fields import (\n    create_realm_custom_profile_field,\n    delete_realm_custom_profile_field,\n    list_realm_custom_profile_fields,\n    remove_user_custom_profile_data,\n    reorder_realm_custom_profile_fields,\n    update_realm_custom_profile_field,\n    update_user_custom_profile_data,\n)\nfrom zerver.views.digest import digest_page\nfrom zerver.views.documentation import IntegrationView, MarkdownDirectoryView, integration_doc\nfrom zerver.views.drafts import create_drafts, delete_draft, edit_draft, fetch_drafts\nfrom zerver.views.email_mirror import email_mirror_message\nfrom zerver.views.events_register import events_register_backend\nfrom zerver.views.home import accounts_accept_terms, desktop_home, home\nfrom zerver.views.hotspots import mark_hotspot_as_read\nfrom zerver.views.invite import (\n    generate_multiuse_invite_backend,\n    get_user_invites,\n    invite_users_backend,\n    resend_user_invite_email,\n    revoke_multiuse_invite,\n    revoke_user_invite,\n)\nfrom zerver.views.message_edit import (\n    delete_message_backend,\n    get_message_edit_history,\n    json_fetch_raw_message,\n    update_message_backend,\n)\nfrom zerver.views.message_fetch import get_messages_backend, messages_in_narrow_backend\nfrom zerver.views.message_flags import (\n    mark_all_as_read,\n    mark_stream_as_read,\n    mark_topic_as_read,\n    update_message_flags,\n)\nfrom zerver.views.message_send import render_message_backend, send_message_backend, zcommand_backend\nfrom zerver.views.muting import mute_user, unmute_user, update_muted_topic\nfrom zerver.views.portico import (\n    app_download_link_redirect,\n    apps_view,\n    hello_view,\n    landing_view,\n    plans_view,\n    privacy_view,\n    team_view,\n    terms_view,\n)\nfrom zerver.views.presence import (\n    get_presence_backend,\n    get_statuses_for_realm,\n    update_active_status_backend,\n    update_user_status_backend,\n)\nfrom zerver.views.push_notifications import (\n    add_android_reg_id,\n    add_apns_device_token,\n    remove_android_reg_id,\n    remove_apns_device_token,\n)\nfrom zerver.views.reactions import add_reaction, remove_reaction\nfrom zerver.views.realm import (\n    check_subdomain_available,\n    deactivate_realm,\n    realm_reactivation,\n    update_realm,\n    update_realm_user_settings_defaults,\n)\nfrom zerver.views.realm_domains import (\n    create_realm_domain,\n    delete_realm_domain,\n    list_realm_domains,\n    patch_realm_domain,\n)\nfrom zerver.views.realm_emoji import delete_emoji, list_emoji, upload_emoji\nfrom zerver.views.realm_export import delete_realm_export, export_realm, get_realm_exports\nfrom zerver.views.realm_icon import delete_icon_backend, get_icon_backend, upload_icon\nfrom zerver.views.realm_linkifiers import (\n    create_linkifier,\n    delete_linkifier,\n    list_linkifiers,\n    update_linkifier,\n)\nfrom zerver.views.realm_logo import delete_logo_backend, get_logo_backend, upload_logo\nfrom zerver.views.realm_playgrounds import add_realm_playground, delete_realm_playground\nfrom zerver.views.registration import (\n    accounts_home,\n    accounts_home_from_multiuse_invite,\n    accounts_register,\n    create_realm,\n    find_account,\n    get_prereg_key_and_redirect,\n    realm_redirect,\n)\nfrom zerver.views.report import (\n    report_csp_violations,\n    report_error,\n    report_narrow_times,\n    report_send_times,\n    report_unnarrow_times,\n)\nfrom zerver.views.storage import get_storage, remove_storage, update_storage\nfrom zerver.views.streams import (\n    add_default_stream,\n    add_subscriptions_backend,\n    create_default_stream_group,\n    deactivate_stream_backend,\n    delete_in_topic,\n    get_streams_backend,\n    get_subscribers_backend,\n    get_topics_backend,\n    json_get_stream_id,\n    list_subscriptions_backend,\n    remove_default_stream,\n    remove_default_stream_group,\n    remove_subscriptions_backend,\n    update_default_stream_group_info,\n    update_default_stream_group_streams,\n    update_stream_backend,\n    update_subscription_properties_backend,\n    update_subscriptions_backend,\n    update_subscriptions_property,\n)\nfrom zerver.views.submessage import process_submessage\nfrom zerver.views.thumbnail import backend_serve_thumbnail\nfrom zerver.views.tutorial import set_tutorial_status\nfrom zerver.views.typing import send_notification_backend\nfrom zerver.views.unsubscribe import email_unsubscribe\nfrom zerver.views.upload import (\n    serve_file_backend,\n    serve_file_url_backend,\n    serve_local_file_unauthed,\n    upload_file_backend,\n)\nfrom zerver.views.user_groups import (\n    add_user_group,\n    delete_user_group,\n    edit_user_group,\n    get_user_group,\n    update_user_group_backend,\n)\nfrom zerver.views.user_settings import (\n    confirm_email_change,\n    delete_avatar_backend,\n    json_change_settings,\n    regenerate_api_key,\n    set_avatar_backend,\n)\nfrom zerver.views.users import (\n    add_bot_backend,\n    avatar,\n    create_user_backend,\n    deactivate_bot_backend,\n    deactivate_user_backend,\n    deactivate_user_own_backend,\n    get_bots_backend,\n    get_members_backend,\n    get_profile_backend,\n    get_subscription_backend,\n    get_user_by_email,\n    patch_bot_backend,\n    reactivate_user_backend,\n    regenerate_bot_api_key,\n    update_user_backend,\n)\nfrom zerver.views.video_calls import (\n    complete_zoom_user,\n    deauthorize_zoom_user,\n    get_bigbluebutton_url,\n    join_bigbluebutton,\n    make_zoom_video_call,\n    register_zoom_user,\n)\nfrom zerver.views.zephyr import webathena_kerberos_login\nfrom zproject import dev_urls\nfrom zproject.legacy_urls import legacy_urls\n\nif settings.TWO_FACTOR_AUTHENTICATION_ENABLED:\n    from two_factor.gateways.twilio.urls import urlpatterns as tf_twilio_urls\n    from two_factor.urls import urlpatterns as tf_urls\n\n# NB: There are several other pieces of code which route requests by URL:\n#\n#   - legacy_urls.py contains API endpoint written before the redesign\n#     and should not be added to.\n#\n#   - runtornado.py has its own URL list for Tornado views.  See the\n#     invocation of web.Application in that file.\n#\n#   - The Nginx config knows which URLs to route to Django or Tornado.\n#\n#   - Likewise for the local dev server in tools/run-dev.py.\n\n# These endpoints constitute the currently designed API (V1), which uses:\n# * REST verbs\n# * Basic auth (username:password is email:apiKey)\n# * Take and return json-formatted data\n#\n# If you're adding a new endpoint to the code that requires authentication,\n# please add it here.\n# See rest_dispatch in zerver.lib.rest for an explanation of auth methods used\n#\n# All of these paths are accessed by either a /json or /api/v1 prefix;\n# e.g. `PATCH /json/realm` or `PATCH /api/v1/realm`.\nv1_api_and_json_patterns = [\n    # realm-level calls\n    rest_path(\"realm\", PATCH=update_realm),\n    rest_path(\"realm/user_settings_defaults\", PATCH=update_realm_user_settings_defaults),\n    path(\"realm/subdomain/<subdomain>\", check_subdomain_available),\n    # realm/domains -> zerver.views.realm_domains\n    rest_path(\"realm/domains\", GET=list_realm_domains, POST=create_realm_domain),\n    rest_path(\"realm/domains/<domain>\", PATCH=patch_realm_domain, DELETE=delete_realm_domain),\n    # realm/emoji -> zerver.views.realm_emoji\n    rest_path(\"realm/emoji\", GET=list_emoji),\n    rest_path(\n        \"realm/emoji/<emoji_name>\",\n        POST=upload_emoji,\n        DELETE=(delete_emoji, {\"intentionally_undocumented\"}),\n    ),\n    # this endpoint throws a status code 400 JsonableError when it should be a 404.\n    # realm/icon -> zerver.views.realm_icon\n    rest_path(\"realm/icon\", POST=upload_icon, DELETE=delete_icon_backend, GET=get_icon_backend),\n    # realm/logo -> zerver.views.realm_logo\n    rest_path(\"realm/logo\", POST=upload_logo, DELETE=delete_logo_backend, GET=get_logo_backend),\n    # realm/filters and realm/linkifiers -> zerver.views.realm_linkifiers\n    rest_path(\"realm/linkifiers\", GET=list_linkifiers),\n    rest_path(\"realm/filters\", POST=create_linkifier),\n    rest_path(\"realm/filters/<int:filter_id>\", DELETE=delete_linkifier, PATCH=update_linkifier),\n    # realm/playgrounds -> zerver.views.realm_playgrounds\n    rest_path(\"realm/playgrounds\", POST=add_realm_playground),\n    rest_path(\"realm/playgrounds/<int:playground_id>\", DELETE=delete_realm_playground),\n    # realm/profile_fields -> zerver.views.custom_profile_fields\n    rest_path(\n        \"realm/profile_fields\",\n        GET=list_realm_custom_profile_fields,\n        PATCH=reorder_realm_custom_profile_fields,\n        POST=create_realm_custom_profile_field,\n    ),\n    rest_path(\n        \"realm/profile_fields/<int:field_id>\",\n        PATCH=update_realm_custom_profile_field,\n        DELETE=delete_realm_custom_profile_field,\n    ),\n    # realm/deactivate -> zerver.views.deactivate_realm\n    rest_path(\"realm/deactivate\", POST=deactivate_realm),\n    # users -> zerver.views.users\n    rest_path(\"users\", GET=get_members_backend, POST=create_user_backend),\n    rest_path(\"users/me\", GET=get_profile_backend, DELETE=deactivate_user_own_backend),\n    rest_path(\"users/<int:user_id>/reactivate\", POST=reactivate_user_backend),\n    rest_path(\n        \"users/<int:user_id>\",\n        GET=get_members_backend,\n        PATCH=update_user_backend,\n        DELETE=deactivate_user_backend,\n    ),\n    rest_path(\"users/<int:user_id>/subscriptions/<int:stream_id>\", GET=get_subscription_backend),\n    rest_path(\"users/<email>\", GET=get_user_by_email),\n    rest_path(\"bots\", GET=get_bots_backend, POST=add_bot_backend),\n    rest_path(\"bots/<int:bot_id>/api_key/regenerate\", POST=regenerate_bot_api_key),\n    rest_path(\"bots/<int:bot_id>\", PATCH=patch_bot_backend, DELETE=deactivate_bot_backend),\n    # invites -> zerver.views.invite\n    rest_path(\"invites\", GET=get_user_invites, POST=invite_users_backend),\n    rest_path(\"invites/<int:prereg_id>\", DELETE=revoke_user_invite),\n    rest_path(\"invites/<int:prereg_id>/resend\", POST=resend_user_invite_email),\n    # invites/multiuse -> zerver.views.invite\n    rest_path(\"invites/multiuse\", POST=generate_multiuse_invite_backend),\n    # invites/multiuse -> zerver.views.invite\n    rest_path(\"invites/multiuse/<int:invite_id>\", DELETE=revoke_multiuse_invite),\n    # mark messages as read (in bulk)\n    rest_path(\"mark_all_as_read\", POST=mark_all_as_read),\n    rest_path(\"mark_stream_as_read\", POST=mark_stream_as_read),\n    rest_path(\"mark_topic_as_read\", POST=mark_topic_as_read),\n    rest_path(\"zcommand\", POST=zcommand_backend),\n    # Endpoints for syncing drafts.\n    rest_path(\"drafts\", GET=fetch_drafts, POST=create_drafts),\n    rest_path(\"drafts/<int:draft_id>\", PATCH=edit_draft, DELETE=delete_draft),\n    # messages -> zerver.views.message*\n    # GET returns messages, possibly filtered, POST sends a message\n    rest_path(\n        \"messages\",\n        GET=(get_messages_backend, {\"allow_anonymous_user_web\"}),\n        POST=(send_message_backend, {\"allow_incoming_webhooks\"}),\n    ),\n    rest_path(\n        \"messages/<int:message_id>\",\n        GET=(json_fetch_raw_message, {\"allow_anonymous_user_web\"}),\n        PATCH=update_message_backend,\n        DELETE=delete_message_backend,\n    ),\n    rest_path(\"messages/render\", POST=render_message_backend),\n    rest_path(\"messages/flags\", POST=update_message_flags),\n    rest_path(\"messages/<int:message_id>/history\", GET=get_message_edit_history),\n    rest_path(\"messages/matches_narrow\", GET=messages_in_narrow_backend),\n    rest_path(\"users/me/subscriptions/properties\", POST=update_subscription_properties_backend),\n    rest_path(\"users/me/subscriptions/<int:stream_id>\", PATCH=update_subscriptions_property),\n    rest_path(\"submessage\", POST=process_submessage),\n    # New endpoint for handling reactions.\n    # reactions -> zerver.view.reactions\n    # POST adds a reaction to a message\n    # DELETE removes a reaction from a message\n    rest_path(\"messages/<int:message_id>/reactions\", POST=add_reaction, DELETE=remove_reaction),\n    # attachments -> zerver.views.attachments\n    rest_path(\"attachments\", GET=list_by_user),\n    rest_path(\"attachments/<int:attachment_id>\", DELETE=remove),\n    # typing -> zerver.views.typing\n    # POST sends a typing notification event to recipients\n    rest_path(\"typing\", POST=send_notification_backend),\n    # user_uploads -> zerver.views.upload\n    rest_path(\"user_uploads\", POST=upload_file_backend),\n    rest_path(\n        \"user_uploads/<realm_id_str>/<path:filename>\",\n        GET=(serve_file_url_backend, {\"override_api_url_scheme\"}),\n    ),\n    # bot_storage -> zerver.views.storage\n    rest_path(\"bot_storage\", PUT=update_storage, GET=get_storage, DELETE=remove_storage),\n    # Endpoint used by mobile devices to register their push\n    # notification credentials\n    rest_path(\n        \"users/me/apns_device_token\", POST=add_apns_device_token, DELETE=remove_apns_device_token\n    ),\n    rest_path(\"users/me/android_gcm_reg_id\", POST=add_android_reg_id, DELETE=remove_android_reg_id),\n    # users/*/presnece => zerver.views.presence.\n    rest_path(\"users/me/presence\", POST=update_active_status_backend),\n    # It's important that this sit after users/me/presence so that\n    # Django's URL resolution order doesn't break the\n    # /users/me/presence endpoint.\n    rest_path(\"users/<user_id_or_email>/presence\", GET=get_presence_backend),\n    rest_path(\"realm/presence\", GET=get_statuses_for_realm),\n    rest_path(\"users/me/status\", POST=update_user_status_backend),\n    # user_groups -> zerver.views.user_groups\n    rest_path(\"user_groups\", GET=get_user_group),\n    rest_path(\"user_groups/create\", POST=add_user_group),\n    rest_path(\"user_groups/<int:user_group_id>\", PATCH=edit_user_group, DELETE=delete_user_group),\n    rest_path(\"user_groups/<int:user_group_id>/members\", POST=update_user_group_backend),\n    # users/me -> zerver.views.user_settings\n    rest_path(\"users/me/api_key/regenerate\", POST=regenerate_api_key),\n    rest_path(\"users/me/avatar\", POST=set_avatar_backend, DELETE=delete_avatar_backend),\n    # users/me/hotspots -> zerver.views.hotspots\n    rest_path(\n        \"users/me/hotspots\",\n        POST=(\n            mark_hotspot_as_read,\n            # This endpoint is low priority for documentation as\n            # it is part of the web app-specific tutorial.\n            {\"intentionally_undocumented\"},\n        ),\n    ),\n    # users/me/tutorial_status -> zerver.views.tutorial\n    rest_path(\n        \"users/me/tutorial_status\",\n        POST=(\n            set_tutorial_status,\n            # This is a relic of an old Zulip tutorial model and\n            # should be deleted.\n            {\"intentionally_undocumented\"},\n        ),\n    ),\n    # settings -> zerver.views.user_settings\n    rest_path(\"settings\", PATCH=json_change_settings),\n    # These next two are legacy aliases for /settings, from before\n    # we merged the endpoints. They are documented in the `/json/settings`\n    # documentation, rather than having dedicated pages.\n    rest_path(\"settings/display\", PATCH=(json_change_settings, {\"intentionally_undocumented\"})),\n    rest_path(\n        \"settings/notifications\", PATCH=(json_change_settings, {\"intentionally_undocumented\"})\n    ),\n    # users/me/alert_words -> zerver.views.alert_words\n    rest_path(\n        \"users/me/alert_words\",\n        GET=list_alert_words,\n        POST=add_alert_words,\n        DELETE=remove_alert_words,\n    ),\n    # users/me/custom_profile_data -> zerver.views.custom_profile_data\n    rest_path(\n        \"users/me/profile_data\",\n        PATCH=update_user_custom_profile_data,\n        DELETE=remove_user_custom_profile_data,\n    ),\n    rest_path(\n        \"users/me/<int:stream_id>/topics\", GET=(get_topics_backend, {\"allow_anonymous_user_web\"})\n    ),\n    # streams -> zerver.views.streams\n    # (this API is only used externally)\n    rest_path(\"streams\", GET=get_streams_backend),\n    # GET returns `stream_id`, stream name should be encoded in the URL query (in `stream` param)\n    rest_path(\"get_stream_id\", GET=json_get_stream_id),\n    # GET returns \"stream info\" (undefined currently?), HEAD returns whether stream exists (200 or 404)\n    rest_path(\"streams/<int:stream_id>/members\", GET=get_subscribers_backend),\n    rest_path(\n        \"streams/<int:stream_id>\", PATCH=update_stream_backend, DELETE=deactivate_stream_backend\n    ),\n    # Delete topic in stream\n    rest_path(\"streams/<int:stream_id>/delete_topic\", POST=delete_in_topic),\n    rest_path(\"default_streams\", POST=add_default_stream, DELETE=remove_default_stream),\n    rest_path(\"default_stream_groups/create\", POST=create_default_stream_group),\n    rest_path(\n        \"default_stream_groups/<int:group_id>\",\n        PATCH=update_default_stream_group_info,\n        DELETE=remove_default_stream_group,\n    ),\n    rest_path(\n        \"default_stream_groups/<int:group_id>/streams\", PATCH=update_default_stream_group_streams\n    ),\n    # GET lists your streams, POST bulk adds, PATCH bulk modifies/removes\n    rest_path(\n        \"users/me/subscriptions\",\n        GET=list_subscriptions_backend,\n        POST=add_subscriptions_backend,\n        PATCH=update_subscriptions_backend,\n        DELETE=remove_subscriptions_backend,\n    ),\n    # muting -> zerver.views.muting\n    rest_path(\"users/me/subscriptions/muted_topics\", PATCH=update_muted_topic),\n    rest_path(\"users/me/muted_users/<int:muted_user_id>\", POST=mute_user, DELETE=unmute_user),\n    # used to register for an event queue in tornado\n    rest_path(\"register\", POST=events_register_backend),\n    # events -> zerver.tornado.views\n    rest_path(\"events\", GET=get_events, DELETE=cleanup_event_queue),\n    # report -> zerver.views.report\n    #\n    # These endpoints are for internal error/performance reporting\n    # from the browser to the web app, and we don't expect to ever\n    # include in our API documentation.\n    rest_path(\n        \"report/error\",\n        # Logged-out browsers can hit this endpoint, for portico page JS exceptions.\n        POST=(report_error, {\"allow_anonymous_user_web\", \"intentionally_undocumented\"}),\n    ),\n    rest_path(\"report/send_times\", POST=(report_send_times, {\"intentionally_undocumented\"})),\n    rest_path(\n        \"report/narrow_times\",\n        POST=(report_narrow_times, {\"allow_anonymous_user_web\", \"intentionally_undocumented\"}),\n    ),\n    rest_path(\n        \"report/unnarrow_times\",\n        POST=(report_unnarrow_times, {\"allow_anonymous_user_web\", \"intentionally_undocumented\"}),\n    ),\n    # Used to generate a Zoom video call URL\n    rest_path(\"calls/zoom/create\", POST=make_zoom_video_call),\n    # Used to generate a BigBlueButton video call URL\n    rest_path(\"calls/bigbluebutton/create\", GET=get_bigbluebutton_url),\n    # export/realm -> zerver.views.realm_export\n    rest_path(\"export/realm\", POST=export_realm, GET=get_realm_exports),\n    rest_path(\"export/realm/<int:export_id>\", DELETE=delete_realm_export),\n]\n\nintegrations_view = IntegrationView.as_view()\n\n# These views serve pages (HTML). As such, their internationalization\n# must depend on the URL.\n#\n# If you're adding a new page to the website (as opposed to a new\n# endpoint for use by code), you should add it here.\ni18n_urls = [\n    path(\"\", home, name=\"home\"),\n    # We have a desktop-specific landing page in case we change our /\n    # to not log in in the future. We don't want to require a new\n    # desktop app build for everyone in that case\n    path(\"desktop_home/\", desktop_home),\n    # Backwards-compatibility (legacy) Google auth URL for the mobile\n    # apps; see https://github.com/zulip/zulip/issues/13081 for\n    # background.  We can remove this once older versions of the\n    # mobile app are no longer present in the wild.\n    path(\"accounts/login/google/\", start_social_login, {\"backend\": \"google\"}),\n    path(\"accounts/login/start/sso/\", start_remote_user_sso, name=\"start-login-sso\"),\n    path(\"accounts/login/sso/\", remote_user_sso, name=\"login-sso\"),\n    path(\"accounts/login/jwt/\", remote_user_jwt),\n    path(\"accounts/login/social/<backend>\", start_social_login, name=\"login-social\"),\n    path(\"accounts/login/social/<backend>/<extra_arg>\", start_social_login, name=\"login-social\"),\n    path(\"accounts/register/social/<backend>\", start_social_signup, name=\"signup-social\"),\n    path(\n        \"accounts/register/social/<backend>/<extra_arg>\", start_social_signup, name=\"signup-social\"\n    ),\n    path(\"accounts/login/subdomain/<token>\", log_into_subdomain),\n    # We have two entries for accounts/login; only the first one is\n    # used for URL resolution.  The second here is to allow\n    # reverse(\"login\") in templates to\n    # return `/accounts/login/`.\n    path(\"accounts/login/\", login_page, {\"template_name\": \"zerver/login.html\"}, name=\"login_page\"),\n    path(\"accounts/login/\", LoginView.as_view(template_name=\"zerver/login.html\"), name=\"login\"),\n    path(\"accounts/logout/\", logout_then_login),\n    path(\"accounts/webathena_kerberos_login/\", webathena_kerberos_login),\n    path(\"accounts/password/reset/\", password_reset, name=\"password_reset\"),\n    path(\n        \"accounts/password/reset/done/\",\n        PasswordResetDoneView.as_view(template_name=\"zerver/reset_emailed.html\"),\n    ),\n    path(\n        \"accounts/password/reset/<uidb64>/<token>/\",\n        PasswordResetConfirmView.as_view(\n            success_url=\"/accounts/password/done/\",\n            template_name=\"zerver/reset_confirm.html\",\n            form_class=LoggingSetPasswordForm,\n        ),\n        name=\"password_reset_confirm\",\n    ),\n    path(\n        \"accounts/password/done/\",\n        PasswordResetCompleteView.as_view(template_name=\"zerver/reset_done.html\"),\n    ),\n    path(\"accounts/deactivated/\", show_deactivation_notice),\n    # Displays digest email content in browser.\n    path(\"digest/\", digest_page),\n    # Registration views, require a confirmation ID.\n    path(\"accounts/home/\", accounts_home),\n    path(\n        \"accounts/send_confirm/<email>\",\n        TemplateView.as_view(template_name=\"zerver/accounts_send_confirm.html\"),\n        name=\"signup_send_confirm\",\n    ),\n    path(\n        \"accounts/new/send_confirm/<email>\",\n        TemplateView.as_view(template_name=\"zerver/accounts_send_confirm.html\"),\n        {\"realm_creation\": True},\n        name=\"new_realm_send_confirm\",\n    ),\n    path(\"accounts/register/\", accounts_register, name=\"accounts_register\"),\n    path(\n        \"accounts/do_confirm/<confirmation_key>\",\n        get_prereg_key_and_redirect,\n        name=\"get_prereg_key_and_redirect\",\n    ),\n    path(\n        \"accounts/confirm_new_email/<confirmation_key>\",\n        confirm_email_change,\n        name=\"confirm_email_change\",\n    ),\n    # Email unsubscription endpoint. Allows for unsubscribing from various types of emails,\n    # including the welcome emails (day 1 & 2), missed PMs, etc.\n    path(\n        \"accounts/unsubscribe/<email_type>/<confirmation_key>\",\n        email_unsubscribe,\n        name=\"unsubscribe\",\n    ),\n    # Portico-styled page used to provide email confirmation of terms acceptance.\n    path(\"accounts/accept_terms/\", accounts_accept_terms, name=\"accept_terms\"),\n    # Find your account\n    path(\"accounts/find/\", find_account, name=\"find_account\"),\n    # Go to organization subdomain\n    path(\"accounts/go/\", realm_redirect, name=\"realm_redirect\"),\n    # Realm creation\n    path(\"new/\", create_realm),\n    path(\"new/<creation_key>\", create_realm, name=\"create_realm\"),\n    # Realm reactivation\n    path(\"reactivate/<confirmation_key>\", realm_reactivation, name=\"realm_reactivation\"),\n    # Login/registration\n    path(\"register/\", accounts_home, name=\"register\"),\n    path(\"login/\", login_page, {\"template_name\": \"zerver/login.html\"}, name=\"login_page\"),\n    path(\"join/<confirmation_key>/\", accounts_home_from_multiuse_invite, name=\"join\"),\n    # Used to generate a Zoom video call URL\n    path(\"calls/zoom/register\", register_zoom_user),\n    path(\"calls/zoom/complete\", complete_zoom_user),\n    path(\"calls/zoom/deauthorize\", deauthorize_zoom_user),\n    # Used to join a BigBlueButton video call\n    path(\"calls/bigbluebutton/join\", join_bigbluebutton),\n    # API and integrations documentation\n    path(\"integrations/doc-html/<integration_name>\", integration_doc),\n    path(\"integrations/\", integrations_view),\n    path(\"integrations/<path:path>\", integrations_view),\n    # Landing page, features pages, signup form, etc.\n    path(\"hello/\", hello_view),\n    path(\"new-user/\", RedirectView.as_view(url=\"/hello\", permanent=True)),\n    path(\"features/\", landing_view, {\"template_name\": \"zerver/features.html\"}),\n    path(\"plans/\", plans_view, name=\"plans\"),\n    path(\"apps/\", apps_view),\n    path(\"apps/download/<platform>\", app_download_link_redirect),\n    path(\"apps/<platform>\", apps_view),\n    path(\n        \"development-community/\",\n        landing_view,\n        {\"template_name\": \"zerver/development-community.html\"},\n    ),\n    path(\"attribution/\", landing_view, {\"template_name\": \"zerver/attribution.html\"}),\n    path(\"team/\", team_view),\n    path(\"history/\", landing_view, {\"template_name\": \"zerver/history.html\"}),\n    path(\"why-zulip/\", landing_view, {\"template_name\": \"zerver/why-zulip.html\"}),\n    path(\"for/education/\", landing_view, {\"template_name\": \"zerver/for-education.html\"}),\n    path(\"for/events/\", landing_view, {\"template_name\": \"zerver/for-events.html\"}),\n    path(\"for/open-source/\", landing_view, {\"template_name\": \"zerver/for-open-source.html\"}),\n    path(\"for/research/\", landing_view, {\"template_name\": \"zerver/for-research.html\"}),\n    path(\"for/companies/\", landing_view, {\"template_name\": \"zerver/for-companies.html\"}),\n    path(\"case-studies/tum/\", landing_view, {\"template_name\": \"zerver/tum-case-study.html\"}),\n    path(\"case-studies/ucsd/\", landing_view, {\"template_name\": \"zerver/ucsd-case-study.html\"}),\n    path(\"case-studies/rust/\", landing_view, {\"template_name\": \"zerver/rust-case-study.html\"}),\n    path(\"case-studies/lean/\", landing_view, {\"template_name\": \"zerver/lean-case-study.html\"}),\n    path(\n        \"for/communities/\",\n        landing_view,\n        {\"template_name\": \"zerver/for-communities.html\"},\n    ),\n    # We merged this into /for/communities.\n    path(\n        \"for/working-groups-and-communities/\",\n        RedirectView.as_view(url=\"/for/communities/\", permanent=True),\n    ),\n    path(\"security/\", landing_view, {\"template_name\": \"zerver/security.html\"}),\n    # Terms of Service and privacy pages.\n    path(\"terms/\", terms_view),\n    path(\"privacy/\", privacy_view),\n    path(\n        \"developer-community/\", RedirectView.as_view(url=\"/development-community/\", permanent=True)\n    ),\n]\n\n# Make a copy of i18n_urls so that they appear without prefix for english\nurls: List[Union[URLPattern, URLResolver]] = list(i18n_urls)\n\n# Include the dual-use patterns twice\nurls += [\n    path(\"api/v1/\", include(v1_api_and_json_patterns)),\n    path(\"json/\", include(v1_api_and_json_patterns)),\n]\n\n# user_uploads -> zerver.views.upload.serve_file_backend\n#\n# This URL is an exception to the URL naming schemes for endpoints. It\n# supports both API and session cookie authentication, using a single\n# URL for both (not 'api/v1/' or 'json/' prefix). This is required to\n# easily support the mobile apps fetching uploaded files without\n# having to rewrite URLs, and is implemented using the\n# 'override_api_url_scheme' flag passed to rest_dispatch\nurls += [\n    path(\n        \"user_uploads/temporary/<token>/<filename>\",\n        serve_local_file_unauthed,\n        name=\"local_file_unauthed\",\n    ),\n    rest_path(\n        \"user_uploads/<realm_id_str>/<path:filename>\",\n        GET=(serve_file_backend, {\"override_api_url_scheme\"}),\n    ),\n    # This endpoint redirects to camo; it requires an exception for the\n    # same reason.\n    rest_path(\"thumbnail\", GET=(backend_serve_thumbnail, {\"override_api_url_scheme\"})),\n    # Avatars have the same constraint because their URLs are included\n    # in API data structures used by both the mobile and web clients.\n    rest_path(\n        \"avatar/<email_or_id>\",\n        GET=(avatar, {\"override_api_url_scheme\", \"allow_anonymous_user_web\"}),\n    ),\n    rest_path(\n        \"avatar/<email_or_id>/medium\",\n        {\"medium\": True},\n        GET=(avatar, {\"override_api_url_scheme\", \"allow_anonymous_user_web\"}),\n    ),\n]\n\n# This URL serves as a way to receive CSP violation reports from the users.\n# We use this endpoint to just log these reports.\nurls += [\n    path(\"report/csp_violations\", report_csp_violations),\n]\n\n# Incoming webhook URLs\n# We don't create URLs for particular Git integrations here\n# because of generic one below\nfor incoming_webhook in WEBHOOK_INTEGRATIONS:\n    if incoming_webhook.url_object:\n        urls.append(incoming_webhook.url_object)\n\n# Desktop-specific authentication URLs\nurls += [\n    rest_path(\"json/fetch_api_key\", POST=json_fetch_api_key),\n]\n\n# Mobile-specific authentication URLs\nurls += [\n    # Used as a global check by all mobile clients, which currently send\n    # requests to https://zulip.com/compatibility almost immediately after\n    # starting up.\n    path(\"compatibility\", check_global_compatibility),\n]\n\nv1_api_mobile_patterns = [\n    # This json format view used by the mobile apps lists which\n    # authentication backends the server allows as well as details\n    # like the requested subdomains'd realm icon (if known) and\n    # server-specific compatibility.\n    path(\"server_settings\", api_get_server_settings),\n    # This json format view used by the mobile apps accepts a username\n    # password/pair and returns an API key.\n    path(\"fetch_api_key\", api_fetch_api_key),\n]\n\n# View for uploading messages from email mirror\nurls += [\n    path(\"email_mirror_message\", email_mirror_message),\n]\n\n# Include URL configuration files for site-specified extra installed\n# Django apps\nfor app_name in settings.EXTRA_INSTALLED_APPS:\n    app_dir = os.path.join(settings.DEPLOY_ROOT, app_name)\n    if os.path.exists(os.path.join(app_dir, \"urls.py\")):\n        urls += [path(\"\", include(f\"{app_name}.urls\"))]\n        i18n_urls += import_string(f\"{app_name}.urls.i18n_urlpatterns\")\n\n# Tornado views\nurls += [\n    # Used internally for communication between Django and Tornado processes\n    #\n    # Since these views don't use rest_dispatch, they cannot have\n    # asynchronous Tornado behavior.\n    path(\"notify_tornado\", notify),\n    path(\"api/v1/events/internal\", get_events_internal),\n]\n\n# Python Social Auth\n\nurls += [path(\"\", include(\"social_django.urls\", namespace=\"social\"))]\nurls += [path(\"saml/metadata.xml\", saml_sp_metadata)]\n\n# SCIM2\n\nfrom zerver.lib.scim import (\n    ZulipSCIMSearchView,\n    ZulipSCIMUserSearchView,\n    ZulipSCIMUsersView,\n    ZulipSCIMView,\n)\n\nurls += [\n    # We have to register all the SCIM URL patterns first, because we override\n    # all the SCIM View classes and we need Django to use them instead of\n    # the django-scim2 Views that the app will register.\n    re_path(r\"^scim/v2/$\", ZulipSCIMView.as_view(implemented=False)),\n    re_path(r\"^scim/v2/.search$\", ZulipSCIMSearchView.as_view(implemented=False)),\n    re_path(r\"^scim/v2/Users/.search$\", ZulipSCIMUserSearchView.as_view()),\n    re_path(r\"^scim/v2/Users(?:/(?P<uuid>[^/]+))?$\", ZulipSCIMUsersView.as_view()),\n    # Everything below here are features that we don't yet support and we want\n    # to explicitly mark them to return \"Not Implemented\" rather than running\n    # the django-scim2 code for them.\n    re_path(\n        r\"^scim/v2/Groups/.search$\",\n        ZulipSCIMView.as_view(implemented=False),\n    ),\n    re_path(\n        r\"^scim/v2/Groups(?:/(?P<uuid>[^/]+))?$\",\n        ZulipSCIMView.as_view(implemented=False),\n    ),\n    re_path(r\"^scim/v2/Me$\", ZulipSCIMView.as_view(implemented=False)),\n    re_path(\n        r\"^scim/v2/ServiceProviderConfig$\",\n        ZulipSCIMView.as_view(implemented=False),\n    ),\n    re_path(\n        r\"^scim/v2/ResourceTypes(?:/(?P<uuid>[^/]+))?$\",\n        ZulipSCIMView.as_view(implemented=False),\n    ),\n    re_path(r\"^scim/v2/Schemas(?:/(?P<uuid>[^/]+))?$\", ZulipSCIMView.as_view(implemented=False)),\n    re_path(r\"^scim/v2/Bulk$\", ZulipSCIMView.as_view(implemented=False)),\n    # At the end we still register the django-scim2 url patterns (even though we override them all above)\n    # so that reverse(\"scim:viewname\") still works like the internal library code expects.\n    path(\"scim/v2/\", include(\"django_scim.urls\", namespace=\"scim\")),\n]\n\n# User documentation site\nhelp_documentation_view = MarkdownDirectoryView.as_view(\n    template_name=\"zerver/documentation_main.html\", path_template=\"/zerver/help/%s.md\"\n)\napi_documentation_view = MarkdownDirectoryView.as_view(\n    template_name=\"zerver/documentation_main.html\", path_template=\"/zerver/api/%s.md\"\n)\nurls += [\n    # Redirects due to us having moved the docs:\n    path(\n        \"help/delete-a-stream\", RedirectView.as_view(url=\"/help/archive-a-stream\", permanent=True)\n    ),\n    path(\"api/delete-stream\", RedirectView.as_view(url=\"/api/archive-stream\", permanent=True)),\n    path(\n        \"help/change-the-topic-of-a-message\",\n        RedirectView.as_view(url=\"/help/rename-a-topic\", permanent=True),\n    ),\n    path(\n        \"help/configure-missed-message-emails\",\n        RedirectView.as_view(url=\"/help/email-notifications\", permanent=True),\n    ),\n    path(\n        \"help/add-an-alert-word\",\n        RedirectView.as_view(\n            url=\"/help/pm-mention-alert-notifications#alert-words\", permanent=True\n        ),\n    ),\n    path(\n        \"help/test-mobile-notifications\",\n        RedirectView.as_view(url=\"/help/mobile-notifications\", permanent=True),\n    ),\n    path(\n        \"help/troubleshooting-desktop-notifications\",\n        RedirectView.as_view(\n            url=\"/help/desktop-notifications#troubleshooting-desktop-notifications\", permanent=True\n        ),\n    ),\n    path(\n        \"help/change-notification-sound\",\n        RedirectView.as_view(\n            url=\"/help/desktop-notifications#change-notification-sound\", permanent=True\n        ),\n    ),\n    path(\n        \"help/configure-message-notification-emails\",\n        RedirectView.as_view(url=\"/help/email-notifications\", permanent=True),\n    ),\n    path(\n        \"help/disable-new-login-emails\",\n        RedirectView.as_view(url=\"/help/email-notifications#new-login-emails\", permanent=True),\n    ),\n    # This redirect is particularly important, because the old URL\n    # appears in links from Welcome Bot messages.\n    path(\n        \"help/about-streams-and-topics\",\n        RedirectView.as_view(url=\"/help/streams-and-topics\", permanent=True),\n    ),\n    path(\n        \"help/community-topic-edits\",\n        RedirectView.as_view(url=\"/help/configure-who-can-edit-topics\", permanent=True),\n    ),\n    path(\n        \"help/only-allow-admins-to-add-emoji\",\n        RedirectView.as_view(\n            url=\"/help/custom-emoji#change-who-can-add-custom-emoji\", permanent=True\n        ),\n    ),\n    path(\n        \"help/configure-who-can-add-custom-emoji\",\n        RedirectView.as_view(\n            url=\"/help/custom-emoji#change-who-can-add-custom-emoji\", permanent=True\n        ),\n    ),\n    path(\n        \"help/add-custom-emoji\",\n        RedirectView.as_view(url=\"/help/custom-emoji\", permanent=True),\n    ),\n    path(\n        \"help/night-mode\",\n        RedirectView.as_view(url=\"/help/dark-theme\", permanent=True),\n    ),\n    path(\"help/\", help_documentation_view),\n    path(\"help/<path:article>\", help_documentation_view),\n    path(\"api/\", api_documentation_view),\n    path(\"api/<slug:article>\", api_documentation_view),\n]\n\n# Two-factor URLs\nif settings.TWO_FACTOR_AUTHENTICATION_ENABLED:\n    urls += [path(\"\", include(tf_urls)), path(\"\", include(tf_twilio_urls))]\n\nif settings.DEVELOPMENT:\n    urls += dev_urls.urls\n    i18n_urls += dev_urls.i18n_urls\n    v1_api_mobile_patterns += dev_urls.v1_api_mobile_patterns\n\nurls += [\n    path(\"api/v1/\", include(v1_api_mobile_patterns)),\n]\n\n# The sequence is important; if i18n URLs don't come first then\n# reverse URL mapping points to i18n URLs which causes the frontend\n# tests to fail\nurlpatterns = i18n_patterns(*i18n_urls) + urls + legacy_urls\n"], "filenames": ["confirmation/models.py", "zerver/tests/test_signup.py", "zerver/views/registration.py", "zproject/urls.py"], "buggy_code_start_loc": [173, 858, 3, 131], "buggy_code_end_loc": [186, 2128, 151, 564], "fixing_code_start_loc": [173, 858, 3, 130], "fixing_code_end_loc": [186, 2138, 166, 564], "type": "CWE-613", "message": "Zulip is an open source group chat application that combines real-time chat with threaded conversations. In affected versions expiration dates on the confirmation objects associated with email invitations were not enforced properly in the new account registration flow. A confirmation link takes a user to the check_prereg_key_and_redirect endpoint, before getting redirected to POST to /accounts/register/. The problem was that validation was happening in the check_prereg_key_and_redirect part and not in /accounts/register/ - meaning that one could submit an expired confirmation key and be able to register. The issue is fixed in Zulip 4.8. There are no known workarounds and users are advised to upgrade as soon as possible.", "other": {"cve": {"id": "CVE-2021-43791", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-02T01:15:07.423", "lastModified": "2021-12-03T18:09:06.503", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Zulip is an open source group chat application that combines real-time chat with threaded conversations. In affected versions expiration dates on the confirmation objects associated with email invitations were not enforced properly in the new account registration flow. A confirmation link takes a user to the check_prereg_key_and_redirect endpoint, before getting redirected to POST to /accounts/register/. The problem was that validation was happening in the check_prereg_key_and_redirect part and not in /accounts/register/ - meaning that one could submit an expired confirmation key and be able to register. The issue is fixed in Zulip 4.8. There are no known workarounds and users are advised to upgrade as soon as possible."}, {"lang": "es", "value": "Zulip es una aplicaci\u00f3n de chat de grupo de c\u00f3digo abierto que combina el chat en tiempo real con conversaciones en hilos. En las versiones afectadas, las fechas de caducidad de los objetos de confirmaci\u00f3n asociados a las invitaciones por correo electr\u00f3nico no se aplicaban correctamente en el flujo de registro de nuevas cuentas. Un enlace de confirmaci\u00f3n lleva al usuario al endpoint check_prereg_key_and_redirect, antes de ser redirigido a POST a /accounts/register/. El problema era que la comprobaci\u00f3n ocurr\u00eda en la parte check_prereg_key_and_redirect y no en /accounts/register/ - lo que significaba que uno pod\u00eda enviar una clave de confirmaci\u00f3n caducada y poder registrarse. El problema se ha corregido en Zulip versi\u00f3n 4.8. No se presentan soluciones conocidas y se aconseja a usuarios que actualicen lo antes posible"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zulip:zulip:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.8", "matchCriteriaId": "E0C73351-4711-4F7A-AD8F-84FC7FC67CF1"}]}]}], "references": [{"url": "https://github.com/zulip/zulip/commit/a014ef75a3a0ed7f24ebb157632ba58751e732c6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/zulip/zulip/security/advisories/GHSA-wj76-pcqr-mf9f", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zulip/zulip/commit/a014ef75a3a0ed7f24ebb157632ba58751e732c6"}}