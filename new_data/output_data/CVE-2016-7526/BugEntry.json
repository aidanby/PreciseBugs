{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                            W   W  PPPP    GGGG                              %\n%                            W   W  P   P  G                                  %\n%                            W W W  PPPP   G GGG                              %\n%                            WW WW  P      G   G                              %\n%                            W   W  P       GGG                               %\n%                                                                             %\n%                                                                             %\n%                       Read WordPerfect Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                 June 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magic.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n\f\ntypedef struct\n   {\n   unsigned char Red;\n   unsigned char Blue;\n   unsigned char Green;\n   } RGB_Record;\n\n/* Default palette for WPG level 1 */\nstatic const RGB_Record WPG1_Palette[256]={\n{  0,  0,  0},    {  0,  0,168},\n{  0,168,  0},    {  0,168,168},\n{168,  0,  0},    {168,  0,168},\n{168, 84,  0},    {168,168,168},\n{ 84, 84, 84},    { 84, 84,252},\n{ 84,252, 84},    { 84,252,252},\n{252, 84, 84},    {252, 84,252},\n{252,252, 84},    {252,252,252},  /*16*/\n{  0,  0,  0},    { 20, 20, 20},\n{ 32, 32, 32},    { 44, 44, 44},\n{ 56, 56, 56},    { 68, 68, 68},\n{ 80, 80, 80},    { 96, 96, 96},\n{112,112,112},    {128,128,128},\n{144,144,144},    {160,160,160},\n{180,180,180},    {200,200,200},\n{224,224,224},    {252,252,252},  /*32*/\n{  0,  0,252},    { 64,  0,252},\n{124,  0,252},    {188,  0,252},\n{252,  0,252},    {252,  0,188},\n{252,  0,124},    {252,  0, 64},\n{252,  0,  0},    {252, 64,  0},\n{252,124,  0},    {252,188,  0},\n{252,252,  0},    {188,252,  0},\n{124,252,  0},    { 64,252,  0},  /*48*/\n{  0,252,  0},    {  0,252, 64},\n{  0,252,124},    {  0,252,188},\n{  0,252,252},    {  0,188,252},\n{  0,124,252},    {  0, 64,252},\n{124,124,252},    {156,124,252},\n{188,124,252},    {220,124,252},\n{252,124,252},    {252,124,220},\n{252,124,188},    {252,124,156},  /*64*/\n{252,124,124},    {252,156,124},\n{252,188,124},    {252,220,124},\n{252,252,124},    {220,252,124},\n{188,252,124},    {156,252,124},\n{124,252,124},    {124,252,156},\n{124,252,188},    {124,252,220},\n{124,252,252},    {124,220,252},\n{124,188,252},    {124,156,252},  /*80*/\n{180,180,252},    {196,180,252},\n{216,180,252},    {232,180,252},\n{252,180,252},    {252,180,232},\n{252,180,216},    {252,180,196},\n{252,180,180},    {252,196,180},\n{252,216,180},    {252,232,180},\n{252,252,180},    {232,252,180},\n{216,252,180},    {196,252,180},  /*96*/\n{180,220,180},    {180,252,196},\n{180,252,216},    {180,252,232},\n{180,252,252},    {180,232,252},\n{180,216,252},    {180,196,252},\n{0,0,112},    {28,0,112},\n{56,0,112},    {84,0,112},\n{112,0,112},    {112,0,84},\n{112,0,56},    {112,0,28},  /*112*/\n{112,0,0},    {112,28,0},\n{112,56,0},    {112,84,0},\n{112,112,0},    {84,112,0},\n{56,112,0},    {28,112,0},\n{0,112,0},    {0,112,28},\n{0,112,56},    {0,112,84},\n{0,112,112},    {0,84,112},\n{0,56,112},    {0,28,112},   /*128*/\n{56,56,112},    {68,56,112},\n{84,56,112},    {96,56,112},\n{112,56,112},    {112,56,96},\n{112,56,84},    {112,56,68},\n{112,56,56},    {112,68,56},\n{112,84,56},    {112,96,56},\n{112,112,56},    {96,112,56},\n{84,112,56},    {68,112,56},  /*144*/\n{56,112,56},    {56,112,69},\n{56,112,84},    {56,112,96},\n{56,112,112},    {56,96,112},\n{56,84,112},    {56,68,112},\n{80,80,112},    {88,80,112},\n{96,80,112},    {104,80,112},\n{112,80,112},    {112,80,104},\n{112,80,96},    {112,80,88},  /*160*/\n{112,80,80},    {112,88,80},\n{112,96,80},    {112,104,80},\n{112,112,80},    {104,112,80},\n{96,112,80},    {88,112,80},\n{80,112,80},    {80,112,88},\n{80,112,96},    {80,112,104},\n{80,112,112},    {80,114,112},\n{80,96,112},    {80,88,112},  /*176*/\n{0,0,64},    {16,0,64},\n{32,0,64},    {48,0,64},\n{64,0,64},    {64,0,48},\n{64,0,32},    {64,0,16},\n{64,0,0},    {64,16,0},\n{64,32,0},    {64,48,0},\n{64,64,0},    {48,64,0},\n{32,64,0},    {16,64,0},  /*192*/\n{0,64,0},    {0,64,16},\n{0,64,32},    {0,64,48},\n{0,64,64},    {0,48,64},\n{0,32,64},    {0,16,64},\n{32,32,64},    {40,32,64},\n{48,32,64},    {56,32,64},\n{64,32,64},    {64,32,56},\n{64,32,48},    {64,32,40},  /*208*/\n{64,32,32},    {64,40,32},\n{64,48,32},    {64,56,32},\n{64,64,32},    {56,64,32},\n{48,64,32},    {40,64,32},\n{32,64,32},    {32,64,40},\n{32,64,48},    {32,64,56},\n{32,64,64},    {32,56,64},\n{32,48,64},    {32,40,64},  /*224*/\n{44,44,64},    {48,44,64},\n{52,44,64},    {60,44,64},\n{64,44,64},    {64,44,60},\n{64,44,52},    {64,44,48},\n{64,44,44},    {64,48,44},\n{64,52,44},    {64,60,44},\n{64,64,44},    {60,64,44},\n{52,64,44},    {48,64,44},  /*240*/\n{44,64,44},    {44,64,48},\n{44,64,52},    {44,64,60},\n{44,64,64},    {44,60,64},\n{44,55,64},    {44,48,64},\n{0,0,0},    {0,0,0},\n{0,0,0},    {0,0,0},\n{0,0,0},    {0,0,0},\n{0,0,0},    {0,0,0}    /*256*/\n};\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s W P G                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsWPG() returns True if the image format type, identified by the magick\n%  string, is WPG.\n%\n%  The format of the IsWPG method is:\n%\n%      unsigned int IsWPG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o status:  Method IsWPG returns True if the image format type is WPG.\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic unsigned int IsWPG(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\377WPC\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n\nstatic void Rd_WP_DWORD(Image *image,size_t *d)\n{\n  unsigned char\n    b;\n\n  b=ReadBlobByte(image);\n  *d=b;\n  if (b < 0xFFU)\n    return;\n  b=ReadBlobByte(image);\n  *d=(size_t) b;\n  b=ReadBlobByte(image);\n  *d+=(size_t) b*256l;\n  if (*d < 0x8000)\n    return;\n  *d=(*d & 0x7FFF) << 16;\n  b=ReadBlobByte(image);\n  *d+=(size_t) b;\n  b=ReadBlobByte(image);\n  *d+=(size_t) b*256l;\n  return;\n}\n\nstatic void InsertRow(Image *image,unsigned char *p,ssize_t y,int bpp,\n  ExceptionInfo *exception)\n{\n  int\n    bit;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  switch (bpp)\n    {\n    case 1:  /* Convert bitmap scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n            {\n              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n              SetPixelIndex(image,index,q);\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if (!SyncAuthenticPixels(image,exception))\n          break;\n        break;\n      }\n    case 2:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-1); x+=4)\n        {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n        }\n       if ((image->columns % 4) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            if ((image->columns % 4) >= 1)\n\n              {\n                index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n                SetPixelIndex(image,index,q);\n                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n                q+=GetPixelChannels(image);\n                if ((image->columns % 4) >= 2)\n\n                  {\n                    index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,\n                      exception);\n                    SetPixelIndex(image,index,q);\n                    SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n                    q+=GetPixelChannels(image);\n                  }\n              }\n            p++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        break;\n      }\n \n    case 4:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          { \n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        break;\n      }\n    case 8: /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL) break;\n\n        for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,*p,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      break;\n     \n    case 24:     /*  Convert DirectColor scanline.  */\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n          q+=GetPixelChannels(image);\n        }\n      if (!SyncAuthenticPixels(image,exception))\n        break;\n      break;     \n    }\n}\n\n\n/* Helper for WPG1 raster reader. */\n#define InsertByte(b) \\\n{ \\\n  BImgBuff[x]=b; \\\n  x++; \\\n  if((ssize_t) x>=ldblk) \\\n  { \\\n    InsertRow(image,BImgBuff,(ssize_t) y,bpp,exception); \\\n    x=0; \\\n    y++; \\\n    } \\\n}\n/* WPG1 raster reader. */\nstatic int UnpackWPGRaster(Image *image,int bpp,ExceptionInfo *exception)\n{\n  int\n    x,\n    y,\n    i;\n\n  unsigned char\n    bbuf,\n    *BImgBuff,\n    RunCount;\n\n  ssize_t\n    ldblk;\n\n  x=0;\n  y=0;\n\n  ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    8*sizeof(*BImgBuff));\n  if(BImgBuff==NULL) return(-2);\n\n  while(y<(ssize_t) image->rows)\n    {\n      int\n        c;\n\n      c=ReadBlobByte(image);\n      if (c == EOF)\n        break;\n      bbuf=(unsigned char) c;\n      RunCount=bbuf & 0x7F;\n      if(bbuf & 0x80)\n        {\n          if(RunCount)  /* repeat next byte runcount * */\n            {\n              bbuf=ReadBlobByte(image);\n              for(i=0;i<(int) RunCount;i++) InsertByte(bbuf);\n            }\n          else {  /* read next byte as RunCount; repeat 0xFF runcount* */\n            c=ReadBlobByte(image);\n            if (c < 0)\n              break;\n            RunCount=(unsigned char) c;\n            for(i=0;i<(int) RunCount;i++) InsertByte(0xFF);\n          }\n        }\n      else {\n        if(RunCount)   /* next runcount byte are readed directly */\n          {\n            for(i=0;i < (int) RunCount;i++)\n              {\n                bbuf=ReadBlobByte(image);\n                InsertByte(bbuf);\n              }\n          }\n        else {  /* repeat previous line runcount* */\n          c=ReadBlobByte(image);\n          if (c < 0)\n            break;\n          RunCount=(unsigned char) c;\n          if(x) {    /* attempt to duplicate row from x position: */\n            /* I do not know what to do here */\n            BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n            return(-3);\n          }\n          for(i=0;i < (int) RunCount;i++)\n            {\n              x=0;\n              y++;    /* Here I need to duplicate previous row RUNCOUNT* */\n              if(y<2) continue;\n              if(y>(ssize_t) image->rows)\n                {\n                  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                  return(-4);\n                }\n              InsertRow(image,BImgBuff,y-1,bpp,exception);\n            }\n        }\n      }\n    }\n  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  return(y <(ssize_t) image->rows ? -5 : 0);\n}\n\n\n/* Helper for WPG2 reader. */\n#define InsertByte6(b) \\\n{ \\\nDisableMSCWarning(4310) \\\n  if(XorMe)\\\n    BImgBuff[x] = (unsigned char)~b;\\\n  else\\\n    BImgBuff[x] = b;\\\nRestoreMSCWarning \\\n  x++; \\\n  if((ssize_t) x >= ldblk) \\\n  { \\\n    InsertRow(image,BImgBuff,(ssize_t) y,bpp,exception); \\\n    x=0; \\\n    y++; \\\n   } \\\n}\n/* WPG2 raster reader. */\nstatic int UnpackWPG2Raster(Image *image,int bpp,ExceptionInfo *exception)\n{\n  int\n    RunCount,\n    XorMe = 0;\n\n  size_t\n    x,\n    y;\n\n  ssize_t\n    i,\n    ldblk;\n\n  unsigned int\n    SampleSize=1;\n\n  unsigned char\n    bbuf,\n    *BImgBuff,\n    SampleBuffer[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\n  x=0;\n  y=0;\n  ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    sizeof(*BImgBuff));\n  if(BImgBuff==NULL)\n    return(-2);\n\n  while( y< image->rows)\n    {\n      bbuf=ReadBlobByte(image);\n\n      switch(bbuf)\n        {\n        case 0x7D:\n          SampleSize=ReadBlobByte(image);  /* DSZ */\n          if(SampleSize>8)\n            return(-2);\n          if(SampleSize<1)\n            return(-2);\n          break;\n        case 0x7E:\n          (void) FormatLocaleFile(stderr,\n            \"\\nUnsupported WPG token XOR, please report!\");\n          XorMe=!XorMe;\n          break;\n        case 0x7F:\n          RunCount=ReadBlobByte(image);   /* BLK */\n          if (RunCount < 0)\n            break;\n          for(i=0; i < SampleSize*(RunCount+1); i++)\n            {\n              InsertByte6(0);\n            }\n          break;\n        case 0xFD:\n          RunCount=ReadBlobByte(image);   /* EXT */\n          if (RunCount < 0)\n            break;\n          for(i=0; i<= RunCount;i++)\n            for(bbuf=0; bbuf < SampleSize; bbuf++)\n              InsertByte6(SampleBuffer[bbuf]);          \n          break;\n        case 0xFE:\n          RunCount=ReadBlobByte(image);  /* RST */\n          if (RunCount < 0)\n            break;\n          if(x!=0)\n            {\n              (void) FormatLocaleFile(stderr,\n                \"\\nUnsupported WPG2 unaligned token RST x=%.20g, please report!\\n\"\n                ,(double) x);\n              return(-3);\n            }\n          {\n            /* duplicate the previous row RunCount x */\n            for(i=0;i<=RunCount;i++)\n              {      \n                InsertRow(image,BImgBuff,(ssize_t) (image->rows >= y ? y : image->rows-1),\n                          bpp,exception);\n                y++;\n              }    \n          }\n          break;\n        case 0xFF:\n          RunCount=ReadBlobByte(image);   /* WHT */\n          if (RunCount < 0)\n            break;\n          for(i=0; i < SampleSize*(RunCount+1); i++)\n            {\n              InsertByte6(0xFF);\n            }\n          break;\n        default:\n          RunCount=bbuf & 0x7F;\n\n          if(bbuf & 0x80)     /* REP */\n            {  \n              for(i=0; i < SampleSize; i++)\n                SampleBuffer[i]=ReadBlobByte(image);\n              for(i=0;i<=RunCount;i++)\n                for(bbuf=0;bbuf<SampleSize;bbuf++)\n                  InsertByte6(SampleBuffer[bbuf]);\n            }\n          else {      /* NRP */\n            for(i=0; i< SampleSize*(RunCount+1);i++)\n              {\n                bbuf=ReadBlobByte(image);\n                InsertByte6(bbuf);\n              }\n          }\n        }\n    }\n  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  return(0);\n}\n\n\ntypedef float tCTM[3][3];\n\nstatic unsigned LoadWPG2Flags(Image *image,char Precision,float *Angle,tCTM *CTM)\n{\nconst unsigned char TPR=1,TRN=2,SKW=4,SCL=8,ROT=0x10,OID=0x20,LCK=0x80;\nssize_t x;\nunsigned DenX;\nunsigned Flags;\n\n (void) memset(*CTM,0,sizeof(*CTM));     /*CTM.erase();CTM.resize(3,3);*/\n (*CTM)[0][0]=1;\n (*CTM)[1][1]=1;\n (*CTM)[2][2]=1;\n\n Flags=ReadBlobLSBShort(image);\n if(Flags & LCK) (void) ReadBlobLSBLong(image);  /*Edit lock*/\n if(Flags & OID)\n  {\n  if(Precision==0)\n    {(void) ReadBlobLSBShort(image);}  /*ObjectID*/\n  else\n    {(void) ReadBlobLSBLong(image);}  /*ObjectID (Double precision)*/\n  }\n if(Flags & ROT)\n  {\n  x=ReadBlobLSBLong(image);  /*Rot Angle*/\n  if(Angle) *Angle=x/65536.0;\n  }\n if(Flags & (ROT|SCL))\n  {\n  x=ReadBlobLSBLong(image);  /*Sx*cos()*/\n  (*CTM)[0][0] = (float)x/0x10000;\n  x=ReadBlobLSBLong(image);  /*Sy*cos()*/\n  (*CTM)[1][1] = (float)x/0x10000;\n  }\n if(Flags & (ROT|SKW))\n  {\n  x=ReadBlobLSBLong(image);       /*Kx*sin()*/\n  (*CTM)[1][0] = (float)x/0x10000;\n  x=ReadBlobLSBLong(image);       /*Ky*sin()*/\n  (*CTM)[0][1] = (float)x/0x10000;\n  }\n if(Flags & TRN)\n  {\n  x=ReadBlobLSBLong(image); DenX=ReadBlobLSBShort(image);  /*Tx*/\n        if(x>=0) (*CTM)[0][2] = (float)x+(float)DenX/0x10000;\n            else (*CTM)[0][2] = (float)x-(float)DenX/0x10000;\n  x=ReadBlobLSBLong(image); DenX=ReadBlobLSBShort(image);  /*Ty*/\n  (*CTM)[1][2]=(float)x + ((x>=0)?1:-1)*(float)DenX/0x10000;\n        if(x>=0) (*CTM)[1][2] = (float)x+(float)DenX/0x10000;\n            else (*CTM)[1][2] = (float)x-(float)DenX/0x10000;\n  }\n if(Flags & TPR)\n  {\n  x=ReadBlobLSBShort(image); DenX=ReadBlobLSBShort(image);  /*Px*/\n  (*CTM)[2][0] = x + (float)DenX/0x10000;;\n  x=ReadBlobLSBShort(image);  DenX=ReadBlobLSBShort(image); /*Py*/\n  (*CTM)[2][1] = x + (float)DenX/0x10000;\n  }\n return(Flags);\n}\n\n\nstatic Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n\n  const MagicInfo\n    *magic_info;    \n\n  FILE\n    *ps_file;\n\n  ImageInfo\n    *clone_info;\n    \n  Image\n    *image2;\n    \n  unsigned char\n    magick[2*MagickPathExtent];    \n    \n\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n\n  /* Obtain temporary file */\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n\n  /* Copy postscript to temporary file */\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  \n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  \n    /* Detect file format - Check magic.mgk configuration file. */\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  /*     printf(\"Detected:%s  \\n\",magic_info->name); */\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n    \n  (void) strncpy(clone_info->magick,magic_info->name,MagickPathExtent);\n  \n    /* Read nested image */\n  /*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*/\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n\n  if (!image2)\n    goto FINISH_UNL;\n\n  /*\n    Replace current image with new image while copying base image\n    attributes.\n  */\n  (void) CopyMagickMemory(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n\n  AppendImageToList(&image,image2);\n\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d W P G I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method ReadWPGImage reads an WPG X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadWPGImage method is:\n%\n%    Image *ReadWPGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadWPGImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:      \n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flip_image);    \n                      }\n                    }\n    \n      /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,rotate_image);    \n                      }\n                    }                \n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=0;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;  \n\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  size_t\n                    one;\n\n                  one=1;\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);;\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    (void) RemoveLastImageFromList(&image);\n                    AppendImageToList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.      \n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */                  \n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     (void) RemoveLastImageFromList(&image);\n                     AppendImageToList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */      \n              }    \n    \n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r W P G I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method RegisterWPGImage adds attributes for the WPG image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterWPGImage method is:\n%\n%      size_t RegisterWPGImage(void)\n%\n*/\nModuleExport size_t RegisterWPGImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"WPG\",\"WPG\",\"Word Perfect Graphics\");\n  entry->decoder=(DecodeImageHandler *) ReadWPGImage;\n  entry->magick=(IsImageFormatHandler *) IsWPG;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r W P G I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method UnregisterWPGImage removes format registrations made by the\n%  WPG module from the list of supported formats.\n%\n%  The format of the UnregisterWPGImage method is:\n%\n%      UnregisterWPGImage(void)\n%\n*/\nModuleExport void UnregisterWPGImage(void)\n{\n  (void) UnregisterMagickInfo(\"WPG\");\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                            W   W  PPPP    GGGG                              %\n%                            W   W  P   P  G                                  %\n%                            W W W  PPPP   G GGG                              %\n%                            WW WW  P      G   G                              %\n%                            W   W  P       GGG                               %\n%                                                                             %\n%                                                                             %\n%                       Read WordPerfect Image Format                         %\n%                                                                             %\n%                              Software Design                                %\n%                              Jaroslav Fojtik                                %\n%                                 June 2000                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/distort.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magic.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n\f\ntypedef struct\n   {\n   unsigned char Red;\n   unsigned char Blue;\n   unsigned char Green;\n   } RGB_Record;\n\n/* Default palette for WPG level 1 */\nstatic const RGB_Record WPG1_Palette[256]={\n{  0,  0,  0},    {  0,  0,168},\n{  0,168,  0},    {  0,168,168},\n{168,  0,  0},    {168,  0,168},\n{168, 84,  0},    {168,168,168},\n{ 84, 84, 84},    { 84, 84,252},\n{ 84,252, 84},    { 84,252,252},\n{252, 84, 84},    {252, 84,252},\n{252,252, 84},    {252,252,252},  /*16*/\n{  0,  0,  0},    { 20, 20, 20},\n{ 32, 32, 32},    { 44, 44, 44},\n{ 56, 56, 56},    { 68, 68, 68},\n{ 80, 80, 80},    { 96, 96, 96},\n{112,112,112},    {128,128,128},\n{144,144,144},    {160,160,160},\n{180,180,180},    {200,200,200},\n{224,224,224},    {252,252,252},  /*32*/\n{  0,  0,252},    { 64,  0,252},\n{124,  0,252},    {188,  0,252},\n{252,  0,252},    {252,  0,188},\n{252,  0,124},    {252,  0, 64},\n{252,  0,  0},    {252, 64,  0},\n{252,124,  0},    {252,188,  0},\n{252,252,  0},    {188,252,  0},\n{124,252,  0},    { 64,252,  0},  /*48*/\n{  0,252,  0},    {  0,252, 64},\n{  0,252,124},    {  0,252,188},\n{  0,252,252},    {  0,188,252},\n{  0,124,252},    {  0, 64,252},\n{124,124,252},    {156,124,252},\n{188,124,252},    {220,124,252},\n{252,124,252},    {252,124,220},\n{252,124,188},    {252,124,156},  /*64*/\n{252,124,124},    {252,156,124},\n{252,188,124},    {252,220,124},\n{252,252,124},    {220,252,124},\n{188,252,124},    {156,252,124},\n{124,252,124},    {124,252,156},\n{124,252,188},    {124,252,220},\n{124,252,252},    {124,220,252},\n{124,188,252},    {124,156,252},  /*80*/\n{180,180,252},    {196,180,252},\n{216,180,252},    {232,180,252},\n{252,180,252},    {252,180,232},\n{252,180,216},    {252,180,196},\n{252,180,180},    {252,196,180},\n{252,216,180},    {252,232,180},\n{252,252,180},    {232,252,180},\n{216,252,180},    {196,252,180},  /*96*/\n{180,220,180},    {180,252,196},\n{180,252,216},    {180,252,232},\n{180,252,252},    {180,232,252},\n{180,216,252},    {180,196,252},\n{0,0,112},    {28,0,112},\n{56,0,112},    {84,0,112},\n{112,0,112},    {112,0,84},\n{112,0,56},    {112,0,28},  /*112*/\n{112,0,0},    {112,28,0},\n{112,56,0},    {112,84,0},\n{112,112,0},    {84,112,0},\n{56,112,0},    {28,112,0},\n{0,112,0},    {0,112,28},\n{0,112,56},    {0,112,84},\n{0,112,112},    {0,84,112},\n{0,56,112},    {0,28,112},   /*128*/\n{56,56,112},    {68,56,112},\n{84,56,112},    {96,56,112},\n{112,56,112},    {112,56,96},\n{112,56,84},    {112,56,68},\n{112,56,56},    {112,68,56},\n{112,84,56},    {112,96,56},\n{112,112,56},    {96,112,56},\n{84,112,56},    {68,112,56},  /*144*/\n{56,112,56},    {56,112,69},\n{56,112,84},    {56,112,96},\n{56,112,112},    {56,96,112},\n{56,84,112},    {56,68,112},\n{80,80,112},    {88,80,112},\n{96,80,112},    {104,80,112},\n{112,80,112},    {112,80,104},\n{112,80,96},    {112,80,88},  /*160*/\n{112,80,80},    {112,88,80},\n{112,96,80},    {112,104,80},\n{112,112,80},    {104,112,80},\n{96,112,80},    {88,112,80},\n{80,112,80},    {80,112,88},\n{80,112,96},    {80,112,104},\n{80,112,112},    {80,114,112},\n{80,96,112},    {80,88,112},  /*176*/\n{0,0,64},    {16,0,64},\n{32,0,64},    {48,0,64},\n{64,0,64},    {64,0,48},\n{64,0,32},    {64,0,16},\n{64,0,0},    {64,16,0},\n{64,32,0},    {64,48,0},\n{64,64,0},    {48,64,0},\n{32,64,0},    {16,64,0},  /*192*/\n{0,64,0},    {0,64,16},\n{0,64,32},    {0,64,48},\n{0,64,64},    {0,48,64},\n{0,32,64},    {0,16,64},\n{32,32,64},    {40,32,64},\n{48,32,64},    {56,32,64},\n{64,32,64},    {64,32,56},\n{64,32,48},    {64,32,40},  /*208*/\n{64,32,32},    {64,40,32},\n{64,48,32},    {64,56,32},\n{64,64,32},    {56,64,32},\n{48,64,32},    {40,64,32},\n{32,64,32},    {32,64,40},\n{32,64,48},    {32,64,56},\n{32,64,64},    {32,56,64},\n{32,48,64},    {32,40,64},  /*224*/\n{44,44,64},    {48,44,64},\n{52,44,64},    {60,44,64},\n{64,44,64},    {64,44,60},\n{64,44,52},    {64,44,48},\n{64,44,44},    {64,48,44},\n{64,52,44},    {64,60,44},\n{64,64,44},    {60,64,44},\n{52,64,44},    {48,64,44},  /*240*/\n{44,64,44},    {44,64,48},\n{44,64,52},    {44,64,60},\n{44,64,64},    {44,60,64},\n{44,55,64},    {44,48,64},\n{0,0,0},    {0,0,0},\n{0,0,0},    {0,0,0},\n{0,0,0},    {0,0,0},\n{0,0,0},    {0,0,0}    /*256*/\n};\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s W P G                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsWPG() returns True if the image format type, identified by the magick\n%  string, is WPG.\n%\n%  The format of the IsWPG method is:\n%\n%      unsigned int IsWPG(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o status:  Method IsWPG returns True if the image format type is WPG.\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic unsigned int IsWPG(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\377WPC\",4) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n\nstatic void Rd_WP_DWORD(Image *image,size_t *d)\n{\n  unsigned char\n    b;\n\n  b=ReadBlobByte(image);\n  *d=b;\n  if (b < 0xFFU)\n    return;\n  b=ReadBlobByte(image);\n  *d=(size_t) b;\n  b=ReadBlobByte(image);\n  *d+=(size_t) b*256l;\n  if (*d < 0x8000)\n    return;\n  *d=(*d & 0x7FFF) << 16;\n  b=ReadBlobByte(image);\n  *d+=(size_t) b;\n  b=ReadBlobByte(image);\n  *d+=(size_t) b*256l;\n  return;\n}\n\nstatic void InsertRow(Image *image,unsigned char *p,ssize_t y,int bpp,\n  ExceptionInfo *exception)\n{\n  int\n    bit;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    x;\n\n  switch (bpp)\n    {\n    case 1:  /* Convert bitmap scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n            {\n              index=((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n              SetPixelIndex(image,index,q);\n              SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if (!SyncAuthenticPixels(image,exception))\n          break;\n        break;\n      }\n    case 2:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n        {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            p++;\n        }\n       if ((image->columns % 4) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            if ((image->columns % 4) > 1)\n              {\n                index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception);\n                SetPixelIndex(image,index,q);\n                SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n                q+=GetPixelChannels(image);\n                if ((image->columns % 4) > 2)\n                  {\n                    index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,\n                      exception);\n                    SetPixelIndex(image,index,q);\n                    SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n                    q+=GetPixelChannels(image);\n                  }\n              }\n            p++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        break;\n      }\n \n    case 4:  /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          { \n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n            index=ConstrainColormapIndex(image,(*p) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        break;\n      }\n    case 8: /* Convert PseudoColor scanline. */\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL) break;\n\n        for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,*p,exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            p++;\n            q+=GetPixelChannels(image);\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      break;\n     \n    case 24:     /*  Convert DirectColor scanline.  */\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n          SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n          SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n          q+=GetPixelChannels(image);\n        }\n      if (!SyncAuthenticPixels(image,exception))\n        break;\n      break;\n    }\n}\n\n\n/* Helper for WPG1 raster reader. */\n#define InsertByte(b) \\\n{ \\\n  BImgBuff[x]=b; \\\n  x++; \\\n  if((ssize_t) x>=ldblk) \\\n  { \\\n    InsertRow(image,BImgBuff,(ssize_t) y,bpp,exception); \\\n    x=0; \\\n    y++; \\\n    } \\\n}\n/* WPG1 raster reader. */\nstatic int UnpackWPGRaster(Image *image,int bpp,ExceptionInfo *exception)\n{\n  int\n    x,\n    y,\n    i;\n\n  unsigned char\n    bbuf,\n    *BImgBuff,\n    RunCount;\n\n  ssize_t\n    ldblk;\n\n  x=0;\n  y=0;\n\n  ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    8*sizeof(*BImgBuff));\n  if(BImgBuff==NULL) return(-2);\n\n  while(y<(ssize_t) image->rows)\n    {\n      int\n        c;\n\n      c=ReadBlobByte(image);\n      if (c == EOF)\n        break;\n      bbuf=(unsigned char) c;\n      RunCount=bbuf & 0x7F;\n      if(bbuf & 0x80)\n        {\n          if(RunCount)  /* repeat next byte runcount * */\n            {\n              bbuf=ReadBlobByte(image);\n              for(i=0;i<(int) RunCount;i++) InsertByte(bbuf);\n            }\n          else {  /* read next byte as RunCount; repeat 0xFF runcount* */\n            c=ReadBlobByte(image);\n            if (c < 0)\n              break;\n            RunCount=(unsigned char) c;\n            for(i=0;i<(int) RunCount;i++) InsertByte(0xFF);\n          }\n        }\n      else {\n        if(RunCount)   /* next runcount byte are readed directly */\n          {\n            for(i=0;i < (int) RunCount;i++)\n              {\n                bbuf=ReadBlobByte(image);\n                InsertByte(bbuf);\n              }\n          }\n        else {  /* repeat previous line runcount* */\n          c=ReadBlobByte(image);\n          if (c < 0)\n            break;\n          RunCount=(unsigned char) c;\n          if(x) {    /* attempt to duplicate row from x position: */\n            /* I do not know what to do here */\n            BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n            return(-3);\n          }\n          for(i=0;i < (int) RunCount;i++)\n            {\n              x=0;\n              y++;    /* Here I need to duplicate previous row RUNCOUNT* */\n              if(y<2) continue;\n              if(y>(ssize_t) image->rows)\n                {\n                  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                  return(-4);\n                }\n              InsertRow(image,BImgBuff,y-1,bpp,exception);\n            }\n        }\n      }\n    }\n  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  return(y <(ssize_t) image->rows ? -5 : 0);\n}\n\n\n/* Helper for WPG2 reader. */\n#define InsertByte6(b) \\\n{ \\\nDisableMSCWarning(4310) \\\n  if(XorMe)\\\n    BImgBuff[x] = (unsigned char)~b;\\\n  else\\\n    BImgBuff[x] = b;\\\nRestoreMSCWarning \\\n  x++; \\\n  if((ssize_t) x >= ldblk) \\\n  { \\\n    InsertRow(image,BImgBuff,(ssize_t) y,bpp,exception); \\\n    x=0; \\\n    y++; \\\n   } \\\n}\n/* WPG2 raster reader. */\nstatic int UnpackWPG2Raster(Image *image,int bpp,ExceptionInfo *exception)\n{\n  int\n    RunCount,\n    XorMe = 0;\n\n  size_t\n    x,\n    y;\n\n  ssize_t\n    i,\n    ldblk;\n\n  unsigned int\n    SampleSize=1;\n\n  unsigned char\n    bbuf,\n    *BImgBuff,\n    SampleBuffer[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\n  x=0;\n  y=0;\n  ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n  BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n    sizeof(*BImgBuff));\n  if(BImgBuff==NULL)\n    return(-2);\n\n  while( y< image->rows)\n    {\n      bbuf=ReadBlobByte(image);\n\n      switch(bbuf)\n        {\n        case 0x7D:\n          SampleSize=ReadBlobByte(image);  /* DSZ */\n          if(SampleSize>8)\n            return(-2);\n          if(SampleSize<1)\n            return(-2);\n          break;\n        case 0x7E:\n          (void) FormatLocaleFile(stderr,\n            \"\\nUnsupported WPG token XOR, please report!\");\n          XorMe=!XorMe;\n          break;\n        case 0x7F:\n          RunCount=ReadBlobByte(image);   /* BLK */\n          if (RunCount < 0)\n            break;\n          for(i=0; i < SampleSize*(RunCount+1); i++)\n            {\n              InsertByte6(0);\n            }\n          break;\n        case 0xFD:\n          RunCount=ReadBlobByte(image);   /* EXT */\n          if (RunCount < 0)\n            break;\n          for(i=0; i<= RunCount;i++)\n            for(bbuf=0; bbuf < SampleSize; bbuf++)\n              InsertByte6(SampleBuffer[bbuf]);          \n          break;\n        case 0xFE:\n          RunCount=ReadBlobByte(image);  /* RST */\n          if (RunCount < 0)\n            break;\n          if(x!=0)\n            {\n              (void) FormatLocaleFile(stderr,\n                \"\\nUnsupported WPG2 unaligned token RST x=%.20g, please report!\\n\"\n                ,(double) x);\n              return(-3);\n            }\n          {\n            /* duplicate the previous row RunCount x */\n            for(i=0;i<=RunCount;i++)\n              {      \n                InsertRow(image,BImgBuff,(ssize_t) (image->rows >= y ? y : image->rows-1),\n                          bpp,exception);\n                y++;\n              }    \n          }\n          break;\n        case 0xFF:\n          RunCount=ReadBlobByte(image);   /* WHT */\n          if (RunCount < 0)\n            break;\n          for(i=0; i < SampleSize*(RunCount+1); i++)\n            {\n              InsertByte6(0xFF);\n            }\n          break;\n        default:\n          RunCount=bbuf & 0x7F;\n\n          if(bbuf & 0x80)     /* REP */\n            {  \n              for(i=0; i < SampleSize; i++)\n                SampleBuffer[i]=ReadBlobByte(image);\n              for(i=0;i<=RunCount;i++)\n                for(bbuf=0;bbuf<SampleSize;bbuf++)\n                  InsertByte6(SampleBuffer[bbuf]);\n            }\n          else {      /* NRP */\n            for(i=0; i< SampleSize*(RunCount+1);i++)\n              {\n                bbuf=ReadBlobByte(image);\n                InsertByte6(bbuf);\n              }\n          }\n        }\n    }\n  BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n  return(0);\n}\n\n\ntypedef float tCTM[3][3];\n\nstatic unsigned LoadWPG2Flags(Image *image,char Precision,float *Angle,tCTM *CTM)\n{\nconst unsigned char TPR=1,TRN=2,SKW=4,SCL=8,ROT=0x10,OID=0x20,LCK=0x80;\nssize_t x;\nunsigned DenX;\nunsigned Flags;\n\n (void) memset(*CTM,0,sizeof(*CTM));     /*CTM.erase();CTM.resize(3,3);*/\n (*CTM)[0][0]=1;\n (*CTM)[1][1]=1;\n (*CTM)[2][2]=1;\n\n Flags=ReadBlobLSBShort(image);\n if(Flags & LCK) (void) ReadBlobLSBLong(image);  /*Edit lock*/\n if(Flags & OID)\n  {\n  if(Precision==0)\n    {(void) ReadBlobLSBShort(image);}  /*ObjectID*/\n  else\n    {(void) ReadBlobLSBLong(image);}  /*ObjectID (Double precision)*/\n  }\n if(Flags & ROT)\n  {\n  x=ReadBlobLSBLong(image);  /*Rot Angle*/\n  if(Angle) *Angle=x/65536.0;\n  }\n if(Flags & (ROT|SCL))\n  {\n  x=ReadBlobLSBLong(image);  /*Sx*cos()*/\n  (*CTM)[0][0] = (float)x/0x10000;\n  x=ReadBlobLSBLong(image);  /*Sy*cos()*/\n  (*CTM)[1][1] = (float)x/0x10000;\n  }\n if(Flags & (ROT|SKW))\n  {\n  x=ReadBlobLSBLong(image);       /*Kx*sin()*/\n  (*CTM)[1][0] = (float)x/0x10000;\n  x=ReadBlobLSBLong(image);       /*Ky*sin()*/\n  (*CTM)[0][1] = (float)x/0x10000;\n  }\n if(Flags & TRN)\n  {\n  x=ReadBlobLSBLong(image); DenX=ReadBlobLSBShort(image);  /*Tx*/\n        if(x>=0) (*CTM)[0][2] = (float)x+(float)DenX/0x10000;\n            else (*CTM)[0][2] = (float)x-(float)DenX/0x10000;\n  x=ReadBlobLSBLong(image); DenX=ReadBlobLSBShort(image);  /*Ty*/\n  (*CTM)[1][2]=(float)x + ((x>=0)?1:-1)*(float)DenX/0x10000;\n        if(x>=0) (*CTM)[1][2] = (float)x+(float)DenX/0x10000;\n            else (*CTM)[1][2] = (float)x-(float)DenX/0x10000;\n  }\n if(Flags & TPR)\n  {\n  x=ReadBlobLSBShort(image); DenX=ReadBlobLSBShort(image);  /*Px*/\n  (*CTM)[2][0] = x + (float)DenX/0x10000;;\n  x=ReadBlobLSBShort(image);  DenX=ReadBlobLSBShort(image); /*Py*/\n  (*CTM)[2][1] = x + (float)DenX/0x10000;\n  }\n return(Flags);\n}\n\n\nstatic Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n\n  const MagicInfo\n    *magic_info;    \n\n  FILE\n    *ps_file;\n\n  ImageInfo\n    *clone_info;\n    \n  Image\n    *image2;\n    \n  unsigned char\n    magick[2*MagickPathExtent];    \n    \n\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n\n  /* Obtain temporary file */\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n\n  /* Copy postscript to temporary file */\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  \n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  \n    /* Detect file format - Check magic.mgk configuration file. */\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  /*     printf(\"Detected:%s  \\n\",magic_info->name); */\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n    \n  (void) strncpy(clone_info->magick,magic_info->name,MagickPathExtent);\n  \n    /* Read nested image */\n  /*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*/\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n\n  if (!image2)\n    goto FINISH_UNL;\n\n  /*\n    Replace current image with new image while copying base image\n    attributes.\n  */\n  (void) CopyMagickMemory(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n\n  AppendImageToList(&image,image2);\n\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d W P G I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method ReadWPGImage reads an WPG X image file and returns it.  It\n%  allocates the memory necessary for the new Image structure and returns a\n%  pointer to the new image.\n%\n%  The format of the ReadWPGImage method is:\n%\n%    Image *ReadWPGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image:  Method ReadWPGImage returns a pointer to the image after\n%      reading. A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: Specifies a pointer to a ImageInfo structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadWPGImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  typedef struct\n  {\n    size_t FileId;\n    MagickOffsetType DataOffset;\n    unsigned int ProductType;\n    unsigned int FileType;\n    unsigned char MajorVersion;\n    unsigned char MinorVersion;\n    unsigned int EncryptKey;\n    unsigned int Reserved;\n  } WPGHeader;\n\n  typedef struct\n  {\n    unsigned char RecType;\n    size_t RecordLength;\n  } WPGRecord;\n\n  typedef struct\n  {\n    unsigned char Class;\n    unsigned char RecType;\n    size_t Extension;\n    size_t RecordLength;\n  } WPG2Record;\n\n  typedef struct\n  {\n    unsigned  HorizontalUnits;\n    unsigned  VerticalUnits;\n    unsigned char PosSizePrecision;\n  } WPG2Start;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType1;\n\n  typedef struct\n  {\n    unsigned int Width;\n    unsigned int Height;\n    unsigned char Depth;\n    unsigned char Compression;\n  } WPG2BitmapType1;\n\n  typedef struct\n  {\n    unsigned int RotAngle;\n    unsigned int LowLeftX;\n    unsigned int LowLeftY;\n    unsigned int UpRightX;\n    unsigned int UpRightY;\n    unsigned int Width;\n    unsigned int Height;\n    unsigned int Depth;\n    unsigned int HorzRes;\n    unsigned int VertRes;\n  } WPGBitmapType2;\n\n  typedef struct\n  {\n    unsigned int StartIndex;\n    unsigned int NumOfEntries;\n  } WPGColorMapRec;\n\n  /*\n  typedef struct {\n    size_t PS_unknown1;\n    unsigned int PS_unknown2;\n    unsigned int PS_unknown3;\n  } WPGPSl1Record;  \n  */\n\n  Image\n    *image;\n\n  unsigned int\n    status;\n\n  WPGHeader\n    Header;\n\n  WPGRecord\n    Rec;\n\n  WPG2Record\n    Rec2;\n\n  WPG2Start StartWPG;\n\n  WPGBitmapType1\n    BitmapHeader1;\n\n  WPG2BitmapType1\n    Bitmap2Header1;\n\n  WPGBitmapType2\n    BitmapHeader2;\n\n  WPGColorMapRec\n    WPG_Palette;\n\n  int\n    i,\n    bpp,\n    WPG2Flags;\n\n  ssize_t\n    ldblk;\n\n  size_t\n    one;\n\n  unsigned char\n    *BImgBuff;\n\n  tCTM CTM;         /*current transform matrix*/\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  one=1;\n  image=AcquireImage(image_info,exception);\n  image->depth=8;\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read WPG image.\n  */\n  Header.FileId=ReadBlobLSBLong(image);\n  Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image);\n  Header.ProductType=ReadBlobLSBShort(image);\n  Header.FileType=ReadBlobLSBShort(image);\n  Header.MajorVersion=ReadBlobByte(image);\n  Header.MinorVersion=ReadBlobByte(image);\n  Header.EncryptKey=ReadBlobLSBShort(image);\n  Header.Reserved=ReadBlobLSBShort(image);\n\n  if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (Header.EncryptKey!=0)\n    ThrowReaderException(CoderError,\"EncryptedWPGImageFileNotSupported\");\n\n  image->columns = 1;\n  image->rows = 1;\n  image->colors = 0;\n  bpp=0;\n  BitmapHeader2.RotAngle=0;\n\n  switch(Header.FileType)\n    {\n    case 1:     /* WPG level 1 */\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec.RecordLength;\n\n          switch(Rec.RecType)\n            {\n            case 0x0B: /* bitmap type 1 */\n              BitmapHeader1.Width=ReadBlobLSBShort(image);\n              BitmapHeader1.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader1.Depth=ReadBlobLSBShort(image);\n              BitmapHeader1.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader1.VertRes=ReadBlobLSBShort(image);\n\n              if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes)\n                {\n                  image->units=PixelsPerCentimeterResolution;\n                  image->resolution.x=BitmapHeader1.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader1.VertRes/470.0;\n                }\n              image->columns=BitmapHeader1.Width;\n              image->rows=BitmapHeader1.Height;\n              bpp=BitmapHeader1.Depth;\n\n              goto UnpackRaster;\n\n            case 0x0E:  /*Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (!AcquireImageColormap(image,image->colors,exception))\n                goto NoMemory;\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image));\n                }\n              break;\n     \n            case 0x11:  /* Start PS l1 */\n              if(Rec.RecordLength > 8)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+8,   /* skip PS header in the wpg */\n                  (ssize_t) Rec.RecordLength-8,exception);\n              break;     \n\n            case 0x14:  /* bitmap type 2 */\n              BitmapHeader2.RotAngle=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftX=ReadBlobLSBShort(image);\n              BitmapHeader2.LowLeftY=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightX=ReadBlobLSBShort(image);\n              BitmapHeader2.UpRightY=ReadBlobLSBShort(image);\n              BitmapHeader2.Width=ReadBlobLSBShort(image);\n              BitmapHeader2.Height=ReadBlobLSBShort(image);\n              if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              BitmapHeader2.Depth=ReadBlobLSBShort(image);\n              BitmapHeader2.HorzRes=ReadBlobLSBShort(image);\n              BitmapHeader2.VertRes=ReadBlobLSBShort(image);\n\n              image->units=PixelsPerCentimeterResolution;\n              image->page.width=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0);\n              image->page.height=(unsigned int)\n                ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0);\n              image->page.x=(int) (BitmapHeader2.LowLeftX/470.0);\n              image->page.y=(int) (BitmapHeader2.LowLeftX/470.0);\n              if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes)\n                {\n                  image->resolution.x=BitmapHeader2.HorzRes/470.0;\n                  image->resolution.y=BitmapHeader2.VertRes/470.0;\n                }\n              image->columns=BitmapHeader2.Width;\n              image->rows=BitmapHeader2.Height;\n              bpp=BitmapHeader2.Depth;\n\n            UnpackRaster:      \n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    {\n                    NoMemory:\n                      ThrowReaderException(ResourceLimitError,\n                        \"MemoryAllocationFailed\");\n                    }\n                  /* printf(\"Load default colormap \\n\"); */\n                  for (i=0; (i < (int) image->colors) && (i < 256); i++)\n                    {               \n                      image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red);\n                      image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green);\n                      image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue);\n                    }\n                }\n              else\n                {\n                  if (bpp < 24)\n                    if ( (image->colors < (one << bpp)) && (bpp != 24) )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                        image->colormap,(size_t) (one << bpp),\n                        sizeof(*image->colormap));\n                }\n          \n              if (bpp == 1)\n                {\n                  if(image->colormap[0].red==0 &&\n                     image->colormap[0].green==0 &&\n                     image->colormap[0].blue==0 &&\n                     image->colormap[1].red==0 &&\n                     image->colormap[1].green==0 &&\n                     image->colormap[1].blue==0)\n                    {  /* fix crippled monochrome palette */\n                      image->colormap[1].red =\n                        image->colormap[1].green =\n                        image->colormap[1].blue = QuantumRange;\n                    }\n                }      \n\n              if(UnpackWPGRaster(image,bpp,exception) < 0)\n                /* The raster cannot be unpacked */\n                {\n                DecompressionFailed:\n                  ThrowReaderException(CoderError,\"UnableToDecompressImage\");\n                    }\n\n              if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping)\n                {  \n                  /* flop command */\n                  if(BitmapHeader2.RotAngle & 0x8000)\n                    {\n                      Image\n                        *flop_image;\n\n                      flop_image = FlopImage(image, exception);\n                      if (flop_image != (Image *) NULL) {\n                        DuplicateBlob(flop_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flop_image);\n                      }\n                    }\n                  /* flip command */\n                  if(BitmapHeader2.RotAngle & 0x2000)\n                    {\n                      Image\n                        *flip_image;\n\n                      flip_image = FlipImage(image, exception);\n                      if (flip_image != (Image *) NULL) {\n                        DuplicateBlob(flip_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,flip_image);\n                      }\n                    }\n                  /* rotate command */\n                  if(BitmapHeader2.RotAngle & 0x0FFF)\n                    {\n                      Image\n                        *rotate_image;\n\n                      rotate_image=RotateImage(image,(BitmapHeader2.RotAngle &\n                        0x0FFF), exception);\n                      if (rotate_image != (Image *) NULL) {\n                        DuplicateBlob(rotate_image,image);\n                        (void) RemoveLastImageFromList(&image);\n                        AppendImageToList(&image,rotate_image);\n                      }\n                    }\n                }\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x1B:  /* Postscript l2 */\n              if(Rec.RecordLength>0x3C)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+0x3C,   /* skip PS l2 header in the wpg */\n                  (ssize_t) Rec.RecordLength-0x3C,exception);\n              break;\n            }\n        }\n      break;\n\n    case 2:  /* WPG level 2 */\n      (void) memset(CTM,0,sizeof(CTM));\n      StartWPG.PosSizePrecision = 0;\n      while(!EOFBlob(image)) /* object parser loop */\n        {\n          (void) SeekBlob(image,Header.DataOffset,SEEK_SET);\n          if(EOFBlob(image))\n            break;\n\n          Rec2.Class=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rec2.RecType=(i=ReadBlobByte(image));\n          if(i==EOF)\n            break;\n          Rd_WP_DWORD(image,&Rec2.Extension);\n          Rd_WP_DWORD(image,&Rec2.RecordLength);\n          if(EOFBlob(image))\n            break;\n\n          Header.DataOffset=TellBlob(image)+Rec2.RecordLength;\n\n          switch(Rec2.RecType)\n            {\n      case 1:\n              StartWPG.HorizontalUnits=ReadBlobLSBShort(image);\n              StartWPG.VerticalUnits=ReadBlobLSBShort(image);\n              StartWPG.PosSizePrecision=ReadBlobByte(image);\n              break;\n            case 0x0C:    /* Color palette */\n              WPG_Palette.StartIndex=ReadBlobLSBShort(image);\n              WPG_Palette.NumOfEntries=ReadBlobLSBShort(image);\n\n              image->colors=WPG_Palette.NumOfEntries;\n              if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              for (i=WPG_Palette.StartIndex;\n                   i < (int)WPG_Palette.NumOfEntries; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].green=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  image->colormap[i].blue=ScaleCharToQuantum((char)\n                    ReadBlobByte(image));\n                  (void) ReadBlobByte(image);   /*Opacity??*/\n                }\n              break;\n            case 0x0E:\n              Bitmap2Header1.Width=ReadBlobLSBShort(image);\n              Bitmap2Header1.Height=ReadBlobLSBShort(image);\n              if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0))\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              Bitmap2Header1.Depth=ReadBlobByte(image);\n              Bitmap2Header1.Compression=ReadBlobByte(image);\n\n              if(Bitmap2Header1.Compression > 1)\n                continue; /*Unknown compression method */\n              switch(Bitmap2Header1.Depth)\n                {\n                case 1:\n                  bpp=1;\n                  break;\n                case 2:\n                  bpp=2;\n                  break;\n                case 3:\n                  bpp=4;\n                  break;\n                case 4:\n                  bpp=8;\n                  break;\n                case 8:\n                  bpp=24;\n                  break;\n                default:\n                  continue;  /*Ignore raster with unknown depth*/\n                }\n              image->columns=Bitmap2Header1.Width;\n              image->rows=Bitmap2Header1.Height;\n\n              if ((image->colors == 0) && (bpp != 24))\n                {\n                  size_t\n                    one;\n\n                  one=1;\n                  image->colors=one << bpp;\n                  if (!AcquireImageColormap(image,image->colors,exception))\n                    goto NoMemory;\n                }\n              else\n                {\n                  if(bpp < 24)\n                    if( image->colors<(one << bpp) && bpp!=24 )\n                      image->colormap=(PixelInfo *) ResizeQuantumMemory(\n                       image->colormap,(size_t) (one << bpp),\n                       sizeof(*image->colormap));\n                }\n\n\n              switch(Bitmap2Header1.Compression)\n                {\n                case 0:    /*Uncompressed raster*/\n                  {\n                    ldblk=(ssize_t) ((bpp*image->columns+7)/8);\n                    BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n                      ldblk+1,sizeof(*BImgBuff));\n                    if (BImgBuff == (unsigned char *) NULL)\n                      goto NoMemory;\n\n                    for(i=0; i< (ssize_t) image->rows; i++)\n                      {\n                        (void) ReadBlob(image,ldblk,BImgBuff);\n                        InsertRow(image,BImgBuff,i,bpp,exception);\n                      }\n\n                    if(BImgBuff)\n                      BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);\n                    break;\n                  }\n                case 1:    /*RLE for WPG2 */\n                  {\n                    if( UnpackWPG2Raster(image,bpp,exception) < 0)\n                      goto DecompressionFailed;\n                    break;\n                  }   \n                }\n\n              if(CTM[0][0]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flop_image;\n\n                  flop_image = FlopImage(image, exception);\n                  if (flop_image != (Image *) NULL) {\n                    DuplicateBlob(flop_image,image);\n                    (void) RemoveLastImageFromList(&image);\n                    AppendImageToList(&image,flop_image);\n                  }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     Tx(0,0)=-1;      Tx(1,0)=0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;      Tx(1,1)=1;   Tx(2,1)=0;\n                     Tx(0,2)=(WPG._2Rect.X_ur+WPG._2Rect.X_ll);\n                     Tx(1,2)=0;   Tx(2,2)=1; */\n                }\n              if(CTM[1][1]<0 && !image_info->ping)\n                {    /*?? RotAngle=360-RotAngle;*/\n                  Image\n                    *flip_image;\n\n                   flip_image = FlipImage(image, exception);\n                   if (flip_image != (Image *) NULL) {\n                     DuplicateBlob(flip_image,image);\n                     (void) RemoveLastImageFromList(&image);\n                     AppendImageToList(&image,flip_image);\n                    }\n                  /* Try to change CTM according to Flip - I am not sure, must be checked.\n                     float_matrix Tx(3,3);\n                     Tx(0,0)= 1;   Tx(1,0)= 0;   Tx(2,0)=0;\n                     Tx(0,1)= 0;   Tx(1,1)=-1;   Tx(2,1)=0;\n                     Tx(0,2)= 0;   Tx(1,2)=(WPG._2Rect.Y_ur+WPG._2Rect.Y_ll);\n                     Tx(2,2)=1; */\n              }\n\n\n              /* Allocate next image structure. */\n              AcquireNextImage(image_info,image,exception);\n              image->depth=8;\n              if (image->next == (Image *) NULL)\n                goto Finish;\n              image=SyncNextImageInList(image);\n              image->columns=image->rows=1;\n              image->colors=0;\n              break;\n\n            case 0x12:  /* Postscript WPG2*/\n        i=ReadBlobLSBShort(image);\n              if(Rec2.RecordLength > (unsigned int) i)\n                image=ExtractPostscript(image,image_info,\n                  TellBlob(image)+i,    /*skip PS header in the wpg2*/\n                  (ssize_t) (Rec2.RecordLength-i-2),exception);\n              break;\n\n      case 0x1B:          /*bitmap rectangle*/\n              WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM);\n              (void) WPG2Flags;\n              break;\n            }\n        }\n\n      break;\n\n    default:\n      {\n         ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n      }\n   }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n Finish:\n  (void) CloseBlob(image);\n\n  {\n    Image\n      *p;\n\n    ssize_t\n      scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n    /*\n      Fix scene numbers.\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=(size_t) scene++;\n  }\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"ImageFileDoesNotContainAnyImageData\");\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r W P G I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method RegisterWPGImage adds attributes for the WPG image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterWPGImage method is:\n%\n%      size_t RegisterWPGImage(void)\n%\n*/\nModuleExport size_t RegisterWPGImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"WPG\",\"WPG\",\"Word Perfect Graphics\");\n  entry->decoder=(DecodeImageHandler *) ReadWPGImage;\n  entry->magick=(IsImageFormatHandler *) IsWPG;\n  entry->flags|=CoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r W P G I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Method UnregisterWPGImage removes format registrations made by the\n%  WPG module from the list of supported formats.\n%\n%  The format of the UnregisterWPGImage method is:\n%\n%      UnregisterWPGImage(void)\n%\n*/\nModuleExport void UnregisterWPGImage(void)\n{\n  (void) UnregisterMagickInfo(\"WPG\");\n}\n"], "filenames": ["coders/wpg.c"], "buggy_code_start_loc": [324], "buggy_code_end_loc": [1397], "fixing_code_start_loc": [324], "fixing_code_end_loc": [1394], "type": "CWE-787", "message": "coders/wpg.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds write) via a crafted file.", "other": {"cve": {"id": "CVE-2016-7526", "sourceIdentifier": "security@debian.org", "published": "2017-04-20T18:59:01.187", "lastModified": "2020-11-16T19:39:56.297", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "coders/wpg.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds write) via a crafted file."}, {"lang": "es", "value": "coders/wpg.c en ImageMagick permite a atacantes remotos provocar una denegaci\u00f3n de servicio (escritura fuera de l\u00edmites) a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:-:*:*:*:*:*:*:*", "matchCriteriaId": "6E6BE7A5-6FF7-4916-B671-9EE11CA54F65"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/22/2", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93131", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.launchpad.net/bugs/1539050", "source": "security@debian.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1378758", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/998c687fb83993c13fa711d75f59a95b38ceab77", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/b60d1ed0af37c50b91a40937825b4c61e8458095", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/b6ae2f9e0ab13343c0281732d479757a8e8979c7", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/d9b2209a69ee90d8df81fb124eb66f593eb9f599", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/102", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/998c687fb83993c13fa711d75f59a95b38ceab77"}}