{"buggy_code": ["\n'use strict'\n\nconst crypto = require('crypto')\nconst fs = require('fs')\nconst path = require('path')\nconst { merge } = require('lodash')\nconst deepFreeze = require('deep-freeze')\nconst { Environment, Permission } = require('./enum')\nconst logger = require('../logger')\nconst { getGitCommit, getGitHubURL } = require('./utils')\n\nconst appRootPath = path.resolve(__dirname, '../../')\nconst env = process.env.NODE_ENV || Environment.development\nconst debugConfig = {\n  debug: (env === Environment.development)\n}\n\n// Get version string from package.json\nconst { version, repository } = require(path.join(appRootPath, 'package.json'))\n\nconst commitID = getGitCommit(appRootPath)\nconst sourceURL = getGitHubURL(repository.url, commitID || version)\nconst fullversion = commitID ? `${version}-${commitID}` : version\n\nconst packageConfig = {\n  version: version,\n  minimumCompatibleVersion: '0.5.0',\n  fullversion: fullversion,\n  sourceURL: sourceURL\n}\n\nconst configFilePath = path.resolve(appRootPath, process.env.CMD_CONFIG_FILE ||\n'config.json')\nconst fileConfig = fs.existsSync(configFilePath) ? require(configFilePath)[env] : undefined\n\nlet config = require('./default')\nmerge(config, require('./defaultSSL'))\nmerge(config, require('./oldDefault'))\nmerge(config, debugConfig)\nmerge(config, packageConfig)\nmerge(config, fileConfig)\nmerge(config, require('./oldEnvironment'))\nmerge(config, require('./hackmdEnvironment'))\nmerge(config, require('./environment'))\nmerge(config, require('./dockerSecret'))\n\nif (['debug', 'verbose', 'info', 'warn', 'error'].includes(config.loglevel)) {\n  logger.level = config.loglevel\n} else {\n  logger.error('Selected loglevel %s doesn\\'t exist, using default level \\'debug\\'. Available options: debug, verbose, info, warn, error', config.loglevel)\n}\n\n// load LDAP CA\nif (config.ldap.tlsca) {\n  let ca = config.ldap.tlsca.split(',')\n  let caContent = []\n  for (let i of ca) {\n    if (fs.existsSync(i)) {\n      caContent.push(fs.readFileSync(i, 'utf8'))\n    }\n  }\n  let tlsOptions = {\n    ca: caContent\n  }\n  config.ldap.tlsOptions = config.ldap.tlsOptions ? Object.assign(config.ldap.tlsOptions, tlsOptions) : tlsOptions\n}\n\n// Permission\nconfig.permission = Permission\nif (!config.allowAnonymous && !config.allowAnonymousEdits) {\n  delete config.permission.freely\n}\nif (!(config.defaultPermission in config.permission)) {\n  config.defaultPermission = config.permission.editable\n}\n\n// cache result, cannot change config in runtime!!!\nconfig.isStandardHTTPsPort = (function isStandardHTTPsPort () {\n  return config.useSSL && config.port === 443\n})()\nconfig.isStandardHTTPPort = (function isStandardHTTPPort () {\n  return !config.useSSL && config.port === 80\n})()\n\n// cache serverURL\nconfig.serverURL = (function getserverurl () {\n  var url = ''\n  if (config.domain) {\n    var protocol = config.protocolUseSSL ? 'https://' : 'http://'\n    url = protocol + config.domain\n    if (config.urlAddPort) {\n      if (!config.isStandardHTTPPort || !config.isStandardHTTPsPort) {\n        url += ':' + config.port\n      }\n    }\n  }\n  if (config.urlPath) {\n    url += '/' + config.urlPath\n  }\n  return url\n})()\n\nif (config.serverURL === '') {\n  logger.warn('Neither \\'domain\\' nor \\'CMD_DOMAIN\\' is configured. This can cause issues with various components.\\nHint: Make sure \\'protocolUseSSL\\' and \\'urlAddPort\\' or \\'CMD_PROTOCOL_USESSL\\' and \\'CMD_URL_ADDPORT\\' are configured properly.')\n}\n\nconfig.Environment = Environment\n\n// auth method\nconfig.isFacebookEnable = config.facebook.clientID && config.facebook.clientSecret\nconfig.isGoogleEnable = config.google.clientID && config.google.clientSecret\nconfig.isDropboxEnable = config.dropbox.clientID && config.dropbox.clientSecret\nconfig.isTwitterEnable = config.twitter.consumerKey && config.twitter.consumerSecret\nconfig.isEmailEnable = config.email\nconfig.isOpenIDEnable = config.openID\nconfig.isGitHubEnable = config.github.clientID && config.github.clientSecret\nconfig.isGitLabEnable = config.gitlab.clientID && config.gitlab.clientSecret\nconfig.isMattermostEnable = config.mattermost.clientID && config.mattermost.clientSecret\nconfig.isLDAPEnable = config.ldap.url\nconfig.isSAMLEnable = config.saml.idpSsoUrl\nconfig.isOAuth2Enable = config.oauth2.clientID && config.oauth2.clientSecret\nconfig.isPDFExportEnable = config.allowPDFExport\n\n// Check gitlab api version\nif (config.gitlab && config.gitlab.version !== 'v4' && config.gitlab.version !== 'v3') {\n  logger.warn('config.js contains wrong version (' + config.gitlab.version + ') for gitlab api; it should be \\'v3\\' or \\'v4\\'. Defaulting to v4')\n  config.gitlab.version = 'v4'\n}\n// If gitlab scope is api, enable snippets Export/import\nconfig.isGitlabSnippetsEnable = (!config.gitlab.scope || config.gitlab.scope === 'api') && config.isGitLabEnable\n\n// Only update i18n files in development setups\nconfig.updateI18nFiles = (env === Environment.development)\n\n// merge legacy values\nlet keys = Object.keys(config)\nconst uppercase = /[A-Z]/\nfor (let i = keys.length; i--;) {\n  let lowercaseKey = keys[i].toLowerCase()\n  // if the config contains uppercase letters\n  // and a lowercase version of this setting exists\n  // and the config with uppercase is not set\n  // we set the new config using the old key.\n  if (uppercase.test(keys[i]) &&\n  config[lowercaseKey] !== undefined &&\n  fileConfig[keys[i]] === undefined) {\n    logger.warn('config.js contains deprecated lowercase setting for ' + keys[i] + '. Please change your config.js file to replace ' + lowercaseKey + ' with ' + keys[i])\n    config[keys[i]] = config[lowercaseKey]\n  }\n}\n\n// Notify users about the prefix change and inform them they use legacy prefix for environment variables\nif (Object.keys(process.env).toString().indexOf('HMD_') !== -1) {\n  logger.warn('Using legacy HMD prefix for environment variables. Please change your variables in future. For details see: https://github.com/codimd/server#environment-variables-will-overwrite-other-server-configs')\n}\n\n// Generate session secret if it stays on default values\nif (config.sessionSecret === 'secret') {\n  logger.warn('Session secret not set. Using random generated one. Please set `sessionSecret` in your config.js file. All users will be logged out.')\n  config.sessionSecret = crypto.randomBytes(Math.ceil(config.sessionSecretLen / 2)) // generate crypto graphic random number\n    .toString('hex') // convert to hexadecimal format\n    .slice(0, config.sessionSecretLen) // return required number of characters\n}\n\n// Validate upload upload providers\nif (['filesystem', 's3', 'minio', 'imgur', 'azure', 'lutim'].indexOf(config.imageUploadType) === -1) {\n  logger.error('\"imageuploadtype\" is not correctly set. Please use \"filesystem\", \"s3\", \"minio\", \"azure\", \"lutim\" or \"imgur\". Defaulting to \"filesystem\"')\n  config.imageUploadType = 'filesystem'\n}\n\n// figure out mime types for image uploads\nswitch (config.imageUploadType) {\n  case 'imgur':\n    config.allowedUploadMimeTypes = [\n      'image/jpeg',\n      'image/png',\n      'image/jpg',\n      'image/gif'\n    ]\n    break\n  default:\n    config.allowedUploadMimeTypes = [\n      'image/jpeg',\n      'image/png',\n      'image/jpg',\n      'image/gif',\n      'image/svg+xml'\n    ]\n}\n\n// generate correct path\nconfig.sslCAPath.forEach(function (capath, i, array) {\n  array[i] = path.resolve(appRootPath, capath)\n})\n\nconfig.sslCertPath = path.resolve(appRootPath, config.sslCertPath)\nconfig.sslKeyPath = path.resolve(appRootPath, config.sslKeyPath)\nconfig.dhParamPath = path.resolve(appRootPath, config.dhParamPath)\nconfig.viewPath = path.resolve(appRootPath, config.viewPath)\nconfig.tmpPath = path.resolve(appRootPath, config.tmpPath)\nconfig.defaultNotePath = path.resolve(appRootPath, config.defaultNotePath)\nconfig.docsPath = path.resolve(appRootPath, config.docsPath)\nconfig.uploadsPath = path.resolve(appRootPath, config.uploadsPath)\n\n// make config readonly\nconfig = deepFreeze(config)\n\nmodule.exports = config\n"], "fixing_code": ["\n'use strict'\n\nconst crypto = require('crypto')\nconst fs = require('fs')\nconst path = require('path')\nconst { merge } = require('lodash')\nconst deepFreeze = require('deep-freeze')\nconst { Environment, Permission } = require('./enum')\nconst logger = require('../logger')\nconst { getGitCommit, getGitHubURL } = require('./utils')\n\nconst appRootPath = path.resolve(__dirname, '../../')\nconst env = process.env.NODE_ENV || Environment.development\nconst debugConfig = {\n  debug: (env === Environment.development)\n}\n\n// Get version string from package.json\nconst { version, repository } = require(path.join(appRootPath, 'package.json'))\n\nconst commitID = getGitCommit(appRootPath)\nconst sourceURL = getGitHubURL(repository.url, commitID || version)\nconst fullversion = commitID ? `${version}-${commitID}` : version\n\nconst packageConfig = {\n  version: version,\n  minimumCompatibleVersion: '0.5.0',\n  fullversion: fullversion,\n  sourceURL: sourceURL\n}\n\nconst configFilePath = path.resolve(appRootPath, process.env.CMD_CONFIG_FILE ||\n'config.json')\nconst fileConfig = fs.existsSync(configFilePath) ? require(configFilePath)[env] : undefined\n\nlet config = require('./default')\nmerge(config, require('./defaultSSL'))\nmerge(config, require('./oldDefault'))\nmerge(config, debugConfig)\nmerge(config, packageConfig)\nmerge(config, fileConfig)\nmerge(config, require('./oldEnvironment'))\nmerge(config, require('./hackmdEnvironment'))\nmerge(config, require('./environment'))\nmerge(config, require('./dockerSecret'))\n\nif (['debug', 'verbose', 'info', 'warn', 'error'].includes(config.loglevel)) {\n  logger.level = config.loglevel\n} else {\n  logger.error('Selected loglevel %s doesn\\'t exist, using default level \\'debug\\'. Available options: debug, verbose, info, warn, error', config.loglevel)\n}\n\n// load LDAP CA\nif (config.ldap.tlsca) {\n  let ca = config.ldap.tlsca.split(',')\n  let caContent = []\n  for (let i of ca) {\n    if (fs.existsSync(i)) {\n      caContent.push(fs.readFileSync(i, 'utf8'))\n    }\n  }\n  let tlsOptions = {\n    ca: caContent\n  }\n  config.ldap.tlsOptions = config.ldap.tlsOptions ? Object.assign(config.ldap.tlsOptions, tlsOptions) : tlsOptions\n}\n\n// Permission\nconfig.permission = Permission\nif (!config.allowAnonymous && !config.allowAnonymousEdits) {\n  delete config.permission.freely\n}\nif (!(config.defaultPermission in config.permission)) {\n  config.defaultPermission = config.permission.editable\n}\n\n// cache result, cannot change config in runtime!!!\nconfig.isStandardHTTPsPort = (function isStandardHTTPsPort () {\n  return config.useSSL && config.port === 443\n})()\nconfig.isStandardHTTPPort = (function isStandardHTTPPort () {\n  return !config.useSSL && config.port === 80\n})()\n\n// cache serverURL\nconfig.serverURL = (function getserverurl () {\n  var url = ''\n  if (config.domain) {\n    var protocol = config.protocolUseSSL ? 'https://' : 'http://'\n    url = protocol + config.domain\n    if (config.urlAddPort) {\n      if (!config.isStandardHTTPPort || !config.isStandardHTTPsPort) {\n        url += ':' + config.port\n      }\n    }\n  }\n  if (config.urlPath) {\n    url += '/' + config.urlPath\n  }\n  return url\n})()\n\nif (config.serverURL === '') {\n  logger.warn('Neither \\'domain\\' nor \\'CMD_DOMAIN\\' is configured. This can cause issues with various components.\\nHint: Make sure \\'protocolUseSSL\\' and \\'urlAddPort\\' or \\'CMD_PROTOCOL_USESSL\\' and \\'CMD_URL_ADDPORT\\' are configured properly.')\n}\n\nconfig.Environment = Environment\n\n// auth method\nconfig.isFacebookEnable = config.facebook.clientID && config.facebook.clientSecret\nconfig.isGoogleEnable = config.google.clientID && config.google.clientSecret\nconfig.isDropboxEnable = config.dropbox.clientID && config.dropbox.clientSecret\nconfig.isTwitterEnable = config.twitter.consumerKey && config.twitter.consumerSecret\nconfig.isEmailEnable = config.email\nconfig.isOpenIDEnable = config.openID\nconfig.isGitHubEnable = config.github.clientID && config.github.clientSecret\nconfig.isGitLabEnable = config.gitlab.clientID && config.gitlab.clientSecret\nconfig.isMattermostEnable = config.mattermost.clientID && config.mattermost.clientSecret\nconfig.isLDAPEnable = config.ldap.url\nconfig.isSAMLEnable = config.saml.idpSsoUrl\nconfig.isOAuth2Enable = config.oauth2.clientID && config.oauth2.clientSecret\nconfig.isPDFExportEnable = config.allowPDFExport\n\n// Check gitlab api version\nif (config.gitlab && config.gitlab.version !== 'v4' && config.gitlab.version !== 'v3') {\n  logger.warn('config.js contains wrong version (' + config.gitlab.version + ') for gitlab api; it should be \\'v3\\' or \\'v4\\'. Defaulting to v4')\n  config.gitlab.version = 'v4'\n}\n// If gitlab scope is api, enable snippets Export/import\nconfig.isGitlabSnippetsEnable = (!config.gitlab.scope || config.gitlab.scope === 'api') && config.isGitLabEnable\n\n// Only update i18n files in development setups\nconfig.updateI18nFiles = (env === Environment.development)\n\n// merge legacy values\nlet keys = Object.keys(config)\nconst uppercase = /[A-Z]/\nfor (let i = keys.length; i--;) {\n  let lowercaseKey = keys[i].toLowerCase()\n  // if the config contains uppercase letters\n  // and a lowercase version of this setting exists\n  // and the config with uppercase is not set\n  // we set the new config using the old key.\n  if (uppercase.test(keys[i]) &&\n  config[lowercaseKey] !== undefined &&\n  fileConfig[keys[i]] === undefined) {\n    logger.warn('config.js contains deprecated lowercase setting for ' + keys[i] + '. Please change your config.js file to replace ' + lowercaseKey + ' with ' + keys[i])\n    config[keys[i]] = config[lowercaseKey]\n  }\n}\n\n// Notify users about the prefix change and inform them they use legacy prefix for environment variables\nif (Object.keys(process.env).toString().indexOf('HMD_') !== -1) {\n  logger.warn('Using legacy HMD prefix for environment variables. Please change your variables in future. For details see: https://github.com/codimd/server#environment-variables-will-overwrite-other-server-configs')\n}\n\n// Generate session secret if it stays on default values\nif (config.sessionSecret === 'secret') {\n  logger.warn('Session secret not set. Using random generated one. Please set `sessionSecret` in your config.js file. All users will be logged out.')\n  config.sessionSecret = crypto.randomBytes(Math.ceil(config.sessionSecretLen / 2)) // generate crypto graphic random number\n    .toString('hex') // convert to hexadecimal format\n    .slice(0, config.sessionSecretLen) // return required number of characters\n}\n\n// Validate upload upload providers\nif (['filesystem', 's3', 'minio', 'imgur', 'azure', 'lutim'].indexOf(config.imageUploadType) === -1) {\n  logger.error('\"imageuploadtype\" is not correctly set. Please use \"filesystem\", \"s3\", \"minio\", \"azure\", \"lutim\" or \"imgur\". Defaulting to \"filesystem\"')\n  config.imageUploadType = 'filesystem'\n}\n\n// figure out mime types for image uploads\nswitch (config.imageUploadType) {\n  case 'imgur':\n    config.allowedUploadMimeTypes = [\n      'image/jpeg',\n      'image/png',\n      'image/jpg',\n      'image/gif'\n    ]\n    break\n  default:\n    config.allowedUploadMimeTypes = [\n      'image/jpeg',\n      'image/png',\n      'image/jpg',\n      'image/gif',\n      'image/svg+xml'\n    ]\n}\n\n// Disable PDF export due to security issue\nif (config.allowPDFExport) {\n  config.allowPDFExport = false\n  logger.warn('PDF export was disabled for this release to mitigate a critical security issue. This feature will hopefully become available again in future releases.')\n}\n\n// generate correct path\nconfig.sslCAPath.forEach(function (capath, i, array) {\n  array[i] = path.resolve(appRootPath, capath)\n})\n\nconfig.sslCertPath = path.resolve(appRootPath, config.sslCertPath)\nconfig.sslKeyPath = path.resolve(appRootPath, config.sslKeyPath)\nconfig.dhParamPath = path.resolve(appRootPath, config.dhParamPath)\nconfig.viewPath = path.resolve(appRootPath, config.viewPath)\nconfig.tmpPath = path.resolve(appRootPath, config.tmpPath)\nconfig.defaultNotePath = path.resolve(appRootPath, config.defaultNotePath)\nconfig.docsPath = path.resolve(appRootPath, config.docsPath)\nconfig.uploadsPath = path.resolve(appRootPath, config.uploadsPath)\n\n// make config readonly\nconfig = deepFreeze(config)\n\nmodule.exports = config\n"], "filenames": ["lib/config/index.js"], "buggy_code_start_loc": [191], "buggy_code_end_loc": [191], "fixing_code_start_loc": [192], "fixing_code_end_loc": [198], "type": "CWE-918", "message": "HedgeDoc (formerly known as CodiMD) is an open-source collaborative markdown editor. An attacker is able to receive arbitrary files from the file system when exporting a note to PDF. Since the code injection has to take place as note content, there fore this exploit requires the attackers ability to modify a note. This will affect all instances, which have pdf export enabled. This issue has been fixed by https://github.com/hedgedoc/hedgedoc/commit/c1789474020a6d668d616464cb2da5e90e123f65 and is available in version 1.5.0. Starting the CodiMD/HedgeDoc instance with `CMD_ALLOW_PDF_EXPORT=false` or set `\"allowPDFExport\": false` in config.json can mitigate this issue for those who cannot upgrade. This exploit works because while PhantomJS doesn't actually render the `file:///` references to the PDF file itself, it still uses them internally, and exfiltration is possible, and easy through JavaScript rendering. The impact is pretty bad, as the attacker is able to read the CodiMD/HedgeDoc `config.json` file as well any other files on the filesystem. Even though the suggested Docker deploy option doesn't have many interesting files itself, the `config.json` still often contains sensitive information, database credentials, and maybe OAuth secrets among other things.", "other": {"cve": {"id": "CVE-2021-29475", "sourceIdentifier": "security-advisories@github.com", "published": "2021-04-26T19:15:08.507", "lastModified": "2022-08-03T10:24:01.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HedgeDoc (formerly known as CodiMD) is an open-source collaborative markdown editor. An attacker is able to receive arbitrary files from the file system when exporting a note to PDF. Since the code injection has to take place as note content, there fore this exploit requires the attackers ability to modify a note. This will affect all instances, which have pdf export enabled. This issue has been fixed by https://github.com/hedgedoc/hedgedoc/commit/c1789474020a6d668d616464cb2da5e90e123f65 and is available in version 1.5.0. Starting the CodiMD/HedgeDoc instance with `CMD_ALLOW_PDF_EXPORT=false` or set `\"allowPDFExport\": false` in config.json can mitigate this issue for those who cannot upgrade. This exploit works because while PhantomJS doesn't actually render the `file:///` references to the PDF file itself, it still uses them internally, and exfiltration is possible, and easy through JavaScript rendering. The impact is pretty bad, as the attacker is able to read the CodiMD/HedgeDoc `config.json` file as well any other files on the filesystem. Even though the suggested Docker deploy option doesn't have many interesting files itself, the `config.json` still often contains sensitive information, database credentials, and maybe OAuth secrets among other things."}, {"lang": "es", "value": "\"HedgeDoc (antes se conoce como CodiMD) es un editor colaborativo de c\u00f3digo abierto. Un atacante es capaz de recibir archivos arbitrarios del sistema de archivos al exportar una nota a PDF. Dado que la inyecci\u00f3n de c\u00f3digo presente que toma lugar como contenido de la nota, esta explotaci\u00f3n requiere la habilidad de los atacantes para modificar una nota. Esto afectar\u00e1 a todas las instancias que tengan habilitada la exportaci\u00f3n a PDF. Este problema ha sido corregido por https://github.com/hedgedoc/hedgedoc/commit/c1789474020a6d668d616464cb2da5e90e123f65 y est\u00e1 disponible en versi\u00f3n 1.5.0. Iniciar la instancia de CodiMD/HedgeDoc con \"\"CMD_ALLOW_PDF_EXPORT=false\"\" o ajustar \"\"allowPDFExport\"\": false\"\" en config.json puede mitigar este problema para aquellos que no puedan actualizar. Esta explotaci\u00f3n funciona porque aunque PhantomJS no renderiza realmente las referencias \"\"file:///\"\" al archivo PDF en s\u00ed, sigue us\u00e1ndolas internamente, y la exfiltraci\u00f3n es posible, y f\u00e1cil por medio del renderizado de JavaScript. El impacto es bastante malo, ya que el atacante es capaz de leer el archivo CodiMD/HedgeDoc \"\"config.json\"\" as\u00ed como cualquier otro archivo en el sistema de archivos. Aunque la opci\u00f3n de despliegue de Docker sugerida no presenta muchos archivos interesantes en s\u00ed misma, el archivo \"\"config.json\"\" suele contener informaci\u00f3n confidencial, credenciales de bases de datos, y quiz\u00e1s secretos de OAuth entre otras cosas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.8}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}, {"lang": "en", "value": "CWE-94"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-918"}, {"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:hedgedoc:hedgedoc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5.0", "matchCriteriaId": "664CACC3-C0B6-4494-8C2E-BD90BBB01EE5"}]}]}], "references": [{"url": "https://github.com/hedgedoc/hedgedoc/commit/c1789474020a6d668d616464cb2da5e90e123f65", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hedgedoc/hedgedoc/security/advisories/GHSA-pxxg-px9v-6qf3", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hedgedoc/hedgedoc/commit/c1789474020a6d668d616464cb2da5e90e123f65"}}