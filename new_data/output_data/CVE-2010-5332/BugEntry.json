{"buggy_code": ["/*\n * Copyright (c) 2007 Mellanox Technologies. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <linux/errno.h>\n#include <linux/if_ether.h>\n\n#include <linux/mlx4/cmd.h>\n\n#include \"mlx4.h\"\n\n#define MLX4_MAC_VALID\t\t(1ull << 63)\n#define MLX4_MAC_MASK\t\t0xffffffffffffULL\n\n#define MLX4_VLAN_VALID\t\t(1u << 31)\n#define MLX4_VLAN_MASK\t\t0xfff\n\nvoid mlx4_init_mac_table(struct mlx4_dev *dev, struct mlx4_mac_table *table)\n{\n\tint i;\n\n\tmutex_init(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\n\t\ttable->entries[i] = 0;\n\t\ttable->refs[i]\t = 0;\n\t}\n\ttable->max   = 1 << dev->caps.log_num_macs;\n\ttable->total = 0;\n}\n\nvoid mlx4_init_vlan_table(struct mlx4_dev *dev, struct mlx4_vlan_table *table)\n{\n\tint i;\n\n\tmutex_init(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\ttable->entries[i] = 0;\n\t\ttable->refs[i]\t = 0;\n\t}\n\ttable->max   = 1 << dev->caps.log_num_vlans;\n\ttable->total = 0;\n}\n\nstatic int mlx4_set_port_mac_table(struct mlx4_dev *dev, u8 port,\n\t\t\t\t   __be64 *entries)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tu32 in_mod;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tmemcpy(mailbox->buf, entries, MLX4_MAC_TABLE_SIZE);\n\n\tin_mod = MLX4_SET_PORT_MAC_TABLE << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\n\t\t       MLX4_CMD_TIME_CLASS_B);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx4_register_mac);\n\nvoid mlx4_unregister_mac(struct mlx4_dev *dev, u8 port, int index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\n\tmutex_lock(&table->mutex);\n\tif (!table->refs[index]) {\n\t\tmlx4_warn(dev, \"No MAC entry for index %d\\n\", index);\n\t\tgoto out;\n\t}\n\tif (--table->refs[index]) {\n\t\tmlx4_warn(dev, \"Have more references for index %d,\"\n\t\t\t  \"no need to modify MAC table\\n\", index);\n\t\tgoto out;\n\t}\n\ttable->entries[index] = 0;\n\tmlx4_set_port_mac_table(dev, port, table->entries);\n\t--table->total;\nout:\n\tmutex_unlock(&table->mutex);\n}\nEXPORT_SYMBOL_GPL(mlx4_unregister_mac);\n\nstatic int mlx4_set_port_vlan_table(struct mlx4_dev *dev, u8 port,\n\t\t\t\t    __be32 *entries)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tu32 in_mod;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tmemcpy(mailbox->buf, entries, MLX4_VLAN_TABLE_SIZE);\n\tin_mod = MLX4_SET_PORT_VLAN_TABLE << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\n\t\t       MLX4_CMD_TIME_CLASS_B);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\n\treturn err;\n}\n\nint mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (table->total == table->max) {\n\t\t/* No free vlan entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx4_register_vlan);\n\nvoid mlx4_unregister_vlan(struct mlx4_dev *dev, u8 port, int index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\n\tif (index < MLX4_VLAN_REGULAR) {\n\t\tmlx4_warn(dev, \"Trying to free special vlan index %d\\n\", index);\n\t\treturn;\n\t}\n\n\tmutex_lock(&table->mutex);\n\tif (!table->refs[index]) {\n\t\tmlx4_warn(dev, \"No vlan entry for index %d\\n\", index);\n\t\tgoto out;\n\t}\n\tif (--table->refs[index]) {\n\t\tmlx4_dbg(dev, \"Have more references for index %d,\"\n\t\t\t \"no need to modify vlan table\\n\", index);\n\t\tgoto out;\n\t}\n\ttable->entries[index] = 0;\n\tmlx4_set_port_vlan_table(dev, port, table->entries);\n\t--table->total;\nout:\n\tmutex_unlock(&table->mutex);\n}\nEXPORT_SYMBOL_GPL(mlx4_unregister_vlan);\n\nint mlx4_get_port_ib_caps(struct mlx4_dev *dev, u8 port, __be32 *caps)\n{\n\tstruct mlx4_cmd_mailbox *inmailbox, *outmailbox;\n\tu8 *inbuf, *outbuf;\n\tint err;\n\n\tinmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(inmailbox))\n\t\treturn PTR_ERR(inmailbox);\n\n\toutmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(outmailbox)) {\n\t\tmlx4_free_cmd_mailbox(dev, inmailbox);\n\t\treturn PTR_ERR(outmailbox);\n\t}\n\n\tinbuf = inmailbox->buf;\n\toutbuf = outmailbox->buf;\n\tmemset(inbuf, 0, 256);\n\tmemset(outbuf, 0, 256);\n\tinbuf[0] = 1;\n\tinbuf[1] = 1;\n\tinbuf[2] = 1;\n\tinbuf[3] = 1;\n\t*(__be16 *) (&inbuf[16]) = cpu_to_be16(0x0015);\n\t*(__be32 *) (&inbuf[20]) = cpu_to_be32(port);\n\n\terr = mlx4_cmd_box(dev, inmailbox->dma, outmailbox->dma, port, 3,\n\t\t\t   MLX4_CMD_MAD_IFC, MLX4_CMD_TIME_CLASS_C);\n\tif (!err)\n\t\t*caps = *(__be32 *) (outbuf + 84);\n\tmlx4_free_cmd_mailbox(dev, inmailbox);\n\tmlx4_free_cmd_mailbox(dev, outmailbox);\n\treturn err;\n}\n\nint mlx4_SET_PORT(struct mlx4_dev *dev, u8 port)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tint err;\n\n\tif (dev->caps.port_type[port] == MLX4_PORT_TYPE_ETH)\n\t\treturn 0;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tmemset(mailbox->buf, 0, 256);\n\n\t((__be32 *) mailbox->buf)[1] = dev->caps.ib_port_def_cap[port];\n\terr = mlx4_cmd(dev, mailbox->dma, port, 0, MLX4_CMD_SET_PORT,\n\t\t       MLX4_CMD_TIME_CLASS_B);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2007 Mellanox Technologies. All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * OpenIB.org BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <linux/errno.h>\n#include <linux/if_ether.h>\n\n#include <linux/mlx4/cmd.h>\n\n#include \"mlx4.h\"\n\n#define MLX4_MAC_VALID\t\t(1ull << 63)\n#define MLX4_MAC_MASK\t\t0xffffffffffffULL\n\n#define MLX4_VLAN_VALID\t\t(1u << 31)\n#define MLX4_VLAN_MASK\t\t0xfff\n\nvoid mlx4_init_mac_table(struct mlx4_dev *dev, struct mlx4_mac_table *table)\n{\n\tint i;\n\n\tmutex_init(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM; i++) {\n\t\ttable->entries[i] = 0;\n\t\ttable->refs[i]\t = 0;\n\t}\n\ttable->max   = 1 << dev->caps.log_num_macs;\n\ttable->total = 0;\n}\n\nvoid mlx4_init_vlan_table(struct mlx4_dev *dev, struct mlx4_vlan_table *table)\n{\n\tint i;\n\n\tmutex_init(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\ttable->entries[i] = 0;\n\t\ttable->refs[i]\t = 0;\n\t}\n\ttable->max   = 1 << dev->caps.log_num_vlans;\n\ttable->total = 0;\n}\n\nstatic int mlx4_set_port_mac_table(struct mlx4_dev *dev, u8 port,\n\t\t\t\t   __be64 *entries)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tu32 in_mod;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tmemcpy(mailbox->buf, entries, MLX4_MAC_TABLE_SIZE);\n\n\tin_mod = MLX4_SET_PORT_MAC_TABLE << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\n\t\t       MLX4_CMD_TIME_CLASS_B);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t/* MAC already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\n\tif (table->total == table->max) {\n\t\t/* No free mac entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx4_register_mac);\n\nvoid mlx4_unregister_mac(struct mlx4_dev *dev, u8 port, int index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\n\tmutex_lock(&table->mutex);\n\tif (!table->refs[index]) {\n\t\tmlx4_warn(dev, \"No MAC entry for index %d\\n\", index);\n\t\tgoto out;\n\t}\n\tif (--table->refs[index]) {\n\t\tmlx4_warn(dev, \"Have more references for index %d,\"\n\t\t\t  \"no need to modify MAC table\\n\", index);\n\t\tgoto out;\n\t}\n\ttable->entries[index] = 0;\n\tmlx4_set_port_mac_table(dev, port, table->entries);\n\t--table->total;\nout:\n\tmutex_unlock(&table->mutex);\n}\nEXPORT_SYMBOL_GPL(mlx4_unregister_mac);\n\nstatic int mlx4_set_port_vlan_table(struct mlx4_dev *dev, u8 port,\n\t\t\t\t    __be32 *entries)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tu32 in_mod;\n\tint err;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tmemcpy(mailbox->buf, entries, MLX4_VLAN_TABLE_SIZE);\n\tin_mod = MLX4_SET_PORT_VLAN_TABLE << 8 | port;\n\terr = mlx4_cmd(dev, mailbox->dma, in_mod, 1, MLX4_CMD_SET_PORT,\n\t\t       MLX4_CMD_TIME_CLASS_B);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\n\treturn err;\n}\n\nint mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t/* Vlan already registered, increase refernce count */\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (table->total == table->max) {\n\t\t/* No free vlan entries */\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* Register new MAC */\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mlx4_register_vlan);\n\nvoid mlx4_unregister_vlan(struct mlx4_dev *dev, u8 port, int index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\n\tif (index < MLX4_VLAN_REGULAR) {\n\t\tmlx4_warn(dev, \"Trying to free special vlan index %d\\n\", index);\n\t\treturn;\n\t}\n\n\tmutex_lock(&table->mutex);\n\tif (!table->refs[index]) {\n\t\tmlx4_warn(dev, \"No vlan entry for index %d\\n\", index);\n\t\tgoto out;\n\t}\n\tif (--table->refs[index]) {\n\t\tmlx4_dbg(dev, \"Have more references for index %d,\"\n\t\t\t \"no need to modify vlan table\\n\", index);\n\t\tgoto out;\n\t}\n\ttable->entries[index] = 0;\n\tmlx4_set_port_vlan_table(dev, port, table->entries);\n\t--table->total;\nout:\n\tmutex_unlock(&table->mutex);\n}\nEXPORT_SYMBOL_GPL(mlx4_unregister_vlan);\n\nint mlx4_get_port_ib_caps(struct mlx4_dev *dev, u8 port, __be32 *caps)\n{\n\tstruct mlx4_cmd_mailbox *inmailbox, *outmailbox;\n\tu8 *inbuf, *outbuf;\n\tint err;\n\n\tinmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(inmailbox))\n\t\treturn PTR_ERR(inmailbox);\n\n\toutmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(outmailbox)) {\n\t\tmlx4_free_cmd_mailbox(dev, inmailbox);\n\t\treturn PTR_ERR(outmailbox);\n\t}\n\n\tinbuf = inmailbox->buf;\n\toutbuf = outmailbox->buf;\n\tmemset(inbuf, 0, 256);\n\tmemset(outbuf, 0, 256);\n\tinbuf[0] = 1;\n\tinbuf[1] = 1;\n\tinbuf[2] = 1;\n\tinbuf[3] = 1;\n\t*(__be16 *) (&inbuf[16]) = cpu_to_be16(0x0015);\n\t*(__be32 *) (&inbuf[20]) = cpu_to_be32(port);\n\n\terr = mlx4_cmd_box(dev, inmailbox->dma, outmailbox->dma, port, 3,\n\t\t\t   MLX4_CMD_MAD_IFC, MLX4_CMD_TIME_CLASS_C);\n\tif (!err)\n\t\t*caps = *(__be32 *) (outbuf + 84);\n\tmlx4_free_cmd_mailbox(dev, inmailbox);\n\tmlx4_free_cmd_mailbox(dev, outmailbox);\n\treturn err;\n}\n\nint mlx4_SET_PORT(struct mlx4_dev *dev, u8 port)\n{\n\tstruct mlx4_cmd_mailbox *mailbox;\n\tint err;\n\n\tif (dev->caps.port_type[port] == MLX4_PORT_TYPE_ETH)\n\t\treturn 0;\n\n\tmailbox = mlx4_alloc_cmd_mailbox(dev);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\n\tmemset(mailbox->buf, 0, 256);\n\n\t((__be32 *) mailbox->buf)[1] = dev->caps.ib_port_def_cap[port];\n\terr = mlx4_cmd(dev, mailbox->dma, port, 0, MLX4_CMD_SET_PORT,\n\t\t       MLX4_CMD_TIME_CLASS_B);\n\n\tmlx4_free_cmd_mailbox(dev, mailbox);\n\treturn err;\n}\n"], "filenames": ["drivers/net/mlx4/port.c"], "buggy_code_start_loc": [113], "buggy_code_end_loc": [205], "fixing_code_start_loc": [114], "fixing_code_end_loc": [217], "type": "CWE-119", "message": "In the Linux kernel before 2.6.37, an out of bounds array access happened in drivers/net/mlx4/port.c. When searching for a free entry in either mlx4_register_vlan() or mlx4_register_mac(), and there is no free entry, the loop terminates without updating the local variable free thus causing out of array bounds access.", "other": {"cve": {"id": "CVE-2010-5332", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-27T22:15:11.150", "lastModified": "2020-02-18T16:44:57.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 2.6.37, an out of bounds array access happened in drivers/net/mlx4/port.c. When searching for a free entry in either mlx4_register_vlan() or mlx4_register_mac(), and there is no free entry, the loop terminates without updating the local variable free thus causing out of array bounds access."}, {"lang": "es", "value": "En el kernel de Linux anterior a versi\u00f3n 2.6.37, se produjo un acceso a la matriz fuera de l\u00edmites en el archivo drivers/net/mlx4/port.c. Cuando se busca una entrada liberada en cualquiera de las funciones mlx4_register_vlan() o mlx4_register_mac(), y no se presenta ninguna entrada liberada, el bucle termina sin actualizar la liberaci\u00f3n de la variable local, lo que causa un acceso fuera de l\u00edmites de la matriz."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 5.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.37", "matchCriteriaId": "76630B45-B590-4651-972E-F938A83010C0"}]}]}], "references": [{"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=0926f91083f34d047abc74f1ca4fa6a9c161f7db", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/0926f91083f34d047abc74f1ca4fa6a9c161f7db", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://mirrors.edge.kernel.org/pub/linux/kernel/v2.6/ChangeLog-2.6.37", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://support.f5.com/csp/article/K04146019", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K04146019?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/0926f91083f34d047abc74f1ca4fa6a9c161f7db"}}