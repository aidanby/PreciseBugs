{"buggy_code": ["<?xml version=\"1.0\"?>\n<!DOCTYPE chapter PUBLIC \"-//OASIS//DTD DocBook XML V4.3//EN\"\n\t\"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd\">\n<chapter id=\"embedding\">\n  <title>Embedding and Integrating Cockpit</title>\n\n  <para>Cockpit can be embedded in other web applications either as a whole or specific\n    Cockpit components can be integrated.</para>\n\n  <section id=\"embedding-full\">\n    <title>Embedding the Cockpit Interface</title>\n\n    <para>Cockpit can be embedded into a larger web page as a frame. To embed\n      the entire Cockpit Window use the URI:\n      <code>https://server.example.com:9090/</code></para>\n\n    <programlisting language=\"html\"><![CDATA[\n<html>\n  <head>\n    <title>Embedded Cockpit</title>\n  </head>\n  <body>\n    This is Cockpit.\n    <br/>\n    <iframe width=\"800px\" height=\"600px\"\n            src=\"https://server.example.com:9090/\"/>\n  </body>\n</html>\n]]></programlisting>\n\n  </section>\n\n  <section id=\"embedding-components\">\n    <title>Integrating Cockpit Components into Web Applications</title>\n\n    <para>Instead of embedding the entirety of Cockpit, you can integrate specific components.\n      Only those components explicitly documented as API should be integrated. Other components\n      can and will change regularly.</para>\n\n    <para>The component will load from the server in question and a WebSocket connection\n      will be established with the server to relay the component's message stream.</para>\n\n    <para>Cockpit components are HTML files contained in\n      <link linkend=\"packages\">packages</link>. These can be placed in an iframe or web browser\n      window. Each documented and stable component has a well-known URL and these are documented\n      in the <link linkend=\"development\">API reference</link>. Each component URL begins with the string\n      <code>/cockpit/@localhost/</code> followed a package name, and then the component itself.</para>\n\n    <para>For example the\n      <link linkend=\"api-terminal-html\">terminal.html</link> in the\n      <link linkend=\"api-system\">system</link> package, has this URL:\n      <code>/cockpit/@localhost/system/terminal.html</code></para>\n\n    <programlisting language=\"html\"><![CDATA[\n<html>\n  <head>\n    <title>Embedded Terminal</title>\n  </head>\n  <body>\n    This is a terminal.\n    <br/>\n    <iframe width=\"800px\" height=\"600px\"\n      src=\"https://server.example.com:9090/cockpit/@localhost/system/terminal.html\"/>\n  </body>\n</html>\n]]></programlisting>\n\n  </section>\n\n  <section id=\"embedding-deep\">\n    <title>Deep Integration</title>\n\n    <para>Most often <link linkend=\"embedding-components\">simple integration</link> will be used\n      to bring Cockpit components into web applications. However it is also possible to do deep\n      integration for embedders who wish to perform non-standard authentication with the server,\n      and relay the component's message stream to the server themselves.</para>\n\n    <warning>\n      <para>Deep integration capability is in heavy flux and is not yet documented.</para>\n    </warning>\n  </section>\n\n  <section id=\"embedding-cors\">\n    <title>Pinging Cockpit</title>\n\n    <para>When embedding Cockpit or integrating Cockpit components, it may be necessary to check\n      whether Cockpit is available on a server before proceeding.</para>\n\n    <para>To do this perform a <code>/ping</code> request to Cockpit. This is a simple HTTP\n      GET request. It returns the following:</para>\n\n<programlisting>\nGET: https://server.example.com:9090/ping\n200 OK: { \"service\": \"cockpit\" }\n</programlisting>\n\n    <para>The <code>/ping</code> request allows\n      <ulink url=\"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\">Cross Origin Resource Sharing</ulink>\n      headers and as such can be performed from Javascript code with any origin. The request can also be\n      made via plain HTTP without SSL. It is by design that no further information is present in the\n      response.</para>\n\n    <para>A complete example of using <code>/ping</code> is available in the Cockpit sources in the\n      <code>/examples/ping-server/</code> directory.</para>\n\n  </section>\n\n</chapter>\n", "import cockpit from \"cockpit\";\nimport QUnit from \"qunit-tests\";\n\n/* Set this to a regexp to ignore that warning once */\n/*\nfunction console_ignore_warning(exp) {\n    var console_warn = console.warn;\n    console.warn = function() {\n        if (!exp.exec(arguments[0]))\n            console_warn.apply(console, arguments);\n        console.warn = console_warn;\n    };\n}\n*/\n\nQUnit.test(\"public api\", function (assert) {\n    var client = cockpit.http(\"/test\");\n    assert.equal(typeof client, \"object\", \"http is an object\");\n    assert.equal(typeof client.get, \"function\", \"http.get() is a function\");\n    assert.equal(typeof client.post, \"function\", \"http.post() is a function\");\n});\n\nQUnit.test(\"simple request\", function (assert) {\n    const done = assert.async();\n    assert.expect(2);\n\n    cockpit.http({ internal: \"/test-server\" }).get(\"/pkg/playground/manifest.json\")\n            .done(function(data) {\n                assert.deepEqual(JSON.parse(data), {\n                    requires: {\n                        cockpit: \"122\"\n                    },\n\n                    tools: {\n                        index: {\n                            label: \"Development\"\n                        }\n                    },\n\n                    playground: {\n                        \"react-patterns\": {\n                            label: \"React Patterns\"\n                        },\n                        translate: {\n                            label: \"Translating\"\n                        },\n                        exception: {\n                            label: \"Exceptions\"\n                        },\n                        pkgs: {\n                            label: \"Packages\"\n                        },\n                        preloaded: {\n                            label: \"Preloaded\"\n                        },\n                        \"notifications-receiver\": {\n                            label: \"Notifications Receiver\"\n                        },\n                        metrics: {\n                            label: \"Monitoring\"\n                        },\n                        plot: {\n                            label: \"Plots\"\n                        },\n                        service: {\n                            label: \"Generic Service Monitor\"\n                        },\n                        speed: {\n                            label: \"Speed Tests\"\n                        },\n                        journal: {\n                            label: \"Logs Box\"\n                        },\n                        test: {\n                            label: \"Playground\"\n                        }\n                    },\n                    preload: [\"preloaded\"],\n                    \"content-security-policy\": \"img-src 'self' data:\"\n                }, \"returned right data\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"didn't fail\");\n                done();\n            });\n});\n\nQUnit.test(\"with params\", function (assert) {\n    const done = assert.async();\n    assert.expect(2);\n\n    cockpit.http({ internal: \"/test-server\" })\n            .get(\"/mock/qs\", { key: \"value\", name: \"Scruffy the Janitor\" })\n            .done(function(resp) {\n                assert.equal(resp, \"key=value&name=Scruffy+the+Janitor\", \"right query string\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"didn't fail\");\n                done();\n            });\n});\n\nQUnit.test(\"not found\", function (assert) {\n    const done = assert.async();\n    assert.expect(7);\n\n    var promise = cockpit.http({ internal: \"/test-server\" })\n            .get(\"/not/found\")\n            .response(function(status, headers) {\n                assert.equal(status, 404, \"status code\");\n                assert.strictEqual(this, promise, \"got right this\");\n            })\n            .fail(function(ex, data) {\n                assert.strictEqual(ex.problem, null, \"mapped to cockpit code\");\n                assert.strictEqual(ex.status, 404, \"has status code\");\n                assert.equal(ex.message, \"Not Found\", \"has reason\");\n                assert.equal(data, \"<html><head><title>Not Found</title></head><body>Not Found</body></html>\\n\", \"got body\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"rejected\", \"should fail\");\n                done();\n            });\n});\n\nQUnit.test(\"streaming\", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    var at = 0;\n    var got = \"\";\n    var promise = cockpit.http({ internal: \"/test-server\" })\n            .get(\"/mock/stream\")\n            .stream(function(resp) {\n                if (at === 0)\n                    assert.strictEqual(this, promise, \"got right this\");\n                got += resp;\n                at++;\n            })\n            .always(function() {\n                var expected = \"\";\n                for (var i = 0; i < at; i++)\n                    expected += String(i) + \" \";\n                assert.equal(got, expected, \"stream got right data\");\n                assert.equal(this.state(), \"resolved\", \"split response didn't fail\");\n                done();\n            });\n});\n\nQUnit.test(\"close\", function (assert) {\n    const done = assert.async();\n    assert.expect(4);\n\n    var req = cockpit.http({ internal: \"/test-server\" }).get(\"/mock/stream\");\n\n    var at = 0;\n    req.stream(function(resp) {\n        at += 1;\n        assert.equal(resp, \"0 \", \"first stream part\");\n        this.close(\"bad-boy\");\n    })\n            .fail(function(ex) {\n                assert.equal(ex.problem, \"bad-boy\", \"right problem\");\n            })\n            .always(function() {\n                assert.equal(at, 1, \"stream got cancelled\");\n                assert.equal(this.state(), \"rejected\", \"cancelling a response rejects it\");\n                done();\n            });\n});\n\nQUnit.test(\"close all\", function (assert) {\n    const done = assert.async();\n    assert.expect(4);\n\n    var http = cockpit.http({ internal: \"/test-server\" });\n    var req = http.get(\"/mock/stream\");\n\n    var at = 0;\n    req.stream(function(resp) {\n        at += 1;\n        assert.equal(resp, \"0 \", \"first stream part\");\n        http.close(\"bad-boy\");\n    })\n            .fail(function(ex) {\n                assert.equal(ex.problem, \"bad-boy\", \"right problem\");\n            })\n            .always(function() {\n                assert.equal(at, 1, \"stream got cancelled\");\n                assert.equal(this.state(), \"rejected\", \"cancelling a response rejects it\");\n                http.close(\"closed\"); // This should be a no-op now\n                done();\n            });\n});\n\nQUnit.test(\"headers\", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    cockpit.http({ internal: \"/test-server\" })\n            .get(\"/mock/headers\", null, { Header1: \"booo\", Header2: \"yay value\" })\n            .response(function(status, headers) {\n                assert.equal(status, 201, \"status code\");\n                assert.deepEqual(headers, {\n                    Header1: \"booo\",\n                    Header2: \"yay value\",\n                    Header3: \"three\",\n                    Header4: \"marmalade\",\n                    \"Referrer-Policy\": \"no-referrer\",\n                    \"X-DNS-Prefetch-Control\": \"off\",\n                    \"X-Content-Type-Options\": \"nosniff\",\n                    \"Cross-Origin-Resource-Policy\": \"same-origin\",\n                }, \"got back headers\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"split response didn't fail\");\n                done();\n            });\n});\n\nQUnit.test(\"escape host header\", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    cockpit.http({ internal: \"/test-server\" })\n            .get(\"/mock/host\", null, { })\n            .response(function(status, headers) {\n                assert.equal(status, 201, \"status code\");\n                assert.deepEqual(headers.Host, \"%2Ftest-server\", \"got back escaped headers\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"split response didn't fail\");\n                done();\n            });\n});\n\nQUnit.test(\"connection headers\", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    cockpit.http({ internal: \"/test-server\", headers: { Header1: \"booo\", Header2: \"not this\" } })\n            .get(\"/mock/headers\", null, { Header2: \"yay value\", Header0: \"extra\" })\n            .response(function(status, headers) {\n                assert.equal(status, 201, \"status code\");\n                assert.deepEqual(headers, {\n                    Header0: \"extra\",\n                    Header1: \"booo\",\n                    Header2: \"yay value\",\n                    Header3: \"three\",\n                    Header4: \"marmalade\",\n                    \"Referrer-Policy\": \"no-referrer\",\n                    \"X-DNS-Prefetch-Control\": \"off\",\n                    \"X-Content-Type-Options\": \"nosniff\",\n                    \"Cross-Origin-Resource-Policy\": \"same-origin\",\n                }, \"got back combined headers\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"split response didn't fail\");\n                done();\n            });\n});\n\nQUnit.test(\"http promise recursive\", function (assert) {\n    assert.expect(7);\n\n    var promise = cockpit.http({ internal: \"/test-server\" }).get(\"/\");\n\n    var target = { };\n    var promise2 = promise.promise(target);\n    assert.strictEqual(promise2, target, \"used target\");\n    assert.equal(typeof promise2.done, \"function\", \"promise2.done()\");\n    assert.equal(typeof promise2.promise, \"function\", \"promise2.promise()\");\n    assert.equal(typeof promise2.input, \"function\", \"promise2.input()\");\n\n    var promise3 = promise2.promise();\n    assert.equal(typeof promise3.done, \"function\", \"promise3.done()\");\n    assert.equal(typeof promise3.promise, \"function\", \"promise3.promise()\");\n    assert.equal(typeof promise3.input, \"function\", \"promise3.input()\");\n});\n\nQUnit.test(\"http keep alive\", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    /*\n     * The /mock/connection handler returns an identifier that changes if\n     * a different connection is used.\n     */\n\n    var first;\n    cockpit.http({ internal: \"/test-server\", connection: \"marmalade\" }).get(\"/mock/connection\")\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"response didn't fail\");\n            })\n            .done(function(data) {\n                first = data;\n                cockpit.http({ internal: \"/test-server\", connection: \"marmalade\" }).get(\"/mock/connection\")\n                        .done(function(data) {\n                            assert.equal(first, data, \"same connection\");\n                        })\n                        .always(function() {\n                            assert.equal(this.state(), \"resolved\", \"response didn't fail\");\n                            done();\n                        });\n            });\n});\n\nQUnit.test(\"http connection different\", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    /*\n     * The /mock/connection handler returns an identifier that changes if\n     * a different connection is used.\n     */\n\n    var first;\n    cockpit.http({ internal: \"/test-server\", connection: \"one\" }).get(\"/mock/connection\")\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"response didn't fail\");\n            })\n            .done(function(data) {\n                first = data;\n                cockpit.http({ internal: \"/test-server\", connection: \"two\" }).get(\"/mock/connection\")\n                        .done(function(data) {\n                            assert.notEqual(first, data, \"different connection\");\n                        })\n                        .always(function() {\n                            assert.equal(this.state(), \"resolved\", \"response didn't fail\");\n                            done();\n                        });\n            });\n});\n\nQUnit.test(\"http connection without address \", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    /*\n     * Able to reuse connection client info and not specify address again.\n     */\n\n    var first;\n    cockpit.http({ internal: \"/test-server\", connection: \"one\" }).get(\"/mock/connection\")\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"response didn't fail\");\n            })\n            .done(function(data) {\n                first = data;\n                cockpit.http({ connection: \"one\" }).get(\"/mock/connection\")\n                        .done(function(data) {\n                            assert.equal(first, data, \"different connection\");\n                        })\n                        .always(function() {\n                            assert.equal(this.state(), \"resolved\", \"response didn't fail\");\n                            done();\n                        });\n            });\n});\n\nQUnit.test(\"no dns address\", function (assert) {\n    const done = assert.async();\n    assert.expect(2);\n\n    cockpit.http({\n        port: 8080,\n        address: \"the-other-host.example.com\"\n    })\n            .get(\"/\")\n            .fail(function(ex, data) {\n            /* Unfortunately we can see either of these errors when running unit tests */\n                if (ex.problem === \"timeout\")\n                    ex.problem = \"not-found\";\n                assert.strictEqual(ex.problem, \"not-found\", \"can't resolve is not found\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"rejected\", \"should fail\");\n                done();\n            });\n});\n\nQUnit.test(\"address with params\", function (assert) {\n    const done = assert.async();\n    // use our window's host and port to request external\n    assert.expect(2);\n\n    cockpit.http({\n        port: parseInt(window.location.port, 10),\n        address: window.location.hostname\n    })\n            .get(\"/mock/qs\", { key: \"value\", name: \"Scruffy the Janitor\" })\n            .done(function(resp) {\n                assert.equal(resp, \"key=value&name=Scruffy+the+Janitor\", \"right query string\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"didn't fail\");\n                done();\n            });\n});\n\nQUnit.start();\n", "\n/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2013 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include \"cockpithttpstream.h\"\n\n#include \"common/cockpitjson.h\"\n#include \"common/cockpittest.h\"\n#include \"common/cockpitwebresponse.h\"\n#include \"common/cockpitwebserver.h\"\n#include \"common/mock-transport.h\"\n\n#include <string.h>\n\n/* Declared in cockpitwebserver.c */\nextern gboolean cockpit_webserver_want_certificate;\n\n/* JSON dict snippet for headers that are present in every request */\n#define STATIC_HEADERS \"\\\"Cross-Origin-Resource-Policy\\\":\\\"same-origin\\\",\\\"Referrer-Policy\\\":\\\"no-referrer\\\",\\\"X-Content-Type-Options\\\":\\\"nosniff\\\",\\\"X-DNS-Prefetch-Control\\\":\\\"off\\\"\"\n\nstatic void\non_closed_set_flag (CockpitChannel *channel,\n                    const gchar *problem,\n                    gpointer user_data)\n{\n  gboolean *flag = user_data;\n  g_assert (flag != NULL);\n  g_assert (*flag != TRUE);\n  *flag = TRUE;\n}\n\ntypedef struct {\n  CockpitWebServer *web_server;\n  guint port;\n  MockTransport *transport;\n  const char *host;\n} TestGeneral;\n\n\nstatic gchar *\nnon_local_ip (void)\n{\n  GInetAddress *inet;\n  gchar *str = NULL;\n  inet = cockpit_test_find_non_loopback_address ();\n  if (inet)\n    {\n      str = g_inet_address_to_string (inet);\n      g_object_unref (inet);\n    }\n\n  return str;\n}\n\nstatic void\nsetup_general (TestGeneral *tt,\n               gconstpointer host_fixture)\n{\n  tt->web_server = cockpit_web_server_new (NULL, 0, NULL, COCKPIT_WEB_SERVER_NONE, NULL, NULL);\n  cockpit_web_server_start (tt->web_server);\n  tt->port = cockpit_web_server_get_port (tt->web_server);\n  tt->transport = mock_transport_new ();\n  tt->host = host_fixture;\n}\n\nstatic void\nteardown_general (TestGeneral *tt,\n                  gconstpointer unused)\n{\n  g_object_unref (tt->web_server);\n  g_object_unref (tt->transport);\n\n  cockpit_assert_expected ();\n}\n\nstatic gboolean\nhandle_host_header (CockpitWebServer *server,\n                    const gchar *path,\n                    GHashTable *headers,\n                    CockpitWebResponse *response,\n                    gpointer user_data)\n{\n  TestGeneral *tt = user_data;\n  const gchar *data = \"Da Da Da\";\n  gchar *expected;\n  GBytes *bytes;\n\n  expected = g_strdup_printf (\"%s:%d\", tt->host, tt->port);\n  g_assert_cmpstr (g_hash_table_lookup (headers, \"Host\"), ==, expected);\n  g_free (expected);\n\n  bytes = g_bytes_new_static (data, strlen (data));\n  cockpit_web_response_content (response, NULL, bytes, NULL);\n  g_bytes_unref (bytes);\n\n  return TRUE;\n}\n\n/* Compare subsequent \"{ control JSON }\" and \"body\" channel messages against expected values. */\nstatic void\nassert_channel_response (MockTransport *transport,\n                         const gchar *channel_id,\n                         const gchar *expected_control,\n                         const gchar *expected_body)\n{\n  GBytes *data;\n\n  data = mock_transport_pop_channel (transport, channel_id);\n  JsonNode *node = cockpit_json_parse (g_bytes_get_data (data, NULL), -1, NULL);\n  cockpit_assert_json_eq (json_node_get_object (node), expected_control);\n  json_node_unref (node);\n\n  data = mock_transport_pop_channel (transport, channel_id);\n  cockpit_assert_bytes_eq (data, expected_body, -1);\n}\n\nstatic void\ntest_host_header (TestGeneral *tt,\n                  gconstpointer unused)\n{\n  CockpitChannel *channel;\n  GBytes *bytes;\n  JsonObject *options;\n  const gchar *control;\n  gboolean closed;\n\n  if (tt->host == NULL)\n    {\n      g_test_skip (\"Couldn't determine non local ip\");\n      return;\n    }\n\n  g_signal_connect (tt->web_server, \"handle-resource::/\", G_CALLBACK (handle_host_header), tt);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", tt->port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/\");\n\n  if (g_strcmp0 (tt->host, \"localhost\") != 0)\n    json_object_set_string_member (options, \"address\", tt->host);\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", tt->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (tt->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  closed = FALSE;\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_closed_set_flag), &closed);\n  while (!closed)\n    g_main_context_iteration (NULL, TRUE);\n\n  assert_channel_response (tt->transport, \"444\",\n                           \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \"}}\",\n                           \"Da Da Da\");\n}\n\nstatic gboolean\nhandle_default (CockpitWebServer *server,\n                const gchar *path,\n                GHashTable *headers,\n                CockpitWebResponse *response,\n                gpointer user_data)\n{\n  const gchar *data = \"Da Da Da\";\n  GBytes *bytes;\n\n  bytes = g_bytes_new_static (data, strlen (data));\n  cockpit_web_response_content (response, NULL, bytes, NULL);\n  g_bytes_unref (bytes);\n\n  return TRUE;\n}\n\nstatic void\ntest_http_stream2 (TestGeneral *tt,\n                   gconstpointer unused)\n{\n  CockpitChannel *channel;\n  GBytes *bytes;\n  JsonObject *options;\n  const gchar *control;\n  JsonObject *object;\n  gboolean closed;\n  GBytes *data;\n  guint count;\n\n  g_signal_connect (tt->web_server, \"handle-resource::/\", G_CALLBACK (handle_default), tt);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", tt->port);\n  json_object_set_string_member (options, \"payload\", \"http-stream2\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/\");\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", tt->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (tt->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  closed = FALSE;\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_closed_set_flag), &closed);\n  while (!closed)\n    g_main_context_iteration (NULL, TRUE);\n\n  object = mock_transport_pop_control (tt->transport);\n  cockpit_assert_json_eq (object, \"{\\\"command\\\":\\\"ready\\\",\\\"channel\\\":\\\"444\\\"}\");\n  object = mock_transport_pop_control (tt->transport);\n  cockpit_assert_json_eq (object, \"{\\\"command\\\":\\\"response\\\",\\\"channel\\\":\\\"444\\\",\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \"}}\");\n\n  data = mock_transport_combine_output (tt->transport, \"444\", &count);\n  cockpit_assert_bytes_eq (data, \"Da Da Da\", -1);\n  g_assert_cmpuint (count, ==, 1);\n  g_bytes_unref (data);\n}\n\nstatic void\ntest_cannot_connect (TestGeneral *tt,\n                     gconstpointer unused)\n{\n  CockpitChannel *channel;\n  GBytes *bytes;\n  JsonObject *options;\n  const gchar *control;\n  JsonObject *object;\n  gboolean closed;\n\n  cockpit_expect_log (\"cockpit-bridge\", G_LOG_LEVEL_MESSAGE, \"*couldn't connect*\");\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", 5555);\n  json_object_set_string_member (options, \"payload\", \"http-stream2\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/\");\n  json_object_set_string_member (options, \"address\", \"0.0.0.0\");\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", tt->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (tt->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  closed = FALSE;\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_closed_set_flag), &closed);\n  while (!closed)\n    g_main_context_iteration (NULL, TRUE);\n\n  object = mock_transport_pop_control (tt->transport);\n  cockpit_assert_json_eq (object, \"{\\\"command\\\":\\\"close\\\",\\\"channel\\\":\\\"444\\\",\\\"problem\\\":\\\"not-found\\\"}\");\n}\n\n/* -----------------------------------------------------------------------------\n * Test\n */\n\ntypedef struct {\n  gchar *problem;\n  gboolean done;\n} TestResult;\n\n/*\n * Yes this is a magic number. It's the lowest number that would\n * trigger a bug where chunked data would be rejected due to an incomplete read.\n */\nconst gint MAGIC_NUMBER = 3068;\n\nstatic gboolean\nhandle_chunked (CockpitWebServer *server,\n                const gchar *path,\n                GHashTable *headers,\n                CockpitWebResponse *response,\n                gpointer user_data)\n{\n  GBytes *bytes;\n  GHashTable *h = g_hash_table_new (g_str_hash,  g_str_equal);\n\n  cockpit_web_response_headers_full (response, 200,\n                                     \"OK\", -1, h);\n  bytes = g_bytes_new_take (g_strdup_printf (\"%0*d\",\n                                             MAGIC_NUMBER, 0),\n                            MAGIC_NUMBER);\n  cockpit_web_response_queue (response, bytes);\n  cockpit_web_response_complete (response);\n\n  g_bytes_unref (bytes);\n  g_hash_table_unref (h);\n  return TRUE;\n}\n\nstatic void\non_channel_close (CockpitChannel *channel,\n                  const gchar *problem,\n                  gpointer user_data)\n{\n  TestResult *tr = user_data;\n  g_assert (tr->done == FALSE);\n  tr->done = TRUE;\n  tr->problem = g_strdup (problem);\n}\n\nstatic void\non_transport_closed (CockpitTransport *transport,\n                     const gchar *problem,\n                     gpointer user_data)\n{\n  g_assert_not_reached ();\n}\n\nstatic void\ntest_http_chunked (void)\n{\n  MockTransport *transport = NULL;\n  CockpitChannel *channel = NULL;\n  CockpitWebServer *web_server = NULL;\n  JsonObject *options = NULL;\n  JsonObject *headers = NULL;\n  TestResult *tr = g_slice_new (TestResult);\n\n  GBytes *bytes = NULL;\n\n  const gchar *control;\n  guint port;\n\n  web_server = cockpit_web_server_new (NULL, 0, NULL, COCKPIT_WEB_SERVER_NONE, NULL, NULL);\n  g_assert (web_server);\n  port = cockpit_web_server_get_port (web_server);\n  g_signal_connect (web_server, \"handle-resource::/\",\n                    G_CALLBACK (handle_chunked), NULL);\n\n  cockpit_web_server_start (web_server);\n\n  transport = mock_transport_new ();\n  g_signal_connect (transport, \"closed\", G_CALLBACK (on_transport_closed), NULL);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/\");\n\n  headers = json_object_new ();\n  json_object_set_string_member (headers, \"Pragma\", \"no-cache\");\n  json_object_set_object_member (options, \"headers\", headers);\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                              \"transport\", transport,\n                              \"id\", \"444\",\n                              \"options\", options,\n                              NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  tr->done = FALSE;\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_channel_close), tr);\n\n  while (tr->done == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tr->problem, ==, NULL);\n\n\n\n  g_autofree gchar *expected_body = g_strdup_printf (\"%0*d\", MAGIC_NUMBER, 0);\n\n  assert_channel_response (transport, \"444\",\n                           \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \"}}\",\n                           expected_body);\n\n  g_object_unref (transport);\n  g_object_add_weak_pointer (G_OBJECT (channel), (gpointer *)&channel);\n  g_object_unref (channel);\n  g_assert (channel == NULL);\n  g_clear_object (&web_server);\n\n  g_free (tr->problem);\n  g_slice_free (TestResult, tr);\n}\n\nstatic void\ntest_parse_keep_alive (void)\n{\n  const gchar *version;\n  GHashTable *headers;\n  gboolean keep_alive;\n\n  headers = g_hash_table_new (g_str_hash, g_str_equal);\n\n  version = \"HTTP/1.1\";\n  g_hash_table_insert (headers, \"Connection\", \"keep-alive\");\n\n  keep_alive = cockpit_http_stream_parse_keep_alive (version, headers);\n  g_assert (keep_alive == TRUE);\n\n  version = \"HTTP/1.0\";\n  keep_alive = cockpit_http_stream_parse_keep_alive (version, headers);\n  g_assert (keep_alive == TRUE);\n\n\n  g_hash_table_remove (headers, \"Connection\");\n\n  keep_alive = cockpit_http_stream_parse_keep_alive (version, headers);\n  g_assert (keep_alive == FALSE);\n\n  version = \"HTTP/1.1\";\n  keep_alive = cockpit_http_stream_parse_keep_alive (version, headers);\n  g_assert (keep_alive == TRUE);\n\n  g_hash_table_destroy (headers);\n}\n\ntypedef struct {\n  GTlsCertificate *certificate;\n  CockpitWebServer *web_server;\n  guint port;\n  MockTransport *transport;\n  GTlsCertificate *peer;\n} TestTls;\n\nstatic gboolean\nhandle_test (CockpitWebServer *server,\n             const gchar *path,\n             GHashTable *headers,\n             CockpitWebResponse *response,\n             gpointer user_data)\n{\n  const gchar *data = \"Oh Marmalaade!\";\n  GTlsConnection *connection;\n  TestTls *test = user_data;\n  GBytes *bytes;\n\n  bytes = g_bytes_new_static (data, strlen (data));\n  cockpit_web_response_content (response, NULL, bytes, NULL);\n  g_bytes_unref (bytes);\n\n  connection = G_TLS_CONNECTION (cockpit_web_response_get_stream (response));\n\n  g_clear_object (&test->peer);\n  test->peer = g_tls_connection_get_peer_certificate (connection);\n  if (test->peer)\n    g_object_ref (test->peer);\n\n  return TRUE;\n}\n\nstatic void\nsetup_tls (TestTls *test,\n           gconstpointer data)\n{\n  GError *error = NULL;\n\n  /* don't require system SSL cert database in build environments */\n  cockpit_expect_possible_log (\"GLib-Net\", G_LOG_LEVEL_WARNING, \"couldn't load TLS file database: * No such file or directory\");\n\n  test->certificate = g_tls_certificate_new_from_files (SRCDIR \"/src/bridge/mock-server.crt\",\n                                                        SRCDIR \"/src/bridge/mock-server.key\", &error);\n  g_assert_no_error (error);\n\n  test->web_server = cockpit_web_server_new (NULL, 0, test->certificate, COCKPIT_WEB_SERVER_NONE, NULL, &error);\n  g_assert_no_error (error);\n\n  test->port = cockpit_web_server_get_port (test->web_server);\n  g_signal_connect (test->web_server, \"handle-resource::/test\", G_CALLBACK (handle_test), test);\n\n  cockpit_web_server_start (test->web_server);\n\n  test->transport = mock_transport_new ();\n  g_signal_connect (test->transport, \"closed\", G_CALLBACK (on_transport_closed), NULL);\n}\n\nstatic void\nteardown_tls (TestTls *test,\n              gconstpointer data)\n{\n  g_object_unref (test->certificate);\n  g_object_unref (test->web_server);\n  g_object_unref (test->transport);\n  g_clear_object (&test->peer);\n  cockpit_webserver_want_certificate = FALSE;\n}\n\nstatic void\ntest_tls_basic (TestTls *test,\n                gconstpointer unused)\n{\n  gboolean closed = FALSE;\n  CockpitChannel *channel;\n  JsonObject *options;\n  const gchar *control;\n  GBytes *bytes;\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", test->port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/test\");\n  json_object_set_object_member (options, \"tls\", json_object_new ());\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", test->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (test->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_closed_set_flag), &closed);\n\n  while (closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  assert_channel_response (test->transport, \"444\",\n                           \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \"}}\",\n                           \"Oh Marmalaade!\");\n\n  g_object_add_weak_pointer (G_OBJECT (channel), (gpointer *)&channel);\n  g_object_unref (channel);\n  g_assert (channel == NULL);\n}\n\nstatic const gchar fixture_tls_certificate_data[] =\n\"{ \\\"certificate\\\": { \\\"data\\\": \"\n\"\\\"-----BEGIN CERTIFICATE-----\\n\"\n\"MIICxzCCAa+gAwIBAgIJANDrBNw3XYJ0MA0GCSqGSIb3DQEBCwUAMBQxEjAQBgNV\\n\"\n\"BAMMCWxvY2FsaG9zdDAgFw0xNTAzMjUxMDMzMzRaGA8yMTE1MDMwMTEwMzMzNFow\\n\"\n\"FDESMBAGA1UEAwwJbG9jYWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\\n\"\n\"CgKCAQEA8l1q01B5N/biaFDazUtuPuOrFsLOC67LX1iiE62guchEf9FyEagglGzt\\n\"\n\"XOSCpY/qX0HWmIkE3Pqotb8lPQ0mUHleYCvzY85cFmj4mu+rDIPxK/lw37Xu00iP\\n\"\n\"/rbcCA6K6dgMjp0TJzZvMnU2PywtFqDpw6ZchcMi517keMfLwscUC/7Y80lP0PGA\\n\"\n\"1wTDaYoxuMlUhqTTfdLoBZ73eA9YzgqBeZ9ePxoUFk9AtJtlOlR60mGbEOweDUfc\\n\"\n\"l1biKtarDW5SJYbVTFjWdPsCV6czZndfVKAAkDd+bsbFMcEiq/doHU092Yy3sZ9g\\n\"\n\"hnOBw5sCq8iTXQ9cmejxUrsu/SvL3QIDAQABoxowGDAJBgNVHRMEAjAAMAsGA1Ud\\n\"\n\"DwQEAwIF4DANBgkqhkiG9w0BAQsFAAOCAQEAalykXV+z1tQOv1ZRvJmppjEIYTa3\\n\"\n\"pFehy97BiNGERTQJQDSzOgptIaCJb1vE34KNL349QEO4F8XTPWhwsCAXNTBN4yhm\\n\"\n\"NJ6qbYkz0HbBmdM4k0MgbB9VG00Hy+TmwEt0zVryICZY4IomKmS1No0Lai5hOqdz\\n\"\n\"afUMVIIYjVB1WYIsIaXXug7Mik/O+6K5hIbqm9HkwRwfoVaOLNG9EPUM14vFnN5p\\n\"\n\"EyHSBByk0mOU8EUK/qsAnbTwABEKsMxCopmvPTguGHTwllEvxPgt5BcYMU9oXlvc\\n\"\n\"cSvnU4a6M2qxQn3LUqxENh9QaQ8vV4l/avZBi1cFKVs1rza36eOGxrJxQw==\\n\"\n\"-----END CERTIFICATE-----\\\"\"\n\"}, \\\"key\\\": { \\\"data\\\": \"\n\"\\\"-----BEGIN PRIVATE KEY-----\\n\"\n\"MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDyXWrTUHk39uJo\\n\"\n\"UNrNS24+46sWws4LrstfWKITraC5yER/0XIRqCCUbO1c5IKlj+pfQdaYiQTc+qi1\\n\"\n\"vyU9DSZQeV5gK/NjzlwWaPia76sMg/Er+XDfte7TSI/+ttwIDorp2AyOnRMnNm8y\\n\"\n\"dTY/LC0WoOnDplyFwyLnXuR4x8vCxxQL/tjzSU/Q8YDXBMNpijG4yVSGpNN90ugF\\n\"\n\"nvd4D1jOCoF5n14/GhQWT0C0m2U6VHrSYZsQ7B4NR9yXVuIq1qsNblIlhtVMWNZ0\\n\"\n\"+wJXpzNmd19UoACQN35uxsUxwSKr92gdTT3ZjLexn2CGc4HDmwKryJNdD1yZ6PFS\\n\"\n\"uy79K8vdAgMBAAECggEAILEJH8fTEgFzOK7vVJHAJSuAgGl2cYz6Uboa4pyg+W5S\\n\"\n\"DwupX0hWXK70tXr9RGfNLVwsHhcdWNFWwG0wELQdXu2AFWjYQ7YqJbuzDPMXF3EU\\n\"\n\"ruHOn95igI1hHvJ7a3rKshA6YWI+myN0jFHTJ2JGEq9R2Nov0LspkhvypXgNvA/r\\n\"\n\"JfFZ9IsPJZDWCnGXkPLlW2X1XEXw2BPs8ib+ZkbzGNiLsy/i4M/oA+g6lz4LU/ll\\n\"\n\"J6cLhwPrBu02+PJt7MaYaNk5zqhyJs0AMjeBlNnXFIWAlTrIe/h8z/gL8ABrYWAA\\n\"\n\"1kgZ11GO8bNAEfLOIUrA1/vq9aK00WDwFLXWJdVE4QKBgQD+R/J+AbYSImeoAj/3\\n\"\n\"hfsFkaUNLyw1ZEO4LG2id0dnve1paL6Y/uXKKqxq0jiyMLT243Vi+1fzth7RNXOl\\n\"\n\"ui0nnVWO7x68FsYcdIM7w+tryh2Y+UhCfwNCakM0GTohcXqFUEzHcwuOv8hAfRQ5\\n\"\n\"jPBCwJdUHpIimVOo5/WRbQGW+wKBgQD0ANkof+jagdNqOkCvFnTPiFlPYrpDzeU5\\n\"\n\"ZxhLlVxnr6G2MPoUO0IqTWVA7uCn29i0yUUXAtRHrkNI1EtKXRIUe2bChVegTBHx\\n\"\n\"26PqXEOonSUJdpUzyzXVX2vSqICm0tTbqyZ0GbjP4y5qQOQHdTGFsHDfSTa5//P+\\n\"\n\"0BLpci4RBwKBgQDBR8DrxLM3b41o6GTk6aNXpVBXCC9LWi4bVTH0l0PgeD54rBSM\\n\"\n\"SNwz4mHyRF6yG1HChDybAz/kUN912HJSW4StIuuA3QN4prrpsCp8iDxvT09WEs25\\n\"\n\"NcAtgIYamL5V42Lk6Jej1y/GzsIROsHfyOBrbObaGu6re+5aag5//uKBdwKBgQDp\\n\"\n\"i4ZPBV7TBkBdBLS04UGdAly5Zz3xeDlW4B6Y+bUgaTLXN7mlc7K42qt3oyzUfdDF\\n\"\n\"+X9vrv2QPnOYWdpWqw6LHDIXLZnZi/YBEMGrp/P6h67Th/T3RiGYwWRqlW3OPy4N\\n\"\n\"s5tytMv37vKWMNYRbVKhK2hdz63aCep4kqAHYYpGMQKBgF83LTyRFwGFos/wDrgY\\n\"\n\"eieLiipmdXGvlrBq6SBzKglIYwNRSGiWkXAuHRzD/2S546ioQKZr7AKuijKGdLMz\\n\"\n\"ABVl/bqqqRXSDbvf+XEdU2rJpxhYWxlsJZMFBFIwuxR2jRqmCgbCvoZQcbIr1ZLr\\n\"\n\"02eC2pQ5eio2+CKqBfqxbnwk\\n\"\n\"-----END PRIVATE KEY-----\\\"\"\n\" } }\";\n\nstatic const gchar fixture_tls_certificate_file[] =\n\"{ \\\"certificate\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.crt\\\" },\"\n\"\\\"key\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.key\\\" } }\";\n\nstatic const gchar fixture_tls_certificate_data_file[] =\n\"{ \\\"certificate\\\": { \\\"data\\\": \"\n\"\\\"-----BEGIN CERTIFICATE-----\\n\"\n\"MIICxzCCAa+gAwIBAgIJANDrBNw3XYJ0MA0GCSqGSIb3DQEBCwUAMBQxEjAQBgNV\\n\"\n\"BAMMCWxvY2FsaG9zdDAgFw0xNTAzMjUxMDMzMzRaGA8yMTE1MDMwMTEwMzMzNFow\\n\"\n\"FDESMBAGA1UEAwwJbG9jYWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\\n\"\n\"CgKCAQEA8l1q01B5N/biaFDazUtuPuOrFsLOC67LX1iiE62guchEf9FyEagglGzt\\n\"\n\"XOSCpY/qX0HWmIkE3Pqotb8lPQ0mUHleYCvzY85cFmj4mu+rDIPxK/lw37Xu00iP\\n\"\n\"/rbcCA6K6dgMjp0TJzZvMnU2PywtFqDpw6ZchcMi517keMfLwscUC/7Y80lP0PGA\\n\"\n\"1wTDaYoxuMlUhqTTfdLoBZ73eA9YzgqBeZ9ePxoUFk9AtJtlOlR60mGbEOweDUfc\\n\"\n\"l1biKtarDW5SJYbVTFjWdPsCV6czZndfVKAAkDd+bsbFMcEiq/doHU092Yy3sZ9g\\n\"\n\"hnOBw5sCq8iTXQ9cmejxUrsu/SvL3QIDAQABoxowGDAJBgNVHRMEAjAAMAsGA1Ud\\n\"\n\"DwQEAwIF4DANBgkqhkiG9w0BAQsFAAOCAQEAalykXV+z1tQOv1ZRvJmppjEIYTa3\\n\"\n\"pFehy97BiNGERTQJQDSzOgptIaCJb1vE34KNL349QEO4F8XTPWhwsCAXNTBN4yhm\\n\"\n\"NJ6qbYkz0HbBmdM4k0MgbB9VG00Hy+TmwEt0zVryICZY4IomKmS1No0Lai5hOqdz\\n\"\n\"afUMVIIYjVB1WYIsIaXXug7Mik/O+6K5hIbqm9HkwRwfoVaOLNG9EPUM14vFnN5p\\n\"\n\"EyHSBByk0mOU8EUK/qsAnbTwABEKsMxCopmvPTguGHTwllEvxPgt5BcYMU9oXlvc\\n\"\n\"cSvnU4a6M2qxQn3LUqxENh9QaQ8vV4l/avZBi1cFKVs1rza36eOGxrJxQw==\\n\"\n\"-----END CERTIFICATE-----\\\"\"\n\"}, \\\"key\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.key\\\"\"\n\"} }\";\n\nstatic const gchar fixture_tls_certificate_file_data[] =\n\"{ \\\"certificate\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.crt\\\"\"\n\"}, \\\"key\\\": { \\\"data\\\": \"\n\"\\\"-----BEGIN PRIVATE KEY-----\\n\"\n\"MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDyXWrTUHk39uJo\\n\"\n\"UNrNS24+46sWws4LrstfWKITraC5yER/0XIRqCCUbO1c5IKlj+pfQdaYiQTc+qi1\\n\"\n\"vyU9DSZQeV5gK/NjzlwWaPia76sMg/Er+XDfte7TSI/+ttwIDorp2AyOnRMnNm8y\\n\"\n\"dTY/LC0WoOnDplyFwyLnXuR4x8vCxxQL/tjzSU/Q8YDXBMNpijG4yVSGpNN90ugF\\n\"\n\"nvd4D1jOCoF5n14/GhQWT0C0m2U6VHrSYZsQ7B4NR9yXVuIq1qsNblIlhtVMWNZ0\\n\"\n\"+wJXpzNmd19UoACQN35uxsUxwSKr92gdTT3ZjLexn2CGc4HDmwKryJNdD1yZ6PFS\\n\"\n\"uy79K8vdAgMBAAECggEAILEJH8fTEgFzOK7vVJHAJSuAgGl2cYz6Uboa4pyg+W5S\\n\"\n\"DwupX0hWXK70tXr9RGfNLVwsHhcdWNFWwG0wELQdXu2AFWjYQ7YqJbuzDPMXF3EU\\n\"\n\"ruHOn95igI1hHvJ7a3rKshA6YWI+myN0jFHTJ2JGEq9R2Nov0LspkhvypXgNvA/r\\n\"\n\"JfFZ9IsPJZDWCnGXkPLlW2X1XEXw2BPs8ib+ZkbzGNiLsy/i4M/oA+g6lz4LU/ll\\n\"\n\"J6cLhwPrBu02+PJt7MaYaNk5zqhyJs0AMjeBlNnXFIWAlTrIe/h8z/gL8ABrYWAA\\n\"\n\"1kgZ11GO8bNAEfLOIUrA1/vq9aK00WDwFLXWJdVE4QKBgQD+R/J+AbYSImeoAj/3\\n\"\n\"hfsFkaUNLyw1ZEO4LG2id0dnve1paL6Y/uXKKqxq0jiyMLT243Vi+1fzth7RNXOl\\n\"\n\"ui0nnVWO7x68FsYcdIM7w+tryh2Y+UhCfwNCakM0GTohcXqFUEzHcwuOv8hAfRQ5\\n\"\n\"jPBCwJdUHpIimVOo5/WRbQGW+wKBgQD0ANkof+jagdNqOkCvFnTPiFlPYrpDzeU5\\n\"\n\"ZxhLlVxnr6G2MPoUO0IqTWVA7uCn29i0yUUXAtRHrkNI1EtKXRIUe2bChVegTBHx\\n\"\n\"26PqXEOonSUJdpUzyzXVX2vSqICm0tTbqyZ0GbjP4y5qQOQHdTGFsHDfSTa5//P+\\n\"\n\"0BLpci4RBwKBgQDBR8DrxLM3b41o6GTk6aNXpVBXCC9LWi4bVTH0l0PgeD54rBSM\\n\"\n\"SNwz4mHyRF6yG1HChDybAz/kUN912HJSW4StIuuA3QN4prrpsCp8iDxvT09WEs25\\n\"\n\"NcAtgIYamL5V42Lk6Jej1y/GzsIROsHfyOBrbObaGu6re+5aag5//uKBdwKBgQDp\\n\"\n\"i4ZPBV7TBkBdBLS04UGdAly5Zz3xeDlW4B6Y+bUgaTLXN7mlc7K42qt3oyzUfdDF\\n\"\n\"+X9vrv2QPnOYWdpWqw6LHDIXLZnZi/YBEMGrp/P6h67Th/T3RiGYwWRqlW3OPy4N\\n\"\n\"s5tytMv37vKWMNYRbVKhK2hdz63aCep4kqAHYYpGMQKBgF83LTyRFwGFos/wDrgY\\n\"\n\"eieLiipmdXGvlrBq6SBzKglIYwNRSGiWkXAuHRzD/2S546ioQKZr7AKuijKGdLMz\\n\"\n\"ABVl/bqqqRXSDbvf+XEdU2rJpxhYWxlsJZMFBFIwuxR2jRqmCgbCvoZQcbIr1ZLr\\n\"\n\"02eC2pQ5eio2+CKqBfqxbnwk\\n\"\n\"-----END PRIVATE KEY-----\\\"\"\n\" } }\";\n\nstatic void\ntest_tls_certificate (TestTls *test,\n                      gconstpointer json)\n{\n  gboolean closed = FALSE;\n  CockpitChannel *channel;\n  JsonObject *options;\n  JsonObject *tls;\n  GError *error = NULL;\n  GTlsCertificate *cert;\n  const gchar *control;\n  GBytes *bytes;\n\n  /* tell server to request client cert */\n  cockpit_webserver_want_certificate = TRUE;\n\n  /* this happens twice, so once more in addition to the ignore in setup_tls */\n  cockpit_expect_possible_log (\"GLib-Net\", G_LOG_LEVEL_WARNING, \"couldn't load TLS file database: * No such file or directory\");\n\n  tls = cockpit_json_parse_object (json, -1, &error);\n  g_assert_no_error (error);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", test->port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/test\");\n  json_object_set_object_member (options, \"tls\", tls);\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", test->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (test->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_closed_set_flag), &closed);\n\n  while (closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  assert_channel_response (test->transport, \"444\",\n                           \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \"}}\",\n                           \"Oh Marmalaade!\");\n\n  g_assert (test->peer != NULL);\n\n  /* Should have used our expected certificate */\n  cert = g_tls_certificate_new_from_files (SRCDIR \"/src/bridge/mock-client.crt\",\n                                           SRCDIR \"/src/bridge/mock-client.key\", &error);\n  g_assert_no_error (error);\n\n  g_assert (g_tls_certificate_is_same (test->peer, cert));\n  g_object_unref (cert);\n\n  g_object_add_weak_pointer (G_OBJECT (channel), (gpointer *)&channel);\n  g_object_unref (channel);\n  g_assert (channel == NULL);\n}\n\nstatic const gchar fixture_tls_authority_good[] =\n  \"{ \\\"authority\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-server.crt\\\" } }\";\n\nstatic void\ntest_tls_authority_good (TestTls *test,\n                         gconstpointer json)\n{\n  gboolean closed = FALSE;\n  CockpitChannel *channel;\n  JsonObject *options;\n  JsonObject *tls;\n  GError *error = NULL;\n  const gchar *control;\n  GBytes *bytes;\n\n  tls = cockpit_json_parse_object (json, -1, &error);\n  g_assert_no_error (error);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", test->port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/test\");\n  json_object_set_object_member (options, \"tls\", tls);\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", test->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (test->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_closed_set_flag), &closed);\n\n  while (closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  assert_channel_response (test->transport, \"444\",\n                           \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \"}}\",\n                           \"Oh Marmalaade!\");\n\n  g_object_add_weak_pointer (G_OBJECT (channel), (gpointer *)&channel);\n  g_object_unref (channel);\n  g_assert (channel == NULL);\n}\n\nstatic const gchar fixture_tls_authority_bad[] =\n  \"{ \\\"certificate\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.crt\\\" },\"\n  \"  \\\"key\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.key\\\" }, \"\n  \"  \\\"authority\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.crt\\\" } }\";\n\nstatic void\ntest_tls_authority_bad (TestTls *test,\n                         gconstpointer json)\n{\n  CockpitChannel *channel;\n  JsonObject *options;\n  JsonObject *tls;\n  GError *error = NULL;\n  const gchar *control;\n  GBytes *bytes;\n  JsonObject *resp;\n\n  tls = cockpit_json_parse_object (json, -1, &error);\n  g_assert_no_error (error);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", test->port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/test\");\n  json_object_set_object_member (options, \"tls\", tls);\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", test->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  cockpit_expect_log (\"cockpit-bridge\", G_LOG_LEVEL_MESSAGE,\n                      \"*Unacceptable TLS certificate\");\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (test->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  while (mock_transport_count_sent (test->transport) < 1)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = mock_transport_pop_control (test->transport);\n  cockpit_assert_json_eq (resp, \"{\\\"command\\\":\\\"close\\\",\\\"channel\\\":\\\"444\\\",\\\"problem\\\":\\\"unknown-hostkey\\\"}\");\n\n  g_object_add_weak_pointer (G_OBJECT (channel), (gpointer *)&channel);\n  g_object_unref (channel);\n  g_assert (channel == NULL);\n}\n\nint\nmain (int argc,\n      char *argv[])\n{\n  char *ip = non_local_ip ();\n  int result;\n\n  cockpit_test_init (&argc, &argv);\n\n  g_test_add (\"/http-stream/host-header\", TestGeneral, \"localhost\",\n              setup_general, test_host_header, teardown_general);\n  g_test_add (\"/http-stream/address-host-header\", TestGeneral, ip,\n              setup_general, test_host_header, teardown_general);\n\n  g_test_add (\"/http-stream/http-stream2\", TestGeneral, NULL,\n              setup_general, test_http_stream2, teardown_general);\n  g_test_add (\"/http-stream/cannot-connect\", TestGeneral, NULL,\n              setup_general, test_cannot_connect, teardown_general);\n\n  g_test_add_func  (\"/http-stream/parse_keepalive\", test_parse_keep_alive);\n  g_test_add_func  (\"/http-stream/http_chunked\", test_http_chunked);\n\n  g_test_add (\"/http-stream/tls/basic\", TestTls, NULL,\n              setup_tls, test_tls_basic, teardown_tls);\n  g_test_add (\"/http-stream/tls/certificate-data\", TestTls, fixture_tls_certificate_data,\n              setup_tls, test_tls_certificate, teardown_tls);\n  g_test_add (\"/http-stream/tls/certificate-file\", TestTls, fixture_tls_certificate_file,\n              setup_tls, test_tls_certificate, teardown_tls);\n  g_test_add (\"/http-stream/tls/certificate-data-file\", TestTls, fixture_tls_certificate_data_file,\n              setup_tls, test_tls_certificate, teardown_tls);\n  g_test_add (\"/http-stream/tls/certificate-file-data\", TestTls, fixture_tls_certificate_file_data,\n              setup_tls, test_tls_certificate, teardown_tls);\n  g_test_add (\"/http-stream/tls/authority-good\", TestTls, fixture_tls_authority_good,\n              setup_tls, test_tls_authority_good, teardown_tls);\n  g_test_add (\"/http-stream/tls/authority-bad\", TestTls, fixture_tls_authority_bad,\n              setup_tls, test_tls_authority_bad, teardown_tls);\n\n  result = g_test_run ();\n  g_free (ip);\n  return result;\n}\n", "/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2014 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdio.h>\n\n#include \"config.h\"\n\n#include \"cockpithttpstream.h\"\n#include \"cockpitpackages.h\"\n\n#include \"common/cockpitchannel.h\"\n#include \"common/cockpitjson.h\"\n#include \"common/cockpitsystem.h\"\n#include \"common/cockpittest.h\"\n#include \"common/mock-transport.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n\n/*\n * To recalculate the checksums found in this file, do something like:\n * $ XDG_DATA_DIRS=$PWD/src/bridge/mock-resource/glob/ XDG_DATA_HOME=/nonexistent ./cockpit-bridge --packages\n */\n#define CHECKSUM_GLOB           \"f5d1bfe84c378dee517cea3e0f0380ad2c9201f6be021fbae877a89d4cb51859\"\n#define CHECKSUM_GZIP           \"13adcb9aae2f22850ec7fa43229428c6bba4450bd6ef4fd06eeea27b41dbf911\"\n#define CHECKSUM_BADPACKAGE     \"86ae6170eb6245c5c80dbcbcc0ba12beddee2e1d807cfdb705440e944b177fbc\"\n#define CHECKSUM_RELOAD_OLD     \"53264dd51401b6f6de0ba63180397919697155653855848dee0f6f71c6e93f40\"\n#define CHECKSUM_RELOAD_NEW     \"eae62ca12c4a92b4ae7f6b0d2f41cb20be0005a6fc62466fccda1ebe0532cc23\"\n#define CHECKSUM_RELOAD_UPDATED \"0d1c0b7c6133cc7c3956197fd8a76bef68b158bd78beac75cfa80b75c36aa827\"\n#define CHECKSUM_CSP            \"80921dc3cde9ff9f2acd2a5851f9b2a3b25ea7b4577128461d9e32fbdd671e16\"\n\n/* JSON dict snippet for headers that are present in every request */\n#define STATIC_HEADERS \"\\\"X-DNS-Prefetch-Control\\\":\\\"off\\\",\\\"Referrer-Policy\\\":\\\"no-referrer\\\",\\\"X-Content-Type-Options\\\":\\\"nosniff\\\",\\\"Cross-Origin-Resource-Policy\\\": \\\"same-origin\\\"\"\n#define STATIC_HEADERS_CACHECONTROL STATIC_HEADERS \",\\\"Cache-Control\\\":\\\"no-cache, no-store\\\"\"\n\nextern const gchar **cockpit_bridge_data_dirs;\nextern const gchar *cockpit_bridge_local_address;\nextern gint cockpit_bridge_packages_port;\n\ntypedef struct {\n  CockpitPackages *packages;\n  MockTransport *transport;\n  CockpitChannel *channel;\n  gchar *problem;\n  gboolean closed;\n} TestCase;\n\ntypedef struct {\n  const gchar *datadirs[8];\n  const gchar *path;\n  const gchar *accept[8];\n  const gchar *expect;\n  const gchar *headers[8];\n  gboolean cacheable;\n  gboolean binary;\n  gboolean no_packages_init;\n} Fixture;\n\nstatic void\non_channel_close (CockpitChannel *channel,\n                  const gchar *problem,\n                  gpointer user_data)\n{\n  TestCase *tc = user_data;\n  g_assert (tc->closed == FALSE);\n  tc->closed = TRUE;\n  tc->problem = g_strdup (problem);\n}\n\nstatic void\non_transport_closed (CockpitTransport *transport,\n                     const gchar *problem,\n                     gpointer user_data)\n{\n  g_assert_not_reached ();\n}\n\nstatic void\nsetup (TestCase *tc,\n       gconstpointer data)\n{\n  const Fixture *fixture = data;\n  JsonObject *options;\n  JsonObject *headers;\n  const gchar *control;\n  gchar *accept;\n  GBytes *bytes;\n  guint i;\n\n  g_assert (fixture != NULL);\n\n  if (fixture->expect)\n    cockpit_expect_warning (fixture->expect);\n\n  if (fixture->datadirs[0])\n    {\n      cockpit_bridge_data_dirs = (const gchar **)fixture->datadirs;\n    }\n  else\n    {\n      cockpit_expect_message (\"incompatible: package requires a later version of cockpit: 999.5*\");\n      cockpit_expect_message (\"requires: package has an unknown requirement: unknown\");\n    }\n\n  tc->packages = cockpit_packages_new ();\n\n  tc->transport = mock_transport_new ();\n  g_signal_connect (tc->transport, \"closed\", G_CALLBACK (on_transport_closed), NULL);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", cockpit_bridge_packages_port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", fixture->path);\n\n  if (fixture->binary)\n    json_object_set_string_member (options, \"binary\", \"raw\");\n\n  headers = json_object_new ();\n  if (fixture->accept[0])\n    {\n      accept = g_strjoinv (\", \", (gchar **)fixture->accept);\n      json_object_set_string_member (headers, \"Accept-Language\", accept);\n      g_free (accept);\n    }\n  if (!fixture->cacheable)\n    json_object_set_string_member (headers, \"Pragma\", \"no-cache\");\n  for (i = 0; i < G_N_ELEMENTS (fixture->headers); i += 2)\n    {\n      if (fixture->headers[i])\n        json_object_set_string_member (headers, fixture->headers[i], fixture->headers[i + 1]);\n    }\n  json_object_set_object_member (options, \"headers\", headers);\n\n  tc->channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                              \"transport\", tc->transport,\n                              \"id\", \"444\",\n                              \"options\", options,\n                              NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (tc->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  g_signal_connect (tc->channel, \"closed\", G_CALLBACK (on_channel_close), tc);\n}\n\nstatic void\nteardown (TestCase *tc,\n          gconstpointer data)\n{\n  cockpit_assert_expected ();\n\n  g_object_unref (tc->transport);\n\n  g_object_add_weak_pointer (G_OBJECT (tc->channel), (gpointer *)&tc->channel);\n  g_object_unref (tc->channel);\n  g_assert (tc->channel == NULL);\n\n  g_free (tc->problem);\n\n  cockpit_packages_free (tc->packages);\n\n  cockpit_bridge_data_dirs = NULL;\n}\n\nstatic const Fixture fixture_simple = {\n  .path = \"/test/sub/file.ext\",\n};\n\nstatic void\ntest_simple (TestCase *tc,\n             gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_simple);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"These are the contents of file.ext\\nOh marmalaaade\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_forwarded = {\n  .path = \"/another/test.html\",\n  .headers = { \"X-Forwarded-Proto\", \"https\", \"X-Forwarded-Host\", \"blah:9090\" },\n};\n\nstatic void\ntest_forwarded (TestCase *tc,\n             gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_forwarded);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \",\\\"Content-Security-Policy\\\":\\\"default-src 'self' https://blah:9090; connect-src 'self' https://blah:9090 wss://blah:9090; form-action 'self' https://blah:9090; base-uri 'self' https://blah:9090; object-src 'none'; font-src 'self' https://blah:9090 data:; img-src 'self' https://blah:9090 data:; block-all-mixed-content\\\",\\\"Content-Type\\\":\\\"text/html\\\",\\\"Access-Control-Allow-Origin\\\":\\\"https://blah:9090\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"<html>\\n<head>\\n<title>In home dir</title>\\n</head>\\n<body>In home dir</body>\\n</html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_pig = {\n  .path = \"/another/test.html\",\n  .accept = { \"pig\" },\n  .headers = { \"Host\", \"blah:9090\" },\n};\n\nstatic void\ntest_localized_translated (TestCase *tc,\n                           gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_pig);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \",\\\"Content-Security-Policy\\\":\\\"default-src 'self' http://blah:9090; connect-src 'self' http://blah:9090 ws://blah:9090; form-action 'self' http://blah:9090; base-uri 'self' http://blah:9090; object-src 'none'; font-src 'self' http://blah:9090 data:; img-src 'self' http://blah:9090 data:; block-all-mixed-content\\\",\\\"Content-Type\\\":\\\"text/html\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"<html>\\n<head>\\n<title>Inlay omehay irday</title>\\n</head>\\n<body>Inlay omehay irday</body>\\n</html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_unknown = {\n  .path = \"/another/test.html\",\n  .accept = { \"unknown\" },\n  .headers = { \"Host\", \"blah:9090\" },\n};\n\nstatic void\ntest_localized_unknown (TestCase *tc,\n                        gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_unknown);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \",\\\"Content-Security-Policy\\\":\\\"default-src 'self' http://blah:9090; connect-src 'self' http://blah:9090 ws://blah:9090; form-action 'self' http://blah:9090; base-uri 'self' http://blah:9090; object-src 'none'; font-src 'self' http://blah:9090 data:; img-src 'self' http://blah:9090 data:; block-all-mixed-content\\\",\\\"Content-Type\\\":\\\"text/html\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"<html>\\n<head>\\n<title>In home dir</title>\\n</head>\\n<body>In home dir</body>\\n</html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_prefer_region = {\n  .path = \"/another/test.html\",\n  .accept = { \"pig-pen\" },\n  .headers = { \"Host\", \"blah:9090\" },\n};\n\nstatic void\ntest_localized_prefer_region (TestCase *tc,\n                              gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_prefer_region);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \",\\\"Content-Security-Policy\\\":\\\"default-src 'self' http://blah:9090; connect-src 'self' http://blah:9090 ws://blah:9090; form-action 'self' http://blah:9090; base-uri 'self' http://blah:9090; object-src 'none'; font-src 'self' http://blah:9090 data:; img-src 'self' http://blah:9090 data:; block-all-mixed-content\\\",\\\"Content-Type\\\":\\\"text/html\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"<html>\\n<head>\\n<title>Inway omeha irda</title>\\n</head>\\n<body>Inway omeha irda</body>\\n</html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_fallback = {\n  .path = \"/another/test.html\",\n  .accept = { \"pig-barn\" },\n  .headers = { \"Host\", \"blah:9090\" },\n};\n\nstatic void\ntest_localized_fallback (TestCase *tc,\n                         gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_fallback);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \",\\\"Content-Security-Policy\\\":\\\"default-src 'self' http://blah:9090; connect-src 'self' http://blah:9090 ws://blah:9090; form-action 'self' http://blah:9090; base-uri 'self' http://blah:9090; object-src 'none'; font-src 'self' http://blah:9090 data:; img-src 'self' http://blah:9090 data:; block-all-mixed-content\\\",\\\"Content-Type\\\":\\\"text/html\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"<html>\\n<head>\\n<title>Inlay omehay irday</title>\\n</head>\\n<body>Inlay omehay irday</body>\\n</html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_version = {\n  .path = \"/incompatible/test.html\",\n};\n\nstatic void\ntest_incompatible_version (TestCase *tc,\n                           gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_version);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":503,\\\"reason\\\":\\\"This package requires Cockpit version 999.5 or later\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  cockpit_assert_bytes_eq (data, \"<html><head><title>This package requires Cockpit version 999.5 or later</title></head><body>This package requires Cockpit version 999.5 or later</body></html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_requires = {\n  .path = \"/requires/test.html\",\n};\n\nstatic void\ntest_incompatible_requires (TestCase *tc,\n                            gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_requires);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":503,\\\"reason\\\":\\\"This package is not compatible with this version of Cockpit\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  cockpit_assert_bytes_eq (data, \"<html><head><title>This package is not compatible with this version of Cockpit</title></head><body>This package is not compatible with this version of Cockpit</body></html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_large = {\n  .path = \"/test/sub/COPYING\",\n};\n\nstatic void\ntest_large (TestCase *tc,\n            gconstpointer fixture)\n{\n  GError *error = NULL;\n  gchar *contents;\n  gsize length;\n  gsize prefixlength;\n  GBytes *data;\n  GBytes *sub;\n  guint count;\n  JsonObject *object;\n\n  g_assert (fixture == &fixture_large);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  g_assert (g_file_get_contents (SRCDIR \"/src/bridge/mock-resource/system/cockpit/test/sub/COPYING\",\n                                 &contents, &length, &error));\n  g_assert_no_error (error);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n\n  /* Should not have been sent as one block */\n  g_assert_cmpuint (count, ==, 8);\n  prefixlength = strcspn (g_bytes_get_data (data, NULL), \"}}\") + 2;\n  g_assert_cmpuint (g_bytes_get_size (data), >, prefixlength);\n  object = cockpit_json_parse_object (g_bytes_get_data (data, NULL), prefixlength, &error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \"}}\");\n  sub = g_bytes_new_from_bytes (data, prefixlength, g_bytes_get_size (data) - prefixlength);\n  cockpit_assert_bytes_eq (sub, contents, length);\n\n  json_object_unref (object);\n  g_bytes_unref (sub);\n  g_bytes_unref (data);\n  g_free (contents);\n}\n\nstatic const Fixture fixture_listing = {\n  .path = \"/manifests.json\",\n};\n\nstatic void\ntest_listing (TestCase *tc,\n              gconstpointer fixture)\n{\n  JsonObject *object;\n  GError *error = NULL;\n  GBytes *message;\n  JsonNode *node;\n  guint count;\n\n  g_assert (fixture == &fixture_listing);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  message = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (message, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \",\\\"Content-Type\\\":\\\"application/json\\\"}}\");\n  json_object_unref (object);\n\n  message = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  node = cockpit_json_parse (g_bytes_get_data (message, NULL), g_bytes_get_size (message), &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (json_node_get_object (node),\n                          \"{\"\n                          \" \\\"another\\\": {\"\n                          \"  \\\"name\\\" : \\\"another\\\",\"\n                          \"  \\\"description\\\" : \\\"another\\\",\"\n                          \"  \\\"bridges\\\": [{ \\\"match\\\": {\\\"host\\\": null },\"\n                          \"                   \\\"problem\\\": \\\"not-supported\\\"}]\"\n                          \" },\"\n                          \" \\\"second\\\": {\"\n                          \"  \\\"description\\\": \\\"second dummy description\\\",\"\n                          \"  \\\"priority\\\": 2,\"\n                          \"  \\\"bridges\\\": [{ \\\"match\\\": { \\\"second\\\": null }, \\\"problem\\\": \\\"never-a-second\\\"}]\"\n                          \" },\"\n                          \" \\\"test\\\": {\"\n                          \"   \\\"name\\\": \\\"test\\\",\"\n                          \"   \\\"priority\\\": 15,\"\n                          \"   \\\"description\\\" : \\\"dummy\\\",\"\n                          \"   \\\"bridges\\\": [{ \\\"match\\\": { \\\"blah\\\": \\\"test*\\\" },\"\n                          \"                  \\\"spawn\\\": [\\\"/usr/bin/cat\\\"],\"\n                          \"                  \\\"environ\\\": [\\\"TEST_ENV=test\\\"]},\"\n                          \"                { \\\"match\\\": { \\\"blah\\\": \\\"marmalade*\\\"},\"\n                          \"                  \\\"problem\\\": \\\"bogus-channel\\\"}]\"\n                          \" },\"\n                          \" \\\"incompatible\\\": {\"\n                          \"   \\\"description\\\" : \\\"incompatible package\\\",\"\n                          \"   \\\"requires\\\" : { \\\"cockpit\\\" : \\\"999.5\\\" }\"\n                          \" },\"\n                          \" \\\"requires\\\": {\"\n                          \"   \\\"description\\\" : \\\"requires package\\\",\"\n                          \"   \\\"requires\\\" : { \\\"unknown\\\" : \\\"requirement\\\" }\"\n                          \" }\"\n                          \"}\");\n  json_node_free (node);\n  g_bytes_unref (message);\n}\n\nstatic const Fixture fixture_not_found = {\n  .path = \"/test/sub/not-found\",\n};\n\nstatic void\ntest_not_found (TestCase *tc,\n                gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n\n\n  g_assert (fixture == &fixture_not_found);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":404,\\\"reason\\\":\\\"Not Found\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n}\n\nstatic const Fixture fixture_unknown_package = {\n  .path = \"/unknownpackage/sub/not-found\",\n};\n\nstatic void\ntest_unknown_package (TestCase *tc,\n                      gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n\n  g_assert (fixture == &fixture_unknown_package);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":404,\\\"reason\\\":\\\"Not Found\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n}\n\nstatic const Fixture fixture_no_path = {\n  .path = \"/test\"\n};\n\nstatic void\ntest_no_path (TestCase *tc,\n              gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n\n  g_assert (fixture == &fixture_no_path);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":404,\\\"reason\\\":\\\"Not Found\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n}\n\nstatic const Fixture fixture_bad_path = {\n  .path = \"/../test/sub/file.ext\"\n};\n\nstatic void\ntest_bad_path (TestCase *tc,\n               gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n\n  g_assert (fixture == &fixture_bad_path);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":404,\\\"reason\\\":\\\"Not Found\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n}\n\nstatic const Fixture fixture_no_package = {\n  .path = \"/test\"\n};\n\nstatic void\ntest_no_package (TestCase *tc,\n                 gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n\n  g_assert (fixture == &fixture_no_package);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":404,\\\"reason\\\":\\\"Not Found\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n}\n\nstatic const Fixture fixture_bad_package = {\n  .path = \"/%%package/test\"\n};\n\nstatic void\ntest_bad_package (TestCase *tc,\n                  gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n\n  g_assert (fixture == &fixture_bad_package);\n\n  cockpit_expect_message (\"invalid 'package' name: %%package\");\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":404,\\\"reason\\\":\\\"Not Found\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n}\n\nstatic void\ntest_bad_receive (TestCase *tc,\n                  gconstpointer fixture)\n{\n  GBytes *bad;\n\n  cockpit_expect_log (\"cockpit-protocol\", G_LOG_LEVEL_MESSAGE, \"444: channel received message after done\");\n\n  /* A resource2 channel should never have payload sent to it */\n  bad = g_bytes_new_static (\"bad\", 3);\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (tc->transport), \"444\", bad);\n  g_bytes_unref (bad);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_assert_cmpstr (tc->problem, ==, \"protocol-error\");\n}\n\nstatic const Fixture fixture_list_bad_name = {\n    .datadirs = { SRCDIR \"/src/bridge/mock-resource/bad-package\", NULL },\n    .expect = \"*package*invalid*name*\",\n    .path = \"/manifests.json\"\n};\n\nstatic void\ntest_list_bad_name (TestCase *tc,\n                    gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"application/json\\\",\\\"X-Cockpit-Pkg-Checksum\\\":\\\"\" CHECKSUM_BADPACKAGE \"\\\",\\\"ETag\\\":\\\"\\\\\\\"$\" CHECKSUM_BADPACKAGE \"\\\\\\\"\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"{\\\".checksum\\\":\\\"\" CHECKSUM_BADPACKAGE \"\\\",\\\"ok\\\":{\\\".checksum\\\":\\\"\" CHECKSUM_BADPACKAGE \"\\\"}}\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_glob = {\n    .datadirs = { SRCDIR \"/src/bridge/mock-resource/glob\", NULL },\n    .path = \"/*/file.txt\"\n};\n\nstatic void\ntest_glob (TestCase *tc,\n           gconstpointer fixture)\n{\n  GError *error = NULL;\n  GBytes *message;\n  JsonObject *object;\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  message = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (message, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"X-Cockpit-Pkg-Checksum\\\":\\\"\" CHECKSUM_GLOB \"\\\",\\\"Content-Type\\\":\\\"text/plain\\\"}}\");\n  json_object_unref (object);\n\n  message = mock_transport_pop_channel (tc->transport, \"444\");\n  cockpit_assert_bytes_eq (message, \"a\\n\", 2);\n\n  message = mock_transport_pop_channel (tc->transport, \"444\");\n  cockpit_assert_bytes_eq (message, \"b\\n\", 2);\n}\n\nstatic const Fixture fixture_with_gzip = {\n    .datadirs = { SRCDIR \"/src/bridge/mock-resource/gzip\", NULL },\n    .path = \"/package/file.txt\",\n    .binary = TRUE,\n    .headers = { \"Accept-Encoding\", \"*\" },\n};\n\nstatic void\ntest_with_gzip (TestCase *tc,\n                gconstpointer fixture)\n{\n  GError *error = NULL;\n  GBytes *message;\n  JsonObject *object;\n  GBytes *data;\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  message = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (message, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"X-Cockpit-Pkg-Checksum\\\":\\\"\" CHECKSUM_GZIP \"\\\",\\\"Content-Encoding\\\":\\\"gzip\\\",\\\"Content-Type\\\":\\\"text/plain\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", NULL);\n  g_assert_cmpint (g_bytes_get_size (data), ==, 9377);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_no_gzip = {\n    .datadirs = { SRCDIR \"/src/bridge/mock-resource/gzip\", NULL },\n    .path = \"/package/file.txt\",\n    .binary = TRUE,\n    .headers = { \"Accept-Encoding\", \"identity\" },\n};\n\nstatic void\ntest_no_gzip (TestCase *tc,\n              gconstpointer fixture)\n{\n  GError *error = NULL;\n  GBytes *message;\n  JsonObject *object;\n  GBytes *data;\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  message = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (message, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"X-Cockpit-Pkg-Checksum\\\":\\\"\" CHECKSUM_GZIP \"\\\",\\\"Content-Type\\\":\\\"text/plain\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", NULL);\n  g_assert_cmpint (g_bytes_get_size (data), ==, 26530);\n  g_bytes_unref (data);\n}\n\nstatic void\nsetup_basic (TestCase *tc,\n             gconstpointer data)\n{\n  const Fixture *fixture = data;\n\n  if (fixture && fixture->datadirs[0])\n    {\n      cockpit_bridge_data_dirs = (const gchar **)fixture->datadirs;\n    }\n  else\n    {\n      cockpit_expect_message (\"incompatible: package requires a later version of cockpit: 999.5*\");\n      cockpit_expect_message (\"requires: package has an unknown requirement: unknown\");\n    }\n\n  if (!fixture || !fixture->no_packages_init)\n    tc->packages = cockpit_packages_new ();\n}\n\nstatic void\nteardown_basic (TestCase *tc,\n                gconstpointer data)\n{\n  cockpit_assert_expected ();\n\n  cockpit_packages_free (tc->packages);\n\n  cockpit_bridge_data_dirs = NULL;\n}\n\nstatic void\ntest_resolve (TestCase *tc,\n              gconstpointer fixture)\n{\n  gchar *path;\n\n  path = cockpit_packages_resolve (tc->packages, \"test\", \"/sub/file.ext\", NULL);\n  g_assert_cmpstr (SRCDIR \"/src/bridge/mock-resource/system/cockpit/test-priority/sub/file.ext\", ==, path);\n  g_free (path);\n\n  path = cockpit_packages_resolve (tc->packages, \"test\", \"/_modules/@testorg/toolkit.js\", NULL);\n  g_assert_cmpstr (SRCDIR \"/src/bridge/mock-resource/system/cockpit/test-priority/_modules/@testorg/toolkit.js\", ==, path);\n  g_free (path);\n}\n\nstatic void\ntest_resolve_bad_dots (TestCase *tc,\n                       gconstpointer fixture)\n{\n  gchar *path;\n\n  cockpit_expect_message (\"invalid 'path' used as a resource: *\");\n\n  path = cockpit_packages_resolve (tc->packages, \"test\", \"../test/sub/file.ext\", NULL);\n  g_assert (path == NULL);\n}\n\nstatic void\ntest_resolve_bad_path (TestCase *tc,\n                       gconstpointer fixture)\n{\n  gchar *path;\n\n  cockpit_expect_message (\"invalid 'path' used as a resource: *\");\n\n  path = cockpit_packages_resolve (tc->packages, \"test\", \"/sub/#file.ext\", NULL);\n  g_assert (path == NULL);\n}\n\nstatic void\ntest_resolve_bad_package (TestCase *tc,\n                          gconstpointer fixture)\n{\n  gchar *path;\n\n  cockpit_expect_message (\"invalid 'package' name: *\");\n\n  path = cockpit_packages_resolve (tc->packages, \"#test\", \"/sub/file.ext\", NULL);\n  g_assert (path == NULL);\n}\n\nstatic void\ntest_resolve_not_found (TestCase *tc,\n                        gconstpointer fixture)\n{\n  gchar *path;\n\n  path = cockpit_packages_resolve (tc->packages, \"unknown\", \"/sub/file.ext\", NULL);\n  g_assert (path == NULL);\n}\n\nstatic int\ncompar_str (const void *pa,\n            const void *pb)\n{\n  return strcmp (*(const char**)pa, *(const char**)pb);\n}\n\nstatic void\ntest_get_names (TestCase *tc,\n                gconstpointer fixture)\n{\n  gchar **names;\n  gchar *result;\n\n  names = cockpit_packages_get_names (tc->packages);\n  g_assert (names != NULL);\n\n  qsort (names, g_strv_length (names), sizeof (gchar *), compar_str);\n  result = g_strjoinv (\", \", names);\n\n  /* Note that unavailable packages are not included */\n  g_assert_cmpstr (result, ==, \"another, second, test\");\n\n  g_free (result);\n  g_free (names);\n}\n\nstatic void\ntest_get_bridges (TestCase *tc,\n                  gconstpointer fixture)\n{\n  GList *bridges, *l;\n  JsonObject *bridge;\n  guint i;\n\n  bridges = cockpit_packages_get_bridges (tc->packages);\n  g_assert (bridges != NULL);\n\n  for (i = 0, l = bridges; l != NULL; l = g_list_next (l), i++)\n    {\n      bridge = l->data;\n      switch (i)\n        {\n        case 0:\n          cockpit_assert_json_eq (json_object_get_object_member (bridge, \"match\"),\n                                  \"{ \\\"blah\\\": \\\"test*\\\" }\");\n          cockpit_assert_json_eq (json_object_get_array_member (bridge, \"environ\"),\n                                  \"[\\\"TEST_ENV=test\\\"]\");\n          cockpit_assert_json_eq (json_object_get_array_member (bridge, \"spawn\"),\n                                  \"[\\\"/usr/bin/cat\\\"]\");\n          break;\n        case 1:\n          cockpit_assert_json_eq (json_object_get_object_member (bridge, \"match\"),\n                                  \"{ \\\"blah\\\": \\\"marmalade*\\\" }\");\n          g_assert_cmpstr (json_object_get_string_member (bridge, \"problem\"), ==, \"bogus-channel\");\n          break;\n        case 2:\n          cockpit_assert_json_eq (json_object_get_object_member (bridge, \"match\"),\n                                  \"{ \\\"second\\\": null }\");\n          g_assert_cmpstr (json_object_get_string_member (bridge, \"problem\"), ==, \"never-a-second\");\n          break;\n        case 3:\n          cockpit_assert_json_eq (json_object_get_object_member (bridge, \"match\"),\n                                  \"{ \\\"host\\\": null }\");\n          g_assert_cmpstr (json_object_get_string_member (bridge, \"problem\"), ==, \"not-supported\");\n          break;\n        default:\n          g_assert_not_reached ();\n        }\n    }\n\n  g_assert_cmpint (i, ==, 4);\n  g_list_free (bridges);\n}\n\nstatic const Fixture fixture_bad_bridges = {\n    .datadirs = { SRCDIR \"/src/bridge/mock-resource/bad-bridges\", NULL },\n};\n\nstatic void\ntest_get_bridges_broken (TestCase *tc,\n                         gconstpointer fixture)\n{\n  GList *bridges;\n\n  g_assert (fixture == &fixture_bad_bridges);\n\n  cockpit_expect_message (\"missing-match: Exactly one of \\\"match\\\" or \\\"privileged\\\" required\");\n  cockpit_expect_message (\"broken-problem: invalid \\\"problem\\\" field in package manifest\");\n  cockpit_expect_message (\"broken-environ: invalid \\\"environ\\\" field in package manifest\");\n  cockpit_expect_message (\"broken-spawn: invalid \\\"spawn\\\" field in package manifest\");\n  cockpit_expect_message (\"broken-match: invalid \\\"match\\\" field in package manifest\");\n  cockpit_expect_message (\"broken-bridges: invalid \\\"bridges\\\" field in package manifest\");\n  cockpit_expect_message (\"broken-bridge: invalid bridge in \\\"bridges\\\" field in package manifest\");\n\n  bridges = cockpit_packages_get_bridges (tc->packages);\n  g_assert (bridges == NULL);\n}\n\nstatic const Fixture fixture_reload = {\n  .no_packages_init = TRUE,\n  .datadirs = { BUILDDIR \"/src/bridge/mock-resource/reload\", NULL },\n};\n\n__attribute__((format(printf, 1, 2)))\nstatic void\nsystemf (const gchar *fmt, ...)\n{\n  gchar *cmd;\n\n  va_list ap;\n  va_start (ap, fmt);\n  cmd = g_strdup_vprintf (fmt, ap);\n  va_end (ap);\n\n  g_assert (system (cmd) == 0);\n\n  g_free (cmd);\n}\n\nstatic void\nsetup_reload_packages (const gchar *datadir,\n                       const gchar *variant)\n{\n  const gchar *srcdir = SRCDIR \"/src/bridge/mock-resource/reload\";\n  systemf (\"mkdir -p $(dirname '%s') && rm -rf '%s' && ln -sf '%s.%s' '%s'\",\n           datadir, datadir, srcdir, variant, datadir);\n}\n\nstatic void\nteardown_reload_packages (const gchar *datadir)\n{\n  systemf (\"rm -f '%s'\", datadir);\n}\n\nstatic void\nassert_manifest_checksum (TestCase *tc,\n                          const gchar *name,\n                          const gchar *expected)\n{\n  JsonObject *json;\n  const gchar *checksum;\n\n  json = cockpit_packages_peek_json (tc->packages);\n  if (name)\n    g_assert (cockpit_json_get_object (json, name, NULL, &json));\n  if (expected)\n    {\n      g_assert (cockpit_json_get_string (json, \".checksum\", NULL, &checksum));\n      g_assert_cmpstr (checksum, ==, expected);\n    }\n  else\n    g_assert (json == NULL);\n}\n\nstatic void\ntest_reload_added (TestCase *tc,\n                   gconstpointer data)\n{\n  const Fixture *fixture = data;\n  const gchar *datadir;\n\n  cockpit_bridge_data_dirs = (const gchar **)fixture->datadirs;\n  datadir = cockpit_bridge_data_dirs[0];\n\n  setup_reload_packages (datadir, \"old\");\n  tc->packages = cockpit_packages_new ();\n\n  assert_manifest_checksum (tc, NULL,  CHECKSUM_RELOAD_OLD);\n  assert_manifest_checksum (tc, \"old\", CHECKSUM_RELOAD_OLD);\n\n  setup_reload_packages (datadir, \"new\");\n  cockpit_packages_reload (tc->packages);\n\n  assert_manifest_checksum (tc, NULL,  CHECKSUM_RELOAD_OLD);\n  assert_manifest_checksum (tc, \"old\", CHECKSUM_RELOAD_OLD);\n  assert_manifest_checksum (tc, \"new\", CHECKSUM_RELOAD_NEW);\n\n  teardown_reload_packages (datadir);\n}\n\nstatic void\ntest_reload_removed (TestCase *tc,\n                     gconstpointer data)\n{\n  const Fixture *fixture = data;\n  const gchar *datadir;\n\n  cockpit_bridge_data_dirs = (const gchar **)fixture->datadirs;\n  datadir = cockpit_bridge_data_dirs[0];\n\n  setup_reload_packages (datadir, \"new\");\n  tc->packages = cockpit_packages_new ();\n\n  assert_manifest_checksum (tc, NULL,  CHECKSUM_RELOAD_NEW);\n  assert_manifest_checksum (tc, \"old\", CHECKSUM_RELOAD_NEW);\n  assert_manifest_checksum (tc, \"new\", CHECKSUM_RELOAD_NEW);\n\n  setup_reload_packages (datadir, \"old\");\n  cockpit_packages_reload (tc->packages);\n\n  assert_manifest_checksum (tc, NULL,  CHECKSUM_RELOAD_NEW);\n  assert_manifest_checksum (tc, \"old\", CHECKSUM_RELOAD_NEW);\n  assert_manifest_checksum (tc, \"new\", NULL);\n\n  teardown_reload_packages (datadir);\n}\n\nstatic void\ntest_reload_updated (TestCase *tc,\n                     gconstpointer data)\n{\n  const Fixture *fixture = data;\n  const gchar *datadir;\n\n  cockpit_bridge_data_dirs = (const gchar **)fixture->datadirs;\n  datadir = cockpit_bridge_data_dirs[0];\n\n  setup_reload_packages (datadir, \"old\");\n  tc->packages = cockpit_packages_new ();\n\n  assert_manifest_checksum (tc, NULL,  CHECKSUM_RELOAD_OLD);\n  assert_manifest_checksum (tc, \"old\", CHECKSUM_RELOAD_OLD);\n\n  setup_reload_packages (datadir, \"updated\");\n  cockpit_packages_reload (tc->packages);\n\n  assert_manifest_checksum (tc, NULL,  CHECKSUM_RELOAD_OLD);\n  assert_manifest_checksum (tc, \"old\", CHECKSUM_RELOAD_UPDATED);\n\n  teardown_reload_packages (datadir);\n}\n\nstatic const Fixture fixture_csp_strip = {\n  .path = \"/strip/test.html\",\n  .datadirs = { SRCDIR \"/src/bridge/mock-resource/csp\", NULL },\n  .headers = { \"Host\", \"blah:9090\" },\n};\n\nstatic void\ntest_csp_strip (TestCase *tc,\n                gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_csp_strip);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Security-Policy\\\":\\\"connect-src 'self' http://blah:9090 ws://blah:9090; form-action 'self' http://blah:9090; base-uri 'self' http://blah:9090; object-src 'none'; font-src 'self' http://blah:9090 data:; block-all-mixed-content; img-src 'self' http://blah:9090; default-src 'self' http://blah:9090\\\",\\\"Content-Type\\\":\\\"text/html\\\",\\\"X-Cockpit-Pkg-Checksum\\\":\\\"\" CHECKSUM_CSP \"\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"<html>\\n<head>\\n<title>Test</title>\\n</head>\\n<body>Test</body>\\n</html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nint\nmain (int argc,\n      char *argv[])\n{\n  cockpit_setenv_check (\"XDG_DATA_DIRS\", SRCDIR \"/src/bridge/mock-resource/system\", TRUE);\n  cockpit_setenv_check (\"XDG_DATA_HOME\", SRCDIR \"/src/bridge/mock-resource/home\", TRUE);\n\n  cockpit_bridge_local_address = \"127.0.0.1\";\n\n  cockpit_test_init (&argc, &argv);\n\n  g_test_add (\"/packages/simple\", TestCase, &fixture_simple,\n              setup, test_simple, teardown);\n  g_test_add (\"/packages/forwarded\", TestCase, &fixture_forwarded,\n              setup, test_forwarded, teardown);\n  g_test_add (\"/packages/localized-translated\", TestCase, &fixture_pig,\n              setup, test_localized_translated, teardown);\n  g_test_add (\"/packages/localized-unknown\", TestCase, &fixture_unknown,\n              setup, test_localized_unknown, teardown);\n  g_test_add (\"/packages/localized-prefer-region\", TestCase, &fixture_prefer_region,\n              setup, test_localized_prefer_region, teardown);\n  g_test_add (\"/packages/localized-fallback\", TestCase, &fixture_fallback,\n              setup, test_localized_fallback, teardown);\n  g_test_add (\"/packages/incompatible/version\", TestCase, &fixture_version,\n              setup, test_incompatible_version, teardown);\n  g_test_add (\"/packages/incompatible/requires\", TestCase, &fixture_requires,\n              setup, test_incompatible_requires, teardown);\n  g_test_add (\"/packages/large\", TestCase, &fixture_large,\n              setup, test_large, teardown);\n  g_test_add (\"/packages/listing\", TestCase, &fixture_listing,\n              setup, test_listing, teardown);\n  g_test_add (\"/packages/not-found\", TestCase, &fixture_not_found,\n              setup, test_not_found, teardown);\n  g_test_add (\"/packages/unknown-package\", TestCase, &fixture_unknown_package,\n              setup, test_unknown_package, teardown);\n  g_test_add (\"/packages/bad-receive\", TestCase, &fixture_large,\n              setup, test_bad_receive, teardown);\n  g_test_add (\"/packages/no-path\", TestCase, &fixture_no_path,\n              setup, test_no_path, teardown);\n  g_test_add (\"/packages/bad-path\", TestCase, &fixture_bad_path,\n              setup, test_bad_path, teardown);\n  g_test_add (\"/packages/no-package\", TestCase, &fixture_no_package,\n              setup, test_no_package, teardown);\n  g_test_add (\"/packages/bad-package\", TestCase, &fixture_bad_package,\n              setup, test_bad_package, teardown);\n\n  g_test_add (\"/packages/listing-bad-name\", TestCase, &fixture_list_bad_name,\n              setup, test_list_bad_name, teardown);\n\n  g_test_add (\"/packages/glob\", TestCase, &fixture_glob,\n              setup, test_glob, teardown);\n  g_test_add (\"/packages/with-gzip\", TestCase, &fixture_with_gzip,\n              setup, test_with_gzip, teardown);\n  g_test_add (\"/packages/no-gzip\", TestCase, &fixture_no_gzip,\n              setup, test_no_gzip, teardown);\n\n  g_test_add (\"/packages/resolve/simple\", TestCase, NULL,\n              setup_basic, test_resolve, teardown_basic);\n  g_test_add (\"/packages/resolve/bad-dots\", TestCase, NULL,\n              setup_basic, test_resolve_bad_dots, teardown_basic);\n  g_test_add (\"/packages/resolve/bad-path\", TestCase, NULL,\n              setup_basic, test_resolve_bad_path, teardown_basic);\n  g_test_add (\"/packages/resolve/bad-package\", TestCase, NULL,\n              setup_basic, test_resolve_bad_package, teardown_basic);\n  g_test_add (\"/packages/resolve/not-found\", TestCase, NULL,\n              setup_basic, test_resolve_not_found, teardown_basic);\n\n  g_test_add (\"/packages/get-names\", TestCase, NULL,\n              setup_basic, test_get_names, teardown_basic);\n\n  g_test_add (\"/packages/get-bridges/normal\", TestCase, NULL,\n              setup_basic, test_get_bridges, teardown_basic);\n  g_test_add (\"/packages/get-bridges/broken\", TestCase, &fixture_bad_bridges,\n              setup_basic, test_get_bridges_broken, teardown_basic);\n\n  g_test_add (\"/packages/reload/added\", TestCase, &fixture_reload,\n              setup_basic, test_reload_added, teardown_basic);\n  g_test_add (\"/packages/reload/removed\", TestCase, &fixture_reload,\n              setup_basic, test_reload_removed, teardown_basic);\n  g_test_add (\"/packages/reload/updated\", TestCase, &fixture_reload,\n              setup_basic, test_reload_updated, teardown_basic);\n\n  g_test_add (\"/packages/csp/strip\", TestCase, &fixture_csp_strip,\n              setup, test_csp_strip, teardown);\n\n  return g_test_run ();\n}\n", "/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2014 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n/* This gets logged as part of the (more verbose) protocol logging */\n#ifdef G_LOG_DOMAIN\n#undef G_LOG_DOMAIN\n#endif\n#define G_LOG_DOMAIN \"cockpit-protocol\"\n\n#include \"config.h\"\n\n#include \"cockpitwebresponse.h\"\n#include \"cockpitwebfilter.h\"\n\n#include \"common/cockpitconf.h\"\n#include \"common/cockpiterror.h\"\n#include \"common/cockpitflow.h\"\n#include \"common/cockpitlocale.h\"\n#include \"common/cockpittemplate.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n\n/**\n * Certain processes may want to have a non-default error page.\n */\nconst gchar *cockpit_web_failure_resource = NULL;\n\nstatic const gchar default_failure_template[] =\n  \"<html><head><title>@@message@@</title></head><body>@@message@@</body></html>\\n\";\n\n/**\n * CockpitWebResponse:\n *\n * A response sent back to an HTTP client. You can use the high level one\n * shot APIs, like cockpit_web_response_content() and\n * cockpit_web_response_error() * or low level builder APIs:\n *\n * cockpit_web_response_headers() send the headers\n * cockpit_web_response_queue() send a block of data.\n * cockpit_web_response_complete() finish.\n */\n\nstruct _CockpitWebResponse {\n  GObject parent;\n  GIOStream *io;\n  const gchar *logname;\n  const gchar *path;\n  gchar *full_path;\n  gchar *query;\n  gchar *url_root;\n  gchar *method;\n  gchar *origin;\n\n  CockpitWebResponseFlags flags;\n  CockpitCacheType cache_type;\n\n  /* The output queue */\n  GPollableOutputStream *out;\n  GQueue *queue;\n  gsize out_queued;\n  gsize out_queueable;\n  gsize partial_offset;\n  GSource *source;\n\n  /* Status flags */\n  guint count;\n  gboolean complete;\n  gboolean failed;\n  gboolean done;\n  gboolean chunked;\n  gboolean keep_alive;\n\n  GList *filters;\n};\n\n/* A megabyte is when we start to consider queue full enough */\n#define QUEUE_PRESSURE 1024UL * 1024UL\n\nstatic guint signal__done;\n\nstatic void      cockpit_web_response_flow_iface_init      (CockpitFlowInterface *iface);\n\nG_DEFINE_TYPE_WITH_CODE (CockpitWebResponse, cockpit_web_response, G_TYPE_OBJECT,\n                         G_IMPLEMENT_INTERFACE (COCKPIT_TYPE_FLOW, cockpit_web_response_flow_iface_init));\n\nstatic void\ncockpit_web_response_init (CockpitWebResponse *self)\n{\n  self->queue = g_queue_new ();\n  self->out_queueable = G_MAXSIZE;\n  self->cache_type = COCKPIT_WEB_RESPONSE_CACHE_UNSET;\n}\n\nstatic void\ncockpit_web_response_done (CockpitWebResponse *self)\n{\n  gboolean reusable = FALSE;\n\n  g_object_ref (self);\n\n  g_assert (!self->done);\n  self->done = TRUE;\n\n  if (self->source)\n    {\n      g_source_destroy (self->source);\n      g_source_unref (self->source);\n      self->source = NULL;\n    }\n\n  if (self->complete)\n    {\n      reusable = !self->failed && self->keep_alive;\n      g_object_unref (self);\n    }\n  else if (!self->failed)\n    {\n      g_critical (\"A CockpitWebResponse was freed without being completed properly. \"\n                  \"This is a programming error.\");\n    }\n\n  g_signal_emit (self, signal__done, 0, reusable);\n\n  g_object_unref (self->io);\n  self->io = NULL;\n  self->out = NULL;\n\n  g_object_unref (self);\n}\n\nstatic void\ncockpit_web_response_dispose (GObject *object)\n{\n  CockpitWebResponse *self = COCKPIT_WEB_RESPONSE (object);\n\n  if (!self->done)\n    cockpit_web_response_done (self);\n  g_list_free_full (self->filters, g_object_unref);\n  self->filters = NULL;\n\n  G_OBJECT_CLASS (cockpit_web_response_parent_class)->dispose (object);\n}\n\nstatic void\ncockpit_web_response_finalize (GObject *object)\n{\n  CockpitWebResponse *self = COCKPIT_WEB_RESPONSE (object);\n\n  g_free (self->full_path);\n  g_free (self->query);\n  g_free (self->url_root);\n  g_free (self->method);\n  g_free (self->origin);\n  g_assert (self->io == NULL);\n  g_assert (self->out == NULL);\n  g_queue_free_full (self->queue, (GDestroyNotify)g_bytes_unref);\n  self->out_queued = 0;\n\n  G_OBJECT_CLASS (cockpit_web_response_parent_class)->finalize (object);\n}\n\nstatic void\ncockpit_web_response_class_init (CockpitWebResponseClass *klass)\n{\n  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n\n  gobject_class->dispose = cockpit_web_response_dispose;\n  gobject_class->finalize = cockpit_web_response_finalize;\n\n  signal__done = g_signal_new (\"done\", COCKPIT_TYPE_WEB_RESPONSE,\n                               G_SIGNAL_RUN_LAST,\n                               0, NULL, NULL, NULL,\n                               G_TYPE_NONE, 1, G_TYPE_BOOLEAN);\n}\n\n/**\n * cockpit_web_response_new:\n * @io: the stream to send on\n * @path: the path resource or NULL\n * @query: the query string or NULL\n * @in_headers: input headers or NULL\n * @flags: in #COCKPIT_WEB_RESPONSE_FOR_TLS_PROXY mode, the origin is assumed to\n *         be https://<host> even for a non-HTTPS connection.\n *\n * Create a new web response.\n *\n * The returned reference belongs to the caller. Additionally\n * once cockpit_web_response_complete() is called, an additional\n * reference is held until the response is sent and flushed.\n *\n * Returns: (transfer full): the new response, unref when done with it\n */\nCockpitWebResponse *\ncockpit_web_response_new (GIOStream *io,\n                          const gchar *original_path,\n                          const gchar *path,\n                          const gchar *query,\n                          GHashTable *in_headers,\n                          CockpitWebResponseFlags flags)\n{\n  CockpitWebResponse *self;\n  GOutputStream *out;\n  const gchar *connection;\n  const gchar *protocol = NULL;\n  const gchar *host = NULL;\n  gint offset;\n\n  /* Trying to be a somewhat performant here, avoiding properties */\n  self = g_object_new (COCKPIT_TYPE_WEB_RESPONSE, NULL);\n  self->io = g_object_ref (io);\n\n  out = g_io_stream_get_output_stream (io);\n  if (G_IS_POLLABLE_OUTPUT_STREAM (out))\n    {\n      self->out = (GPollableOutputStream *)out;\n    }\n  else if (out)\n    {\n      g_critical (\"Cannot send web response over non-pollable output stream: %s\",\n                  G_OBJECT_TYPE_NAME (out));\n    }\n  else\n    {\n      g_critical (\"Cannot send web response: no output stream available\");\n    }\n\n  self->url_root = NULL;\n  self->full_path = g_strdup (path);\n  self->path = self->full_path;\n\n  if (path && original_path)\n    {\n      offset = strlen (original_path) - strlen (path);\n      if (offset > 0 && g_strcmp0 (original_path + offset, path) == 0)\n        self->url_root = g_strndup (original_path, offset);\n    }\n\n  self->query = g_strdup (query);\n  if (self->path)\n    self->logname = self->path;\n  else\n    self->logname = \"response\";\n\n  self->keep_alive = TRUE;\n  if (in_headers)\n    {\n      connection = g_hash_table_lookup (in_headers, \"Connection\");\n      if (connection)\n        self->keep_alive = g_str_equal (connection, \"keep-alive\");\n      host = g_hash_table_lookup (in_headers, \"Host\");\n    }\n\n  self->flags = flags;\n  protocol = cockpit_web_response_get_protocol (self, in_headers);\n  if (protocol && host)\n    self->origin = g_strdup_printf (\"%s://%s\", protocol, host);\n\n  return self;\n}\n\nvoid\ncockpit_web_response_set_method (CockpitWebResponse *response,\n                                 const gchar *method)\n{\n  g_return_if_fail (g_strcmp0 (method, \"GET\") == 0 || g_strcmp0 (method, \"HEAD\") == 0);\n  response->method = g_strdup (method);\n}\n\n/**\n * cockpit_web_response_get_path:\n * @self: the response\n *\n * Returns: the resource path for response\n */\nconst gchar *\ncockpit_web_response_get_path (CockpitWebResponse *self)\n{\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), NULL);\n  return self->path;\n}\n\n/**\n * cockpit_web_response_get_url_root:\n * @self: the response\n *\n * Returns: The url root portion of the original path that was removed\n */\nconst gchar *\ncockpit_web_response_get_url_root (CockpitWebResponse *self) {\n  return self->url_root;\n}\n\n/**\n * cockpit_web_response_get_query:\n * @self: the response\n *\n * Returns: the resource path for response\n */\nconst gchar *\ncockpit_web_response_get_query (CockpitWebResponse *self)\n{\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), NULL);\n  return self->query;\n}\n\n/**\n * cockpit_web_response_get_stream:\n * @self: the response\n *\n * Returns: the stream we're sending on\n */\nGIOStream *\ncockpit_web_response_get_stream  (CockpitWebResponse *self)\n{\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), NULL);\n  return self->io;\n}\n\n#if !GLIB_CHECK_VERSION(2,43,2)\n#define G_IO_ERROR_CONNECTION_CLOSED G_IO_ERROR_BROKEN_PIPE\n#endif\n\ngboolean\ncockpit_web_should_suppress_output_error (const gchar *logname,\n                                          GError *error)\n{\n  if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CONNECTION_CLOSED) ||\n      g_error_matches (error, G_IO_ERROR, G_IO_ERROR_BROKEN_PIPE))\n    {\n      g_debug (\"%s: output error: %s\", logname, error->message);\n      return TRUE;\n    }\n\n#if !GLIB_CHECK_VERSION(2,43,2)\n  if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED) &&\n      strstr (error->message, g_strerror (ECONNRESET)))\n    {\n      g_debug (\"%s: output error: %s\", logname, error->message);\n      return TRUE;\n    }\n#endif\n\n  return FALSE;\n}\n\nstatic void\non_output_flushed (GObject *stream,\n                   GAsyncResult *result,\n                   gpointer user_data)\n{\n  CockpitWebResponse *self = COCKPIT_WEB_RESPONSE (user_data);\n  GOutputStream *output = G_OUTPUT_STREAM (stream);\n  GError *error = NULL;\n\n  if (g_output_stream_flush_finish (output, result, &error))\n    {\n      g_debug (\"%s: flushed output\", self->logname);\n    }\n  else\n    {\n      if (!cockpit_web_should_suppress_output_error (self->logname, error))\n        g_message (\"%s: couldn't flush web output: %s\", self->logname, error->message);\n      self->failed = TRUE;\n      g_error_free (error);\n    }\n\n  cockpit_web_response_done (self);\n  g_object_unref (self);\n}\n\nstatic gboolean\non_response_output (GObject *pollable,\n                    gpointer user_data)\n{\n  CockpitWebResponse *self = user_data;\n  GError *error = NULL;\n  const guint8 *data;\n  GBytes *block;\n  gssize count;\n  gsize before, size, len;\n\n  block = g_queue_peek_head (self->queue);\n  if (block)\n    {\n      data = g_bytes_get_data (block, &len);\n      g_assert (len == 0 || self->partial_offset < len);\n      data += self->partial_offset;\n      len -= self->partial_offset;\n\n      before = self->out_queued;\n\n      if (len > 0)\n        {\n          count = g_pollable_output_stream_write_nonblocking (self->out, data, len,\n                                                              NULL, &error);\n        }\n      else\n        {\n          count = 0;\n        }\n\n      if (count < 0)\n        {\n          if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK))\n            {\n              g_error_free (error);\n              return TRUE;\n            }\n\n          if (!cockpit_web_should_suppress_output_error (self->logname, error))\n            g_message (\"%s: couldn't write web output: %s\", self->logname, error->message);\n\n          self->failed = TRUE;\n          cockpit_web_response_done (self);\n\n          g_error_free (error);\n          return FALSE;\n        }\n\n      if (count == len)\n        {\n          g_debug (\"%s: sent %d bytes\", self->logname, (int)len);\n          self->partial_offset = 0;\n          block = g_queue_pop_head (self->queue);\n          size = g_bytes_get_size (block);\n          g_assert (size <= self->out_queued);\n          self->out_queued -= size;\n          g_bytes_unref (block);\n        }\n      else\n        {\n          g_debug (\"%s: sent %d partial\", self->logname, (int)count);\n          g_assert (count < len);\n          self->partial_offset += count;\n        }\n\n      /*\n       * If we're controlling another flow, turn it on again when our output\n       * buffer size becomes less than the low mark.\n       */\n      if (before >= QUEUE_PRESSURE && self->out_queued < QUEUE_PRESSURE)\n        cockpit_flow_emit_pressure (COCKPIT_FLOW (self), FALSE);\n\n      return TRUE;\n    }\n  else\n    {\n      g_source_destroy (self->source);\n      g_source_unref (self->source);\n      self->source = NULL;\n\n      if (self->complete)\n        {\n          g_debug (\"%s: complete flushing output\", self->logname);\n          g_output_stream_flush_async (G_OUTPUT_STREAM (self->out), G_PRIORITY_DEFAULT,\n                                       NULL, on_output_flushed, g_object_ref (self));\n        }\n\n      return FALSE;\n    }\n}\n\nstatic void\nqueue_bytes (CockpitWebResponse *self,\n             GBytes *block)\n{\n  gsize size, before;\n\n  size = g_bytes_get_size (block);\n  before = self->out_queued;\n  g_return_if_fail (G_MAXSIZE - size > self->out_queued);\n  self->out_queued += size;\n\n  g_queue_push_tail (self->queue, g_bytes_ref (block));\n\n  self->count++;\n\n  if (!self->source)\n    {\n      self->source = g_pollable_output_stream_create_source (self->out, NULL);\n      g_source_set_callback (self->source, (GSourceFunc)on_response_output, self, NULL);\n      g_source_attach (self->source, NULL);\n    }\n\n  if (before < QUEUE_PRESSURE && self->out_queued >= QUEUE_PRESSURE)\n    cockpit_flow_emit_pressure (COCKPIT_FLOW (self), TRUE);\n}\n\nstatic void\nqueue_block (CockpitWebResponse *self,\n             GBytes *block)\n{\n  gsize length = g_bytes_get_size (block);\n  GBytes *bytes;\n  gchar *data;\n\n  /*\n   * We cannot queue chunks of length zero. Besides being silly, this\n   * messes with chunked encoding. The 0 length block means end of\n   * response.\n   */\n  if (length == 0)\n    return;\n\n  if (self->out_queueable < length)\n    {\n      g_critical (\"Too much data queuing in HTTP response. This is a programmer error.\");\n      return;\n    }\n\n  self->out_queueable -= length;\n  g_debug (\"%s: queued %d bytes\", self->logname, (int)length);\n\n  if (!self->chunked)\n    {\n      queue_bytes (self, block);\n    }\n  else\n    {\n      /* Required for chunked transfer encoding. */\n      data = g_strdup_printf (\"%x\\r\\n\", (unsigned int)length);\n      bytes = g_bytes_new_take (data, strlen (data));\n      queue_bytes (self, bytes);\n      g_bytes_unref (bytes);\n\n      queue_bytes (self, block);\n\n      bytes = g_bytes_new_static (\"\\r\\n\", 2);\n      queue_bytes (self, bytes);\n      g_bytes_unref (bytes);\n    }\n}\n\ntypedef struct {\n  CockpitWebResponse *response;\n  GList *filters;\n} QueueStep;\n\nstatic void\nqueue_filter (gpointer data,\n              GBytes *bytes)\n{\n  QueueStep *qs = data;\n  QueueStep qn = { .response = qs->response };\n\n  g_return_if_fail (bytes != NULL);\n\n  if (qs->filters)\n    {\n      qn.filters = qs->filters->next;\n      cockpit_web_filter_push (qs->filters->data, bytes, queue_filter, &qn);\n    }\n  else\n    {\n      queue_block (qs->response, bytes);\n    }\n}\n\n/**\n * cockpit_web_response_queue:\n * @self: the response\n * @block: the block of data to queue\n *\n * Queue a single block of data on the response. Will be sent\n * during the main loop.\n *\n * See cockpit_web_response_content() for a simple way to\n * avoid queueing individual blocks.\n *\n * If this function returns %FALSE, then the response has failed\n * or has been completed elsewhere. The block was ignored and\n * queuing more blocks doesn't makes sense.\n *\n * After done queuing all your blocks call\n * cockpit_web_response_complete().\n*\n * Returns: Whether queuing more blocks makes sense\n */\ngboolean\ncockpit_web_response_queue (CockpitWebResponse *self,\n                            GBytes *block)\n{\n  QueueStep qn = { .response = self };\n\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), FALSE);\n  g_return_val_if_fail (block != NULL, FALSE);\n  g_return_val_if_fail (self->complete == FALSE, FALSE);\n\n  if (self->failed)\n    {\n      g_debug (\"%s: ignoring queued block after failure\", self->logname);\n      return FALSE;\n    }\n\n  if (g_strcmp0 (self->method, \"HEAD\") == 0)\n    {\n      g_debug (\"%s: ignoring queued block for method HEAD\", self->logname);\n      return TRUE;\n    }\n\n  qn.filters = self->filters;\n  queue_filter (&qn, block);\n  return TRUE;\n}\n\n/**\n * cockpit_web_response_complete:\n * @self: the response\n *\n * See cockpit_web_response_content() for easy to use stuff.\n *\n * Tell the response that all the data has been queued.\n * The response will hold a reference to itself until the\n * data is actually sent, so you can unref it.\n */\nvoid\ncockpit_web_response_complete (CockpitWebResponse *self)\n{\n  GBytes *bytes;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n  g_return_if_fail (self->complete == FALSE);\n\n  if (self->failed)\n    return;\n\n  /* Hold a reference until cockpit_web_response_done() */\n  g_object_ref (self);\n  self->complete = TRUE;\n\n  if (self->chunked)\n    {\n      bytes = g_bytes_new_static (\"0\\r\\n\\r\\n\", 5);\n      queue_bytes (self, bytes);\n      g_bytes_unref (bytes);\n    }\n\n  if (self->source)\n    {\n      g_debug (\"%s: queueing complete\", self->logname);\n    }\n  else\n    {\n      g_debug (\"%s: complete closing io\", self->logname);\n      g_output_stream_flush_async (G_OUTPUT_STREAM (self->out), G_PRIORITY_DEFAULT,\n                                   NULL, on_output_flushed, g_object_ref (self));\n    }\n}\n\n/**\n * cockpit_web_response_abort:\n * @self: the response\n *\n * This function is used when streaming content, and at\n * some point we can't provide the remainder of the content\n *\n * This completes the response and terminates the connection.\n */\nvoid\ncockpit_web_response_abort (CockpitWebResponse *self)\n{\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n  g_return_if_fail (self->complete == FALSE);\n\n  if (self->failed)\n    return;\n\n  /* Hold a reference until cockpit_web_response_done() */\n  g_object_ref (self);\n\n  self->complete = TRUE;\n  self->failed = TRUE;\n\n  g_debug (\"%s: aborted\", self->logname);\n  cockpit_web_response_done (self);\n}\n\n/**\n * CockpitWebResponding:\n * @COCKPIT_WEB_RESPONSE_READY: nothing queued or sent yet\n * @COCKPIT_WEB_RESPONSE_QUEUING: started and still queuing data on response\n * @COCKPIT_WEB_RESPONSE_COMPLETE: all data is queued or aborted\n * @COCKPIT_WEB_RESPONSE_SENT: data is completely sent\n *\n * Various states of the web response.\n */\n\n/**\n * cockpit_web_response_get_state:\n * @self: the web response\n *\n * Return the state of the web response.\n */\nCockpitWebResponding\ncockpit_web_response_get_state (CockpitWebResponse *self)\n{\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), 0);\n\n  if (self->done)\n    return COCKPIT_WEB_RESPONSE_SENT;\n  else if (self->complete)\n    return COCKPIT_WEB_RESPONSE_COMPLETE;\n  else if (self->count == 0)\n    return COCKPIT_WEB_RESPONSE_READY;\n  else\n    return COCKPIT_WEB_RESPONSE_QUEUING;\n}\n\ngboolean\ncockpit_web_response_is_simple_token (const gchar *string)\n{\n  string += strcspn (string, \" \\t\\r\\n\\v\");\n  return string[0] == '\\0';\n}\n\ngboolean\ncockpit_web_response_is_header_value (const gchar *string)\n{\n  string += strcspn (string, \"\\r\\n\\v\");\n  return string[0] == '\\0';\n}\n\nenum {\n    HEADER_CONTENT_TYPE = 1 << 0,\n    HEADER_CONTENT_ENCODING = 1 << 1,\n    HEADER_VARY = 1 << 2,\n    HEADER_CACHE_CONTROL = 1 << 3,\n    HEADER_DNS_PREFETCH_CONTROL = 1 << 4,\n    HEADER_REFERRER_POLICY = 1 << 5,\n    HEADER_CONTENT_TYPE_OPTIONS = 1 << 6,\n    HEADER_CROSS_ORIGIN_RESOURCE_POLICY = 1 << 7,\n};\n\nstatic GString *\nbegin_headers (CockpitWebResponse *response,\n               guint status,\n               const gchar *reason)\n{\n  GString *string;\n\n  string = g_string_sized_new (1024);\n  g_string_printf (string, \"HTTP/1.1 %d %s\\r\\n\", status, reason);\n\n  return string;\n}\n\nstatic guint\nappend_header (GString *string,\n               const gchar *name,\n               const gchar *value)\n{\n  if (value)\n    {\n      g_return_val_if_fail (cockpit_web_response_is_simple_token (name), 0);\n      g_return_val_if_fail (cockpit_web_response_is_header_value (value), 0);\n      g_string_append_printf (string, \"%s: %s\\r\\n\", name, value);\n    }\n  if (g_ascii_strcasecmp (\"Content-Type\", name) == 0)\n    return HEADER_CONTENT_TYPE;\n  if (g_ascii_strcasecmp (\"Cache-Control\", name) == 0)\n    return HEADER_CACHE_CONTROL;\n  if (g_ascii_strcasecmp (\"Vary\", name) == 0)\n    return HEADER_VARY;\n  if (g_ascii_strcasecmp (\"Content-Encoding\", name) == 0)\n    return HEADER_CONTENT_ENCODING;\n  if (g_ascii_strcasecmp (\"X-DNS-Prefetch-Control\", name) == 0)\n    return HEADER_DNS_PREFETCH_CONTROL;\n  if (g_ascii_strcasecmp (\"Referrer-Policy\", name) == 0)\n    return HEADER_REFERRER_POLICY;\n  if (g_ascii_strcasecmp (\"X-Content-Type-Options\", name) == 0)\n    return HEADER_CONTENT_TYPE_OPTIONS;\n  if (g_ascii_strcasecmp (\"Cross-Origin-Resource-Policy\", name) == 0)\n    return HEADER_CROSS_ORIGIN_RESOURCE_POLICY;\n  if (g_ascii_strcasecmp (\"Content-Length\", name) == 0 ||\n      g_ascii_strcasecmp (\"Transfer-Encoding\", name) == 0 ||\n      g_ascii_strcasecmp (\"Connection\", name) == 0)\n    {\n      g_critical (\"Don't set %s header manually. This is a programmer error.\", name);\n    }\n  return 0;\n}\n\nstatic guint\nappend_table (GString *string,\n              GHashTable *headers)\n{\n  GHashTableIter iter;\n  gpointer key;\n  gpointer value;\n  guint seen = 0;\n\n  if (headers)\n    {\n      g_hash_table_iter_init (&iter, headers);\n      while (g_hash_table_iter_next (&iter, &key, &value))\n        seen |= append_header (string, key, value);\n    }\n\n  return seen;\n}\n\nstatic guint\nappend_va (GString *string,\n           va_list va)\n{\n  const gchar *name;\n  const gchar *value;\n  guint seen = 0;\n\n  for (;;)\n    {\n      name = va_arg (va, const gchar *);\n      if (!name)\n        break;\n      value = va_arg (va, const gchar *);\n      seen |= append_header (string, name, value);\n    }\n\n  return seen;\n}\n\nstatic GBytes *\nfinish_headers (CockpitWebResponse *self,\n                GString *string,\n                gssize length,\n                gint status,\n                guint seen)\n{\n  const gchar *content_type;\n\n  /* Automatically figure out content type */\n  if ((seen & HEADER_CONTENT_TYPE) == 0 &&\n      self->full_path != NULL && status >= 200 && status <= 299)\n    {\n      content_type = cockpit_web_response_content_type (self->full_path);\n      if (content_type)\n        g_string_append_printf (string, \"Content-Type: %s\\r\\n\", content_type);\n    }\n\n  if (status != 304)\n    {\n      if (length < 0 || seen & HEADER_CONTENT_ENCODING || self->filters)\n        {\n          self->chunked = TRUE;\n          g_string_append_printf (string, \"Transfer-Encoding: chunked\\r\\n\");\n        }\n      else\n        {\n          self->chunked = FALSE;\n          g_string_append_printf (string, \"Content-Length: %\" G_GSSIZE_FORMAT \"\\r\\n\", length);\n          self->out_queueable = length;\n        }\n    }\n\n  if ((seen & HEADER_CACHE_CONTROL) == 0 && status >= 200 && status <= 299)\n    {\n      if (self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_FOREVER)\n        g_string_append (string, \"Cache-Control: max-age=31556926, public\\r\\n\");\n      else if (self->cache_type == COCKPIT_WEB_RESPONSE_NO_CACHE)\n        g_string_append (string, \"Cache-Control: no-cache, no-store\\r\\n\");\n      else if (self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE)\n        g_string_append (string, \"Cache-Control: max-age=86400, private\\r\\n\");\n    }\n\n  if ((seen & HEADER_VARY) == 0 && status >= 200 && status <= 299 &&\n      self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE)\n    {\n      g_string_append (string, \"Vary: Cookie\\r\\n\");\n    }\n\n  if (!self->keep_alive)\n    g_string_append (string, \"Connection: close\\r\\n\");\n\n  /* Some blanket security headers */\n  if ((seen & HEADER_DNS_PREFETCH_CONTROL) == 0)\n    g_string_append (string, \"X-DNS-Prefetch-Control: off\\r\\n\");\n  if ((seen & HEADER_REFERRER_POLICY) == 0)\n    g_string_append (string, \"Referrer-Policy: no-referrer\\r\\n\");\n  if ((seen & HEADER_CONTENT_TYPE_OPTIONS) == 0)\n    g_string_append (string, \"X-Content-Type-Options: nosniff\\r\\n\");\n  /* Be very strict here -- there is no reason that external web sites should\n   * be able to read any resource. This does *not* affect embedding with <iframe> */\n  if ((seen & HEADER_CROSS_ORIGIN_RESOURCE_POLICY) == 0)\n    g_string_append (string, \"Cross-Origin-Resource-Policy: same-origin\\r\\n\");\n\n  g_string_append (string, \"\\r\\n\");\n  return g_string_free_to_bytes (string);\n}\n\n/**\n * cockpit_web_response_set_cache_type:\n * @self: the response\n * @cache_type: Ensures the appropriate cache headers are returned for\n   the given cache type.\n */\nvoid\ncockpit_web_response_set_cache_type (CockpitWebResponse *self,\n                                     CockpitCacheType cache_type)\n{\n  self->cache_type = cache_type;\n}\n\n/**\n * cockpit_web_response_headers:\n * @self: the response\n * @status: the HTTP status code\n * @reason: the HTTP reason\n * @length: the combined length of data blocks to follow, or -1\n *\n * See cockpit_web_response_content() for an easy to use function.\n *\n * Queue the headers of the response. No data blocks must yet be\n * queued on the response.\n *\n * Specify header name/value pairs in the var args, and end with\n * a NULL name. If value is NULL, then that header won't be sent.\n *\n * Don't specify Content-Length or Connection headers.\n *\n * If @length is zero or greater, then it must represent the\n * number of queued blocks to follow.\n */\nvoid\ncockpit_web_response_headers (CockpitWebResponse *self,\n                              guint status,\n                              const gchar *reason,\n                              gssize length,\n                              ...)\n{\n  GString *string;\n  GBytes *block;\n  va_list va;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n\n  if (self->count > 0)\n    {\n      g_critical (\"Headers should be sent first. This is a programmer error.\");\n      return;\n    }\n\n  string = begin_headers (self, status, reason);\n\n  va_start (va, length);\n  block = finish_headers (self, string, length, status,\n                          append_va (string, va));\n  va_end (va);\n\n  queue_bytes (self, block);\n  g_bytes_unref (block);\n}\n\n/**\n * cockpit_web_response_headers:\n * @self: the response\n * @status: the HTTP status code\n * @reason: the HTTP reason\n * @length: the combined length of data blocks to follow, or -1\n * @headers: headers to include or NULL\n *\n * See cockpit_web_response_content() for an easy to use function.\n *\n * Queue the headers of the response. No data blocks must yet be\n * queued on the response.\n *\n * Don't put Content-Length or Connection in @headers.\n *\n * If @length is zero or greater, then it must represent the\n * number of queued blocks to follow.\n */\nvoid\ncockpit_web_response_headers_full  (CockpitWebResponse *self,\n                                    guint status,\n                                    const gchar *reason,\n                                    gssize length,\n                                    GHashTable *headers)\n{\n  GString *string;\n  GBytes *block;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n\n  if (self->count > 0)\n    {\n      g_critical (\"Headers should be sent first. This is a programmer error.\");\n      return;\n    }\n\n  string = begin_headers (self, status, reason);\n\n  block = finish_headers (self, string, length, status,\n                          append_table (string, headers));\n\n  queue_bytes (self, block);\n  g_bytes_unref (block);\n}\n\n/**\n * cockpit_web_response_content:\n * @self: the response\n * @headers: headers to include or NULL\n * @block: first block to send\n *\n * This is a simple way to send an HTTP response as a single\n * call. The response will be complete after this call, and will\n * send in the main-loop.\n *\n * The var args are additional GBytes* blocks to send, followed by\n * a trailing NULL.\n *\n * Don't include Content-Length or Connection in @headers.\n *\n * This calls cockpit_web_response_headers_full(),\n * cockpit_web_response_queue() and cockpit_web_response_complete()\n * internally.\n */\nvoid\ncockpit_web_response_content (CockpitWebResponse *self,\n                              GHashTable *headers,\n                              GBytes *block,\n                              ...)\n{\n  GBytes *first;\n  gsize length = 0;\n  va_list va;\n  va_list va2;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n\n  first = block;\n  va_start (va, block);\n  va_copy (va2, va);\n\n  while (block)\n    {\n      length += g_bytes_get_size (block);\n      block = va_arg (va, GBytes *);\n    }\n  va_end (va);\n\n  cockpit_web_response_headers_full (self, 200, \"OK\", length, headers);\n\n  block = first;\n  for (;;)\n    {\n      if (!block)\n        {\n          cockpit_web_response_complete (self);\n          break;\n        }\n      if (!cockpit_web_response_queue (self, block))\n        break;\n      block = va_arg (va2, GBytes *);\n    }\n  va_end (va2);\n}\n\nstatic GBytes *\nsubstitute_message (const gchar *variable,\n                    gpointer user_data)\n{\n  const gchar *message = user_data;\n  if (g_str_equal (variable, \"message\"))\n    return g_bytes_new (message, strlen (message));\n  return NULL;\n}\n\nstatic GBytes *\nsubstitute_hash_value (const gchar *variable,\n                       gpointer user_data)\n{\n  GHashTable *data = user_data;\n  gchar *value = g_hash_table_lookup (data, variable);\n  if (value)\n    return g_bytes_new (value, strlen (value));\n  return g_bytes_new (\"\", 0);\n}\n\n/**\n * cockpit_web_response_error:\n * @self: the response\n * @status: the HTTP status code\n * @headers: headers to include or NULL\n * @format: printf format of error message\n *\n * Send an error message with a basic HTML page containing\n * the error.\n */\nvoid\ncockpit_web_response_error (CockpitWebResponse *self,\n                            guint code,\n                            GHashTable *headers,\n                            const gchar *format,\n                            ...)\n{\n  va_list var_args;\n  gchar *reason = NULL;\n  gchar *escaped = NULL;\n  const gchar *message;\n  GBytes *input = NULL;\n  GList *output, *l;\n  GError *error = NULL;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n\n  if (format)\n    {\n      va_start (var_args, format);\n      reason = g_strdup_vprintf (format, var_args);\n      va_end (var_args);\n      message = reason;\n    }\n  else\n    {\n      switch (code)\n        {\n        case 400:\n          message = \"Bad request\";\n          break;\n        case 401:\n          message = \"Not Authorized\";\n          break;\n        case 403:\n          message = \"Forbidden\";\n          break;\n        case 404:\n          message = \"Not Found\";\n          break;\n        case 405:\n          message = \"Method Not Allowed\";\n          break;\n        case 413:\n          message = \"Request Entity Too Large\";\n          break;\n        case 502:\n          message = \"Remote Page is Unavailable\";\n          break;\n        case 500:\n          message = \"Internal Server Error\";\n          break;\n        default:\n          if (code < 100)\n            reason = g_strdup_printf (\"%u Continue\", code);\n          else if (code < 200)\n            reason = g_strdup_printf (\"%u OK\", code);\n          else if (code < 300)\n            reason = g_strdup_printf (\"%u Moved\", code);\n          else\n            reason = g_strdup_printf (\"%u Failed\", code);\n          message = reason;\n          break;\n        }\n    }\n\n  g_debug (\"%s: returning error: %u %s\", self->logname, code, message);\n\n  if (cockpit_web_failure_resource)\n    {\n      input = g_resources_lookup_data (cockpit_web_failure_resource, G_RESOURCE_LOOKUP_FLAGS_NONE, &error);\n      if (input == NULL)\n        {\n          g_critical (\"couldn't load: %s: %s\", cockpit_web_failure_resource, error->message);\n          g_error_free (error);\n        }\n    }\n\n  if (!input)\n    input = g_bytes_new_static (default_failure_template, strlen (default_failure_template));\n  output = cockpit_template_expand (input, \"@@\", \"@@\", substitute_message, (gpointer) message);\n  g_bytes_unref (input);\n\n  /* If sending arbitrary messages, make sure they're escaped */\n  if (reason)\n    {\n      g_strstrip (reason);\n      escaped = g_uri_escape_string (reason, \" :\", FALSE);\n      message = escaped;\n    }\n\n  if (headers)\n    {\n      if (!g_hash_table_lookup (headers, \"Content-Type\"))\n        g_hash_table_replace (headers, g_strdup (\"Content-Type\"), g_strdup (\"text/html; charset=utf8\"));\n      cockpit_web_response_headers_full (self, code, message, -1, headers);\n    }\n  else\n    {\n      cockpit_web_response_headers (self, code, message, -1, \"Content-Type\", \"text/html; charset=utf8\", NULL);\n    }\n\n  for (l = output; l != NULL; l = g_list_next (l))\n    {\n      if (!cockpit_web_response_queue (self, l->data))\n        break;\n    }\n  if (l == NULL)\n    cockpit_web_response_complete (self);\n  g_list_free_full (output, (GDestroyNotify)g_bytes_unref);\n\n  g_free (reason);\n  g_free (escaped);\n}\n\n/**\n * cockpit_web_response_error:\n * @self: the response\n * @headers: headers to include or NULL\n * @error: the error\n *\n * Send an error message with a basic HTML page containing\n * the error.\n */\nvoid\ncockpit_web_response_gerror (CockpitWebResponse *self,\n                             GHashTable *headers,\n                             GError *error)\n{\n  int code;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n\n  if (g_error_matches (error,\n                       COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED))\n    code = 401;\n  else if (g_error_matches (error,\n                       COCKPIT_ERROR, COCKPIT_ERROR_PERMISSION_DENIED))\n    code = 403;\n  else if (g_error_matches (error,\n                            G_IO_ERROR, G_IO_ERROR_INVALID_DATA))\n    code = 400;\n  else if (g_error_matches (error,\n                            G_IO_ERROR, G_IO_ERROR_NO_SPACE))\n    code = 413;\n  else\n    code = 500;\n\n  cockpit_web_response_error (self, code, headers, \"%s\", error->message);\n}\n\nstatic gboolean\npath_has_prefix (const gchar *path,\n                 const gchar *prefix)\n{\n  gsize len;\n  if (prefix == NULL)\n    return FALSE;\n  len = strlen (prefix);\n  if (len == 0)\n    return FALSE;\n  if (!g_str_has_prefix (path, prefix))\n    return FALSE;\n  if (prefix[len - 1] == '/' ||\n      path[len] == '/')\n    return TRUE;\n  return FALSE;\n}\n\ngchar **\ncockpit_web_response_resolve_roots (const gchar **input)\n{\n  GPtrArray *roots;\n  char *path;\n  gint i;\n\n  roots = g_ptr_array_new ();\n  for (i = 0; input && input[i]; i++)\n    {\n      path = realpath (input[i], NULL);\n      if (path == NULL)\n        g_debug (\"couldn't resolve document root: %s: %m\", input[i]);\n      else\n        g_ptr_array_add (roots, path);\n    }\n  g_ptr_array_add (roots, NULL);\n  return (gchar **)g_ptr_array_free (roots, FALSE);\n}\n\nstatic void\nweb_response_file (CockpitWebResponse *response,\n                   const gchar *escaped,\n                   const gchar **roots,\n                   CockpitTemplateFunc template_func,\n                   gpointer user_data)\n{\n  const gchar *default_policy = \"default-src 'self' 'unsafe-inline';\";\n\n  const gchar *headers[5] = { NULL };\n  GError *error = NULL;\n  gchar *unescaped = NULL;\n  gchar *path = NULL;\n  gchar *alloc = NULL;\n  GMappedFile *file = NULL;\n  const gchar *root;\n  GBytes *body;\n  GList *output = NULL;\n  GList *l = NULL;\n  gint content_length = -1;\n  gint at = 0;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (response));\n\n  if (!escaped)\n    escaped = cockpit_web_response_get_path (response);\n\n  g_return_if_fail (escaped != NULL);\n\n  /* Someone is trying to escape the root directory, or access hidden files? */\n  unescaped = g_uri_unescape_string (escaped, \"/\");\n  if (!unescaped || strstr (unescaped, \"/.\") || strstr (unescaped, \"../\") || strstr (unescaped, \"//\"))\n    {\n      g_debug (\"%s: invalid path request\", escaped);\n      cockpit_web_response_error (response, 404, NULL, \"Not Found\");\n      goto out;\n    }\n\nagain:\n  root = *(roots++);\n  if (root == NULL)\n    {\n      cockpit_web_response_error (response, 404, NULL, \"Not Found\");\n      goto out;\n    }\n\n  g_free (path);\n  path = g_build_filename (root, unescaped, NULL);\n\n  if (g_file_test (path, G_FILE_TEST_IS_DIR))\n    {\n      cockpit_web_response_error (response, 403, NULL, \"Directory Listing Denied\");\n      goto out;\n    }\n\n  /* As a double check of above behavior */\n  g_assert (path_has_prefix (path, root));\n\n  g_clear_error (&error);\n  file = g_mapped_file_new (path, FALSE, &error);\n  if (file == NULL)\n    {\n      if (g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT) ||\n          g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NAMETOOLONG))\n        {\n          g_debug (\"%s: file not found in root: %s\", escaped, root);\n          goto again;\n        }\n      else if (g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_PERM) ||\n               g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_ACCES) ||\n               g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_ISDIR))\n        {\n          cockpit_web_response_error (response, 403, NULL, \"Access denied\");\n          goto out;\n        }\n      else\n        {\n          g_warning (\"%s: %s\", path, error->message);\n          cockpit_web_response_error (response, 500, NULL, \"Internal server error\");\n          goto out;\n        }\n    }\n\n  body = g_mapped_file_get_bytes (file);\n  if (template_func)\n    {\n      output = cockpit_template_expand (body, \"${\", \"}\", template_func, user_data);\n    }\n  else\n    {\n      output = g_list_prepend (output, g_bytes_ref (body));\n      content_length = g_bytes_get_size (body);\n    }\n  g_bytes_unref (body);\n\n  if (response->origin)\n    {\n      headers[at++] = \"Access-Control-Allow-Origin\";\n      headers[at++] = response->origin;\n    }\n\n  /*\n   * The default Content-Security-Policy for .html files allows\n   * the site to have inline <script> and <style> tags. This code\n   * is only used for static resources that do not use the session.\n   */\n  if (g_str_has_suffix (unescaped, \".html\"))\n    {\n      headers[at++] = \"Content-Security-Policy\";\n      headers[at++] = alloc = cockpit_web_response_security_policy (default_policy, response->origin);\n    }\n\n  cockpit_web_response_headers (response, 200, \"OK\", content_length,\n                                headers[0], headers[1], headers[2], headers[3], NULL);\n\n  for (l = output; l != NULL; l = g_list_next (l))\n    {\n      if (!cockpit_web_response_queue (response, l->data))\n        break;\n    }\n  if (l == NULL)\n    cockpit_web_response_complete (response);\n\nout:\n  g_free (alloc);\n  g_free (unescaped);\n  g_clear_error (&error);\n  g_free (path);\n  if (file)\n    g_mapped_file_unref (file);\n\n  if (output)\n    g_list_free_full (output, (GDestroyNotify)g_bytes_unref);\n}\n\n/**\n * cockpit_web_response_file:\n * @response: the response\n * @path: escaped path, or NULL to get from response\n * @roots: directories to look for file in\n *\n * Serve a file from disk as an HTTP response.\n */\nvoid\ncockpit_web_response_file (CockpitWebResponse *response,\n                           const gchar *escaped,\n                           const gchar **roots)\n{\n  web_response_file (response, escaped, roots, NULL, NULL);\n}\n\nvoid\ncockpit_web_response_template (CockpitWebResponse *response,\n                                   const gchar *escaped,\n                                   const gchar **roots,\n                                   GHashTable *values)\n{\n  web_response_file (response, escaped, roots, substitute_hash_value, values);\n}\n\nstatic gboolean\nresponse_next_path (CockpitWebResponse *self,\n                    gchar **component)\n{\n  const gchar *beg = NULL;\n  const gchar *path;\n\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), FALSE);\n\n  path = self->path;\n\n  if (path && path[0] == '/')\n    {\n      beg = path + 1;\n      path = strchr (beg, '/');\n    }\n  else\n    {\n      path = NULL;\n    }\n\n  if (!beg || path == beg)\n    return FALSE;\n\n  self->path = path;\n\n  if (self->path)\n    {\n      if (component)\n        *component = g_strndup (beg, path - beg);\n    }\n  else if (beg && beg[0])\n    {\n      if (component)\n        *component = g_strdup (beg);\n    }\n  else\n    {\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\ngboolean\ncockpit_web_response_skip_path (CockpitWebResponse *self)\n{\n  return response_next_path (self, NULL);\n}\n\ngchar *\ncockpit_web_response_pop_path (CockpitWebResponse *self)\n{\n  gchar *component = NULL;\n  if (!response_next_path (self, &component))\n    return NULL;\n  return component;\n}\n\nvoid\ncockpit_web_response_add_filter (CockpitWebResponse *self,\n                                 CockpitWebFilter *filter)\n{\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n  g_return_if_fail (COCKPIT_IS_WEB_FILTER (filter));\n  g_return_if_fail (self->count == 0);\n  self->filters = g_list_append (self->filters, g_object_ref (filter));\n}\n\n/**\n * cockpit_web_response_gunzip:\n * @bytes: the compressed bytes\n * @error: place to put an error\n *\n * Perform gzip decompression on the @bytes.\n *\n * Returns: the uncompressed bytes, caller owns return value.\n */\nGBytes *\ncockpit_web_response_gunzip (GBytes *bytes,\n                             GError **error)\n{\n  GConverter *converter;\n  GConverterResult result;\n  const guint8 *in;\n  gsize inl, outl, read, written;\n  GByteArray *out;\n\n  converter = G_CONVERTER (g_zlib_decompressor_new (G_ZLIB_COMPRESSOR_FORMAT_GZIP));\n\n  in = g_bytes_get_data (bytes, &inl);\n  out = g_byte_array_new ();\n\n  do\n    {\n      outl = out->len;\n      g_byte_array_set_size (out, outl + inl);\n\n      result = g_converter_convert (converter, in, inl, out->data + outl, inl,\n                                    G_CONVERTER_INPUT_AT_END, &read, &written, error);\n      if (result == G_CONVERTER_ERROR)\n        break;\n\n      g_byte_array_set_size (out, outl + written);\n      in += read;\n      inl -= read;\n    }\n  while (result != G_CONVERTER_FINISHED);\n\n  g_object_unref (converter);\n\n  if (result != G_CONVERTER_FINISHED)\n    {\n      g_byte_array_unref (out);\n      return NULL;\n    }\n  else\n    {\n      return g_byte_array_free_to_bytes (out);\n    }\n}\n\nstatic const gchar *\nfind_extension (const gchar *path)\n{\n  const gchar *dot;\n  const gchar *slash;\n\n  dot = strrchr (path, '.');\n  slash = strrchr (path, '/');\n\n  /* Dots before the last slash don't count */\n  if (dot && slash && dot < slash)\n    dot = NULL;\n\n  /* Leading dots on the filename don't count */\n  if (dot && (dot == path || dot == slash + 1))\n    dot = NULL;\n\n  return dot;\n}\n\nstatic GBytes *\nload_file (const gchar *filename,\n           GError **error)\n{\n  GError *local_error = NULL;\n\n  g_autoptr(GMappedFile) mapped = g_mapped_file_new (filename, FALSE, &local_error);\n\n  if (mapped)\n    /* success! */\n    return g_mapped_file_get_bytes (mapped);\n\n  if (g_error_matches (local_error, G_FILE_ERROR, G_FILE_ERROR_NOENT) ||\n      g_error_matches (local_error, G_FILE_ERROR, G_FILE_ERROR_ISDIR) ||\n      g_error_matches (local_error, G_FILE_ERROR, G_FILE_ERROR_NAMETOOLONG) ||\n      g_error_matches (local_error, G_FILE_ERROR, G_FILE_ERROR_LOOP) ||\n      g_error_matches (local_error, G_FILE_ERROR, G_FILE_ERROR_INVAL))\n    {\n      g_clear_error (&local_error);\n    }\n\n  /* A real error to stop on */\n  else\n    {\n      g_propagate_error (error, local_error);\n    }\n\n  return NULL;\n}\n\n/**\n * cockpit_web_response_negotiation:\n * @path: likely filesystem path\n * @existing: a table of existing files\n * @chosen: out, a pointer to the suffix that was chosen\n * @error: a failure\n *\n * Find a file to serve based on the suffixes. We prune off extra\n * extensions while looking for a file that's present. We append\n * .min and .gz when looking for files. We also check for the language\n * before the extensions if set.\n *\n * The @existing may be NULL, if non-null it'll be used to check if\n * files exist.\n */\nGBytes *\ncockpit_web_response_negotiation (const gchar *path,\n                                  GHashTable *existing,\n                                  const gchar *language,\n                                  gchar **actual,\n                                  GError **error)\n{\n  gchar *base = NULL;\n  const gchar *ext;\n  gchar *dot;\n  gchar *name = NULL;\n  GBytes *bytes = NULL;\n  GError *local_error = NULL;\n  gchar *locale = NULL;\n  gchar *shorter = NULL;\n  gchar *lang = NULL;\n  gchar *lang_region = NULL;\n\n  gint i;\n\n  if (language)\n      locale = cockpit_locale_from_language (language, NULL, &shorter);\n\n  ext = find_extension (path);\n  if (ext)\n    {\n      base = g_strndup (path, ext - path);\n    }\n  else\n    {\n      ext = \"\";\n      base = g_strdup (path);\n    }\n\n  while (!bytes)\n    {\n      /* For a request for a file named \"base.ext\" and locale \"lang_REGION\", We try the following variants, in\n         order, and serve the first that is found:\n\n           base.lang_REGION.ext\n           base.lang_REGION.ext.gz\n           base.lang.ext\n           base.lang.ext.gz\n           base.ext\n           base.min.ext\n           base.ext.gz\n           base.ext.min.gz\n\n         If no locale is requested, or a locale without region, those variants are left out by starting\n         further down in the list.\n\n         If none of the variants are found, and the base of the file name has internal dots, these internal\n         extensions are dropped one by one from the right.  For example, for a file named \"foo.bar.js\", we\n         first try \"foo.bar\" with extension \".js\", and then \"foo\" with extension \".js\".\n      */\n\n      if (locale && shorter && g_strcmp0 (locale, shorter) != 0) {\n        lang = shorter;\n        lang_region = locale;\n        i = 0;\n      } else if (locale) {\n        lang = locale;\n        i = 2;\n      } else {\n        i = 4;\n      }\n\n      for (; i < 8; i++)\n        {\n          g_free (name);\n          switch (i)\n            {\n            case 0:\n              name = g_strconcat (base, \".\", lang_region, ext, NULL);\n              break;\n            case 1:\n              name = g_strconcat (base, \".\", lang_region, ext, \".gz\", NULL);\n              break;\n            case 2:\n              name = g_strconcat (base, \".\", lang, ext, NULL);\n              break;\n            case 3:\n              name = g_strconcat (base, \".\", lang, ext, \".gz\", NULL);\n              break;\n            case 4:\n              name = g_strconcat (base, ext, NULL);\n              break;\n            case 5:\n              name = g_strconcat (base, \".min\", ext, NULL);\n              break;\n            case 6:\n              name = g_strconcat (base, ext, \".gz\", NULL);\n              break;\n            case 7:\n              name = g_strconcat (base, \".min\", ext, \".gz\", NULL);\n              break;\n            default:\n              g_assert_not_reached ();\n            }\n\n          if (existing)\n            {\n              if (!g_hash_table_lookup (existing, name))\n                continue;\n            }\n\n          bytes = load_file (name, &local_error);\n          if (bytes)\n            break;\n          if (local_error)\n            goto out;\n        }\n\n      /* Pop one level off the file name */\n      dot = (gchar *)find_extension (base);\n      if (!dot)\n        break;\n\n      dot[0] = '\\0';\n    }\n\nout:\n  if (local_error)\n    g_propagate_error (error, local_error);\n  if (bytes && name && actual)\n    {\n      *actual = name;\n      name = NULL;\n    }\n  g_free (name);\n  g_free (base);\n  g_free (locale);\n  g_free (shorter);\n  return bytes;\n}\n\nconst gchar *\ncockpit_web_response_content_type (const gchar *path)\n{\n  static const struct {\n    const gchar *extension;\n    const gchar *content_type;\n  } content_types[] = {\n    { \".css\", \"text/css\" },\n    { \".gif\", \"image/gif\" },\n    { \".eot\", \"application/vnd.ms-fontobject\" },\n    { \".html\", \"text/html\" },\n    /* { \".ico\", \"image/vnd.microsoft.icon\" }, */\n    { \".jpg\", \"image/jpg\" },\n    { \".js\", \"application/javascript\" },\n    { \".json\", \"application/json\" },\n    { \".otf\", \"font/opentype\" },\n    { \".png\", \"image/png\" },\n    { \".svg\", \"image/svg+xml\" },\n    { \".ttf\", \"application/octet-stream\" }, /* unassigned */\n    { \".txt\", \"text/plain\" },\n    { \".wasm\", \"application/wasm\" },\n    { \".woff\", \"application/font-woff\" },\n    { \".xml\", \"text/xml\" },\n  };\n\n  gint i;\n\n  for (i = 0; i < G_N_ELEMENTS (content_types); i++)\n    {\n      if (g_str_has_suffix (path, content_types[i].extension))\n          return content_types[i].content_type;\n    }\n\n  return NULL;\n}\n\nstatic gboolean\nstrv_have_prefix (gchar **strv,\n                  const gchar *prefix)\n{\n  gint i;\n\n  for (i = 0; strv && strv[i] != NULL; i++)\n    {\n      if (g_str_has_prefix (strv[i], prefix))\n        return TRUE;\n    }\n  return FALSE;\n}\n\nstatic void\nstring_inject_origin (GString *string,\n                      const gchar *origin)\n{\n  const gchar *found;\n  gsize pos = 0;\n\n  for (;;)\n    {\n      found = strstr (string->str + pos, \"'self'\");\n      if (!found)\n        break;\n\n      pos = (found - string->str) + 6;\n      g_string_insert (string, pos, \" \");\n      g_string_insert (string, pos + 1, origin);\n      pos += strlen (origin) + 1;\n    }\n}\n\n/**\n * cockpit_web_response_content_security_policy:\n * @content_security_policy: the raw security policy or %NULL for a default\n * @self_origin: our own web origin or %NULL\n *\n * Calculates the security policy.\n *\n * Returns: A calculated security policy, filled with defaults if necessary.\n */\ngchar *\ncockpit_web_response_security_policy (const gchar *content_security_policy,\n                                      const gchar *self_origin)\n{\n  const gchar *default_src = \"default-src 'self'\";\n  const gchar *form_action = \"form-action 'self'\";\n  const gchar *base_uri = \"base-uri 'self'\";\n  const gchar *object_src = \"object-src 'none'\";\n  const gchar *font_src = \"font-src 'self' data:\";\n  const gchar *img_src = \"img-src 'self' data:\";\n  const gchar *block_all_mixed_content = \"block-all-mixed-content\";\n  gchar **parts = NULL;\n  GString *result;\n  gint i;\n\n  result = g_string_sized_new (128);\n\n  /*\n   * Note that browsers need to be explicitly told they can connect\n   * to a WebSocket. This is non-obvious, but it stems from the fact\n   * that some browsers treat 'https' and 'wss' as different protocols.\n   *\n   * Since each component could establish a WebSocket connection back to\n   * cockpit-ws, we need to insert that into the policy.\n   */\n\n  if (content_security_policy)\n    parts = g_strsplit (content_security_policy, \";\", -1);\n\n  for (i = 0; parts && parts[i] != NULL; i++)\n    g_strstrip (parts[i]);\n\n  if (!strv_have_prefix (parts, \"default-src \"))\n    g_string_append_printf (result, \"%s; \", default_src);\n  if (!strv_have_prefix (parts, \"connect-src \"))\n    {\n      g_string_append (result, \"connect-src 'self'\");\n      if (self_origin && g_str_has_prefix (self_origin, \"http\"))\n        g_string_append_printf (result, \" ws%s\", self_origin + 4);\n      g_string_append (result, \"; \");\n    }\n  if (!strv_have_prefix (parts, \"form-action \"))\n    g_string_append_printf (result, \"%s; \", form_action);\n  if (!strv_have_prefix (parts, \"base-uri \"))\n    g_string_append_printf (result, \"%s; \", base_uri);\n  if (!strv_have_prefix (parts, \"object-src \"))\n    g_string_append_printf (result, \"%s; \", object_src);\n  if (!strv_have_prefix (parts, \"font-src \"))\n    g_string_append_printf (result, \"%s; \", font_src);\n  if (!strv_have_prefix (parts, \"img-src \"))\n    g_string_append_printf (result, \"%s; \", img_src);\n  if (!strv_have_prefix (parts, \"block-all-mixed-content\"))\n    g_string_append_printf (result, \"%s; \", block_all_mixed_content);\n\n  for (i = 0; parts && parts[i] != NULL; i++)\n    g_string_append_printf (result, \"%s; \", parts[i]);\n\n  g_strfreev (parts);\n\n  /* Remove trailing semicolon */\n  g_string_set_size (result, result->len - 2);\n\n  /* Put in our own origin */\n  if (self_origin)\n    string_inject_origin (result, self_origin);\n\n  return g_string_free (result, FALSE);\n}\n\nconst gchar *\ncockpit_web_response_get_origin (CockpitWebResponse *self)\n{\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), NULL);\n  return self->origin;\n}\n\nconst gchar *\ncockpit_web_response_get_protocol (CockpitWebResponse *self,\n                                   GHashTable *headers)\n{\n  return cockpit_connection_get_protocol (self->io, headers, self->flags & COCKPIT_WEB_RESPONSE_FOR_TLS_PROXY);\n}\n\nstatic void\ncockpit_web_response_flow_iface_init (CockpitFlowInterface *iface)\n{\n  /* No implementation */\n}\n\nconst gchar *\ncockpit_connection_get_protocol (GIOStream *connection,\n                                 GHashTable *headers,\n                                 gboolean for_tls_proxy)\n{\n  const gchar *protocol = NULL;\n  const gchar *protocol_header;\n\n  if (connection && G_IS_TLS_CONNECTION (connection))\n    {\n      protocol = \"https\";\n    }\n  else\n    {\n      protocol_header = cockpit_conf_string (\"WebService\", \"ProtocolHeader\");\n      if (protocol_header && headers)\n         protocol = g_hash_table_lookup (headers, protocol_header);\n    }\n\n  return protocol ?: (for_tls_proxy ? \"https\" : \"http\");\n}\n", "/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2014 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include \"cockpitwebinject.h\"\n#include \"cockpitwebresponse.h\"\n#include \"cockpitwebserver.h\"\n\n#include \"mock-io-stream.h\"\n\n#include \"common/cockpittest.h\"\n\n#include \"websocket/websocket.h\"\n\n#include <glib/gstdio.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n/* headers that are present in every request */\n#define STATIC_HEADERS \"X-DNS-Prefetch-Control: off\\r\\nReferrer-Policy: no-referrer\\r\\nX-Content-Type-Options: nosniff\\r\\nCross-Origin-Resource-Policy: same-origin\\r\\n\\r\\n\"\nstatic gchar *srcdir;\n\ntypedef struct {\n    CockpitWebResponse *response;\n    GOutputStream *output;\n    gchar *scratch;\n    gboolean response_done;\n    gulong sig_done;\n} TestCase;\n\ntypedef struct {\n    const gchar *path;\n    const gchar *header;\n    const gchar *value;\n    const gchar *expected_content_type;\n    CockpitCacheType cache;\n    gboolean for_tls_proxy;\n} TestFixture;\n\nstatic void\non_response_done (CockpitWebResponse *response,\n                  gboolean reusable,\n                  gpointer user_data)\n{\n  gboolean *response_done = user_data;\n  g_assert (response_done != NULL);\n  g_assert (*response_done == FALSE);\n  *response_done = TRUE;\n}\n\nstatic void\nsetup (TestCase *tc,\n       gconstpointer data)\n{\n  const TestFixture *fixture = data;\n  const gchar *path = NULL;\n  GHashTable *headers = NULL;\n  GInputStream *input;\n  GIOStream *io;\n\n  if (fixture)\n    path = fixture->path;\n\n  input = g_memory_input_stream_new ();\n  tc->output = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);\n  io = mock_io_stream_new (input, tc->output);\n  g_object_unref (input);\n\n  if (fixture && fixture->header)\n    {\n      headers = cockpit_web_server_new_table ();\n      g_hash_table_insert (headers, g_strdup (fixture->header), g_strdup (fixture->value));\n    }\n\n  tc->response = cockpit_web_response_new (io, path, path, NULL, headers,\n                                           (fixture && fixture->for_tls_proxy) ? COCKPIT_WEB_RESPONSE_FOR_TLS_PROXY : COCKPIT_WEB_RESPONSE_NONE);\n\n  if (headers)\n    g_hash_table_unref (headers);\n  g_object_unref (io);\n\n  tc->sig_done = g_signal_connect (tc->response, \"done\",\n                                   G_CALLBACK (on_response_done),\n                                   &tc->response_done);\n}\n\nstatic void\nteardown (TestCase *tc,\n          gconstpointer data)\n{\n  while (g_main_context_iteration (NULL, FALSE));\n  g_assert (tc->response_done);\n\n  g_signal_handler_disconnect (tc->response, tc->sig_done);\n  g_clear_object (&tc->output);\n  g_clear_object (&tc->response);\n  g_free (tc->scratch);\n}\n\nstatic const gchar *\noutput_as_string (TestCase *tc)\n{\n  while (!tc->response_done)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_free (tc->scratch);\n  tc->scratch = g_strndup (g_memory_output_stream_get_data (G_MEMORY_OUTPUT_STREAM (tc->output)),\n                           g_memory_output_stream_get_data_size (G_MEMORY_OUTPUT_STREAM (tc->output)));\n  return tc->scratch;\n}\n\nstatic void\ntest_return_content (TestCase *tc,\n                     gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  content = g_bytes_new_static (\"the content\", 11);\n  cockpit_web_response_content (tc->response, NULL, content, NULL);\n  g_bytes_unref (content);\n\n  resp = output_as_string (tc);\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Length: 11\\r\\n\" STATIC_HEADERS \"the content\");\n}\n\nstatic void\ntest_return_content_headers (TestCase *tc,\n                             gconstpointer data)\n{\n  const gchar *resp;\n  GHashTable *headers;\n  GBytes *content;\n\n  headers = cockpit_web_server_new_table ();\n  g_hash_table_insert (headers, g_strdup (\"My-header\"), g_strdup (\"my-value\"));\n\n  content = g_bytes_new_static (\"the content\", 11);\n  cockpit_web_response_content (tc->response, headers, content, NULL);\n  g_bytes_unref (content);\n  g_hash_table_destroy (headers);\n\n  resp = output_as_string (tc);\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nMy-header: my-value\\r\\nContent-Length: 11\\r\\n\" STATIC_HEADERS \"the content\");\n}\n\n\nstatic void\ntest_return_error (TestCase *tc,\n                   gconstpointer data)\n{\n  const gchar *resp;\n\n  cockpit_expect_message (\"Returning error-response 500*\");\n\n  cockpit_web_response_error (tc->response, 500, NULL, \"Reason here: %s\", \"booyah\");\n\n  resp = output_as_string (tc);\n  g_assert_cmpstr (resp, ==,\n    \"HTTP/1.1 500 Reason here: booyah\\r\\n\"\n    \"Content-Type: text/html; charset=utf8\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    STATIC_HEADERS\n    \"13\\r\\n<html><head><title>\\r\\n\"\n    \"13\\r\\nReason here: booyah\\r\\n\"\n    \"15\\r\\n</title></head><body>\\r\\n\"\n    \"13\\r\\nReason here: booyah\\r\\n\"\n    \"f\\r\\n</body></html>\\n\\r\\n\"\n    \"0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_return_error_headers (TestCase *tc,\n                           gconstpointer data)\n{\n  const gchar *resp;\n  GHashTable *headers;\n\n  cockpit_expect_message (\"Returning error-response 500*\");\n\n  headers = cockpit_web_server_new_table ();\n  g_hash_table_insert (headers, g_strdup (\"Header1\"), g_strdup (\"value1\"));\n\n  cockpit_web_response_error (tc->response, 500, headers, \"Reason here: %s\", \"booyah\");\n\n  g_hash_table_destroy (headers);\n\n  resp = output_as_string (tc);\n  cockpit_assert_strmatch(resp,\"HTTP/1.1 500 Reason here: booyah\\r*\\n\"\n    \"Header1: value1\\r*\\n\"\n    \"\\r\\n\");\n}\n\nstatic void\ntest_return_gerror_headers (TestCase *tc,\n                            gconstpointer data)\n{\n  const gchar *resp;\n  GHashTable *headers;\n  GError *error;\n\n  cockpit_expect_message (\"Returning error-response 500*\");\n\n  headers = cockpit_web_server_new_table ();\n  g_hash_table_insert (headers, g_strdup (\"Header1\"), g_strdup (\"value1\"));\n\n  error = g_error_new (G_IO_ERROR, G_IO_ERROR_FAILED, \"Reason here: %s\", \"booyah\");\n  cockpit_web_response_gerror (tc->response, headers, error);\n\n  g_error_free (error);\n  g_hash_table_destroy (headers);\n\n  resp = output_as_string (tc);\n  cockpit_assert_strmatch(resp,\"HTTP/1.1 500 Reason here: booyah\\r*\\n\"\n    \"Header1: value1\\r*\\n\"\n    \"\\r\\n\");\n}\n\nstatic void\ntest_return_error_resource (TestCase *tc,\n                            gconstpointer user_data)\n{\n  const gchar *roots[] = { srcdir, NULL };\n  cockpit_web_failure_resource = \"/org/cockpit-project/Cockpit/fail.html\";\n  cockpit_web_response_file (tc->response, \"/non-existent\", roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 404 Not Found*<img*Not Found*\");\n  cockpit_web_failure_resource = NULL;\n}\n\nstatic void\ntest_file_not_found (TestCase *tc,\n                     gconstpointer user_data)\n{\n  const gchar *roots[] = { srcdir, NULL };\n  cockpit_web_response_file (tc->response, \"/non-existent\", roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 404 Not Found*\");\n}\n\nstatic void\ntest_file_directory_denied (TestCase *tc,\n                            gconstpointer user_data)\n{\n  const gchar *roots[] = { srcdir, NULL };\n  cockpit_web_response_file (tc->response, \"/src\", roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 403 Directory Listing Denied*\");\n}\n\nstatic void\ntest_file_access_denied (TestCase *tc,\n                         gconstpointer user_data)\n{\n  const gchar *roots[] = { \"/tmp\", NULL };\n  gchar templ[] = \"/tmp/test-temp.XXXXXX\";\n\n  if (!g_mkdtemp_full (templ, 0000))\n    g_assert_not_reached ();\n\n  cockpit_web_response_file (tc->response, templ + 4, roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 403*\");\n\n  g_unlink (templ);\n}\n\nstatic void\ntest_file_breakout_denied (TestCase *tc,\n                           gconstpointer user_data)\n{\n  gchar *root = realpath ( SRCDIR \"/src\", NULL);\n  const gchar *roots[] = { root, NULL };\n  const gchar *breakout = \"/../Makefile.am\";\n  gchar *check = g_build_filename (roots[0], breakout, NULL);\n  g_assert (root);\n  g_assert (g_file_test (check, G_FILE_TEST_EXISTS));\n  g_free (check);\n  cockpit_web_response_file (tc->response, breakout, roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 404*\");\n  free (root);\n}\n\nstatic void\ntest_file_encoding_denied (TestCase *tc,\n                           gconstpointer user_data)\n{\n  gchar *root = realpath ( SRCDIR \"/src\", NULL);\n  const gchar *roots[] = { root, NULL };\n  const gchar *breakout = \"/common/Makefile-common.am%00\";\n  gchar *check = g_build_filename (roots[0], \"common\", \"Makefile-common.am\", NULL);\n  g_assert (root);\n  g_assert (g_file_test (check, G_FILE_TEST_EXISTS));\n  g_free (check);\n  cockpit_web_response_file (tc->response, breakout, roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 404*\");\n  free (root);\n}\n\nstatic void\ntest_file_slash_denied (TestCase *tc,\n                        gconstpointer user_data)\n{\n  gchar *root = realpath ( SRCDIR \"/src\", NULL);\n  const gchar *roots[] = { root, NULL };\n  const gchar *breakout = \"/common%2fMakefile-common.am\";\n  gchar *check = g_build_filename (roots[0], \"common\", \"Makefile-common.am\", NULL);\n  g_assert (root);\n  g_assert (g_file_test (check, G_FILE_TEST_EXISTS));\n  g_free (check);\n  cockpit_web_response_file (tc->response, breakout, roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 404*\");\n  free (root);\n}\n\nstatic void\ntest_file_breakout_non_existant (TestCase *tc,\n                                 gconstpointer user_data)\n{\n  gchar *root = realpath ( SRCDIR \"/src\", NULL);\n  const gchar *roots[] = { root, NULL };\n  const gchar *breakout = \"/../non-existent\";\n  gchar *check = g_build_filename (roots[0], breakout, NULL);\n  g_assert (root);\n  g_assert (!g_file_test (check, G_FILE_TEST_EXISTS));\n  g_free (check);\n  cockpit_web_response_file (tc->response, breakout, roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 404*\");\n  free (root);\n}\n\nstatic const TestFixture content_type_fixture_html = {\n  .path = \"/pkg/shell/index.html\",\n  .expected_content_type = \"text/html\",\n};\n\nstatic const TestFixture content_type_fixture_png = {\n  .path = \"/pkg/shell/images/server-small.png\",\n  .expected_content_type = \"image/png\",\n};\n\nstatic const TestFixture content_type_fixture_wasm = {\n  .path = \"/src/common/mock-content/test.wasm\",\n  .expected_content_type = \"application/wasm\",\n};\n\nstatic void\ntest_content_type (TestCase *tc,\n                   gconstpointer user_data)\n{\n  const TestFixture *fixture = user_data;\n  const gchar *roots[] = { srcdir, NULL };\n  GHashTable *headers;\n  const gchar *resp;\n  gsize length;\n  guint status;\n  gssize off;\n\n  cockpit_web_response_file (tc->response, NULL, roots);\n\n  resp = output_as_string (tc);\n  length = strlen (resp);\n\n  off = web_socket_util_parse_status_line (resp, length, NULL, &status, NULL);\n  g_assert_cmpuint (off, >, 0);\n  g_assert_cmpint (status, ==, 200);\n\n  off = web_socket_util_parse_headers (resp + off, length - off, &headers);\n  g_assert_cmpuint (off, >, 0);\n\n  g_assert_cmpstr (g_hash_table_lookup (headers, \"Content-Type\"), ==, fixture->expected_content_type);\n\n  g_hash_table_unref (headers);\n}\n\nstatic const TestFixture template_fixture = {\n  .path = \"/test.css\"\n};\n\nstatic void\ntest_template (TestCase *tc,\n               gconstpointer user_data)\n{\n  const gchar *roots[] = { SRCDIR \"/src/common/mock-content/\", NULL };\n  const gchar *resp;\n  GHashTable *data = g_hash_table_new (g_str_hash, g_str_equal);\n\n  g_hash_table_insert (data, \"NAME\", \"test\");\n  g_hash_table_insert (data, \"VARIANT\", \"VALUE\");\n  cockpit_web_response_template (tc->response, NULL, roots, data);\n\n  resp = output_as_string (tc);\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/css\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS \"17\\r\\n#brand {\\n    content: \\\"\\r\\n4\\r\\ntest\\r\\n4\\r\\n <b>\\r\\n5\\r\\nVALUE\\r\\n9\\r\\n</b>\\\";\\n}\\n\\r\\n0\\r\\n\\r\\n\");\n  g_hash_table_unref (data);\n}\n\nstatic const TestFixture cache_forever_fixture = {\n  .path = \"/pkg/shell/index.html\",\n  .cache = COCKPIT_WEB_RESPONSE_CACHE_FOREVER,\n};\n\nstatic const TestFixture cache_none_fixture = {\n  .path = \"/pkg/shell/index.html\",\n  .cache = COCKPIT_WEB_RESPONSE_NO_CACHE\n};\n\nstatic const TestFixture cache_private_fixture = {\n  .path = \"/pkg/shell/index.html\",\n  .cache = COCKPIT_WEB_RESPONSE_CACHE_PRIVATE\n};\n\nstatic const TestFixture cache_unset_fixture = {\n  .path = \"/pkg/shell/index.html\",\n  .cache = COCKPIT_WEB_RESPONSE_CACHE_UNSET\n};\n\nstatic void\ntest_cache (TestCase *tc,\n            gconstpointer user_data)\n{\n  const TestFixture *fixture = user_data;\n  const gchar *roots[] = { srcdir, NULL };\n  GHashTable *headers;\n  const gchar *resp;\n  gsize length;\n  guint status;\n  gssize off;\n\n  cockpit_web_response_set_cache_type (tc->response, fixture->cache);\n  cockpit_web_response_file (tc->response, NULL, roots);\n\n  resp = output_as_string (tc);\n  length = strlen (resp);\n\n  off = web_socket_util_parse_status_line (resp, length, NULL, &status, NULL);\n  g_assert_cmpuint (off, >, 0);\n  g_assert_cmpint (status, ==, 200);\n\n  off = web_socket_util_parse_headers (resp + off, length - off, &headers);\n  g_assert_cmpuint (off, >, 0);\n\n  if (fixture->cache == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE)\n    g_assert_cmpstr (g_hash_table_lookup (headers, \"Vary\"), ==, \"Cookie\");\n  else\n    g_assert_null (g_hash_table_lookup (headers, \"Vary\"));\n\n  if (fixture->cache == COCKPIT_WEB_RESPONSE_CACHE_FOREVER)\n    g_assert_cmpstr (g_hash_table_lookup (headers, \"Cache-Control\"), ==, \"max-age=31556926, public\");\n  else if (fixture->cache == COCKPIT_WEB_RESPONSE_NO_CACHE)\n    g_assert_cmpstr (g_hash_table_lookup (headers, \"Cache-Control\"), ==, \"no-cache, no-store\");\n  else if (fixture->cache == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE)\n    g_assert_cmpstr (g_hash_table_lookup (headers, \"Cache-Control\"), ==, \"max-age=86400, private\");\n  else\n    g_assert_null (g_hash_table_lookup (headers, \"Cache-Control\"));\n  g_hash_table_unref (headers);\n}\n\nstatic void\ntest_content_encoding (TestCase *tc,\n                       gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_READY);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", 50,\n                                \"Content-Encoding\", \"blah\",\n                                NULL);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  content = g_bytes_new_static (\"Cockpit is perfect for new sysadmins, \", 38);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  cockpit_web_response_complete (tc->response);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_COMPLETE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Encoding: blah\\r\\n\"\n                   \"Transfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"26\\r\\nCockpit is perfect for new sysadmins, \\r\\n0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_stream (TestCase *tc,\n             gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_READY);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", 11, NULL);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  content = g_bytes_new_static (\"the content\", 11);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  cockpit_web_response_complete (tc->response);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_COMPLETE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Length: 11\\r\\n\" STATIC_HEADERS \"the content\");\n}\n\nstatic void\non_pressure_set_throttle (CockpitWebResponse *response,\n                          gboolean throttle,\n                          gpointer user_data)\n{\n  gint *data = user_data;\n  g_assert (user_data != NULL);\n  *data = throttle ? 1 : 0;\n}\n\nstatic void\ntest_pressure (TestCase *tc,\n               gconstpointer data)\n{\n  GBytes *sent;\n  gint throttle = -1;\n  gint i;\n\n  g_signal_connect (tc->response, \"pressure\", G_CALLBACK (on_pressure_set_throttle), &throttle);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_READY);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", -1, NULL);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  /* Sent this a thousand times */\n  sent = g_bytes_new_take (g_strnfill (10 * 1000, '?'), 10 * 1000);\n  for (i = 0; i < 1000; i++)\n    cockpit_web_response_queue (tc->response, sent);\n  g_bytes_unref (sent);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  /*\n   * This should have put way too much in the queue, and thus\n   * emitted the back-pressure signal. This signal would normally\n   * be used by others to slow down their queueing, but in this\n   * case we just check that it was fired.\n   */\n  g_assert_cmpint (throttle, ==, 1);\n  throttle = -1;\n\n  cockpit_web_response_complete (tc->response);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_COMPLETE);\n\n  /*\n   * Now the queue is getting drained. At some point, it will be\n   * signaled that back pressure has been turned off\n   */\n  while (throttle == -1)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_assert_cmpint (throttle, ==, 0);\n\n  while (!tc->response_done)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpint (g_memory_output_stream_get_data_size (G_MEMORY_OUTPUT_STREAM (tc->output)), >, 10 * 1000 * 1000);\n}\n\nstatic void\ntest_head (TestCase *tc,\n           gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  cockpit_web_response_set_method (tc->response, \"HEAD\");\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_READY);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", 19, NULL);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  content = g_bytes_new_static (\"I shall not be seen\", 19);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  cockpit_web_response_complete (tc->response);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_COMPLETE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Length: 19\\r\\n\" STATIC_HEADERS);\n}\n\nstatic void\ntest_chunked_transfer_encoding (TestCase *tc,\n                                gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_READY);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", -1, NULL);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  content = g_bytes_new_static (\"Cockpit is perfect for new sysadmins, \", 38);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  content = g_bytes_new_static (\"allowing them to easily perform simple tasks such as storage administration, \", 77);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  content = g_bytes_new_static (\"inspecting journals and starting and stopping services.\", 55);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  cockpit_web_response_complete (tc->response);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_COMPLETE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"26\\r\\nCockpit is perfect for new sysadmins, \\r\\n\"\n                   \"4d\\r\\nallowing them to easily perform simple tasks such as storage administration, \\r\\n\"\n                   \"37\\r\\ninspecting journals and starting and stopping services.\\r\\n0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_chunked_zero_length (TestCase *tc,\n                          gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_READY);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", -1, NULL);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  content = g_bytes_new_static (\"Cockpit is perfect for new sysadmins, \", 38);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  content = g_bytes_new_static (\"\", 0);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  content = g_bytes_new_static (\"inspecting journals and starting and stopping services.\", 55);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  content = g_bytes_new_static (\"\", 0);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n  cockpit_web_response_complete (tc->response);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_COMPLETE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"26\\r\\nCockpit is perfect for new sysadmins, \\r\\n\"\n                   \"37\\r\\ninspecting journals and starting and stopping services.\\r\\n0\\r\\n\\r\\n\");\n}\n\nstatic GBytes *\nbytes_static (const gchar *data)\n{\n  return g_bytes_new_static (data, strlen (data));\n}\n\nstatic void\ntest_web_filter_simple (TestCase *tc,\n                        gconstpointer data)\n{\n  CockpitWebFilter *filter;\n  const gchar *resp;\n  GBytes *content;\n  GBytes *inject;\n\n  inject = bytes_static (\"<meta inject>\");\n  filter = cockpit_web_inject_new (\"<head>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  content = bytes_static (\"<html><head><title>The Title</title></head></html>\");\n  cockpit_web_response_content (tc->response, NULL, content, NULL);\n  g_bytes_unref (content);\n\n  while (cockpit_web_response_get_state (tc->response) != COCKPIT_WEB_RESPONSE_COMPLETE)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"c\\r\\n<html><head>\\r\\n\"\n                   \"d\\r\\n<meta inject>\\r\\n\"\n                   \"26\\r\\n<title>The Title</title></head></html>\\r\\n\"\n                   \"0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_web_filter_multiple (TestCase *tc,\n                          gconstpointer data)\n{\n  CockpitWebFilter *filter;\n  const gchar *resp;\n  GBytes *content;\n  GBytes *inject;\n\n  inject = bytes_static (\"<meta inject>\");\n  filter = cockpit_web_inject_new (\"<head>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  inject = bytes_static (\"<body>Body</body>\");\n  filter = cockpit_web_inject_new (\"</head>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  inject = bytes_static (\"Prefix \");\n  filter = cockpit_web_inject_new (\"<title>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  inject = bytes_static (\" \");\n  filter = cockpit_web_inject_new (\">\", inject, 3);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  content = bytes_static (\"<html><head><title>The Title</title></head></html>\");\n  cockpit_web_response_content (tc->response, NULL, content, NULL);\n  g_bytes_unref (content);\n\n  while (cockpit_web_response_get_state (tc->response) != COCKPIT_WEB_RESPONSE_COMPLETE)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"6\\r\\n<html>\\r\\n\"\n                   \"1\\r\\n \\r\\n\"\n                   \"6\\r\\n<head>\\r\\n\"\n                   \"1\\r\\n \\r\\n\"\n                   \"d\\r\\n<meta inject>\\r\\n\"\n                   \"1\\r\\n \\r\\n\"\n                   \"7\\r\\n<title>\\r\\n\"\n                   \"7\\r\\nPrefix \\r\\n\"\n                   \"18\\r\\nThe Title</title></head>\\r\\n\"\n                   \"11\\r\\n<body>Body</body>\\r\\n\"\n                   \"7\\r\\n</html>\\r\\n\"\n                   \"0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_web_filter_split (TestCase *tc,\n                       gconstpointer data)\n{\n  CockpitWebFilter *filter;\n  const gchar *string;\n  const gchar *resp;\n  GBytes *inject;\n  GBytes *block;\n  gsize i, x, len;\n\n  inject = bytes_static (\"<meta inject>\");\n  filter = cockpit_web_inject_new (\"<head>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  inject = bytes_static (\"<body>Body</body>\");\n  filter = cockpit_web_inject_new (\"</head>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  inject = bytes_static (\"Prefix \");\n  filter = cockpit_web_inject_new (\"<title>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", -1, NULL);\n\n  string = \"<html><head><title>The Title</title></head></html>\";\n  len = strlen (string);\n\n  for (i = 0, x = 1; i < len; i += x, x = 1 + (i % 4))\n    {\n      block = g_bytes_new_static (string + i, MIN (x, strlen (string + i)));\n      g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n      g_bytes_unref (block);\n    }\n\n  cockpit_web_response_complete (tc->response);\n\n  while (cockpit_web_response_get_state (tc->response) != COCKPIT_WEB_RESPONSE_COMPLETE)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"1\\r\\n<\\r\\n\"\n                   \"2\\r\\nht\\r\\n\"\n                   \"4\\r\\nml><\\r\\n\"\n                   \"4\\r\\nhead\\r\\n\"\n                   \"1\\r\\n>\\r\\n\"\n                   \"d\\r\\n<meta inject>\\r\\n\"\n                   \"3\\r\\n<ti\\r\\n\"\n                   \"4\\r\\ntle>\\r\\n\"\n                   \"7\\r\\nPrefix \\r\\n\"\n                   \"4\\r\\nThe \\r\\n\"\n                   \"4\\r\\nTitl\\r\\n\"\n                   \"4\\r\\ne</t\\r\\n\"\n                   \"4\\r\\nitle\\r\\n\"\n                   \"4\\r\\n></h\\r\\n\"\n                   \"4\\r\\nead>\\r\\n\"\n                   \"11\\r\\n<body>Body</body>\\r\\n\"\n                   \"4\\r\\n</ht\\r\\n\"\n                   \"3\\r\\nml>\\r\\n\"\n                   \"0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_web_filter_shift (TestCase *tc,\n                       gconstpointer data)\n{\n  CockpitWebFilter *filter;\n  const gchar *resp;\n  GBytes *block;\n  GBytes *inject;\n\n  inject = bytes_static (\"injected\");\n  filter = cockpit_web_inject_new (\"foofn\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  cockpit_web_response_headers_full (tc->response, 200, \"OK\", -1, NULL);\n\n  /* Total content is foofoofn and split after the first 4 characters */\n  block = bytes_static (\"foof\");\n  g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n  g_bytes_unref (block);\n  block = bytes_static (\"oofn\");\n  g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n  g_bytes_unref (block);\n  cockpit_web_response_complete (tc->response);\n\n  while (cockpit_web_response_get_state (tc->response) != COCKPIT_WEB_RESPONSE_COMPLETE)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"4\\r\\nfoof\\r\\n\"\n                   \"4\\r\\noofn\\r\\n\"\n                   \"8\\r\\ninjected\\r\\n\"\n                   \"0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_web_filter_shift_three (TestCase *tc,\n                             gconstpointer data)\n{\n  CockpitWebFilter *filter;\n  const gchar *resp;\n  GBytes *block;\n  GBytes *inject;\n\n  inject = bytes_static (\"injected\");\n  filter = cockpit_web_inject_new (\"foofn\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  cockpit_web_response_headers_full (tc->response, 200, \"OK\", -1, NULL);\n\n  /* Total content is foofoofn and split across multiple packets after the first 4 characters */\n  block = bytes_static (\"foof\");\n  g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n  g_bytes_unref (block);\n  block = bytes_static (\"o\");\n  g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n  g_bytes_unref (block);\n  block = bytes_static (\"of\");\n  g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n  g_bytes_unref (block);\n  block = bytes_static (\"n\");\n  g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n  g_bytes_unref (block);\n  cockpit_web_response_complete (tc->response);\n\n  while (cockpit_web_response_get_state (tc->response) != COCKPIT_WEB_RESPONSE_COMPLETE)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"4\\r\\nfoof\\r\\n\"\n                   \"1\\r\\no\\r\\n\"\n                   \"2\\r\\nof\\r\\n\"\n                   \"1\\r\\nn\\r\\n\"\n                   \"8\\r\\ninjected\\r\\n\"\n                   \"0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_web_filter_passthrough (TestCase *tc,\n                             gconstpointer data)\n{\n  CockpitWebFilter *filter;\n  const gchar *resp;\n  GBytes *content;\n  GBytes *inject;\n\n  inject = bytes_static (\"<meta inject>\");\n  filter = cockpit_web_inject_new (\"<unknown>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  content = bytes_static (\"<html><head><title>The Title</title></head></html>\");\n  cockpit_web_response_content (tc->response, NULL, content, NULL);\n  g_bytes_unref (content);\n\n  while (cockpit_web_response_get_state (tc->response) != COCKPIT_WEB_RESPONSE_COMPLETE)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"32\\r\\n<html><head><title>The Title</title></head></html>\\r\\n\"\n                   \"0\\r\\n\\r\\n\");\n}\n\nstatic void\non_response_done_not_resuable (CockpitWebResponse *response,\n                               gboolean reusable,\n                               gpointer user_data)\n{\n  g_assert (reusable == FALSE);\n}\n\nstatic void\ntest_abort (TestCase *tc,\n            gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", 11, NULL);\n  g_signal_connect (tc->response, \"done\", G_CALLBACK (on_response_done_not_resuable), NULL);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  content = g_bytes_new_static (\"the content\", 11);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  cockpit_web_response_abort (tc->response);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  resp = output_as_string (tc);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Length: 11\\r\\n\" STATIC_HEADERS);\n}\n\nstatic const TestFixture fixture_connection_close = {\n  .header = \"Connection\",\n  .value = \"close\",\n};\n\nstatic void\ntest_connection_close (TestCase *tc,\n                       gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  g_assert (data == &fixture_connection_close);\n\n  g_signal_connect (tc->response, \"done\", G_CALLBACK (on_response_done_not_resuable), NULL);\n\n  content = g_bytes_new_static (\"the content\", 11);\n  cockpit_web_response_content (tc->response, NULL, content, NULL);\n  g_bytes_unref (content);\n\n  resp = output_as_string (tc);\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Length: 11\\r\\nConnection: close\\r\\n\"\n                   STATIC_HEADERS \"the content\");\n}\n\nstatic const TestFixture fixture_origin_default = {\n  .header = \"Host\",\n  .value = \"somemachine\",\n  .for_tls_proxy = FALSE,\n};\n\nstatic const TestFixture fixture_origin_tls_proxy = {\n  .header = \"Host\",\n  .value = \"somemachine\",\n  .for_tls_proxy = TRUE,\n};\n\nstatic void\ntest_origin (TestCase *tc,\n             gconstpointer data)\n{\n  const TestFixture *fixture = data;\n  GBytes *content;\n\n  if (fixture->for_tls_proxy)\n    g_assert_cmpstr (cockpit_web_response_get_origin (tc->response), ==, \"https://somemachine\");\n  else\n    g_assert_cmpstr (cockpit_web_response_get_origin (tc->response), ==, \"http://somemachine\");\n\n  content = g_bytes_new_static (\"the content\", 11);\n  cockpit_web_response_content (tc->response, NULL, content, NULL);\n  g_bytes_unref (content);\n  output_as_string (tc);\n}\n\ntypedef struct {\n    GHashTable *headers;\n    GIOStream *io;\n} TestPlain;\n\nstatic void\nsetup_plain (TestPlain *tc,\n             gconstpointer unused)\n{\n  GInputStream *input;\n  GOutputStream *output;\n\n  input = g_memory_input_stream_new ();\n  output = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);\n\n  tc->io = mock_io_stream_new (input, output);\n\n  g_object_unref (input);\n  g_object_unref (output);\n\n  tc->headers = cockpit_web_server_new_table ();\n}\n\nstatic void\nteardown_plain (TestPlain *tc,\n                gconstpointer unused)\n{\n  g_object_unref (tc->io);\n  g_hash_table_unref (tc->headers);\n}\n\nstatic void\ntest_pop_path (TestPlain *tc,\n               gconstpointer unused)\n{\n  CockpitWebResponse *response;\n  gchar *part;\n  const gchar *start = \"/cockpit/@localhost/another/test.html\";\n\n  response = cockpit_web_response_new (tc->io, start, start, NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, start);\n  g_assert_cmpstr (cockpit_web_response_get_url_root (response), ==, NULL);\n\n  part = cockpit_web_response_pop_path (response);\n  g_assert_cmpstr (part, ==, \"cockpit\");\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/@localhost/another/test.html\");\n  g_free (part);\n\n  part = cockpit_web_response_pop_path (response);\n  g_assert_cmpstr (part, ==, \"@localhost\");\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/another/test.html\");\n  g_free (part);\n\n  part = cockpit_web_response_pop_path (response);\n  g_assert_cmpstr (part, ==, \"another\");\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/test.html\");\n  g_free (part);\n\n  part = cockpit_web_response_pop_path (response);\n  g_assert_cmpstr (part, ==, \"test.html\");\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, NULL);\n  g_free (part);\n\n  part = cockpit_web_response_pop_path (response);\n  g_assert (part == NULL);\n  g_assert (cockpit_web_response_get_path (response) == NULL);\n  g_free (part);\n\n  cockpit_web_response_abort (response);\n  g_object_unref (response);\n}\n\nstatic void\ntest_pop_path_root (TestPlain *tc,\n                    gconstpointer unused)\n{\n  CockpitWebResponse *response;\n  gchar *part;\n\n  response = cockpit_web_response_new (tc->io, \"/\", \"/\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/\");\n\n  part = cockpit_web_response_pop_path (response);\n  g_assert_cmpstr (part, ==, NULL);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, NULL);\n  g_free (part);\n\n  cockpit_web_response_abort (response);\n  g_object_unref (response);\n}\n\nstatic void\ntest_skip_path (TestPlain *tc,\n                gconstpointer unused)\n{\n  CockpitWebResponse *response;\n  const gchar *start = \"/cockpit/@localhost/another/test.html\";\n\n  response = cockpit_web_response_new (tc->io, start, start, NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/cockpit/@localhost/another/test.html\");\n\n  g_assert (cockpit_web_response_skip_path (response) == TRUE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/@localhost/another/test.html\");\n\n  g_assert (cockpit_web_response_skip_path (response) == TRUE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/another/test.html\");\n\n  g_assert (cockpit_web_response_skip_path (response) == TRUE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/test.html\");\n\n  g_assert (cockpit_web_response_skip_path (response) == TRUE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, NULL);\n\n  g_assert (cockpit_web_response_skip_path (response) == FALSE);\n  g_assert (cockpit_web_response_get_path (response) == NULL);\n\n  cockpit_web_response_abort (response);\n  g_object_unref (response);\n}\n\nstatic void\ntest_skip_path_root (TestPlain *tc,\n                     gconstpointer unused)\n{\n  CockpitWebResponse *response;\n\n  response = cockpit_web_response_new (tc->io, \"/\", \"/\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/\");\n\n  g_assert (cockpit_web_response_skip_path (response) == FALSE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, NULL);\n\n  cockpit_web_response_abort (response);\n  g_object_unref (response);\n}\n\nstatic void\ntest_removed_prefix (TestPlain *tc,\n                     gconstpointer unused)\n{\n  CockpitWebResponse *response;\n\n  response = cockpit_web_response_new (tc->io, \"/\", \"/\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/\");\n  g_assert_cmpstr (cockpit_web_response_get_url_root (response), ==, NULL);\n  cockpit_web_response_abort (response);\n  g_clear_object (&response);\n\n  response = cockpit_web_response_new (tc->io, \"/path/\", \"/path/\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/path/\");\n  g_assert_cmpstr (cockpit_web_response_get_url_root (response), ==, NULL);\n  cockpit_web_response_abort (response);\n  g_clear_object (&response);\n\n  response = cockpit_web_response_new (tc->io, \"/path/path2/\", \"/path2/\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/path2/\");\n  g_assert_cmpstr (cockpit_web_response_get_url_root (response), ==, \"/path\");\n  cockpit_web_response_abort (response);\n  g_clear_object (&response);\n\n  response = cockpit_web_response_new (tc->io, \"/mis/\", \"/match/\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/match/\");\n  g_assert_cmpstr (cockpit_web_response_get_url_root (response), ==, NULL);\n  cockpit_web_response_abort (response);\n  g_clear_object (&response);\n\n  response = cockpit_web_response_new (tc->io, NULL, NULL, NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, NULL);\n  g_assert_cmpstr (cockpit_web_response_get_url_root (response), ==, NULL);\n  cockpit_web_response_abort (response);\n  g_clear_object (&response);\n}\n\nstatic void\ntest_gunzip_small (void)\n{\n  GError *error = NULL;\n  GMappedFile *file;\n  GBytes *compressed;\n  GBytes *bytes;\n\n  file = g_mapped_file_new (SRCDIR \"/src/common/mock-content/test-file.txt.gz\", FALSE, &error);\n  g_assert_no_error (error);\n\n  compressed = g_mapped_file_get_bytes (file);\n  g_mapped_file_unref (file);\n\n  bytes = cockpit_web_response_gunzip (compressed, &error);\n  g_assert_no_error (error);\n  g_bytes_unref (compressed);\n\n  cockpit_assert_bytes_eq (bytes, \"A small test file\\n\", -1);\n  g_bytes_unref (bytes);\n}\n\nstatic void\ntest_gunzip_large (void)\n{\n  GError *error = NULL;\n  GMappedFile *file;\n  GBytes *compressed;\n  GBytes *bytes;\n  gchar *checksum;\n\n  file = g_mapped_file_new (SRCDIR \"/src/common/mock-content/large.min.js.gz\", FALSE, &error);\n  g_assert_no_error (error);\n\n  compressed = g_mapped_file_get_bytes (file);\n  g_mapped_file_unref (file);\n\n  bytes = cockpit_web_response_gunzip (compressed, &error);\n  g_assert_no_error (error);\n  g_bytes_unref (compressed);\n\n  checksum = g_compute_checksum_for_bytes (G_CHECKSUM_MD5, bytes);\n  g_assert_cmpstr (checksum, ==, \"5ca7582261c421482436dfdf3af9bffe\");\n  g_free (checksum);\n\n  g_bytes_unref (bytes);\n}\n\nstatic void\ntest_gunzip_invalid (void)\n{\n  GError *error = NULL;\n  GBytes *compressed;\n  GBytes *bytes;\n\n  compressed = g_bytes_new_static (\"invalid\", 7);\n\n  bytes = cockpit_web_response_gunzip (compressed, &error);\n  g_assert (bytes == NULL);\n  g_assert_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n  g_error_free (error);\n\n  g_bytes_unref (compressed);\n}\n\nstatic void\ntest_negotiation_first (void)\n{\n  gchar *chosen = NULL;\n  GError *error = NULL;\n  GBytes *bytes;\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/test-file.txt\",\n                                            NULL, NULL, &chosen, &error);\n\n  cockpit_assert_bytes_eq (bytes, \"A small test file\\n\", -1);\n  g_assert_no_error (error);\n  g_bytes_unref (bytes);\n\n  g_assert_cmpstr (chosen, ==, SRCDIR \"/src/common/mock-content/test-file.txt\");\n  g_free (chosen);\n}\n\nstatic void\ntest_negotiation_last (void)\n{\n  gchar *chosen = NULL;\n  GError *error = NULL;\n  gchar *checksum;\n  GBytes *bytes;\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/large.js\",\n                                            NULL, NULL, &chosen, &error);\n\n  g_assert_no_error (error);\n  g_assert_cmpstr (chosen, ==, SRCDIR \"/src/common/mock-content/large.min.js.gz\");\n  g_free (chosen);\n\n  checksum = g_compute_checksum_for_bytes (G_CHECKSUM_MD5, bytes);\n  g_assert_cmpstr (checksum, ==, \"e5284b625b7665fc04e082827de3436c\");\n  g_free (checksum);\n\n  g_bytes_unref (bytes);\n}\n\nstatic void\ntest_negotiation_prune (void)\n{\n  gchar *chosen = NULL;\n  GError *error = NULL;\n  GBytes *bytes;\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/test-file.extra.extension.txt\",\n                                            NULL, NULL, &chosen, &error);\n\n  cockpit_assert_bytes_eq (bytes, \"A small test file\\n\", -1);\n  g_assert_no_error (error);\n  g_bytes_unref (bytes);\n\n  g_assert_cmpstr (chosen, ==, SRCDIR \"/src/common/mock-content/test-file.txt\");\n  g_free (chosen);\n}\n\nstatic void\ntest_negotiation_with_listing (void)\n{\n  GHashTable *existing;\n  GError *error = NULL;\n  GBytes *bytes;\n\n  /* Lie and say that only the .gz file exists */\n  existing = g_hash_table_new (g_str_hash, g_str_equal);\n  g_hash_table_add (existing, SRCDIR \"/src/common/mock-content/test-file.txt.gz\");\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/test-file.txt\",\n                                            existing, NULL, NULL, &error);\n\n  cockpit_assert_bytes_eq (bytes, \"\\x1F\\x8B\\x08\\x08N1\\x03U\\x00\\x03test-file.txt\\x00\"\n                           \"sT(\\xCEM\\xCC\\xC9Q(I-.QH\\xCB\\xCCI\\xE5\\x02\\x00>PjG\\x12\\x00\\x00\\x00\", 52);\n  g_assert_no_error (error);\n  g_bytes_unref (bytes);\n\n  g_hash_table_unref (existing);\n}\n\nstatic void\ntest_negotiation_locale (void)\n{\n  gchar *chosen = NULL;\n  GError *error = NULL;\n  GBytes *bytes;\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/test-file.txt\",\n                                            NULL, \"zh-cn\", &chosen, &error);\n\n  cockpit_assert_bytes_eq (bytes, \"A translated test file\\n\", -1);\n  g_assert_no_error (error);\n  g_bytes_unref (bytes);\n\n  g_assert_cmpstr (chosen, ==, SRCDIR \"/src/common/mock-content/test-file.zh_CN.txt\");\n  g_free (chosen);\n}\n\nstatic void\ntest_negotiation_notfound (void)\n{\n  gchar *chosen = NULL;\n  GError *error = NULL;\n  GBytes *bytes;\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/non-existent\",\n                                            NULL, NULL, &chosen, &error);\n\n  g_assert_no_error (error);\n  g_assert (bytes == NULL);\n\n  g_assert (chosen == NULL);\n}\n\nstatic void\ntest_negotiation_failure (void)\n{\n  gchar *chosen = NULL;\n  GError *error = NULL;\n  GBytes *bytes;\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/directory\",\n                                            NULL, NULL, &chosen, &error);\n\n  g_assert (error != NULL);\n  g_error_free (error);\n\n  g_assert (bytes == NULL);\n\n  g_assert (chosen == NULL);\n}\n\nint\nmain (int argc,\n      char *argv[])\n{\n  gint ret;\n\n  srcdir = realpath (SRCDIR, NULL);\n  g_assert (srcdir != NULL);\n\n  cockpit_test_init (&argc, &argv);\n\n  g_test_add (\"/web-response/return-content\", TestCase, NULL,\n              setup, test_return_content, teardown);\n  g_test_add (\"/web-response/return-content-headers\", TestCase, NULL,\n              setup, test_return_content_headers, teardown);\n  g_test_add (\"/web-response/return-error\", TestCase, NULL,\n              setup, test_return_error, teardown);\n  g_test_add (\"/web-response/return-error-headers\", TestCase, NULL,\n              setup, test_return_error_headers, teardown);\n  g_test_add (\"/web-response/return-gerror-headers\", TestCase, NULL,\n              setup, test_return_gerror_headers, teardown);\n  g_test_add (\"/web-response/return-error-resource\", TestCase, NULL,\n              setup, test_return_error_resource, teardown);\n  g_test_add (\"/web-response/file/not-found\", TestCase, NULL,\n              setup, test_file_not_found, teardown);\n  g_test_add (\"/web-response/file/directory-denied\", TestCase, NULL,\n              setup, test_file_directory_denied, teardown);\n  g_test_add (\"/web-response/file/access-denied\", TestCase, NULL,\n              setup, test_file_access_denied, teardown);\n  g_test_add (\"/web-response/file/breakout-denied\", TestCase, NULL,\n              setup, test_file_breakout_denied, teardown);\n  g_test_add (\"/web-response/file/invalid-encoding-denied\", TestCase, NULL,\n              setup, test_file_encoding_denied, teardown);\n  g_test_add (\"/web-response/file/file-slash-denied\", TestCase, NULL,\n              setup, test_file_slash_denied, teardown);\n  g_test_add (\"/web-response/file/breakout-non-existant\", TestCase, NULL,\n              setup, test_file_breakout_non_existant, teardown);\n  g_test_add (\"/web-reponse/file/template\", TestCase, &template_fixture,\n              setup, test_template, teardown);\n  g_test_add (\"/web-response/content-type/html\", TestCase, &content_type_fixture_html,\n              setup, test_content_type, teardown);\n  g_test_add (\"/web-response/content-type/png\", TestCase, &content_type_fixture_png,\n              setup, test_content_type, teardown);\n  g_test_add (\"/web-response/content-type/wasm\", TestCase, &content_type_fixture_wasm,\n              setup, test_content_type, teardown);\n  g_test_add (\"/web-response/content-encoding\", TestCase, NULL,\n              setup, test_content_encoding, teardown);\n  g_test_add (\"/web-response/stream\", TestCase, NULL,\n              setup, test_stream, teardown);\n  g_test_add (\"/web-response/pressure\", TestCase, NULL,\n              setup, test_pressure, teardown);\n  g_test_add (\"/web-response/head\", TestCase, NULL,\n              setup, test_head, teardown);\n  g_test_add (\"/web-response/chunked-transfer-encoding\", TestCase, NULL,\n              setup, test_chunked_transfer_encoding, teardown);\n  g_test_add (\"/web-response/chunked-zero-length\", TestCase, NULL,\n              setup, test_chunked_zero_length, teardown);\n  g_test_add (\"/web-response/abort\", TestCase, NULL,\n              setup, test_abort, teardown);\n  g_test_add (\"/web-response/connection-close\", TestCase, &fixture_connection_close,\n              setup, test_connection_close, teardown);\n  g_test_add (\"/web-response/origin-default\", TestCase, &fixture_origin_default,\n              setup, test_origin, teardown);\n  g_test_add (\"/web-response/origin-tls-proxy\", TestCase, &fixture_origin_tls_proxy,\n              setup, test_origin, teardown);\n\n  g_test_add (\"/web-response/cache-forever\", TestCase, &cache_forever_fixture,\n              setup, test_cache, teardown);\n  g_test_add (\"/web-response/cache-private\", TestCase, &cache_private_fixture,\n              setup, test_cache, teardown);\n  g_test_add (\"/web-response/cache-none\", TestCase, &cache_none_fixture,\n              setup, test_cache, teardown);\n  g_test_add (\"/web-response/cache-unset\", TestCase, &cache_unset_fixture,\n              setup, test_cache, teardown);\n\n  g_test_add (\"/web-response/filter/simple\", TestCase, NULL,\n              setup, test_web_filter_simple, teardown);\n  g_test_add (\"/web-response/filter/multiple\", TestCase, NULL,\n              setup, test_web_filter_multiple, teardown);\n  g_test_add (\"/web-response/filter/passthrough\", TestCase, NULL,\n              setup, test_web_filter_passthrough, teardown);\n  g_test_add (\"/web-response/filter/split\", TestCase, NULL,\n              setup, test_web_filter_split, teardown);\n  g_test_add (\"/web-response/filter/shift\", TestCase, NULL,\n              setup, test_web_filter_shift, teardown);\n  g_test_add (\"/web-response/filter/shift_three\", TestCase, NULL,\n              setup, test_web_filter_shift_three, teardown);\n\n  g_test_add (\"/web-response/path/pop\", TestPlain, NULL,\n              setup_plain, test_pop_path, teardown_plain);\n  g_test_add (\"/web-response/path/pop-root\", TestPlain, NULL,\n              setup_plain, test_pop_path_root, teardown_plain);\n  g_test_add (\"/web-response/path/skip\", TestPlain, NULL,\n              setup_plain, test_skip_path, teardown_plain);\n  g_test_add (\"/web-response/path/skip-root\", TestPlain, NULL,\n              setup_plain, test_skip_path_root, teardown_plain);\n  g_test_add (\"/web-response/path/removed-prefix\", TestPlain, NULL,\n              setup_plain, test_removed_prefix, teardown_plain);\n\n  g_test_add_func (\"/web-response/gunzip/small\", test_gunzip_small);\n  g_test_add_func (\"/web-response/gunzip/large\", test_gunzip_large);\n  g_test_add_func (\"/web-response/gunzip/invalid\", test_gunzip_invalid);\n\n  g_test_add_func (\"/web-response/negotiation/first\", test_negotiation_first);\n  g_test_add_func (\"/web-response/negotiation/last\", test_negotiation_last);\n  g_test_add_func (\"/web-response/negotiation/locale\", test_negotiation_locale);\n  g_test_add_func (\"/web-response/negotiation/prune\", test_negotiation_prune);\n  g_test_add_func (\"/web-response/negotiation/with-listing\", test_negotiation_with_listing);\n  g_test_add_func (\"/web-response/negotiation/notfound\", test_negotiation_notfound);\n  g_test_add_func (\"/web-response/negotiation/failure\", test_negotiation_failure);\n\n  ret = g_test_run ();\n\n  free (srcdir);\n\n  return ret;\n}\n", "/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2015 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include \"mock-auth.h\"\n#include \"cockpitws.h\"\n#include \"cockpitcreds.h\"\n#include \"cockpitchannelresponse.h\"\n\n#include \"common/cockpitpipetransport.h\"\n#include \"common/cockpittransport.h\"\n#include \"common/cockpitjson.h\"\n#include \"common/cockpittest.h\"\n#include \"common/mock-io-stream.h\"\n#include \"common/cockpitwebserver.h\"\n#include \"common/cockpitconf.h\"\n\n#include \"websocket/websocket.h\"\n\n#include <glib.h>\n\n#include <string.h>\n#include <errno.h>\n#include <stdio.h>\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n\n/*\n * To recalculate the checksums found in this file, do something like:\n * $ XDG_DATA_DIRS=$PWD/src/bridge/mock-resource/system/ XDG_DATA_HOME=/nonexistent ./cockpit-bridge --packages\n */\n#define CHECKSUM \"$025e419da72456a49bc60c042b2e983a4a7a44e78eac1fffd062e046e8d4cf3b\"\n\n#define PASSWORD \"this is the password\"\n\n/* headers that are present in every request */\n#define STATIC_HEADERS \"X-Content-Type-Options: nosniff\\r\\nX-DNS-Prefetch-Control: off\\r\\nReferrer-Policy: no-referrer\\r\\nCross-Origin-Resource-Policy: same-origin\\r\\n\"\n\ntypedef struct {\n  CockpitWebService *service;\n  GIOStream *io;\n  GMemoryOutputStream *output;\n  CockpitPipe *pipe;\n  GHashTable *headers;\n} TestResourceCase;\n\ntypedef struct {\n  const gchar *xdg_data_home;\n  gboolean org_path;\n} TestResourceFixture;\n\nstatic gboolean\non_transport_control (CockpitTransport *transport,\n                      const char *command,\n                      const gchar *channel,\n                      JsonObject *options,\n                      GBytes *payload,\n                      gpointer data)\n{\n  gboolean *flag = data;\n  g_assert (flag != NULL);\n\n  if (g_str_equal (command, \"init\"))\n    *flag = TRUE;\n\n  return FALSE;\n}\n\nstatic void\nsetup_resource (TestResourceCase *tc,\n                gconstpointer data)\n{\n  const TestResourceFixture *fixture = data;\n  CockpitTransport *transport;\n  GInputStream *input;\n  GOutputStream *output;\n  CockpitCreds *creds;\n  gchar **environ;\n  const gchar *user;\n  const gchar *home = NULL;\n  gboolean ready = FALSE;\n  GBytes *password;\n  gulong handler;\n\n  const gchar *argv[] = {\n    BUILDDIR \"/cockpit-bridge\",\n    NULL\n  };\n\n  environ = g_get_environ ();\n  environ = g_environ_setenv (environ, \"XDG_DATA_DIRS\", SRCDIR \"/src/bridge/mock-resource/system\", TRUE);\n\n  if (fixture)\n    home = fixture->xdg_data_home;\n  if (!home)\n    home = SRCDIR \"/src/bridge/mock-resource/home\";\n  environ = g_environ_setenv (environ, \"XDG_DATA_HOME\", home, TRUE);\n\n  /* Start up a cockpit-bridge here */\n  tc->pipe = cockpit_pipe_spawn (argv, (const gchar **)environ, NULL, COCKPIT_PIPE_FLAGS_NONE);\n\n  g_strfreev (environ);\n\n  user = g_get_user_name ();\n  password = g_bytes_new_take (g_strdup (PASSWORD), strlen (PASSWORD));\n  creds = cockpit_creds_new (\"cockpit\", COCKPIT_CRED_USER, user, COCKPIT_CRED_PASSWORD, password, NULL);\n  g_bytes_unref (password);\n\n  transport = cockpit_pipe_transport_new (tc->pipe);\n  tc->service = cockpit_web_service_new (creds, transport);\n\n  /* Manually created services won't be init'd yet, wait for that before sending data */\n  handler = g_signal_connect (transport, \"control\", G_CALLBACK (on_transport_control), &ready);\n\n  while (!ready)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_object_unref (transport);\n\n  cockpit_creds_unref (creds);\n\n  input = g_memory_input_stream_new_from_data (\"\", 0, NULL);\n  output = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);\n  tc->io = mock_io_stream_new (input, output);\n  tc->output = G_MEMORY_OUTPUT_STREAM (output);\n  g_object_unref (input);\n\n  tc->headers = cockpit_web_server_new_table ();\n  g_hash_table_insert (tc->headers, g_strdup (\"Accept-Encoding\"), g_strdup (\"gzip, identity\"));\n\n  g_signal_handler_disconnect (transport, handler);\n}\n\nstatic void\nteardown_resource (TestResourceCase *tc,\n                   gconstpointer data)\n{\n  cockpit_assert_expected ();\n\n  g_hash_table_unref (tc->headers);\n\n  g_object_add_weak_pointer (G_OBJECT (tc->service), (gpointer *)&tc->service);\n  g_object_unref (tc->service);\n  g_assert (tc->service == NULL);\n\n  g_object_unref (tc->io);\n  g_object_unref (tc->output);\n  g_object_unref (tc->pipe);\n}\n\nstatic gboolean\nstr_contains_strv (const gchar *haystack, const gchar *sewing_kit, const gchar *delim)\n{\n  gchar **needles;\n  gboolean result = TRUE;\n  if (strlen (haystack) != strlen (sewing_kit))\n    {\n      fprintf(stderr, \"Length of '%s' doesn't match '%s'\\n\", haystack, sewing_kit);\n      return FALSE;\n    }\n\n  needles = g_strsplit (sewing_kit, delim, 0);\n  for (guint i = 0; i < g_strv_length (needles) && result; ++i)\n    result &= strstr (haystack, needles[i]) != NULL;\n  g_strfreev (needles);\n  if (!result)\n    fprintf(stderr, \"String '%s' doesn't contain each element in '%s'\\n\",\n            haystack, sewing_kit);\n  return result;\n}\n\nstatic void\ntest_resource_simple (TestResourceCase *tc,\n                      gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *url = \"/@localhost/another/test.html\";\n  const gchar *expected =\n    \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://localhost; connect-src 'self' http://localhost ws://localhost; form-action 'self' http://localhost; base-uri 'self' http://localhost; object-src 'none'; font-src 'self' http://localhost data:; img-src 'self' http://localhost data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"52\\r\\n\"\n    \"<html>\\n\"\n    \"<head>\\n\"\n    \"<title>In home dir</title>\\n\"\n    \"</head>\\n\"\n    \"<body>In home dir</body>\\n\"\n    \"</html>\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"52\\r\\n\"\n                           \"<html>\\n\"\n                           \"<head>\\n\"\n                           \"<title>In home dir</title>\\n\"\n                           \"</head>\\n\"\n                           \"<body>In home dir</body>\\n\"\n                           \"</html>\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_simple_host (TestResourceCase *tc,\n                           gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *url = \"/@localhost/another/test.html\";\n  const gchar *expected =\n    \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://my.host; connect-src 'self' http://my.host ws://my.host; form-action 'self' http://my.host; base-uri 'self' http://my.host; object-src 'none'; font-src 'self' http://my.host data:; img-src 'self' http://my.host data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://my.host\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"52\\r\\n\"\n    \"<html>\\n\"\n    \"<head>\\n\"\n    \"<title>In home dir</title>\\n\"\n    \"</head>\\n\"\n    \"<body>In home dir</body>\\n\"\n    \"</html>\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  g_hash_table_insert (tc->headers, g_strdup (\"Host\"), g_strdup (\"my.host\"));\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"52\\r\\n\"\n                           \"<html>\\n\"\n                           \"<head>\\n\"\n                           \"<title>In home dir</title>\\n\"\n                           \"</head>\\n\"\n                           \"<body>In home dir</body>\\n\"\n                           \"</html>\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_language (TestResourceCase *tc,\n                        gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  gchar *url = \"/@localhost/another/test.html\";\n  const gchar *expected =  \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://localhost; connect-src 'self' http://localhost ws://localhost; form-action 'self' http://localhost; base-uri 'self' http://localhost; object-src 'none'; font-src 'self' http://localhost data:; img-src 'self' http://localhost data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"60\\r\\n\"\n    \"<html>\\n\"\n    \"<head>\\n\"\n    \"<title>Inlay omehay irday</title>\\n\"\n    \"</head>\\n\"\n    \"<body>Inlay omehay irday</body>\\n\"\n    \"</html>\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  g_hash_table_insert (tc->headers, g_strdup (\"Accept-Language\"), g_strdup (\"pig, blah\"));\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"60\\r\\n\"\n                           \"<html>\\n\"\n                           \"<head>\\n\"\n                           \"<title>Inlay omehay irday</title>\\n\"\n                           \"</head>\\n\"\n                           \"<body>Inlay omehay irday</body>\\n\"\n                           \"</html>\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_cookie (TestResourceCase *tc,\n                      gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *url = \"/@localhost/another/test.html\";\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://localhost; connect-src 'self' http://localhost ws://localhost; form-action 'self' http://localhost; base-uri 'self' http://localhost; object-src 'none'; font-src 'self' http://localhost data:; img-src 'self' http://localhost data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"60\\r\\n\"\n    \"<html>\\n\"\n    \"<head>\\n\"\n    \"<title>Inlay omehay irday</title>\\n\"\n    \"</head>\\n\"\n    \"<body>Inlay omehay irday</body>\\n\"\n    \"</html>\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  g_hash_table_insert (tc->headers, g_strdup (\"Cookie\"), g_strdup (\"CockpitLang=pig\"));\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str, \"*\\r\\n\"\n                           \"60\\r\\n\"\n                           \"<html>\\n\"\n                           \"<head>\\n\"\n                           \"<title>Inlay omehay irday</title>\\n\"\n                           \"</head>\\n\"\n                           \"<body>Inlay omehay irday</body>\\n\"\n                           \"</html>\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_not_found (TestResourceCase *tc,\n                         gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *url = \"/cockpit/another@localhost/not-exist\";\n  const gchar *expected = \"HTTP/1.1 404 Not Found\\r\\n\"\n    \"Content-Type: text/html; charset=utf8\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    STATIC_HEADERS\n    \"\\r\\n13\\r\\n\"\n    \"<html><head><title>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\n15\\r\\n\"\n    \"</title></head><body>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\nf\\r\\n\"\n    \"</body></html>\\n\\r\\n0\\r\\n\\r\\n\";\n\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"another@localhost\", \"/not-exist\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str, \"*\\r\\n13\\r\\n\"\n                           \"<html><head><title>\\r\\n9\\r\\n\"\n                           \"Not Found\\r\\n15\\r\\n\"\n                           \"</title></head><body>\\r\\n9\\r\\n\"\n                           \"Not Found\\r\\nf\\r\\n\"\n                           \"</body></html>\\n\\r\\n0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_no_path (TestResourceCase *tc,\n                       gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *url = \"/cockpit/another@localhost\";\n  const gchar *expected = \"HTTP/1.1 404 Not Found\\r\\n\"\n    \"Content-Type: text/html; charset=utf8\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    STATIC_HEADERS\n    \"\\r\\n13\\r\\n\"\n    \"<html><head><title>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\n15\\r\\n\"\n    \"</title></head><body>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\nf\\r\\n\"\n    \"</body></html>\\n\\r\\n0\\r\\n\\r\\n\";\n\n  /* Missing path after package */\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"another@localhost\", \"\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str, \"*\\r\\n13\\r\\n\"\n                           \"<html><head><title>\\r\\n9\\r\\n\"\n                           \"Not Found\\r\\n15\\r\\n\"\n                           \"</title></head><body>\\r\\n9\\r\\n\"\n                           \"Not Found\\r\\nf\\r\\n\"\n                           \"</body></html>\\n\\r\\n0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\n\nstatic void\ntest_resource_failure (TestResourceCase *tc,\n                       gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  GPid pid;\n  const gchar *expected = \"HTTP/1.1 500 terminated\\r\\nContent-Type: text/html; charset=utf8\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS \"\\r\\n13\\r\\n<html><head><title>\\r\\na\\r\\nterminated\\r\\n15\\r\\n</title></head><body>\\r\\na\\r\\nterminated\\r\\nf\\r\\n</body></html>\\n\\r\\n0\\r\\n\\r\\n\";\n  const gchar *expected_alt = \"HTTP/1.1 500 internal-error\\r\\nContent-Type: text/html; charset=utf8\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS \"\\r\\n13\\r\\n<html><head><title>\\r\\ne\\r\\ninternal-error\\r\\n15\\r\\n</title></head><body>\\r\\ne\\r\\ninternal-error\\r\\nf\\r\\n</body></html>\\n\\r\\n0\\r\\n\\r\\n\";\n\n  cockpit_expect_possible_log (\"cockpit-protocol\", G_LOG_LEVEL_WARNING, \"*: bridge program failed:*\");\n  cockpit_expect_possible_log (\"cockpit-ws\", G_LOG_LEVEL_MESSAGE, \"*: external channel failed: *\");\n\n  /* Now kill the bridge */\n  g_assert (cockpit_pipe_get_pid (tc->pipe, &pid));\n  g_assert_cmpint (pid, >, 0);\n  g_assert_cmpint (kill (pid, SIGTERM), ==, 0);\n  /* Wait until it's gone; we can't use waitpid(), it interferes with GChildWatch */\n  while (kill (pid, 0) >= 0)\n    g_usleep (1000);\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  /* Null terminate for str-match below */\n  g_output_stream_write_all (G_OUTPUT_STREAM (tc->output), \"\\0\", 1, NULL, NULL, &error);\n  g_assert_no_error (error);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\") || str_contains_strv (str, expected_alt, \"\\n\"));\n  cockpit_assert_strmatch (str, \"*\\r\\n\\r\\n13\\r\\n<html><head><title>\\r\\n*\\r\\n*\\r\\n15\\r\\n</title></head><body>\\r\\n*\\r\\n*\\r\\nf\\r\\n</body></html>\\n\\r\\n0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic const TestResourceFixture checksum_fixture = {\n  .xdg_data_home = \"/nonexistent\"\n};\n\n\nstatic void\nrequest_checksum (TestResourceCase *tc)\n{\n  CockpitWebResponse *response;\n  GInputStream *input;\n  GOutputStream *output;\n  GIOStream *io;\n\n  input = g_memory_input_stream_new_from_data (\"\", 0, NULL);\n  output = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);\n  io = mock_io_stream_new (input, output);\n  g_object_unref (input);\n\n  /* Start the connection up, and poke it a bit */\n  response = cockpit_web_response_new (io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/checksum\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_object_unref (io);\n\n  /* Use this when the checksum changes, due to mock resource changes */\n#if 0\n  bytes = g_memory_output_stream_steal_as_bytes (G_MEMORY_OUTPUT_STREAM (output));\n  g_printerr (\"%.*s\\n\", (gint)g_bytes_get_size (bytes), (gchar *)g_bytes_get_data (bytes, NULL));\n  g_bytes_unref (bytes);\n#endif\n\n  g_object_unref (output);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_checksum (TestResourceCase *tc,\n                        gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"ETag: \\\"\" CHECKSUM \"-c\\\"\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Cache-Control: max-age=31556926, public\\r\\n\"\n    \"\\r\\n\"\n    \"32\\r\\n\"\n    \"These are the contents of file.ext\\nOh marmalaaade\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  /* We require that no user packages are loaded, so we have a checksum */\n  g_assert (data == &checksum_fixture);\n\n  request_checksum (tc);\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_channel_response_serve (tc->service, tc->headers, response,\n                                CHECKSUM,\n                                \"/test/sub/file.ext\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"32\\r\\n\"\n                           \"These are the contents of file.ext\\nOh marmalaaade\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_not_modified (TestResourceCase *tc,\n                            gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  const gchar *expected = \"HTTP/1.1 304 Not Modified\\r\\n\"\n    \"ETag: \\\"\" CHECKSUM \"-c\\\"\\r\\n\"\n    STATIC_HEADERS\n    \"\\r\\n\";\n\n  request_checksum (tc);\n\n  g_hash_table_insert (tc->headers, g_strdup (\"If-None-Match\"),\n                       g_strdup (\"\\\"\" CHECKSUM \"-c\\\"\"));\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_channel_response_serve (tc->service, tc->headers, response,\n                                CHECKSUM,\n                                \"/test/sub/file.ext\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  g_assert (str_contains_strv (g_bytes_get_data (bytes, NULL), expected, \"\\n\"));\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_not_modified_new_language (TestResourceCase *tc,\n                                         gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"ETag: \\\"\" CHECKSUM \"-de\\\"\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Cache-Control: max-age=31556926, public\\r\\n\"\n    \"\\r\\n\"\n    \"32\\r\\n\"\n    \"These are the contents of file.ext\\nOh marmalaaade\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  request_checksum (tc);\n\n  g_hash_table_insert (tc->headers, g_strdup (\"If-None-Match\"),\n                       g_strdup (\"\\\"\" CHECKSUM \"-c\\\"\"));\n  g_hash_table_insert (tc->headers, g_strdup (\"Accept-Language\"), g_strdup (\"de\"));\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_channel_response_serve (tc->service, tc->headers, response,\n                                CHECKSUM,\n                                \"/test/sub/file.ext\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"32\\r\\n\"\n                           \"These are the contents of file.ext\\nOh marmalaaade\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_not_modified_cookie_language (TestResourceCase *tc,\n                                            gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  gchar *cookie;\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"ETag: \\\"\" CHECKSUM \"-fr\\\"\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Cache-Control: max-age=31556926, public\\r\\n\"\n    \"\\r\\n\"\n    \"32\\r\\n\"\n    \"These are the contents of file.ext\\nOh marmalaaade\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  request_checksum (tc);\n\n  g_hash_table_insert (tc->headers, g_strdup (\"If-None-Match\"),\n                       g_strdup (\"\\\"\" CHECKSUM \"-c\\\"\"));\n\n  cookie = g_strdup_printf (\"%s; CockpitLang=fr\", (gchar *)g_hash_table_lookup (tc->headers, \"Cookie\"));\n  g_hash_table_insert (tc->headers, g_strdup (\"Cookie\"), cookie);\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_channel_response_serve (tc->service, tc->headers, response,\n                                CHECKSUM,\n                                \"/test/sub/file.ext\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"32\\r\\n\"\n                           \"These are the contents of file.ext\\nOh marmalaaade\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_no_checksum (TestResourceCase *tc,\n                           gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 404 Not Found\\r\\n\"\n    \"Content-Type: text/html; charset=utf8\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    STATIC_HEADERS\n    \"\\r\\n13\\r\\n\"\n    \"<html><head><title>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\n15\\r\\n\"\n    \"</title></head><body>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\nf\\r\\n\"\n    \"</body></html>\\n\\r\\n0\\r\\n\\r\\n\";\n\n  /* Missing checksum */\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"xxx\", \"/test\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n13\\r\\n*\"\n                           \"*<html><head><title>\\r\\n9\\r\\n*\"\n                           \"*Not Found\\r\\n15\\r\\n*\"\n                           \"*</title></head><body>\\r\\n9\\r\\n*\"\n                           \"*Not Found\\r\\nf\\r\\n*\"\n                           \"*</body></html>\\n\\r\\n0\\r\\n\\r\\n*\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_bad_checksum (TestResourceCase *tc,\n                            gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 404 Not Found\\r\\n\"\n    \"Content-Type: text/html; charset=utf8\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    STATIC_HEADERS\n    \"\\r\\n13\\r\\n\"\n    \"<html><head><title>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\n15\\r\\n\"\n    \"</title></head><body>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\nf\\r\\n\"\n    \"</body></html>\\n\\r\\n0\\r\\n\\r\\n\";\n\n  /* Missing checksum */\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"09323094823029348\", \"/path\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n13\\r\\n*\"\n                           \"*<html><head><title>\\r\\n9\\r\\n*\"\n                           \"*Not Found\\r\\n15\\r\\n*\"\n                           \"*</title></head><body>\\r\\n9\\r\\n*\"\n                           \"*Not Found\\r\\nf\\r\\n*\"\n                           \"*</body></html>\\n\\r\\n0\\r\\n\\r\\n*\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_language_suffix (TestResourceCase *tc,\n                               gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://localhost; connect-src 'self' http://localhost ws://localhost; form-action 'self' http://localhost; base-uri 'self' http://localhost; object-src 'none'; font-src 'self' http://localhost data:; img-src 'self' http://localhost data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"62\\r\\n\"\n    \"<html>\\n\"\n    \"<head>\\n\"\n    \"<title>Im Home-Verzeichnis</title>\\n\"\n    \"</head>\\n\"\n    \"<body>Im Home-Verzeichnis</body>\\n\"\n    \"</html>\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.de.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"62\\r\\n\"\n                           \"<html>\\n\"\n                           \"<head>\\n\"\n                           \"<title>Im Home-Verzeichnis</title>\\n\"\n                           \"</head>\\n\"\n                           \"<body>Im Home-Verzeichnis</body>\\n\"\n                           \"</html>\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_language_fallback (TestResourceCase *tc,\n                                 gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://localhost; connect-src 'self' http://localhost ws://localhost; form-action 'self' http://localhost; base-uri 'self' http://localhost; object-src 'none'; font-src 'self' http://localhost data:; img-src 'self' http://localhost data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"52\\r\\n\"\n    \"<html>\\n\"\n    \"<head>\\n\"\n    \"<title>In home dir</title>\\n\"\n    \"</head>\\n\"\n    \"<body>In home dir</body>\\n\"\n    \"</html>\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  /* Language cookie overrides */\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.fi.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"52\\r\\n\"\n                           \"<html>\\n\"\n                           \"<head>\\n\"\n                           \"<title>In home dir</title>\\n\"\n                           \"</head>\\n\"\n                           \"<body>In home dir</body>\\n\"\n                           \"</html>\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_gzip_encoding (TestResourceCase *tc,\n                             gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Encoding: gzip\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Content-Type: text/plain\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"34\\r\\n\"\n    \"\\x1F\\x8B\\x08\\x08N1\\x03U\\x00\\x03test-file.txt\\x00sT(\\xCEM\\xCC\\xC9Q(I-\"\n    \".QH\\xCB\\xCCI\\xE5\\x02\\x00>PjG\\x12\\x00\\x00\\x00\\x0D\\x0A\"\n    \"0\\x0D\\x0A\\x0D\\x0A\";\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test-file.txt\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"34\\r\\n\"\n                           \"\\x1F\\x8B\\x08\\x08N1\\x03U\\x00\\x03test-file.txt\\x00sT(\\xCEM\\xCC\\xC9Q(I-\"\n                           \".QH\\xCB\\xCCI\\xE5\\x02\\x00>PjG\\x12\\x00\\x00\\x00\\x0D\\x0A\"\n                           \"0\\x0D\\x0A\\x0D\\x0A\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_head (TestResourceCase *tc,\n                    gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *url = \"/@localhost/another/test.html\";\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://localhost; connect-src 'self' http://localhost ws://localhost; form-action 'self' http://localhost; base-uri 'self' http://localhost; object-src 'none'; font-src 'self' http://localhost data:; img-src 'self' http://localhost data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_web_response_set_method (response, \"HEAD\");\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic gboolean\non_hack_raise_sigchld (gpointer user_data)\n{\n  raise (SIGCHLD);\n  return TRUE;\n}\n\nint\nmain (int argc,\n      char *argv[])\n{\n  cockpit_test_init (&argc, &argv);\n\n  /*\n   * HACK: Work around races in glib SIGCHLD handling.\n   *\n   * https://bugzilla.gnome.org/show_bug.cgi?id=731771\n   * https://bugzilla.gnome.org/show_bug.cgi?id=711090\n   */\n  g_timeout_add_seconds (1, on_hack_raise_sigchld, NULL);\n\n  /* Try to debug crashing during tests */\n  signal (SIGSEGV, cockpit_test_signal_backtrace);\n\n  /* We don't want to test the ping functionality in these tests */\n  cockpit_ws_ping_interval = G_MAXUINT;\n\n  g_test_add (\"/web-channel/resource/simple\", TestResourceCase, NULL,\n              setup_resource, test_resource_simple, teardown_resource);\n  g_test_add (\"/web-channel/resource/simple_host\", TestResourceCase, NULL,\n              setup_resource, test_resource_simple_host, teardown_resource);\n  g_test_add (\"/web-channel/resource/language\", TestResourceCase, NULL,\n              setup_resource, test_resource_language, teardown_resource);\n  g_test_add (\"/web-channel/resource/cookie\", TestResourceCase, NULL,\n              setup_resource, test_resource_cookie, teardown_resource);\n  g_test_add (\"/web-channel/resource/not-found\", TestResourceCase, NULL,\n              setup_resource, test_resource_not_found, teardown_resource);\n  g_test_add (\"/web-channel/resource/no-path\", TestResourceCase, NULL,\n              setup_resource, test_resource_no_path, teardown_resource);\n  g_test_add (\"/web-channel/resource/failure\", TestResourceCase, NULL,\n              setup_resource, test_resource_failure, teardown_resource);\n  g_test_add (\"/web-channel/resource/checksum\", TestResourceCase, &checksum_fixture,\n              setup_resource, test_resource_checksum, teardown_resource);\n  g_test_add (\"/web-channel/resource/not-modified\", TestResourceCase, &checksum_fixture,\n              setup_resource, test_resource_not_modified, teardown_resource);\n  g_test_add (\"/web-channel/resource/not-modified-new-language\", TestResourceCase, &checksum_fixture,\n              setup_resource, test_resource_not_modified_new_language, teardown_resource);\n  g_test_add (\"/web-channel/resource/not-modified-cookie-language\", TestResourceCase, &checksum_fixture,\n              setup_resource, test_resource_not_modified_cookie_language, teardown_resource);\n  g_test_add (\"/web-channel/resource/no-checksum\", TestResourceCase, NULL,\n              setup_resource, test_resource_no_checksum, teardown_resource);\n  g_test_add (\"/web-channel/resource/bad-checksum\", TestResourceCase, NULL,\n              setup_resource, test_resource_bad_checksum, teardown_resource);\n  g_test_add (\"/web-channel/resource/language-suffix\", TestResourceCase, NULL,\n              setup_resource, test_resource_language_suffix, teardown_resource);\n  g_test_add (\"/web-channel/resource/language-fallback\", TestResourceCase, NULL,\n              setup_resource, test_resource_language_fallback, teardown_resource);\n\n  g_test_add (\"/web-channel/resource/gzip-encoding\", TestResourceCase, NULL,\n              setup_resource, test_resource_gzip_encoding, teardown_resource);\n  g_test_add (\"/web-channel/resource/head\", TestResourceCase, NULL,\n              setup_resource, test_resource_head, teardown_resource);\n\n  return g_test_run ();\n}\n", "#!/usr/bin/python3\n\n# This file is part of Cockpit.\n#\n# Copyright (C) 2013 Red Hat, Inc.\n#\n# Cockpit is free software; you can redistribute it and/or modify it\n# under the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation; either version 2.1 of the License, or\n# (at your option) any later version.\n#\n# Cockpit is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\nimport base64\nimport time\nimport os\nimport subprocess\n\nimport parent\nfrom testlib import *\n\n\n@skipDistroPackage()\nclass TestConnection(MachineCase):\n\n    def setUp(self):\n        super().setUp()\n        self.ws_executable = f\"{self.libexecdir}/cockpit-ws\"\n\n    def ostree_setup_ws(self):\n        '''Overlay cockpit-ws package on OSTree image\n\n        Disable the cockpit/ws container. This is for tests that don't work with the container,\n        and to make sure that overlaying cockpit-ws works as well.\n        '''\n        m = self.machine\n        if not m.ostree_image:\n            return\n\n        # uninstall cockpit/ws container startup script\n        m.execute(\"rm /etc/systemd/system/cockpit.service\")\n        # overlay cockpit-ws rpm\n        m.execute(\"rpm-ostree install --cache-only /var/tmp/build-results/cockpit-ws-*.rpm\")\n        m.spawn(\"sync && sync && sync && sleep 0.1 && reboot\", \"reboot\")\n        m.wait_reboot()\n\n    @skipBrowser(\"Firefox cannot work with cookies\", \"firefox\")\n    def testBasic(self):\n        m = self.machine\n\n        # always test with the default ws install (container on OSTree, package everywhere else)\n        self.check_basic_with_start_stop(m.start_cockpit, m.stop_cockpit)\n\n        # on OSTree, also check with overlaid cockpit-ws rpm\n        if m.ostree_image:\n            def ws_start():\n                m.execute(r\"\"\"set -e;\n                    mkdir -p /etc/systemd/system/cockpit.service.d/ &&\n                    printf \"[Service]\\nExecStart=\\n%s --no-tls\" `grep ExecStart= /lib/systemd/system/cockpit.service` \\\n                            > /etc/systemd/system/cockpit.service.d/notls.conf\n                    systemctl daemon-reload\n                    systemctl start cockpit.socket\"\"\")\n\n            def ws_stop():\n                m.execute(\"systemctl stop cockpit cockpit.socket\")\n\n            self.ostree_setup_ws()\n            # HACK: Getting SELinux errors with just rpm-ostree install; there's a plethora of failures, so just allow them all\n            m.execute(\"setenforce 0\")\n            self.allow_journal_messages('audit.*avc:  denied .*')\n            self.check_basic_with_start_stop(ws_start, ws_stop)\n\n    def check_basic_with_start_stop(self, start_cockpit, stop_cockpit):\n        m = self.machine\n        b = self.browser\n        start_cockpit()\n\n        # take cockpit-ws down on the login page\n        b.open(\"/system\")\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        stop_cockpit()\n        b.click('#login-button')\n        b.wait_text_not('#login-fatal-message', \"\")\n        start_cockpit()\n        b.reload()\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load()\n        b.enter_page(\"/system\")\n\n        # cookie should not be marked as secure, it's not https\n        cookie = b.cookie(\"cockpit\")\n        self.assertTrue(cookie[\"httpOnly\"])\n        self.assertEqual(cookie[\"sameSite\"], \"Strict\")\n        self.assertFalse(cookie[\"secure\"])\n\n        # take cockpit-ws down on the server page\n        stop_cockpit()\n        b.switch_to_top()\n        b.wait_in_text(\".curtains-ct h1\", \"Disconnected\")\n\n        start_cockpit()\n        b.click(\"#machine-reconnect\")\n        b.expect_load()\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n\n        # sever the connection on the login page\n        m.execute(\"iptables -w -I INPUT -p tcp --dport 9090 -j REJECT --reject-with tcp-reset\")\n        b.click('#login-button')\n        with b.wait_timeout(20):\n            b.wait_text_not('#login-fatal-message', \"\")\n        m.execute(\"iptables -w -D INPUT -p tcp --dport 9090 -j REJECT --reject-with tcp-reset\")\n        b.reload()\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load()\n        b.enter_page(\"/system\")\n\n        # sever the connection on the server page\n        m.execute(\"iptables -w -I INPUT -p tcp --dport 9090 -j REJECT\")\n        b.switch_to_top()\n        with b.wait_timeout(60):\n            b.wait_visible(\".curtains-ct\")\n\n        b.wait_in_text(\".curtains-ct h1\", \"Disconnected\")\n        b.wait_in_text('.curtains-ct p', \"Connection has timed out.\")\n        m.execute(\"iptables -w -D INPUT -p tcp --dport 9090 -j REJECT\")\n        b.click(\"#machine-reconnect\")\n        b.expect_load()\n        b.enter_page(\"/system\")\n        b.logout()\n\n        # deleted cookie after logout should not be marked as secure, it's not https\n        cookie = b.cookie(\"cockpit\")\n        self.assertEqual(cookie[\"value\"], \"deleted\")\n        self.assertTrue(cookie[\"httpOnly\"])\n        self.assertFalse(cookie[\"secure\"])\n\n        if not m.ostree_image:  # cannot write to /usr on OSTree, and cockpit-session is in a container\n            # damage cockpit-session permissions, expect generic error message\n            m.execute(f\"chmod g-x {self.libexecdir}/cockpit-session\")\n            b.open(\"/system\")\n            b.wait_in_text('#login-fatal-message', \"Internal error in login process\")\n            m.execute(f\"chmod g+x {self.libexecdir}/cockpit-session\")\n\n            self.allow_journal_messages(\".*cockpit-session: bridge program failed.*\")\n\n            # pretend cockpit-bridge is not installed, expect specific error message\n            m.execute(\"mv /usr/bin/cockpit-bridge /usr/bin/cockpit-bridge.disabled\")\n            b.open(\"/system\")\n            b.wait_visible(\"#login\")\n            b.set_val(\"#login-user-input\", \"admin\")\n            b.set_val(\"#login-password-input\", \"foobar\")\n            b.click('#login-button')\n            b.wait_visible('#login-fatal-message')\n            b.wait_text('#login-fatal-message', \"The cockpit package is not installed\")\n            m.execute(\"mv /usr/bin/cockpit-bridge.disabled /usr/bin/cockpit-bridge\")\n\n        self.allow_restart_journal_messages()\n\n        # Lets crash a systemd-crontrolled process and see if we get a proper backtrace in the logs\n        # This helps with debugging failures in the tests elsewhere\n        m.execute(\"\"\"mkdir -p /run/systemd/system/systemd-hostnamed.service.d\n                     printf '[Service]\\nLimitCORE=infinity\\n' > /run/systemd/system/systemd-hostnamed.service.d/core.conf\n                     systemctl daemon-reload\n                     systemctl restart systemd-hostnamed\n                     pkill -e -SEGV systemd-hostnam\"\"\")\n        wait(lambda: m.execute(\"journalctl -b | grep 'Process.*systemd-hostnam.*of user.*dumped core.'\"))\n\n        # Make sure the core dumps exist in the directory, so we can download them\n        cores = m.execute(\"find /var/lib/systemd/coredump -type f\")\n        self.assertNotEqual(cores, \"\")\n\n        self.allow_core_dumps = True\n        self.allow_journal_messages(\".*org.freedesktop.hostname1.*DBus.Error.NoReply.*\")\n\n    @skipImage(\"OSTree doesn't use systemd units\", \"fedora-coreos\")\n    def testUnitLifecycle(self):\n        m = self.machine\n\n        def expect_active(unit, is_active):\n            status = m.execute(\"systemctl is-active %s || true\" % unit).strip()\n            self.assertIn(status, [\"active\", \"inactive\"])\n            if is_active:\n                self.assertEqual(status, \"active\", \"%s is not active\" % unit)\n            else:\n                self.assertEqual(status, \"inactive\", \"%s is active\" % unit)\n\n        def expect_actives(ws_socket, instance_sockets, http_instances, https_instances=0):\n            expect_active(\"cockpit.socket\", ws_socket)\n            # http instances\n            for instance in [\"http\", \"http-redirect\"]:\n                expect_active(\"cockpit-wsinstance-%s.socket\" % instance, instance_sockets)\n                expect_active(\"cockpit-wsinstance-%s.service\" % instance, instance in http_instances)\n            # number of https instances\n            expect_active(\"cockpit-wsinstance-https-factory.socket\", instance_sockets)\n            for _type in [\"service\", \"socket\"]:\n                out = m.execute(\"systemctl --no-legend -t %s list-units cockpit-wsinstance-https@*\" % _type)\n                count = len(out.strip().splitlines())\n                self.assertEqual(count, https_instances, out)\n\n        # at the beginning, no cockpit related units are running\n        expect_actives(False, False, [])\n\n        # http only mode\n\n        m.start_cockpit(tls=False)\n        expect_actives(True, False, [])\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9090\"))\n\n        expect_actives(True, True, [\"http\"])\n        self.assertRaises(subprocess.CalledProcessError, m.execute,\n                          \"curl --silent https://127.0.0.1:9090\")\n        # c-tls knows it can't do https, and not activate that instance\n        expect_actives(True, True, [\"http\"])\n\n        m.restart_cockpit()\n        expect_actives(True, True, [\"http\"])\n\n        m.stop_cockpit()\n        expect_actives(False, False, [])\n\n        # cleans up also when cockpit-tls crashes or idle-exits, not just by explicit stop request\n        m.start_cockpit(tls=False)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9090\"))\n        m.execute(\"pkill -e cockpit-tls\")\n        expect_actives(True, False, [])\n\n        # and recovers from that\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9090\"))\n        expect_actives(True, True, [\"http\"])\n\n        # https mode\n\n        m.start_cockpit(tls=True)\n        expect_actives(True, False, [], 0)\n\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9090\"))\n\n        expect_actives(True, True, [\"http-redirect\"], 0)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent -k --head https://127.0.0.1:9090\"))\n        expect_actives(True, True, [\"http-redirect\"], 1)\n\n        m.restart_cockpit()\n        expect_actives(True, True, [\"http-redirect\"], 1)\n\n        m.stop_cockpit()\n        expect_actives(False, False, [], 0)\n\n        m.start_cockpit(tls=True)\n        expect_actives(True, False, [], 0)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9090\"))\n\n        expect_actives(True, True, [\"http-redirect\"], 0)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent -k --head https://127.0.0.1:9090\"))\n        expect_actives(True, True, [\"http-redirect\"], 1)\n\n        # cleans up also when cockpit-tls crashes or idle-exits, not just by explicit stop request\n        m.execute(\"pkill -e cockpit-tls\")\n        expect_actives(True, False, [], 0)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9090\"))\n        expect_actives(True, True, [\"http-redirect\"], 0)\n        # next https request after crash doesn't leak an instance\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent -k --head https://127.0.0.1:9090\"))\n        expect_actives(True, True, [\"http-redirect\"], 1)\n\n        # instance service+socket going away does not confuse cockpit-tls' bookkeeping\n        m.execute(\"systemctl stop cockpit-wsinstance-https@*.service cockpit-wsinstance-https@*.socket\")\n        expect_actives(True, True, [\"http-redirect\"], 0)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --show-error -k --head https://127.0.0.1:9090\"))\n        expect_actives(True, True, [\"http-redirect\"], 1)\n\n        # sockets are inaccessible to users, only to cockpit-tls\n        for s in [\"http.sock\", \"https-factory.sock\"]:\n            out = m.execute(\"su -c '! nc -U /run/cockpit/wsinstance/%s 2>&1 || exit 1' admin\" % s)\n            self.assertIn(\"Permission denied\", out)\n\n    @skipImage(\"OSTree doesn't use systemd units\", \"fedora-coreos\")\n    def testHttpsInstanceDoS(self):\n        m = self.machine\n        # prevent generating core dump artifacts\n        m.execute(\"echo core > /proc/sys/kernel/core_pattern\")\n        m.start_cockpit(tls=True)\n\n        # some netcat versions need an explicit shutdown option, others default to shutting down and don't have -N\n        n_opt = \"-N\" if \"-N\" in m.execute(\"nc -h 2>&1\") else \"\"\n\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent -k --head https://127.0.0.1:9090\"))\n\n        # number of https instances is bounded (DoS prevention)\n        # with MaxTasks=200 und 2 threads per ws instance we should have a\n        # rough limit of 100 instances, so at some point curl should start failing\n        m.execute(\"su -s /bin/sh -c 'RC=1; for i in `seq 120`; do \"\n                  \"  echo -n $i | nc %s -U /run/cockpit/wsinstance/https-factory.sock;\"\n                  \"  curl --silent --head --max-time 5 --unix /run/cockpit/wsinstance/https@$i.sock http://dummy > /dev/null || RC=0; \"\n                  \"done; exit $RC' cockpit-ws\" % n_opt)\n\n        for type_ in [\"socket\", \"service\"]:\n            active = int(m.execute(\"systemctl --no-legend list-units -t %s --state=active \"\n                                   \"'cockpit-wsinstance-https@*' | wc -l\" % type_).strip())\n            self.assertGreater(active, 45)\n            self.assertLess(active, 110)\n        failed = int(m.execute(\"systemctl --no-legend list-units --state=failed 'cockpit-wsinstance-https@*' | wc -l\").strip())\n        self.assertGreater(failed, 0)\n        self.assertLess(failed, 75)  # services and sockets\n\n        self.allow_journal_messages(\".*cockpit-ws.*dumped core.*\")\n        self.allow_journal_messages(\".*Error creating thread: Resource temporarily unavailable.*\")\n\n        # initial instance still works\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --show-error -k --head https://127.0.0.1:9090\"))\n\n        # can launch new instances after freeing up some old ones\n        m.execute(\"systemctl stop cockpit-wsinstance-https@30 cockpit-wsinstance-https@31 cockpit-wsinstance-https@32\")\n        m.execute(\"echo -n new | nc %s -U /run/cockpit/wsinstance/https-factory.sock\" % n_opt)\n        out = m.execute(\"curl --silent --show-error --head --unix /run/cockpit/wsinstance/https@new.sock http://dummy\")\n        self.assertIn(\"HTTP/1.1 200 OK\", out)\n\n    @skipBrowser(\"Firefox needs proper cert and CA\", \"firefox\")\n    def testTls(self):\n        m = self.machine\n        b = self.browser\n\n        # Start Cockpit with TLS\n        m.start_cockpit(tls=True)\n\n        # A normal TLS connection works\n        output = m.execute('openssl s_client -connect 172.27.0.15:9090 2>&1')\n        m.message(output)\n        self.assertIn(\"DONE\", output)\n\n        # has proper keyUsage and SAN (both with sscg and with self-signed)\n        output = m.execute(\"openssl s_client -showcerts -connect 172.27.0.15:9090 |\"\n                           \"openssl x509 -noout -ext keyUsage,extendedKeyUsage,subjectAltName\")\n        # keyUsage\n        self.assertIn(\"Digital Signature\", output)\n        self.assertIn(\"Key Encipherment\", output)\n        # extendedKeyUsage\n        self.assertIn(\"TLS Web Server Authentication\", output)\n        # SAN\n        self.assertIn(\"IP Address:127.0.0.1\", output)\n        self.assertIn(\"DNS:localhost\", output)\n\n        # SSLv3 should not work\n        output = m.execute('openssl s_client -connect 172.27.0.15:9090 -ssl3 2>&1 || true')\n        self.assertNotIn(\"DONE\", output)\n\n        # Some operating systems fail SSL3 on the server side\n        self.assertRegex(output, \"Secure Renegotiation IS NOT supported|\"\n                         \"ssl handshake failure|\"\n                         \"[uU]nknown option.* -ssl3|\"\n                         \"null ssl method passed|\"\n                         \"wrong version number\")\n\n        # RC4 should not work\n        output = m.execute('! openssl s_client -connect 172.27.0.15:9090 -tls1_2 -cipher RC4 2>&1')\n        self.assertNotIn(\"DONE\", output)\n        self.assertRegex(\n            output, r\"no cipher match|no ciphers available|ssl handshake failure|Cipher is \\(NONE\\)\")\n\n        # get along with read-only config directory, as long as certificate exists\n        # this does not work on coreos as the user/group IDs are not mapped correctly\n        if not m.ostree_image:\n            m.stop_cockpit()\n            m.execute(\"cp -a /etc/cockpit /tmp; mount -o bind -r /tmp/cockpit /etc/cockpit\")\n            m.start_cockpit(tls=True)\n            self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl -k --head https://127.0.0.1:9090\"))\n            m.execute(\"umount /etc/cockpit\")\n\n        # Install a certificate chain, and make it accessible for cockpit\n        m.upload([\"verify/files/cert-chain.cert\"], \"/etc/cockpit/ws-certs.d\")\n        m.execute(\"cd /etc/cockpit/ws-certs.d; chgrp cockpit-ws cert-chain.cert; ! selinuxenabled || chcon --type etc_t cert-chain.cert\")\n\n        def check_cert_chain():\n            # This should also reset the file context\n            m.restart_cockpit()\n            output = m.execute('openssl s_client -connect 172.27.0.15:9090 2>&1')\n            self.assertIn(\"DONE\", output)\n            self.assertRegex(output, \"s:/?CN *= *localhost\")\n            self.assertRegex(output, \"1 s:/?OU *= *Intermediate\")\n\n        check_cert_chain()\n\n        # *.crt file also works\n        m.execute(\"mv /etc/cockpit/ws-certs.d/cert-chain.cert /etc/cockpit/ws-certs.d/cert-chain.crt\")\n        check_cert_chain()\n\n        # separate *.key file instead of merged .cert\n        m.execute(\"sed -n '/---BEGIN PRIVATE KEY/,$ p' /etc/cockpit/ws-certs.d/cert-chain.crt > /etc/cockpit/ws-certs.d/cert-chain.key\")\n        m.execute(\"sed -i '/---BEGIN PRIVATE KEY/,$ d' /etc/cockpit/ws-certs.d/cert-chain.crt\")\n        check_cert_chain()\n\n        # login handler: correct password\n        m.execute(\"curl -k -c cockpit.jar -s --head --header 'Authorization: Basic {}' https://127.0.0.1:9090/cockpit/login\".format(\n            base64.b64encode(b\"admin:foobar\").decode(), ))\n        headers = m.execute(\"curl -k --head -b cockpit.jar -s https://127.0.0.1:9090/\")\n        self.assertIn(\n            \"default-src 'self' https://127.0.0.1:9090; connect-src 'self' https://127.0.0.1:9090 wss://127.0.0.1:9090\", headers)\n        self.assertIn(\"Access-Control-Allow-Origin: https://127.0.0.1:9090\", headers)\n        # CORP is also set for dynamic paths\n        self.assertIn(\"Cross-Origin-Resource-Policy: same-origin\", headers)\n\n        self.allow_journal_messages(\n            \".*Peer failed to perform TLS handshake\",\n            \".*Peer sent fatal TLS alert:.*\",\n            \".*invalid base64 data in Basic header\",\n            \".*Error performing TLS handshake: No supported cipher suites have been found.\",\n            \".*Error performing TLS handshake: Could not negotiate a supported cipher suite.\")\n\n        # check the Debian smoke test\n        m.upload([\"../tools/debian/tests/smoke\"], \"/tmp\")\n        m.execute(\"/tmp/smoke\")\n\n        b.ignore_ssl_certificate_errors(True)\n        self.login_and_go(\"/system\", tls=True)\n        cookie = b.cookie(\"cockpit\")\n        # cookie should be marked as secure\n        self.assertTrue(cookie[\"httpOnly\"])\n        self.assertTrue(cookie[\"secure\"])\n        self.assertEqual(cookie[\"sameSite\"], \"Strict\")\n        # same after logout\n        b.logout()\n        cookie = b.cookie(\"cockpit\")\n        self.assertEqual(cookie[\"value\"], \"deleted\")\n        self.assertTrue(cookie[\"httpOnly\"])\n        self.assertTrue(cookie[\"secure\"])\n        self.assertEqual(cookie[\"sameSite\"], \"Strict\")\n\n        # http on localhost should not redirect to https\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --head http://127.0.0.1:9090\"))\n        # http on other IP should redirect to https\n        output = m.execute(\"curl --head http://172.27.0.15:9090\")\n        self.assertIn(\"HTTP/1.1 301 Moved Permanently\", output)\n        self.assertIn(\"Location: https://172.27.0.15:9090/\", output)\n        # enable AllowUnencrypted, this disables redirect\n        m.execute('mkdir -p /etc/cockpit/ && echo \"[WebService]\\nAllowUnencrypted=true\" > /etc/cockpit/cockpit.conf')\n        m.restart_cockpit()\n        # now it should not redirect\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --head http://127.0.0.1:9090\"))\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --head http://172.27.0.15:9090\"))\n\n    def testConfigOrigins(self):\n        m = self.machine\n        m.execute(\n            'mkdir -p /etc/cockpit/ && echo \"[WebService]\\nOrigins = http://other-origin:9090 http://localhost:9090\" > /etc/cockpit/cockpit.conf')\n        m.start_cockpit()\n        output = m.execute('curl -s -f -N -H \"Connection: Upgrade\" -H \"Upgrade: websocket\" -H \"Origin: http://other-origin:9090\" -H \"Host: localhost:9090\" -H \"Sec-Websocket-Key: 3sc2c9IzwRUc3BlSIYwtSA==\" -H \"Sec-Websocket-Version: 13\" http://localhost:9090/cockpit/socket')\n        self.assertIn('\"no-session\"', output)\n\n        # The socket should also answer at /socket\n        output = m.execute('curl -s -f -N -H \"Connection: Upgrade\" -H \"Upgrade: websocket\" -H \"Origin: http://other-origin:9090\" -H \"Host: localhost:9090\" -H \"Sec-Websocket-Key: 3sc2c9IzwRUc3BlSIYwtSA==\" -H \"Sec-Websocket-Version: 13\" http://localhost:9090/socket')\n        self.assertIn('\"no-session\"', output)\n\n        self.allow_journal_messages('peer did not close io when expected')\n\n    @skipImage(\"OSTree doesn't use systemd units\", \"fedora-coreos\")\n    def testSocket(self):\n        m = self.machine\n\n        # non-admin user\n        m.execute(\"useradd user\")\n\n        # enable no-password login for 'admin' and 'user'\n        m.execute(\"passwd -d admin\")\n        m.execute(\"passwd -d user\")\n\n        self.sed_file('$ a\\\\\\nPermitEmptyPasswords yes', '/etc/ssh/sshd_config',\n                      'systemctl restart sshd.service')\n\n        def assertInOrNot(string, result, expected):\n            if expected:\n                self.assertIn(string, result)\n            else:\n                self.assertNotIn(string, result)\n\n        def checkMotdForUser(string, user, expected):\n            result = m.execute(f\"ssh -o StrictHostKeyChecking=no -n {user}@localhost\")\n            assertInOrNot(string, result, expected)\n\n        def checkMotdContent(string, expected=True):\n            # Needs https://github.com/linux-pam/linux-pam/pull/292 (or PAM 1.5.0)\n            old_pam = (m.image in ['centos-8-stream', 'debian-stable', 'debian-testing', 'ubuntu-2004', 'ubuntu-stable', 'rhel-8-4', 'rhel-8-5'])\n\n            # check issue (should be exactly the same as motd)\n            assertInOrNot(string, m.execute(\"cat /etc/issue.d/cockpit.issue\"), expected)\n\n            # check motd as 'root' (via cat) and 'admin' and 'user' (via ssh)\n            assertInOrNot(string, m.execute(\"cat /etc/motd.d/cockpit\"), expected)\n            checkMotdForUser(string, expected=expected, user='admin')\n            checkMotdForUser(string, expected=old_pam and expected or False, user='user')\n\n        checkMotdContent('systemctl')\n        checkMotdContent(':9090/', expected=False)\n        m.start_cockpit()\n\n        checkMotdContent(':9090/')\n        checkMotdContent('systemctl', expected=False)\n        m.execute(\"systemctl stop cockpit.socket\")\n\n        # Change port according to documentation: https://cockpit-project.org/guide/latest/listen.html\n        m.execute('! selinuxenabled || semanage port -m -t websm_port_t -p tcp 443')\n        m.execute(\n            'mkdir -p /etc/systemd/system/cockpit.socket.d/ && printf \"[Socket]\\nListenStream=\\nListenStream=/run/cockpit/sock\\nListenStream=443\" > /etc/systemd/system/cockpit.socket.d/listen.conf')\n\n        checkMotdContent('systemctl')\n        checkMotdContent(':9090/', expected=False)\n        checkMotdContent(':443/', expected=False)\n        m.start_cockpit(tls=True)\n\n        checkMotdContent('systemctl', expected=False)\n        checkMotdContent(':9090/', expected=False)\n        checkMotdContent(':443/')\n\n        output = m.execute('curl -k https://localhost 2>&1 || true')\n        self.assertIn('Loading...', output)\n        output = m.execute('curl -k --unix /run/cockpit/sock https://dummy 2>&1 || true')\n        self.assertIn('Loading...', output)\n\n        output = m.execute('curl -k https://localhost:9090 2>&1 || true')\n        self.assertIn('Connection refused', output)\n\n        self.allow_journal_messages(\".*Peer failed to perform TLS handshake\")\n\n    @skipImage(\"Can't remove/upgrade packages on OSTree\", \"fedora-coreos\")\n    def testWsPackage(self):\n        m = self.machine\n\n        if m.image.startswith(\"debian\") or m.image.startswith(\"ubuntu\"):\n            # clean up debug symbols, they get in the way of upgrading\n            m.execute(\"dpkg --purge cockpit-ws-dbgsym\")\n        elif m.image.startswith(\"rhel\"):\n            # subscription-manager-cockpit depends on cockpit-ws\n            m.execute(\"rpm --erase subscription-manager-cockpit\")\n\n        def install():\n            if m.image.startswith(\"debian\") or m.image.startswith(\"ubuntu\"):\n                m.execute(\"dpkg --install /var/tmp/build-results/cockpit-ws_*.deb\")\n            else:\n                m.execute(\"if rpm -q cockpit-ws; then rpm --verify cockpit-ws; fi\")\n                m.execute(\"rpm --upgrade --force /var/tmp/build-results/cockpit-ws-*.rpm\")\n                m.execute(\"rpm --verify cockpit-ws\")\n\n        def remove():\n            if m.image.startswith(\"debian\") or m.image.startswith(\"ubuntu\"):\n                m.execute(\"dpkg --purge cockpit cockpit-ws\")\n            else:\n                m.execute(\"rpm --erase cockpit cockpit-ws\")\n\n        # upgrade from distro version (our images have cockpit-ws preinstalled) sets up dynamic motd/issue symlink\n        self.assertEqual(m.execute(\"readlink /etc/motd.d/cockpit\").strip(), \"/run/cockpit/motd\")\n        self.assertEqual(m.execute(\"readlink /etc/issue.d/cockpit.issue\").strip(), \"/run/cockpit/motd\")\n\n        # package upgrade keeps them\n        install()\n        self.assertEqual(m.execute(\"readlink /etc/motd.d/cockpit\").strip(), \"/run/cockpit/motd\")\n        self.assertEqual(m.execute(\"readlink /etc/issue.d/cockpit.issue\").strip(), \"/run/cockpit/motd\")\n\n        # manual change/removal is respected on upgrade\n        m.execute(\"ln -sf /dev/null /etc/motd.d/cockpit; rm /etc/issue.d/cockpit.issue\")\n        install()\n        self.assertEqual(m.execute(\"readlink /etc/motd.d/cockpit\").strip(), \"/dev/null\")\n        m.execute(\"test ! -e /etc/issue.d/cockpit.issue\")\n\n        # removing the package cleans up the links\n        remove()\n        m.execute(\"test ! -e /etc/motd.d/cockpit\")\n        m.execute(\"test ! -e /etc/issue.d/cockpit.issue\")\n\n        # fresh install (most of our test images have cockpit-ws preinstalled, so the first test above does not cover that)\n        install()\n        self.assertEqual(m.execute(\"readlink /etc/motd.d/cockpit\").strip(), \"/run/cockpit/motd\")\n        self.assertEqual(m.execute(\"readlink /etc/issue.d/cockpit.issue\").strip(), \"/run/cockpit/motd\")\n\n    @skipImage(\"OSTree doesn't have cockpit-ws\", \"fedora-coreos\")\n    def testCommandline(self):\n        m = self.machine\n\n        # Large requests are processed correctly with plain HTTP through cockpit-tls\n        m.start_cockpit(tls=True)\n        self.assertIn('id=\"login\"', m.execute('''curl -s -S -H \"Authorization: Negotiate $(printf '%0.7000i' 1)\" http://localhost:9090/'''))\n\n        # Large requests are processed correctly with TLS through cockpit-tls\n        self.assertIn('id=\"login\"', m.execute('''curl -s -S -k -H \"Authorization: Negotiate $(printf '%0.7000i' 1)\" https://localhost:9090/'''))\n        m.stop_cockpit()\n\n        self.restore_dir(\"/etc/cockpit\")\n        m.execute(\"rm -f /etc/cockpit/ws-certs.d/* /etc/cockpit/cockpit.conf\")\n        m.write(\"/etc/cockpit/cockpit.conf\", \"[WebService]\\nLoginTitle = A Custom Title\\n\")\n\n        m.execute(f\"{self.libexecdir}/cockpit-certificate-ensure\")\n        self.assertTrue(m.execute(\"ls /etc/cockpit/ws-certs.d/*\"))\n\n        m.execute(f\"{self.ws_executable} --port 9000 --address 127.0.0.1 0<&- &>/dev/null &\")\n\n        # The port may not be available immediately, so wait for it\n        wait(lambda: 'A Custom Title' in m.execute('curl -s -k https://localhost:9000/'))\n\n        output = m.execute('curl -s -S -k https://172.27.0.15:9000/ 2>&1 || true')\n        self.assertIn('Connection refused', output)\n\n        # Large requests are processed correctly with plain HTTP\n        self.assertIn('A Custom Title', m.execute('''curl -s -S -H \"Authorization: Negotiate $(printf '%0.7000i' 1)\" http://localhost:9000/'''))\n\n        # Large requests are processed correctly with TLS\n        self.assertIn('A Custom Title', m.execute('''curl -s -S -k -H \"Authorization: Negotiate $(printf '%0.7000i' 1)\" https://localhost:9000/'''))\n\n    def testHeadRequest(self):\n        m = self.machine\n        m.start_cockpit()\n\n        # static handler\n        headers = m.execute(\"curl -s --head http://172.27.0.15:9090/cockpit/static/login.html\")\n        self.assertIn(\"HTTP/1.1 200 OK\\r\\n\", headers)\n        self.assertIn(\"Content-Type: text/html\\r\\n\", headers)\n        self.assertIn(\"Cross-Origin-Resource-Policy: same-origin\\r\\n\", headers)\n        # login.html is not always accessible as a file (e.g. on CoreOS), so just assert a reasonable content length\n        self.assertIn(\"Content-Length: \", headers)\n        length = int(headers.split('Content-Length: ', 1)[1].split()[0])\n        self.assertGreater(length, 5000)\n        self.assertLess(length, 100000)\n\n        # login handler: wrong password\n        headers = m.execute(\"curl -s --head --header 'Authorization: Basic {}' http://172.27.0.15:9090/cockpit/login\".format(\n            base64.b64encode(b\"admin:hahawrong\").decode()))\n        self.assertIn(\"HTTP/1.1 401 Authentication failed\\r\\n\", headers)\n        self.assertNotIn(\"Set-Cookie:\", headers)\n\n        # login handler: correct password\n        headers = m.execute(\"curl -s --head --header 'Authorization: Basic {}' http://172.27.0.15:9090/cockpit/login\".format(\n            base64.b64encode(b\"admin:foobar\").decode()))\n        self.assertIn(\"HTTP/1.1 200 OK\\r\\n\", headers)\n        self.assertIn(\"Set-Cookie: cockpit\", headers)\n\n        # socket handler; this should refuse HEAD (as it makes little sense on sockets), so 404\n        headers = m.execute(\"curl -s --head http://172.27.0.15:9090/cockpit/socket\")\n        self.assertIn(\"HTTP/1.1 404 Not Found\\r\\n\", headers)\n\n        # external channel handler; unauthenticated, thus 404\n        headers = m.execute(\"curl -s --head http://172.27.0.15:9090/cockpit+123/channel/foo\")\n        self.assertIn(\"HTTP/1.1 404 Not Found\\r\\n\", headers)\n\n    @skipImage(\"ssh root login not allowed\", \"fedora-coreos\")\n    def testFlowControl(self):\n        m = self.machine\n        b = self.browser\n\n        self.login_and_go(\"/playground/speed\", user=\"root\")\n\n        # Check the speed playground page\n        b.switch_to_top()\n        b.go(\"/playground/speed\")\n        b.enter_page(\"/playground/speed\")\n\n        b.wait_text_not(\"#pid\", \"\")\n        pid = b.text(\"#pid\")\n\n        b.set_val(\"#read-path\", \"/dev/vda\")\n        b.click(\"#read-sideband\")\n\n        b.wait_text_not(\"#speed\", \"\")\n        time.sleep(20)\n        output = m.execute(\"cat /proc/{}/statm\".format(pid))\n        rss = int(output.split(\" \")[0])\n\n        # This fails when flow control is not present\n        self.assertLess(rss, 250000)\n\n    @skipImage(\"OSTree doesn't have cockpit-ws\", \"fedora-coreos\")\n    def testLocalSession(self):\n        m = self.machine\n\n        # start ws with --local-session, let it spawn bridge; ensure that this works without /etc/cockpit/\n        m.spawn(\"su - -c 'G_MESSAGES_DEBUG=all XDG_CONFIG_DIRS=/usr/local %s -p 9999 -a 127.0.0.90 \"\n                \"--local-session=cockpit-bridge' admin\" % self.ws_executable,\n                \"cockpit-ws-local\")\n        m.wait_for_cockpit_running('127.0.0.90', 9999)\n        # System frame should work directly, no login page\n        out = m.execute(\"curl --compressed http://127.0.0.90:9999/cockpit/@localhost/system/index.html\")\n        self.assertIn('id=\"overview\"', out)\n\n        # shut it down, wait until it is gone\n        m.execute(\"pkill -ef cockpit-ws\")\n\n        # start ws with --local-session and existing running bridge\n        script = '''#!/bin/bash -eu\ncoproc env G_MESSAGES_DEBUG=all cockpit-bridge\nG_MESSAGES_DEBUG=all XDG_CONFIG_DIRS=/usr/local %s -p 9999 -a 127.0.0.90 --local-session=- <&${COPROC[0]} >&${COPROC[1]}\n''' % self.ws_executable\n        m.execute([\"tee\", \"/tmp/local.sh\"], input=script)\n        m.execute(\"chmod a+x /tmp/local.sh\")\n        m.spawn(\"su - -c /tmp/local.sh admin\", \"local.sh\")\n        m.wait_for_cockpit_running('127.0.0.90', 9999)\n\n        # System frame should work directly, no login page\n        out = m.execute(\"curl --compressed http://127.0.0.90:9999/cockpit/@localhost/system/index.html\")\n        self.assertIn('id=\"overview\"', out)\n\n        self.allow_journal_messages(\"couldn't register polkit authentication agent.*\")\n\n    @skipImage(\"OSTree doesn't have cockpit-ws\", \"fedora-coreos\")\n    @skipImage(\"Kernel does not allow user namespaces\", \"debian-stable\", \"debian-testing\")\n    def testCockpitDesktop(self):\n        m = self.machine\n\n        cases = [(['/cockpit/@localhost/system/index.html', 'system', 'system/index', 'system/'],\n                  ['id=\"overview\"']\n                  ),\n                 (['/cockpit/@localhost/network/firewall.html', 'network/firewall'],\n                  ['div id=\"firewall\"', 'script src=\"firewall.js\"']\n                  ),\n                 (['/cockpit/@localhost/playground/react-patterns.html', 'playground/react-patterns'],\n                  ['script src=\"react-patterns.js\"']\n                  ),\n                 # no ssh host\n                 (['/cockpit/@localhost/manifests.json'],\n                  ['\"system\"', '\"Overview\"']\n                  ),\n                 # remote ssh host\n                 (['/cockpit/@localhost/manifests.json test1@localhost'],\n                  ['\"system\"', '\"Overview\"', '\"HACK\"']\n                  )\n                 ]\n\n        # prepare fake ssh target; to verify that we really use that, fake dashboard manifest\n        m.execute(\"\"\"set -e; useradd test1\n                  [ -f ~admin/.ssh/id_rsa ] || su -c \"ssh-keygen -t rsa -N '' -f ~/.ssh/id_rsa\" admin\n                  mkdir -p ~test1/.ssh ~test1/.local/share/cockpit/dashboard\n                  echo '{ \"version\": \"42\", \"dashboard\": { \"index\": { \"label\": \"HACK\" } } }' > ~test1/.local/share/cockpit/dashboard/manifest.json\n                  cp ~admin/.ssh/id_rsa.pub ~test1/.ssh/authorized_keys\n                  ssh-keyscan localhost >> ~admin/.ssh/known_hosts\n                  chown admin:admin ~admin/.ssh/known_hosts\n                  chown -R test1:test1 ~test1\n                  su -c \"ssh test1@localhost cockpit-bridge --packages\" admin | grep -q test1.*dashboard  # validate setup\n                  \"\"\")\n\n        for (pages, asserts) in cases:\n            for page in pages:\n                m.execute(f'''su - -c 'BROWSER=\"curl --silent --compressed -o /tmp/out.html\" {self.libexecdir}/cockpit-desktop {page}' admin''')\n\n                out = m.execute(\"cat /tmp/out.html\")\n                for a in asserts:\n                    self.assertIn(a, out)\n\n                # should clean up processes\n                self.assertEqual(m.execute(\"! pgrep -a cockpit-ws && ! pgrep -a cockpit-bridge\"), \"\")\n\n        # cockpit-desktop can start a privileged bridge through polkit\n        # we don't have an agent, so just allow the privilege without interactive authentication\n        m.write(\"/etc/polkit-1/localauthority/50-local.d/test.pkla\", r\"\"\"\n[Testing without an agent]\nIdentity=unix-user:admin\nAction=org.cockpit-project.cockpit.root-bridge\nResultAny=yes\nResultInactive=yes\nResultActive=yes\"\"\")\n        m.write(r\"/tmp/browser.sh\", \"\"\"#!/bin/sh -e\ncurl --silent --compressed -o /tmp/out.html \"$@\"\n# wait until privileged bridge starts\nuntil pgrep -f cockpit-bridge.*--privileged; do sleep 1; done\n\"\"\")\n        m.execute(\"chmod 755 /tmp/browser.sh\")\n        m.execute(f\"su - -c 'BROWSER=/tmp/browser.sh {self.libexecdir}/cockpit-desktop system' admin\")\n        self.assertIn('id=\"overview\"', m.execute(\"cat /tmp/out.html\"))\n\n        self.allow_journal_messages(\"couldn't register polkit authentication agent.*\")\n        self.allow_journal_messages(\"Refusing to render service to dead parents.\")\n        self.allow_journal_messages(\".*No authentication agent found.*\")\n        self.allow_journal_messages(\".*Peer failed to perform TLS handshake.*\")\n        self.allow_journal_messages(r\".*cannot reauthorize identity\\(s\\): unix-user:.*\")\n\n    @skipBrowser(\"Firefox needs proper cert and CA\", \"firefox\")\n    def testReverseProxy(self):\n        m = self.machine\n        b = self.browser\n\n        self.ostree_setup_ws()\n\n        # set up a poor man's reverse TLS proxy with socat\n        m.upload([\"../src/bridge/mock-server.crt\", \"../src/bridge/mock-server.key\"], \"/tmp\")\n        m.spawn(\"socat OPENSSL-LISTEN:9090,reuseaddr,fork,cert=/tmp/mock-server.crt,\"\n                \"key=/tmp/mock-server.key,verify=0 TCP:localhost:9099\",\n                \"socat-tls.log\")\n\n        # and another proxy for plain http\n        m.spawn(\"socat TCP-LISTEN:9091,reuseaddr,fork TCP:localhost:9099\", \"socat.log\")\n\n        # ws with plain --no-tls should fail after login with mismatching Origin (expected http, got https)\n        m.spawn(\"su -s /bin/sh -c '%s --no-tls -p 9099' cockpit-wsinstance\" % self.ws_executable,\n                \"ws-notls.log\")\n        m.wait_for_cockpit_running(tls=True)\n\n        b.ignore_ssl_certificate_errors(True)\n        b.open(\"https://%s:%s/system\" % (b.address, b.port))\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load()\n\n        def check_wss_log():\n            for log in self.browser.get_js_log():\n                if 'Error during WebSocket handshake: Unexpected response code: 403' in log:\n                    return True\n            return False\n        wait(check_wss_log)\n\n        wait(lambda: m.execute(\"grep 'received request from bad Origin' /var/log/ws-notls.log\"))\n\n        # sanity check: unencrypted http through SSL proxy does not work\n        m.execute(\"! curl http://localhost:9090\")\n\n        # does not redirect to https (through plain http proxy)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9091\"))\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://172.27.0.15:9091\"))\n\n        m.execute(\"pkill -e cockpit-ws; while pgrep -a cockpit-ws; do sleep 1; done\")\n        # this page failure is reeally noisy\n        self.allow_restart_journal_messages()\n        self.allow_journal_messages(\".*No authentication agent found.*\")\n        self.allow_journal_messages(\"couldn't register polkit authentication agent.*\")\n        self.allow_journal_messages(\"received request from bad Origin.*\")\n        self.allow_journal_messages(\".*invalid handshake.*\")\n        self.allow_browser_errors(\".*received unsupported version in init message.*\")\n        self.allow_browser_errors(\".*received message before init.*\")\n        self.allow_browser_errors(\"Error reading machine id\")\n\n        # ws with --for-tls-proxy accepts only https origins, thus should work\n        m.spawn(\"su -s /bin/sh -c '%s --for-tls-proxy -p 9099 -a 127.0.0.1' cockpit-wsinstance\" % self.ws_executable,\n                \"ws-fortlsproxy.log\")\n        m.wait_for_cockpit_running(tls=True)\n        b.open(\"https://%s:%s/system\" % (b.address, b.port))\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load()\n        b.wait_visible('#content')\n        b.enter_page(\"/system\")\n        # cookie should be marked as secure, as for the browser it's https\n        cookie = b.cookie(\"cockpit\")\n        self.assertTrue(cookie[\"httpOnly\"])\n        self.assertTrue(cookie[\"secure\"])\n        b.logout()\n        # deleted cookie after logout should be marked as secure\n        cookie = b.cookie(\"cockpit\")\n        self.assertEqual(cookie[\"value\"], \"deleted\")\n        self.assertTrue(cookie[\"httpOnly\"])\n        self.assertTrue(cookie[\"secure\"])\n\n        # should have https:// URLs in Content-Security-Policy\n        out = m.execute(\"curl --insecure --head https://localhost:9090/\")\n        self.assertIn(\"Content-Security-Policy: connect-src 'self' https://localhost:9090 wss://localhost:9090;\", out)\n\n        # sanity check: does not redirect to https (through plain http proxy) -- this isn't a supported mode, though!\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9091\"))\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://172.27.0.15:9091\"))\n\n        # ws with --proxy-tls-redirect redirects non-localhost to https\n        m.execute(\"pkill -e cockpit-ws; while pgrep -a cockpit-ws; do sleep 1; done\")\n        m.spawn(\"su -s /bin/sh -c '%s --proxy-tls-redirect --no-tls -p 9099 -a 127.0.0.1' cockpit-wsinstance\" % self.ws_executable,\n                \"ws-proxy-tls-redirect.log\")\n        m.wait_for_cockpit_running(tls=True)\n        self.assertIn(\"HTTP/1.1 301 Moved Permanently\", m.execute(\"curl --silent --head http://172.27.0.15:9091\"))\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9091\"))\n\n    def testCaCert(self):\n        m = self.machine\n\n        m.start_cockpit()\n        if not m.ostree_image:\n            # Really start Cockpit to make sure it has generated all its certificates.\n            m.execute(\"systemctl start cockpit\")\n\n        # Start without a CA certificate.\n        m.execute(\"rm -f /etc/cockpit/ws-certs.d/0-self-signed-ca.pem\")\n        m.execute(\"! curl -sfS http://localhost:9090/ca.cer\")\n\n        # Now make one up and check that is is served.\n        m.write(\"/etc/cockpit/ws-certs.d/0-self-signed-ca.pem\", \"FAKE CERT FOR TESTING\\n\")\n        self.assertEqual(m.execute(\"curl -sfS http://localhost:9090/ca.cer\"), \"FAKE CERT FOR TESTING\\n\")\n\n\n@skipDistroPackage()\nclass TestReverseProxy(MachineCase):\n\n    provision = {\n        \"0\": {\"forward\": {\"443\": 8443}}\n    }\n\n    def setUp(self):\n        super().setUp()\n        m = self.machine\n\n        m.execute(\"if firewall-cmd --state >/dev/null 2>&1; then firewall-cmd --add-service https; fi\")\n\n        m.upload([\"../src/tls/ca/alice.pem\", \"../src/tls/ca/alice.key\"], \"/etc/pki\")\n\n        m.write(\"/etc/cockpit/cockpit.conf\", \"\"\"[WebService]\nOrigins = https://%(origin)s wss://%(origin)s\nProtocolHeader = X-Forwarded-Proto\n\"\"\" % {\"origin\": m.forward[\"443\"]}, append=True)\n\n        m.execute(\"setsebool -P httpd_can_network_connect on\")\n        self.allow_journal_messages(\"audit.*bool=httpd_can_network_connect.*val=1.*\")\n\n    def checkCockpitOnProxy(self, urlroot=\"\"):\n        b = self.browser\n\n        # should use nginx' certificate, not cockpit's; use --resolve so that SNI matches the certificate's CN\n        (https_host, https_port) = self.machine.forward[\"443\"].split(':')\n        out = subprocess.check_output(\n            [\"curl\", \"--verbose\", \"--head\",\n             \"--resolve\", f\"alice:{https_port}:{https_host}\",\n             \"--cacert\", os.path.join(TEST_DIR, \"../src/tls/ca/ca.pem\"),\n             f\"https://alice:{https_port}{urlroot}/cockpit/static/login.html\"],\n            stderr=subprocess.STDOUT)\n        self.assertIn(b\"HTTP/1.1 200 OK\", out)\n        self.assertIn(b\"subject: CN=alice; DC=COCKPIT\", out)\n\n        # works with browser (but we can't set our CA)\n        b.ignore_ssl_certificate_errors(True)\n        b.open(f\"https://{https_host}:{https_port}{urlroot}/system\")\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load()\n        b.wait_visible('#content')\n        b.logout()\n\n        self.allow_restart_journal_messages()\n\n    @skipImage(\"nginx not installed\", \"centos-8-stream\", \"debian-stable\", \"debian-testing\", \"fedora-coreos\",\n               \"rhel-8-4\", \"rhel-8-5\", \"rhel-9-0\", \"ubuntu-stable\", \"ubuntu-2004\")\n    @skipBrowser(\"Firefox needs proper cert and CA\", \"firefox\")\n    def testNginxTLS(self):\n        '''test proxying to Cockpit with TLS\n\n        As described on https://github.com/cockpit-project/cockpit/wiki/Proxying-Cockpit-over-NGINX\n        This use use case is important for proxying a remote machine.\n        '''\n        m = self.machine\n\n        m.write(\"/etc/nginx/conf.d/cockpit.conf\", \"\"\"\nserver {\n    listen 443 ssl;\n    server_name %(origin)s;\n    root /srv/www;\n\n    ssl_certificate \"/etc/pki/alice.pem\";\n    ssl_certificate_key \"/etc/pki/alice.key\";\n\n    location / {\n        # Required to proxy the connection to Cockpit\n        proxy_pass https://127.0.0.1:9090;\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # Required for web sockets to function\n        proxy_http_version 1.1;\n        proxy_buffering off;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n\n        # Pass ETag header from Cockpit to clients.\n        # See: https://github.com/cockpit-project/cockpit/issues/5239\n        gzip off;\n    }\n}\n\"\"\" % {\"origin\": m.forward[\"443\"]})\n\n        m.execute(\"systemctl start nginx\")\n        m.start_cockpit(tls=True)\n        self.checkCockpitOnProxy()\n\n        # now test with UrlRoot\n        m.write(\"/etc/cockpit/cockpit.conf\", \"UrlRoot = cockpit-root\\n\", append=True)\n        m.execute(\"systemctl stop cockpit.service\")\n        self.sed_file(\"s_location /_location /cockpit-root_\", \"/etc/nginx/conf.d/cockpit.conf\",\n                      \"systemctl restart nginx\")\n        self.checkCockpitOnProxy(urlroot=\"/cockpit-root\")\n\n        # get a non-cockpit file from the server\n        m.execute(\"mkdir -p /srv/www/embed-cockpit\")\n        m.upload([\"verify/files/embed-cockpit/index.html\",\n                  \"verify/files/embed-cockpit/embed.js\",\n                  \"verify/files/embed-cockpit/embed.css\"],\n                 \"/srv/www/embed-cockpit/\")\n        m.execute(\"if selinuxenabled 2>&1; then chcon -R -t httpd_sys_content_t /srv/www; fi\")\n\n        (https_host, https_port) = self.machine.forward[\"443\"].split(':')\n        out = subprocess.check_output(\n            [\"curl\", \"--verbose\",\n             \"--resolve\", f\"alice:{https_port}:{https_host}\",\n             \"--cacert\", os.path.join(TEST_DIR, \"../src/tls/ca/ca.pem\"),\n             f\"https://alice:{https_port}/embed-cockpit/embed.css\"],\n            stderr=subprocess.STDOUT)\n        self.assertIn(b\"HTTP/1.1 200 OK\", out)\n        self.assertIn(b\"#embed-links\", out)\n\n        # embedding\n        b = self.browser\n        b.ignore_ssl_certificate_errors(True)\n        b.open(f\"https://{https_host}:{https_port}/embed-cockpit/index.html\")\n        b.set_val(\"#embed-address\", f\"https://{https_host}:{https_port}/cockpit-root\")\n        b.click(\"#embed-full\")\n        b.wait_visible(\"iframe[name='embed-full'][loaded]\")\n        b.switch_to_frame(\"embed-full\")\n\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load_frame(\"embed-full\")\n        b.wait_visible('article.system-health')\n\n    @skipImage(\"nginx not installed\", \"centos-8-stream\", \"debian-stable\", \"debian-testing\", \"fedora-coreos\",\n               \"rhel-8-4\", \"rhel-8-5\", \"rhel-9-0\", \"ubuntu-stable\", \"ubuntu-2004\")\n    @skipBrowser(\"Firefox needs proper cert and CA\", \"firefox\")\n    def testNginxNoTLS(self):\n        '''test proxying to Cockpit with plain HTTP\n\n        This can be done when nginx and cockpit run on the same machine.\n        '''\n        m = self.machine\n\n        m.write(\"/etc/nginx/conf.d/cockpit.conf\", \"\"\"\nserver {\n    listen 443 ssl;\n    server_name %(origin)s;\n\n    ssl_certificate \"/etc/pki/alice.pem\";\n    ssl_certificate_key \"/etc/pki/alice.key\";\n\n    location / {\n        # Required to proxy the connection to Cockpit\n        proxy_pass http://127.0.0.1:9090;\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # Required for web sockets to function\n        proxy_http_version 1.1;\n        proxy_buffering off;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n\n        # Pass ETag header from Cockpit to clients.\n        # See: https://github.com/cockpit-project/cockpit/issues/5239\n        gzip off;\n    }\n}\n\"\"\" % {\"origin\": m.forward[\"443\"]})\n\n        m.execute(\"systemctl start nginx\")\n\n        # start cockpit-ws in proxy mode, skip all the ws-certs.d/ steps\n        m.spawn(f\"su -s /bin/sh -c '{self.libexecdir}/cockpit-ws --address=127.0.0.1 --for-tls-proxy' cockpit-wsinstance\", \"ws.log\")\n        m.wait_for_cockpit_running()\n\n        self.checkCockpitOnProxy()\n\n        self.allow_journal_messages(\"couldn't register polkit authentication agent.*\")\n\n\nif __name__ == '__main__':\n    test_main()\n", "#! /usr/bin/python3\n\n# This file is part of Cockpit.\n#\n# Copyright (C) 2013 Red Hat, Inc.\n#\n# Cockpit is free software; you can redistribute it and/or modify it\n# under the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation; either version 2.1 of the License, or\n# (at your option) any later version.\n#\n# Cockpit is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\nimport subprocess\n\nimport parent\nfrom testlib import *\n\n\n@skipDistroPackage()\n@nondestructive\nclass TestEmbed(MachineCase):\n\n    def testBasic(self):\n        b = self.browser\n        m = self.machine\n\n        self.restore_dir(\"/home/admin/.local/share/cockpit\")\n        m.execute(\"mkdir -p /home/admin/.local/share/cockpit/embed-cockpit\")\n        m.upload([\"verify/files/embed-cockpit/index.html\",\n                  \"verify/files/embed-cockpit/embed.js\",\n                  \"verify/files/embed-cockpit/embed.css\",\n                  \"verify/files/embed-cockpit/manifest.json\"],\n                 \"/home/admin/.local/share/cockpit/embed-cockpit/\")\n\n        # replace the shell with our embedded page, this way we can avoid\n        # cross-origin errors when executing js in the iframe\n        m.write(\"/etc/cockpit/cockpit.conf\", \"\"\"\n[WebService]\nShell=/embed-cockpit/index.html\n\"\"\")\n        m.start_cockpit()\n        self.login_and_go()\n\n        b.wait_visible(\"#embed-loaded\")\n        b.wait_visible(\"#embed-address\")\n        m.write(\"/etc/cockpit/cockpit.conf\", \"\"\"\n[WebService]\nShell=/shell/index.html\n\"\"\")\n        b.set_val(\"#embed-address\", \"http://{0}:{1}\".format(m.web_address, m.web_port))\n        b.click(\"#embed-full\")\n        b.wait_visible(\"iframe[name='embed-full'][loaded]\")\n        b.switch_to_frame(\"embed-full\")\n        b.wait_visible(\"#system_information_os_text\")\n\n        # Page should show automatically now that other frame logged in\n        b.switch_to_top()\n        b.click(\"#embed-terminal\")\n        b.wait_visible(\"iframe[name='embed-terminal'][loaded]\")\n        b.switch_to_frame(\"embed-terminal\")\n        b.wait_visible(\"#terminal\")\n\n        # Clicking on the link with separate auth, shouldn't log in automatically\n        b.switch_to_top()\n        b.click(\"#embed-auth\")\n        b.wait_visible(\"iframe[name='embed-auth'][loaded]\")\n        b.switch_to_frame(\"embed-auth\")\n        b.wait_visible(\"#login-user-input\")\n\n    @skipBrowser(\"Chromium cannot inspect cross-origin frames\", \"chromium\")\n    def testCrossOrigin(self):\n        b = self.browser\n        m = self.machine\n\n        pyhttpd = subprocess.Popen(['python3', '-m', 'http.server', '--bind=localhost',\n                                    '--directory=test/verify/files/embed-cockpit', '12346'])\n\n        def clean_pyhttpd():\n            pyhttpd.terminate()\n            pyhttpd.wait()\n\n        self.addCleanup(clean_pyhttpd)\n\n        # log in normally, to get the auth cookie into the browser and thus maximize possible cross-domain exposure\n        self.login_and_go()\n\n        b.open(\"http://localhost:12346/index.html\")\n        b.set_val(\"#embed-address\", \"http://{0}:{1}\".format(m.web_address, m.web_port))\n        b.click(\"#embed-full\")\n        # FIXME (#16122): we should not even get that far, frame loading should already be blocked here\n        b.wait_visible(\"iframe[name='embed-full'][loaded]\")\n        b.switch_to_frame(\"embed-full\")\n\n        # second line of defense: existing login cookie does not work (default browser protection)\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load_frame(\"embed-full\")\n\n        # third line of defense: login succeeds and creates a PAM session; but loading session UI does not\n        # (again, due to default browser protection)\n        b.wait_visible(\"#login\")\n\n\nif __name__ == '__main__':\n    test_main()\n"], "fixing_code": ["<?xml version=\"1.0\"?>\n<!DOCTYPE chapter PUBLIC \"-//OASIS//DTD DocBook XML V4.3//EN\"\n\t\"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd\">\n<chapter id=\"embedding\">\n  <title>Embedding and Integrating Cockpit</title>\n\n  <para>Cockpit can be embedded in other web applications either as a whole or specific\n    Cockpit components can be integrated. Due to frame security policy restrictions,\n    this only works if Cockpit and the web application have the <emphasis>same origin</emphasis>;\n    this is commonly achieved by running both from a common reverse proxy.</para>\n\n  <section id=\"embedding-full\">\n    <title>Embedding the Cockpit Interface</title>\n\n    <para>Cockpit can be embedded into a larger web page as a frame. To embed\n      the entire Cockpit Window use the URI:\n      <code>https://server.example.com:9090/</code></para>\n\n    <programlisting language=\"html\"><![CDATA[\n<html>\n  <head>\n    <title>Embedded Cockpit</title>\n  </head>\n  <body>\n    This is Cockpit.\n    <br/>\n    <iframe width=\"800px\" height=\"600px\"\n            src=\"https://server.example.com:9090/\"/>\n  </body>\n</html>\n]]></programlisting>\n\n  </section>\n\n  <section id=\"embedding-components\">\n    <title>Integrating Cockpit Components into Web Applications</title>\n\n    <para>Instead of embedding the entirety of Cockpit, you can integrate specific components.\n      Only those components explicitly documented as API should be integrated. Other components\n      can and will change regularly.</para>\n\n    <para>The component will load from the server in question and a WebSocket connection\n      will be established with the server to relay the component's message stream.</para>\n\n    <para>Cockpit components are HTML files contained in\n      <link linkend=\"packages\">packages</link>. These can be placed in an iframe or web browser\n      window. Each documented and stable component has a well-known URL and these are documented\n      in the <link linkend=\"development\">API reference</link>. Each component URL begins with the string\n      <code>/cockpit/@localhost/</code> followed a package name, and then the component itself.</para>\n\n    <para>For example the\n      <link linkend=\"api-terminal-html\">terminal.html</link> in the\n      <link linkend=\"api-system\">system</link> package, has this URL:\n      <code>/cockpit/@localhost/system/terminal.html</code></para>\n\n    <programlisting language=\"html\"><![CDATA[\n<html>\n  <head>\n    <title>Embedded Terminal</title>\n  </head>\n  <body>\n    This is a terminal.\n    <br/>\n    <iframe width=\"800px\" height=\"600px\"\n      src=\"https://server.example.com:9090/cockpit/@localhost/system/terminal.html\"/>\n  </body>\n</html>\n]]></programlisting>\n\n  </section>\n\n  <section id=\"embedding-deep\">\n    <title>Deep Integration</title>\n\n    <para>Most often <link linkend=\"embedding-components\">simple integration</link> will be used\n      to bring Cockpit components into web applications. However it is also possible to do deep\n      integration for embedders who wish to perform non-standard authentication with the server,\n      and relay the component's message stream to the server themselves.</para>\n\n    <warning>\n      <para>Deep integration capability is in heavy flux and is not yet documented.</para>\n    </warning>\n  </section>\n\n  <section id=\"embedding-cors\">\n    <title>Pinging Cockpit</title>\n\n    <para>When embedding Cockpit or integrating Cockpit components, it may be necessary to check\n      whether Cockpit is available on a server before proceeding.</para>\n\n    <para>To do this perform a <code>/ping</code> request to Cockpit. This is a simple HTTP\n      GET request. It returns the following:</para>\n\n<programlisting>\nGET: https://server.example.com:9090/ping\n200 OK: { \"service\": \"cockpit\" }\n</programlisting>\n\n    <para>The <code>/ping</code> request allows\n      <ulink url=\"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\">Cross Origin Resource Sharing</ulink>\n      headers and as such can be performed from Javascript code with any origin. The request can also be\n      made via plain HTTP without SSL. It is by design that no further information is present in the\n      response.</para>\n\n    <para>A complete example of using <code>/ping</code> is available in the Cockpit sources in the\n      <code>/examples/ping-server/</code> directory.</para>\n\n  </section>\n\n</chapter>\n", "import cockpit from \"cockpit\";\nimport QUnit from \"qunit-tests\";\n\n/* Set this to a regexp to ignore that warning once */\n/*\nfunction console_ignore_warning(exp) {\n    var console_warn = console.warn;\n    console.warn = function() {\n        if (!exp.exec(arguments[0]))\n            console_warn.apply(console, arguments);\n        console.warn = console_warn;\n    };\n}\n*/\n\nQUnit.test(\"public api\", function (assert) {\n    var client = cockpit.http(\"/test\");\n    assert.equal(typeof client, \"object\", \"http is an object\");\n    assert.equal(typeof client.get, \"function\", \"http.get() is a function\");\n    assert.equal(typeof client.post, \"function\", \"http.post() is a function\");\n});\n\nQUnit.test(\"simple request\", function (assert) {\n    const done = assert.async();\n    assert.expect(2);\n\n    cockpit.http({ internal: \"/test-server\" }).get(\"/pkg/playground/manifest.json\")\n            .done(function(data) {\n                assert.deepEqual(JSON.parse(data), {\n                    requires: {\n                        cockpit: \"122\"\n                    },\n\n                    tools: {\n                        index: {\n                            label: \"Development\"\n                        }\n                    },\n\n                    playground: {\n                        \"react-patterns\": {\n                            label: \"React Patterns\"\n                        },\n                        translate: {\n                            label: \"Translating\"\n                        },\n                        exception: {\n                            label: \"Exceptions\"\n                        },\n                        pkgs: {\n                            label: \"Packages\"\n                        },\n                        preloaded: {\n                            label: \"Preloaded\"\n                        },\n                        \"notifications-receiver\": {\n                            label: \"Notifications Receiver\"\n                        },\n                        metrics: {\n                            label: \"Monitoring\"\n                        },\n                        plot: {\n                            label: \"Plots\"\n                        },\n                        service: {\n                            label: \"Generic Service Monitor\"\n                        },\n                        speed: {\n                            label: \"Speed Tests\"\n                        },\n                        journal: {\n                            label: \"Logs Box\"\n                        },\n                        test: {\n                            label: \"Playground\"\n                        }\n                    },\n                    preload: [\"preloaded\"],\n                    \"content-security-policy\": \"img-src 'self' data:\"\n                }, \"returned right data\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"didn't fail\");\n                done();\n            });\n});\n\nQUnit.test(\"with params\", function (assert) {\n    const done = assert.async();\n    assert.expect(2);\n\n    cockpit.http({ internal: \"/test-server\" })\n            .get(\"/mock/qs\", { key: \"value\", name: \"Scruffy the Janitor\" })\n            .done(function(resp) {\n                assert.equal(resp, \"key=value&name=Scruffy+the+Janitor\", \"right query string\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"didn't fail\");\n                done();\n            });\n});\n\nQUnit.test(\"not found\", function (assert) {\n    const done = assert.async();\n    assert.expect(7);\n\n    var promise = cockpit.http({ internal: \"/test-server\" })\n            .get(\"/not/found\")\n            .response(function(status, headers) {\n                assert.equal(status, 404, \"status code\");\n                assert.strictEqual(this, promise, \"got right this\");\n            })\n            .fail(function(ex, data) {\n                assert.strictEqual(ex.problem, null, \"mapped to cockpit code\");\n                assert.strictEqual(ex.status, 404, \"has status code\");\n                assert.equal(ex.message, \"Not Found\", \"has reason\");\n                assert.equal(data, \"<html><head><title>Not Found</title></head><body>Not Found</body></html>\\n\", \"got body\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"rejected\", \"should fail\");\n                done();\n            });\n});\n\nQUnit.test(\"streaming\", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    var at = 0;\n    var got = \"\";\n    var promise = cockpit.http({ internal: \"/test-server\" })\n            .get(\"/mock/stream\")\n            .stream(function(resp) {\n                if (at === 0)\n                    assert.strictEqual(this, promise, \"got right this\");\n                got += resp;\n                at++;\n            })\n            .always(function() {\n                var expected = \"\";\n                for (var i = 0; i < at; i++)\n                    expected += String(i) + \" \";\n                assert.equal(got, expected, \"stream got right data\");\n                assert.equal(this.state(), \"resolved\", \"split response didn't fail\");\n                done();\n            });\n});\n\nQUnit.test(\"close\", function (assert) {\n    const done = assert.async();\n    assert.expect(4);\n\n    var req = cockpit.http({ internal: \"/test-server\" }).get(\"/mock/stream\");\n\n    var at = 0;\n    req.stream(function(resp) {\n        at += 1;\n        assert.equal(resp, \"0 \", \"first stream part\");\n        this.close(\"bad-boy\");\n    })\n            .fail(function(ex) {\n                assert.equal(ex.problem, \"bad-boy\", \"right problem\");\n            })\n            .always(function() {\n                assert.equal(at, 1, \"stream got cancelled\");\n                assert.equal(this.state(), \"rejected\", \"cancelling a response rejects it\");\n                done();\n            });\n});\n\nQUnit.test(\"close all\", function (assert) {\n    const done = assert.async();\n    assert.expect(4);\n\n    var http = cockpit.http({ internal: \"/test-server\" });\n    var req = http.get(\"/mock/stream\");\n\n    var at = 0;\n    req.stream(function(resp) {\n        at += 1;\n        assert.equal(resp, \"0 \", \"first stream part\");\n        http.close(\"bad-boy\");\n    })\n            .fail(function(ex) {\n                assert.equal(ex.problem, \"bad-boy\", \"right problem\");\n            })\n            .always(function() {\n                assert.equal(at, 1, \"stream got cancelled\");\n                assert.equal(this.state(), \"rejected\", \"cancelling a response rejects it\");\n                http.close(\"closed\"); // This should be a no-op now\n                done();\n            });\n});\n\nQUnit.test(\"headers\", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    cockpit.http({ internal: \"/test-server\" })\n            .get(\"/mock/headers\", null, { Header1: \"booo\", Header2: \"yay value\" })\n            .response(function(status, headers) {\n                assert.equal(status, 201, \"status code\");\n                assert.deepEqual(headers, {\n                    Header1: \"booo\",\n                    Header2: \"yay value\",\n                    Header3: \"three\",\n                    Header4: \"marmalade\",\n                    \"Referrer-Policy\": \"no-referrer\",\n                    \"X-DNS-Prefetch-Control\": \"off\",\n                    \"X-Content-Type-Options\": \"nosniff\",\n                    \"X-Frame-Options\": \"sameorigin\",\n                    \"Cross-Origin-Resource-Policy\": \"same-origin\",\n                }, \"got back headers\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"split response didn't fail\");\n                done();\n            });\n});\n\nQUnit.test(\"escape host header\", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    cockpit.http({ internal: \"/test-server\" })\n            .get(\"/mock/host\", null, { })\n            .response(function(status, headers) {\n                assert.equal(status, 201, \"status code\");\n                assert.deepEqual(headers.Host, \"%2Ftest-server\", \"got back escaped headers\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"split response didn't fail\");\n                done();\n            });\n});\n\nQUnit.test(\"connection headers\", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    cockpit.http({ internal: \"/test-server\", headers: { Header1: \"booo\", Header2: \"not this\" } })\n            .get(\"/mock/headers\", null, { Header2: \"yay value\", Header0: \"extra\" })\n            .response(function(status, headers) {\n                assert.equal(status, 201, \"status code\");\n                assert.deepEqual(headers, {\n                    Header0: \"extra\",\n                    Header1: \"booo\",\n                    Header2: \"yay value\",\n                    Header3: \"three\",\n                    Header4: \"marmalade\",\n                    \"Referrer-Policy\": \"no-referrer\",\n                    \"X-DNS-Prefetch-Control\": \"off\",\n                    \"X-Content-Type-Options\": \"nosniff\",\n                    \"X-Frame-Options\": \"sameorigin\",\n                    \"Cross-Origin-Resource-Policy\": \"same-origin\",\n                }, \"got back combined headers\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"split response didn't fail\");\n                done();\n            });\n});\n\nQUnit.test(\"http promise recursive\", function (assert) {\n    assert.expect(7);\n\n    var promise = cockpit.http({ internal: \"/test-server\" }).get(\"/\");\n\n    var target = { };\n    var promise2 = promise.promise(target);\n    assert.strictEqual(promise2, target, \"used target\");\n    assert.equal(typeof promise2.done, \"function\", \"promise2.done()\");\n    assert.equal(typeof promise2.promise, \"function\", \"promise2.promise()\");\n    assert.equal(typeof promise2.input, \"function\", \"promise2.input()\");\n\n    var promise3 = promise2.promise();\n    assert.equal(typeof promise3.done, \"function\", \"promise3.done()\");\n    assert.equal(typeof promise3.promise, \"function\", \"promise3.promise()\");\n    assert.equal(typeof promise3.input, \"function\", \"promise3.input()\");\n});\n\nQUnit.test(\"http keep alive\", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    /*\n     * The /mock/connection handler returns an identifier that changes if\n     * a different connection is used.\n     */\n\n    var first;\n    cockpit.http({ internal: \"/test-server\", connection: \"marmalade\" }).get(\"/mock/connection\")\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"response didn't fail\");\n            })\n            .done(function(data) {\n                first = data;\n                cockpit.http({ internal: \"/test-server\", connection: \"marmalade\" }).get(\"/mock/connection\")\n                        .done(function(data) {\n                            assert.equal(first, data, \"same connection\");\n                        })\n                        .always(function() {\n                            assert.equal(this.state(), \"resolved\", \"response didn't fail\");\n                            done();\n                        });\n            });\n});\n\nQUnit.test(\"http connection different\", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    /*\n     * The /mock/connection handler returns an identifier that changes if\n     * a different connection is used.\n     */\n\n    var first;\n    cockpit.http({ internal: \"/test-server\", connection: \"one\" }).get(\"/mock/connection\")\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"response didn't fail\");\n            })\n            .done(function(data) {\n                first = data;\n                cockpit.http({ internal: \"/test-server\", connection: \"two\" }).get(\"/mock/connection\")\n                        .done(function(data) {\n                            assert.notEqual(first, data, \"different connection\");\n                        })\n                        .always(function() {\n                            assert.equal(this.state(), \"resolved\", \"response didn't fail\");\n                            done();\n                        });\n            });\n});\n\nQUnit.test(\"http connection without address \", function (assert) {\n    const done = assert.async();\n    assert.expect(3);\n\n    /*\n     * Able to reuse connection client info and not specify address again.\n     */\n\n    var first;\n    cockpit.http({ internal: \"/test-server\", connection: \"one\" }).get(\"/mock/connection\")\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"response didn't fail\");\n            })\n            .done(function(data) {\n                first = data;\n                cockpit.http({ connection: \"one\" }).get(\"/mock/connection\")\n                        .done(function(data) {\n                            assert.equal(first, data, \"different connection\");\n                        })\n                        .always(function() {\n                            assert.equal(this.state(), \"resolved\", \"response didn't fail\");\n                            done();\n                        });\n            });\n});\n\nQUnit.test(\"no dns address\", function (assert) {\n    const done = assert.async();\n    assert.expect(2);\n\n    cockpit.http({\n        port: 8080,\n        address: \"the-other-host.example.com\"\n    })\n            .get(\"/\")\n            .fail(function(ex, data) {\n            /* Unfortunately we can see either of these errors when running unit tests */\n                if (ex.problem === \"timeout\")\n                    ex.problem = \"not-found\";\n                assert.strictEqual(ex.problem, \"not-found\", \"can't resolve is not found\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"rejected\", \"should fail\");\n                done();\n            });\n});\n\nQUnit.test(\"address with params\", function (assert) {\n    const done = assert.async();\n    // use our window's host and port to request external\n    assert.expect(2);\n\n    cockpit.http({\n        port: parseInt(window.location.port, 10),\n        address: window.location.hostname\n    })\n            .get(\"/mock/qs\", { key: \"value\", name: \"Scruffy the Janitor\" })\n            .done(function(resp) {\n                assert.equal(resp, \"key=value&name=Scruffy+the+Janitor\", \"right query string\");\n            })\n            .always(function() {\n                assert.equal(this.state(), \"resolved\", \"didn't fail\");\n                done();\n            });\n});\n\nQUnit.start();\n", "\n/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2013 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include \"cockpithttpstream.h\"\n\n#include \"common/cockpitjson.h\"\n#include \"common/cockpittest.h\"\n#include \"common/cockpitwebresponse.h\"\n#include \"common/cockpitwebserver.h\"\n#include \"common/mock-transport.h\"\n\n#include <string.h>\n\n/* Declared in cockpitwebserver.c */\nextern gboolean cockpit_webserver_want_certificate;\n\n/* JSON dict snippet for headers that are present in every request */\n#define STATIC_HEADERS \"\\\"Cross-Origin-Resource-Policy\\\":\\\"same-origin\\\",\\\"Referrer-Policy\\\":\\\"no-referrer\\\",\\\"X-Content-Type-Options\\\":\\\"nosniff\\\",\\\"X-DNS-Prefetch-Control\\\":\\\"off\\\",\\\"X-Frame-Options\\\":\\\"sameorigin\\\"\"\n\nstatic void\non_closed_set_flag (CockpitChannel *channel,\n                    const gchar *problem,\n                    gpointer user_data)\n{\n  gboolean *flag = user_data;\n  g_assert (flag != NULL);\n  g_assert (*flag != TRUE);\n  *flag = TRUE;\n}\n\ntypedef struct {\n  CockpitWebServer *web_server;\n  guint port;\n  MockTransport *transport;\n  const char *host;\n} TestGeneral;\n\n\nstatic gchar *\nnon_local_ip (void)\n{\n  GInetAddress *inet;\n  gchar *str = NULL;\n  inet = cockpit_test_find_non_loopback_address ();\n  if (inet)\n    {\n      str = g_inet_address_to_string (inet);\n      g_object_unref (inet);\n    }\n\n  return str;\n}\n\nstatic void\nsetup_general (TestGeneral *tt,\n               gconstpointer host_fixture)\n{\n  tt->web_server = cockpit_web_server_new (NULL, 0, NULL, COCKPIT_WEB_SERVER_NONE, NULL, NULL);\n  cockpit_web_server_start (tt->web_server);\n  tt->port = cockpit_web_server_get_port (tt->web_server);\n  tt->transport = mock_transport_new ();\n  tt->host = host_fixture;\n}\n\nstatic void\nteardown_general (TestGeneral *tt,\n                  gconstpointer unused)\n{\n  g_object_unref (tt->web_server);\n  g_object_unref (tt->transport);\n\n  cockpit_assert_expected ();\n}\n\nstatic gboolean\nhandle_host_header (CockpitWebServer *server,\n                    const gchar *path,\n                    GHashTable *headers,\n                    CockpitWebResponse *response,\n                    gpointer user_data)\n{\n  TestGeneral *tt = user_data;\n  const gchar *data = \"Da Da Da\";\n  gchar *expected;\n  GBytes *bytes;\n\n  expected = g_strdup_printf (\"%s:%d\", tt->host, tt->port);\n  g_assert_cmpstr (g_hash_table_lookup (headers, \"Host\"), ==, expected);\n  g_free (expected);\n\n  bytes = g_bytes_new_static (data, strlen (data));\n  cockpit_web_response_content (response, NULL, bytes, NULL);\n  g_bytes_unref (bytes);\n\n  return TRUE;\n}\n\n/* Compare subsequent \"{ control JSON }\" and \"body\" channel messages against expected values. */\nstatic void\nassert_channel_response (MockTransport *transport,\n                         const gchar *channel_id,\n                         const gchar *expected_control,\n                         const gchar *expected_body)\n{\n  GBytes *data;\n\n  data = mock_transport_pop_channel (transport, channel_id);\n  JsonNode *node = cockpit_json_parse (g_bytes_get_data (data, NULL), -1, NULL);\n  cockpit_assert_json_eq (json_node_get_object (node), expected_control);\n  json_node_unref (node);\n\n  data = mock_transport_pop_channel (transport, channel_id);\n  cockpit_assert_bytes_eq (data, expected_body, -1);\n}\n\nstatic void\ntest_host_header (TestGeneral *tt,\n                  gconstpointer unused)\n{\n  CockpitChannel *channel;\n  GBytes *bytes;\n  JsonObject *options;\n  const gchar *control;\n  gboolean closed;\n\n  if (tt->host == NULL)\n    {\n      g_test_skip (\"Couldn't determine non local ip\");\n      return;\n    }\n\n  g_signal_connect (tt->web_server, \"handle-resource::/\", G_CALLBACK (handle_host_header), tt);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", tt->port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/\");\n\n  if (g_strcmp0 (tt->host, \"localhost\") != 0)\n    json_object_set_string_member (options, \"address\", tt->host);\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", tt->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (tt->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  closed = FALSE;\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_closed_set_flag), &closed);\n  while (!closed)\n    g_main_context_iteration (NULL, TRUE);\n\n  assert_channel_response (tt->transport, \"444\",\n                           \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \"}}\",\n                           \"Da Da Da\");\n}\n\nstatic gboolean\nhandle_default (CockpitWebServer *server,\n                const gchar *path,\n                GHashTable *headers,\n                CockpitWebResponse *response,\n                gpointer user_data)\n{\n  const gchar *data = \"Da Da Da\";\n  GBytes *bytes;\n\n  bytes = g_bytes_new_static (data, strlen (data));\n  cockpit_web_response_content (response, NULL, bytes, NULL);\n  g_bytes_unref (bytes);\n\n  return TRUE;\n}\n\nstatic void\ntest_http_stream2 (TestGeneral *tt,\n                   gconstpointer unused)\n{\n  CockpitChannel *channel;\n  GBytes *bytes;\n  JsonObject *options;\n  const gchar *control;\n  JsonObject *object;\n  gboolean closed;\n  GBytes *data;\n  guint count;\n\n  g_signal_connect (tt->web_server, \"handle-resource::/\", G_CALLBACK (handle_default), tt);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", tt->port);\n  json_object_set_string_member (options, \"payload\", \"http-stream2\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/\");\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", tt->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (tt->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  closed = FALSE;\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_closed_set_flag), &closed);\n  while (!closed)\n    g_main_context_iteration (NULL, TRUE);\n\n  object = mock_transport_pop_control (tt->transport);\n  cockpit_assert_json_eq (object, \"{\\\"command\\\":\\\"ready\\\",\\\"channel\\\":\\\"444\\\"}\");\n  object = mock_transport_pop_control (tt->transport);\n  cockpit_assert_json_eq (object, \"{\\\"command\\\":\\\"response\\\",\\\"channel\\\":\\\"444\\\",\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \"}}\");\n\n  data = mock_transport_combine_output (tt->transport, \"444\", &count);\n  cockpit_assert_bytes_eq (data, \"Da Da Da\", -1);\n  g_assert_cmpuint (count, ==, 1);\n  g_bytes_unref (data);\n}\n\nstatic void\ntest_cannot_connect (TestGeneral *tt,\n                     gconstpointer unused)\n{\n  CockpitChannel *channel;\n  GBytes *bytes;\n  JsonObject *options;\n  const gchar *control;\n  JsonObject *object;\n  gboolean closed;\n\n  cockpit_expect_log (\"cockpit-bridge\", G_LOG_LEVEL_MESSAGE, \"*couldn't connect*\");\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", 5555);\n  json_object_set_string_member (options, \"payload\", \"http-stream2\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/\");\n  json_object_set_string_member (options, \"address\", \"0.0.0.0\");\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", tt->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (tt->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  closed = FALSE;\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_closed_set_flag), &closed);\n  while (!closed)\n    g_main_context_iteration (NULL, TRUE);\n\n  object = mock_transport_pop_control (tt->transport);\n  cockpit_assert_json_eq (object, \"{\\\"command\\\":\\\"close\\\",\\\"channel\\\":\\\"444\\\",\\\"problem\\\":\\\"not-found\\\"}\");\n}\n\n/* -----------------------------------------------------------------------------\n * Test\n */\n\ntypedef struct {\n  gchar *problem;\n  gboolean done;\n} TestResult;\n\n/*\n * Yes this is a magic number. It's the lowest number that would\n * trigger a bug where chunked data would be rejected due to an incomplete read.\n */\nconst gint MAGIC_NUMBER = 3068;\n\nstatic gboolean\nhandle_chunked (CockpitWebServer *server,\n                const gchar *path,\n                GHashTable *headers,\n                CockpitWebResponse *response,\n                gpointer user_data)\n{\n  GBytes *bytes;\n  GHashTable *h = g_hash_table_new (g_str_hash,  g_str_equal);\n\n  cockpit_web_response_headers_full (response, 200,\n                                     \"OK\", -1, h);\n  bytes = g_bytes_new_take (g_strdup_printf (\"%0*d\",\n                                             MAGIC_NUMBER, 0),\n                            MAGIC_NUMBER);\n  cockpit_web_response_queue (response, bytes);\n  cockpit_web_response_complete (response);\n\n  g_bytes_unref (bytes);\n  g_hash_table_unref (h);\n  return TRUE;\n}\n\nstatic void\non_channel_close (CockpitChannel *channel,\n                  const gchar *problem,\n                  gpointer user_data)\n{\n  TestResult *tr = user_data;\n  g_assert (tr->done == FALSE);\n  tr->done = TRUE;\n  tr->problem = g_strdup (problem);\n}\n\nstatic void\non_transport_closed (CockpitTransport *transport,\n                     const gchar *problem,\n                     gpointer user_data)\n{\n  g_assert_not_reached ();\n}\n\nstatic void\ntest_http_chunked (void)\n{\n  MockTransport *transport = NULL;\n  CockpitChannel *channel = NULL;\n  CockpitWebServer *web_server = NULL;\n  JsonObject *options = NULL;\n  JsonObject *headers = NULL;\n  TestResult *tr = g_slice_new (TestResult);\n\n  GBytes *bytes = NULL;\n\n  const gchar *control;\n  guint port;\n\n  web_server = cockpit_web_server_new (NULL, 0, NULL, COCKPIT_WEB_SERVER_NONE, NULL, NULL);\n  g_assert (web_server);\n  port = cockpit_web_server_get_port (web_server);\n  g_signal_connect (web_server, \"handle-resource::/\",\n                    G_CALLBACK (handle_chunked), NULL);\n\n  cockpit_web_server_start (web_server);\n\n  transport = mock_transport_new ();\n  g_signal_connect (transport, \"closed\", G_CALLBACK (on_transport_closed), NULL);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/\");\n\n  headers = json_object_new ();\n  json_object_set_string_member (headers, \"Pragma\", \"no-cache\");\n  json_object_set_object_member (options, \"headers\", headers);\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                              \"transport\", transport,\n                              \"id\", \"444\",\n                              \"options\", options,\n                              NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  tr->done = FALSE;\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_channel_close), tr);\n\n  while (tr->done == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tr->problem, ==, NULL);\n\n\n\n  g_autofree gchar *expected_body = g_strdup_printf (\"%0*d\", MAGIC_NUMBER, 0);\n\n  assert_channel_response (transport, \"444\",\n                           \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \"}}\",\n                           expected_body);\n\n  g_object_unref (transport);\n  g_object_add_weak_pointer (G_OBJECT (channel), (gpointer *)&channel);\n  g_object_unref (channel);\n  g_assert (channel == NULL);\n  g_clear_object (&web_server);\n\n  g_free (tr->problem);\n  g_slice_free (TestResult, tr);\n}\n\nstatic void\ntest_parse_keep_alive (void)\n{\n  const gchar *version;\n  GHashTable *headers;\n  gboolean keep_alive;\n\n  headers = g_hash_table_new (g_str_hash, g_str_equal);\n\n  version = \"HTTP/1.1\";\n  g_hash_table_insert (headers, \"Connection\", \"keep-alive\");\n\n  keep_alive = cockpit_http_stream_parse_keep_alive (version, headers);\n  g_assert (keep_alive == TRUE);\n\n  version = \"HTTP/1.0\";\n  keep_alive = cockpit_http_stream_parse_keep_alive (version, headers);\n  g_assert (keep_alive == TRUE);\n\n\n  g_hash_table_remove (headers, \"Connection\");\n\n  keep_alive = cockpit_http_stream_parse_keep_alive (version, headers);\n  g_assert (keep_alive == FALSE);\n\n  version = \"HTTP/1.1\";\n  keep_alive = cockpit_http_stream_parse_keep_alive (version, headers);\n  g_assert (keep_alive == TRUE);\n\n  g_hash_table_destroy (headers);\n}\n\ntypedef struct {\n  GTlsCertificate *certificate;\n  CockpitWebServer *web_server;\n  guint port;\n  MockTransport *transport;\n  GTlsCertificate *peer;\n} TestTls;\n\nstatic gboolean\nhandle_test (CockpitWebServer *server,\n             const gchar *path,\n             GHashTable *headers,\n             CockpitWebResponse *response,\n             gpointer user_data)\n{\n  const gchar *data = \"Oh Marmalaade!\";\n  GTlsConnection *connection;\n  TestTls *test = user_data;\n  GBytes *bytes;\n\n  bytes = g_bytes_new_static (data, strlen (data));\n  cockpit_web_response_content (response, NULL, bytes, NULL);\n  g_bytes_unref (bytes);\n\n  connection = G_TLS_CONNECTION (cockpit_web_response_get_stream (response));\n\n  g_clear_object (&test->peer);\n  test->peer = g_tls_connection_get_peer_certificate (connection);\n  if (test->peer)\n    g_object_ref (test->peer);\n\n  return TRUE;\n}\n\nstatic void\nsetup_tls (TestTls *test,\n           gconstpointer data)\n{\n  GError *error = NULL;\n\n  /* don't require system SSL cert database in build environments */\n  cockpit_expect_possible_log (\"GLib-Net\", G_LOG_LEVEL_WARNING, \"couldn't load TLS file database: * No such file or directory\");\n\n  test->certificate = g_tls_certificate_new_from_files (SRCDIR \"/src/bridge/mock-server.crt\",\n                                                        SRCDIR \"/src/bridge/mock-server.key\", &error);\n  g_assert_no_error (error);\n\n  test->web_server = cockpit_web_server_new (NULL, 0, test->certificate, COCKPIT_WEB_SERVER_NONE, NULL, &error);\n  g_assert_no_error (error);\n\n  test->port = cockpit_web_server_get_port (test->web_server);\n  g_signal_connect (test->web_server, \"handle-resource::/test\", G_CALLBACK (handle_test), test);\n\n  cockpit_web_server_start (test->web_server);\n\n  test->transport = mock_transport_new ();\n  g_signal_connect (test->transport, \"closed\", G_CALLBACK (on_transport_closed), NULL);\n}\n\nstatic void\nteardown_tls (TestTls *test,\n              gconstpointer data)\n{\n  g_object_unref (test->certificate);\n  g_object_unref (test->web_server);\n  g_object_unref (test->transport);\n  g_clear_object (&test->peer);\n  cockpit_webserver_want_certificate = FALSE;\n}\n\nstatic void\ntest_tls_basic (TestTls *test,\n                gconstpointer unused)\n{\n  gboolean closed = FALSE;\n  CockpitChannel *channel;\n  JsonObject *options;\n  const gchar *control;\n  GBytes *bytes;\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", test->port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/test\");\n  json_object_set_object_member (options, \"tls\", json_object_new ());\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", test->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (test->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_closed_set_flag), &closed);\n\n  while (closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  assert_channel_response (test->transport, \"444\",\n                           \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \"}}\",\n                           \"Oh Marmalaade!\");\n\n  g_object_add_weak_pointer (G_OBJECT (channel), (gpointer *)&channel);\n  g_object_unref (channel);\n  g_assert (channel == NULL);\n}\n\nstatic const gchar fixture_tls_certificate_data[] =\n\"{ \\\"certificate\\\": { \\\"data\\\": \"\n\"\\\"-----BEGIN CERTIFICATE-----\\n\"\n\"MIICxzCCAa+gAwIBAgIJANDrBNw3XYJ0MA0GCSqGSIb3DQEBCwUAMBQxEjAQBgNV\\n\"\n\"BAMMCWxvY2FsaG9zdDAgFw0xNTAzMjUxMDMzMzRaGA8yMTE1MDMwMTEwMzMzNFow\\n\"\n\"FDESMBAGA1UEAwwJbG9jYWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\\n\"\n\"CgKCAQEA8l1q01B5N/biaFDazUtuPuOrFsLOC67LX1iiE62guchEf9FyEagglGzt\\n\"\n\"XOSCpY/qX0HWmIkE3Pqotb8lPQ0mUHleYCvzY85cFmj4mu+rDIPxK/lw37Xu00iP\\n\"\n\"/rbcCA6K6dgMjp0TJzZvMnU2PywtFqDpw6ZchcMi517keMfLwscUC/7Y80lP0PGA\\n\"\n\"1wTDaYoxuMlUhqTTfdLoBZ73eA9YzgqBeZ9ePxoUFk9AtJtlOlR60mGbEOweDUfc\\n\"\n\"l1biKtarDW5SJYbVTFjWdPsCV6czZndfVKAAkDd+bsbFMcEiq/doHU092Yy3sZ9g\\n\"\n\"hnOBw5sCq8iTXQ9cmejxUrsu/SvL3QIDAQABoxowGDAJBgNVHRMEAjAAMAsGA1Ud\\n\"\n\"DwQEAwIF4DANBgkqhkiG9w0BAQsFAAOCAQEAalykXV+z1tQOv1ZRvJmppjEIYTa3\\n\"\n\"pFehy97BiNGERTQJQDSzOgptIaCJb1vE34KNL349QEO4F8XTPWhwsCAXNTBN4yhm\\n\"\n\"NJ6qbYkz0HbBmdM4k0MgbB9VG00Hy+TmwEt0zVryICZY4IomKmS1No0Lai5hOqdz\\n\"\n\"afUMVIIYjVB1WYIsIaXXug7Mik/O+6K5hIbqm9HkwRwfoVaOLNG9EPUM14vFnN5p\\n\"\n\"EyHSBByk0mOU8EUK/qsAnbTwABEKsMxCopmvPTguGHTwllEvxPgt5BcYMU9oXlvc\\n\"\n\"cSvnU4a6M2qxQn3LUqxENh9QaQ8vV4l/avZBi1cFKVs1rza36eOGxrJxQw==\\n\"\n\"-----END CERTIFICATE-----\\\"\"\n\"}, \\\"key\\\": { \\\"data\\\": \"\n\"\\\"-----BEGIN PRIVATE KEY-----\\n\"\n\"MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDyXWrTUHk39uJo\\n\"\n\"UNrNS24+46sWws4LrstfWKITraC5yER/0XIRqCCUbO1c5IKlj+pfQdaYiQTc+qi1\\n\"\n\"vyU9DSZQeV5gK/NjzlwWaPia76sMg/Er+XDfte7TSI/+ttwIDorp2AyOnRMnNm8y\\n\"\n\"dTY/LC0WoOnDplyFwyLnXuR4x8vCxxQL/tjzSU/Q8YDXBMNpijG4yVSGpNN90ugF\\n\"\n\"nvd4D1jOCoF5n14/GhQWT0C0m2U6VHrSYZsQ7B4NR9yXVuIq1qsNblIlhtVMWNZ0\\n\"\n\"+wJXpzNmd19UoACQN35uxsUxwSKr92gdTT3ZjLexn2CGc4HDmwKryJNdD1yZ6PFS\\n\"\n\"uy79K8vdAgMBAAECggEAILEJH8fTEgFzOK7vVJHAJSuAgGl2cYz6Uboa4pyg+W5S\\n\"\n\"DwupX0hWXK70tXr9RGfNLVwsHhcdWNFWwG0wELQdXu2AFWjYQ7YqJbuzDPMXF3EU\\n\"\n\"ruHOn95igI1hHvJ7a3rKshA6YWI+myN0jFHTJ2JGEq9R2Nov0LspkhvypXgNvA/r\\n\"\n\"JfFZ9IsPJZDWCnGXkPLlW2X1XEXw2BPs8ib+ZkbzGNiLsy/i4M/oA+g6lz4LU/ll\\n\"\n\"J6cLhwPrBu02+PJt7MaYaNk5zqhyJs0AMjeBlNnXFIWAlTrIe/h8z/gL8ABrYWAA\\n\"\n\"1kgZ11GO8bNAEfLOIUrA1/vq9aK00WDwFLXWJdVE4QKBgQD+R/J+AbYSImeoAj/3\\n\"\n\"hfsFkaUNLyw1ZEO4LG2id0dnve1paL6Y/uXKKqxq0jiyMLT243Vi+1fzth7RNXOl\\n\"\n\"ui0nnVWO7x68FsYcdIM7w+tryh2Y+UhCfwNCakM0GTohcXqFUEzHcwuOv8hAfRQ5\\n\"\n\"jPBCwJdUHpIimVOo5/WRbQGW+wKBgQD0ANkof+jagdNqOkCvFnTPiFlPYrpDzeU5\\n\"\n\"ZxhLlVxnr6G2MPoUO0IqTWVA7uCn29i0yUUXAtRHrkNI1EtKXRIUe2bChVegTBHx\\n\"\n\"26PqXEOonSUJdpUzyzXVX2vSqICm0tTbqyZ0GbjP4y5qQOQHdTGFsHDfSTa5//P+\\n\"\n\"0BLpci4RBwKBgQDBR8DrxLM3b41o6GTk6aNXpVBXCC9LWi4bVTH0l0PgeD54rBSM\\n\"\n\"SNwz4mHyRF6yG1HChDybAz/kUN912HJSW4StIuuA3QN4prrpsCp8iDxvT09WEs25\\n\"\n\"NcAtgIYamL5V42Lk6Jej1y/GzsIROsHfyOBrbObaGu6re+5aag5//uKBdwKBgQDp\\n\"\n\"i4ZPBV7TBkBdBLS04UGdAly5Zz3xeDlW4B6Y+bUgaTLXN7mlc7K42qt3oyzUfdDF\\n\"\n\"+X9vrv2QPnOYWdpWqw6LHDIXLZnZi/YBEMGrp/P6h67Th/T3RiGYwWRqlW3OPy4N\\n\"\n\"s5tytMv37vKWMNYRbVKhK2hdz63aCep4kqAHYYpGMQKBgF83LTyRFwGFos/wDrgY\\n\"\n\"eieLiipmdXGvlrBq6SBzKglIYwNRSGiWkXAuHRzD/2S546ioQKZr7AKuijKGdLMz\\n\"\n\"ABVl/bqqqRXSDbvf+XEdU2rJpxhYWxlsJZMFBFIwuxR2jRqmCgbCvoZQcbIr1ZLr\\n\"\n\"02eC2pQ5eio2+CKqBfqxbnwk\\n\"\n\"-----END PRIVATE KEY-----\\\"\"\n\" } }\";\n\nstatic const gchar fixture_tls_certificate_file[] =\n\"{ \\\"certificate\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.crt\\\" },\"\n\"\\\"key\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.key\\\" } }\";\n\nstatic const gchar fixture_tls_certificate_data_file[] =\n\"{ \\\"certificate\\\": { \\\"data\\\": \"\n\"\\\"-----BEGIN CERTIFICATE-----\\n\"\n\"MIICxzCCAa+gAwIBAgIJANDrBNw3XYJ0MA0GCSqGSIb3DQEBCwUAMBQxEjAQBgNV\\n\"\n\"BAMMCWxvY2FsaG9zdDAgFw0xNTAzMjUxMDMzMzRaGA8yMTE1MDMwMTEwMzMzNFow\\n\"\n\"FDESMBAGA1UEAwwJbG9jYWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\\n\"\n\"CgKCAQEA8l1q01B5N/biaFDazUtuPuOrFsLOC67LX1iiE62guchEf9FyEagglGzt\\n\"\n\"XOSCpY/qX0HWmIkE3Pqotb8lPQ0mUHleYCvzY85cFmj4mu+rDIPxK/lw37Xu00iP\\n\"\n\"/rbcCA6K6dgMjp0TJzZvMnU2PywtFqDpw6ZchcMi517keMfLwscUC/7Y80lP0PGA\\n\"\n\"1wTDaYoxuMlUhqTTfdLoBZ73eA9YzgqBeZ9ePxoUFk9AtJtlOlR60mGbEOweDUfc\\n\"\n\"l1biKtarDW5SJYbVTFjWdPsCV6czZndfVKAAkDd+bsbFMcEiq/doHU092Yy3sZ9g\\n\"\n\"hnOBw5sCq8iTXQ9cmejxUrsu/SvL3QIDAQABoxowGDAJBgNVHRMEAjAAMAsGA1Ud\\n\"\n\"DwQEAwIF4DANBgkqhkiG9w0BAQsFAAOCAQEAalykXV+z1tQOv1ZRvJmppjEIYTa3\\n\"\n\"pFehy97BiNGERTQJQDSzOgptIaCJb1vE34KNL349QEO4F8XTPWhwsCAXNTBN4yhm\\n\"\n\"NJ6qbYkz0HbBmdM4k0MgbB9VG00Hy+TmwEt0zVryICZY4IomKmS1No0Lai5hOqdz\\n\"\n\"afUMVIIYjVB1WYIsIaXXug7Mik/O+6K5hIbqm9HkwRwfoVaOLNG9EPUM14vFnN5p\\n\"\n\"EyHSBByk0mOU8EUK/qsAnbTwABEKsMxCopmvPTguGHTwllEvxPgt5BcYMU9oXlvc\\n\"\n\"cSvnU4a6M2qxQn3LUqxENh9QaQ8vV4l/avZBi1cFKVs1rza36eOGxrJxQw==\\n\"\n\"-----END CERTIFICATE-----\\\"\"\n\"}, \\\"key\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.key\\\"\"\n\"} }\";\n\nstatic const gchar fixture_tls_certificate_file_data[] =\n\"{ \\\"certificate\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.crt\\\"\"\n\"}, \\\"key\\\": { \\\"data\\\": \"\n\"\\\"-----BEGIN PRIVATE KEY-----\\n\"\n\"MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDyXWrTUHk39uJo\\n\"\n\"UNrNS24+46sWws4LrstfWKITraC5yER/0XIRqCCUbO1c5IKlj+pfQdaYiQTc+qi1\\n\"\n\"vyU9DSZQeV5gK/NjzlwWaPia76sMg/Er+XDfte7TSI/+ttwIDorp2AyOnRMnNm8y\\n\"\n\"dTY/LC0WoOnDplyFwyLnXuR4x8vCxxQL/tjzSU/Q8YDXBMNpijG4yVSGpNN90ugF\\n\"\n\"nvd4D1jOCoF5n14/GhQWT0C0m2U6VHrSYZsQ7B4NR9yXVuIq1qsNblIlhtVMWNZ0\\n\"\n\"+wJXpzNmd19UoACQN35uxsUxwSKr92gdTT3ZjLexn2CGc4HDmwKryJNdD1yZ6PFS\\n\"\n\"uy79K8vdAgMBAAECggEAILEJH8fTEgFzOK7vVJHAJSuAgGl2cYz6Uboa4pyg+W5S\\n\"\n\"DwupX0hWXK70tXr9RGfNLVwsHhcdWNFWwG0wELQdXu2AFWjYQ7YqJbuzDPMXF3EU\\n\"\n\"ruHOn95igI1hHvJ7a3rKshA6YWI+myN0jFHTJ2JGEq9R2Nov0LspkhvypXgNvA/r\\n\"\n\"JfFZ9IsPJZDWCnGXkPLlW2X1XEXw2BPs8ib+ZkbzGNiLsy/i4M/oA+g6lz4LU/ll\\n\"\n\"J6cLhwPrBu02+PJt7MaYaNk5zqhyJs0AMjeBlNnXFIWAlTrIe/h8z/gL8ABrYWAA\\n\"\n\"1kgZ11GO8bNAEfLOIUrA1/vq9aK00WDwFLXWJdVE4QKBgQD+R/J+AbYSImeoAj/3\\n\"\n\"hfsFkaUNLyw1ZEO4LG2id0dnve1paL6Y/uXKKqxq0jiyMLT243Vi+1fzth7RNXOl\\n\"\n\"ui0nnVWO7x68FsYcdIM7w+tryh2Y+UhCfwNCakM0GTohcXqFUEzHcwuOv8hAfRQ5\\n\"\n\"jPBCwJdUHpIimVOo5/WRbQGW+wKBgQD0ANkof+jagdNqOkCvFnTPiFlPYrpDzeU5\\n\"\n\"ZxhLlVxnr6G2MPoUO0IqTWVA7uCn29i0yUUXAtRHrkNI1EtKXRIUe2bChVegTBHx\\n\"\n\"26PqXEOonSUJdpUzyzXVX2vSqICm0tTbqyZ0GbjP4y5qQOQHdTGFsHDfSTa5//P+\\n\"\n\"0BLpci4RBwKBgQDBR8DrxLM3b41o6GTk6aNXpVBXCC9LWi4bVTH0l0PgeD54rBSM\\n\"\n\"SNwz4mHyRF6yG1HChDybAz/kUN912HJSW4StIuuA3QN4prrpsCp8iDxvT09WEs25\\n\"\n\"NcAtgIYamL5V42Lk6Jej1y/GzsIROsHfyOBrbObaGu6re+5aag5//uKBdwKBgQDp\\n\"\n\"i4ZPBV7TBkBdBLS04UGdAly5Zz3xeDlW4B6Y+bUgaTLXN7mlc7K42qt3oyzUfdDF\\n\"\n\"+X9vrv2QPnOYWdpWqw6LHDIXLZnZi/YBEMGrp/P6h67Th/T3RiGYwWRqlW3OPy4N\\n\"\n\"s5tytMv37vKWMNYRbVKhK2hdz63aCep4kqAHYYpGMQKBgF83LTyRFwGFos/wDrgY\\n\"\n\"eieLiipmdXGvlrBq6SBzKglIYwNRSGiWkXAuHRzD/2S546ioQKZr7AKuijKGdLMz\\n\"\n\"ABVl/bqqqRXSDbvf+XEdU2rJpxhYWxlsJZMFBFIwuxR2jRqmCgbCvoZQcbIr1ZLr\\n\"\n\"02eC2pQ5eio2+CKqBfqxbnwk\\n\"\n\"-----END PRIVATE KEY-----\\\"\"\n\" } }\";\n\nstatic void\ntest_tls_certificate (TestTls *test,\n                      gconstpointer json)\n{\n  gboolean closed = FALSE;\n  CockpitChannel *channel;\n  JsonObject *options;\n  JsonObject *tls;\n  GError *error = NULL;\n  GTlsCertificate *cert;\n  const gchar *control;\n  GBytes *bytes;\n\n  /* tell server to request client cert */\n  cockpit_webserver_want_certificate = TRUE;\n\n  /* this happens twice, so once more in addition to the ignore in setup_tls */\n  cockpit_expect_possible_log (\"GLib-Net\", G_LOG_LEVEL_WARNING, \"couldn't load TLS file database: * No such file or directory\");\n\n  tls = cockpit_json_parse_object (json, -1, &error);\n  g_assert_no_error (error);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", test->port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/test\");\n  json_object_set_object_member (options, \"tls\", tls);\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", test->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (test->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_closed_set_flag), &closed);\n\n  while (closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  assert_channel_response (test->transport, \"444\",\n                           \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \"}}\",\n                           \"Oh Marmalaade!\");\n\n  g_assert (test->peer != NULL);\n\n  /* Should have used our expected certificate */\n  cert = g_tls_certificate_new_from_files (SRCDIR \"/src/bridge/mock-client.crt\",\n                                           SRCDIR \"/src/bridge/mock-client.key\", &error);\n  g_assert_no_error (error);\n\n  g_assert (g_tls_certificate_is_same (test->peer, cert));\n  g_object_unref (cert);\n\n  g_object_add_weak_pointer (G_OBJECT (channel), (gpointer *)&channel);\n  g_object_unref (channel);\n  g_assert (channel == NULL);\n}\n\nstatic const gchar fixture_tls_authority_good[] =\n  \"{ \\\"authority\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-server.crt\\\" } }\";\n\nstatic void\ntest_tls_authority_good (TestTls *test,\n                         gconstpointer json)\n{\n  gboolean closed = FALSE;\n  CockpitChannel *channel;\n  JsonObject *options;\n  JsonObject *tls;\n  GError *error = NULL;\n  const gchar *control;\n  GBytes *bytes;\n\n  tls = cockpit_json_parse_object (json, -1, &error);\n  g_assert_no_error (error);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", test->port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/test\");\n  json_object_set_object_member (options, \"tls\", tls);\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", test->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (test->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  g_signal_connect (channel, \"closed\", G_CALLBACK (on_closed_set_flag), &closed);\n\n  while (closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  assert_channel_response (test->transport, \"444\",\n                           \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \"}}\",\n                           \"Oh Marmalaade!\");\n\n  g_object_add_weak_pointer (G_OBJECT (channel), (gpointer *)&channel);\n  g_object_unref (channel);\n  g_assert (channel == NULL);\n}\n\nstatic const gchar fixture_tls_authority_bad[] =\n  \"{ \\\"certificate\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.crt\\\" },\"\n  \"  \\\"key\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.key\\\" }, \"\n  \"  \\\"authority\\\": { \\\"file\\\": \\\"\" SRCDIR \"/src/bridge/mock-client.crt\\\" } }\";\n\nstatic void\ntest_tls_authority_bad (TestTls *test,\n                         gconstpointer json)\n{\n  CockpitChannel *channel;\n  JsonObject *options;\n  JsonObject *tls;\n  GError *error = NULL;\n  const gchar *control;\n  GBytes *bytes;\n  JsonObject *resp;\n\n  tls = cockpit_json_parse_object (json, -1, &error);\n  g_assert_no_error (error);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", test->port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", \"/test\");\n  json_object_set_object_member (options, \"tls\", tls);\n\n  channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                          \"transport\", test->transport,\n                          \"id\", \"444\",\n                          \"options\", options,\n                          NULL);\n\n  cockpit_expect_log (\"cockpit-bridge\", G_LOG_LEVEL_MESSAGE,\n                      \"*Unacceptable TLS certificate\");\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (test->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  while (mock_transport_count_sent (test->transport) < 1)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = mock_transport_pop_control (test->transport);\n  cockpit_assert_json_eq (resp, \"{\\\"command\\\":\\\"close\\\",\\\"channel\\\":\\\"444\\\",\\\"problem\\\":\\\"unknown-hostkey\\\"}\");\n\n  g_object_add_weak_pointer (G_OBJECT (channel), (gpointer *)&channel);\n  g_object_unref (channel);\n  g_assert (channel == NULL);\n}\n\nint\nmain (int argc,\n      char *argv[])\n{\n  char *ip = non_local_ip ();\n  int result;\n\n  cockpit_test_init (&argc, &argv);\n\n  g_test_add (\"/http-stream/host-header\", TestGeneral, \"localhost\",\n              setup_general, test_host_header, teardown_general);\n  g_test_add (\"/http-stream/address-host-header\", TestGeneral, ip,\n              setup_general, test_host_header, teardown_general);\n\n  g_test_add (\"/http-stream/http-stream2\", TestGeneral, NULL,\n              setup_general, test_http_stream2, teardown_general);\n  g_test_add (\"/http-stream/cannot-connect\", TestGeneral, NULL,\n              setup_general, test_cannot_connect, teardown_general);\n\n  g_test_add_func  (\"/http-stream/parse_keepalive\", test_parse_keep_alive);\n  g_test_add_func  (\"/http-stream/http_chunked\", test_http_chunked);\n\n  g_test_add (\"/http-stream/tls/basic\", TestTls, NULL,\n              setup_tls, test_tls_basic, teardown_tls);\n  g_test_add (\"/http-stream/tls/certificate-data\", TestTls, fixture_tls_certificate_data,\n              setup_tls, test_tls_certificate, teardown_tls);\n  g_test_add (\"/http-stream/tls/certificate-file\", TestTls, fixture_tls_certificate_file,\n              setup_tls, test_tls_certificate, teardown_tls);\n  g_test_add (\"/http-stream/tls/certificate-data-file\", TestTls, fixture_tls_certificate_data_file,\n              setup_tls, test_tls_certificate, teardown_tls);\n  g_test_add (\"/http-stream/tls/certificate-file-data\", TestTls, fixture_tls_certificate_file_data,\n              setup_tls, test_tls_certificate, teardown_tls);\n  g_test_add (\"/http-stream/tls/authority-good\", TestTls, fixture_tls_authority_good,\n              setup_tls, test_tls_authority_good, teardown_tls);\n  g_test_add (\"/http-stream/tls/authority-bad\", TestTls, fixture_tls_authority_bad,\n              setup_tls, test_tls_authority_bad, teardown_tls);\n\n  result = g_test_run ();\n  g_free (ip);\n  return result;\n}\n", "/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2014 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdio.h>\n\n#include \"config.h\"\n\n#include \"cockpithttpstream.h\"\n#include \"cockpitpackages.h\"\n\n#include \"common/cockpitchannel.h\"\n#include \"common/cockpitjson.h\"\n#include \"common/cockpitsystem.h\"\n#include \"common/cockpittest.h\"\n#include \"common/mock-transport.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n\n/*\n * To recalculate the checksums found in this file, do something like:\n * $ XDG_DATA_DIRS=$PWD/src/bridge/mock-resource/glob/ XDG_DATA_HOME=/nonexistent ./cockpit-bridge --packages\n */\n#define CHECKSUM_GLOB           \"f5d1bfe84c378dee517cea3e0f0380ad2c9201f6be021fbae877a89d4cb51859\"\n#define CHECKSUM_GZIP           \"13adcb9aae2f22850ec7fa43229428c6bba4450bd6ef4fd06eeea27b41dbf911\"\n#define CHECKSUM_BADPACKAGE     \"86ae6170eb6245c5c80dbcbcc0ba12beddee2e1d807cfdb705440e944b177fbc\"\n#define CHECKSUM_RELOAD_OLD     \"53264dd51401b6f6de0ba63180397919697155653855848dee0f6f71c6e93f40\"\n#define CHECKSUM_RELOAD_NEW     \"eae62ca12c4a92b4ae7f6b0d2f41cb20be0005a6fc62466fccda1ebe0532cc23\"\n#define CHECKSUM_RELOAD_UPDATED \"0d1c0b7c6133cc7c3956197fd8a76bef68b158bd78beac75cfa80b75c36aa827\"\n#define CHECKSUM_CSP            \"80921dc3cde9ff9f2acd2a5851f9b2a3b25ea7b4577128461d9e32fbdd671e16\"\n\n/* JSON dict snippet for headers that are present in every request */\n#define STATIC_HEADERS \"\\\"X-DNS-Prefetch-Control\\\":\\\"off\\\",\\\"Referrer-Policy\\\":\\\"no-referrer\\\",\\\"X-Content-Type-Options\\\":\\\"nosniff\\\",\\\"Cross-Origin-Resource-Policy\\\": \\\"same-origin\\\",\\\"X-Frame-Options\\\": \\\"sameorigin\\\"\"\n#define STATIC_HEADERS_CACHECONTROL STATIC_HEADERS \",\\\"Cache-Control\\\":\\\"no-cache, no-store\\\"\"\n\nextern const gchar **cockpit_bridge_data_dirs;\nextern const gchar *cockpit_bridge_local_address;\nextern gint cockpit_bridge_packages_port;\n\ntypedef struct {\n  CockpitPackages *packages;\n  MockTransport *transport;\n  CockpitChannel *channel;\n  gchar *problem;\n  gboolean closed;\n} TestCase;\n\ntypedef struct {\n  const gchar *datadirs[8];\n  const gchar *path;\n  const gchar *accept[8];\n  const gchar *expect;\n  const gchar *headers[8];\n  gboolean cacheable;\n  gboolean binary;\n  gboolean no_packages_init;\n} Fixture;\n\nstatic void\non_channel_close (CockpitChannel *channel,\n                  const gchar *problem,\n                  gpointer user_data)\n{\n  TestCase *tc = user_data;\n  g_assert (tc->closed == FALSE);\n  tc->closed = TRUE;\n  tc->problem = g_strdup (problem);\n}\n\nstatic void\non_transport_closed (CockpitTransport *transport,\n                     const gchar *problem,\n                     gpointer user_data)\n{\n  g_assert_not_reached ();\n}\n\nstatic void\nsetup (TestCase *tc,\n       gconstpointer data)\n{\n  const Fixture *fixture = data;\n  JsonObject *options;\n  JsonObject *headers;\n  const gchar *control;\n  gchar *accept;\n  GBytes *bytes;\n  guint i;\n\n  g_assert (fixture != NULL);\n\n  if (fixture->expect)\n    cockpit_expect_warning (fixture->expect);\n\n  if (fixture->datadirs[0])\n    {\n      cockpit_bridge_data_dirs = (const gchar **)fixture->datadirs;\n    }\n  else\n    {\n      cockpit_expect_message (\"incompatible: package requires a later version of cockpit: 999.5*\");\n      cockpit_expect_message (\"requires: package has an unknown requirement: unknown\");\n    }\n\n  tc->packages = cockpit_packages_new ();\n\n  tc->transport = mock_transport_new ();\n  g_signal_connect (tc->transport, \"closed\", G_CALLBACK (on_transport_closed), NULL);\n\n  options = json_object_new ();\n  json_object_set_int_member (options, \"port\", cockpit_bridge_packages_port);\n  json_object_set_string_member (options, \"payload\", \"http-stream1\");\n  json_object_set_string_member (options, \"method\", \"GET\");\n  json_object_set_string_member (options, \"path\", fixture->path);\n\n  if (fixture->binary)\n    json_object_set_string_member (options, \"binary\", \"raw\");\n\n  headers = json_object_new ();\n  if (fixture->accept[0])\n    {\n      accept = g_strjoinv (\", \", (gchar **)fixture->accept);\n      json_object_set_string_member (headers, \"Accept-Language\", accept);\n      g_free (accept);\n    }\n  if (!fixture->cacheable)\n    json_object_set_string_member (headers, \"Pragma\", \"no-cache\");\n  for (i = 0; i < G_N_ELEMENTS (fixture->headers); i += 2)\n    {\n      if (fixture->headers[i])\n        json_object_set_string_member (headers, fixture->headers[i], fixture->headers[i + 1]);\n    }\n  json_object_set_object_member (options, \"headers\", headers);\n\n  tc->channel = g_object_new (COCKPIT_TYPE_HTTP_STREAM,\n                              \"transport\", tc->transport,\n                              \"id\", \"444\",\n                              \"options\", options,\n                              NULL);\n\n  json_object_unref (options);\n\n  /* Tell HTTP we have no more data to send */\n  control = \"{\\\"command\\\": \\\"done\\\", \\\"channel\\\": \\\"444\\\"}\";\n  bytes = g_bytes_new_static (control, strlen (control));\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (tc->transport), NULL, bytes);\n  g_bytes_unref (bytes);\n\n  g_signal_connect (tc->channel, \"closed\", G_CALLBACK (on_channel_close), tc);\n}\n\nstatic void\nteardown (TestCase *tc,\n          gconstpointer data)\n{\n  cockpit_assert_expected ();\n\n  g_object_unref (tc->transport);\n\n  g_object_add_weak_pointer (G_OBJECT (tc->channel), (gpointer *)&tc->channel);\n  g_object_unref (tc->channel);\n  g_assert (tc->channel == NULL);\n\n  g_free (tc->problem);\n\n  cockpit_packages_free (tc->packages);\n\n  cockpit_bridge_data_dirs = NULL;\n}\n\nstatic const Fixture fixture_simple = {\n  .path = \"/test/sub/file.ext\",\n};\n\nstatic void\ntest_simple (TestCase *tc,\n             gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_simple);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"These are the contents of file.ext\\nOh marmalaaade\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_forwarded = {\n  .path = \"/another/test.html\",\n  .headers = { \"X-Forwarded-Proto\", \"https\", \"X-Forwarded-Host\", \"blah:9090\" },\n};\n\nstatic void\ntest_forwarded (TestCase *tc,\n             gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_forwarded);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \",\\\"Content-Security-Policy\\\":\\\"default-src 'self' https://blah:9090; connect-src 'self' https://blah:9090 wss://blah:9090; form-action 'self' https://blah:9090; base-uri 'self' https://blah:9090; object-src 'none'; font-src 'self' https://blah:9090 data:; img-src 'self' https://blah:9090 data:; block-all-mixed-content\\\",\\\"Content-Type\\\":\\\"text/html\\\",\\\"Access-Control-Allow-Origin\\\":\\\"https://blah:9090\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"<html>\\n<head>\\n<title>In home dir</title>\\n</head>\\n<body>In home dir</body>\\n</html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_pig = {\n  .path = \"/another/test.html\",\n  .accept = { \"pig\" },\n  .headers = { \"Host\", \"blah:9090\" },\n};\n\nstatic void\ntest_localized_translated (TestCase *tc,\n                           gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_pig);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \",\\\"Content-Security-Policy\\\":\\\"default-src 'self' http://blah:9090; connect-src 'self' http://blah:9090 ws://blah:9090; form-action 'self' http://blah:9090; base-uri 'self' http://blah:9090; object-src 'none'; font-src 'self' http://blah:9090 data:; img-src 'self' http://blah:9090 data:; block-all-mixed-content\\\",\\\"Content-Type\\\":\\\"text/html\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"<html>\\n<head>\\n<title>Inlay omehay irday</title>\\n</head>\\n<body>Inlay omehay irday</body>\\n</html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_unknown = {\n  .path = \"/another/test.html\",\n  .accept = { \"unknown\" },\n  .headers = { \"Host\", \"blah:9090\" },\n};\n\nstatic void\ntest_localized_unknown (TestCase *tc,\n                        gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_unknown);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \",\\\"Content-Security-Policy\\\":\\\"default-src 'self' http://blah:9090; connect-src 'self' http://blah:9090 ws://blah:9090; form-action 'self' http://blah:9090; base-uri 'self' http://blah:9090; object-src 'none'; font-src 'self' http://blah:9090 data:; img-src 'self' http://blah:9090 data:; block-all-mixed-content\\\",\\\"Content-Type\\\":\\\"text/html\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"<html>\\n<head>\\n<title>In home dir</title>\\n</head>\\n<body>In home dir</body>\\n</html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_prefer_region = {\n  .path = \"/another/test.html\",\n  .accept = { \"pig-pen\" },\n  .headers = { \"Host\", \"blah:9090\" },\n};\n\nstatic void\ntest_localized_prefer_region (TestCase *tc,\n                              gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_prefer_region);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \",\\\"Content-Security-Policy\\\":\\\"default-src 'self' http://blah:9090; connect-src 'self' http://blah:9090 ws://blah:9090; form-action 'self' http://blah:9090; base-uri 'self' http://blah:9090; object-src 'none'; font-src 'self' http://blah:9090 data:; img-src 'self' http://blah:9090 data:; block-all-mixed-content\\\",\\\"Content-Type\\\":\\\"text/html\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"<html>\\n<head>\\n<title>Inway omeha irda</title>\\n</head>\\n<body>Inway omeha irda</body>\\n</html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_fallback = {\n  .path = \"/another/test.html\",\n  .accept = { \"pig-barn\" },\n  .headers = { \"Host\", \"blah:9090\" },\n};\n\nstatic void\ntest_localized_fallback (TestCase *tc,\n                         gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_fallback);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \",\\\"Content-Security-Policy\\\":\\\"default-src 'self' http://blah:9090; connect-src 'self' http://blah:9090 ws://blah:9090; form-action 'self' http://blah:9090; base-uri 'self' http://blah:9090; object-src 'none'; font-src 'self' http://blah:9090 data:; img-src 'self' http://blah:9090 data:; block-all-mixed-content\\\",\\\"Content-Type\\\":\\\"text/html\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"<html>\\n<head>\\n<title>Inlay omehay irday</title>\\n</head>\\n<body>Inlay omehay irday</body>\\n</html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_version = {\n  .path = \"/incompatible/test.html\",\n};\n\nstatic void\ntest_incompatible_version (TestCase *tc,\n                           gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_version);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":503,\\\"reason\\\":\\\"This package requires Cockpit version 999.5 or later\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  cockpit_assert_bytes_eq (data, \"<html><head><title>This package requires Cockpit version 999.5 or later</title></head><body>This package requires Cockpit version 999.5 or later</body></html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_requires = {\n  .path = \"/requires/test.html\",\n};\n\nstatic void\ntest_incompatible_requires (TestCase *tc,\n                            gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_requires);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":503,\\\"reason\\\":\\\"This package is not compatible with this version of Cockpit\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  cockpit_assert_bytes_eq (data, \"<html><head><title>This package is not compatible with this version of Cockpit</title></head><body>This package is not compatible with this version of Cockpit</body></html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_large = {\n  .path = \"/test/sub/COPYING\",\n};\n\nstatic void\ntest_large (TestCase *tc,\n            gconstpointer fixture)\n{\n  GError *error = NULL;\n  gchar *contents;\n  gsize length;\n  gsize prefixlength;\n  GBytes *data;\n  GBytes *sub;\n  guint count;\n  JsonObject *object;\n\n  g_assert (fixture == &fixture_large);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  g_assert (g_file_get_contents (SRCDIR \"/src/bridge/mock-resource/system/cockpit/test/sub/COPYING\",\n                                 &contents, &length, &error));\n  g_assert_no_error (error);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n\n  /* Should not have been sent as one block */\n  g_assert_cmpuint (count, ==, 8);\n  prefixlength = strcspn (g_bytes_get_data (data, NULL), \"}}\") + 2;\n  g_assert_cmpuint (g_bytes_get_size (data), >, prefixlength);\n  object = cockpit_json_parse_object (g_bytes_get_data (data, NULL), prefixlength, &error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \"}}\");\n  sub = g_bytes_new_from_bytes (data, prefixlength, g_bytes_get_size (data) - prefixlength);\n  cockpit_assert_bytes_eq (sub, contents, length);\n\n  json_object_unref (object);\n  g_bytes_unref (sub);\n  g_bytes_unref (data);\n  g_free (contents);\n}\n\nstatic const Fixture fixture_listing = {\n  .path = \"/manifests.json\",\n};\n\nstatic void\ntest_listing (TestCase *tc,\n              gconstpointer fixture)\n{\n  JsonObject *object;\n  GError *error = NULL;\n  GBytes *message;\n  JsonNode *node;\n  guint count;\n\n  g_assert (fixture == &fixture_listing);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  message = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (message, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS_CACHECONTROL \",\\\"Content-Type\\\":\\\"application/json\\\"}}\");\n  json_object_unref (object);\n\n  message = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  node = cockpit_json_parse (g_bytes_get_data (message, NULL), g_bytes_get_size (message), &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (json_node_get_object (node),\n                          \"{\"\n                          \" \\\"another\\\": {\"\n                          \"  \\\"name\\\" : \\\"another\\\",\"\n                          \"  \\\"description\\\" : \\\"another\\\",\"\n                          \"  \\\"bridges\\\": [{ \\\"match\\\": {\\\"host\\\": null },\"\n                          \"                   \\\"problem\\\": \\\"not-supported\\\"}]\"\n                          \" },\"\n                          \" \\\"second\\\": {\"\n                          \"  \\\"description\\\": \\\"second dummy description\\\",\"\n                          \"  \\\"priority\\\": 2,\"\n                          \"  \\\"bridges\\\": [{ \\\"match\\\": { \\\"second\\\": null }, \\\"problem\\\": \\\"never-a-second\\\"}]\"\n                          \" },\"\n                          \" \\\"test\\\": {\"\n                          \"   \\\"name\\\": \\\"test\\\",\"\n                          \"   \\\"priority\\\": 15,\"\n                          \"   \\\"description\\\" : \\\"dummy\\\",\"\n                          \"   \\\"bridges\\\": [{ \\\"match\\\": { \\\"blah\\\": \\\"test*\\\" },\"\n                          \"                  \\\"spawn\\\": [\\\"/usr/bin/cat\\\"],\"\n                          \"                  \\\"environ\\\": [\\\"TEST_ENV=test\\\"]},\"\n                          \"                { \\\"match\\\": { \\\"blah\\\": \\\"marmalade*\\\"},\"\n                          \"                  \\\"problem\\\": \\\"bogus-channel\\\"}]\"\n                          \" },\"\n                          \" \\\"incompatible\\\": {\"\n                          \"   \\\"description\\\" : \\\"incompatible package\\\",\"\n                          \"   \\\"requires\\\" : { \\\"cockpit\\\" : \\\"999.5\\\" }\"\n                          \" },\"\n                          \" \\\"requires\\\": {\"\n                          \"   \\\"description\\\" : \\\"requires package\\\",\"\n                          \"   \\\"requires\\\" : { \\\"unknown\\\" : \\\"requirement\\\" }\"\n                          \" }\"\n                          \"}\");\n  json_node_free (node);\n  g_bytes_unref (message);\n}\n\nstatic const Fixture fixture_not_found = {\n  .path = \"/test/sub/not-found\",\n};\n\nstatic void\ntest_not_found (TestCase *tc,\n                gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n\n\n  g_assert (fixture == &fixture_not_found);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":404,\\\"reason\\\":\\\"Not Found\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n}\n\nstatic const Fixture fixture_unknown_package = {\n  .path = \"/unknownpackage/sub/not-found\",\n};\n\nstatic void\ntest_unknown_package (TestCase *tc,\n                      gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n\n  g_assert (fixture == &fixture_unknown_package);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":404,\\\"reason\\\":\\\"Not Found\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n}\n\nstatic const Fixture fixture_no_path = {\n  .path = \"/test\"\n};\n\nstatic void\ntest_no_path (TestCase *tc,\n              gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n\n  g_assert (fixture == &fixture_no_path);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":404,\\\"reason\\\":\\\"Not Found\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n}\n\nstatic const Fixture fixture_bad_path = {\n  .path = \"/../test/sub/file.ext\"\n};\n\nstatic void\ntest_bad_path (TestCase *tc,\n               gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n\n  g_assert (fixture == &fixture_bad_path);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":404,\\\"reason\\\":\\\"Not Found\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n}\n\nstatic const Fixture fixture_no_package = {\n  .path = \"/test\"\n};\n\nstatic void\ntest_no_package (TestCase *tc,\n                 gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n\n  g_assert (fixture == &fixture_no_package);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":404,\\\"reason\\\":\\\"Not Found\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n}\n\nstatic const Fixture fixture_bad_package = {\n  .path = \"/%%package/test\"\n};\n\nstatic void\ntest_bad_package (TestCase *tc,\n                  gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n\n  g_assert (fixture == &fixture_bad_package);\n\n  cockpit_expect_message (\"invalid 'package' name: %%package\");\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":404,\\\"reason\\\":\\\"Not Found\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"text/html; charset=utf8\\\"}}\");\n  json_object_unref (object);\n}\n\nstatic void\ntest_bad_receive (TestCase *tc,\n                  gconstpointer fixture)\n{\n  GBytes *bad;\n\n  cockpit_expect_log (\"cockpit-protocol\", G_LOG_LEVEL_MESSAGE, \"444: channel received message after done\");\n\n  /* A resource2 channel should never have payload sent to it */\n  bad = g_bytes_new_static (\"bad\", 3);\n  cockpit_transport_emit_recv (COCKPIT_TRANSPORT (tc->transport), \"444\", bad);\n  g_bytes_unref (bad);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_assert_cmpstr (tc->problem, ==, \"protocol-error\");\n}\n\nstatic const Fixture fixture_list_bad_name = {\n    .datadirs = { SRCDIR \"/src/bridge/mock-resource/bad-package\", NULL },\n    .expect = \"*package*invalid*name*\",\n    .path = \"/manifests.json\"\n};\n\nstatic void\ntest_list_bad_name (TestCase *tc,\n                    gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Type\\\":\\\"application/json\\\",\\\"X-Cockpit-Pkg-Checksum\\\":\\\"\" CHECKSUM_BADPACKAGE \"\\\",\\\"ETag\\\":\\\"\\\\\\\"$\" CHECKSUM_BADPACKAGE \"\\\\\\\"\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"{\\\".checksum\\\":\\\"\" CHECKSUM_BADPACKAGE \"\\\",\\\"ok\\\":{\\\".checksum\\\":\\\"\" CHECKSUM_BADPACKAGE \"\\\"}}\", -1);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_glob = {\n    .datadirs = { SRCDIR \"/src/bridge/mock-resource/glob\", NULL },\n    .path = \"/*/file.txt\"\n};\n\nstatic void\ntest_glob (TestCase *tc,\n           gconstpointer fixture)\n{\n  GError *error = NULL;\n  GBytes *message;\n  JsonObject *object;\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  message = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (message, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"X-Cockpit-Pkg-Checksum\\\":\\\"\" CHECKSUM_GLOB \"\\\",\\\"Content-Type\\\":\\\"text/plain\\\"}}\");\n  json_object_unref (object);\n\n  message = mock_transport_pop_channel (tc->transport, \"444\");\n  cockpit_assert_bytes_eq (message, \"a\\n\", 2);\n\n  message = mock_transport_pop_channel (tc->transport, \"444\");\n  cockpit_assert_bytes_eq (message, \"b\\n\", 2);\n}\n\nstatic const Fixture fixture_with_gzip = {\n    .datadirs = { SRCDIR \"/src/bridge/mock-resource/gzip\", NULL },\n    .path = \"/package/file.txt\",\n    .binary = TRUE,\n    .headers = { \"Accept-Encoding\", \"*\" },\n};\n\nstatic void\ntest_with_gzip (TestCase *tc,\n                gconstpointer fixture)\n{\n  GError *error = NULL;\n  GBytes *message;\n  JsonObject *object;\n  GBytes *data;\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  message = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (message, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"X-Cockpit-Pkg-Checksum\\\":\\\"\" CHECKSUM_GZIP \"\\\",\\\"Content-Encoding\\\":\\\"gzip\\\",\\\"Content-Type\\\":\\\"text/plain\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", NULL);\n  g_assert_cmpint (g_bytes_get_size (data), ==, 9377);\n  g_bytes_unref (data);\n}\n\nstatic const Fixture fixture_no_gzip = {\n    .datadirs = { SRCDIR \"/src/bridge/mock-resource/gzip\", NULL },\n    .path = \"/package/file.txt\",\n    .binary = TRUE,\n    .headers = { \"Accept-Encoding\", \"identity\" },\n};\n\nstatic void\ntest_no_gzip (TestCase *tc,\n              gconstpointer fixture)\n{\n  GError *error = NULL;\n  GBytes *message;\n  JsonObject *object;\n  GBytes *data;\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  message = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (message, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"X-Cockpit-Pkg-Checksum\\\":\\\"\" CHECKSUM_GZIP \"\\\",\\\"Content-Type\\\":\\\"text/plain\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", NULL);\n  g_assert_cmpint (g_bytes_get_size (data), ==, 26530);\n  g_bytes_unref (data);\n}\n\nstatic void\nsetup_basic (TestCase *tc,\n             gconstpointer data)\n{\n  const Fixture *fixture = data;\n\n  if (fixture && fixture->datadirs[0])\n    {\n      cockpit_bridge_data_dirs = (const gchar **)fixture->datadirs;\n    }\n  else\n    {\n      cockpit_expect_message (\"incompatible: package requires a later version of cockpit: 999.5*\");\n      cockpit_expect_message (\"requires: package has an unknown requirement: unknown\");\n    }\n\n  if (!fixture || !fixture->no_packages_init)\n    tc->packages = cockpit_packages_new ();\n}\n\nstatic void\nteardown_basic (TestCase *tc,\n                gconstpointer data)\n{\n  cockpit_assert_expected ();\n\n  cockpit_packages_free (tc->packages);\n\n  cockpit_bridge_data_dirs = NULL;\n}\n\nstatic void\ntest_resolve (TestCase *tc,\n              gconstpointer fixture)\n{\n  gchar *path;\n\n  path = cockpit_packages_resolve (tc->packages, \"test\", \"/sub/file.ext\", NULL);\n  g_assert_cmpstr (SRCDIR \"/src/bridge/mock-resource/system/cockpit/test-priority/sub/file.ext\", ==, path);\n  g_free (path);\n\n  path = cockpit_packages_resolve (tc->packages, \"test\", \"/_modules/@testorg/toolkit.js\", NULL);\n  g_assert_cmpstr (SRCDIR \"/src/bridge/mock-resource/system/cockpit/test-priority/_modules/@testorg/toolkit.js\", ==, path);\n  g_free (path);\n}\n\nstatic void\ntest_resolve_bad_dots (TestCase *tc,\n                       gconstpointer fixture)\n{\n  gchar *path;\n\n  cockpit_expect_message (\"invalid 'path' used as a resource: *\");\n\n  path = cockpit_packages_resolve (tc->packages, \"test\", \"../test/sub/file.ext\", NULL);\n  g_assert (path == NULL);\n}\n\nstatic void\ntest_resolve_bad_path (TestCase *tc,\n                       gconstpointer fixture)\n{\n  gchar *path;\n\n  cockpit_expect_message (\"invalid 'path' used as a resource: *\");\n\n  path = cockpit_packages_resolve (tc->packages, \"test\", \"/sub/#file.ext\", NULL);\n  g_assert (path == NULL);\n}\n\nstatic void\ntest_resolve_bad_package (TestCase *tc,\n                          gconstpointer fixture)\n{\n  gchar *path;\n\n  cockpit_expect_message (\"invalid 'package' name: *\");\n\n  path = cockpit_packages_resolve (tc->packages, \"#test\", \"/sub/file.ext\", NULL);\n  g_assert (path == NULL);\n}\n\nstatic void\ntest_resolve_not_found (TestCase *tc,\n                        gconstpointer fixture)\n{\n  gchar *path;\n\n  path = cockpit_packages_resolve (tc->packages, \"unknown\", \"/sub/file.ext\", NULL);\n  g_assert (path == NULL);\n}\n\nstatic int\ncompar_str (const void *pa,\n            const void *pb)\n{\n  return strcmp (*(const char**)pa, *(const char**)pb);\n}\n\nstatic void\ntest_get_names (TestCase *tc,\n                gconstpointer fixture)\n{\n  gchar **names;\n  gchar *result;\n\n  names = cockpit_packages_get_names (tc->packages);\n  g_assert (names != NULL);\n\n  qsort (names, g_strv_length (names), sizeof (gchar *), compar_str);\n  result = g_strjoinv (\", \", names);\n\n  /* Note that unavailable packages are not included */\n  g_assert_cmpstr (result, ==, \"another, second, test\");\n\n  g_free (result);\n  g_free (names);\n}\n\nstatic void\ntest_get_bridges (TestCase *tc,\n                  gconstpointer fixture)\n{\n  GList *bridges, *l;\n  JsonObject *bridge;\n  guint i;\n\n  bridges = cockpit_packages_get_bridges (tc->packages);\n  g_assert (bridges != NULL);\n\n  for (i = 0, l = bridges; l != NULL; l = g_list_next (l), i++)\n    {\n      bridge = l->data;\n      switch (i)\n        {\n        case 0:\n          cockpit_assert_json_eq (json_object_get_object_member (bridge, \"match\"),\n                                  \"{ \\\"blah\\\": \\\"test*\\\" }\");\n          cockpit_assert_json_eq (json_object_get_array_member (bridge, \"environ\"),\n                                  \"[\\\"TEST_ENV=test\\\"]\");\n          cockpit_assert_json_eq (json_object_get_array_member (bridge, \"spawn\"),\n                                  \"[\\\"/usr/bin/cat\\\"]\");\n          break;\n        case 1:\n          cockpit_assert_json_eq (json_object_get_object_member (bridge, \"match\"),\n                                  \"{ \\\"blah\\\": \\\"marmalade*\\\" }\");\n          g_assert_cmpstr (json_object_get_string_member (bridge, \"problem\"), ==, \"bogus-channel\");\n          break;\n        case 2:\n          cockpit_assert_json_eq (json_object_get_object_member (bridge, \"match\"),\n                                  \"{ \\\"second\\\": null }\");\n          g_assert_cmpstr (json_object_get_string_member (bridge, \"problem\"), ==, \"never-a-second\");\n          break;\n        case 3:\n          cockpit_assert_json_eq (json_object_get_object_member (bridge, \"match\"),\n                                  \"{ \\\"host\\\": null }\");\n          g_assert_cmpstr (json_object_get_string_member (bridge, \"problem\"), ==, \"not-supported\");\n          break;\n        default:\n          g_assert_not_reached ();\n        }\n    }\n\n  g_assert_cmpint (i, ==, 4);\n  g_list_free (bridges);\n}\n\nstatic const Fixture fixture_bad_bridges = {\n    .datadirs = { SRCDIR \"/src/bridge/mock-resource/bad-bridges\", NULL },\n};\n\nstatic void\ntest_get_bridges_broken (TestCase *tc,\n                         gconstpointer fixture)\n{\n  GList *bridges;\n\n  g_assert (fixture == &fixture_bad_bridges);\n\n  cockpit_expect_message (\"missing-match: Exactly one of \\\"match\\\" or \\\"privileged\\\" required\");\n  cockpit_expect_message (\"broken-problem: invalid \\\"problem\\\" field in package manifest\");\n  cockpit_expect_message (\"broken-environ: invalid \\\"environ\\\" field in package manifest\");\n  cockpit_expect_message (\"broken-spawn: invalid \\\"spawn\\\" field in package manifest\");\n  cockpit_expect_message (\"broken-match: invalid \\\"match\\\" field in package manifest\");\n  cockpit_expect_message (\"broken-bridges: invalid \\\"bridges\\\" field in package manifest\");\n  cockpit_expect_message (\"broken-bridge: invalid bridge in \\\"bridges\\\" field in package manifest\");\n\n  bridges = cockpit_packages_get_bridges (tc->packages);\n  g_assert (bridges == NULL);\n}\n\nstatic const Fixture fixture_reload = {\n  .no_packages_init = TRUE,\n  .datadirs = { BUILDDIR \"/src/bridge/mock-resource/reload\", NULL },\n};\n\n__attribute__((format(printf, 1, 2)))\nstatic void\nsystemf (const gchar *fmt, ...)\n{\n  gchar *cmd;\n\n  va_list ap;\n  va_start (ap, fmt);\n  cmd = g_strdup_vprintf (fmt, ap);\n  va_end (ap);\n\n  g_assert (system (cmd) == 0);\n\n  g_free (cmd);\n}\n\nstatic void\nsetup_reload_packages (const gchar *datadir,\n                       const gchar *variant)\n{\n  const gchar *srcdir = SRCDIR \"/src/bridge/mock-resource/reload\";\n  systemf (\"mkdir -p $(dirname '%s') && rm -rf '%s' && ln -sf '%s.%s' '%s'\",\n           datadir, datadir, srcdir, variant, datadir);\n}\n\nstatic void\nteardown_reload_packages (const gchar *datadir)\n{\n  systemf (\"rm -f '%s'\", datadir);\n}\n\nstatic void\nassert_manifest_checksum (TestCase *tc,\n                          const gchar *name,\n                          const gchar *expected)\n{\n  JsonObject *json;\n  const gchar *checksum;\n\n  json = cockpit_packages_peek_json (tc->packages);\n  if (name)\n    g_assert (cockpit_json_get_object (json, name, NULL, &json));\n  if (expected)\n    {\n      g_assert (cockpit_json_get_string (json, \".checksum\", NULL, &checksum));\n      g_assert_cmpstr (checksum, ==, expected);\n    }\n  else\n    g_assert (json == NULL);\n}\n\nstatic void\ntest_reload_added (TestCase *tc,\n                   gconstpointer data)\n{\n  const Fixture *fixture = data;\n  const gchar *datadir;\n\n  cockpit_bridge_data_dirs = (const gchar **)fixture->datadirs;\n  datadir = cockpit_bridge_data_dirs[0];\n\n  setup_reload_packages (datadir, \"old\");\n  tc->packages = cockpit_packages_new ();\n\n  assert_manifest_checksum (tc, NULL,  CHECKSUM_RELOAD_OLD);\n  assert_manifest_checksum (tc, \"old\", CHECKSUM_RELOAD_OLD);\n\n  setup_reload_packages (datadir, \"new\");\n  cockpit_packages_reload (tc->packages);\n\n  assert_manifest_checksum (tc, NULL,  CHECKSUM_RELOAD_OLD);\n  assert_manifest_checksum (tc, \"old\", CHECKSUM_RELOAD_OLD);\n  assert_manifest_checksum (tc, \"new\", CHECKSUM_RELOAD_NEW);\n\n  teardown_reload_packages (datadir);\n}\n\nstatic void\ntest_reload_removed (TestCase *tc,\n                     gconstpointer data)\n{\n  const Fixture *fixture = data;\n  const gchar *datadir;\n\n  cockpit_bridge_data_dirs = (const gchar **)fixture->datadirs;\n  datadir = cockpit_bridge_data_dirs[0];\n\n  setup_reload_packages (datadir, \"new\");\n  tc->packages = cockpit_packages_new ();\n\n  assert_manifest_checksum (tc, NULL,  CHECKSUM_RELOAD_NEW);\n  assert_manifest_checksum (tc, \"old\", CHECKSUM_RELOAD_NEW);\n  assert_manifest_checksum (tc, \"new\", CHECKSUM_RELOAD_NEW);\n\n  setup_reload_packages (datadir, \"old\");\n  cockpit_packages_reload (tc->packages);\n\n  assert_manifest_checksum (tc, NULL,  CHECKSUM_RELOAD_NEW);\n  assert_manifest_checksum (tc, \"old\", CHECKSUM_RELOAD_NEW);\n  assert_manifest_checksum (tc, \"new\", NULL);\n\n  teardown_reload_packages (datadir);\n}\n\nstatic void\ntest_reload_updated (TestCase *tc,\n                     gconstpointer data)\n{\n  const Fixture *fixture = data;\n  const gchar *datadir;\n\n  cockpit_bridge_data_dirs = (const gchar **)fixture->datadirs;\n  datadir = cockpit_bridge_data_dirs[0];\n\n  setup_reload_packages (datadir, \"old\");\n  tc->packages = cockpit_packages_new ();\n\n  assert_manifest_checksum (tc, NULL,  CHECKSUM_RELOAD_OLD);\n  assert_manifest_checksum (tc, \"old\", CHECKSUM_RELOAD_OLD);\n\n  setup_reload_packages (datadir, \"updated\");\n  cockpit_packages_reload (tc->packages);\n\n  assert_manifest_checksum (tc, NULL,  CHECKSUM_RELOAD_OLD);\n  assert_manifest_checksum (tc, \"old\", CHECKSUM_RELOAD_UPDATED);\n\n  teardown_reload_packages (datadir);\n}\n\nstatic const Fixture fixture_csp_strip = {\n  .path = \"/strip/test.html\",\n  .datadirs = { SRCDIR \"/src/bridge/mock-resource/csp\", NULL },\n  .headers = { \"Host\", \"blah:9090\" },\n};\n\nstatic void\ntest_csp_strip (TestCase *tc,\n                gconstpointer fixture)\n{\n  GBytes *data;\n  JsonObject *object;\n  GError *error = NULL;\n  guint count;\n\n  g_assert (fixture == &fixture_csp_strip);\n\n  while (tc->closed == FALSE)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpstr (tc->problem, ==, NULL);\n\n  data = mock_transport_pop_channel (tc->transport, \"444\");\n  object = cockpit_json_parse_bytes (data, &error);\n  g_assert_no_error (error);\n  cockpit_assert_json_eq (object, \"{\\\"status\\\":200,\\\"reason\\\":\\\"OK\\\",\\\"headers\\\":{\" STATIC_HEADERS \",\\\"Content-Security-Policy\\\":\\\"connect-src 'self' http://blah:9090 ws://blah:9090; form-action 'self' http://blah:9090; base-uri 'self' http://blah:9090; object-src 'none'; font-src 'self' http://blah:9090 data:; block-all-mixed-content; img-src 'self' http://blah:9090; default-src 'self' http://blah:9090\\\",\\\"Content-Type\\\":\\\"text/html\\\",\\\"X-Cockpit-Pkg-Checksum\\\":\\\"\" CHECKSUM_CSP \"\\\"}}\");\n  json_object_unref (object);\n\n  data = mock_transport_combine_output (tc->transport, \"444\", &count);\n  g_assert_cmpint (count, ==, 1);\n  cockpit_assert_bytes_eq (data, \"<html>\\n<head>\\n<title>Test</title>\\n</head>\\n<body>Test</body>\\n</html>\\n\", -1);\n  g_bytes_unref (data);\n}\n\nint\nmain (int argc,\n      char *argv[])\n{\n  cockpit_setenv_check (\"XDG_DATA_DIRS\", SRCDIR \"/src/bridge/mock-resource/system\", TRUE);\n  cockpit_setenv_check (\"XDG_DATA_HOME\", SRCDIR \"/src/bridge/mock-resource/home\", TRUE);\n\n  cockpit_bridge_local_address = \"127.0.0.1\";\n\n  cockpit_test_init (&argc, &argv);\n\n  g_test_add (\"/packages/simple\", TestCase, &fixture_simple,\n              setup, test_simple, teardown);\n  g_test_add (\"/packages/forwarded\", TestCase, &fixture_forwarded,\n              setup, test_forwarded, teardown);\n  g_test_add (\"/packages/localized-translated\", TestCase, &fixture_pig,\n              setup, test_localized_translated, teardown);\n  g_test_add (\"/packages/localized-unknown\", TestCase, &fixture_unknown,\n              setup, test_localized_unknown, teardown);\n  g_test_add (\"/packages/localized-prefer-region\", TestCase, &fixture_prefer_region,\n              setup, test_localized_prefer_region, teardown);\n  g_test_add (\"/packages/localized-fallback\", TestCase, &fixture_fallback,\n              setup, test_localized_fallback, teardown);\n  g_test_add (\"/packages/incompatible/version\", TestCase, &fixture_version,\n              setup, test_incompatible_version, teardown);\n  g_test_add (\"/packages/incompatible/requires\", TestCase, &fixture_requires,\n              setup, test_incompatible_requires, teardown);\n  g_test_add (\"/packages/large\", TestCase, &fixture_large,\n              setup, test_large, teardown);\n  g_test_add (\"/packages/listing\", TestCase, &fixture_listing,\n              setup, test_listing, teardown);\n  g_test_add (\"/packages/not-found\", TestCase, &fixture_not_found,\n              setup, test_not_found, teardown);\n  g_test_add (\"/packages/unknown-package\", TestCase, &fixture_unknown_package,\n              setup, test_unknown_package, teardown);\n  g_test_add (\"/packages/bad-receive\", TestCase, &fixture_large,\n              setup, test_bad_receive, teardown);\n  g_test_add (\"/packages/no-path\", TestCase, &fixture_no_path,\n              setup, test_no_path, teardown);\n  g_test_add (\"/packages/bad-path\", TestCase, &fixture_bad_path,\n              setup, test_bad_path, teardown);\n  g_test_add (\"/packages/no-package\", TestCase, &fixture_no_package,\n              setup, test_no_package, teardown);\n  g_test_add (\"/packages/bad-package\", TestCase, &fixture_bad_package,\n              setup, test_bad_package, teardown);\n\n  g_test_add (\"/packages/listing-bad-name\", TestCase, &fixture_list_bad_name,\n              setup, test_list_bad_name, teardown);\n\n  g_test_add (\"/packages/glob\", TestCase, &fixture_glob,\n              setup, test_glob, teardown);\n  g_test_add (\"/packages/with-gzip\", TestCase, &fixture_with_gzip,\n              setup, test_with_gzip, teardown);\n  g_test_add (\"/packages/no-gzip\", TestCase, &fixture_no_gzip,\n              setup, test_no_gzip, teardown);\n\n  g_test_add (\"/packages/resolve/simple\", TestCase, NULL,\n              setup_basic, test_resolve, teardown_basic);\n  g_test_add (\"/packages/resolve/bad-dots\", TestCase, NULL,\n              setup_basic, test_resolve_bad_dots, teardown_basic);\n  g_test_add (\"/packages/resolve/bad-path\", TestCase, NULL,\n              setup_basic, test_resolve_bad_path, teardown_basic);\n  g_test_add (\"/packages/resolve/bad-package\", TestCase, NULL,\n              setup_basic, test_resolve_bad_package, teardown_basic);\n  g_test_add (\"/packages/resolve/not-found\", TestCase, NULL,\n              setup_basic, test_resolve_not_found, teardown_basic);\n\n  g_test_add (\"/packages/get-names\", TestCase, NULL,\n              setup_basic, test_get_names, teardown_basic);\n\n  g_test_add (\"/packages/get-bridges/normal\", TestCase, NULL,\n              setup_basic, test_get_bridges, teardown_basic);\n  g_test_add (\"/packages/get-bridges/broken\", TestCase, &fixture_bad_bridges,\n              setup_basic, test_get_bridges_broken, teardown_basic);\n\n  g_test_add (\"/packages/reload/added\", TestCase, &fixture_reload,\n              setup_basic, test_reload_added, teardown_basic);\n  g_test_add (\"/packages/reload/removed\", TestCase, &fixture_reload,\n              setup_basic, test_reload_removed, teardown_basic);\n  g_test_add (\"/packages/reload/updated\", TestCase, &fixture_reload,\n              setup_basic, test_reload_updated, teardown_basic);\n\n  g_test_add (\"/packages/csp/strip\", TestCase, &fixture_csp_strip,\n              setup, test_csp_strip, teardown);\n\n  return g_test_run ();\n}\n", "/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2014 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n/* This gets logged as part of the (more verbose) protocol logging */\n#ifdef G_LOG_DOMAIN\n#undef G_LOG_DOMAIN\n#endif\n#define G_LOG_DOMAIN \"cockpit-protocol\"\n\n#include \"config.h\"\n\n#include \"cockpitwebresponse.h\"\n#include \"cockpitwebfilter.h\"\n\n#include \"common/cockpitconf.h\"\n#include \"common/cockpiterror.h\"\n#include \"common/cockpitflow.h\"\n#include \"common/cockpitlocale.h\"\n#include \"common/cockpittemplate.h\"\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n\n/**\n * Certain processes may want to have a non-default error page.\n */\nconst gchar *cockpit_web_failure_resource = NULL;\n\nstatic const gchar default_failure_template[] =\n  \"<html><head><title>@@message@@</title></head><body>@@message@@</body></html>\\n\";\n\n/**\n * CockpitWebResponse:\n *\n * A response sent back to an HTTP client. You can use the high level one\n * shot APIs, like cockpit_web_response_content() and\n * cockpit_web_response_error() * or low level builder APIs:\n *\n * cockpit_web_response_headers() send the headers\n * cockpit_web_response_queue() send a block of data.\n * cockpit_web_response_complete() finish.\n */\n\nstruct _CockpitWebResponse {\n  GObject parent;\n  GIOStream *io;\n  const gchar *logname;\n  const gchar *path;\n  gchar *full_path;\n  gchar *query;\n  gchar *url_root;\n  gchar *method;\n  gchar *origin;\n\n  CockpitWebResponseFlags flags;\n  CockpitCacheType cache_type;\n\n  /* The output queue */\n  GPollableOutputStream *out;\n  GQueue *queue;\n  gsize out_queued;\n  gsize out_queueable;\n  gsize partial_offset;\n  GSource *source;\n\n  /* Status flags */\n  guint count;\n  gboolean complete;\n  gboolean failed;\n  gboolean done;\n  gboolean chunked;\n  gboolean keep_alive;\n\n  GList *filters;\n};\n\n/* A megabyte is when we start to consider queue full enough */\n#define QUEUE_PRESSURE 1024UL * 1024UL\n\nstatic guint signal__done;\n\nstatic void      cockpit_web_response_flow_iface_init      (CockpitFlowInterface *iface);\n\nG_DEFINE_TYPE_WITH_CODE (CockpitWebResponse, cockpit_web_response, G_TYPE_OBJECT,\n                         G_IMPLEMENT_INTERFACE (COCKPIT_TYPE_FLOW, cockpit_web_response_flow_iface_init));\n\nstatic void\ncockpit_web_response_init (CockpitWebResponse *self)\n{\n  self->queue = g_queue_new ();\n  self->out_queueable = G_MAXSIZE;\n  self->cache_type = COCKPIT_WEB_RESPONSE_CACHE_UNSET;\n}\n\nstatic void\ncockpit_web_response_done (CockpitWebResponse *self)\n{\n  gboolean reusable = FALSE;\n\n  g_object_ref (self);\n\n  g_assert (!self->done);\n  self->done = TRUE;\n\n  if (self->source)\n    {\n      g_source_destroy (self->source);\n      g_source_unref (self->source);\n      self->source = NULL;\n    }\n\n  if (self->complete)\n    {\n      reusable = !self->failed && self->keep_alive;\n      g_object_unref (self);\n    }\n  else if (!self->failed)\n    {\n      g_critical (\"A CockpitWebResponse was freed without being completed properly. \"\n                  \"This is a programming error.\");\n    }\n\n  g_signal_emit (self, signal__done, 0, reusable);\n\n  g_object_unref (self->io);\n  self->io = NULL;\n  self->out = NULL;\n\n  g_object_unref (self);\n}\n\nstatic void\ncockpit_web_response_dispose (GObject *object)\n{\n  CockpitWebResponse *self = COCKPIT_WEB_RESPONSE (object);\n\n  if (!self->done)\n    cockpit_web_response_done (self);\n  g_list_free_full (self->filters, g_object_unref);\n  self->filters = NULL;\n\n  G_OBJECT_CLASS (cockpit_web_response_parent_class)->dispose (object);\n}\n\nstatic void\ncockpit_web_response_finalize (GObject *object)\n{\n  CockpitWebResponse *self = COCKPIT_WEB_RESPONSE (object);\n\n  g_free (self->full_path);\n  g_free (self->query);\n  g_free (self->url_root);\n  g_free (self->method);\n  g_free (self->origin);\n  g_assert (self->io == NULL);\n  g_assert (self->out == NULL);\n  g_queue_free_full (self->queue, (GDestroyNotify)g_bytes_unref);\n  self->out_queued = 0;\n\n  G_OBJECT_CLASS (cockpit_web_response_parent_class)->finalize (object);\n}\n\nstatic void\ncockpit_web_response_class_init (CockpitWebResponseClass *klass)\n{\n  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n\n  gobject_class->dispose = cockpit_web_response_dispose;\n  gobject_class->finalize = cockpit_web_response_finalize;\n\n  signal__done = g_signal_new (\"done\", COCKPIT_TYPE_WEB_RESPONSE,\n                               G_SIGNAL_RUN_LAST,\n                               0, NULL, NULL, NULL,\n                               G_TYPE_NONE, 1, G_TYPE_BOOLEAN);\n}\n\n/**\n * cockpit_web_response_new:\n * @io: the stream to send on\n * @path: the path resource or NULL\n * @query: the query string or NULL\n * @in_headers: input headers or NULL\n * @flags: in #COCKPIT_WEB_RESPONSE_FOR_TLS_PROXY mode, the origin is assumed to\n *         be https://<host> even for a non-HTTPS connection.\n *\n * Create a new web response.\n *\n * The returned reference belongs to the caller. Additionally\n * once cockpit_web_response_complete() is called, an additional\n * reference is held until the response is sent and flushed.\n *\n * Returns: (transfer full): the new response, unref when done with it\n */\nCockpitWebResponse *\ncockpit_web_response_new (GIOStream *io,\n                          const gchar *original_path,\n                          const gchar *path,\n                          const gchar *query,\n                          GHashTable *in_headers,\n                          CockpitWebResponseFlags flags)\n{\n  CockpitWebResponse *self;\n  GOutputStream *out;\n  const gchar *connection;\n  const gchar *protocol = NULL;\n  const gchar *host = NULL;\n  gint offset;\n\n  /* Trying to be a somewhat performant here, avoiding properties */\n  self = g_object_new (COCKPIT_TYPE_WEB_RESPONSE, NULL);\n  self->io = g_object_ref (io);\n\n  out = g_io_stream_get_output_stream (io);\n  if (G_IS_POLLABLE_OUTPUT_STREAM (out))\n    {\n      self->out = (GPollableOutputStream *)out;\n    }\n  else if (out)\n    {\n      g_critical (\"Cannot send web response over non-pollable output stream: %s\",\n                  G_OBJECT_TYPE_NAME (out));\n    }\n  else\n    {\n      g_critical (\"Cannot send web response: no output stream available\");\n    }\n\n  self->url_root = NULL;\n  self->full_path = g_strdup (path);\n  self->path = self->full_path;\n\n  if (path && original_path)\n    {\n      offset = strlen (original_path) - strlen (path);\n      if (offset > 0 && g_strcmp0 (original_path + offset, path) == 0)\n        self->url_root = g_strndup (original_path, offset);\n    }\n\n  self->query = g_strdup (query);\n  if (self->path)\n    self->logname = self->path;\n  else\n    self->logname = \"response\";\n\n  self->keep_alive = TRUE;\n  if (in_headers)\n    {\n      connection = g_hash_table_lookup (in_headers, \"Connection\");\n      if (connection)\n        self->keep_alive = g_str_equal (connection, \"keep-alive\");\n      host = g_hash_table_lookup (in_headers, \"Host\");\n    }\n\n  self->flags = flags;\n  protocol = cockpit_web_response_get_protocol (self, in_headers);\n  if (protocol && host)\n    self->origin = g_strdup_printf (\"%s://%s\", protocol, host);\n\n  return self;\n}\n\nvoid\ncockpit_web_response_set_method (CockpitWebResponse *response,\n                                 const gchar *method)\n{\n  g_return_if_fail (g_strcmp0 (method, \"GET\") == 0 || g_strcmp0 (method, \"HEAD\") == 0);\n  response->method = g_strdup (method);\n}\n\n/**\n * cockpit_web_response_get_path:\n * @self: the response\n *\n * Returns: the resource path for response\n */\nconst gchar *\ncockpit_web_response_get_path (CockpitWebResponse *self)\n{\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), NULL);\n  return self->path;\n}\n\n/**\n * cockpit_web_response_get_url_root:\n * @self: the response\n *\n * Returns: The url root portion of the original path that was removed\n */\nconst gchar *\ncockpit_web_response_get_url_root (CockpitWebResponse *self) {\n  return self->url_root;\n}\n\n/**\n * cockpit_web_response_get_query:\n * @self: the response\n *\n * Returns: the resource path for response\n */\nconst gchar *\ncockpit_web_response_get_query (CockpitWebResponse *self)\n{\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), NULL);\n  return self->query;\n}\n\n/**\n * cockpit_web_response_get_stream:\n * @self: the response\n *\n * Returns: the stream we're sending on\n */\nGIOStream *\ncockpit_web_response_get_stream  (CockpitWebResponse *self)\n{\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), NULL);\n  return self->io;\n}\n\n#if !GLIB_CHECK_VERSION(2,43,2)\n#define G_IO_ERROR_CONNECTION_CLOSED G_IO_ERROR_BROKEN_PIPE\n#endif\n\ngboolean\ncockpit_web_should_suppress_output_error (const gchar *logname,\n                                          GError *error)\n{\n  if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_CONNECTION_CLOSED) ||\n      g_error_matches (error, G_IO_ERROR, G_IO_ERROR_BROKEN_PIPE))\n    {\n      g_debug (\"%s: output error: %s\", logname, error->message);\n      return TRUE;\n    }\n\n#if !GLIB_CHECK_VERSION(2,43,2)\n  if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED) &&\n      strstr (error->message, g_strerror (ECONNRESET)))\n    {\n      g_debug (\"%s: output error: %s\", logname, error->message);\n      return TRUE;\n    }\n#endif\n\n  return FALSE;\n}\n\nstatic void\non_output_flushed (GObject *stream,\n                   GAsyncResult *result,\n                   gpointer user_data)\n{\n  CockpitWebResponse *self = COCKPIT_WEB_RESPONSE (user_data);\n  GOutputStream *output = G_OUTPUT_STREAM (stream);\n  GError *error = NULL;\n\n  if (g_output_stream_flush_finish (output, result, &error))\n    {\n      g_debug (\"%s: flushed output\", self->logname);\n    }\n  else\n    {\n      if (!cockpit_web_should_suppress_output_error (self->logname, error))\n        g_message (\"%s: couldn't flush web output: %s\", self->logname, error->message);\n      self->failed = TRUE;\n      g_error_free (error);\n    }\n\n  cockpit_web_response_done (self);\n  g_object_unref (self);\n}\n\nstatic gboolean\non_response_output (GObject *pollable,\n                    gpointer user_data)\n{\n  CockpitWebResponse *self = user_data;\n  GError *error = NULL;\n  const guint8 *data;\n  GBytes *block;\n  gssize count;\n  gsize before, size, len;\n\n  block = g_queue_peek_head (self->queue);\n  if (block)\n    {\n      data = g_bytes_get_data (block, &len);\n      g_assert (len == 0 || self->partial_offset < len);\n      data += self->partial_offset;\n      len -= self->partial_offset;\n\n      before = self->out_queued;\n\n      if (len > 0)\n        {\n          count = g_pollable_output_stream_write_nonblocking (self->out, data, len,\n                                                              NULL, &error);\n        }\n      else\n        {\n          count = 0;\n        }\n\n      if (count < 0)\n        {\n          if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_WOULD_BLOCK))\n            {\n              g_error_free (error);\n              return TRUE;\n            }\n\n          if (!cockpit_web_should_suppress_output_error (self->logname, error))\n            g_message (\"%s: couldn't write web output: %s\", self->logname, error->message);\n\n          self->failed = TRUE;\n          cockpit_web_response_done (self);\n\n          g_error_free (error);\n          return FALSE;\n        }\n\n      if (count == len)\n        {\n          g_debug (\"%s: sent %d bytes\", self->logname, (int)len);\n          self->partial_offset = 0;\n          block = g_queue_pop_head (self->queue);\n          size = g_bytes_get_size (block);\n          g_assert (size <= self->out_queued);\n          self->out_queued -= size;\n          g_bytes_unref (block);\n        }\n      else\n        {\n          g_debug (\"%s: sent %d partial\", self->logname, (int)count);\n          g_assert (count < len);\n          self->partial_offset += count;\n        }\n\n      /*\n       * If we're controlling another flow, turn it on again when our output\n       * buffer size becomes less than the low mark.\n       */\n      if (before >= QUEUE_PRESSURE && self->out_queued < QUEUE_PRESSURE)\n        cockpit_flow_emit_pressure (COCKPIT_FLOW (self), FALSE);\n\n      return TRUE;\n    }\n  else\n    {\n      g_source_destroy (self->source);\n      g_source_unref (self->source);\n      self->source = NULL;\n\n      if (self->complete)\n        {\n          g_debug (\"%s: complete flushing output\", self->logname);\n          g_output_stream_flush_async (G_OUTPUT_STREAM (self->out), G_PRIORITY_DEFAULT,\n                                       NULL, on_output_flushed, g_object_ref (self));\n        }\n\n      return FALSE;\n    }\n}\n\nstatic void\nqueue_bytes (CockpitWebResponse *self,\n             GBytes *block)\n{\n  gsize size, before;\n\n  size = g_bytes_get_size (block);\n  before = self->out_queued;\n  g_return_if_fail (G_MAXSIZE - size > self->out_queued);\n  self->out_queued += size;\n\n  g_queue_push_tail (self->queue, g_bytes_ref (block));\n\n  self->count++;\n\n  if (!self->source)\n    {\n      self->source = g_pollable_output_stream_create_source (self->out, NULL);\n      g_source_set_callback (self->source, (GSourceFunc)on_response_output, self, NULL);\n      g_source_attach (self->source, NULL);\n    }\n\n  if (before < QUEUE_PRESSURE && self->out_queued >= QUEUE_PRESSURE)\n    cockpit_flow_emit_pressure (COCKPIT_FLOW (self), TRUE);\n}\n\nstatic void\nqueue_block (CockpitWebResponse *self,\n             GBytes *block)\n{\n  gsize length = g_bytes_get_size (block);\n  GBytes *bytes;\n  gchar *data;\n\n  /*\n   * We cannot queue chunks of length zero. Besides being silly, this\n   * messes with chunked encoding. The 0 length block means end of\n   * response.\n   */\n  if (length == 0)\n    return;\n\n  if (self->out_queueable < length)\n    {\n      g_critical (\"Too much data queuing in HTTP response. This is a programmer error.\");\n      return;\n    }\n\n  self->out_queueable -= length;\n  g_debug (\"%s: queued %d bytes\", self->logname, (int)length);\n\n  if (!self->chunked)\n    {\n      queue_bytes (self, block);\n    }\n  else\n    {\n      /* Required for chunked transfer encoding. */\n      data = g_strdup_printf (\"%x\\r\\n\", (unsigned int)length);\n      bytes = g_bytes_new_take (data, strlen (data));\n      queue_bytes (self, bytes);\n      g_bytes_unref (bytes);\n\n      queue_bytes (self, block);\n\n      bytes = g_bytes_new_static (\"\\r\\n\", 2);\n      queue_bytes (self, bytes);\n      g_bytes_unref (bytes);\n    }\n}\n\ntypedef struct {\n  CockpitWebResponse *response;\n  GList *filters;\n} QueueStep;\n\nstatic void\nqueue_filter (gpointer data,\n              GBytes *bytes)\n{\n  QueueStep *qs = data;\n  QueueStep qn = { .response = qs->response };\n\n  g_return_if_fail (bytes != NULL);\n\n  if (qs->filters)\n    {\n      qn.filters = qs->filters->next;\n      cockpit_web_filter_push (qs->filters->data, bytes, queue_filter, &qn);\n    }\n  else\n    {\n      queue_block (qs->response, bytes);\n    }\n}\n\n/**\n * cockpit_web_response_queue:\n * @self: the response\n * @block: the block of data to queue\n *\n * Queue a single block of data on the response. Will be sent\n * during the main loop.\n *\n * See cockpit_web_response_content() for a simple way to\n * avoid queueing individual blocks.\n *\n * If this function returns %FALSE, then the response has failed\n * or has been completed elsewhere. The block was ignored and\n * queuing more blocks doesn't makes sense.\n *\n * After done queuing all your blocks call\n * cockpit_web_response_complete().\n*\n * Returns: Whether queuing more blocks makes sense\n */\ngboolean\ncockpit_web_response_queue (CockpitWebResponse *self,\n                            GBytes *block)\n{\n  QueueStep qn = { .response = self };\n\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), FALSE);\n  g_return_val_if_fail (block != NULL, FALSE);\n  g_return_val_if_fail (self->complete == FALSE, FALSE);\n\n  if (self->failed)\n    {\n      g_debug (\"%s: ignoring queued block after failure\", self->logname);\n      return FALSE;\n    }\n\n  if (g_strcmp0 (self->method, \"HEAD\") == 0)\n    {\n      g_debug (\"%s: ignoring queued block for method HEAD\", self->logname);\n      return TRUE;\n    }\n\n  qn.filters = self->filters;\n  queue_filter (&qn, block);\n  return TRUE;\n}\n\n/**\n * cockpit_web_response_complete:\n * @self: the response\n *\n * See cockpit_web_response_content() for easy to use stuff.\n *\n * Tell the response that all the data has been queued.\n * The response will hold a reference to itself until the\n * data is actually sent, so you can unref it.\n */\nvoid\ncockpit_web_response_complete (CockpitWebResponse *self)\n{\n  GBytes *bytes;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n  g_return_if_fail (self->complete == FALSE);\n\n  if (self->failed)\n    return;\n\n  /* Hold a reference until cockpit_web_response_done() */\n  g_object_ref (self);\n  self->complete = TRUE;\n\n  if (self->chunked)\n    {\n      bytes = g_bytes_new_static (\"0\\r\\n\\r\\n\", 5);\n      queue_bytes (self, bytes);\n      g_bytes_unref (bytes);\n    }\n\n  if (self->source)\n    {\n      g_debug (\"%s: queueing complete\", self->logname);\n    }\n  else\n    {\n      g_debug (\"%s: complete closing io\", self->logname);\n      g_output_stream_flush_async (G_OUTPUT_STREAM (self->out), G_PRIORITY_DEFAULT,\n                                   NULL, on_output_flushed, g_object_ref (self));\n    }\n}\n\n/**\n * cockpit_web_response_abort:\n * @self: the response\n *\n * This function is used when streaming content, and at\n * some point we can't provide the remainder of the content\n *\n * This completes the response and terminates the connection.\n */\nvoid\ncockpit_web_response_abort (CockpitWebResponse *self)\n{\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n  g_return_if_fail (self->complete == FALSE);\n\n  if (self->failed)\n    return;\n\n  /* Hold a reference until cockpit_web_response_done() */\n  g_object_ref (self);\n\n  self->complete = TRUE;\n  self->failed = TRUE;\n\n  g_debug (\"%s: aborted\", self->logname);\n  cockpit_web_response_done (self);\n}\n\n/**\n * CockpitWebResponding:\n * @COCKPIT_WEB_RESPONSE_READY: nothing queued or sent yet\n * @COCKPIT_WEB_RESPONSE_QUEUING: started and still queuing data on response\n * @COCKPIT_WEB_RESPONSE_COMPLETE: all data is queued or aborted\n * @COCKPIT_WEB_RESPONSE_SENT: data is completely sent\n *\n * Various states of the web response.\n */\n\n/**\n * cockpit_web_response_get_state:\n * @self: the web response\n *\n * Return the state of the web response.\n */\nCockpitWebResponding\ncockpit_web_response_get_state (CockpitWebResponse *self)\n{\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), 0);\n\n  if (self->done)\n    return COCKPIT_WEB_RESPONSE_SENT;\n  else if (self->complete)\n    return COCKPIT_WEB_RESPONSE_COMPLETE;\n  else if (self->count == 0)\n    return COCKPIT_WEB_RESPONSE_READY;\n  else\n    return COCKPIT_WEB_RESPONSE_QUEUING;\n}\n\ngboolean\ncockpit_web_response_is_simple_token (const gchar *string)\n{\n  string += strcspn (string, \" \\t\\r\\n\\v\");\n  return string[0] == '\\0';\n}\n\ngboolean\ncockpit_web_response_is_header_value (const gchar *string)\n{\n  string += strcspn (string, \"\\r\\n\\v\");\n  return string[0] == '\\0';\n}\n\nenum {\n    HEADER_CONTENT_TYPE = 1 << 0,\n    HEADER_CONTENT_ENCODING = 1 << 1,\n    HEADER_VARY = 1 << 2,\n    HEADER_CACHE_CONTROL = 1 << 3,\n    HEADER_DNS_PREFETCH_CONTROL = 1 << 4,\n    HEADER_REFERRER_POLICY = 1 << 5,\n    HEADER_CONTENT_TYPE_OPTIONS = 1 << 6,\n    HEADER_CROSS_ORIGIN_RESOURCE_POLICY = 1 << 7,\n    HEADER_X_FRAME_OPTIONS = 1 << 8,\n};\n\nstatic GString *\nbegin_headers (CockpitWebResponse *response,\n               guint status,\n               const gchar *reason)\n{\n  GString *string;\n\n  string = g_string_sized_new (1024);\n  g_string_printf (string, \"HTTP/1.1 %d %s\\r\\n\", status, reason);\n\n  return string;\n}\n\nstatic guint\nappend_header (GString *string,\n               const gchar *name,\n               const gchar *value)\n{\n  if (value)\n    {\n      g_return_val_if_fail (cockpit_web_response_is_simple_token (name), 0);\n      g_return_val_if_fail (cockpit_web_response_is_header_value (value), 0);\n      g_string_append_printf (string, \"%s: %s\\r\\n\", name, value);\n    }\n  if (g_ascii_strcasecmp (\"Content-Type\", name) == 0)\n    return HEADER_CONTENT_TYPE;\n  if (g_ascii_strcasecmp (\"Cache-Control\", name) == 0)\n    return HEADER_CACHE_CONTROL;\n  if (g_ascii_strcasecmp (\"Vary\", name) == 0)\n    return HEADER_VARY;\n  if (g_ascii_strcasecmp (\"Content-Encoding\", name) == 0)\n    return HEADER_CONTENT_ENCODING;\n  if (g_ascii_strcasecmp (\"X-DNS-Prefetch-Control\", name) == 0)\n    return HEADER_DNS_PREFETCH_CONTROL;\n  if (g_ascii_strcasecmp (\"Referrer-Policy\", name) == 0)\n    return HEADER_REFERRER_POLICY;\n  if (g_ascii_strcasecmp (\"X-Content-Type-Options\", name) == 0)\n    return HEADER_CONTENT_TYPE_OPTIONS;\n  if (g_ascii_strcasecmp (\"Cross-Origin-Resource-Policy\", name) == 0)\n    return HEADER_CROSS_ORIGIN_RESOURCE_POLICY;\n  if (g_ascii_strcasecmp (\"X-Frame-Options\", name) == 0)\n    return HEADER_X_FRAME_OPTIONS;\n  if (g_ascii_strcasecmp (\"Content-Length\", name) == 0 ||\n      g_ascii_strcasecmp (\"Transfer-Encoding\", name) == 0 ||\n      g_ascii_strcasecmp (\"Connection\", name) == 0)\n    {\n      g_critical (\"Don't set %s header manually. This is a programmer error.\", name);\n    }\n  return 0;\n}\n\nstatic guint\nappend_table (GString *string,\n              GHashTable *headers)\n{\n  GHashTableIter iter;\n  gpointer key;\n  gpointer value;\n  guint seen = 0;\n\n  if (headers)\n    {\n      g_hash_table_iter_init (&iter, headers);\n      while (g_hash_table_iter_next (&iter, &key, &value))\n        seen |= append_header (string, key, value);\n    }\n\n  return seen;\n}\n\nstatic guint\nappend_va (GString *string,\n           va_list va)\n{\n  const gchar *name;\n  const gchar *value;\n  guint seen = 0;\n\n  for (;;)\n    {\n      name = va_arg (va, const gchar *);\n      if (!name)\n        break;\n      value = va_arg (va, const gchar *);\n      seen |= append_header (string, name, value);\n    }\n\n  return seen;\n}\n\nstatic GBytes *\nfinish_headers (CockpitWebResponse *self,\n                GString *string,\n                gssize length,\n                gint status,\n                guint seen)\n{\n  const gchar *content_type;\n\n  /* Automatically figure out content type */\n  if ((seen & HEADER_CONTENT_TYPE) == 0 &&\n      self->full_path != NULL && status >= 200 && status <= 299)\n    {\n      content_type = cockpit_web_response_content_type (self->full_path);\n      if (content_type)\n        g_string_append_printf (string, \"Content-Type: %s\\r\\n\", content_type);\n    }\n\n  if (status != 304)\n    {\n      if (length < 0 || seen & HEADER_CONTENT_ENCODING || self->filters)\n        {\n          self->chunked = TRUE;\n          g_string_append_printf (string, \"Transfer-Encoding: chunked\\r\\n\");\n        }\n      else\n        {\n          self->chunked = FALSE;\n          g_string_append_printf (string, \"Content-Length: %\" G_GSSIZE_FORMAT \"\\r\\n\", length);\n          self->out_queueable = length;\n        }\n    }\n\n  if ((seen & HEADER_CACHE_CONTROL) == 0 && status >= 200 && status <= 299)\n    {\n      if (self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_FOREVER)\n        g_string_append (string, \"Cache-Control: max-age=31556926, public\\r\\n\");\n      else if (self->cache_type == COCKPIT_WEB_RESPONSE_NO_CACHE)\n        g_string_append (string, \"Cache-Control: no-cache, no-store\\r\\n\");\n      else if (self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE)\n        g_string_append (string, \"Cache-Control: max-age=86400, private\\r\\n\");\n    }\n\n  if ((seen & HEADER_VARY) == 0 && status >= 200 && status <= 299 &&\n      self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE)\n    {\n      g_string_append (string, \"Vary: Cookie\\r\\n\");\n    }\n\n  if (!self->keep_alive)\n    g_string_append (string, \"Connection: close\\r\\n\");\n\n  /* Some blanket security headers */\n  if ((seen & HEADER_DNS_PREFETCH_CONTROL) == 0)\n    g_string_append (string, \"X-DNS-Prefetch-Control: off\\r\\n\");\n  if ((seen & HEADER_REFERRER_POLICY) == 0)\n    g_string_append (string, \"Referrer-Policy: no-referrer\\r\\n\");\n  if ((seen & HEADER_CONTENT_TYPE_OPTIONS) == 0)\n    g_string_append (string, \"X-Content-Type-Options: nosniff\\r\\n\");\n  /* Be very strict here -- there is no reason that external web sites should\n   * be able to read any resource. This does *not* affect embedding with <iframe> */\n  if ((seen & HEADER_CROSS_ORIGIN_RESOURCE_POLICY) == 0)\n    g_string_append (string, \"Cross-Origin-Resource-Policy: same-origin\\r\\n\");\n  /* This is the counterpart for iframe embedding, line of defence against clickjacking */\n  if ((seen & HEADER_X_FRAME_OPTIONS) == 0)\n    g_string_append (string, \"X-Frame-Options: sameorigin\\r\\n\");\n\n  g_string_append (string, \"\\r\\n\");\n  return g_string_free_to_bytes (string);\n}\n\n/**\n * cockpit_web_response_set_cache_type:\n * @self: the response\n * @cache_type: Ensures the appropriate cache headers are returned for\n   the given cache type.\n */\nvoid\ncockpit_web_response_set_cache_type (CockpitWebResponse *self,\n                                     CockpitCacheType cache_type)\n{\n  self->cache_type = cache_type;\n}\n\n/**\n * cockpit_web_response_headers:\n * @self: the response\n * @status: the HTTP status code\n * @reason: the HTTP reason\n * @length: the combined length of data blocks to follow, or -1\n *\n * See cockpit_web_response_content() for an easy to use function.\n *\n * Queue the headers of the response. No data blocks must yet be\n * queued on the response.\n *\n * Specify header name/value pairs in the var args, and end with\n * a NULL name. If value is NULL, then that header won't be sent.\n *\n * Don't specify Content-Length or Connection headers.\n *\n * If @length is zero or greater, then it must represent the\n * number of queued blocks to follow.\n */\nvoid\ncockpit_web_response_headers (CockpitWebResponse *self,\n                              guint status,\n                              const gchar *reason,\n                              gssize length,\n                              ...)\n{\n  GString *string;\n  GBytes *block;\n  va_list va;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n\n  if (self->count > 0)\n    {\n      g_critical (\"Headers should be sent first. This is a programmer error.\");\n      return;\n    }\n\n  string = begin_headers (self, status, reason);\n\n  va_start (va, length);\n  block = finish_headers (self, string, length, status,\n                          append_va (string, va));\n  va_end (va);\n\n  queue_bytes (self, block);\n  g_bytes_unref (block);\n}\n\n/**\n * cockpit_web_response_headers:\n * @self: the response\n * @status: the HTTP status code\n * @reason: the HTTP reason\n * @length: the combined length of data blocks to follow, or -1\n * @headers: headers to include or NULL\n *\n * See cockpit_web_response_content() for an easy to use function.\n *\n * Queue the headers of the response. No data blocks must yet be\n * queued on the response.\n *\n * Don't put Content-Length or Connection in @headers.\n *\n * If @length is zero or greater, then it must represent the\n * number of queued blocks to follow.\n */\nvoid\ncockpit_web_response_headers_full  (CockpitWebResponse *self,\n                                    guint status,\n                                    const gchar *reason,\n                                    gssize length,\n                                    GHashTable *headers)\n{\n  GString *string;\n  GBytes *block;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n\n  if (self->count > 0)\n    {\n      g_critical (\"Headers should be sent first. This is a programmer error.\");\n      return;\n    }\n\n  string = begin_headers (self, status, reason);\n\n  block = finish_headers (self, string, length, status,\n                          append_table (string, headers));\n\n  queue_bytes (self, block);\n  g_bytes_unref (block);\n}\n\n/**\n * cockpit_web_response_content:\n * @self: the response\n * @headers: headers to include or NULL\n * @block: first block to send\n *\n * This is a simple way to send an HTTP response as a single\n * call. The response will be complete after this call, and will\n * send in the main-loop.\n *\n * The var args are additional GBytes* blocks to send, followed by\n * a trailing NULL.\n *\n * Don't include Content-Length or Connection in @headers.\n *\n * This calls cockpit_web_response_headers_full(),\n * cockpit_web_response_queue() and cockpit_web_response_complete()\n * internally.\n */\nvoid\ncockpit_web_response_content (CockpitWebResponse *self,\n                              GHashTable *headers,\n                              GBytes *block,\n                              ...)\n{\n  GBytes *first;\n  gsize length = 0;\n  va_list va;\n  va_list va2;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n\n  first = block;\n  va_start (va, block);\n  va_copy (va2, va);\n\n  while (block)\n    {\n      length += g_bytes_get_size (block);\n      block = va_arg (va, GBytes *);\n    }\n  va_end (va);\n\n  cockpit_web_response_headers_full (self, 200, \"OK\", length, headers);\n\n  block = first;\n  for (;;)\n    {\n      if (!block)\n        {\n          cockpit_web_response_complete (self);\n          break;\n        }\n      if (!cockpit_web_response_queue (self, block))\n        break;\n      block = va_arg (va2, GBytes *);\n    }\n  va_end (va2);\n}\n\nstatic GBytes *\nsubstitute_message (const gchar *variable,\n                    gpointer user_data)\n{\n  const gchar *message = user_data;\n  if (g_str_equal (variable, \"message\"))\n    return g_bytes_new (message, strlen (message));\n  return NULL;\n}\n\nstatic GBytes *\nsubstitute_hash_value (const gchar *variable,\n                       gpointer user_data)\n{\n  GHashTable *data = user_data;\n  gchar *value = g_hash_table_lookup (data, variable);\n  if (value)\n    return g_bytes_new (value, strlen (value));\n  return g_bytes_new (\"\", 0);\n}\n\n/**\n * cockpit_web_response_error:\n * @self: the response\n * @status: the HTTP status code\n * @headers: headers to include or NULL\n * @format: printf format of error message\n *\n * Send an error message with a basic HTML page containing\n * the error.\n */\nvoid\ncockpit_web_response_error (CockpitWebResponse *self,\n                            guint code,\n                            GHashTable *headers,\n                            const gchar *format,\n                            ...)\n{\n  va_list var_args;\n  gchar *reason = NULL;\n  gchar *escaped = NULL;\n  const gchar *message;\n  GBytes *input = NULL;\n  GList *output, *l;\n  GError *error = NULL;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n\n  if (format)\n    {\n      va_start (var_args, format);\n      reason = g_strdup_vprintf (format, var_args);\n      va_end (var_args);\n      message = reason;\n    }\n  else\n    {\n      switch (code)\n        {\n        case 400:\n          message = \"Bad request\";\n          break;\n        case 401:\n          message = \"Not Authorized\";\n          break;\n        case 403:\n          message = \"Forbidden\";\n          break;\n        case 404:\n          message = \"Not Found\";\n          break;\n        case 405:\n          message = \"Method Not Allowed\";\n          break;\n        case 413:\n          message = \"Request Entity Too Large\";\n          break;\n        case 502:\n          message = \"Remote Page is Unavailable\";\n          break;\n        case 500:\n          message = \"Internal Server Error\";\n          break;\n        default:\n          if (code < 100)\n            reason = g_strdup_printf (\"%u Continue\", code);\n          else if (code < 200)\n            reason = g_strdup_printf (\"%u OK\", code);\n          else if (code < 300)\n            reason = g_strdup_printf (\"%u Moved\", code);\n          else\n            reason = g_strdup_printf (\"%u Failed\", code);\n          message = reason;\n          break;\n        }\n    }\n\n  g_debug (\"%s: returning error: %u %s\", self->logname, code, message);\n\n  if (cockpit_web_failure_resource)\n    {\n      input = g_resources_lookup_data (cockpit_web_failure_resource, G_RESOURCE_LOOKUP_FLAGS_NONE, &error);\n      if (input == NULL)\n        {\n          g_critical (\"couldn't load: %s: %s\", cockpit_web_failure_resource, error->message);\n          g_error_free (error);\n        }\n    }\n\n  if (!input)\n    input = g_bytes_new_static (default_failure_template, strlen (default_failure_template));\n  output = cockpit_template_expand (input, \"@@\", \"@@\", substitute_message, (gpointer) message);\n  g_bytes_unref (input);\n\n  /* If sending arbitrary messages, make sure they're escaped */\n  if (reason)\n    {\n      g_strstrip (reason);\n      escaped = g_uri_escape_string (reason, \" :\", FALSE);\n      message = escaped;\n    }\n\n  if (headers)\n    {\n      if (!g_hash_table_lookup (headers, \"Content-Type\"))\n        g_hash_table_replace (headers, g_strdup (\"Content-Type\"), g_strdup (\"text/html; charset=utf8\"));\n      cockpit_web_response_headers_full (self, code, message, -1, headers);\n    }\n  else\n    {\n      cockpit_web_response_headers (self, code, message, -1, \"Content-Type\", \"text/html; charset=utf8\", NULL);\n    }\n\n  for (l = output; l != NULL; l = g_list_next (l))\n    {\n      if (!cockpit_web_response_queue (self, l->data))\n        break;\n    }\n  if (l == NULL)\n    cockpit_web_response_complete (self);\n  g_list_free_full (output, (GDestroyNotify)g_bytes_unref);\n\n  g_free (reason);\n  g_free (escaped);\n}\n\n/**\n * cockpit_web_response_error:\n * @self: the response\n * @headers: headers to include or NULL\n * @error: the error\n *\n * Send an error message with a basic HTML page containing\n * the error.\n */\nvoid\ncockpit_web_response_gerror (CockpitWebResponse *self,\n                             GHashTable *headers,\n                             GError *error)\n{\n  int code;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n\n  if (g_error_matches (error,\n                       COCKPIT_ERROR, COCKPIT_ERROR_AUTHENTICATION_FAILED))\n    code = 401;\n  else if (g_error_matches (error,\n                       COCKPIT_ERROR, COCKPIT_ERROR_PERMISSION_DENIED))\n    code = 403;\n  else if (g_error_matches (error,\n                            G_IO_ERROR, G_IO_ERROR_INVALID_DATA))\n    code = 400;\n  else if (g_error_matches (error,\n                            G_IO_ERROR, G_IO_ERROR_NO_SPACE))\n    code = 413;\n  else\n    code = 500;\n\n  cockpit_web_response_error (self, code, headers, \"%s\", error->message);\n}\n\nstatic gboolean\npath_has_prefix (const gchar *path,\n                 const gchar *prefix)\n{\n  gsize len;\n  if (prefix == NULL)\n    return FALSE;\n  len = strlen (prefix);\n  if (len == 0)\n    return FALSE;\n  if (!g_str_has_prefix (path, prefix))\n    return FALSE;\n  if (prefix[len - 1] == '/' ||\n      path[len] == '/')\n    return TRUE;\n  return FALSE;\n}\n\ngchar **\ncockpit_web_response_resolve_roots (const gchar **input)\n{\n  GPtrArray *roots;\n  char *path;\n  gint i;\n\n  roots = g_ptr_array_new ();\n  for (i = 0; input && input[i]; i++)\n    {\n      path = realpath (input[i], NULL);\n      if (path == NULL)\n        g_debug (\"couldn't resolve document root: %s: %m\", input[i]);\n      else\n        g_ptr_array_add (roots, path);\n    }\n  g_ptr_array_add (roots, NULL);\n  return (gchar **)g_ptr_array_free (roots, FALSE);\n}\n\nstatic void\nweb_response_file (CockpitWebResponse *response,\n                   const gchar *escaped,\n                   const gchar **roots,\n                   CockpitTemplateFunc template_func,\n                   gpointer user_data)\n{\n  const gchar *default_policy = \"default-src 'self' 'unsafe-inline';\";\n\n  const gchar *headers[5] = { NULL };\n  GError *error = NULL;\n  gchar *unescaped = NULL;\n  gchar *path = NULL;\n  gchar *alloc = NULL;\n  GMappedFile *file = NULL;\n  const gchar *root;\n  GBytes *body;\n  GList *output = NULL;\n  GList *l = NULL;\n  gint content_length = -1;\n  gint at = 0;\n\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (response));\n\n  if (!escaped)\n    escaped = cockpit_web_response_get_path (response);\n\n  g_return_if_fail (escaped != NULL);\n\n  /* Someone is trying to escape the root directory, or access hidden files? */\n  unescaped = g_uri_unescape_string (escaped, \"/\");\n  if (!unescaped || strstr (unescaped, \"/.\") || strstr (unescaped, \"../\") || strstr (unescaped, \"//\"))\n    {\n      g_debug (\"%s: invalid path request\", escaped);\n      cockpit_web_response_error (response, 404, NULL, \"Not Found\");\n      goto out;\n    }\n\nagain:\n  root = *(roots++);\n  if (root == NULL)\n    {\n      cockpit_web_response_error (response, 404, NULL, \"Not Found\");\n      goto out;\n    }\n\n  g_free (path);\n  path = g_build_filename (root, unescaped, NULL);\n\n  if (g_file_test (path, G_FILE_TEST_IS_DIR))\n    {\n      cockpit_web_response_error (response, 403, NULL, \"Directory Listing Denied\");\n      goto out;\n    }\n\n  /* As a double check of above behavior */\n  g_assert (path_has_prefix (path, root));\n\n  g_clear_error (&error);\n  file = g_mapped_file_new (path, FALSE, &error);\n  if (file == NULL)\n    {\n      if (g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT) ||\n          g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NAMETOOLONG))\n        {\n          g_debug (\"%s: file not found in root: %s\", escaped, root);\n          goto again;\n        }\n      else if (g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_PERM) ||\n               g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_ACCES) ||\n               g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_ISDIR))\n        {\n          cockpit_web_response_error (response, 403, NULL, \"Access denied\");\n          goto out;\n        }\n      else\n        {\n          g_warning (\"%s: %s\", path, error->message);\n          cockpit_web_response_error (response, 500, NULL, \"Internal server error\");\n          goto out;\n        }\n    }\n\n  body = g_mapped_file_get_bytes (file);\n  if (template_func)\n    {\n      output = cockpit_template_expand (body, \"${\", \"}\", template_func, user_data);\n    }\n  else\n    {\n      output = g_list_prepend (output, g_bytes_ref (body));\n      content_length = g_bytes_get_size (body);\n    }\n  g_bytes_unref (body);\n\n  if (response->origin)\n    {\n      headers[at++] = \"Access-Control-Allow-Origin\";\n      headers[at++] = response->origin;\n    }\n\n  /*\n   * The default Content-Security-Policy for .html files allows\n   * the site to have inline <script> and <style> tags. This code\n   * is only used for static resources that do not use the session.\n   */\n  if (g_str_has_suffix (unescaped, \".html\"))\n    {\n      headers[at++] = \"Content-Security-Policy\";\n      headers[at++] = alloc = cockpit_web_response_security_policy (default_policy, response->origin);\n    }\n\n  cockpit_web_response_headers (response, 200, \"OK\", content_length,\n                                headers[0], headers[1], headers[2], headers[3], NULL);\n\n  for (l = output; l != NULL; l = g_list_next (l))\n    {\n      if (!cockpit_web_response_queue (response, l->data))\n        break;\n    }\n  if (l == NULL)\n    cockpit_web_response_complete (response);\n\nout:\n  g_free (alloc);\n  g_free (unescaped);\n  g_clear_error (&error);\n  g_free (path);\n  if (file)\n    g_mapped_file_unref (file);\n\n  if (output)\n    g_list_free_full (output, (GDestroyNotify)g_bytes_unref);\n}\n\n/**\n * cockpit_web_response_file:\n * @response: the response\n * @path: escaped path, or NULL to get from response\n * @roots: directories to look for file in\n *\n * Serve a file from disk as an HTTP response.\n */\nvoid\ncockpit_web_response_file (CockpitWebResponse *response,\n                           const gchar *escaped,\n                           const gchar **roots)\n{\n  web_response_file (response, escaped, roots, NULL, NULL);\n}\n\nvoid\ncockpit_web_response_template (CockpitWebResponse *response,\n                                   const gchar *escaped,\n                                   const gchar **roots,\n                                   GHashTable *values)\n{\n  web_response_file (response, escaped, roots, substitute_hash_value, values);\n}\n\nstatic gboolean\nresponse_next_path (CockpitWebResponse *self,\n                    gchar **component)\n{\n  const gchar *beg = NULL;\n  const gchar *path;\n\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), FALSE);\n\n  path = self->path;\n\n  if (path && path[0] == '/')\n    {\n      beg = path + 1;\n      path = strchr (beg, '/');\n    }\n  else\n    {\n      path = NULL;\n    }\n\n  if (!beg || path == beg)\n    return FALSE;\n\n  self->path = path;\n\n  if (self->path)\n    {\n      if (component)\n        *component = g_strndup (beg, path - beg);\n    }\n  else if (beg && beg[0])\n    {\n      if (component)\n        *component = g_strdup (beg);\n    }\n  else\n    {\n      return FALSE;\n    }\n\n  return TRUE;\n}\n\ngboolean\ncockpit_web_response_skip_path (CockpitWebResponse *self)\n{\n  return response_next_path (self, NULL);\n}\n\ngchar *\ncockpit_web_response_pop_path (CockpitWebResponse *self)\n{\n  gchar *component = NULL;\n  if (!response_next_path (self, &component))\n    return NULL;\n  return component;\n}\n\nvoid\ncockpit_web_response_add_filter (CockpitWebResponse *self,\n                                 CockpitWebFilter *filter)\n{\n  g_return_if_fail (COCKPIT_IS_WEB_RESPONSE (self));\n  g_return_if_fail (COCKPIT_IS_WEB_FILTER (filter));\n  g_return_if_fail (self->count == 0);\n  self->filters = g_list_append (self->filters, g_object_ref (filter));\n}\n\n/**\n * cockpit_web_response_gunzip:\n * @bytes: the compressed bytes\n * @error: place to put an error\n *\n * Perform gzip decompression on the @bytes.\n *\n * Returns: the uncompressed bytes, caller owns return value.\n */\nGBytes *\ncockpit_web_response_gunzip (GBytes *bytes,\n                             GError **error)\n{\n  GConverter *converter;\n  GConverterResult result;\n  const guint8 *in;\n  gsize inl, outl, read, written;\n  GByteArray *out;\n\n  converter = G_CONVERTER (g_zlib_decompressor_new (G_ZLIB_COMPRESSOR_FORMAT_GZIP));\n\n  in = g_bytes_get_data (bytes, &inl);\n  out = g_byte_array_new ();\n\n  do\n    {\n      outl = out->len;\n      g_byte_array_set_size (out, outl + inl);\n\n      result = g_converter_convert (converter, in, inl, out->data + outl, inl,\n                                    G_CONVERTER_INPUT_AT_END, &read, &written, error);\n      if (result == G_CONVERTER_ERROR)\n        break;\n\n      g_byte_array_set_size (out, outl + written);\n      in += read;\n      inl -= read;\n    }\n  while (result != G_CONVERTER_FINISHED);\n\n  g_object_unref (converter);\n\n  if (result != G_CONVERTER_FINISHED)\n    {\n      g_byte_array_unref (out);\n      return NULL;\n    }\n  else\n    {\n      return g_byte_array_free_to_bytes (out);\n    }\n}\n\nstatic const gchar *\nfind_extension (const gchar *path)\n{\n  const gchar *dot;\n  const gchar *slash;\n\n  dot = strrchr (path, '.');\n  slash = strrchr (path, '/');\n\n  /* Dots before the last slash don't count */\n  if (dot && slash && dot < slash)\n    dot = NULL;\n\n  /* Leading dots on the filename don't count */\n  if (dot && (dot == path || dot == slash + 1))\n    dot = NULL;\n\n  return dot;\n}\n\nstatic GBytes *\nload_file (const gchar *filename,\n           GError **error)\n{\n  GError *local_error = NULL;\n\n  g_autoptr(GMappedFile) mapped = g_mapped_file_new (filename, FALSE, &local_error);\n\n  if (mapped)\n    /* success! */\n    return g_mapped_file_get_bytes (mapped);\n\n  if (g_error_matches (local_error, G_FILE_ERROR, G_FILE_ERROR_NOENT) ||\n      g_error_matches (local_error, G_FILE_ERROR, G_FILE_ERROR_ISDIR) ||\n      g_error_matches (local_error, G_FILE_ERROR, G_FILE_ERROR_NAMETOOLONG) ||\n      g_error_matches (local_error, G_FILE_ERROR, G_FILE_ERROR_LOOP) ||\n      g_error_matches (local_error, G_FILE_ERROR, G_FILE_ERROR_INVAL))\n    {\n      g_clear_error (&local_error);\n    }\n\n  /* A real error to stop on */\n  else\n    {\n      g_propagate_error (error, local_error);\n    }\n\n  return NULL;\n}\n\n/**\n * cockpit_web_response_negotiation:\n * @path: likely filesystem path\n * @existing: a table of existing files\n * @chosen: out, a pointer to the suffix that was chosen\n * @error: a failure\n *\n * Find a file to serve based on the suffixes. We prune off extra\n * extensions while looking for a file that's present. We append\n * .min and .gz when looking for files. We also check for the language\n * before the extensions if set.\n *\n * The @existing may be NULL, if non-null it'll be used to check if\n * files exist.\n */\nGBytes *\ncockpit_web_response_negotiation (const gchar *path,\n                                  GHashTable *existing,\n                                  const gchar *language,\n                                  gchar **actual,\n                                  GError **error)\n{\n  gchar *base = NULL;\n  const gchar *ext;\n  gchar *dot;\n  gchar *name = NULL;\n  GBytes *bytes = NULL;\n  GError *local_error = NULL;\n  gchar *locale = NULL;\n  gchar *shorter = NULL;\n  gchar *lang = NULL;\n  gchar *lang_region = NULL;\n\n  gint i;\n\n  if (language)\n      locale = cockpit_locale_from_language (language, NULL, &shorter);\n\n  ext = find_extension (path);\n  if (ext)\n    {\n      base = g_strndup (path, ext - path);\n    }\n  else\n    {\n      ext = \"\";\n      base = g_strdup (path);\n    }\n\n  while (!bytes)\n    {\n      /* For a request for a file named \"base.ext\" and locale \"lang_REGION\", We try the following variants, in\n         order, and serve the first that is found:\n\n           base.lang_REGION.ext\n           base.lang_REGION.ext.gz\n           base.lang.ext\n           base.lang.ext.gz\n           base.ext\n           base.min.ext\n           base.ext.gz\n           base.ext.min.gz\n\n         If no locale is requested, or a locale without region, those variants are left out by starting\n         further down in the list.\n\n         If none of the variants are found, and the base of the file name has internal dots, these internal\n         extensions are dropped one by one from the right.  For example, for a file named \"foo.bar.js\", we\n         first try \"foo.bar\" with extension \".js\", and then \"foo\" with extension \".js\".\n      */\n\n      if (locale && shorter && g_strcmp0 (locale, shorter) != 0) {\n        lang = shorter;\n        lang_region = locale;\n        i = 0;\n      } else if (locale) {\n        lang = locale;\n        i = 2;\n      } else {\n        i = 4;\n      }\n\n      for (; i < 8; i++)\n        {\n          g_free (name);\n          switch (i)\n            {\n            case 0:\n              name = g_strconcat (base, \".\", lang_region, ext, NULL);\n              break;\n            case 1:\n              name = g_strconcat (base, \".\", lang_region, ext, \".gz\", NULL);\n              break;\n            case 2:\n              name = g_strconcat (base, \".\", lang, ext, NULL);\n              break;\n            case 3:\n              name = g_strconcat (base, \".\", lang, ext, \".gz\", NULL);\n              break;\n            case 4:\n              name = g_strconcat (base, ext, NULL);\n              break;\n            case 5:\n              name = g_strconcat (base, \".min\", ext, NULL);\n              break;\n            case 6:\n              name = g_strconcat (base, ext, \".gz\", NULL);\n              break;\n            case 7:\n              name = g_strconcat (base, \".min\", ext, \".gz\", NULL);\n              break;\n            default:\n              g_assert_not_reached ();\n            }\n\n          if (existing)\n            {\n              if (!g_hash_table_lookup (existing, name))\n                continue;\n            }\n\n          bytes = load_file (name, &local_error);\n          if (bytes)\n            break;\n          if (local_error)\n            goto out;\n        }\n\n      /* Pop one level off the file name */\n      dot = (gchar *)find_extension (base);\n      if (!dot)\n        break;\n\n      dot[0] = '\\0';\n    }\n\nout:\n  if (local_error)\n    g_propagate_error (error, local_error);\n  if (bytes && name && actual)\n    {\n      *actual = name;\n      name = NULL;\n    }\n  g_free (name);\n  g_free (base);\n  g_free (locale);\n  g_free (shorter);\n  return bytes;\n}\n\nconst gchar *\ncockpit_web_response_content_type (const gchar *path)\n{\n  static const struct {\n    const gchar *extension;\n    const gchar *content_type;\n  } content_types[] = {\n    { \".css\", \"text/css\" },\n    { \".gif\", \"image/gif\" },\n    { \".eot\", \"application/vnd.ms-fontobject\" },\n    { \".html\", \"text/html\" },\n    /* { \".ico\", \"image/vnd.microsoft.icon\" }, */\n    { \".jpg\", \"image/jpg\" },\n    { \".js\", \"application/javascript\" },\n    { \".json\", \"application/json\" },\n    { \".otf\", \"font/opentype\" },\n    { \".png\", \"image/png\" },\n    { \".svg\", \"image/svg+xml\" },\n    { \".ttf\", \"application/octet-stream\" }, /* unassigned */\n    { \".txt\", \"text/plain\" },\n    { \".wasm\", \"application/wasm\" },\n    { \".woff\", \"application/font-woff\" },\n    { \".xml\", \"text/xml\" },\n  };\n\n  gint i;\n\n  for (i = 0; i < G_N_ELEMENTS (content_types); i++)\n    {\n      if (g_str_has_suffix (path, content_types[i].extension))\n          return content_types[i].content_type;\n    }\n\n  return NULL;\n}\n\nstatic gboolean\nstrv_have_prefix (gchar **strv,\n                  const gchar *prefix)\n{\n  gint i;\n\n  for (i = 0; strv && strv[i] != NULL; i++)\n    {\n      if (g_str_has_prefix (strv[i], prefix))\n        return TRUE;\n    }\n  return FALSE;\n}\n\nstatic void\nstring_inject_origin (GString *string,\n                      const gchar *origin)\n{\n  const gchar *found;\n  gsize pos = 0;\n\n  for (;;)\n    {\n      found = strstr (string->str + pos, \"'self'\");\n      if (!found)\n        break;\n\n      pos = (found - string->str) + 6;\n      g_string_insert (string, pos, \" \");\n      g_string_insert (string, pos + 1, origin);\n      pos += strlen (origin) + 1;\n    }\n}\n\n/**\n * cockpit_web_response_content_security_policy:\n * @content_security_policy: the raw security policy or %NULL for a default\n * @self_origin: our own web origin or %NULL\n *\n * Calculates the security policy.\n *\n * Returns: A calculated security policy, filled with defaults if necessary.\n */\ngchar *\ncockpit_web_response_security_policy (const gchar *content_security_policy,\n                                      const gchar *self_origin)\n{\n  const gchar *default_src = \"default-src 'self'\";\n  const gchar *form_action = \"form-action 'self'\";\n  const gchar *base_uri = \"base-uri 'self'\";\n  const gchar *object_src = \"object-src 'none'\";\n  const gchar *font_src = \"font-src 'self' data:\";\n  const gchar *img_src = \"img-src 'self' data:\";\n  const gchar *block_all_mixed_content = \"block-all-mixed-content\";\n  gchar **parts = NULL;\n  GString *result;\n  gint i;\n\n  result = g_string_sized_new (128);\n\n  /*\n   * Note that browsers need to be explicitly told they can connect\n   * to a WebSocket. This is non-obvious, but it stems from the fact\n   * that some browsers treat 'https' and 'wss' as different protocols.\n   *\n   * Since each component could establish a WebSocket connection back to\n   * cockpit-ws, we need to insert that into the policy.\n   */\n\n  if (content_security_policy)\n    parts = g_strsplit (content_security_policy, \";\", -1);\n\n  for (i = 0; parts && parts[i] != NULL; i++)\n    g_strstrip (parts[i]);\n\n  if (!strv_have_prefix (parts, \"default-src \"))\n    g_string_append_printf (result, \"%s; \", default_src);\n  if (!strv_have_prefix (parts, \"connect-src \"))\n    {\n      g_string_append (result, \"connect-src 'self'\");\n      if (self_origin && g_str_has_prefix (self_origin, \"http\"))\n        g_string_append_printf (result, \" ws%s\", self_origin + 4);\n      g_string_append (result, \"; \");\n    }\n  if (!strv_have_prefix (parts, \"form-action \"))\n    g_string_append_printf (result, \"%s; \", form_action);\n  if (!strv_have_prefix (parts, \"base-uri \"))\n    g_string_append_printf (result, \"%s; \", base_uri);\n  if (!strv_have_prefix (parts, \"object-src \"))\n    g_string_append_printf (result, \"%s; \", object_src);\n  if (!strv_have_prefix (parts, \"font-src \"))\n    g_string_append_printf (result, \"%s; \", font_src);\n  if (!strv_have_prefix (parts, \"img-src \"))\n    g_string_append_printf (result, \"%s; \", img_src);\n  if (!strv_have_prefix (parts, \"block-all-mixed-content\"))\n    g_string_append_printf (result, \"%s; \", block_all_mixed_content);\n\n  for (i = 0; parts && parts[i] != NULL; i++)\n    g_string_append_printf (result, \"%s; \", parts[i]);\n\n  g_strfreev (parts);\n\n  /* Remove trailing semicolon */\n  g_string_set_size (result, result->len - 2);\n\n  /* Put in our own origin */\n  if (self_origin)\n    string_inject_origin (result, self_origin);\n\n  return g_string_free (result, FALSE);\n}\n\nconst gchar *\ncockpit_web_response_get_origin (CockpitWebResponse *self)\n{\n  g_return_val_if_fail (COCKPIT_IS_WEB_RESPONSE (self), NULL);\n  return self->origin;\n}\n\nconst gchar *\ncockpit_web_response_get_protocol (CockpitWebResponse *self,\n                                   GHashTable *headers)\n{\n  return cockpit_connection_get_protocol (self->io, headers, self->flags & COCKPIT_WEB_RESPONSE_FOR_TLS_PROXY);\n}\n\nstatic void\ncockpit_web_response_flow_iface_init (CockpitFlowInterface *iface)\n{\n  /* No implementation */\n}\n\nconst gchar *\ncockpit_connection_get_protocol (GIOStream *connection,\n                                 GHashTable *headers,\n                                 gboolean for_tls_proxy)\n{\n  const gchar *protocol = NULL;\n  const gchar *protocol_header;\n\n  if (connection && G_IS_TLS_CONNECTION (connection))\n    {\n      protocol = \"https\";\n    }\n  else\n    {\n      protocol_header = cockpit_conf_string (\"WebService\", \"ProtocolHeader\");\n      if (protocol_header && headers)\n         protocol = g_hash_table_lookup (headers, protocol_header);\n    }\n\n  return protocol ?: (for_tls_proxy ? \"https\" : \"http\");\n}\n", "/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2014 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include \"cockpitwebinject.h\"\n#include \"cockpitwebresponse.h\"\n#include \"cockpitwebserver.h\"\n\n#include \"mock-io-stream.h\"\n\n#include \"common/cockpittest.h\"\n\n#include \"websocket/websocket.h\"\n\n#include <glib/gstdio.h>\n\n#include <stdlib.h>\n#include <string.h>\n\n/* headers that are present in every request */\n#define STATIC_HEADERS \"X-DNS-Prefetch-Control: off\\r\\nReferrer-Policy: no-referrer\\r\\nX-Content-Type-Options: nosniff\\r\\nCross-Origin-Resource-Policy: same-origin\\r\\nX-Frame-Options: sameorigin\\r\\n\\r\\n\"\nstatic gchar *srcdir;\n\ntypedef struct {\n    CockpitWebResponse *response;\n    GOutputStream *output;\n    gchar *scratch;\n    gboolean response_done;\n    gulong sig_done;\n} TestCase;\n\ntypedef struct {\n    const gchar *path;\n    const gchar *header;\n    const gchar *value;\n    const gchar *expected_content_type;\n    CockpitCacheType cache;\n    gboolean for_tls_proxy;\n} TestFixture;\n\nstatic void\non_response_done (CockpitWebResponse *response,\n                  gboolean reusable,\n                  gpointer user_data)\n{\n  gboolean *response_done = user_data;\n  g_assert (response_done != NULL);\n  g_assert (*response_done == FALSE);\n  *response_done = TRUE;\n}\n\nstatic void\nsetup (TestCase *tc,\n       gconstpointer data)\n{\n  const TestFixture *fixture = data;\n  const gchar *path = NULL;\n  GHashTable *headers = NULL;\n  GInputStream *input;\n  GIOStream *io;\n\n  if (fixture)\n    path = fixture->path;\n\n  input = g_memory_input_stream_new ();\n  tc->output = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);\n  io = mock_io_stream_new (input, tc->output);\n  g_object_unref (input);\n\n  if (fixture && fixture->header)\n    {\n      headers = cockpit_web_server_new_table ();\n      g_hash_table_insert (headers, g_strdup (fixture->header), g_strdup (fixture->value));\n    }\n\n  tc->response = cockpit_web_response_new (io, path, path, NULL, headers,\n                                           (fixture && fixture->for_tls_proxy) ? COCKPIT_WEB_RESPONSE_FOR_TLS_PROXY : COCKPIT_WEB_RESPONSE_NONE);\n\n  if (headers)\n    g_hash_table_unref (headers);\n  g_object_unref (io);\n\n  tc->sig_done = g_signal_connect (tc->response, \"done\",\n                                   G_CALLBACK (on_response_done),\n                                   &tc->response_done);\n}\n\nstatic void\nteardown (TestCase *tc,\n          gconstpointer data)\n{\n  while (g_main_context_iteration (NULL, FALSE));\n  g_assert (tc->response_done);\n\n  g_signal_handler_disconnect (tc->response, tc->sig_done);\n  g_clear_object (&tc->output);\n  g_clear_object (&tc->response);\n  g_free (tc->scratch);\n}\n\nstatic const gchar *\noutput_as_string (TestCase *tc)\n{\n  while (!tc->response_done)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_free (tc->scratch);\n  tc->scratch = g_strndup (g_memory_output_stream_get_data (G_MEMORY_OUTPUT_STREAM (tc->output)),\n                           g_memory_output_stream_get_data_size (G_MEMORY_OUTPUT_STREAM (tc->output)));\n  return tc->scratch;\n}\n\nstatic void\ntest_return_content (TestCase *tc,\n                     gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  content = g_bytes_new_static (\"the content\", 11);\n  cockpit_web_response_content (tc->response, NULL, content, NULL);\n  g_bytes_unref (content);\n\n  resp = output_as_string (tc);\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Length: 11\\r\\n\" STATIC_HEADERS \"the content\");\n}\n\nstatic void\ntest_return_content_headers (TestCase *tc,\n                             gconstpointer data)\n{\n  const gchar *resp;\n  GHashTable *headers;\n  GBytes *content;\n\n  headers = cockpit_web_server_new_table ();\n  g_hash_table_insert (headers, g_strdup (\"My-header\"), g_strdup (\"my-value\"));\n\n  content = g_bytes_new_static (\"the content\", 11);\n  cockpit_web_response_content (tc->response, headers, content, NULL);\n  g_bytes_unref (content);\n  g_hash_table_destroy (headers);\n\n  resp = output_as_string (tc);\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nMy-header: my-value\\r\\nContent-Length: 11\\r\\n\" STATIC_HEADERS \"the content\");\n}\n\n\nstatic void\ntest_return_error (TestCase *tc,\n                   gconstpointer data)\n{\n  const gchar *resp;\n\n  cockpit_expect_message (\"Returning error-response 500*\");\n\n  cockpit_web_response_error (tc->response, 500, NULL, \"Reason here: %s\", \"booyah\");\n\n  resp = output_as_string (tc);\n  g_assert_cmpstr (resp, ==,\n    \"HTTP/1.1 500 Reason here: booyah\\r\\n\"\n    \"Content-Type: text/html; charset=utf8\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    STATIC_HEADERS\n    \"13\\r\\n<html><head><title>\\r\\n\"\n    \"13\\r\\nReason here: booyah\\r\\n\"\n    \"15\\r\\n</title></head><body>\\r\\n\"\n    \"13\\r\\nReason here: booyah\\r\\n\"\n    \"f\\r\\n</body></html>\\n\\r\\n\"\n    \"0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_return_error_headers (TestCase *tc,\n                           gconstpointer data)\n{\n  const gchar *resp;\n  GHashTable *headers;\n\n  cockpit_expect_message (\"Returning error-response 500*\");\n\n  headers = cockpit_web_server_new_table ();\n  g_hash_table_insert (headers, g_strdup (\"Header1\"), g_strdup (\"value1\"));\n\n  cockpit_web_response_error (tc->response, 500, headers, \"Reason here: %s\", \"booyah\");\n\n  g_hash_table_destroy (headers);\n\n  resp = output_as_string (tc);\n  cockpit_assert_strmatch(resp,\"HTTP/1.1 500 Reason here: booyah\\r*\\n\"\n    \"Header1: value1\\r*\\n\"\n    \"\\r\\n\");\n}\n\nstatic void\ntest_return_gerror_headers (TestCase *tc,\n                            gconstpointer data)\n{\n  const gchar *resp;\n  GHashTable *headers;\n  GError *error;\n\n  cockpit_expect_message (\"Returning error-response 500*\");\n\n  headers = cockpit_web_server_new_table ();\n  g_hash_table_insert (headers, g_strdup (\"Header1\"), g_strdup (\"value1\"));\n\n  error = g_error_new (G_IO_ERROR, G_IO_ERROR_FAILED, \"Reason here: %s\", \"booyah\");\n  cockpit_web_response_gerror (tc->response, headers, error);\n\n  g_error_free (error);\n  g_hash_table_destroy (headers);\n\n  resp = output_as_string (tc);\n  cockpit_assert_strmatch(resp,\"HTTP/1.1 500 Reason here: booyah\\r*\\n\"\n    \"Header1: value1\\r*\\n\"\n    \"\\r\\n\");\n}\n\nstatic void\ntest_return_error_resource (TestCase *tc,\n                            gconstpointer user_data)\n{\n  const gchar *roots[] = { srcdir, NULL };\n  cockpit_web_failure_resource = \"/org/cockpit-project/Cockpit/fail.html\";\n  cockpit_web_response_file (tc->response, \"/non-existent\", roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 404 Not Found*<img*Not Found*\");\n  cockpit_web_failure_resource = NULL;\n}\n\nstatic void\ntest_file_not_found (TestCase *tc,\n                     gconstpointer user_data)\n{\n  const gchar *roots[] = { srcdir, NULL };\n  cockpit_web_response_file (tc->response, \"/non-existent\", roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 404 Not Found*\");\n}\n\nstatic void\ntest_file_directory_denied (TestCase *tc,\n                            gconstpointer user_data)\n{\n  const gchar *roots[] = { srcdir, NULL };\n  cockpit_web_response_file (tc->response, \"/src\", roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 403 Directory Listing Denied*\");\n}\n\nstatic void\ntest_file_access_denied (TestCase *tc,\n                         gconstpointer user_data)\n{\n  const gchar *roots[] = { \"/tmp\", NULL };\n  gchar templ[] = \"/tmp/test-temp.XXXXXX\";\n\n  if (!g_mkdtemp_full (templ, 0000))\n    g_assert_not_reached ();\n\n  cockpit_web_response_file (tc->response, templ + 4, roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 403*\");\n\n  g_unlink (templ);\n}\n\nstatic void\ntest_file_breakout_denied (TestCase *tc,\n                           gconstpointer user_data)\n{\n  gchar *root = realpath ( SRCDIR \"/src\", NULL);\n  const gchar *roots[] = { root, NULL };\n  const gchar *breakout = \"/../Makefile.am\";\n  gchar *check = g_build_filename (roots[0], breakout, NULL);\n  g_assert (root);\n  g_assert (g_file_test (check, G_FILE_TEST_EXISTS));\n  g_free (check);\n  cockpit_web_response_file (tc->response, breakout, roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 404*\");\n  free (root);\n}\n\nstatic void\ntest_file_encoding_denied (TestCase *tc,\n                           gconstpointer user_data)\n{\n  gchar *root = realpath ( SRCDIR \"/src\", NULL);\n  const gchar *roots[] = { root, NULL };\n  const gchar *breakout = \"/common/Makefile-common.am%00\";\n  gchar *check = g_build_filename (roots[0], \"common\", \"Makefile-common.am\", NULL);\n  g_assert (root);\n  g_assert (g_file_test (check, G_FILE_TEST_EXISTS));\n  g_free (check);\n  cockpit_web_response_file (tc->response, breakout, roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 404*\");\n  free (root);\n}\n\nstatic void\ntest_file_slash_denied (TestCase *tc,\n                        gconstpointer user_data)\n{\n  gchar *root = realpath ( SRCDIR \"/src\", NULL);\n  const gchar *roots[] = { root, NULL };\n  const gchar *breakout = \"/common%2fMakefile-common.am\";\n  gchar *check = g_build_filename (roots[0], \"common\", \"Makefile-common.am\", NULL);\n  g_assert (root);\n  g_assert (g_file_test (check, G_FILE_TEST_EXISTS));\n  g_free (check);\n  cockpit_web_response_file (tc->response, breakout, roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 404*\");\n  free (root);\n}\n\nstatic void\ntest_file_breakout_non_existant (TestCase *tc,\n                                 gconstpointer user_data)\n{\n  gchar *root = realpath ( SRCDIR \"/src\", NULL);\n  const gchar *roots[] = { root, NULL };\n  const gchar *breakout = \"/../non-existent\";\n  gchar *check = g_build_filename (roots[0], breakout, NULL);\n  g_assert (root);\n  g_assert (!g_file_test (check, G_FILE_TEST_EXISTS));\n  g_free (check);\n  cockpit_web_response_file (tc->response, breakout, roots);\n  cockpit_assert_strmatch (output_as_string (tc), \"HTTP/1.1 404*\");\n  free (root);\n}\n\nstatic const TestFixture content_type_fixture_html = {\n  .path = \"/pkg/shell/index.html\",\n  .expected_content_type = \"text/html\",\n};\n\nstatic const TestFixture content_type_fixture_png = {\n  .path = \"/pkg/shell/images/server-small.png\",\n  .expected_content_type = \"image/png\",\n};\n\nstatic const TestFixture content_type_fixture_wasm = {\n  .path = \"/src/common/mock-content/test.wasm\",\n  .expected_content_type = \"application/wasm\",\n};\n\nstatic void\ntest_content_type (TestCase *tc,\n                   gconstpointer user_data)\n{\n  const TestFixture *fixture = user_data;\n  const gchar *roots[] = { srcdir, NULL };\n  GHashTable *headers;\n  const gchar *resp;\n  gsize length;\n  guint status;\n  gssize off;\n\n  cockpit_web_response_file (tc->response, NULL, roots);\n\n  resp = output_as_string (tc);\n  length = strlen (resp);\n\n  off = web_socket_util_parse_status_line (resp, length, NULL, &status, NULL);\n  g_assert_cmpuint (off, >, 0);\n  g_assert_cmpint (status, ==, 200);\n\n  off = web_socket_util_parse_headers (resp + off, length - off, &headers);\n  g_assert_cmpuint (off, >, 0);\n\n  g_assert_cmpstr (g_hash_table_lookup (headers, \"Content-Type\"), ==, fixture->expected_content_type);\n\n  g_hash_table_unref (headers);\n}\n\nstatic const TestFixture template_fixture = {\n  .path = \"/test.css\"\n};\n\nstatic void\ntest_template (TestCase *tc,\n               gconstpointer user_data)\n{\n  const gchar *roots[] = { SRCDIR \"/src/common/mock-content/\", NULL };\n  const gchar *resp;\n  GHashTable *data = g_hash_table_new (g_str_hash, g_str_equal);\n\n  g_hash_table_insert (data, \"NAME\", \"test\");\n  g_hash_table_insert (data, \"VARIANT\", \"VALUE\");\n  cockpit_web_response_template (tc->response, NULL, roots, data);\n\n  resp = output_as_string (tc);\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Type: text/css\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS \"17\\r\\n#brand {\\n    content: \\\"\\r\\n4\\r\\ntest\\r\\n4\\r\\n <b>\\r\\n5\\r\\nVALUE\\r\\n9\\r\\n</b>\\\";\\n}\\n\\r\\n0\\r\\n\\r\\n\");\n  g_hash_table_unref (data);\n}\n\nstatic const TestFixture cache_forever_fixture = {\n  .path = \"/pkg/shell/index.html\",\n  .cache = COCKPIT_WEB_RESPONSE_CACHE_FOREVER,\n};\n\nstatic const TestFixture cache_none_fixture = {\n  .path = \"/pkg/shell/index.html\",\n  .cache = COCKPIT_WEB_RESPONSE_NO_CACHE\n};\n\nstatic const TestFixture cache_private_fixture = {\n  .path = \"/pkg/shell/index.html\",\n  .cache = COCKPIT_WEB_RESPONSE_CACHE_PRIVATE\n};\n\nstatic const TestFixture cache_unset_fixture = {\n  .path = \"/pkg/shell/index.html\",\n  .cache = COCKPIT_WEB_RESPONSE_CACHE_UNSET\n};\n\nstatic void\ntest_cache (TestCase *tc,\n            gconstpointer user_data)\n{\n  const TestFixture *fixture = user_data;\n  const gchar *roots[] = { srcdir, NULL };\n  GHashTable *headers;\n  const gchar *resp;\n  gsize length;\n  guint status;\n  gssize off;\n\n  cockpit_web_response_set_cache_type (tc->response, fixture->cache);\n  cockpit_web_response_file (tc->response, NULL, roots);\n\n  resp = output_as_string (tc);\n  length = strlen (resp);\n\n  off = web_socket_util_parse_status_line (resp, length, NULL, &status, NULL);\n  g_assert_cmpuint (off, >, 0);\n  g_assert_cmpint (status, ==, 200);\n\n  off = web_socket_util_parse_headers (resp + off, length - off, &headers);\n  g_assert_cmpuint (off, >, 0);\n\n  if (fixture->cache == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE)\n    g_assert_cmpstr (g_hash_table_lookup (headers, \"Vary\"), ==, \"Cookie\");\n  else\n    g_assert_null (g_hash_table_lookup (headers, \"Vary\"));\n\n  if (fixture->cache == COCKPIT_WEB_RESPONSE_CACHE_FOREVER)\n    g_assert_cmpstr (g_hash_table_lookup (headers, \"Cache-Control\"), ==, \"max-age=31556926, public\");\n  else if (fixture->cache == COCKPIT_WEB_RESPONSE_NO_CACHE)\n    g_assert_cmpstr (g_hash_table_lookup (headers, \"Cache-Control\"), ==, \"no-cache, no-store\");\n  else if (fixture->cache == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE)\n    g_assert_cmpstr (g_hash_table_lookup (headers, \"Cache-Control\"), ==, \"max-age=86400, private\");\n  else\n    g_assert_null (g_hash_table_lookup (headers, \"Cache-Control\"));\n  g_hash_table_unref (headers);\n}\n\nstatic void\ntest_content_encoding (TestCase *tc,\n                       gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_READY);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", 50,\n                                \"Content-Encoding\", \"blah\",\n                                NULL);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  content = g_bytes_new_static (\"Cockpit is perfect for new sysadmins, \", 38);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  cockpit_web_response_complete (tc->response);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_COMPLETE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Encoding: blah\\r\\n\"\n                   \"Transfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"26\\r\\nCockpit is perfect for new sysadmins, \\r\\n0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_stream (TestCase *tc,\n             gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_READY);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", 11, NULL);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  content = g_bytes_new_static (\"the content\", 11);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  cockpit_web_response_complete (tc->response);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_COMPLETE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Length: 11\\r\\n\" STATIC_HEADERS \"the content\");\n}\n\nstatic void\non_pressure_set_throttle (CockpitWebResponse *response,\n                          gboolean throttle,\n                          gpointer user_data)\n{\n  gint *data = user_data;\n  g_assert (user_data != NULL);\n  *data = throttle ? 1 : 0;\n}\n\nstatic void\ntest_pressure (TestCase *tc,\n               gconstpointer data)\n{\n  GBytes *sent;\n  gint throttle = -1;\n  gint i;\n\n  g_signal_connect (tc->response, \"pressure\", G_CALLBACK (on_pressure_set_throttle), &throttle);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_READY);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", -1, NULL);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  /* Sent this a thousand times */\n  sent = g_bytes_new_take (g_strnfill (10 * 1000, '?'), 10 * 1000);\n  for (i = 0; i < 1000; i++)\n    cockpit_web_response_queue (tc->response, sent);\n  g_bytes_unref (sent);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  /*\n   * This should have put way too much in the queue, and thus\n   * emitted the back-pressure signal. This signal would normally\n   * be used by others to slow down their queueing, but in this\n   * case we just check that it was fired.\n   */\n  g_assert_cmpint (throttle, ==, 1);\n  throttle = -1;\n\n  cockpit_web_response_complete (tc->response);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_COMPLETE);\n\n  /*\n   * Now the queue is getting drained. At some point, it will be\n   * signaled that back pressure has been turned off\n   */\n  while (throttle == -1)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_assert_cmpint (throttle, ==, 0);\n\n  while (!tc->response_done)\n    g_main_context_iteration (NULL, TRUE);\n  g_assert_cmpint (g_memory_output_stream_get_data_size (G_MEMORY_OUTPUT_STREAM (tc->output)), >, 10 * 1000 * 1000);\n}\n\nstatic void\ntest_head (TestCase *tc,\n           gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  cockpit_web_response_set_method (tc->response, \"HEAD\");\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_READY);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", 19, NULL);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  content = g_bytes_new_static (\"I shall not be seen\", 19);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  cockpit_web_response_complete (tc->response);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_COMPLETE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Length: 19\\r\\n\" STATIC_HEADERS);\n}\n\nstatic void\ntest_chunked_transfer_encoding (TestCase *tc,\n                                gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_READY);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", -1, NULL);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  content = g_bytes_new_static (\"Cockpit is perfect for new sysadmins, \", 38);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  content = g_bytes_new_static (\"allowing them to easily perform simple tasks such as storage administration, \", 77);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  content = g_bytes_new_static (\"inspecting journals and starting and stopping services.\", 55);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  cockpit_web_response_complete (tc->response);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_COMPLETE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"26\\r\\nCockpit is perfect for new sysadmins, \\r\\n\"\n                   \"4d\\r\\nallowing them to easily perform simple tasks such as storage administration, \\r\\n\"\n                   \"37\\r\\ninspecting journals and starting and stopping services.\\r\\n0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_chunked_zero_length (TestCase *tc,\n                          gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_READY);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", -1, NULL);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  content = g_bytes_new_static (\"Cockpit is perfect for new sysadmins, \", 38);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  content = g_bytes_new_static (\"\", 0);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  content = g_bytes_new_static (\"inspecting journals and starting and stopping services.\", 55);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  content = g_bytes_new_static (\"\", 0);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_QUEUING);\n  cockpit_web_response_complete (tc->response);\n\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_COMPLETE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"26\\r\\nCockpit is perfect for new sysadmins, \\r\\n\"\n                   \"37\\r\\ninspecting journals and starting and stopping services.\\r\\n0\\r\\n\\r\\n\");\n}\n\nstatic GBytes *\nbytes_static (const gchar *data)\n{\n  return g_bytes_new_static (data, strlen (data));\n}\n\nstatic void\ntest_web_filter_simple (TestCase *tc,\n                        gconstpointer data)\n{\n  CockpitWebFilter *filter;\n  const gchar *resp;\n  GBytes *content;\n  GBytes *inject;\n\n  inject = bytes_static (\"<meta inject>\");\n  filter = cockpit_web_inject_new (\"<head>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  content = bytes_static (\"<html><head><title>The Title</title></head></html>\");\n  cockpit_web_response_content (tc->response, NULL, content, NULL);\n  g_bytes_unref (content);\n\n  while (cockpit_web_response_get_state (tc->response) != COCKPIT_WEB_RESPONSE_COMPLETE)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"c\\r\\n<html><head>\\r\\n\"\n                   \"d\\r\\n<meta inject>\\r\\n\"\n                   \"26\\r\\n<title>The Title</title></head></html>\\r\\n\"\n                   \"0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_web_filter_multiple (TestCase *tc,\n                          gconstpointer data)\n{\n  CockpitWebFilter *filter;\n  const gchar *resp;\n  GBytes *content;\n  GBytes *inject;\n\n  inject = bytes_static (\"<meta inject>\");\n  filter = cockpit_web_inject_new (\"<head>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  inject = bytes_static (\"<body>Body</body>\");\n  filter = cockpit_web_inject_new (\"</head>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  inject = bytes_static (\"Prefix \");\n  filter = cockpit_web_inject_new (\"<title>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  inject = bytes_static (\" \");\n  filter = cockpit_web_inject_new (\">\", inject, 3);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  content = bytes_static (\"<html><head><title>The Title</title></head></html>\");\n  cockpit_web_response_content (tc->response, NULL, content, NULL);\n  g_bytes_unref (content);\n\n  while (cockpit_web_response_get_state (tc->response) != COCKPIT_WEB_RESPONSE_COMPLETE)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"6\\r\\n<html>\\r\\n\"\n                   \"1\\r\\n \\r\\n\"\n                   \"6\\r\\n<head>\\r\\n\"\n                   \"1\\r\\n \\r\\n\"\n                   \"d\\r\\n<meta inject>\\r\\n\"\n                   \"1\\r\\n \\r\\n\"\n                   \"7\\r\\n<title>\\r\\n\"\n                   \"7\\r\\nPrefix \\r\\n\"\n                   \"18\\r\\nThe Title</title></head>\\r\\n\"\n                   \"11\\r\\n<body>Body</body>\\r\\n\"\n                   \"7\\r\\n</html>\\r\\n\"\n                   \"0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_web_filter_split (TestCase *tc,\n                       gconstpointer data)\n{\n  CockpitWebFilter *filter;\n  const gchar *string;\n  const gchar *resp;\n  GBytes *inject;\n  GBytes *block;\n  gsize i, x, len;\n\n  inject = bytes_static (\"<meta inject>\");\n  filter = cockpit_web_inject_new (\"<head>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  inject = bytes_static (\"<body>Body</body>\");\n  filter = cockpit_web_inject_new (\"</head>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  inject = bytes_static (\"Prefix \");\n  filter = cockpit_web_inject_new (\"<title>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", -1, NULL);\n\n  string = \"<html><head><title>The Title</title></head></html>\";\n  len = strlen (string);\n\n  for (i = 0, x = 1; i < len; i += x, x = 1 + (i % 4))\n    {\n      block = g_bytes_new_static (string + i, MIN (x, strlen (string + i)));\n      g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n      g_bytes_unref (block);\n    }\n\n  cockpit_web_response_complete (tc->response);\n\n  while (cockpit_web_response_get_state (tc->response) != COCKPIT_WEB_RESPONSE_COMPLETE)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"1\\r\\n<\\r\\n\"\n                   \"2\\r\\nht\\r\\n\"\n                   \"4\\r\\nml><\\r\\n\"\n                   \"4\\r\\nhead\\r\\n\"\n                   \"1\\r\\n>\\r\\n\"\n                   \"d\\r\\n<meta inject>\\r\\n\"\n                   \"3\\r\\n<ti\\r\\n\"\n                   \"4\\r\\ntle>\\r\\n\"\n                   \"7\\r\\nPrefix \\r\\n\"\n                   \"4\\r\\nThe \\r\\n\"\n                   \"4\\r\\nTitl\\r\\n\"\n                   \"4\\r\\ne</t\\r\\n\"\n                   \"4\\r\\nitle\\r\\n\"\n                   \"4\\r\\n></h\\r\\n\"\n                   \"4\\r\\nead>\\r\\n\"\n                   \"11\\r\\n<body>Body</body>\\r\\n\"\n                   \"4\\r\\n</ht\\r\\n\"\n                   \"3\\r\\nml>\\r\\n\"\n                   \"0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_web_filter_shift (TestCase *tc,\n                       gconstpointer data)\n{\n  CockpitWebFilter *filter;\n  const gchar *resp;\n  GBytes *block;\n  GBytes *inject;\n\n  inject = bytes_static (\"injected\");\n  filter = cockpit_web_inject_new (\"foofn\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  cockpit_web_response_headers_full (tc->response, 200, \"OK\", -1, NULL);\n\n  /* Total content is foofoofn and split after the first 4 characters */\n  block = bytes_static (\"foof\");\n  g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n  g_bytes_unref (block);\n  block = bytes_static (\"oofn\");\n  g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n  g_bytes_unref (block);\n  cockpit_web_response_complete (tc->response);\n\n  while (cockpit_web_response_get_state (tc->response) != COCKPIT_WEB_RESPONSE_COMPLETE)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"4\\r\\nfoof\\r\\n\"\n                   \"4\\r\\noofn\\r\\n\"\n                   \"8\\r\\ninjected\\r\\n\"\n                   \"0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_web_filter_shift_three (TestCase *tc,\n                             gconstpointer data)\n{\n  CockpitWebFilter *filter;\n  const gchar *resp;\n  GBytes *block;\n  GBytes *inject;\n\n  inject = bytes_static (\"injected\");\n  filter = cockpit_web_inject_new (\"foofn\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  cockpit_web_response_headers_full (tc->response, 200, \"OK\", -1, NULL);\n\n  /* Total content is foofoofn and split across multiple packets after the first 4 characters */\n  block = bytes_static (\"foof\");\n  g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n  g_bytes_unref (block);\n  block = bytes_static (\"o\");\n  g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n  g_bytes_unref (block);\n  block = bytes_static (\"of\");\n  g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n  g_bytes_unref (block);\n  block = bytes_static (\"n\");\n  g_assert (cockpit_web_response_queue (tc->response, block) == TRUE);\n  g_bytes_unref (block);\n  cockpit_web_response_complete (tc->response);\n\n  while (cockpit_web_response_get_state (tc->response) != COCKPIT_WEB_RESPONSE_COMPLETE)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"4\\r\\nfoof\\r\\n\"\n                   \"1\\r\\no\\r\\n\"\n                   \"2\\r\\nof\\r\\n\"\n                   \"1\\r\\nn\\r\\n\"\n                   \"8\\r\\ninjected\\r\\n\"\n                   \"0\\r\\n\\r\\n\");\n}\n\nstatic void\ntest_web_filter_passthrough (TestCase *tc,\n                             gconstpointer data)\n{\n  CockpitWebFilter *filter;\n  const gchar *resp;\n  GBytes *content;\n  GBytes *inject;\n\n  inject = bytes_static (\"<meta inject>\");\n  filter = cockpit_web_inject_new (\"<unknown>\", inject, 1);\n  cockpit_web_response_add_filter (tc->response, filter);\n  g_object_unref (filter);\n  g_bytes_unref (inject);\n\n  content = bytes_static (\"<html><head><title>The Title</title></head></html>\");\n  cockpit_web_response_content (tc->response, NULL, content, NULL);\n  g_bytes_unref (content);\n\n  while (cockpit_web_response_get_state (tc->response) != COCKPIT_WEB_RESPONSE_COMPLETE)\n    g_main_context_iteration (NULL, TRUE);\n\n  resp = output_as_string (tc);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS\n                   \"32\\r\\n<html><head><title>The Title</title></head></html>\\r\\n\"\n                   \"0\\r\\n\\r\\n\");\n}\n\nstatic void\non_response_done_not_resuable (CockpitWebResponse *response,\n                               gboolean reusable,\n                               gpointer user_data)\n{\n  g_assert (reusable == FALSE);\n}\n\nstatic void\ntest_abort (TestCase *tc,\n            gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  cockpit_web_response_headers (tc->response, 200, \"OK\", 11, NULL);\n  g_signal_connect (tc->response, \"done\", G_CALLBACK (on_response_done_not_resuable), NULL);\n\n  while (g_main_context_iteration (NULL, FALSE));\n\n  content = g_bytes_new_static (\"the content\", 11);\n  cockpit_web_response_queue (tc->response, content);\n  g_bytes_unref (content);\n\n  cockpit_web_response_abort (tc->response);\n  g_assert_cmpint (cockpit_web_response_get_state (tc->response), ==, COCKPIT_WEB_RESPONSE_SENT);\n\n  resp = output_as_string (tc);\n\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Length: 11\\r\\n\" STATIC_HEADERS);\n}\n\nstatic const TestFixture fixture_connection_close = {\n  .header = \"Connection\",\n  .value = \"close\",\n};\n\nstatic void\ntest_connection_close (TestCase *tc,\n                       gconstpointer data)\n{\n  const gchar *resp;\n  GBytes *content;\n\n  g_assert (data == &fixture_connection_close);\n\n  g_signal_connect (tc->response, \"done\", G_CALLBACK (on_response_done_not_resuable), NULL);\n\n  content = g_bytes_new_static (\"the content\", 11);\n  cockpit_web_response_content (tc->response, NULL, content, NULL);\n  g_bytes_unref (content);\n\n  resp = output_as_string (tc);\n  g_assert_cmpstr (resp, ==, \"HTTP/1.1 200 OK\\r\\nContent-Length: 11\\r\\nConnection: close\\r\\n\"\n                   STATIC_HEADERS \"the content\");\n}\n\nstatic const TestFixture fixture_origin_default = {\n  .header = \"Host\",\n  .value = \"somemachine\",\n  .for_tls_proxy = FALSE,\n};\n\nstatic const TestFixture fixture_origin_tls_proxy = {\n  .header = \"Host\",\n  .value = \"somemachine\",\n  .for_tls_proxy = TRUE,\n};\n\nstatic void\ntest_origin (TestCase *tc,\n             gconstpointer data)\n{\n  const TestFixture *fixture = data;\n  GBytes *content;\n\n  if (fixture->for_tls_proxy)\n    g_assert_cmpstr (cockpit_web_response_get_origin (tc->response), ==, \"https://somemachine\");\n  else\n    g_assert_cmpstr (cockpit_web_response_get_origin (tc->response), ==, \"http://somemachine\");\n\n  content = g_bytes_new_static (\"the content\", 11);\n  cockpit_web_response_content (tc->response, NULL, content, NULL);\n  g_bytes_unref (content);\n  output_as_string (tc);\n}\n\ntypedef struct {\n    GHashTable *headers;\n    GIOStream *io;\n} TestPlain;\n\nstatic void\nsetup_plain (TestPlain *tc,\n             gconstpointer unused)\n{\n  GInputStream *input;\n  GOutputStream *output;\n\n  input = g_memory_input_stream_new ();\n  output = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);\n\n  tc->io = mock_io_stream_new (input, output);\n\n  g_object_unref (input);\n  g_object_unref (output);\n\n  tc->headers = cockpit_web_server_new_table ();\n}\n\nstatic void\nteardown_plain (TestPlain *tc,\n                gconstpointer unused)\n{\n  g_object_unref (tc->io);\n  g_hash_table_unref (tc->headers);\n}\n\nstatic void\ntest_pop_path (TestPlain *tc,\n               gconstpointer unused)\n{\n  CockpitWebResponse *response;\n  gchar *part;\n  const gchar *start = \"/cockpit/@localhost/another/test.html\";\n\n  response = cockpit_web_response_new (tc->io, start, start, NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, start);\n  g_assert_cmpstr (cockpit_web_response_get_url_root (response), ==, NULL);\n\n  part = cockpit_web_response_pop_path (response);\n  g_assert_cmpstr (part, ==, \"cockpit\");\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/@localhost/another/test.html\");\n  g_free (part);\n\n  part = cockpit_web_response_pop_path (response);\n  g_assert_cmpstr (part, ==, \"@localhost\");\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/another/test.html\");\n  g_free (part);\n\n  part = cockpit_web_response_pop_path (response);\n  g_assert_cmpstr (part, ==, \"another\");\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/test.html\");\n  g_free (part);\n\n  part = cockpit_web_response_pop_path (response);\n  g_assert_cmpstr (part, ==, \"test.html\");\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, NULL);\n  g_free (part);\n\n  part = cockpit_web_response_pop_path (response);\n  g_assert (part == NULL);\n  g_assert (cockpit_web_response_get_path (response) == NULL);\n  g_free (part);\n\n  cockpit_web_response_abort (response);\n  g_object_unref (response);\n}\n\nstatic void\ntest_pop_path_root (TestPlain *tc,\n                    gconstpointer unused)\n{\n  CockpitWebResponse *response;\n  gchar *part;\n\n  response = cockpit_web_response_new (tc->io, \"/\", \"/\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/\");\n\n  part = cockpit_web_response_pop_path (response);\n  g_assert_cmpstr (part, ==, NULL);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, NULL);\n  g_free (part);\n\n  cockpit_web_response_abort (response);\n  g_object_unref (response);\n}\n\nstatic void\ntest_skip_path (TestPlain *tc,\n                gconstpointer unused)\n{\n  CockpitWebResponse *response;\n  const gchar *start = \"/cockpit/@localhost/another/test.html\";\n\n  response = cockpit_web_response_new (tc->io, start, start, NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/cockpit/@localhost/another/test.html\");\n\n  g_assert (cockpit_web_response_skip_path (response) == TRUE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/@localhost/another/test.html\");\n\n  g_assert (cockpit_web_response_skip_path (response) == TRUE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/another/test.html\");\n\n  g_assert (cockpit_web_response_skip_path (response) == TRUE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/test.html\");\n\n  g_assert (cockpit_web_response_skip_path (response) == TRUE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, NULL);\n\n  g_assert (cockpit_web_response_skip_path (response) == FALSE);\n  g_assert (cockpit_web_response_get_path (response) == NULL);\n\n  cockpit_web_response_abort (response);\n  g_object_unref (response);\n}\n\nstatic void\ntest_skip_path_root (TestPlain *tc,\n                     gconstpointer unused)\n{\n  CockpitWebResponse *response;\n\n  response = cockpit_web_response_new (tc->io, \"/\", \"/\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/\");\n\n  g_assert (cockpit_web_response_skip_path (response) == FALSE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, NULL);\n\n  cockpit_web_response_abort (response);\n  g_object_unref (response);\n}\n\nstatic void\ntest_removed_prefix (TestPlain *tc,\n                     gconstpointer unused)\n{\n  CockpitWebResponse *response;\n\n  response = cockpit_web_response_new (tc->io, \"/\", \"/\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/\");\n  g_assert_cmpstr (cockpit_web_response_get_url_root (response), ==, NULL);\n  cockpit_web_response_abort (response);\n  g_clear_object (&response);\n\n  response = cockpit_web_response_new (tc->io, \"/path/\", \"/path/\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/path/\");\n  g_assert_cmpstr (cockpit_web_response_get_url_root (response), ==, NULL);\n  cockpit_web_response_abort (response);\n  g_clear_object (&response);\n\n  response = cockpit_web_response_new (tc->io, \"/path/path2/\", \"/path2/\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/path2/\");\n  g_assert_cmpstr (cockpit_web_response_get_url_root (response), ==, \"/path\");\n  cockpit_web_response_abort (response);\n  g_clear_object (&response);\n\n  response = cockpit_web_response_new (tc->io, \"/mis/\", \"/match/\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, \"/match/\");\n  g_assert_cmpstr (cockpit_web_response_get_url_root (response), ==, NULL);\n  cockpit_web_response_abort (response);\n  g_clear_object (&response);\n\n  response = cockpit_web_response_new (tc->io, NULL, NULL, NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  g_assert_cmpstr (cockpit_web_response_get_path (response), ==, NULL);\n  g_assert_cmpstr (cockpit_web_response_get_url_root (response), ==, NULL);\n  cockpit_web_response_abort (response);\n  g_clear_object (&response);\n}\n\nstatic void\ntest_gunzip_small (void)\n{\n  GError *error = NULL;\n  GMappedFile *file;\n  GBytes *compressed;\n  GBytes *bytes;\n\n  file = g_mapped_file_new (SRCDIR \"/src/common/mock-content/test-file.txt.gz\", FALSE, &error);\n  g_assert_no_error (error);\n\n  compressed = g_mapped_file_get_bytes (file);\n  g_mapped_file_unref (file);\n\n  bytes = cockpit_web_response_gunzip (compressed, &error);\n  g_assert_no_error (error);\n  g_bytes_unref (compressed);\n\n  cockpit_assert_bytes_eq (bytes, \"A small test file\\n\", -1);\n  g_bytes_unref (bytes);\n}\n\nstatic void\ntest_gunzip_large (void)\n{\n  GError *error = NULL;\n  GMappedFile *file;\n  GBytes *compressed;\n  GBytes *bytes;\n  gchar *checksum;\n\n  file = g_mapped_file_new (SRCDIR \"/src/common/mock-content/large.min.js.gz\", FALSE, &error);\n  g_assert_no_error (error);\n\n  compressed = g_mapped_file_get_bytes (file);\n  g_mapped_file_unref (file);\n\n  bytes = cockpit_web_response_gunzip (compressed, &error);\n  g_assert_no_error (error);\n  g_bytes_unref (compressed);\n\n  checksum = g_compute_checksum_for_bytes (G_CHECKSUM_MD5, bytes);\n  g_assert_cmpstr (checksum, ==, \"5ca7582261c421482436dfdf3af9bffe\");\n  g_free (checksum);\n\n  g_bytes_unref (bytes);\n}\n\nstatic void\ntest_gunzip_invalid (void)\n{\n  GError *error = NULL;\n  GBytes *compressed;\n  GBytes *bytes;\n\n  compressed = g_bytes_new_static (\"invalid\", 7);\n\n  bytes = cockpit_web_response_gunzip (compressed, &error);\n  g_assert (bytes == NULL);\n  g_assert_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n  g_error_free (error);\n\n  g_bytes_unref (compressed);\n}\n\nstatic void\ntest_negotiation_first (void)\n{\n  gchar *chosen = NULL;\n  GError *error = NULL;\n  GBytes *bytes;\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/test-file.txt\",\n                                            NULL, NULL, &chosen, &error);\n\n  cockpit_assert_bytes_eq (bytes, \"A small test file\\n\", -1);\n  g_assert_no_error (error);\n  g_bytes_unref (bytes);\n\n  g_assert_cmpstr (chosen, ==, SRCDIR \"/src/common/mock-content/test-file.txt\");\n  g_free (chosen);\n}\n\nstatic void\ntest_negotiation_last (void)\n{\n  gchar *chosen = NULL;\n  GError *error = NULL;\n  gchar *checksum;\n  GBytes *bytes;\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/large.js\",\n                                            NULL, NULL, &chosen, &error);\n\n  g_assert_no_error (error);\n  g_assert_cmpstr (chosen, ==, SRCDIR \"/src/common/mock-content/large.min.js.gz\");\n  g_free (chosen);\n\n  checksum = g_compute_checksum_for_bytes (G_CHECKSUM_MD5, bytes);\n  g_assert_cmpstr (checksum, ==, \"e5284b625b7665fc04e082827de3436c\");\n  g_free (checksum);\n\n  g_bytes_unref (bytes);\n}\n\nstatic void\ntest_negotiation_prune (void)\n{\n  gchar *chosen = NULL;\n  GError *error = NULL;\n  GBytes *bytes;\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/test-file.extra.extension.txt\",\n                                            NULL, NULL, &chosen, &error);\n\n  cockpit_assert_bytes_eq (bytes, \"A small test file\\n\", -1);\n  g_assert_no_error (error);\n  g_bytes_unref (bytes);\n\n  g_assert_cmpstr (chosen, ==, SRCDIR \"/src/common/mock-content/test-file.txt\");\n  g_free (chosen);\n}\n\nstatic void\ntest_negotiation_with_listing (void)\n{\n  GHashTable *existing;\n  GError *error = NULL;\n  GBytes *bytes;\n\n  /* Lie and say that only the .gz file exists */\n  existing = g_hash_table_new (g_str_hash, g_str_equal);\n  g_hash_table_add (existing, SRCDIR \"/src/common/mock-content/test-file.txt.gz\");\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/test-file.txt\",\n                                            existing, NULL, NULL, &error);\n\n  cockpit_assert_bytes_eq (bytes, \"\\x1F\\x8B\\x08\\x08N1\\x03U\\x00\\x03test-file.txt\\x00\"\n                           \"sT(\\xCEM\\xCC\\xC9Q(I-.QH\\xCB\\xCCI\\xE5\\x02\\x00>PjG\\x12\\x00\\x00\\x00\", 52);\n  g_assert_no_error (error);\n  g_bytes_unref (bytes);\n\n  g_hash_table_unref (existing);\n}\n\nstatic void\ntest_negotiation_locale (void)\n{\n  gchar *chosen = NULL;\n  GError *error = NULL;\n  GBytes *bytes;\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/test-file.txt\",\n                                            NULL, \"zh-cn\", &chosen, &error);\n\n  cockpit_assert_bytes_eq (bytes, \"A translated test file\\n\", -1);\n  g_assert_no_error (error);\n  g_bytes_unref (bytes);\n\n  g_assert_cmpstr (chosen, ==, SRCDIR \"/src/common/mock-content/test-file.zh_CN.txt\");\n  g_free (chosen);\n}\n\nstatic void\ntest_negotiation_notfound (void)\n{\n  gchar *chosen = NULL;\n  GError *error = NULL;\n  GBytes *bytes;\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/non-existent\",\n                                            NULL, NULL, &chosen, &error);\n\n  g_assert_no_error (error);\n  g_assert (bytes == NULL);\n\n  g_assert (chosen == NULL);\n}\n\nstatic void\ntest_negotiation_failure (void)\n{\n  gchar *chosen = NULL;\n  GError *error = NULL;\n  GBytes *bytes;\n\n  bytes = cockpit_web_response_negotiation (SRCDIR \"/src/common/mock-content/directory\",\n                                            NULL, NULL, &chosen, &error);\n\n  g_assert (error != NULL);\n  g_error_free (error);\n\n  g_assert (bytes == NULL);\n\n  g_assert (chosen == NULL);\n}\n\nint\nmain (int argc,\n      char *argv[])\n{\n  gint ret;\n\n  srcdir = realpath (SRCDIR, NULL);\n  g_assert (srcdir != NULL);\n\n  cockpit_test_init (&argc, &argv);\n\n  g_test_add (\"/web-response/return-content\", TestCase, NULL,\n              setup, test_return_content, teardown);\n  g_test_add (\"/web-response/return-content-headers\", TestCase, NULL,\n              setup, test_return_content_headers, teardown);\n  g_test_add (\"/web-response/return-error\", TestCase, NULL,\n              setup, test_return_error, teardown);\n  g_test_add (\"/web-response/return-error-headers\", TestCase, NULL,\n              setup, test_return_error_headers, teardown);\n  g_test_add (\"/web-response/return-gerror-headers\", TestCase, NULL,\n              setup, test_return_gerror_headers, teardown);\n  g_test_add (\"/web-response/return-error-resource\", TestCase, NULL,\n              setup, test_return_error_resource, teardown);\n  g_test_add (\"/web-response/file/not-found\", TestCase, NULL,\n              setup, test_file_not_found, teardown);\n  g_test_add (\"/web-response/file/directory-denied\", TestCase, NULL,\n              setup, test_file_directory_denied, teardown);\n  g_test_add (\"/web-response/file/access-denied\", TestCase, NULL,\n              setup, test_file_access_denied, teardown);\n  g_test_add (\"/web-response/file/breakout-denied\", TestCase, NULL,\n              setup, test_file_breakout_denied, teardown);\n  g_test_add (\"/web-response/file/invalid-encoding-denied\", TestCase, NULL,\n              setup, test_file_encoding_denied, teardown);\n  g_test_add (\"/web-response/file/file-slash-denied\", TestCase, NULL,\n              setup, test_file_slash_denied, teardown);\n  g_test_add (\"/web-response/file/breakout-non-existant\", TestCase, NULL,\n              setup, test_file_breakout_non_existant, teardown);\n  g_test_add (\"/web-reponse/file/template\", TestCase, &template_fixture,\n              setup, test_template, teardown);\n  g_test_add (\"/web-response/content-type/html\", TestCase, &content_type_fixture_html,\n              setup, test_content_type, teardown);\n  g_test_add (\"/web-response/content-type/png\", TestCase, &content_type_fixture_png,\n              setup, test_content_type, teardown);\n  g_test_add (\"/web-response/content-type/wasm\", TestCase, &content_type_fixture_wasm,\n              setup, test_content_type, teardown);\n  g_test_add (\"/web-response/content-encoding\", TestCase, NULL,\n              setup, test_content_encoding, teardown);\n  g_test_add (\"/web-response/stream\", TestCase, NULL,\n              setup, test_stream, teardown);\n  g_test_add (\"/web-response/pressure\", TestCase, NULL,\n              setup, test_pressure, teardown);\n  g_test_add (\"/web-response/head\", TestCase, NULL,\n              setup, test_head, teardown);\n  g_test_add (\"/web-response/chunked-transfer-encoding\", TestCase, NULL,\n              setup, test_chunked_transfer_encoding, teardown);\n  g_test_add (\"/web-response/chunked-zero-length\", TestCase, NULL,\n              setup, test_chunked_zero_length, teardown);\n  g_test_add (\"/web-response/abort\", TestCase, NULL,\n              setup, test_abort, teardown);\n  g_test_add (\"/web-response/connection-close\", TestCase, &fixture_connection_close,\n              setup, test_connection_close, teardown);\n  g_test_add (\"/web-response/origin-default\", TestCase, &fixture_origin_default,\n              setup, test_origin, teardown);\n  g_test_add (\"/web-response/origin-tls-proxy\", TestCase, &fixture_origin_tls_proxy,\n              setup, test_origin, teardown);\n\n  g_test_add (\"/web-response/cache-forever\", TestCase, &cache_forever_fixture,\n              setup, test_cache, teardown);\n  g_test_add (\"/web-response/cache-private\", TestCase, &cache_private_fixture,\n              setup, test_cache, teardown);\n  g_test_add (\"/web-response/cache-none\", TestCase, &cache_none_fixture,\n              setup, test_cache, teardown);\n  g_test_add (\"/web-response/cache-unset\", TestCase, &cache_unset_fixture,\n              setup, test_cache, teardown);\n\n  g_test_add (\"/web-response/filter/simple\", TestCase, NULL,\n              setup, test_web_filter_simple, teardown);\n  g_test_add (\"/web-response/filter/multiple\", TestCase, NULL,\n              setup, test_web_filter_multiple, teardown);\n  g_test_add (\"/web-response/filter/passthrough\", TestCase, NULL,\n              setup, test_web_filter_passthrough, teardown);\n  g_test_add (\"/web-response/filter/split\", TestCase, NULL,\n              setup, test_web_filter_split, teardown);\n  g_test_add (\"/web-response/filter/shift\", TestCase, NULL,\n              setup, test_web_filter_shift, teardown);\n  g_test_add (\"/web-response/filter/shift_three\", TestCase, NULL,\n              setup, test_web_filter_shift_three, teardown);\n\n  g_test_add (\"/web-response/path/pop\", TestPlain, NULL,\n              setup_plain, test_pop_path, teardown_plain);\n  g_test_add (\"/web-response/path/pop-root\", TestPlain, NULL,\n              setup_plain, test_pop_path_root, teardown_plain);\n  g_test_add (\"/web-response/path/skip\", TestPlain, NULL,\n              setup_plain, test_skip_path, teardown_plain);\n  g_test_add (\"/web-response/path/skip-root\", TestPlain, NULL,\n              setup_plain, test_skip_path_root, teardown_plain);\n  g_test_add (\"/web-response/path/removed-prefix\", TestPlain, NULL,\n              setup_plain, test_removed_prefix, teardown_plain);\n\n  g_test_add_func (\"/web-response/gunzip/small\", test_gunzip_small);\n  g_test_add_func (\"/web-response/gunzip/large\", test_gunzip_large);\n  g_test_add_func (\"/web-response/gunzip/invalid\", test_gunzip_invalid);\n\n  g_test_add_func (\"/web-response/negotiation/first\", test_negotiation_first);\n  g_test_add_func (\"/web-response/negotiation/last\", test_negotiation_last);\n  g_test_add_func (\"/web-response/negotiation/locale\", test_negotiation_locale);\n  g_test_add_func (\"/web-response/negotiation/prune\", test_negotiation_prune);\n  g_test_add_func (\"/web-response/negotiation/with-listing\", test_negotiation_with_listing);\n  g_test_add_func (\"/web-response/negotiation/notfound\", test_negotiation_notfound);\n  g_test_add_func (\"/web-response/negotiation/failure\", test_negotiation_failure);\n\n  ret = g_test_run ();\n\n  free (srcdir);\n\n  return ret;\n}\n", "/*\n * This file is part of Cockpit.\n *\n * Copyright (C) 2015 Red Hat, Inc.\n *\n * Cockpit is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * Cockpit is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"config.h\"\n\n#include \"mock-auth.h\"\n#include \"cockpitws.h\"\n#include \"cockpitcreds.h\"\n#include \"cockpitchannelresponse.h\"\n\n#include \"common/cockpitpipetransport.h\"\n#include \"common/cockpittransport.h\"\n#include \"common/cockpitjson.h\"\n#include \"common/cockpittest.h\"\n#include \"common/mock-io-stream.h\"\n#include \"common/cockpitwebserver.h\"\n#include \"common/cockpitconf.h\"\n\n#include \"websocket/websocket.h\"\n\n#include <glib.h>\n\n#include <string.h>\n#include <errno.h>\n#include <stdio.h>\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n\n/*\n * To recalculate the checksums found in this file, do something like:\n * $ XDG_DATA_DIRS=$PWD/src/bridge/mock-resource/system/ XDG_DATA_HOME=/nonexistent ./cockpit-bridge --packages\n */\n#define CHECKSUM \"$025e419da72456a49bc60c042b2e983a4a7a44e78eac1fffd062e046e8d4cf3b\"\n\n#define PASSWORD \"this is the password\"\n\n/* headers that are present in every request */\n#define STATIC_HEADERS \"X-Content-Type-Options: nosniff\\r\\nX-DNS-Prefetch-Control: off\\r\\nReferrer-Policy: no-referrer\\r\\nCross-Origin-Resource-Policy: same-origin\\r\\nX-Frame-Options: sameorigin\\r\\n\"\n\ntypedef struct {\n  CockpitWebService *service;\n  GIOStream *io;\n  GMemoryOutputStream *output;\n  CockpitPipe *pipe;\n  GHashTable *headers;\n} TestResourceCase;\n\ntypedef struct {\n  const gchar *xdg_data_home;\n  gboolean org_path;\n} TestResourceFixture;\n\nstatic gboolean\non_transport_control (CockpitTransport *transport,\n                      const char *command,\n                      const gchar *channel,\n                      JsonObject *options,\n                      GBytes *payload,\n                      gpointer data)\n{\n  gboolean *flag = data;\n  g_assert (flag != NULL);\n\n  if (g_str_equal (command, \"init\"))\n    *flag = TRUE;\n\n  return FALSE;\n}\n\nstatic void\nsetup_resource (TestResourceCase *tc,\n                gconstpointer data)\n{\n  const TestResourceFixture *fixture = data;\n  CockpitTransport *transport;\n  GInputStream *input;\n  GOutputStream *output;\n  CockpitCreds *creds;\n  gchar **environ;\n  const gchar *user;\n  const gchar *home = NULL;\n  gboolean ready = FALSE;\n  GBytes *password;\n  gulong handler;\n\n  const gchar *argv[] = {\n    BUILDDIR \"/cockpit-bridge\",\n    NULL\n  };\n\n  environ = g_get_environ ();\n  environ = g_environ_setenv (environ, \"XDG_DATA_DIRS\", SRCDIR \"/src/bridge/mock-resource/system\", TRUE);\n\n  if (fixture)\n    home = fixture->xdg_data_home;\n  if (!home)\n    home = SRCDIR \"/src/bridge/mock-resource/home\";\n  environ = g_environ_setenv (environ, \"XDG_DATA_HOME\", home, TRUE);\n\n  /* Start up a cockpit-bridge here */\n  tc->pipe = cockpit_pipe_spawn (argv, (const gchar **)environ, NULL, COCKPIT_PIPE_FLAGS_NONE);\n\n  g_strfreev (environ);\n\n  user = g_get_user_name ();\n  password = g_bytes_new_take (g_strdup (PASSWORD), strlen (PASSWORD));\n  creds = cockpit_creds_new (\"cockpit\", COCKPIT_CRED_USER, user, COCKPIT_CRED_PASSWORD, password, NULL);\n  g_bytes_unref (password);\n\n  transport = cockpit_pipe_transport_new (tc->pipe);\n  tc->service = cockpit_web_service_new (creds, transport);\n\n  /* Manually created services won't be init'd yet, wait for that before sending data */\n  handler = g_signal_connect (transport, \"control\", G_CALLBACK (on_transport_control), &ready);\n\n  while (!ready)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_object_unref (transport);\n\n  cockpit_creds_unref (creds);\n\n  input = g_memory_input_stream_new_from_data (\"\", 0, NULL);\n  output = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);\n  tc->io = mock_io_stream_new (input, output);\n  tc->output = G_MEMORY_OUTPUT_STREAM (output);\n  g_object_unref (input);\n\n  tc->headers = cockpit_web_server_new_table ();\n  g_hash_table_insert (tc->headers, g_strdup (\"Accept-Encoding\"), g_strdup (\"gzip, identity\"));\n\n  g_signal_handler_disconnect (transport, handler);\n}\n\nstatic void\nteardown_resource (TestResourceCase *tc,\n                   gconstpointer data)\n{\n  cockpit_assert_expected ();\n\n  g_hash_table_unref (tc->headers);\n\n  g_object_add_weak_pointer (G_OBJECT (tc->service), (gpointer *)&tc->service);\n  g_object_unref (tc->service);\n  g_assert (tc->service == NULL);\n\n  g_object_unref (tc->io);\n  g_object_unref (tc->output);\n  g_object_unref (tc->pipe);\n}\n\nstatic gboolean\nstr_contains_strv (const gchar *haystack, const gchar *sewing_kit, const gchar *delim)\n{\n  gchar **needles;\n  gboolean result = TRUE;\n  if (strlen (haystack) != strlen (sewing_kit))\n    {\n      fprintf(stderr, \"Length of '%s' doesn't match '%s'\\n\", haystack, sewing_kit);\n      return FALSE;\n    }\n\n  needles = g_strsplit (sewing_kit, delim, 0);\n  for (guint i = 0; i < g_strv_length (needles) && result; ++i)\n    result &= strstr (haystack, needles[i]) != NULL;\n  g_strfreev (needles);\n  if (!result)\n    fprintf(stderr, \"String '%s' doesn't contain each element in '%s'\\n\",\n            haystack, sewing_kit);\n  return result;\n}\n\nstatic void\ntest_resource_simple (TestResourceCase *tc,\n                      gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *url = \"/@localhost/another/test.html\";\n  const gchar *expected =\n    \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://localhost; connect-src 'self' http://localhost ws://localhost; form-action 'self' http://localhost; base-uri 'self' http://localhost; object-src 'none'; font-src 'self' http://localhost data:; img-src 'self' http://localhost data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"52\\r\\n\"\n    \"<html>\\n\"\n    \"<head>\\n\"\n    \"<title>In home dir</title>\\n\"\n    \"</head>\\n\"\n    \"<body>In home dir</body>\\n\"\n    \"</html>\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"52\\r\\n\"\n                           \"<html>\\n\"\n                           \"<head>\\n\"\n                           \"<title>In home dir</title>\\n\"\n                           \"</head>\\n\"\n                           \"<body>In home dir</body>\\n\"\n                           \"</html>\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_simple_host (TestResourceCase *tc,\n                           gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *url = \"/@localhost/another/test.html\";\n  const gchar *expected =\n    \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://my.host; connect-src 'self' http://my.host ws://my.host; form-action 'self' http://my.host; base-uri 'self' http://my.host; object-src 'none'; font-src 'self' http://my.host data:; img-src 'self' http://my.host data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://my.host\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"52\\r\\n\"\n    \"<html>\\n\"\n    \"<head>\\n\"\n    \"<title>In home dir</title>\\n\"\n    \"</head>\\n\"\n    \"<body>In home dir</body>\\n\"\n    \"</html>\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  g_hash_table_insert (tc->headers, g_strdup (\"Host\"), g_strdup (\"my.host\"));\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"52\\r\\n\"\n                           \"<html>\\n\"\n                           \"<head>\\n\"\n                           \"<title>In home dir</title>\\n\"\n                           \"</head>\\n\"\n                           \"<body>In home dir</body>\\n\"\n                           \"</html>\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_language (TestResourceCase *tc,\n                        gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  gchar *url = \"/@localhost/another/test.html\";\n  const gchar *expected =  \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://localhost; connect-src 'self' http://localhost ws://localhost; form-action 'self' http://localhost; base-uri 'self' http://localhost; object-src 'none'; font-src 'self' http://localhost data:; img-src 'self' http://localhost data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"60\\r\\n\"\n    \"<html>\\n\"\n    \"<head>\\n\"\n    \"<title>Inlay omehay irday</title>\\n\"\n    \"</head>\\n\"\n    \"<body>Inlay omehay irday</body>\\n\"\n    \"</html>\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  g_hash_table_insert (tc->headers, g_strdup (\"Accept-Language\"), g_strdup (\"pig, blah\"));\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"60\\r\\n\"\n                           \"<html>\\n\"\n                           \"<head>\\n\"\n                           \"<title>Inlay omehay irday</title>\\n\"\n                           \"</head>\\n\"\n                           \"<body>Inlay omehay irday</body>\\n\"\n                           \"</html>\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_cookie (TestResourceCase *tc,\n                      gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *url = \"/@localhost/another/test.html\";\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://localhost; connect-src 'self' http://localhost ws://localhost; form-action 'self' http://localhost; base-uri 'self' http://localhost; object-src 'none'; font-src 'self' http://localhost data:; img-src 'self' http://localhost data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"60\\r\\n\"\n    \"<html>\\n\"\n    \"<head>\\n\"\n    \"<title>Inlay omehay irday</title>\\n\"\n    \"</head>\\n\"\n    \"<body>Inlay omehay irday</body>\\n\"\n    \"</html>\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  g_hash_table_insert (tc->headers, g_strdup (\"Cookie\"), g_strdup (\"CockpitLang=pig\"));\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str, \"*\\r\\n\"\n                           \"60\\r\\n\"\n                           \"<html>\\n\"\n                           \"<head>\\n\"\n                           \"<title>Inlay omehay irday</title>\\n\"\n                           \"</head>\\n\"\n                           \"<body>Inlay omehay irday</body>\\n\"\n                           \"</html>\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_not_found (TestResourceCase *tc,\n                         gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *url = \"/cockpit/another@localhost/not-exist\";\n  const gchar *expected = \"HTTP/1.1 404 Not Found\\r\\n\"\n    \"Content-Type: text/html; charset=utf8\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    STATIC_HEADERS\n    \"\\r\\n13\\r\\n\"\n    \"<html><head><title>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\n15\\r\\n\"\n    \"</title></head><body>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\nf\\r\\n\"\n    \"</body></html>\\n\\r\\n0\\r\\n\\r\\n\";\n\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"another@localhost\", \"/not-exist\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str, \"*\\r\\n13\\r\\n\"\n                           \"<html><head><title>\\r\\n9\\r\\n\"\n                           \"Not Found\\r\\n15\\r\\n\"\n                           \"</title></head><body>\\r\\n9\\r\\n\"\n                           \"Not Found\\r\\nf\\r\\n\"\n                           \"</body></html>\\n\\r\\n0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_no_path (TestResourceCase *tc,\n                       gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *url = \"/cockpit/another@localhost\";\n  const gchar *expected = \"HTTP/1.1 404 Not Found\\r\\n\"\n    \"Content-Type: text/html; charset=utf8\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    STATIC_HEADERS\n    \"\\r\\n13\\r\\n\"\n    \"<html><head><title>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\n15\\r\\n\"\n    \"</title></head><body>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\nf\\r\\n\"\n    \"</body></html>\\n\\r\\n0\\r\\n\\r\\n\";\n\n  /* Missing path after package */\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"another@localhost\", \"\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str, \"*\\r\\n13\\r\\n\"\n                           \"<html><head><title>\\r\\n9\\r\\n\"\n                           \"Not Found\\r\\n15\\r\\n\"\n                           \"</title></head><body>\\r\\n9\\r\\n\"\n                           \"Not Found\\r\\nf\\r\\n\"\n                           \"</body></html>\\n\\r\\n0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\n\nstatic void\ntest_resource_failure (TestResourceCase *tc,\n                       gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  GPid pid;\n  const gchar *expected = \"HTTP/1.1 500 terminated\\r\\nContent-Type: text/html; charset=utf8\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS \"\\r\\n13\\r\\n<html><head><title>\\r\\na\\r\\nterminated\\r\\n15\\r\\n</title></head><body>\\r\\na\\r\\nterminated\\r\\nf\\r\\n</body></html>\\n\\r\\n0\\r\\n\\r\\n\";\n  const gchar *expected_alt = \"HTTP/1.1 500 internal-error\\r\\nContent-Type: text/html; charset=utf8\\r\\nTransfer-Encoding: chunked\\r\\n\" STATIC_HEADERS \"\\r\\n13\\r\\n<html><head><title>\\r\\ne\\r\\ninternal-error\\r\\n15\\r\\n</title></head><body>\\r\\ne\\r\\ninternal-error\\r\\nf\\r\\n</body></html>\\n\\r\\n0\\r\\n\\r\\n\";\n\n  cockpit_expect_possible_log (\"cockpit-protocol\", G_LOG_LEVEL_WARNING, \"*: bridge program failed:*\");\n  cockpit_expect_possible_log (\"cockpit-ws\", G_LOG_LEVEL_MESSAGE, \"*: external channel failed: *\");\n\n  /* Now kill the bridge */\n  g_assert (cockpit_pipe_get_pid (tc->pipe, &pid));\n  g_assert_cmpint (pid, >, 0);\n  g_assert_cmpint (kill (pid, SIGTERM), ==, 0);\n  /* Wait until it's gone; we can't use waitpid(), it interferes with GChildWatch */\n  while (kill (pid, 0) >= 0)\n    g_usleep (1000);\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  /* Null terminate for str-match below */\n  g_output_stream_write_all (G_OUTPUT_STREAM (tc->output), \"\\0\", 1, NULL, NULL, &error);\n  g_assert_no_error (error);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\") || str_contains_strv (str, expected_alt, \"\\n\"));\n  cockpit_assert_strmatch (str, \"*\\r\\n\\r\\n13\\r\\n<html><head><title>\\r\\n*\\r\\n*\\r\\n15\\r\\n</title></head><body>\\r\\n*\\r\\n*\\r\\nf\\r\\n</body></html>\\n\\r\\n0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic const TestResourceFixture checksum_fixture = {\n  .xdg_data_home = \"/nonexistent\"\n};\n\n\nstatic void\nrequest_checksum (TestResourceCase *tc)\n{\n  CockpitWebResponse *response;\n  GInputStream *input;\n  GOutputStream *output;\n  GIOStream *io;\n\n  input = g_memory_input_stream_new_from_data (\"\", 0, NULL);\n  output = g_memory_output_stream_new (NULL, 0, g_realloc, g_free);\n  io = mock_io_stream_new (input, output);\n  g_object_unref (input);\n\n  /* Start the connection up, and poke it a bit */\n  response = cockpit_web_response_new (io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/checksum\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_object_unref (io);\n\n  /* Use this when the checksum changes, due to mock resource changes */\n#if 0\n  bytes = g_memory_output_stream_steal_as_bytes (G_MEMORY_OUTPUT_STREAM (output));\n  g_printerr (\"%.*s\\n\", (gint)g_bytes_get_size (bytes), (gchar *)g_bytes_get_data (bytes, NULL));\n  g_bytes_unref (bytes);\n#endif\n\n  g_object_unref (output);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_checksum (TestResourceCase *tc,\n                        gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"ETag: \\\"\" CHECKSUM \"-c\\\"\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Cache-Control: max-age=31556926, public\\r\\n\"\n    \"\\r\\n\"\n    \"32\\r\\n\"\n    \"These are the contents of file.ext\\nOh marmalaaade\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  /* We require that no user packages are loaded, so we have a checksum */\n  g_assert (data == &checksum_fixture);\n\n  request_checksum (tc);\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_channel_response_serve (tc->service, tc->headers, response,\n                                CHECKSUM,\n                                \"/test/sub/file.ext\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"32\\r\\n\"\n                           \"These are the contents of file.ext\\nOh marmalaaade\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_not_modified (TestResourceCase *tc,\n                            gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  const gchar *expected = \"HTTP/1.1 304 Not Modified\\r\\n\"\n    \"ETag: \\\"\" CHECKSUM \"-c\\\"\\r\\n\"\n    STATIC_HEADERS\n    \"\\r\\n\";\n\n  request_checksum (tc);\n\n  g_hash_table_insert (tc->headers, g_strdup (\"If-None-Match\"),\n                       g_strdup (\"\\\"\" CHECKSUM \"-c\\\"\"));\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_channel_response_serve (tc->service, tc->headers, response,\n                                CHECKSUM,\n                                \"/test/sub/file.ext\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  g_assert (str_contains_strv (g_bytes_get_data (bytes, NULL), expected, \"\\n\"));\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_not_modified_new_language (TestResourceCase *tc,\n                                         gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"ETag: \\\"\" CHECKSUM \"-de\\\"\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Cache-Control: max-age=31556926, public\\r\\n\"\n    \"\\r\\n\"\n    \"32\\r\\n\"\n    \"These are the contents of file.ext\\nOh marmalaaade\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  request_checksum (tc);\n\n  g_hash_table_insert (tc->headers, g_strdup (\"If-None-Match\"),\n                       g_strdup (\"\\\"\" CHECKSUM \"-c\\\"\"));\n  g_hash_table_insert (tc->headers, g_strdup (\"Accept-Language\"), g_strdup (\"de\"));\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_channel_response_serve (tc->service, tc->headers, response,\n                                CHECKSUM,\n                                \"/test/sub/file.ext\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"32\\r\\n\"\n                           \"These are the contents of file.ext\\nOh marmalaaade\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_not_modified_cookie_language (TestResourceCase *tc,\n                                            gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  gchar *cookie;\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"ETag: \\\"\" CHECKSUM \"-fr\\\"\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Cache-Control: max-age=31556926, public\\r\\n\"\n    \"\\r\\n\"\n    \"32\\r\\n\"\n    \"These are the contents of file.ext\\nOh marmalaaade\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  request_checksum (tc);\n\n  g_hash_table_insert (tc->headers, g_strdup (\"If-None-Match\"),\n                       g_strdup (\"\\\"\" CHECKSUM \"-c\\\"\"));\n\n  cookie = g_strdup_printf (\"%s; CockpitLang=fr\", (gchar *)g_hash_table_lookup (tc->headers, \"Cookie\"));\n  g_hash_table_insert (tc->headers, g_strdup (\"Cookie\"), cookie);\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, tc->headers, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_channel_response_serve (tc->service, tc->headers, response,\n                                CHECKSUM,\n                                \"/test/sub/file.ext\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"32\\r\\n\"\n                           \"These are the contents of file.ext\\nOh marmalaaade\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_no_checksum (TestResourceCase *tc,\n                           gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 404 Not Found\\r\\n\"\n    \"Content-Type: text/html; charset=utf8\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    STATIC_HEADERS\n    \"\\r\\n13\\r\\n\"\n    \"<html><head><title>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\n15\\r\\n\"\n    \"</title></head><body>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\nf\\r\\n\"\n    \"</body></html>\\n\\r\\n0\\r\\n\\r\\n\";\n\n  /* Missing checksum */\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"xxx\", \"/test\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n13\\r\\n*\"\n                           \"*<html><head><title>\\r\\n9\\r\\n*\"\n                           \"*Not Found\\r\\n15\\r\\n*\"\n                           \"*</title></head><body>\\r\\n9\\r\\n*\"\n                           \"*Not Found\\r\\nf\\r\\n*\"\n                           \"*</body></html>\\n\\r\\n0\\r\\n\\r\\n*\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_bad_checksum (TestResourceCase *tc,\n                            gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 404 Not Found\\r\\n\"\n    \"Content-Type: text/html; charset=utf8\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    STATIC_HEADERS\n    \"\\r\\n13\\r\\n\"\n    \"<html><head><title>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\n15\\r\\n\"\n    \"</title></head><body>\\r\\n9\\r\\n\"\n    \"Not Found\\r\\nf\\r\\n\"\n    \"</body></html>\\n\\r\\n0\\r\\n\\r\\n\";\n\n  /* Missing checksum */\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"09323094823029348\", \"/path\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n13\\r\\n*\"\n                           \"*<html><head><title>\\r\\n9\\r\\n*\"\n                           \"*Not Found\\r\\n15\\r\\n*\"\n                           \"*</title></head><body>\\r\\n9\\r\\n*\"\n                           \"*Not Found\\r\\nf\\r\\n*\"\n                           \"*</body></html>\\n\\r\\n0\\r\\n\\r\\n*\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_language_suffix (TestResourceCase *tc,\n                               gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://localhost; connect-src 'self' http://localhost ws://localhost; form-action 'self' http://localhost; base-uri 'self' http://localhost; object-src 'none'; font-src 'self' http://localhost data:; img-src 'self' http://localhost data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"62\\r\\n\"\n    \"<html>\\n\"\n    \"<head>\\n\"\n    \"<title>Im Home-Verzeichnis</title>\\n\"\n    \"</head>\\n\"\n    \"<body>Im Home-Verzeichnis</body>\\n\"\n    \"</html>\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.de.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"62\\r\\n\"\n                           \"<html>\\n\"\n                           \"<head>\\n\"\n                           \"<title>Im Home-Verzeichnis</title>\\n\"\n                           \"</head>\\n\"\n                           \"<body>Im Home-Verzeichnis</body>\\n\"\n                           \"</html>\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_language_fallback (TestResourceCase *tc,\n                                 gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://localhost; connect-src 'self' http://localhost ws://localhost; form-action 'self' http://localhost; base-uri 'self' http://localhost; object-src 'none'; font-src 'self' http://localhost data:; img-src 'self' http://localhost data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"52\\r\\n\"\n    \"<html>\\n\"\n    \"<head>\\n\"\n    \"<title>In home dir</title>\\n\"\n    \"</head>\\n\"\n    \"<body>In home dir</body>\\n\"\n    \"</html>\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  /* Language cookie overrides */\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.fi.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"52\\r\\n\"\n                           \"<html>\\n\"\n                           \"<head>\\n\"\n                           \"<title>In home dir</title>\\n\"\n                           \"</head>\\n\"\n                           \"<body>In home dir</body>\\n\"\n                           \"</html>\\n\"\n                           \"\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_gzip_encoding (TestResourceCase *tc,\n                             gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Encoding: gzip\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Content-Type: text/plain\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"34\\r\\n\"\n    \"\\x1F\\x8B\\x08\\x08N1\\x03U\\x00\\x03test-file.txt\\x00sT(\\xCEM\\xCC\\xC9Q(I-\"\n    \".QH\\xCB\\xCCI\\xE5\\x02\\x00>PjG\\x12\\x00\\x00\\x00\\x0D\\x0A\"\n    \"0\\x0D\\x0A\\x0D\\x0A\";\n\n  response = cockpit_web_response_new (tc->io, \"/unused\", \"/unused\", NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test-file.txt\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"34\\r\\n\"\n                           \"\\x1F\\x8B\\x08\\x08N1\\x03U\\x00\\x03test-file.txt\\x00sT(\\xCEM\\xCC\\xC9Q(I-\"\n                           \".QH\\xCB\\xCCI\\xE5\\x02\\x00>PjG\\x12\\x00\\x00\\x00\\x0D\\x0A\"\n                           \"0\\x0D\\x0A\\x0D\\x0A\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic void\ntest_resource_head (TestResourceCase *tc,\n                    gconstpointer data)\n{\n  CockpitWebResponse *response;\n  GError *error = NULL;\n  GBytes *bytes;\n  gconstpointer str;\n  const gchar *url = \"/@localhost/another/test.html\";\n  const gchar *expected = \"HTTP/1.1 200 OK\\r\\n\"\n    STATIC_HEADERS\n    \"Content-Security-Policy: default-src 'self' http://localhost; connect-src 'self' http://localhost ws://localhost; form-action 'self' http://localhost; base-uri 'self' http://localhost; object-src 'none'; font-src 'self' http://localhost data:; img-src 'self' http://localhost data:; block-all-mixed-content\\r\\n\"\n    \"Content-Type: text/html\\r\\n\"\n    \"Cache-Control: no-cache, no-store\\r\\n\"\n    \"Access-Control-Allow-Origin: http://localhost\\r\\n\"\n    \"Transfer-Encoding: chunked\\r\\n\"\n    \"Vary: Cookie\\r\\n\"\n    \"\\r\\n\"\n    \"0\\r\\n\\r\\n\";\n\n  response = cockpit_web_response_new (tc->io, url, url, NULL, NULL, COCKPIT_WEB_RESPONSE_NONE);\n  cockpit_web_response_set_method (response, \"HEAD\");\n\n  cockpit_channel_response_serve (tc->service, tc->headers, response, \"@localhost\", \"/another/test.html\");\n\n  while (cockpit_web_response_get_state (response) != COCKPIT_WEB_RESPONSE_SENT)\n    g_main_context_iteration (NULL, TRUE);\n\n  g_output_stream_close (G_OUTPUT_STREAM (tc->output), NULL, &error);\n  g_assert_no_error (error);\n\n  bytes = g_memory_output_stream_steal_as_bytes (tc->output);\n  str = g_bytes_get_data (bytes, NULL);\n  g_assert (str_contains_strv (str, expected, \"\\n\"));\n  cockpit_assert_strmatch (str,\n                           \"*\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n\n  g_bytes_unref (bytes);\n  g_object_unref (response);\n}\n\nstatic gboolean\non_hack_raise_sigchld (gpointer user_data)\n{\n  raise (SIGCHLD);\n  return TRUE;\n}\n\nint\nmain (int argc,\n      char *argv[])\n{\n  cockpit_test_init (&argc, &argv);\n\n  /*\n   * HACK: Work around races in glib SIGCHLD handling.\n   *\n   * https://bugzilla.gnome.org/show_bug.cgi?id=731771\n   * https://bugzilla.gnome.org/show_bug.cgi?id=711090\n   */\n  g_timeout_add_seconds (1, on_hack_raise_sigchld, NULL);\n\n  /* Try to debug crashing during tests */\n  signal (SIGSEGV, cockpit_test_signal_backtrace);\n\n  /* We don't want to test the ping functionality in these tests */\n  cockpit_ws_ping_interval = G_MAXUINT;\n\n  g_test_add (\"/web-channel/resource/simple\", TestResourceCase, NULL,\n              setup_resource, test_resource_simple, teardown_resource);\n  g_test_add (\"/web-channel/resource/simple_host\", TestResourceCase, NULL,\n              setup_resource, test_resource_simple_host, teardown_resource);\n  g_test_add (\"/web-channel/resource/language\", TestResourceCase, NULL,\n              setup_resource, test_resource_language, teardown_resource);\n  g_test_add (\"/web-channel/resource/cookie\", TestResourceCase, NULL,\n              setup_resource, test_resource_cookie, teardown_resource);\n  g_test_add (\"/web-channel/resource/not-found\", TestResourceCase, NULL,\n              setup_resource, test_resource_not_found, teardown_resource);\n  g_test_add (\"/web-channel/resource/no-path\", TestResourceCase, NULL,\n              setup_resource, test_resource_no_path, teardown_resource);\n  g_test_add (\"/web-channel/resource/failure\", TestResourceCase, NULL,\n              setup_resource, test_resource_failure, teardown_resource);\n  g_test_add (\"/web-channel/resource/checksum\", TestResourceCase, &checksum_fixture,\n              setup_resource, test_resource_checksum, teardown_resource);\n  g_test_add (\"/web-channel/resource/not-modified\", TestResourceCase, &checksum_fixture,\n              setup_resource, test_resource_not_modified, teardown_resource);\n  g_test_add (\"/web-channel/resource/not-modified-new-language\", TestResourceCase, &checksum_fixture,\n              setup_resource, test_resource_not_modified_new_language, teardown_resource);\n  g_test_add (\"/web-channel/resource/not-modified-cookie-language\", TestResourceCase, &checksum_fixture,\n              setup_resource, test_resource_not_modified_cookie_language, teardown_resource);\n  g_test_add (\"/web-channel/resource/no-checksum\", TestResourceCase, NULL,\n              setup_resource, test_resource_no_checksum, teardown_resource);\n  g_test_add (\"/web-channel/resource/bad-checksum\", TestResourceCase, NULL,\n              setup_resource, test_resource_bad_checksum, teardown_resource);\n  g_test_add (\"/web-channel/resource/language-suffix\", TestResourceCase, NULL,\n              setup_resource, test_resource_language_suffix, teardown_resource);\n  g_test_add (\"/web-channel/resource/language-fallback\", TestResourceCase, NULL,\n              setup_resource, test_resource_language_fallback, teardown_resource);\n\n  g_test_add (\"/web-channel/resource/gzip-encoding\", TestResourceCase, NULL,\n              setup_resource, test_resource_gzip_encoding, teardown_resource);\n  g_test_add (\"/web-channel/resource/head\", TestResourceCase, NULL,\n              setup_resource, test_resource_head, teardown_resource);\n\n  return g_test_run ();\n}\n", "#!/usr/bin/python3\n\n# This file is part of Cockpit.\n#\n# Copyright (C) 2013 Red Hat, Inc.\n#\n# Cockpit is free software; you can redistribute it and/or modify it\n# under the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation; either version 2.1 of the License, or\n# (at your option) any later version.\n#\n# Cockpit is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\nimport base64\nimport time\nimport os\nimport subprocess\n\nimport parent\nfrom testlib import *\n\n\n@skipDistroPackage()\nclass TestConnection(MachineCase):\n\n    def setUp(self):\n        super().setUp()\n        self.ws_executable = f\"{self.libexecdir}/cockpit-ws\"\n\n    def ostree_setup_ws(self):\n        '''Overlay cockpit-ws package on OSTree image\n\n        Disable the cockpit/ws container. This is for tests that don't work with the container,\n        and to make sure that overlaying cockpit-ws works as well.\n        '''\n        m = self.machine\n        if not m.ostree_image:\n            return\n\n        # uninstall cockpit/ws container startup script\n        m.execute(\"rm /etc/systemd/system/cockpit.service\")\n        # overlay cockpit-ws rpm\n        m.execute(\"rpm-ostree install --cache-only /var/tmp/build-results/cockpit-ws-*.rpm\")\n        m.spawn(\"sync && sync && sync && sleep 0.1 && reboot\", \"reboot\")\n        m.wait_reboot()\n\n    @skipBrowser(\"Firefox cannot work with cookies\", \"firefox\")\n    def testBasic(self):\n        m = self.machine\n\n        # always test with the default ws install (container on OSTree, package everywhere else)\n        self.check_basic_with_start_stop(m.start_cockpit, m.stop_cockpit)\n\n        # on OSTree, also check with overlaid cockpit-ws rpm\n        if m.ostree_image:\n            def ws_start():\n                m.execute(r\"\"\"set -e;\n                    mkdir -p /etc/systemd/system/cockpit.service.d/ &&\n                    printf \"[Service]\\nExecStart=\\n%s --no-tls\" `grep ExecStart= /lib/systemd/system/cockpit.service` \\\n                            > /etc/systemd/system/cockpit.service.d/notls.conf\n                    systemctl daemon-reload\n                    systemctl start cockpit.socket\"\"\")\n\n            def ws_stop():\n                m.execute(\"systemctl stop cockpit cockpit.socket\")\n\n            self.ostree_setup_ws()\n            # HACK: Getting SELinux errors with just rpm-ostree install; there's a plethora of failures, so just allow them all\n            m.execute(\"setenforce 0\")\n            self.allow_journal_messages('audit.*avc:  denied .*')\n            self.check_basic_with_start_stop(ws_start, ws_stop)\n\n    def check_basic_with_start_stop(self, start_cockpit, stop_cockpit):\n        m = self.machine\n        b = self.browser\n        start_cockpit()\n\n        # take cockpit-ws down on the login page\n        b.open(\"/system\")\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        stop_cockpit()\n        b.click('#login-button')\n        b.wait_text_not('#login-fatal-message', \"\")\n        start_cockpit()\n        b.reload()\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load()\n        b.enter_page(\"/system\")\n\n        # cookie should not be marked as secure, it's not https\n        cookie = b.cookie(\"cockpit\")\n        self.assertTrue(cookie[\"httpOnly\"])\n        self.assertEqual(cookie[\"sameSite\"], \"Strict\")\n        self.assertFalse(cookie[\"secure\"])\n\n        # take cockpit-ws down on the server page\n        stop_cockpit()\n        b.switch_to_top()\n        b.wait_in_text(\".curtains-ct h1\", \"Disconnected\")\n\n        start_cockpit()\n        b.click(\"#machine-reconnect\")\n        b.expect_load()\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n\n        # sever the connection on the login page\n        m.execute(\"iptables -w -I INPUT -p tcp --dport 9090 -j REJECT --reject-with tcp-reset\")\n        b.click('#login-button')\n        with b.wait_timeout(20):\n            b.wait_text_not('#login-fatal-message', \"\")\n        m.execute(\"iptables -w -D INPUT -p tcp --dport 9090 -j REJECT --reject-with tcp-reset\")\n        b.reload()\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load()\n        b.enter_page(\"/system\")\n\n        # sever the connection on the server page\n        m.execute(\"iptables -w -I INPUT -p tcp --dport 9090 -j REJECT\")\n        b.switch_to_top()\n        with b.wait_timeout(60):\n            b.wait_visible(\".curtains-ct\")\n\n        b.wait_in_text(\".curtains-ct h1\", \"Disconnected\")\n        b.wait_in_text('.curtains-ct p', \"Connection has timed out.\")\n        m.execute(\"iptables -w -D INPUT -p tcp --dport 9090 -j REJECT\")\n        b.click(\"#machine-reconnect\")\n        b.expect_load()\n        b.enter_page(\"/system\")\n        b.logout()\n\n        # deleted cookie after logout should not be marked as secure, it's not https\n        cookie = b.cookie(\"cockpit\")\n        self.assertEqual(cookie[\"value\"], \"deleted\")\n        self.assertTrue(cookie[\"httpOnly\"])\n        self.assertFalse(cookie[\"secure\"])\n\n        if not m.ostree_image:  # cannot write to /usr on OSTree, and cockpit-session is in a container\n            # damage cockpit-session permissions, expect generic error message\n            m.execute(f\"chmod g-x {self.libexecdir}/cockpit-session\")\n            b.open(\"/system\")\n            b.wait_in_text('#login-fatal-message', \"Internal error in login process\")\n            m.execute(f\"chmod g+x {self.libexecdir}/cockpit-session\")\n\n            self.allow_journal_messages(\".*cockpit-session: bridge program failed.*\")\n\n            # pretend cockpit-bridge is not installed, expect specific error message\n            m.execute(\"mv /usr/bin/cockpit-bridge /usr/bin/cockpit-bridge.disabled\")\n            b.open(\"/system\")\n            b.wait_visible(\"#login\")\n            b.set_val(\"#login-user-input\", \"admin\")\n            b.set_val(\"#login-password-input\", \"foobar\")\n            b.click('#login-button')\n            b.wait_visible('#login-fatal-message')\n            b.wait_text('#login-fatal-message', \"The cockpit package is not installed\")\n            m.execute(\"mv /usr/bin/cockpit-bridge.disabled /usr/bin/cockpit-bridge\")\n\n        self.allow_restart_journal_messages()\n\n        # Lets crash a systemd-crontrolled process and see if we get a proper backtrace in the logs\n        # This helps with debugging failures in the tests elsewhere\n        m.execute(\"\"\"mkdir -p /run/systemd/system/systemd-hostnamed.service.d\n                     printf '[Service]\\nLimitCORE=infinity\\n' > /run/systemd/system/systemd-hostnamed.service.d/core.conf\n                     systemctl daemon-reload\n                     systemctl restart systemd-hostnamed\n                     pkill -e -SEGV systemd-hostnam\"\"\")\n        wait(lambda: m.execute(\"journalctl -b | grep 'Process.*systemd-hostnam.*of user.*dumped core.'\"))\n\n        # Make sure the core dumps exist in the directory, so we can download them\n        cores = m.execute(\"find /var/lib/systemd/coredump -type f\")\n        self.assertNotEqual(cores, \"\")\n\n        self.allow_core_dumps = True\n        self.allow_journal_messages(\".*org.freedesktop.hostname1.*DBus.Error.NoReply.*\")\n\n    @skipImage(\"OSTree doesn't use systemd units\", \"fedora-coreos\")\n    def testUnitLifecycle(self):\n        m = self.machine\n\n        def expect_active(unit, is_active):\n            status = m.execute(\"systemctl is-active %s || true\" % unit).strip()\n            self.assertIn(status, [\"active\", \"inactive\"])\n            if is_active:\n                self.assertEqual(status, \"active\", \"%s is not active\" % unit)\n            else:\n                self.assertEqual(status, \"inactive\", \"%s is active\" % unit)\n\n        def expect_actives(ws_socket, instance_sockets, http_instances, https_instances=0):\n            expect_active(\"cockpit.socket\", ws_socket)\n            # http instances\n            for instance in [\"http\", \"http-redirect\"]:\n                expect_active(\"cockpit-wsinstance-%s.socket\" % instance, instance_sockets)\n                expect_active(\"cockpit-wsinstance-%s.service\" % instance, instance in http_instances)\n            # number of https instances\n            expect_active(\"cockpit-wsinstance-https-factory.socket\", instance_sockets)\n            for _type in [\"service\", \"socket\"]:\n                out = m.execute(\"systemctl --no-legend -t %s list-units cockpit-wsinstance-https@*\" % _type)\n                count = len(out.strip().splitlines())\n                self.assertEqual(count, https_instances, out)\n\n        # at the beginning, no cockpit related units are running\n        expect_actives(False, False, [])\n\n        # http only mode\n\n        m.start_cockpit(tls=False)\n        expect_actives(True, False, [])\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9090\"))\n\n        expect_actives(True, True, [\"http\"])\n        self.assertRaises(subprocess.CalledProcessError, m.execute,\n                          \"curl --silent https://127.0.0.1:9090\")\n        # c-tls knows it can't do https, and not activate that instance\n        expect_actives(True, True, [\"http\"])\n\n        m.restart_cockpit()\n        expect_actives(True, True, [\"http\"])\n\n        m.stop_cockpit()\n        expect_actives(False, False, [])\n\n        # cleans up also when cockpit-tls crashes or idle-exits, not just by explicit stop request\n        m.start_cockpit(tls=False)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9090\"))\n        m.execute(\"pkill -e cockpit-tls\")\n        expect_actives(True, False, [])\n\n        # and recovers from that\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9090\"))\n        expect_actives(True, True, [\"http\"])\n\n        # https mode\n\n        m.start_cockpit(tls=True)\n        expect_actives(True, False, [], 0)\n\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9090\"))\n\n        expect_actives(True, True, [\"http-redirect\"], 0)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent -k --head https://127.0.0.1:9090\"))\n        expect_actives(True, True, [\"http-redirect\"], 1)\n\n        m.restart_cockpit()\n        expect_actives(True, True, [\"http-redirect\"], 1)\n\n        m.stop_cockpit()\n        expect_actives(False, False, [], 0)\n\n        m.start_cockpit(tls=True)\n        expect_actives(True, False, [], 0)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9090\"))\n\n        expect_actives(True, True, [\"http-redirect\"], 0)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent -k --head https://127.0.0.1:9090\"))\n        expect_actives(True, True, [\"http-redirect\"], 1)\n\n        # cleans up also when cockpit-tls crashes or idle-exits, not just by explicit stop request\n        m.execute(\"pkill -e cockpit-tls\")\n        expect_actives(True, False, [], 0)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9090\"))\n        expect_actives(True, True, [\"http-redirect\"], 0)\n        # next https request after crash doesn't leak an instance\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent -k --head https://127.0.0.1:9090\"))\n        expect_actives(True, True, [\"http-redirect\"], 1)\n\n        # instance service+socket going away does not confuse cockpit-tls' bookkeeping\n        m.execute(\"systemctl stop cockpit-wsinstance-https@*.service cockpit-wsinstance-https@*.socket\")\n        expect_actives(True, True, [\"http-redirect\"], 0)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --show-error -k --head https://127.0.0.1:9090\"))\n        expect_actives(True, True, [\"http-redirect\"], 1)\n\n        # sockets are inaccessible to users, only to cockpit-tls\n        for s in [\"http.sock\", \"https-factory.sock\"]:\n            out = m.execute(\"su -c '! nc -U /run/cockpit/wsinstance/%s 2>&1 || exit 1' admin\" % s)\n            self.assertIn(\"Permission denied\", out)\n\n    @skipImage(\"OSTree doesn't use systemd units\", \"fedora-coreos\")\n    def testHttpsInstanceDoS(self):\n        m = self.machine\n        # prevent generating core dump artifacts\n        m.execute(\"echo core > /proc/sys/kernel/core_pattern\")\n        m.start_cockpit(tls=True)\n\n        # some netcat versions need an explicit shutdown option, others default to shutting down and don't have -N\n        n_opt = \"-N\" if \"-N\" in m.execute(\"nc -h 2>&1\") else \"\"\n\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent -k --head https://127.0.0.1:9090\"))\n\n        # number of https instances is bounded (DoS prevention)\n        # with MaxTasks=200 und 2 threads per ws instance we should have a\n        # rough limit of 100 instances, so at some point curl should start failing\n        m.execute(\"su -s /bin/sh -c 'RC=1; for i in `seq 120`; do \"\n                  \"  echo -n $i | nc %s -U /run/cockpit/wsinstance/https-factory.sock;\"\n                  \"  curl --silent --head --max-time 5 --unix /run/cockpit/wsinstance/https@$i.sock http://dummy > /dev/null || RC=0; \"\n                  \"done; exit $RC' cockpit-ws\" % n_opt)\n\n        for type_ in [\"socket\", \"service\"]:\n            active = int(m.execute(\"systemctl --no-legend list-units -t %s --state=active \"\n                                   \"'cockpit-wsinstance-https@*' | wc -l\" % type_).strip())\n            self.assertGreater(active, 45)\n            self.assertLess(active, 110)\n        failed = int(m.execute(\"systemctl --no-legend list-units --state=failed 'cockpit-wsinstance-https@*' | wc -l\").strip())\n        self.assertGreater(failed, 0)\n        self.assertLess(failed, 75)  # services and sockets\n\n        self.allow_journal_messages(\".*cockpit-ws.*dumped core.*\")\n        self.allow_journal_messages(\".*Error creating thread: Resource temporarily unavailable.*\")\n\n        # initial instance still works\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --show-error -k --head https://127.0.0.1:9090\"))\n\n        # can launch new instances after freeing up some old ones\n        m.execute(\"systemctl stop cockpit-wsinstance-https@30 cockpit-wsinstance-https@31 cockpit-wsinstance-https@32\")\n        m.execute(\"echo -n new | nc %s -U /run/cockpit/wsinstance/https-factory.sock\" % n_opt)\n        out = m.execute(\"curl --silent --show-error --head --unix /run/cockpit/wsinstance/https@new.sock http://dummy\")\n        self.assertIn(\"HTTP/1.1 200 OK\", out)\n\n    @skipBrowser(\"Firefox needs proper cert and CA\", \"firefox\")\n    def testTls(self):\n        m = self.machine\n        b = self.browser\n\n        # Start Cockpit with TLS\n        m.start_cockpit(tls=True)\n\n        # A normal TLS connection works\n        output = m.execute('openssl s_client -connect 172.27.0.15:9090 2>&1')\n        m.message(output)\n        self.assertIn(\"DONE\", output)\n\n        # has proper keyUsage and SAN (both with sscg and with self-signed)\n        output = m.execute(\"openssl s_client -showcerts -connect 172.27.0.15:9090 |\"\n                           \"openssl x509 -noout -ext keyUsage,extendedKeyUsage,subjectAltName\")\n        # keyUsage\n        self.assertIn(\"Digital Signature\", output)\n        self.assertIn(\"Key Encipherment\", output)\n        # extendedKeyUsage\n        self.assertIn(\"TLS Web Server Authentication\", output)\n        # SAN\n        self.assertIn(\"IP Address:127.0.0.1\", output)\n        self.assertIn(\"DNS:localhost\", output)\n\n        # SSLv3 should not work\n        output = m.execute('openssl s_client -connect 172.27.0.15:9090 -ssl3 2>&1 || true')\n        self.assertNotIn(\"DONE\", output)\n\n        # Some operating systems fail SSL3 on the server side\n        self.assertRegex(output, \"Secure Renegotiation IS NOT supported|\"\n                         \"ssl handshake failure|\"\n                         \"[uU]nknown option.* -ssl3|\"\n                         \"null ssl method passed|\"\n                         \"wrong version number\")\n\n        # RC4 should not work\n        output = m.execute('! openssl s_client -connect 172.27.0.15:9090 -tls1_2 -cipher RC4 2>&1')\n        self.assertNotIn(\"DONE\", output)\n        self.assertRegex(\n            output, r\"no cipher match|no ciphers available|ssl handshake failure|Cipher is \\(NONE\\)\")\n\n        # get along with read-only config directory, as long as certificate exists\n        # this does not work on coreos as the user/group IDs are not mapped correctly\n        if not m.ostree_image:\n            m.stop_cockpit()\n            m.execute(\"cp -a /etc/cockpit /tmp; mount -o bind -r /tmp/cockpit /etc/cockpit\")\n            m.start_cockpit(tls=True)\n            self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl -k --head https://127.0.0.1:9090\"))\n            m.execute(\"umount /etc/cockpit\")\n\n        # Install a certificate chain, and make it accessible for cockpit\n        m.upload([\"verify/files/cert-chain.cert\"], \"/etc/cockpit/ws-certs.d\")\n        m.execute(\"cd /etc/cockpit/ws-certs.d; chgrp cockpit-ws cert-chain.cert; ! selinuxenabled || chcon --type etc_t cert-chain.cert\")\n\n        def check_cert_chain():\n            # This should also reset the file context\n            m.restart_cockpit()\n            output = m.execute('openssl s_client -connect 172.27.0.15:9090 2>&1')\n            self.assertIn(\"DONE\", output)\n            self.assertRegex(output, \"s:/?CN *= *localhost\")\n            self.assertRegex(output, \"1 s:/?OU *= *Intermediate\")\n\n        check_cert_chain()\n\n        # *.crt file also works\n        m.execute(\"mv /etc/cockpit/ws-certs.d/cert-chain.cert /etc/cockpit/ws-certs.d/cert-chain.crt\")\n        check_cert_chain()\n\n        # separate *.key file instead of merged .cert\n        m.execute(\"sed -n '/---BEGIN PRIVATE KEY/,$ p' /etc/cockpit/ws-certs.d/cert-chain.crt > /etc/cockpit/ws-certs.d/cert-chain.key\")\n        m.execute(\"sed -i '/---BEGIN PRIVATE KEY/,$ d' /etc/cockpit/ws-certs.d/cert-chain.crt\")\n        check_cert_chain()\n\n        # login handler: correct password\n        m.execute(\"curl -k -c cockpit.jar -s --head --header 'Authorization: Basic {}' https://127.0.0.1:9090/cockpit/login\".format(\n            base64.b64encode(b\"admin:foobar\").decode(), ))\n        headers = m.execute(\"curl -k --head -b cockpit.jar -s https://127.0.0.1:9090/\")\n        self.assertIn(\n            \"default-src 'self' https://127.0.0.1:9090; connect-src 'self' https://127.0.0.1:9090 wss://127.0.0.1:9090\", headers)\n        self.assertIn(\"Access-Control-Allow-Origin: https://127.0.0.1:9090\", headers)\n        # CORP and Frame-Options are also set for dynamic paths\n        self.assertIn(\"Cross-Origin-Resource-Policy: same-origin\", headers)\n        self.assertIn(\"X-Frame-Options: sameorigin\", headers)\n\n        self.allow_journal_messages(\n            \".*Peer failed to perform TLS handshake\",\n            \".*Peer sent fatal TLS alert:.*\",\n            \".*invalid base64 data in Basic header\",\n            \".*Error performing TLS handshake: No supported cipher suites have been found.\",\n            \".*Error performing TLS handshake: Could not negotiate a supported cipher suite.\")\n\n        # check the Debian smoke test\n        m.upload([\"../tools/debian/tests/smoke\"], \"/tmp\")\n        m.execute(\"/tmp/smoke\")\n\n        b.ignore_ssl_certificate_errors(True)\n        self.login_and_go(\"/system\", tls=True)\n        cookie = b.cookie(\"cockpit\")\n        # cookie should be marked as secure\n        self.assertTrue(cookie[\"httpOnly\"])\n        self.assertTrue(cookie[\"secure\"])\n        self.assertEqual(cookie[\"sameSite\"], \"Strict\")\n        # same after logout\n        b.logout()\n        cookie = b.cookie(\"cockpit\")\n        self.assertEqual(cookie[\"value\"], \"deleted\")\n        self.assertTrue(cookie[\"httpOnly\"])\n        self.assertTrue(cookie[\"secure\"])\n        self.assertEqual(cookie[\"sameSite\"], \"Strict\")\n\n        # http on localhost should not redirect to https\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --head http://127.0.0.1:9090\"))\n        # http on other IP should redirect to https\n        output = m.execute(\"curl --head http://172.27.0.15:9090\")\n        self.assertIn(\"HTTP/1.1 301 Moved Permanently\", output)\n        self.assertIn(\"Location: https://172.27.0.15:9090/\", output)\n        # enable AllowUnencrypted, this disables redirect\n        m.execute('mkdir -p /etc/cockpit/ && echo \"[WebService]\\nAllowUnencrypted=true\" > /etc/cockpit/cockpit.conf')\n        m.restart_cockpit()\n        # now it should not redirect\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --head http://127.0.0.1:9090\"))\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --head http://172.27.0.15:9090\"))\n\n    def testConfigOrigins(self):\n        m = self.machine\n        m.execute(\n            'mkdir -p /etc/cockpit/ && echo \"[WebService]\\nOrigins = http://other-origin:9090 http://localhost:9090\" > /etc/cockpit/cockpit.conf')\n        m.start_cockpit()\n        output = m.execute('curl -s -f -N -H \"Connection: Upgrade\" -H \"Upgrade: websocket\" -H \"Origin: http://other-origin:9090\" -H \"Host: localhost:9090\" -H \"Sec-Websocket-Key: 3sc2c9IzwRUc3BlSIYwtSA==\" -H \"Sec-Websocket-Version: 13\" http://localhost:9090/cockpit/socket')\n        self.assertIn('\"no-session\"', output)\n\n        # The socket should also answer at /socket\n        output = m.execute('curl -s -f -N -H \"Connection: Upgrade\" -H \"Upgrade: websocket\" -H \"Origin: http://other-origin:9090\" -H \"Host: localhost:9090\" -H \"Sec-Websocket-Key: 3sc2c9IzwRUc3BlSIYwtSA==\" -H \"Sec-Websocket-Version: 13\" http://localhost:9090/socket')\n        self.assertIn('\"no-session\"', output)\n\n        self.allow_journal_messages('peer did not close io when expected')\n\n    @skipImage(\"OSTree doesn't use systemd units\", \"fedora-coreos\")\n    def testSocket(self):\n        m = self.machine\n\n        # non-admin user\n        m.execute(\"useradd user\")\n\n        # enable no-password login for 'admin' and 'user'\n        m.execute(\"passwd -d admin\")\n        m.execute(\"passwd -d user\")\n\n        self.sed_file('$ a\\\\\\nPermitEmptyPasswords yes', '/etc/ssh/sshd_config',\n                      'systemctl restart sshd.service')\n\n        def assertInOrNot(string, result, expected):\n            if expected:\n                self.assertIn(string, result)\n            else:\n                self.assertNotIn(string, result)\n\n        def checkMotdForUser(string, user, expected):\n            result = m.execute(f\"ssh -o StrictHostKeyChecking=no -n {user}@localhost\")\n            assertInOrNot(string, result, expected)\n\n        def checkMotdContent(string, expected=True):\n            # Needs https://github.com/linux-pam/linux-pam/pull/292 (or PAM 1.5.0)\n            old_pam = (m.image in ['centos-8-stream', 'debian-stable', 'debian-testing', 'ubuntu-2004', 'ubuntu-stable', 'rhel-8-4', 'rhel-8-5'])\n\n            # check issue (should be exactly the same as motd)\n            assertInOrNot(string, m.execute(\"cat /etc/issue.d/cockpit.issue\"), expected)\n\n            # check motd as 'root' (via cat) and 'admin' and 'user' (via ssh)\n            assertInOrNot(string, m.execute(\"cat /etc/motd.d/cockpit\"), expected)\n            checkMotdForUser(string, expected=expected, user='admin')\n            checkMotdForUser(string, expected=old_pam and expected or False, user='user')\n\n        checkMotdContent('systemctl')\n        checkMotdContent(':9090/', expected=False)\n        m.start_cockpit()\n\n        checkMotdContent(':9090/')\n        checkMotdContent('systemctl', expected=False)\n        m.execute(\"systemctl stop cockpit.socket\")\n\n        # Change port according to documentation: https://cockpit-project.org/guide/latest/listen.html\n        m.execute('! selinuxenabled || semanage port -m -t websm_port_t -p tcp 443')\n        m.execute(\n            'mkdir -p /etc/systemd/system/cockpit.socket.d/ && printf \"[Socket]\\nListenStream=\\nListenStream=/run/cockpit/sock\\nListenStream=443\" > /etc/systemd/system/cockpit.socket.d/listen.conf')\n\n        checkMotdContent('systemctl')\n        checkMotdContent(':9090/', expected=False)\n        checkMotdContent(':443/', expected=False)\n        m.start_cockpit(tls=True)\n\n        checkMotdContent('systemctl', expected=False)\n        checkMotdContent(':9090/', expected=False)\n        checkMotdContent(':443/')\n\n        output = m.execute('curl -k https://localhost 2>&1 || true')\n        self.assertIn('Loading...', output)\n        output = m.execute('curl -k --unix /run/cockpit/sock https://dummy 2>&1 || true')\n        self.assertIn('Loading...', output)\n\n        output = m.execute('curl -k https://localhost:9090 2>&1 || true')\n        self.assertIn('Connection refused', output)\n\n        self.allow_journal_messages(\".*Peer failed to perform TLS handshake\")\n\n    @skipImage(\"Can't remove/upgrade packages on OSTree\", \"fedora-coreos\")\n    def testWsPackage(self):\n        m = self.machine\n\n        if m.image.startswith(\"debian\") or m.image.startswith(\"ubuntu\"):\n            # clean up debug symbols, they get in the way of upgrading\n            m.execute(\"dpkg --purge cockpit-ws-dbgsym\")\n        elif m.image.startswith(\"rhel\"):\n            # subscription-manager-cockpit depends on cockpit-ws\n            m.execute(\"rpm --erase subscription-manager-cockpit\")\n\n        def install():\n            if m.image.startswith(\"debian\") or m.image.startswith(\"ubuntu\"):\n                m.execute(\"dpkg --install /var/tmp/build-results/cockpit-ws_*.deb\")\n            else:\n                m.execute(\"if rpm -q cockpit-ws; then rpm --verify cockpit-ws; fi\")\n                m.execute(\"rpm --upgrade --force /var/tmp/build-results/cockpit-ws-*.rpm\")\n                m.execute(\"rpm --verify cockpit-ws\")\n\n        def remove():\n            if m.image.startswith(\"debian\") or m.image.startswith(\"ubuntu\"):\n                m.execute(\"dpkg --purge cockpit cockpit-ws\")\n            else:\n                m.execute(\"rpm --erase cockpit cockpit-ws\")\n\n        # upgrade from distro version (our images have cockpit-ws preinstalled) sets up dynamic motd/issue symlink\n        self.assertEqual(m.execute(\"readlink /etc/motd.d/cockpit\").strip(), \"/run/cockpit/motd\")\n        self.assertEqual(m.execute(\"readlink /etc/issue.d/cockpit.issue\").strip(), \"/run/cockpit/motd\")\n\n        # package upgrade keeps them\n        install()\n        self.assertEqual(m.execute(\"readlink /etc/motd.d/cockpit\").strip(), \"/run/cockpit/motd\")\n        self.assertEqual(m.execute(\"readlink /etc/issue.d/cockpit.issue\").strip(), \"/run/cockpit/motd\")\n\n        # manual change/removal is respected on upgrade\n        m.execute(\"ln -sf /dev/null /etc/motd.d/cockpit; rm /etc/issue.d/cockpit.issue\")\n        install()\n        self.assertEqual(m.execute(\"readlink /etc/motd.d/cockpit\").strip(), \"/dev/null\")\n        m.execute(\"test ! -e /etc/issue.d/cockpit.issue\")\n\n        # removing the package cleans up the links\n        remove()\n        m.execute(\"test ! -e /etc/motd.d/cockpit\")\n        m.execute(\"test ! -e /etc/issue.d/cockpit.issue\")\n\n        # fresh install (most of our test images have cockpit-ws preinstalled, so the first test above does not cover that)\n        install()\n        self.assertEqual(m.execute(\"readlink /etc/motd.d/cockpit\").strip(), \"/run/cockpit/motd\")\n        self.assertEqual(m.execute(\"readlink /etc/issue.d/cockpit.issue\").strip(), \"/run/cockpit/motd\")\n\n    @skipImage(\"OSTree doesn't have cockpit-ws\", \"fedora-coreos\")\n    def testCommandline(self):\n        m = self.machine\n\n        # Large requests are processed correctly with plain HTTP through cockpit-tls\n        m.start_cockpit(tls=True)\n        self.assertIn('id=\"login\"', m.execute('''curl -s -S -H \"Authorization: Negotiate $(printf '%0.7000i' 1)\" http://localhost:9090/'''))\n\n        # Large requests are processed correctly with TLS through cockpit-tls\n        self.assertIn('id=\"login\"', m.execute('''curl -s -S -k -H \"Authorization: Negotiate $(printf '%0.7000i' 1)\" https://localhost:9090/'''))\n        m.stop_cockpit()\n\n        self.restore_dir(\"/etc/cockpit\")\n        m.execute(\"rm -f /etc/cockpit/ws-certs.d/* /etc/cockpit/cockpit.conf\")\n        m.write(\"/etc/cockpit/cockpit.conf\", \"[WebService]\\nLoginTitle = A Custom Title\\n\")\n\n        m.execute(f\"{self.libexecdir}/cockpit-certificate-ensure\")\n        self.assertTrue(m.execute(\"ls /etc/cockpit/ws-certs.d/*\"))\n\n        m.execute(f\"{self.ws_executable} --port 9000 --address 127.0.0.1 0<&- &>/dev/null &\")\n\n        # The port may not be available immediately, so wait for it\n        wait(lambda: 'A Custom Title' in m.execute('curl -s -k https://localhost:9000/'))\n\n        output = m.execute('curl -s -S -k https://172.27.0.15:9000/ 2>&1 || true')\n        self.assertIn('Connection refused', output)\n\n        # Large requests are processed correctly with plain HTTP\n        self.assertIn('A Custom Title', m.execute('''curl -s -S -H \"Authorization: Negotiate $(printf '%0.7000i' 1)\" http://localhost:9000/'''))\n\n        # Large requests are processed correctly with TLS\n        self.assertIn('A Custom Title', m.execute('''curl -s -S -k -H \"Authorization: Negotiate $(printf '%0.7000i' 1)\" https://localhost:9000/'''))\n\n    def testHeadRequest(self):\n        m = self.machine\n        m.start_cockpit()\n\n        # static handler\n        headers = m.execute(\"curl -s --head http://172.27.0.15:9090/cockpit/static/login.html\")\n        self.assertIn(\"HTTP/1.1 200 OK\\r\\n\", headers)\n        self.assertIn(\"Content-Type: text/html\\r\\n\", headers)\n        self.assertIn(\"Cross-Origin-Resource-Policy: same-origin\\r\\n\", headers)\n        self.assertIn(\"X-Frame-Options: sameorigin\\r\\n\", headers)\n        # login.html is not always accessible as a file (e.g. on CoreOS), so just assert a reasonable content length\n        self.assertIn(\"Content-Length: \", headers)\n        length = int(headers.split('Content-Length: ', 1)[1].split()[0])\n        self.assertGreater(length, 5000)\n        self.assertLess(length, 100000)\n\n        # login handler: wrong password\n        headers = m.execute(\"curl -s --head --header 'Authorization: Basic {}' http://172.27.0.15:9090/cockpit/login\".format(\n            base64.b64encode(b\"admin:hahawrong\").decode()))\n        self.assertIn(\"HTTP/1.1 401 Authentication failed\\r\\n\", headers)\n        self.assertNotIn(\"Set-Cookie:\", headers)\n\n        # login handler: correct password\n        headers = m.execute(\"curl -s --head --header 'Authorization: Basic {}' http://172.27.0.15:9090/cockpit/login\".format(\n            base64.b64encode(b\"admin:foobar\").decode()))\n        self.assertIn(\"HTTP/1.1 200 OK\\r\\n\", headers)\n        self.assertIn(\"Set-Cookie: cockpit\", headers)\n\n        # socket handler; this should refuse HEAD (as it makes little sense on sockets), so 404\n        headers = m.execute(\"curl -s --head http://172.27.0.15:9090/cockpit/socket\")\n        self.assertIn(\"HTTP/1.1 404 Not Found\\r\\n\", headers)\n\n        # external channel handler; unauthenticated, thus 404\n        headers = m.execute(\"curl -s --head http://172.27.0.15:9090/cockpit+123/channel/foo\")\n        self.assertIn(\"HTTP/1.1 404 Not Found\\r\\n\", headers)\n\n    @skipImage(\"ssh root login not allowed\", \"fedora-coreos\")\n    def testFlowControl(self):\n        m = self.machine\n        b = self.browser\n\n        self.login_and_go(\"/playground/speed\", user=\"root\")\n\n        # Check the speed playground page\n        b.switch_to_top()\n        b.go(\"/playground/speed\")\n        b.enter_page(\"/playground/speed\")\n\n        b.wait_text_not(\"#pid\", \"\")\n        pid = b.text(\"#pid\")\n\n        b.set_val(\"#read-path\", \"/dev/vda\")\n        b.click(\"#read-sideband\")\n\n        b.wait_text_not(\"#speed\", \"\")\n        time.sleep(20)\n        output = m.execute(\"cat /proc/{}/statm\".format(pid))\n        rss = int(output.split(\" \")[0])\n\n        # This fails when flow control is not present\n        self.assertLess(rss, 250000)\n\n    @skipImage(\"OSTree doesn't have cockpit-ws\", \"fedora-coreos\")\n    def testLocalSession(self):\n        m = self.machine\n\n        # start ws with --local-session, let it spawn bridge; ensure that this works without /etc/cockpit/\n        m.spawn(\"su - -c 'G_MESSAGES_DEBUG=all XDG_CONFIG_DIRS=/usr/local %s -p 9999 -a 127.0.0.90 \"\n                \"--local-session=cockpit-bridge' admin\" % self.ws_executable,\n                \"cockpit-ws-local\")\n        m.wait_for_cockpit_running('127.0.0.90', 9999)\n        # System frame should work directly, no login page\n        out = m.execute(\"curl --compressed http://127.0.0.90:9999/cockpit/@localhost/system/index.html\")\n        self.assertIn('id=\"overview\"', out)\n\n        # shut it down, wait until it is gone\n        m.execute(\"pkill -ef cockpit-ws\")\n\n        # start ws with --local-session and existing running bridge\n        script = '''#!/bin/bash -eu\ncoproc env G_MESSAGES_DEBUG=all cockpit-bridge\nG_MESSAGES_DEBUG=all XDG_CONFIG_DIRS=/usr/local %s -p 9999 -a 127.0.0.90 --local-session=- <&${COPROC[0]} >&${COPROC[1]}\n''' % self.ws_executable\n        m.execute([\"tee\", \"/tmp/local.sh\"], input=script)\n        m.execute(\"chmod a+x /tmp/local.sh\")\n        m.spawn(\"su - -c /tmp/local.sh admin\", \"local.sh\")\n        m.wait_for_cockpit_running('127.0.0.90', 9999)\n\n        # System frame should work directly, no login page\n        out = m.execute(\"curl --compressed http://127.0.0.90:9999/cockpit/@localhost/system/index.html\")\n        self.assertIn('id=\"overview\"', out)\n\n        self.allow_journal_messages(\"couldn't register polkit authentication agent.*\")\n\n    @skipImage(\"OSTree doesn't have cockpit-ws\", \"fedora-coreos\")\n    @skipImage(\"Kernel does not allow user namespaces\", \"debian-stable\", \"debian-testing\")\n    def testCockpitDesktop(self):\n        m = self.machine\n\n        cases = [(['/cockpit/@localhost/system/index.html', 'system', 'system/index', 'system/'],\n                  ['id=\"overview\"']\n                  ),\n                 (['/cockpit/@localhost/network/firewall.html', 'network/firewall'],\n                  ['div id=\"firewall\"', 'script src=\"firewall.js\"']\n                  ),\n                 (['/cockpit/@localhost/playground/react-patterns.html', 'playground/react-patterns'],\n                  ['script src=\"react-patterns.js\"']\n                  ),\n                 # no ssh host\n                 (['/cockpit/@localhost/manifests.json'],\n                  ['\"system\"', '\"Overview\"']\n                  ),\n                 # remote ssh host\n                 (['/cockpit/@localhost/manifests.json test1@localhost'],\n                  ['\"system\"', '\"Overview\"', '\"HACK\"']\n                  )\n                 ]\n\n        # prepare fake ssh target; to verify that we really use that, fake dashboard manifest\n        m.execute(\"\"\"set -e; useradd test1\n                  [ -f ~admin/.ssh/id_rsa ] || su -c \"ssh-keygen -t rsa -N '' -f ~/.ssh/id_rsa\" admin\n                  mkdir -p ~test1/.ssh ~test1/.local/share/cockpit/dashboard\n                  echo '{ \"version\": \"42\", \"dashboard\": { \"index\": { \"label\": \"HACK\" } } }' > ~test1/.local/share/cockpit/dashboard/manifest.json\n                  cp ~admin/.ssh/id_rsa.pub ~test1/.ssh/authorized_keys\n                  ssh-keyscan localhost >> ~admin/.ssh/known_hosts\n                  chown admin:admin ~admin/.ssh/known_hosts\n                  chown -R test1:test1 ~test1\n                  su -c \"ssh test1@localhost cockpit-bridge --packages\" admin | grep -q test1.*dashboard  # validate setup\n                  \"\"\")\n\n        for (pages, asserts) in cases:\n            for page in pages:\n                m.execute(f'''su - -c 'BROWSER=\"curl --silent --compressed -o /tmp/out.html\" {self.libexecdir}/cockpit-desktop {page}' admin''')\n\n                out = m.execute(\"cat /tmp/out.html\")\n                for a in asserts:\n                    self.assertIn(a, out)\n\n                # should clean up processes\n                self.assertEqual(m.execute(\"! pgrep -a cockpit-ws && ! pgrep -a cockpit-bridge\"), \"\")\n\n        # cockpit-desktop can start a privileged bridge through polkit\n        # we don't have an agent, so just allow the privilege without interactive authentication\n        m.write(\"/etc/polkit-1/localauthority/50-local.d/test.pkla\", r\"\"\"\n[Testing without an agent]\nIdentity=unix-user:admin\nAction=org.cockpit-project.cockpit.root-bridge\nResultAny=yes\nResultInactive=yes\nResultActive=yes\"\"\")\n        m.write(r\"/tmp/browser.sh\", \"\"\"#!/bin/sh -e\ncurl --silent --compressed -o /tmp/out.html \"$@\"\n# wait until privileged bridge starts\nuntil pgrep -f cockpit-bridge.*--privileged; do sleep 1; done\n\"\"\")\n        m.execute(\"chmod 755 /tmp/browser.sh\")\n        m.execute(f\"su - -c 'BROWSER=/tmp/browser.sh {self.libexecdir}/cockpit-desktop system' admin\")\n        self.assertIn('id=\"overview\"', m.execute(\"cat /tmp/out.html\"))\n\n        self.allow_journal_messages(\"couldn't register polkit authentication agent.*\")\n        self.allow_journal_messages(\"Refusing to render service to dead parents.\")\n        self.allow_journal_messages(\".*No authentication agent found.*\")\n        self.allow_journal_messages(\".*Peer failed to perform TLS handshake.*\")\n        self.allow_journal_messages(r\".*cannot reauthorize identity\\(s\\): unix-user:.*\")\n\n    @skipBrowser(\"Firefox needs proper cert and CA\", \"firefox\")\n    def testReverseProxy(self):\n        m = self.machine\n        b = self.browser\n\n        self.ostree_setup_ws()\n\n        # set up a poor man's reverse TLS proxy with socat\n        m.upload([\"../src/bridge/mock-server.crt\", \"../src/bridge/mock-server.key\"], \"/tmp\")\n        m.spawn(\"socat OPENSSL-LISTEN:9090,reuseaddr,fork,cert=/tmp/mock-server.crt,\"\n                \"key=/tmp/mock-server.key,verify=0 TCP:localhost:9099\",\n                \"socat-tls.log\")\n\n        # and another proxy for plain http\n        m.spawn(\"socat TCP-LISTEN:9091,reuseaddr,fork TCP:localhost:9099\", \"socat.log\")\n\n        # ws with plain --no-tls should fail after login with mismatching Origin (expected http, got https)\n        m.spawn(\"su -s /bin/sh -c '%s --no-tls -p 9099' cockpit-wsinstance\" % self.ws_executable,\n                \"ws-notls.log\")\n        m.wait_for_cockpit_running(tls=True)\n\n        b.ignore_ssl_certificate_errors(True)\n        b.open(\"https://%s:%s/system\" % (b.address, b.port))\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load()\n\n        def check_wss_log():\n            for log in self.browser.get_js_log():\n                if 'Error during WebSocket handshake: Unexpected response code: 403' in log:\n                    return True\n            return False\n        wait(check_wss_log)\n\n        wait(lambda: m.execute(\"grep 'received request from bad Origin' /var/log/ws-notls.log\"))\n\n        # sanity check: unencrypted http through SSL proxy does not work\n        m.execute(\"! curl http://localhost:9090\")\n\n        # does not redirect to https (through plain http proxy)\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9091\"))\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://172.27.0.15:9091\"))\n\n        m.execute(\"pkill -e cockpit-ws; while pgrep -a cockpit-ws; do sleep 1; done\")\n        # this page failure is reeally noisy\n        self.allow_restart_journal_messages()\n        self.allow_journal_messages(\".*No authentication agent found.*\")\n        self.allow_journal_messages(\"couldn't register polkit authentication agent.*\")\n        self.allow_journal_messages(\"received request from bad Origin.*\")\n        self.allow_journal_messages(\".*invalid handshake.*\")\n        self.allow_browser_errors(\".*received unsupported version in init message.*\")\n        self.allow_browser_errors(\".*received message before init.*\")\n        self.allow_browser_errors(\"Error reading machine id\")\n\n        # ws with --for-tls-proxy accepts only https origins, thus should work\n        m.spawn(\"su -s /bin/sh -c '%s --for-tls-proxy -p 9099 -a 127.0.0.1' cockpit-wsinstance\" % self.ws_executable,\n                \"ws-fortlsproxy.log\")\n        m.wait_for_cockpit_running(tls=True)\n        b.open(\"https://%s:%s/system\" % (b.address, b.port))\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load()\n        b.wait_visible('#content')\n        b.enter_page(\"/system\")\n        # cookie should be marked as secure, as for the browser it's https\n        cookie = b.cookie(\"cockpit\")\n        self.assertTrue(cookie[\"httpOnly\"])\n        self.assertTrue(cookie[\"secure\"])\n        b.logout()\n        # deleted cookie after logout should be marked as secure\n        cookie = b.cookie(\"cockpit\")\n        self.assertEqual(cookie[\"value\"], \"deleted\")\n        self.assertTrue(cookie[\"httpOnly\"])\n        self.assertTrue(cookie[\"secure\"])\n\n        # should have https:// URLs in Content-Security-Policy\n        out = m.execute(\"curl --insecure --head https://localhost:9090/\")\n        self.assertIn(\"Content-Security-Policy: connect-src 'self' https://localhost:9090 wss://localhost:9090;\", out)\n\n        # sanity check: does not redirect to https (through plain http proxy) -- this isn't a supported mode, though!\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9091\"))\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://172.27.0.15:9091\"))\n\n        # ws with --proxy-tls-redirect redirects non-localhost to https\n        m.execute(\"pkill -e cockpit-ws; while pgrep -a cockpit-ws; do sleep 1; done\")\n        m.spawn(\"su -s /bin/sh -c '%s --proxy-tls-redirect --no-tls -p 9099 -a 127.0.0.1' cockpit-wsinstance\" % self.ws_executable,\n                \"ws-proxy-tls-redirect.log\")\n        m.wait_for_cockpit_running(tls=True)\n        self.assertIn(\"HTTP/1.1 301 Moved Permanently\", m.execute(\"curl --silent --head http://172.27.0.15:9091\"))\n        self.assertIn(\"HTTP/1.1 200 OK\", m.execute(\"curl --silent --head http://127.0.0.1:9091\"))\n\n    def testCaCert(self):\n        m = self.machine\n\n        m.start_cockpit()\n        if not m.ostree_image:\n            # Really start Cockpit to make sure it has generated all its certificates.\n            m.execute(\"systemctl start cockpit\")\n\n        # Start without a CA certificate.\n        m.execute(\"rm -f /etc/cockpit/ws-certs.d/0-self-signed-ca.pem\")\n        m.execute(\"! curl -sfS http://localhost:9090/ca.cer\")\n\n        # Now make one up and check that is is served.\n        m.write(\"/etc/cockpit/ws-certs.d/0-self-signed-ca.pem\", \"FAKE CERT FOR TESTING\\n\")\n        self.assertEqual(m.execute(\"curl -sfS http://localhost:9090/ca.cer\"), \"FAKE CERT FOR TESTING\\n\")\n\n\n@skipDistroPackage()\nclass TestReverseProxy(MachineCase):\n\n    provision = {\n        \"0\": {\"forward\": {\"443\": 8443}}\n    }\n\n    def setUp(self):\n        super().setUp()\n        m = self.machine\n\n        m.execute(\"if firewall-cmd --state >/dev/null 2>&1; then firewall-cmd --add-service https; fi\")\n\n        m.upload([\"../src/tls/ca/alice.pem\", \"../src/tls/ca/alice.key\"], \"/etc/pki\")\n\n        m.write(\"/etc/cockpit/cockpit.conf\", \"\"\"[WebService]\nOrigins = https://%(origin)s wss://%(origin)s\nProtocolHeader = X-Forwarded-Proto\n\"\"\" % {\"origin\": m.forward[\"443\"]}, append=True)\n\n        m.execute(\"setsebool -P httpd_can_network_connect on\")\n        self.allow_journal_messages(\"audit.*bool=httpd_can_network_connect.*val=1.*\")\n\n    def checkCockpitOnProxy(self, urlroot=\"\"):\n        b = self.browser\n\n        # should use nginx' certificate, not cockpit's; use --resolve so that SNI matches the certificate's CN\n        (https_host, https_port) = self.machine.forward[\"443\"].split(':')\n        out = subprocess.check_output(\n            [\"curl\", \"--verbose\", \"--head\",\n             \"--resolve\", f\"alice:{https_port}:{https_host}\",\n             \"--cacert\", os.path.join(TEST_DIR, \"../src/tls/ca/ca.pem\"),\n             f\"https://alice:{https_port}{urlroot}/cockpit/static/login.html\"],\n            stderr=subprocess.STDOUT)\n        self.assertIn(b\"HTTP/1.1 200 OK\", out)\n        self.assertIn(b\"subject: CN=alice; DC=COCKPIT\", out)\n\n        # works with browser (but we can't set our CA)\n        b.ignore_ssl_certificate_errors(True)\n        b.open(f\"https://{https_host}:{https_port}{urlroot}/system\")\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load()\n        b.wait_visible('#content')\n        b.logout()\n\n        self.allow_restart_journal_messages()\n\n    @skipImage(\"nginx not installed\", \"centos-8-stream\", \"debian-stable\", \"debian-testing\", \"fedora-coreos\",\n               \"rhel-8-4\", \"rhel-8-5\", \"rhel-9-0\", \"ubuntu-stable\", \"ubuntu-2004\")\n    @skipBrowser(\"Firefox needs proper cert and CA\", \"firefox\")\n    def testNginxTLS(self):\n        '''test proxying to Cockpit with TLS\n\n        As described on https://github.com/cockpit-project/cockpit/wiki/Proxying-Cockpit-over-NGINX\n        This use use case is important for proxying a remote machine.\n        '''\n        m = self.machine\n\n        m.write(\"/etc/nginx/conf.d/cockpit.conf\", \"\"\"\nserver {\n    listen 443 ssl;\n    server_name %(origin)s;\n    root /srv/www;\n\n    ssl_certificate \"/etc/pki/alice.pem\";\n    ssl_certificate_key \"/etc/pki/alice.key\";\n\n    location / {\n        # Required to proxy the connection to Cockpit\n        proxy_pass https://127.0.0.1:9090;\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # Required for web sockets to function\n        proxy_http_version 1.1;\n        proxy_buffering off;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n\n        # Pass ETag header from Cockpit to clients.\n        # See: https://github.com/cockpit-project/cockpit/issues/5239\n        gzip off;\n    }\n}\n\"\"\" % {\"origin\": m.forward[\"443\"]})\n\n        m.execute(\"systemctl start nginx\")\n        m.start_cockpit(tls=True)\n        self.checkCockpitOnProxy()\n\n        # now test with UrlRoot\n        m.write(\"/etc/cockpit/cockpit.conf\", \"UrlRoot = cockpit-root\\n\", append=True)\n        m.execute(\"systemctl stop cockpit.service\")\n        self.sed_file(\"s_location /_location /cockpit-root_\", \"/etc/nginx/conf.d/cockpit.conf\",\n                      \"systemctl restart nginx\")\n        self.checkCockpitOnProxy(urlroot=\"/cockpit-root\")\n\n        # get a non-cockpit file from the server\n        m.execute(\"mkdir -p /srv/www/embed-cockpit\")\n        m.upload([\"verify/files/embed-cockpit/index.html\",\n                  \"verify/files/embed-cockpit/embed.js\",\n                  \"verify/files/embed-cockpit/embed.css\"],\n                 \"/srv/www/embed-cockpit/\")\n        m.execute(\"if selinuxenabled 2>&1; then chcon -R -t httpd_sys_content_t /srv/www; fi\")\n\n        (https_host, https_port) = self.machine.forward[\"443\"].split(':')\n        out = subprocess.check_output(\n            [\"curl\", \"--verbose\",\n             \"--resolve\", f\"alice:{https_port}:{https_host}\",\n             \"--cacert\", os.path.join(TEST_DIR, \"../src/tls/ca/ca.pem\"),\n             f\"https://alice:{https_port}/embed-cockpit/embed.css\"],\n            stderr=subprocess.STDOUT)\n        self.assertIn(b\"HTTP/1.1 200 OK\", out)\n        self.assertIn(b\"#embed-links\", out)\n\n        # embedding\n        b = self.browser\n        b.ignore_ssl_certificate_errors(True)\n        b.open(f\"https://{https_host}:{https_port}/embed-cockpit/index.html\")\n        b.set_val(\"#embed-address\", f\"https://{https_host}:{https_port}/cockpit-root\")\n        b.click(\"#embed-full\")\n        b.wait_visible(\"iframe[name='embed-full'][loaded]\")\n        b.switch_to_frame(\"embed-full\")\n\n        b.wait_visible(\"#login\")\n        b.set_val(\"#login-user-input\", \"admin\")\n        b.set_val(\"#login-password-input\", \"foobar\")\n        b.click('#login-button')\n        b.expect_load_frame(\"embed-full\")\n        b.wait_visible('article.system-health')\n\n    @skipImage(\"nginx not installed\", \"centos-8-stream\", \"debian-stable\", \"debian-testing\", \"fedora-coreos\",\n               \"rhel-8-4\", \"rhel-8-5\", \"rhel-9-0\", \"ubuntu-stable\", \"ubuntu-2004\")\n    @skipBrowser(\"Firefox needs proper cert and CA\", \"firefox\")\n    def testNginxNoTLS(self):\n        '''test proxying to Cockpit with plain HTTP\n\n        This can be done when nginx and cockpit run on the same machine.\n        '''\n        m = self.machine\n\n        m.write(\"/etc/nginx/conf.d/cockpit.conf\", \"\"\"\nserver {\n    listen 443 ssl;\n    server_name %(origin)s;\n\n    ssl_certificate \"/etc/pki/alice.pem\";\n    ssl_certificate_key \"/etc/pki/alice.key\";\n\n    location / {\n        # Required to proxy the connection to Cockpit\n        proxy_pass http://127.0.0.1:9090;\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarded-Proto $scheme;\n\n        # Required for web sockets to function\n        proxy_http_version 1.1;\n        proxy_buffering off;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n\n        # Pass ETag header from Cockpit to clients.\n        # See: https://github.com/cockpit-project/cockpit/issues/5239\n        gzip off;\n    }\n}\n\"\"\" % {\"origin\": m.forward[\"443\"]})\n\n        m.execute(\"systemctl start nginx\")\n\n        # start cockpit-ws in proxy mode, skip all the ws-certs.d/ steps\n        m.spawn(f\"su -s /bin/sh -c '{self.libexecdir}/cockpit-ws --address=127.0.0.1 --for-tls-proxy' cockpit-wsinstance\", \"ws.log\")\n        m.wait_for_cockpit_running()\n\n        self.checkCockpitOnProxy()\n\n        self.allow_journal_messages(\"couldn't register polkit authentication agent.*\")\n\n\nif __name__ == '__main__':\n    test_main()\n", "#! /usr/bin/python3\n\n# This file is part of Cockpit.\n#\n# Copyright (C) 2013 Red Hat, Inc.\n#\n# Cockpit is free software; you can redistribute it and/or modify it\n# under the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation; either version 2.1 of the License, or\n# (at your option) any later version.\n#\n# Cockpit is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.\n\nimport subprocess\n\nimport parent\nfrom testlib import *\n\n\n@skipDistroPackage()\n@nondestructive\nclass TestEmbed(MachineCase):\n\n    def testBasic(self):\n        b = self.browser\n        m = self.machine\n\n        self.restore_dir(\"/home/admin/.local/share/cockpit\")\n        m.execute(\"mkdir -p /home/admin/.local/share/cockpit/embed-cockpit\")\n        m.upload([\"verify/files/embed-cockpit/index.html\",\n                  \"verify/files/embed-cockpit/embed.js\",\n                  \"verify/files/embed-cockpit/embed.css\",\n                  \"verify/files/embed-cockpit/manifest.json\"],\n                 \"/home/admin/.local/share/cockpit/embed-cockpit/\")\n\n        # replace the shell with our embedded page, this way we can avoid\n        # cross-origin errors when executing js in the iframe\n        m.write(\"/etc/cockpit/cockpit.conf\", \"\"\"\n[WebService]\nShell=/embed-cockpit/index.html\n\"\"\")\n        m.start_cockpit()\n        self.login_and_go()\n\n        b.wait_visible(\"#embed-loaded\")\n        b.wait_visible(\"#embed-address\")\n        m.write(\"/etc/cockpit/cockpit.conf\", \"\"\"\n[WebService]\nShell=/shell/index.html\n\"\"\")\n        b.set_val(\"#embed-address\", \"http://{0}:{1}\".format(m.web_address, m.web_port))\n        b.click(\"#embed-full\")\n        b.wait_visible(\"iframe[name='embed-full'][loaded]\")\n        b.switch_to_frame(\"embed-full\")\n        b.wait_visible(\"#system_information_os_text\")\n\n        # Page should show automatically now that other frame logged in\n        b.switch_to_top()\n        b.click(\"#embed-terminal\")\n        b.wait_visible(\"iframe[name='embed-terminal'][loaded]\")\n        b.switch_to_frame(\"embed-terminal\")\n        b.wait_visible(\"#terminal\")\n\n        # Clicking on the link with separate auth, shouldn't log in automatically\n        b.switch_to_top()\n        b.click(\"#embed-auth\")\n        b.wait_visible(\"iframe[name='embed-auth'][loaded]\")\n        b.switch_to_frame(\"embed-auth\")\n        b.wait_visible(\"#login-user-input\")\n\n    @skipBrowser(\"Chromium cannot inspect cross-origin frames\", \"chromium\")\n    def testCrossOrigin(self):\n        b = self.browser\n        m = self.machine\n\n        pyhttpd = subprocess.Popen(['python3', '-m', 'http.server', '--bind=localhost',\n                                    '--directory=test/verify/files/embed-cockpit', '12346'])\n\n        def clean_pyhttpd():\n            pyhttpd.terminate()\n            pyhttpd.wait()\n\n        self.addCleanup(clean_pyhttpd)\n\n        # log in normally, to get the auth cookie into the browser and thus maximize possible cross-domain exposure\n        self.login_and_go()\n\n        b.open(\"http://localhost:12346/index.html\")\n        b.set_val(\"#embed-address\", \"http://{0}:{1}\".format(m.web_address, m.web_port))\n        b.click(\"#embed-full\")\n        b.wait_visible(\"iframe[name='embed-full'][loaded]\")\n        b.switch_to_frame(\"embed-full\")\n\n        # X-Frame-Options sameorigin blocks frame\n        if b.cdp.browser == \"firefox\":\n            b.wait_visible(\"body.neterror\")\n        self.assertFalse(b.is_present(\"#login\"))\n\n\nif __name__ == '__main__':\n    test_main()\n"], "filenames": ["doc/guide/embedding.xml", "pkg/base1/test-http.js", "src/bridge/test-httpstream.c", "src/bridge/test-packages.c", "src/common/cockpitwebresponse.c", "src/common/test-webresponse.c", "src/ws/test-channelresponse.c", "test/verify/check-connection", "test/verify/check-embed"], "buggy_code_start_loc": [8, 210, 37, 50, 749, 38, 56, 414, 97], "buggy_code_end_loc": [9, 252, 38, 51, 902, 39, 57, 629, 111], "fixing_code_start_loc": [8, 211, 37, 50, 750, 38, 56, 414, 96], "fixing_code_end_loc": [11, 255, 38, 51, 909, 39, 57, 632, 104], "type": "CWE-1021", "message": "Cockpit (and its plugins) do not seem to protect itself against clickjacking. It is possible to render a page from a cockpit server via another website, inside an <iFrame> HTML entry. This may be used by a malicious website in clickjacking or similar attacks.", "other": {"cve": {"id": "CVE-2021-3660", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-10T17:42:55.647", "lastModified": "2023-02-12T23:42:07.917", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Cockpit (and its plugins) do not seem to protect itself against clickjacking. It is possible to render a page from a cockpit server via another website, inside an <iFrame> HTML entry. This may be used by a malicious website in clickjacking or similar attacks."}, {"lang": "es", "value": "Cockpit (y sus plugins) no parecen protegerse contra un ataque de clickjacking. Es posible renderizar una p\u00e1gina de un servidor de Cockpit por medio de otro sitio web, dentro de una entrada HTML (iFrame). Esto puede ser usado por un sitio web malicioso en ataques de clickjacking o similares"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1021"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1021"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cockpit-project:cockpit:*:*:*:*:*:*:*:*", "versionEndExcluding": "254", "matchCriteriaId": "24AF3BAD-6273-447B-ACC7-9705C2C198DC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1980688", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/cockpit-project/cockpit/commit/8d9bc10d8128aae03dfde62fd00075fe492ead10", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cockpit-project/cockpit/issues/16122", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cockpit-project/cockpit/commit/8d9bc10d8128aae03dfde62fd00075fe492ead10"}}