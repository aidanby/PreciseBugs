{"buggy_code": ["// imagew-jpeg.c\n// Part of ImageWorsener, Copyright (c) 2011 by Jason Summers.\n// For more information, see the readme.txt file.\n\n#include \"imagew-config.h\"\n\n#if IW_SUPPORT_JPEG == 1\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <setjmp.h>\n\n#include <jpeglib.h>\n#include <jerror.h>\n\n#define IW_INCLUDE_UTIL_FUNCTIONS\n#include \"imagew.h\"\n\n#if BITS_IN_JSAMPLE != 8\n#error \"Wrong JSAMPLE size\"\n#endif\n\nstruct my_error_mgr {\n\tstruct jpeg_error_mgr pub;\n\tjmp_buf setjmp_buffer;\n};\n\nstatic void my_error_exit(j_common_ptr cinfo)\n{\n\tstruct my_error_mgr* myerr = (struct my_error_mgr*)cinfo->err;\n\tlongjmp(myerr->setjmp_buffer, 1);\n}\n\n// If we don't make our own output_message function, libjpeg will\n// print warnings to stderr.\nstatic void my_output_message(j_common_ptr cinfo)\n{\n\treturn;\n}\n\nstruct iwjpegrcontext {\n\tstruct jpeg_source_mgr pub; // This field must be first.\n\tstruct iw_context *ctx;\n\tstruct iw_iodescr *iodescr;\n\tJOCTET *buffer;\n\tsize_t buffer_len;\n\tint is_jfif;\n\tunsigned int exif_orientation; // 0 means not set\n\tdouble exif_density_x, exif_density_y; // -1.0 means not set.\n\tunsigned int exif_density_unit; // 0 means not set\n};\n\nstruct iw_exif_state {\n\tint endian;\n\tconst iw_byte *d;\n\tsize_t d_len;\n};\n\n// Try to read an Exif tag into an integer.\n// Returns zero on failure.\nstatic int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tunsigned int *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\n\tif(value_count!=1) return 0;\n\n\tif(field_type==3) { // SHORT (uint16)\n\t\t*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\telse if(field_type==4) { // LONG (uint32)\n\t\t*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n// Read an Exif tag into a double.\n// This only supports the case where the tag contains exactly one Rational value.\nstatic int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tdouble *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tunsigned int value_pos;\n\tunsigned int numer, denom;\n\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\n\tif(value_count!=1) return 0;\n\n\tif(field_type!=5) return 0; // 5=Rational (two uint32's)\n\n\t// A rational is 8 bytes. Since 8>4, it is stored indirectly. First, read\n\t// the location where it is stored.\n\n\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\tif(value_pos > e->d_len-8) return 0;\n\n\t// Read the actual value.\n\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n\tif(denom==0) return 0;\n\n\t*pv = ((double)numer)/denom;\n\treturn 1;\n}\n\nstatic void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n\tstruct iw_exif_state *e, iw_uint32 ifd)\n{\n\tunsigned int tag_count;\n\tunsigned int i;\n\tunsigned int tag_pos;\n\tunsigned int tag_id;\n\tunsigned int v;\n\tdouble v_dbl;\n\n\tif(ifd<8 || ifd>e->d_len-18) return;\n\n\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n\tif(tag_count>1000) return; // Sanity check.\n\n\tfor(i=0;i<tag_count;i++) {\n\t\ttag_pos = ifd+2+i*12;\n\t\tif(tag_pos+12 > e->d_len) return; // Avoid overruns.\n\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n\n\t\tswitch(tag_id) {\n\t\tcase 274: // 274 = Orientation\n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_orientation = v;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 296: // 296 = ResolutionUnit\n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_density_unit = v;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 282: // 282 = XResolution\n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_x = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 283: // 283 = YResolution\n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_y = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n\t\tconst iw_byte *d, size_t d_len)\n{\n\tstruct iw_exif_state e;\n\tiw_uint32 ifd;\n\n\tif(d_len<8) return;\n\n\tiw_zeromem(&e,sizeof(struct iw_exif_state));\n\te.d = d;\n\te.d_len = d_len;\n\n\te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n\n\tifd = iw_get_ui32_e(&d[4],e.endian);\n\n\tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n}\n\n// Look at the saved JPEG markers.\n// The only one we care about is Exif.\nstatic void iwjpeg_read_saved_markers(struct iwjpegrcontext *rctx,\n\tstruct jpeg_decompress_struct *cinfo)\n{\n\tstruct jpeg_marker_struct *mk;\n\tconst iw_byte *d;\n\n\tmk = cinfo->marker_list;\n\n\t// Walk the list of saved markers.\n\twhile(mk) {\n\t\td = (const iw_byte*)mk->data;\n\n\t\tif(mk->marker==0xe1) {\n\t\t\tif(mk->data_length>=6 && d[0]=='E' && d[1]=='x' &&\n\t\t\t\td[2]=='i' && d[3]=='f' && d[4]==0)\n\t\t\t{\n\t\t\t\t// I don't know what the d[5] byte is for, but Exif\n\t\t\t\t// data always starts with d[6].\n\t\t\t\tiwjpeg_scan_exif(rctx, &d[6], mk->data_length-6);\n\t\t\t}\n\t\t}\n\n\t\tmk = mk->next;\n\t}\n}\n\nstatic void iwjpeg_read_density(struct iw_context *ctx, struct iw_image *img,\n\tstruct jpeg_decompress_struct *cinfo)\n{\n\tswitch(cinfo->density_unit) {\n\tcase 1: // pixels/inch\n\t\timg->density_x = ((double)cinfo->X_density)/0.0254;\n\t\timg->density_y = ((double)cinfo->Y_density)/0.0254;\n\t\timg->density_code = IW_DENSITY_UNITS_PER_METER;\n\t\tbreak;\n\tcase 2: // pixels/cm\n\t\timg->density_x = ((double)cinfo->X_density)*100.0;\n\t\timg->density_y = ((double)cinfo->Y_density)*100.0;\n\t\timg->density_code = IW_DENSITY_UNITS_PER_METER;\n\t\tbreak;\n\tdefault: // unknown units\n\t\t// If we have square pixels with unknown units, we might be looking at\n\t\t// libjpeg's default (i.e. no JFIF segment), or the density might have\n\t\t// been read from the file. In either case, leave the density set to\n\t\t// \"unknown\", which allows it to be overridden later by Exif data.\n\t\tif(cinfo->X_density!=cinfo->Y_density) {\n\t\t\timg->density_x = (double)cinfo->X_density;\n\t\t\timg->density_y = (double)cinfo->Y_density;\n\t\t\timg->density_code = IW_DENSITY_UNITS_UNKNOWN;\n\t\t}\n\t}\n}\n\n// Look at the Exif density setting that we may have recorded, and copy\n// it to the image, if appropriate.\nstatic void handle_exif_density(struct iwjpegrcontext *rctx, struct iw_image *img)\n{\n\tif(img->density_code!=IW_DENSITY_UNKNOWN) {\n\t\t// We already have a density, presumably from the JFIF segment.\n\t\t// TODO: In principle, Exif should not be allowed to overrule JFIF.\n\t\t// But Exif density can be more precise than JFIF density, so it might\n\t\t// be better to respect Exif.\n\t\t// (On the other other hand, files with Exif data are usually from\n\t\t// digital cameras, which means the density information is unlikely\n\t\t// to be meaningful anyway.)\n\t\treturn;\n\t}\n\n\tif(rctx->exif_density_x<=0.0 || rctx->exif_density_y<=0.0) return;\n\n\tswitch(rctx->exif_density_unit) {\n\tcase 1: // No units\n\t\tif(fabs(rctx->exif_density_x-rctx->exif_density_y)<0.00001)\n\t\t\treturn; // Square, unitless pixels = no meaningful information.\n\t\timg->density_x = rctx->exif_density_x;\n\t\timg->density_y = rctx->exif_density_y;\n\t\timg->density_code = IW_DENSITY_UNITS_UNKNOWN;\n\t\tbreak;\n\tcase 2: // Inches\n\t\timg->density_x = rctx->exif_density_x/0.0254;\n\t\timg->density_y = rctx->exif_density_y/0.0254;\n\t\timg->density_code = IW_DENSITY_UNITS_PER_METER;\n\t\tbreak;\n\tcase 3: // Centimeters\n\t\timg->density_x = rctx->exif_density_x*100.0;\n\t\timg->density_y = rctx->exif_density_y*100.0;\n\t\timg->density_code = IW_DENSITY_UNITS_PER_METER;\n\t\tbreak;\n\t}\n}\n\nstatic void my_init_source_fn(j_decompress_ptr cinfo)\n{\n\tstruct iwjpegrcontext *rctx = (struct iwjpegrcontext*)cinfo->src;\n\trctx->pub.next_input_byte = rctx->buffer;\n\trctx->pub.bytes_in_buffer = 0;\n}\n\nstatic boolean my_fill_input_buffer_fn(j_decompress_ptr cinfo)\n{\n\tstruct iwjpegrcontext *rctx = (struct iwjpegrcontext*)cinfo->src;\n\tsize_t bytesread = 0;\n\tint ret;\n\n\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\trctx->buffer,rctx->buffer_len,&bytesread);\n\tif(!ret) return FALSE;\n\n\trctx->pub.next_input_byte = rctx->buffer;\n\trctx->pub.bytes_in_buffer = bytesread;\n\n\tif(bytesread<1) return FALSE;\n\treturn TRUE;\n}\n\nstatic void my_skip_input_data_fn(j_decompress_ptr cinfo, long num_bytes)\n{\n\tstruct iwjpegrcontext *rctx = (struct iwjpegrcontext*)cinfo->src;\n\tsize_t bytes_still_to_skip;\n\tsize_t nbytes;\n\tint ret;\n\tsize_t bytesread;\n\n\tif(num_bytes<=0) return;\n\tbytes_still_to_skip = (size_t)num_bytes;\n\n\twhile(bytes_still_to_skip>0) {\n\t\tif(rctx->pub.bytes_in_buffer>0) {\n\t\t\t// There are some bytes in the buffer. Skip up to\n\t\t\t// 'bytes_still_to_skip' of them.\n\t\t\tnbytes = rctx->pub.bytes_in_buffer;\n\t\t\tif(nbytes>bytes_still_to_skip)\n\t\t\t\tnbytes = bytes_still_to_skip;\n\n\t\t\trctx->pub.bytes_in_buffer -= nbytes;\n\t\t\trctx->pub.next_input_byte += nbytes;\n\t\t\tbytes_still_to_skip -= nbytes;\n\t\t}\n\n\t\tif(bytes_still_to_skip<1) return;\n\n\t\t// Need to read from the file (or do a seek, but we currently don't\n\t\t// support seeking).\n\t\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\t\trctx->buffer,rctx->buffer_len,&bytesread);\n\t\tif(!ret) bytesread=0;\n\n\t\trctx->pub.next_input_byte = rctx->buffer;\n\t\trctx->pub.bytes_in_buffer = bytesread;\n\t}\n}\n\nstatic void my_term_source_fn(j_decompress_ptr cinfo)\n{\n}\n\nstatic void convert_cmyk_to_rbg(struct iw_context *ctx, const JSAMPLE *src,\n\tJSAMPLE *dst, int npixels)\n{\n\tint i;\n\tdouble c, m, y, k, r, g, b;\n\n\tfor(i=0;i<npixels;i++) {\n\t\tc = 1.0 - ((double)src[4*i+0])/255.0;\n\t\tm = 1.0 - ((double)src[4*i+1])/255.0;\n\t\ty = 1.0 - ((double)src[4*i+2])/255.0;\n\t\tk = 1.0 - ((double)src[4*i+3])/255.0;\n\t\tr = 1.0 - c*(1.0-k) - k;\n\t\tg = 1.0 - m*(1.0-k) - k;\n\t\tb = 1.0 - y*(1.0-k) - k;\n\t\tif(r<0.0) r=0.0; if(r>1.0) r=1.0;\n\t\tif(g<0.0) g=0.0; if(g>1.0) g=1.0;\n\t\tif(b<0.0) b=0.0; if(b>1.0) b=1.0;\n\t\tdst[3*i+0] = (JSAMPLE)(0.5+255.0*r);\n\t\tdst[3*i+1] = (JSAMPLE)(0.5+255.0*g);\n\t\tdst[3*i+2] = (JSAMPLE)(0.5+255.0*b);\n\t}\n}\n\nIW_IMPL(int) iw_read_jpeg_file(struct iw_context *ctx, struct iw_iodescr *iodescr)\n{\n\tint retval=0;\n\tstruct jpeg_decompress_struct cinfo;\n\tstruct my_error_mgr jerr;\n\tint cinfo_valid=0;\n\tint colorspace;\n\tJDIMENSION rownum;\n\tJSAMPLE *jsamprow;\n\tint numchannels=0;\n\tstruct iw_image img;\n\tstruct iwjpegrcontext rctx;\n\tJSAMPLE *tmprow = NULL;\n\tint cmyk_flag = 0;\n\n\tiw_zeromem(&img,sizeof(struct iw_image));\n\tiw_zeromem(&cinfo,sizeof(struct jpeg_decompress_struct));\n\tiw_zeromem(&jerr,sizeof(struct my_error_mgr));\n\tiw_zeromem(&rctx,sizeof(struct iwjpegrcontext));\n\n\tcinfo.err = jpeg_std_error(&jerr.pub);\n\tjerr.pub.error_exit = my_error_exit;\n\tjerr.pub.output_message = my_output_message;\n\n\tif (setjmp(jerr.setjmp_buffer)) {\n\t\tchar buffer[JMSG_LENGTH_MAX];\n\n\t\t(*cinfo.err->format_message) ((j_common_ptr)&cinfo, buffer);\n\n\t\tiw_set_errorf(ctx,\"libjpeg reports read error: %s\",buffer);\n\n\t\tgoto done;\n\t}\n\n\tjpeg_create_decompress(&cinfo);\n\tcinfo_valid=1;\n\n\t// Set up our custom source manager.\n\trctx.pub.init_source = my_init_source_fn;\n\trctx.pub.fill_input_buffer = my_fill_input_buffer_fn;\n\trctx.pub.skip_input_data = my_skip_input_data_fn;\n\trctx.pub.resync_to_restart = jpeg_resync_to_restart; // libjpeg default\n\trctx.pub.term_source = my_term_source_fn;\n\trctx.ctx = ctx;\n\trctx.iodescr = iodescr;\n\trctx.buffer_len = 32768;\n\trctx.buffer = iw_malloc(ctx, rctx.buffer_len);\n\tif(!rctx.buffer) goto done;\n\trctx.exif_density_x = -1.0;\n\trctx.exif_density_y = -1.0;\n\tcinfo.src = (struct jpeg_source_mgr*)&rctx;\n\n\t// The lazy way. It would be more efficient to use\n\t// jpeg_set_marker_processor(), instead of saving everything to memory.\n\t// But libjpeg's marker processing functions have fairly complex\n\t// requirements.\n\tjpeg_save_markers(&cinfo, 0xe1, 65535);\n\n\tjpeg_read_header(&cinfo, TRUE);\n\n\trctx.is_jfif = cinfo.saw_JFIF_marker;\n\n\tiwjpeg_read_density(ctx,&img,&cinfo);\n\n\tiwjpeg_read_saved_markers(&rctx,&cinfo);\n\n\tjpeg_start_decompress(&cinfo);\n\n\tcolorspace=cinfo.out_color_space;\n\tnumchannels=cinfo.output_components;\n\n\t// libjpeg will automatically convert YCbCr images to RGB, and YCCK images\n\t// to CMYK. That leaves GRAYSCALE, RGB, and CMYK for us to handle.\n\t// Note: cinfo.jpeg_color_space is the colorspace before conversion, and\n\t// cinfo.out_color_space is the colorspace after conversion.\n\n\tif(colorspace==JCS_GRAYSCALE && numchannels==1) {\n\t\timg.imgtype = IW_IMGTYPE_GRAY;\n\t\timg.native_grayscale = 1;\n\t}\n\telse if((colorspace==JCS_RGB) && numchannels==3) {\n\t\timg.imgtype = IW_IMGTYPE_RGB;\n\t}\n\telse if((colorspace==JCS_CMYK) && numchannels==4) {\n\t\timg.imgtype = IW_IMGTYPE_RGB;\n\t\tcmyk_flag = 1;\n\t}\n\telse {\n\t\tiw_set_error(ctx,\"Unsupported type of JPEG\");\n\t\tgoto done;\n\t}\n\n\timg.width = cinfo.output_width;\n\timg.height = cinfo.output_height;\n\tif(!iw_check_image_dimensions(ctx,img.width,img.height)) {\n\t\tgoto done;\n\t}\n\n\timg.bit_depth = 8;\n\timg.bpr = iw_calc_bytesperrow(img.width,img.bit_depth*numchannels);\n\n\timg.pixels = (iw_byte*)iw_malloc_large(ctx, img.bpr, img.height);\n\tif(!img.pixels) {\n\t\tgoto done;\n\t}\n\n\tif(cmyk_flag) {\n\t\ttmprow = iw_malloc(ctx,4*img.width);\n\t\tif(!tmprow) goto done;\n\t}\n\n\twhile(cinfo.output_scanline < cinfo.output_height) {\n\t\trownum=cinfo.output_scanline;\n\t\tjsamprow = &img.pixels[img.bpr * rownum];\n\t\tif(cmyk_flag) {\n\t\t\t// read into tmprow, then convert and copy to img.pixels\n\t\t\tjpeg_read_scanlines(&cinfo, &tmprow, 1);\n\t\t\tconvert_cmyk_to_rbg(ctx,tmprow,jsamprow,img.width);\n\t\t}\n\t\telse {\n\t\t\t// read directly into img.pixels\n\t\t\tjpeg_read_scanlines(&cinfo, &jsamprow, 1);\n\t\t}\n\t\tif(cinfo.output_scanline<=rownum) {\n\t\t\tiw_set_error(ctx,\"Error reading JPEG file\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\tjpeg_finish_decompress(&cinfo);\n\n\thandle_exif_density(&rctx, &img);\n\n\tiw_set_input_image(ctx, &img);\n\t// The contents of img no longer belong to us.\n\timg.pixels = NULL;\n\n\tif(rctx.exif_orientation>=2 && rctx.exif_orientation<=8) {\n\t\tstatic const unsigned int exif_orient_to_transform[9] =\n\t\t   { 0,0, 1,3,2,4,5,7,6 };\n\n\t\t// An Exif marker indicated an unusual image orientation.\n\n\t\tif(rctx.is_jfif) {\n\t\t\t// The presence of a JFIF marker implies a particular orientation.\n\t\t\t// If there's also an Exif marker that says something different,\n\t\t\t// I'm not sure what we're supposed to do.\n\t\t\tiw_warning(ctx,\"JPEG image has an ambiguous orientation\");\n\t\t}\n\t\tiw_reorient_image(ctx,exif_orient_to_transform[rctx.exif_orientation]);\n\t}\n\n\tretval=1;\n\ndone:\n\tiw_free(ctx, img.pixels);\n\tif(cinfo_valid) jpeg_destroy_decompress(&cinfo);\n\tif(rctx.buffer) iw_free(ctx,rctx.buffer);\n\tif(tmprow) iw_free(ctx,tmprow);\n\treturn retval;\n}\n\n////////////////////////////////////\n\nstruct iwjpegwcontext {\n\tstruct jpeg_destination_mgr pub; // This field must be first.\n\tstruct iw_context *ctx;\n\tstruct iw_iodescr *iodescr;\n\tJOCTET *buffer;\n\tsize_t buffer_len;\n};\n\nstatic void iwjpg_set_density(struct iw_context *ctx,struct jpeg_compress_struct *cinfo,\n\tconst struct iw_image *img)\n{\n\tint pref_units;\n\n\tif(img->density_code==IW_DENSITY_UNITS_UNKNOWN) {\n\t\tcinfo->density_unit=0; // unknown units\n\t\tcinfo->X_density = (UINT16)(0.5+img->density_x);\n\t\tcinfo->Y_density = (UINT16)(0.5+img->density_y);\n\t}\n\telse if(img->density_code==IW_DENSITY_UNITS_PER_METER) {\n\t\tpref_units = iw_get_value(ctx,IW_VAL_PREF_UNITS);\n\n\t\tif(pref_units==IW_PREF_UNITS_METRIC) {\n\t\t\t// If we think the caller prefers metric, use dots/cm.\n\t\t\tcinfo->density_unit=2; // dots/cm\n\t\t\tcinfo->X_density = (UINT16)(0.5+ img->density_x*0.01);\n\t\t\tcinfo->Y_density = (UINT16)(0.5+ img->density_y*0.01);\n\t\t}\n\t\telse {\n\t\t\t// Otherwise use dpi.\n\t\t\tcinfo->density_unit=1; // dots/inch\n\t\t\tcinfo->X_density = (UINT16)(0.5+ img->density_x*0.0254);\n\t\t\tcinfo->Y_density = (UINT16)(0.5+ img->density_y*0.0254);\n\t\t}\n\t}\n}\n\nstatic void my_init_destination_fn(j_compress_ptr cinfo)\n{\n\tstruct iwjpegwcontext *wctx = (struct iwjpegwcontext*)cinfo->dest;\n\n\t// Configure the destination manager to use our buffer.\n\twctx->pub.next_output_byte = wctx->buffer;\n\twctx->pub.free_in_buffer = wctx->buffer_len;\n}\n\nstatic boolean my_empty_output_buffer_fn(j_compress_ptr cinfo)\n{\n\tstruct iwjpegwcontext *wctx = (struct iwjpegwcontext*)cinfo->dest;\n\n\t// Write out the entire buffer\n\t(*wctx->iodescr->write_fn)(wctx->ctx,wctx->iodescr,\n\t\twctx->buffer,wctx->buffer_len);\n\t// Change the data pointer and free-space indicator to reflect the\n\t// data we wrote.\n\twctx->pub.next_output_byte = wctx->buffer;\n\twctx->pub.free_in_buffer = wctx->buffer_len;\n\treturn TRUE;\n}\n\nstatic void my_term_destination_fn(j_compress_ptr cinfo)\n{\n\tstruct iwjpegwcontext *wctx = (struct iwjpegwcontext*)cinfo->dest;\n\tsize_t bytesleft;\n\n\tbytesleft = wctx->buffer_len - wctx->pub.free_in_buffer;\n\tif(bytesleft>0) {\n\t\t(*wctx->iodescr->write_fn)(wctx->ctx,wctx->iodescr,\n\t\t\twctx->buffer,bytesleft);\n\t}\n}\n\nIW_IMPL(int) iw_write_jpeg_file(struct iw_context *ctx,  struct iw_iodescr *iodescr)\n{\n\tint retval=0;\n\tstruct jpeg_compress_struct cinfo;\n\tstruct my_error_mgr jerr;\n\tJ_COLOR_SPACE in_colortype; // Color type of the data we give to libjpeg\n\tint jpeg_cmpts;\n\tint compress_created = 0;\n\tint compress_started = 0;\n\tJSAMPROW *row_pointers = NULL;\n\tint is_grayscale;\n\tint j;\n\tstruct iw_image img;\n\tint jpeg_quality;\n\tint samp_factor_h, samp_factor_v;\n\tint disable_subsampling = 0;\n\tstruct iwjpegwcontext wctx;\n\tconst char *optv;\n\tint ret;\n\n\tiw_zeromem(&cinfo,sizeof(struct jpeg_compress_struct));\n\tiw_zeromem(&jerr,sizeof(struct my_error_mgr));\n\tiw_zeromem(&wctx,sizeof(struct iwjpegwcontext));\n\n\tiw_get_output_image(ctx,&img);\n\n\tif(IW_IMGTYPE_HAS_ALPHA(img.imgtype)) {\n\t\tiw_set_error(ctx,\"Internal: Transparency not supported with JPEG output\");\n\t\tgoto done;\n\t}\n\n\tif(img.bit_depth!=8) {\n\t\tiw_set_errorf(ctx,\"Internal: Precision %d not supported with JPEG output\",img.bit_depth);\n\t\tgoto done;\n\t}\n\n\tis_grayscale = IW_IMGTYPE_IS_GRAY(img.imgtype);\n\n\tif(is_grayscale) {\n\t\tin_colortype=JCS_GRAYSCALE;\n\t\tjpeg_cmpts=1;\n\t}\n\telse {\n\t\tin_colortype=JCS_RGB;\n\t\tjpeg_cmpts=3;\n\t}\n\n\tcinfo.err = jpeg_std_error(&jerr.pub);\n\tjerr.pub.error_exit = my_error_exit;\n\n\tif (setjmp(jerr.setjmp_buffer)) {\n\t\tchar buffer[JMSG_LENGTH_MAX];\n\n\t\t(*cinfo.err->format_message) ((j_common_ptr)&cinfo, buffer);\n\n\t\tiw_set_errorf(ctx,\"libjpeg reports write error: %s\",buffer);\n\n\t\tgoto done;\n\t}\n\n\tjpeg_create_compress(&cinfo);\n\tcompress_created=1;\n\n\t// Set up our custom destination manager.\n\twctx.pub.init_destination = my_init_destination_fn;\n\twctx.pub.empty_output_buffer = my_empty_output_buffer_fn;\n\twctx.pub.term_destination = my_term_destination_fn;\n\twctx.ctx = ctx;\n\twctx.iodescr = iodescr;\n\twctx.buffer_len = 32768;\n\twctx.buffer = iw_malloc(ctx,wctx.buffer_len);\n\tif(!wctx.buffer) goto done;\n\t// Our wctx is organized so it can double as a\n\t// 'struct jpeg_destination_mgr'.\n\tcinfo.dest = (struct jpeg_destination_mgr*)&wctx;\n\n\tcinfo.image_width = img.width;\n\tcinfo.image_height = img.height;\n\tcinfo.input_components = jpeg_cmpts;\n\tcinfo.in_color_space = in_colortype;\n\n\tjpeg_set_defaults(&cinfo);\n\n\toptv = iw_get_option(ctx, \"jpeg:block\");\n\tif(optv) {\n#if (JPEG_LIB_VERSION_MAJOR>=9 || \\\n\t(JPEG_LIB_VERSION_MAJOR==8 && JPEG_LIB_VERSION_MINOR>=3))\n\t\t// Note: This might not work if DCT_SCALING_SUPPORTED was not defined when\n\t\t// libjpeg was compiled, but that symbol is not normally exposed to\n\t\t// applications.\n\t\tcinfo.block_size = iw_parse_int(optv);\n#else\n\t\tiw_warning(ctx, \"Setting block size is not supported by this version of libjpeg\");\n#endif\n\t}\n\n\toptv = iw_get_option(ctx, \"jpeg:arith\");\n\tif(optv)\n\t\tcinfo.arith_code = iw_parse_int(optv) ? TRUE : FALSE;\n\telse\n\t\tcinfo.arith_code = FALSE;\n\n\toptv = iw_get_option(ctx, \"jpeg:colortype\");\n\tif(optv) {\n\t\tif(!strcmp(optv, \"rgb\")) {\n\t\t\tif(in_colortype==JCS_RGB) {\n\t\t\t\tjpeg_set_colorspace(&cinfo,JCS_RGB);\n\t\t\t\tdisable_subsampling = 1;\n\t\t\t}\n\t\t}\n\t\telse if(!strcmp(optv, \"rgb1\")) {\n\t\t\tif(in_colortype==JCS_RGB) {\n#if JPEG_LIB_VERSION_MAJOR >= 9\n\t\t\t\tcinfo.color_transform = JCT_SUBTRACT_GREEN;\n#else\n\t\t\t\tiw_warning(ctx, \"Color type rgb1 is not supported by this version of libjpeg\");\n#endif\n\t\t\t\tjpeg_set_colorspace(&cinfo,JCS_RGB);\n\t\t\t\tdisable_subsampling = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\toptv = iw_get_option(ctx, \"jpeg:bgycc\");\n\tif(optv && iw_parse_int(optv)) {\n#if (JPEG_LIB_VERSION_MAJOR>9 || \\\n\t(JPEG_LIB_VERSION_MAJOR==9 && JPEG_LIB_VERSION_MINOR>=1))\n\t\tjpeg_set_colorspace(&cinfo, JCS_BG_YCC);\n#else\n\t\tiw_warning(ctx, \"Big gamut YCC is not supported by this version of libjpeg\");\n#endif\n\t}\n\n\tiwjpg_set_density(ctx,&cinfo,&img);\n\n\toptv = iw_get_option(ctx, \"jpeg:quality\");\n\tif(optv)\n\t\tjpeg_quality = iw_parse_int(optv);\n\telse\n\t\tjpeg_quality = 0;\n\n\tif(jpeg_quality>0) {\n\t\tjpeg_set_quality(&cinfo,jpeg_quality,0);\n\t}\n\n\tif(jpeg_cmpts>1 && !disable_subsampling) {\n\t\tsamp_factor_h = 0;\n\t\tsamp_factor_v = 0;\n\n\t\t// sampling-x and sampling-y are for backward compatibility, and should\n\t\t// not be used.\n\t\toptv = iw_get_option(ctx, \"jpeg:sampling-x\");\n\t\tif(optv)\n\t\t\tsamp_factor_h = iw_parse_int(optv);\n\t\toptv = iw_get_option(ctx, \"jpeg:sampling-y\");\n\t\tif(optv)\n\t\t\tsamp_factor_v = iw_parse_int(optv);\n\n\t\toptv = iw_get_option(ctx, \"jpeg:sampling\");\n\t\tif(optv) {\n\t\t\tdouble tmpsamp[2];\n\t\t\ttmpsamp[0] = 1.0;\n\t\t\ttmpsamp[1] = 1.0;\n\t\t\tret = iw_parse_number_list(optv, 2, tmpsamp);\n\t\t\tsamp_factor_h = iw_round_to_int(tmpsamp[0]);\n\t\t\tif(ret==1) {\n\t\t\t\t// If only one value was given, use it for both factors.\n\t\t\t\tsamp_factor_v = samp_factor_h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsamp_factor_v = iw_round_to_int(tmpsamp[1]);\n\t\t\t}\n\t\t}\n\n\t\tif(samp_factor_h>0) {\n\t\t\tif(samp_factor_h>4) samp_factor_h=4;\n\t\t\tcinfo.comp_info[0].h_samp_factor = samp_factor_h;\n\t\t}\n\t\tif(samp_factor_v>0) {\n\t\t\tif(samp_factor_v>4) samp_factor_v=4;\n\t\t\tcinfo.comp_info[0].v_samp_factor = samp_factor_v;\n\t\t}\n\t}\n\n\tif(iw_get_value(ctx,IW_VAL_OUTPUT_INTERLACED)) {\n\t\tjpeg_simple_progression(&cinfo);\n\t}\n\n\trow_pointers = (JSAMPROW*)iw_malloc(ctx, img.height * sizeof(JSAMPROW));\n\tif(!row_pointers) goto done;\n\n\tfor(j=0;j<img.height;j++) {\n\t\trow_pointers[j] = &img.pixels[j*img.bpr];\n\t}\n\n\tjpeg_start_compress(&cinfo, TRUE);\n\tcompress_started=1;\n\n\tjpeg_write_scanlines(&cinfo, row_pointers, img.height);\n\n\tretval=1;\n\ndone:\n\tif(compress_started)\n\t\tjpeg_finish_compress(&cinfo);\n\n\tif(compress_created)\n\t\tjpeg_destroy_compress(&cinfo);\n\n\tif(row_pointers) iw_free(ctx,row_pointers);\n\n\tif(wctx.buffer) iw_free(ctx,wctx.buffer);\n\n\treturn retval;\n}\n\nIW_IMPL(char*) iw_get_libjpeg_version_string(char *s, int s_len)\n{\n\tstruct jpeg_error_mgr jerr;\n\tconst char *jv;\n\tchar *space_ptr;\n\n\tjpeg_std_error(&jerr);\n\tjv = jerr.jpeg_message_table[JMSG_VERSION];\n\tiw_snprintf(s,s_len,\"%s\",jv);\n\n\t// The version is probably a string like \"8c  16-Jan-2011\", containing\n\t// both the version number and the release date. We only need the version\n\t// number, so chop it off at the first space.\n\tspace_ptr = strchr(s,' ');\n\tif(space_ptr) *space_ptr = '\\0';\n\treturn s;\n}\n\n#endif // IW_SUPPORT_JPEG\n"], "fixing_code": ["// imagew-jpeg.c\n// Part of ImageWorsener, Copyright (c) 2011 by Jason Summers.\n// For more information, see the readme.txt file.\n\n#include \"imagew-config.h\"\n\n#if IW_SUPPORT_JPEG == 1\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <setjmp.h>\n\n#include <jpeglib.h>\n#include <jerror.h>\n\n#define IW_INCLUDE_UTIL_FUNCTIONS\n#include \"imagew.h\"\n\n#if BITS_IN_JSAMPLE != 8\n#error \"Wrong JSAMPLE size\"\n#endif\n\nstruct my_error_mgr {\n\tstruct jpeg_error_mgr pub;\n\tjmp_buf setjmp_buffer;\n};\n\nstatic void my_error_exit(j_common_ptr cinfo)\n{\n\tstruct my_error_mgr* myerr = (struct my_error_mgr*)cinfo->err;\n\tlongjmp(myerr->setjmp_buffer, 1);\n}\n\n// If we don't make our own output_message function, libjpeg will\n// print warnings to stderr.\nstatic void my_output_message(j_common_ptr cinfo)\n{\n\treturn;\n}\n\nstruct iwjpegrcontext {\n\tstruct jpeg_source_mgr pub; // This field must be first.\n\tstruct iw_context *ctx;\n\tstruct iw_iodescr *iodescr;\n\tJOCTET *buffer;\n\tsize_t buffer_len;\n\tint is_jfif;\n\tunsigned int exif_orientation; // 0 means not set\n\tdouble exif_density_x, exif_density_y; // -1.0 means not set.\n\tunsigned int exif_density_unit; // 0 means not set\n};\n\nstruct iw_exif_state {\n\tint endian;\n\tconst iw_byte *d;\n\tsize_t d_len;\n};\n\nstatic unsigned int get_exif_ui16(struct iw_exif_state *e, unsigned int pos)\n{\n\tif(e->d_len<2 || pos>e->d_len-2) return 0;\n\treturn iw_get_ui16_e(&e->d[pos], e->endian);\n}\n\nstatic unsigned int get_exif_ui32(struct iw_exif_state *e, unsigned int pos)\n{\n\tif(e->d_len<4 || pos>e->d_len-4) return 0;\n\treturn iw_get_ui32_e(&e->d[pos], e->endian);\n}\n\n// Try to read an Exif tag into an integer.\n// Returns zero on failure.\nstatic int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tunsigned int *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\n\tfield_type = get_exif_ui16(e, tag_pos+2);\n\tvalue_count = get_exif_ui32(e, tag_pos+4);\n\n\tif(value_count!=1) return 0;\n\n\tif(field_type==3) { // SHORT (uint16)\n\t\t*pv = get_exif_ui16(e, tag_pos+8);\n\t\treturn 1;\n\t}\n\telse if(field_type==4) { // LONG (uint32)\n\t\t*pv = get_exif_ui32(e, tag_pos+8);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n// Read an Exif tag into a double.\n// This only supports the case where the tag contains exactly one Rational value.\nstatic int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tdouble *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tunsigned int value_pos;\n\tunsigned int numer, denom;\n\n\tfield_type = get_exif_ui16(e, tag_pos+2);\n\tvalue_count = get_exif_ui32(e, tag_pos+4);\n\n\tif(value_count!=1) return 0;\n\n\tif(field_type!=5) return 0; // 5=Rational (two uint32's)\n\n\t// A rational is 8 bytes. Since 8>4, it is stored indirectly. First, read\n\t// the location where it is stored.\n\n\tvalue_pos = get_exif_ui32(e, tag_pos+8);\n\tif(value_pos > e->d_len-8) return 0;\n\n\t// Read the actual value.\n\tnumer = get_exif_ui32(e, value_pos);\n\tdenom = get_exif_ui32(e, value_pos+4);\n\tif(denom==0) return 0;\n\n\t*pv = ((double)numer)/denom;\n\treturn 1;\n}\n\nstatic void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n\tstruct iw_exif_state *e, iw_uint32 ifd)\n{\n\tunsigned int tag_count;\n\tunsigned int i;\n\tunsigned int tag_pos;\n\tunsigned int tag_id;\n\tunsigned int v;\n\tdouble v_dbl;\n\n\tif(ifd<8 || e->d_len<18 || ifd>e->d_len-18) return;\n\n\ttag_count = get_exif_ui16(e, ifd);\n\tif(tag_count>1000) return; // Sanity check.\n\n\tfor(i=0;i<tag_count;i++) {\n\t\ttag_pos = ifd+2+i*12;\n\t\tif(tag_pos+12 > e->d_len) return; // Avoid overruns.\n\t\ttag_id = get_exif_ui16(e, tag_pos);\n\n\t\tswitch(tag_id) {\n\t\tcase 274: // 274 = Orientation\n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_orientation = v;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 296: // 296 = ResolutionUnit\n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_density_unit = v;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 282: // 282 = XResolution\n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_x = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 283: // 283 = YResolution\n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_y = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n\t\tconst iw_byte *d, size_t d_len)\n{\n\tstruct iw_exif_state e;\n\tiw_uint32 ifd;\n\n\tif(d_len<8) return;\n\n\tiw_zeromem(&e,sizeof(struct iw_exif_state));\n\te.d = d;\n\te.d_len = d_len;\n\n\te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n\n\tifd = get_exif_ui32(&e, 4);\n\n\tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n}\n\n// Look at the saved JPEG markers.\n// The only one we care about is Exif.\nstatic void iwjpeg_read_saved_markers(struct iwjpegrcontext *rctx,\n\tstruct jpeg_decompress_struct *cinfo)\n{\n\tstruct jpeg_marker_struct *mk;\n\tconst iw_byte *d;\n\n\tmk = cinfo->marker_list;\n\n\t// Walk the list of saved markers.\n\twhile(mk) {\n\t\td = (const iw_byte*)mk->data;\n\n\t\tif(mk->marker==0xe1) {\n\t\t\tif(mk->data_length>=6 && d[0]=='E' && d[1]=='x' &&\n\t\t\t\td[2]=='i' && d[3]=='f' && d[4]==0)\n\t\t\t{\n\t\t\t\t// I don't know what the d[5] byte is for, but Exif\n\t\t\t\t// data always starts with d[6].\n\t\t\t\tiwjpeg_scan_exif(rctx, &d[6], mk->data_length-6);\n\t\t\t}\n\t\t}\n\n\t\tmk = mk->next;\n\t}\n}\n\nstatic void iwjpeg_read_density(struct iw_context *ctx, struct iw_image *img,\n\tstruct jpeg_decompress_struct *cinfo)\n{\n\tswitch(cinfo->density_unit) {\n\tcase 1: // pixels/inch\n\t\timg->density_x = ((double)cinfo->X_density)/0.0254;\n\t\timg->density_y = ((double)cinfo->Y_density)/0.0254;\n\t\timg->density_code = IW_DENSITY_UNITS_PER_METER;\n\t\tbreak;\n\tcase 2: // pixels/cm\n\t\timg->density_x = ((double)cinfo->X_density)*100.0;\n\t\timg->density_y = ((double)cinfo->Y_density)*100.0;\n\t\timg->density_code = IW_DENSITY_UNITS_PER_METER;\n\t\tbreak;\n\tdefault: // unknown units\n\t\t// If we have square pixels with unknown units, we might be looking at\n\t\t// libjpeg's default (i.e. no JFIF segment), or the density might have\n\t\t// been read from the file. In either case, leave the density set to\n\t\t// \"unknown\", which allows it to be overridden later by Exif data.\n\t\tif(cinfo->X_density!=cinfo->Y_density) {\n\t\t\timg->density_x = (double)cinfo->X_density;\n\t\t\timg->density_y = (double)cinfo->Y_density;\n\t\t\timg->density_code = IW_DENSITY_UNITS_UNKNOWN;\n\t\t}\n\t}\n}\n\n// Look at the Exif density setting that we may have recorded, and copy\n// it to the image, if appropriate.\nstatic void handle_exif_density(struct iwjpegrcontext *rctx, struct iw_image *img)\n{\n\tif(img->density_code!=IW_DENSITY_UNKNOWN) {\n\t\t// We already have a density, presumably from the JFIF segment.\n\t\t// TODO: In principle, Exif should not be allowed to overrule JFIF.\n\t\t// But Exif density can be more precise than JFIF density, so it might\n\t\t// be better to respect Exif.\n\t\t// (On the other other hand, files with Exif data are usually from\n\t\t// digital cameras, which means the density information is unlikely\n\t\t// to be meaningful anyway.)\n\t\treturn;\n\t}\n\n\tif(rctx->exif_density_x<=0.0 || rctx->exif_density_y<=0.0) return;\n\n\tswitch(rctx->exif_density_unit) {\n\tcase 1: // No units\n\t\tif(fabs(rctx->exif_density_x-rctx->exif_density_y)<0.00001)\n\t\t\treturn; // Square, unitless pixels = no meaningful information.\n\t\timg->density_x = rctx->exif_density_x;\n\t\timg->density_y = rctx->exif_density_y;\n\t\timg->density_code = IW_DENSITY_UNITS_UNKNOWN;\n\t\tbreak;\n\tcase 2: // Inches\n\t\timg->density_x = rctx->exif_density_x/0.0254;\n\t\timg->density_y = rctx->exif_density_y/0.0254;\n\t\timg->density_code = IW_DENSITY_UNITS_PER_METER;\n\t\tbreak;\n\tcase 3: // Centimeters\n\t\timg->density_x = rctx->exif_density_x*100.0;\n\t\timg->density_y = rctx->exif_density_y*100.0;\n\t\timg->density_code = IW_DENSITY_UNITS_PER_METER;\n\t\tbreak;\n\t}\n}\n\nstatic void my_init_source_fn(j_decompress_ptr cinfo)\n{\n\tstruct iwjpegrcontext *rctx = (struct iwjpegrcontext*)cinfo->src;\n\trctx->pub.next_input_byte = rctx->buffer;\n\trctx->pub.bytes_in_buffer = 0;\n}\n\nstatic boolean my_fill_input_buffer_fn(j_decompress_ptr cinfo)\n{\n\tstruct iwjpegrcontext *rctx = (struct iwjpegrcontext*)cinfo->src;\n\tsize_t bytesread = 0;\n\tint ret;\n\n\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\trctx->buffer,rctx->buffer_len,&bytesread);\n\tif(!ret) return FALSE;\n\n\trctx->pub.next_input_byte = rctx->buffer;\n\trctx->pub.bytes_in_buffer = bytesread;\n\n\tif(bytesread<1) return FALSE;\n\treturn TRUE;\n}\n\nstatic void my_skip_input_data_fn(j_decompress_ptr cinfo, long num_bytes)\n{\n\tstruct iwjpegrcontext *rctx = (struct iwjpegrcontext*)cinfo->src;\n\tsize_t bytes_still_to_skip;\n\tsize_t nbytes;\n\tint ret;\n\tsize_t bytesread;\n\n\tif(num_bytes<=0) return;\n\tbytes_still_to_skip = (size_t)num_bytes;\n\n\twhile(bytes_still_to_skip>0) {\n\t\tif(rctx->pub.bytes_in_buffer>0) {\n\t\t\t// There are some bytes in the buffer. Skip up to\n\t\t\t// 'bytes_still_to_skip' of them.\n\t\t\tnbytes = rctx->pub.bytes_in_buffer;\n\t\t\tif(nbytes>bytes_still_to_skip)\n\t\t\t\tnbytes = bytes_still_to_skip;\n\n\t\t\trctx->pub.bytes_in_buffer -= nbytes;\n\t\t\trctx->pub.next_input_byte += nbytes;\n\t\t\tbytes_still_to_skip -= nbytes;\n\t\t}\n\n\t\tif(bytes_still_to_skip<1) return;\n\n\t\t// Need to read from the file (or do a seek, but we currently don't\n\t\t// support seeking).\n\t\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\t\trctx->buffer,rctx->buffer_len,&bytesread);\n\t\tif(!ret) bytesread=0;\n\n\t\trctx->pub.next_input_byte = rctx->buffer;\n\t\trctx->pub.bytes_in_buffer = bytesread;\n\t}\n}\n\nstatic void my_term_source_fn(j_decompress_ptr cinfo)\n{\n}\n\nstatic void convert_cmyk_to_rbg(struct iw_context *ctx, const JSAMPLE *src,\n\tJSAMPLE *dst, int npixels)\n{\n\tint i;\n\tdouble c, m, y, k, r, g, b;\n\n\tfor(i=0;i<npixels;i++) {\n\t\tc = 1.0 - ((double)src[4*i+0])/255.0;\n\t\tm = 1.0 - ((double)src[4*i+1])/255.0;\n\t\ty = 1.0 - ((double)src[4*i+2])/255.0;\n\t\tk = 1.0 - ((double)src[4*i+3])/255.0;\n\t\tr = 1.0 - c*(1.0-k) - k;\n\t\tg = 1.0 - m*(1.0-k) - k;\n\t\tb = 1.0 - y*(1.0-k) - k;\n\t\tif(r<0.0) r=0.0; if(r>1.0) r=1.0;\n\t\tif(g<0.0) g=0.0; if(g>1.0) g=1.0;\n\t\tif(b<0.0) b=0.0; if(b>1.0) b=1.0;\n\t\tdst[3*i+0] = (JSAMPLE)(0.5+255.0*r);\n\t\tdst[3*i+1] = (JSAMPLE)(0.5+255.0*g);\n\t\tdst[3*i+2] = (JSAMPLE)(0.5+255.0*b);\n\t}\n}\n\nIW_IMPL(int) iw_read_jpeg_file(struct iw_context *ctx, struct iw_iodescr *iodescr)\n{\n\tint retval=0;\n\tstruct jpeg_decompress_struct cinfo;\n\tstruct my_error_mgr jerr;\n\tint cinfo_valid=0;\n\tint colorspace;\n\tJDIMENSION rownum;\n\tJSAMPLE *jsamprow;\n\tint numchannels=0;\n\tstruct iw_image img;\n\tstruct iwjpegrcontext rctx;\n\tJSAMPLE *tmprow = NULL;\n\tint cmyk_flag = 0;\n\n\tiw_zeromem(&img,sizeof(struct iw_image));\n\tiw_zeromem(&cinfo,sizeof(struct jpeg_decompress_struct));\n\tiw_zeromem(&jerr,sizeof(struct my_error_mgr));\n\tiw_zeromem(&rctx,sizeof(struct iwjpegrcontext));\n\n\tcinfo.err = jpeg_std_error(&jerr.pub);\n\tjerr.pub.error_exit = my_error_exit;\n\tjerr.pub.output_message = my_output_message;\n\n\tif (setjmp(jerr.setjmp_buffer)) {\n\t\tchar buffer[JMSG_LENGTH_MAX];\n\n\t\t(*cinfo.err->format_message) ((j_common_ptr)&cinfo, buffer);\n\n\t\tiw_set_errorf(ctx,\"libjpeg reports read error: %s\",buffer);\n\n\t\tgoto done;\n\t}\n\n\tjpeg_create_decompress(&cinfo);\n\tcinfo_valid=1;\n\n\t// Set up our custom source manager.\n\trctx.pub.init_source = my_init_source_fn;\n\trctx.pub.fill_input_buffer = my_fill_input_buffer_fn;\n\trctx.pub.skip_input_data = my_skip_input_data_fn;\n\trctx.pub.resync_to_restart = jpeg_resync_to_restart; // libjpeg default\n\trctx.pub.term_source = my_term_source_fn;\n\trctx.ctx = ctx;\n\trctx.iodescr = iodescr;\n\trctx.buffer_len = 32768;\n\trctx.buffer = iw_malloc(ctx, rctx.buffer_len);\n\tif(!rctx.buffer) goto done;\n\trctx.exif_density_x = -1.0;\n\trctx.exif_density_y = -1.0;\n\tcinfo.src = (struct jpeg_source_mgr*)&rctx;\n\n\t// The lazy way. It would be more efficient to use\n\t// jpeg_set_marker_processor(), instead of saving everything to memory.\n\t// But libjpeg's marker processing functions have fairly complex\n\t// requirements.\n\tjpeg_save_markers(&cinfo, 0xe1, 65535);\n\n\tjpeg_read_header(&cinfo, TRUE);\n\n\trctx.is_jfif = cinfo.saw_JFIF_marker;\n\n\tiwjpeg_read_density(ctx,&img,&cinfo);\n\n\tiwjpeg_read_saved_markers(&rctx,&cinfo);\n\n\tjpeg_start_decompress(&cinfo);\n\n\tcolorspace=cinfo.out_color_space;\n\tnumchannels=cinfo.output_components;\n\n\t// libjpeg will automatically convert YCbCr images to RGB, and YCCK images\n\t// to CMYK. That leaves GRAYSCALE, RGB, and CMYK for us to handle.\n\t// Note: cinfo.jpeg_color_space is the colorspace before conversion, and\n\t// cinfo.out_color_space is the colorspace after conversion.\n\n\tif(colorspace==JCS_GRAYSCALE && numchannels==1) {\n\t\timg.imgtype = IW_IMGTYPE_GRAY;\n\t\timg.native_grayscale = 1;\n\t}\n\telse if((colorspace==JCS_RGB) && numchannels==3) {\n\t\timg.imgtype = IW_IMGTYPE_RGB;\n\t}\n\telse if((colorspace==JCS_CMYK) && numchannels==4) {\n\t\timg.imgtype = IW_IMGTYPE_RGB;\n\t\tcmyk_flag = 1;\n\t}\n\telse {\n\t\tiw_set_error(ctx,\"Unsupported type of JPEG\");\n\t\tgoto done;\n\t}\n\n\timg.width = cinfo.output_width;\n\timg.height = cinfo.output_height;\n\tif(!iw_check_image_dimensions(ctx,img.width,img.height)) {\n\t\tgoto done;\n\t}\n\n\timg.bit_depth = 8;\n\timg.bpr = iw_calc_bytesperrow(img.width,img.bit_depth*numchannels);\n\n\timg.pixels = (iw_byte*)iw_malloc_large(ctx, img.bpr, img.height);\n\tif(!img.pixels) {\n\t\tgoto done;\n\t}\n\n\tif(cmyk_flag) {\n\t\ttmprow = iw_malloc(ctx,4*img.width);\n\t\tif(!tmprow) goto done;\n\t}\n\n\twhile(cinfo.output_scanline < cinfo.output_height) {\n\t\trownum=cinfo.output_scanline;\n\t\tjsamprow = &img.pixels[img.bpr * rownum];\n\t\tif(cmyk_flag) {\n\t\t\t// read into tmprow, then convert and copy to img.pixels\n\t\t\tjpeg_read_scanlines(&cinfo, &tmprow, 1);\n\t\t\tconvert_cmyk_to_rbg(ctx,tmprow,jsamprow,img.width);\n\t\t}\n\t\telse {\n\t\t\t// read directly into img.pixels\n\t\t\tjpeg_read_scanlines(&cinfo, &jsamprow, 1);\n\t\t}\n\t\tif(cinfo.output_scanline<=rownum) {\n\t\t\tiw_set_error(ctx,\"Error reading JPEG file\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\tjpeg_finish_decompress(&cinfo);\n\n\thandle_exif_density(&rctx, &img);\n\n\tiw_set_input_image(ctx, &img);\n\t// The contents of img no longer belong to us.\n\timg.pixels = NULL;\n\n\tif(rctx.exif_orientation>=2 && rctx.exif_orientation<=8) {\n\t\tstatic const unsigned int exif_orient_to_transform[9] =\n\t\t   { 0,0, 1,3,2,4,5,7,6 };\n\n\t\t// An Exif marker indicated an unusual image orientation.\n\n\t\tif(rctx.is_jfif) {\n\t\t\t// The presence of a JFIF marker implies a particular orientation.\n\t\t\t// If there's also an Exif marker that says something different,\n\t\t\t// I'm not sure what we're supposed to do.\n\t\t\tiw_warning(ctx,\"JPEG image has an ambiguous orientation\");\n\t\t}\n\t\tiw_reorient_image(ctx,exif_orient_to_transform[rctx.exif_orientation]);\n\t}\n\n\tretval=1;\n\ndone:\n\tiw_free(ctx, img.pixels);\n\tif(cinfo_valid) jpeg_destroy_decompress(&cinfo);\n\tif(rctx.buffer) iw_free(ctx,rctx.buffer);\n\tif(tmprow) iw_free(ctx,tmprow);\n\treturn retval;\n}\n\n////////////////////////////////////\n\nstruct iwjpegwcontext {\n\tstruct jpeg_destination_mgr pub; // This field must be first.\n\tstruct iw_context *ctx;\n\tstruct iw_iodescr *iodescr;\n\tJOCTET *buffer;\n\tsize_t buffer_len;\n};\n\nstatic void iwjpg_set_density(struct iw_context *ctx,struct jpeg_compress_struct *cinfo,\n\tconst struct iw_image *img)\n{\n\tint pref_units;\n\n\tif(img->density_code==IW_DENSITY_UNITS_UNKNOWN) {\n\t\tcinfo->density_unit=0; // unknown units\n\t\tcinfo->X_density = (UINT16)(0.5+img->density_x);\n\t\tcinfo->Y_density = (UINT16)(0.5+img->density_y);\n\t}\n\telse if(img->density_code==IW_DENSITY_UNITS_PER_METER) {\n\t\tpref_units = iw_get_value(ctx,IW_VAL_PREF_UNITS);\n\n\t\tif(pref_units==IW_PREF_UNITS_METRIC) {\n\t\t\t// If we think the caller prefers metric, use dots/cm.\n\t\t\tcinfo->density_unit=2; // dots/cm\n\t\t\tcinfo->X_density = (UINT16)(0.5+ img->density_x*0.01);\n\t\t\tcinfo->Y_density = (UINT16)(0.5+ img->density_y*0.01);\n\t\t}\n\t\telse {\n\t\t\t// Otherwise use dpi.\n\t\t\tcinfo->density_unit=1; // dots/inch\n\t\t\tcinfo->X_density = (UINT16)(0.5+ img->density_x*0.0254);\n\t\t\tcinfo->Y_density = (UINT16)(0.5+ img->density_y*0.0254);\n\t\t}\n\t}\n}\n\nstatic void my_init_destination_fn(j_compress_ptr cinfo)\n{\n\tstruct iwjpegwcontext *wctx = (struct iwjpegwcontext*)cinfo->dest;\n\n\t// Configure the destination manager to use our buffer.\n\twctx->pub.next_output_byte = wctx->buffer;\n\twctx->pub.free_in_buffer = wctx->buffer_len;\n}\n\nstatic boolean my_empty_output_buffer_fn(j_compress_ptr cinfo)\n{\n\tstruct iwjpegwcontext *wctx = (struct iwjpegwcontext*)cinfo->dest;\n\n\t// Write out the entire buffer\n\t(*wctx->iodescr->write_fn)(wctx->ctx,wctx->iodescr,\n\t\twctx->buffer,wctx->buffer_len);\n\t// Change the data pointer and free-space indicator to reflect the\n\t// data we wrote.\n\twctx->pub.next_output_byte = wctx->buffer;\n\twctx->pub.free_in_buffer = wctx->buffer_len;\n\treturn TRUE;\n}\n\nstatic void my_term_destination_fn(j_compress_ptr cinfo)\n{\n\tstruct iwjpegwcontext *wctx = (struct iwjpegwcontext*)cinfo->dest;\n\tsize_t bytesleft;\n\n\tbytesleft = wctx->buffer_len - wctx->pub.free_in_buffer;\n\tif(bytesleft>0) {\n\t\t(*wctx->iodescr->write_fn)(wctx->ctx,wctx->iodescr,\n\t\t\twctx->buffer,bytesleft);\n\t}\n}\n\nIW_IMPL(int) iw_write_jpeg_file(struct iw_context *ctx,  struct iw_iodescr *iodescr)\n{\n\tint retval=0;\n\tstruct jpeg_compress_struct cinfo;\n\tstruct my_error_mgr jerr;\n\tJ_COLOR_SPACE in_colortype; // Color type of the data we give to libjpeg\n\tint jpeg_cmpts;\n\tint compress_created = 0;\n\tint compress_started = 0;\n\tJSAMPROW *row_pointers = NULL;\n\tint is_grayscale;\n\tint j;\n\tstruct iw_image img;\n\tint jpeg_quality;\n\tint samp_factor_h, samp_factor_v;\n\tint disable_subsampling = 0;\n\tstruct iwjpegwcontext wctx;\n\tconst char *optv;\n\tint ret;\n\n\tiw_zeromem(&cinfo,sizeof(struct jpeg_compress_struct));\n\tiw_zeromem(&jerr,sizeof(struct my_error_mgr));\n\tiw_zeromem(&wctx,sizeof(struct iwjpegwcontext));\n\n\tiw_get_output_image(ctx,&img);\n\n\tif(IW_IMGTYPE_HAS_ALPHA(img.imgtype)) {\n\t\tiw_set_error(ctx,\"Internal: Transparency not supported with JPEG output\");\n\t\tgoto done;\n\t}\n\n\tif(img.bit_depth!=8) {\n\t\tiw_set_errorf(ctx,\"Internal: Precision %d not supported with JPEG output\",img.bit_depth);\n\t\tgoto done;\n\t}\n\n\tis_grayscale = IW_IMGTYPE_IS_GRAY(img.imgtype);\n\n\tif(is_grayscale) {\n\t\tin_colortype=JCS_GRAYSCALE;\n\t\tjpeg_cmpts=1;\n\t}\n\telse {\n\t\tin_colortype=JCS_RGB;\n\t\tjpeg_cmpts=3;\n\t}\n\n\tcinfo.err = jpeg_std_error(&jerr.pub);\n\tjerr.pub.error_exit = my_error_exit;\n\n\tif (setjmp(jerr.setjmp_buffer)) {\n\t\tchar buffer[JMSG_LENGTH_MAX];\n\n\t\t(*cinfo.err->format_message) ((j_common_ptr)&cinfo, buffer);\n\n\t\tiw_set_errorf(ctx,\"libjpeg reports write error: %s\",buffer);\n\n\t\tgoto done;\n\t}\n\n\tjpeg_create_compress(&cinfo);\n\tcompress_created=1;\n\n\t// Set up our custom destination manager.\n\twctx.pub.init_destination = my_init_destination_fn;\n\twctx.pub.empty_output_buffer = my_empty_output_buffer_fn;\n\twctx.pub.term_destination = my_term_destination_fn;\n\twctx.ctx = ctx;\n\twctx.iodescr = iodescr;\n\twctx.buffer_len = 32768;\n\twctx.buffer = iw_malloc(ctx,wctx.buffer_len);\n\tif(!wctx.buffer) goto done;\n\t// Our wctx is organized so it can double as a\n\t// 'struct jpeg_destination_mgr'.\n\tcinfo.dest = (struct jpeg_destination_mgr*)&wctx;\n\n\tcinfo.image_width = img.width;\n\tcinfo.image_height = img.height;\n\tcinfo.input_components = jpeg_cmpts;\n\tcinfo.in_color_space = in_colortype;\n\n\tjpeg_set_defaults(&cinfo);\n\n\toptv = iw_get_option(ctx, \"jpeg:block\");\n\tif(optv) {\n#if (JPEG_LIB_VERSION_MAJOR>=9 || \\\n\t(JPEG_LIB_VERSION_MAJOR==8 && JPEG_LIB_VERSION_MINOR>=3))\n\t\t// Note: This might not work if DCT_SCALING_SUPPORTED was not defined when\n\t\t// libjpeg was compiled, but that symbol is not normally exposed to\n\t\t// applications.\n\t\tcinfo.block_size = iw_parse_int(optv);\n#else\n\t\tiw_warning(ctx, \"Setting block size is not supported by this version of libjpeg\");\n#endif\n\t}\n\n\toptv = iw_get_option(ctx, \"jpeg:arith\");\n\tif(optv)\n\t\tcinfo.arith_code = iw_parse_int(optv) ? TRUE : FALSE;\n\telse\n\t\tcinfo.arith_code = FALSE;\n\n\toptv = iw_get_option(ctx, \"jpeg:colortype\");\n\tif(optv) {\n\t\tif(!strcmp(optv, \"rgb\")) {\n\t\t\tif(in_colortype==JCS_RGB) {\n\t\t\t\tjpeg_set_colorspace(&cinfo,JCS_RGB);\n\t\t\t\tdisable_subsampling = 1;\n\t\t\t}\n\t\t}\n\t\telse if(!strcmp(optv, \"rgb1\")) {\n\t\t\tif(in_colortype==JCS_RGB) {\n#if JPEG_LIB_VERSION_MAJOR >= 9\n\t\t\t\tcinfo.color_transform = JCT_SUBTRACT_GREEN;\n#else\n\t\t\t\tiw_warning(ctx, \"Color type rgb1 is not supported by this version of libjpeg\");\n#endif\n\t\t\t\tjpeg_set_colorspace(&cinfo,JCS_RGB);\n\t\t\t\tdisable_subsampling = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\toptv = iw_get_option(ctx, \"jpeg:bgycc\");\n\tif(optv && iw_parse_int(optv)) {\n#if (JPEG_LIB_VERSION_MAJOR>9 || \\\n\t(JPEG_LIB_VERSION_MAJOR==9 && JPEG_LIB_VERSION_MINOR>=1))\n\t\tjpeg_set_colorspace(&cinfo, JCS_BG_YCC);\n#else\n\t\tiw_warning(ctx, \"Big gamut YCC is not supported by this version of libjpeg\");\n#endif\n\t}\n\n\tiwjpg_set_density(ctx,&cinfo,&img);\n\n\toptv = iw_get_option(ctx, \"jpeg:quality\");\n\tif(optv)\n\t\tjpeg_quality = iw_parse_int(optv);\n\telse\n\t\tjpeg_quality = 0;\n\n\tif(jpeg_quality>0) {\n\t\tjpeg_set_quality(&cinfo,jpeg_quality,0);\n\t}\n\n\tif(jpeg_cmpts>1 && !disable_subsampling) {\n\t\tsamp_factor_h = 0;\n\t\tsamp_factor_v = 0;\n\n\t\t// sampling-x and sampling-y are for backward compatibility, and should\n\t\t// not be used.\n\t\toptv = iw_get_option(ctx, \"jpeg:sampling-x\");\n\t\tif(optv)\n\t\t\tsamp_factor_h = iw_parse_int(optv);\n\t\toptv = iw_get_option(ctx, \"jpeg:sampling-y\");\n\t\tif(optv)\n\t\t\tsamp_factor_v = iw_parse_int(optv);\n\n\t\toptv = iw_get_option(ctx, \"jpeg:sampling\");\n\t\tif(optv) {\n\t\t\tdouble tmpsamp[2];\n\t\t\ttmpsamp[0] = 1.0;\n\t\t\ttmpsamp[1] = 1.0;\n\t\t\tret = iw_parse_number_list(optv, 2, tmpsamp);\n\t\t\tsamp_factor_h = iw_round_to_int(tmpsamp[0]);\n\t\t\tif(ret==1) {\n\t\t\t\t// If only one value was given, use it for both factors.\n\t\t\t\tsamp_factor_v = samp_factor_h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsamp_factor_v = iw_round_to_int(tmpsamp[1]);\n\t\t\t}\n\t\t}\n\n\t\tif(samp_factor_h>0) {\n\t\t\tif(samp_factor_h>4) samp_factor_h=4;\n\t\t\tcinfo.comp_info[0].h_samp_factor = samp_factor_h;\n\t\t}\n\t\tif(samp_factor_v>0) {\n\t\t\tif(samp_factor_v>4) samp_factor_v=4;\n\t\t\tcinfo.comp_info[0].v_samp_factor = samp_factor_v;\n\t\t}\n\t}\n\n\tif(iw_get_value(ctx,IW_VAL_OUTPUT_INTERLACED)) {\n\t\tjpeg_simple_progression(&cinfo);\n\t}\n\n\trow_pointers = (JSAMPROW*)iw_malloc(ctx, img.height * sizeof(JSAMPROW));\n\tif(!row_pointers) goto done;\n\n\tfor(j=0;j<img.height;j++) {\n\t\trow_pointers[j] = &img.pixels[j*img.bpr];\n\t}\n\n\tjpeg_start_compress(&cinfo, TRUE);\n\tcompress_started=1;\n\n\tjpeg_write_scanlines(&cinfo, row_pointers, img.height);\n\n\tretval=1;\n\ndone:\n\tif(compress_started)\n\t\tjpeg_finish_compress(&cinfo);\n\n\tif(compress_created)\n\t\tjpeg_destroy_compress(&cinfo);\n\n\tif(row_pointers) iw_free(ctx,row_pointers);\n\n\tif(wctx.buffer) iw_free(ctx,wctx.buffer);\n\n\treturn retval;\n}\n\nIW_IMPL(char*) iw_get_libjpeg_version_string(char *s, int s_len)\n{\n\tstruct jpeg_error_mgr jerr;\n\tconst char *jv;\n\tchar *space_ptr;\n\n\tjpeg_std_error(&jerr);\n\tjv = jerr.jpeg_message_table[JMSG_VERSION];\n\tiw_snprintf(s,s_len,\"%s\",jv);\n\n\t// The version is probably a string like \"8c  16-Jan-2011\", containing\n\t// both the version number and the release date. We only need the version\n\t// number, so chop it off at the first space.\n\tspace_ptr = strchr(s,' ');\n\tif(space_ptr) *space_ptr = '\\0';\n\treturn s;\n}\n\n#endif // IW_SUPPORT_JPEG\n"], "filenames": ["src/imagew-jpeg.c"], "buggy_code_start_loc": [60], "buggy_code_end_loc": [181], "fixing_code_start_loc": [61], "fixing_code_end_loc": [193], "type": "CWE-125", "message": "The iw_get_ui16be function in imagew-util.c:422:24 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted image, related to imagew-jpeg.c.", "other": {"cve": {"id": "CVE-2017-9207", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-23T04:29:04.667", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The iw_get_ui16be function in imagew-util.c:422:24 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted image, related to imagew-jpeg.c."}, {"lang": "es", "value": "La funci\u00f3n iw_get_ui16be en imagew-util.c:422:24 en libimageworsener.a en ImageWorsener 1.3.1 permite a los atacantes remotos provocar una denegaci\u00f3n de servicio (sobrelectura de b\u00fafer basado en memoria din\u00e1mica -heap-) a trav\u00e9s de una imagen especialmente dise\u00f1ada, relacionada con imagew-jpeg.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:entropymine:imageworsener:1.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "60307047-29E3-470F-9482-7FA546DE3196"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2017/05/20/imageworsener-multiple-vulnerabilities/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/jsummers/imageworsener/commit/b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jsummers/imageworsener/commit/b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d"}}