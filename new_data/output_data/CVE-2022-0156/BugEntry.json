{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * alloc.c: functions for memory management\n */\n\n#include \"vim.h\"\n\n/**********************************************************************\n * Various routines dealing with allocation and deallocation of memory.\n */\n\n#if defined(MEM_PROFILE) || defined(PROTO)\n\n# define MEM_SIZES  8200\nstatic long_u mem_allocs[MEM_SIZES];\nstatic long_u mem_frees[MEM_SIZES];\nstatic long_u mem_allocated;\nstatic long_u mem_freed;\nstatic long_u mem_peak;\nstatic long_u num_alloc;\nstatic long_u num_freed;\n\n    static void\nmem_pre_alloc_s(size_t *sizep)\n{\n    *sizep += sizeof(size_t);\n}\n\n    static void\nmem_pre_alloc_l(size_t *sizep)\n{\n    *sizep += sizeof(size_t);\n}\n\n    static void\nmem_post_alloc(\n    void **pp,\n    size_t size)\n{\n    if (*pp == NULL)\n\treturn;\n    size -= sizeof(size_t);\n    *(long_u *)*pp = size;\n    if (size <= MEM_SIZES-1)\n\tmem_allocs[size-1]++;\n    else\n\tmem_allocs[MEM_SIZES-1]++;\n    mem_allocated += size;\n    if (mem_allocated - mem_freed > mem_peak)\n\tmem_peak = mem_allocated - mem_freed;\n    num_alloc++;\n    *pp = (void *)((char *)*pp + sizeof(size_t));\n}\n\n    static void\nmem_pre_free(void **pp)\n{\n    long_u size;\n\n    *pp = (void *)((char *)*pp - sizeof(size_t));\n    size = *(size_t *)*pp;\n    if (size <= MEM_SIZES-1)\n\tmem_frees[size-1]++;\n    else\n\tmem_frees[MEM_SIZES-1]++;\n    mem_freed += size;\n    num_freed++;\n}\n\n/*\n * called on exit via atexit()\n */\n    void\nvim_mem_profile_dump(void)\n{\n    int i, j;\n\n    printf(\"\\r\\n\");\n    j = 0;\n    for (i = 0; i < MEM_SIZES - 1; i++)\n    {\n\tif (mem_allocs[i] || mem_frees[i])\n\t{\n\t    if (mem_frees[i] > mem_allocs[i])\n\t\tprintf(\"\\r\\n%s\", _(\"ERROR: \"));\n\t    printf(\"[%4d / %4lu-%-4lu] \", i + 1, mem_allocs[i], mem_frees[i]);\n\t    j++;\n\t    if (j > 3)\n\t    {\n\t\tj = 0;\n\t\tprintf(\"\\r\\n\");\n\t    }\n\t}\n    }\n\n    i = MEM_SIZES - 1;\n    if (mem_allocs[i])\n    {\n\tprintf(\"\\r\\n\");\n\tif (mem_frees[i] > mem_allocs[i])\n\t    puts(_(\"ERROR: \"));\n\tprintf(\"[>%d / %4lu-%-4lu]\", i, mem_allocs[i], mem_frees[i]);\n    }\n\n    printf(_(\"\\n[bytes] total alloc-freed %lu-%lu, in use %lu, peak use %lu\\n\"),\n\t    mem_allocated, mem_freed, mem_allocated - mem_freed, mem_peak);\n    printf(_(\"[calls] total re/malloc()'s %lu, total free()'s %lu\\n\\n\"),\n\t    num_alloc, num_freed);\n}\n\n#endif // MEM_PROFILE\n\n#ifdef FEAT_EVAL\n    int\nalloc_does_fail(size_t size)\n{\n    if (alloc_fail_countdown == 0)\n    {\n\tif (--alloc_fail_repeat <= 0)\n\t    alloc_fail_id = 0;\n\tdo_outofmem_msg(size);\n\treturn TRUE;\n    }\n    --alloc_fail_countdown;\n    return FALSE;\n}\n#endif\n\n/*\n * Some memory is reserved for error messages and for being able to\n * call mf_release_all(), which needs some memory for mf_trans_add().\n */\n#define KEEP_ROOM (2 * 8192L)\n#define KEEP_ROOM_KB (KEEP_ROOM / 1024L)\n\n/*\n * The normal way to allocate memory.  This handles an out-of-memory situation\n * as well as possible, still returns NULL when we're completely out.\n */\n    void *\nalloc(size_t size)\n{\n    return lalloc(size, TRUE);\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * alloc() with an ID for alloc_fail().\n */\n    void *\nalloc_id(size_t size, alloc_id_T id UNUSED)\n{\n#ifdef FEAT_EVAL\n    if (alloc_fail_id == id && alloc_does_fail(size))\n\treturn NULL;\n#endif\n    return lalloc(size, TRUE);\n}\n#endif\n\n/*\n * Allocate memory and set all bytes to zero.\n */\n    void *\nalloc_clear(size_t size)\n{\n    void *p;\n\n    p = lalloc(size, TRUE);\n    if (p != NULL)\n\t(void)vim_memset(p, 0, size);\n    return p;\n}\n\n#if defined(FEAT_SIGNS) || defined(PROTO)\n/*\n * Same as alloc_clear() but with allocation id for testing\n */\n    void *\nalloc_clear_id(size_t size, alloc_id_T id UNUSED)\n{\n#ifdef FEAT_EVAL\n    if (alloc_fail_id == id && alloc_does_fail(size))\n\treturn NULL;\n#endif\n    return alloc_clear(size);\n}\n#endif\n\n/*\n * Allocate memory like lalloc() and set all bytes to zero.\n */\n    void *\nlalloc_clear(size_t size, int message)\n{\n    void *p;\n\n    p = lalloc(size, message);\n    if (p != NULL)\n\t(void)vim_memset(p, 0, size);\n    return p;\n}\n\n/*\n * Low level memory allocation function.\n * This is used often, KEEP IT FAST!\n */\n    void *\nlalloc(size_t size, int message)\n{\n    void\t*p;\t\t    // pointer to new storage space\n    static int\treleasing = FALSE;  // don't do mf_release_all() recursive\n    int\t\ttry_again;\n#if defined(HAVE_AVAIL_MEM)\n    static size_t allocated = 0;    // allocated since last avail check\n#endif\n\n    // Safety check for allocating zero bytes\n    if (size == 0)\n    {\n\t// Don't hide this message\n\temsg_silent = 0;\n\tiemsg(_(e_internal_error_lalloc_zero));\n\treturn NULL;\n    }\n\n#ifdef MEM_PROFILE\n    mem_pre_alloc_l(&size);\n#endif\n\n    // Loop when out of memory: Try to release some memfile blocks and\n    // if some blocks are released call malloc again.\n    for (;;)\n    {\n\t// Handle three kinds of systems:\n\t// 1. No check for available memory: Just return.\n\t// 2. Slow check for available memory: call mch_avail_mem() after\n\t//    allocating KEEP_ROOM amount of memory.\n\t// 3. Strict check for available memory: call mch_avail_mem()\n\tif ((p = malloc(size)) != NULL)\n\t{\n#ifndef HAVE_AVAIL_MEM\n\t    // 1. No check for available memory: Just return.\n\t    goto theend;\n#else\n\t    // 2. Slow check for available memory: call mch_avail_mem() after\n\t    //    allocating (KEEP_ROOM / 2) amount of memory.\n\t    allocated += size;\n\t    if (allocated < KEEP_ROOM / 2)\n\t\tgoto theend;\n\t    allocated = 0;\n\n\t    // 3. check for available memory: call mch_avail_mem()\n\t    if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)\n\t    {\n\t\tfree(p);\t// System is low... no go!\n\t\tp = NULL;\n\t    }\n\t    else\n\t\tgoto theend;\n#endif\n\t}\n\t// Remember that mf_release_all() is being called to avoid an endless\n\t// loop, because mf_release_all() may call alloc() recursively.\n\tif (releasing)\n\t    break;\n\treleasing = TRUE;\n\n\tclear_sb_text(TRUE);\t      // free any scrollback text\n\ttry_again = mf_release_all(); // release as many blocks as possible\n\n\treleasing = FALSE;\n\tif (!try_again)\n\t    break;\n    }\n\n    if (message && p == NULL)\n\tdo_outofmem_msg(size);\n\ntheend:\n#ifdef MEM_PROFILE\n    mem_post_alloc(&p, size);\n#endif\n    return p;\n}\n\n/*\n * lalloc() with an ID for alloc_fail().\n */\n#if defined(FEAT_SIGNS) || defined(PROTO)\n    void *\nlalloc_id(size_t size, int message, alloc_id_T id UNUSED)\n{\n#ifdef FEAT_EVAL\n    if (alloc_fail_id == id && alloc_does_fail(size))\n\treturn NULL;\n#endif\n    return (lalloc(size, message));\n}\n#endif\n\n#if defined(MEM_PROFILE) || defined(PROTO)\n/*\n * realloc() with memory profiling.\n */\n    void *\nmem_realloc(void *ptr, size_t size)\n{\n    void *p;\n\n    mem_pre_free(&ptr);\n    mem_pre_alloc_s(&size);\n\n    p = realloc(ptr, size);\n\n    mem_post_alloc(&p, size);\n\n    return p;\n}\n#endif\n\n/*\n* Avoid repeating the error message many times (they take 1 second each).\n* Did_outofmem_msg is reset when a character is read.\n*/\n    void\ndo_outofmem_msg(size_t size)\n{\n    if (!did_outofmem_msg)\n    {\n\t// Don't hide this message\n\temsg_silent = 0;\n\n\t// Must come first to avoid coming back here when printing the error\n\t// message fails, e.g. when setting v:errmsg.\n\tdid_outofmem_msg = TRUE;\n\n\tsemsg(_(e_out_of_memory_allocating_nr_bytes), (long_u)size);\n\n\tif (starting == NO_SCREEN)\n\t    // Not even finished with initializations and already out of\n\t    // memory?  Then nothing is going to work, exit.\n\t    mch_exit(123);\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n\n/*\n * Free everything that we allocated.\n * Can be used to detect memory leaks, e.g., with ccmalloc.\n * NOTE: This is tricky!  Things are freed that functions depend on.  Don't be\n * surprised if Vim crashes...\n * Some things can't be freed, esp. things local to a library function.\n */\n    void\nfree_all_mem(void)\n{\n    buf_T\t*buf, *nextbuf;\n\n    // When we cause a crash here it is caught and Vim tries to exit cleanly.\n    // Don't try freeing everything again.\n    if (entered_free_all_mem)\n\treturn;\n    entered_free_all_mem = TRUE;\n    // Don't want to trigger autocommands from here on.\n    block_autocmds();\n\n    // Close all tabs and windows.  Reset 'equalalways' to avoid redraws.\n    p_ea = FALSE;\n    if (first_tabpage != NULL && first_tabpage->tp_next != NULL)\n\tdo_cmdline_cmd((char_u *)\"tabonly!\");\n    if (!ONE_WINDOW)\n\tdo_cmdline_cmd((char_u *)\"only!\");\n\n# if defined(FEAT_SPELL)\n    // Free all spell info.\n    spell_free_all();\n# endif\n\n# if defined(FEAT_BEVAL_TERM)\n    ui_remove_balloon();\n# endif\n# ifdef FEAT_PROP_POPUP\n    if (curwin != NULL)\n\tclose_all_popups(TRUE);\n# endif\n\n    // Clear user commands (before deleting buffers).\n    ex_comclear(NULL);\n\n    // When exiting from mainerr_arg_missing curbuf has not been initialized,\n    // and not much else.\n    if (curbuf != NULL)\n    {\n# ifdef FEAT_MENU\n\t// Clear menus.\n\tdo_cmdline_cmd((char_u *)\"aunmenu *\");\n#  ifdef FEAT_MULTI_LANG\n\tdo_cmdline_cmd((char_u *)\"menutranslate clear\");\n#  endif\n# endif\n\t// Clear mappings, abbreviations, breakpoints.\n\tdo_cmdline_cmd((char_u *)\"lmapclear\");\n\tdo_cmdline_cmd((char_u *)\"xmapclear\");\n\tdo_cmdline_cmd((char_u *)\"mapclear\");\n\tdo_cmdline_cmd((char_u *)\"mapclear!\");\n\tdo_cmdline_cmd((char_u *)\"abclear\");\n# if defined(FEAT_EVAL)\n\tdo_cmdline_cmd((char_u *)\"breakdel *\");\n# endif\n# if defined(FEAT_PROFILE)\n\tdo_cmdline_cmd((char_u *)\"profdel *\");\n# endif\n# if defined(FEAT_KEYMAP)\n\tdo_cmdline_cmd((char_u *)\"set keymap=\");\n# endif\n    }\n\n    free_titles();\n# if defined(FEAT_SEARCHPATH)\n    free_findfile();\n# endif\n\n    // Obviously named calls.\n    free_all_autocmds();\n    clear_termcodes();\n    free_all_marks();\n    alist_clear(&global_alist);\n    free_homedir();\n    free_users();\n    free_search_patterns();\n    free_old_sub();\n    free_last_insert();\n    free_insexpand_stuff();\n    free_prev_shellcmd();\n    free_regexp_stuff();\n    free_tag_stuff();\n    free_xim_stuff();\n    free_cd_dir();\n# ifdef FEAT_SIGNS\n    free_signs();\n# endif\n# ifdef FEAT_EVAL\n    set_expr_line(NULL, NULL);\n# endif\n# ifdef FEAT_DIFF\n    if (curtab != NULL)\n\tdiff_clear(curtab);\n# endif\n    clear_sb_text(TRUE);\t      // free any scrollback text\n\n    // Free some global vars.\n    free_username();\n# ifdef FEAT_CLIPBOARD\n    vim_regfree(clip_exclude_prog);\n# endif\n    vim_free(last_cmdline);\n    vim_free(new_last_cmdline);\n    set_keep_msg(NULL, 0);\n\n    // Clear cmdline history.\n    p_hi = 0;\n    init_history();\n# ifdef FEAT_PROP_POPUP\n    clear_global_prop_types();\n# endif\n\n# ifdef FEAT_QUICKFIX\n    {\n\twin_T\t    *win;\n\ttabpage_T   *tab;\n\n\tqf_free_all(NULL);\n\t// Free all location lists\n\tFOR_ALL_TAB_WINDOWS(tab, win)\n\t    qf_free_all(win);\n    }\n# endif\n\n    // Close all script inputs.\n    close_all_scripts();\n\n    if (curwin != NULL)\n\t// Destroy all windows.  Must come before freeing buffers.\n\twin_free_all();\n\n    // Free all option values.  Must come after closing windows.\n    free_all_options();\n\n    // Free all buffers.  Reset 'autochdir' to avoid accessing things that\n    // were freed already.\n# ifdef FEAT_AUTOCHDIR\n    p_acd = FALSE;\n# endif\n    for (buf = firstbuf; buf != NULL; )\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, buf);\n\tnextbuf = buf->b_next;\n\tclose_buffer(NULL, buf, DOBUF_WIPE, FALSE, FALSE);\n\tif (bufref_valid(&bufref))\n\t    buf = nextbuf;\t// didn't work, try next one\n\telse\n\t    buf = firstbuf;\n    }\n\n# ifdef FEAT_ARABIC\n    free_arshape_buf();\n# endif\n\n    // Clear registers.\n    clear_registers();\n    ResetRedobuff();\n    ResetRedobuff();\n\n# if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)\n    vim_free(serverDelayedStartName);\n# endif\n\n    // highlight info\n    free_highlight();\n\n    reset_last_sourcing();\n\n    if (first_tabpage != NULL)\n    {\n\tfree_tabpage(first_tabpage);\n\tfirst_tabpage = NULL;\n    }\n\n# ifdef UNIX\n    // Machine-specific free.\n    mch_free_mem();\n# endif\n\n    // message history\n    for (;;)\n\tif (delete_first_msg() == FAIL)\n\t    break;\n\n# ifdef FEAT_JOB_CHANNEL\n    channel_free_all();\n# endif\n# ifdef FEAT_TIMERS\n    timer_free_all();\n# endif\n# ifdef FEAT_EVAL\n    // must be after channel_free_all() with unrefs partials\n    eval_clear();\n# endif\n# ifdef FEAT_JOB_CHANNEL\n    // must be after eval_clear() with unrefs jobs\n    job_free_all();\n# endif\n\n    free_termoptions();\n    free_cur_term();\n\n    // screenlines (can't display anything now!)\n    free_screenlines();\n\n# if defined(FEAT_SOUND)\n    sound_free();\n# endif\n# if defined(USE_XSMP)\n    xsmp_close();\n# endif\n# ifdef FEAT_GUI_GTK\n    gui_mch_free_all();\n# endif\n# ifdef FEAT_TCL\n    vim_tcl_finalize();\n# endif\n    clear_hl_tables();\n\n    vim_free(IObuff);\n    vim_free(NameBuff);\n# ifdef FEAT_QUICKFIX\n    check_quickfix_busy();\n# endif\n}\n#endif\n\n/*\n * Copy \"p[len]\" into allocated memory, ignoring NUL characters.\n * Returns NULL when out of memory.\n */\n    char_u *\nvim_memsave(char_u *p, size_t len)\n{\n    char_u *ret = alloc(len);\n\n    if (ret != NULL)\n\tmch_memmove(ret, p, len);\n    return ret;\n}\n\n/*\n * Replacement for free() that ignores NULL pointers.\n * Also skip free() when exiting for sure, this helps when we caught a deadly\n * signal that was caused by a crash in free().\n * If you want to set NULL after calling this function, you should use\n * VIM_CLEAR() instead.\n */\n    void\nvim_free(void *x)\n{\n    if (x != NULL && !really_exiting)\n    {\n#ifdef MEM_PROFILE\n\tmem_pre_free(&x);\n#endif\n\tfree(x);\n    }\n}\n\n/************************************************************************\n * Functions for handling growing arrays.\n */\n\n/*\n * Clear an allocated growing array.\n */\n    void\nga_clear(garray_T *gap)\n{\n    vim_free(gap->ga_data);\n    ga_init(gap);\n}\n\n/*\n * Clear a growing array that contains a list of strings.\n */\n    void\nga_clear_strings(garray_T *gap)\n{\n    int\t\ti;\n\n    if (gap->ga_data != NULL)\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t    vim_free(((char_u **)(gap->ga_data))[i]);\n    ga_clear(gap);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Copy a growing array that contains a list of strings.\n */\n    int\nga_copy_strings(garray_T *from, garray_T *to)\n{\n    int\t\ti;\n\n    ga_init2(to, sizeof(char_u *), 1);\n    if (ga_grow(to, from->ga_len) == FAIL)\n\treturn FAIL;\n\n    for (i = 0; i < from->ga_len; ++i)\n    {\n\tchar_u *orig = ((char_u **)from->ga_data)[i];\n\tchar_u *copy;\n\n\tif (orig == NULL)\n\t    copy = NULL;\n\telse\n\t{\n\t    copy = vim_strsave(orig);\n\t    if (copy == NULL)\n\t    {\n\t\tto->ga_len = i;\n\t\tga_clear_strings(to);\n\t\treturn FAIL;\n\t    }\n\t}\n\t((char_u **)to->ga_data)[i] = copy;\n    }\n    to->ga_len = from->ga_len;\n    return OK;\n}\n#endif\n\n/*\n * Initialize a growing array.\tDon't forget to set ga_itemsize and\n * ga_growsize!  Or use ga_init2().\n */\n    void\nga_init(garray_T *gap)\n{\n    gap->ga_data = NULL;\n    gap->ga_maxlen = 0;\n    gap->ga_len = 0;\n}\n\n    void\nga_init2(garray_T *gap, int itemsize, int growsize)\n{\n    ga_init(gap);\n    gap->ga_itemsize = itemsize;\n    gap->ga_growsize = growsize;\n}\n\n/*\n * Make room in growing array \"gap\" for at least \"n\" items.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nga_grow(garray_T *gap, int n)\n{\n    if (gap->ga_maxlen - gap->ga_len < n)\n\treturn ga_grow_inner(gap, n);\n    return OK;\n}\n\n    int\nga_grow_inner(garray_T *gap, int n)\n{\n    size_t\told_len;\n    size_t\tnew_len;\n    char_u\t*pp;\n\n    if (n < gap->ga_growsize)\n\tn = gap->ga_growsize;\n\n    // A linear growth is very inefficient when the array grows big.  This\n    // is a compromise between allocating memory that won't be used and too\n    // many copy operations. A factor of 1.5 seems reasonable.\n    if (n < gap->ga_len / 2)\n\tn = gap->ga_len / 2;\n\n    new_len = gap->ga_itemsize * (gap->ga_len + n);\n    pp = vim_realloc(gap->ga_data, new_len);\n    if (pp == NULL)\n\treturn FAIL;\n    old_len = gap->ga_itemsize * gap->ga_maxlen;\n    vim_memset(pp + old_len, 0, new_len - old_len);\n    gap->ga_maxlen = gap->ga_len + n;\n    gap->ga_data = pp;\n    return OK;\n}\n\n/*\n * For a growing array that contains a list of strings: concatenate all the\n * strings with a separating \"sep\".\n * Returns NULL when out of memory.\n */\n    char_u *\nga_concat_strings(garray_T *gap, char *sep)\n{\n    int\t\ti;\n    int\t\tlen = 0;\n    int\t\tsep_len = (int)STRLEN(sep);\n    char_u\t*s;\n    char_u\t*p;\n\n    for (i = 0; i < gap->ga_len; ++i)\n\tlen += (int)STRLEN(((char_u **)(gap->ga_data))[i]) + sep_len;\n\n    s = alloc(len + 1);\n    if (s != NULL)\n    {\n\t*s = NUL;\n\tp = s;\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    if (p != s)\n\t    {\n\t\tSTRCPY(p, sep);\n\t\tp += sep_len;\n\t    }\n\t    STRCPY(p, ((char_u **)(gap->ga_data))[i]);\n\t    p += STRLEN(p);\n\t}\n    }\n    return s;\n}\n\n/*\n * Make a copy of string \"p\" and add it to \"gap\".\n * When out of memory nothing changes and FAIL is returned.\n */\n    int\nga_add_string(garray_T *gap, char_u *p)\n{\n    char_u *cp = vim_strsave(p);\n\n    if (cp == NULL)\n\treturn FAIL;\n\n    if (ga_grow(gap, 1) == FAIL)\n    {\n\tvim_free(cp);\n\treturn FAIL;\n    }\n    ((char_u **)(gap->ga_data))[gap->ga_len++] = cp;\n    return OK;\n}\n\n/*\n * Concatenate a string to a growarray which contains bytes.\n * When \"s\" is NULL does not do anything.\n * Note: Does NOT copy the NUL at the end!\n */\n    void\nga_concat(garray_T *gap, char_u *s)\n{\n    int    len;\n\n    if (s == NULL || *s == NUL)\n\treturn;\n    len = (int)STRLEN(s);\n    if (ga_grow(gap, len) == OK)\n    {\n\tmch_memmove((char *)gap->ga_data + gap->ga_len, s, (size_t)len);\n\tgap->ga_len += len;\n    }\n}\n\n/*\n * Concatenate 'len' bytes from string 's' to a growarray.\n * When \"s\" is NULL does not do anything.\n */\n    void\nga_concat_len(garray_T *gap, char_u *s, size_t len)\n{\n    if (s == NULL || *s == NUL)\n\treturn;\n    if (ga_grow(gap, (int)len) == OK)\n    {\n\tmch_memmove((char *)gap->ga_data + gap->ga_len, s, len);\n\tgap->ga_len += (int)len;\n    }\n}\n\n/*\n * Append one byte to a growarray which contains bytes.\n */\n    void\nga_append(garray_T *gap, int c)\n{\n    if (ga_grow(gap, 1) == OK)\n    {\n\t*((char *)gap->ga_data + gap->ga_len) = c;\n\t++gap->ga_len;\n    }\n}\n\n#if (defined(UNIX) && !defined(USE_SYSTEM)) || defined(MSWIN) \\\n\t|| defined(PROTO)\n/*\n * Append the text in \"gap\" below the cursor line and clear \"gap\".\n */\n    void\nappend_ga_line(garray_T *gap)\n{\n    // Remove trailing CR.\n    if (gap->ga_len > 0\n\t    && !curbuf->b_p_bin\n\t    && ((char_u *)gap->ga_data)[gap->ga_len - 1] == CAR)\n\t--gap->ga_len;\n    ga_append(gap, NUL);\n    ml_append(curwin->w_cursor.lnum++, gap->ga_data, 0, FALSE);\n    gap->ga_len = 0;\n}\n#endif\n\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * message.c: functions for displaying messages on the command line\n */\n\n#define MESSAGE_FILE\t\t// don't include prototype for smsg()\n\n#include \"vim.h\"\n\nstatic void add_msg_hist(char_u *s, int len, int attr);\nstatic void hit_return_msg(void);\nstatic void msg_home_replace_attr(char_u *fname, int attr);\nstatic void msg_puts_attr_len(char *str, int maxlen, int attr);\nstatic void msg_puts_display(char_u *str, int maxlen, int attr, int recurse);\nstatic void msg_scroll_up(void);\nstatic void inc_msg_scrolled(void);\nstatic void store_sb_text(char_u **sb_str, char_u *s, int attr, int *sb_col, int finish);\nstatic void t_puts(int *t_col, char_u *t_s, char_u *s, int attr);\nstatic void msg_puts_printf(char_u *str, int maxlen);\nstatic int do_more_prompt(int typed_char);\nstatic void msg_screen_putchar(int c, int attr);\nstatic void msg_moremsg(int full);\nstatic int  msg_check_screen(void);\nstatic void redir_write(char_u *s, int maxlen);\n#ifdef FEAT_CON_DIALOG\nstatic char_u *msg_show_console_dialog(char_u *message, char_u *buttons, int dfltbutton);\nstatic int\tconfirm_msg_used = FALSE;\t// displaying confirm_msg\nstatic char_u\t*confirm_msg = NULL;\t\t// \":confirm\" message\nstatic char_u\t*confirm_msg_tail;\t\t// tail of confirm_msg\nstatic void display_confirm_msg(void);\n#endif\n#ifdef FEAT_JOB_CHANNEL\nstatic int emsg_to_channel_log = FALSE;\n#endif\n\nstruct msg_hist\n{\n    struct msg_hist\t*next;\n    char_u\t\t*msg;\n    int\t\t\tattr;\n};\n\nstatic struct msg_hist *first_msg_hist = NULL;\nstatic struct msg_hist *last_msg_hist = NULL;\nstatic int msg_hist_len = 0;\n\nstatic FILE *verbose_fd = NULL;\nstatic int  verbose_did_open = FALSE;\n\n/*\n * When writing messages to the screen, there are many different situations.\n * A number of variables is used to remember the current state:\n * msg_didany\t    TRUE when messages were written since the last time the\n *\t\t    user reacted to a prompt.\n *\t\t    Reset: After hitting a key for the hit-return prompt,\n *\t\t    hitting <CR> for the command line or input().\n *\t\t    Set: When any message is written to the screen.\n * msg_didout\t    TRUE when something was written to the current line.\n *\t\t    Reset: When advancing to the next line, when the current\n *\t\t    text can be overwritten.\n *\t\t    Set: When any message is written to the screen.\n * msg_nowait\t    No extra delay for the last drawn message.\n *\t\t    Used in normal_cmd() before the mode message is drawn.\n * emsg_on_display  There was an error message recently.  Indicates that there\n *\t\t    should be a delay before redrawing.\n * msg_scroll\t    The next message should not overwrite the current one.\n * msg_scrolled\t    How many lines the screen has been scrolled (because of\n *\t\t    messages).  Used in update_screen() to scroll the screen\n *\t\t    back.  Incremented each time the screen scrolls a line.\n * msg_scrolled_ign  TRUE when msg_scrolled is non-zero and msg_puts_attr()\n *\t\t    writes something without scrolling should not make\n *\t\t    need_wait_return to be set.  This is a hack to make \":ts\"\n *\t\t    work without an extra prompt.\n * lines_left\t    Number of lines available for messages before the\n *\t\t    more-prompt is to be given.  -1 when not set.\n * need_wait_return TRUE when the hit-return prompt is needed.\n *\t\t    Reset: After giving the hit-return prompt, when the user\n *\t\t    has answered some other prompt.\n *\t\t    Set: When the ruler or typeahead display is overwritten,\n *\t\t    scrolling the screen for some message.\n * keep_msg\t    Message to be displayed after redrawing the screen, in\n *\t\t    main_loop().\n *\t\t    This is an allocated string or NULL when not used.\n */\n\n/*\n * msg(s) - displays the string 's' on the status line\n * When terminal not initialized (yet) mch_errmsg(..) is used.\n * return TRUE if wait_return not called\n */\n    int\nmsg(char *s)\n{\n    return msg_attr_keep(s, 0, FALSE);\n}\n\n/*\n * Like msg() but keep it silent when 'verbosefile' is set.\n */\n    int\nverb_msg(char *s)\n{\n    int\t\tn;\n\n    verbose_enter();\n    n = msg_attr_keep(s, 0, FALSE);\n    verbose_leave();\n\n    return n;\n}\n\n    int\nmsg_attr(char *s, int attr)\n{\n    return msg_attr_keep(s, attr, FALSE);\n}\n\n    int\nmsg_attr_keep(\n    char\t*s,\n    int\t\tattr,\n    int\t\tkeep)\t    // TRUE: set keep_msg if it doesn't scroll\n{\n    static int\tentered = 0;\n    int\t\tretval;\n    char_u\t*buf = NULL;\n\n    // Skip messages not matching \":filter pattern\".\n    // Don't filter when there is an error.\n    if (!emsg_on_display && message_filtered((char_u *)s))\n\treturn TRUE;\n\n#ifdef FEAT_EVAL\n    if (attr == 0)\n\tset_vim_var_string(VV_STATUSMSG, (char_u *)s, -1);\n#endif\n\n    /*\n     * It is possible that displaying a messages causes a problem (e.g.,\n     * when redrawing the window), which causes another message, etc..\tTo\n     * break this loop, limit the recursiveness to 3 levels.\n     */\n    if (entered >= 3)\n\treturn TRUE;\n    ++entered;\n\n    // Add message to history (unless it's a repeated kept message or a\n    // truncated message)\n    if ((char_u *)s != keep_msg\n\t    || (*s != '<'\n\t\t&& last_msg_hist != NULL\n\t\t&& last_msg_hist->msg != NULL\n\t\t&& STRCMP(s, last_msg_hist->msg)))\n\tadd_msg_hist((char_u *)s, -1, attr);\n\n#ifdef FEAT_JOB_CHANNEL\n    if (emsg_to_channel_log)\n\t// Write message in the channel log.\n\tch_log(NULL, \"ERROR: %s\", (char *)s);\n#endif\n\n    // Truncate the message if needed.\n    msg_start();\n    buf = msg_strtrunc((char_u *)s, FALSE);\n    if (buf != NULL)\n\ts = (char *)buf;\n\n    msg_outtrans_attr((char_u *)s, attr);\n    msg_clr_eos();\n    retval = msg_end();\n\n    if (keep && retval && vim_strsize((char_u *)s)\n\t\t\t    < (int)(Rows - cmdline_row - 1) * Columns + sc_col)\n\tset_keep_msg((char_u *)s, 0);\n\n    vim_free(buf);\n    --entered;\n    return retval;\n}\n\n/*\n * Truncate a string such that it can be printed without causing a scroll.\n * Returns an allocated string or NULL when no truncating is done.\n */\n    char_u *\nmsg_strtrunc(\n    char_u\t*s,\n    int\t\tforce)\t    // always truncate\n{\n    char_u\t*buf = NULL;\n    int\t\tlen;\n    int\t\troom;\n\n    // May truncate message to avoid a hit-return prompt\n    if ((!msg_scroll && !need_wait_return && shortmess(SHM_TRUNCALL)\n\t\t\t       && !exmode_active && msg_silent == 0) || force)\n    {\n\tlen = vim_strsize(s);\n\tif (msg_scrolled != 0)\n\t    // Use all the columns.\n\t    room = (int)(Rows - msg_row) * Columns - 1;\n\telse\n\t    // Use up to 'showcmd' column.\n\t    room = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;\n\tif (len > room && room > 0)\n\t{\n\t    if (enc_utf8)\n\t\t// may have up to 18 bytes per cell (6 per char, up to two\n\t\t// composing chars)\n\t\tlen = (room + 2) * 18;\n\t    else if (enc_dbcs == DBCS_JPNU)\n\t\t// may have up to 2 bytes per cell for euc-jp\n\t\tlen = (room + 2) * 2;\n\t    else\n\t\tlen = room + 2;\n\t    buf = alloc(len);\n\t    if (buf != NULL)\n\t\ttrunc_string(s, buf, room, len);\n\t}\n    }\n    return buf;\n}\n\n/*\n * Truncate a string \"s\" to \"buf\" with cell width \"room\".\n * \"s\" and \"buf\" may be equal.\n */\n    void\ntrunc_string(\n    char_u\t*s,\n    char_u\t*buf,\n    int\t\troom_in,\n    int\t\tbuflen)\n{\n    size_t\troom = room_in - 3; // \"...\" takes 3 chars\n    size_t\thalf;\n    size_t\tlen = 0;\n    int\t\te;\n    int\t\ti;\n    int\t\tn;\n\n    if (*s == NUL)\n    {\n\tif (buflen > 0)\n\t    *buf = NUL;\n\treturn;\n    }\n\n    if (room_in < 3)\n\troom = 0;\n    half = room / 2;\n\n    // First part: Start of the string.\n    for (e = 0; len < half && e < buflen; ++e)\n    {\n\tif (s[e] == NUL)\n\t{\n\t    // text fits without truncating!\n\t    buf[e] = NUL;\n\t    return;\n\t}\n\tn = ptr2cells(s + e);\n\tif (len + n > half)\n\t    break;\n\tlen += n;\n\tbuf[e] = s[e];\n\tif (has_mbyte)\n\t    for (n = (*mb_ptr2len)(s + e); --n > 0; )\n\t    {\n\t\tif (++e == buflen)\n\t\t    break;\n\t\tbuf[e] = s[e];\n\t    }\n    }\n\n    // Last part: End of the string.\n    i = e;\n    if (enc_dbcs != 0)\n    {\n\t// For DBCS going backwards in a string is slow, but\n\t// computing the cell width isn't too slow: go forward\n\t// until the rest fits.\n\tn = vim_strsize(s + i);\n\twhile (len + n > room)\n\t{\n\t    n -= ptr2cells(s + i);\n\t    i += (*mb_ptr2len)(s + i);\n\t}\n    }\n    else if (enc_utf8)\n    {\n\t// For UTF-8 we can go backwards easily.\n\thalf = i = (int)STRLEN(s);\n\tfor (;;)\n\t{\n\t    do\n\t\thalf = half - utf_head_off(s, s + half - 1) - 1;\n\t    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));\n\t    n = ptr2cells(s + half);\n\t    if (len + n > room || half == 0)\n\t\tbreak;\n\t    len += n;\n\t    i = (int)half;\n\t}\n    }\n    else\n    {\n\tfor (i = (int)STRLEN(s);\n\t\t   i - 1 >= 0 && len + (n = ptr2cells(s + i - 1)) <= room; --i)\n\t    len += n;\n    }\n\n\n    if (i <= e + 3)\n    {\n\t// text fits without truncating\n\tif (s != buf)\n\t{\n\t    len = STRLEN(s);\n\t    if (len >= (size_t)buflen)\n\t\tlen = buflen - 1;\n\t    len = len - e + 1;\n\t    if (len < 1)\n\t\tbuf[e - 1] = NUL;\n\t    else\n\t\tmch_memmove(buf + e, s + e, len);\n\t}\n    }\n    else if (e + 3 < buflen)\n    {\n\t// set the middle and copy the last part\n\tmch_memmove(buf + e, \"...\", (size_t)3);\n\tlen = STRLEN(s + i) + 1;\n\tif (len >= (size_t)buflen - e - 3)\n\t    len = buflen - e - 3 - 1;\n\tmch_memmove(buf + e + 3, s + i, len);\n\tbuf[e + 3 + len - 1] = NUL;\n    }\n    else\n    {\n\t// can't fit in the \"...\", just truncate it\n\tbuf[e - 1] = NUL;\n    }\n}\n\n/*\n * Automatic prototype generation does not understand this function.\n * Note: Caller of smsg() and smsg_attr() must check the resulting string is\n * shorter than IOSIZE!!!\n */\n#ifndef PROTO\n\nint vim_snprintf(char *str, size_t str_m, const char *fmt, ...);\n\n    int\nsmsg(const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg((char *)s);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg((char *)IObuff);\n    }\n}\n\n    int\nsmsg_attr(int attr, const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg_attr((char *)s, attr);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg_attr((char *)IObuff, attr);\n    }\n}\n\n    int\nsmsg_attr_keep(int attr, const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg_attr_keep((char *)s, attr, TRUE);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg_attr_keep((char *)IObuff, attr, TRUE);\n    }\n}\n\n#endif\n\n/*\n * Remember the last sourcing name/lnum used in an error message, so that it\n * isn't printed each time when it didn't change.\n */\nstatic int\tlast_sourcing_lnum = 0;\nstatic char_u   *last_sourcing_name = NULL;\n\n/*\n * Reset the last used sourcing name/lnum.  Makes sure it is displayed again\n * for the next error message;\n */\n    void\nreset_last_sourcing(void)\n{\n    VIM_CLEAR(last_sourcing_name);\n    last_sourcing_lnum = 0;\n}\n\n/*\n * Return TRUE if \"SOURCING_NAME\" differs from \"last_sourcing_name\".\n */\n    static int\nother_sourcing_name(void)\n{\n    if (HAVE_SOURCING_INFO && SOURCING_NAME != NULL)\n    {\n\tif (last_sourcing_name != NULL)\n\t    return STRCMP(SOURCING_NAME, last_sourcing_name) != 0;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Get the message about the source, as used for an error message.\n * Returns an allocated string with room for one more character.\n * Returns NULL when no message is to be given.\n */\n    static char_u *\nget_emsg_source(void)\n{\n    char_u\t*Buf, *p;\n\n    if (HAVE_SOURCING_INFO && SOURCING_NAME != NULL && other_sourcing_name())\n    {\n\tchar_u\t    *sname = estack_sfile(ESTACK_NONE);\n\tchar_u\t    *tofree = sname;\n\n\tif (sname == NULL)\n\t    sname = SOURCING_NAME;\n\n#ifdef FEAT_EVAL\n\tif (estack_compiling)\n\t    p = (char_u *)_(\"Error detected while compiling %s:\");\n\telse\n#endif\n\t    p = (char_u *)_(\"Error detected while processing %s:\");\n\tBuf = alloc(STRLEN(sname) + STRLEN(p));\n\tif (Buf != NULL)\n\t    sprintf((char *)Buf, (char *)p, sname);\n\tvim_free(tofree);\n\treturn Buf;\n    }\n    return NULL;\n}\n\n/*\n * Get the message about the source lnum, as used for an error message.\n * Returns an allocated string with room for one more character.\n * Returns NULL when no message is to be given.\n */\n    static char_u *\nget_emsg_lnum(void)\n{\n    char_u\t*Buf, *p;\n\n    // lnum is 0 when executing a command from the command line\n    // argument, we don't want a line number then\n    if (SOURCING_NAME != NULL\n\t    && (other_sourcing_name() || SOURCING_LNUM != last_sourcing_lnum)\n\t    && SOURCING_LNUM != 0)\n    {\n\tp = (char_u *)_(\"line %4ld:\");\n\tBuf = alloc(STRLEN(p) + 20);\n\tif (Buf != NULL)\n\t    sprintf((char *)Buf, (char *)p, (long)SOURCING_LNUM);\n\treturn Buf;\n    }\n    return NULL;\n}\n\n/*\n * Display name and line number for the source of an error.\n * Remember the file name and line number, so that for the next error the info\n * is only displayed if it changed.\n */\n    void\nmsg_source(int attr)\n{\n    char_u\t*p;\n    static int\trecursive = FALSE;\n\n    // Bail out if something called here causes an error.\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n\n    ++no_wait_return;\n    p = get_emsg_source();\n    if (p != NULL)\n    {\n\tmsg_attr((char *)p, attr);\n\tvim_free(p);\n    }\n    p = get_emsg_lnum();\n    if (p != NULL)\n    {\n\tmsg_attr((char *)p, HL_ATTR(HLF_N));\n\tvim_free(p);\n\tlast_sourcing_lnum = SOURCING_LNUM;  // only once for each line\n    }\n\n    // remember the last sourcing name printed, also when it's empty\n    if (SOURCING_NAME == NULL || other_sourcing_name())\n    {\n\tVIM_CLEAR(last_sourcing_name);\n\tif (SOURCING_NAME != NULL)\n\t    last_sourcing_name = vim_strsave(SOURCING_NAME);\n    }\n    --no_wait_return;\n\n    recursive = FALSE;\n}\n\n/*\n * Return TRUE if not giving error messages right now:\n * If \"emsg_off\" is set: no error messages at the moment.\n * If \"msg\" is in 'debug': do error message but without side effects.\n * If \"emsg_skip\" is set: never do error messages.\n */\n    static int\nemsg_not_now(void)\n{\n    if ((emsg_off > 0 && vim_strchr(p_debug, 'm') == NULL\n\t\t\t\t\t  && vim_strchr(p_debug, 't') == NULL)\n#ifdef FEAT_EVAL\n\t    || emsg_skip > 0\n#endif\n\t    )\n\treturn TRUE;\n    return FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic garray_T ignore_error_list = GA_EMPTY;\n\n    void\nignore_error_for_testing(char_u *error)\n{\n    if (ignore_error_list.ga_itemsize == 0)\n\tga_init2(&ignore_error_list, sizeof(char_u *), 1);\n\n    if (STRCMP(\"RESET\", error) == 0)\n\tga_clear_strings(&ignore_error_list);\n    else\n\tga_add_string(&ignore_error_list, error);\n}\n\n    static int\nignore_error(char_u *msg)\n{\n    int i;\n\n    for (i = 0; i < ignore_error_list.ga_len; ++i)\n\tif (strstr((char *)msg,\n\t\t  (char *)((char_u **)(ignore_error_list.ga_data))[i]) != NULL)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n#if !defined(HAVE_STRERROR) || defined(PROTO)\n/*\n * Replacement for perror() that behaves more or less like emsg() was called.\n * v:errmsg will be set and called_emsg will be incremented.\n */\n    void\ndo_perror(char *msg)\n{\n    perror(msg);\n    ++emsg_silent;\n    emsg(msg);\n    --emsg_silent;\n}\n#endif\n\n/*\n * emsg_core() - display an error message\n *\n * Rings the bell, if appropriate, and calls message() to do the real work\n * When terminal not initialized (yet) mch_errmsg(..) is used.\n *\n * Return TRUE if wait_return not called.\n * Note: caller must check 'emsg_not_now()' before calling this.\n */\n    static int\nemsg_core(char_u *s)\n{\n    int\t\tattr;\n    char_u\t*p;\n    int\t\tr;\n#ifdef FEAT_EVAL\n    int\t\tignore = FALSE;\n    int\t\tsevere;\n#endif\n\n#ifdef FEAT_EVAL\n    // When testing some errors are turned into a normal message.\n    if (ignore_error(s))\n\t// don't call msg() if it results in a dialog\n\treturn msg_use_printf() ? FALSE : msg((char *)s);\n#endif\n\n    ++called_emsg;\n\n#ifdef FEAT_EVAL\n    // If \"emsg_severe\" is TRUE: When an error exception is to be thrown,\n    // prefer this message over previous messages for the same command.\n    severe = emsg_severe;\n    emsg_severe = FALSE;\n#endif\n\n    if (!emsg_off || vim_strchr(p_debug, 't') != NULL)\n    {\n#ifdef FEAT_EVAL\n\t/*\n\t * Cause a throw of an error exception if appropriate.  Don't display\n\t * the error message in this case.  (If no matching catch clause will\n\t * be found, the message will be displayed later on.)  \"ignore\" is set\n\t * when the message should be ignored completely (used for the\n\t * interrupt message).\n\t */\n\tif (cause_errthrow(s, severe, &ignore) == TRUE)\n\t{\n\t    if (!ignore)\n\t\t++did_emsg;\n\t    return TRUE;\n\t}\n\n\tif (in_assert_fails && emsg_assert_fails_msg == NULL)\n\t{\n\t    emsg_assert_fails_msg = vim_strsave(s);\n\t    emsg_assert_fails_lnum = SOURCING_LNUM;\n\t    vim_free(emsg_assert_fails_context);\n\t    emsg_assert_fails_context = vim_strsave(\n\t\t\t SOURCING_NAME == NULL ? (char_u *)\"\" : SOURCING_NAME);\n\t}\n\n\t// set \"v:errmsg\", also when using \":silent! cmd\"\n\tset_vim_var_string(VV_ERRMSG, s, -1);\n#endif\n\n\t/*\n\t * When using \":silent! cmd\" ignore error messages.\n\t * But do write it to the redirection file.\n\t */\n\tif (emsg_silent != 0)\n\t{\n#ifdef FEAT_EVAL\n\t    ++did_emsg_silent;\n#endif\n\t    if (emsg_noredir == 0)\n\t    {\n\t\tmsg_start();\n\t\tp = get_emsg_source();\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(p, \"\\n\");\n\t\t    redir_write(p, -1);\n\t\t    vim_free(p);\n\t\t}\n\t\tp = get_emsg_lnum();\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(p, \"\\n\");\n\t\t    redir_write(p, -1);\n\t\t    vim_free(p);\n\t\t}\n\t\tredir_write(s, -1);\n\t    }\n#ifdef FEAT_EVAL\n\t    // Only increment did_emsg_def when :silent! wasn't used inside the\n\t    // :def function.\n\t    if (emsg_silent == emsg_silent_def)\n\t\t++did_emsg_def;\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t    ch_log(NULL, \"ERROR silent: %s\", (char *)s);\n#endif\n\t    return TRUE;\n\t}\n\n\tex_exitval = 1;\n\n\t// Reset msg_silent, an error causes messages to be switched back on.\n\tmsg_silent = 0;\n\tcmd_silent = FALSE;\n\n\tif (global_busy)\t\t// break :global command\n\t    ++global_busy;\n\n\tif (p_eb)\n\t    beep_flush();\t\t// also includes flush_buffers()\n\telse\n\t    flush_buffers(FLUSH_MINIMAL);  // flush internal buffers\n\t++did_emsg;\t\t\t   // flag for DoOneCmd()\n#ifdef FEAT_EVAL\n\t++uncaught_emsg;\n#endif\n    }\n\n    emsg_on_display = TRUE;\t// remember there is an error message\n    ++msg_scroll;\t\t// don't overwrite a previous message\n    attr = HL_ATTR(HLF_E);\t// set highlight mode for error messages\n    if (msg_scrolled != 0)\n\tneed_wait_return = TRUE;    // needed in case emsg() is called after\n\t\t\t\t    // wait_return has reset need_wait_return\n\t\t\t\t    // and a redraw is expected because\n\t\t\t\t    // msg_scrolled is non-zero\n\n#ifdef FEAT_JOB_CHANNEL\n    emsg_to_channel_log = TRUE;\n#endif\n    /*\n     * Display name and line number for the source of the error.\n     */\n    msg_source(attr);\n\n    /*\n     * Display the error message itself.\n     */\n    msg_nowait = FALSE;\t\t\t// wait for this msg\n    r = msg_attr((char *)s, attr);\n\n#ifdef FEAT_JOB_CHANNEL\n    emsg_to_channel_log = FALSE;\n#endif\n    return r;\n}\n\n/*\n * Print an error message.\n */\n    int\nemsg(char *s)\n{\n    // Skip this if not giving error messages at the moment.\n    if (!emsg_not_now())\n\treturn emsg_core((char_u *)s);\n    return TRUE;\t\t// no error messages at the moment\n}\n\n#ifndef PROTO  // manual proto with __attribute__\n/*\n * Print an error message with format string and variable arguments.\n * Note: caller must not pass 'IObuff' as 1st argument.\n */\n    int\nsemsg(const char *s, ...)\n{\n    // Skip this if not giving error messages at the moment.\n    if (!emsg_not_now())\n    {\n\tif (IObuff == NULL)\n\t{\n\t    // Very early in initialisation and already something wrong, just\n\t    // give the raw message so the user at least gets a hint.\n\t    return emsg_core((char_u *)s);\n\t}\n\telse\n\t{\n\t    va_list ap;\n\n\t    va_start(ap, s);\n\t    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\t    va_end(ap);\n\t    return emsg_core(IObuff);\n\t}\n    }\n    return TRUE;\t\t// no error messages at the moment\n}\n#endif\n\n/*\n * Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is\n * defined. It is used for internal errors only, so that they can be\n * detected when fuzzing vim.\n */\n    void\niemsg(char *s)\n{\n    if (!emsg_not_now())\n    {\n\temsg_core((char_u *)s);\n#if defined(ABORT_ON_INTERNAL_ERROR) && defined(FEAT_EVAL)\n\tset_vim_var_string(VV_ERRMSG, (char_u *)s, -1);\n\tabort();\n#endif\n    }\n}\n\n#ifndef PROTO  // manual proto with __attribute__\n/*\n * Same as semsg(...) but abort on error when ABORT_ON_INTERNAL_ERROR is\n * defined. It is used for internal errors only, so that they can be\n * detected when fuzzing vim.\n * Note: caller must not pass 'IObuff' as 1st argument.\n */\n    void\nsiemsg(const char *s, ...)\n{\n    if (!emsg_not_now())\n    {\n\tif (IObuff == NULL)\n\t{\n\t    // Very early in initialisation and already something wrong, just\n\t    // give the raw message so the user at least gets a hint.\n\t    emsg_core((char_u *)s);\n\t}\n\telse\n\t{\n\t    va_list ap;\n\n\t    va_start(ap, s);\n\t    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\t    va_end(ap);\n\t    emsg_core(IObuff);\n\t}\n    }\n# ifdef ABORT_ON_INTERNAL_ERROR\n    abort();\n# endif\n}\n#endif\n\n/*\n * Give an \"Internal error\" message.\n */\n    void\ninternal_error(char *where)\n{\n    siemsg(_(e_internal_error_str), where);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Like internal_error() but do not call abort(), to avoid tests using\n * test_unknown() and test_void() causing Vim to exit.\n */\n    void\ninternal_error_no_abort(char *where)\n{\n     semsg(_(e_internal_error_str), where);\n}\n#endif\n\n// emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes.\n\n    void\nemsg_invreg(int name)\n{\n    semsg(_(e_invalid_register_name_str), transchar(name));\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Give an error message which contains %s for \"name[len]\".\n */\n    void\nemsg_namelen(char *msg, char_u *name, int len)\n{\n    char_u *copy = vim_strnsave((char_u *)name, len);\n\n    semsg(msg, copy == NULL ? \"NULL\" : (char *)copy);\n    vim_free(copy);\n}\n#endif\n\n/*\n * Like msg(), but truncate to a single line if p_shm contains 't', or when\n * \"force\" is TRUE.  This truncates in another way as for normal messages.\n * Careful: The string may be changed by msg_may_trunc()!\n * Returns a pointer to the printed message, if wait_return() not called.\n */\n    char *\nmsg_trunc_attr(char *s, int force, int attr)\n{\n    int\t\tn;\n    char\t*ts;\n\n    // Add message to history before truncating\n    add_msg_hist((char_u *)s, -1, attr);\n\n    ts = (char *)msg_may_trunc(force, (char_u *)s);\n\n    msg_hist_off = TRUE;\n    n = msg_attr(ts, attr);\n    msg_hist_off = FALSE;\n\n    if (n)\n\treturn ts;\n    return NULL;\n}\n\n/*\n * Check if message \"s\" should be truncated at the start (for filenames).\n * Return a pointer to where the truncated message starts.\n * Note: May change the message by replacing a character with '<'.\n */\n    char_u *\nmsg_may_trunc(int force, char_u *s)\n{\n    int\t\tn;\n    int\t\troom;\n\n    room = (int)(Rows - cmdline_row - 1) * Columns + sc_col - 1;\n    if ((force || (shortmess(SHM_TRUNC) && !exmode_active))\n\t    && (n = (int)STRLEN(s) - room) > 0)\n    {\n\tif (has_mbyte)\n\t{\n\t    int\tsize = vim_strsize(s);\n\n\t    // There may be room anyway when there are multibyte chars.\n\t    if (size <= room)\n\t\treturn s;\n\n\t    for (n = 0; size >= room; )\n\t    {\n\t\tsize -= (*mb_ptr2cells)(s + n);\n\t\tn += (*mb_ptr2len)(s + n);\n\t    }\n\t    --n;\n\t}\n\ts += n;\n\t*s = '<';\n    }\n    return s;\n}\n\n    static void\nadd_msg_hist(\n    char_u\t*s,\n    int\t\tlen,\t\t// -1 for undetermined length\n    int\t\tattr)\n{\n    struct msg_hist *p;\n\n    if (msg_hist_off || msg_silent != 0)\n\treturn;\n\n    // Don't let the message history get too big\n    while (msg_hist_len > MAX_MSG_HIST_LEN)\n\t(void)delete_first_msg();\n\n    // allocate an entry and add the message at the end of the history\n    p = ALLOC_ONE(struct msg_hist);\n    if (p != NULL)\n    {\n\tif (len < 0)\n\t    len = (int)STRLEN(s);\n\t// remove leading and trailing newlines\n\twhile (len > 0 && *s == '\\n')\n\t{\n\t    ++s;\n\t    --len;\n\t}\n\twhile (len > 0 && s[len - 1] == '\\n')\n\t    --len;\n\tp->msg = vim_strnsave(s, len);\n\tp->next = NULL;\n\tp->attr = attr;\n\tif (last_msg_hist != NULL)\n\t    last_msg_hist->next = p;\n\tlast_msg_hist = p;\n\tif (first_msg_hist == NULL)\n\t    first_msg_hist = last_msg_hist;\n\t++msg_hist_len;\n    }\n}\n\n/*\n * Delete the first (oldest) message from the history.\n * Returns FAIL if there are no messages.\n */\n    int\ndelete_first_msg(void)\n{\n    struct msg_hist *p;\n\n    if (msg_hist_len <= 0)\n\treturn FAIL;\n    p = first_msg_hist;\n    first_msg_hist = p->next;\n    if (first_msg_hist == NULL)\n\tlast_msg_hist = NULL;  // history is empty\n    vim_free(p->msg);\n    vim_free(p);\n    --msg_hist_len;\n    return OK;\n}\n\n/*\n * \":messages\" command.\n */\n    void\nex_messages(exarg_T *eap)\n{\n    struct msg_hist *p;\n    char_u\t    *s;\n    int\t\t    c = 0;\n\n    if (STRCMP(eap->arg, \"clear\") == 0)\n    {\n\tint keep = eap->addr_count == 0 ? 0 : eap->line2;\n\n\twhile (msg_hist_len > keep)\n\t    (void)delete_first_msg();\n\treturn;\n    }\n\n    if (*eap->arg != NUL)\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    msg_hist_off = TRUE;\n\n    p = first_msg_hist;\n    if (eap->addr_count != 0)\n    {\n\t// Count total messages\n\tfor (; p != NULL && !got_int; p = p->next)\n\t    c++;\n\n\tc -= eap->line2;\n\n\t// Skip without number of messages specified\n\tfor (p = first_msg_hist; p != NULL && !got_int && c > 0;\n\t\t\t\t\t\t    p = p->next, c--);\n    }\n\n    if (p == first_msg_hist)\n    {\n#ifdef FEAT_MULTI_LANG\n\ts = get_mess_lang();\n#else\n\ts = mch_getenv((char_u *)\"LANG\");\n#endif\n\tif (s != NULL && *s != NUL)\n\t    // The next comment is extracted by xgettext and put in po file for\n\t    // translators to read.\n\t    msg_attr(\n\t\t    // Translator: Please replace the name and email address\n\t\t    // with the appropriate text for your translation.\n\t\t    _(\"Messages maintainer: Bram Moolenaar <Bram@vim.org>\"),\n\t\t    HL_ATTR(HLF_T));\n    }\n\n    // Display what was not skipped.\n    for (; p != NULL && !got_int; p = p->next)\n\tif (p->msg != NULL)\n\t    msg_attr((char *)p->msg, p->attr);\n\n    msg_hist_off = FALSE;\n}\n\n#if defined(FEAT_CON_DIALOG) || defined(FIND_REPLACE_DIALOG) || defined(PROTO)\n/*\n * Call this after prompting the user.  This will avoid a hit-return message\n * and a delay.\n */\n    void\nmsg_end_prompt(void)\n{\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    cmdline_row = msg_row;\n    msg_col = 0;\n    msg_clr_eos();\n    lines_left = -1;\n}\n#endif\n\n/*\n * Wait for the user to hit a key (normally Enter).\n * If \"redraw\" is TRUE, clear and redraw the screen.\n * If \"redraw\" is FALSE, just redraw the screen.\n * If \"redraw\" is -1, don't redraw at all.\n */\n    void\nwait_return(int redraw)\n{\n    int\t\tc;\n    int\t\toldState;\n    int\t\ttmpState;\n    int\t\thad_got_int;\n    int\t\tsave_reg_recording;\n    FILE\t*save_scriptout;\n\n    if (redraw == TRUE)\n\tmust_redraw = CLEAR;\n\n    // If using \":silent cmd\", don't wait for a return.  Also don't set\n    // need_wait_return to do it later.\n    if (msg_silent != 0)\n\treturn;\n\n    /*\n     * When inside vgetc(), we can't wait for a typed character at all.\n     * With the global command (and some others) we only need one return at\n     * the end. Adjust cmdline_row to avoid the next message overwriting the\n     * last one.\n     */\n    if (vgetc_busy > 0)\n\treturn;\n    need_wait_return = TRUE;\n    if (no_wait_return)\n    {\n\tif (!exmode_active)\n\t    cmdline_row = msg_row;\n\treturn;\n    }\n\n    redir_off = TRUE;\t\t// don't redirect this message\n    oldState = State;\n    if (quit_more)\n    {\n\tc = CAR;\t\t// just pretend CR was hit\n\tquit_more = FALSE;\n\tgot_int = FALSE;\n    }\n    else if (exmode_active)\n    {\n\tmsg_puts(\" \");\t\t// make sure the cursor is on the right line\n\tc = CAR;\t\t// no need for a return in ex mode\n\tgot_int = FALSE;\n    }\n    else\n    {\n\t// Make sure the hit-return prompt is on screen when 'guioptions' was\n\t// just changed.\n\tscreenalloc(FALSE);\n\n\tState = HITRETURN;\n\tsetmouse();\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\tcmdline_row = msg_row;\n\n\t// Avoid the sequence that the user types \":\" at the hit-return prompt\n\t// to start an Ex command, but the file-changed dialog gets in the\n\t// way.\n\tif (need_check_timestamps)\n\t    check_timestamps(FALSE);\n\n\thit_return_msg();\n\n\tdo\n\t{\n\t    // Remember \"got_int\", if it is set vgetc() probably returns a\n\t    // CTRL-C, but we need to loop then.\n\t    had_got_int = got_int;\n\n\t    // Don't do mappings here, we put the character back in the\n\t    // typeahead buffer.\n\t    ++no_mapping;\n\t    ++allow_keys;\n\n\t    // Temporarily disable Recording. If Recording is active, the\n\t    // character will be recorded later, since it will be added to the\n\t    // typebuf after the loop\n\t    save_reg_recording = reg_recording;\n\t    save_scriptout = scriptout;\n\t    reg_recording = 0;\n\t    scriptout = NULL;\n\t    c = safe_vgetc();\n\t    if (had_got_int && !global_busy)\n\t\tgot_int = FALSE;\n\t    --no_mapping;\n\t    --allow_keys;\n\t    reg_recording = save_reg_recording;\n\t    scriptout = save_scriptout;\n\n#ifdef FEAT_CLIPBOARD\n\t    // Strange way to allow copying (yanking) a modeless selection at\n\t    // the hit-enter prompt.  Use CTRL-Y, because the same is used in\n\t    // Cmdline-mode and it's harmless when there is no selection.\n\t    if (c == Ctrl_Y && clip_star.state == SELECT_DONE)\n\t    {\n\t\tclip_copy_modeless_selection(TRUE);\n\t\tc = K_IGNORE;\n\t    }\n#endif\n\n\t    /*\n\t     * Allow scrolling back in the messages.\n\t     * Also accept scroll-down commands when messages fill the screen,\n\t     * to avoid that typing one 'j' too many makes the messages\n\t     * disappear.\n\t     */\n\t    if (p_more && !p_cp)\n\t    {\n\t\tif (c == 'b' || c == 'k' || c == 'u' || c == 'g'\n\t\t\t\t\t\t|| c == K_UP || c == K_PAGEUP)\n\t\t{\n\t\t    if (msg_scrolled > Rows)\n\t\t\t// scroll back to show older messages\n\t\t\tdo_more_prompt(c);\n\t\t    else\n\t\t    {\n\t\t\tmsg_didout = FALSE;\n\t\t\tc = K_IGNORE;\n\t\t\tmsg_col =\n#ifdef FEAT_RIGHTLEFT\n\t\t\t    cmdmsg_rl ? Columns - 1 :\n#endif\n\t\t\t    0;\n\t\t    }\n\t\t    if (quit_more)\n\t\t    {\n\t\t\tc = CAR;\t\t// just pretend CR was hit\n\t\t\tquit_more = FALSE;\n\t\t\tgot_int = FALSE;\n\t\t    }\n\t\t    else if (c != K_IGNORE)\n\t\t    {\n\t\t\tc = K_IGNORE;\n\t\t\thit_return_msg();\n\t\t    }\n\t\t}\n\t\telse if (msg_scrolled > Rows - 2\n\t\t\t && (c == 'j' || c == 'd' || c == 'f'\n\t\t\t\t\t   || c == K_DOWN || c == K_PAGEDOWN))\n\t\t    c = K_IGNORE;\n\t    }\n\t} while ((had_got_int && c == Ctrl_C)\n\t\t\t\t|| c == K_IGNORE\n#ifdef FEAT_GUI\n\t\t\t\t|| c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR\n#endif\n\t\t\t\t|| c == K_LEFTDRAG   || c == K_LEFTRELEASE\n\t\t\t\t|| c == K_MIDDLEDRAG || c == K_MIDDLERELEASE\n\t\t\t\t|| c == K_RIGHTDRAG  || c == K_RIGHTRELEASE\n\t\t\t\t|| c == K_MOUSELEFT  || c == K_MOUSERIGHT\n\t\t\t\t|| c == K_MOUSEDOWN  || c == K_MOUSEUP\n\t\t\t\t|| c == K_MOUSEMOVE\n\t\t\t\t|| (!mouse_has(MOUSE_RETURN)\n\t\t\t\t    && mouse_row < msg_row\n\t\t\t\t    && (c == K_LEFTMOUSE\n\t\t\t\t\t|| c == K_MIDDLEMOUSE\n\t\t\t\t\t|| c == K_RIGHTMOUSE\n\t\t\t\t\t|| c == K_X1MOUSE\n\t\t\t\t\t|| c == K_X2MOUSE))\n\t\t\t\t);\n\tui_breakcheck();\n\t/*\n\t * Avoid that the mouse-up event causes visual mode to start.\n\t */\n\tif (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE\n\t\t\t\t\t  || c == K_X1MOUSE || c == K_X2MOUSE)\n\t    (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);\n\telse if (vim_strchr((char_u *)\"\\r\\n \", c) == NULL && c != Ctrl_C)\n\t{\n\t    // Put the character back in the typeahead buffer.  Don't use the\n\t    // stuff buffer, because lmaps wouldn't work.\n\t    ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\t    do_redraw = TRUE;\t    // need a redraw even though there is\n\t\t\t\t    // typeahead\n\t}\n    }\n    redir_off = FALSE;\n\n    /*\n     * If the user hits ':', '?' or '/' we get a command line from the next\n     * line.\n     */\n    if (c == ':' || c == '?' || c == '/')\n    {\n\tif (!exmode_active)\n\t    cmdline_row = msg_row;\n\tskip_redraw = TRUE;\t    // skip redraw once\n\tdo_redraw = FALSE;\n#ifdef FEAT_TERMINAL\n\tskip_term_loop = TRUE;\n#endif\n    }\n\n    /*\n     * If the window size changed set_shellsize() will redraw the screen.\n     * Otherwise the screen is only redrawn if 'redraw' is set and no ':'\n     * typed.\n     */\n    tmpState = State;\n    State = oldState;\t\t    // restore State before set_shellsize\n    setmouse();\n    msg_check();\n\n#if defined(UNIX) || defined(VMS)\n    /*\n     * When switching screens, we need to output an extra newline on exit.\n     */\n    if (swapping_screen() && !termcap_active)\n\tnewline_on_exit = TRUE;\n#endif\n\n    need_wait_return = FALSE;\n    did_wait_return = TRUE;\n    emsg_on_display = FALSE;\t// can delete error message now\n    lines_left = -1;\t\t// reset lines_left at next msg_start()\n    reset_last_sourcing();\n    if (keep_msg != NULL && vim_strsize(keep_msg) >=\n\t\t\t\t  (Rows - cmdline_row - 1) * Columns + sc_col)\n\tVIM_CLEAR(keep_msg);\t    // don't redisplay message, it's too long\n\n    if (tmpState == SETWSIZE)\t    // got resize event while in vgetc()\n    {\n\tstarttermcap();\t\t    // start termcap before redrawing\n\tshell_resized();\n    }\n    else if (!skip_redraw\n\t    && (redraw == TRUE || (msg_scrolled != 0 && redraw != -1)))\n    {\n\tstarttermcap();\t\t    // start termcap before redrawing\n\tredraw_later(VALID);\n    }\n}\n\n/*\n * Write the hit-return prompt.\n */\n    static void\nhit_return_msg(void)\n{\n    int\t\tsave_p_more = p_more;\n\n    p_more = FALSE;\t// don't want to see this message when scrolling back\n    if (msg_didout)\t// start on a new line\n\tmsg_putchar('\\n');\n    if (got_int)\n\tmsg_puts(_(\"Interrupt: \"));\n\n    msg_puts_attr(_(\"Press ENTER or type command to continue\"), HL_ATTR(HLF_R));\n    if (!msg_use_printf())\n\tmsg_clr_eos();\n    p_more = save_p_more;\n}\n\n/*\n * Set \"keep_msg\" to \"s\".  Free the old value and check for NULL pointer.\n */\n    void\nset_keep_msg(char_u *s, int attr)\n{\n    vim_free(keep_msg);\n    if (s != NULL && msg_silent == 0)\n\tkeep_msg = vim_strsave(s);\n    else\n\tkeep_msg = NULL;\n    keep_msg_more = FALSE;\n    keep_msg_attr = attr;\n}\n\n#if defined(FEAT_TERMRESPONSE) || defined(PROTO)\n/*\n * If there currently is a message being displayed, set \"keep_msg\" to it, so\n * that it will be displayed again after redraw.\n */\n    void\nset_keep_msg_from_hist(void)\n{\n    if (keep_msg == NULL && last_msg_hist != NULL && msg_scrolled == 0\n\t\t\t\t\t\t\t  && (State & NORMAL))\n\tset_keep_msg(last_msg_hist->msg, last_msg_hist->attr);\n}\n#endif\n\n/*\n * Prepare for outputting characters in the command line.\n */\n    void\nmsg_start(void)\n{\n    int\t\tdid_return = FALSE;\n\n    if (!msg_silent)\n\tVIM_CLEAR(keep_msg);\n\n#ifdef FEAT_EVAL\n    if (need_clr_eos)\n    {\n\t// Halfway an \":echo\" command and getting an (error) message: clear\n\t// any text from the command.\n\tneed_clr_eos = FALSE;\n\tmsg_clr_eos();\n    }\n#endif\n\n    if (!msg_scroll && full_screen)\t// overwrite last message\n    {\n\tmsg_row = cmdline_row;\n\tmsg_col =\n#ifdef FEAT_RIGHTLEFT\n\t    cmdmsg_rl ? Columns - 1 :\n#endif\n\t    0;\n    }\n    else if (msg_didout)\t\t    // start message on next line\n    {\n\tmsg_putchar('\\n');\n\tdid_return = TRUE;\n\tif (exmode_active != EXMODE_NORMAL)\n\t    cmdline_row = msg_row;\n    }\n    if (!msg_didany || lines_left < 0)\n\tmsg_starthere();\n    if (msg_silent == 0)\n    {\n\tmsg_didout = FALSE;\t\t    // no output on current line yet\n\tcursor_off();\n    }\n\n    // when redirecting, may need to start a new line.\n    if (!did_return)\n\tredir_write((char_u *)\"\\n\", -1);\n}\n\n/*\n * Note that the current msg position is where messages start.\n */\n    void\nmsg_starthere(void)\n{\n    lines_left = cmdline_row;\n    msg_didany = FALSE;\n}\n\n    void\nmsg_putchar(int c)\n{\n    msg_putchar_attr(c, 0);\n}\n\n    void\nmsg_putchar_attr(int c, int attr)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (IS_SPECIAL(c))\n    {\n\tbuf[0] = K_SPECIAL;\n\tbuf[1] = K_SECOND(c);\n\tbuf[2] = K_THIRD(c);\n\tbuf[3] = NUL;\n    }\n    else\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    msg_puts_attr((char *)buf, attr);\n}\n\n    void\nmsg_outnum(long n)\n{\n    char\tbuf[20];\n\n    sprintf(buf, \"%ld\", n);\n    msg_puts(buf);\n}\n\n    void\nmsg_home_replace(char_u *fname)\n{\n    msg_home_replace_attr(fname, 0);\n}\n\n#if defined(FEAT_FIND_ID) || defined(PROTO)\n    void\nmsg_home_replace_hl(char_u *fname)\n{\n    msg_home_replace_attr(fname, HL_ATTR(HLF_D));\n}\n#endif\n\n    static void\nmsg_home_replace_attr(char_u *fname, int attr)\n{\n    char_u\t*name;\n\n    name = home_replace_save(NULL, fname);\n    if (name != NULL)\n\tmsg_outtrans_attr(name, attr);\n    vim_free(name);\n}\n\n/*\n * Output 'len' characters in 'str' (including NULs) with translation\n * if 'len' is -1, output up to a NUL character.\n * Use attributes 'attr'.\n * Return the number of characters it takes on the screen.\n */\n    int\nmsg_outtrans(char_u *str)\n{\n    return msg_outtrans_attr(str, 0);\n}\n\n    int\nmsg_outtrans_attr(char_u *str, int attr)\n{\n    return msg_outtrans_len_attr(str, (int)STRLEN(str), attr);\n}\n\n    int\nmsg_outtrans_len(char_u *str, int len)\n{\n    return msg_outtrans_len_attr(str, len, 0);\n}\n\n/*\n * Output one character at \"p\".  Return pointer to the next character.\n * Handles multi-byte characters.\n */\n    char_u *\nmsg_outtrans_one(char_u *p, int attr)\n{\n    int\t\tl;\n\n    if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n    {\n\tmsg_outtrans_len_attr(p, l, attr);\n\treturn p + l;\n    }\n    msg_puts_attr((char *)transchar_byte(*p), attr);\n    return p + 1;\n}\n\n    int\nmsg_outtrans_len_attr(char_u *msgstr, int len, int attr)\n{\n    int\t\tretval = 0;\n    char_u\t*str = msgstr;\n    char_u\t*plain_start = msgstr;\n    char_u\t*s;\n    int\t\tmb_l;\n    int\t\tc;\n    int\t\tsave_got_int = got_int;\n\n    // Only quit when got_int was set in here.\n    got_int = FALSE;\n\n    // if MSG_HIST flag set, add message to history\n    if (attr & MSG_HIST)\n    {\n\tadd_msg_hist(str, len, attr);\n\tattr &= ~MSG_HIST;\n    }\n\n    // If the string starts with a composing character first draw a space on\n    // which the composing char can be drawn.\n    if (enc_utf8 && utf_iscomposing(utf_ptr2char(msgstr)))\n\tmsg_puts_attr(\" \", attr);\n\n    /*\n     * Go over the string.  Special characters are translated and printed.\n     * Normal characters are printed several at a time.\n     */\n    while (--len >= 0 && !got_int)\n    {\n\tif (enc_utf8)\n\t    // Don't include composing chars after the end.\n\t    mb_l = utfc_ptr2len_len(str, len + 1);\n\telse if (has_mbyte)\n\t    mb_l = (*mb_ptr2len)(str);\n\telse\n\t    mb_l = 1;\n\tif (has_mbyte && mb_l > 1)\n\t{\n\t    c = (*mb_ptr2char)(str);\n\t    if (vim_isprintc(c))\n\t\t// printable multi-byte char: count the cells.\n\t\tretval += (*mb_ptr2cells)(str);\n\t    else\n\t    {\n\t\t// unprintable multi-byte char: print the printable chars so\n\t\t// far and the translation of the unprintable char.\n\t\tif (str > plain_start)\n\t\t    msg_puts_attr_len((char *)plain_start,\n\t\t\t\t\t       (int)(str - plain_start), attr);\n\t\tplain_start = str + mb_l;\n\t\tmsg_puts_attr((char *)transchar(c),\n\t\t\t\t\t    attr == 0 ? HL_ATTR(HLF_8) : attr);\n\t\tretval += char2cells(c);\n\t    }\n\t    len -= mb_l - 1;\n\t    str += mb_l;\n\t}\n\telse\n\t{\n\t    s = transchar_byte(*str);\n\t    if (s[1] != NUL)\n\t    {\n\t\t// unprintable char: print the printable chars so far and the\n\t\t// translation of the unprintable char.\n\t\tif (str > plain_start)\n\t\t    msg_puts_attr_len((char *)plain_start,\n\t\t\t\t\t       (int)(str - plain_start), attr);\n\t\tplain_start = str + 1;\n\t\tmsg_puts_attr((char *)s, attr == 0 ? HL_ATTR(HLF_8) : attr);\n\t\tretval += (int)STRLEN(s);\n\t    }\n\t    else\n\t\t++retval;\n\t    ++str;\n\t}\n    }\n\n    if (str > plain_start && !got_int)\n\t// print the printable chars at the end\n\tmsg_puts_attr_len((char *)plain_start, (int)(str - plain_start), attr);\n\n    got_int |= save_got_int;\n\n    return retval;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    void\nmsg_make(char_u *arg)\n{\n    int\t    i;\n    static char_u *str = (char_u *)\"eeffoc\", *rs = (char_u *)\"Plon#dqg#vxjduB\";\n\n    arg = skipwhite(arg);\n    for (i = 5; *arg && i >= 0; --i)\n\tif (*arg++ != str[i])\n\t    break;\n    if (i < 0)\n    {\n\tmsg_putchar('\\n');\n\tfor (i = 0; rs[i]; ++i)\n\t    msg_putchar(rs[i] - 3);\n    }\n}\n#endif\n\n/*\n * Output the string 'str' up to a NUL character.\n * Return the number of characters it takes on the screen.\n *\n * If K_SPECIAL is encountered, then it is taken in conjunction with the\n * following character and shown as <F1>, <S-Up> etc.  Any other character\n * which is not printable shown in <> form.\n * If 'from' is TRUE (lhs of a mapping), a space is shown as <Space>.\n * If a character is displayed in one of these special ways, is also\n * highlighted (its highlight name is '8' in the p_hl variable).\n * Otherwise characters are not highlighted.\n * This function is used to show mappings, where we want to see how to type\n * the character/string -- webb\n */\n    int\nmsg_outtrans_special(\n    char_u\t*strstart,\n    int\t\tfrom,\t// TRUE for lhs of a mapping\n    int\t\tmaxlen) // screen columns, 0 for unlimited\n{\n    char_u\t*str = strstart;\n    int\t\tretval = 0;\n    char\t*text;\n    int\t\tattr;\n    int\t\tlen;\n\n    attr = HL_ATTR(HLF_8);\n    while (*str != NUL)\n    {\n\t// Leading and trailing spaces need to be displayed in <> form.\n\tif ((str == strstart || str[1] == NUL) && *str == ' ')\n\t{\n\t    text = \"<Space>\";\n\t    ++str;\n\t}\n\telse\n\t    text = (char *)str2special(&str, from);\n\tlen = vim_strsize((char_u *)text);\n\tif (maxlen > 0 && retval + len >= maxlen)\n\t    break;\n\t// Highlight special keys\n\tmsg_puts_attr(text, len > 1\n\t\t&& (*mb_ptr2len)((char_u *)text) <= 1 ? attr : 0);\n\tretval += len;\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the lhs or rhs of a mapping, with the key codes turned into printable\n * strings, in an allocated string.\n */\n    char_u *\nstr2special_save(\n    char_u  *str,\n    int\t    is_lhs)  // TRUE for lhs, FALSE for rhs\n{\n    garray_T\tga;\n    char_u\t*p = str;\n\n    ga_init2(&ga, 1, 40);\n    while (*p != NUL)\n\tga_concat(&ga, str2special(&p, is_lhs));\n    ga_append(&ga, NUL);\n    return (char_u *)ga.ga_data;\n}\n#endif\n\n/*\n * Return the printable string for the key codes at \"*sp\".\n * Used for translating the lhs or rhs of a mapping to printable chars.\n * Advances \"sp\" to the next code.\n */\n    char_u *\nstr2special(\n    char_u\t**sp,\n    int\t\tfrom)\t// TRUE for lhs of mapping\n{\n    int\t\t\tc;\n    static char_u\tbuf[7];\n    char_u\t\t*str = *sp;\n    int\t\t\tmodifiers = 0;\n    int\t\t\tspecial = FALSE;\n\n    if (has_mbyte)\n    {\n\tchar_u\t*p;\n\n\t// Try to un-escape a multi-byte character.  Return the un-escaped\n\t// string if it is a multi-byte character.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    return p;\n    }\n\n    c = *str;\n    if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n    {\n\tif (str[1] == KS_MODIFIER)\n\t{\n\t    modifiers = str[2];\n\t    str += 3;\n\t    c = *str;\n\t}\n\tif (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(str[1], str[2]);\n\t    str += 2;\n\t}\n\tif (IS_SPECIAL(c) || modifiers)\t// special key\n\t    special = TRUE;\n    }\n\n    if (has_mbyte && !IS_SPECIAL(c))\n    {\n\tint len = (*mb_ptr2len)(str);\n\n\t// For multi-byte characters check for an illegal byte.\n\tif (has_mbyte && MB_BYTE2LEN(*str) > len)\n\t{\n\t    transchar_nonprint(curbuf, buf, c);\n\t    *sp = str + 1;\n\t    return buf;\n\t}\n\t// Since 'special' is TRUE the multi-byte character 'c' will be\n\t// processed by get_special_key_name()\n\tc = (*mb_ptr2char)(str);\n\t*sp = str + len;\n    }\n    else\n\t*sp = str + 1;\n\n    // Make unprintable characters in <> form, also <M-Space> and <Tab>.\n    // Use <Space> only for lhs of a mapping.\n    if (special || char2cells(c) > 1 || (from && c == ' '))\n\treturn get_special_key_name(c, modifiers);\n    buf[0] = c;\n    buf[1] = NUL;\n    return buf;\n}\n\n/*\n * Translate a key sequence into special key names.\n */\n    void\nstr2specialbuf(char_u *sp, char_u *buf, int len)\n{\n    char_u\t*s;\n\n    *buf = NUL;\n    while (*sp)\n    {\n\ts = str2special(&sp, FALSE);\n\tif ((int)(STRLEN(s) + STRLEN(buf)) < len)\n\t    STRCAT(buf, s);\n    }\n}\n\n/*\n * print line for :print or :list command\n */\n    void\nmsg_prt_line(char_u *s, int list)\n{\n    int\t\tc;\n    int\t\tcol = 0;\n    int\t\tn_extra = 0;\n    int\t\tc_extra = 0;\n    int\t\tc_final = 0;\n    char_u\t*p_extra = NULL;\t    // init to make SASC shut up\n    int\t\tn;\n    int\t\tattr = 0;\n    char_u\t*trail = NULL;\n    char_u\t*lead = NULL;\n    int\t\tin_multispace = FALSE;\n    int\t\tmultispace_pos = 0;\n    int\t\tl;\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (curwin->w_p_list)\n\tlist = TRUE;\n\n    if (list)\n    {\n\t// find start of trailing whitespace\n\tif (curwin->w_lcs_chars.trail)\n\t{\n\t    trail = s + STRLEN(s);\n\t    while (trail > s && VIM_ISWHITE(trail[-1]))\n\t\t--trail;\n\t}\n\t// find end of leading whitespace\n\tif (curwin->w_lcs_chars.lead)\n\t{\n\t    lead = s;\n\t    while (VIM_ISWHITE(lead[0]))\n\t\tlead++;\n\t    // in a line full of spaces all of them are treated as trailing\n\t    if (*lead == NUL)\n\t\tlead = NULL;\n\t}\n    }\n\n    // output a space for an empty line, otherwise the line will be\n    // overwritten\n    if (*s == NUL && !(list && curwin->w_lcs_chars.eol != NUL))\n\tmsg_putchar(' ');\n\n    while (!got_int)\n    {\n\tif (n_extra > 0)\n\t{\n\t    --n_extra;\n\t    if (n_extra == 0 && c_final)\n\t\tc = c_final;\n\t    else if (c_extra)\n\t\tc = c_extra;\n\t    else\n\t\tc = *p_extra++;\n\t}\n\telse if (has_mbyte && (l = (*mb_ptr2len)(s)) > 1)\n\t{\n\t    col += (*mb_ptr2cells)(s);\n\t    if (l >= MB_MAXBYTES)\n\t    {\n\t\tSTRCPY(buf, \"?\");\n\t    }\n\t    else if (curwin->w_lcs_chars.nbsp != NUL && list\n\t\t    && (mb_ptr2char(s) == 160\n\t\t\t|| mb_ptr2char(s) == 0x202f))\n\t    {\n\t\tmb_char2bytes(curwin->w_lcs_chars.nbsp, buf);\n\t\tbuf[(*mb_ptr2len)(buf)] = NUL;\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(buf, s, (size_t)l);\n\t\tbuf[l] = NUL;\n\t    }\n\t    msg_puts((char *)buf);\n\t    s += l;\n\t    continue;\n\t}\n\telse\n\t{\n\t    attr = 0;\n\t    c = *s++;\n\t    in_multispace = c == ' '\n\t\t&& ((col > 0 && s[-2] == ' ') || *s == ' ');\n\t    if (!in_multispace)\n\t\tmultispace_pos = 0;\n\t    if (c == TAB && (!list || curwin->w_lcs_chars.tab1))\n\t    {\n\t\t// tab amount depends on current column\n#ifdef FEAT_VARTABS\n\t\tn_extra = tabstop_padding(col, curbuf->b_p_ts,\n\t\t\t\t\t\t    curbuf->b_p_vts_array) - 1;\n#else\n\t\tn_extra = curbuf->b_p_ts - col % curbuf->b_p_ts - 1;\n#endif\n\t\tif (!list)\n\t\t{\n\t\t    c = ' ';\n\t\t    c_extra = ' ';\n\t\t    c_final = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = (n_extra == 0 && curwin->w_lcs_chars.tab3)\n\t\t\t\t\t\t? curwin->w_lcs_chars.tab3\n\t\t\t\t\t\t: curwin->w_lcs_chars.tab1;\n\t\t    c_extra = curwin->w_lcs_chars.tab2;\n\t\t    c_final = curwin->w_lcs_chars.tab3;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t    }\n\t    else if (c == 160 && list && curwin->w_lcs_chars.nbsp != NUL)\n\t    {\n\t\tc = curwin->w_lcs_chars.nbsp;\n\t\tattr = HL_ATTR(HLF_8);\n\t    }\n\t    else if (c == NUL && list && curwin->w_lcs_chars.eol != NUL)\n\t    {\n\t\tp_extra = (char_u *)\"\";\n\t\tc_extra = NUL;\n\t\tc_final = NUL;\n\t\tn_extra = 1;\n\t\tc = curwin->w_lcs_chars.eol;\n\t\tattr = HL_ATTR(HLF_AT);\n\t\t--s;\n\t    }\n\t    else if (c != NUL && (n = byte2cells(c)) > 1)\n\t    {\n\t\tn_extra = n - 1;\n\t\tp_extra = transchar_byte(c);\n\t\tc_extra = NUL;\n\t\tc_final = NUL;\n\t\tc = *p_extra++;\n\t\t// Use special coloring to be able to distinguish <hex> from\n\t\t// the same in plain text.\n\t\tattr = HL_ATTR(HLF_8);\n\t    }\n\t    else if (c == ' ')\n\t    {\n\t\tif (lead != NULL && s <= lead)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.lead;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (trail != NULL && s > trail)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.trail;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (list && in_multispace\n\t\t\t&& curwin->w_lcs_chars.multispace != NULL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.multispace[multispace_pos++];\n\t\t    if (curwin->w_lcs_chars.multispace[multispace_pos] == NUL)\n\t\t\tmultispace_pos = 0;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (list && curwin->w_lcs_chars.space != NUL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.space;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t    }\n\t}\n\n\tif (c == NUL)\n\t    break;\n\n\tmsg_putchar_attr(c, attr);\n\tcol++;\n    }\n    msg_clr_eos();\n}\n\n/*\n * Use screen_puts() to output one multi-byte character.\n * Return the pointer \"s\" advanced to the next character.\n */\n    static char_u *\nscreen_puts_mbyte(char_u *s, int l, int attr)\n{\n    int\t\tcw;\n\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    cw = (*mb_ptr2cells)(s);\n    if (cw > 1 && (\n#ifdef FEAT_RIGHTLEFT\n\t\tcmdmsg_rl ? msg_col <= 1 :\n#endif\n\t\tmsg_col == Columns - 1))\n    {\n\t// Doesn't fit, print a highlighted '>' to fill it up.\n\tmsg_screen_putchar('>', HL_ATTR(HLF_AT));\n\treturn s;\n    }\n\n    screen_puts_len(s, l, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_col -= cw;\n\tif (msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tmsg_col += cw;\n\tif (msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n    return s + l;\n}\n\n/*\n * Output a string to the screen at position msg_row, msg_col.\n * Update msg_row and msg_col for the next message.\n */\n    void\nmsg_puts(char *s)\n{\n    msg_puts_attr(s, 0);\n}\n\n    void\nmsg_puts_title(char *s)\n{\n    msg_puts_attr(s, HL_ATTR(HLF_T));\n}\n\n/*\n * Show a message in such a way that it always fits in the line.  Cut out a\n * part in the middle and replace it with \"...\" when necessary.\n * Does not handle multi-byte characters!\n */\n    static void\nmsg_outtrans_long_len_attr(char_u *longstr, int len, int attr)\n{\n    int\t\tslen = len;\n    int\t\troom;\n\n    room = Columns - msg_col;\n    if (len > room && room >= 20)\n    {\n\tslen = (room - 3) / 2;\n\tmsg_outtrans_len_attr(longstr, slen, attr);\n\tmsg_puts_attr(\"...\", HL_ATTR(HLF_8));\n    }\n    msg_outtrans_len_attr(longstr + len - slen, slen, attr);\n}\n\n    void\nmsg_outtrans_long_attr(char_u *longstr, int attr)\n{\n    msg_outtrans_long_len_attr(longstr, (int)STRLEN(longstr), attr);\n}\n\n/*\n * Basic function for writing a message with highlight attributes.\n */\n    void\nmsg_puts_attr(char *s, int attr)\n{\n    msg_puts_attr_len(s, -1, attr);\n}\n\n/*\n * Like msg_puts_attr(), but with a maximum length \"maxlen\" (in bytes).\n * When \"maxlen\" is -1 there is no maximum length.\n * When \"maxlen\" is >= 0 the message is not put in the history.\n */\n    static void\nmsg_puts_attr_len(char *str, int maxlen, int attr)\n{\n    /*\n     * If redirection is on, also write to the redirection file.\n     */\n    redir_write((char_u *)str, maxlen);\n\n    /*\n     * Don't print anything when using \":silent cmd\".\n     */\n    if (msg_silent != 0)\n\treturn;\n\n    // if MSG_HIST flag set, add message to history\n    if ((attr & MSG_HIST) && maxlen < 0)\n    {\n\tadd_msg_hist((char_u *)str, -1, attr);\n\tattr &= ~MSG_HIST;\n    }\n\n    // When writing something to the screen after it has scrolled, requires a\n    // wait-return prompt later.  Needed when scrolling, resetting\n    // need_wait_return after some prompt, and then outputting something\n    // without scrolling\n    // Not needed when only using CR to move the cursor.\n    if (msg_scrolled != 0 && !msg_scrolled_ign && STRCMP(str, \"\\r\") != 0)\n\tneed_wait_return = TRUE;\n    msg_didany = TRUE;\t\t// remember that something was outputted\n\n    /*\n     * If there is no valid screen, use fprintf so we can see error messages.\n     * If termcap is not active, we may be writing in an alternate console\n     * window, cursor positioning may not work correctly (window size may be\n     * different, e.g. for Win32 console) or we just don't know where the\n     * cursor is.\n     */\n    if (msg_use_printf())\n\tmsg_puts_printf((char_u *)str, maxlen);\n    else\n\tmsg_puts_display((char_u *)str, maxlen, attr, FALSE);\n}\n\n/*\n * The display part of msg_puts_attr_len().\n * May be called recursively to display scroll-back text.\n */\n    static void\nmsg_puts_display(\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tattr,\n    int\t\trecurse)\n{\n    char_u\t*s = str;\n    char_u\t*t_s = str;\t// string from \"t_s\" to \"s\" is still todo\n    int\t\tt_col = 0;\t// screen cells todo, 0 when \"t_s\" not used\n    int\t\tl;\n    int\t\tcw;\n    char_u\t*sb_str = str;\n    int\t\tsb_col = msg_col;\n    int\t\twrap;\n    int\t\tdid_last_char;\n\n    did_wait_return = FALSE;\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\t/*\n\t * We are at the end of the screen line when:\n\t * - When outputting a newline.\n\t * - When outputting a character in the last column.\n\t */\n\tif (!recurse && msg_row >= Rows - 1 && (*s == '\\n' || (\n#ifdef FEAT_RIGHTLEFT\n\t\t    cmdmsg_rl\n\t\t    ? (\n\t\t\tmsg_col <= 1\n\t\t      || (*s == TAB && msg_col <= 7)\n\t\t      || (has_mbyte && (*mb_ptr2cells)(s) > 1 && msg_col <= 2))\n\t\t    :\n#endif\n\t\t      ((*s != '\\r' && msg_col + t_col >= Columns - 1)\n\t\t       || (*s == TAB && msg_col + t_col >= ((Columns - 1) & ~7))\n\t\t       || (has_mbyte && (*mb_ptr2cells)(s) > 1\n\t\t\t\t\t && msg_col + t_col >= Columns - 2)))))\n\t{\n\t    /*\n\t     * The screen is scrolled up when at the last row (some terminals\n\t     * scroll automatically, some don't.  To avoid problems we scroll\n\t     * ourselves).\n\t     */\n\t    if (t_col > 0)\n\t\t// output postponed text\n\t\tt_puts(&t_col, t_s, s, attr);\n\n\t    // When no more prompt and no more room, truncate here\n\t    if (msg_no_more && lines_left == 0)\n\t\tbreak;\n\n\t    // Scroll the screen up one line.\n\t    msg_scroll_up();\n\n\t    msg_row = Rows - 2;\n\t    if (msg_col >= Columns)\t// can happen after screen resize\n\t\tmsg_col = Columns - 1;\n\n\t    // Display char in last column before showing more-prompt.\n\t    if (*s >= ' '\n#ifdef FEAT_RIGHTLEFT\n\t\t    && !cmdmsg_rl\n#endif\n\t       )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    if (enc_utf8 && maxlen >= 0)\n\t\t\t// avoid including composing chars after the end\n\t\t\tl = utfc_ptr2len_len(s, (int)((str + maxlen) - s));\n\t\t    else\n\t\t\tl = (*mb_ptr2len)(s);\n\t\t    s = screen_puts_mbyte(s, l, attr);\n\t\t}\n\t\telse\n\t\t    msg_screen_putchar(*s++, attr);\n\t\tdid_last_char = TRUE;\n\t    }\n\t    else\n\t\tdid_last_char = FALSE;\n\n\t    if (p_more)\n\t\t// store text for scrolling back\n\t\tstore_sb_text(&sb_str, s, attr, &sb_col, TRUE);\n\n\t    inc_msg_scrolled();\n\t    need_wait_return = TRUE; // may need wait_return in main()\n\t    redraw_cmdline = TRUE;\n\t    if (cmdline_row > 0 && !exmode_active)\n\t\t--cmdline_row;\n\n\t    /*\n\t     * If screen is completely filled and 'more' is set then wait\n\t     * for a character.\n\t     */\n\t    if (lines_left > 0)\n\t\t--lines_left;\n\t    if (p_more && lines_left == 0 && State != HITRETURN\n\t\t\t\t\t    && !msg_no_more && !exmode_active)\n\t    {\n#ifdef FEAT_CON_DIALOG\n\t\tif (do_more_prompt(NUL))\n\t\t    s = confirm_msg_tail;\n#else\n\t\t(void)do_more_prompt(NUL);\n#endif\n\t\tif (quit_more)\n\t\t    return;\n\t    }\n\n\t    // When we displayed a char in last column need to check if there\n\t    // is still more.\n\t    if (did_last_char)\n\t\tcontinue;\n\t}\n\n\twrap = *s == '\\n'\n\t\t    || msg_col + t_col >= Columns\n\t\t    || (has_mbyte && (*mb_ptr2cells)(s) > 1\n\t\t\t\t\t    && msg_col + t_col >= Columns - 1);\n\tif (t_col > 0 && (wrap || *s == '\\r' || *s == '\\b'\n\t\t\t\t\t\t || *s == '\\t' || *s == BELL))\n\t    // output any postponed text\n\t    t_puts(&t_col, t_s, s, attr);\n\n\tif (wrap && p_more && !recurse)\n\t    // store text for scrolling back\n\t    store_sb_text(&sb_str, s, attr, &sb_col, TRUE);\n\n\tif (*s == '\\n')\t\t    // go to next line\n\t{\n\t    msg_didout = FALSE;\t    // remember that line is empty\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns - 1;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    if (++msg_row >= Rows)  // safety check\n\t\tmsg_row = Rows - 1;\n\t}\n\telse if (*s == '\\r')\t    // go to column 0\n\t{\n\t    msg_col = 0;\n\t}\n\telse if (*s == '\\b')\t    // go to previous char\n\t{\n\t    if (msg_col)\n\t\t--msg_col;\n\t}\n\telse if (*s == TAB)\t    // translate Tab into spaces\n\t{\n\t    do\n\t\tmsg_screen_putchar(' ', attr);\n\t    while (msg_col & 7);\n\t}\n\telse if (*s == BELL)\t\t// beep (from \":sh\")\n\t    vim_beep(BO_SH);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tcw = (*mb_ptr2cells)(s);\n\t\tif (enc_utf8 && maxlen >= 0)\n\t\t    // avoid including composing chars after the end\n\t\t    l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));\n\t\telse\n\t\t    l = (*mb_ptr2len)(s);\n\t    }\n\t    else\n\t    {\n\t\tcw = 1;\n\t\tl = 1;\n\t    }\n\n\t    // When drawing from right to left or when a double-wide character\n\t    // doesn't fit, draw a single character here.  Otherwise collect\n\t    // characters and draw them all at once later.\n\t    if (\n# ifdef FEAT_RIGHTLEFT\n\t\t    cmdmsg_rl ||\n# endif\n\t\t    (cw > 1 && msg_col + t_col >= Columns - 1))\n\t    {\n\t\tif (l > 1)\n\t\t    s = screen_puts_mbyte(s, l, attr) - 1;\n\t\telse\n\t\t    msg_screen_putchar(*s, attr);\n\t    }\n\t    else\n\t    {\n\t\t// postpone this character until later\n\t\tif (t_col == 0)\n\t\t    t_s = s;\n\t\tt_col += cw;\n\t\ts += l - 1;\n\t    }\n\t}\n\t++s;\n    }\n\n    // output any postponed text\n    if (t_col > 0)\n\tt_puts(&t_col, t_s, s, attr);\n    if (p_more && !recurse)\n\tstore_sb_text(&sb_str, s, attr, &sb_col, FALSE);\n\n    msg_check();\n}\n\n/*\n * Return TRUE when \":filter pattern\" was used and \"msg\" does not match\n * \"pattern\".\n */\n    int\nmessage_filtered(char_u *msg)\n{\n    int match;\n\n    if (cmdmod.cmod_filter_regmatch.regprog == NULL)\n\treturn FALSE;\n    match = vim_regexec(&cmdmod.cmod_filter_regmatch, msg, (colnr_T)0);\n    return cmdmod.cmod_filter_force ? match : !match;\n}\n\n/*\n * Scroll the screen up one line for displaying the next message line.\n */\n    static void\nmsg_scroll_up(void)\n{\n#ifdef FEAT_GUI\n    // Remove the cursor before scrolling, ScreenLines[] is going\n    // to become invalid.\n    if (gui.in_use)\n\tgui_undraw_cursor();\n#endif\n    // scrolling up always works\n    mch_disable_flush();\n    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);\n    mch_enable_flush();\n\n    if (!can_clear((char_u *)\" \"))\n    {\n\t// Scrolling up doesn't result in the right background.  Set the\n\t// background here.  It's not efficient, but avoids that we have to do\n\t// it all over the code.\n\tscreen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\n\t// Also clear the last char of the last but one line if it was not\n\t// cleared before to avoid a scroll-up.\n\tif (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)\n\t    screen_fill((int)Rows - 2, (int)Rows - 1,\n\t\t\t\t (int)Columns - 1, (int)Columns, ' ', ' ', 0);\n    }\n}\n\n/*\n * Increment \"msg_scrolled\".\n */\n    static void\ninc_msg_scrolled(void)\n{\n#ifdef FEAT_EVAL\n    if (*get_vim_var_str(VV_SCROLLSTART) == NUL)\n    {\n\tchar_u\t    *p = SOURCING_NAME;\n\tchar_u\t    *tofree = NULL;\n\tint\t    len;\n\n\t// v:scrollstart is empty, set it to the script/function name and line\n\t// number\n\tif (p == NULL)\n\t    p = (char_u *)_(\"Unknown\");\n\telse\n\t{\n\t    len = (int)STRLEN(p) + 40;\n\t    tofree = alloc(len);\n\t    if (tofree != NULL)\n\t    {\n\t\tvim_snprintf((char *)tofree, len, _(\"%s line %ld\"),\n\t\t\t\t\t\t      p, (long)SOURCING_LNUM);\n\t\tp = tofree;\n\t    }\n\t}\n\tset_vim_var_string(VV_SCROLLSTART, p, -1);\n\tvim_free(tofree);\n    }\n#endif\n    ++msg_scrolled;\n    if (must_redraw < VALID)\n\tmust_redraw = VALID;\n}\n\n/*\n * To be able to scroll back at the \"more\" and \"hit-enter\" prompts we need to\n * store the displayed text and remember where screen lines start.\n */\ntypedef struct msgchunk_S msgchunk_T;\nstruct msgchunk_S\n{\n    msgchunk_T\t*sb_next;\n    msgchunk_T\t*sb_prev;\n    char\tsb_eol;\t\t// TRUE when line ends after this text\n    int\t\tsb_msg_col;\t// column in which text starts\n    int\t\tsb_attr;\t// text attributes\n    char_u\tsb_text[1];\t// text to be displayed, actually longer\n};\n\nstatic msgchunk_T *last_msgchunk = NULL; // last displayed text\n\nstatic msgchunk_T *msg_sb_start(msgchunk_T *mps);\n\ntypedef enum {\n    SB_CLEAR_NONE = 0,\n    SB_CLEAR_ALL,\n    SB_CLEAR_CMDLINE_BUSY,\n    SB_CLEAR_CMDLINE_DONE\n} sb_clear_T;\n\n// When to clear text on next msg.\nstatic sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;\n\n/*\n * Store part of a printed message for displaying when scrolling back.\n */\n    static void\nstore_sb_text(\n    char_u\t**sb_str,\t// start of string\n    char_u\t*s,\t\t// just after string\n    int\t\tattr,\n    int\t\t*sb_col,\n    int\t\tfinish)\t\t// line ends\n{\n    msgchunk_T\t*mp;\n\n    if (do_clear_sb_text == SB_CLEAR_ALL\n\t    || do_clear_sb_text == SB_CLEAR_CMDLINE_DONE)\n    {\n\tclear_sb_text(do_clear_sb_text == SB_CLEAR_ALL);\n\tdo_clear_sb_text = SB_CLEAR_NONE;\n    }\n\n    if (s > *sb_str)\n    {\n\tmp = alloc(sizeof(msgchunk_T) + (s - *sb_str));\n\tif (mp != NULL)\n\t{\n\t    mp->sb_eol = finish;\n\t    mp->sb_msg_col = *sb_col;\n\t    mp->sb_attr = attr;\n\t    vim_strncpy(mp->sb_text, *sb_str, s - *sb_str);\n\n\t    if (last_msgchunk == NULL)\n\t    {\n\t\tlast_msgchunk = mp;\n\t\tmp->sb_prev = NULL;\n\t    }\n\t    else\n\t    {\n\t\tmp->sb_prev = last_msgchunk;\n\t\tlast_msgchunk->sb_next = mp;\n\t\tlast_msgchunk = mp;\n\t    }\n\t    mp->sb_next = NULL;\n\t}\n    }\n    else if (finish && last_msgchunk != NULL)\n\tlast_msgchunk->sb_eol = TRUE;\n\n    *sb_str = s;\n    *sb_col = 0;\n}\n\n/*\n * Finished showing messages, clear the scroll-back text on the next message.\n */\n    void\nmay_clear_sb_text(void)\n{\n    do_clear_sb_text = SB_CLEAR_ALL;\n}\n\n/*\n * Starting to edit the command line, do not clear messages now.\n */\n    void\nsb_text_start_cmdline(void)\n{\n    do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;\n    msg_sb_eol();\n}\n\n/*\n * Ending to edit the command line.  Clear old lines but the last one later.\n */\n    void\nsb_text_end_cmdline(void)\n{\n    do_clear_sb_text = SB_CLEAR_CMDLINE_DONE;\n}\n\n/*\n * Clear any text remembered for scrolling back.\n * When \"all\" is FALSE keep the last line.\n * Called when redrawing the screen.\n */\n    void\nclear_sb_text(int all)\n{\n    msgchunk_T\t*mp;\n    msgchunk_T\t**lastp;\n\n    if (all)\n\tlastp = &last_msgchunk;\n    else\n    {\n\tif (last_msgchunk == NULL)\n\t    return;\n\tlastp = &last_msgchunk->sb_prev;\n    }\n\n    while (*lastp != NULL)\n    {\n\tmp = (*lastp)->sb_prev;\n\tvim_free(*lastp);\n\t*lastp = mp;\n    }\n}\n\n/*\n * \"g<\" command.\n */\n    void\nshow_sb_text(void)\n{\n    msgchunk_T\t*mp;\n\n    // Only show something if there is more than one line, otherwise it looks\n    // weird, typing a command without output results in one line.\n    mp = msg_sb_start(last_msgchunk);\n    if (mp == NULL || mp->sb_prev == NULL)\n\tvim_beep(BO_MESS);\n    else\n    {\n\tdo_more_prompt('G');\n\twait_return(FALSE);\n    }\n}\n\n/*\n * Move to the start of screen line in already displayed text.\n */\n    static msgchunk_T *\nmsg_sb_start(msgchunk_T *mps)\n{\n    msgchunk_T *mp = mps;\n\n    while (mp != NULL && mp->sb_prev != NULL && !mp->sb_prev->sb_eol)\n\tmp = mp->sb_prev;\n    return mp;\n}\n\n/*\n * Mark the last message chunk as finishing the line.\n */\n    void\nmsg_sb_eol(void)\n{\n    if (last_msgchunk != NULL)\n\tlast_msgchunk->sb_eol = TRUE;\n}\n\n/*\n * Display a screen line from previously displayed text at row \"row\".\n * Returns a pointer to the text for the next line (can be NULL).\n */\n    static msgchunk_T *\ndisp_sb_line(int row, msgchunk_T *smp)\n{\n    msgchunk_T\t*mp = smp;\n    char_u\t*p;\n\n    for (;;)\n    {\n\tmsg_row = row;\n\tmsg_col = mp->sb_msg_col;\n\tp = mp->sb_text;\n\tif (*p == '\\n')\t    // don't display the line break\n\t    ++p;\n\tmsg_puts_display(p, -1, mp->sb_attr, TRUE);\n\tif (mp->sb_eol || mp->sb_next == NULL)\n\t    break;\n\tmp = mp->sb_next;\n    }\n    return mp->sb_next;\n}\n\n/*\n * Output any postponed text for msg_puts_attr_len().\n */\n    static void\nt_puts(\n    int\t\t*t_col,\n    char_u\t*t_s,\n    char_u\t*s,\n    int\t\tattr)\n{\n    // output postponed text\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_puts_len(t_s, (int)(s - t_s), msg_row, msg_col, attr);\n    msg_col += *t_col;\n    *t_col = 0;\n    // If the string starts with a composing character don't increment the\n    // column position for it.\n    if (enc_utf8 && utf_iscomposing(utf_ptr2char(t_s)))\n\t--msg_col;\n    if (msg_col >= Columns)\n    {\n\tmsg_col = 0;\n\t++msg_row;\n    }\n}\n\n/*\n * Returns TRUE when messages should be printed with mch_errmsg().\n * This is used when there is no valid screen, so we can see error messages.\n * If termcap is not active, we may be writing in an alternate console\n * window, cursor positioning may not work correctly (window size may be\n * different, e.g. for Win32 console) or we just don't know where the\n * cursor is.\n */\n    int\nmsg_use_printf(void)\n{\n    return (!msg_check_screen()\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\t    || (!gui.in_use && !termcap_active)\n# else\n\t    || !termcap_active\n# endif\n#endif\n\t    || (swapping_screen() && !termcap_active)\n\t       );\n}\n\n/*\n * Print a message when there is no valid screen.\n */\n    static void\nmsg_puts_printf(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    char_u\t*buf = NULL;\n    char_u\t*p = s;\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_COOK);\t// handle CR and NL correctly\n#endif\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\tif (!(silent_mode && p_verbose == 0))\n\t{\n\t    // NL --> CR NL translation (for Unix, not for \"--version\")\n\t    if (*s == NL)\n\t    {\n\t\tint n = (int)(s - p);\n\n\t\tbuf = alloc(n + 3);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    memcpy(buf, p, n);\n\t\t    if (!info_message)\n\t\t\tbuf[n++] = CAR;\n\t\t    buf[n++] = NL;\n\t\t    buf[n++] = NUL;\n\t\t    if (info_message)   // informative message, not an error\n\t\t\tmch_msg((char *)buf);\n\t\t    else\n\t\t\tmch_errmsg((char *)buf);\n\t\t    vim_free(buf);\n\t\t}\n\t\tp = s + 1;\n\t    }\n\t}\n\n\t// primitive way to compute the current column\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = Columns - 1;\n\t    else\n\t\t--msg_col;\n\t}\n\telse\n#endif\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = 0;\n\t    else\n\t\t++msg_col;\n\t}\n\t++s;\n    }\n\n    if (*p != NUL && !(silent_mode && p_verbose == 0))\n    {\n\tchar_u *tofree = NULL;\n\n\tif (maxlen > 0 && STRLEN(p) > (size_t)maxlen)\n\t{\n\t    tofree = vim_strnsave(p, (size_t)maxlen);\n\t    p = tofree;\n\t}\n\tif (p != NULL)\n\t{\n\t    if (info_message)\n\t\tmch_msg((char *)p);\n\t    else\n\t\tmch_errmsg((char *)p);\n\t    vim_free(tofree);\n\t}\n    }\n\n    msg_didout = TRUE;\t    // assume that line is not empty\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_RAW);\n#endif\n}\n\n/*\n * Show the more-prompt and handle the user response.\n * This takes care of scrolling back and displaying previously displayed text.\n * When at hit-enter prompt \"typed_char\" is the already typed character,\n * otherwise it's NUL.\n * Returns TRUE when jumping ahead to \"confirm_msg_tail\".\n */\n    static int\ndo_more_prompt(int typed_char)\n{\n    static int\tentered = FALSE;\n    int\t\tused_typed_char = typed_char;\n    int\t\toldState = State;\n    int\t\tc;\n#ifdef FEAT_CON_DIALOG\n    int\t\tretval = FALSE;\n#endif\n    int\t\ttoscroll;\n    msgchunk_T\t*mp_last = NULL;\n    msgchunk_T\t*mp;\n    int\t\ti;\n\n    // We get called recursively when a timer callback outputs a message. In\n    // that case don't show another prompt. Also when at the hit-Enter prompt\n    // and nothing was typed.\n    if (entered || (State == HITRETURN && typed_char == 0))\n\treturn FALSE;\n    entered = TRUE;\n\n    if (typed_char == 'G')\n    {\n\t// \"g<\": Find first line on the last page.\n\tmp_last = msg_sb_start(last_msgchunk);\n\tfor (i = 0; i < Rows - 2 && mp_last != NULL\n\t\t\t\t\t     && mp_last->sb_prev != NULL; ++i)\n\t    mp_last = msg_sb_start(mp_last->sb_prev);\n    }\n\n    State = ASKMORE;\n    setmouse();\n    if (typed_char == NUL)\n\tmsg_moremsg(FALSE);\n    for (;;)\n    {\n\t/*\n\t * Get a typed character directly from the user.\n\t */\n\tif (used_typed_char != NUL)\n\t{\n\t    c = used_typed_char;\t// was typed at hit-enter prompt\n\t    used_typed_char = NUL;\n\t}\n\telse\n\t    c = get_keystroke();\n\n#if defined(FEAT_MENU) && defined(FEAT_GUI)\n\tif (c == K_MENU)\n\t{\n\t    int idx = get_menu_index(current_menu, ASKMORE);\n\n\t    // Used a menu.  If it starts with CTRL-Y, it must\n\t    // be a \"Copy\" for the clipboard.  Otherwise\n\t    // assume that we end\n\t    if (idx == MENU_INDEX_INVALID)\n\t\tcontinue;\n\t    c = *current_menu->strings[idx];\n\t    if (c != NUL && current_menu->strings[idx][1] != NUL)\n\t\tins_typebuf(current_menu->strings[idx] + 1,\n\t\t\t\tcurrent_menu->noremap[idx], 0, TRUE,\n\t\t\t\t\t\t   current_menu->silent[idx]);\n\t}\n#endif\n\n\ttoscroll = 0;\n\tswitch (c)\n\t{\n\tcase BS:\t\t// scroll one line back\n\tcase K_BS:\n\tcase 'k':\n\tcase K_UP:\n\t    toscroll = -1;\n\t    break;\n\n\tcase CAR:\t\t// one extra line\n\tcase NL:\n\tcase 'j':\n\tcase K_DOWN:\n\t    toscroll = 1;\n\t    break;\n\n\tcase 'u':\t\t// Up half a page\n\t    toscroll = -(Rows / 2);\n\t    break;\n\n\tcase 'd':\t\t// Down half a page\n\t    toscroll = Rows / 2;\n\t    break;\n\n\tcase 'b':\t\t// one page back\n\tcase K_PAGEUP:\n\t    toscroll = -(Rows - 1);\n\t    break;\n\n\tcase ' ':\t\t// one extra page\n\tcase 'f':\n\tcase K_PAGEDOWN:\n\tcase K_LEFTMOUSE:\n\t    toscroll = Rows - 1;\n\t    break;\n\n\tcase 'g':\t\t// all the way back to the start\n\t    toscroll = -999999;\n\t    break;\n\n\tcase 'G':\t\t// all the way to the end\n\t    toscroll = 999999;\n\t    lines_left = 999999;\n\t    break;\n\n\tcase ':':\t\t// start new command line\n#ifdef FEAT_CON_DIALOG\n\t    if (!confirm_msg_used)\n#endif\n\t    {\n\t\t// Since got_int is set all typeahead will be flushed, but we\n\t\t// want to keep this ':', remember that in a special way.\n\t\ttypeahead_noflush(':');\n#ifdef FEAT_TERMINAL\n\t\tskip_term_loop = TRUE;\n#endif\n\t\tcmdline_row = Rows - 1;\t\t// put ':' on this line\n\t\tskip_redraw = TRUE;\t\t// skip redraw once\n\t\tneed_wait_return = FALSE;\t// don't wait in main()\n\t    }\n\t    // FALLTHROUGH\n\tcase 'q':\t\t// quit\n\tcase Ctrl_C:\n\tcase ESC:\n#ifdef FEAT_CON_DIALOG\n\t    if (confirm_msg_used)\n\t    {\n\t\t// Jump to the choices of the dialog.\n\t\tretval = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tgot_int = TRUE;\n\t\tquit_more = TRUE;\n\t    }\n\t    // When there is some more output (wrapping line) display that\n\t    // without another prompt.\n\t    lines_left = Rows - 1;\n\t    break;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t    // Strange way to allow copying (yanking) a modeless\n\t    // selection at the more prompt.  Use CTRL-Y,\n\t    // because the same is used in Cmdline-mode and at the\n\t    // hit-enter prompt.  However, scrolling one line up\n\t    // might be expected...\n\t    if (clip_star.state == SELECT_DONE)\n\t\tclip_copy_modeless_selection(TRUE);\n\t    continue;\n#endif\n\tdefault:\t\t// no valid response\n\t    msg_moremsg(TRUE);\n\t    continue;\n\t}\n\n\tif (toscroll != 0)\n\t{\n\t    if (toscroll < 0)\n\t    {\n\t\t// go to start of last line\n\t\tif (mp_last == NULL)\n\t\t    mp = msg_sb_start(last_msgchunk);\n\t\telse if (mp_last->sb_prev != NULL)\n\t\t    mp = msg_sb_start(mp_last->sb_prev);\n\t\telse\n\t\t    mp = NULL;\n\n\t\t// go to start of line at top of the screen\n\t\tfor (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;\n\t\t\t\t\t\t\t\t\t  ++i)\n\t\t    mp = msg_sb_start(mp->sb_prev);\n\n\t\tif (mp != NULL && mp->sb_prev != NULL)\n\t\t{\n\t\t    // Find line to be displayed at top.\n\t\t    for (i = 0; i > toscroll; --i)\n\t\t    {\n\t\t\tif (mp == NULL || mp->sb_prev == NULL)\n\t\t\t    break;\n\t\t\tmp = msg_sb_start(mp->sb_prev);\n\t\t\tif (mp_last == NULL)\n\t\t\t    mp_last = msg_sb_start(last_msgchunk);\n\t\t\telse\n\t\t\t    mp_last = msg_sb_start(mp_last->sb_prev);\n\t\t    }\n\n\t\t    if (toscroll == -1 && screen_ins_lines(0, 0, 1,\n\t\t\t\t\t\t     (int)Rows, 0, NULL) == OK)\n\t\t    {\n\t\t\t// display line at top\n\t\t\t(void)disp_sb_line(0, mp);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// redisplay all lines\n\t\t\tscreenclear();\n\t\t\tfor (i = 0; mp != NULL && i < Rows - 1; ++i)\n\t\t\t{\n\t\t\t    mp = disp_sb_line(i, mp);\n\t\t\t    ++msg_scrolled;\n\t\t\t}\n\t\t    }\n\t\t    toscroll = 0;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// First display any text that we scrolled back.\n\t\twhile (toscroll > 0 && mp_last != NULL)\n\t\t{\n\t\t    // scroll up, display line at bottom\n\t\t    msg_scroll_up();\n\t\t    inc_msg_scrolled();\n\t\t    screen_fill((int)Rows - 2, (int)Rows - 1, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t\t    mp_last = disp_sb_line((int)Rows - 2, mp_last);\n\t\t    --toscroll;\n\t\t}\n\t    }\n\n\t    if (toscroll <= 0)\n\t    {\n\t\t// displayed the requested text, more prompt again\n\t\tscreen_fill((int)Rows - 1, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t\tmsg_moremsg(FALSE);\n\t\tcontinue;\n\t    }\n\n\t    // display more text, return to caller\n\t    lines_left = toscroll;\n\t}\n\n\tbreak;\n    }\n\n    // clear the --more-- message\n    screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n    State = oldState;\n    setmouse();\n    if (quit_more)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\n    }\n#ifdef FEAT_RIGHTLEFT\n    else if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n#endif\n\n    entered = FALSE;\n#ifdef FEAT_CON_DIALOG\n    return retval;\n#else\n    return FALSE;\n#endif\n}\n\n#if defined(USE_MCH_ERRMSG) || defined(PROTO)\n\n#ifdef mch_errmsg\n# undef mch_errmsg\n#endif\n#ifdef mch_msg\n# undef mch_msg\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n    static void\nmch_errmsg_c(char *str)\n{\n    int\t    len = (int)STRLEN(str);\n    DWORD   nwrite = 0;\n    DWORD   mode = 0;\n    HANDLE  h = GetStdHandle(STD_ERROR_HANDLE);\n\n    if (GetConsoleMode(h, &mode) && enc_codepage >= 0\n\t    && (int)GetConsoleCP() != enc_codepage)\n    {\n\tWCHAR\t*w = enc_to_utf16((char_u *)str, &len);\n\n\tWriteConsoleW(h, w, len, &nwrite, NULL);\n\tvim_free(w);\n    }\n    else\n    {\n\tfprintf(stderr, \"%s\", str);\n    }\n}\n#endif\n\n/*\n * Give an error message.  To be used when the screen hasn't been initialized\n * yet.  When stderr can't be used, collect error messages until the GUI has\n * started and they can be displayed in a message box.\n */\n    void\nmch_errmsg(char *str)\n{\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    int\t\tlen;\n#endif\n\n#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)\n    // On Unix use stderr if it's a tty.\n    // When not going to start the GUI also use stderr.\n    // On Mac, when started from Finder, stderr is the console.\n    if (\n# ifdef UNIX\n#  ifdef MACOS_X\n\t    (isatty(2) && strcmp(\"/dev/console\", ttyname(2)) != 0)\n#  else\n\t    isatty(2)\n#  endif\n#  ifdef FEAT_GUI\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_GUI\n\t    !(gui.in_use || gui.starting)\n# endif\n\t    )\n    {\n\tfprintf(stderr, \"%s\", str);\n\treturn;\n    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!(gui.in_use || gui.starting))\n# endif\n    {\n\tmch_errmsg_c(str);\n\treturn;\n    }\n#endif\n\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    // avoid a delay for a message that isn't there\n    emsg_on_display = FALSE;\n\n    len = (int)STRLEN(str) + 1;\n    if (error_ga.ga_growsize == 0)\n    {\n\terror_ga.ga_growsize = 80;\n\terror_ga.ga_itemsize = 1;\n    }\n    if (ga_grow(&error_ga, len) == OK)\n    {\n\tmch_memmove((char_u *)error_ga.ga_data + error_ga.ga_len,\n\t\t\t\t\t\t\t  (char_u *)str, len);\n# ifdef UNIX\n\t// remove CR characters, they are displayed\n\t{\n\t    char_u\t*p;\n\n\t    p = (char_u *)error_ga.ga_data + error_ga.ga_len;\n\t    for (;;)\n\t    {\n\t\tp = vim_strchr(p, '\\r');\n\t\tif (p == NULL)\n\t\t    break;\n\t\t*p = ' ';\n\t    }\n\t}\n# endif\n\t--len;\t\t// don't count the NUL at the end\n\terror_ga.ga_len += len;\n    }\n#endif\n}\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n    static void\nmch_msg_c(char *str)\n{\n    int\t    len = (int)STRLEN(str);\n    DWORD   nwrite = 0;\n    DWORD   mode;\n    HANDLE  h = GetStdHandle(STD_OUTPUT_HANDLE);\n\n\n    if (GetConsoleMode(h, &mode) && enc_codepage >= 0\n\t    && (int)GetConsoleCP() != enc_codepage)\n    {\n\tWCHAR\t*w = enc_to_utf16((char_u *)str, &len);\n\n\tWriteConsoleW(h, w, len, &nwrite, NULL);\n\tvim_free(w);\n    }\n    else\n    {\n\tprintf(\"%s\", str);\n    }\n}\n#endif\n\n/*\n * Give a message.  To be used when the screen hasn't been initialized yet.\n * When there is no tty, collect messages until the GUI has started and they\n * can be displayed in a message box.\n */\n    void\nmch_msg(char *str)\n{\n#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)\n    // On Unix use stdout if we have a tty.  This allows \"vim -h | more\" and\n    // uses mch_errmsg() when started from the desktop.\n    // When not going to start the GUI also use stdout.\n    // On Mac, when started from Finder, stderr is the console.\n    if (\n# ifdef UNIX\n#  ifdef MACOS_X\n\t    (isatty(2) && strcmp(\"/dev/console\", ttyname(2)) != 0)\n#  else\n\t    isatty(2)\n#  endif\n#  ifdef FEAT_GUI\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_GUI\n\t    !(gui.in_use || gui.starting)\n# endif\n\t    )\n    {\n\tprintf(\"%s\", str);\n\treturn;\n    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!(gui.in_use || gui.starting))\n# endif\n    {\n\tmch_msg_c(str);\n\treturn;\n    }\n#endif\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    mch_errmsg(str);\n#endif\n}\n#endif // USE_MCH_ERRMSG\n\n/*\n * Put a character on the screen at the current message position and advance\n * to the next position.  Only for printable ASCII!\n */\n    static void\nmsg_screen_putchar(int c, int attr)\n{\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_putchar(c, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tif (--msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tif (++msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n}\n\n    static void\nmsg_moremsg(int full)\n{\n    int\t\tattr;\n    char_u\t*s = (char_u *)_(\"-- More --\");\n\n    attr = HL_ATTR(HLF_M);\n    screen_puts(s, (int)Rows - 1, 0, attr);\n    if (full)\n\tscreen_puts((char_u *)\n\t\t_(\" SPACE/d/j: screen/page/line down, b/u/k: up, q: quit \"),\n\t\t(int)Rows - 1, vim_strsize(s), attr);\n}\n\n/*\n * Repeat the message for the current mode: ASKMORE, EXTERNCMD, CONFIRM or\n * exmode_active.\n */\n    void\nrepeat_message(void)\n{\n    if (State == ASKMORE)\n    {\n\tmsg_moremsg(TRUE);\t// display --more-- message again\n\tmsg_row = Rows - 1;\n    }\n#ifdef FEAT_CON_DIALOG\n    else if (State == CONFIRM)\n    {\n\tdisplay_confirm_msg();\t// display \":confirm\" message again\n\tmsg_row = Rows - 1;\n    }\n#endif\n    else if (State == EXTERNCMD)\n    {\n\twindgoto(msg_row, msg_col); // put cursor back\n    }\n    else if (State == HITRETURN || State == SETWSIZE)\n    {\n\tif (msg_row == Rows - 1)\n\t{\n\t    // Avoid drawing the \"hit-enter\" prompt below the previous one,\n\t    // overwrite it.  Esp. useful when regaining focus and a\n\t    // FocusGained autocmd exists but didn't draw anything.\n\t    msg_didout = FALSE;\n\t    msg_col = 0;\n\t    msg_clr_eos();\n\t}\n\thit_return_msg();\n\tmsg_row = Rows - 1;\n    }\n}\n\n/*\n * msg_check_screen - check if the screen is initialized.\n * Also check msg_row and msg_col, if they are too big it may cause a crash.\n * While starting the GUI the terminal codes will be set for the GUI, but the\n * output goes to the terminal.  Don't use the terminal codes then.\n */\n    static int\nmsg_check_screen(void)\n{\n    if (!full_screen || !screen_valid(FALSE))\n\treturn FALSE;\n\n    if (msg_row >= Rows)\n\tmsg_row = Rows - 1;\n    if (msg_col >= Columns)\n\tmsg_col = Columns - 1;\n    return TRUE;\n}\n\n/*\n * Clear from current message position to end of screen.\n * Skip this when \":silent\" was used, no need to clear for redirection.\n */\n    void\nmsg_clr_eos(void)\n{\n    if (msg_silent == 0)\n\tmsg_clr_eos_force();\n}\n\n/*\n * Clear from current message position to end of screen.\n * Note: msg_col is not updated, so we remember the end of the message\n * for msg_check().\n */\n    void\nmsg_clr_eos_force(void)\n{\n    if (msg_use_printf())\n    {\n\tif (full_screen)\t// only when termcap codes are valid\n\t{\n\t    if (*T_CD)\n\t\tout_str(T_CD);\t// clear to end of display\n\t    else if (*T_CE)\n\t\tout_str(T_CE);\t// clear to end of line\n\t}\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    screen_fill(msg_row, msg_row + 1, 0, msg_col + 1, ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n\telse\n#endif\n\t{\n\t    screen_fill(msg_row, msg_row + 1, msg_col, (int)Columns,\n\t\t\t\t\t\t\t\t ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n    }\n}\n\n/*\n * Clear the command line.\n */\n    void\nmsg_clr_cmdline(void)\n{\n    msg_row = cmdline_row;\n    msg_col = 0;\n    msg_clr_eos_force();\n}\n\n/*\n * end putting a message on the screen\n * call wait_return if the message does not fit in the available space\n * return TRUE if wait_return not called.\n */\n    int\nmsg_end(void)\n{\n    /*\n     * If the string is larger than the window,\n     * or the ruler option is set and we run into it,\n     * we have to redraw the window.\n     * Do not do this if we are abandoning the file or editing the command line.\n     */\n    if (!exiting && need_wait_return && !(State & CMDLINE))\n    {\n\twait_return(FALSE);\n\treturn FALSE;\n    }\n    out_flush();\n    return TRUE;\n}\n\n/*\n * If the written message runs into the shown command or ruler, we have to\n * wait for hit-return and redraw the window later.\n */\n    void\nmsg_check(void)\n{\n    if (msg_row == Rows - 1 && msg_col >= sc_col)\n    {\n\tneed_wait_return = TRUE;\n\tredraw_cmdline = TRUE;\n    }\n}\n\n/*\n * May write a string to the redirection file.\n * When \"maxlen\" is -1 write the whole string, otherwise up to \"maxlen\" bytes.\n */\n    static void\nredir_write(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    static int\tcur_col = 0;\n\n    // Don't do anything for displaying prompts and the like.\n    if (redir_off)\n\treturn;\n\n    // If 'verbosefile' is set prepare for writing in that file.\n    if (*p_vfile != NUL && verbose_fd == NULL)\n\tverbose_open();\n\n    if (redirecting())\n    {\n\t// If the string doesn't start with CR or NL, go to msg_col\n\tif (*s != '\\n' && *s != '\\r')\n\t{\n\t    while (cur_col < msg_col)\n\t    {\n#ifdef FEAT_EVAL\n\t\tif (redir_execute)\n\t\t    execute_redir_str((char_u *)\" \", -1);\n\t\telse if (redir_reg)\n\t\t    write_reg_contents(redir_reg, (char_u *)\" \", -1, TRUE);\n\t\telse if (redir_vname)\n\t\t    var_redir_str((char_u *)\" \", -1);\n\t\telse\n#endif\n\t\t    if (redir_fd != NULL)\n\t\t    fputs(\" \", redir_fd);\n\t\tif (verbose_fd != NULL)\n\t\t    fputs(\" \", verbose_fd);\n\t\t++cur_col;\n\t    }\n\t}\n\n#ifdef FEAT_EVAL\n\tif (redir_execute)\n\t    execute_redir_str(s, maxlen);\n\telse if (redir_reg)\n\t    write_reg_contents(redir_reg, s, maxlen, TRUE);\n\telse if (redir_vname)\n\t    var_redir_str(s, maxlen);\n#endif\n\n\t// Write and adjust the current column.\n\twhile (*s != NUL && (maxlen < 0 || (int)(s - str) < maxlen))\n\t{\n#ifdef FEAT_EVAL\n\t    if (!redir_reg && !redir_vname && !redir_execute)\n#endif\n\t\tif (redir_fd != NULL)\n\t\t    putc(*s, redir_fd);\n\t    if (verbose_fd != NULL)\n\t\tputc(*s, verbose_fd);\n\t    if (*s == '\\r' || *s == '\\n')\n\t\tcur_col = 0;\n\t    else if (*s == '\\t')\n\t\tcur_col += (8 - cur_col % 8);\n\t    else\n\t\t++cur_col;\n\t    ++s;\n\t}\n\n\tif (msg_silent != 0)\t// should update msg_col\n\t    msg_col = cur_col;\n    }\n}\n\n    int\nredirecting(void)\n{\n    return redir_fd != NULL || *p_vfile != NUL\n#ifdef FEAT_EVAL\n\t\t\t  || redir_reg || redir_vname || redir_execute\n#endif\n\t\t\t\t       ;\n}\n\n/*\n * Before giving verbose message.\n * Must always be called paired with verbose_leave()!\n */\n    void\nverbose_enter(void)\n{\n    if (*p_vfile != NUL)\n\t++msg_silent;\n}\n\n/*\n * After giving verbose message.\n * Must always be called paired with verbose_enter()!\n */\n    void\nverbose_leave(void)\n{\n    if (*p_vfile != NUL)\n\tif (--msg_silent < 0)\n\t    msg_silent = 0;\n}\n\n/*\n * Like verbose_enter() and set msg_scroll when displaying the message.\n */\n    void\nverbose_enter_scroll(void)\n{\n    if (*p_vfile != NUL)\n\t++msg_silent;\n    else\n\t// always scroll up, don't overwrite\n\tmsg_scroll = TRUE;\n}\n\n/*\n * Like verbose_leave() and set cmdline_row when displaying the message.\n */\n    void\nverbose_leave_scroll(void)\n{\n    if (*p_vfile != NUL)\n    {\n\tif (--msg_silent < 0)\n\t    msg_silent = 0;\n    }\n    else\n\tcmdline_row = msg_row;\n}\n\n/*\n * Called when 'verbosefile' is set: stop writing to the file.\n */\n    void\nverbose_stop(void)\n{\n    if (verbose_fd != NULL)\n    {\n\tfclose(verbose_fd);\n\tverbose_fd = NULL;\n    }\n    verbose_did_open = FALSE;\n}\n\n/*\n * Open the file 'verbosefile'.\n * Return FAIL or OK.\n */\n    int\nverbose_open(void)\n{\n    if (verbose_fd == NULL && !verbose_did_open)\n    {\n\t// Only give the error message once.\n\tverbose_did_open = TRUE;\n\n\tverbose_fd = mch_fopen((char *)p_vfile, \"a\");\n\tif (verbose_fd == NULL)\n\t{\n\t    semsg(_(e_cant_open_file_str), p_vfile);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Give a warning message (for searching).\n * Use 'w' highlighting and may repeat the message after redrawing\n */\n    void\ngive_warning(char_u *message, int hl)\n{\n    give_warning_with_source(message, hl, FALSE);\n}\n\n    void\ngive_warning_with_source(char_u *message, int hl, int with_source)\n{\n    // Don't do this for \":silent\".\n    if (msg_silent != 0)\n\treturn;\n\n    // Don't want a hit-enter prompt here.\n    ++no_wait_return;\n\n#ifdef FEAT_EVAL\n    set_vim_var_string(VV_WARNINGMSG, message, -1);\n#endif\n    VIM_CLEAR(keep_msg);\n    if (hl)\n\tkeep_msg_attr = HL_ATTR(HLF_W);\n    else\n\tkeep_msg_attr = 0;\n\n    if (with_source)\n    {\n\t// Do what msg() does, but with a column offset if the warning should\n\t// be after the mode message.\n\tmsg_start();\n\tmsg_source(HL_ATTR(HLF_W));\n\tmsg_puts(\" \");\n\tmsg_puts_attr((char *)message, HL_ATTR(HLF_W) | MSG_HIST);\n\tmsg_clr_eos();\n\t(void)msg_end();\n    }\n    else if (msg_attr((char *)message, keep_msg_attr) && msg_scrolled == 0)\n\tset_keep_msg(message, keep_msg_attr);\n\n    msg_didout = FALSE;\t    // overwrite this message\n    msg_nowait = TRUE;\t    // don't wait for this message\n    msg_col = 0;\n\n    --no_wait_return;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    void\ngive_warning2(char_u *message, char_u *a1, int hl)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just give\n\t// the raw message so the user at least gets a hint.\n\tgive_warning((char_u *)message, hl);\n    }\n    else\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE, (char *)message, a1);\n\tgive_warning(IObuff, hl);\n    }\n}\n#endif\n\n/*\n * Advance msg cursor to column \"col\".\n */\n    void\nmsg_advance(int col)\n{\n    if (msg_silent != 0)\t// nothing to advance to\n    {\n\tmsg_col = col;\t\t// for redirection, may fill it up later\n\treturn;\n    }\n    if (col >= Columns)\t\t// not enough room\n\tcol = Columns - 1;\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\twhile (msg_col > Columns - col)\n\t    msg_putchar(' ');\n    else\n#endif\n\twhile (msg_col < col)\n\t    msg_putchar(' ');\n}\n\n#if defined(FEAT_CON_DIALOG) || defined(PROTO)\n/*\n * Used for \"confirm()\" function, and the :confirm command prefix.\n * Versions which haven't got flexible dialogs yet, and console\n * versions, get this generic handler which uses the command line.\n *\n * type  = one of:\n *\t   VIM_QUESTION, VIM_INFO, VIM_WARNING, VIM_ERROR or VIM_GENERIC\n * title = title string (can be NULL for default)\n * (neither used in console dialogs at the moment)\n *\n * Format of the \"buttons\" string:\n * \"Button1Name\\nButton2Name\\nButton3Name\"\n * The first button should normally be the default/accept\n * The second button should be the 'Cancel' button\n * Other buttons- use your imagination!\n * A '&' in a button name becomes a shortcut, so each '&' should be before a\n * different letter.\n */\n    int\ndo_dialog(\n    int\t\ttype UNUSED,\n    char_u\t*title UNUSED,\n    char_u\t*message,\n    char_u\t*buttons,\n    int\t\tdfltbutton,\n    char_u\t*textfield UNUSED,\t// IObuff for inputdialog(), NULL\n\t\t\t\t\t// otherwise\n    int\t\tex_cmd)\t    // when TRUE pressing : accepts default and starts\n\t\t\t    // Ex command\n{\n    int\t\toldState;\n    int\t\tretval = 0;\n    char_u\t*hotkeys;\n    int\t\tc;\n    int\t\ti;\n    tmode_T\tsave_tmode;\n\n#ifndef NO_CONSOLE\n    // Don't output anything in silent mode (\"ex -s\")\n    if (silent_mode)\n\treturn dfltbutton;   // return default option\n#endif\n\n#ifdef FEAT_GUI_DIALOG\n    // When GUI is running and 'c' not in 'guioptions', use the GUI dialog\n    if (gui.in_use && vim_strchr(p_go, GO_CONDIALOG) == NULL)\n    {\n\tc = gui_mch_dialog(type, title, message, buttons, dfltbutton,\n\t\t\t\t\t\t\t   textfield, ex_cmd);\n\t// avoid a hit-enter prompt without clearing the cmdline\n\tneed_wait_return = FALSE;\n\temsg_on_display = FALSE;\n\tcmdline_row = msg_row;\n\n\t// Flush output to avoid that further messages and redrawing is done\n\t// in the wrong order.\n\tout_flush();\n\tgui_mch_update();\n\n\treturn c;\n    }\n#endif\n\n    oldState = State;\n    State = CONFIRM;\n    setmouse();\n\n    // Ensure raw mode here.\n    save_tmode = cur_tmode;\n    settmode(TMODE_RAW);\n\n    /*\n     * Since we wait for a keypress, don't make the\n     * user press RETURN as well afterwards.\n     */\n    ++no_wait_return;\n    hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);\n\n    if (hotkeys != NULL)\n    {\n\tfor (;;)\n\t{\n\t    // Get a typed character directly from the user.\n\t    c = get_keystroke();\n\t    switch (c)\n\t    {\n\t    case CAR:\t\t// User accepts default option\n\t    case NL:\n\t\tretval = dfltbutton;\n\t\tbreak;\n\t    case Ctrl_C:\t// User aborts/cancels\n\t    case ESC:\n\t\tretval = 0;\n\t\tbreak;\n\t    default:\t\t// Could be a hotkey?\n\t\tif (c < 0)\t// special keys are ignored here\n\t\t    continue;\n\t\tif (c == ':' && ex_cmd)\n\t\t{\n\t\t    retval = dfltbutton;\n\t\t    ins_char_typebuf(':', 0);\n\t\t    break;\n\t\t}\n\n\t\t// Make the character lowercase, as chars in \"hotkeys\" are.\n\t\tc = MB_TOLOWER(c);\n\t\tretval = 1;\n\t\tfor (i = 0; hotkeys[i]; ++i)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tif ((*mb_ptr2char)(hotkeys + i) == c)\n\t\t\t    break;\n\t\t\ti += (*mb_ptr2len)(hotkeys + i) - 1;\n\t\t    }\n\t\t    else\n\t\t\tif (hotkeys[i] == c)\n\t\t\t    break;\n\t\t    ++retval;\n\t\t}\n\t\tif (hotkeys[i])\n\t\t    break;\n\t\t// No hotkey match, so keep waiting\n\t\tcontinue;\n\t    }\n\t    break;\n\t}\n\n\tvim_free(hotkeys);\n    }\n\n    settmode(save_tmode);\n    State = oldState;\n    setmouse();\n    --no_wait_return;\n    msg_end_prompt();\n\n    return retval;\n}\n\n/*\n * Copy one character from \"*from\" to \"*to\", taking care of multi-byte\n * characters.  Return the length of the character in bytes.\n */\n    static int\ncopy_char(\n    char_u\t*from,\n    char_u\t*to,\n    int\t\tlowercase)\t// make character lower case\n{\n    int\t\tlen;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tif (lowercase)\n\t{\n\t    c = MB_TOLOWER((*mb_ptr2char)(from));\n\t    return (*mb_char2bytes)(c, to);\n\t}\n\telse\n\t{\n\t    len = (*mb_ptr2len)(from);\n\t    mch_memmove(to, from, (size_t)len);\n\t    return len;\n\t}\n    }\n    else\n    {\n\tif (lowercase)\n\t    *to = (char_u)TOLOWER_LOC(*from);\n\telse\n\t    *to = *from;\n\treturn 1;\n    }\n}\n\n/*\n * Format the dialog string, and display it at the bottom of\n * the screen. Return a string of hotkey chars (if defined) for\n * each 'button'. If a button has no hotkey defined, the first character of\n * the button is used.\n * The hotkeys can be multi-byte characters, but without combining chars.\n *\n * Returns an allocated string with hotkeys, or NULL for error.\n */\n    static char_u *\nmsg_show_console_dialog(\n    char_u\t*message,\n    char_u\t*buttons,\n    int\t\tdfltbutton)\n{\n    int\t\tlen = 0;\n#define HOTK_LEN (has_mbyte ? MB_MAXBYTES : 1)\n    int\t\tlenhotkey = HOTK_LEN;\t// count first button\n    char_u\t*hotk = NULL;\n    char_u\t*msgp = NULL;\n    char_u\t*hotkp = NULL;\n    char_u\t*r;\n    int\t\tcopy;\n#define HAS_HOTKEY_LEN 30\n    char_u\thas_hotkey[HAS_HOTKEY_LEN];\n    int\t\tfirst_hotkey = FALSE;\t// first char of button is hotkey\n    int\t\tidx;\n\n    has_hotkey[0] = FALSE;\n\n    /*\n     * First loop: compute the size of memory to allocate.\n     * Second loop: copy to the allocated memory.\n     */\n    for (copy = 0; copy <= 1; ++copy)\n    {\n\tr = buttons;\n\tidx = 0;\n\twhile (*r)\n\t{\n\t    if (*r == DLG_BUTTON_SEP)\n\t    {\n\t\tif (copy)\n\t\t{\n\t\t    *msgp++ = ',';\n\t\t    *msgp++ = ' ';\t    // '\\n' -> ', '\n\n\t\t    // advance to next hotkey and set default hotkey\n\t\t    if (has_mbyte)\n\t\t\thotkp += STRLEN(hotkp);\n\t\t    else\n\t\t\t++hotkp;\n\t\t    hotkp[copy_char(r + 1, hotkp, TRUE)] = NUL;\n\t\t    if (dfltbutton)\n\t\t\t--dfltbutton;\n\n\t\t    // If no hotkey is specified first char is used.\n\t\t    if (idx < HAS_HOTKEY_LEN - 1 && !has_hotkey[++idx])\n\t\t\tfirst_hotkey = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    len += 3;\t\t    // '\\n' -> ', '; 'x' -> '(x)'\n\t\t    lenhotkey += HOTK_LEN;  // each button needs a hotkey\n\t\t    if (idx < HAS_HOTKEY_LEN - 1)\n\t\t\thas_hotkey[++idx] = FALSE;\n\t\t}\n\t    }\n\t    else if (*r == DLG_HOTKEY_CHAR || first_hotkey)\n\t    {\n\t\tif (*r == DLG_HOTKEY_CHAR)\n\t\t    ++r;\n\t\tfirst_hotkey = FALSE;\n\t\tif (copy)\n\t\t{\n\t\t    if (*r == DLG_HOTKEY_CHAR)\t\t// '&&a' -> '&a'\n\t\t\t*msgp++ = *r;\n\t\t    else\n\t\t    {\n\t\t\t// '&a' -> '[a]'\n\t\t\t*msgp++ = (dfltbutton == 1) ? '[' : '(';\n\t\t\tmsgp += copy_char(r, msgp, FALSE);\n\t\t\t*msgp++ = (dfltbutton == 1) ? ']' : ')';\n\n\t\t\t// redefine hotkey\n\t\t\thotkp[copy_char(r, hotkp, TRUE)] = NUL;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++len;\t    // '&a' -> '[a]'\n\t\t    if (idx < HAS_HOTKEY_LEN - 1)\n\t\t\thas_hotkey[idx] = TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// everything else copy literally\n\t\tif (copy)\n\t\t    msgp += copy_char(r, msgp, FALSE);\n\t    }\n\n\t    // advance to the next character\n\t    MB_PTR_ADV(r);\n\t}\n\n\tif (copy)\n\t{\n\t    *msgp++ = ':';\n\t    *msgp++ = ' ';\n\t    *msgp = NUL;\n\t}\n\telse\n\t{\n\t    len += (int)(STRLEN(message)\n\t\t\t+ 2\t\t\t// for the NL's\n\t\t\t+ STRLEN(buttons)\n\t\t\t+ 3);\t\t\t// for the \": \" and NUL\n\t    lenhotkey++;\t\t\t// for the NUL\n\n\t    // If no hotkey is specified first char is used.\n\t    if (!has_hotkey[0])\n\t    {\n\t\tfirst_hotkey = TRUE;\n\t\tlen += 2;\t\t// \"x\" -> \"[x]\"\n\t    }\n\n\t    /*\n\t     * Now allocate and load the strings\n\t     */\n\t    vim_free(confirm_msg);\n\t    confirm_msg = alloc(len);\n\t    if (confirm_msg == NULL)\n\t\treturn NULL;\n\t    *confirm_msg = NUL;\n\t    hotk = alloc(lenhotkey);\n\t    if (hotk == NULL)\n\t\treturn NULL;\n\n\t    *confirm_msg = '\\n';\n\t    STRCPY(confirm_msg + 1, message);\n\n\t    msgp = confirm_msg + 1 + STRLEN(message);\n\t    hotkp = hotk;\n\n\t    // Define first default hotkey.  Keep the hotkey string NUL\n\t    // terminated to avoid reading past the end.\n\t    hotkp[copy_char(buttons, hotkp, TRUE)] = NUL;\n\n\t    // Remember where the choices start, displaying starts here when\n\t    // \"hotkp\" typed at the more prompt.\n\t    confirm_msg_tail = msgp;\n\t    *msgp++ = '\\n';\n\t}\n    }\n\n    display_confirm_msg();\n    return hotk;\n}\n\n/*\n * Display the \":confirm\" message.  Also called when screen resized.\n */\n    static void\ndisplay_confirm_msg(void)\n{\n    // avoid that 'q' at the more prompt truncates the message here\n    ++confirm_msg_used;\n    if (confirm_msg != NULL)\n\tmsg_puts_attr((char *)confirm_msg, HL_ATTR(HLF_M));\n    --confirm_msg_used;\n}\n\n#endif // FEAT_CON_DIALOG\n\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n\n    int\nvim_dialog_yesno(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    if (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)_(\"Question\") : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)\n\treturn VIM_YES;\n    return VIM_NO;\n}\n\n    int\nvim_dialog_yesnocancel(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    switch (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)_(\"Question\") : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE))\n    {\n\tcase 1: return VIM_YES;\n\tcase 2: return VIM_NO;\n    }\n    return VIM_CANCEL;\n}\n\n    int\nvim_dialog_yesnoallcancel(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    switch (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)\"Question\" : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),\n\t\t\t\t\t\t\t   dflt, NULL, FALSE))\n    {\n\tcase 1: return VIM_YES;\n\tcase 2: return VIM_NO;\n\tcase 3: return VIM_ALL;\n\tcase 4: return VIM_DISCARDALL;\n    }\n    return VIM_CANCEL;\n}\n\n#endif // FEAT_GUI_DIALOG || FEAT_CON_DIALOG\n", "/* alloc.c */\nvoid vim_mem_profile_dump(void);\nint alloc_does_fail(size_t size);\nvoid *alloc(size_t size);\nvoid *alloc_id(size_t size, alloc_id_T id);\nvoid *alloc_clear(size_t size);\nvoid *alloc_clear_id(size_t size, alloc_id_T id);\nvoid *lalloc_clear(size_t size, int message);\nvoid *lalloc(size_t size, int message);\nvoid *lalloc_id(size_t size, int message, alloc_id_T id);\nvoid *mem_realloc(void *ptr, size_t size);\nvoid do_outofmem_msg(size_t size);\nvoid free_all_mem(void);\nchar_u *vim_memsave(char_u *p, size_t len);\nvoid vim_free(void *x);\nvoid ga_clear(garray_T *gap);\nvoid ga_clear_strings(garray_T *gap);\nint ga_copy_strings(garray_T *from, garray_T *to);\nvoid ga_init(garray_T *gap);\nvoid ga_init2(garray_T *gap, int itemsize, int growsize);\nint ga_grow(garray_T *gap, int n);\nint ga_grow_inner(garray_T *gap, int n);\nchar_u *ga_concat_strings(garray_T *gap, char *sep);\nint ga_add_string(garray_T *gap, char_u *p);\nvoid ga_concat(garray_T *gap, char_u *s);\nvoid ga_concat_len(garray_T *gap, char_u *s, size_t len);\nvoid ga_append(garray_T *gap, int c);\nvoid append_ga_line(garray_T *gap);\n/* vim: set ft=c : */\n", "/* userfunc.c */\nvoid func_init(void);\nhashtab_T *func_tbl_get(void);\nchar_u *get_lambda_name(void);\nchar_u *register_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state);\nint get_lambda_tv(char_u **arg, typval_T *rettv, int types_optional, evalarg_T *evalarg);\nchar_u *deref_func_name(char_u *name, int *lenp, partial_T **partialp, type_T **type, int no_autoload, int *found_var);\nvoid emsg_funcname(char *ermsg, char_u *name);\nint get_func_tv(char_u *name, int len, typval_T *rettv, char_u **arg, evalarg_T *evalarg, funcexe_T *funcexe);\nchar_u *fname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error);\nufunc_T *find_func_even_dead(char_u *name, int is_global, cctx_T *cctx);\nufunc_T *find_func(char_u *name, int is_global, cctx_T *cctx);\nint func_is_global(ufunc_T *ufunc);\nint func_name_refcount(char_u *name);\nvoid func_clear_free(ufunc_T *fp, int force);\nint copy_func(char_u *lambda, char_u *global, ectx_T *ectx);\nint funcdepth_increment(void);\nvoid funcdepth_decrement(void);\nint funcdepth_get(void);\nvoid funcdepth_restore(int depth);\nint check_user_func_argcount(ufunc_T *fp, int argcount);\nint call_user_func_check(ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv, funcexe_T *funcexe, dict_T *selfdict);\nvoid save_funccal(funccal_entry_T *entry);\nvoid restore_funccal(void);\nfunccall_T *get_current_funccal(void);\nvoid delete_script_functions(int sid);\nvoid free_all_functions(void);\nint builtin_function(char_u *name, int len);\nint func_call(char_u *name, typval_T *args, partial_T *partial, dict_T *selfdict, typval_T *rettv);\nint get_callback_depth(void);\nint call_callback(callback_T *callback, int len, typval_T *rettv, int argcount, typval_T *argvars);\nvarnumber_T call_callback_retnr(callback_T *callback, int argcount, typval_T *argvars);\nvoid user_func_error(int error, char_u *name, funcexe_T *funcexe);\nint call_func(char_u *funcname, int len, typval_T *rettv, int argcount_in, typval_T *argvars_in, funcexe_T *funcexe);\nchar_u *printable_func_name(ufunc_T *fp);\nchar_u *trans_function_name(char_u **pp, int *is_global, int skip, int flags, funcdict_T *fdp, partial_T **partial, type_T **type);\nchar_u *untrans_function_name(char_u *name);\nchar_u *get_scriptlocal_funcname(char_u *funcname);\nchar_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);\nvoid list_functions(regmatch_T *regmatch);\nufunc_T *define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free);\nvoid ex_function(exarg_T *eap);\nvoid ex_defcompile(exarg_T *eap);\nint eval_fname_script(char_u *p);\nint translated_function_exists(char_u *name, int is_global);\nint has_varargs(ufunc_T *ufunc);\nint function_exists(char_u *name, int no_deref);\nchar_u *get_expanded_name(char_u *name, int check);\nchar_u *get_user_func_name(expand_T *xp, int idx);\nvoid ex_delfunction(exarg_T *eap);\nvoid func_unref(char_u *name);\nvoid func_ptr_unref(ufunc_T *fp);\nvoid func_ref(char_u *name);\nvoid func_ptr_ref(ufunc_T *fp);\nvoid ex_return(exarg_T *eap);\nvoid ex_call(exarg_T *eap);\nint do_return(exarg_T *eap, int reanimate, int is_cmd, void *rettv);\nvoid discard_pending_return(void *rettv);\nchar_u *get_return_cmd(void *rettv);\nchar_u *get_func_line(int c, void *cookie, int indent, getline_opt_T options);\nint func_has_ended(void *cookie);\nint func_has_abort(void *cookie);\ndict_T *make_partial(dict_T *selfdict_in, typval_T *rettv);\nchar_u *func_name(void *cookie);\nlinenr_T *func_breakpoint(void *cookie);\nint *func_dbg_tick(void *cookie);\nint func_level(void *cookie);\nint current_func_returned(void);\nint free_unref_funccal(int copyID, int testing);\nhashtab_T *get_funccal_local_ht(void);\ndictitem_T *get_funccal_local_var(void);\nhashtab_T *get_funccal_args_ht(void);\ndictitem_T *get_funccal_args_var(void);\nvoid list_func_vars(int *first);\ndict_T *get_current_funccal_dict(hashtab_T *ht);\nhashitem_T *find_hi_in_scoped_ht(char_u *name, hashtab_T **pht);\ndictitem_T *find_var_in_scoped_ht(char_u *name, int no_autoload);\nint set_ref_in_previous_funccal(int copyID);\nint set_ref_in_call_stack(int copyID);\nint set_ref_in_functions(int copyID);\nint set_ref_in_func_args(int copyID);\nint set_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID);\n/* vim: set ft=c : */\n", "\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nsource view_util.vim\nsource vim9.vim\nsource screendump.vim\n\nfunc Test_def_basic()\n  def SomeFunc(): string\n    return 'yes'\n  enddef\n  call SomeFunc()->assert_equal('yes')\nendfunc\n\nfunc Test_compiling_error()\n  \" use a terminal to see the whole error message\n  CheckRunVimInTerminal\n\n  call TestCompilingError()\n  call TestCompilingErrorInTry()\nendfunc\n\ndef TestCompilingError()\n  var lines =<< trim END\n    vim9script\n    def Fails()\n      echo nothing\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_compile_error')\n  var buf = RunVimInTerminal('-S XTest_compile_error',\n              {rows: 10, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Error detected while compiling command line.*Fails.*Variable not found: nothing',\n                     Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_compile_error')\nenddef\n\ndef TestCompilingErrorInTry()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      def script#OnlyCompiled()\n        g:runtime = 'yes'\n        invalid\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  lines =<< trim END\n      vim9script\n      todo\n      try\n        script#OnlyCompiled()\n      catch /nothing/\n      endtry\n  END\n  lines[1] = 'set rtp=' .. getcwd() .. '/Xdir'\n  writefile(lines, 'XTest_compile_error')\n\n  var buf = RunVimInTerminal('-S XTest_compile_error', {rows: 10, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Error detected while compiling command line.*function script#OnlyCompiled.*Invalid command: invalid',\n                     Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_compile_error')\n  delete('Xdir', 'rf')\nenddef\n\ndef Test_compile_error_in_called_function()\n  var lines =<< trim END\n      vim9script\n      var n: number\n      def Foo()\n        &hls = n\n      enddef\n      def Bar()\n        Foo()\n      enddef\n      silent! Foo()\n      Bar()\n  END\n  CheckScriptFailureList(lines, ['E1012:', 'E1191:'])\nenddef\n\ndef Test_wrong_function_name()\n  var lines =<< trim END\n      vim9script\n      func _Foo()\n        echo 'foo'\n      endfunc\n  END\n  CheckScriptFailure(lines, 'E128:')\n\n  lines =<< trim END\n      vim9script\n      def _Foo()\n        echo 'foo'\n      enddef\n  END\n  CheckScriptFailure(lines, 'E128:')\nenddef\n\ndef Test_autoload_name_mismatch()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      def scriptX#Function()\n        # comment\n        g:runtime = 'yes'\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n  lines =<< trim END\n      call script#Function()\n  END\n  CheckScriptFailure(lines, 'E746:', 2)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_names()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func foobar#function()\n        return 'yes'\n      endfunc\n      let foobar#var = 'no'\n  END\n  writefile(lines, dir .. '/foobar.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  lines =<< trim END\n      assert_equal('yes', foobar#function())\n      var Function = foobar#function\n      assert_equal('yes', Function())\n\n      assert_equal('no', foobar#var)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_error_in_script()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func scripterror#function()\n        let g:called_function = 'yes'\n      endfunc\n      let 0 = 1\n  END\n  writefile(lines, dir .. '/scripterror.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  g:called_function = 'no'\n  # The error in the autoload script cannot be checked with assert_fails(), use\n  # CheckDefSuccess() instead of CheckDefFailure()\n  try\n    CheckDefSuccess(['scripterror#function()'])\n  catch\n    assert_match('E121: Undefined variable: 0', v:exception)\n  endtry\n  assert_equal('no', g:called_function)\n\n  lines =<< trim END\n      func scriptcaught#function()\n        let g:called_function = 'yes'\n      endfunc\n      try\n        let 0 = 1\n      catch\n        let g:caught = v:exception\n      endtry\n  END\n  writefile(lines, dir .. '/scriptcaught.vim')\n\n  g:called_function = 'no'\n  CheckDefSuccess(['scriptcaught#function()'])\n  assert_match('E121: Undefined variable: 0', g:caught)\n  assert_equal('yes', g:called_function)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef CallRecursive(n: number): number\n  return CallRecursive(n + 1)\nenddef\n\ndef CallMapRecursive(l: list<number>): number\n  return map(l, (_, v) => CallMapRecursive([v]))[0]\nenddef\n\ndef Test_funcdepth_error()\n  set maxfuncdepth=10\n\n  var caught = false\n  try\n    CallRecursive(1)\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  caught = false\n  try\n    CallMapRecursive([1])\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  set maxfuncdepth&\nenddef\n\ndef Test_endfunc_enddef()\n  var lines =<< trim END\n    def Test()\n      echo 'test'\n      endfunc\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1151:', 3)\n\n  lines =<< trim END\n    def Test()\n      func Nested()\n        echo 'test'\n      enddef\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1152:', 4)\n\n  lines =<< trim END\n    def Ok()\n      echo 'hello'\n    enddef | echo 'there'\n    def Bad()\n      echo 'hello'\n    enddef there\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: there', 6)\nenddef\n\ndef Test_missing_endfunc_enddef()\n  var lines =<< trim END\n    vim9script\n    def Test()\n      echo 'test'\n    endef\n  END\n  CheckScriptFailure(lines, 'E1057:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Some()\n      echo 'test'\n    enfffunc\n  END\n  CheckScriptFailure(lines, 'E126:', 2)\nenddef\n\ndef Test_white_space_before_paren()\n  var lines =<< trim END\n    vim9script\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_enddef_dict_key()\n  var d = {\n    enddef: 'x',\n    endfunc: 'y',\n  }\n  assert_equal({enddef: 'x', endfunc: 'y'}, d)\nenddef\n\ndef ReturnString(): string\n  return 'string'\nenddef\n\ndef ReturnNumber(): number\n  return 123\nenddef\n\nlet g:notNumber = 'string'\n\ndef ReturnGlobal(): number\n  return g:notNumber\nenddef\n\ndef Test_return_something()\n  ReturnString()->assert_equal('string')\n  ReturnNumber()->assert_equal(123)\n  assert_fails('ReturnGlobal()', 'E1012: Type mismatch; expected number but got string', '', 1, 'ReturnGlobal')\nenddef\n\ndef Test_check_argument_type()\n  var lines =<< trim END\n      vim9script\n      def Val(a: number, b: number): number\n        return 0\n      enddef\n      def Func()\n        var x: any = true\n        Val(0, x)\n      enddef\n      disass Func\n      Func()\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got bool', 2)\nenddef\n\ndef Test_missing_return()\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    echo \"no return\"',\n                   '  else',\n                   '    return 0',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    echo \"no return\"',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    return 2',\n                   '  endif'\n                   '  return 3'\n                   'enddef'], 'E1095:')\nenddef\n\ndef Test_return_bool()\n  var lines =<< trim END\n      vim9script\n      def MenuFilter(id: number, key: string): bool\n        return popup_filter_menu(id, key)\n      enddef\n      def YesnoFilter(id: number, key: string): bool\n        return popup_filter_yesno(id, key)\n      enddef\n      defcompile\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet s:nothing = 0\ndef ReturnNothing()\n  s:nothing = 1\n  if true\n    return\n  endif\n  s:nothing = 2\nenddef\n\ndef Test_return_nothing()\n  ReturnNothing()\n  s:nothing->assert_equal(1)\nenddef\n\ndef Test_return_invalid()\n  var lines =<< trim END\n    vim9script\n    def Func(): invalid\n      return xxx\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E1010:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n          return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      defcompile\n      def Inc(nr: number): nr\n        return nr + 2\n      enddef\n      echo Test(Inc)\n  END\n  # doing this twice was leaking memory\n  CheckScriptFailure(lines, 'E1010:')\n  CheckScriptFailure(lines, 'E1010:')\nenddef\n\ndef Test_return_list_any()\n  # This used to fail but now the actual list type is checked, and since it has\n  # an item of type string it can be used as list<string>.\n  var lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l->add('string')\n        return l\n      enddef\n      echo Func()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l += ['string']\n        return l\n      enddef\n      echo Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nfunc Increment()\n  let g:counter += 1\nendfunc\n\ndef Test_call_ufunc_count()\n  g:counter = 1\n  Increment()\n  Increment()\n  Increment()\n  # works with and without :call\n  g:counter->assert_equal(4)\n  eval g:counter->assert_equal(4)\n  unlet g:counter\nenddef\n\ndef MyVarargs(arg: string, ...rest: list<string>): string\n  var res = arg\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_varargs()\n  MyVarargs('one')->assert_equal('one')\n  MyVarargs('one', 'two')->assert_equal('one,two')\n  MyVarargs('one', 'two', 'three')->assert_equal('one,two,three')\nenddef\n\ndef Test_call_white_space()\n  CheckDefAndScriptFailure([\"call Test ('text')\"], ['E476:', 'E1068:'])\nenddef\n\ndef MyDefaultArgs(name = 'string'): string\n  return name\nenddef\n\ndef MyDefaultSecond(name: string, second: bool  = true): string\n  return second ? name : 'none'\nenddef\n\n\ndef Test_call_default_args()\n  MyDefaultArgs()->assert_equal('string')\n  MyDefaultArgs(v:none)->assert_equal('string')\n  MyDefaultArgs('one')->assert_equal('one')\n  assert_fails('MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 4, 'Test_call_default_args')\n\n  MyDefaultSecond('test')->assert_equal('test')\n  MyDefaultSecond('test', true)->assert_equal('test')\n  MyDefaultSecond('test', false)->assert_equal('none')\n\n  var lines =<< trim END\n      def MyDefaultThird(name: string, aa = 'aa', bb = 'bb'): string\n        return name .. aa .. bb\n      enddef\n\n      MyDefaultThird('->')->assert_equal('->aabb')\n      MyDefaultThird('->', v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx')->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx', v:none)->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, 'yy')->assert_equal('->aayy')\n      MyDefaultThird('->', 'xx', 'yy')->assert_equal('->xxyy')\n\n      def DefArg(mandatory: any, optional = mandatory): string\n        return mandatory .. optional\n      enddef\n      DefArg(1234)->assert_equal('12341234')\n      DefArg(\"ok\")->assert_equal('okok')\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckScriptFailure(['def Func(arg: number = asdf)', 'enddef', 'defcompile'], 'E1001:')\n  delfunc g:Func\n  CheckScriptFailure(['def Func(arg: number = \"text\")', 'enddef', 'defcompile'], 'E1013: Argument 1: type mismatch, expected number but got string')\n  delfunc g:Func\n  CheckDefFailure(['def Func(x: number = )', 'enddef'], 'E15:')\n\n  lines =<< trim END\n      vim9script\n      def Func(a = b == 0 ? 1 : 2, b = 0)\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1001: Variable not found: b')\n\n  # using script variable requires matching type or type cast when executed\n  lines =<< trim END\n      vim9script\n      var a: any\n      def Func(arg: string = a)\n        echo arg\n      enddef\n      defcompile\n  END\n  CheckScriptSuccess(lines + ['a = \"text\"', 'Func()'])\n  CheckScriptFailure(lines + ['a = 123', 'Func()'], 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  # using global variable does not require type cast\n  lines =<< trim END\n      vim9script\n      def Func(arg: string = g:str)\n        echo arg\n      enddef\n      g:str = 'works'\n      Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef FuncWithComment(  # comment\n  a: number, #comment\n  b: bool, # comment\n  c: string) #comment\n  assert_equal(4, a)\n  assert_equal(true, b)\n  assert_equal('yes', c)\nenddef\n\ndef Test_func_with_comments()\n  FuncWithComment(4, true, 'yes')\n\n  var lines =<< trim END\n      def Func(# comment\n        arg: string)\n      enddef\n  END\n  CheckScriptFailure(lines, 'E125:', 1)\n\n  lines =<< trim END\n      def Func(\n        arg: string# comment\n        )\n      enddef\n  END\n  CheckScriptFailure(lines, 'E475:', 2)\n\n  lines =<< trim END\n      def Func(\n        arg: string\n        )# comment\n      enddef\n  END\n  CheckScriptFailure(lines, 'E488:', 3)\nenddef\n\ndef Test_nested_function()\n  def NestedDef(arg: string): string\n    return 'nested ' .. arg\n  enddef\n  NestedDef(':def')->assert_equal('nested :def')\n\n  func NestedFunc(arg)\n    return 'nested ' .. a:arg\n  endfunc\n  NestedFunc(':func')->assert_equal('nested :func')\n\n  CheckDefFailure(['def Nested()', 'enddef', 'Nested(66)'], 'E118:')\n  CheckDefFailure(['def Nested(arg: string)', 'enddef', 'Nested()'], 'E119:')\n\n  CheckDefFailure(['def s:Nested()', 'enddef'], 'E1075:')\n  CheckDefFailure(['def b:Nested()', 'enddef'], 'E1075:')\n\n  var lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def Inner()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1073:')\n\n  lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def! Inner()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1117:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          g:result = 'ok'\n        enddef\n        Inner()\n      enddef\n      Outer()\n      Inner()\n  END\n  CheckScriptFailure(lines, 'E117: Unknown function: Inner')\n  assert_equal('ok', g:result)\n  unlet g:result\n\n  # nested function inside conditional\n  lines =<< trim END\n      vim9script\n      var thecount = 0\n      if true\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  CheckScriptSuccess(lines)\n\n  # also works when \"thecount\" is inside the \"if\" block\n  lines =<< trim END\n      vim9script\n      if true\n        var thecount = 0\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          echo 'hello'\n        enddef burp\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: burp', 3)\nenddef\n\ndef Test_not_nested_function()\n  echo printf('%d',\n      function('len')('xxx'))\nenddef\n\nfunc Test_call_default_args_from_func()\n  call MyDefaultArgs()->assert_equal('string')\n  call MyDefaultArgs('one')->assert_equal('one')\n  call assert_fails('call MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 3, 'Test_call_default_args_from_func')\nendfunc\n\ndef Test_nested_global_function()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          func g:Inner()\n            return 'inner'\n          endfunc\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      Outer()\n  END\n  CheckScriptFailure(lines, \"E122:\")\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:Inner()\n          echo map([1, 2, 3], (_, v) => v + 1)\n        enddef\n        g:Inner()\n      enddef\n      Outer()\n  END\n  CheckScriptSuccess(lines)\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Outer()\n        def Func()\n          echo 'inner'\n        enddef\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, \"E1073:\", 1)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Func()\n        echo 'script'\n      enddef\n  END\n  CheckScriptFailure(lines, \"E1073:\", 5)\nenddef\n\ndef DefListAll()\n  def\nenddef\n\ndef DefListOne()\n  def DefListOne\nenddef\n\ndef DefListMatches()\n  def /DefList\nenddef\n\ndef Test_nested_def_list()\n  var funcs = split(execute('call DefListAll()'), \"\\n\")\n  assert_true(len(funcs) > 10)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n\n  funcs = split(execute('call DefListOne()'), \"\\n\")\n  assert_equal(['   def DefListOne()', '1    def DefListOne', '   enddef'], funcs)\n\n  funcs = split(execute('call DefListMatches()'), \"\\n\")\n  assert_true(len(funcs) >= 3)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n  assert_true(funcs->index('def DefListOne()') >= 0)\n  assert_true(funcs->index('def DefListMatches()') >= 0)\n\n  var lines =<< trim END\n    vim9script\n    def Func()\n      def +Func+\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E476:', 1)\nenddef\n\ndef Test_global_local_function()\n  var lines =<< trim END\n      vim9script\n      def g:Func(): string\n          return 'global'\n      enddef\n      def Func(): string\n          return 'local'\n      enddef\n      g:Func()->assert_equal('global')\n      Func()->assert_equal('local')\n      delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Funcy()\n        echo 'funcy'\n      enddef\n      s:Funcy()\n  END\n  CheckScriptFailure(lines, 'E117:')\nenddef\n\ndef Test_local_function_shadows_global()\n  var lines =<< trim END\n      vim9script\n      def g:Gfunc(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): number\n        var Gfunc = function('len')\n        return Gfunc('testing')\n      enddef\n      g:Gfunc()->assert_equal('global')\n      AnotherFunc()->assert_equal(7)\n      delfunc g:Gfunc\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc()\n        g:Func = function('len')\n      enddef\n      AnotherFunc()\n  END\n  CheckScriptFailure(lines, 'E705:')\n  delfunc g:Func\n\n  # global function is found without g: prefix\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): string\n        return Func()\n      enddef\n      assert_equal('global', AnotherFunc())\n    delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      assert_equal('global', Func())\n      delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  # This does not shadow \"i\" which is visible only inside the for loop\n  lines =<< trim END\n      vim9script\n\n      def Foo(i: number)\n        echo i\n      enddef\n\n      for i in range(3)\n        # Foo() is compiled here\n        Foo(i)\n      endfor\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nfunc TakesOneArg(arg)\n  echo a:arg\nendfunc\n\ndef Test_call_wrong_args()\n  CheckDefFailure(['TakesOneArg()'], 'E119:')\n  CheckDefFailure(['TakesOneArg(11, 22)'], 'E118:')\n  CheckDefFailure(['bufnr(xxx)'], 'E1001:')\n  CheckScriptFailure(['def Func(Ref: func(s: string))'], 'E475:')\n\n  var lines =<< trim END\n    vim9script\n    def Func(s: string)\n      echo s\n    enddef\n    Func([])\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got list<unknown>', 5)\n\n  # argument name declared earlier is found when declaring a function\n  lines =<< trim END\n    vim9script\n    var name = 'piet'\n    def FuncOne(name: string)\n      echo nr\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1168:')\n\n  # argument name declared later is only found when compiling\n  lines =<< trim END\n    vim9script\n    def FuncOne(name: string)\n      echo nr\n    enddef\n    var name = 'piet'\n  END\n  CheckScriptSuccess(lines)\n  CheckScriptFailure(lines + ['defcompile'], 'E1168:')\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne()\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  var didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E119: Not enough arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne(1, 2)\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E118: Too many arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  delete('Xscript')\nenddef\n\ndef Test_call_funcref_wrong_args()\n  var head =<< trim END\n      vim9script\n      def Func3(a1: string, a2: number, a3: list<number>)\n        echo a1 .. a2 .. a3[0]\n      enddef\n      def Testme()\n        var funcMap: dict<func> = {func: Func3}\n  END\n  var tail =<< trim END\n      enddef\n      Testme()\n  END\n  CheckScriptSuccess(head + [\"funcMap['func']('str', 123, [1, 2, 3])\"] + tail)\n\n  CheckScriptFailure(head + [\"funcMap['func']('str', 123)\"] + tail, 'E119:')\n  CheckScriptFailure(head + [\"funcMap['func']('str', 123, [1], 4)\"] + tail, 'E118:')\n\n  var lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      echo Ref(false)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\n\n  lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      call Ref(false)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\nenddef\n\ndef Test_call_lambda_args()\n  var lines =<< trim END\n    var Callback = (..._) => 'anything'\n    assert_equal('anything', Callback())\n    assert_equal('anything', Callback(1))\n    assert_equal('anything', Callback('a', 2))\n\n    assert_equal('xyz', ((a: string): string => a)('xyz'))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefFailure(['echo ((i) => 0)()'],\n                  'E119: Not enough arguments for function: ((i) => 0)()')\n\n  lines =<< trim END\n      var Ref = (x: number, y: number) => x + y\n      echo Ref(1, 'x')\n  END\n  CheckDefFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string')\n\n  lines =<< trim END\n    var Ref: func(job, string, number)\n    Ref = (x, y) => 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n    var Ref: func(job, string)\n    Ref = (x, y, z) => 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n      var one = 1\n      var l = [1, 2, 3]\n      echo map(l, (one) => one)\n  END\n  CheckDefFailure(lines, 'E1167:')\n  CheckScriptFailure(['vim9script'] + lines, 'E1168:')\n\n  lines =<< trim END\n    var Ref: func(any, ?any): bool\n    Ref = (_, y = 1) => false\n  END\n  CheckDefAndScriptFailure(lines, 'E1172:')\n\n  lines =<< trim END\n      var a = 0\n      var b = (a == 0 ? 1 : 2)\n      assert_equal(1, b)\n      var txt = 'a'\n      b = (txt =~ 'x' ? 1 : 2)\n      assert_equal(2, b)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      def ShadowLocal()\n        var one = 1\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n      def Shadowarg(one: number)\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n    echo ((a) => a)('aa', 'bb')\n  END\n  CheckDefAndScriptFailure(lines, 'E118:', 1)\n\n  lines =<< trim END\n    echo 'aa'->((a) => a)('bb')\n  END\n  CheckDefFailure(lines, 'E118: Too many arguments for function: ->((a) => a)(''bb'')', 1)\n  CheckScriptFailure(['vim9script'] + lines, 'E118: Too many arguments for function: <lambda>', 2)\nenddef\n\ndef Test_lambda_line_nr()\n  var lines =<< trim END\n      vim9script\n      # comment\n      # comment\n      var id = timer_start(1'000, (_) => 0)\n      var out = execute('verbose ' .. timer_info(id)[0].callback\n          ->string()\n          ->substitute(\"('\\\\|')\", ' ', 'g'))\n      assert_match('Last set from .* line 4', out)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef FilterWithCond(x: string, Cond: func(string): bool): bool\n  return Cond(x)\nenddef\n\ndef Test_lambda_return_type()\n  var lines =<< trim END\n    var Ref = (): => 123\n  END\n  CheckDefAndScriptFailure(lines, 'E1157:', 1)\n\n  # no space before the return type\n  lines =<< trim END\n    var Ref = (x):number => x + 1\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  # this works\n  for x in ['foo', 'boo']\n    echo FilterWithCond(x, (v) => v =~ '^b')\n  endfor\n\n  # this fails\n  lines =<< trim END\n      echo FilterWithCond('foo', (v) => v .. '^b')\n  END\n  CheckDefAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected func(string): bool but got func(any): string', 1)\n\n  lines =<< trim END\n      var Lambda1 = (x) => {\n              return x\n              }\n      assert_equal('asdf', Lambda1('asdf'))\n      var Lambda2 = (x): string => {\n              return x\n              }\n      assert_equal('foo', Lambda2('foo'))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var Lambda = (x): string => {\n              return x\n              }\n      echo Lambda(['foo'])\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_lambda_uses_assigned_var()\n  CheckDefSuccess([\n        'var x: any = \"aaa\"'\n        'x = filter([\"bbb\"], (_, v) => v =~ x)'])\nenddef\n\ndef Test_pass_legacy_lambda_to_def_func()\n  var lines =<< trim END\n      vim9script\n      func Foo()\n        eval s:Bar({x -> 0})\n      endfunc\n      def Bar(y: any)\n      enddef\n      Foo()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:TestFunc(f: func)\n      enddef\n      legacy call g:TestFunc({-> 0})\n      delfunc g:TestFunc\n\n      def g:TestFunc(f: func(number))\n      enddef\n      legacy call g:TestFunc({nr -> 0})\n      delfunc g:TestFunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_in_reduce_line_break()\n  # this was using freed memory\n  var lines =<< trim END\n      vim9script\n      const result: dict<number> =\n          ['Bob', 'Sam', 'Cat', 'Bob', 'Cat', 'Cat']\n          ->reduce((acc, val) => {\n              if has_key(acc, val)\n                  acc[val] += 1\n                  return acc\n              else\n                  acc[val] = 1\n                  return acc\n              endif\n          }, {})\n      assert_equal({Bob: 2, Sam: 1, Cat: 3}, result)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_lambda()\n  var lines =<< trim END\n    vim9script\n    nnoremap <expr> <F4> <SID>CountSpaces() .. '_'\n    def CountSpaces(type = ''): string\n      if type == ''\n        &operatorfunc = (t) => CountSpaces(t)\n        return 'g@'\n      endif\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"\\<F4>\", 'x')\n    assert_equal(4, g:result)\n    bwipe!\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_global_function()\n  var lines =<< trim END\n    vim9script\n    def g:CountSpaces(type = ''): string\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    # global function works at script level\n    &operatorfunc = g:CountSpaces\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    &operatorfunc = ''\n    g:result = 0\n    # global function works in :def function\n    def Func()\n      &operatorfunc = g:CountSpaces\n    enddef\n    Func()\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    bwipe!\n  END\n  CheckScriptSuccess(lines)\n  &operatorfunc = ''\nenddef\n\ndef Test_use_script_func_name_with_prefix()\n  var lines =<< trim END\n      vim9script\n      func s:Getit()\n        return 'it'\n      endfunc\n      var Fn = s:Getit\n      assert_equal('it', Fn())\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_type_allocated()\n  # Check that unreferencing a partial using a lambda can use the variable type\n  # after the lambda has been freed and does not leak memory.\n  var lines =<< trim END\n    vim9script\n\n    func MyomniFunc1(val, findstart, base)\n      return a:findstart ? 0 : []\n    endfunc\n\n    var Lambda = (a, b) => MyomniFunc1(19, a, b)\n    &omnifunc = Lambda\n    Lambda = (a, b) => MyomniFunc1(20, a, b)\n    &omnifunc = string(Lambda)\n    Lambda = (a, b) => strlen(a)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\n\" Default arg and varargs\ndef MyDefVarargs(one: string, two = 'foo', ...rest: list<string>): string\n  var res = one .. ',' .. two\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_def_varargs()\n  assert_fails('MyDefVarargs()', 'E119:', '', 1, 'Test_call_def_varargs')\n  MyDefVarargs('one')->assert_equal('one,foo')\n  MyDefVarargs('one', 'two')->assert_equal('one,two')\n  MyDefVarargs('one', 'two', 'three')->assert_equal('one,two,three')\n  CheckDefFailure(['MyDefVarargs(\"one\", 22)'],\n      'E1013: Argument 2: type mismatch, expected string but got number')\n  CheckDefFailure(['MyDefVarargs(\"one\", \"two\", 123)'],\n      'E1013: Argument 3: type mismatch, expected string but got number')\n\n  var lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<any>)\n        echo l\n      enddef\n      Func(0)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: any)\n        echo l\n      enddef\n      Func(0)\n  END\n  CheckScriptFailure(lines, 'E1180:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Func(..._l: list<string>)\n        echo _l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 2, 3)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 9)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 'a')\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(  # some comment\n                ...l = []\n                )\n        echo l\n      enddef\n  END\n  CheckScriptFailure(lines, 'E1160:')\n\n  lines =<< trim END\n      vim9script\n      def DoIt()\n        g:Later('')\n      enddef\n      defcompile\n      def g:Later(...l:  list<number>)\n      enddef\n      DoIt()\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got string')\nenddef\n\nlet s:value = ''\n\ndef FuncOneDefArg(opt = 'text')\n  s:value = opt\nenddef\n\ndef FuncTwoDefArg(nr = 123, opt = 'text'): string\n  return nr .. opt\nenddef\n\ndef FuncVarargs(...arg: list<string>): string\n  return join(arg, ',')\nenddef\n\ndef Test_func_type_varargs()\n  var RefDefArg: func(?string)\n  RefDefArg = FuncOneDefArg\n  RefDefArg()\n  s:value->assert_equal('text')\n  RefDefArg('some')\n  s:value->assert_equal('some')\n\n  var RefDef2Arg: func(?number, ?string): string\n  RefDef2Arg = FuncTwoDefArg\n  RefDef2Arg()->assert_equal('123text')\n  RefDef2Arg(99)->assert_equal('99text')\n  RefDef2Arg(77, 'some')->assert_equal('77some')\n\n  CheckDefFailure(['var RefWrong: func(string?)'], 'E1010:')\n  CheckDefFailure(['var RefWrong: func(?string, string)'], 'E1007:')\n\n  var RefVarargs: func(...list<string>): string\n  RefVarargs = FuncVarargs\n  RefVarargs()->assert_equal('')\n  RefVarargs('one')->assert_equal('one')\n  RefVarargs('one', 'two')->assert_equal('one,two')\n\n  CheckDefFailure(['var RefWrong: func(...list<string>, string)'], 'E110:')\n  CheckDefFailure(['var RefWrong: func(...list<string>, ?string)'], 'E110:')\nenddef\n\n\" Only varargs\ndef MyVarargsOnly(...args: list<string>): string\n  return join(args, ',')\nenddef\n\ndef Test_call_varargs_only()\n  MyVarargsOnly()->assert_equal('')\n  MyVarargsOnly('one')->assert_equal('one')\n  MyVarargsOnly('one', 'two')->assert_equal('one,two')\n  CheckDefFailure(['MyVarargsOnly(1)'], 'E1013: Argument 1: type mismatch, expected string but got number')\n  CheckDefFailure(['MyVarargsOnly(\"one\", 2)'], 'E1013: Argument 2: type mismatch, expected string but got number')\nenddef\n\ndef Test_using_var_as_arg()\n  var lines =<< trim END\n      def Func(x: number)\n        var x = 234\n      enddef\n  END\n  CheckDefFailure(lines, 'E1006:')\n\n  lines =<< trim END\n      def Func(Ref: number)\n        def Ref()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1073:')\nenddef\n\ndef DictArg(arg: dict<string>)\n  arg['key'] = 'value'\nenddef\n\ndef ListArg(arg: list<string>)\n  arg[0] = 'value'\nenddef\n\ndef Test_assign_to_argument()\n  # works for dict and list\n  var d: dict<string> = {}\n  DictArg(d)\n  d['key']->assert_equal('value')\n  var l: list<string> = []\n  ListArg(l)\n  l[0]->assert_equal('value')\n\n  CheckScriptFailure(['def Func(arg: number)', 'arg = 3', 'enddef', 'defcompile'], 'E1090:')\n  delfunc! g:Func\nenddef\n\n\" These argument names are reserved in legacy functions.\ndef WithReservedNames(firstline: string, lastline: string): string\n  return firstline .. lastline\nenddef\n\ndef Test_argument_names()\n  assert_equal('OK', WithReservedNames('O', 'K'))\nenddef\n\ndef Test_call_func_defined_later()\n  g:DefinedLater('one')->assert_equal('one')\n  assert_fails('NotDefined(\"one\")', 'E117:', '', 2, 'Test_call_func_defined_later')\nenddef\n\nfunc DefinedLater(arg)\n  return a:arg\nendfunc\n\ndef Test_call_funcref()\n  g:SomeFunc('abc')->assert_equal(3)\n  assert_fails('NotAFunc()', 'E117:', '', 2, 'Test_call_funcref') # comment after call\n  assert_fails('g:NotAFunc()', 'E1085:', '', 3, 'Test_call_funcref')\n\n  var lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    var Funcref: func: number = function('RetNumber')\n    Funcref()->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    def Bar(F: func: number): number\n      return F()\n    enddef\n    var Funcref = function('RetNumber')\n    Bar(Funcref)->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(number) = function('UseNumber')\n    Funcref(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(string) = function('UseNumber')\n  END\n  CheckScriptFailure(lines, 'E1012: Type mismatch; expected func(string) but got func(number)')\n\n  lines =<< trim END\n    vim9script\n    def EchoNr(nr = 34)\n      g:echo = nr\n    enddef\n    var Funcref: func(?number) = function('EchoNr')\n    Funcref()\n    g:echo->assert_equal(34)\n    Funcref(123)\n    g:echo->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def EchoList(...l: list<number>)\n      g:echo = l\n    enddef\n    var Funcref: func(...list<number>) = function('EchoList')\n    Funcref()\n    g:echo->assert_equal([])\n    Funcref(1, 2, 3)\n    g:echo->assert_equal([1, 2, 3])\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def OptAndVar(nr: number, opt = 12, ...l: list<number>): number\n      g:optarg = opt\n      g:listarg = l\n      return nr\n    enddef\n    var Funcref: func(number, ?number, ...list<number>): number = function('OptAndVar')\n    Funcref(10)->assert_equal(10)\n    g:optarg->assert_equal(12)\n    g:listarg->assert_equal([])\n\n    Funcref(11, 22)->assert_equal(11)\n    g:optarg->assert_equal(22)\n    g:listarg->assert_equal([])\n\n    Funcref(17, 18, 1, 2, 3)->assert_equal(17)\n    g:optarg->assert_equal(18)\n    g:listarg->assert_equal([1, 2, 3])\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet SomeFunc = function('len')\nlet NotAFunc = 'text'\n\ndef CombineFuncrefTypes()\n  # same arguments, different return type\n  var Ref1: func(bool): string\n  var Ref2: func(bool): number\n  var Ref3: func(bool): any\n  Ref3 = g:cond ? Ref1 : Ref2\n\n  # different number of arguments\n  var Refa1: func(bool): number\n  var Refa2: func(bool, number): number\n  var Refa3: func: number\n  Refa3 = g:cond ? Refa1 : Refa2\n\n  # different argument types\n  var Refb1: func(bool, string): number\n  var Refb2: func(string, number): number\n  var Refb3: func(any, any): number\n  Refb3 = g:cond ? Refb1 : Refb2\nenddef\n\ndef FuncWithForwardCall()\n  return g:DefinedEvenLater(\"yes\")\nenddef\n\ndef DefinedEvenLater(arg: string): string\n  return arg\nenddef\n\ndef Test_error_in_nested_function()\n  # Error in called function requires unwinding the call stack.\n  assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')\nenddef\n\ndef Test_nested_function_with_nextcmd()\n  var lines =<< trim END\n      vim9script\n      # Define an outer function\n      def FirstFunction()\n        # Define an inner function\n        def SecondFunction()\n          # the function has a body, a double free is detected.\n          AAAAA\n\n         # enddef followed by | or } followed by # one or more characters\n         enddef|BBBB\n      enddef\n\n      # Compile all functions\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')\nenddef\n\ndef Test_nested_function_with_args_split()\n  var lines =<< trim END\n      vim9script\n      def FirstFunction()\n        def SecondFunction(\n        )\n        # had a double free if the right parenthesis of the nested function is\n        # on the next line\n         \n        enddef|BBBB\n      enddef\n      # Compile all functions\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')\n\n  lines =<< trim END\n      vim9script\n      def FirstFunction()\n        func SecondFunction()\n        endfunc|BBBB\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')\nenddef\n\ndef Test_return_type_wrong()\n  CheckScriptFailure([\n        'def Func(): number',\n        'return \"a\"',\n        'enddef',\n        'defcompile'], 'expected number but got string')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func(): string',\n        'return 1',\n        'enddef',\n        'defcompile'], 'expected string but got number')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func(): void',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func()',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func(): number',\n        'return',\n        'enddef',\n        'defcompile'], 'E1003:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func():number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1069:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func() :number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func() : number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  CheckScriptFailure(['def Func(): list', 'return []', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  CheckScriptFailure(['def Func(): dict', 'return {}', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  CheckScriptFailure(['def Func()', 'return 1'], 'E1057:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'vim9script',\n        'def FuncB()',\n        '  return 123',\n        'enddef',\n        'def FuncA()',\n        '   FuncB()',\n        'enddef',\n        'defcompile'], 'E1096:')\nenddef\n\ndef Test_arg_type_wrong()\n  CheckScriptFailure(['def Func3(items: list)', 'echo \"a\"', 'enddef'], 'E1008: Missing <type>')\n  CheckScriptFailure(['def Func4(...)', 'echo \"a\"', 'enddef'], 'E1055: Missing name after ...')\n  CheckScriptFailure(['def Func5(items:string)', 'echo \"a\"'], 'E1069:')\n  CheckScriptFailure(['def Func5(items)', 'echo \"a\"'], 'E1077:')\n  CheckScriptFailure(['def Func6(...x:list<number>)', 'echo \"a\"', 'enddef'], 'E1069:')\n  CheckScriptFailure(['def Func7(...x: int)', 'echo \"a\"', 'enddef'], 'E1010:')\nenddef\n\ndef Test_white_space_before_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number , b: number)\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:')\n  call assert_fails('vim9cmd echo stridx(\"a\" .. \"b\" , \"a\")', 'E1068:')\nenddef\n\ndef Test_white_space_after_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number,b: number)\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1069:')\n\n  # OK in legacy function\n  lines =<< trim END\n    vim9script\n    func Func(a,b)\n    endfunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_vim9script_call()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       name = arg\n    enddef\n    MyFunc('foobar')\n    name->assert_equal('foobar')\n\n    var str = 'barfoo'\n    str->MyFunc()\n    name->assert_equal('barfoo')\n\n    g:value = 'value'\n    g:value->MyFunc()\n    name->assert_equal('value')\n\n    var listvar = []\n    def ListFunc(arg: list<number>)\n       listvar = arg\n    enddef\n    [1, 2, 3]->ListFunc()\n    listvar->assert_equal([1, 2, 3])\n\n    var dictvar = {}\n    def DictFunc(arg: dict<number>)\n       dictvar = arg\n    enddef\n    {a: 1, b: 2}->DictFunc()\n    dictvar->assert_equal({a: 1, b: 2})\n    def CompiledDict()\n      {a: 3, b: 4}->DictFunc()\n    enddef\n    CompiledDict()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    {a: 3, b: 4}->DictFunc()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    ('text')->MyFunc()\n    name->assert_equal('text')\n    (\"some\")->MyFunc()\n    name->assert_equal('some')\n\n    # line starting with single quote is not a mark\n    # line starting with double quote can be a method call\n    'asdfasdf'->MyFunc()\n    name->assert_equal('asdfasdf')\n    \"xyz\"->MyFunc()\n    name->assert_equal('xyz')\n\n    def UseString()\n      'xyork'->MyFunc()\n    enddef\n    UseString()\n    name->assert_equal('xyork')\n\n    def UseString2()\n      \"knife\"->MyFunc()\n    enddef\n    UseString2()\n    name->assert_equal('knife')\n\n    # prepending a colon makes it a mark\n    new\n    setline(1, ['aaa', 'bbb', 'ccc'])\n    normal! 3Gmt1G\n    :'t\n    getcurpos()[1]->assert_equal(3)\n    bwipe!\n\n    MyFunc(\n        'continued'\n        )\n    assert_equal('continued',\n            name\n            )\n\n    call MyFunc(\n        'more'\n          ..\n          'lines'\n        )\n    assert_equal(\n        'morelines',\n        name)\n  END\n  writefile(lines, 'Xcall.vim')\n  source Xcall.vim\n  delete('Xcall.vim')\nenddef\n\ndef Test_vim9script_call_fail_decl()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       var name = 123\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E1054:')\nenddef\n\ndef Test_vim9script_call_fail_type()\n  var lines =<< trim END\n    vim9script\n    def MyFunc(arg: string)\n      echo arg\n    enddef\n    MyFunc(1234)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\nenddef\n\ndef Test_vim9script_call_fail_const()\n  var lines =<< trim END\n    vim9script\n    const var = ''\n    def MyFunc(arg: string)\n       var = 'asdf'\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xcall_const.vim')\n  assert_fails('source Xcall_const.vim', 'E46:', '', 1, 'MyFunc')\n  delete('Xcall_const.vim')\n\n  lines =<< trim END\n      const g:Aconst = 77\n      def Change()\n        # comment\n        g:Aconst = 99\n      enddef\n      call Change()\n      unlet g:Aconst\n  END\n  CheckScriptFailure(lines, 'E741: Value is locked: Aconst', 2)\nenddef\n\n\" Test that inside :function a Python function can be defined, :def is not\n\" recognized.\nfunc Test_function_python()\n  CheckFeature python3\n  let py = 'python3'\n  execute py \"<< EOF\"\ndef do_something():\n  return 1\nEOF\nendfunc\n\ndef Test_delfunc()\n  var lines =<< trim END\n    vim9script\n    def g:GoneSoon()\n      echo 'hello'\n    enddef\n\n    def CallGoneSoon()\n      GoneSoon()\n    enddef\n    defcompile\n\n    delfunc g:GoneSoon\n    CallGoneSoon()\n  END\n  writefile(lines, 'XToDelFunc')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n\n  delete('XToDelFunc')\nenddef\n\nfunc Test_free_dict_while_in_funcstack()\n  \" relies on the sleep command\n  CheckUnix\n  call Run_Test_free_dict_while_in_funcstack()\nendfunc\n\ndef Run_Test_free_dict_while_in_funcstack()\n\n  # this was freeing the TermRun() default argument dictionary while it was\n  # still referenced in a funcstack_T\n  var lines =<< trim END\n      vim9script\n\n      &updatetime = 400\n      def TermRun(_ = {})\n          def Post()\n          enddef\n          def Exec()\n              term_start('sleep 1', {\n                  term_finish: 'close',\n                  exit_cb: (_, _) => Post(),\n              })\n          enddef\n          Exec()\n      enddef\n      nnoremap <F4> <Cmd>call <SID>TermRun()<CR>\n      timer_start(100, (_) => feedkeys(\"\\<F4>\"))\n      timer_start(1000, (_) => feedkeys(\"\\<F4>\"))\n      sleep 1500m\n  END\n  CheckScriptSuccess(lines)\n  nunmap <F4>\n  set updatetime&\nenddef\n\ndef Test_redef_failure()\n  writefile(['def Func0(): string',  'return \"Func0\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def Func1(): string',  'return \"Func1\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def! Func0(): string', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1027:', '', 1, 'Func0')\n  writefile(['def Func2(): string',  'return \"Func2\"', 'enddef'], 'Xdef')\n  so Xdef\n  delete('Xdef')\n\n  assert_fails('g:Func0()', 'E1091:')\n  g:Func1()->assert_equal('Func1')\n  g:Func2()->assert_equal('Func2')\n\n  delfunc! Func0\n  delfunc! Func1\n  delfunc! Func2\nenddef\n\ndef Test_vim9script_func()\n  var lines =<< trim END\n    vim9script\n    func Func(arg)\n      echo a:arg\n    endfunc\n    Func('text')\n  END\n  writefile(lines, 'XVim9Func')\n  so XVim9Func\n\n  delete('XVim9Func')\nenddef\n\nlet s:funcResult = 0\n\ndef FuncNoArgNoRet()\n  s:funcResult = 11\nenddef\n\ndef FuncNoArgRetNumber(): number\n  s:funcResult = 22\n  return 1234\nenddef\n\ndef FuncNoArgRetString(): string\n  s:funcResult = 45\n  return 'text'\nenddef\n\ndef FuncOneArgNoRet(arg: number)\n  s:funcResult = arg\nenddef\n\ndef FuncOneArgRetNumber(arg: number): number\n  s:funcResult = arg\n  return arg\nenddef\n\ndef FuncTwoArgNoRet(one: bool, two: number)\n  s:funcResult = two\nenddef\n\ndef FuncOneArgRetString(arg: string): string\n  return arg\nenddef\n\ndef FuncOneArgRetAny(arg: any): any\n  return arg\nenddef\n\ndef Test_func_type()\n  var Ref1: func()\n  s:funcResult = 0\n  Ref1 = FuncNoArgNoRet\n  Ref1()\n  s:funcResult->assert_equal(11)\n\n  var Ref2: func\n  s:funcResult = 0\n  Ref2 = FuncNoArgNoRet\n  Ref2()\n  s:funcResult->assert_equal(11)\n\n  s:funcResult = 0\n  Ref2 = FuncOneArgNoRet\n  Ref2(12)\n  s:funcResult->assert_equal(12)\n\n  s:funcResult = 0\n  Ref2 = FuncNoArgRetNumber\n  Ref2()->assert_equal(1234)\n  s:funcResult->assert_equal(22)\n\n  s:funcResult = 0\n  Ref2 = FuncOneArgRetNumber\n  Ref2(13)->assert_equal(13)\n  s:funcResult->assert_equal(13)\nenddef\n\ndef Test_repeat_return_type()\n  var res = 0\n  for n in repeat([1], 3)\n    res += n\n  endfor\n  res->assert_equal(3)\n\n  res = 0\n  for n in add([1, 2], 3)\n    res += n\n  endfor\n  res->assert_equal(6)\nenddef\n\ndef Test_argv_return_type()\n  next fileone filetwo\n  var res = ''\n  for name in argv()\n    res ..= name\n  endfor\n  res->assert_equal('fileonefiletwo')\nenddef\n\ndef Test_func_type_part()\n  var RefVoid: func: void\n  RefVoid = FuncNoArgNoRet\n  RefVoid = FuncOneArgNoRet\n  CheckDefFailure(['var RefVoid: func: void', 'RefVoid = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...) but got func(): number')\n  CheckDefFailure(['var RefVoid: func: void', 'RefVoid = FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...) but got func(): string')\n\n  var RefAny: func(): any\n  RefAny = FuncNoArgRetNumber\n  RefAny = FuncNoArgRetString\n  CheckDefFailure(['var RefAny: func(): any', 'RefAny = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func()')\n  CheckDefFailure(['var RefAny: func(): any', 'RefAny = FuncOneArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func(number)')\n\n  var RefAnyNoArgs: func: any = RefAny\n\n  var RefNr: func: number\n  RefNr = FuncNoArgRetNumber\n  RefNr = FuncOneArgRetNumber\n  CheckDefFailure(['var RefNr: func: number', 'RefNr = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): number but got func()')\n  CheckDefFailure(['var RefNr: func: number', 'RefNr = FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...): number but got func(): string')\n\n  var RefStr: func: string\n  RefStr = FuncNoArgRetString\n  RefStr = FuncOneArgRetString\n  CheckDefFailure(['var RefStr: func: string', 'RefStr = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): string but got func()')\n  CheckDefFailure(['var RefStr: func: string', 'RefStr = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...): string but got func(): number')\nenddef\n\ndef Test_func_type_fails()\n  CheckDefFailure(['var ref1: func()'], 'E704:')\n\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(): number')\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncOneArgNoRet'], 'E1012: Type mismatch; expected func() but got func(number)')\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncOneArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(number): number')\n  CheckDefFailure(['var Ref1: func(bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(bool) but got func(bool, number)')\n  CheckDefFailure(['var Ref1: func(?bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(?bool) but got func(bool, number)')\n  CheckDefFailure(['var Ref1: func(...bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(...bool) but got func(bool, number)')\n\n  CheckDefFailure(['var RefWrong: func(string ,number)'], 'E1068:')\n  CheckDefFailure(['var RefWrong: func(string,number)'], 'E1069:')\n  CheckDefFailure(['var RefWrong: func(bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool)'], 'E1005:')\n  CheckDefFailure(['var RefWrong: func(bool):string'], 'E1069:')\nenddef\n\ndef Test_func_return_type()\n  var nr: number\n  nr = FuncNoArgRetNumber()\n  nr->assert_equal(1234)\n\n  nr = FuncOneArgRetAny(122)\n  nr->assert_equal(122)\n\n  var str: string\n  str = FuncOneArgRetAny('yes')\n  str->assert_equal('yes')\n\n  CheckDefFailure(['var str: string', 'str = FuncNoArgRetNumber()'], 'E1012: Type mismatch; expected string but got number')\nenddef\n\ndef Test_func_common_type()\n  def FuncOne(n: number): number\n    return n\n  enddef\n  def FuncTwo(s: string): number\n    return len(s)\n  enddef\n  def FuncThree(n: number, s: string): number\n    return n + len(s)\n  enddef\n  var list = [FuncOne, FuncTwo, FuncThree]\n  assert_equal(8, list[0](8))\n  assert_equal(4, list[1]('word'))\n  assert_equal(7, list[2](3, 'word'))\nenddef\n\ndef MultiLine(\n    arg1: string,\n    arg2 = 1234,\n    ...rest: list<string>\n      ): string\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef MultiLineComment(\n    arg1: string, # comment\n    arg2 = 1234, # comment\n    ...rest: list<string> # comment\n      ): string # comment\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef Test_multiline()\n  MultiLine('text')->assert_equal('text1234')\n  MultiLine('text', 777)->assert_equal('text777')\n  MultiLine('text', 777, 'one')->assert_equal('text777one')\n  MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nenddef\n\nfunc Test_multiline_not_vim9()\n  call MultiLine('text')->assert_equal('text1234')\n  call MultiLine('text', 777)->assert_equal('text777')\n  call MultiLine('text', 777, 'one')->assert_equal('text777one')\n  call MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nendfunc\n\n\n\" When using CheckScriptFailure() for the below test, E1010 is generated instead\n\" of E1056.\nfunc Test_E1056_1059()\n  let caught_1056 = 0\n  try\n    def F():\n      return 1\n    enddef\n  catch /E1056:/\n    let caught_1056 = 1\n  endtry\n  eval caught_1056->assert_equal(1)\n\n  let caught_1059 = 0\n  try\n    def F5(items : list)\n      echo 'a'\n    enddef\n  catch /E1059:/\n    let caught_1059 = 1\n  endtry\n  eval caught_1059->assert_equal(1)\nendfunc\n\nfunc DelMe()\n  echo 'DelMe'\nendfunc\n\ndef Test_error_reporting()\n  # comment lines at the start of the function\n  var lines =<< trim END\n    \" comment\n    def Func()\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 3$')\n  endtry\n  delfunc! g:Func\n\n  # comment lines after the start of the function\n  lines =<< trim END\n    \" comment\n    def Func()\n      var x = 1234\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 4$')\n  endtry\n  delfunc! g:Func\n\n  lines =<< trim END\n    vim9script\n    def Func()\n      var db = {foo: 1, bar: 2}\n      # comment\n      var x = db.asdf\n    enddef\n    defcompile\n    Func()\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E716:/\n    v:throwpoint->assert_match('_Func, line 3$')\n  endtry\n  delfunc! g:Func\n\n  delete('Xdef')\nenddef\n\ndef Test_deleted_function()\n  CheckDefExecFailure([\n      'var RefMe: func = function(\"g:DelMe\")',\n      'delfunc g:DelMe',\n      'echo RefMe()'], 'E117:')\nenddef\n\ndef Test_unknown_function()\n  CheckDefExecFailure([\n      'var Ref: func = function(\"NotExist\")',\n      'delfunc g:NotExist'], 'E700:')\nenddef\n\ndef RefFunc(Ref: func(any): any): string\n  return Ref('more')\nenddef\n\ndef Test_closure_simple()\n  var local = 'some '\n  RefFunc((s) => local .. s)->assert_equal('some more')\nenddef\n\ndef MakeRef()\n  var local = 'some '\n  g:Ref = (s) => local .. s\nenddef\n\ndef Test_closure_ref_after_return()\n  MakeRef()\n  g:Ref('thing')->assert_equal('some thing')\n  unlet g:Ref\nenddef\n\ndef MakeTwoRefs()\n  var local = ['some']\n  g:Extend = (s) => local->add(s)\n  g:Read = () => local\nenddef\n\ndef Test_closure_two_refs()\n  MakeTwoRefs()\n  join(g:Read(), ' ')->assert_equal('some')\n  g:Extend('more')\n  join(g:Read(), ' ')->assert_equal('some more')\n  g:Extend('even')\n  join(g:Read(), ' ')->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef ReadRef(Ref: func(): list<string>): string\n  return join(Ref(), ' ')\nenddef\n\ndef ExtendRef(Ref: func(string): list<string>, add: string)\n  Ref(add)\nenddef\n\ndef Test_closure_two_indirect_refs()\n  MakeTwoRefs()\n  ReadRef(g:Read)->assert_equal('some')\n  ExtendRef(g:Extend, 'more')\n  ReadRef(g:Read)->assert_equal('some more')\n  ExtendRef(g:Extend, 'even')\n  ReadRef(g:Read)->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef MakeArgRefs(theArg: string)\n  var local = 'loc_val'\n  g:UseArg = (s) => theArg .. '/' .. local .. '/' .. s\nenddef\n\ndef MakeArgRefsVarargs(theArg: string, ...rest: list<string>)\n  var local = 'the_loc'\n  g:UseVararg = (s) => theArg .. '/' .. local .. '/' .. s .. '/' .. join(rest)\nenddef\n\ndef Test_closure_using_argument()\n  MakeArgRefs('arg_val')\n  g:UseArg('call_val')->assert_equal('arg_val/loc_val/call_val')\n\n  MakeArgRefsVarargs('arg_val', 'one', 'two')\n  g:UseVararg('call_val')->assert_equal('arg_val/the_loc/call_val/one two')\n\n  unlet g:UseArg\n  unlet g:UseVararg\n\n  var lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n        return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      def Inc(nr: number): number\n        return nr + 2\n      enddef\n      assert_equal([3, 4, 5], Test(Inc))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef MakeGetAndAppendRefs()\n  var local = 'a'\n\n  def Append(arg: string)\n    local ..= arg\n  enddef\n  g:Append = Append\n\n  def Get(): string\n    return local\n  enddef\n  g:Get = Get\nenddef\n\ndef Test_closure_append_get()\n  MakeGetAndAppendRefs()\n  g:Get()->assert_equal('a')\n  g:Append('-b')\n  g:Get()->assert_equal('a-b')\n  g:Append('-c')\n  g:Get()->assert_equal('a-b-c')\n\n  unlet g:Append\n  unlet g:Get\nenddef\n\ndef Test_nested_closure()\n  var local = 'text'\n  def Closure(arg: string): string\n    return local .. arg\n  enddef\n  Closure('!!!')->assert_equal('text!!!')\nenddef\n\nfunc GetResult(Ref)\n  return a:Ref('some')\nendfunc\n\ndef Test_call_closure_not_compiled()\n  var text = 'text'\n  g:Ref = (s) =>  s .. text\n  GetResult(g:Ref)->assert_equal('sometext')\nenddef\n\ndef Test_double_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var name = 0\n      for i in range(2)\n          timer_start(0, () => name)\n      endfor\n    enddef\n    Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_used()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = 'hello'\n        var Closure = () => x\n        g:Myclosure = () => Closure()\n      enddef\n      Func()\n      assert_equal('hello', g:Myclosure())\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def FuncA()\n      FuncB(0)\n    enddef\n    def FuncB(n: number): list<string>\n      return map([0], (_, v) => n)\n    enddef\n    FuncA()\n  END\n  CheckScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_global_closure()\n  var lines =<< trim END\n      vim9script\n      def ReverseEveryNLines(n: number, line1: number, line2: number)\n        var mods = 'sil keepj keepp lockm '\n        var range = ':' .. line1 .. ',' .. line2\n        def g:Offset(): number\n            var offset = (line('.') - line1 + 1) % n\n            return offset != 0 ? offset : n\n        enddef\n        exe mods .. range .. 'g/^/exe \"m .-\" .. g:Offset()'\n      enddef\n\n      new\n      repeat(['aaa', 'bbb', 'ccc'], 3)->setline(1)\n      ReverseEveryNLines(3, 1, 9)\n  END\n  CheckScriptSuccess(lines)\n  var expected = repeat(['ccc', 'bbb', 'aaa'], 3)\n  assert_equal(expected, getline(1, 9))\n  bwipe!\nenddef\n\ndef Test_global_closure_called_directly()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n        var x = 1\n        def g:Inner()\n          var y = x\n          x += 1\n          assert_equal(1, y)\n        enddef\n        g:Inner()\n        assert_equal(2, x)\n      enddef\n      Outer()\n  END\n  CheckScriptSuccess(lines)\n  delfunc g:Inner\nenddef\n\ndef Test_closure_called_from_legacy()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var outer = 'foo'\n        var F = () => {\n              outer = 'bar'\n            }\n        execute printf('call %s()', string(F))\n      enddef\n      Func()\n  END\n  CheckScriptFailure(lines, 'E1248')\nenddef\n\ndef Test_failure_in_called_function()\n  # this was using the frame index as the return value\n  var lines =<< trim END\n      vim9script\n      au TerminalWinOpen * eval [][0]\n      def PopupTerm(a: any)\n        # make sure typvals on stack are string\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']->join()\n        FireEvent()\n      enddef\n      def FireEvent()\n          do TerminalWinOpen\n      enddef\n      # use try/catch to make eval fail\n      try\n          call PopupTerm(0)\n      catch\n      endtry\n      au! TerminalWinOpen\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_lambda()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var x = 4\n      var Lambda1 = () => 7\n      var Lambda2 = () => [Lambda1(), x]\n      var res = Lambda2()\n      assert_equal([7, 4], res)\n    enddef\n    Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_double_nested_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(head: string): func(string): func(string): string\n        return (sep: string): func(string): string => ((tail: string): string => {\n            return head .. sep .. tail\n          })\n      enddef\n      assert_equal('hello-there', F('hello')('-')('there'))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_inline_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(text: string): func(string): func(string): string\n        return (arg: string): func(string): string => ((sep: string): string => {\n            return sep .. arg .. text\n          })\n      enddef\n      assert_equal('--there++', F('++')('there')('--'))\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      echo range(4)->mapnew((_, v) => {\n        return range(v) ->mapnew((_, s) => {\n          return string(s)\n          })\n        })\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      def s:func()\n        range(10)\n          ->mapnew((_, _) => ({\n            key: range(10)->mapnew((_, _) => {\n              return ' '\n            }),\n          }))\n      enddef\n\n      defcomp\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Shadowed(): list<number>\n  var FuncList: list<func: number> = [() => 42]\n  return FuncList->mapnew((_, Shadowed) => Shadowed())\nenddef\n\ndef Test_lambda_arg_shadows_func()\n  assert_equal([42], Shadowed())\nenddef\n\ndef Line_continuation_in_def(dir: string = ''): string\n  var path: string = empty(dir)\n          \\ ? 'empty'\n          \\ : 'full'\n  return path\nenddef\n\ndef Test_line_continuation_in_def()\n  Line_continuation_in_def('.')->assert_equal('full')\nenddef\n\ndef Test_script_var_in_lambda()\n  var lines =<< trim END\n      vim9script\n      var script = 'test'\n      assert_equal(['test'], map(['one'], (_, _) => script))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Line_continuation_in_lambda(): list<string>\n  var x = range(97, 100)\n      ->mapnew((_, v) => nr2char(v)\n          ->toupper())\n      ->reverse()\n  return x\nenddef\n\ndef Test_line_continuation_in_lambda()\n  Line_continuation_in_lambda()->assert_equal(['D', 'C', 'B', 'A'])\n\n  var lines =<< trim END\n      vim9script\n      var res = [{n: 1, m: 2, s: 'xxx'}]\n                ->mapnew((_, v: dict<any>): string => printf('%d:%d:%s',\n                    v.n,\n                    v.m,\n                    substitute(v.s, '.*', 'yyy', '')\n                    ))\n      assert_equal(['1:2:yyy'], res)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_lambda()\n  timer_start(1000, (_) => 0)\n  var body = execute(timer_info()[0].callback\n         ->string()\n         ->substitute(\"('\", ' ', '')\n         ->substitute(\"')\", '', '')\n         ->substitute('function\\zs', ' ', ''))\n  assert_match('def <lambda>\\d\\+(_: any): number\\n1  return 0\\n   enddef', body)\nenddef\n\ndef Test_lambda_block_variable()\n  var lines =<< trim END\n      vim9script\n      var flist: list<func>\n      for i in range(10)\n          var inloop = i\n          flist[i] = () => inloop\n      endfor\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n        var flist: list<func>\n        for i in range(10)\n          flist[i] = () => outloop\n        endfor\n      endif\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n      endif\n      var flist: list<func>\n      for i in range(10)\n        flist[i] = () => outloop\n      endfor\n  END\n  CheckScriptFailure(lines, 'E1001: Variable not found: outloop', 1)\n\n  lines =<< trim END\n      vim9script\n      for i in range(10)\n        var Ref = () => 0\n      endfor\n      assert_equal(0, ((i) => 0)(0))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_lambda()\n  legacy echo {x -> 'hello ' .. x}('foo')\n\n  var lines =<< trim END\n      echo {x -> 'hello ' .. x}('foo')\n  END\n  CheckDefAndScriptFailure(lines, 'E720:')\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo (() => 'no error')()\n      enddef\n      legacy call s:Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy()\n  var lines =<< trim END\n      vim9script\n      func g:LegacyFunction()\n        let g:legacyvar = 1\n      endfunc\n      def Testit()\n        legacy call g:LegacyFunction()\n      enddef\n      Testit()\n      assert_equal(1, g:legacyvar)\n      unlet g:legacyvar\n      delfunc g:LegacyFunction\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_errors()\n  for cmd in ['if', 'elseif', 'else', 'endif',\n              'for', 'endfor', 'continue', 'break',\n              'while', 'endwhile',\n              'try', 'catch', 'finally', 'endtry']\n    CheckDefFailure(['legacy ' .. cmd .. ' expr'], 'E1189:')\n  endfor\nenddef\n\ndef Test_call_legacy_with_dict()\n  var lines =<< trim END\n      vim9script\n      func Legacy() dict\n        let g:result = self.value\n      endfunc\n      def TestDirect()\n        var d = {value: 'yes', func: Legacy}\n        d.func()\n      enddef\n      TestDirect()\n      assert_equal('yes', g:result)\n      unlet g:result\n\n      def TestIndirect()\n        var d = {value: 'foo', func: Legacy}\n        var Fi = d.func\n        Fi()\n      enddef\n      TestIndirect()\n      assert_equal('foo', g:result)\n      unlet g:result\n\n      var d = {value: 'bar', func: Legacy}\n      d.func()\n      assert_equal('bar', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef DoFilterThis(a: string): list<string>\n  # closure nested inside another closure using argument\n  var Filter = (l) => filter(l, (_, v) => stridx(v, a) == 0)\n  return ['x', 'y', 'a', 'x2', 'c']->Filter()\nenddef\n\ndef Test_nested_closure_using_argument()\n  assert_equal(['x', 'x2'], DoFilterThis('x'))\nenddef\n\ndef Test_triple_nested_closure()\n  var what = 'x'\n  var Match = (val: string, cmp: string): bool => stridx(val, cmp) == 0\n  var Filter = (l) => filter(l, (_, v) => Match(v, what))\n  assert_equal(['x', 'x2'], ['x', 'y', 'a', 'x2', 'c']->Filter())\nenddef\n\nfunc Test_silent_echo()\n  CheckScreendump\n  call Run_Test_silent_echo()\nendfunc\n\ndef Run_Test_silent_echo()\n  var lines =<< trim END\n    vim9script\n    def EchoNothing()\n      silent echo ''\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_silent_echo')\n\n  # Check that the balloon shows up after a mouse move\n  var buf = RunVimInTerminal('-S XTest_silent_echo', {'rows': 6})\n  term_sendkeys(buf, \":abc\")\n  VerifyScreenDump(buf, 'Test_vim9_silent_echo', {})\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_silent_echo')\nenddef\n\ndef SilentlyError()\n  execute('silent! invalid')\n  g:did_it = 'yes'\nenddef\n\nfunc UserError()\n  silent! invalid\nendfunc\n\ndef SilentlyUserError()\n  UserError()\n  g:did_it = 'yes'\nenddef\n\n\" This can't be a :def function, because the assert would not be reached.\nfunc Test_ignore_silent_error()\n  let g:did_it = 'no'\n  call SilentlyError()\n  call assert_equal('yes', g:did_it)\n\n  let g:did_it = 'no'\n  call SilentlyUserError()\n  call assert_equal('yes', g:did_it)\n\n  unlet g:did_it\nendfunc\n\ndef Test_ignore_silent_error_in_filter()\n  var lines =<< trim END\n      vim9script\n      def Filter(winid: number, key: string): bool\n          if key == 'o'\n              silent! eval [][0]\n              return true\n          endif\n          return popup_filter_menu(winid, key)\n      enddef\n\n      popup_create('popup', {filter: Filter})\n      feedkeys(\"o\\r\", 'xnt')\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Fibonacci(n: number): number\n  if n < 2\n    return n\n  else\n    return Fibonacci(n - 1) + Fibonacci(n - 2)\n  endif\nenddef\n\ndef Test_recursive_call()\n  Fibonacci(20)->assert_equal(6765)\nenddef\n\ndef TreeWalk(dir: string): list<any>\n  return readdir(dir)->mapnew((_, val) =>\n            fnamemodify(dir .. '/' .. val, ':p')->isdirectory()\n               ? {[val]: TreeWalk(dir .. '/' .. val)}\n               : val\n             )\nenddef\n\ndef Test_closure_in_map()\n  mkdir('XclosureDir/tdir', 'p')\n  writefile(['111'], 'XclosureDir/file1')\n  writefile(['222'], 'XclosureDir/file2')\n  writefile(['333'], 'XclosureDir/tdir/file3')\n\n  TreeWalk('XclosureDir')->assert_equal(['file1', 'file2', {tdir: ['file3']}])\n\n  delete('XclosureDir', 'rf')\nenddef\n\ndef Test_invalid_function_name()\n  var lines =<< trim END\n      vim9script\n      def s: list<string>\n  END\n  CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def g: list<string>\n  END\n  CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def <SID>: list<string>\n  END\n  CheckScriptFailure(lines, 'E884:')\n\n  lines =<< trim END\n      vim9script\n      def F list<string>\n  END\n  CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_partial_call()\n  var lines =<< trim END\n      var Xsetlist: func\n      Xsetlist = function('setloclist', [0])\n      Xsetlist([], ' ', {title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setloclist', [0, [], ' '])\n      Xsetlist({title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist')\n      Xsetlist([], ' ', {title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist', [[], ' '])\n      Xsetlist({title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      var Len: func: number = function('len', ['word'])\n      assert_equal(4, Len())\n\n      var RepeatFunc = function('repeat', ['o'])\n      assert_equal('ooooo', RepeatFunc(5))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(Parser: any)\n      enddef\n      var Expr: func(dict<any>): dict<any>\n      const Call = Foo(Expr)\n  END\n  CheckScriptFailure(lines, 'E1235:')\nenddef\n\ndef Test_cmd_modifier()\n  tab echo '0'\n  CheckDefFailure(['5tab echo 3'], 'E16:')\nenddef\n\ndef Test_restore_modifiers()\n  # check that when compiling a :def function command modifiers are not messed\n  # up.\n  var lines =<< trim END\n      vim9script\n      set eventignore=\n      autocmd QuickFixCmdPost * copen\n      def AutocmdsDisabled()\n        eval 1 + 2\n      enddef\n      func Func()\n        noautocmd call s:AutocmdsDisabled()\n        let g:ei_after = &eventignore\n      endfunc\n      Func()\n  END\n  CheckScriptSuccess(lines)\n  g:ei_after->assert_equal('')\nenddef\n\ndef StackTop()\n  eval 1 + 2\n  eval 2 + 3\n  # call not on fourth line\n  StackBot()\nenddef\n\ndef StackBot()\n  # throw an error\n  eval [][0]\nenddef\n\ndef Test_callstack_def()\n  try\n    StackTop()\n  catch\n    v:throwpoint->assert_match('Test_callstack_def\\[2\\]..StackTop\\[4\\]..StackBot, line 2')\n  endtry\nenddef\n\n\" Re-using spot for variable used in block\ndef Test_block_scoped_var()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = ['a', 'b', 'c']\n        if 1\n          var y = 'x'\n          map(x, (_, _) => y)\n        endif\n        var z = x\n        assert_equal(['x', 'x', 'x'], z)\n      enddef\n      Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_reset_did_emsg()\n  var lines =<< trim END\n      @s = 'blah'\n      au BufWinLeave * #\n      def Func()\n        var winid = popup_create('popup', {})\n        exe '*s'\n        popup_close(winid)\n      enddef\n      Func()\n  END\n  CheckScriptFailure(lines, 'E492:', 8)\n  delfunc! g:Func\nenddef\n\ndef Test_did_emsg_reset()\n  # executing an autocommand resets did_emsg, this should not result in a\n  # builtin function considered failing\n  var lines =<< trim END\n      vim9script\n      au BufWinLeave * #\n      def Func()\n          popup_menu('', {callback: (a, b) => popup_create('', {})->popup_close()})\n          eval [][0]\n      enddef\n      nno <F3> <cmd>call <sid>Func()<cr>\n      feedkeys(\"\\<F3>\\e\", 'xt')\n  END\n  writefile(lines, 'XemsgReset')\n  assert_fails('so XemsgReset', ['E684:', 'E684:'], lines, 2)\n  delete('XemsgReset')\n  nunmap <F3>\n  au! BufWinLeave\nenddef\n\ndef Test_abort_with_silent_call()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, but function aborts on error\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_continues_with_silent_error()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        silent!  g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, function does not abort\n      Func()\n      assert_equal('yes', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_abort_even_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        eval {-> ''}() .. '' .. {}['X']\n        g:result = 'yes'\n      enddef\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_cmdmod_silent_restored()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        g:result = 'none'\n        silent! g:result += 3\n        g:result = 'none'\n        g:result += 3\n      enddef\n      Func()\n  END\n  # can't use CheckScriptFailure, it ignores the :silent!\n  var fname = 'Xdefsilent'\n  writefile(lines, fname)\n  var caught = 'no'\n  try\n    exe 'source ' .. fname\n  catch /E1030:/\n    caught = 'yes'\n    assert_match('Func, line 4', v:throwpoint)\n  endtry\n  assert_equal('yes', caught)\n  delete(fname)\nenddef\n\ndef Test_cmdmod_silent_nested()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n\n      def Error()\n          result ..= 'Eb'\n          eval [][0]\n          result ..= 'Ea'\n      enddef\n\n      def Crash()\n          result ..= 'Cb'\n          sil! Error()\n          result ..= 'Ca'\n      enddef\n\n      Crash()\n      assert_equal('CbEbEaCa', result)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_dict_member_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      var d: dict<any>\n      def Func()\n        try\n          g:result = map([], (_, v) => ({}[v]))->join() .. d['']\n        catch\n        endtry\n      enddef\n      silent! Func()\n      assert_equal('0', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_skip_cmds_with_silent()\n  var lines =<< trim END\n      vim9script\n\n      def Func(b: bool)\n        Crash()\n      enddef\n\n      def Crash()\n        sil! :/not found/d _\n        sil! :/not found/put _\n      enddef\n\n      Func(true)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_opfunc()\n  nnoremap <F3> <cmd>set opfunc=Opfunc<cr>g@\n  def g:Opfunc(_: any): string\n    setline(1, 'ASDF')\n    return ''\n  enddef\n  new\n  setline(1, 'asdf')\n  feedkeys(\"\\<F3>$\", 'x')\n  assert_equal('ASDF', getline(1))\n\n  bwipe!\n  nunmap <F3>\nenddef\n\nfunc Test_opfunc_error()\n  CheckScreendump\n  call Run_Test_opfunc_error()\nendfunc\n\ndef Run_Test_opfunc_error()\n  # test that the error from Opfunc() is displayed right away\n  var lines =<< trim END\n      vim9script\n\n      def Opfunc(type: string)\n        try\n          eval [][0]\n        catch /nothing/  # error not caught\n        endtry\n      enddef\n      &operatorfunc = Opfunc\n      nnoremap <expr> l <SID>L()\n      def L(): string\n        return 'l'\n      enddef\n      'x'->repeat(10)->setline(1)\n      feedkeys('g@l', 'n')\n      feedkeys('llll')\n  END\n  call writefile(lines, 'XTest_opfunc_error')\n\n  var buf = RunVimInTerminal('-S XTest_opfunc_error', {rows: 6, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Press ENTER', term_getline(buf, 6)))\n  WaitForAssert(() => assert_match('E684: list index out of range: 0', term_getline(buf, 5)))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_opfunc_error')\nenddef\n\n\" this was crashing on exit\ndef Test_nested_lambda_in_closure()\n  var lines =<< trim END\n      vim9script\n      command WriteDone writefile(['Done'], 'XnestedDone')\n      def Outer()\n          def g:Inner()\n              echo map([1, 2, 3], {_, v -> v + 1})\n          enddef\n          g:Inner()\n      enddef\n      defcompile\n      # not reached\n  END\n  if !RunVim([], lines, '--clean -c WriteDone -c quit')\n    return\n  endif\n  assert_equal(['Done'], readfile('XnestedDone'))\n  delete('XnestedDone')\nenddef\n\ndef Test_check_func_arg_types()\n  var lines =<< trim END\n      vim9script\n      def F1(x: string): string\n        return x\n      enddef\n\n      def F2(x: number): number\n        return x + 1\n      enddef\n\n      def G(g: func): dict<func>\n        return {f: g}\n      enddef\n\n      def H(d: dict<func>): string\n        return d.f('a')\n      enddef\n  END\n\n  CheckScriptSuccess(lines + ['echo H(G(F1))'])\n  CheckScriptFailure(lines + ['echo H(G(F2))'], 'E1013:')\nenddef\n\ndef Test_list_any_type_checked()\n  var lines =<< trim END\n      vim9script\n      def Foo()\n        --decl--\n        Bar(l)\n      enddef\n      def Bar(ll: list<dict<any>>)\n      enddef\n      Foo()\n  END\n  lines[2] = 'var l: list<any>'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<any>', 2)\n\n  lines[2] = 'var l: list<any> = []'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<any>', 2)\n\n  lines[2] = 'var l: list<any> = [11]'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<number>', 2)\nenddef\n\ndef Test_compile_error()\n  var lines =<< trim END\n    def g:Broken()\n      echo 'a' + {}\n    enddef\n    call g:Broken()\n  END\n  # First call: compilation error\n  CheckScriptFailure(lines, 'E1051: Wrong argument type for +')\n\n  # Second call won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\n\n  # No error when compiling with :silent!\n  lines =<< trim END\n    def g:Broken()\n      echo 'a' + []\n    enddef\n    silent! defcompile\n  END\n  CheckScriptSuccess(lines)\n\n  # Calling the function won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\nenddef\n\ndef Test_ignored_argument()\n  var lines =<< trim END\n      vim9script\n      def Ignore(_, _): string\n        return 'yes'\n      enddef\n      assert_equal('yes', Ignore(1, 2))\n\n      func Ok(_)\n        return a:_\n      endfunc\n      assert_equal('ok', Ok('ok'))\n\n      func Oktoo()\n        let _ = 'too'\n        return _\n      endfunc\n      assert_equal('too', Oktoo())\n\n      assert_equal([[1], [2], [3]], range(3)->mapnew((_, v) => [v]->map((_, w) => w + 1)))\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      def Ignore(_: string): string\n        return _\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var _ = 1\n  END\n  CheckDefAndScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var x = _\n  END\n  CheckDefAndScriptFailure(lines, 'E1181:', 1)\nenddef\n\ndef Test_too_many_arguments()\n  var lines =<< trim END\n    echo [0, 1, 2]->map(() => 123)\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1106: 2 arguments too many', 1)\n\n  lines =<< trim END\n    echo [0, 1, 2]->map((_) => 123)\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1106: One argument too many', 1)\nenddef\n\ndef Test_closing_brace_at_start_of_line()\n  var lines =<< trim END\n      def Func()\n      enddef\n      Func(\n      )\n  END\n  call CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc CreateMydict()\n  let g:mydict = {}\n  func g:mydict.afunc()\n    let g:result = self.key\n  endfunc\nendfunc\n\ndef Test_numbered_function_reference()\n  CreateMydict()\n  var output = execute('legacy func g:mydict.afunc')\n  var funcName = 'g:' .. substitute(output, '.*function \\(\\d\\+\\).*', '\\1', '')\n  execute 'function(' .. funcName .. ', [], {key: 42})()'\n  # check that the function still exists\n  assert_equal(output, execute('legacy func g:mydict.afunc'))\n  unlet g:mydict\nenddef\n\ndef Test_go_beyond_end_of_cmd()\n  # this was reading the byte after the end of the line\n  var lines =<< trim END\n    def F()\n      cal\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E476:')\nenddef\n\nif has('python3')\n  def Test_python3_heredoc()\n    py3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'yes'\n    EOF\n    assert_equal('yes', g:didit)\n\n    python3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'again'\n    EOF\n    assert_equal('again', g:didit)\n  enddef\nendif\n\n\" This messes up syntax highlight, keep near the end.\nif has('lua')\n  def Test_lua_heredoc()\n    g:d = {}\n    lua << trim EOF\n        x = vim.eval('g:d')\n        x['key'] = 'val'\n    EOF\n    assert_equal('val', g:d.key)\n  enddef\nendif\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * usercmd.c: User defined command support\n */\n\n#include \"vim.h\"\n\ntypedef struct ucmd\n{\n    char_u\t*uc_name;\t// The command name\n    long_u\tuc_argt;\t// The argument type\n    char_u\t*uc_rep;\t// The command's replacement string\n    long\tuc_def;\t\t// The default value for a range/count\n    int\t\tuc_compl;\t// completion type\n    cmd_addr_T\tuc_addr_type;\t// The command's address type\n    sctx_T\tuc_script_ctx;\t// SCTX where the command was defined\n# ifdef FEAT_EVAL\n    char_u\t*uc_compl_arg;\t// completion argument if any\n# endif\n} ucmd_T;\n\n// List of all user commands.\nstatic garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};\n\n#define USER_CMD(i) (&((ucmd_T *)(ucmds.ga_data))[i])\n#define USER_CMD_GA(gap, i) (&((ucmd_T *)((gap)->ga_data))[i])\n\n/*\n * List of names for completion for \":command\" with the EXPAND_ flag.\n * Must be alphabetical for completion.\n */\nstatic struct\n{\n    int\t    expand;\n    char    *name;\n} command_complete[] =\n{\n    {EXPAND_ARGLIST, \"arglist\"},\n    {EXPAND_AUGROUP, \"augroup\"},\n    {EXPAND_BEHAVE, \"behave\"},\n    {EXPAND_BUFFERS, \"buffer\"},\n    {EXPAND_COLORS, \"color\"},\n    {EXPAND_COMMANDS, \"command\"},\n    {EXPAND_COMPILER, \"compiler\"},\n#if defined(FEAT_CSCOPE)\n    {EXPAND_CSCOPE, \"cscope\"},\n#endif\n#if defined(FEAT_EVAL)\n    {EXPAND_USER_DEFINED, \"custom\"},\n    {EXPAND_USER_LIST, \"customlist\"},\n#endif\n    {EXPAND_DIFF_BUFFERS, \"diff_buffer\"},\n    {EXPAND_DIRECTORIES, \"dir\"},\n    {EXPAND_ENV_VARS, \"environment\"},\n    {EXPAND_EVENTS, \"event\"},\n    {EXPAND_EXPRESSION, \"expression\"},\n    {EXPAND_FILES, \"file\"},\n    {EXPAND_FILES_IN_PATH, \"file_in_path\"},\n    {EXPAND_FILETYPE, \"filetype\"},\n    {EXPAND_FUNCTIONS, \"function\"},\n    {EXPAND_HELP, \"help\"},\n    {EXPAND_HIGHLIGHT, \"highlight\"},\n    {EXPAND_HISTORY, \"history\"},\n#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n    {EXPAND_LOCALES, \"locale\"},\n#endif\n    {EXPAND_MAPCLEAR, \"mapclear\"},\n    {EXPAND_MAPPINGS, \"mapping\"},\n    {EXPAND_MENUS, \"menu\"},\n    {EXPAND_MESSAGES, \"messages\"},\n    {EXPAND_OWNSYNTAX, \"syntax\"},\n#if defined(FEAT_PROFILE)\n    {EXPAND_SYNTIME, \"syntime\"},\n#endif\n    {EXPAND_SETTINGS, \"option\"},\n    {EXPAND_PACKADD, \"packadd\"},\n    {EXPAND_SHELLCMD, \"shellcmd\"},\n#if defined(FEAT_SIGNS)\n    {EXPAND_SIGN, \"sign\"},\n#endif\n    {EXPAND_TAGS, \"tag\"},\n    {EXPAND_TAGS_LISTFILES, \"tag_listfiles\"},\n    {EXPAND_USER, \"user\"},\n    {EXPAND_USER_VARS, \"var\"},\n    {0, NULL}\n};\n\n/*\n * List of names of address types.  Must be alphabetical for completion.\n */\nstatic struct\n{\n    cmd_addr_T\texpand;\n    char\t*name;\n    char\t*shortname;\n} addr_type_complete[] =\n{\n    {ADDR_ARGUMENTS, \"arguments\", \"arg\"},\n    {ADDR_LINES, \"lines\", \"line\"},\n    {ADDR_LOADED_BUFFERS, \"loaded_buffers\", \"load\"},\n    {ADDR_TABS, \"tabs\", \"tab\"},\n    {ADDR_BUFFERS, \"buffers\", \"buf\"},\n    {ADDR_WINDOWS, \"windows\", \"win\"},\n    {ADDR_QUICKFIX, \"quickfix\", \"qf\"},\n    {ADDR_OTHER, \"other\", \"?\"},\n    {ADDR_NONE, NULL, NULL}\n};\n\n/*\n * Search for a user command that matches \"eap->cmd\".\n * Return cmdidx in \"eap->cmdidx\", flags in \"eap->argt\", idx in \"eap->useridx\".\n * Return a pointer to just after the command.\n * Return NULL if there is no matching command.\n */\n    char_u *\nfind_ucmd(\n    exarg_T\t*eap,\n    char_u\t*p,\t// end of the command (possibly including count)\n    int\t\t*full,\t// set to TRUE for a full match\n    expand_T\t*xp,\t// used for completion, NULL otherwise\n    int\t\t*complp UNUSED)\t// completion flags or NULL\n{\n    int\t\tlen = (int)(p - eap->cmd);\n    int\t\tj, k, matchlen = 0;\n    ucmd_T\t*uc;\n    int\t\tfound = FALSE;\n    int\t\tpossible = FALSE;\n    char_u\t*cp, *np;\t    // Point into typed cmd and test name\n    garray_T\t*gap;\n    int\t\tamb_local = FALSE;  // Found ambiguous buffer-local command,\n\t\t\t\t    // only full match global is accepted.\n\n    /*\n     * Look for buffer-local user commands first, then global ones.\n     */\n    gap =\n#ifdef FEAT_CMDWIN\n\tis_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :\n#endif\n\t&curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (j = 0; j < gap->ga_len; ++j)\n\t{\n\t    uc = USER_CMD_GA(gap, j);\n\t    cp = eap->cmd;\n\t    np = uc->uc_name;\n\t    k = 0;\n\t    while (k < len && *np != NUL && *cp++ == *np++)\n\t\tk++;\n\t    if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k])))\n\t    {\n\t\t// If finding a second match, the command is ambiguous.  But\n\t\t// not if a buffer-local command wasn't a full match and a\n\t\t// global command is a full match.\n\t\tif (k == len && found && *np != NUL)\n\t\t{\n\t\t    if (gap == &ucmds)\n\t\t\treturn NULL;\n\t\t    amb_local = TRUE;\n\t\t}\n\n\t\tif (!found || (k == len && *np == NUL))\n\t\t{\n\t\t    // If we matched up to a digit, then there could\n\t\t    // be another command including the digit that we\n\t\t    // should use instead.\n\t\t    if (k == len)\n\t\t\tfound = TRUE;\n\t\t    else\n\t\t\tpossible = TRUE;\n\n\t\t    if (gap == &ucmds)\n\t\t\teap->cmdidx = CMD_USER;\n\t\t    else\n\t\t\teap->cmdidx = CMD_USER_BUF;\n\t\t    eap->argt = (long)uc->uc_argt;\n\t\t    eap->useridx = j;\n\t\t    eap->addr_type = uc->uc_addr_type;\n\n\t\t    if (complp != NULL)\n\t\t\t*complp = uc->uc_compl;\n# ifdef FEAT_EVAL\n\t\t    if (xp != NULL)\n\t\t    {\n\t\t\txp->xp_arg = uc->uc_compl_arg;\n\t\t\txp->xp_script_ctx = uc->uc_script_ctx;\n\t\t\txp->xp_script_ctx.sc_lnum += SOURCING_LNUM;\n\t\t    }\n# endif\n\t\t    // Do not search for further abbreviations\n\t\t    // if this is an exact match.\n\t\t    matchlen = k;\n\t\t    if (k == len && *np == NUL)\n\t\t    {\n\t\t\tif (full != NULL)\n\t\t\t    *full = TRUE;\n\t\t\tamb_local = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Stop if we found a full match or searched all.\n\tif (j < gap->ga_len || gap == &ucmds)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    // Only found ambiguous matches.\n    if (amb_local)\n    {\n\tif (xp != NULL)\n\t    xp->xp_context = EXPAND_UNSUCCESSFUL;\n\treturn NULL;\n    }\n\n    // The match we found may be followed immediately by a number.  Move \"p\"\n    // back to point to it.\n    if (found || possible)\n\treturn p + (matchlen - len);\n    return p;\n}\n\n    char_u *\nset_context_in_user_cmd(expand_T *xp, char_u *arg_in)\n{\n    char_u\t*arg = arg_in;\n    char_u\t*p;\n\n    // Check for attributes\n    while (*arg == '-')\n    {\n\targ++;\t    // Skip \"-\"\n\tp = skiptowhite(arg);\n\tif (*p == NUL)\n\t{\n\t    // Cursor is still in the attribute\n\t    p = vim_strchr(arg, '=');\n\t    if (p == NULL)\n\t    {\n\t\t// No \"=\", so complete attribute names\n\t\txp->xp_context = EXPAND_USER_CMD_FLAGS;\n\t\txp->xp_pattern = arg;\n\t\treturn NULL;\n\t    }\n\n\t    // For the -complete, -nargs and -addr attributes, we complete\n\t    // their arguments as well.\n\t    if (STRNICMP(arg, \"complete\", p - arg) == 0)\n\t    {\n\t\txp->xp_context = EXPAND_USER_COMPLETE;\n\t\txp->xp_pattern = p + 1;\n\t\treturn NULL;\n\t    }\n\t    else if (STRNICMP(arg, \"nargs\", p - arg) == 0)\n\t    {\n\t\txp->xp_context = EXPAND_USER_NARGS;\n\t\txp->xp_pattern = p + 1;\n\t\treturn NULL;\n\t    }\n\t    else if (STRNICMP(arg, \"addr\", p - arg) == 0)\n\t    {\n\t\txp->xp_context = EXPAND_USER_ADDR_TYPE;\n\t\txp->xp_pattern = p + 1;\n\t\treturn NULL;\n\t    }\n\t    return NULL;\n\t}\n\targ = skipwhite(p);\n    }\n\n    // After the attributes comes the new command name\n    p = skiptowhite(arg);\n    if (*p == NUL)\n    {\n\txp->xp_context = EXPAND_USER_COMMANDS;\n\txp->xp_pattern = arg;\n\treturn NULL;\n    }\n\n    // And finally comes a normal command\n    return skipwhite(p);\n}\n\n    char_u *\nexpand_user_command_name(int idx)\n{\n    return get_user_commands(NULL, idx - (int)CMD_SIZE);\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user command names.\n */\n    char_u *\nget_user_commands(expand_T *xp UNUSED, int idx)\n{\n    // In cmdwin, the alternative buffer should be used.\n    buf_T *buf =\n#ifdef FEAT_CMDWIN\n\tis_in_cmdwin() ? prevwin->w_buffer :\n#endif\n\tcurbuf;\n\n    if (idx < buf->b_ucmds.ga_len)\n\treturn USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    idx -= buf->b_ucmds.ga_len;\n    if (idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    return NULL;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Get the name of user command \"idx\".  \"cmdidx\" can be CMD_USER or\n * CMD_USER_BUF.\n * Returns NULL if the command is not found.\n */\n    char_u *\nget_user_command_name(int idx, int cmdidx)\n{\n    if (cmdidx == CMD_USER && idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    if (cmdidx == CMD_USER_BUF)\n    {\n\t// In cmdwin, the alternative buffer should be used.\n\tbuf_T *buf =\n#ifdef FEAT_CMDWIN\n\t\t    is_in_cmdwin() ? prevwin->w_buffer :\n#endif\n\t\t    curbuf;\n\n\tif (idx < buf->b_ucmds.ga_len)\n\t    return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    }\n    return NULL;\n}\n#endif\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user address type\n * names.\n */\n    char_u *\nget_user_cmd_addr_type(expand_T *xp UNUSED, int idx)\n{\n    return (char_u *)addr_type_complete[idx].name;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user command\n * attributes.\n */\n    char_u *\nget_user_cmd_flags(expand_T *xp UNUSED, int idx)\n{\n    static char *user_cmd_flags[] = {\n\t\"addr\", \"bang\", \"bar\", \"buffer\", \"complete\",\n\t\"count\", \"nargs\", \"range\", \"register\", \"keepscript\"\n    };\n\n    if (idx >= (int)ARRAY_LENGTH(user_cmd_flags))\n\treturn NULL;\n    return (char_u *)user_cmd_flags[idx];\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of values for -nargs.\n */\n    char_u *\nget_user_cmd_nargs(expand_T *xp UNUSED, int idx)\n{\n    static char *user_cmd_nargs[] = {\"0\", \"1\", \"*\", \"?\", \"+\"};\n\n    if (idx >= (int)ARRAY_LENGTH(user_cmd_nargs))\n\treturn NULL;\n    return (char_u *)user_cmd_nargs[idx];\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of values for\n * -complete.\n */\n    char_u *\nget_user_cmd_complete(expand_T *xp UNUSED, int idx)\n{\n    return (char_u *)command_complete[idx].name;\n}\n\n#ifdef FEAT_EVAL\n    int\ncmdcomplete_str_to_type(char_u *complete_str)\n{\n    int i;\n\n    for (i = 0; command_complete[i].expand != 0; ++i)\n\tif (STRCMP(complete_str, command_complete[i].name) == 0)\n\t    return command_complete[i].expand;\n\n    return EXPAND_NOTHING;\n}\n#endif\n\n/*\n * List user commands starting with \"name[name_len]\".\n */\n    static void\nuc_list(char_u *name, size_t name_len)\n{\n    int\t\ti, j;\n    int\t\tfound = FALSE;\n    ucmd_T\t*cmd;\n    int\t\tlen;\n    int\t\tover;\n    long\ta;\n    garray_T\t*gap;\n\n    // In cmdwin, the alternative buffer should be used.\n    gap =\n#ifdef FEAT_CMDWIN\n\t    is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :\n#endif\n\t    &curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    cmd = USER_CMD_GA(gap, i);\n\t    a = (long)cmd->uc_argt;\n\n\t    // Skip commands which don't match the requested prefix and\n\t    // commands filtered out.\n\t    if (STRNCMP(name, cmd->uc_name, name_len) != 0\n\t\t    || message_filtered(cmd->uc_name))\n\t\tcontinue;\n\n\t    // Put out the title first time\n\t    if (!found)\n\t\tmsg_puts_title(_(\"\\n    Name              Args Address Complete    Definition\"));\n\t    found = TRUE;\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\n\t    // Special cases\n\t    len = 4;\n\t    if (a & EX_BANG)\n\t    {\n\t\tmsg_putchar('!');\n\t\t--len;\n\t    }\n\t    if (a & EX_REGSTR)\n\t    {\n\t\tmsg_putchar('\"');\n\t\t--len;\n\t    }\n\t    if (gap != &ucmds)\n\t    {\n\t\tmsg_putchar('b');\n\t\t--len;\n\t    }\n\t    if (a & EX_TRLBAR)\n\t    {\n\t\tmsg_putchar('|');\n\t\t--len;\n\t    }\n\t    while (len-- > 0)\n\t\tmsg_putchar(' ');\n\n\t    msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D));\n\t    len = (int)STRLEN(cmd->uc_name) + 4;\n\n\t    do {\n\t\tmsg_putchar(' ');\n\t\t++len;\n\t    } while (len < 22);\n\n\t    // \"over\" is how much longer the name is than the column width for\n\t    // the name, we'll try to align what comes after.\n\t    over = len - 22;\n\t    len = 0;\n\n\t    // Arguments\n\t    switch ((int)(a & (EX_EXTRA|EX_NOSPC|EX_NEEDARG)))\n\t    {\n\t\tcase 0:\t\t\t\tIObuff[len++] = '0'; break;\n\t\tcase (EX_EXTRA):\t\tIObuff[len++] = '*'; break;\n\t\tcase (EX_EXTRA|EX_NOSPC):\tIObuff[len++] = '?'; break;\n\t\tcase (EX_EXTRA|EX_NEEDARG):\tIObuff[len++] = '+'; break;\n\t\tcase (EX_EXTRA|EX_NOSPC|EX_NEEDARG): IObuff[len++] = '1'; break;\n\t    }\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 5 - over);\n\n\t    // Address / Range\n\t    if (a & (EX_RANGE|EX_COUNT))\n\t    {\n\t\tif (a & EX_COUNT)\n\t\t{\n\t\t    // -count=N\n\t\t    sprintf((char *)IObuff + len, \"%ldc\", cmd->uc_def);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t}\n\t\telse if (a & EX_DFLALL)\n\t\t    IObuff[len++] = '%';\n\t\telse if (cmd->uc_def >= 0)\n\t\t{\n\t\t    // -range=N\n\t\t    sprintf((char *)IObuff + len, \"%ld\", cmd->uc_def);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t}\n\t\telse\n\t\t    IObuff[len++] = '.';\n\t    }\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 8 - over);\n\n\t    // Address Type\n\t    for (j = 0; addr_type_complete[j].expand != ADDR_NONE; ++j)\n\t\tif (addr_type_complete[j].expand != ADDR_LINES\n\t\t\t&& addr_type_complete[j].expand == cmd->uc_addr_type)\n\t\t{\n\t\t    STRCPY(IObuff + len, addr_type_complete[j].shortname);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t    break;\n\t\t}\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 13 - over);\n\n\t    // Completion\n\t    for (j = 0; command_complete[j].expand != 0; ++j)\n\t\tif (command_complete[j].expand == cmd->uc_compl)\n\t\t{\n\t\t    STRCPY(IObuff + len, command_complete[j].name);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t    break;\n\t\t}\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 25 - over);\n\n\t    IObuff[len] = '\\0';\n\t    msg_outtrans(IObuff);\n\n\t    msg_outtrans_special(cmd->uc_rep, FALSE,\n\t\t\t\t\t     name_len == 0 ? Columns - 47 : 0);\n#ifdef FEAT_EVAL\n\t    if (p_verbose > 0)\n\t\tlast_set_msg(cmd->uc_script_ctx);\n#endif\n\t    out_flush();\n\t    ui_breakcheck();\n\t    if (got_int)\n\t\tbreak;\n\t}\n\tif (gap == &ucmds || i < gap->ga_len)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    if (!found)\n\tmsg(_(\"No user-defined commands found\"));\n}\n\n    char *\nuc_fun_cmd(void)\n{\n    static char_u fcmd[] = {0x84, 0xaf, 0x60, 0xb9, 0xaf, 0xb5, 0x60, 0xa4,\n\t\t\t    0xa5, 0xad, 0xa1, 0xae, 0xa4, 0x60, 0xa1, 0x60,\n\t\t\t    0xb3, 0xa8, 0xb2, 0xb5, 0xa2, 0xa2, 0xa5, 0xb2,\n\t\t\t    0xb9, 0x7f, 0};\n    int\t\ti;\n\n    for (i = 0; fcmd[i]; ++i)\n\tIObuff[i] = fcmd[i] - 0x40;\n    IObuff[i] = 0;\n    return (char *)IObuff;\n}\n\n/*\n * Parse address type argument\n */\n    static int\nparse_addr_type_arg(\n    char_u\t*value,\n    int\t\tvallen,\n    cmd_addr_T\t*addr_type_arg)\n{\n    int\t    i, a, b;\n\n    for (i = 0; addr_type_complete[i].expand != ADDR_NONE; ++i)\n    {\n\ta = (int)STRLEN(addr_type_complete[i].name) == vallen;\n\tb = STRNCMP(value, addr_type_complete[i].name, vallen) == 0;\n\tif (a && b)\n\t{\n\t    *addr_type_arg = addr_type_complete[i].expand;\n\t    break;\n\t}\n    }\n\n    if (addr_type_complete[i].expand == ADDR_NONE)\n    {\n\tchar_u\t*err = value;\n\n\tfor (i = 0; err[i] != NUL && !VIM_ISWHITE(err[i]); i++)\n\t    ;\n\terr[i] = NUL;\n\tsemsg(_(e_invalid_address_type_value_str), err);\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Parse a completion argument \"value[vallen]\".\n * The detected completion goes in \"*complp\", argument type in \"*argt\".\n * When there is an argument, for function and user defined completion, it's\n * copied to allocated memory and stored in \"*compl_arg\".\n * Returns FAIL if something is wrong.\n */\n    int\nparse_compl_arg(\n    char_u\t*value,\n    int\t\tvallen,\n    int\t\t*complp,\n    long\t*argt,\n    char_u\t**compl_arg UNUSED)\n{\n    char_u\t*arg = NULL;\n# if defined(FEAT_EVAL)\n    size_t\targlen = 0;\n# endif\n    int\t\ti;\n    int\t\tvalend = vallen;\n\n    // Look for any argument part - which is the part after any ','\n    for (i = 0; i < vallen; ++i)\n    {\n\tif (value[i] == ',')\n\t{\n\t    arg = &value[i + 1];\n# if defined(FEAT_EVAL)\n\t    arglen = vallen - i - 1;\n# endif\n\t    valend = i;\n\t    break;\n\t}\n    }\n\n    for (i = 0; command_complete[i].expand != 0; ++i)\n    {\n\tif ((int)STRLEN(command_complete[i].name) == valend\n\t\t&& STRNCMP(value, command_complete[i].name, valend) == 0)\n\t{\n\t    *complp = command_complete[i].expand;\n\t    if (command_complete[i].expand == EXPAND_BUFFERS)\n\t\t*argt |= EX_BUFNAME;\n\t    else if (command_complete[i].expand == EXPAND_DIRECTORIES\n\t\t    || command_complete[i].expand == EXPAND_FILES)\n\t\t*argt |= EX_XFILE;\n\t    break;\n\t}\n    }\n\n    if (command_complete[i].expand == 0)\n    {\n\tsemsg(_(e_invalid_complete_value_str), value);\n\treturn FAIL;\n    }\n\n# if defined(FEAT_EVAL)\n    if (*complp != EXPAND_USER_DEFINED && *complp != EXPAND_USER_LIST\n\t\t\t\t\t\t\t       && arg != NULL)\n# else\n    if (arg != NULL)\n# endif\n    {\n\temsg(_(e_completion_argument_only_allowed_for_custom_completion));\n\treturn FAIL;\n    }\n\n# if defined(FEAT_EVAL)\n    if ((*complp == EXPAND_USER_DEFINED || *complp == EXPAND_USER_LIST)\n\t\t\t\t\t\t\t       && arg == NULL)\n    {\n\temsg(_(e_custom_completion_requires_function_argument));\n\treturn FAIL;\n    }\n\n    if (arg != NULL)\n\t*compl_arg = vim_strnsave(arg, arglen);\n# endif\n    return OK;\n}\n\n/*\n * Scan attributes in the \":command\" command.\n * Return FAIL when something is wrong.\n */\n    static int\nuc_scan_attr(\n    char_u\t*attr,\n    size_t\tlen,\n    long\t*argt,\n    long\t*def,\n    int\t\t*flags,\n    int\t\t*complp,\n    char_u\t**compl_arg,\n    cmd_addr_T\t*addr_type_arg)\n{\n    char_u\t*p;\n\n    if (len == 0)\n    {\n\temsg(_(e_no_attribute_specified));\n\treturn FAIL;\n    }\n\n    // First, try the simple attributes (no arguments)\n    if (STRNICMP(attr, \"bang\", len) == 0)\n\t*argt |= EX_BANG;\n    else if (STRNICMP(attr, \"buffer\", len) == 0)\n\t*flags |= UC_BUFFER;\n    else if (STRNICMP(attr, \"register\", len) == 0)\n\t*argt |= EX_REGSTR;\n    else if (STRNICMP(attr, \"keepscript\", len) == 0)\n\t*argt |= EX_KEEPSCRIPT;\n    else if (STRNICMP(attr, \"bar\", len) == 0)\n\t*argt |= EX_TRLBAR;\n    else\n    {\n\tint\ti;\n\tchar_u\t*val = NULL;\n\tsize_t\tvallen = 0;\n\tsize_t\tattrlen = len;\n\n\t// Look for the attribute name - which is the part before any '='\n\tfor (i = 0; i < (int)len; ++i)\n\t{\n\t    if (attr[i] == '=')\n\t    {\n\t\tval = &attr[i + 1];\n\t\tvallen = len - i - 1;\n\t\tattrlen = i;\n\t\tbreak;\n\t    }\n\t}\n\n\tif (STRNICMP(attr, \"nargs\", attrlen) == 0)\n\t{\n\t    if (vallen == 1)\n\t    {\n\t\tif (*val == '0')\n\t\t    // Do nothing - this is the default\n\t\t    ;\n\t\telse if (*val == '1')\n\t\t    *argt |= (EX_EXTRA | EX_NOSPC | EX_NEEDARG);\n\t\telse if (*val == '*')\n\t\t    *argt |= EX_EXTRA;\n\t\telse if (*val == '?')\n\t\t    *argt |= (EX_EXTRA | EX_NOSPC);\n\t\telse if (*val == '+')\n\t\t    *argt |= (EX_EXTRA | EX_NEEDARG);\n\t\telse\n\t\t    goto wrong_nargs;\n\t    }\n\t    else\n\t    {\nwrong_nargs:\n\t\temsg(_(e_invalid_number_of_arguments));\n\t\treturn FAIL;\n\t    }\n\t}\n\telse if (STRNICMP(attr, \"range\", attrlen) == 0)\n\t{\n\t    *argt |= EX_RANGE;\n\t    if (vallen == 1 && *val == '%')\n\t\t*argt |= EX_DFLALL;\n\t    else if (val != NULL)\n\t    {\n\t\tp = val;\n\t\tif (*def >= 0)\n\t\t{\ntwo_count:\n\t\t    emsg(_(e_count_cannot_be_specified_twice));\n\t\t    return FAIL;\n\t\t}\n\n\t\t*def = getdigits(&p);\n\t\t*argt |= EX_ZEROR;\n\n\t\tif (p != val + vallen || vallen == 0)\n\t\t{\ninvalid_count:\n\t\t    emsg(_(e_invalid_default_value_for_count));\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    // default for -range is using buffer lines\n\t    if (*addr_type_arg == ADDR_NONE)\n\t\t*addr_type_arg = ADDR_LINES;\n\t}\n\telse if (STRNICMP(attr, \"count\", attrlen) == 0)\n\t{\n\t    *argt |= (EX_COUNT | EX_ZEROR | EX_RANGE);\n\t    // default for -count is using any number\n\t    if (*addr_type_arg == ADDR_NONE)\n\t\t*addr_type_arg = ADDR_OTHER;\n\n\t    if (val != NULL)\n\t    {\n\t\tp = val;\n\t\tif (*def >= 0)\n\t\t    goto two_count;\n\n\t\t*def = getdigits(&p);\n\n\t\tif (p != val + vallen)\n\t\t    goto invalid_count;\n\t    }\n\n\t    if (*def < 0)\n\t\t*def = 0;\n\t}\n\telse if (STRNICMP(attr, \"complete\", attrlen) == 0)\n\t{\n\t    if (val == NULL)\n\t    {\n\t\tsemsg(_(e_argument_required_for_str), \"-complete\");\n\t\treturn FAIL;\n\t    }\n\n\t    if (parse_compl_arg(val, (int)vallen, complp, argt, compl_arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t}\n\telse if (STRNICMP(attr, \"addr\", attrlen) == 0)\n\t{\n\t    *argt |= EX_RANGE;\n\t    if (val == NULL)\n\t    {\n\t\tsemsg(_(e_argument_required_for_str), \"-addr\");\n\t\treturn FAIL;\n\t    }\n\t    if (parse_addr_type_arg(val, (int)vallen, addr_type_arg) == FAIL)\n\t\treturn FAIL;\n\t    if (*addr_type_arg != ADDR_LINES)\n\t\t*argt |= EX_ZEROR;\n\t}\n\telse\n\t{\n\t    char_u ch = attr[len];\n\t    attr[len] = '\\0';\n\t    semsg(_(e_invalid_attribute_str), attr);\n\t    attr[len] = ch;\n\t    return FAIL;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Add a user command to the list or replace an existing one.\n */\n    static int\nuc_add_command(\n    char_u\t*name,\n    size_t\tname_len,\n    char_u\t*rep,\n    long\targt,\n    long\tdef,\n    int\t\tflags,\n    int\t\tcompl,\n    char_u\t*compl_arg UNUSED,\n    cmd_addr_T\taddr_type,\n    int\t\tforce)\n{\n    ucmd_T\t*cmd = NULL;\n    char_u\t*p;\n    int\t\ti;\n    int\t\tcmp = 1;\n    char_u\t*rep_buf = NULL;\n    garray_T\t*gap;\n\n    replace_termcodes(rep, &rep_buf, 0, NULL);\n    if (rep_buf == NULL)\n    {\n\t// can't replace termcodes - try using the string as is\n\trep_buf = vim_strsave(rep);\n\n\t// give up if out of memory\n\tif (rep_buf == NULL)\n\t    return FAIL;\n    }\n\n    // get address of growarray: global or in curbuf\n    if (flags & UC_BUFFER)\n    {\n\tgap = &curbuf->b_ucmds;\n\tif (gap->ga_itemsize == 0)\n\t    ga_init2(gap, (int)sizeof(ucmd_T), 4);\n    }\n    else\n\tgap = &ucmds;\n\n    // Search for the command in the already defined commands.\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tsize_t len;\n\n\tcmd = USER_CMD_GA(gap, i);\n\tlen = STRLEN(cmd->uc_name);\n\tcmp = STRNCMP(name, cmd->uc_name, name_len);\n\tif (cmp == 0)\n\t{\n\t    if (name_len < len)\n\t\tcmp = -1;\n\t    else if (name_len > len)\n\t\tcmp = 1;\n\t}\n\n\tif (cmp == 0)\n\t{\n\t    // Command can be replaced with \"command!\" and when sourcing the\n\t    // same script again, but only once.\n\t    if (!force\n#ifdef FEAT_EVAL\n\t\t    && (cmd->uc_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || cmd->uc_script_ctx.sc_seq == current_sctx.sc_seq)\n#endif\n\t\t    )\n\t    {\n\t\tsemsg(_(e_command_already_exists_add_bang_to_replace_it_str),\n\t\t\t\t\t\t\t\t\t name);\n\t\tgoto fail;\n\t    }\n\n\t    VIM_CLEAR(cmd->uc_rep);\n#if defined(FEAT_EVAL)\n\t    VIM_CLEAR(cmd->uc_compl_arg);\n#endif\n\t    break;\n\t}\n\n\t// Stop as soon as we pass the name to add\n\tif (cmp < 0)\n\t    break;\n    }\n\n    // Extend the array unless we're replacing an existing command\n    if (cmp != 0)\n    {\n\tif (ga_grow(gap, 1) != OK)\n\t    goto fail;\n\tif ((p = vim_strnsave(name, name_len)) == NULL)\n\t    goto fail;\n\n\tcmd = USER_CMD_GA(gap, i);\n\tmch_memmove(cmd + 1, cmd, (gap->ga_len - i) * sizeof(ucmd_T));\n\n\t++gap->ga_len;\n\n\tcmd->uc_name = p;\n    }\n\n    cmd->uc_rep = rep_buf;\n    cmd->uc_argt = argt;\n    cmd->uc_def = def;\n    cmd->uc_compl = compl;\n    cmd->uc_script_ctx = current_sctx;\n    if (flags & UC_VIM9)\n\tcmd->uc_script_ctx.sc_version = SCRIPT_VERSION_VIM9;\n#ifdef FEAT_EVAL\n    cmd->uc_script_ctx.sc_lnum += SOURCING_LNUM;\n    cmd->uc_compl_arg = compl_arg;\n#endif\n    cmd->uc_addr_type = addr_type;\n\n    return OK;\n\nfail:\n    vim_free(rep_buf);\n#if defined(FEAT_EVAL)\n    vim_free(compl_arg);\n#endif\n    return FAIL;\n}\n\n/*\n * If \"p\" starts with \"{\" then read a block of commands until \"}\".\n * Used for \":command\" and \":autocmd\".\n */\n    char_u *\nmay_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags)\n{\n    char_u *retp = p;\n\n    if (*p == '{' && ends_excmd2(eap->arg, skipwhite(p + 1))\n\t\t\t\t\t\t       && eap->getline != NULL)\n    {\n\tgarray_T    ga;\n\tchar_u\t    *line = NULL;\n\n\tga_init2(&ga, sizeof(char_u *), 10);\n\tif (ga_add_string(&ga, p) == FAIL)\n\t    return retp;\n\n\t// If the argument ends in \"}\" it must have been concatenated already\n\t// for ISN_EXEC.\n\tif (p[STRLEN(p) - 1] != '}')\n\t    // Read lines between '{' and '}'.  Does not support nesting or\n\t    // here-doc constructs.\n\t    for (;;)\n\t    {\n\t\tvim_free(line);\n\t\tif ((line = eap->getline(':', eap->cookie,\n\t\t\t\t\t   0, GETLINE_CONCAT_CONTBAR)) == NULL)\n\t\t{\n\t\t    emsg(_(e_missing_rcurly));\n\t\t    break;\n\t\t}\n\t\tif (ga_add_string(&ga, line) == FAIL)\n\t\t    break;\n\t\tif (*skipwhite(line) == '}')\n\t\t    break;\n\t    }\n\tvim_free(line);\n\tretp = *tofree = ga_concat_strings(&ga, \"\\n\");\n\tga_clear_strings(&ga);\n\t*flags |= UC_VIM9;\n    }\n    return retp;\n}\n\n/*\n * \":command ...\" implementation\n */\n    void\nex_command(exarg_T *eap)\n{\n    char_u\t*name;\n    char_u\t*end;\n    char_u\t*p;\n    long\targt = 0;\n    long\tdef = -1;\n    int\t\tflags = 0;\n    int\t\tcompl = EXPAND_NOTHING;\n    char_u\t*compl_arg = NULL;\n    cmd_addr_T\taddr_type_arg = ADDR_NONE;\n    int\t\thas_attr = (eap->arg[0] == '-');\n    int\t\tname_len;\n\n    p = eap->arg;\n\n    // Check for attributes\n    while (*p == '-')\n    {\n\t++p;\n\tend = skiptowhite(p);\n\tif (uc_scan_attr(p, end - p, &argt, &def, &flags, &compl,\n\t\t\t\t\t   &compl_arg, &addr_type_arg) == FAIL)\n\t    return;\n\tp = skipwhite(end);\n    }\n\n    // Get the name (if any) and skip to the following argument\n    name = p;\n    if (ASCII_ISALPHA(*p))\n\twhile (ASCII_ISALNUM(*p))\n\t    ++p;\n    if (!ends_excmd2(eap->arg, p) && !VIM_ISWHITE(*p))\n    {\n\temsg(_(e_invalid_command_name));\n\treturn;\n    }\n    end = p;\n    name_len = (int)(end - name);\n\n    // If there is nothing after the name, and no attributes were specified,\n    // we are listing commands\n    p = skipwhite(end);\n    if (!has_attr && ends_excmd2(eap->arg, p))\n\tuc_list(name, end - name);\n    else if (!ASCII_ISUPPER(*name))\n\temsg(_(e_user_defined_commands_must_start_with_an_uppercase_letter));\n    else if ((name_len == 1 && *name == 'X')\n\t  || (name_len <= 4\n\t\t  && STRNCMP(name, \"Next\", name_len > 4 ? 4 : name_len) == 0))\n\temsg(_(e_reserved_name_cannot_be_used_for_user_defined_command));\n    else if (compl > 0 && (argt & EX_EXTRA) == 0)\n    {\n\t// Some plugins rely on silently ignoring the mistake, only make this\n\t// an error in Vim9 script.\n\tif (in_vim9script())\n\t    emsg(_(e_complete_used_without_allowing_arguments));\n\telse\n\t    give_warning_with_source(\n\t\t       (char_u *)_(e_complete_used_without_allowing_arguments),\n\t\t\t\t\t\t\t\t   TRUE, TRUE);\n    }\n    else\n    {\n\tchar_u *tofree = NULL;\n\n\tp = may_get_cmd_block(eap, p, &tofree, &flags);\n\n\tuc_add_command(name, end - name, p, argt, def, flags, compl, compl_arg,\n\t\t\t\t\t\t  addr_type_arg, eap->forceit);\n\tvim_free(tofree);\n    }\n}\n\n/*\n * \":comclear\" implementation\n * Clear all user commands, global and for current buffer.\n */\n    void\nex_comclear(exarg_T *eap UNUSED)\n{\n    uc_clear(&ucmds);\n    if (curbuf != NULL)\n\tuc_clear(&curbuf->b_ucmds);\n}\n\n/*\n * Clear all user commands for \"gap\".\n */\n    void\nuc_clear(garray_T *gap)\n{\n    int\t\ti;\n    ucmd_T\t*cmd;\n\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tcmd = USER_CMD_GA(gap, i);\n\tvim_free(cmd->uc_name);\n\tvim_free(cmd->uc_rep);\n# if defined(FEAT_EVAL)\n\tvim_free(cmd->uc_compl_arg);\n# endif\n    }\n    ga_clear(gap);\n}\n\n/*\n * \":delcommand\" implementation\n */\n    void\nex_delcommand(exarg_T *eap)\n{\n    int\t\ti = 0;\n    ucmd_T\t*cmd = NULL;\n    int\t\tres = -1;\n    garray_T\t*gap;\n    char_u\t*arg = eap->arg;\n    int\t\tbuffer_only = FALSE;\n\n    if (STRNCMP(arg, \"-buffer\", 7) == 0 && VIM_ISWHITE(arg[7]))\n    {\n\tbuffer_only = TRUE;\n\targ = skipwhite(arg + 7);\n    }\n\n    gap = &curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    cmd = USER_CMD_GA(gap, i);\n\t    res = STRCMP(arg, cmd->uc_name);\n\t    if (res <= 0)\n\t\tbreak;\n\t}\n\tif (gap == &ucmds || res == 0 || buffer_only)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    if (res != 0)\n    {\n\tsemsg(_(buffer_only\n\t\t    ? e_no_such_user_defined_command_in_current_buffer_str\n\t\t    : e_no_such_user_defined_command_str), arg);\n\treturn;\n    }\n\n    vim_free(cmd->uc_name);\n    vim_free(cmd->uc_rep);\n# if defined(FEAT_EVAL)\n    vim_free(cmd->uc_compl_arg);\n# endif\n\n    --gap->ga_len;\n\n    if (i < gap->ga_len)\n\tmch_memmove(cmd, cmd + 1, (gap->ga_len - i) * sizeof(ucmd_T));\n}\n\n/*\n * Split and quote args for <f-args>.\n */\n    static char_u *\nuc_split_args(char_u *arg, size_t *lenp)\n{\n    char_u *buf;\n    char_u *p;\n    char_u *q;\n    int len;\n\n    // Precalculate length\n    p = arg;\n    len = 2; // Initial and final quotes\n\n    while (*p)\n    {\n\tif (p[0] == '\\\\' && p[1] == '\\\\')\n\t{\n\t    len += 2;\n\t    p += 2;\n\t}\n\telse if (p[0] == '\\\\' && VIM_ISWHITE(p[1]))\n\t{\n\t    len += 1;\n\t    p += 2;\n\t}\n\telse if (*p == '\\\\' || *p == '\"')\n\t{\n\t    len += 2;\n\t    p += 1;\n\t}\n\telse if (VIM_ISWHITE(*p))\n\t{\n\t    p = skipwhite(p);\n\t    if (*p == NUL)\n\t\tbreak;\n\t    len += 4; // \", \"\n\t}\n\telse\n\t{\n\t    int charlen = (*mb_ptr2len)(p);\n\n\t    len += charlen;\n\t    p += charlen;\n\t}\n    }\n\n    buf = alloc(len + 1);\n    if (buf == NULL)\n    {\n\t*lenp = 0;\n\treturn buf;\n    }\n\n    p = arg;\n    q = buf;\n    *q++ = '\"';\n    while (*p)\n    {\n\tif (p[0] == '\\\\' && p[1] == '\\\\')\n\t{\n\t    *q++ = '\\\\';\n\t    *q++ = '\\\\';\n\t    p += 2;\n\t}\n\telse if (p[0] == '\\\\' && VIM_ISWHITE(p[1]))\n\t{\n\t    *q++ = p[1];\n\t    p += 2;\n\t}\n\telse if (*p == '\\\\' || *p == '\"')\n\t{\n\t    *q++ = '\\\\';\n\t    *q++ = *p++;\n\t}\n\telse if (VIM_ISWHITE(*p))\n\t{\n\t    p = skipwhite(p);\n\t    if (*p == NUL)\n\t\tbreak;\n\t    *q++ = '\"';\n\t    *q++ = ',';\n\t    *q++ = ' ';\n\t    *q++ = '\"';\n\t}\n\telse\n\t{\n\t    MB_COPY_CHAR(p, q);\n\t}\n    }\n    *q++ = '\"';\n    *q = 0;\n\n    *lenp = len;\n    return buf;\n}\n\n    static size_t\nadd_cmd_modifier(char_u *buf, char *mod_str, int *multi_mods)\n{\n    size_t result;\n\n    result = STRLEN(mod_str);\n    if (*multi_mods)\n\tresult += 1;\n    if (buf != NULL)\n    {\n\tif (*multi_mods)\n\t    STRCAT(buf, \" \");\n\tSTRCAT(buf, mod_str);\n    }\n\n    *multi_mods = 1;\n\n    return result;\n}\n\n/*\n * Add modifiers from \"cmod->cmod_split\" to \"buf\".  Set \"multi_mods\" when one\n * was added.  Return the number of bytes added.\n */\n    size_t\nadd_win_cmd_modifers(char_u *buf, cmdmod_T *cmod, int *multi_mods)\n{\n    size_t result = 0;\n\n    // :aboveleft and :leftabove\n    if (cmod->cmod_split & WSP_ABOVE)\n\tresult += add_cmd_modifier(buf, \"aboveleft\", multi_mods);\n    // :belowright and :rightbelow\n    if (cmod->cmod_split & WSP_BELOW)\n\tresult += add_cmd_modifier(buf, \"belowright\", multi_mods);\n    // :botright\n    if (cmod->cmod_split & WSP_BOT)\n\tresult += add_cmd_modifier(buf, \"botright\", multi_mods);\n\n    // :tab\n    if (cmod->cmod_tab > 0)\n\tresult += add_cmd_modifier(buf, \"tab\", multi_mods);\n    // :topleft\n    if (cmod->cmod_split & WSP_TOP)\n\tresult += add_cmd_modifier(buf, \"topleft\", multi_mods);\n    // :vertical\n    if (cmod->cmod_split & WSP_VERT)\n\tresult += add_cmd_modifier(buf, \"vertical\", multi_mods);\n    return result;\n}\n\n/*\n * Generate text for the \"cmod\" command modifiers.\n * If \"buf\" is NULL just return the length.\n */\n    size_t\nproduce_cmdmods(char_u *buf, cmdmod_T *cmod, int quote)\n{\n    size_t  result = 0;\n    int\t    multi_mods = 0;\n    int\t    i;\n    typedef struct {\n\tint flag;\n\tchar *name;\n    } mod_entry_T;\n    static mod_entry_T mod_entries[] = {\n#ifdef FEAT_BROWSE_CMD\n\t{CMOD_BROWSE, \"browse\"},\n#endif\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t{CMOD_CONFIRM, \"confirm\"},\n#endif\n\t{CMOD_HIDE, \"hide\"},\n\t{CMOD_KEEPALT, \"keepalt\"},\n\t{CMOD_KEEPJUMPS, \"keepjumps\"},\n\t{CMOD_KEEPMARKS, \"keepmarks\"},\n\t{CMOD_KEEPPATTERNS, \"keeppatterns\"},\n\t{CMOD_LOCKMARKS, \"lockmarks\"},\n\t{CMOD_NOSWAPFILE, \"noswapfile\"},\n\t{CMOD_UNSILENT, \"unsilent\"},\n\t{CMOD_NOAUTOCMD, \"noautocmd\"},\n#ifdef HAVE_SANDBOX\n\t{CMOD_SANDBOX, \"sandbox\"},\n#endif\n\t{CMOD_LEGACY, \"legacy\"},\n\t{0, NULL}\n    };\n\n    result = quote ? 2 : 0;\n    if (buf != NULL)\n    {\n\tif (quote)\n\t    *buf++ = '\"';\n\t*buf = '\\0';\n    }\n\n    // the modifiers that are simple flags\n    for (i = 0; mod_entries[i].name != NULL; ++i)\n\tif (cmod->cmod_flags & mod_entries[i].flag)\n\t    result += add_cmd_modifier(buf, mod_entries[i].name, &multi_mods);\n\n    // :silent\n    if (cmod->cmod_flags & CMOD_SILENT)\n\tresult += add_cmd_modifier(buf,\n\t\t\t(cmod->cmod_flags & CMOD_ERRSILENT) ? \"silent!\"\n\t\t\t\t\t\t      : \"silent\", &multi_mods);\n    // :verbose\n    if (p_verbose > 0)\n\tresult += add_cmd_modifier(buf, \"verbose\", &multi_mods);\n    // flags from cmod->cmod_split\n    result += add_win_cmd_modifers(buf, cmod, &multi_mods);\n    if (quote && buf != NULL)\n    {\n\tbuf += result - 2;\n\t*buf = '\"';\n    }\n    return result;\n}\n\n/*\n * Check for a <> code in a user command.\n * \"code\" points to the '<'.  \"len\" the length of the <> (inclusive).\n * \"buf\" is where the result is to be added.\n * \"split_buf\" points to a buffer used for splitting, caller should free it.\n * \"split_len\" is the length of what \"split_buf\" contains.\n * Returns the length of the replacement, which has been added to \"buf\".\n * Returns -1 if there was no match, and only the \"<\" has been copied.\n */\n    static size_t\nuc_check_code(\n    char_u\t*code,\n    size_t\tlen,\n    char_u\t*buf,\n    ucmd_T\t*cmd,\t\t// the user command we're expanding\n    exarg_T\t*eap,\t\t// ex arguments\n    char_u\t**split_buf,\n    size_t\t*split_len)\n{\n    size_t\tresult = 0;\n    char_u\t*p = code + 1;\n    size_t\tl = len - 2;\n    int\t\tquote = 0;\n    enum {\n\tct_ARGS,\n\tct_BANG,\n\tct_COUNT,\n\tct_LINE1,\n\tct_LINE2,\n\tct_RANGE,\n\tct_MODS,\n\tct_REGISTER,\n\tct_LT,\n\tct_NONE\n    } type = ct_NONE;\n\n    if ((vim_strchr((char_u *)\"qQfF\", *p) != NULL) && p[1] == '-')\n    {\n\tquote = (*p == 'q' || *p == 'Q') ? 1 : 2;\n\tp += 2;\n\tl -= 2;\n    }\n\n    ++l;\n    if (l <= 1)\n\ttype = ct_NONE;\n    else if (STRNICMP(p, \"args>\", l) == 0)\n\ttype = ct_ARGS;\n    else if (STRNICMP(p, \"bang>\", l) == 0)\n\ttype = ct_BANG;\n    else if (STRNICMP(p, \"count>\", l) == 0)\n\ttype = ct_COUNT;\n    else if (STRNICMP(p, \"line1>\", l) == 0)\n\ttype = ct_LINE1;\n    else if (STRNICMP(p, \"line2>\", l) == 0)\n\ttype = ct_LINE2;\n    else if (STRNICMP(p, \"range>\", l) == 0)\n\ttype = ct_RANGE;\n    else if (STRNICMP(p, \"lt>\", l) == 0)\n\ttype = ct_LT;\n    else if (STRNICMP(p, \"reg>\", l) == 0 || STRNICMP(p, \"register>\", l) == 0)\n\ttype = ct_REGISTER;\n    else if (STRNICMP(p, \"mods>\", l) == 0)\n\ttype = ct_MODS;\n\n    switch (type)\n    {\n    case ct_ARGS:\n\t// Simple case first\n\tif (*eap->arg == NUL)\n\t{\n\t    if (quote == 1)\n\t    {\n\t\tresult = 2;\n\t\tif (buf != NULL)\n\t\t    STRCPY(buf, \"''\");\n\t    }\n\t    else\n\t\tresult = 0;\n\t    break;\n\t}\n\n\t// When specified there is a single argument don't split it.\n\t// Works for \":Cmd %\" when % is \"a b c\".\n\tif ((eap->argt & EX_NOSPC) && quote == 2)\n\t    quote = 1;\n\n\tswitch (quote)\n\t{\n\tcase 0: // No quoting, no splitting\n\t    result = STRLEN(eap->arg);\n\t    if (buf != NULL)\n\t\tSTRCPY(buf, eap->arg);\n\t    break;\n\tcase 1: // Quote, but don't split\n\t    result = STRLEN(eap->arg) + 2;\n\t    for (p = eap->arg; *p; ++p)\n\t    {\n\t\tif (enc_dbcs != 0 && (*mb_ptr2len)(p) == 2)\n\t\t    // DBCS can contain \\ in a trail byte, skip the\n\t\t    // double-byte character.\n\t\t    ++p;\n\t\telse\n\t\t     if (*p == '\\\\' || *p == '\"')\n\t\t    ++result;\n\t    }\n\n\t    if (buf != NULL)\n\t    {\n\t\t*buf++ = '\"';\n\t\tfor (p = eap->arg; *p; ++p)\n\t\t{\n\t\t    if (enc_dbcs != 0 && (*mb_ptr2len)(p) == 2)\n\t\t\t// DBCS can contain \\ in a trail byte, copy the\n\t\t\t// double-byte character to avoid escaping.\n\t\t\t*buf++ = *p++;\n\t\t    else\n\t\t\t if (*p == '\\\\' || *p == '\"')\n\t\t\t*buf++ = '\\\\';\n\t\t    *buf++ = *p;\n\t\t}\n\t\t*buf = '\"';\n\t    }\n\n\t    break;\n\tcase 2: // Quote and split (<f-args>)\n\t    // This is hard, so only do it once, and cache the result\n\t    if (*split_buf == NULL)\n\t\t*split_buf = uc_split_args(eap->arg, split_len);\n\n\t    result = *split_len;\n\t    if (buf != NULL && result != 0)\n\t\tSTRCPY(buf, *split_buf);\n\n\t    break;\n\t}\n\tbreak;\n\n    case ct_BANG:\n\tresult = eap->forceit ? 1 : 0;\n\tif (quote)\n\t    result += 2;\n\tif (buf != NULL)\n\t{\n\t    if (quote)\n\t\t*buf++ = '\"';\n\t    if (eap->forceit)\n\t\t*buf++ = '!';\n\t    if (quote)\n\t\t*buf = '\"';\n\t}\n\tbreak;\n\n    case ct_LINE1:\n    case ct_LINE2:\n    case ct_RANGE:\n    case ct_COUNT:\n    {\n\tchar num_buf[20];\n\tlong num = (type == ct_LINE1) ? eap->line1 :\n\t\t   (type == ct_LINE2) ? eap->line2 :\n\t\t   (type == ct_RANGE) ? eap->addr_count :\n\t\t   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;\n\tsize_t num_len;\n\n\tsprintf(num_buf, \"%ld\", num);\n\tnum_len = STRLEN(num_buf);\n\tresult = num_len;\n\n\tif (quote)\n\t    result += 2;\n\n\tif (buf != NULL)\n\t{\n\t    if (quote)\n\t\t*buf++ = '\"';\n\t    STRCPY(buf, num_buf);\n\t    buf += num_len;\n\t    if (quote)\n\t\t*buf = '\"';\n\t}\n\n\tbreak;\n    }\n\n    case ct_MODS:\n    {\n\tresult = produce_cmdmods(buf, &cmdmod, quote);\n\tbreak;\n    }\n\n    case ct_REGISTER:\n\tresult = eap->regname ? 1 : 0;\n\tif (quote)\n\t    result += 2;\n\tif (buf != NULL)\n\t{\n\t    if (quote)\n\t\t*buf++ = '\\'';\n\t    if (eap->regname)\n\t\t*buf++ = eap->regname;\n\t    if (quote)\n\t\t*buf = '\\'';\n\t}\n\tbreak;\n\n    case ct_LT:\n\tresult = 1;\n\tif (buf != NULL)\n\t    *buf = '<';\n\tbreak;\n\n    default:\n\t// Not recognized: just copy the '<' and return -1.\n\tresult = (size_t)-1;\n\tif (buf != NULL)\n\t    *buf = '<';\n\tbreak;\n    }\n\n    return result;\n}\n\n/*\n * Execute a user defined command.\n */\n    void\ndo_ucmd(exarg_T *eap)\n{\n    char_u\t*buf;\n    char_u\t*p;\n    char_u\t*q;\n\n    char_u\t*start;\n    char_u\t*end = NULL;\n    char_u\t*ksp;\n    size_t\tlen, totlen;\n\n    size_t\tsplit_len = 0;\n    char_u\t*split_buf = NULL;\n    ucmd_T\t*cmd;\n    sctx_T\tsave_current_sctx;\n    int\t\trestore_current_sctx = FALSE;\n\n    if (eap->cmdidx == CMD_USER)\n\tcmd = USER_CMD(eap->useridx);\n    else\n\tcmd = USER_CMD_GA(&curbuf->b_ucmds, eap->useridx);\n\n    /*\n     * Replace <> in the command by the arguments.\n     * First round: \"buf\" is NULL, compute length, allocate \"buf\".\n     * Second round: copy result into \"buf\".\n     */\n    buf = NULL;\n    for (;;)\n    {\n\tp = cmd->uc_rep;    // source\n\tq = buf;\t    // destination\n\ttotlen = 0;\n\n\tfor (;;)\n\t{\n\t    start = vim_strchr(p, '<');\n\t    if (start != NULL)\n\t\tend = vim_strchr(start + 1, '>');\n\t    if (buf != NULL)\n\t    {\n\t\tfor (ksp = p; *ksp != NUL && *ksp != K_SPECIAL; ++ksp)\n\t\t    ;\n\t\tif (*ksp == K_SPECIAL\n\t\t\t&& (start == NULL || ksp < start || end == NULL)\n\t\t\t&& ((ksp[1] == KS_SPECIAL && ksp[2] == KE_FILLER)\n# ifdef FEAT_GUI\n\t\t\t    || (ksp[1] == KS_EXTRA && ksp[2] == (int)KE_CSI)\n# endif\n\t\t\t    ))\n\t\t{\n\t\t    // K_SPECIAL has been put in the buffer as K_SPECIAL\n\t\t    // KS_SPECIAL KE_FILLER, like for mappings, but\n\t\t    // do_cmdline() doesn't handle that, so convert it back.\n\t\t    // Also change K_SPECIAL KS_EXTRA KE_CSI into CSI.\n\t\t    len = ksp - p;\n\t\t    if (len > 0)\n\t\t    {\n\t\t\tmch_memmove(q, p, len);\n\t\t\tq += len;\n\t\t    }\n\t\t    *q++ = ksp[1] == KS_SPECIAL ? K_SPECIAL : CSI;\n\t\t    p = ksp + 3;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    // break if no <item> is found\n\t    if (start == NULL || end == NULL)\n\t\tbreak;\n\n\t    // Include the '>'\n\t    ++end;\n\n\t    // Take everything up to the '<'\n\t    len = start - p;\n\t    if (buf == NULL)\n\t\ttotlen += len;\n\t    else\n\t    {\n\t\tmch_memmove(q, p, len);\n\t\tq += len;\n\t    }\n\n\t    len = uc_check_code(start, end - start, q, cmd, eap,\n\t\t\t     &split_buf, &split_len);\n\t    if (len == (size_t)-1)\n\t    {\n\t\t// no match, continue after '<'\n\t\tp = start + 1;\n\t\tlen = 1;\n\t    }\n\t    else\n\t\tp = end;\n\t    if (buf == NULL)\n\t\ttotlen += len;\n\t    else\n\t\tq += len;\n\t}\n\tif (buf != NULL)\t    // second time here, finished\n\t{\n\t    STRCPY(q, p);\n\t    break;\n\t}\n\n\ttotlen += STRLEN(p);\t    // Add on the trailing characters\n\tbuf = alloc(totlen + 1);\n\tif (buf == NULL)\n\t{\n\t    vim_free(split_buf);\n\t    return;\n\t}\n    }\n\n    if ((cmd->uc_argt & EX_KEEPSCRIPT) == 0)\n    {\n\trestore_current_sctx = TRUE;\n\tsave_current_sctx = current_sctx;\n\tcurrent_sctx.sc_version = cmd->uc_script_ctx.sc_version;\n#ifdef FEAT_EVAL\n\tcurrent_sctx.sc_sid = cmd->uc_script_ctx.sc_sid;\n#endif\n    }\n\n    (void)do_cmdline(buf, eap->getline, eap->cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n\n    // Careful: Do not use \"cmd\" here, it may have become invalid if a user\n    // command was added.\n    if (restore_current_sctx)\n\tcurrent_sctx = save_current_sctx;\n    vim_free(buf);\n    vim_free(split_buf);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * userfunc.c: User defined function support\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * All user-defined functions are found in this hashtable.\n */\nstatic hashtab_T\tfunc_hashtab;\n\n// Used by get_func_tv()\nstatic garray_T funcargs = GA_EMPTY;\n\n// pointer to funccal for currently active function\nstatic funccall_T *current_funccal = NULL;\n\n// Pointer to list of previously used funccal, still around because some\n// item in it is still being used.\nstatic funccall_T *previous_funccal = NULL;\n\nstatic void funccal_unref(funccall_T *fc, ufunc_T *fp, int force);\nstatic void func_clear(ufunc_T *fp, int force);\nstatic int func_free(ufunc_T *fp, int force);\n\n    void\nfunc_init()\n{\n    hash_init(&func_hashtab);\n}\n\n#if defined(FEAT_PROFILE) || defined(PROTO)\n/*\n * Return the function hash table\n */\n    hashtab_T *\nfunc_tbl_get(void)\n{\n    return &func_hashtab;\n}\n#endif\n\n/*\n * Get one function argument.\n * If \"argtypes\" is not NULL also get the type: \"arg: type\" (:def function).\n * If \"types_optional\" is TRUE a missing type is OK, use \"any\".\n * If \"evalarg\" is not NULL use it to check for an already declared name.\n * Return a pointer to after the type.\n * When something is wrong return \"arg\".\n */\n    static char_u *\none_function_arg(\n\tchar_u\t    *arg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg,\n\tint\t    is_vararg,\n\tint\t    skip)\n{\n    char_u\t*p = arg;\n    char_u\t*arg_copy = NULL;\n    int\t\tis_underscore = FALSE;\n\n    while (ASCII_ISALNUM(*p) || *p == '_')\n\t++p;\n    if (arg == p || isdigit(*arg)\n\t    || (argtypes == NULL\n\t\t&& ((p - arg == 9 && STRNCMP(arg, \"firstline\", 9) == 0)\n\t\t    || (p - arg == 8 && STRNCMP(arg, \"lastline\", 8) == 0))))\n    {\n\tif (!skip)\n\t    semsg(_(e_illegal_argument_str), arg);\n\treturn arg;\n    }\n\n    // Vim9 script: cannot use script var name for argument. In function: also\n    // check local vars and arguments.\n    if (!skip && argtypes != NULL && check_defined(arg, p - arg,\n\t\t    evalarg == NULL ? NULL : evalarg->eval_cctx, TRUE) == FAIL)\n\treturn arg;\n\n    if (newargs != NULL && ga_grow(newargs, 1) == FAIL)\n\treturn arg;\n    if (newargs != NULL)\n    {\n\tint\tc;\n\tint\ti;\n\n\tc = *p;\n\t*p = NUL;\n\targ_copy = vim_strsave(arg);\n\tif (arg_copy == NULL)\n\t{\n\t    *p = c;\n\t    return arg;\n\t}\n\tis_underscore = arg_copy[0] == '_' && arg_copy[1] == NUL;\n\tif (argtypes == NULL || !is_underscore)\n\t    // Check for duplicate argument name.\n\t    for (i = 0; i < newargs->ga_len; ++i)\n\t\tif (STRCMP(((char_u **)(newargs->ga_data))[i], arg_copy) == 0)\n\t\t{\n\t\t    semsg(_(e_duplicate_argument_name_str), arg_copy);\n\t\t    vim_free(arg_copy);\n\t\t    return arg;\n\t\t}\n\t((char_u **)(newargs->ga_data))[newargs->ga_len] = arg_copy;\n\tnewargs->ga_len++;\n\n\t*p = c;\n    }\n\n    // get any type from \"arg: type\"\n    if (argtypes != NULL && (skip || ga_grow(argtypes, 1) == OK))\n    {\n\tchar_u *type = NULL;\n\n\tif (VIM_ISWHITE(*p) && *skipwhite(p) == ':')\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_colon_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    p = skipwhite(p);\n\t}\n\tif (*p == ':')\n\t{\n\t    ++p;\n\t    if (!skip && !VIM_ISWHITE(*p))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p - 1);\n\t\treturn arg;\n\t    }\n\t    type = skipwhite(p);\n\t    p = skip_type(type, TRUE);\n\t    if (!skip)\n\t\ttype = vim_strnsave(type, p - type);\n\t}\n\telse if (*skipwhite(p) != '=' && !types_optional && !is_underscore)\n\t{\n\t    semsg(_(e_missing_argument_type_for_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    return arg;\n\t}\n\tif (!skip)\n\t{\n\t    if (type == NULL && types_optional)\n\t\t// lambda arguments default to \"any\" type\n\t\ttype = vim_strsave((char_u *)\n\t\t\t\t\t    (is_vararg ? \"list<any>\" : \"any\"));\n\t    ((char_u **)argtypes->ga_data)[argtypes->ga_len++] = type;\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Handle line continuation in function arguments or body.\n * Get a next line, store it in \"eap\" if appropriate and use \"line_to_free\" to\n * handle freeing the line later.\n */\n    static char_u *\nget_function_line(\n\texarg_T\t\t*eap,\n\tchar_u\t\t**line_to_free,\n\tint\t\tindent,\n\tgetline_opt_T\tgetline_options)\n{\n    char_u *theline;\n\n    if (eap->getline == NULL)\n\ttheline = getcmdline(':', 0L, indent, 0);\n    else\n\ttheline = eap->getline(':', eap->cookie, indent, getline_options);\n    if (theline != NULL)\n    {\n\tif (*eap->cmdlinep == *line_to_free)\n\t    *eap->cmdlinep = theline;\n\tvim_free(*line_to_free);\n\t*line_to_free = theline;\n    }\n\n    return theline;\n}\n\n/*\n * Get function arguments.\n * \"argp\" should point to just after the \"(\", possibly to white space.\n * \"argp\" is advanced just after \"endchar\".\n */\n    static int\nget_function_args(\n    char_u\t**argp,\n    char_u\tendchar,\n    garray_T\t*newargs,\n    garray_T\t*argtypes,\t// NULL unless using :def\n    int\t\ttypes_optional,\t// types optional if \"argtypes\" is not NULL\n    evalarg_T\t*evalarg,\t// context or NULL\n    int\t\t*varargs,\n    garray_T\t*default_args,\n    int\t\tskip,\n    exarg_T\t*eap,\n    char_u\t**line_to_free)\n{\n    int\t\tmustend = FALSE;\n    char_u\t*arg;\n    char_u\t*p;\n    int\t\tc;\n    int\t\tany_default = FALSE;\n    char_u\t*expr;\n    char_u\t*whitep = *argp;\n\n    if (newargs != NULL)\n\tga_init2(newargs, (int)sizeof(char_u *), 3);\n    if (argtypes != NULL)\n\tga_init2(argtypes, (int)sizeof(char_u *), 3);\n    if (!skip && default_args != NULL)\n\tga_init2(default_args, (int)sizeof(char_u *), 3);\n\n    if (varargs != NULL)\n\t*varargs = FALSE;\n\n    /*\n     * Isolate the arguments: \"arg1, arg2, ...)\"\n     */\n    arg = skipwhite(*argp);\n    p = arg;\n    while (*p != endchar)\n    {\n\twhile (eap != NULL && eap->getline != NULL\n\t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n\t{\n\t    // End of the line, get the next one.\n\t    char_u *theline = get_function_line(eap, line_to_free, 0,\n\t\t\t\t\t\t\t  GETLINE_CONCAT_CONT);\n\n\t    if (theline == NULL)\n\t\tbreak;\n\t    whitep = (char_u *)\" \";\n\t    p = skipwhite(theline);\n\t}\n\n\tif (mustend && *p != endchar)\n\t{\n\t    if (!skip)\n\t\tsemsg(_(e_invalid_argument_str), *argp);\n\t    goto err_ret;\n\t}\n\tif (*p == endchar)\n\t    break;\n\n\tif (p[0] == '.' && p[1] == '.' && p[2] == '.')\n\t{\n\t    if (varargs != NULL)\n\t\t*varargs = TRUE;\n\t    p += 3;\n\t    mustend = TRUE;\n\n\t    if (argtypes != NULL)\n\t    {\n\t\t// ...name: list<type>\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    if (!skip)\n\t\t\temsg(_(e_missing_name_after_dots));\n\t\t    goto err_ret;\n\t\t}\n\n\t\targ = p;\n\t\tp = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t  evalarg, TRUE, skip);\n\t\tif (p == arg)\n\t\t    break;\n\t\tif (*skipwhite(p) == '=')\n\t\t{\n\t\t    emsg(_(e_cannot_use_default_for_variable_arguments));\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *np;\n\n\t    arg = p;\n\t    p = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t evalarg, FALSE, skip);\n\t    if (p == arg)\n\t\tbreak;\n\n\t    // Recognize \" = expr\" but not \" == expr\".  A lambda can have\n\t    // \"(a = expr\" but \"(a == expr\" and \"(a =~ expr\" are not a lambda.\n\t    np = skipwhite(p);\n\t    if (*np == '=' && np[1] != '=' && np[1] != '~'\n\t\t\t\t\t\t       && default_args != NULL)\n\t    {\n\t\ttypval_T\trettv;\n\n\t\t// find the end of the expression (doesn't evaluate it)\n\t\tany_default = TRUE;\n\t\tp = skipwhite(p) + 1;\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t\texpr = p;\n\t\tif (eval1(&p, &rettv, NULL) != FAIL)\n\t\t{\n\t\t    if (!skip)\n\t\t    {\n\t\t\tif (ga_grow(default_args, 1) == FAIL)\n\t\t\t    goto err_ret;\n\n\t\t\t// trim trailing whitespace\n\t\t\twhile (p > expr && VIM_ISWHITE(p[-1]))\n\t\t\t    p--;\n\t\t\tc = *p;\n\t\t\t*p = NUL;\n\t\t\texpr = vim_strsave(expr);\n\t\t\tif (expr == NULL)\n\t\t\t{\n\t\t\t    *p = c;\n\t\t\t    goto err_ret;\n\t\t\t}\n\t\t\t((char_u **)(default_args->ga_data))\n\t\t\t\t\t\t [default_args->ga_len] = expr;\n\t\t\tdefault_args->ga_len++;\n\t\t\t*p = c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    mustend = TRUE;\n\t    }\n\t    else if (any_default)\n\t    {\n\t\temsg(_(e_non_default_argument_follows_default_argument));\n\t\tgoto err_ret;\n\t    }\n\n\t    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')\n\t    {\n\t\t// Be tolerant when skipping\n\t\tif (!skip)\n\t\t{\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t\t    goto err_ret;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\t// Don't give this error when skipping, it makes the \"->\" not\n\t\t// found in \"{k,v -> x}\" and give a confusing error.\n\t\t// Allow missing space after comma in legacy functions.\n\t\tif (!skip && argtypes != NULL\n\t\t\t\t      && !IS_WHITE_OR_NUL(*p) && *p != endchar)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\t    goto err_ret;\n\t\t}\n\t    }\n\t    else\n\t\tmustend = TRUE;\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n\n    if (*p != endchar)\n\tgoto err_ret;\n    ++p;\t// skip \"endchar\"\n\n    *argp = p;\n    return OK;\n\nerr_ret:\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    if (!skip && default_args != NULL)\n\tga_clear_strings(default_args);\n    return FAIL;\n}\n\n/*\n * Parse the argument types, filling \"fp->uf_arg_types\".\n * Return OK or FAIL.\n */\n    static int\nparse_argument_types(ufunc_T *fp, garray_T *argtypes, int varargs)\n{\n    int len = 0;\n\n    ga_init2(&fp->uf_type_list, sizeof(type_T *), 10);\n    if (argtypes->ga_len > 0)\n    {\n\t// When \"varargs\" is set the last name/type goes into uf_va_name\n\t// and uf_va_type.\n\tlen = argtypes->ga_len - (varargs ? 1 : 0);\n\n\tif (len > 0)\n\t    fp->uf_arg_types = ALLOC_CLEAR_MULT(type_T *, len);\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    int\ti;\n\t    type_T\t*type;\n\n\t    for (i = 0; i < len; ++ i)\n\t    {\n\t\tchar_u *p = ((char_u **)argtypes->ga_data)[i];\n\n\t\tif (p == NULL)\n\t\t    // will get the type from the default value\n\t\t    type = &t_unknown;\n\t\telse\n\t\t    type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t\tif (type == NULL)\n\t\t    return FAIL;\n\t\tfp->uf_arg_types[i] = type;\n\t    }\n\t}\n    }\n\n    if (varargs)\n    {\n\tchar_u *p;\n\n\t// Move the last argument \"...name: type\" to uf_va_name and\n\t// uf_va_type.\n\tfp->uf_va_name = ((char_u **)fp->uf_args.ga_data)\n\t\t\t\t\t      [fp->uf_args.ga_len - 1];\n\t--fp->uf_args.ga_len;\n\tp = ((char_u **)argtypes->ga_data)[len];\n\tif (p == NULL)\n\t    // TODO: get type from default value\n\t    fp->uf_va_type = &t_list_any;\n\telse\n\t{\n\t    fp->uf_va_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t    if (fp->uf_va_type != NULL && fp->uf_va_type->tt_type != VAR_LIST)\n\t    {\n\t\tsemsg(_(e_variable_arguments_type_must_be_list_str),\n\t\t\t\t\t  ((char_u **)argtypes->ga_data)[len]);\n\t\treturn FAIL;\n\t    }\n\t}\n\tif (fp->uf_va_type == NULL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static int\nparse_return_type(ufunc_T *fp, char_u *ret_type)\n{\n    if (ret_type == NULL)\n\tfp->uf_ret_type = &t_void;\n    else\n    {\n\tchar_u *p = ret_type;\n\n\tfp->uf_ret_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\tif (fp->uf_ret_type == NULL)\n\t{\n\t    fp->uf_ret_type = &t_void;\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Register function \"fp\" as using \"current_funccal\" as its scope.\n */\n    static int\nregister_closure(ufunc_T *fp)\n{\n    if (fp->uf_scoped == current_funccal)\n\t// no change\n\treturn OK;\n    funccal_unref(fp->uf_scoped, fp, FALSE);\n    fp->uf_scoped = current_funccal;\n    current_funccal->fc_refcount++;\n\n    if (ga_grow(&current_funccal->fc_funcs, 1) == FAIL)\n\treturn FAIL;\n    ((ufunc_T **)current_funccal->fc_funcs.ga_data)\n\t[current_funccal->fc_funcs.ga_len++] = fp;\n    return OK;\n}\n\n    static void\nset_ufunc_name(ufunc_T *fp, char_u *name)\n{\n    // Add a type cast to avoid a warning for an overflow, the uf_name[] array\n    // actually extends beyond the struct.\n    STRCPY((void *)fp->uf_name, name);\n\n    if (name[0] == K_SPECIAL)\n    {\n\tfp->uf_name_exp = alloc(STRLEN(name) + 3);\n\tif (fp->uf_name_exp != NULL)\n\t{\n\t    STRCPY(fp->uf_name_exp, \"<SNR>\");\n\t    STRCAT(fp->uf_name_exp, fp->uf_name + 3);\n\t}\n    }\n}\n\n/*\n * Get a name for a lambda.  Returned in static memory.\n */\n    char_u *\nget_lambda_name(void)\n{\n    static char_u   name[30];\n    static int\t    lambda_no = 0;\n\n    sprintf((char*)name, \"<lambda>%d\", ++lambda_no);\n    return name;\n}\n\n#if defined(FEAT_LUA) || defined(PROTO)\n/*\n * Registers a native C callback which can be called from Vim script.\n * Returns the name of the Vim script function.\n */\n    char_u *\nregister_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state)\n{\n    char_u\t*name = get_lambda_name();\n    ufunc_T\t*fp;\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (fp == NULL)\n\treturn NULL;\n\n    fp->uf_def_status = UF_NOT_COMPILED;\n    fp->uf_refcount = 1;\n    fp->uf_varargs = TRUE;\n    fp->uf_flags = FC_CFUNC | FC_LAMBDA;\n    fp->uf_calls = 0;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_cb = cb;\n    fp->uf_cb_free = cb_free;\n    fp->uf_cb_state = state;\n\n    set_ufunc_name(fp, name);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    return name;\n}\n#endif\n\n/*\n * Skip over \"->\" or \"=>\" after the arguments of a lambda.\n * If \": type\" is found make \"ret_type\" point to \"type\".\n * If \"white_error\" is not NULL check for correct use of white space and set\n * \"white_error\" to TRUE if there is an error.\n * Return NULL if no valid arrow found.\n */\n    static char_u *\nskip_arrow(\n\tchar_u\t*start,\n\tint\tequal_arrow,\n\tchar_u\t**ret_type,\n\tint\t*white_error)\n{\n    char_u  *s = start;\n    char_u  *bef = start - 2; // \"start\" points to > of ->\n\n    if (equal_arrow)\n    {\n\tif (*s == ':')\n\t{\n\t    if (white_error != NULL && !VIM_ISWHITE(s[1]))\n\t    {\n\t\t*white_error = TRUE;\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", s);\n\t\treturn NULL;\n\t    }\n\t    s = skipwhite(s + 1);\n\t    *ret_type = s;\n\t    s = skip_type(s, TRUE);\n\t    if (s == *ret_type)\n\t    {\n\t\temsg(_(e_missing_return_type));\n\t\treturn NULL;\n\t    }\n\t}\n\tbef = s;\n\ts = skipwhite(s);\n\tif (*s != '=')\n\t    return NULL;\n\t++s;\n    }\n    if (*s != '>')\n\treturn NULL;\n    if (white_error != NULL && ((!VIM_ISWHITE(*bef) && *bef != '{')\n\t\t|| !IS_WHITE_OR_NUL(s[1])))\n    {\n\t*white_error = TRUE;\n\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t       equal_arrow ? \"=>\" : \"->\", bef);\n\treturn NULL;\n    }\n    return skipwhite(s + 1);\n}\n\n/*\n * Check if \"*cmd\" points to a function command and if so advance \"*cmd\" and\n * return TRUE.\n * Otherwise return FALSE;\n * Do not consider \"function(\" to be a command.\n */\n    static int\nis_function_cmd(char_u **cmd)\n{\n    char_u *p = *cmd;\n\n    if (checkforcmd(&p, \"function\", 2))\n    {\n\tif (*p == '(')\n\t    return FALSE;\n\t*cmd = p;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Called when defining a function: The context may be needed for script\n * variables declared in a block that is visible now but not when the function\n * is compiled or called later.\n */\n    static void\nfunction_using_block_scopes(ufunc_T *fp, cstack_T *cstack)\n{\n    if (cstack != NULL && cstack->cs_idx >= 0)\n    {\n\tint\t    count = cstack->cs_idx + 1;\n\tint\t    i;\n\n\tfp->uf_block_ids = ALLOC_MULT(int, count);\n\tif (fp->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(fp->uf_block_ids, cstack->cs_block_id,\n\t\t\t\t\t\t\t  sizeof(int) * count);\n\t    fp->uf_block_depth = count;\n\t}\n\n\t// Set flag in each block to indicate a function was defined.  This\n\t// is used to keep the variable when leaving the block, see\n\t// hide_script_var().\n\tfor (i = 0; i <= cstack->cs_idx; ++i)\n\t    cstack->cs_flags[i] |= CSF_FUNC_DEF;\n    }\n}\n\n/*\n * Read the body of a function, put every line in \"newlines\".\n * This stops at \"}\", \"endfunction\" or \"enddef\".\n * \"newlines\" must already have been initialized.\n * \"eap->cmdidx\" is CMD_function, CMD_def or CMD_block;\n */\n    static int\nget_function_body(\n\texarg_T\t    *eap,\n\tgarray_T    *newlines,\n\tchar_u\t    *line_arg_in,\n\tchar_u\t    **line_to_free)\n{\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n    linenr_T\tsourcing_lnum_off;\n    int\t\tsaved_wait_return = need_wait_return;\n    char_u\t*line_arg = line_arg_in;\n    int\t\tvim9_function = eap->cmdidx == CMD_def\n\t\t\t\t\t\t   || eap->cmdidx == CMD_block;\n#define MAX_FUNC_NESTING 50\n    char\tnesting_def[MAX_FUNC_NESTING];\n    char\tnesting_inline[MAX_FUNC_NESTING];\n    int\t\tnesting = 0;\n    getline_opt_T getline_options;\n    int\t\tindent = 2;\n    char_u\t*skip_until = NULL;\n    int\t\tret = FAIL;\n    int\t\tis_heredoc = FALSE;\n    int\t\theredoc_concat_len = 0;\n    garray_T\theredoc_ga;\n    char_u\t*heredoc_trimmed = NULL;\n\n    ga_init2(&heredoc_ga, 1, 500);\n\n    // Detect having skipped over comment lines to find the return\n    // type.  Add NULL lines to keep the line count correct.\n    sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n    if (SOURCING_LNUM < sourcing_lnum_off)\n    {\n\tsourcing_lnum_off -= SOURCING_LNUM;\n\tif (ga_grow(newlines, sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n    }\n\n    nesting_def[0] = vim9_function;\n    nesting_inline[0] = eap->cmdidx == CMD_block;\n    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n    for (;;)\n    {\n\tchar_u\t*theline;\n\tchar_u\t*p;\n\tchar_u\t*arg;\n\n\tif (KeyTyped)\n\t{\n\t    msg_scroll = TRUE;\n\t    saved_wait_return = FALSE;\n\t}\n\tneed_wait_return = FALSE;\n\n\tif (line_arg != NULL)\n\t{\n\t    // Use eap->arg, split up in parts by line breaks.\n\t    theline = line_arg;\n\t    p = vim_strchr(theline, '\\n');\n\t    if (p == NULL)\n\t\tline_arg += STRLEN(line_arg);\n\t    else\n\t    {\n\t\t*p = NUL;\n\t\tline_arg = p + 1;\n\t    }\n\t}\n\telse\n\t{\n\t    theline = get_function_line(eap, line_to_free, indent,\n\t\t\t\t\t\t\t      getline_options);\n\t}\n\tif (KeyTyped)\n\t    lines_left = Rows - 1;\n\tif (theline == NULL)\n\t{\n\t    // Use the start of the function for the line number.\n\t    SOURCING_LNUM = sourcing_lnum_top;\n\t    if (skip_until != NULL)\n\t\tsemsg(_(e_missing_heredoc_end_marker_str), skip_until);\n\t    else if (nesting_inline[nesting])\n\t\temsg(_(e_missing_end_block));\n\t    else if (eap->cmdidx == CMD_def)\n\t\temsg(_(e_missing_enddef));\n\t    else\n\t\temsg(_(e_missing_endfunction));\n\t    goto theend;\n\t}\n\n\t// Detect line continuation: SOURCING_LNUM increased more than one.\n\tsourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n\tif (SOURCING_LNUM < sourcing_lnum_off)\n\t    sourcing_lnum_off -= SOURCING_LNUM;\n\telse\n\t    sourcing_lnum_off = 0;\n\n\tif (skip_until != NULL)\n\t{\n\t    // Don't check for \":endfunc\"/\":enddef\" between\n\t    // * \":append\" and \".\"\n\t    // * \":python <<EOF\" and \"EOF\"\n\t    // * \":let {var-name} =<< [trim] {marker}\" and \"{marker}\"\n\t    if (heredoc_trimmed == NULL\n\t\t    || (is_heredoc && skipwhite(theline) == theline)\n\t\t    || STRNCMP(theline, heredoc_trimmed,\n\t\t\t\t\t\t STRLEN(heredoc_trimmed)) == 0)\n\t    {\n\t\tif (heredoc_trimmed == NULL)\n\t\t    p = theline;\n\t\telse if (is_heredoc)\n\t\t    p = skipwhite(theline) == theline\n\t\t\t\t ? theline : theline + STRLEN(heredoc_trimmed);\n\t\telse\n\t\t    p = theline + STRLEN(heredoc_trimmed);\n\t\tif (STRCMP(p, skip_until) == 0)\n\t\t{\n\t\t    VIM_CLEAR(skip_until);\n\t\t    VIM_CLEAR(heredoc_trimmed);\n\t\t    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n\t\t    is_heredoc = FALSE;\n\n\t\t    if (heredoc_concat_len > 0)\n\t\t    {\n\t\t\t// Replace the starting line with all the concatenated\n\t\t\t// lines.\n\t\t\tga_concat(&heredoc_ga, theline);\n\t\t\tvim_free(((char_u **)(newlines->ga_data))[\n\t\t\t\t\t\t      heredoc_concat_len - 1]);\n\t\t\t((char_u **)(newlines->ga_data))[\n\t\t\t\t  heredoc_concat_len - 1] = heredoc_ga.ga_data;\n\t\t\tga_init(&heredoc_ga);\n\t\t\theredoc_concat_len = 0;\n\t\t\ttheline += STRLEN(theline);  // skip the \"EOF\"\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    int\t    c;\n\t    char_u  *end;\n\n\t    // skip ':' and blanks\n\t    for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)\n\t\t;\n\n\t    // Check for \"endfunction\", \"enddef\" or \"}\".\n\t    // When a \":\" follows it must be a dict key; \"enddef: value,\"\n\t    if (nesting_inline[nesting]\n\t\t    ? *p == '}'\n\t\t    : (checkforcmd(&p, nesting_def[nesting]\n\t\t\t\t\t\t? \"enddef\" : \"endfunction\", 4)\n\t\t\t&& *p != ':'))\n\t    {\n\t\tif (nesting-- == 0)\n\t\t{\n\t\t    char_u *nextcmd = NULL;\n\n\t\t    if (*p == '|' || *p == '}')\n\t\t\tnextcmd = p + 1;\n\t\t    else if (line_arg != NULL && *skipwhite(line_arg) != NUL)\n\t\t\tnextcmd = line_arg;\n\t\t    else if (*p != NUL && *p != (vim9_function ? '#' : '\"')\n\t\t\t\t\t   && (vim9_function || p_verbose > 0))\n\t\t    {\n\t\t\tSOURCING_LNUM = sourcing_lnum_top\n\t\t\t\t\t\t\t+ newlines->ga_len + 1;\n\t\t\tif (eap->cmdidx == CMD_def)\n\t\t\t    semsg(_(e_text_found_after_str_str), \"enddef\", p);\n\t\t\telse\n\t\t\t    give_warning2((char_u *)\n\t\t\t\t   _(\"W22: Text found after :endfunction: %s\"),\n\t\t\t\t   p, TRUE);\n\t\t    }\n\t\t    if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)\n\t\t    {\n\t\t\t// Another command follows. If the line came from \"eap\"\n\t\t\t// we can simply point into it, otherwise we need to\n\t\t\t// change \"eap->cmdlinep\".\n\t\t\teap->nextcmd = nextcmd;\n\t\t\tif (*line_to_free != NULL\n\t\t\t\t\t    && *eap->cmdlinep != *line_to_free)\n\t\t\t{\n\t\t\t    vim_free(*eap->cmdlinep);\n\t\t\t    *eap->cmdlinep = *line_to_free;\n\t\t\t    *line_to_free = NULL;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\n\t    // Check for mismatched \"endfunc\" or \"enddef\".\n\t    // We don't check for \"def\" inside \"func\" thus we also can't check\n\t    // for \"enddef\".\n\t    // We continue to find the end of the function, although we might\n\t    // not find it.\n\t    else if (nesting_def[nesting])\n\t    {\n\t\tif (checkforcmd(&p, \"endfunction\", 4) && *p != ':')\n\t\t    emsg(_(e_mismatched_endfunction));\n\t    }\n\t    else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))\n\t\temsg(_(e_mismatched_enddef));\n\n\t    // Increase indent inside \"if\", \"while\", \"for\" and \"try\", decrease\n\t    // at \"end\".\n\t    if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))\n\t\tindent -= 2;\n\t    else if (STRNCMP(p, \"if\", 2) == 0\n\t\t    || STRNCMP(p, \"wh\", 2) == 0\n\t\t    || STRNCMP(p, \"for\", 3) == 0\n\t\t    || STRNCMP(p, \"try\", 3) == 0)\n\t\tindent += 2;\n\n\t    // Check for defining a function inside this function.\n\t    // Only recognize \"def\" inside \"def\", not inside \"function\",\n\t    // For backwards compatibility, see Test_function_python().\n\t    c = *p;\n\t    if (is_function_cmd(&p)\n\t\t    || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))\n\t    {\n\t\tif (*p == '!')\n\t\t    p = skipwhite(p + 1);\n\t\tp += eval_fname_script(p);\n\t\tvim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,\n\t\t\t\t\t\t\t\t  NULL, NULL));\n\t\tif (*skipwhite(p) == '(')\n\t\t{\n\t\t    if (nesting == MAX_FUNC_NESTING - 1)\n\t\t\temsg(_(e_function_nesting_too_deep));\n\t\t    else\n\t\t    {\n\t\t\t++nesting;\n\t\t\tnesting_def[nesting] = (c == 'd');\n\t\t\tnesting_inline[nesting] = FALSE;\n\t\t\tindent += 2;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (nesting_def[nesting] ? *p != '#' : *p != '\"')\n\t    {\n\t\t// Not a comment line: check for nested inline function.\n\t\tend = p + STRLEN(p) - 1;\n\t\twhile (end > p && VIM_ISWHITE(*end))\n\t\t    --end;\n\t\tif (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))\n\t\t{\n\t\t    int\t    is_block;\n\n\t\t    // check for trailing \"=> {\": start of an inline function\n\t\t    --end;\n\t\t    while (end > p && VIM_ISWHITE(*end))\n\t\t\t--end;\n\t\t    is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';\n\t\t    if (!is_block)\n\t\t    {\n\t\t\tchar_u *s = p;\n\n\t\t\t// check for line starting with \"au\" for :autocmd or\n\t\t\t// \"com\" for :command, these can use a {} block\n\t\t\tis_block = checkforcmd_noparen(&s, \"autocmd\", 2)\n\t\t\t\t      || checkforcmd_noparen(&s, \"command\", 3);\n\t\t    }\n\n\t\t    if (is_block)\n\t\t    {\n\t\t\tif (nesting == MAX_FUNC_NESTING - 1)\n\t\t\t    emsg(_(e_function_nesting_too_deep));\n\t\t\telse\n\t\t\t{\n\t\t\t    ++nesting;\n\t\t\t    nesting_def[nesting] = TRUE;\n\t\t\t    nesting_inline[nesting] = TRUE;\n\t\t\t    indent += 2;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Check for \":append\", \":change\", \":insert\".  Not for :def.\n\t    p = skip_range(p, FALSE, NULL);\n\t    if (!vim9_function\n\t\t&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))\n\t\t    || (p[0] == 'c'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'\n\t\t\t\t\t&& (STRNCMP(&p[3], \"nge\", 3) != 0\n\t\t\t\t\t    || !ASCII_ISALPHA(p[6])))))))\n\t\t    || (p[0] == 'i'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2])\n\t\t\t\t    || (p[2] == 's'\n\t\t\t\t\t&& (!ASCII_ISALPHA(p[3])\n\t\t\t\t\t\t|| p[3] == 'e'))))))))\n\t\tskip_until = vim_strsave((char_u *)\".\");\n\n\t    // Check for \":python <<EOF\", \":tcl <<EOF\", etc.\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (arg[0] == '<' && arg[1] =='<'\n\t\t    && ((p[0] == 'p' && p[1] == 'y'\n\t\t\t\t    && (!ASCII_ISALNUM(p[2]) || p[2] == 't'\n\t\t\t\t\t|| ((p[2] == '3' || p[2] == 'x')\n\t\t\t\t\t\t   && !ASCII_ISALPHA(p[3]))))\n\t\t\t|| (p[0] == 'p' && p[1] == 'e'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))\n\t\t\t|| (p[0] == 't' && p[1] == 'c'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))\n\t\t\t|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'\n\t\t\t\t    && !ASCII_ISALPHA(p[3]))\n\t\t\t|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'\n\t\t\t\t    && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))\n\t\t\t|| (p[0] == 'm' && p[1] == 'z'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))\n\t\t\t))\n\t    {\n\t\t// \":python <<\" continues until a dot, like \":append\"\n\t\tp = skipwhite(arg + 2);\n\t\tif (STRNCMP(p, \"trim\", 4) == 0)\n\t\t{\n\t\t    // Ignore leading white space.\n\t\t    p = skipwhite(p + 4);\n\t\t    heredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t}\n\t\tif (*p == NUL)\n\t\t    skip_until = vim_strsave((char_u *)\".\");\n\t\telse\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\tgetline_options = GETLINE_NONE;\n\t\tis_heredoc = TRUE;\n\t\tif (eap->cmdidx == CMD_def)\n\t\t    heredoc_concat_len = newlines->ga_len + 1;\n\t    }\n\n\t    // Check for \":cmd v =<< [trim] EOF\"\n\t    //       and \":cmd [a, b] =<< [trim] EOF\"\n\t    //       and \"lines =<< [trim] EOF\" for Vim9\n\t    // Where \"cmd\" can be \"let\", \"var\", \"final\" or \"const\".\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (*arg == '[')\n\t\targ = vim_strchr(arg, ']');\n\t    if (arg != NULL)\n\t    {\n\t\tint found = (eap->cmdidx == CMD_def && arg[0] == '='\n\t\t\t\t\t     && arg[1] == '<' && arg[2] =='<');\n\n\t\tif (!found)\n\t\t    // skip over the argument after \"cmd\"\n\t\t    arg = skipwhite(skiptowhite(arg));\n\t\tif (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'\n\t\t\t&& (checkforcmd(&p, \"let\", 2)\n\t\t\t    || checkforcmd(&p, \"var\", 3)\n\t\t\t    || checkforcmd(&p, \"final\", 5)\n\t\t\t    || checkforcmd(&p, \"const\", 5))))\n\t\t{\n\t\t    p = skipwhite(arg + 3);\n\t\t    if (STRNCMP(p, \"trim\", 4) == 0)\n\t\t    {\n\t\t\t// Ignore leading white space.\n\t\t\tp = skipwhite(p + 4);\n\t\t\theredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t    }\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\t    getline_options = GETLINE_NONE;\n\t\t    is_heredoc = TRUE;\n\t\t}\n\t    }\n\t}\n\n\t// Add the line to the function.\n\tif (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\n\tif (heredoc_concat_len > 0)\n\t{\n\t    // For a :def function \"python << EOF\" concatenates all the lines,\n\t    // to be used for the instruction later.\n\t    ga_concat(&heredoc_ga, theline);\n\t    ga_concat(&heredoc_ga, (char_u *)\"\\n\");\n\t    p = vim_strsave((char_u *)\"\");\n\t}\n\telse\n\t{\n\t    // Copy the line to newly allocated memory.  get_one_sourceline()\n\t    // allocates 250 bytes per line, this saves 80% on average.  The\n\t    // cost is an extra alloc/free.\n\t    p = vim_strsave(theline);\n\t}\n\tif (p == NULL)\n\t    goto theend;\n\t((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;\n\n\t// Add NULL lines for continuation lines, so that the line count is\n\t// equal to the index in the growarray.\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n\n\t// Check for end of eap->arg.\n\tif (line_arg != NULL && *line_arg == NUL)\n\t    line_arg = NULL;\n    }\n\n    // Return OK when no error was detected.\n    if (!did_emsg)\n\tret = OK;\n\ntheend:\n    vim_free(skip_until);\n    vim_free(heredoc_trimmed);\n    vim_free(heredoc_ga.ga_data);\n    need_wait_return |= saved_wait_return;\n    return ret;\n}\n\n/*\n * Handle the body of a lambda.  *arg points to the \"{\", process statements\n * until the matching \"}\".\n * When not evaluating \"newargs\" is NULL.\n * When successful \"rettv\" is set to a funcref.\n */\n    static int\nlambda_function_body(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tevalarg_T   *evalarg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    varargs,\n\tgarray_T    *default_args,\n\tchar_u\t    *ret_type)\n{\n    int\t\tevaluate = (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\t*gap = &evalarg->eval_ga;\n    garray_T\t*freegap = &evalarg->eval_freega;\n    ufunc_T\t*ufunc = NULL;\n    exarg_T\teap;\n    garray_T\tnewlines;\n    char_u\t*cmdline = NULL;\n    int\t\tret = FAIL;\n    char_u\t*line_to_free = NULL;\n    partial_T\t*pt;\n    char_u\t*name;\n    int\t\tlnum_save = -1;\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n\n    if (!ends_excmd2(*arg, skipwhite(*arg + 1)))\n    {\n\tsemsg(_(e_trailing_characters_str), *arg + 1);\n\treturn FAIL;\n    }\n\n    CLEAR_FIELD(eap);\n    eap.cmdidx = CMD_block;\n    eap.forceit = FALSE;\n    eap.cmdlinep = &cmdline;\n    eap.skip = !evaluate;\n    if (evalarg->eval_cctx != NULL)\n\tfill_exarg_from_cctx(&eap, evalarg->eval_cctx);\n    else\n    {\n\teap.getline = evalarg->eval_getline;\n\teap.cookie = evalarg->eval_cookie;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n    if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL)\n    {\n\tif (cmdline != line_to_free)\n\t    vim_free(cmdline);\n\tgoto erret;\n    }\n\n    // When inside a lambda must add the function lines to evalarg.eval_ga.\n    evalarg->eval_break_count += newlines.ga_len;\n    if (gap->ga_itemsize > 0)\n    {\n\tint\tidx;\n\tchar_u\t*last;\n\tsize_t  plen;\n\tchar_u  *pnl;\n\n\tfor (idx = 0; idx < newlines.ga_len; ++idx)\n\t{\n\t    char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);\n\n\t    if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t\tgoto erret;\n\n\t    // Going to concatenate the lines after parsing.  For an empty or\n\t    // comment line use an empty string.\n\t    // Insert NL characters at the start of each line, the string will\n\t    // be split again later in .get_lambda_tv().\n\t    if (*p == NUL || vim9_comment_start(p))\n\t\tp = (char_u *)\"\";\n\t    plen = STRLEN(p);\n\t    pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\t    if (pnl != NULL)\n\t\tmch_memmove(pnl + 1, p, plen + 1);\n\t    ((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t    ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n\t}\n\tif (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t    goto erret;\n\tif (eap.nextcmd != NULL)\n\t    // more is following after the \"}\", which was skipped\n\t    last = cmdline;\n\telse\n\t    // nothing is following the \"}\"\n\t    last = (char_u *)\"}\";\n\tplen = STRLEN(last);\n\tpnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\tif (pnl != NULL)\n\t    mch_memmove(pnl + 1, last, plen + 1);\n\t((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n    }\n\n    if (eap.nextcmd != NULL)\n    {\n\tgarray_T *tfgap = &evalarg->eval_tofree_ga;\n\n\t// Something comes after the \"}\".\n\t*arg = eap.nextcmd;\n\n\t// \"arg\" points into cmdline, need to keep the line and free it later.\n\tif (ga_grow(tfgap, 1) == OK)\n\t{\n\t    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;\n\t    evalarg->eval_using_cmdline = TRUE;\n\t    if (cmdline == line_to_free)\n\t\tline_to_free = NULL;\n\t}\n    }\n    else\n\t*arg = (char_u *)\"\";\n\n    if (!evaluate)\n    {\n\tret = OK;\n\tgoto erret;\n    }\n\n    name = get_lambda_name();\n    ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (ufunc == NULL)\n\tgoto erret;\n    set_ufunc_name(ufunc, name);\n    if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)\n\tgoto erret;\n    ufunc->uf_flags = FC_LAMBDA;\n    ufunc->uf_refcount = 1;\n    ufunc->uf_args = *newargs;\n    newargs->ga_data = NULL;\n    ufunc->uf_def_args = *default_args;\n    default_args->ga_data = NULL;\n    ufunc->uf_func_type = &t_func_any;\n\n    // error messages are for the first function line\n    lnum_save = SOURCING_LNUM;\n    SOURCING_LNUM = sourcing_lnum_top;\n\n    // parse argument types\n    if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)\n    {\n\tSOURCING_LNUM = lnum_save;\n\tgoto erret;\n    }\n\n    // parse the return type, if any\n    if (parse_return_type(ufunc, ret_type) == FAIL)\n\tgoto erret;\n\n    pt = ALLOC_CLEAR_ONE(partial_T);\n    if (pt == NULL)\n\tgoto erret;\n    pt->pt_func = ufunc;\n    pt->pt_refcount = 1;\n\n    ufunc->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if (sandbox)\n\tufunc->uf_flags |= FC_SANDBOX;\n    if (!ASCII_ISUPPER(*ufunc->uf_name))\n\tufunc->uf_flags |= FC_VIM9;\n    ufunc->uf_script_ctx = current_sctx;\n    ufunc->uf_script_ctx_version = current_sctx.sc_version;\n    ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    set_function_type(ufunc);\n\n    function_using_block_scopes(ufunc, evalarg->eval_cstack);\n\n    rettv->vval.v_partial = pt;\n    rettv->v_type = VAR_PARTIAL;\n    ufunc = NULL;\n    ret = OK;\n\nerret:\n    if (lnum_save >= 0)\n\tSOURCING_LNUM = lnum_save;\n    vim_free(line_to_free);\n    ga_clear_strings(&newlines);\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    ga_clear_strings(default_args);\n    if (ufunc != NULL)\n    {\n\tfunc_clear(ufunc, TRUE);\n\tfunc_free(ufunc, TRUE);\n    }\n    return ret;\n}\n\n/*\n * Parse a lambda expression and get a Funcref from \"*arg\" into \"rettv\".\n * \"arg\" points to the { in \"{arg -> expr}\" or the ( in \"(arg) => expr\"\n * When \"types_optional\" is TRUE optionally take argument types.\n * Return OK or FAIL.  Returns NOTDONE for dict or {expr}.\n */\n    int\nget_lambda_tv(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg)\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\tnewargs;\n    garray_T\tnewlines;\n    garray_T\t*pnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    ufunc_T\t*fp = NULL;\n    partial_T   *pt = NULL;\n    int\t\tvarargs;\n    char_u\t*ret_type = NULL;\n    int\t\tret;\n    char_u\t*s;\n    char_u\t*start, *end;\n    int\t\t*old_eval_lavars = eval_lavars_used;\n    int\t\teval_lavars = FALSE;\n    char_u\t*tofree1 = NULL;\n    char_u\t*tofree2 = NULL;\n    int\t\tequal_arrow = **arg == '(';\n    int\t\twhite_error = FALSE;\n    int\t\tcalled_emsg_start = called_emsg;\n\n    if (equal_arrow && !in_vim9script())\n\treturn NOTDONE;\n\n    ga_init(&newargs);\n    ga_init(&newlines);\n\n    // First, check if this is really a lambda expression. \"->\" or \"=>\" must\n    // be found after the arguments.\n    s = *arg + 1;\n    ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\tNULL, &default_args, TRUE, NULL, NULL);\n    if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\treturn called_emsg == called_emsg_start ? NOTDONE : FAIL;\n    }\n\n    // Parse the arguments for real.\n    if (evaluate)\n\tpnewargs = &newargs;\n    else\n\tpnewargs = NULL;\n    *arg += 1;\n    ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\t    &varargs, &default_args,\n\t\t\t\t\t    FALSE, NULL, NULL);\n    if (ret == FAIL\n\t\t  || (s = skip_arrow(*arg, equal_arrow, &ret_type,\n\t\tequal_arrow || in_vim9script() ? &white_error : NULL)) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\tga_clear_strings(&newargs);\n\treturn white_error ? FAIL : NOTDONE;\n    }\n    *arg = s;\n\n    // Skipping over linebreaks may make \"ret_type\" invalid, make a copy.\n    if (ret_type != NULL)\n    {\n\tret_type = vim_strsave(ret_type);\n\ttofree2 = ret_type;\n    }\n\n    // Set up a flag for checking local variables and arguments.\n    if (evaluate)\n\teval_lavars_used = &eval_lavars;\n\n    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\n    // Recognize \"{\" as the start of a function body.\n    if (equal_arrow && **arg == '{')\n    {\n\tif (evalarg == NULL)\n\t    // cannot happen?\n\t    goto theend;\n\tif (lambda_function_body(arg, rettv, evalarg, pnewargs,\n\t\t\t   types_optional ? &argtypes : NULL, varargs,\n\t\t\t   &default_args, ret_type) == FAIL)\n\t    goto errret;\n\tgoto theend;\n    }\n    if (default_args.ga_len > 0)\n    {\n\temsg(_(e_cannot_use_default_values_in_lambda));\n\tgoto errret;\n    }\n\n    // Get the start and the end of the expression.\n    start = *arg;\n    ret = skip_expr_concatenate(arg, &start, &end, evalarg);\n    if (ret == FAIL)\n\tgoto errret;\n    if (evalarg != NULL)\n    {\n\t// avoid that the expression gets freed when another line break follows\n\ttofree1 = evalarg->eval_tofree;\n\tevalarg->eval_tofree = NULL;\n    }\n\n    if (!equal_arrow)\n    {\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != '}')\n\t{\n\t    semsg(_(e_expected_right_curly_str), *arg);\n\t    goto errret;\n\t}\n\t++*arg;\n    }\n\n    if (evaluate)\n    {\n\tint\t    len;\n\tint\t    flags = FC_LAMBDA;\n\tchar_u\t    *p;\n\tchar_u\t    *line_end;\n\tchar_u\t    *name = get_lambda_name();\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto errret;\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\tpt = ALLOC_CLEAR_ONE(partial_T);\n\tif (pt == NULL)\n\t    goto errret;\n\n\tga_init2(&newlines, (int)sizeof(char_u *), 1);\n\tif (ga_grow(&newlines, 1) == FAIL)\n\t    goto errret;\n\n\t// If there are line breaks, we need to split up the string.\n\tline_end = vim_strchr(start, '\\n');\n\tif (line_end == NULL || line_end > end)\n\t    line_end = end;\n\n\t// Add \"return \" before the expression (or the first line).\n\tlen = 7 + (int)(line_end - start) + 1;\n\tp = alloc(len);\n\tif (p == NULL)\n\t    goto errret;\n\t((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;\n\tSTRCPY(p, \"return \");\n\tvim_strncpy(p + 7, start, line_end - start);\n\n\tif (line_end != end)\n\t{\n\t    // Add more lines, split by line breaks.  Thus is used when a\n\t    // lambda with { cmds } is encountered.\n\t    while (*line_end == '\\n')\n\t    {\n\t\tif (ga_grow(&newlines, 1) == FAIL)\n\t\t    goto errret;\n\t\tstart = line_end + 1;\n\t\tline_end = vim_strchr(start, '\\n');\n\t\tif (line_end == NULL)\n\t\t    line_end = end;\n\t\t((char_u **)(newlines.ga_data))[newlines.ga_len++] =\n\t\t\t\t\t vim_strnsave(start, line_end - start);\n\t    }\n\t}\n\n\tif (strstr((char *)p + 7, \"a:\") == NULL)\n\t    // No a: variables are used for sure.\n\t    flags |= FC_NOARGS;\n\n\tfp->uf_refcount = 1;\n\tset_ufunc_name(fp, name);\n\tfp->uf_args = newargs;\n\tga_init(&fp->uf_def_args);\n\tif (types_optional)\n\t{\n\t    if (parse_argument_types(fp, &argtypes,\n\t\t\t\t\t   in_vim9script() && varargs) == FAIL)\n\t\tgoto errret;\n\t    if (ret_type != NULL)\n\t    {\n\t\tfp->uf_ret_type = parse_type(&ret_type,\n\t\t\t\t\t\t      &fp->uf_type_list, TRUE);\n\t\tif (fp->uf_ret_type == NULL)\n\t\t    goto errret;\n\t    }\n\t    else\n\t\tfp->uf_ret_type = &t_unknown;\n\t}\n\n\tfp->uf_lines = newlines;\n\tif (current_funccal != NULL && eval_lavars)\n\t{\n\t    flags |= FC_CLOSURE;\n\t    if (register_closure(fp) == FAIL)\n\t\tgoto errret;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (prof_def_func())\n\t    func_do_profile(fp);\n#endif\n\tif (sandbox)\n\t    flags |= FC_SANDBOX;\n\t// In legacy script a lambda can be called with more args than\n\t// uf_args.ga_len.  In Vim9 script \"...name\" has to be used.\n\tfp->uf_varargs = !in_vim9script() || varargs;\n\tfp->uf_flags = flags;\n\tfp->uf_calls = 0;\n\tfp->uf_script_ctx = current_sctx;\n\tfp->uf_script_ctx.sc_lnum += SOURCING_LNUM - newlines.ga_len + 1;\n\n\tfunction_using_block_scopes(fp, evalarg->eval_cstack);\n\n\tpt->pt_func = fp;\n\tpt->pt_refcount = 1;\n\trettv->vval.v_partial = pt;\n\trettv->v_type = VAR_PARTIAL;\n\n\thash_add(&func_hashtab, UF2HIKEY(fp));\n    }\n\ntheend:\n    eval_lavars_used = old_eval_lavars;\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    if (types_optional)\n\tga_clear_strings(&argtypes);\n\n    return OK;\n\nerrret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&newlines);\n    ga_clear_strings(&default_args);\n    if (types_optional)\n    {\n\tga_clear_strings(&argtypes);\n\tif (fp != NULL)\n\t    vim_free(fp->uf_arg_types);\n    }\n    vim_free(fp);\n    vim_free(pt);\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    eval_lavars_used = old_eval_lavars;\n    return FAIL;\n}\n\n/*\n * Check if \"name\" is a variable of type VAR_FUNC.  If so, return the function\n * name it contains, otherwise return \"name\".\n * If \"partialp\" is not NULL, and \"name\" is of type VAR_PARTIAL also set\n * \"partialp\".\n * If \"type\" is not NULL and a Vim9 script-local variable is found look up the\n * type of the variable.\n * If \"found_var\" is not NULL and a variable was found set it to TRUE.\n */\n    char_u *\nderef_func_name(\n\tchar_u\t    *name,\n\tint\t    *lenp,\n\tpartial_T   **partialp,\n\ttype_T\t    **type,\n\tint\t    no_autoload,\n\tint\t    *found_var)\n{\n    dictitem_T\t*v;\n    typval_T\t*tv = NULL;\n    int\t\tcc;\n    char_u\t*s = NULL;\n    hashtab_T\t*ht;\n    int\t\tdid_type = FALSE;\n\n    if (partialp != NULL)\n\t*partialp = NULL;\n\n    cc = name[*lenp];\n    name[*lenp] = NUL;\n\n    v = find_var_also_in_script(name, &ht, no_autoload);\n    name[*lenp] = cc;\n    if (v != NULL)\n    {\n\ttv = &v->di_tv;\n    }\n    else if (in_vim9script() || STRNCMP(name, \"s:\", 2) == 0)\n    {\n\timported_T  *import;\n\tchar_u\t    *p = name;\n\tint\t    len = *lenp;\n\n\tif (STRNCMP(name, \"s:\", 2) == 0)\n\t{\n\t    p = name + 2;\n\t    len -= 2;\n\t}\n\timport = find_imported(p, len, NULL);\n\n\t// imported function from another script\n\tif (import != NULL)\n\t{\n\t    name[len] = NUL;\n\t    semsg(_(e_cannot_use_str_itself_it_is_imported), name);\n\t    name[len] = cc;\n\t    *lenp = 0;\n\t    return (char_u *)\"\";\t// just in case\n\t}\n    }\n\n    if (tv != NULL)\n    {\n\tif (found_var != NULL)\n\t    *found_var = TRUE;\n\tif (tv->v_type == VAR_FUNC)\n\t{\n\t    if (tv->vval.v_string == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    s = tv->vval.v_string;\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (tv->v_type == VAR_PARTIAL)\n\t{\n\t    partial_T *pt = tv->vval.v_partial;\n\n\t    if (pt == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    if (partialp != NULL)\n\t\t*partialp = pt;\n\t    s = partial_name(pt);\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (s != NULL)\n\t{\n\t    if (!did_type && type != NULL && ht == get_script_local_ht())\n\t    {\n\t\tsvar_T  *sv = find_typval_in_script(tv, 0);\n\n\t\tif (sv != NULL)\n\t\t    *type = sv->sv_type;\n\t    }\n\t    return s;\n\t}\n    }\n\n    return name;\n}\n\n/*\n * Give an error message with a function name.  Handle <SNR> things.\n * \"ermsg\" is to be passed without translation, use N_() instead of _().\n */\n    void\nemsg_funcname(char *ermsg, char_u *name)\n{\n    char_u\t*p;\n\n    if (*name == K_SPECIAL)\n\tp = concat_str((char_u *)\"<SNR>\", name + 3);\n    else\n\tp = name;\n    semsg(_(ermsg), p);\n    if (p != name)\n\tvim_free(p);\n}\n\n/*\n * Allocate a variable for the result of a function.\n * Return OK or FAIL.\n */\n    int\nget_func_tv(\n    char_u\t*name,\t\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\n    char_u\t**arg,\t\t// argument, pointing to the '('\n    evalarg_T\t*evalarg,\t// for line continuation\n    funcexe_T\t*funcexe)\t// various values\n{\n    char_u\t*argp;\n    int\t\tret = OK;\n    typval_T\targvars[MAX_FUNC_ARGS + 1];\t// vars for arguments\n    int\t\targcount = 0;\t\t// number of arguments found\n    int\t\tvim9script = in_vim9script();\n\n    /*\n     * Get the arguments.\n     */\n    argp = *arg;\n    while (argcount < MAX_FUNC_ARGS - (funcexe->fe_partial == NULL ? 0\n\t\t\t\t\t       : funcexe->fe_partial->pt_argc))\n    {\n\t// skip the '(' or ',' and possibly line breaks\n\targp = skipwhite_and_linebreak(argp + 1, evalarg);\n\n\tif (*argp == ')' || *argp == ',' || *argp == NUL)\n\t    break;\n\tif (eval1(&argp, &argvars[argcount], evalarg) == FAIL)\n\t{\n\t    ret = FAIL;\n\t    break;\n\t}\n\t++argcount;\n\t// The comma should come right after the argument, but this wasn't\n\t// checked previously, thus only enforce it in Vim9 script.\n\tif (vim9script)\n\t{\n\t    if (*argp != ',' && *skipwhite(argp) == ',')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \",\", argp);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\telse\n\t    argp = skipwhite(argp);\n\tif (*argp != ',')\n\t    break;\n\tif (vim9script && !IS_WHITE_OR_NUL(argp[1]))\n\t{\n\t    semsg(_(e_white_space_required_after_str_str), \",\", argp);\n\t    ret = FAIL;\n\t    break;\n\t}\n    }\n    argp = skipwhite_and_linebreak(argp, evalarg);\n    if (*argp == ')')\n\t++argp;\n    else\n\tret = FAIL;\n\n    if (ret == OK)\n    {\n\tint\ti = 0;\n\tint\tdid_emsg_before = did_emsg;\n\n\tif (get_vim_var_nr(VV_TESTING))\n\t{\n\t    // Prepare for calling test_garbagecollect_now(), need to know\n\t    // what variables are used on the call stack.\n\t    if (funcargs.ga_itemsize == 0)\n\t\tga_init2(&funcargs, (int)sizeof(typval_T *), 50);\n\t    for (i = 0; i < argcount; ++i)\n\t\tif (ga_grow(&funcargs, 1) == OK)\n\t\t    ((typval_T **)funcargs.ga_data)[funcargs.ga_len++] =\n\t\t\t\t\t\t\t\t  &argvars[i];\n\t}\n\n\tret = call_func(name, len, rettv, argcount, argvars, funcexe);\n\tif (in_vim9script() && did_emsg > did_emsg_before)\n\t{\n\t    // An error in a builtin function does not return FAIL, but we do\n\t    // want to abort further processing if an error was given.\n\t    ret = FAIL;\n\t    clear_tv(rettv);\n\t}\n\n\tfuncargs.ga_len -= i;\n    }\n    else if (!aborting())\n    {\n\tif (argcount == MAX_FUNC_ARGS)\n\t    emsg_funcname(e_too_many_arguments_for_function_str_2, name);\n\telse\n\t    emsg_funcname(e_invalid_arguments_for_function_str, name);\n    }\n\n    while (--argcount >= 0)\n\tclear_tv(&argvars[argcount]);\n\n    if (in_vim9script())\n\t*arg = argp;\n    else\n\t*arg = skipwhite(argp);\n    return ret;\n}\n\n/*\n * Return TRUE if \"p\" starts with \"<SID>\" or \"s:\".\n * Only works if eval_fname_script() returned non-zero for \"p\"!\n */\n    static int\neval_fname_sid(char_u *p)\n{\n    return (*p == 's' || TOUPPER_ASC(p[2]) == 'I');\n}\n\n/*\n * In a script change <SID>name() and s:name() to K_SNR 123_name().\n * Change <SNR>123_name() to K_SNR 123_name().\n * Use \"fname_buf[FLEN_FIXED + 1]\" when it fits, otherwise allocate memory\n * (slow).\n */\n    char_u *\nfname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error)\n{\n    int\t\tllen;\n    char_u\t*fname;\n    int\t\ti;\n\n    llen = eval_fname_script(name);\n    if (llen > 0)\n    {\n\tfname_buf[0] = K_SPECIAL;\n\tfname_buf[1] = KS_EXTRA;\n\tfname_buf[2] = (int)KE_SNR;\n\ti = 3;\n\tif (eval_fname_sid(name))\t// \"<SID>\" or \"s:\"\n\t{\n\t    if (current_sctx.sc_sid <= 0)\n\t\t*error = FCERR_SCRIPT;\n\t    else\n\t    {\n\t\tsprintf((char *)fname_buf + 3, \"%ld_\",\n\t\t\t\t\t\t    (long)current_sctx.sc_sid);\n\t\ti = (int)STRLEN(fname_buf);\n\t    }\n\t}\n\tif (i + STRLEN(name + llen) < FLEN_FIXED)\n\t{\n\t    STRCPY(fname_buf + i, name + llen);\n\t    fname = fname_buf;\n\t}\n\telse\n\t{\n\t    fname = alloc(i + STRLEN(name + llen) + 1);\n\t    if (fname == NULL)\n\t\t*error = FCERR_OTHER;\n\t    else\n\t    {\n\t\t*tofree = fname;\n\t\tmch_memmove(fname, fname_buf, (size_t)i);\n\t\tSTRCPY(fname + i, name + llen);\n\t    }\n\t}\n    }\n    else\n\tfname = name;\n    return fname;\n}\n\n/*\n * Find a function \"name\" in script \"sid\".\n */\n    static ufunc_T *\nfind_func_with_sid(char_u *name, int sid)\n{\n    hashitem_T\t*hi;\n    char_u\tbuffer[200];\n\n    buffer[0] = K_SPECIAL;\n    buffer[1] = KS_EXTRA;\n    buffer[2] = (int)KE_SNR;\n    vim_snprintf((char *)buffer + 3, sizeof(buffer) - 3, \"%ld_%s\",\n\t\t\t\t\t\t\t      (long)sid, name);\n    hi = hash_find(&func_hashtab, buffer);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * When \"is_global\" is true don't find script-local or imported functions.\n * Return NULL for unknown function.\n */\n    ufunc_T *\nfind_func_even_dead(char_u *name, int is_global, cctx_T *cctx UNUSED)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*func;\n\n    if (!is_global)\n    {\n\tint\tfind_script_local = in_vim9script() && eval_isnamec1(*name)\n\t\t\t\t\t   && (name[1] != ':' || *name == 's');\n\n\tif (find_script_local)\n\t{\n\t    // Find script-local function before global one.\n\t    func = find_func_with_sid(name[0] == 's' && name[1] == ':'\n\t\t\t\t       ? name + 2 : name, current_sctx.sc_sid);\n\t    if (func != NULL)\n\t\treturn func;\n\t}\n    }\n\n    hi = hash_find(&func_hashtab,\n\t\t\t\tSTRNCMP(name, \"g:\", 2) == 0 ? name + 2 : name);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * \"cctx\" is passed in a :def function to find imported functions.\n * Return NULL for unknown or dead function.\n */\n    ufunc_T *\nfind_func(char_u *name, int is_global, cctx_T *cctx)\n{\n    ufunc_T\t*fp = find_func_even_dead(name, is_global, cctx);\n\n    if (fp != NULL && (fp->uf_flags & FC_DEAD) == 0)\n\treturn fp;\n    return NULL;\n}\n\n/*\n * Return TRUE if \"ufunc\" is a global function.\n */\n    int\nfunc_is_global(ufunc_T *ufunc)\n{\n    return ufunc->uf_name[0] != K_SPECIAL;\n}\n\n/*\n * Copy the function name of \"fp\" to buffer \"buf\".\n * \"buf\" must be able to hold the function name plus three bytes.\n * Takes care of script-local function names.\n */\n    static void\ncat_func_name(char_u *buf, ufunc_T *fp)\n{\n    if (!func_is_global(fp))\n    {\n\tSTRCPY(buf, \"<SNR>\");\n\tSTRCAT(buf, fp->uf_name + 3);\n    }\n    else\n\tSTRCPY(buf, fp->uf_name);\n}\n\n/*\n * Add a number variable \"name\" to dict \"dp\" with value \"nr\".\n */\n    static void\nadd_nr_var(\n    dict_T\t*dp,\n    dictitem_T\t*v,\n    char\t*name,\n    varnumber_T nr)\n{\n    STRCPY(v->di_key, name);\n    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    hash_add(&dp->dv_hashtab, DI2HIKEY(v));\n    v->di_tv.v_type = VAR_NUMBER;\n    v->di_tv.v_lock = VAR_FIXED;\n    v->di_tv.vval.v_number = nr;\n}\n\n/*\n * Free \"fc\".\n */\n    static void\nfree_funccal(funccall_T *fc)\n{\n    int\ti;\n\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n    {\n\tufunc_T *fp = ((ufunc_T **)(fc->fc_funcs.ga_data))[i];\n\n\t// When garbage collecting a funccall_T may be freed before the\n\t// function that references it, clear its uf_scoped field.\n\t// The function may have been redefined and point to another\n\t// funccall_T, don't clear it then.\n\tif (fp != NULL && fp->uf_scoped == fc)\n\t    fp->uf_scoped = NULL;\n    }\n    ga_clear(&fc->fc_funcs);\n\n    func_ptr_unref(fc->func);\n    vim_free(fc);\n}\n\n/*\n * Free \"fc\" and what it contains.\n * Can be called only when \"fc\" is kept beyond the period of it called,\n * i.e. after cleanup_function_call(fc).\n */\n   static void\nfree_funccal_contents(funccall_T *fc)\n{\n    listitem_T\t*li;\n\n    // Free all l: variables.\n    vars_clear(&fc->l_vars.dv_hashtab);\n\n    // Free all a: variables.\n    vars_clear(&fc->l_avars.dv_hashtab);\n\n    // Free the a:000 variables.\n    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\tclear_tv(&li->li_tv);\n\n    free_funccal(fc);\n}\n\n/*\n * Handle the last part of returning from a function: free the local hashtable.\n * Unless it is still in use by a closure.\n */\n    static void\ncleanup_function_call(funccall_T *fc)\n{\n    int\tmay_free_fc = fc->fc_refcount <= 0;\n    int\tfree_fc = TRUE;\n\n    current_funccal = fc->caller;\n\n    // Free all l: variables if not referred.\n    if (may_free_fc && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear(&fc->l_vars.dv_hashtab);\n    else\n\tfree_fc = FALSE;\n\n    // If the a:000 list and the l: and a: dicts are not referenced and\n    // there is no closure using it, we can free the funccall_T and what's\n    // in it.\n    if (may_free_fc && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear_ext(&fc->l_avars.dv_hashtab, FALSE);\n    else\n    {\n\tint\t    todo;\n\thashitem_T  *hi;\n\tdictitem_T  *di;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a: variables, since we didn't do that above.\n\ttodo = (int)fc->l_avars.dv_hashtab.ht_used;\n\tfor (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tdi = HI2DI(hi);\n\t\tcopy_tv(&di->di_tv, &di->di_tv);\n\t    }\n\t}\n    }\n\n    if (may_free_fc && fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT)\n\tfc->l_varlist.lv_first = NULL;\n    else\n    {\n\tlistitem_T *li;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a:000 items, since we didn't do that above.\n\tFOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\t    copy_tv(&li->li_tv, &li->li_tv);\n    }\n\n    if (free_fc)\n\tfree_funccal(fc);\n    else\n    {\n\tstatic int made_copy = 0;\n\n\t// \"fc\" is still in use.  This can happen when returning \"a:000\",\n\t// assigning \"l:\" to a global variable or defining a closure.\n\t// Link \"fc\" in the list for garbage collection later.\n\tfc->caller = previous_funccal;\n\tprevious_funccal = fc;\n\n\tif (want_garbage_collect)\n\t    // If garbage collector is ready, clear count.\n\t    made_copy = 0;\n\telse if (++made_copy >= (int)((4096 * 1024) / sizeof(*fc)))\n\t{\n\t    // We have made a lot of copies, worth 4 Mbyte.  This can happen\n\t    // when repetitively calling a function that creates a reference to\n\t    // itself somehow.  Call the garbage collector soon to avoid using\n\t    // too much memory.\n\t    made_copy = 0;\n\t    want_garbage_collect = TRUE;\n\t}\n    }\n}\n\n/*\n * Return TRUE if \"name\" is a numbered function, ignoring a \"g:\" prefix.\n */\n    static int\nnumbered_function(char_u *name)\n{\n    return isdigit(*name)\n\t    || (name[0] == 'g' && name[1] == ':' && isdigit(name[2]));\n}\n\n/*\n * There are two kinds of function names:\n * 1. ordinary names, function defined with :function or :def\n * 2. numbered functions and lambdas\n * For the first we only count the name stored in func_hashtab as a reference,\n * using function() does not count as a reference, because the function is\n * looked up by name.\n */\n    int\nfunc_name_refcount(char_u *name)\n{\n    return numbered_function(name) || *name == '<';\n}\n\n/*\n * Unreference \"fc\": decrement the reference count and free it when it\n * becomes zero.  \"fp\" is detached from \"fc\".\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunccal_unref(funccall_T *fc, ufunc_T *fp, int force)\n{\n    funccall_T\t**pfc;\n    int\t\ti;\n\n    if (fc == NULL)\n\treturn;\n\n    if (--fc->fc_refcount <= 0 && (force || (\n\t\tfc->l_varlist.lv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_vars.dv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)))\n\tfor (pfc = &previous_funccal; *pfc != NULL; pfc = &(*pfc)->caller)\n\t{\n\t    if (fc == *pfc)\n\t    {\n\t\t*pfc = fc->caller;\n\t\tfree_funccal_contents(fc);\n\t\treturn;\n\t    }\n\t}\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n\tif (((ufunc_T **)(fc->fc_funcs.ga_data))[i] == fp)\n\t    ((ufunc_T **)(fc->fc_funcs.ga_data))[i] = NULL;\n}\n\n/*\n * Remove the function from the function hashtable.  If the function was\n * deleted while it still has references this was already done.\n * Return TRUE if the entry was deleted, FALSE if it wasn't found.\n */\n    static int\nfunc_remove(ufunc_T *fp)\n{\n    hashitem_T\t*hi;\n\n    // Return if it was already virtually deleted.\n    if (fp->uf_flags & FC_DEAD)\n\treturn FALSE;\n\n    hi = hash_find(&func_hashtab, UF2HIKEY(fp));\n    if (!HASHITEM_EMPTY(hi))\n    {\n\t// When there is a def-function index do not actually remove the\n\t// function, so we can find the index when defining the function again.\n\t// Do remove it when it's a copy.\n\tif (fp->uf_def_status == UF_COMPILED && (fp->uf_flags & FC_COPY) == 0)\n\t{\n\t    fp->uf_flags |= FC_DEAD;\n\t    return FALSE;\n\t}\n\thash_remove(&func_hashtab, hi);\n\tfp->uf_flags |= FC_DELETED;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nfunc_clear_items(ufunc_T *fp)\n{\n    ga_clear_strings(&(fp->uf_args));\n    ga_clear_strings(&(fp->uf_def_args));\n    ga_clear_strings(&(fp->uf_lines));\n    VIM_CLEAR(fp->uf_arg_types);\n    VIM_CLEAR(fp->uf_block_ids);\n    VIM_CLEAR(fp->uf_va_name);\n    clear_type_list(&fp->uf_type_list);\n\n    // Increment the refcount of this function to avoid it being freed\n    // recursively when the partial is freed.\n    fp->uf_refcount += 3;\n    partial_unref(fp->uf_partial);\n    fp->uf_partial = NULL;\n    fp->uf_refcount -= 3;\n\n#ifdef FEAT_LUA\n    if (fp->uf_cb_free != NULL)\n    {\n\tfp->uf_cb_free(fp->uf_cb_state);\n\tfp->uf_cb_free = NULL;\n    }\n\n    fp->uf_cb_state = NULL;\n    fp->uf_cb = NULL;\n#endif\n#ifdef FEAT_PROFILE\n    VIM_CLEAR(fp->uf_tml_count);\n    VIM_CLEAR(fp->uf_tml_total);\n    VIM_CLEAR(fp->uf_tml_self);\n#endif\n}\n\n/*\n * Free all things that a function contains.  Does not free the function\n * itself, use func_free() for that.\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunc_clear(ufunc_T *fp, int force)\n{\n    if (fp->uf_cleared)\n\treturn;\n    fp->uf_cleared = TRUE;\n\n    // clear this function\n    func_clear_items(fp);\n    funccal_unref(fp->uf_scoped, fp, force);\n    unlink_def_function(fp);\n}\n\n/*\n * Free a function and remove it from the list of functions.  Does not free\n * what a function contains, call func_clear() first.\n * When \"force\" is TRUE we are exiting.\n * Returns OK when the function was actually freed.\n */\n    static int\nfunc_free(ufunc_T *fp, int force)\n{\n    // Only remove it when not done already, otherwise we would remove a newer\n    // version of the function with the same name.\n    if ((fp->uf_flags & (FC_DELETED | FC_REMOVED)) == 0)\n\tfunc_remove(fp);\n\n    if ((fp->uf_flags & FC_DEAD) == 0 || force)\n    {\n\tif (fp->uf_dfunc_idx > 0)\n\t    unlink_def_function(fp);\n\tVIM_CLEAR(fp->uf_name_exp);\n\tvim_free(fp);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Free all things that a function contains and free the function itself.\n * When \"force\" is TRUE we are exiting.\n */\n    void\nfunc_clear_free(ufunc_T *fp, int force)\n{\n    func_clear(fp, force);\n    if (force || fp->uf_dfunc_idx == 0 || func_name_refcount(fp->uf_name)\n\t\t\t\t\t\t   || (fp->uf_flags & FC_COPY))\n\tfunc_free(fp, force);\n    else\n\tfp->uf_flags |= FC_DEAD;\n}\n\n/*\n * Copy already defined function \"lambda\" to a new function with name \"global\".\n * This is for when a compiled function defines a global function.\n */\n    int\ncopy_func(char_u *lambda, char_u *global, ectx_T *ectx)\n{\n    ufunc_T *ufunc = find_func_even_dead(lambda, TRUE, NULL);\n    ufunc_T *fp = NULL;\n\n    if (ufunc == NULL)\n    {\n\tsemsg(_(e_lambda_function_not_found_str), lambda);\n\treturn FAIL;\n    }\n\n    fp = find_func(global, TRUE, NULL);\n    if (fp != NULL)\n    {\n\t// TODO: handle ! to overwrite\n\tsemsg(_(e_function_str_already_exists_add_bang_to_replace), global);\n\treturn FAIL;\n    }\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(global) + 1);\n    if (fp == NULL)\n\treturn FAIL;\n\n    fp->uf_varargs = ufunc->uf_varargs;\n    fp->uf_flags = (ufunc->uf_flags & ~FC_VIM9) | FC_COPY;\n    fp->uf_def_status = ufunc->uf_def_status;\n    fp->uf_dfunc_idx = ufunc->uf_dfunc_idx;\n    if (ga_copy_strings(&ufunc->uf_args, &fp->uf_args) == FAIL\n\t    || ga_copy_strings(&ufunc->uf_def_args, &fp->uf_def_args)\n\t\t\t\t\t\t\t\t    == FAIL\n\t    || ga_copy_strings(&ufunc->uf_lines, &fp->uf_lines) == FAIL)\n\tgoto failed;\n\n    fp->uf_name_exp = ufunc->uf_name_exp == NULL ? NULL\n\t\t\t\t\t : vim_strsave(ufunc->uf_name_exp);\n    if (ufunc->uf_arg_types != NULL)\n    {\n\tfp->uf_arg_types = ALLOC_MULT(type_T *, fp->uf_args.ga_len);\n\tif (fp->uf_arg_types == NULL)\n\t    goto failed;\n\tmch_memmove(fp->uf_arg_types, ufunc->uf_arg_types,\n\t\t\t\t    sizeof(type_T *) * fp->uf_args.ga_len);\n    }\n    if (ufunc->uf_va_name != NULL)\n    {\n\tfp->uf_va_name = vim_strsave(ufunc->uf_va_name);\n\tif (fp->uf_va_name == NULL)\n\t    goto failed;\n    }\n    fp->uf_ret_type = ufunc->uf_ret_type;\n\n    fp->uf_refcount = 1;\n    STRCPY(fp->uf_name, global);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    // the referenced dfunc_T is now used one more time\n    link_def_function(fp);\n\n    // Create a partial to store the context of the function where it was\n    // instantiated.  Only needs to be done once.  Do this on the original\n    // function, \"dfunc->df_ufunc\" will point to it.\n    if ((ufunc->uf_flags & FC_CLOSURE) && ufunc->uf_partial == NULL)\n    {\n\tpartial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt == NULL)\n\t    goto failed;\n\tif (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t{\n            vim_free(pt);\n\t    goto failed;\n\t}\n\tufunc->uf_partial = pt;\n\t--pt->pt_refcount;  // not actually referenced here\n    }\n\n    return OK;\n\nfailed:\n    func_clear_free(fp, TRUE);\n    return FAIL;\n}\n\nstatic int\tfuncdepth = 0;\n\n/*\n * Increment the function call depth count.\n * Return FAIL when going over 'maxfuncdepth'.\n * Otherwise return OK, must call funcdepth_decrement() later!\n */\n    int\nfuncdepth_increment(void)\n{\n    if (funcdepth >= p_mfd)\n    {\n\temsg(_(e_function_call_depth_is_higher_than_macfuncdepth));\n\treturn FAIL;\n    }\n    ++funcdepth;\n    return OK;\n}\n\n    void\nfuncdepth_decrement(void)\n{\n    --funcdepth;\n}\n\n/*\n * Get the current function call depth.\n */\n    int\nfuncdepth_get(void)\n{\n    return funcdepth;\n}\n\n/*\n * Restore the function call depth.  This is for cases where there is no\n * guarantee funcdepth_decrement() can be called exactly the same number of\n * times as funcdepth_increment().\n */\n    void\nfuncdepth_restore(int depth)\n{\n    funcdepth = depth;\n}\n\n/*\n * Call a user function.\n */\n    static void\ncall_user_func(\n    ufunc_T\t*fp,\t\t// pointer to function\n    int\t\targcount,\t// nr of args\n    typval_T\t*argvars,\t// arguments\n    typval_T\t*rettv,\t\t// return value\n    funcexe_T\t*funcexe,\t// context\n    dict_T\t*selfdict)\t// Dictionary for \"self\"\n{\n    sctx_T\tsave_current_sctx;\n    int\t\tusing_sandbox = FALSE;\n    funccall_T\t*fc;\n    int\t\tsave_did_emsg;\n    int\t\tdefault_arg_err = FALSE;\n    dictitem_T\t*v;\n    int\t\tfixvar_idx = 0;\t// index in fixvar[]\n    int\t\ti;\n    int\t\tai;\n    int\t\tislambda = FALSE;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*name;\n    typval_T\t*tv_to_free[MAX_FUNC_ARGS];\n    int\t\ttv_to_free_len = 0;\n#ifdef FEAT_PROFILE\n    profinfo_T\tprofile_info;\n#endif\n    ESTACK_CHECK_DECLARATION\n\n#ifdef FEAT_PROFILE\n    CLEAR_FIELD(profile_info);\n#endif\n\n    // If depth of calling is getting too high, don't execute the function.\n    if (funcdepth_increment() == FAIL)\n    {\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n\treturn;\n    }\n\n    line_breakcheck();\t\t// check for CTRL-C hit\n\n    fc = ALLOC_CLEAR_ONE(funccall_T);\n    if (fc == NULL)\n\treturn;\n    fc->caller = current_funccal;\n    current_funccal = fc;\n    fc->func = fp;\n    fc->rettv = rettv;\n    fc->level = ex_nesting_level;\n    // Check if this function has a breakpoint.\n    fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);\n    fc->dbg_tick = debug_tick;\n    // Set up fields for closure.\n    ga_init2(&fc->fc_funcs, sizeof(ufunc_T *), 1);\n    func_ptr_ref(fp);\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n#ifdef FEAT_PROFILE\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n#endif\n\t// Execute the function, possibly compiling it first.\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES)\n\t    profile_may_start_func(&profile_info, fp, caller);\n#endif\n\tcall_def_function(fp, argcount, argvars, funcexe->fe_partial, rettv);\n\tfuncdepth_decrement();\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES && (fp->uf_profiling\n\t\t\t\t  || (caller != NULL && caller->uf_profiling)))\n\t    profile_may_end_func(&profile_info, fp, caller);\n#endif\n\tcurrent_funccal = fc->caller;\n\tfree_funccal(fc);\n\treturn;\n    }\n\n    islambda = fp->uf_flags & FC_LAMBDA;\n\n    /*\n     * Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables\n     * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free\n     * each argument variable and saves a lot of time.\n     */\n    /*\n     * Init l: variables.\n     */\n    init_var_dict(&fc->l_vars, &fc->l_vars_var, VAR_DEF_SCOPE);\n    if (selfdict != NULL)\n    {\n\t// Set l:self to \"selfdict\".  Use \"name\" to avoid a warning from\n\t// some compiler that checks the destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"self\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_DICT;\n\tv->di_tv.v_lock = 0;\n\tv->di_tv.vval.v_dict = selfdict;\n\t++selfdict->dv_refcount;\n    }\n\n    /*\n     * Init a: variables, unless none found (in lambda).\n     * Set a:0 to \"argcount\" less number of named arguments, if >= 0.\n     * Set a:000 to a list with room for the \"...\" arguments.\n     */\n    init_var_dict(&fc->l_avars, &fc->l_avars_var, VAR_SCOPE);\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"0\",\n\t\t\t\t(varnumber_T)(argcount >= fp->uf_args.ga_len\n\t\t\t\t    ? argcount - fp->uf_args.ga_len : 0));\n    fc->l_avars.dv_lock = VAR_FIXED;\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\t// Use \"name\" to avoid a warning from some compiler that checks the\n\t// destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"000\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_LIST;\n\tv->di_tv.v_lock = VAR_FIXED;\n\tv->di_tv.vval.v_list = &fc->l_varlist;\n    }\n    CLEAR_FIELD(fc->l_varlist);\n    fc->l_varlist.lv_refcount = DO_NOT_FREE_CNT;\n    fc->l_varlist.lv_lock = VAR_FIXED;\n\n    /*\n     * Set a:firstline to \"firstline\" and a:lastline to \"lastline\".\n     * Set a:name to named arguments.\n     * Set a:N to the \"...\" arguments.\n     * Skipped when no a: variables used (in lambda).\n     */\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"firstline\",\n\t\t\t\t\t   (varnumber_T)funcexe->fe_firstline);\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"lastline\",\n\t\t\t\t\t    (varnumber_T)funcexe->fe_lastline);\n    }\n    for (i = 0; i < argcount || i < fp->uf_args.ga_len; ++i)\n    {\n\tint\t    addlocal = FALSE;\n\ttypval_T    def_rettv;\n\tint\t    isdefault = FALSE;\n\n\tai = i - fp->uf_args.ga_len;\n\tif (ai < 0)\n\t{\n\t    // named argument a:name\n\t    name = FUNCARG(fp, i);\n\t    if (islambda)\n\t\taddlocal = TRUE;\n\n\t    // evaluate named argument default expression\n\t    isdefault = ai + fp->uf_def_args.ga_len >= 0\n\t\t       && (i >= argcount || (argvars[i].v_type == VAR_SPECIAL\n\t\t\t\t   && argvars[i].vval.v_number == VVAL_NONE));\n\t    if (isdefault)\n\t    {\n\t\tchar_u\t    *default_expr = NULL;\n\n\t\tdef_rettv.v_type = VAR_NUMBER;\n\t\tdef_rettv.vval.v_number = -1;\n\n\t\tdefault_expr = ((char_u **)(fp->uf_def_args.ga_data))\n\t\t\t\t\t\t [ai + fp->uf_def_args.ga_len];\n\t\tif (eval1(&default_expr, &def_rettv, &EVALARG_EVALUATE) == FAIL)\n\t\t{\n\t\t    default_arg_err = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    if ((fp->uf_flags & FC_NOARGS) != 0)\n\t\t// Bail out if no a: arguments used (in lambda).\n\t\tbreak;\n\n\t    // \"...\" argument a:1, a:2, etc.\n\t    sprintf((char *)numbuf, \"%d\", ai + 1);\n\t    name = numbuf;\n\t}\n\tif (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)\n\t{\n\t    v = &fc->fixvar[fixvar_idx++].var;\n\t    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\t    STRCPY(v->di_key, name);\n\t}\n\telse\n\t{\n\t    v = dictitem_alloc(name);\n\t    if (v == NULL)\n\t\tbreak;\n\t    v->di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;\n\t}\n\n\t// Note: the values are copied directly to avoid alloc/free.\n\t// \"argvars\" must have VAR_FIXED for v_lock.\n\tv->di_tv = isdefault ? def_rettv : argvars[i];\n\tv->di_tv.v_lock = VAR_FIXED;\n\n\tif (isdefault)\n\t    // Need to free this later, no matter where it's stored.\n\t    tv_to_free[tv_to_free_len++] = &v->di_tv;\n\n\tif (addlocal)\n\t{\n\t    // Named arguments should be accessed without the \"a:\" prefix in\n\t    // lambda expressions.  Add to the l: dict.\n\t    copy_tv(&v->di_tv, &v->di_tv);\n\t    hash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\t}\n\telse\n\t    hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\n\tif (ai >= 0 && ai < MAX_FUNC_ARGS)\n\t{\n\t    listitem_T *li = &fc->l_listitems[ai];\n\n\t    li->li_tv = argvars[i];\n\t    li->li_tv.v_lock = VAR_FIXED;\n\t    list_append(&fc->l_varlist, li);\n\t}\n    }\n\n    // Don't redraw while executing the function.\n    ++RedrawingDisabled;\n\n    if (fp->uf_flags & FC_SANDBOX)\n    {\n\tusing_sandbox = TRUE;\n\t++sandbox;\n    }\n\n    estack_push_ufunc(fp, 1);\n    ESTACK_CHECK_SETUP\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"calling %s\"), SOURCING_NAME);\n\tif (p_verbose >= 14)\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    msg_puts(\"(\");\n\t    for (i = 0; i < argcount; ++i)\n\t    {\n\t\tif (i > 0)\n\t\t    msg_puts(\", \");\n\t\tif (argvars[i].v_type == VAR_NUMBER)\n\t\t    msg_outnum((long)argvars[i].vval.v_number);\n\t\telse\n\t\t{\n\t\t    // Do not want errors such as E724 here.\n\t\t    ++emsg_off;\n\t\t    s = tv2string(&argvars[i], &tofree, numbuf2, 0);\n\t\t    --emsg_off;\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t\t{\n\t\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t\t    s = buf;\n\t\t\t}\n\t\t\tmsg_puts((char *)s);\n\t\t\tvim_free(tofree);\n\t\t    }\n\t\t}\n\t    }\n\t    msg_puts(\")\");\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprofile_may_start_func(&profile_info, fp,\n\t\t\t\t fc->caller == NULL ? NULL : fc->caller->func);\n#endif\n\n    save_current_sctx = current_sctx;\n    current_sctx = fp->uf_script_ctx;\n    save_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    if (default_arg_err && (fp->uf_flags & FC_ABORT))\n\tdid_emsg = TRUE;\n    else if (islambda)\n    {\n\tchar_u *p = *(char_u **)fp->uf_lines.ga_data + 7;\n\n\t// A Lambda always has the command \"return {expr}\".  It is much faster\n\t// to evaluate {expr} directly.\n\t++ex_nesting_level;\n\t(void)eval1(&p, rettv, &EVALARG_EVALUATE);\n\t--ex_nesting_level;\n    }\n    else\n\t// call do_cmdline() to execute the lines\n\tdo_cmdline(NULL, get_func_line, (void *)fc,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n    --RedrawingDisabled;\n\n    // when the function was aborted because of an error, return -1\n    if ((did_emsg && (fp->uf_flags & FC_ABORT)) || rettv->v_type == VAR_UNKNOWN)\n    {\n\tclear_tv(rettv);\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n    }\n\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n\n\tif (fp->uf_profiling || (caller != NULL && caller->uf_profiling))\n\t    profile_may_end_func(&profile_info, fp, caller);\n    }\n#endif\n\n    // when being verbose, mention the return value\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tif (aborting())\n\t    smsg(_(\"%s aborted\"), SOURCING_NAME);\n\telse if (fc->rettv->v_type == VAR_NUMBER)\n\t    smsg(_(\"%s returning #%ld\"), SOURCING_NAME,\n\t\t\t\t\t       (long)fc->rettv->vval.v_number);\n\telse\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    // The value may be very long.  Skip the middle part, so that we\n\t    // have some idea how it starts and ends. smsg() would always\n\t    // truncate it at the end. Don't want errors such as E724 here.\n\t    ++emsg_off;\n\t    s = tv2string(fc->rettv, &tofree, numbuf2, 0);\n\t    --emsg_off;\n\t    if (s != NULL)\n\t    {\n\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t{\n\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t    s = buf;\n\t\t}\n\t\tsmsg(_(\"%s returning %s\"), SOURCING_NAME, s);\n\t\tvim_free(tofree);\n\t    }\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    ESTACK_CHECK_NOW\n    estack_pop();\n    current_sctx = save_current_sctx;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tscript_prof_restore(&profile_info.pi_wait_start);\n#endif\n    if (using_sandbox)\n\t--sandbox;\n\n    if (p_verbose >= 12 && SOURCING_NAME != NULL)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"continuing in %s\"), SOURCING_NAME);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    did_emsg |= save_did_emsg;\n    funcdepth_decrement();\n    for (i = 0; i < tv_to_free_len; ++i)\n\tclear_tv(tv_to_free[i]);\n    cleanup_function_call(fc);\n}\n\n/*\n * Check the argument count for user function \"fp\".\n * Return FCERR_UNKNOWN if OK, FCERR_TOOFEW or FCERR_TOOMANY otherwise.\n */\n    int\ncheck_user_func_argcount(ufunc_T *fp, int argcount)\n{\n    int regular_args = fp->uf_args.ga_len;\n\n    if (argcount < regular_args - fp->uf_def_args.ga_len)\n\treturn FCERR_TOOFEW;\n    else if (!has_varargs(fp) && argcount > regular_args)\n\treturn FCERR_TOOMANY;\n    return FCERR_UNKNOWN;\n}\n\n/*\n * Call a user function after checking the arguments.\n */\n    int\ncall_user_func_check(\n\tufunc_T\t    *fp,\n\tint\t    argcount,\n\ttypval_T    *argvars,\n\ttypval_T    *rettv,\n\tfuncexe_T   *funcexe,\n\tdict_T\t    *selfdict)\n{\n    int error;\n\n    if (fp->uf_flags & FC_RANGE && funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = TRUE;\n    error = check_user_func_argcount(fp, argcount);\n    if (error != FCERR_UNKNOWN)\n\treturn error;\n    if ((fp->uf_flags & FC_DICT) && selfdict == NULL)\n\terror = FCERR_DICT;\n    else\n    {\n\tint\t\tdid_save_redo = FALSE;\n\tsave_redo_T\tsave_redo;\n\n\t/*\n\t * Call the user function.\n\t * Save and restore search patterns, script variables and\n\t * redo buffer.\n\t */\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redo = TRUE;\n\t}\n\t++fp->uf_calls;\n\tcall_user_func(fp, argcount, argvars, rettv, funcexe,\n\t\t\t\t   (fp->uf_flags & FC_DICT) ? selfdict : NULL);\n\tif (--fp->uf_calls <= 0 && fp->uf_refcount <= 0)\n\t    // Function was unreferenced while being used, free it now.\n\t    func_clear_free(fp, FALSE);\n\tif (did_save_redo)\n\t    restoreRedobuff(&save_redo);\n\trestore_search_patterns();\n\terror = FCERR_NONE;\n    }\n    return error;\n}\n\nstatic funccal_entry_T *funccal_stack = NULL;\n\n/*\n * Save the current function call pointer, and set it to NULL.\n * Used when executing autocommands and for \":source\".\n */\n    void\nsave_funccal(funccal_entry_T *entry)\n{\n    entry->top_funccal = current_funccal;\n    entry->next = funccal_stack;\n    funccal_stack = entry;\n    current_funccal = NULL;\n}\n\n    void\nrestore_funccal(void)\n{\n    if (funccal_stack == NULL)\n\tiemsg(\"INTERNAL: restore_funccal()\");\n    else\n    {\n\tcurrent_funccal = funccal_stack->top_funccal;\n\tfunccal_stack = funccal_stack->next;\n    }\n}\n\n    funccall_T *\nget_current_funccal(void)\n{\n    return current_funccal;\n}\n\n/*\n * Mark all functions of script \"sid\" as deleted.\n */\n    void\ndelete_script_functions(int sid)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\ttodo = 1;\n    char_u\tbuf[30];\n    size_t\tlen;\n\n    buf[0] = K_SPECIAL;\n    buf[1] = KS_EXTRA;\n    buf[2] = (int)KE_SNR;\n    sprintf((char *)buf + 3, \"%d_\", sid);\n    len = STRLEN(buf);\n\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tfp = HI2UF(hi);\n\t\tif (STRNCMP(fp->uf_name, buf, len) == 0)\n\t\t{\n\t\t    int changed = func_hashtab.ht_changed;\n\n\t\t    fp->uf_flags |= FC_DEAD;\n\n\t\t    if (fp->uf_calls > 0)\n\t\t    {\n\t\t\t// Function is executing, don't free it but do remove\n\t\t\t// it from the hashtable.\n\t\t\tif (func_remove(fp))\n\t\t\t    fp->uf_refcount--;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfunc_clear(fp, TRUE);\n\t\t\t// When clearing a function another function can be\n\t\t\t// cleared as a side effect.  When that happens start\n\t\t\t// over.\n\t\t\tif (changed != func_hashtab.ht_changed)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_functions(void)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\tskipped = 0;\n    long_u\ttodo = 1;\n    int\t\tchanged;\n\n    // Clean up the current_funccal chain and the funccal stack.\n    while (current_funccal != NULL)\n    {\n\tclear_tv(current_funccal->rettv);\n\tcleanup_function_call(current_funccal);\n\tif (current_funccal == NULL && funccal_stack != NULL)\n\t    restore_funccal();\n    }\n\n    // First clear what the functions contain.  Since this may lower the\n    // reference count of a function, it may also free a function and change\n    // the hash table. Restart if that happens.\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t// clear the def function index now\n\t\tfp = HI2UF(hi);\n\t\tfp->uf_flags &= ~FC_DEAD;\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    func_clear(fp, TRUE);\n\t\t    if (changed != func_hashtab.ht_changed)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n\n    // Now actually free the functions.  Need to start all over every time,\n    // because func_free() may change the hash table.\n    skipped = 0;\n    while (func_hashtab.ht_used > skipped)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tfp = HI2UF(hi);\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    if (func_free(fp, FALSE) == OK)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    // did not actually free it\n\t\t    ++skipped;\n\t\t}\n\t    }\n    }\n    if (skipped == 0)\n\thash_clear(&func_hashtab);\n\n    free_def_functions();\n}\n#endif\n\n/*\n * Return TRUE if \"name\" looks like a builtin function name: starts with a\n * lower case letter and doesn't contain AUTOLOAD_CHAR or ':'.\n * \"len\" is the length of \"name\", or -1 for NUL terminated.\n */\n    int\nbuiltin_function(char_u *name, int len)\n{\n    char_u *p;\n\n    if (!ASCII_ISLOWER(name[0]) || name[1] == ':')\n\treturn FALSE;\n    p = vim_strchr(name, AUTOLOAD_CHAR);\n    return p == NULL || (len > 0 && p > name + len);\n}\n\n    int\nfunc_call(\n    char_u\t*name,\n    typval_T\t*args,\n    partial_T\t*partial,\n    dict_T\t*selfdict,\n    typval_T\t*rettv)\n{\n    list_T\t*l = args->vval.v_list;\n    listitem_T\t*item;\n    typval_T\targv[MAX_FUNC_ARGS + 1];\n    int\t\targc = 0;\n    int\t\tr = 0;\n\n    CHECK_LIST_MATERIALIZE(l);\n    FOR_ALL_LIST_ITEMS(l, item)\n    {\n\tif (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial->pt_argc))\n\t{\n\t    emsg(_(e_too_many_arguments));\n\t    break;\n\t}\n\t// Make a copy of each argument.  This is needed to be able to set\n\t// v_lock to VAR_FIXED in the copy without changing the original list.\n\tcopy_tv(&item->li_tv, &argv[argc++]);\n    }\n\n    if (item == NULL)\n    {\n\tfuncexe_T funcexe;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = TRUE;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = selfdict;\n\tr = call_func(name, -1, rettv, argc, argv, &funcexe);\n    }\n\n    // Free the arguments.\n    while (argc > 0)\n\tclear_tv(&argv[--argc]);\n\n    return r;\n}\n\nstatic int callback_depth = 0;\n\n    int\nget_callback_depth(void)\n{\n    return callback_depth;\n}\n\n/*\n * Invoke call_func() with a callback.\n * Returns FAIL if the callback could not be called.\n */\n    int\ncall_callback(\n    callback_T\t*callback,\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    funcexe_T\tfuncexe;\n    int\t\tret;\n\n    if (callback->cb_name == NULL || *callback->cb_name == NUL)\n\treturn FAIL;\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_evaluate = TRUE;\n    funcexe.fe_partial = callback->cb_partial;\n    ++callback_depth;\n    ret = call_func(callback->cb_name, len, rettv, argcount, argvars, &funcexe);\n    --callback_depth;\n\n    // When a :def function was called that uses :try an error would be turned\n    // into an exception.  Need to give the error here.\n    if (need_rethrow && current_exception != NULL && trylevel == 0)\n    {\n\tneed_rethrow = FALSE;\n\thandle_did_throw();\n    }\n\n    return ret;\n}\n\n/*\n * call the 'callback' function and return the result as a number.\n * Returns -2 when calling the function fails.  Uses argv[0] to argv[argc - 1]\n * for the function arguments. argv[argc] should have type VAR_UNKNOWN.\n */\n    varnumber_T\ncall_callback_retnr(\n    callback_T\t*callback,\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n\n    if (call_callback(callback, 0, &rettv, argcount, argvars) == FAIL)\n\treturn -2;\n\n    retval = tv_get_number_chk(&rettv, NULL);\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Give an error message for the result of a function.\n * Nothing if \"error\" is FCERR_NONE.\n */\n    void\nuser_func_error(int error, char_u *name, funcexe_T *funcexe)\n{\n    switch (error)\n    {\n\tcase FCERR_UNKNOWN:\n\t\tif (funcexe->fe_found_var)\n\t\t    semsg(_(e_not_callable_type_str), name);\n\t\telse\n\t\t    emsg_funcname(e_unknown_function_str, name);\n\t\tbreak;\n\tcase FCERR_NOTMETHOD:\n\t\temsg_funcname(\n\t\t\tN_(e_cannot_use_function_as_method_str), name);\n\t\tbreak;\n\tcase FCERR_DELETED:\n\t\temsg_funcname(e_function_was_deleted_str, name);\n\t\tbreak;\n\tcase FCERR_TOOMANY:\n\t\temsg_funcname(e_too_many_arguments_for_function_str, name);\n\t\tbreak;\n\tcase FCERR_TOOFEW:\n\t\temsg_funcname(e_not_enough_arguments_for_function_str, name);\n\t\tbreak;\n\tcase FCERR_SCRIPT:\n\t\temsg_funcname(\n\t\t    e_using_sid_not_in_script_context_str, name);\n\t\tbreak;\n\tcase FCERR_DICT:\n\t\temsg_funcname(e_calling_dict_function_without_dictionary_str,\n\t\t\t\t\t\t\t\t\t name);\n\t\tbreak;\n    }\n}\n\n/*\n * Call a function with its resolved parameters\n *\n * Return FAIL when the function can't be called,  OK otherwise.\n * Also returns OK when an error was encountered while executing the function.\n */\n    int\ncall_func(\n    char_u\t*funcname,\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount_in,\t// number of \"argvars\"\n    typval_T\t*argvars_in,\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n    funcexe_T\t*funcexe)\t// more arguments\n{\n    int\t\tret = FAIL;\n    int\t\terror = FCERR_NONE;\n    int\t\ti;\n    ufunc_T\t*fp = NULL;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname = NULL;\n    char_u\t*name = NULL;\n    int\t\targcount = argcount_in;\n    typval_T\t*argvars = argvars_in;\n    dict_T\t*selfdict = funcexe->fe_selfdict;\n    typval_T\targv[MAX_FUNC_ARGS + 1]; // used when \"partial\" or\n\t\t\t\t\t // \"funcexe->fe_basetv\" is not NULL\n    int\t\targv_clear = 0;\n    int\t\targv_base = 0;\n    partial_T\t*partial = funcexe->fe_partial;\n    type_T\tcheck_type;\n    type_T\t*check_type_args[MAX_FUNC_ARGS];\n\n    // Initialize rettv so that it is safe for caller to invoke clear_tv(rettv)\n    // even when call_func() returns FAIL.\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (partial != NULL)\n\tfp = partial->pt_func;\n    if (fp == NULL)\n    {\n\t// Make a copy of the name, if it comes from a funcref variable it\n\t// could be changed or deleted in the called function.\n\tname = len > 0 ? vim_strnsave(funcname, len) : vim_strsave(funcname);\n\tif (name == NULL)\n\t    return ret;\n\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n    }\n\n    if (funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = FALSE;\n\n    if (partial != NULL)\n    {\n\t// When the function has a partial with a dict and there is a dict\n\t// argument, use the dict argument.  That is backwards compatible.\n\t// When the dict was bound explicitly use the one from the partial.\n\tif (partial->pt_dict != NULL && (selfdict == NULL || !partial->pt_auto))\n\t    selfdict = partial->pt_dict;\n\tif (error == FCERR_NONE && partial->pt_argc > 0)\n\t{\n\t    for (argv_clear = 0; argv_clear < partial->pt_argc; ++argv_clear)\n\t    {\n\t\tif (argv_clear + argcount_in >= MAX_FUNC_ARGS)\n\t\t{\n\t\t    error = FCERR_TOOMANY;\n\t\t    goto theend;\n\t\t}\n\t\tcopy_tv(&partial->pt_argv[argv_clear], &argv[argv_clear]);\n\t    }\n\t    for (i = 0; i < argcount_in; ++i)\n\t\targv[i + argv_clear] = argvars_in[i];\n\t    argvars = argv;\n\t    argcount = partial->pt_argc + argcount_in;\n\n\t    if (funcexe->fe_check_type != NULL\n\t\t\t\t  && funcexe->fe_check_type->tt_argcount != -1)\n\t    {\n\t\t// Now funcexe->fe_check_type is missing the added arguments,\n\t\t// make a copy of the type with the correction.\n\t\tcheck_type = *funcexe->fe_check_type;\n\t\tfuncexe->fe_check_type = &check_type;\n\t\tcheck_type.tt_args = check_type_args;\n\t\tCLEAR_FIELD(check_type_args);\n\t\tfor (i = 0; i < check_type.tt_argcount; ++i)\n\t\t    check_type_args[i + partial->pt_argc] =\n\t\t\t\t\t\t\t check_type.tt_args[i];\n\t\tcheck_type.tt_argcount += partial->pt_argc;\n\t\tcheck_type.tt_min_argcount += partial->pt_argc;\n\t    }\n\t}\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_check_type != NULL\n\t\t\t\t\t\t       && funcexe->fe_evaluate)\n    {\n\t// Check that the argument types are OK for the types of the funcref.\n\tif (check_argument_types(funcexe->fe_check_type, argvars, argcount,\n\t\t\t\t     (name != NULL) ? name : funcname) == FAIL)\n\t    error = FCERR_OTHER;\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_evaluate)\n    {\n\tchar_u *rfname = fname;\n\tint\tis_global = FALSE;\n\n\t// Skip \"g:\" before a function name.\n\tif (fp == NULL && fname[0] == 'g' && fname[1] == ':')\n\t{\n\t    is_global = TRUE;\n\t    rfname = fname + 2;\n\t}\n\n\trettv->v_type = VAR_NUMBER;\t// default rettv is number zero\n\trettv->vval.v_number = 0;\n\terror = FCERR_UNKNOWN;\n\n\tif (fp != NULL || !builtin_function(rfname, -1))\n\t{\n\t    /*\n\t     * User defined function.\n\t     */\n\t    if (fp == NULL)\n\t\tfp = find_func(rfname, is_global, NULL);\n\n\t    // Trigger FuncUndefined event, may load the function.\n\t    if (fp == NULL\n\t\t    && apply_autocmds(EVENT_FUNCUNDEFINED,\n\t\t\t\t\t\t    rfname, rfname, TRUE, NULL)\n\t\t    && !aborting())\n\t    {\n\t\t// executed an autocommand, search for the function again\n\t\tfp = find_func(rfname, is_global, NULL);\n\t    }\n\t    // Try loading a package.\n\t    if (fp == NULL && script_autoload(rfname, TRUE) && !aborting())\n\t    {\n\t\t// loaded a package, search for the function again\n\t\tfp = find_func(rfname, is_global, NULL);\n\t    }\n\t    if (fp == NULL)\n\t    {\n\t\tchar_u *p = untrans_function_name(rfname);\n\n\t\t// If using Vim9 script try not local to the script.\n\t\t// Don't do this if the name starts with \"s:\".\n\t\tif (p != NULL && (funcname[0] != 's' || funcname[1] != ':'))\n\t\t    fp = find_func(p, is_global, NULL);\n\t    }\n\n\t    if (fp != NULL && (fp->uf_flags & FC_DELETED))\n\t\terror = FCERR_DELETED;\n#ifdef FEAT_LUA\n\t    else if (fp != NULL && (fp->uf_flags & FC_CFUNC))\n\t    {\n\t\tcfunc_T cb = fp->uf_cb;\n\n\t\terror = (*cb)(argcount, argvars, rettv, fp->uf_cb_state);\n\t    }\n#endif\n\t    else if (fp != NULL)\n\t    {\n\t\tif (funcexe->fe_argv_func != NULL)\n\t\t    // postponed filling in the arguments, do it now\n\t\t    argcount = funcexe->fe_argv_func(argcount, argvars,\n\t\t\t\t\t       argv_clear, fp->uf_args.ga_len);\n\n\t\tif (funcexe->fe_basetv != NULL)\n\t\t{\n\t\t    // Method call: base->Method()\n\t\t    mch_memmove(&argv[1], argvars, sizeof(typval_T) * argcount);\n\t\t    argv[0] = *funcexe->fe_basetv;\n\t\t    argcount++;\n\t\t    argvars = argv;\n\t\t    argv_base = 1;\n\t\t}\n\n\t\terror = call_user_func_check(fp, argcount, argvars, rettv,\n\t\t\t\t\t\t\t    funcexe, selfdict);\n\t    }\n\t}\n\telse if (funcexe->fe_basetv != NULL)\n\t{\n\t    /*\n\t     * expr->method(): Find the method name in the table, call its\n\t     * implementation with the base as one of the arguments.\n\t     */\n\t    error = call_internal_method(fname, argcount, argvars, rettv,\n\t\t\t\t\t\t\t   funcexe->fe_basetv);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Find the function name in the table, call its implementation.\n\t     */\n\t    error = call_internal_func(fname, argcount, argvars, rettv);\n\t}\n\n\t/*\n\t * The function call (or \"FuncUndefined\" autocommand sequence) might\n\t * have been aborted by an error, an interrupt, or an explicitly thrown\n\t * exception that has not been caught so far.  This situation can be\n\t * tested for by calling aborting().  For an error in an internal\n\t * function or for the \"E132\" error in call_user_func(), however, the\n\t * throw point at which the \"force_abort\" flag (temporarily reset by\n\t * emsg()) is normally updated has not been reached yet. We need to\n\t * update that flag first to make aborting() reliable.\n\t */\n\tupdate_force_abort();\n    }\n    if (error == FCERR_NONE)\n\tret = OK;\n\ntheend:\n    /*\n     * Report an error unless the argument evaluation or function call has been\n     * cancelled due to an aborting error, an interrupt, or an exception.\n     */\n    if (!aborting())\n    {\n\tuser_func_error(error, (name != NULL) ? name : funcname, funcexe);\n    }\n\n    // clear the copies made from the partial\n    while (argv_clear > 0)\n\tclear_tv(&argv[--argv_clear + argv_base]);\n\n    vim_free(tofree);\n    vim_free(name);\n\n    return ret;\n}\n\n    char_u *\nprintable_func_name(ufunc_T *fp)\n{\n    return fp->uf_name_exp != NULL ? fp->uf_name_exp : fp->uf_name;\n}\n\n/*\n * List the head of the function: \"function name(arg1, arg2)\".\n */\n    static void\nlist_func_head(ufunc_T *fp, int indent)\n{\n    int\t\tj;\n\n    msg_start();\n    if (indent)\n\tmsg_puts(\"   \");\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n\tmsg_puts(\"def \");\n    else\n\tmsg_puts(\"function \");\n    msg_puts((char *)printable_func_name(fp));\n    msg_putchar('(');\n    for (j = 0; j < fp->uf_args.ga_len; ++j)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts((char *)FUNCARG(fp, j));\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_arg_types[j], &tofree));\n\t    vim_free(tofree);\n\t}\n\tif (j >= fp->uf_args.ga_len - fp->uf_def_args.ga_len)\n\t{\n\t    msg_puts(\" = \");\n\t    msg_puts(((char **)(fp->uf_def_args.ga_data))\n\t\t       [j - fp->uf_args.ga_len + fp->uf_def_args.ga_len]);\n\t}\n    }\n    if (fp->uf_varargs)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n    }\n    if (fp->uf_va_name != NULL)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n\tmsg_puts((char *)fp->uf_va_name);\n\tif (fp->uf_va_type != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_va_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    msg_putchar(')');\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n\tif (fp->uf_ret_type != &t_void)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_ret_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    else if (fp->uf_flags & FC_ABORT)\n\tmsg_puts(\" abort\");\n    if (fp->uf_flags & FC_RANGE)\n\tmsg_puts(\" range\");\n    if (fp->uf_flags & FC_DICT)\n\tmsg_puts(\" dict\");\n    if (fp->uf_flags & FC_CLOSURE)\n\tmsg_puts(\" closure\");\n    msg_clr_eos();\n    if (p_verbose > 0)\n\tlast_set_msg(fp->uf_script_ctx);\n}\n\n/*\n * Get a function name, translating \"<SID>\" and \"<SNR>\".\n * Also handles a Funcref in a List or Dictionary.\n * Returns the function name in allocated memory, or NULL for failure.\n * Set \"*is_global\" to TRUE when the function must be global, unless\n * \"is_global\" is NULL.\n * flags:\n * TFN_INT:\t    internal function name OK\n * TFN_QUIET:\t    be quiet\n * TFN_NO_AUTOLOAD: do not use script autoloading\n * TFN_NO_DEREF:    do not dereference a Funcref\n * Advances \"pp\" to just after the function name (if no error).\n */\n    char_u *\ntrans_function_name(\n    char_u\t**pp,\n    int\t\t*is_global,\n    int\t\tskip,\t\t// only find the end, don't evaluate\n    int\t\tflags,\n    funcdict_T\t*fdp,\t\t// return: info about dictionary used\n    partial_T\t**partial,\t// return: partial of a FuncRef\n    type_T\t**type)\t\t// return: type of funcref if not NULL\n{\n    char_u\t*name = NULL;\n    char_u\t*start;\n    char_u\t*end;\n    int\t\tlead;\n    char_u\tsid_buf[20];\n    int\t\tlen;\n    int\t\textra = 0;\n    lval_T\tlv;\n    int\t\tvim9script;\n\n    if (fdp != NULL)\n\tCLEAR_POINTER(fdp);\n    start = *pp;\n\n    // Check for hard coded <SNR>: already translated function ID (from a user\n    // command).\n    if ((*pp)[0] == K_SPECIAL && (*pp)[1] == KS_EXTRA\n\t\t\t\t\t\t   && (*pp)[2] == (int)KE_SNR)\n    {\n\t*pp += 3;\n\tlen = get_id_len(pp) + 3;\n\treturn vim_strnsave(start, len);\n    }\n\n    // A name starting with \"<SID>\" or \"<SNR>\" is local to a script.  But\n    // don't skip over \"s:\", get_lval() needs it for \"s:dict.func\".\n    lead = eval_fname_script(start);\n    if (lead > 2)\n\tstart += lead;\n\n    // Note that TFN_ flags use the same values as GLV_ flags.\n    end = get_lval(start, NULL, &lv, FALSE, skip, flags | GLV_READ_ONLY,\n\t\t\t\t\t      lead > 2 ? 0 : FNE_CHECK_START);\n    if (end == start)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name_required));\n\tgoto theend;\n    }\n    if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range)))\n    {\n\t/*\n\t * Report an invalid expression in braces, unless the expression\n\t * evaluation has been cancelled due to an aborting error, an\n\t * interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t{\n\t    if (end != NULL)\n\t\tsemsg(_(e_invalid_argument_str), start);\n\t}\n\telse\n\t    *pp = find_name_end(start, NULL, NULL, FNE_INCL_BR);\n\tgoto theend;\n    }\n\n    if (lv.ll_tv != NULL)\n    {\n\tif (fdp != NULL)\n\t{\n\t    fdp->fd_dict = lv.ll_dict;\n\t    fdp->fd_newkey = lv.ll_newkey;\n\t    lv.ll_newkey = NULL;\n\t    fdp->fd_di = lv.ll_di;\n\t}\n\tif (lv.ll_tv->v_type == VAR_FUNC && lv.ll_tv->vval.v_string != NULL)\n\t{\n\t    name = vim_strsave(lv.ll_tv->vval.v_string);\n\t    *pp = end;\n\t}\n\telse if (lv.ll_tv->v_type == VAR_PARTIAL\n\t\t\t\t\t  && lv.ll_tv->vval.v_partial != NULL)\n\t{\n\t    name = vim_strsave(partial_name(lv.ll_tv->vval.v_partial));\n\t    *pp = end;\n\t    if (partial != NULL)\n\t\t*partial = lv.ll_tv->vval.v_partial;\n\t}\n\telse\n\t{\n\t    if (!skip && !(flags & TFN_QUIET) && (fdp == NULL\n\t\t\t     || lv.ll_dict == NULL || fdp->fd_newkey == NULL))\n\t\temsg(_(e_funcref_required));\n\t    else\n\t\t*pp = end;\n\t    name = NULL;\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_name == NULL)\n    {\n\t// Error found, but continue after the function name.\n\t*pp = end;\n\tgoto theend;\n    }\n\n    // Check if the name is a Funcref.  If so, use the value.\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tname = deref_func_name(lv.ll_exp_name, &len, partial, type,\n\t\t\t\t\t\tflags & TFN_NO_AUTOLOAD, NULL);\n\tif (name == lv.ll_exp_name)\n\t    name = NULL;\n    }\n    else if (!(flags & TFN_NO_DEREF))\n    {\n\tlen = (int)(end - *pp);\n\tname = deref_func_name(*pp, &len, partial, type,\n\t\t\t\t\t\tflags & TFN_NO_AUTOLOAD, NULL);\n\tif (name == *pp)\n\t    name = NULL;\n    }\n    if (name != NULL)\n    {\n\tname = vim_strsave(name);\n\t*pp = end;\n\tif (STRNCMP(name, \"<SNR>\", 5) == 0)\n\t{\n\t    // Change \"<SNR>\" to the byte sequence.\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    mch_memmove(name + 3, name + 5, STRLEN(name + 5) + 1);\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tif (lead <= 2 && lv.ll_name == lv.ll_exp_name\n\t\t\t\t\t && STRNCMP(lv.ll_name, \"s:\", 2) == 0)\n\t{\n\t    // When there was \"s:\" already or the name expanded to get a\n\t    // leading \"s:\" then remove it.\n\t    lv.ll_name += 2;\n\t    len -= 2;\n\t    lead = 2;\n\t}\n    }\n    else\n    {\n\t// skip over \"s:\" and \"g:\"\n\tif (lead == 2 || (lv.ll_name[0] == 'g' && lv.ll_name[1] == ':'))\n\t{\n\t    if (is_global != NULL && lv.ll_name[0] == 'g')\n\t\t*is_global = TRUE;\n\t    lv.ll_name += 2;\n\t}\n\tlen = (int)(end - lv.ll_name);\n    }\n    if (len <= 0)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name_required));\n\tgoto theend;\n    }\n\n    // In Vim9 script a user function is script-local by default, unless it\n    // starts with a lower case character: dict.func().\n    vim9script = ASCII_ISUPPER(*start) && in_vim9script();\n    if (vim9script)\n    {\n\tchar_u *p;\n\n\t// SomeScript#func() is a global function.\n\tfor (p = start; *p != NUL && *p != '('; ++p)\n\t    if (*p == AUTOLOAD_CHAR)\n\t\tvim9script = FALSE;\n    }\n\n    /*\n     * Copy the function name to allocated memory.\n     * Accept <SID>name() inside a script, translate into <SNR>123_name().\n     * Accept <SNR>123_name() outside a script.\n     */\n    if (skip)\n\tlead = 0;\t// do nothing\n    else if (lead > 0 || vim9script)\n    {\n\tif (!vim9script)\n\t    lead = 3;\n\tif (vim9script || (lv.ll_exp_name != NULL\n\t\t\t\t\t     && eval_fname_sid(lv.ll_exp_name))\n\t\t\t\t\t\t       || eval_fname_sid(*pp))\n\t{\n\t    // It's script-local, \"s:\" or \"<SID>\"\n\t    if (current_sctx.sc_sid <= 0)\n\t    {\n\t\temsg(_(e_using_sid_not_in_script_context));\n\t\tgoto theend;\n\t    }\n\t    sprintf((char *)sid_buf, \"%ld_\", (long)current_sctx.sc_sid);\n\t    if (vim9script)\n\t\textra = 3 + (int)STRLEN(sid_buf);\n\t    else\n\t\tlead += (int)STRLEN(sid_buf);\n\t}\n    }\n    else if (!(flags & TFN_INT) && (builtin_function(lv.ll_name, len)\n\t\t\t\t   || (in_vim9script() && *lv.ll_name == '_')))\n    {\n\tsemsg(_(e_function_name_must_start_with_capital_or_s_str), start);\n\tgoto theend;\n    }\n    if (!skip && !(flags & TFN_QUIET) && !(flags & TFN_NO_DEREF))\n    {\n\tchar_u *cp = vim_strchr(lv.ll_name, ':');\n\n\tif (cp != NULL && cp < end)\n\t{\n\t    semsg(_(e_function_name_cannot_contain_colon_str), start);\n\t    goto theend;\n\t}\n    }\n\n    name = alloc(len + lead + extra + 1);\n    if (name != NULL)\n    {\n\tif (!skip && (lead > 0 || vim9script))\n\t{\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    if (vim9script || lead > 3)\t// If it's \"<SID>\"\n\t\tSTRCPY(name + 3, sid_buf);\n\t}\n\tmch_memmove(name + lead + extra, lv.ll_name, (size_t)len);\n\tname[lead + extra + len] = NUL;\n    }\n    *pp = end;\n\ntheend:\n    clear_lval(&lv);\n    return name;\n}\n\n/*\n * Assuming \"name\" is the result of trans_function_name() and it was prefixed\n * to use the script-local name, return the unmodified name (points into\n * \"name\").  Otherwise return NULL.\n * This can be used to first search for a script-local function and fall back\n * to the global function if not found.\n */\n    char_u *\nuntrans_function_name(char_u *name)\n{\n    char_u *p;\n\n    if (*name == K_SPECIAL && in_vim9script())\n    {\n\tp = vim_strchr(name, '_');\n\tif (p != NULL)\n\t    return p + 1;\n    }\n    return NULL;\n}\n\n/*\n * If the 'funcname' starts with \"s:\" or \"<SID>\", then expands it to the\n * current script ID and returns the expanded function name. The caller should\n * free the returned name. If not called from a script context or the function\n * name doesn't start with these prefixes, then returns NULL.\n * This doesn't check whether the script-local function exists or not.\n */\n    char_u *\nget_scriptlocal_funcname(char_u *funcname)\n{\n    char\tsid_buf[25];\n    int\t\toff;\n    char_u\t*newname;\n\n    if (funcname == NULL)\n\treturn NULL;\n\n    if (STRNCMP(funcname, \"s:\", 2) != 0\n\t\t&& STRNCMP(funcname, \"<SID>\", 5) != 0)\n\t// The function name is not a script-local function name\n\treturn NULL;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n    {\n\temsg(_(e_using_sid_not_in_script_context));\n\treturn NULL;\n    }\n    // Expand s: prefix into <SNR>nr_<name>\n    vim_snprintf(sid_buf, sizeof(sid_buf), \"<SNR>%ld_\",\n\t    (long)current_sctx.sc_sid);\n    off = *funcname == 's' ? 2 : 5;\n    newname = alloc(STRLEN(sid_buf) + STRLEN(funcname + off) + 1);\n    if (newname == NULL)\n\treturn NULL;\n    STRCPY(newname, sid_buf);\n    STRCAT(newname, funcname + off);\n\n    return newname;\n}\n\n/*\n * Call trans_function_name(), except that a lambda is returned as-is.\n * Returns the name in allocated memory.\n */\n    char_u *\nsave_function_name(\n\tchar_u\t    **name,\n\tint\t    *is_global,\n\tint\t    skip,\n\tint\t    flags,\n\tfuncdict_T  *fudi)\n{\n    char_u *p = *name;\n    char_u *saved;\n\n    if (STRNCMP(p, \"<lambda>\", 8) == 0)\n    {\n\tp += 8;\n\t(void)getdigits(&p);\n\tsaved = vim_strnsave(*name, p - *name);\n\tif (fudi != NULL)\n\t    CLEAR_POINTER(fudi);\n    }\n    else\n\tsaved = trans_function_name(&p, is_global, skip,\n\t\t\t\t\t\t      flags, fudi, NULL, NULL);\n    *name = p;\n    return saved;\n}\n\n/*\n * List functions.  When \"regmatch\" is NULL all of then.\n * Otherwise functions matching \"regmatch\".\n */\n    void\nlist_functions(regmatch_T *regmatch)\n{\n    int\t\tchanged = func_hashtab.ht_changed;\n    long_u\ttodo = func_hashtab.ht_used;\n    hashitem_T\t*hi;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    ufunc_T\t*fp = HI2UF(hi);\n\n\t    --todo;\n\t    if ((fp->uf_flags & FC_DEAD) == 0\n\t\t    && (regmatch == NULL\n\t\t\t? !message_filtered(fp->uf_name)\n\t\t\t    && !func_name_refcount(fp->uf_name)\n\t\t\t: !isdigit(*fp->uf_name)\n\t\t\t    && vim_regexec(regmatch, fp->uf_name, 0)))\n\t    {\n\t\tlist_func_head(fp, FALSE);\n\t\tif (changed != func_hashtab.ht_changed)\n\t\t{\n\t\t    emsg(_(e_function_list_was_modified));\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * \":function\" also supporting nested \":def\".\n * When \"name_arg\" is not NULL this is a nested function, using \"name_arg\" for\n * the function name.\n * Returns a pointer to the function or NULL if no function defined.\n */\n    ufunc_T *\ndefine_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n    garray_T\tnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    garray_T\tnewlines;\n    int\t\tvarargs = FALSE;\n    int\t\tflags = 0;\n    char_u\t*ret_type = NULL;\n    ufunc_T\t*fp = NULL;\n    int\t\tfp_allocated = FALSE;\n    int\t\tfree_fp = FALSE;\n    int\t\toverwrite = FALSE;\n    dictitem_T\t*v;\n    funcdict_T\tfudi;\n    static int\tfunc_nr = 0;\t    // number for nameless function\n    int\t\tparen;\n    hashitem_T\t*hi;\n    linenr_T\tsourcing_lnum_top;\n    int\t\tvim9script = in_vim9script();\n    imported_T\t*import = NULL;\n\n    /*\n     * \":function\" without argument: list functions.\n     */\n    if (ends_excmd2(eap->cmd, eap->arg))\n    {\n\tif (!eap->skip)\n\t    list_functions(NULL);\n\tset_nextcmd(eap, eap->arg);\n\treturn NULL;\n    }\n\n    /*\n     * \":function /pat\": list functions matching pattern.\n     */\n    if (*eap->arg == '/')\n    {\n\tp = skip_regexp(eap->arg + 1, '/', TRUE);\n\tif (!eap->skip)\n\t{\n\t    regmatch_T\tregmatch;\n\n\t    c = *p;\n\t    *p = NUL;\n\t    regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);\n\t    *p = c;\n\t    if (regmatch.regprog != NULL)\n\t    {\n\t\tregmatch.rm_ic = p_ic;\n\t\tlist_functions(&regmatch);\n\t\tvim_regfree(regmatch.regprog);\n\t    }\n\t}\n\tif (*p == '/')\n\t    ++p;\n\tset_nextcmd(eap, p);\n\treturn NULL;\n    }\n\n    ga_init(&newargs);\n    ga_init(&argtypes);\n    ga_init(&default_args);\n\n    /*\n     * Get the function name.  There are these situations:\n     * func\t    normal function name\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" == NULL\n     * dict.func    new dictionary entry\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" == NULL, \"fudi.fd_newkey\" == func\n     * dict.func    existing dict entry with a Funcref\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * dict.func    existing dict entry that's not a Funcref\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * s:func\t    script-local function name\n     * g:func\t    global function name, same as \"func\"\n     */\n    p = eap->arg;\n    if (name_arg != NULL)\n    {\n\t// nested function, argument is (args).\n\tparen = TRUE;\n\tCLEAR_FIELD(fudi);\n    }\n    else\n    {\n\tname = save_function_name(&p, &is_global, eap->skip,\n\t\t\t\t\t\t       TFN_NO_AUTOLOAD, &fudi);\n\tparen = (vim_strchr(p, '(') != NULL);\n\tif (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)\n\t{\n\t    /*\n\t     * Return on an invalid expression in braces, unless the expression\n\t     * evaluation has been cancelled due to an aborting error, an\n\t     * interrupt, or an exception.\n\t     */\n\t    if (!aborting())\n\t    {\n\t\tif (!eap->skip && fudi.fd_newkey != NULL)\n\t\t    semsg(_(e_key_not_present_in_dictionary), fudi.fd_newkey);\n\t\tvim_free(fudi.fd_newkey);\n\t\treturn NULL;\n\t    }\n\t    else\n\t\teap->skip = TRUE;\n\t}\n    }\n\n    // An error in a function call during evaluation of an expression in magic\n    // braces should not cause the function not to be defined.\n    saved_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    /*\n     * \":function func\" with only function name: list function.\n     */\n    if (!paren)\n    {\n\tif (!ends_excmd(*skipwhite(p)))\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    goto ret_free;\n\t}\n\tset_nextcmd(eap, p);\n\tif (eap->nextcmd != NULL)\n\t    *p = NUL;\n\tif (!eap->skip && !got_int)\n\t{\n\t    fp = find_func(name, is_global, NULL);\n\t    if (fp == NULL && ASCII_ISUPPER(*eap->arg))\n\t    {\n\t\tchar_u *up = untrans_function_name(name);\n\n\t\t// With Vim9 script the name was made script-local, if not\n\t\t// found try again with the original name.\n\t\tif (up != NULL)\n\t\t    fp = find_func(up, FALSE, NULL);\n\t    }\n\n\t    if (fp != NULL)\n\t    {\n\t\tlist_func_head(fp, TRUE);\n\t\tfor (j = 0; j < fp->uf_lines.ga_len && !got_int; ++j)\n\t\t{\n\t\t    if (FUNCLINE(fp, j) == NULL)\n\t\t\tcontinue;\n\t\t    msg_putchar('\\n');\n\t\t    msg_outnum((long)(j + 1));\n\t\t    if (j < 9)\n\t\t\tmsg_putchar(' ');\n\t\t    if (j < 99)\n\t\t\tmsg_putchar(' ');\n\t\t    msg_prt_line(FUNCLINE(fp, j), FALSE);\n\t\t    out_flush();\t// show a line at a time\n\t\t    ui_breakcheck();\n\t\t}\n\t\tif (!got_int)\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    if (fp->uf_def_status != UF_NOT_COMPILED)\n\t\t\tmsg_puts(\"   enddef\");\n\t\t    else\n\t\t\tmsg_puts(\"   endfunction\");\n\t\t}\n\t    }\n\t    else\n\t\temsg_funcname(e_undefined_function_str, eap->arg);\n\t}\n\tgoto ret_free;\n    }\n\n    /*\n     * \":function name(arg1, arg2)\" Define function.\n     */\n    p = skipwhite(p);\n    if (*p != '(')\n    {\n\tif (!eap->skip)\n\t{\n\t    semsg(_(e_missing_paren_str), eap->arg);\n\t    goto ret_free;\n\t}\n\t// attempt to continue by skipping some text\n\tif (vim_strchr(p, '(') != NULL)\n\t    p = vim_strchr(p, '(');\n    }\n\n    if ((vim9script || eap->cmdidx == CMD_def) && VIM_ISWHITE(p[-1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", p - 1);\n\tgoto ret_free;\n    }\n\n    // In Vim9 script only global functions can be redefined.\n    if (vim9script && eap->forceit && !is_global)\n    {\n\temsg(_(e_no_bang_allowed));\n\tgoto ret_free;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n\n    if (!eap->skip && name_arg == NULL)\n    {\n\t// Check the name of the function.  Unless it's a dictionary function\n\t// (that we are overwriting).\n\tif (name != NULL)\n\t    arg = name;\n\telse\n\t    arg = fudi.fd_newkey;\n\tif (arg != NULL && (fudi.fd_di == NULL\n\t\t\t\t     || (fudi.fd_di->di_tv.v_type != VAR_FUNC\n\t\t\t\t && fudi.fd_di->di_tv.v_type != VAR_PARTIAL)))\n\t{\n\t    char_u  *name_base = arg;\n\t    int\t    i;\n\n\t    if (*arg == K_SPECIAL)\n\t    {\n\t\tname_base = vim_strchr(arg, '_');\n\t\tif (name_base == NULL)\n\t\t    name_base = arg + 3;\n\t\telse\n\t\t    ++name_base;\n\t    }\n\t    for (i = 0; name_base[i] != NUL && (i == 0\n\t\t\t\t\t? eval_isnamec1(name_base[i])\n\t\t\t\t\t: eval_isnamec(name_base[i])); ++i)\n\t\t;\n\t    if (name_base[i] != NUL)\n\t\temsg_funcname(e_invalid_argument_str, arg);\n\n\t    // In Vim9 script a function cannot have the same name as a\n\t    // variable.\n\t    if (vim9script && *arg == K_SPECIAL\n\t\t&& eval_variable(name_base, (int)STRLEN(name_base), 0, NULL,\n\t\t    NULL, EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT\n\t\t\t\t\t\t     + EVAL_VAR_NO_FUNC) == OK)\n\t    {\n\t\tsemsg(_(e_redefining_script_item_str), name_base);\n\t\tgoto ret_free;\n\t    }\n\t}\n\t// Disallow using the g: dict.\n\tif (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)\n\t{\n\t    emsg(_(e_cannot_use_g_here));\n\t    goto ret_free;\n\t}\n    }\n\n    // This may get more lines and make the pointers into the first line\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, line_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t// find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_colon_str), p);\n\t\tp = skipwhite(p);\n\t    }\n\t    else if (!IS_WHITE_OR_NUL(p[1]))\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p);\n\t    ret_type = skipwhite(p + 1);\n\t    p = skip_type(ret_type, FALSE);\n\t    if (p > ret_type)\n\t    {\n\t\tret_type = vim_strnsave(ret_type, p - ret_type);\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_expected_type_str), ret_type);\n\t\tret_type = NULL;\n\t    }\n\t}\n\tp = skipwhite(p);\n    }\n    else\n\t// find extra arguments \"range\", \"dict\", \"abort\" and \"closure\"\n\tfor (;;)\n\t{\n\t    whitep = p;\n\t    p = skipwhite(p);\n\t    if (STRNCMP(p, \"range\", 5) == 0)\n\t    {\n\t\tflags |= FC_RANGE;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"dict\", 4) == 0)\n\t    {\n\t\tflags |= FC_DICT;\n\t\tp += 4;\n\t    }\n\t    else if (STRNCMP(p, \"abort\", 5) == 0)\n\t    {\n\t\tflags |= FC_ABORT;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"closure\", 7) == 0)\n\t    {\n\t\tflags |= FC_CLOSURE;\n\t\tp += 7;\n\t\tif (current_funccal == NULL)\n\t\t{\n\t\t    emsg_funcname(e_closure_function_should_not_be_at_top_level,\n\t\t\t    name == NULL ? (char_u *)\"\" : name);\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n\n    // When there is a line break use what follows for the function body.\n    // Makes 'exe \"func Test()\\n...\\nendfunc\"' work.\n    if (*p == '\\n')\n\tline_arg = p + 1;\n    else if (*p != NUL\n\t    && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)\n\t\t\t\t\t\t     && eap->cmdidx != CMD_def)\n\t    && !(VIM_ISWHITE(*whitep) && *p == '#'\n\t\t\t\t     && (vim9script || eap->cmdidx == CMD_def))\n\t    && !eap->skip\n\t    && !did_emsg)\n\tsemsg(_(e_trailing_characters_str), p);\n\n    /*\n     * Read the body of the function, until \"}\", \":endfunction\" or \":enddef\" is\n     * found.\n     */\n    if (KeyTyped)\n    {\n\t// Check if the function already exists, don't let the user type the\n\t// whole function before telling him it doesn't work!  For a script we\n\t// need to skip the body to be able to find what follows.\n\tif (!eap->skip && !eap->forceit)\n\t{\n\t    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)\n\t\temsg(_(e_dictionary_entry_already_exists));\n\t    else if (name != NULL && find_func(name, is_global, NULL) != NULL)\n\t\temsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);\n\t}\n\n\tif (!eap->skip && did_emsg)\n\t    goto erret;\n\n\tmsg_putchar('\\n');\t    // don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function\n     */\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n\n\tv = find_var(name, &ht, TRUE);\n\tif (v != NULL && v->di_tv.v_type == VAR_FUNC)\n\t{\n\t    emsg_funcname(e_function_name_conflicts_with_variable_str, name);\n\t    goto erret;\n\t}\n\n\tfp = find_func_even_dead(name, is_global, NULL);\n\tif (vim9script)\n\t{\n\t    char_u *uname = untrans_function_name(name);\n\n\t    import = find_imported(uname == NULL ? name : uname, 0, NULL);\n\t}\n\n\tif (fp != NULL || import != NULL)\n\t{\n\t    int dead = fp != NULL && (fp->uf_flags & FC_DEAD);\n\n\t    // Function can be replaced with \"function!\" and when sourcing the\n\t    // same script again, but only once.\n\t    // A name that is used by an import can not be overruled.\n\t    if (import != NULL\n\t\t    || (!dead && !eap->forceit\n\t\t\t&& (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)))\n\t    {\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tif (vim9script)\n\t\t    emsg_funcname(e_name_already_defined_str, name);\n\t\telse\n\t\t    emsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_calls > 0)\n\t    {\n\t\temsg_funcname(\n\t\t\t    e_cannot_redefine_function_str_it_is_in_use, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_refcount > 1)\n\t    {\n\t\t// This function is referenced somewhere, don't redefine it but\n\t\t// create a new one.\n\t\t--fp->uf_refcount;\n\t\tfp->uf_flags |= FC_REMOVED;\n\t\tfp = NULL;\n\t\toverwrite = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u *exp_name = fp->uf_name_exp;\n\n\t\t// redefine existing function, keep the expanded name\n\t\tVIM_CLEAR(name);\n\t\tfp->uf_name_exp = NULL;\n\t\tfunc_clear_items(fp);\n\t\tfp->uf_name_exp = exp_name;\n\t\tfp->uf_flags &= ~FC_DEAD;\n#ifdef FEAT_PROFILE\n\t\tfp->uf_profiling = FALSE;\n\t\tfp->uf_prof_initialized = FALSE;\n#endif\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\t    }\n\t}\n    }\n    else\n    {\n\tchar\tnumbuf[20];\n\n\tfp = NULL;\n\tif (fudi.fd_newkey == NULL && !eap->forceit)\n\t{\n\t    emsg(_(e_dictionary_entry_already_exists));\n\t    goto erret;\n\t}\n\tif (fudi.fd_di == NULL)\n\t{\n\t    // Can't add a function to a locked dictionary\n\t    if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))\n\t\tgoto erret;\n\t}\n\t    // Can't change an existing function if it is locked\n\telse if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))\n\t    goto erret;\n\n\t// Give the function a sequential number.  Can only be used with a\n\t// Funcref!\n\tvim_free(name);\n\tsprintf(numbuf, \"%d\", ++func_nr);\n\tname = vim_strsave((char_u *)numbuf);\n\tif (name == NULL)\n\t    goto erret;\n    }\n\n    if (fp == NULL)\n    {\n\tif (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    int\t    slen, plen;\n\t    char_u  *scriptname;\n\n\t    // Check that the autoload name matches the script name.\n\t    j = FAIL;\n\t    if (SOURCING_NAME != NULL)\n\t    {\n\t\tscriptname = autoload_name(name);\n\t\tif (scriptname != NULL)\n\t\t{\n\t\t    p = vim_strchr(scriptname, '/');\n\t\t    plen = (int)STRLEN(p);\n\t\t    slen = (int)STRLEN(SOURCING_NAME);\n\t\t    if (slen > plen && fnamecmp(p,\n\t\t\t\t\t    SOURCING_NAME + slen - plen) == 0)\n\t\t\tj = OK;\n\t\t    vim_free(scriptname);\n\t\t}\n\t    }\n\t    if (j == FAIL)\n\t    {\n\t\tlinenr_T save_lnum = SOURCING_LNUM;\n\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tsemsg(_(e_function_name_does_not_match_script_file_name_str),\n\t\t\t\t\t\t\t\t\t name);\n\t\tSOURCING_LNUM = save_lnum;\n\t\tgoto erret;\n\t    }\n\t}\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto erret;\n\tfp_allocated = TRUE;\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    if (fudi.fd_di == NULL)\n\t    {\n\t\t// add new dict entry\n\t\tfudi.fd_di = dictitem_alloc(fudi.fd_newkey);\n\t\tif (fudi.fd_di == NULL)\n\t\t{\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t\tif (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)\n\t\t{\n\t\t    vim_free(fudi.fd_di);\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\t// overwrite existing dict entry\n\t\tclear_tv(&fudi.fd_di->di_tv);\n\t    fudi.fd_di->di_tv.v_type = VAR_FUNC;\n\t    fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);\n\n\t    // behave like \"dict\" was used\n\t    flags |= FC_DICT;\n\t}\n    }\n    fp->uf_args = newargs;\n    fp->uf_def_args = default_args;\n    fp->uf_ret_type = &t_any;\n    fp->uf_func_type = &t_func_any;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\tint\t    lnum_save = SOURCING_LNUM;\n\tcstack_T    *cstack = eap->cstack;\n\n\tfp->uf_def_status = UF_TO_BE_COMPILED;\n\n\t// error messages are for the first function line\n\tSOURCING_LNUM = sourcing_lnum_top;\n\n\t// The function may use script variables from the context.\n\tfunction_using_block_scopes(fp, cstack);\n\n\tif (parse_argument_types(fp, &argtypes, varargs) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tvarargs = FALSE;\n\n\t// parse the return type, if any\n\tif (parse_return_type(fp, ret_type) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tSOURCING_LNUM = lnum_save;\n    }\n    else\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\n    if (fp_allocated)\n    {\n\t// insert the new function in the function list\n\tset_ufunc_name(fp, name);\n\tif (overwrite)\n\t{\n\t    hi = hash_find(&func_hashtab, name);\n\t    hi->hi_key = UF2HIKEY(fp);\n\t}\n\telse if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)\n\t{\n\t    free_fp = TRUE;\n\t    goto erret;\n\t}\n\tfp->uf_refcount = 1;\n    }\n\n    fp->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if ((flags & FC_CLOSURE) != 0)\n    {\n\tif (register_closure(fp) == FAIL)\n\t    goto erret;\n    }\n    else\n\tfp->uf_scoped = NULL;\n\n#ifdef FEAT_PROFILE\n    if (prof_def_func())\n\tfunc_do_profile(fp);\n#endif\n    fp->uf_varargs = varargs;\n    if (sandbox)\n\tflags |= FC_SANDBOX;\n    if (vim9script && !ASCII_ISUPPER(*fp->uf_name))\n\tflags |= FC_VIM9;\n    fp->uf_flags = flags;\n    fp->uf_calls = 0;\n    fp->uf_cleared = FALSE;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_script_ctx_version = current_sctx.sc_version;\n    fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    if (is_export)\n    {\n\tfp->uf_flags |= FC_EXPORT;\n\t// let ex_export() know the export worked.\n\tis_export = FALSE;\n    }\n\n    if (eap->cmdidx == CMD_def)\n\tset_function_type(fp);\n    else if (fp->uf_script_ctx.sc_version == SCRIPT_VERSION_VIM9)\n\t// :func does not use Vim9 script syntax, even in a Vim9 script file\n\tfp->uf_script_ctx.sc_version = SCRIPT_VERSION_MAX;\n\n    goto ret_free;\n\nerret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&default_args);\n    if (fp != NULL)\n    {\n\tga_init(&fp->uf_args);\n\tga_init(&fp->uf_def_args);\n    }\nerrret_2:\n    ga_clear_strings(&newlines);\n    if (fp != NULL)\n\tVIM_CLEAR(fp->uf_arg_types);\n    if (free_fp)\n    {\n\tvim_free(fp);\n\tfp = NULL;\n    }\nret_free:\n    ga_clear_strings(&argtypes);\n    vim_free(fudi.fd_newkey);\n    if (name != name_arg)\n\tvim_free(name);\n    vim_free(ret_type);\n    did_emsg |= saved_did_emsg;\n\n    return fp;\n}\n\n/*\n * \":function\"\n */\n    void\nex_function(exarg_T *eap)\n{\n    char_u *line_to_free = NULL;\n\n    (void)define_function(eap, NULL, &line_to_free);\n    vim_free(line_to_free);\n}\n\n/*\n * :defcompile - compile all :def functions in the current script that need to\n * be compiled.  Except dead functions.  Doesn't do profiling.\n */\n    void\nex_defcompile(exarg_T *eap UNUSED)\n{\n    long\ttodo = (long)func_hashtab.ht_used;\n    int\t\tchanged = func_hashtab.ht_changed;\n    hashitem_T\t*hi;\n    ufunc_T\t*ufunc;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    ufunc = HI2UF(hi);\n\t    if (ufunc->uf_script_ctx.sc_sid == current_sctx.sc_sid\n\t\t    && ufunc->uf_def_status == UF_TO_BE_COMPILED\n\t\t    && (ufunc->uf_flags & FC_DEAD) == 0)\n\t    {\n\t\t(void)compile_def_function(ufunc, FALSE, CT_NONE, NULL);\n\n\t\tif (func_hashtab.ht_changed != changed)\n\t\t{\n\t\t    // a function has been added or removed, need to start over\n\t\t    todo = (long)func_hashtab.ht_used;\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    hi = func_hashtab.ht_array;\n\t\t    --hi;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Return 5 if \"p\" starts with \"<SID>\" or \"<SNR>\" (ignoring case).\n * Return 2 if \"p\" starts with \"s:\".\n * Return 0 otherwise.\n */\n    int\neval_fname_script(char_u *p)\n{\n    // Use MB_STRICMP() because in Turkish comparing the \"I\" may not work with\n    // the standard library function.\n    if (p[0] == '<' && (MB_STRNICMP(p + 1, \"SID>\", 4) == 0\n\t\t\t\t       || MB_STRNICMP(p + 1, \"SNR>\", 4) == 0))\n\treturn 5;\n    if (p[0] == 's' && p[1] == ':')\n\treturn 2;\n    return 0;\n}\n\n    int\ntranslated_function_exists(char_u *name, int is_global)\n{\n    if (builtin_function(name, -1))\n\treturn has_internal_func(name);\n    return find_func(name, is_global, NULL) != NULL;\n}\n\n/*\n * Return TRUE when \"ufunc\" has old-style \"...\" varargs\n * or named varargs \"...name: type\".\n */\n    int\nhas_varargs(ufunc_T *ufunc)\n{\n    return ufunc->uf_varargs || ufunc->uf_va_name != NULL;\n}\n\n/*\n * Return TRUE if a function \"name\" exists.\n * If \"no_defef\" is TRUE, do not dereference a Funcref.\n */\n    int\nfunction_exists(char_u *name, int no_deref)\n{\n    char_u  *nm = name;\n    char_u  *p;\n    int\t    n = FALSE;\n    int\t    flag;\n    int\t    is_global = FALSE;\n\n    flag = TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD;\n    if (no_deref)\n\tflag |= TFN_NO_DEREF;\n    p = trans_function_name(&nm, &is_global, FALSE, flag, NULL, NULL, NULL);\n    nm = skipwhite(nm);\n\n    // Only accept \"funcname\", \"funcname \", \"funcname (...\" and\n    // \"funcname(...\", not \"funcname!...\".\n    if (p != NULL && (*nm == NUL || *nm == '('))\n\tn = translated_function_exists(p, is_global);\n    vim_free(p);\n    return n;\n}\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    char_u *\nget_expanded_name(char_u *name, int check)\n{\n    char_u\t*nm = name;\n    char_u\t*p;\n    int\t\tis_global = FALSE;\n\n    p = trans_function_name(&nm, &is_global, FALSE,\n\t\t\t\t\t  TFN_INT|TFN_QUIET, NULL, NULL, NULL);\n\n    if (p != NULL && *nm == NUL\n\t\t       && (!check || translated_function_exists(p, is_global)))\n\treturn p;\n\n    vim_free(p);\n    return NULL;\n}\n#endif\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user defined\n * function names.\n */\n    char_u *\nget_user_func_name(expand_T *xp, int idx)\n{\n    static long_u\tdone;\n    static int\t\tchanged;\n    static hashitem_T\t*hi;\n    ufunc_T\t\t*fp;\n\n    if (idx == 0)\n    {\n\tdone = 0;\n\thi = func_hashtab.ht_array;\n\tchanged = func_hashtab.ht_changed;\n    }\n    if (changed == func_hashtab.ht_changed && done < func_hashtab.ht_used)\n    {\n\tif (done++ > 0)\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\tfp = HI2UF(hi);\n\n\t// don't show dead, dict and lambda functions\n\tif ((fp->uf_flags & FC_DEAD) || (fp->uf_flags & FC_DICT)\n\t\t\t\t|| STRNCMP(fp->uf_name, \"<lambda>\", 8) == 0)\n\t    return (char_u *)\"\";\n\n\tif (STRLEN(fp->uf_name) + 4 >= IOSIZE)\n\t    return fp->uf_name;\t// prevents overflow\n\n\tcat_func_name(IObuff, fp);\n\tif (xp->xp_context != EXPAND_USER_FUNC\n\t\t\t\t       && xp->xp_context != EXPAND_DISASSEMBLE)\n\t{\n\t    STRCAT(IObuff, \"(\");\n\t    if (!has_varargs(fp) && fp->uf_args.ga_len == 0)\n\t\tSTRCAT(IObuff, \")\");\n\t}\n\treturn IObuff;\n    }\n    return NULL;\n}\n\n/*\n * \":delfunction {name}\"\n */\n    void\nex_delfunction(exarg_T *eap)\n{\n    ufunc_T\t*fp = NULL;\n    char_u\t*p;\n    char_u\t*name;\n    funcdict_T\tfudi;\n    int\t\tis_global = FALSE;\n\n    p = eap->arg;\n    name = trans_function_name(&p, &is_global, eap->skip, 0, &fudi,\n\t\t\t\t\t\t\t\t   NULL, NULL);\n    vim_free(fudi.fd_newkey);\n    if (name == NULL)\n    {\n\tif (fudi.fd_dict != NULL && !eap->skip)\n\t    emsg(_(e_funcref_required));\n\treturn;\n    }\n    if (!ends_excmd(*skipwhite(p)))\n    {\n\tvim_free(name);\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn;\n    }\n    set_nextcmd(eap, p);\n    if (eap->nextcmd != NULL)\n\t*p = NUL;\n\n    if (numbered_function(name) && fudi.fd_dict == NULL)\n    {\n\tif (!eap->skip)\n\t    semsg(_(e_invalid_argument_str), eap->arg);\n\tvim_free(name);\n\treturn;\n    }\n    if (!eap->skip)\n\tfp = find_func(name, is_global, NULL);\n    vim_free(name);\n\n    if (!eap->skip)\n    {\n\tif (fp == NULL)\n\t{\n\t    if (!eap->forceit)\n\t\tsemsg(_(e_unknown_function_str), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_calls > 0)\n\t{\n\t    semsg(_(e_cannot_delete_function_str_it_is_in_use), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_flags & FC_VIM9)\n\t{\n\t    semsg(_(e_cannot_delete_vim9_script_function_str), eap->arg);\n\t    return;\n\t}\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    // Delete the dict item that refers to the function, it will\n\t    // invoke func_unref() and possibly delete the function.\n\t    dictitem_remove(fudi.fd_dict, fudi.fd_di);\n\t}\n\telse\n\t{\n\t    // A normal function (not a numbered function or lambda) has a\n\t    // refcount of 1 for the entry in the hashtable.  When deleting\n\t    // it and the refcount is more than one, it should be kept.\n\t    // A numbered function and lambda should be kept if the refcount is\n\t    // one or more.\n\t    if (fp->uf_refcount > (func_name_refcount(fp->uf_name) ? 0 : 1))\n\t    {\n\t\t// Function is still referenced somewhere.  Don't free it but\n\t\t// do remove it from the hashtable.\n\t\tif (func_remove(fp))\n\t\t    fp->uf_refcount--;\n\t    }\n\t    else\n\t\tfunc_clear_free(fp, FALSE);\n\t}\n    }\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\nfunc_unref(char_u *name)\n{\n    ufunc_T *fp = NULL;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE, NULL);\n    if (fp == NULL && numbered_function(name))\n    {\n#ifdef EXITFREE\n\tif (!entered_free_all_mem)\n#endif\n\t    internal_error(\"func_unref()\");\n    }\n    func_ptr_unref(fp);\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n * Also when it becomes one and uf_partial points to the function.\n */\n    void\nfunc_ptr_unref(ufunc_T *fp)\n{\n    if (fp != NULL && (--fp->uf_refcount <= 0\n\t\t|| (fp->uf_refcount == 1 && fp->uf_partial != NULL\n\t\t\t\t\t && fp->uf_partial->pt_refcount <= 1\n\t\t\t\t\t && fp->uf_partial->pt_func == fp)))\n    {\n\t// Only delete it when it's not being used.  Otherwise it's done\n\t// when \"uf_calls\" becomes zero.\n\tif (fp->uf_calls == 0)\n\t    func_clear_free(fp, FALSE);\n    }\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ref(char_u *name)\n{\n    ufunc_T *fp;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE, NULL);\n    if (fp != NULL)\n\t++fp->uf_refcount;\n    else if (numbered_function(name))\n\t// Only give an error for a numbered function.\n\t// Fail silently, when named or lambda function isn't found.\n\tinternal_error(\"func_ref()\");\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ptr_ref(ufunc_T *fp)\n{\n    if (fp != NULL)\n\t++fp->uf_refcount;\n}\n\n/*\n * Return TRUE if items in \"fc\" do not have \"copyID\".  That means they are not\n * referenced from anywhere that is in use.\n */\n    static int\ncan_free_funccal(funccall_T *fc, int copyID)\n{\n    return (fc->l_varlist.lv_copyID != copyID\n\t    && fc->l_vars.dv_copyID != copyID\n\t    && fc->l_avars.dv_copyID != copyID\n\t    && fc->fc_copyID != copyID);\n}\n\n/*\n * \":return [expr]\"\n */\n    void\nex_return(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\treturning = FALSE;\n    evalarg_T\tevalarg;\n\n    if (current_funccal == NULL)\n    {\n\temsg(_(e_return_not_inside_function));\n\treturn;\n    }\n\n    init_evalarg(&evalarg);\n    evalarg.eval_flags = eap->skip ? 0 : EVAL_EVALUATE;\n\n    if (eap->skip)\n\t++emsg_skip;\n\n    eap->nextcmd = NULL;\n    if ((*arg != NUL && *arg != '|' && *arg != '\\n')\n\t\t\t\t  && eval0(arg, &rettv, eap, &evalarg) != FAIL)\n    {\n\tif (!eap->skip)\n\t    returning = do_return(eap, FALSE, TRUE, &rettv);\n\telse\n\t    clear_tv(&rettv);\n    }\n    // It's safer to return also on error.\n    else if (!eap->skip)\n    {\n\t// In return statement, cause_abort should be force_abort.\n\tupdate_force_abort();\n\n\t/*\n\t * Return unless the expression evaluation has been cancelled due to an\n\t * aborting error, an interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t    returning = do_return(eap, FALSE, TRUE, NULL);\n    }\n\n    // When skipping or the return gets pending, advance to the next command\n    // in this line (!returning).  Otherwise, ignore the rest of the line.\n    // Following lines will be ignored by get_func_line().\n    if (returning)\n\teap->nextcmd = NULL;\n    else if (eap->nextcmd == NULL)\t    // no argument\n\tset_nextcmd(eap, arg);\n\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n}\n\n/*\n * \":1,25call func(arg1, arg2)\"\tfunction call.\n */\n    void\nex_call(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*startarg;\n    char_u\t*name;\n    char_u\t*tofree;\n    int\t\tlen;\n    typval_T\trettv;\n    linenr_T\tlnum;\n    int\t\tdoesrange;\n    int\t\tfailed = FALSE;\n    funcdict_T\tfudi;\n    partial_T\t*partial = NULL;\n    evalarg_T\tevalarg;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n    if (eap->skip)\n    {\n\t// trans_function_name() doesn't work well when skipping, use eval0()\n\t// instead to skip to any following command, e.g. for:\n\t//   :if 0 | call dict.foo().bar() | endif\n\t++emsg_skip;\n\tif (eval0(eap->arg, &rettv, eap, &evalarg) != FAIL)\n\t    clear_tv(&rettv);\n\t--emsg_skip;\n\tclear_evalarg(&evalarg, eap);\n\treturn;\n    }\n\n    tofree = trans_function_name(&arg, NULL, eap->skip, TFN_INT,\n\t\t\t      &fudi, &partial, in_vim9script() ? &type : NULL);\n    if (fudi.fd_newkey != NULL)\n    {\n\t// Still need to give an error message for missing key.\n\tsemsg(_(e_key_not_present_in_dictionary), fudi.fd_newkey);\n\tvim_free(fudi.fd_newkey);\n    }\n    if (tofree == NULL)\n\treturn;\n\n    // Increase refcount on dictionary, it could get deleted when evaluating\n    // the arguments.\n    if (fudi.fd_dict != NULL)\n\t++fudi.fd_dict->dv_refcount;\n\n    // If it is the name of a variable of type VAR_FUNC or VAR_PARTIAL use its\n    // contents.  For VAR_PARTIAL get its partial, unless we already have one\n    // from trans_function_name().\n    len = (int)STRLEN(tofree);\n    name = deref_func_name(tofree, &len, partial != NULL ? NULL : &partial,\n\t    in_vim9script() && type == NULL ? &type : NULL, FALSE, &found_var);\n\n    // Skip white space to allow \":call func ()\".  Not good, but required for\n    // backward compatibility.\n    startarg = skipwhite(arg);\n    if (*startarg != '(')\n    {\n\tsemsg(_(e_missing_parenthesis_str), eap->arg);\n\tgoto end;\n    }\n    if (in_vim9script() && startarg > arg)\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", eap->arg);\n\tgoto end;\n    }\n\n    /*\n     * When skipping, evaluate the function once, to find the end of the\n     * arguments.\n     * When the function takes a range, this is discovered after the first\n     * call, and the loop is broken.\n     */\n    if (eap->skip)\n    {\n\t++emsg_skip;\n\tlnum = eap->line2;\t// do it once, also with an invalid range\n    }\n    else\n\tlnum = eap->line1;\n    for ( ; lnum <= eap->line2; ++lnum)\n    {\n\tfuncexe_T funcexe;\n\n\tif (!eap->skip && eap->addr_count > 0)\n\t{\n\t    if (lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// If the function deleted lines or switched to another buffer\n\t\t// the line number may become invalid.\n\t\temsg(_(e_invalid_range));\n\t\tbreak;\n\t    }\n\t    curwin->w_cursor.lnum = lnum;\n\t    curwin->w_cursor.col = 0;\n\t    curwin->w_cursor.coladd = 0;\n\t}\n\targ = startarg;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = eap->line1;\n\tfuncexe.fe_lastline = eap->line2;\n\tfuncexe.fe_doesrange = &doesrange;\n\tfuncexe.fe_evaluate = !eap->skip;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = fudi.fd_dict;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\trettv.v_type = VAR_UNKNOWN;\t// clear_tv() uses this\n\tif (get_func_tv(name, -1, &rettv, &arg, &evalarg, &funcexe) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\tif (has_watchexpr())\n\t    dbg_check_breakpoint(eap);\n\n\t// Handle a function returning a Funcref, Dictionary or List.\n\tif (handle_subscript(&arg, NULL, &rettv,\n\t\t\t   eap->skip ? NULL : &EVALARG_EVALUATE, TRUE) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\n\tclear_tv(&rettv);\n\tif (doesrange || eap->skip)\n\t    break;\n\n\t// Stop when immediately aborting on error, or when an interrupt\n\t// occurred or an exception was thrown but not caught.\n\t// get_func_tv() returned OK, so that the check for trailing\n\t// characters below is executed.\n\tif (aborting())\n\t    break;\n    }\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    // When inside :try we need to check for following \"| catch\" or \"| endtry\".\n    // Not when there was an error, but do check if an exception was thrown.\n    if ((!aborting() || did_throw)\n\t\t\t\t  && (!failed || eap->cstack->cs_trylevel > 0))\n    {\n\t// Check for trailing illegal characters and a following command.\n\targ = skipwhite(arg);\n\tif (!ends_excmd2(eap->arg, arg))\n\t{\n\t    if (!failed && !aborting())\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_trailing_characters_str), arg);\n\t    }\n\t}\n\telse\n\t    set_nextcmd(eap, arg);\n    }\n\nend:\n    dict_unref(fudi.fd_dict);\n    vim_free(tofree);\n}\n\n/*\n * Return from a function.  Possibly makes the return pending.  Also called\n * for a pending return at the \":endtry\" or after returning from an extra\n * do_cmdline().  \"reanimate\" is used in the latter case.  \"is_cmd\" is set\n * when called due to a \":return\" command.  \"rettv\" may point to a typval_T\n * with the return rettv.  Returns TRUE when the return can be carried out,\n * FALSE when the return gets pending.\n */\n    int\ndo_return(\n    exarg_T\t*eap,\n    int\t\treanimate,\n    int\t\tis_cmd,\n    void\t*rettv)\n{\n    int\t\tidx;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (reanimate)\n\t// Undo the return.\n\tcurrent_funccal->returned = FALSE;\n\n    /*\n     * Cleanup (and inactivate) conditionals, but stop when a try conditional\n     * not in its finally clause (which then is to be executed next) is found.\n     * In this case, make the \":return\" pending for execution at the \":endtry\".\n     * Otherwise, return normally.\n     */\n    idx = cleanup_conditionals(eap->cstack, 0, TRUE);\n    if (idx >= 0)\n    {\n\tcstack->cs_pending[idx] = CSTP_RETURN;\n\n\tif (!is_cmd && !reanimate)\n\t    // A pending return again gets pending.  \"rettv\" points to an\n\t    // allocated variable with the rettv of the original \":return\"'s\n\t    // argument if present or is NULL else.\n\t    cstack->cs_rettv[idx] = rettv;\n\telse\n\t{\n\t    // When undoing a return in order to make it pending, get the stored\n\t    // return rettv.\n\t    if (reanimate)\n\t\trettv = current_funccal->rettv;\n\n\t    if (rettv != NULL)\n\t    {\n\t\t// Store the value of the pending return.\n\t\tif ((cstack->cs_rettv[idx] = alloc_tv()) != NULL)\n\t\t    *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;\n\t\telse\n\t\t    emsg(_(e_out_of_memory));\n\t    }\n\t    else\n\t\tcstack->cs_rettv[idx] = NULL;\n\n\t    if (reanimate)\n\t    {\n\t\t// The pending return value could be overwritten by a \":return\"\n\t\t// without argument in a finally clause; reset the default\n\t\t// return value.\n\t\tcurrent_funccal->rettv->v_type = VAR_NUMBER;\n\t\tcurrent_funccal->rettv->vval.v_number = 0;\n\t    }\n\t}\n\treport_make_pending(CSTP_RETURN, rettv);\n    }\n    else\n    {\n\tcurrent_funccal->returned = TRUE;\n\n\t// If the return is carried out now, store the return value.  For\n\t// a return immediately after reanimation, the value is already\n\t// there.\n\tif (!reanimate && rettv != NULL)\n\t{\n\t    clear_tv(current_funccal->rettv);\n\t    *current_funccal->rettv = *(typval_T *)rettv;\n\t    if (!is_cmd)\n\t\tvim_free(rettv);\n\t}\n    }\n\n    return idx < 0;\n}\n\n/*\n * Free the variable with a pending return value.\n */\n    void\ndiscard_pending_return(void *rettv)\n{\n    free_tv((typval_T *)rettv);\n}\n\n/*\n * Generate a return command for producing the value of \"rettv\".  The result\n * is an allocated string.  Used by report_pending() for verbose messages.\n */\n    char_u *\nget_return_cmd(void *rettv)\n{\n    char_u\t*s = NULL;\n    char_u\t*tofree = NULL;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    if (rettv != NULL)\n\ts = echo_string((typval_T *)rettv, &tofree, numbuf, 0);\n    if (s == NULL)\n\ts = (char_u *)\"\";\n\n    STRCPY(IObuff, \":return \");\n    STRNCPY(IObuff + 8, s, IOSIZE - 8);\n    if (STRLEN(s) + 8 >= IOSIZE)\n\tSTRCPY(IObuff + IOSIZE - 4, \"...\");\n    vim_free(tofree);\n    return vim_strsave(IObuff);\n}\n\n/*\n * Get next function line.\n * Called by do_cmdline() to get the next line.\n * Returns allocated string, or NULL for end of function.\n */\n    char_u *\nget_func_line(\n    int\t    c UNUSED,\n    void    *cookie,\n    int\t    indent UNUSED,\n    getline_opt_T options UNUSED)\n{\n    funccall_T\t*fcp = (funccall_T *)cookie;\n    ufunc_T\t*fp = fcp->func;\n    char_u\t*retval;\n    garray_T\t*gap;  // growarray with function lines\n\n    // If breakpoints have been added/deleted need to check for it.\n    if (fcp->dbg_tick != debug_tick)\n    {\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tfunc_line_end(cookie);\n#endif\n\n    gap = &fp->uf_lines;\n    if (((fp->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned)\n\tretval = NULL;\n    else\n    {\n\t// Skip NULL lines (continuation lines).\n\twhile (fcp->linenr < gap->ga_len\n\t\t\t  && ((char_u **)(gap->ga_data))[fcp->linenr] == NULL)\n\t    ++fcp->linenr;\n\tif (fcp->linenr >= gap->ga_len)\n\t    retval = NULL;\n\telse\n\t{\n\t    retval = vim_strsave(((char_u **)(gap->ga_data))[fcp->linenr++]);\n\t    SOURCING_LNUM = fcp->linenr;\n#ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t\tfunc_line_start(cookie, SOURCING_LNUM);\n#endif\n\t}\n    }\n\n    // Did we encounter a breakpoint?\n    if (fcp->breakpoint != 0 && fcp->breakpoint <= SOURCING_LNUM)\n    {\n\tdbg_breakpoint(fp->uf_name, SOURCING_LNUM);\n\t// Find next breakpoint.\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if the currently active function should be ended, because a\n * return was encountered or an error occurred.  Used inside a \":while\".\n */\n    int\nfunc_has_ended(void *cookie)\n{\n    funccall_T  *fcp = (funccall_T *)cookie;\n\n    // Ignore the \"abort\" flag if the abortion behavior has been changed due to\n    // an error inside a try conditional.\n    return (((fcp->func->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned);\n}\n\n/*\n * return TRUE if cookie indicates a function which \"abort\"s on errors.\n */\n    int\nfunc_has_abort(\n    void    *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_flags & FC_ABORT;\n}\n\n\n/*\n * Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n * Don't do this when \"Func\" is already a partial that was bound\n * explicitly (pt_auto is FALSE).\n * Changes \"rettv\" in-place.\n * Returns the updated \"selfdict_in\".\n */\n    dict_T *\nmake_partial(dict_T *selfdict_in, typval_T *rettv)\n{\n    char_u\t*fname;\n    char_u\t*tofree = NULL;\n    ufunc_T\t*fp;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    int\t\terror;\n    dict_T\t*selfdict = selfdict_in;\n\n    if (rettv->v_type == VAR_PARTIAL && rettv->vval.v_partial->pt_func != NULL)\n\tfp = rettv->vval.v_partial->pt_func;\n    else\n    {\n\tfname = rettv->v_type == VAR_FUNC ? rettv->vval.v_string\n\t\t\t\t\t      : rettv->vval.v_partial->pt_name;\n\t// Translate \"s:func\" to the stored function name.\n\tfname = fname_trans_sid(fname, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE, NULL);\n\tvim_free(tofree);\n    }\n\n    if (fp != NULL && (fp->uf_flags & FC_DICT))\n    {\n\tpartial_T\t*pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt != NULL)\n\t{\n\t    pt->pt_refcount = 1;\n\t    pt->pt_dict = selfdict;\n\t    pt->pt_auto = TRUE;\n\t    selfdict = NULL;\n\t    if (rettv->v_type == VAR_FUNC)\n\t    {\n\t\t// Just a function: Take over the function name and use\n\t\t// selfdict.\n\t\tpt->pt_name = rettv->vval.v_string;\n\t    }\n\t    else\n\t    {\n\t\tpartial_T\t*ret_pt = rettv->vval.v_partial;\n\t\tint\t\ti;\n\n\t\t// Partial: copy the function name, use selfdict and copy\n\t\t// args.  Can't take over name or args, the partial might\n\t\t// be referenced elsewhere.\n\t\tif (ret_pt->pt_name != NULL)\n\t\t{\n\t\t    pt->pt_name = vim_strsave(ret_pt->pt_name);\n\t\t    func_ref(pt->pt_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    pt->pt_func = ret_pt->pt_func;\n\t\t    func_ptr_ref(pt->pt_func);\n\t\t}\n\t\tif (ret_pt->pt_argc > 0)\n\t\t{\n\t\t    pt->pt_argv = ALLOC_MULT(typval_T, ret_pt->pt_argc);\n\t\t    if (pt->pt_argv == NULL)\n\t\t\t// out of memory: drop the arguments\n\t\t\tpt->pt_argc = 0;\n\t\t    else\n\t\t    {\n\t\t\tpt->pt_argc = ret_pt->pt_argc;\n\t\t\tfor (i = 0; i < pt->pt_argc; i++)\n\t\t\t    copy_tv(&ret_pt->pt_argv[i], &pt->pt_argv[i]);\n\t\t    }\n\t\t}\n\t\tpartial_unref(ret_pt);\n\t    }\n\t    rettv->v_type = VAR_PARTIAL;\n\t    rettv->vval.v_partial = pt;\n\t}\n    }\n    return selfdict;\n}\n\n/*\n * Return the name of the executed function.\n */\n    char_u *\nfunc_name(void *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_name;\n}\n\n/*\n * Return the address holding the next breakpoint line for a funccall cookie.\n */\n    linenr_T *\nfunc_breakpoint(void *cookie)\n{\n    return &((funccall_T *)cookie)->breakpoint;\n}\n\n/*\n * Return the address holding the debug tick for a funccall cookie.\n */\n    int *\nfunc_dbg_tick(void *cookie)\n{\n    return &((funccall_T *)cookie)->dbg_tick;\n}\n\n/*\n * Return the nesting level for a funccall cookie.\n */\n    int\nfunc_level(void *cookie)\n{\n    return ((funccall_T *)cookie)->level;\n}\n\n/*\n * Return TRUE when a function was ended by a \":return\" command.\n */\n    int\ncurrent_func_returned(void)\n{\n    return current_funccal->returned;\n}\n\n    int\nfree_unref_funccal(int copyID, int testing)\n{\n    int\t\tdid_free = FALSE;\n    int\t\tdid_free_funccal = FALSE;\n    funccall_T\t*fc, **pfc;\n\n    for (pfc = &previous_funccal; *pfc != NULL; )\n    {\n\tif (can_free_funccal(*pfc, copyID))\n\t{\n\t    fc = *pfc;\n\t    *pfc = fc->caller;\n\t    free_funccal_contents(fc);\n\t    did_free = TRUE;\n\t    did_free_funccal = TRUE;\n\t}\n\telse\n\t    pfc = &(*pfc)->caller;\n    }\n    if (did_free_funccal)\n\t// When a funccal was freed some more items might be garbage\n\t// collected, so run again.\n\t(void)garbage_collect(testing);\n\n    return did_free;\n}\n\n/*\n * Get function call environment based on backtrace debug level\n */\n    static funccall_T *\nget_funccal(void)\n{\n    int\t\ti;\n    funccall_T\t*funccal;\n    funccall_T\t*temp_funccal;\n\n    funccal = current_funccal;\n    if (debug_backtrace_level > 0)\n    {\n\tfor (i = 0; i < debug_backtrace_level; i++)\n\t{\n\t    temp_funccal = funccal->caller;\n\t    if (temp_funccal)\n\t\tfunccal = temp_funccal;\n\t    else\n\t\t// backtrace level overflow. reset to max\n\t\tdebug_backtrace_level = i;\n\t}\n    }\n    return funccal;\n}\n\n/*\n * Return the hashtable used for local variables in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_local_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars.dv_hashtab;\n}\n\n/*\n * Return the l: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_local_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars_var;\n}\n\n/*\n * Return the hashtable used for argument in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_args_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars.dv_hashtab;\n}\n\n/*\n * Return the a: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_args_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars_var;\n}\n\n/*\n * List function variables, if there is a function.\n */\n    void\nlist_func_vars(int *first)\n{\n    if (current_funccal != NULL && current_funccal->l_vars.dv_refcount > 0)\n\tlist_hashtable_vars(&current_funccal->l_vars.dv_hashtab,\n\t\t\t\t\t\t\t   \"l:\", FALSE, first);\n}\n\n/*\n * If \"ht\" is the hashtable for local variables in the current funccal, return\n * the dict that contains it.\n * Otherwise return NULL.\n */\n    dict_T *\nget_current_funccal_dict(hashtab_T *ht)\n{\n    if (current_funccal != NULL\n\t    && ht == &current_funccal->l_vars.dv_hashtab)\n\treturn &current_funccal->l_vars;\n    return NULL;\n}\n\n/*\n * Search hashitem in parent scope.\n */\n    hashitem_T *\nfind_hi_in_scoped_ht(char_u *name, hashtab_T **pht)\n{\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    hashitem_T\t*hi = NULL;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n      return NULL;\n\n    // Search in parent scope, which can be referenced from a lambda.\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal != NULL)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    hi = hash_find(ht, varname);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t*pht = ht;\n\t\tbreak;\n\t    }\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return hi;\n}\n\n/*\n * Search variable in parent scope.\n */\n    dictitem_T *\nfind_var_in_scoped_ht(char_u *name, int no_autoload)\n{\n    dictitem_T\t*v = NULL;\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n\treturn NULL;\n\n    // Search in parent scope which is possible to reference from lambda\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    v = find_var_in_ht(ht, *name, varname, no_autoload);\n\t    if (v != NULL)\n\t\tbreak;\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return v;\n}\n\n/*\n * Set \"copyID + 1\" in previous_funccal and callers.\n */\n    int\nset_ref_in_previous_funccal(int copyID)\n{\n    funccall_T\t*fc;\n\n    for (fc = previous_funccal; fc != NULL; fc = fc->caller)\n    {\n\tfc->fc_copyID = copyID + 1;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID + 1, NULL))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n    static int\nset_ref_in_funccal(funccall_T *fc, int copyID)\n{\n    if (fc->fc_copyID != copyID)\n    {\n\tfc->fc_copyID = copyID;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID, NULL)\n\t\t|| set_ref_in_func(NULL, fc->func, copyID))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all local vars and arguments in the call stack.\n */\n    int\nset_ref_in_call_stack(int copyID)\n{\n    funccall_T\t\t*fc;\n    funccal_entry_T\t*entry;\n\n    for (fc = current_funccal; fc != NULL; fc = fc->caller)\n\tif (set_ref_in_funccal(fc, copyID))\n\t    return TRUE;\n\n    // Also go through the funccal_stack.\n    for (entry = funccal_stack; entry != NULL; entry = entry->next)\n\tfor (fc = entry->top_funccal; fc != NULL; fc = fc->caller)\n\t    if (set_ref_in_funccal(fc, copyID))\n\t\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all functions available by name.\n */\n    int\nset_ref_in_functions(int copyID)\n{\n    int\t\ttodo;\n    hashitem_T\t*hi = NULL;\n    ufunc_T\t*fp;\n\n    todo = (int)func_hashtab.ht_used;\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    fp = HI2UF(hi);\n\t    if (!func_name_refcount(fp->uf_name)\n\t\t\t\t\t  && set_ref_in_func(NULL, fp, copyID))\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all function arguments.\n */\n    int\nset_ref_in_func_args(int copyID)\n{\n    int i;\n\n    for (i = 0; i < funcargs.ga_len; ++i)\n\tif (set_ref_in_item(((typval_T **)funcargs.ga_data)[i],\n\t\t\t\t\t\t\t  copyID, NULL, NULL))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through function \"name\" with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID)\n{\n    ufunc_T\t*fp = fp_in;\n    funccall_T\t*fc;\n    int\t\terror = FCERR_NONE;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname;\n    int\t\tabort = FALSE;\n\n    if (name == NULL && fp_in == NULL)\n\treturn FALSE;\n\n    if (fp_in == NULL)\n    {\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE, NULL);\n    }\n    if (fp != NULL)\n    {\n\tfor (fc = fp->uf_scoped; fc != NULL; fc = fc->func->uf_scoped)\n\t    abort = abort || set_ref_in_funccal(fc, copyID);\n    }\n\n    vim_free(tofree);\n    return abort;\n}\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9compile.c: compiling a :def function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n// Functions defined with :def are stored in this growarray.\n// They are never removed, so that they can be found by index.\n// Deleted functions have the df_deleted flag set.\ngarray_T def_functions = {0, 0, sizeof(dfunc_T), 50, NULL};\n\nstatic void delete_def_function_contents(dfunc_T *dfunc, int mark_deleted);\n\n/*\n * Lookup variable \"name\" in the local scope and return it in \"lvar\".\n * \"lvar->lv_from_outer\" is incremented accordingly.\n * If \"lvar\" is NULL only check if the variable can be found.\n * Return FAIL if not found.\n */\n    int\nlookup_local(char_u *name, size_t len, lvar_T *lvar, cctx_T *cctx)\n{\n    int\t    idx;\n    lvar_T  *lvp;\n\n    if (len == 0)\n\treturn FAIL;\n\n    // Find local in current function scope.\n    for (idx = 0; idx < cctx->ctx_locals.ga_len; ++idx)\n    {\n\tlvp = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\tif (STRNCMP(name, lvp->lv_name, len) == 0\n\t\t\t\t\t       && STRLEN(lvp->lv_name) == len)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\t*lvar = *lvp;\n\t\tlvar->lv_from_outer = 0;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    // Find local in outer function scope.\n    if (cctx->ctx_outer != NULL)\n    {\n\tif (lookup_local(name, len, lvar, cctx->ctx_outer) == OK)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\tcctx->ctx_outer_used = TRUE;\n\t\t++lvar->lv_from_outer;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup an argument in the current function and an enclosing function.\n * Returns the argument index in \"idxp\"\n * Returns the argument type in \"type\"\n * Sets \"gen_load_outer\" to TRUE if found in outer scope.\n * Returns OK when found, FAIL otherwise.\n */\n    int\narg_exists(\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\t*idxp,\n\ttype_T\t**type,\n\tint\t*gen_load_outer,\n\tcctx_T\t*cctx)\n{\n    int\t    idx;\n    char_u  *va_name;\n\n    if (len == 0)\n\treturn FAIL;\n    for (idx = 0; idx < cctx->ctx_ufunc->uf_args_visible; ++idx)\n    {\n\tchar_u *arg = FUNCARG(cctx->ctx_ufunc, idx);\n\n\tif (STRNCMP(name, arg, len) == 0 && arg[len] == NUL)\n\t{\n\t    if (idxp != NULL)\n\t    {\n\t\t// Arguments are located above the frame pointer.  One further\n\t\t// if there is a vararg argument\n\t\t*idxp = idx - (cctx->ctx_ufunc->uf_args.ga_len\n\t\t\t\t\t\t\t    + STACK_FRAME_SIZE)\n\t\t\t      + (cctx->ctx_ufunc->uf_va_name != NULL ? -1 : 0);\n\n\t\tif (cctx->ctx_ufunc->uf_arg_types != NULL)\n\t\t    *type = cctx->ctx_ufunc->uf_arg_types[idx];\n\t\telse\n\t\t    *type = &t_any;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    va_name = cctx->ctx_ufunc->uf_va_name;\n    if (va_name != NULL\n\t\t    && STRNCMP(name, va_name, len) == 0 && va_name[len] == NUL)\n    {\n\tif (idxp != NULL)\n\t{\n\t    // varargs is always the last argument\n\t    *idxp = -STACK_FRAME_SIZE - 1;\n\t    *type = cctx->ctx_ufunc->uf_va_type;\n\t}\n\treturn OK;\n    }\n\n    if (cctx->ctx_outer != NULL)\n    {\n\t// Lookup the name for an argument of the outer function.\n\tif (arg_exists(name, len, idxp, type, gen_load_outer, cctx->ctx_outer)\n\t\t\t\t\t\t\t\t\t == OK)\n\t{\n\t    if (gen_load_outer != NULL)\n\t\t++*gen_load_outer;\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup a script-local variable in the current script, possibly defined in a\n * block that contains the function \"cctx->ctx_ufunc\".\n * \"cctx\" is NULL at the script level.\n * If \"len\" is <= 0 \"name\" must be NUL terminated.\n * Return NULL when not found.\n */\n    static sallvar_T *\nfind_script_var(char_u *name, size_t len, cctx_T *cctx)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);\n    hashitem_T\t    *hi;\n    int\t\t    cc;\n    sallvar_T\t    *sav;\n    ufunc_T\t    *ufunc;\n\n    // Find the list of all script variables with the right name.\n    if (len > 0)\n    {\n\tcc = name[len];\n\tname[len] = NUL;\n    }\n    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n    if (len > 0)\n\tname[len] = cc;\n    if (HASHITEM_EMPTY(hi))\n\treturn NULL;\n\n    sav = HI2SAV(hi);\n    if (sav->sav_block_id == 0)\n\t// variable defined in the top script scope is always visible\n\treturn sav;\n\n    if (cctx == NULL)\n    {\n\t// Not in a function scope, find variable with block id equal to or\n\t// smaller than the current block id.\n\twhile (sav != NULL)\n\t{\n\t    if (sav->sav_block_id <= si->sn_current_block_id)\n\t\tbreak;\n\t    sav = sav->sav_next;\n\t}\n\treturn sav;\n    }\n\n    // Go over the variables with this name and find one that was visible\n    // from the function.\n    ufunc = cctx->ctx_ufunc;\n    while (sav != NULL)\n    {\n\tint idx;\n\n\t// Go over the blocks that this function was defined in.  If the\n\t// variable block ID matches it was visible to the function.\n\tfor (idx = 0; idx < ufunc->uf_block_depth; ++idx)\n\t    if (ufunc->uf_block_ids[idx] == sav->sav_block_id)\n\t\treturn sav;\n\tsav = sav->sav_next;\n    }\n\n    // Not found, variable was not visible.\n    return NULL;\n}\n\n/*\n * Return TRUE if the script context is Vim9 script.\n */\n    int\nscript_is_vim9()\n{\n    return SCRIPT_ITEM(current_sctx.sc_sid)->sn_version == SCRIPT_VERSION_VIM9;\n}\n\n/*\n * Lookup a variable (without s: prefix) in the current script.\n * \"cctx\" is NULL at the script level.\n * Returns OK or FAIL.\n */\n    int\nscript_var_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    if (current_sctx.sc_sid <= 0)\n\treturn FAIL;\n    if (script_is_vim9())\n    {\n\t// Check script variables that were visible where the function was\n\t// defined.\n\tif (find_script_var(name, len, cctx) != NULL)\n\t    return OK;\n    }\n    else\n    {\n\thashtab_T\t*ht = &SCRIPT_VARS(current_sctx.sc_sid);\n\tdictitem_T\t*di;\n\tint\t\tcc;\n\n\t// Check script variables that are currently visible\n\tcc = name[len];\n\tname[len] = NUL;\n\tdi = find_var_in_ht(ht, 0, name, TRUE);\n\tname[len] = cc;\n\tif (di != NULL)\n\t    return OK;\n    }\n\n    return FAIL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable or\n * imported.\n */\n    static int\nvariable_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    return (cctx != NULL\n\t\t&& (lookup_local(name, len, NULL, cctx) == OK\n\t\t    || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK))\n\t    || script_var_exists(name, len, cctx) == OK\n\t    || find_imported(name, len, cctx) != NULL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable,\n * imported or function.\n */\n    static int\nitem_exists(char_u *name, size_t len, int cmd UNUSED, cctx_T *cctx)\n{\n    int\t    is_global;\n    char_u  *p;\n\n    if (variable_exists(name, len, cctx))\n\treturn TRUE;\n\n    // This is similar to what is in lookup_scriptitem():\n    // Find a function, so that a following \"->\" works.\n    // Require \"(\" or \"->\" to follow, \"Cmd\" is a user command while \"Cmd()\" is\n    // a function call.\n    p = skipwhite(name + len);\n\n    if (name[len] == '(' || (p[0] == '-' && p[1] == '>'))\n    {\n\t// Do not check for an internal function, since it might also be a\n\t// valid command, such as \":split\" versus \"split()\".\n\t// Skip \"g:\" before a function name.\n\tis_global = (name[0] == 'g' && name[1] == ':');\n\treturn find_func(is_global ? name + 2 : name, is_global, cctx) != NULL;\n    }\n    return FALSE;\n}\n\n/*\n * Check if \"p[len]\" is already defined, either in script \"import_sid\" or in\n * compilation context \"cctx\".  \"cctx\" is NULL at the script level.\n * Does not check the global namespace.\n * If \"is_arg\" is TRUE the error message is for an argument name.\n * Return FAIL and give an error if it defined.\n */\n    int\ncheck_defined(char_u *p, size_t len, cctx_T *cctx, int is_arg)\n{\n    int\t\tc = p[len];\n    ufunc_T\t*ufunc = NULL;\n\n    // underscore argument is OK\n    if (len == 1 && *p == '_')\n\treturn OK;\n\n    if (script_var_exists(p, len, cctx) == OK)\n    {\n\tif (is_arg)\n\t    semsg(_(e_argument_already_declared_in_script_str), p);\n\telse\n\t    semsg(_(e_variable_already_declared_in_script_str), p);\n\treturn FAIL;\n    }\n\n    p[len] = NUL;\n    if ((cctx != NULL\n\t\t&& (lookup_local(p, len, NULL, cctx) == OK\n\t\t    || arg_exists(p, len, NULL, NULL, NULL, cctx) == OK))\n\t    || find_imported(p, len, cctx) != NULL\n\t    || (ufunc = find_func_even_dead(p, FALSE, cctx)) != NULL)\n    {\n\t// A local or script-local function can shadow a global function.\n\tif (ufunc == NULL || ((ufunc->uf_flags & FC_DEAD) == 0\n\t\t    && (!func_is_global(ufunc)\n\t\t\t\t\t     || (p[0] == 'g' && p[1] == ':'))))\n\t{\n\t    if (is_arg)\n\t\tsemsg(_(e_argument_name_shadows_existing_variable_str), p);\n\t    else\n\t\tsemsg(_(e_name_already_defined_str), p);\n\t    p[len] = c;\n\t    return FAIL;\n\t}\n    }\n    p[len] = c;\n    return OK;\n}\n\n\n/*\n * Return TRUE if \"actual\" could be \"expected\" and a runtime typecheck is to be\n * used.  Return FALSE if the types will never match.\n */\n    static int\nuse_typecheck(type_T *actual, type_T *expected)\n{\n    if (actual->tt_type == VAR_ANY\n\t    || actual->tt_type == VAR_UNKNOWN\n\t    || (actual->tt_type == VAR_FUNC\n\t\t&& (expected->tt_type == VAR_FUNC\n\t\t\t\t\t   || expected->tt_type == VAR_PARTIAL)\n\t\t&& (actual->tt_member == &t_any\n\t\t    || actual->tt_member == &t_unknown\n\t\t    || actual->tt_argcount < 0)\n\t\t&& (actual->tt_member == &t_unknown ||\n\t\t    (actual->tt_member == &t_void)\n\t\t\t\t\t == (expected->tt_member == &t_void))))\n\treturn TRUE;\n    if ((actual->tt_type == VAR_LIST || actual->tt_type == VAR_DICT)\n\t\t\t\t       && actual->tt_type == expected->tt_type)\n\t// This takes care of a nested list or dict.\n\treturn use_typecheck(actual->tt_member, expected->tt_member);\n    return FALSE;\n}\n\n/*\n * Check that\n * - \"actual\" matches \"expected\" type or\n * - \"actual\" is a type that can be \"expected\" type: add a runtime check; or\n * - return FAIL.\n * If \"actual_is_const\" is TRUE then the type won't change at runtime, do not\n * generate a TYPECHECK.\n */\n    static int\nneed_type_where(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\twhere_T\twhere,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    int ret;\n\n    if (expected == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n    {\n\t// Using \"0\", \"1\" or the result of an expression with \"&&\" or \"||\" as a\n\t// boolean is OK but requires a conversion.\n\tgenerate_2BOOL(cctx, FALSE, offset);\n\treturn OK;\n    }\n\n    ret = check_type_maybe(expected, actual, FALSE, where);\n    if (ret == OK)\n\treturn OK;\n\n    // If the actual type can be the expected type add a runtime check.\n    // If it's a constant a runtime check makes no sense.\n    if (!actual_is_const && ret == MAYBE && use_typecheck(actual, expected))\n    {\n\tgenerate_TYPECHECK(cctx, expected, offset, where.wt_index);\n\treturn OK;\n    }\n\n    if (!silent)\n\ttype_mismatch_where(expected, actual, where);\n    return FAIL;\n}\n\n    int\nneed_type(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\tint\targ_idx,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    where_T where = WHERE_INIT;\n\n    where.wt_index = arg_idx;\n    return need_type_where(actual, expected, offset, where,\n\t\t\t\t\t\tcctx, silent, actual_is_const);\n}\n\n/*\n * Reserve space for a local variable.\n * Return the variable or NULL if it failed.\n */\n    lvar_T *\nreserve_local(\n\tcctx_T\t*cctx,\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\tisConst,\n\ttype_T\t*type)\n{\n    lvar_T  *lvar;\n    dfunc_T *dfunc;\n\n    if (arg_exists(name, len, NULL, NULL, NULL, cctx) == OK)\n    {\n\temsg_namelen(_(e_str_is_used_as_argument), name, (int)len);\n\treturn NULL;\n    }\n\n    if (GA_GROW_FAILS(&cctx->ctx_locals, 1))\n\treturn NULL;\n    lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + cctx->ctx_locals.ga_len++;\n    CLEAR_POINTER(lvar);\n\n    // Every local variable uses the next entry on the stack.  We could re-use\n    // the last ones when leaving a scope, but then variables used in a closure\n    // might get overwritten.  To keep things simple do not re-use stack\n    // entries.  This is less efficient, but memory is cheap these days.\n    dfunc = ((dfunc_T *)def_functions.ga_data) + cctx->ctx_ufunc->uf_dfunc_idx;\n    lvar->lv_idx = dfunc->df_var_names.ga_len;\n\n    lvar->lv_name = vim_strnsave(name, len == 0 ? STRLEN(name) : len);\n    lvar->lv_const = isConst;\n    lvar->lv_type = type;\n\n    // Remember the name for debugging.\n    if (GA_GROW_FAILS(&dfunc->df_var_names, 1))\n\treturn NULL;\n    ((char_u **)dfunc->df_var_names.ga_data)[lvar->lv_idx] =\n\t\t\t\t\t\t    vim_strsave(lvar->lv_name);\n    ++dfunc->df_var_names.ga_len;\n\n    return lvar;\n}\n\n/*\n * If \"check_writable\" is ASSIGN_CONST give an error if the variable was\n * defined with :final or :const, if \"check_writable\" is ASSIGN_FINAL give an\n * error if the variable was defined with :const.\n */\n    static int\ncheck_item_writable(svar_T *sv, int check_writable, char_u *name)\n{\n    if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)\n\t    || (check_writable == ASSIGN_FINAL\n\t\t\t\t\t      && sv->sv_const == ASSIGN_CONST))\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Find \"name\" in script-local items of script \"sid\".\n * Pass \"check_writable\" to check_item_writable().\n * Returns the index in \"sn_var_vals\" if found.\n * If found but not in \"sn_var_vals\" returns -1.\n * If not found or the variable is not writable returns -2.\n */\n    int\nget_script_item_idx(int sid, char_u *name, int check_writable, cctx_T *cctx)\n{\n    hashtab_T\t    *ht;\n    dictitem_T\t    *di;\n    scriptitem_T    *si = SCRIPT_ITEM(sid);\n    svar_T\t    *sv;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn -1;\n    if (sid == current_sctx.sc_sid)\n    {\n\tsallvar_T *sav = find_script_var(name, 0, cctx);\n\n\tif (sav == NULL)\n\t    return -2;\n\tidx = sav->sav_var_vals_idx;\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (check_item_writable(sv, check_writable, name) == FAIL)\n\t    return -2;\n\treturn idx;\n    }\n\n    // First look the name up in the hashtable.\n    ht = &SCRIPT_VARS(sid);\n    di = find_var_in_ht(ht, 0, name, TRUE);\n    if (di == NULL)\n\treturn -2;\n\n    // Now find the svar_T index in sn_var_vals.\n    for (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)\n    {\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (sv->sv_tv == &di->di_tv)\n\t{\n\t    if (check_item_writable(sv, check_writable, name) == FAIL)\n\t\treturn -2;\n\t    return idx;\n\t}\n    }\n    return -1;\n}\n\n/*\n * Find \"name\" in imported items of the current script or in \"cctx\" if not\n * NULL.\n */\n    imported_T *\nfind_imported(char_u *name, size_t len, cctx_T *cctx)\n{\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\treturn NULL;\n    if (cctx != NULL)\n\tfor (idx = 0; idx < cctx->ctx_imports.ga_len; ++idx)\n\t{\n\t    imported_T *import = ((imported_T *)cctx->ctx_imports.ga_data)\n\t\t\t\t\t\t\t\t\t + idx;\n\n\t    if (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t\t : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t\treturn import;\n\t}\n\n    return find_imported_in_script(name, len, current_sctx.sc_sid);\n}\n\n    imported_T *\nfind_imported_in_script(char_u *name, size_t len, int sid)\n{\n    scriptitem_T    *si;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\n    si = SCRIPT_ITEM(sid);\n    for (idx = 0; idx < si->sn_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)si->sn_imports.ga_data) + idx;\n\n\tif (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t     : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t    return import;\n    }\n    return NULL;\n}\n\n/*\n * Free all imported variables.\n */\n    static void\nfree_imported(cctx_T *cctx)\n{\n    int idx;\n\n    for (idx = 0; idx < cctx->ctx_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)cctx->ctx_imports.ga_data) + idx;\n\n\tvim_free(import->imp_name);\n    }\n    ga_clear(&cctx->ctx_imports);\n}\n\n/*\n * Called when checking for a following operator at \"arg\".  When the rest of\n * the line is empty or only a comment, peek the next line.  If there is a next\n * line return a pointer to it and set \"nextp\".\n * Otherwise skip over white space.\n */\n    char_u *\nmay_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp)\n{\n    char_u *p = skipwhite(arg);\n\n    *nextp = NULL;\n    if (*p == NUL || (VIM_ISWHITE(*arg) && vim9_comment_start(p)))\n    {\n\t*nextp = peek_next_line_from_context(cctx);\n\tif (*nextp != NULL)\n\t    return *nextp;\n    }\n    return p;\n}\n\n/*\n * Return a pointer to the next line that isn't empty or only contains a\n * comment. Skips over white space.\n * Returns NULL if there is none.\n */\n    char_u *\npeek_next_line_from_context(cctx_T *cctx)\n{\n    int lnum = cctx->ctx_lnum;\n\n    while (++lnum < cctx->ctx_ufunc->uf_lines.ga_len)\n    {\n\tchar_u *line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[lnum];\n\tchar_u *p;\n\n\t// ignore NULLs inserted for continuation lines\n\tif (line != NULL)\n\t{\n\t    p = skipwhite(line);\n\t    if (vim9_bad_comment(p))\n\t\treturn NULL;\n\t    if (*p != NUL && !vim9_comment_start(p))\n\t\treturn p;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the next line of the function from \"cctx\".\n * Skips over empty lines.  Skips over comment lines if \"skip_comment\" is TRUE.\n * Returns NULL when at the end.\n */\n    char_u *\nnext_line_from_context(cctx_T *cctx, int skip_comment)\n{\n    char_u\t*line;\n\n    do\n    {\n\t++cctx->ctx_lnum;\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len)\n\t{\n\t    line = NULL;\n\t    break;\n\t}\n\tline = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\tcctx->ctx_line_start = line;\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n    } while (line == NULL || *skipwhite(line) == NUL\n\t\t     || (skip_comment && vim9_comment_start(skipwhite(line))));\n    return line;\n}\n\n/*\n * Skip over white space at \"whitep\" and assign to \"*arg\".\n * If \"*arg\" is at the end of the line, advance to the next line.\n * Also when \"whitep\" points to white space and \"*arg\" is on a \"#\".\n * Return FAIL if beyond the last line, \"*arg\" is unmodified then.\n */\n    int\nmay_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    *arg = skipwhite(whitep);\n    if (vim9_bad_comment(*arg))\n\treturn FAIL;\n    if (**arg == NUL || (VIM_ISWHITE(*whitep) && vim9_comment_start(*arg)))\n    {\n\tchar_u *next = next_line_from_context(cctx, TRUE);\n\n\tif (next == NULL)\n\t    return FAIL;\n\t*arg = skipwhite(next);\n    }\n    return OK;\n}\n\n/*\n * Idem, and give an error when failed.\n */\n    int\nmay_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    if (may_get_next_line(whitep, arg, cctx) == FAIL)\n    {\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n\temsg(_(e_line_incomplete));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Get a line from the compilation context, compatible with exarg_T getline().\n * Return a pointer to the line in allocated memory.\n * Return NULL for end-of-file or some error.\n */\n    static char_u *\nexarg_getline(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    cctx_T  *cctx = (cctx_T *)cookie;\n    char_u  *p;\n\n    for (;;)\n    {\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len - 1)\n\t    return NULL;\n\t++cctx->ctx_lnum;\n\tp = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\t// Comment lines result in NULL pointers, skip them.\n\tif (p != NULL)\n\t    return vim_strsave(p);\n    }\n}\n\n    void\nfill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)\n{\n    eap->getline = exarg_getline;\n    eap->cookie = cctx;\n}\n\n/*\n * Return TRUE if \"ufunc\" should be compiled, taking into account whether\n * \"profile\" indicates profiling is to be done.\n */\n    int\nfunc_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)\n{\n    switch (ufunc->uf_def_status)\n    {\n\tcase UF_TO_BE_COMPILED:\n\t    return TRUE;\n\n\tcase UF_COMPILED:\n\t{\n\t    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t    switch (compile_type)\n\t    {\n\t\tcase CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t    return dfunc->df_instr_prof == NULL;\n#endif\n\t\tcase CT_NONE:\n\t\t    return dfunc->df_instr == NULL;\n\t\tcase CT_DEBUG:\n\t\t    return dfunc->df_instr_debug == NULL;\n\t    }\n\t}\n\n\tcase UF_NOT_COMPILED:\n\tcase UF_COMPILE_ERROR:\n\tcase UF_COMPILING:\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Compile a nested :def command.\n */\n    static char_u *\ncompile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n\tif (*name_end == '/')\n\t    ++name_end;\n\tset_nextcmd(eap, name_end);\n    }\n    if (name_end == name_start || *skipwhite(name_end) != '(')\n    {\n\tif (!ends_excmd2(name_start, name_end))\n\t{\n\t    semsg(_(e_invalid_command_str), eap->cmd);\n\t    return NULL;\n\t}\n\n\t// \"def\" or \"def Name\": list functions\n\tif (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)\n\t    return NULL;\n\treturn eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n    }\n\n    // Only g:Func() can use a namespace.\n    if (name_start[1] == ':' && !is_global)\n    {\n\tsemsg(_(e_namespace_not_supported_str), name_start);\n\treturn NULL;\n    }\n    if (check_defined(name_start, name_end - name_start, cctx, FALSE) == FAIL)\n\treturn NULL;\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    // This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, line_to_free);\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n    if (eap->nextcmd != NULL)\n    {\n\tsemsg(_(e_text_found_after_str_str),\n\t      eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);\n\tr = FAIL;\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\tint block_depth = cctx->ctx_ufunc->uf_block_depth;\n\n\tufunc->uf_block_ids = ALLOC_MULT(int, block_depth);\n\tif (ufunc->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,\n\t\t\t\t\t\t    sizeof(int) * block_depth);\n\t    ufunc->uf_block_depth = block_depth;\n\t}\n    }\n\n    compile_type = COMPILE_TYPE(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}\n\n/*\n * Return the length of an assignment operator, or zero if there isn't one.\n */\n    int\nassignment_len(char_u *p, int *heredoc)\n{\n    if (*p == '=')\n    {\n\tif (p[1] == '<' && p[2] == '<')\n\t{\n\t    *heredoc = TRUE;\n\t    return 3;\n\t}\n\treturn 1;\n    }\n    if (vim_strchr((char_u *)\"+-*/%\", *p) != NULL && p[1] == '=')\n\treturn 2;\n    if (STRNCMP(p, \"..=\", 3) == 0)\n\treturn 3;\n    return 0;\n}\n\n/*\n * Generate the load instruction for \"name\".\n */\n    static void\ngenerate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t\tgenerate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t    name + (name[1] == ':' ? 2 : 0), NULL, NULL, TRUE);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2, TRUE);\n\t    break;\n\tcase dest_local:\n\t    if (lvar->lv_from_outer > 0)\n\t\tgenerate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}\n\n/*\n * Skip over \"[expr]\" or \".member\".\n * Does not check for any errors.\n */\n    static char_u *\nskip_index(char_u *start)\n{\n    char_u *p = start;\n\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\t(void)skip_expr(&p, NULL);\n\tp = skipwhite(p);\n\tif (*p == ']')\n\t    return p + 1;\n\treturn p;\n    }\n    // if (*p == '.')\n    return to_name_end(p + 1, TRUE);\n}\n\n    void\nvim9_declare_error(char_u *name)\n{\n    char *scope = \"\";\n\n    switch (*name)\n    {\n\tcase 'g': scope = _(\"global\"); break;\n\tcase 'b': scope = _(\"buffer\"); break;\n\tcase 'w': scope = _(\"window\"); break;\n\tcase 't': scope = _(\"tab\"); break;\n\tcase 'v': scope = \"v:\"; break;\n\tcase '$': semsg(_(e_cannot_declare_an_environment_variable), name);\n\t\t  return;\n\tcase '&': semsg(_(e_cannot_declare_an_option), name);\n\t\t  return;\n\tcase '@': semsg(_(e_cannot_declare_a_register_str), name);\n\t\t  return;\n\tdefault: return;\n    }\n    semsg(_(e_cannot_declare_a_scope_variable), scope, name);\n}\n\n/*\n * For one assignment figure out the type of destination.  Return it in \"dest\".\n * When not recognized \"dest\" is not set.\n * For an option \"option_scope\" is set.\n * For a v:var \"vimvaridx\" is set.\n * \"type\" is set to the destination type if known, unchanted otherwise.\n * Return FAIL if an error message was given.\n */\n    int\nget_var_dest(\n\tchar_u\t\t*name,\n\tassign_dest_T\t*dest,\n\tint\t\tcmdidx,\n\tint\t\t*option_scope,\n\tint\t\t*vimvaridx,\n\ttype_T\t\t**type,\n\tcctx_T\t\t*cctx)\n{\n    char_u *p;\n\n    if (*name == '&')\n    {\n\tint\t\tcc;\n\tlong\t\tnumval;\n\tgetoption_T\topt_type;\n\tint\t\topt_p_flags;\n\n\t*dest = dest_option;\n\tif (cmdidx == CMD_final || cmdidx == CMD_const)\n\t{\n\t    emsg(_(e_cannot_lock_option));\n\t    return FAIL;\n\t}\n\tp = name;\n\tp = find_option_end(&p, option_scope);\n\tif (p == NULL)\n\t{\n\t    // cannot happen?\n\t    emsg(_(e_unexpected_characters_in_assignment));\n\t    return FAIL;\n\t}\n\tcc = *p;\n\t*p = NUL;\n\topt_type = get_option_value(skip_option_env_lead(name),\n\t\t\t\t   &numval, NULL, &opt_p_flags, *option_scope);\n\t*p = cc;\n\tswitch (opt_type)\n\t{\n\t    case gov_unknown:\n\t\t    semsg(_(e_unknown_option_str), name);\n\t\t    return FAIL;\n\t    case gov_string:\n\t    case gov_hidden_string:\n\t\t    if (opt_p_flags & P_FUNC)\n\t\t    {\n\t\t\t// might be a Funcref, check the type later\n\t\t\t*type = &t_any;\n\t\t\t*dest = dest_func_option;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t*type = &t_string;\n\t\t    }\n\t\t    break;\n\t    case gov_bool:\n\t    case gov_hidden_bool:\n\t\t    *type = &t_bool;\n\t\t    break;\n\t    case gov_number:\n\t    case gov_hidden_number:\n\t\t    *type = &t_number;\n\t\t    break;\n\t}\n    }\n    else if (*name == '$')\n    {\n\t*dest = dest_env;\n\t*type = &t_string;\n    }\n    else if (*name == '@')\n    {\n\tif (name[1] != '@'\n\t\t\t&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))\n\t{\n\t    emsg_invreg(name[1]);\n\t    return FAIL;\n\t}\n\t*dest = dest_reg;\n\t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n    }\n    else if (STRNCMP(name, \"g:\", 2) == 0)\n    {\n\t*dest = dest_global;\n    }\n    else if (STRNCMP(name, \"b:\", 2) == 0)\n    {\n\t*dest = dest_buffer;\n    }\n    else if (STRNCMP(name, \"w:\", 2) == 0)\n    {\n\t*dest = dest_window;\n    }\n    else if (STRNCMP(name, \"t:\", 2) == 0)\n    {\n\t*dest = dest_tab;\n    }\n    else if (STRNCMP(name, \"v:\", 2) == 0)\n    {\n\ttypval_T\t*vtv;\n\tint\t\tdi_flags;\n\n\t*vimvaridx = find_vim_var(name + 2, &di_flags);\n\tif (*vimvaridx < 0)\n\t{\n\t    semsg(_(e_variable_not_found_str), name);\n\t    return FAIL;\n\t}\n\t// We use the current value of \"sandbox\" here, is that OK?\n\tif (var_check_ro(di_flags, name, FALSE))\n\t    return FAIL;\n\t*dest = dest_vimvar;\n\tvtv = get_vim_var_tv(*vimvaridx);\n\t*type = typval2type_vimvar(vtv, cctx->ctx_type_list);\n    }\n    return OK;\n}\n\n    static int\nis_decl_command(int cmdidx)\n{\n    return cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_final || cmdidx == CMD_const;\n}\n\n/*\n * Figure out the LHS type and other properties for an assignment or one item\n * of \":unlet\" with an index.\n * Returns OK or FAIL.\n */\n    int\ncompile_lhs(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tcmdidx,\n\tint\theredoc,\n\tint\toplen,\n\tcctx_T\t*cctx)\n{\n    char_u\t*var_end;\n    int\t\tis_decl = is_decl_command(cmdidx);\n\n    CLEAR_POINTER(lhs);\n    lhs->lhs_dest = dest_local;\n    lhs->lhs_vimvaridx = -1;\n    lhs->lhs_scriptvar_idx = -1;\n\n    // \"dest_end\" is the end of the destination, including \"[expr]\" or\n    // \".name\".\n    // \"var_end\" is the end of the variable/option/etc. name.\n    lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n    if (*var_start == '@')\n\tvar_end = var_start + 2;\n    else\n    {\n\t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"\n\tvar_end = skip_option_env_lead(var_start);\n\tvar_end = to_name_end(var_end, TRUE);\n    }\n\n    // \"a: type\" is declaring variable \"a\" with a type, not dict \"a:\".\n    if (is_decl && lhs->lhs_dest_end == var_start + 2\n\t\t\t\t\t       && lhs->lhs_dest_end[-1] == ':')\n\t--lhs->lhs_dest_end;\n    if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')\n\t--var_end;\n    lhs->lhs_end = lhs->lhs_dest_end;\n\n    // compute the length of the destination without \"[expr]\" or \".name\"\n    lhs->lhs_varlen = var_end - var_start;\n    lhs->lhs_varlen_total = lhs->lhs_varlen;\n    lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);\n    if (lhs->lhs_name == NULL)\n\treturn FAIL;\n\n    if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tlhs->lhs_has_index = TRUE;\n\n    if (heredoc)\n\tlhs->lhs_type = &t_list_string;\n    else\n\tlhs->lhs_type = &t_any;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tint\t    declare_error = FALSE;\n\n\tif (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,\n\t\t\t\t      &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,\n\t\t\t\t\t\t &lhs->lhs_type, cctx) == FAIL)\n\t    return FAIL;\n\tif (lhs->lhs_dest != dest_local\n\t\t\t\t && cmdidx != CMD_const && cmdidx != CMD_final)\n\t{\n\t    // Specific kind of variable recognized.\n\t    declare_error = is_decl;\n\t}\n\telse\n\t{\n\t    // No specific kind of variable recognized, just a name.\n\t    if (check_reserved_name(lhs->lhs_name) == FAIL)\n\t\treturn FAIL;\n\n\t    if (lookup_local(var_start, lhs->lhs_varlen,\n\t\t\t\t\t     &lhs->lhs_local_lvar, cctx) == OK)\n\t\tlhs->lhs_lvar = &lhs->lhs_local_lvar;\n\t    else\n\t    {\n\t\tCLEAR_FIELD(lhs->lhs_arg_lvar);\n\t\tif (arg_exists(var_start, lhs->lhs_varlen,\n\t\t\t &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,\n\t\t\t    &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)\n\t\t{\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tsemsg(_(e_str_is_used_as_argument), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    lhs->lhs_lvar = &lhs->lhs_arg_lvar;\n\t\t}\n\t    }\n\t    if (lhs->lhs_lvar != NULL)\n\t    {\n\t\tif (is_decl)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), lhs->lhs_name);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tint script_namespace = lhs->lhs_varlen > 1\n\t\t\t\t       && STRNCMP(var_start, \"s:\", 2) == 0;\n\t\tint script_var = (script_namespace\n\t\t\t? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,\n\t\t\t\t\t\t\t\t\t  cctx)\n\t\t\t  : script_var_exists(var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\t\t  cctx)) == OK;\n\t\timported_T  *import =\n\t\t\t       find_imported(var_start, lhs->lhs_varlen, cctx);\n\n\t\tif (script_namespace || script_var || import != NULL)\n\t\t{\n\t\t    char_u\t*rawname = lhs->lhs_name\n\t\t\t\t\t   + (lhs->lhs_name[1] == ':' ? 2 : 0);\n\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tif (script_namespace)\n\t\t\t    semsg(_(e_cannot_declare_script_variable_in_function),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\telse\n\t\t\t    semsg(_(e_variable_already_declared_in_script_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    else if (cctx->ctx_ufunc->uf_script_ctx_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t\t\t\t    && script_namespace\n\t\t\t\t    && !script_var && import == NULL)\n\t\t    {\n\t\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\n\t\t    lhs->lhs_dest = dest_script;\n\n\t\t    // existing script-local variables should have a type\n\t\t    lhs->lhs_scriptvar_sid = current_sctx.sc_sid;\n\t\t    if (import != NULL)\n\t\t    {\n\t\t\tchar_u\t*dot = vim_strchr(var_start, '.');\n\t\t\tchar_u\t*p;\n\n\t\t\t// for an import the name is what comes after the dot\n\t\t\tif (dot == NULL)\n\t\t\t{\n\t\t\t    semsg(_(e_no_dot_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tp = skipwhite(dot + 1);\n\t\t\tvar_end = to_name_end(p, TRUE);\n\t\t\tif (var_end == p)\n\t\t\t{\n\t\t\t    semsg(_(e_missing_name_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tvim_free(lhs->lhs_name);\n\t\t\tlhs->lhs_varlen = var_end - p;\n\t\t\tlhs->lhs_name = vim_strnsave(p, lhs->lhs_varlen);\n\t\t\tif (lhs->lhs_name == NULL)\n\t\t\t    return FAIL;\n\t\t\trawname = lhs->lhs_name;\n\t\t\tlhs->lhs_scriptvar_sid = import->imp_sid;\n\t\t\t// TODO: where do we check this name is exported?\n\n\t\t\t// Check if something follows: \"exp.var[idx]\" or\n\t\t\t// \"exp.var.key\".\n\t\t\tlhs->lhs_has_index = lhs->lhs_dest_end\n\t\t\t\t\t\t\t  > skipwhite(var_end);\n\t\t    }\n\t\t    if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))\n\t\t    {\n\t\t\t// Check writable only when no index follows.\n\t\t\tlhs->lhs_scriptvar_idx = get_script_item_idx(\n\t\t\t\t\t       lhs->lhs_scriptvar_sid, rawname,\n\t\t\t      lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,\n\t\t\t\t\t\t\t\t\t cctx);\n\t\t\tif (lhs->lhs_scriptvar_idx >= 0)\n\t\t\t{\n\t\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t\t       lhs->lhs_scriptvar_sid);\n\t\t\t    svar_T\t *sv =\n\t\t\t\t\t    ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t      + lhs->lhs_scriptvar_idx;\n\t\t\t    lhs->lhs_type = sv->sv_type;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (check_defined(var_start, lhs->lhs_varlen, cctx, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\tif (declare_error)\n\t{\n\t    vim9_declare_error(lhs->lhs_name);\n\t    return FAIL;\n\t}\n    }\n\n    // handle \"a:name\" as a name, not index \"name\" in \"a\"\n    if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')\n\tvar_end = lhs->lhs_dest_end;\n\n    if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)\n    {\n\tif (is_decl && *var_end == ':')\n\t{\n\t    char_u *p;\n\n\t    // parse optional type: \"let var: type = expr\"\n\t    if (!VIM_ISWHITE(var_end[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", var_end);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(var_end + 1);\n\t    lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    if (lhs->lhs_type == NULL)\n\t\treturn FAIL;\n\t    lhs->lhs_has_type = TRUE;\n\t    lhs->lhs_end = p;\n\t}\n\telse if (lhs->lhs_lvar != NULL)\n\t    lhs->lhs_type = lhs->lhs_lvar->lv_type;\n    }\n\n    if (oplen == 3 && !heredoc\n\t\t   && lhs->lhs_dest != dest_global\n\t\t   && !lhs->lhs_has_index\n\t\t   && lhs->lhs_type->tt_type != VAR_STRING\n\t\t   && lhs->lhs_type->tt_type != VAR_ANY)\n    {\n\temsg(_(e_can_only_concatenate_to_string));\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local\n\t\t\t\t\t\t && cctx->ctx_skip != SKIP_YES)\n    {\n\tif (oplen > 1 && !heredoc)\n\t{\n\t    // +=, /=, etc. require an existing variable\n\t    semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\tif (!is_decl)\n\t{\n\t    semsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Check the name is valid for a funcref.\n\tif ((lhs->lhs_type->tt_type == VAR_FUNC\n\t\t\t\t      || lhs->lhs_type->tt_type == VAR_PARTIAL)\n\t\t&& var_wrong_func_name(lhs->lhs_name, TRUE))\n\t    return FAIL;\n\n\t// New local variable.\n\tlhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,\n\t\t    cmdidx == CMD_final || cmdidx == CMD_const, lhs->lhs_type);\n\tif (lhs->lhs_lvar == NULL)\n\t    return FAIL;\n\tlhs->lhs_new_local = TRUE;\n    }\n\n    lhs->lhs_member_type = lhs->lhs_type;\n    if (lhs->lhs_has_index)\n    {\n\tchar_u\t*after = var_start + lhs->lhs_varlen;\n\tchar_u\t*p;\n\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tif (is_decl)\n\t{\n\t    emsg(_(e_cannot_use_index_when_declaring_variable));\n\t    return FAIL;\n\t}\n\n\t// Now: var_start[lhs->lhs_varlen] is '[' or '.'\n\t// Only the last index is used below, if there are others\n\t// before it generate code for the expression.  Thus for\n\t// \"ll[1][2]\" the expression is \"ll[1]\" and \"[2]\" is the index.\n\tfor (;;)\n\t{\n\t    p = skip_index(after);\n\t    if (*p != '[' && *p != '.')\n\t    {\n\t\tlhs->lhs_varlen_total = p - var_start;\n\t\tbreak;\n\t    }\n\t    after = p;\n\t}\n\tif (after > var_start + lhs->lhs_varlen)\n\t{\n\t    lhs->lhs_varlen = after - var_start;\n\t    lhs->lhs_dest = dest_expr;\n\t    // We don't know the type before evaluating the expression,\n\t    // use \"any\" until then.\n\t    lhs->lhs_type = &t_any;\n\t}\n\n\tif (lhs->lhs_type->tt_member == NULL)\n\t    lhs->lhs_member_type = &t_any;\n\telse\n\t    lhs->lhs_member_type = lhs->lhs_type->tt_member;\n    }\n    return OK;\n}\n\n/*\n * Figure out the LHS and check a few errors.\n */\n    int\ncompile_assign_lhs(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tcmdidx,\n\tint\tis_decl,\n\tint\theredoc,\n\tint\toplen,\n\tcctx_T\t*cctx)\n{\n    if (compile_lhs(var_start, lhs, cmdidx, heredoc, oplen, cctx) == FAIL)\n\treturn FAIL;\n\n    if (!lhs->lhs_has_index && lhs->lhs_lvar == &lhs->lhs_arg_lvar)\n    {\n\tsemsg(_(e_cannot_assign_to_argument), lhs->lhs_name);\n\treturn FAIL;\n    }\n    if (!is_decl && lhs->lhs_lvar != NULL\n\t\t\t   && lhs->lhs_lvar->lv_const && !lhs->lhs_has_index)\n    {\n\tsemsg(_(e_cannot_assign_to_constant), lhs->lhs_name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Return TRUE if \"lhs\" has a range index: \"[expr : expr]\".\n */\n    static int\nhas_list_index(char_u *idx_start, cctx_T *cctx)\n{\n    char_u  *p = idx_start;\n    int\t    save_skip;\n\n    if (*p != '[')\n\treturn FALSE;\n\n    p = skipwhite(p + 1);\n    if (*p == ':')\n\treturn TRUE;\n\n    save_skip = cctx->ctx_skip;\n    cctx->ctx_skip = SKIP_YES;\n    (void)compile_expr0(&p, cctx);\n    cctx->ctx_skip = save_skip;\n    return *skipwhite(p) == ':';\n}\n\n/*\n * For an assignment with an index, compile the \"idx\" in \"var[idx]\" or \"key\" in\n * \"var.key\".\n */\n    static int\ncompile_assign_index(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\t*range,\n\tcctx_T\t*cctx)\n{\n    size_t\tvarlen = lhs->lhs_varlen;\n    char_u\t*p;\n    int\t\tr = OK;\n    int\t\tneed_white_before = TRUE;\n    int\t\tempty_second;\n\n    p = var_start + varlen;\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\tif (*p == ':')\n\t{\n\t    // empty first index, push zero\n\t    r = generate_PUSHNR(cctx, 0);\n\t    need_white_before = FALSE;\n\t}\n\telse\n\t    r = compile_expr0(&p, cctx);\n\n\tif (r == OK && *skipwhite(p) == ':')\n\t{\n\t    // unlet var[idx : idx]\n\t    // blob[idx : idx] = value\n\t    *range = TRUE;\n\t    p = skipwhite(p);\n\t    empty_second = *skipwhite(p + 1) == ']';\n\t    if ((need_white_before && !IS_WHITE_OR_NUL(p[-1]))\n\t\t    || (!empty_second && !IS_WHITE_OR_NUL(p[1])))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t      \":\", p);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(p + 1);\n\t    if (*p == ']')\n\t\t// empty second index, push \"none\"\n\t\tr = generate_PUSHSPEC(cctx, VVAL_NONE);\n\t    else\n\t\tr = compile_expr0(&p, cctx);\n\t}\n\n\tif (r == OK && *skipwhite(p) != ']')\n\t{\n\t    // this should not happen\n\t    emsg(_(e_missing_closing_square_brace));\n\t    r = FAIL;\n\t}\n    }\n    else // if (*p == '.')\n    {\n\tchar_u *key_end = to_name_end(p + 1, TRUE);\n\tchar_u *key = vim_strnsave(p + 1, key_end - p - 1);\n\n\tr = generate_PUSHS(cctx, &key);\n    }\n    return r;\n}\n\n/*\n * For a LHS with an index, load the variable to be indexed.\n */\n    static int\ncompile_load_lhs(\n\tlhs_T\t*lhs,\n\tchar_u\t*var_start,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    if (lhs->lhs_dest == dest_expr)\n    {\n\tsize_t\t    varlen = lhs->lhs_varlen;\n\tint\t    c = var_start[varlen];\n\tint\t    lines_len = cctx->ctx_ufunc->uf_lines.ga_len;\n\tchar_u\t    *p = var_start;\n\tint\t    res;\n\n\t// Evaluate \"ll[expr]\" of \"ll[expr][idx]\".  End the line with a NUL and\n\t// limit the lines array length to avoid skipping to a following line.\n\tvar_start[varlen] = NUL;\n\tcctx->ctx_ufunc->uf_lines.ga_len = cctx->ctx_lnum + 1;\n\tres = compile_expr0(&p, cctx);\n\tvar_start[varlen] = c;\n\tcctx->ctx_ufunc->uf_lines.ga_len = lines_len;\n\tif (res == FAIL || p != var_start + varlen)\n\t{\n\t    // this should not happen\n\t    if (res != FAIL)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    return FAIL;\n\t}\n\n\tlhs->lhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t// now we can properly check the type\n\tif (rhs_type != NULL && lhs->lhs_type->tt_member != NULL\n\t\t&& rhs_type != &t_void\n\t\t&& need_type(rhs_type, lhs->lhs_type->tt_member, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t    return FAIL;\n    }\n    else\n\tgenerate_loadvar(cctx, lhs->lhs_dest, lhs->lhs_name,\n\t\t\t\t\t\t lhs->lhs_lvar, lhs->lhs_type);\n    return OK;\n}\n\n/*\n * Produce code for loading \"lhs\" and also take care of an index.\n * Return OK/FAIL.\n */\n    int\ncompile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx)\n{\n    compile_load_lhs(lhs, var_start, NULL, cctx);\n\n    if (lhs->lhs_has_index)\n    {\n\tint range = FALSE;\n\n\t// Get member from list or dict.  First compile the\n\t// index value.\n\tif (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\t    return FAIL;\n\tif (range)\n\t{\n\t    semsg(_(e_cannot_use_range_with_assignment_operator_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t    return FAIL;\n\t}\n\n\t// Get the member.\n\tif (compile_member(FALSE, NULL, cctx) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Assignment to a list or dict member, or \":unlet\" for the item, using the\n * information in \"lhs\".\n * Returns OK or FAIL.\n */\n    int\ncompile_assign_unlet(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tis_assign,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    vartype_T\tdest_type;\n    int\t\trange = FALSE;\n\n    if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\treturn FAIL;\n    if (is_assign && range\n\t    && lhs->lhs_type->tt_type != VAR_LIST\n\t    && lhs->lhs_type != &t_blob\n\t    && lhs->lhs_type != &t_any)\n    {\n\tsemsg(_(e_cannot_use_range_with_assignment_str), var_start);\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_type == &t_any)\n    {\n\t// Index on variable of unknown type: check at runtime.\n\tdest_type = VAR_ANY;\n    }\n    else\n    {\n\tdest_type = lhs->lhs_type->tt_type;\n\tif (dest_type == VAR_DICT && range)\n\t{\n\t    emsg(e_cannot_use_range_with_dictionary);\n\t    return FAIL;\n\t}\n\tif (dest_type == VAR_DICT\n\t\t\t      && may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (dest_type == VAR_LIST || dest_type == VAR_BLOB)\n\t{\n\t    type_T *type;\n\n\t    if (range)\n\t    {\n\t\ttype = get_type_on_stack(cctx, 1);\n\t\tif (need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    }\n\t    type = get_type_on_stack(cctx, 0);\n\t    if ((dest_type != VAR_BLOB && type != &t_special)\n\t\t    && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    // Load the dict or list.  On the stack we then have:\n    // - value (for assignment, not for :unlet)\n    // - index\n    // - for [a : b] second index\n    // - variable\n    if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)\n\treturn FAIL;\n\n    if (dest_type == VAR_LIST || dest_type == VAR_DICT\n\t\t\t      || dest_type == VAR_BLOB || dest_type == VAR_ANY)\n    {\n\tif (is_assign)\n\t{\n\t    if (range)\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tisn_T\t*isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);\n\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t\tisn->isn_arg.vartype = dest_type;\n\t    }\n\t}\n\telse if (range)\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\temsg(_(e_indexable_type_required));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Compile declaration and assignment:\n * \"let name\"\n * \"var name = expr\"\n * \"final name = expr\"\n * \"const name = expr\"\n * \"name = expr\"\n * \"arg\" points to \"name\".\n * \"++arg\" and \"--arg\"\n * Return NULL for an error.\n * Return \"arg\" if it does not look like a variable list.\n */\n    static char_u *\ncompile_assignment(char_u *arg, exarg_T *eap, cmdidx_T cmdidx, cctx_T *cctx)\n{\n    char_u\t*var_start;\n    char_u\t*p;\n    char_u\t*end = arg;\n    char_u\t*ret = NULL;\n    int\t\tvar_count = 0;\n    int\t\tvar_idx;\n    int\t\tsemicolon = 0;\n    int\t\tdid_generate_slice = FALSE;\n    garray_T\t*instr = &cctx->ctx_instr;\n    char_u\t*op;\n    int\t\toplen = 0;\n    int\t\theredoc = FALSE;\n    int\t\tincdec = FALSE;\n    type_T\t*rhs_type = &t_any;\n    char_u\t*sp;\n    int\t\tis_decl = is_decl_command(cmdidx);\n    lhs_T\tlhs;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    // Skip over the \"var\" or \"[var, var]\" to get to any \"=\".\n    p = skip_var_list(arg, TRUE, &var_count, &semicolon, TRUE);\n    if (p == NULL)\n\treturn *arg == '[' ? arg : NULL;\n\n    lhs.lhs_name = NULL;\n\n    sp = p;\n    p = skipwhite(p);\n    op = p;\n    oplen = assignment_len(p, &heredoc);\n\n    if (var_count > 0 && oplen == 0)\n\t// can be something like \"[1, 2]->func()\"\n\treturn arg;\n\n    if (oplen > 0 && (!VIM_ISWHITE(*sp) || !IS_WHITE_OR_NUL(op[oplen])))\n    {\n\terror_white_both(op, oplen);\n\treturn NULL;\n    }\n    if (eap->cmdidx == CMD_increment || eap->cmdidx == CMD_decrement)\n    {\n\tif (VIM_ISWHITE(eap->cmd[2]))\n\t{\n\t    semsg(_(e_no_white_space_allowed_after_str_str),\n\t\t\t eap->cmdidx == CMD_increment ? \"++\" : \"--\", eap->cmd);\n\t    return NULL;\n\t}\n\top = (char_u *)(eap->cmdidx == CMD_increment ? \"+=\" : \"-=\");\n\toplen = 2;\n\tincdec = TRUE;\n    }\n\n    if (heredoc)\n    {\n\tlist_T\t   *l;\n\tlistitem_T *li;\n\n\t// [let] varname =<< [trim] {end}\n\teap->getline = exarg_getline;\n\teap->cookie = cctx;\n\tl = heredoc_get(eap, op + 3, FALSE);\n\tif (l == NULL)\n\t    return NULL;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    // Push each line and the create the list.\n\t    FOR_ALL_LIST_ITEMS(l, li)\n\t    {\n\t\tgenerate_PUSHS(cctx, &li->li_tv.vval.v_string);\n\t\tli->li_tv.vval.v_string = NULL;\n\t    }\n\t    generate_NEWLIST(cctx, l->lv_len);\n\t}\n\tlist_free(l);\n\tp += STRLEN(p);\n\tend = p;\n    }\n    else if (var_count > 0)\n    {\n\tchar_u *wp;\n\n\t// for \"[var, var] = expr\" evaluate the expression here, loop over the\n\t// list of variables below.\n\t// A line break may follow the \"=\".\n\n\twp = op + oplen;\n\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t    return FAIL;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tend = p;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    type_T\t*stacktype;\n\t    int\t\tneeded_list_len;\n\t    int\t\tdid_check = FALSE;\n\n\t    stacktype = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t    if (stacktype->tt_type == VAR_VOID)\n\t    {\n\t\temsg(_(e_cannot_use_void_value));\n\t\tgoto theend;\n\t    }\n\t    if (need_type(stacktype, &t_list_any, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t    // If a constant list was used we can check the length right here.\n\t    needed_list_len = semicolon ? var_count - 1 : var_count;\n\t    if (instr->ga_len > 0)\n\t    {\n\t\tisn_T\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\t\tif (isn->isn_type == ISN_NEWLIST)\n\t\t{\n\t\t    did_check = TRUE;\n\t\t    if (semicolon ? isn->isn_arg.number < needed_list_len\n\t\t\t    : isn->isn_arg.number != needed_list_len)\n\t\t    {\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t\t needed_list_len, isn->isn_arg.number);\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!did_check)\n\t\tgenerate_CHECKLEN(cctx, needed_list_len, semicolon);\n\t    if (stacktype->tt_member != NULL)\n\t\trhs_type = stacktype->tt_member;\n\t}\n    }\n\n    /*\n     * Loop over variables in \"[var, var] = expr\".\n     * For \"var = expr\" and \"let var: type\" this is done only once.\n     */\n    if (var_count > 0)\n\tvar_start = skipwhite(arg + 1);  // skip over the \"[\"\n    else\n\tvar_start = arg;\n    for (var_idx = 0; var_idx == 0 || var_idx < var_count; var_idx++)\n    {\n\tint\tinstr_count = -1;\n\tint\tsave_lnum;\n\tint\tskip_store = FALSE;\n\n\tif (var_start[0] == '_' && !eval_isnamec(var_start[1]))\n\t{\n\t    // Ignore underscore in \"[a, _, b] = list\".\n\t    if (var_count > 0)\n\t    {\n\t\tvar_start = skipwhite(var_start + 2);\n\t\tcontinue;\n\t    }\n\t    emsg(_(e_cannot_use_underscore_here));\n\t    goto theend;\n\t}\n\tvim_free(lhs.lhs_name);\n\n\t/*\n\t * Figure out the LHS type and other properties.\n\t */\n\tif (compile_assign_lhs(var_start, &lhs, cmdidx,\n\t\t\t\t\tis_decl, heredoc, oplen, cctx) == FAIL)\n\t    goto theend;\n\tif (heredoc)\n\t{\n\t    SOURCING_LNUM = start_lnum;\n\t    if (lhs.lhs_has_type\n\t\t    && need_type(&t_list_string, lhs.lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t}\n\telse\n\t{\n\t    if (cctx->ctx_skip == SKIP_YES)\n\t    {\n\t\tif (oplen > 0 && var_count == 0)\n\t\t{\n\t\t    // skip over the \"=\" and the expression\n\t\t    p = skipwhite(op + oplen);\n\t\t    (void)compile_expr0(&p, cctx);\n\t\t}\n\t    }\n\t    else if (oplen > 0)\n\t    {\n\t\tint\tis_const = FALSE;\n\t\tchar_u\t*wp;\n\n\t\t// for \"+=\", \"*=\", \"..=\" etc. first load the current value\n\t\tif (*op != '='\n\t\t\t&& compile_load_lhs_with_index(&lhs, var_start,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    goto theend;\n\n\t\t// For \"var = expr\" evaluate the expression.\n\t\tif (var_count == 0)\n\t\t{\n\t\t    int\tr;\n\n\t\t    // Compile the expression.\n\t\t    instr_count = instr->ga_len;\n\t\t    if (incdec)\n\t\t    {\n\t\t\tr = generate_PUSHNR(cctx, 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Temporarily hide the new local variable here, it is\n\t\t\t// not available to this expression.\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    --cctx->ctx_locals.ga_len;\n\t\t\twp = op + oplen;\n\t\t\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t\t\t{\n\t\t\t    if (lhs.lhs_new_local)\n\t\t\t\t++cctx->ctx_locals.ga_len;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tr = compile_expr0_ext(&p, cctx, &is_const);\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    ++cctx->ctx_locals.ga_len;\n\t\t\tif (r == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse if (semicolon && var_idx == var_count - 1)\n\t\t{\n\t\t    // For \"[var; var] = expr\" get the rest of the list\n\t\t    did_generate_slice = TRUE;\n\t\t    if (generate_SLICE(cctx, var_count - 1) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For \"[var, var] = expr\" get the \"var_idx\" item from the\n\t\t    // list.\n\t\t    if (generate_GETITEM(cctx, var_idx, *op != '=') == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\n\t\trhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t\tif (lhs.lhs_lvar != NULL && (is_decl || !lhs.lhs_has_type))\n\t\t{\n\t\t    if ((rhs_type->tt_type == VAR_FUNC\n\t\t\t\t|| rhs_type->tt_type == VAR_PARTIAL)\n\t\t\t    && !lhs.lhs_has_index\n\t\t\t    && var_wrong_func_name(lhs.lhs_name, TRUE))\n\t\t\tgoto theend;\n\n\t\t    if (lhs.lhs_new_local && !lhs.lhs_has_type)\n\t\t    {\n\t\t\tif (rhs_type->tt_type == VAR_VOID)\n\t\t\t{\n\t\t\t    emsg(_(e_cannot_use_void_value));\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // An empty list or dict has a &t_unknown member,\n\t\t\t    // for a variable that implies &t_any.\n\t\t\t    if (rhs_type == &t_list_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_list_any;\n\t\t\t    else if (rhs_type == &t_dict_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_dict_any;\n\t\t\t    else if (rhs_type == &t_unknown)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_any;\n\t\t\t    else\n\t\t\t\tlhs.lhs_lvar->lv_type = rhs_type;\n\t\t\t}\n\t\t    }\n\t\t    else if (*op == '=')\n\t\t    {\n\t\t\ttype_T *use_type = lhs.lhs_lvar->lv_type;\n\t\t\twhere_T where = WHERE_INIT;\n\n\t\t\t// Without operator check type here, otherwise below.\n\t\t\t// Use the line number of the assignment.\n\t\t\tSOURCING_LNUM = start_lnum;\n\t\t\twhere.wt_index = var_count > 0 ? var_idx + 1 : 0;\n\t\t\twhere.wt_variable = var_count > 0;\n\t\t\t// If assigning to a list or dict member, use the\n\t\t\t// member type.  Not for \"list[:] =\".\n\t\t\tif (lhs.lhs_has_index\n\t\t\t\t&& !has_list_index(var_start + lhs.lhs_varlen,\n\t\t\t\t\t\t\t\t\t cctx))\n\t\t\t    use_type = lhs.lhs_member_type;\n\t\t\tif (need_type_where(rhs_type, use_type, -1, where,\n\t\t\t\t    cctx, FALSE, is_const) == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    type_T *lhs_type = lhs.lhs_member_type;\n\n\t\t    // Special case: assigning to @# can use a number or a\n\t\t    // string.\n\t\t    // Also: can assign a number to a float.\n\t\t    if ((lhs_type == &t_number_or_string\n\t\t\t\t|| lhs_type == &t_float)\n\t\t\t    && rhs_type->tt_type == VAR_NUMBER)\n\t\t\tlhs_type = &t_number;\n\t\t    if (*p != '=' && need_type(rhs_type, lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t\t}\n\t    }\n\t    else if (cmdidx == CMD_final)\n\t    {\n\t\temsg(_(e_final_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (cmdidx == CMD_const)\n\t    {\n\t\temsg(_(e_const_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (!lhs.lhs_has_type || lhs.lhs_dest == dest_option\n\t\t\t\t\t   || lhs.lhs_dest == dest_func_option)\n\t    {\n\t\temsg(_(e_type_or_initialization_required));\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\t// variables are always initialized\n\t\tif (GA_GROW_FAILS(instr, 1))\n\t\t    goto theend;\n\t\tswitch (lhs.lhs_member_type->tt_type)\n\t\t{\n\t\t    case VAR_BOOL:\n\t\t\tgenerate_PUSHBOOL(cctx, VVAL_FALSE);\n\t\t\tbreak;\n\t\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t\tgenerate_PUSHF(cctx, 0.0);\n#endif\n\t\t\tbreak;\n\t\t    case VAR_STRING:\n\t\t\tgenerate_PUSHS(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_BLOB:\n\t\t\tgenerate_PUSHBLOB(cctx, blob_alloc());\n\t\t\tbreak;\n\t\t    case VAR_FUNC:\n\t\t\tgenerate_PUSHFUNC(cctx, NULL, &t_func_void);\n\t\t\tbreak;\n\t\t    case VAR_LIST:\n\t\t\tgenerate_NEWLIST(cctx, 0);\n\t\t\tbreak;\n\t\t    case VAR_DICT:\n\t\t\tgenerate_NEWDICT(cctx, 0);\n\t\t\tbreak;\n\t\t    case VAR_JOB:\n\t\t\tgenerate_PUSHJOB(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_CHANNEL:\n\t\t\tgenerate_PUSHCHANNEL(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_NUMBER:\n\t\t    case VAR_UNKNOWN:\n\t\t    case VAR_ANY:\n\t\t    case VAR_PARTIAL:\n\t\t    case VAR_VOID:\n\t\t    case VAR_INSTR:\n\t\t    case VAR_SPECIAL:  // cannot happen\n\t\t\t// This is skipped for local variables, they are\n\t\t\t// always initialized to zero.\n\t\t\tif (lhs.lhs_dest == dest_local)\n\t\t\t    skip_store = TRUE;\n\t\t\telse\n\t\t\t    generate_PUSHNR(cctx, 0);\n\t\t\tbreak;\n\t\t}\n\t    }\n\t    if (var_count == 0)\n\t\tend = p;\n\t}\n\n\t// no need to parse more when skipping\n\tif (cctx->ctx_skip == SKIP_YES)\n\t    break;\n\n\tif (oplen > 0 && *op != '=')\n\t{\n\t    type_T\t    *expected;\n\t    type_T\t    *stacktype = NULL;\n\n\t    if (*op == '.')\n\t    {\n\t\tif (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else\n\t    {\n\t\texpected = lhs.lhs_member_type;\n\t\tstacktype = get_type_on_stack(cctx, 0);\n\t\tif (\n#ifdef FEAT_FLOAT\n\t\t    // If variable is float operation with number is OK.\n\t\t    !(expected == &t_float && (stacktype == &t_number\n\t\t\t    || stacktype == &t_number_bool)) &&\n#endif\n\t\t    need_type(stacktype, expected, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t    }\n\n\t    if (*op == '.')\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_CONCAT, 1) == NULL)\n\t\t    goto theend;\n\t    }\n\t    else if (*op == '+')\n\t    {\n\t\tif (generate_add_instr(cctx,\n\t\t\t    operator_type(lhs.lhs_member_type, stacktype),\n\t\t\t\t       lhs.lhs_member_type, stacktype,\n\t\t\t\t\t\t\t  EXPR_APPEND) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (generate_two_op(cctx, op) == FAIL)\n\t\tgoto theend;\n\t}\n\n\t// Use the line number of the assignment for store instruction.\n\tsave_lnum = cctx->ctx_lnum;\n\tcctx->ctx_lnum = start_lnum - 1;\n\n\tif (lhs.lhs_has_index)\n\t{\n\t    // Use the info in \"lhs\" to store the value at the index in the\n\t    // list or dict.\n\t    if (compile_assign_unlet(var_start, &lhs, TRUE, rhs_type, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (is_decl && cmdidx == CMD_const && (lhs.lhs_dest == dest_script\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_global\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_local))\n\t\t// \":const var\": lock the value, but not referenced variables\n\t\tgenerate_LOCKCONST(cctx);\n\n\t    if ((lhs.lhs_type->tt_type == VAR_DICT\n\t\t\t\t\t  || lhs.lhs_type->tt_type == VAR_LIST)\n\t\t    && lhs.lhs_type->tt_member != NULL\n\t\t    && lhs.lhs_type->tt_member != &t_unknown)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, lhs.lhs_type);\n\n\t    if (!skip_store && generate_store_lhs(cctx, &lhs,\n\t\t\t\t\t\t instr_count, is_decl) == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\tcctx->ctx_lnum = save_lnum;\n\n\tif (var_idx + 1 < var_count)\n\t    var_start = skipwhite(lhs.lhs_end + 1);\n    }\n\n    // For \"[var, var] = expr\" drop the \"expr\" value.\n    // Also for \"[var, var; _] = expr\".\n    if (var_count > 0 && (!semicolon || !did_generate_slice))\n    {\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    goto theend;\n    }\n\n    ret = skipwhite(end);\n\ntheend:\n    vim_free(lhs.lhs_name);\n    return ret;\n}\n\n/*\n * Check for an assignment at \"eap->cmd\", compile it if found.\n * Return NOTDONE if there is none, FAIL for failure, OK if done.\n */\n    static int\nmay_compile_assignment(exarg_T *eap, char_u **line, cctx_T *cctx)\n{\n    char_u  *pskip;\n    char_u  *p;\n\n    // Assuming the command starts with a variable or function name,\n    // find what follows.\n    // Skip over \"var.member\", \"var[idx]\" and the like.\n    // Also \"&opt = val\", \"$ENV = val\" and \"@r = val\".\n    pskip = (*eap->cmd == '&' || *eap->cmd == '$' || *eap->cmd == '@')\n\t\t\t\t\t\t ? eap->cmd + 1 : eap->cmd;\n    p = to_name_end(pskip, TRUE);\n    if (p > eap->cmd && *p != NUL)\n    {\n\tchar_u *var_end;\n\tint\toplen;\n\tint\theredoc;\n\n\tif (eap->cmd[0] == '@')\n\t    var_end = eap->cmd + 2;\n\telse\n\t    var_end = find_name_end(pskip, NULL, NULL,\n\t\t\t\t\tFNE_CHECK_START | FNE_INCL_BR);\n\toplen = assignment_len(skipwhite(var_end), &heredoc);\n\tif (oplen > 0)\n\t{\n\t    size_t len = p - eap->cmd;\n\n\t    // Recognize an assignment if we recognize the variable\n\t    // name:\n\t    // \"g:var = expr\"\n\t    // \"local = expr\"  where \"local\" is a local var.\n\t    // \"script = expr\"  where \"script\" is a script-local var.\n\t    // \"import = expr\"  where \"import\" is an imported var\n\t    // \"&opt = expr\"\n\t    // \"$ENV = expr\"\n\t    // \"@r = expr\"\n\t    if (*eap->cmd == '&'\n\t\t    || *eap->cmd == '$'\n\t\t    || *eap->cmd == '@'\n\t\t    || ((len) > 2 && eap->cmd[1] == ':')\n\t\t    || variable_exists(eap->cmd, len, cctx))\n\t    {\n\t\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\t\tif (*line == NULL || *line == eap->cmd)\n\t\t    return FAIL;\n\t\treturn OK;\n\t    }\n\t}\n    }\n\n    if (*eap->cmd == '[')\n    {\n\t// [var, var] = expr\n\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\tif (*line == NULL)\n\t    return FAIL;\n\tif (*line != eap->cmd)\n\t    return OK;\n    }\n    return NOTDONE;\n}\n\n/*\n * Check if arguments of \"ufunc\" shadow variables in \"cctx\".\n * Return OK or FAIL.\n */\n    static int\ncheck_args_shadowing(ufunc_T *ufunc, cctx_T *cctx)\n{\n    int\t    i;\n    char_u  *arg;\n    int\t    r = OK;\n\n    // Make sure arguments are not found when compiling a second time.\n    ufunc->uf_args_visible = 0;\n\n    // Check for arguments shadowing variables from the context.\n    for (i = 0; i < ufunc->uf_args.ga_len; ++i)\n    {\n\targ = ((char_u **)(ufunc->uf_args.ga_data))[i];\n\tif (check_defined(arg, STRLEN(arg), cctx, TRUE) == FAIL)\n\t{\n\t    r = FAIL;\n\t    break;\n\t}\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n    return r;\n}\n\n\n/*\n * Add a function to the list of :def functions.\n * This sets \"ufunc->uf_dfunc_idx\" but the function isn't compiled yet.\n */\n    static int\nadd_def_function(ufunc_T *ufunc)\n{\n    dfunc_T *dfunc;\n\n    if (def_functions.ga_len == 0)\n    {\n\t// The first position is not used, so that a zero uf_dfunc_idx means it\n\t// wasn't set.\n\tif (GA_GROW_FAILS(&def_functions, 1))\n\t    return FAIL;\n\t++def_functions.ga_len;\n    }\n\n    // Add the function to \"def_functions\".\n    if (GA_GROW_FAILS(&def_functions, 1))\n\treturn FAIL;\n    dfunc = ((dfunc_T *)def_functions.ga_data) + def_functions.ga_len;\n    CLEAR_POINTER(dfunc);\n    dfunc->df_idx = def_functions.ga_len;\n    ufunc->uf_dfunc_idx = dfunc->df_idx;\n    dfunc->df_ufunc = ufunc;\n    dfunc->df_name = vim_strsave(ufunc->uf_name);\n    ga_init2(&dfunc->df_var_names, sizeof(char_u *), 10);\n    ++dfunc->df_refcount;\n    ++def_functions.ga_len;\n    return OK;\n}\n\n/*\n * After ex_function() has collected all the function lines: parse and compile\n * the lines into instructions.\n * Adds the function to \"def_functions\".\n * When \"check_return_type\" is set then set ufunc->uf_ret_type to the type of\n * the return statement (used for lambda).  When uf_ret_type is already set\n * then check that it matches.\n * When \"profiling\" is true add ISN_PROF_START instructions.\n * \"outer_cctx\" is set for a nested function.\n * This can be used recursively through compile_lambda(), which may reallocate\n * \"def_functions\".\n * Returns OK or FAIL.\n */\n    int\ncompile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    char_u\t*line_to_free = NULL;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in \"def_functions\".\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc->df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc->df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&dfunc->df_var_names);\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    ufunc->uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);\n    // Each entry on the type stack consists of two type pointers.\n    ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50);\n    ga_init2(&cctx.ctx_imports, sizeof(imported_T), 10);\n    cctx.ctx_type_list = &ufunc->uf_type_list;\n    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don't use the flag from \":legacy\" here.\n    cmdmod.cmod_flags &= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (check_args_shadowing(ufunc, &cctx) == FAIL)\n\tgoto erret;\n\n    if (ufunc->uf_def_args.ga_len > 0)\n    {\n\tint\tcount = ufunc->uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc->uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i < count; ++i)\n\t{\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr->ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc->uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&arg, &cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = get_type_on_stack(&cctx, 0);\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc->uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;\n\t    isn->isn_arg.jumparg.jump_where = instr->ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL && *line == '|')\n\t    // the line continues after a '|'\n\t    ++line;\n\telse if (line != NULL && *skipwhite(line) != NUL\n\t\t&& !(*line == '#' && (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_characters_str), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL && vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&cctx, FALSE);\n\t    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tvim_free(line_to_free);\n\t\tline_to_free = line;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &line;\n\tea.cmd = skipwhite(line);\n\n\tif (*ea.cmd == '#')\n\t{\n\t    // \"#\" starts a comment\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case '}':\n\t\t{\n\t\t    // \"}\" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope->se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case '{':\n\t\t// \"{\" starts a block scope\n\t\t// \"{'a': 1}->func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t{\n\t    if (errormsg != NULL)\n\t\tgoto erret;\n\t    // empty line or comment\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\tgenerate_cmdmods(&cctx, &local_cmdmod);\n\tundo_cmdmod(&local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p >= line; --p)\n\t{\n\t    if (*p == ':')\n\t\tstarts_with_colon = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip \":call\" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&ea.cmd, \"call\", 3))\n\t    {\n\t\tif (*ea.cmd == '(')\n\t\t    // not for \"call()\"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&ea, &line, &cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * 'text'->func() should not be confused with 'a mark\n\t * \"++nr\" and \"--nr\" are eval commands\n\t * in \"$ENV->func()\" the \"$\" is not a range\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != '$' || starts_with_colon)\n\t\t&& (starts_with_colon || !(*cmd == '\\''\n\t\t       || (cmd[0] != NUL && cmd[0] == cmd[1]\n\t\t\t\t\t    && (*cmd == '+' || *cmd == '-')))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd > cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\temsg(_(e_ambiguous_use_of_user_defined_command));\n\t    goto erret;\n\t}\n\n\t// When using \":legacy cmd\" always use compile_exec().\n\tif (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // \":legacy return expr\" needs to be handled differently.\n\t    if (checkforcmd(&start, \"return\", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd && ea.cmdidx != CMD_SIZE)\n\t{\n\t    if (cctx.ctx_skip == SKIP_YES && ea.cmdidx != CMD_eval)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else if (ea.cmdidx != CMD_eval)\n\t    {\n\t\t// CMD_var cannot happen, compile_assignment() above would be\n\t\t// used.  Most likely an assignment to a non-existing variable.\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&& ea.cmdidx != CMD_elseif\n\t\t&& ea.cmdidx != CMD_else\n\t\t&& ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endwhile\n\t\t&& ea.cmdidx != CMD_catch\n\t\t&& ea.cmdidx != CMD_finally\n\t\t&& ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx >= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt & EX_BANG) && *p == '!')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&ea, &cctx, &line_to_free);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);\n\t\t    if (line == p)\n\t\t\tline = NULL;\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &cctx);\n\t\t    break;\n\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_execute:\n\t    case CMD_echomsg:\n\t    case CMD_echoerr:\n\t    case CMD_echoconsole:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, &cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)\"\";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &ea, &cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &ea, &cctx);\n#else\n\t\t    ex_ni(&ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don't check for a next command here.\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, '\\n') == NULL)\n\t\t\tline = compile_exec(line, &ea, &cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &cctx);\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &ea, &cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&cctx);\n\n\tif (cctx.ctx_type_stack.ga_len < 0)\n\t{\n\t    iemsg(\"Type stack underflow\");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope->se_type == IF_SCOPE)\n\t    emsg(_(e_missing_endif));\n\telse if (cctx.ctx_scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (cctx.ctx_scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)\n\t    ufunc->uf_ret_type = &t_void;\n\telse if (ufunc->uf_ret_type->tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with \":silent!\" and there was an error don't consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tdfunc->df_deleted = FALSE;\n\tdfunc->df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc->df_instr_prof = instr->ga_data;\n\t    dfunc->df_instr_prof_count = instr->ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc->df_instr_debug = instr->ga_data;\n\t    dfunc->df_instr_debug_count = instr->ga_len;\n\t}\n\telse\n\t{\n\t    dfunc->df_instr = instr->ga_data;\n\t    dfunc->df_instr_count = instr->ga_len;\n\t}\n\tdfunc->df_varcount = dfunc->df_var_names.ga_len;\n\tdfunc->df_has_closure = cctx.ctx_has_closure;\n\tif (cctx.ctx_outer_used)\n\t    ufunc->uf_flags |= FC_CLOSURE;\n\tufunc->uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc->uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc->df_name);\n\tga_clear_strings(&dfunc->df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc->df_deleted && new_def_function\n\t\t\t    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc->uf_dfunc_idx = 0;\n\t}\n\tufunc->uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    vim_free(line_to_free);\n    free_imported(&cctx);\n    free_locals(&cctx);\n    ga_clear(&cctx.ctx_type_stack);\n    return ret;\n}\n\n    void\nset_function_type(ufunc_T *ufunc)\n{\n    int varargs = ufunc->uf_va_name != NULL;\n    int argcount = ufunc->uf_args.ga_len;\n\n    // Create a type for the function, with the return type and any\n    // argument types.\n    // A vararg is included in uf_args.ga_len but not in uf_arg_types.\n    // The type is included in \"tt_args\".\n    if (argcount > 0 || varargs)\n    {\n\tif (ufunc->uf_type_list.ga_itemsize == 0)\n\t    ga_init2(&ufunc->uf_type_list, sizeof(type_T *), 10);\n\tufunc->uf_func_type = alloc_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n\t// Add argument types to the function type.\n\tif (func_type_add_arg_types(ufunc->uf_func_type,\n\t\t\t\t    argcount + varargs,\n\t\t\t\t    &ufunc->uf_type_list) == FAIL)\n\t    return;\n\tufunc->uf_func_type->tt_argcount = argcount + varargs;\n\tufunc->uf_func_type->tt_min_argcount =\n\t\t\t\t      argcount - ufunc->uf_def_args.ga_len;\n\tif (ufunc->uf_arg_types == NULL)\n\t{\n\t    int i;\n\n\t    // lambda does not have argument types.\n\t    for (i = 0; i < argcount; ++i)\n\t\tufunc->uf_func_type->tt_args[i] = &t_any;\n\t}\n\telse\n\t    mch_memmove(ufunc->uf_func_type->tt_args,\n\t\t\t ufunc->uf_arg_types, sizeof(type_T *) * argcount);\n\tif (varargs)\n\t{\n\t    ufunc->uf_func_type->tt_args[argcount] =\n\t\t   ufunc->uf_va_type == NULL ? &t_list_any : ufunc->uf_va_type;\n\t    ufunc->uf_func_type->tt_flags = TTFLAG_VARARGS;\n\t}\n    }\n    else\n\t// No arguments, can use a predefined type.\n\tufunc->uf_func_type = get_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n}\n\n/*\n * Free all instructions for \"dfunc\" except df_name.\n */\n    static void\ndelete_def_function_contents(dfunc_T *dfunc, int mark_deleted)\n{\n    int idx;\n\n    ga_clear(&dfunc->df_def_args_isn);\n    ga_clear_strings(&dfunc->df_var_names);\n\n    if (dfunc->df_instr != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_count; ++idx)\n\t    delete_instr(dfunc->df_instr + idx);\n\tVIM_CLEAR(dfunc->df_instr);\n\tdfunc->df_instr = NULL;\n    }\n    if (dfunc->df_instr_debug != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_debug_count; ++idx)\n\t    delete_instr(dfunc->df_instr_debug + idx);\n\tVIM_CLEAR(dfunc->df_instr_debug);\n\tdfunc->df_instr_debug = NULL;\n    }\n#ifdef FEAT_PROFILE\n    if (dfunc->df_instr_prof != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_prof_count; ++idx)\n\t    delete_instr(dfunc->df_instr_prof + idx);\n\tVIM_CLEAR(dfunc->df_instr_prof);\n\tdfunc->df_instr_prof = NULL;\n    }\n#endif\n\n    if (mark_deleted)\n\tdfunc->df_deleted = TRUE;\n    if (dfunc->df_ufunc != NULL)\n\tdfunc->df_ufunc->uf_def_status = UF_NOT_COMPILED;\n}\n\n/*\n * When a user function is deleted, clear the contents of any associated def\n * function, unless another user function still uses it.\n * The position in def_functions can be re-used.\n */\n    void\nunlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\tif (--dfunc->df_refcount <= 0)\n\t    delete_def_function_contents(dfunc, TRUE);\n\tufunc->uf_def_status = UF_NOT_COMPILED;\n\tufunc->uf_dfunc_idx = 0;\n\tif (dfunc->df_ufunc == ufunc)\n\t    dfunc->df_ufunc = NULL;\n    }\n}\n\n/*\n * Used when a user function refers to an existing dfunc.\n */\n    void\nlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t++dfunc->df_refcount;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all functions defined with \":def\".\n */\n    void\nfree_def_functions(void)\n{\n    int idx;\n\n    for (idx = 0; idx < def_functions.ga_len; ++idx)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data) + idx;\n\n\tdelete_def_function_contents(dfunc, TRUE);\n\tvim_free(dfunc->df_name);\n    }\n\n    ga_clear(&def_functions);\n}\n#endif\n\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * viminfo.c: viminfo related functions\n */\n\n#include \"vim.h\"\n#include \"version.h\"\n\n/*\n * Structure used for reading from the viminfo file.\n */\ntypedef struct\n{\n    char_u\t*vir_line;\t// text of the current line\n    FILE\t*vir_fd;\t// file descriptor\n    vimconv_T\tvir_conv;\t// encoding conversion\n    int\t\tvir_version;\t// viminfo version detected or -1\n    garray_T\tvir_barlines;\t// lines starting with |\n} vir_T;\n\ntypedef enum {\n    BVAL_NR,\n    BVAL_STRING,\n    BVAL_EMPTY\n} btype_T;\n\ntypedef struct {\n    btype_T\tbv_type;\n    long\tbv_nr;\n    char_u\t*bv_string;\n    char_u\t*bv_tofree;\t// free later when not NULL\n    int\t\tbv_len;\t\t// length of bv_string\n    int\t\tbv_allocated;\t// bv_string was allocated\n} bval_T;\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n\nstatic int  viminfo_errcnt;\n\n/*\n * Find the parameter represented by the given character (eg ''', ':', '\"', or\n * '/') in the 'viminfo' option and return a pointer to the string after it.\n * Return NULL if the parameter is not specified in the string.\n */\n    static char_u *\nfind_viminfo_parameter(int type)\n{\n    char_u  *p;\n\n    for (p = p_viminfo; *p; ++p)\n    {\n\tif (*p == type)\n\t    return p + 1;\n\tif (*p == 'n')\t\t    // 'n' is always the last one\n\t    break;\n\tp = vim_strchr(p, ',');\t    // skip until next ','\n\tif (p == NULL)\t\t    // hit the end without finding parameter\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * Find the parameter represented by the given character (eg ', :, \", or /),\n * and return its associated value in the 'viminfo' string.\n * Only works for number parameters, not for 'r' or 'n'.\n * If the parameter is not specified in the string or there is no following\n * number, return -1.\n */\n    int\nget_viminfo_parameter(int type)\n{\n    char_u  *p;\n\n    p = find_viminfo_parameter(type);\n    if (p != NULL && VIM_ISDIGIT(*p))\n\treturn atoi((char *)p);\n    return -1;\n}\n\n/*\n * Get the viminfo file name to use.\n * If \"file\" is given and not empty, use it (has already been expanded by\n * cmdline functions).\n * Otherwise use \"-i file_name\", value from 'viminfo' or the default, and\n * expand environment variables.\n * Returns an allocated string.  NULL when out of memory.\n */\n    static char_u *\nviminfo_filename(char_u *file)\n{\n    if (file == NULL || *file == NUL)\n    {\n\tif (*p_viminfofile != NUL)\n\t    file = p_viminfofile;\n\telse if ((file = find_viminfo_parameter('n')) == NULL || *file == NUL)\n\t{\n#ifdef VIMINFO_FILE2\n# ifdef VMS\n\t    if (mch_getenv((char_u *)\"SYS$LOGIN\") == NULL)\n# else\n#  ifdef MSWIN\n\t    // Use $VIM only if $HOME is the default \"C:/\".\n\t    if (STRCMP(vim_getenv((char_u *)\"HOME\", NULL), \"C:/\") == 0\n\t\t    && mch_getenv((char_u *)\"HOME\") == NULL)\n#  else\n\t    if (mch_getenv((char_u *)\"HOME\") == NULL)\n#  endif\n# endif\n\t    {\n\t\t// don't use $VIM when not available.\n\t\texpand_env((char_u *)\"$VIM\", NameBuff, MAXPATHL);\n\t\tif (STRCMP(\"$VIM\", NameBuff) != 0)  // $VIM was expanded\n\t\t    file = (char_u *)VIMINFO_FILE2;\n\t\telse\n\t\t    file = (char_u *)VIMINFO_FILE;\n\t    }\n\t    else\n#endif\n\t\tfile = (char_u *)VIMINFO_FILE;\n\t}\n\texpand_env(file, NameBuff, MAXPATHL);\n\tfile = NameBuff;\n    }\n    return vim_strsave(file);\n}\n\n/*\n * write string to viminfo file\n * - replace CTRL-V with CTRL-V CTRL-V\n * - replace '\\n'   with CTRL-V 'n'\n * - add a '\\n' at the end\n *\n * For a long line:\n * - write \" CTRL-V <length> \\n \" in first line\n * - write \" < <string> \\n \"\t  in second line\n */\n    static void\nviminfo_writestring(FILE *fd, char_u *p)\n{\n    int\t\tc;\n    char_u\t*s;\n    int\t\tlen = 0;\n\n    for (s = p; *s != NUL; ++s)\n    {\n\tif (*s == Ctrl_V || *s == '\\n')\n\t    ++len;\n\t++len;\n    }\n\n    // If the string will be too long, write its length and put it in the next\n    // line.  Take into account that some room is needed for what comes before\n    // the string (e.g., variable name).  Add something to the length for the\n    // '<', NL and trailing NUL.\n    if (len > LSIZE / 2)\n\tfprintf(fd, IF_EB(\"\\026%d\\n<\", CTRL_V_STR \"%d\\n<\"), len + 3);\n\n    while ((c = *p++) != NUL)\n    {\n\tif (c == Ctrl_V || c == '\\n')\n\t{\n\t    putc(Ctrl_V, fd);\n\t    if (c == '\\n')\n\t\tc = 'n';\n\t}\n\tputc(c, fd);\n    }\n    putc('\\n', fd);\n}\n\n/*\n * Write a string in quotes that barline_parse() can read back.\n * Breaks the line in less than LSIZE pieces when needed.\n * Returns remaining characters in the line.\n */\n    static int\nbarline_writestring(FILE *fd, char_u *s, int remaining_start)\n{\n    char_u *p;\n    int\t    remaining = remaining_start;\n    int\t    len = 2;\n\n    // Count the number of characters produced, including quotes.\n    for (p = s; *p != NUL; ++p)\n    {\n\tif (*p == NL)\n\t    len += 2;\n\telse if (*p == '\"' || *p == '\\\\')\n\t    len += 2;\n\telse\n\t    ++len;\n    }\n    if (len > remaining - 2)\n    {\n\tfprintf(fd, \">%d\\n|<\", len);\n\tremaining = LSIZE - 20;\n    }\n\n    putc('\"', fd);\n    for (p = s; *p != NUL; ++p)\n    {\n\tif (*p == NL)\n\t{\n\t    putc('\\\\', fd);\n\t    putc('n', fd);\n\t    --remaining;\n\t}\n\telse if (*p == '\"' || *p == '\\\\')\n\t{\n\t    putc('\\\\', fd);\n\t    putc(*p, fd);\n\t    --remaining;\n\t}\n\telse\n\t    putc(*p, fd);\n\t--remaining;\n\n\tif (remaining < 3)\n\t{\n\t    putc('\\n', fd);\n\t    putc('|', fd);\n\t    putc('<', fd);\n\t    // Leave enough space for another continuation.\n\t    remaining = LSIZE - 20;\n\t}\n    }\n    putc('\"', fd);\n    return remaining - 2;\n}\n\n/*\n * Check string read from viminfo file.\n * Remove '\\n' at the end of the line.\n * - replace CTRL-V CTRL-V with CTRL-V\n * - replace CTRL-V 'n'    with '\\n'\n *\n * Check for a long line as written by viminfo_writestring().\n *\n * Return the string in allocated memory (NULL when out of memory).\n */\n    static char_u *\nviminfo_readstring(\n    vir_T\t*virp,\n    int\t\toff,\t\t    // offset for virp->vir_line\n    int\t\tconvert UNUSED)\t    // convert the string\n{\n    char_u\t*retval = NULL;\n    char_u\t*s, *d;\n    long\tlen;\n\n    if (virp->vir_line[off] == Ctrl_V && vim_isdigit(virp->vir_line[off + 1]))\n    {\n\tlen = atol((char *)virp->vir_line + off + 1);\n\tif (len > 0 && len < 1000000)\n\t    retval = lalloc(len, TRUE);\n\tif (retval == NULL)\n\t{\n\t    // Invalid length, line too long, out of memory?  Skip next line.\n\t    (void)vim_fgets(virp->vir_line, 10, virp->vir_fd);\n\t    return NULL;\n\t}\n\t(void)vim_fgets(retval, (int)len, virp->vir_fd);\n\ts = retval + 1;\t    // Skip the leading '<'\n    }\n    else\n    {\n\tretval = vim_strsave(virp->vir_line + off);\n\tif (retval == NULL)\n\t    return NULL;\n\ts = retval;\n    }\n\n    // Change CTRL-V CTRL-V to CTRL-V and CTRL-V n to \\n in-place.\n    d = retval;\n    while (*s != NUL && *s != '\\n')\n    {\n\tif (s[0] == Ctrl_V && s[1] != NUL)\n\t{\n\t    if (s[1] == 'n')\n\t\t*d++ = '\\n';\n\t    else\n\t\t*d++ = Ctrl_V;\n\t    s += 2;\n\t}\n\telse\n\t    *d++ = *s++;\n    }\n    *d = NUL;\n\n    if (convert && virp->vir_conv.vc_type != CONV_NONE && *retval != NUL)\n    {\n\td = string_convert(&virp->vir_conv, retval, NULL);\n\tif (d != NULL)\n\t{\n\t    vim_free(retval);\n\t    retval = d;\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Read a line from the viminfo file.\n * Returns TRUE for end-of-file;\n */\n    static int\nviminfo_readline(vir_T *virp)\n{\n    return vim_fgets(virp->vir_line, LSIZE, virp->vir_fd);\n}\n\n    static int\nread_viminfo_bufferlist(\n    vir_T\t*virp,\n    int\t\twriting)\n{\n    char_u\t*tab;\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    buf_T\t*buf;\n    char_u\t*sfname;\n    char_u\t*xline;\n\n    // Handle long line and escaped characters.\n    xline = viminfo_readstring(virp, 1, FALSE);\n\n    // don't read in if there are files on the command-line or if writing:\n    if (xline != NULL && !writing && ARGCOUNT == 0\n\t\t\t\t       && find_viminfo_parameter('%') != NULL)\n    {\n\t// Format is: <fname> Tab <lnum> Tab <col>.\n\t// Watch out for a Tab in the file name, work from the end.\n\tlnum = 0;\n\tcol = 0;\n\ttab = vim_strrchr(xline, '\\t');\n\tif (tab != NULL)\n\t{\n\t    *tab++ = '\\0';\n\t    col = (colnr_T)atoi((char *)tab);\n\t    tab = vim_strrchr(xline, '\\t');\n\t    if (tab != NULL)\n\t    {\n\t\t*tab++ = '\\0';\n\t\tlnum = atol((char *)tab);\n\t    }\n\t}\n\n\t// Expand \"~/\" in the file name at \"line + 1\" to a full path.\n\t// Then try shortening it by comparing with the current directory\n\texpand_env(xline, NameBuff, MAXPATHL);\n\tsfname = shorten_fname1(NameBuff);\n\n\tbuf = buflist_new(NameBuff, sfname, (linenr_T)0, BLN_LISTED);\n\tif (buf != NULL)\t// just in case...\n\t{\n\t    buf->b_last_cursor.lnum = lnum;\n\t    buf->b_last_cursor.col = col;\n\t    buflist_setfpos(buf, curwin, lnum, col, FALSE);\n\t}\n    }\n    vim_free(xline);\n\n    return viminfo_readline(virp);\n}\n\n/*\n * Return TRUE if \"name\" is on removable media (depending on 'viminfo').\n */\n    static int\nremovable(char_u *name)\n{\n    char_u  *p;\n    char_u  part[51];\n    int\t    retval = FALSE;\n    size_t  n;\n\n    name = home_replace_save(NULL, name);\n    if (name != NULL)\n    {\n\tfor (p = p_viminfo; *p; )\n\t{\n\t    copy_option_part(&p, part, 51, \", \");\n\t    if (part[0] == 'r')\n\t    {\n\t\tn = STRLEN(part + 1);\n\t\tif (MB_STRNICMP(part + 1, name, n) == 0)\n\t\t{\n\t\t    retval = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tvim_free(name);\n    }\n    return retval;\n}\n\n    static void\nwrite_viminfo_bufferlist(FILE *fp)\n{\n    buf_T\t*buf;\n    win_T\t*win;\n    tabpage_T\t*tp;\n    char_u\t*line;\n    int\t\tmax_buffers;\n\n    if (find_viminfo_parameter('%') == NULL)\n\treturn;\n\n    // Without a number -1 is returned: do all buffers.\n    max_buffers = get_viminfo_parameter('%');\n\n    // Allocate room for the file name, lnum and col.\n#define LINE_BUF_LEN (MAXPATHL + 40)\n    line = alloc(LINE_BUF_LEN);\n    if (line == NULL)\n\treturn;\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n\tset_last_cursor(win);\n\n    fputs(_(\"\\n# Buffer list:\\n\"), fp);\n    FOR_ALL_BUFFERS(buf)\n    {\n\tif (buf->b_fname == NULL\n\t\t|| !buf->b_p_bl\n#ifdef FEAT_QUICKFIX\n\t\t|| bt_quickfix(buf)\n#endif\n#ifdef FEAT_TERMINAL\n\t\t|| bt_terminal(buf)\n#endif\n\t\t|| removable(buf->b_ffname))\n\t    continue;\n\n\tif (max_buffers-- == 0)\n\t    break;\n\tputc('%', fp);\n\thome_replace(NULL, buf->b_ffname, line, MAXPATHL, TRUE);\n\tvim_snprintf_add((char *)line, LINE_BUF_LEN, \"\\t%ld\\t%d\",\n\t\t\t(long)buf->b_last_cursor.lnum,\n\t\t\tbuf->b_last_cursor.col);\n\tviminfo_writestring(fp, line);\n    }\n    vim_free(line);\n}\n\n/*\n * Buffers for history read from a viminfo file.  Only valid while reading.\n */\nstatic histentry_T *viminfo_history[HIST_COUNT] =\n\t\t\t\t\t       {NULL, NULL, NULL, NULL, NULL};\nstatic int\tviminfo_hisidx[HIST_COUNT] = {0, 0, 0, 0, 0};\nstatic int\tviminfo_hislen[HIST_COUNT] = {0, 0, 0, 0, 0};\nstatic int\tviminfo_add_at_front = FALSE;\n\n/*\n * Translate a history type number to the associated character.\n */\n    static int\nhist_type2char(\n    int\t    type,\n    int\t    use_question)\t    // use '?' instead of '/'\n{\n    if (type == HIST_CMD)\n\treturn ':';\n    if (type == HIST_SEARCH)\n    {\n\tif (use_question)\n\t    return '?';\n\telse\n\t    return '/';\n    }\n    if (type == HIST_EXPR)\n\treturn '=';\n    return '@';\n}\n\n/*\n * Prepare for reading the history from the viminfo file.\n * This allocates history arrays to store the read history lines.\n */\n    static void\nprepare_viminfo_history(int asklen, int writing)\n{\n    int\t    i;\n    int\t    num;\n    int\t    type;\n    int\t    len;\n    int\t    hislen;\n\n    init_history();\n    hislen = get_hislen();\n    viminfo_add_at_front = (asklen != 0 && !writing);\n    if (asklen > hislen)\n\tasklen = hislen;\n\n    for (type = 0; type < HIST_COUNT; ++type)\n    {\n\thistentry_T *histentry = get_histentry(type);\n\n\t// Count the number of empty spaces in the history list.  Entries read\n\t// from viminfo previously are also considered empty.  If there are\n\t// more spaces available than we request, then fill them up.\n\tfor (i = 0, num = 0; i < hislen; i++)\n\t    if (histentry[i].hisstr == NULL || histentry[i].viminfo)\n\t\tnum++;\n\tlen = asklen;\n\tif (num > len)\n\t    len = num;\n\tif (len <= 0)\n\t    viminfo_history[type] = NULL;\n\telse\n\t    viminfo_history[type] = LALLOC_MULT(histentry_T, len);\n\tif (viminfo_history[type] == NULL)\n\t    len = 0;\n\tviminfo_hislen[type] = len;\n\tviminfo_hisidx[type] = 0;\n    }\n}\n\n/*\n * Accept a line from the viminfo, store it in the history array when it's\n * new.\n */\n    static int\nread_viminfo_history(vir_T *virp, int writing)\n{\n    int\t\ttype;\n    long_u\tlen;\n    char_u\t*val;\n    char_u\t*p;\n\n    type = hist_char2type(virp->vir_line[0]);\n    if (viminfo_hisidx[type] < viminfo_hislen[type])\n    {\n\tval = viminfo_readstring(virp, 1, TRUE);\n\tif (val != NULL && *val != NUL)\n\t{\n\t    int sep = (*val == ' ' ? NUL : *val);\n\n\t    if (!in_history(type, val + (type == HIST_SEARCH),\n\t\t\t\t\t  viminfo_add_at_front, sep, writing))\n\t    {\n\t\t// Need to re-allocate to append the separator byte.\n\t\tlen = STRLEN(val);\n\t\tp = alloc(len + 2);\n\t\tif (p != NULL)\n\t\t{\n\t\t    if (type == HIST_SEARCH)\n\t\t    {\n\t\t\t// Search entry: Move the separator from the first\n\t\t\t// column to after the NUL.\n\t\t\tmch_memmove(p, val + 1, (size_t)len);\n\t\t\tp[len] = sep;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Not a search entry: No separator in the viminfo\n\t\t\t// file, add a NUL separator.\n\t\t\tmch_memmove(p, val, (size_t)len + 1);\n\t\t\tp[len + 1] = NUL;\n\t\t    }\n\t\t    viminfo_history[type][viminfo_hisidx[type]].hisstr = p;\n\t\t    viminfo_history[type][viminfo_hisidx[type]].time_set = 0;\n\t\t    viminfo_history[type][viminfo_hisidx[type]].viminfo = TRUE;\n\t\t    viminfo_history[type][viminfo_hisidx[type]].hisnum = 0;\n\t\t    viminfo_hisidx[type]++;\n\t\t}\n\t    }\n\t}\n\tvim_free(val);\n    }\n    return viminfo_readline(virp);\n}\n\n/*\n * Accept a new style history line from the viminfo, store it in the history\n * array when it's new.\n */\n    static void\nhandle_viminfo_history(\n\tgarray_T    *values,\n\tint\t    writing)\n{\n    int\t\ttype;\n    long_u\tlen;\n    char_u\t*val;\n    char_u\t*p;\n    bval_T\t*vp = (bval_T *)values->ga_data;\n\n    // Check the format:\n    // |{bartype},{histtype},{timestamp},{separator},\"text\"\n    if (values->ga_len < 4\n\t    || vp[0].bv_type != BVAL_NR\n\t    || vp[1].bv_type != BVAL_NR\n\t    || (vp[2].bv_type != BVAL_NR && vp[2].bv_type != BVAL_EMPTY)\n\t    || vp[3].bv_type != BVAL_STRING)\n\treturn;\n\n    type = vp[0].bv_nr;\n    if (type >= HIST_COUNT)\n\treturn;\n    if (viminfo_hisidx[type] < viminfo_hislen[type])\n    {\n\tval = vp[3].bv_string;\n\tif (val != NULL && *val != NUL)\n\t{\n\t    int sep = type == HIST_SEARCH && vp[2].bv_type == BVAL_NR\n\t\t\t\t\t\t      ? vp[2].bv_nr : NUL;\n\t    int idx;\n\t    int overwrite = FALSE;\n\n\t    if (!in_history(type, val, viminfo_add_at_front, sep, writing))\n\t    {\n\t\t// If lines were written by an older Vim we need to avoid\n\t\t// getting duplicates. See if the entry already exists.\n\t\tfor (idx = 0; idx < viminfo_hisidx[type]; ++idx)\n\t\t{\n\t\t    p = viminfo_history[type][idx].hisstr;\n\t\t    if (STRCMP(val, p) == 0\n\t\t\t  && (type != HIST_SEARCH || sep == p[STRLEN(p) + 1]))\n\t\t    {\n\t\t\toverwrite = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tif (!overwrite)\n\t\t{\n\t\t    // Need to re-allocate to append the separator byte.\n\t\t    len = vp[3].bv_len;\n\t\t    p = alloc(len + 2);\n\t\t}\n\t\telse\n\t\t    len = 0; // for picky compilers\n\t\tif (p != NULL)\n\t\t{\n\t\t    viminfo_history[type][idx].time_set = vp[1].bv_nr;\n\t\t    if (!overwrite)\n\t\t    {\n\t\t\tmch_memmove(p, val, (size_t)len + 1);\n\t\t\t// Put the separator after the NUL.\n\t\t\tp[len + 1] = sep;\n\t\t\tviminfo_history[type][idx].hisstr = p;\n\t\t\tviminfo_history[type][idx].hisnum = 0;\n\t\t\tviminfo_history[type][idx].viminfo = TRUE;\n\t\t\tviminfo_hisidx[type]++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Concatenate history lines from viminfo after the lines typed in this Vim.\n */\n    static void\nconcat_history(int type)\n{\n    int\t\tidx;\n    int\t\ti;\n    int\t\thislen = get_hislen();\n    histentry_T *histentry = get_histentry(type);\n    int\t\t*hisidx = get_hisidx(type);\n    int\t\t*hisnum = get_hisnum(type);\n\n    idx = *hisidx + viminfo_hisidx[type];\n    if (idx >= hislen)\n\tidx -= hislen;\n    else if (idx < 0)\n\tidx = hislen - 1;\n    if (viminfo_add_at_front)\n\t*hisidx = idx;\n    else\n    {\n\tif (*hisidx == -1)\n\t    *hisidx = hislen - 1;\n\tdo\n\t{\n\t    if (histentry[idx].hisstr != NULL || histentry[idx].viminfo)\n\t\tbreak;\n\t    if (++idx == hislen)\n\t\tidx = 0;\n\t} while (idx != *hisidx);\n\tif (idx != *hisidx && --idx < 0)\n\t    idx = hislen - 1;\n    }\n    for (i = 0; i < viminfo_hisidx[type]; i++)\n    {\n\tvim_free(histentry[idx].hisstr);\n\thistentry[idx].hisstr = viminfo_history[type][i].hisstr;\n\thistentry[idx].viminfo = TRUE;\n\thistentry[idx].time_set = viminfo_history[type][i].time_set;\n\tif (--idx < 0)\n\t    idx = hislen - 1;\n    }\n    idx += 1;\n    idx %= hislen;\n    for (i = 0; i < viminfo_hisidx[type]; i++)\n    {\n\thistentry[idx++].hisnum = ++*hisnum;\n\tidx %= hislen;\n    }\n}\n\n    static int\nsort_hist(const void *s1, const void *s2)\n{\n    histentry_T *p1 = *(histentry_T **)s1;\n    histentry_T *p2 = *(histentry_T **)s2;\n\n    if (p1->time_set < p2->time_set) return -1;\n    if (p1->time_set > p2->time_set) return 1;\n    return 0;\n}\n\n/*\n * Merge history lines from viminfo and lines typed in this Vim based on the\n * timestamp;\n */\n    static void\nmerge_history(int type)\n{\n    int\t\tmax_len;\n    histentry_T **tot_hist;\n    histentry_T *new_hist;\n    int\t\ti;\n    int\t\tlen;\n    int\t\thislen = get_hislen();\n    histentry_T *histentry = get_histentry(type);\n    int\t\t*hisidx = get_hisidx(type);\n    int\t\t*hisnum = get_hisnum(type);\n\n    // Make one long list with all entries.\n    max_len = hislen + viminfo_hisidx[type];\n    tot_hist = ALLOC_MULT(histentry_T *, max_len);\n    new_hist = ALLOC_MULT(histentry_T, hislen);\n    if (tot_hist == NULL || new_hist == NULL)\n    {\n\tvim_free(tot_hist);\n\tvim_free(new_hist);\n\treturn;\n    }\n    for (i = 0; i < viminfo_hisidx[type]; i++)\n\ttot_hist[i] = &viminfo_history[type][i];\n    len = i;\n    for (i = 0; i < hislen; i++)\n\tif (histentry[i].hisstr != NULL)\n\t    tot_hist[len++] = &histentry[i];\n\n    // Sort the list on timestamp.\n    qsort((void *)tot_hist, (size_t)len, sizeof(histentry_T *), sort_hist);\n\n    // Keep the newest ones.\n    for (i = 0; i < hislen; i++)\n    {\n\tif (i < len)\n\t{\n\t    new_hist[i] = *tot_hist[i];\n\t    tot_hist[i]->hisstr = NULL;\n\t    if (new_hist[i].hisnum == 0)\n\t\tnew_hist[i].hisnum = ++*hisnum;\n\t}\n\telse\n\t    clear_hist_entry(&new_hist[i]);\n    }\n    *hisidx = (i < len ? i : len) - 1;\n\n    // Free what is not kept.\n    for (i = 0; i < viminfo_hisidx[type]; i++)\n\tvim_free(viminfo_history[type][i].hisstr);\n    for (i = 0; i < hislen; i++)\n\tvim_free(histentry[i].hisstr);\n    vim_free(histentry);\n    set_histentry(type, new_hist);\n    vim_free(tot_hist);\n}\n\n/*\n * Finish reading history lines from viminfo.  Not used when writing viminfo.\n */\n    static void\nfinish_viminfo_history(vir_T *virp)\n{\n    int\ttype;\n    int merge = virp->vir_version >= VIMINFO_VERSION_WITH_HISTORY;\n\n    for (type = 0; type < HIST_COUNT; ++type)\n    {\n\tif (get_histentry(type) == NULL)\n\t    continue;\n\n\tif (merge)\n\t    merge_history(type);\n\telse\n\t    concat_history(type);\n\n\tVIM_CLEAR(viminfo_history[type]);\n\tviminfo_hisidx[type] = 0;\n    }\n}\n\n/*\n * Write history to viminfo file in \"fp\".\n * When \"merge\" is TRUE merge history lines with a previously read viminfo\n * file, data is in viminfo_history[].\n * When \"merge\" is FALSE just write all history lines.  Used for \":wviminfo!\".\n */\n    static void\nwrite_viminfo_history(FILE *fp, int merge)\n{\n    int\t    i;\n    int\t    type;\n    int\t    num_saved;\n    int     round;\n    int\t    hislen;\n\n    init_history();\n    hislen = get_hislen();\n    if (hislen == 0)\n\treturn;\n    for (type = 0; type < HIST_COUNT; ++type)\n    {\n\thistentry_T *histentry = get_histentry(type);\n\tint\t    *hisidx = get_hisidx(type);\n\n\tnum_saved = get_viminfo_parameter(hist_type2char(type, FALSE));\n\tif (num_saved == 0)\n\t    continue;\n\tif (num_saved < 0)  // Use default\n\t    num_saved = hislen;\n\tfprintf(fp, _(\"\\n# %s History (newest to oldest):\\n\"),\n\t\t\t    type == HIST_CMD ? _(\"Command Line\") :\n\t\t\t    type == HIST_SEARCH ? _(\"Search String\") :\n\t\t\t    type == HIST_EXPR ? _(\"Expression\") :\n\t\t\t    type == HIST_INPUT ? _(\"Input Line\") :\n\t\t\t\t\t_(\"Debug Line\"));\n\tif (num_saved > hislen)\n\t    num_saved = hislen;\n\n\t// Merge typed and viminfo history:\n\t// round 1: history of typed commands.\n\t// round 2: history from recently read viminfo.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    if (round == 1)\n\t\t// start at newest entry, somewhere in the list\n\t\ti = *hisidx;\n\t    else if (viminfo_hisidx[type] > 0)\n\t\t// start at newest entry, first in the list\n\t\ti = 0;\n\t    else\n\t\t// empty list\n\t\ti = -1;\n\t    if (i >= 0)\n\t\twhile (num_saved > 0\n\t\t\t&& !(round == 2 && i >= viminfo_hisidx[type]))\n\t\t{\n\t\t    char_u  *p;\n\t\t    time_t  timestamp;\n\t\t    int\t    c = NUL;\n\n\t\t    if (round == 1)\n\t\t    {\n\t\t\tp = histentry[i].hisstr;\n\t\t\ttimestamp = histentry[i].time_set;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tp = viminfo_history[type] == NULL ? NULL\n\t\t\t\t\t    : viminfo_history[type][i].hisstr;\n\t\t\ttimestamp = viminfo_history[type] == NULL ? 0\n\t\t\t\t\t  : viminfo_history[type][i].time_set;\n\t\t    }\n\n\t\t    if (p != NULL && (round == 2\n\t\t\t\t       || !merge\n\t\t\t\t       || !histentry[i].viminfo))\n\t\t    {\n\t\t\t--num_saved;\n\t\t\tfputc(hist_type2char(type, TRUE), fp);\n\t\t\t// For the search history: put the separator in the\n\t\t\t// second column; use a space if there isn't one.\n\t\t\tif (type == HIST_SEARCH)\n\t\t\t{\n\t\t\t    c = p[STRLEN(p) + 1];\n\t\t\t    putc(c == NUL ? ' ' : c, fp);\n\t\t\t}\n\t\t\tviminfo_writestring(fp, p);\n\n\t\t\t{\n\t\t\t    char    cbuf[NUMBUFLEN];\n\n\t\t\t    // New style history with a bar line. Format:\n\t\t\t    // |{bartype},{histtype},{timestamp},{separator},\"text\"\n\t\t\t    if (c == NUL)\n\t\t\t\tcbuf[0] = NUL;\n\t\t\t    else\n\t\t\t\tsprintf(cbuf, \"%d\", c);\n\t\t\t    fprintf(fp, \"|%d,%d,%ld,%s,\", BARTYPE_HISTORY,\n\t\t\t\t\t\t type, (long)timestamp, cbuf);\n\t\t\t    barline_writestring(fp, p, LSIZE - 20);\n\t\t\t    putc('\\n', fp);\n\t\t\t}\n\t\t    }\n\t\t    if (round == 1)\n\t\t    {\n\t\t\t// Decrement index, loop around and stop when back at\n\t\t\t// the start.\n\t\t\tif (--i < 0)\n\t\t\t    i = hislen - 1;\n\t\t\tif (i == *hisidx)\n\t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Increment index. Stop at the end in the while.\n\t\t\t++i;\n\t\t    }\n\t\t}\n\t}\n\tfor (i = 0; i < viminfo_hisidx[type]; ++i)\n\t    if (viminfo_history[type] != NULL)\n\t\tvim_free(viminfo_history[type][i].hisstr);\n\tVIM_CLEAR(viminfo_history[type]);\n\tviminfo_hisidx[type] = 0;\n    }\n}\n\n    static void\nwrite_viminfo_barlines(vir_T *virp, FILE *fp_out)\n{\n    int\t\ti;\n    garray_T\t*gap = &virp->vir_barlines;\n    int\t\tseen_useful = FALSE;\n    char\t*line;\n\n    if (gap->ga_len > 0)\n    {\n\tfputs(_(\"\\n# Bar lines, copied verbatim:\\n\"), fp_out);\n\n\t// Skip over continuation lines until seeing a useful line.\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    line = ((char **)(gap->ga_data))[i];\n\t    if (seen_useful || line[1] != '<')\n\t    {\n\t\tfputs(line, fp_out);\n\t\tseen_useful = TRUE;\n\t    }\n\t}\n    }\n}\n\n/*\n * Parse a viminfo line starting with '|'.\n * Add each decoded value to \"values\".\n * Returns TRUE if the next line is to be read after using the parsed values.\n */\n    static int\nbarline_parse(vir_T *virp, char_u *text, garray_T *values)\n{\n    char_u  *p = text;\n    char_u  *nextp = NULL;\n    char_u  *buf = NULL;\n    bval_T  *value;\n    int\t    i;\n    int\t    allocated = FALSE;\n    int\t    eof;\n    char_u  *sconv;\n    int\t    converted;\n\n    while (*p == ',')\n    {\n\t++p;\n\tif (ga_grow(values, 1) == FAIL)\n\t    break;\n\tvalue = (bval_T *)(values->ga_data) + values->ga_len;\n\n\tif (*p == '>')\n\t{\n\t    // Need to read a continuation line.  Put strings in allocated\n\t    // memory, because virp->vir_line is overwritten.\n\t    if (!allocated)\n\t    {\n\t\tfor (i = 0; i < values->ga_len; ++i)\n\t\t{\n\t\t    bval_T  *vp = (bval_T *)(values->ga_data) + i;\n\n\t\t    if (vp->bv_type == BVAL_STRING && !vp->bv_allocated)\n\t\t    {\n\t\t\tvp->bv_string = vim_strnsave(vp->bv_string, vp->bv_len);\n\t\t\tvp->bv_allocated = TRUE;\n\t\t    }\n\t\t}\n\t\tallocated = TRUE;\n\t    }\n\n\t    if (vim_isdigit(p[1]))\n\t    {\n\t\tsize_t len;\n\t\tsize_t todo;\n\t\tsize_t n;\n\n\t\t// String value was split into lines that are each shorter\n\t\t// than LSIZE:\n\t\t//     |{bartype},>{length of \"{text}{text2}\"}\n\t\t//     |<\"{text1}\n\t\t//     |<{text2}\",{value}\n\t\t// Length includes the quotes.\n\t\t++p;\n\t\tlen = getdigits(&p);\n\t\tbuf = alloc((int)(len + 1));\n\t\tif (buf == NULL)\n\t\t    return TRUE;\n\t\tp = buf;\n\t\tfor (todo = len; todo > 0; todo -= n)\n\t\t{\n\t\t    eof = viminfo_readline(virp);\n\t\t    if (eof || virp->vir_line[0] != '|'\n\t\t\t\t\t\t  || virp->vir_line[1] != '<')\n\t\t    {\n\t\t\t// File was truncated or garbled. Read another line if\n\t\t\t// this one starts with '|'.\n\t\t\tvim_free(buf);\n\t\t\treturn eof || virp->vir_line[0] == '|';\n\t\t    }\n\t\t    // Get length of text, excluding |< and NL chars.\n\t\t    n = STRLEN(virp->vir_line);\n\t\t    while (n > 0 && (virp->vir_line[n - 1] == NL\n\t\t\t\t\t     || virp->vir_line[n - 1] == CAR))\n\t\t\t--n;\n\t\t    n -= 2;\n\t\t    if (n > todo)\n\t\t    {\n\t\t\t// more values follow after the string\n\t\t\tnextp = virp->vir_line + 2 + todo;\n\t\t\tn = todo;\n\t\t    }\n\t\t    mch_memmove(p, virp->vir_line + 2, n);\n\t\t    p += n;\n\t\t}\n\t\t*p = NUL;\n\t\tp = buf;\n\t    }\n\t    else\n\t    {\n\t\t// Line ending in \">\" continues in the next line:\n\t\t//     |{bartype},{lots of values},>\n\t\t//     |<{value},{value}\n\t\teof = viminfo_readline(virp);\n\t\tif (eof || virp->vir_line[0] != '|'\n\t\t\t\t\t      || virp->vir_line[1] != '<')\n\t\t    // File was truncated or garbled. Read another line if\n\t\t    // this one starts with '|'.\n\t\t    return eof || virp->vir_line[0] == '|';\n\t\tp = virp->vir_line + 2;\n\t    }\n\t}\n\n\tif (isdigit(*p))\n\t{\n\t    value->bv_type = BVAL_NR;\n\t    value->bv_nr = getdigits(&p);\n\t    ++values->ga_len;\n\t}\n\telse if (*p == '\"')\n\t{\n\t    int\t    len = 0;\n\t    char_u  *s = p;\n\n\t    // Unescape special characters in-place.\n\t    ++p;\n\t    while (*p != '\"')\n\t    {\n\t\tif (*p == NL || *p == NUL)\n\t\t    return TRUE;  // syntax error, drop the value\n\t\tif (*p == '\\\\')\n\t\t{\n\t\t    ++p;\n\t\t    if (*p == 'n')\n\t\t\ts[len++] = '\\n';\n\t\t    else\n\t\t\ts[len++] = *p;\n\t\t    ++p;\n\t\t}\n\t\telse\n\t\t    s[len++] = *p++;\n\t    }\n\t    ++p;\n\t    s[len] = NUL;\n\n\t    converted = FALSE;\n\t    value->bv_tofree = NULL;\n\t    if (virp->vir_conv.vc_type != CONV_NONE && *s != NUL)\n\t    {\n\t\tsconv = string_convert(&virp->vir_conv, s, NULL);\n\t\tif (sconv != NULL)\n\t\t{\n\t\t    if (s == buf)\n\t\t\t// the converted string is stored in bv_string and\n\t\t\t// freed later, also need to free \"buf\" later\n\t\t\tvalue->bv_tofree = buf;\n\t\t    s = sconv;\n\t\t    converted = TRUE;\n\t\t}\n\t    }\n\n\t    // Need to copy in allocated memory if the string wasn't allocated\n\t    // above and we did allocate before, thus vir_line may change.\n\t    if (s != buf && allocated && !converted)\n\t\ts = vim_strsave(s);\n\t    value->bv_string = s;\n\t    value->bv_type = BVAL_STRING;\n\t    value->bv_len = len;\n\t    value->bv_allocated = allocated || converted;\n\t    ++values->ga_len;\n\t    if (nextp != NULL)\n\t    {\n\t\t// values following a long string\n\t\tp = nextp;\n\t\tnextp = NULL;\n\t    }\n\t}\n\telse if (*p == ',')\n\t{\n\t    value->bv_type = BVAL_EMPTY;\n\t    ++values->ga_len;\n\t}\n\telse\n\t    break;\n    }\n    return TRUE;\n}\n\n    static void\nwrite_viminfo_version(FILE *fp_out)\n{\n    fprintf(fp_out, \"# Viminfo version\\n|%d,%d\\n\\n\",\n\t\t\t\t\t    BARTYPE_VERSION, VIMINFO_VERSION);\n}\n\n    static int\nno_viminfo(void)\n{\n    // \"vim -i NONE\" does not read or write a viminfo file\n    return STRCMP(p_viminfofile, \"NONE\") == 0;\n}\n\n/*\n * Report an error for reading a viminfo file.\n * Count the number of errors.\tWhen there are more than 10, return TRUE.\n */\n    static int\nviminfo_error(char *errnum, char *message, char_u *line)\n{\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"%sviminfo: %s in line: \"),\n\t\t\t\t\t\t\t     errnum, message);\n    STRNCAT(IObuff, line, IOSIZE - STRLEN(IObuff) - 1);\n    if (IObuff[STRLEN(IObuff) - 1] == '\\n')\n\tIObuff[STRLEN(IObuff) - 1] = NUL;\n    emsg((char *)IObuff);\n    if (++viminfo_errcnt >= 10)\n    {\n\temsg(_(e_viminfo_too_many_errors_skipping_rest_of_file));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Compare the 'encoding' value in the viminfo file with the current value of\n * 'encoding'.  If different and the 'c' flag is in 'viminfo', setup for\n * conversion of text with iconv() in viminfo_readstring().\n */\n    static int\nviminfo_encoding(vir_T *virp)\n{\n    char_u\t*p;\n    int\t\ti;\n\n    if (get_viminfo_parameter('c') != 0)\n    {\n\tp = vim_strchr(virp->vir_line, '=');\n\tif (p != NULL)\n\t{\n\t    // remove trailing newline\n\t    ++p;\n\t    for (i = 0; vim_isprintc(p[i]); ++i)\n\t\t;\n\t    p[i] = NUL;\n\n\t    convert_setup(&virp->vir_conv, p, p_enc);\n\t}\n    }\n    return viminfo_readline(virp);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Restore global vars that start with a capital from the viminfo file\n */\n    static int\nread_viminfo_varlist(vir_T *virp, int writing)\n{\n    char_u\t*tab;\n    int\t\ttype = VAR_NUMBER;\n    typval_T\ttv;\n    funccal_entry_T funccal_entry;\n\n    if (!writing && (find_viminfo_parameter('!') != NULL))\n    {\n\ttab = vim_strchr(virp->vir_line + 1, '\\t');\n\tif (tab != NULL)\n\t{\n\t    *tab++ = '\\0';\t// isolate the variable name\n\t    switch (*tab)\n\t    {\n\t\tcase 'S': type = VAR_STRING; break;\n#ifdef FEAT_FLOAT\n\t\tcase 'F': type = VAR_FLOAT; break;\n#endif\n\t\tcase 'D': type = VAR_DICT; break;\n\t\tcase 'L': type = VAR_LIST; break;\n\t\tcase 'B': type = VAR_BLOB; break;\n\t\tcase 'X': type = VAR_SPECIAL; break;\n\t    }\n\n\t    tab = vim_strchr(tab, '\\t');\n\t    if (tab != NULL)\n\t    {\n\t\ttv.v_type = type;\n\t\tif (type == VAR_STRING || type == VAR_DICT\n\t\t\t|| type == VAR_LIST || type == VAR_BLOB)\n\t\t    tv.vval.v_string = viminfo_readstring(virp,\n\t\t\t\t       (int)(tab - virp->vir_line + 1), TRUE);\n#ifdef FEAT_FLOAT\n\t\telse if (type == VAR_FLOAT)\n\t\t    (void)string2float(tab + 1, &tv.vval.v_float, FALSE);\n#endif\n\t\telse\n\t\t{\n\t\t    tv.vval.v_number = atol((char *)tab + 1);\n\t\t    if (type == VAR_SPECIAL && (tv.vval.v_number == VVAL_FALSE\n\t\t\t\t\t     || tv.vval.v_number == VVAL_TRUE))\n\t\t\ttv.v_type = VAR_BOOL;\n\t\t}\n\t\tif (type == VAR_DICT || type == VAR_LIST)\n\t\t{\n\t\t    typval_T *etv = eval_expr(tv.vval.v_string, NULL);\n\n\t\t    if (etv == NULL)\n\t\t\t// Failed to parse back the dict or list, use it as a\n\t\t\t// string.\n\t\t\ttv.v_type = VAR_STRING;\n\t\t    else\n\t\t    {\n\t\t\tvim_free(tv.vval.v_string);\n\t\t\ttv = *etv;\n\t\t\tvim_free(etv);\n\t\t    }\n\t\t}\n\t\telse if (type == VAR_BLOB)\n\t\t{\n\t\t    blob_T *blob = string2blob(tv.vval.v_string);\n\n\t\t    if (blob == NULL)\n\t\t\t// Failed to parse back the blob, use it as a string.\n\t\t\ttv.v_type = VAR_STRING;\n\t\t    else\n\t\t    {\n\t\t\tvim_free(tv.vval.v_string);\n\t\t\ttv.v_type = VAR_BLOB;\n\t\t\ttv.vval.v_blob = blob;\n\t\t    }\n\t\t}\n\n\t\t// when in a function use global variables\n\t\tsave_funccal(&funccal_entry);\n\t\tset_var(virp->vir_line + 1, &tv, FALSE);\n\t\trestore_funccal();\n\n\t\tif (tv.v_type == VAR_STRING)\n\t\t    vim_free(tv.vval.v_string);\n\t\telse if (tv.v_type == VAR_DICT || tv.v_type == VAR_LIST ||\n\t\t\ttv.v_type == VAR_BLOB)\n\t\t    clear_tv(&tv);\n\t    }\n\t}\n    }\n\n    return viminfo_readline(virp);\n}\n\n/*\n * Write global vars that start with a capital to the viminfo file\n */\n    static void\nwrite_viminfo_varlist(FILE *fp)\n{\n    hashtab_T\t*gvht = get_globvar_ht();\n    hashitem_T\t*hi;\n    dictitem_T\t*this_var;\n    int\t\ttodo;\n    char\t*s = \"\";\n    char_u\t*p;\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    if (find_viminfo_parameter('!') == NULL)\n\treturn;\n\n    fputs(_(\"\\n# global variables:\\n\"), fp);\n\n    todo = (int)gvht->ht_used;\n    for (hi = gvht->ht_array; todo > 0; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    this_var = HI2DI(hi);\n\t    if (var_flavour(this_var->di_key) == VAR_FLAVOUR_VIMINFO)\n\t    {\n\t\tswitch (this_var->di_tv.v_type)\n\t\t{\n\t\t    case VAR_STRING:  s = \"STR\"; break;\n\t\t    case VAR_NUMBER:  s = \"NUM\"; break;\n\t\t    case VAR_FLOAT:   s = \"FLO\"; break;\n\t\t    case VAR_DICT:\n\t\t\t  {\n\t\t\t      dict_T\t*di = this_var->di_tv.vval.v_dict;\n\t\t\t      int\tcopyID = get_copyID();\n\n\t\t\t      s = \"DIC\";\n\t\t\t      if (di != NULL && !set_ref_in_ht(\n\t\t\t\t\t\t &di->dv_hashtab, copyID, NULL)\n\t\t\t\t      && di->dv_copyID == copyID)\n\t\t\t\t  // has a circular reference, can't turn the\n\t\t\t\t  // value into a string\n\t\t\t\t  continue;\n\t\t\t      break;\n\t\t\t  }\n\t\t    case VAR_LIST:\n\t\t\t  {\n\t\t\t      list_T\t*l = this_var->di_tv.vval.v_list;\n\t\t\t      int\tcopyID = get_copyID();\n\n\t\t\t      s = \"LIS\";\n\t\t\t      if (l != NULL && !set_ref_in_list_items(\n\t\t\t\t\t\t\t       l, copyID, NULL)\n\t\t\t\t      && l->lv_copyID == copyID)\n\t\t\t\t  // has a circular reference, can't turn the\n\t\t\t\t  // value into a string\n\t\t\t\t  continue;\n\t\t\t      break;\n\t\t\t  }\n\t\t    case VAR_BLOB:    s = \"BLO\"; break;\n\t\t    case VAR_BOOL:    s = \"XPL\"; break;  // backwards compat.\n\t\t    case VAR_SPECIAL: s = \"XPL\"; break;\n\n\t\t    case VAR_UNKNOWN:\n\t\t    case VAR_ANY:\n\t\t    case VAR_VOID:\n\t\t    case VAR_FUNC:\n\t\t    case VAR_PARTIAL:\n\t\t    case VAR_JOB:\n\t\t    case VAR_CHANNEL:\n\t\t    case VAR_INSTR:\n\t\t\t\t     continue;\n\t\t}\n\t\tfprintf(fp, \"!%s\\t%s\\t\", this_var->di_key, s);\n\t\tif (this_var->di_tv.v_type == VAR_BOOL\n\t\t\t\t      || this_var->di_tv.v_type == VAR_SPECIAL)\n\t\t{\n\t\t    // do not use \"v:true\" but \"1\"\n\t\t    sprintf((char *)numbuf, \"%ld\",\n\t\t\t\t\t  (long)this_var->di_tv.vval.v_number);\n\t\t    p = numbuf;\n\t\t    tofree = NULL;\n\t\t}\n\t\telse\n\t\t    p = echo_string(&this_var->di_tv, &tofree, numbuf, 0);\n\t\tif (p != NULL)\n\t\t    viminfo_writestring(fp, p);\n\t\tvim_free(tofree);\n\t    }\n\t}\n    }\n}\n#endif // FEAT_EVAL\n\n    static int\nread_viminfo_sub_string(vir_T *virp, int force)\n{\n    if (force || get_old_sub() == NULL)\n\tset_old_sub(viminfo_readstring(virp, 1, TRUE));\n    return viminfo_readline(virp);\n}\n\n    static void\nwrite_viminfo_sub_string(FILE *fp)\n{\n    char_u *old_sub = get_old_sub();\n\n    if (get_viminfo_parameter('/') != 0 && old_sub != NULL)\n    {\n\tfputs(_(\"\\n# Last Substitute String:\\n$\"), fp);\n\tviminfo_writestring(fp, old_sub);\n    }\n}\n\n/*\n * Functions relating to reading/writing the search pattern from viminfo\n */\n\n    static int\nread_viminfo_search_pattern(vir_T *virp, int force)\n{\n    char_u\t*lp;\n    int\t\tidx = -1;\n    int\t\tmagic = FALSE;\n    int\t\tno_scs = FALSE;\n    int\t\toff_line = FALSE;\n    int\t\toff_end = 0;\n    long\toff = 0;\n    int\t\tsetlast = FALSE;\n#ifdef FEAT_SEARCH_EXTRA\n    static int\thlsearch_on = FALSE;\n#endif\n    char_u\t*val;\n    spat_T\t*spat;\n\n    // Old line types:\n    // \"/pat\", \"&pat\": search/subst. pat\n    // \"~/pat\", \"~&pat\": last used search/subst. pat\n    // New line types:\n    // \"~h\", \"~H\": hlsearch highlighting off/on\n    // \"~<magic><smartcase><line><end><off><last><which>pat\"\n    // <magic>: 'm' off, 'M' on\n    // <smartcase>: 's' off, 'S' on\n    // <line>: 'L' line offset, 'l' char offset\n    // <end>: 'E' from end, 'e' from start\n    // <off>: decimal, offset\n    // <last>: '~' last used pattern\n    // <which>: '/' search pat, '&' subst. pat\n    lp = virp->vir_line;\n    if (lp[0] == '~' && (lp[1] == 'm' || lp[1] == 'M'))\t// new line type\n    {\n\tif (lp[1] == 'M')\t\t// magic on\n\t    magic = TRUE;\n\tif (lp[2] == 's')\n\t    no_scs = TRUE;\n\tif (lp[3] == 'L')\n\t    off_line = TRUE;\n\tif (lp[4] == 'E')\n\t    off_end = SEARCH_END;\n\tlp += 5;\n\toff = getdigits(&lp);\n    }\n    if (lp[0] == '~')\t\t// use this pattern for last-used pattern\n    {\n\tsetlast = TRUE;\n\tlp++;\n    }\n    if (lp[0] == '/')\n\tidx = RE_SEARCH;\n    else if (lp[0] == '&')\n\tidx = RE_SUBST;\n#ifdef FEAT_SEARCH_EXTRA\n    else if (lp[0] == 'h')\t// ~h: 'hlsearch' highlighting off\n\thlsearch_on = FALSE;\n    else if (lp[0] == 'H')\t// ~H: 'hlsearch' highlighting on\n\thlsearch_on = TRUE;\n#endif\n    if (idx >= 0)\n    {\n\tspat = get_spat(idx);\n\tif (force || spat->pat == NULL)\n\t{\n\t    val = viminfo_readstring(virp, (int)(lp - virp->vir_line + 1),\n\t\t\t\t\t\t\t\t\tTRUE);\n\t    if (val != NULL)\n\t    {\n\t\tset_last_search_pat(val, idx, magic, setlast);\n\t\tvim_free(val);\n\t\tspat->no_scs = no_scs;\n\t\tspat->off.line = off_line;\n\t\tspat->off.end = off_end;\n\t\tspat->off.off = off;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (setlast)\n\t\t    set_no_hlsearch(!hlsearch_on);\n#endif\n\t    }\n\t}\n    }\n    return viminfo_readline(virp);\n}\n\n    static void\nwvsp_one(\n    FILE\t*fp,\t// file to write to\n    int\t\tidx,\t// spats[] index\n    char\t*s,\t// search pat\n    int\t\tsc)\t// dir char\n{\n    spat_T\t*spat = get_spat(idx);\n    if (spat->pat != NULL)\n    {\n\tfprintf(fp, _(\"\\n# Last %sSearch Pattern:\\n~\"), s);\n\t// off.dir is not stored, it's reset to forward\n\tfprintf(fp, \"%c%c%c%c%ld%s%c\",\n\t\tspat->magic    ? 'M' : 'm',\t// magic\n\t\tspat->no_scs   ? 's' : 'S',\t// smartcase\n\t\tspat->off.line ? 'L' : 'l',\t// line offset\n\t\tspat->off.end  ? 'E' : 'e',\t// offset from end\n\t\tspat->off.off,\t\t\t// offset\n\t\tget_spat_last_idx() == idx ? \"~\" : \"\",\t// last used pat\n\t\tsc);\n\tviminfo_writestring(fp, spat->pat);\n    }\n}\n\n    static void\nwrite_viminfo_search_pattern(FILE *fp)\n{\n    if (get_viminfo_parameter('/') != 0)\n    {\n#ifdef FEAT_SEARCH_EXTRA\n\tfprintf(fp, \"\\n# hlsearch on (H) or off (h):\\n~%c\",\n\t    (no_hlsearch || find_viminfo_parameter('h') != NULL) ? 'h' : 'H');\n#endif\n\twvsp_one(fp, RE_SEARCH, \"\", '/');\n\twvsp_one(fp, RE_SUBST, _(\"Substitute \"), '&');\n    }\n}\n\n/*\n * Functions relating to reading/writing registers from viminfo\n */\n\nstatic yankreg_T *y_read_regs = NULL;\n\n#define REG_PREVIOUS 1\n#define REG_EXEC 2\n\n/*\n * Prepare for reading viminfo registers when writing viminfo later.\n */\n    static void\nprepare_viminfo_registers(void)\n{\n     y_read_regs = ALLOC_CLEAR_MULT(yankreg_T, NUM_REGISTERS);\n}\n\n    static void\nfinish_viminfo_registers(void)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (y_read_regs != NULL)\n    {\n\tfor (i = 0; i < NUM_REGISTERS; ++i)\n\t    if (y_read_regs[i].y_array != NULL)\n\t    {\n\t\tfor (j = 0; j < y_read_regs[i].y_size; j++)\n\t\t    vim_free(y_read_regs[i].y_array[j]);\n\t\tvim_free(y_read_regs[i].y_array);\n\t    }\n\tVIM_CLEAR(y_read_regs);\n    }\n}\n\n    static int\nread_viminfo_register(vir_T *virp, int force)\n{\n    int\t\teof;\n    int\t\tdo_it = TRUE;\n    int\t\tsize;\n    int\t\tlimit;\n    int\t\ti;\n    int\t\tset_prev = FALSE;\n    char_u\t*str;\n    char_u\t**array = NULL;\n    int\t\tnew_type = MCHAR; // init to shut up compiler\n    colnr_T\tnew_width = 0; // init to shut up compiler\n    yankreg_T\t*y_current_p;\n\n    // We only get here (hopefully) if line[0] == '\"'\n    str = virp->vir_line + 1;\n\n    // If the line starts with \"\" this is the y_previous register.\n    if (*str == '\"')\n    {\n\tset_prev = TRUE;\n\tstr++;\n    }\n\n    if (!ASCII_ISALNUM(*str) && *str != '-')\n    {\n\tif (viminfo_error(\"E577: \", _(e_illegal_register_name), virp->vir_line))\n\t    return TRUE;\t// too many errors, pretend end-of-file\n\tdo_it = FALSE;\n    }\n    get_yank_register(*str++, FALSE);\n    y_current_p = get_y_current();\n    if (!force && y_current_p->y_array != NULL)\n\tdo_it = FALSE;\n\n    if (*str == '@')\n    {\n\t// \"x@: register x used for @@\n\tif (force || get_execreg_lastc() == NUL)\n\t    set_execreg_lastc(str[-1]);\n    }\n\n    size = 0;\n    limit = 100;\t// Optimized for registers containing <= 100 lines\n    if (do_it)\n    {\n\t// Build the new register in array[].\n\t// y_array is kept as-is until done.\n\t// The \"do_it\" flag is reset when something is wrong, in which case\n\t// array[] needs to be freed.\n\tif (set_prev)\n\t    set_y_previous(y_current_p);\n\tarray = ALLOC_MULT(char_u *, limit);\n\tstr = skipwhite(skiptowhite(str));\n\tif (STRNCMP(str, \"CHAR\", 4) == 0)\n\t    new_type = MCHAR;\n\telse if (STRNCMP(str, \"BLOCK\", 5) == 0)\n\t    new_type = MBLOCK;\n\telse\n\t    new_type = MLINE;\n\t// get the block width; if it's missing we get a zero, which is OK\n\tstr = skipwhite(skiptowhite(str));\n\tnew_width = getdigits(&str);\n    }\n\n    while (!(eof = viminfo_readline(virp))\n\t\t    && (virp->vir_line[0] == TAB || virp->vir_line[0] == '<'))\n    {\n\tif (do_it)\n\t{\n\t    if (size == limit)\n\t    {\n\t\tchar_u **new_array = (char_u **)\n\t\t\t\t\t   alloc(limit * 2 * sizeof(char_u *));\n\n\t\tif (new_array == NULL)\n\t\t{\n\t\t    do_it = FALSE;\n\t\t    break;\n\t\t}\n\t\tfor (i = 0; i < limit; i++)\n\t\t    new_array[i] = array[i];\n\t\tvim_free(array);\n\t\tarray = new_array;\n\t\tlimit *= 2;\n\t    }\n\t    str = viminfo_readstring(virp, 1, TRUE);\n\t    if (str != NULL)\n\t\tarray[size++] = str;\n\t    else\n\t\t// error, don't store the result\n\t\tdo_it = FALSE;\n\t}\n    }\n\n    if (do_it)\n    {\n\t// free y_array[]\n\tfor (i = 0; i < y_current_p->y_size; i++)\n\t    vim_free(y_current_p->y_array[i]);\n\tvim_free(y_current_p->y_array);\n\n\ty_current_p->y_type = new_type;\n\ty_current_p->y_width = new_width;\n\ty_current_p->y_size = size;\n\ty_current_p->y_time_set = 0;\n\tif (size == 0)\n\t{\n\t    y_current_p->y_array = NULL;\n\t}\n\telse\n\t{\n\t    // Move the lines from array[] to y_array[].\n\t    y_current_p->y_array = ALLOC_MULT(char_u *, size);\n\t    for (i = 0; i < size; i++)\n\t    {\n\t\tif (y_current_p->y_array == NULL)\n\t\t    vim_free(array[i]);\n\t\telse\n\t\t    y_current_p->y_array[i] = array[i];\n\t    }\n\t}\n    }\n    else\n    {\n\t// Free array[] if it was filled.\n\tfor (i = 0; i < size; i++)\n\t    vim_free(array[i]);\n    }\n    vim_free(array);\n\n    return eof;\n}\n\n/*\n * Accept a new style register line from the viminfo, store it when it's new.\n */\n    static void\nhandle_viminfo_register(garray_T *values, int force)\n{\n    bval_T\t*vp = (bval_T *)values->ga_data;\n    int\t\tflags;\n    int\t\tname;\n    int\t\ttype;\n    int\t\tlinecount;\n    int\t\twidth;\n    time_t\ttimestamp;\n    yankreg_T\t*y_ptr;\n    yankreg_T\t*y_regs_p = get_y_regs();\n    int\t\ti;\n\n    // Check the format:\n    // |{bartype},{flags},{name},{type},\n    //      {linecount},{width},{timestamp},\"line1\",\"line2\"\n    if (values->ga_len < 6\n\t    || vp[0].bv_type != BVAL_NR\n\t    || vp[1].bv_type != BVAL_NR\n\t    || vp[2].bv_type != BVAL_NR\n\t    || vp[3].bv_type != BVAL_NR\n\t    || vp[4].bv_type != BVAL_NR\n\t    || vp[5].bv_type != BVAL_NR)\n\treturn;\n    flags = vp[0].bv_nr;\n    name = vp[1].bv_nr;\n    if (name < 0 || name >= NUM_REGISTERS)\n\treturn;\n    type = vp[2].bv_nr;\n    if (type != MCHAR && type != MLINE && type != MBLOCK)\n\treturn;\n    linecount = vp[3].bv_nr;\n    if (values->ga_len < 6 + linecount)\n\treturn;\n    width = vp[4].bv_nr;\n    if (width < 0)\n\treturn;\n\n    if (y_read_regs != NULL)\n\t// Reading viminfo for merging and writing.  Store the register\n\t// content, don't update the current registers.\n\ty_ptr = &y_read_regs[name];\n    else\n\ty_ptr = &y_regs_p[name];\n\n    // Do not overwrite unless forced or the timestamp is newer.\n    timestamp = (time_t)vp[5].bv_nr;\n    if (y_ptr->y_array != NULL && !force\n\t\t\t && (timestamp == 0 || y_ptr->y_time_set > timestamp))\n\treturn;\n\n    if (y_ptr->y_array != NULL)\n\tfor (i = 0; i < y_ptr->y_size; i++)\n\t    vim_free(y_ptr->y_array[i]);\n    vim_free(y_ptr->y_array);\n\n    if (y_read_regs == NULL)\n    {\n\tif (flags & REG_PREVIOUS)\n\t    set_y_previous(y_ptr);\n\tif ((flags & REG_EXEC) && (force || get_execreg_lastc() == NUL))\n\t    set_execreg_lastc(get_register_name(name));\n    }\n    y_ptr->y_type = type;\n    y_ptr->y_width = width;\n    y_ptr->y_size = linecount;\n    y_ptr->y_time_set = timestamp;\n    if (linecount == 0)\n    {\n\ty_ptr->y_array = NULL;\n\treturn;\n    }\n    y_ptr->y_array = ALLOC_MULT(char_u *, linecount);\n    if (y_ptr->y_array == NULL)\n    {\n\ty_ptr->y_size = 0; // ensure object state is consistent\n\treturn;\n    }\n    for (i = 0; i < linecount; i++)\n    {\n\tif (vp[i + 6].bv_allocated)\n\t{\n\t    y_ptr->y_array[i] = vp[i + 6].bv_string;\n\t    vp[i + 6].bv_string = NULL;\n\t}\n\telse\n\t    y_ptr->y_array[i] = vim_strsave(vp[i + 6].bv_string);\n    }\n}\n\n    static void\nwrite_viminfo_registers(FILE *fp)\n{\n    int\t\ti, j;\n    char_u\t*type;\n    char_u\tc;\n    int\t\tnum_lines;\n    int\t\tmax_num_lines;\n    int\t\tmax_kbyte;\n    long\tlen;\n    yankreg_T\t*y_ptr;\n    yankreg_T\t*y_regs_p = get_y_regs();;\n\n    fputs(_(\"\\n# Registers:\\n\"), fp);\n\n    // Get '<' value, use old '\"' value if '<' is not found.\n    max_num_lines = get_viminfo_parameter('<');\n    if (max_num_lines < 0)\n\tmax_num_lines = get_viminfo_parameter('\"');\n    if (max_num_lines == 0)\n\treturn;\n    max_kbyte = get_viminfo_parameter('s');\n    if (max_kbyte == 0)\n\treturn;\n\n    for (i = 0; i < NUM_REGISTERS; i++)\n    {\n#ifdef FEAT_CLIPBOARD\n\t// Skip '*'/'+' register, we don't want them back next time\n\tif (i == STAR_REGISTER || i == PLUS_REGISTER)\n\t    continue;\n#endif\n#ifdef FEAT_DND\n\t// Neither do we want the '~' register\n\tif (i == TILDE_REGISTER)\n\t    continue;\n#endif\n\t// When reading viminfo for merging and writing: Use the register from\n\t// viminfo if it's newer.\n\tif (y_read_regs != NULL\n\t\t&& y_read_regs[i].y_array != NULL\n\t\t&& (y_regs_p[i].y_array == NULL ||\n\t\t\t    y_read_regs[i].y_time_set > y_regs_p[i].y_time_set))\n\t    y_ptr = &y_read_regs[i];\n\telse if (y_regs_p[i].y_array == NULL)\n\t    continue;\n\telse\n\t    y_ptr = &y_regs_p[i];\n\n\t// Skip empty registers.\n\tnum_lines = y_ptr->y_size;\n\tif (num_lines == 0\n\t\t|| (num_lines == 1 && y_ptr->y_type == MCHAR\n\t\t\t\t\t&& *y_ptr->y_array[0] == NUL))\n\t    continue;\n\n\tif (max_kbyte > 0)\n\t{\n\t    // Skip register if there is more text than the maximum size.\n\t    len = 0;\n\t    for (j = 0; j < num_lines; j++)\n\t\tlen += (long)STRLEN(y_ptr->y_array[j]) + 1L;\n\t    if (len > (long)max_kbyte * 1024L)\n\t\tcontinue;\n\t}\n\n\tswitch (y_ptr->y_type)\n\t{\n\t    case MLINE:\n\t\ttype = (char_u *)\"LINE\";\n\t\tbreak;\n\t    case MCHAR:\n\t\ttype = (char_u *)\"CHAR\";\n\t\tbreak;\n\t    case MBLOCK:\n\t\ttype = (char_u *)\"BLOCK\";\n\t\tbreak;\n\t    default:\n\t\tsemsg(_(e_unknown_register_type_nr), y_ptr->y_type);\n\t\ttype = (char_u *)\"LINE\";\n\t\tbreak;\n\t}\n\tif (get_y_previous() == &y_regs_p[i])\n\t    fprintf(fp, \"\\\"\");\n\tc = get_register_name(i);\n\tfprintf(fp, \"\\\"%c\", c);\n\tif (c == get_execreg_lastc())\n\t    fprintf(fp, \"@\");\n\tfprintf(fp, \"\\t%s\\t%d\\n\", type, (int)y_ptr->y_width);\n\n\t// If max_num_lines < 0, then we save ALL the lines in the register\n\tif (max_num_lines > 0 && num_lines > max_num_lines)\n\t    num_lines = max_num_lines;\n\tfor (j = 0; j < num_lines; j++)\n\t{\n\t    putc('\\t', fp);\n\t    viminfo_writestring(fp, y_ptr->y_array[j]);\n\t}\n\n\t{\n\t    int\t    flags = 0;\n\t    int\t    remaining;\n\n\t    // New style with a bar line. Format:\n\t    // |{bartype},{flags},{name},{type},\n\t    //      {linecount},{width},{timestamp},\"line1\",\"line2\"\n\t    // flags: REG_PREVIOUS - register is y_previous\n\t    //\t      REG_EXEC - used for @@\n\t    if (get_y_previous() == &y_regs_p[i])\n\t\tflags |= REG_PREVIOUS;\n\t    if (c == get_execreg_lastc())\n\t\tflags |= REG_EXEC;\n\t    fprintf(fp, \"|%d,%d,%d,%d,%d,%d,%ld\", BARTYPE_REGISTER, flags,\n\t\t    i, y_ptr->y_type, num_lines, (int)y_ptr->y_width,\n\t\t    (long)y_ptr->y_time_set);\n\t    // 11 chars for type/flags/name/type, 3 * 20 for numbers\n\t    remaining = LSIZE - 71;\n\t    for (j = 0; j < num_lines; j++)\n\t    {\n\t\tputc(',', fp);\n\t\t--remaining;\n\t\tremaining = barline_writestring(fp, y_ptr->y_array[j],\n\t\t\t\t\t\t\t\t   remaining);\n\t    }\n\t    putc('\\n', fp);\n\t}\n    }\n}\n\n/*\n * Functions relating to reading/writing marks from viminfo\n */\n\nstatic xfmark_T *vi_namedfm = NULL;\nstatic xfmark_T *vi_jumplist = NULL;\nstatic int vi_jumplist_len = 0;\n\n    static void\nwrite_one_mark(FILE *fp_out, int c, pos_T *pos)\n{\n    if (pos->lnum != 0)\n\tfprintf(fp_out, \"\\t%c\\t%ld\\t%d\\n\", c, (long)pos->lnum, (int)pos->col);\n}\n\n    static void\nwrite_buffer_marks(buf_T *buf, FILE *fp_out)\n{\n    int\t\ti;\n    pos_T\tpos;\n\n    home_replace(NULL, buf->b_ffname, IObuff, IOSIZE, TRUE);\n    fprintf(fp_out, \"\\n> \");\n    viminfo_writestring(fp_out, IObuff);\n\n    // Write the last used timestamp as the lnum of the non-existing mark '*'.\n    // Older Vims will ignore it and/or copy it.\n    pos.lnum = (linenr_T)buf->b_last_used;\n    pos.col = 0;\n    write_one_mark(fp_out, '*', &pos);\n\n    write_one_mark(fp_out, '\"', &buf->b_last_cursor);\n    write_one_mark(fp_out, '^', &buf->b_last_insert);\n    write_one_mark(fp_out, '.', &buf->b_last_change);\n    // changelist positions are stored oldest first\n    for (i = 0; i < buf->b_changelistlen; ++i)\n    {\n\t// skip duplicates\n\tif (i == 0 || !EQUAL_POS(buf->b_changelist[i - 1],\n\t\t\t\t\t\t\t buf->b_changelist[i]))\n\t    write_one_mark(fp_out, '+', &buf->b_changelist[i]);\n    }\n    for (i = 0; i < NMARKS; i++)\n\twrite_one_mark(fp_out, 'a' + i, &buf->b_namedm[i]);\n}\n\n/*\n * Return TRUE if marks for \"buf\" should not be written.\n */\n    static int\nskip_for_viminfo(buf_T *buf)\n{\n    return\n#ifdef FEAT_TERMINAL\n\t    bt_terminal(buf) ||\n#endif\n\t    removable(buf->b_ffname);\n}\n\n/*\n * Write all the named marks for all buffers.\n * When \"buflist\" is not NULL fill it with the buffers for which marks are to\n * be written.\n */\n    static void\nwrite_viminfo_marks(FILE *fp_out, garray_T *buflist)\n{\n    buf_T\t*buf;\n    int\t\tis_mark_set;\n    int\t\ti;\n    win_T\t*win;\n    tabpage_T\t*tp;\n\n    // Set b_last_cursor for the all buffers that have a window.\n    FOR_ALL_TAB_WINDOWS(tp, win)\n\tset_last_cursor(win);\n\n    fputs(_(\"\\n# History of marks within files (newest to oldest):\\n\"), fp_out);\n    FOR_ALL_BUFFERS(buf)\n    {\n\t// Only write something if buffer has been loaded and at least one\n\t// mark is set.\n\tif (buf->b_marks_read)\n\t{\n\t    if (buf->b_last_cursor.lnum != 0)\n\t\tis_mark_set = TRUE;\n\t    else\n\t    {\n\t\tis_mark_set = FALSE;\n\t\tfor (i = 0; i < NMARKS; i++)\n\t\t    if (buf->b_namedm[i].lnum != 0)\n\t\t    {\n\t\t\tis_mark_set = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t    if (is_mark_set && buf->b_ffname != NULL\n\t\t      && buf->b_ffname[0] != NUL\n\t\t      && !skip_for_viminfo(buf))\n\t    {\n\t\tif (buflist == NULL)\n\t\t    write_buffer_marks(buf, fp_out);\n\t\telse if (ga_grow(buflist, 1) == OK)\n\t\t    ((buf_T **)buflist->ga_data)[buflist->ga_len++] = buf;\n\t    }\n\t}\n    }\n}\n\n    static void\nwrite_one_filemark(\n    FILE\t*fp,\n    xfmark_T\t*fm,\n    int\t\tc1,\n    int\t\tc2)\n{\n    char_u\t*name;\n\n    if (fm->fmark.mark.lnum == 0)\t// not set\n\treturn;\n\n    if (fm->fmark.fnum != 0)\t\t// there is a buffer\n\tname = buflist_nr2name(fm->fmark.fnum, TRUE, FALSE);\n    else\n\tname = fm->fname;\t\t// use name from .viminfo\n    if (name != NULL && *name != NUL)\n    {\n\tfprintf(fp, \"%c%c  %ld  %ld  \", c1, c2, (long)fm->fmark.mark.lnum,\n\t\t\t\t\t\t    (long)fm->fmark.mark.col);\n\tviminfo_writestring(fp, name);\n\n\t// Barline: |{bartype},{name},{lnum},{col},{timestamp},{filename}\n\t// size up to filename: 8 + 3 * 20\n\tfprintf(fp, \"|%d,%d,%ld,%ld,%ld,\", BARTYPE_MARK, c2,\n\t\t(long)fm->fmark.mark.lnum, (long)fm->fmark.mark.col,\n\t\t(long)fm->time_set);\n\tbarline_writestring(fp, name, LSIZE - 70);\n\tputc('\\n', fp);\n    }\n\n    if (fm->fmark.fnum != 0)\n\tvim_free(name);\n}\n\n    static void\nwrite_viminfo_filemarks(FILE *fp)\n{\n    int\t\ti;\n    char_u\t*name;\n    buf_T\t*buf;\n    xfmark_T\t*namedfm_p = get_namedfm();\n    xfmark_T\t*fm;\n    int\t\tvi_idx;\n    int\t\tidx;\n\n    if (get_viminfo_parameter('f') == 0)\n\treturn;\n\n    fputs(_(\"\\n# File marks:\\n\"), fp);\n\n    // Write the filemarks 'A - 'Z\n    for (i = 0; i < NMARKS; i++)\n    {\n\tif (vi_namedfm != NULL\n\t\t\t&& (vi_namedfm[i].time_set > namedfm_p[i].time_set))\n\t    fm = &vi_namedfm[i];\n\telse\n\t    fm = &namedfm_p[i];\n\twrite_one_filemark(fp, fm, '\\'', i + 'A');\n    }\n\n    // Find a mark that is the same file and position as the cursor.\n    // That one, or else the last one is deleted.\n    // Move '0 to '1, '1 to '2, etc. until the matching one or '9\n    // Set the '0 mark to current cursor position.\n    if (curbuf->b_ffname != NULL && !skip_for_viminfo(curbuf))\n    {\n\tname = buflist_nr2name(curbuf->b_fnum, TRUE, FALSE);\n\tfor (i = NMARKS; i < NMARKS + EXTRA_MARKS - 1; ++i)\n\t    if (namedfm_p[i].fmark.mark.lnum == curwin->w_cursor.lnum\n\t\t    && (namedfm_p[i].fname == NULL\n\t\t\t    ? namedfm_p[i].fmark.fnum == curbuf->b_fnum\n\t\t\t    : (name != NULL\n\t\t\t\t    && STRCMP(name, namedfm_p[i].fname) == 0)))\n\t\tbreak;\n\tvim_free(name);\n\n\tvim_free(namedfm_p[i].fname);\n\tfor ( ; i > NMARKS; --i)\n\t    namedfm_p[i] = namedfm_p[i - 1];\n\tnamedfm_p[NMARKS].fmark.mark = curwin->w_cursor;\n\tnamedfm_p[NMARKS].fmark.fnum = curbuf->b_fnum;\n\tnamedfm_p[NMARKS].fname = NULL;\n\tnamedfm_p[NMARKS].time_set = vim_time();\n    }\n\n    // Write the filemarks '0 - '9.  Newest (highest timestamp) first.\n    vi_idx = NMARKS;\n    idx = NMARKS;\n    for (i = NMARKS; i < NMARKS + EXTRA_MARKS; i++)\n    {\n\txfmark_T *vi_fm = vi_namedfm != NULL ? &vi_namedfm[vi_idx] : NULL;\n\n\tif (vi_fm != NULL\n\t\t&& vi_fm->fmark.mark.lnum != 0\n\t\t&& (vi_fm->time_set > namedfm_p[idx].time_set\n\t\t    || namedfm_p[idx].fmark.mark.lnum == 0))\n\t{\n\t    fm = vi_fm;\n\t    ++vi_idx;\n\t}\n\telse\n\t{\n\t    fm = &namedfm_p[idx++];\n\t    if (vi_fm != NULL\n\t\t  && vi_fm->fmark.mark.lnum == fm->fmark.mark.lnum\n\t\t  && vi_fm->time_set == fm->time_set\n\t\t  && ((vi_fm->fmark.fnum != 0\n\t\t\t  && vi_fm->fmark.fnum == fm->fmark.fnum)\n\t\t      || (vi_fm->fname != NULL\n\t\t\t  && fm->fname != NULL\n\t\t\t  && STRCMP(vi_fm->fname, fm->fname) == 0)))\n\t\t++vi_idx;  // skip duplicate\n\t}\n\twrite_one_filemark(fp, fm, '\\'', i - NMARKS + '0');\n    }\n\n    // Write the jumplist with -'\n    fputs(_(\"\\n# Jumplist (newest first):\\n\"), fp);\n    setpcmark();\t// add current cursor position\n    cleanup_jumplist(curwin, FALSE);\n    vi_idx = 0;\n    idx = curwin->w_jumplistlen - 1;\n    for (i = 0; i < JUMPLISTSIZE; ++i)\n    {\n\txfmark_T\t*vi_fm;\n\n\tfm = idx >= 0 ? &curwin->w_jumplist[idx] : NULL;\n\tvi_fm = (vi_jumplist != NULL && vi_idx < vi_jumplist_len)\n\t\t\t\t\t? &vi_jumplist[vi_idx] : NULL;\n\tif (fm == NULL && vi_fm == NULL)\n\t    break;\n\tif (fm == NULL || (vi_fm != NULL && fm->time_set < vi_fm->time_set))\n\t{\n\t    fm = vi_fm;\n\t    ++vi_idx;\n\t}\n\telse\n\t    --idx;\n\tif (fm->fmark.fnum == 0\n\t\t|| ((buf = buflist_findnr(fm->fmark.fnum)) != NULL\n\t\t    && !skip_for_viminfo(buf)))\n\t    write_one_filemark(fp, fm, '-', '\\'');\n    }\n}\n\n/*\n * Compare functions for qsort() below, that compares b_last_used.\n */\n    int\nbuf_compare(const void *s1, const void *s2)\n{\n    buf_T *buf1 = *(buf_T **)s1;\n    buf_T *buf2 = *(buf_T **)s2;\n\n    if (buf1->b_last_used == buf2->b_last_used)\n\treturn 0;\n    return buf1->b_last_used > buf2->b_last_used ? -1 : 1;\n}\n\n/*\n * Handle marks in the viminfo file:\n * fp_out != NULL: copy marks, in time order with buffers in \"buflist\".\n * fp_out == NULL && (flags & VIF_WANT_MARKS): read marks for curbuf\n * fp_out == NULL && (flags & VIF_ONLY_CURBUF): bail out after curbuf marks\n * fp_out == NULL && (flags & VIF_GET_OLDFILES | VIF_FORCEIT): fill v:oldfiles\n */\n    static void\ncopy_viminfo_marks(\n    vir_T\t*virp,\n    FILE\t*fp_out,\n    garray_T\t*buflist,\n    int\t\teof,\n    int\t\tflags)\n{\n    char_u\t*line = virp->vir_line;\n    buf_T\t*buf;\n    int\t\tnum_marked_files;\n    int\t\tload_marks;\n    int\t\tcopy_marks_out;\n    char_u\t*str;\n    int\t\ti;\n    char_u\t*p;\n    char_u\t*name_buf;\n    pos_T\tpos;\n#ifdef FEAT_EVAL\n    list_T\t*list = NULL;\n#endif\n    int\t\tcount = 0;\n    int\t\tbuflist_used = 0;\n    buf_T\t*buflist_buf = NULL;\n\n    if ((name_buf = alloc(LSIZE)) == NULL)\n\treturn;\n    *name_buf = NUL;\n\n    if (fp_out != NULL && buflist->ga_len > 0)\n    {\n\t// Sort the list of buffers on b_last_used.\n\tqsort(buflist->ga_data, (size_t)buflist->ga_len,\n\t\t\t\t\t\tsizeof(buf_T *), buf_compare);\n\tbuflist_buf = ((buf_T **)buflist->ga_data)[0];\n    }\n\n#ifdef FEAT_EVAL\n    if (fp_out == NULL && (flags & (VIF_GET_OLDFILES | VIF_FORCEIT)))\n    {\n\tlist = list_alloc();\n\tif (list != NULL)\n\t    set_vim_var_list(VV_OLDFILES, list);\n    }\n#endif\n\n    num_marked_files = get_viminfo_parameter('\\'');\n    while (!eof && (count < num_marked_files || fp_out == NULL))\n    {\n\tif (line[0] != '>')\n\t{\n\t    if (line[0] != '\\n' && line[0] != '\\r' && line[0] != '#')\n\t    {\n\t\tif (viminfo_error(\"E576: \", _(e_nonr_missing_gt), line))\n\t\t    break;\t// too many errors, return now\n\t    }\n\t    eof = vim_fgets(line, LSIZE, virp->vir_fd);\n\t    continue;\t\t// Skip this dud line\n\t}\n\n\t// Handle long line and translate escaped characters.\n\t// Find file name, set str to start.\n\t// Ignore leading and trailing white space.\n\tstr = skipwhite(line + 1);\n\tstr = viminfo_readstring(virp, (int)(str - virp->vir_line), FALSE);\n\tif (str == NULL)\n\t    continue;\n\tp = str + STRLEN(str);\n\twhile (p != str && (*p == NUL || vim_isspace(*p)))\n\t    p--;\n\tif (*p)\n\t    p++;\n\t*p = NUL;\n\n#ifdef FEAT_EVAL\n\tif (list != NULL)\n\t    list_append_string(list, str, -1);\n#endif\n\n\t// If fp_out == NULL, load marks for current buffer.\n\t// If fp_out != NULL, copy marks for buffers not in buflist.\n\tload_marks = copy_marks_out = FALSE;\n\tif (fp_out == NULL)\n\t{\n\t    if ((flags & VIF_WANT_MARKS) && curbuf->b_ffname != NULL)\n\t    {\n\t\tif (*name_buf == NUL)\t    // only need to do this once\n\t\t    home_replace(NULL, curbuf->b_ffname, name_buf, LSIZE, TRUE);\n\t\tif (fnamecmp(str, name_buf) == 0)\n\t\t    load_marks = TRUE;\n\t    }\n\t}\n\telse // fp_out != NULL\n\t{\n\t    // This is slow if there are many buffers!!\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_ffname != NULL)\n\t\t{\n\t\t    home_replace(NULL, buf->b_ffname, name_buf, LSIZE, TRUE);\n\t\t    if (fnamecmp(str, name_buf) == 0)\n\t\t\tbreak;\n\t\t}\n\n\t    // Copy marks if the buffer has not been loaded.\n\t    if (buf == NULL || !buf->b_marks_read)\n\t    {\n\t\tint\tdid_read_line = FALSE;\n\n\t\tif (buflist_buf != NULL)\n\t\t{\n\t\t    // Read the next line.  If it has the \"*\" mark compare the\n\t\t    // time stamps.  Write entries from \"buflist\" that are\n\t\t    // newer.\n\t\t    if (!(eof = viminfo_readline(virp)) && line[0] == TAB)\n\t\t    {\n\t\t\tdid_read_line = TRUE;\n\t\t\tif (line[1] == '*')\n\t\t\t{\n\t\t\t    long\tltime;\n\n\t\t\t    sscanf((char *)line + 2, \"%ld \", &ltime);\n\t\t\t    while ((time_T)ltime < buflist_buf->b_last_used)\n\t\t\t    {\n\t\t\t\twrite_buffer_marks(buflist_buf, fp_out);\n\t\t\t\tif (++count >= num_marked_files)\n\t\t\t\t    break;\n\t\t\t\tif (++buflist_used == buflist->ga_len)\n\t\t\t\t{\n\t\t\t\t    buflist_buf = NULL;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\tbuflist_buf =\n\t\t\t\t   ((buf_T **)buflist->ga_data)[buflist_used];\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // No timestamp, must be written by an older Vim.\n\t\t\t    // Assume all remaining buffers are older than\n\t\t\t    // ours.\n\t\t\t    while (count < num_marked_files\n\t\t\t\t\t    && buflist_used < buflist->ga_len)\n\t\t\t    {\n\t\t\t\tbuflist_buf = ((buf_T **)buflist->ga_data)\n\t\t\t\t\t\t\t     [buflist_used++];\n\t\t\t\twrite_buffer_marks(buflist_buf, fp_out);\n\t\t\t\t++count;\n\t\t\t    }\n\t\t\t    buflist_buf = NULL;\n\t\t\t}\n\n\t\t\tif (count >= num_marked_files)\n\t\t\t{\n\t\t\t    vim_free(str);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tfputs(\"\\n> \", fp_out);\n\t\tviminfo_writestring(fp_out, str);\n\t\tif (did_read_line)\n\t\t    fputs((char *)line, fp_out);\n\n\t\tcount++;\n\t\tcopy_marks_out = TRUE;\n\t    }\n\t}\n\tvim_free(str);\n\n\tpos.coladd = 0;\n\twhile (!(eof = viminfo_readline(virp)) && line[0] == TAB)\n\t{\n\t    if (load_marks)\n\t    {\n\t\tif (line[1] != NUL)\n\t\t{\n\t\t    unsigned u;\n\n\t\t    sscanf((char *)line + 2, \"%ld %u\", &pos.lnum, &u);\n\t\t    pos.col = u;\n\t\t    switch (line[1])\n\t\t    {\n\t\t\tcase '\"': curbuf->b_last_cursor = pos; break;\n\t\t\tcase '^': curbuf->b_last_insert = pos; break;\n\t\t\tcase '.': curbuf->b_last_change = pos; break;\n\t\t\tcase '+':\n\t\t\t\t  // changelist positions are stored oldest\n\t\t\t\t  // first\n\t\t\t\t  if (curbuf->b_changelistlen == JUMPLISTSIZE)\n\t\t\t\t      // list is full, remove oldest entry\n\t\t\t\t      mch_memmove(curbuf->b_changelist,\n\t\t\t\t\t    curbuf->b_changelist + 1,\n\t\t\t\t\t    sizeof(pos_T) * (JUMPLISTSIZE - 1));\n\t\t\t\t  else\n\t\t\t\t      ++curbuf->b_changelistlen;\n\t\t\t\t  curbuf->b_changelist[\n\t\t\t\t\t   curbuf->b_changelistlen - 1] = pos;\n\t\t\t\t  break;\n\n\t\t\t\t  // Using the line number for the last-used\n\t\t\t\t  // timestamp.\n\t\t\tcase '*': curbuf->b_last_used = pos.lnum; break;\n\n\t\t\tdefault:  if ((i = line[1] - 'a') >= 0 && i < NMARKS)\n\t\t\t\t      curbuf->b_namedm[i] = pos;\n\t\t    }\n\t\t}\n\t    }\n\t    else if (copy_marks_out)\n\t\tfputs((char *)line, fp_out);\n\t}\n\n\tif (load_marks)\n\t{\n\t    win_T\t*wp;\n\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp->w_buffer == curbuf)\n\t\t    wp->w_changelistidx = curbuf->b_changelistlen;\n\t    }\n\t    if (flags & VIF_ONLY_CURBUF)\n\t\tbreak;\n\t}\n    }\n\n    if (fp_out != NULL)\n\t// Write any remaining entries from buflist.\n\twhile (count < num_marked_files && buflist_used < buflist->ga_len)\n\t{\n\t    buflist_buf = ((buf_T **)buflist->ga_data)[buflist_used++];\n\t    write_buffer_marks(buflist_buf, fp_out);\n\t    ++count;\n\t}\n\n    vim_free(name_buf);\n}\n\n/*\n * Read marks for the current buffer from the viminfo file, when we support\n * buffer marks and the buffer has a name.\n */\n    void\ncheck_marks_read(void)\n{\n    if (!curbuf->b_marks_read && get_viminfo_parameter('\\'') > 0\n\t\t\t\t\t\t  && curbuf->b_ffname != NULL)\n\tread_viminfo(NULL, VIF_WANT_MARKS | VIF_ONLY_CURBUF);\n\n    // Always set b_marks_read; needed when 'viminfo' is changed to include\n    // the ' parameter after opening a buffer.\n    curbuf->b_marks_read = TRUE;\n}\n\n    static int\nread_viminfo_filemark(vir_T *virp, int force)\n{\n    char_u\t*str;\n    xfmark_T\t*namedfm_p = get_namedfm();\n    xfmark_T\t*fm;\n    int\t\ti;\n\n    // We only get here if line[0] == '\\'' or '-'.\n    // Illegal mark names are ignored (for future expansion).\n    str = virp->vir_line + 1;\n    if (\n#ifndef EBCDIC\n\t    *str <= 127 &&\n#endif\n\t    ((*virp->vir_line == '\\'' && (VIM_ISDIGIT(*str) || isupper(*str)))\n\t     || (*virp->vir_line == '-' && *str == '\\'')))\n    {\n\tif (*str == '\\'')\n\t{\n\t    // If the jumplist isn't full insert fmark as oldest entry\n\t    if (curwin->w_jumplistlen == JUMPLISTSIZE)\n\t\tfm = NULL;\n\t    else\n\t    {\n\t\tfor (i = curwin->w_jumplistlen; i > 0; --i)\n\t\t    curwin->w_jumplist[i] = curwin->w_jumplist[i - 1];\n\t\t++curwin->w_jumplistidx;\n\t\t++curwin->w_jumplistlen;\n\t\tfm = &curwin->w_jumplist[0];\n\t\tfm->fmark.mark.lnum = 0;\n\t\tfm->fname = NULL;\n\t    }\n\t}\n\telse if (VIM_ISDIGIT(*str))\n\t    fm = &namedfm_p[*str - '0' + NMARKS];\n\telse\n\t    fm = &namedfm_p[*str - 'A'];\n\tif (fm != NULL && (fm->fmark.mark.lnum == 0 || force))\n\t{\n\t    str = skipwhite(str + 1);\n\t    fm->fmark.mark.lnum = getdigits(&str);\n\t    str = skipwhite(str);\n\t    fm->fmark.mark.col = getdigits(&str);\n\t    fm->fmark.mark.coladd = 0;\n\t    fm->fmark.fnum = 0;\n\t    str = skipwhite(str);\n\t    vim_free(fm->fname);\n\t    fm->fname = viminfo_readstring(virp, (int)(str - virp->vir_line),\n\t\t\t\t\t\t\t\t       FALSE);\n\t    fm->time_set = 0;\n\t}\n    }\n    return vim_fgets(virp->vir_line, LSIZE, virp->vir_fd);\n}\n\n/*\n * Prepare for reading viminfo marks when writing viminfo later.\n */\n    static void\nprepare_viminfo_marks(void)\n{\n    vi_namedfm = ALLOC_CLEAR_MULT(xfmark_T, NMARKS + EXTRA_MARKS);\n    vi_jumplist = ALLOC_CLEAR_MULT(xfmark_T, JUMPLISTSIZE);\n    vi_jumplist_len = 0;\n}\n\n    static void\nfinish_viminfo_marks(void)\n{\n    int\t\ti;\n\n    if (vi_namedfm != NULL)\n    {\n\tfor (i = 0; i < NMARKS + EXTRA_MARKS; ++i)\n\t    vim_free(vi_namedfm[i].fname);\n\tVIM_CLEAR(vi_namedfm);\n    }\n    if (vi_jumplist != NULL)\n    {\n\tfor (i = 0; i < vi_jumplist_len; ++i)\n\t    vim_free(vi_jumplist[i].fname);\n\tVIM_CLEAR(vi_jumplist);\n    }\n}\n\n/*\n * Accept a new style mark line from the viminfo, store it when it's new.\n */\n    static void\nhandle_viminfo_mark(garray_T *values, int force)\n{\n    bval_T\t*vp = (bval_T *)values->ga_data;\n    int\t\tname;\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    time_t\ttimestamp;\n    xfmark_T\t*fm = NULL;\n\n    // Check the format:\n    // |{bartype},{name},{lnum},{col},{timestamp},{filename}\n    if (values->ga_len < 5\n\t    || vp[0].bv_type != BVAL_NR\n\t    || vp[1].bv_type != BVAL_NR\n\t    || vp[2].bv_type != BVAL_NR\n\t    || vp[3].bv_type != BVAL_NR\n\t    || vp[4].bv_type != BVAL_STRING)\n\treturn;\n\n    name = vp[0].bv_nr;\n    if (name != '\\'' && !VIM_ISDIGIT(name) && !ASCII_ISUPPER(name))\n\treturn;\n    lnum = vp[1].bv_nr;\n    col = vp[2].bv_nr;\n    if (lnum <= 0 || col < 0)\n\treturn;\n    timestamp = (time_t)vp[3].bv_nr;\n\n    if (name == '\\'')\n    {\n\tif (vi_jumplist != NULL)\n\t{\n\t    if (vi_jumplist_len < JUMPLISTSIZE)\n\t\tfm = &vi_jumplist[vi_jumplist_len++];\n\t}\n\telse\n\t{\n\t    int idx;\n\t    int i;\n\n\t    // If we have a timestamp insert it in the right place.\n\t    if (timestamp != 0)\n\t    {\n\t\tfor (idx = curwin->w_jumplistlen - 1; idx >= 0; --idx)\n\t\t    if (curwin->w_jumplist[idx].time_set < timestamp)\n\t\t    {\n\t\t\t++idx;\n\t\t\tbreak;\n\t\t    }\n\t\t// idx cannot be zero now\n\t\tif (idx < 0 && curwin->w_jumplistlen < JUMPLISTSIZE)\n\t\t    // insert as the oldest entry\n\t\t    idx = 0;\n\t    }\n\t    else if (curwin->w_jumplistlen < JUMPLISTSIZE)\n\t\t// insert as oldest entry\n\t\tidx = 0;\n\t    else\n\t\tidx = -1;\n\n\t    if (idx >= 0)\n\t    {\n\t\tif (curwin->w_jumplistlen == JUMPLISTSIZE)\n\t\t{\n\t\t    // Drop the oldest entry.\n\t\t    --idx;\n\t\t    vim_free(curwin->w_jumplist[0].fname);\n\t\t    for (i = 0; i < idx; ++i)\n\t\t\tcurwin->w_jumplist[i] = curwin->w_jumplist[i + 1];\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Move newer entries forward.\n\t\t    for (i = curwin->w_jumplistlen; i > idx; --i)\n\t\t\tcurwin->w_jumplist[i] = curwin->w_jumplist[i - 1];\n\t\t    ++curwin->w_jumplistidx;\n\t\t    ++curwin->w_jumplistlen;\n\t\t}\n\t\tfm = &curwin->w_jumplist[idx];\n\t\tfm->fmark.mark.lnum = 0;\n\t\tfm->fname = NULL;\n\t\tfm->time_set = 0;\n\t    }\n\t}\n    }\n    else\n    {\n\tint\t\tidx;\n\txfmark_T\t*namedfm_p = get_namedfm();\n\n\tif (VIM_ISDIGIT(name))\n\t{\n\t    if (vi_namedfm != NULL)\n\t\tidx = name - '0' + NMARKS;\n\t    else\n\t    {\n\t\tint i;\n\n\t\t// Do not use the name from the viminfo file, insert in time\n\t\t// order.\n\t\tfor (idx = NMARKS; idx < NMARKS + EXTRA_MARKS; ++idx)\n\t\t    if (namedfm_p[idx].time_set < timestamp)\n\t\t\tbreak;\n\t\tif (idx == NMARKS + EXTRA_MARKS)\n\t\t    // All existing entries are newer.\n\t\t    return;\n\t\ti = NMARKS + EXTRA_MARKS - 1;\n\n\t\tvim_free(namedfm_p[i].fname);\n\t\tfor ( ; i > idx; --i)\n\t\t    namedfm_p[i] = namedfm_p[i - 1];\n\t\tnamedfm_p[idx].fname = NULL;\n\t    }\n\t}\n\telse\n\t    idx = name - 'A';\n\tif (vi_namedfm != NULL)\n\t    fm = &vi_namedfm[idx];\n\telse\n\t    fm = &namedfm_p[idx];\n    }\n\n    if (fm != NULL)\n    {\n\tif (vi_namedfm != NULL || fm->fmark.mark.lnum == 0\n\t\t\t\t\t  || fm->time_set < timestamp || force)\n\t{\n\t    fm->fmark.mark.lnum = lnum;\n\t    fm->fmark.mark.col = col;\n\t    fm->fmark.mark.coladd = 0;\n\t    fm->fmark.fnum = 0;\n\t    vim_free(fm->fname);\n\t    if (vp[4].bv_allocated)\n\t    {\n\t\tfm->fname = vp[4].bv_string;\n\t\tvp[4].bv_string = NULL;\n\t    }\n\t    else\n\t\tfm->fname = vim_strsave(vp[4].bv_string);\n\t    fm->time_set = timestamp;\n\t}\n    }\n}\n\n    static int\nread_viminfo_barline(vir_T *virp, int got_encoding, int force, int writing)\n{\n    char_u\t*p = virp->vir_line + 1;\n    int\t\tbartype;\n    garray_T\tvalues;\n    bval_T\t*vp;\n    int\t\ti;\n    int\t\tread_next = TRUE;\n\n    // The format is: |{bartype},{value},...\n    // For a very long string:\n    //     |{bartype},>{length of \"{text}{text2}\"}\n    //     |<{text1}\n    //     |<{text2},{value}\n    // For a long line not using a string\n    //     |{bartype},{lots of values},>\n    //     |<{value},{value}\n    if (*p == '<')\n    {\n\t// Continuation line of an unrecognized item.\n\tif (writing)\n\t    ga_add_string(&virp->vir_barlines, virp->vir_line);\n    }\n    else\n    {\n\tga_init2(&values, sizeof(bval_T), 20);\n\tbartype = getdigits(&p);\n\tswitch (bartype)\n\t{\n\t    case BARTYPE_VERSION:\n\t\t// Only use the version when it comes before the encoding.\n\t\t// If it comes later it was copied by a Vim version that\n\t\t// doesn't understand the version.\n\t\tif (!got_encoding)\n\t\t{\n\t\t    read_next = barline_parse(virp, p, &values);\n\t\t    vp = (bval_T *)values.ga_data;\n\t\t    if (values.ga_len > 0 && vp->bv_type == BVAL_NR)\n\t\t\tvirp->vir_version = vp->bv_nr;\n\t\t}\n\t\tbreak;\n\n\t    case BARTYPE_HISTORY:\n\t\tread_next = barline_parse(virp, p, &values);\n\t\thandle_viminfo_history(&values, writing);\n\t\tbreak;\n\n\t    case BARTYPE_REGISTER:\n\t\tread_next = barline_parse(virp, p, &values);\n\t\thandle_viminfo_register(&values, force);\n\t\tbreak;\n\n\t    case BARTYPE_MARK:\n\t\tread_next = barline_parse(virp, p, &values);\n\t\thandle_viminfo_mark(&values, force);\n\t\tbreak;\n\n\t    default:\n\t\t// copy unrecognized line (for future use)\n\t\tif (writing)\n\t\t    ga_add_string(&virp->vir_barlines, virp->vir_line);\n\t}\n\tfor (i = 0; i < values.ga_len; ++i)\n\t{\n\t    vp = (bval_T *)values.ga_data + i;\n\t    if (vp->bv_type == BVAL_STRING && vp->bv_allocated)\n\t\tvim_free(vp->bv_string);\n\t    vim_free(vp->bv_tofree);\n\t}\n\tga_clear(&values);\n    }\n\n    if (read_next)\n\treturn viminfo_readline(virp);\n    return FALSE;\n}\n\n/*\n * read_viminfo_up_to_marks() -- Only called from do_viminfo().  Reads in the\n * first part of the viminfo file which contains everything but the marks that\n * are local to a file.  Returns TRUE when end-of-file is reached. -- webb\n */\n    static int\nread_viminfo_up_to_marks(\n    vir_T\t*virp,\n    int\t\tforceit,\n    int\t\twriting)\n{\n    int\t\teof;\n    buf_T\t*buf;\n    int\t\tgot_encoding = FALSE;\n\n    prepare_viminfo_history(forceit ? 9999 : 0, writing);\n\n    eof = viminfo_readline(virp);\n    while (!eof && virp->vir_line[0] != '>')\n    {\n\tswitch (virp->vir_line[0])\n\t{\n\t\t// Characters reserved for future expansion, ignored now\n\t    case '+': // \"+40 /path/dir file\", for running vim without args\n\t    case '^': // to be defined\n\t    case '<': // long line - ignored\n\t\t// A comment or empty line.\n\t    case NUL:\n\t    case '\\r':\n\t    case '\\n':\n\t    case '#':\n\t\teof = viminfo_readline(virp);\n\t\tbreak;\n\t    case '|':\n\t\teof = read_viminfo_barline(virp, got_encoding,\n\t\t\t\t\t\t\t    forceit, writing);\n\t\tbreak;\n\t    case '*': // \"*encoding=value\"\n\t\tgot_encoding = TRUE;\n\t\teof = viminfo_encoding(virp);\n\t\tbreak;\n\t    case '!': // global variable\n#ifdef FEAT_EVAL\n\t\teof = read_viminfo_varlist(virp, writing);\n#else\n\t\teof = viminfo_readline(virp);\n#endif\n\t\tbreak;\n\t    case '%': // entry for buffer list\n\t\teof = read_viminfo_bufferlist(virp, writing);\n\t\tbreak;\n\t    case '\"':\n\t\t// When registers are in bar lines skip the old style register\n\t\t// lines.\n\t\tif (virp->vir_version < VIMINFO_VERSION_WITH_REGISTERS)\n\t\t    eof = read_viminfo_register(virp, forceit);\n\t\telse\n\t\t    do {\n\t\t\teof = viminfo_readline(virp);\n\t\t    } while (!eof && (virp->vir_line[0] == TAB\n\t\t\t\t\t\t|| virp->vir_line[0] == '<'));\n\t\tbreak;\n\t    case '/':\t    // Search string\n\t    case '&':\t    // Substitute search string\n\t    case '~':\t    // Last search string, followed by '/' or '&'\n\t\teof = read_viminfo_search_pattern(virp, forceit);\n\t\tbreak;\n\t    case '$':\n\t\teof = read_viminfo_sub_string(virp, forceit);\n\t\tbreak;\n\t    case ':':\n\t    case '?':\n\t    case '=':\n\t    case '@':\n\t\t// When history is in bar lines skip the old style history\n\t\t// lines.\n\t\tif (virp->vir_version < VIMINFO_VERSION_WITH_HISTORY)\n\t\t    eof = read_viminfo_history(virp, writing);\n\t\telse\n\t\t    eof = viminfo_readline(virp);\n\t\tbreak;\n\t    case '-':\n\t    case '\\'':\n\t\t// When file marks are in bar lines skip the old style lines.\n\t\tif (virp->vir_version < VIMINFO_VERSION_WITH_MARKS)\n\t\t    eof = read_viminfo_filemark(virp, forceit);\n\t\telse\n\t\t    eof = viminfo_readline(virp);\n\t\tbreak;\n\t    default:\n\t\tif (viminfo_error(\"E575: \", _(e_illegal_starting_char),\n\t\t\t    virp->vir_line))\n\t\t    eof = TRUE;\n\t\telse\n\t\t    eof = viminfo_readline(virp);\n\t\tbreak;\n\t}\n    }\n\n    // Finish reading history items.\n    if (!writing)\n\tfinish_viminfo_history(virp);\n\n    // Change file names to buffer numbers for fmarks.\n    FOR_ALL_BUFFERS(buf)\n\tfmarks_check_names(buf);\n\n    return eof;\n}\n\n/*\n * do_viminfo() -- Should only be called from read_viminfo() & write_viminfo().\n */\n    static void\ndo_viminfo(FILE *fp_in, FILE *fp_out, int flags)\n{\n    int\t\teof = FALSE;\n    vir_T\tvir;\n    int\t\tmerge = FALSE;\n    int\t\tdo_copy_marks = FALSE;\n    garray_T\tbuflist;\n\n    if ((vir.vir_line = alloc(LSIZE)) == NULL)\n\treturn;\n    vir.vir_fd = fp_in;\n    vir.vir_conv.vc_type = CONV_NONE;\n    ga_init2(&vir.vir_barlines, (int)sizeof(char_u *), 100);\n    vir.vir_version = -1;\n\n    if (fp_in != NULL)\n    {\n\tif (flags & VIF_WANT_INFO)\n\t{\n\t    if (fp_out != NULL)\n\t    {\n\t\t// Registers and marks are read and kept separate from what\n\t\t// this Vim is using.  They are merged when writing.\n\t\tprepare_viminfo_registers();\n\t\tprepare_viminfo_marks();\n\t    }\n\n\t    eof = read_viminfo_up_to_marks(&vir,\n\t\t\t\t\t flags & VIF_FORCEIT, fp_out != NULL);\n\t    merge = TRUE;\n\t}\n\telse if (flags != 0)\n\t    // Skip info, find start of marks\n\t    while (!(eof = viminfo_readline(&vir))\n\t\t    && vir.vir_line[0] != '>')\n\t\t;\n\n\tdo_copy_marks = (flags & (VIF_WANT_MARKS | VIF_ONLY_CURBUF\n\t\t\t\t\t    | VIF_GET_OLDFILES | VIF_FORCEIT));\n    }\n\n    if (fp_out != NULL)\n    {\n\t// Write the info:\n\tfprintf(fp_out, _(\"# This viminfo file was generated by Vim %s.\\n\"),\n\t\t\t\t\t\t\t  VIM_VERSION_MEDIUM);\n\tfputs(_(\"# You may edit it if you're careful!\\n\\n\"), fp_out);\n\twrite_viminfo_version(fp_out);\n\tfputs(_(\"# Value of 'encoding' when this file was written\\n\"), fp_out);\n\tfprintf(fp_out, \"*encoding=%s\\n\\n\", p_enc);\n\twrite_viminfo_search_pattern(fp_out);\n\twrite_viminfo_sub_string(fp_out);\n\twrite_viminfo_history(fp_out, merge);\n\twrite_viminfo_registers(fp_out);\n\tfinish_viminfo_registers();\n#ifdef FEAT_EVAL\n\twrite_viminfo_varlist(fp_out);\n#endif\n\twrite_viminfo_filemarks(fp_out);\n\tfinish_viminfo_marks();\n\twrite_viminfo_bufferlist(fp_out);\n\twrite_viminfo_barlines(&vir, fp_out);\n\n\tif (do_copy_marks)\n\t    ga_init2(&buflist, sizeof(buf_T *), 50);\n\twrite_viminfo_marks(fp_out, do_copy_marks ? &buflist : NULL);\n    }\n\n    if (do_copy_marks)\n    {\n\tcopy_viminfo_marks(&vir, fp_out, &buflist, eof, flags);\n\tif (fp_out != NULL)\n\t    ga_clear(&buflist);\n    }\n\n    vim_free(vir.vir_line);\n    if (vir.vir_conv.vc_type != CONV_NONE)\n\tconvert_setup(&vir.vir_conv, NULL, NULL);\n    ga_clear_strings(&vir.vir_barlines);\n}\n\n/*\n * read_viminfo() -- Read the viminfo file.  Registers etc. which are already\n * set are not over-written unless \"flags\" includes VIF_FORCEIT. -- webb\n */\n    int\nread_viminfo(\n    char_u\t*file,\t    // file name or NULL to use default name\n    int\t\tflags)\t    // VIF_WANT_INFO et al.\n{\n    FILE\t*fp;\n    char_u\t*fname;\n    stat_T\tst;\t\t// mch_stat() of existing viminfo file\n\n    if (no_viminfo())\n\treturn FAIL;\n\n    fname = viminfo_filename(file);\t// get file name in allocated buffer\n    if (fname == NULL)\n\treturn FAIL;\n    fp = mch_fopen((char *)fname, READBIN);\n\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Reading viminfo file \\\"%s\\\"%s%s%s%s\"),\n\t\tfname,\n\t\t(flags & VIF_WANT_INFO) ? _(\" info\") : \"\",\n\t\t(flags & VIF_WANT_MARKS) ? _(\" marks\") : \"\",\n\t\t(flags & VIF_GET_OLDFILES) ? _(\" oldfiles\") : \"\",\n\t\tfp == NULL ? _(\" FAILED\") : \"\");\n\tverbose_leave();\n    }\n\n    vim_free(fname);\n    if (fp == NULL)\n\treturn FAIL;\n    if (mch_fstat(fileno(fp), &st) < 0 || S_ISDIR(st.st_mode))\n    {\n\tfclose(fp);\n\treturn FAIL;\n    }\n\n    viminfo_errcnt = 0;\n    do_viminfo(fp, NULL, flags);\n\n    fclose(fp);\n    return OK;\n}\n\n/*\n * Write the viminfo file.  The old one is read in first so that effectively a\n * merge of current info and old info is done.  This allows multiple vims to\n * run simultaneously, without losing any marks etc.\n * If \"forceit\" is TRUE, then the old file is not read in, and only internal\n * info is written to the file.\n */\n    void\nwrite_viminfo(char_u *file, int forceit)\n{\n    char_u\t*fname;\n    FILE\t*fp_in = NULL;\t// input viminfo file, if any\n    FILE\t*fp_out = NULL;\t// output viminfo file\n    char_u\t*tempname = NULL;\t// name of temp viminfo file\n    stat_T\tst_new;\t\t// mch_stat() of potential new file\n    stat_T\tst_old;\t\t// mch_stat() of existing viminfo file\n#if defined(UNIX) || defined(VMS)\n    mode_t\tumask_save;\n#endif\n#ifdef UNIX\n    int\t\tshortname = FALSE;\t// use 8.3 file name\n#endif\n#ifdef MSWIN\n    int\t\thidden = FALSE;\n#endif\n\n    if (no_viminfo())\n\treturn;\n\n    fname = viminfo_filename(file);\t// may set to default if NULL\n    if (fname == NULL)\n\treturn;\n\n    fp_in = mch_fopen((char *)fname, READBIN);\n    if (fp_in == NULL)\n    {\n\tint fd;\n\n\t// if it does exist, but we can't read it, don't try writing\n\tif (mch_stat((char *)fname, &st_new) == 0)\n\t    goto end;\n\n\t// Create the new .viminfo non-accessible for others, because it may\n\t// contain text from non-accessible documents. It is up to the user to\n\t// widen access (e.g. to a group). This may also fail if there is a\n\t// race condition, then just give up.\n\tfd = mch_open((char *)fname,\n\t\t\t    O_CREAT|O_EXTRA|O_EXCL|O_WRONLY|O_NOFOLLOW, 0600);\n\tif (fd < 0)\n\t    goto end;\n\tfp_out = fdopen(fd, WRITEBIN);\n    }\n    else\n    {\n\t// There is an existing viminfo file.  Create a temporary file to\n\t// write the new viminfo into, in the same directory as the\n\t// existing viminfo file, which will be renamed once all writing is\n\t// successful.\n\tif (mch_fstat(fileno(fp_in), &st_old) < 0\n\t\t|| S_ISDIR(st_old.st_mode)\n#ifdef UNIX\n\t\t// For Unix we check the owner of the file.  It's not very nice\n\t\t// to overwrite a user's viminfo file after a \"su root\", with a\n\t\t// viminfo file that the user can't read.\n\t\t|| (getuid() != ROOT_UID\n\t\t    && !(st_old.st_uid == getuid()\n\t\t\t    ? (st_old.st_mode & 0200)\n\t\t\t    : (st_old.st_gid == getgid()\n\t\t\t\t    ? (st_old.st_mode & 0020)\n\t\t\t\t    : (st_old.st_mode & 0002))))\n#endif\n\t\t)\n\t{\n\t    int\ttt = msg_didany;\n\n\t    // avoid a wait_return for this message, it's annoying\n\t    semsg(_(e_viminfo_file_is_not_writable_str), fname);\n\t    msg_didany = tt;\n\t    fclose(fp_in);\n\t    goto end;\n\t}\n#ifdef MSWIN\n\t// Get the file attributes of the existing viminfo file.\n\thidden = mch_ishidden(fname);\n#endif\n\n\t// Make tempname, find one that does not exist yet.\n\t// Beware of a race condition: If someone logs out and all Vim\n\t// instances exit at the same time a temp file might be created between\n\t// stat() and open().  Use mch_open() with O_EXCL to avoid that.\n\t// May try twice: Once normal and once with shortname set, just in\n\t// case somebody puts his viminfo file in an 8.3 filesystem.\n\tfor (;;)\n\t{\n\t    int\t\tnext_char = 'z';\n\t    char_u\t*wp;\n\n\t    tempname = buf_modname(\n#ifdef UNIX\n\t\t\t\t    shortname,\n#else\n\t\t\t\t    FALSE,\n#endif\n\t\t\t\t    fname,\n#ifdef VMS\n\t\t\t\t    (char_u *)\"-tmp\",\n#else\n\t\t\t\t    (char_u *)\".tmp\",\n#endif\n\t\t\t\t    FALSE);\n\t    if (tempname == NULL)\t\t// out of memory\n\t\tbreak;\n\n\t    // Try a series of names.  Change one character, just before\n\t    // the extension.  This should also work for an 8.3\n\t    // file name, when after adding the extension it still is\n\t    // the same file as the original.\n\t    wp = tempname + STRLEN(tempname) - 5;\n\t    if (wp < gettail(tempname))\t    // empty file name?\n\t\twp = gettail(tempname);\n\t    for (;;)\n\t    {\n\t\t// Check if tempfile already exists.  Never overwrite an\n\t\t// existing file!\n\t\tif (mch_stat((char *)tempname, &st_new) == 0)\n\t\t{\n#ifdef UNIX\n\t\t    // Check if tempfile is same as original file.  May happen\n\t\t    // when modname() gave the same file back.  E.g.  silly\n\t\t    // link, or file name-length reached.  Try again with\n\t\t    // shortname set.\n\t\t    if (!shortname && st_new.st_dev == st_old.st_dev\n\t\t\t\t\t\t&& st_new.st_ino == st_old.st_ino)\n\t\t    {\n\t\t\tVIM_CLEAR(tempname);\n\t\t\tshortname = TRUE;\n\t\t\tbreak;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Try creating the file exclusively.  This may fail if\n\t\t    // another Vim tries to do it at the same time.\n#ifdef VMS\n\t\t    // fdopen() fails for some reason\n\t\t    umask_save = umask(077);\n\t\t    fp_out = mch_fopen((char *)tempname, WRITEBIN);\n\t\t    (void)umask(umask_save);\n#else\n\t\t    int\tfd;\n\n\t\t    // Use mch_open() to be able to use O_NOFOLLOW and set file\n\t\t    // protection:\n\t\t    // Unix: same as original file, but strip s-bit.  Reset\n\t\t    // umask to avoid it getting in the way.\n\t\t    // Others: r&w for user only.\n# ifdef UNIX\n\t\t    umask_save = umask(0);\n\t\t    fd = mch_open((char *)tempname,\n\t\t\t    O_CREAT|O_EXTRA|O_EXCL|O_WRONLY|O_NOFOLLOW,\n\t\t\t\t\t(int)((st_old.st_mode & 0777) | 0600));\n\t\t    (void)umask(umask_save);\n# else\n\t\t    fd = mch_open((char *)tempname,\n\t\t\t     O_CREAT|O_EXTRA|O_EXCL|O_WRONLY|O_NOFOLLOW, 0600);\n# endif\n\t\t    if (fd < 0)\n\t\t    {\n\t\t\tfp_out = NULL;\n# ifdef EEXIST\n\t\t\t// Avoid trying lots of names while the problem is lack\n\t\t\t// of permission, only retry if the file already\n\t\t\t// exists.\n\t\t\tif (errno != EEXIST)\n\t\t\t    break;\n# endif\n\t\t    }\n\t\t    else\n\t\t\tfp_out = fdopen(fd, WRITEBIN);\n#endif // VMS\n\t\t    if (fp_out != NULL)\n\t\t\tbreak;\n\t\t}\n\n\t\t// Assume file exists, try again with another name.\n\t\tif (next_char == 'a' - 1)\n\t\t{\n\t\t    // They all exist?  Must be something wrong! Don't write\n\t\t    // the viminfo file then.\n\t\t    semsg(_(e_too_many_viminfo_temp_files_like_str), tempname);\n\t\t    break;\n\t\t}\n\t\t*wp = next_char;\n\t\t--next_char;\n\t    }\n\n\t    if (tempname != NULL)\n\t\tbreak;\n\t    // continue if shortname was set\n\t}\n\n#if defined(UNIX) && defined(HAVE_FCHOWN)\n\tif (tempname != NULL && fp_out != NULL)\n\t{\n\t\tstat_T\ttmp_st;\n\n\t    // Make sure the original owner can read/write the tempfile and\n\t    // otherwise preserve permissions, making sure the group matches.\n\t    if (mch_stat((char *)tempname, &tmp_st) >= 0)\n\t    {\n\t\tif (st_old.st_uid != tmp_st.st_uid)\n\t\t    // Changing the owner might fail, in which case the\n\t\t    // file will now be owned by the current user, oh well.\n\t\t    vim_ignored = fchown(fileno(fp_out), st_old.st_uid, -1);\n\t\tif (st_old.st_gid != tmp_st.st_gid\n\t\t\t&& fchown(fileno(fp_out), -1, st_old.st_gid) == -1)\n\t\t    // can't set the group to what it should be, remove\n\t\t    // group permissions\n\t\t    (void)mch_setperm(tempname, 0600);\n\t    }\n\t    else\n\t\t// can't stat the file, set conservative permissions\n\t\t(void)mch_setperm(tempname, 0600);\n\t}\n#endif\n    }\n\n    // Check if the new viminfo file can be written to.\n    if (fp_out == NULL)\n    {\n\tsemsg(_(e_cant_write_viminfo_file_str),\n\t\t       (fp_in == NULL || tempname == NULL) ? fname : tempname);\n\tif (fp_in != NULL)\n\t    fclose(fp_in);\n\tgoto end;\n    }\n\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Writing viminfo file \\\"%s\\\"\"), fname);\n\tverbose_leave();\n    }\n\n    viminfo_errcnt = 0;\n    do_viminfo(fp_in, fp_out, forceit ? 0 : (VIF_WANT_INFO | VIF_WANT_MARKS));\n\n    if (fclose(fp_out) == EOF)\n\t++viminfo_errcnt;\n\n    if (fp_in != NULL)\n    {\n\tfclose(fp_in);\n\n\t// In case of an error keep the original viminfo file.  Otherwise\n\t// rename the newly written file.  Give an error if that fails.\n\tif (viminfo_errcnt == 0)\n\t{\n\t    if (vim_rename(tempname, fname) == -1)\n\t    {\n\t\t++viminfo_errcnt;\n\t\tsemsg(_(e_cant_rename_viminfo_file_to_str), fname);\n\t    }\n# ifdef MSWIN\n\t    // If the viminfo file was hidden then also hide the new file.\n\t    else if (hidden)\n\t\tmch_hide(fname);\n# endif\n\t}\n\tif (viminfo_errcnt > 0)\n\t    mch_remove(tempname);\n    }\n\nend:\n    vim_free(fname);\n    vim_free(tempname);\n}\n\n/*\n * \":rviminfo\" and \":wviminfo\".\n */\n    void\nex_viminfo(\n    exarg_T\t*eap)\n{\n    char_u\t*save_viminfo;\n\n    save_viminfo = p_viminfo;\n    if (*p_viminfo == NUL)\n\tp_viminfo = (char_u *)\"'100\";\n    if (eap->cmdidx == CMD_rviminfo)\n    {\n\tif (read_viminfo(eap->arg, VIF_WANT_INFO | VIF_WANT_MARKS\n\t\t\t\t  | (eap->forceit ? VIF_FORCEIT : 0)) == FAIL)\n\t    emsg(_(e_cannot_open_viminfo_file_for_reading));\n    }\n    else\n\twrite_viminfo(eap->arg, eap->forceit);\n    p_viminfo = save_viminfo;\n}\n\n#endif // FEAT_VIMINFO\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * alloc.c: functions for memory management\n */\n\n#include \"vim.h\"\n\n/**********************************************************************\n * Various routines dealing with allocation and deallocation of memory.\n */\n\n#if defined(MEM_PROFILE) || defined(PROTO)\n\n# define MEM_SIZES  8200\nstatic long_u mem_allocs[MEM_SIZES];\nstatic long_u mem_frees[MEM_SIZES];\nstatic long_u mem_allocated;\nstatic long_u mem_freed;\nstatic long_u mem_peak;\nstatic long_u num_alloc;\nstatic long_u num_freed;\n\n    static void\nmem_pre_alloc_s(size_t *sizep)\n{\n    *sizep += sizeof(size_t);\n}\n\n    static void\nmem_pre_alloc_l(size_t *sizep)\n{\n    *sizep += sizeof(size_t);\n}\n\n    static void\nmem_post_alloc(\n    void **pp,\n    size_t size)\n{\n    if (*pp == NULL)\n\treturn;\n    size -= sizeof(size_t);\n    *(long_u *)*pp = size;\n    if (size <= MEM_SIZES-1)\n\tmem_allocs[size-1]++;\n    else\n\tmem_allocs[MEM_SIZES-1]++;\n    mem_allocated += size;\n    if (mem_allocated - mem_freed > mem_peak)\n\tmem_peak = mem_allocated - mem_freed;\n    num_alloc++;\n    *pp = (void *)((char *)*pp + sizeof(size_t));\n}\n\n    static void\nmem_pre_free(void **pp)\n{\n    long_u size;\n\n    *pp = (void *)((char *)*pp - sizeof(size_t));\n    size = *(size_t *)*pp;\n    if (size <= MEM_SIZES-1)\n\tmem_frees[size-1]++;\n    else\n\tmem_frees[MEM_SIZES-1]++;\n    mem_freed += size;\n    num_freed++;\n}\n\n/*\n * called on exit via atexit()\n */\n    void\nvim_mem_profile_dump(void)\n{\n    int i, j;\n\n    printf(\"\\r\\n\");\n    j = 0;\n    for (i = 0; i < MEM_SIZES - 1; i++)\n    {\n\tif (mem_allocs[i] || mem_frees[i])\n\t{\n\t    if (mem_frees[i] > mem_allocs[i])\n\t\tprintf(\"\\r\\n%s\", _(\"ERROR: \"));\n\t    printf(\"[%4d / %4lu-%-4lu] \", i + 1, mem_allocs[i], mem_frees[i]);\n\t    j++;\n\t    if (j > 3)\n\t    {\n\t\tj = 0;\n\t\tprintf(\"\\r\\n\");\n\t    }\n\t}\n    }\n\n    i = MEM_SIZES - 1;\n    if (mem_allocs[i])\n    {\n\tprintf(\"\\r\\n\");\n\tif (mem_frees[i] > mem_allocs[i])\n\t    puts(_(\"ERROR: \"));\n\tprintf(\"[>%d / %4lu-%-4lu]\", i, mem_allocs[i], mem_frees[i]);\n    }\n\n    printf(_(\"\\n[bytes] total alloc-freed %lu-%lu, in use %lu, peak use %lu\\n\"),\n\t    mem_allocated, mem_freed, mem_allocated - mem_freed, mem_peak);\n    printf(_(\"[calls] total re/malloc()'s %lu, total free()'s %lu\\n\\n\"),\n\t    num_alloc, num_freed);\n}\n\n#endif // MEM_PROFILE\n\n#ifdef FEAT_EVAL\n    int\nalloc_does_fail(size_t size)\n{\n    if (alloc_fail_countdown == 0)\n    {\n\tif (--alloc_fail_repeat <= 0)\n\t    alloc_fail_id = 0;\n\tdo_outofmem_msg(size);\n\treturn TRUE;\n    }\n    --alloc_fail_countdown;\n    return FALSE;\n}\n#endif\n\n/*\n * Some memory is reserved for error messages and for being able to\n * call mf_release_all(), which needs some memory for mf_trans_add().\n */\n#define KEEP_ROOM (2 * 8192L)\n#define KEEP_ROOM_KB (KEEP_ROOM / 1024L)\n\n/*\n * The normal way to allocate memory.  This handles an out-of-memory situation\n * as well as possible, still returns NULL when we're completely out.\n */\n    void *\nalloc(size_t size)\n{\n    return lalloc(size, TRUE);\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * alloc() with an ID for alloc_fail().\n */\n    void *\nalloc_id(size_t size, alloc_id_T id UNUSED)\n{\n#ifdef FEAT_EVAL\n    if (alloc_fail_id == id && alloc_does_fail(size))\n\treturn NULL;\n#endif\n    return lalloc(size, TRUE);\n}\n#endif\n\n/*\n * Allocate memory and set all bytes to zero.\n */\n    void *\nalloc_clear(size_t size)\n{\n    void *p;\n\n    p = lalloc(size, TRUE);\n    if (p != NULL)\n\t(void)vim_memset(p, 0, size);\n    return p;\n}\n\n#if defined(FEAT_SIGNS) || defined(PROTO)\n/*\n * Same as alloc_clear() but with allocation id for testing\n */\n    void *\nalloc_clear_id(size_t size, alloc_id_T id UNUSED)\n{\n#ifdef FEAT_EVAL\n    if (alloc_fail_id == id && alloc_does_fail(size))\n\treturn NULL;\n#endif\n    return alloc_clear(size);\n}\n#endif\n\n/*\n * Allocate memory like lalloc() and set all bytes to zero.\n */\n    void *\nlalloc_clear(size_t size, int message)\n{\n    void *p;\n\n    p = lalloc(size, message);\n    if (p != NULL)\n\t(void)vim_memset(p, 0, size);\n    return p;\n}\n\n/*\n * Low level memory allocation function.\n * This is used often, KEEP IT FAST!\n */\n    void *\nlalloc(size_t size, int message)\n{\n    void\t*p;\t\t    // pointer to new storage space\n    static int\treleasing = FALSE;  // don't do mf_release_all() recursive\n    int\t\ttry_again;\n#if defined(HAVE_AVAIL_MEM)\n    static size_t allocated = 0;    // allocated since last avail check\n#endif\n\n    // Safety check for allocating zero bytes\n    if (size == 0)\n    {\n\t// Don't hide this message\n\temsg_silent = 0;\n\tiemsg(_(e_internal_error_lalloc_zero));\n\treturn NULL;\n    }\n\n#ifdef MEM_PROFILE\n    mem_pre_alloc_l(&size);\n#endif\n\n    // Loop when out of memory: Try to release some memfile blocks and\n    // if some blocks are released call malloc again.\n    for (;;)\n    {\n\t// Handle three kinds of systems:\n\t// 1. No check for available memory: Just return.\n\t// 2. Slow check for available memory: call mch_avail_mem() after\n\t//    allocating KEEP_ROOM amount of memory.\n\t// 3. Strict check for available memory: call mch_avail_mem()\n\tif ((p = malloc(size)) != NULL)\n\t{\n#ifndef HAVE_AVAIL_MEM\n\t    // 1. No check for available memory: Just return.\n\t    goto theend;\n#else\n\t    // 2. Slow check for available memory: call mch_avail_mem() after\n\t    //    allocating (KEEP_ROOM / 2) amount of memory.\n\t    allocated += size;\n\t    if (allocated < KEEP_ROOM / 2)\n\t\tgoto theend;\n\t    allocated = 0;\n\n\t    // 3. check for available memory: call mch_avail_mem()\n\t    if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)\n\t    {\n\t\tfree(p);\t// System is low... no go!\n\t\tp = NULL;\n\t    }\n\t    else\n\t\tgoto theend;\n#endif\n\t}\n\t// Remember that mf_release_all() is being called to avoid an endless\n\t// loop, because mf_release_all() may call alloc() recursively.\n\tif (releasing)\n\t    break;\n\treleasing = TRUE;\n\n\tclear_sb_text(TRUE);\t      // free any scrollback text\n\ttry_again = mf_release_all(); // release as many blocks as possible\n\n\treleasing = FALSE;\n\tif (!try_again)\n\t    break;\n    }\n\n    if (message && p == NULL)\n\tdo_outofmem_msg(size);\n\ntheend:\n#ifdef MEM_PROFILE\n    mem_post_alloc(&p, size);\n#endif\n    return p;\n}\n\n/*\n * lalloc() with an ID for alloc_fail().\n */\n#if defined(FEAT_SIGNS) || defined(PROTO)\n    void *\nlalloc_id(size_t size, int message, alloc_id_T id UNUSED)\n{\n#ifdef FEAT_EVAL\n    if (alloc_fail_id == id && alloc_does_fail(size))\n\treturn NULL;\n#endif\n    return (lalloc(size, message));\n}\n#endif\n\n#if defined(MEM_PROFILE) || defined(PROTO)\n/*\n * realloc() with memory profiling.\n */\n    void *\nmem_realloc(void *ptr, size_t size)\n{\n    void *p;\n\n    mem_pre_free(&ptr);\n    mem_pre_alloc_s(&size);\n\n    p = realloc(ptr, size);\n\n    mem_post_alloc(&p, size);\n\n    return p;\n}\n#endif\n\n/*\n* Avoid repeating the error message many times (they take 1 second each).\n* Did_outofmem_msg is reset when a character is read.\n*/\n    void\ndo_outofmem_msg(size_t size)\n{\n    if (!did_outofmem_msg)\n    {\n\t// Don't hide this message\n\temsg_silent = 0;\n\n\t// Must come first to avoid coming back here when printing the error\n\t// message fails, e.g. when setting v:errmsg.\n\tdid_outofmem_msg = TRUE;\n\n\tsemsg(_(e_out_of_memory_allocating_nr_bytes), (long_u)size);\n\n\tif (starting == NO_SCREEN)\n\t    // Not even finished with initializations and already out of\n\t    // memory?  Then nothing is going to work, exit.\n\t    mch_exit(123);\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n\n/*\n * Free everything that we allocated.\n * Can be used to detect memory leaks, e.g., with ccmalloc.\n * NOTE: This is tricky!  Things are freed that functions depend on.  Don't be\n * surprised if Vim crashes...\n * Some things can't be freed, esp. things local to a library function.\n */\n    void\nfree_all_mem(void)\n{\n    buf_T\t*buf, *nextbuf;\n\n    // When we cause a crash here it is caught and Vim tries to exit cleanly.\n    // Don't try freeing everything again.\n    if (entered_free_all_mem)\n\treturn;\n    entered_free_all_mem = TRUE;\n    // Don't want to trigger autocommands from here on.\n    block_autocmds();\n\n    // Close all tabs and windows.  Reset 'equalalways' to avoid redraws.\n    p_ea = FALSE;\n    if (first_tabpage != NULL && first_tabpage->tp_next != NULL)\n\tdo_cmdline_cmd((char_u *)\"tabonly!\");\n    if (!ONE_WINDOW)\n\tdo_cmdline_cmd((char_u *)\"only!\");\n\n# if defined(FEAT_SPELL)\n    // Free all spell info.\n    spell_free_all();\n# endif\n\n# if defined(FEAT_BEVAL_TERM)\n    ui_remove_balloon();\n# endif\n# ifdef FEAT_PROP_POPUP\n    if (curwin != NULL)\n\tclose_all_popups(TRUE);\n# endif\n\n    // Clear user commands (before deleting buffers).\n    ex_comclear(NULL);\n\n    // When exiting from mainerr_arg_missing curbuf has not been initialized,\n    // and not much else.\n    if (curbuf != NULL)\n    {\n# ifdef FEAT_MENU\n\t// Clear menus.\n\tdo_cmdline_cmd((char_u *)\"aunmenu *\");\n#  ifdef FEAT_MULTI_LANG\n\tdo_cmdline_cmd((char_u *)\"menutranslate clear\");\n#  endif\n# endif\n\t// Clear mappings, abbreviations, breakpoints.\n\tdo_cmdline_cmd((char_u *)\"lmapclear\");\n\tdo_cmdline_cmd((char_u *)\"xmapclear\");\n\tdo_cmdline_cmd((char_u *)\"mapclear\");\n\tdo_cmdline_cmd((char_u *)\"mapclear!\");\n\tdo_cmdline_cmd((char_u *)\"abclear\");\n# if defined(FEAT_EVAL)\n\tdo_cmdline_cmd((char_u *)\"breakdel *\");\n# endif\n# if defined(FEAT_PROFILE)\n\tdo_cmdline_cmd((char_u *)\"profdel *\");\n# endif\n# if defined(FEAT_KEYMAP)\n\tdo_cmdline_cmd((char_u *)\"set keymap=\");\n# endif\n    }\n\n    free_titles();\n# if defined(FEAT_SEARCHPATH)\n    free_findfile();\n# endif\n\n    // Obviously named calls.\n    free_all_autocmds();\n    clear_termcodes();\n    free_all_marks();\n    alist_clear(&global_alist);\n    free_homedir();\n    free_users();\n    free_search_patterns();\n    free_old_sub();\n    free_last_insert();\n    free_insexpand_stuff();\n    free_prev_shellcmd();\n    free_regexp_stuff();\n    free_tag_stuff();\n    free_xim_stuff();\n    free_cd_dir();\n# ifdef FEAT_SIGNS\n    free_signs();\n# endif\n# ifdef FEAT_EVAL\n    set_expr_line(NULL, NULL);\n# endif\n# ifdef FEAT_DIFF\n    if (curtab != NULL)\n\tdiff_clear(curtab);\n# endif\n    clear_sb_text(TRUE);\t      // free any scrollback text\n\n    // Free some global vars.\n    free_username();\n# ifdef FEAT_CLIPBOARD\n    vim_regfree(clip_exclude_prog);\n# endif\n    vim_free(last_cmdline);\n    vim_free(new_last_cmdline);\n    set_keep_msg(NULL, 0);\n\n    // Clear cmdline history.\n    p_hi = 0;\n    init_history();\n# ifdef FEAT_PROP_POPUP\n    clear_global_prop_types();\n# endif\n\n# ifdef FEAT_QUICKFIX\n    {\n\twin_T\t    *win;\n\ttabpage_T   *tab;\n\n\tqf_free_all(NULL);\n\t// Free all location lists\n\tFOR_ALL_TAB_WINDOWS(tab, win)\n\t    qf_free_all(win);\n    }\n# endif\n\n    // Close all script inputs.\n    close_all_scripts();\n\n    if (curwin != NULL)\n\t// Destroy all windows.  Must come before freeing buffers.\n\twin_free_all();\n\n    // Free all option values.  Must come after closing windows.\n    free_all_options();\n\n    // Free all buffers.  Reset 'autochdir' to avoid accessing things that\n    // were freed already.\n# ifdef FEAT_AUTOCHDIR\n    p_acd = FALSE;\n# endif\n    for (buf = firstbuf; buf != NULL; )\n    {\n\tbufref_T    bufref;\n\n\tset_bufref(&bufref, buf);\n\tnextbuf = buf->b_next;\n\tclose_buffer(NULL, buf, DOBUF_WIPE, FALSE, FALSE);\n\tif (bufref_valid(&bufref))\n\t    buf = nextbuf;\t// didn't work, try next one\n\telse\n\t    buf = firstbuf;\n    }\n\n# ifdef FEAT_ARABIC\n    free_arshape_buf();\n# endif\n\n    // Clear registers.\n    clear_registers();\n    ResetRedobuff();\n    ResetRedobuff();\n\n# if defined(FEAT_CLIENTSERVER) && defined(FEAT_X11)\n    vim_free(serverDelayedStartName);\n# endif\n\n    // highlight info\n    free_highlight();\n\n    reset_last_sourcing();\n\n    if (first_tabpage != NULL)\n    {\n\tfree_tabpage(first_tabpage);\n\tfirst_tabpage = NULL;\n    }\n\n# ifdef UNIX\n    // Machine-specific free.\n    mch_free_mem();\n# endif\n\n    // message history\n    for (;;)\n\tif (delete_first_msg() == FAIL)\n\t    break;\n\n# ifdef FEAT_JOB_CHANNEL\n    channel_free_all();\n# endif\n# ifdef FEAT_TIMERS\n    timer_free_all();\n# endif\n# ifdef FEAT_EVAL\n    // must be after channel_free_all() with unrefs partials\n    eval_clear();\n# endif\n# ifdef FEAT_JOB_CHANNEL\n    // must be after eval_clear() with unrefs jobs\n    job_free_all();\n# endif\n\n    free_termoptions();\n    free_cur_term();\n\n    // screenlines (can't display anything now!)\n    free_screenlines();\n\n# if defined(FEAT_SOUND)\n    sound_free();\n# endif\n# if defined(USE_XSMP)\n    xsmp_close();\n# endif\n# ifdef FEAT_GUI_GTK\n    gui_mch_free_all();\n# endif\n# ifdef FEAT_TCL\n    vim_tcl_finalize();\n# endif\n    clear_hl_tables();\n\n    vim_free(IObuff);\n    vim_free(NameBuff);\n# ifdef FEAT_QUICKFIX\n    check_quickfix_busy();\n# endif\n}\n#endif\n\n/*\n * Copy \"p[len]\" into allocated memory, ignoring NUL characters.\n * Returns NULL when out of memory.\n */\n    char_u *\nvim_memsave(char_u *p, size_t len)\n{\n    char_u *ret = alloc(len);\n\n    if (ret != NULL)\n\tmch_memmove(ret, p, len);\n    return ret;\n}\n\n/*\n * Replacement for free() that ignores NULL pointers.\n * Also skip free() when exiting for sure, this helps when we caught a deadly\n * signal that was caused by a crash in free().\n * If you want to set NULL after calling this function, you should use\n * VIM_CLEAR() instead.\n */\n    void\nvim_free(void *x)\n{\n    if (x != NULL && !really_exiting)\n    {\n#ifdef MEM_PROFILE\n\tmem_pre_free(&x);\n#endif\n\tfree(x);\n    }\n}\n\n/************************************************************************\n * Functions for handling growing arrays.\n */\n\n/*\n * Clear an allocated growing array.\n */\n    void\nga_clear(garray_T *gap)\n{\n    vim_free(gap->ga_data);\n    ga_init(gap);\n}\n\n/*\n * Clear a growing array that contains a list of strings.\n */\n    void\nga_clear_strings(garray_T *gap)\n{\n    int\t\ti;\n\n    if (gap->ga_data != NULL)\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t    vim_free(((char_u **)(gap->ga_data))[i]);\n    ga_clear(gap);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Copy a growing array that contains a list of strings.\n */\n    int\nga_copy_strings(garray_T *from, garray_T *to)\n{\n    int\t\ti;\n\n    ga_init2(to, sizeof(char_u *), 1);\n    if (ga_grow(to, from->ga_len) == FAIL)\n\treturn FAIL;\n\n    for (i = 0; i < from->ga_len; ++i)\n    {\n\tchar_u *orig = ((char_u **)from->ga_data)[i];\n\tchar_u *copy;\n\n\tif (orig == NULL)\n\t    copy = NULL;\n\telse\n\t{\n\t    copy = vim_strsave(orig);\n\t    if (copy == NULL)\n\t    {\n\t\tto->ga_len = i;\n\t\tga_clear_strings(to);\n\t\treturn FAIL;\n\t    }\n\t}\n\t((char_u **)to->ga_data)[i] = copy;\n    }\n    to->ga_len = from->ga_len;\n    return OK;\n}\n#endif\n\n/*\n * Initialize a growing array.\tDon't forget to set ga_itemsize and\n * ga_growsize!  Or use ga_init2().\n */\n    void\nga_init(garray_T *gap)\n{\n    gap->ga_data = NULL;\n    gap->ga_maxlen = 0;\n    gap->ga_len = 0;\n}\n\n    void\nga_init2(garray_T *gap, size_t itemsize, int growsize)\n{\n    ga_init(gap);\n    gap->ga_itemsize = itemsize;\n    gap->ga_growsize = growsize;\n}\n\n/*\n * Make room in growing array \"gap\" for at least \"n\" items.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nga_grow(garray_T *gap, int n)\n{\n    if (gap->ga_maxlen - gap->ga_len < n)\n\treturn ga_grow_inner(gap, n);\n    return OK;\n}\n\n    int\nga_grow_inner(garray_T *gap, int n)\n{\n    size_t\told_len;\n    size_t\tnew_len;\n    char_u\t*pp;\n\n    if (n < gap->ga_growsize)\n\tn = gap->ga_growsize;\n\n    // A linear growth is very inefficient when the array grows big.  This\n    // is a compromise between allocating memory that won't be used and too\n    // many copy operations. A factor of 1.5 seems reasonable.\n    if (n < gap->ga_len / 2)\n\tn = gap->ga_len / 2;\n\n    new_len = gap->ga_itemsize * (gap->ga_len + n);\n    pp = vim_realloc(gap->ga_data, new_len);\n    if (pp == NULL)\n\treturn FAIL;\n    old_len = gap->ga_itemsize * gap->ga_maxlen;\n    vim_memset(pp + old_len, 0, new_len - old_len);\n    gap->ga_maxlen = gap->ga_len + n;\n    gap->ga_data = pp;\n    return OK;\n}\n\n/*\n * For a growing array that contains a list of strings: concatenate all the\n * strings with a separating \"sep\".\n * Returns NULL when out of memory.\n */\n    char_u *\nga_concat_strings(garray_T *gap, char *sep)\n{\n    int\t\ti;\n    int\t\tlen = 0;\n    int\t\tsep_len = (int)STRLEN(sep);\n    char_u\t*s;\n    char_u\t*p;\n\n    for (i = 0; i < gap->ga_len; ++i)\n\tlen += (int)STRLEN(((char_u **)(gap->ga_data))[i]) + sep_len;\n\n    s = alloc(len + 1);\n    if (s != NULL)\n    {\n\t*s = NUL;\n\tp = s;\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    if (p != s)\n\t    {\n\t\tSTRCPY(p, sep);\n\t\tp += sep_len;\n\t    }\n\t    STRCPY(p, ((char_u **)(gap->ga_data))[i]);\n\t    p += STRLEN(p);\n\t}\n    }\n    return s;\n}\n\n/*\n * Make a copy of string \"p\" and add it to \"gap\".\n * When out of memory nothing changes and FAIL is returned.\n */\n    int\nga_copy_string(garray_T *gap, char_u *p)\n{\n    char_u *cp = vim_strsave(p);\n\n    if (cp == NULL)\n\treturn FAIL;\n\n    if (ga_grow(gap, 1) == FAIL)\n    {\n\tvim_free(cp);\n\treturn FAIL;\n    }\n    ((char_u **)(gap->ga_data))[gap->ga_len++] = cp;\n    return OK;\n}\n\n/*\n * Add string \"p\" to \"gap\".\n * When out of memory \"p\" is freed and FAIL is returned.\n */\n    int\nga_add_string(garray_T *gap, char_u *p)\n{\n    if (ga_grow(gap, 1) == FAIL)\n\treturn FAIL;\n    ((char_u **)(gap->ga_data))[gap->ga_len++] = p;\n    return OK;\n}\n\n/*\n * Concatenate a string to a growarray which contains bytes.\n * When \"s\" is NULL does not do anything.\n * Note: Does NOT copy the NUL at the end!\n */\n    void\nga_concat(garray_T *gap, char_u *s)\n{\n    int    len;\n\n    if (s == NULL || *s == NUL)\n\treturn;\n    len = (int)STRLEN(s);\n    if (ga_grow(gap, len) == OK)\n    {\n\tmch_memmove((char *)gap->ga_data + gap->ga_len, s, (size_t)len);\n\tgap->ga_len += len;\n    }\n}\n\n/*\n * Concatenate 'len' bytes from string 's' to a growarray.\n * When \"s\" is NULL does not do anything.\n */\n    void\nga_concat_len(garray_T *gap, char_u *s, size_t len)\n{\n    if (s == NULL || *s == NUL)\n\treturn;\n    if (ga_grow(gap, (int)len) == OK)\n    {\n\tmch_memmove((char *)gap->ga_data + gap->ga_len, s, len);\n\tgap->ga_len += (int)len;\n    }\n}\n\n/*\n * Append one byte to a growarray which contains bytes.\n */\n    void\nga_append(garray_T *gap, int c)\n{\n    if (ga_grow(gap, 1) == OK)\n    {\n\t*((char *)gap->ga_data + gap->ga_len) = c;\n\t++gap->ga_len;\n    }\n}\n\n#if (defined(UNIX) && !defined(USE_SYSTEM)) || defined(MSWIN) \\\n\t|| defined(PROTO)\n/*\n * Append the text in \"gap\" below the cursor line and clear \"gap\".\n */\n    void\nappend_ga_line(garray_T *gap)\n{\n    // Remove trailing CR.\n    if (gap->ga_len > 0\n\t    && !curbuf->b_p_bin\n\t    && ((char_u *)gap->ga_data)[gap->ga_len - 1] == CAR)\n\t--gap->ga_len;\n    ga_append(gap, NUL);\n    ml_append(curwin->w_cursor.lnum++, gap->ga_data, 0, FALSE);\n    gap->ga_len = 0;\n}\n#endif\n\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * message.c: functions for displaying messages on the command line\n */\n\n#define MESSAGE_FILE\t\t// don't include prototype for smsg()\n\n#include \"vim.h\"\n\nstatic void add_msg_hist(char_u *s, int len, int attr);\nstatic void hit_return_msg(void);\nstatic void msg_home_replace_attr(char_u *fname, int attr);\nstatic void msg_puts_attr_len(char *str, int maxlen, int attr);\nstatic void msg_puts_display(char_u *str, int maxlen, int attr, int recurse);\nstatic void msg_scroll_up(void);\nstatic void inc_msg_scrolled(void);\nstatic void store_sb_text(char_u **sb_str, char_u *s, int attr, int *sb_col, int finish);\nstatic void t_puts(int *t_col, char_u *t_s, char_u *s, int attr);\nstatic void msg_puts_printf(char_u *str, int maxlen);\nstatic int do_more_prompt(int typed_char);\nstatic void msg_screen_putchar(int c, int attr);\nstatic void msg_moremsg(int full);\nstatic int  msg_check_screen(void);\nstatic void redir_write(char_u *s, int maxlen);\n#ifdef FEAT_CON_DIALOG\nstatic char_u *msg_show_console_dialog(char_u *message, char_u *buttons, int dfltbutton);\nstatic int\tconfirm_msg_used = FALSE;\t// displaying confirm_msg\nstatic char_u\t*confirm_msg = NULL;\t\t// \":confirm\" message\nstatic char_u\t*confirm_msg_tail;\t\t// tail of confirm_msg\nstatic void display_confirm_msg(void);\n#endif\n#ifdef FEAT_JOB_CHANNEL\nstatic int emsg_to_channel_log = FALSE;\n#endif\n\nstruct msg_hist\n{\n    struct msg_hist\t*next;\n    char_u\t\t*msg;\n    int\t\t\tattr;\n};\n\nstatic struct msg_hist *first_msg_hist = NULL;\nstatic struct msg_hist *last_msg_hist = NULL;\nstatic int msg_hist_len = 0;\n\nstatic FILE *verbose_fd = NULL;\nstatic int  verbose_did_open = FALSE;\n\n/*\n * When writing messages to the screen, there are many different situations.\n * A number of variables is used to remember the current state:\n * msg_didany\t    TRUE when messages were written since the last time the\n *\t\t    user reacted to a prompt.\n *\t\t    Reset: After hitting a key for the hit-return prompt,\n *\t\t    hitting <CR> for the command line or input().\n *\t\t    Set: When any message is written to the screen.\n * msg_didout\t    TRUE when something was written to the current line.\n *\t\t    Reset: When advancing to the next line, when the current\n *\t\t    text can be overwritten.\n *\t\t    Set: When any message is written to the screen.\n * msg_nowait\t    No extra delay for the last drawn message.\n *\t\t    Used in normal_cmd() before the mode message is drawn.\n * emsg_on_display  There was an error message recently.  Indicates that there\n *\t\t    should be a delay before redrawing.\n * msg_scroll\t    The next message should not overwrite the current one.\n * msg_scrolled\t    How many lines the screen has been scrolled (because of\n *\t\t    messages).  Used in update_screen() to scroll the screen\n *\t\t    back.  Incremented each time the screen scrolls a line.\n * msg_scrolled_ign  TRUE when msg_scrolled is non-zero and msg_puts_attr()\n *\t\t    writes something without scrolling should not make\n *\t\t    need_wait_return to be set.  This is a hack to make \":ts\"\n *\t\t    work without an extra prompt.\n * lines_left\t    Number of lines available for messages before the\n *\t\t    more-prompt is to be given.  -1 when not set.\n * need_wait_return TRUE when the hit-return prompt is needed.\n *\t\t    Reset: After giving the hit-return prompt, when the user\n *\t\t    has answered some other prompt.\n *\t\t    Set: When the ruler or typeahead display is overwritten,\n *\t\t    scrolling the screen for some message.\n * keep_msg\t    Message to be displayed after redrawing the screen, in\n *\t\t    main_loop().\n *\t\t    This is an allocated string or NULL when not used.\n */\n\n/*\n * msg(s) - displays the string 's' on the status line\n * When terminal not initialized (yet) mch_errmsg(..) is used.\n * return TRUE if wait_return not called\n */\n    int\nmsg(char *s)\n{\n    return msg_attr_keep(s, 0, FALSE);\n}\n\n/*\n * Like msg() but keep it silent when 'verbosefile' is set.\n */\n    int\nverb_msg(char *s)\n{\n    int\t\tn;\n\n    verbose_enter();\n    n = msg_attr_keep(s, 0, FALSE);\n    verbose_leave();\n\n    return n;\n}\n\n    int\nmsg_attr(char *s, int attr)\n{\n    return msg_attr_keep(s, attr, FALSE);\n}\n\n    int\nmsg_attr_keep(\n    char\t*s,\n    int\t\tattr,\n    int\t\tkeep)\t    // TRUE: set keep_msg if it doesn't scroll\n{\n    static int\tentered = 0;\n    int\t\tretval;\n    char_u\t*buf = NULL;\n\n    // Skip messages not matching \":filter pattern\".\n    // Don't filter when there is an error.\n    if (!emsg_on_display && message_filtered((char_u *)s))\n\treturn TRUE;\n\n#ifdef FEAT_EVAL\n    if (attr == 0)\n\tset_vim_var_string(VV_STATUSMSG, (char_u *)s, -1);\n#endif\n\n    /*\n     * It is possible that displaying a messages causes a problem (e.g.,\n     * when redrawing the window), which causes another message, etc..\tTo\n     * break this loop, limit the recursiveness to 3 levels.\n     */\n    if (entered >= 3)\n\treturn TRUE;\n    ++entered;\n\n    // Add message to history (unless it's a repeated kept message or a\n    // truncated message)\n    if ((char_u *)s != keep_msg\n\t    || (*s != '<'\n\t\t&& last_msg_hist != NULL\n\t\t&& last_msg_hist->msg != NULL\n\t\t&& STRCMP(s, last_msg_hist->msg)))\n\tadd_msg_hist((char_u *)s, -1, attr);\n\n#ifdef FEAT_JOB_CHANNEL\n    if (emsg_to_channel_log)\n\t// Write message in the channel log.\n\tch_log(NULL, \"ERROR: %s\", (char *)s);\n#endif\n\n    // Truncate the message if needed.\n    msg_start();\n    buf = msg_strtrunc((char_u *)s, FALSE);\n    if (buf != NULL)\n\ts = (char *)buf;\n\n    msg_outtrans_attr((char_u *)s, attr);\n    msg_clr_eos();\n    retval = msg_end();\n\n    if (keep && retval && vim_strsize((char_u *)s)\n\t\t\t    < (int)(Rows - cmdline_row - 1) * Columns + sc_col)\n\tset_keep_msg((char_u *)s, 0);\n\n    vim_free(buf);\n    --entered;\n    return retval;\n}\n\n/*\n * Truncate a string such that it can be printed without causing a scroll.\n * Returns an allocated string or NULL when no truncating is done.\n */\n    char_u *\nmsg_strtrunc(\n    char_u\t*s,\n    int\t\tforce)\t    // always truncate\n{\n    char_u\t*buf = NULL;\n    int\t\tlen;\n    int\t\troom;\n\n    // May truncate message to avoid a hit-return prompt\n    if ((!msg_scroll && !need_wait_return && shortmess(SHM_TRUNCALL)\n\t\t\t       && !exmode_active && msg_silent == 0) || force)\n    {\n\tlen = vim_strsize(s);\n\tif (msg_scrolled != 0)\n\t    // Use all the columns.\n\t    room = (int)(Rows - msg_row) * Columns - 1;\n\telse\n\t    // Use up to 'showcmd' column.\n\t    room = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;\n\tif (len > room && room > 0)\n\t{\n\t    if (enc_utf8)\n\t\t// may have up to 18 bytes per cell (6 per char, up to two\n\t\t// composing chars)\n\t\tlen = (room + 2) * 18;\n\t    else if (enc_dbcs == DBCS_JPNU)\n\t\t// may have up to 2 bytes per cell for euc-jp\n\t\tlen = (room + 2) * 2;\n\t    else\n\t\tlen = room + 2;\n\t    buf = alloc(len);\n\t    if (buf != NULL)\n\t\ttrunc_string(s, buf, room, len);\n\t}\n    }\n    return buf;\n}\n\n/*\n * Truncate a string \"s\" to \"buf\" with cell width \"room\".\n * \"s\" and \"buf\" may be equal.\n */\n    void\ntrunc_string(\n    char_u\t*s,\n    char_u\t*buf,\n    int\t\troom_in,\n    int\t\tbuflen)\n{\n    size_t\troom = room_in - 3; // \"...\" takes 3 chars\n    size_t\thalf;\n    size_t\tlen = 0;\n    int\t\te;\n    int\t\ti;\n    int\t\tn;\n\n    if (*s == NUL)\n    {\n\tif (buflen > 0)\n\t    *buf = NUL;\n\treturn;\n    }\n\n    if (room_in < 3)\n\troom = 0;\n    half = room / 2;\n\n    // First part: Start of the string.\n    for (e = 0; len < half && e < buflen; ++e)\n    {\n\tif (s[e] == NUL)\n\t{\n\t    // text fits without truncating!\n\t    buf[e] = NUL;\n\t    return;\n\t}\n\tn = ptr2cells(s + e);\n\tif (len + n > half)\n\t    break;\n\tlen += n;\n\tbuf[e] = s[e];\n\tif (has_mbyte)\n\t    for (n = (*mb_ptr2len)(s + e); --n > 0; )\n\t    {\n\t\tif (++e == buflen)\n\t\t    break;\n\t\tbuf[e] = s[e];\n\t    }\n    }\n\n    // Last part: End of the string.\n    i = e;\n    if (enc_dbcs != 0)\n    {\n\t// For DBCS going backwards in a string is slow, but\n\t// computing the cell width isn't too slow: go forward\n\t// until the rest fits.\n\tn = vim_strsize(s + i);\n\twhile (len + n > room)\n\t{\n\t    n -= ptr2cells(s + i);\n\t    i += (*mb_ptr2len)(s + i);\n\t}\n    }\n    else if (enc_utf8)\n    {\n\t// For UTF-8 we can go backwards easily.\n\thalf = i = (int)STRLEN(s);\n\tfor (;;)\n\t{\n\t    do\n\t\thalf = half - utf_head_off(s, s + half - 1) - 1;\n\t    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));\n\t    n = ptr2cells(s + half);\n\t    if (len + n > room || half == 0)\n\t\tbreak;\n\t    len += n;\n\t    i = (int)half;\n\t}\n    }\n    else\n    {\n\tfor (i = (int)STRLEN(s);\n\t\t   i - 1 >= 0 && len + (n = ptr2cells(s + i - 1)) <= room; --i)\n\t    len += n;\n    }\n\n\n    if (i <= e + 3)\n    {\n\t// text fits without truncating\n\tif (s != buf)\n\t{\n\t    len = STRLEN(s);\n\t    if (len >= (size_t)buflen)\n\t\tlen = buflen - 1;\n\t    len = len - e + 1;\n\t    if (len < 1)\n\t\tbuf[e - 1] = NUL;\n\t    else\n\t\tmch_memmove(buf + e, s + e, len);\n\t}\n    }\n    else if (e + 3 < buflen)\n    {\n\t// set the middle and copy the last part\n\tmch_memmove(buf + e, \"...\", (size_t)3);\n\tlen = STRLEN(s + i) + 1;\n\tif (len >= (size_t)buflen - e - 3)\n\t    len = buflen - e - 3 - 1;\n\tmch_memmove(buf + e + 3, s + i, len);\n\tbuf[e + 3 + len - 1] = NUL;\n    }\n    else\n    {\n\t// can't fit in the \"...\", just truncate it\n\tbuf[e - 1] = NUL;\n    }\n}\n\n/*\n * Automatic prototype generation does not understand this function.\n * Note: Caller of smsg() and smsg_attr() must check the resulting string is\n * shorter than IOSIZE!!!\n */\n#ifndef PROTO\n\nint vim_snprintf(char *str, size_t str_m, const char *fmt, ...);\n\n    int\nsmsg(const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg((char *)s);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg((char *)IObuff);\n    }\n}\n\n    int\nsmsg_attr(int attr, const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg_attr((char *)s, attr);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg_attr((char *)IObuff, attr);\n    }\n}\n\n    int\nsmsg_attr_keep(int attr, const char *s, ...)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just\n\t// give the raw message so the user at least gets a hint.\n\treturn msg_attr_keep((char *)s, attr, TRUE);\n    }\n    else\n    {\n\tva_list arglist;\n\n\tva_start(arglist, s);\n\tvim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);\n\tva_end(arglist);\n\treturn msg_attr_keep((char *)IObuff, attr, TRUE);\n    }\n}\n\n#endif\n\n/*\n * Remember the last sourcing name/lnum used in an error message, so that it\n * isn't printed each time when it didn't change.\n */\nstatic int\tlast_sourcing_lnum = 0;\nstatic char_u   *last_sourcing_name = NULL;\n\n/*\n * Reset the last used sourcing name/lnum.  Makes sure it is displayed again\n * for the next error message;\n */\n    void\nreset_last_sourcing(void)\n{\n    VIM_CLEAR(last_sourcing_name);\n    last_sourcing_lnum = 0;\n}\n\n/*\n * Return TRUE if \"SOURCING_NAME\" differs from \"last_sourcing_name\".\n */\n    static int\nother_sourcing_name(void)\n{\n    if (HAVE_SOURCING_INFO && SOURCING_NAME != NULL)\n    {\n\tif (last_sourcing_name != NULL)\n\t    return STRCMP(SOURCING_NAME, last_sourcing_name) != 0;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Get the message about the source, as used for an error message.\n * Returns an allocated string with room for one more character.\n * Returns NULL when no message is to be given.\n */\n    static char_u *\nget_emsg_source(void)\n{\n    char_u\t*Buf, *p;\n\n    if (HAVE_SOURCING_INFO && SOURCING_NAME != NULL && other_sourcing_name())\n    {\n\tchar_u\t    *sname = estack_sfile(ESTACK_NONE);\n\tchar_u\t    *tofree = sname;\n\n\tif (sname == NULL)\n\t    sname = SOURCING_NAME;\n\n#ifdef FEAT_EVAL\n\tif (estack_compiling)\n\t    p = (char_u *)_(\"Error detected while compiling %s:\");\n\telse\n#endif\n\t    p = (char_u *)_(\"Error detected while processing %s:\");\n\tBuf = alloc(STRLEN(sname) + STRLEN(p));\n\tif (Buf != NULL)\n\t    sprintf((char *)Buf, (char *)p, sname);\n\tvim_free(tofree);\n\treturn Buf;\n    }\n    return NULL;\n}\n\n/*\n * Get the message about the source lnum, as used for an error message.\n * Returns an allocated string with room for one more character.\n * Returns NULL when no message is to be given.\n */\n    static char_u *\nget_emsg_lnum(void)\n{\n    char_u\t*Buf, *p;\n\n    // lnum is 0 when executing a command from the command line\n    // argument, we don't want a line number then\n    if (SOURCING_NAME != NULL\n\t    && (other_sourcing_name() || SOURCING_LNUM != last_sourcing_lnum)\n\t    && SOURCING_LNUM != 0)\n    {\n\tp = (char_u *)_(\"line %4ld:\");\n\tBuf = alloc(STRLEN(p) + 20);\n\tif (Buf != NULL)\n\t    sprintf((char *)Buf, (char *)p, (long)SOURCING_LNUM);\n\treturn Buf;\n    }\n    return NULL;\n}\n\n/*\n * Display name and line number for the source of an error.\n * Remember the file name and line number, so that for the next error the info\n * is only displayed if it changed.\n */\n    void\nmsg_source(int attr)\n{\n    char_u\t*p;\n    static int\trecursive = FALSE;\n\n    // Bail out if something called here causes an error.\n    if (recursive)\n\treturn;\n    recursive = TRUE;\n\n    ++no_wait_return;\n    p = get_emsg_source();\n    if (p != NULL)\n    {\n\tmsg_attr((char *)p, attr);\n\tvim_free(p);\n    }\n    p = get_emsg_lnum();\n    if (p != NULL)\n    {\n\tmsg_attr((char *)p, HL_ATTR(HLF_N));\n\tvim_free(p);\n\tlast_sourcing_lnum = SOURCING_LNUM;  // only once for each line\n    }\n\n    // remember the last sourcing name printed, also when it's empty\n    if (SOURCING_NAME == NULL || other_sourcing_name())\n    {\n\tVIM_CLEAR(last_sourcing_name);\n\tif (SOURCING_NAME != NULL)\n\t    last_sourcing_name = vim_strsave(SOURCING_NAME);\n    }\n    --no_wait_return;\n\n    recursive = FALSE;\n}\n\n/*\n * Return TRUE if not giving error messages right now:\n * If \"emsg_off\" is set: no error messages at the moment.\n * If \"msg\" is in 'debug': do error message but without side effects.\n * If \"emsg_skip\" is set: never do error messages.\n */\n    static int\nemsg_not_now(void)\n{\n    if ((emsg_off > 0 && vim_strchr(p_debug, 'm') == NULL\n\t\t\t\t\t  && vim_strchr(p_debug, 't') == NULL)\n#ifdef FEAT_EVAL\n\t    || emsg_skip > 0\n#endif\n\t    )\n\treturn TRUE;\n    return FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\nstatic garray_T ignore_error_list = GA_EMPTY;\n\n    void\nignore_error_for_testing(char_u *error)\n{\n    if (ignore_error_list.ga_itemsize == 0)\n\tga_init2(&ignore_error_list, sizeof(char_u *), 1);\n\n    if (STRCMP(\"RESET\", error) == 0)\n\tga_clear_strings(&ignore_error_list);\n    else\n\tga_copy_string(&ignore_error_list, error);\n}\n\n    static int\nignore_error(char_u *msg)\n{\n    int i;\n\n    for (i = 0; i < ignore_error_list.ga_len; ++i)\n\tif (strstr((char *)msg,\n\t\t  (char *)((char_u **)(ignore_error_list.ga_data))[i]) != NULL)\n\t    return TRUE;\n    return FALSE;\n}\n#endif\n\n#if !defined(HAVE_STRERROR) || defined(PROTO)\n/*\n * Replacement for perror() that behaves more or less like emsg() was called.\n * v:errmsg will be set and called_emsg will be incremented.\n */\n    void\ndo_perror(char *msg)\n{\n    perror(msg);\n    ++emsg_silent;\n    emsg(msg);\n    --emsg_silent;\n}\n#endif\n\n/*\n * emsg_core() - display an error message\n *\n * Rings the bell, if appropriate, and calls message() to do the real work\n * When terminal not initialized (yet) mch_errmsg(..) is used.\n *\n * Return TRUE if wait_return not called.\n * Note: caller must check 'emsg_not_now()' before calling this.\n */\n    static int\nemsg_core(char_u *s)\n{\n    int\t\tattr;\n    char_u\t*p;\n    int\t\tr;\n#ifdef FEAT_EVAL\n    int\t\tignore = FALSE;\n    int\t\tsevere;\n#endif\n\n#ifdef FEAT_EVAL\n    // When testing some errors are turned into a normal message.\n    if (ignore_error(s))\n\t// don't call msg() if it results in a dialog\n\treturn msg_use_printf() ? FALSE : msg((char *)s);\n#endif\n\n    ++called_emsg;\n\n#ifdef FEAT_EVAL\n    // If \"emsg_severe\" is TRUE: When an error exception is to be thrown,\n    // prefer this message over previous messages for the same command.\n    severe = emsg_severe;\n    emsg_severe = FALSE;\n#endif\n\n    if (!emsg_off || vim_strchr(p_debug, 't') != NULL)\n    {\n#ifdef FEAT_EVAL\n\t/*\n\t * Cause a throw of an error exception if appropriate.  Don't display\n\t * the error message in this case.  (If no matching catch clause will\n\t * be found, the message will be displayed later on.)  \"ignore\" is set\n\t * when the message should be ignored completely (used for the\n\t * interrupt message).\n\t */\n\tif (cause_errthrow(s, severe, &ignore) == TRUE)\n\t{\n\t    if (!ignore)\n\t\t++did_emsg;\n\t    return TRUE;\n\t}\n\n\tif (in_assert_fails && emsg_assert_fails_msg == NULL)\n\t{\n\t    emsg_assert_fails_msg = vim_strsave(s);\n\t    emsg_assert_fails_lnum = SOURCING_LNUM;\n\t    vim_free(emsg_assert_fails_context);\n\t    emsg_assert_fails_context = vim_strsave(\n\t\t\t SOURCING_NAME == NULL ? (char_u *)\"\" : SOURCING_NAME);\n\t}\n\n\t// set \"v:errmsg\", also when using \":silent! cmd\"\n\tset_vim_var_string(VV_ERRMSG, s, -1);\n#endif\n\n\t/*\n\t * When using \":silent! cmd\" ignore error messages.\n\t * But do write it to the redirection file.\n\t */\n\tif (emsg_silent != 0)\n\t{\n#ifdef FEAT_EVAL\n\t    ++did_emsg_silent;\n#endif\n\t    if (emsg_noredir == 0)\n\t    {\n\t\tmsg_start();\n\t\tp = get_emsg_source();\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(p, \"\\n\");\n\t\t    redir_write(p, -1);\n\t\t    vim_free(p);\n\t\t}\n\t\tp = get_emsg_lnum();\n\t\tif (p != NULL)\n\t\t{\n\t\t    STRCAT(p, \"\\n\");\n\t\t    redir_write(p, -1);\n\t\t    vim_free(p);\n\t\t}\n\t\tredir_write(s, -1);\n\t    }\n#ifdef FEAT_EVAL\n\t    // Only increment did_emsg_def when :silent! wasn't used inside the\n\t    // :def function.\n\t    if (emsg_silent == emsg_silent_def)\n\t\t++did_emsg_def;\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t    ch_log(NULL, \"ERROR silent: %s\", (char *)s);\n#endif\n\t    return TRUE;\n\t}\n\n\tex_exitval = 1;\n\n\t// Reset msg_silent, an error causes messages to be switched back on.\n\tmsg_silent = 0;\n\tcmd_silent = FALSE;\n\n\tif (global_busy)\t\t// break :global command\n\t    ++global_busy;\n\n\tif (p_eb)\n\t    beep_flush();\t\t// also includes flush_buffers()\n\telse\n\t    flush_buffers(FLUSH_MINIMAL);  // flush internal buffers\n\t++did_emsg;\t\t\t   // flag for DoOneCmd()\n#ifdef FEAT_EVAL\n\t++uncaught_emsg;\n#endif\n    }\n\n    emsg_on_display = TRUE;\t// remember there is an error message\n    ++msg_scroll;\t\t// don't overwrite a previous message\n    attr = HL_ATTR(HLF_E);\t// set highlight mode for error messages\n    if (msg_scrolled != 0)\n\tneed_wait_return = TRUE;    // needed in case emsg() is called after\n\t\t\t\t    // wait_return has reset need_wait_return\n\t\t\t\t    // and a redraw is expected because\n\t\t\t\t    // msg_scrolled is non-zero\n\n#ifdef FEAT_JOB_CHANNEL\n    emsg_to_channel_log = TRUE;\n#endif\n    /*\n     * Display name and line number for the source of the error.\n     */\n    msg_source(attr);\n\n    /*\n     * Display the error message itself.\n     */\n    msg_nowait = FALSE;\t\t\t// wait for this msg\n    r = msg_attr((char *)s, attr);\n\n#ifdef FEAT_JOB_CHANNEL\n    emsg_to_channel_log = FALSE;\n#endif\n    return r;\n}\n\n/*\n * Print an error message.\n */\n    int\nemsg(char *s)\n{\n    // Skip this if not giving error messages at the moment.\n    if (!emsg_not_now())\n\treturn emsg_core((char_u *)s);\n    return TRUE;\t\t// no error messages at the moment\n}\n\n#ifndef PROTO  // manual proto with __attribute__\n/*\n * Print an error message with format string and variable arguments.\n * Note: caller must not pass 'IObuff' as 1st argument.\n */\n    int\nsemsg(const char *s, ...)\n{\n    // Skip this if not giving error messages at the moment.\n    if (!emsg_not_now())\n    {\n\tif (IObuff == NULL)\n\t{\n\t    // Very early in initialisation and already something wrong, just\n\t    // give the raw message so the user at least gets a hint.\n\t    return emsg_core((char_u *)s);\n\t}\n\telse\n\t{\n\t    va_list ap;\n\n\t    va_start(ap, s);\n\t    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\t    va_end(ap);\n\t    return emsg_core(IObuff);\n\t}\n    }\n    return TRUE;\t\t// no error messages at the moment\n}\n#endif\n\n/*\n * Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is\n * defined. It is used for internal errors only, so that they can be\n * detected when fuzzing vim.\n */\n    void\niemsg(char *s)\n{\n    if (!emsg_not_now())\n    {\n\temsg_core((char_u *)s);\n#if defined(ABORT_ON_INTERNAL_ERROR) && defined(FEAT_EVAL)\n\tset_vim_var_string(VV_ERRMSG, (char_u *)s, -1);\n\tabort();\n#endif\n    }\n}\n\n#ifndef PROTO  // manual proto with __attribute__\n/*\n * Same as semsg(...) but abort on error when ABORT_ON_INTERNAL_ERROR is\n * defined. It is used for internal errors only, so that they can be\n * detected when fuzzing vim.\n * Note: caller must not pass 'IObuff' as 1st argument.\n */\n    void\nsiemsg(const char *s, ...)\n{\n    if (!emsg_not_now())\n    {\n\tif (IObuff == NULL)\n\t{\n\t    // Very early in initialisation and already something wrong, just\n\t    // give the raw message so the user at least gets a hint.\n\t    emsg_core((char_u *)s);\n\t}\n\telse\n\t{\n\t    va_list ap;\n\n\t    va_start(ap, s);\n\t    vim_vsnprintf((char *)IObuff, IOSIZE, s, ap);\n\t    va_end(ap);\n\t    emsg_core(IObuff);\n\t}\n    }\n# ifdef ABORT_ON_INTERNAL_ERROR\n    abort();\n# endif\n}\n#endif\n\n/*\n * Give an \"Internal error\" message.\n */\n    void\ninternal_error(char *where)\n{\n    siemsg(_(e_internal_error_str), where);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Like internal_error() but do not call abort(), to avoid tests using\n * test_unknown() and test_void() causing Vim to exit.\n */\n    void\ninternal_error_no_abort(char *where)\n{\n     semsg(_(e_internal_error_str), where);\n}\n#endif\n\n// emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes.\n\n    void\nemsg_invreg(int name)\n{\n    semsg(_(e_invalid_register_name_str), transchar(name));\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Give an error message which contains %s for \"name[len]\".\n */\n    void\nemsg_namelen(char *msg, char_u *name, int len)\n{\n    char_u *copy = vim_strnsave((char_u *)name, len);\n\n    semsg(msg, copy == NULL ? \"NULL\" : (char *)copy);\n    vim_free(copy);\n}\n#endif\n\n/*\n * Like msg(), but truncate to a single line if p_shm contains 't', or when\n * \"force\" is TRUE.  This truncates in another way as for normal messages.\n * Careful: The string may be changed by msg_may_trunc()!\n * Returns a pointer to the printed message, if wait_return() not called.\n */\n    char *\nmsg_trunc_attr(char *s, int force, int attr)\n{\n    int\t\tn;\n    char\t*ts;\n\n    // Add message to history before truncating\n    add_msg_hist((char_u *)s, -1, attr);\n\n    ts = (char *)msg_may_trunc(force, (char_u *)s);\n\n    msg_hist_off = TRUE;\n    n = msg_attr(ts, attr);\n    msg_hist_off = FALSE;\n\n    if (n)\n\treturn ts;\n    return NULL;\n}\n\n/*\n * Check if message \"s\" should be truncated at the start (for filenames).\n * Return a pointer to where the truncated message starts.\n * Note: May change the message by replacing a character with '<'.\n */\n    char_u *\nmsg_may_trunc(int force, char_u *s)\n{\n    int\t\tn;\n    int\t\troom;\n\n    room = (int)(Rows - cmdline_row - 1) * Columns + sc_col - 1;\n    if ((force || (shortmess(SHM_TRUNC) && !exmode_active))\n\t    && (n = (int)STRLEN(s) - room) > 0)\n    {\n\tif (has_mbyte)\n\t{\n\t    int\tsize = vim_strsize(s);\n\n\t    // There may be room anyway when there are multibyte chars.\n\t    if (size <= room)\n\t\treturn s;\n\n\t    for (n = 0; size >= room; )\n\t    {\n\t\tsize -= (*mb_ptr2cells)(s + n);\n\t\tn += (*mb_ptr2len)(s + n);\n\t    }\n\t    --n;\n\t}\n\ts += n;\n\t*s = '<';\n    }\n    return s;\n}\n\n    static void\nadd_msg_hist(\n    char_u\t*s,\n    int\t\tlen,\t\t// -1 for undetermined length\n    int\t\tattr)\n{\n    struct msg_hist *p;\n\n    if (msg_hist_off || msg_silent != 0)\n\treturn;\n\n    // Don't let the message history get too big\n    while (msg_hist_len > MAX_MSG_HIST_LEN)\n\t(void)delete_first_msg();\n\n    // allocate an entry and add the message at the end of the history\n    p = ALLOC_ONE(struct msg_hist);\n    if (p != NULL)\n    {\n\tif (len < 0)\n\t    len = (int)STRLEN(s);\n\t// remove leading and trailing newlines\n\twhile (len > 0 && *s == '\\n')\n\t{\n\t    ++s;\n\t    --len;\n\t}\n\twhile (len > 0 && s[len - 1] == '\\n')\n\t    --len;\n\tp->msg = vim_strnsave(s, len);\n\tp->next = NULL;\n\tp->attr = attr;\n\tif (last_msg_hist != NULL)\n\t    last_msg_hist->next = p;\n\tlast_msg_hist = p;\n\tif (first_msg_hist == NULL)\n\t    first_msg_hist = last_msg_hist;\n\t++msg_hist_len;\n    }\n}\n\n/*\n * Delete the first (oldest) message from the history.\n * Returns FAIL if there are no messages.\n */\n    int\ndelete_first_msg(void)\n{\n    struct msg_hist *p;\n\n    if (msg_hist_len <= 0)\n\treturn FAIL;\n    p = first_msg_hist;\n    first_msg_hist = p->next;\n    if (first_msg_hist == NULL)\n\tlast_msg_hist = NULL;  // history is empty\n    vim_free(p->msg);\n    vim_free(p);\n    --msg_hist_len;\n    return OK;\n}\n\n/*\n * \":messages\" command.\n */\n    void\nex_messages(exarg_T *eap)\n{\n    struct msg_hist *p;\n    char_u\t    *s;\n    int\t\t    c = 0;\n\n    if (STRCMP(eap->arg, \"clear\") == 0)\n    {\n\tint keep = eap->addr_count == 0 ? 0 : eap->line2;\n\n\twhile (msg_hist_len > keep)\n\t    (void)delete_first_msg();\n\treturn;\n    }\n\n    if (*eap->arg != NUL)\n    {\n\temsg(_(e_invalid_argument));\n\treturn;\n    }\n\n    msg_hist_off = TRUE;\n\n    p = first_msg_hist;\n    if (eap->addr_count != 0)\n    {\n\t// Count total messages\n\tfor (; p != NULL && !got_int; p = p->next)\n\t    c++;\n\n\tc -= eap->line2;\n\n\t// Skip without number of messages specified\n\tfor (p = first_msg_hist; p != NULL && !got_int && c > 0;\n\t\t\t\t\t\t    p = p->next, c--);\n    }\n\n    if (p == first_msg_hist)\n    {\n#ifdef FEAT_MULTI_LANG\n\ts = get_mess_lang();\n#else\n\ts = mch_getenv((char_u *)\"LANG\");\n#endif\n\tif (s != NULL && *s != NUL)\n\t    // The next comment is extracted by xgettext and put in po file for\n\t    // translators to read.\n\t    msg_attr(\n\t\t    // Translator: Please replace the name and email address\n\t\t    // with the appropriate text for your translation.\n\t\t    _(\"Messages maintainer: Bram Moolenaar <Bram@vim.org>\"),\n\t\t    HL_ATTR(HLF_T));\n    }\n\n    // Display what was not skipped.\n    for (; p != NULL && !got_int; p = p->next)\n\tif (p->msg != NULL)\n\t    msg_attr((char *)p->msg, p->attr);\n\n    msg_hist_off = FALSE;\n}\n\n#if defined(FEAT_CON_DIALOG) || defined(FIND_REPLACE_DIALOG) || defined(PROTO)\n/*\n * Call this after prompting the user.  This will avoid a hit-return message\n * and a delay.\n */\n    void\nmsg_end_prompt(void)\n{\n    need_wait_return = FALSE;\n    emsg_on_display = FALSE;\n    cmdline_row = msg_row;\n    msg_col = 0;\n    msg_clr_eos();\n    lines_left = -1;\n}\n#endif\n\n/*\n * Wait for the user to hit a key (normally Enter).\n * If \"redraw\" is TRUE, clear and redraw the screen.\n * If \"redraw\" is FALSE, just redraw the screen.\n * If \"redraw\" is -1, don't redraw at all.\n */\n    void\nwait_return(int redraw)\n{\n    int\t\tc;\n    int\t\toldState;\n    int\t\ttmpState;\n    int\t\thad_got_int;\n    int\t\tsave_reg_recording;\n    FILE\t*save_scriptout;\n\n    if (redraw == TRUE)\n\tmust_redraw = CLEAR;\n\n    // If using \":silent cmd\", don't wait for a return.  Also don't set\n    // need_wait_return to do it later.\n    if (msg_silent != 0)\n\treturn;\n\n    /*\n     * When inside vgetc(), we can't wait for a typed character at all.\n     * With the global command (and some others) we only need one return at\n     * the end. Adjust cmdline_row to avoid the next message overwriting the\n     * last one.\n     */\n    if (vgetc_busy > 0)\n\treturn;\n    need_wait_return = TRUE;\n    if (no_wait_return)\n    {\n\tif (!exmode_active)\n\t    cmdline_row = msg_row;\n\treturn;\n    }\n\n    redir_off = TRUE;\t\t// don't redirect this message\n    oldState = State;\n    if (quit_more)\n    {\n\tc = CAR;\t\t// just pretend CR was hit\n\tquit_more = FALSE;\n\tgot_int = FALSE;\n    }\n    else if (exmode_active)\n    {\n\tmsg_puts(\" \");\t\t// make sure the cursor is on the right line\n\tc = CAR;\t\t// no need for a return in ex mode\n\tgot_int = FALSE;\n    }\n    else\n    {\n\t// Make sure the hit-return prompt is on screen when 'guioptions' was\n\t// just changed.\n\tscreenalloc(FALSE);\n\n\tState = HITRETURN;\n\tsetmouse();\n#ifdef USE_ON_FLY_SCROLL\n\tdont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\tcmdline_row = msg_row;\n\n\t// Avoid the sequence that the user types \":\" at the hit-return prompt\n\t// to start an Ex command, but the file-changed dialog gets in the\n\t// way.\n\tif (need_check_timestamps)\n\t    check_timestamps(FALSE);\n\n\thit_return_msg();\n\n\tdo\n\t{\n\t    // Remember \"got_int\", if it is set vgetc() probably returns a\n\t    // CTRL-C, but we need to loop then.\n\t    had_got_int = got_int;\n\n\t    // Don't do mappings here, we put the character back in the\n\t    // typeahead buffer.\n\t    ++no_mapping;\n\t    ++allow_keys;\n\n\t    // Temporarily disable Recording. If Recording is active, the\n\t    // character will be recorded later, since it will be added to the\n\t    // typebuf after the loop\n\t    save_reg_recording = reg_recording;\n\t    save_scriptout = scriptout;\n\t    reg_recording = 0;\n\t    scriptout = NULL;\n\t    c = safe_vgetc();\n\t    if (had_got_int && !global_busy)\n\t\tgot_int = FALSE;\n\t    --no_mapping;\n\t    --allow_keys;\n\t    reg_recording = save_reg_recording;\n\t    scriptout = save_scriptout;\n\n#ifdef FEAT_CLIPBOARD\n\t    // Strange way to allow copying (yanking) a modeless selection at\n\t    // the hit-enter prompt.  Use CTRL-Y, because the same is used in\n\t    // Cmdline-mode and it's harmless when there is no selection.\n\t    if (c == Ctrl_Y && clip_star.state == SELECT_DONE)\n\t    {\n\t\tclip_copy_modeless_selection(TRUE);\n\t\tc = K_IGNORE;\n\t    }\n#endif\n\n\t    /*\n\t     * Allow scrolling back in the messages.\n\t     * Also accept scroll-down commands when messages fill the screen,\n\t     * to avoid that typing one 'j' too many makes the messages\n\t     * disappear.\n\t     */\n\t    if (p_more && !p_cp)\n\t    {\n\t\tif (c == 'b' || c == 'k' || c == 'u' || c == 'g'\n\t\t\t\t\t\t|| c == K_UP || c == K_PAGEUP)\n\t\t{\n\t\t    if (msg_scrolled > Rows)\n\t\t\t// scroll back to show older messages\n\t\t\tdo_more_prompt(c);\n\t\t    else\n\t\t    {\n\t\t\tmsg_didout = FALSE;\n\t\t\tc = K_IGNORE;\n\t\t\tmsg_col =\n#ifdef FEAT_RIGHTLEFT\n\t\t\t    cmdmsg_rl ? Columns - 1 :\n#endif\n\t\t\t    0;\n\t\t    }\n\t\t    if (quit_more)\n\t\t    {\n\t\t\tc = CAR;\t\t// just pretend CR was hit\n\t\t\tquit_more = FALSE;\n\t\t\tgot_int = FALSE;\n\t\t    }\n\t\t    else if (c != K_IGNORE)\n\t\t    {\n\t\t\tc = K_IGNORE;\n\t\t\thit_return_msg();\n\t\t    }\n\t\t}\n\t\telse if (msg_scrolled > Rows - 2\n\t\t\t && (c == 'j' || c == 'd' || c == 'f'\n\t\t\t\t\t   || c == K_DOWN || c == K_PAGEDOWN))\n\t\t    c = K_IGNORE;\n\t    }\n\t} while ((had_got_int && c == Ctrl_C)\n\t\t\t\t|| c == K_IGNORE\n#ifdef FEAT_GUI\n\t\t\t\t|| c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR\n#endif\n\t\t\t\t|| c == K_LEFTDRAG   || c == K_LEFTRELEASE\n\t\t\t\t|| c == K_MIDDLEDRAG || c == K_MIDDLERELEASE\n\t\t\t\t|| c == K_RIGHTDRAG  || c == K_RIGHTRELEASE\n\t\t\t\t|| c == K_MOUSELEFT  || c == K_MOUSERIGHT\n\t\t\t\t|| c == K_MOUSEDOWN  || c == K_MOUSEUP\n\t\t\t\t|| c == K_MOUSEMOVE\n\t\t\t\t|| (!mouse_has(MOUSE_RETURN)\n\t\t\t\t    && mouse_row < msg_row\n\t\t\t\t    && (c == K_LEFTMOUSE\n\t\t\t\t\t|| c == K_MIDDLEMOUSE\n\t\t\t\t\t|| c == K_RIGHTMOUSE\n\t\t\t\t\t|| c == K_X1MOUSE\n\t\t\t\t\t|| c == K_X2MOUSE))\n\t\t\t\t);\n\tui_breakcheck();\n\t/*\n\t * Avoid that the mouse-up event causes visual mode to start.\n\t */\n\tif (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE\n\t\t\t\t\t  || c == K_X1MOUSE || c == K_X2MOUSE)\n\t    (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);\n\telse if (vim_strchr((char_u *)\"\\r\\n \", c) == NULL && c != Ctrl_C)\n\t{\n\t    // Put the character back in the typeahead buffer.  Don't use the\n\t    // stuff buffer, because lmaps wouldn't work.\n\t    ins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\t    do_redraw = TRUE;\t    // need a redraw even though there is\n\t\t\t\t    // typeahead\n\t}\n    }\n    redir_off = FALSE;\n\n    /*\n     * If the user hits ':', '?' or '/' we get a command line from the next\n     * line.\n     */\n    if (c == ':' || c == '?' || c == '/')\n    {\n\tif (!exmode_active)\n\t    cmdline_row = msg_row;\n\tskip_redraw = TRUE;\t    // skip redraw once\n\tdo_redraw = FALSE;\n#ifdef FEAT_TERMINAL\n\tskip_term_loop = TRUE;\n#endif\n    }\n\n    /*\n     * If the window size changed set_shellsize() will redraw the screen.\n     * Otherwise the screen is only redrawn if 'redraw' is set and no ':'\n     * typed.\n     */\n    tmpState = State;\n    State = oldState;\t\t    // restore State before set_shellsize\n    setmouse();\n    msg_check();\n\n#if defined(UNIX) || defined(VMS)\n    /*\n     * When switching screens, we need to output an extra newline on exit.\n     */\n    if (swapping_screen() && !termcap_active)\n\tnewline_on_exit = TRUE;\n#endif\n\n    need_wait_return = FALSE;\n    did_wait_return = TRUE;\n    emsg_on_display = FALSE;\t// can delete error message now\n    lines_left = -1;\t\t// reset lines_left at next msg_start()\n    reset_last_sourcing();\n    if (keep_msg != NULL && vim_strsize(keep_msg) >=\n\t\t\t\t  (Rows - cmdline_row - 1) * Columns + sc_col)\n\tVIM_CLEAR(keep_msg);\t    // don't redisplay message, it's too long\n\n    if (tmpState == SETWSIZE)\t    // got resize event while in vgetc()\n    {\n\tstarttermcap();\t\t    // start termcap before redrawing\n\tshell_resized();\n    }\n    else if (!skip_redraw\n\t    && (redraw == TRUE || (msg_scrolled != 0 && redraw != -1)))\n    {\n\tstarttermcap();\t\t    // start termcap before redrawing\n\tredraw_later(VALID);\n    }\n}\n\n/*\n * Write the hit-return prompt.\n */\n    static void\nhit_return_msg(void)\n{\n    int\t\tsave_p_more = p_more;\n\n    p_more = FALSE;\t// don't want to see this message when scrolling back\n    if (msg_didout)\t// start on a new line\n\tmsg_putchar('\\n');\n    if (got_int)\n\tmsg_puts(_(\"Interrupt: \"));\n\n    msg_puts_attr(_(\"Press ENTER or type command to continue\"), HL_ATTR(HLF_R));\n    if (!msg_use_printf())\n\tmsg_clr_eos();\n    p_more = save_p_more;\n}\n\n/*\n * Set \"keep_msg\" to \"s\".  Free the old value and check for NULL pointer.\n */\n    void\nset_keep_msg(char_u *s, int attr)\n{\n    vim_free(keep_msg);\n    if (s != NULL && msg_silent == 0)\n\tkeep_msg = vim_strsave(s);\n    else\n\tkeep_msg = NULL;\n    keep_msg_more = FALSE;\n    keep_msg_attr = attr;\n}\n\n#if defined(FEAT_TERMRESPONSE) || defined(PROTO)\n/*\n * If there currently is a message being displayed, set \"keep_msg\" to it, so\n * that it will be displayed again after redraw.\n */\n    void\nset_keep_msg_from_hist(void)\n{\n    if (keep_msg == NULL && last_msg_hist != NULL && msg_scrolled == 0\n\t\t\t\t\t\t\t  && (State & NORMAL))\n\tset_keep_msg(last_msg_hist->msg, last_msg_hist->attr);\n}\n#endif\n\n/*\n * Prepare for outputting characters in the command line.\n */\n    void\nmsg_start(void)\n{\n    int\t\tdid_return = FALSE;\n\n    if (!msg_silent)\n\tVIM_CLEAR(keep_msg);\n\n#ifdef FEAT_EVAL\n    if (need_clr_eos)\n    {\n\t// Halfway an \":echo\" command and getting an (error) message: clear\n\t// any text from the command.\n\tneed_clr_eos = FALSE;\n\tmsg_clr_eos();\n    }\n#endif\n\n    if (!msg_scroll && full_screen)\t// overwrite last message\n    {\n\tmsg_row = cmdline_row;\n\tmsg_col =\n#ifdef FEAT_RIGHTLEFT\n\t    cmdmsg_rl ? Columns - 1 :\n#endif\n\t    0;\n    }\n    else if (msg_didout)\t\t    // start message on next line\n    {\n\tmsg_putchar('\\n');\n\tdid_return = TRUE;\n\tif (exmode_active != EXMODE_NORMAL)\n\t    cmdline_row = msg_row;\n    }\n    if (!msg_didany || lines_left < 0)\n\tmsg_starthere();\n    if (msg_silent == 0)\n    {\n\tmsg_didout = FALSE;\t\t    // no output on current line yet\n\tcursor_off();\n    }\n\n    // when redirecting, may need to start a new line.\n    if (!did_return)\n\tredir_write((char_u *)\"\\n\", -1);\n}\n\n/*\n * Note that the current msg position is where messages start.\n */\n    void\nmsg_starthere(void)\n{\n    lines_left = cmdline_row;\n    msg_didany = FALSE;\n}\n\n    void\nmsg_putchar(int c)\n{\n    msg_putchar_attr(c, 0);\n}\n\n    void\nmsg_putchar_attr(int c, int attr)\n{\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (IS_SPECIAL(c))\n    {\n\tbuf[0] = K_SPECIAL;\n\tbuf[1] = K_SECOND(c);\n\tbuf[2] = K_THIRD(c);\n\tbuf[3] = NUL;\n    }\n    else\n\tbuf[(*mb_char2bytes)(c, buf)] = NUL;\n    msg_puts_attr((char *)buf, attr);\n}\n\n    void\nmsg_outnum(long n)\n{\n    char\tbuf[20];\n\n    sprintf(buf, \"%ld\", n);\n    msg_puts(buf);\n}\n\n    void\nmsg_home_replace(char_u *fname)\n{\n    msg_home_replace_attr(fname, 0);\n}\n\n#if defined(FEAT_FIND_ID) || defined(PROTO)\n    void\nmsg_home_replace_hl(char_u *fname)\n{\n    msg_home_replace_attr(fname, HL_ATTR(HLF_D));\n}\n#endif\n\n    static void\nmsg_home_replace_attr(char_u *fname, int attr)\n{\n    char_u\t*name;\n\n    name = home_replace_save(NULL, fname);\n    if (name != NULL)\n\tmsg_outtrans_attr(name, attr);\n    vim_free(name);\n}\n\n/*\n * Output 'len' characters in 'str' (including NULs) with translation\n * if 'len' is -1, output up to a NUL character.\n * Use attributes 'attr'.\n * Return the number of characters it takes on the screen.\n */\n    int\nmsg_outtrans(char_u *str)\n{\n    return msg_outtrans_attr(str, 0);\n}\n\n    int\nmsg_outtrans_attr(char_u *str, int attr)\n{\n    return msg_outtrans_len_attr(str, (int)STRLEN(str), attr);\n}\n\n    int\nmsg_outtrans_len(char_u *str, int len)\n{\n    return msg_outtrans_len_attr(str, len, 0);\n}\n\n/*\n * Output one character at \"p\".  Return pointer to the next character.\n * Handles multi-byte characters.\n */\n    char_u *\nmsg_outtrans_one(char_u *p, int attr)\n{\n    int\t\tl;\n\n    if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n    {\n\tmsg_outtrans_len_attr(p, l, attr);\n\treturn p + l;\n    }\n    msg_puts_attr((char *)transchar_byte(*p), attr);\n    return p + 1;\n}\n\n    int\nmsg_outtrans_len_attr(char_u *msgstr, int len, int attr)\n{\n    int\t\tretval = 0;\n    char_u\t*str = msgstr;\n    char_u\t*plain_start = msgstr;\n    char_u\t*s;\n    int\t\tmb_l;\n    int\t\tc;\n    int\t\tsave_got_int = got_int;\n\n    // Only quit when got_int was set in here.\n    got_int = FALSE;\n\n    // if MSG_HIST flag set, add message to history\n    if (attr & MSG_HIST)\n    {\n\tadd_msg_hist(str, len, attr);\n\tattr &= ~MSG_HIST;\n    }\n\n    // If the string starts with a composing character first draw a space on\n    // which the composing char can be drawn.\n    if (enc_utf8 && utf_iscomposing(utf_ptr2char(msgstr)))\n\tmsg_puts_attr(\" \", attr);\n\n    /*\n     * Go over the string.  Special characters are translated and printed.\n     * Normal characters are printed several at a time.\n     */\n    while (--len >= 0 && !got_int)\n    {\n\tif (enc_utf8)\n\t    // Don't include composing chars after the end.\n\t    mb_l = utfc_ptr2len_len(str, len + 1);\n\telse if (has_mbyte)\n\t    mb_l = (*mb_ptr2len)(str);\n\telse\n\t    mb_l = 1;\n\tif (has_mbyte && mb_l > 1)\n\t{\n\t    c = (*mb_ptr2char)(str);\n\t    if (vim_isprintc(c))\n\t\t// printable multi-byte char: count the cells.\n\t\tretval += (*mb_ptr2cells)(str);\n\t    else\n\t    {\n\t\t// unprintable multi-byte char: print the printable chars so\n\t\t// far and the translation of the unprintable char.\n\t\tif (str > plain_start)\n\t\t    msg_puts_attr_len((char *)plain_start,\n\t\t\t\t\t       (int)(str - plain_start), attr);\n\t\tplain_start = str + mb_l;\n\t\tmsg_puts_attr((char *)transchar(c),\n\t\t\t\t\t    attr == 0 ? HL_ATTR(HLF_8) : attr);\n\t\tretval += char2cells(c);\n\t    }\n\t    len -= mb_l - 1;\n\t    str += mb_l;\n\t}\n\telse\n\t{\n\t    s = transchar_byte(*str);\n\t    if (s[1] != NUL)\n\t    {\n\t\t// unprintable char: print the printable chars so far and the\n\t\t// translation of the unprintable char.\n\t\tif (str > plain_start)\n\t\t    msg_puts_attr_len((char *)plain_start,\n\t\t\t\t\t       (int)(str - plain_start), attr);\n\t\tplain_start = str + 1;\n\t\tmsg_puts_attr((char *)s, attr == 0 ? HL_ATTR(HLF_8) : attr);\n\t\tretval += (int)STRLEN(s);\n\t    }\n\t    else\n\t\t++retval;\n\t    ++str;\n\t}\n    }\n\n    if (str > plain_start && !got_int)\n\t// print the printable chars at the end\n\tmsg_puts_attr_len((char *)plain_start, (int)(str - plain_start), attr);\n\n    got_int |= save_got_int;\n\n    return retval;\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n    void\nmsg_make(char_u *arg)\n{\n    int\t    i;\n    static char_u *str = (char_u *)\"eeffoc\", *rs = (char_u *)\"Plon#dqg#vxjduB\";\n\n    arg = skipwhite(arg);\n    for (i = 5; *arg && i >= 0; --i)\n\tif (*arg++ != str[i])\n\t    break;\n    if (i < 0)\n    {\n\tmsg_putchar('\\n');\n\tfor (i = 0; rs[i]; ++i)\n\t    msg_putchar(rs[i] - 3);\n    }\n}\n#endif\n\n/*\n * Output the string 'str' up to a NUL character.\n * Return the number of characters it takes on the screen.\n *\n * If K_SPECIAL is encountered, then it is taken in conjunction with the\n * following character and shown as <F1>, <S-Up> etc.  Any other character\n * which is not printable shown in <> form.\n * If 'from' is TRUE (lhs of a mapping), a space is shown as <Space>.\n * If a character is displayed in one of these special ways, is also\n * highlighted (its highlight name is '8' in the p_hl variable).\n * Otherwise characters are not highlighted.\n * This function is used to show mappings, where we want to see how to type\n * the character/string -- webb\n */\n    int\nmsg_outtrans_special(\n    char_u\t*strstart,\n    int\t\tfrom,\t// TRUE for lhs of a mapping\n    int\t\tmaxlen) // screen columns, 0 for unlimited\n{\n    char_u\t*str = strstart;\n    int\t\tretval = 0;\n    char\t*text;\n    int\t\tattr;\n    int\t\tlen;\n\n    attr = HL_ATTR(HLF_8);\n    while (*str != NUL)\n    {\n\t// Leading and trailing spaces need to be displayed in <> form.\n\tif ((str == strstart || str[1] == NUL) && *str == ' ')\n\t{\n\t    text = \"<Space>\";\n\t    ++str;\n\t}\n\telse\n\t    text = (char *)str2special(&str, from);\n\tlen = vim_strsize((char_u *)text);\n\tif (maxlen > 0 && retval + len >= maxlen)\n\t    break;\n\t// Highlight special keys\n\tmsg_puts_attr(text, len > 1\n\t\t&& (*mb_ptr2len)((char_u *)text) <= 1 ? attr : 0);\n\tretval += len;\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the lhs or rhs of a mapping, with the key codes turned into printable\n * strings, in an allocated string.\n */\n    char_u *\nstr2special_save(\n    char_u  *str,\n    int\t    is_lhs)  // TRUE for lhs, FALSE for rhs\n{\n    garray_T\tga;\n    char_u\t*p = str;\n\n    ga_init2(&ga, 1, 40);\n    while (*p != NUL)\n\tga_concat(&ga, str2special(&p, is_lhs));\n    ga_append(&ga, NUL);\n    return (char_u *)ga.ga_data;\n}\n#endif\n\n/*\n * Return the printable string for the key codes at \"*sp\".\n * Used for translating the lhs or rhs of a mapping to printable chars.\n * Advances \"sp\" to the next code.\n */\n    char_u *\nstr2special(\n    char_u\t**sp,\n    int\t\tfrom)\t// TRUE for lhs of mapping\n{\n    int\t\t\tc;\n    static char_u\tbuf[7];\n    char_u\t\t*str = *sp;\n    int\t\t\tmodifiers = 0;\n    int\t\t\tspecial = FALSE;\n\n    if (has_mbyte)\n    {\n\tchar_u\t*p;\n\n\t// Try to un-escape a multi-byte character.  Return the un-escaped\n\t// string if it is a multi-byte character.\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    return p;\n    }\n\n    c = *str;\n    if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n    {\n\tif (str[1] == KS_MODIFIER)\n\t{\n\t    modifiers = str[2];\n\t    str += 3;\n\t    c = *str;\n\t}\n\tif (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(str[1], str[2]);\n\t    str += 2;\n\t}\n\tif (IS_SPECIAL(c) || modifiers)\t// special key\n\t    special = TRUE;\n    }\n\n    if (has_mbyte && !IS_SPECIAL(c))\n    {\n\tint len = (*mb_ptr2len)(str);\n\n\t// For multi-byte characters check for an illegal byte.\n\tif (has_mbyte && MB_BYTE2LEN(*str) > len)\n\t{\n\t    transchar_nonprint(curbuf, buf, c);\n\t    *sp = str + 1;\n\t    return buf;\n\t}\n\t// Since 'special' is TRUE the multi-byte character 'c' will be\n\t// processed by get_special_key_name()\n\tc = (*mb_ptr2char)(str);\n\t*sp = str + len;\n    }\n    else\n\t*sp = str + 1;\n\n    // Make unprintable characters in <> form, also <M-Space> and <Tab>.\n    // Use <Space> only for lhs of a mapping.\n    if (special || char2cells(c) > 1 || (from && c == ' '))\n\treturn get_special_key_name(c, modifiers);\n    buf[0] = c;\n    buf[1] = NUL;\n    return buf;\n}\n\n/*\n * Translate a key sequence into special key names.\n */\n    void\nstr2specialbuf(char_u *sp, char_u *buf, int len)\n{\n    char_u\t*s;\n\n    *buf = NUL;\n    while (*sp)\n    {\n\ts = str2special(&sp, FALSE);\n\tif ((int)(STRLEN(s) + STRLEN(buf)) < len)\n\t    STRCAT(buf, s);\n    }\n}\n\n/*\n * print line for :print or :list command\n */\n    void\nmsg_prt_line(char_u *s, int list)\n{\n    int\t\tc;\n    int\t\tcol = 0;\n    int\t\tn_extra = 0;\n    int\t\tc_extra = 0;\n    int\t\tc_final = 0;\n    char_u\t*p_extra = NULL;\t    // init to make SASC shut up\n    int\t\tn;\n    int\t\tattr = 0;\n    char_u\t*trail = NULL;\n    char_u\t*lead = NULL;\n    int\t\tin_multispace = FALSE;\n    int\t\tmultispace_pos = 0;\n    int\t\tl;\n    char_u\tbuf[MB_MAXBYTES + 1];\n\n    if (curwin->w_p_list)\n\tlist = TRUE;\n\n    if (list)\n    {\n\t// find start of trailing whitespace\n\tif (curwin->w_lcs_chars.trail)\n\t{\n\t    trail = s + STRLEN(s);\n\t    while (trail > s && VIM_ISWHITE(trail[-1]))\n\t\t--trail;\n\t}\n\t// find end of leading whitespace\n\tif (curwin->w_lcs_chars.lead)\n\t{\n\t    lead = s;\n\t    while (VIM_ISWHITE(lead[0]))\n\t\tlead++;\n\t    // in a line full of spaces all of them are treated as trailing\n\t    if (*lead == NUL)\n\t\tlead = NULL;\n\t}\n    }\n\n    // output a space for an empty line, otherwise the line will be\n    // overwritten\n    if (*s == NUL && !(list && curwin->w_lcs_chars.eol != NUL))\n\tmsg_putchar(' ');\n\n    while (!got_int)\n    {\n\tif (n_extra > 0)\n\t{\n\t    --n_extra;\n\t    if (n_extra == 0 && c_final)\n\t\tc = c_final;\n\t    else if (c_extra)\n\t\tc = c_extra;\n\t    else\n\t\tc = *p_extra++;\n\t}\n\telse if (has_mbyte && (l = (*mb_ptr2len)(s)) > 1)\n\t{\n\t    col += (*mb_ptr2cells)(s);\n\t    if (l >= MB_MAXBYTES)\n\t    {\n\t\tSTRCPY(buf, \"?\");\n\t    }\n\t    else if (curwin->w_lcs_chars.nbsp != NUL && list\n\t\t    && (mb_ptr2char(s) == 160\n\t\t\t|| mb_ptr2char(s) == 0x202f))\n\t    {\n\t\tmb_char2bytes(curwin->w_lcs_chars.nbsp, buf);\n\t\tbuf[(*mb_ptr2len)(buf)] = NUL;\n\t    }\n\t    else\n\t    {\n\t\tmch_memmove(buf, s, (size_t)l);\n\t\tbuf[l] = NUL;\n\t    }\n\t    msg_puts((char *)buf);\n\t    s += l;\n\t    continue;\n\t}\n\telse\n\t{\n\t    attr = 0;\n\t    c = *s++;\n\t    in_multispace = c == ' '\n\t\t&& ((col > 0 && s[-2] == ' ') || *s == ' ');\n\t    if (!in_multispace)\n\t\tmultispace_pos = 0;\n\t    if (c == TAB && (!list || curwin->w_lcs_chars.tab1))\n\t    {\n\t\t// tab amount depends on current column\n#ifdef FEAT_VARTABS\n\t\tn_extra = tabstop_padding(col, curbuf->b_p_ts,\n\t\t\t\t\t\t    curbuf->b_p_vts_array) - 1;\n#else\n\t\tn_extra = curbuf->b_p_ts - col % curbuf->b_p_ts - 1;\n#endif\n\t\tif (!list)\n\t\t{\n\t\t    c = ' ';\n\t\t    c_extra = ' ';\n\t\t    c_final = NUL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    c = (n_extra == 0 && curwin->w_lcs_chars.tab3)\n\t\t\t\t\t\t? curwin->w_lcs_chars.tab3\n\t\t\t\t\t\t: curwin->w_lcs_chars.tab1;\n\t\t    c_extra = curwin->w_lcs_chars.tab2;\n\t\t    c_final = curwin->w_lcs_chars.tab3;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t    }\n\t    else if (c == 160 && list && curwin->w_lcs_chars.nbsp != NUL)\n\t    {\n\t\tc = curwin->w_lcs_chars.nbsp;\n\t\tattr = HL_ATTR(HLF_8);\n\t    }\n\t    else if (c == NUL && list && curwin->w_lcs_chars.eol != NUL)\n\t    {\n\t\tp_extra = (char_u *)\"\";\n\t\tc_extra = NUL;\n\t\tc_final = NUL;\n\t\tn_extra = 1;\n\t\tc = curwin->w_lcs_chars.eol;\n\t\tattr = HL_ATTR(HLF_AT);\n\t\t--s;\n\t    }\n\t    else if (c != NUL && (n = byte2cells(c)) > 1)\n\t    {\n\t\tn_extra = n - 1;\n\t\tp_extra = transchar_byte(c);\n\t\tc_extra = NUL;\n\t\tc_final = NUL;\n\t\tc = *p_extra++;\n\t\t// Use special coloring to be able to distinguish <hex> from\n\t\t// the same in plain text.\n\t\tattr = HL_ATTR(HLF_8);\n\t    }\n\t    else if (c == ' ')\n\t    {\n\t\tif (lead != NULL && s <= lead)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.lead;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (trail != NULL && s > trail)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.trail;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (list && in_multispace\n\t\t\t&& curwin->w_lcs_chars.multispace != NULL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.multispace[multispace_pos++];\n\t\t    if (curwin->w_lcs_chars.multispace[multispace_pos] == NUL)\n\t\t\tmultispace_pos = 0;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t\telse if (list && curwin->w_lcs_chars.space != NUL)\n\t\t{\n\t\t    c = curwin->w_lcs_chars.space;\n\t\t    attr = HL_ATTR(HLF_8);\n\t\t}\n\t    }\n\t}\n\n\tif (c == NUL)\n\t    break;\n\n\tmsg_putchar_attr(c, attr);\n\tcol++;\n    }\n    msg_clr_eos();\n}\n\n/*\n * Use screen_puts() to output one multi-byte character.\n * Return the pointer \"s\" advanced to the next character.\n */\n    static char_u *\nscreen_puts_mbyte(char_u *s, int l, int attr)\n{\n    int\t\tcw;\n\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    cw = (*mb_ptr2cells)(s);\n    if (cw > 1 && (\n#ifdef FEAT_RIGHTLEFT\n\t\tcmdmsg_rl ? msg_col <= 1 :\n#endif\n\t\tmsg_col == Columns - 1))\n    {\n\t// Doesn't fit, print a highlighted '>' to fill it up.\n\tmsg_screen_putchar('>', HL_ATTR(HLF_AT));\n\treturn s;\n    }\n\n    screen_puts_len(s, l, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tmsg_col -= cw;\n\tif (msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tmsg_col += cw;\n\tif (msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n    return s + l;\n}\n\n/*\n * Output a string to the screen at position msg_row, msg_col.\n * Update msg_row and msg_col for the next message.\n */\n    void\nmsg_puts(char *s)\n{\n    msg_puts_attr(s, 0);\n}\n\n    void\nmsg_puts_title(char *s)\n{\n    msg_puts_attr(s, HL_ATTR(HLF_T));\n}\n\n/*\n * Show a message in such a way that it always fits in the line.  Cut out a\n * part in the middle and replace it with \"...\" when necessary.\n * Does not handle multi-byte characters!\n */\n    static void\nmsg_outtrans_long_len_attr(char_u *longstr, int len, int attr)\n{\n    int\t\tslen = len;\n    int\t\troom;\n\n    room = Columns - msg_col;\n    if (len > room && room >= 20)\n    {\n\tslen = (room - 3) / 2;\n\tmsg_outtrans_len_attr(longstr, slen, attr);\n\tmsg_puts_attr(\"...\", HL_ATTR(HLF_8));\n    }\n    msg_outtrans_len_attr(longstr + len - slen, slen, attr);\n}\n\n    void\nmsg_outtrans_long_attr(char_u *longstr, int attr)\n{\n    msg_outtrans_long_len_attr(longstr, (int)STRLEN(longstr), attr);\n}\n\n/*\n * Basic function for writing a message with highlight attributes.\n */\n    void\nmsg_puts_attr(char *s, int attr)\n{\n    msg_puts_attr_len(s, -1, attr);\n}\n\n/*\n * Like msg_puts_attr(), but with a maximum length \"maxlen\" (in bytes).\n * When \"maxlen\" is -1 there is no maximum length.\n * When \"maxlen\" is >= 0 the message is not put in the history.\n */\n    static void\nmsg_puts_attr_len(char *str, int maxlen, int attr)\n{\n    /*\n     * If redirection is on, also write to the redirection file.\n     */\n    redir_write((char_u *)str, maxlen);\n\n    /*\n     * Don't print anything when using \":silent cmd\".\n     */\n    if (msg_silent != 0)\n\treturn;\n\n    // if MSG_HIST flag set, add message to history\n    if ((attr & MSG_HIST) && maxlen < 0)\n    {\n\tadd_msg_hist((char_u *)str, -1, attr);\n\tattr &= ~MSG_HIST;\n    }\n\n    // When writing something to the screen after it has scrolled, requires a\n    // wait-return prompt later.  Needed when scrolling, resetting\n    // need_wait_return after some prompt, and then outputting something\n    // without scrolling\n    // Not needed when only using CR to move the cursor.\n    if (msg_scrolled != 0 && !msg_scrolled_ign && STRCMP(str, \"\\r\") != 0)\n\tneed_wait_return = TRUE;\n    msg_didany = TRUE;\t\t// remember that something was outputted\n\n    /*\n     * If there is no valid screen, use fprintf so we can see error messages.\n     * If termcap is not active, we may be writing in an alternate console\n     * window, cursor positioning may not work correctly (window size may be\n     * different, e.g. for Win32 console) or we just don't know where the\n     * cursor is.\n     */\n    if (msg_use_printf())\n\tmsg_puts_printf((char_u *)str, maxlen);\n    else\n\tmsg_puts_display((char_u *)str, maxlen, attr, FALSE);\n}\n\n/*\n * The display part of msg_puts_attr_len().\n * May be called recursively to display scroll-back text.\n */\n    static void\nmsg_puts_display(\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tattr,\n    int\t\trecurse)\n{\n    char_u\t*s = str;\n    char_u\t*t_s = str;\t// string from \"t_s\" to \"s\" is still todo\n    int\t\tt_col = 0;\t// screen cells todo, 0 when \"t_s\" not used\n    int\t\tl;\n    int\t\tcw;\n    char_u\t*sb_str = str;\n    int\t\tsb_col = msg_col;\n    int\t\twrap;\n    int\t\tdid_last_char;\n\n    did_wait_return = FALSE;\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\t/*\n\t * We are at the end of the screen line when:\n\t * - When outputting a newline.\n\t * - When outputting a character in the last column.\n\t */\n\tif (!recurse && msg_row >= Rows - 1 && (*s == '\\n' || (\n#ifdef FEAT_RIGHTLEFT\n\t\t    cmdmsg_rl\n\t\t    ? (\n\t\t\tmsg_col <= 1\n\t\t      || (*s == TAB && msg_col <= 7)\n\t\t      || (has_mbyte && (*mb_ptr2cells)(s) > 1 && msg_col <= 2))\n\t\t    :\n#endif\n\t\t      ((*s != '\\r' && msg_col + t_col >= Columns - 1)\n\t\t       || (*s == TAB && msg_col + t_col >= ((Columns - 1) & ~7))\n\t\t       || (has_mbyte && (*mb_ptr2cells)(s) > 1\n\t\t\t\t\t && msg_col + t_col >= Columns - 2)))))\n\t{\n\t    /*\n\t     * The screen is scrolled up when at the last row (some terminals\n\t     * scroll automatically, some don't.  To avoid problems we scroll\n\t     * ourselves).\n\t     */\n\t    if (t_col > 0)\n\t\t// output postponed text\n\t\tt_puts(&t_col, t_s, s, attr);\n\n\t    // When no more prompt and no more room, truncate here\n\t    if (msg_no_more && lines_left == 0)\n\t\tbreak;\n\n\t    // Scroll the screen up one line.\n\t    msg_scroll_up();\n\n\t    msg_row = Rows - 2;\n\t    if (msg_col >= Columns)\t// can happen after screen resize\n\t\tmsg_col = Columns - 1;\n\n\t    // Display char in last column before showing more-prompt.\n\t    if (*s >= ' '\n#ifdef FEAT_RIGHTLEFT\n\t\t    && !cmdmsg_rl\n#endif\n\t       )\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    if (enc_utf8 && maxlen >= 0)\n\t\t\t// avoid including composing chars after the end\n\t\t\tl = utfc_ptr2len_len(s, (int)((str + maxlen) - s));\n\t\t    else\n\t\t\tl = (*mb_ptr2len)(s);\n\t\t    s = screen_puts_mbyte(s, l, attr);\n\t\t}\n\t\telse\n\t\t    msg_screen_putchar(*s++, attr);\n\t\tdid_last_char = TRUE;\n\t    }\n\t    else\n\t\tdid_last_char = FALSE;\n\n\t    if (p_more)\n\t\t// store text for scrolling back\n\t\tstore_sb_text(&sb_str, s, attr, &sb_col, TRUE);\n\n\t    inc_msg_scrolled();\n\t    need_wait_return = TRUE; // may need wait_return in main()\n\t    redraw_cmdline = TRUE;\n\t    if (cmdline_row > 0 && !exmode_active)\n\t\t--cmdline_row;\n\n\t    /*\n\t     * If screen is completely filled and 'more' is set then wait\n\t     * for a character.\n\t     */\n\t    if (lines_left > 0)\n\t\t--lines_left;\n\t    if (p_more && lines_left == 0 && State != HITRETURN\n\t\t\t\t\t    && !msg_no_more && !exmode_active)\n\t    {\n#ifdef FEAT_CON_DIALOG\n\t\tif (do_more_prompt(NUL))\n\t\t    s = confirm_msg_tail;\n#else\n\t\t(void)do_more_prompt(NUL);\n#endif\n\t\tif (quit_more)\n\t\t    return;\n\t    }\n\n\t    // When we displayed a char in last column need to check if there\n\t    // is still more.\n\t    if (did_last_char)\n\t\tcontinue;\n\t}\n\n\twrap = *s == '\\n'\n\t\t    || msg_col + t_col >= Columns\n\t\t    || (has_mbyte && (*mb_ptr2cells)(s) > 1\n\t\t\t\t\t    && msg_col + t_col >= Columns - 1);\n\tif (t_col > 0 && (wrap || *s == '\\r' || *s == '\\b'\n\t\t\t\t\t\t || *s == '\\t' || *s == BELL))\n\t    // output any postponed text\n\t    t_puts(&t_col, t_s, s, attr);\n\n\tif (wrap && p_more && !recurse)\n\t    // store text for scrolling back\n\t    store_sb_text(&sb_str, s, attr, &sb_col, TRUE);\n\n\tif (*s == '\\n')\t\t    // go to next line\n\t{\n\t    msg_didout = FALSE;\t    // remember that line is empty\n#ifdef FEAT_RIGHTLEFT\n\t    if (cmdmsg_rl)\n\t\tmsg_col = Columns - 1;\n\t    else\n#endif\n\t\tmsg_col = 0;\n\t    if (++msg_row >= Rows)  // safety check\n\t\tmsg_row = Rows - 1;\n\t}\n\telse if (*s == '\\r')\t    // go to column 0\n\t{\n\t    msg_col = 0;\n\t}\n\telse if (*s == '\\b')\t    // go to previous char\n\t{\n\t    if (msg_col)\n\t\t--msg_col;\n\t}\n\telse if (*s == TAB)\t    // translate Tab into spaces\n\t{\n\t    do\n\t\tmsg_screen_putchar(' ', attr);\n\t    while (msg_col & 7);\n\t}\n\telse if (*s == BELL)\t\t// beep (from \":sh\")\n\t    vim_beep(BO_SH);\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tcw = (*mb_ptr2cells)(s);\n\t\tif (enc_utf8 && maxlen >= 0)\n\t\t    // avoid including composing chars after the end\n\t\t    l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));\n\t\telse\n\t\t    l = (*mb_ptr2len)(s);\n\t    }\n\t    else\n\t    {\n\t\tcw = 1;\n\t\tl = 1;\n\t    }\n\n\t    // When drawing from right to left or when a double-wide character\n\t    // doesn't fit, draw a single character here.  Otherwise collect\n\t    // characters and draw them all at once later.\n\t    if (\n# ifdef FEAT_RIGHTLEFT\n\t\t    cmdmsg_rl ||\n# endif\n\t\t    (cw > 1 && msg_col + t_col >= Columns - 1))\n\t    {\n\t\tif (l > 1)\n\t\t    s = screen_puts_mbyte(s, l, attr) - 1;\n\t\telse\n\t\t    msg_screen_putchar(*s, attr);\n\t    }\n\t    else\n\t    {\n\t\t// postpone this character until later\n\t\tif (t_col == 0)\n\t\t    t_s = s;\n\t\tt_col += cw;\n\t\ts += l - 1;\n\t    }\n\t}\n\t++s;\n    }\n\n    // output any postponed text\n    if (t_col > 0)\n\tt_puts(&t_col, t_s, s, attr);\n    if (p_more && !recurse)\n\tstore_sb_text(&sb_str, s, attr, &sb_col, FALSE);\n\n    msg_check();\n}\n\n/*\n * Return TRUE when \":filter pattern\" was used and \"msg\" does not match\n * \"pattern\".\n */\n    int\nmessage_filtered(char_u *msg)\n{\n    int match;\n\n    if (cmdmod.cmod_filter_regmatch.regprog == NULL)\n\treturn FALSE;\n    match = vim_regexec(&cmdmod.cmod_filter_regmatch, msg, (colnr_T)0);\n    return cmdmod.cmod_filter_force ? match : !match;\n}\n\n/*\n * Scroll the screen up one line for displaying the next message line.\n */\n    static void\nmsg_scroll_up(void)\n{\n#ifdef FEAT_GUI\n    // Remove the cursor before scrolling, ScreenLines[] is going\n    // to become invalid.\n    if (gui.in_use)\n\tgui_undraw_cursor();\n#endif\n    // scrolling up always works\n    mch_disable_flush();\n    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);\n    mch_enable_flush();\n\n    if (!can_clear((char_u *)\" \"))\n    {\n\t// Scrolling up doesn't result in the right background.  Set the\n\t// background here.  It's not efficient, but avoids that we have to do\n\t// it all over the code.\n\tscreen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\n\t// Also clear the last char of the last but one line if it was not\n\t// cleared before to avoid a scroll-up.\n\tif (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)\n\t    screen_fill((int)Rows - 2, (int)Rows - 1,\n\t\t\t\t (int)Columns - 1, (int)Columns, ' ', ' ', 0);\n    }\n}\n\n/*\n * Increment \"msg_scrolled\".\n */\n    static void\ninc_msg_scrolled(void)\n{\n#ifdef FEAT_EVAL\n    if (*get_vim_var_str(VV_SCROLLSTART) == NUL)\n    {\n\tchar_u\t    *p = SOURCING_NAME;\n\tchar_u\t    *tofree = NULL;\n\tint\t    len;\n\n\t// v:scrollstart is empty, set it to the script/function name and line\n\t// number\n\tif (p == NULL)\n\t    p = (char_u *)_(\"Unknown\");\n\telse\n\t{\n\t    len = (int)STRLEN(p) + 40;\n\t    tofree = alloc(len);\n\t    if (tofree != NULL)\n\t    {\n\t\tvim_snprintf((char *)tofree, len, _(\"%s line %ld\"),\n\t\t\t\t\t\t      p, (long)SOURCING_LNUM);\n\t\tp = tofree;\n\t    }\n\t}\n\tset_vim_var_string(VV_SCROLLSTART, p, -1);\n\tvim_free(tofree);\n    }\n#endif\n    ++msg_scrolled;\n    if (must_redraw < VALID)\n\tmust_redraw = VALID;\n}\n\n/*\n * To be able to scroll back at the \"more\" and \"hit-enter\" prompts we need to\n * store the displayed text and remember where screen lines start.\n */\ntypedef struct msgchunk_S msgchunk_T;\nstruct msgchunk_S\n{\n    msgchunk_T\t*sb_next;\n    msgchunk_T\t*sb_prev;\n    char\tsb_eol;\t\t// TRUE when line ends after this text\n    int\t\tsb_msg_col;\t// column in which text starts\n    int\t\tsb_attr;\t// text attributes\n    char_u\tsb_text[1];\t// text to be displayed, actually longer\n};\n\nstatic msgchunk_T *last_msgchunk = NULL; // last displayed text\n\nstatic msgchunk_T *msg_sb_start(msgchunk_T *mps);\n\ntypedef enum {\n    SB_CLEAR_NONE = 0,\n    SB_CLEAR_ALL,\n    SB_CLEAR_CMDLINE_BUSY,\n    SB_CLEAR_CMDLINE_DONE\n} sb_clear_T;\n\n// When to clear text on next msg.\nstatic sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;\n\n/*\n * Store part of a printed message for displaying when scrolling back.\n */\n    static void\nstore_sb_text(\n    char_u\t**sb_str,\t// start of string\n    char_u\t*s,\t\t// just after string\n    int\t\tattr,\n    int\t\t*sb_col,\n    int\t\tfinish)\t\t// line ends\n{\n    msgchunk_T\t*mp;\n\n    if (do_clear_sb_text == SB_CLEAR_ALL\n\t    || do_clear_sb_text == SB_CLEAR_CMDLINE_DONE)\n    {\n\tclear_sb_text(do_clear_sb_text == SB_CLEAR_ALL);\n\tdo_clear_sb_text = SB_CLEAR_NONE;\n    }\n\n    if (s > *sb_str)\n    {\n\tmp = alloc(sizeof(msgchunk_T) + (s - *sb_str));\n\tif (mp != NULL)\n\t{\n\t    mp->sb_eol = finish;\n\t    mp->sb_msg_col = *sb_col;\n\t    mp->sb_attr = attr;\n\t    vim_strncpy(mp->sb_text, *sb_str, s - *sb_str);\n\n\t    if (last_msgchunk == NULL)\n\t    {\n\t\tlast_msgchunk = mp;\n\t\tmp->sb_prev = NULL;\n\t    }\n\t    else\n\t    {\n\t\tmp->sb_prev = last_msgchunk;\n\t\tlast_msgchunk->sb_next = mp;\n\t\tlast_msgchunk = mp;\n\t    }\n\t    mp->sb_next = NULL;\n\t}\n    }\n    else if (finish && last_msgchunk != NULL)\n\tlast_msgchunk->sb_eol = TRUE;\n\n    *sb_str = s;\n    *sb_col = 0;\n}\n\n/*\n * Finished showing messages, clear the scroll-back text on the next message.\n */\n    void\nmay_clear_sb_text(void)\n{\n    do_clear_sb_text = SB_CLEAR_ALL;\n}\n\n/*\n * Starting to edit the command line, do not clear messages now.\n */\n    void\nsb_text_start_cmdline(void)\n{\n    do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;\n    msg_sb_eol();\n}\n\n/*\n * Ending to edit the command line.  Clear old lines but the last one later.\n */\n    void\nsb_text_end_cmdline(void)\n{\n    do_clear_sb_text = SB_CLEAR_CMDLINE_DONE;\n}\n\n/*\n * Clear any text remembered for scrolling back.\n * When \"all\" is FALSE keep the last line.\n * Called when redrawing the screen.\n */\n    void\nclear_sb_text(int all)\n{\n    msgchunk_T\t*mp;\n    msgchunk_T\t**lastp;\n\n    if (all)\n\tlastp = &last_msgchunk;\n    else\n    {\n\tif (last_msgchunk == NULL)\n\t    return;\n\tlastp = &last_msgchunk->sb_prev;\n    }\n\n    while (*lastp != NULL)\n    {\n\tmp = (*lastp)->sb_prev;\n\tvim_free(*lastp);\n\t*lastp = mp;\n    }\n}\n\n/*\n * \"g<\" command.\n */\n    void\nshow_sb_text(void)\n{\n    msgchunk_T\t*mp;\n\n    // Only show something if there is more than one line, otherwise it looks\n    // weird, typing a command without output results in one line.\n    mp = msg_sb_start(last_msgchunk);\n    if (mp == NULL || mp->sb_prev == NULL)\n\tvim_beep(BO_MESS);\n    else\n    {\n\tdo_more_prompt('G');\n\twait_return(FALSE);\n    }\n}\n\n/*\n * Move to the start of screen line in already displayed text.\n */\n    static msgchunk_T *\nmsg_sb_start(msgchunk_T *mps)\n{\n    msgchunk_T *mp = mps;\n\n    while (mp != NULL && mp->sb_prev != NULL && !mp->sb_prev->sb_eol)\n\tmp = mp->sb_prev;\n    return mp;\n}\n\n/*\n * Mark the last message chunk as finishing the line.\n */\n    void\nmsg_sb_eol(void)\n{\n    if (last_msgchunk != NULL)\n\tlast_msgchunk->sb_eol = TRUE;\n}\n\n/*\n * Display a screen line from previously displayed text at row \"row\".\n * Returns a pointer to the text for the next line (can be NULL).\n */\n    static msgchunk_T *\ndisp_sb_line(int row, msgchunk_T *smp)\n{\n    msgchunk_T\t*mp = smp;\n    char_u\t*p;\n\n    for (;;)\n    {\n\tmsg_row = row;\n\tmsg_col = mp->sb_msg_col;\n\tp = mp->sb_text;\n\tif (*p == '\\n')\t    // don't display the line break\n\t    ++p;\n\tmsg_puts_display(p, -1, mp->sb_attr, TRUE);\n\tif (mp->sb_eol || mp->sb_next == NULL)\n\t    break;\n\tmp = mp->sb_next;\n    }\n    return mp->sb_next;\n}\n\n/*\n * Output any postponed text for msg_puts_attr_len().\n */\n    static void\nt_puts(\n    int\t\t*t_col,\n    char_u\t*t_s,\n    char_u\t*s,\n    int\t\tattr)\n{\n    // output postponed text\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_puts_len(t_s, (int)(s - t_s), msg_row, msg_col, attr);\n    msg_col += *t_col;\n    *t_col = 0;\n    // If the string starts with a composing character don't increment the\n    // column position for it.\n    if (enc_utf8 && utf_iscomposing(utf_ptr2char(t_s)))\n\t--msg_col;\n    if (msg_col >= Columns)\n    {\n\tmsg_col = 0;\n\t++msg_row;\n    }\n}\n\n/*\n * Returns TRUE when messages should be printed with mch_errmsg().\n * This is used when there is no valid screen, so we can see error messages.\n * If termcap is not active, we may be writing in an alternate console\n * window, cursor positioning may not work correctly (window size may be\n * different, e.g. for Win32 console) or we just don't know where the\n * cursor is.\n */\n    int\nmsg_use_printf(void)\n{\n    return (!msg_check_screen()\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\t    || (!gui.in_use && !termcap_active)\n# else\n\t    || !termcap_active\n# endif\n#endif\n\t    || (swapping_screen() && !termcap_active)\n\t       );\n}\n\n/*\n * Print a message when there is no valid screen.\n */\n    static void\nmsg_puts_printf(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    char_u\t*buf = NULL;\n    char_u\t*p = s;\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_COOK);\t// handle CR and NL correctly\n#endif\n    while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)\n    {\n\tif (!(silent_mode && p_verbose == 0))\n\t{\n\t    // NL --> CR NL translation (for Unix, not for \"--version\")\n\t    if (*s == NL)\n\t    {\n\t\tint n = (int)(s - p);\n\n\t\tbuf = alloc(n + 3);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    memcpy(buf, p, n);\n\t\t    if (!info_message)\n\t\t\tbuf[n++] = CAR;\n\t\t    buf[n++] = NL;\n\t\t    buf[n++] = NUL;\n\t\t    if (info_message)   // informative message, not an error\n\t\t\tmch_msg((char *)buf);\n\t\t    else\n\t\t\tmch_errmsg((char *)buf);\n\t\t    vim_free(buf);\n\t\t}\n\t\tp = s + 1;\n\t    }\n\t}\n\n\t// primitive way to compute the current column\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = Columns - 1;\n\t    else\n\t\t--msg_col;\n\t}\n\telse\n#endif\n\t{\n\t    if (*s == CAR || *s == NL)\n\t\tmsg_col = 0;\n\t    else\n\t\t++msg_col;\n\t}\n\t++s;\n    }\n\n    if (*p != NUL && !(silent_mode && p_verbose == 0))\n    {\n\tchar_u *tofree = NULL;\n\n\tif (maxlen > 0 && STRLEN(p) > (size_t)maxlen)\n\t{\n\t    tofree = vim_strnsave(p, (size_t)maxlen);\n\t    p = tofree;\n\t}\n\tif (p != NULL)\n\t{\n\t    if (info_message)\n\t\tmch_msg((char *)p);\n\t    else\n\t\tmch_errmsg((char *)p);\n\t    vim_free(tofree);\n\t}\n    }\n\n    msg_didout = TRUE;\t    // assume that line is not empty\n\n#ifdef MSWIN\n    if (!(silent_mode && p_verbose == 0))\n\tmch_settmode(TMODE_RAW);\n#endif\n}\n\n/*\n * Show the more-prompt and handle the user response.\n * This takes care of scrolling back and displaying previously displayed text.\n * When at hit-enter prompt \"typed_char\" is the already typed character,\n * otherwise it's NUL.\n * Returns TRUE when jumping ahead to \"confirm_msg_tail\".\n */\n    static int\ndo_more_prompt(int typed_char)\n{\n    static int\tentered = FALSE;\n    int\t\tused_typed_char = typed_char;\n    int\t\toldState = State;\n    int\t\tc;\n#ifdef FEAT_CON_DIALOG\n    int\t\tretval = FALSE;\n#endif\n    int\t\ttoscroll;\n    msgchunk_T\t*mp_last = NULL;\n    msgchunk_T\t*mp;\n    int\t\ti;\n\n    // We get called recursively when a timer callback outputs a message. In\n    // that case don't show another prompt. Also when at the hit-Enter prompt\n    // and nothing was typed.\n    if (entered || (State == HITRETURN && typed_char == 0))\n\treturn FALSE;\n    entered = TRUE;\n\n    if (typed_char == 'G')\n    {\n\t// \"g<\": Find first line on the last page.\n\tmp_last = msg_sb_start(last_msgchunk);\n\tfor (i = 0; i < Rows - 2 && mp_last != NULL\n\t\t\t\t\t     && mp_last->sb_prev != NULL; ++i)\n\t    mp_last = msg_sb_start(mp_last->sb_prev);\n    }\n\n    State = ASKMORE;\n    setmouse();\n    if (typed_char == NUL)\n\tmsg_moremsg(FALSE);\n    for (;;)\n    {\n\t/*\n\t * Get a typed character directly from the user.\n\t */\n\tif (used_typed_char != NUL)\n\t{\n\t    c = used_typed_char;\t// was typed at hit-enter prompt\n\t    used_typed_char = NUL;\n\t}\n\telse\n\t    c = get_keystroke();\n\n#if defined(FEAT_MENU) && defined(FEAT_GUI)\n\tif (c == K_MENU)\n\t{\n\t    int idx = get_menu_index(current_menu, ASKMORE);\n\n\t    // Used a menu.  If it starts with CTRL-Y, it must\n\t    // be a \"Copy\" for the clipboard.  Otherwise\n\t    // assume that we end\n\t    if (idx == MENU_INDEX_INVALID)\n\t\tcontinue;\n\t    c = *current_menu->strings[idx];\n\t    if (c != NUL && current_menu->strings[idx][1] != NUL)\n\t\tins_typebuf(current_menu->strings[idx] + 1,\n\t\t\t\tcurrent_menu->noremap[idx], 0, TRUE,\n\t\t\t\t\t\t   current_menu->silent[idx]);\n\t}\n#endif\n\n\ttoscroll = 0;\n\tswitch (c)\n\t{\n\tcase BS:\t\t// scroll one line back\n\tcase K_BS:\n\tcase 'k':\n\tcase K_UP:\n\t    toscroll = -1;\n\t    break;\n\n\tcase CAR:\t\t// one extra line\n\tcase NL:\n\tcase 'j':\n\tcase K_DOWN:\n\t    toscroll = 1;\n\t    break;\n\n\tcase 'u':\t\t// Up half a page\n\t    toscroll = -(Rows / 2);\n\t    break;\n\n\tcase 'd':\t\t// Down half a page\n\t    toscroll = Rows / 2;\n\t    break;\n\n\tcase 'b':\t\t// one page back\n\tcase K_PAGEUP:\n\t    toscroll = -(Rows - 1);\n\t    break;\n\n\tcase ' ':\t\t// one extra page\n\tcase 'f':\n\tcase K_PAGEDOWN:\n\tcase K_LEFTMOUSE:\n\t    toscroll = Rows - 1;\n\t    break;\n\n\tcase 'g':\t\t// all the way back to the start\n\t    toscroll = -999999;\n\t    break;\n\n\tcase 'G':\t\t// all the way to the end\n\t    toscroll = 999999;\n\t    lines_left = 999999;\n\t    break;\n\n\tcase ':':\t\t// start new command line\n#ifdef FEAT_CON_DIALOG\n\t    if (!confirm_msg_used)\n#endif\n\t    {\n\t\t// Since got_int is set all typeahead will be flushed, but we\n\t\t// want to keep this ':', remember that in a special way.\n\t\ttypeahead_noflush(':');\n#ifdef FEAT_TERMINAL\n\t\tskip_term_loop = TRUE;\n#endif\n\t\tcmdline_row = Rows - 1;\t\t// put ':' on this line\n\t\tskip_redraw = TRUE;\t\t// skip redraw once\n\t\tneed_wait_return = FALSE;\t// don't wait in main()\n\t    }\n\t    // FALLTHROUGH\n\tcase 'q':\t\t// quit\n\tcase Ctrl_C:\n\tcase ESC:\n#ifdef FEAT_CON_DIALOG\n\t    if (confirm_msg_used)\n\t    {\n\t\t// Jump to the choices of the dialog.\n\t\tretval = TRUE;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tgot_int = TRUE;\n\t\tquit_more = TRUE;\n\t    }\n\t    // When there is some more output (wrapping line) display that\n\t    // without another prompt.\n\t    lines_left = Rows - 1;\n\t    break;\n\n#ifdef FEAT_CLIPBOARD\n\tcase Ctrl_Y:\n\t    // Strange way to allow copying (yanking) a modeless\n\t    // selection at the more prompt.  Use CTRL-Y,\n\t    // because the same is used in Cmdline-mode and at the\n\t    // hit-enter prompt.  However, scrolling one line up\n\t    // might be expected...\n\t    if (clip_star.state == SELECT_DONE)\n\t\tclip_copy_modeless_selection(TRUE);\n\t    continue;\n#endif\n\tdefault:\t\t// no valid response\n\t    msg_moremsg(TRUE);\n\t    continue;\n\t}\n\n\tif (toscroll != 0)\n\t{\n\t    if (toscroll < 0)\n\t    {\n\t\t// go to start of last line\n\t\tif (mp_last == NULL)\n\t\t    mp = msg_sb_start(last_msgchunk);\n\t\telse if (mp_last->sb_prev != NULL)\n\t\t    mp = msg_sb_start(mp_last->sb_prev);\n\t\telse\n\t\t    mp = NULL;\n\n\t\t// go to start of line at top of the screen\n\t\tfor (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;\n\t\t\t\t\t\t\t\t\t  ++i)\n\t\t    mp = msg_sb_start(mp->sb_prev);\n\n\t\tif (mp != NULL && mp->sb_prev != NULL)\n\t\t{\n\t\t    // Find line to be displayed at top.\n\t\t    for (i = 0; i > toscroll; --i)\n\t\t    {\n\t\t\tif (mp == NULL || mp->sb_prev == NULL)\n\t\t\t    break;\n\t\t\tmp = msg_sb_start(mp->sb_prev);\n\t\t\tif (mp_last == NULL)\n\t\t\t    mp_last = msg_sb_start(last_msgchunk);\n\t\t\telse\n\t\t\t    mp_last = msg_sb_start(mp_last->sb_prev);\n\t\t    }\n\n\t\t    if (toscroll == -1 && screen_ins_lines(0, 0, 1,\n\t\t\t\t\t\t     (int)Rows, 0, NULL) == OK)\n\t\t    {\n\t\t\t// display line at top\n\t\t\t(void)disp_sb_line(0, mp);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// redisplay all lines\n\t\t\tscreenclear();\n\t\t\tfor (i = 0; mp != NULL && i < Rows - 1; ++i)\n\t\t\t{\n\t\t\t    mp = disp_sb_line(i, mp);\n\t\t\t    ++msg_scrolled;\n\t\t\t}\n\t\t    }\n\t\t    toscroll = 0;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// First display any text that we scrolled back.\n\t\twhile (toscroll > 0 && mp_last != NULL)\n\t\t{\n\t\t    // scroll up, display line at bottom\n\t\t    msg_scroll_up();\n\t\t    inc_msg_scrolled();\n\t\t    screen_fill((int)Rows - 2, (int)Rows - 1, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t\t    mp_last = disp_sb_line((int)Rows - 2, mp_last);\n\t\t    --toscroll;\n\t\t}\n\t    }\n\n\t    if (toscroll <= 0)\n\t    {\n\t\t// displayed the requested text, more prompt again\n\t\tscreen_fill((int)Rows - 1, (int)Rows, 0,\n\t\t\t\t\t\t   (int)Columns, ' ', ' ', 0);\n\t\tmsg_moremsg(FALSE);\n\t\tcontinue;\n\t    }\n\n\t    // display more text, return to caller\n\t    lines_left = toscroll;\n\t}\n\n\tbreak;\n    }\n\n    // clear the --more-- message\n    screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n    State = oldState;\n    setmouse();\n    if (quit_more)\n    {\n\tmsg_row = Rows - 1;\n\tmsg_col = 0;\n    }\n#ifdef FEAT_RIGHTLEFT\n    else if (cmdmsg_rl)\n\tmsg_col = Columns - 1;\n#endif\n\n    entered = FALSE;\n#ifdef FEAT_CON_DIALOG\n    return retval;\n#else\n    return FALSE;\n#endif\n}\n\n#if defined(USE_MCH_ERRMSG) || defined(PROTO)\n\n#ifdef mch_errmsg\n# undef mch_errmsg\n#endif\n#ifdef mch_msg\n# undef mch_msg\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n    static void\nmch_errmsg_c(char *str)\n{\n    int\t    len = (int)STRLEN(str);\n    DWORD   nwrite = 0;\n    DWORD   mode = 0;\n    HANDLE  h = GetStdHandle(STD_ERROR_HANDLE);\n\n    if (GetConsoleMode(h, &mode) && enc_codepage >= 0\n\t    && (int)GetConsoleCP() != enc_codepage)\n    {\n\tWCHAR\t*w = enc_to_utf16((char_u *)str, &len);\n\n\tWriteConsoleW(h, w, len, &nwrite, NULL);\n\tvim_free(w);\n    }\n    else\n    {\n\tfprintf(stderr, \"%s\", str);\n    }\n}\n#endif\n\n/*\n * Give an error message.  To be used when the screen hasn't been initialized\n * yet.  When stderr can't be used, collect error messages until the GUI has\n * started and they can be displayed in a message box.\n */\n    void\nmch_errmsg(char *str)\n{\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    int\t\tlen;\n#endif\n\n#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)\n    // On Unix use stderr if it's a tty.\n    // When not going to start the GUI also use stderr.\n    // On Mac, when started from Finder, stderr is the console.\n    if (\n# ifdef UNIX\n#  ifdef MACOS_X\n\t    (isatty(2) && strcmp(\"/dev/console\", ttyname(2)) != 0)\n#  else\n\t    isatty(2)\n#  endif\n#  ifdef FEAT_GUI\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_GUI\n\t    !(gui.in_use || gui.starting)\n# endif\n\t    )\n    {\n\tfprintf(stderr, \"%s\", str);\n\treturn;\n    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!(gui.in_use || gui.starting))\n# endif\n    {\n\tmch_errmsg_c(str);\n\treturn;\n    }\n#endif\n\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    // avoid a delay for a message that isn't there\n    emsg_on_display = FALSE;\n\n    len = (int)STRLEN(str) + 1;\n    if (error_ga.ga_growsize == 0)\n    {\n\terror_ga.ga_growsize = 80;\n\terror_ga.ga_itemsize = 1;\n    }\n    if (ga_grow(&error_ga, len) == OK)\n    {\n\tmch_memmove((char_u *)error_ga.ga_data + error_ga.ga_len,\n\t\t\t\t\t\t\t  (char_u *)str, len);\n# ifdef UNIX\n\t// remove CR characters, they are displayed\n\t{\n\t    char_u\t*p;\n\n\t    p = (char_u *)error_ga.ga_data + error_ga.ga_len;\n\t    for (;;)\n\t    {\n\t\tp = vim_strchr(p, '\\r');\n\t\tif (p == NULL)\n\t\t    break;\n\t\t*p = ' ';\n\t    }\n\t}\n# endif\n\t--len;\t\t// don't count the NUL at the end\n\terror_ga.ga_len += len;\n    }\n#endif\n}\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n    static void\nmch_msg_c(char *str)\n{\n    int\t    len = (int)STRLEN(str);\n    DWORD   nwrite = 0;\n    DWORD   mode;\n    HANDLE  h = GetStdHandle(STD_OUTPUT_HANDLE);\n\n\n    if (GetConsoleMode(h, &mode) && enc_codepage >= 0\n\t    && (int)GetConsoleCP() != enc_codepage)\n    {\n\tWCHAR\t*w = enc_to_utf16((char_u *)str, &len);\n\n\tWriteConsoleW(h, w, len, &nwrite, NULL);\n\tvim_free(w);\n    }\n    else\n    {\n\tprintf(\"%s\", str);\n    }\n}\n#endif\n\n/*\n * Give a message.  To be used when the screen hasn't been initialized yet.\n * When there is no tty, collect messages until the GUI has started and they\n * can be displayed in a message box.\n */\n    void\nmch_msg(char *str)\n{\n#if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)\n    // On Unix use stdout if we have a tty.  This allows \"vim -h | more\" and\n    // uses mch_errmsg() when started from the desktop.\n    // When not going to start the GUI also use stdout.\n    // On Mac, when started from Finder, stderr is the console.\n    if (\n# ifdef UNIX\n#  ifdef MACOS_X\n\t    (isatty(2) && strcmp(\"/dev/console\", ttyname(2)) != 0)\n#  else\n\t    isatty(2)\n#  endif\n#  ifdef FEAT_GUI\n\t    ||\n#  endif\n# endif\n# ifdef FEAT_GUI\n\t    !(gui.in_use || gui.starting)\n# endif\n\t    )\n    {\n\tprintf(\"%s\", str);\n\treturn;\n    }\n#endif\n\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n    if (!(gui.in_use || gui.starting))\n# endif\n    {\n\tmch_msg_c(str);\n\treturn;\n    }\n#endif\n#if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)\n    mch_errmsg(str);\n#endif\n}\n#endif // USE_MCH_ERRMSG\n\n/*\n * Put a character on the screen at the current message position and advance\n * to the next position.  Only for printable ASCII!\n */\n    static void\nmsg_screen_putchar(int c, int attr)\n{\n    msg_didout = TRUE;\t\t// remember that line is not empty\n    screen_putchar(c, msg_row, msg_col, attr);\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n    {\n\tif (--msg_col == 0)\n\t{\n\t    msg_col = Columns;\n\t    ++msg_row;\n\t}\n    }\n    else\n#endif\n    {\n\tif (++msg_col >= Columns)\n\t{\n\t    msg_col = 0;\n\t    ++msg_row;\n\t}\n    }\n}\n\n    static void\nmsg_moremsg(int full)\n{\n    int\t\tattr;\n    char_u\t*s = (char_u *)_(\"-- More --\");\n\n    attr = HL_ATTR(HLF_M);\n    screen_puts(s, (int)Rows - 1, 0, attr);\n    if (full)\n\tscreen_puts((char_u *)\n\t\t_(\" SPACE/d/j: screen/page/line down, b/u/k: up, q: quit \"),\n\t\t(int)Rows - 1, vim_strsize(s), attr);\n}\n\n/*\n * Repeat the message for the current mode: ASKMORE, EXTERNCMD, CONFIRM or\n * exmode_active.\n */\n    void\nrepeat_message(void)\n{\n    if (State == ASKMORE)\n    {\n\tmsg_moremsg(TRUE);\t// display --more-- message again\n\tmsg_row = Rows - 1;\n    }\n#ifdef FEAT_CON_DIALOG\n    else if (State == CONFIRM)\n    {\n\tdisplay_confirm_msg();\t// display \":confirm\" message again\n\tmsg_row = Rows - 1;\n    }\n#endif\n    else if (State == EXTERNCMD)\n    {\n\twindgoto(msg_row, msg_col); // put cursor back\n    }\n    else if (State == HITRETURN || State == SETWSIZE)\n    {\n\tif (msg_row == Rows - 1)\n\t{\n\t    // Avoid drawing the \"hit-enter\" prompt below the previous one,\n\t    // overwrite it.  Esp. useful when regaining focus and a\n\t    // FocusGained autocmd exists but didn't draw anything.\n\t    msg_didout = FALSE;\n\t    msg_col = 0;\n\t    msg_clr_eos();\n\t}\n\thit_return_msg();\n\tmsg_row = Rows - 1;\n    }\n}\n\n/*\n * msg_check_screen - check if the screen is initialized.\n * Also check msg_row and msg_col, if they are too big it may cause a crash.\n * While starting the GUI the terminal codes will be set for the GUI, but the\n * output goes to the terminal.  Don't use the terminal codes then.\n */\n    static int\nmsg_check_screen(void)\n{\n    if (!full_screen || !screen_valid(FALSE))\n\treturn FALSE;\n\n    if (msg_row >= Rows)\n\tmsg_row = Rows - 1;\n    if (msg_col >= Columns)\n\tmsg_col = Columns - 1;\n    return TRUE;\n}\n\n/*\n * Clear from current message position to end of screen.\n * Skip this when \":silent\" was used, no need to clear for redirection.\n */\n    void\nmsg_clr_eos(void)\n{\n    if (msg_silent == 0)\n\tmsg_clr_eos_force();\n}\n\n/*\n * Clear from current message position to end of screen.\n * Note: msg_col is not updated, so we remember the end of the message\n * for msg_check().\n */\n    void\nmsg_clr_eos_force(void)\n{\n    if (msg_use_printf())\n    {\n\tif (full_screen)\t// only when termcap codes are valid\n\t{\n\t    if (*T_CD)\n\t\tout_str(T_CD);\t// clear to end of display\n\t    else if (*T_CE)\n\t\tout_str(T_CE);\t// clear to end of line\n\t}\n    }\n    else\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (cmdmsg_rl)\n\t{\n\t    screen_fill(msg_row, msg_row + 1, 0, msg_col + 1, ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n\telse\n#endif\n\t{\n\t    screen_fill(msg_row, msg_row + 1, msg_col, (int)Columns,\n\t\t\t\t\t\t\t\t ' ', ' ', 0);\n\t    screen_fill(msg_row + 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);\n\t}\n    }\n}\n\n/*\n * Clear the command line.\n */\n    void\nmsg_clr_cmdline(void)\n{\n    msg_row = cmdline_row;\n    msg_col = 0;\n    msg_clr_eos_force();\n}\n\n/*\n * end putting a message on the screen\n * call wait_return if the message does not fit in the available space\n * return TRUE if wait_return not called.\n */\n    int\nmsg_end(void)\n{\n    /*\n     * If the string is larger than the window,\n     * or the ruler option is set and we run into it,\n     * we have to redraw the window.\n     * Do not do this if we are abandoning the file or editing the command line.\n     */\n    if (!exiting && need_wait_return && !(State & CMDLINE))\n    {\n\twait_return(FALSE);\n\treturn FALSE;\n    }\n    out_flush();\n    return TRUE;\n}\n\n/*\n * If the written message runs into the shown command or ruler, we have to\n * wait for hit-return and redraw the window later.\n */\n    void\nmsg_check(void)\n{\n    if (msg_row == Rows - 1 && msg_col >= sc_col)\n    {\n\tneed_wait_return = TRUE;\n\tredraw_cmdline = TRUE;\n    }\n}\n\n/*\n * May write a string to the redirection file.\n * When \"maxlen\" is -1 write the whole string, otherwise up to \"maxlen\" bytes.\n */\n    static void\nredir_write(char_u *str, int maxlen)\n{\n    char_u\t*s = str;\n    static int\tcur_col = 0;\n\n    // Don't do anything for displaying prompts and the like.\n    if (redir_off)\n\treturn;\n\n    // If 'verbosefile' is set prepare for writing in that file.\n    if (*p_vfile != NUL && verbose_fd == NULL)\n\tverbose_open();\n\n    if (redirecting())\n    {\n\t// If the string doesn't start with CR or NL, go to msg_col\n\tif (*s != '\\n' && *s != '\\r')\n\t{\n\t    while (cur_col < msg_col)\n\t    {\n#ifdef FEAT_EVAL\n\t\tif (redir_execute)\n\t\t    execute_redir_str((char_u *)\" \", -1);\n\t\telse if (redir_reg)\n\t\t    write_reg_contents(redir_reg, (char_u *)\" \", -1, TRUE);\n\t\telse if (redir_vname)\n\t\t    var_redir_str((char_u *)\" \", -1);\n\t\telse\n#endif\n\t\t    if (redir_fd != NULL)\n\t\t    fputs(\" \", redir_fd);\n\t\tif (verbose_fd != NULL)\n\t\t    fputs(\" \", verbose_fd);\n\t\t++cur_col;\n\t    }\n\t}\n\n#ifdef FEAT_EVAL\n\tif (redir_execute)\n\t    execute_redir_str(s, maxlen);\n\telse if (redir_reg)\n\t    write_reg_contents(redir_reg, s, maxlen, TRUE);\n\telse if (redir_vname)\n\t    var_redir_str(s, maxlen);\n#endif\n\n\t// Write and adjust the current column.\n\twhile (*s != NUL && (maxlen < 0 || (int)(s - str) < maxlen))\n\t{\n#ifdef FEAT_EVAL\n\t    if (!redir_reg && !redir_vname && !redir_execute)\n#endif\n\t\tif (redir_fd != NULL)\n\t\t    putc(*s, redir_fd);\n\t    if (verbose_fd != NULL)\n\t\tputc(*s, verbose_fd);\n\t    if (*s == '\\r' || *s == '\\n')\n\t\tcur_col = 0;\n\t    else if (*s == '\\t')\n\t\tcur_col += (8 - cur_col % 8);\n\t    else\n\t\t++cur_col;\n\t    ++s;\n\t}\n\n\tif (msg_silent != 0)\t// should update msg_col\n\t    msg_col = cur_col;\n    }\n}\n\n    int\nredirecting(void)\n{\n    return redir_fd != NULL || *p_vfile != NUL\n#ifdef FEAT_EVAL\n\t\t\t  || redir_reg || redir_vname || redir_execute\n#endif\n\t\t\t\t       ;\n}\n\n/*\n * Before giving verbose message.\n * Must always be called paired with verbose_leave()!\n */\n    void\nverbose_enter(void)\n{\n    if (*p_vfile != NUL)\n\t++msg_silent;\n}\n\n/*\n * After giving verbose message.\n * Must always be called paired with verbose_enter()!\n */\n    void\nverbose_leave(void)\n{\n    if (*p_vfile != NUL)\n\tif (--msg_silent < 0)\n\t    msg_silent = 0;\n}\n\n/*\n * Like verbose_enter() and set msg_scroll when displaying the message.\n */\n    void\nverbose_enter_scroll(void)\n{\n    if (*p_vfile != NUL)\n\t++msg_silent;\n    else\n\t// always scroll up, don't overwrite\n\tmsg_scroll = TRUE;\n}\n\n/*\n * Like verbose_leave() and set cmdline_row when displaying the message.\n */\n    void\nverbose_leave_scroll(void)\n{\n    if (*p_vfile != NUL)\n    {\n\tif (--msg_silent < 0)\n\t    msg_silent = 0;\n    }\n    else\n\tcmdline_row = msg_row;\n}\n\n/*\n * Called when 'verbosefile' is set: stop writing to the file.\n */\n    void\nverbose_stop(void)\n{\n    if (verbose_fd != NULL)\n    {\n\tfclose(verbose_fd);\n\tverbose_fd = NULL;\n    }\n    verbose_did_open = FALSE;\n}\n\n/*\n * Open the file 'verbosefile'.\n * Return FAIL or OK.\n */\n    int\nverbose_open(void)\n{\n    if (verbose_fd == NULL && !verbose_did_open)\n    {\n\t// Only give the error message once.\n\tverbose_did_open = TRUE;\n\n\tverbose_fd = mch_fopen((char *)p_vfile, \"a\");\n\tif (verbose_fd == NULL)\n\t{\n\t    semsg(_(e_cant_open_file_str), p_vfile);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Give a warning message (for searching).\n * Use 'w' highlighting and may repeat the message after redrawing\n */\n    void\ngive_warning(char_u *message, int hl)\n{\n    give_warning_with_source(message, hl, FALSE);\n}\n\n    void\ngive_warning_with_source(char_u *message, int hl, int with_source)\n{\n    // Don't do this for \":silent\".\n    if (msg_silent != 0)\n\treturn;\n\n    // Don't want a hit-enter prompt here.\n    ++no_wait_return;\n\n#ifdef FEAT_EVAL\n    set_vim_var_string(VV_WARNINGMSG, message, -1);\n#endif\n    VIM_CLEAR(keep_msg);\n    if (hl)\n\tkeep_msg_attr = HL_ATTR(HLF_W);\n    else\n\tkeep_msg_attr = 0;\n\n    if (with_source)\n    {\n\t// Do what msg() does, but with a column offset if the warning should\n\t// be after the mode message.\n\tmsg_start();\n\tmsg_source(HL_ATTR(HLF_W));\n\tmsg_puts(\" \");\n\tmsg_puts_attr((char *)message, HL_ATTR(HLF_W) | MSG_HIST);\n\tmsg_clr_eos();\n\t(void)msg_end();\n    }\n    else if (msg_attr((char *)message, keep_msg_attr) && msg_scrolled == 0)\n\tset_keep_msg(message, keep_msg_attr);\n\n    msg_didout = FALSE;\t    // overwrite this message\n    msg_nowait = TRUE;\t    // don't wait for this message\n    msg_col = 0;\n\n    --no_wait_return;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    void\ngive_warning2(char_u *message, char_u *a1, int hl)\n{\n    if (IObuff == NULL)\n    {\n\t// Very early in initialisation and already something wrong, just give\n\t// the raw message so the user at least gets a hint.\n\tgive_warning((char_u *)message, hl);\n    }\n    else\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE, (char *)message, a1);\n\tgive_warning(IObuff, hl);\n    }\n}\n#endif\n\n/*\n * Advance msg cursor to column \"col\".\n */\n    void\nmsg_advance(int col)\n{\n    if (msg_silent != 0)\t// nothing to advance to\n    {\n\tmsg_col = col;\t\t// for redirection, may fill it up later\n\treturn;\n    }\n    if (col >= Columns)\t\t// not enough room\n\tcol = Columns - 1;\n#ifdef FEAT_RIGHTLEFT\n    if (cmdmsg_rl)\n\twhile (msg_col > Columns - col)\n\t    msg_putchar(' ');\n    else\n#endif\n\twhile (msg_col < col)\n\t    msg_putchar(' ');\n}\n\n#if defined(FEAT_CON_DIALOG) || defined(PROTO)\n/*\n * Used for \"confirm()\" function, and the :confirm command prefix.\n * Versions which haven't got flexible dialogs yet, and console\n * versions, get this generic handler which uses the command line.\n *\n * type  = one of:\n *\t   VIM_QUESTION, VIM_INFO, VIM_WARNING, VIM_ERROR or VIM_GENERIC\n * title = title string (can be NULL for default)\n * (neither used in console dialogs at the moment)\n *\n * Format of the \"buttons\" string:\n * \"Button1Name\\nButton2Name\\nButton3Name\"\n * The first button should normally be the default/accept\n * The second button should be the 'Cancel' button\n * Other buttons- use your imagination!\n * A '&' in a button name becomes a shortcut, so each '&' should be before a\n * different letter.\n */\n    int\ndo_dialog(\n    int\t\ttype UNUSED,\n    char_u\t*title UNUSED,\n    char_u\t*message,\n    char_u\t*buttons,\n    int\t\tdfltbutton,\n    char_u\t*textfield UNUSED,\t// IObuff for inputdialog(), NULL\n\t\t\t\t\t// otherwise\n    int\t\tex_cmd)\t    // when TRUE pressing : accepts default and starts\n\t\t\t    // Ex command\n{\n    int\t\toldState;\n    int\t\tretval = 0;\n    char_u\t*hotkeys;\n    int\t\tc;\n    int\t\ti;\n    tmode_T\tsave_tmode;\n\n#ifndef NO_CONSOLE\n    // Don't output anything in silent mode (\"ex -s\")\n    if (silent_mode)\n\treturn dfltbutton;   // return default option\n#endif\n\n#ifdef FEAT_GUI_DIALOG\n    // When GUI is running and 'c' not in 'guioptions', use the GUI dialog\n    if (gui.in_use && vim_strchr(p_go, GO_CONDIALOG) == NULL)\n    {\n\tc = gui_mch_dialog(type, title, message, buttons, dfltbutton,\n\t\t\t\t\t\t\t   textfield, ex_cmd);\n\t// avoid a hit-enter prompt without clearing the cmdline\n\tneed_wait_return = FALSE;\n\temsg_on_display = FALSE;\n\tcmdline_row = msg_row;\n\n\t// Flush output to avoid that further messages and redrawing is done\n\t// in the wrong order.\n\tout_flush();\n\tgui_mch_update();\n\n\treturn c;\n    }\n#endif\n\n    oldState = State;\n    State = CONFIRM;\n    setmouse();\n\n    // Ensure raw mode here.\n    save_tmode = cur_tmode;\n    settmode(TMODE_RAW);\n\n    /*\n     * Since we wait for a keypress, don't make the\n     * user press RETURN as well afterwards.\n     */\n    ++no_wait_return;\n    hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);\n\n    if (hotkeys != NULL)\n    {\n\tfor (;;)\n\t{\n\t    // Get a typed character directly from the user.\n\t    c = get_keystroke();\n\t    switch (c)\n\t    {\n\t    case CAR:\t\t// User accepts default option\n\t    case NL:\n\t\tretval = dfltbutton;\n\t\tbreak;\n\t    case Ctrl_C:\t// User aborts/cancels\n\t    case ESC:\n\t\tretval = 0;\n\t\tbreak;\n\t    default:\t\t// Could be a hotkey?\n\t\tif (c < 0)\t// special keys are ignored here\n\t\t    continue;\n\t\tif (c == ':' && ex_cmd)\n\t\t{\n\t\t    retval = dfltbutton;\n\t\t    ins_char_typebuf(':', 0);\n\t\t    break;\n\t\t}\n\n\t\t// Make the character lowercase, as chars in \"hotkeys\" are.\n\t\tc = MB_TOLOWER(c);\n\t\tretval = 1;\n\t\tfor (i = 0; hotkeys[i]; ++i)\n\t\t{\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tif ((*mb_ptr2char)(hotkeys + i) == c)\n\t\t\t    break;\n\t\t\ti += (*mb_ptr2len)(hotkeys + i) - 1;\n\t\t    }\n\t\t    else\n\t\t\tif (hotkeys[i] == c)\n\t\t\t    break;\n\t\t    ++retval;\n\t\t}\n\t\tif (hotkeys[i])\n\t\t    break;\n\t\t// No hotkey match, so keep waiting\n\t\tcontinue;\n\t    }\n\t    break;\n\t}\n\n\tvim_free(hotkeys);\n    }\n\n    settmode(save_tmode);\n    State = oldState;\n    setmouse();\n    --no_wait_return;\n    msg_end_prompt();\n\n    return retval;\n}\n\n/*\n * Copy one character from \"*from\" to \"*to\", taking care of multi-byte\n * characters.  Return the length of the character in bytes.\n */\n    static int\ncopy_char(\n    char_u\t*from,\n    char_u\t*to,\n    int\t\tlowercase)\t// make character lower case\n{\n    int\t\tlen;\n    int\t\tc;\n\n    if (has_mbyte)\n    {\n\tif (lowercase)\n\t{\n\t    c = MB_TOLOWER((*mb_ptr2char)(from));\n\t    return (*mb_char2bytes)(c, to);\n\t}\n\telse\n\t{\n\t    len = (*mb_ptr2len)(from);\n\t    mch_memmove(to, from, (size_t)len);\n\t    return len;\n\t}\n    }\n    else\n    {\n\tif (lowercase)\n\t    *to = (char_u)TOLOWER_LOC(*from);\n\telse\n\t    *to = *from;\n\treturn 1;\n    }\n}\n\n/*\n * Format the dialog string, and display it at the bottom of\n * the screen. Return a string of hotkey chars (if defined) for\n * each 'button'. If a button has no hotkey defined, the first character of\n * the button is used.\n * The hotkeys can be multi-byte characters, but without combining chars.\n *\n * Returns an allocated string with hotkeys, or NULL for error.\n */\n    static char_u *\nmsg_show_console_dialog(\n    char_u\t*message,\n    char_u\t*buttons,\n    int\t\tdfltbutton)\n{\n    int\t\tlen = 0;\n#define HOTK_LEN (has_mbyte ? MB_MAXBYTES : 1)\n    int\t\tlenhotkey = HOTK_LEN;\t// count first button\n    char_u\t*hotk = NULL;\n    char_u\t*msgp = NULL;\n    char_u\t*hotkp = NULL;\n    char_u\t*r;\n    int\t\tcopy;\n#define HAS_HOTKEY_LEN 30\n    char_u\thas_hotkey[HAS_HOTKEY_LEN];\n    int\t\tfirst_hotkey = FALSE;\t// first char of button is hotkey\n    int\t\tidx;\n\n    has_hotkey[0] = FALSE;\n\n    /*\n     * First loop: compute the size of memory to allocate.\n     * Second loop: copy to the allocated memory.\n     */\n    for (copy = 0; copy <= 1; ++copy)\n    {\n\tr = buttons;\n\tidx = 0;\n\twhile (*r)\n\t{\n\t    if (*r == DLG_BUTTON_SEP)\n\t    {\n\t\tif (copy)\n\t\t{\n\t\t    *msgp++ = ',';\n\t\t    *msgp++ = ' ';\t    // '\\n' -> ', '\n\n\t\t    // advance to next hotkey and set default hotkey\n\t\t    if (has_mbyte)\n\t\t\thotkp += STRLEN(hotkp);\n\t\t    else\n\t\t\t++hotkp;\n\t\t    hotkp[copy_char(r + 1, hotkp, TRUE)] = NUL;\n\t\t    if (dfltbutton)\n\t\t\t--dfltbutton;\n\n\t\t    // If no hotkey is specified first char is used.\n\t\t    if (idx < HAS_HOTKEY_LEN - 1 && !has_hotkey[++idx])\n\t\t\tfirst_hotkey = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    len += 3;\t\t    // '\\n' -> ', '; 'x' -> '(x)'\n\t\t    lenhotkey += HOTK_LEN;  // each button needs a hotkey\n\t\t    if (idx < HAS_HOTKEY_LEN - 1)\n\t\t\thas_hotkey[++idx] = FALSE;\n\t\t}\n\t    }\n\t    else if (*r == DLG_HOTKEY_CHAR || first_hotkey)\n\t    {\n\t\tif (*r == DLG_HOTKEY_CHAR)\n\t\t    ++r;\n\t\tfirst_hotkey = FALSE;\n\t\tif (copy)\n\t\t{\n\t\t    if (*r == DLG_HOTKEY_CHAR)\t\t// '&&a' -> '&a'\n\t\t\t*msgp++ = *r;\n\t\t    else\n\t\t    {\n\t\t\t// '&a' -> '[a]'\n\t\t\t*msgp++ = (dfltbutton == 1) ? '[' : '(';\n\t\t\tmsgp += copy_char(r, msgp, FALSE);\n\t\t\t*msgp++ = (dfltbutton == 1) ? ']' : ')';\n\n\t\t\t// redefine hotkey\n\t\t\thotkp[copy_char(r, hotkp, TRUE)] = NUL;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++len;\t    // '&a' -> '[a]'\n\t\t    if (idx < HAS_HOTKEY_LEN - 1)\n\t\t\thas_hotkey[idx] = TRUE;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// everything else copy literally\n\t\tif (copy)\n\t\t    msgp += copy_char(r, msgp, FALSE);\n\t    }\n\n\t    // advance to the next character\n\t    MB_PTR_ADV(r);\n\t}\n\n\tif (copy)\n\t{\n\t    *msgp++ = ':';\n\t    *msgp++ = ' ';\n\t    *msgp = NUL;\n\t}\n\telse\n\t{\n\t    len += (int)(STRLEN(message)\n\t\t\t+ 2\t\t\t// for the NL's\n\t\t\t+ STRLEN(buttons)\n\t\t\t+ 3);\t\t\t// for the \": \" and NUL\n\t    lenhotkey++;\t\t\t// for the NUL\n\n\t    // If no hotkey is specified first char is used.\n\t    if (!has_hotkey[0])\n\t    {\n\t\tfirst_hotkey = TRUE;\n\t\tlen += 2;\t\t// \"x\" -> \"[x]\"\n\t    }\n\n\t    /*\n\t     * Now allocate and load the strings\n\t     */\n\t    vim_free(confirm_msg);\n\t    confirm_msg = alloc(len);\n\t    if (confirm_msg == NULL)\n\t\treturn NULL;\n\t    *confirm_msg = NUL;\n\t    hotk = alloc(lenhotkey);\n\t    if (hotk == NULL)\n\t\treturn NULL;\n\n\t    *confirm_msg = '\\n';\n\t    STRCPY(confirm_msg + 1, message);\n\n\t    msgp = confirm_msg + 1 + STRLEN(message);\n\t    hotkp = hotk;\n\n\t    // Define first default hotkey.  Keep the hotkey string NUL\n\t    // terminated to avoid reading past the end.\n\t    hotkp[copy_char(buttons, hotkp, TRUE)] = NUL;\n\n\t    // Remember where the choices start, displaying starts here when\n\t    // \"hotkp\" typed at the more prompt.\n\t    confirm_msg_tail = msgp;\n\t    *msgp++ = '\\n';\n\t}\n    }\n\n    display_confirm_msg();\n    return hotk;\n}\n\n/*\n * Display the \":confirm\" message.  Also called when screen resized.\n */\n    static void\ndisplay_confirm_msg(void)\n{\n    // avoid that 'q' at the more prompt truncates the message here\n    ++confirm_msg_used;\n    if (confirm_msg != NULL)\n\tmsg_puts_attr((char *)confirm_msg, HL_ATTR(HLF_M));\n    --confirm_msg_used;\n}\n\n#endif // FEAT_CON_DIALOG\n\n#if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)\n\n    int\nvim_dialog_yesno(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    if (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)_(\"Question\") : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1)\n\treturn VIM_YES;\n    return VIM_NO;\n}\n\n    int\nvim_dialog_yesnocancel(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    switch (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)_(\"Question\") : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE))\n    {\n\tcase 1: return VIM_YES;\n\tcase 2: return VIM_NO;\n    }\n    return VIM_CANCEL;\n}\n\n    int\nvim_dialog_yesnoallcancel(\n    int\t\ttype,\n    char_u\t*title,\n    char_u\t*message,\n    int\t\tdflt)\n{\n    switch (do_dialog(type,\n\t\ttitle == NULL ? (char_u *)\"Question\" : title,\n\t\tmessage,\n\t\t(char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),\n\t\t\t\t\t\t\t   dflt, NULL, FALSE))\n    {\n\tcase 1: return VIM_YES;\n\tcase 2: return VIM_NO;\n\tcase 3: return VIM_ALL;\n\tcase 4: return VIM_DISCARDALL;\n    }\n    return VIM_CANCEL;\n}\n\n#endif // FEAT_GUI_DIALOG || FEAT_CON_DIALOG\n", "/* alloc.c */\nvoid vim_mem_profile_dump(void);\nint alloc_does_fail(size_t size);\nvoid *alloc(size_t size);\nvoid *alloc_id(size_t size, alloc_id_T id);\nvoid *alloc_clear(size_t size);\nvoid *alloc_clear_id(size_t size, alloc_id_T id);\nvoid *lalloc_clear(size_t size, int message);\nvoid *lalloc(size_t size, int message);\nvoid *lalloc_id(size_t size, int message, alloc_id_T id);\nvoid *mem_realloc(void *ptr, size_t size);\nvoid do_outofmem_msg(size_t size);\nvoid free_all_mem(void);\nchar_u *vim_memsave(char_u *p, size_t len);\nvoid vim_free(void *x);\nvoid ga_clear(garray_T *gap);\nvoid ga_clear_strings(garray_T *gap);\nint ga_copy_strings(garray_T *from, garray_T *to);\nvoid ga_init(garray_T *gap);\nvoid ga_init2(garray_T *gap, size_t itemsize, int growsize);\nint ga_grow(garray_T *gap, int n);\nint ga_grow_inner(garray_T *gap, int n);\nchar_u *ga_concat_strings(garray_T *gap, char *sep);\nint ga_copy_string(garray_T *gap, char_u *p);\nint ga_add_string(garray_T *gap, char_u *p);\nvoid ga_concat(garray_T *gap, char_u *s);\nvoid ga_concat_len(garray_T *gap, char_u *s, size_t len);\nvoid ga_append(garray_T *gap, int c);\nvoid append_ga_line(garray_T *gap);\n/* vim: set ft=c : */\n", "/* userfunc.c */\nvoid func_init(void);\nhashtab_T *func_tbl_get(void);\nchar_u *get_lambda_name(void);\nchar_u *register_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state);\nint get_lambda_tv(char_u **arg, typval_T *rettv, int types_optional, evalarg_T *evalarg);\nchar_u *deref_func_name(char_u *name, int *lenp, partial_T **partialp, type_T **type, int no_autoload, int *found_var);\nvoid emsg_funcname(char *ermsg, char_u *name);\nint get_func_tv(char_u *name, int len, typval_T *rettv, char_u **arg, evalarg_T *evalarg, funcexe_T *funcexe);\nchar_u *fname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error);\nufunc_T *find_func_even_dead(char_u *name, int is_global, cctx_T *cctx);\nufunc_T *find_func(char_u *name, int is_global, cctx_T *cctx);\nint func_is_global(ufunc_T *ufunc);\nint func_name_refcount(char_u *name);\nvoid func_clear_free(ufunc_T *fp, int force);\nint copy_func(char_u *lambda, char_u *global, ectx_T *ectx);\nint funcdepth_increment(void);\nvoid funcdepth_decrement(void);\nint funcdepth_get(void);\nvoid funcdepth_restore(int depth);\nint check_user_func_argcount(ufunc_T *fp, int argcount);\nint call_user_func_check(ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv, funcexe_T *funcexe, dict_T *selfdict);\nvoid save_funccal(funccal_entry_T *entry);\nvoid restore_funccal(void);\nfunccall_T *get_current_funccal(void);\nvoid delete_script_functions(int sid);\nvoid free_all_functions(void);\nint builtin_function(char_u *name, int len);\nint func_call(char_u *name, typval_T *args, partial_T *partial, dict_T *selfdict, typval_T *rettv);\nint get_callback_depth(void);\nint call_callback(callback_T *callback, int len, typval_T *rettv, int argcount, typval_T *argvars);\nvarnumber_T call_callback_retnr(callback_T *callback, int argcount, typval_T *argvars);\nvoid user_func_error(int error, char_u *name, funcexe_T *funcexe);\nint call_func(char_u *funcname, int len, typval_T *rettv, int argcount_in, typval_T *argvars_in, funcexe_T *funcexe);\nchar_u *printable_func_name(ufunc_T *fp);\nchar_u *trans_function_name(char_u **pp, int *is_global, int skip, int flags, funcdict_T *fdp, partial_T **partial, type_T **type);\nchar_u *untrans_function_name(char_u *name);\nchar_u *get_scriptlocal_funcname(char_u *funcname);\nchar_u *save_function_name(char_u **name, int *is_global, int skip, int flags, funcdict_T *fudi);\nvoid list_functions(regmatch_T *regmatch);\nufunc_T *define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free);\nvoid ex_function(exarg_T *eap);\nvoid ex_defcompile(exarg_T *eap);\nint eval_fname_script(char_u *p);\nint translated_function_exists(char_u *name, int is_global);\nint has_varargs(ufunc_T *ufunc);\nint function_exists(char_u *name, int no_deref);\nchar_u *get_expanded_name(char_u *name, int check);\nchar_u *get_user_func_name(expand_T *xp, int idx);\nvoid ex_delfunction(exarg_T *eap);\nvoid func_unref(char_u *name);\nvoid func_ptr_unref(ufunc_T *fp);\nvoid func_ref(char_u *name);\nvoid func_ptr_ref(ufunc_T *fp);\nvoid ex_return(exarg_T *eap);\nvoid ex_call(exarg_T *eap);\nint do_return(exarg_T *eap, int reanimate, int is_cmd, void *rettv);\nvoid discard_pending_return(void *rettv);\nchar_u *get_return_cmd(void *rettv);\nchar_u *get_func_line(int c, void *cookie, int indent, getline_opt_T options);\nint func_has_ended(void *cookie);\nint func_has_abort(void *cookie);\ndict_T *make_partial(dict_T *selfdict_in, typval_T *rettv);\nchar_u *func_name(void *cookie);\nlinenr_T *func_breakpoint(void *cookie);\nint *func_dbg_tick(void *cookie);\nint func_level(void *cookie);\nint current_func_returned(void);\nint free_unref_funccal(int copyID, int testing);\nhashtab_T *get_funccal_local_ht(void);\ndictitem_T *get_funccal_local_var(void);\nhashtab_T *get_funccal_args_ht(void);\ndictitem_T *get_funccal_args_var(void);\nvoid list_func_vars(int *first);\ndict_T *get_current_funccal_dict(hashtab_T *ht);\nhashitem_T *find_hi_in_scoped_ht(char_u *name, hashtab_T **pht);\ndictitem_T *find_var_in_scoped_ht(char_u *name, int no_autoload);\nint set_ref_in_previous_funccal(int copyID);\nint set_ref_in_call_stack(int copyID);\nint set_ref_in_functions(int copyID);\nint set_ref_in_func_args(int copyID);\nint set_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID);\n/* vim: set ft=c : */\n", "\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nsource view_util.vim\nsource vim9.vim\nsource screendump.vim\n\nfunc Test_def_basic()\n  def SomeFunc(): string\n    return 'yes'\n  enddef\n  call SomeFunc()->assert_equal('yes')\nendfunc\n\nfunc Test_compiling_error()\n  \" use a terminal to see the whole error message\n  CheckRunVimInTerminal\n\n  call TestCompilingError()\n  call TestCompilingErrorInTry()\nendfunc\n\ndef TestCompilingError()\n  var lines =<< trim END\n    vim9script\n    def Fails()\n      echo nothing\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_compile_error')\n  var buf = RunVimInTerminal('-S XTest_compile_error',\n              {rows: 10, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Error detected while compiling command line.*Fails.*Variable not found: nothing',\n                     Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_compile_error')\nenddef\n\ndef TestCompilingErrorInTry()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      def script#OnlyCompiled()\n        g:runtime = 'yes'\n        invalid\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  lines =<< trim END\n      vim9script\n      todo\n      try\n        script#OnlyCompiled()\n      catch /nothing/\n      endtry\n  END\n  lines[1] = 'set rtp=' .. getcwd() .. '/Xdir'\n  writefile(lines, 'XTest_compile_error')\n\n  var buf = RunVimInTerminal('-S XTest_compile_error', {rows: 10, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Error detected while compiling command line.*function script#OnlyCompiled.*Invalid command: invalid',\n                     Term_getlines(buf, range(1, 9))))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_compile_error')\n  delete('Xdir', 'rf')\nenddef\n\ndef Test_compile_error_in_called_function()\n  var lines =<< trim END\n      vim9script\n      var n: number\n      def Foo()\n        &hls = n\n      enddef\n      def Bar()\n        Foo()\n      enddef\n      silent! Foo()\n      Bar()\n  END\n  CheckScriptFailureList(lines, ['E1012:', 'E1191:'])\nenddef\n\ndef Test_wrong_function_name()\n  var lines =<< trim END\n      vim9script\n      func _Foo()\n        echo 'foo'\n      endfunc\n  END\n  CheckScriptFailure(lines, 'E128:')\n\n  lines =<< trim END\n      vim9script\n      def _Foo()\n        echo 'foo'\n      enddef\n  END\n  CheckScriptFailure(lines, 'E128:')\nenddef\n\ndef Test_autoload_name_mismatch()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      vim9script\n      def scriptX#Function()\n        # comment\n        g:runtime = 'yes'\n      enddef\n  END\n  writefile(lines, dir .. '/script.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n  lines =<< trim END\n      call script#Function()\n  END\n  CheckScriptFailure(lines, 'E746:', 2)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_names()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func foobar#function()\n        return 'yes'\n      endfunc\n      let foobar#var = 'no'\n  END\n  writefile(lines, dir .. '/foobar.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  lines =<< trim END\n      assert_equal('yes', foobar#function())\n      var Function = foobar#function\n      assert_equal('yes', Function())\n\n      assert_equal('no', foobar#var)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_autoload_error_in_script()\n  var dir = 'Xdir/autoload'\n  mkdir(dir, 'p')\n\n  var lines =<< trim END\n      func scripterror#function()\n        let g:called_function = 'yes'\n      endfunc\n      let 0 = 1\n  END\n  writefile(lines, dir .. '/scripterror.vim')\n\n  var save_rtp = &rtp\n  exe 'set rtp=' .. getcwd() .. '/Xdir'\n\n  g:called_function = 'no'\n  # The error in the autoload script cannot be checked with assert_fails(), use\n  # CheckDefSuccess() instead of CheckDefFailure()\n  try\n    CheckDefSuccess(['scripterror#function()'])\n  catch\n    assert_match('E121: Undefined variable: 0', v:exception)\n  endtry\n  assert_equal('no', g:called_function)\n\n  lines =<< trim END\n      func scriptcaught#function()\n        let g:called_function = 'yes'\n      endfunc\n      try\n        let 0 = 1\n      catch\n        let g:caught = v:exception\n      endtry\n  END\n  writefile(lines, dir .. '/scriptcaught.vim')\n\n  g:called_function = 'no'\n  CheckDefSuccess(['scriptcaught#function()'])\n  assert_match('E121: Undefined variable: 0', g:caught)\n  assert_equal('yes', g:called_function)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef CallRecursive(n: number): number\n  return CallRecursive(n + 1)\nenddef\n\ndef CallMapRecursive(l: list<number>): number\n  return map(l, (_, v) => CallMapRecursive([v]))[0]\nenddef\n\ndef Test_funcdepth_error()\n  set maxfuncdepth=10\n\n  var caught = false\n  try\n    CallRecursive(1)\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  caught = false\n  try\n    CallMapRecursive([1])\n  catch /E132:/\n    caught = true\n  endtry\n  assert_true(caught)\n\n  set maxfuncdepth&\nenddef\n\ndef Test_endfunc_enddef()\n  var lines =<< trim END\n    def Test()\n      echo 'test'\n      endfunc\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1151:', 3)\n\n  lines =<< trim END\n    def Test()\n      func Nested()\n        echo 'test'\n      enddef\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1152:', 4)\n\n  lines =<< trim END\n    def Ok()\n      echo 'hello'\n    enddef | echo 'there'\n    def Bad()\n      echo 'hello'\n    enddef there\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: there', 6)\nenddef\n\ndef Test_missing_endfunc_enddef()\n  var lines =<< trim END\n    vim9script\n    def Test()\n      echo 'test'\n    endef\n  END\n  CheckScriptFailure(lines, 'E1057:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Some()\n      echo 'test'\n    enfffunc\n  END\n  CheckScriptFailure(lines, 'E126:', 2)\nenddef\n\ndef Test_white_space_before_paren()\n  var lines =<< trim END\n    vim9script\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    vim9script\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  CheckScriptFailure(lines, 'E1068:', 2)\n\n  lines =<< trim END\n    def Test ()\n      echo 'test'\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:', 1)\n\n  lines =<< trim END\n    func Test ()\n      echo 'test'\n    endfunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_enddef_dict_key()\n  var d = {\n    enddef: 'x',\n    endfunc: 'y',\n  }\n  assert_equal({enddef: 'x', endfunc: 'y'}, d)\nenddef\n\ndef ReturnString(): string\n  return 'string'\nenddef\n\ndef ReturnNumber(): number\n  return 123\nenddef\n\nlet g:notNumber = 'string'\n\ndef ReturnGlobal(): number\n  return g:notNumber\nenddef\n\ndef Test_return_something()\n  ReturnString()->assert_equal('string')\n  ReturnNumber()->assert_equal(123)\n  assert_fails('ReturnGlobal()', 'E1012: Type mismatch; expected number but got string', '', 1, 'ReturnGlobal')\nenddef\n\ndef Test_check_argument_type()\n  var lines =<< trim END\n      vim9script\n      def Val(a: number, b: number): number\n        return 0\n      enddef\n      def Func()\n        var x: any = true\n        Val(0, x)\n      enddef\n      disass Func\n      Func()\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got bool', 2)\nenddef\n\ndef Test_missing_return()\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    echo \"no return\"',\n                   '  else',\n                   '    return 0',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    echo \"no return\"',\n                   '  endif'\n                   'enddef'], 'E1027:')\n  CheckDefFailure(['def Missing(): number',\n                   '  if g:cond',\n                   '    return 1',\n                   '  else',\n                   '    return 2',\n                   '  endif'\n                   '  return 3'\n                   'enddef'], 'E1095:')\nenddef\n\ndef Test_return_bool()\n  var lines =<< trim END\n      vim9script\n      def MenuFilter(id: number, key: string): bool\n        return popup_filter_menu(id, key)\n      enddef\n      def YesnoFilter(id: number, key: string): bool\n        return popup_filter_yesno(id, key)\n      enddef\n      defcompile\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet s:nothing = 0\ndef ReturnNothing()\n  s:nothing = 1\n  if true\n    return\n  endif\n  s:nothing = 2\nenddef\n\ndef Test_return_nothing()\n  ReturnNothing()\n  s:nothing->assert_equal(1)\nenddef\n\ndef Test_return_invalid()\n  var lines =<< trim END\n    vim9script\n    def Func(): invalid\n      return xxx\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E1010:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n          return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      defcompile\n      def Inc(nr: number): nr\n        return nr + 2\n      enddef\n      echo Test(Inc)\n  END\n  # doing this twice was leaking memory\n  CheckScriptFailure(lines, 'E1010:')\n  CheckScriptFailure(lines, 'E1010:')\nenddef\n\ndef Test_return_list_any()\n  # This used to fail but now the actual list type is checked, and since it has\n  # an item of type string it can be used as list<string>.\n  var lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l->add('string')\n        return l\n      enddef\n      echo Func()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(): list<string>\n        var l: list<any>\n        l += ['string']\n        return l\n      enddef\n      echo Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nfunc Increment()\n  let g:counter += 1\nendfunc\n\ndef Test_call_ufunc_count()\n  g:counter = 1\n  Increment()\n  Increment()\n  Increment()\n  # works with and without :call\n  g:counter->assert_equal(4)\n  eval g:counter->assert_equal(4)\n  unlet g:counter\nenddef\n\ndef MyVarargs(arg: string, ...rest: list<string>): string\n  var res = arg\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_varargs()\n  MyVarargs('one')->assert_equal('one')\n  MyVarargs('one', 'two')->assert_equal('one,two')\n  MyVarargs('one', 'two', 'three')->assert_equal('one,two,three')\nenddef\n\ndef Test_call_white_space()\n  CheckDefAndScriptFailure([\"call Test ('text')\"], ['E476:', 'E1068:'])\nenddef\n\ndef MyDefaultArgs(name = 'string'): string\n  return name\nenddef\n\ndef MyDefaultSecond(name: string, second: bool  = true): string\n  return second ? name : 'none'\nenddef\n\n\ndef Test_call_default_args()\n  MyDefaultArgs()->assert_equal('string')\n  MyDefaultArgs(v:none)->assert_equal('string')\n  MyDefaultArgs('one')->assert_equal('one')\n  assert_fails('MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 4, 'Test_call_default_args')\n\n  MyDefaultSecond('test')->assert_equal('test')\n  MyDefaultSecond('test', true)->assert_equal('test')\n  MyDefaultSecond('test', false)->assert_equal('none')\n\n  var lines =<< trim END\n      def MyDefaultThird(name: string, aa = 'aa', bb = 'bb'): string\n        return name .. aa .. bb\n      enddef\n\n      MyDefaultThird('->')->assert_equal('->aabb')\n      MyDefaultThird('->', v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx')->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, v:none)->assert_equal('->aabb')\n      MyDefaultThird('->', 'xx', v:none)->assert_equal('->xxbb')\n      MyDefaultThird('->', v:none, 'yy')->assert_equal('->aayy')\n      MyDefaultThird('->', 'xx', 'yy')->assert_equal('->xxyy')\n\n      def DefArg(mandatory: any, optional = mandatory): string\n        return mandatory .. optional\n      enddef\n      DefArg(1234)->assert_equal('12341234')\n      DefArg(\"ok\")->assert_equal('okok')\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckScriptFailure(['def Func(arg: number = asdf)', 'enddef', 'defcompile'], 'E1001:')\n  delfunc g:Func\n  CheckScriptFailure(['def Func(arg: number = \"text\")', 'enddef', 'defcompile'], 'E1013: Argument 1: type mismatch, expected number but got string')\n  delfunc g:Func\n  CheckDefFailure(['def Func(x: number = )', 'enddef'], 'E15:')\n\n  lines =<< trim END\n      vim9script\n      def Func(a = b == 0 ? 1 : 2, b = 0)\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1001: Variable not found: b')\n\n  # using script variable requires matching type or type cast when executed\n  lines =<< trim END\n      vim9script\n      var a: any\n      def Func(arg: string = a)\n        echo arg\n      enddef\n      defcompile\n  END\n  CheckScriptSuccess(lines + ['a = \"text\"', 'Func()'])\n  CheckScriptFailure(lines + ['a = 123', 'Func()'], 'E1013: Argument 1: type mismatch, expected string but got number')\n\n  # using global variable does not require type cast\n  lines =<< trim END\n      vim9script\n      def Func(arg: string = g:str)\n        echo arg\n      enddef\n      g:str = 'works'\n      Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef FuncWithComment(  # comment\n  a: number, #comment\n  b: bool, # comment\n  c: string) #comment\n  assert_equal(4, a)\n  assert_equal(true, b)\n  assert_equal('yes', c)\nenddef\n\ndef Test_func_with_comments()\n  FuncWithComment(4, true, 'yes')\n\n  var lines =<< trim END\n      def Func(# comment\n        arg: string)\n      enddef\n  END\n  CheckScriptFailure(lines, 'E125:', 1)\n\n  lines =<< trim END\n      def Func(\n        arg: string# comment\n        )\n      enddef\n  END\n  CheckScriptFailure(lines, 'E475:', 2)\n\n  lines =<< trim END\n      def Func(\n        arg: string\n        )# comment\n      enddef\n  END\n  CheckScriptFailure(lines, 'E488:', 3)\nenddef\n\ndef Test_nested_function()\n  def NestedDef(arg: string): string\n    return 'nested ' .. arg\n  enddef\n  NestedDef(':def')->assert_equal('nested :def')\n\n  func NestedFunc(arg)\n    return 'nested ' .. a:arg\n  endfunc\n  NestedFunc(':func')->assert_equal('nested :func')\n\n  CheckDefFailure(['def Nested()', 'enddef', 'Nested(66)'], 'E118:')\n  CheckDefFailure(['def Nested(arg: string)', 'enddef', 'Nested()'], 'E119:')\n\n  CheckDefFailure(['def s:Nested()', 'enddef'], 'E1075:')\n  CheckDefFailure(['def b:Nested()', 'enddef'], 'E1075:')\n\n  var lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def Inner()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1073:')\n\n  lines =<< trim END\n      def Outer()\n        def Inner()\n          # comment\n        enddef\n        def! Inner()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1117:')\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          g:result = 'ok'\n        enddef\n        Inner()\n      enddef\n      Outer()\n      Inner()\n  END\n  CheckScriptFailure(lines, 'E117: Unknown function: Inner')\n  assert_equal('ok', g:result)\n  unlet g:result\n\n  # nested function inside conditional\n  lines =<< trim END\n      vim9script\n      var thecount = 0\n      if true\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  CheckScriptSuccess(lines)\n\n  # also works when \"thecount\" is inside the \"if\" block\n  lines =<< trim END\n      vim9script\n      if true\n        var thecount = 0\n        def Test(): number\n          def TheFunc(): number\n            thecount += 1\n            return thecount\n          enddef\n          return TheFunc()\n        enddef\n      endif\n      defcompile\n      assert_equal(1, Test())\n      assert_equal(2, Test())\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def Inner()\n          echo 'hello'\n        enddef burp\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: burp', 3)\nenddef\n\ndef Test_not_nested_function()\n  echo printf('%d',\n      function('len')('xxx'))\nenddef\n\nfunc Test_call_default_args_from_func()\n  call MyDefaultArgs()->assert_equal('string')\n  call MyDefaultArgs('one')->assert_equal('one')\n  call assert_fails('call MyDefaultArgs(\"one\", \"two\")', 'E118:', '', 3, 'Test_call_default_args_from_func')\nendfunc\n\ndef Test_nested_global_function()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          func g:Inner()\n            return 'inner'\n          endfunc\n      enddef\n      defcompile\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n      Outer()\n      g:Inner()->assert_equal('inner')\n      delfunc g:Inner\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n          def g:Inner(): string\n              return 'inner'\n          enddef\n      enddef\n      defcompile\n      Outer()\n      Outer()\n  END\n  CheckScriptFailure(lines, \"E122:\")\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Outer()\n        def g:Inner()\n          echo map([1, 2, 3], (_, v) => v + 1)\n        enddef\n        g:Inner()\n      enddef\n      Outer()\n  END\n  CheckScriptSuccess(lines)\n  delfunc g:Inner\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Outer()\n        def Func()\n          echo 'inner'\n        enddef\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, \"E1073:\", 1)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo 'script'\n      enddef\n      def Func()\n        echo 'script'\n      enddef\n  END\n  CheckScriptFailure(lines, \"E1073:\", 5)\nenddef\n\ndef DefListAll()\n  def\nenddef\n\ndef DefListOne()\n  def DefListOne\nenddef\n\ndef DefListMatches()\n  def /DefList\nenddef\n\ndef Test_nested_def_list()\n  var funcs = split(execute('call DefListAll()'), \"\\n\")\n  assert_true(len(funcs) > 10)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n\n  funcs = split(execute('call DefListOne()'), \"\\n\")\n  assert_equal(['   def DefListOne()', '1    def DefListOne', '   enddef'], funcs)\n\n  funcs = split(execute('call DefListMatches()'), \"\\n\")\n  assert_true(len(funcs) >= 3)\n  assert_true(funcs->index('def DefListAll()') >= 0)\n  assert_true(funcs->index('def DefListOne()') >= 0)\n  assert_true(funcs->index('def DefListMatches()') >= 0)\n\n  var lines =<< trim END\n    vim9script\n    def Func()\n      def +Func+\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E476:', 1)\nenddef\n\ndef Test_global_local_function()\n  var lines =<< trim END\n      vim9script\n      def g:Func(): string\n          return 'global'\n      enddef\n      def Func(): string\n          return 'local'\n      enddef\n      g:Func()->assert_equal('global')\n      Func()->assert_equal('local')\n      delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Funcy()\n        echo 'funcy'\n      enddef\n      s:Funcy()\n  END\n  CheckScriptFailure(lines, 'E117:')\nenddef\n\ndef Test_local_function_shadows_global()\n  var lines =<< trim END\n      vim9script\n      def g:Gfunc(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): number\n        var Gfunc = function('len')\n        return Gfunc('testing')\n      enddef\n      g:Gfunc()->assert_equal('global')\n      AnotherFunc()->assert_equal(7)\n      delfunc g:Gfunc\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc()\n        g:Func = function('len')\n      enddef\n      AnotherFunc()\n  END\n  CheckScriptFailure(lines, 'E705:')\n  delfunc g:Func\n\n  # global function is found without g: prefix\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      def AnotherFunc(): string\n        return Func()\n      enddef\n      assert_equal('global', AnotherFunc())\n    delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:Func(): string\n        return 'global'\n      enddef\n      assert_equal('global', Func())\n      delfunc g:Func\n  END\n  CheckScriptSuccess(lines)\n\n  # This does not shadow \"i\" which is visible only inside the for loop\n  lines =<< trim END\n      vim9script\n\n      def Foo(i: number)\n        echo i\n      enddef\n\n      for i in range(3)\n        # Foo() is compiled here\n        Foo(i)\n      endfor\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nfunc TakesOneArg(arg)\n  echo a:arg\nendfunc\n\ndef Test_call_wrong_args()\n  CheckDefFailure(['TakesOneArg()'], 'E119:')\n  CheckDefFailure(['TakesOneArg(11, 22)'], 'E118:')\n  CheckDefFailure(['bufnr(xxx)'], 'E1001:')\n  CheckScriptFailure(['def Func(Ref: func(s: string))'], 'E475:')\n\n  var lines =<< trim END\n    vim9script\n    def Func(s: string)\n      echo s\n    enddef\n    Func([])\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got list<unknown>', 5)\n\n  # argument name declared earlier is found when declaring a function\n  lines =<< trim END\n    vim9script\n    var name = 'piet'\n    def FuncOne(name: string)\n      echo nr\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1168:')\n\n  # argument name declared later is only found when compiling\n  lines =<< trim END\n    vim9script\n    def FuncOne(name: string)\n      echo nr\n    enddef\n    var name = 'piet'\n  END\n  CheckScriptSuccess(lines)\n  CheckScriptFailure(lines + ['defcompile'], 'E1168:')\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne()\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  var didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E119: Not enough arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  lines =<< trim END\n    vim9script\n    def FuncOne(nr: number)\n      echo nr\n    enddef\n    def FuncTwo()\n      FuncOne(1, 2)\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xscript')\n  didCatch = false\n  try\n    source Xscript\n  catch\n    assert_match('E118: Too many arguments for function: <SNR>\\d\\+_FuncOne', v:exception)\n    assert_match('Xscript\\[8\\]..function <SNR>\\d\\+_FuncTwo, line 1', v:throwpoint)\n    didCatch = true\n  endtry\n  assert_true(didCatch)\n\n  delete('Xscript')\nenddef\n\ndef Test_call_funcref_wrong_args()\n  var head =<< trim END\n      vim9script\n      def Func3(a1: string, a2: number, a3: list<number>)\n        echo a1 .. a2 .. a3[0]\n      enddef\n      def Testme()\n        var funcMap: dict<func> = {func: Func3}\n  END\n  var tail =<< trim END\n      enddef\n      Testme()\n  END\n  CheckScriptSuccess(head + [\"funcMap['func']('str', 123, [1, 2, 3])\"] + tail)\n\n  CheckScriptFailure(head + [\"funcMap['func']('str', 123)\"] + tail, 'E119:')\n  CheckScriptFailure(head + [\"funcMap['func']('str', 123, [1], 4)\"] + tail, 'E118:')\n\n  var lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      echo Ref(false)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\n\n  lines =<< trim END\n      vim9script\n      var Ref: func(number): any\n      Ref = (j) => !j\n      call Ref(false)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got bool', 4)\nenddef\n\ndef Test_call_lambda_args()\n  var lines =<< trim END\n    var Callback = (..._) => 'anything'\n    assert_equal('anything', Callback())\n    assert_equal('anything', Callback(1))\n    assert_equal('anything', Callback('a', 2))\n\n    assert_equal('xyz', ((a: string): string => a)('xyz'))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  CheckDefFailure(['echo ((i) => 0)()'],\n                  'E119: Not enough arguments for function: ((i) => 0)()')\n\n  lines =<< trim END\n      var Ref = (x: number, y: number) => x + y\n      echo Ref(1, 'x')\n  END\n  CheckDefFailure(lines, 'E1013: Argument 2: type mismatch, expected number but got string')\n\n  lines =<< trim END\n    var Ref: func(job, string, number)\n    Ref = (x, y) => 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n    var Ref: func(job, string)\n    Ref = (x, y, z) => 0\n  END\n  CheckDefAndScriptFailure(lines, 'E1012:')\n\n  lines =<< trim END\n      var one = 1\n      var l = [1, 2, 3]\n      echo map(l, (one) => one)\n  END\n  CheckDefFailure(lines, 'E1167:')\n  CheckScriptFailure(['vim9script'] + lines, 'E1168:')\n\n  lines =<< trim END\n    var Ref: func(any, ?any): bool\n    Ref = (_, y = 1) => false\n  END\n  CheckDefAndScriptFailure(lines, 'E1172:')\n\n  lines =<< trim END\n      var a = 0\n      var b = (a == 0 ? 1 : 2)\n      assert_equal(1, b)\n      var txt = 'a'\n      b = (txt =~ 'x' ? 1 : 2)\n      assert_equal(2, b)\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      def ShadowLocal()\n        var one = 1\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n      def Shadowarg(one: number)\n        var l = [1, 2, 3]\n        echo map(l, (one) => one)\n      enddef\n  END\n  CheckDefFailure(lines, 'E1167:')\n\n  lines =<< trim END\n    echo ((a) => a)('aa', 'bb')\n  END\n  CheckDefAndScriptFailure(lines, 'E118:', 1)\n\n  lines =<< trim END\n    echo 'aa'->((a) => a)('bb')\n  END\n  CheckDefFailure(lines, 'E118: Too many arguments for function: ->((a) => a)(''bb'')', 1)\n  CheckScriptFailure(['vim9script'] + lines, 'E118: Too many arguments for function: <lambda>', 2)\nenddef\n\ndef Test_lambda_line_nr()\n  var lines =<< trim END\n      vim9script\n      # comment\n      # comment\n      var id = timer_start(1'000, (_) => 0)\n      var out = execute('verbose ' .. timer_info(id)[0].callback\n          ->string()\n          ->substitute(\"('\\\\|')\", ' ', 'g'))\n      assert_match('Last set from .* line 4', out)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef FilterWithCond(x: string, Cond: func(string): bool): bool\n  return Cond(x)\nenddef\n\ndef Test_lambda_return_type()\n  var lines =<< trim END\n    var Ref = (): => 123\n  END\n  CheckDefAndScriptFailure(lines, 'E1157:', 1)\n\n  # no space before the return type\n  lines =<< trim END\n    var Ref = (x):number => x + 1\n  END\n  CheckDefAndScriptFailure(lines, 'E1069:', 1)\n\n  # this works\n  for x in ['foo', 'boo']\n    echo FilterWithCond(x, (v) => v =~ '^b')\n  endfor\n\n  # this fails\n  lines =<< trim END\n      echo FilterWithCond('foo', (v) => v .. '^b')\n  END\n  CheckDefAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected func(string): bool but got func(any): string', 1)\n\n  lines =<< trim END\n      var Lambda1 = (x) => {\n              return x\n              }\n      assert_equal('asdf', Lambda1('asdf'))\n      var Lambda2 = (x): string => {\n              return x\n              }\n      assert_equal('foo', Lambda2('foo'))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var Lambda = (x): string => {\n              return x\n              }\n      echo Lambda(['foo'])\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_lambda_uses_assigned_var()\n  CheckDefSuccess([\n        'var x: any = \"aaa\"'\n        'x = filter([\"bbb\"], (_, v) => v =~ x)'])\nenddef\n\ndef Test_pass_legacy_lambda_to_def_func()\n  var lines =<< trim END\n      vim9script\n      func Foo()\n        eval s:Bar({x -> 0})\n      endfunc\n      def Bar(y: any)\n      enddef\n      Foo()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def g:TestFunc(f: func)\n      enddef\n      legacy call g:TestFunc({-> 0})\n      delfunc g:TestFunc\n\n      def g:TestFunc(f: func(number))\n      enddef\n      legacy call g:TestFunc({nr -> 0})\n      delfunc g:TestFunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_in_reduce_line_break()\n  # this was using freed memory\n  var lines =<< trim END\n      vim9script\n      const result: dict<number> =\n          ['Bob', 'Sam', 'Cat', 'Bob', 'Cat', 'Cat']\n          ->reduce((acc, val) => {\n              if has_key(acc, val)\n                  acc[val] += 1\n                  return acc\n              else\n                  acc[val] = 1\n                  return acc\n              endif\n          }, {})\n      assert_equal({Bob: 2, Sam: 1, Cat: 3}, result)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_lambda()\n  var lines =<< trim END\n    vim9script\n    nnoremap <expr> <F4> <SID>CountSpaces() .. '_'\n    def CountSpaces(type = ''): string\n      if type == ''\n        &operatorfunc = (t) => CountSpaces(t)\n        return 'g@'\n      endif\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"\\<F4>\", 'x')\n    assert_equal(4, g:result)\n    bwipe!\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_set_opfunc_to_global_function()\n  var lines =<< trim END\n    vim9script\n    def g:CountSpaces(type = ''): string\n      normal! '[V']y\n      g:result = getreg('\"')->count(' ')\n      return ''\n    enddef\n    # global function works at script level\n    &operatorfunc = g:CountSpaces\n    new\n    'a b c d e'->setline(1)\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    &operatorfunc = ''\n    g:result = 0\n    # global function works in :def function\n    def Func()\n      &operatorfunc = g:CountSpaces\n    enddef\n    Func()\n    feedkeys(\"g@_\", 'x')\n    assert_equal(4, g:result)\n\n    bwipe!\n  END\n  CheckScriptSuccess(lines)\n  &operatorfunc = ''\nenddef\n\ndef Test_use_script_func_name_with_prefix()\n  var lines =<< trim END\n      vim9script\n      func s:Getit()\n        return 'it'\n      endfunc\n      var Fn = s:Getit\n      assert_equal('it', Fn())\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_lambda_type_allocated()\n  # Check that unreferencing a partial using a lambda can use the variable type\n  # after the lambda has been freed and does not leak memory.\n  var lines =<< trim END\n    vim9script\n\n    func MyomniFunc1(val, findstart, base)\n      return a:findstart ? 0 : []\n    endfunc\n\n    var Lambda = (a, b) => MyomniFunc1(19, a, b)\n    &omnifunc = Lambda\n    Lambda = (a, b) => MyomniFunc1(20, a, b)\n    &omnifunc = string(Lambda)\n    Lambda = (a, b) => strlen(a)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\n\" Default arg and varargs\ndef MyDefVarargs(one: string, two = 'foo', ...rest: list<string>): string\n  var res = one .. ',' .. two\n  for s in rest\n    res ..= ',' .. s\n  endfor\n  return res\nenddef\n\ndef Test_call_def_varargs()\n  assert_fails('MyDefVarargs()', 'E119:', '', 1, 'Test_call_def_varargs')\n  MyDefVarargs('one')->assert_equal('one,foo')\n  MyDefVarargs('one', 'two')->assert_equal('one,two')\n  MyDefVarargs('one', 'two', 'three')->assert_equal('one,two,three')\n  CheckDefFailure(['MyDefVarargs(\"one\", 22)'],\n      'E1013: Argument 2: type mismatch, expected string but got number')\n  CheckDefFailure(['MyDefVarargs(\"one\", \"two\", 123)'],\n      'E1013: Argument 3: type mismatch, expected string but got number')\n\n  var lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func()\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<any>)\n        echo l\n      enddef\n      Func(0)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: any)\n        echo l\n      enddef\n      Func(0)\n  END\n  CheckScriptFailure(lines, 'E1180:', 2)\n\n  lines =<< trim END\n      vim9script\n      def Func(..._l: list<string>)\n        echo _l\n      enddef\n      Func('a', 'b', 'c')\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 2, 3)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func('a', 9)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 2: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(...l: list<string>)\n        echo l\n      enddef\n      Func(1, 'a')\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch')\n\n  lines =<< trim END\n      vim9script\n      def Func(  # some comment\n                ...l = []\n                )\n        echo l\n      enddef\n  END\n  CheckScriptFailure(lines, 'E1160:')\n\n  lines =<< trim END\n      vim9script\n      def DoIt()\n        g:Later('')\n      enddef\n      defcompile\n      def g:Later(...l:  list<number>)\n      enddef\n      DoIt()\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected number but got string')\nenddef\n\nlet s:value = ''\n\ndef FuncOneDefArg(opt = 'text')\n  s:value = opt\nenddef\n\ndef FuncTwoDefArg(nr = 123, opt = 'text'): string\n  return nr .. opt\nenddef\n\ndef FuncVarargs(...arg: list<string>): string\n  return join(arg, ',')\nenddef\n\ndef Test_func_type_varargs()\n  var RefDefArg: func(?string)\n  RefDefArg = FuncOneDefArg\n  RefDefArg()\n  s:value->assert_equal('text')\n  RefDefArg('some')\n  s:value->assert_equal('some')\n\n  var RefDef2Arg: func(?number, ?string): string\n  RefDef2Arg = FuncTwoDefArg\n  RefDef2Arg()->assert_equal('123text')\n  RefDef2Arg(99)->assert_equal('99text')\n  RefDef2Arg(77, 'some')->assert_equal('77some')\n\n  CheckDefFailure(['var RefWrong: func(string?)'], 'E1010:')\n  CheckDefFailure(['var RefWrong: func(?string, string)'], 'E1007:')\n\n  var RefVarargs: func(...list<string>): string\n  RefVarargs = FuncVarargs\n  RefVarargs()->assert_equal('')\n  RefVarargs('one')->assert_equal('one')\n  RefVarargs('one', 'two')->assert_equal('one,two')\n\n  CheckDefFailure(['var RefWrong: func(...list<string>, string)'], 'E110:')\n  CheckDefFailure(['var RefWrong: func(...list<string>, ?string)'], 'E110:')\nenddef\n\n\" Only varargs\ndef MyVarargsOnly(...args: list<string>): string\n  return join(args, ',')\nenddef\n\ndef Test_call_varargs_only()\n  MyVarargsOnly()->assert_equal('')\n  MyVarargsOnly('one')->assert_equal('one')\n  MyVarargsOnly('one', 'two')->assert_equal('one,two')\n  CheckDefFailure(['MyVarargsOnly(1)'], 'E1013: Argument 1: type mismatch, expected string but got number')\n  CheckDefFailure(['MyVarargsOnly(\"one\", 2)'], 'E1013: Argument 2: type mismatch, expected string but got number')\nenddef\n\ndef Test_using_var_as_arg()\n  var lines =<< trim END\n      def Func(x: number)\n        var x = 234\n      enddef\n  END\n  CheckDefFailure(lines, 'E1006:')\n\n  lines =<< trim END\n      def Func(Ref: number)\n        def Ref()\n        enddef\n      enddef\n  END\n  CheckDefFailure(lines, 'E1073:')\nenddef\n\ndef DictArg(arg: dict<string>)\n  arg['key'] = 'value'\nenddef\n\ndef ListArg(arg: list<string>)\n  arg[0] = 'value'\nenddef\n\ndef Test_assign_to_argument()\n  # works for dict and list\n  var d: dict<string> = {}\n  DictArg(d)\n  d['key']->assert_equal('value')\n  var l: list<string> = []\n  ListArg(l)\n  l[0]->assert_equal('value')\n\n  CheckScriptFailure(['def Func(arg: number)', 'arg = 3', 'enddef', 'defcompile'], 'E1090:')\n  delfunc! g:Func\nenddef\n\n\" These argument names are reserved in legacy functions.\ndef WithReservedNames(firstline: string, lastline: string): string\n  return firstline .. lastline\nenddef\n\ndef Test_argument_names()\n  assert_equal('OK', WithReservedNames('O', 'K'))\nenddef\n\ndef Test_call_func_defined_later()\n  g:DefinedLater('one')->assert_equal('one')\n  assert_fails('NotDefined(\"one\")', 'E117:', '', 2, 'Test_call_func_defined_later')\nenddef\n\nfunc DefinedLater(arg)\n  return a:arg\nendfunc\n\ndef Test_call_funcref()\n  g:SomeFunc('abc')->assert_equal(3)\n  assert_fails('NotAFunc()', 'E117:', '', 2, 'Test_call_funcref') # comment after call\n  assert_fails('g:NotAFunc()', 'E1085:', '', 3, 'Test_call_funcref')\n\n  var lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    var Funcref: func: number = function('RetNumber')\n    Funcref()->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def RetNumber(): number\n      return 123\n    enddef\n    def Bar(F: func: number): number\n      return F()\n    enddef\n    var Funcref = function('RetNumber')\n    Bar(Funcref)->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(number) = function('UseNumber')\n    Funcref(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def UseNumber(nr: number)\n      echo nr\n    enddef\n    var Funcref: func(string) = function('UseNumber')\n  END\n  CheckScriptFailure(lines, 'E1012: Type mismatch; expected func(string) but got func(number)')\n\n  lines =<< trim END\n    vim9script\n    def EchoNr(nr = 34)\n      g:echo = nr\n    enddef\n    var Funcref: func(?number) = function('EchoNr')\n    Funcref()\n    g:echo->assert_equal(34)\n    Funcref(123)\n    g:echo->assert_equal(123)\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def EchoList(...l: list<number>)\n      g:echo = l\n    enddef\n    var Funcref: func(...list<number>) = function('EchoList')\n    Funcref()\n    g:echo->assert_equal([])\n    Funcref(1, 2, 3)\n    g:echo->assert_equal([1, 2, 3])\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    def OptAndVar(nr: number, opt = 12, ...l: list<number>): number\n      g:optarg = opt\n      g:listarg = l\n      return nr\n    enddef\n    var Funcref: func(number, ?number, ...list<number>): number = function('OptAndVar')\n    Funcref(10)->assert_equal(10)\n    g:optarg->assert_equal(12)\n    g:listarg->assert_equal([])\n\n    Funcref(11, 22)->assert_equal(11)\n    g:optarg->assert_equal(22)\n    g:listarg->assert_equal([])\n\n    Funcref(17, 18, 1, 2, 3)->assert_equal(17)\n    g:optarg->assert_equal(18)\n    g:listarg->assert_equal([1, 2, 3])\n  END\n  CheckScriptSuccess(lines)\nenddef\n\nlet SomeFunc = function('len')\nlet NotAFunc = 'text'\n\ndef CombineFuncrefTypes()\n  # same arguments, different return type\n  var Ref1: func(bool): string\n  var Ref2: func(bool): number\n  var Ref3: func(bool): any\n  Ref3 = g:cond ? Ref1 : Ref2\n\n  # different number of arguments\n  var Refa1: func(bool): number\n  var Refa2: func(bool, number): number\n  var Refa3: func: number\n  Refa3 = g:cond ? Refa1 : Refa2\n\n  # different argument types\n  var Refb1: func(bool, string): number\n  var Refb2: func(string, number): number\n  var Refb3: func(any, any): number\n  Refb3 = g:cond ? Refb1 : Refb2\nenddef\n\ndef FuncWithForwardCall()\n  return g:DefinedEvenLater(\"yes\")\nenddef\n\ndef DefinedEvenLater(arg: string): string\n  return arg\nenddef\n\ndef Test_error_in_nested_function()\n  # Error in called function requires unwinding the call stack.\n  assert_fails('FuncWithForwardCall()', 'E1096:', '', 1, 'FuncWithForwardCall')\nenddef\n\ndef Test_nested_function_with_nextcmd()\n  var lines =<< trim END\n      vim9script\n      # Define an outer function\n      def FirstFunction()\n        # Define an inner function\n        def SecondFunction()\n          # the function has a body, a double free is detected.\n          AAAAA\n\n         # enddef followed by | or } followed by # one or more characters\n         enddef|BBBB\n      enddef\n\n      # Compile all functions\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')\nenddef\n\ndef Test_nested_function_with_args_split()\n  var lines =<< trim END\n      vim9script\n      def FirstFunction()\n        def SecondFunction(\n        )\n        # had a double free if the right parenthesis of the nested function is\n        # on the next line\n         \n        enddef|BBBB\n      enddef\n      # Compile all functions\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after enddef: BBBB')\n\n  lines =<< trim END\n      vim9script\n      def FirstFunction()\n        func SecondFunction()\n        endfunc|BBBB\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1173: Text found after endfunction: BBBB')\nenddef\n\ndef Test_error_in_function_args()\n  var lines =<< trim END\n      def FirstFunction()\n        def SecondFunction(J  =\n        # Nois\n        # one\n         \n         enddef|BBBB\n      enddef\n      # Compile all functions\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_return_type_wrong()\n  CheckScriptFailure([\n        'def Func(): number',\n        'return \"a\"',\n        'enddef',\n        'defcompile'], 'expected number but got string')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func(): string',\n        'return 1',\n        'enddef',\n        'defcompile'], 'expected string but got number')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func(): void',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n  CheckScriptFailure([\n        'def Func()',\n        'return \"a\"',\n        'enddef',\n        'defcompile'],\n        'E1096: Returning a value in a function without a return type')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func(): number',\n        'return',\n        'enddef',\n        'defcompile'], 'E1003:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func():number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1069:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func() :number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'def Func() : number',\n        'return 123',\n        'enddef',\n        'defcompile'], 'E1059:')\n  delfunc! g:Func\n\n  CheckScriptFailure(['def Func(): list', 'return []', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  CheckScriptFailure(['def Func(): dict', 'return {}', 'enddef'], 'E1008:')\n  delfunc! g:Func\n  CheckScriptFailure(['def Func()', 'return 1'], 'E1057:')\n  delfunc! g:Func\n\n  CheckScriptFailure([\n        'vim9script',\n        'def FuncB()',\n        '  return 123',\n        'enddef',\n        'def FuncA()',\n        '   FuncB()',\n        'enddef',\n        'defcompile'], 'E1096:')\nenddef\n\ndef Test_arg_type_wrong()\n  CheckScriptFailure(['def Func3(items: list)', 'echo \"a\"', 'enddef'], 'E1008: Missing <type>')\n  CheckScriptFailure(['def Func4(...)', 'echo \"a\"', 'enddef'], 'E1055: Missing name after ...')\n  CheckScriptFailure(['def Func5(items:string)', 'echo \"a\"'], 'E1069:')\n  CheckScriptFailure(['def Func5(items)', 'echo \"a\"'], 'E1077:')\n  CheckScriptFailure(['def Func6(...x:list<number>)', 'echo \"a\"', 'enddef'], 'E1069:')\n  CheckScriptFailure(['def Func7(...x: int)', 'echo \"a\"', 'enddef'], 'E1010:')\nenddef\n\ndef Test_white_space_before_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number , b: number)\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1068:')\n  call assert_fails('vim9cmd echo stridx(\"a\" .. \"b\" , \"a\")', 'E1068:')\nenddef\n\ndef Test_white_space_after_comma()\n  var lines =<< trim END\n    vim9script\n    def Func(a: number,b: number)\n    enddef\n  END\n  CheckScriptFailure(lines, 'E1069:')\n\n  # OK in legacy function\n  lines =<< trim END\n    vim9script\n    func Func(a,b)\n    endfunc\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_vim9script_call()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       name = arg\n    enddef\n    MyFunc('foobar')\n    name->assert_equal('foobar')\n\n    var str = 'barfoo'\n    str->MyFunc()\n    name->assert_equal('barfoo')\n\n    g:value = 'value'\n    g:value->MyFunc()\n    name->assert_equal('value')\n\n    var listvar = []\n    def ListFunc(arg: list<number>)\n       listvar = arg\n    enddef\n    [1, 2, 3]->ListFunc()\n    listvar->assert_equal([1, 2, 3])\n\n    var dictvar = {}\n    def DictFunc(arg: dict<number>)\n       dictvar = arg\n    enddef\n    {a: 1, b: 2}->DictFunc()\n    dictvar->assert_equal({a: 1, b: 2})\n    def CompiledDict()\n      {a: 3, b: 4}->DictFunc()\n    enddef\n    CompiledDict()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    {a: 3, b: 4}->DictFunc()\n    dictvar->assert_equal({a: 3, b: 4})\n\n    ('text')->MyFunc()\n    name->assert_equal('text')\n    (\"some\")->MyFunc()\n    name->assert_equal('some')\n\n    # line starting with single quote is not a mark\n    # line starting with double quote can be a method call\n    'asdfasdf'->MyFunc()\n    name->assert_equal('asdfasdf')\n    \"xyz\"->MyFunc()\n    name->assert_equal('xyz')\n\n    def UseString()\n      'xyork'->MyFunc()\n    enddef\n    UseString()\n    name->assert_equal('xyork')\n\n    def UseString2()\n      \"knife\"->MyFunc()\n    enddef\n    UseString2()\n    name->assert_equal('knife')\n\n    # prepending a colon makes it a mark\n    new\n    setline(1, ['aaa', 'bbb', 'ccc'])\n    normal! 3Gmt1G\n    :'t\n    getcurpos()[1]->assert_equal(3)\n    bwipe!\n\n    MyFunc(\n        'continued'\n        )\n    assert_equal('continued',\n            name\n            )\n\n    call MyFunc(\n        'more'\n          ..\n          'lines'\n        )\n    assert_equal(\n        'morelines',\n        name)\n  END\n  writefile(lines, 'Xcall.vim')\n  source Xcall.vim\n  delete('Xcall.vim')\nenddef\n\ndef Test_vim9script_call_fail_decl()\n  var lines =<< trim END\n    vim9script\n    var name = ''\n    def MyFunc(arg: string)\n       var name = 123\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E1054:')\nenddef\n\ndef Test_vim9script_call_fail_type()\n  var lines =<< trim END\n    vim9script\n    def MyFunc(arg: string)\n      echo arg\n    enddef\n    MyFunc(1234)\n  END\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected string but got number')\nenddef\n\ndef Test_vim9script_call_fail_const()\n  var lines =<< trim END\n    vim9script\n    const var = ''\n    def MyFunc(arg: string)\n       var = 'asdf'\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xcall_const.vim')\n  assert_fails('source Xcall_const.vim', 'E46:', '', 1, 'MyFunc')\n  delete('Xcall_const.vim')\n\n  lines =<< trim END\n      const g:Aconst = 77\n      def Change()\n        # comment\n        g:Aconst = 99\n      enddef\n      call Change()\n      unlet g:Aconst\n  END\n  CheckScriptFailure(lines, 'E741: Value is locked: Aconst', 2)\nenddef\n\n\" Test that inside :function a Python function can be defined, :def is not\n\" recognized.\nfunc Test_function_python()\n  CheckFeature python3\n  let py = 'python3'\n  execute py \"<< EOF\"\ndef do_something():\n  return 1\nEOF\nendfunc\n\ndef Test_delfunc()\n  var lines =<< trim END\n    vim9script\n    def g:GoneSoon()\n      echo 'hello'\n    enddef\n\n    def CallGoneSoon()\n      GoneSoon()\n    enddef\n    defcompile\n\n    delfunc g:GoneSoon\n    CallGoneSoon()\n  END\n  writefile(lines, 'XToDelFunc')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n  assert_fails('so XToDelFunc', 'E933:', '', 1, 'CallGoneSoon')\n\n  delete('XToDelFunc')\nenddef\n\nfunc Test_free_dict_while_in_funcstack()\n  \" relies on the sleep command\n  CheckUnix\n  call Run_Test_free_dict_while_in_funcstack()\nendfunc\n\ndef Run_Test_free_dict_while_in_funcstack()\n  # this was freeing the TermRun() default argument dictionary while it was\n  # still referenced in a funcstack_T\n  var lines =<< trim END\n      vim9script\n\n      &updatetime = 400\n      def TermRun(_ = {})\n          def Post()\n          enddef\n          def Exec()\n              term_start('sleep 1', {\n                  term_finish: 'close',\n                  exit_cb: (_, _) => Post(),\n              })\n          enddef\n          Exec()\n      enddef\n      nnoremap <F4> <Cmd>call <SID>TermRun()<CR>\n      timer_start(100, (_) => feedkeys(\"\\<F4>\"))\n      timer_start(1000, (_) => feedkeys(\"\\<F4>\"))\n      sleep 1500m\n  END\n  CheckScriptSuccess(lines)\n  nunmap <F4>\n  set updatetime&\nenddef\n\ndef Test_redef_failure()\n  writefile(['def Func0(): string',  'return \"Func0\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def Func1(): string',  'return \"Func1\"', 'enddef'], 'Xdef')\n  so Xdef\n  writefile(['def! Func0(): string', 'enddef', 'defcompile'], 'Xdef')\n  assert_fails('so Xdef', 'E1027:', '', 1, 'Func0')\n  writefile(['def Func2(): string',  'return \"Func2\"', 'enddef'], 'Xdef')\n  so Xdef\n  delete('Xdef')\n\n  assert_fails('g:Func0()', 'E1091:')\n  g:Func1()->assert_equal('Func1')\n  g:Func2()->assert_equal('Func2')\n\n  delfunc! Func0\n  delfunc! Func1\n  delfunc! Func2\nenddef\n\ndef Test_vim9script_func()\n  var lines =<< trim END\n    vim9script\n    func Func(arg)\n      echo a:arg\n    endfunc\n    Func('text')\n  END\n  writefile(lines, 'XVim9Func')\n  so XVim9Func\n\n  delete('XVim9Func')\nenddef\n\nlet s:funcResult = 0\n\ndef FuncNoArgNoRet()\n  s:funcResult = 11\nenddef\n\ndef FuncNoArgRetNumber(): number\n  s:funcResult = 22\n  return 1234\nenddef\n\ndef FuncNoArgRetString(): string\n  s:funcResult = 45\n  return 'text'\nenddef\n\ndef FuncOneArgNoRet(arg: number)\n  s:funcResult = arg\nenddef\n\ndef FuncOneArgRetNumber(arg: number): number\n  s:funcResult = arg\n  return arg\nenddef\n\ndef FuncTwoArgNoRet(one: bool, two: number)\n  s:funcResult = two\nenddef\n\ndef FuncOneArgRetString(arg: string): string\n  return arg\nenddef\n\ndef FuncOneArgRetAny(arg: any): any\n  return arg\nenddef\n\ndef Test_func_type()\n  var Ref1: func()\n  s:funcResult = 0\n  Ref1 = FuncNoArgNoRet\n  Ref1()\n  s:funcResult->assert_equal(11)\n\n  var Ref2: func\n  s:funcResult = 0\n  Ref2 = FuncNoArgNoRet\n  Ref2()\n  s:funcResult->assert_equal(11)\n\n  s:funcResult = 0\n  Ref2 = FuncOneArgNoRet\n  Ref2(12)\n  s:funcResult->assert_equal(12)\n\n  s:funcResult = 0\n  Ref2 = FuncNoArgRetNumber\n  Ref2()->assert_equal(1234)\n  s:funcResult->assert_equal(22)\n\n  s:funcResult = 0\n  Ref2 = FuncOneArgRetNumber\n  Ref2(13)->assert_equal(13)\n  s:funcResult->assert_equal(13)\nenddef\n\ndef Test_repeat_return_type()\n  var res = 0\n  for n in repeat([1], 3)\n    res += n\n  endfor\n  res->assert_equal(3)\n\n  res = 0\n  for n in add([1, 2], 3)\n    res += n\n  endfor\n  res->assert_equal(6)\nenddef\n\ndef Test_argv_return_type()\n  next fileone filetwo\n  var res = ''\n  for name in argv()\n    res ..= name\n  endfor\n  res->assert_equal('fileonefiletwo')\nenddef\n\ndef Test_func_type_part()\n  var RefVoid: func: void\n  RefVoid = FuncNoArgNoRet\n  RefVoid = FuncOneArgNoRet\n  CheckDefFailure(['var RefVoid: func: void', 'RefVoid = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...) but got func(): number')\n  CheckDefFailure(['var RefVoid: func: void', 'RefVoid = FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...) but got func(): string')\n\n  var RefAny: func(): any\n  RefAny = FuncNoArgRetNumber\n  RefAny = FuncNoArgRetString\n  CheckDefFailure(['var RefAny: func(): any', 'RefAny = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func()')\n  CheckDefFailure(['var RefAny: func(): any', 'RefAny = FuncOneArgNoRet'], 'E1012: Type mismatch; expected func(): any but got func(number)')\n\n  var RefAnyNoArgs: func: any = RefAny\n\n  var RefNr: func: number\n  RefNr = FuncNoArgRetNumber\n  RefNr = FuncOneArgRetNumber\n  CheckDefFailure(['var RefNr: func: number', 'RefNr = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): number but got func()')\n  CheckDefFailure(['var RefNr: func: number', 'RefNr = FuncNoArgRetString'], 'E1012: Type mismatch; expected func(...): number but got func(): string')\n\n  var RefStr: func: string\n  RefStr = FuncNoArgRetString\n  RefStr = FuncOneArgRetString\n  CheckDefFailure(['var RefStr: func: string', 'RefStr = FuncNoArgNoRet'], 'E1012: Type mismatch; expected func(...): string but got func()')\n  CheckDefFailure(['var RefStr: func: string', 'RefStr = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func(...): string but got func(): number')\nenddef\n\ndef Test_func_type_fails()\n  CheckDefFailure(['var ref1: func()'], 'E704:')\n\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncNoArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(): number')\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncOneArgNoRet'], 'E1012: Type mismatch; expected func() but got func(number)')\n  CheckDefFailure(['var Ref1: func()', 'Ref1 = FuncOneArgRetNumber'], 'E1012: Type mismatch; expected func() but got func(number): number')\n  CheckDefFailure(['var Ref1: func(bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(bool) but got func(bool, number)')\n  CheckDefFailure(['var Ref1: func(?bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(?bool) but got func(bool, number)')\n  CheckDefFailure(['var Ref1: func(...bool)', 'Ref1 = FuncTwoArgNoRet'], 'E1012: Type mismatch; expected func(...bool) but got func(bool, number)')\n\n  CheckDefFailure(['var RefWrong: func(string ,number)'], 'E1068:')\n  CheckDefFailure(['var RefWrong: func(string,number)'], 'E1069:')\n  CheckDefFailure(['var RefWrong: func(bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool)'], 'E1005:')\n  CheckDefFailure(['var RefWrong: func(bool):string'], 'E1069:')\nenddef\n\ndef Test_func_return_type()\n  var nr: number\n  nr = FuncNoArgRetNumber()\n  nr->assert_equal(1234)\n\n  nr = FuncOneArgRetAny(122)\n  nr->assert_equal(122)\n\n  var str: string\n  str = FuncOneArgRetAny('yes')\n  str->assert_equal('yes')\n\n  CheckDefFailure(['var str: string', 'str = FuncNoArgRetNumber()'], 'E1012: Type mismatch; expected string but got number')\nenddef\n\ndef Test_func_common_type()\n  def FuncOne(n: number): number\n    return n\n  enddef\n  def FuncTwo(s: string): number\n    return len(s)\n  enddef\n  def FuncThree(n: number, s: string): number\n    return n + len(s)\n  enddef\n  var list = [FuncOne, FuncTwo, FuncThree]\n  assert_equal(8, list[0](8))\n  assert_equal(4, list[1]('word'))\n  assert_equal(7, list[2](3, 'word'))\nenddef\n\ndef MultiLine(\n    arg1: string,\n    arg2 = 1234,\n    ...rest: list<string>\n      ): string\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef MultiLineComment(\n    arg1: string, # comment\n    arg2 = 1234, # comment\n    ...rest: list<string> # comment\n      ): string # comment\n  return arg1 .. arg2 .. join(rest, '-')\nenddef\n\ndef Test_multiline()\n  MultiLine('text')->assert_equal('text1234')\n  MultiLine('text', 777)->assert_equal('text777')\n  MultiLine('text', 777, 'one')->assert_equal('text777one')\n  MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nenddef\n\nfunc Test_multiline_not_vim9()\n  call MultiLine('text')->assert_equal('text1234')\n  call MultiLine('text', 777)->assert_equal('text777')\n  call MultiLine('text', 777, 'one')->assert_equal('text777one')\n  call MultiLine('text', 777, 'one', 'two')->assert_equal('text777one-two')\nendfunc\n\n\n\" When using CheckScriptFailure() for the below test, E1010 is generated instead\n\" of E1056.\nfunc Test_E1056_1059()\n  let caught_1056 = 0\n  try\n    def F():\n      return 1\n    enddef\n  catch /E1056:/\n    let caught_1056 = 1\n  endtry\n  eval caught_1056->assert_equal(1)\n\n  let caught_1059 = 0\n  try\n    def F5(items : list)\n      echo 'a'\n    enddef\n  catch /E1059:/\n    let caught_1059 = 1\n  endtry\n  eval caught_1059->assert_equal(1)\nendfunc\n\nfunc DelMe()\n  echo 'DelMe'\nendfunc\n\ndef Test_error_reporting()\n  # comment lines at the start of the function\n  var lines =<< trim END\n    \" comment\n    def Func()\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 3$')\n  endtry\n  delfunc! g:Func\n\n  # comment lines after the start of the function\n  lines =<< trim END\n    \" comment\n    def Func()\n      var x = 1234\n      # comment\n      # comment\n      invalid\n    enddef\n    defcompile\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E476:/\n    v:exception->assert_match('Invalid command: invalid')\n    v:throwpoint->assert_match(', line 4$')\n  endtry\n  delfunc! g:Func\n\n  lines =<< trim END\n    vim9script\n    def Func()\n      var db = {foo: 1, bar: 2}\n      # comment\n      var x = db.asdf\n    enddef\n    defcompile\n    Func()\n  END\n  writefile(lines, 'Xdef')\n  try\n    source Xdef\n    assert_report('should have failed')\n  catch /E716:/\n    v:throwpoint->assert_match('_Func, line 3$')\n  endtry\n  delfunc! g:Func\n\n  delete('Xdef')\nenddef\n\ndef Test_deleted_function()\n  CheckDefExecFailure([\n      'var RefMe: func = function(\"g:DelMe\")',\n      'delfunc g:DelMe',\n      'echo RefMe()'], 'E117:')\nenddef\n\ndef Test_unknown_function()\n  CheckDefExecFailure([\n      'var Ref: func = function(\"NotExist\")',\n      'delfunc g:NotExist'], 'E700:')\nenddef\n\ndef RefFunc(Ref: func(any): any): string\n  return Ref('more')\nenddef\n\ndef Test_closure_simple()\n  var local = 'some '\n  RefFunc((s) => local .. s)->assert_equal('some more')\nenddef\n\ndef MakeRef()\n  var local = 'some '\n  g:Ref = (s) => local .. s\nenddef\n\ndef Test_closure_ref_after_return()\n  MakeRef()\n  g:Ref('thing')->assert_equal('some thing')\n  unlet g:Ref\nenddef\n\ndef MakeTwoRefs()\n  var local = ['some']\n  g:Extend = (s) => local->add(s)\n  g:Read = () => local\nenddef\n\ndef Test_closure_two_refs()\n  MakeTwoRefs()\n  join(g:Read(), ' ')->assert_equal('some')\n  g:Extend('more')\n  join(g:Read(), ' ')->assert_equal('some more')\n  g:Extend('even')\n  join(g:Read(), ' ')->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef ReadRef(Ref: func(): list<string>): string\n  return join(Ref(), ' ')\nenddef\n\ndef ExtendRef(Ref: func(string): list<string>, add: string)\n  Ref(add)\nenddef\n\ndef Test_closure_two_indirect_refs()\n  MakeTwoRefs()\n  ReadRef(g:Read)->assert_equal('some')\n  ExtendRef(g:Extend, 'more')\n  ReadRef(g:Read)->assert_equal('some more')\n  ExtendRef(g:Extend, 'even')\n  ReadRef(g:Read)->assert_equal('some more even')\n\n  unlet g:Extend\n  unlet g:Read\nenddef\n\ndef MakeArgRefs(theArg: string)\n  var local = 'loc_val'\n  g:UseArg = (s) => theArg .. '/' .. local .. '/' .. s\nenddef\n\ndef MakeArgRefsVarargs(theArg: string, ...rest: list<string>)\n  var local = 'the_loc'\n  g:UseVararg = (s) => theArg .. '/' .. local .. '/' .. s .. '/' .. join(rest)\nenddef\n\ndef Test_closure_using_argument()\n  MakeArgRefs('arg_val')\n  g:UseArg('call_val')->assert_equal('arg_val/loc_val/call_val')\n\n  MakeArgRefsVarargs('arg_val', 'one', 'two')\n  g:UseVararg('call_val')->assert_equal('arg_val/the_loc/call_val/one two')\n\n  unlet g:UseArg\n  unlet g:UseVararg\n\n  var lines =<< trim END\n      vim9script\n      def Test(Fun: func(number): number): list<number>\n        return map([1, 2, 3], (_, i) => Fun(i))\n      enddef\n      def Inc(nr: number): number\n        return nr + 2\n      enddef\n      assert_equal([3, 4, 5], Test(Inc))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef MakeGetAndAppendRefs()\n  var local = 'a'\n\n  def Append(arg: string)\n    local ..= arg\n  enddef\n  g:Append = Append\n\n  def Get(): string\n    return local\n  enddef\n  g:Get = Get\nenddef\n\ndef Test_closure_append_get()\n  MakeGetAndAppendRefs()\n  g:Get()->assert_equal('a')\n  g:Append('-b')\n  g:Get()->assert_equal('a-b')\n  g:Append('-c')\n  g:Get()->assert_equal('a-b-c')\n\n  unlet g:Append\n  unlet g:Get\nenddef\n\ndef Test_nested_closure()\n  var local = 'text'\n  def Closure(arg: string): string\n    return local .. arg\n  enddef\n  Closure('!!!')->assert_equal('text!!!')\nenddef\n\nfunc GetResult(Ref)\n  return a:Ref('some')\nendfunc\n\ndef Test_call_closure_not_compiled()\n  var text = 'text'\n  g:Ref = (s) =>  s .. text\n  GetResult(g:Ref)->assert_equal('sometext')\nenddef\n\ndef Test_double_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var name = 0\n      for i in range(2)\n          timer_start(0, () => name)\n      endfor\n    enddef\n    Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_used()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = 'hello'\n        var Closure = () => x\n        g:Myclosure = () => Closure()\n      enddef\n      Func()\n      assert_equal('hello', g:Myclosure())\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_closure_fails()\n  var lines =<< trim END\n    vim9script\n    def FuncA()\n      FuncB(0)\n    enddef\n    def FuncB(n: number): list<string>\n      return map([0], (_, v) => n)\n    enddef\n    FuncA()\n  END\n  CheckScriptFailure(lines, 'E1012:')\nenddef\n\ndef Test_global_closure()\n  var lines =<< trim END\n      vim9script\n      def ReverseEveryNLines(n: number, line1: number, line2: number)\n        var mods = 'sil keepj keepp lockm '\n        var range = ':' .. line1 .. ',' .. line2\n        def g:Offset(): number\n            var offset = (line('.') - line1 + 1) % n\n            return offset != 0 ? offset : n\n        enddef\n        exe mods .. range .. 'g/^/exe \"m .-\" .. g:Offset()'\n      enddef\n\n      new\n      repeat(['aaa', 'bbb', 'ccc'], 3)->setline(1)\n      ReverseEveryNLines(3, 1, 9)\n  END\n  CheckScriptSuccess(lines)\n  var expected = repeat(['ccc', 'bbb', 'aaa'], 3)\n  assert_equal(expected, getline(1, 9))\n  bwipe!\nenddef\n\ndef Test_global_closure_called_directly()\n  var lines =<< trim END\n      vim9script\n      def Outer()\n        var x = 1\n        def g:Inner()\n          var y = x\n          x += 1\n          assert_equal(1, y)\n        enddef\n        g:Inner()\n        assert_equal(2, x)\n      enddef\n      Outer()\n  END\n  CheckScriptSuccess(lines)\n  delfunc g:Inner\nenddef\n\ndef Test_closure_called_from_legacy()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var outer = 'foo'\n        var F = () => {\n              outer = 'bar'\n            }\n        execute printf('call %s()', string(F))\n      enddef\n      Func()\n  END\n  CheckScriptFailure(lines, 'E1248')\nenddef\n\ndef Test_failure_in_called_function()\n  # this was using the frame index as the return value\n  var lines =<< trim END\n      vim9script\n      au TerminalWinOpen * eval [][0]\n      def PopupTerm(a: any)\n        # make sure typvals on stack are string\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']->join()\n        FireEvent()\n      enddef\n      def FireEvent()\n          do TerminalWinOpen\n      enddef\n      # use try/catch to make eval fail\n      try\n          call PopupTerm(0)\n      catch\n      endtry\n      au! TerminalWinOpen\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_lambda()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      var x = 4\n      var Lambda1 = () => 7\n      var Lambda2 = () => [Lambda1(), x]\n      var res = Lambda2()\n      assert_equal([7, 4], res)\n    enddef\n    Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_double_nested_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(head: string): func(string): func(string): string\n        return (sep: string): func(string): string => ((tail: string): string => {\n            return head .. sep .. tail\n          })\n      enddef\n      assert_equal('hello-there', F('hello')('-')('there'))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_nested_inline_lambda()\n  var lines =<< trim END\n      vim9script\n      def F(text: string): func(string): func(string): string\n        return (arg: string): func(string): string => ((sep: string): string => {\n            return sep .. arg .. text\n          })\n      enddef\n      assert_equal('--there++', F('++')('there')('--'))\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      echo range(4)->mapnew((_, v) => {\n        return range(v) ->mapnew((_, s) => {\n          return string(s)\n          })\n        })\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      def s:func()\n        range(10)\n          ->mapnew((_, _) => ({\n            key: range(10)->mapnew((_, _) => {\n              return ' '\n            }),\n          }))\n      enddef\n\n      defcomp\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Shadowed(): list<number>\n  var FuncList: list<func: number> = [() => 42]\n  return FuncList->mapnew((_, Shadowed) => Shadowed())\nenddef\n\ndef Test_lambda_arg_shadows_func()\n  assert_equal([42], Shadowed())\nenddef\n\ndef Line_continuation_in_def(dir: string = ''): string\n  var path: string = empty(dir)\n          \\ ? 'empty'\n          \\ : 'full'\n  return path\nenddef\n\ndef Test_line_continuation_in_def()\n  Line_continuation_in_def('.')->assert_equal('full')\nenddef\n\ndef Test_script_var_in_lambda()\n  var lines =<< trim END\n      vim9script\n      var script = 'test'\n      assert_equal(['test'], map(['one'], (_, _) => script))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Line_continuation_in_lambda(): list<string>\n  var x = range(97, 100)\n      ->mapnew((_, v) => nr2char(v)\n          ->toupper())\n      ->reverse()\n  return x\nenddef\n\ndef Test_line_continuation_in_lambda()\n  Line_continuation_in_lambda()->assert_equal(['D', 'C', 'B', 'A'])\n\n  var lines =<< trim END\n      vim9script\n      var res = [{n: 1, m: 2, s: 'xxx'}]\n                ->mapnew((_, v: dict<any>): string => printf('%d:%d:%s',\n                    v.n,\n                    v.m,\n                    substitute(v.s, '.*', 'yyy', '')\n                    ))\n      assert_equal(['1:2:yyy'], res)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_lambda()\n  timer_start(1000, (_) => 0)\n  var body = execute(timer_info()[0].callback\n         ->string()\n         ->substitute(\"('\", ' ', '')\n         ->substitute(\"')\", '', '')\n         ->substitute('function\\zs', ' ', ''))\n  assert_match('def <lambda>\\d\\+(_: any): number\\n1  return 0\\n   enddef', body)\nenddef\n\ndef Test_lambda_block_variable()\n  var lines =<< trim END\n      vim9script\n      var flist: list<func>\n      for i in range(10)\n          var inloop = i\n          flist[i] = () => inloop\n      endfor\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n        var flist: list<func>\n        for i in range(10)\n          flist[i] = () => outloop\n        endfor\n      endif\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      if true\n        var outloop = 5\n      endif\n      var flist: list<func>\n      for i in range(10)\n        flist[i] = () => outloop\n      endfor\n  END\n  CheckScriptFailure(lines, 'E1001: Variable not found: outloop', 1)\n\n  lines =<< trim END\n      vim9script\n      for i in range(10)\n        var Ref = () => 0\n      endfor\n      assert_equal(0, ((i) => 0)(0))\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_lambda()\n  legacy echo {x -> 'hello ' .. x}('foo')\n\n  var lines =<< trim END\n      echo {x -> 'hello ' .. x}('foo')\n  END\n  CheckDefAndScriptFailure(lines, 'E720:')\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        echo (() => 'no error')()\n      enddef\n      legacy call s:Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy()\n  var lines =<< trim END\n      vim9script\n      func g:LegacyFunction()\n        let g:legacyvar = 1\n      endfunc\n      def Testit()\n        legacy call g:LegacyFunction()\n      enddef\n      Testit()\n      assert_equal(1, g:legacyvar)\n      unlet g:legacyvar\n      delfunc g:LegacyFunction\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_legacy_errors()\n  for cmd in ['if', 'elseif', 'else', 'endif',\n              'for', 'endfor', 'continue', 'break',\n              'while', 'endwhile',\n              'try', 'catch', 'finally', 'endtry']\n    CheckDefFailure(['legacy ' .. cmd .. ' expr'], 'E1189:')\n  endfor\nenddef\n\ndef Test_call_legacy_with_dict()\n  var lines =<< trim END\n      vim9script\n      func Legacy() dict\n        let g:result = self.value\n      endfunc\n      def TestDirect()\n        var d = {value: 'yes', func: Legacy}\n        d.func()\n      enddef\n      TestDirect()\n      assert_equal('yes', g:result)\n      unlet g:result\n\n      def TestIndirect()\n        var d = {value: 'foo', func: Legacy}\n        var Fi = d.func\n        Fi()\n      enddef\n      TestIndirect()\n      assert_equal('foo', g:result)\n      unlet g:result\n\n      var d = {value: 'bar', func: Legacy}\n      d.func()\n      assert_equal('bar', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef DoFilterThis(a: string): list<string>\n  # closure nested inside another closure using argument\n  var Filter = (l) => filter(l, (_, v) => stridx(v, a) == 0)\n  return ['x', 'y', 'a', 'x2', 'c']->Filter()\nenddef\n\ndef Test_nested_closure_using_argument()\n  assert_equal(['x', 'x2'], DoFilterThis('x'))\nenddef\n\ndef Test_triple_nested_closure()\n  var what = 'x'\n  var Match = (val: string, cmp: string): bool => stridx(val, cmp) == 0\n  var Filter = (l) => filter(l, (_, v) => Match(v, what))\n  assert_equal(['x', 'x2'], ['x', 'y', 'a', 'x2', 'c']->Filter())\nenddef\n\nfunc Test_silent_echo()\n  CheckScreendump\n  call Run_Test_silent_echo()\nendfunc\n\ndef Run_Test_silent_echo()\n  var lines =<< trim END\n    vim9script\n    def EchoNothing()\n      silent echo ''\n    enddef\n    defcompile\n  END\n  writefile(lines, 'XTest_silent_echo')\n\n  # Check that the balloon shows up after a mouse move\n  var buf = RunVimInTerminal('-S XTest_silent_echo', {'rows': 6})\n  term_sendkeys(buf, \":abc\")\n  VerifyScreenDump(buf, 'Test_vim9_silent_echo', {})\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_silent_echo')\nenddef\n\ndef SilentlyError()\n  execute('silent! invalid')\n  g:did_it = 'yes'\nenddef\n\nfunc UserError()\n  silent! invalid\nendfunc\n\ndef SilentlyUserError()\n  UserError()\n  g:did_it = 'yes'\nenddef\n\n\" This can't be a :def function, because the assert would not be reached.\nfunc Test_ignore_silent_error()\n  let g:did_it = 'no'\n  call SilentlyError()\n  call assert_equal('yes', g:did_it)\n\n  let g:did_it = 'no'\n  call SilentlyUserError()\n  call assert_equal('yes', g:did_it)\n\n  unlet g:did_it\nendfunc\n\ndef Test_ignore_silent_error_in_filter()\n  var lines =<< trim END\n      vim9script\n      def Filter(winid: number, key: string): bool\n          if key == 'o'\n              silent! eval [][0]\n              return true\n          endif\n          return popup_filter_menu(winid, key)\n      enddef\n\n      popup_create('popup', {filter: Filter})\n      feedkeys(\"o\\r\", 'xnt')\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Fibonacci(n: number): number\n  if n < 2\n    return n\n  else\n    return Fibonacci(n - 1) + Fibonacci(n - 2)\n  endif\nenddef\n\ndef Test_recursive_call()\n  Fibonacci(20)->assert_equal(6765)\nenddef\n\ndef TreeWalk(dir: string): list<any>\n  return readdir(dir)->mapnew((_, val) =>\n            fnamemodify(dir .. '/' .. val, ':p')->isdirectory()\n               ? {[val]: TreeWalk(dir .. '/' .. val)}\n               : val\n             )\nenddef\n\ndef Test_closure_in_map()\n  mkdir('XclosureDir/tdir', 'p')\n  writefile(['111'], 'XclosureDir/file1')\n  writefile(['222'], 'XclosureDir/file2')\n  writefile(['333'], 'XclosureDir/tdir/file3')\n\n  TreeWalk('XclosureDir')->assert_equal(['file1', 'file2', {tdir: ['file3']}])\n\n  delete('XclosureDir', 'rf')\nenddef\n\ndef Test_invalid_function_name()\n  var lines =<< trim END\n      vim9script\n      def s: list<string>\n  END\n  CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def g: list<string>\n  END\n  CheckScriptFailure(lines, 'E129:')\n\n  lines =<< trim END\n      vim9script\n      def <SID>: list<string>\n  END\n  CheckScriptFailure(lines, 'E884:')\n\n  lines =<< trim END\n      vim9script\n      def F list<string>\n  END\n  CheckScriptFailure(lines, 'E488:')\nenddef\n\ndef Test_partial_call()\n  var lines =<< trim END\n      var Xsetlist: func\n      Xsetlist = function('setloclist', [0])\n      Xsetlist([], ' ', {title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setloclist', [0, [], ' '])\n      Xsetlist({title: 'test'})\n      getloclist(0, {title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist')\n      Xsetlist([], ' ', {title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      Xsetlist = function('setqflist', [[], ' '])\n      Xsetlist({title: 'test'})\n      getqflist({title: 1})->assert_equal({title: 'test'})\n\n      var Len: func: number = function('len', ['word'])\n      assert_equal(4, Len())\n\n      var RepeatFunc = function('repeat', ['o'])\n      assert_equal('ooooo', RepeatFunc(5))\n  END\n  CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(Parser: any)\n      enddef\n      var Expr: func(dict<any>): dict<any>\n      const Call = Foo(Expr)\n  END\n  CheckScriptFailure(lines, 'E1235:')\nenddef\n\ndef Test_cmd_modifier()\n  tab echo '0'\n  CheckDefFailure(['5tab echo 3'], 'E16:')\nenddef\n\ndef Test_restore_modifiers()\n  # check that when compiling a :def function command modifiers are not messed\n  # up.\n  var lines =<< trim END\n      vim9script\n      set eventignore=\n      autocmd QuickFixCmdPost * copen\n      def AutocmdsDisabled()\n        eval 1 + 2\n      enddef\n      func Func()\n        noautocmd call s:AutocmdsDisabled()\n        let g:ei_after = &eventignore\n      endfunc\n      Func()\n  END\n  CheckScriptSuccess(lines)\n  g:ei_after->assert_equal('')\nenddef\n\ndef StackTop()\n  eval 1 + 2\n  eval 2 + 3\n  # call not on fourth line\n  StackBot()\nenddef\n\ndef StackBot()\n  # throw an error\n  eval [][0]\nenddef\n\ndef Test_callstack_def()\n  try\n    StackTop()\n  catch\n    v:throwpoint->assert_match('Test_callstack_def\\[2\\]..StackTop\\[4\\]..StackBot, line 2')\n  endtry\nenddef\n\n\" Re-using spot for variable used in block\ndef Test_block_scoped_var()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var x = ['a', 'b', 'c']\n        if 1\n          var y = 'x'\n          map(x, (_, _) => y)\n        endif\n        var z = x\n        assert_equal(['x', 'x', 'x'], z)\n      enddef\n      Func()\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_reset_did_emsg()\n  var lines =<< trim END\n      @s = 'blah'\n      au BufWinLeave * #\n      def Func()\n        var winid = popup_create('popup', {})\n        exe '*s'\n        popup_close(winid)\n      enddef\n      Func()\n  END\n  CheckScriptFailure(lines, 'E492:', 8)\n  delfunc! g:Func\nenddef\n\ndef Test_did_emsg_reset()\n  # executing an autocommand resets did_emsg, this should not result in a\n  # builtin function considered failing\n  var lines =<< trim END\n      vim9script\n      au BufWinLeave * #\n      def Func()\n          popup_menu('', {callback: (a, b) => popup_create('', {})->popup_close()})\n          eval [][0]\n      enddef\n      nno <F3> <cmd>call <sid>Func()<cr>\n      feedkeys(\"\\<F3>\\e\", 'xt')\n  END\n  writefile(lines, 'XemsgReset')\n  assert_fails('so XemsgReset', ['E684:', 'E684:'], lines, 2)\n  delete('XemsgReset')\n  nunmap <F3>\n  au! BufWinLeave\nenddef\n\ndef Test_abort_with_silent_call()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, but function aborts on error\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_continues_with_silent_error()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        silent!  g:result += 3\n        g:result = 'yes'\n      enddef\n      # error is silenced, function does not abort\n      Func()\n      assert_equal('yes', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_abort_even_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      def Func()\n        eval {-> ''}() .. '' .. {}['X']\n        g:result = 'yes'\n      enddef\n      silent! Func()\n      assert_equal('none', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_cmdmod_silent_restored()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        g:result = 'none'\n        silent! g:result += 3\n        g:result = 'none'\n        g:result += 3\n      enddef\n      Func()\n  END\n  # can't use CheckScriptFailure, it ignores the :silent!\n  var fname = 'Xdefsilent'\n  writefile(lines, fname)\n  var caught = 'no'\n  try\n    exe 'source ' .. fname\n  catch /E1030:/\n    caught = 'yes'\n    assert_match('Func, line 4', v:throwpoint)\n  endtry\n  assert_equal('yes', caught)\n  delete(fname)\nenddef\n\ndef Test_cmdmod_silent_nested()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n\n      def Error()\n          result ..= 'Eb'\n          eval [][0]\n          result ..= 'Ea'\n      enddef\n\n      def Crash()\n          result ..= 'Cb'\n          sil! Error()\n          result ..= 'Ca'\n      enddef\n\n      Crash()\n      assert_equal('CbEbEaCa', result)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_dict_member_with_silent()\n  var lines =<< trim END\n      vim9script\n      g:result = 'none'\n      var d: dict<any>\n      def Func()\n        try\n          g:result = map([], (_, v) => ({}[v]))->join() .. d['']\n        catch\n        endtry\n      enddef\n      silent! Func()\n      assert_equal('0', g:result)\n      unlet g:result\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_skip_cmds_with_silent()\n  var lines =<< trim END\n      vim9script\n\n      def Func(b: bool)\n        Crash()\n      enddef\n\n      def Crash()\n        sil! :/not found/d _\n        sil! :/not found/put _\n      enddef\n\n      Func(true)\n  END\n  CheckScriptSuccess(lines)\nenddef\n\ndef Test_opfunc()\n  nnoremap <F3> <cmd>set opfunc=Opfunc<cr>g@\n  def g:Opfunc(_: any): string\n    setline(1, 'ASDF')\n    return ''\n  enddef\n  new\n  setline(1, 'asdf')\n  feedkeys(\"\\<F3>$\", 'x')\n  assert_equal('ASDF', getline(1))\n\n  bwipe!\n  nunmap <F3>\nenddef\n\nfunc Test_opfunc_error()\n  CheckScreendump\n  call Run_Test_opfunc_error()\nendfunc\n\ndef Run_Test_opfunc_error()\n  # test that the error from Opfunc() is displayed right away\n  var lines =<< trim END\n      vim9script\n\n      def Opfunc(type: string)\n        try\n          eval [][0]\n        catch /nothing/  # error not caught\n        endtry\n      enddef\n      &operatorfunc = Opfunc\n      nnoremap <expr> l <SID>L()\n      def L(): string\n        return 'l'\n      enddef\n      'x'->repeat(10)->setline(1)\n      feedkeys('g@l', 'n')\n      feedkeys('llll')\n  END\n  call writefile(lines, 'XTest_opfunc_error')\n\n  var buf = RunVimInTerminal('-S XTest_opfunc_error', {rows: 6, wait_for_ruler: 0})\n  WaitForAssert(() => assert_match('Press ENTER', term_getline(buf, 6)))\n  WaitForAssert(() => assert_match('E684: list index out of range: 0', term_getline(buf, 5)))\n\n  # clean up\n  StopVimInTerminal(buf)\n  delete('XTest_opfunc_error')\nenddef\n\n\" this was crashing on exit\ndef Test_nested_lambda_in_closure()\n  var lines =<< trim END\n      vim9script\n      command WriteDone writefile(['Done'], 'XnestedDone')\n      def Outer()\n          def g:Inner()\n              echo map([1, 2, 3], {_, v -> v + 1})\n          enddef\n          g:Inner()\n      enddef\n      defcompile\n      # not reached\n  END\n  if !RunVim([], lines, '--clean -c WriteDone -c quit')\n    return\n  endif\n  assert_equal(['Done'], readfile('XnestedDone'))\n  delete('XnestedDone')\nenddef\n\ndef Test_check_func_arg_types()\n  var lines =<< trim END\n      vim9script\n      def F1(x: string): string\n        return x\n      enddef\n\n      def F2(x: number): number\n        return x + 1\n      enddef\n\n      def G(g: func): dict<func>\n        return {f: g}\n      enddef\n\n      def H(d: dict<func>): string\n        return d.f('a')\n      enddef\n  END\n\n  CheckScriptSuccess(lines + ['echo H(G(F1))'])\n  CheckScriptFailure(lines + ['echo H(G(F2))'], 'E1013:')\nenddef\n\ndef Test_list_any_type_checked()\n  var lines =<< trim END\n      vim9script\n      def Foo()\n        --decl--\n        Bar(l)\n      enddef\n      def Bar(ll: list<dict<any>>)\n      enddef\n      Foo()\n  END\n  lines[2] = 'var l: list<any>'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<any>', 2)\n\n  lines[2] = 'var l: list<any> = []'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<any>', 2)\n\n  lines[2] = 'var l: list<any> = [11]'\n  CheckScriptFailure(lines, 'E1013: Argument 1: type mismatch, expected list<dict<any>> but got list<number>', 2)\nenddef\n\ndef Test_compile_error()\n  var lines =<< trim END\n    def g:Broken()\n      echo 'a' + {}\n    enddef\n    call g:Broken()\n  END\n  # First call: compilation error\n  CheckScriptFailure(lines, 'E1051: Wrong argument type for +')\n\n  # Second call won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\n\n  # No error when compiling with :silent!\n  lines =<< trim END\n    def g:Broken()\n      echo 'a' + []\n    enddef\n    silent! defcompile\n  END\n  CheckScriptSuccess(lines)\n\n  # Calling the function won't try compiling again\n  assert_fails('call g:Broken()', 'E1091: Function is not compiled: Broken')\n  delfunc g:Broken\nenddef\n\ndef Test_ignored_argument()\n  var lines =<< trim END\n      vim9script\n      def Ignore(_, _): string\n        return 'yes'\n      enddef\n      assert_equal('yes', Ignore(1, 2))\n\n      func Ok(_)\n        return a:_\n      endfunc\n      assert_equal('ok', Ok('ok'))\n\n      func Oktoo()\n        let _ = 'too'\n        return _\n      endfunc\n      assert_equal('too', Oktoo())\n\n      assert_equal([[1], [2], [3]], range(3)->mapnew((_, v) => [v]->map((_, w) => w + 1)))\n  END\n  CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      def Ignore(_: string): string\n        return _\n      enddef\n      defcompile\n  END\n  CheckScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var _ = 1\n  END\n  CheckDefAndScriptFailure(lines, 'E1181:', 1)\n\n  lines =<< trim END\n      var x = _\n  END\n  CheckDefAndScriptFailure(lines, 'E1181:', 1)\nenddef\n\ndef Test_too_many_arguments()\n  var lines =<< trim END\n    echo [0, 1, 2]->map(() => 123)\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1106: 2 arguments too many', 1)\n\n  lines =<< trim END\n    echo [0, 1, 2]->map((_) => 123)\n  END\n  CheckDefExecAndScriptFailure(lines, 'E1106: One argument too many', 1)\nenddef\n\ndef Test_closing_brace_at_start_of_line()\n  var lines =<< trim END\n      def Func()\n      enddef\n      Func(\n      )\n  END\n  call CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc CreateMydict()\n  let g:mydict = {}\n  func g:mydict.afunc()\n    let g:result = self.key\n  endfunc\nendfunc\n\ndef Test_numbered_function_reference()\n  CreateMydict()\n  var output = execute('legacy func g:mydict.afunc')\n  var funcName = 'g:' .. substitute(output, '.*function \\(\\d\\+\\).*', '\\1', '')\n  execute 'function(' .. funcName .. ', [], {key: 42})()'\n  # check that the function still exists\n  assert_equal(output, execute('legacy func g:mydict.afunc'))\n  unlet g:mydict\nenddef\n\ndef Test_go_beyond_end_of_cmd()\n  # this was reading the byte after the end of the line\n  var lines =<< trim END\n    def F()\n      cal\n    enddef\n    defcompile\n  END\n  CheckScriptFailure(lines, 'E476:')\nenddef\n\nif has('python3')\n  def Test_python3_heredoc()\n    py3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'yes'\n    EOF\n    assert_equal('yes', g:didit)\n\n    python3 << trim EOF\n      import vim\n      vim.vars['didit'] = 'again'\n    EOF\n    assert_equal('again', g:didit)\n  enddef\nendif\n\n\" This messes up syntax highlight, keep near the end.\nif has('lua')\n  def Test_lua_heredoc()\n    g:d = {}\n    lua << trim EOF\n        x = vim.eval('g:d')\n        x['key'] = 'val'\n    EOF\n    assert_equal('val', g:d.key)\n  enddef\nendif\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * usercmd.c: User defined command support\n */\n\n#include \"vim.h\"\n\ntypedef struct ucmd\n{\n    char_u\t*uc_name;\t// The command name\n    long_u\tuc_argt;\t// The argument type\n    char_u\t*uc_rep;\t// The command's replacement string\n    long\tuc_def;\t\t// The default value for a range/count\n    int\t\tuc_compl;\t// completion type\n    cmd_addr_T\tuc_addr_type;\t// The command's address type\n    sctx_T\tuc_script_ctx;\t// SCTX where the command was defined\n# ifdef FEAT_EVAL\n    char_u\t*uc_compl_arg;\t// completion argument if any\n# endif\n} ucmd_T;\n\n// List of all user commands.\nstatic garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};\n\n#define USER_CMD(i) (&((ucmd_T *)(ucmds.ga_data))[i])\n#define USER_CMD_GA(gap, i) (&((ucmd_T *)((gap)->ga_data))[i])\n\n/*\n * List of names for completion for \":command\" with the EXPAND_ flag.\n * Must be alphabetical for completion.\n */\nstatic struct\n{\n    int\t    expand;\n    char    *name;\n} command_complete[] =\n{\n    {EXPAND_ARGLIST, \"arglist\"},\n    {EXPAND_AUGROUP, \"augroup\"},\n    {EXPAND_BEHAVE, \"behave\"},\n    {EXPAND_BUFFERS, \"buffer\"},\n    {EXPAND_COLORS, \"color\"},\n    {EXPAND_COMMANDS, \"command\"},\n    {EXPAND_COMPILER, \"compiler\"},\n#if defined(FEAT_CSCOPE)\n    {EXPAND_CSCOPE, \"cscope\"},\n#endif\n#if defined(FEAT_EVAL)\n    {EXPAND_USER_DEFINED, \"custom\"},\n    {EXPAND_USER_LIST, \"customlist\"},\n#endif\n    {EXPAND_DIFF_BUFFERS, \"diff_buffer\"},\n    {EXPAND_DIRECTORIES, \"dir\"},\n    {EXPAND_ENV_VARS, \"environment\"},\n    {EXPAND_EVENTS, \"event\"},\n    {EXPAND_EXPRESSION, \"expression\"},\n    {EXPAND_FILES, \"file\"},\n    {EXPAND_FILES_IN_PATH, \"file_in_path\"},\n    {EXPAND_FILETYPE, \"filetype\"},\n    {EXPAND_FUNCTIONS, \"function\"},\n    {EXPAND_HELP, \"help\"},\n    {EXPAND_HIGHLIGHT, \"highlight\"},\n    {EXPAND_HISTORY, \"history\"},\n#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)\n    {EXPAND_LOCALES, \"locale\"},\n#endif\n    {EXPAND_MAPCLEAR, \"mapclear\"},\n    {EXPAND_MAPPINGS, \"mapping\"},\n    {EXPAND_MENUS, \"menu\"},\n    {EXPAND_MESSAGES, \"messages\"},\n    {EXPAND_OWNSYNTAX, \"syntax\"},\n#if defined(FEAT_PROFILE)\n    {EXPAND_SYNTIME, \"syntime\"},\n#endif\n    {EXPAND_SETTINGS, \"option\"},\n    {EXPAND_PACKADD, \"packadd\"},\n    {EXPAND_SHELLCMD, \"shellcmd\"},\n#if defined(FEAT_SIGNS)\n    {EXPAND_SIGN, \"sign\"},\n#endif\n    {EXPAND_TAGS, \"tag\"},\n    {EXPAND_TAGS_LISTFILES, \"tag_listfiles\"},\n    {EXPAND_USER, \"user\"},\n    {EXPAND_USER_VARS, \"var\"},\n    {0, NULL}\n};\n\n/*\n * List of names of address types.  Must be alphabetical for completion.\n */\nstatic struct\n{\n    cmd_addr_T\texpand;\n    char\t*name;\n    char\t*shortname;\n} addr_type_complete[] =\n{\n    {ADDR_ARGUMENTS, \"arguments\", \"arg\"},\n    {ADDR_LINES, \"lines\", \"line\"},\n    {ADDR_LOADED_BUFFERS, \"loaded_buffers\", \"load\"},\n    {ADDR_TABS, \"tabs\", \"tab\"},\n    {ADDR_BUFFERS, \"buffers\", \"buf\"},\n    {ADDR_WINDOWS, \"windows\", \"win\"},\n    {ADDR_QUICKFIX, \"quickfix\", \"qf\"},\n    {ADDR_OTHER, \"other\", \"?\"},\n    {ADDR_NONE, NULL, NULL}\n};\n\n/*\n * Search for a user command that matches \"eap->cmd\".\n * Return cmdidx in \"eap->cmdidx\", flags in \"eap->argt\", idx in \"eap->useridx\".\n * Return a pointer to just after the command.\n * Return NULL if there is no matching command.\n */\n    char_u *\nfind_ucmd(\n    exarg_T\t*eap,\n    char_u\t*p,\t// end of the command (possibly including count)\n    int\t\t*full,\t// set to TRUE for a full match\n    expand_T\t*xp,\t// used for completion, NULL otherwise\n    int\t\t*complp UNUSED)\t// completion flags or NULL\n{\n    int\t\tlen = (int)(p - eap->cmd);\n    int\t\tj, k, matchlen = 0;\n    ucmd_T\t*uc;\n    int\t\tfound = FALSE;\n    int\t\tpossible = FALSE;\n    char_u\t*cp, *np;\t    // Point into typed cmd and test name\n    garray_T\t*gap;\n    int\t\tamb_local = FALSE;  // Found ambiguous buffer-local command,\n\t\t\t\t    // only full match global is accepted.\n\n    /*\n     * Look for buffer-local user commands first, then global ones.\n     */\n    gap =\n#ifdef FEAT_CMDWIN\n\tis_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :\n#endif\n\t&curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (j = 0; j < gap->ga_len; ++j)\n\t{\n\t    uc = USER_CMD_GA(gap, j);\n\t    cp = eap->cmd;\n\t    np = uc->uc_name;\n\t    k = 0;\n\t    while (k < len && *np != NUL && *cp++ == *np++)\n\t\tk++;\n\t    if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k])))\n\t    {\n\t\t// If finding a second match, the command is ambiguous.  But\n\t\t// not if a buffer-local command wasn't a full match and a\n\t\t// global command is a full match.\n\t\tif (k == len && found && *np != NUL)\n\t\t{\n\t\t    if (gap == &ucmds)\n\t\t\treturn NULL;\n\t\t    amb_local = TRUE;\n\t\t}\n\n\t\tif (!found || (k == len && *np == NUL))\n\t\t{\n\t\t    // If we matched up to a digit, then there could\n\t\t    // be another command including the digit that we\n\t\t    // should use instead.\n\t\t    if (k == len)\n\t\t\tfound = TRUE;\n\t\t    else\n\t\t\tpossible = TRUE;\n\n\t\t    if (gap == &ucmds)\n\t\t\teap->cmdidx = CMD_USER;\n\t\t    else\n\t\t\teap->cmdidx = CMD_USER_BUF;\n\t\t    eap->argt = (long)uc->uc_argt;\n\t\t    eap->useridx = j;\n\t\t    eap->addr_type = uc->uc_addr_type;\n\n\t\t    if (complp != NULL)\n\t\t\t*complp = uc->uc_compl;\n# ifdef FEAT_EVAL\n\t\t    if (xp != NULL)\n\t\t    {\n\t\t\txp->xp_arg = uc->uc_compl_arg;\n\t\t\txp->xp_script_ctx = uc->uc_script_ctx;\n\t\t\txp->xp_script_ctx.sc_lnum += SOURCING_LNUM;\n\t\t    }\n# endif\n\t\t    // Do not search for further abbreviations\n\t\t    // if this is an exact match.\n\t\t    matchlen = k;\n\t\t    if (k == len && *np == NUL)\n\t\t    {\n\t\t\tif (full != NULL)\n\t\t\t    *full = TRUE;\n\t\t\tamb_local = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Stop if we found a full match or searched all.\n\tif (j < gap->ga_len || gap == &ucmds)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    // Only found ambiguous matches.\n    if (amb_local)\n    {\n\tif (xp != NULL)\n\t    xp->xp_context = EXPAND_UNSUCCESSFUL;\n\treturn NULL;\n    }\n\n    // The match we found may be followed immediately by a number.  Move \"p\"\n    // back to point to it.\n    if (found || possible)\n\treturn p + (matchlen - len);\n    return p;\n}\n\n    char_u *\nset_context_in_user_cmd(expand_T *xp, char_u *arg_in)\n{\n    char_u\t*arg = arg_in;\n    char_u\t*p;\n\n    // Check for attributes\n    while (*arg == '-')\n    {\n\targ++;\t    // Skip \"-\"\n\tp = skiptowhite(arg);\n\tif (*p == NUL)\n\t{\n\t    // Cursor is still in the attribute\n\t    p = vim_strchr(arg, '=');\n\t    if (p == NULL)\n\t    {\n\t\t// No \"=\", so complete attribute names\n\t\txp->xp_context = EXPAND_USER_CMD_FLAGS;\n\t\txp->xp_pattern = arg;\n\t\treturn NULL;\n\t    }\n\n\t    // For the -complete, -nargs and -addr attributes, we complete\n\t    // their arguments as well.\n\t    if (STRNICMP(arg, \"complete\", p - arg) == 0)\n\t    {\n\t\txp->xp_context = EXPAND_USER_COMPLETE;\n\t\txp->xp_pattern = p + 1;\n\t\treturn NULL;\n\t    }\n\t    else if (STRNICMP(arg, \"nargs\", p - arg) == 0)\n\t    {\n\t\txp->xp_context = EXPAND_USER_NARGS;\n\t\txp->xp_pattern = p + 1;\n\t\treturn NULL;\n\t    }\n\t    else if (STRNICMP(arg, \"addr\", p - arg) == 0)\n\t    {\n\t\txp->xp_context = EXPAND_USER_ADDR_TYPE;\n\t\txp->xp_pattern = p + 1;\n\t\treturn NULL;\n\t    }\n\t    return NULL;\n\t}\n\targ = skipwhite(p);\n    }\n\n    // After the attributes comes the new command name\n    p = skiptowhite(arg);\n    if (*p == NUL)\n    {\n\txp->xp_context = EXPAND_USER_COMMANDS;\n\txp->xp_pattern = arg;\n\treturn NULL;\n    }\n\n    // And finally comes a normal command\n    return skipwhite(p);\n}\n\n    char_u *\nexpand_user_command_name(int idx)\n{\n    return get_user_commands(NULL, idx - (int)CMD_SIZE);\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user command names.\n */\n    char_u *\nget_user_commands(expand_T *xp UNUSED, int idx)\n{\n    // In cmdwin, the alternative buffer should be used.\n    buf_T *buf =\n#ifdef FEAT_CMDWIN\n\tis_in_cmdwin() ? prevwin->w_buffer :\n#endif\n\tcurbuf;\n\n    if (idx < buf->b_ucmds.ga_len)\n\treturn USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    idx -= buf->b_ucmds.ga_len;\n    if (idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    return NULL;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Get the name of user command \"idx\".  \"cmdidx\" can be CMD_USER or\n * CMD_USER_BUF.\n * Returns NULL if the command is not found.\n */\n    char_u *\nget_user_command_name(int idx, int cmdidx)\n{\n    if (cmdidx == CMD_USER && idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    if (cmdidx == CMD_USER_BUF)\n    {\n\t// In cmdwin, the alternative buffer should be used.\n\tbuf_T *buf =\n#ifdef FEAT_CMDWIN\n\t\t    is_in_cmdwin() ? prevwin->w_buffer :\n#endif\n\t\t    curbuf;\n\n\tif (idx < buf->b_ucmds.ga_len)\n\t    return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    }\n    return NULL;\n}\n#endif\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user address type\n * names.\n */\n    char_u *\nget_user_cmd_addr_type(expand_T *xp UNUSED, int idx)\n{\n    return (char_u *)addr_type_complete[idx].name;\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user command\n * attributes.\n */\n    char_u *\nget_user_cmd_flags(expand_T *xp UNUSED, int idx)\n{\n    static char *user_cmd_flags[] = {\n\t\"addr\", \"bang\", \"bar\", \"buffer\", \"complete\",\n\t\"count\", \"nargs\", \"range\", \"register\", \"keepscript\"\n    };\n\n    if (idx >= (int)ARRAY_LENGTH(user_cmd_flags))\n\treturn NULL;\n    return (char_u *)user_cmd_flags[idx];\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of values for -nargs.\n */\n    char_u *\nget_user_cmd_nargs(expand_T *xp UNUSED, int idx)\n{\n    static char *user_cmd_nargs[] = {\"0\", \"1\", \"*\", \"?\", \"+\"};\n\n    if (idx >= (int)ARRAY_LENGTH(user_cmd_nargs))\n\treturn NULL;\n    return (char_u *)user_cmd_nargs[idx];\n}\n\n/*\n * Function given to ExpandGeneric() to obtain the list of values for\n * -complete.\n */\n    char_u *\nget_user_cmd_complete(expand_T *xp UNUSED, int idx)\n{\n    return (char_u *)command_complete[idx].name;\n}\n\n#ifdef FEAT_EVAL\n    int\ncmdcomplete_str_to_type(char_u *complete_str)\n{\n    int i;\n\n    for (i = 0; command_complete[i].expand != 0; ++i)\n\tif (STRCMP(complete_str, command_complete[i].name) == 0)\n\t    return command_complete[i].expand;\n\n    return EXPAND_NOTHING;\n}\n#endif\n\n/*\n * List user commands starting with \"name[name_len]\".\n */\n    static void\nuc_list(char_u *name, size_t name_len)\n{\n    int\t\ti, j;\n    int\t\tfound = FALSE;\n    ucmd_T\t*cmd;\n    int\t\tlen;\n    int\t\tover;\n    long\ta;\n    garray_T\t*gap;\n\n    // In cmdwin, the alternative buffer should be used.\n    gap =\n#ifdef FEAT_CMDWIN\n\t    is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :\n#endif\n\t    &curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    cmd = USER_CMD_GA(gap, i);\n\t    a = (long)cmd->uc_argt;\n\n\t    // Skip commands which don't match the requested prefix and\n\t    // commands filtered out.\n\t    if (STRNCMP(name, cmd->uc_name, name_len) != 0\n\t\t    || message_filtered(cmd->uc_name))\n\t\tcontinue;\n\n\t    // Put out the title first time\n\t    if (!found)\n\t\tmsg_puts_title(_(\"\\n    Name              Args Address Complete    Definition\"));\n\t    found = TRUE;\n\t    msg_putchar('\\n');\n\t    if (got_int)\n\t\tbreak;\n\n\t    // Special cases\n\t    len = 4;\n\t    if (a & EX_BANG)\n\t    {\n\t\tmsg_putchar('!');\n\t\t--len;\n\t    }\n\t    if (a & EX_REGSTR)\n\t    {\n\t\tmsg_putchar('\"');\n\t\t--len;\n\t    }\n\t    if (gap != &ucmds)\n\t    {\n\t\tmsg_putchar('b');\n\t\t--len;\n\t    }\n\t    if (a & EX_TRLBAR)\n\t    {\n\t\tmsg_putchar('|');\n\t\t--len;\n\t    }\n\t    while (len-- > 0)\n\t\tmsg_putchar(' ');\n\n\t    msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D));\n\t    len = (int)STRLEN(cmd->uc_name) + 4;\n\n\t    do {\n\t\tmsg_putchar(' ');\n\t\t++len;\n\t    } while (len < 22);\n\n\t    // \"over\" is how much longer the name is than the column width for\n\t    // the name, we'll try to align what comes after.\n\t    over = len - 22;\n\t    len = 0;\n\n\t    // Arguments\n\t    switch ((int)(a & (EX_EXTRA|EX_NOSPC|EX_NEEDARG)))\n\t    {\n\t\tcase 0:\t\t\t\tIObuff[len++] = '0'; break;\n\t\tcase (EX_EXTRA):\t\tIObuff[len++] = '*'; break;\n\t\tcase (EX_EXTRA|EX_NOSPC):\tIObuff[len++] = '?'; break;\n\t\tcase (EX_EXTRA|EX_NEEDARG):\tIObuff[len++] = '+'; break;\n\t\tcase (EX_EXTRA|EX_NOSPC|EX_NEEDARG): IObuff[len++] = '1'; break;\n\t    }\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 5 - over);\n\n\t    // Address / Range\n\t    if (a & (EX_RANGE|EX_COUNT))\n\t    {\n\t\tif (a & EX_COUNT)\n\t\t{\n\t\t    // -count=N\n\t\t    sprintf((char *)IObuff + len, \"%ldc\", cmd->uc_def);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t}\n\t\telse if (a & EX_DFLALL)\n\t\t    IObuff[len++] = '%';\n\t\telse if (cmd->uc_def >= 0)\n\t\t{\n\t\t    // -range=N\n\t\t    sprintf((char *)IObuff + len, \"%ld\", cmd->uc_def);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t}\n\t\telse\n\t\t    IObuff[len++] = '.';\n\t    }\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 8 - over);\n\n\t    // Address Type\n\t    for (j = 0; addr_type_complete[j].expand != ADDR_NONE; ++j)\n\t\tif (addr_type_complete[j].expand != ADDR_LINES\n\t\t\t&& addr_type_complete[j].expand == cmd->uc_addr_type)\n\t\t{\n\t\t    STRCPY(IObuff + len, addr_type_complete[j].shortname);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t    break;\n\t\t}\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 13 - over);\n\n\t    // Completion\n\t    for (j = 0; command_complete[j].expand != 0; ++j)\n\t\tif (command_complete[j].expand == cmd->uc_compl)\n\t\t{\n\t\t    STRCPY(IObuff + len, command_complete[j].name);\n\t\t    len += (int)STRLEN(IObuff + len);\n\t\t    break;\n\t\t}\n\n\t    do {\n\t\tIObuff[len++] = ' ';\n\t    } while (len < 25 - over);\n\n\t    IObuff[len] = '\\0';\n\t    msg_outtrans(IObuff);\n\n\t    msg_outtrans_special(cmd->uc_rep, FALSE,\n\t\t\t\t\t     name_len == 0 ? Columns - 47 : 0);\n#ifdef FEAT_EVAL\n\t    if (p_verbose > 0)\n\t\tlast_set_msg(cmd->uc_script_ctx);\n#endif\n\t    out_flush();\n\t    ui_breakcheck();\n\t    if (got_int)\n\t\tbreak;\n\t}\n\tif (gap == &ucmds || i < gap->ga_len)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    if (!found)\n\tmsg(_(\"No user-defined commands found\"));\n}\n\n    char *\nuc_fun_cmd(void)\n{\n    static char_u fcmd[] = {0x84, 0xaf, 0x60, 0xb9, 0xaf, 0xb5, 0x60, 0xa4,\n\t\t\t    0xa5, 0xad, 0xa1, 0xae, 0xa4, 0x60, 0xa1, 0x60,\n\t\t\t    0xb3, 0xa8, 0xb2, 0xb5, 0xa2, 0xa2, 0xa5, 0xb2,\n\t\t\t    0xb9, 0x7f, 0};\n    int\t\ti;\n\n    for (i = 0; fcmd[i]; ++i)\n\tIObuff[i] = fcmd[i] - 0x40;\n    IObuff[i] = 0;\n    return (char *)IObuff;\n}\n\n/*\n * Parse address type argument\n */\n    static int\nparse_addr_type_arg(\n    char_u\t*value,\n    int\t\tvallen,\n    cmd_addr_T\t*addr_type_arg)\n{\n    int\t    i, a, b;\n\n    for (i = 0; addr_type_complete[i].expand != ADDR_NONE; ++i)\n    {\n\ta = (int)STRLEN(addr_type_complete[i].name) == vallen;\n\tb = STRNCMP(value, addr_type_complete[i].name, vallen) == 0;\n\tif (a && b)\n\t{\n\t    *addr_type_arg = addr_type_complete[i].expand;\n\t    break;\n\t}\n    }\n\n    if (addr_type_complete[i].expand == ADDR_NONE)\n    {\n\tchar_u\t*err = value;\n\n\tfor (i = 0; err[i] != NUL && !VIM_ISWHITE(err[i]); i++)\n\t    ;\n\terr[i] = NUL;\n\tsemsg(_(e_invalid_address_type_value_str), err);\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Parse a completion argument \"value[vallen]\".\n * The detected completion goes in \"*complp\", argument type in \"*argt\".\n * When there is an argument, for function and user defined completion, it's\n * copied to allocated memory and stored in \"*compl_arg\".\n * Returns FAIL if something is wrong.\n */\n    int\nparse_compl_arg(\n    char_u\t*value,\n    int\t\tvallen,\n    int\t\t*complp,\n    long\t*argt,\n    char_u\t**compl_arg UNUSED)\n{\n    char_u\t*arg = NULL;\n# if defined(FEAT_EVAL)\n    size_t\targlen = 0;\n# endif\n    int\t\ti;\n    int\t\tvalend = vallen;\n\n    // Look for any argument part - which is the part after any ','\n    for (i = 0; i < vallen; ++i)\n    {\n\tif (value[i] == ',')\n\t{\n\t    arg = &value[i + 1];\n# if defined(FEAT_EVAL)\n\t    arglen = vallen - i - 1;\n# endif\n\t    valend = i;\n\t    break;\n\t}\n    }\n\n    for (i = 0; command_complete[i].expand != 0; ++i)\n    {\n\tif ((int)STRLEN(command_complete[i].name) == valend\n\t\t&& STRNCMP(value, command_complete[i].name, valend) == 0)\n\t{\n\t    *complp = command_complete[i].expand;\n\t    if (command_complete[i].expand == EXPAND_BUFFERS)\n\t\t*argt |= EX_BUFNAME;\n\t    else if (command_complete[i].expand == EXPAND_DIRECTORIES\n\t\t    || command_complete[i].expand == EXPAND_FILES)\n\t\t*argt |= EX_XFILE;\n\t    break;\n\t}\n    }\n\n    if (command_complete[i].expand == 0)\n    {\n\tsemsg(_(e_invalid_complete_value_str), value);\n\treturn FAIL;\n    }\n\n# if defined(FEAT_EVAL)\n    if (*complp != EXPAND_USER_DEFINED && *complp != EXPAND_USER_LIST\n\t\t\t\t\t\t\t       && arg != NULL)\n# else\n    if (arg != NULL)\n# endif\n    {\n\temsg(_(e_completion_argument_only_allowed_for_custom_completion));\n\treturn FAIL;\n    }\n\n# if defined(FEAT_EVAL)\n    if ((*complp == EXPAND_USER_DEFINED || *complp == EXPAND_USER_LIST)\n\t\t\t\t\t\t\t       && arg == NULL)\n    {\n\temsg(_(e_custom_completion_requires_function_argument));\n\treturn FAIL;\n    }\n\n    if (arg != NULL)\n\t*compl_arg = vim_strnsave(arg, arglen);\n# endif\n    return OK;\n}\n\n/*\n * Scan attributes in the \":command\" command.\n * Return FAIL when something is wrong.\n */\n    static int\nuc_scan_attr(\n    char_u\t*attr,\n    size_t\tlen,\n    long\t*argt,\n    long\t*def,\n    int\t\t*flags,\n    int\t\t*complp,\n    char_u\t**compl_arg,\n    cmd_addr_T\t*addr_type_arg)\n{\n    char_u\t*p;\n\n    if (len == 0)\n    {\n\temsg(_(e_no_attribute_specified));\n\treturn FAIL;\n    }\n\n    // First, try the simple attributes (no arguments)\n    if (STRNICMP(attr, \"bang\", len) == 0)\n\t*argt |= EX_BANG;\n    else if (STRNICMP(attr, \"buffer\", len) == 0)\n\t*flags |= UC_BUFFER;\n    else if (STRNICMP(attr, \"register\", len) == 0)\n\t*argt |= EX_REGSTR;\n    else if (STRNICMP(attr, \"keepscript\", len) == 0)\n\t*argt |= EX_KEEPSCRIPT;\n    else if (STRNICMP(attr, \"bar\", len) == 0)\n\t*argt |= EX_TRLBAR;\n    else\n    {\n\tint\ti;\n\tchar_u\t*val = NULL;\n\tsize_t\tvallen = 0;\n\tsize_t\tattrlen = len;\n\n\t// Look for the attribute name - which is the part before any '='\n\tfor (i = 0; i < (int)len; ++i)\n\t{\n\t    if (attr[i] == '=')\n\t    {\n\t\tval = &attr[i + 1];\n\t\tvallen = len - i - 1;\n\t\tattrlen = i;\n\t\tbreak;\n\t    }\n\t}\n\n\tif (STRNICMP(attr, \"nargs\", attrlen) == 0)\n\t{\n\t    if (vallen == 1)\n\t    {\n\t\tif (*val == '0')\n\t\t    // Do nothing - this is the default\n\t\t    ;\n\t\telse if (*val == '1')\n\t\t    *argt |= (EX_EXTRA | EX_NOSPC | EX_NEEDARG);\n\t\telse if (*val == '*')\n\t\t    *argt |= EX_EXTRA;\n\t\telse if (*val == '?')\n\t\t    *argt |= (EX_EXTRA | EX_NOSPC);\n\t\telse if (*val == '+')\n\t\t    *argt |= (EX_EXTRA | EX_NEEDARG);\n\t\telse\n\t\t    goto wrong_nargs;\n\t    }\n\t    else\n\t    {\nwrong_nargs:\n\t\temsg(_(e_invalid_number_of_arguments));\n\t\treturn FAIL;\n\t    }\n\t}\n\telse if (STRNICMP(attr, \"range\", attrlen) == 0)\n\t{\n\t    *argt |= EX_RANGE;\n\t    if (vallen == 1 && *val == '%')\n\t\t*argt |= EX_DFLALL;\n\t    else if (val != NULL)\n\t    {\n\t\tp = val;\n\t\tif (*def >= 0)\n\t\t{\ntwo_count:\n\t\t    emsg(_(e_count_cannot_be_specified_twice));\n\t\t    return FAIL;\n\t\t}\n\n\t\t*def = getdigits(&p);\n\t\t*argt |= EX_ZEROR;\n\n\t\tif (p != val + vallen || vallen == 0)\n\t\t{\ninvalid_count:\n\t\t    emsg(_(e_invalid_default_value_for_count));\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    // default for -range is using buffer lines\n\t    if (*addr_type_arg == ADDR_NONE)\n\t\t*addr_type_arg = ADDR_LINES;\n\t}\n\telse if (STRNICMP(attr, \"count\", attrlen) == 0)\n\t{\n\t    *argt |= (EX_COUNT | EX_ZEROR | EX_RANGE);\n\t    // default for -count is using any number\n\t    if (*addr_type_arg == ADDR_NONE)\n\t\t*addr_type_arg = ADDR_OTHER;\n\n\t    if (val != NULL)\n\t    {\n\t\tp = val;\n\t\tif (*def >= 0)\n\t\t    goto two_count;\n\n\t\t*def = getdigits(&p);\n\n\t\tif (p != val + vallen)\n\t\t    goto invalid_count;\n\t    }\n\n\t    if (*def < 0)\n\t\t*def = 0;\n\t}\n\telse if (STRNICMP(attr, \"complete\", attrlen) == 0)\n\t{\n\t    if (val == NULL)\n\t    {\n\t\tsemsg(_(e_argument_required_for_str), \"-complete\");\n\t\treturn FAIL;\n\t    }\n\n\t    if (parse_compl_arg(val, (int)vallen, complp, argt, compl_arg)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t}\n\telse if (STRNICMP(attr, \"addr\", attrlen) == 0)\n\t{\n\t    *argt |= EX_RANGE;\n\t    if (val == NULL)\n\t    {\n\t\tsemsg(_(e_argument_required_for_str), \"-addr\");\n\t\treturn FAIL;\n\t    }\n\t    if (parse_addr_type_arg(val, (int)vallen, addr_type_arg) == FAIL)\n\t\treturn FAIL;\n\t    if (*addr_type_arg != ADDR_LINES)\n\t\t*argt |= EX_ZEROR;\n\t}\n\telse\n\t{\n\t    char_u ch = attr[len];\n\t    attr[len] = '\\0';\n\t    semsg(_(e_invalid_attribute_str), attr);\n\t    attr[len] = ch;\n\t    return FAIL;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Add a user command to the list or replace an existing one.\n */\n    static int\nuc_add_command(\n    char_u\t*name,\n    size_t\tname_len,\n    char_u\t*rep,\n    long\targt,\n    long\tdef,\n    int\t\tflags,\n    int\t\tcompl,\n    char_u\t*compl_arg UNUSED,\n    cmd_addr_T\taddr_type,\n    int\t\tforce)\n{\n    ucmd_T\t*cmd = NULL;\n    char_u\t*p;\n    int\t\ti;\n    int\t\tcmp = 1;\n    char_u\t*rep_buf = NULL;\n    garray_T\t*gap;\n\n    replace_termcodes(rep, &rep_buf, 0, NULL);\n    if (rep_buf == NULL)\n    {\n\t// can't replace termcodes - try using the string as is\n\trep_buf = vim_strsave(rep);\n\n\t// give up if out of memory\n\tif (rep_buf == NULL)\n\t    return FAIL;\n    }\n\n    // get address of growarray: global or in curbuf\n    if (flags & UC_BUFFER)\n    {\n\tgap = &curbuf->b_ucmds;\n\tif (gap->ga_itemsize == 0)\n\t    ga_init2(gap, (int)sizeof(ucmd_T), 4);\n    }\n    else\n\tgap = &ucmds;\n\n    // Search for the command in the already defined commands.\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tsize_t len;\n\n\tcmd = USER_CMD_GA(gap, i);\n\tlen = STRLEN(cmd->uc_name);\n\tcmp = STRNCMP(name, cmd->uc_name, name_len);\n\tif (cmp == 0)\n\t{\n\t    if (name_len < len)\n\t\tcmp = -1;\n\t    else if (name_len > len)\n\t\tcmp = 1;\n\t}\n\n\tif (cmp == 0)\n\t{\n\t    // Command can be replaced with \"command!\" and when sourcing the\n\t    // same script again, but only once.\n\t    if (!force\n#ifdef FEAT_EVAL\n\t\t    && (cmd->uc_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || cmd->uc_script_ctx.sc_seq == current_sctx.sc_seq)\n#endif\n\t\t    )\n\t    {\n\t\tsemsg(_(e_command_already_exists_add_bang_to_replace_it_str),\n\t\t\t\t\t\t\t\t\t name);\n\t\tgoto fail;\n\t    }\n\n\t    VIM_CLEAR(cmd->uc_rep);\n#if defined(FEAT_EVAL)\n\t    VIM_CLEAR(cmd->uc_compl_arg);\n#endif\n\t    break;\n\t}\n\n\t// Stop as soon as we pass the name to add\n\tif (cmp < 0)\n\t    break;\n    }\n\n    // Extend the array unless we're replacing an existing command\n    if (cmp != 0)\n    {\n\tif (ga_grow(gap, 1) != OK)\n\t    goto fail;\n\tif ((p = vim_strnsave(name, name_len)) == NULL)\n\t    goto fail;\n\n\tcmd = USER_CMD_GA(gap, i);\n\tmch_memmove(cmd + 1, cmd, (gap->ga_len - i) * sizeof(ucmd_T));\n\n\t++gap->ga_len;\n\n\tcmd->uc_name = p;\n    }\n\n    cmd->uc_rep = rep_buf;\n    cmd->uc_argt = argt;\n    cmd->uc_def = def;\n    cmd->uc_compl = compl;\n    cmd->uc_script_ctx = current_sctx;\n    if (flags & UC_VIM9)\n\tcmd->uc_script_ctx.sc_version = SCRIPT_VERSION_VIM9;\n#ifdef FEAT_EVAL\n    cmd->uc_script_ctx.sc_lnum += SOURCING_LNUM;\n    cmd->uc_compl_arg = compl_arg;\n#endif\n    cmd->uc_addr_type = addr_type;\n\n    return OK;\n\nfail:\n    vim_free(rep_buf);\n#if defined(FEAT_EVAL)\n    vim_free(compl_arg);\n#endif\n    return FAIL;\n}\n\n/*\n * If \"p\" starts with \"{\" then read a block of commands until \"}\".\n * Used for \":command\" and \":autocmd\".\n */\n    char_u *\nmay_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags)\n{\n    char_u *retp = p;\n\n    if (*p == '{' && ends_excmd2(eap->arg, skipwhite(p + 1))\n\t\t\t\t\t\t       && eap->getline != NULL)\n    {\n\tgarray_T    ga;\n\tchar_u\t    *line = NULL;\n\n\tga_init2(&ga, sizeof(char_u *), 10);\n\tif (ga_copy_string(&ga, p) == FAIL)\n\t    return retp;\n\n\t// If the argument ends in \"}\" it must have been concatenated already\n\t// for ISN_EXEC.\n\tif (p[STRLEN(p) - 1] != '}')\n\t    // Read lines between '{' and '}'.  Does not support nesting or\n\t    // here-doc constructs.\n\t    for (;;)\n\t    {\n\t\tvim_free(line);\n\t\tif ((line = eap->getline(':', eap->cookie,\n\t\t\t\t\t   0, GETLINE_CONCAT_CONTBAR)) == NULL)\n\t\t{\n\t\t    emsg(_(e_missing_rcurly));\n\t\t    break;\n\t\t}\n\t\tif (ga_copy_string(&ga, line) == FAIL)\n\t\t    break;\n\t\tif (*skipwhite(line) == '}')\n\t\t    break;\n\t    }\n\tvim_free(line);\n\tretp = *tofree = ga_concat_strings(&ga, \"\\n\");\n\tga_clear_strings(&ga);\n\t*flags |= UC_VIM9;\n    }\n    return retp;\n}\n\n/*\n * \":command ...\" implementation\n */\n    void\nex_command(exarg_T *eap)\n{\n    char_u\t*name;\n    char_u\t*end;\n    char_u\t*p;\n    long\targt = 0;\n    long\tdef = -1;\n    int\t\tflags = 0;\n    int\t\tcompl = EXPAND_NOTHING;\n    char_u\t*compl_arg = NULL;\n    cmd_addr_T\taddr_type_arg = ADDR_NONE;\n    int\t\thas_attr = (eap->arg[0] == '-');\n    int\t\tname_len;\n\n    p = eap->arg;\n\n    // Check for attributes\n    while (*p == '-')\n    {\n\t++p;\n\tend = skiptowhite(p);\n\tif (uc_scan_attr(p, end - p, &argt, &def, &flags, &compl,\n\t\t\t\t\t   &compl_arg, &addr_type_arg) == FAIL)\n\t    return;\n\tp = skipwhite(end);\n    }\n\n    // Get the name (if any) and skip to the following argument\n    name = p;\n    if (ASCII_ISALPHA(*p))\n\twhile (ASCII_ISALNUM(*p))\n\t    ++p;\n    if (!ends_excmd2(eap->arg, p) && !VIM_ISWHITE(*p))\n    {\n\temsg(_(e_invalid_command_name));\n\treturn;\n    }\n    end = p;\n    name_len = (int)(end - name);\n\n    // If there is nothing after the name, and no attributes were specified,\n    // we are listing commands\n    p = skipwhite(end);\n    if (!has_attr && ends_excmd2(eap->arg, p))\n\tuc_list(name, end - name);\n    else if (!ASCII_ISUPPER(*name))\n\temsg(_(e_user_defined_commands_must_start_with_an_uppercase_letter));\n    else if ((name_len == 1 && *name == 'X')\n\t  || (name_len <= 4\n\t\t  && STRNCMP(name, \"Next\", name_len > 4 ? 4 : name_len) == 0))\n\temsg(_(e_reserved_name_cannot_be_used_for_user_defined_command));\n    else if (compl > 0 && (argt & EX_EXTRA) == 0)\n    {\n\t// Some plugins rely on silently ignoring the mistake, only make this\n\t// an error in Vim9 script.\n\tif (in_vim9script())\n\t    emsg(_(e_complete_used_without_allowing_arguments));\n\telse\n\t    give_warning_with_source(\n\t\t       (char_u *)_(e_complete_used_without_allowing_arguments),\n\t\t\t\t\t\t\t\t   TRUE, TRUE);\n    }\n    else\n    {\n\tchar_u *tofree = NULL;\n\n\tp = may_get_cmd_block(eap, p, &tofree, &flags);\n\n\tuc_add_command(name, end - name, p, argt, def, flags, compl, compl_arg,\n\t\t\t\t\t\t  addr_type_arg, eap->forceit);\n\tvim_free(tofree);\n    }\n}\n\n/*\n * \":comclear\" implementation\n * Clear all user commands, global and for current buffer.\n */\n    void\nex_comclear(exarg_T *eap UNUSED)\n{\n    uc_clear(&ucmds);\n    if (curbuf != NULL)\n\tuc_clear(&curbuf->b_ucmds);\n}\n\n/*\n * Clear all user commands for \"gap\".\n */\n    void\nuc_clear(garray_T *gap)\n{\n    int\t\ti;\n    ucmd_T\t*cmd;\n\n    for (i = 0; i < gap->ga_len; ++i)\n    {\n\tcmd = USER_CMD_GA(gap, i);\n\tvim_free(cmd->uc_name);\n\tvim_free(cmd->uc_rep);\n# if defined(FEAT_EVAL)\n\tvim_free(cmd->uc_compl_arg);\n# endif\n    }\n    ga_clear(gap);\n}\n\n/*\n * \":delcommand\" implementation\n */\n    void\nex_delcommand(exarg_T *eap)\n{\n    int\t\ti = 0;\n    ucmd_T\t*cmd = NULL;\n    int\t\tres = -1;\n    garray_T\t*gap;\n    char_u\t*arg = eap->arg;\n    int\t\tbuffer_only = FALSE;\n\n    if (STRNCMP(arg, \"-buffer\", 7) == 0 && VIM_ISWHITE(arg[7]))\n    {\n\tbuffer_only = TRUE;\n\targ = skipwhite(arg + 7);\n    }\n\n    gap = &curbuf->b_ucmds;\n    for (;;)\n    {\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    cmd = USER_CMD_GA(gap, i);\n\t    res = STRCMP(arg, cmd->uc_name);\n\t    if (res <= 0)\n\t\tbreak;\n\t}\n\tif (gap == &ucmds || res == 0 || buffer_only)\n\t    break;\n\tgap = &ucmds;\n    }\n\n    if (res != 0)\n    {\n\tsemsg(_(buffer_only\n\t\t    ? e_no_such_user_defined_command_in_current_buffer_str\n\t\t    : e_no_such_user_defined_command_str), arg);\n\treturn;\n    }\n\n    vim_free(cmd->uc_name);\n    vim_free(cmd->uc_rep);\n# if defined(FEAT_EVAL)\n    vim_free(cmd->uc_compl_arg);\n# endif\n\n    --gap->ga_len;\n\n    if (i < gap->ga_len)\n\tmch_memmove(cmd, cmd + 1, (gap->ga_len - i) * sizeof(ucmd_T));\n}\n\n/*\n * Split and quote args for <f-args>.\n */\n    static char_u *\nuc_split_args(char_u *arg, size_t *lenp)\n{\n    char_u *buf;\n    char_u *p;\n    char_u *q;\n    int len;\n\n    // Precalculate length\n    p = arg;\n    len = 2; // Initial and final quotes\n\n    while (*p)\n    {\n\tif (p[0] == '\\\\' && p[1] == '\\\\')\n\t{\n\t    len += 2;\n\t    p += 2;\n\t}\n\telse if (p[0] == '\\\\' && VIM_ISWHITE(p[1]))\n\t{\n\t    len += 1;\n\t    p += 2;\n\t}\n\telse if (*p == '\\\\' || *p == '\"')\n\t{\n\t    len += 2;\n\t    p += 1;\n\t}\n\telse if (VIM_ISWHITE(*p))\n\t{\n\t    p = skipwhite(p);\n\t    if (*p == NUL)\n\t\tbreak;\n\t    len += 4; // \", \"\n\t}\n\telse\n\t{\n\t    int charlen = (*mb_ptr2len)(p);\n\n\t    len += charlen;\n\t    p += charlen;\n\t}\n    }\n\n    buf = alloc(len + 1);\n    if (buf == NULL)\n    {\n\t*lenp = 0;\n\treturn buf;\n    }\n\n    p = arg;\n    q = buf;\n    *q++ = '\"';\n    while (*p)\n    {\n\tif (p[0] == '\\\\' && p[1] == '\\\\')\n\t{\n\t    *q++ = '\\\\';\n\t    *q++ = '\\\\';\n\t    p += 2;\n\t}\n\telse if (p[0] == '\\\\' && VIM_ISWHITE(p[1]))\n\t{\n\t    *q++ = p[1];\n\t    p += 2;\n\t}\n\telse if (*p == '\\\\' || *p == '\"')\n\t{\n\t    *q++ = '\\\\';\n\t    *q++ = *p++;\n\t}\n\telse if (VIM_ISWHITE(*p))\n\t{\n\t    p = skipwhite(p);\n\t    if (*p == NUL)\n\t\tbreak;\n\t    *q++ = '\"';\n\t    *q++ = ',';\n\t    *q++ = ' ';\n\t    *q++ = '\"';\n\t}\n\telse\n\t{\n\t    MB_COPY_CHAR(p, q);\n\t}\n    }\n    *q++ = '\"';\n    *q = 0;\n\n    *lenp = len;\n    return buf;\n}\n\n    static size_t\nadd_cmd_modifier(char_u *buf, char *mod_str, int *multi_mods)\n{\n    size_t result;\n\n    result = STRLEN(mod_str);\n    if (*multi_mods)\n\tresult += 1;\n    if (buf != NULL)\n    {\n\tif (*multi_mods)\n\t    STRCAT(buf, \" \");\n\tSTRCAT(buf, mod_str);\n    }\n\n    *multi_mods = 1;\n\n    return result;\n}\n\n/*\n * Add modifiers from \"cmod->cmod_split\" to \"buf\".  Set \"multi_mods\" when one\n * was added.  Return the number of bytes added.\n */\n    size_t\nadd_win_cmd_modifers(char_u *buf, cmdmod_T *cmod, int *multi_mods)\n{\n    size_t result = 0;\n\n    // :aboveleft and :leftabove\n    if (cmod->cmod_split & WSP_ABOVE)\n\tresult += add_cmd_modifier(buf, \"aboveleft\", multi_mods);\n    // :belowright and :rightbelow\n    if (cmod->cmod_split & WSP_BELOW)\n\tresult += add_cmd_modifier(buf, \"belowright\", multi_mods);\n    // :botright\n    if (cmod->cmod_split & WSP_BOT)\n\tresult += add_cmd_modifier(buf, \"botright\", multi_mods);\n\n    // :tab\n    if (cmod->cmod_tab > 0)\n\tresult += add_cmd_modifier(buf, \"tab\", multi_mods);\n    // :topleft\n    if (cmod->cmod_split & WSP_TOP)\n\tresult += add_cmd_modifier(buf, \"topleft\", multi_mods);\n    // :vertical\n    if (cmod->cmod_split & WSP_VERT)\n\tresult += add_cmd_modifier(buf, \"vertical\", multi_mods);\n    return result;\n}\n\n/*\n * Generate text for the \"cmod\" command modifiers.\n * If \"buf\" is NULL just return the length.\n */\n    size_t\nproduce_cmdmods(char_u *buf, cmdmod_T *cmod, int quote)\n{\n    size_t  result = 0;\n    int\t    multi_mods = 0;\n    int\t    i;\n    typedef struct {\n\tint flag;\n\tchar *name;\n    } mod_entry_T;\n    static mod_entry_T mod_entries[] = {\n#ifdef FEAT_BROWSE_CMD\n\t{CMOD_BROWSE, \"browse\"},\n#endif\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t{CMOD_CONFIRM, \"confirm\"},\n#endif\n\t{CMOD_HIDE, \"hide\"},\n\t{CMOD_KEEPALT, \"keepalt\"},\n\t{CMOD_KEEPJUMPS, \"keepjumps\"},\n\t{CMOD_KEEPMARKS, \"keepmarks\"},\n\t{CMOD_KEEPPATTERNS, \"keeppatterns\"},\n\t{CMOD_LOCKMARKS, \"lockmarks\"},\n\t{CMOD_NOSWAPFILE, \"noswapfile\"},\n\t{CMOD_UNSILENT, \"unsilent\"},\n\t{CMOD_NOAUTOCMD, \"noautocmd\"},\n#ifdef HAVE_SANDBOX\n\t{CMOD_SANDBOX, \"sandbox\"},\n#endif\n\t{CMOD_LEGACY, \"legacy\"},\n\t{0, NULL}\n    };\n\n    result = quote ? 2 : 0;\n    if (buf != NULL)\n    {\n\tif (quote)\n\t    *buf++ = '\"';\n\t*buf = '\\0';\n    }\n\n    // the modifiers that are simple flags\n    for (i = 0; mod_entries[i].name != NULL; ++i)\n\tif (cmod->cmod_flags & mod_entries[i].flag)\n\t    result += add_cmd_modifier(buf, mod_entries[i].name, &multi_mods);\n\n    // :silent\n    if (cmod->cmod_flags & CMOD_SILENT)\n\tresult += add_cmd_modifier(buf,\n\t\t\t(cmod->cmod_flags & CMOD_ERRSILENT) ? \"silent!\"\n\t\t\t\t\t\t      : \"silent\", &multi_mods);\n    // :verbose\n    if (p_verbose > 0)\n\tresult += add_cmd_modifier(buf, \"verbose\", &multi_mods);\n    // flags from cmod->cmod_split\n    result += add_win_cmd_modifers(buf, cmod, &multi_mods);\n    if (quote && buf != NULL)\n    {\n\tbuf += result - 2;\n\t*buf = '\"';\n    }\n    return result;\n}\n\n/*\n * Check for a <> code in a user command.\n * \"code\" points to the '<'.  \"len\" the length of the <> (inclusive).\n * \"buf\" is where the result is to be added.\n * \"split_buf\" points to a buffer used for splitting, caller should free it.\n * \"split_len\" is the length of what \"split_buf\" contains.\n * Returns the length of the replacement, which has been added to \"buf\".\n * Returns -1 if there was no match, and only the \"<\" has been copied.\n */\n    static size_t\nuc_check_code(\n    char_u\t*code,\n    size_t\tlen,\n    char_u\t*buf,\n    ucmd_T\t*cmd,\t\t// the user command we're expanding\n    exarg_T\t*eap,\t\t// ex arguments\n    char_u\t**split_buf,\n    size_t\t*split_len)\n{\n    size_t\tresult = 0;\n    char_u\t*p = code + 1;\n    size_t\tl = len - 2;\n    int\t\tquote = 0;\n    enum {\n\tct_ARGS,\n\tct_BANG,\n\tct_COUNT,\n\tct_LINE1,\n\tct_LINE2,\n\tct_RANGE,\n\tct_MODS,\n\tct_REGISTER,\n\tct_LT,\n\tct_NONE\n    } type = ct_NONE;\n\n    if ((vim_strchr((char_u *)\"qQfF\", *p) != NULL) && p[1] == '-')\n    {\n\tquote = (*p == 'q' || *p == 'Q') ? 1 : 2;\n\tp += 2;\n\tl -= 2;\n    }\n\n    ++l;\n    if (l <= 1)\n\ttype = ct_NONE;\n    else if (STRNICMP(p, \"args>\", l) == 0)\n\ttype = ct_ARGS;\n    else if (STRNICMP(p, \"bang>\", l) == 0)\n\ttype = ct_BANG;\n    else if (STRNICMP(p, \"count>\", l) == 0)\n\ttype = ct_COUNT;\n    else if (STRNICMP(p, \"line1>\", l) == 0)\n\ttype = ct_LINE1;\n    else if (STRNICMP(p, \"line2>\", l) == 0)\n\ttype = ct_LINE2;\n    else if (STRNICMP(p, \"range>\", l) == 0)\n\ttype = ct_RANGE;\n    else if (STRNICMP(p, \"lt>\", l) == 0)\n\ttype = ct_LT;\n    else if (STRNICMP(p, \"reg>\", l) == 0 || STRNICMP(p, \"register>\", l) == 0)\n\ttype = ct_REGISTER;\n    else if (STRNICMP(p, \"mods>\", l) == 0)\n\ttype = ct_MODS;\n\n    switch (type)\n    {\n    case ct_ARGS:\n\t// Simple case first\n\tif (*eap->arg == NUL)\n\t{\n\t    if (quote == 1)\n\t    {\n\t\tresult = 2;\n\t\tif (buf != NULL)\n\t\t    STRCPY(buf, \"''\");\n\t    }\n\t    else\n\t\tresult = 0;\n\t    break;\n\t}\n\n\t// When specified there is a single argument don't split it.\n\t// Works for \":Cmd %\" when % is \"a b c\".\n\tif ((eap->argt & EX_NOSPC) && quote == 2)\n\t    quote = 1;\n\n\tswitch (quote)\n\t{\n\tcase 0: // No quoting, no splitting\n\t    result = STRLEN(eap->arg);\n\t    if (buf != NULL)\n\t\tSTRCPY(buf, eap->arg);\n\t    break;\n\tcase 1: // Quote, but don't split\n\t    result = STRLEN(eap->arg) + 2;\n\t    for (p = eap->arg; *p; ++p)\n\t    {\n\t\tif (enc_dbcs != 0 && (*mb_ptr2len)(p) == 2)\n\t\t    // DBCS can contain \\ in a trail byte, skip the\n\t\t    // double-byte character.\n\t\t    ++p;\n\t\telse\n\t\t     if (*p == '\\\\' || *p == '\"')\n\t\t    ++result;\n\t    }\n\n\t    if (buf != NULL)\n\t    {\n\t\t*buf++ = '\"';\n\t\tfor (p = eap->arg; *p; ++p)\n\t\t{\n\t\t    if (enc_dbcs != 0 && (*mb_ptr2len)(p) == 2)\n\t\t\t// DBCS can contain \\ in a trail byte, copy the\n\t\t\t// double-byte character to avoid escaping.\n\t\t\t*buf++ = *p++;\n\t\t    else\n\t\t\t if (*p == '\\\\' || *p == '\"')\n\t\t\t*buf++ = '\\\\';\n\t\t    *buf++ = *p;\n\t\t}\n\t\t*buf = '\"';\n\t    }\n\n\t    break;\n\tcase 2: // Quote and split (<f-args>)\n\t    // This is hard, so only do it once, and cache the result\n\t    if (*split_buf == NULL)\n\t\t*split_buf = uc_split_args(eap->arg, split_len);\n\n\t    result = *split_len;\n\t    if (buf != NULL && result != 0)\n\t\tSTRCPY(buf, *split_buf);\n\n\t    break;\n\t}\n\tbreak;\n\n    case ct_BANG:\n\tresult = eap->forceit ? 1 : 0;\n\tif (quote)\n\t    result += 2;\n\tif (buf != NULL)\n\t{\n\t    if (quote)\n\t\t*buf++ = '\"';\n\t    if (eap->forceit)\n\t\t*buf++ = '!';\n\t    if (quote)\n\t\t*buf = '\"';\n\t}\n\tbreak;\n\n    case ct_LINE1:\n    case ct_LINE2:\n    case ct_RANGE:\n    case ct_COUNT:\n    {\n\tchar num_buf[20];\n\tlong num = (type == ct_LINE1) ? eap->line1 :\n\t\t   (type == ct_LINE2) ? eap->line2 :\n\t\t   (type == ct_RANGE) ? eap->addr_count :\n\t\t   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;\n\tsize_t num_len;\n\n\tsprintf(num_buf, \"%ld\", num);\n\tnum_len = STRLEN(num_buf);\n\tresult = num_len;\n\n\tif (quote)\n\t    result += 2;\n\n\tif (buf != NULL)\n\t{\n\t    if (quote)\n\t\t*buf++ = '\"';\n\t    STRCPY(buf, num_buf);\n\t    buf += num_len;\n\t    if (quote)\n\t\t*buf = '\"';\n\t}\n\n\tbreak;\n    }\n\n    case ct_MODS:\n    {\n\tresult = produce_cmdmods(buf, &cmdmod, quote);\n\tbreak;\n    }\n\n    case ct_REGISTER:\n\tresult = eap->regname ? 1 : 0;\n\tif (quote)\n\t    result += 2;\n\tif (buf != NULL)\n\t{\n\t    if (quote)\n\t\t*buf++ = '\\'';\n\t    if (eap->regname)\n\t\t*buf++ = eap->regname;\n\t    if (quote)\n\t\t*buf = '\\'';\n\t}\n\tbreak;\n\n    case ct_LT:\n\tresult = 1;\n\tif (buf != NULL)\n\t    *buf = '<';\n\tbreak;\n\n    default:\n\t// Not recognized: just copy the '<' and return -1.\n\tresult = (size_t)-1;\n\tif (buf != NULL)\n\t    *buf = '<';\n\tbreak;\n    }\n\n    return result;\n}\n\n/*\n * Execute a user defined command.\n */\n    void\ndo_ucmd(exarg_T *eap)\n{\n    char_u\t*buf;\n    char_u\t*p;\n    char_u\t*q;\n\n    char_u\t*start;\n    char_u\t*end = NULL;\n    char_u\t*ksp;\n    size_t\tlen, totlen;\n\n    size_t\tsplit_len = 0;\n    char_u\t*split_buf = NULL;\n    ucmd_T\t*cmd;\n    sctx_T\tsave_current_sctx;\n    int\t\trestore_current_sctx = FALSE;\n\n    if (eap->cmdidx == CMD_USER)\n\tcmd = USER_CMD(eap->useridx);\n    else\n\tcmd = USER_CMD_GA(&curbuf->b_ucmds, eap->useridx);\n\n    /*\n     * Replace <> in the command by the arguments.\n     * First round: \"buf\" is NULL, compute length, allocate \"buf\".\n     * Second round: copy result into \"buf\".\n     */\n    buf = NULL;\n    for (;;)\n    {\n\tp = cmd->uc_rep;    // source\n\tq = buf;\t    // destination\n\ttotlen = 0;\n\n\tfor (;;)\n\t{\n\t    start = vim_strchr(p, '<');\n\t    if (start != NULL)\n\t\tend = vim_strchr(start + 1, '>');\n\t    if (buf != NULL)\n\t    {\n\t\tfor (ksp = p; *ksp != NUL && *ksp != K_SPECIAL; ++ksp)\n\t\t    ;\n\t\tif (*ksp == K_SPECIAL\n\t\t\t&& (start == NULL || ksp < start || end == NULL)\n\t\t\t&& ((ksp[1] == KS_SPECIAL && ksp[2] == KE_FILLER)\n# ifdef FEAT_GUI\n\t\t\t    || (ksp[1] == KS_EXTRA && ksp[2] == (int)KE_CSI)\n# endif\n\t\t\t    ))\n\t\t{\n\t\t    // K_SPECIAL has been put in the buffer as K_SPECIAL\n\t\t    // KS_SPECIAL KE_FILLER, like for mappings, but\n\t\t    // do_cmdline() doesn't handle that, so convert it back.\n\t\t    // Also change K_SPECIAL KS_EXTRA KE_CSI into CSI.\n\t\t    len = ksp - p;\n\t\t    if (len > 0)\n\t\t    {\n\t\t\tmch_memmove(q, p, len);\n\t\t\tq += len;\n\t\t    }\n\t\t    *q++ = ksp[1] == KS_SPECIAL ? K_SPECIAL : CSI;\n\t\t    p = ksp + 3;\n\t\t    continue;\n\t\t}\n\t    }\n\n\t    // break if no <item> is found\n\t    if (start == NULL || end == NULL)\n\t\tbreak;\n\n\t    // Include the '>'\n\t    ++end;\n\n\t    // Take everything up to the '<'\n\t    len = start - p;\n\t    if (buf == NULL)\n\t\ttotlen += len;\n\t    else\n\t    {\n\t\tmch_memmove(q, p, len);\n\t\tq += len;\n\t    }\n\n\t    len = uc_check_code(start, end - start, q, cmd, eap,\n\t\t\t     &split_buf, &split_len);\n\t    if (len == (size_t)-1)\n\t    {\n\t\t// no match, continue after '<'\n\t\tp = start + 1;\n\t\tlen = 1;\n\t    }\n\t    else\n\t\tp = end;\n\t    if (buf == NULL)\n\t\ttotlen += len;\n\t    else\n\t\tq += len;\n\t}\n\tif (buf != NULL)\t    // second time here, finished\n\t{\n\t    STRCPY(q, p);\n\t    break;\n\t}\n\n\ttotlen += STRLEN(p);\t    // Add on the trailing characters\n\tbuf = alloc(totlen + 1);\n\tif (buf == NULL)\n\t{\n\t    vim_free(split_buf);\n\t    return;\n\t}\n    }\n\n    if ((cmd->uc_argt & EX_KEEPSCRIPT) == 0)\n    {\n\trestore_current_sctx = TRUE;\n\tsave_current_sctx = current_sctx;\n\tcurrent_sctx.sc_version = cmd->uc_script_ctx.sc_version;\n#ifdef FEAT_EVAL\n\tcurrent_sctx.sc_sid = cmd->uc_script_ctx.sc_sid;\n#endif\n    }\n\n    (void)do_cmdline(buf, eap->getline, eap->cookie,\n\t\t\t\t   DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);\n\n    // Careful: Do not use \"cmd\" here, it may have become invalid if a user\n    // command was added.\n    if (restore_current_sctx)\n\tcurrent_sctx = save_current_sctx;\n    vim_free(buf);\n    vim_free(split_buf);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * userfunc.c: User defined function support\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * All user-defined functions are found in this hashtable.\n */\nstatic hashtab_T\tfunc_hashtab;\n\n// Used by get_func_tv()\nstatic garray_T funcargs = GA_EMPTY;\n\n// pointer to funccal for currently active function\nstatic funccall_T *current_funccal = NULL;\n\n// Pointer to list of previously used funccal, still around because some\n// item in it is still being used.\nstatic funccall_T *previous_funccal = NULL;\n\nstatic void funccal_unref(funccall_T *fc, ufunc_T *fp, int force);\nstatic void func_clear(ufunc_T *fp, int force);\nstatic int func_free(ufunc_T *fp, int force);\n\n    void\nfunc_init()\n{\n    hash_init(&func_hashtab);\n}\n\n#if defined(FEAT_PROFILE) || defined(PROTO)\n/*\n * Return the function hash table\n */\n    hashtab_T *\nfunc_tbl_get(void)\n{\n    return &func_hashtab;\n}\n#endif\n\n/*\n * Get one function argument.\n * If \"argtypes\" is not NULL also get the type: \"arg: type\" (:def function).\n * If \"types_optional\" is TRUE a missing type is OK, use \"any\".\n * If \"evalarg\" is not NULL use it to check for an already declared name.\n * Return a pointer to after the type.\n * When something is wrong return \"arg\".\n */\n    static char_u *\none_function_arg(\n\tchar_u\t    *arg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg,\n\tint\t    is_vararg,\n\tint\t    skip)\n{\n    char_u\t*p = arg;\n    char_u\t*arg_copy = NULL;\n    int\t\tis_underscore = FALSE;\n\n    while (ASCII_ISALNUM(*p) || *p == '_')\n\t++p;\n    if (arg == p || isdigit(*arg)\n\t    || (argtypes == NULL\n\t\t&& ((p - arg == 9 && STRNCMP(arg, \"firstline\", 9) == 0)\n\t\t    || (p - arg == 8 && STRNCMP(arg, \"lastline\", 8) == 0))))\n    {\n\tif (!skip)\n\t    semsg(_(e_illegal_argument_str), arg);\n\treturn arg;\n    }\n\n    // Vim9 script: cannot use script var name for argument. In function: also\n    // check local vars and arguments.\n    if (!skip && argtypes != NULL && check_defined(arg, p - arg,\n\t\t    evalarg == NULL ? NULL : evalarg->eval_cctx, TRUE) == FAIL)\n\treturn arg;\n\n    if (newargs != NULL && ga_grow(newargs, 1) == FAIL)\n\treturn arg;\n    if (newargs != NULL)\n    {\n\tint\tc;\n\tint\ti;\n\n\tc = *p;\n\t*p = NUL;\n\targ_copy = vim_strsave(arg);\n\tif (arg_copy == NULL)\n\t{\n\t    *p = c;\n\t    return arg;\n\t}\n\tis_underscore = arg_copy[0] == '_' && arg_copy[1] == NUL;\n\tif (argtypes == NULL || !is_underscore)\n\t    // Check for duplicate argument name.\n\t    for (i = 0; i < newargs->ga_len; ++i)\n\t\tif (STRCMP(((char_u **)(newargs->ga_data))[i], arg_copy) == 0)\n\t\t{\n\t\t    semsg(_(e_duplicate_argument_name_str), arg_copy);\n\t\t    vim_free(arg_copy);\n\t\t    return arg;\n\t\t}\n\t((char_u **)(newargs->ga_data))[newargs->ga_len] = arg_copy;\n\tnewargs->ga_len++;\n\n\t*p = c;\n    }\n\n    // get any type from \"arg: type\"\n    if (argtypes != NULL && (skip || ga_grow(argtypes, 1) == OK))\n    {\n\tchar_u *type = NULL;\n\n\tif (VIM_ISWHITE(*p) && *skipwhite(p) == ':')\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_colon_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    p = skipwhite(p);\n\t}\n\tif (*p == ':')\n\t{\n\t    ++p;\n\t    if (!skip && !VIM_ISWHITE(*p))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p - 1);\n\t\treturn arg;\n\t    }\n\t    type = skipwhite(p);\n\t    p = skip_type(type, TRUE);\n\t    if (!skip)\n\t\ttype = vim_strnsave(type, p - type);\n\t}\n\telse if (*skipwhite(p) != '=' && !types_optional && !is_underscore)\n\t{\n\t    semsg(_(e_missing_argument_type_for_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    return arg;\n\t}\n\tif (!skip)\n\t{\n\t    if (type == NULL && types_optional)\n\t\t// lambda arguments default to \"any\" type\n\t\ttype = vim_strsave((char_u *)\n\t\t\t\t\t    (is_vararg ? \"list<any>\" : \"any\"));\n\t    ((char_u **)argtypes->ga_data)[argtypes->ga_len++] = type;\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Handle line continuation in function arguments or body.\n * Get a next line, store it in \"eap\" if appropriate and put the line in\n * \"lines_to_free\" to free the line later.\n */\n    static char_u *\nget_function_line(\n\texarg_T\t\t*eap,\n\tgarray_T\t*lines_to_free,\n\tint\t\tindent,\n\tgetline_opt_T\tgetline_options)\n{\n    char_u *theline;\n\n    if (eap->getline == NULL)\n\ttheline = getcmdline(':', 0L, indent, 0);\n    else\n\ttheline = eap->getline(':', eap->cookie, indent, getline_options);\n    if (theline != NULL)\n    {\n\tif (lines_to_free->ga_len > 0\n\t\t&& *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)\n\t\t\t\t\t\t   [lines_to_free->ga_len - 1])\n\t    *eap->cmdlinep = theline;\n\tga_add_string(lines_to_free, theline);\n    }\n\n    return theline;\n}\n\n/*\n * Get function arguments.\n * \"argp\" should point to just after the \"(\", possibly to white space.\n * \"argp\" is advanced just after \"endchar\".\n */\n    static int\nget_function_args(\n    char_u\t**argp,\n    char_u\tendchar,\n    garray_T\t*newargs,\n    garray_T\t*argtypes,\t// NULL unless using :def\n    int\t\ttypes_optional,\t// types optional if \"argtypes\" is not NULL\n    evalarg_T\t*evalarg,\t// context or NULL\n    int\t\t*varargs,\n    garray_T\t*default_args,\n    int\t\tskip,\n    exarg_T\t*eap,\n    garray_T\t*lines_to_free)\n{\n    int\t\tmustend = FALSE;\n    char_u\t*arg;\n    char_u\t*p;\n    int\t\tc;\n    int\t\tany_default = FALSE;\n    char_u\t*expr;\n    char_u\t*whitep = *argp;\n\n    if (newargs != NULL)\n\tga_init2(newargs, (int)sizeof(char_u *), 3);\n    if (argtypes != NULL)\n\tga_init2(argtypes, (int)sizeof(char_u *), 3);\n    if (!skip && default_args != NULL)\n\tga_init2(default_args, (int)sizeof(char_u *), 3);\n\n    if (varargs != NULL)\n\t*varargs = FALSE;\n\n    /*\n     * Isolate the arguments: \"arg1, arg2, ...)\"\n     */\n    arg = skipwhite(*argp);\n    p = arg;\n    while (*p != endchar)\n    {\n\twhile (eap != NULL && eap->getline != NULL\n\t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n\t{\n\t    // End of the line, get the next one.\n\t    char_u *theline = get_function_line(eap, lines_to_free, 0,\n\t\t\t\t\t\t\t  GETLINE_CONCAT_CONT);\n\n\t    if (theline == NULL)\n\t\tbreak;\n\t    whitep = (char_u *)\" \";\n\t    p = skipwhite(theline);\n\t}\n\n\tif (mustend && *p != endchar)\n\t{\n\t    if (!skip)\n\t\tsemsg(_(e_invalid_argument_str), *argp);\n\t    goto err_ret;\n\t}\n\tif (*p == endchar)\n\t    break;\n\n\tif (p[0] == '.' && p[1] == '.' && p[2] == '.')\n\t{\n\t    if (varargs != NULL)\n\t\t*varargs = TRUE;\n\t    p += 3;\n\t    mustend = TRUE;\n\n\t    if (argtypes != NULL)\n\t    {\n\t\t// ...name: list<type>\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    if (!skip)\n\t\t\temsg(_(e_missing_name_after_dots));\n\t\t    goto err_ret;\n\t\t}\n\n\t\targ = p;\n\t\tp = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t  evalarg, TRUE, skip);\n\t\tif (p == arg)\n\t\t    break;\n\t\tif (*skipwhite(p) == '=')\n\t\t{\n\t\t    emsg(_(e_cannot_use_default_for_variable_arguments));\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *np;\n\n\t    arg = p;\n\t    p = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t\t evalarg, FALSE, skip);\n\t    if (p == arg)\n\t\tbreak;\n\n\t    // Recognize \" = expr\" but not \" == expr\".  A lambda can have\n\t    // \"(a = expr\" but \"(a == expr\" and \"(a =~ expr\" are not a lambda.\n\t    np = skipwhite(p);\n\t    if (*np == '=' && np[1] != '=' && np[1] != '~'\n\t\t\t\t\t\t       && default_args != NULL)\n\t    {\n\t\ttypval_T\trettv;\n\n\t\t// find the end of the expression (doesn't evaluate it)\n\t\tany_default = TRUE;\n\t\tp = skipwhite(p) + 1;\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t\texpr = p;\n\t\tif (eval1(&p, &rettv, NULL) != FAIL)\n\t\t{\n\t\t    if (!skip)\n\t\t    {\n\t\t\tif (ga_grow(default_args, 1) == FAIL)\n\t\t\t    goto err_ret;\n\n\t\t\t// trim trailing whitespace\n\t\t\twhile (p > expr && VIM_ISWHITE(p[-1]))\n\t\t\t    p--;\n\t\t\tc = *p;\n\t\t\t*p = NUL;\n\t\t\texpr = vim_strsave(expr);\n\t\t\tif (expr == NULL)\n\t\t\t{\n\t\t\t    *p = c;\n\t\t\t    goto err_ret;\n\t\t\t}\n\t\t\t((char_u **)(default_args->ga_data))\n\t\t\t\t\t\t [default_args->ga_len] = expr;\n\t\t\tdefault_args->ga_len++;\n\t\t\t*p = c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    mustend = TRUE;\n\t    }\n\t    else if (any_default)\n\t    {\n\t\temsg(_(e_non_default_argument_follows_default_argument));\n\t\tgoto err_ret;\n\t    }\n\n\t    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')\n\t    {\n\t\t// Be tolerant when skipping\n\t\tif (!skip)\n\t\t{\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t\t    goto err_ret;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\t// Don't give this error when skipping, it makes the \"->\" not\n\t\t// found in \"{k,v -> x}\" and give a confusing error.\n\t\t// Allow missing space after comma in legacy functions.\n\t\tif (!skip && argtypes != NULL\n\t\t\t\t      && !IS_WHITE_OR_NUL(*p) && *p != endchar)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\t    goto err_ret;\n\t\t}\n\t    }\n\t    else\n\t\tmustend = TRUE;\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n\n    if (*p != endchar)\n\tgoto err_ret;\n    ++p;\t// skip \"endchar\"\n\n    *argp = p;\n    return OK;\n\nerr_ret:\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    if (!skip && default_args != NULL)\n\tga_clear_strings(default_args);\n    return FAIL;\n}\n\n/*\n * Parse the argument types, filling \"fp->uf_arg_types\".\n * Return OK or FAIL.\n */\n    static int\nparse_argument_types(ufunc_T *fp, garray_T *argtypes, int varargs)\n{\n    int len = 0;\n\n    ga_init2(&fp->uf_type_list, sizeof(type_T *), 10);\n    if (argtypes->ga_len > 0)\n    {\n\t// When \"varargs\" is set the last name/type goes into uf_va_name\n\t// and uf_va_type.\n\tlen = argtypes->ga_len - (varargs ? 1 : 0);\n\n\tif (len > 0)\n\t    fp->uf_arg_types = ALLOC_CLEAR_MULT(type_T *, len);\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    int\ti;\n\t    type_T\t*type;\n\n\t    for (i = 0; i < len; ++ i)\n\t    {\n\t\tchar_u *p = ((char_u **)argtypes->ga_data)[i];\n\n\t\tif (p == NULL)\n\t\t    // will get the type from the default value\n\t\t    type = &t_unknown;\n\t\telse\n\t\t    type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t\tif (type == NULL)\n\t\t    return FAIL;\n\t\tfp->uf_arg_types[i] = type;\n\t    }\n\t}\n    }\n\n    if (varargs)\n    {\n\tchar_u *p;\n\n\t// Move the last argument \"...name: type\" to uf_va_name and\n\t// uf_va_type.\n\tfp->uf_va_name = ((char_u **)fp->uf_args.ga_data)\n\t\t\t\t\t      [fp->uf_args.ga_len - 1];\n\t--fp->uf_args.ga_len;\n\tp = ((char_u **)argtypes->ga_data)[len];\n\tif (p == NULL)\n\t    // TODO: get type from default value\n\t    fp->uf_va_type = &t_list_any;\n\telse\n\t{\n\t    fp->uf_va_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t    if (fp->uf_va_type != NULL && fp->uf_va_type->tt_type != VAR_LIST)\n\t    {\n\t\tsemsg(_(e_variable_arguments_type_must_be_list_str),\n\t\t\t\t\t  ((char_u **)argtypes->ga_data)[len]);\n\t\treturn FAIL;\n\t    }\n\t}\n\tif (fp->uf_va_type == NULL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static int\nparse_return_type(ufunc_T *fp, char_u *ret_type)\n{\n    if (ret_type == NULL)\n\tfp->uf_ret_type = &t_void;\n    else\n    {\n\tchar_u *p = ret_type;\n\n\tfp->uf_ret_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\tif (fp->uf_ret_type == NULL)\n\t{\n\t    fp->uf_ret_type = &t_void;\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Register function \"fp\" as using \"current_funccal\" as its scope.\n */\n    static int\nregister_closure(ufunc_T *fp)\n{\n    if (fp->uf_scoped == current_funccal)\n\t// no change\n\treturn OK;\n    funccal_unref(fp->uf_scoped, fp, FALSE);\n    fp->uf_scoped = current_funccal;\n    current_funccal->fc_refcount++;\n\n    if (ga_grow(&current_funccal->fc_funcs, 1) == FAIL)\n\treturn FAIL;\n    ((ufunc_T **)current_funccal->fc_funcs.ga_data)\n\t[current_funccal->fc_funcs.ga_len++] = fp;\n    return OK;\n}\n\n    static void\nset_ufunc_name(ufunc_T *fp, char_u *name)\n{\n    // Add a type cast to avoid a warning for an overflow, the uf_name[] array\n    // actually extends beyond the struct.\n    STRCPY((void *)fp->uf_name, name);\n\n    if (name[0] == K_SPECIAL)\n    {\n\tfp->uf_name_exp = alloc(STRLEN(name) + 3);\n\tif (fp->uf_name_exp != NULL)\n\t{\n\t    STRCPY(fp->uf_name_exp, \"<SNR>\");\n\t    STRCAT(fp->uf_name_exp, fp->uf_name + 3);\n\t}\n    }\n}\n\n/*\n * Get a name for a lambda.  Returned in static memory.\n */\n    char_u *\nget_lambda_name(void)\n{\n    static char_u   name[30];\n    static int\t    lambda_no = 0;\n\n    sprintf((char*)name, \"<lambda>%d\", ++lambda_no);\n    return name;\n}\n\n#if defined(FEAT_LUA) || defined(PROTO)\n/*\n * Registers a native C callback which can be called from Vim script.\n * Returns the name of the Vim script function.\n */\n    char_u *\nregister_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state)\n{\n    char_u\t*name = get_lambda_name();\n    ufunc_T\t*fp;\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (fp == NULL)\n\treturn NULL;\n\n    fp->uf_def_status = UF_NOT_COMPILED;\n    fp->uf_refcount = 1;\n    fp->uf_varargs = TRUE;\n    fp->uf_flags = FC_CFUNC | FC_LAMBDA;\n    fp->uf_calls = 0;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_cb = cb;\n    fp->uf_cb_free = cb_free;\n    fp->uf_cb_state = state;\n\n    set_ufunc_name(fp, name);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    return name;\n}\n#endif\n\n/*\n * Skip over \"->\" or \"=>\" after the arguments of a lambda.\n * If \": type\" is found make \"ret_type\" point to \"type\".\n * If \"white_error\" is not NULL check for correct use of white space and set\n * \"white_error\" to TRUE if there is an error.\n * Return NULL if no valid arrow found.\n */\n    static char_u *\nskip_arrow(\n\tchar_u\t*start,\n\tint\tequal_arrow,\n\tchar_u\t**ret_type,\n\tint\t*white_error)\n{\n    char_u  *s = start;\n    char_u  *bef = start - 2; // \"start\" points to > of ->\n\n    if (equal_arrow)\n    {\n\tif (*s == ':')\n\t{\n\t    if (white_error != NULL && !VIM_ISWHITE(s[1]))\n\t    {\n\t\t*white_error = TRUE;\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", s);\n\t\treturn NULL;\n\t    }\n\t    s = skipwhite(s + 1);\n\t    *ret_type = s;\n\t    s = skip_type(s, TRUE);\n\t    if (s == *ret_type)\n\t    {\n\t\temsg(_(e_missing_return_type));\n\t\treturn NULL;\n\t    }\n\t}\n\tbef = s;\n\ts = skipwhite(s);\n\tif (*s != '=')\n\t    return NULL;\n\t++s;\n    }\n    if (*s != '>')\n\treturn NULL;\n    if (white_error != NULL && ((!VIM_ISWHITE(*bef) && *bef != '{')\n\t\t|| !IS_WHITE_OR_NUL(s[1])))\n    {\n\t*white_error = TRUE;\n\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t       equal_arrow ? \"=>\" : \"->\", bef);\n\treturn NULL;\n    }\n    return skipwhite(s + 1);\n}\n\n/*\n * Check if \"*cmd\" points to a function command and if so advance \"*cmd\" and\n * return TRUE.\n * Otherwise return FALSE;\n * Do not consider \"function(\" to be a command.\n */\n    static int\nis_function_cmd(char_u **cmd)\n{\n    char_u *p = *cmd;\n\n    if (checkforcmd(&p, \"function\", 2))\n    {\n\tif (*p == '(')\n\t    return FALSE;\n\t*cmd = p;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Called when defining a function: The context may be needed for script\n * variables declared in a block that is visible now but not when the function\n * is compiled or called later.\n */\n    static void\nfunction_using_block_scopes(ufunc_T *fp, cstack_T *cstack)\n{\n    if (cstack != NULL && cstack->cs_idx >= 0)\n    {\n\tint\t    count = cstack->cs_idx + 1;\n\tint\t    i;\n\n\tfp->uf_block_ids = ALLOC_MULT(int, count);\n\tif (fp->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(fp->uf_block_ids, cstack->cs_block_id,\n\t\t\t\t\t\t\t  sizeof(int) * count);\n\t    fp->uf_block_depth = count;\n\t}\n\n\t// Set flag in each block to indicate a function was defined.  This\n\t// is used to keep the variable when leaving the block, see\n\t// hide_script_var().\n\tfor (i = 0; i <= cstack->cs_idx; ++i)\n\t    cstack->cs_flags[i] |= CSF_FUNC_DEF;\n    }\n}\n\n/*\n * Read the body of a function, put every line in \"newlines\".\n * This stops at \"}\", \"endfunction\" or \"enddef\".\n * \"newlines\" must already have been initialized.\n * \"eap->cmdidx\" is CMD_function, CMD_def or CMD_block;\n */\n    static int\nget_function_body(\n\texarg_T\t    *eap,\n\tgarray_T    *newlines,\n\tchar_u\t    *line_arg_in,\n\tgarray_T    *lines_to_free)\n{\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n    linenr_T\tsourcing_lnum_off;\n    int\t\tsaved_wait_return = need_wait_return;\n    char_u\t*line_arg = line_arg_in;\n    int\t\tvim9_function = eap->cmdidx == CMD_def\n\t\t\t\t\t\t   || eap->cmdidx == CMD_block;\n#define MAX_FUNC_NESTING 50\n    char\tnesting_def[MAX_FUNC_NESTING];\n    char\tnesting_inline[MAX_FUNC_NESTING];\n    int\t\tnesting = 0;\n    getline_opt_T getline_options;\n    int\t\tindent = 2;\n    char_u\t*skip_until = NULL;\n    int\t\tret = FAIL;\n    int\t\tis_heredoc = FALSE;\n    int\t\theredoc_concat_len = 0;\n    garray_T\theredoc_ga;\n    char_u\t*heredoc_trimmed = NULL;\n\n    ga_init2(&heredoc_ga, 1, 500);\n\n    // Detect having skipped over comment lines to find the return\n    // type.  Add NULL lines to keep the line count correct.\n    sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n    if (SOURCING_LNUM < sourcing_lnum_off)\n    {\n\tsourcing_lnum_off -= SOURCING_LNUM;\n\tif (ga_grow(newlines, sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n    }\n\n    nesting_def[0] = vim9_function;\n    nesting_inline[0] = eap->cmdidx == CMD_block;\n    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n    for (;;)\n    {\n\tchar_u\t*theline;\n\tchar_u\t*p;\n\tchar_u\t*arg;\n\n\tif (KeyTyped)\n\t{\n\t    msg_scroll = TRUE;\n\t    saved_wait_return = FALSE;\n\t}\n\tneed_wait_return = FALSE;\n\n\tif (line_arg != NULL)\n\t{\n\t    // Use eap->arg, split up in parts by line breaks.\n\t    theline = line_arg;\n\t    p = vim_strchr(theline, '\\n');\n\t    if (p == NULL)\n\t\tline_arg += STRLEN(line_arg);\n\t    else\n\t    {\n\t\t*p = NUL;\n\t\tline_arg = p + 1;\n\t    }\n\t}\n\telse\n\t{\n\t    theline = get_function_line(eap, lines_to_free, indent,\n\t\t\t\t\t\t\t      getline_options);\n\t}\n\tif (KeyTyped)\n\t    lines_left = Rows - 1;\n\tif (theline == NULL)\n\t{\n\t    // Use the start of the function for the line number.\n\t    SOURCING_LNUM = sourcing_lnum_top;\n\t    if (skip_until != NULL)\n\t\tsemsg(_(e_missing_heredoc_end_marker_str), skip_until);\n\t    else if (nesting_inline[nesting])\n\t\temsg(_(e_missing_end_block));\n\t    else if (eap->cmdidx == CMD_def)\n\t\temsg(_(e_missing_enddef));\n\t    else\n\t\temsg(_(e_missing_endfunction));\n\t    goto theend;\n\t}\n\n\t// Detect line continuation: SOURCING_LNUM increased more than one.\n\tsourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n\tif (SOURCING_LNUM < sourcing_lnum_off)\n\t    sourcing_lnum_off -= SOURCING_LNUM;\n\telse\n\t    sourcing_lnum_off = 0;\n\n\tif (skip_until != NULL)\n\t{\n\t    // Don't check for \":endfunc\"/\":enddef\" between\n\t    // * \":append\" and \".\"\n\t    // * \":python <<EOF\" and \"EOF\"\n\t    // * \":let {var-name} =<< [trim] {marker}\" and \"{marker}\"\n\t    if (heredoc_trimmed == NULL\n\t\t    || (is_heredoc && skipwhite(theline) == theline)\n\t\t    || STRNCMP(theline, heredoc_trimmed,\n\t\t\t\t\t\t STRLEN(heredoc_trimmed)) == 0)\n\t    {\n\t\tif (heredoc_trimmed == NULL)\n\t\t    p = theline;\n\t\telse if (is_heredoc)\n\t\t    p = skipwhite(theline) == theline\n\t\t\t\t ? theline : theline + STRLEN(heredoc_trimmed);\n\t\telse\n\t\t    p = theline + STRLEN(heredoc_trimmed);\n\t\tif (STRCMP(p, skip_until) == 0)\n\t\t{\n\t\t    VIM_CLEAR(skip_until);\n\t\t    VIM_CLEAR(heredoc_trimmed);\n\t\t    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n\t\t    is_heredoc = FALSE;\n\n\t\t    if (heredoc_concat_len > 0)\n\t\t    {\n\t\t\t// Replace the starting line with all the concatenated\n\t\t\t// lines.\n\t\t\tga_concat(&heredoc_ga, theline);\n\t\t\tvim_free(((char_u **)(newlines->ga_data))[\n\t\t\t\t\t\t      heredoc_concat_len - 1]);\n\t\t\t((char_u **)(newlines->ga_data))[\n\t\t\t\t  heredoc_concat_len - 1] = heredoc_ga.ga_data;\n\t\t\tga_init(&heredoc_ga);\n\t\t\theredoc_concat_len = 0;\n\t\t\ttheline += STRLEN(theline);  // skip the \"EOF\"\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    int\t    c;\n\t    char_u  *end;\n\n\t    // skip ':' and blanks\n\t    for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)\n\t\t;\n\n\t    // Check for \"endfunction\", \"enddef\" or \"}\".\n\t    // When a \":\" follows it must be a dict key; \"enddef: value,\"\n\t    if (nesting_inline[nesting]\n\t\t    ? *p == '}'\n\t\t    : (checkforcmd(&p, nesting_def[nesting]\n\t\t\t\t\t\t? \"enddef\" : \"endfunction\", 4)\n\t\t\t&& *p != ':'))\n\t    {\n\t\tif (nesting-- == 0)\n\t\t{\n\t\t    char_u *nextcmd = NULL;\n\n\t\t    if (*p == '|' || *p == '}')\n\t\t\tnextcmd = p + 1;\n\t\t    else if (line_arg != NULL && *skipwhite(line_arg) != NUL)\n\t\t\tnextcmd = line_arg;\n\t\t    else if (*p != NUL && *p != (vim9_function ? '#' : '\"')\n\t\t\t\t\t   && (vim9_function || p_verbose > 0))\n\t\t    {\n\t\t\tSOURCING_LNUM = sourcing_lnum_top\n\t\t\t\t\t\t\t+ newlines->ga_len + 1;\n\t\t\tif (eap->cmdidx == CMD_def)\n\t\t\t    semsg(_(e_text_found_after_str_str), \"enddef\", p);\n\t\t\telse\n\t\t\t    give_warning2((char_u *)\n\t\t\t\t   _(\"W22: Text found after :endfunction: %s\"),\n\t\t\t\t   p, TRUE);\n\t\t    }\n\t\t    if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)\n\t\t    {\n\t\t\t// Another command follows. If the line came from \"eap\"\n\t\t\t// we can simply point into it, otherwise we need to\n\t\t\t// change \"eap->cmdlinep\" to point to the last fetched\n\t\t\t// line.\n\t\t\teap->nextcmd = nextcmd;\n\t\t\tif (lines_to_free->ga_len > 0\n\t\t\t\t&& *eap->cmdlinep !=\n\t\t\t\t\t    ((char_u **)lines_to_free->ga_data)\n\t\t\t\t\t\t   [lines_to_free->ga_len - 1])\n\t\t\t{\n\t\t\t    // *cmdlinep will be freed later, thus remove the\n\t\t\t    // line from lines_to_free.\n\t\t\t    vim_free(*eap->cmdlinep);\n\t\t\t    *eap->cmdlinep = ((char_u **)lines_to_free->ga_data)\n\t\t\t\t\t\t   [lines_to_free->ga_len - 1];\n\t\t\t    --lines_to_free->ga_len;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\n\t    // Check for mismatched \"endfunc\" or \"enddef\".\n\t    // We don't check for \"def\" inside \"func\" thus we also can't check\n\t    // for \"enddef\".\n\t    // We continue to find the end of the function, although we might\n\t    // not find it.\n\t    else if (nesting_def[nesting])\n\t    {\n\t\tif (checkforcmd(&p, \"endfunction\", 4) && *p != ':')\n\t\t    emsg(_(e_mismatched_endfunction));\n\t    }\n\t    else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))\n\t\temsg(_(e_mismatched_enddef));\n\n\t    // Increase indent inside \"if\", \"while\", \"for\" and \"try\", decrease\n\t    // at \"end\".\n\t    if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))\n\t\tindent -= 2;\n\t    else if (STRNCMP(p, \"if\", 2) == 0\n\t\t    || STRNCMP(p, \"wh\", 2) == 0\n\t\t    || STRNCMP(p, \"for\", 3) == 0\n\t\t    || STRNCMP(p, \"try\", 3) == 0)\n\t\tindent += 2;\n\n\t    // Check for defining a function inside this function.\n\t    // Only recognize \"def\" inside \"def\", not inside \"function\",\n\t    // For backwards compatibility, see Test_function_python().\n\t    c = *p;\n\t    if (is_function_cmd(&p)\n\t\t    || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))\n\t    {\n\t\tif (*p == '!')\n\t\t    p = skipwhite(p + 1);\n\t\tp += eval_fname_script(p);\n\t\tvim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,\n\t\t\t\t\t\t\t\t  NULL, NULL));\n\t\tif (*skipwhite(p) == '(')\n\t\t{\n\t\t    if (nesting == MAX_FUNC_NESTING - 1)\n\t\t\temsg(_(e_function_nesting_too_deep));\n\t\t    else\n\t\t    {\n\t\t\t++nesting;\n\t\t\tnesting_def[nesting] = (c == 'd');\n\t\t\tnesting_inline[nesting] = FALSE;\n\t\t\tindent += 2;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (nesting_def[nesting] ? *p != '#' : *p != '\"')\n\t    {\n\t\t// Not a comment line: check for nested inline function.\n\t\tend = p + STRLEN(p) - 1;\n\t\twhile (end > p && VIM_ISWHITE(*end))\n\t\t    --end;\n\t\tif (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))\n\t\t{\n\t\t    int\t    is_block;\n\n\t\t    // check for trailing \"=> {\": start of an inline function\n\t\t    --end;\n\t\t    while (end > p && VIM_ISWHITE(*end))\n\t\t\t--end;\n\t\t    is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';\n\t\t    if (!is_block)\n\t\t    {\n\t\t\tchar_u *s = p;\n\n\t\t\t// check for line starting with \"au\" for :autocmd or\n\t\t\t// \"com\" for :command, these can use a {} block\n\t\t\tis_block = checkforcmd_noparen(&s, \"autocmd\", 2)\n\t\t\t\t      || checkforcmd_noparen(&s, \"command\", 3);\n\t\t    }\n\n\t\t    if (is_block)\n\t\t    {\n\t\t\tif (nesting == MAX_FUNC_NESTING - 1)\n\t\t\t    emsg(_(e_function_nesting_too_deep));\n\t\t\telse\n\t\t\t{\n\t\t\t    ++nesting;\n\t\t\t    nesting_def[nesting] = TRUE;\n\t\t\t    nesting_inline[nesting] = TRUE;\n\t\t\t    indent += 2;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Check for \":append\", \":change\", \":insert\".  Not for :def.\n\t    p = skip_range(p, FALSE, NULL);\n\t    if (!vim9_function\n\t\t&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))\n\t\t    || (p[0] == 'c'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'\n\t\t\t\t\t&& (STRNCMP(&p[3], \"nge\", 3) != 0\n\t\t\t\t\t    || !ASCII_ISALPHA(p[6])))))))\n\t\t    || (p[0] == 'i'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2])\n\t\t\t\t    || (p[2] == 's'\n\t\t\t\t\t&& (!ASCII_ISALPHA(p[3])\n\t\t\t\t\t\t|| p[3] == 'e'))))))))\n\t\tskip_until = vim_strsave((char_u *)\".\");\n\n\t    // Check for \":python <<EOF\", \":tcl <<EOF\", etc.\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (arg[0] == '<' && arg[1] =='<'\n\t\t    && ((p[0] == 'p' && p[1] == 'y'\n\t\t\t\t    && (!ASCII_ISALNUM(p[2]) || p[2] == 't'\n\t\t\t\t\t|| ((p[2] == '3' || p[2] == 'x')\n\t\t\t\t\t\t   && !ASCII_ISALPHA(p[3]))))\n\t\t\t|| (p[0] == 'p' && p[1] == 'e'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))\n\t\t\t|| (p[0] == 't' && p[1] == 'c'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))\n\t\t\t|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'\n\t\t\t\t    && !ASCII_ISALPHA(p[3]))\n\t\t\t|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'\n\t\t\t\t    && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))\n\t\t\t|| (p[0] == 'm' && p[1] == 'z'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))\n\t\t\t))\n\t    {\n\t\t// \":python <<\" continues until a dot, like \":append\"\n\t\tp = skipwhite(arg + 2);\n\t\tif (STRNCMP(p, \"trim\", 4) == 0)\n\t\t{\n\t\t    // Ignore leading white space.\n\t\t    p = skipwhite(p + 4);\n\t\t    heredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t}\n\t\tif (*p == NUL)\n\t\t    skip_until = vim_strsave((char_u *)\".\");\n\t\telse\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\tgetline_options = GETLINE_NONE;\n\t\tis_heredoc = TRUE;\n\t\tif (eap->cmdidx == CMD_def)\n\t\t    heredoc_concat_len = newlines->ga_len + 1;\n\t    }\n\n\t    // Check for \":cmd v =<< [trim] EOF\"\n\t    //       and \":cmd [a, b] =<< [trim] EOF\"\n\t    //       and \"lines =<< [trim] EOF\" for Vim9\n\t    // Where \"cmd\" can be \"let\", \"var\", \"final\" or \"const\".\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (*arg == '[')\n\t\targ = vim_strchr(arg, ']');\n\t    if (arg != NULL)\n\t    {\n\t\tint found = (eap->cmdidx == CMD_def && arg[0] == '='\n\t\t\t\t\t     && arg[1] == '<' && arg[2] =='<');\n\n\t\tif (!found)\n\t\t    // skip over the argument after \"cmd\"\n\t\t    arg = skipwhite(skiptowhite(arg));\n\t\tif (found || (arg[0] == '=' && arg[1] == '<' && arg[2] =='<'\n\t\t\t&& (checkforcmd(&p, \"let\", 2)\n\t\t\t    || checkforcmd(&p, \"var\", 3)\n\t\t\t    || checkforcmd(&p, \"final\", 5)\n\t\t\t    || checkforcmd(&p, \"const\", 5))))\n\t\t{\n\t\t    p = skipwhite(arg + 3);\n\t\t    if (STRNCMP(p, \"trim\", 4) == 0)\n\t\t    {\n\t\t\t// Ignore leading white space.\n\t\t\tp = skipwhite(p + 4);\n\t\t\theredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t    }\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\t    getline_options = GETLINE_NONE;\n\t\t    is_heredoc = TRUE;\n\t\t}\n\t    }\n\t}\n\n\t// Add the line to the function.\n\tif (ga_grow(newlines, 1 + sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\n\tif (heredoc_concat_len > 0)\n\t{\n\t    // For a :def function \"python << EOF\" concatenates all the lines,\n\t    // to be used for the instruction later.\n\t    ga_concat(&heredoc_ga, theline);\n\t    ga_concat(&heredoc_ga, (char_u *)\"\\n\");\n\t    p = vim_strsave((char_u *)\"\");\n\t}\n\telse\n\t{\n\t    // Copy the line to newly allocated memory.  get_one_sourceline()\n\t    // allocates 250 bytes per line, this saves 80% on average.  The\n\t    // cost is an extra alloc/free.\n\t    p = vim_strsave(theline);\n\t}\n\tif (p == NULL)\n\t    goto theend;\n\t((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;\n\n\t// Add NULL lines for continuation lines, so that the line count is\n\t// equal to the index in the growarray.\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n\n\t// Check for end of eap->arg.\n\tif (line_arg != NULL && *line_arg == NUL)\n\t    line_arg = NULL;\n    }\n\n    // Return OK when no error was detected.\n    if (!did_emsg)\n\tret = OK;\n\ntheend:\n    vim_free(skip_until);\n    vim_free(heredoc_trimmed);\n    vim_free(heredoc_ga.ga_data);\n    need_wait_return |= saved_wait_return;\n    return ret;\n}\n\n/*\n * Handle the body of a lambda.  *arg points to the \"{\", process statements\n * until the matching \"}\".\n * When not evaluating \"newargs\" is NULL.\n * When successful \"rettv\" is set to a funcref.\n */\n    static int\nlambda_function_body(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tevalarg_T   *evalarg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    varargs,\n\tgarray_T    *default_args,\n\tchar_u\t    *ret_type)\n{\n    int\t\tevaluate = (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\t*gap = &evalarg->eval_ga;\n    garray_T\t*freegap = &evalarg->eval_freega;\n    ufunc_T\t*ufunc = NULL;\n    exarg_T\teap;\n    garray_T\tnewlines;\n    char_u\t*cmdline = NULL;\n    int\t\tret = FAIL;\n    partial_T\t*pt;\n    char_u\t*name;\n    int\t\tlnum_save = -1;\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n\n    if (!ends_excmd2(*arg, skipwhite(*arg + 1)))\n    {\n\tsemsg(_(e_trailing_characters_str), *arg + 1);\n\treturn FAIL;\n    }\n\n    CLEAR_FIELD(eap);\n    eap.cmdidx = CMD_block;\n    eap.forceit = FALSE;\n    eap.cmdlinep = &cmdline;\n    eap.skip = !evaluate;\n    if (evalarg->eval_cctx != NULL)\n\tfill_exarg_from_cctx(&eap, evalarg->eval_cctx);\n    else\n    {\n\teap.getline = evalarg->eval_getline;\n\teap.cookie = evalarg->eval_cookie;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n    if (get_function_body(&eap, &newlines, NULL,\n\t\t\t\t\t     &evalarg->eval_tofree_ga) == FAIL)\n\tgoto erret;\n\n    // When inside a lambda must add the function lines to evalarg.eval_ga.\n    evalarg->eval_break_count += newlines.ga_len;\n    if (gap->ga_itemsize > 0)\n    {\n\tint\tidx;\n\tchar_u\t*last;\n\tsize_t  plen;\n\tchar_u  *pnl;\n\n\tfor (idx = 0; idx < newlines.ga_len; ++idx)\n\t{\n\t    char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);\n\n\t    if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t\tgoto erret;\n\n\t    // Going to concatenate the lines after parsing.  For an empty or\n\t    // comment line use an empty string.\n\t    // Insert NL characters at the start of each line, the string will\n\t    // be split again later in .get_lambda_tv().\n\t    if (*p == NUL || vim9_comment_start(p))\n\t\tp = (char_u *)\"\";\n\t    plen = STRLEN(p);\n\t    pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\t    if (pnl != NULL)\n\t\tmch_memmove(pnl + 1, p, plen + 1);\n\t    ((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t    ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n\t}\n\tif (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t    goto erret;\n\tif (eap.nextcmd != NULL)\n\t    // more is following after the \"}\", which was skipped\n\t    last = cmdline;\n\telse\n\t    // nothing is following the \"}\"\n\t    last = (char_u *)\"}\";\n\tplen = STRLEN(last);\n\tpnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\tif (pnl != NULL)\n\t    mch_memmove(pnl + 1, last, plen + 1);\n\t((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n    }\n\n    if (eap.nextcmd != NULL)\n    {\n\tgarray_T *tfgap = &evalarg->eval_tofree_ga;\n\n\t// Something comes after the \"}\".\n\t*arg = eap.nextcmd;\n\n\t// \"arg\" points into cmdline, need to keep the line and free it later.\n\tif (ga_grow(tfgap, 1) == OK)\n\t{\n\t    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;\n\t    evalarg->eval_using_cmdline = TRUE;\n\t}\n    }\n    else\n\t*arg = (char_u *)\"\";\n\n    if (!evaluate)\n    {\n\tret = OK;\n\tgoto erret;\n    }\n\n    name = get_lambda_name();\n    ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (ufunc == NULL)\n\tgoto erret;\n    set_ufunc_name(ufunc, name);\n    if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)\n\tgoto erret;\n    ufunc->uf_flags = FC_LAMBDA;\n    ufunc->uf_refcount = 1;\n    ufunc->uf_args = *newargs;\n    newargs->ga_data = NULL;\n    ufunc->uf_def_args = *default_args;\n    default_args->ga_data = NULL;\n    ufunc->uf_func_type = &t_func_any;\n\n    // error messages are for the first function line\n    lnum_save = SOURCING_LNUM;\n    SOURCING_LNUM = sourcing_lnum_top;\n\n    // parse argument types\n    if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)\n    {\n\tSOURCING_LNUM = lnum_save;\n\tgoto erret;\n    }\n\n    // parse the return type, if any\n    if (parse_return_type(ufunc, ret_type) == FAIL)\n\tgoto erret;\n\n    pt = ALLOC_CLEAR_ONE(partial_T);\n    if (pt == NULL)\n\tgoto erret;\n    pt->pt_func = ufunc;\n    pt->pt_refcount = 1;\n\n    ufunc->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if (sandbox)\n\tufunc->uf_flags |= FC_SANDBOX;\n    if (!ASCII_ISUPPER(*ufunc->uf_name))\n\tufunc->uf_flags |= FC_VIM9;\n    ufunc->uf_script_ctx = current_sctx;\n    ufunc->uf_script_ctx_version = current_sctx.sc_version;\n    ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    set_function_type(ufunc);\n\n    function_using_block_scopes(ufunc, evalarg->eval_cstack);\n\n    rettv->vval.v_partial = pt;\n    rettv->v_type = VAR_PARTIAL;\n    ufunc = NULL;\n    ret = OK;\n\nerret:\n    if (lnum_save >= 0)\n\tSOURCING_LNUM = lnum_save;\n    ga_clear_strings(&newlines);\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    ga_clear_strings(default_args);\n    if (ufunc != NULL)\n    {\n\tfunc_clear(ufunc, TRUE);\n\tfunc_free(ufunc, TRUE);\n    }\n    return ret;\n}\n\n/*\n * Parse a lambda expression and get a Funcref from \"*arg\" into \"rettv\".\n * \"arg\" points to the { in \"{arg -> expr}\" or the ( in \"(arg) => expr\"\n * When \"types_optional\" is TRUE optionally take argument types.\n * Return OK or FAIL.  Returns NOTDONE for dict or {expr}.\n */\n    int\nget_lambda_tv(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg)\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\tnewargs;\n    garray_T\tnewlines;\n    garray_T\t*pnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    ufunc_T\t*fp = NULL;\n    partial_T   *pt = NULL;\n    int\t\tvarargs;\n    char_u\t*ret_type = NULL;\n    int\t\tret;\n    char_u\t*s;\n    char_u\t*start, *end;\n    int\t\t*old_eval_lavars = eval_lavars_used;\n    int\t\teval_lavars = FALSE;\n    char_u\t*tofree1 = NULL;\n    char_u\t*tofree2 = NULL;\n    int\t\tequal_arrow = **arg == '(';\n    int\t\twhite_error = FALSE;\n    int\t\tcalled_emsg_start = called_emsg;\n\n    if (equal_arrow && !in_vim9script())\n\treturn NOTDONE;\n\n    ga_init(&newargs);\n    ga_init(&newlines);\n\n    // First, check if this is really a lambda expression. \"->\" or \"=>\" must\n    // be found after the arguments.\n    s = *arg + 1;\n    ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\tNULL, &default_args, TRUE, NULL, NULL);\n    if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\treturn called_emsg == called_emsg_start ? NOTDONE : FAIL;\n    }\n\n    // Parse the arguments for real.\n    if (evaluate)\n\tpnewargs = &newargs;\n    else\n\tpnewargs = NULL;\n    *arg += 1;\n    ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\t    &varargs, &default_args,\n\t\t\t\t\t    FALSE, NULL, NULL);\n    if (ret == FAIL\n\t\t  || (s = skip_arrow(*arg, equal_arrow, &ret_type,\n\t\tequal_arrow || in_vim9script() ? &white_error : NULL)) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\tga_clear_strings(&newargs);\n\treturn white_error ? FAIL : NOTDONE;\n    }\n    *arg = s;\n\n    // Skipping over linebreaks may make \"ret_type\" invalid, make a copy.\n    if (ret_type != NULL)\n    {\n\tret_type = vim_strsave(ret_type);\n\ttofree2 = ret_type;\n    }\n\n    // Set up a flag for checking local variables and arguments.\n    if (evaluate)\n\teval_lavars_used = &eval_lavars;\n\n    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\n    // Recognize \"{\" as the start of a function body.\n    if (equal_arrow && **arg == '{')\n    {\n\tif (evalarg == NULL)\n\t    // cannot happen?\n\t    goto theend;\n\tif (lambda_function_body(arg, rettv, evalarg, pnewargs,\n\t\t\t   types_optional ? &argtypes : NULL, varargs,\n\t\t\t   &default_args, ret_type) == FAIL)\n\t    goto errret;\n\tgoto theend;\n    }\n    if (default_args.ga_len > 0)\n    {\n\temsg(_(e_cannot_use_default_values_in_lambda));\n\tgoto errret;\n    }\n\n    // Get the start and the end of the expression.\n    start = *arg;\n    ret = skip_expr_concatenate(arg, &start, &end, evalarg);\n    if (ret == FAIL)\n\tgoto errret;\n    if (evalarg != NULL)\n    {\n\t// avoid that the expression gets freed when another line break follows\n\ttofree1 = evalarg->eval_tofree;\n\tevalarg->eval_tofree = NULL;\n    }\n\n    if (!equal_arrow)\n    {\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != '}')\n\t{\n\t    semsg(_(e_expected_right_curly_str), *arg);\n\t    goto errret;\n\t}\n\t++*arg;\n    }\n\n    if (evaluate)\n    {\n\tint\t    len;\n\tint\t    flags = FC_LAMBDA;\n\tchar_u\t    *p;\n\tchar_u\t    *line_end;\n\tchar_u\t    *name = get_lambda_name();\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto errret;\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\tpt = ALLOC_CLEAR_ONE(partial_T);\n\tif (pt == NULL)\n\t    goto errret;\n\n\tga_init2(&newlines, (int)sizeof(char_u *), 1);\n\tif (ga_grow(&newlines, 1) == FAIL)\n\t    goto errret;\n\n\t// If there are line breaks, we need to split up the string.\n\tline_end = vim_strchr(start, '\\n');\n\tif (line_end == NULL || line_end > end)\n\t    line_end = end;\n\n\t// Add \"return \" before the expression (or the first line).\n\tlen = 7 + (int)(line_end - start) + 1;\n\tp = alloc(len);\n\tif (p == NULL)\n\t    goto errret;\n\t((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;\n\tSTRCPY(p, \"return \");\n\tvim_strncpy(p + 7, start, line_end - start);\n\n\tif (line_end != end)\n\t{\n\t    // Add more lines, split by line breaks.  Thus is used when a\n\t    // lambda with { cmds } is encountered.\n\t    while (*line_end == '\\n')\n\t    {\n\t\tif (ga_grow(&newlines, 1) == FAIL)\n\t\t    goto errret;\n\t\tstart = line_end + 1;\n\t\tline_end = vim_strchr(start, '\\n');\n\t\tif (line_end == NULL)\n\t\t    line_end = end;\n\t\t((char_u **)(newlines.ga_data))[newlines.ga_len++] =\n\t\t\t\t\t vim_strnsave(start, line_end - start);\n\t    }\n\t}\n\n\tif (strstr((char *)p + 7, \"a:\") == NULL)\n\t    // No a: variables are used for sure.\n\t    flags |= FC_NOARGS;\n\n\tfp->uf_refcount = 1;\n\tset_ufunc_name(fp, name);\n\tfp->uf_args = newargs;\n\tga_init(&fp->uf_def_args);\n\tif (types_optional)\n\t{\n\t    if (parse_argument_types(fp, &argtypes,\n\t\t\t\t\t   in_vim9script() && varargs) == FAIL)\n\t\tgoto errret;\n\t    if (ret_type != NULL)\n\t    {\n\t\tfp->uf_ret_type = parse_type(&ret_type,\n\t\t\t\t\t\t      &fp->uf_type_list, TRUE);\n\t\tif (fp->uf_ret_type == NULL)\n\t\t    goto errret;\n\t    }\n\t    else\n\t\tfp->uf_ret_type = &t_unknown;\n\t}\n\n\tfp->uf_lines = newlines;\n\tif (current_funccal != NULL && eval_lavars)\n\t{\n\t    flags |= FC_CLOSURE;\n\t    if (register_closure(fp) == FAIL)\n\t\tgoto errret;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (prof_def_func())\n\t    func_do_profile(fp);\n#endif\n\tif (sandbox)\n\t    flags |= FC_SANDBOX;\n\t// In legacy script a lambda can be called with more args than\n\t// uf_args.ga_len.  In Vim9 script \"...name\" has to be used.\n\tfp->uf_varargs = !in_vim9script() || varargs;\n\tfp->uf_flags = flags;\n\tfp->uf_calls = 0;\n\tfp->uf_script_ctx = current_sctx;\n\tfp->uf_script_ctx.sc_lnum += SOURCING_LNUM - newlines.ga_len + 1;\n\n\tfunction_using_block_scopes(fp, evalarg->eval_cstack);\n\n\tpt->pt_func = fp;\n\tpt->pt_refcount = 1;\n\trettv->vval.v_partial = pt;\n\trettv->v_type = VAR_PARTIAL;\n\n\thash_add(&func_hashtab, UF2HIKEY(fp));\n    }\n\ntheend:\n    eval_lavars_used = old_eval_lavars;\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    if (types_optional)\n\tga_clear_strings(&argtypes);\n\n    return OK;\n\nerrret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&newlines);\n    ga_clear_strings(&default_args);\n    if (types_optional)\n    {\n\tga_clear_strings(&argtypes);\n\tif (fp != NULL)\n\t    vim_free(fp->uf_arg_types);\n    }\n    vim_free(fp);\n    vim_free(pt);\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    eval_lavars_used = old_eval_lavars;\n    return FAIL;\n}\n\n/*\n * Check if \"name\" is a variable of type VAR_FUNC.  If so, return the function\n * name it contains, otherwise return \"name\".\n * If \"partialp\" is not NULL, and \"name\" is of type VAR_PARTIAL also set\n * \"partialp\".\n * If \"type\" is not NULL and a Vim9 script-local variable is found look up the\n * type of the variable.\n * If \"found_var\" is not NULL and a variable was found set it to TRUE.\n */\n    char_u *\nderef_func_name(\n\tchar_u\t    *name,\n\tint\t    *lenp,\n\tpartial_T   **partialp,\n\ttype_T\t    **type,\n\tint\t    no_autoload,\n\tint\t    *found_var)\n{\n    dictitem_T\t*v;\n    typval_T\t*tv = NULL;\n    int\t\tcc;\n    char_u\t*s = NULL;\n    hashtab_T\t*ht;\n    int\t\tdid_type = FALSE;\n\n    if (partialp != NULL)\n\t*partialp = NULL;\n\n    cc = name[*lenp];\n    name[*lenp] = NUL;\n\n    v = find_var_also_in_script(name, &ht, no_autoload);\n    name[*lenp] = cc;\n    if (v != NULL)\n    {\n\ttv = &v->di_tv;\n    }\n    else if (in_vim9script() || STRNCMP(name, \"s:\", 2) == 0)\n    {\n\timported_T  *import;\n\tchar_u\t    *p = name;\n\tint\t    len = *lenp;\n\n\tif (STRNCMP(name, \"s:\", 2) == 0)\n\t{\n\t    p = name + 2;\n\t    len -= 2;\n\t}\n\timport = find_imported(p, len, NULL);\n\n\t// imported function from another script\n\tif (import != NULL)\n\t{\n\t    name[len] = NUL;\n\t    semsg(_(e_cannot_use_str_itself_it_is_imported), name);\n\t    name[len] = cc;\n\t    *lenp = 0;\n\t    return (char_u *)\"\";\t// just in case\n\t}\n    }\n\n    if (tv != NULL)\n    {\n\tif (found_var != NULL)\n\t    *found_var = TRUE;\n\tif (tv->v_type == VAR_FUNC)\n\t{\n\t    if (tv->vval.v_string == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    s = tv->vval.v_string;\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (tv->v_type == VAR_PARTIAL)\n\t{\n\t    partial_T *pt = tv->vval.v_partial;\n\n\t    if (pt == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    if (partialp != NULL)\n\t\t*partialp = pt;\n\t    s = partial_name(pt);\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (s != NULL)\n\t{\n\t    if (!did_type && type != NULL && ht == get_script_local_ht())\n\t    {\n\t\tsvar_T  *sv = find_typval_in_script(tv, 0);\n\n\t\tif (sv != NULL)\n\t\t    *type = sv->sv_type;\n\t    }\n\t    return s;\n\t}\n    }\n\n    return name;\n}\n\n/*\n * Give an error message with a function name.  Handle <SNR> things.\n * \"ermsg\" is to be passed without translation, use N_() instead of _().\n */\n    void\nemsg_funcname(char *ermsg, char_u *name)\n{\n    char_u\t*p;\n\n    if (*name == K_SPECIAL)\n\tp = concat_str((char_u *)\"<SNR>\", name + 3);\n    else\n\tp = name;\n    semsg(_(ermsg), p);\n    if (p != name)\n\tvim_free(p);\n}\n\n/*\n * Allocate a variable for the result of a function.\n * Return OK or FAIL.\n */\n    int\nget_func_tv(\n    char_u\t*name,\t\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\n    char_u\t**arg,\t\t// argument, pointing to the '('\n    evalarg_T\t*evalarg,\t// for line continuation\n    funcexe_T\t*funcexe)\t// various values\n{\n    char_u\t*argp;\n    int\t\tret = OK;\n    typval_T\targvars[MAX_FUNC_ARGS + 1];\t// vars for arguments\n    int\t\targcount = 0;\t\t// number of arguments found\n    int\t\tvim9script = in_vim9script();\n\n    /*\n     * Get the arguments.\n     */\n    argp = *arg;\n    while (argcount < MAX_FUNC_ARGS - (funcexe->fe_partial == NULL ? 0\n\t\t\t\t\t       : funcexe->fe_partial->pt_argc))\n    {\n\t// skip the '(' or ',' and possibly line breaks\n\targp = skipwhite_and_linebreak(argp + 1, evalarg);\n\n\tif (*argp == ')' || *argp == ',' || *argp == NUL)\n\t    break;\n\tif (eval1(&argp, &argvars[argcount], evalarg) == FAIL)\n\t{\n\t    ret = FAIL;\n\t    break;\n\t}\n\t++argcount;\n\t// The comma should come right after the argument, but this wasn't\n\t// checked previously, thus only enforce it in Vim9 script.\n\tif (vim9script)\n\t{\n\t    if (*argp != ',' && *skipwhite(argp) == ',')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \",\", argp);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\telse\n\t    argp = skipwhite(argp);\n\tif (*argp != ',')\n\t    break;\n\tif (vim9script && !IS_WHITE_OR_NUL(argp[1]))\n\t{\n\t    semsg(_(e_white_space_required_after_str_str), \",\", argp);\n\t    ret = FAIL;\n\t    break;\n\t}\n    }\n    argp = skipwhite_and_linebreak(argp, evalarg);\n    if (*argp == ')')\n\t++argp;\n    else\n\tret = FAIL;\n\n    if (ret == OK)\n    {\n\tint\ti = 0;\n\tint\tdid_emsg_before = did_emsg;\n\n\tif (get_vim_var_nr(VV_TESTING))\n\t{\n\t    // Prepare for calling test_garbagecollect_now(), need to know\n\t    // what variables are used on the call stack.\n\t    if (funcargs.ga_itemsize == 0)\n\t\tga_init2(&funcargs, (int)sizeof(typval_T *), 50);\n\t    for (i = 0; i < argcount; ++i)\n\t\tif (ga_grow(&funcargs, 1) == OK)\n\t\t    ((typval_T **)funcargs.ga_data)[funcargs.ga_len++] =\n\t\t\t\t\t\t\t\t  &argvars[i];\n\t}\n\n\tret = call_func(name, len, rettv, argcount, argvars, funcexe);\n\tif (in_vim9script() && did_emsg > did_emsg_before)\n\t{\n\t    // An error in a builtin function does not return FAIL, but we do\n\t    // want to abort further processing if an error was given.\n\t    ret = FAIL;\n\t    clear_tv(rettv);\n\t}\n\n\tfuncargs.ga_len -= i;\n    }\n    else if (!aborting())\n    {\n\tif (argcount == MAX_FUNC_ARGS)\n\t    emsg_funcname(e_too_many_arguments_for_function_str_2, name);\n\telse\n\t    emsg_funcname(e_invalid_arguments_for_function_str, name);\n    }\n\n    while (--argcount >= 0)\n\tclear_tv(&argvars[argcount]);\n\n    if (in_vim9script())\n\t*arg = argp;\n    else\n\t*arg = skipwhite(argp);\n    return ret;\n}\n\n/*\n * Return TRUE if \"p\" starts with \"<SID>\" or \"s:\".\n * Only works if eval_fname_script() returned non-zero for \"p\"!\n */\n    static int\neval_fname_sid(char_u *p)\n{\n    return (*p == 's' || TOUPPER_ASC(p[2]) == 'I');\n}\n\n/*\n * In a script change <SID>name() and s:name() to K_SNR 123_name().\n * Change <SNR>123_name() to K_SNR 123_name().\n * Use \"fname_buf[FLEN_FIXED + 1]\" when it fits, otherwise allocate memory\n * (slow).\n */\n    char_u *\nfname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error)\n{\n    int\t\tllen;\n    char_u\t*fname;\n    int\t\ti;\n\n    llen = eval_fname_script(name);\n    if (llen > 0)\n    {\n\tfname_buf[0] = K_SPECIAL;\n\tfname_buf[1] = KS_EXTRA;\n\tfname_buf[2] = (int)KE_SNR;\n\ti = 3;\n\tif (eval_fname_sid(name))\t// \"<SID>\" or \"s:\"\n\t{\n\t    if (current_sctx.sc_sid <= 0)\n\t\t*error = FCERR_SCRIPT;\n\t    else\n\t    {\n\t\tsprintf((char *)fname_buf + 3, \"%ld_\",\n\t\t\t\t\t\t    (long)current_sctx.sc_sid);\n\t\ti = (int)STRLEN(fname_buf);\n\t    }\n\t}\n\tif (i + STRLEN(name + llen) < FLEN_FIXED)\n\t{\n\t    STRCPY(fname_buf + i, name + llen);\n\t    fname = fname_buf;\n\t}\n\telse\n\t{\n\t    fname = alloc(i + STRLEN(name + llen) + 1);\n\t    if (fname == NULL)\n\t\t*error = FCERR_OTHER;\n\t    else\n\t    {\n\t\t*tofree = fname;\n\t\tmch_memmove(fname, fname_buf, (size_t)i);\n\t\tSTRCPY(fname + i, name + llen);\n\t    }\n\t}\n    }\n    else\n\tfname = name;\n    return fname;\n}\n\n/*\n * Find a function \"name\" in script \"sid\".\n */\n    static ufunc_T *\nfind_func_with_sid(char_u *name, int sid)\n{\n    hashitem_T\t*hi;\n    char_u\tbuffer[200];\n\n    buffer[0] = K_SPECIAL;\n    buffer[1] = KS_EXTRA;\n    buffer[2] = (int)KE_SNR;\n    vim_snprintf((char *)buffer + 3, sizeof(buffer) - 3, \"%ld_%s\",\n\t\t\t\t\t\t\t      (long)sid, name);\n    hi = hash_find(&func_hashtab, buffer);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * When \"is_global\" is true don't find script-local or imported functions.\n * Return NULL for unknown function.\n */\n    ufunc_T *\nfind_func_even_dead(char_u *name, int is_global, cctx_T *cctx UNUSED)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*func;\n\n    if (!is_global)\n    {\n\tint\tfind_script_local = in_vim9script() && eval_isnamec1(*name)\n\t\t\t\t\t   && (name[1] != ':' || *name == 's');\n\n\tif (find_script_local)\n\t{\n\t    // Find script-local function before global one.\n\t    func = find_func_with_sid(name[0] == 's' && name[1] == ':'\n\t\t\t\t       ? name + 2 : name, current_sctx.sc_sid);\n\t    if (func != NULL)\n\t\treturn func;\n\t}\n    }\n\n    hi = hash_find(&func_hashtab,\n\t\t\t\tSTRNCMP(name, \"g:\", 2) == 0 ? name + 2 : name);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * \"cctx\" is passed in a :def function to find imported functions.\n * Return NULL for unknown or dead function.\n */\n    ufunc_T *\nfind_func(char_u *name, int is_global, cctx_T *cctx)\n{\n    ufunc_T\t*fp = find_func_even_dead(name, is_global, cctx);\n\n    if (fp != NULL && (fp->uf_flags & FC_DEAD) == 0)\n\treturn fp;\n    return NULL;\n}\n\n/*\n * Return TRUE if \"ufunc\" is a global function.\n */\n    int\nfunc_is_global(ufunc_T *ufunc)\n{\n    return ufunc->uf_name[0] != K_SPECIAL;\n}\n\n/*\n * Copy the function name of \"fp\" to buffer \"buf\".\n * \"buf\" must be able to hold the function name plus three bytes.\n * Takes care of script-local function names.\n */\n    static void\ncat_func_name(char_u *buf, ufunc_T *fp)\n{\n    if (!func_is_global(fp))\n    {\n\tSTRCPY(buf, \"<SNR>\");\n\tSTRCAT(buf, fp->uf_name + 3);\n    }\n    else\n\tSTRCPY(buf, fp->uf_name);\n}\n\n/*\n * Add a number variable \"name\" to dict \"dp\" with value \"nr\".\n */\n    static void\nadd_nr_var(\n    dict_T\t*dp,\n    dictitem_T\t*v,\n    char\t*name,\n    varnumber_T nr)\n{\n    STRCPY(v->di_key, name);\n    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    hash_add(&dp->dv_hashtab, DI2HIKEY(v));\n    v->di_tv.v_type = VAR_NUMBER;\n    v->di_tv.v_lock = VAR_FIXED;\n    v->di_tv.vval.v_number = nr;\n}\n\n/*\n * Free \"fc\".\n */\n    static void\nfree_funccal(funccall_T *fc)\n{\n    int\ti;\n\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n    {\n\tufunc_T *fp = ((ufunc_T **)(fc->fc_funcs.ga_data))[i];\n\n\t// When garbage collecting a funccall_T may be freed before the\n\t// function that references it, clear its uf_scoped field.\n\t// The function may have been redefined and point to another\n\t// funccall_T, don't clear it then.\n\tif (fp != NULL && fp->uf_scoped == fc)\n\t    fp->uf_scoped = NULL;\n    }\n    ga_clear(&fc->fc_funcs);\n\n    func_ptr_unref(fc->func);\n    vim_free(fc);\n}\n\n/*\n * Free \"fc\" and what it contains.\n * Can be called only when \"fc\" is kept beyond the period of it called,\n * i.e. after cleanup_function_call(fc).\n */\n   static void\nfree_funccal_contents(funccall_T *fc)\n{\n    listitem_T\t*li;\n\n    // Free all l: variables.\n    vars_clear(&fc->l_vars.dv_hashtab);\n\n    // Free all a: variables.\n    vars_clear(&fc->l_avars.dv_hashtab);\n\n    // Free the a:000 variables.\n    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\tclear_tv(&li->li_tv);\n\n    free_funccal(fc);\n}\n\n/*\n * Handle the last part of returning from a function: free the local hashtable.\n * Unless it is still in use by a closure.\n */\n    static void\ncleanup_function_call(funccall_T *fc)\n{\n    int\tmay_free_fc = fc->fc_refcount <= 0;\n    int\tfree_fc = TRUE;\n\n    current_funccal = fc->caller;\n\n    // Free all l: variables if not referred.\n    if (may_free_fc && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear(&fc->l_vars.dv_hashtab);\n    else\n\tfree_fc = FALSE;\n\n    // If the a:000 list and the l: and a: dicts are not referenced and\n    // there is no closure using it, we can free the funccall_T and what's\n    // in it.\n    if (may_free_fc && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear_ext(&fc->l_avars.dv_hashtab, FALSE);\n    else\n    {\n\tint\t    todo;\n\thashitem_T  *hi;\n\tdictitem_T  *di;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a: variables, since we didn't do that above.\n\ttodo = (int)fc->l_avars.dv_hashtab.ht_used;\n\tfor (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tdi = HI2DI(hi);\n\t\tcopy_tv(&di->di_tv, &di->di_tv);\n\t    }\n\t}\n    }\n\n    if (may_free_fc && fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT)\n\tfc->l_varlist.lv_first = NULL;\n    else\n    {\n\tlistitem_T *li;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a:000 items, since we didn't do that above.\n\tFOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\t    copy_tv(&li->li_tv, &li->li_tv);\n    }\n\n    if (free_fc)\n\tfree_funccal(fc);\n    else\n    {\n\tstatic int made_copy = 0;\n\n\t// \"fc\" is still in use.  This can happen when returning \"a:000\",\n\t// assigning \"l:\" to a global variable or defining a closure.\n\t// Link \"fc\" in the list for garbage collection later.\n\tfc->caller = previous_funccal;\n\tprevious_funccal = fc;\n\n\tif (want_garbage_collect)\n\t    // If garbage collector is ready, clear count.\n\t    made_copy = 0;\n\telse if (++made_copy >= (int)((4096 * 1024) / sizeof(*fc)))\n\t{\n\t    // We have made a lot of copies, worth 4 Mbyte.  This can happen\n\t    // when repetitively calling a function that creates a reference to\n\t    // itself somehow.  Call the garbage collector soon to avoid using\n\t    // too much memory.\n\t    made_copy = 0;\n\t    want_garbage_collect = TRUE;\n\t}\n    }\n}\n\n/*\n * Return TRUE if \"name\" is a numbered function, ignoring a \"g:\" prefix.\n */\n    static int\nnumbered_function(char_u *name)\n{\n    return isdigit(*name)\n\t    || (name[0] == 'g' && name[1] == ':' && isdigit(name[2]));\n}\n\n/*\n * There are two kinds of function names:\n * 1. ordinary names, function defined with :function or :def\n * 2. numbered functions and lambdas\n * For the first we only count the name stored in func_hashtab as a reference,\n * using function() does not count as a reference, because the function is\n * looked up by name.\n */\n    int\nfunc_name_refcount(char_u *name)\n{\n    return numbered_function(name) || *name == '<';\n}\n\n/*\n * Unreference \"fc\": decrement the reference count and free it when it\n * becomes zero.  \"fp\" is detached from \"fc\".\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunccal_unref(funccall_T *fc, ufunc_T *fp, int force)\n{\n    funccall_T\t**pfc;\n    int\t\ti;\n\n    if (fc == NULL)\n\treturn;\n\n    if (--fc->fc_refcount <= 0 && (force || (\n\t\tfc->l_varlist.lv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_vars.dv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)))\n\tfor (pfc = &previous_funccal; *pfc != NULL; pfc = &(*pfc)->caller)\n\t{\n\t    if (fc == *pfc)\n\t    {\n\t\t*pfc = fc->caller;\n\t\tfree_funccal_contents(fc);\n\t\treturn;\n\t    }\n\t}\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n\tif (((ufunc_T **)(fc->fc_funcs.ga_data))[i] == fp)\n\t    ((ufunc_T **)(fc->fc_funcs.ga_data))[i] = NULL;\n}\n\n/*\n * Remove the function from the function hashtable.  If the function was\n * deleted while it still has references this was already done.\n * Return TRUE if the entry was deleted, FALSE if it wasn't found.\n */\n    static int\nfunc_remove(ufunc_T *fp)\n{\n    hashitem_T\t*hi;\n\n    // Return if it was already virtually deleted.\n    if (fp->uf_flags & FC_DEAD)\n\treturn FALSE;\n\n    hi = hash_find(&func_hashtab, UF2HIKEY(fp));\n    if (!HASHITEM_EMPTY(hi))\n    {\n\t// When there is a def-function index do not actually remove the\n\t// function, so we can find the index when defining the function again.\n\t// Do remove it when it's a copy.\n\tif (fp->uf_def_status == UF_COMPILED && (fp->uf_flags & FC_COPY) == 0)\n\t{\n\t    fp->uf_flags |= FC_DEAD;\n\t    return FALSE;\n\t}\n\thash_remove(&func_hashtab, hi);\n\tfp->uf_flags |= FC_DELETED;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nfunc_clear_items(ufunc_T *fp)\n{\n    ga_clear_strings(&(fp->uf_args));\n    ga_clear_strings(&(fp->uf_def_args));\n    ga_clear_strings(&(fp->uf_lines));\n    VIM_CLEAR(fp->uf_arg_types);\n    VIM_CLEAR(fp->uf_block_ids);\n    VIM_CLEAR(fp->uf_va_name);\n    clear_type_list(&fp->uf_type_list);\n\n    // Increment the refcount of this function to avoid it being freed\n    // recursively when the partial is freed.\n    fp->uf_refcount += 3;\n    partial_unref(fp->uf_partial);\n    fp->uf_partial = NULL;\n    fp->uf_refcount -= 3;\n\n#ifdef FEAT_LUA\n    if (fp->uf_cb_free != NULL)\n    {\n\tfp->uf_cb_free(fp->uf_cb_state);\n\tfp->uf_cb_free = NULL;\n    }\n\n    fp->uf_cb_state = NULL;\n    fp->uf_cb = NULL;\n#endif\n#ifdef FEAT_PROFILE\n    VIM_CLEAR(fp->uf_tml_count);\n    VIM_CLEAR(fp->uf_tml_total);\n    VIM_CLEAR(fp->uf_tml_self);\n#endif\n}\n\n/*\n * Free all things that a function contains.  Does not free the function\n * itself, use func_free() for that.\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunc_clear(ufunc_T *fp, int force)\n{\n    if (fp->uf_cleared)\n\treturn;\n    fp->uf_cleared = TRUE;\n\n    // clear this function\n    func_clear_items(fp);\n    funccal_unref(fp->uf_scoped, fp, force);\n    unlink_def_function(fp);\n}\n\n/*\n * Free a function and remove it from the list of functions.  Does not free\n * what a function contains, call func_clear() first.\n * When \"force\" is TRUE we are exiting.\n * Returns OK when the function was actually freed.\n */\n    static int\nfunc_free(ufunc_T *fp, int force)\n{\n    // Only remove it when not done already, otherwise we would remove a newer\n    // version of the function with the same name.\n    if ((fp->uf_flags & (FC_DELETED | FC_REMOVED)) == 0)\n\tfunc_remove(fp);\n\n    if ((fp->uf_flags & FC_DEAD) == 0 || force)\n    {\n\tif (fp->uf_dfunc_idx > 0)\n\t    unlink_def_function(fp);\n\tVIM_CLEAR(fp->uf_name_exp);\n\tvim_free(fp);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Free all things that a function contains and free the function itself.\n * When \"force\" is TRUE we are exiting.\n */\n    void\nfunc_clear_free(ufunc_T *fp, int force)\n{\n    func_clear(fp, force);\n    if (force || fp->uf_dfunc_idx == 0 || func_name_refcount(fp->uf_name)\n\t\t\t\t\t\t   || (fp->uf_flags & FC_COPY))\n\tfunc_free(fp, force);\n    else\n\tfp->uf_flags |= FC_DEAD;\n}\n\n/*\n * Copy already defined function \"lambda\" to a new function with name \"global\".\n * This is for when a compiled function defines a global function.\n */\n    int\ncopy_func(char_u *lambda, char_u *global, ectx_T *ectx)\n{\n    ufunc_T *ufunc = find_func_even_dead(lambda, TRUE, NULL);\n    ufunc_T *fp = NULL;\n\n    if (ufunc == NULL)\n    {\n\tsemsg(_(e_lambda_function_not_found_str), lambda);\n\treturn FAIL;\n    }\n\n    fp = find_func(global, TRUE, NULL);\n    if (fp != NULL)\n    {\n\t// TODO: handle ! to overwrite\n\tsemsg(_(e_function_str_already_exists_add_bang_to_replace), global);\n\treturn FAIL;\n    }\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(global) + 1);\n    if (fp == NULL)\n\treturn FAIL;\n\n    fp->uf_varargs = ufunc->uf_varargs;\n    fp->uf_flags = (ufunc->uf_flags & ~FC_VIM9) | FC_COPY;\n    fp->uf_def_status = ufunc->uf_def_status;\n    fp->uf_dfunc_idx = ufunc->uf_dfunc_idx;\n    if (ga_copy_strings(&ufunc->uf_args, &fp->uf_args) == FAIL\n\t    || ga_copy_strings(&ufunc->uf_def_args, &fp->uf_def_args)\n\t\t\t\t\t\t\t\t    == FAIL\n\t    || ga_copy_strings(&ufunc->uf_lines, &fp->uf_lines) == FAIL)\n\tgoto failed;\n\n    fp->uf_name_exp = ufunc->uf_name_exp == NULL ? NULL\n\t\t\t\t\t : vim_strsave(ufunc->uf_name_exp);\n    if (ufunc->uf_arg_types != NULL)\n    {\n\tfp->uf_arg_types = ALLOC_MULT(type_T *, fp->uf_args.ga_len);\n\tif (fp->uf_arg_types == NULL)\n\t    goto failed;\n\tmch_memmove(fp->uf_arg_types, ufunc->uf_arg_types,\n\t\t\t\t    sizeof(type_T *) * fp->uf_args.ga_len);\n    }\n    if (ufunc->uf_va_name != NULL)\n    {\n\tfp->uf_va_name = vim_strsave(ufunc->uf_va_name);\n\tif (fp->uf_va_name == NULL)\n\t    goto failed;\n    }\n    fp->uf_ret_type = ufunc->uf_ret_type;\n\n    fp->uf_refcount = 1;\n    STRCPY(fp->uf_name, global);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    // the referenced dfunc_T is now used one more time\n    link_def_function(fp);\n\n    // Create a partial to store the context of the function where it was\n    // instantiated.  Only needs to be done once.  Do this on the original\n    // function, \"dfunc->df_ufunc\" will point to it.\n    if ((ufunc->uf_flags & FC_CLOSURE) && ufunc->uf_partial == NULL)\n    {\n\tpartial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt == NULL)\n\t    goto failed;\n\tif (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t{\n            vim_free(pt);\n\t    goto failed;\n\t}\n\tufunc->uf_partial = pt;\n\t--pt->pt_refcount;  // not actually referenced here\n    }\n\n    return OK;\n\nfailed:\n    func_clear_free(fp, TRUE);\n    return FAIL;\n}\n\nstatic int\tfuncdepth = 0;\n\n/*\n * Increment the function call depth count.\n * Return FAIL when going over 'maxfuncdepth'.\n * Otherwise return OK, must call funcdepth_decrement() later!\n */\n    int\nfuncdepth_increment(void)\n{\n    if (funcdepth >= p_mfd)\n    {\n\temsg(_(e_function_call_depth_is_higher_than_macfuncdepth));\n\treturn FAIL;\n    }\n    ++funcdepth;\n    return OK;\n}\n\n    void\nfuncdepth_decrement(void)\n{\n    --funcdepth;\n}\n\n/*\n * Get the current function call depth.\n */\n    int\nfuncdepth_get(void)\n{\n    return funcdepth;\n}\n\n/*\n * Restore the function call depth.  This is for cases where there is no\n * guarantee funcdepth_decrement() can be called exactly the same number of\n * times as funcdepth_increment().\n */\n    void\nfuncdepth_restore(int depth)\n{\n    funcdepth = depth;\n}\n\n/*\n * Call a user function.\n */\n    static void\ncall_user_func(\n    ufunc_T\t*fp,\t\t// pointer to function\n    int\t\targcount,\t// nr of args\n    typval_T\t*argvars,\t// arguments\n    typval_T\t*rettv,\t\t// return value\n    funcexe_T\t*funcexe,\t// context\n    dict_T\t*selfdict)\t// Dictionary for \"self\"\n{\n    sctx_T\tsave_current_sctx;\n    int\t\tusing_sandbox = FALSE;\n    funccall_T\t*fc;\n    int\t\tsave_did_emsg;\n    int\t\tdefault_arg_err = FALSE;\n    dictitem_T\t*v;\n    int\t\tfixvar_idx = 0;\t// index in fixvar[]\n    int\t\ti;\n    int\t\tai;\n    int\t\tislambda = FALSE;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*name;\n    typval_T\t*tv_to_free[MAX_FUNC_ARGS];\n    int\t\ttv_to_free_len = 0;\n#ifdef FEAT_PROFILE\n    profinfo_T\tprofile_info;\n#endif\n    ESTACK_CHECK_DECLARATION\n\n#ifdef FEAT_PROFILE\n    CLEAR_FIELD(profile_info);\n#endif\n\n    // If depth of calling is getting too high, don't execute the function.\n    if (funcdepth_increment() == FAIL)\n    {\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n\treturn;\n    }\n\n    line_breakcheck();\t\t// check for CTRL-C hit\n\n    fc = ALLOC_CLEAR_ONE(funccall_T);\n    if (fc == NULL)\n\treturn;\n    fc->caller = current_funccal;\n    current_funccal = fc;\n    fc->func = fp;\n    fc->rettv = rettv;\n    fc->level = ex_nesting_level;\n    // Check if this function has a breakpoint.\n    fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);\n    fc->dbg_tick = debug_tick;\n    // Set up fields for closure.\n    ga_init2(&fc->fc_funcs, sizeof(ufunc_T *), 1);\n    func_ptr_ref(fp);\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n#ifdef FEAT_PROFILE\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n#endif\n\t// Execute the function, possibly compiling it first.\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES)\n\t    profile_may_start_func(&profile_info, fp, caller);\n#endif\n\tcall_def_function(fp, argcount, argvars, funcexe->fe_partial, rettv);\n\tfuncdepth_decrement();\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES && (fp->uf_profiling\n\t\t\t\t  || (caller != NULL && caller->uf_profiling)))\n\t    profile_may_end_func(&profile_info, fp, caller);\n#endif\n\tcurrent_funccal = fc->caller;\n\tfree_funccal(fc);\n\treturn;\n    }\n\n    islambda = fp->uf_flags & FC_LAMBDA;\n\n    /*\n     * Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables\n     * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free\n     * each argument variable and saves a lot of time.\n     */\n    /*\n     * Init l: variables.\n     */\n    init_var_dict(&fc->l_vars, &fc->l_vars_var, VAR_DEF_SCOPE);\n    if (selfdict != NULL)\n    {\n\t// Set l:self to \"selfdict\".  Use \"name\" to avoid a warning from\n\t// some compiler that checks the destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"self\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_DICT;\n\tv->di_tv.v_lock = 0;\n\tv->di_tv.vval.v_dict = selfdict;\n\t++selfdict->dv_refcount;\n    }\n\n    /*\n     * Init a: variables, unless none found (in lambda).\n     * Set a:0 to \"argcount\" less number of named arguments, if >= 0.\n     * Set a:000 to a list with room for the \"...\" arguments.\n     */\n    init_var_dict(&fc->l_avars, &fc->l_avars_var, VAR_SCOPE);\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"0\",\n\t\t\t\t(varnumber_T)(argcount >= fp->uf_args.ga_len\n\t\t\t\t    ? argcount - fp->uf_args.ga_len : 0));\n    fc->l_avars.dv_lock = VAR_FIXED;\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\t// Use \"name\" to avoid a warning from some compiler that checks the\n\t// destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"000\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_LIST;\n\tv->di_tv.v_lock = VAR_FIXED;\n\tv->di_tv.vval.v_list = &fc->l_varlist;\n    }\n    CLEAR_FIELD(fc->l_varlist);\n    fc->l_varlist.lv_refcount = DO_NOT_FREE_CNT;\n    fc->l_varlist.lv_lock = VAR_FIXED;\n\n    /*\n     * Set a:firstline to \"firstline\" and a:lastline to \"lastline\".\n     * Set a:name to named arguments.\n     * Set a:N to the \"...\" arguments.\n     * Skipped when no a: variables used (in lambda).\n     */\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"firstline\",\n\t\t\t\t\t   (varnumber_T)funcexe->fe_firstline);\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"lastline\",\n\t\t\t\t\t    (varnumber_T)funcexe->fe_lastline);\n    }\n    for (i = 0; i < argcount || i < fp->uf_args.ga_len; ++i)\n    {\n\tint\t    addlocal = FALSE;\n\ttypval_T    def_rettv;\n\tint\t    isdefault = FALSE;\n\n\tai = i - fp->uf_args.ga_len;\n\tif (ai < 0)\n\t{\n\t    // named argument a:name\n\t    name = FUNCARG(fp, i);\n\t    if (islambda)\n\t\taddlocal = TRUE;\n\n\t    // evaluate named argument default expression\n\t    isdefault = ai + fp->uf_def_args.ga_len >= 0\n\t\t       && (i >= argcount || (argvars[i].v_type == VAR_SPECIAL\n\t\t\t\t   && argvars[i].vval.v_number == VVAL_NONE));\n\t    if (isdefault)\n\t    {\n\t\tchar_u\t    *default_expr = NULL;\n\n\t\tdef_rettv.v_type = VAR_NUMBER;\n\t\tdef_rettv.vval.v_number = -1;\n\n\t\tdefault_expr = ((char_u **)(fp->uf_def_args.ga_data))\n\t\t\t\t\t\t [ai + fp->uf_def_args.ga_len];\n\t\tif (eval1(&default_expr, &def_rettv, &EVALARG_EVALUATE) == FAIL)\n\t\t{\n\t\t    default_arg_err = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    if ((fp->uf_flags & FC_NOARGS) != 0)\n\t\t// Bail out if no a: arguments used (in lambda).\n\t\tbreak;\n\n\t    // \"...\" argument a:1, a:2, etc.\n\t    sprintf((char *)numbuf, \"%d\", ai + 1);\n\t    name = numbuf;\n\t}\n\tif (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)\n\t{\n\t    v = &fc->fixvar[fixvar_idx++].var;\n\t    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\t    STRCPY(v->di_key, name);\n\t}\n\telse\n\t{\n\t    v = dictitem_alloc(name);\n\t    if (v == NULL)\n\t\tbreak;\n\t    v->di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;\n\t}\n\n\t// Note: the values are copied directly to avoid alloc/free.\n\t// \"argvars\" must have VAR_FIXED for v_lock.\n\tv->di_tv = isdefault ? def_rettv : argvars[i];\n\tv->di_tv.v_lock = VAR_FIXED;\n\n\tif (isdefault)\n\t    // Need to free this later, no matter where it's stored.\n\t    tv_to_free[tv_to_free_len++] = &v->di_tv;\n\n\tif (addlocal)\n\t{\n\t    // Named arguments should be accessed without the \"a:\" prefix in\n\t    // lambda expressions.  Add to the l: dict.\n\t    copy_tv(&v->di_tv, &v->di_tv);\n\t    hash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\t}\n\telse\n\t    hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\n\tif (ai >= 0 && ai < MAX_FUNC_ARGS)\n\t{\n\t    listitem_T *li = &fc->l_listitems[ai];\n\n\t    li->li_tv = argvars[i];\n\t    li->li_tv.v_lock = VAR_FIXED;\n\t    list_append(&fc->l_varlist, li);\n\t}\n    }\n\n    // Don't redraw while executing the function.\n    ++RedrawingDisabled;\n\n    if (fp->uf_flags & FC_SANDBOX)\n    {\n\tusing_sandbox = TRUE;\n\t++sandbox;\n    }\n\n    estack_push_ufunc(fp, 1);\n    ESTACK_CHECK_SETUP\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"calling %s\"), SOURCING_NAME);\n\tif (p_verbose >= 14)\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    msg_puts(\"(\");\n\t    for (i = 0; i < argcount; ++i)\n\t    {\n\t\tif (i > 0)\n\t\t    msg_puts(\", \");\n\t\tif (argvars[i].v_type == VAR_NUMBER)\n\t\t    msg_outnum((long)argvars[i].vval.v_number);\n\t\telse\n\t\t{\n\t\t    // Do not want errors such as E724 here.\n\t\t    ++emsg_off;\n\t\t    s = tv2string(&argvars[i], &tofree, numbuf2, 0);\n\t\t    --emsg_off;\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t\t{\n\t\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t\t    s = buf;\n\t\t\t}\n\t\t\tmsg_puts((char *)s);\n\t\t\tvim_free(tofree);\n\t\t    }\n\t\t}\n\t    }\n\t    msg_puts(\")\");\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprofile_may_start_func(&profile_info, fp,\n\t\t\t\t fc->caller == NULL ? NULL : fc->caller->func);\n#endif\n\n    save_current_sctx = current_sctx;\n    current_sctx = fp->uf_script_ctx;\n    save_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    if (default_arg_err && (fp->uf_flags & FC_ABORT))\n\tdid_emsg = TRUE;\n    else if (islambda)\n    {\n\tchar_u *p = *(char_u **)fp->uf_lines.ga_data + 7;\n\n\t// A Lambda always has the command \"return {expr}\".  It is much faster\n\t// to evaluate {expr} directly.\n\t++ex_nesting_level;\n\t(void)eval1(&p, rettv, &EVALARG_EVALUATE);\n\t--ex_nesting_level;\n    }\n    else\n\t// call do_cmdline() to execute the lines\n\tdo_cmdline(NULL, get_func_line, (void *)fc,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n    --RedrawingDisabled;\n\n    // when the function was aborted because of an error, return -1\n    if ((did_emsg && (fp->uf_flags & FC_ABORT)) || rettv->v_type == VAR_UNKNOWN)\n    {\n\tclear_tv(rettv);\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n    }\n\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n\n\tif (fp->uf_profiling || (caller != NULL && caller->uf_profiling))\n\t    profile_may_end_func(&profile_info, fp, caller);\n    }\n#endif\n\n    // when being verbose, mention the return value\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tif (aborting())\n\t    smsg(_(\"%s aborted\"), SOURCING_NAME);\n\telse if (fc->rettv->v_type == VAR_NUMBER)\n\t    smsg(_(\"%s returning #%ld\"), SOURCING_NAME,\n\t\t\t\t\t       (long)fc->rettv->vval.v_number);\n\telse\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    // The value may be very long.  Skip the middle part, so that we\n\t    // have some idea how it starts and ends. smsg() would always\n\t    // truncate it at the end. Don't want errors such as E724 here.\n\t    ++emsg_off;\n\t    s = tv2string(fc->rettv, &tofree, numbuf2, 0);\n\t    --emsg_off;\n\t    if (s != NULL)\n\t    {\n\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t{\n\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t    s = buf;\n\t\t}\n\t\tsmsg(_(\"%s returning %s\"), SOURCING_NAME, s);\n\t\tvim_free(tofree);\n\t    }\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    ESTACK_CHECK_NOW\n    estack_pop();\n    current_sctx = save_current_sctx;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tscript_prof_restore(&profile_info.pi_wait_start);\n#endif\n    if (using_sandbox)\n\t--sandbox;\n\n    if (p_verbose >= 12 && SOURCING_NAME != NULL)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"continuing in %s\"), SOURCING_NAME);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    did_emsg |= save_did_emsg;\n    funcdepth_decrement();\n    for (i = 0; i < tv_to_free_len; ++i)\n\tclear_tv(tv_to_free[i]);\n    cleanup_function_call(fc);\n}\n\n/*\n * Check the argument count for user function \"fp\".\n * Return FCERR_UNKNOWN if OK, FCERR_TOOFEW or FCERR_TOOMANY otherwise.\n */\n    int\ncheck_user_func_argcount(ufunc_T *fp, int argcount)\n{\n    int regular_args = fp->uf_args.ga_len;\n\n    if (argcount < regular_args - fp->uf_def_args.ga_len)\n\treturn FCERR_TOOFEW;\n    else if (!has_varargs(fp) && argcount > regular_args)\n\treturn FCERR_TOOMANY;\n    return FCERR_UNKNOWN;\n}\n\n/*\n * Call a user function after checking the arguments.\n */\n    int\ncall_user_func_check(\n\tufunc_T\t    *fp,\n\tint\t    argcount,\n\ttypval_T    *argvars,\n\ttypval_T    *rettv,\n\tfuncexe_T   *funcexe,\n\tdict_T\t    *selfdict)\n{\n    int error;\n\n    if (fp->uf_flags & FC_RANGE && funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = TRUE;\n    error = check_user_func_argcount(fp, argcount);\n    if (error != FCERR_UNKNOWN)\n\treturn error;\n    if ((fp->uf_flags & FC_DICT) && selfdict == NULL)\n\terror = FCERR_DICT;\n    else\n    {\n\tint\t\tdid_save_redo = FALSE;\n\tsave_redo_T\tsave_redo;\n\n\t/*\n\t * Call the user function.\n\t * Save and restore search patterns, script variables and\n\t * redo buffer.\n\t */\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redo = TRUE;\n\t}\n\t++fp->uf_calls;\n\tcall_user_func(fp, argcount, argvars, rettv, funcexe,\n\t\t\t\t   (fp->uf_flags & FC_DICT) ? selfdict : NULL);\n\tif (--fp->uf_calls <= 0 && fp->uf_refcount <= 0)\n\t    // Function was unreferenced while being used, free it now.\n\t    func_clear_free(fp, FALSE);\n\tif (did_save_redo)\n\t    restoreRedobuff(&save_redo);\n\trestore_search_patterns();\n\terror = FCERR_NONE;\n    }\n    return error;\n}\n\nstatic funccal_entry_T *funccal_stack = NULL;\n\n/*\n * Save the current function call pointer, and set it to NULL.\n * Used when executing autocommands and for \":source\".\n */\n    void\nsave_funccal(funccal_entry_T *entry)\n{\n    entry->top_funccal = current_funccal;\n    entry->next = funccal_stack;\n    funccal_stack = entry;\n    current_funccal = NULL;\n}\n\n    void\nrestore_funccal(void)\n{\n    if (funccal_stack == NULL)\n\tiemsg(\"INTERNAL: restore_funccal()\");\n    else\n    {\n\tcurrent_funccal = funccal_stack->top_funccal;\n\tfunccal_stack = funccal_stack->next;\n    }\n}\n\n    funccall_T *\nget_current_funccal(void)\n{\n    return current_funccal;\n}\n\n/*\n * Mark all functions of script \"sid\" as deleted.\n */\n    void\ndelete_script_functions(int sid)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\ttodo = 1;\n    char_u\tbuf[30];\n    size_t\tlen;\n\n    buf[0] = K_SPECIAL;\n    buf[1] = KS_EXTRA;\n    buf[2] = (int)KE_SNR;\n    sprintf((char *)buf + 3, \"%d_\", sid);\n    len = STRLEN(buf);\n\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tfp = HI2UF(hi);\n\t\tif (STRNCMP(fp->uf_name, buf, len) == 0)\n\t\t{\n\t\t    int changed = func_hashtab.ht_changed;\n\n\t\t    fp->uf_flags |= FC_DEAD;\n\n\t\t    if (fp->uf_calls > 0)\n\t\t    {\n\t\t\t// Function is executing, don't free it but do remove\n\t\t\t// it from the hashtable.\n\t\t\tif (func_remove(fp))\n\t\t\t    fp->uf_refcount--;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfunc_clear(fp, TRUE);\n\t\t\t// When clearing a function another function can be\n\t\t\t// cleared as a side effect.  When that happens start\n\t\t\t// over.\n\t\t\tif (changed != func_hashtab.ht_changed)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_functions(void)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\tskipped = 0;\n    long_u\ttodo = 1;\n    int\t\tchanged;\n\n    // Clean up the current_funccal chain and the funccal stack.\n    while (current_funccal != NULL)\n    {\n\tclear_tv(current_funccal->rettv);\n\tcleanup_function_call(current_funccal);\n\tif (current_funccal == NULL && funccal_stack != NULL)\n\t    restore_funccal();\n    }\n\n    // First clear what the functions contain.  Since this may lower the\n    // reference count of a function, it may also free a function and change\n    // the hash table. Restart if that happens.\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t// clear the def function index now\n\t\tfp = HI2UF(hi);\n\t\tfp->uf_flags &= ~FC_DEAD;\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    func_clear(fp, TRUE);\n\t\t    if (changed != func_hashtab.ht_changed)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n\n    // Now actually free the functions.  Need to start all over every time,\n    // because func_free() may change the hash table.\n    skipped = 0;\n    while (func_hashtab.ht_used > skipped)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tfp = HI2UF(hi);\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    if (func_free(fp, FALSE) == OK)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    // did not actually free it\n\t\t    ++skipped;\n\t\t}\n\t    }\n    }\n    if (skipped == 0)\n\thash_clear(&func_hashtab);\n\n    free_def_functions();\n}\n#endif\n\n/*\n * Return TRUE if \"name\" looks like a builtin function name: starts with a\n * lower case letter and doesn't contain AUTOLOAD_CHAR or ':'.\n * \"len\" is the length of \"name\", or -1 for NUL terminated.\n */\n    int\nbuiltin_function(char_u *name, int len)\n{\n    char_u *p;\n\n    if (!ASCII_ISLOWER(name[0]) || name[1] == ':')\n\treturn FALSE;\n    p = vim_strchr(name, AUTOLOAD_CHAR);\n    return p == NULL || (len > 0 && p > name + len);\n}\n\n    int\nfunc_call(\n    char_u\t*name,\n    typval_T\t*args,\n    partial_T\t*partial,\n    dict_T\t*selfdict,\n    typval_T\t*rettv)\n{\n    list_T\t*l = args->vval.v_list;\n    listitem_T\t*item;\n    typval_T\targv[MAX_FUNC_ARGS + 1];\n    int\t\targc = 0;\n    int\t\tr = 0;\n\n    CHECK_LIST_MATERIALIZE(l);\n    FOR_ALL_LIST_ITEMS(l, item)\n    {\n\tif (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial->pt_argc))\n\t{\n\t    emsg(_(e_too_many_arguments));\n\t    break;\n\t}\n\t// Make a copy of each argument.  This is needed to be able to set\n\t// v_lock to VAR_FIXED in the copy without changing the original list.\n\tcopy_tv(&item->li_tv, &argv[argc++]);\n    }\n\n    if (item == NULL)\n    {\n\tfuncexe_T funcexe;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = TRUE;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = selfdict;\n\tr = call_func(name, -1, rettv, argc, argv, &funcexe);\n    }\n\n    // Free the arguments.\n    while (argc > 0)\n\tclear_tv(&argv[--argc]);\n\n    return r;\n}\n\nstatic int callback_depth = 0;\n\n    int\nget_callback_depth(void)\n{\n    return callback_depth;\n}\n\n/*\n * Invoke call_func() with a callback.\n * Returns FAIL if the callback could not be called.\n */\n    int\ncall_callback(\n    callback_T\t*callback,\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    funcexe_T\tfuncexe;\n    int\t\tret;\n\n    if (callback->cb_name == NULL || *callback->cb_name == NUL)\n\treturn FAIL;\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_evaluate = TRUE;\n    funcexe.fe_partial = callback->cb_partial;\n    ++callback_depth;\n    ret = call_func(callback->cb_name, len, rettv, argcount, argvars, &funcexe);\n    --callback_depth;\n\n    // When a :def function was called that uses :try an error would be turned\n    // into an exception.  Need to give the error here.\n    if (need_rethrow && current_exception != NULL && trylevel == 0)\n    {\n\tneed_rethrow = FALSE;\n\thandle_did_throw();\n    }\n\n    return ret;\n}\n\n/*\n * call the 'callback' function and return the result as a number.\n * Returns -2 when calling the function fails.  Uses argv[0] to argv[argc - 1]\n * for the function arguments. argv[argc] should have type VAR_UNKNOWN.\n */\n    varnumber_T\ncall_callback_retnr(\n    callback_T\t*callback,\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n\n    if (call_callback(callback, 0, &rettv, argcount, argvars) == FAIL)\n\treturn -2;\n\n    retval = tv_get_number_chk(&rettv, NULL);\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Give an error message for the result of a function.\n * Nothing if \"error\" is FCERR_NONE.\n */\n    void\nuser_func_error(int error, char_u *name, funcexe_T *funcexe)\n{\n    switch (error)\n    {\n\tcase FCERR_UNKNOWN:\n\t\tif (funcexe->fe_found_var)\n\t\t    semsg(_(e_not_callable_type_str), name);\n\t\telse\n\t\t    emsg_funcname(e_unknown_function_str, name);\n\t\tbreak;\n\tcase FCERR_NOTMETHOD:\n\t\temsg_funcname(\n\t\t\tN_(e_cannot_use_function_as_method_str), name);\n\t\tbreak;\n\tcase FCERR_DELETED:\n\t\temsg_funcname(e_function_was_deleted_str, name);\n\t\tbreak;\n\tcase FCERR_TOOMANY:\n\t\temsg_funcname(e_too_many_arguments_for_function_str, name);\n\t\tbreak;\n\tcase FCERR_TOOFEW:\n\t\temsg_funcname(e_not_enough_arguments_for_function_str, name);\n\t\tbreak;\n\tcase FCERR_SCRIPT:\n\t\temsg_funcname(\n\t\t    e_using_sid_not_in_script_context_str, name);\n\t\tbreak;\n\tcase FCERR_DICT:\n\t\temsg_funcname(e_calling_dict_function_without_dictionary_str,\n\t\t\t\t\t\t\t\t\t name);\n\t\tbreak;\n    }\n}\n\n/*\n * Call a function with its resolved parameters\n *\n * Return FAIL when the function can't be called,  OK otherwise.\n * Also returns OK when an error was encountered while executing the function.\n */\n    int\ncall_func(\n    char_u\t*funcname,\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount_in,\t// number of \"argvars\"\n    typval_T\t*argvars_in,\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n    funcexe_T\t*funcexe)\t// more arguments\n{\n    int\t\tret = FAIL;\n    int\t\terror = FCERR_NONE;\n    int\t\ti;\n    ufunc_T\t*fp = NULL;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname = NULL;\n    char_u\t*name = NULL;\n    int\t\targcount = argcount_in;\n    typval_T\t*argvars = argvars_in;\n    dict_T\t*selfdict = funcexe->fe_selfdict;\n    typval_T\targv[MAX_FUNC_ARGS + 1]; // used when \"partial\" or\n\t\t\t\t\t // \"funcexe->fe_basetv\" is not NULL\n    int\t\targv_clear = 0;\n    int\t\targv_base = 0;\n    partial_T\t*partial = funcexe->fe_partial;\n    type_T\tcheck_type;\n    type_T\t*check_type_args[MAX_FUNC_ARGS];\n\n    // Initialize rettv so that it is safe for caller to invoke clear_tv(rettv)\n    // even when call_func() returns FAIL.\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (partial != NULL)\n\tfp = partial->pt_func;\n    if (fp == NULL)\n    {\n\t// Make a copy of the name, if it comes from a funcref variable it\n\t// could be changed or deleted in the called function.\n\tname = len > 0 ? vim_strnsave(funcname, len) : vim_strsave(funcname);\n\tif (name == NULL)\n\t    return ret;\n\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n    }\n\n    if (funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = FALSE;\n\n    if (partial != NULL)\n    {\n\t// When the function has a partial with a dict and there is a dict\n\t// argument, use the dict argument.  That is backwards compatible.\n\t// When the dict was bound explicitly use the one from the partial.\n\tif (partial->pt_dict != NULL && (selfdict == NULL || !partial->pt_auto))\n\t    selfdict = partial->pt_dict;\n\tif (error == FCERR_NONE && partial->pt_argc > 0)\n\t{\n\t    for (argv_clear = 0; argv_clear < partial->pt_argc; ++argv_clear)\n\t    {\n\t\tif (argv_clear + argcount_in >= MAX_FUNC_ARGS)\n\t\t{\n\t\t    error = FCERR_TOOMANY;\n\t\t    goto theend;\n\t\t}\n\t\tcopy_tv(&partial->pt_argv[argv_clear], &argv[argv_clear]);\n\t    }\n\t    for (i = 0; i < argcount_in; ++i)\n\t\targv[i + argv_clear] = argvars_in[i];\n\t    argvars = argv;\n\t    argcount = partial->pt_argc + argcount_in;\n\n\t    if (funcexe->fe_check_type != NULL\n\t\t\t\t  && funcexe->fe_check_type->tt_argcount != -1)\n\t    {\n\t\t// Now funcexe->fe_check_type is missing the added arguments,\n\t\t// make a copy of the type with the correction.\n\t\tcheck_type = *funcexe->fe_check_type;\n\t\tfuncexe->fe_check_type = &check_type;\n\t\tcheck_type.tt_args = check_type_args;\n\t\tCLEAR_FIELD(check_type_args);\n\t\tfor (i = 0; i < check_type.tt_argcount; ++i)\n\t\t    check_type_args[i + partial->pt_argc] =\n\t\t\t\t\t\t\t check_type.tt_args[i];\n\t\tcheck_type.tt_argcount += partial->pt_argc;\n\t\tcheck_type.tt_min_argcount += partial->pt_argc;\n\t    }\n\t}\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_check_type != NULL\n\t\t\t\t\t\t       && funcexe->fe_evaluate)\n    {\n\t// Check that the argument types are OK for the types of the funcref.\n\tif (check_argument_types(funcexe->fe_check_type, argvars, argcount,\n\t\t\t\t     (name != NULL) ? name : funcname) == FAIL)\n\t    error = FCERR_OTHER;\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_evaluate)\n    {\n\tchar_u *rfname = fname;\n\tint\tis_global = FALSE;\n\n\t// Skip \"g:\" before a function name.\n\tif (fp == NULL && fname[0] == 'g' && fname[1] == ':')\n\t{\n\t    is_global = TRUE;\n\t    rfname = fname + 2;\n\t}\n\n\trettv->v_type = VAR_NUMBER;\t// default rettv is number zero\n\trettv->vval.v_number = 0;\n\terror = FCERR_UNKNOWN;\n\n\tif (fp != NULL || !builtin_function(rfname, -1))\n\t{\n\t    /*\n\t     * User defined function.\n\t     */\n\t    if (fp == NULL)\n\t\tfp = find_func(rfname, is_global, NULL);\n\n\t    // Trigger FuncUndefined event, may load the function.\n\t    if (fp == NULL\n\t\t    && apply_autocmds(EVENT_FUNCUNDEFINED,\n\t\t\t\t\t\t    rfname, rfname, TRUE, NULL)\n\t\t    && !aborting())\n\t    {\n\t\t// executed an autocommand, search for the function again\n\t\tfp = find_func(rfname, is_global, NULL);\n\t    }\n\t    // Try loading a package.\n\t    if (fp == NULL && script_autoload(rfname, TRUE) && !aborting())\n\t    {\n\t\t// loaded a package, search for the function again\n\t\tfp = find_func(rfname, is_global, NULL);\n\t    }\n\t    if (fp == NULL)\n\t    {\n\t\tchar_u *p = untrans_function_name(rfname);\n\n\t\t// If using Vim9 script try not local to the script.\n\t\t// Don't do this if the name starts with \"s:\".\n\t\tif (p != NULL && (funcname[0] != 's' || funcname[1] != ':'))\n\t\t    fp = find_func(p, is_global, NULL);\n\t    }\n\n\t    if (fp != NULL && (fp->uf_flags & FC_DELETED))\n\t\terror = FCERR_DELETED;\n#ifdef FEAT_LUA\n\t    else if (fp != NULL && (fp->uf_flags & FC_CFUNC))\n\t    {\n\t\tcfunc_T cb = fp->uf_cb;\n\n\t\terror = (*cb)(argcount, argvars, rettv, fp->uf_cb_state);\n\t    }\n#endif\n\t    else if (fp != NULL)\n\t    {\n\t\tif (funcexe->fe_argv_func != NULL)\n\t\t    // postponed filling in the arguments, do it now\n\t\t    argcount = funcexe->fe_argv_func(argcount, argvars,\n\t\t\t\t\t       argv_clear, fp->uf_args.ga_len);\n\n\t\tif (funcexe->fe_basetv != NULL)\n\t\t{\n\t\t    // Method call: base->Method()\n\t\t    mch_memmove(&argv[1], argvars, sizeof(typval_T) * argcount);\n\t\t    argv[0] = *funcexe->fe_basetv;\n\t\t    argcount++;\n\t\t    argvars = argv;\n\t\t    argv_base = 1;\n\t\t}\n\n\t\terror = call_user_func_check(fp, argcount, argvars, rettv,\n\t\t\t\t\t\t\t    funcexe, selfdict);\n\t    }\n\t}\n\telse if (funcexe->fe_basetv != NULL)\n\t{\n\t    /*\n\t     * expr->method(): Find the method name in the table, call its\n\t     * implementation with the base as one of the arguments.\n\t     */\n\t    error = call_internal_method(fname, argcount, argvars, rettv,\n\t\t\t\t\t\t\t   funcexe->fe_basetv);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Find the function name in the table, call its implementation.\n\t     */\n\t    error = call_internal_func(fname, argcount, argvars, rettv);\n\t}\n\n\t/*\n\t * The function call (or \"FuncUndefined\" autocommand sequence) might\n\t * have been aborted by an error, an interrupt, or an explicitly thrown\n\t * exception that has not been caught so far.  This situation can be\n\t * tested for by calling aborting().  For an error in an internal\n\t * function or for the \"E132\" error in call_user_func(), however, the\n\t * throw point at which the \"force_abort\" flag (temporarily reset by\n\t * emsg()) is normally updated has not been reached yet. We need to\n\t * update that flag first to make aborting() reliable.\n\t */\n\tupdate_force_abort();\n    }\n    if (error == FCERR_NONE)\n\tret = OK;\n\ntheend:\n    /*\n     * Report an error unless the argument evaluation or function call has been\n     * cancelled due to an aborting error, an interrupt, or an exception.\n     */\n    if (!aborting())\n    {\n\tuser_func_error(error, (name != NULL) ? name : funcname, funcexe);\n    }\n\n    // clear the copies made from the partial\n    while (argv_clear > 0)\n\tclear_tv(&argv[--argv_clear + argv_base]);\n\n    vim_free(tofree);\n    vim_free(name);\n\n    return ret;\n}\n\n    char_u *\nprintable_func_name(ufunc_T *fp)\n{\n    return fp->uf_name_exp != NULL ? fp->uf_name_exp : fp->uf_name;\n}\n\n/*\n * List the head of the function: \"function name(arg1, arg2)\".\n */\n    static void\nlist_func_head(ufunc_T *fp, int indent)\n{\n    int\t\tj;\n\n    msg_start();\n    if (indent)\n\tmsg_puts(\"   \");\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n\tmsg_puts(\"def \");\n    else\n\tmsg_puts(\"function \");\n    msg_puts((char *)printable_func_name(fp));\n    msg_putchar('(');\n    for (j = 0; j < fp->uf_args.ga_len; ++j)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts((char *)FUNCARG(fp, j));\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_arg_types[j], &tofree));\n\t    vim_free(tofree);\n\t}\n\tif (j >= fp->uf_args.ga_len - fp->uf_def_args.ga_len)\n\t{\n\t    msg_puts(\" = \");\n\t    msg_puts(((char **)(fp->uf_def_args.ga_data))\n\t\t       [j - fp->uf_args.ga_len + fp->uf_def_args.ga_len]);\n\t}\n    }\n    if (fp->uf_varargs)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n    }\n    if (fp->uf_va_name != NULL)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n\tmsg_puts((char *)fp->uf_va_name);\n\tif (fp->uf_va_type != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_va_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    msg_putchar(')');\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n\tif (fp->uf_ret_type != &t_void)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_ret_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    else if (fp->uf_flags & FC_ABORT)\n\tmsg_puts(\" abort\");\n    if (fp->uf_flags & FC_RANGE)\n\tmsg_puts(\" range\");\n    if (fp->uf_flags & FC_DICT)\n\tmsg_puts(\" dict\");\n    if (fp->uf_flags & FC_CLOSURE)\n\tmsg_puts(\" closure\");\n    msg_clr_eos();\n    if (p_verbose > 0)\n\tlast_set_msg(fp->uf_script_ctx);\n}\n\n/*\n * Get a function name, translating \"<SID>\" and \"<SNR>\".\n * Also handles a Funcref in a List or Dictionary.\n * Returns the function name in allocated memory, or NULL for failure.\n * Set \"*is_global\" to TRUE when the function must be global, unless\n * \"is_global\" is NULL.\n * flags:\n * TFN_INT:\t    internal function name OK\n * TFN_QUIET:\t    be quiet\n * TFN_NO_AUTOLOAD: do not use script autoloading\n * TFN_NO_DEREF:    do not dereference a Funcref\n * Advances \"pp\" to just after the function name (if no error).\n */\n    char_u *\ntrans_function_name(\n    char_u\t**pp,\n    int\t\t*is_global,\n    int\t\tskip,\t\t// only find the end, don't evaluate\n    int\t\tflags,\n    funcdict_T\t*fdp,\t\t// return: info about dictionary used\n    partial_T\t**partial,\t// return: partial of a FuncRef\n    type_T\t**type)\t\t// return: type of funcref if not NULL\n{\n    char_u\t*name = NULL;\n    char_u\t*start;\n    char_u\t*end;\n    int\t\tlead;\n    char_u\tsid_buf[20];\n    int\t\tlen;\n    int\t\textra = 0;\n    lval_T\tlv;\n    int\t\tvim9script;\n\n    if (fdp != NULL)\n\tCLEAR_POINTER(fdp);\n    start = *pp;\n\n    // Check for hard coded <SNR>: already translated function ID (from a user\n    // command).\n    if ((*pp)[0] == K_SPECIAL && (*pp)[1] == KS_EXTRA\n\t\t\t\t\t\t   && (*pp)[2] == (int)KE_SNR)\n    {\n\t*pp += 3;\n\tlen = get_id_len(pp) + 3;\n\treturn vim_strnsave(start, len);\n    }\n\n    // A name starting with \"<SID>\" or \"<SNR>\" is local to a script.  But\n    // don't skip over \"s:\", get_lval() needs it for \"s:dict.func\".\n    lead = eval_fname_script(start);\n    if (lead > 2)\n\tstart += lead;\n\n    // Note that TFN_ flags use the same values as GLV_ flags.\n    end = get_lval(start, NULL, &lv, FALSE, skip, flags | GLV_READ_ONLY,\n\t\t\t\t\t      lead > 2 ? 0 : FNE_CHECK_START);\n    if (end == start)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name_required));\n\tgoto theend;\n    }\n    if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range)))\n    {\n\t/*\n\t * Report an invalid expression in braces, unless the expression\n\t * evaluation has been cancelled due to an aborting error, an\n\t * interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t{\n\t    if (end != NULL)\n\t\tsemsg(_(e_invalid_argument_str), start);\n\t}\n\telse\n\t    *pp = find_name_end(start, NULL, NULL, FNE_INCL_BR);\n\tgoto theend;\n    }\n\n    if (lv.ll_tv != NULL)\n    {\n\tif (fdp != NULL)\n\t{\n\t    fdp->fd_dict = lv.ll_dict;\n\t    fdp->fd_newkey = lv.ll_newkey;\n\t    lv.ll_newkey = NULL;\n\t    fdp->fd_di = lv.ll_di;\n\t}\n\tif (lv.ll_tv->v_type == VAR_FUNC && lv.ll_tv->vval.v_string != NULL)\n\t{\n\t    name = vim_strsave(lv.ll_tv->vval.v_string);\n\t    *pp = end;\n\t}\n\telse if (lv.ll_tv->v_type == VAR_PARTIAL\n\t\t\t\t\t  && lv.ll_tv->vval.v_partial != NULL)\n\t{\n\t    name = vim_strsave(partial_name(lv.ll_tv->vval.v_partial));\n\t    *pp = end;\n\t    if (partial != NULL)\n\t\t*partial = lv.ll_tv->vval.v_partial;\n\t}\n\telse\n\t{\n\t    if (!skip && !(flags & TFN_QUIET) && (fdp == NULL\n\t\t\t     || lv.ll_dict == NULL || fdp->fd_newkey == NULL))\n\t\temsg(_(e_funcref_required));\n\t    else\n\t\t*pp = end;\n\t    name = NULL;\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_name == NULL)\n    {\n\t// Error found, but continue after the function name.\n\t*pp = end;\n\tgoto theend;\n    }\n\n    // Check if the name is a Funcref.  If so, use the value.\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tname = deref_func_name(lv.ll_exp_name, &len, partial, type,\n\t\t\t\t\t\tflags & TFN_NO_AUTOLOAD, NULL);\n\tif (name == lv.ll_exp_name)\n\t    name = NULL;\n    }\n    else if (!(flags & TFN_NO_DEREF))\n    {\n\tlen = (int)(end - *pp);\n\tname = deref_func_name(*pp, &len, partial, type,\n\t\t\t\t\t\tflags & TFN_NO_AUTOLOAD, NULL);\n\tif (name == *pp)\n\t    name = NULL;\n    }\n    if (name != NULL)\n    {\n\tname = vim_strsave(name);\n\t*pp = end;\n\tif (STRNCMP(name, \"<SNR>\", 5) == 0)\n\t{\n\t    // Change \"<SNR>\" to the byte sequence.\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    mch_memmove(name + 3, name + 5, STRLEN(name + 5) + 1);\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tif (lead <= 2 && lv.ll_name == lv.ll_exp_name\n\t\t\t\t\t && STRNCMP(lv.ll_name, \"s:\", 2) == 0)\n\t{\n\t    // When there was \"s:\" already or the name expanded to get a\n\t    // leading \"s:\" then remove it.\n\t    lv.ll_name += 2;\n\t    len -= 2;\n\t    lead = 2;\n\t}\n    }\n    else\n    {\n\t// skip over \"s:\" and \"g:\"\n\tif (lead == 2 || (lv.ll_name[0] == 'g' && lv.ll_name[1] == ':'))\n\t{\n\t    if (is_global != NULL && lv.ll_name[0] == 'g')\n\t\t*is_global = TRUE;\n\t    lv.ll_name += 2;\n\t}\n\tlen = (int)(end - lv.ll_name);\n    }\n    if (len <= 0)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name_required));\n\tgoto theend;\n    }\n\n    // In Vim9 script a user function is script-local by default, unless it\n    // starts with a lower case character: dict.func().\n    vim9script = ASCII_ISUPPER(*start) && in_vim9script();\n    if (vim9script)\n    {\n\tchar_u *p;\n\n\t// SomeScript#func() is a global function.\n\tfor (p = start; *p != NUL && *p != '('; ++p)\n\t    if (*p == AUTOLOAD_CHAR)\n\t\tvim9script = FALSE;\n    }\n\n    /*\n     * Copy the function name to allocated memory.\n     * Accept <SID>name() inside a script, translate into <SNR>123_name().\n     * Accept <SNR>123_name() outside a script.\n     */\n    if (skip)\n\tlead = 0;\t// do nothing\n    else if (lead > 0 || vim9script)\n    {\n\tif (!vim9script)\n\t    lead = 3;\n\tif (vim9script || (lv.ll_exp_name != NULL\n\t\t\t\t\t     && eval_fname_sid(lv.ll_exp_name))\n\t\t\t\t\t\t       || eval_fname_sid(*pp))\n\t{\n\t    // It's script-local, \"s:\" or \"<SID>\"\n\t    if (current_sctx.sc_sid <= 0)\n\t    {\n\t\temsg(_(e_using_sid_not_in_script_context));\n\t\tgoto theend;\n\t    }\n\t    sprintf((char *)sid_buf, \"%ld_\", (long)current_sctx.sc_sid);\n\t    if (vim9script)\n\t\textra = 3 + (int)STRLEN(sid_buf);\n\t    else\n\t\tlead += (int)STRLEN(sid_buf);\n\t}\n    }\n    else if (!(flags & TFN_INT) && (builtin_function(lv.ll_name, len)\n\t\t\t\t   || (in_vim9script() && *lv.ll_name == '_')))\n    {\n\tsemsg(_(e_function_name_must_start_with_capital_or_s_str), start);\n\tgoto theend;\n    }\n    if (!skip && !(flags & TFN_QUIET) && !(flags & TFN_NO_DEREF))\n    {\n\tchar_u *cp = vim_strchr(lv.ll_name, ':');\n\n\tif (cp != NULL && cp < end)\n\t{\n\t    semsg(_(e_function_name_cannot_contain_colon_str), start);\n\t    goto theend;\n\t}\n    }\n\n    name = alloc(len + lead + extra + 1);\n    if (name != NULL)\n    {\n\tif (!skip && (lead > 0 || vim9script))\n\t{\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    if (vim9script || lead > 3)\t// If it's \"<SID>\"\n\t\tSTRCPY(name + 3, sid_buf);\n\t}\n\tmch_memmove(name + lead + extra, lv.ll_name, (size_t)len);\n\tname[lead + extra + len] = NUL;\n    }\n    *pp = end;\n\ntheend:\n    clear_lval(&lv);\n    return name;\n}\n\n/*\n * Assuming \"name\" is the result of trans_function_name() and it was prefixed\n * to use the script-local name, return the unmodified name (points into\n * \"name\").  Otherwise return NULL.\n * This can be used to first search for a script-local function and fall back\n * to the global function if not found.\n */\n    char_u *\nuntrans_function_name(char_u *name)\n{\n    char_u *p;\n\n    if (*name == K_SPECIAL && in_vim9script())\n    {\n\tp = vim_strchr(name, '_');\n\tif (p != NULL)\n\t    return p + 1;\n    }\n    return NULL;\n}\n\n/*\n * If the 'funcname' starts with \"s:\" or \"<SID>\", then expands it to the\n * current script ID and returns the expanded function name. The caller should\n * free the returned name. If not called from a script context or the function\n * name doesn't start with these prefixes, then returns NULL.\n * This doesn't check whether the script-local function exists or not.\n */\n    char_u *\nget_scriptlocal_funcname(char_u *funcname)\n{\n    char\tsid_buf[25];\n    int\t\toff;\n    char_u\t*newname;\n\n    if (funcname == NULL)\n\treturn NULL;\n\n    if (STRNCMP(funcname, \"s:\", 2) != 0\n\t\t&& STRNCMP(funcname, \"<SID>\", 5) != 0)\n\t// The function name is not a script-local function name\n\treturn NULL;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n    {\n\temsg(_(e_using_sid_not_in_script_context));\n\treturn NULL;\n    }\n    // Expand s: prefix into <SNR>nr_<name>\n    vim_snprintf(sid_buf, sizeof(sid_buf), \"<SNR>%ld_\",\n\t    (long)current_sctx.sc_sid);\n    off = *funcname == 's' ? 2 : 5;\n    newname = alloc(STRLEN(sid_buf) + STRLEN(funcname + off) + 1);\n    if (newname == NULL)\n\treturn NULL;\n    STRCPY(newname, sid_buf);\n    STRCAT(newname, funcname + off);\n\n    return newname;\n}\n\n/*\n * Call trans_function_name(), except that a lambda is returned as-is.\n * Returns the name in allocated memory.\n */\n    char_u *\nsave_function_name(\n\tchar_u\t    **name,\n\tint\t    *is_global,\n\tint\t    skip,\n\tint\t    flags,\n\tfuncdict_T  *fudi)\n{\n    char_u *p = *name;\n    char_u *saved;\n\n    if (STRNCMP(p, \"<lambda>\", 8) == 0)\n    {\n\tp += 8;\n\t(void)getdigits(&p);\n\tsaved = vim_strnsave(*name, p - *name);\n\tif (fudi != NULL)\n\t    CLEAR_POINTER(fudi);\n    }\n    else\n\tsaved = trans_function_name(&p, is_global, skip,\n\t\t\t\t\t\t      flags, fudi, NULL, NULL);\n    *name = p;\n    return saved;\n}\n\n/*\n * List functions.  When \"regmatch\" is NULL all of then.\n * Otherwise functions matching \"regmatch\".\n */\n    void\nlist_functions(regmatch_T *regmatch)\n{\n    int\t\tchanged = func_hashtab.ht_changed;\n    long_u\ttodo = func_hashtab.ht_used;\n    hashitem_T\t*hi;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    ufunc_T\t*fp = HI2UF(hi);\n\n\t    --todo;\n\t    if ((fp->uf_flags & FC_DEAD) == 0\n\t\t    && (regmatch == NULL\n\t\t\t? !message_filtered(fp->uf_name)\n\t\t\t    && !func_name_refcount(fp->uf_name)\n\t\t\t: !isdigit(*fp->uf_name)\n\t\t\t    && vim_regexec(regmatch, fp->uf_name, 0)))\n\t    {\n\t\tlist_func_head(fp, FALSE);\n\t\tif (changed != func_hashtab.ht_changed)\n\t\t{\n\t\t    emsg(_(e_function_list_was_modified));\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * \":function\" also supporting nested \":def\".\n * When \"name_arg\" is not NULL this is a nested function, using \"name_arg\" for\n * the function name.\n * \"lines_to_free\" is a list of strings to be freed later.\n * Returns a pointer to the function or NULL if no function defined.\n */\n    ufunc_T *\ndefine_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n    garray_T\tnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    garray_T\tnewlines;\n    int\t\tvarargs = FALSE;\n    int\t\tflags = 0;\n    char_u\t*ret_type = NULL;\n    ufunc_T\t*fp = NULL;\n    int\t\tfp_allocated = FALSE;\n    int\t\tfree_fp = FALSE;\n    int\t\toverwrite = FALSE;\n    dictitem_T\t*v;\n    funcdict_T\tfudi;\n    static int\tfunc_nr = 0;\t    // number for nameless function\n    int\t\tparen;\n    hashitem_T\t*hi;\n    linenr_T\tsourcing_lnum_top;\n    int\t\tvim9script = in_vim9script();\n    imported_T\t*import = NULL;\n\n    /*\n     * \":function\" without argument: list functions.\n     */\n    if (ends_excmd2(eap->cmd, eap->arg))\n    {\n\tif (!eap->skip)\n\t    list_functions(NULL);\n\tset_nextcmd(eap, eap->arg);\n\treturn NULL;\n    }\n\n    /*\n     * \":function /pat\": list functions matching pattern.\n     */\n    if (*eap->arg == '/')\n    {\n\tp = skip_regexp(eap->arg + 1, '/', TRUE);\n\tif (!eap->skip)\n\t{\n\t    regmatch_T\tregmatch;\n\n\t    c = *p;\n\t    *p = NUL;\n\t    regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);\n\t    *p = c;\n\t    if (regmatch.regprog != NULL)\n\t    {\n\t\tregmatch.rm_ic = p_ic;\n\t\tlist_functions(&regmatch);\n\t\tvim_regfree(regmatch.regprog);\n\t    }\n\t}\n\tif (*p == '/')\n\t    ++p;\n\tset_nextcmd(eap, p);\n\treturn NULL;\n    }\n\n    ga_init(&newargs);\n    ga_init(&argtypes);\n    ga_init(&default_args);\n\n    /*\n     * Get the function name.  There are these situations:\n     * func\t    normal function name\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" == NULL\n     * dict.func    new dictionary entry\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" == NULL, \"fudi.fd_newkey\" == func\n     * dict.func    existing dict entry with a Funcref\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * dict.func    existing dict entry that's not a Funcref\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * s:func\t    script-local function name\n     * g:func\t    global function name, same as \"func\"\n     */\n    p = eap->arg;\n    if (name_arg != NULL)\n    {\n\t// nested function, argument is (args).\n\tparen = TRUE;\n\tCLEAR_FIELD(fudi);\n    }\n    else\n    {\n\tname = save_function_name(&p, &is_global, eap->skip,\n\t\t\t\t\t\t       TFN_NO_AUTOLOAD, &fudi);\n\tparen = (vim_strchr(p, '(') != NULL);\n\tif (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)\n\t{\n\t    /*\n\t     * Return on an invalid expression in braces, unless the expression\n\t     * evaluation has been cancelled due to an aborting error, an\n\t     * interrupt, or an exception.\n\t     */\n\t    if (!aborting())\n\t    {\n\t\tif (!eap->skip && fudi.fd_newkey != NULL)\n\t\t    semsg(_(e_key_not_present_in_dictionary), fudi.fd_newkey);\n\t\tvim_free(fudi.fd_newkey);\n\t\treturn NULL;\n\t    }\n\t    else\n\t\teap->skip = TRUE;\n\t}\n    }\n\n    // An error in a function call during evaluation of an expression in magic\n    // braces should not cause the function not to be defined.\n    saved_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    /*\n     * \":function func\" with only function name: list function.\n     */\n    if (!paren)\n    {\n\tif (!ends_excmd(*skipwhite(p)))\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    goto ret_free;\n\t}\n\tset_nextcmd(eap, p);\n\tif (eap->nextcmd != NULL)\n\t    *p = NUL;\n\tif (!eap->skip && !got_int)\n\t{\n\t    fp = find_func(name, is_global, NULL);\n\t    if (fp == NULL && ASCII_ISUPPER(*eap->arg))\n\t    {\n\t\tchar_u *up = untrans_function_name(name);\n\n\t\t// With Vim9 script the name was made script-local, if not\n\t\t// found try again with the original name.\n\t\tif (up != NULL)\n\t\t    fp = find_func(up, FALSE, NULL);\n\t    }\n\n\t    if (fp != NULL)\n\t    {\n\t\tlist_func_head(fp, TRUE);\n\t\tfor (j = 0; j < fp->uf_lines.ga_len && !got_int; ++j)\n\t\t{\n\t\t    if (FUNCLINE(fp, j) == NULL)\n\t\t\tcontinue;\n\t\t    msg_putchar('\\n');\n\t\t    msg_outnum((long)(j + 1));\n\t\t    if (j < 9)\n\t\t\tmsg_putchar(' ');\n\t\t    if (j < 99)\n\t\t\tmsg_putchar(' ');\n\t\t    msg_prt_line(FUNCLINE(fp, j), FALSE);\n\t\t    out_flush();\t// show a line at a time\n\t\t    ui_breakcheck();\n\t\t}\n\t\tif (!got_int)\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    if (fp->uf_def_status != UF_NOT_COMPILED)\n\t\t\tmsg_puts(\"   enddef\");\n\t\t    else\n\t\t\tmsg_puts(\"   endfunction\");\n\t\t}\n\t    }\n\t    else\n\t\temsg_funcname(e_undefined_function_str, eap->arg);\n\t}\n\tgoto ret_free;\n    }\n\n    /*\n     * \":function name(arg1, arg2)\" Define function.\n     */\n    p = skipwhite(p);\n    if (*p != '(')\n    {\n\tif (!eap->skip)\n\t{\n\t    semsg(_(e_missing_paren_str), eap->arg);\n\t    goto ret_free;\n\t}\n\t// attempt to continue by skipping some text\n\tif (vim_strchr(p, '(') != NULL)\n\t    p = vim_strchr(p, '(');\n    }\n\n    if ((vim9script || eap->cmdidx == CMD_def) && VIM_ISWHITE(p[-1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", p - 1);\n\tgoto ret_free;\n    }\n\n    // In Vim9 script only global functions can be redefined.\n    if (vim9script && eap->forceit && !is_global)\n    {\n\temsg(_(e_no_bang_allowed));\n\tgoto ret_free;\n    }\n\n    ga_init2(&newlines, (int)sizeof(char_u *), 10);\n\n    if (!eap->skip && name_arg == NULL)\n    {\n\t// Check the name of the function.  Unless it's a dictionary function\n\t// (that we are overwriting).\n\tif (name != NULL)\n\t    arg = name;\n\telse\n\t    arg = fudi.fd_newkey;\n\tif (arg != NULL && (fudi.fd_di == NULL\n\t\t\t\t     || (fudi.fd_di->di_tv.v_type != VAR_FUNC\n\t\t\t\t && fudi.fd_di->di_tv.v_type != VAR_PARTIAL)))\n\t{\n\t    char_u  *name_base = arg;\n\t    int\t    i;\n\n\t    if (*arg == K_SPECIAL)\n\t    {\n\t\tname_base = vim_strchr(arg, '_');\n\t\tif (name_base == NULL)\n\t\t    name_base = arg + 3;\n\t\telse\n\t\t    ++name_base;\n\t    }\n\t    for (i = 0; name_base[i] != NUL && (i == 0\n\t\t\t\t\t? eval_isnamec1(name_base[i])\n\t\t\t\t\t: eval_isnamec(name_base[i])); ++i)\n\t\t;\n\t    if (name_base[i] != NUL)\n\t\temsg_funcname(e_invalid_argument_str, arg);\n\n\t    // In Vim9 script a function cannot have the same name as a\n\t    // variable.\n\t    if (vim9script && *arg == K_SPECIAL\n\t\t&& eval_variable(name_base, (int)STRLEN(name_base), 0, NULL,\n\t\t    NULL, EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT\n\t\t\t\t\t\t     + EVAL_VAR_NO_FUNC) == OK)\n\t    {\n\t\tsemsg(_(e_redefining_script_item_str), name_base);\n\t\tgoto ret_free;\n\t    }\n\t}\n\t// Disallow using the g: dict.\n\tif (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)\n\t{\n\t    emsg(_(e_cannot_use_g_here));\n\t    goto ret_free;\n\t}\n    }\n\n    // This may get more lines and make the pointers into the first line\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, lines_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t// find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_colon_str), p);\n\t\tp = skipwhite(p);\n\t    }\n\t    else if (!IS_WHITE_OR_NUL(p[1]))\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p);\n\t    ret_type = skipwhite(p + 1);\n\t    p = skip_type(ret_type, FALSE);\n\t    if (p > ret_type)\n\t    {\n\t\tret_type = vim_strnsave(ret_type, p - ret_type);\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_expected_type_str), ret_type);\n\t\tret_type = NULL;\n\t    }\n\t}\n\tp = skipwhite(p);\n    }\n    else\n\t// find extra arguments \"range\", \"dict\", \"abort\" and \"closure\"\n\tfor (;;)\n\t{\n\t    whitep = p;\n\t    p = skipwhite(p);\n\t    if (STRNCMP(p, \"range\", 5) == 0)\n\t    {\n\t\tflags |= FC_RANGE;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"dict\", 4) == 0)\n\t    {\n\t\tflags |= FC_DICT;\n\t\tp += 4;\n\t    }\n\t    else if (STRNCMP(p, \"abort\", 5) == 0)\n\t    {\n\t\tflags |= FC_ABORT;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"closure\", 7) == 0)\n\t    {\n\t\tflags |= FC_CLOSURE;\n\t\tp += 7;\n\t\tif (current_funccal == NULL)\n\t\t{\n\t\t    emsg_funcname(e_closure_function_should_not_be_at_top_level,\n\t\t\t    name == NULL ? (char_u *)\"\" : name);\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n\n    // When there is a line break use what follows for the function body.\n    // Makes 'exe \"func Test()\\n...\\nendfunc\"' work.\n    if (*p == '\\n')\n\tline_arg = p + 1;\n    else if (*p != NUL\n\t    && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)\n\t\t\t\t\t\t     && eap->cmdidx != CMD_def)\n\t    && !(VIM_ISWHITE(*whitep) && *p == '#'\n\t\t\t\t     && (vim9script || eap->cmdidx == CMD_def))\n\t    && !eap->skip\n\t    && !did_emsg)\n\tsemsg(_(e_trailing_characters_str), p);\n\n    /*\n     * Read the body of the function, until \"}\", \":endfunction\" or \":enddef\" is\n     * found.\n     */\n    if (KeyTyped)\n    {\n\t// Check if the function already exists, don't let the user type the\n\t// whole function before telling him it doesn't work!  For a script we\n\t// need to skip the body to be able to find what follows.\n\tif (!eap->skip && !eap->forceit)\n\t{\n\t    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)\n\t\temsg(_(e_dictionary_entry_already_exists));\n\t    else if (name != NULL && find_func(name, is_global, NULL) != NULL)\n\t\temsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);\n\t}\n\n\tif (!eap->skip && did_emsg)\n\t    goto erret;\n\n\tmsg_putchar('\\n');\t    // don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function\n     */\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n\n\tv = find_var(name, &ht, TRUE);\n\tif (v != NULL && v->di_tv.v_type == VAR_FUNC)\n\t{\n\t    emsg_funcname(e_function_name_conflicts_with_variable_str, name);\n\t    goto erret;\n\t}\n\n\tfp = find_func_even_dead(name, is_global, NULL);\n\tif (vim9script)\n\t{\n\t    char_u *uname = untrans_function_name(name);\n\n\t    import = find_imported(uname == NULL ? name : uname, 0, NULL);\n\t}\n\n\tif (fp != NULL || import != NULL)\n\t{\n\t    int dead = fp != NULL && (fp->uf_flags & FC_DEAD);\n\n\t    // Function can be replaced with \"function!\" and when sourcing the\n\t    // same script again, but only once.\n\t    // A name that is used by an import can not be overruled.\n\t    if (import != NULL\n\t\t    || (!dead && !eap->forceit\n\t\t\t&& (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)))\n\t    {\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tif (vim9script)\n\t\t    emsg_funcname(e_name_already_defined_str, name);\n\t\telse\n\t\t    emsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_calls > 0)\n\t    {\n\t\temsg_funcname(\n\t\t\t    e_cannot_redefine_function_str_it_is_in_use, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_refcount > 1)\n\t    {\n\t\t// This function is referenced somewhere, don't redefine it but\n\t\t// create a new one.\n\t\t--fp->uf_refcount;\n\t\tfp->uf_flags |= FC_REMOVED;\n\t\tfp = NULL;\n\t\toverwrite = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u *exp_name = fp->uf_name_exp;\n\n\t\t// redefine existing function, keep the expanded name\n\t\tVIM_CLEAR(name);\n\t\tfp->uf_name_exp = NULL;\n\t\tfunc_clear_items(fp);\n\t\tfp->uf_name_exp = exp_name;\n\t\tfp->uf_flags &= ~FC_DEAD;\n#ifdef FEAT_PROFILE\n\t\tfp->uf_profiling = FALSE;\n\t\tfp->uf_prof_initialized = FALSE;\n#endif\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\t    }\n\t}\n    }\n    else\n    {\n\tchar\tnumbuf[20];\n\n\tfp = NULL;\n\tif (fudi.fd_newkey == NULL && !eap->forceit)\n\t{\n\t    emsg(_(e_dictionary_entry_already_exists));\n\t    goto erret;\n\t}\n\tif (fudi.fd_di == NULL)\n\t{\n\t    // Can't add a function to a locked dictionary\n\t    if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))\n\t\tgoto erret;\n\t}\n\t    // Can't change an existing function if it is locked\n\telse if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))\n\t    goto erret;\n\n\t// Give the function a sequential number.  Can only be used with a\n\t// Funcref!\n\tvim_free(name);\n\tsprintf(numbuf, \"%d\", ++func_nr);\n\tname = vim_strsave((char_u *)numbuf);\n\tif (name == NULL)\n\t    goto erret;\n    }\n\n    if (fp == NULL)\n    {\n\tif (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    int\t    slen, plen;\n\t    char_u  *scriptname;\n\n\t    // Check that the autoload name matches the script name.\n\t    j = FAIL;\n\t    if (SOURCING_NAME != NULL)\n\t    {\n\t\tscriptname = autoload_name(name);\n\t\tif (scriptname != NULL)\n\t\t{\n\t\t    p = vim_strchr(scriptname, '/');\n\t\t    plen = (int)STRLEN(p);\n\t\t    slen = (int)STRLEN(SOURCING_NAME);\n\t\t    if (slen > plen && fnamecmp(p,\n\t\t\t\t\t    SOURCING_NAME + slen - plen) == 0)\n\t\t\tj = OK;\n\t\t    vim_free(scriptname);\n\t\t}\n\t    }\n\t    if (j == FAIL)\n\t    {\n\t\tlinenr_T save_lnum = SOURCING_LNUM;\n\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tsemsg(_(e_function_name_does_not_match_script_file_name_str),\n\t\t\t\t\t\t\t\t\t name);\n\t\tSOURCING_LNUM = save_lnum;\n\t\tgoto erret;\n\t    }\n\t}\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto erret;\n\tfp_allocated = TRUE;\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    if (fudi.fd_di == NULL)\n\t    {\n\t\t// add new dict entry\n\t\tfudi.fd_di = dictitem_alloc(fudi.fd_newkey);\n\t\tif (fudi.fd_di == NULL)\n\t\t{\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t\tif (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)\n\t\t{\n\t\t    vim_free(fudi.fd_di);\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\t// overwrite existing dict entry\n\t\tclear_tv(&fudi.fd_di->di_tv);\n\t    fudi.fd_di->di_tv.v_type = VAR_FUNC;\n\t    fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);\n\n\t    // behave like \"dict\" was used\n\t    flags |= FC_DICT;\n\t}\n    }\n    fp->uf_args = newargs;\n    fp->uf_def_args = default_args;\n    fp->uf_ret_type = &t_any;\n    fp->uf_func_type = &t_func_any;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\tint\t    lnum_save = SOURCING_LNUM;\n\tcstack_T    *cstack = eap->cstack;\n\n\tfp->uf_def_status = UF_TO_BE_COMPILED;\n\n\t// error messages are for the first function line\n\tSOURCING_LNUM = sourcing_lnum_top;\n\n\t// The function may use script variables from the context.\n\tfunction_using_block_scopes(fp, cstack);\n\n\tif (parse_argument_types(fp, &argtypes, varargs) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tvarargs = FALSE;\n\n\t// parse the return type, if any\n\tif (parse_return_type(fp, ret_type) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tSOURCING_LNUM = lnum_save;\n    }\n    else\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\n    if (fp_allocated)\n    {\n\t// insert the new function in the function list\n\tset_ufunc_name(fp, name);\n\tif (overwrite)\n\t{\n\t    hi = hash_find(&func_hashtab, name);\n\t    hi->hi_key = UF2HIKEY(fp);\n\t}\n\telse if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)\n\t{\n\t    free_fp = TRUE;\n\t    goto erret;\n\t}\n\tfp->uf_refcount = 1;\n    }\n\n    fp->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if ((flags & FC_CLOSURE) != 0)\n    {\n\tif (register_closure(fp) == FAIL)\n\t    goto erret;\n    }\n    else\n\tfp->uf_scoped = NULL;\n\n#ifdef FEAT_PROFILE\n    if (prof_def_func())\n\tfunc_do_profile(fp);\n#endif\n    fp->uf_varargs = varargs;\n    if (sandbox)\n\tflags |= FC_SANDBOX;\n    if (vim9script && !ASCII_ISUPPER(*fp->uf_name))\n\tflags |= FC_VIM9;\n    fp->uf_flags = flags;\n    fp->uf_calls = 0;\n    fp->uf_cleared = FALSE;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_script_ctx_version = current_sctx.sc_version;\n    fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    if (is_export)\n    {\n\tfp->uf_flags |= FC_EXPORT;\n\t// let ex_export() know the export worked.\n\tis_export = FALSE;\n    }\n\n    if (eap->cmdidx == CMD_def)\n\tset_function_type(fp);\n    else if (fp->uf_script_ctx.sc_version == SCRIPT_VERSION_VIM9)\n\t// :func does not use Vim9 script syntax, even in a Vim9 script file\n\tfp->uf_script_ctx.sc_version = SCRIPT_VERSION_MAX;\n\n    goto ret_free;\n\nerret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&default_args);\n    if (fp != NULL)\n    {\n\tga_init(&fp->uf_args);\n\tga_init(&fp->uf_def_args);\n    }\nerrret_2:\n    ga_clear_strings(&newlines);\n    if (fp != NULL)\n\tVIM_CLEAR(fp->uf_arg_types);\n    if (free_fp)\n    {\n\tvim_free(fp);\n\tfp = NULL;\n    }\nret_free:\n    ga_clear_strings(&argtypes);\n    vim_free(fudi.fd_newkey);\n    if (name != name_arg)\n\tvim_free(name);\n    vim_free(ret_type);\n    did_emsg |= saved_did_emsg;\n\n    return fp;\n}\n\n/*\n * \":function\"\n */\n    void\nex_function(exarg_T *eap)\n{\n    garray_T lines_to_free;\n\n    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n    (void)define_function(eap, NULL, &lines_to_free);\n    ga_clear_strings(&lines_to_free);\n}\n\n/*\n * :defcompile - compile all :def functions in the current script that need to\n * be compiled.  Except dead functions.  Doesn't do profiling.\n */\n    void\nex_defcompile(exarg_T *eap UNUSED)\n{\n    long\ttodo = (long)func_hashtab.ht_used;\n    int\t\tchanged = func_hashtab.ht_changed;\n    hashitem_T\t*hi;\n    ufunc_T\t*ufunc;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    ufunc = HI2UF(hi);\n\t    if (ufunc->uf_script_ctx.sc_sid == current_sctx.sc_sid\n\t\t    && ufunc->uf_def_status == UF_TO_BE_COMPILED\n\t\t    && (ufunc->uf_flags & FC_DEAD) == 0)\n\t    {\n\t\t(void)compile_def_function(ufunc, FALSE, CT_NONE, NULL);\n\n\t\tif (func_hashtab.ht_changed != changed)\n\t\t{\n\t\t    // a function has been added or removed, need to start over\n\t\t    todo = (long)func_hashtab.ht_used;\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    hi = func_hashtab.ht_array;\n\t\t    --hi;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Return 5 if \"p\" starts with \"<SID>\" or \"<SNR>\" (ignoring case).\n * Return 2 if \"p\" starts with \"s:\".\n * Return 0 otherwise.\n */\n    int\neval_fname_script(char_u *p)\n{\n    // Use MB_STRICMP() because in Turkish comparing the \"I\" may not work with\n    // the standard library function.\n    if (p[0] == '<' && (MB_STRNICMP(p + 1, \"SID>\", 4) == 0\n\t\t\t\t       || MB_STRNICMP(p + 1, \"SNR>\", 4) == 0))\n\treturn 5;\n    if (p[0] == 's' && p[1] == ':')\n\treturn 2;\n    return 0;\n}\n\n    int\ntranslated_function_exists(char_u *name, int is_global)\n{\n    if (builtin_function(name, -1))\n\treturn has_internal_func(name);\n    return find_func(name, is_global, NULL) != NULL;\n}\n\n/*\n * Return TRUE when \"ufunc\" has old-style \"...\" varargs\n * or named varargs \"...name: type\".\n */\n    int\nhas_varargs(ufunc_T *ufunc)\n{\n    return ufunc->uf_varargs || ufunc->uf_va_name != NULL;\n}\n\n/*\n * Return TRUE if a function \"name\" exists.\n * If \"no_defef\" is TRUE, do not dereference a Funcref.\n */\n    int\nfunction_exists(char_u *name, int no_deref)\n{\n    char_u  *nm = name;\n    char_u  *p;\n    int\t    n = FALSE;\n    int\t    flag;\n    int\t    is_global = FALSE;\n\n    flag = TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD;\n    if (no_deref)\n\tflag |= TFN_NO_DEREF;\n    p = trans_function_name(&nm, &is_global, FALSE, flag, NULL, NULL, NULL);\n    nm = skipwhite(nm);\n\n    // Only accept \"funcname\", \"funcname \", \"funcname (...\" and\n    // \"funcname(...\", not \"funcname!...\".\n    if (p != NULL && (*nm == NUL || *nm == '('))\n\tn = translated_function_exists(p, is_global);\n    vim_free(p);\n    return n;\n}\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    char_u *\nget_expanded_name(char_u *name, int check)\n{\n    char_u\t*nm = name;\n    char_u\t*p;\n    int\t\tis_global = FALSE;\n\n    p = trans_function_name(&nm, &is_global, FALSE,\n\t\t\t\t\t  TFN_INT|TFN_QUIET, NULL, NULL, NULL);\n\n    if (p != NULL && *nm == NUL\n\t\t       && (!check || translated_function_exists(p, is_global)))\n\treturn p;\n\n    vim_free(p);\n    return NULL;\n}\n#endif\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user defined\n * function names.\n */\n    char_u *\nget_user_func_name(expand_T *xp, int idx)\n{\n    static long_u\tdone;\n    static int\t\tchanged;\n    static hashitem_T\t*hi;\n    ufunc_T\t\t*fp;\n\n    if (idx == 0)\n    {\n\tdone = 0;\n\thi = func_hashtab.ht_array;\n\tchanged = func_hashtab.ht_changed;\n    }\n    if (changed == func_hashtab.ht_changed && done < func_hashtab.ht_used)\n    {\n\tif (done++ > 0)\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\tfp = HI2UF(hi);\n\n\t// don't show dead, dict and lambda functions\n\tif ((fp->uf_flags & FC_DEAD) || (fp->uf_flags & FC_DICT)\n\t\t\t\t|| STRNCMP(fp->uf_name, \"<lambda>\", 8) == 0)\n\t    return (char_u *)\"\";\n\n\tif (STRLEN(fp->uf_name) + 4 >= IOSIZE)\n\t    return fp->uf_name;\t// prevents overflow\n\n\tcat_func_name(IObuff, fp);\n\tif (xp->xp_context != EXPAND_USER_FUNC\n\t\t\t\t       && xp->xp_context != EXPAND_DISASSEMBLE)\n\t{\n\t    STRCAT(IObuff, \"(\");\n\t    if (!has_varargs(fp) && fp->uf_args.ga_len == 0)\n\t\tSTRCAT(IObuff, \")\");\n\t}\n\treturn IObuff;\n    }\n    return NULL;\n}\n\n/*\n * \":delfunction {name}\"\n */\n    void\nex_delfunction(exarg_T *eap)\n{\n    ufunc_T\t*fp = NULL;\n    char_u\t*p;\n    char_u\t*name;\n    funcdict_T\tfudi;\n    int\t\tis_global = FALSE;\n\n    p = eap->arg;\n    name = trans_function_name(&p, &is_global, eap->skip, 0, &fudi,\n\t\t\t\t\t\t\t\t   NULL, NULL);\n    vim_free(fudi.fd_newkey);\n    if (name == NULL)\n    {\n\tif (fudi.fd_dict != NULL && !eap->skip)\n\t    emsg(_(e_funcref_required));\n\treturn;\n    }\n    if (!ends_excmd(*skipwhite(p)))\n    {\n\tvim_free(name);\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn;\n    }\n    set_nextcmd(eap, p);\n    if (eap->nextcmd != NULL)\n\t*p = NUL;\n\n    if (numbered_function(name) && fudi.fd_dict == NULL)\n    {\n\tif (!eap->skip)\n\t    semsg(_(e_invalid_argument_str), eap->arg);\n\tvim_free(name);\n\treturn;\n    }\n    if (!eap->skip)\n\tfp = find_func(name, is_global, NULL);\n    vim_free(name);\n\n    if (!eap->skip)\n    {\n\tif (fp == NULL)\n\t{\n\t    if (!eap->forceit)\n\t\tsemsg(_(e_unknown_function_str), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_calls > 0)\n\t{\n\t    semsg(_(e_cannot_delete_function_str_it_is_in_use), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_flags & FC_VIM9)\n\t{\n\t    semsg(_(e_cannot_delete_vim9_script_function_str), eap->arg);\n\t    return;\n\t}\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    // Delete the dict item that refers to the function, it will\n\t    // invoke func_unref() and possibly delete the function.\n\t    dictitem_remove(fudi.fd_dict, fudi.fd_di);\n\t}\n\telse\n\t{\n\t    // A normal function (not a numbered function or lambda) has a\n\t    // refcount of 1 for the entry in the hashtable.  When deleting\n\t    // it and the refcount is more than one, it should be kept.\n\t    // A numbered function and lambda should be kept if the refcount is\n\t    // one or more.\n\t    if (fp->uf_refcount > (func_name_refcount(fp->uf_name) ? 0 : 1))\n\t    {\n\t\t// Function is still referenced somewhere.  Don't free it but\n\t\t// do remove it from the hashtable.\n\t\tif (func_remove(fp))\n\t\t    fp->uf_refcount--;\n\t    }\n\t    else\n\t\tfunc_clear_free(fp, FALSE);\n\t}\n    }\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\nfunc_unref(char_u *name)\n{\n    ufunc_T *fp = NULL;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE, NULL);\n    if (fp == NULL && numbered_function(name))\n    {\n#ifdef EXITFREE\n\tif (!entered_free_all_mem)\n#endif\n\t    internal_error(\"func_unref()\");\n    }\n    func_ptr_unref(fp);\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n * Also when it becomes one and uf_partial points to the function.\n */\n    void\nfunc_ptr_unref(ufunc_T *fp)\n{\n    if (fp != NULL && (--fp->uf_refcount <= 0\n\t\t|| (fp->uf_refcount == 1 && fp->uf_partial != NULL\n\t\t\t\t\t && fp->uf_partial->pt_refcount <= 1\n\t\t\t\t\t && fp->uf_partial->pt_func == fp)))\n    {\n\t// Only delete it when it's not being used.  Otherwise it's done\n\t// when \"uf_calls\" becomes zero.\n\tif (fp->uf_calls == 0)\n\t    func_clear_free(fp, FALSE);\n    }\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ref(char_u *name)\n{\n    ufunc_T *fp;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE, NULL);\n    if (fp != NULL)\n\t++fp->uf_refcount;\n    else if (numbered_function(name))\n\t// Only give an error for a numbered function.\n\t// Fail silently, when named or lambda function isn't found.\n\tinternal_error(\"func_ref()\");\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ptr_ref(ufunc_T *fp)\n{\n    if (fp != NULL)\n\t++fp->uf_refcount;\n}\n\n/*\n * Return TRUE if items in \"fc\" do not have \"copyID\".  That means they are not\n * referenced from anywhere that is in use.\n */\n    static int\ncan_free_funccal(funccall_T *fc, int copyID)\n{\n    return (fc->l_varlist.lv_copyID != copyID\n\t    && fc->l_vars.dv_copyID != copyID\n\t    && fc->l_avars.dv_copyID != copyID\n\t    && fc->fc_copyID != copyID);\n}\n\n/*\n * \":return [expr]\"\n */\n    void\nex_return(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\treturning = FALSE;\n    evalarg_T\tevalarg;\n\n    if (current_funccal == NULL)\n    {\n\temsg(_(e_return_not_inside_function));\n\treturn;\n    }\n\n    init_evalarg(&evalarg);\n    evalarg.eval_flags = eap->skip ? 0 : EVAL_EVALUATE;\n\n    if (eap->skip)\n\t++emsg_skip;\n\n    eap->nextcmd = NULL;\n    if ((*arg != NUL && *arg != '|' && *arg != '\\n')\n\t\t\t\t  && eval0(arg, &rettv, eap, &evalarg) != FAIL)\n    {\n\tif (!eap->skip)\n\t    returning = do_return(eap, FALSE, TRUE, &rettv);\n\telse\n\t    clear_tv(&rettv);\n    }\n    // It's safer to return also on error.\n    else if (!eap->skip)\n    {\n\t// In return statement, cause_abort should be force_abort.\n\tupdate_force_abort();\n\n\t/*\n\t * Return unless the expression evaluation has been cancelled due to an\n\t * aborting error, an interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t    returning = do_return(eap, FALSE, TRUE, NULL);\n    }\n\n    // When skipping or the return gets pending, advance to the next command\n    // in this line (!returning).  Otherwise, ignore the rest of the line.\n    // Following lines will be ignored by get_func_line().\n    if (returning)\n\teap->nextcmd = NULL;\n    else if (eap->nextcmd == NULL)\t    // no argument\n\tset_nextcmd(eap, arg);\n\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n}\n\n/*\n * \":1,25call func(arg1, arg2)\"\tfunction call.\n */\n    void\nex_call(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*startarg;\n    char_u\t*name;\n    char_u\t*tofree;\n    int\t\tlen;\n    typval_T\trettv;\n    linenr_T\tlnum;\n    int\t\tdoesrange;\n    int\t\tfailed = FALSE;\n    funcdict_T\tfudi;\n    partial_T\t*partial = NULL;\n    evalarg_T\tevalarg;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n    if (eap->skip)\n    {\n\t// trans_function_name() doesn't work well when skipping, use eval0()\n\t// instead to skip to any following command, e.g. for:\n\t//   :if 0 | call dict.foo().bar() | endif\n\t++emsg_skip;\n\tif (eval0(eap->arg, &rettv, eap, &evalarg) != FAIL)\n\t    clear_tv(&rettv);\n\t--emsg_skip;\n\tclear_evalarg(&evalarg, eap);\n\treturn;\n    }\n\n    tofree = trans_function_name(&arg, NULL, eap->skip, TFN_INT,\n\t\t\t      &fudi, &partial, in_vim9script() ? &type : NULL);\n    if (fudi.fd_newkey != NULL)\n    {\n\t// Still need to give an error message for missing key.\n\tsemsg(_(e_key_not_present_in_dictionary), fudi.fd_newkey);\n\tvim_free(fudi.fd_newkey);\n    }\n    if (tofree == NULL)\n\treturn;\n\n    // Increase refcount on dictionary, it could get deleted when evaluating\n    // the arguments.\n    if (fudi.fd_dict != NULL)\n\t++fudi.fd_dict->dv_refcount;\n\n    // If it is the name of a variable of type VAR_FUNC or VAR_PARTIAL use its\n    // contents.  For VAR_PARTIAL get its partial, unless we already have one\n    // from trans_function_name().\n    len = (int)STRLEN(tofree);\n    name = deref_func_name(tofree, &len, partial != NULL ? NULL : &partial,\n\t    in_vim9script() && type == NULL ? &type : NULL, FALSE, &found_var);\n\n    // Skip white space to allow \":call func ()\".  Not good, but required for\n    // backward compatibility.\n    startarg = skipwhite(arg);\n    if (*startarg != '(')\n    {\n\tsemsg(_(e_missing_parenthesis_str), eap->arg);\n\tgoto end;\n    }\n    if (in_vim9script() && startarg > arg)\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", eap->arg);\n\tgoto end;\n    }\n\n    /*\n     * When skipping, evaluate the function once, to find the end of the\n     * arguments.\n     * When the function takes a range, this is discovered after the first\n     * call, and the loop is broken.\n     */\n    if (eap->skip)\n    {\n\t++emsg_skip;\n\tlnum = eap->line2;\t// do it once, also with an invalid range\n    }\n    else\n\tlnum = eap->line1;\n    for ( ; lnum <= eap->line2; ++lnum)\n    {\n\tfuncexe_T funcexe;\n\n\tif (!eap->skip && eap->addr_count > 0)\n\t{\n\t    if (lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// If the function deleted lines or switched to another buffer\n\t\t// the line number may become invalid.\n\t\temsg(_(e_invalid_range));\n\t\tbreak;\n\t    }\n\t    curwin->w_cursor.lnum = lnum;\n\t    curwin->w_cursor.col = 0;\n\t    curwin->w_cursor.coladd = 0;\n\t}\n\targ = startarg;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = eap->line1;\n\tfuncexe.fe_lastline = eap->line2;\n\tfuncexe.fe_doesrange = &doesrange;\n\tfuncexe.fe_evaluate = !eap->skip;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = fudi.fd_dict;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\trettv.v_type = VAR_UNKNOWN;\t// clear_tv() uses this\n\tif (get_func_tv(name, -1, &rettv, &arg, &evalarg, &funcexe) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\tif (has_watchexpr())\n\t    dbg_check_breakpoint(eap);\n\n\t// Handle a function returning a Funcref, Dictionary or List.\n\tif (handle_subscript(&arg, NULL, &rettv,\n\t\t\t   eap->skip ? NULL : &EVALARG_EVALUATE, TRUE) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\n\tclear_tv(&rettv);\n\tif (doesrange || eap->skip)\n\t    break;\n\n\t// Stop when immediately aborting on error, or when an interrupt\n\t// occurred or an exception was thrown but not caught.\n\t// get_func_tv() returned OK, so that the check for trailing\n\t// characters below is executed.\n\tif (aborting())\n\t    break;\n    }\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    // When inside :try we need to check for following \"| catch\" or \"| endtry\".\n    // Not when there was an error, but do check if an exception was thrown.\n    if ((!aborting() || did_throw)\n\t\t\t\t  && (!failed || eap->cstack->cs_trylevel > 0))\n    {\n\t// Check for trailing illegal characters and a following command.\n\targ = skipwhite(arg);\n\tif (!ends_excmd2(eap->arg, arg))\n\t{\n\t    if (!failed && !aborting())\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_trailing_characters_str), arg);\n\t    }\n\t}\n\telse\n\t    set_nextcmd(eap, arg);\n    }\n\nend:\n    dict_unref(fudi.fd_dict);\n    vim_free(tofree);\n}\n\n/*\n * Return from a function.  Possibly makes the return pending.  Also called\n * for a pending return at the \":endtry\" or after returning from an extra\n * do_cmdline().  \"reanimate\" is used in the latter case.  \"is_cmd\" is set\n * when called due to a \":return\" command.  \"rettv\" may point to a typval_T\n * with the return rettv.  Returns TRUE when the return can be carried out,\n * FALSE when the return gets pending.\n */\n    int\ndo_return(\n    exarg_T\t*eap,\n    int\t\treanimate,\n    int\t\tis_cmd,\n    void\t*rettv)\n{\n    int\t\tidx;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (reanimate)\n\t// Undo the return.\n\tcurrent_funccal->returned = FALSE;\n\n    /*\n     * Cleanup (and inactivate) conditionals, but stop when a try conditional\n     * not in its finally clause (which then is to be executed next) is found.\n     * In this case, make the \":return\" pending for execution at the \":endtry\".\n     * Otherwise, return normally.\n     */\n    idx = cleanup_conditionals(eap->cstack, 0, TRUE);\n    if (idx >= 0)\n    {\n\tcstack->cs_pending[idx] = CSTP_RETURN;\n\n\tif (!is_cmd && !reanimate)\n\t    // A pending return again gets pending.  \"rettv\" points to an\n\t    // allocated variable with the rettv of the original \":return\"'s\n\t    // argument if present or is NULL else.\n\t    cstack->cs_rettv[idx] = rettv;\n\telse\n\t{\n\t    // When undoing a return in order to make it pending, get the stored\n\t    // return rettv.\n\t    if (reanimate)\n\t\trettv = current_funccal->rettv;\n\n\t    if (rettv != NULL)\n\t    {\n\t\t// Store the value of the pending return.\n\t\tif ((cstack->cs_rettv[idx] = alloc_tv()) != NULL)\n\t\t    *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;\n\t\telse\n\t\t    emsg(_(e_out_of_memory));\n\t    }\n\t    else\n\t\tcstack->cs_rettv[idx] = NULL;\n\n\t    if (reanimate)\n\t    {\n\t\t// The pending return value could be overwritten by a \":return\"\n\t\t// without argument in a finally clause; reset the default\n\t\t// return value.\n\t\tcurrent_funccal->rettv->v_type = VAR_NUMBER;\n\t\tcurrent_funccal->rettv->vval.v_number = 0;\n\t    }\n\t}\n\treport_make_pending(CSTP_RETURN, rettv);\n    }\n    else\n    {\n\tcurrent_funccal->returned = TRUE;\n\n\t// If the return is carried out now, store the return value.  For\n\t// a return immediately after reanimation, the value is already\n\t// there.\n\tif (!reanimate && rettv != NULL)\n\t{\n\t    clear_tv(current_funccal->rettv);\n\t    *current_funccal->rettv = *(typval_T *)rettv;\n\t    if (!is_cmd)\n\t\tvim_free(rettv);\n\t}\n    }\n\n    return idx < 0;\n}\n\n/*\n * Free the variable with a pending return value.\n */\n    void\ndiscard_pending_return(void *rettv)\n{\n    free_tv((typval_T *)rettv);\n}\n\n/*\n * Generate a return command for producing the value of \"rettv\".  The result\n * is an allocated string.  Used by report_pending() for verbose messages.\n */\n    char_u *\nget_return_cmd(void *rettv)\n{\n    char_u\t*s = NULL;\n    char_u\t*tofree = NULL;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    if (rettv != NULL)\n\ts = echo_string((typval_T *)rettv, &tofree, numbuf, 0);\n    if (s == NULL)\n\ts = (char_u *)\"\";\n\n    STRCPY(IObuff, \":return \");\n    STRNCPY(IObuff + 8, s, IOSIZE - 8);\n    if (STRLEN(s) + 8 >= IOSIZE)\n\tSTRCPY(IObuff + IOSIZE - 4, \"...\");\n    vim_free(tofree);\n    return vim_strsave(IObuff);\n}\n\n/*\n * Get next function line.\n * Called by do_cmdline() to get the next line.\n * Returns allocated string, or NULL for end of function.\n */\n    char_u *\nget_func_line(\n    int\t    c UNUSED,\n    void    *cookie,\n    int\t    indent UNUSED,\n    getline_opt_T options UNUSED)\n{\n    funccall_T\t*fcp = (funccall_T *)cookie;\n    ufunc_T\t*fp = fcp->func;\n    char_u\t*retval;\n    garray_T\t*gap;  // growarray with function lines\n\n    // If breakpoints have been added/deleted need to check for it.\n    if (fcp->dbg_tick != debug_tick)\n    {\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tfunc_line_end(cookie);\n#endif\n\n    gap = &fp->uf_lines;\n    if (((fp->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned)\n\tretval = NULL;\n    else\n    {\n\t// Skip NULL lines (continuation lines).\n\twhile (fcp->linenr < gap->ga_len\n\t\t\t  && ((char_u **)(gap->ga_data))[fcp->linenr] == NULL)\n\t    ++fcp->linenr;\n\tif (fcp->linenr >= gap->ga_len)\n\t    retval = NULL;\n\telse\n\t{\n\t    retval = vim_strsave(((char_u **)(gap->ga_data))[fcp->linenr++]);\n\t    SOURCING_LNUM = fcp->linenr;\n#ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t\tfunc_line_start(cookie, SOURCING_LNUM);\n#endif\n\t}\n    }\n\n    // Did we encounter a breakpoint?\n    if (fcp->breakpoint != 0 && fcp->breakpoint <= SOURCING_LNUM)\n    {\n\tdbg_breakpoint(fp->uf_name, SOURCING_LNUM);\n\t// Find next breakpoint.\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if the currently active function should be ended, because a\n * return was encountered or an error occurred.  Used inside a \":while\".\n */\n    int\nfunc_has_ended(void *cookie)\n{\n    funccall_T  *fcp = (funccall_T *)cookie;\n\n    // Ignore the \"abort\" flag if the abortion behavior has been changed due to\n    // an error inside a try conditional.\n    return (((fcp->func->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned);\n}\n\n/*\n * return TRUE if cookie indicates a function which \"abort\"s on errors.\n */\n    int\nfunc_has_abort(\n    void    *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_flags & FC_ABORT;\n}\n\n\n/*\n * Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n * Don't do this when \"Func\" is already a partial that was bound\n * explicitly (pt_auto is FALSE).\n * Changes \"rettv\" in-place.\n * Returns the updated \"selfdict_in\".\n */\n    dict_T *\nmake_partial(dict_T *selfdict_in, typval_T *rettv)\n{\n    char_u\t*fname;\n    char_u\t*tofree = NULL;\n    ufunc_T\t*fp;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    int\t\terror;\n    dict_T\t*selfdict = selfdict_in;\n\n    if (rettv->v_type == VAR_PARTIAL && rettv->vval.v_partial->pt_func != NULL)\n\tfp = rettv->vval.v_partial->pt_func;\n    else\n    {\n\tfname = rettv->v_type == VAR_FUNC ? rettv->vval.v_string\n\t\t\t\t\t      : rettv->vval.v_partial->pt_name;\n\t// Translate \"s:func\" to the stored function name.\n\tfname = fname_trans_sid(fname, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE, NULL);\n\tvim_free(tofree);\n    }\n\n    if (fp != NULL && (fp->uf_flags & FC_DICT))\n    {\n\tpartial_T\t*pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt != NULL)\n\t{\n\t    pt->pt_refcount = 1;\n\t    pt->pt_dict = selfdict;\n\t    pt->pt_auto = TRUE;\n\t    selfdict = NULL;\n\t    if (rettv->v_type == VAR_FUNC)\n\t    {\n\t\t// Just a function: Take over the function name and use\n\t\t// selfdict.\n\t\tpt->pt_name = rettv->vval.v_string;\n\t    }\n\t    else\n\t    {\n\t\tpartial_T\t*ret_pt = rettv->vval.v_partial;\n\t\tint\t\ti;\n\n\t\t// Partial: copy the function name, use selfdict and copy\n\t\t// args.  Can't take over name or args, the partial might\n\t\t// be referenced elsewhere.\n\t\tif (ret_pt->pt_name != NULL)\n\t\t{\n\t\t    pt->pt_name = vim_strsave(ret_pt->pt_name);\n\t\t    func_ref(pt->pt_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    pt->pt_func = ret_pt->pt_func;\n\t\t    func_ptr_ref(pt->pt_func);\n\t\t}\n\t\tif (ret_pt->pt_argc > 0)\n\t\t{\n\t\t    pt->pt_argv = ALLOC_MULT(typval_T, ret_pt->pt_argc);\n\t\t    if (pt->pt_argv == NULL)\n\t\t\t// out of memory: drop the arguments\n\t\t\tpt->pt_argc = 0;\n\t\t    else\n\t\t    {\n\t\t\tpt->pt_argc = ret_pt->pt_argc;\n\t\t\tfor (i = 0; i < pt->pt_argc; i++)\n\t\t\t    copy_tv(&ret_pt->pt_argv[i], &pt->pt_argv[i]);\n\t\t    }\n\t\t}\n\t\tpartial_unref(ret_pt);\n\t    }\n\t    rettv->v_type = VAR_PARTIAL;\n\t    rettv->vval.v_partial = pt;\n\t}\n    }\n    return selfdict;\n}\n\n/*\n * Return the name of the executed function.\n */\n    char_u *\nfunc_name(void *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_name;\n}\n\n/*\n * Return the address holding the next breakpoint line for a funccall cookie.\n */\n    linenr_T *\nfunc_breakpoint(void *cookie)\n{\n    return &((funccall_T *)cookie)->breakpoint;\n}\n\n/*\n * Return the address holding the debug tick for a funccall cookie.\n */\n    int *\nfunc_dbg_tick(void *cookie)\n{\n    return &((funccall_T *)cookie)->dbg_tick;\n}\n\n/*\n * Return the nesting level for a funccall cookie.\n */\n    int\nfunc_level(void *cookie)\n{\n    return ((funccall_T *)cookie)->level;\n}\n\n/*\n * Return TRUE when a function was ended by a \":return\" command.\n */\n    int\ncurrent_func_returned(void)\n{\n    return current_funccal->returned;\n}\n\n    int\nfree_unref_funccal(int copyID, int testing)\n{\n    int\t\tdid_free = FALSE;\n    int\t\tdid_free_funccal = FALSE;\n    funccall_T\t*fc, **pfc;\n\n    for (pfc = &previous_funccal; *pfc != NULL; )\n    {\n\tif (can_free_funccal(*pfc, copyID))\n\t{\n\t    fc = *pfc;\n\t    *pfc = fc->caller;\n\t    free_funccal_contents(fc);\n\t    did_free = TRUE;\n\t    did_free_funccal = TRUE;\n\t}\n\telse\n\t    pfc = &(*pfc)->caller;\n    }\n    if (did_free_funccal)\n\t// When a funccal was freed some more items might be garbage\n\t// collected, so run again.\n\t(void)garbage_collect(testing);\n\n    return did_free;\n}\n\n/*\n * Get function call environment based on backtrace debug level\n */\n    static funccall_T *\nget_funccal(void)\n{\n    int\t\ti;\n    funccall_T\t*funccal;\n    funccall_T\t*temp_funccal;\n\n    funccal = current_funccal;\n    if (debug_backtrace_level > 0)\n    {\n\tfor (i = 0; i < debug_backtrace_level; i++)\n\t{\n\t    temp_funccal = funccal->caller;\n\t    if (temp_funccal)\n\t\tfunccal = temp_funccal;\n\t    else\n\t\t// backtrace level overflow. reset to max\n\t\tdebug_backtrace_level = i;\n\t}\n    }\n    return funccal;\n}\n\n/*\n * Return the hashtable used for local variables in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_local_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars.dv_hashtab;\n}\n\n/*\n * Return the l: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_local_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars_var;\n}\n\n/*\n * Return the hashtable used for argument in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_args_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars.dv_hashtab;\n}\n\n/*\n * Return the a: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_args_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars_var;\n}\n\n/*\n * List function variables, if there is a function.\n */\n    void\nlist_func_vars(int *first)\n{\n    if (current_funccal != NULL && current_funccal->l_vars.dv_refcount > 0)\n\tlist_hashtable_vars(&current_funccal->l_vars.dv_hashtab,\n\t\t\t\t\t\t\t   \"l:\", FALSE, first);\n}\n\n/*\n * If \"ht\" is the hashtable for local variables in the current funccal, return\n * the dict that contains it.\n * Otherwise return NULL.\n */\n    dict_T *\nget_current_funccal_dict(hashtab_T *ht)\n{\n    if (current_funccal != NULL\n\t    && ht == &current_funccal->l_vars.dv_hashtab)\n\treturn &current_funccal->l_vars;\n    return NULL;\n}\n\n/*\n * Search hashitem in parent scope.\n */\n    hashitem_T *\nfind_hi_in_scoped_ht(char_u *name, hashtab_T **pht)\n{\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    hashitem_T\t*hi = NULL;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n      return NULL;\n\n    // Search in parent scope, which can be referenced from a lambda.\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal != NULL)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    hi = hash_find(ht, varname);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t*pht = ht;\n\t\tbreak;\n\t    }\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return hi;\n}\n\n/*\n * Search variable in parent scope.\n */\n    dictitem_T *\nfind_var_in_scoped_ht(char_u *name, int no_autoload)\n{\n    dictitem_T\t*v = NULL;\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n\treturn NULL;\n\n    // Search in parent scope which is possible to reference from lambda\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    v = find_var_in_ht(ht, *name, varname, no_autoload);\n\t    if (v != NULL)\n\t\tbreak;\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return v;\n}\n\n/*\n * Set \"copyID + 1\" in previous_funccal and callers.\n */\n    int\nset_ref_in_previous_funccal(int copyID)\n{\n    funccall_T\t*fc;\n\n    for (fc = previous_funccal; fc != NULL; fc = fc->caller)\n    {\n\tfc->fc_copyID = copyID + 1;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID + 1, NULL))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n    static int\nset_ref_in_funccal(funccall_T *fc, int copyID)\n{\n    if (fc->fc_copyID != copyID)\n    {\n\tfc->fc_copyID = copyID;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID, NULL)\n\t\t|| set_ref_in_func(NULL, fc->func, copyID))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all local vars and arguments in the call stack.\n */\n    int\nset_ref_in_call_stack(int copyID)\n{\n    funccall_T\t\t*fc;\n    funccal_entry_T\t*entry;\n\n    for (fc = current_funccal; fc != NULL; fc = fc->caller)\n\tif (set_ref_in_funccal(fc, copyID))\n\t    return TRUE;\n\n    // Also go through the funccal_stack.\n    for (entry = funccal_stack; entry != NULL; entry = entry->next)\n\tfor (fc = entry->top_funccal; fc != NULL; fc = fc->caller)\n\t    if (set_ref_in_funccal(fc, copyID))\n\t\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all functions available by name.\n */\n    int\nset_ref_in_functions(int copyID)\n{\n    int\t\ttodo;\n    hashitem_T\t*hi = NULL;\n    ufunc_T\t*fp;\n\n    todo = (int)func_hashtab.ht_used;\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    fp = HI2UF(hi);\n\t    if (!func_name_refcount(fp->uf_name)\n\t\t\t\t\t  && set_ref_in_func(NULL, fp, copyID))\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all function arguments.\n */\n    int\nset_ref_in_func_args(int copyID)\n{\n    int i;\n\n    for (i = 0; i < funcargs.ga_len; ++i)\n\tif (set_ref_in_item(((typval_T **)funcargs.ga_data)[i],\n\t\t\t\t\t\t\t  copyID, NULL, NULL))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through function \"name\" with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID)\n{\n    ufunc_T\t*fp = fp_in;\n    funccall_T\t*fc;\n    int\t\terror = FCERR_NONE;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname;\n    int\t\tabort = FALSE;\n\n    if (name == NULL && fp_in == NULL)\n\treturn FALSE;\n\n    if (fp_in == NULL)\n    {\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE, NULL);\n    }\n    if (fp != NULL)\n    {\n\tfor (fc = fp->uf_scoped; fc != NULL; fc = fc->func->uf_scoped)\n\t    abort = abort || set_ref_in_funccal(fc, copyID);\n    }\n\n    vim_free(tofree);\n    return abort;\n}\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9compile.c: compiling a :def function\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n// Functions defined with :def are stored in this growarray.\n// They are never removed, so that they can be found by index.\n// Deleted functions have the df_deleted flag set.\ngarray_T def_functions = {0, 0, sizeof(dfunc_T), 50, NULL};\n\nstatic void delete_def_function_contents(dfunc_T *dfunc, int mark_deleted);\n\n/*\n * Lookup variable \"name\" in the local scope and return it in \"lvar\".\n * \"lvar->lv_from_outer\" is incremented accordingly.\n * If \"lvar\" is NULL only check if the variable can be found.\n * Return FAIL if not found.\n */\n    int\nlookup_local(char_u *name, size_t len, lvar_T *lvar, cctx_T *cctx)\n{\n    int\t    idx;\n    lvar_T  *lvp;\n\n    if (len == 0)\n\treturn FAIL;\n\n    // Find local in current function scope.\n    for (idx = 0; idx < cctx->ctx_locals.ga_len; ++idx)\n    {\n\tlvp = ((lvar_T *)cctx->ctx_locals.ga_data) + idx;\n\tif (STRNCMP(name, lvp->lv_name, len) == 0\n\t\t\t\t\t       && STRLEN(lvp->lv_name) == len)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\t*lvar = *lvp;\n\t\tlvar->lv_from_outer = 0;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    // Find local in outer function scope.\n    if (cctx->ctx_outer != NULL)\n    {\n\tif (lookup_local(name, len, lvar, cctx->ctx_outer) == OK)\n\t{\n\t    if (lvar != NULL)\n\t    {\n\t\tcctx->ctx_outer_used = TRUE;\n\t\t++lvar->lv_from_outer;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup an argument in the current function and an enclosing function.\n * Returns the argument index in \"idxp\"\n * Returns the argument type in \"type\"\n * Sets \"gen_load_outer\" to TRUE if found in outer scope.\n * Returns OK when found, FAIL otherwise.\n */\n    int\narg_exists(\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\t*idxp,\n\ttype_T\t**type,\n\tint\t*gen_load_outer,\n\tcctx_T\t*cctx)\n{\n    int\t    idx;\n    char_u  *va_name;\n\n    if (len == 0)\n\treturn FAIL;\n    for (idx = 0; idx < cctx->ctx_ufunc->uf_args_visible; ++idx)\n    {\n\tchar_u *arg = FUNCARG(cctx->ctx_ufunc, idx);\n\n\tif (STRNCMP(name, arg, len) == 0 && arg[len] == NUL)\n\t{\n\t    if (idxp != NULL)\n\t    {\n\t\t// Arguments are located above the frame pointer.  One further\n\t\t// if there is a vararg argument\n\t\t*idxp = idx - (cctx->ctx_ufunc->uf_args.ga_len\n\t\t\t\t\t\t\t    + STACK_FRAME_SIZE)\n\t\t\t      + (cctx->ctx_ufunc->uf_va_name != NULL ? -1 : 0);\n\n\t\tif (cctx->ctx_ufunc->uf_arg_types != NULL)\n\t\t    *type = cctx->ctx_ufunc->uf_arg_types[idx];\n\t\telse\n\t\t    *type = &t_any;\n\t    }\n\t    return OK;\n\t}\n    }\n\n    va_name = cctx->ctx_ufunc->uf_va_name;\n    if (va_name != NULL\n\t\t    && STRNCMP(name, va_name, len) == 0 && va_name[len] == NUL)\n    {\n\tif (idxp != NULL)\n\t{\n\t    // varargs is always the last argument\n\t    *idxp = -STACK_FRAME_SIZE - 1;\n\t    *type = cctx->ctx_ufunc->uf_va_type;\n\t}\n\treturn OK;\n    }\n\n    if (cctx->ctx_outer != NULL)\n    {\n\t// Lookup the name for an argument of the outer function.\n\tif (arg_exists(name, len, idxp, type, gen_load_outer, cctx->ctx_outer)\n\t\t\t\t\t\t\t\t\t == OK)\n\t{\n\t    if (gen_load_outer != NULL)\n\t\t++*gen_load_outer;\n\t    return OK;\n\t}\n    }\n\n    return FAIL;\n}\n\n/*\n * Lookup a script-local variable in the current script, possibly defined in a\n * block that contains the function \"cctx->ctx_ufunc\".\n * \"cctx\" is NULL at the script level.\n * If \"len\" is <= 0 \"name\" must be NUL terminated.\n * Return NULL when not found.\n */\n    static sallvar_T *\nfind_script_var(char_u *name, size_t len, cctx_T *cctx)\n{\n    scriptitem_T    *si = SCRIPT_ITEM(current_sctx.sc_sid);\n    hashitem_T\t    *hi;\n    int\t\t    cc;\n    sallvar_T\t    *sav;\n    ufunc_T\t    *ufunc;\n\n    // Find the list of all script variables with the right name.\n    if (len > 0)\n    {\n\tcc = name[len];\n\tname[len] = NUL;\n    }\n    hi = hash_find(&si->sn_all_vars.dv_hashtab, name);\n    if (len > 0)\n\tname[len] = cc;\n    if (HASHITEM_EMPTY(hi))\n\treturn NULL;\n\n    sav = HI2SAV(hi);\n    if (sav->sav_block_id == 0)\n\t// variable defined in the top script scope is always visible\n\treturn sav;\n\n    if (cctx == NULL)\n    {\n\t// Not in a function scope, find variable with block id equal to or\n\t// smaller than the current block id.\n\twhile (sav != NULL)\n\t{\n\t    if (sav->sav_block_id <= si->sn_current_block_id)\n\t\tbreak;\n\t    sav = sav->sav_next;\n\t}\n\treturn sav;\n    }\n\n    // Go over the variables with this name and find one that was visible\n    // from the function.\n    ufunc = cctx->ctx_ufunc;\n    while (sav != NULL)\n    {\n\tint idx;\n\n\t// Go over the blocks that this function was defined in.  If the\n\t// variable block ID matches it was visible to the function.\n\tfor (idx = 0; idx < ufunc->uf_block_depth; ++idx)\n\t    if (ufunc->uf_block_ids[idx] == sav->sav_block_id)\n\t\treturn sav;\n\tsav = sav->sav_next;\n    }\n\n    // Not found, variable was not visible.\n    return NULL;\n}\n\n/*\n * Return TRUE if the script context is Vim9 script.\n */\n    int\nscript_is_vim9()\n{\n    return SCRIPT_ITEM(current_sctx.sc_sid)->sn_version == SCRIPT_VERSION_VIM9;\n}\n\n/*\n * Lookup a variable (without s: prefix) in the current script.\n * \"cctx\" is NULL at the script level.\n * Returns OK or FAIL.\n */\n    int\nscript_var_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    if (current_sctx.sc_sid <= 0)\n\treturn FAIL;\n    if (script_is_vim9())\n    {\n\t// Check script variables that were visible where the function was\n\t// defined.\n\tif (find_script_var(name, len, cctx) != NULL)\n\t    return OK;\n    }\n    else\n    {\n\thashtab_T\t*ht = &SCRIPT_VARS(current_sctx.sc_sid);\n\tdictitem_T\t*di;\n\tint\t\tcc;\n\n\t// Check script variables that are currently visible\n\tcc = name[len];\n\tname[len] = NUL;\n\tdi = find_var_in_ht(ht, 0, name, TRUE);\n\tname[len] = cc;\n\tif (di != NULL)\n\t    return OK;\n    }\n\n    return FAIL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable or\n * imported.\n */\n    static int\nvariable_exists(char_u *name, size_t len, cctx_T *cctx)\n{\n    return (cctx != NULL\n\t\t&& (lookup_local(name, len, NULL, cctx) == OK\n\t\t    || arg_exists(name, len, NULL, NULL, NULL, cctx) == OK))\n\t    || script_var_exists(name, len, cctx) == OK\n\t    || find_imported(name, len, cctx) != NULL;\n}\n\n/*\n * Return TRUE if \"name\" is a local variable, argument, script variable,\n * imported or function.\n */\n    static int\nitem_exists(char_u *name, size_t len, int cmd UNUSED, cctx_T *cctx)\n{\n    int\t    is_global;\n    char_u  *p;\n\n    if (variable_exists(name, len, cctx))\n\treturn TRUE;\n\n    // This is similar to what is in lookup_scriptitem():\n    // Find a function, so that a following \"->\" works.\n    // Require \"(\" or \"->\" to follow, \"Cmd\" is a user command while \"Cmd()\" is\n    // a function call.\n    p = skipwhite(name + len);\n\n    if (name[len] == '(' || (p[0] == '-' && p[1] == '>'))\n    {\n\t// Do not check for an internal function, since it might also be a\n\t// valid command, such as \":split\" versus \"split()\".\n\t// Skip \"g:\" before a function name.\n\tis_global = (name[0] == 'g' && name[1] == ':');\n\treturn find_func(is_global ? name + 2 : name, is_global, cctx) != NULL;\n    }\n    return FALSE;\n}\n\n/*\n * Check if \"p[len]\" is already defined, either in script \"import_sid\" or in\n * compilation context \"cctx\".  \"cctx\" is NULL at the script level.\n * Does not check the global namespace.\n * If \"is_arg\" is TRUE the error message is for an argument name.\n * Return FAIL and give an error if it defined.\n */\n    int\ncheck_defined(char_u *p, size_t len, cctx_T *cctx, int is_arg)\n{\n    int\t\tc = p[len];\n    ufunc_T\t*ufunc = NULL;\n\n    // underscore argument is OK\n    if (len == 1 && *p == '_')\n\treturn OK;\n\n    if (script_var_exists(p, len, cctx) == OK)\n    {\n\tif (is_arg)\n\t    semsg(_(e_argument_already_declared_in_script_str), p);\n\telse\n\t    semsg(_(e_variable_already_declared_in_script_str), p);\n\treturn FAIL;\n    }\n\n    p[len] = NUL;\n    if ((cctx != NULL\n\t\t&& (lookup_local(p, len, NULL, cctx) == OK\n\t\t    || arg_exists(p, len, NULL, NULL, NULL, cctx) == OK))\n\t    || find_imported(p, len, cctx) != NULL\n\t    || (ufunc = find_func_even_dead(p, FALSE, cctx)) != NULL)\n    {\n\t// A local or script-local function can shadow a global function.\n\tif (ufunc == NULL || ((ufunc->uf_flags & FC_DEAD) == 0\n\t\t    && (!func_is_global(ufunc)\n\t\t\t\t\t     || (p[0] == 'g' && p[1] == ':'))))\n\t{\n\t    if (is_arg)\n\t\tsemsg(_(e_argument_name_shadows_existing_variable_str), p);\n\t    else\n\t\tsemsg(_(e_name_already_defined_str), p);\n\t    p[len] = c;\n\t    return FAIL;\n\t}\n    }\n    p[len] = c;\n    return OK;\n}\n\n\n/*\n * Return TRUE if \"actual\" could be \"expected\" and a runtime typecheck is to be\n * used.  Return FALSE if the types will never match.\n */\n    static int\nuse_typecheck(type_T *actual, type_T *expected)\n{\n    if (actual->tt_type == VAR_ANY\n\t    || actual->tt_type == VAR_UNKNOWN\n\t    || (actual->tt_type == VAR_FUNC\n\t\t&& (expected->tt_type == VAR_FUNC\n\t\t\t\t\t   || expected->tt_type == VAR_PARTIAL)\n\t\t&& (actual->tt_member == &t_any\n\t\t    || actual->tt_member == &t_unknown\n\t\t    || actual->tt_argcount < 0)\n\t\t&& (actual->tt_member == &t_unknown ||\n\t\t    (actual->tt_member == &t_void)\n\t\t\t\t\t == (expected->tt_member == &t_void))))\n\treturn TRUE;\n    if ((actual->tt_type == VAR_LIST || actual->tt_type == VAR_DICT)\n\t\t\t\t       && actual->tt_type == expected->tt_type)\n\t// This takes care of a nested list or dict.\n\treturn use_typecheck(actual->tt_member, expected->tt_member);\n    return FALSE;\n}\n\n/*\n * Check that\n * - \"actual\" matches \"expected\" type or\n * - \"actual\" is a type that can be \"expected\" type: add a runtime check; or\n * - return FAIL.\n * If \"actual_is_const\" is TRUE then the type won't change at runtime, do not\n * generate a TYPECHECK.\n */\n    static int\nneed_type_where(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\twhere_T\twhere,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    int ret;\n\n    if (expected == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n    {\n\t// Using \"0\", \"1\" or the result of an expression with \"&&\" or \"||\" as a\n\t// boolean is OK but requires a conversion.\n\tgenerate_2BOOL(cctx, FALSE, offset);\n\treturn OK;\n    }\n\n    ret = check_type_maybe(expected, actual, FALSE, where);\n    if (ret == OK)\n\treturn OK;\n\n    // If the actual type can be the expected type add a runtime check.\n    // If it's a constant a runtime check makes no sense.\n    if (!actual_is_const && ret == MAYBE && use_typecheck(actual, expected))\n    {\n\tgenerate_TYPECHECK(cctx, expected, offset, where.wt_index);\n\treturn OK;\n    }\n\n    if (!silent)\n\ttype_mismatch_where(expected, actual, where);\n    return FAIL;\n}\n\n    int\nneed_type(\n\ttype_T\t*actual,\n\ttype_T\t*expected,\n\tint\toffset,\n\tint\targ_idx,\n\tcctx_T\t*cctx,\n\tint\tsilent,\n\tint\tactual_is_const)\n{\n    where_T where = WHERE_INIT;\n\n    where.wt_index = arg_idx;\n    return need_type_where(actual, expected, offset, where,\n\t\t\t\t\t\tcctx, silent, actual_is_const);\n}\n\n/*\n * Reserve space for a local variable.\n * Return the variable or NULL if it failed.\n */\n    lvar_T *\nreserve_local(\n\tcctx_T\t*cctx,\n\tchar_u\t*name,\n\tsize_t\tlen,\n\tint\tisConst,\n\ttype_T\t*type)\n{\n    lvar_T  *lvar;\n    dfunc_T *dfunc;\n\n    if (arg_exists(name, len, NULL, NULL, NULL, cctx) == OK)\n    {\n\temsg_namelen(_(e_str_is_used_as_argument), name, (int)len);\n\treturn NULL;\n    }\n\n    if (GA_GROW_FAILS(&cctx->ctx_locals, 1))\n\treturn NULL;\n    lvar = ((lvar_T *)cctx->ctx_locals.ga_data) + cctx->ctx_locals.ga_len++;\n    CLEAR_POINTER(lvar);\n\n    // Every local variable uses the next entry on the stack.  We could re-use\n    // the last ones when leaving a scope, but then variables used in a closure\n    // might get overwritten.  To keep things simple do not re-use stack\n    // entries.  This is less efficient, but memory is cheap these days.\n    dfunc = ((dfunc_T *)def_functions.ga_data) + cctx->ctx_ufunc->uf_dfunc_idx;\n    lvar->lv_idx = dfunc->df_var_names.ga_len;\n\n    lvar->lv_name = vim_strnsave(name, len == 0 ? STRLEN(name) : len);\n    lvar->lv_const = isConst;\n    lvar->lv_type = type;\n\n    // Remember the name for debugging.\n    if (GA_GROW_FAILS(&dfunc->df_var_names, 1))\n\treturn NULL;\n    ((char_u **)dfunc->df_var_names.ga_data)[lvar->lv_idx] =\n\t\t\t\t\t\t    vim_strsave(lvar->lv_name);\n    ++dfunc->df_var_names.ga_len;\n\n    return lvar;\n}\n\n/*\n * If \"check_writable\" is ASSIGN_CONST give an error if the variable was\n * defined with :final or :const, if \"check_writable\" is ASSIGN_FINAL give an\n * error if the variable was defined with :const.\n */\n    static int\ncheck_item_writable(svar_T *sv, int check_writable, char_u *name)\n{\n    if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)\n\t    || (check_writable == ASSIGN_FINAL\n\t\t\t\t\t      && sv->sv_const == ASSIGN_CONST))\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Find \"name\" in script-local items of script \"sid\".\n * Pass \"check_writable\" to check_item_writable().\n * Returns the index in \"sn_var_vals\" if found.\n * If found but not in \"sn_var_vals\" returns -1.\n * If not found or the variable is not writable returns -2.\n */\n    int\nget_script_item_idx(int sid, char_u *name, int check_writable, cctx_T *cctx)\n{\n    hashtab_T\t    *ht;\n    dictitem_T\t    *di;\n    scriptitem_T    *si = SCRIPT_ITEM(sid);\n    svar_T\t    *sv;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn -1;\n    if (sid == current_sctx.sc_sid)\n    {\n\tsallvar_T *sav = find_script_var(name, 0, cctx);\n\n\tif (sav == NULL)\n\t    return -2;\n\tidx = sav->sav_var_vals_idx;\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (check_item_writable(sv, check_writable, name) == FAIL)\n\t    return -2;\n\treturn idx;\n    }\n\n    // First look the name up in the hashtable.\n    ht = &SCRIPT_VARS(sid);\n    di = find_var_in_ht(ht, 0, name, TRUE);\n    if (di == NULL)\n\treturn -2;\n\n    // Now find the svar_T index in sn_var_vals.\n    for (idx = 0; idx < si->sn_var_vals.ga_len; ++idx)\n    {\n\tsv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\tif (sv->sv_tv == &di->di_tv)\n\t{\n\t    if (check_item_writable(sv, check_writable, name) == FAIL)\n\t\treturn -2;\n\t    return idx;\n\t}\n    }\n    return -1;\n}\n\n/*\n * Find \"name\" in imported items of the current script or in \"cctx\" if not\n * NULL.\n */\n    imported_T *\nfind_imported(char_u *name, size_t len, cctx_T *cctx)\n{\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\treturn NULL;\n    if (cctx != NULL)\n\tfor (idx = 0; idx < cctx->ctx_imports.ga_len; ++idx)\n\t{\n\t    imported_T *import = ((imported_T *)cctx->ctx_imports.ga_data)\n\t\t\t\t\t\t\t\t\t + idx;\n\n\t    if (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t\t : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t\treturn import;\n\t}\n\n    return find_imported_in_script(name, len, current_sctx.sc_sid);\n}\n\n    imported_T *\nfind_imported_in_script(char_u *name, size_t len, int sid)\n{\n    scriptitem_T    *si;\n    int\t\t    idx;\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\n    si = SCRIPT_ITEM(sid);\n    for (idx = 0; idx < si->sn_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)si->sn_imports.ga_data) + idx;\n\n\tif (len == 0 ? STRCMP(name, import->imp_name) == 0\n\t\t     : STRLEN(import->imp_name) == len\n\t\t\t\t  && STRNCMP(name, import->imp_name, len) == 0)\n\t    return import;\n    }\n    return NULL;\n}\n\n/*\n * Free all imported variables.\n */\n    static void\nfree_imported(cctx_T *cctx)\n{\n    int idx;\n\n    for (idx = 0; idx < cctx->ctx_imports.ga_len; ++idx)\n    {\n\timported_T *import = ((imported_T *)cctx->ctx_imports.ga_data) + idx;\n\n\tvim_free(import->imp_name);\n    }\n    ga_clear(&cctx->ctx_imports);\n}\n\n/*\n * Called when checking for a following operator at \"arg\".  When the rest of\n * the line is empty or only a comment, peek the next line.  If there is a next\n * line return a pointer to it and set \"nextp\".\n * Otherwise skip over white space.\n */\n    char_u *\nmay_peek_next_line(cctx_T *cctx, char_u *arg, char_u **nextp)\n{\n    char_u *p = skipwhite(arg);\n\n    *nextp = NULL;\n    if (*p == NUL || (VIM_ISWHITE(*arg) && vim9_comment_start(p)))\n    {\n\t*nextp = peek_next_line_from_context(cctx);\n\tif (*nextp != NULL)\n\t    return *nextp;\n    }\n    return p;\n}\n\n/*\n * Return a pointer to the next line that isn't empty or only contains a\n * comment. Skips over white space.\n * Returns NULL if there is none.\n */\n    char_u *\npeek_next_line_from_context(cctx_T *cctx)\n{\n    int lnum = cctx->ctx_lnum;\n\n    while (++lnum < cctx->ctx_ufunc->uf_lines.ga_len)\n    {\n\tchar_u *line = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[lnum];\n\tchar_u *p;\n\n\t// ignore NULLs inserted for continuation lines\n\tif (line != NULL)\n\t{\n\t    p = skipwhite(line);\n\t    if (vim9_bad_comment(p))\n\t\treturn NULL;\n\t    if (*p != NUL && !vim9_comment_start(p))\n\t\treturn p;\n\t}\n    }\n    return NULL;\n}\n\n/*\n * Get the next line of the function from \"cctx\".\n * Skips over empty lines.  Skips over comment lines if \"skip_comment\" is TRUE.\n * Returns NULL when at the end.\n */\n    char_u *\nnext_line_from_context(cctx_T *cctx, int skip_comment)\n{\n    char_u\t*line;\n\n    do\n    {\n\t++cctx->ctx_lnum;\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len)\n\t{\n\t    line = NULL;\n\t    break;\n\t}\n\tline = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\tcctx->ctx_line_start = line;\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n    } while (line == NULL || *skipwhite(line) == NUL\n\t\t     || (skip_comment && vim9_comment_start(skipwhite(line))));\n    return line;\n}\n\n/*\n * Skip over white space at \"whitep\" and assign to \"*arg\".\n * If \"*arg\" is at the end of the line, advance to the next line.\n * Also when \"whitep\" points to white space and \"*arg\" is on a \"#\".\n * Return FAIL if beyond the last line, \"*arg\" is unmodified then.\n */\n    int\nmay_get_next_line(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    *arg = skipwhite(whitep);\n    if (vim9_bad_comment(*arg))\n\treturn FAIL;\n    if (**arg == NUL || (VIM_ISWHITE(*whitep) && vim9_comment_start(*arg)))\n    {\n\tchar_u *next = next_line_from_context(cctx, TRUE);\n\n\tif (next == NULL)\n\t    return FAIL;\n\t*arg = skipwhite(next);\n    }\n    return OK;\n}\n\n/*\n * Idem, and give an error when failed.\n */\n    int\nmay_get_next_line_error(char_u *whitep, char_u **arg, cctx_T *cctx)\n{\n    if (may_get_next_line(whitep, arg, cctx) == FAIL)\n    {\n\tSOURCING_LNUM = cctx->ctx_lnum + 1;\n\temsg(_(e_line_incomplete));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Get a line from the compilation context, compatible with exarg_T getline().\n * Return a pointer to the line in allocated memory.\n * Return NULL for end-of-file or some error.\n */\n    static char_u *\nexarg_getline(\n\tint c UNUSED,\n\tvoid *cookie,\n\tint indent UNUSED,\n\tgetline_opt_T options UNUSED)\n{\n    cctx_T  *cctx = (cctx_T *)cookie;\n    char_u  *p;\n\n    for (;;)\n    {\n\tif (cctx->ctx_lnum >= cctx->ctx_ufunc->uf_lines.ga_len - 1)\n\t    return NULL;\n\t++cctx->ctx_lnum;\n\tp = ((char_u **)cctx->ctx_ufunc->uf_lines.ga_data)[cctx->ctx_lnum];\n\t// Comment lines result in NULL pointers, skip them.\n\tif (p != NULL)\n\t    return vim_strsave(p);\n    }\n}\n\n    void\nfill_exarg_from_cctx(exarg_T *eap, cctx_T *cctx)\n{\n    eap->getline = exarg_getline;\n    eap->cookie = cctx;\n}\n\n/*\n * Return TRUE if \"ufunc\" should be compiled, taking into account whether\n * \"profile\" indicates profiling is to be done.\n */\n    int\nfunc_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)\n{\n    switch (ufunc->uf_def_status)\n    {\n\tcase UF_TO_BE_COMPILED:\n\t    return TRUE;\n\n\tcase UF_COMPILED:\n\t{\n\t    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t    switch (compile_type)\n\t    {\n\t\tcase CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t    return dfunc->df_instr_prof == NULL;\n#endif\n\t\tcase CT_NONE:\n\t\t    return dfunc->df_instr == NULL;\n\t\tcase CT_DEBUG:\n\t\t    return dfunc->df_instr_debug == NULL;\n\t    }\n\t}\n\n\tcase UF_NOT_COMPILED:\n\tcase UF_COMPILE_ERROR:\n\tcase UF_COMPILING:\n\t    break;\n    }\n    return FALSE;\n}\n\n/*\n * Compile a nested :def command.\n */\n    static char_u *\ncompile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n\tif (*name_end == '/')\n\t    ++name_end;\n\tset_nextcmd(eap, name_end);\n    }\n    if (name_end == name_start || *skipwhite(name_end) != '(')\n    {\n\tif (!ends_excmd2(name_start, name_end))\n\t{\n\t    semsg(_(e_invalid_command_str), eap->cmd);\n\t    return NULL;\n\t}\n\n\t// \"def\" or \"def Name\": list functions\n\tif (generate_DEF(cctx, name_start, name_end - name_start) == FAIL)\n\t    return NULL;\n\treturn eap->nextcmd == NULL ? (char_u *)\"\" : eap->nextcmd;\n    }\n\n    // Only g:Func() can use a namespace.\n    if (name_start[1] == ':' && !is_global)\n    {\n\tsemsg(_(e_namespace_not_supported_str), name_start);\n\treturn NULL;\n    }\n    if (check_defined(name_start, name_end - name_start, cctx, FALSE) == FAIL)\n\treturn NULL;\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    // This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, lines_to_free);\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n    if (eap->nextcmd != NULL)\n    {\n\tsemsg(_(e_text_found_after_str_str),\n\t      eap->cmdidx == CMD_def ? \"enddef\" : \"endfunction\", eap->nextcmd);\n\tr = FAIL;\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\tint block_depth = cctx->ctx_ufunc->uf_block_depth;\n\n\tufunc->uf_block_ids = ALLOC_MULT(int, block_depth);\n\tif (ufunc->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids,\n\t\t\t\t\t\t    sizeof(int) * block_depth);\n\t    ufunc->uf_block_depth = block_depth;\n\t}\n    }\n\n    compile_type = COMPILE_TYPE(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}\n\n/*\n * Return the length of an assignment operator, or zero if there isn't one.\n */\n    int\nassignment_len(char_u *p, int *heredoc)\n{\n    if (*p == '=')\n    {\n\tif (p[1] == '<' && p[2] == '<')\n\t{\n\t    *heredoc = TRUE;\n\t    return 3;\n\t}\n\treturn 1;\n    }\n    if (vim_strchr((char_u *)\"+-*/%\", *p) != NULL && p[1] == '=')\n\treturn 2;\n    if (STRNCMP(p, \"..=\", 3) == 0)\n\treturn 3;\n    return 0;\n}\n\n/*\n * Generate the load instruction for \"name\".\n */\n    static void\ngenerate_loadvar(\n\tcctx_T\t\t*cctx,\n\tassign_dest_T\tdest,\n\tchar_u\t\t*name,\n\tlvar_T\t\t*lvar,\n\ttype_T\t\t*type)\n{\n    switch (dest)\n    {\n\tcase dest_option:\n\tcase dest_func_option:\n\t    generate_LOAD(cctx, ISN_LOADOPT, 0, name, type);\n\t    break;\n\tcase dest_global:\n\t    if (vim_strchr(name, AUTOLOAD_CHAR) == NULL)\n\t\tgenerate_LOAD(cctx, ISN_LOADG, 0, name + 2, type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOADAUTO, 0, name, type);\n\t    break;\n\tcase dest_buffer:\n\t    generate_LOAD(cctx, ISN_LOADB, 0, name + 2, type);\n\t    break;\n\tcase dest_window:\n\t    generate_LOAD(cctx, ISN_LOADW, 0, name + 2, type);\n\t    break;\n\tcase dest_tab:\n\t    generate_LOAD(cctx, ISN_LOADT, 0, name + 2, type);\n\t    break;\n\tcase dest_script:\n\t    compile_load_scriptvar(cctx,\n\t\t    name + (name[1] == ':' ? 2 : 0), NULL, NULL, TRUE);\n\t    break;\n\tcase dest_env:\n\t    // Include $ in the name here\n\t    generate_LOAD(cctx, ISN_LOADENV, 0, name, type);\n\t    break;\n\tcase dest_reg:\n\t    generate_LOAD(cctx, ISN_LOADREG, name[1], NULL, &t_string);\n\t    break;\n\tcase dest_vimvar:\n\t    generate_LOADV(cctx, name + 2, TRUE);\n\t    break;\n\tcase dest_local:\n\t    if (lvar->lv_from_outer > 0)\n\t\tgenerate_LOADOUTER(cctx, lvar->lv_idx, lvar->lv_from_outer,\n\t\t\t\t\t\t\t\t\t type);\n\t    else\n\t\tgenerate_LOAD(cctx, ISN_LOAD, lvar->lv_idx, NULL, type);\n\t    break;\n\tcase dest_expr:\n\t    // list or dict value should already be on the stack.\n\t    break;\n    }\n}\n\n/*\n * Skip over \"[expr]\" or \".member\".\n * Does not check for any errors.\n */\n    static char_u *\nskip_index(char_u *start)\n{\n    char_u *p = start;\n\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\t(void)skip_expr(&p, NULL);\n\tp = skipwhite(p);\n\tif (*p == ']')\n\t    return p + 1;\n\treturn p;\n    }\n    // if (*p == '.')\n    return to_name_end(p + 1, TRUE);\n}\n\n    void\nvim9_declare_error(char_u *name)\n{\n    char *scope = \"\";\n\n    switch (*name)\n    {\n\tcase 'g': scope = _(\"global\"); break;\n\tcase 'b': scope = _(\"buffer\"); break;\n\tcase 'w': scope = _(\"window\"); break;\n\tcase 't': scope = _(\"tab\"); break;\n\tcase 'v': scope = \"v:\"; break;\n\tcase '$': semsg(_(e_cannot_declare_an_environment_variable), name);\n\t\t  return;\n\tcase '&': semsg(_(e_cannot_declare_an_option), name);\n\t\t  return;\n\tcase '@': semsg(_(e_cannot_declare_a_register_str), name);\n\t\t  return;\n\tdefault: return;\n    }\n    semsg(_(e_cannot_declare_a_scope_variable), scope, name);\n}\n\n/*\n * For one assignment figure out the type of destination.  Return it in \"dest\".\n * When not recognized \"dest\" is not set.\n * For an option \"option_scope\" is set.\n * For a v:var \"vimvaridx\" is set.\n * \"type\" is set to the destination type if known, unchanted otherwise.\n * Return FAIL if an error message was given.\n */\n    int\nget_var_dest(\n\tchar_u\t\t*name,\n\tassign_dest_T\t*dest,\n\tint\t\tcmdidx,\n\tint\t\t*option_scope,\n\tint\t\t*vimvaridx,\n\ttype_T\t\t**type,\n\tcctx_T\t\t*cctx)\n{\n    char_u *p;\n\n    if (*name == '&')\n    {\n\tint\t\tcc;\n\tlong\t\tnumval;\n\tgetoption_T\topt_type;\n\tint\t\topt_p_flags;\n\n\t*dest = dest_option;\n\tif (cmdidx == CMD_final || cmdidx == CMD_const)\n\t{\n\t    emsg(_(e_cannot_lock_option));\n\t    return FAIL;\n\t}\n\tp = name;\n\tp = find_option_end(&p, option_scope);\n\tif (p == NULL)\n\t{\n\t    // cannot happen?\n\t    emsg(_(e_unexpected_characters_in_assignment));\n\t    return FAIL;\n\t}\n\tcc = *p;\n\t*p = NUL;\n\topt_type = get_option_value(skip_option_env_lead(name),\n\t\t\t\t   &numval, NULL, &opt_p_flags, *option_scope);\n\t*p = cc;\n\tswitch (opt_type)\n\t{\n\t    case gov_unknown:\n\t\t    semsg(_(e_unknown_option_str), name);\n\t\t    return FAIL;\n\t    case gov_string:\n\t    case gov_hidden_string:\n\t\t    if (opt_p_flags & P_FUNC)\n\t\t    {\n\t\t\t// might be a Funcref, check the type later\n\t\t\t*type = &t_any;\n\t\t\t*dest = dest_func_option;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t*type = &t_string;\n\t\t    }\n\t\t    break;\n\t    case gov_bool:\n\t    case gov_hidden_bool:\n\t\t    *type = &t_bool;\n\t\t    break;\n\t    case gov_number:\n\t    case gov_hidden_number:\n\t\t    *type = &t_number;\n\t\t    break;\n\t}\n    }\n    else if (*name == '$')\n    {\n\t*dest = dest_env;\n\t*type = &t_string;\n    }\n    else if (*name == '@')\n    {\n\tif (name[1] != '@'\n\t\t\t&& (!valid_yank_reg(name[1], FALSE) || name[1] == '.'))\n\t{\n\t    emsg_invreg(name[1]);\n\t    return FAIL;\n\t}\n\t*dest = dest_reg;\n\t*type = name[1] == '#' ? &t_number_or_string : &t_string;\n    }\n    else if (STRNCMP(name, \"g:\", 2) == 0)\n    {\n\t*dest = dest_global;\n    }\n    else if (STRNCMP(name, \"b:\", 2) == 0)\n    {\n\t*dest = dest_buffer;\n    }\n    else if (STRNCMP(name, \"w:\", 2) == 0)\n    {\n\t*dest = dest_window;\n    }\n    else if (STRNCMP(name, \"t:\", 2) == 0)\n    {\n\t*dest = dest_tab;\n    }\n    else if (STRNCMP(name, \"v:\", 2) == 0)\n    {\n\ttypval_T\t*vtv;\n\tint\t\tdi_flags;\n\n\t*vimvaridx = find_vim_var(name + 2, &di_flags);\n\tif (*vimvaridx < 0)\n\t{\n\t    semsg(_(e_variable_not_found_str), name);\n\t    return FAIL;\n\t}\n\t// We use the current value of \"sandbox\" here, is that OK?\n\tif (var_check_ro(di_flags, name, FALSE))\n\t    return FAIL;\n\t*dest = dest_vimvar;\n\tvtv = get_vim_var_tv(*vimvaridx);\n\t*type = typval2type_vimvar(vtv, cctx->ctx_type_list);\n    }\n    return OK;\n}\n\n    static int\nis_decl_command(int cmdidx)\n{\n    return cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_final || cmdidx == CMD_const;\n}\n\n/*\n * Figure out the LHS type and other properties for an assignment or one item\n * of \":unlet\" with an index.\n * Returns OK or FAIL.\n */\n    int\ncompile_lhs(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tcmdidx,\n\tint\theredoc,\n\tint\toplen,\n\tcctx_T\t*cctx)\n{\n    char_u\t*var_end;\n    int\t\tis_decl = is_decl_command(cmdidx);\n\n    CLEAR_POINTER(lhs);\n    lhs->lhs_dest = dest_local;\n    lhs->lhs_vimvaridx = -1;\n    lhs->lhs_scriptvar_idx = -1;\n\n    // \"dest_end\" is the end of the destination, including \"[expr]\" or\n    // \".name\".\n    // \"var_end\" is the end of the variable/option/etc. name.\n    lhs->lhs_dest_end = skip_var_one(var_start, FALSE);\n    if (*var_start == '@')\n\tvar_end = var_start + 2;\n    else\n    {\n\t// skip over the leading \"&\", \"&l:\", \"&g:\" and \"$\"\n\tvar_end = skip_option_env_lead(var_start);\n\tvar_end = to_name_end(var_end, TRUE);\n    }\n\n    // \"a: type\" is declaring variable \"a\" with a type, not dict \"a:\".\n    if (is_decl && lhs->lhs_dest_end == var_start + 2\n\t\t\t\t\t       && lhs->lhs_dest_end[-1] == ':')\n\t--lhs->lhs_dest_end;\n    if (is_decl && var_end == var_start + 2 && var_end[-1] == ':')\n\t--var_end;\n    lhs->lhs_end = lhs->lhs_dest_end;\n\n    // compute the length of the destination without \"[expr]\" or \".name\"\n    lhs->lhs_varlen = var_end - var_start;\n    lhs->lhs_varlen_total = lhs->lhs_varlen;\n    lhs->lhs_name = vim_strnsave(var_start, lhs->lhs_varlen);\n    if (lhs->lhs_name == NULL)\n\treturn FAIL;\n\n    if (lhs->lhs_dest_end > var_start + lhs->lhs_varlen)\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tlhs->lhs_has_index = TRUE;\n\n    if (heredoc)\n\tlhs->lhs_type = &t_list_string;\n    else\n\tlhs->lhs_type = &t_any;\n\n    if (cctx->ctx_skip != SKIP_YES)\n    {\n\tint\t    declare_error = FALSE;\n\n\tif (get_var_dest(lhs->lhs_name, &lhs->lhs_dest, cmdidx,\n\t\t\t\t      &lhs->lhs_opt_flags, &lhs->lhs_vimvaridx,\n\t\t\t\t\t\t &lhs->lhs_type, cctx) == FAIL)\n\t    return FAIL;\n\tif (lhs->lhs_dest != dest_local\n\t\t\t\t && cmdidx != CMD_const && cmdidx != CMD_final)\n\t{\n\t    // Specific kind of variable recognized.\n\t    declare_error = is_decl;\n\t}\n\telse\n\t{\n\t    // No specific kind of variable recognized, just a name.\n\t    if (check_reserved_name(lhs->lhs_name) == FAIL)\n\t\treturn FAIL;\n\n\t    if (lookup_local(var_start, lhs->lhs_varlen,\n\t\t\t\t\t     &lhs->lhs_local_lvar, cctx) == OK)\n\t\tlhs->lhs_lvar = &lhs->lhs_local_lvar;\n\t    else\n\t    {\n\t\tCLEAR_FIELD(lhs->lhs_arg_lvar);\n\t\tif (arg_exists(var_start, lhs->lhs_varlen,\n\t\t\t &lhs->lhs_arg_lvar.lv_idx, &lhs->lhs_arg_lvar.lv_type,\n\t\t\t    &lhs->lhs_arg_lvar.lv_from_outer, cctx) == OK)\n\t\t{\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tsemsg(_(e_str_is_used_as_argument), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    lhs->lhs_lvar = &lhs->lhs_arg_lvar;\n\t\t}\n\t    }\n\t    if (lhs->lhs_lvar != NULL)\n\t    {\n\t\tif (is_decl)\n\t\t{\n\t\t    semsg(_(e_variable_already_declared), lhs->lhs_name);\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tint script_namespace = lhs->lhs_varlen > 1\n\t\t\t\t       && STRNCMP(var_start, \"s:\", 2) == 0;\n\t\tint script_var = (script_namespace\n\t\t\t? script_var_exists(var_start + 2, lhs->lhs_varlen - 2,\n\t\t\t\t\t\t\t\t\t  cctx)\n\t\t\t  : script_var_exists(var_start, lhs->lhs_varlen,\n\t\t\t\t\t\t\t\t  cctx)) == OK;\n\t\timported_T  *import =\n\t\t\t       find_imported(var_start, lhs->lhs_varlen, cctx);\n\n\t\tif (script_namespace || script_var || import != NULL)\n\t\t{\n\t\t    char_u\t*rawname = lhs->lhs_name\n\t\t\t\t\t   + (lhs->lhs_name[1] == ':' ? 2 : 0);\n\n\t\t    if (is_decl)\n\t\t    {\n\t\t\tif (script_namespace)\n\t\t\t    semsg(_(e_cannot_declare_script_variable_in_function),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\telse\n\t\t\t    semsg(_(e_variable_already_declared_in_script_str),\n\t\t\t\t\t\t\t\tlhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    else if (cctx->ctx_ufunc->uf_script_ctx_version\n\t\t\t\t\t\t\t == SCRIPT_VERSION_VIM9\n\t\t\t\t    && script_namespace\n\t\t\t\t    && !script_var && import == NULL)\n\t\t    {\n\t\t\tsemsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t\t\treturn FAIL;\n\t\t    }\n\n\t\t    lhs->lhs_dest = dest_script;\n\n\t\t    // existing script-local variables should have a type\n\t\t    lhs->lhs_scriptvar_sid = current_sctx.sc_sid;\n\t\t    if (import != NULL)\n\t\t    {\n\t\t\tchar_u\t*dot = vim_strchr(var_start, '.');\n\t\t\tchar_u\t*p;\n\n\t\t\t// for an import the name is what comes after the dot\n\t\t\tif (dot == NULL)\n\t\t\t{\n\t\t\t    semsg(_(e_no_dot_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tp = skipwhite(dot + 1);\n\t\t\tvar_end = to_name_end(p, TRUE);\n\t\t\tif (var_end == p)\n\t\t\t{\n\t\t\t    semsg(_(e_missing_name_after_imported_name_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t\t\t    return FAIL;\n\t\t\t}\n\t\t\tvim_free(lhs->lhs_name);\n\t\t\tlhs->lhs_varlen = var_end - p;\n\t\t\tlhs->lhs_name = vim_strnsave(p, lhs->lhs_varlen);\n\t\t\tif (lhs->lhs_name == NULL)\n\t\t\t    return FAIL;\n\t\t\trawname = lhs->lhs_name;\n\t\t\tlhs->lhs_scriptvar_sid = import->imp_sid;\n\t\t\t// TODO: where do we check this name is exported?\n\n\t\t\t// Check if something follows: \"exp.var[idx]\" or\n\t\t\t// \"exp.var.key\".\n\t\t\tlhs->lhs_has_index = lhs->lhs_dest_end\n\t\t\t\t\t\t\t  > skipwhite(var_end);\n\t\t    }\n\t\t    if (SCRIPT_ID_VALID(lhs->lhs_scriptvar_sid))\n\t\t    {\n\t\t\t// Check writable only when no index follows.\n\t\t\tlhs->lhs_scriptvar_idx = get_script_item_idx(\n\t\t\t\t\t       lhs->lhs_scriptvar_sid, rawname,\n\t\t\t      lhs->lhs_has_index ? ASSIGN_FINAL : ASSIGN_CONST,\n\t\t\t\t\t\t\t\t\t cctx);\n\t\t\tif (lhs->lhs_scriptvar_idx >= 0)\n\t\t\t{\n\t\t\t    scriptitem_T *si = SCRIPT_ITEM(\n\t\t\t\t\t\t       lhs->lhs_scriptvar_sid);\n\t\t\t    svar_T\t *sv =\n\t\t\t\t\t    ((svar_T *)si->sn_var_vals.ga_data)\n\t\t\t\t\t\t      + lhs->lhs_scriptvar_idx;\n\t\t\t    lhs->lhs_type = sv->sv_type;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (check_defined(var_start, lhs->lhs_varlen, cctx, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    return FAIL;\n\t    }\n\t}\n\n\tif (declare_error)\n\t{\n\t    vim9_declare_error(lhs->lhs_name);\n\t    return FAIL;\n\t}\n    }\n\n    // handle \"a:name\" as a name, not index \"name\" in \"a\"\n    if (lhs->lhs_varlen > 1 || var_start[lhs->lhs_varlen] != ':')\n\tvar_end = lhs->lhs_dest_end;\n\n    if (lhs->lhs_dest != dest_option && lhs->lhs_dest != dest_func_option)\n    {\n\tif (is_decl && *var_end == ':')\n\t{\n\t    char_u *p;\n\n\t    // parse optional type: \"let var: type = expr\"\n\t    if (!VIM_ISWHITE(var_end[1]))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", var_end);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(var_end + 1);\n\t    lhs->lhs_type = parse_type(&p, cctx->ctx_type_list, TRUE);\n\t    if (lhs->lhs_type == NULL)\n\t\treturn FAIL;\n\t    lhs->lhs_has_type = TRUE;\n\t    lhs->lhs_end = p;\n\t}\n\telse if (lhs->lhs_lvar != NULL)\n\t    lhs->lhs_type = lhs->lhs_lvar->lv_type;\n    }\n\n    if (oplen == 3 && !heredoc\n\t\t   && lhs->lhs_dest != dest_global\n\t\t   && !lhs->lhs_has_index\n\t\t   && lhs->lhs_type->tt_type != VAR_STRING\n\t\t   && lhs->lhs_type->tt_type != VAR_ANY)\n    {\n\temsg(_(e_can_only_concatenate_to_string));\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_lvar == NULL && lhs->lhs_dest == dest_local\n\t\t\t\t\t\t && cctx->ctx_skip != SKIP_YES)\n    {\n\tif (oplen > 1 && !heredoc)\n\t{\n\t    // +=, /=, etc. require an existing variable\n\t    semsg(_(e_cannot_use_operator_on_new_variable), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\tif (!is_decl)\n\t{\n\t    semsg(_(e_unknown_variable_str), lhs->lhs_name);\n\t    return FAIL;\n\t}\n\n\t// Check the name is valid for a funcref.\n\tif ((lhs->lhs_type->tt_type == VAR_FUNC\n\t\t\t\t      || lhs->lhs_type->tt_type == VAR_PARTIAL)\n\t\t&& var_wrong_func_name(lhs->lhs_name, TRUE))\n\t    return FAIL;\n\n\t// New local variable.\n\tlhs->lhs_lvar = reserve_local(cctx, var_start, lhs->lhs_varlen,\n\t\t    cmdidx == CMD_final || cmdidx == CMD_const, lhs->lhs_type);\n\tif (lhs->lhs_lvar == NULL)\n\t    return FAIL;\n\tlhs->lhs_new_local = TRUE;\n    }\n\n    lhs->lhs_member_type = lhs->lhs_type;\n    if (lhs->lhs_has_index)\n    {\n\tchar_u\t*after = var_start + lhs->lhs_varlen;\n\tchar_u\t*p;\n\n\t// Something follows after the variable: \"var[idx]\" or \"var.key\".\n\tif (is_decl)\n\t{\n\t    emsg(_(e_cannot_use_index_when_declaring_variable));\n\t    return FAIL;\n\t}\n\n\t// Now: var_start[lhs->lhs_varlen] is '[' or '.'\n\t// Only the last index is used below, if there are others\n\t// before it generate code for the expression.  Thus for\n\t// \"ll[1][2]\" the expression is \"ll[1]\" and \"[2]\" is the index.\n\tfor (;;)\n\t{\n\t    p = skip_index(after);\n\t    if (*p != '[' && *p != '.')\n\t    {\n\t\tlhs->lhs_varlen_total = p - var_start;\n\t\tbreak;\n\t    }\n\t    after = p;\n\t}\n\tif (after > var_start + lhs->lhs_varlen)\n\t{\n\t    lhs->lhs_varlen = after - var_start;\n\t    lhs->lhs_dest = dest_expr;\n\t    // We don't know the type before evaluating the expression,\n\t    // use \"any\" until then.\n\t    lhs->lhs_type = &t_any;\n\t}\n\n\tif (lhs->lhs_type->tt_member == NULL)\n\t    lhs->lhs_member_type = &t_any;\n\telse\n\t    lhs->lhs_member_type = lhs->lhs_type->tt_member;\n    }\n    return OK;\n}\n\n/*\n * Figure out the LHS and check a few errors.\n */\n    int\ncompile_assign_lhs(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tcmdidx,\n\tint\tis_decl,\n\tint\theredoc,\n\tint\toplen,\n\tcctx_T\t*cctx)\n{\n    if (compile_lhs(var_start, lhs, cmdidx, heredoc, oplen, cctx) == FAIL)\n\treturn FAIL;\n\n    if (!lhs->lhs_has_index && lhs->lhs_lvar == &lhs->lhs_arg_lvar)\n    {\n\tsemsg(_(e_cannot_assign_to_argument), lhs->lhs_name);\n\treturn FAIL;\n    }\n    if (!is_decl && lhs->lhs_lvar != NULL\n\t\t\t   && lhs->lhs_lvar->lv_const && !lhs->lhs_has_index)\n    {\n\tsemsg(_(e_cannot_assign_to_constant), lhs->lhs_name);\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Return TRUE if \"lhs\" has a range index: \"[expr : expr]\".\n */\n    static int\nhas_list_index(char_u *idx_start, cctx_T *cctx)\n{\n    char_u  *p = idx_start;\n    int\t    save_skip;\n\n    if (*p != '[')\n\treturn FALSE;\n\n    p = skipwhite(p + 1);\n    if (*p == ':')\n\treturn TRUE;\n\n    save_skip = cctx->ctx_skip;\n    cctx->ctx_skip = SKIP_YES;\n    (void)compile_expr0(&p, cctx);\n    cctx->ctx_skip = save_skip;\n    return *skipwhite(p) == ':';\n}\n\n/*\n * For an assignment with an index, compile the \"idx\" in \"var[idx]\" or \"key\" in\n * \"var.key\".\n */\n    static int\ncompile_assign_index(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\t*range,\n\tcctx_T\t*cctx)\n{\n    size_t\tvarlen = lhs->lhs_varlen;\n    char_u\t*p;\n    int\t\tr = OK;\n    int\t\tneed_white_before = TRUE;\n    int\t\tempty_second;\n\n    p = var_start + varlen;\n    if (*p == '[')\n    {\n\tp = skipwhite(p + 1);\n\tif (*p == ':')\n\t{\n\t    // empty first index, push zero\n\t    r = generate_PUSHNR(cctx, 0);\n\t    need_white_before = FALSE;\n\t}\n\telse\n\t    r = compile_expr0(&p, cctx);\n\n\tif (r == OK && *skipwhite(p) == ':')\n\t{\n\t    // unlet var[idx : idx]\n\t    // blob[idx : idx] = value\n\t    *range = TRUE;\n\t    p = skipwhite(p);\n\t    empty_second = *skipwhite(p + 1) == ']';\n\t    if ((need_white_before && !IS_WHITE_OR_NUL(p[-1]))\n\t\t    || (!empty_second && !IS_WHITE_OR_NUL(p[1])))\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t      \":\", p);\n\t\treturn FAIL;\n\t    }\n\t    p = skipwhite(p + 1);\n\t    if (*p == ']')\n\t\t// empty second index, push \"none\"\n\t\tr = generate_PUSHSPEC(cctx, VVAL_NONE);\n\t    else\n\t\tr = compile_expr0(&p, cctx);\n\t}\n\n\tif (r == OK && *skipwhite(p) != ']')\n\t{\n\t    // this should not happen\n\t    emsg(_(e_missing_closing_square_brace));\n\t    r = FAIL;\n\t}\n    }\n    else // if (*p == '.')\n    {\n\tchar_u *key_end = to_name_end(p + 1, TRUE);\n\tchar_u *key = vim_strnsave(p + 1, key_end - p - 1);\n\n\tr = generate_PUSHS(cctx, &key);\n    }\n    return r;\n}\n\n/*\n * For a LHS with an index, load the variable to be indexed.\n */\n    static int\ncompile_load_lhs(\n\tlhs_T\t*lhs,\n\tchar_u\t*var_start,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    if (lhs->lhs_dest == dest_expr)\n    {\n\tsize_t\t    varlen = lhs->lhs_varlen;\n\tint\t    c = var_start[varlen];\n\tint\t    lines_len = cctx->ctx_ufunc->uf_lines.ga_len;\n\tchar_u\t    *p = var_start;\n\tint\t    res;\n\n\t// Evaluate \"ll[expr]\" of \"ll[expr][idx]\".  End the line with a NUL and\n\t// limit the lines array length to avoid skipping to a following line.\n\tvar_start[varlen] = NUL;\n\tcctx->ctx_ufunc->uf_lines.ga_len = cctx->ctx_lnum + 1;\n\tres = compile_expr0(&p, cctx);\n\tvar_start[varlen] = c;\n\tcctx->ctx_ufunc->uf_lines.ga_len = lines_len;\n\tif (res == FAIL || p != var_start + varlen)\n\t{\n\t    // this should not happen\n\t    if (res != FAIL)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    return FAIL;\n\t}\n\n\tlhs->lhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t// now we can properly check the type\n\tif (rhs_type != NULL && lhs->lhs_type->tt_member != NULL\n\t\t&& rhs_type != &t_void\n\t\t&& need_type(rhs_type, lhs->lhs_type->tt_member, -2, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t    return FAIL;\n    }\n    else\n\tgenerate_loadvar(cctx, lhs->lhs_dest, lhs->lhs_name,\n\t\t\t\t\t\t lhs->lhs_lvar, lhs->lhs_type);\n    return OK;\n}\n\n/*\n * Produce code for loading \"lhs\" and also take care of an index.\n * Return OK/FAIL.\n */\n    int\ncompile_load_lhs_with_index(lhs_T *lhs, char_u *var_start, cctx_T *cctx)\n{\n    compile_load_lhs(lhs, var_start, NULL, cctx);\n\n    if (lhs->lhs_has_index)\n    {\n\tint range = FALSE;\n\n\t// Get member from list or dict.  First compile the\n\t// index value.\n\tif (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\t    return FAIL;\n\tif (range)\n\t{\n\t    semsg(_(e_cannot_use_range_with_assignment_operator_str),\n\t\t\t\t\t\t\t\t    var_start);\n\t    return FAIL;\n\t}\n\n\t// Get the member.\n\tif (compile_member(FALSE, NULL, cctx) == FAIL)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Assignment to a list or dict member, or \":unlet\" for the item, using the\n * information in \"lhs\".\n * Returns OK or FAIL.\n */\n    int\ncompile_assign_unlet(\n\tchar_u\t*var_start,\n\tlhs_T\t*lhs,\n\tint\tis_assign,\n\ttype_T\t*rhs_type,\n\tcctx_T\t*cctx)\n{\n    vartype_T\tdest_type;\n    int\t\trange = FALSE;\n\n    if (compile_assign_index(var_start, lhs, &range, cctx) == FAIL)\n\treturn FAIL;\n    if (is_assign && range\n\t    && lhs->lhs_type->tt_type != VAR_LIST\n\t    && lhs->lhs_type != &t_blob\n\t    && lhs->lhs_type != &t_any)\n    {\n\tsemsg(_(e_cannot_use_range_with_assignment_str), var_start);\n\treturn FAIL;\n    }\n\n    if (lhs->lhs_type == &t_any)\n    {\n\t// Index on variable of unknown type: check at runtime.\n\tdest_type = VAR_ANY;\n    }\n    else\n    {\n\tdest_type = lhs->lhs_type->tt_type;\n\tif (dest_type == VAR_DICT && range)\n\t{\n\t    emsg(e_cannot_use_range_with_dictionary);\n\t    return FAIL;\n\t}\n\tif (dest_type == VAR_DICT\n\t\t\t      && may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t    return FAIL;\n\tif (dest_type == VAR_LIST || dest_type == VAR_BLOB)\n\t{\n\t    type_T *type;\n\n\t    if (range)\n\t    {\n\t\ttype = get_type_on_stack(cctx, 1);\n\t\tif (need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t    }\n\t    type = get_type_on_stack(cctx, 0);\n\t    if ((dest_type != VAR_BLOB && type != &t_special)\n\t\t    && need_type(type, &t_number,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n\n    // Load the dict or list.  On the stack we then have:\n    // - value (for assignment, not for :unlet)\n    // - index\n    // - for [a : b] second index\n    // - variable\n    if (compile_load_lhs(lhs, var_start, rhs_type, cctx) == FAIL)\n\treturn FAIL;\n\n    if (dest_type == VAR_LIST || dest_type == VAR_DICT\n\t\t\t      || dest_type == VAR_BLOB || dest_type == VAR_ANY)\n    {\n\tif (is_assign)\n\t{\n\t    if (range)\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_STORERANGE, 4) == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tisn_T\t*isn = generate_instr_drop(cctx, ISN_STOREINDEX, 3);\n\n\t\tif (isn == NULL)\n\t\t    return FAIL;\n\t\tisn->isn_arg.vartype = dest_type;\n\t    }\n\t}\n\telse if (range)\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETRANGE, 3) == NULL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    if (generate_instr_drop(cctx, ISN_UNLETINDEX, 2) == NULL)\n\t\treturn FAIL;\n\t}\n    }\n    else\n    {\n\temsg(_(e_indexable_type_required));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Compile declaration and assignment:\n * \"let name\"\n * \"var name = expr\"\n * \"final name = expr\"\n * \"const name = expr\"\n * \"name = expr\"\n * \"arg\" points to \"name\".\n * \"++arg\" and \"--arg\"\n * Return NULL for an error.\n * Return \"arg\" if it does not look like a variable list.\n */\n    static char_u *\ncompile_assignment(char_u *arg, exarg_T *eap, cmdidx_T cmdidx, cctx_T *cctx)\n{\n    char_u\t*var_start;\n    char_u\t*p;\n    char_u\t*end = arg;\n    char_u\t*ret = NULL;\n    int\t\tvar_count = 0;\n    int\t\tvar_idx;\n    int\t\tsemicolon = 0;\n    int\t\tdid_generate_slice = FALSE;\n    garray_T\t*instr = &cctx->ctx_instr;\n    char_u\t*op;\n    int\t\toplen = 0;\n    int\t\theredoc = FALSE;\n    int\t\tincdec = FALSE;\n    type_T\t*rhs_type = &t_any;\n    char_u\t*sp;\n    int\t\tis_decl = is_decl_command(cmdidx);\n    lhs_T\tlhs;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    // Skip over the \"var\" or \"[var, var]\" to get to any \"=\".\n    p = skip_var_list(arg, TRUE, &var_count, &semicolon, TRUE);\n    if (p == NULL)\n\treturn *arg == '[' ? arg : NULL;\n\n    lhs.lhs_name = NULL;\n\n    sp = p;\n    p = skipwhite(p);\n    op = p;\n    oplen = assignment_len(p, &heredoc);\n\n    if (var_count > 0 && oplen == 0)\n\t// can be something like \"[1, 2]->func()\"\n\treturn arg;\n\n    if (oplen > 0 && (!VIM_ISWHITE(*sp) || !IS_WHITE_OR_NUL(op[oplen])))\n    {\n\terror_white_both(op, oplen);\n\treturn NULL;\n    }\n    if (eap->cmdidx == CMD_increment || eap->cmdidx == CMD_decrement)\n    {\n\tif (VIM_ISWHITE(eap->cmd[2]))\n\t{\n\t    semsg(_(e_no_white_space_allowed_after_str_str),\n\t\t\t eap->cmdidx == CMD_increment ? \"++\" : \"--\", eap->cmd);\n\t    return NULL;\n\t}\n\top = (char_u *)(eap->cmdidx == CMD_increment ? \"+=\" : \"-=\");\n\toplen = 2;\n\tincdec = TRUE;\n    }\n\n    if (heredoc)\n    {\n\tlist_T\t   *l;\n\tlistitem_T *li;\n\n\t// [let] varname =<< [trim] {end}\n\teap->getline = exarg_getline;\n\teap->cookie = cctx;\n\tl = heredoc_get(eap, op + 3, FALSE);\n\tif (l == NULL)\n\t    return NULL;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    // Push each line and the create the list.\n\t    FOR_ALL_LIST_ITEMS(l, li)\n\t    {\n\t\tgenerate_PUSHS(cctx, &li->li_tv.vval.v_string);\n\t\tli->li_tv.vval.v_string = NULL;\n\t    }\n\t    generate_NEWLIST(cctx, l->lv_len);\n\t}\n\tlist_free(l);\n\tp += STRLEN(p);\n\tend = p;\n    }\n    else if (var_count > 0)\n    {\n\tchar_u *wp;\n\n\t// for \"[var, var] = expr\" evaluate the expression here, loop over the\n\t// list of variables below.\n\t// A line break may follow the \"=\".\n\n\twp = op + oplen;\n\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t    return FAIL;\n\tif (compile_expr0(&p, cctx) == FAIL)\n\t    return NULL;\n\tend = p;\n\n\tif (cctx->ctx_skip != SKIP_YES)\n\t{\n\t    type_T\t*stacktype;\n\t    int\t\tneeded_list_len;\n\t    int\t\tdid_check = FALSE;\n\n\t    stacktype = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t    if (stacktype->tt_type == VAR_VOID)\n\t    {\n\t\temsg(_(e_cannot_use_void_value));\n\t\tgoto theend;\n\t    }\n\t    if (need_type(stacktype, &t_list_any, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t    // If a constant list was used we can check the length right here.\n\t    needed_list_len = semicolon ? var_count - 1 : var_count;\n\t    if (instr->ga_len > 0)\n\t    {\n\t\tisn_T\t*isn = ((isn_T *)instr->ga_data) + instr->ga_len - 1;\n\n\t\tif (isn->isn_type == ISN_NEWLIST)\n\t\t{\n\t\t    did_check = TRUE;\n\t\t    if (semicolon ? isn->isn_arg.number < needed_list_len\n\t\t\t    : isn->isn_arg.number != needed_list_len)\n\t\t    {\n\t\t\tsemsg(_(e_expected_nr_items_but_got_nr),\n\t\t\t\t\t needed_list_len, isn->isn_arg.number);\n\t\t\tgoto theend;\n\t\t    }\n\t\t}\n\t    }\n\t    if (!did_check)\n\t\tgenerate_CHECKLEN(cctx, needed_list_len, semicolon);\n\t    if (stacktype->tt_member != NULL)\n\t\trhs_type = stacktype->tt_member;\n\t}\n    }\n\n    /*\n     * Loop over variables in \"[var, var] = expr\".\n     * For \"var = expr\" and \"let var: type\" this is done only once.\n     */\n    if (var_count > 0)\n\tvar_start = skipwhite(arg + 1);  // skip over the \"[\"\n    else\n\tvar_start = arg;\n    for (var_idx = 0; var_idx == 0 || var_idx < var_count; var_idx++)\n    {\n\tint\tinstr_count = -1;\n\tint\tsave_lnum;\n\tint\tskip_store = FALSE;\n\n\tif (var_start[0] == '_' && !eval_isnamec(var_start[1]))\n\t{\n\t    // Ignore underscore in \"[a, _, b] = list\".\n\t    if (var_count > 0)\n\t    {\n\t\tvar_start = skipwhite(var_start + 2);\n\t\tcontinue;\n\t    }\n\t    emsg(_(e_cannot_use_underscore_here));\n\t    goto theend;\n\t}\n\tvim_free(lhs.lhs_name);\n\n\t/*\n\t * Figure out the LHS type and other properties.\n\t */\n\tif (compile_assign_lhs(var_start, &lhs, cmdidx,\n\t\t\t\t\tis_decl, heredoc, oplen, cctx) == FAIL)\n\t    goto theend;\n\tif (heredoc)\n\t{\n\t    SOURCING_LNUM = start_lnum;\n\t    if (lhs.lhs_has_type\n\t\t    && need_type(&t_list_string, lhs.lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\tgoto theend;\n\t}\n\telse\n\t{\n\t    if (cctx->ctx_skip == SKIP_YES)\n\t    {\n\t\tif (oplen > 0 && var_count == 0)\n\t\t{\n\t\t    // skip over the \"=\" and the expression\n\t\t    p = skipwhite(op + oplen);\n\t\t    (void)compile_expr0(&p, cctx);\n\t\t}\n\t    }\n\t    else if (oplen > 0)\n\t    {\n\t\tint\tis_const = FALSE;\n\t\tchar_u\t*wp;\n\n\t\t// for \"+=\", \"*=\", \"..=\" etc. first load the current value\n\t\tif (*op != '='\n\t\t\t&& compile_load_lhs_with_index(&lhs, var_start,\n\t\t\t\t\t\t\t\t cctx) == FAIL)\n\t\t    goto theend;\n\n\t\t// For \"var = expr\" evaluate the expression.\n\t\tif (var_count == 0)\n\t\t{\n\t\t    int\tr;\n\n\t\t    // Compile the expression.\n\t\t    instr_count = instr->ga_len;\n\t\t    if (incdec)\n\t\t    {\n\t\t\tr = generate_PUSHNR(cctx, 1);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Temporarily hide the new local variable here, it is\n\t\t\t// not available to this expression.\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    --cctx->ctx_locals.ga_len;\n\t\t\twp = op + oplen;\n\t\t\tif (may_get_next_line_error(wp, &p, cctx) == FAIL)\n\t\t\t{\n\t\t\t    if (lhs.lhs_new_local)\n\t\t\t\t++cctx->ctx_locals.ga_len;\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\tr = compile_expr0_ext(&p, cctx, &is_const);\n\t\t\tif (lhs.lhs_new_local)\n\t\t\t    ++cctx->ctx_locals.ga_len;\n\t\t\tif (r == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse if (semicolon && var_idx == var_count - 1)\n\t\t{\n\t\t    // For \"[var; var] = expr\" get the rest of the list\n\t\t    did_generate_slice = TRUE;\n\t\t    if (generate_SLICE(cctx, var_count - 1) == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // For \"[var, var] = expr\" get the \"var_idx\" item from the\n\t\t    // list.\n\t\t    if (generate_GETITEM(cctx, var_idx, *op != '=') == FAIL)\n\t\t\tgoto theend;\n\t\t}\n\n\t\trhs_type = cctx->ctx_type_stack.ga_len == 0 ? &t_void\n\t\t\t\t\t\t  : get_type_on_stack(cctx, 0);\n\t\tif (lhs.lhs_lvar != NULL && (is_decl || !lhs.lhs_has_type))\n\t\t{\n\t\t    if ((rhs_type->tt_type == VAR_FUNC\n\t\t\t\t|| rhs_type->tt_type == VAR_PARTIAL)\n\t\t\t    && !lhs.lhs_has_index\n\t\t\t    && var_wrong_func_name(lhs.lhs_name, TRUE))\n\t\t\tgoto theend;\n\n\t\t    if (lhs.lhs_new_local && !lhs.lhs_has_type)\n\t\t    {\n\t\t\tif (rhs_type->tt_type == VAR_VOID)\n\t\t\t{\n\t\t\t    emsg(_(e_cannot_use_void_value));\n\t\t\t    goto theend;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // An empty list or dict has a &t_unknown member,\n\t\t\t    // for a variable that implies &t_any.\n\t\t\t    if (rhs_type == &t_list_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_list_any;\n\t\t\t    else if (rhs_type == &t_dict_empty)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_dict_any;\n\t\t\t    else if (rhs_type == &t_unknown)\n\t\t\t\tlhs.lhs_lvar->lv_type = &t_any;\n\t\t\t    else\n\t\t\t\tlhs.lhs_lvar->lv_type = rhs_type;\n\t\t\t}\n\t\t    }\n\t\t    else if (*op == '=')\n\t\t    {\n\t\t\ttype_T *use_type = lhs.lhs_lvar->lv_type;\n\t\t\twhere_T where = WHERE_INIT;\n\n\t\t\t// Without operator check type here, otherwise below.\n\t\t\t// Use the line number of the assignment.\n\t\t\tSOURCING_LNUM = start_lnum;\n\t\t\twhere.wt_index = var_count > 0 ? var_idx + 1 : 0;\n\t\t\twhere.wt_variable = var_count > 0;\n\t\t\t// If assigning to a list or dict member, use the\n\t\t\t// member type.  Not for \"list[:] =\".\n\t\t\tif (lhs.lhs_has_index\n\t\t\t\t&& !has_list_index(var_start + lhs.lhs_varlen,\n\t\t\t\t\t\t\t\t\t cctx))\n\t\t\t    use_type = lhs.lhs_member_type;\n\t\t\tif (need_type_where(rhs_type, use_type, -1, where,\n\t\t\t\t    cctx, FALSE, is_const) == FAIL)\n\t\t\t    goto theend;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    type_T *lhs_type = lhs.lhs_member_type;\n\n\t\t    // Special case: assigning to @# can use a number or a\n\t\t    // string.\n\t\t    // Also: can assign a number to a float.\n\t\t    if ((lhs_type == &t_number_or_string\n\t\t\t\t|| lhs_type == &t_float)\n\t\t\t    && rhs_type->tt_type == VAR_NUMBER)\n\t\t\tlhs_type = &t_number;\n\t\t    if (*p != '=' && need_type(rhs_type, lhs_type,\n\t\t\t\t\t    -1, 0, cctx, FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t\t}\n\t    }\n\t    else if (cmdidx == CMD_final)\n\t    {\n\t\temsg(_(e_final_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (cmdidx == CMD_const)\n\t    {\n\t\temsg(_(e_const_requires_a_value));\n\t\tgoto theend;\n\t    }\n\t    else if (!lhs.lhs_has_type || lhs.lhs_dest == dest_option\n\t\t\t\t\t   || lhs.lhs_dest == dest_func_option)\n\t    {\n\t\temsg(_(e_type_or_initialization_required));\n\t\tgoto theend;\n\t    }\n\t    else\n\t    {\n\t\t// variables are always initialized\n\t\tif (GA_GROW_FAILS(instr, 1))\n\t\t    goto theend;\n\t\tswitch (lhs.lhs_member_type->tt_type)\n\t\t{\n\t\t    case VAR_BOOL:\n\t\t\tgenerate_PUSHBOOL(cctx, VVAL_FALSE);\n\t\t\tbreak;\n\t\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t\tgenerate_PUSHF(cctx, 0.0);\n#endif\n\t\t\tbreak;\n\t\t    case VAR_STRING:\n\t\t\tgenerate_PUSHS(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_BLOB:\n\t\t\tgenerate_PUSHBLOB(cctx, blob_alloc());\n\t\t\tbreak;\n\t\t    case VAR_FUNC:\n\t\t\tgenerate_PUSHFUNC(cctx, NULL, &t_func_void);\n\t\t\tbreak;\n\t\t    case VAR_LIST:\n\t\t\tgenerate_NEWLIST(cctx, 0);\n\t\t\tbreak;\n\t\t    case VAR_DICT:\n\t\t\tgenerate_NEWDICT(cctx, 0);\n\t\t\tbreak;\n\t\t    case VAR_JOB:\n\t\t\tgenerate_PUSHJOB(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_CHANNEL:\n\t\t\tgenerate_PUSHCHANNEL(cctx, NULL);\n\t\t\tbreak;\n\t\t    case VAR_NUMBER:\n\t\t    case VAR_UNKNOWN:\n\t\t    case VAR_ANY:\n\t\t    case VAR_PARTIAL:\n\t\t    case VAR_VOID:\n\t\t    case VAR_INSTR:\n\t\t    case VAR_SPECIAL:  // cannot happen\n\t\t\t// This is skipped for local variables, they are\n\t\t\t// always initialized to zero.\n\t\t\tif (lhs.lhs_dest == dest_local)\n\t\t\t    skip_store = TRUE;\n\t\t\telse\n\t\t\t    generate_PUSHNR(cctx, 0);\n\t\t\tbreak;\n\t\t}\n\t    }\n\t    if (var_count == 0)\n\t\tend = p;\n\t}\n\n\t// no need to parse more when skipping\n\tif (cctx->ctx_skip == SKIP_YES)\n\t    break;\n\n\tif (oplen > 0 && *op != '=')\n\t{\n\t    type_T\t    *expected;\n\t    type_T\t    *stacktype = NULL;\n\n\t    if (*op == '.')\n\t    {\n\t\tif (may_generate_2STRING(-1, FALSE, cctx) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else\n\t    {\n\t\texpected = lhs.lhs_member_type;\n\t\tstacktype = get_type_on_stack(cctx, 0);\n\t\tif (\n#ifdef FEAT_FLOAT\n\t\t    // If variable is float operation with number is OK.\n\t\t    !(expected == &t_float && (stacktype == &t_number\n\t\t\t    || stacktype == &t_number_bool)) &&\n#endif\n\t\t    need_type(stacktype, expected, -1, 0, cctx,\n\t\t\t\t\t\t\t FALSE, FALSE) == FAIL)\n\t\t    goto theend;\n\t    }\n\n\t    if (*op == '.')\n\t    {\n\t\tif (generate_instr_drop(cctx, ISN_CONCAT, 1) == NULL)\n\t\t    goto theend;\n\t    }\n\t    else if (*op == '+')\n\t    {\n\t\tif (generate_add_instr(cctx,\n\t\t\t    operator_type(lhs.lhs_member_type, stacktype),\n\t\t\t\t       lhs.lhs_member_type, stacktype,\n\t\t\t\t\t\t\t  EXPR_APPEND) == FAIL)\n\t\t    goto theend;\n\t    }\n\t    else if (generate_two_op(cctx, op) == FAIL)\n\t\tgoto theend;\n\t}\n\n\t// Use the line number of the assignment for store instruction.\n\tsave_lnum = cctx->ctx_lnum;\n\tcctx->ctx_lnum = start_lnum - 1;\n\n\tif (lhs.lhs_has_index)\n\t{\n\t    // Use the info in \"lhs\" to store the value at the index in the\n\t    // list or dict.\n\t    if (compile_assign_unlet(var_start, &lhs, TRUE, rhs_type, cctx)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\telse\n\t{\n\t    if (is_decl && cmdidx == CMD_const && (lhs.lhs_dest == dest_script\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_global\n\t\t\t\t\t\t|| lhs.lhs_dest == dest_local))\n\t\t// \":const var\": lock the value, but not referenced variables\n\t\tgenerate_LOCKCONST(cctx);\n\n\t    if ((lhs.lhs_type->tt_type == VAR_DICT\n\t\t\t\t\t  || lhs.lhs_type->tt_type == VAR_LIST)\n\t\t    && lhs.lhs_type->tt_member != NULL\n\t\t    && lhs.lhs_type->tt_member != &t_unknown)\n\t\t// Set the type in the list or dict, so that it can be checked,\n\t\t// also in legacy script.\n\t\tgenerate_SETTYPE(cctx, lhs.lhs_type);\n\n\t    if (!skip_store && generate_store_lhs(cctx, &lhs,\n\t\t\t\t\t\t instr_count, is_decl) == FAIL)\n\t    {\n\t\tcctx->ctx_lnum = save_lnum;\n\t\tgoto theend;\n\t    }\n\t}\n\tcctx->ctx_lnum = save_lnum;\n\n\tif (var_idx + 1 < var_count)\n\t    var_start = skipwhite(lhs.lhs_end + 1);\n    }\n\n    // For \"[var, var] = expr\" drop the \"expr\" value.\n    // Also for \"[var, var; _] = expr\".\n    if (var_count > 0 && (!semicolon || !did_generate_slice))\n    {\n\tif (generate_instr_drop(cctx, ISN_DROP, 1) == NULL)\n\t    goto theend;\n    }\n\n    ret = skipwhite(end);\n\ntheend:\n    vim_free(lhs.lhs_name);\n    return ret;\n}\n\n/*\n * Check for an assignment at \"eap->cmd\", compile it if found.\n * Return NOTDONE if there is none, FAIL for failure, OK if done.\n */\n    static int\nmay_compile_assignment(exarg_T *eap, char_u **line, cctx_T *cctx)\n{\n    char_u  *pskip;\n    char_u  *p;\n\n    // Assuming the command starts with a variable or function name,\n    // find what follows.\n    // Skip over \"var.member\", \"var[idx]\" and the like.\n    // Also \"&opt = val\", \"$ENV = val\" and \"@r = val\".\n    pskip = (*eap->cmd == '&' || *eap->cmd == '$' || *eap->cmd == '@')\n\t\t\t\t\t\t ? eap->cmd + 1 : eap->cmd;\n    p = to_name_end(pskip, TRUE);\n    if (p > eap->cmd && *p != NUL)\n    {\n\tchar_u *var_end;\n\tint\toplen;\n\tint\theredoc;\n\n\tif (eap->cmd[0] == '@')\n\t    var_end = eap->cmd + 2;\n\telse\n\t    var_end = find_name_end(pskip, NULL, NULL,\n\t\t\t\t\tFNE_CHECK_START | FNE_INCL_BR);\n\toplen = assignment_len(skipwhite(var_end), &heredoc);\n\tif (oplen > 0)\n\t{\n\t    size_t len = p - eap->cmd;\n\n\t    // Recognize an assignment if we recognize the variable\n\t    // name:\n\t    // \"g:var = expr\"\n\t    // \"local = expr\"  where \"local\" is a local var.\n\t    // \"script = expr\"  where \"script\" is a script-local var.\n\t    // \"import = expr\"  where \"import\" is an imported var\n\t    // \"&opt = expr\"\n\t    // \"$ENV = expr\"\n\t    // \"@r = expr\"\n\t    if (*eap->cmd == '&'\n\t\t    || *eap->cmd == '$'\n\t\t    || *eap->cmd == '@'\n\t\t    || ((len) > 2 && eap->cmd[1] == ':')\n\t\t    || variable_exists(eap->cmd, len, cctx))\n\t    {\n\t\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\t\tif (*line == NULL || *line == eap->cmd)\n\t\t    return FAIL;\n\t\treturn OK;\n\t    }\n\t}\n    }\n\n    if (*eap->cmd == '[')\n    {\n\t// [var, var] = expr\n\t*line = compile_assignment(eap->cmd, eap, CMD_SIZE, cctx);\n\tif (*line == NULL)\n\t    return FAIL;\n\tif (*line != eap->cmd)\n\t    return OK;\n    }\n    return NOTDONE;\n}\n\n/*\n * Check if arguments of \"ufunc\" shadow variables in \"cctx\".\n * Return OK or FAIL.\n */\n    static int\ncheck_args_shadowing(ufunc_T *ufunc, cctx_T *cctx)\n{\n    int\t    i;\n    char_u  *arg;\n    int\t    r = OK;\n\n    // Make sure arguments are not found when compiling a second time.\n    ufunc->uf_args_visible = 0;\n\n    // Check for arguments shadowing variables from the context.\n    for (i = 0; i < ufunc->uf_args.ga_len; ++i)\n    {\n\targ = ((char_u **)(ufunc->uf_args.ga_data))[i];\n\tif (check_defined(arg, STRLEN(arg), cctx, TRUE) == FAIL)\n\t{\n\t    r = FAIL;\n\t    break;\n\t}\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n    return r;\n}\n\n\n/*\n * Add a function to the list of :def functions.\n * This sets \"ufunc->uf_dfunc_idx\" but the function isn't compiled yet.\n */\n    static int\nadd_def_function(ufunc_T *ufunc)\n{\n    dfunc_T *dfunc;\n\n    if (def_functions.ga_len == 0)\n    {\n\t// The first position is not used, so that a zero uf_dfunc_idx means it\n\t// wasn't set.\n\tif (GA_GROW_FAILS(&def_functions, 1))\n\t    return FAIL;\n\t++def_functions.ga_len;\n    }\n\n    // Add the function to \"def_functions\".\n    if (GA_GROW_FAILS(&def_functions, 1))\n\treturn FAIL;\n    dfunc = ((dfunc_T *)def_functions.ga_data) + def_functions.ga_len;\n    CLEAR_POINTER(dfunc);\n    dfunc->df_idx = def_functions.ga_len;\n    ufunc->uf_dfunc_idx = dfunc->df_idx;\n    dfunc->df_ufunc = ufunc;\n    dfunc->df_name = vim_strsave(ufunc->uf_name);\n    ga_init2(&dfunc->df_var_names, sizeof(char_u *), 10);\n    ++dfunc->df_refcount;\n    ++def_functions.ga_len;\n    return OK;\n}\n\n/*\n * After ex_function() has collected all the function lines: parse and compile\n * the lines into instructions.\n * Adds the function to \"def_functions\".\n * When \"check_return_type\" is set then set ufunc->uf_ret_type to the type of\n * the return statement (used for lambda).  When uf_ret_type is already set\n * then check that it matches.\n * When \"profiling\" is true add ISN_PROF_START instructions.\n * \"outer_cctx\" is set for a nested function.\n * This can be used recursively through compile_lambda(), which may reallocate\n * \"def_functions\".\n * Returns OK or FAIL.\n */\n    int\ncompile_def_function(\n\tufunc_T\t\t*ufunc,\n\tint\t\tcheck_return_type,\n\tcompiletype_T   compile_type,\n\tcctx_T\t\t*outer_cctx)\n{\n    char_u\t*line = NULL;\n    garray_T\tlines_to_free;\n    char_u\t*p;\n    char\t*errormsg = NULL;\t// error message\n    cctx_T\tcctx;\n    garray_T\t*instr;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tdid_emsg_silent_before = did_emsg_silent;\n    int\t\tret = FAIL;\n    sctx_T\tsave_current_sctx = current_sctx;\n    int\t\tsave_estack_compiling = estack_compiling;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n    int\t\tdo_estack_push;\n    int\t\tnew_def_function = FALSE;\n#ifdef FEAT_PROFILE\n    int\t\tprof_lnum = -1;\n#endif\n    int\t\tdebug_lnum = -1;\n\n    // allocated lines are freed at the end\n    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n\n    // When using a function that was compiled before: Free old instructions.\n    // The index is reused.  Otherwise add a new entry in \"def_functions\".\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tisn_T\t*instr_dest = NULL;\n\n\tswitch (compile_type)\n\t{\n\t    case CT_PROFILE:\n#ifdef FEAT_PROFILE\n\t\t\t    instr_dest = dfunc->df_instr_prof; break;\n#endif\n\t    case CT_NONE:   instr_dest = dfunc->df_instr; break;\n\t    case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break;\n\t}\n\tif (instr_dest != NULL)\n\t    // Was compiled in this mode before: Free old instructions.\n\t    delete_def_function_contents(dfunc, FALSE);\n\tga_clear_strings(&dfunc->df_var_names);\n    }\n    else\n    {\n\tif (add_def_function(ufunc) == FAIL)\n\t    return FAIL;\n\tnew_def_function = TRUE;\n    }\n\n    ufunc->uf_def_status = UF_COMPILING;\n\n    CLEAR_FIELD(cctx);\n\n    cctx.ctx_compile_type = compile_type;\n    cctx.ctx_ufunc = ufunc;\n    cctx.ctx_lnum = -1;\n    cctx.ctx_outer = outer_cctx;\n    ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10);\n    // Each entry on the type stack consists of two type pointers.\n    ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50);\n    ga_init2(&cctx.ctx_imports, sizeof(imported_T), 10);\n    cctx.ctx_type_list = &ufunc->uf_type_list;\n    ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50);\n    instr = &cctx.ctx_instr;\n\n    // Set the context to the function, it may be compiled when called from\n    // another script.  Set the script version to the most modern one.\n    // The line number will be set in next_line_from_context().\n    current_sctx = ufunc->uf_script_ctx;\n    current_sctx.sc_version = SCRIPT_VERSION_VIM9;\n\n    // Don't use the flag from \":legacy\" here.\n    cmdmod.cmod_flags &= ~CMOD_LEGACY;\n\n    // Make sure error messages are OK.\n    do_estack_push = !estack_top_is_ufunc(ufunc, 1);\n    if (do_estack_push)\n\testack_push_ufunc(ufunc, 1);\n    estack_compiling = TRUE;\n\n    if (check_args_shadowing(ufunc, &cctx) == FAIL)\n\tgoto erret;\n\n    if (ufunc->uf_def_args.ga_len > 0)\n    {\n\tint\tcount = ufunc->uf_def_args.ga_len;\n\tint\tfirst_def_arg = ufunc->uf_args.ga_len - count;\n\tint\ti;\n\tchar_u\t*arg;\n\tint\toff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0);\n\tint\tdid_set_arg_type = FALSE;\n\n\t// Produce instructions for the default values of optional arguments.\n\tSOURCING_LNUM = 0;  // line number unknown\n\tfor (i = 0; i < count; ++i)\n\t{\n\t    type_T\t*val_type;\n\t    int\t\targ_idx = first_def_arg + i;\n\t    where_T\twhere = WHERE_INIT;\n\t    int\t\tr;\n\t    int\t\tjump_instr_idx = instr->ga_len;\n\t    isn_T\t*isn;\n\n\t    // Use a JUMP_IF_ARG_SET instruction to skip if the value was given.\n\t    if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL)\n\t\tgoto erret;\n\n\t    // Make sure later arguments are not found.\n\t    ufunc->uf_args_visible = arg_idx;\n\n\t    arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i];\n\t    r = compile_expr0(&arg, &cctx);\n\n\t    if (r == FAIL)\n\t\tgoto erret;\n\n\t    // If no type specified use the type of the default value.\n\t    // Otherwise check that the default value type matches the\n\t    // specified type.\n\t    val_type = get_type_on_stack(&cctx, 0);\n\t    where.wt_index = arg_idx + 1;\n\t    if (ufunc->uf_arg_types[arg_idx] == &t_unknown)\n\t    {\n\t\tdid_set_arg_type = TRUE;\n\t\tufunc->uf_arg_types[arg_idx] = val_type;\n\t    }\n\t    else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx],\n\t\t\t\t       -1, where, &cctx, FALSE, FALSE) == FAIL)\n\t\tgoto erret;\n\n\t    if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL)\n\t\tgoto erret;\n\n\t    // set instruction index in JUMP_IF_ARG_SET to here\n\t    isn = ((isn_T *)instr->ga_data) + jump_instr_idx;\n\t    isn->isn_arg.jumparg.jump_where = instr->ga_len;\n\t}\n\n\tif (did_set_arg_type)\n\t    set_function_type(ufunc);\n    }\n    ufunc->uf_args_visible = ufunc->uf_args.ga_len;\n\n    /*\n     * Loop over all the lines of the function and generate instructions.\n     */\n    for (;;)\n    {\n\texarg_T\t    ea;\n\tint\t    starts_with_colon = FALSE;\n\tchar_u\t    *cmd;\n\tcmdmod_T    local_cmdmod;\n\n\t// Bail out on the first error to avoid a flood of errors and report\n\t// the right line number when inside try/catch.\n\tif (did_emsg_before != did_emsg)\n\t    goto erret;\n\n\tif (line != NULL && *line == '|')\n\t    // the line continues after a '|'\n\t    ++line;\n\telse if (line != NULL && *skipwhite(line) != NUL\n\t\t&& !(*line == '#' && (line == cctx.ctx_line_start\n\t\t\t\t\t\t    || VIM_ISWHITE(line[-1]))))\n\t{\n\t    semsg(_(e_trailing_characters_str), line);\n\t    goto erret;\n\t}\n\telse if (line != NULL && vim9_bad_comment(skipwhite(line)))\n\t    goto erret;\n\telse\n\t{\n\t    line = next_line_from_context(&cctx, FALSE);\n\t    if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len)\n\t    {\n\t\t// beyond the last line\n#ifdef FEAT_PROFILE\n\t\tif (cctx.ctx_skip != SKIP_YES)\n\t\t    may_generate_prof_end(&cctx, prof_lnum);\n#endif\n\t\tbreak;\n\t    }\n\t    // Make a copy, splitting off nextcmd and removing trailing spaces\n\t    // may change it.\n\t    if (line != NULL)\n\t    {\n\t\tline = vim_strsave(line);\n\t\tif (ga_add_string(&lines_to_free, line) == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\tCLEAR_FIELD(ea);\n\tea.cmdlinep = &line;\n\tea.cmd = skipwhite(line);\n\n\tif (*ea.cmd == '#')\n\t{\n\t    // \"#\" starts a comment\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    may_generate_prof_end(&cctx, prof_lnum);\n\n\t    prof_lnum = cctx.ctx_lnum;\n\t    generate_instr(&cctx, ISN_PROF_START);\n\t}\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum\n\t\t\t\t\t\t  && cctx.ctx_skip != SKIP_YES)\n\t{\n\t    debug_lnum = cctx.ctx_lnum;\n\t    generate_instr_debug(&cctx);\n\t}\n\tcctx.ctx_prev_lnum = cctx.ctx_lnum + 1;\n\n\t// Some things can be recognized by the first character.\n\tswitch (*ea.cmd)\n\t{\n\t    case '}':\n\t\t{\n\t\t    // \"}\" ends a block scope\n\t\t    scopetype_T stype = cctx.ctx_scope == NULL\n\t\t\t\t\t  ? NO_SCOPE : cctx.ctx_scope->se_type;\n\n\t\t    if (stype == BLOCK_SCOPE)\n\t\t    {\n\t\t\tcompile_endblock(&cctx);\n\t\t\tline = ea.cmd;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\temsg(_(e_using_rcurly_outside_if_block_scope));\n\t\t\tgoto erret;\n\t\t    }\n\t\t    if (line != NULL)\n\t\t\tline = skipwhite(ea.cmd + 1);\n\t\t    continue;\n\t\t}\n\n\t    case '{':\n\t\t// \"{\" starts a block scope\n\t\t// \"{'a': 1}->func() is something else\n\t\tif (ends_excmd(*skipwhite(ea.cmd + 1)))\n\t\t{\n\t\t    line = compile_block(ea.cmd, &cctx);\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * COMMAND MODIFIERS\n\t */\n\tcctx.ctx_has_cmdmod = FALSE;\n\tif (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t{\n\t    if (errormsg != NULL)\n\t\tgoto erret;\n\t    // empty line or comment\n\t    line = (char_u *)\"\";\n\t    continue;\n\t}\n\tgenerate_cmdmods(&cctx, &local_cmdmod);\n\tundo_cmdmod(&local_cmdmod);\n\n\t// Check if there was a colon after the last command modifier or before\n\t// the current position.\n\tfor (p = ea.cmd; p >= line; --p)\n\t{\n\t    if (*p == ':')\n\t\tstarts_with_colon = TRUE;\n\t    if (p < ea.cmd && !VIM_ISWHITE(*p))\n\t\tbreak;\n\t}\n\n\t// Skip \":call\" to get to the function name, unless using :legacy\n\tp = ea.cmd;\n\tif (!(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t{\n\t    if (checkforcmd(&ea.cmd, \"call\", 3))\n\t    {\n\t\tif (*ea.cmd == '(')\n\t\t    // not for \"call()\"\n\t\t    ea.cmd = p;\n\t\telse\n\t\t    ea.cmd = skipwhite(ea.cmd);\n\t    }\n\n\t    if (!starts_with_colon)\n\t    {\n\t\tint\t    assign;\n\n\t\t// Check for assignment after command modifiers.\n\t\tassign = may_compile_assignment(&ea, &line, &cctx);\n\t\tif (assign == OK)\n\t\t    goto nextline;\n\t\tif (assign == FAIL)\n\t\t    goto erret;\n\t    }\n\t}\n\n\t/*\n\t * COMMAND after range\n\t * 'text'->func() should not be confused with 'a mark\n\t * \"++nr\" and \"--nr\" are eval commands\n\t * in \"$ENV->func()\" the \"$\" is not a range\n\t */\n\tcmd = ea.cmd;\n\tif ((*cmd != '$' || starts_with_colon)\n\t\t&& (starts_with_colon || !(*cmd == '\\''\n\t\t       || (cmd[0] != NUL && cmd[0] == cmd[1]\n\t\t\t\t\t    && (*cmd == '+' || *cmd == '-')))))\n\t{\n\t    ea.cmd = skip_range(ea.cmd, TRUE, NULL);\n\t    if (ea.cmd > cmd)\n\t    {\n\t\tif (!starts_with_colon\n\t\t\t\t   && !(local_cmdmod.cmod_flags & CMOD_LEGACY))\n\t\t{\n\t\t    semsg(_(e_colon_required_before_range_str), cmd);\n\t\t    goto erret;\n\t\t}\n\t\tea.addr_count = 1;\n\t\tif (ends_excmd2(line, ea.cmd))\n\t\t{\n\t\t    // A range without a command: jump to the line.\n\t\t    generate_EXEC(&cctx, ISN_EXECRANGE,\n\t\t\t\t\t      vim_strnsave(cmd, ea.cmd - cmd));\n\t\t    line = ea.cmd;\n\t\t    goto nextline;\n\t\t}\n\t    }\n\t}\n\tp = find_ex_command(&ea, NULL,\n\t\tstarts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t\t\t\t\t  ? NULL : item_exists, &cctx);\n\n\tif (p == NULL)\n\t{\n\t    if (cctx.ctx_skip != SKIP_YES)\n\t\temsg(_(e_ambiguous_use_of_user_defined_command));\n\t    goto erret;\n\t}\n\n\t// When using \":legacy cmd\" always use compile_exec().\n\tif (local_cmdmod.cmod_flags & CMOD_LEGACY)\n\t{\n\t    char_u *start = ea.cmd;\n\n\t    switch (ea.cmdidx)\n\t    {\n\t\tcase CMD_if:\n\t\tcase CMD_elseif:\n\t\tcase CMD_else:\n\t\tcase CMD_endif:\n\t\tcase CMD_for:\n\t\tcase CMD_endfor:\n\t\tcase CMD_continue:\n\t\tcase CMD_break:\n\t\tcase CMD_while:\n\t\tcase CMD_endwhile:\n\t\tcase CMD_try:\n\t\tcase CMD_catch:\n\t\tcase CMD_finally:\n\t\tcase CMD_endtry:\n\t\t\tsemsg(_(e_cannot_use_legacy_with_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\tdefault: break;\n\t    }\n\n\t    // \":legacy return expr\" needs to be handled differently.\n\t    if (checkforcmd(&start, \"return\", 4))\n\t\tea.cmdidx = CMD_return;\n\t    else\n\t\tea.cmdidx = CMD_legacy;\n\t}\n\n\tif (p == ea.cmd && ea.cmdidx != CMD_SIZE)\n\t{\n\t    if (cctx.ctx_skip == SKIP_YES && ea.cmdidx != CMD_eval)\n\t    {\n\t\tline += STRLEN(line);\n\t\tgoto nextline;\n\t    }\n\t    else if (ea.cmdidx != CMD_eval)\n\t    {\n\t\t// CMD_var cannot happen, compile_assignment() above would be\n\t\t// used.  Most likely an assignment to a non-existing variable.\n\t\tsemsg(_(e_command_not_recognized_str), ea.cmd);\n\t\tgoto erret;\n\t    }\n\t}\n\n\tif (cctx.ctx_had_return\n\t\t&& ea.cmdidx != CMD_elseif\n\t\t&& ea.cmdidx != CMD_else\n\t\t&& ea.cmdidx != CMD_endif\n\t\t&& ea.cmdidx != CMD_endfor\n\t\t&& ea.cmdidx != CMD_endwhile\n\t\t&& ea.cmdidx != CMD_catch\n\t\t&& ea.cmdidx != CMD_finally\n\t\t&& ea.cmdidx != CMD_endtry)\n\t{\n\t    emsg(_(e_unreachable_code_after_return));\n\t    goto erret;\n\t}\n\n\tp = skipwhite(p);\n\tif (ea.cmdidx != CMD_SIZE\n\t\t\t    && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read)\n\t{\n\t    if (ea.cmdidx >= 0)\n\t\tea.argt = excmd_get_argt(ea.cmdidx);\n\t    if ((ea.argt & EX_BANG) && *p == '!')\n\t    {\n\t\tea.forceit = TRUE;\n\t\tp = skipwhite(p + 1);\n\t    }\n\t}\n\n\tswitch (ea.cmdidx)\n\t{\n\t    case CMD_def:\n\t    case CMD_function:\n\t\t    ea.arg = p;\n\t\t    line = compile_nested_function(&ea, &cctx, &lines_to_free);\n\t\t    break;\n\n\t    case CMD_return:\n\t\t    line = compile_return(p, check_return_type,\n\t\t\t\t local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx);\n\t\t    cctx.ctx_had_return = TRUE;\n\t\t    break;\n\n\t    case CMD_let:\n\t\t    emsg(_(e_cannot_use_let_in_vim9_script));\n\t\t    break;\n\t    case CMD_var:\n\t    case CMD_final:\n\t    case CMD_const:\n\t    case CMD_increment:\n\t    case CMD_decrement:\n\t\t    line = compile_assignment(p, &ea, ea.cmdidx, &cctx);\n\t\t    if (line == p)\n\t\t\tline = NULL;\n\t\t    break;\n\n\t    case CMD_unlet:\n\t    case CMD_unlockvar:\n\t    case CMD_lockvar:\n\t\t    line = compile_unletlock(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_import:\n\t\t    emsg(_(e_import_can_only_be_used_in_script));\n\t\t    line = NULL;\n\t\t    break;\n\n\t    case CMD_if:\n\t\t    line = compile_if(p, &cctx);\n\t\t    break;\n\t    case CMD_elseif:\n\t\t    line = compile_elseif(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_else:\n\t\t    line = compile_else(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endif:\n\t\t    line = compile_endif(p, &cctx);\n\t\t    break;\n\n\t    case CMD_while:\n\t\t    line = compile_while(p, &cctx);\n\t\t    break;\n\t    case CMD_endwhile:\n\t\t    line = compile_endwhile(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\n\t    case CMD_for:\n\t\t    line = compile_for(p, &cctx);\n\t\t    break;\n\t    case CMD_endfor:\n\t\t    line = compile_endfor(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_continue:\n\t\t    line = compile_continue(p, &cctx);\n\t\t    break;\n\t    case CMD_break:\n\t\t    line = compile_break(p, &cctx);\n\t\t    break;\n\n\t    case CMD_try:\n\t\t    line = compile_try(p, &cctx);\n\t\t    break;\n\t    case CMD_catch:\n\t\t    line = compile_catch(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_finally:\n\t\t    line = compile_finally(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_endtry:\n\t\t    line = compile_endtry(p, &cctx);\n\t\t    cctx.ctx_had_return = FALSE;\n\t\t    break;\n\t    case CMD_throw:\n\t\t    line = compile_throw(p, &cctx);\n\t\t    break;\n\n\t    case CMD_eval:\n\t\t    line = compile_eval(p, &cctx);\n\t\t    break;\n\n\t    case CMD_echo:\n\t    case CMD_echon:\n\t    case CMD_execute:\n\t    case CMD_echomsg:\n\t    case CMD_echoerr:\n\t    case CMD_echoconsole:\n\t\t    line = compile_mult_expr(p, ea.cmdidx, &cctx);\n\t\t    break;\n\n\t    case CMD_put:\n\t\t    ea.cmd = cmd;\n\t\t    line = compile_put(p, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_substitute:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    if (cctx.ctx_skip == SKIP_YES)\n\t\t\tline = (char_u *)\"\";\n\t\t    else\n\t\t    {\n\t\t\tea.arg = p;\n\t\t\tline = compile_substitute(line, &ea, &cctx);\n\t\t    }\n\t\t    break;\n\n\t    case CMD_redir:\n\t\t    ea.arg = p;\n\t\t    line = compile_redir(line, &ea, &cctx);\n\t\t    break;\n\n\t    case CMD_cexpr:\n\t    case CMD_lexpr:\n\t    case CMD_caddexpr:\n\t    case CMD_laddexpr:\n\t    case CMD_cgetexpr:\n\t    case CMD_lgetexpr:\n#ifdef FEAT_QUICKFIX\n\t\t    ea.arg = p;\n\t\t    line = compile_cexpr(line, &ea, &cctx);\n#else\n\t\t    ex_ni(&ea);\n\t\t    line = NULL;\n#endif\n\t\t    break;\n\n\t    case CMD_append:\n\t    case CMD_change:\n\t    case CMD_insert:\n\t    case CMD_k:\n\t    case CMD_t:\n\t    case CMD_xit:\n\t\t    not_in_vim9(&ea);\n\t\t    goto erret;\n\n\t    case CMD_SIZE:\n\t\t    if (cctx.ctx_skip != SKIP_YES)\n\t\t    {\n\t\t\tsemsg(_(e_invalid_command_str), ea.cmd);\n\t\t\tgoto erret;\n\t\t    }\n\t\t    // We don't check for a next command here.\n\t\t    line = (char_u *)\"\";\n\t\t    break;\n\n\t    case CMD_lua:\n\t    case CMD_mzscheme:\n\t    case CMD_perl:\n\t    case CMD_py3:\n\t    case CMD_python3:\n\t    case CMD_python:\n\t    case CMD_pythonx:\n\t    case CMD_ruby:\n\t    case CMD_tcl:\n\t\t    ea.arg = p;\n\t\t    if (vim_strchr(line, '\\n') == NULL)\n\t\t\tline = compile_exec(line, &ea, &cctx);\n\t\t    else\n\t\t\t// heredoc lines have been concatenated with NL\n\t\t\t// characters in get_function_body()\n\t\t\tline = compile_script(line, &cctx);\n\t\t    break;\n\n\t    case CMD_global:\n\t\t    if (check_global_and_subst(ea.cmd, p) == FAIL)\n\t\t\tgoto erret;\n\t\t    // FALLTHROUGH\n\t    default:\n\t\t    // Not recognized, execute with do_cmdline_cmd().\n\t\t    ea.arg = p;\n\t\t    line = compile_exec(line, &ea, &cctx);\n\t\t    break;\n\t}\nnextline:\n\tif (line == NULL)\n\t    goto erret;\n\tline = skipwhite(line);\n\n\t// Undo any command modifiers.\n\tgenerate_undo_cmdmods(&cctx);\n\n\tif (cctx.ctx_type_stack.ga_len < 0)\n\t{\n\t    iemsg(\"Type stack underflow\");\n\t    goto erret;\n\t}\n    }\n\n    if (cctx.ctx_scope != NULL)\n    {\n\tif (cctx.ctx_scope->se_type == IF_SCOPE)\n\t    emsg(_(e_missing_endif));\n\telse if (cctx.ctx_scope->se_type == WHILE_SCOPE)\n\t    emsg(_(e_missing_endwhile));\n\telse if (cctx.ctx_scope->se_type == FOR_SCOPE)\n\t    emsg(_(e_missing_endfor));\n\telse\n\t    emsg(_(e_missing_rcurly));\n\tgoto erret;\n    }\n\n    if (!cctx.ctx_had_return)\n    {\n\tif (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN)\n\t    ufunc->uf_ret_type = &t_void;\n\telse if (ufunc->uf_ret_type->tt_type != VAR_VOID)\n\t{\n\t    emsg(_(e_missing_return_statement));\n\t    goto erret;\n\t}\n\n\t// Return void if there is no return at the end.\n\tgenerate_instr(&cctx, ISN_RETURN_VOID);\n    }\n\n    // When compiled with \":silent!\" and there was an error don't consider the\n    // function compiled.\n    if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\tdfunc->df_deleted = FALSE;\n\tdfunc->df_script_seq = current_sctx.sc_seq;\n#ifdef FEAT_PROFILE\n\tif (cctx.ctx_compile_type == CT_PROFILE)\n\t{\n\t    dfunc->df_instr_prof = instr->ga_data;\n\t    dfunc->df_instr_prof_count = instr->ga_len;\n\t}\n\telse\n#endif\n\tif (cctx.ctx_compile_type == CT_DEBUG)\n\t{\n\t    dfunc->df_instr_debug = instr->ga_data;\n\t    dfunc->df_instr_debug_count = instr->ga_len;\n\t}\n\telse\n\t{\n\t    dfunc->df_instr = instr->ga_data;\n\t    dfunc->df_instr_count = instr->ga_len;\n\t}\n\tdfunc->df_varcount = dfunc->df_var_names.ga_len;\n\tdfunc->df_has_closure = cctx.ctx_has_closure;\n\tif (cctx.ctx_outer_used)\n\t    ufunc->uf_flags |= FC_CLOSURE;\n\tufunc->uf_def_status = UF_COMPILED;\n    }\n\n    ret = OK;\n\nerret:\n    if (ufunc->uf_def_status == UF_COMPILING)\n    {\n\tdfunc_T\t*dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t// Compiling aborted, free the generated instructions.\n\tclear_instr_ga(instr);\n\tVIM_CLEAR(dfunc->df_name);\n\tga_clear_strings(&dfunc->df_var_names);\n\n\t// If using the last entry in the table and it was added above, we\n\t// might as well remove it.\n\tif (!dfunc->df_deleted && new_def_function\n\t\t\t    && ufunc->uf_dfunc_idx == def_functions.ga_len - 1)\n\t{\n\t    --def_functions.ga_len;\n\t    ufunc->uf_dfunc_idx = 0;\n\t}\n\tufunc->uf_def_status = UF_COMPILE_ERROR;\n\n\twhile (cctx.ctx_scope != NULL)\n\t    drop_scope(&cctx);\n\n\tif (errormsg != NULL)\n\t    emsg(errormsg);\n\telse if (did_emsg == did_emsg_before)\n\t    emsg(_(e_compiling_def_function_failed));\n    }\n\n    if (cctx.ctx_redir_lhs.lhs_name != NULL)\n    {\n\tif (ret == OK)\n\t{\n\t    emsg(_(e_missing_redir_end));\n\t    ret = FAIL;\n\t}\n\tvim_free(cctx.ctx_redir_lhs.lhs_name);\n\tvim_free(cctx.ctx_redir_lhs.lhs_whole);\n    }\n\n    current_sctx = save_current_sctx;\n    estack_compiling = save_estack_compiling;\n    cmdmod.cmod_flags =\tsave_cmod_flags;\n    if (do_estack_push)\n\testack_pop();\n\n    ga_clear_strings(&lines_to_free);\n    free_imported(&cctx);\n    free_locals(&cctx);\n    ga_clear(&cctx.ctx_type_stack);\n    return ret;\n}\n\n    void\nset_function_type(ufunc_T *ufunc)\n{\n    int varargs = ufunc->uf_va_name != NULL;\n    int argcount = ufunc->uf_args.ga_len;\n\n    // Create a type for the function, with the return type and any\n    // argument types.\n    // A vararg is included in uf_args.ga_len but not in uf_arg_types.\n    // The type is included in \"tt_args\".\n    if (argcount > 0 || varargs)\n    {\n\tif (ufunc->uf_type_list.ga_itemsize == 0)\n\t    ga_init2(&ufunc->uf_type_list, sizeof(type_T *), 10);\n\tufunc->uf_func_type = alloc_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n\t// Add argument types to the function type.\n\tif (func_type_add_arg_types(ufunc->uf_func_type,\n\t\t\t\t    argcount + varargs,\n\t\t\t\t    &ufunc->uf_type_list) == FAIL)\n\t    return;\n\tufunc->uf_func_type->tt_argcount = argcount + varargs;\n\tufunc->uf_func_type->tt_min_argcount =\n\t\t\t\t      argcount - ufunc->uf_def_args.ga_len;\n\tif (ufunc->uf_arg_types == NULL)\n\t{\n\t    int i;\n\n\t    // lambda does not have argument types.\n\t    for (i = 0; i < argcount; ++i)\n\t\tufunc->uf_func_type->tt_args[i] = &t_any;\n\t}\n\telse\n\t    mch_memmove(ufunc->uf_func_type->tt_args,\n\t\t\t ufunc->uf_arg_types, sizeof(type_T *) * argcount);\n\tif (varargs)\n\t{\n\t    ufunc->uf_func_type->tt_args[argcount] =\n\t\t   ufunc->uf_va_type == NULL ? &t_list_any : ufunc->uf_va_type;\n\t    ufunc->uf_func_type->tt_flags = TTFLAG_VARARGS;\n\t}\n    }\n    else\n\t// No arguments, can use a predefined type.\n\tufunc->uf_func_type = get_func_type(ufunc->uf_ret_type,\n\t\t\t\t\t   argcount, &ufunc->uf_type_list);\n}\n\n/*\n * Free all instructions for \"dfunc\" except df_name.\n */\n    static void\ndelete_def_function_contents(dfunc_T *dfunc, int mark_deleted)\n{\n    int idx;\n\n    ga_clear(&dfunc->df_def_args_isn);\n    ga_clear_strings(&dfunc->df_var_names);\n\n    if (dfunc->df_instr != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_count; ++idx)\n\t    delete_instr(dfunc->df_instr + idx);\n\tVIM_CLEAR(dfunc->df_instr);\n\tdfunc->df_instr = NULL;\n    }\n    if (dfunc->df_instr_debug != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_debug_count; ++idx)\n\t    delete_instr(dfunc->df_instr_debug + idx);\n\tVIM_CLEAR(dfunc->df_instr_debug);\n\tdfunc->df_instr_debug = NULL;\n    }\n#ifdef FEAT_PROFILE\n    if (dfunc->df_instr_prof != NULL)\n    {\n\tfor (idx = 0; idx < dfunc->df_instr_prof_count; ++idx)\n\t    delete_instr(dfunc->df_instr_prof + idx);\n\tVIM_CLEAR(dfunc->df_instr_prof);\n\tdfunc->df_instr_prof = NULL;\n    }\n#endif\n\n    if (mark_deleted)\n\tdfunc->df_deleted = TRUE;\n    if (dfunc->df_ufunc != NULL)\n\tdfunc->df_ufunc->uf_def_status = UF_NOT_COMPILED;\n}\n\n/*\n * When a user function is deleted, clear the contents of any associated def\n * function, unless another user function still uses it.\n * The position in def_functions can be re-used.\n */\n    void\nunlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\tif (--dfunc->df_refcount <= 0)\n\t    delete_def_function_contents(dfunc, TRUE);\n\tufunc->uf_def_status = UF_NOT_COMPILED;\n\tufunc->uf_dfunc_idx = 0;\n\tif (dfunc->df_ufunc == ufunc)\n\t    dfunc->df_ufunc = NULL;\n    }\n}\n\n/*\n * Used when a user function refers to an existing dfunc.\n */\n    void\nlink_def_function(ufunc_T *ufunc)\n{\n    if (ufunc->uf_dfunc_idx > 0)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)\n\t\t\t\t\t\t\t + ufunc->uf_dfunc_idx;\n\n\t++dfunc->df_refcount;\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n/*\n * Free all functions defined with \":def\".\n */\n    void\nfree_def_functions(void)\n{\n    int idx;\n\n    for (idx = 0; idx < def_functions.ga_len; ++idx)\n    {\n\tdfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data) + idx;\n\n\tdelete_def_function_contents(dfunc, TRUE);\n\tvim_free(dfunc->df_name);\n    }\n\n    ga_clear(&def_functions);\n}\n#endif\n\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * viminfo.c: viminfo related functions\n */\n\n#include \"vim.h\"\n#include \"version.h\"\n\n/*\n * Structure used for reading from the viminfo file.\n */\ntypedef struct\n{\n    char_u\t*vir_line;\t// text of the current line\n    FILE\t*vir_fd;\t// file descriptor\n    vimconv_T\tvir_conv;\t// encoding conversion\n    int\t\tvir_version;\t// viminfo version detected or -1\n    garray_T\tvir_barlines;\t// lines starting with |\n} vir_T;\n\ntypedef enum {\n    BVAL_NR,\n    BVAL_STRING,\n    BVAL_EMPTY\n} btype_T;\n\ntypedef struct {\n    btype_T\tbv_type;\n    long\tbv_nr;\n    char_u\t*bv_string;\n    char_u\t*bv_tofree;\t// free later when not NULL\n    int\t\tbv_len;\t\t// length of bv_string\n    int\t\tbv_allocated;\t// bv_string was allocated\n} bval_T;\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n\nstatic int  viminfo_errcnt;\n\n/*\n * Find the parameter represented by the given character (eg ''', ':', '\"', or\n * '/') in the 'viminfo' option and return a pointer to the string after it.\n * Return NULL if the parameter is not specified in the string.\n */\n    static char_u *\nfind_viminfo_parameter(int type)\n{\n    char_u  *p;\n\n    for (p = p_viminfo; *p; ++p)\n    {\n\tif (*p == type)\n\t    return p + 1;\n\tif (*p == 'n')\t\t    // 'n' is always the last one\n\t    break;\n\tp = vim_strchr(p, ',');\t    // skip until next ','\n\tif (p == NULL)\t\t    // hit the end without finding parameter\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * Find the parameter represented by the given character (eg ', :, \", or /),\n * and return its associated value in the 'viminfo' string.\n * Only works for number parameters, not for 'r' or 'n'.\n * If the parameter is not specified in the string or there is no following\n * number, return -1.\n */\n    int\nget_viminfo_parameter(int type)\n{\n    char_u  *p;\n\n    p = find_viminfo_parameter(type);\n    if (p != NULL && VIM_ISDIGIT(*p))\n\treturn atoi((char *)p);\n    return -1;\n}\n\n/*\n * Get the viminfo file name to use.\n * If \"file\" is given and not empty, use it (has already been expanded by\n * cmdline functions).\n * Otherwise use \"-i file_name\", value from 'viminfo' or the default, and\n * expand environment variables.\n * Returns an allocated string.  NULL when out of memory.\n */\n    static char_u *\nviminfo_filename(char_u *file)\n{\n    if (file == NULL || *file == NUL)\n    {\n\tif (*p_viminfofile != NUL)\n\t    file = p_viminfofile;\n\telse if ((file = find_viminfo_parameter('n')) == NULL || *file == NUL)\n\t{\n#ifdef VIMINFO_FILE2\n# ifdef VMS\n\t    if (mch_getenv((char_u *)\"SYS$LOGIN\") == NULL)\n# else\n#  ifdef MSWIN\n\t    // Use $VIM only if $HOME is the default \"C:/\".\n\t    if (STRCMP(vim_getenv((char_u *)\"HOME\", NULL), \"C:/\") == 0\n\t\t    && mch_getenv((char_u *)\"HOME\") == NULL)\n#  else\n\t    if (mch_getenv((char_u *)\"HOME\") == NULL)\n#  endif\n# endif\n\t    {\n\t\t// don't use $VIM when not available.\n\t\texpand_env((char_u *)\"$VIM\", NameBuff, MAXPATHL);\n\t\tif (STRCMP(\"$VIM\", NameBuff) != 0)  // $VIM was expanded\n\t\t    file = (char_u *)VIMINFO_FILE2;\n\t\telse\n\t\t    file = (char_u *)VIMINFO_FILE;\n\t    }\n\t    else\n#endif\n\t\tfile = (char_u *)VIMINFO_FILE;\n\t}\n\texpand_env(file, NameBuff, MAXPATHL);\n\tfile = NameBuff;\n    }\n    return vim_strsave(file);\n}\n\n/*\n * write string to viminfo file\n * - replace CTRL-V with CTRL-V CTRL-V\n * - replace '\\n'   with CTRL-V 'n'\n * - add a '\\n' at the end\n *\n * For a long line:\n * - write \" CTRL-V <length> \\n \" in first line\n * - write \" < <string> \\n \"\t  in second line\n */\n    static void\nviminfo_writestring(FILE *fd, char_u *p)\n{\n    int\t\tc;\n    char_u\t*s;\n    int\t\tlen = 0;\n\n    for (s = p; *s != NUL; ++s)\n    {\n\tif (*s == Ctrl_V || *s == '\\n')\n\t    ++len;\n\t++len;\n    }\n\n    // If the string will be too long, write its length and put it in the next\n    // line.  Take into account that some room is needed for what comes before\n    // the string (e.g., variable name).  Add something to the length for the\n    // '<', NL and trailing NUL.\n    if (len > LSIZE / 2)\n\tfprintf(fd, IF_EB(\"\\026%d\\n<\", CTRL_V_STR \"%d\\n<\"), len + 3);\n\n    while ((c = *p++) != NUL)\n    {\n\tif (c == Ctrl_V || c == '\\n')\n\t{\n\t    putc(Ctrl_V, fd);\n\t    if (c == '\\n')\n\t\tc = 'n';\n\t}\n\tputc(c, fd);\n    }\n    putc('\\n', fd);\n}\n\n/*\n * Write a string in quotes that barline_parse() can read back.\n * Breaks the line in less than LSIZE pieces when needed.\n * Returns remaining characters in the line.\n */\n    static int\nbarline_writestring(FILE *fd, char_u *s, int remaining_start)\n{\n    char_u *p;\n    int\t    remaining = remaining_start;\n    int\t    len = 2;\n\n    // Count the number of characters produced, including quotes.\n    for (p = s; *p != NUL; ++p)\n    {\n\tif (*p == NL)\n\t    len += 2;\n\telse if (*p == '\"' || *p == '\\\\')\n\t    len += 2;\n\telse\n\t    ++len;\n    }\n    if (len > remaining - 2)\n    {\n\tfprintf(fd, \">%d\\n|<\", len);\n\tremaining = LSIZE - 20;\n    }\n\n    putc('\"', fd);\n    for (p = s; *p != NUL; ++p)\n    {\n\tif (*p == NL)\n\t{\n\t    putc('\\\\', fd);\n\t    putc('n', fd);\n\t    --remaining;\n\t}\n\telse if (*p == '\"' || *p == '\\\\')\n\t{\n\t    putc('\\\\', fd);\n\t    putc(*p, fd);\n\t    --remaining;\n\t}\n\telse\n\t    putc(*p, fd);\n\t--remaining;\n\n\tif (remaining < 3)\n\t{\n\t    putc('\\n', fd);\n\t    putc('|', fd);\n\t    putc('<', fd);\n\t    // Leave enough space for another continuation.\n\t    remaining = LSIZE - 20;\n\t}\n    }\n    putc('\"', fd);\n    return remaining - 2;\n}\n\n/*\n * Check string read from viminfo file.\n * Remove '\\n' at the end of the line.\n * - replace CTRL-V CTRL-V with CTRL-V\n * - replace CTRL-V 'n'    with '\\n'\n *\n * Check for a long line as written by viminfo_writestring().\n *\n * Return the string in allocated memory (NULL when out of memory).\n */\n    static char_u *\nviminfo_readstring(\n    vir_T\t*virp,\n    int\t\toff,\t\t    // offset for virp->vir_line\n    int\t\tconvert UNUSED)\t    // convert the string\n{\n    char_u\t*retval = NULL;\n    char_u\t*s, *d;\n    long\tlen;\n\n    if (virp->vir_line[off] == Ctrl_V && vim_isdigit(virp->vir_line[off + 1]))\n    {\n\tlen = atol((char *)virp->vir_line + off + 1);\n\tif (len > 0 && len < 1000000)\n\t    retval = lalloc(len, TRUE);\n\tif (retval == NULL)\n\t{\n\t    // Invalid length, line too long, out of memory?  Skip next line.\n\t    (void)vim_fgets(virp->vir_line, 10, virp->vir_fd);\n\t    return NULL;\n\t}\n\t(void)vim_fgets(retval, (int)len, virp->vir_fd);\n\ts = retval + 1;\t    // Skip the leading '<'\n    }\n    else\n    {\n\tretval = vim_strsave(virp->vir_line + off);\n\tif (retval == NULL)\n\t    return NULL;\n\ts = retval;\n    }\n\n    // Change CTRL-V CTRL-V to CTRL-V and CTRL-V n to \\n in-place.\n    d = retval;\n    while (*s != NUL && *s != '\\n')\n    {\n\tif (s[0] == Ctrl_V && s[1] != NUL)\n\t{\n\t    if (s[1] == 'n')\n\t\t*d++ = '\\n';\n\t    else\n\t\t*d++ = Ctrl_V;\n\t    s += 2;\n\t}\n\telse\n\t    *d++ = *s++;\n    }\n    *d = NUL;\n\n    if (convert && virp->vir_conv.vc_type != CONV_NONE && *retval != NUL)\n    {\n\td = string_convert(&virp->vir_conv, retval, NULL);\n\tif (d != NULL)\n\t{\n\t    vim_free(retval);\n\t    retval = d;\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Read a line from the viminfo file.\n * Returns TRUE for end-of-file;\n */\n    static int\nviminfo_readline(vir_T *virp)\n{\n    return vim_fgets(virp->vir_line, LSIZE, virp->vir_fd);\n}\n\n    static int\nread_viminfo_bufferlist(\n    vir_T\t*virp,\n    int\t\twriting)\n{\n    char_u\t*tab;\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    buf_T\t*buf;\n    char_u\t*sfname;\n    char_u\t*xline;\n\n    // Handle long line and escaped characters.\n    xline = viminfo_readstring(virp, 1, FALSE);\n\n    // don't read in if there are files on the command-line or if writing:\n    if (xline != NULL && !writing && ARGCOUNT == 0\n\t\t\t\t       && find_viminfo_parameter('%') != NULL)\n    {\n\t// Format is: <fname> Tab <lnum> Tab <col>.\n\t// Watch out for a Tab in the file name, work from the end.\n\tlnum = 0;\n\tcol = 0;\n\ttab = vim_strrchr(xline, '\\t');\n\tif (tab != NULL)\n\t{\n\t    *tab++ = '\\0';\n\t    col = (colnr_T)atoi((char *)tab);\n\t    tab = vim_strrchr(xline, '\\t');\n\t    if (tab != NULL)\n\t    {\n\t\t*tab++ = '\\0';\n\t\tlnum = atol((char *)tab);\n\t    }\n\t}\n\n\t// Expand \"~/\" in the file name at \"line + 1\" to a full path.\n\t// Then try shortening it by comparing with the current directory\n\texpand_env(xline, NameBuff, MAXPATHL);\n\tsfname = shorten_fname1(NameBuff);\n\n\tbuf = buflist_new(NameBuff, sfname, (linenr_T)0, BLN_LISTED);\n\tif (buf != NULL)\t// just in case...\n\t{\n\t    buf->b_last_cursor.lnum = lnum;\n\t    buf->b_last_cursor.col = col;\n\t    buflist_setfpos(buf, curwin, lnum, col, FALSE);\n\t}\n    }\n    vim_free(xline);\n\n    return viminfo_readline(virp);\n}\n\n/*\n * Return TRUE if \"name\" is on removable media (depending on 'viminfo').\n */\n    static int\nremovable(char_u *name)\n{\n    char_u  *p;\n    char_u  part[51];\n    int\t    retval = FALSE;\n    size_t  n;\n\n    name = home_replace_save(NULL, name);\n    if (name != NULL)\n    {\n\tfor (p = p_viminfo; *p; )\n\t{\n\t    copy_option_part(&p, part, 51, \", \");\n\t    if (part[0] == 'r')\n\t    {\n\t\tn = STRLEN(part + 1);\n\t\tif (MB_STRNICMP(part + 1, name, n) == 0)\n\t\t{\n\t\t    retval = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tvim_free(name);\n    }\n    return retval;\n}\n\n    static void\nwrite_viminfo_bufferlist(FILE *fp)\n{\n    buf_T\t*buf;\n    win_T\t*win;\n    tabpage_T\t*tp;\n    char_u\t*line;\n    int\t\tmax_buffers;\n\n    if (find_viminfo_parameter('%') == NULL)\n\treturn;\n\n    // Without a number -1 is returned: do all buffers.\n    max_buffers = get_viminfo_parameter('%');\n\n    // Allocate room for the file name, lnum and col.\n#define LINE_BUF_LEN (MAXPATHL + 40)\n    line = alloc(LINE_BUF_LEN);\n    if (line == NULL)\n\treturn;\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n\tset_last_cursor(win);\n\n    fputs(_(\"\\n# Buffer list:\\n\"), fp);\n    FOR_ALL_BUFFERS(buf)\n    {\n\tif (buf->b_fname == NULL\n\t\t|| !buf->b_p_bl\n#ifdef FEAT_QUICKFIX\n\t\t|| bt_quickfix(buf)\n#endif\n#ifdef FEAT_TERMINAL\n\t\t|| bt_terminal(buf)\n#endif\n\t\t|| removable(buf->b_ffname))\n\t    continue;\n\n\tif (max_buffers-- == 0)\n\t    break;\n\tputc('%', fp);\n\thome_replace(NULL, buf->b_ffname, line, MAXPATHL, TRUE);\n\tvim_snprintf_add((char *)line, LINE_BUF_LEN, \"\\t%ld\\t%d\",\n\t\t\t(long)buf->b_last_cursor.lnum,\n\t\t\tbuf->b_last_cursor.col);\n\tviminfo_writestring(fp, line);\n    }\n    vim_free(line);\n}\n\n/*\n * Buffers for history read from a viminfo file.  Only valid while reading.\n */\nstatic histentry_T *viminfo_history[HIST_COUNT] =\n\t\t\t\t\t       {NULL, NULL, NULL, NULL, NULL};\nstatic int\tviminfo_hisidx[HIST_COUNT] = {0, 0, 0, 0, 0};\nstatic int\tviminfo_hislen[HIST_COUNT] = {0, 0, 0, 0, 0};\nstatic int\tviminfo_add_at_front = FALSE;\n\n/*\n * Translate a history type number to the associated character.\n */\n    static int\nhist_type2char(\n    int\t    type,\n    int\t    use_question)\t    // use '?' instead of '/'\n{\n    if (type == HIST_CMD)\n\treturn ':';\n    if (type == HIST_SEARCH)\n    {\n\tif (use_question)\n\t    return '?';\n\telse\n\t    return '/';\n    }\n    if (type == HIST_EXPR)\n\treturn '=';\n    return '@';\n}\n\n/*\n * Prepare for reading the history from the viminfo file.\n * This allocates history arrays to store the read history lines.\n */\n    static void\nprepare_viminfo_history(int asklen, int writing)\n{\n    int\t    i;\n    int\t    num;\n    int\t    type;\n    int\t    len;\n    int\t    hislen;\n\n    init_history();\n    hislen = get_hislen();\n    viminfo_add_at_front = (asklen != 0 && !writing);\n    if (asklen > hislen)\n\tasklen = hislen;\n\n    for (type = 0; type < HIST_COUNT; ++type)\n    {\n\thistentry_T *histentry = get_histentry(type);\n\n\t// Count the number of empty spaces in the history list.  Entries read\n\t// from viminfo previously are also considered empty.  If there are\n\t// more spaces available than we request, then fill them up.\n\tfor (i = 0, num = 0; i < hislen; i++)\n\t    if (histentry[i].hisstr == NULL || histentry[i].viminfo)\n\t\tnum++;\n\tlen = asklen;\n\tif (num > len)\n\t    len = num;\n\tif (len <= 0)\n\t    viminfo_history[type] = NULL;\n\telse\n\t    viminfo_history[type] = LALLOC_MULT(histentry_T, len);\n\tif (viminfo_history[type] == NULL)\n\t    len = 0;\n\tviminfo_hislen[type] = len;\n\tviminfo_hisidx[type] = 0;\n    }\n}\n\n/*\n * Accept a line from the viminfo, store it in the history array when it's\n * new.\n */\n    static int\nread_viminfo_history(vir_T *virp, int writing)\n{\n    int\t\ttype;\n    long_u\tlen;\n    char_u\t*val;\n    char_u\t*p;\n\n    type = hist_char2type(virp->vir_line[0]);\n    if (viminfo_hisidx[type] < viminfo_hislen[type])\n    {\n\tval = viminfo_readstring(virp, 1, TRUE);\n\tif (val != NULL && *val != NUL)\n\t{\n\t    int sep = (*val == ' ' ? NUL : *val);\n\n\t    if (!in_history(type, val + (type == HIST_SEARCH),\n\t\t\t\t\t  viminfo_add_at_front, sep, writing))\n\t    {\n\t\t// Need to re-allocate to append the separator byte.\n\t\tlen = STRLEN(val);\n\t\tp = alloc(len + 2);\n\t\tif (p != NULL)\n\t\t{\n\t\t    if (type == HIST_SEARCH)\n\t\t    {\n\t\t\t// Search entry: Move the separator from the first\n\t\t\t// column to after the NUL.\n\t\t\tmch_memmove(p, val + 1, (size_t)len);\n\t\t\tp[len] = sep;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Not a search entry: No separator in the viminfo\n\t\t\t// file, add a NUL separator.\n\t\t\tmch_memmove(p, val, (size_t)len + 1);\n\t\t\tp[len + 1] = NUL;\n\t\t    }\n\t\t    viminfo_history[type][viminfo_hisidx[type]].hisstr = p;\n\t\t    viminfo_history[type][viminfo_hisidx[type]].time_set = 0;\n\t\t    viminfo_history[type][viminfo_hisidx[type]].viminfo = TRUE;\n\t\t    viminfo_history[type][viminfo_hisidx[type]].hisnum = 0;\n\t\t    viminfo_hisidx[type]++;\n\t\t}\n\t    }\n\t}\n\tvim_free(val);\n    }\n    return viminfo_readline(virp);\n}\n\n/*\n * Accept a new style history line from the viminfo, store it in the history\n * array when it's new.\n */\n    static void\nhandle_viminfo_history(\n\tgarray_T    *values,\n\tint\t    writing)\n{\n    int\t\ttype;\n    long_u\tlen;\n    char_u\t*val;\n    char_u\t*p;\n    bval_T\t*vp = (bval_T *)values->ga_data;\n\n    // Check the format:\n    // |{bartype},{histtype},{timestamp},{separator},\"text\"\n    if (values->ga_len < 4\n\t    || vp[0].bv_type != BVAL_NR\n\t    || vp[1].bv_type != BVAL_NR\n\t    || (vp[2].bv_type != BVAL_NR && vp[2].bv_type != BVAL_EMPTY)\n\t    || vp[3].bv_type != BVAL_STRING)\n\treturn;\n\n    type = vp[0].bv_nr;\n    if (type >= HIST_COUNT)\n\treturn;\n    if (viminfo_hisidx[type] < viminfo_hislen[type])\n    {\n\tval = vp[3].bv_string;\n\tif (val != NULL && *val != NUL)\n\t{\n\t    int sep = type == HIST_SEARCH && vp[2].bv_type == BVAL_NR\n\t\t\t\t\t\t      ? vp[2].bv_nr : NUL;\n\t    int idx;\n\t    int overwrite = FALSE;\n\n\t    if (!in_history(type, val, viminfo_add_at_front, sep, writing))\n\t    {\n\t\t// If lines were written by an older Vim we need to avoid\n\t\t// getting duplicates. See if the entry already exists.\n\t\tfor (idx = 0; idx < viminfo_hisidx[type]; ++idx)\n\t\t{\n\t\t    p = viminfo_history[type][idx].hisstr;\n\t\t    if (STRCMP(val, p) == 0\n\t\t\t  && (type != HIST_SEARCH || sep == p[STRLEN(p) + 1]))\n\t\t    {\n\t\t\toverwrite = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tif (!overwrite)\n\t\t{\n\t\t    // Need to re-allocate to append the separator byte.\n\t\t    len = vp[3].bv_len;\n\t\t    p = alloc(len + 2);\n\t\t}\n\t\telse\n\t\t    len = 0; // for picky compilers\n\t\tif (p != NULL)\n\t\t{\n\t\t    viminfo_history[type][idx].time_set = vp[1].bv_nr;\n\t\t    if (!overwrite)\n\t\t    {\n\t\t\tmch_memmove(p, val, (size_t)len + 1);\n\t\t\t// Put the separator after the NUL.\n\t\t\tp[len + 1] = sep;\n\t\t\tviminfo_history[type][idx].hisstr = p;\n\t\t\tviminfo_history[type][idx].hisnum = 0;\n\t\t\tviminfo_history[type][idx].viminfo = TRUE;\n\t\t\tviminfo_hisidx[type]++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Concatenate history lines from viminfo after the lines typed in this Vim.\n */\n    static void\nconcat_history(int type)\n{\n    int\t\tidx;\n    int\t\ti;\n    int\t\thislen = get_hislen();\n    histentry_T *histentry = get_histentry(type);\n    int\t\t*hisidx = get_hisidx(type);\n    int\t\t*hisnum = get_hisnum(type);\n\n    idx = *hisidx + viminfo_hisidx[type];\n    if (idx >= hislen)\n\tidx -= hislen;\n    else if (idx < 0)\n\tidx = hislen - 1;\n    if (viminfo_add_at_front)\n\t*hisidx = idx;\n    else\n    {\n\tif (*hisidx == -1)\n\t    *hisidx = hislen - 1;\n\tdo\n\t{\n\t    if (histentry[idx].hisstr != NULL || histentry[idx].viminfo)\n\t\tbreak;\n\t    if (++idx == hislen)\n\t\tidx = 0;\n\t} while (idx != *hisidx);\n\tif (idx != *hisidx && --idx < 0)\n\t    idx = hislen - 1;\n    }\n    for (i = 0; i < viminfo_hisidx[type]; i++)\n    {\n\tvim_free(histentry[idx].hisstr);\n\thistentry[idx].hisstr = viminfo_history[type][i].hisstr;\n\thistentry[idx].viminfo = TRUE;\n\thistentry[idx].time_set = viminfo_history[type][i].time_set;\n\tif (--idx < 0)\n\t    idx = hislen - 1;\n    }\n    idx += 1;\n    idx %= hislen;\n    for (i = 0; i < viminfo_hisidx[type]; i++)\n    {\n\thistentry[idx++].hisnum = ++*hisnum;\n\tidx %= hislen;\n    }\n}\n\n    static int\nsort_hist(const void *s1, const void *s2)\n{\n    histentry_T *p1 = *(histentry_T **)s1;\n    histentry_T *p2 = *(histentry_T **)s2;\n\n    if (p1->time_set < p2->time_set) return -1;\n    if (p1->time_set > p2->time_set) return 1;\n    return 0;\n}\n\n/*\n * Merge history lines from viminfo and lines typed in this Vim based on the\n * timestamp;\n */\n    static void\nmerge_history(int type)\n{\n    int\t\tmax_len;\n    histentry_T **tot_hist;\n    histentry_T *new_hist;\n    int\t\ti;\n    int\t\tlen;\n    int\t\thislen = get_hislen();\n    histentry_T *histentry = get_histentry(type);\n    int\t\t*hisidx = get_hisidx(type);\n    int\t\t*hisnum = get_hisnum(type);\n\n    // Make one long list with all entries.\n    max_len = hislen + viminfo_hisidx[type];\n    tot_hist = ALLOC_MULT(histentry_T *, max_len);\n    new_hist = ALLOC_MULT(histentry_T, hislen);\n    if (tot_hist == NULL || new_hist == NULL)\n    {\n\tvim_free(tot_hist);\n\tvim_free(new_hist);\n\treturn;\n    }\n    for (i = 0; i < viminfo_hisidx[type]; i++)\n\ttot_hist[i] = &viminfo_history[type][i];\n    len = i;\n    for (i = 0; i < hislen; i++)\n\tif (histentry[i].hisstr != NULL)\n\t    tot_hist[len++] = &histentry[i];\n\n    // Sort the list on timestamp.\n    qsort((void *)tot_hist, (size_t)len, sizeof(histentry_T *), sort_hist);\n\n    // Keep the newest ones.\n    for (i = 0; i < hislen; i++)\n    {\n\tif (i < len)\n\t{\n\t    new_hist[i] = *tot_hist[i];\n\t    tot_hist[i]->hisstr = NULL;\n\t    if (new_hist[i].hisnum == 0)\n\t\tnew_hist[i].hisnum = ++*hisnum;\n\t}\n\telse\n\t    clear_hist_entry(&new_hist[i]);\n    }\n    *hisidx = (i < len ? i : len) - 1;\n\n    // Free what is not kept.\n    for (i = 0; i < viminfo_hisidx[type]; i++)\n\tvim_free(viminfo_history[type][i].hisstr);\n    for (i = 0; i < hislen; i++)\n\tvim_free(histentry[i].hisstr);\n    vim_free(histentry);\n    set_histentry(type, new_hist);\n    vim_free(tot_hist);\n}\n\n/*\n * Finish reading history lines from viminfo.  Not used when writing viminfo.\n */\n    static void\nfinish_viminfo_history(vir_T *virp)\n{\n    int\ttype;\n    int merge = virp->vir_version >= VIMINFO_VERSION_WITH_HISTORY;\n\n    for (type = 0; type < HIST_COUNT; ++type)\n    {\n\tif (get_histentry(type) == NULL)\n\t    continue;\n\n\tif (merge)\n\t    merge_history(type);\n\telse\n\t    concat_history(type);\n\n\tVIM_CLEAR(viminfo_history[type]);\n\tviminfo_hisidx[type] = 0;\n    }\n}\n\n/*\n * Write history to viminfo file in \"fp\".\n * When \"merge\" is TRUE merge history lines with a previously read viminfo\n * file, data is in viminfo_history[].\n * When \"merge\" is FALSE just write all history lines.  Used for \":wviminfo!\".\n */\n    static void\nwrite_viminfo_history(FILE *fp, int merge)\n{\n    int\t    i;\n    int\t    type;\n    int\t    num_saved;\n    int     round;\n    int\t    hislen;\n\n    init_history();\n    hislen = get_hislen();\n    if (hislen == 0)\n\treturn;\n    for (type = 0; type < HIST_COUNT; ++type)\n    {\n\thistentry_T *histentry = get_histentry(type);\n\tint\t    *hisidx = get_hisidx(type);\n\n\tnum_saved = get_viminfo_parameter(hist_type2char(type, FALSE));\n\tif (num_saved == 0)\n\t    continue;\n\tif (num_saved < 0)  // Use default\n\t    num_saved = hislen;\n\tfprintf(fp, _(\"\\n# %s History (newest to oldest):\\n\"),\n\t\t\t    type == HIST_CMD ? _(\"Command Line\") :\n\t\t\t    type == HIST_SEARCH ? _(\"Search String\") :\n\t\t\t    type == HIST_EXPR ? _(\"Expression\") :\n\t\t\t    type == HIST_INPUT ? _(\"Input Line\") :\n\t\t\t\t\t_(\"Debug Line\"));\n\tif (num_saved > hislen)\n\t    num_saved = hislen;\n\n\t// Merge typed and viminfo history:\n\t// round 1: history of typed commands.\n\t// round 2: history from recently read viminfo.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    if (round == 1)\n\t\t// start at newest entry, somewhere in the list\n\t\ti = *hisidx;\n\t    else if (viminfo_hisidx[type] > 0)\n\t\t// start at newest entry, first in the list\n\t\ti = 0;\n\t    else\n\t\t// empty list\n\t\ti = -1;\n\t    if (i >= 0)\n\t\twhile (num_saved > 0\n\t\t\t&& !(round == 2 && i >= viminfo_hisidx[type]))\n\t\t{\n\t\t    char_u  *p;\n\t\t    time_t  timestamp;\n\t\t    int\t    c = NUL;\n\n\t\t    if (round == 1)\n\t\t    {\n\t\t\tp = histentry[i].hisstr;\n\t\t\ttimestamp = histentry[i].time_set;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tp = viminfo_history[type] == NULL ? NULL\n\t\t\t\t\t    : viminfo_history[type][i].hisstr;\n\t\t\ttimestamp = viminfo_history[type] == NULL ? 0\n\t\t\t\t\t  : viminfo_history[type][i].time_set;\n\t\t    }\n\n\t\t    if (p != NULL && (round == 2\n\t\t\t\t       || !merge\n\t\t\t\t       || !histentry[i].viminfo))\n\t\t    {\n\t\t\t--num_saved;\n\t\t\tfputc(hist_type2char(type, TRUE), fp);\n\t\t\t// For the search history: put the separator in the\n\t\t\t// second column; use a space if there isn't one.\n\t\t\tif (type == HIST_SEARCH)\n\t\t\t{\n\t\t\t    c = p[STRLEN(p) + 1];\n\t\t\t    putc(c == NUL ? ' ' : c, fp);\n\t\t\t}\n\t\t\tviminfo_writestring(fp, p);\n\n\t\t\t{\n\t\t\t    char    cbuf[NUMBUFLEN];\n\n\t\t\t    // New style history with a bar line. Format:\n\t\t\t    // |{bartype},{histtype},{timestamp},{separator},\"text\"\n\t\t\t    if (c == NUL)\n\t\t\t\tcbuf[0] = NUL;\n\t\t\t    else\n\t\t\t\tsprintf(cbuf, \"%d\", c);\n\t\t\t    fprintf(fp, \"|%d,%d,%ld,%s,\", BARTYPE_HISTORY,\n\t\t\t\t\t\t type, (long)timestamp, cbuf);\n\t\t\t    barline_writestring(fp, p, LSIZE - 20);\n\t\t\t    putc('\\n', fp);\n\t\t\t}\n\t\t    }\n\t\t    if (round == 1)\n\t\t    {\n\t\t\t// Decrement index, loop around and stop when back at\n\t\t\t// the start.\n\t\t\tif (--i < 0)\n\t\t\t    i = hislen - 1;\n\t\t\tif (i == *hisidx)\n\t\t\t    break;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// Increment index. Stop at the end in the while.\n\t\t\t++i;\n\t\t    }\n\t\t}\n\t}\n\tfor (i = 0; i < viminfo_hisidx[type]; ++i)\n\t    if (viminfo_history[type] != NULL)\n\t\tvim_free(viminfo_history[type][i].hisstr);\n\tVIM_CLEAR(viminfo_history[type]);\n\tviminfo_hisidx[type] = 0;\n    }\n}\n\n    static void\nwrite_viminfo_barlines(vir_T *virp, FILE *fp_out)\n{\n    int\t\ti;\n    garray_T\t*gap = &virp->vir_barlines;\n    int\t\tseen_useful = FALSE;\n    char\t*line;\n\n    if (gap->ga_len > 0)\n    {\n\tfputs(_(\"\\n# Bar lines, copied verbatim:\\n\"), fp_out);\n\n\t// Skip over continuation lines until seeing a useful line.\n\tfor (i = 0; i < gap->ga_len; ++i)\n\t{\n\t    line = ((char **)(gap->ga_data))[i];\n\t    if (seen_useful || line[1] != '<')\n\t    {\n\t\tfputs(line, fp_out);\n\t\tseen_useful = TRUE;\n\t    }\n\t}\n    }\n}\n\n/*\n * Parse a viminfo line starting with '|'.\n * Add each decoded value to \"values\".\n * Returns TRUE if the next line is to be read after using the parsed values.\n */\n    static int\nbarline_parse(vir_T *virp, char_u *text, garray_T *values)\n{\n    char_u  *p = text;\n    char_u  *nextp = NULL;\n    char_u  *buf = NULL;\n    bval_T  *value;\n    int\t    i;\n    int\t    allocated = FALSE;\n    int\t    eof;\n    char_u  *sconv;\n    int\t    converted;\n\n    while (*p == ',')\n    {\n\t++p;\n\tif (ga_grow(values, 1) == FAIL)\n\t    break;\n\tvalue = (bval_T *)(values->ga_data) + values->ga_len;\n\n\tif (*p == '>')\n\t{\n\t    // Need to read a continuation line.  Put strings in allocated\n\t    // memory, because virp->vir_line is overwritten.\n\t    if (!allocated)\n\t    {\n\t\tfor (i = 0; i < values->ga_len; ++i)\n\t\t{\n\t\t    bval_T  *vp = (bval_T *)(values->ga_data) + i;\n\n\t\t    if (vp->bv_type == BVAL_STRING && !vp->bv_allocated)\n\t\t    {\n\t\t\tvp->bv_string = vim_strnsave(vp->bv_string, vp->bv_len);\n\t\t\tvp->bv_allocated = TRUE;\n\t\t    }\n\t\t}\n\t\tallocated = TRUE;\n\t    }\n\n\t    if (vim_isdigit(p[1]))\n\t    {\n\t\tsize_t len;\n\t\tsize_t todo;\n\t\tsize_t n;\n\n\t\t// String value was split into lines that are each shorter\n\t\t// than LSIZE:\n\t\t//     |{bartype},>{length of \"{text}{text2}\"}\n\t\t//     |<\"{text1}\n\t\t//     |<{text2}\",{value}\n\t\t// Length includes the quotes.\n\t\t++p;\n\t\tlen = getdigits(&p);\n\t\tbuf = alloc((int)(len + 1));\n\t\tif (buf == NULL)\n\t\t    return TRUE;\n\t\tp = buf;\n\t\tfor (todo = len; todo > 0; todo -= n)\n\t\t{\n\t\t    eof = viminfo_readline(virp);\n\t\t    if (eof || virp->vir_line[0] != '|'\n\t\t\t\t\t\t  || virp->vir_line[1] != '<')\n\t\t    {\n\t\t\t// File was truncated or garbled. Read another line if\n\t\t\t// this one starts with '|'.\n\t\t\tvim_free(buf);\n\t\t\treturn eof || virp->vir_line[0] == '|';\n\t\t    }\n\t\t    // Get length of text, excluding |< and NL chars.\n\t\t    n = STRLEN(virp->vir_line);\n\t\t    while (n > 0 && (virp->vir_line[n - 1] == NL\n\t\t\t\t\t     || virp->vir_line[n - 1] == CAR))\n\t\t\t--n;\n\t\t    n -= 2;\n\t\t    if (n > todo)\n\t\t    {\n\t\t\t// more values follow after the string\n\t\t\tnextp = virp->vir_line + 2 + todo;\n\t\t\tn = todo;\n\t\t    }\n\t\t    mch_memmove(p, virp->vir_line + 2, n);\n\t\t    p += n;\n\t\t}\n\t\t*p = NUL;\n\t\tp = buf;\n\t    }\n\t    else\n\t    {\n\t\t// Line ending in \">\" continues in the next line:\n\t\t//     |{bartype},{lots of values},>\n\t\t//     |<{value},{value}\n\t\teof = viminfo_readline(virp);\n\t\tif (eof || virp->vir_line[0] != '|'\n\t\t\t\t\t      || virp->vir_line[1] != '<')\n\t\t    // File was truncated or garbled. Read another line if\n\t\t    // this one starts with '|'.\n\t\t    return eof || virp->vir_line[0] == '|';\n\t\tp = virp->vir_line + 2;\n\t    }\n\t}\n\n\tif (isdigit(*p))\n\t{\n\t    value->bv_type = BVAL_NR;\n\t    value->bv_nr = getdigits(&p);\n\t    ++values->ga_len;\n\t}\n\telse if (*p == '\"')\n\t{\n\t    int\t    len = 0;\n\t    char_u  *s = p;\n\n\t    // Unescape special characters in-place.\n\t    ++p;\n\t    while (*p != '\"')\n\t    {\n\t\tif (*p == NL || *p == NUL)\n\t\t    return TRUE;  // syntax error, drop the value\n\t\tif (*p == '\\\\')\n\t\t{\n\t\t    ++p;\n\t\t    if (*p == 'n')\n\t\t\ts[len++] = '\\n';\n\t\t    else\n\t\t\ts[len++] = *p;\n\t\t    ++p;\n\t\t}\n\t\telse\n\t\t    s[len++] = *p++;\n\t    }\n\t    ++p;\n\t    s[len] = NUL;\n\n\t    converted = FALSE;\n\t    value->bv_tofree = NULL;\n\t    if (virp->vir_conv.vc_type != CONV_NONE && *s != NUL)\n\t    {\n\t\tsconv = string_convert(&virp->vir_conv, s, NULL);\n\t\tif (sconv != NULL)\n\t\t{\n\t\t    if (s == buf)\n\t\t\t// the converted string is stored in bv_string and\n\t\t\t// freed later, also need to free \"buf\" later\n\t\t\tvalue->bv_tofree = buf;\n\t\t    s = sconv;\n\t\t    converted = TRUE;\n\t\t}\n\t    }\n\n\t    // Need to copy in allocated memory if the string wasn't allocated\n\t    // above and we did allocate before, thus vir_line may change.\n\t    if (s != buf && allocated && !converted)\n\t\ts = vim_strsave(s);\n\t    value->bv_string = s;\n\t    value->bv_type = BVAL_STRING;\n\t    value->bv_len = len;\n\t    value->bv_allocated = allocated || converted;\n\t    ++values->ga_len;\n\t    if (nextp != NULL)\n\t    {\n\t\t// values following a long string\n\t\tp = nextp;\n\t\tnextp = NULL;\n\t    }\n\t}\n\telse if (*p == ',')\n\t{\n\t    value->bv_type = BVAL_EMPTY;\n\t    ++values->ga_len;\n\t}\n\telse\n\t    break;\n    }\n    return TRUE;\n}\n\n    static void\nwrite_viminfo_version(FILE *fp_out)\n{\n    fprintf(fp_out, \"# Viminfo version\\n|%d,%d\\n\\n\",\n\t\t\t\t\t    BARTYPE_VERSION, VIMINFO_VERSION);\n}\n\n    static int\nno_viminfo(void)\n{\n    // \"vim -i NONE\" does not read or write a viminfo file\n    return STRCMP(p_viminfofile, \"NONE\") == 0;\n}\n\n/*\n * Report an error for reading a viminfo file.\n * Count the number of errors.\tWhen there are more than 10, return TRUE.\n */\n    static int\nviminfo_error(char *errnum, char *message, char_u *line)\n{\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"%sviminfo: %s in line: \"),\n\t\t\t\t\t\t\t     errnum, message);\n    STRNCAT(IObuff, line, IOSIZE - STRLEN(IObuff) - 1);\n    if (IObuff[STRLEN(IObuff) - 1] == '\\n')\n\tIObuff[STRLEN(IObuff) - 1] = NUL;\n    emsg((char *)IObuff);\n    if (++viminfo_errcnt >= 10)\n    {\n\temsg(_(e_viminfo_too_many_errors_skipping_rest_of_file));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Compare the 'encoding' value in the viminfo file with the current value of\n * 'encoding'.  If different and the 'c' flag is in 'viminfo', setup for\n * conversion of text with iconv() in viminfo_readstring().\n */\n    static int\nviminfo_encoding(vir_T *virp)\n{\n    char_u\t*p;\n    int\t\ti;\n\n    if (get_viminfo_parameter('c') != 0)\n    {\n\tp = vim_strchr(virp->vir_line, '=');\n\tif (p != NULL)\n\t{\n\t    // remove trailing newline\n\t    ++p;\n\t    for (i = 0; vim_isprintc(p[i]); ++i)\n\t\t;\n\t    p[i] = NUL;\n\n\t    convert_setup(&virp->vir_conv, p, p_enc);\n\t}\n    }\n    return viminfo_readline(virp);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Restore global vars that start with a capital from the viminfo file\n */\n    static int\nread_viminfo_varlist(vir_T *virp, int writing)\n{\n    char_u\t*tab;\n    int\t\ttype = VAR_NUMBER;\n    typval_T\ttv;\n    funccal_entry_T funccal_entry;\n\n    if (!writing && (find_viminfo_parameter('!') != NULL))\n    {\n\ttab = vim_strchr(virp->vir_line + 1, '\\t');\n\tif (tab != NULL)\n\t{\n\t    *tab++ = '\\0';\t// isolate the variable name\n\t    switch (*tab)\n\t    {\n\t\tcase 'S': type = VAR_STRING; break;\n#ifdef FEAT_FLOAT\n\t\tcase 'F': type = VAR_FLOAT; break;\n#endif\n\t\tcase 'D': type = VAR_DICT; break;\n\t\tcase 'L': type = VAR_LIST; break;\n\t\tcase 'B': type = VAR_BLOB; break;\n\t\tcase 'X': type = VAR_SPECIAL; break;\n\t    }\n\n\t    tab = vim_strchr(tab, '\\t');\n\t    if (tab != NULL)\n\t    {\n\t\ttv.v_type = type;\n\t\tif (type == VAR_STRING || type == VAR_DICT\n\t\t\t|| type == VAR_LIST || type == VAR_BLOB)\n\t\t    tv.vval.v_string = viminfo_readstring(virp,\n\t\t\t\t       (int)(tab - virp->vir_line + 1), TRUE);\n#ifdef FEAT_FLOAT\n\t\telse if (type == VAR_FLOAT)\n\t\t    (void)string2float(tab + 1, &tv.vval.v_float, FALSE);\n#endif\n\t\telse\n\t\t{\n\t\t    tv.vval.v_number = atol((char *)tab + 1);\n\t\t    if (type == VAR_SPECIAL && (tv.vval.v_number == VVAL_FALSE\n\t\t\t\t\t     || tv.vval.v_number == VVAL_TRUE))\n\t\t\ttv.v_type = VAR_BOOL;\n\t\t}\n\t\tif (type == VAR_DICT || type == VAR_LIST)\n\t\t{\n\t\t    typval_T *etv = eval_expr(tv.vval.v_string, NULL);\n\n\t\t    if (etv == NULL)\n\t\t\t// Failed to parse back the dict or list, use it as a\n\t\t\t// string.\n\t\t\ttv.v_type = VAR_STRING;\n\t\t    else\n\t\t    {\n\t\t\tvim_free(tv.vval.v_string);\n\t\t\ttv = *etv;\n\t\t\tvim_free(etv);\n\t\t    }\n\t\t}\n\t\telse if (type == VAR_BLOB)\n\t\t{\n\t\t    blob_T *blob = string2blob(tv.vval.v_string);\n\n\t\t    if (blob == NULL)\n\t\t\t// Failed to parse back the blob, use it as a string.\n\t\t\ttv.v_type = VAR_STRING;\n\t\t    else\n\t\t    {\n\t\t\tvim_free(tv.vval.v_string);\n\t\t\ttv.v_type = VAR_BLOB;\n\t\t\ttv.vval.v_blob = blob;\n\t\t    }\n\t\t}\n\n\t\t// when in a function use global variables\n\t\tsave_funccal(&funccal_entry);\n\t\tset_var(virp->vir_line + 1, &tv, FALSE);\n\t\trestore_funccal();\n\n\t\tif (tv.v_type == VAR_STRING)\n\t\t    vim_free(tv.vval.v_string);\n\t\telse if (tv.v_type == VAR_DICT || tv.v_type == VAR_LIST ||\n\t\t\ttv.v_type == VAR_BLOB)\n\t\t    clear_tv(&tv);\n\t    }\n\t}\n    }\n\n    return viminfo_readline(virp);\n}\n\n/*\n * Write global vars that start with a capital to the viminfo file\n */\n    static void\nwrite_viminfo_varlist(FILE *fp)\n{\n    hashtab_T\t*gvht = get_globvar_ht();\n    hashitem_T\t*hi;\n    dictitem_T\t*this_var;\n    int\t\ttodo;\n    char\t*s = \"\";\n    char_u\t*p;\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    if (find_viminfo_parameter('!') == NULL)\n\treturn;\n\n    fputs(_(\"\\n# global variables:\\n\"), fp);\n\n    todo = (int)gvht->ht_used;\n    for (hi = gvht->ht_array; todo > 0; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    this_var = HI2DI(hi);\n\t    if (var_flavour(this_var->di_key) == VAR_FLAVOUR_VIMINFO)\n\t    {\n\t\tswitch (this_var->di_tv.v_type)\n\t\t{\n\t\t    case VAR_STRING:  s = \"STR\"; break;\n\t\t    case VAR_NUMBER:  s = \"NUM\"; break;\n\t\t    case VAR_FLOAT:   s = \"FLO\"; break;\n\t\t    case VAR_DICT:\n\t\t\t  {\n\t\t\t      dict_T\t*di = this_var->di_tv.vval.v_dict;\n\t\t\t      int\tcopyID = get_copyID();\n\n\t\t\t      s = \"DIC\";\n\t\t\t      if (di != NULL && !set_ref_in_ht(\n\t\t\t\t\t\t &di->dv_hashtab, copyID, NULL)\n\t\t\t\t      && di->dv_copyID == copyID)\n\t\t\t\t  // has a circular reference, can't turn the\n\t\t\t\t  // value into a string\n\t\t\t\t  continue;\n\t\t\t      break;\n\t\t\t  }\n\t\t    case VAR_LIST:\n\t\t\t  {\n\t\t\t      list_T\t*l = this_var->di_tv.vval.v_list;\n\t\t\t      int\tcopyID = get_copyID();\n\n\t\t\t      s = \"LIS\";\n\t\t\t      if (l != NULL && !set_ref_in_list_items(\n\t\t\t\t\t\t\t       l, copyID, NULL)\n\t\t\t\t      && l->lv_copyID == copyID)\n\t\t\t\t  // has a circular reference, can't turn the\n\t\t\t\t  // value into a string\n\t\t\t\t  continue;\n\t\t\t      break;\n\t\t\t  }\n\t\t    case VAR_BLOB:    s = \"BLO\"; break;\n\t\t    case VAR_BOOL:    s = \"XPL\"; break;  // backwards compat.\n\t\t    case VAR_SPECIAL: s = \"XPL\"; break;\n\n\t\t    case VAR_UNKNOWN:\n\t\t    case VAR_ANY:\n\t\t    case VAR_VOID:\n\t\t    case VAR_FUNC:\n\t\t    case VAR_PARTIAL:\n\t\t    case VAR_JOB:\n\t\t    case VAR_CHANNEL:\n\t\t    case VAR_INSTR:\n\t\t\t\t     continue;\n\t\t}\n\t\tfprintf(fp, \"!%s\\t%s\\t\", this_var->di_key, s);\n\t\tif (this_var->di_tv.v_type == VAR_BOOL\n\t\t\t\t      || this_var->di_tv.v_type == VAR_SPECIAL)\n\t\t{\n\t\t    // do not use \"v:true\" but \"1\"\n\t\t    sprintf((char *)numbuf, \"%ld\",\n\t\t\t\t\t  (long)this_var->di_tv.vval.v_number);\n\t\t    p = numbuf;\n\t\t    tofree = NULL;\n\t\t}\n\t\telse\n\t\t    p = echo_string(&this_var->di_tv, &tofree, numbuf, 0);\n\t\tif (p != NULL)\n\t\t    viminfo_writestring(fp, p);\n\t\tvim_free(tofree);\n\t    }\n\t}\n    }\n}\n#endif // FEAT_EVAL\n\n    static int\nread_viminfo_sub_string(vir_T *virp, int force)\n{\n    if (force || get_old_sub() == NULL)\n\tset_old_sub(viminfo_readstring(virp, 1, TRUE));\n    return viminfo_readline(virp);\n}\n\n    static void\nwrite_viminfo_sub_string(FILE *fp)\n{\n    char_u *old_sub = get_old_sub();\n\n    if (get_viminfo_parameter('/') != 0 && old_sub != NULL)\n    {\n\tfputs(_(\"\\n# Last Substitute String:\\n$\"), fp);\n\tviminfo_writestring(fp, old_sub);\n    }\n}\n\n/*\n * Functions relating to reading/writing the search pattern from viminfo\n */\n\n    static int\nread_viminfo_search_pattern(vir_T *virp, int force)\n{\n    char_u\t*lp;\n    int\t\tidx = -1;\n    int\t\tmagic = FALSE;\n    int\t\tno_scs = FALSE;\n    int\t\toff_line = FALSE;\n    int\t\toff_end = 0;\n    long\toff = 0;\n    int\t\tsetlast = FALSE;\n#ifdef FEAT_SEARCH_EXTRA\n    static int\thlsearch_on = FALSE;\n#endif\n    char_u\t*val;\n    spat_T\t*spat;\n\n    // Old line types:\n    // \"/pat\", \"&pat\": search/subst. pat\n    // \"~/pat\", \"~&pat\": last used search/subst. pat\n    // New line types:\n    // \"~h\", \"~H\": hlsearch highlighting off/on\n    // \"~<magic><smartcase><line><end><off><last><which>pat\"\n    // <magic>: 'm' off, 'M' on\n    // <smartcase>: 's' off, 'S' on\n    // <line>: 'L' line offset, 'l' char offset\n    // <end>: 'E' from end, 'e' from start\n    // <off>: decimal, offset\n    // <last>: '~' last used pattern\n    // <which>: '/' search pat, '&' subst. pat\n    lp = virp->vir_line;\n    if (lp[0] == '~' && (lp[1] == 'm' || lp[1] == 'M'))\t// new line type\n    {\n\tif (lp[1] == 'M')\t\t// magic on\n\t    magic = TRUE;\n\tif (lp[2] == 's')\n\t    no_scs = TRUE;\n\tif (lp[3] == 'L')\n\t    off_line = TRUE;\n\tif (lp[4] == 'E')\n\t    off_end = SEARCH_END;\n\tlp += 5;\n\toff = getdigits(&lp);\n    }\n    if (lp[0] == '~')\t\t// use this pattern for last-used pattern\n    {\n\tsetlast = TRUE;\n\tlp++;\n    }\n    if (lp[0] == '/')\n\tidx = RE_SEARCH;\n    else if (lp[0] == '&')\n\tidx = RE_SUBST;\n#ifdef FEAT_SEARCH_EXTRA\n    else if (lp[0] == 'h')\t// ~h: 'hlsearch' highlighting off\n\thlsearch_on = FALSE;\n    else if (lp[0] == 'H')\t// ~H: 'hlsearch' highlighting on\n\thlsearch_on = TRUE;\n#endif\n    if (idx >= 0)\n    {\n\tspat = get_spat(idx);\n\tif (force || spat->pat == NULL)\n\t{\n\t    val = viminfo_readstring(virp, (int)(lp - virp->vir_line + 1),\n\t\t\t\t\t\t\t\t\tTRUE);\n\t    if (val != NULL)\n\t    {\n\t\tset_last_search_pat(val, idx, magic, setlast);\n\t\tvim_free(val);\n\t\tspat->no_scs = no_scs;\n\t\tspat->off.line = off_line;\n\t\tspat->off.end = off_end;\n\t\tspat->off.off = off;\n#ifdef FEAT_SEARCH_EXTRA\n\t\tif (setlast)\n\t\t    set_no_hlsearch(!hlsearch_on);\n#endif\n\t    }\n\t}\n    }\n    return viminfo_readline(virp);\n}\n\n    static void\nwvsp_one(\n    FILE\t*fp,\t// file to write to\n    int\t\tidx,\t// spats[] index\n    char\t*s,\t// search pat\n    int\t\tsc)\t// dir char\n{\n    spat_T\t*spat = get_spat(idx);\n    if (spat->pat != NULL)\n    {\n\tfprintf(fp, _(\"\\n# Last %sSearch Pattern:\\n~\"), s);\n\t// off.dir is not stored, it's reset to forward\n\tfprintf(fp, \"%c%c%c%c%ld%s%c\",\n\t\tspat->magic    ? 'M' : 'm',\t// magic\n\t\tspat->no_scs   ? 's' : 'S',\t// smartcase\n\t\tspat->off.line ? 'L' : 'l',\t// line offset\n\t\tspat->off.end  ? 'E' : 'e',\t// offset from end\n\t\tspat->off.off,\t\t\t// offset\n\t\tget_spat_last_idx() == idx ? \"~\" : \"\",\t// last used pat\n\t\tsc);\n\tviminfo_writestring(fp, spat->pat);\n    }\n}\n\n    static void\nwrite_viminfo_search_pattern(FILE *fp)\n{\n    if (get_viminfo_parameter('/') != 0)\n    {\n#ifdef FEAT_SEARCH_EXTRA\n\tfprintf(fp, \"\\n# hlsearch on (H) or off (h):\\n~%c\",\n\t    (no_hlsearch || find_viminfo_parameter('h') != NULL) ? 'h' : 'H');\n#endif\n\twvsp_one(fp, RE_SEARCH, \"\", '/');\n\twvsp_one(fp, RE_SUBST, _(\"Substitute \"), '&');\n    }\n}\n\n/*\n * Functions relating to reading/writing registers from viminfo\n */\n\nstatic yankreg_T *y_read_regs = NULL;\n\n#define REG_PREVIOUS 1\n#define REG_EXEC 2\n\n/*\n * Prepare for reading viminfo registers when writing viminfo later.\n */\n    static void\nprepare_viminfo_registers(void)\n{\n     y_read_regs = ALLOC_CLEAR_MULT(yankreg_T, NUM_REGISTERS);\n}\n\n    static void\nfinish_viminfo_registers(void)\n{\n    int\t\ti;\n    int\t\tj;\n\n    if (y_read_regs != NULL)\n    {\n\tfor (i = 0; i < NUM_REGISTERS; ++i)\n\t    if (y_read_regs[i].y_array != NULL)\n\t    {\n\t\tfor (j = 0; j < y_read_regs[i].y_size; j++)\n\t\t    vim_free(y_read_regs[i].y_array[j]);\n\t\tvim_free(y_read_regs[i].y_array);\n\t    }\n\tVIM_CLEAR(y_read_regs);\n    }\n}\n\n    static int\nread_viminfo_register(vir_T *virp, int force)\n{\n    int\t\teof;\n    int\t\tdo_it = TRUE;\n    int\t\tsize;\n    int\t\tlimit;\n    int\t\ti;\n    int\t\tset_prev = FALSE;\n    char_u\t*str;\n    char_u\t**array = NULL;\n    int\t\tnew_type = MCHAR; // init to shut up compiler\n    colnr_T\tnew_width = 0; // init to shut up compiler\n    yankreg_T\t*y_current_p;\n\n    // We only get here (hopefully) if line[0] == '\"'\n    str = virp->vir_line + 1;\n\n    // If the line starts with \"\" this is the y_previous register.\n    if (*str == '\"')\n    {\n\tset_prev = TRUE;\n\tstr++;\n    }\n\n    if (!ASCII_ISALNUM(*str) && *str != '-')\n    {\n\tif (viminfo_error(\"E577: \", _(e_illegal_register_name), virp->vir_line))\n\t    return TRUE;\t// too many errors, pretend end-of-file\n\tdo_it = FALSE;\n    }\n    get_yank_register(*str++, FALSE);\n    y_current_p = get_y_current();\n    if (!force && y_current_p->y_array != NULL)\n\tdo_it = FALSE;\n\n    if (*str == '@')\n    {\n\t// \"x@: register x used for @@\n\tif (force || get_execreg_lastc() == NUL)\n\t    set_execreg_lastc(str[-1]);\n    }\n\n    size = 0;\n    limit = 100;\t// Optimized for registers containing <= 100 lines\n    if (do_it)\n    {\n\t// Build the new register in array[].\n\t// y_array is kept as-is until done.\n\t// The \"do_it\" flag is reset when something is wrong, in which case\n\t// array[] needs to be freed.\n\tif (set_prev)\n\t    set_y_previous(y_current_p);\n\tarray = ALLOC_MULT(char_u *, limit);\n\tstr = skipwhite(skiptowhite(str));\n\tif (STRNCMP(str, \"CHAR\", 4) == 0)\n\t    new_type = MCHAR;\n\telse if (STRNCMP(str, \"BLOCK\", 5) == 0)\n\t    new_type = MBLOCK;\n\telse\n\t    new_type = MLINE;\n\t// get the block width; if it's missing we get a zero, which is OK\n\tstr = skipwhite(skiptowhite(str));\n\tnew_width = getdigits(&str);\n    }\n\n    while (!(eof = viminfo_readline(virp))\n\t\t    && (virp->vir_line[0] == TAB || virp->vir_line[0] == '<'))\n    {\n\tif (do_it)\n\t{\n\t    if (size == limit)\n\t    {\n\t\tchar_u **new_array = (char_u **)\n\t\t\t\t\t   alloc(limit * 2 * sizeof(char_u *));\n\n\t\tif (new_array == NULL)\n\t\t{\n\t\t    do_it = FALSE;\n\t\t    break;\n\t\t}\n\t\tfor (i = 0; i < limit; i++)\n\t\t    new_array[i] = array[i];\n\t\tvim_free(array);\n\t\tarray = new_array;\n\t\tlimit *= 2;\n\t    }\n\t    str = viminfo_readstring(virp, 1, TRUE);\n\t    if (str != NULL)\n\t\tarray[size++] = str;\n\t    else\n\t\t// error, don't store the result\n\t\tdo_it = FALSE;\n\t}\n    }\n\n    if (do_it)\n    {\n\t// free y_array[]\n\tfor (i = 0; i < y_current_p->y_size; i++)\n\t    vim_free(y_current_p->y_array[i]);\n\tvim_free(y_current_p->y_array);\n\n\ty_current_p->y_type = new_type;\n\ty_current_p->y_width = new_width;\n\ty_current_p->y_size = size;\n\ty_current_p->y_time_set = 0;\n\tif (size == 0)\n\t{\n\t    y_current_p->y_array = NULL;\n\t}\n\telse\n\t{\n\t    // Move the lines from array[] to y_array[].\n\t    y_current_p->y_array = ALLOC_MULT(char_u *, size);\n\t    for (i = 0; i < size; i++)\n\t    {\n\t\tif (y_current_p->y_array == NULL)\n\t\t    vim_free(array[i]);\n\t\telse\n\t\t    y_current_p->y_array[i] = array[i];\n\t    }\n\t}\n    }\n    else\n    {\n\t// Free array[] if it was filled.\n\tfor (i = 0; i < size; i++)\n\t    vim_free(array[i]);\n    }\n    vim_free(array);\n\n    return eof;\n}\n\n/*\n * Accept a new style register line from the viminfo, store it when it's new.\n */\n    static void\nhandle_viminfo_register(garray_T *values, int force)\n{\n    bval_T\t*vp = (bval_T *)values->ga_data;\n    int\t\tflags;\n    int\t\tname;\n    int\t\ttype;\n    int\t\tlinecount;\n    int\t\twidth;\n    time_t\ttimestamp;\n    yankreg_T\t*y_ptr;\n    yankreg_T\t*y_regs_p = get_y_regs();\n    int\t\ti;\n\n    // Check the format:\n    // |{bartype},{flags},{name},{type},\n    //      {linecount},{width},{timestamp},\"line1\",\"line2\"\n    if (values->ga_len < 6\n\t    || vp[0].bv_type != BVAL_NR\n\t    || vp[1].bv_type != BVAL_NR\n\t    || vp[2].bv_type != BVAL_NR\n\t    || vp[3].bv_type != BVAL_NR\n\t    || vp[4].bv_type != BVAL_NR\n\t    || vp[5].bv_type != BVAL_NR)\n\treturn;\n    flags = vp[0].bv_nr;\n    name = vp[1].bv_nr;\n    if (name < 0 || name >= NUM_REGISTERS)\n\treturn;\n    type = vp[2].bv_nr;\n    if (type != MCHAR && type != MLINE && type != MBLOCK)\n\treturn;\n    linecount = vp[3].bv_nr;\n    if (values->ga_len < 6 + linecount)\n\treturn;\n    width = vp[4].bv_nr;\n    if (width < 0)\n\treturn;\n\n    if (y_read_regs != NULL)\n\t// Reading viminfo for merging and writing.  Store the register\n\t// content, don't update the current registers.\n\ty_ptr = &y_read_regs[name];\n    else\n\ty_ptr = &y_regs_p[name];\n\n    // Do not overwrite unless forced or the timestamp is newer.\n    timestamp = (time_t)vp[5].bv_nr;\n    if (y_ptr->y_array != NULL && !force\n\t\t\t && (timestamp == 0 || y_ptr->y_time_set > timestamp))\n\treturn;\n\n    if (y_ptr->y_array != NULL)\n\tfor (i = 0; i < y_ptr->y_size; i++)\n\t    vim_free(y_ptr->y_array[i]);\n    vim_free(y_ptr->y_array);\n\n    if (y_read_regs == NULL)\n    {\n\tif (flags & REG_PREVIOUS)\n\t    set_y_previous(y_ptr);\n\tif ((flags & REG_EXEC) && (force || get_execreg_lastc() == NUL))\n\t    set_execreg_lastc(get_register_name(name));\n    }\n    y_ptr->y_type = type;\n    y_ptr->y_width = width;\n    y_ptr->y_size = linecount;\n    y_ptr->y_time_set = timestamp;\n    if (linecount == 0)\n    {\n\ty_ptr->y_array = NULL;\n\treturn;\n    }\n    y_ptr->y_array = ALLOC_MULT(char_u *, linecount);\n    if (y_ptr->y_array == NULL)\n    {\n\ty_ptr->y_size = 0; // ensure object state is consistent\n\treturn;\n    }\n    for (i = 0; i < linecount; i++)\n    {\n\tif (vp[i + 6].bv_allocated)\n\t{\n\t    y_ptr->y_array[i] = vp[i + 6].bv_string;\n\t    vp[i + 6].bv_string = NULL;\n\t}\n\telse\n\t    y_ptr->y_array[i] = vim_strsave(vp[i + 6].bv_string);\n    }\n}\n\n    static void\nwrite_viminfo_registers(FILE *fp)\n{\n    int\t\ti, j;\n    char_u\t*type;\n    char_u\tc;\n    int\t\tnum_lines;\n    int\t\tmax_num_lines;\n    int\t\tmax_kbyte;\n    long\tlen;\n    yankreg_T\t*y_ptr;\n    yankreg_T\t*y_regs_p = get_y_regs();;\n\n    fputs(_(\"\\n# Registers:\\n\"), fp);\n\n    // Get '<' value, use old '\"' value if '<' is not found.\n    max_num_lines = get_viminfo_parameter('<');\n    if (max_num_lines < 0)\n\tmax_num_lines = get_viminfo_parameter('\"');\n    if (max_num_lines == 0)\n\treturn;\n    max_kbyte = get_viminfo_parameter('s');\n    if (max_kbyte == 0)\n\treturn;\n\n    for (i = 0; i < NUM_REGISTERS; i++)\n    {\n#ifdef FEAT_CLIPBOARD\n\t// Skip '*'/'+' register, we don't want them back next time\n\tif (i == STAR_REGISTER || i == PLUS_REGISTER)\n\t    continue;\n#endif\n#ifdef FEAT_DND\n\t// Neither do we want the '~' register\n\tif (i == TILDE_REGISTER)\n\t    continue;\n#endif\n\t// When reading viminfo for merging and writing: Use the register from\n\t// viminfo if it's newer.\n\tif (y_read_regs != NULL\n\t\t&& y_read_regs[i].y_array != NULL\n\t\t&& (y_regs_p[i].y_array == NULL ||\n\t\t\t    y_read_regs[i].y_time_set > y_regs_p[i].y_time_set))\n\t    y_ptr = &y_read_regs[i];\n\telse if (y_regs_p[i].y_array == NULL)\n\t    continue;\n\telse\n\t    y_ptr = &y_regs_p[i];\n\n\t// Skip empty registers.\n\tnum_lines = y_ptr->y_size;\n\tif (num_lines == 0\n\t\t|| (num_lines == 1 && y_ptr->y_type == MCHAR\n\t\t\t\t\t&& *y_ptr->y_array[0] == NUL))\n\t    continue;\n\n\tif (max_kbyte > 0)\n\t{\n\t    // Skip register if there is more text than the maximum size.\n\t    len = 0;\n\t    for (j = 0; j < num_lines; j++)\n\t\tlen += (long)STRLEN(y_ptr->y_array[j]) + 1L;\n\t    if (len > (long)max_kbyte * 1024L)\n\t\tcontinue;\n\t}\n\n\tswitch (y_ptr->y_type)\n\t{\n\t    case MLINE:\n\t\ttype = (char_u *)\"LINE\";\n\t\tbreak;\n\t    case MCHAR:\n\t\ttype = (char_u *)\"CHAR\";\n\t\tbreak;\n\t    case MBLOCK:\n\t\ttype = (char_u *)\"BLOCK\";\n\t\tbreak;\n\t    default:\n\t\tsemsg(_(e_unknown_register_type_nr), y_ptr->y_type);\n\t\ttype = (char_u *)\"LINE\";\n\t\tbreak;\n\t}\n\tif (get_y_previous() == &y_regs_p[i])\n\t    fprintf(fp, \"\\\"\");\n\tc = get_register_name(i);\n\tfprintf(fp, \"\\\"%c\", c);\n\tif (c == get_execreg_lastc())\n\t    fprintf(fp, \"@\");\n\tfprintf(fp, \"\\t%s\\t%d\\n\", type, (int)y_ptr->y_width);\n\n\t// If max_num_lines < 0, then we save ALL the lines in the register\n\tif (max_num_lines > 0 && num_lines > max_num_lines)\n\t    num_lines = max_num_lines;\n\tfor (j = 0; j < num_lines; j++)\n\t{\n\t    putc('\\t', fp);\n\t    viminfo_writestring(fp, y_ptr->y_array[j]);\n\t}\n\n\t{\n\t    int\t    flags = 0;\n\t    int\t    remaining;\n\n\t    // New style with a bar line. Format:\n\t    // |{bartype},{flags},{name},{type},\n\t    //      {linecount},{width},{timestamp},\"line1\",\"line2\"\n\t    // flags: REG_PREVIOUS - register is y_previous\n\t    //\t      REG_EXEC - used for @@\n\t    if (get_y_previous() == &y_regs_p[i])\n\t\tflags |= REG_PREVIOUS;\n\t    if (c == get_execreg_lastc())\n\t\tflags |= REG_EXEC;\n\t    fprintf(fp, \"|%d,%d,%d,%d,%d,%d,%ld\", BARTYPE_REGISTER, flags,\n\t\t    i, y_ptr->y_type, num_lines, (int)y_ptr->y_width,\n\t\t    (long)y_ptr->y_time_set);\n\t    // 11 chars for type/flags/name/type, 3 * 20 for numbers\n\t    remaining = LSIZE - 71;\n\t    for (j = 0; j < num_lines; j++)\n\t    {\n\t\tputc(',', fp);\n\t\t--remaining;\n\t\tremaining = barline_writestring(fp, y_ptr->y_array[j],\n\t\t\t\t\t\t\t\t   remaining);\n\t    }\n\t    putc('\\n', fp);\n\t}\n    }\n}\n\n/*\n * Functions relating to reading/writing marks from viminfo\n */\n\nstatic xfmark_T *vi_namedfm = NULL;\nstatic xfmark_T *vi_jumplist = NULL;\nstatic int vi_jumplist_len = 0;\n\n    static void\nwrite_one_mark(FILE *fp_out, int c, pos_T *pos)\n{\n    if (pos->lnum != 0)\n\tfprintf(fp_out, \"\\t%c\\t%ld\\t%d\\n\", c, (long)pos->lnum, (int)pos->col);\n}\n\n    static void\nwrite_buffer_marks(buf_T *buf, FILE *fp_out)\n{\n    int\t\ti;\n    pos_T\tpos;\n\n    home_replace(NULL, buf->b_ffname, IObuff, IOSIZE, TRUE);\n    fprintf(fp_out, \"\\n> \");\n    viminfo_writestring(fp_out, IObuff);\n\n    // Write the last used timestamp as the lnum of the non-existing mark '*'.\n    // Older Vims will ignore it and/or copy it.\n    pos.lnum = (linenr_T)buf->b_last_used;\n    pos.col = 0;\n    write_one_mark(fp_out, '*', &pos);\n\n    write_one_mark(fp_out, '\"', &buf->b_last_cursor);\n    write_one_mark(fp_out, '^', &buf->b_last_insert);\n    write_one_mark(fp_out, '.', &buf->b_last_change);\n    // changelist positions are stored oldest first\n    for (i = 0; i < buf->b_changelistlen; ++i)\n    {\n\t// skip duplicates\n\tif (i == 0 || !EQUAL_POS(buf->b_changelist[i - 1],\n\t\t\t\t\t\t\t buf->b_changelist[i]))\n\t    write_one_mark(fp_out, '+', &buf->b_changelist[i]);\n    }\n    for (i = 0; i < NMARKS; i++)\n\twrite_one_mark(fp_out, 'a' + i, &buf->b_namedm[i]);\n}\n\n/*\n * Return TRUE if marks for \"buf\" should not be written.\n */\n    static int\nskip_for_viminfo(buf_T *buf)\n{\n    return\n#ifdef FEAT_TERMINAL\n\t    bt_terminal(buf) ||\n#endif\n\t    removable(buf->b_ffname);\n}\n\n/*\n * Write all the named marks for all buffers.\n * When \"buflist\" is not NULL fill it with the buffers for which marks are to\n * be written.\n */\n    static void\nwrite_viminfo_marks(FILE *fp_out, garray_T *buflist)\n{\n    buf_T\t*buf;\n    int\t\tis_mark_set;\n    int\t\ti;\n    win_T\t*win;\n    tabpage_T\t*tp;\n\n    // Set b_last_cursor for the all buffers that have a window.\n    FOR_ALL_TAB_WINDOWS(tp, win)\n\tset_last_cursor(win);\n\n    fputs(_(\"\\n# History of marks within files (newest to oldest):\\n\"), fp_out);\n    FOR_ALL_BUFFERS(buf)\n    {\n\t// Only write something if buffer has been loaded and at least one\n\t// mark is set.\n\tif (buf->b_marks_read)\n\t{\n\t    if (buf->b_last_cursor.lnum != 0)\n\t\tis_mark_set = TRUE;\n\t    else\n\t    {\n\t\tis_mark_set = FALSE;\n\t\tfor (i = 0; i < NMARKS; i++)\n\t\t    if (buf->b_namedm[i].lnum != 0)\n\t\t    {\n\t\t\tis_mark_set = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t    if (is_mark_set && buf->b_ffname != NULL\n\t\t      && buf->b_ffname[0] != NUL\n\t\t      && !skip_for_viminfo(buf))\n\t    {\n\t\tif (buflist == NULL)\n\t\t    write_buffer_marks(buf, fp_out);\n\t\telse if (ga_grow(buflist, 1) == OK)\n\t\t    ((buf_T **)buflist->ga_data)[buflist->ga_len++] = buf;\n\t    }\n\t}\n    }\n}\n\n    static void\nwrite_one_filemark(\n    FILE\t*fp,\n    xfmark_T\t*fm,\n    int\t\tc1,\n    int\t\tc2)\n{\n    char_u\t*name;\n\n    if (fm->fmark.mark.lnum == 0)\t// not set\n\treturn;\n\n    if (fm->fmark.fnum != 0)\t\t// there is a buffer\n\tname = buflist_nr2name(fm->fmark.fnum, TRUE, FALSE);\n    else\n\tname = fm->fname;\t\t// use name from .viminfo\n    if (name != NULL && *name != NUL)\n    {\n\tfprintf(fp, \"%c%c  %ld  %ld  \", c1, c2, (long)fm->fmark.mark.lnum,\n\t\t\t\t\t\t    (long)fm->fmark.mark.col);\n\tviminfo_writestring(fp, name);\n\n\t// Barline: |{bartype},{name},{lnum},{col},{timestamp},{filename}\n\t// size up to filename: 8 + 3 * 20\n\tfprintf(fp, \"|%d,%d,%ld,%ld,%ld,\", BARTYPE_MARK, c2,\n\t\t(long)fm->fmark.mark.lnum, (long)fm->fmark.mark.col,\n\t\t(long)fm->time_set);\n\tbarline_writestring(fp, name, LSIZE - 70);\n\tputc('\\n', fp);\n    }\n\n    if (fm->fmark.fnum != 0)\n\tvim_free(name);\n}\n\n    static void\nwrite_viminfo_filemarks(FILE *fp)\n{\n    int\t\ti;\n    char_u\t*name;\n    buf_T\t*buf;\n    xfmark_T\t*namedfm_p = get_namedfm();\n    xfmark_T\t*fm;\n    int\t\tvi_idx;\n    int\t\tidx;\n\n    if (get_viminfo_parameter('f') == 0)\n\treturn;\n\n    fputs(_(\"\\n# File marks:\\n\"), fp);\n\n    // Write the filemarks 'A - 'Z\n    for (i = 0; i < NMARKS; i++)\n    {\n\tif (vi_namedfm != NULL\n\t\t\t&& (vi_namedfm[i].time_set > namedfm_p[i].time_set))\n\t    fm = &vi_namedfm[i];\n\telse\n\t    fm = &namedfm_p[i];\n\twrite_one_filemark(fp, fm, '\\'', i + 'A');\n    }\n\n    // Find a mark that is the same file and position as the cursor.\n    // That one, or else the last one is deleted.\n    // Move '0 to '1, '1 to '2, etc. until the matching one or '9\n    // Set the '0 mark to current cursor position.\n    if (curbuf->b_ffname != NULL && !skip_for_viminfo(curbuf))\n    {\n\tname = buflist_nr2name(curbuf->b_fnum, TRUE, FALSE);\n\tfor (i = NMARKS; i < NMARKS + EXTRA_MARKS - 1; ++i)\n\t    if (namedfm_p[i].fmark.mark.lnum == curwin->w_cursor.lnum\n\t\t    && (namedfm_p[i].fname == NULL\n\t\t\t    ? namedfm_p[i].fmark.fnum == curbuf->b_fnum\n\t\t\t    : (name != NULL\n\t\t\t\t    && STRCMP(name, namedfm_p[i].fname) == 0)))\n\t\tbreak;\n\tvim_free(name);\n\n\tvim_free(namedfm_p[i].fname);\n\tfor ( ; i > NMARKS; --i)\n\t    namedfm_p[i] = namedfm_p[i - 1];\n\tnamedfm_p[NMARKS].fmark.mark = curwin->w_cursor;\n\tnamedfm_p[NMARKS].fmark.fnum = curbuf->b_fnum;\n\tnamedfm_p[NMARKS].fname = NULL;\n\tnamedfm_p[NMARKS].time_set = vim_time();\n    }\n\n    // Write the filemarks '0 - '9.  Newest (highest timestamp) first.\n    vi_idx = NMARKS;\n    idx = NMARKS;\n    for (i = NMARKS; i < NMARKS + EXTRA_MARKS; i++)\n    {\n\txfmark_T *vi_fm = vi_namedfm != NULL ? &vi_namedfm[vi_idx] : NULL;\n\n\tif (vi_fm != NULL\n\t\t&& vi_fm->fmark.mark.lnum != 0\n\t\t&& (vi_fm->time_set > namedfm_p[idx].time_set\n\t\t    || namedfm_p[idx].fmark.mark.lnum == 0))\n\t{\n\t    fm = vi_fm;\n\t    ++vi_idx;\n\t}\n\telse\n\t{\n\t    fm = &namedfm_p[idx++];\n\t    if (vi_fm != NULL\n\t\t  && vi_fm->fmark.mark.lnum == fm->fmark.mark.lnum\n\t\t  && vi_fm->time_set == fm->time_set\n\t\t  && ((vi_fm->fmark.fnum != 0\n\t\t\t  && vi_fm->fmark.fnum == fm->fmark.fnum)\n\t\t      || (vi_fm->fname != NULL\n\t\t\t  && fm->fname != NULL\n\t\t\t  && STRCMP(vi_fm->fname, fm->fname) == 0)))\n\t\t++vi_idx;  // skip duplicate\n\t}\n\twrite_one_filemark(fp, fm, '\\'', i - NMARKS + '0');\n    }\n\n    // Write the jumplist with -'\n    fputs(_(\"\\n# Jumplist (newest first):\\n\"), fp);\n    setpcmark();\t// add current cursor position\n    cleanup_jumplist(curwin, FALSE);\n    vi_idx = 0;\n    idx = curwin->w_jumplistlen - 1;\n    for (i = 0; i < JUMPLISTSIZE; ++i)\n    {\n\txfmark_T\t*vi_fm;\n\n\tfm = idx >= 0 ? &curwin->w_jumplist[idx] : NULL;\n\tvi_fm = (vi_jumplist != NULL && vi_idx < vi_jumplist_len)\n\t\t\t\t\t? &vi_jumplist[vi_idx] : NULL;\n\tif (fm == NULL && vi_fm == NULL)\n\t    break;\n\tif (fm == NULL || (vi_fm != NULL && fm->time_set < vi_fm->time_set))\n\t{\n\t    fm = vi_fm;\n\t    ++vi_idx;\n\t}\n\telse\n\t    --idx;\n\tif (fm->fmark.fnum == 0\n\t\t|| ((buf = buflist_findnr(fm->fmark.fnum)) != NULL\n\t\t    && !skip_for_viminfo(buf)))\n\t    write_one_filemark(fp, fm, '-', '\\'');\n    }\n}\n\n/*\n * Compare functions for qsort() below, that compares b_last_used.\n */\n    int\nbuf_compare(const void *s1, const void *s2)\n{\n    buf_T *buf1 = *(buf_T **)s1;\n    buf_T *buf2 = *(buf_T **)s2;\n\n    if (buf1->b_last_used == buf2->b_last_used)\n\treturn 0;\n    return buf1->b_last_used > buf2->b_last_used ? -1 : 1;\n}\n\n/*\n * Handle marks in the viminfo file:\n * fp_out != NULL: copy marks, in time order with buffers in \"buflist\".\n * fp_out == NULL && (flags & VIF_WANT_MARKS): read marks for curbuf\n * fp_out == NULL && (flags & VIF_ONLY_CURBUF): bail out after curbuf marks\n * fp_out == NULL && (flags & VIF_GET_OLDFILES | VIF_FORCEIT): fill v:oldfiles\n */\n    static void\ncopy_viminfo_marks(\n    vir_T\t*virp,\n    FILE\t*fp_out,\n    garray_T\t*buflist,\n    int\t\teof,\n    int\t\tflags)\n{\n    char_u\t*line = virp->vir_line;\n    buf_T\t*buf;\n    int\t\tnum_marked_files;\n    int\t\tload_marks;\n    int\t\tcopy_marks_out;\n    char_u\t*str;\n    int\t\ti;\n    char_u\t*p;\n    char_u\t*name_buf;\n    pos_T\tpos;\n#ifdef FEAT_EVAL\n    list_T\t*list = NULL;\n#endif\n    int\t\tcount = 0;\n    int\t\tbuflist_used = 0;\n    buf_T\t*buflist_buf = NULL;\n\n    if ((name_buf = alloc(LSIZE)) == NULL)\n\treturn;\n    *name_buf = NUL;\n\n    if (fp_out != NULL && buflist->ga_len > 0)\n    {\n\t// Sort the list of buffers on b_last_used.\n\tqsort(buflist->ga_data, (size_t)buflist->ga_len,\n\t\t\t\t\t\tsizeof(buf_T *), buf_compare);\n\tbuflist_buf = ((buf_T **)buflist->ga_data)[0];\n    }\n\n#ifdef FEAT_EVAL\n    if (fp_out == NULL && (flags & (VIF_GET_OLDFILES | VIF_FORCEIT)))\n    {\n\tlist = list_alloc();\n\tif (list != NULL)\n\t    set_vim_var_list(VV_OLDFILES, list);\n    }\n#endif\n\n    num_marked_files = get_viminfo_parameter('\\'');\n    while (!eof && (count < num_marked_files || fp_out == NULL))\n    {\n\tif (line[0] != '>')\n\t{\n\t    if (line[0] != '\\n' && line[0] != '\\r' && line[0] != '#')\n\t    {\n\t\tif (viminfo_error(\"E576: \", _(e_nonr_missing_gt), line))\n\t\t    break;\t// too many errors, return now\n\t    }\n\t    eof = vim_fgets(line, LSIZE, virp->vir_fd);\n\t    continue;\t\t// Skip this dud line\n\t}\n\n\t// Handle long line and translate escaped characters.\n\t// Find file name, set str to start.\n\t// Ignore leading and trailing white space.\n\tstr = skipwhite(line + 1);\n\tstr = viminfo_readstring(virp, (int)(str - virp->vir_line), FALSE);\n\tif (str == NULL)\n\t    continue;\n\tp = str + STRLEN(str);\n\twhile (p != str && (*p == NUL || vim_isspace(*p)))\n\t    p--;\n\tif (*p)\n\t    p++;\n\t*p = NUL;\n\n#ifdef FEAT_EVAL\n\tif (list != NULL)\n\t    list_append_string(list, str, -1);\n#endif\n\n\t// If fp_out == NULL, load marks for current buffer.\n\t// If fp_out != NULL, copy marks for buffers not in buflist.\n\tload_marks = copy_marks_out = FALSE;\n\tif (fp_out == NULL)\n\t{\n\t    if ((flags & VIF_WANT_MARKS) && curbuf->b_ffname != NULL)\n\t    {\n\t\tif (*name_buf == NUL)\t    // only need to do this once\n\t\t    home_replace(NULL, curbuf->b_ffname, name_buf, LSIZE, TRUE);\n\t\tif (fnamecmp(str, name_buf) == 0)\n\t\t    load_marks = TRUE;\n\t    }\n\t}\n\telse // fp_out != NULL\n\t{\n\t    // This is slow if there are many buffers!!\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_ffname != NULL)\n\t\t{\n\t\t    home_replace(NULL, buf->b_ffname, name_buf, LSIZE, TRUE);\n\t\t    if (fnamecmp(str, name_buf) == 0)\n\t\t\tbreak;\n\t\t}\n\n\t    // Copy marks if the buffer has not been loaded.\n\t    if (buf == NULL || !buf->b_marks_read)\n\t    {\n\t\tint\tdid_read_line = FALSE;\n\n\t\tif (buflist_buf != NULL)\n\t\t{\n\t\t    // Read the next line.  If it has the \"*\" mark compare the\n\t\t    // time stamps.  Write entries from \"buflist\" that are\n\t\t    // newer.\n\t\t    if (!(eof = viminfo_readline(virp)) && line[0] == TAB)\n\t\t    {\n\t\t\tdid_read_line = TRUE;\n\t\t\tif (line[1] == '*')\n\t\t\t{\n\t\t\t    long\tltime;\n\n\t\t\t    sscanf((char *)line + 2, \"%ld \", &ltime);\n\t\t\t    while ((time_T)ltime < buflist_buf->b_last_used)\n\t\t\t    {\n\t\t\t\twrite_buffer_marks(buflist_buf, fp_out);\n\t\t\t\tif (++count >= num_marked_files)\n\t\t\t\t    break;\n\t\t\t\tif (++buflist_used == buflist->ga_len)\n\t\t\t\t{\n\t\t\t\t    buflist_buf = NULL;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\tbuflist_buf =\n\t\t\t\t   ((buf_T **)buflist->ga_data)[buflist_used];\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // No timestamp, must be written by an older Vim.\n\t\t\t    // Assume all remaining buffers are older than\n\t\t\t    // ours.\n\t\t\t    while (count < num_marked_files\n\t\t\t\t\t    && buflist_used < buflist->ga_len)\n\t\t\t    {\n\t\t\t\tbuflist_buf = ((buf_T **)buflist->ga_data)\n\t\t\t\t\t\t\t     [buflist_used++];\n\t\t\t\twrite_buffer_marks(buflist_buf, fp_out);\n\t\t\t\t++count;\n\t\t\t    }\n\t\t\t    buflist_buf = NULL;\n\t\t\t}\n\n\t\t\tif (count >= num_marked_files)\n\t\t\t{\n\t\t\t    vim_free(str);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tfputs(\"\\n> \", fp_out);\n\t\tviminfo_writestring(fp_out, str);\n\t\tif (did_read_line)\n\t\t    fputs((char *)line, fp_out);\n\n\t\tcount++;\n\t\tcopy_marks_out = TRUE;\n\t    }\n\t}\n\tvim_free(str);\n\n\tpos.coladd = 0;\n\twhile (!(eof = viminfo_readline(virp)) && line[0] == TAB)\n\t{\n\t    if (load_marks)\n\t    {\n\t\tif (line[1] != NUL)\n\t\t{\n\t\t    unsigned u;\n\n\t\t    sscanf((char *)line + 2, \"%ld %u\", &pos.lnum, &u);\n\t\t    pos.col = u;\n\t\t    switch (line[1])\n\t\t    {\n\t\t\tcase '\"': curbuf->b_last_cursor = pos; break;\n\t\t\tcase '^': curbuf->b_last_insert = pos; break;\n\t\t\tcase '.': curbuf->b_last_change = pos; break;\n\t\t\tcase '+':\n\t\t\t\t  // changelist positions are stored oldest\n\t\t\t\t  // first\n\t\t\t\t  if (curbuf->b_changelistlen == JUMPLISTSIZE)\n\t\t\t\t      // list is full, remove oldest entry\n\t\t\t\t      mch_memmove(curbuf->b_changelist,\n\t\t\t\t\t    curbuf->b_changelist + 1,\n\t\t\t\t\t    sizeof(pos_T) * (JUMPLISTSIZE - 1));\n\t\t\t\t  else\n\t\t\t\t      ++curbuf->b_changelistlen;\n\t\t\t\t  curbuf->b_changelist[\n\t\t\t\t\t   curbuf->b_changelistlen - 1] = pos;\n\t\t\t\t  break;\n\n\t\t\t\t  // Using the line number for the last-used\n\t\t\t\t  // timestamp.\n\t\t\tcase '*': curbuf->b_last_used = pos.lnum; break;\n\n\t\t\tdefault:  if ((i = line[1] - 'a') >= 0 && i < NMARKS)\n\t\t\t\t      curbuf->b_namedm[i] = pos;\n\t\t    }\n\t\t}\n\t    }\n\t    else if (copy_marks_out)\n\t\tfputs((char *)line, fp_out);\n\t}\n\n\tif (load_marks)\n\t{\n\t    win_T\t*wp;\n\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp->w_buffer == curbuf)\n\t\t    wp->w_changelistidx = curbuf->b_changelistlen;\n\t    }\n\t    if (flags & VIF_ONLY_CURBUF)\n\t\tbreak;\n\t}\n    }\n\n    if (fp_out != NULL)\n\t// Write any remaining entries from buflist.\n\twhile (count < num_marked_files && buflist_used < buflist->ga_len)\n\t{\n\t    buflist_buf = ((buf_T **)buflist->ga_data)[buflist_used++];\n\t    write_buffer_marks(buflist_buf, fp_out);\n\t    ++count;\n\t}\n\n    vim_free(name_buf);\n}\n\n/*\n * Read marks for the current buffer from the viminfo file, when we support\n * buffer marks and the buffer has a name.\n */\n    void\ncheck_marks_read(void)\n{\n    if (!curbuf->b_marks_read && get_viminfo_parameter('\\'') > 0\n\t\t\t\t\t\t  && curbuf->b_ffname != NULL)\n\tread_viminfo(NULL, VIF_WANT_MARKS | VIF_ONLY_CURBUF);\n\n    // Always set b_marks_read; needed when 'viminfo' is changed to include\n    // the ' parameter after opening a buffer.\n    curbuf->b_marks_read = TRUE;\n}\n\n    static int\nread_viminfo_filemark(vir_T *virp, int force)\n{\n    char_u\t*str;\n    xfmark_T\t*namedfm_p = get_namedfm();\n    xfmark_T\t*fm;\n    int\t\ti;\n\n    // We only get here if line[0] == '\\'' or '-'.\n    // Illegal mark names are ignored (for future expansion).\n    str = virp->vir_line + 1;\n    if (\n#ifndef EBCDIC\n\t    *str <= 127 &&\n#endif\n\t    ((*virp->vir_line == '\\'' && (VIM_ISDIGIT(*str) || isupper(*str)))\n\t     || (*virp->vir_line == '-' && *str == '\\'')))\n    {\n\tif (*str == '\\'')\n\t{\n\t    // If the jumplist isn't full insert fmark as oldest entry\n\t    if (curwin->w_jumplistlen == JUMPLISTSIZE)\n\t\tfm = NULL;\n\t    else\n\t    {\n\t\tfor (i = curwin->w_jumplistlen; i > 0; --i)\n\t\t    curwin->w_jumplist[i] = curwin->w_jumplist[i - 1];\n\t\t++curwin->w_jumplistidx;\n\t\t++curwin->w_jumplistlen;\n\t\tfm = &curwin->w_jumplist[0];\n\t\tfm->fmark.mark.lnum = 0;\n\t\tfm->fname = NULL;\n\t    }\n\t}\n\telse if (VIM_ISDIGIT(*str))\n\t    fm = &namedfm_p[*str - '0' + NMARKS];\n\telse\n\t    fm = &namedfm_p[*str - 'A'];\n\tif (fm != NULL && (fm->fmark.mark.lnum == 0 || force))\n\t{\n\t    str = skipwhite(str + 1);\n\t    fm->fmark.mark.lnum = getdigits(&str);\n\t    str = skipwhite(str);\n\t    fm->fmark.mark.col = getdigits(&str);\n\t    fm->fmark.mark.coladd = 0;\n\t    fm->fmark.fnum = 0;\n\t    str = skipwhite(str);\n\t    vim_free(fm->fname);\n\t    fm->fname = viminfo_readstring(virp, (int)(str - virp->vir_line),\n\t\t\t\t\t\t\t\t       FALSE);\n\t    fm->time_set = 0;\n\t}\n    }\n    return vim_fgets(virp->vir_line, LSIZE, virp->vir_fd);\n}\n\n/*\n * Prepare for reading viminfo marks when writing viminfo later.\n */\n    static void\nprepare_viminfo_marks(void)\n{\n    vi_namedfm = ALLOC_CLEAR_MULT(xfmark_T, NMARKS + EXTRA_MARKS);\n    vi_jumplist = ALLOC_CLEAR_MULT(xfmark_T, JUMPLISTSIZE);\n    vi_jumplist_len = 0;\n}\n\n    static void\nfinish_viminfo_marks(void)\n{\n    int\t\ti;\n\n    if (vi_namedfm != NULL)\n    {\n\tfor (i = 0; i < NMARKS + EXTRA_MARKS; ++i)\n\t    vim_free(vi_namedfm[i].fname);\n\tVIM_CLEAR(vi_namedfm);\n    }\n    if (vi_jumplist != NULL)\n    {\n\tfor (i = 0; i < vi_jumplist_len; ++i)\n\t    vim_free(vi_jumplist[i].fname);\n\tVIM_CLEAR(vi_jumplist);\n    }\n}\n\n/*\n * Accept a new style mark line from the viminfo, store it when it's new.\n */\n    static void\nhandle_viminfo_mark(garray_T *values, int force)\n{\n    bval_T\t*vp = (bval_T *)values->ga_data;\n    int\t\tname;\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    time_t\ttimestamp;\n    xfmark_T\t*fm = NULL;\n\n    // Check the format:\n    // |{bartype},{name},{lnum},{col},{timestamp},{filename}\n    if (values->ga_len < 5\n\t    || vp[0].bv_type != BVAL_NR\n\t    || vp[1].bv_type != BVAL_NR\n\t    || vp[2].bv_type != BVAL_NR\n\t    || vp[3].bv_type != BVAL_NR\n\t    || vp[4].bv_type != BVAL_STRING)\n\treturn;\n\n    name = vp[0].bv_nr;\n    if (name != '\\'' && !VIM_ISDIGIT(name) && !ASCII_ISUPPER(name))\n\treturn;\n    lnum = vp[1].bv_nr;\n    col = vp[2].bv_nr;\n    if (lnum <= 0 || col < 0)\n\treturn;\n    timestamp = (time_t)vp[3].bv_nr;\n\n    if (name == '\\'')\n    {\n\tif (vi_jumplist != NULL)\n\t{\n\t    if (vi_jumplist_len < JUMPLISTSIZE)\n\t\tfm = &vi_jumplist[vi_jumplist_len++];\n\t}\n\telse\n\t{\n\t    int idx;\n\t    int i;\n\n\t    // If we have a timestamp insert it in the right place.\n\t    if (timestamp != 0)\n\t    {\n\t\tfor (idx = curwin->w_jumplistlen - 1; idx >= 0; --idx)\n\t\t    if (curwin->w_jumplist[idx].time_set < timestamp)\n\t\t    {\n\t\t\t++idx;\n\t\t\tbreak;\n\t\t    }\n\t\t// idx cannot be zero now\n\t\tif (idx < 0 && curwin->w_jumplistlen < JUMPLISTSIZE)\n\t\t    // insert as the oldest entry\n\t\t    idx = 0;\n\t    }\n\t    else if (curwin->w_jumplistlen < JUMPLISTSIZE)\n\t\t// insert as oldest entry\n\t\tidx = 0;\n\t    else\n\t\tidx = -1;\n\n\t    if (idx >= 0)\n\t    {\n\t\tif (curwin->w_jumplistlen == JUMPLISTSIZE)\n\t\t{\n\t\t    // Drop the oldest entry.\n\t\t    --idx;\n\t\t    vim_free(curwin->w_jumplist[0].fname);\n\t\t    for (i = 0; i < idx; ++i)\n\t\t\tcurwin->w_jumplist[i] = curwin->w_jumplist[i + 1];\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Move newer entries forward.\n\t\t    for (i = curwin->w_jumplistlen; i > idx; --i)\n\t\t\tcurwin->w_jumplist[i] = curwin->w_jumplist[i - 1];\n\t\t    ++curwin->w_jumplistidx;\n\t\t    ++curwin->w_jumplistlen;\n\t\t}\n\t\tfm = &curwin->w_jumplist[idx];\n\t\tfm->fmark.mark.lnum = 0;\n\t\tfm->fname = NULL;\n\t\tfm->time_set = 0;\n\t    }\n\t}\n    }\n    else\n    {\n\tint\t\tidx;\n\txfmark_T\t*namedfm_p = get_namedfm();\n\n\tif (VIM_ISDIGIT(name))\n\t{\n\t    if (vi_namedfm != NULL)\n\t\tidx = name - '0' + NMARKS;\n\t    else\n\t    {\n\t\tint i;\n\n\t\t// Do not use the name from the viminfo file, insert in time\n\t\t// order.\n\t\tfor (idx = NMARKS; idx < NMARKS + EXTRA_MARKS; ++idx)\n\t\t    if (namedfm_p[idx].time_set < timestamp)\n\t\t\tbreak;\n\t\tif (idx == NMARKS + EXTRA_MARKS)\n\t\t    // All existing entries are newer.\n\t\t    return;\n\t\ti = NMARKS + EXTRA_MARKS - 1;\n\n\t\tvim_free(namedfm_p[i].fname);\n\t\tfor ( ; i > idx; --i)\n\t\t    namedfm_p[i] = namedfm_p[i - 1];\n\t\tnamedfm_p[idx].fname = NULL;\n\t    }\n\t}\n\telse\n\t    idx = name - 'A';\n\tif (vi_namedfm != NULL)\n\t    fm = &vi_namedfm[idx];\n\telse\n\t    fm = &namedfm_p[idx];\n    }\n\n    if (fm != NULL)\n    {\n\tif (vi_namedfm != NULL || fm->fmark.mark.lnum == 0\n\t\t\t\t\t  || fm->time_set < timestamp || force)\n\t{\n\t    fm->fmark.mark.lnum = lnum;\n\t    fm->fmark.mark.col = col;\n\t    fm->fmark.mark.coladd = 0;\n\t    fm->fmark.fnum = 0;\n\t    vim_free(fm->fname);\n\t    if (vp[4].bv_allocated)\n\t    {\n\t\tfm->fname = vp[4].bv_string;\n\t\tvp[4].bv_string = NULL;\n\t    }\n\t    else\n\t\tfm->fname = vim_strsave(vp[4].bv_string);\n\t    fm->time_set = timestamp;\n\t}\n    }\n}\n\n    static int\nread_viminfo_barline(vir_T *virp, int got_encoding, int force, int writing)\n{\n    char_u\t*p = virp->vir_line + 1;\n    int\t\tbartype;\n    garray_T\tvalues;\n    bval_T\t*vp;\n    int\t\ti;\n    int\t\tread_next = TRUE;\n\n    // The format is: |{bartype},{value},...\n    // For a very long string:\n    //     |{bartype},>{length of \"{text}{text2}\"}\n    //     |<{text1}\n    //     |<{text2},{value}\n    // For a long line not using a string\n    //     |{bartype},{lots of values},>\n    //     |<{value},{value}\n    if (*p == '<')\n    {\n\t// Continuation line of an unrecognized item.\n\tif (writing)\n\t    ga_copy_string(&virp->vir_barlines, virp->vir_line);\n    }\n    else\n    {\n\tga_init2(&values, sizeof(bval_T), 20);\n\tbartype = getdigits(&p);\n\tswitch (bartype)\n\t{\n\t    case BARTYPE_VERSION:\n\t\t// Only use the version when it comes before the encoding.\n\t\t// If it comes later it was copied by a Vim version that\n\t\t// doesn't understand the version.\n\t\tif (!got_encoding)\n\t\t{\n\t\t    read_next = barline_parse(virp, p, &values);\n\t\t    vp = (bval_T *)values.ga_data;\n\t\t    if (values.ga_len > 0 && vp->bv_type == BVAL_NR)\n\t\t\tvirp->vir_version = vp->bv_nr;\n\t\t}\n\t\tbreak;\n\n\t    case BARTYPE_HISTORY:\n\t\tread_next = barline_parse(virp, p, &values);\n\t\thandle_viminfo_history(&values, writing);\n\t\tbreak;\n\n\t    case BARTYPE_REGISTER:\n\t\tread_next = barline_parse(virp, p, &values);\n\t\thandle_viminfo_register(&values, force);\n\t\tbreak;\n\n\t    case BARTYPE_MARK:\n\t\tread_next = barline_parse(virp, p, &values);\n\t\thandle_viminfo_mark(&values, force);\n\t\tbreak;\n\n\t    default:\n\t\t// copy unrecognized line (for future use)\n\t\tif (writing)\n\t\t    ga_copy_string(&virp->vir_barlines, virp->vir_line);\n\t}\n\tfor (i = 0; i < values.ga_len; ++i)\n\t{\n\t    vp = (bval_T *)values.ga_data + i;\n\t    if (vp->bv_type == BVAL_STRING && vp->bv_allocated)\n\t\tvim_free(vp->bv_string);\n\t    vim_free(vp->bv_tofree);\n\t}\n\tga_clear(&values);\n    }\n\n    if (read_next)\n\treturn viminfo_readline(virp);\n    return FALSE;\n}\n\n/*\n * read_viminfo_up_to_marks() -- Only called from do_viminfo().  Reads in the\n * first part of the viminfo file which contains everything but the marks that\n * are local to a file.  Returns TRUE when end-of-file is reached. -- webb\n */\n    static int\nread_viminfo_up_to_marks(\n    vir_T\t*virp,\n    int\t\tforceit,\n    int\t\twriting)\n{\n    int\t\teof;\n    buf_T\t*buf;\n    int\t\tgot_encoding = FALSE;\n\n    prepare_viminfo_history(forceit ? 9999 : 0, writing);\n\n    eof = viminfo_readline(virp);\n    while (!eof && virp->vir_line[0] != '>')\n    {\n\tswitch (virp->vir_line[0])\n\t{\n\t\t// Characters reserved for future expansion, ignored now\n\t    case '+': // \"+40 /path/dir file\", for running vim without args\n\t    case '^': // to be defined\n\t    case '<': // long line - ignored\n\t\t// A comment or empty line.\n\t    case NUL:\n\t    case '\\r':\n\t    case '\\n':\n\t    case '#':\n\t\teof = viminfo_readline(virp);\n\t\tbreak;\n\t    case '|':\n\t\teof = read_viminfo_barline(virp, got_encoding,\n\t\t\t\t\t\t\t    forceit, writing);\n\t\tbreak;\n\t    case '*': // \"*encoding=value\"\n\t\tgot_encoding = TRUE;\n\t\teof = viminfo_encoding(virp);\n\t\tbreak;\n\t    case '!': // global variable\n#ifdef FEAT_EVAL\n\t\teof = read_viminfo_varlist(virp, writing);\n#else\n\t\teof = viminfo_readline(virp);\n#endif\n\t\tbreak;\n\t    case '%': // entry for buffer list\n\t\teof = read_viminfo_bufferlist(virp, writing);\n\t\tbreak;\n\t    case '\"':\n\t\t// When registers are in bar lines skip the old style register\n\t\t// lines.\n\t\tif (virp->vir_version < VIMINFO_VERSION_WITH_REGISTERS)\n\t\t    eof = read_viminfo_register(virp, forceit);\n\t\telse\n\t\t    do {\n\t\t\teof = viminfo_readline(virp);\n\t\t    } while (!eof && (virp->vir_line[0] == TAB\n\t\t\t\t\t\t|| virp->vir_line[0] == '<'));\n\t\tbreak;\n\t    case '/':\t    // Search string\n\t    case '&':\t    // Substitute search string\n\t    case '~':\t    // Last search string, followed by '/' or '&'\n\t\teof = read_viminfo_search_pattern(virp, forceit);\n\t\tbreak;\n\t    case '$':\n\t\teof = read_viminfo_sub_string(virp, forceit);\n\t\tbreak;\n\t    case ':':\n\t    case '?':\n\t    case '=':\n\t    case '@':\n\t\t// When history is in bar lines skip the old style history\n\t\t// lines.\n\t\tif (virp->vir_version < VIMINFO_VERSION_WITH_HISTORY)\n\t\t    eof = read_viminfo_history(virp, writing);\n\t\telse\n\t\t    eof = viminfo_readline(virp);\n\t\tbreak;\n\t    case '-':\n\t    case '\\'':\n\t\t// When file marks are in bar lines skip the old style lines.\n\t\tif (virp->vir_version < VIMINFO_VERSION_WITH_MARKS)\n\t\t    eof = read_viminfo_filemark(virp, forceit);\n\t\telse\n\t\t    eof = viminfo_readline(virp);\n\t\tbreak;\n\t    default:\n\t\tif (viminfo_error(\"E575: \", _(e_illegal_starting_char),\n\t\t\t    virp->vir_line))\n\t\t    eof = TRUE;\n\t\telse\n\t\t    eof = viminfo_readline(virp);\n\t\tbreak;\n\t}\n    }\n\n    // Finish reading history items.\n    if (!writing)\n\tfinish_viminfo_history(virp);\n\n    // Change file names to buffer numbers for fmarks.\n    FOR_ALL_BUFFERS(buf)\n\tfmarks_check_names(buf);\n\n    return eof;\n}\n\n/*\n * do_viminfo() -- Should only be called from read_viminfo() & write_viminfo().\n */\n    static void\ndo_viminfo(FILE *fp_in, FILE *fp_out, int flags)\n{\n    int\t\teof = FALSE;\n    vir_T\tvir;\n    int\t\tmerge = FALSE;\n    int\t\tdo_copy_marks = FALSE;\n    garray_T\tbuflist;\n\n    if ((vir.vir_line = alloc(LSIZE)) == NULL)\n\treturn;\n    vir.vir_fd = fp_in;\n    vir.vir_conv.vc_type = CONV_NONE;\n    ga_init2(&vir.vir_barlines, (int)sizeof(char_u *), 100);\n    vir.vir_version = -1;\n\n    if (fp_in != NULL)\n    {\n\tif (flags & VIF_WANT_INFO)\n\t{\n\t    if (fp_out != NULL)\n\t    {\n\t\t// Registers and marks are read and kept separate from what\n\t\t// this Vim is using.  They are merged when writing.\n\t\tprepare_viminfo_registers();\n\t\tprepare_viminfo_marks();\n\t    }\n\n\t    eof = read_viminfo_up_to_marks(&vir,\n\t\t\t\t\t flags & VIF_FORCEIT, fp_out != NULL);\n\t    merge = TRUE;\n\t}\n\telse if (flags != 0)\n\t    // Skip info, find start of marks\n\t    while (!(eof = viminfo_readline(&vir))\n\t\t    && vir.vir_line[0] != '>')\n\t\t;\n\n\tdo_copy_marks = (flags & (VIF_WANT_MARKS | VIF_ONLY_CURBUF\n\t\t\t\t\t    | VIF_GET_OLDFILES | VIF_FORCEIT));\n    }\n\n    if (fp_out != NULL)\n    {\n\t// Write the info:\n\tfprintf(fp_out, _(\"# This viminfo file was generated by Vim %s.\\n\"),\n\t\t\t\t\t\t\t  VIM_VERSION_MEDIUM);\n\tfputs(_(\"# You may edit it if you're careful!\\n\\n\"), fp_out);\n\twrite_viminfo_version(fp_out);\n\tfputs(_(\"# Value of 'encoding' when this file was written\\n\"), fp_out);\n\tfprintf(fp_out, \"*encoding=%s\\n\\n\", p_enc);\n\twrite_viminfo_search_pattern(fp_out);\n\twrite_viminfo_sub_string(fp_out);\n\twrite_viminfo_history(fp_out, merge);\n\twrite_viminfo_registers(fp_out);\n\tfinish_viminfo_registers();\n#ifdef FEAT_EVAL\n\twrite_viminfo_varlist(fp_out);\n#endif\n\twrite_viminfo_filemarks(fp_out);\n\tfinish_viminfo_marks();\n\twrite_viminfo_bufferlist(fp_out);\n\twrite_viminfo_barlines(&vir, fp_out);\n\n\tif (do_copy_marks)\n\t    ga_init2(&buflist, sizeof(buf_T *), 50);\n\twrite_viminfo_marks(fp_out, do_copy_marks ? &buflist : NULL);\n    }\n\n    if (do_copy_marks)\n    {\n\tcopy_viminfo_marks(&vir, fp_out, &buflist, eof, flags);\n\tif (fp_out != NULL)\n\t    ga_clear(&buflist);\n    }\n\n    vim_free(vir.vir_line);\n    if (vir.vir_conv.vc_type != CONV_NONE)\n\tconvert_setup(&vir.vir_conv, NULL, NULL);\n    ga_clear_strings(&vir.vir_barlines);\n}\n\n/*\n * read_viminfo() -- Read the viminfo file.  Registers etc. which are already\n * set are not over-written unless \"flags\" includes VIF_FORCEIT. -- webb\n */\n    int\nread_viminfo(\n    char_u\t*file,\t    // file name or NULL to use default name\n    int\t\tflags)\t    // VIF_WANT_INFO et al.\n{\n    FILE\t*fp;\n    char_u\t*fname;\n    stat_T\tst;\t\t// mch_stat() of existing viminfo file\n\n    if (no_viminfo())\n\treturn FAIL;\n\n    fname = viminfo_filename(file);\t// get file name in allocated buffer\n    if (fname == NULL)\n\treturn FAIL;\n    fp = mch_fopen((char *)fname, READBIN);\n\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Reading viminfo file \\\"%s\\\"%s%s%s%s\"),\n\t\tfname,\n\t\t(flags & VIF_WANT_INFO) ? _(\" info\") : \"\",\n\t\t(flags & VIF_WANT_MARKS) ? _(\" marks\") : \"\",\n\t\t(flags & VIF_GET_OLDFILES) ? _(\" oldfiles\") : \"\",\n\t\tfp == NULL ? _(\" FAILED\") : \"\");\n\tverbose_leave();\n    }\n\n    vim_free(fname);\n    if (fp == NULL)\n\treturn FAIL;\n    if (mch_fstat(fileno(fp), &st) < 0 || S_ISDIR(st.st_mode))\n    {\n\tfclose(fp);\n\treturn FAIL;\n    }\n\n    viminfo_errcnt = 0;\n    do_viminfo(fp, NULL, flags);\n\n    fclose(fp);\n    return OK;\n}\n\n/*\n * Write the viminfo file.  The old one is read in first so that effectively a\n * merge of current info and old info is done.  This allows multiple vims to\n * run simultaneously, without losing any marks etc.\n * If \"forceit\" is TRUE, then the old file is not read in, and only internal\n * info is written to the file.\n */\n    void\nwrite_viminfo(char_u *file, int forceit)\n{\n    char_u\t*fname;\n    FILE\t*fp_in = NULL;\t// input viminfo file, if any\n    FILE\t*fp_out = NULL;\t// output viminfo file\n    char_u\t*tempname = NULL;\t// name of temp viminfo file\n    stat_T\tst_new;\t\t// mch_stat() of potential new file\n    stat_T\tst_old;\t\t// mch_stat() of existing viminfo file\n#if defined(UNIX) || defined(VMS)\n    mode_t\tumask_save;\n#endif\n#ifdef UNIX\n    int\t\tshortname = FALSE;\t// use 8.3 file name\n#endif\n#ifdef MSWIN\n    int\t\thidden = FALSE;\n#endif\n\n    if (no_viminfo())\n\treturn;\n\n    fname = viminfo_filename(file);\t// may set to default if NULL\n    if (fname == NULL)\n\treturn;\n\n    fp_in = mch_fopen((char *)fname, READBIN);\n    if (fp_in == NULL)\n    {\n\tint fd;\n\n\t// if it does exist, but we can't read it, don't try writing\n\tif (mch_stat((char *)fname, &st_new) == 0)\n\t    goto end;\n\n\t// Create the new .viminfo non-accessible for others, because it may\n\t// contain text from non-accessible documents. It is up to the user to\n\t// widen access (e.g. to a group). This may also fail if there is a\n\t// race condition, then just give up.\n\tfd = mch_open((char *)fname,\n\t\t\t    O_CREAT|O_EXTRA|O_EXCL|O_WRONLY|O_NOFOLLOW, 0600);\n\tif (fd < 0)\n\t    goto end;\n\tfp_out = fdopen(fd, WRITEBIN);\n    }\n    else\n    {\n\t// There is an existing viminfo file.  Create a temporary file to\n\t// write the new viminfo into, in the same directory as the\n\t// existing viminfo file, which will be renamed once all writing is\n\t// successful.\n\tif (mch_fstat(fileno(fp_in), &st_old) < 0\n\t\t|| S_ISDIR(st_old.st_mode)\n#ifdef UNIX\n\t\t// For Unix we check the owner of the file.  It's not very nice\n\t\t// to overwrite a user's viminfo file after a \"su root\", with a\n\t\t// viminfo file that the user can't read.\n\t\t|| (getuid() != ROOT_UID\n\t\t    && !(st_old.st_uid == getuid()\n\t\t\t    ? (st_old.st_mode & 0200)\n\t\t\t    : (st_old.st_gid == getgid()\n\t\t\t\t    ? (st_old.st_mode & 0020)\n\t\t\t\t    : (st_old.st_mode & 0002))))\n#endif\n\t\t)\n\t{\n\t    int\ttt = msg_didany;\n\n\t    // avoid a wait_return for this message, it's annoying\n\t    semsg(_(e_viminfo_file_is_not_writable_str), fname);\n\t    msg_didany = tt;\n\t    fclose(fp_in);\n\t    goto end;\n\t}\n#ifdef MSWIN\n\t// Get the file attributes of the existing viminfo file.\n\thidden = mch_ishidden(fname);\n#endif\n\n\t// Make tempname, find one that does not exist yet.\n\t// Beware of a race condition: If someone logs out and all Vim\n\t// instances exit at the same time a temp file might be created between\n\t// stat() and open().  Use mch_open() with O_EXCL to avoid that.\n\t// May try twice: Once normal and once with shortname set, just in\n\t// case somebody puts his viminfo file in an 8.3 filesystem.\n\tfor (;;)\n\t{\n\t    int\t\tnext_char = 'z';\n\t    char_u\t*wp;\n\n\t    tempname = buf_modname(\n#ifdef UNIX\n\t\t\t\t    shortname,\n#else\n\t\t\t\t    FALSE,\n#endif\n\t\t\t\t    fname,\n#ifdef VMS\n\t\t\t\t    (char_u *)\"-tmp\",\n#else\n\t\t\t\t    (char_u *)\".tmp\",\n#endif\n\t\t\t\t    FALSE);\n\t    if (tempname == NULL)\t\t// out of memory\n\t\tbreak;\n\n\t    // Try a series of names.  Change one character, just before\n\t    // the extension.  This should also work for an 8.3\n\t    // file name, when after adding the extension it still is\n\t    // the same file as the original.\n\t    wp = tempname + STRLEN(tempname) - 5;\n\t    if (wp < gettail(tempname))\t    // empty file name?\n\t\twp = gettail(tempname);\n\t    for (;;)\n\t    {\n\t\t// Check if tempfile already exists.  Never overwrite an\n\t\t// existing file!\n\t\tif (mch_stat((char *)tempname, &st_new) == 0)\n\t\t{\n#ifdef UNIX\n\t\t    // Check if tempfile is same as original file.  May happen\n\t\t    // when modname() gave the same file back.  E.g.  silly\n\t\t    // link, or file name-length reached.  Try again with\n\t\t    // shortname set.\n\t\t    if (!shortname && st_new.st_dev == st_old.st_dev\n\t\t\t\t\t\t&& st_new.st_ino == st_old.st_ino)\n\t\t    {\n\t\t\tVIM_CLEAR(tempname);\n\t\t\tshortname = TRUE;\n\t\t\tbreak;\n\t\t    }\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Try creating the file exclusively.  This may fail if\n\t\t    // another Vim tries to do it at the same time.\n#ifdef VMS\n\t\t    // fdopen() fails for some reason\n\t\t    umask_save = umask(077);\n\t\t    fp_out = mch_fopen((char *)tempname, WRITEBIN);\n\t\t    (void)umask(umask_save);\n#else\n\t\t    int\tfd;\n\n\t\t    // Use mch_open() to be able to use O_NOFOLLOW and set file\n\t\t    // protection:\n\t\t    // Unix: same as original file, but strip s-bit.  Reset\n\t\t    // umask to avoid it getting in the way.\n\t\t    // Others: r&w for user only.\n# ifdef UNIX\n\t\t    umask_save = umask(0);\n\t\t    fd = mch_open((char *)tempname,\n\t\t\t    O_CREAT|O_EXTRA|O_EXCL|O_WRONLY|O_NOFOLLOW,\n\t\t\t\t\t(int)((st_old.st_mode & 0777) | 0600));\n\t\t    (void)umask(umask_save);\n# else\n\t\t    fd = mch_open((char *)tempname,\n\t\t\t     O_CREAT|O_EXTRA|O_EXCL|O_WRONLY|O_NOFOLLOW, 0600);\n# endif\n\t\t    if (fd < 0)\n\t\t    {\n\t\t\tfp_out = NULL;\n# ifdef EEXIST\n\t\t\t// Avoid trying lots of names while the problem is lack\n\t\t\t// of permission, only retry if the file already\n\t\t\t// exists.\n\t\t\tif (errno != EEXIST)\n\t\t\t    break;\n# endif\n\t\t    }\n\t\t    else\n\t\t\tfp_out = fdopen(fd, WRITEBIN);\n#endif // VMS\n\t\t    if (fp_out != NULL)\n\t\t\tbreak;\n\t\t}\n\n\t\t// Assume file exists, try again with another name.\n\t\tif (next_char == 'a' - 1)\n\t\t{\n\t\t    // They all exist?  Must be something wrong! Don't write\n\t\t    // the viminfo file then.\n\t\t    semsg(_(e_too_many_viminfo_temp_files_like_str), tempname);\n\t\t    break;\n\t\t}\n\t\t*wp = next_char;\n\t\t--next_char;\n\t    }\n\n\t    if (tempname != NULL)\n\t\tbreak;\n\t    // continue if shortname was set\n\t}\n\n#if defined(UNIX) && defined(HAVE_FCHOWN)\n\tif (tempname != NULL && fp_out != NULL)\n\t{\n\t\tstat_T\ttmp_st;\n\n\t    // Make sure the original owner can read/write the tempfile and\n\t    // otherwise preserve permissions, making sure the group matches.\n\t    if (mch_stat((char *)tempname, &tmp_st) >= 0)\n\t    {\n\t\tif (st_old.st_uid != tmp_st.st_uid)\n\t\t    // Changing the owner might fail, in which case the\n\t\t    // file will now be owned by the current user, oh well.\n\t\t    vim_ignored = fchown(fileno(fp_out), st_old.st_uid, -1);\n\t\tif (st_old.st_gid != tmp_st.st_gid\n\t\t\t&& fchown(fileno(fp_out), -1, st_old.st_gid) == -1)\n\t\t    // can't set the group to what it should be, remove\n\t\t    // group permissions\n\t\t    (void)mch_setperm(tempname, 0600);\n\t    }\n\t    else\n\t\t// can't stat the file, set conservative permissions\n\t\t(void)mch_setperm(tempname, 0600);\n\t}\n#endif\n    }\n\n    // Check if the new viminfo file can be written to.\n    if (fp_out == NULL)\n    {\n\tsemsg(_(e_cant_write_viminfo_file_str),\n\t\t       (fp_in == NULL || tempname == NULL) ? fname : tempname);\n\tif (fp_in != NULL)\n\t    fclose(fp_in);\n\tgoto end;\n    }\n\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tsmsg(_(\"Writing viminfo file \\\"%s\\\"\"), fname);\n\tverbose_leave();\n    }\n\n    viminfo_errcnt = 0;\n    do_viminfo(fp_in, fp_out, forceit ? 0 : (VIF_WANT_INFO | VIF_WANT_MARKS));\n\n    if (fclose(fp_out) == EOF)\n\t++viminfo_errcnt;\n\n    if (fp_in != NULL)\n    {\n\tfclose(fp_in);\n\n\t// In case of an error keep the original viminfo file.  Otherwise\n\t// rename the newly written file.  Give an error if that fails.\n\tif (viminfo_errcnt == 0)\n\t{\n\t    if (vim_rename(tempname, fname) == -1)\n\t    {\n\t\t++viminfo_errcnt;\n\t\tsemsg(_(e_cant_rename_viminfo_file_to_str), fname);\n\t    }\n# ifdef MSWIN\n\t    // If the viminfo file was hidden then also hide the new file.\n\t    else if (hidden)\n\t\tmch_hide(fname);\n# endif\n\t}\n\tif (viminfo_errcnt > 0)\n\t    mch_remove(tempname);\n    }\n\nend:\n    vim_free(fname);\n    vim_free(tempname);\n}\n\n/*\n * \":rviminfo\" and \":wviminfo\".\n */\n    void\nex_viminfo(\n    exarg_T\t*eap)\n{\n    char_u\t*save_viminfo;\n\n    save_viminfo = p_viminfo;\n    if (*p_viminfo == NUL)\n\tp_viminfo = (char_u *)\"'100\";\n    if (eap->cmdidx == CMD_rviminfo)\n    {\n\tif (read_viminfo(eap->arg, VIF_WANT_INFO | VIF_WANT_MARKS\n\t\t\t\t  | (eap->forceit ? VIF_FORCEIT : 0)) == FAIL)\n\t    emsg(_(e_cannot_open_viminfo_file_for_reading));\n    }\n    else\n\twrite_viminfo(eap->arg, eap->forceit);\n    p_viminfo = save_viminfo;\n}\n\n#endif // FEAT_VIMINFO\n"], "filenames": ["src/alloc.c", "src/message.c", "src/proto/alloc.pro", "src/proto/userfunc.pro", "src/testdir/test_vim9_func.vim", "src/usercmd.c", "src/userfunc.c", "src/version.c", "src/vim9compile.c", "src/viminfo.c"], "buggy_code_start_loc": [705, 590, 20, 41, 1757, 1024, 169, 752, 813, 2733], "buggy_code_end_loc": [804, 591, 23, 42, 2052, 1042, 4652, 752, 3240, 2773], "fixing_code_start_loc": [705, 590, 20, 41, 1758, 1024, 169, 753, 813, 2733], "fixing_code_end_loc": [818, 591, 25, 42, 2065, 1042, 4654, 755, 3243, 2773], "type": "CWE-416", "message": "vim is vulnerable to Use After Free", "other": {"cve": {"id": "CVE-2022-0156", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-10T16:15:09.733", "lastModified": "2022-08-26T17:45:53.073", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vim is vulnerable to Use After Free"}, {"lang": "es", "value": "vim es vulnerable a un Uso de Memoria Previamente Liberada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.4040", "matchCriteriaId": "A0A422CC-3599-4D72-8211-4E47731AC940"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionEndExcluding": "12.3", "matchCriteriaId": "9060C1B6-F101-46AE-8B08-6D6951304916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:apple:macos:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0", "versionEndExcluding": "11.6.8", "matchCriteriaId": "21572D24-45CE-4FF4-8AFD-E13E1FE853B1"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2022/Jul/13", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://seclists.org/fulldisclosure/2022/Mar/29", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2022/01/15/1", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/47dded34-3767-4725-8c7c-9dcb68c70b36", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3FH2J57GDA2WMBS6J56F6QQRA6BXQQFZ/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HD5S2FC2HF22A7XQXK2XXIR46EARVWIM/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213183", "source": "security@huntr.dev", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://support.apple.com/kb/HT213344", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/9f1a39a5d1cd7989ada2d1cb32f97d84360e050f"}}