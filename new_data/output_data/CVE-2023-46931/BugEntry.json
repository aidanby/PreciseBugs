{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2017-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ffmpeg demux filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/setup.h>\n\n#ifdef GPAC_HAS_FFMPEG\n\n#include \"ff_common.h\"\n\n//for NTP clock\n#include <gpac/network.h>\n#include <gpac/bitstream.h>\n#if (LIBAVCODEC_VERSION_MAJOR>58)\n#include <libavutil/mastering_display_metadata.h>\n#else\n#define FFMPEG_NO_DOVI\n#endif\n\nenum\n{\n\tCOPY_NO,\n\tCOPY_A,\n\tCOPY_V,\n\tCOPY_AV\n};\n\ntypedef struct\n{\n\tGF_FilterPid *pid;\n\tu64 ts_offset;\n\tBool mkv_webvtt;\n\tu32 vc1_mode;\n\tu64 fake_dts_plus_one, fake_dts_orig;\n\tBool fake_dts_set;\n\tGF_List *pck_queue;\n} PidCtx;\n\ntypedef struct\n{\n\t//options\n\tconst char *src;\n\tu32 block_size;\n\tu32 copy, probes;\n\tBool sclock;\n\tconst char *fmt, *dev;\n\tBool reparse;\n\n\t//internal data\n\tconst char *fname;\n\tu32 log_class;\n\n\tBool raw_data;\n\t//input file\n\tAVFormatContext *demuxer;\n\t//demux options\n\tAVDictionary *options;\n\n\tPidCtx *pids_ctx;\n\n\tBool raw_pck_out;\n\tu32 nb_streams;\n\tu32 nb_playing, nb_stop_pending;\n\tBool stop_seen;\n\tu64 first_sample_clock, last_frame_ts;\n\tu32 probe_frames;\n    u32 nb_pck_sent;\n\tDouble last_play_start_range;\n\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\tAVPacket pkt;\n#else\n\tAVPacket *pkt;\n#endif\n\n\ts32 audio_idx, video_idx;\n\n\tu64 *probe_times;\n\n\tBool copy_audio, copy_video;\n\n\tu8 *avio_ctx_buffer;\n\tAVIOContext *avio_ctx;\n\tFILE *gfio;\n\tGF_Fraction fps_forced;\n\n\t//for ffdmx used as filter on http or file input\n\t//we must buffer enough data so that calls to read_packet() does not abort in the middle of a packet\n\tGF_FilterPid *ipid;\n\tu32 is_open;\n\tu32 strbuf_offset;\n\tu8 *strbuf;\n\tu32 strbuf_size, strbuf_alloc, strbuf_min, in_seek;\n\tBool in_eos, first_block;\n\ts64 seek_offset;\n\tu64 seek_ms;\n} GF_FFDemuxCtx;\n\nstatic void ffdmx_finalize(GF_Filter *filter)\n{\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *) gf_filter_get_udta(filter);\n\tif (ctx->pids_ctx) {\n\t\tu32 i;\n\t\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\t\tif (!ctx->pids_ctx[i].pck_queue) continue;\n\t\t\twhile (gf_list_count(ctx->pids_ctx[i].pck_queue)) {\n\t\t\t\tgf_filter_pck_discard( gf_list_pop_back(ctx->pids_ctx[i].pck_queue) );\n\t\t\t}\n\t\t\tgf_list_del(ctx->pids_ctx[i].pck_queue);\n\t\t}\n\t\tgf_free(ctx->pids_ctx);\n\t}\n\tif (ctx->options)\n\t\tav_dict_free(&ctx->options);\n\tif (ctx->probe_times)\n\t\tgf_free(ctx->probe_times);\n\tif (ctx->demuxer) {\n\t\tavformat_close_input(&ctx->demuxer);\n\t\tavformat_free_context(ctx->demuxer);\n\t}\n\tif (ctx->avio_ctx) {\n\t\tif (ctx->avio_ctx->buffer) av_freep(&ctx->avio_ctx->buffer);\n\t\tav_freep(&ctx->avio_ctx);\n\t}\n\tif (ctx->gfio) gf_fclose(ctx->gfio);\n\tif (ctx->strbuf) gf_free(ctx->strbuf);\n\treturn;\n}\n\nvoid ffdmx_shared_pck_release(GF_Filter *filter, GF_FilterPid *pid, GF_FilterPacket *pck)\n{\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *) gf_filter_get_udta(filter);\n\tif (ctx->raw_pck_out) {\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\t\tav_free_packet(&ctx->pkt);\n#else\n\t\tav_packet_unref(ctx->pkt);\n#endif\n\t\tctx->raw_pck_out = GF_FALSE;\n\t\tgf_filter_post_process_task(filter);\n\t}\n}\n\nstatic GF_Err ffdmx_set_decoder_config(PidCtx *pctx, const u8 *exdata, u32 exdata_size, u32 gpac_codec_id)\n{\n\tu8 *dsi;\n\tu32 dsi_size;\n\tGF_Err e = ffmpeg_extradata_to_gpac(gpac_codec_id, exdata, exdata_size, &dsi, &dsi_size);\n\tif (e) return e;\n\n\tif (gpac_codec_id==GF_CODECID_SMPTE_VC1) {\n\t\tpctx->vc1_mode = 1;\n\t\t//if no_interlace (bit 6 of 2nd byte) is not set, inject interlaced\n\t\tif ((dsi_size>=7) && ((dsi[2] & 0x20) != 0x20))\n\t\t\tpctx->vc1_mode = 2;\n\t}\n\treturn gf_filter_pid_set_property(pctx->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY( dsi, dsi_size) );\n}\n\n#if (LIBAVCODEC_VERSION_MAJOR>58)\nstatic inline u32 rescale_mdcv(AVRational q, int b)\n{\n    return (u32) av_rescale(q.num, b, q.den);\n}\n#endif\n\n//dovi_meta.h not exported in old releases, just redefine\ntypedef struct {\n    u8 dv_version_major;\n    u8 dv_version_minor;\n    u8 dv_profile;\n    u8 dv_level;\n    u8 rpu_present_flag;\n    u8 el_present_flag;\n    u8 bl_present_flag;\n    u8 dv_bl_signal_compatibility_id;\n} Ref_FFAVDoviRecord;\n\nstatic void ffdmx_parse_side_data(const AVPacketSideData *sd, GF_FilterPid *pid)\n{\n\tswitch (sd->type) {\n\tcase AV_PKT_DATA_PALETTE:\n\t\tbreak;\n\tcase AV_PKT_DATA_NEW_EXTRADATA:\n\t\tbreak;\n\tcase AV_PKT_DATA_PARAM_CHANGE:\n\t\tbreak;\n\tcase AV_PKT_DATA_H263_MB_INFO:\n\t\tbreak;\n\tcase AV_PKT_DATA_REPLAYGAIN:\n\t\tbreak;\n\tcase AV_PKT_DATA_STEREO3D:\n\t\tbreak;\n\tcase AV_PKT_DATA_AUDIO_SERVICE_TYPE:\n\t\tbreak;\n\tcase AV_PKT_DATA_QUALITY_STATS:\n\t\tbreak;\n\tcase AV_PKT_DATA_DISPLAYMATRIX:\n\t{\n\t\tGF_PropertyValue p;\n\t\tmemset(&p, 0, sizeof(GF_PropertyValue));\n\t\tp.type = GF_PROP_SINT_LIST;\n\t\tp.value.uint_list.nb_items = 9;\n\t\tp.value.uint_list.vals = (u32 *)sd->data;\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ISOM_TRACK_MATRIX, &p);\n\n\t}\n\t\tbreak;\n\n#if (LIBAVCODEC_VERSION_MAJOR >= 58)\n\tcase AV_PKT_DATA_CPB_PROPERTIES:\n\t\tbreak;\n\tcase AV_PKT_DATA_SPHERICAL:\n\t\tbreak;\n#endif\n\n\n#if (LIBAVCODEC_VERSION_MAJOR>58)\n\tcase AV_PKT_DATA_MASTERING_DISPLAY_METADATA:\n\t{\n\t\tu8 mdcv[24];\n\t\tconst int chroma_den = 50000;\n\t\tconst int luma_den = 10000;\n\t\tmemset(mdcv, 0, sizeof(u8)*24);\n\t\tconst AVMasteringDisplayMetadata *metadata = (const AVMasteringDisplayMetadata *)sd->data;\n\t\tGF_BitStream *bs = gf_bs_new(mdcv, 24, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u16(bs, rescale_mdcv(metadata->display_primaries[1][0], chroma_den));\n\t\tgf_bs_write_u16(bs, rescale_mdcv(metadata->display_primaries[1][1], chroma_den));\n    \tgf_bs_write_u16(bs, rescale_mdcv(metadata->display_primaries[2][0], chroma_den));\n    \tgf_bs_write_u16(bs, rescale_mdcv(metadata->display_primaries[2][1], chroma_den));\n    \tgf_bs_write_u16(bs, rescale_mdcv(metadata->display_primaries[0][0], chroma_den));\n    \tgf_bs_write_u16(bs, rescale_mdcv(metadata->display_primaries[0][1], chroma_den));\n    \tgf_bs_write_u16(bs, rescale_mdcv(metadata->white_point[0], chroma_den));\n    \tgf_bs_write_u16(bs, rescale_mdcv(metadata->white_point[1], chroma_den));\n    \tgf_bs_write_u32(bs, rescale_mdcv(metadata->max_luminance, luma_den));\n    \tgf_bs_write_u32(bs, rescale_mdcv(metadata->min_luminance, luma_den));\n    \tgf_bs_del(bs);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_MASTER_DISPLAY_COLOUR, &PROP_DATA(mdcv, 24));\n\t}\n\t\tbreak;\n\n\tcase AV_PKT_DATA_CONTENT_LIGHT_LEVEL:\n\t{\n\t\tu8 clli[4];\n\t\tmemset(clli, 0, sizeof(u8)*4);\n\t\tconst AVContentLightMetadata *metadata = (const AVContentLightMetadata *)sd->data;\n\t\tGF_BitStream *bs = gf_bs_new(clli, 4, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u16(bs, metadata->MaxCLL);\n\t\tgf_bs_write_u16(bs, metadata->MaxFALL);\n    \tgf_bs_del(bs);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA(clli, 4));\n\t}\n\t\tbreak;\n\tcase AV_PKT_DATA_ICC_PROFILE:\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ICC_PROFILE, &PROP_DATA(sd->data, (u32) sd->size));\n\t\tbreak;\n\tcase AV_PKT_DATA_DOVI_CONF:\n\t{\n\t\tu8 dv_cfg[24];\n\t\tconst Ref_FFAVDoviRecord *dovi = (const Ref_FFAVDoviRecord *)sd->data;\n\t\tmemset(dv_cfg, 0, sizeof(u8)*24);\n\t\tGF_BitStream *bs = gf_bs_new(dv_cfg, 24, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u8(bs, dovi->dv_version_major);\n\t\tgf_bs_write_u8(bs, dovi->dv_version_minor);\n\t\tgf_bs_write_int(bs, dovi->dv_profile, 7);\n\t\tgf_bs_write_int(bs, dovi->dv_level, 6);\n\t\tgf_bs_write_int(bs, dovi->rpu_present_flag, 1);\n\t\tgf_bs_write_int(bs, dovi->el_present_flag, 1);\n\t\tgf_bs_write_int(bs, dovi->bl_present_flag, 1);\n\t\tgf_bs_write_int(bs, dovi->dv_bl_signal_compatibility_id, 4);\n\t\t//the rest is zero-reserved\n\t\tgf_bs_write_int(bs, 0, 28);\n\t\tgf_bs_write_u32(bs, 0);\n\t\tgf_bs_write_u32(bs, 0);\n\t\tgf_bs_write_u32(bs, 0);\n\t\tgf_bs_write_u32(bs, 0);\n\t\tgf_bs_del(bs);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DOLBY_VISION, &PROP_DATA(dv_cfg, 24));\n\t}\n\t\tbreak;\n\tcase AV_PKT_DATA_S12M_TIMECODE:\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nGF_Err ffdmx_init_common(GF_Filter *filter, GF_FFDemuxCtx *ctx, u32 grab_type);\n\nstatic GF_Err ffdmx_flush_input(GF_Filter *filter, GF_FFDemuxCtx *ctx)\n{\n\tint res;\n\tGF_Err e;\n\tif (ctx->is_open==2)\n\t\treturn GF_NOT_SUPPORTED;\n\n\tif (!ctx->is_open)\n\t\tctx->demuxer->pb = ctx->avio_ctx;\n\n\twhile (1) {\n\t\tif (ctx->strbuf_size - ctx->strbuf_offset >= ctx->strbuf_min) {\n\t\t\tif (ctx->is_open) return GF_OK;\n\t\t\tbreak;\n\t\t}\n\n\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(ctx->ipid);\n\t\tif (!pck) {\n\t\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\t\tctx->in_eos = GF_TRUE;\n\t\t\t\tif (ctx->is_open) return GF_OK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn GF_NOT_READY;\n\t\t}\n\t\tu32 size;\n\t\tconst u8 *data = gf_filter_pck_get_data(pck, &size);\n\t\tif (!size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\tcontinue;\n\t\t}\n\t\tctx->in_eos = GF_FALSE;\n\t\tmemmove(ctx->strbuf, ctx->strbuf+ctx->strbuf_offset, ctx->strbuf_size - ctx->strbuf_offset);\n\t\tctx->strbuf_size -= ctx->strbuf_offset;\n\t\tctx->strbuf_offset = 0;\n\t\tif (ctx->strbuf_size + size > ctx->strbuf_alloc) {\n\t\t\tctx->strbuf_alloc = ctx->strbuf_size + size;\n\t\t\tctx->strbuf = gf_realloc(ctx->strbuf, ctx->strbuf_alloc);\n\t\t\tif (!ctx->strbuf) {\n\t\t\t\tctx->strbuf_alloc = 0;\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t}\n\t\tmemcpy(ctx->strbuf + ctx->strbuf_size, data, size);\n\t\tctx->strbuf_size += size;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\tctx->demuxer->pb->eof_reached = 0;\n\t}\n\n\tctx->first_block = GF_TRUE;\n\n\t//open context\n\tAVDictionary *options = NULL;\n\tav_dict_copy(&options, ctx->options, 0);\n\n\tctx->demuxer->flags |= AVFMT_FLAG_CUSTOM_IO | AVFMT_FLAG_NONBLOCK | AVFMT_FLAG_NOBUFFER;\n\tres = avformat_open_input(&ctx->demuxer, NULL, NULL, &options);\n\tswitch (res) {\n\tcase 0:\n\t\te = GF_OK;\n\t\tbreak;\n\tcase AVERROR_INVALIDDATA:\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tbreak;\n\tcase AVERROR_DEMUXER_NOT_FOUND:\n\tcase -ENOENT:\n\t\te = GF_URL_ERROR;\n\t\tbreak;\n\tcase AVERROR_EOF:\n\t\te = GF_EOS;\n\t\tbreak;\n\tdefault:\n\t\te = GF_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Fail to open %s - error %s\\n\", ctx->fname, ctx->src, av_err2str(res) ));\n\t\tavformat_close_input(&ctx->demuxer);\n\t\tavformat_free_context(ctx->demuxer);\n\t\tctx->demuxer = NULL;\n\t\tif (options) av_dict_free(&options);\n\t\tctx->is_open = 2;\n\t\tctx->first_block = GF_FALSE;\n\t\treturn e;\n\t}\n\n\tAVDictionary** optionsarr = NULL;\n\tif (ctx->options && ctx->demuxer && ctx->demuxer->nb_streams) {\n\t\toptionsarr = (AVDictionary**)gf_malloc(ctx->demuxer->nb_streams * sizeof(AVDictionary*));\n\t\tfor (unsigned si = 0; si < ctx->demuxer->nb_streams; si++) {\n\t\t\toptionsarr[si] = NULL;\n\t\t\tav_dict_copy(&optionsarr[si], ctx->options, 0);\n\t\t}\n\t}\n\tctx->demuxer->probesize = ctx->strbuf_size;\n\tres = avformat_find_stream_info(ctx->demuxer, optionsarr);\n\tctx->first_block = GF_FALSE;\n\n\tif (optionsarr) {\n\t\tfor (unsigned si = 0; si < ctx->demuxer->nb_streams; si++) {\n\t\t\tav_dict_free(&optionsarr[si]);\n\t\t}\n\t\tgf_free(optionsarr);\n\t\toptionsarr = NULL;\n\t}\n\n\tif (res < 0) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] cannot locate streams - error %s\\n\", ctx->fname, av_err2str(res)));\n\t\te = GF_NOT_SUPPORTED;\n\t\tavformat_close_input(&ctx->demuxer);\n\t\tavformat_free_context(ctx->demuxer);\n\t\tctx->demuxer = NULL;\n\t\tif (options) av_dict_free(&options);\n\t\tctx->is_open = 2;\n\t\treturn e;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, ctx->log_class, (\"[%s] file %s opened - %d streams\\n\", ctx->fname, ctx->src, ctx->demuxer->nb_streams));\n\n\tffmpeg_report_options(filter, options, ctx->options);\n\te = ffdmx_init_common(filter, ctx, 0);\n\tif (e) {\n\t\tctx->is_open = 2;\n\t\treturn e;\n\t}\n\tctx->is_open = 1;\n\treturn GF_OK;\n}\n\nstatic GF_Err ffdmx_process(GF_Filter *filter)\n{\n\tGF_Err e;\n\tu32 i, nb_pck=0;\n\tu64 sample_time;\n\tu8 *data_dst;\n\tBool copy = GF_TRUE;\n\tBool check_webvtt = GF_FALSE;\n\tGF_FilterPacket *pck_dst;\n\tAVPacket *pkt;\n\tPidCtx *pctx;\n\tint res;\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *) gf_filter_get_udta(filter);\n\nrestart:\n\tif (ctx->ipid) {\n\t\te = ffdmx_flush_input(filter, ctx);\n\t\tif (e==GF_NOT_READY) return GF_OK;\n\t\tif (!ctx->is_open) return GF_OK;\n\t\tif (ctx->is_open==2) return GF_PROFILE_NOT_SUPPORTED;\n\t\tif (!ctx->demuxer) return GF_PROFILE_NOT_SUPPORTED;\n\t\tif (!ctx->strbuf_size) return GF_OK;\n\t}\n\n\tif (!ctx->nb_playing) {\n\t\tif (ctx->stop_seen) {\n\t\t\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\t\t\tif (ctx->pids_ctx[i].pid) gf_filter_pid_set_eos(ctx->pids_ctx[i].pid);\n\t\t\t}\n\t\t}\n\t\treturn GF_EOS;\n\t}\n\n\tif (ctx->raw_pck_out)\n\t\treturn GF_EOS;\n\n\tu32 would_block, pids;\n\n\twould_block = pids = 0;\n\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\tif (!ctx->pids_ctx[i].pid) continue;\n\t\tpids++;\n\t\tif (!gf_filter_pid_is_playing(ctx->pids_ctx[i].pid))\n\t\t\twould_block++;\n\t\telse if (gf_filter_pid_would_block(ctx->pids_ctx[i].pid))\n\t\t\twould_block++;\n\t}\n\tif (would_block == pids) {\n\t\tgf_filter_ask_rt_reschedule(filter, 1000);\n\t\treturn GF_OK;\n\t}\n\n\tsample_time = gf_sys_clock_high_res();\n\n\tFF_INIT_PCK(ctx, pkt)\n\tpkt->side_data = NULL;\n\tpkt->side_data_elems = 0;\n\n\tpkt->stream_index = -1;\n\n\t/*EOF*/\n\tres = av_read_frame(ctx->demuxer, pkt);\n\tif (res < 0) {\n\t\tif (!ctx->in_eos && (ctx->strbuf_size>ctx->strbuf_offset) && (res == AVERROR(EAGAIN)))\n\t\t\treturn GF_OK;\n\n\t\tFF_FREE_PCK(pkt);\n\t\tif (!ctx->raw_data) {\n\t\t\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\t\t\tif (ctx->pids_ctx[i].pid) gf_filter_pid_set_eos(ctx->pids_ctx[i].pid);\n\t\t\t}\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tassert(pkt->stream_index>=0);\n\tassert(pkt->stream_index < (s32) ctx->demuxer->nb_streams);\n\n\tif (pkt->stream_index >= (s32) ctx->nb_streams) {\n\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] More streams (%d) than initialy declared (%d), buggy source demux or not supported, ignoring packet in stream %d\\n\", ctx->fname, ctx->demuxer->nb_streams, ctx->nb_streams, pkt->stream_index+1 ));\n\t\tFF_FREE_PCK(pkt);\n\t\treturn GF_OK;\n\t}\n\n\tif (pkt->pts == AV_NOPTS_VALUE) {\n\t\tif (pkt->dts == AV_NOPTS_VALUE) {\n\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] No PTS for packet on stream %d\\n\", ctx->fname, pkt->stream_index ));\n\t\t} else {\n\t\t\tpkt->pts = pkt->dts;\n\t\t}\n\t}\n\tif (ctx->seek_ms) {\n\t\tif (pkt->pts * 1000 < (s64)ctx->seek_ms * ctx->demuxer->streams[pkt->stream_index]->time_base.den) {\n\t\t\tif (!ctx->raw_pck_out) {\n\t\t\t\tFF_FREE_PCK(pkt);\n\t\t\t}\n\t\t\tgoto restart;\n\t\t}\n\t\tctx->seek_ms = 0;\n\t}\n\n\tpctx = &ctx->pids_ctx[pkt->stream_index];\n\tif (! pctx->pid ) {\n\t\tGF_LOG(GF_LOG_DEBUG, ctx->log_class, (\"[%s] No PID defined for given stream %d\\n\", ctx->fname, pkt->stream_index ));\n\t\tFF_FREE_PCK(pkt);\n\t\treturn GF_OK;\n\t}\n    if (ctx->stop_seen && ! gf_filter_pid_is_playing( pctx->pid ) ) {\n\t\tFF_FREE_PCK(pkt);\n        return GF_OK;\n    }\n\tif (ctx->raw_data && (ctx->probe_frames<ctx->probes) ) {\n\t\tif (pkt->stream_index==ctx->audio_idx) {\n\t\t\tFF_FREE_PCK(pkt);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tctx->probe_times[ctx->probe_frames] = ctx->sclock ? sample_time : pkt->pts;\n\t\tctx->probe_frames++;\n\t\tif (ctx->probe_frames==ctx->probes) {\n\t\t\tu32 best_diff=0, max_stat=0;\n\t\t\tfor (i=0; i<ctx->probes; i++) {\n\t\t\t\tif (i) {\n\t\t\t\t\tu32 j, nb_stats=0;\n\t\t\t\t\tu32 diff = (u32) (ctx->probe_times[i]-ctx->probe_times[i-1]);\n\t\t\t\t\tfor (j=1; j<ctx->probes; j++) {\n\t\t\t\t\t\ts32 sdiff = (s32) (ctx->probe_times[j]-ctx->probe_times[j-1]);\n\t\t\t\t\t\tsdiff -= (s32) diff;\n\t\t\t\t\t\tif (sdiff<0) sdiff = -sdiff;\n\t\t\t\t\t\tif (sdiff<2000) nb_stats++;\n\t\t\t\t\t}\n\t\t\t\t\tif (max_stat<nb_stats) {\n\t\t\t\t\t\tmax_stat = nb_stats;\n\t\t\t\t\t\tbest_diff = diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_INFO, ctx->log_class, (\"[%s] Video probing done, frame diff is %d us (for %d frames out of %d)\\n\", ctx->fname, best_diff, max_stat, ctx->probes));\n\t\t} else {\n\t\t\tFF_FREE_PCK(pkt);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (pkt->side_data_elems) {\n\t\tfor (i=0; i < (u32) pkt->side_data_elems; i++) {\n\t\t\tAVPacketSideData *sd = &pkt->side_data[i];\n\t\t\tif (sd->type == AV_PKT_DATA_NEW_EXTRADATA) {\n\t\t\t\tif (sd->data) {\n\t\t\t\t\tu32 cid = 0;\n\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(pctx->pid, GF_PROP_PID_CODECID);\n\t\t\t\t\tif (p) cid = p->value.uint;\n\t\t\t\t\tffdmx_set_decoder_config(pctx, sd->data, (u32) sd->size, cid);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sd->type == AV_PKT_DATA_PARAM_CHANGE) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(sd->data, sd->size, GF_BITSTREAM_READ);\n\n\t\t\t\tu32 flags = gf_bs_read_u32_le(bs);\n\t\t\t\tif (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\n\t\t\t\t\tu32 new_ch = gf_bs_read_u32_le(bs);\n\t\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT(new_ch) );\n\t\t\t\t}\n\t\t\t\tif (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\n\t\t\t\t\tu64 new_lay = gf_bs_read_u64_le(bs);\n\t\t\t\t\tnew_lay = ffmpeg_channel_layout_to_gpac(new_lay);\n\t\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_CHANNEL_LAYOUT, &PROP_LONGUINT(new_lay) );\n\t\t\t\t}\n\t\t\t\tif (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\n\t\t\t\t\tu32 new_sr = gf_bs_read_u32_le(bs);\n\t\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT(new_sr) );\n\t\t\t\t}\n\t\t\t\tif (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\n\t\t\t\t\tu32 new_w = gf_bs_read_u32_le(bs);\n\t\t\t\t\tu32 new_h = gf_bs_read_u32_le(bs);\n\t\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_WIDTH, &PROP_UINT(new_w) );\n\t\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_HEIGHT, &PROP_UINT(new_h) );\n\t\t\t\t}\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t\telse if ((sd->type == AV_PKT_DATA_WEBVTT_IDENTIFIER) || (sd->type == AV_PKT_DATA_WEBVTT_SETTINGS)\n\t\t\t\t|| (sd->type == AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL)\n\t\t\t) {\n\t\t\t\tcheck_webvtt = pctx->mkv_webvtt;\n\t\t\t}\n\t\t\t//todo, map the rest ?\n\t\t\telse {\n\t\t\t\tffdmx_parse_side_data(sd, pctx->pid);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx->raw_data) {\n\t\tif (pkt->stream_index==ctx->audio_idx) copy = ctx->copy_audio;\n\t\telse copy = ctx->copy_video;\n\t}\n\n\t/*patch vc1 to always include start codes*/\n\tif (pctx->vc1_mode && (pkt->data[0]!=0) && (pkt->data[1]!=0) && (pkt->data[2]!=1)) {\n\t\tpck_dst = gf_filter_pck_new_alloc(pctx->pid, pkt->size+4, &data_dst);\n\t\tif (!pck_dst) return GF_OUT_OF_MEM;\n\t\tdata_dst[0]=0;\n\t\tdata_dst[1]=0;\n\t\tdata_dst[2]=1;\n\t\tif ((pctx->vc1_mode==2) && ((pkt->data[0] & 0xC0) == 0xC0)) {\n\t\t\tdata_dst[3] = 0x0C;\n\t\t} else {\n\t\t\tdata_dst[3] = 0x0D;\n\t\t}\n\t\tmemcpy(data_dst+4, pkt->data, pkt->size);\n\t} else if (ctx->raw_data && !copy) {\n\t\t//we don't use shared memory on demuxers since they are usually the ones performing all the buffering\n\t\tpck_dst = gf_filter_pck_new_shared(pctx->pid, pkt->data, pkt->size, ffdmx_shared_pck_release);\n\t\tif (!pck_dst) return GF_OUT_OF_MEM;\n\t\tctx->raw_pck_out = GF_TRUE;\n\t} else {\n\t\t//we don't use shared memory on demuxers since they are usually the ones performing all the buffering\n\t\tpck_dst = gf_filter_pck_new_alloc(pctx->pid, pkt->size, &data_dst);\n\t\tif (!pck_dst) return GF_OUT_OF_MEM;\n\t\tmemcpy(data_dst, pkt->data, pkt->size);\n\t}\n\n\tBool queue_pck=GF_FALSE;\n\tif (ctx->raw_data && ctx->sclock) {\n\t\tu64 ts;\n\t\tif (!ctx->first_sample_clock) {\n\t\t\tctx->last_frame_ts = ctx->first_sample_clock = sample_time;\n\t\t}\n\t\tts = sample_time - ctx->first_sample_clock;\n\t\tgf_filter_pck_set_cts(pck_dst, ts );\n\t\tctx->last_frame_ts = ts;\n\t} else if (pkt->pts != AV_NOPTS_VALUE) {\n\t\tAVStream *stream = ctx->demuxer->streams[pkt->stream_index];\n\t\tu64 ts;\n\n\t\t//initial delay setup - we only dispatch dts or cts >=0\n\t\tif (!pctx->ts_offset) {\n\t\t\t//if first dts is <0, offset timeline and set offset\n\t\t\tif ((pkt->dts != AV_NOPTS_VALUE) && (pkt->dts<0) && !pctx->ts_offset) {\n\t\t\t\tpctx->ts_offset = -pkt->dts + 1;\n\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_DELAY, &PROP_LONGSINT( pkt->dts) );\n\t\t\t}\n\t\t\t//otherwise reset any potential delay set previously\n\t\t\telse {\n\t\t\t\tpctx->ts_offset = 1;\n\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_DELAY, NULL);\n\t\t\t}\n\t\t}\n\n\t\tts = (pkt->pts + pctx->ts_offset-1) * stream->time_base.num;\n\t\tgf_filter_pck_set_cts(pck_dst, ts );\n\n\t\t//trick for some demuxers in libavformat no setting dts when negative (mkv for ex)\n\t\tif (!pctx->fake_dts_plus_one) {\n\t\t\tpctx->fake_dts_plus_one = 1+ts;\n\t\t\tpctx->fake_dts_orig = ts;\n\t\t}\n\n\t\tif (pkt->dts != AV_NOPTS_VALUE) {\n\t\t\tts = (pctx->fake_dts_plus_one-1 - pctx->fake_dts_orig + pkt->dts + pctx->ts_offset-1) * stream->time_base.num;\n\t\t\tgf_filter_pck_set_dts(pck_dst, ts);\n\t\t\tif (!pctx->fake_dts_set) {\n\t\t\t\tif (pctx->fake_dts_plus_one) {\n\t\t\t\t\ts64 offset = pctx->fake_dts_plus_one-1;\n\t\t\t\t\toffset -= pctx->fake_dts_orig;\n\t\t\t\t\tif (offset)\n\t\t\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_DELAY, &PROP_LONGSINT( -offset) );\n\t\t\t\t}\n\t\t\t\tpctx->fake_dts_set = GF_TRUE;\n\t\t\t\tif (pctx->pck_queue) {\n\t\t\t\t\twhile (gf_list_count(pctx->pck_queue)) {\n\t\t\t\t\t\tGF_FilterPacket *pck_q = gf_list_pop_front(pctx->pck_queue);\n\t\t\t\t\t\tgf_filter_pck_send(pck_q);\n\t\t\t\t\t}\n\t\t\t\t\tgf_list_del(pctx->pck_queue);\n\t\t\t\t\tpctx->pck_queue = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tts = pctx->fake_dts_plus_one-1;\n\t\t\tgf_filter_pck_set_dts(pck_dst, ts);\n\t\t\tpctx->fake_dts_plus_one += pkt->duration ? pkt->duration : 1;\n\t\t\tif (!ctx->raw_data && !pctx->fake_dts_set) queue_pck = GF_TRUE;\n\t\t}\n\n\t\tif (pkt->duration)\n\t\t\tgf_filter_pck_set_duration(pck_dst, (u32) pkt->duration);\n\t}\n\n\t//fixme: try to identify SAP type 2 and more\n\tif (pkt->flags & AV_PKT_FLAG_KEY)\n\t\tgf_filter_pck_set_sap(pck_dst, GF_FILTER_SAP_1);\n\n\tif (pkt->flags & AV_PKT_FLAG_CORRUPT)\n\t\tgf_filter_pck_set_corrupted(pck_dst, GF_TRUE);\n\n\tif (ctx->raw_data) {\n\t\tu64 ntp = gf_net_get_ntp_ts();\n\t\tgf_filter_pck_set_property(pck_dst, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ntp) );\n\t}\n\tif (check_webvtt) {\n\t\tfor (i=0; i < (u32) pkt->side_data_elems; i++) {\n\t\t\tAVPacketSideData *sd = &pkt->side_data[i];\n\t\t\tif (!sd->data) continue;\n\t\t\tif ((sd->type == AV_PKT_DATA_WEBVTT_IDENTIFIER) || (sd->type == AV_PKT_DATA_WEBVTT_SETTINGS)) {\n\t\t\t\tu8 *d = gf_malloc(sd->size+1);\n\t\t\t\tif (d) {\n\t\t\t\t\tmemcpy(d, sd->data, sd->size);\n\t\t\t\t\td[sd->size]=0;\n\t\t\t\t\tif (sd->type == AV_PKT_DATA_WEBVTT_SETTINGS)\n\t\t\t\t\t\tgf_filter_pck_set_property_str(pck_dst, \"vtt_settings\", &PROP_STRING_NO_COPY(d) );\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_filter_pck_set_property_str(pck_dst, \"vtt_cueid\", &PROP_STRING_NO_COPY(d) );\n\t\t\t\t}\n\t\t\t} else if ((sd->type == AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL) && (sd->size>8)) {\n\t\t\t\tu8 *d = gf_malloc(sd->size-7);\n\t\t\t\tif (d) {\n\t\t\t\t\tmemcpy(d, sd->data+8, sd->size-8);\n\t\t\t\t\td[sd->size-8]=0;\n\t\t\t\t\tgf_filter_pck_set_property_str(pck_dst, \"vtt_pre\", &PROP_STRING_NO_COPY(d) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (queue_pck) {\n\t\tif (!pctx->pck_queue) pctx->pck_queue = gf_list_new();\n\t\te = gf_list_add(pctx->pck_queue, pck_dst);\n\t} else {\n\t\te = gf_filter_pck_send(pck_dst);\n\t}\n\tctx->nb_pck_sent++;\n\tctx->nb_stop_pending=0;\n\tif (!ctx->raw_pck_out) {\n\t\tFF_FREE_PCK(pkt);\n\t}\n\n\tnb_pck++;\n\tif (e || (nb_pck>10)) return e;\n\n\t//we demux an input, restart to flush it\n\tif (ctx->ipid) {\n\t\tif (ctx->strbuf_size && (ctx->strbuf_offset*2 > ctx->strbuf_size)) {\n\t\t\tgf_filter_post_process_task(filter);\n\t\t}\n\t\tgoto restart;\n\t}\n\n\t//we don't demux an input, only rely on session to schedule the filter\n\treturn GF_OK;\n}\n\n\nstatic GF_Err ffdmx_update_arg(GF_Filter *filter, const char *arg_name, const GF_PropertyValue *arg_val)\n{\n\tGF_FFDemuxCtx *ctx = gf_filter_get_udta(filter);\n\treturn ffmpeg_update_arg(ctx->fname, ctx->demuxer, &ctx->options, arg_name, arg_val);\n}\n\n#include <gpac/mpeg4_odf.h>\n#include <gpac/avparse.h>\n/* probe DSI syntax - if valid according to our own representation, we're good to go otherwise we'll need a reframer\n\nThis is needed because libavformat does not always expose the same dsi syntax depending on mux types (!)\n*/\nstatic u32 ffdmx_valid_should_reframe(u32 gpac_codec_id, u8 *dsi, u32 dsi_size)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tGF_AC3Config ac3;\n\tGF_M4ADecSpecInfo aaccfg;\n\tGF_AVCConfig *avcc;\n\tGF_HEVCConfig *hvcc;\n\tGF_VVCConfig *vvcc;\n\tGF_AV1Config *av1c;\n\tGF_VPConfig *vpxc;\n\n\tif (!dsi_size) dsi = NULL;\n\n\tswitch (gpac_codec_id) {\n\t//force reframer for the following formats if no DSI is found\n\tcase GF_CODECID_AC3:\n\tcase GF_CODECID_EAC3:\n\t\tif (dsi && (gf_odf_ac3_config_parse(dsi, dsi_size, (gpac_codec_id==GF_CODECID_EAC3) ? GF_TRUE : GF_FALSE, &ac3) == GF_OK))\n\t\t\treturn 0;\n\t\treturn 1;\n\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\tif (dsi && (gf_m4a_get_config(dsi, dsi_size, &aaccfg) == GF_OK))\n\t\t\treturn 0;\n\t\treturn 1;\n\n\tcase GF_CODECID_FLAC:\n\t\tif (!dsi) return 1;\n\t\tbreak;\n\tcase GF_CODECID_AVC:\n\t\tavcc = dsi ? gf_odf_avc_cfg_read(dsi, dsi_size) : NULL;\n\t\tif (avcc) {\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase GF_CODECID_HEVC:\n\t\thvcc = dsi ? gf_odf_hevc_cfg_read(dsi, dsi_size, GF_FALSE) : NULL;\n\t\tif (hvcc) {\n\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase GF_CODECID_VVC:\n\t\tvvcc = dsi ? gf_odf_vvc_cfg_read(dsi, dsi_size) : NULL;\n\t\tif (vvcc) {\n\t\t\tgf_odf_vvc_cfg_del(vvcc);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase GF_CODECID_AV1:\n\t\tav1c = dsi ? gf_odf_av1_cfg_read(dsi, dsi_size) : NULL;\n\t\tif (av1c) {\n\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase GF_CODECID_VP8:\n\tcase GF_CODECID_VP9:\n\t\tvpxc = dsi ? gf_odf_vp_cfg_read(dsi, dsi_size) : NULL;\n\t\tif (vpxc) {\n\t\t\tgf_odf_vp_cfg_del(vpxc);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t//force reframer for the following formats regardless of DSI and drop it\n\tcase GF_CODECID_MPEG1:\n\tcase GF_CODECID_MPEG2_422:\n\tcase GF_CODECID_MPEG2_SNR:\n\tcase GF_CODECID_MPEG2_HIGH:\n\tcase GF_CODECID_MPEG2_MAIN:\n\tcase GF_CODECID_MPEG2_SIMPLE:\n\tcase GF_CODECID_MPEG2_SPATIAL:\n\tcase GF_CODECID_MPEG4_PART2:\n\t\treturn 1;\n\n\t//SRT or other subs: sample data is the raw text but timing is at packet level, force a reframer to parse styles and other\n\t//keep dsi if any (for webvtt in mkv)\n\tcase GF_CODECID_SUBS_TEXT:\n\tcase GF_CODECID_WEBVTT:\n\tcase GF_CODECID_SUBS_SSA:\n\t\treturn 2;\n\n\t//all other codecs are reframed\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n#else\n\treturn 0;\n#endif\n}\n\nGF_Err ffdmx_init_common(GF_Filter *filter, GF_FFDemuxCtx *ctx, u32 grab_type)\n{\n\tu32 i;\n\tu32 nb_a, nb_v, nb_t, clock_id;\n\tchar szName[50];\n\n\n\tif (gf_filter_is_temporary(filter)) {\n\t\tgf_filter_meta_set_instances(filter, ctx->demuxer->av_class->class_name);\n\t\treturn GF_OK;\n\t}\n\n#if (LIBAVCODEC_VERSION_MAJOR >= 59)\n\tctx->pkt = av_packet_alloc();\n#endif\n\n\tctx->pids_ctx = gf_malloc(sizeof(PidCtx)*ctx->demuxer->nb_streams);\n\tmemset(ctx->pids_ctx, 0, sizeof(PidCtx)*ctx->demuxer->nb_streams);\n\tctx->nb_streams = ctx->demuxer->nb_streams;\n\n\tclock_id = 0;\n\tfor (i = 0; i < ctx->demuxer->nb_streams; i++) {\n\t\tAVStream *stream = ctx->demuxer->streams[i];\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\t\tAVCodecContext *codec = stream->codec;\n\t\tu32 codec_type = codec->codec_type;\n#else\n\t\tu32 codec_type = stream->codecpar->codec_type;\n#endif\n\t\tswitch(codec_type) {\n\t\tcase AVMEDIA_TYPE_AUDIO:\n\t\t\tif (!clock_id) clock_id = stream->id ? stream->id : i+1;\n\t\t\tbreak;\n\t\tcase AVMEDIA_TYPE_VIDEO:\n\t\t\tclock_id = stream->id ? stream->id : i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnb_a = nb_v = nb_t = 0;\n\tfor (i = 0; i < ctx->demuxer->nb_streams; i++) {\n\t\tGF_FilterPid *pid=NULL;\n\t\tPidCtx *pctx;\n\t\tu32 j;\n\t\tu32 force_reframer = 0;\n\t\tBool expose_ffdec=GF_FALSE;\n\t\tu32 gpac_codec_id;\n\t\tAVStream *stream = ctx->demuxer->streams[i];\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\t\tAVCodecContext *codec = stream->codec;\n\t\tu32 codec_type = codec->codec_type;\n\t\tu32 codec_id = codec->codec_id;\n\t\tconst uint8_t *exdata = codec->extradata;\n\t\tu32 exdata_size = codec->extradata_size;\n\t\tu32 codec_sample_rate = codec->sample_rate;\n\t\tu32 codec_frame_size = codec->frame_size;\n\t\tu32 codec_channels = codec->channels;\n\t\tu32 codec_width = codec->width;\n\t\tu32 codec_height = codec->height;\n\t\tu32 codec_field_order = codec->field_order;\n\t\tu32 codec_tag = codec->codec_tag;\n\t\tu32 codec_pixfmt = codec->pix_fmt;\n\t\tu32 codec_blockalign = 0;\n\t\tAVRational codec_framerate = {0, 0};\n#if LIBAVCODEC_VERSION_MAJOR >= 58\n\t\tcodec_framerate = codec->framerate;\n#endif\n\t\ts32 codec_sample_fmt = codec->sample_fmt;\n\t\tu32 codec_bitrate = (u32) codec->bit_rate;\n\n#else\n\t\tu32 codec_type = stream->codecpar->codec_type;\n\t\tu32 codec_id = stream->codecpar->codec_id;\n\t\tconst uint8_t *exdata = stream->codecpar->extradata;\n\t\tu32 exdata_size = stream->codecpar->extradata_size;\n\t\tu32 codec_sample_rate = stream->codecpar->sample_rate;\n\t\tu32 codec_frame_size = stream->codecpar->frame_size;\n\t\tu32 codec_channels = stream->codecpar->channels;\n\t\tu32 codec_width = stream->codecpar->width;\n\t\tu32 codec_height = stream->codecpar->height;\n\t\tu32 codec_field_order = stream->codecpar->field_order;\n\t\tu32 codec_tag = stream->codecpar->codec_tag;\n\t\tu32 codec_pixfmt = (codec_type==AVMEDIA_TYPE_VIDEO) ? stream->codecpar->format : 0;\n\t\ts32 codec_sample_fmt = (codec_type==AVMEDIA_TYPE_AUDIO) ? stream->codecpar->format : 0;\n\t\tu32 codec_bitrate = (u32) stream->codecpar->bit_rate;\n\t\tu32 codec_blockalign = (u32) stream->codecpar->block_align;\n\t\tAVRational codec_framerate = stream->r_frame_rate;\n\t\tif (!stream->r_frame_rate.num || !stream->r_frame_rate.den)\n\t\t\tcodec_framerate = stream->avg_frame_rate;\n#endif\n\n\t\t//if fps was detected by ffavin, use it (r_frame_rate is unreliable, just a guess)\n\t\tif (ctx->fps_forced.num) {\n\t\t\tcodec_framerate.num = ctx->fps_forced.num;\n\t\t\tcodec_framerate.den = ctx->fps_forced.den;\n\t\t}\n\t\tswitch(codec_type) {\n\t\tcase AVMEDIA_TYPE_AUDIO:\n\t\t\tpid = gf_filter_pid_new(filter);\n\t\t\tif (!pid) return GF_OUT_OF_MEM;\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO) );\n\t\t\tnb_a++;\n\t\t\tsprintf(szName, \"audio%d\", nb_a);\n\t\t\tif (ctx->audio_idx<0)\n\t\t\t\tctx->audio_idx = i;\n\t\t\tbreak;\n\n\t\tcase AVMEDIA_TYPE_VIDEO:\n\t\t\tpid = gf_filter_pid_new(filter);\n\t\t\tif (!pid) return GF_OUT_OF_MEM;\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL) );\n\t\t\tnb_v++;\n\t\t\tsprintf(szName, \"video%d\", nb_v);\n\t\t\tif (ctx->video_idx<0)\n\t\t\t\tctx->video_idx = i;\n\t\t\tbreak;\n\t\tcase AVMEDIA_TYPE_SUBTITLE:\n\t\t\tpid = gf_filter_pid_new(filter);\n\t\t\tif (!pid) return GF_OUT_OF_MEM;\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\t\t\tnb_t++;\n\t\t\tsprintf(szName, \"text%d\", nb_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(szName, \"ffdmx%d\", i+1);\n\t\t\tbreak;\n\t\t}\n\t\tif (!pid) continue;\n\t\tpctx = &ctx->pids_ctx[i];\n\t\tpctx->pid = pid;\n\t\tpctx->ts_offset = 0;\n\t\tgf_filter_pid_set_udta(pid, stream);\n\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT( (stream->id ? stream->id : i+1)) );\n\t\tgf_filter_pid_set_name(pid, szName);\n\n\t\tif (ctx->raw_data && ctx->sclock) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000000) );\n\t\t} else {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(stream->time_base.den) );\n\t\t}\n\t\tif (clock_id)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(clock_id) );\n\n\t\tif (!ctx->raw_data) {\n\t\t\tif (stream->duration>=0)\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(stream->duration, stream->time_base.den) );\n\t\t\telse if (ctx->demuxer->duration>=0)\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(ctx->demuxer->duration, AV_TIME_BASE) );\n\t\t}\n\n\t\tif (stream->sample_aspect_ratio.num && stream->sample_aspect_ratio.den)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_SAR, &PROP_FRAC_INT( stream->sample_aspect_ratio.num, stream->sample_aspect_ratio.den ) );\n\n\t\tffmpeg_tags_to_gpac(stream->metadata, pid);\n\n\t\tgpac_codec_id = ffmpeg_codecid_to_gpac(codec_id);\n\t\tif (!gpac_codec_id) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_FFMPEG) );\n\t\t\texpose_ffdec = GF_TRUE;\n\t\t} else {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(gpac_codec_id) );\n\t\t}\n\n\t\tif (grab_type)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_RAWGRAB, &PROP_UINT(grab_type) );\n\t\telse if (ctx->demuxer->iformat) {\n\t\t\tif ((ctx->demuxer->iformat->flags & AVFMT_SEEK_TO_PTS) || ctx->demuxer->iformat->read_seek)\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\n\n\t\tu32 lt = gf_log_get_tool_level(GF_LOG_CODING);\n\t\tgf_log_set_tool_level(GF_LOG_CODING, GF_LOG_QUIET);\n\t\tforce_reframer = ffdmx_valid_should_reframe(gpac_codec_id, (u8 *) exdata, exdata_size);\n\t\tgf_log_set_tool_level(GF_LOG_CODING, lt);\n\n\t\tif (expose_ffdec) {\n\t\t\tconst char *cname = avcodec_get_name(codec_id);\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_CODEC_ID, &PROP_POINTER( (void*)codec ) );\n#else\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_CODEC_ID, &PROP_UINT( codec_id ) );\n\t\t\tif (exdata) {\n\t\t\t\t//expose as const data\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DECODER_CONFIG, &PROP_CONST_DATA( (char *)exdata, exdata_size) );\n\t\t\t}\n#endif\n\n\t\t\tif (cname)\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_CODEC_NAME, &PROP_STRING(cname ) );\n\t\t} else if (exdata_size) {\n\n\t\t\t//avc/hevc read by ffmpeg is still in annex B format\n\t\t\tif (ctx->demuxer->iformat) {\n\t\t\t\tif (!strcmp(ctx->demuxer->iformat->name, \"h264\")\n\t\t\t\t\t|| !strcmp(ctx->demuxer->iformat->name, \"hevc\")\n\t\t\t\t\t|| !strcmp(ctx->demuxer->iformat->name, \"vvc\")\n\t\t\t\t) {\n\t\t\t\t\tforce_reframer = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//set extra data if desired\n\t\t\tif (force_reframer!=1) {\n\t\t\t\tffdmx_set_decoder_config(pctx, exdata, exdata_size, gpac_codec_id);\n\t\t\t}\n\t\t}\n\n\t\tif (force_reframer) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_UNFRAMED, &PROP_BOOL(GF_TRUE) );\n\t\t}\n\t\telse if (!gf_sys_is_test_mode() ){\n\t\t\t//force reparse of nalu-base codecs if no dovi support\n\t\t\tswitch (gpac_codec_id) {\n\t\t\tcase GF_CODECID_AVC:\n\t\t\tcase GF_CODECID_HEVC:\n\t\t\tcase GF_CODECID_LHVC:\n\t\t\tcase GF_CODECID_VVC:\n\t\t\tcase GF_CODECID_AV1:\n\t\t\t\tif (ctx->reparse\n#ifdef FFMPEG_NO_DOVI\n\t\t\t\t || 1\n#endif\n\t\t\t\t) {\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_FORCE_UNFRAME, &PROP_BOOL(GF_TRUE) );\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_UNFRAMED, &PROP_BOOL(GF_TRUE) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif (codec_sample_rate)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT( codec_sample_rate ) );\n\t\tif (codec_frame_size)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_SAMPLES_PER_FRAME, &PROP_UINT( codec_frame_size ) );\n\t\tif (codec_channels)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT( codec_channels ) );\n\n\t\tif (codec_width)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_WIDTH, &PROP_UINT( codec_width ) );\n\t\tif (codec_height)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_HEIGHT, &PROP_UINT( codec_height ) );\n\n\n#if (LIBAVFORMAT_VERSION_MAJOR >= 59)\n\t\tffmpeg_codec_par_to_gpac(stream->codecpar, pid, 0);\n\t\tif (gpac_codec_id!=GF_CODECID_RAW) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PIXFMT, NULL);\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_AUDIO_FORMAT, NULL);\n\t\t}\n#endif\n\n\t\tif (codec_width && codec_height) {\n\t\t\tif (codec_framerate.num && codec_framerate.den) {\n\t\t\t\tgf_media_get_reduced_frame_rate(&codec_framerate.num, &codec_framerate.den);\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_FPS, &PROP_FRAC_INT( codec_framerate.num, codec_framerate.den ) );\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] Unknown frame rate, will use 25 fps - use `:#FPS=VAL` to force frame rate signaling\\n\", ctx->fname));\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_FPS, &PROP_FRAC_INT( 25, 1 ) );\n\t\t\t}\n\t\t}\n\n\t\tif (codec_field_order>AV_FIELD_PROGRESSIVE)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_INTERLACED, &PROP_BOOL(GF_TRUE) );\n\n\t\tif ((codec_type==AVMEDIA_TYPE_VIDEO)\n\t\t\t&& (codec_pixfmt || ((codec_id==AV_CODEC_ID_RAWVIDEO) && codec_tag))\n\t\t) {\n\t\t\tBool is_full_range = GF_FALSE;\n\t\t\tu32 pfmt = 0;\n\n\t\t\tif (codec_pixfmt) {\n\t\t\t\tpfmt = ffmpeg_pixfmt_to_gpac(codec_pixfmt, GF_FALSE);\n\t\t\t\tis_full_range = ffmpeg_pixfmt_is_fullrange(codec_pixfmt);\n\t\t\t} else if (codec_tag) {\n\t\t\t\tpfmt = ffmpeg_pixfmt_from_codec_tag(codec_tag, &is_full_range);\n\t\t\t}\n\n\t\t\tif (!pfmt) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] Unsupported pixel format %d\\n\", ctx->fname, codec_pixfmt));\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PIXFMT, &PROP_UINT( pfmt) );\n\t\t\t\tif (is_full_range)\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_COLR_RANGE, &PROP_BOOL( GF_TRUE ) );\n\t\t\t}\n\t\t}\n\n\t\tif (codec_type==AVMEDIA_TYPE_SUBTITLE) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_SUBTYPE, &PROP_UINT(GF_4CC('s','b','t','l')));\n\t\t}\n\n\t\tctx->pids_ctx[i].mkv_webvtt = GF_FALSE;\n\t\tif ((gpac_codec_id==GF_CODECID_WEBVTT) && strstr(ctx->demuxer->iformat->name, \"matroska\"))\n\t\t\tctx->pids_ctx[i].mkv_webvtt = GF_TRUE;\n\n\t\tif (codec_sample_fmt>0) {\n\t\t\tu32 sfmt = 0;\n\t\t\tswitch (codec_sample_fmt) {\n\t\t\tcase AV_SAMPLE_FMT_U8: sfmt = GF_AUDIO_FMT_U8; break;\n\t\t\tcase AV_SAMPLE_FMT_S16: sfmt = GF_AUDIO_FMT_S16; break;\n\t\t\tcase AV_SAMPLE_FMT_S32: sfmt = GF_AUDIO_FMT_S32; break;\n\t\t\tcase AV_SAMPLE_FMT_FLT: sfmt = GF_AUDIO_FMT_FLT; break;\n\t\t\tcase AV_SAMPLE_FMT_DBL: sfmt = GF_AUDIO_FMT_DBL; break;\n\t\t\tcase AV_SAMPLE_FMT_U8P: sfmt = GF_AUDIO_FMT_U8P; break;\n\t\t\tcase AV_SAMPLE_FMT_S16P: sfmt = GF_AUDIO_FMT_S16P; break;\n\t\t\tcase AV_SAMPLE_FMT_S32P: sfmt = GF_AUDIO_FMT_S32P; break;\n\t\t\tcase AV_SAMPLE_FMT_FLTP: sfmt = GF_AUDIO_FMT_FLTP; break;\n\t\t\tcase AV_SAMPLE_FMT_DBLP: sfmt = GF_AUDIO_FMT_DBLP; break;\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] Unsupported sample format %d\\n\", ctx->fname, codec_sample_fmt));\n\t\t\t}\n\t\t\tif (gpac_codec_id==GF_CODECID_RAW) {\n\t\t\t\tu32 res = ffmpeg_codecid_to_gpac_audio_fmt(codec_id);\n\t\t\t\tif (res) sfmt = res;\n\t\t\t}\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT( sfmt) );\n\t\t}\n\n\t\tif (codec_bitrate)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_BITRATE, &PROP_UINT( (u32) codec_bitrate ) );\n\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_URL, &PROP_STRING( AVFMT_URL(ctx->demuxer) ));\n\n\t\tif (gf_file_exists(ctx->src)) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_FILE_CACHED, &PROP_BOOL(GF_TRUE));\n\t\t}\n\n\t\tif (codec_blockalign)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_OPAQUE, &PROP_UINT(codec_blockalign));\n\n\t\tif ((stream->disposition & AV_DISPOSITION_DEFAULT) && !gf_sys_is_test_mode()) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_IS_DEFAULT, &PROP_BOOL(GF_TRUE));\n\t\t}\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_MUX_INDEX, &PROP_UINT(i+1));\n\n\t\tfor (j=0; j<(u32) stream->nb_side_data; j++) {\n\t\t\tffdmx_parse_side_data(&stream->side_data[i], pid);\n\t\t}\n\n\t\tif (ctx->demuxer->nb_chapters) {\n\t\t\tGF_PropertyValue p;\n\t\t\tGF_PropUIntList times;\n\t\t\tGF_PropStringList names;\n\t\t\tu32 nb_c = ctx->demuxer->nb_chapters;\n\n\t\t\ttimes.vals = gf_malloc(sizeof(u32)*nb_c);\n\t\t\tnames.vals = gf_malloc(sizeof(char *)*nb_c);\n\t\t\tmemset(names.vals, 0, sizeof(char *)*nb_c);\n\t\t\ttimes.nb_items = names.nb_items = nb_c;\n\n\t\t\tfor (j=0; j<ctx->demuxer->nb_chapters; j++) {\n\t\t\t\tAVChapter *c = ctx->demuxer->chapters[j];\n\t\t\t\tu64 start = gf_timestamp_rescale(c->start * c->time_base.num, c->time_base.den, 1000);\n\t\t\t\ttimes.vals[j] = (u32) start;\n\t\t\t\tAVDictionaryEntry *ent = NULL;\n\t\t\t\twhile (c->metadata) {\n\t\t\t\t\tent = av_dict_get(c->metadata, \"\", ent, AV_DICT_IGNORE_SUFFIX);\n\t\t\t\t\tif (!ent) break;\n\t\t\t\t\tif (!strcmp(ent->key, \"title\")) {\n\t\t\t\t\t\tnames.vals[j] = gf_strdup(ent->value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!names.vals[j]) names.vals[j] = gf_strdup(\"Unknwon\");\n\t\t\t}\n\t\t\tp.type = GF_PROP_UINT_LIST;\n\t\t\tp.value.uint_list = times;\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CHAP_TIMES, &p);\n\t\t\tgf_free(times.vals);\n\n\t\t\tp.type = GF_PROP_STRING_LIST;\n\t\t\tp.value.string_list = names;\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CHAP_NAMES, &p);\n\t\t\t//no free for string lists\n\t\t}\n\t}\n\n\tif (!nb_a && !nb_v && !nb_t)\n\t\treturn GF_NOT_SUPPORTED;\n\n\treturn GF_OK;\n}\n\nstatic int ffavio_read_packet(void *opaque, uint8_t *buf, int buf_size)\n{\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *)opaque;\n\tint res = (int) gf_fread(buf, buf_size, ctx->gfio);\n\tif (!res && gf_feof(ctx->gfio)) {\n\t\treturn AVERROR_EOF;\n\t}\n\treturn res;\n}\n\nstatic int64_t ffavio_seek(void *opaque, int64_t offset, int whence)\n{\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *)opaque;\n\tif (whence==AVSEEK_SIZE) {\n\t\tu64 pos = gf_ftell(ctx->gfio);\n\t\tu64 size = gf_fsize(ctx->gfio);\n\t\tgf_fseek(ctx->gfio, pos, SEEK_SET);\n\t\treturn size;\n\t}\n\treturn (int64_t) gf_fseek(ctx->gfio, offset, whence);\n}\n\n#include <libavutil/avstring.h>\nstatic GF_Err ffdmx_initialize(GF_Filter *filter)\n{\n\tGF_FFDemuxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_Err e;\n\ts32 res;\n\tu32 i;\n\tchar *ext;\n\tconst char *url;\n\tconst AVInputFormat *av_in = NULL;\n\tctx->fname = \"FFDmx\";\n\tctx->log_class = GF_LOG_CONTAINER;\n\n\tffmpeg_setup_logs(ctx->log_class);\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode()) {\n\t\tffdmx_update_arg(filter, \"foo\", &PROP_STRING_NO_COPY(\"bar\"));\n\t\tffmpeg_pixfmt_from_codec_tag(0, NULL);\n#if (LIBAVCODEC_VERSION_MAJOR > 56)\n\t\tffmpeg_codec_par_to_gpac(NULL, NULL, 0);\n#endif\n\t}\n#endif\n\tif (!ctx->src) {\n//\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Missing file name, cannot open\\n\", ctx->fname));\n\t\treturn GF_OK;\n\t}\n\t/*some extensions not supported by ffmpeg, overload input format*/\n\text = strrchr(ctx->src, '.');\n\tif (ext) {\n\t\tif (!stricmp(ext+1, \"cmp\")) av_in = av_find_input_format(\"m4v\");\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, ctx->log_class, (\"[%s] opening file %s - av_in %08x\\n\", ctx->fname, ctx->src, av_in));\n\n\tctx->demuxer = avformat_alloc_context();\n\tffmpeg_set_mx_dmx_flags(ctx->options, ctx->demuxer);\n\n\turl = ctx->src;\n\tif (!strncmp(ctx->src, \"gfio://\", 7)) {\n\t\tctx->gfio = gf_fopen(ctx->src, \"rb\");\n\t\tif (!ctx->gfio) {\n\t\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Failed to open %s\\n\", ctx->fname, ctx->src));\n\t\t\treturn GF_URL_ERROR;\n\t\t}\n\t\tctx->avio_ctx_buffer = av_malloc(ctx->block_size);\n\t\tif (!ctx->avio_ctx_buffer) {\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tctx->avio_ctx = avio_alloc_context(ctx->avio_ctx_buffer, ctx->block_size,\n\t\t\t\t\t\t\t\t\t  0, ctx, &ffavio_read_packet, NULL, &ffavio_seek);\n\n\t\tif (!ctx->avio_ctx) {\n\t\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Failed to create AVIO context for %s\\n\", ctx->fname, ctx->src));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tctx->demuxer->pb = ctx->avio_ctx;\n\t\turl = gf_fileio_translate_url(ctx->src);\n\t}\n\n\tAVDictionary *options = NULL;\n\tav_dict_copy(&options, ctx->options, 0);\n\n\tres = avformat_open_input(&ctx->demuxer, url, FF_IFMT_CAST av_in, &options);\n\n\tswitch (res) {\n\tcase 0:\n\t\te = GF_OK;\n\t\tbreak;\n\tcase AVERROR_INVALIDDATA:\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tbreak;\n\tcase AVERROR_DEMUXER_NOT_FOUND:\n\tcase -ENOENT:\n\t\te = GF_URL_ERROR;\n\t\tbreak;\n\tcase AVERROR_EOF:\n\t\te = GF_EOS;\n\t\tbreak;\n\tdefault:\n\t\te = GF_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\n\tif (e && gf_filter_is_temporary(filter)) {\n\t\text = strrchr(ctx->src, '.');\n\t\tconst AVInputFormat *ifmt = av_find_input_format(ctx->src);\n\t\tif (!ifmt && ext) ifmt = av_find_input_format(ext+1);\n#if (LIBAVFORMAT_VERSION_MAJOR>=59)\n\t\tif (!ifmt && ext) {\n\t\t\tconst AVInputFormat *fmt = NULL;\n\t\t\tvoid *i = 0;\n\t\t\twhile ((fmt = av_demuxer_iterate(&i))) {\n\t\t\t\tif (av_match_name(ext+1, fmt->extensions)) {\n\t\t\t\t\tifmt = fmt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\tif (ifmt) {\n\t\t\tgf_filter_meta_set_instances(filter, ifmt->name);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Fail to open %s - error %s\\n\", ctx->fname, ctx->src, av_err2str(res) ));\n\t\tavformat_close_input(&ctx->demuxer);\n\t\tavformat_free_context(ctx->demuxer);\n\t\tctx->demuxer = NULL;\n\t\tif (options) av_dict_free(&options);\n\t\treturn e;\n\t}\n\n\tAVDictionary** optionsarr = NULL;\n\tu32 optionsarr_size = 0;\n\tif (ctx->options && ctx->demuxer) {\n\t\toptionsarr = (AVDictionary**)gf_malloc(ctx->demuxer->nb_streams * sizeof(AVDictionary*));\n\t\toptionsarr_size = ctx->demuxer->nb_streams;\n\t\tfor (i=0; i < optionsarr_size; i++) {\n\t\t\toptionsarr[i] = NULL;\n\t\t\tav_dict_copy(&optionsarr[i], ctx->options, 0);\n\t\t}\n\t}\n\n\tres = avformat_find_stream_info(ctx->demuxer, optionsarr);\n\n\tif (optionsarr) {\n\t\tfor (i=0; i < optionsarr_size; i++) {\n\t\t\tav_dict_free(&optionsarr[i]);\n\t\t}\n\t\tgf_free(optionsarr);\n\t\toptionsarr = NULL;\n\t}\n\n\tif (res <0) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] cannot locate streams - error %s\\n\", ctx->fname, av_err2str(res)));\n\t\te = GF_NOT_SUPPORTED;\n\t\tavformat_close_input(&ctx->demuxer);\n\t\tavformat_free_context(ctx->demuxer);\n\t\tctx->demuxer = NULL;\n\t\tif (options) av_dict_free(&options);\n\t\treturn e;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, ctx->log_class, (\"[%s] file %s opened - %d streams\\n\", ctx->fname, ctx->src, ctx->demuxer->nb_streams));\n\n\tffmpeg_report_options(filter, options, ctx->options);\n\treturn ffdmx_init_common(filter, ctx, 0);\n}\n\nstatic int ffdmx_read_packet(void *opaque, uint8_t *buf, int buf_size)\n{\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *)opaque;\n\tif (ctx->in_seek && (ctx->seek_offset >= 0)) {\n\t\tctx->in_seek = 2;\n\t\treturn -1;\n\t}\n\tif (ctx->strbuf_offset + buf_size > ctx->strbuf_size) {\n\t\tif (!ctx->in_eos) {\n\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] Internal buffer too small, may result in packet drops - try increaset strbuf_min option\\n\", ctx->fname));\n\t\t\tctx->strbuf_min += ctx->strbuf_offset + buf_size - ctx->strbuf_size;\n\t\t}\n\t\tif (buf_size && (ctx->strbuf_size == ctx->strbuf_offset)) {\n\t\t\treturn ctx->in_eos ? AVERROR_EOF : AVERROR(EAGAIN);\n\t\t}\n\t\tbuf_size = ctx->strbuf_size - ctx->strbuf_offset;\n\t}\n\tmemcpy(buf, ctx->strbuf + ctx->strbuf_offset, buf_size);\n\tctx->strbuf_offset += buf_size;\n\t//if 2xbuffer size is larger than our min internal buffer, increase size - this should limit risks of getting called with no packets to deliver\n\tif ((u32)buf_size*2 >= ctx->strbuf_min)\n\t\tctx->strbuf_min = 2*buf_size;\n\treturn buf_size;\n}\n\nstatic int64_t ffdmx_seek(void *opaque, int64_t offset, int whence)\n{\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *)opaque;\n\tif (whence==AVSEEK_SIZE) {\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_DOWN_SIZE);\n\t\tif (p) return p->value.longuint;\n\t\tGF_PropertyEntry *pe=NULL;\n\t\tp = gf_filter_pid_get_info(ctx->ipid, GF_PROP_PID_DOWN_SIZE, &pe);\n\t\ts64 val = p ? p->value.longuint : -1;\n\t\tgf_filter_release_property(pe);\n\t\treturn val;\n\t}\n\tif (ctx->in_seek) {\n\t\tif (ctx->in_seek == 1) {\n\t\t\tctx->seek_offset = offset;\n\t\t\treturn offset;\n\t\t}\n\t\treturn -1;\n\t}\n\t//if seeking in first block (while probing for stream info), allow it\n\tif (ctx->first_block && (whence==SEEK_SET) && (offset<ctx->strbuf_size)) {\n\t\tctx->strbuf_offset = (u32) offset;\n\t\treturn offset;\n\t}\n\treturn -1;\n}\n\nstatic GF_Err ffdmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_FFDemuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (ctx->ipid && is_remove) {\n\t\tu32 i;\n\t\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\t\tif (ctx->pids_ctx[i].pid) gf_filter_pid_remove(ctx->pids_ctx[i].pid);\n\t\t\tctx->pids_ctx[i].pid = NULL;\n\t\t}\n\t\tctx->nb_playing = 0;\n\t\treturn GF_EOS;\n\t}\n\tif (ctx->src) return GF_BAD_PARAM;\n\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property(pid, GF_PROP_PID_URL);\n\tif (!p || !p->value.string || !stricmp(p->value.string, \"null\"))\n\t\treturn GF_NOT_SUPPORTED;\n\tctx->src = gf_strdup(p->value.string);\n\tctx->ipid = pid;\n\tif (ctx->avio_ctx_buffer) return GF_OK;\n\tctx->avio_ctx_buffer = av_malloc(ctx->block_size);\n\tif (!ctx->avio_ctx_buffer) return GF_OUT_OF_MEM;\n\n\tctx->strbuf_min = ctx->strbuf_alloc = 1000000;\n\tctx->strbuf = gf_malloc(ctx->strbuf_alloc);\n\tif (!ctx->strbuf) return GF_OUT_OF_MEM;\n\n\tctx->avio_ctx = avio_alloc_context(ctx->avio_ctx_buffer, ctx->block_size, 0, ctx, &ffdmx_read_packet, NULL, &ffdmx_seek);\n//\tctx->avio_ctx = avio_alloc_context(ctx->avio_ctx_buffer, ctx->block_size, 0, ctx, &ffdmx_read_packet, NULL, NULL);\n\tif (!ctx->avio_ctx) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Failed to create AVIO context for %s\\n\", ctx->fname, ctx->src));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tctx->demuxer = avformat_alloc_context();\n\tffmpeg_set_mx_dmx_flags(ctx->options, ctx->demuxer);\n\treturn GF_OK;\n}\n\n\nstatic Bool ffdmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tGF_FFDemuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (evt->play.initial_broadcast_play==2)\n\t\t\treturn GF_TRUE;\n\n\t\tctx->nb_playing++;\n\t\tif (ctx->nb_playing>1) {\n\t\t\tBool skip_com = GF_TRUE;\n\t\t\t//PLAY/STOP may arrive at different times depending on the length of filter chains on each PID\n\t\t\t//we stack number of STOP received and trigger seek when we have the same amount of play\n\t\t\tif (ctx->nb_stop_pending==ctx->nb_playing) {\n\t\t\t\tskip_com = GF_FALSE;\n\t\t\t\tctx->last_play_start_range = 0;\n\t\t\t}\n\t\t\tif (skip_com) {\n\t\t\t\tif (evt->play.orig_delay) {\n\t\t\t\t\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\t\t\t\t\tif (ctx->pids_ctx[i].pid==evt->base.on_pid) {\n\t\t\t\t\t\t\tctx->pids_ctx[i].ts_offset = evt->play.orig_delay+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\tctx->nb_playing--;\n\t\t}\n\n\t\t//change in play range\n\t\tBool cancel_event = ctx->ipid ? GF_FALSE : GF_TRUE;\n\t\tif (!ctx->raw_data && (ctx->last_play_start_range != evt->play.start_range)) {\n\t\t\tu32 i;\n\t\t\tif (ctx->ipid) {\n\t\t\t\tctx->seek_ms = 0;\n\t\t\t\tctx->in_seek = 1;\n\t\t\t\tctx->seek_offset = -1;\n\t\t\t}\n\n\t\t\tint res = av_seek_frame(ctx->demuxer, -1, (s64) (AV_TIME_BASE*evt->play.start_range), AVSEEK_FLAG_BACKWARD);\n\t\t\tif (res<0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] Fail to seek %s to %g - error %s\\n\", ctx->fname, ctx->src, evt->play.start_range, av_err2str(res) ));\n\t\t\t\tctx->in_seek = 2;\n\t\t\t\tctx->seek_offset=0;\n\t\t\t}\n\t\t\tif (ctx->ipid && (ctx->seek_offset>=0)) {\n\t\t\t\tGF_FilterEvent fevt;\n\t\t\t\t//failed to seek, start from 0\n\t\t\t\tif (evt->play.start_range && (ctx->in_seek==2)) {\n\t\t\t\t\tctx->seek_offset=0;\n\t\t\t\t\tctx->seek_ms = (u64) (1000*evt->play.start_range);\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] Fail to seek %s to %g, seeking from start\\n\", ctx->fname, ctx->src, evt->play.start_range));\n\t\t\t\t\tif (res<0)\n\t\t\t\t\t\tav_seek_frame(ctx->demuxer, -1, 0, AVSEEK_FLAG_BACKWARD);\n\t\t\t\t}\n\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\t\t\tfevt.seek.start_offset = ctx->seek_offset;\n\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\tctx->strbuf_size = 0;\n\t\t\t\tctx->strbuf_offset = 0;\n\t\t\t\tcancel_event = GF_TRUE;\n\t\t\t}\n\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t//reset initial delay compute\n\t\t\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\t\t\tctx->pids_ctx[i].ts_offset = 0;\n\t\t\t\tif (evt->play.orig_delay && (ctx->pids_ctx[i].pid==evt->base.on_pid)) {\n\t\t\t\t\tctx->pids_ctx[i].ts_offset = evt->play.orig_delay+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->last_play_start_range = evt->play.start_range;\n\t\t}\n\t\tctx->stop_seen = GF_FALSE;\n\t\treturn cancel_event;\n\n\tcase GF_FEVT_STOP:\n\t\tif (evt->play.initial_broadcast_play==2)\n\t\t\treturn GF_TRUE;\n\t\tctx->nb_stop_pending++;\n\t\tif (ctx->nb_playing) {\n\t\t\tctx->nb_playing--;\n\t\t\tctx->stop_seen = GF_TRUE;\n\t\t}\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GF_FilterProbeScore ffdmx_probe_url(const char *url, const char *mime)\n{\n\tif (!strncmp(url, \"video://\", 8)) return GF_FPROBE_NOT_SUPPORTED;\n\tif (!strncmp(url, \"audio://\", 8)) return GF_FPROBE_NOT_SUPPORTED;\n\tif (!strncmp(url, \"av://\", 5)) return GF_FPROBE_NOT_SUPPORTED;\n\tif (!strncmp(url, \"pipe://\", 7)) return GF_FPROBE_NOT_SUPPORTED;\n\n\tconst char *ext = gf_file_ext_start(url);\n\tif (ext) {\n\t\tconst AVInputFormat *f = av_find_input_format(ext+1);\n\t\tif (!f)\n\t\t\treturn GF_FPROBE_MAYBE_NOT_SUPPORTED;\n\t}\n\treturn GF_FPROBE_MAYBE_SUPPORTED;\n}\n\nextern Bool ff_probe_mode;\nstatic const char *ffdmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tint ffscore;\n\tconst AVInputFormat *probe_fmt;\n\tAVProbeData pb;\n\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\tav_register_all();\n#endif\n\n\tmemset(&pb, 0, sizeof(AVProbeData));\n\tff_probe_mode=GF_TRUE;\n\t//not setting this crashes some probers in ffmpeg\n\tpb.filename = \"\";\n\tif (size <= AVPROBE_PADDING_SIZE) {\n\t\tpb.buf = gf_malloc(sizeof(char) * (size+AVPROBE_PADDING_SIZE) );\n\t\tmemcpy(pb.buf, data, sizeof(char)*size);\n\t\tmemset(pb.buf+size, 0, sizeof(char)*AVPROBE_PADDING_SIZE);\n\t\tpb.buf_size = size;\n\t\tprobe_fmt = av_probe_input_format3(&pb, GF_TRUE, &ffscore);\n\t\tif (ffscore<=AVPROBE_SCORE_RETRY/2) probe_fmt=NULL;\n\t\tif (!probe_fmt) probe_fmt = av_probe_input_format3(&pb, GF_FALSE, &ffscore);\n\t\tif (ffscore<=AVPROBE_SCORE_RETRY/2) probe_fmt=NULL;\n\t\tgf_free(pb.buf);\n\t} else {\n\t\tpb.buf =  (char *) data;\n\t\tpb.buf_size = size - AVPROBE_PADDING_SIZE;\n\t\tprobe_fmt = av_probe_input_format3(&pb, GF_TRUE, &ffscore);\n\t\tif (ffscore<=AVPROBE_SCORE_RETRY/2) probe_fmt=NULL;\n\t\tif (!probe_fmt) probe_fmt = av_probe_input_format3(&pb, GF_FALSE, &ffscore);\n\t\tif (ffscore<=AVPROBE_SCORE_RETRY/2) probe_fmt=NULL;\n\t}\n\tff_probe_mode=GF_FALSE;\n\n\tif (!probe_fmt) return NULL;\n\tif (probe_fmt->mime_type) {\n\t\t//TODO try to refine based on ffprobe score\n\t\t*score = GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn probe_fmt->mime_type;\n\t}\n\t*score = (ffscore==AVPROBE_SCORE_MAX) ? GF_FPROBE_MAYBE_SUPPORTED : GF_FPROBE_MAYBE_NOT_SUPPORTED;\n\treturn \"video/x-ffmpeg\";\n}\n\n#define OFFS(_n)\t#_n, offsetof(GF_FFDemuxCtx, _n)\n\nstatic const GF_FilterCapability FFDmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\t{0},\n\t//for forced frame->unframe\n\tCAP_UINT(GF_CAPS_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_BOOL(GF_CAPS_OUTPUT,GF_PROP_PID_FORCE_UNFRAME, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_OUTPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n\nGF_FilterRegister FFDemuxRegister = {\n\t.name = \"ffdmx\",\n\t.version=LIBAVFORMAT_IDENT,\n\tGF_FS_SET_DESCRIPTION(\"FFMPEG demultiplexer\")\n\tGF_FS_SET_HELP(\"This filter demultiplexes an input file or open a source protocol using FFMPEG.\\n\"\n\t\"See FFMPEG documentation (https://ffmpeg.org/documentation.html) for more details.\\n\"\n\t\"To list all supported demultiplexers for your GPAC build, use `gpac -h ffdmx:*`.\\n\"\n\t\"This will list both supported input formats and protocols.\\n\"\n\t\"Input protocols are listed with `Description: Input protocol`, and the subclass name identifies the protocol scheme.\\n\"\n\t\"For example, if `ffdmx:rtmp` is listed as input protocol, this means `rtmp://` source URLs are supported.\\n\"\n\t)\n\t.private_size = sizeof(GF_FFDemuxCtx),\n\tSETCAPS(FFDmxCaps),\n\t.initialize = ffdmx_initialize,\n\t.finalize = ffdmx_finalize,\n\t.process = ffdmx_process,\n\t.update_arg = ffdmx_update_arg,\n\t.probe_url = ffdmx_probe_url,\n\t.probe_data = ffdmx_probe_data,\n\t.process_event = ffdmx_process_event,\n\t.flags = GF_FS_REG_META | GF_FS_REG_USE_SYNC_READ,\n\t.priority = 128\n\n};\n\n\nstatic const GF_FilterArgs FFDemuxArgs[] =\n{\n\t{ OFFS(src), \"URL of source content\", GF_PROP_NAME, NULL, NULL, 0},\n\t{ OFFS(reparse), \"force reparsing of stream content (AVC,HEVC,VVC,AV1 only for now)\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(block_size), \"block size used to read file when using GFIO context\", GF_PROP_UINT, \"4096\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(strbuf_min), \"internal buffer size when demuxing from GPAC's input stream\", GF_PROP_UINT, \"1MB\", NULL, GF_ARG_HINT_EXPERT},\n\t{ \"*\", -1, \"any possible options defined for AVFormatContext and sub-classes. See `gpac -hx ffdmx` and `gpac -hx ffdmx:*`\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_META},\n\t{0}\n};\n\nconst int FFDMX_STATIC_ARGS = (sizeof (FFDemuxArgs) / sizeof (GF_FilterArgs)) - 1;\n\n\nconst GF_FilterRegister *ffdmx_register(GF_FilterSession *session)\n{\n\treturn ffmpeg_build_register(session, &FFDemuxRegister, FFDemuxArgs, FFDMX_STATIC_ARGS, FF_REG_TYPE_DEMUX);\n}\n\n//we define a dedicated registry for demuxing a GPAC pid using ffmpeg, not doing so can create wrong link resolutions\n//disabling GPAC demuxers\nstatic const GF_FilterCapability FFPidDmxCaps[] =\n{\n\t//for demuxing input pids\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FILEPATH, \"*\"),\n\tCAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_URL, \"NULL\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n\t{0},\n\t//for forced frame->unframe from pid\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FILEPATH, \"*\"),\n\tCAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_URL, \"NULL\"),\n\tCAP_UINT(GF_CAPS_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_BOOL(GF_CAPS_OUTPUT,GF_PROP_PID_FORCE_UNFRAME, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_OUTPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n\t{0},\n};\nstatic const GF_FilterArgs FFDemuxPidArgs[] =\n{\n\t{ OFFS(reparse), \"force reparsing of stream content (AVC,HEVC,VVC,AV1 only for now)\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(block_size), \"block size used to read file when using GFIO context\", GF_PROP_UINT, \"4096\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(strbuf_min), \"internal buffer size when demuxing from GPAC's input stream\", GF_PROP_UINT, \"1MB\", NULL, GF_ARG_HINT_EXPERT},\n\t{0}\n};\n\nstatic void ffdmxpid_finalize(GF_Filter *filter)\n{\n\tGF_FFDemuxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->src) {\n\t\tgf_free((char *)ctx->src);\n\t\tctx->src = NULL;\n\t}\n\tffdmx_finalize(filter);\n\n}\nconst GF_FilterRegister FFDemuxPidRegister = {\n\t.name = \"ffdmxpid\",\n\t.version=LIBAVFORMAT_IDENT,\n\tGF_FS_SET_DESCRIPTION(\"FFMPEG demultiplexer\")\n\tGF_FS_SET_HELP(\"Alias of ffdmx for GPAC pid demultiplexing, same options as ffdmx.\\n\")\n\t.private_size = sizeof(GF_FFDemuxCtx),\n\tSETCAPS(FFPidDmxCaps),\n\t.initialize = ffdmx_initialize,\n\t.finalize = ffdmxpid_finalize,\n\t.configure_pid = ffdmx_configure_pid,\n\t.process = ffdmx_process,\n\t.update_arg = ffdmx_update_arg,\n\t.process_event = ffdmx_process_event,\n\t.flags = GF_FS_REG_META,\n\t.args = FFDemuxPidArgs,\n\t//also set lower priority\n\t.priority = 128\n};\n\nconst GF_FilterRegister *ffdmxpid_register(GF_FilterSession *session)\n{\n\tif (gf_opts_get_bool(\"temp\", \"gendoc\")) return NULL;\n\treturn &FFDemuxPidRegister;\n}\n\n\n#ifndef FFMPEG_DISABLE_AVDEVICE\n\nstatic GF_Err ffavin_initialize(GF_Filter *filter)\n{\n\ts32 res, i, dev_idx=-1;\n\tBool has_a, has_v;\n\tchar szPatchedName[1024];\n\tconst char *dev_name=NULL;\n\tconst char *default_fmt=NULL;\n\tconst AVInputFormat *dev_fmt=NULL;\n\tGF_FFDemuxCtx *ctx = gf_filter_get_udta(filter);\n\tBool wants_audio = GF_FALSE;\n\tBool wants_video = GF_FALSE;\n\tctx->fname = \"FFAVIn\";\n\tctx->log_class = GF_LOG_MMIO;\n\n\tffmpeg_setup_logs(ctx->log_class);\n\n\tavdevice_register_all();\n\n\tif (!ctx->src) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] No source URL specified, expecting video://, audio:/ or av://\\n\", ctx->fname));\n\t\treturn GF_SERVICE_ERROR;\n\t}\n\tdefault_fmt = ctx->fmt;\n\tif (!default_fmt) {\n#ifdef WIN32\n\t\tdefault_fmt = \"dshow\";\n#elif defined(__DARWIN) || defined(__APPLE__)\n\t\tdefault_fmt = \"avfoundation\";\n#elif defined(GPAC_CONFIG_ANDROID)\n\t\tdefault_fmt = \"android_camera\";\n#else\n\t\tdefault_fmt = \"video4linux2\";\n#endif\n\t}\n\n\tif (default_fmt) {\n\t\tdev_fmt = av_find_input_format(default_fmt);\n\t\tif (dev_fmt == NULL) {\n\t\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Cannot find the input format %s\\n\", ctx->fname, default_fmt));\n\t\t}\n#if LIBAVCODEC_VERSION_MAJOR >= 58\n\t\telse if (dev_fmt->priv_class->category != AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT && dev_fmt->priv_class->category != AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT) {\n\t\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s]] %s is neither a video nor an audio input device\\n\", ctx->fname, default_fmt));\n\t\t\tdev_fmt = NULL;\n\t\t}\n#else\n\t\t//not supported for old FFMPEG versions\n#endif\n\t}\n#if (LIBAVCODEC_VERSION_MAJOR >= 58) && (LIBAVCODEC_VERSION_MINOR>=20)\n\tif (!dev_fmt) {\n\t\twhile (1) {\n\t\t\tdev_fmt = av_input_video_device_next(FF_IFMT_CAST dev_fmt);\n\t\t\tif (!dev_fmt) break;\n\t\t\tif (!dev_fmt || !dev_fmt->priv_class) continue;\n\t\t\tif ((dev_fmt->priv_class->category != AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT) && (dev_fmt->priv_class->category != AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT))\n\t\t\t\tcontinue;\n\n\t\t\t//listing devices is on its way of implementation in ffmpeg ... for now break at first provider\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\tif (!dev_fmt) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] No input format specified\\n\", ctx->fname, ctx->fmt));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tdev_name = ctx->dev;\n\n\tif (!strncmp(ctx->src, \"video://\", 8)) wants_video = GF_TRUE;\n\telse if (!strncmp(ctx->src, \"audio://\", 8)) wants_audio = GF_TRUE;\n\telse if (!strncmp(ctx->src, \"av://\", 5)) wants_video = wants_audio = GF_TRUE;\n\n\tif (sscanf(dev_name, \"%d\", &dev_idx)==1) {\n\t\tsprintf(szPatchedName, \"%d\", dev_idx);\n\t\tif (strcmp(szPatchedName, dev_name))\n\t\t\tdev_idx = -1;\n\t} else {\n\t\tdev_idx = -1;\n\t}\n\n\tszPatchedName[0]=0;\n\n#if defined(__DARWIN) || defined(__APPLE__)\n\tif (!strncmp(dev_name, \"screen\", 6)) {\n\t\tstrcpy(szPatchedName, \"Capture screen \");\n\t\tstrcat(szPatchedName, dev_name+6);\n\t\tdev_name = (char *) szPatchedName;\n\t}\n#endif\n\tif (!strncmp(dev_fmt->priv_class->class_name, \"V4L2\", 4) && (dev_idx>=0) ) {\n\t\tif (wants_audio) {\n\t\t\tsprintf(szPatchedName, \"/dev/video%d:hw:%d\", dev_idx, dev_idx);\n\t\t} else {\n\t\t\tsprintf(szPatchedName, \"/dev/video%d\", dev_idx);\n\t\t}\n\t\tdev_name = (char *) szPatchedName;\n\t}\n\n\telse if (wants_video && wants_audio && (dev_idx>=0)) {\n\t\tsprintf(szPatchedName, \"%d:%d\", dev_idx, dev_idx);\n\t\tdev_name = (char *) szPatchedName;\n\t}\n#if defined(__APPLE__) && !defined(GPAC_CONFIG_IOS)\n\telse if (!strncmp(dev_fmt->priv_class->class_name, \"AVFoundation\", 12) && wants_audio && !wants_video) {\n\t\t//for avfoundation if no video, we must use \":audio_dev_idx\"\n\t\tif (ctx->dev[0] != ':') {\n\t\t\tstrcpy(szPatchedName, \":\");\n\t\t\tstrcat(szPatchedName, ctx->dev);\n\t\t\tdev_name = (char *) szPatchedName;\n\t\t}\n\t}\n#endif\n\n\t/* Open video */\n\tctx->demuxer = avformat_alloc_context();\n\tffmpeg_set_mx_dmx_flags(ctx->options, ctx->demuxer);\n\n\tAVDictionary *options = NULL;\n\tav_dict_copy(&options, ctx->options, 0);\n\n\tres = avformat_open_input(&ctx->demuxer, dev_name, FF_IFMT_CAST dev_fmt, &options);\n\tif ( (res < 0) && !stricmp(ctx->dev, \"screen-capture-recorder\") ) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Buggy screen capture input (open failed with code %d), retrying without specifying resolution\\n\", ctx->fname, res));\n\t\tav_dict_free(&options);\n\t\toptions = NULL;\n\t\tav_dict_copy(&options, ctx->options, 0);\n\t\tav_dict_set(&options, \"video_size\", NULL, 0);\n\t\tres = avformat_open_input(&ctx->demuxer, ctx->dev, FF_IFMT_CAST dev_fmt, &options);\n\t}\n\n\tif (res < 0) {\n\t\tav_dict_free(&options);\n\t\toptions = NULL;\n\t\tav_dict_copy(&options, ctx->options, 0);\n\t\tav_dict_set(&options, \"framerate\", \"30\", 0);\n\t\tctx->fps_forced.num = 30;\n\t\tctx->fps_forced.den = 1;\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Error %d opening input - retrying with 30 fps\\n\", ctx->fname, res));\n\t\tres = avformat_open_input(&ctx->demuxer, dev_name, FF_IFMT_CAST dev_fmt, &options);\n\t\tif (res < 0) {\n\t\t\tav_dict_free(&options);\n\t\t\toptions = NULL;\n\t\t\tav_dict_copy(&options, ctx->options, 0);\n\t\t\tav_dict_set(&options, \"framerate\", \"25\", 0);\n\t\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Error %d opening input - retrying with 25 fps\\n\", ctx->fname, res));\n\t\t\tctx->fps_forced.num = 25;\n\t\t\tres = avformat_open_input(&ctx->demuxer, dev_name, FF_IFMT_CAST dev_fmt, &options);\n\n\t\t\tif ((res<0) && options) {\n\t\t\t\tav_dict_free(&options);\n\t\t\t\toptions = NULL;\n\t\t\t\tctx->fps_forced.num = 0;\n\t\t\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Error %d opening input - retrying without options\\n\", ctx->fname, res));\n\t\t\t\tres = avformat_open_input(&ctx->demuxer, dev_name, FF_IFMT_CAST dev_fmt, NULL);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tAVDictionaryEntry *key = NULL;\n\t\twhile (1) {\n\t\t\tkey = av_dict_get(ctx->options, \"\", key, AV_DICT_IGNORE_SUFFIX);\n\t\t\tif (!key) break;\n\t\t\tif (!strcmp(key->key, \"framerate\")) {\n\t\t\t\tchar *fps = key->value;\n\t\t\t\tif (strchr(fps, '.')) {\n\t\t\t\t\tctx->fps_forced.num = (u32) (atoi(fps)*1000);\n\t\t\t\t\tctx->fps_forced.den = 1000;\n\t\t\t\t} else {\n\t\t\t\t\tctx->fps_forced.num = atoi(fps);\n\t\t\t\t\tctx->fps_forced.den = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res < 0) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Cannot open device %s:%s\\n\", ctx->fname, dev_fmt->priv_class->class_name, ctx->dev));\n\t\tif (options) av_dict_free(&options);\n\t\treturn -1;\n\t}\n\n\tav_dump_format(ctx->demuxer, 0, ctx->dev, 0);\n\tctx->raw_data = GF_TRUE;\n\tctx->audio_idx = ctx->video_idx = -1;\n\tu32 grab_type = 1;\n#if defined(GPAC_CONFIG_IOS) || defined(GPAC_CONFIG_ANDROID)\n\tif (!strcmp(ctx->dev, \"1\") || strstr(ctx->dev, \"Front\") || strstr(ctx->dev, \"front\") )\n\t\tgrab_type = 2;\n#endif\n\n\tres = avformat_find_stream_info(ctx->demuxer, ctx->options ? &ctx->options : NULL);\n\n\tffmpeg_report_options(filter, options, ctx->options);\n\n\tif (res <0) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] cannot locate streams - error %s\\n\", ctx->fname,  av_err2str(res)));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\t//check we have the stream we want\n\thas_a = has_v = GF_FALSE;\n\tfor (i = 0; (u32) i < ctx->demuxer->nb_streams; i++) {\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\t\tu32 codec_type = ctx->demuxer->streams[i]->codec->codec_type;\n#else\n\t\tu32 codec_type = ctx->demuxer->streams[i]->codecpar->codec_type;\n#endif\n\n\t\tswitch (codec_type) {\n\t\tcase AVMEDIA_TYPE_AUDIO:\n\t\t\thas_a = GF_TRUE;\n\t\t\tbreak;\n\t\tcase AVMEDIA_TYPE_VIDEO:\n\t\t\thas_v = GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (wants_audio && !has_a) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] No audio stream in input device\\n\", ctx->fname));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (wants_video && !has_v) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] No video stream in input device\\n\", ctx->fname));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tctx->probe_frames = ctx->probes;\n\tif (has_v && ctx->probes) {\n\t\tctx->probe_times = gf_malloc(sizeof(u64) * ctx->probes);\n\t\tmemset(ctx->probe_times, 0, sizeof(u64) * ctx->probes);\n\t\t//we probe timestamps in either modes because timestamps of first frames are sometimes off\n\t\tctx->probe_frames = 0;\n\t}\n\n\tGF_LOG(GF_LOG_INFO, ctx->log_class, (\"[%s] device %s:%s opened - %d streams\\n\", ctx->fname, dev_fmt->priv_class->class_name, ctx->dev, ctx->demuxer->nb_streams));\n\n\tctx->copy_audio = ctx->copy_video = GF_FALSE;\n\tswitch (ctx->copy) {\n\tcase COPY_NO:\n\t\tbreak;\n\tcase COPY_A:\n\t\tctx->copy_audio = GF_TRUE;\n\t\tbreak;\n\tcase COPY_V:\n\t\tctx->copy_video = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\tctx->copy_audio = ctx->copy_video = GF_TRUE;\n\t\tbreak;\n\t}\n\tif (wants_audio && wants_video) {\n\t\tif (!ctx->copy_audio || !ctx->copy_video) {\n\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] using muxed capture av:// without copy on %s, this might introduce packet losses due to blocking modes or delayed consumption of the frames. If experiencing problems, either set [-copy]() to `AV` or consider using two filters video:// and audio://\\n\", ctx->fname, (!ctx->copy_audio && !ctx->copy_video) ? \"audio and video streams\" : ctx->copy_video ? \"audio stream\" : \"video stream\"));\n\t\t}\n\t}\n\treturn ffdmx_init_common(filter, ctx, grab_type);\n}\n\nstatic GF_FilterProbeScore ffavin_probe_url(const char *url, const char *mime)\n{\n\tif (!strncmp(url, \"video://\", 8)) return GF_FPROBE_MAYBE_SUPPORTED;\n\tif (!strncmp(url, \"audio://\", 8)) return GF_FPROBE_MAYBE_SUPPORTED;\n\tif (!strncmp(url, \"av://\", 5)) return GF_FPROBE_MAYBE_SUPPORTED;\n\treturn GF_FPROBE_NOT_SUPPORTED;\n}\n\nstatic const GF_FilterCapability FFAVInCaps[] =\n{\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL)\n\t//do not expose a specific codec ID (eg raw) as some grabbers might give us mjpeg\n};\n\nGF_FilterRegister FFAVInRegister = {\n\t.name = \"ffavin\",\n\t.version = LIBAVDEVICE_IDENT,\n\tGF_FS_SET_DESCRIPTION(\"FFMPEG AV Capture\")\n\tGF_FS_SET_HELP(\"Reads from audio/video capture devices using FFMPEG.\\n\"\n\t\"See FFMPEG documentation (https://ffmpeg.org/documentation.html) for more details.\\n\"\n\t\"To list all supported grabbers for your GPAC build, use `gpac -h ffavin:*`.\\n\"\n\t\"\\n\"\n\t\"# Device identification\\n\"\n\t\"Typical classes are `dshow` on windows, `avfoundation` on OSX, `video4linux2` or `x11grab` on linux\\n\"\n\t\"\\n\"\n\t\"Typical device name can be the webcam name:\\n\"\n\t\"- `FaceTime HD Camera` on OSX, device name on windows, `/dev/video0` on linux\\n\"\n\t\"- `screen-capture-recorder`, see http://screencapturer.sf.net/ on windows\\n\"\n\t\"- `Capture screen 0` on OSX (0=first screen), or `screenN` for short\\n\"\n\t\"- X display name (e.g. `:0.0`) on linux\\n\"\n\t\"\\n\"\n\t\"The general mapping from ffmpeg command line is:\\n\"\n\t\"- ffmpeg `-f` maps to [-fmt]() option\\n\"\n\t\"- ffmpeg `-i` maps to [-dev]() option\\n\"\n\t\"\\n\"\n\t\"EX ffmpeg -f libndi_newtek -i MY_NDI_TEST ...\\n\"\n\t\"EX gpac -i av://:fmt=libndi_newtek:dev=MY_NDI_TEST ...\\n\"\n\t\"\\n\"\n\t\"You may need to escape the [-dev]() option if the format uses ':' as separator, as is the case for AVFoundation:\\n\"\n\t\"EX gpac -i av://::dev=0:1 ...\\n\"\n\t)\n\t.private_size = sizeof(GF_FFDemuxCtx),\n\tSETCAPS(FFAVInCaps),\n\t.initialize = ffavin_initialize,\n\t.finalize = ffdmx_finalize,\n\t.process = ffdmx_process,\n\t.update_arg = ffdmx_update_arg,\n\t.probe_url = ffavin_probe_url,\n\t.process_event = ffdmx_process_event,\n\t.flags = GF_FS_REG_META,\n};\n\n\nstatic const GF_FilterArgs FFAVInArgs[] =\n{\n\t{ OFFS(src), \"url of device, `video://`, `audio://` or `av://`\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(fmt), \"name of device class. If not set, defaults to first device class\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(dev), \"name of device or index of device\", GF_PROP_STRING, \"0\", NULL, 0},\n\t{ OFFS(copy), \"set copy mode of raw frames\\n\"\n\t\t\"- N: frames are only forwarded (shared memory, no copy)\\n\"\n\t\t\"- A: audio frames are copied, video frames are forwarded\\n\"\n\t\t\"- V: video frames are copied, audio frames are forwarded\\n\"\n\t\t\"- AV: all frames are copied\"\n\t\t\"\", GF_PROP_UINT, \"A\", \"N|A|V|AV\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sclock), \"use system clock (us) instead of device timestamp (for buggy devices)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(probes), \"probe a given number of video frames before emitting (this usually helps with bad timing of the first frames)\", GF_PROP_UINT, \"10\", \"0-100\", GF_FS_ARG_HINT_EXPERT},\n\t{ \"*\", -1, \"any possible options defined for AVInputFormat and AVFormatContext (see `gpac -hx ffavin` and `gpac -hx ffavin:*`)\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_META},\n\t{0}\n};\n\n\n//number of arguments defined above\nconst int FFAVIN_STATIC_ARGS = (sizeof (FFAVInArgs) / sizeof (GF_FilterArgs)) - 1;\n\n\n#if (LIBAVCODEC_VERSION_MAJOR >= 58) && (LIBAVCODEC_VERSION_MINOR>=18) && !defined(GPAC_DISABLE_DOC)\n#define FF_PROBE_DEVICES\n#endif\n\n#ifdef FF_PROBE_DEVICES\nchar *dev_desc = NULL;\n\nstatic void ffavin_enum_devices(const char *dev_name, Bool is_audio)\n{\n\tconst AVInputFormat *fmt;\n\tAVFormatContext *ctx;\n\n    if (!dev_name) return;\n    fmt = av_find_input_format(dev_name);\n    if (!fmt) return;\n\n    if (!fmt || !fmt->priv_class || !AV_IS_INPUT_DEVICE(fmt->priv_class->category)) {\n\t\treturn;\n\t}\n    ctx = avformat_alloc_context();\n    if (!ctx) return;\n    ctx->iformat = (AVInputFormat *)fmt;\n    if (ctx->iformat->priv_data_size > 0) {\n        ctx->priv_data = av_mallocz(ctx->iformat->priv_data_size);\n        if (!ctx->priv_data) {\n\t\t\tavformat_free_context(ctx);\n            return;\n        }\n        if (ctx->iformat->priv_class) {\n            *(const AVClass**)ctx->priv_data = ctx->iformat->priv_class;\n            av_opt_set_defaults(ctx->priv_data);\n        }\n    } else {\n        ctx->priv_data = NULL;\n\t}\n\n\tAVDeviceInfoList *dev_list = NULL;\n\n    AVDictionary *tmp = NULL;\n\tav_dict_set(&tmp, \"list_devices\", \"1\", 0);\n    av_opt_set_dict2(ctx, &tmp, AV_OPT_SEARCH_CHILDREN);\n\tif (tmp)\n\t\tav_dict_free(&tmp);\n\n\tint res = avdevice_list_devices(ctx, &dev_list);\n\tif (res<0) {\n\t\t//device doesn't implement avdevice_list_devices, try loading the context using \"list_devices=1\" option\n\t\tif (-res == ENOSYS) {\n\t\t\tAVDictionary *opts = NULL;\n\t\t\tav_dict_set(&opts, \"list_devices\", \"1\", 0);\n\t\t\tres = avformat_open_input(&ctx, \"dummy\", FF_IFMT_CAST fmt, &opts);\n\t\t\tif (opts)\n\t\t\t\tav_dict_free(&opts);\n\t\t}\n\t} else if (!res && dev_list->nb_devices) {\n\t\tif (!dev_desc) {\n\t\t\tgf_dynstrcat(&dev_desc, \"# Detected devices\\n\", NULL);\n\t\t}\n\t\tgf_dynstrcat(&dev_desc, dev_name, NULL);\n\t\tgf_dynstrcat(&dev_desc, is_audio ? \" audio\" : \" video\", NULL);\n\t\tgf_dynstrcat(&dev_desc, \" devices\\n\", NULL);\n\t\tfor (int i=0; i<dev_list->nb_devices; i++) {\n\t\t\tchar szFmt[20];\n\t\t\tsprintf(szFmt, \"[%d] \", i);\n\t\t\tgf_dynstrcat(&dev_desc, dev_list->devices[i]->device_name, szFmt);\n\t\t\tgf_dynstrcat(&dev_desc, dev_list->devices[i]->device_description, \": \");\n\t\t\tgf_dynstrcat(&dev_desc, \"\\n\", NULL);\n\t\t}\n\t}\n\n\tif (dev_list) avdevice_free_list_devices(&dev_list);\n\tavformat_free_context(ctx);\n}\n\nstatic void ffavin_log_none(void *avcl, int level, const char *fmt, va_list vl)\n{\n\tif (level == AV_LOG_INFO) {\n\t\tchar szLogBuf[2049];\n\t\tvsnprintf(szLogBuf, 2048, fmt, vl);\n\t\tszLogBuf[2048]=0;\n\n\t\tif (!dev_desc) {\n\t\t\tgf_dynstrcat(&dev_desc, \"# Detected devices\\n\", NULL);\n\t\t}\n\t\tgf_dynstrcat(&dev_desc, szLogBuf, NULL);\n\t}\n}\n#endif\n\nconst GF_FilterRegister *ffavin_register(GF_FilterSession *session)\n{\n\tGF_FilterRegister *res_reg = ffmpeg_build_register(session, &FFAVInRegister, FFAVInArgs, FFAVIN_STATIC_ARGS, FF_REG_TYPE_DEV_IN);\n\n\tif (gf_opts_get_bool(\"temp\", \"get_proto_schemes\")) {\n\t\tgf_opts_set_key(\"temp_in_proto\", FFAVInRegister.name, \"video,audio,av\");\n\t}\n\tif (!gf_opts_get_bool(\"temp\", \"helponly\") || gf_opts_get_bool(\"temp\", \"gendoc\"))\n\t\treturn res_reg;\n\n\t//do not open devices if help is not for ffavin or a sub-filter\n\tBool found = GF_FALSE;\n\tu32 i, argc = gf_sys_get_argc();\n\tfor (i=1; i<argc; i++) {\n\t\tconst char *a = gf_sys_get_arg(i);\n\t\tif (!strncmp(a, \"ffavin\", 6)) {\n\t\t\tfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn res_reg;\n\n#ifdef FF_PROBE_DEVICES\n\tBool audio_pass=GF_FALSE;\n\tav_log_set_callback(ffavin_log_none);\n\tconst AVInputFormat *fmt = NULL;\n\twhile (1) {\n\t\tif (audio_pass) {\n\t\t\tfmt = av_input_audio_device_next(FF_IFMT_CAST fmt);\n\t\t} else {\n\t\t\tfmt = av_input_video_device_next(FF_IFMT_CAST fmt);\n\t\t}\n\t\tif (!fmt) {\n\t\t\tif (audio_pass) break;\n\t\t\taudio_pass = GF_TRUE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!fmt->priv_class) continue;\n\t\tif (audio_pass && (fmt->priv_class->category!=AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT)) continue;\n\t\telse if (!audio_pass && (fmt->priv_class->category!=AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT)) continue;\n\t\tffavin_enum_devices(fmt->name, audio_pass);\n\t}\n\tav_log_set_callback(av_log_default_callback);\n\n\tif (!dev_desc) dev_desc = gf_strdup(\"No device found !\\n\");\n\tif (dev_desc) {\n\t\tchar *out_doc = NULL;\n\t\tgf_dynstrcat(&out_doc, FFAVInRegister.help, NULL);\n\t\tgf_dynstrcat(&out_doc, dev_desc, \"\\n\");\n\t\tgf_free(dev_desc);\n\t\tres_reg->help = out_doc;\n\t\tffmpeg_register_set_dyn_help(res_reg);\n\t}\n#endif\n\treturn res_reg;\n}\n\n#else // FFMPEG_DISABLE_AVDEVICE\n\nconst GF_FilterRegister *ffavin_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif\n\n\n#else\n\n#include <gpac/filters.h>\n\nconst GF_FilterRegister *ffdmx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\nconst GF_FilterRegister *ffdmxpid_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n\nconst GF_FilterRegister *ffavin_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2017-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ffmpeg demux filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/setup.h>\n\n#ifdef GPAC_HAS_FFMPEG\n\n#include \"ff_common.h\"\n\n//for NTP clock\n#include <gpac/network.h>\n#include <gpac/bitstream.h>\n#if (LIBAVCODEC_VERSION_MAJOR>58)\n#include <libavutil/mastering_display_metadata.h>\n#else\n#define FFMPEG_NO_DOVI\n#endif\n\nenum\n{\n\tCOPY_NO,\n\tCOPY_A,\n\tCOPY_V,\n\tCOPY_AV\n};\n\ntypedef struct\n{\n\tGF_FilterPid *pid;\n\tu64 ts_offset;\n\tBool mkv_webvtt;\n\tu32 vc1_mode;\n\tu64 fake_dts_plus_one, fake_dts_orig;\n\tBool fake_dts_set;\n\tGF_List *pck_queue;\n} PidCtx;\n\ntypedef struct\n{\n\t//options\n\tconst char *src;\n\tu32 block_size;\n\tu32 copy, probes;\n\tBool sclock;\n\tconst char *fmt, *dev;\n\tBool reparse;\n\n\t//internal data\n\tconst char *fname;\n\tu32 log_class;\n\n\tBool raw_data;\n\t//input file\n\tAVFormatContext *demuxer;\n\t//demux options\n\tAVDictionary *options;\n\n\tPidCtx *pids_ctx;\n\n\tBool raw_pck_out;\n\tu32 nb_streams;\n\tu32 nb_playing, nb_stop_pending;\n\tBool stop_seen;\n\tu64 first_sample_clock, last_frame_ts;\n\tu32 probe_frames;\n    u32 nb_pck_sent;\n\tDouble last_play_start_range;\n\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\tAVPacket pkt;\n#else\n\tAVPacket *pkt;\n#endif\n\n\ts32 audio_idx, video_idx;\n\n\tu64 *probe_times;\n\n\tBool copy_audio, copy_video;\n\n\tu8 *avio_ctx_buffer;\n\tAVIOContext *avio_ctx;\n\tFILE *gfio;\n\tGF_Fraction fps_forced;\n\n\t//for ffdmx used as filter on http or file input\n\t//we must buffer enough data so that calls to read_packet() does not abort in the middle of a packet\n\tGF_FilterPid *ipid;\n\tu32 is_open;\n\tu32 strbuf_offset;\n\tu8 *strbuf;\n\tu32 strbuf_size, strbuf_alloc, strbuf_min, in_seek;\n\tBool in_eos, first_block;\n\ts64 seek_offset;\n\tu64 seek_ms;\n} GF_FFDemuxCtx;\n\nstatic void ffdmx_finalize(GF_Filter *filter)\n{\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *) gf_filter_get_udta(filter);\n\tif (ctx->pids_ctx) {\n\t\tu32 i;\n\t\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\t\tif (!ctx->pids_ctx[i].pck_queue) continue;\n\t\t\twhile (gf_list_count(ctx->pids_ctx[i].pck_queue)) {\n\t\t\t\tgf_filter_pck_discard( gf_list_pop_back(ctx->pids_ctx[i].pck_queue) );\n\t\t\t}\n\t\t\tgf_list_del(ctx->pids_ctx[i].pck_queue);\n\t\t}\n\t\tgf_free(ctx->pids_ctx);\n\t}\n\tif (ctx->options)\n\t\tav_dict_free(&ctx->options);\n\tif (ctx->probe_times)\n\t\tgf_free(ctx->probe_times);\n\tif (ctx->demuxer) {\n\t\tavformat_close_input(&ctx->demuxer);\n\t\tavformat_free_context(ctx->demuxer);\n\t}\n\tif (ctx->avio_ctx) {\n\t\tif (ctx->avio_ctx->buffer) av_freep(&ctx->avio_ctx->buffer);\n\t\tav_freep(&ctx->avio_ctx);\n\t}\n\tif (ctx->gfio) gf_fclose(ctx->gfio);\n\tif (ctx->strbuf) gf_free(ctx->strbuf);\n\treturn;\n}\n\nvoid ffdmx_shared_pck_release(GF_Filter *filter, GF_FilterPid *pid, GF_FilterPacket *pck)\n{\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *) gf_filter_get_udta(filter);\n\tif (ctx->raw_pck_out) {\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\t\tav_free_packet(&ctx->pkt);\n#else\n\t\tav_packet_unref(ctx->pkt);\n#endif\n\t\tctx->raw_pck_out = GF_FALSE;\n\t\tgf_filter_post_process_task(filter);\n\t}\n}\n\nstatic GF_Err ffdmx_set_decoder_config(PidCtx *pctx, const u8 *exdata, u32 exdata_size, u32 gpac_codec_id)\n{\n\tu8 *dsi;\n\tu32 dsi_size;\n\tGF_Err e = ffmpeg_extradata_to_gpac(gpac_codec_id, exdata, exdata_size, &dsi, &dsi_size);\n\tif (e) return e;\n\n\tif (gpac_codec_id==GF_CODECID_SMPTE_VC1) {\n\t\tpctx->vc1_mode = 1;\n\t\t//if no_interlace (bit 6 of 2nd byte) is not set, inject interlaced\n\t\tif ((dsi_size>=7) && ((dsi[2] & 0x20) != 0x20))\n\t\t\tpctx->vc1_mode = 2;\n\t}\n\treturn gf_filter_pid_set_property(pctx->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY( dsi, dsi_size) );\n}\n\n#if (LIBAVCODEC_VERSION_MAJOR>58)\nstatic inline u32 rescale_mdcv(AVRational q, int b)\n{\n    return (u32) av_rescale(q.num, b, q.den);\n}\n#endif\n\n//dovi_meta.h not exported in old releases, just redefine\ntypedef struct {\n    u8 dv_version_major;\n    u8 dv_version_minor;\n    u8 dv_profile;\n    u8 dv_level;\n    u8 rpu_present_flag;\n    u8 el_present_flag;\n    u8 bl_present_flag;\n    u8 dv_bl_signal_compatibility_id;\n} Ref_FFAVDoviRecord;\n\nstatic void ffdmx_parse_side_data(const AVPacketSideData *sd, GF_FilterPid *pid)\n{\n\tswitch (sd->type) {\n\tcase AV_PKT_DATA_PALETTE:\n\t\tbreak;\n\tcase AV_PKT_DATA_NEW_EXTRADATA:\n\t\tbreak;\n\tcase AV_PKT_DATA_PARAM_CHANGE:\n\t\tbreak;\n\tcase AV_PKT_DATA_H263_MB_INFO:\n\t\tbreak;\n\tcase AV_PKT_DATA_REPLAYGAIN:\n\t\tbreak;\n\tcase AV_PKT_DATA_STEREO3D:\n\t\tbreak;\n\tcase AV_PKT_DATA_AUDIO_SERVICE_TYPE:\n\t\tbreak;\n\tcase AV_PKT_DATA_QUALITY_STATS:\n\t\tbreak;\n\tcase AV_PKT_DATA_DISPLAYMATRIX:\n\t{\n\t\tGF_PropertyValue p;\n\t\tmemset(&p, 0, sizeof(GF_PropertyValue));\n\t\tp.type = GF_PROP_SINT_LIST;\n\t\tp.value.uint_list.nb_items = 9;\n\t\tp.value.uint_list.vals = (u32 *)sd->data;\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ISOM_TRACK_MATRIX, &p);\n\n\t}\n\t\tbreak;\n\n#if (LIBAVCODEC_VERSION_MAJOR >= 58)\n\tcase AV_PKT_DATA_CPB_PROPERTIES:\n\t\tbreak;\n\tcase AV_PKT_DATA_SPHERICAL:\n\t\tbreak;\n#endif\n\n\n#if (LIBAVCODEC_VERSION_MAJOR>58)\n\tcase AV_PKT_DATA_MASTERING_DISPLAY_METADATA:\n\t{\n\t\tu8 mdcv[24];\n\t\tconst int chroma_den = 50000;\n\t\tconst int luma_den = 10000;\n\t\tmemset(mdcv, 0, sizeof(u8)*24);\n\t\tconst AVMasteringDisplayMetadata *metadata = (const AVMasteringDisplayMetadata *)sd->data;\n\t\tGF_BitStream *bs = gf_bs_new(mdcv, 24, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u16(bs, rescale_mdcv(metadata->display_primaries[1][0], chroma_den));\n\t\tgf_bs_write_u16(bs, rescale_mdcv(metadata->display_primaries[1][1], chroma_den));\n    \tgf_bs_write_u16(bs, rescale_mdcv(metadata->display_primaries[2][0], chroma_den));\n    \tgf_bs_write_u16(bs, rescale_mdcv(metadata->display_primaries[2][1], chroma_den));\n    \tgf_bs_write_u16(bs, rescale_mdcv(metadata->display_primaries[0][0], chroma_den));\n    \tgf_bs_write_u16(bs, rescale_mdcv(metadata->display_primaries[0][1], chroma_den));\n    \tgf_bs_write_u16(bs, rescale_mdcv(metadata->white_point[0], chroma_den));\n    \tgf_bs_write_u16(bs, rescale_mdcv(metadata->white_point[1], chroma_den));\n    \tgf_bs_write_u32(bs, rescale_mdcv(metadata->max_luminance, luma_den));\n    \tgf_bs_write_u32(bs, rescale_mdcv(metadata->min_luminance, luma_den));\n    \tgf_bs_del(bs);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_MASTER_DISPLAY_COLOUR, &PROP_DATA(mdcv, 24));\n\t}\n\t\tbreak;\n\n\tcase AV_PKT_DATA_CONTENT_LIGHT_LEVEL:\n\t{\n\t\tu8 clli[4];\n\t\tmemset(clli, 0, sizeof(u8)*4);\n\t\tconst AVContentLightMetadata *metadata = (const AVContentLightMetadata *)sd->data;\n\t\tGF_BitStream *bs = gf_bs_new(clli, 4, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u16(bs, metadata->MaxCLL);\n\t\tgf_bs_write_u16(bs, metadata->MaxFALL);\n    \tgf_bs_del(bs);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA(clli, 4));\n\t}\n\t\tbreak;\n\tcase AV_PKT_DATA_ICC_PROFILE:\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ICC_PROFILE, &PROP_DATA(sd->data, (u32) sd->size));\n\t\tbreak;\n\tcase AV_PKT_DATA_DOVI_CONF:\n\t{\n\t\tu8 dv_cfg[24];\n\t\tconst Ref_FFAVDoviRecord *dovi = (const Ref_FFAVDoviRecord *)sd->data;\n\t\tmemset(dv_cfg, 0, sizeof(u8)*24);\n\t\tGF_BitStream *bs = gf_bs_new(dv_cfg, 24, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_u8(bs, dovi->dv_version_major);\n\t\tgf_bs_write_u8(bs, dovi->dv_version_minor);\n\t\tgf_bs_write_int(bs, dovi->dv_profile, 7);\n\t\tgf_bs_write_int(bs, dovi->dv_level, 6);\n\t\tgf_bs_write_int(bs, dovi->rpu_present_flag, 1);\n\t\tgf_bs_write_int(bs, dovi->el_present_flag, 1);\n\t\tgf_bs_write_int(bs, dovi->bl_present_flag, 1);\n\t\tgf_bs_write_int(bs, dovi->dv_bl_signal_compatibility_id, 4);\n\t\t//the rest is zero-reserved\n\t\tgf_bs_write_int(bs, 0, 28);\n\t\tgf_bs_write_u32(bs, 0);\n\t\tgf_bs_write_u32(bs, 0);\n\t\tgf_bs_write_u32(bs, 0);\n\t\tgf_bs_write_u32(bs, 0);\n\t\tgf_bs_del(bs);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DOLBY_VISION, &PROP_DATA(dv_cfg, 24));\n\t}\n\t\tbreak;\n\tcase AV_PKT_DATA_S12M_TIMECODE:\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nGF_Err ffdmx_init_common(GF_Filter *filter, GF_FFDemuxCtx *ctx, u32 grab_type);\n\nstatic GF_Err ffdmx_flush_input(GF_Filter *filter, GF_FFDemuxCtx *ctx)\n{\n\tint res;\n\tGF_Err e;\n\tif (ctx->is_open==2)\n\t\treturn GF_NOT_SUPPORTED;\n\n\tif (!ctx->is_open)\n\t\tctx->demuxer->pb = ctx->avio_ctx;\n\n\twhile (1) {\n\t\tif (ctx->strbuf_size - ctx->strbuf_offset >= ctx->strbuf_min) {\n\t\t\tif (ctx->is_open) return GF_OK;\n\t\t\tbreak;\n\t\t}\n\n\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(ctx->ipid);\n\t\tif (!pck) {\n\t\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\t\tctx->in_eos = GF_TRUE;\n\t\t\t\tif (ctx->is_open) return GF_OK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn GF_NOT_READY;\n\t\t}\n\t\tu32 size;\n\t\tconst u8 *data = gf_filter_pck_get_data(pck, &size);\n\t\tif (!size) {\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\tcontinue;\n\t\t}\n\t\tctx->in_eos = GF_FALSE;\n\t\tmemmove(ctx->strbuf, ctx->strbuf+ctx->strbuf_offset, ctx->strbuf_size - ctx->strbuf_offset);\n\t\tctx->strbuf_size -= ctx->strbuf_offset;\n\t\tctx->strbuf_offset = 0;\n\t\tif (ctx->strbuf_size + size > ctx->strbuf_alloc) {\n\t\t\tctx->strbuf_alloc = ctx->strbuf_size + size;\n\t\t\tctx->strbuf = gf_realloc(ctx->strbuf, ctx->strbuf_alloc);\n\t\t\tif (!ctx->strbuf) {\n\t\t\t\tctx->strbuf_alloc = 0;\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t}\n\t\tmemcpy(ctx->strbuf + ctx->strbuf_size, data, size);\n\t\tctx->strbuf_size += size;\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\tctx->demuxer->pb->eof_reached = 0;\n\t}\n\n\tctx->first_block = GF_TRUE;\n\n\t//open context\n\tAVDictionary *options = NULL;\n\tav_dict_copy(&options, ctx->options, 0);\n\n\tctx->demuxer->flags |= AVFMT_FLAG_CUSTOM_IO | AVFMT_FLAG_NONBLOCK | AVFMT_FLAG_NOBUFFER;\n\tres = avformat_open_input(&ctx->demuxer, NULL, NULL, &options);\n\tswitch (res) {\n\tcase 0:\n\t\te = GF_OK;\n\t\tbreak;\n\tcase AVERROR_INVALIDDATA:\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tbreak;\n\tcase AVERROR_DEMUXER_NOT_FOUND:\n\tcase -ENOENT:\n\t\te = GF_URL_ERROR;\n\t\tbreak;\n\tcase AVERROR_EOF:\n\t\te = GF_EOS;\n\t\tbreak;\n\tdefault:\n\t\te = GF_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Fail to open %s - error %s\\n\", ctx->fname, ctx->src, av_err2str(res) ));\n\t\tavformat_close_input(&ctx->demuxer);\n\t\tavformat_free_context(ctx->demuxer);\n\t\tctx->demuxer = NULL;\n\t\tif (options) av_dict_free(&options);\n\t\tctx->is_open = 2;\n\t\tctx->first_block = GF_FALSE;\n\t\treturn e;\n\t}\n\n\tAVDictionary** optionsarr = NULL;\n\tif (ctx->options && ctx->demuxer && ctx->demuxer->nb_streams) {\n\t\toptionsarr = (AVDictionary**)gf_malloc(ctx->demuxer->nb_streams * sizeof(AVDictionary*));\n\t\tfor (unsigned si = 0; si < ctx->demuxer->nb_streams; si++) {\n\t\t\toptionsarr[si] = NULL;\n\t\t\tav_dict_copy(&optionsarr[si], ctx->options, 0);\n\t\t}\n\t}\n\tctx->demuxer->probesize = ctx->strbuf_size;\n\tres = avformat_find_stream_info(ctx->demuxer, optionsarr);\n\tctx->first_block = GF_FALSE;\n\n\tif (optionsarr) {\n\t\tfor (unsigned si = 0; si < ctx->demuxer->nb_streams; si++) {\n\t\t\tav_dict_free(&optionsarr[si]);\n\t\t}\n\t\tgf_free(optionsarr);\n\t\toptionsarr = NULL;\n\t}\n\n\tif (res < 0) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] cannot locate streams - error %s\\n\", ctx->fname, av_err2str(res)));\n\t\te = GF_NOT_SUPPORTED;\n\t\tavformat_close_input(&ctx->demuxer);\n\t\tavformat_free_context(ctx->demuxer);\n\t\tctx->demuxer = NULL;\n\t\tif (options) av_dict_free(&options);\n\t\tctx->is_open = 2;\n\t\treturn e;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, ctx->log_class, (\"[%s] file %s opened - %d streams\\n\", ctx->fname, ctx->src, ctx->demuxer->nb_streams));\n\n\tffmpeg_report_options(filter, options, ctx->options);\n\te = ffdmx_init_common(filter, ctx, 0);\n\tif (e) {\n\t\tctx->is_open = 2;\n\t\treturn e;\n\t}\n\tctx->is_open = 1;\n\treturn GF_OK;\n}\n\nstatic GF_Err ffdmx_process(GF_Filter *filter)\n{\n\tGF_Err e;\n\tu32 i, nb_pck=0;\n\tu64 sample_time;\n\tu8 *data_dst;\n\tBool copy = GF_TRUE;\n\tBool check_webvtt = GF_FALSE;\n\tGF_FilterPacket *pck_dst;\n\tAVPacket *pkt;\n\tPidCtx *pctx;\n\tint res;\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *) gf_filter_get_udta(filter);\n\nrestart:\n\tif (ctx->ipid) {\n\t\te = ffdmx_flush_input(filter, ctx);\n\t\tif (e==GF_NOT_READY) return GF_OK;\n\t\tif (!ctx->is_open) return GF_OK;\n\t\tif (ctx->is_open==2) return GF_PROFILE_NOT_SUPPORTED;\n\t\tif (!ctx->demuxer) return GF_PROFILE_NOT_SUPPORTED;\n\t\tif (!ctx->strbuf_size) return GF_OK;\n\t}\n\n\tif (!ctx->nb_playing) {\n\t\tif (ctx->stop_seen) {\n\t\t\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\t\t\tif (ctx->pids_ctx[i].pid) gf_filter_pid_set_eos(ctx->pids_ctx[i].pid);\n\t\t\t}\n\t\t}\n\t\treturn GF_EOS;\n\t}\n\n\tif (ctx->raw_pck_out)\n\t\treturn GF_EOS;\n\n\tu32 would_block, pids;\n\n\twould_block = pids = 0;\n\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\tif (!ctx->pids_ctx[i].pid) continue;\n\t\tpids++;\n\t\tif (!gf_filter_pid_is_playing(ctx->pids_ctx[i].pid))\n\t\t\twould_block++;\n\t\telse if (gf_filter_pid_would_block(ctx->pids_ctx[i].pid))\n\t\t\twould_block++;\n\t}\n\tif (would_block == pids) {\n\t\tgf_filter_ask_rt_reschedule(filter, 1000);\n\t\treturn GF_OK;\n\t}\n\n\tsample_time = gf_sys_clock_high_res();\n\n\tFF_INIT_PCK(ctx, pkt)\n\tpkt->side_data = NULL;\n\tpkt->side_data_elems = 0;\n\n\tpkt->stream_index = -1;\n\n\t/*EOF*/\n\tres = av_read_frame(ctx->demuxer, pkt);\n\tif (res < 0) {\n\t\tif (!ctx->in_eos && (ctx->strbuf_size>ctx->strbuf_offset) && (res == AVERROR(EAGAIN)))\n\t\t\treturn GF_OK;\n\n\t\tFF_FREE_PCK(pkt);\n\t\tif (!ctx->raw_data) {\n\t\t\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\t\t\tif (ctx->pids_ctx[i].pid) gf_filter_pid_set_eos(ctx->pids_ctx[i].pid);\n\t\t\t}\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tassert(pkt->stream_index>=0);\n\tassert(pkt->stream_index < (s32) ctx->demuxer->nb_streams);\n\n\tif (pkt->stream_index >= (s32) ctx->nb_streams) {\n\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] More streams (%d) than initialy declared (%d), buggy source demux or not supported, ignoring packet in stream %d\\n\", ctx->fname, ctx->demuxer->nb_streams, ctx->nb_streams, pkt->stream_index+1 ));\n\t\tFF_FREE_PCK(pkt);\n\t\treturn GF_OK;\n\t}\n\n\tif (pkt->pts == AV_NOPTS_VALUE) {\n\t\tif (pkt->dts == AV_NOPTS_VALUE) {\n\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] No PTS for packet on stream %d\\n\", ctx->fname, pkt->stream_index ));\n\t\t} else {\n\t\t\tpkt->pts = pkt->dts;\n\t\t}\n\t}\n\tif (ctx->seek_ms) {\n\t\tif (pkt->pts * 1000 < (s64)ctx->seek_ms * ctx->demuxer->streams[pkt->stream_index]->time_base.den) {\n\t\t\tif (!ctx->raw_pck_out) {\n\t\t\t\tFF_FREE_PCK(pkt);\n\t\t\t}\n\t\t\tgoto restart;\n\t\t}\n\t\tctx->seek_ms = 0;\n\t}\n\n\tpctx = &ctx->pids_ctx[pkt->stream_index];\n\tif (! pctx->pid ) {\n\t\tGF_LOG(GF_LOG_DEBUG, ctx->log_class, (\"[%s] No PID defined for given stream %d\\n\", ctx->fname, pkt->stream_index ));\n\t\tFF_FREE_PCK(pkt);\n\t\treturn GF_OK;\n\t}\n    if (ctx->stop_seen && ! gf_filter_pid_is_playing( pctx->pid ) ) {\n\t\tFF_FREE_PCK(pkt);\n        return GF_OK;\n    }\n\tif (ctx->raw_data && (ctx->probe_frames<ctx->probes) ) {\n\t\tif (pkt->stream_index==ctx->audio_idx) {\n\t\t\tFF_FREE_PCK(pkt);\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tctx->probe_times[ctx->probe_frames] = ctx->sclock ? sample_time : pkt->pts;\n\t\tctx->probe_frames++;\n\t\tif (ctx->probe_frames==ctx->probes) {\n\t\t\tu32 best_diff=0, max_stat=0;\n\t\t\tfor (i=0; i<ctx->probes; i++) {\n\t\t\t\tif (i) {\n\t\t\t\t\tu32 j, nb_stats=0;\n\t\t\t\t\tu32 diff = (u32) (ctx->probe_times[i]-ctx->probe_times[i-1]);\n\t\t\t\t\tfor (j=1; j<ctx->probes; j++) {\n\t\t\t\t\t\ts32 sdiff = (s32) (ctx->probe_times[j]-ctx->probe_times[j-1]);\n\t\t\t\t\t\tsdiff -= (s32) diff;\n\t\t\t\t\t\tif (sdiff<0) sdiff = -sdiff;\n\t\t\t\t\t\tif (sdiff<2000) nb_stats++;\n\t\t\t\t\t}\n\t\t\t\t\tif (max_stat<nb_stats) {\n\t\t\t\t\t\tmax_stat = nb_stats;\n\t\t\t\t\t\tbest_diff = diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_INFO, ctx->log_class, (\"[%s] Video probing done, frame diff is %d us (for %d frames out of %d)\\n\", ctx->fname, best_diff, max_stat, ctx->probes));\n\t\t} else {\n\t\t\tFF_FREE_PCK(pkt);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (pkt->side_data_elems) {\n\t\tfor (i=0; i < (u32) pkt->side_data_elems; i++) {\n\t\t\tAVPacketSideData *sd = &pkt->side_data[i];\n\t\t\tif (sd->type == AV_PKT_DATA_NEW_EXTRADATA) {\n\t\t\t\tif (sd->data) {\n\t\t\t\t\tu32 cid = 0;\n\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(pctx->pid, GF_PROP_PID_CODECID);\n\t\t\t\t\tif (p) cid = p->value.uint;\n\t\t\t\t\tffdmx_set_decoder_config(pctx, sd->data, (u32) sd->size, cid);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sd->type == AV_PKT_DATA_PARAM_CHANGE) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(sd->data, sd->size, GF_BITSTREAM_READ);\n\n\t\t\t\tu32 flags = gf_bs_read_u32_le(bs);\n\t\t\t\tif (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT) {\n\t\t\t\t\tu32 new_ch = gf_bs_read_u32_le(bs);\n\t\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT(new_ch) );\n\t\t\t\t}\n\t\t\t\tif (flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT) {\n\t\t\t\t\tu64 new_lay = gf_bs_read_u64_le(bs);\n\t\t\t\t\tnew_lay = ffmpeg_channel_layout_to_gpac(new_lay);\n\t\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_CHANNEL_LAYOUT, &PROP_LONGUINT(new_lay) );\n\t\t\t\t}\n\t\t\t\tif (flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE) {\n\t\t\t\t\tu32 new_sr = gf_bs_read_u32_le(bs);\n\t\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT(new_sr) );\n\t\t\t\t}\n\t\t\t\tif (flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS) {\n\t\t\t\t\tu32 new_w = gf_bs_read_u32_le(bs);\n\t\t\t\t\tu32 new_h = gf_bs_read_u32_le(bs);\n\t\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_WIDTH, &PROP_UINT(new_w) );\n\t\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_HEIGHT, &PROP_UINT(new_h) );\n\t\t\t\t}\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t\telse if ((sd->type == AV_PKT_DATA_WEBVTT_IDENTIFIER) || (sd->type == AV_PKT_DATA_WEBVTT_SETTINGS)\n\t\t\t\t|| (sd->type == AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL)\n\t\t\t) {\n\t\t\t\tcheck_webvtt = pctx->mkv_webvtt;\n\t\t\t}\n\t\t\t//todo, map the rest ?\n\t\t\telse {\n\t\t\t\tffdmx_parse_side_data(sd, pctx->pid);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx->raw_data) {\n\t\tif (pkt->stream_index==ctx->audio_idx) copy = ctx->copy_audio;\n\t\telse copy = ctx->copy_video;\n\t}\n\n\t/*patch vc1 to always include start codes*/\n\tif (pctx->vc1_mode && (pkt->data[0]!=0) && (pkt->data[1]!=0) && (pkt->data[2]!=1)) {\n\t\tpck_dst = gf_filter_pck_new_alloc(pctx->pid, pkt->size+4, &data_dst);\n\t\tif (!pck_dst) return GF_OUT_OF_MEM;\n\t\tdata_dst[0]=0;\n\t\tdata_dst[1]=0;\n\t\tdata_dst[2]=1;\n\t\tif ((pctx->vc1_mode==2) && ((pkt->data[0] & 0xC0) == 0xC0)) {\n\t\t\tdata_dst[3] = 0x0C;\n\t\t} else {\n\t\t\tdata_dst[3] = 0x0D;\n\t\t}\n\t\tmemcpy(data_dst+4, pkt->data, pkt->size);\n\t} else if (ctx->raw_data && !copy) {\n\t\t//we don't use shared memory on demuxers since they are usually the ones performing all the buffering\n\t\tpck_dst = gf_filter_pck_new_shared(pctx->pid, pkt->data, pkt->size, ffdmx_shared_pck_release);\n\t\tif (!pck_dst) return GF_OUT_OF_MEM;\n\t\tctx->raw_pck_out = GF_TRUE;\n\t} else {\n\t\t//we don't use shared memory on demuxers since they are usually the ones performing all the buffering\n\t\tpck_dst = gf_filter_pck_new_alloc(pctx->pid, pkt->size, &data_dst);\n\t\tif (!pck_dst) return GF_OUT_OF_MEM;\n\t\tmemcpy(data_dst, pkt->data, pkt->size);\n\t}\n\n\tBool queue_pck=GF_FALSE;\n\tif (ctx->raw_data && ctx->sclock) {\n\t\tu64 ts;\n\t\tif (!ctx->first_sample_clock) {\n\t\t\tctx->last_frame_ts = ctx->first_sample_clock = sample_time;\n\t\t}\n\t\tts = sample_time - ctx->first_sample_clock;\n\t\tgf_filter_pck_set_cts(pck_dst, ts );\n\t\tctx->last_frame_ts = ts;\n\t} else if (pkt->pts != AV_NOPTS_VALUE) {\n\t\tAVStream *stream = ctx->demuxer->streams[pkt->stream_index];\n\t\tu64 ts;\n\n\t\t//initial delay setup - we only dispatch dts or cts >=0\n\t\tif (!pctx->ts_offset) {\n\t\t\t//if first dts is <0, offset timeline and set offset\n\t\t\tif ((pkt->dts != AV_NOPTS_VALUE) && (pkt->dts<0) && !pctx->ts_offset) {\n\t\t\t\tpctx->ts_offset = -pkt->dts + 1;\n\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_DELAY, &PROP_LONGSINT( pkt->dts) );\n\t\t\t}\n\t\t\t//otherwise reset any potential delay set previously\n\t\t\telse {\n\t\t\t\tpctx->ts_offset = 1;\n\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_DELAY, NULL);\n\t\t\t}\n\t\t}\n\n\t\tts = (pkt->pts + pctx->ts_offset-1) * stream->time_base.num;\n\t\tgf_filter_pck_set_cts(pck_dst, ts );\n\n\t\t//trick for some demuxers in libavformat no setting dts when negative (mkv for ex)\n\t\tif (!pctx->fake_dts_plus_one) {\n\t\t\tpctx->fake_dts_plus_one = 1+ts;\n\t\t\tpctx->fake_dts_orig = ts;\n\t\t}\n\n\t\tif (pkt->dts != AV_NOPTS_VALUE) {\n\t\t\tts = (pctx->fake_dts_plus_one-1 - pctx->fake_dts_orig + pkt->dts + pctx->ts_offset-1) * stream->time_base.num;\n\t\t\tgf_filter_pck_set_dts(pck_dst, ts);\n\t\t\tif (!pctx->fake_dts_set) {\n\t\t\t\tif (pctx->fake_dts_plus_one) {\n\t\t\t\t\ts64 offset = pctx->fake_dts_plus_one-1;\n\t\t\t\t\toffset -= pctx->fake_dts_orig;\n\t\t\t\t\tif (offset)\n\t\t\t\t\t\tgf_filter_pid_set_property(pctx->pid, GF_PROP_PID_DELAY, &PROP_LONGSINT( -offset) );\n\t\t\t\t}\n\t\t\t\tpctx->fake_dts_set = GF_TRUE;\n\t\t\t\tif (pctx->pck_queue) {\n\t\t\t\t\twhile (gf_list_count(pctx->pck_queue)) {\n\t\t\t\t\t\tGF_FilterPacket *pck_q = gf_list_pop_front(pctx->pck_queue);\n\t\t\t\t\t\tgf_filter_pck_send(pck_q);\n\t\t\t\t\t}\n\t\t\t\t\tgf_list_del(pctx->pck_queue);\n\t\t\t\t\tpctx->pck_queue = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tts = pctx->fake_dts_plus_one-1;\n\t\t\tgf_filter_pck_set_dts(pck_dst, ts);\n\t\t\tpctx->fake_dts_plus_one += pkt->duration ? pkt->duration : 1;\n\t\t\tif (!ctx->raw_data && !pctx->fake_dts_set) queue_pck = GF_TRUE;\n\t\t}\n\n\t\tif (pkt->duration)\n\t\t\tgf_filter_pck_set_duration(pck_dst, (u32) pkt->duration);\n\t}\n\n\t//fixme: try to identify SAP type 2 and more\n\tif (pkt->flags & AV_PKT_FLAG_KEY)\n\t\tgf_filter_pck_set_sap(pck_dst, GF_FILTER_SAP_1);\n\n\tif (pkt->flags & AV_PKT_FLAG_CORRUPT)\n\t\tgf_filter_pck_set_corrupted(pck_dst, GF_TRUE);\n\n\tif (ctx->raw_data) {\n\t\tu64 ntp = gf_net_get_ntp_ts();\n\t\tgf_filter_pck_set_property(pck_dst, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ntp) );\n\t}\n\tif (check_webvtt) {\n\t\tfor (i=0; i < (u32) pkt->side_data_elems; i++) {\n\t\t\tAVPacketSideData *sd = &pkt->side_data[i];\n\t\t\tif (!sd->data) continue;\n\t\t\tif ((sd->type == AV_PKT_DATA_WEBVTT_IDENTIFIER) || (sd->type == AV_PKT_DATA_WEBVTT_SETTINGS)) {\n\t\t\t\tu8 *d = gf_malloc(sd->size+1);\n\t\t\t\tif (d) {\n\t\t\t\t\tmemcpy(d, sd->data, sd->size);\n\t\t\t\t\td[sd->size]=0;\n\t\t\t\t\tif (sd->type == AV_PKT_DATA_WEBVTT_SETTINGS)\n\t\t\t\t\t\tgf_filter_pck_set_property_str(pck_dst, \"vtt_settings\", &PROP_STRING_NO_COPY(d) );\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_filter_pck_set_property_str(pck_dst, \"vtt_cueid\", &PROP_STRING_NO_COPY(d) );\n\t\t\t\t}\n\t\t\t} else if ((sd->type == AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL) && (sd->size>8)) {\n\t\t\t\tu8 *d = gf_malloc(sd->size-7);\n\t\t\t\tif (d) {\n\t\t\t\t\tmemcpy(d, sd->data+8, sd->size-8);\n\t\t\t\t\td[sd->size-8]=0;\n\t\t\t\t\tgf_filter_pck_set_property_str(pck_dst, \"vtt_pre\", &PROP_STRING_NO_COPY(d) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (queue_pck) {\n\t\tif (!pctx->pck_queue) pctx->pck_queue = gf_list_new();\n\t\te = gf_list_add(pctx->pck_queue, pck_dst);\n\t} else {\n\t\te = gf_filter_pck_send(pck_dst);\n\t}\n\tctx->nb_pck_sent++;\n\tctx->nb_stop_pending=0;\n\tif (!ctx->raw_pck_out) {\n\t\tFF_FREE_PCK(pkt);\n\t}\n\n\tnb_pck++;\n\tif (e || (nb_pck>10)) return e;\n\n\t//we demux an input, restart to flush it\n\tif (ctx->ipid) {\n\t\tif (ctx->strbuf_size && (ctx->strbuf_offset*2 > ctx->strbuf_size)) {\n\t\t\tgf_filter_post_process_task(filter);\n\t\t}\n\t\tgoto restart;\n\t}\n\n\t//we don't demux an input, only rely on session to schedule the filter\n\treturn GF_OK;\n}\n\n\nstatic GF_Err ffdmx_update_arg(GF_Filter *filter, const char *arg_name, const GF_PropertyValue *arg_val)\n{\n\tGF_FFDemuxCtx *ctx = gf_filter_get_udta(filter);\n\treturn ffmpeg_update_arg(ctx->fname, ctx->demuxer, &ctx->options, arg_name, arg_val);\n}\n\n#include <gpac/mpeg4_odf.h>\n#include <gpac/avparse.h>\n/* probe DSI syntax - if valid according to our own representation, we're good to go otherwise we'll need a reframer\n\nThis is needed because libavformat does not always expose the same dsi syntax depending on mux types (!)\n*/\nstatic u32 ffdmx_valid_should_reframe(u32 gpac_codec_id, u8 *dsi, u32 dsi_size)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tGF_AC3Config ac3;\n\tGF_M4ADecSpecInfo aaccfg;\n\tGF_AVCConfig *avcc;\n\tGF_HEVCConfig *hvcc;\n\tGF_VVCConfig *vvcc;\n\tGF_AV1Config *av1c;\n\tGF_VPConfig *vpxc;\n\n\tif (!dsi_size) dsi = NULL;\n\n\tswitch (gpac_codec_id) {\n\t//force reframer for the following formats if no DSI is found\n\tcase GF_CODECID_AC3:\n\tcase GF_CODECID_EAC3:\n\t\tif (dsi && (gf_odf_ac3_config_parse(dsi, dsi_size, (gpac_codec_id==GF_CODECID_EAC3) ? GF_TRUE : GF_FALSE, &ac3) == GF_OK))\n\t\t\treturn 0;\n\t\treturn 1;\n\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\tif (dsi && (gf_m4a_get_config(dsi, dsi_size, &aaccfg) == GF_OK))\n\t\t\treturn 0;\n\t\treturn 1;\n\n\tcase GF_CODECID_FLAC:\n\t\tif (!dsi) return 1;\n\t\tbreak;\n\tcase GF_CODECID_AVC:\n\t\tavcc = dsi ? gf_odf_avc_cfg_read(dsi, dsi_size) : NULL;\n\t\tif (avcc) {\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase GF_CODECID_HEVC:\n\t\thvcc = dsi ? gf_odf_hevc_cfg_read(dsi, dsi_size, GF_FALSE) : NULL;\n\t\tif (hvcc) {\n\t\t\tgf_odf_hevc_cfg_del(hvcc);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase GF_CODECID_VVC:\n\t\tvvcc = dsi ? gf_odf_vvc_cfg_read(dsi, dsi_size) : NULL;\n\t\tif (vvcc) {\n\t\t\tgf_odf_vvc_cfg_del(vvcc);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase GF_CODECID_AV1:\n\t\tav1c = dsi ? gf_odf_av1_cfg_read(dsi, dsi_size) : NULL;\n\t\tif (av1c) {\n\t\t\tgf_odf_av1_cfg_del(av1c);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\tcase GF_CODECID_VP8:\n\tcase GF_CODECID_VP9:\n\t\tvpxc = dsi ? gf_odf_vp_cfg_read(dsi, dsi_size) : NULL;\n\t\tif (vpxc) {\n\t\t\tgf_odf_vp_cfg_del(vpxc);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t//force reframer for the following formats regardless of DSI and drop it\n\tcase GF_CODECID_MPEG1:\n\tcase GF_CODECID_MPEG2_422:\n\tcase GF_CODECID_MPEG2_SNR:\n\tcase GF_CODECID_MPEG2_HIGH:\n\tcase GF_CODECID_MPEG2_MAIN:\n\tcase GF_CODECID_MPEG2_SIMPLE:\n\tcase GF_CODECID_MPEG2_SPATIAL:\n\tcase GF_CODECID_MPEG4_PART2:\n\t\treturn 1;\n\n\t//SRT or other subs: sample data is the raw text but timing is at packet level, force a reframer to parse styles and other\n\t//keep dsi if any (for webvtt in mkv)\n\tcase GF_CODECID_SUBS_TEXT:\n\tcase GF_CODECID_WEBVTT:\n\tcase GF_CODECID_SUBS_SSA:\n\t\treturn 2;\n\n\t//all other codecs are reframed\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n#else\n\treturn 0;\n#endif\n}\n\nGF_Err ffdmx_init_common(GF_Filter *filter, GF_FFDemuxCtx *ctx, u32 grab_type)\n{\n\tu32 i;\n\tu32 nb_a, nb_v, nb_t, clock_id;\n\tchar szName[50];\n\n\n\tif (gf_filter_is_temporary(filter)) {\n\t\tgf_filter_meta_set_instances(filter, ctx->demuxer->av_class->class_name);\n\t\treturn GF_OK;\n\t}\n\n#if (LIBAVCODEC_VERSION_MAJOR >= 59)\n\tctx->pkt = av_packet_alloc();\n#endif\n\n\tctx->pids_ctx = gf_malloc(sizeof(PidCtx)*ctx->demuxer->nb_streams);\n\tmemset(ctx->pids_ctx, 0, sizeof(PidCtx)*ctx->demuxer->nb_streams);\n\tctx->nb_streams = ctx->demuxer->nb_streams;\n\n\tclock_id = 0;\n\tfor (i = 0; i < ctx->demuxer->nb_streams; i++) {\n\t\tAVStream *stream = ctx->demuxer->streams[i];\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\t\tAVCodecContext *codec = stream->codec;\n\t\tu32 codec_type = codec->codec_type;\n#else\n\t\tu32 codec_type = stream->codecpar->codec_type;\n#endif\n\t\tswitch(codec_type) {\n\t\tcase AVMEDIA_TYPE_AUDIO:\n\t\t\tif (!clock_id) clock_id = stream->id ? stream->id : i+1;\n\t\t\tbreak;\n\t\tcase AVMEDIA_TYPE_VIDEO:\n\t\t\tclock_id = stream->id ? stream->id : i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnb_a = nb_v = nb_t = 0;\n\tfor (i = 0; i < ctx->demuxer->nb_streams; i++) {\n\t\tGF_FilterPid *pid=NULL;\n\t\tPidCtx *pctx;\n\t\tu32 j;\n\t\tu32 force_reframer = 0;\n\t\tBool expose_ffdec=GF_FALSE;\n\t\tu32 gpac_codec_id;\n\t\tAVStream *stream = ctx->demuxer->streams[i];\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\t\tAVCodecContext *codec = stream->codec;\n\t\tu32 codec_type = codec->codec_type;\n\t\tu32 codec_id = codec->codec_id;\n\t\tconst uint8_t *exdata = codec->extradata;\n\t\tu32 exdata_size = codec->extradata_size;\n\t\tu32 codec_sample_rate = codec->sample_rate;\n\t\tu32 codec_frame_size = codec->frame_size;\n\t\tu32 codec_channels = codec->channels;\n\t\tu32 codec_width = codec->width;\n\t\tu32 codec_height = codec->height;\n\t\tu32 codec_field_order = codec->field_order;\n\t\tu32 codec_tag = codec->codec_tag;\n\t\tu32 codec_pixfmt = codec->pix_fmt;\n\t\tu32 codec_blockalign = 0;\n\t\tAVRational codec_framerate = {0, 0};\n#if LIBAVCODEC_VERSION_MAJOR >= 58\n\t\tcodec_framerate = codec->framerate;\n#endif\n\t\ts32 codec_sample_fmt = codec->sample_fmt;\n\t\tu32 codec_bitrate = (u32) codec->bit_rate;\n\n#else\n\t\tu32 codec_type = stream->codecpar->codec_type;\n\t\tu32 codec_id = stream->codecpar->codec_id;\n\t\tconst uint8_t *exdata = stream->codecpar->extradata;\n\t\tu32 exdata_size = stream->codecpar->extradata_size;\n\t\tu32 codec_sample_rate = stream->codecpar->sample_rate;\n\t\tu32 codec_frame_size = stream->codecpar->frame_size;\n\t\tu32 codec_channels = stream->codecpar->channels;\n\t\tu32 codec_width = stream->codecpar->width;\n\t\tu32 codec_height = stream->codecpar->height;\n\t\tu32 codec_field_order = stream->codecpar->field_order;\n\t\tu32 codec_tag = stream->codecpar->codec_tag;\n\t\tu32 codec_pixfmt = (codec_type==AVMEDIA_TYPE_VIDEO) ? stream->codecpar->format : 0;\n\t\ts32 codec_sample_fmt = (codec_type==AVMEDIA_TYPE_AUDIO) ? stream->codecpar->format : 0;\n\t\tu32 codec_bitrate = (u32) stream->codecpar->bit_rate;\n\t\tu32 codec_blockalign = (u32) stream->codecpar->block_align;\n\t\tAVRational codec_framerate = stream->r_frame_rate;\n\t\tif (!stream->r_frame_rate.num || !stream->r_frame_rate.den)\n\t\t\tcodec_framerate = stream->avg_frame_rate;\n#endif\n\n\t\t//if fps was detected by ffavin, use it (r_frame_rate is unreliable, just a guess)\n\t\tif (ctx->fps_forced.num) {\n\t\t\tcodec_framerate.num = ctx->fps_forced.num;\n\t\t\tcodec_framerate.den = ctx->fps_forced.den;\n\t\t}\n\t\tswitch(codec_type) {\n\t\tcase AVMEDIA_TYPE_AUDIO:\n\t\t\tpid = gf_filter_pid_new(filter);\n\t\t\tif (!pid) return GF_OUT_OF_MEM;\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO) );\n\t\t\tnb_a++;\n\t\t\tsprintf(szName, \"audio%d\", nb_a);\n\t\t\tif (ctx->audio_idx<0)\n\t\t\t\tctx->audio_idx = i;\n\t\t\tbreak;\n\n\t\tcase AVMEDIA_TYPE_VIDEO:\n\t\t\tpid = gf_filter_pid_new(filter);\n\t\t\tif (!pid) return GF_OUT_OF_MEM;\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL) );\n\t\t\tnb_v++;\n\t\t\tsprintf(szName, \"video%d\", nb_v);\n\t\t\tif (ctx->video_idx<0)\n\t\t\t\tctx->video_idx = i;\n\t\t\tbreak;\n\t\tcase AVMEDIA_TYPE_SUBTITLE:\n\t\t\tpid = gf_filter_pid_new(filter);\n\t\t\tif (!pid) return GF_OUT_OF_MEM;\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\t\t\tnb_t++;\n\t\t\tsprintf(szName, \"text%d\", nb_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(szName, \"ffdmx%d\", i+1);\n\t\t\tbreak;\n\t\t}\n\t\tif (!pid) continue;\n\t\tpctx = &ctx->pids_ctx[i];\n\t\tpctx->pid = pid;\n\t\tpctx->ts_offset = 0;\n\t\tgf_filter_pid_set_udta(pid, stream);\n\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT( (stream->id ? stream->id : i+1)) );\n\t\tgf_filter_pid_set_name(pid, szName);\n\n\t\tif (ctx->raw_data && ctx->sclock) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000000) );\n\t\t} else {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(stream->time_base.den) );\n\t\t}\n\t\tif (clock_id)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(clock_id) );\n\n\t\tif (!ctx->raw_data) {\n\t\t\tif (stream->duration>=0)\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(stream->duration, stream->time_base.den) );\n\t\t\telse if (ctx->demuxer->duration>=0)\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(ctx->demuxer->duration, AV_TIME_BASE) );\n\t\t}\n\n\t\tif (stream->sample_aspect_ratio.num && stream->sample_aspect_ratio.den)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_SAR, &PROP_FRAC_INT( stream->sample_aspect_ratio.num, stream->sample_aspect_ratio.den ) );\n\n\t\tffmpeg_tags_to_gpac(stream->metadata, pid);\n\n\t\tgpac_codec_id = ffmpeg_codecid_to_gpac(codec_id);\n\t\tif (!gpac_codec_id) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_FFMPEG) );\n\t\t\texpose_ffdec = GF_TRUE;\n\t\t} else {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(gpac_codec_id) );\n\t\t}\n\n\t\tif (grab_type)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_RAWGRAB, &PROP_UINT(grab_type) );\n\t\telse if (ctx->demuxer->iformat) {\n\t\t\tif ((ctx->demuxer->iformat->flags & AVFMT_SEEK_TO_PTS) || ctx->demuxer->iformat->read_seek)\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\n\n\t\tu32 lt = gf_log_get_tool_level(GF_LOG_CODING);\n\t\tgf_log_set_tool_level(GF_LOG_CODING, GF_LOG_QUIET);\n\t\tforce_reframer = ffdmx_valid_should_reframe(gpac_codec_id, (u8 *) exdata, exdata_size);\n\t\tgf_log_set_tool_level(GF_LOG_CODING, lt);\n\n\t\tif (expose_ffdec) {\n\t\t\tconst char *cname = avcodec_get_name(codec_id);\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_CODEC_ID, &PROP_POINTER( (void*)codec ) );\n#else\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_CODEC_ID, &PROP_UINT( codec_id ) );\n\t\t\tif (exdata) {\n\t\t\t\t//expose as const data\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DECODER_CONFIG, &PROP_CONST_DATA( (char *)exdata, exdata_size) );\n\t\t\t}\n#endif\n\n\t\t\tif (cname)\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_CODEC_NAME, &PROP_STRING(cname ) );\n\t\t} else if (exdata_size) {\n\n\t\t\t//avc/hevc read by ffmpeg is still in annex B format\n\t\t\tif (ctx->demuxer->iformat) {\n\t\t\t\tif (!strcmp(ctx->demuxer->iformat->name, \"h264\")\n\t\t\t\t\t|| !strcmp(ctx->demuxer->iformat->name, \"hevc\")\n\t\t\t\t\t|| !strcmp(ctx->demuxer->iformat->name, \"vvc\")\n\t\t\t\t) {\n\t\t\t\t\tforce_reframer = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//set extra data if desired\n\t\t\tif (force_reframer!=1) {\n\t\t\t\tffdmx_set_decoder_config(pctx, exdata, exdata_size, gpac_codec_id);\n\t\t\t}\n\t\t}\n\n\t\tif (force_reframer) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_UNFRAMED, &PROP_BOOL(GF_TRUE) );\n\t\t}\n\t\telse if (!gf_sys_is_test_mode() ){\n\t\t\t//force reparse of nalu-base codecs if no dovi support\n\t\t\tswitch (gpac_codec_id) {\n\t\t\tcase GF_CODECID_AVC:\n\t\t\tcase GF_CODECID_HEVC:\n\t\t\tcase GF_CODECID_LHVC:\n\t\t\tcase GF_CODECID_VVC:\n\t\t\tcase GF_CODECID_AV1:\n\t\t\t\tif (ctx->reparse\n#ifdef FFMPEG_NO_DOVI\n\t\t\t\t || 1\n#endif\n\t\t\t\t) {\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_FORCE_UNFRAME, &PROP_BOOL(GF_TRUE) );\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_UNFRAMED, &PROP_BOOL(GF_TRUE) );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif (codec_sample_rate)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT( codec_sample_rate ) );\n\t\tif (codec_frame_size)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_SAMPLES_PER_FRAME, &PROP_UINT( codec_frame_size ) );\n\t\tif (codec_channels)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT( codec_channels ) );\n\n\t\tif (codec_width)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_WIDTH, &PROP_UINT( codec_width ) );\n\t\tif (codec_height)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_HEIGHT, &PROP_UINT( codec_height ) );\n\n\n#if (LIBAVFORMAT_VERSION_MAJOR >= 59)\n\t\tffmpeg_codec_par_to_gpac(stream->codecpar, pid, 0);\n\t\tif (gpac_codec_id!=GF_CODECID_RAW) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PIXFMT, NULL);\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_AUDIO_FORMAT, NULL);\n\t\t}\n#endif\n\n\t\tif (codec_width && codec_height) {\n\t\t\tif (codec_framerate.num && codec_framerate.den) {\n\t\t\t\tgf_media_get_reduced_frame_rate(&codec_framerate.num, &codec_framerate.den);\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_FPS, &PROP_FRAC_INT( codec_framerate.num, codec_framerate.den ) );\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] Unknown frame rate, will use 25 fps - use `:#FPS=VAL` to force frame rate signaling\\n\", ctx->fname));\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_FPS, &PROP_FRAC_INT( 25, 1 ) );\n\t\t\t}\n\t\t}\n\n\t\tif (codec_field_order>AV_FIELD_PROGRESSIVE)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_INTERLACED, &PROP_BOOL(GF_TRUE) );\n\n\t\tif ((codec_type==AVMEDIA_TYPE_VIDEO)\n\t\t\t&& (codec_pixfmt || ((codec_id==AV_CODEC_ID_RAWVIDEO) && codec_tag))\n\t\t) {\n\t\t\tBool is_full_range = GF_FALSE;\n\t\t\tu32 pfmt = 0;\n\n\t\t\tif (codec_pixfmt) {\n\t\t\t\tpfmt = ffmpeg_pixfmt_to_gpac(codec_pixfmt, GF_FALSE);\n\t\t\t\tis_full_range = ffmpeg_pixfmt_is_fullrange(codec_pixfmt);\n\t\t\t} else if (codec_tag) {\n\t\t\t\tpfmt = ffmpeg_pixfmt_from_codec_tag(codec_tag, &is_full_range);\n\t\t\t}\n\n\t\t\tif (!pfmt) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] Unsupported pixel format %d\\n\", ctx->fname, codec_pixfmt));\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PIXFMT, &PROP_UINT( pfmt) );\n\t\t\t\tif (is_full_range)\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_COLR_RANGE, &PROP_BOOL( GF_TRUE ) );\n\t\t\t}\n\t\t}\n\n\t\tif (codec_type==AVMEDIA_TYPE_SUBTITLE) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_SUBTYPE, &PROP_UINT(GF_4CC('s','b','t','l')));\n\t\t}\n\n\t\tctx->pids_ctx[i].mkv_webvtt = GF_FALSE;\n\t\tif ((gpac_codec_id==GF_CODECID_WEBVTT) && strstr(ctx->demuxer->iformat->name, \"matroska\"))\n\t\t\tctx->pids_ctx[i].mkv_webvtt = GF_TRUE;\n\n\t\tif (codec_sample_fmt>0) {\n\t\t\tu32 sfmt = 0;\n\t\t\tswitch (codec_sample_fmt) {\n\t\t\tcase AV_SAMPLE_FMT_U8: sfmt = GF_AUDIO_FMT_U8; break;\n\t\t\tcase AV_SAMPLE_FMT_S16: sfmt = GF_AUDIO_FMT_S16; break;\n\t\t\tcase AV_SAMPLE_FMT_S32: sfmt = GF_AUDIO_FMT_S32; break;\n\t\t\tcase AV_SAMPLE_FMT_FLT: sfmt = GF_AUDIO_FMT_FLT; break;\n\t\t\tcase AV_SAMPLE_FMT_DBL: sfmt = GF_AUDIO_FMT_DBL; break;\n\t\t\tcase AV_SAMPLE_FMT_U8P: sfmt = GF_AUDIO_FMT_U8P; break;\n\t\t\tcase AV_SAMPLE_FMT_S16P: sfmt = GF_AUDIO_FMT_S16P; break;\n\t\t\tcase AV_SAMPLE_FMT_S32P: sfmt = GF_AUDIO_FMT_S32P; break;\n\t\t\tcase AV_SAMPLE_FMT_FLTP: sfmt = GF_AUDIO_FMT_FLTP; break;\n\t\t\tcase AV_SAMPLE_FMT_DBLP: sfmt = GF_AUDIO_FMT_DBLP; break;\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] Unsupported sample format %d\\n\", ctx->fname, codec_sample_fmt));\n\t\t\t}\n\t\t\tif (gpac_codec_id==GF_CODECID_RAW) {\n\t\t\t\tu32 res = ffmpeg_codecid_to_gpac_audio_fmt(codec_id);\n\t\t\t\tif (res) sfmt = res;\n\t\t\t}\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT( sfmt) );\n\t\t}\n\n\t\tif (codec_bitrate)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_BITRATE, &PROP_UINT( (u32) codec_bitrate ) );\n\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_URL, &PROP_STRING( AVFMT_URL(ctx->demuxer) ));\n\n\t\tif (gf_file_exists(ctx->src)) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_FILE_CACHED, &PROP_BOOL(GF_TRUE));\n\t\t}\n\n\t\tif (codec_blockalign)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_META_DEMUX_OPAQUE, &PROP_UINT(codec_blockalign));\n\n\t\tif ((stream->disposition & AV_DISPOSITION_DEFAULT) && !gf_sys_is_test_mode()) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_IS_DEFAULT, &PROP_BOOL(GF_TRUE));\n\t\t}\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_MUX_INDEX, &PROP_UINT(i+1));\n\n\t\tfor (j=0; j<(u32) stream->nb_side_data; j++) {\n\t\t\tffdmx_parse_side_data(&stream->side_data[j], pid);\n\t\t}\n\n\t\tif (ctx->demuxer->nb_chapters) {\n\t\t\tGF_PropertyValue p;\n\t\t\tGF_PropUIntList times;\n\t\t\tGF_PropStringList names;\n\t\t\tu32 nb_c = ctx->demuxer->nb_chapters;\n\n\t\t\ttimes.vals = gf_malloc(sizeof(u32)*nb_c);\n\t\t\tnames.vals = gf_malloc(sizeof(char *)*nb_c);\n\t\t\tmemset(names.vals, 0, sizeof(char *)*nb_c);\n\t\t\ttimes.nb_items = names.nb_items = nb_c;\n\n\t\t\tfor (j=0; j<ctx->demuxer->nb_chapters; j++) {\n\t\t\t\tAVChapter *c = ctx->demuxer->chapters[j];\n\t\t\t\tu64 start = gf_timestamp_rescale(c->start * c->time_base.num, c->time_base.den, 1000);\n\t\t\t\ttimes.vals[j] = (u32) start;\n\t\t\t\tAVDictionaryEntry *ent = NULL;\n\t\t\t\twhile (c->metadata) {\n\t\t\t\t\tent = av_dict_get(c->metadata, \"\", ent, AV_DICT_IGNORE_SUFFIX);\n\t\t\t\t\tif (!ent) break;\n\t\t\t\t\tif (!strcmp(ent->key, \"title\")) {\n\t\t\t\t\t\tnames.vals[j] = gf_strdup(ent->value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!names.vals[j]) names.vals[j] = gf_strdup(\"Unknwon\");\n\t\t\t}\n\t\t\tp.type = GF_PROP_UINT_LIST;\n\t\t\tp.value.uint_list = times;\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CHAP_TIMES, &p);\n\t\t\tgf_free(times.vals);\n\n\t\t\tp.type = GF_PROP_STRING_LIST;\n\t\t\tp.value.string_list = names;\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CHAP_NAMES, &p);\n\t\t\t//no free for string lists\n\t\t}\n\t}\n\n\tif (!nb_a && !nb_v && !nb_t)\n\t\treturn GF_NOT_SUPPORTED;\n\n\treturn GF_OK;\n}\n\nstatic int ffavio_read_packet(void *opaque, uint8_t *buf, int buf_size)\n{\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *)opaque;\n\tint res = (int) gf_fread(buf, buf_size, ctx->gfio);\n\tif (!res && gf_feof(ctx->gfio)) {\n\t\treturn AVERROR_EOF;\n\t}\n\treturn res;\n}\n\nstatic int64_t ffavio_seek(void *opaque, int64_t offset, int whence)\n{\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *)opaque;\n\tif (whence==AVSEEK_SIZE) {\n\t\tu64 pos = gf_ftell(ctx->gfio);\n\t\tu64 size = gf_fsize(ctx->gfio);\n\t\tgf_fseek(ctx->gfio, pos, SEEK_SET);\n\t\treturn size;\n\t}\n\treturn (int64_t) gf_fseek(ctx->gfio, offset, whence);\n}\n\n#include <libavutil/avstring.h>\nstatic GF_Err ffdmx_initialize(GF_Filter *filter)\n{\n\tGF_FFDemuxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_Err e;\n\ts32 res;\n\tu32 i;\n\tchar *ext;\n\tconst char *url;\n\tconst AVInputFormat *av_in = NULL;\n\tctx->fname = \"FFDmx\";\n\tctx->log_class = GF_LOG_CONTAINER;\n\n\tffmpeg_setup_logs(ctx->log_class);\n\n#ifdef GPAC_ENABLE_COVERAGE\n\tif (gf_sys_is_cov_mode()) {\n\t\tffdmx_update_arg(filter, \"foo\", &PROP_STRING_NO_COPY(\"bar\"));\n\t\tffmpeg_pixfmt_from_codec_tag(0, NULL);\n#if (LIBAVCODEC_VERSION_MAJOR > 56)\n\t\tffmpeg_codec_par_to_gpac(NULL, NULL, 0);\n#endif\n\t}\n#endif\n\tif (!ctx->src) {\n//\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Missing file name, cannot open\\n\", ctx->fname));\n\t\treturn GF_OK;\n\t}\n\t/*some extensions not supported by ffmpeg, overload input format*/\n\text = strrchr(ctx->src, '.');\n\tif (ext) {\n\t\tif (!stricmp(ext+1, \"cmp\")) av_in = av_find_input_format(\"m4v\");\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, ctx->log_class, (\"[%s] opening file %s - av_in %08x\\n\", ctx->fname, ctx->src, av_in));\n\n\tctx->demuxer = avformat_alloc_context();\n\tffmpeg_set_mx_dmx_flags(ctx->options, ctx->demuxer);\n\n\turl = ctx->src;\n\tif (!strncmp(ctx->src, \"gfio://\", 7)) {\n\t\tctx->gfio = gf_fopen(ctx->src, \"rb\");\n\t\tif (!ctx->gfio) {\n\t\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Failed to open %s\\n\", ctx->fname, ctx->src));\n\t\t\treturn GF_URL_ERROR;\n\t\t}\n\t\tctx->avio_ctx_buffer = av_malloc(ctx->block_size);\n\t\tif (!ctx->avio_ctx_buffer) {\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tctx->avio_ctx = avio_alloc_context(ctx->avio_ctx_buffer, ctx->block_size,\n\t\t\t\t\t\t\t\t\t  0, ctx, &ffavio_read_packet, NULL, &ffavio_seek);\n\n\t\tif (!ctx->avio_ctx) {\n\t\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Failed to create AVIO context for %s\\n\", ctx->fname, ctx->src));\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tctx->demuxer->pb = ctx->avio_ctx;\n\t\turl = gf_fileio_translate_url(ctx->src);\n\t}\n\n\tAVDictionary *options = NULL;\n\tav_dict_copy(&options, ctx->options, 0);\n\n\tres = avformat_open_input(&ctx->demuxer, url, FF_IFMT_CAST av_in, &options);\n\n\tswitch (res) {\n\tcase 0:\n\t\te = GF_OK;\n\t\tbreak;\n\tcase AVERROR_INVALIDDATA:\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tbreak;\n\tcase AVERROR_DEMUXER_NOT_FOUND:\n\tcase -ENOENT:\n\t\te = GF_URL_ERROR;\n\t\tbreak;\n\tcase AVERROR_EOF:\n\t\te = GF_EOS;\n\t\tbreak;\n\tdefault:\n\t\te = GF_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\n\tif (e && gf_filter_is_temporary(filter)) {\n\t\text = strrchr(ctx->src, '.');\n\t\tconst AVInputFormat *ifmt = av_find_input_format(ctx->src);\n\t\tif (!ifmt && ext) ifmt = av_find_input_format(ext+1);\n#if (LIBAVFORMAT_VERSION_MAJOR>=59)\n\t\tif (!ifmt && ext) {\n\t\t\tconst AVInputFormat *fmt = NULL;\n\t\t\tvoid *i = 0;\n\t\t\twhile ((fmt = av_demuxer_iterate(&i))) {\n\t\t\t\tif (av_match_name(ext+1, fmt->extensions)) {\n\t\t\t\t\tifmt = fmt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\tif (ifmt) {\n\t\t\tgf_filter_meta_set_instances(filter, ifmt->name);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Fail to open %s - error %s\\n\", ctx->fname, ctx->src, av_err2str(res) ));\n\t\tavformat_close_input(&ctx->demuxer);\n\t\tavformat_free_context(ctx->demuxer);\n\t\tctx->demuxer = NULL;\n\t\tif (options) av_dict_free(&options);\n\t\treturn e;\n\t}\n\n\tAVDictionary** optionsarr = NULL;\n\tu32 optionsarr_size = 0;\n\tif (ctx->options && ctx->demuxer) {\n\t\toptionsarr = (AVDictionary**)gf_malloc(ctx->demuxer->nb_streams * sizeof(AVDictionary*));\n\t\toptionsarr_size = ctx->demuxer->nb_streams;\n\t\tfor (i=0; i < optionsarr_size; i++) {\n\t\t\toptionsarr[i] = NULL;\n\t\t\tav_dict_copy(&optionsarr[i], ctx->options, 0);\n\t\t}\n\t}\n\n\tres = avformat_find_stream_info(ctx->demuxer, optionsarr);\n\n\tif (optionsarr) {\n\t\tfor (i=0; i < optionsarr_size; i++) {\n\t\t\tav_dict_free(&optionsarr[i]);\n\t\t}\n\t\tgf_free(optionsarr);\n\t\toptionsarr = NULL;\n\t}\n\n\tif (res <0) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] cannot locate streams - error %s\\n\", ctx->fname, av_err2str(res)));\n\t\te = GF_NOT_SUPPORTED;\n\t\tavformat_close_input(&ctx->demuxer);\n\t\tavformat_free_context(ctx->demuxer);\n\t\tctx->demuxer = NULL;\n\t\tif (options) av_dict_free(&options);\n\t\treturn e;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, ctx->log_class, (\"[%s] file %s opened - %d streams\\n\", ctx->fname, ctx->src, ctx->demuxer->nb_streams));\n\n\tffmpeg_report_options(filter, options, ctx->options);\n\treturn ffdmx_init_common(filter, ctx, 0);\n}\n\nstatic int ffdmx_read_packet(void *opaque, uint8_t *buf, int buf_size)\n{\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *)opaque;\n\tif (ctx->in_seek && (ctx->seek_offset >= 0)) {\n\t\tctx->in_seek = 2;\n\t\treturn -1;\n\t}\n\tif (ctx->strbuf_offset + buf_size > ctx->strbuf_size) {\n\t\tif (!ctx->in_eos) {\n\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] Internal buffer too small, may result in packet drops - try increaset strbuf_min option\\n\", ctx->fname));\n\t\t\tctx->strbuf_min += ctx->strbuf_offset + buf_size - ctx->strbuf_size;\n\t\t}\n\t\tif (buf_size && (ctx->strbuf_size == ctx->strbuf_offset)) {\n\t\t\treturn ctx->in_eos ? AVERROR_EOF : AVERROR(EAGAIN);\n\t\t}\n\t\tbuf_size = ctx->strbuf_size - ctx->strbuf_offset;\n\t}\n\tmemcpy(buf, ctx->strbuf + ctx->strbuf_offset, buf_size);\n\tctx->strbuf_offset += buf_size;\n\t//if 2xbuffer size is larger than our min internal buffer, increase size - this should limit risks of getting called with no packets to deliver\n\tif ((u32)buf_size*2 >= ctx->strbuf_min)\n\t\tctx->strbuf_min = 2*buf_size;\n\treturn buf_size;\n}\n\nstatic int64_t ffdmx_seek(void *opaque, int64_t offset, int whence)\n{\n\tGF_FFDemuxCtx *ctx = (GF_FFDemuxCtx *)opaque;\n\tif (whence==AVSEEK_SIZE) {\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_DOWN_SIZE);\n\t\tif (p) return p->value.longuint;\n\t\tGF_PropertyEntry *pe=NULL;\n\t\tp = gf_filter_pid_get_info(ctx->ipid, GF_PROP_PID_DOWN_SIZE, &pe);\n\t\ts64 val = p ? p->value.longuint : -1;\n\t\tgf_filter_release_property(pe);\n\t\treturn val;\n\t}\n\tif (ctx->in_seek) {\n\t\tif (ctx->in_seek == 1) {\n\t\t\tctx->seek_offset = offset;\n\t\t\treturn offset;\n\t\t}\n\t\treturn -1;\n\t}\n\t//if seeking in first block (while probing for stream info), allow it\n\tif (ctx->first_block && (whence==SEEK_SET) && (offset<ctx->strbuf_size)) {\n\t\tctx->strbuf_offset = (u32) offset;\n\t\treturn offset;\n\t}\n\treturn -1;\n}\n\nstatic GF_Err ffdmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_FFDemuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (ctx->ipid && is_remove) {\n\t\tu32 i;\n\t\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\t\tif (ctx->pids_ctx[i].pid) gf_filter_pid_remove(ctx->pids_ctx[i].pid);\n\t\t\tctx->pids_ctx[i].pid = NULL;\n\t\t}\n\t\tctx->nb_playing = 0;\n\t\treturn GF_EOS;\n\t}\n\tif (ctx->src) return GF_BAD_PARAM;\n\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property(pid, GF_PROP_PID_URL);\n\tif (!p || !p->value.string || !stricmp(p->value.string, \"null\"))\n\t\treturn GF_NOT_SUPPORTED;\n\tctx->src = gf_strdup(p->value.string);\n\tctx->ipid = pid;\n\tif (ctx->avio_ctx_buffer) return GF_OK;\n\tctx->avio_ctx_buffer = av_malloc(ctx->block_size);\n\tif (!ctx->avio_ctx_buffer) return GF_OUT_OF_MEM;\n\n\tctx->strbuf_min = ctx->strbuf_alloc = 1000000;\n\tctx->strbuf = gf_malloc(ctx->strbuf_alloc);\n\tif (!ctx->strbuf) return GF_OUT_OF_MEM;\n\n\tctx->avio_ctx = avio_alloc_context(ctx->avio_ctx_buffer, ctx->block_size, 0, ctx, &ffdmx_read_packet, NULL, &ffdmx_seek);\n//\tctx->avio_ctx = avio_alloc_context(ctx->avio_ctx_buffer, ctx->block_size, 0, ctx, &ffdmx_read_packet, NULL, NULL);\n\tif (!ctx->avio_ctx) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Failed to create AVIO context for %s\\n\", ctx->fname, ctx->src));\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tctx->demuxer = avformat_alloc_context();\n\tffmpeg_set_mx_dmx_flags(ctx->options, ctx->demuxer);\n\treturn GF_OK;\n}\n\n\nstatic Bool ffdmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tGF_FFDemuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (evt->play.initial_broadcast_play==2)\n\t\t\treturn GF_TRUE;\n\n\t\tctx->nb_playing++;\n\t\tif (ctx->nb_playing>1) {\n\t\t\tBool skip_com = GF_TRUE;\n\t\t\t//PLAY/STOP may arrive at different times depending on the length of filter chains on each PID\n\t\t\t//we stack number of STOP received and trigger seek when we have the same amount of play\n\t\t\tif (ctx->nb_stop_pending==ctx->nb_playing) {\n\t\t\t\tskip_com = GF_FALSE;\n\t\t\t\tctx->last_play_start_range = 0;\n\t\t\t}\n\t\t\tif (skip_com) {\n\t\t\t\tif (evt->play.orig_delay) {\n\t\t\t\t\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\t\t\t\t\tif (ctx->pids_ctx[i].pid==evt->base.on_pid) {\n\t\t\t\t\t\t\tctx->pids_ctx[i].ts_offset = evt->play.orig_delay+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\tctx->nb_playing--;\n\t\t}\n\n\t\t//change in play range\n\t\tBool cancel_event = ctx->ipid ? GF_FALSE : GF_TRUE;\n\t\tif (!ctx->raw_data && (ctx->last_play_start_range != evt->play.start_range)) {\n\t\t\tu32 i;\n\t\t\tif (ctx->ipid) {\n\t\t\t\tctx->seek_ms = 0;\n\t\t\t\tctx->in_seek = 1;\n\t\t\t\tctx->seek_offset = -1;\n\t\t\t}\n\n\t\t\tint res = av_seek_frame(ctx->demuxer, -1, (s64) (AV_TIME_BASE*evt->play.start_range), AVSEEK_FLAG_BACKWARD);\n\t\t\tif (res<0) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] Fail to seek %s to %g - error %s\\n\", ctx->fname, ctx->src, evt->play.start_range, av_err2str(res) ));\n\t\t\t\tctx->in_seek = 2;\n\t\t\t\tctx->seek_offset=0;\n\t\t\t}\n\t\t\tif (ctx->ipid && (ctx->seek_offset>=0)) {\n\t\t\t\tGF_FilterEvent fevt;\n\t\t\t\t//failed to seek, start from 0\n\t\t\t\tif (evt->play.start_range && (ctx->in_seek==2)) {\n\t\t\t\t\tctx->seek_offset=0;\n\t\t\t\t\tctx->seek_ms = (u64) (1000*evt->play.start_range);\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] Fail to seek %s to %g, seeking from start\\n\", ctx->fname, ctx->src, evt->play.start_range));\n\t\t\t\t\tif (res<0)\n\t\t\t\t\t\tav_seek_frame(ctx->demuxer, -1, 0, AVSEEK_FLAG_BACKWARD);\n\t\t\t\t}\n\t\t\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\t\t\tfevt.seek.start_offset = ctx->seek_offset;\n\t\t\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\t\t\tctx->strbuf_size = 0;\n\t\t\t\tctx->strbuf_offset = 0;\n\t\t\t\tcancel_event = GF_TRUE;\n\t\t\t}\n\t\t\tctx->in_seek = GF_FALSE;\n\t\t\t//reset initial delay compute\n\t\t\tfor (i=0; i<ctx->nb_streams; i++) {\n\t\t\t\tctx->pids_ctx[i].ts_offset = 0;\n\t\t\t\tif (evt->play.orig_delay && (ctx->pids_ctx[i].pid==evt->base.on_pid)) {\n\t\t\t\t\tctx->pids_ctx[i].ts_offset = evt->play.orig_delay+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->last_play_start_range = evt->play.start_range;\n\t\t}\n\t\tctx->stop_seen = GF_FALSE;\n\t\treturn cancel_event;\n\n\tcase GF_FEVT_STOP:\n\t\tif (evt->play.initial_broadcast_play==2)\n\t\t\treturn GF_TRUE;\n\t\tctx->nb_stop_pending++;\n\t\tif (ctx->nb_playing) {\n\t\t\tctx->nb_playing--;\n\t\t\tctx->stop_seen = GF_TRUE;\n\t\t}\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GF_FilterProbeScore ffdmx_probe_url(const char *url, const char *mime)\n{\n\tif (!strncmp(url, \"video://\", 8)) return GF_FPROBE_NOT_SUPPORTED;\n\tif (!strncmp(url, \"audio://\", 8)) return GF_FPROBE_NOT_SUPPORTED;\n\tif (!strncmp(url, \"av://\", 5)) return GF_FPROBE_NOT_SUPPORTED;\n\tif (!strncmp(url, \"pipe://\", 7)) return GF_FPROBE_NOT_SUPPORTED;\n\n\tconst char *ext = gf_file_ext_start(url);\n\tif (ext) {\n\t\tconst AVInputFormat *f = av_find_input_format(ext+1);\n\t\tif (!f)\n\t\t\treturn GF_FPROBE_MAYBE_NOT_SUPPORTED;\n\t}\n\treturn GF_FPROBE_MAYBE_SUPPORTED;\n}\n\nextern Bool ff_probe_mode;\nstatic const char *ffdmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tint ffscore;\n\tconst AVInputFormat *probe_fmt;\n\tAVProbeData pb;\n\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\tav_register_all();\n#endif\n\n\tmemset(&pb, 0, sizeof(AVProbeData));\n\tff_probe_mode=GF_TRUE;\n\t//not setting this crashes some probers in ffmpeg\n\tpb.filename = \"\";\n\tif (size <= AVPROBE_PADDING_SIZE) {\n\t\tpb.buf = gf_malloc(sizeof(char) * (size+AVPROBE_PADDING_SIZE) );\n\t\tmemcpy(pb.buf, data, sizeof(char)*size);\n\t\tmemset(pb.buf+size, 0, sizeof(char)*AVPROBE_PADDING_SIZE);\n\t\tpb.buf_size = size;\n\t\tprobe_fmt = av_probe_input_format3(&pb, GF_TRUE, &ffscore);\n\t\tif (ffscore<=AVPROBE_SCORE_RETRY/2) probe_fmt=NULL;\n\t\tif (!probe_fmt) probe_fmt = av_probe_input_format3(&pb, GF_FALSE, &ffscore);\n\t\tif (ffscore<=AVPROBE_SCORE_RETRY/2) probe_fmt=NULL;\n\t\tgf_free(pb.buf);\n\t} else {\n\t\tpb.buf =  (char *) data;\n\t\tpb.buf_size = size - AVPROBE_PADDING_SIZE;\n\t\tprobe_fmt = av_probe_input_format3(&pb, GF_TRUE, &ffscore);\n\t\tif (ffscore<=AVPROBE_SCORE_RETRY/2) probe_fmt=NULL;\n\t\tif (!probe_fmt) probe_fmt = av_probe_input_format3(&pb, GF_FALSE, &ffscore);\n\t\tif (ffscore<=AVPROBE_SCORE_RETRY/2) probe_fmt=NULL;\n\t}\n\tff_probe_mode=GF_FALSE;\n\n\tif (!probe_fmt) return NULL;\n\tif (probe_fmt->mime_type) {\n\t\t//TODO try to refine based on ffprobe score\n\t\t*score = GF_FPROBE_MAYBE_SUPPORTED;\n\t\treturn probe_fmt->mime_type;\n\t}\n\t*score = (ffscore==AVPROBE_SCORE_MAX) ? GF_FPROBE_MAYBE_SUPPORTED : GF_FPROBE_MAYBE_NOT_SUPPORTED;\n\treturn \"video/x-ffmpeg\";\n}\n\n#define OFFS(_n)\t#_n, offsetof(GF_FFDemuxCtx, _n)\n\nstatic const GF_FilterCapability FFDmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\t{0},\n\t//for forced frame->unframe\n\tCAP_UINT(GF_CAPS_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_BOOL(GF_CAPS_OUTPUT,GF_PROP_PID_FORCE_UNFRAME, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_OUTPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n\nGF_FilterRegister FFDemuxRegister = {\n\t.name = \"ffdmx\",\n\t.version=LIBAVFORMAT_IDENT,\n\tGF_FS_SET_DESCRIPTION(\"FFMPEG demultiplexer\")\n\tGF_FS_SET_HELP(\"This filter demultiplexes an input file or open a source protocol using FFMPEG.\\n\"\n\t\"See FFMPEG documentation (https://ffmpeg.org/documentation.html) for more details.\\n\"\n\t\"To list all supported demultiplexers for your GPAC build, use `gpac -h ffdmx:*`.\\n\"\n\t\"This will list both supported input formats and protocols.\\n\"\n\t\"Input protocols are listed with `Description: Input protocol`, and the subclass name identifies the protocol scheme.\\n\"\n\t\"For example, if `ffdmx:rtmp` is listed as input protocol, this means `rtmp://` source URLs are supported.\\n\"\n\t)\n\t.private_size = sizeof(GF_FFDemuxCtx),\n\tSETCAPS(FFDmxCaps),\n\t.initialize = ffdmx_initialize,\n\t.finalize = ffdmx_finalize,\n\t.process = ffdmx_process,\n\t.update_arg = ffdmx_update_arg,\n\t.probe_url = ffdmx_probe_url,\n\t.probe_data = ffdmx_probe_data,\n\t.process_event = ffdmx_process_event,\n\t.flags = GF_FS_REG_META | GF_FS_REG_USE_SYNC_READ,\n\t.priority = 128\n\n};\n\n\nstatic const GF_FilterArgs FFDemuxArgs[] =\n{\n\t{ OFFS(src), \"URL of source content\", GF_PROP_NAME, NULL, NULL, 0},\n\t{ OFFS(reparse), \"force reparsing of stream content (AVC,HEVC,VVC,AV1 only for now)\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(block_size), \"block size used to read file when using GFIO context\", GF_PROP_UINT, \"4096\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(strbuf_min), \"internal buffer size when demuxing from GPAC's input stream\", GF_PROP_UINT, \"1MB\", NULL, GF_ARG_HINT_EXPERT},\n\t{ \"*\", -1, \"any possible options defined for AVFormatContext and sub-classes. See `gpac -hx ffdmx` and `gpac -hx ffdmx:*`\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_META},\n\t{0}\n};\n\nconst int FFDMX_STATIC_ARGS = (sizeof (FFDemuxArgs) / sizeof (GF_FilterArgs)) - 1;\n\n\nconst GF_FilterRegister *ffdmx_register(GF_FilterSession *session)\n{\n\treturn ffmpeg_build_register(session, &FFDemuxRegister, FFDemuxArgs, FFDMX_STATIC_ARGS, FF_REG_TYPE_DEMUX);\n}\n\n//we define a dedicated registry for demuxing a GPAC pid using ffmpeg, not doing so can create wrong link resolutions\n//disabling GPAC demuxers\nstatic const GF_FilterCapability FFPidDmxCaps[] =\n{\n\t//for demuxing input pids\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FILEPATH, \"*\"),\n\tCAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_URL, \"NULL\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n\t{0},\n\t//for forced frame->unframe from pid\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FILEPATH, \"*\"),\n\tCAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_URL, \"NULL\"),\n\tCAP_UINT(GF_CAPS_OUTPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_BOOL(GF_CAPS_OUTPUT,GF_PROP_PID_FORCE_UNFRAME, GF_TRUE),\n\tCAP_BOOL(GF_CAPS_OUTPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n\t{0},\n};\nstatic const GF_FilterArgs FFDemuxPidArgs[] =\n{\n\t{ OFFS(reparse), \"force reparsing of stream content (AVC,HEVC,VVC,AV1 only for now)\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(block_size), \"block size used to read file when using GFIO context\", GF_PROP_UINT, \"4096\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(strbuf_min), \"internal buffer size when demuxing from GPAC's input stream\", GF_PROP_UINT, \"1MB\", NULL, GF_ARG_HINT_EXPERT},\n\t{0}\n};\n\nstatic void ffdmxpid_finalize(GF_Filter *filter)\n{\n\tGF_FFDemuxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->src) {\n\t\tgf_free((char *)ctx->src);\n\t\tctx->src = NULL;\n\t}\n\tffdmx_finalize(filter);\n\n}\nconst GF_FilterRegister FFDemuxPidRegister = {\n\t.name = \"ffdmxpid\",\n\t.version=LIBAVFORMAT_IDENT,\n\tGF_FS_SET_DESCRIPTION(\"FFMPEG demultiplexer\")\n\tGF_FS_SET_HELP(\"Alias of ffdmx for GPAC pid demultiplexing, same options as ffdmx.\\n\")\n\t.private_size = sizeof(GF_FFDemuxCtx),\n\tSETCAPS(FFPidDmxCaps),\n\t.initialize = ffdmx_initialize,\n\t.finalize = ffdmxpid_finalize,\n\t.configure_pid = ffdmx_configure_pid,\n\t.process = ffdmx_process,\n\t.update_arg = ffdmx_update_arg,\n\t.process_event = ffdmx_process_event,\n\t.flags = GF_FS_REG_META,\n\t.args = FFDemuxPidArgs,\n\t//also set lower priority\n\t.priority = 128\n};\n\nconst GF_FilterRegister *ffdmxpid_register(GF_FilterSession *session)\n{\n\tif (gf_opts_get_bool(\"temp\", \"gendoc\")) return NULL;\n\treturn &FFDemuxPidRegister;\n}\n\n\n#ifndef FFMPEG_DISABLE_AVDEVICE\n\nstatic GF_Err ffavin_initialize(GF_Filter *filter)\n{\n\ts32 res, i, dev_idx=-1;\n\tBool has_a, has_v;\n\tchar szPatchedName[1024];\n\tconst char *dev_name=NULL;\n\tconst char *default_fmt=NULL;\n\tconst AVInputFormat *dev_fmt=NULL;\n\tGF_FFDemuxCtx *ctx = gf_filter_get_udta(filter);\n\tBool wants_audio = GF_FALSE;\n\tBool wants_video = GF_FALSE;\n\tctx->fname = \"FFAVIn\";\n\tctx->log_class = GF_LOG_MMIO;\n\n\tffmpeg_setup_logs(ctx->log_class);\n\n\tavdevice_register_all();\n\n\tif (!ctx->src) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] No source URL specified, expecting video://, audio:/ or av://\\n\", ctx->fname));\n\t\treturn GF_SERVICE_ERROR;\n\t}\n\tdefault_fmt = ctx->fmt;\n\tif (!default_fmt) {\n#ifdef WIN32\n\t\tdefault_fmt = \"dshow\";\n#elif defined(__DARWIN) || defined(__APPLE__)\n\t\tdefault_fmt = \"avfoundation\";\n#elif defined(GPAC_CONFIG_ANDROID)\n\t\tdefault_fmt = \"android_camera\";\n#else\n\t\tdefault_fmt = \"video4linux2\";\n#endif\n\t}\n\n\tif (default_fmt) {\n\t\tdev_fmt = av_find_input_format(default_fmt);\n\t\tif (dev_fmt == NULL) {\n\t\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Cannot find the input format %s\\n\", ctx->fname, default_fmt));\n\t\t}\n#if LIBAVCODEC_VERSION_MAJOR >= 58\n\t\telse if (dev_fmt->priv_class->category != AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT && dev_fmt->priv_class->category != AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT) {\n\t\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s]] %s is neither a video nor an audio input device\\n\", ctx->fname, default_fmt));\n\t\t\tdev_fmt = NULL;\n\t\t}\n#else\n\t\t//not supported for old FFMPEG versions\n#endif\n\t}\n#if (LIBAVCODEC_VERSION_MAJOR >= 58) && (LIBAVCODEC_VERSION_MINOR>=20)\n\tif (!dev_fmt) {\n\t\twhile (1) {\n\t\t\tdev_fmt = av_input_video_device_next(FF_IFMT_CAST dev_fmt);\n\t\t\tif (!dev_fmt) break;\n\t\t\tif (!dev_fmt || !dev_fmt->priv_class) continue;\n\t\t\tif ((dev_fmt->priv_class->category != AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT) && (dev_fmt->priv_class->category != AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT))\n\t\t\t\tcontinue;\n\n\t\t\t//listing devices is on its way of implementation in ffmpeg ... for now break at first provider\n\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\tif (!dev_fmt) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] No input format specified\\n\", ctx->fname, ctx->fmt));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tdev_name = ctx->dev;\n\n\tif (!strncmp(ctx->src, \"video://\", 8)) wants_video = GF_TRUE;\n\telse if (!strncmp(ctx->src, \"audio://\", 8)) wants_audio = GF_TRUE;\n\telse if (!strncmp(ctx->src, \"av://\", 5)) wants_video = wants_audio = GF_TRUE;\n\n\tif (sscanf(dev_name, \"%d\", &dev_idx)==1) {\n\t\tsprintf(szPatchedName, \"%d\", dev_idx);\n\t\tif (strcmp(szPatchedName, dev_name))\n\t\t\tdev_idx = -1;\n\t} else {\n\t\tdev_idx = -1;\n\t}\n\n\tszPatchedName[0]=0;\n\n#if defined(__DARWIN) || defined(__APPLE__)\n\tif (!strncmp(dev_name, \"screen\", 6)) {\n\t\tstrcpy(szPatchedName, \"Capture screen \");\n\t\tstrcat(szPatchedName, dev_name+6);\n\t\tdev_name = (char *) szPatchedName;\n\t}\n#endif\n\tif (!strncmp(dev_fmt->priv_class->class_name, \"V4L2\", 4) && (dev_idx>=0) ) {\n\t\tif (wants_audio) {\n\t\t\tsprintf(szPatchedName, \"/dev/video%d:hw:%d\", dev_idx, dev_idx);\n\t\t} else {\n\t\t\tsprintf(szPatchedName, \"/dev/video%d\", dev_idx);\n\t\t}\n\t\tdev_name = (char *) szPatchedName;\n\t}\n\n\telse if (wants_video && wants_audio && (dev_idx>=0)) {\n\t\tsprintf(szPatchedName, \"%d:%d\", dev_idx, dev_idx);\n\t\tdev_name = (char *) szPatchedName;\n\t}\n#if defined(__APPLE__) && !defined(GPAC_CONFIG_IOS)\n\telse if (!strncmp(dev_fmt->priv_class->class_name, \"AVFoundation\", 12) && wants_audio && !wants_video) {\n\t\t//for avfoundation if no video, we must use \":audio_dev_idx\"\n\t\tif (ctx->dev[0] != ':') {\n\t\t\tstrcpy(szPatchedName, \":\");\n\t\t\tstrcat(szPatchedName, ctx->dev);\n\t\t\tdev_name = (char *) szPatchedName;\n\t\t}\n\t}\n#endif\n\n\t/* Open video */\n\tctx->demuxer = avformat_alloc_context();\n\tffmpeg_set_mx_dmx_flags(ctx->options, ctx->demuxer);\n\n\tAVDictionary *options = NULL;\n\tav_dict_copy(&options, ctx->options, 0);\n\n\tres = avformat_open_input(&ctx->demuxer, dev_name, FF_IFMT_CAST dev_fmt, &options);\n\tif ( (res < 0) && !stricmp(ctx->dev, \"screen-capture-recorder\") ) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Buggy screen capture input (open failed with code %d), retrying without specifying resolution\\n\", ctx->fname, res));\n\t\tav_dict_free(&options);\n\t\toptions = NULL;\n\t\tav_dict_copy(&options, ctx->options, 0);\n\t\tav_dict_set(&options, \"video_size\", NULL, 0);\n\t\tres = avformat_open_input(&ctx->demuxer, ctx->dev, FF_IFMT_CAST dev_fmt, &options);\n\t}\n\n\tif (res < 0) {\n\t\tav_dict_free(&options);\n\t\toptions = NULL;\n\t\tav_dict_copy(&options, ctx->options, 0);\n\t\tav_dict_set(&options, \"framerate\", \"30\", 0);\n\t\tctx->fps_forced.num = 30;\n\t\tctx->fps_forced.den = 1;\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Error %d opening input - retrying with 30 fps\\n\", ctx->fname, res));\n\t\tres = avformat_open_input(&ctx->demuxer, dev_name, FF_IFMT_CAST dev_fmt, &options);\n\t\tif (res < 0) {\n\t\t\tav_dict_free(&options);\n\t\t\toptions = NULL;\n\t\t\tav_dict_copy(&options, ctx->options, 0);\n\t\t\tav_dict_set(&options, \"framerate\", \"25\", 0);\n\t\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Error %d opening input - retrying with 25 fps\\n\", ctx->fname, res));\n\t\t\tctx->fps_forced.num = 25;\n\t\t\tres = avformat_open_input(&ctx->demuxer, dev_name, FF_IFMT_CAST dev_fmt, &options);\n\n\t\t\tif ((res<0) && options) {\n\t\t\t\tav_dict_free(&options);\n\t\t\t\toptions = NULL;\n\t\t\t\tctx->fps_forced.num = 0;\n\t\t\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Error %d opening input - retrying without options\\n\", ctx->fname, res));\n\t\t\t\tres = avformat_open_input(&ctx->demuxer, dev_name, FF_IFMT_CAST dev_fmt, NULL);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tAVDictionaryEntry *key = NULL;\n\t\twhile (1) {\n\t\t\tkey = av_dict_get(ctx->options, \"\", key, AV_DICT_IGNORE_SUFFIX);\n\t\t\tif (!key) break;\n\t\t\tif (!strcmp(key->key, \"framerate\")) {\n\t\t\t\tchar *fps = key->value;\n\t\t\t\tif (strchr(fps, '.')) {\n\t\t\t\t\tctx->fps_forced.num = (u32) (atoi(fps)*1000);\n\t\t\t\t\tctx->fps_forced.den = 1000;\n\t\t\t\t} else {\n\t\t\t\t\tctx->fps_forced.num = atoi(fps);\n\t\t\t\t\tctx->fps_forced.den = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (res < 0) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] Cannot open device %s:%s\\n\", ctx->fname, dev_fmt->priv_class->class_name, ctx->dev));\n\t\tif (options) av_dict_free(&options);\n\t\treturn -1;\n\t}\n\n\tav_dump_format(ctx->demuxer, 0, ctx->dev, 0);\n\tctx->raw_data = GF_TRUE;\n\tctx->audio_idx = ctx->video_idx = -1;\n\tu32 grab_type = 1;\n#if defined(GPAC_CONFIG_IOS) || defined(GPAC_CONFIG_ANDROID)\n\tif (!strcmp(ctx->dev, \"1\") || strstr(ctx->dev, \"Front\") || strstr(ctx->dev, \"front\") )\n\t\tgrab_type = 2;\n#endif\n\n\tres = avformat_find_stream_info(ctx->demuxer, ctx->options ? &ctx->options : NULL);\n\n\tffmpeg_report_options(filter, options, ctx->options);\n\n\tif (res <0) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] cannot locate streams - error %s\\n\", ctx->fname,  av_err2str(res)));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\t//check we have the stream we want\n\thas_a = has_v = GF_FALSE;\n\tfor (i = 0; (u32) i < ctx->demuxer->nb_streams; i++) {\n#if (LIBAVFORMAT_VERSION_MAJOR < 59)\n\t\tu32 codec_type = ctx->demuxer->streams[i]->codec->codec_type;\n#else\n\t\tu32 codec_type = ctx->demuxer->streams[i]->codecpar->codec_type;\n#endif\n\n\t\tswitch (codec_type) {\n\t\tcase AVMEDIA_TYPE_AUDIO:\n\t\t\thas_a = GF_TRUE;\n\t\t\tbreak;\n\t\tcase AVMEDIA_TYPE_VIDEO:\n\t\t\thas_v = GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (wants_audio && !has_a) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] No audio stream in input device\\n\", ctx->fname));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (wants_video && !has_v) {\n\t\tGF_LOG(GF_LOG_ERROR, ctx->log_class, (\"[%s] No video stream in input device\\n\", ctx->fname));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tctx->probe_frames = ctx->probes;\n\tif (has_v && ctx->probes) {\n\t\tctx->probe_times = gf_malloc(sizeof(u64) * ctx->probes);\n\t\tmemset(ctx->probe_times, 0, sizeof(u64) * ctx->probes);\n\t\t//we probe timestamps in either modes because timestamps of first frames are sometimes off\n\t\tctx->probe_frames = 0;\n\t}\n\n\tGF_LOG(GF_LOG_INFO, ctx->log_class, (\"[%s] device %s:%s opened - %d streams\\n\", ctx->fname, dev_fmt->priv_class->class_name, ctx->dev, ctx->demuxer->nb_streams));\n\n\tctx->copy_audio = ctx->copy_video = GF_FALSE;\n\tswitch (ctx->copy) {\n\tcase COPY_NO:\n\t\tbreak;\n\tcase COPY_A:\n\t\tctx->copy_audio = GF_TRUE;\n\t\tbreak;\n\tcase COPY_V:\n\t\tctx->copy_video = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\tctx->copy_audio = ctx->copy_video = GF_TRUE;\n\t\tbreak;\n\t}\n\tif (wants_audio && wants_video) {\n\t\tif (!ctx->copy_audio || !ctx->copy_video) {\n\t\t\tGF_LOG(GF_LOG_WARNING, ctx->log_class, (\"[%s] using muxed capture av:// without copy on %s, this might introduce packet losses due to blocking modes or delayed consumption of the frames. If experiencing problems, either set [-copy]() to `AV` or consider using two filters video:// and audio://\\n\", ctx->fname, (!ctx->copy_audio && !ctx->copy_video) ? \"audio and video streams\" : ctx->copy_video ? \"audio stream\" : \"video stream\"));\n\t\t}\n\t}\n\treturn ffdmx_init_common(filter, ctx, grab_type);\n}\n\nstatic GF_FilterProbeScore ffavin_probe_url(const char *url, const char *mime)\n{\n\tif (!strncmp(url, \"video://\", 8)) return GF_FPROBE_MAYBE_SUPPORTED;\n\tif (!strncmp(url, \"audio://\", 8)) return GF_FPROBE_MAYBE_SUPPORTED;\n\tif (!strncmp(url, \"av://\", 5)) return GF_FPROBE_MAYBE_SUPPORTED;\n\treturn GF_FPROBE_NOT_SUPPORTED;\n}\n\nstatic const GF_FilterCapability FFAVInCaps[] =\n{\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL)\n\t//do not expose a specific codec ID (eg raw) as some grabbers might give us mjpeg\n};\n\nGF_FilterRegister FFAVInRegister = {\n\t.name = \"ffavin\",\n\t.version = LIBAVDEVICE_IDENT,\n\tGF_FS_SET_DESCRIPTION(\"FFMPEG AV Capture\")\n\tGF_FS_SET_HELP(\"Reads from audio/video capture devices using FFMPEG.\\n\"\n\t\"See FFMPEG documentation (https://ffmpeg.org/documentation.html) for more details.\\n\"\n\t\"To list all supported grabbers for your GPAC build, use `gpac -h ffavin:*`.\\n\"\n\t\"\\n\"\n\t\"# Device identification\\n\"\n\t\"Typical classes are `dshow` on windows, `avfoundation` on OSX, `video4linux2` or `x11grab` on linux\\n\"\n\t\"\\n\"\n\t\"Typical device name can be the webcam name:\\n\"\n\t\"- `FaceTime HD Camera` on OSX, device name on windows, `/dev/video0` on linux\\n\"\n\t\"- `screen-capture-recorder`, see http://screencapturer.sf.net/ on windows\\n\"\n\t\"- `Capture screen 0` on OSX (0=first screen), or `screenN` for short\\n\"\n\t\"- X display name (e.g. `:0.0`) on linux\\n\"\n\t\"\\n\"\n\t\"The general mapping from ffmpeg command line is:\\n\"\n\t\"- ffmpeg `-f` maps to [-fmt]() option\\n\"\n\t\"- ffmpeg `-i` maps to [-dev]() option\\n\"\n\t\"\\n\"\n\t\"EX ffmpeg -f libndi_newtek -i MY_NDI_TEST ...\\n\"\n\t\"EX gpac -i av://:fmt=libndi_newtek:dev=MY_NDI_TEST ...\\n\"\n\t\"\\n\"\n\t\"You may need to escape the [-dev]() option if the format uses ':' as separator, as is the case for AVFoundation:\\n\"\n\t\"EX gpac -i av://::dev=0:1 ...\\n\"\n\t)\n\t.private_size = sizeof(GF_FFDemuxCtx),\n\tSETCAPS(FFAVInCaps),\n\t.initialize = ffavin_initialize,\n\t.finalize = ffdmx_finalize,\n\t.process = ffdmx_process,\n\t.update_arg = ffdmx_update_arg,\n\t.probe_url = ffavin_probe_url,\n\t.process_event = ffdmx_process_event,\n\t.flags = GF_FS_REG_META,\n};\n\n\nstatic const GF_FilterArgs FFAVInArgs[] =\n{\n\t{ OFFS(src), \"url of device, `video://`, `audio://` or `av://`\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(fmt), \"name of device class. If not set, defaults to first device class\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(dev), \"name of device or index of device\", GF_PROP_STRING, \"0\", NULL, 0},\n\t{ OFFS(copy), \"set copy mode of raw frames\\n\"\n\t\t\"- N: frames are only forwarded (shared memory, no copy)\\n\"\n\t\t\"- A: audio frames are copied, video frames are forwarded\\n\"\n\t\t\"- V: video frames are copied, audio frames are forwarded\\n\"\n\t\t\"- AV: all frames are copied\"\n\t\t\"\", GF_PROP_UINT, \"A\", \"N|A|V|AV\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sclock), \"use system clock (us) instead of device timestamp (for buggy devices)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(probes), \"probe a given number of video frames before emitting (this usually helps with bad timing of the first frames)\", GF_PROP_UINT, \"10\", \"0-100\", GF_FS_ARG_HINT_EXPERT},\n\t{ \"*\", -1, \"any possible options defined for AVInputFormat and AVFormatContext (see `gpac -hx ffavin` and `gpac -hx ffavin:*`)\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_META},\n\t{0}\n};\n\n\n//number of arguments defined above\nconst int FFAVIN_STATIC_ARGS = (sizeof (FFAVInArgs) / sizeof (GF_FilterArgs)) - 1;\n\n\n#if (LIBAVCODEC_VERSION_MAJOR >= 58) && (LIBAVCODEC_VERSION_MINOR>=18) && !defined(GPAC_DISABLE_DOC)\n#define FF_PROBE_DEVICES\n#endif\n\n#ifdef FF_PROBE_DEVICES\nchar *dev_desc = NULL;\n\nstatic void ffavin_enum_devices(const char *dev_name, Bool is_audio)\n{\n\tconst AVInputFormat *fmt;\n\tAVFormatContext *ctx;\n\n    if (!dev_name) return;\n    fmt = av_find_input_format(dev_name);\n    if (!fmt) return;\n\n    if (!fmt || !fmt->priv_class || !AV_IS_INPUT_DEVICE(fmt->priv_class->category)) {\n\t\treturn;\n\t}\n    ctx = avformat_alloc_context();\n    if (!ctx) return;\n    ctx->iformat = (AVInputFormat *)fmt;\n    if (ctx->iformat->priv_data_size > 0) {\n        ctx->priv_data = av_mallocz(ctx->iformat->priv_data_size);\n        if (!ctx->priv_data) {\n\t\t\tavformat_free_context(ctx);\n            return;\n        }\n        if (ctx->iformat->priv_class) {\n            *(const AVClass**)ctx->priv_data = ctx->iformat->priv_class;\n            av_opt_set_defaults(ctx->priv_data);\n        }\n    } else {\n        ctx->priv_data = NULL;\n\t}\n\n\tAVDeviceInfoList *dev_list = NULL;\n\n    AVDictionary *tmp = NULL;\n\tav_dict_set(&tmp, \"list_devices\", \"1\", 0);\n    av_opt_set_dict2(ctx, &tmp, AV_OPT_SEARCH_CHILDREN);\n\tif (tmp)\n\t\tav_dict_free(&tmp);\n\n\tint res = avdevice_list_devices(ctx, &dev_list);\n\tif (res<0) {\n\t\t//device doesn't implement avdevice_list_devices, try loading the context using \"list_devices=1\" option\n\t\tif (-res == ENOSYS) {\n\t\t\tAVDictionary *opts = NULL;\n\t\t\tav_dict_set(&opts, \"list_devices\", \"1\", 0);\n\t\t\tres = avformat_open_input(&ctx, \"dummy\", FF_IFMT_CAST fmt, &opts);\n\t\t\tif (opts)\n\t\t\t\tav_dict_free(&opts);\n\t\t}\n\t} else if (!res && dev_list->nb_devices) {\n\t\tif (!dev_desc) {\n\t\t\tgf_dynstrcat(&dev_desc, \"# Detected devices\\n\", NULL);\n\t\t}\n\t\tgf_dynstrcat(&dev_desc, dev_name, NULL);\n\t\tgf_dynstrcat(&dev_desc, is_audio ? \" audio\" : \" video\", NULL);\n\t\tgf_dynstrcat(&dev_desc, \" devices\\n\", NULL);\n\t\tfor (int i=0; i<dev_list->nb_devices; i++) {\n\t\t\tchar szFmt[20];\n\t\t\tsprintf(szFmt, \"[%d] \", i);\n\t\t\tgf_dynstrcat(&dev_desc, dev_list->devices[i]->device_name, szFmt);\n\t\t\tgf_dynstrcat(&dev_desc, dev_list->devices[i]->device_description, \": \");\n\t\t\tgf_dynstrcat(&dev_desc, \"\\n\", NULL);\n\t\t}\n\t}\n\n\tif (dev_list) avdevice_free_list_devices(&dev_list);\n\tavformat_free_context(ctx);\n}\n\nstatic void ffavin_log_none(void *avcl, int level, const char *fmt, va_list vl)\n{\n\tif (level == AV_LOG_INFO) {\n\t\tchar szLogBuf[2049];\n\t\tvsnprintf(szLogBuf, 2048, fmt, vl);\n\t\tszLogBuf[2048]=0;\n\n\t\tif (!dev_desc) {\n\t\t\tgf_dynstrcat(&dev_desc, \"# Detected devices\\n\", NULL);\n\t\t}\n\t\tgf_dynstrcat(&dev_desc, szLogBuf, NULL);\n\t}\n}\n#endif\n\nconst GF_FilterRegister *ffavin_register(GF_FilterSession *session)\n{\n\tGF_FilterRegister *res_reg = ffmpeg_build_register(session, &FFAVInRegister, FFAVInArgs, FFAVIN_STATIC_ARGS, FF_REG_TYPE_DEV_IN);\n\n\tif (gf_opts_get_bool(\"temp\", \"get_proto_schemes\")) {\n\t\tgf_opts_set_key(\"temp_in_proto\", FFAVInRegister.name, \"video,audio,av\");\n\t}\n\tif (!gf_opts_get_bool(\"temp\", \"helponly\") || gf_opts_get_bool(\"temp\", \"gendoc\"))\n\t\treturn res_reg;\n\n\t//do not open devices if help is not for ffavin or a sub-filter\n\tBool found = GF_FALSE;\n\tu32 i, argc = gf_sys_get_argc();\n\tfor (i=1; i<argc; i++) {\n\t\tconst char *a = gf_sys_get_arg(i);\n\t\tif (!strncmp(a, \"ffavin\", 6)) {\n\t\t\tfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\treturn res_reg;\n\n#ifdef FF_PROBE_DEVICES\n\tBool audio_pass=GF_FALSE;\n\tav_log_set_callback(ffavin_log_none);\n\tconst AVInputFormat *fmt = NULL;\n\twhile (1) {\n\t\tif (audio_pass) {\n\t\t\tfmt = av_input_audio_device_next(FF_IFMT_CAST fmt);\n\t\t} else {\n\t\t\tfmt = av_input_video_device_next(FF_IFMT_CAST fmt);\n\t\t}\n\t\tif (!fmt) {\n\t\t\tif (audio_pass) break;\n\t\t\taudio_pass = GF_TRUE;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!fmt->priv_class) continue;\n\t\tif (audio_pass && (fmt->priv_class->category!=AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT)) continue;\n\t\telse if (!audio_pass && (fmt->priv_class->category!=AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT)) continue;\n\t\tffavin_enum_devices(fmt->name, audio_pass);\n\t}\n\tav_log_set_callback(av_log_default_callback);\n\n\tif (!dev_desc) dev_desc = gf_strdup(\"No device found !\\n\");\n\tif (dev_desc) {\n\t\tchar *out_doc = NULL;\n\t\tgf_dynstrcat(&out_doc, FFAVInRegister.help, NULL);\n\t\tgf_dynstrcat(&out_doc, dev_desc, \"\\n\");\n\t\tgf_free(dev_desc);\n\t\tres_reg->help = out_doc;\n\t\tffmpeg_register_set_dyn_help(res_reg);\n\t}\n#endif\n\treturn res_reg;\n}\n\n#else // FFMPEG_DISABLE_AVDEVICE\n\nconst GF_FilterRegister *ffavin_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif\n\n\n#else\n\n#include <gpac/filters.h>\n\nconst GF_FilterRegister *ffdmx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\nconst GF_FilterRegister *ffdmxpid_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n\nconst GF_FilterRegister *ffavin_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif\n"], "filenames": ["src/filters/ff_dmx.c"], "buggy_code_start_loc": [1240], "buggy_code_end_loc": [1241], "fixing_code_start_loc": [1240], "fixing_code_end_loc": [1241], "type": "CWE-787", "message": "GPAC 2.3-DEV-rev605-gfc9e29089-master contains a heap-buffer-overflow in ffdmx_parse_side_data /afltest/gpac/src/filters/ff_dmx.c:202:14 in gpac/MP4Box.", "other": {"cve": {"id": "CVE-2023-46931", "sourceIdentifier": "cve@mitre.org", "published": "2023-11-01T14:15:38.640", "lastModified": "2023-11-08T19:36:49.673", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GPAC 2.3-DEV-rev605-gfc9e29089-master contains a heap-buffer-overflow in ffdmx_parse_side_data /afltest/gpac/src/filters/ff_dmx.c:202:14 in gpac/MP4Box."}, {"lang": "es", "value": "GPAC 2.3-DEV-rev605-gfc9e29089-master contiene un desbordamiento de b\u00fafer de mont\u00f3n en ffdmx_parse_side_data /afltest/gpac/src/filters/ff_dmx.c:202:14 en gpac/MP4Box."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:2.3-dev-rev605-gfc9e29089-master:*:*:*:*:*:*:*", "matchCriteriaId": "276701A5-2ABB-4EDB-9E2A-96A6A9EA62D9"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/671976fccc971b3dff8d3dcf6ebd600472ca64bf.", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/2664", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/671976fccc971b3dff8d3dcf6ebd600472ca64bf."}}