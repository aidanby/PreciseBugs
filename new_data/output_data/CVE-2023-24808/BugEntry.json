{"buggy_code": ["Changes in PDFio\n================\n\n\nv1.1.0 (Month DD, YYYY)\n-----------------------\n\n- Added `pdfioFileCreateTemporary` function (Issue #29)\n- Added `pdfioDictIterateKeys` function (Issue #31)\n- Added `pdfioContentPathEnd` function.\n- Added protection against opening multiple streams in the same file at the\n  same time.\n- Documentation updates (Issue #37)\n- Fixed \"install-shared\" target (Issue #32)\n- Fixed `pdfioFileGet...` metadata APIs (Issue #33)\n- Fixed `pdfioContentMatrixRotate` function.\n\n\nv1.0.1 (March 2, 2022)\n----------------------\n\n- Added missing `pdfioPageGetNumStreams` and `pdfioPageOpenStream` functions.\n- Added demo pdfiototext utility.\n- Fixed bug in `pdfioStreamGetToken`.\n\n\nv1.0.0 (December 14, 2021)\n--------------------------\n\n- First stable release.\n\n\nv1.0rc1 (November 30, 2021)\n---------------------------\n\n- Fixed a few stack/buffer overflow bugs discovered via fuzzing.\n\n\nv1.0b2 (November 7, 2021)\n-------------------------\n\n- Added `pdfioFileCreateOutput` API to support streaming output of PDF\n  (Issue #21)\n- Fixed `all-shared` target (Issue #22)\n- Fixed memory leaks (Issue #23)\n- Updated `pdfioContentSetDashPattern` to accept `double` values (Issue #25)\n- Added support for reading and writing encrypted PDFs (Issue #26)\n- Fixed some issues identified by a Coverity scan.\n\n\nv1.0b1 (August 30, 2021)\n------------------------\n\n- Initial release\n", "#\n# Makefile for PDFio.\n#\n# Copyright \u00a9\u00a02021-2022 by Michael R Sweet.\n#\n# Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n# information.\n#\n\n# POSIX makefile\n.POSIX:\n\n# Build silently\n.SILENT:\n\n# Variables\nAR\t\t=\tar\nARFLAGS\t\t=\tcr\nCC\t\t=\tcc\nCFLAGS\t\t=\nCODESIGN_IDENTITY =\tDeveloper ID\nCOMMONFLAGS\t=\t-Os -g\n#COMMONFLAGS\t=\t-O0 -g -fsanitize=address\nCPPFLAGS\t=\t'-DPDFIO_VERSION=\"$(VERSION)\"'\nDESTDIR\t\t=\t$(DSTROOT)\nDSO\t\t=\tcc\nDSOFLAGS\t=\nDSONAME\t\t=\nLDFLAGS\t\t=\nLIBS\t\t=\t-lm -lz\nRANLIB\t\t=\tranlib\nVERSION\t\t=\t1.1\nprefix\t\t=\t/usr/local\n\n\n# Base rules\n.SUFFIXES:\t.c .h .o\n.c.o:\n\techo Compiling $<...\n\t$(CC) $(CFLAGS) $(CPPFLAGS) $(COMMONFLAGS) -c $<\n\n\n# Files\nPUBHEADERS\t=\t\\\n\t\t\tpdfio.h \\\n\t\t\tpdfio-content.h\nPUBOBJS\t\t=\t\\\n\t\t\tpdfio-aes.o \\\n\t\t\tpdfio-array.o \\\n\t\t\tpdfio-common.o \\\n\t\t\tpdfio-content.o \\\n\t\t\tpdfio-crypto.o \\\n\t\t\tpdfio-dict.o \\\n\t\t\tpdfio-file.o \\\n\t\t\tpdfio-md5.o \\\n\t\t\tpdfio-object.o \\\n\t\t\tpdfio-page.o \\\n\t\t\tpdfio-rc4.o \\\n\t\t\tpdfio-sha256.o \\\n\t\t\tpdfio-stream.o \\\n\t\t\tpdfio-string.o \\\n\t\t\tpdfio-token.o \\\n\t\t\tpdfio-value.o\nLIBOBJS\t\t=\t\\\n\t\t\t$(PUBOBJS) \\\n\t\t\tttf.o\nOBJS\t\t=\t\\\n\t\t\t$(LIBOBJS) \\\n\t\t\tpdfiototext.o \\\n\t\t\ttestpdfio.o\nTARGETS\t\t=\t\\\n\t\t\t$(DSONAME) \\\n\t\t\tlibpdfio.a \\\n\t\t\tpdfiototext \\\n\t\t\ttestpdfio\n\n\n# Make everything\nall:\t\t$(TARGETS)\n\nall-shared:\n\tif test `uname` = Darwin; then \\\n\t\t$(MAKE) DSONAME=\"libpdfio.1.dylib\" -$(MAKEFLAGS) all; \\\n\telse \\\n\t\t$(MAKE) COMMONFLAGS=\"-g -Os -fPIC\" DSONAME=\"libpdfio.so.1\" -$(MAKEFLAGS) all; \\\n\tfi\n\ndebug:\n\t$(MAKE) -$(MAKEFLAGS) COMMONFLAGS=\"-g -fsanitize=address -DDEBUG=1\" clean all\n\nmacos:\n\t$(MAKE) -$(MAKEFLAGS) COMMONFLAGS=\"-Os -mmacosx-version-min=10.14 -arch x86_64 -arch arm64\" clean all\n\n\n# Clean everything\nclean:\n\trm -f $(TARGETS) $(OBJS)\n\n\n# Install everything\ninstall:\t$(TARGETS)\n\techo Installing header files to $(DESTDIR)$(prefix)/include...\n\t-mkdir -p $(DESTDIR)$(prefix)/include\n\tcp $(PUBHEADERS) $(DESTDIR)$(prefix)/include\n\techo Installing library files to $(DESTDIR)$(prefix)/lib...\n\t-mkdir -p $(DESTDIR)$(prefix)/lib\n\tcp libpdfio.a $(DESTDIR)$(prefix)/lib\n\t$(RANLIB) $(DESTDIR)$(prefix)/lib/libpdfio.a\n\tif test \"x$(DSONAME)\" = xlibpdfio.so.1; then \\\n\t\tcp $(DSONAME) $(DESTDIR)$(prefix)/lib; \\\n\t\tln -sf libpdfio.so.1 $(DESTDIR)$(prefix)/lib/libpdfio.so; \\\n\telif test \"x$(DSONAME)\" = xlibpdfio.1.dylib; then \\\n\t\tcp $(DSONAME) $(DESTDIR)$(prefix)/lib; \\\n\t\tcodesign -s \"$(CODESIGN_IDENTITY)\" -o runtime --timestamp $(DESTDIR)$(prefix)/lib/libpdfio.1.dylib; \\\n\t\tln -sf libpdfio.1.dylib $(DESTDIR)$(prefix)/lib/libpdfio.dylib; \\\n\tfi\n\techo Installing pkg-config files to $(DESTDIR)$(prefix)/lib/pkgconfig...\n\t-mkdir -p $(DESTDIR)$(prefix)/lib/pkgconfig\n\techo 'prefix=\"$(prefix)\"' >$(DESTDIR)$(prefix)/lib/pkgconfig/pdfio.pc\n\techo 'Version: $(VERSION)' >>$(DESTDIR)$(prefix)/lib/pkgconfig/pdfio.pc\n\tcat pdfio.pc.in >>$(DESTDIR)$(prefix)/lib/pkgconfig/pdfio.pc\n\techo Installing documentation to $(DESTDIR)$(prefix)/share/doc/pdfio...\n\t-mkdir -p $(DESTDIR)$(prefix)/share/doc/pdfio\n\tcp doc/pdfio.html doc/pdfio-512.png LICENSE NOTICE $(DESTDIR)$(prefix)/share/doc/pdfio\n\techo Installing man page to $(DESTDIR)$(prefix)/share/man/man3...\n\t-mkdir -p $(DESTDIR)$(prefix)/share/man/man3\n\tcp doc/pdfio.3 $(DESTDIR)$(prefix)/share/man/man3\n\ninstall-shared:\n\tif test `uname` = Darwin; then \\\n\t\t$(MAKE) DSONAME=\"libpdfio.1.dylib\" -$(MAKEFLAGS) install; \\\n\telse \\\n\t\t$(MAKE) DSONAME=\"libpdfio.so.1\" -$(MAKEFLAGS) install; \\\n\tfi\n\n\n# Test everything\ntest:\ttestpdfio\n\t./testpdfio\n\nvalgrind:\ttestpdfio\n\tvalgrind --leak-check=full ./testpdfio\n\n\n# pdfio library\nlibpdfio.a:\t\t$(LIBOBJS)\n\techo Archiving $@...\n\t$(AR) $(ARFLAGS) $@ $(LIBOBJS)\n\t$(RANLIB) $@\n\nlibpdfio.so.1:\t\t$(LIBOBJS)\n\techo Linking $@...\n\t$(CC) $(DSOFLAGS) $(COMMONFLAGS) -shared -o $@ -Wl,-soname,$@ $(LIBOBJS) $(LIBS)\n\nlibpdfio.1.dylib:\t$(LIBOBJS)\n\techo Linking $@...\n\t$(CC) $(DSOFLAGS) $(COMMONFLAGS) -dynamiclib -o $@ -install_name $(prefix)/lib/$@ -current_version $(VERSION) -compatibility_version 1.0 $(LIBOBJS) $(LIBS)\n\n\n# pdfio1.def (Windows DLL exports file...)\n#\n# I'd love to use __declspec(dllexport) but MS puts it before the function\n# declaration instead of after like everyone else, and it breaks Codedoc and\n# other tools I rely on...\npdfio1.def: $(LIBOBJS) Makefile\n\techo Generating $@...\n\techo \"LIBRARY pdfio1\" >$@\n\techo \"VERSION 1.0\" >>$@\n\techo \"EXPORTS\" >>$@\n\tnm $(LIBOBJS) 2>/dev/null | grep \"T _\" | awk '{print $$3}' | \\\n\t\tgrep -v '^_ttf' | sed -e '1,$$s/^_//' | sort >>$@\n\n\n# pdfio text extraction (demo, doesn't handle a lot of things yet)\npdfiototext:\t\tpdfiototext.o libpdfio.a\n\techo Linking $@...\n\t$(CC) $(LDFLAGS) $(COMMONFLAGS) -o $@ pdfiototext.o libpdfio.a $(LIBS)\n\n\n# pdfio test program\ntestpdfio:\t\ttestpdfio.o libpdfio.a\n\techo Linking $@...\n\t$(CC) $(LDFLAGS) $(COMMONFLAGS) -o $@ testpdfio.o libpdfio.a $(LIBS)\n\n\n# Dependencies\n$(OBJS):\t\tpdfio.h pdfio-private.h Makefile\npdfio-content.o:\tpdfio-content.h ttf.h\nttf.o:\t\t\tttf.h\n\n# Make documentation using Codedoc <https://www.msweet.org/codedoc>\nDOCFLAGS\t=\t\\\n\t\t\t--author \"Michael R Sweet\" \\\n\t\t\t--copyright \"Copyright (c) 2021-2022 by Michael R Sweet\" \\\n\t\t\t--docversion $(VERSION)\n\n.PHONY: doc\ndoc:\n\techo Generating documentation...\n\tcodedoc $(DOCFLAGS) --title \"PDFio Programming Manual v$(VERSION)\" $(PUBHEADERS) $(PUBOBJS:.o=.c) --body doc/pdfio.md --coverimage doc/pdfio-512.png pdfio.xml >doc/pdfio.html\n\tcodedoc $(DOCFLAGS) --title \"PDFio Programming Manual v$(VERSION)\" --body doc/pdfio.md --coverimage doc/pdfio-epub.png pdfio.xml --epub doc/pdfio.epub\n\tcodedoc $(DOCFLAGS) --title \"pdf read/write library\" --man pdfio --section 3 --body doc/pdfio.md pdfio.xml >doc/pdfio.3\n\trm -f pdfio.xml\n\n\n# Fuzz-test the library <>\n.PHONY: afl\nafl:\n\t$(MAKE) -$(MAKEFLAGS) CC=\"afl-clang-fast\" COMMONFLAGS=\"-g\" clean all\n\ttest afl-output || rm -rf afl-output\n\tafl-fuzz -x afl-pdf.dict -i afl-input -o afl-output -V 600 -e pdf -t 5000 ./testpdfio @@\n\n\n# Analyze code with the Clang static analyzer <https://clang-analyzer.llvm.org>\nclang:\n\tclang $(CPPFLAGS) --analyze $(OBJS:.o=.c) 2>clang.log\n\trm -rf $(OBJS:.o=.plist)\n\ttest -s clang.log && (echo \"$(GHA_ERROR)Clang detected issues.\"; echo \"\"; cat clang.log; exit 1) || exit 0\n\n\n# Analyze code using Cppcheck <http://cppcheck.sourceforge.net>\ncppcheck:\n\tcppcheck $(CPPFLAGS) --template=gcc --addon=cert.py --suppressions-list=.cppcheck $(OBJS:.o=.c) 2>cppcheck.log\n\ttest -s cppcheck.log && (echo \"$(GHA_ERROR)Cppcheck detected issues.\"; echo \"\"; cat cppcheck.log; exit 1) || exit 0\n", "PDFio - PDF Read/Write Library\n\nCopyright \u00a9 2021-2022 by Michael R Sweet.\n\n(Optional) Exceptions to the Apache 2.0 License:\n================================================\n\nAs an exception, if, as a result of your compiling your source code, portions\nof this Software are embedded into an Object form of such source code, you\nmay redistribute such embedded portions in such Object form without complying\nwith the conditions of Sections 4(a), 4(b) and 4(d) of the License.\n\nIn addition, if you combine or link compiled forms of this Software with\nsoftware that is licensed under the GPLv2 (\"Combined Software\") and if a\ncourt of competent jurisdiction determines that the patent provision (Section\n3), the indemnity provision (Section 9) or other Section of the License\nconflicts with the conditions of the GPLv2, you may retroactively and\nprospectively choose to deem waived or otherwise exclude such Section(s) of\nthe License, but only in their entirety and only with respect to the Combined\nSoftware.\n", "//\n// Common support functions for pdfio.\n//\n// Copyright \u00a9\u00a02021 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n\n\n//\n// Local functions...\n//\n\nstatic bool\tfill_buffer(pdfio_file_t *pdf);\nstatic ssize_t\tread_buffer(pdfio_file_t *pdf, char *buffer, size_t bytes);\nstatic bool\twrite_buffer(pdfio_file_t *pdf, const void *buffer, size_t bytes);\n\n\n//\n// '_pdfioFileConsume()' - Consume bytes from the file.\n//\n\nbool\t\t\t\t\t// O - `true` on sucess, `false` on EOF\n_pdfioFileConsume(pdfio_file_t *pdf,\t// I - PDF file\n                  size_t       bytes)\t// I - Bytes to consume\n{\n  PDFIO_DEBUG(\"_pdfioFileConsume(pdf=%p, bytes=%u)\\n\", pdf, (unsigned)bytes);\n\n  if ((size_t)(pdf->bufend - pdf->bufptr) > bytes)\n    pdf->bufptr += bytes;\n  else if (_pdfioFileSeek(pdf, (off_t)bytes, SEEK_CUR) < 0)\n    return (false);\n\n  return (true);\n}\n\n\n//\n// '_pdfioFileDefaultError()' - Default error callback.\n//\n// The default error callback writes the error message to stderr and returns\n// `false` to halt.\n//\n\nbool\t\t\t\t\t// O - `false` to stop\n_pdfioFileDefaultError(\n    pdfio_file_t *pdf,\t\t\t// I - PDF file\n    const char   *message,\t\t// I - Error message\n    void         *data)\t\t\t// I - Callback data (unused)\n{\n  (void)data;\n\n  fprintf(stderr, \"%s: %s\\n\", pdf->filename, message);\n\n  return (false);\n}\n\n\n//\n// '_pdfioFileError()' - Display an error message.\n//\n\nbool\t\t\t\t\t// O - `true` to continue, `false` to stop\n_pdfioFileError(pdfio_file_t *pdf,\t// I - PDF file\n                const char   *format,\t// I - `printf`-style format string\n                ...)\t\t\t// I - Additional arguments as needed\n{\n  char\t\tbuffer[8192];\t\t// Message buffer\n  va_list\tap;\t\t\t// Argument pointer\n\n\n  va_start(ap, format);\n  vsnprintf(buffer, sizeof(buffer), format, ap);\n  va_end(ap);\n\n  PDFIO_DEBUG(\"_pdfioFileError: %s\\n\", buffer);\n\n  return ((pdf->error_cb)(pdf, buffer, pdf->error_data));\n}\n\n\n//\n// '_pdfioFileFlush()' - Flush any pending write data.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioFileFlush(pdfio_file_t *pdf)\t// I - PDF file\n{\n  PDFIO_DEBUG(\"_pdfioFileFlush(pdf=%p)\\n\", pdf);\n\n  if (pdf->bufptr > pdf->buffer)\n  {\n    if (!write_buffer(pdf, pdf->buffer, (size_t)(pdf->bufptr - pdf->buffer)))\n      return (false);\n\n    pdf->bufpos += pdf->bufptr - pdf->buffer;\n  }\n\n  pdf->bufptr = pdf->buffer;\n\n  return (true);\n}\n\n\n//\n// '_pdfioFileGetChar()' - Get a character from a PDF file.\n//\n\nint\t\t\t\t\t// O - Character or `-1` on EOF\n_pdfioFileGetChar(pdfio_file_t *pdf)\t// I - PDF file\n{\n  // If there is a character ready in the buffer, return it now...\n  if (pdf->bufptr < pdf->bufend)\n    return (*(pdf->bufptr ++));\n\n  // Otherwise try to fill the read buffer...\n  if (!fill_buffer(pdf))\n    return (-1);\n\n  // Then return the next character in the buffer...\n  return (*(pdf->bufptr ++));\n}\n\n\n//\n// '_pdfioFileGets()' - Read a line from a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on error\n_pdfioFileGets(pdfio_file_t *pdf,\t// I - PDF file\n               char         *buffer,\t// I - Line buffer\n\t       size_t       bufsize)\t// I - Size of line buffer\n{\n  bool\teol = false;\t\t\t// End of line?\n  char\t*bufptr = buffer,\t\t// Pointer into buffer\n\t*bufend = buffer + bufsize - 1;\t// Pointer to end of buffer\n\n\n  PDFIO_DEBUG(\"_pdfioFileGets(pdf=%p, buffer=%p, bufsize=%lu) bufpos=%ld, buffer=%p, bufptr=%p, bufend=%p\\n\", pdf, buffer, (unsigned long)bufsize, (long)pdf->bufpos, pdf->buffer, pdf->bufptr, pdf->bufend);\n\n  while (!eol)\n  {\n    // If there are characters ready in the buffer, use them...\n    while (!eol && pdf->bufptr < pdf->bufend && bufptr < bufend)\n    {\n      char ch = *(pdf->bufptr++);\t// Next character in buffer\n\n      if (ch == '\\n' || ch == '\\r')\n      {\n        // CR, LF, or CR + LF end a line...\n        eol = true;\n\n        if (ch == '\\r')\n        {\n          // Check for a LF after CR\n          if (pdf->bufptr >= pdf->bufend)\n          {\n            if (!fill_buffer(pdf))\n              break;\n\t  }\n\n\t  if (pdf->bufptr < pdf->bufend && *(pdf->bufptr) == '\\n')\n\t    pdf->bufptr ++;\n\t}\n      }\n      else\n        *bufptr++ = ch;\n    }\n\n    // Fill the read buffer as needed...\n    if (!eol)\n    {\n      if (!fill_buffer(pdf))\n        break;\n    }\n  }\n\n  *bufptr = '\\0';\n\n  PDFIO_DEBUG(\"_pdfioFileGets: Returning %s, '%s'\\n\", eol ? \"true\" : \"false\", buffer);\n\n  return (eol);\n}\n\n\n//\n// '_pdfioFilePeek()' - Peek at upcoming data in a PDF file.\n//\n\nssize_t\t\t\t\t\t// O - Number of bytes returned\n_pdfioFilePeek(pdfio_file_t *pdf,\t// I - PDF file\n               void         *buffer,\t// I - Buffer\n               size_t       bytes)\t// I - Size of bufffer\n{\n  ssize_t\ttotal;\t\t\t// Total bytes available\n\n\n  // See how much data is buffered up...\n  if (pdf->bufptr >= pdf->bufend)\n  {\n    // Fill the buffer...\n    if (!fill_buffer(pdf))\n      return (-1);\n  }\n\n  if ((total = pdf->bufend - pdf->bufptr) < (ssize_t)bytes && total < (ssize_t)(sizeof(pdf->buffer) / 2))\n  {\n    // Yes, try reading more...\n    ssize_t\trbytes;\t\t\t// Bytes read\n\n    PDFIO_DEBUG(\"_pdfioFilePeek: Sliding buffer, total=%ld\\n\", (long)total);\n\n    memmove(pdf->buffer, pdf->bufptr, total);\n    pdf->bufpos += pdf->bufptr - pdf->buffer;\n    pdf->bufptr = pdf->buffer;\n    pdf->bufend = pdf->buffer + total;\n\n    // Read until we have bytes or a non-recoverable error...\n    while ((rbytes = read(pdf->fd, pdf->bufend, sizeof(pdf->buffer) - (size_t)total)) < 0)\n    {\n      if (errno != EINTR && errno != EAGAIN)\n\tbreak;\n    }\n\n    if (rbytes > 0)\n    {\n      // Expand the buffer...\n      pdf->bufend += rbytes;\n      total       += rbytes;\n    }\n  }\n\n  // Copy anything we have to the buffer...\n  if (total > (ssize_t)bytes)\n    total = (ssize_t)bytes;\n\n  if (total > 0)\n    memcpy(buffer, pdf->bufptr, total);\n\n  return (total);\n}\n\n\n//\n// '_pdfioFilePrintf()' - Write a formatted string to a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioFilePrintf(pdfio_file_t *pdf,\t// I - PDF file\n                 const char   *format,\t// I - `printf`-style format string\n                 ...)\t\t\t// I - Additional arguments as needed\n{\n  char\t\tbuffer[8102];\t\t// String buffer\n  va_list\tap;\t\t\t// Argument list\n\n\n  // Format the string...\n  va_start(ap, format);\n  vsnprintf(buffer, sizeof(buffer), format, ap);\n  va_end(ap);\n\n  // Write it...\n  return (_pdfioFileWrite(pdf, buffer, strlen(buffer)));\n}\n\n\n//\n// '_pdfioFilePuts()' - Write a literal string to a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioFilePuts(pdfio_file_t *pdf,\t// I - PDF file\n               const char   *s)\t\t// I - Literal string\n{\n  // Write it...\n  return (_pdfioFileWrite(pdf, s, strlen(s)));\n}\n\n\n//\n// '_pdfioFileRead()' - Read from a PDF file.\n//\n\nssize_t\t\t\t\t\t// O - Number of bytes read or `-1` on error\n_pdfioFileRead(pdfio_file_t *pdf,\t// I - PDF file\n               void         *buffer,\t// I - Read buffer\n               size_t       bytes)\t// I - Number of bytes to read\n{\n  char\t\t*bufptr = (char *)buffer;\n\t\t\t\t\t// Pointer into buffer\n  ssize_t\ttotal,\t\t\t// Total bytes read\n\t\trbytes;\t\t\t// Bytes read this time\n\n\n  // Loop until we have read all of the requested bytes or hit an error...\n  for (total = 0; bytes > 0; total += rbytes, bytes -= (size_t)rbytes, bufptr += rbytes)\n  {\n    // First read from the file buffer...\n    if ((rbytes = pdf->bufend - pdf->bufptr) > 0)\n    {\n      if ((size_t)rbytes > bytes)\n        rbytes = (ssize_t)bytes;\n\n      memcpy(bufptr, pdf->bufptr, rbytes);\n      pdf->bufptr += rbytes;\n      continue;\n    }\n\n    // Nothing buffered...\n    if (bytes > 1024)\n    {\n      // Advance current position in file as needed...\n      if (pdf->bufend)\n      {\n\tpdf->bufpos += pdf->bufend - pdf->buffer;\n\tpdf->bufptr = pdf->bufend = NULL;\n      }\n\n      // Read directly from the file...\n      if ((rbytes = read_buffer(pdf, bufptr, bytes)) > 0)\n      {\n\tpdf->bufpos += rbytes;\n\tcontinue;\n      }\n      else if (rbytes < 0 && (errno == EINTR || errno == EAGAIN))\n      {\n        rbytes = 0;\n        continue;\n      }\n      else\n        break;\n    }\n    else\n    {\n      // Fill buffer and try again...\n      if (!fill_buffer(pdf))\n\tbreak;\n    }\n  }\n\n  return (total);\n}\n\n\n//\n// '_pdfioFileSeek()' - Seek within a PDF file.\n//\n\noff_t\t\t\t\t\t// O - New offset from beginning of file or `-1` on error\n_pdfioFileSeek(pdfio_file_t *pdf,\t// I - PDF file\n               off_t        offset,\t// I - Offset\n               int          whence)\t// I - Offset base\n{\n  PDFIO_DEBUG(\"_pdfioFileSeek(pdf=%p, offset=%ld, whence=%d)\\n\", pdf, (long)offset, whence);\n\n  // Adjust offset for relative seeks...\n  if (whence == SEEK_CUR)\n  {\n    offset += pdf->bufpos;\n    whence = SEEK_SET;\n  }\n\n  if (pdf->mode == _PDFIO_MODE_READ)\n  {\n    // Reading, see if we already have the data we need...\n    if (whence != SEEK_END && offset >= pdf->bufpos && offset < (pdf->bufpos + pdf->bufend - pdf->buffer))\n    {\n      // Yes, seek within existing buffer...\n      pdf->bufptr = pdf->buffer + offset - pdf->bufpos;\n      PDFIO_DEBUG(\"_pdfioFileSeek: Seek within buffer, bufpos=%ld.\\n\", (long)pdf->bufpos);\n      PDFIO_DEBUG(\"_pdfioFileSeek: buffer=%p, bufptr=%p, bufend=%p\\n\", pdf->buffer, pdf->bufptr, pdf->bufend);\n      return (offset);\n    }\n\n    // No, reset the read buffer\n    pdf->bufptr = pdf->bufend = NULL;\n  }\n  else if (pdf->output_cb)\n  {\n    _pdfioFileError(pdf, \"Unable to seek within output stream.\");\n    return (-1);\n  }\n  else\n  {\n    // Writing, make sure we write any buffered data...\n    if (pdf->bufptr > pdf->buffer)\n    {\n      if (!write_buffer(pdf, pdf->buffer, (size_t)(pdf->bufptr - pdf->buffer)))\n\treturn (-1);\n    }\n\n    pdf->bufptr = pdf->buffer;\n  }\n\n  // Seek within the file...\n  if ((offset = lseek(pdf->fd, offset, whence)) < 0)\n  {\n    _pdfioFileError(pdf, \"Unable to seek within file - %s\", strerror(errno));\n    return (-1);\n  }\n\n  PDFIO_DEBUG(\"_pdfioFileSeek: Reset bufpos=%ld.\\n\", (long)pdf->bufpos);\n  PDFIO_DEBUG(\"_pdfioFileSeek: buffer=%p, bufptr=%p, bufend=%p\\n\", pdf->buffer, pdf->bufptr, pdf->bufend);\n\n  pdf->bufpos = offset;\n\n  return (offset);\n}\n\n\n//\n// '_pdfioFileTell()' - Return the offset within a PDF file.\n//\n\noff_t\t\t\t\t\t// O - Offset from beginning of file\n_pdfioFileTell(pdfio_file_t *pdf)\t// I - PDF file\n{\n  if (pdf->bufptr)\n    return (pdf->bufpos + (pdf->bufptr - pdf->buffer));\n  else\n    return (pdf->bufpos);\n}\n\n\n//\n// '_pdfioFileWrite()' - Write to a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success and `false` on error\n_pdfioFileWrite(pdfio_file_t *pdf,\t// I - PDF file\n                const void   *buffer,\t// I - Write buffer\n                size_t       bytes)\t// I - Bytes to write\n{\n  // See if the data will fit in the write buffer...\n  if (bytes > (size_t)(pdf->bufend - pdf->bufptr))\n  {\n    // No room, flush any current data...\n    if (!_pdfioFileFlush(pdf))\n      return (false);\n\n    if (bytes >= sizeof(pdf->buffer))\n    {\n      // Write directly...\n      if (!write_buffer(pdf, buffer, bytes))\n        return (false);\n\n      pdf->bufpos += bytes;\n\n      return (true);\n    }\n  }\n\n  // Copy data to the buffer and return...\n  memcpy(pdf->bufptr, buffer, bytes);\n  pdf->bufptr += bytes;\n\n  return (true);\n}\n\n\n//\n// 'fill_buffer()' - Fill the read buffer in a PDF file.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nfill_buffer(pdfio_file_t *pdf)\t\t// I - PDF file\n{\n  ssize_t\tbytes;\t\t\t// Bytes read...\n\n\n  // Advance current position in file as needed...\n  if (pdf->bufend)\n    pdf->bufpos += pdf->bufend - pdf->buffer;\n\n  // Try reading from the file...\n  if ((bytes = read_buffer(pdf, pdf->buffer, sizeof(pdf->buffer))) <= 0)\n  {\n    // EOF or hard error...\n    pdf->bufptr = pdf->bufend = NULL;\n    return (false);\n  }\n  else\n  {\n    // Successful read...\n    pdf->bufptr = pdf->buffer;\n    pdf->bufend = pdf->buffer + bytes;\n    return (true);\n  }\n}\n\n\n//\n// 'read_buffer()' - Read a buffer from a PDF file.\n//\n\nstatic ssize_t\t\t\t\t// O - Number of bytes read or -1 on error\nread_buffer(pdfio_file_t *pdf,\t\t// I - PDF file\n            char         *buffer,\t// I - Buffer\n            size_t       bytes)\t\t// I - Number of bytes to read\n{\n  ssize_t\trbytes;\t\t\t// Bytes read...\n\n\n  // Read from the file...\n  while ((rbytes = read(pdf->fd, buffer, bytes)) < 0)\n  {\n    // Stop if we have an error that shouldn't be retried...\n    if (errno != EINTR && errno != EAGAIN)\n      break;\n  }\n\n  if (rbytes < 0)\n  {\n    // Hard error...\n    _pdfioFileError(pdf, \"Unable to read from file - %s\", strerror(errno));\n  }\n\n  return (rbytes);\n}\n\n  \n//\n// 'write_buffer()' - Write a buffer to a PDF file.\n//\n\nstatic bool\t\t\t\t// O - `true` on success and `false` on error\nwrite_buffer(pdfio_file_t *pdf,\t\t// I - PDF file\n\t     const void   *buffer,\t// I - Write buffer\n\t     size_t       bytes)\t// I - Bytes to write\n{\n  const char\t*bufptr = (const char *)buffer;\n\t\t\t\t\t// Pointer into buffer\n  ssize_t\twbytes;\t\t\t// Bytes written...\n\n\n  if (pdf->output_cb)\n  {\n    // Write to a stream...\n    if ((pdf->output_cb)(pdf->output_ctx, buffer, bytes) < 0)\n    {\n      _pdfioFileError(pdf, \"Unable to write to output callback.\");\n      return (false);\n    }\n  }\n  else\n  {\n    // Write to the file...\n    while (bytes > 0)\n    {\n      while ((wbytes = write(pdf->fd, bufptr, bytes)) < 0)\n      {\n\t// Stop if we have an error that shouldn't be retried...\n\tif (errno != EINTR && errno != EAGAIN)\n\t  break;\n      }\n\n      if (wbytes < 0)\n      {\n\t// Hard error...\n\t_pdfioFileError(pdf, \"Unable to write to file - %s\", strerror(errno));\n\treturn (false);\n      }\n\n      bufptr += wbytes;\n      bytes  -= (size_t)wbytes;\n    }\n  }\n\n  return (true);\n}\n", "//\n// PDF dictionary functions for PDFio.\n//\n// Copyright \u00a9\u00a02021-2022 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n\n\n//\n// Local functions...\n//\n\nstatic int\tcompare_pairs(_pdfio_pair_t *a, _pdfio_pair_t *b);\n\n\n//\n// '_pdfioDictClear()' - Remove a key/value pair from a dictionary.\n//\n\nvoid\n_pdfioDictClear(pdfio_dict_t *dict,\t// I - Dictionary\n                const char   *key)\t// I - Key\n{\n  size_t\tidx;\t\t\t// Index into pairs\n  _pdfio_pair_t\t*pair,\t\t\t// Current pair\n\t\tpkey;\t\t\t// Search key\n\n\n  PDFIO_DEBUG(\"_pdfioDictClear(dict=%p, key=\\\"%s\\\")\\n\", dict, key);\n\n  // See if the key is already set...\n  if (dict->num_pairs > 0)\n  {\n    pkey.key = key;\n\n    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n    {\n      // Yes, remove it...\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n\n      idx = (size_t)(pair - dict->pairs);\n      dict->num_pairs --;\n\n      if (idx < dict->num_pairs)\n        memmove(pair, pair + 1, (dict->num_pairs - idx) * sizeof(_pdfio_pair_t));\n    }\n  }\n}\n\n\n//\n// 'pdfioDictCopy()' - Copy a dictionary to a PDF file.\n//\n\npdfio_dict_t *\t\t\t\t// O - New dictionary\npdfioDictCopy(pdfio_file_t *pdf,\t// I - PDF file\n              pdfio_dict_t *dict)\t// I - Original dictionary\n{\n  pdfio_dict_t\t\t*ndict;\t\t// New dictionary\n  size_t\t\ti;\t\t// Looping var\n  _pdfio_pair_t\t\t*p;\t\t// Current source pair\n  const char\t\t*key;\t\t// Current destination key\n  _pdfio_value_t\tv;\t\t// Current destination value\n\n\n  PDFIO_DEBUG(\"pdfioDictCopy(pdf=%p, dict=%p(%p))\\n\", pdf, dict, dict ? dict->pdf : NULL);\n\n  // Create the new dictionary...\n  if ((ndict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n\n  // Pre-allocate the pairs array to make this a little faster...\n  if ((ndict->pairs = (_pdfio_pair_t *)malloc(dict->num_pairs * sizeof(_pdfio_pair_t))) == NULL)\n    return (NULL);\t\t\t// Let pdfioFileClose do the cleanup...\n\n  ndict->alloc_pairs = dict->num_pairs;\n\n  // Copy and add each of the source dictionary's key/value pairs...\n  for (i = dict->num_pairs, p = dict->pairs; i > 0; i --, p ++)\n  {\n    if (!strcmp(p->key, \"Length\") && p->value.type == PDFIO_VALTYPE_INDIRECT && dict->pdf != pdf)\n    {\n      // Don't use indirect stream lengths for copied objects...\n      pdfio_obj_t *lenobj = pdfioFileFindObj(dict->pdf, p->value.value.indirect.number);\n\t\t\t\t\t// Length object\n\n      v.type = PDFIO_VALTYPE_NUMBER;\n      if (lenobj)\n      {\n        if (lenobj->value.type == PDFIO_VALTYPE_NONE)\n          _pdfioObjLoad(lenobj);\n\n\tv.value.number = lenobj->value.value.number;\n      }\n      else\n        v.value.number = 0.0;\n    }\n    else if (!_pdfioValueCopy(pdf, &v, dict->pdf, &p->value))\n      return (NULL);\t\t\t// Let pdfioFileClose do the cleanup...\n\n    if (_pdfioStringIsAllocated(dict->pdf, p->key))\n      key = pdfioStringCreate(pdf, p->key);\n    else\n      key = p->key;\n\n    if (!key)\n      return (NULL);\t\t\t// Let pdfioFileClose do the cleanup...\n\n    // Cannot fail since we already allocated space for the pairs...\n    _pdfioDictSetValue(ndict, key, &v);\n  }\n\n  // Successfully copied the dictionary, so return it...\n  return (ndict);\n}\n\n\n//\n// 'pdfioDictCreate()' - Create a dictionary to hold key/value pairs.\n//\n\npdfio_dict_t *\t\t\t\t// O - New dictionary\npdfioDictCreate(pdfio_file_t *pdf)\t// I - PDF file\n{\n  pdfio_dict_t\t*dict;\t\t\t// New dictionary\n\n\n  if (!pdf)\n    return (NULL);\n\n  if ((dict = (pdfio_dict_t *)calloc(1, sizeof(pdfio_dict_t))) == NULL)\n    return (NULL);\n\n  dict->pdf = pdf;\n\n  if (pdf->num_dicts >= pdf->alloc_dicts)\n  {\n    pdfio_dict_t **temp = (pdfio_dict_t **)realloc(pdf->dicts, (pdf->alloc_dicts + 16) * sizeof(pdfio_dict_t *));\n\n    if (!temp)\n    {\n      free(dict);\n      return (NULL);\n    }\n\n    pdf->dicts       = temp;\n    pdf->alloc_dicts += 16;\n  }\n\n  pdf->dicts[pdf->num_dicts ++] = dict;\n\n  return (dict);\n}\n\n\n//\n// '_pdfioDictDebug()' - Dump a dictionary to stderr.\n//\n\nvoid\n_pdfioDictDebug(pdfio_dict_t *dict,\t// I - Dictionary\n                FILE         *fp)\t// I - Output file\n{\n  size_t\ti;\t\t\t// Looping var\n  _pdfio_pair_t\t*pair;\t\t\t// Current pair\n\n\n  for (i = dict->num_pairs, pair = dict->pairs; i > 0; i --, pair ++)\n  {\n    fprintf(fp, \"/%s\", pair->key);\n    _pdfioValueDebug(&pair->value, fp);\n  }\n}\n\n\n//\n// '_pdfioDictDelete()' - Free the memory used by a dictionary.\n//\n\nvoid\n_pdfioDictDelete(pdfio_dict_t *dict)\t// I - Dictionary\n{\n  if (dict)\n  {\n    size_t\ti;\t\t\t// Looping var\n    _pdfio_pair_t *pair;\t\t// Current pair\n\n    for (i = dict->num_pairs, pair = dict->pairs; i > 0; i --, pair ++)\n    {\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n    }\n\n    free(dict->pairs);\n  }\n\n  free(dict);\n}\n\n\n//\n// 'pdfioDictGetArray()' - Get a key array value from a dictionary.\n//\n\npdfio_array_t *\t\t\t\t// O - Value\npdfioDictGetArray(pdfio_dict_t *dict,\t// I - Dictionary\n                  const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_ARRAY)\n    return (value->value.array);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioDictGetBinary()' - Get a key binary string value from a dictionary.\n//\n\nunsigned char *\t\t\t\t// O - Value\npdfioDictGetBinary(pdfio_dict_t *dict,\t// I - Dictionary\n                   const char   *key,\t// I - Key\n                   size_t       *length)// O - Length of value\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (!length)\n    return (NULL);\n\n  if (value && value->type == PDFIO_VALTYPE_BINARY)\n  {\n    *length = value->value.binary.datalen;\n    return (value->value.binary.data);\n  }\n  else if (value && value->type == PDFIO_VALTYPE_STRING)\n  {\n    *length = strlen(value->value.string);\n    return ((unsigned char *)value->value.string);\n  }\n  else\n  {\n    *length = 0;\n    return (NULL);\n  }\n}\n\n\n//\n// 'pdfioDictGetBoolean()' - Get a key boolean value from a dictionary.\n//\n\nbool\t\t\t\t\t// O - Value\npdfioDictGetBoolean(pdfio_dict_t *dict,\t// I - Dictionary\n                    const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_BOOLEAN)\n    return (value->value.boolean);\n  else\n    return (false);\n}\n\n\n//\n// 'pdfioDictGetDate()' - Get a date value from a dictionary.\n//\n\ntime_t\t\t\t\t\t// O - Value\npdfioDictGetDate(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_DATE)\n    return (value->value.date);\n  else\n    return (0);\n}\n\n\n//\n// 'pdfioDictGetDict()' - Get a key dictionary value from a dictionary.\n//\n\npdfio_dict_t *\t\t\t\t// O - Value\npdfioDictGetDict(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_DICT)\n    return (value->value.dict);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioDictGetName()' - Get a key name value from a dictionary.\n//\n\nconst char *\t\t\t\t// O - Value\npdfioDictGetName(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_NAME)\n    return (value->value.name);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioDictGetNumber()' - Get a key number value from a dictionary.\n//\n\ndouble\t\t\t\t\t// O - Value\npdfioDictGetNumber(pdfio_dict_t *dict,\t// I - Dictionary\n                   const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_NUMBER)\n    return (value->value.number);\n  else\n    return (0.0);\n}\n\n\n//\n// 'pdfioDictGetObj()' - Get a key indirect object value from a dictionary.\n//\n\npdfio_obj_t *\t\t\t\t// O - Value\npdfioDictGetObj(pdfio_dict_t *dict,\t// I - Dictionary\n                const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_INDIRECT)\n    return (pdfioFileFindObj(dict->pdf, value->value.indirect.number));\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioDictGetRect()' - Get a key rectangle value from a dictionary.\n//\n\npdfio_rect_t *\t\t\t\t// O - Rectangle\npdfioDictGetRect(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key,\t// I - Key\n                 pdfio_rect_t *rect)\t// I - Rectangle\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_ARRAY && pdfioArrayGetSize(value->value.array) == 4)\n  {\n    rect->x1 = pdfioArrayGetNumber(value->value.array, 0);\n    rect->y1 = pdfioArrayGetNumber(value->value.array, 1);\n    rect->x2 = pdfioArrayGetNumber(value->value.array, 2);\n    rect->y2 = pdfioArrayGetNumber(value->value.array, 3);\n    return (rect);\n  }\n  else\n  {\n    memset(rect, 0, sizeof(pdfio_rect_t));\n    return (NULL);\n  }\n}\n\n\n//\n// 'pdfioDictGetString()' - Get a key string value from a dictionary.\n//\n\nconst char *\t\t\t\t// O - Value\npdfioDictGetString(pdfio_dict_t *dict,\t// I - Dictionary\n                   const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_STRING)\n    return (value->value.string);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioDictGetType()' - Get a key value type from a dictionary.\n//\n\npdfio_valtype_t\t\t\t\t// O - Value type\npdfioDictGetType(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  return (value ? value->type : PDFIO_VALTYPE_NONE);\n}\n\n\n//\n// '_pdfioDictGetValue()' - Get a key value from a dictionary.\n//\n\n_pdfio_value_t *\t\t\t// O - Value or `NULL` on error\n_pdfioDictGetValue(pdfio_dict_t *dict,\t// I - Dictionary\n                   const char   *key)\t// I - Key\n{\n  _pdfio_pair_t\ttemp,\t\t\t// Search key\n\t\t*match;\t\t\t// Matching key pair\n\n\n  PDFIO_DEBUG(\"_pdfioDictGetValue(dict=%p, key=\\\"%s\\\")\\n\", dict, key);\n\n  if (!dict || !dict->num_pairs || !key)\n  {\n    PDFIO_DEBUG(\"_pdfioDictGetValue: Returning NULL.\\n\");\n    return (NULL);\n  }\n\n  temp.key = key;\n\n  if ((match = bsearch(&temp, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n  {\n    PDFIO_DEBUG(\"_pdfioDictGetValue: Match, returning \");\n    PDFIO_DEBUG_VALUE(&(match->value));\n    PDFIO_DEBUG(\".\\n\");\n    return (&(match->value));\n  }\n  else\n  {\n    PDFIO_DEBUG(\"_pdfioDictGetValue: No match, returning NULL.\\n\");\n    return (NULL);\n  }\n}\n\n\n//\n// 'pdfioDictIterateKeys()' - Iterate the keys in a dictionary.\n//\n// This function iterates the keys in a dictionary, calling the supplied\n// function \"cb\":\n//\n// ```\n// bool\n// my_dict_cb(pdfio_dict_t *dict, const char *key, void *cb_data)\n// {\n// ... \"key\" contains the dictionary key ...\n// ... return true to continue or false to stop ...\n// }\n// ```\n//\n// The iteration continues as long as the callback returns `true` or all keys\n// have been iterated.\n//\n\nvoid\npdfioDictIterateKeys(\n    pdfio_dict_t    *dict,\t\t// I - Dictionary\n    pdfio_dict_cb_t cb,\t\t\t// I - Callback function\n    void            *cb_data)\t\t// I - Callback data\n{\n  size_t\ti;\t\t\t// Looping var\n  _pdfio_pair_t\t*pair;\t\t\t// Current pair\n\n\n  // Range check input...\n  if (!dict || !cb)\n    return;\n\n  for (i = dict->num_pairs, pair = dict->pairs; i > 0; i --, pair ++)\n  {\n    if (!(cb)(dict, pair->key, cb_data))\n      break;\n  }\n}\n\n\n//\n// '_pdfioDictRead()' - Read a dictionary from a PDF file.\n//\n// At this point we've seen the initial \"<<\"...\n//\n\npdfio_dict_t *\t\t\t\t// O - New dictionary\n_pdfioDictRead(pdfio_file_t   *pdf,\t// I - PDF file\n               pdfio_obj_t    *obj,\t// I - Object, if any\n               _pdfio_token_t *tb,\t// I - Token buffer/stack\n               size_t         depth)\t// I - Depth of dictionary\n{\n  pdfio_dict_t\t\t*dict;\t\t// New dictionary\n  char\t\t\tkey[256];\t// Dictionary key\n  _pdfio_value_t\tvalue;\t\t// Dictionary value\n\n\n  PDFIO_DEBUG(\"_pdfioDictRead(pdf=%p)\\n\", pdf);\n\n  // Create a dictionary and start reading...\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n\n  while (_pdfioTokenGet(tb, key, sizeof(key)))\n  {\n    // Get the next key or end-of-dictionary...\n    if (!strcmp(key, \">>\"))\n    {\n      // End of dictionary...\n      return (dict);\n    }\n    else if (key[0] != '/')\n    {\n      _pdfioFileError(pdf, \"Invalid dictionary contents.\");\n      break;\n    }\n\n    // Then get the next value...\n    if (!_pdfioValueRead(pdf, obj, tb, &value, depth))\n    {\n      _pdfioFileError(pdf, \"Missing value for dictionary key.\");\n      break;\n    }\n\n    if (!_pdfioDictSetValue(dict, pdfioStringCreate(pdf, key + 1), &value))\n      break;\n\n//    PDFIO_DEBUG(\"_pdfioDictRead: Set %s.\\n\", key);\n  }\n\n  // Dictionary is invalid - pdfioFileClose will free the memory, return NULL\n  // to indicate an error...\n  return (NULL);\n}\n\n\n//\n// 'pdfioDictSetArray()' - Set a key array in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetArray(pdfio_dict_t  *dict,\t// I - Dictionary\n                  const char    *key,\t// I - Key\n                  pdfio_array_t *value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type        = PDFIO_VALTYPE_ARRAY;\n  temp.value.array = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetBinary()' - Set a key binary string in a dictionary.\n//\n\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetBinary(\n    pdfio_dict_t        *dict,\t\t// I - Dictionary\n    const char          *key,\t\t// I - Key\n    const unsigned char *value,\t\t// I - Value\n    size_t              valuelen)\t// I - Length of value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value || !valuelen)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type                 = PDFIO_VALTYPE_BINARY;\n  temp.value.binary.datalen = valuelen;\n\n  if ((temp.value.binary.data = (unsigned char *)malloc(valuelen)) == NULL)\n    return (false);\n\n  memcpy(temp.value.binary.data, value, valuelen);\n\n  if (!_pdfioDictSetValue(dict, key, &temp))\n  {\n    free(temp.value.binary.data);\n    return (false);\n  }\n\n  return (true);\n}\n\n\n//\n// 'pdfioDictSetBoolean()' - Set a key boolean in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetBoolean(pdfio_dict_t *dict,\t// I - Dictionary\n                    const char   *key,\t// I - Key\n                    bool         value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type          = PDFIO_VALTYPE_BOOLEAN;\n  temp.value.boolean = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetDate()' - Set a date value in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetDate(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key,\t// I - Key\n                 time_t       value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type       = PDFIO_VALTYPE_DATE;\n  temp.value.date = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetDict()' - Set a key dictionary in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetDict(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key,\t// I - Key\n                 pdfio_dict_t *value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type       = PDFIO_VALTYPE_DICT;\n  temp.value.dict = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetName()' - Set a key name in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetName(pdfio_dict_t  *dict,\t// I - Dictionary\n                 const char    *key,\t// I - Key\n                 const char    *value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type       = PDFIO_VALTYPE_NAME;\n  temp.value.name = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetNull()' - Set a key null in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetNull(pdfio_dict_t *dict,\t// I - Dictionary\n\t\t const char   *key)\t// I - Key\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type = PDFIO_VALTYPE_NULL;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetNumber()' - Set a key number in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetNumber(pdfio_dict_t  *dict,\t// I - Dictionary\n                   const char    *key,\t// I - Key\n                   double        value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type         = PDFIO_VALTYPE_NUMBER;\n  temp.value.number = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetObj()' - Set a key indirect object reference in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetObj(pdfio_dict_t *dict,\t// I - Dictionary\n                const char    *key,\t// I - Key\n                pdfio_obj_t   *value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type                      = PDFIO_VALTYPE_INDIRECT;\n  temp.value.indirect.number     = value->number;\n  temp.value.indirect.generation = value->generation;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetRect()' - Set a key rectangle in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetRect(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key,\t// I - Key\n                 pdfio_rect_t *value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type        = PDFIO_VALTYPE_ARRAY;\n  temp.value.array = pdfioArrayCreate(dict->pdf);\n\n  pdfioArrayAppendNumber(temp.value.array, value->x1);\n  pdfioArrayAppendNumber(temp.value.array, value->y1);\n  pdfioArrayAppendNumber(temp.value.array, value->x2);\n  pdfioArrayAppendNumber(temp.value.array, value->y2);\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetString()' - Set a key literal string in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetString(pdfio_dict_t  *dict,\t// I - Dictionary\n                  const char     *key,\t// I - Key\n                  const char     *value)// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type         = PDFIO_VALTYPE_STRING;\n  temp.value.string = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetStringf()' - Set a key formatted string in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetStringf(\n    pdfio_dict_t  *dict,\t\t// I - Dictionary\n    const char    *key,\t\t\t// I - Key\n    const char    *format,\t\t// I - `printf`-style format string\n    ...)\t\t\t\t// I - Additional arguments as needed\n{\n  char\t\tbuffer[8192];\t\t// String buffer\n  va_list\tap;\t\t\t// Argument list\n\n\n  // Range check input...\n  if (!dict || !key || !format)\n    return (false);\n\n  // Set the key/value pair...\n  va_start(ap, format);\n  vsnprintf(buffer, sizeof(buffer), format, ap);\n  va_end(ap);\n\n  return (pdfioDictSetString(dict, key, buffer));\n}\n\n\n//\n// '_pdfioDictSetValue()' - Set a key value in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioDictSetValue(\n    pdfio_dict_t   *dict,\t\t// I - Dictionary\n    const char     *key,\t\t// I - Key\n    _pdfio_value_t *value)\t\t// I - Value\n{\n  _pdfio_pair_t\t*pair;\t\t\t// Current pair\n\n\n  PDFIO_DEBUG(\"_pdfioDictSetValue(dict=%p, key=\\\"%s\\\", value=%p)\\n\", dict, key, (void *)value);\n\n  // See if the key is already set...\n  if (dict->num_pairs > 0)\n  {\n    _pdfio_pair_t\tpkey;\t\t// Search key\n\n    pkey.key = key;\n\n    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n    {\n      // Yes, replace the value...\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Replacing existing value.\\n\");\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n      pair->value = *value;\n      return (true);\n    }\n  }\n\n  // Nope, add a pair...\n  if (dict->num_pairs >= dict->alloc_pairs)\n  {\n    // Expand the dictionary...\n    _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t));\n\n    if (!temp)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Out of memory.\\n\");\n      return (false);\n    }\n\n    dict->pairs       = temp;\n    dict->alloc_pairs += 8;\n  }\n\n  pair = dict->pairs + dict->num_pairs;\n  dict->num_pairs ++;\n\n  pair->key   = key;\n  pair->value = *value;\n\n  // Re-sort the dictionary and return...\n  if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0)\n    qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs);\n\n#ifdef DEBUG\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): %lu pairs\\n\", (void *)dict, (unsigned long)dict->num_pairs);\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n  PDFIO_DEBUG_DICT(dict);\n  PDFIO_DEBUG(\"\\n\");\n#endif // DEBUG\n\n  return (true);\n}\n\n\n//\n// '_pdfioDictWrite()' - Write a dictionary to a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioDictWrite(pdfio_dict_t *dict,\t// I - Dictionary\n\t\tpdfio_obj_t  *obj,\t// I - Object, if any\n                off_t        *length)\t// I - Offset to length value\n{\n  pdfio_file_t\t*pdf = dict->pdf;\t// PDF file\n  size_t\ti;\t\t\t// Looping var\n  _pdfio_pair_t\t*pair;\t\t\t// Current key/value pair\n\n\n  if (length)\n    *length = 0;\n\n  // Dictionaries are bounded by \"<<\" and \">>\"...\n  if (!_pdfioFilePuts(pdf, \"<<\"))\n    return (false);\n\n  // Write all of the key/value pairs...\n  for (i = dict->num_pairs, pair = dict->pairs; i > 0; i --, pair ++)\n  {\n    if (!_pdfioFilePrintf(pdf, \"/%s\", pair->key))\n      return (false);\n\n    if (length && !strcmp(pair->key, \"Length\") && pair->value.type == PDFIO_VALTYPE_NUMBER && pair->value.value.number <= 0.0)\n    {\n      // Writing an object dictionary with an undefined length\n      *length = _pdfioFileTell(pdf) + 1;\n      if (!_pdfioFilePuts(pdf, \" 9999999999\"))\n        return (false);\n    }\n    else if (!_pdfioValueWrite(pdf, obj, &pair->value, NULL))\n      return (false);\n  }\n\n  // Close it up...\n  return (_pdfioFilePuts(pdf, \">>\"));\n}\n\n\n//\n// 'compare_pairs()' - Compare the keys for two pairs.\n//\n\nstatic int\t\t\t\t// O - Result of comparison\ncompare_pairs(_pdfio_pair_t *a,\t\t// I - First pair\n              _pdfio_pair_t *b)\t\t// I - Second pair\n{\n  return (strcmp(a->key, b->key));\n}\n", "//\n// PDF file functions for PDFio.\n//\n// Copyright \u00a9\u00a02021-2022 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n#ifndef O_BINARY\n#  define O_BINARY 0\n#endif // !O_BINARY\n\n\n//\n// Local functions...\n//\n\nstatic pdfio_obj_t\t*add_obj(pdfio_file_t *pdf, size_t number, unsigned short generation, off_t offset);\nstatic int\t\tcompare_objmaps(_pdfio_objmap_t *a, _pdfio_objmap_t *b);\nstatic int\t\tcompare_objs(pdfio_obj_t **a, pdfio_obj_t **b);\nstatic const char\t*get_info_string(pdfio_file_t *pdf, const char *key);\nstatic bool\t\tload_obj_stream(pdfio_obj_t *obj);\nstatic bool\t\tload_pages(pdfio_file_t *pdf, pdfio_obj_t *obj, size_t depth);\nstatic bool\t\tload_xref(pdfio_file_t *pdf, off_t xref_offset, pdfio_password_cb_t password_cb, void *password_data);\nstatic bool\t\twrite_catalog(pdfio_file_t *pdf);\nstatic bool\t\twrite_pages(pdfio_file_t *pdf);\nstatic bool\t\twrite_trailer(pdfio_file_t *pdf);\n\n\n//\n// '_pdfioFileAddMappedObj()' - Add a mapped object.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioFileAddMappedObj(\n    pdfio_file_t *pdf,\t\t\t// I - Destination PDF file\n    pdfio_obj_t  *dst_obj,\t\t// I - Destination object\n    pdfio_obj_t  *src_obj)\t\t// I - Source object\n{\n  _pdfio_objmap_t\t*map;\t\t// Object map\n\n\n  // Allocate memory as needed...\n  if (pdf->num_objmaps >= pdf->alloc_objmaps)\n  {\n    if ((map = realloc(pdf->objmaps, (pdf->alloc_objmaps + 16) * sizeof(_pdfio_objmap_t))) == NULL)\n    {\n      _pdfioFileError(pdf, \"Unable to allocate memory for object map.\");\n      return (false);\n    }\n\n    pdf->alloc_objmaps += 16;\n    pdf->objmaps       = map;\n  }\n\n  // Add an object to the end...\n  map = pdf->objmaps + pdf->num_objmaps;\n  pdf->num_objmaps ++;\n\n  map->obj        = dst_obj;\n  map->src_pdf    = src_obj->pdf;\n  map->src_number = src_obj->number;\n\n  // Sort as needed...\n  if (pdf->num_objmaps > 1 && compare_objmaps(map, pdf->objmaps + pdf->num_objmaps - 2) < 0)\n    qsort(pdf->objmaps, pdf->num_objmaps, sizeof(_pdfio_objmap_t), (int (*)(const void *, const void *))compare_objmaps);\n\n  return (true);\n}\n\n\n//\n// '_pdfioFileAddPage()' - Add a page to a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success and `false` on failure\n_pdfioFileAddPage(pdfio_file_t *pdf,\t// I - PDF file\n                  pdfio_obj_t  *obj)\t// I - Page object\n{\n  // Add the page to the array of pages...\n  if (pdf->num_pages >= pdf->alloc_pages)\n  {\n    pdfio_obj_t **temp = (pdfio_obj_t **)realloc(pdf->pages, (pdf->alloc_pages + 16) * sizeof(pdfio_obj_t *));\n\n    if (!temp)\n    {\n      _pdfioFileError(pdf, \"Unable to allocate memory for pages.\");\n      return (false);\n    }\n\n    pdf->alloc_pages += 16;\n    pdf->pages       = temp;\n  }\n\n  pdf->pages[pdf->num_pages ++] = obj;\n\n  return (true);\n}\n\n\n//\n// 'pdfioFileClose()' - Close a PDF file and free all memory used for it.\n//\n\nbool\t\t\t\t\t// O - `true` on success and `false` on failure\npdfioFileClose(pdfio_file_t *pdf)\t// I - PDF file\n{\n  bool\t\tret = true;\t\t// Return value\n  size_t\ti;\t\t\t// Looping var\n\n\n  // Range check input\n  if (!pdf)\n    return (false);\n\n  // Close the file itself...\n  if (pdf->mode == _PDFIO_MODE_WRITE)\n  {\n    ret = false;\n\n    if (pdfioObjClose(pdf->info_obj))\n      if (write_pages(pdf))\n\tif (write_catalog(pdf))\n\t  if (write_trailer(pdf))\n\t    ret = _pdfioFileFlush(pdf);\n  }\n\n  if (pdf->fd >= 0 && close(pdf->fd) < 0)\n    ret = false;\n\n  // Free all data...\n  free(pdf->filename);\n  free(pdf->version);\n\n  for (i = 0; i < pdf->num_arrays; i ++)\n    _pdfioArrayDelete(pdf->arrays[i]);\n  free(pdf->arrays);\n\n  for (i = 0; i < pdf->num_dicts; i ++)\n    _pdfioDictDelete(pdf->dicts[i]);\n  free(pdf->dicts);\n\n  for (i = 0; i < pdf->num_objs; i ++)\n    _pdfioObjDelete(pdf->objs[i]);\n  free(pdf->objs);\n\n  free(pdf->objmaps);\n\n  free(pdf->pages);\n\n  for (i = 0; i < pdf->num_strings; i ++)\n    free(pdf->strings[i]);\n  free(pdf->strings);\n\n  free(pdf);\n\n  return (ret);\n}\n\n\n//\n// 'pdfioFileCreate()' - Create a PDF file.\n//\n// This function creates a new PDF file.  The \"filename\" argument specifies the\n// name of the PDF file to create.\n//\n// The \"version\" argument specifies the PDF version number for the file or\n// `NULL` for the default (\"2.0\").\n//\n// The \"media_box\" and \"crop_box\" arguments specify the default MediaBox and\n// CropBox for pages in the PDF file - if `NULL` then a default \"Universal\" size\n// of 8.27x11in (the intersection of US Letter and ISO A4) is used.\n//\n// The \"error_cb\" and \"error_data\" arguments specify an error handler callback\n// and its data pointer - if `NULL` the default error handler is used that\n// writes error messages to `stderr`.\n//\n\npdfio_file_t *\t\t\t\t// O - PDF file or `NULL` on error\npdfioFileCreate(\n    const char       *filename,\t\t// I - Filename\n    const char       *version,\t\t// I - PDF version number or `NULL` for default (2.0)\n    pdfio_rect_t     *media_box,\t// I - Default MediaBox for pages\n    pdfio_rect_t     *crop_box,\t\t// I - Default CropBox for pages\n    pdfio_error_cb_t error_cb,\t\t// I - Error callback or `NULL` for default\n    void             *error_data)\t// I - Error callback data, if any\n{\n  pdfio_file_t\t*pdf;\t\t\t// PDF file\n  pdfio_dict_t\t*dict;\t\t\t// Dictionary for pages object\n  pdfio_dict_t\t*info_dict;\t\t// Dictionary for information object\n  unsigned char\tid_value[16];\t\t// File ID value\n\n\n  // Range check input...\n  if (!filename)\n    return (NULL);\n\n  if (!version)\n    version = \"2.0\";\n\n  if (!error_cb)\n  {\n    error_cb   = _pdfioFileDefaultError;\n    error_data = NULL;\n  }\n\n  // Allocate a PDF file structure...\n  if ((pdf = (pdfio_file_t *)calloc(1, sizeof(pdfio_file_t))) == NULL)\n  {\n    pdfio_file_t temp;\t\t\t// Dummy file\n    char\tmessage[8192];\t\t// Message string\n\n    temp.filename = (char *)filename;\n    snprintf(message, sizeof(message), \"Unable to allocate memory for PDF file - %s\", strerror(errno));\n    (error_cb)(&temp, message, error_data);\n    return (NULL);\n  }\n\n  pdf->filename    = strdup(filename);\n  pdf->version     = strdup(version);\n  pdf->mode        = _PDFIO_MODE_WRITE;\n  pdf->error_cb    = error_cb;\n  pdf->error_data  = error_data;\n  pdf->permissions = PDFIO_PERMISSION_ALL;\n  pdf->bufptr      = pdf->buffer;\n  pdf->bufend      = pdf->buffer + sizeof(pdf->buffer);\n\n  if (media_box)\n  {\n    pdf->media_box = *media_box;\n  }\n  else\n  {\n    // Default to \"universal\" size (intersection of A4 and US Letter)\n    pdf->media_box.x2 = 210.0 * 72.0f / 25.4f;\n    pdf->media_box.y2 = 11.0f * 72.0f;\n  }\n\n  if (crop_box)\n  {\n    pdf->crop_box = *crop_box;\n  }\n  else\n  {\n    // Default to \"universal\" size (intersection of A4 and US Letter)\n    pdf->crop_box.x2 = 210.0 * 72.0f / 25.4f;\n    pdf->crop_box.y2 = 11.0f * 72.0f;\n  }\n\n  // Create the file...\n  if ((pdf->fd = open(filename, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, 0666)) < 0)\n  {\n    _pdfioFileError(pdf, \"Unable to create file - %s\", strerror(errno));\n    free(pdf->filename);\n    free(pdf->version);\n    free(pdf);\n    return (NULL);\n  }\n\n  // Write a standard PDF header...\n  if (!_pdfioFilePrintf(pdf, \"%%PDF-%s\\n%%\\342\\343\\317\\323\\n\", version))\n    goto error;\n\n  // Create the pages object...\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    goto error;\n\n  pdfioDictSetName(dict, \"Type\", \"Pages\");\n\n  if ((pdf->pages_obj = pdfioFileCreateObj(pdf, dict)) == NULL)\n    goto error;\n\n  // Create the info object...\n  if ((info_dict = pdfioDictCreate(pdf)) == NULL)\n    goto error;\n\n  pdfioDictSetDate(info_dict, \"CreationDate\", time(NULL));\n  pdfioDictSetString(info_dict, \"Producer\", \"pdfio/\" PDFIO_VERSION);\n\n  if ((pdf->info_obj = pdfioFileCreateObj(pdf, info_dict)) == NULL)\n    goto error;\n\n  // Create random file ID values...\n  _pdfioCryptoMakeRandom(id_value, sizeof(id_value));\n\n  if ((pdf->id_array = pdfioArrayCreate(pdf)) != NULL)\n  {\n    pdfioArrayAppendBinary(pdf->id_array, id_value, sizeof(id_value));\n    pdfioArrayAppendBinary(pdf->id_array, id_value, sizeof(id_value));\n  }\n\n  return (pdf);\n\n  // Common error handling code...\n  error:\n\n  pdfioFileClose(pdf);\n\n  unlink(filename);\n\n  return (NULL);\n}\n\n\n//\n// 'pdfioFileCreateArrayObj()' - Create a new object in a PDF file containing an array.\n//\n// This function creates a new object with an array value in a PDF file.\n// You must call @link pdfioObjClose@ to write the object to the file.\n//\n\npdfio_obj_t *\t\t\t\t// O - New object\npdfioFileCreateArrayObj(\n    pdfio_file_t  *pdf,\t\t\t// I - PDF file\n    pdfio_array_t *array)\t\t// I - Object array\n{\n  _pdfio_value_t\tvalue;\t\t// Object value\n\n\n  // Range check input...\n  if (!pdf || !array)\n    return (NULL);\n\n  value.type        = PDFIO_VALTYPE_ARRAY;\n  value.value.array = array;\n\n  return (_pdfioFileCreateObj(pdf, array->pdf, &value));\n}\n\n\n//\n// 'pdfioFileCreateObj()' - Create a new object in a PDF file.\n//\n\npdfio_obj_t *\t\t\t\t// O - New object\npdfioFileCreateObj(\n    pdfio_file_t *pdf,\t\t\t// I - PDF file\n    pdfio_dict_t *dict)\t\t\t// I - Object dictionary\n{\n  _pdfio_value_t\tvalue;\t\t// Object value\n\n\n  // Range check input...\n  if (!pdf || !dict)\n    return (NULL);\n\n  value.type       = PDFIO_VALTYPE_DICT;\n  value.value.dict = dict;\n\n  return (_pdfioFileCreateObj(pdf, dict->pdf, &value));\n}\n\n\n//\n// '_pdfioFileCreateObj()' - Create a new object in a PDF file with a value.\n//\n\npdfio_obj_t *\t\t\t\t// O - New object\n_pdfioFileCreateObj(\n    pdfio_file_t   *pdf,\t\t// I - PDF file\n    pdfio_file_t   *srcpdf,\t\t// I - Source PDF file, if any\n    _pdfio_value_t *value)\t\t// I - Object dictionary\n{\n  pdfio_obj_t\t*obj;\t\t\t// New object\n\n\n  // Range check input...\n  if (!pdf)\n    return (NULL);\n\n  if (pdf->mode != _PDFIO_MODE_WRITE)\n    return (NULL);\n\n  // Allocate memory for the object...\n  if ((obj = (pdfio_obj_t *)calloc(1, sizeof(pdfio_obj_t))) == NULL)\n  {\n    _pdfioFileError(pdf, \"Unable to allocate memory for object - %s\", strerror(errno));\n    return (NULL);\n  }\n\n  // Expand the objects array as needed\n  if (pdf->num_objs >= pdf->alloc_objs)\n  {\n    pdfio_obj_t **temp = (pdfio_obj_t **)realloc(pdf->objs, (pdf->alloc_objs + 32) * sizeof(pdfio_obj_t *));\n\n    if (!temp)\n    {\n      _pdfioFileError(pdf, \"Unable to allocate memory for object - %s\", strerror(errno));\n      free(obj);\n      return (NULL);\n    }\n\n    pdf->objs       = temp;\n    pdf->alloc_objs += 32;\n  }\n\n  pdf->objs[pdf->num_objs ++] = obj;\n\n  // Initialize the object...\n  obj->pdf    = pdf;\n  obj->number = pdf->num_objs;\n\n  if (value)\n    _pdfioValueCopy(pdf, &obj->value, srcpdf, value);\n\n  // Don't write anything just yet...\n  return (obj);\n}\n\n\n//\n// 'pdfioFileCreateOutput()' - Create a PDF file through an output callback.\n//\n// This function creates a new PDF file that is streamed though an output\n// callback.  The \"output_cb\" and \"output_ctx\" arguments specify the output\n// callback and its context pointer which is called whenever data needs to be\n// written:\n//\n// ```\n// ssize_t\n// output_cb(void *output_ctx, const void *buffer, size_t bytes)\n// {\n//   // Write buffer to output and return the number of bytes written\n// }\n// ```\n//\n// The \"version\" argument specifies the PDF version number for the file or\n// `NULL` for the default (\"2.0\").\n//\n// The \"media_box\" and \"crop_box\" arguments specify the default MediaBox and\n// CropBox for pages in the PDF file - if `NULL` then a default \"Universal\" size\n// of 8.27x11in (the intersection of US Letter and ISO A4) is used.\n//\n// The \"error_cb\" and \"error_data\" arguments specify an error handler callback\n// and its data pointer - if `NULL` the default error handler is used that\n// writes error messages to `stderr`.\n//\n// > *Note*: Files created using this API are slightly larger than those\n// > created using the @link pdfioFileCreate@ function since stream lengths are\n// > stored as indirect object references.\n//\n\npdfio_file_t *\t\t\t\t// O - PDF file or `NULL` on error\npdfioFileCreateOutput(\n    pdfio_output_cb_t output_cb,\t// I - Output callback\n    void              *output_ctx,\t// I - Output context\n    const char        *version,\t\t// I - PDF version number or `NULL` for default (2.0)\n    pdfio_rect_t      *media_box,\t// I - Default MediaBox for pages\n    pdfio_rect_t      *crop_box,\t// I - Default CropBox for pages\n    pdfio_error_cb_t  error_cb,\t\t// I - Error callback or `NULL` for default\n    void              *error_data)\t// I - Error callback data, if any\n{\n  pdfio_file_t\t*pdf;\t\t\t// PDF file\n  pdfio_dict_t\t*dict;\t\t\t// Dictionary for pages object\n  pdfio_dict_t\t*info_dict;\t\t// Dictionary for information object\n  unsigned char\tid_value[16];\t\t// File ID value\n\n\n  // Range check input...\n  if (!output_cb)\n    return (NULL);\n\n  if (!version)\n    version = \"2.0\";\n\n  if (!error_cb)\n  {\n    error_cb   = _pdfioFileDefaultError;\n    error_data = NULL;\n  }\n\n  // Allocate a PDF file structure...\n  if ((pdf = (pdfio_file_t *)calloc(1, sizeof(pdfio_file_t))) == NULL)\n  {\n    pdfio_file_t temp;\t\t\t// Dummy file\n    char\tmessage[8192];\t\t// Message string\n\n    temp.filename = (char *)\"output.pdf\";\n    snprintf(message, sizeof(message), \"Unable to allocate memory for PDF file - %s\", strerror(errno));\n    (error_cb)(&temp, message, error_data);\n    return (NULL);\n  }\n\n  pdf->filename    = strdup(\"output.pdf\");\n  pdf->version     = strdup(version);\n  pdf->mode        = _PDFIO_MODE_WRITE;\n  pdf->error_cb    = error_cb;\n  pdf->error_data  = error_data;\n  pdf->permissions = PDFIO_PERMISSION_ALL;\n  pdf->bufptr      = pdf->buffer;\n  pdf->bufend      = pdf->buffer + sizeof(pdf->buffer);\n\n  if (media_box)\n  {\n    pdf->media_box = *media_box;\n  }\n  else\n  {\n    // Default to \"universal\" size (intersection of A4 and US Letter)\n    pdf->media_box.x2 = 210.0 * 72.0f / 25.4f;\n    pdf->media_box.y2 = 11.0f * 72.0f;\n  }\n\n  if (crop_box)\n  {\n    pdf->crop_box = *crop_box;\n  }\n  else\n  {\n    // Default to \"universal\" size (intersection of A4 and US Letter)\n    pdf->crop_box.x2 = 210.0 * 72.0f / 25.4f;\n    pdf->crop_box.y2 = 11.0f * 72.0f;\n  }\n\n  // Save output callback...\n  pdf->fd         = -1;\n  pdf->output_cb  = output_cb;\n  pdf->output_ctx = output_ctx;\n\n  // Write a standard PDF header...\n  if (!_pdfioFilePrintf(pdf, \"%%PDF-%s\\n%%\\342\\343\\317\\323\\n\", version))\n    goto error;\n\n  // Create the pages object...\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    goto error;\n\n  pdfioDictSetName(dict, \"Type\", \"Pages\");\n\n  if ((pdf->pages_obj = pdfioFileCreateObj(pdf, dict)) == NULL)\n    goto error;\n\n  // Create the info object...\n  if ((info_dict = pdfioDictCreate(pdf)) == NULL)\n    goto error;\n\n  pdfioDictSetDate(info_dict, \"CreationDate\", time(NULL));\n  pdfioDictSetString(info_dict, \"Producer\", \"pdfio/\" PDFIO_VERSION);\n\n  if ((pdf->info_obj = pdfioFileCreateObj(pdf, info_dict)) == NULL)\n    goto error;\n\n  // Create random file ID values...\n  _pdfioCryptoMakeRandom(id_value, sizeof(id_value));\n\n  if ((pdf->id_array = pdfioArrayCreate(pdf)) != NULL)\n  {\n    pdfioArrayAppendBinary(pdf->id_array, id_value, sizeof(id_value));\n    pdfioArrayAppendBinary(pdf->id_array, id_value, sizeof(id_value));\n  }\n\n  return (pdf);\n\n  // Common error handling code...\n  error:\n\n  pdfioFileClose(pdf);\n\n  return (NULL);\n}\n\n\n//\n// 'pdfioFileCreatePage()' - Create a page in a PDF file.\n//\n\npdfio_stream_t *\t\t\t// O - Contents stream\npdfioFileCreatePage(pdfio_file_t *pdf,\t// I - PDF file\n                    pdfio_dict_t *dict)\t// I - Page dictionary\n{\n  pdfio_obj_t\t*page,\t\t\t// Page object\n\t\t*contents;\t\t// Contents object\n  pdfio_dict_t\t*contents_dict;\t\t// Dictionary for Contents object\n\n\n  // Range check input...\n  if (!pdf)\n    return (NULL);\n\n  // Copy the page dictionary...\n  if (dict)\n    dict = pdfioDictCopy(pdf, dict);\n  else\n    dict = pdfioDictCreate(pdf);\n\n  if (!dict)\n    return (NULL);\n\n  // Make sure the page dictionary has all of the required keys...\n  if (!_pdfioDictGetValue(dict, \"CropBox\"))\n    pdfioDictSetRect(dict, \"CropBox\", &pdf->crop_box);\n\n  if (!_pdfioDictGetValue(dict, \"MediaBox\"))\n    pdfioDictSetRect(dict, \"MediaBox\", &pdf->media_box);\n\n  pdfioDictSetObj(dict, \"Parent\", pdf->pages_obj);\n\n  if (!_pdfioDictGetValue(dict, \"Resources\"))\n    pdfioDictSetDict(dict, \"Resources\", pdfioDictCreate(pdf));\n\n  if (!_pdfioDictGetValue(dict, \"Type\"))\n    pdfioDictSetName(dict, \"Type\", \"Page\");\n\n  // Create the page object...\n  if ((page = pdfioFileCreateObj(pdf, dict)) == NULL)\n    return (NULL);\n\n  // Create a contents object to hold the contents of the page...\n  if ((contents_dict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n\n#ifndef DEBUG\n  pdfioDictSetName(contents_dict, \"Filter\", \"FlateDecode\");\n#endif // !DEBUG\n\n  if ((contents = pdfioFileCreateObj(pdf, contents_dict)) == NULL)\n    return (NULL);\n\n  // Add the contents stream to the pages object and write it...\n  pdfioDictSetObj(dict, \"Contents\", contents);\n  if (!pdfioObjClose(page))\n    return (NULL);\n\n  if (!_pdfioFileAddPage(pdf, page))\n    return (NULL);\n\n  // Create the contents stream...\n#ifdef DEBUG\n  return (pdfioObjCreateStream(contents, PDFIO_FILTER_NONE));\n#else\n  return (pdfioObjCreateStream(contents, PDFIO_FILTER_FLATE));\n#endif // DEBUG\n}\n\n\n//\n// 'pdfioFileCreateTemporary()' - Create a temporary PDF file.\n//\n// This function creates a PDF file with a unique filename in the current\n// temporary directory.  The temporary file is stored in the string \"buffer\" an\n// will have a \".pdf\" extension.  Otherwise, this function works the same as\n// the @link pdfioFileCreate@ function.\n//\n// @since PDFio v1.1@\n//\n\npdfio_file_t *\npdfioFileCreateTemporary(\n    char             *buffer,\t\t// I - Filename buffer\n    size_t           bufsize,\t\t// I - Size of filename buffer\n    const char       *version,\t\t// I - PDF version number or `NULL` for default (2.0)\n    pdfio_rect_t     *media_box,\t// I - Default MediaBox for pages\n    pdfio_rect_t     *crop_box,\t\t// I - Default CropBox for pages\n    pdfio_error_cb_t error_cb,\t\t// I - Error callback or `NULL` for default\n    void             *error_data)\t// I - Error callback data, if any\n{\n  pdfio_file_t\t*pdf;\t\t\t// PDF file\n  pdfio_dict_t\t*dict;\t\t\t// Dictionary for pages object\n  pdfio_dict_t\t*info_dict;\t\t// Dictionary for information object\n  unsigned char\tid_value[16];\t\t// File ID value\n  int\t\ti;\t\t\t// Looping var\n  const char\t*tmpdir;\t\t// Temporary directory\n#if _WIN32 || defined(__APPLE__)\n  char\t\ttmppath[256];\t\t// Temporary directory path\n#endif // _WIN32 || __APPLE__\n  unsigned\ttmpnum;\t\t\t// Temporary filename number\n\n\n  // Range check input...\n  if (!buffer || bufsize < 32)\n  {\n    if (buffer)\n      *buffer = '\\0';\n    return (NULL);\n  }\n\n  if (!version)\n    version = \"2.0\";\n\n  if (!error_cb)\n  {\n    error_cb   = _pdfioFileDefaultError;\n    error_data = NULL;\n  }\n\n  // Allocate a PDF file structure...\n  if ((pdf = (pdfio_file_t *)calloc(1, sizeof(pdfio_file_t))) == NULL)\n  {\n    pdfio_file_t temp;\t\t\t// Dummy file\n    char\tmessage[8192];\t\t// Message string\n\n    temp.filename = (char *)\"temporary.pdf\";\n    snprintf(message, sizeof(message), \"Unable to allocate memory for PDF file - %s\", strerror(errno));\n    (error_cb)(&temp, message, error_data);\n\n    *buffer = '\\0';\n\n    return (NULL);\n  }\n\n  // Create the file...\n#if _WIN32\n  if ((tmpdir = getenv(\"TEMP\")) == NULL)\n  {\n    GetTempPathA(sizeof(tmppath), tmppath);\n    tmpdir = tmppath;\n  }\n\n#elif defined(__APPLE__)\n  if ((tmpdir = getenv(\"TMPDIR\")) != NULL && access(tmpdir, W_OK))\n    tmpdir = NULL;\n\n  if (!tmpdir)\n  {\n    // Grab the per-process temporary directory for sandboxed apps...\n#  ifdef _CS_DARWIN_USER_TEMP_DIR\n    if (confstr(_CS_DARWIN_USER_TEMP_DIR, tmppath, sizeof(tmppath)))\n      tmpdir = tmppath;\n    else\n#  endif // _CS_DARWIN_USER_TEMP_DIR\n      tmpdir = \"/private/tmp\";\n  }\n\n#else\n  if ((tmpdir = getenv(\"TMPDIR\")) == NULL || access(tmpdir, W_OK))\n    tmpdir = \"/tmp\";\n#endif // _WIN32\n\n  for (i = 0; i < 1000; i ++)\n  {\n    _pdfioCryptoMakeRandom((uint8_t *)&tmpnum, sizeof(tmpnum));\n    snprintf(buffer, bufsize, \"%s/%08x.pdf\", tmpdir, tmpnum);\n    if ((pdf->fd = open(buffer, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC | O_EXCL, 0666)) >= 0)\n      break;\n  }\n\n  pdf->filename = strdup(buffer);\n\n  if (i >= 1000)\n  {\n    _pdfioFileError(pdf, \"Unable to create file - %s\", strerror(errno));\n    free(pdf->filename);\n    free(pdf);\n    *buffer = '\\0';\n    return (NULL);\n  }\n\n  pdf->version     = strdup(version);\n  pdf->mode        = _PDFIO_MODE_WRITE;\n  pdf->error_cb    = error_cb;\n  pdf->error_data  = error_data;\n  pdf->permissions = PDFIO_PERMISSION_ALL;\n  pdf->bufptr      = pdf->buffer;\n  pdf->bufend      = pdf->buffer + sizeof(pdf->buffer);\n\n  if (media_box)\n  {\n    pdf->media_box = *media_box;\n  }\n  else\n  {\n    // Default to \"universal\" size (intersection of A4 and US Letter)\n    pdf->media_box.x2 = 210.0 * 72.0f / 25.4f;\n    pdf->media_box.y2 = 11.0f * 72.0f;\n  }\n\n  if (crop_box)\n  {\n    pdf->crop_box = *crop_box;\n  }\n  else\n  {\n    // Default to \"universal\" size (intersection of A4 and US Letter)\n    pdf->crop_box.x2 = 210.0 * 72.0f / 25.4f;\n    pdf->crop_box.y2 = 11.0f * 72.0f;\n  }\n\n  // Write a standard PDF header...\n  if (!_pdfioFilePrintf(pdf, \"%%PDF-%s\\n%%\\342\\343\\317\\323\\n\", version))\n    goto error;\n\n  // Create the pages object...\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    goto error;\n\n  pdfioDictSetName(dict, \"Type\", \"Pages\");\n\n  if ((pdf->pages_obj = pdfioFileCreateObj(pdf, dict)) == NULL)\n    goto error;\n\n  // Create the info object...\n  if ((info_dict = pdfioDictCreate(pdf)) == NULL)\n    goto error;\n\n  pdfioDictSetDate(info_dict, \"CreationDate\", time(NULL));\n  pdfioDictSetString(info_dict, \"Producer\", \"pdfio/\" PDFIO_VERSION);\n\n  if ((pdf->info_obj = pdfioFileCreateObj(pdf, info_dict)) == NULL)\n    goto error;\n\n  // Create random file ID values...\n  _pdfioCryptoMakeRandom(id_value, sizeof(id_value));\n\n  if ((pdf->id_array = pdfioArrayCreate(pdf)) != NULL)\n  {\n    pdfioArrayAppendBinary(pdf->id_array, id_value, sizeof(id_value));\n    pdfioArrayAppendBinary(pdf->id_array, id_value, sizeof(id_value));\n  }\n\n  return (pdf);\n\n  // Common error handling code...\n  error:\n\n  pdfioFileClose(pdf);\n\n  unlink(buffer);\n  *buffer = '\\0';\n\n  return (NULL);\n}\n\n\n//\n// '_pdfioFileFindMappedObj()' - Find a mapped object.\n//\n\npdfio_obj_t *\t\t\t\t// O - Match object or `NULL` if none\n_pdfioFileFindMappedObj(\n    pdfio_file_t *pdf,\t\t\t// I - Destination PDF file\n    pdfio_file_t *src_pdf,\t\t// I - Source PDF file\n    size_t       src_number)\t\t// I - Source object number\n{\n  _pdfio_objmap_t\tkey,\t\t// Search key\n\t\t\t*match;\t\t// Matching object map\n\n\n  // If we have no mapped objects, return NULL immediately...\n  if (pdf->num_objmaps == 0)\n    return (NULL);\n\n  // Otherwise search for a match...\n  key.src_pdf    = src_pdf;\n  key.src_number = src_number;\n\n  if ((match = (_pdfio_objmap_t *)bsearch(&key, pdf->objmaps, pdf->num_objmaps, sizeof(_pdfio_objmap_t), (int (*)(const void *, const void *))compare_objmaps)) != NULL)\n    return (match->obj);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioFileFindObj()' - Find an object using its object number.\n//\n// This differs from @link pdfioFileGetObj@ which takes an index into the\n// list of objects while this function takes the object number.\n//\n\npdfio_obj_t *\t\t\t\t// O - Object or `NULL` if not found\npdfioFileFindObj(\n    pdfio_file_t *pdf,\t\t\t// I - PDF file\n    size_t       number)\t\t// I - Object number (1 to N)\n{\n  pdfio_obj_t\tkey,\t\t\t// Search key\n\t\t*keyptr,\t\t// Pointer to key\n\t\t**match;\t\t// Pointer to match\n\n\n  if (pdf->num_objs > 0)\n  {\n    key.number = number;\n    keyptr     = &key;\n    match      = (pdfio_obj_t **)bsearch(&keyptr, pdf->objs, pdf->num_objs, sizeof(pdfio_obj_t *), (int (*)(const void *, const void *))compare_objs);\n\n    return (match ? *match : NULL);\n  }\n\n  return (NULL);\n}\n\n\n//\n// 'pdfioFileGetAuthor()' - Get the author for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Author or `NULL` for none\npdfioFileGetAuthor(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (get_info_string(pdf, \"Author\"));\n}\n\n\n//\n// 'pdfioFileGetCreationDate()' - Get the creation date for a PDF file.\n//\n\ntime_t\t\t\t\t\t// O - Creation date or `0` for none\npdfioFileGetCreationDate(\n    pdfio_file_t *pdf)\t\t\t// I - PDF file\n{\n  return (pdf && pdf->info_obj ? pdfioDictGetDate(pdfioObjGetDict(pdf->info_obj), \"CreationDate\") : 0);\n}\n\n\n//\n// 'pdfioFileGetCreator()' - Get the creator string for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Creator string or `NULL` for none\npdfioFileGetCreator(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (get_info_string(pdf, \"Creator\"));\n}\n\n\n//\n// 'pdfioFileGetID()' - Get the PDF file's ID strings.\n//\n\npdfio_array_t *\t\t\t\t// O - Array with binary strings\npdfioFileGetID(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (pdf ? pdf->id_array : NULL);\n}\n\n\n//\n// 'pdfioFileGetKeywords()' - Get the keywords for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Keywords string or `NULL` for none\npdfioFileGetKeywords(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (get_info_string(pdf, \"Keywords\"));\n}\n\n\n//\n// 'pdfioFileGetName()' - Get a PDF's filename.\n//\n\nconst char *\t\t\t\t// O - Filename\npdfioFileGetName(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (pdf ? pdf->filename : NULL);\n}\n\n\n//\n// 'pdfioFileGetNumObjs()' - Get the number of objects in a PDF file.\n//\n\nsize_t\t\t\t\t\t// O - Number of objects\npdfioFileGetNumObjs(\n    pdfio_file_t *pdf)\t\t\t// I - PDF file\n{\n  return (pdf ? pdf->num_objs : 0);\n}\n\n\n//\n// 'pdfioFileGetNumPages()' - Get the number of pages in a PDF file.\n//\n\nsize_t\t\t\t\t\t// O - Number of pages\npdfioFileGetNumPages(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (pdf ? pdf->num_pages : 0);\n}\n\n\n//\n// 'pdfioFileGetObj()' - Get an object from a PDF file.\n//\n\npdfio_obj_t *\t\t\t\t// O - Object\npdfioFileGetObj(pdfio_file_t *pdf,\t// I - PDF file\n                size_t       n)\t\t// I - Object index (starting at 0)\n{\n  if (!pdf || n >= pdf->num_objs)\n    return (NULL);\n  else\n    return (pdf->objs[n]);\n}\n\n\n//\n// 'pdfioFileGetPage()' - Get a page object from a PDF file.\n//\n\npdfio_obj_t *\t\t\t\t// O - Object\npdfioFileGetPage(pdfio_file_t *pdf,\t// I - PDF file\n                 size_t       n)\t// I - Page index (starting at 0)\n{\n  if (!pdf || n >= pdf->num_pages)\n    return (NULL);\n  else\n    return (pdf->pages[n]);\n}\n\n\n//\n// 'pdfioFileGetPermissions()' - Get the access permissions of a PDF file.\n//\n// This function returns the access permissions of a PDF file and (optionally)\n// the type of encryption that has been used.\n//\n\npdfio_permission_t\t\t\t// O - Permission bits\npdfioFileGetPermissions(\n    pdfio_file_t       *pdf,\t\t// I - PDF file\n    pdfio_encryption_t *encryption)\t// O - Type of encryption used or `NULL` to ignore\n{\n  // Range check input...\n  if (!pdf)\n  {\n    if (encryption)\n      *encryption = PDFIO_ENCRYPTION_NONE;\n\n    return (PDFIO_PERMISSION_ALL);\n  }\n\n  // Return values...\n  if (encryption)\n    *encryption = pdf->encryption;\n\n  return (pdf->permissions);\n}\n\n\n//\n// 'pdfioFileGetProducer()' - Get the producer string for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Producer string or `NULL` for none\npdfioFileGetProducer(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (get_info_string(pdf, \"Producer\"));\n}\n\n\n//\n// 'pdfioFileGetSubject()' - Get the subject for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Subject or `NULL` for none\npdfioFileGetSubject(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (get_info_string(pdf, \"Subject\"));\n}\n\n\n//\n// 'pdfioFileGetTitle()' - Get the title for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Title or `NULL` for none\npdfioFileGetTitle(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (get_info_string(pdf, \"Title\"));\n}\n\n\n//\n// 'pdfioFileGetVersion()' - Get the PDF version number for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Version number or `NULL`\npdfioFileGetVersion(\n    pdfio_file_t *pdf)\t\t\t// I - PDF file\n{\n  return (pdf ? pdf->version : NULL);\n}\n\n\n//\n// 'pdfioFileOpen()' - Open a PDF file for reading.\n//\n// This function opens an existing PDF file.  The \"filename\" argument specifies\n// the name of the PDF file to create.\n//\n// The \"password_cb\" and \"password_data\" arguments specify a password callback\n// and its data pointer for PDF files that use one of the standard Adobe\n// \"security\" handlers.  The callback returns a password string or `NULL` to\n// cancel the open.  If `NULL` is specified for the callback function and the\n// PDF file requires a password, the open will always fail.\n//\n// The \"error_cb\" and \"error_data\" arguments specify an error handler callback\n// and its data pointer - if `NULL` the default error handler is used that\n// writes error messages to `stderr`.\n//\n\npdfio_file_t *\t\t\t\t// O - PDF file\npdfioFileOpen(\n    const char          *filename,\t// I - Filename\n    pdfio_password_cb_t password_cb,\t// I - Password callback or `NULL` for none\n    void                *password_data,\t// I - Password callback data, if any\n    pdfio_error_cb_t    error_cb,\t// I - Error callback or `NULL` for default\n    void                *error_data)\t// I - Error callback data, if any\n{\n  pdfio_file_t\t*pdf;\t\t\t// PDF file\n  char\t\tline[1024],\t\t// Line from file\n\t\t*ptr;\t\t\t// Pointer into line\n  off_t\t\txref_offset;\t\t// Offset to xref table\n\n\n  // Range check input...\n  if (!filename)\n    return (NULL);\n\n  if (!error_cb)\n  {\n    error_cb   = _pdfioFileDefaultError;\n    error_data = NULL;\n  }\n\n  // Allocate a PDF file structure...\n  if ((pdf = (pdfio_file_t *)calloc(1, sizeof(pdfio_file_t))) == NULL)\n  {\n    pdfio_file_t temp;\t\t\t// Dummy file\n    char\tmessage[8192];\t\t// Message string\n\n    temp.filename = (char *)filename;\n    snprintf(message, sizeof(message), \"Unable to allocate memory for PDF file - %s\", strerror(errno));\n    (error_cb)(&temp, message, error_data);\n    return (NULL);\n  }\n\n  pdf->filename    = strdup(filename);\n  pdf->mode        = _PDFIO_MODE_READ;\n  pdf->error_cb    = error_cb;\n  pdf->error_data  = error_data;\n  pdf->permissions = PDFIO_PERMISSION_ALL;\n\n  // Open the file...\n  if ((pdf->fd = open(filename, O_RDONLY | O_BINARY)) < 0)\n  {\n    _pdfioFileError(pdf, \"Unable to open file - %s\", strerror(errno));\n    free(pdf->filename);\n    free(pdf);\n    return (NULL);\n  }\n\n  // Read the header from the first line...\n  if (!_pdfioFileGets(pdf, line, sizeof(line)))\n    goto error;\n\n  if ((strncmp(line, \"%PDF-1.\", 7) && strncmp(line, \"%PDF-2.\", 7)) || !isdigit(line[7] & 255))\n  {\n    // Bad header\n    _pdfioFileError(pdf, \"Bad header '%s'.\", line);\n    goto error;\n  }\n\n  // Copy the version number...\n  pdf->version = strdup(line + 5);\n\n  // Grab the last 32 characters of the file to find the start of the xref table...\n  if (_pdfioFileSeek(pdf, -32, SEEK_END) < 0)\n  {\n    _pdfioFileError(pdf, \"Unable to read startxref data.\");\n    goto error;\n  }\n\n  if (_pdfioFileRead(pdf, line, 32) < 32)\n  {\n    _pdfioFileError(pdf, \"Unable to read startxref data.\");\n    goto error;\n  }\n  line[32] = '\\0';\n\n  if ((ptr = strstr(line, \"startxref\")) == NULL)\n  {\n    _pdfioFileError(pdf, \"Unable to find start of xref table.\");\n    goto error;\n  }\n\n  xref_offset = (off_t)strtol(ptr + 9, NULL, 10);\n\n  if (!load_xref(pdf, xref_offset, password_cb, password_data))\n    goto error;\n\n  return (pdf);\n\n\n  // If we get here we had a fatal read error...\n  error:\n\n  pdfioFileClose(pdf);\n\n  return (NULL);\n}\n\n\n//\n// 'pdfioFileSetAuthor()' - Set the author for a PDF file.\n//\n\nvoid\npdfioFileSetAuthor(pdfio_file_t *pdf,\t// I - PDF file\n                   const char   *value)\t// I - Value\n{\n  if (pdf && pdf->info_obj)\n    pdfioDictSetString(pdf->info_obj->value.value.dict, \"Author\", pdfioStringCreate(pdf, value));\n}\n\n\n//\n// 'pdfioFileSetCreationDate()' - Set the creation date for a PDF file.\n//\n\nvoid\npdfioFileSetCreationDate(\n    pdfio_file_t *pdf,\t\t\t// I - PDF file\n    time_t       value)\t\t\t// I - Value\n{\n  if (pdf && pdf->info_obj)\n    pdfioDictSetDate(pdf->info_obj->value.value.dict, \"CreationDate\", value);\n}\n\n\n//\n// 'pdfioFileSetCreator()' - Set the creator string for a PDF file.\n//\n\nvoid\npdfioFileSetCreator(pdfio_file_t *pdf,\t// I - PDF file\n                    const char   *value)// I - Value\n{\n  if (pdf && pdf->info_obj)\n    pdfioDictSetString(pdf->info_obj->value.value.dict, \"Creator\", pdfioStringCreate(pdf, value));\n}\n\n\n//\n// 'pdfioFileSetKeywords()' - Set the keywords string for a PDF file.\n//\n\nvoid\npdfioFileSetKeywords(\n    pdfio_file_t *pdf,\t\t\t// I - PDF file\n    const char   *value)\t\t// I - Value\n{\n  if (pdf && pdf->info_obj)\n    pdfioDictSetString(pdf->info_obj->value.value.dict, \"Keywords\", pdfioStringCreate(pdf, value));\n}\n\n\n//\n// 'pdfioFileSetPermissions()' - Set the PDF permissions, encryption mode, and passwords.\n//\n// This function sets the PDF usage permissions, encryption mode, and\n// passwords.\n//\n// > *Note*: This function must be called before creating or copying any\n// > objects.  Due to fundamental limitations in the PDF format, PDF encryption\n// > offers little protection from disclosure.  Permissions are not enforced in\n// > any meaningful way.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` otherwise\npdfioFileSetPermissions(\n    pdfio_file_t       *pdf,\t\t// I - PDF file\n    pdfio_permission_t permissions,\t// I - Use permissions\n    pdfio_encryption_t encryption,\t// I - Type of encryption to use\n    const char         *owner_password,\t// I - Owner password, if any\n    const char         *user_password)\t// I - User password, if any\n{\n  if (!pdf)\n    return (false);\n\n  if (pdf->num_objs > 2)\t\t// First two objects are pages and info\n  {\n    _pdfioFileError(pdf, \"You must call pdfioFileSetPermissions before adding any objects.\");\n    return (false);\n  }\n\n  if (encryption == PDFIO_ENCRYPTION_NONE)\n    return (true);\n\n  return (_pdfioCryptoLock(pdf, permissions, encryption, owner_password, user_password));\n}\n\n\n//\n// 'pdfioFileSetSubject()' - Set the subject for a PDF file.\n//\n\nvoid\npdfioFileSetSubject(\n    pdfio_file_t *pdf,\t\t\t// I - PDF file\n    const char   *value)\t\t// I - Value\n{\n  if (pdf && pdf->info_obj)\n    pdfioDictSetString(pdf->info_obj->value.value.dict, \"Subject\", pdfioStringCreate(pdf, value));\n}\n\n\n//\n// 'pdfioFileSetTitle()' - Set the title for a PDF file.\n//\n\nvoid\npdfioFileSetTitle(pdfio_file_t *pdf,\t// I - PDF file\n                  const char   *value)\t// I - Value\n{\n  if (pdf && pdf->info_obj)\n    pdfioDictSetString(pdf->info_obj->value.value.dict, \"Title\", pdfioStringCreate(pdf, value));\n}\n\n\n//\n// '_pdfioObjAdd()' - Add an object to a file.\n//\n\nstatic pdfio_obj_t *\t\t\t// O - Object\nadd_obj(pdfio_file_t   *pdf,\t\t// I - PDF file\n\tsize_t         number,\t\t// I - Object number\n\tunsigned short generation,\t// I - Object generation\n\toff_t          offset)\t\t// I - Offset in file\n{\n  pdfio_obj_t\t*obj;\t\t\t// Object\n\n\n  // Allocate memory for the object...\n  if ((obj = (pdfio_obj_t *)calloc(1, sizeof(pdfio_obj_t))) == NULL)\n  {\n    _pdfioFileError(pdf, \"Unable to allocate memory for object - %s\", strerror(errno));\n    return (NULL);\n  }\n\n  // Expand the objects array as needed\n  if (pdf->num_objs >= pdf->alloc_objs)\n  {\n    pdfio_obj_t **temp = (pdfio_obj_t **)realloc(pdf->objs, (pdf->alloc_objs + 32) * sizeof(pdfio_obj_t *));\n\n    if (!temp)\n    {\n      _pdfioFileError(pdf, \"Unable to allocate memory for object - %s\", strerror(errno));\n      free(obj);\n      return (NULL);\n    }\n\n    pdf->objs       = temp;\n    pdf->alloc_objs += 32;\n  }\n\n  pdf->objs[pdf->num_objs ++] = obj;\n\n  obj->pdf        = pdf;\n  obj->number     = number;\n  obj->generation = generation;\n  obj->offset     = offset;\n\n  PDFIO_DEBUG(\"add_obj: obj=%p, ->pdf=%p, ->number=%lu\\n\", obj, pdf, (unsigned long)obj->number);\n\n  // Re-sort object array as needed...\n  if (pdf->num_objs > 1 && pdf->objs[pdf->num_objs - 2]->number > number)\n    qsort(pdf->objs, pdf->num_objs, sizeof(pdfio_obj_t *), (int (*)(const void *, const void *))compare_objs);\n\n  return (obj);\n}\n\n\n//\n// 'compare_objmaps()' - Compare two object maps...\n//\n\nstatic int\t\t\t\t// O - Result of comparison\ncompare_objmaps(_pdfio_objmap_t *a,\t// I - First object map\n                _pdfio_objmap_t *b)\t// I - Second object map\n{\n  if (a->src_pdf < b->src_pdf)\n    return (-1);\n  else if (a->src_pdf > b->src_pdf)\n    return (1);\n  else if (a->src_number < b->src_number)\n    return (-1);\n  else if (a->src_number > b->src_number)\n    return (1);\n  else\n    return (0);\n}\n\n\n//\n// 'compare_objs()' - Compare the object numbers of two objects.\n//\n\nstatic int\t\t\t\t// O - Result of comparison\ncompare_objs(pdfio_obj_t **a,\t\t// I - First object\n             pdfio_obj_t **b)\t\t// I - Second object\n{\n  if ((*a)->number < (*b)->number)\n    return (-1);\n  else if ((*a)->number == (*b)->number)\n    return (0);\n  else\n    return (1);\n}\n\n\n//\n// 'get_info_string()' - Get a string value from the Info dictionary.\n//\n// This function also handles converting binary strings to C strings, which\n// occur in encrypted PDF files.\n//\n\nstatic const char *\t\t\t// O - String or `NULL` if not found\nget_info_string(pdfio_file_t *pdf,\t// I - PDF file\n                const char   *key)\t// I - Dictionary key\n{\n  pdfio_dict_t\t*dict;\t\t\t// Info dictionary\n  _pdfio_value_t *value;\t\t// Value\n\n  // Range check input...\n  if (!pdf || !pdf->info_obj || (dict = pdfioObjGetDict(pdf->info_obj)) == NULL || (value = _pdfioDictGetValue(dict, key)) == NULL)\n    return (NULL);\n\n  // If we already have a value, return it...\n  if (value->type == PDFIO_VALTYPE_NAME || value->type == PDFIO_VALTYPE_STRING)\n  {\n    return (value->value.string);\n  }\n  else if (value->type == PDFIO_VALTYPE_BINARY && value->value.binary.datalen < 4096)\n  {\n    // Convert binary string to regular string...\n    char\ttemp[4096];\t\t// Temporary string\n\n    memcpy(temp, value->value.binary.data, value->value.binary.datalen);\n    temp[value->value.binary.datalen] = '\\0';\n\n    free(value->value.binary.data);\n    value->type         = PDFIO_VALTYPE_STRING;\n    value->value.string = pdfioStringCreate(pdf, temp);\n\n    return (value->value.string);\n  }\n  else\n  {\n    // Something else that is not a string...\n    return (NULL);\n  }\n}\n\n\n//\n// 'load_obj_stream()' - Load an object stream.\n//\n// Object streams are Adobe's complicated solution for saving a few\n// kilobytes in an average PDF file at the expense of massively more\n// complicated reader applications.\n//\n// Each object stream starts with pairs of object numbers and offsets,\n// followed by the object values (typically dictionaries).  For\n// simplicity pdfio loads all of these values into memory so that we\n// don't later have to randomly access compressed stream data to get\n// a dictionary.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on error\nload_obj_stream(pdfio_obj_t *obj)\t// I - Object to load\n{\n  pdfio_stream_t\t*st;\t\t// Stream\n  _pdfio_token_t\ttb;\t\t// Token buffer/stack\n  char\t\t\tbuffer[32];\t// Token\n  size_t\t\tnumber,\t\t// Object number\n\t\t\tcur_obj,\t// Current object\n\t\t\tnum_objs = 0;\t// Number of objects\n  pdfio_obj_t\t\t*objs[16384];\t// Objects\n\n\n  PDFIO_DEBUG(\"load_obj_stream(obj=%p(%d))\\n\", obj, (int)obj->number);\n\n  // Open the object stream...\n  if ((st = pdfioObjOpenStream(obj, true)) == NULL)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to open compressed object stream %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  _pdfioTokenInit(&tb, obj->pdf, (_pdfio_tconsume_cb_t)pdfioStreamConsume, (_pdfio_tpeek_cb_t)pdfioStreamPeek, st);\n\n  // Read the object numbers from the beginning of the stream...\n  while (_pdfioTokenGet(&tb, buffer, sizeof(buffer)))\n  {\n    // Stop if this isn't an object number...\n    if (!isdigit(buffer[0] & 255))\n      break;\n\n    // Stop if we have too many objects...\n    if (num_objs >= (sizeof(objs) / sizeof(objs[0])))\n    {\n      _pdfioFileError(obj->pdf, \"Too many compressed objects in one stream.\");\n      pdfioStreamClose(st);\n      return (false);\n    }\n\n    // Add the object in memory...\n    number = (size_t)strtoimax(buffer, NULL, 10);\n\n    if ((objs[num_objs] = pdfioFileFindObj(obj->pdf, number)) == NULL)\n      objs[num_objs] = add_obj(obj->pdf, number, 0, 0);\n\n    num_objs ++;\n\n    // Skip offset\n    _pdfioTokenGet(&tb, buffer, sizeof(buffer));\n  }\n\n  if (!buffer[0])\n  {\n    pdfioStreamClose(st);\n    return (false);\n  }\n\n  _pdfioTokenPush(&tb, buffer);\n\n  // Read the objects themselves...\n  for (cur_obj = 0; cur_obj < num_objs; cur_obj ++)\n  {\n    if (!_pdfioValueRead(obj->pdf, obj, &tb, &(objs[cur_obj]->value), 0))\n    {\n      pdfioStreamClose(st);\n      return (false);\n    }\n  }\n\n  // Close the stream and return\n  pdfioStreamClose(st);\n\n  return (true);\n}\n\n\n//\n// 'load_pages()' - Load pages in the document.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on error\nload_pages(pdfio_file_t *pdf,\t\t// I - PDF file\n           pdfio_obj_t  *obj,\t\t// I - Page object\n           size_t       depth)\t\t// I - Depth of page tree\n{\n  pdfio_dict_t\t*dict;\t\t\t// Page object dictionary\n  const char\t*type;\t\t\t// Node type\n  pdfio_array_t\t*kids;\t\t\t// Kids array\n\n\n  // Range check input...\n  if (!obj)\n  {\n    _pdfioFileError(pdf, \"Unable to find pages object.\");\n    return (false);\n  }\n\n  // Get the object dictionary and make sure this is a Pages or Page object...\n  if ((dict = pdfioObjGetDict(obj)) == NULL)\n  {\n    _pdfioFileError(pdf, \"No dictionary for pages object.\");\n    return (false);\n  }\n\n  if ((type = pdfioDictGetName(dict, \"Type\")) == NULL || (strcmp(type, \"Pages\") && strcmp(type, \"Page\")))\n    return (false);\n\n  // If there is a Kids array, then this is a parent node and we have to look\n  // at the child objects...\n  if ((kids = pdfioDictGetArray(dict, \"Kids\")) != NULL)\n  {\n    // Load the child objects...\n    size_t\ti,\t\t\t// Looping var\n\t\tnum_kids;\t\t// Number of elements in array\n\n    if (depth >= PDFIO_MAX_DEPTH)\n    {\n      _pdfioFileError(pdf, \"Depth of pages objects too great to load.\");\n      return (false);\n    }\n\n    for (i = 0, num_kids = pdfioArrayGetSize(kids); i < num_kids; i ++)\n    {\n      if (!load_pages(pdf, pdfioArrayGetObj(kids, i), depth + 1))\n        return (false);\n    }\n  }\n  else\n  {\n    // Add this page...\n    if (pdf->num_pages >= pdf->alloc_pages)\n    {\n      pdfio_obj_t **temp = (pdfio_obj_t **)realloc(pdf->pages, (pdf->alloc_pages + 32) * sizeof(pdfio_obj_t *));\n\n      if (!temp)\n      {\n        _pdfioFileError(pdf, \"Unable to allocate memory for pages.\");\n        return (false);\n      }\n\n      pdf->alloc_pages += 32;\n      pdf->pages       = temp;\n    }\n\n    pdf->pages[pdf->num_pages ++] = obj;\n  }\n\n  return (true);\n}\n\n\n//\n// 'load_xref()' - Load an XREF table...\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nload_xref(\n    pdfio_file_t        *pdf,\t\t// I - PDF file\n    off_t               xref_offset,\t// I - Offset to xref\n    pdfio_password_cb_t password_cb,\t// I - Password callback or `NULL` for none\n    void                *password_data)\t// I - Password callback data, if any\n{\n  bool\t\tdone = false;\t\t// Are we done?\n  char\t\tline[1024],\t\t// Line from file\n\t\t*ptr;\t\t\t// Pointer into line\n  _pdfio_value_t trailer;\t\t// Trailer dictionary\n  intmax_t\tnumber,\t\t\t// Object number\n\t\tnum_objects,\t\t// Number of objects\n\t\toffset;\t\t\t// Offset in file\n  int\t\tgeneration;\t\t// Generation number\n  _pdfio_token_t tb;\t\t\t// Token buffer/stack\n  off_t\t\tline_offset;\t\t// Offset to start of line\n\n\n  while (!done)\n  {\n    if (_pdfioFileSeek(pdf, xref_offset, SEEK_SET) != xref_offset)\n    {\n      _pdfioFileError(pdf, \"Unable to seek to start of xref table.\");\n      return (false);\n    }\n\n    do\n    {\n      line_offset = _pdfioFileTell(pdf);\n\n      if (!_pdfioFileGets(pdf, line, sizeof(line)))\n      {\n\t_pdfioFileError(pdf, \"Unable to read start of xref table.\");\n\treturn (false);\n      }\n    }\n    while (!line[0]);\n\n    PDFIO_DEBUG(\"load_xref: line_offset=%lu, line='%s'\\n\", (unsigned long)line_offset, line);\n\n    if (isdigit(line[0] & 255) && strlen(line) > 4 && (!strcmp(line + strlen(line) - 4, \" obj\") || ((ptr = strstr(line, \" obj\")) != NULL && ptr[4] == '<')))\n    {\n      // Cross-reference stream\n      pdfio_obj_t\t*obj;\t\t// Object\n      size_t\t\ti;\t\t// Looping var\n      pdfio_array_t\t*index_array;\t// Index array\n      size_t\t\tindex_n,\t// Current element in array\n\t\t\tindex_count,\t// Number of values in index array\n\t\t\tcount;\t\t// Number of objects in current pairing\n      pdfio_array_t\t*w_array;\t// W array\n      size_t\t\tw[3];\t\t// Size of each cross-reference field\n      size_t\t\tw_2,\t\t// Offset to second field\n\t\t\tw_3;\t\t// Offset to third field\n      size_t\t\tw_total;\t// Total length\n      pdfio_stream_t\t*st;\t\t// Stream\n      unsigned char\tbuffer[32];\t// Read buffer\n      size_t\t\tnum_sobjs = 0,\t// Number of object streams\n\t\t\tsobjs[4096];\t// Object streams to load\n      pdfio_obj_t\t*current;\t// Current object\n\n      if ((number = strtoimax(line, &ptr, 10)) < 1)\n      {\n\t_pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n\treturn (false);\n      }\n\n      if ((generation = (int)strtol(ptr, &ptr, 10)) < 0 || generation > 65535)\n      {\n\t_pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n\treturn (false);\n      }\n\n      while (isspace(*ptr & 255))\n\tptr ++;\n\n      if (strncmp(ptr, \"obj\", 3))\n      {\n\t_pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n\treturn (false);\n      }\n\n      if (_pdfioFileSeek(pdf, line_offset + ptr + 3 - line, SEEK_SET) < 0)\n      {\n        _pdfioFileError(pdf, \"Unable to seek to xref object %lu %u.\", (unsigned long)number, (unsigned)generation);\n        return (false);\n      }\n\n      PDFIO_DEBUG(\"load_xref: Loading object %lu %u.\\n\", (unsigned long)number, (unsigned)generation);\n\n      if ((obj = add_obj(pdf, (size_t)number, (unsigned short)generation, xref_offset)) == NULL)\n      {\n        _pdfioFileError(pdf, \"Unable to allocate memory for object.\");\n        return (false);\n      }\n\n      _pdfioTokenInit(&tb, pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, pdf);\n\n      if (!_pdfioValueRead(pdf, obj, &tb, &trailer, 0))\n      {\n        _pdfioFileError(pdf, \"Unable to read cross-reference stream dictionary.\");\n        return (false);\n      }\n      else if (trailer.type != PDFIO_VALTYPE_DICT)\n      {\n\t_pdfioFileError(pdf, \"Cross-reference stream does not have a dictionary.\");\n\treturn (false);\n      }\n\n      obj->value = trailer;\n\n      if (!_pdfioTokenGet(&tb, line, sizeof(line)) || strcmp(line, \"stream\"))\n      {\n        _pdfioFileError(pdf, \"Unable to get stream after xref dictionary.\");\n        return (false);\n      }\n\n      _pdfioTokenFlush(&tb);\n\n      obj->stream_offset = _pdfioFileTell(pdf);\n\n      if ((index_array = pdfioDictGetArray(trailer.value.dict, \"Index\")) != NULL)\n        index_count = index_array->num_values;\n      else\n        index_count = 1;\n\n      if ((w_array = pdfioDictGetArray(trailer.value.dict, \"W\")) == NULL)\n      {\n\t_pdfioFileError(pdf, \"Cross-reference stream does not have required W key.\");\n\treturn (false);\n      }\n\n      w[0]    = (size_t)pdfioArrayGetNumber(w_array, 0);\n      w[1]    = (size_t)pdfioArrayGetNumber(w_array, 1);\n      w[2]    = (size_t)pdfioArrayGetNumber(w_array, 2);\n      w_total = w[0] + w[1] + w[2];\n      w_2     = w[0];\n      w_3     = w[0] + w[1];\n\n      if (w[1] == 0 || w[2] > 2 || w[0] > sizeof(buffer) || w[1] > sizeof(buffer) || w[2] > sizeof(buffer) || w_total > sizeof(buffer))\n      {\n\t_pdfioFileError(pdf, \"Cross-reference stream has invalid W key.\");\n\treturn (false);\n      }\n\n      if ((st = pdfioObjOpenStream(obj, true)) == NULL)\n      {\n\t_pdfioFileError(pdf, \"Unable to open cross-reference stream.\");\n\treturn (false);\n      }\n\n      for (index_n = 0; index_n < index_count; index_n += 2)\n      {\n        if (index_count == 1)\n        {\n          number = 0;\n          count  = 999999999;\n\t}\n\telse\n\t{\n          number = (intmax_t)pdfioArrayGetNumber(index_array, index_n);\n          count  = (size_t)pdfioArrayGetNumber(index_array, index_n + 1);\n\t}\n\n\twhile (count > 0 && pdfioStreamRead(st, buffer, w_total) > 0)\n\t{\n\t  count --;\n\n\t  PDFIO_DEBUG(\"load_xref: number=%u %02X%02X%02X%02X%02X\\n\", (unsigned)number, buffer[0], buffer[1], buffer[2], buffer[3], buffer[4]);\n\n\t  // Check whether this is an object definition...\n\t  if (w[0] > 0)\n\t  {\n\t    if (buffer[0] == 0)\n\t    {\n\t      // Ignore free objects...\n\t      number ++;\n\t      continue;\n\t    }\n\t  }\n\n\t  for (i = 1, offset = buffer[w_2]; i < w[1]; i ++)\n\t    offset = (offset << 8) | buffer[w_2 + i];\n\n\t  switch (w[2])\n\t  {\n\t    default :\n\t\tgeneration = 0;\n\t\tbreak;\n\t    case 1 :\n\t\tgeneration = buffer[w_3];\n\t\tbreak;\n\t    case 2 :\n\t\tgeneration = (buffer[w_3] << 8) | buffer[w_3 + 1];\n\t\tbreak;\n\t  }\n\n\t  // Create a placeholder for the object in memory...\n\t  if ((current = pdfioFileFindObj(pdf, (size_t)number)) != NULL)\n\t  {\n\t    PDFIO_DEBUG(\"load_xref: existing object, prev offset=%u\\n\", (unsigned)current->offset);\n\n            if (w[0] == 0 || buffer[0] == 1)\n            {\n              // Location of object...\n\t      current->offset = offset;\n\t    }\n\t    else if (number != offset)\n\t    {\n\t      // Object is part of a stream, offset is the object number...\n\t      current->offset = 0;\n\t    }\n\n\t    PDFIO_DEBUG(\"load_xref: new offset=%u\\n\", (unsigned)current->offset);\n\t  }\n\n\t  if (w[0] > 0 && buffer[0] == 2)\n\t  {\n\t    // Object streams need to be loaded into memory, so add them\n\t    // to the list of objects to load later as needed...\n\t    for (i = 0; i < num_sobjs; i ++)\n\t    {\n\t      if (sobjs[i] == (size_t)offset)\n\t\tbreak;\n\t    }\n\n\t    if (i >= num_sobjs && num_sobjs < (sizeof(sobjs) / sizeof(sobjs[0])))\n\t      sobjs[num_sobjs ++] = (size_t)offset;\n\t  }\n\t  else if (!current)\n\t  {\n\t    // Add this object...\n\t    if (!add_obj(pdf, (size_t)number, (unsigned short)generation, offset))\n\t      return (false);\n\t  }\n\n\t  number ++;\n\t}\n      }\n\n      pdfioStreamClose(st);\n\n      if (!pdf->trailer_dict)\n      {\n\t// Save the trailer dictionary and grab the root (catalog) and info\n\t// objects...\n\tpdf->trailer_dict = trailer.value.dict;\n\tpdf->info_obj     = pdfioDictGetObj(pdf->trailer_dict, \"Info\");\n\tpdf->encrypt_obj  = pdfioDictGetObj(pdf->trailer_dict, \"Encrypt\");\n\tpdf->id_array     = pdfioDictGetArray(pdf->trailer_dict, \"ID\");\n\n\t// If the trailer contains an Encrypt key, try unlocking the file...\n\tif (pdf->encrypt_obj && !_pdfioCryptoUnlock(pdf, password_cb, password_data))\n\t  return (false);\n      }\n\n      // Load any object streams that are left...\n      PDFIO_DEBUG(\"load_xref: %lu compressed object streams to load.\\n\", (unsigned long)num_sobjs);\n\n      for (i = 0; i < num_sobjs; i ++)\n      {\n        if ((obj = pdfioFileFindObj(pdf, sobjs[i])) != NULL)\n        {\n\t  PDFIO_DEBUG(\"load_xref: Loading compressed object stream %lu (pdf=%p, obj->pdf=%p).\\n\", (unsigned long)sobjs[i], pdf, obj->pdf);\n\n          if (!load_obj_stream(obj))\n            return (false);\n\t}\n\telse\n\t{\n\t  _pdfioFileError(pdf, \"Unable to find compressed object stream %lu.\", (unsigned long)sobjs[i]);\n\t  return (false);\n\t}\n      }\n    }\n    else if (!strcmp(line, \"xref\"))\n    {\n      // Read the xref tables\n      while (_pdfioFileGets(pdf, line, sizeof(line)))\n      {\n\tif (!strcmp(line, \"trailer\"))\n\t  break;\n\telse if (!line[0])\n\t  continue;\n\n\tif (sscanf(line, \"%jd%jd\", &number, &num_objects) != 2)\n\t{\n\t  _pdfioFileError(pdf, \"Malformed xref table section '%s'.\", line);\n\t  return (false);\n\t}\n\n\t// Read this group of objects...\n\tfor (; num_objects > 0; num_objects --, number ++)\n\t{\n\t  // Read a line from the file and validate it...\n\t  if (_pdfioFileRead(pdf, line, 20) != 20)\n\t    return (false);\n\n\t  line[20] = '\\0';\n\n\t  if (strcmp(line + 18, \"\\r\\n\") && strcmp(line + 18, \" \\n\") && strcmp(line + 18, \" \\r\"))\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\t  line[18] = '\\0';\n\n\t  // Parse the line\n\t  if ((offset = strtoimax(line, &ptr, 10)) < 0)\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  if ((generation = (int)strtol(ptr, &ptr, 10)) < 0 || generation > 65535)\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  if (*ptr != ' ')\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  ptr ++;\n\t  if (*ptr != 'f' && *ptr != 'n')\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  if (*ptr == 'f')\n\t    continue;\t\t\t// Don't care about free objects...\n\n\t  // Create a placeholder for the object in memory...\n\t  if (pdfioFileFindObj(pdf, (size_t)number))\n\t    continue;\t\t\t// Don't replace newer object...\n\n\t  if (!add_obj(pdf, (size_t)number, (unsigned short)generation, offset))\n\t    return (false);\n\t}\n      }\n\n      if (strcmp(line, \"trailer\"))\n      {\n\t_pdfioFileError(pdf, \"Missing trailer.\");\n\treturn (false);\n      }\n\n      _pdfioTokenInit(&tb, pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, pdf);\n\n      if (!_pdfioValueRead(pdf, NULL, &tb, &trailer, 0))\n      {\n\t_pdfioFileError(pdf, \"Unable to read trailer dictionary.\");\n\treturn (false);\n      }\n      else if (trailer.type != PDFIO_VALTYPE_DICT)\n      {\n\t_pdfioFileError(pdf, \"Trailer is not a dictionary.\");\n\treturn (false);\n      }\n\n      _pdfioTokenFlush(&tb);\n\n      if (!pdf->trailer_dict)\n      {\n\t// Save the trailer dictionary and grab the root (catalog) and info\n\t// objects...\n\tpdf->trailer_dict = trailer.value.dict;\n\tpdf->info_obj     = pdfioDictGetObj(pdf->trailer_dict, \"Info\");\n\tpdf->encrypt_obj  = pdfioDictGetObj(pdf->trailer_dict, \"Encrypt\");\n\tpdf->id_array     = pdfioDictGetArray(pdf->trailer_dict, \"ID\");\n\n\t// If the trailer contains an Encrypt key, try unlocking the file...\n\tif (pdf->encrypt_obj && !_pdfioCryptoUnlock(pdf, password_cb, password_data))\n\t  return (false);\n      }\n    }\n    else\n    {\n      _pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n      return (false);\n    }\n\n    PDFIO_DEBUG(\"load_xref: Contents of trailer dictionary:\\n\");\n    PDFIO_DEBUG(\"load_xref: \");\n    PDFIO_DEBUG_VALUE(&trailer);\n    PDFIO_DEBUG(\"\\n\");\n\n    if ((xref_offset = (off_t)pdfioDictGetNumber(trailer.value.dict, \"Prev\")) <= 0)\n      done = true;\n  }\n\n  // Once we have all of the xref tables loaded, get the important objects and\n  // build the pages array...\n  if ((pdf->root_obj = pdfioDictGetObj(pdf->trailer_dict, \"Root\")) == NULL)\n  {\n    _pdfioFileError(pdf, \"Missing Root object.\");\n    return (false);\n  }\n\n  PDFIO_DEBUG(\"load_xref: Root=%p(%lu)\\n\", pdf->root_obj, (unsigned long)pdf->root_obj->number);\n\n  return (load_pages(pdf, pdfioDictGetObj(pdfioObjGetDict(pdf->root_obj), \"Pages\"), 0));\n}\n\n\n//\n// 'write_catalog()' - Write the PDF root object/catalog.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nwrite_catalog(pdfio_file_t *pdf)\t// I - PDF file\n{\n  pdfio_dict_t\t*dict;\t\t\t// Dictionary for catalog...\n\n\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    return (false);\n\n  pdfioDictSetName(dict, \"Type\", \"Catalog\");\n  pdfioDictSetObj(dict, \"Pages\", pdf->pages_obj);\n  // TODO: Add support for all of the root object dictionary keys\n\n  if ((pdf->root_obj = pdfioFileCreateObj(pdf, dict)) == NULL)\n    return (false);\n  else\n    return (pdfioObjClose(pdf->root_obj));\n}\n\n\n//\n// 'write_pages()' - Write the PDF pages objects.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nwrite_pages(pdfio_file_t *pdf)\t\t// I - PDF file\n{\n  pdfio_array_t\t*kids;\t\t\t// Pages array\n  size_t\ti;\t\t\t// Looping var\n\n\n  // Build the \"Kids\" array pointing to each page...\n  if ((kids = pdfioArrayCreate(pdf)) == NULL)\n    return (false);\n\n  for (i = 0; i < pdf->num_pages; i ++)\n    pdfioArrayAppendObj(kids, pdf->pages[i]);\n\n  pdfioDictSetNumber(pdf->pages_obj->value.value.dict, \"Count\", pdf->num_pages);\n  pdfioDictSetArray(pdf->pages_obj->value.value.dict, \"Kids\", kids);\n\n  // Write the Pages object...\n  return (pdfioObjClose(pdf->pages_obj));\n}\n\n\n//\n// 'write_trailer()' - Write the PDF catalog object, xref table, and trailer.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nwrite_trailer(pdfio_file_t *pdf)\t// I - PDF file\n{\n  bool\t\tret = true;\t\t// Return value\n  off_t\t\txref_offset;\t\t// Offset to xref table\n  size_t\ti;\t\t\t// Looping var\n\n\n  // Write the xref table...\n  // TODO: Look at adding support for xref streams...\n  xref_offset = _pdfioFileTell(pdf);\n\n  if (!_pdfioFilePrintf(pdf, \"xref\\n0 %lu \\n0000000000 65535 f \\n\", (unsigned long)pdf->num_objs + 1))\n  {\n    _pdfioFileError(pdf, \"Unable to write cross-reference table.\");\n    ret = false;\n    goto done;\n  }\n\n  for (i = 0; i < pdf->num_objs; i ++)\n  {\n    pdfio_obj_t\t*obj = pdf->objs[i];\t// Current object\n\n    if (!_pdfioFilePrintf(pdf, \"%010lu %05u n \\n\", (unsigned long)obj->offset, obj->generation))\n    {\n      _pdfioFileError(pdf, \"Unable to write cross-reference table.\");\n      ret = false;\n      goto done;\n    }\n  }\n\n  // Write the trailer...\n  if (!_pdfioFilePuts(pdf, \"trailer\\n\"))\n  {\n    _pdfioFileError(pdf, \"Unable to write trailer.\");\n    ret = false;\n    goto done;\n  }\n\n  if ((pdf->trailer_dict = pdfioDictCreate(pdf)) == NULL)\n  {\n    _pdfioFileError(pdf, \"Unable to create trailer.\");\n    ret = false;\n    goto done;\n  }\n\n  if (pdf->encrypt_obj)\n    pdfioDictSetObj(pdf->trailer_dict, \"Encrypt\", pdf->encrypt_obj);\n  if (pdf->id_array)\n    pdfioDictSetArray(pdf->trailer_dict, \"ID\", pdf->id_array);\n  pdfioDictSetObj(pdf->trailer_dict, \"Info\", pdf->info_obj);\n  pdfioDictSetObj(pdf->trailer_dict, \"Root\", pdf->root_obj);\n  pdfioDictSetNumber(pdf->trailer_dict, \"Size\", pdf->num_objs + 1);\n\n  if (!_pdfioDictWrite(pdf->trailer_dict, NULL, NULL))\n  {\n    _pdfioFileError(pdf, \"Unable to write trailer.\");\n    ret = false;\n    goto done;\n  }\n\n  if (!_pdfioFilePrintf(pdf, \"\\nstartxref\\n%lu\\n%%EOF\\n\", (unsigned long)xref_offset))\n  {\n    _pdfioFileError(pdf, \"Unable to write xref offset.\");\n    ret = false;\n  }\n\n  done:\n\n  return (ret);\n}\n", "//\n// PDF object functions for PDFio.\n//\n// Copyright \u00a9\u00a02021-2022 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n\n\n//\n// Local functions...\n//\n\nstatic bool\twrite_obj_header(pdfio_obj_t *obj);\n\n\n//\n// 'pdfioObjClose()' - Close an object, writing any data as needed to the PDF\n//                     file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioObjClose(pdfio_obj_t *obj)\t\t// I - Object\n{\n  // Range check input\n  if (!obj)\n    return (false);\n\n  // Clear the current object pointer...\n  obj->pdf->current_obj = NULL;\n\n  if (obj->pdf->mode != _PDFIO_MODE_WRITE)\n  {\n    // Nothing to do when reading\n    return (true);\n  }\n\n  // Write what remains for the object...\n  if (!obj->offset)\n  {\n    // Write the object value\n    if (!write_obj_header(obj))\n      return (false);\n\n    // Write the \"endobj\" line...\n    return (_pdfioFilePuts(obj->pdf, \"endobj\\n\"));\n  }\n  else if (obj->stream)\n  {\n    // Close the stream...\n    return (pdfioStreamClose(obj->stream));\n  }\n  else\n  {\n    // Already closed\n    return (true);\n  }\n}\n\n\n//\n// 'pdfioObjCopy()' - Copy an object to another PDF file.\n//\n\npdfio_obj_t *\t\t\t\t// O - New object or `NULL` on error\npdfioObjCopy(pdfio_file_t *pdf,\t\t// I - PDF file\n             pdfio_obj_t  *srcobj)\t// I - Object to copy\n{\n  pdfio_obj_t\t*dstobj;\t\t// Destination object\n  pdfio_stream_t *srcst,\t\t// Source stream\n\t\t*dstst;\t\t\t// Destination stream\n  char\t\tbuffer[32768];\t\t// Copy buffer\n  ssize_t\tbytes;\t\t\t// Bytes read\n\n\n  PDFIO_DEBUG(\"pdfioObjCopy(pdf=%p, srcobj=%p(%p))\\n\", pdf, srcobj, srcobj ? srcobj->pdf : NULL);\n\n  // Range check input\n  if (!pdf || !srcobj)\n    return (NULL);\n\n  // Load the object value if needed...\n  if (srcobj->value.type == PDFIO_VALTYPE_NONE)\n    _pdfioObjLoad(srcobj);\n\n  // Create the new object...\n  if ((dstobj = _pdfioFileCreateObj(pdf, srcobj->pdf, NULL)) == NULL)\n    return (NULL);\n\n  // Add new object to the cache of copied objects...\n  if (!_pdfioFileAddMappedObj(pdf, dstobj, srcobj))\n    return (NULL);\n\n  // Copy the object's value...\n  if (!_pdfioValueCopy(pdf, &dstobj->value, srcobj->pdf, &srcobj->value))\n    return (NULL);\n\n  if (dstobj->value.type == PDFIO_VALTYPE_DICT)\n    _pdfioDictClear(dstobj->value.value.dict, \"Length\");\n\n  if (srcobj->stream_offset)\n  {\n    // Copy stream data...\n    if ((srcst = pdfioObjOpenStream(srcobj, false)) == NULL)\n    {\n      pdfioObjClose(dstobj);\n      return (NULL);\n    }\n\n    if ((dstst = pdfioObjCreateStream(dstobj, PDFIO_FILTER_NONE)) == NULL)\n    {\n      pdfioStreamClose(srcst);\n      pdfioObjClose(dstobj);\n      return (NULL);\n    }\n\n    while ((bytes = pdfioStreamRead(srcst, buffer, sizeof(buffer))) > 0)\n    {\n      if (!pdfioStreamWrite(dstst, buffer, (size_t)bytes))\n      {\n        bytes = -1;\n        break;\n      }\n    }\n\n    pdfioStreamClose(srcst);\n    pdfioStreamClose(dstst);\n\n    if (bytes < 0)\n      return (NULL);\n  }\n  else\n    pdfioObjClose(dstobj);\n\n  return (dstobj);\n}\n\n\n//\n// 'pdfioObjCreateStream()' - Create an object (data) stream for writing.\n//\n\npdfio_stream_t *\t\t\t// O - Stream or `NULL` on error\npdfioObjCreateStream(\n    pdfio_obj_t    *obj,\t\t// I - Object\n    pdfio_filter_t filter)\t\t// I - Type of compression to apply\n{\n  pdfio_obj_t\t*length_obj = NULL;\t// Length object, if any\n\n\n  // Range check input\n  if (!obj || obj->pdf->mode != _PDFIO_MODE_WRITE || obj->value.type != PDFIO_VALTYPE_DICT)\n    return (NULL);\n\n  if (obj->offset)\n  {\n    _pdfioFileError(obj->pdf, \"Object has already been written.\");\n    return (NULL);\n  }\n\n  if (filter != PDFIO_FILTER_NONE && filter != PDFIO_FILTER_FLATE)\n  {\n    _pdfioFileError(obj->pdf, \"Unsupported filter value for PDFioObjCreateStream.\");\n    return (NULL);\n  }\n\n  if (obj->pdf->current_obj)\n  {\n    _pdfioFileError(obj->pdf, \"Another object (%u) is already open.\", (unsigned)obj->pdf->current_obj->number);\n    return (NULL);\n  }\n\n  // Write the header...\n  if (!_pdfioDictGetValue(obj->value.value.dict, \"Length\"))\n  {\n    if (obj->pdf->output_cb)\n    {\n      // Streaming via an output callback, so add a placeholder length object\n      _pdfio_value_t\tlength_value;\t// Length value\n\n      length_value.type         = PDFIO_VALTYPE_NUMBER;\n      length_value.value.number = 0.0f;\n\n      length_obj = _pdfioFileCreateObj(obj->pdf, obj->pdf, &length_value);\n      pdfioDictSetObj(obj->value.value.dict, \"Length\", length_obj);\n    }\n    else\n    {\n      // Need a Length key for the stream, add a placeholder that we can fill in\n      // later...\n      pdfioDictSetNumber(obj->value.value.dict, \"Length\", 0.0);\n    }\n  }\n\n  if (!write_obj_header(obj))\n    return (NULL);\n\n  if (!_pdfioFilePuts(obj->pdf, \"stream\\n\"))\n    return (NULL);\n\n  obj->stream_offset    = _pdfioFileTell(obj->pdf);\n  obj->pdf->current_obj = obj;\n\n  // Return the new stream...\n  return (_pdfioStreamCreate(obj, length_obj, filter));\n}\n\n\n//\n// '_pdfioObjDelete()' - Free memory used by an object.\n//\n\nvoid\n_pdfioObjDelete(pdfio_obj_t *obj)\t// I - Object\n{\n  if (obj)\n    pdfioStreamClose(obj->stream);\n\n  free(obj);\n}\n\n\n//\n// 'pdfioObjGetArray()' - Get the array associated with an object.\n//\n\npdfio_array_t *\t\t\t\t// O - Array or `NULL` on error\npdfioObjGetArray(pdfio_obj_t *obj)\t// I - Object\n{\n  if (!obj)\n    return (NULL);\n\n  if (obj->value.type == PDFIO_VALTYPE_NONE)\n    _pdfioObjLoad(obj);\n\n  if (obj->value.type == PDFIO_VALTYPE_ARRAY)\n    return (obj->value.value.array);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioObjGetDict()' - Get the dictionary associated with an object.\n//\n\npdfio_dict_t *\t\t\t\t// O - Dictionary or `NULL` on error\npdfioObjGetDict(pdfio_obj_t *obj)\t// I - Object\n{\n  if (!obj)\n    return (NULL);\n\n  if (obj->value.type == PDFIO_VALTYPE_NONE)\n    _pdfioObjLoad(obj);\n\n  if (obj->value.type == PDFIO_VALTYPE_DICT)\n    return (obj->value.value.dict);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioObjGetGeneration()' - Get the object's generation number.\n//\n\nunsigned short\t\t\t\t// O - Generation number (0 to 65535)\npdfioObjGetGeneration(pdfio_obj_t *obj)\t// I - Object\n{\n  return (obj ? obj->generation : 0);\n}\n\n\n//\n// 'pdfioObjGetLength()' - Get the length of the object's (data) stream.\n//\n\nsize_t\t\t\t\t\t// O - Length in bytes or `0` for none\npdfioObjGetLength(pdfio_obj_t *obj)\t// I - Object\n{\n  size_t\tlength;\t\t\t// Length of stream\n  pdfio_obj_t\t*lenobj;\t\t// Length object\n\n\n  // Range check input...\n  if (!obj || !obj->stream_offset || obj->value.type != PDFIO_VALTYPE_DICT)\n    return (0);\n\n  // Try getting the length, directly or indirectly\n  if ((length = (size_t)pdfioDictGetNumber(obj->value.value.dict, \"Length\")) > 0)\n  {\n    PDFIO_DEBUG(\"pdfioObjGetLength(obj=%p) returning %lu.\\n\", obj, (unsigned long)length);\n    return (length);\n  }\n\n  if ((lenobj = pdfioDictGetObj(obj->value.value.dict, \"Length\")) == NULL)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to get length of stream.\");\n    return (0);\n  }\n\n  if (lenobj->value.type == PDFIO_VALTYPE_NONE)\n    _pdfioObjLoad(lenobj);\n\n  if (lenobj->value.type != PDFIO_VALTYPE_NUMBER || lenobj->value.value.number <= 0.0)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to get length of stream.\");\n    return (0);\n  }\n\n  PDFIO_DEBUG(\"pdfioObjGetLength(obj=%p) returning %lu.\\n\", obj, (unsigned long)lenobj->value.value.number);\n\n  return ((size_t)lenobj->value.value.number);\n}\n\n\n//\n// 'pdfioObjGetNumber()' - Get the object's number.\n//\n\nsize_t\t\t\t\t\t// O - Object number (1 to 9999999999)\npdfioObjGetNumber(pdfio_obj_t *obj)\t// I - Object\n{\n  return (obj ? obj->number : 0);\n}\n\n\n//\n// 'pdfioObjGetSubtype()' - Get an object's subtype.\n//\n\nconst char *\t\t\t\t// O - Object subtype\npdfioObjGetSubtype(pdfio_obj_t *obj)\t// I - Object\n{\n  pdfio_dict_t\t*dict;\t\t\t// Object dictionary\n\n\n  if ((dict = pdfioObjGetDict(obj)) == NULL)\n    return (NULL);\n  else\n    return (pdfioDictGetName(dict, \"Subtype\"));\n}\n\n\n//\n// 'pdfioObjGetType()' - Get an object's type.\n//\n\nconst char *\t\t\t\t// O - Object type\npdfioObjGetType(pdfio_obj_t *obj)\t// I - Object\n{\n  pdfio_dict_t\t*dict;\t\t\t// Object dictionary\n\n\n  if ((dict = pdfioObjGetDict(obj)) == NULL)\n    return (NULL);\n  else\n    return (pdfioDictGetName(dict, \"Type\"));\n}\n\n\n//\n// '_pdfioObjLoad()' - Load an object dictionary/value.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` otherwise\n_pdfioObjLoad(pdfio_obj_t *obj)\t\t// I - Object\n{\n  char\t\t\tline[64],\t// Line from file\n\t\t\t*ptr;\t\t// Pointer into line\n  ssize_t\t\tbytes;\t\t// Bytes read\n  _pdfio_token_t\ttb;\t\t// Token buffer/stack\n\n\n  PDFIO_DEBUG(\"_pdfioObjLoad(obj=%p(%lu)), offset=%lu\\n\", obj, (unsigned long)obj->number, (unsigned long)obj->offset);\n\n  // Seek to the start of the object and read its header...\n  if (_pdfioFileSeek(obj->pdf, obj->offset, SEEK_SET) != obj->offset)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to seek to object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  if ((bytes = _pdfioFilePeek(obj->pdf, line, sizeof(line) - 1)) < 0)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to read header for object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  line[bytes] = '\\0';\n\n  PDFIO_DEBUG(\"_pdfioObjLoad: Header is '%s'.\\n\", line);\n\n  if (strtoimax(line, &ptr, 10) != (intmax_t)obj->number)\n  {\n    _pdfioFileError(obj->pdf, \"Bad header for object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  if (strtol(ptr, &ptr, 10) != (long)obj->generation)\n  {\n    _pdfioFileError(obj->pdf, \"Bad header for object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  while (isspace(*ptr & 255))\n    ptr ++;\n\n  if (strncmp(ptr, \"obj\", 3) || (ptr[3] && ptr[3] != '<' && ptr[3] != '[' && !isspace(ptr[3] & 255)))\n  {\n    _pdfioFileError(obj->pdf, \"Bad header for object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  ptr += 3;\n  _pdfioFileConsume(obj->pdf, (size_t)(ptr - line));\n\n  // Then grab the object value...\n  _pdfioTokenInit(&tb, obj->pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, obj->pdf);\n\n  if (!_pdfioValueRead(obj->pdf, obj, &tb, &obj->value, 0))\n  {\n    _pdfioFileError(obj->pdf, \"Unable to read value for object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  // Now see if there is an associated stream...\n  if (!_pdfioTokenGet(&tb, line, sizeof(line)))\n  {\n    _pdfioFileError(obj->pdf, \"Early end-of-file for object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  _pdfioTokenFlush(&tb);\n\n  if (!strcmp(line, \"stream\"))\n  {\n    // Yes, save its location...\n    obj->stream_offset = _pdfioFileTell(obj->pdf);\n    PDFIO_DEBUG(\"_pdfioObjLoad: stream_offset=%lu.\\n\", (unsigned long)obj->stream_offset);\n  }\n\n  PDFIO_DEBUG(\"_pdfioObjLoad: \");\n  PDFIO_DEBUG_VALUE(&obj->value);\n  PDFIO_DEBUG(\"\\n\");\n\n  return (true);\n}\n\n\n//\n// 'pdfioObjOpenStream()' - Open an object's (data) stream for reading.\n//\n\npdfio_stream_t *\t\t\t// O - Stream or `NULL` on error\npdfioObjOpenStream(pdfio_obj_t *obj,\t// I - Object\n                   bool        decode)\t// I - Decode/decompress data?\n{\n  // Range check input...\n  if (!obj)\n    return (NULL);\n\n  if (obj->pdf->current_obj)\n  {\n    _pdfioFileError(obj->pdf, \"Another object (%u) is already open.\", (unsigned)obj->pdf->current_obj->number);\n    return (NULL);\n  }\n\n  // Make sure we've loaded the object dictionary...\n  if (!obj->value.type)\n  {\n    if (!_pdfioObjLoad(obj))\n      return (NULL);\n  }\n\n  // No stream if there is no dict or offset to a stream...\n  if (obj->value.type != PDFIO_VALTYPE_DICT || !obj->stream_offset)\n    return (NULL);\n\n  // Open the stream...\n  obj->pdf->current_obj = obj;\n\n  return (_pdfioStreamOpen(obj, decode));\n}\n\n\n//\n// 'write_obj_header()' - Write the object header...\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nwrite_obj_header(pdfio_obj_t *obj)\t// I - Object\n{\n  obj->offset = _pdfioFileTell(obj->pdf);\n\n  if (!_pdfioFilePrintf(obj->pdf, \"%lu %u obj\\n\", (unsigned long)obj->number, obj->generation))\n    return (false);\n\n  if (!_pdfioValueWrite(obj->pdf, obj, &obj->value, &obj->length_offset))\n    return (false);\n\n  return (_pdfioFilePuts(obj->pdf, \"\\n\"));\n}\n", "//\n// PDF token parsing functions for PDFio.\n//\n// Copyright \u00a9\u00a02021 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n\n\n//\n// This file parses PDF language syntax:\n//\n// << dict >>                \"<<\" and \">>\" delimit a dictionary\n// (string)                  \"(\" and \")\" delimit a string\n// [array]                   \"[\" and \"]\" delimit an array\n// <hex-string>              \"<\" and \">\" delimit a hex string\n// {...}                     \"{\" and \"}\" are reserved as future delimiters\n// /name                     \"/\" starts a name with any special characters\n//                           quoted as \"#HH\" where HH is the byte value in hex.\n// %comment                  \"%\" starts a comment to the end of a line\n// keyword                   A keyword consists of other unreserved characters\n// [-+]?[0-9]*(.[0-9]*)?     A number optionally starts with \"+\" or \"-\".\n//\n// Newlines are CR, LF, or CR LF.\n//\n// Strings and names are returned with the leading delimiter (\"(string\",\n// \"<hex-string\", \"/name\") and all escaping/whitespace removal resolved.\n// Other delimiters, keywords, and numbers are returned as-is.\n//\n\n\n//\n// Constants...\n//\n\n#define PDFIO_NUMBER_CHARS\t\"0123456789-+.\"\n#define PDFIO_DELIM_CHARS\t\"<>(){}[]/%\"\n\n\n//\n// Local functions...\n//\n\nstatic int\tget_char(_pdfio_token_t *tb);\n\n\n//\n// '_pdfioTokenClear()' - Clear the token stack.\n//\n\nvoid\n_pdfioTokenClear(_pdfio_token_t *tb)\t// I - Token buffer/stack\n{\n  PDFIO_DEBUG(\"_pdfioTokenClear(tb=%p)\\n\", tb);\n\n  while (tb->num_tokens > 0)\n  {\n    tb->num_tokens --;\n    free(tb->tokens[tb->num_tokens]);\n    tb->tokens[tb->num_tokens] = NULL;\n  }\n}\n\n\n//\n// '_pdfioTokenFlush()' - Flush (consume) any bytes that have been used.\n//\n\nvoid\n_pdfioTokenFlush(_pdfio_token_t *tb)\t// I - Token buffer/stack\n{\n  if (tb->bufptr > tb->buffer)\n  {\n    size_t remaining = (size_t)(tb->bufend - tb->bufptr);\n\t\t\t\t\t// Remaining bytes in buffer\n\n    // Consume what we've used...\n    PDFIO_DEBUG(\"_pdfioTokenFlush: Consuming %d bytes.\\n\", (int)(tb->bufptr - tb->buffer));\n    (tb->consume_cb)(tb->cb_data, (size_t)(tb->bufptr - tb->buffer));\n\n    if (remaining > 0)\n    {\n      // Shuffle remaining bytes for next call...\n      memmove(tb->buffer, tb->bufptr, remaining);\n      tb->bufptr = tb->buffer;\n      tb->bufend = tb->buffer + remaining;\n\n#ifdef DEBUG\n      unsigned char *ptr;\t\t// Pointer into buffer\n\n      PDFIO_DEBUG(\"_pdfioTokenFlush: Remainder '\");\n      for (ptr = tb->buffer; ptr < tb->bufend; ptr ++)\n      {\n\tif (*ptr < ' ' || *ptr == 0x7f)\n\t  PDFIO_DEBUG(\"\\\\%03o\", *ptr);\n\telse\n\t  PDFIO_DEBUG(\"%c\", *ptr);\n      }\n      PDFIO_DEBUG(\"'\\n\");\n#endif // DEBUG\n    }\n    else\n    {\n      // Nothing left, reset pointers...\n      PDFIO_DEBUG(\"_pdfioTokenFlush: Resetting pointers.\\n\");\n      tb->bufptr = tb->bufend = tb->buffer;\n    }\n  }\n}\n\n\n//\n// '_pdfioTokenGet()' - Get a token.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioTokenGet(_pdfio_token_t *tb,\t// I - Token buffer/stack\n\t       char           *buffer,\t// I - String buffer\n\t       size_t         bufsize)\t// I - Size of string buffer\n{\n  // See if we have a token waiting on the stack...\n  if (tb->num_tokens > 0)\n  {\n    // Yes, return it...\n    tb->num_tokens --;\n    strncpy(buffer, tb->tokens[tb->num_tokens], bufsize - 1);\n    buffer[bufsize - 1] = '\\0';\n\n    PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\\n\", tb, buffer, (unsigned)bufsize, buffer);\n\n    free(tb->tokens[tb->num_tokens]);\n    tb->tokens[tb->num_tokens] = NULL;\n\n    return (true);\n  }\n\n  // No, read a new one...\n  return (_pdfioTokenRead(tb, buffer, bufsize));\n}\n\n\n//\n// '_pdfioTokenInit()' - Initialize a token buffer/stack.\n//\n\nvoid\n_pdfioTokenInit(\n    _pdfio_token_t       *ts,\t\t// I - Token buffer/stack\n    pdfio_file_t         *pdf,\t\t// I - PDF file\n    _pdfio_tconsume_cb_t consume_cb,\t// I - Consume callback\n    _pdfio_tpeek_cb_t    peek_cb,\t// I - Peek callback\n    void                 *cb_data)\t// I - Callback data\n{\n  // Zero everything out and then initialize key pointers...\n  memset(ts, 0, sizeof(_pdfio_token_t));\n\n  ts->pdf        = pdf;\n  ts->consume_cb = consume_cb;\n  ts->peek_cb    = peek_cb;\n  ts->cb_data    = cb_data;\n  ts->bufptr     = ts->buffer;\n  ts->bufend     = ts->buffer;\n}\n\n\n//\n// '_pdfioTokenPush()' - Push a token on the token stack.\n//\n\nvoid\n_pdfioTokenPush(_pdfio_token_t *tb,\t// I - Token buffer/stack\n\t\tconst char     *token)\t// I - Token to push\n{\n  if (tb->num_tokens < (sizeof(tb->tokens) / sizeof(tb->tokens[0])))\n  {\n    if ((tb->tokens[tb->num_tokens ++] = strdup(token)) == NULL)\n      tb->num_tokens --;\n  }\n}\n\n\n//\n// '_pdfioTokenRead()' - Read a token from a file/stream.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioTokenRead(_pdfio_token_t *tb,\t// I - Token buffer/stack\n\t\tchar           *buffer,\t// I - String buffer\n\t\tsize_t         bufsize)\t// I - Size of string buffer\n{\n  int\tch,\t\t\t\t// Character\n\tparens = 0;\t\t\t// Parenthesis level\n  char\t*bufptr,\t\t\t// Pointer into buffer\n\t*bufend,\t\t\t// End of buffer\n\tstate = '\\0';\t\t\t// Current state\n  bool\tsaw_nul = false;\t\t// Did we see a nul character?\n\n\n  //\n  // \"state\" is:\n  //\n  // - '\\0' for idle\n  // - '(' for literal string\n  // - '/' for name\n  // - '<' for possible hex string or dict\n  // - '>' for possible dict\n  // - '%' for comment\n  // - 'K' for keyword\n  // - 'N' for number\n\n  // Read the next token, skipping any leading whitespace...\n  bufptr = buffer;\n  bufend = buffer + bufsize - 1;\n\n  // Skip leading whitespace...\n  while ((ch = get_char(tb)) != EOF)\n  {\n    if (ch == '%')\n    {\n      // Skip comment\n      while ((ch = get_char(tb)) != EOF)\n      {\n\tif (ch == '\\n' || ch == '\\r')\n\t  break;\n      }\n    }\n    else if (!isspace(ch))\n      break;\n  }\n\n  if (ch == EOF)\n    return (false);\n\n  // Check for delimiters...\n  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)\n  {\n    *bufptr++ = state = (char)ch;\n  }\n  else if (strchr(PDFIO_NUMBER_CHARS, ch) != NULL)\n  {\n    // Number\n    state     = 'N';\n    *bufptr++ = (char)ch;\n  }\n  else\n  {\n    // Keyword\n    state     = 'K';\n    *bufptr++ = (char)ch;\n  }\n\n  switch (state)\n  {\n    case '(' : // Literal string\n\twhile ((ch = get_char(tb)) != EOF)\n\t{\n\t  if (ch == 0)\n\t    saw_nul = true;\n\n\t  if (ch == '\\\\')\n\t  {\n\t    // Quoted character...\n\t    int\ti;\t\t\t// Looping var\n\n\t    switch (ch = get_char(tb))\n\t    {\n\t      case '0' : // Octal character escape\n\t      case '1' :\n\t      case '2' :\n\t      case '3' :\n\t      case '4' :\n\t      case '5' :\n\t      case '6' :\n\t      case '7' :\n\t\t  for (ch -= '0', i = 0; i < 2; i ++)\n\t\t  {\n\t\t    int tch = get_char(tb);\t// Next char\n\n\t\t    if (tch >= '0' && tch <= '7')\n\t\t    {\n\t\t      ch = (char)((ch << 3) | (tch - '0'));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t      tb->bufptr --;\n\t\t      break;\n\t\t    }\n\t\t  }\n\t\t  break;\n\n\t      case '\\\\' :\n\t      case '(' :\n\t      case ')' :\n\t\t  break;\n\n\t      case 'n' :\n\t\t  ch = '\\n';\n\t\t  break;\n\n\t      case 'r' :\n\t\t  ch = '\\r';\n\t\t  break;\n\n\t      case 't' :\n\t\t  ch = '\\t';\n\t\t  break;\n\n\t      case 'b' :\n\t\t  ch = '\\b';\n\t\t  break;\n\n\t      case 'f' :\n\t\t  ch = '\\f';\n\t\t  break;\n\n\t      default :\n\t          // Ignore blackslash per PDF spec...\n\t          break;\n\t    }\n\t  }\n\t  else if (ch == '(')\n\t  {\n\t    // Keep track of parenthesis\n\t    parens ++;\n\t  }\n\t  else if (ch == ')')\n\t  {\n\t    if (parens == 0)\n\t      break;\n\n\t    parens --;\n\t  }\n\n\t  if (bufptr < bufend)\n\t  {\n\t    // Normal character...\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\n\tif (ch != ')')\n\t{\n\t  _pdfioFileError(tb->pdf, \"Unterminated string literal.\");\n\t  return (false);\n\t}\n\n\tif (saw_nul)\n\t{\n\t  // Convert to a hex (binary) string...\n\t  char\t*litptr,\t\t// Pointer to literal character\n\t\t*hexptr;\t\t// Pointer to hex character\n\t  size_t bytes = (size_t)(bufptr - buffer - 1);\n\t\t\t\t\t// Bytes of data...\n          static const char *hexchars = \"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n          PDFIO_DEBUG(\"_pdfioTokenRead: Converting nul-containing string to binary.\\n\");\n\n          if ((2 * (bytes + 1)) > bufsize)\n          {\n\t    // Out of space...\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n          }\n\n\t  *buffer = '<';\n\t  for (litptr = bufptr - 1, hexptr = buffer + 2 * bytes - 1; litptr > buffer; litptr --, hexptr -= 2)\n\t  {\n\t    int litch = *litptr;\t// Grab the character\n\n\t    hexptr[0] = hexchars[(litch >> 4) & 15];\n\t    hexptr[1] = hexchars[litch & 15];\n\t  }\n\t  bufptr = buffer + 2 * bytes + 1;\n\t}\n\tbreak;\n\n    case 'K' : // keyword\n\twhile ((ch = get_char(tb)) != EOF && !isspace(ch))\n\t{\n\t  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)\n\t  {\n\t    // End of keyword...\n\t    tb->bufptr --;\n\t    break;\n\t  }\n\t  else if (bufptr < bufend)\n\t  {\n\t    // Normal character...\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space...\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\tbreak;\n\n    case 'N' : // number\n\twhile ((ch = get_char(tb)) != EOF && !isspace(ch))\n\t{\n\t  if (!isdigit(ch) && ch != '.')\n\t  {\n\t    // End of number...\n\t    tb->bufptr --;\n\t    break;\n\t  }\n\t  else if (bufptr < bufend)\n\t  {\n\t    // Normal character...\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space...\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\tbreak;\n\n    case '/' : // \"/name\"\n\twhile ((ch = get_char(tb)) != EOF && !isspace(ch))\n\t{\n\t  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)\n\t  {\n\t    // End of keyword...\n\t    tb->bufptr --;\n\t    break;\n\t  }\n\t  else if (ch == '#')\n\t  {\n\t    // Quoted character (#xx) in name...\n\t    int\ti;\t\t\t// Looping var\n\n\t    for (i = 0, ch = 0; i < 2; i ++)\n\t    {\n\t      int tch = get_char(tb);\n\n\t      if (!isxdigit(tch & 255))\n\t      {\n\t\t_pdfioFileError(tb->pdf, \"Bad # escape in name.\");\n\t\treturn (false);\n\t      }\n\t      else if (isdigit(tch))\n\t\tch = ((ch & 255) << 4) | (tch - '0');\n\t      else\n\t\tch = ((ch & 255) << 4) | (tolower(tch) - 'a' + 10);\n\t    }\n\t  }\n\n\t  if (bufptr < bufend)\n\t  {\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\tbreak;\n\n    case '<' : // Potential hex string\n\tif ((ch = get_char(tb)) == '<')\n\t{\n\t  // Dictionary delimiter\n\t  *bufptr++ = (char)ch;\n\t  break;\n\t}\n\telse if (!isspace(ch & 255) && !isxdigit(ch & 255))\n\t{\n\t  _pdfioFileError(tb->pdf, \"Syntax error: '<%c'\", ch);\n\t  return (false);\n\t}\n\n        do\n\t{\n\t  if (isxdigit(ch))\n\t  {\n\t    if (bufptr < bufend)\n\t    {\n\t      // Hex digit\n\t      *bufptr++ = (char)ch;\n\t    }\n\t    else\n\t    {\n\t      // Too large\n\t      _pdfioFileError(tb->pdf, \"Token too large.\");\n\t      return (false);\n\t    }\n\t  }\n\t  else if (!isspace(ch))\n\t  {\n\t    _pdfioFileError(tb->pdf, \"Invalid hex string character '%c'.\", ch);\n\t    return (false);\n\t  }\n\t}\n\twhile ((ch = get_char(tb)) != EOF && ch != '>');\n\n\tif (ch == EOF)\n\t{\n\t  _pdfioFileError(tb->pdf, \"Unterminated hex string.\");\n\t  return (false);\n\t}\n\tbreak;\n\n    case '>' : // Dictionary\n\tif ((ch = get_char(tb)) == '>')\n\t{\n\t  *bufptr++ = '>';\n\t}\n\telse\n\t{\n\t  _pdfioFileError(tb->pdf, \"Syntax error: '>%c'.\", ch);\n\t  return (false);\n\t}\n\tbreak;\n  }\n\n  *bufptr = '\\0';\n\n  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);\n\n  return (bufptr > buffer);\n}\n\n\n//\n// 'get_char()' - Get a character from the token buffer.\n//\n\nstatic int\t\t\t\t// O - Character or `EOF` on end-of-file\nget_char(_pdfio_token_t *tb)\t\t// I - Token buffer\n{\n  ssize_t\tbytes;\t\t\t// Bytes peeked\n\n\n  // Refill the buffer as needed...\n  if (tb->bufptr >= tb->bufend)\n  {\n    // Consume previous bytes...\n    if (tb->bufend > tb->buffer)\n    {\n      PDFIO_DEBUG(\"get_char: Consuming %d bytes.\\n\", (int)(tb->bufend - tb->buffer));\n      (tb->consume_cb)(tb->cb_data, (size_t)(tb->bufend - tb->buffer));\n    }\n\n    // Peek new bytes...\n    if ((bytes = (tb->peek_cb)(tb->cb_data, tb->buffer, sizeof(tb->buffer))) <= 0)\n    {\n      tb->bufptr = tb->bufend = tb->buffer;\n      return (EOF);\n    }\n\n    // Update pointers...\n    tb->bufptr = tb->buffer;\n    tb->bufend = tb->buffer + bytes;\n\n#ifdef DEBUG\n    unsigned char *ptr;\t\t\t// Pointer into buffer\n\n    PDFIO_DEBUG(\"get_char: Read '\");\n    for (ptr = tb->buffer; ptr < tb->bufend; ptr ++)\n    {\n      if (*ptr < ' ' || *ptr == 0x7f)\n        PDFIO_DEBUG(\"\\\\%03o\", *ptr);\n      else\n        PDFIO_DEBUG(\"%c\", *ptr);\n    }\n    PDFIO_DEBUG(\"'\\n\");\n#endif // DEBUG\n  }\n\n  // Return the next character...\n  return (*(tb->bufptr)++);\n}\n", "//\n// PDF value functions for PDFio.\n//\n// Copyright \u00a9\u00a02021 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n\n\n//\n// '_pdfioValueCopy()' - Copy a value to a PDF file.\n//\n\n_pdfio_value_t\t*\n_pdfioValueCopy(pdfio_file_t   *pdfdst,\t// I - Destination PDF file\n                _pdfio_value_t *vdst,\t// I - Destination value\n                pdfio_file_t   *pdfsrc,\t// I - Source PDF file\n                _pdfio_value_t *vsrc)\t// I - Source value\n{\n  pdfio_obj_t\t*obj;\t\t\t// Object reference\n#ifdef DEBUG\n  static const char * const types[] =\t// Type strings for debug\n  {\n    \"PDFIO_VALTYPE_NONE\",\n    \"PDFIO_VALTYPE_ARRAY\",\n    \"PDFIO_VALTYPE_BINARY\",\n    \"PDFIO_VALTYPE_BOOLEAN\",\n    \"PDFIO_VALTYPE_DATE\",\n    \"PDFIO_VALTYPE_DICT\",\n    \"PDFIO_VALTYPE_INDIRECT\",\n    \"PDFIO_VALTYPE_NAME\",\n    \"PDFIO_VALTYPE_NULL\",\n    \"PDFIO_VALTYPE_NUMBER\",\n    \"PDFIO_VALTYPE_STRING\"\n  };\n#endif // DEBUG\n\n\n  PDFIO_DEBUG(\"_pdfioValueCopy(pdfdst=%p, vdst=%p, pdfsrc=%p, vsrc=%p(%s))\\n\", pdfdst, vdst, pdfsrc, vsrc, types[vsrc->type]);\n\n  if (pdfdst == pdfsrc && vsrc->type != PDFIO_VALTYPE_BINARY)\n  {\n    // For the same document we can copy the values without any other effort\n    // unless there is a binary (hex string) value...\n    *vdst = *vsrc;\n    return (vdst);\n  }\n\n  // Not the same document or a binary value, do a deep copy...\n  switch (vsrc->type)\n  {\n    case PDFIO_VALTYPE_INDIRECT :\n        if ((obj = _pdfioFileFindMappedObj(pdfdst, pdfsrc, vsrc->value.indirect.number)) == NULL)\n        {\n          obj = pdfioObjCopy(pdfdst, pdfioFileFindObj(pdfsrc, vsrc->value.indirect.number));\n\t}\n\n        if (!obj)\n          return (NULL);\n\n\tvdst->value.indirect.number     = obj->number;\n\tvdst->value.indirect.generation = obj->generation;\n\tbreak;\n\n    default :\n        return (NULL);\n\n    case PDFIO_VALTYPE_ARRAY :\n        vdst->value.array = pdfioArrayCopy(pdfdst, vsrc->value.array);\n        break;\n\n    case PDFIO_VALTYPE_BINARY :\n        if ((vdst->value.binary.data = (unsigned char *)malloc(vsrc->value.binary.datalen)) == NULL)\n        {\n          _pdfioFileError(pdfdst, \"Unable to allocate memory for a binary string - %s\", strerror(errno));\n          return (NULL);\n        }\n\n        vdst->value.binary.datalen = vsrc->value.binary.datalen;\n        memcpy(vdst->value.binary.data, vsrc->value.binary.data, vdst->value.binary.datalen);\n        break;\n\n    case PDFIO_VALTYPE_BOOLEAN :\n    case PDFIO_VALTYPE_DATE :\n    case PDFIO_VALTYPE_NUMBER :\n\t*vdst = *vsrc;\n        return (vdst);\n\n    case PDFIO_VALTYPE_DICT :\n        vdst->value.dict = pdfioDictCopy(pdfdst, vsrc->value.dict);\n        break;\n\n    case PDFIO_VALTYPE_NAME :\n    case PDFIO_VALTYPE_STRING :\n        vdst->value.name = pdfioStringCreate(pdfdst, vsrc->value.name);\n        break;\n  }\n\n  vdst->type = vsrc->type;\n\n  return (vdst);\n}\n\n\n//\n// '_pdfioValueDebug()' - Print the contents of a value.\n//\n\nvoid\n_pdfioValueDebug(_pdfio_value_t *v,\t// I - Value\n\t\t FILE           *fp)\t// I - Output file\n{\n  switch (v->type)\n  {\n    case PDFIO_VALTYPE_ARRAY :\n        _pdfioArrayDebug(v->value.array, fp);\n\tbreak;\n    case PDFIO_VALTYPE_BINARY :\n\t{\n\t  size_t\ti;\t\t// Looping var\n\t  unsigned char\t*ptr;\t\t// Pointer into data\n\n\t  putc('<', fp);\n\t  for (i = v->value.binary.datalen, ptr = v->value.binary.data; i > 0; i --, ptr ++)\n\t    fprintf(fp, \"%02X\", *ptr);\n\t  putc('>', fp);\n\t}\n\tbreak;\n    case PDFIO_VALTYPE_BOOLEAN :\n\tfputs(v->value.boolean ? \" true\" : \" false\", fp);\n\tbreak;\n    case PDFIO_VALTYPE_DATE :\n        {\n\t  struct tm\tdateval;\t// Date value\n\n#ifdef _WIN32\n          gmtime_s(&dateval, &v->value.date);\n#else\n          gmtime_r(&v->value.date, &dateval);\n#endif // _WIN32\n\n          fprintf(fp, \"(D:%04d%02d%02d%02d%02d%02dZ)\", dateval.tm_year + 1900, dateval.tm_mon + 1, dateval.tm_mday, dateval.tm_hour, dateval.tm_min, dateval.tm_sec);\n        }\n        break;\n    case PDFIO_VALTYPE_DICT :\n\tfputs(\"<<\", fp);\n\t_pdfioDictDebug(v->value.dict, fp);\n\tfputs(\">>\", fp);\n\tbreak;\n    case PDFIO_VALTYPE_INDIRECT :\n\tfprintf(fp, \" %lu %u R\", (unsigned long)v->value.indirect.number, v->value.indirect.generation);\n\tbreak;\n    case PDFIO_VALTYPE_NAME :\n\tfprintf(fp, \"/%s\", v->value.name);\n\tbreak;\n    case PDFIO_VALTYPE_NULL :\n\tfputs(\" null\", fp);\n\tbreak;\n    case PDFIO_VALTYPE_NUMBER :\n\tfprintf(fp, \" %g\", v->value.number);\n\tbreak;\n    case PDFIO_VALTYPE_STRING :\n\tfprintf(fp, \"(%s)\", v->value.string);\n\tbreak;\n\n    default :\n        break;\n  }\n}\n\n\n//\n// '_pdfioValueDelete()' - Free the memory used by a value.\n//\n\nvoid\n_pdfioValueDelete(_pdfio_value_t *v)\t// I - Value\n{\n  if (v->type == PDFIO_VALTYPE_BINARY)\n    free(v->value.binary.data);\n}\n\n\n//\n// '_pdfioValueRead()' - Read a value from a file.\n//\n\n_pdfio_value_t *\t\t\t// O - Value or `NULL` on error/EOF\n_pdfioValueRead(pdfio_file_t   *pdf,\t// I - PDF file\n                pdfio_obj_t    *obj,\t// I - Object, if any\n                _pdfio_token_t *tb,\t// I - Token buffer/stack\n                _pdfio_value_t *v,\t// I - Value\n                size_t         depth)\t// I - Depth of value\n{\n  char\t\ttoken[32768];\t\t// Token buffer\n#ifdef DEBUG\n  static const char * const valtypes[] =\n  {\n    \"<<none>>\",\t\t\t\t// No value, not set\n    \"array\",\t\t\t\t// Array\n    \"hex-string\",\t\t\t// Binary data\n    \"boolean\",\t\t\t\t// Boolean\n    \"date\",\t\t\t\t// Date/time\n    \"dict\",\t\t\t\t// Dictionary\n    \"indirect\",\t\t\t\t// Indirect object (N G obj)\n    \"name\",\t\t\t\t// Name\n    \"null\",\t\t\t\t// Null object\n    \"number\",\t\t\t\t// Number (integer or real)\n    \"string\"\t\t\t\t// String\n  };\n#endif // DEBUG\n\n\n  PDFIO_DEBUG(\"_pdfioValueRead(pdf=%p, obj=%p, v=%p)\\n\", pdf, obj, v);\n\n  if (!_pdfioTokenGet(tb, token, sizeof(token)))\n    return (NULL);\n\n  if (!strcmp(token, \"[\"))\n  {\n    // Start of array\n    if (depth >= PDFIO_MAX_DEPTH)\n    {\n      _pdfioFileError(pdf, \"Too many nested arrays.\");\n      return (NULL);\n    }\n\n    v->type = PDFIO_VALTYPE_ARRAY;\n    if ((v->value.array = _pdfioArrayRead(pdf, obj, tb, depth + 1)) == NULL)\n      return (NULL);\n  }\n  else if (!strcmp(token, \"<<\"))\n  {\n    // Start of dictionary\n    if (depth >= PDFIO_MAX_DEPTH)\n    {\n      _pdfioFileError(pdf, \"Too many nested dictionaries.\");\n      return (NULL);\n    }\n\n    v->type = PDFIO_VALTYPE_DICT;\n    if ((v->value.dict = _pdfioDictRead(pdf, obj, tb, depth + 1)) == NULL)\n      return (NULL);\n  }\n  else if (!strncmp(token, \"(D:\", 3))\n  {\n    // Possible date value of the form:\n    //\n    //   (D:YYYYMMDDhhmmssZ)\n    //   (D:YYYYMMDDhhmmss+HH'mm)\n    //   (D:YYYYMMDDhhmmss-HH'mm)\n    //\n    int\t\ti;\t\t\t// Looping var\n    struct tm\tdateval;\t\t// Date value\n    int\t\toffset;\t\t\t// Date offset\n\n    for (i = 3; i < 17; i ++)\n    {\n      if (!isdigit(token[i] & 255))\n        break;\n    }\n\n    if (i >= 17)\n    {\n      if (token[i] == 'Z')\n      {\n        i ++;\n      }\n      else if (token[i] == '-' || token[i] == '+')\n      {\n        if (isdigit(token[i + 1] & 255) && isdigit(token[i + 2] & 255) && token[i + 3] == '\\'' && isdigit(token[i + 4] & 255) && isdigit(token[i + 5] & 255))\n        {\n          i += 6;\n          if (token[i] == '\\'')\n            i ++;\n\t}\n      }\n    }\n\n    if (token[i])\n    {\n      // Just a string...\n      v->type         = PDFIO_VALTYPE_STRING;\n      v->value.string = pdfioStringCreate(pdf, token + 1);\n    }\n    else\n    {\n      // Date value...\n      memset(&dateval, 0, sizeof(dateval));\n\n      dateval.tm_year = (token[3] - '0') * 1000 + (token[4] - '0') * 100 + (token[5] - '0') * 10 + token[6] - '0' - 1900;\n      dateval.tm_mon  = (token[7] - '0') * 10 + token[8] - '0' - 1;\n      dateval.tm_mday = (token[9] - '0') * 10 + token[10] - '0';\n      dateval.tm_hour = (token[11] - '0') * 10 + token[12] - '0';\n      dateval.tm_min  = (token[13] - '0') * 10 + token[14] - '0';\n      dateval.tm_sec  = (token[15] - '0') * 10 + token[16] - '0';\n\n      if (token[17] == 'Z')\n      {\n        offset = 0;\n      }\n      else\n      {\n        offset = (token[18] - '0') * 600 + (token[19] - '0') * 60 + (token[20] - '0') * 10 + token[21] - '0';\n        if (token[17] == '-')\n          offset = -offset;\n      }\n\n      v->type       = PDFIO_VALTYPE_DATE;\n      v->value.date = mktime(&dateval) + offset;\n    }\n  }\n  else if (token[0] == '(')\n  {\n    // String\n    v->type         = PDFIO_VALTYPE_STRING;\n    v->value.string = pdfioStringCreate(pdf, token + 1);\n  }\n  else if (token[0] == '/')\n  {\n    // Name\n    v->type       = PDFIO_VALTYPE_NAME;\n    v->value.name = pdfioStringCreate(pdf, token + 1);\n  }\n  else if (token[0] == '<')\n  {\n    // Hex string\n    const char\t\t*tokptr;\t// Pointer into token\n    unsigned char\t*dataptr;\t// Pointer into data\n\n    v->type                 = PDFIO_VALTYPE_BINARY;\n    v->value.binary.datalen = strlen(token) / 2;\n    if ((v->value.binary.data = (unsigned char *)malloc(v->value.binary.datalen)) == NULL)\n    {\n      _pdfioFileError(pdf, \"Out of memory for hex string.\");\n      return (NULL);\n    }\n\n    // Convert hex to binary...\n    tokptr  = token + 1;\n    dataptr = v->value.binary.data;\n\n    while (*tokptr)\n    {\n      int\td;\t\t\t// Data value\n\n      if (isdigit(*tokptr))\n\td = (*tokptr++ - '0') << 4;\n      else\n\td = (tolower(*tokptr++) - 'a' + 10) << 4;\n\n      if (*tokptr)\n      {\n\t// PDF allows writers to drop a trailing 0...\n\tif (isdigit(*tokptr))\n\t  d |= *tokptr++ - '0';\n\telse\n\t  d |= tolower(*tokptr++) - 'a' + 10;\n      }\n\n      *dataptr++ = (unsigned char)d;\n    }\n\n    if (obj && pdf->encryption)\n    {\n      // Decrypt the string...\n      _pdfio_crypto_ctx_t ctx;\t\t// Decryption context\n      _pdfio_crypto_cb_t cb;\t\t// Decryption callback\n      size_t\tivlen;\t\t\t// Number of initialization vector bytes\n      uint8_t\ttemp[32768];\t\t// Temporary buffer for decryption\n      size_t\ttemplen;\t\t// Number of actual data bytes\n\n      if (v->value.binary.datalen > (sizeof(temp) - 32))\n      {\n\t_pdfioFileError(pdf, \"Unable to read encrypted binary string - too long.\");\n\treturn (false);\n      }\n\n      cb      = _pdfioCryptoMakeReader(pdf, obj, &ctx, v->value.binary.data, &ivlen);\n      templen = (cb)(&ctx, temp, v->value.binary.data + ivlen, v->value.binary.datalen - ivlen);\n\n      // Copy the decrypted string back to the value and adjust the length...\n      memcpy(v->value.binary.data, temp, templen);\n\n      if (pdf->encryption >= PDFIO_ENCRYPTION_AES_128)\n        v->value.binary.datalen = templen - temp[templen - 1];\n      else\n\tv->value.binary.datalen = templen;\n    }\n  }\n  else if (strchr(\"0123456789-+.\", token[0]) != NULL)\n  {\n    // Number or indirect object reference\n    if (isdigit(token[0]) && !strchr(token, '.'))\n    {\n      // Integer or object ref...\n      unsigned char *tempptr;\t\t// Pointer into buffer\n\n#ifdef DEBUG\n      PDFIO_DEBUG(\"_pdfioValueRead: %d bytes left in buffer: '\", (int)(tb->bufend - tb->bufptr));\n      for (tempptr = tb->bufptr; tempptr < tb->bufend; tempptr ++)\n      {\n\tif (*tempptr < ' ' || *tempptr == 0x7f)\n\t  PDFIO_DEBUG(\"\\\\%03o\", *tempptr);\n\telse\n\t  PDFIO_DEBUG(\"%c\", *tempptr);\n      }\n      PDFIO_DEBUG(\"'.\\n\");\n#endif // DEBUG\n\n      if ((tb->bufend - tb->bufptr) < 10)\n      {\n        // Fill up buffer...\n        ssize_t\tbytes;\t\t\t// Bytes peeked\n\n        _pdfioTokenFlush(tb);\n\n        if ((bytes = (tb->peek_cb)(tb->cb_data, tb->buffer, sizeof(tb->buffer))) > 0)\n\t  tb->bufend = tb->buffer + bytes;\n\n#ifdef DEBUG\n\tPDFIO_DEBUG(\"_pdfioValueRead: %d bytes now in buffer: '\", (int)(tb->bufend - tb->bufptr));\n\tfor (tempptr = tb->bufptr; tempptr < tb->bufend; tempptr ++)\n\t{\n\t  if (*tempptr < ' ' || *tempptr == 0x7f)\n\t    PDFIO_DEBUG(\"\\\\%03o\", *tempptr);\n\t  else\n\t    PDFIO_DEBUG(\"%c\", *tempptr);\n\t}\n\tPDFIO_DEBUG(\"'.\\n\");\n#endif // DEBUG\n      }\n\n      tempptr = tb->bufptr;\n\n      while (tempptr < tb->bufend && isspace(*tempptr & 255))\n        tempptr ++;\t\t\t// Skip whitespace as needed...\n\n      if (tempptr < tb->bufend && isdigit(*tempptr & 255))\n      {\n        // Integer...\n        long generation = 0;\t\t// Generation number\n\n        while (tempptr < tb->bufend && isdigit(*tempptr & 255))\n        {\n          generation = generation * 10 + *tempptr - '0';\n          tempptr ++;\n        }\n\n\twhile (tempptr < tb->bufend && isspace(*tempptr & 255))\n\t  tempptr ++;\t\t\t// Skip whitespace\n\n\tif (tempptr < tb->bufend && *tempptr == 'R')\n\t{\n\t  // Reference!\n\t  PDFIO_DEBUG(\"_pdfioValueRead: Consuming %d bytes.\\n\", (int)(tempptr - tb->bufptr + 1));\n\t  tb->bufptr = tempptr + 1;\n\n#ifdef DEBUG\n\t  PDFIO_DEBUG(\"_pdfioValueRead: Next bytes are '\");\n\t  for (tempptr = tb->bufptr; tempptr < tb->bufend; tempptr ++)\n\t  {\n\t    if (*tempptr < ' ' || *tempptr == 0x7f)\n\t      PDFIO_DEBUG(\"\\\\%03o\", *tempptr);\n\t    else\n\t      PDFIO_DEBUG(\"%c\", *tempptr);\n\t  }\n\t  PDFIO_DEBUG(\"'.\\n\");\n#endif // DEBUG\n\n\t  v->type                      = PDFIO_VALTYPE_INDIRECT;\n\t  v->value.indirect.number     = (size_t)strtoimax(token, NULL, 10);\n\t  v->value.indirect.generation = (unsigned short)generation;\n\n\t  PDFIO_DEBUG(\"_pdfioValueRead: Returning indirect value %lu %u R.\\n\", (unsigned long)v->value.indirect.number, v->value.indirect.generation);\n\n\t  return (v);\n\t}\n      }\n    }\n\n    // If we get here, we have a number...\n    v->type         = PDFIO_VALTYPE_NUMBER;\n    v->value.number = (double)strtod(token, NULL);\n  }\n  else if (!strcmp(token, \"true\") || !strcmp(token, \"false\"))\n  {\n    // Boolean value\n    v->type          = PDFIO_VALTYPE_BOOLEAN;\n    v->value.boolean = !strcmp(token, \"true\");\n  }\n  else if (!strcmp(token, \"null\"))\n  {\n    // null value\n    v->type = PDFIO_VALTYPE_NULL;\n  }\n  else\n  {\n    _pdfioFileError(pdf, \"Unexpected '%s' token seen.\", token);\n    return (NULL);\n  }\n\n  PDFIO_DEBUG(\"_pdfioValueRead: Returning %s value.\\n\", valtypes[v->type]);\n\n  return (v);\n}\n\n\n//\n// '_pdfioValueWrite()' - Write a value to a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioValueWrite(pdfio_file_t   *pdf,\t// I - PDF file\n                 pdfio_obj_t    *obj,\t// I - Object, if any\n                 _pdfio_value_t *v,\t// I - Value\n                 off_t          *length)// O - Offset to /Length value, if any\n{\n  switch (v->type)\n  {\n    default :\n        return (false);\n\n    case PDFIO_VALTYPE_ARRAY :\n        return (_pdfioArrayWrite(v->value.array, obj));\n\n    case PDFIO_VALTYPE_BINARY :\n        {\n          size_t\tdatabytes;\t// Bytes to write\n          uint8_t\ttemp[32768],\t// Temporary buffer for encryption\n\t\t\t*dataptr;\t// Pointer into data\n\n          if (obj && pdf->encryption)\n          {\n\t    // Write encrypted string...\n\t    _pdfio_crypto_ctx_t ctx;\t// Encryption context\n\t    _pdfio_crypto_cb_t cb;\t// Encryption callback\n\t    size_t\tivlen;\t\t// Number of initialization vector bytes\n\n            if (v->value.binary.datalen > (sizeof(temp) - 32))\n            {\n\t      _pdfioFileError(pdf, \"Unable to write encrypted binary string - too long.\");\n\t      return (false);\n            }\n\n\t    cb        = _pdfioCryptoMakeWriter(pdf, obj, &ctx, temp, &ivlen);\n\t    databytes = (cb)(&ctx, temp + ivlen, v->value.binary.data, v->value.binary.datalen) + ivlen;\n\t    dataptr   = temp;\n          }\n          else\n          {\n            dataptr   = v->value.binary.data;\n            databytes = v->value.binary.datalen;\n          }\n\n          if (!_pdfioFilePuts(pdf, \"<\"))\n            return (false);\n\n          for (; databytes > 1; databytes -= 2, dataptr += 2)\n          {\n            if (!_pdfioFilePrintf(pdf, \"%02X%02X\", dataptr[0], dataptr[1]))\n              return (false);\n          }\n\n          if (databytes > 0)\n            return (_pdfioFilePrintf(pdf, \"%02X>\", dataptr[0]));\n          else\n            return (_pdfioFilePuts(pdf, \">\"));\n        }\n\n    case PDFIO_VALTYPE_BOOLEAN :\n        if (v->value.boolean)\n          return (_pdfioFilePuts(pdf, \" true\"));\n        else\n          return (_pdfioFilePuts(pdf, \" false\"));\n\n    case PDFIO_VALTYPE_DATE :\n        {\n          struct tm\tdate;\t\t// Date values\n          char\t\tdatestr[32];\t// Formatted date value\n\n#ifdef _WIN32\n          gmtime_s(&date, &v->value.date);\n#else\n\t  gmtime_r(&v->value.date, &date);\n#endif // _WIN32\n\n\t  snprintf(datestr, sizeof(datestr), \"D:%04d%02d%02d%02d%02d%02dZ\", date.tm_year + 1900, date.tm_mon + 1, date.tm_mday, date.tm_hour, date.tm_min, date.tm_sec);\n\n\t  if (obj && pdf->encryption)\n\t  {\n\t    // Write encrypted string...\n\t    uint8_t\ttemp[32768],\t// Encrypted bytes\n\t\t\t*tempptr;\t// Pointer into encrypted bytes\n\t    _pdfio_crypto_ctx_t ctx;\t// Encryption context\n\t    _pdfio_crypto_cb_t cb;\t// Encryption callback\n\t    size_t\tlen = strlen(datestr),\n\t\t\t\t\t  // Length of value\n\t\t\tivlen,\t\t// Number of initialization vector bytes\n\t\t\ttempbytes;\t// Number of output bytes\n\n\t    cb        = _pdfioCryptoMakeWriter(pdf, obj, &ctx, temp, &ivlen);\n\t    tempbytes = (cb)(&ctx, temp + ivlen, (const uint8_t *)datestr, len) + ivlen;\n\n\t    if (!_pdfioFilePuts(pdf, \"<\"))\n\t      return (false);\n\n\t    for (tempptr = temp; tempbytes > 1; tempbytes -= 2, tempptr += 2)\n\t    {\n\t      if (!_pdfioFilePrintf(pdf, \"%02X%02X\", tempptr[0], tempptr[1]))\n\t\treturn (false);\n\t    }\n\n            if (tempbytes > 0)\n              return (_pdfioFilePrintf(pdf, \"%02X>\", *tempptr));\n            else\n\t      return (_pdfioFilePuts(pdf, \">\"));\n\t  }\n\t  else\n\t  {\n\t    return (_pdfioFilePrintf(pdf, \"(%s)\", datestr));\n\t  }\n        }\n\n    case PDFIO_VALTYPE_DICT :\n        return (_pdfioDictWrite(v->value.dict, obj, length));\n\n    case PDFIO_VALTYPE_INDIRECT :\n        return (_pdfioFilePrintf(pdf, \" %lu %u R\", (unsigned long)v->value.indirect.number, v->value.indirect.generation));\n\n    case PDFIO_VALTYPE_NAME :\n        return (_pdfioFilePrintf(pdf, \"/%s\", v->value.name));\n\n    case PDFIO_VALTYPE_NULL :\n        return (_pdfioFilePuts(pdf, \" null\"));\n\n    case PDFIO_VALTYPE_NUMBER :\n        return (_pdfioFilePrintf(pdf, \" %g\", v->value.number));\n\n    case PDFIO_VALTYPE_STRING :\n        if (obj && pdf->encryption)\n        {\n          // Write encrypted string...\n          uint8_t\ttemp[32768],\t// Encrypted bytes\n\t\t\t*tempptr;\t// Pointer into encrypted bytes\n          _pdfio_crypto_ctx_t ctx;\t// Encryption context\n          _pdfio_crypto_cb_t cb;\t// Encryption callback\n          size_t\tlen = strlen(v->value.string),\n\t\t\t\t\t// Length of value\n\t\t\tivlen,\t\t// Number of initialization vector bytes\n\t\t\ttempbytes;\t// Number of output bytes\n\n          if (len > (sizeof(temp) - 32))\n          {\n            _pdfioFileError(pdf, \"Unable to write encrypted string - too long.\");\n            return (false);\n          }\n\n          cb        = _pdfioCryptoMakeWriter(pdf, obj, &ctx, temp, &ivlen);\n          tempbytes = (cb)(&ctx, temp + ivlen, (const uint8_t *)v->value.string, len) + ivlen;\n\n          if (!_pdfioFilePuts(pdf, \"<\"))\n            return (false);\n\n          for (tempptr = temp; tempbytes > 1; tempbytes -= 2, tempptr += 2)\n          {\n            if (!_pdfioFilePrintf(pdf, \"%02X%02X\", tempptr[0], tempptr[1]))\n              return (false);\n          }\n\n          if (tempbytes > 0)\n            return (_pdfioFilePrintf(pdf, \"%02X>\", *tempptr));\n          else\n\t    return (_pdfioFilePuts(pdf, \">\"));\n        }\n        else\n        {\n          // Write unencrypted string...\n          const char *start,\t\t// Start of fragment\n\t\t     *end;\t\t// End of fragment\n\n          if (!_pdfioFilePuts(pdf, \"(\"))\n            return (false);\n\n          // Write a quoted string value...\n          for (start = v->value.string; *start; start = end)\n          {\n            // Find the next character that needs to be quoted...\n            for (end = start; *end; end ++)\n            {\n              if (*end == '\\\\' || *end == ')' || (*end & 255) < ' ')\n                break;\n            }\n\n            if (end > start)\n            {\n              // Write unquoted (safe) characters...\n\t      if (!_pdfioFileWrite(pdf, start, (size_t)(end - start)))\n\t\treturn (false);\n\t    }\n\n            if (*end)\n            {\n              // Quote this character...\n              bool success;\t\t// Did the write work?\n\n              if (*end == '\\\\' || *end == ')')\n                success = _pdfioFilePrintf(pdf, \"\\\\%c\", *end);\n              else\n                success = _pdfioFilePrintf(pdf, \"\\\\%03o\", *end);\n\n              if (!success)\n                return (false);\n\n              end ++;\n            }\n          }\n\n          return (_pdfioFilePuts(pdf, \")\"));\n        }\n  }\n\n  return (false);\n}\n"], "fixing_code": ["Changes in PDFio\n================\n\n\nv1.1.0 (February 3, 2023)\n-------------------------\n\n- CVE-2023-nnnn: Fixed a potential denial-of-service with corrupt PDF files.\n- Added `pdfioFileCreateTemporary` function (Issue #29)\n- Added `pdfioDictIterateKeys` function (Issue #31)\n- Added `pdfioContentPathEnd` function.\n- Added protection against opening multiple streams in the same file at the\n  same time.\n- Documentation updates (Issue #37)\n- Fixed \"install-shared\" target (Issue #32)\n- Fixed `pdfioFileGet...` metadata APIs (Issue #33)\n- Fixed `pdfioContentMatrixRotate` function.\n\n\nv1.0.1 (March 2, 2022)\n----------------------\n\n- Added missing `pdfioPageGetNumStreams` and `pdfioPageOpenStream` functions.\n- Added demo pdfiototext utility.\n- Fixed bug in `pdfioStreamGetToken`.\n\n\nv1.0.0 (December 14, 2021)\n--------------------------\n\n- First stable release.\n\n\nv1.0rc1 (November 30, 2021)\n---------------------------\n\n- Fixed a few stack/buffer overflow bugs discovered via fuzzing.\n\n\nv1.0b2 (November 7, 2021)\n-------------------------\n\n- Added `pdfioFileCreateOutput` API to support streaming output of PDF\n  (Issue #21)\n- Fixed `all-shared` target (Issue #22)\n- Fixed memory leaks (Issue #23)\n- Updated `pdfioContentSetDashPattern` to accept `double` values (Issue #25)\n- Added support for reading and writing encrypted PDFs (Issue #26)\n- Fixed some issues identified by a Coverity scan.\n\n\nv1.0b1 (August 30, 2021)\n------------------------\n\n- Initial release\n", "#\n# Makefile for PDFio.\n#\n# Copyright \u00a9\u00a02021-2023 by Michael R Sweet.\n#\n# Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n# information.\n#\n\n# POSIX makefile\n.POSIX:\n\n# Build silently\n.SILENT:\n\n# Variables\nAR\t\t=\tar\nARFLAGS\t\t=\tcr\nCC\t\t=\tcc\nCFLAGS\t\t=\nCODESIGN_IDENTITY =\tDeveloper ID\nCOMMONFLAGS\t=\t-Os -g\n#COMMONFLAGS\t=\t-O0 -g -fsanitize=address\nCPPFLAGS\t=\t'-DPDFIO_VERSION=\"$(VERSION)\"'\nDESTDIR\t\t=\t$(DSTROOT)\nDSO\t\t=\tcc\nDSOFLAGS\t=\nDSONAME\t\t=\nLDFLAGS\t\t=\nLIBS\t\t=\t-lm -lz\nRANLIB\t\t=\tranlib\nVERSION\t\t=\t1.1.0\nprefix\t\t=\t/usr/local\n\n\n# Base rules\n.SUFFIXES:\t.c .h .o\n.c.o:\n\techo Compiling $<...\n\t$(CC) $(CFLAGS) $(CPPFLAGS) $(COMMONFLAGS) -c $<\n\n\n# Files\nPUBHEADERS\t=\t\\\n\t\t\tpdfio.h \\\n\t\t\tpdfio-content.h\nPUBOBJS\t\t=\t\\\n\t\t\tpdfio-aes.o \\\n\t\t\tpdfio-array.o \\\n\t\t\tpdfio-common.o \\\n\t\t\tpdfio-content.o \\\n\t\t\tpdfio-crypto.o \\\n\t\t\tpdfio-dict.o \\\n\t\t\tpdfio-file.o \\\n\t\t\tpdfio-md5.o \\\n\t\t\tpdfio-object.o \\\n\t\t\tpdfio-page.o \\\n\t\t\tpdfio-rc4.o \\\n\t\t\tpdfio-sha256.o \\\n\t\t\tpdfio-stream.o \\\n\t\t\tpdfio-string.o \\\n\t\t\tpdfio-token.o \\\n\t\t\tpdfio-value.o\nLIBOBJS\t\t=\t\\\n\t\t\t$(PUBOBJS) \\\n\t\t\tttf.o\nOBJS\t\t=\t\\\n\t\t\t$(LIBOBJS) \\\n\t\t\tpdfiototext.o \\\n\t\t\ttestpdfio.o\nTARGETS\t\t=\t\\\n\t\t\t$(DSONAME) \\\n\t\t\tlibpdfio.a \\\n\t\t\tpdfiototext \\\n\t\t\ttestpdfio\n\n\n# Make everything\nall:\t\t$(TARGETS)\n\nall-shared:\n\tif test `uname` = Darwin; then \\\n\t\t$(MAKE) DSONAME=\"libpdfio.1.dylib\" -$(MAKEFLAGS) all; \\\n\telse \\\n\t\t$(MAKE) COMMONFLAGS=\"-g -Os -fPIC\" DSONAME=\"libpdfio.so.1\" -$(MAKEFLAGS) all; \\\n\tfi\n\ndebug:\n\t$(MAKE) -$(MAKEFLAGS) COMMONFLAGS=\"-g -fsanitize=address -DDEBUG=1\" clean all\n\nmacos:\n\t$(MAKE) -$(MAKEFLAGS) COMMONFLAGS=\"-Os -mmacosx-version-min=10.14 -arch x86_64 -arch arm64\" clean all\n\n\n# Clean everything\nclean:\n\trm -f $(TARGETS) $(OBJS)\n\n\n# Install everything\ninstall:\t$(TARGETS)\n\techo Installing header files to $(DESTDIR)$(prefix)/include...\n\t-mkdir -p $(DESTDIR)$(prefix)/include\n\tcp $(PUBHEADERS) $(DESTDIR)$(prefix)/include\n\techo Installing library files to $(DESTDIR)$(prefix)/lib...\n\t-mkdir -p $(DESTDIR)$(prefix)/lib\n\tcp libpdfio.a $(DESTDIR)$(prefix)/lib\n\t$(RANLIB) $(DESTDIR)$(prefix)/lib/libpdfio.a\n\tif test \"x$(DSONAME)\" = xlibpdfio.so.1; then \\\n\t\tcp $(DSONAME) $(DESTDIR)$(prefix)/lib; \\\n\t\tln -sf libpdfio.so.1 $(DESTDIR)$(prefix)/lib/libpdfio.so; \\\n\telif test \"x$(DSONAME)\" = xlibpdfio.1.dylib; then \\\n\t\tcp $(DSONAME) $(DESTDIR)$(prefix)/lib; \\\n\t\tcodesign -s \"$(CODESIGN_IDENTITY)\" -o runtime --timestamp $(DESTDIR)$(prefix)/lib/libpdfio.1.dylib; \\\n\t\tln -sf libpdfio.1.dylib $(DESTDIR)$(prefix)/lib/libpdfio.dylib; \\\n\tfi\n\techo Installing pkg-config files to $(DESTDIR)$(prefix)/lib/pkgconfig...\n\t-mkdir -p $(DESTDIR)$(prefix)/lib/pkgconfig\n\techo 'prefix=\"$(prefix)\"' >$(DESTDIR)$(prefix)/lib/pkgconfig/pdfio.pc\n\techo 'Version: $(VERSION)' >>$(DESTDIR)$(prefix)/lib/pkgconfig/pdfio.pc\n\tcat pdfio.pc.in >>$(DESTDIR)$(prefix)/lib/pkgconfig/pdfio.pc\n\techo Installing documentation to $(DESTDIR)$(prefix)/share/doc/pdfio...\n\t-mkdir -p $(DESTDIR)$(prefix)/share/doc/pdfio\n\tcp doc/pdfio.html doc/pdfio-512.png LICENSE NOTICE $(DESTDIR)$(prefix)/share/doc/pdfio\n\techo Installing man page to $(DESTDIR)$(prefix)/share/man/man3...\n\t-mkdir -p $(DESTDIR)$(prefix)/share/man/man3\n\tcp doc/pdfio.3 $(DESTDIR)$(prefix)/share/man/man3\n\ninstall-shared:\n\tif test `uname` = Darwin; then \\\n\t\t$(MAKE) DSONAME=\"libpdfio.1.dylib\" -$(MAKEFLAGS) install; \\\n\telse \\\n\t\t$(MAKE) DSONAME=\"libpdfio.so.1\" -$(MAKEFLAGS) install; \\\n\tfi\n\n\n# Test everything\ntest:\ttestpdfio\n\t./testpdfio\n\nvalgrind:\ttestpdfio\n\tvalgrind --leak-check=full ./testpdfio\n\n\n# pdfio library\nlibpdfio.a:\t\t$(LIBOBJS)\n\techo Archiving $@...\n\t$(AR) $(ARFLAGS) $@ $(LIBOBJS)\n\t$(RANLIB) $@\n\nlibpdfio.so.1:\t\t$(LIBOBJS)\n\techo Linking $@...\n\t$(CC) $(DSOFLAGS) $(COMMONFLAGS) -shared -o $@ -Wl,-soname,$@ $(LIBOBJS) $(LIBS)\n\nlibpdfio.1.dylib:\t$(LIBOBJS)\n\techo Linking $@...\n\t$(CC) $(DSOFLAGS) $(COMMONFLAGS) -dynamiclib -o $@ -install_name $(prefix)/lib/$@ -current_version $(VERSION) -compatibility_version 1.0 $(LIBOBJS) $(LIBS)\n\n\n# pdfio1.def (Windows DLL exports file...)\n#\n# I'd love to use __declspec(dllexport) but MS puts it before the function\n# declaration instead of after like everyone else, and it breaks Codedoc and\n# other tools I rely on...\npdfio1.def: $(LIBOBJS) Makefile\n\techo Generating $@...\n\techo \"LIBRARY pdfio1\" >$@\n\techo \"VERSION 1.0\" >>$@\n\techo \"EXPORTS\" >>$@\n\tnm $(LIBOBJS) 2>/dev/null | grep \"T _\" | awk '{print $$3}' | \\\n\t\tgrep -v '^_ttf' | sed -e '1,$$s/^_//' | sort >>$@\n\n\n# pdfio text extraction (demo, doesn't handle a lot of things yet)\npdfiototext:\t\tpdfiototext.o libpdfio.a\n\techo Linking $@...\n\t$(CC) $(LDFLAGS) $(COMMONFLAGS) -o $@ pdfiototext.o libpdfio.a $(LIBS)\n\n\n# pdfio test program\ntestpdfio:\t\ttestpdfio.o libpdfio.a\n\techo Linking $@...\n\t$(CC) $(LDFLAGS) $(COMMONFLAGS) -o $@ testpdfio.o libpdfio.a $(LIBS)\n\n\n# Dependencies\n$(OBJS):\t\tpdfio.h pdfio-private.h Makefile\npdfio-content.o:\tpdfio-content.h ttf.h\nttf.o:\t\t\tttf.h\n\n# Make documentation using Codedoc <https://www.msweet.org/codedoc>\nDOCFLAGS\t=\t\\\n\t\t\t--author \"Michael R Sweet\" \\\n\t\t\t--copyright \"Copyright (c) 2021-2022 by Michael R Sweet\" \\\n\t\t\t--docversion $(VERSION)\n\n.PHONY: doc\ndoc:\n\techo Generating documentation...\n\tcodedoc $(DOCFLAGS) --title \"PDFio Programming Manual v$(VERSION)\" $(PUBHEADERS) $(PUBOBJS:.o=.c) --body doc/pdfio.md --coverimage doc/pdfio-512.png pdfio.xml >doc/pdfio.html\n\tcodedoc $(DOCFLAGS) --title \"PDFio Programming Manual v$(VERSION)\" --body doc/pdfio.md --coverimage doc/pdfio-epub.png pdfio.xml --epub doc/pdfio.epub\n\tcodedoc $(DOCFLAGS) --title \"pdf read/write library\" --man pdfio --section 3 --body doc/pdfio.md pdfio.xml >doc/pdfio.3\n\trm -f pdfio.xml\n\n\n# Fuzz-test the library <>\n.PHONY: afl\nafl:\n\t$(MAKE) -$(MAKEFLAGS) CC=\"afl-clang-fast\" COMMONFLAGS=\"-g\" clean all\n\ttest afl-output || rm -rf afl-output\n\tafl-fuzz -x afl-pdf.dict -i afl-input -o afl-output -V 600 -e pdf -t 5000 ./testpdfio @@\n\n\n# Analyze code with the Clang static analyzer <https://clang-analyzer.llvm.org>\nclang:\n\tclang $(CPPFLAGS) --analyze $(OBJS:.o=.c) 2>clang.log\n\trm -rf $(OBJS:.o=.plist)\n\ttest -s clang.log && (echo \"$(GHA_ERROR)Clang detected issues.\"; echo \"\"; cat clang.log; exit 1) || exit 0\n\n\n# Analyze code using Cppcheck <http://cppcheck.sourceforge.net>\ncppcheck:\n\tcppcheck $(CPPFLAGS) --template=gcc --addon=cert.py --suppressions-list=.cppcheck $(OBJS:.o=.c) 2>cppcheck.log\n\ttest -s cppcheck.log && (echo \"$(GHA_ERROR)Cppcheck detected issues.\"; echo \"\"; cat cppcheck.log; exit 1) || exit 0\n", "PDFio - PDF Read/Write Library\n\nCopyright \u00a9 2021-2023 by Michael R Sweet.\n\n(Optional) Exceptions to the Apache 2.0 License:\n================================================\n\nAs an exception, if, as a result of your compiling your source code, portions\nof this Software are embedded into an Object form of such source code, you\nmay redistribute such embedded portions in such Object form without complying\nwith the conditions of Sections 4(a), 4(b) and 4(d) of the License.\n\nIn addition, if you combine or link compiled forms of this Software with\nsoftware that is licensed under the GPLv2 (\"Combined Software\") and if a\ncourt of competent jurisdiction determines that the patent provision (Section\n3), the indemnity provision (Section 9) or other Section of the License\nconflicts with the conditions of the GPLv2, you may retroactively and\nprospectively choose to deem waived or otherwise exclude such Section(s) of\nthe License, but only in their entirety and only with respect to the Combined\nSoftware.\n", "//\n// Common support functions for pdfio.\n//\n// Copyright \u00a9\u00a02021-2023 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n\n\n//\n// Local functions...\n//\n\nstatic bool\tfill_buffer(pdfio_file_t *pdf);\nstatic ssize_t\tread_buffer(pdfio_file_t *pdf, char *buffer, size_t bytes);\nstatic bool\twrite_buffer(pdfio_file_t *pdf, const void *buffer, size_t bytes);\n\n\n//\n// '_pdfioFileConsume()' - Consume bytes from the file.\n//\n\nbool\t\t\t\t\t// O - `true` on sucess, `false` on EOF\n_pdfioFileConsume(pdfio_file_t *pdf,\t// I - PDF file\n                  size_t       bytes)\t// I - Bytes to consume\n{\n  PDFIO_DEBUG(\"_pdfioFileConsume(pdf=%p, bytes=%u)\\n\", pdf, (unsigned)bytes);\n\n  if ((size_t)(pdf->bufend - pdf->bufptr) > bytes)\n    pdf->bufptr += bytes;\n  else if (_pdfioFileSeek(pdf, (off_t)bytes, SEEK_CUR) < 0)\n    return (false);\n\n  PDFIO_DEBUG(\"_pdfioFileConsume: pos=%ld\\n\", (long)(pdf->bufpos + pdf->bufptr - pdf->buffer));\n\n  return (true);\n}\n\n\n//\n// '_pdfioFileDefaultError()' - Default error callback.\n//\n// The default error callback writes the error message to stderr and returns\n// `false` to halt.\n//\n\nbool\t\t\t\t\t// O - `false` to stop\n_pdfioFileDefaultError(\n    pdfio_file_t *pdf,\t\t\t// I - PDF file\n    const char   *message,\t\t// I - Error message\n    void         *data)\t\t\t// I - Callback data (unused)\n{\n  (void)data;\n\n  fprintf(stderr, \"%s: %s\\n\", pdf->filename, message);\n\n  return (false);\n}\n\n\n//\n// '_pdfioFileError()' - Display an error message.\n//\n\nbool\t\t\t\t\t// O - `true` to continue, `false` to stop\n_pdfioFileError(pdfio_file_t *pdf,\t// I - PDF file\n                const char   *format,\t// I - `printf`-style format string\n                ...)\t\t\t// I - Additional arguments as needed\n{\n  char\t\tbuffer[8192];\t\t// Message buffer\n  va_list\tap;\t\t\t// Argument pointer\n\n\n  va_start(ap, format);\n  vsnprintf(buffer, sizeof(buffer), format, ap);\n  va_end(ap);\n\n  PDFIO_DEBUG(\"_pdfioFileError: %s\\n\", buffer);\n\n  return ((pdf->error_cb)(pdf, buffer, pdf->error_data));\n}\n\n\n//\n// '_pdfioFileFlush()' - Flush any pending write data.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioFileFlush(pdfio_file_t *pdf)\t// I - PDF file\n{\n  PDFIO_DEBUG(\"_pdfioFileFlush(pdf=%p)\\n\", pdf);\n\n  if (pdf->bufptr > pdf->buffer)\n  {\n    if (!write_buffer(pdf, pdf->buffer, (size_t)(pdf->bufptr - pdf->buffer)))\n      return (false);\n\n    pdf->bufpos += pdf->bufptr - pdf->buffer;\n  }\n\n  pdf->bufptr = pdf->buffer;\n\n  return (true);\n}\n\n\n//\n// '_pdfioFileGetChar()' - Get a character from a PDF file.\n//\n\nint\t\t\t\t\t// O - Character or `-1` on EOF\n_pdfioFileGetChar(pdfio_file_t *pdf)\t// I - PDF file\n{\n  // If there is a character ready in the buffer, return it now...\n  if (pdf->bufptr < pdf->bufend)\n    return (*(pdf->bufptr ++));\n\n  // Otherwise try to fill the read buffer...\n  if (!fill_buffer(pdf))\n    return (-1);\n\n  // Then return the next character in the buffer...\n  return (*(pdf->bufptr ++));\n}\n\n\n//\n// '_pdfioFileGets()' - Read a line from a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on error\n_pdfioFileGets(pdfio_file_t *pdf,\t// I - PDF file\n               char         *buffer,\t// I - Line buffer\n\t       size_t       bufsize)\t// I - Size of line buffer\n{\n  bool\teol = false;\t\t\t// End of line?\n  char\t*bufptr = buffer,\t\t// Pointer into buffer\n\t*bufend = buffer + bufsize - 1;\t// Pointer to end of buffer\n\n\n  PDFIO_DEBUG(\"_pdfioFileGets(pdf=%p, buffer=%p, bufsize=%lu) bufpos=%ld, buffer=%p, bufptr=%p, bufend=%p\\n\", pdf, buffer, (unsigned long)bufsize, (long)pdf->bufpos, pdf->buffer, pdf->bufptr, pdf->bufend);\n\n  while (!eol)\n  {\n    // If there are characters ready in the buffer, use them...\n    while (!eol && pdf->bufptr < pdf->bufend && bufptr < bufend)\n    {\n      char ch = *(pdf->bufptr++);\t// Next character in buffer\n\n      if (ch == '\\n' || ch == '\\r')\n      {\n        // CR, LF, or CR + LF end a line...\n        eol = true;\n\n        if (ch == '\\r')\n        {\n          // Check for a LF after CR\n          if (pdf->bufptr >= pdf->bufend)\n          {\n            if (!fill_buffer(pdf))\n              break;\n\t  }\n\n\t  if (pdf->bufptr < pdf->bufend && *(pdf->bufptr) == '\\n')\n\t    pdf->bufptr ++;\n\t}\n      }\n      else\n        *bufptr++ = ch;\n    }\n\n    // Fill the read buffer as needed...\n    if (!eol)\n    {\n      if (!fill_buffer(pdf))\n        break;\n    }\n  }\n\n  *bufptr = '\\0';\n\n  PDFIO_DEBUG(\"_pdfioFileGets: Returning %s, '%s'\\n\", eol ? \"true\" : \"false\", buffer);\n\n  return (eol);\n}\n\n\n//\n// '_pdfioFilePeek()' - Peek at upcoming data in a PDF file.\n//\n\nssize_t\t\t\t\t\t// O - Number of bytes returned\n_pdfioFilePeek(pdfio_file_t *pdf,\t// I - PDF file\n               void         *buffer,\t// I - Buffer\n               size_t       bytes)\t// I - Size of bufffer\n{\n  ssize_t\ttotal;\t\t\t// Total bytes available\n\n\n  // See how much data is buffered up...\n  if (pdf->bufptr >= pdf->bufend)\n  {\n    // Fill the buffer...\n    if (!fill_buffer(pdf))\n      return (-1);\n  }\n\n  if ((total = pdf->bufend - pdf->bufptr) < (ssize_t)bytes && total < (ssize_t)(sizeof(pdf->buffer) / 2))\n  {\n    // Yes, try reading more...\n    ssize_t\trbytes;\t\t\t// Bytes read\n\n    PDFIO_DEBUG(\"_pdfioFilePeek: Sliding buffer, total=%ld\\n\", (long)total);\n\n    memmove(pdf->buffer, pdf->bufptr, total);\n    pdf->bufpos += pdf->bufptr - pdf->buffer;\n    pdf->bufptr = pdf->buffer;\n    pdf->bufend = pdf->buffer + total;\n\n    // Read until we have bytes or a non-recoverable error...\n    while ((rbytes = read(pdf->fd, pdf->bufend, sizeof(pdf->buffer) - (size_t)total)) < 0)\n    {\n      if (errno != EINTR && errno != EAGAIN)\n\tbreak;\n    }\n\n    if (rbytes > 0)\n    {\n      // Expand the buffer...\n      pdf->bufend += rbytes;\n      total       += rbytes;\n    }\n  }\n\n  // Copy anything we have to the buffer...\n  if (total > (ssize_t)bytes)\n    total = (ssize_t)bytes;\n\n  if (total > 0)\n    memcpy(buffer, pdf->bufptr, total);\n\n  return (total);\n}\n\n\n//\n// '_pdfioFilePrintf()' - Write a formatted string to a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioFilePrintf(pdfio_file_t *pdf,\t// I - PDF file\n                 const char   *format,\t// I - `printf`-style format string\n                 ...)\t\t\t// I - Additional arguments as needed\n{\n  char\t\tbuffer[8102];\t\t// String buffer\n  va_list\tap;\t\t\t// Argument list\n\n\n  // Format the string...\n  va_start(ap, format);\n  vsnprintf(buffer, sizeof(buffer), format, ap);\n  va_end(ap);\n\n  // Write it...\n  return (_pdfioFileWrite(pdf, buffer, strlen(buffer)));\n}\n\n\n//\n// '_pdfioFilePuts()' - Write a literal string to a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioFilePuts(pdfio_file_t *pdf,\t// I - PDF file\n               const char   *s)\t\t// I - Literal string\n{\n  // Write it...\n  return (_pdfioFileWrite(pdf, s, strlen(s)));\n}\n\n\n//\n// '_pdfioFileRead()' - Read from a PDF file.\n//\n\nssize_t\t\t\t\t\t// O - Number of bytes read or `-1` on error\n_pdfioFileRead(pdfio_file_t *pdf,\t// I - PDF file\n               void         *buffer,\t// I - Read buffer\n               size_t       bytes)\t// I - Number of bytes to read\n{\n  char\t\t*bufptr = (char *)buffer;\n\t\t\t\t\t// Pointer into buffer\n  ssize_t\ttotal,\t\t\t// Total bytes read\n\t\trbytes;\t\t\t// Bytes read this time\n\n\n  // Loop until we have read all of the requested bytes or hit an error...\n  for (total = 0; bytes > 0; total += rbytes, bytes -= (size_t)rbytes, bufptr += rbytes)\n  {\n    // First read from the file buffer...\n    if ((rbytes = pdf->bufend - pdf->bufptr) > 0)\n    {\n      if ((size_t)rbytes > bytes)\n        rbytes = (ssize_t)bytes;\n\n      memcpy(bufptr, pdf->bufptr, rbytes);\n      pdf->bufptr += rbytes;\n      continue;\n    }\n\n    // Nothing buffered...\n    if (bytes > 1024)\n    {\n      // Advance current position in file as needed...\n      if (pdf->bufend)\n      {\n\tpdf->bufpos += pdf->bufend - pdf->buffer;\n\tpdf->bufptr = pdf->bufend = NULL;\n      }\n\n      // Read directly from the file...\n      if ((rbytes = read_buffer(pdf, bufptr, bytes)) > 0)\n      {\n\tpdf->bufpos += rbytes;\n\tcontinue;\n      }\n      else if (rbytes < 0 && (errno == EINTR || errno == EAGAIN))\n      {\n        rbytes = 0;\n        continue;\n      }\n      else\n        break;\n    }\n    else\n    {\n      // Fill buffer and try again...\n      if (!fill_buffer(pdf))\n\tbreak;\n    }\n  }\n\n  return (total);\n}\n\n\n//\n// '_pdfioFileSeek()' - Seek within a PDF file.\n//\n\noff_t\t\t\t\t\t// O - New offset from beginning of file or `-1` on error\n_pdfioFileSeek(pdfio_file_t *pdf,\t// I - PDF file\n               off_t        offset,\t// I - Offset\n               int          whence)\t// I - Offset base\n{\n  PDFIO_DEBUG(\"_pdfioFileSeek(pdf=%p, offset=%ld, whence=%d)\\n\", pdf, (long)offset, whence);\n\n  // Adjust offset for relative seeks...\n  if (whence == SEEK_CUR)\n  {\n    offset += pdf->bufpos;\n    whence = SEEK_SET;\n  }\n\n  if (pdf->mode == _PDFIO_MODE_READ)\n  {\n    // Reading, see if we already have the data we need...\n    if (whence != SEEK_END && offset >= pdf->bufpos && offset < (pdf->bufpos + pdf->bufend - pdf->buffer))\n    {\n      // Yes, seek within existing buffer...\n      pdf->bufptr = pdf->buffer + offset - pdf->bufpos;\n      PDFIO_DEBUG(\"_pdfioFileSeek: Seek within buffer, bufpos=%ld.\\n\", (long)pdf->bufpos);\n      PDFIO_DEBUG(\"_pdfioFileSeek: buffer=%p, bufptr=%p, bufend=%p\\n\", pdf->buffer, pdf->bufptr, pdf->bufend);\n      return (offset);\n    }\n\n    // No, reset the read buffer\n    pdf->bufptr = pdf->bufend = NULL;\n  }\n  else if (pdf->output_cb)\n  {\n    _pdfioFileError(pdf, \"Unable to seek within output stream.\");\n    return (-1);\n  }\n  else\n  {\n    // Writing, make sure we write any buffered data...\n    if (pdf->bufptr > pdf->buffer)\n    {\n      if (!write_buffer(pdf, pdf->buffer, (size_t)(pdf->bufptr - pdf->buffer)))\n\treturn (-1);\n    }\n\n    pdf->bufptr = pdf->buffer;\n  }\n\n  // Seek within the file...\n  if ((offset = lseek(pdf->fd, offset, whence)) < 0)\n  {\n    _pdfioFileError(pdf, \"Unable to seek within file - %s\", strerror(errno));\n    return (-1);\n  }\n\n  PDFIO_DEBUG(\"_pdfioFileSeek: Reset bufpos=%ld.\\n\", (long)pdf->bufpos);\n  PDFIO_DEBUG(\"_pdfioFileSeek: buffer=%p, bufptr=%p, bufend=%p\\n\", pdf->buffer, pdf->bufptr, pdf->bufend);\n\n  pdf->bufpos = offset;\n\n  return (offset);\n}\n\n\n//\n// '_pdfioFileTell()' - Return the offset within a PDF file.\n//\n\noff_t\t\t\t\t\t// O - Offset from beginning of file\n_pdfioFileTell(pdfio_file_t *pdf)\t// I - PDF file\n{\n  if (pdf->bufptr)\n    return (pdf->bufpos + (pdf->bufptr - pdf->buffer));\n  else\n    return (pdf->bufpos);\n}\n\n\n//\n// '_pdfioFileWrite()' - Write to a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success and `false` on error\n_pdfioFileWrite(pdfio_file_t *pdf,\t// I - PDF file\n                const void   *buffer,\t// I - Write buffer\n                size_t       bytes)\t// I - Bytes to write\n{\n  // See if the data will fit in the write buffer...\n  if (bytes > (size_t)(pdf->bufend - pdf->bufptr))\n  {\n    // No room, flush any current data...\n    if (!_pdfioFileFlush(pdf))\n      return (false);\n\n    if (bytes >= sizeof(pdf->buffer))\n    {\n      // Write directly...\n      if (!write_buffer(pdf, buffer, bytes))\n        return (false);\n\n      pdf->bufpos += bytes;\n\n      return (true);\n    }\n  }\n\n  // Copy data to the buffer and return...\n  memcpy(pdf->bufptr, buffer, bytes);\n  pdf->bufptr += bytes;\n\n  return (true);\n}\n\n\n//\n// 'fill_buffer()' - Fill the read buffer in a PDF file.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nfill_buffer(pdfio_file_t *pdf)\t\t// I - PDF file\n{\n  ssize_t\tbytes;\t\t\t// Bytes read...\n\n\n  // Advance current position in file as needed...\n  if (pdf->bufend)\n    pdf->bufpos += pdf->bufend - pdf->buffer;\n\n  // Try reading from the file...\n  if ((bytes = read_buffer(pdf, pdf->buffer, sizeof(pdf->buffer))) <= 0)\n  {\n    // EOF or hard error...\n    pdf->bufptr = pdf->bufend = NULL;\n    return (false);\n  }\n  else\n  {\n    // Successful read...\n    pdf->bufptr = pdf->buffer;\n    pdf->bufend = pdf->buffer + bytes;\n    return (true);\n  }\n}\n\n\n//\n// 'read_buffer()' - Read a buffer from a PDF file.\n//\n\nstatic ssize_t\t\t\t\t// O - Number of bytes read or -1 on error\nread_buffer(pdfio_file_t *pdf,\t\t// I - PDF file\n            char         *buffer,\t// I - Buffer\n            size_t       bytes)\t\t// I - Number of bytes to read\n{\n  ssize_t\trbytes;\t\t\t// Bytes read...\n\n\n  // Read from the file...\n  while ((rbytes = read(pdf->fd, buffer, bytes)) < 0)\n  {\n    // Stop if we have an error that shouldn't be retried...\n    if (errno != EINTR && errno != EAGAIN)\n      break;\n  }\n\n  if (rbytes < 0)\n  {\n    // Hard error...\n    _pdfioFileError(pdf, \"Unable to read from file - %s\", strerror(errno));\n  }\n\n  return (rbytes);\n}\n\n\n//\n// 'write_buffer()' - Write a buffer to a PDF file.\n//\n\nstatic bool\t\t\t\t// O - `true` on success and `false` on error\nwrite_buffer(pdfio_file_t *pdf,\t\t// I - PDF file\n\t     const void   *buffer,\t// I - Write buffer\n\t     size_t       bytes)\t// I - Bytes to write\n{\n  const char\t*bufptr = (const char *)buffer;\n\t\t\t\t\t// Pointer into buffer\n  ssize_t\twbytes;\t\t\t// Bytes written...\n\n\n  if (pdf->output_cb)\n  {\n    // Write to a stream...\n    if ((pdf->output_cb)(pdf->output_ctx, buffer, bytes) < 0)\n    {\n      _pdfioFileError(pdf, \"Unable to write to output callback.\");\n      return (false);\n    }\n  }\n  else\n  {\n    // Write to the file...\n    while (bytes > 0)\n    {\n      while ((wbytes = write(pdf->fd, bufptr, bytes)) < 0)\n      {\n\t// Stop if we have an error that shouldn't be retried...\n\tif (errno != EINTR && errno != EAGAIN)\n\t  break;\n      }\n\n      if (wbytes < 0)\n      {\n\t// Hard error...\n\t_pdfioFileError(pdf, \"Unable to write to file - %s\", strerror(errno));\n\treturn (false);\n      }\n\n      bufptr += wbytes;\n      bytes  -= (size_t)wbytes;\n    }\n  }\n\n  return (true);\n}\n", "//\n// PDF dictionary functions for PDFio.\n//\n// Copyright \u00a9\u00a02021-2023 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n\n\n//\n// Local functions...\n//\n\nstatic int\tcompare_pairs(_pdfio_pair_t *a, _pdfio_pair_t *b);\n\n\n//\n// '_pdfioDictClear()' - Remove a key/value pair from a dictionary.\n//\n\nvoid\n_pdfioDictClear(pdfio_dict_t *dict,\t// I - Dictionary\n                const char   *key)\t// I - Key\n{\n  size_t\tidx;\t\t\t// Index into pairs\n  _pdfio_pair_t\t*pair,\t\t\t// Current pair\n\t\tpkey;\t\t\t// Search key\n\n\n  PDFIO_DEBUG(\"_pdfioDictClear(dict=%p, key=\\\"%s\\\")\\n\", dict, key);\n\n  // See if the key is already set...\n  if (dict->num_pairs > 0)\n  {\n    pkey.key = key;\n\n    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n    {\n      // Yes, remove it...\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n\n      idx = (size_t)(pair - dict->pairs);\n      dict->num_pairs --;\n\n      if (idx < dict->num_pairs)\n        memmove(pair, pair + 1, (dict->num_pairs - idx) * sizeof(_pdfio_pair_t));\n    }\n  }\n}\n\n\n//\n// 'pdfioDictCopy()' - Copy a dictionary to a PDF file.\n//\n\npdfio_dict_t *\t\t\t\t// O - New dictionary\npdfioDictCopy(pdfio_file_t *pdf,\t// I - PDF file\n              pdfio_dict_t *dict)\t// I - Original dictionary\n{\n  pdfio_dict_t\t\t*ndict;\t\t// New dictionary\n  size_t\t\ti;\t\t// Looping var\n  _pdfio_pair_t\t\t*p;\t\t// Current source pair\n  const char\t\t*key;\t\t// Current destination key\n  _pdfio_value_t\tv;\t\t// Current destination value\n\n\n  PDFIO_DEBUG(\"pdfioDictCopy(pdf=%p, dict=%p(%p))\\n\", pdf, dict, dict ? dict->pdf : NULL);\n\n  // Create the new dictionary...\n  if ((ndict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n\n  // Pre-allocate the pairs array to make this a little faster...\n  if ((ndict->pairs = (_pdfio_pair_t *)malloc(dict->num_pairs * sizeof(_pdfio_pair_t))) == NULL)\n    return (NULL);\t\t\t// Let pdfioFileClose do the cleanup...\n\n  ndict->alloc_pairs = dict->num_pairs;\n\n  // Copy and add each of the source dictionary's key/value pairs...\n  for (i = dict->num_pairs, p = dict->pairs; i > 0; i --, p ++)\n  {\n    if (!strcmp(p->key, \"Length\") && p->value.type == PDFIO_VALTYPE_INDIRECT && dict->pdf != pdf)\n    {\n      // Don't use indirect stream lengths for copied objects...\n      pdfio_obj_t *lenobj = pdfioFileFindObj(dict->pdf, p->value.value.indirect.number);\n\t\t\t\t\t// Length object\n\n      v.type = PDFIO_VALTYPE_NUMBER;\n      if (lenobj)\n      {\n        if (lenobj->value.type == PDFIO_VALTYPE_NONE)\n          _pdfioObjLoad(lenobj);\n\n\tv.value.number = lenobj->value.value.number;\n      }\n      else\n        v.value.number = 0.0;\n    }\n    else if (!_pdfioValueCopy(pdf, &v, dict->pdf, &p->value))\n      return (NULL);\t\t\t// Let pdfioFileClose do the cleanup...\n\n    if (_pdfioStringIsAllocated(dict->pdf, p->key))\n      key = pdfioStringCreate(pdf, p->key);\n    else\n      key = p->key;\n\n    if (!key)\n      return (NULL);\t\t\t// Let pdfioFileClose do the cleanup...\n\n    // Cannot fail since we already allocated space for the pairs...\n    _pdfioDictSetValue(ndict, key, &v);\n  }\n\n  // Successfully copied the dictionary, so return it...\n  return (ndict);\n}\n\n\n//\n// 'pdfioDictCreate()' - Create a dictionary to hold key/value pairs.\n//\n\npdfio_dict_t *\t\t\t\t// O - New dictionary\npdfioDictCreate(pdfio_file_t *pdf)\t// I - PDF file\n{\n  pdfio_dict_t\t*dict;\t\t\t// New dictionary\n\n\n  if (!pdf)\n    return (NULL);\n\n  if ((dict = (pdfio_dict_t *)calloc(1, sizeof(pdfio_dict_t))) == NULL)\n    return (NULL);\n\n  dict->pdf = pdf;\n\n  if (pdf->num_dicts >= pdf->alloc_dicts)\n  {\n    pdfio_dict_t **temp = (pdfio_dict_t **)realloc(pdf->dicts, (pdf->alloc_dicts + 16) * sizeof(pdfio_dict_t *));\n\n    if (!temp)\n    {\n      free(dict);\n      return (NULL);\n    }\n\n    pdf->dicts       = temp;\n    pdf->alloc_dicts += 16;\n  }\n\n  pdf->dicts[pdf->num_dicts ++] = dict;\n\n  return (dict);\n}\n\n\n//\n// '_pdfioDictDebug()' - Dump a dictionary to stderr.\n//\n\nvoid\n_pdfioDictDebug(pdfio_dict_t *dict,\t// I - Dictionary\n                FILE         *fp)\t// I - Output file\n{\n  size_t\ti;\t\t\t// Looping var\n  _pdfio_pair_t\t*pair;\t\t\t// Current pair\n\n\n  for (i = dict->num_pairs, pair = dict->pairs; i > 0; i --, pair ++)\n  {\n    fprintf(fp, \"/%s\", pair->key);\n    _pdfioValueDebug(&pair->value, fp);\n  }\n}\n\n\n//\n// '_pdfioDictDelete()' - Free the memory used by a dictionary.\n//\n\nvoid\n_pdfioDictDelete(pdfio_dict_t *dict)\t// I - Dictionary\n{\n  if (dict)\n  {\n    size_t\ti;\t\t\t// Looping var\n    _pdfio_pair_t *pair;\t\t// Current pair\n\n    for (i = dict->num_pairs, pair = dict->pairs; i > 0; i --, pair ++)\n    {\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n    }\n\n    free(dict->pairs);\n  }\n\n  free(dict);\n}\n\n\n//\n// 'pdfioDictGetArray()' - Get a key array value from a dictionary.\n//\n\npdfio_array_t *\t\t\t\t// O - Value\npdfioDictGetArray(pdfio_dict_t *dict,\t// I - Dictionary\n                  const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_ARRAY)\n    return (value->value.array);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioDictGetBinary()' - Get a key binary string value from a dictionary.\n//\n\nunsigned char *\t\t\t\t// O - Value\npdfioDictGetBinary(pdfio_dict_t *dict,\t// I - Dictionary\n                   const char   *key,\t// I - Key\n                   size_t       *length)// O - Length of value\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (!length)\n    return (NULL);\n\n  if (value && value->type == PDFIO_VALTYPE_BINARY)\n  {\n    *length = value->value.binary.datalen;\n    return (value->value.binary.data);\n  }\n  else if (value && value->type == PDFIO_VALTYPE_STRING)\n  {\n    *length = strlen(value->value.string);\n    return ((unsigned char *)value->value.string);\n  }\n  else\n  {\n    *length = 0;\n    return (NULL);\n  }\n}\n\n\n//\n// 'pdfioDictGetBoolean()' - Get a key boolean value from a dictionary.\n//\n\nbool\t\t\t\t\t// O - Value\npdfioDictGetBoolean(pdfio_dict_t *dict,\t// I - Dictionary\n                    const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_BOOLEAN)\n    return (value->value.boolean);\n  else\n    return (false);\n}\n\n\n//\n// 'pdfioDictGetDate()' - Get a date value from a dictionary.\n//\n\ntime_t\t\t\t\t\t// O - Value\npdfioDictGetDate(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_DATE)\n    return (value->value.date);\n  else\n    return (0);\n}\n\n\n//\n// 'pdfioDictGetDict()' - Get a key dictionary value from a dictionary.\n//\n\npdfio_dict_t *\t\t\t\t// O - Value\npdfioDictGetDict(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_DICT)\n    return (value->value.dict);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioDictGetName()' - Get a key name value from a dictionary.\n//\n\nconst char *\t\t\t\t// O - Value\npdfioDictGetName(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_NAME)\n    return (value->value.name);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioDictGetNumber()' - Get a key number value from a dictionary.\n//\n\ndouble\t\t\t\t\t// O - Value\npdfioDictGetNumber(pdfio_dict_t *dict,\t// I - Dictionary\n                   const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_NUMBER)\n    return (value->value.number);\n  else\n    return (0.0);\n}\n\n\n//\n// 'pdfioDictGetObj()' - Get a key indirect object value from a dictionary.\n//\n\npdfio_obj_t *\t\t\t\t// O - Value\npdfioDictGetObj(pdfio_dict_t *dict,\t// I - Dictionary\n                const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_INDIRECT)\n    return (pdfioFileFindObj(dict->pdf, value->value.indirect.number));\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioDictGetRect()' - Get a key rectangle value from a dictionary.\n//\n\npdfio_rect_t *\t\t\t\t// O - Rectangle\npdfioDictGetRect(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key,\t// I - Key\n                 pdfio_rect_t *rect)\t// I - Rectangle\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_ARRAY && pdfioArrayGetSize(value->value.array) == 4)\n  {\n    rect->x1 = pdfioArrayGetNumber(value->value.array, 0);\n    rect->y1 = pdfioArrayGetNumber(value->value.array, 1);\n    rect->x2 = pdfioArrayGetNumber(value->value.array, 2);\n    rect->y2 = pdfioArrayGetNumber(value->value.array, 3);\n    return (rect);\n  }\n  else\n  {\n    memset(rect, 0, sizeof(pdfio_rect_t));\n    return (NULL);\n  }\n}\n\n\n//\n// 'pdfioDictGetString()' - Get a key string value from a dictionary.\n//\n\nconst char *\t\t\t\t// O - Value\npdfioDictGetString(pdfio_dict_t *dict,\t// I - Dictionary\n                   const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  if (value && value->type == PDFIO_VALTYPE_STRING)\n    return (value->value.string);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioDictGetType()' - Get a key value type from a dictionary.\n//\n\npdfio_valtype_t\t\t\t\t// O - Value type\npdfioDictGetType(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key)\t// I - Key\n{\n  _pdfio_value_t *value = _pdfioDictGetValue(dict, key);\n\n\n  return (value ? value->type : PDFIO_VALTYPE_NONE);\n}\n\n\n//\n// '_pdfioDictGetValue()' - Get a key value from a dictionary.\n//\n\n_pdfio_value_t *\t\t\t// O - Value or `NULL` on error\n_pdfioDictGetValue(pdfio_dict_t *dict,\t// I - Dictionary\n                   const char   *key)\t// I - Key\n{\n  _pdfio_pair_t\ttemp,\t\t\t// Search key\n\t\t*match;\t\t\t// Matching key pair\n\n\n  PDFIO_DEBUG(\"_pdfioDictGetValue(dict=%p, key=\\\"%s\\\")\\n\", dict, key);\n\n  if (!dict || !dict->num_pairs || !key)\n  {\n    PDFIO_DEBUG(\"_pdfioDictGetValue: Returning NULL.\\n\");\n    return (NULL);\n  }\n\n  temp.key = key;\n\n  if ((match = bsearch(&temp, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n  {\n    PDFIO_DEBUG(\"_pdfioDictGetValue: Match, returning \");\n    PDFIO_DEBUG_VALUE(&(match->value));\n    PDFIO_DEBUG(\".\\n\");\n    return (&(match->value));\n  }\n  else\n  {\n    PDFIO_DEBUG(\"_pdfioDictGetValue: No match, returning NULL.\\n\");\n    return (NULL);\n  }\n}\n\n\n//\n// 'pdfioDictIterateKeys()' - Iterate the keys in a dictionary.\n//\n// This function iterates the keys in a dictionary, calling the supplied\n// function \"cb\":\n//\n// ```\n// bool\n// my_dict_cb(pdfio_dict_t *dict, const char *key, void *cb_data)\n// {\n// ... \"key\" contains the dictionary key ...\n// ... return true to continue or false to stop ...\n// }\n// ```\n//\n// The iteration continues as long as the callback returns `true` or all keys\n// have been iterated.\n//\n\nvoid\npdfioDictIterateKeys(\n    pdfio_dict_t    *dict,\t\t// I - Dictionary\n    pdfio_dict_cb_t cb,\t\t\t// I - Callback function\n    void            *cb_data)\t\t// I - Callback data\n{\n  size_t\ti;\t\t\t// Looping var\n  _pdfio_pair_t\t*pair;\t\t\t// Current pair\n\n\n  // Range check input...\n  if (!dict || !cb)\n    return;\n\n  for (i = dict->num_pairs, pair = dict->pairs; i > 0; i --, pair ++)\n  {\n    if (!(cb)(dict, pair->key, cb_data))\n      break;\n  }\n}\n\n\n//\n// '_pdfioDictRead()' - Read a dictionary from a PDF file.\n//\n// At this point we've seen the initial \"<<\"...\n//\n\npdfio_dict_t *\t\t\t\t// O - New dictionary\n_pdfioDictRead(pdfio_file_t   *pdf,\t// I - PDF file\n               pdfio_obj_t    *obj,\t// I - Object, if any\n               _pdfio_token_t *tb,\t// I - Token buffer/stack\n               size_t         depth)\t// I - Depth of dictionary\n{\n  pdfio_dict_t\t\t*dict;\t\t// New dictionary\n  char\t\t\tkey[256];\t// Dictionary key\n  _pdfio_value_t\tvalue;\t\t// Dictionary value\n\n\n  PDFIO_DEBUG(\"_pdfioDictRead(pdf=%p)\\n\", pdf);\n\n  // Create a dictionary and start reading...\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n\n  while (_pdfioTokenGet(tb, key, sizeof(key)))\n  {\n    // Get the next key or end-of-dictionary...\n    if (!strcmp(key, \">>\"))\n    {\n      // End of dictionary...\n      return (dict);\n    }\n    else if (key[0] != '/')\n    {\n      _pdfioFileError(pdf, \"Invalid dictionary contents.\");\n      break;\n    }\n    else if (_pdfioDictGetValue(dict, key + 1))\n    {\n      _pdfioFileError(pdf, \"Duplicate dictionary key '%s'.\", key + 1);\n      return (NULL);\n    }\n\n    // Then get the next value...\n    PDFIO_DEBUG(\"_pdfioDictRead: Reading value for '%s'.\\n\", key + 1);\n\n    if (!_pdfioValueRead(pdf, obj, tb, &value, depth))\n    {\n      _pdfioFileError(pdf, \"Missing value for dictionary key.\");\n      break;\n    }\n\n    if (!_pdfioDictSetValue(dict, pdfioStringCreate(pdf, key + 1), &value))\n      break;\n\n//    PDFIO_DEBUG(\"_pdfioDictRead: Set %s.\\n\", key);\n  }\n\n  // Dictionary is invalid - pdfioFileClose will free the memory, return NULL\n  // to indicate an error...\n  return (NULL);\n}\n\n\n//\n// 'pdfioDictSetArray()' - Set a key array in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetArray(pdfio_dict_t  *dict,\t// I - Dictionary\n                  const char    *key,\t// I - Key\n                  pdfio_array_t *value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type        = PDFIO_VALTYPE_ARRAY;\n  temp.value.array = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetBinary()' - Set a key binary string in a dictionary.\n//\n\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetBinary(\n    pdfio_dict_t        *dict,\t\t// I - Dictionary\n    const char          *key,\t\t// I - Key\n    const unsigned char *value,\t\t// I - Value\n    size_t              valuelen)\t// I - Length of value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value || !valuelen)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type                 = PDFIO_VALTYPE_BINARY;\n  temp.value.binary.datalen = valuelen;\n\n  if ((temp.value.binary.data = (unsigned char *)malloc(valuelen)) == NULL)\n    return (false);\n\n  memcpy(temp.value.binary.data, value, valuelen);\n\n  if (!_pdfioDictSetValue(dict, key, &temp))\n  {\n    free(temp.value.binary.data);\n    return (false);\n  }\n\n  return (true);\n}\n\n\n//\n// 'pdfioDictSetBoolean()' - Set a key boolean in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetBoolean(pdfio_dict_t *dict,\t// I - Dictionary\n                    const char   *key,\t// I - Key\n                    bool         value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type          = PDFIO_VALTYPE_BOOLEAN;\n  temp.value.boolean = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetDate()' - Set a date value in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetDate(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key,\t// I - Key\n                 time_t       value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type       = PDFIO_VALTYPE_DATE;\n  temp.value.date = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetDict()' - Set a key dictionary in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetDict(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key,\t// I - Key\n                 pdfio_dict_t *value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type       = PDFIO_VALTYPE_DICT;\n  temp.value.dict = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetName()' - Set a key name in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetName(pdfio_dict_t  *dict,\t// I - Dictionary\n                 const char    *key,\t// I - Key\n                 const char    *value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type       = PDFIO_VALTYPE_NAME;\n  temp.value.name = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetNull()' - Set a key null in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetNull(pdfio_dict_t *dict,\t// I - Dictionary\n\t\t const char   *key)\t// I - Key\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type = PDFIO_VALTYPE_NULL;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetNumber()' - Set a key number in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetNumber(pdfio_dict_t  *dict,\t// I - Dictionary\n                   const char    *key,\t// I - Key\n                   double        value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type         = PDFIO_VALTYPE_NUMBER;\n  temp.value.number = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetObj()' - Set a key indirect object reference in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetObj(pdfio_dict_t *dict,\t// I - Dictionary\n                const char    *key,\t// I - Key\n                pdfio_obj_t   *value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type                      = PDFIO_VALTYPE_INDIRECT;\n  temp.value.indirect.number     = value->number;\n  temp.value.indirect.generation = value->generation;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetRect()' - Set a key rectangle in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetRect(pdfio_dict_t *dict,\t// I - Dictionary\n                 const char   *key,\t// I - Key\n                 pdfio_rect_t *value)\t// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type        = PDFIO_VALTYPE_ARRAY;\n  temp.value.array = pdfioArrayCreate(dict->pdf);\n\n  pdfioArrayAppendNumber(temp.value.array, value->x1);\n  pdfioArrayAppendNumber(temp.value.array, value->y1);\n  pdfioArrayAppendNumber(temp.value.array, value->x2);\n  pdfioArrayAppendNumber(temp.value.array, value->y2);\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetString()' - Set a key literal string in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetString(pdfio_dict_t  *dict,\t// I - Dictionary\n                  const char     *key,\t// I - Key\n                  const char     *value)// I - Value\n{\n  _pdfio_value_t temp;\t\t\t// New value\n\n\n  // Range check input...\n  if (!dict || !key || !value)\n    return (false);\n\n  // Set the key/value pair...\n  temp.type         = PDFIO_VALTYPE_STRING;\n  temp.value.string = value;\n\n  return (_pdfioDictSetValue(dict, key, &temp));\n}\n\n\n//\n// 'pdfioDictSetStringf()' - Set a key formatted string in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioDictSetStringf(\n    pdfio_dict_t  *dict,\t\t// I - Dictionary\n    const char    *key,\t\t\t// I - Key\n    const char    *format,\t\t// I - `printf`-style format string\n    ...)\t\t\t\t// I - Additional arguments as needed\n{\n  char\t\tbuffer[8192];\t\t// String buffer\n  va_list\tap;\t\t\t// Argument list\n\n\n  // Range check input...\n  if (!dict || !key || !format)\n    return (false);\n\n  // Set the key/value pair...\n  va_start(ap, format);\n  vsnprintf(buffer, sizeof(buffer), format, ap);\n  va_end(ap);\n\n  return (pdfioDictSetString(dict, key, buffer));\n}\n\n\n//\n// '_pdfioDictSetValue()' - Set a key value in a dictionary.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioDictSetValue(\n    pdfio_dict_t   *dict,\t\t// I - Dictionary\n    const char     *key,\t\t// I - Key\n    _pdfio_value_t *value)\t\t// I - Value\n{\n  _pdfio_pair_t\t*pair;\t\t\t// Current pair\n\n\n  PDFIO_DEBUG(\"_pdfioDictSetValue(dict=%p, key=\\\"%s\\\", value=%p)\\n\", dict, key, (void *)value);\n\n  // See if the key is already set...\n  if (dict->num_pairs > 0)\n  {\n    _pdfio_pair_t\tpkey;\t\t// Search key\n\n    pkey.key = key;\n\n    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n    {\n      // Yes, replace the value...\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Replacing existing value.\\n\");\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n      pair->value = *value;\n      return (true);\n    }\n  }\n\n  // Nope, add a pair...\n  if (dict->num_pairs >= dict->alloc_pairs)\n  {\n    // Expand the dictionary...\n    _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t));\n\n    if (!temp)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Out of memory.\\n\");\n      return (false);\n    }\n\n    dict->pairs       = temp;\n    dict->alloc_pairs += 8;\n  }\n\n  pair = dict->pairs + dict->num_pairs;\n  dict->num_pairs ++;\n\n  pair->key   = key;\n  pair->value = *value;\n\n  // Re-sort the dictionary and return...\n  if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0)\n    qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs);\n\n#ifdef DEBUG\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): %lu pairs\\n\", (void *)dict, (unsigned long)dict->num_pairs);\n//  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n//  PDFIO_DEBUG_DICT(dict);\n//  PDFIO_DEBUG(\"\\n\");\n#endif // DEBUG\n\n  return (true);\n}\n\n\n//\n// '_pdfioDictWrite()' - Write a dictionary to a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioDictWrite(pdfio_dict_t *dict,\t// I - Dictionary\n\t\tpdfio_obj_t  *obj,\t// I - Object, if any\n                off_t        *length)\t// I - Offset to length value\n{\n  pdfio_file_t\t*pdf = dict->pdf;\t// PDF file\n  size_t\ti;\t\t\t// Looping var\n  _pdfio_pair_t\t*pair;\t\t\t// Current key/value pair\n\n\n  if (length)\n    *length = 0;\n\n  // Dictionaries are bounded by \"<<\" and \">>\"...\n  if (!_pdfioFilePuts(pdf, \"<<\"))\n    return (false);\n\n  // Write all of the key/value pairs...\n  for (i = dict->num_pairs, pair = dict->pairs; i > 0; i --, pair ++)\n  {\n    if (!_pdfioFilePrintf(pdf, \"/%s\", pair->key))\n      return (false);\n\n    if (length && !strcmp(pair->key, \"Length\") && pair->value.type == PDFIO_VALTYPE_NUMBER && pair->value.value.number <= 0.0)\n    {\n      // Writing an object dictionary with an undefined length\n      *length = _pdfioFileTell(pdf) + 1;\n      if (!_pdfioFilePuts(pdf, \" 9999999999\"))\n        return (false);\n    }\n    else if (!_pdfioValueWrite(pdf, obj, &pair->value, NULL))\n      return (false);\n  }\n\n  // Close it up...\n  return (_pdfioFilePuts(pdf, \">>\"));\n}\n\n\n//\n// 'compare_pairs()' - Compare the keys for two pairs.\n//\n\nstatic int\t\t\t\t// O - Result of comparison\ncompare_pairs(_pdfio_pair_t *a,\t\t// I - First pair\n              _pdfio_pair_t *b)\t\t// I - Second pair\n{\n  return (strcmp(a->key, b->key));\n}\n", "//\n// PDF file functions for PDFio.\n//\n// Copyright \u00a9\u00a02021-2023 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n#ifndef O_BINARY\n#  define O_BINARY 0\n#endif // !O_BINARY\n\n\n//\n// Local functions...\n//\n\nstatic pdfio_obj_t\t*add_obj(pdfio_file_t *pdf, size_t number, unsigned short generation, off_t offset);\nstatic int\t\tcompare_objmaps(_pdfio_objmap_t *a, _pdfio_objmap_t *b);\nstatic int\t\tcompare_objs(pdfio_obj_t **a, pdfio_obj_t **b);\nstatic const char\t*get_info_string(pdfio_file_t *pdf, const char *key);\nstatic bool\t\tload_obj_stream(pdfio_obj_t *obj);\nstatic bool\t\tload_pages(pdfio_file_t *pdf, pdfio_obj_t *obj, size_t depth);\nstatic bool\t\tload_xref(pdfio_file_t *pdf, off_t xref_offset, pdfio_password_cb_t password_cb, void *password_data);\nstatic bool\t\twrite_catalog(pdfio_file_t *pdf);\nstatic bool\t\twrite_pages(pdfio_file_t *pdf);\nstatic bool\t\twrite_trailer(pdfio_file_t *pdf);\n\n\n//\n// '_pdfioFileAddMappedObj()' - Add a mapped object.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioFileAddMappedObj(\n    pdfio_file_t *pdf,\t\t\t// I - Destination PDF file\n    pdfio_obj_t  *dst_obj,\t\t// I - Destination object\n    pdfio_obj_t  *src_obj)\t\t// I - Source object\n{\n  _pdfio_objmap_t\t*map;\t\t// Object map\n\n\n  // Allocate memory as needed...\n  if (pdf->num_objmaps >= pdf->alloc_objmaps)\n  {\n    if ((map = realloc(pdf->objmaps, (pdf->alloc_objmaps + 16) * sizeof(_pdfio_objmap_t))) == NULL)\n    {\n      _pdfioFileError(pdf, \"Unable to allocate memory for object map.\");\n      return (false);\n    }\n\n    pdf->alloc_objmaps += 16;\n    pdf->objmaps       = map;\n  }\n\n  // Add an object to the end...\n  map = pdf->objmaps + pdf->num_objmaps;\n  pdf->num_objmaps ++;\n\n  map->obj        = dst_obj;\n  map->src_pdf    = src_obj->pdf;\n  map->src_number = src_obj->number;\n\n  // Sort as needed...\n  if (pdf->num_objmaps > 1 && compare_objmaps(map, pdf->objmaps + pdf->num_objmaps - 2) < 0)\n    qsort(pdf->objmaps, pdf->num_objmaps, sizeof(_pdfio_objmap_t), (int (*)(const void *, const void *))compare_objmaps);\n\n  return (true);\n}\n\n\n//\n// '_pdfioFileAddPage()' - Add a page to a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success and `false` on failure\n_pdfioFileAddPage(pdfio_file_t *pdf,\t// I - PDF file\n                  pdfio_obj_t  *obj)\t// I - Page object\n{\n  // Add the page to the array of pages...\n  if (pdf->num_pages >= pdf->alloc_pages)\n  {\n    pdfio_obj_t **temp = (pdfio_obj_t **)realloc(pdf->pages, (pdf->alloc_pages + 16) * sizeof(pdfio_obj_t *));\n\n    if (!temp)\n    {\n      _pdfioFileError(pdf, \"Unable to allocate memory for pages.\");\n      return (false);\n    }\n\n    pdf->alloc_pages += 16;\n    pdf->pages       = temp;\n  }\n\n  pdf->pages[pdf->num_pages ++] = obj;\n\n  return (true);\n}\n\n\n//\n// 'pdfioFileClose()' - Close a PDF file and free all memory used for it.\n//\n\nbool\t\t\t\t\t// O - `true` on success and `false` on failure\npdfioFileClose(pdfio_file_t *pdf)\t// I - PDF file\n{\n  bool\t\tret = true;\t\t// Return value\n  size_t\ti;\t\t\t// Looping var\n\n\n  // Range check input\n  if (!pdf)\n    return (false);\n\n  // Close the file itself...\n  if (pdf->mode == _PDFIO_MODE_WRITE)\n  {\n    ret = false;\n\n    if (pdfioObjClose(pdf->info_obj))\n      if (write_pages(pdf))\n\tif (write_catalog(pdf))\n\t  if (write_trailer(pdf))\n\t    ret = _pdfioFileFlush(pdf);\n  }\n\n  if (pdf->fd >= 0 && close(pdf->fd) < 0)\n    ret = false;\n\n  // Free all data...\n  free(pdf->filename);\n  free(pdf->version);\n\n  for (i = 0; i < pdf->num_arrays; i ++)\n    _pdfioArrayDelete(pdf->arrays[i]);\n  free(pdf->arrays);\n\n  for (i = 0; i < pdf->num_dicts; i ++)\n    _pdfioDictDelete(pdf->dicts[i]);\n  free(pdf->dicts);\n\n  for (i = 0; i < pdf->num_objs; i ++)\n    _pdfioObjDelete(pdf->objs[i]);\n  free(pdf->objs);\n\n  free(pdf->objmaps);\n\n  free(pdf->pages);\n\n  for (i = 0; i < pdf->num_strings; i ++)\n    free(pdf->strings[i]);\n  free(pdf->strings);\n\n  free(pdf);\n\n  return (ret);\n}\n\n\n//\n// 'pdfioFileCreate()' - Create a PDF file.\n//\n// This function creates a new PDF file.  The \"filename\" argument specifies the\n// name of the PDF file to create.\n//\n// The \"version\" argument specifies the PDF version number for the file or\n// `NULL` for the default (\"2.0\").\n//\n// The \"media_box\" and \"crop_box\" arguments specify the default MediaBox and\n// CropBox for pages in the PDF file - if `NULL` then a default \"Universal\" size\n// of 8.27x11in (the intersection of US Letter and ISO A4) is used.\n//\n// The \"error_cb\" and \"error_data\" arguments specify an error handler callback\n// and its data pointer - if `NULL` the default error handler is used that\n// writes error messages to `stderr`.\n//\n\npdfio_file_t *\t\t\t\t// O - PDF file or `NULL` on error\npdfioFileCreate(\n    const char       *filename,\t\t// I - Filename\n    const char       *version,\t\t// I - PDF version number or `NULL` for default (2.0)\n    pdfio_rect_t     *media_box,\t// I - Default MediaBox for pages\n    pdfio_rect_t     *crop_box,\t\t// I - Default CropBox for pages\n    pdfio_error_cb_t error_cb,\t\t// I - Error callback or `NULL` for default\n    void             *error_data)\t// I - Error callback data, if any\n{\n  pdfio_file_t\t*pdf;\t\t\t// PDF file\n  pdfio_dict_t\t*dict;\t\t\t// Dictionary for pages object\n  pdfio_dict_t\t*info_dict;\t\t// Dictionary for information object\n  unsigned char\tid_value[16];\t\t// File ID value\n\n\n  // Range check input...\n  if (!filename)\n    return (NULL);\n\n  if (!version)\n    version = \"2.0\";\n\n  if (!error_cb)\n  {\n    error_cb   = _pdfioFileDefaultError;\n    error_data = NULL;\n  }\n\n  // Allocate a PDF file structure...\n  if ((pdf = (pdfio_file_t *)calloc(1, sizeof(pdfio_file_t))) == NULL)\n  {\n    pdfio_file_t temp;\t\t\t// Dummy file\n    char\tmessage[8192];\t\t// Message string\n\n    temp.filename = (char *)filename;\n    snprintf(message, sizeof(message), \"Unable to allocate memory for PDF file - %s\", strerror(errno));\n    (error_cb)(&temp, message, error_data);\n    return (NULL);\n  }\n\n  pdf->filename    = strdup(filename);\n  pdf->version     = strdup(version);\n  pdf->mode        = _PDFIO_MODE_WRITE;\n  pdf->error_cb    = error_cb;\n  pdf->error_data  = error_data;\n  pdf->permissions = PDFIO_PERMISSION_ALL;\n  pdf->bufptr      = pdf->buffer;\n  pdf->bufend      = pdf->buffer + sizeof(pdf->buffer);\n\n  if (media_box)\n  {\n    pdf->media_box = *media_box;\n  }\n  else\n  {\n    // Default to \"universal\" size (intersection of A4 and US Letter)\n    pdf->media_box.x2 = 210.0 * 72.0f / 25.4f;\n    pdf->media_box.y2 = 11.0f * 72.0f;\n  }\n\n  if (crop_box)\n  {\n    pdf->crop_box = *crop_box;\n  }\n  else\n  {\n    // Default to \"universal\" size (intersection of A4 and US Letter)\n    pdf->crop_box.x2 = 210.0 * 72.0f / 25.4f;\n    pdf->crop_box.y2 = 11.0f * 72.0f;\n  }\n\n  // Create the file...\n  if ((pdf->fd = open(filename, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, 0666)) < 0)\n  {\n    _pdfioFileError(pdf, \"Unable to create file - %s\", strerror(errno));\n    free(pdf->filename);\n    free(pdf->version);\n    free(pdf);\n    return (NULL);\n  }\n\n  // Write a standard PDF header...\n  if (!_pdfioFilePrintf(pdf, \"%%PDF-%s\\n%%\\342\\343\\317\\323\\n\", version))\n    goto error;\n\n  // Create the pages object...\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    goto error;\n\n  pdfioDictSetName(dict, \"Type\", \"Pages\");\n\n  if ((pdf->pages_obj = pdfioFileCreateObj(pdf, dict)) == NULL)\n    goto error;\n\n  // Create the info object...\n  if ((info_dict = pdfioDictCreate(pdf)) == NULL)\n    goto error;\n\n  pdfioDictSetDate(info_dict, \"CreationDate\", time(NULL));\n  pdfioDictSetString(info_dict, \"Producer\", \"pdfio/\" PDFIO_VERSION);\n\n  if ((pdf->info_obj = pdfioFileCreateObj(pdf, info_dict)) == NULL)\n    goto error;\n\n  // Create random file ID values...\n  _pdfioCryptoMakeRandom(id_value, sizeof(id_value));\n\n  if ((pdf->id_array = pdfioArrayCreate(pdf)) != NULL)\n  {\n    pdfioArrayAppendBinary(pdf->id_array, id_value, sizeof(id_value));\n    pdfioArrayAppendBinary(pdf->id_array, id_value, sizeof(id_value));\n  }\n\n  return (pdf);\n\n  // Common error handling code...\n  error:\n\n  pdfioFileClose(pdf);\n\n  unlink(filename);\n\n  return (NULL);\n}\n\n\n//\n// 'pdfioFileCreateArrayObj()' - Create a new object in a PDF file containing an array.\n//\n// This function creates a new object with an array value in a PDF file.\n// You must call @link pdfioObjClose@ to write the object to the file.\n//\n\npdfio_obj_t *\t\t\t\t// O - New object\npdfioFileCreateArrayObj(\n    pdfio_file_t  *pdf,\t\t\t// I - PDF file\n    pdfio_array_t *array)\t\t// I - Object array\n{\n  _pdfio_value_t\tvalue;\t\t// Object value\n\n\n  // Range check input...\n  if (!pdf || !array)\n    return (NULL);\n\n  value.type        = PDFIO_VALTYPE_ARRAY;\n  value.value.array = array;\n\n  return (_pdfioFileCreateObj(pdf, array->pdf, &value));\n}\n\n\n//\n// 'pdfioFileCreateObj()' - Create a new object in a PDF file.\n//\n\npdfio_obj_t *\t\t\t\t// O - New object\npdfioFileCreateObj(\n    pdfio_file_t *pdf,\t\t\t// I - PDF file\n    pdfio_dict_t *dict)\t\t\t// I - Object dictionary\n{\n  _pdfio_value_t\tvalue;\t\t// Object value\n\n\n  // Range check input...\n  if (!pdf || !dict)\n    return (NULL);\n\n  value.type       = PDFIO_VALTYPE_DICT;\n  value.value.dict = dict;\n\n  return (_pdfioFileCreateObj(pdf, dict->pdf, &value));\n}\n\n\n//\n// '_pdfioFileCreateObj()' - Create a new object in a PDF file with a value.\n//\n\npdfio_obj_t *\t\t\t\t// O - New object\n_pdfioFileCreateObj(\n    pdfio_file_t   *pdf,\t\t// I - PDF file\n    pdfio_file_t   *srcpdf,\t\t// I - Source PDF file, if any\n    _pdfio_value_t *value)\t\t// I - Object dictionary\n{\n  pdfio_obj_t\t*obj;\t\t\t// New object\n\n\n  // Range check input...\n  if (!pdf)\n    return (NULL);\n\n  if (pdf->mode != _PDFIO_MODE_WRITE)\n    return (NULL);\n\n  // Allocate memory for the object...\n  if ((obj = (pdfio_obj_t *)calloc(1, sizeof(pdfio_obj_t))) == NULL)\n  {\n    _pdfioFileError(pdf, \"Unable to allocate memory for object - %s\", strerror(errno));\n    return (NULL);\n  }\n\n  // Expand the objects array as needed\n  if (pdf->num_objs >= pdf->alloc_objs)\n  {\n    pdfio_obj_t **temp = (pdfio_obj_t **)realloc(pdf->objs, (pdf->alloc_objs + 32) * sizeof(pdfio_obj_t *));\n\n    if (!temp)\n    {\n      _pdfioFileError(pdf, \"Unable to allocate memory for object - %s\", strerror(errno));\n      free(obj);\n      return (NULL);\n    }\n\n    pdf->objs       = temp;\n    pdf->alloc_objs += 32;\n  }\n\n  pdf->objs[pdf->num_objs ++] = obj;\n\n  // Initialize the object...\n  obj->pdf    = pdf;\n  obj->number = pdf->num_objs;\n\n  if (value)\n    _pdfioValueCopy(pdf, &obj->value, srcpdf, value);\n\n  // Don't write anything just yet...\n  return (obj);\n}\n\n\n//\n// 'pdfioFileCreateOutput()' - Create a PDF file through an output callback.\n//\n// This function creates a new PDF file that is streamed though an output\n// callback.  The \"output_cb\" and \"output_ctx\" arguments specify the output\n// callback and its context pointer which is called whenever data needs to be\n// written:\n//\n// ```\n// ssize_t\n// output_cb(void *output_ctx, const void *buffer, size_t bytes)\n// {\n//   // Write buffer to output and return the number of bytes written\n// }\n// ```\n//\n// The \"version\" argument specifies the PDF version number for the file or\n// `NULL` for the default (\"2.0\").\n//\n// The \"media_box\" and \"crop_box\" arguments specify the default MediaBox and\n// CropBox for pages in the PDF file - if `NULL` then a default \"Universal\" size\n// of 8.27x11in (the intersection of US Letter and ISO A4) is used.\n//\n// The \"error_cb\" and \"error_data\" arguments specify an error handler callback\n// and its data pointer - if `NULL` the default error handler is used that\n// writes error messages to `stderr`.\n//\n// > *Note*: Files created using this API are slightly larger than those\n// > created using the @link pdfioFileCreate@ function since stream lengths are\n// > stored as indirect object references.\n//\n\npdfio_file_t *\t\t\t\t// O - PDF file or `NULL` on error\npdfioFileCreateOutput(\n    pdfio_output_cb_t output_cb,\t// I - Output callback\n    void              *output_ctx,\t// I - Output context\n    const char        *version,\t\t// I - PDF version number or `NULL` for default (2.0)\n    pdfio_rect_t      *media_box,\t// I - Default MediaBox for pages\n    pdfio_rect_t      *crop_box,\t// I - Default CropBox for pages\n    pdfio_error_cb_t  error_cb,\t\t// I - Error callback or `NULL` for default\n    void              *error_data)\t// I - Error callback data, if any\n{\n  pdfio_file_t\t*pdf;\t\t\t// PDF file\n  pdfio_dict_t\t*dict;\t\t\t// Dictionary for pages object\n  pdfio_dict_t\t*info_dict;\t\t// Dictionary for information object\n  unsigned char\tid_value[16];\t\t// File ID value\n\n\n  // Range check input...\n  if (!output_cb)\n    return (NULL);\n\n  if (!version)\n    version = \"2.0\";\n\n  if (!error_cb)\n  {\n    error_cb   = _pdfioFileDefaultError;\n    error_data = NULL;\n  }\n\n  // Allocate a PDF file structure...\n  if ((pdf = (pdfio_file_t *)calloc(1, sizeof(pdfio_file_t))) == NULL)\n  {\n    pdfio_file_t temp;\t\t\t// Dummy file\n    char\tmessage[8192];\t\t// Message string\n\n    temp.filename = (char *)\"output.pdf\";\n    snprintf(message, sizeof(message), \"Unable to allocate memory for PDF file - %s\", strerror(errno));\n    (error_cb)(&temp, message, error_data);\n    return (NULL);\n  }\n\n  pdf->filename    = strdup(\"output.pdf\");\n  pdf->version     = strdup(version);\n  pdf->mode        = _PDFIO_MODE_WRITE;\n  pdf->error_cb    = error_cb;\n  pdf->error_data  = error_data;\n  pdf->permissions = PDFIO_PERMISSION_ALL;\n  pdf->bufptr      = pdf->buffer;\n  pdf->bufend      = pdf->buffer + sizeof(pdf->buffer);\n\n  if (media_box)\n  {\n    pdf->media_box = *media_box;\n  }\n  else\n  {\n    // Default to \"universal\" size (intersection of A4 and US Letter)\n    pdf->media_box.x2 = 210.0 * 72.0f / 25.4f;\n    pdf->media_box.y2 = 11.0f * 72.0f;\n  }\n\n  if (crop_box)\n  {\n    pdf->crop_box = *crop_box;\n  }\n  else\n  {\n    // Default to \"universal\" size (intersection of A4 and US Letter)\n    pdf->crop_box.x2 = 210.0 * 72.0f / 25.4f;\n    pdf->crop_box.y2 = 11.0f * 72.0f;\n  }\n\n  // Save output callback...\n  pdf->fd         = -1;\n  pdf->output_cb  = output_cb;\n  pdf->output_ctx = output_ctx;\n\n  // Write a standard PDF header...\n  if (!_pdfioFilePrintf(pdf, \"%%PDF-%s\\n%%\\342\\343\\317\\323\\n\", version))\n    goto error;\n\n  // Create the pages object...\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    goto error;\n\n  pdfioDictSetName(dict, \"Type\", \"Pages\");\n\n  if ((pdf->pages_obj = pdfioFileCreateObj(pdf, dict)) == NULL)\n    goto error;\n\n  // Create the info object...\n  if ((info_dict = pdfioDictCreate(pdf)) == NULL)\n    goto error;\n\n  pdfioDictSetDate(info_dict, \"CreationDate\", time(NULL));\n  pdfioDictSetString(info_dict, \"Producer\", \"pdfio/\" PDFIO_VERSION);\n\n  if ((pdf->info_obj = pdfioFileCreateObj(pdf, info_dict)) == NULL)\n    goto error;\n\n  // Create random file ID values...\n  _pdfioCryptoMakeRandom(id_value, sizeof(id_value));\n\n  if ((pdf->id_array = pdfioArrayCreate(pdf)) != NULL)\n  {\n    pdfioArrayAppendBinary(pdf->id_array, id_value, sizeof(id_value));\n    pdfioArrayAppendBinary(pdf->id_array, id_value, sizeof(id_value));\n  }\n\n  return (pdf);\n\n  // Common error handling code...\n  error:\n\n  pdfioFileClose(pdf);\n\n  return (NULL);\n}\n\n\n//\n// 'pdfioFileCreatePage()' - Create a page in a PDF file.\n//\n\npdfio_stream_t *\t\t\t// O - Contents stream\npdfioFileCreatePage(pdfio_file_t *pdf,\t// I - PDF file\n                    pdfio_dict_t *dict)\t// I - Page dictionary\n{\n  pdfio_obj_t\t*page,\t\t\t// Page object\n\t\t*contents;\t\t// Contents object\n  pdfio_dict_t\t*contents_dict;\t\t// Dictionary for Contents object\n\n\n  // Range check input...\n  if (!pdf)\n    return (NULL);\n\n  // Copy the page dictionary...\n  if (dict)\n    dict = pdfioDictCopy(pdf, dict);\n  else\n    dict = pdfioDictCreate(pdf);\n\n  if (!dict)\n    return (NULL);\n\n  // Make sure the page dictionary has all of the required keys...\n  if (!_pdfioDictGetValue(dict, \"CropBox\"))\n    pdfioDictSetRect(dict, \"CropBox\", &pdf->crop_box);\n\n  if (!_pdfioDictGetValue(dict, \"MediaBox\"))\n    pdfioDictSetRect(dict, \"MediaBox\", &pdf->media_box);\n\n  pdfioDictSetObj(dict, \"Parent\", pdf->pages_obj);\n\n  if (!_pdfioDictGetValue(dict, \"Resources\"))\n    pdfioDictSetDict(dict, \"Resources\", pdfioDictCreate(pdf));\n\n  if (!_pdfioDictGetValue(dict, \"Type\"))\n    pdfioDictSetName(dict, \"Type\", \"Page\");\n\n  // Create the page object...\n  if ((page = pdfioFileCreateObj(pdf, dict)) == NULL)\n    return (NULL);\n\n  // Create a contents object to hold the contents of the page...\n  if ((contents_dict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n\n#ifndef DEBUG\n  pdfioDictSetName(contents_dict, \"Filter\", \"FlateDecode\");\n#endif // !DEBUG\n\n  if ((contents = pdfioFileCreateObj(pdf, contents_dict)) == NULL)\n    return (NULL);\n\n  // Add the contents stream to the pages object and write it...\n  pdfioDictSetObj(dict, \"Contents\", contents);\n  if (!pdfioObjClose(page))\n    return (NULL);\n\n  if (!_pdfioFileAddPage(pdf, page))\n    return (NULL);\n\n  // Create the contents stream...\n#ifdef DEBUG\n  return (pdfioObjCreateStream(contents, PDFIO_FILTER_NONE));\n#else\n  return (pdfioObjCreateStream(contents, PDFIO_FILTER_FLATE));\n#endif // DEBUG\n}\n\n\n//\n// 'pdfioFileCreateTemporary()' - Create a temporary PDF file.\n//\n// This function creates a PDF file with a unique filename in the current\n// temporary directory.  The temporary file is stored in the string \"buffer\" an\n// will have a \".pdf\" extension.  Otherwise, this function works the same as\n// the @link pdfioFileCreate@ function.\n//\n// @since PDFio v1.1@\n//\n\npdfio_file_t *\npdfioFileCreateTemporary(\n    char             *buffer,\t\t// I - Filename buffer\n    size_t           bufsize,\t\t// I - Size of filename buffer\n    const char       *version,\t\t// I - PDF version number or `NULL` for default (2.0)\n    pdfio_rect_t     *media_box,\t// I - Default MediaBox for pages\n    pdfio_rect_t     *crop_box,\t\t// I - Default CropBox for pages\n    pdfio_error_cb_t error_cb,\t\t// I - Error callback or `NULL` for default\n    void             *error_data)\t// I - Error callback data, if any\n{\n  pdfio_file_t\t*pdf;\t\t\t// PDF file\n  pdfio_dict_t\t*dict;\t\t\t// Dictionary for pages object\n  pdfio_dict_t\t*info_dict;\t\t// Dictionary for information object\n  unsigned char\tid_value[16];\t\t// File ID value\n  int\t\ti;\t\t\t// Looping var\n  const char\t*tmpdir;\t\t// Temporary directory\n#if _WIN32 || defined(__APPLE__)\n  char\t\ttmppath[256];\t\t// Temporary directory path\n#endif // _WIN32 || __APPLE__\n  unsigned\ttmpnum;\t\t\t// Temporary filename number\n\n\n  // Range check input...\n  if (!buffer || bufsize < 32)\n  {\n    if (buffer)\n      *buffer = '\\0';\n    return (NULL);\n  }\n\n  if (!version)\n    version = \"2.0\";\n\n  if (!error_cb)\n  {\n    error_cb   = _pdfioFileDefaultError;\n    error_data = NULL;\n  }\n\n  // Allocate a PDF file structure...\n  if ((pdf = (pdfio_file_t *)calloc(1, sizeof(pdfio_file_t))) == NULL)\n  {\n    pdfio_file_t temp;\t\t\t// Dummy file\n    char\tmessage[8192];\t\t// Message string\n\n    temp.filename = (char *)\"temporary.pdf\";\n    snprintf(message, sizeof(message), \"Unable to allocate memory for PDF file - %s\", strerror(errno));\n    (error_cb)(&temp, message, error_data);\n\n    *buffer = '\\0';\n\n    return (NULL);\n  }\n\n  // Create the file...\n#if _WIN32\n  if ((tmpdir = getenv(\"TEMP\")) == NULL)\n  {\n    GetTempPathA(sizeof(tmppath), tmppath);\n    tmpdir = tmppath;\n  }\n\n#elif defined(__APPLE__)\n  if ((tmpdir = getenv(\"TMPDIR\")) != NULL && access(tmpdir, W_OK))\n    tmpdir = NULL;\n\n  if (!tmpdir)\n  {\n    // Grab the per-process temporary directory for sandboxed apps...\n#  ifdef _CS_DARWIN_USER_TEMP_DIR\n    if (confstr(_CS_DARWIN_USER_TEMP_DIR, tmppath, sizeof(tmppath)))\n      tmpdir = tmppath;\n    else\n#  endif // _CS_DARWIN_USER_TEMP_DIR\n      tmpdir = \"/private/tmp\";\n  }\n\n#else\n  if ((tmpdir = getenv(\"TMPDIR\")) == NULL || access(tmpdir, W_OK))\n    tmpdir = \"/tmp\";\n#endif // _WIN32\n\n  for (i = 0; i < 1000; i ++)\n  {\n    _pdfioCryptoMakeRandom((uint8_t *)&tmpnum, sizeof(tmpnum));\n    snprintf(buffer, bufsize, \"%s/%08x.pdf\", tmpdir, tmpnum);\n    if ((pdf->fd = open(buffer, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC | O_EXCL, 0666)) >= 0)\n      break;\n  }\n\n  pdf->filename = strdup(buffer);\n\n  if (i >= 1000)\n  {\n    _pdfioFileError(pdf, \"Unable to create file - %s\", strerror(errno));\n    free(pdf->filename);\n    free(pdf);\n    *buffer = '\\0';\n    return (NULL);\n  }\n\n  pdf->version     = strdup(version);\n  pdf->mode        = _PDFIO_MODE_WRITE;\n  pdf->error_cb    = error_cb;\n  pdf->error_data  = error_data;\n  pdf->permissions = PDFIO_PERMISSION_ALL;\n  pdf->bufptr      = pdf->buffer;\n  pdf->bufend      = pdf->buffer + sizeof(pdf->buffer);\n\n  if (media_box)\n  {\n    pdf->media_box = *media_box;\n  }\n  else\n  {\n    // Default to \"universal\" size (intersection of A4 and US Letter)\n    pdf->media_box.x2 = 210.0 * 72.0f / 25.4f;\n    pdf->media_box.y2 = 11.0f * 72.0f;\n  }\n\n  if (crop_box)\n  {\n    pdf->crop_box = *crop_box;\n  }\n  else\n  {\n    // Default to \"universal\" size (intersection of A4 and US Letter)\n    pdf->crop_box.x2 = 210.0 * 72.0f / 25.4f;\n    pdf->crop_box.y2 = 11.0f * 72.0f;\n  }\n\n  // Write a standard PDF header...\n  if (!_pdfioFilePrintf(pdf, \"%%PDF-%s\\n%%\\342\\343\\317\\323\\n\", version))\n    goto error;\n\n  // Create the pages object...\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    goto error;\n\n  pdfioDictSetName(dict, \"Type\", \"Pages\");\n\n  if ((pdf->pages_obj = pdfioFileCreateObj(pdf, dict)) == NULL)\n    goto error;\n\n  // Create the info object...\n  if ((info_dict = pdfioDictCreate(pdf)) == NULL)\n    goto error;\n\n  pdfioDictSetDate(info_dict, \"CreationDate\", time(NULL));\n  pdfioDictSetString(info_dict, \"Producer\", \"pdfio/\" PDFIO_VERSION);\n\n  if ((pdf->info_obj = pdfioFileCreateObj(pdf, info_dict)) == NULL)\n    goto error;\n\n  // Create random file ID values...\n  _pdfioCryptoMakeRandom(id_value, sizeof(id_value));\n\n  if ((pdf->id_array = pdfioArrayCreate(pdf)) != NULL)\n  {\n    pdfioArrayAppendBinary(pdf->id_array, id_value, sizeof(id_value));\n    pdfioArrayAppendBinary(pdf->id_array, id_value, sizeof(id_value));\n  }\n\n  return (pdf);\n\n  // Common error handling code...\n  error:\n\n  pdfioFileClose(pdf);\n\n  unlink(buffer);\n  *buffer = '\\0';\n\n  return (NULL);\n}\n\n\n//\n// '_pdfioFileFindMappedObj()' - Find a mapped object.\n//\n\npdfio_obj_t *\t\t\t\t// O - Match object or `NULL` if none\n_pdfioFileFindMappedObj(\n    pdfio_file_t *pdf,\t\t\t// I - Destination PDF file\n    pdfio_file_t *src_pdf,\t\t// I - Source PDF file\n    size_t       src_number)\t\t// I - Source object number\n{\n  _pdfio_objmap_t\tkey,\t\t// Search key\n\t\t\t*match;\t\t// Matching object map\n\n\n  // If we have no mapped objects, return NULL immediately...\n  if (pdf->num_objmaps == 0)\n    return (NULL);\n\n  // Otherwise search for a match...\n  key.src_pdf    = src_pdf;\n  key.src_number = src_number;\n\n  if ((match = (_pdfio_objmap_t *)bsearch(&key, pdf->objmaps, pdf->num_objmaps, sizeof(_pdfio_objmap_t), (int (*)(const void *, const void *))compare_objmaps)) != NULL)\n    return (match->obj);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioFileFindObj()' - Find an object using its object number.\n//\n// This differs from @link pdfioFileGetObj@ which takes an index into the\n// list of objects while this function takes the object number.\n//\n\npdfio_obj_t *\t\t\t\t// O - Object or `NULL` if not found\npdfioFileFindObj(\n    pdfio_file_t *pdf,\t\t\t// I - PDF file\n    size_t       number)\t\t// I - Object number (1 to N)\n{\n  pdfio_obj_t\tkey,\t\t\t// Search key\n\t\t*keyptr,\t\t// Pointer to key\n\t\t**match;\t\t// Pointer to match\n\n\n  if (pdf->num_objs > 0)\n  {\n    key.number = number;\n    keyptr     = &key;\n    match      = (pdfio_obj_t **)bsearch(&keyptr, pdf->objs, pdf->num_objs, sizeof(pdfio_obj_t *), (int (*)(const void *, const void *))compare_objs);\n\n    return (match ? *match : NULL);\n  }\n\n  return (NULL);\n}\n\n\n//\n// 'pdfioFileGetAuthor()' - Get the author for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Author or `NULL` for none\npdfioFileGetAuthor(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (get_info_string(pdf, \"Author\"));\n}\n\n\n//\n// 'pdfioFileGetCreationDate()' - Get the creation date for a PDF file.\n//\n\ntime_t\t\t\t\t\t// O - Creation date or `0` for none\npdfioFileGetCreationDate(\n    pdfio_file_t *pdf)\t\t\t// I - PDF file\n{\n  return (pdf && pdf->info_obj ? pdfioDictGetDate(pdfioObjGetDict(pdf->info_obj), \"CreationDate\") : 0);\n}\n\n\n//\n// 'pdfioFileGetCreator()' - Get the creator string for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Creator string or `NULL` for none\npdfioFileGetCreator(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (get_info_string(pdf, \"Creator\"));\n}\n\n\n//\n// 'pdfioFileGetID()' - Get the PDF file's ID strings.\n//\n\npdfio_array_t *\t\t\t\t// O - Array with binary strings\npdfioFileGetID(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (pdf ? pdf->id_array : NULL);\n}\n\n\n//\n// 'pdfioFileGetKeywords()' - Get the keywords for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Keywords string or `NULL` for none\npdfioFileGetKeywords(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (get_info_string(pdf, \"Keywords\"));\n}\n\n\n//\n// 'pdfioFileGetName()' - Get a PDF's filename.\n//\n\nconst char *\t\t\t\t// O - Filename\npdfioFileGetName(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (pdf ? pdf->filename : NULL);\n}\n\n\n//\n// 'pdfioFileGetNumObjs()' - Get the number of objects in a PDF file.\n//\n\nsize_t\t\t\t\t\t// O - Number of objects\npdfioFileGetNumObjs(\n    pdfio_file_t *pdf)\t\t\t// I - PDF file\n{\n  return (pdf ? pdf->num_objs : 0);\n}\n\n\n//\n// 'pdfioFileGetNumPages()' - Get the number of pages in a PDF file.\n//\n\nsize_t\t\t\t\t\t// O - Number of pages\npdfioFileGetNumPages(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (pdf ? pdf->num_pages : 0);\n}\n\n\n//\n// 'pdfioFileGetObj()' - Get an object from a PDF file.\n//\n\npdfio_obj_t *\t\t\t\t// O - Object\npdfioFileGetObj(pdfio_file_t *pdf,\t// I - PDF file\n                size_t       n)\t\t// I - Object index (starting at 0)\n{\n  if (!pdf || n >= pdf->num_objs)\n    return (NULL);\n  else\n    return (pdf->objs[n]);\n}\n\n\n//\n// 'pdfioFileGetPage()' - Get a page object from a PDF file.\n//\n\npdfio_obj_t *\t\t\t\t// O - Object\npdfioFileGetPage(pdfio_file_t *pdf,\t// I - PDF file\n                 size_t       n)\t// I - Page index (starting at 0)\n{\n  if (!pdf || n >= pdf->num_pages)\n    return (NULL);\n  else\n    return (pdf->pages[n]);\n}\n\n\n//\n// 'pdfioFileGetPermissions()' - Get the access permissions of a PDF file.\n//\n// This function returns the access permissions of a PDF file and (optionally)\n// the type of encryption that has been used.\n//\n\npdfio_permission_t\t\t\t// O - Permission bits\npdfioFileGetPermissions(\n    pdfio_file_t       *pdf,\t\t// I - PDF file\n    pdfio_encryption_t *encryption)\t// O - Type of encryption used or `NULL` to ignore\n{\n  // Range check input...\n  if (!pdf)\n  {\n    if (encryption)\n      *encryption = PDFIO_ENCRYPTION_NONE;\n\n    return (PDFIO_PERMISSION_ALL);\n  }\n\n  // Return values...\n  if (encryption)\n    *encryption = pdf->encryption;\n\n  return (pdf->permissions);\n}\n\n\n//\n// 'pdfioFileGetProducer()' - Get the producer string for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Producer string or `NULL` for none\npdfioFileGetProducer(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (get_info_string(pdf, \"Producer\"));\n}\n\n\n//\n// 'pdfioFileGetSubject()' - Get the subject for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Subject or `NULL` for none\npdfioFileGetSubject(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (get_info_string(pdf, \"Subject\"));\n}\n\n\n//\n// 'pdfioFileGetTitle()' - Get the title for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Title or `NULL` for none\npdfioFileGetTitle(pdfio_file_t *pdf)\t// I - PDF file\n{\n  return (get_info_string(pdf, \"Title\"));\n}\n\n\n//\n// 'pdfioFileGetVersion()' - Get the PDF version number for a PDF file.\n//\n\nconst char *\t\t\t\t// O - Version number or `NULL`\npdfioFileGetVersion(\n    pdfio_file_t *pdf)\t\t\t// I - PDF file\n{\n  return (pdf ? pdf->version : NULL);\n}\n\n\n//\n// 'pdfioFileOpen()' - Open a PDF file for reading.\n//\n// This function opens an existing PDF file.  The \"filename\" argument specifies\n// the name of the PDF file to create.\n//\n// The \"password_cb\" and \"password_data\" arguments specify a password callback\n// and its data pointer for PDF files that use one of the standard Adobe\n// \"security\" handlers.  The callback returns a password string or `NULL` to\n// cancel the open.  If `NULL` is specified for the callback function and the\n// PDF file requires a password, the open will always fail.\n//\n// The \"error_cb\" and \"error_data\" arguments specify an error handler callback\n// and its data pointer - if `NULL` the default error handler is used that\n// writes error messages to `stderr`.\n//\n\npdfio_file_t *\t\t\t\t// O - PDF file\npdfioFileOpen(\n    const char          *filename,\t// I - Filename\n    pdfio_password_cb_t password_cb,\t// I - Password callback or `NULL` for none\n    void                *password_data,\t// I - Password callback data, if any\n    pdfio_error_cb_t    error_cb,\t// I - Error callback or `NULL` for default\n    void                *error_data)\t// I - Error callback data, if any\n{\n  pdfio_file_t\t*pdf;\t\t\t// PDF file\n  char\t\tline[1024],\t\t// Line from file\n\t\t*ptr;\t\t\t// Pointer into line\n  off_t\t\txref_offset;\t\t// Offset to xref table\n\n\n  // Range check input...\n  if (!filename)\n    return (NULL);\n\n  if (!error_cb)\n  {\n    error_cb   = _pdfioFileDefaultError;\n    error_data = NULL;\n  }\n\n  // Allocate a PDF file structure...\n  if ((pdf = (pdfio_file_t *)calloc(1, sizeof(pdfio_file_t))) == NULL)\n  {\n    pdfio_file_t temp;\t\t\t// Dummy file\n    char\tmessage[8192];\t\t// Message string\n\n    temp.filename = (char *)filename;\n    snprintf(message, sizeof(message), \"Unable to allocate memory for PDF file - %s\", strerror(errno));\n    (error_cb)(&temp, message, error_data);\n    return (NULL);\n  }\n\n  pdf->filename    = strdup(filename);\n  pdf->mode        = _PDFIO_MODE_READ;\n  pdf->error_cb    = error_cb;\n  pdf->error_data  = error_data;\n  pdf->permissions = PDFIO_PERMISSION_ALL;\n\n  // Open the file...\n  if ((pdf->fd = open(filename, O_RDONLY | O_BINARY)) < 0)\n  {\n    _pdfioFileError(pdf, \"Unable to open file - %s\", strerror(errno));\n    free(pdf->filename);\n    free(pdf);\n    return (NULL);\n  }\n\n  // Read the header from the first line...\n  if (!_pdfioFileGets(pdf, line, sizeof(line)))\n    goto error;\n\n  if ((strncmp(line, \"%PDF-1.\", 7) && strncmp(line, \"%PDF-2.\", 7)) || !isdigit(line[7] & 255))\n  {\n    // Bad header\n    _pdfioFileError(pdf, \"Bad header '%s'.\", line);\n    goto error;\n  }\n\n  // Copy the version number...\n  pdf->version = strdup(line + 5);\n\n  // Grab the last 32 characters of the file to find the start of the xref table...\n  if (_pdfioFileSeek(pdf, -32, SEEK_END) < 0)\n  {\n    _pdfioFileError(pdf, \"Unable to read startxref data.\");\n    goto error;\n  }\n\n  if (_pdfioFileRead(pdf, line, 32) < 32)\n  {\n    _pdfioFileError(pdf, \"Unable to read startxref data.\");\n    goto error;\n  }\n  line[32] = '\\0';\n\n  if ((ptr = strstr(line, \"startxref\")) == NULL)\n  {\n    _pdfioFileError(pdf, \"Unable to find start of xref table.\");\n    goto error;\n  }\n\n  xref_offset = (off_t)strtol(ptr + 9, NULL, 10);\n\n  if (!load_xref(pdf, xref_offset, password_cb, password_data))\n    goto error;\n\n  return (pdf);\n\n\n  // If we get here we had a fatal read error...\n  error:\n\n  pdfioFileClose(pdf);\n\n  return (NULL);\n}\n\n\n//\n// 'pdfioFileSetAuthor()' - Set the author for a PDF file.\n//\n\nvoid\npdfioFileSetAuthor(pdfio_file_t *pdf,\t// I - PDF file\n                   const char   *value)\t// I - Value\n{\n  if (pdf && pdf->info_obj)\n    pdfioDictSetString(pdf->info_obj->value.value.dict, \"Author\", pdfioStringCreate(pdf, value));\n}\n\n\n//\n// 'pdfioFileSetCreationDate()' - Set the creation date for a PDF file.\n//\n\nvoid\npdfioFileSetCreationDate(\n    pdfio_file_t *pdf,\t\t\t// I - PDF file\n    time_t       value)\t\t\t// I - Value\n{\n  if (pdf && pdf->info_obj)\n    pdfioDictSetDate(pdf->info_obj->value.value.dict, \"CreationDate\", value);\n}\n\n\n//\n// 'pdfioFileSetCreator()' - Set the creator string for a PDF file.\n//\n\nvoid\npdfioFileSetCreator(pdfio_file_t *pdf,\t// I - PDF file\n                    const char   *value)// I - Value\n{\n  if (pdf && pdf->info_obj)\n    pdfioDictSetString(pdf->info_obj->value.value.dict, \"Creator\", pdfioStringCreate(pdf, value));\n}\n\n\n//\n// 'pdfioFileSetKeywords()' - Set the keywords string for a PDF file.\n//\n\nvoid\npdfioFileSetKeywords(\n    pdfio_file_t *pdf,\t\t\t// I - PDF file\n    const char   *value)\t\t// I - Value\n{\n  if (pdf && pdf->info_obj)\n    pdfioDictSetString(pdf->info_obj->value.value.dict, \"Keywords\", pdfioStringCreate(pdf, value));\n}\n\n\n//\n// 'pdfioFileSetPermissions()' - Set the PDF permissions, encryption mode, and passwords.\n//\n// This function sets the PDF usage permissions, encryption mode, and\n// passwords.\n//\n// > *Note*: This function must be called before creating or copying any\n// > objects.  Due to fundamental limitations in the PDF format, PDF encryption\n// > offers little protection from disclosure.  Permissions are not enforced in\n// > any meaningful way.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` otherwise\npdfioFileSetPermissions(\n    pdfio_file_t       *pdf,\t\t// I - PDF file\n    pdfio_permission_t permissions,\t// I - Use permissions\n    pdfio_encryption_t encryption,\t// I - Type of encryption to use\n    const char         *owner_password,\t// I - Owner password, if any\n    const char         *user_password)\t// I - User password, if any\n{\n  if (!pdf)\n    return (false);\n\n  if (pdf->num_objs > 2)\t\t// First two objects are pages and info\n  {\n    _pdfioFileError(pdf, \"You must call pdfioFileSetPermissions before adding any objects.\");\n    return (false);\n  }\n\n  if (encryption == PDFIO_ENCRYPTION_NONE)\n    return (true);\n\n  return (_pdfioCryptoLock(pdf, permissions, encryption, owner_password, user_password));\n}\n\n\n//\n// 'pdfioFileSetSubject()' - Set the subject for a PDF file.\n//\n\nvoid\npdfioFileSetSubject(\n    pdfio_file_t *pdf,\t\t\t// I - PDF file\n    const char   *value)\t\t// I - Value\n{\n  if (pdf && pdf->info_obj)\n    pdfioDictSetString(pdf->info_obj->value.value.dict, \"Subject\", pdfioStringCreate(pdf, value));\n}\n\n\n//\n// 'pdfioFileSetTitle()' - Set the title for a PDF file.\n//\n\nvoid\npdfioFileSetTitle(pdfio_file_t *pdf,\t// I - PDF file\n                  const char   *value)\t// I - Value\n{\n  if (pdf && pdf->info_obj)\n    pdfioDictSetString(pdf->info_obj->value.value.dict, \"Title\", pdfioStringCreate(pdf, value));\n}\n\n\n//\n// '_pdfioObjAdd()' - Add an object to a file.\n//\n\nstatic pdfio_obj_t *\t\t\t// O - Object\nadd_obj(pdfio_file_t   *pdf,\t\t// I - PDF file\n\tsize_t         number,\t\t// I - Object number\n\tunsigned short generation,\t// I - Object generation\n\toff_t          offset)\t\t// I - Offset in file\n{\n  pdfio_obj_t\t*obj;\t\t\t// Object\n\n\n  // Allocate memory for the object...\n  if ((obj = (pdfio_obj_t *)calloc(1, sizeof(pdfio_obj_t))) == NULL)\n  {\n    _pdfioFileError(pdf, \"Unable to allocate memory for object - %s\", strerror(errno));\n    return (NULL);\n  }\n\n  // Expand the objects array as needed\n  if (pdf->num_objs >= pdf->alloc_objs)\n  {\n    pdfio_obj_t **temp = (pdfio_obj_t **)realloc(pdf->objs, (pdf->alloc_objs + 32) * sizeof(pdfio_obj_t *));\n\n    if (!temp)\n    {\n      _pdfioFileError(pdf, \"Unable to allocate memory for object - %s\", strerror(errno));\n      free(obj);\n      return (NULL);\n    }\n\n    pdf->objs       = temp;\n    pdf->alloc_objs += 32;\n  }\n\n  pdf->objs[pdf->num_objs ++] = obj;\n\n  obj->pdf        = pdf;\n  obj->number     = number;\n  obj->generation = generation;\n  obj->offset     = offset;\n\n  PDFIO_DEBUG(\"add_obj: obj=%p, ->pdf=%p, ->number=%lu\\n\", obj, pdf, (unsigned long)obj->number);\n\n  // Re-sort object array as needed...\n  if (pdf->num_objs > 1 && pdf->objs[pdf->num_objs - 2]->number > number)\n    qsort(pdf->objs, pdf->num_objs, sizeof(pdfio_obj_t *), (int (*)(const void *, const void *))compare_objs);\n\n  return (obj);\n}\n\n\n//\n// 'compare_objmaps()' - Compare two object maps...\n//\n\nstatic int\t\t\t\t// O - Result of comparison\ncompare_objmaps(_pdfio_objmap_t *a,\t// I - First object map\n                _pdfio_objmap_t *b)\t// I - Second object map\n{\n  if (a->src_pdf < b->src_pdf)\n    return (-1);\n  else if (a->src_pdf > b->src_pdf)\n    return (1);\n  else if (a->src_number < b->src_number)\n    return (-1);\n  else if (a->src_number > b->src_number)\n    return (1);\n  else\n    return (0);\n}\n\n\n//\n// 'compare_objs()' - Compare the object numbers of two objects.\n//\n\nstatic int\t\t\t\t// O - Result of comparison\ncompare_objs(pdfio_obj_t **a,\t\t// I - First object\n             pdfio_obj_t **b)\t\t// I - Second object\n{\n  if ((*a)->number < (*b)->number)\n    return (-1);\n  else if ((*a)->number == (*b)->number)\n    return (0);\n  else\n    return (1);\n}\n\n\n//\n// 'get_info_string()' - Get a string value from the Info dictionary.\n//\n// This function also handles converting binary strings to C strings, which\n// occur in encrypted PDF files.\n//\n\nstatic const char *\t\t\t// O - String or `NULL` if not found\nget_info_string(pdfio_file_t *pdf,\t// I - PDF file\n                const char   *key)\t// I - Dictionary key\n{\n  pdfio_dict_t\t*dict;\t\t\t// Info dictionary\n  _pdfio_value_t *value;\t\t// Value\n\n  // Range check input...\n  if (!pdf || !pdf->info_obj || (dict = pdfioObjGetDict(pdf->info_obj)) == NULL || (value = _pdfioDictGetValue(dict, key)) == NULL)\n    return (NULL);\n\n  // If we already have a value, return it...\n  if (value->type == PDFIO_VALTYPE_NAME || value->type == PDFIO_VALTYPE_STRING)\n  {\n    return (value->value.string);\n  }\n  else if (value->type == PDFIO_VALTYPE_BINARY && value->value.binary.datalen < 4096)\n  {\n    // Convert binary string to regular string...\n    char\ttemp[4096];\t\t// Temporary string\n\n    memcpy(temp, value->value.binary.data, value->value.binary.datalen);\n    temp[value->value.binary.datalen] = '\\0';\n\n    free(value->value.binary.data);\n    value->type         = PDFIO_VALTYPE_STRING;\n    value->value.string = pdfioStringCreate(pdf, temp);\n\n    return (value->value.string);\n  }\n  else\n  {\n    // Something else that is not a string...\n    return (NULL);\n  }\n}\n\n\n//\n// 'load_obj_stream()' - Load an object stream.\n//\n// Object streams are Adobe's complicated solution for saving a few\n// kilobytes in an average PDF file at the expense of massively more\n// complicated reader applications.\n//\n// Each object stream starts with pairs of object numbers and offsets,\n// followed by the object values (typically dictionaries).  For\n// simplicity pdfio loads all of these values into memory so that we\n// don't later have to randomly access compressed stream data to get\n// a dictionary.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on error\nload_obj_stream(pdfio_obj_t *obj)\t// I - Object to load\n{\n  pdfio_stream_t\t*st;\t\t// Stream\n  _pdfio_token_t\ttb;\t\t// Token buffer/stack\n  char\t\t\tbuffer[32];\t// Token\n  size_t\t\tnumber,\t\t// Object number\n\t\t\tcur_obj,\t// Current object\n\t\t\tnum_objs = 0;\t// Number of objects\n  pdfio_obj_t\t\t*objs[16384];\t// Objects\n\n\n  PDFIO_DEBUG(\"load_obj_stream(obj=%p(%d))\\n\", obj, (int)obj->number);\n\n  // Open the object stream...\n  if ((st = pdfioObjOpenStream(obj, true)) == NULL)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to open compressed object stream %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  _pdfioTokenInit(&tb, obj->pdf, (_pdfio_tconsume_cb_t)pdfioStreamConsume, (_pdfio_tpeek_cb_t)pdfioStreamPeek, st);\n\n  // Read the object numbers from the beginning of the stream...\n  while (_pdfioTokenGet(&tb, buffer, sizeof(buffer)))\n  {\n    // Stop if this isn't an object number...\n    if (!isdigit(buffer[0] & 255))\n      break;\n\n    // Stop if we have too many objects...\n    if (num_objs >= (sizeof(objs) / sizeof(objs[0])))\n    {\n      _pdfioFileError(obj->pdf, \"Too many compressed objects in one stream.\");\n      pdfioStreamClose(st);\n      return (false);\n    }\n\n    // Add the object in memory...\n    number = (size_t)strtoimax(buffer, NULL, 10);\n\n    if ((objs[num_objs] = pdfioFileFindObj(obj->pdf, number)) == NULL)\n      objs[num_objs] = add_obj(obj->pdf, number, 0, 0);\n\n    num_objs ++;\n\n    // Skip offset\n    _pdfioTokenGet(&tb, buffer, sizeof(buffer));\n  }\n\n  if (!buffer[0])\n  {\n    pdfioStreamClose(st);\n    return (false);\n  }\n\n  _pdfioTokenPush(&tb, buffer);\n\n  // Read the objects themselves...\n  for (cur_obj = 0; cur_obj < num_objs; cur_obj ++)\n  {\n    if (!_pdfioValueRead(obj->pdf, obj, &tb, &(objs[cur_obj]->value), 0))\n    {\n      pdfioStreamClose(st);\n      return (false);\n    }\n  }\n\n  // Close the stream and return\n  pdfioStreamClose(st);\n\n  return (true);\n}\n\n\n//\n// 'load_pages()' - Load pages in the document.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on error\nload_pages(pdfio_file_t *pdf,\t\t// I - PDF file\n           pdfio_obj_t  *obj,\t\t// I - Page object\n           size_t       depth)\t\t// I - Depth of page tree\n{\n  pdfio_dict_t\t*dict;\t\t\t// Page object dictionary\n  const char\t*type;\t\t\t// Node type\n  pdfio_array_t\t*kids;\t\t\t// Kids array\n\n\n  // Range check input...\n  if (!obj)\n  {\n    _pdfioFileError(pdf, \"Unable to find pages object.\");\n    return (false);\n  }\n\n  // Get the object dictionary and make sure this is a Pages or Page object...\n  if ((dict = pdfioObjGetDict(obj)) == NULL)\n  {\n    _pdfioFileError(pdf, \"No dictionary for pages object.\");\n    return (false);\n  }\n\n  if ((type = pdfioDictGetName(dict, \"Type\")) == NULL || (strcmp(type, \"Pages\") && strcmp(type, \"Page\")))\n    return (false);\n\n  // If there is a Kids array, then this is a parent node and we have to look\n  // at the child objects...\n  if ((kids = pdfioDictGetArray(dict, \"Kids\")) != NULL)\n  {\n    // Load the child objects...\n    size_t\ti,\t\t\t// Looping var\n\t\tnum_kids;\t\t// Number of elements in array\n\n    if (depth >= PDFIO_MAX_DEPTH)\n    {\n      _pdfioFileError(pdf, \"Depth of pages objects too great to load.\");\n      return (false);\n    }\n\n    for (i = 0, num_kids = pdfioArrayGetSize(kids); i < num_kids; i ++)\n    {\n      if (!load_pages(pdf, pdfioArrayGetObj(kids, i), depth + 1))\n        return (false);\n    }\n  }\n  else\n  {\n    // Add this page...\n    if (pdf->num_pages >= pdf->alloc_pages)\n    {\n      pdfio_obj_t **temp = (pdfio_obj_t **)realloc(pdf->pages, (pdf->alloc_pages + 32) * sizeof(pdfio_obj_t *));\n\n      if (!temp)\n      {\n        _pdfioFileError(pdf, \"Unable to allocate memory for pages.\");\n        return (false);\n      }\n\n      pdf->alloc_pages += 32;\n      pdf->pages       = temp;\n    }\n\n    pdf->pages[pdf->num_pages ++] = obj;\n  }\n\n  return (true);\n}\n\n\n//\n// 'load_xref()' - Load an XREF table...\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nload_xref(\n    pdfio_file_t        *pdf,\t\t// I - PDF file\n    off_t               xref_offset,\t// I - Offset to xref\n    pdfio_password_cb_t password_cb,\t// I - Password callback or `NULL` for none\n    void                *password_data)\t// I - Password callback data, if any\n{\n  bool\t\tdone = false;\t\t// Are we done?\n  char\t\tline[1024],\t\t// Line from file\n\t\t*ptr;\t\t\t// Pointer into line\n  _pdfio_value_t trailer;\t\t// Trailer dictionary\n  intmax_t\tnumber,\t\t\t// Object number\n\t\tnum_objects,\t\t// Number of objects\n\t\toffset;\t\t\t// Offset in file\n  int\t\tgeneration;\t\t// Generation number\n  _pdfio_token_t tb;\t\t\t// Token buffer/stack\n  off_t\t\tline_offset;\t\t// Offset to start of line\n\n\n  while (!done)\n  {\n    if (_pdfioFileSeek(pdf, xref_offset, SEEK_SET) != xref_offset)\n    {\n      _pdfioFileError(pdf, \"Unable to seek to start of xref table.\");\n      return (false);\n    }\n\n    do\n    {\n      line_offset = _pdfioFileTell(pdf);\n\n      if (!_pdfioFileGets(pdf, line, sizeof(line)))\n      {\n\t_pdfioFileError(pdf, \"Unable to read start of xref table.\");\n\treturn (false);\n      }\n    }\n    while (!line[0]);\n\n    PDFIO_DEBUG(\"load_xref: line_offset=%lu, line='%s'\\n\", (unsigned long)line_offset, line);\n\n    if (isdigit(line[0] & 255) && strlen(line) > 4 && (!strcmp(line + strlen(line) - 4, \" obj\") || ((ptr = strstr(line, \" obj\")) != NULL && ptr[4] == '<')))\n    {\n      // Cross-reference stream\n      pdfio_obj_t\t*obj;\t\t// Object\n      size_t\t\ti;\t\t// Looping var\n      pdfio_array_t\t*index_array;\t// Index array\n      size_t\t\tindex_n,\t// Current element in array\n\t\t\tindex_count,\t// Number of values in index array\n\t\t\tcount;\t\t// Number of objects in current pairing\n      pdfio_array_t\t*w_array;\t// W array\n      size_t\t\tw[3];\t\t// Size of each cross-reference field\n      size_t\t\tw_2,\t\t// Offset to second field\n\t\t\tw_3;\t\t// Offset to third field\n      size_t\t\tw_total;\t// Total length\n      pdfio_stream_t\t*st;\t\t// Stream\n      unsigned char\tbuffer[32];\t// Read buffer\n      size_t\t\tnum_sobjs = 0,\t// Number of object streams\n\t\t\tsobjs[4096];\t// Object streams to load\n      pdfio_obj_t\t*current;\t// Current object\n\n      if ((number = strtoimax(line, &ptr, 10)) < 1)\n      {\n\t_pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n\treturn (false);\n      }\n\n      if ((generation = (int)strtol(ptr, &ptr, 10)) < 0 || generation > 65535)\n      {\n\t_pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n\treturn (false);\n      }\n\n      while (isspace(*ptr & 255))\n\tptr ++;\n\n      if (strncmp(ptr, \"obj\", 3))\n      {\n\t_pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n\treturn (false);\n      }\n\n      if (_pdfioFileSeek(pdf, line_offset + ptr + 3 - line, SEEK_SET) < 0)\n      {\n        _pdfioFileError(pdf, \"Unable to seek to xref object %lu %u.\", (unsigned long)number, (unsigned)generation);\n        return (false);\n      }\n\n      PDFIO_DEBUG(\"load_xref: Loading object %lu %u.\\n\", (unsigned long)number, (unsigned)generation);\n\n      if ((obj = add_obj(pdf, (size_t)number, (unsigned short)generation, xref_offset)) == NULL)\n      {\n        _pdfioFileError(pdf, \"Unable to allocate memory for object.\");\n        return (false);\n      }\n\n      _pdfioTokenInit(&tb, pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, pdf);\n\n      if (!_pdfioValueRead(pdf, obj, &tb, &trailer, 0))\n      {\n        _pdfioFileError(pdf, \"Unable to read cross-reference stream dictionary.\");\n        return (false);\n      }\n      else if (trailer.type != PDFIO_VALTYPE_DICT)\n      {\n\t_pdfioFileError(pdf, \"Cross-reference stream does not have a dictionary.\");\n\treturn (false);\n      }\n\n      obj->value = trailer;\n\n      if (!_pdfioTokenGet(&tb, line, sizeof(line)) || strcmp(line, \"stream\"))\n      {\n        _pdfioFileError(pdf, \"Unable to get stream after xref dictionary.\");\n        return (false);\n      }\n\n      _pdfioTokenFlush(&tb);\n\n      obj->stream_offset = _pdfioFileTell(pdf);\n\n      if ((index_array = pdfioDictGetArray(trailer.value.dict, \"Index\")) != NULL)\n        index_count = index_array->num_values;\n      else\n        index_count = 1;\n\n      if ((w_array = pdfioDictGetArray(trailer.value.dict, \"W\")) == NULL)\n      {\n\t_pdfioFileError(pdf, \"Cross-reference stream does not have required W key.\");\n\treturn (false);\n      }\n\n      w[0]    = (size_t)pdfioArrayGetNumber(w_array, 0);\n      w[1]    = (size_t)pdfioArrayGetNumber(w_array, 1);\n      w[2]    = (size_t)pdfioArrayGetNumber(w_array, 2);\n      w_total = w[0] + w[1] + w[2];\n      w_2     = w[0];\n      w_3     = w[0] + w[1];\n\n      if (w[1] == 0 || w[2] > 2 || w[0] > sizeof(buffer) || w[1] > sizeof(buffer) || w[2] > sizeof(buffer) || w_total > sizeof(buffer))\n      {\n\t_pdfioFileError(pdf, \"Cross-reference stream has invalid W key.\");\n\treturn (false);\n      }\n\n      if ((st = pdfioObjOpenStream(obj, true)) == NULL)\n      {\n\t_pdfioFileError(pdf, \"Unable to open cross-reference stream.\");\n\treturn (false);\n      }\n\n      for (index_n = 0; index_n < index_count; index_n += 2)\n      {\n        if (index_count == 1)\n        {\n          number = 0;\n          count  = 999999999;\n\t}\n\telse\n\t{\n          number = (intmax_t)pdfioArrayGetNumber(index_array, index_n);\n          count  = (size_t)pdfioArrayGetNumber(index_array, index_n + 1);\n\t}\n\n\twhile (count > 0 && pdfioStreamRead(st, buffer, w_total) > 0)\n\t{\n\t  count --;\n\n\t  PDFIO_DEBUG(\"load_xref: number=%u %02X%02X%02X%02X%02X\\n\", (unsigned)number, buffer[0], buffer[1], buffer[2], buffer[3], buffer[4]);\n\n\t  // Check whether this is an object definition...\n\t  if (w[0] > 0)\n\t  {\n\t    if (buffer[0] == 0)\n\t    {\n\t      // Ignore free objects...\n\t      number ++;\n\t      continue;\n\t    }\n\t  }\n\n\t  for (i = 1, offset = buffer[w_2]; i < w[1]; i ++)\n\t    offset = (offset << 8) | buffer[w_2 + i];\n\n\t  switch (w[2])\n\t  {\n\t    default :\n\t\tgeneration = 0;\n\t\tbreak;\n\t    case 1 :\n\t\tgeneration = buffer[w_3];\n\t\tbreak;\n\t    case 2 :\n\t\tgeneration = (buffer[w_3] << 8) | buffer[w_3 + 1];\n\t\tbreak;\n\t  }\n\n\t  // Create a placeholder for the object in memory...\n\t  if ((current = pdfioFileFindObj(pdf, (size_t)number)) != NULL)\n\t  {\n\t    PDFIO_DEBUG(\"load_xref: existing object, prev offset=%u\\n\", (unsigned)current->offset);\n\n            if (w[0] == 0 || buffer[0] == 1)\n            {\n              // Location of object...\n\t      current->offset = offset;\n\t    }\n\t    else if (number != offset)\n\t    {\n\t      // Object is part of a stream, offset is the object number...\n\t      current->offset = 0;\n\t    }\n\n\t    PDFIO_DEBUG(\"load_xref: new offset=%u\\n\", (unsigned)current->offset);\n\t  }\n\n\t  if (w[0] > 0 && buffer[0] == 2)\n\t  {\n\t    // Object streams need to be loaded into memory, so add them\n\t    // to the list of objects to load later as needed...\n\t    for (i = 0; i < num_sobjs; i ++)\n\t    {\n\t      if (sobjs[i] == (size_t)offset)\n\t\tbreak;\n\t    }\n\n\t    if (i >= num_sobjs && num_sobjs < (sizeof(sobjs) / sizeof(sobjs[0])))\n\t      sobjs[num_sobjs ++] = (size_t)offset;\n\t  }\n\t  else if (!current)\n\t  {\n\t    // Add this object...\n\t    if (!add_obj(pdf, (size_t)number, (unsigned short)generation, offset))\n\t      return (false);\n\t  }\n\n\t  number ++;\n\t}\n      }\n\n      pdfioStreamClose(st);\n\n      if (!pdf->trailer_dict)\n      {\n\t// Save the trailer dictionary and grab the root (catalog) and info\n\t// objects...\n\tpdf->trailer_dict = trailer.value.dict;\n\tpdf->info_obj     = pdfioDictGetObj(pdf->trailer_dict, \"Info\");\n\tpdf->encrypt_obj  = pdfioDictGetObj(pdf->trailer_dict, \"Encrypt\");\n\tpdf->id_array     = pdfioDictGetArray(pdf->trailer_dict, \"ID\");\n\n\t// If the trailer contains an Encrypt key, try unlocking the file...\n\tif (pdf->encrypt_obj && !_pdfioCryptoUnlock(pdf, password_cb, password_data))\n\t  return (false);\n      }\n\n      // Load any object streams that are left...\n      PDFIO_DEBUG(\"load_xref: %lu compressed object streams to load.\\n\", (unsigned long)num_sobjs);\n\n      for (i = 0; i < num_sobjs; i ++)\n      {\n        if ((obj = pdfioFileFindObj(pdf, sobjs[i])) != NULL)\n        {\n\t  PDFIO_DEBUG(\"load_xref: Loading compressed object stream %lu (pdf=%p, obj->pdf=%p).\\n\", (unsigned long)sobjs[i], pdf, obj->pdf);\n\n          if (!load_obj_stream(obj))\n            return (false);\n\t}\n\telse\n\t{\n\t  _pdfioFileError(pdf, \"Unable to find compressed object stream %lu.\", (unsigned long)sobjs[i]);\n\t  return (false);\n\t}\n      }\n    }\n    else if (!strcmp(line, \"xref\"))\n    {\n      // Read the xref tables\n      while (_pdfioFileGets(pdf, line, sizeof(line)))\n      {\n\tif (!strcmp(line, \"trailer\"))\n\t  break;\n\telse if (!line[0])\n\t  continue;\n\n\tif (sscanf(line, \"%jd%jd\", &number, &num_objects) != 2)\n\t{\n\t  _pdfioFileError(pdf, \"Malformed xref table section '%s'.\", line);\n\t  return (false);\n\t}\n\n\t// Read this group of objects...\n\tfor (; num_objects > 0; num_objects --, number ++)\n\t{\n\t  // Read a line from the file and validate it...\n\t  if (_pdfioFileRead(pdf, line, 20) != 20)\n\t    return (false);\n\n\t  line[20] = '\\0';\n\n\t  if (strcmp(line + 18, \"\\r\\n\") && strcmp(line + 18, \" \\n\") && strcmp(line + 18, \" \\r\"))\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\t  line[18] = '\\0';\n\n\t  // Parse the line\n\t  if ((offset = strtoimax(line, &ptr, 10)) < 0)\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  if ((generation = (int)strtol(ptr, &ptr, 10)) < 0 || generation > 65535)\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  if (*ptr != ' ')\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  ptr ++;\n\t  if (*ptr != 'f' && *ptr != 'n')\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  if (*ptr == 'f')\n\t    continue;\t\t\t// Don't care about free objects...\n\n\t  // Create a placeholder for the object in memory...\n\t  if (pdfioFileFindObj(pdf, (size_t)number))\n\t    continue;\t\t\t// Don't replace newer object...\n\n\t  if (!add_obj(pdf, (size_t)number, (unsigned short)generation, offset))\n\t    return (false);\n\t}\n      }\n\n      if (strcmp(line, \"trailer\"))\n      {\n\t_pdfioFileError(pdf, \"Missing trailer.\");\n\treturn (false);\n      }\n\n      _pdfioTokenInit(&tb, pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, pdf);\n\n      if (!_pdfioValueRead(pdf, NULL, &tb, &trailer, 0))\n      {\n\t_pdfioFileError(pdf, \"Unable to read trailer dictionary.\");\n\treturn (false);\n      }\n      else if (trailer.type != PDFIO_VALTYPE_DICT)\n      {\n\t_pdfioFileError(pdf, \"Trailer is not a dictionary.\");\n\treturn (false);\n      }\n\n      PDFIO_DEBUG(\"load_xref: Got trailer dict.\\n\");\n\n      _pdfioTokenFlush(&tb);\n\n      if (!pdf->trailer_dict)\n      {\n\t// Save the trailer dictionary and grab the root (catalog) and info\n\t// objects...\n\tpdf->trailer_dict = trailer.value.dict;\n\tpdf->info_obj     = pdfioDictGetObj(pdf->trailer_dict, \"Info\");\n\tpdf->encrypt_obj  = pdfioDictGetObj(pdf->trailer_dict, \"Encrypt\");\n\tpdf->id_array     = pdfioDictGetArray(pdf->trailer_dict, \"ID\");\n\n\t// If the trailer contains an Encrypt key, try unlocking the file...\n\tif (pdf->encrypt_obj && !_pdfioCryptoUnlock(pdf, password_cb, password_data))\n\t  return (false);\n      }\n    }\n    else\n    {\n      _pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n      return (false);\n    }\n\n    PDFIO_DEBUG(\"load_xref: Contents of trailer dictionary:\\n\");\n    PDFIO_DEBUG(\"load_xref: \");\n    PDFIO_DEBUG_VALUE(&trailer);\n    PDFIO_DEBUG(\"\\n\");\n\n    if ((xref_offset = (off_t)pdfioDictGetNumber(trailer.value.dict, \"Prev\")) <= 0)\n      done = true;\n  }\n\n  // Once we have all of the xref tables loaded, get the important objects and\n  // build the pages array...\n  if ((pdf->root_obj = pdfioDictGetObj(pdf->trailer_dict, \"Root\")) == NULL)\n  {\n    _pdfioFileError(pdf, \"Missing Root object.\");\n    return (false);\n  }\n\n  PDFIO_DEBUG(\"load_xref: Root=%p(%lu)\\n\", pdf->root_obj, (unsigned long)pdf->root_obj->number);\n\n  return (load_pages(pdf, pdfioDictGetObj(pdfioObjGetDict(pdf->root_obj), \"Pages\"), 0));\n}\n\n\n//\n// 'write_catalog()' - Write the PDF root object/catalog.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nwrite_catalog(pdfio_file_t *pdf)\t// I - PDF file\n{\n  pdfio_dict_t\t*dict;\t\t\t// Dictionary for catalog...\n\n\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    return (false);\n\n  pdfioDictSetName(dict, \"Type\", \"Catalog\");\n  pdfioDictSetObj(dict, \"Pages\", pdf->pages_obj);\n  // TODO: Add support for all of the root object dictionary keys\n\n  if ((pdf->root_obj = pdfioFileCreateObj(pdf, dict)) == NULL)\n    return (false);\n  else\n    return (pdfioObjClose(pdf->root_obj));\n}\n\n\n//\n// 'write_pages()' - Write the PDF pages objects.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nwrite_pages(pdfio_file_t *pdf)\t\t// I - PDF file\n{\n  pdfio_array_t\t*kids;\t\t\t// Pages array\n  size_t\ti;\t\t\t// Looping var\n\n\n  // Build the \"Kids\" array pointing to each page...\n  if ((kids = pdfioArrayCreate(pdf)) == NULL)\n    return (false);\n\n  for (i = 0; i < pdf->num_pages; i ++)\n    pdfioArrayAppendObj(kids, pdf->pages[i]);\n\n  pdfioDictSetNumber(pdf->pages_obj->value.value.dict, \"Count\", pdf->num_pages);\n  pdfioDictSetArray(pdf->pages_obj->value.value.dict, \"Kids\", kids);\n\n  // Write the Pages object...\n  return (pdfioObjClose(pdf->pages_obj));\n}\n\n\n//\n// 'write_trailer()' - Write the PDF catalog object, xref table, and trailer.\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nwrite_trailer(pdfio_file_t *pdf)\t// I - PDF file\n{\n  bool\t\tret = true;\t\t// Return value\n  off_t\t\txref_offset;\t\t// Offset to xref table\n  size_t\ti;\t\t\t// Looping var\n\n\n  // Write the xref table...\n  // TODO: Look at adding support for xref streams...\n  xref_offset = _pdfioFileTell(pdf);\n\n  if (!_pdfioFilePrintf(pdf, \"xref\\n0 %lu \\n0000000000 65535 f \\n\", (unsigned long)pdf->num_objs + 1))\n  {\n    _pdfioFileError(pdf, \"Unable to write cross-reference table.\");\n    ret = false;\n    goto done;\n  }\n\n  for (i = 0; i < pdf->num_objs; i ++)\n  {\n    pdfio_obj_t\t*obj = pdf->objs[i];\t// Current object\n\n    if (!_pdfioFilePrintf(pdf, \"%010lu %05u n \\n\", (unsigned long)obj->offset, obj->generation))\n    {\n      _pdfioFileError(pdf, \"Unable to write cross-reference table.\");\n      ret = false;\n      goto done;\n    }\n  }\n\n  // Write the trailer...\n  if (!_pdfioFilePuts(pdf, \"trailer\\n\"))\n  {\n    _pdfioFileError(pdf, \"Unable to write trailer.\");\n    ret = false;\n    goto done;\n  }\n\n  if ((pdf->trailer_dict = pdfioDictCreate(pdf)) == NULL)\n  {\n    _pdfioFileError(pdf, \"Unable to create trailer.\");\n    ret = false;\n    goto done;\n  }\n\n  if (pdf->encrypt_obj)\n    pdfioDictSetObj(pdf->trailer_dict, \"Encrypt\", pdf->encrypt_obj);\n  if (pdf->id_array)\n    pdfioDictSetArray(pdf->trailer_dict, \"ID\", pdf->id_array);\n  pdfioDictSetObj(pdf->trailer_dict, \"Info\", pdf->info_obj);\n  pdfioDictSetObj(pdf->trailer_dict, \"Root\", pdf->root_obj);\n  pdfioDictSetNumber(pdf->trailer_dict, \"Size\", pdf->num_objs + 1);\n\n  if (!_pdfioDictWrite(pdf->trailer_dict, NULL, NULL))\n  {\n    _pdfioFileError(pdf, \"Unable to write trailer.\");\n    ret = false;\n    goto done;\n  }\n\n  if (!_pdfioFilePrintf(pdf, \"\\nstartxref\\n%lu\\n%%EOF\\n\", (unsigned long)xref_offset))\n  {\n    _pdfioFileError(pdf, \"Unable to write xref offset.\");\n    ret = false;\n  }\n\n  done:\n\n  return (ret);\n}\n", "//\n// PDF object functions for PDFio.\n//\n// Copyright \u00a9\u00a02021-2023 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n\n\n//\n// Local functions...\n//\n\nstatic bool\twrite_obj_header(pdfio_obj_t *obj);\n\n\n//\n// 'pdfioObjClose()' - Close an object, writing any data as needed to the PDF\n//                     file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\npdfioObjClose(pdfio_obj_t *obj)\t\t// I - Object\n{\n  // Range check input\n  if (!obj)\n    return (false);\n\n  // Clear the current object pointer...\n  obj->pdf->current_obj = NULL;\n\n  if (obj->pdf->mode != _PDFIO_MODE_WRITE)\n  {\n    // Nothing to do when reading\n    return (true);\n  }\n\n  // Write what remains for the object...\n  if (!obj->offset)\n  {\n    // Write the object value\n    if (!write_obj_header(obj))\n      return (false);\n\n    // Write the \"endobj\" line...\n    return (_pdfioFilePuts(obj->pdf, \"endobj\\n\"));\n  }\n  else if (obj->stream)\n  {\n    // Close the stream...\n    return (pdfioStreamClose(obj->stream));\n  }\n  else\n  {\n    // Already closed\n    return (true);\n  }\n}\n\n\n//\n// 'pdfioObjCopy()' - Copy an object to another PDF file.\n//\n\npdfio_obj_t *\t\t\t\t// O - New object or `NULL` on error\npdfioObjCopy(pdfio_file_t *pdf,\t\t// I - PDF file\n             pdfio_obj_t  *srcobj)\t// I - Object to copy\n{\n  pdfio_obj_t\t*dstobj;\t\t// Destination object\n  pdfio_stream_t *srcst,\t\t// Source stream\n\t\t*dstst;\t\t\t// Destination stream\n  char\t\tbuffer[32768];\t\t// Copy buffer\n  ssize_t\tbytes;\t\t\t// Bytes read\n\n\n  PDFIO_DEBUG(\"pdfioObjCopy(pdf=%p, srcobj=%p(%p))\\n\", pdf, srcobj, srcobj ? srcobj->pdf : NULL);\n\n  // Range check input\n  if (!pdf || !srcobj)\n    return (NULL);\n\n  // Load the object value if needed...\n  if (srcobj->value.type == PDFIO_VALTYPE_NONE)\n    _pdfioObjLoad(srcobj);\n\n  // Create the new object...\n  if ((dstobj = _pdfioFileCreateObj(pdf, srcobj->pdf, NULL)) == NULL)\n    return (NULL);\n\n  // Add new object to the cache of copied objects...\n  if (!_pdfioFileAddMappedObj(pdf, dstobj, srcobj))\n    return (NULL);\n\n  // Copy the object's value...\n  if (!_pdfioValueCopy(pdf, &dstobj->value, srcobj->pdf, &srcobj->value))\n    return (NULL);\n\n  if (dstobj->value.type == PDFIO_VALTYPE_DICT)\n    _pdfioDictClear(dstobj->value.value.dict, \"Length\");\n\n  if (srcobj->stream_offset)\n  {\n    // Copy stream data...\n    if ((srcst = pdfioObjOpenStream(srcobj, false)) == NULL)\n    {\n      pdfioObjClose(dstobj);\n      return (NULL);\n    }\n\n    if ((dstst = pdfioObjCreateStream(dstobj, PDFIO_FILTER_NONE)) == NULL)\n    {\n      pdfioStreamClose(srcst);\n      pdfioObjClose(dstobj);\n      return (NULL);\n    }\n\n    while ((bytes = pdfioStreamRead(srcst, buffer, sizeof(buffer))) > 0)\n    {\n      if (!pdfioStreamWrite(dstst, buffer, (size_t)bytes))\n      {\n        bytes = -1;\n        break;\n      }\n    }\n\n    pdfioStreamClose(srcst);\n    pdfioStreamClose(dstst);\n\n    if (bytes < 0)\n      return (NULL);\n  }\n  else\n    pdfioObjClose(dstobj);\n\n  return (dstobj);\n}\n\n\n//\n// 'pdfioObjCreateStream()' - Create an object (data) stream for writing.\n//\n\npdfio_stream_t *\t\t\t// O - Stream or `NULL` on error\npdfioObjCreateStream(\n    pdfio_obj_t    *obj,\t\t// I - Object\n    pdfio_filter_t filter)\t\t// I - Type of compression to apply\n{\n  pdfio_obj_t\t*length_obj = NULL;\t// Length object, if any\n\n\n  // Range check input\n  if (!obj || obj->pdf->mode != _PDFIO_MODE_WRITE || obj->value.type != PDFIO_VALTYPE_DICT)\n    return (NULL);\n\n  if (obj->offset)\n  {\n    _pdfioFileError(obj->pdf, \"Object has already been written.\");\n    return (NULL);\n  }\n\n  if (filter != PDFIO_FILTER_NONE && filter != PDFIO_FILTER_FLATE)\n  {\n    _pdfioFileError(obj->pdf, \"Unsupported filter value for PDFioObjCreateStream.\");\n    return (NULL);\n  }\n\n  if (obj->pdf->current_obj)\n  {\n    _pdfioFileError(obj->pdf, \"Another object (%u) is already open.\", (unsigned)obj->pdf->current_obj->number);\n    return (NULL);\n  }\n\n  // Write the header...\n  if (!_pdfioDictGetValue(obj->value.value.dict, \"Length\"))\n  {\n    if (obj->pdf->output_cb)\n    {\n      // Streaming via an output callback, so add a placeholder length object\n      _pdfio_value_t\tlength_value;\t// Length value\n\n      length_value.type         = PDFIO_VALTYPE_NUMBER;\n      length_value.value.number = 0.0f;\n\n      length_obj = _pdfioFileCreateObj(obj->pdf, obj->pdf, &length_value);\n      pdfioDictSetObj(obj->value.value.dict, \"Length\", length_obj);\n    }\n    else\n    {\n      // Need a Length key for the stream, add a placeholder that we can fill in\n      // later...\n      pdfioDictSetNumber(obj->value.value.dict, \"Length\", 0.0);\n    }\n  }\n\n  if (!write_obj_header(obj))\n    return (NULL);\n\n  if (!_pdfioFilePuts(obj->pdf, \"stream\\n\"))\n    return (NULL);\n\n  obj->stream_offset    = _pdfioFileTell(obj->pdf);\n  obj->pdf->current_obj = obj;\n\n  // Return the new stream...\n  return (_pdfioStreamCreate(obj, length_obj, filter));\n}\n\n\n//\n// '_pdfioObjDelete()' - Free memory used by an object.\n//\n\nvoid\n_pdfioObjDelete(pdfio_obj_t *obj)\t// I - Object\n{\n  if (obj)\n    pdfioStreamClose(obj->stream);\n\n  free(obj);\n}\n\n\n//\n// 'pdfioObjGetArray()' - Get the array associated with an object.\n//\n\npdfio_array_t *\t\t\t\t// O - Array or `NULL` on error\npdfioObjGetArray(pdfio_obj_t *obj)\t// I - Object\n{\n  if (!obj)\n    return (NULL);\n\n  if (obj->value.type == PDFIO_VALTYPE_NONE)\n    _pdfioObjLoad(obj);\n\n  if (obj->value.type == PDFIO_VALTYPE_ARRAY)\n    return (obj->value.value.array);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioObjGetDict()' - Get the dictionary associated with an object.\n//\n\npdfio_dict_t *\t\t\t\t// O - Dictionary or `NULL` on error\npdfioObjGetDict(pdfio_obj_t *obj)\t// I - Object\n{\n  if (!obj)\n    return (NULL);\n\n  if (obj->value.type == PDFIO_VALTYPE_NONE)\n    _pdfioObjLoad(obj);\n\n  if (obj->value.type == PDFIO_VALTYPE_DICT)\n    return (obj->value.value.dict);\n  else\n    return (NULL);\n}\n\n\n//\n// 'pdfioObjGetGeneration()' - Get the object's generation number.\n//\n\nunsigned short\t\t\t\t// O - Generation number (0 to 65535)\npdfioObjGetGeneration(pdfio_obj_t *obj)\t// I - Object\n{\n  return (obj ? obj->generation : 0);\n}\n\n\n//\n// 'pdfioObjGetLength()' - Get the length of the object's (data) stream.\n//\n\nsize_t\t\t\t\t\t// O - Length in bytes or `0` for none\npdfioObjGetLength(pdfio_obj_t *obj)\t// I - Object\n{\n  size_t\tlength;\t\t\t// Length of stream\n  pdfio_obj_t\t*lenobj;\t\t// Length object\n\n\n  // Range check input...\n  if (!obj || !obj->stream_offset || obj->value.type != PDFIO_VALTYPE_DICT)\n    return (0);\n\n  // Try getting the length, directly or indirectly\n  if ((length = (size_t)pdfioDictGetNumber(obj->value.value.dict, \"Length\")) > 0)\n  {\n    PDFIO_DEBUG(\"pdfioObjGetLength(obj=%p) returning %lu.\\n\", obj, (unsigned long)length);\n    return (length);\n  }\n\n  if ((lenobj = pdfioDictGetObj(obj->value.value.dict, \"Length\")) == NULL)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to get length of stream.\");\n    return (0);\n  }\n\n  if (lenobj->value.type == PDFIO_VALTYPE_NONE)\n    _pdfioObjLoad(lenobj);\n\n  if (lenobj->value.type != PDFIO_VALTYPE_NUMBER || lenobj->value.value.number <= 0.0)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to get length of stream.\");\n    return (0);\n  }\n\n  PDFIO_DEBUG(\"pdfioObjGetLength(obj=%p) returning %lu.\\n\", obj, (unsigned long)lenobj->value.value.number);\n\n  return ((size_t)lenobj->value.value.number);\n}\n\n\n//\n// 'pdfioObjGetNumber()' - Get the object's number.\n//\n\nsize_t\t\t\t\t\t// O - Object number (1 to 9999999999)\npdfioObjGetNumber(pdfio_obj_t *obj)\t// I - Object\n{\n  return (obj ? obj->number : 0);\n}\n\n\n//\n// 'pdfioObjGetSubtype()' - Get an object's subtype.\n//\n\nconst char *\t\t\t\t// O - Object subtype\npdfioObjGetSubtype(pdfio_obj_t *obj)\t// I - Object\n{\n  pdfio_dict_t\t*dict;\t\t\t// Object dictionary\n\n\n  if ((dict = pdfioObjGetDict(obj)) == NULL)\n    return (NULL);\n  else\n    return (pdfioDictGetName(dict, \"Subtype\"));\n}\n\n\n//\n// 'pdfioObjGetType()' - Get an object's type.\n//\n\nconst char *\t\t\t\t// O - Object type\npdfioObjGetType(pdfio_obj_t *obj)\t// I - Object\n{\n  pdfio_dict_t\t*dict;\t\t\t// Object dictionary\n\n\n  if ((dict = pdfioObjGetDict(obj)) == NULL)\n    return (NULL);\n  else\n    return (pdfioDictGetName(dict, \"Type\"));\n}\n\n\n//\n// '_pdfioObjLoad()' - Load an object dictionary/value.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` otherwise\n_pdfioObjLoad(pdfio_obj_t *obj)\t\t// I - Object\n{\n  char\t\t\tline[64],\t// Line from file\n\t\t\t*ptr;\t\t// Pointer into line\n  ssize_t\t\tbytes;\t\t// Bytes read\n  _pdfio_token_t\ttb;\t\t// Token buffer/stack\n\n\n  PDFIO_DEBUG(\"_pdfioObjLoad(obj=%p(%lu)), offset=%lu\\n\", obj, (unsigned long)obj->number, (unsigned long)obj->offset);\n\n  // Seek to the start of the object and read its header...\n  if (_pdfioFileSeek(obj->pdf, obj->offset, SEEK_SET) != obj->offset)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to seek to object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  if ((bytes = _pdfioFilePeek(obj->pdf, line, sizeof(line) - 1)) < 0)\n  {\n    _pdfioFileError(obj->pdf, \"Unable to read header for object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  line[bytes] = '\\0';\n\n  PDFIO_DEBUG(\"_pdfioObjLoad: Header is '%s'.\\n\", line);\n\n  if (strtoimax(line, &ptr, 10) != (intmax_t)obj->number)\n  {\n    _pdfioFileError(obj->pdf, \"Bad header for object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  if (strtol(ptr, &ptr, 10) != (long)obj->generation)\n  {\n    _pdfioFileError(obj->pdf, \"Bad header for object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  while (isspace(*ptr & 255))\n    ptr ++;\n\n  if (strncmp(ptr, \"obj\", 3) || (ptr[3] && ptr[3] != '<' && ptr[3] != '[' && !isspace(ptr[3] & 255)))\n  {\n    _pdfioFileError(obj->pdf, \"Bad header for object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  ptr += 3;\n  _pdfioFileConsume(obj->pdf, (size_t)(ptr - line));\n\n  // Then grab the object value...\n  _pdfioTokenInit(&tb, obj->pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, obj->pdf);\n\n  if (!_pdfioValueRead(obj->pdf, obj, &tb, &obj->value, 0))\n  {\n    _pdfioFileError(obj->pdf, \"Unable to read value for object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  // Now see if there is an associated stream...\n  if (!_pdfioTokenGet(&tb, line, sizeof(line)))\n  {\n    _pdfioFileError(obj->pdf, \"Early end-of-file for object %lu.\", (unsigned long)obj->number);\n    return (false);\n  }\n\n  _pdfioTokenFlush(&tb);\n\n  if (!strcmp(line, \"stream\"))\n  {\n    // Yes, save its location...\n    obj->stream_offset = _pdfioFileTell(obj->pdf);\n    PDFIO_DEBUG(\"_pdfioObjLoad: stream_offset=%lu.\\n\", (unsigned long)obj->stream_offset);\n  }\n\n  PDFIO_DEBUG(\"_pdfioObjLoad: \");\n  PDFIO_DEBUG_VALUE(&obj->value);\n  PDFIO_DEBUG(\"\\n\");\n\n  return (true);\n}\n\n\n//\n// 'pdfioObjOpenStream()' - Open an object's (data) stream for reading.\n//\n\npdfio_stream_t *\t\t\t// O - Stream or `NULL` on error\npdfioObjOpenStream(pdfio_obj_t *obj,\t// I - Object\n                   bool        decode)\t// I - Decode/decompress data?\n{\n  // Range check input...\n  if (!obj)\n    return (NULL);\n\n  if (obj->pdf->current_obj)\n  {\n    _pdfioFileError(obj->pdf, \"Another object (%u) is already open.\", (unsigned)obj->pdf->current_obj->number);\n    return (NULL);\n  }\n\n  // Make sure we've loaded the object dictionary...\n  if (!obj->value.type)\n  {\n    if (!_pdfioObjLoad(obj))\n      return (NULL);\n  }\n\n  // No stream if there is no dict or offset to a stream...\n  if (obj->value.type != PDFIO_VALTYPE_DICT || !obj->stream_offset)\n    return (NULL);\n\n  // Open the stream...\n  obj->pdf->current_obj = obj;\n\n  return (_pdfioStreamOpen(obj, decode));\n}\n\n\n//\n// 'write_obj_header()' - Write the object header...\n//\n\nstatic bool\t\t\t\t// O - `true` on success, `false` on failure\nwrite_obj_header(pdfio_obj_t *obj)\t// I - Object\n{\n  obj->offset = _pdfioFileTell(obj->pdf);\n\n  if (!_pdfioFilePrintf(obj->pdf, \"%lu %u obj\\n\", (unsigned long)obj->number, obj->generation))\n    return (false);\n\n  if (!_pdfioValueWrite(obj->pdf, obj, &obj->value, &obj->length_offset))\n    return (false);\n\n  return (_pdfioFilePuts(obj->pdf, \"\\n\"));\n}\n", "//\n// PDF token parsing functions for PDFio.\n//\n// Copyright \u00a9\u00a02021-2023 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n\n\n//\n// This file parses PDF language syntax:\n//\n// << dict >>                \"<<\" and \">>\" delimit a dictionary\n// (string)                  \"(\" and \")\" delimit a string\n// [array]                   \"[\" and \"]\" delimit an array\n// <hex-string>              \"<\" and \">\" delimit a hex string\n// {...}                     \"{\" and \"}\" are reserved as future delimiters\n// /name                     \"/\" starts a name with any special characters\n//                           quoted as \"#HH\" where HH is the byte value in hex.\n// %comment                  \"%\" starts a comment to the end of a line\n// keyword                   A keyword consists of other unreserved characters\n// [-+]?[0-9]*(.[0-9]*)?     A number optionally starts with \"+\" or \"-\".\n//\n// Newlines are CR, LF, or CR LF.\n//\n// Strings and names are returned with the leading delimiter (\"(string\",\n// \"<hex-string\", \"/name\") and all escaping/whitespace removal resolved.\n// Other delimiters, keywords, and numbers are returned as-is.\n//\n\n\n//\n// Constants...\n//\n\n#define PDFIO_NUMBER_CHARS\t\"0123456789-+.\"\n#define PDFIO_DELIM_CHARS\t\"<>(){}[]/%\"\n\n\n//\n// Local functions...\n//\n\nstatic int\tget_char(_pdfio_token_t *tb);\n\n\n//\n// '_pdfioTokenClear()' - Clear the token stack.\n//\n\nvoid\n_pdfioTokenClear(_pdfio_token_t *tb)\t// I - Token buffer/stack\n{\n  PDFIO_DEBUG(\"_pdfioTokenClear(tb=%p)\\n\", tb);\n\n  while (tb->num_tokens > 0)\n  {\n    tb->num_tokens --;\n    free(tb->tokens[tb->num_tokens]);\n    tb->tokens[tb->num_tokens] = NULL;\n  }\n}\n\n\n//\n// '_pdfioTokenFlush()' - Flush (consume) any bytes that have been used.\n//\n\nvoid\n_pdfioTokenFlush(_pdfio_token_t *tb)\t// I - Token buffer/stack\n{\n  if (tb->bufptr > tb->buffer)\n  {\n    size_t remaining = (size_t)(tb->bufend - tb->bufptr);\n\t\t\t\t\t// Remaining bytes in buffer\n\n    // Consume what we've used...\n    PDFIO_DEBUG(\"_pdfioTokenFlush: Consuming %d bytes.\\n\", (int)(tb->bufptr - tb->buffer));\n    (tb->consume_cb)(tb->cb_data, (size_t)(tb->bufptr - tb->buffer));\n\n    if (remaining > 0)\n    {\n      // Shuffle remaining bytes for next call...\n      memmove(tb->buffer, tb->bufptr, remaining);\n      tb->bufptr = tb->buffer;\n      tb->bufend = tb->buffer + remaining;\n\n#ifdef DEBUG\n      unsigned char *ptr;\t\t// Pointer into buffer\n\n      PDFIO_DEBUG(\"_pdfioTokenFlush: Remainder '\");\n      for (ptr = tb->buffer; ptr < tb->bufend; ptr ++)\n      {\n\tif (*ptr < ' ' || *ptr == 0x7f)\n\t  PDFIO_DEBUG(\"\\\\%03o\", *ptr);\n\telse\n\t  PDFIO_DEBUG(\"%c\", *ptr);\n      }\n      PDFIO_DEBUG(\"'\\n\");\n#endif // DEBUG\n    }\n    else\n    {\n      // Nothing left, reset pointers...\n      PDFIO_DEBUG(\"_pdfioTokenFlush: Resetting pointers.\\n\");\n      tb->bufptr = tb->bufend = tb->buffer;\n    }\n  }\n}\n\n\n//\n// '_pdfioTokenGet()' - Get a token.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioTokenGet(_pdfio_token_t *tb,\t// I - Token buffer/stack\n\t       char           *buffer,\t// I - String buffer\n\t       size_t         bufsize)\t// I - Size of string buffer\n{\n  // See if we have a token waiting on the stack...\n  if (tb->num_tokens > 0)\n  {\n    // Yes, return it...\n    size_t len;\t\t\t\t// Length of token\n\n    tb->num_tokens --;\n\n    if ((len = strlen(tb->tokens[tb->num_tokens])) > (bufsize - 1))\n    {\n      // Value too large...\n      PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Token '%s' from stack too large.\\n\", tb, buffer, (unsigned)bufsize, tb->tokens[tb->num_tokens]);\n      *buffer = '\\0';\n      return (false);\n    }\n\n    memcpy(buffer, tb->tokens[tb->num_tokens], len);\n    buffer[len] = '\\0';\n\n    PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\\n\", tb, buffer, (unsigned)bufsize, buffer);\n\n    free(tb->tokens[tb->num_tokens]);\n    tb->tokens[tb->num_tokens] = NULL;\n\n    return (true);\n  }\n\n  // No, read a new one...\n  return (_pdfioTokenRead(tb, buffer, bufsize));\n}\n\n\n//\n// '_pdfioTokenInit()' - Initialize a token buffer/stack.\n//\n\nvoid\n_pdfioTokenInit(\n    _pdfio_token_t       *ts,\t\t// I - Token buffer/stack\n    pdfio_file_t         *pdf,\t\t// I - PDF file\n    _pdfio_tconsume_cb_t consume_cb,\t// I - Consume callback\n    _pdfio_tpeek_cb_t    peek_cb,\t// I - Peek callback\n    void                 *cb_data)\t// I - Callback data\n{\n  // Zero everything out and then initialize key pointers...\n  memset(ts, 0, sizeof(_pdfio_token_t));\n\n  ts->pdf        = pdf;\n  ts->consume_cb = consume_cb;\n  ts->peek_cb    = peek_cb;\n  ts->cb_data    = cb_data;\n  ts->bufptr     = ts->buffer;\n  ts->bufend     = ts->buffer;\n}\n\n\n//\n// '_pdfioTokenPush()' - Push a token on the token stack.\n//\n\nvoid\n_pdfioTokenPush(_pdfio_token_t *tb,\t// I - Token buffer/stack\n\t\tconst char     *token)\t// I - Token to push\n{\n  if (tb->num_tokens < (sizeof(tb->tokens) / sizeof(tb->tokens[0])))\n  {\n    if ((tb->tokens[tb->num_tokens ++] = strdup(token)) == NULL)\n      tb->num_tokens --;\n  }\n}\n\n\n//\n// '_pdfioTokenRead()' - Read a token from a file/stream.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioTokenRead(_pdfio_token_t *tb,\t// I - Token buffer/stack\n\t\tchar           *buffer,\t// I - String buffer\n\t\tsize_t         bufsize)\t// I - Size of string buffer\n{\n  int\tch,\t\t\t\t// Character\n\tparens = 0;\t\t\t// Parenthesis level\n  char\t*bufptr,\t\t\t// Pointer into buffer\n\t*bufend,\t\t\t// End of buffer\n\tstate = '\\0';\t\t\t// Current state\n  bool\tsaw_nul = false;\t\t// Did we see a nul character?\n\n\n  //\n  // \"state\" is:\n  //\n  // - '\\0' for idle\n  // - '(' for literal string\n  // - '/' for name\n  // - '<' for possible hex string or dict\n  // - '>' for possible dict\n  // - '%' for comment\n  // - 'K' for keyword\n  // - 'N' for number\n\n  // Read the next token, skipping any leading whitespace...\n  bufptr = buffer;\n  bufend = buffer + bufsize - 1;\n\n  // Skip leading whitespace...\n  while ((ch = get_char(tb)) != EOF)\n  {\n    if (ch == '%')\n    {\n      // Skip comment\n      while ((ch = get_char(tb)) != EOF)\n      {\n\tif (ch == '\\n' || ch == '\\r')\n\t  break;\n      }\n    }\n    else if (!isspace(ch))\n      break;\n  }\n\n  if (ch == EOF)\n    return (false);\n\n  // Check for delimiters...\n  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)\n  {\n    *bufptr++ = state = (char)ch;\n  }\n  else if (strchr(PDFIO_NUMBER_CHARS, ch) != NULL)\n  {\n    // Number\n    state     = 'N';\n    *bufptr++ = (char)ch;\n  }\n  else\n  {\n    // Keyword\n    state     = 'K';\n    *bufptr++ = (char)ch;\n  }\n\n  switch (state)\n  {\n    case '(' : // Literal string\n\twhile ((ch = get_char(tb)) != EOF)\n\t{\n\t  if (ch == 0)\n\t    saw_nul = true;\n\n\t  if (ch == '\\\\')\n\t  {\n\t    // Quoted character...\n\t    int\ti;\t\t\t// Looping var\n\n\t    switch (ch = get_char(tb))\n\t    {\n\t      case '0' : // Octal character escape\n\t      case '1' :\n\t      case '2' :\n\t      case '3' :\n\t      case '4' :\n\t      case '5' :\n\t      case '6' :\n\t      case '7' :\n\t\t  for (ch -= '0', i = 0; i < 2; i ++)\n\t\t  {\n\t\t    int tch = get_char(tb);\t// Next char\n\n\t\t    if (tch >= '0' && tch <= '7')\n\t\t    {\n\t\t      ch = (char)((ch << 3) | (tch - '0'));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t      tb->bufptr --;\n\t\t      break;\n\t\t    }\n\t\t  }\n\t\t  break;\n\n\t      case '\\\\' :\n\t      case '(' :\n\t      case ')' :\n\t\t  break;\n\n\t      case 'n' :\n\t\t  ch = '\\n';\n\t\t  break;\n\n\t      case 'r' :\n\t\t  ch = '\\r';\n\t\t  break;\n\n\t      case 't' :\n\t\t  ch = '\\t';\n\t\t  break;\n\n\t      case 'b' :\n\t\t  ch = '\\b';\n\t\t  break;\n\n\t      case 'f' :\n\t\t  ch = '\\f';\n\t\t  break;\n\n\t      default :\n\t          // Ignore blackslash per PDF spec...\n\t          break;\n\t    }\n\t  }\n\t  else if (ch == '(')\n\t  {\n\t    // Keep track of parenthesis\n\t    parens ++;\n\t  }\n\t  else if (ch == ')')\n\t  {\n\t    if (parens == 0)\n\t      break;\n\n\t    parens --;\n\t  }\n\n\t  if (bufptr < bufend)\n\t  {\n\t    // Normal character...\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\n\tif (ch != ')')\n\t{\n\t  _pdfioFileError(tb->pdf, \"Unterminated string literal.\");\n\t  return (false);\n\t}\n\n\tif (saw_nul)\n\t{\n\t  // Convert to a hex (binary) string...\n\t  char\t*litptr,\t\t// Pointer to literal character\n\t\t*hexptr;\t\t// Pointer to hex character\n\t  size_t bytes = (size_t)(bufptr - buffer - 1);\n\t\t\t\t\t// Bytes of data...\n          static const char *hexchars = \"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n          PDFIO_DEBUG(\"_pdfioTokenRead: Converting nul-containing string to binary.\\n\");\n\n          if ((2 * (bytes + 1)) > bufsize)\n          {\n\t    // Out of space...\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n          }\n\n\t  *buffer = '<';\n\t  for (litptr = bufptr - 1, hexptr = buffer + 2 * bytes - 1; litptr > buffer; litptr --, hexptr -= 2)\n\t  {\n\t    int litch = *litptr;\t// Grab the character\n\n\t    hexptr[0] = hexchars[(litch >> 4) & 15];\n\t    hexptr[1] = hexchars[litch & 15];\n\t  }\n\t  bufptr = buffer + 2 * bytes + 1;\n\t}\n\tbreak;\n\n    case 'K' : // keyword\n\twhile ((ch = get_char(tb)) != EOF && !isspace(ch))\n\t{\n\t  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)\n\t  {\n\t    // End of keyword...\n\t    tb->bufptr --;\n\t    break;\n\t  }\n\t  else if (bufptr < bufend)\n\t  {\n\t    // Normal character...\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space...\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\tbreak;\n\n    case 'N' : // number\n\twhile ((ch = get_char(tb)) != EOF && !isspace(ch))\n\t{\n\t  if (!isdigit(ch) && ch != '.')\n\t  {\n\t    // End of number...\n\t    tb->bufptr --;\n\t    break;\n\t  }\n\t  else if (bufptr < bufend)\n\t  {\n\t    // Normal character...\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space...\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\tbreak;\n\n    case '/' : // \"/name\"\n\twhile ((ch = get_char(tb)) != EOF && !isspace(ch))\n\t{\n\t  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)\n\t  {\n\t    // End of keyword...\n\t    tb->bufptr --;\n\t    break;\n\t  }\n\t  else if (ch == '#')\n\t  {\n\t    // Quoted character (#xx) in name...\n\t    int\ti;\t\t\t// Looping var\n\n\t    for (i = 0, ch = 0; i < 2; i ++)\n\t    {\n\t      int tch = get_char(tb);\n\n\t      if (!isxdigit(tch & 255))\n\t      {\n\t\t_pdfioFileError(tb->pdf, \"Bad # escape in name.\");\n\t\treturn (false);\n\t      }\n\t      else if (isdigit(tch))\n\t\tch = ((ch & 255) << 4) | (tch - '0');\n\t      else\n\t\tch = ((ch & 255) << 4) | (tolower(tch) - 'a' + 10);\n\t    }\n\t  }\n\n\t  if (bufptr < bufend)\n\t  {\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\tbreak;\n\n    case '<' : // Potential hex string\n\tif ((ch = get_char(tb)) == '<')\n\t{\n\t  // Dictionary delimiter\n\t  *bufptr++ = (char)ch;\n\t  break;\n\t}\n\telse if (!isspace(ch & 255) && !isxdigit(ch & 255))\n\t{\n\t  _pdfioFileError(tb->pdf, \"Syntax error: '<%c'\", ch);\n\t  return (false);\n\t}\n\n        do\n\t{\n\t  if (isxdigit(ch))\n\t  {\n\t    if (bufptr < bufend)\n\t    {\n\t      // Hex digit\n\t      *bufptr++ = (char)ch;\n\t    }\n\t    else\n\t    {\n\t      // Too large\n\t      _pdfioFileError(tb->pdf, \"Token too large.\");\n\t      return (false);\n\t    }\n\t  }\n\t  else if (!isspace(ch))\n\t  {\n\t    _pdfioFileError(tb->pdf, \"Invalid hex string character '%c'.\", ch);\n\t    return (false);\n\t  }\n\t}\n\twhile ((ch = get_char(tb)) != EOF && ch != '>');\n\n\tif (ch == EOF)\n\t{\n\t  _pdfioFileError(tb->pdf, \"Unterminated hex string.\");\n\t  return (false);\n\t}\n\tbreak;\n\n    case '>' : // Dictionary\n\tif ((ch = get_char(tb)) == '>')\n\t{\n\t  *bufptr++ = '>';\n\t}\n\telse\n\t{\n\t  _pdfioFileError(tb->pdf, \"Syntax error: '>%c'.\", ch);\n\t  return (false);\n\t}\n\tbreak;\n  }\n\n  *bufptr = '\\0';\n\n//  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);\n\n  return (bufptr > buffer);\n}\n\n\n//\n// 'get_char()' - Get a character from the token buffer.\n//\n\nstatic int\t\t\t\t// O - Character or `EOF` on end-of-file\nget_char(_pdfio_token_t *tb)\t\t// I - Token buffer\n{\n  ssize_t\tbytes;\t\t\t// Bytes peeked\n\n\n  // Refill the buffer as needed...\n  if (tb->bufptr >= tb->bufend)\n  {\n    // Consume previous bytes...\n    if (tb->bufend > tb->buffer)\n    {\n      PDFIO_DEBUG(\"get_char: Consuming %d bytes.\\n\", (int)(tb->bufend - tb->buffer));\n      (tb->consume_cb)(tb->cb_data, (size_t)(tb->bufend - tb->buffer));\n    }\n\n    // Peek new bytes...\n    if ((bytes = (tb->peek_cb)(tb->cb_data, tb->buffer, sizeof(tb->buffer))) <= 0)\n    {\n      tb->bufptr = tb->bufend = tb->buffer;\n      return (EOF);\n    }\n\n    // Update pointers...\n    tb->bufptr = tb->buffer;\n    tb->bufend = tb->buffer + bytes;\n\n#if 0\n#ifdef DEBUG\n    unsigned char *ptr;\t\t\t// Pointer into buffer\n\n    PDFIO_DEBUG(\"get_char: Read '\");\n    for (ptr = tb->buffer; ptr < tb->bufend; ptr ++)\n    {\n      if (*ptr < ' ' || *ptr == 0x7f)\n        PDFIO_DEBUG(\"\\\\%03o\", *ptr);\n      else\n        PDFIO_DEBUG(\"%c\", *ptr);\n    }\n    PDFIO_DEBUG(\"'\\n\");\n#endif // DEBUG\n#endif // 0\n  }\n\n  // Return the next character...\n  return (*(tb->bufptr)++);\n}\n", "//\n// PDF value functions for PDFio.\n//\n// Copyright \u00a9\u00a02021-2023 by Michael R Sweet.\n//\n// Licensed under Apache License v2.0.  See the file \"LICENSE\" for more\n// information.\n//\n\n//\n// Include necessary headers...\n//\n\n#include \"pdfio-private.h\"\n\n\n//\n// '_pdfioValueCopy()' - Copy a value to a PDF file.\n//\n\n_pdfio_value_t\t*\n_pdfioValueCopy(pdfio_file_t   *pdfdst,\t// I - Destination PDF file\n                _pdfio_value_t *vdst,\t// I - Destination value\n                pdfio_file_t   *pdfsrc,\t// I - Source PDF file\n                _pdfio_value_t *vsrc)\t// I - Source value\n{\n  pdfio_obj_t\t*obj;\t\t\t// Object reference\n#ifdef DEBUG\n  static const char * const types[] =\t// Type strings for debug\n  {\n    \"PDFIO_VALTYPE_NONE\",\n    \"PDFIO_VALTYPE_ARRAY\",\n    \"PDFIO_VALTYPE_BINARY\",\n    \"PDFIO_VALTYPE_BOOLEAN\",\n    \"PDFIO_VALTYPE_DATE\",\n    \"PDFIO_VALTYPE_DICT\",\n    \"PDFIO_VALTYPE_INDIRECT\",\n    \"PDFIO_VALTYPE_NAME\",\n    \"PDFIO_VALTYPE_NULL\",\n    \"PDFIO_VALTYPE_NUMBER\",\n    \"PDFIO_VALTYPE_STRING\"\n  };\n#endif // DEBUG\n\n\n  PDFIO_DEBUG(\"_pdfioValueCopy(pdfdst=%p, vdst=%p, pdfsrc=%p, vsrc=%p(%s))\\n\", pdfdst, vdst, pdfsrc, vsrc, types[vsrc->type]);\n\n  if (pdfdst == pdfsrc && vsrc->type != PDFIO_VALTYPE_BINARY)\n  {\n    // For the same document we can copy the values without any other effort\n    // unless there is a binary (hex string) value...\n    *vdst = *vsrc;\n    return (vdst);\n  }\n\n  // Not the same document or a binary value, do a deep copy...\n  switch (vsrc->type)\n  {\n    case PDFIO_VALTYPE_INDIRECT :\n        if ((obj = _pdfioFileFindMappedObj(pdfdst, pdfsrc, vsrc->value.indirect.number)) == NULL)\n        {\n          obj = pdfioObjCopy(pdfdst, pdfioFileFindObj(pdfsrc, vsrc->value.indirect.number));\n\t}\n\n        if (!obj)\n          return (NULL);\n\n\tvdst->value.indirect.number     = obj->number;\n\tvdst->value.indirect.generation = obj->generation;\n\tbreak;\n\n    default :\n        return (NULL);\n\n    case PDFIO_VALTYPE_ARRAY :\n        vdst->value.array = pdfioArrayCopy(pdfdst, vsrc->value.array);\n        break;\n\n    case PDFIO_VALTYPE_BINARY :\n        if ((vdst->value.binary.data = (unsigned char *)malloc(vsrc->value.binary.datalen)) == NULL)\n        {\n          _pdfioFileError(pdfdst, \"Unable to allocate memory for a binary string - %s\", strerror(errno));\n          return (NULL);\n        }\n\n        vdst->value.binary.datalen = vsrc->value.binary.datalen;\n        memcpy(vdst->value.binary.data, vsrc->value.binary.data, vdst->value.binary.datalen);\n        break;\n\n    case PDFIO_VALTYPE_BOOLEAN :\n    case PDFIO_VALTYPE_DATE :\n    case PDFIO_VALTYPE_NUMBER :\n\t*vdst = *vsrc;\n        return (vdst);\n\n    case PDFIO_VALTYPE_DICT :\n        vdst->value.dict = pdfioDictCopy(pdfdst, vsrc->value.dict);\n        break;\n\n    case PDFIO_VALTYPE_NAME :\n    case PDFIO_VALTYPE_STRING :\n        vdst->value.name = pdfioStringCreate(pdfdst, vsrc->value.name);\n        break;\n  }\n\n  vdst->type = vsrc->type;\n\n  return (vdst);\n}\n\n\n//\n// '_pdfioValueDebug()' - Print the contents of a value.\n//\n\nvoid\n_pdfioValueDebug(_pdfio_value_t *v,\t// I - Value\n\t\t FILE           *fp)\t// I - Output file\n{\n  switch (v->type)\n  {\n    case PDFIO_VALTYPE_ARRAY :\n        _pdfioArrayDebug(v->value.array, fp);\n\tbreak;\n    case PDFIO_VALTYPE_BINARY :\n\t{\n\t  size_t\ti;\t\t// Looping var\n\t  unsigned char\t*ptr;\t\t// Pointer into data\n\n\t  putc('<', fp);\n\t  for (i = v->value.binary.datalen, ptr = v->value.binary.data; i > 0; i --, ptr ++)\n\t    fprintf(fp, \"%02X\", *ptr);\n\t  putc('>', fp);\n\t}\n\tbreak;\n    case PDFIO_VALTYPE_BOOLEAN :\n\tfputs(v->value.boolean ? \" true\" : \" false\", fp);\n\tbreak;\n    case PDFIO_VALTYPE_DATE :\n        {\n\t  struct tm\tdateval;\t// Date value\n\n#ifdef _WIN32\n          gmtime_s(&dateval, &v->value.date);\n#else\n          gmtime_r(&v->value.date, &dateval);\n#endif // _WIN32\n\n          fprintf(fp, \"(D:%04d%02d%02d%02d%02d%02dZ)\", dateval.tm_year + 1900, dateval.tm_mon + 1, dateval.tm_mday, dateval.tm_hour, dateval.tm_min, dateval.tm_sec);\n        }\n        break;\n    case PDFIO_VALTYPE_DICT :\n\tfputs(\"<<\", fp);\n\t_pdfioDictDebug(v->value.dict, fp);\n\tfputs(\">>\", fp);\n\tbreak;\n    case PDFIO_VALTYPE_INDIRECT :\n\tfprintf(fp, \" %lu %u R\", (unsigned long)v->value.indirect.number, v->value.indirect.generation);\n\tbreak;\n    case PDFIO_VALTYPE_NAME :\n\tfprintf(fp, \"/%s\", v->value.name);\n\tbreak;\n    case PDFIO_VALTYPE_NULL :\n\tfputs(\" null\", fp);\n\tbreak;\n    case PDFIO_VALTYPE_NUMBER :\n\tfprintf(fp, \" %g\", v->value.number);\n\tbreak;\n    case PDFIO_VALTYPE_STRING :\n\tfprintf(fp, \"(%s)\", v->value.string);\n\tbreak;\n\n    default :\n        break;\n  }\n}\n\n\n//\n// '_pdfioValueDelete()' - Free the memory used by a value.\n//\n\nvoid\n_pdfioValueDelete(_pdfio_value_t *v)\t// I - Value\n{\n  if (v->type == PDFIO_VALTYPE_BINARY)\n    free(v->value.binary.data);\n}\n\n\n//\n// '_pdfioValueRead()' - Read a value from a file.\n//\n\n_pdfio_value_t *\t\t\t// O - Value or `NULL` on error/EOF\n_pdfioValueRead(pdfio_file_t   *pdf,\t// I - PDF file\n                pdfio_obj_t    *obj,\t// I - Object, if any\n                _pdfio_token_t *tb,\t// I - Token buffer/stack\n                _pdfio_value_t *v,\t// I - Value\n                size_t         depth)\t// I - Depth of value\n{\n  char\t\ttoken[32768];\t\t// Token buffer\n#ifdef DEBUG\n  static const char * const valtypes[] =\n  {\n    \"<<none>>\",\t\t\t\t// No value, not set\n    \"array\",\t\t\t\t// Array\n    \"hex-string\",\t\t\t// Binary data\n    \"boolean\",\t\t\t\t// Boolean\n    \"date\",\t\t\t\t// Date/time\n    \"dict\",\t\t\t\t// Dictionary\n    \"indirect\",\t\t\t\t// Indirect object (N G obj)\n    \"name\",\t\t\t\t// Name\n    \"null\",\t\t\t\t// Null object\n    \"number\",\t\t\t\t// Number (integer or real)\n    \"string\"\t\t\t\t// String\n  };\n#endif // DEBUG\n\n\n  PDFIO_DEBUG(\"_pdfioValueRead(pdf=%p, obj=%p, v=%p)\\n\", pdf, obj, v);\n\n  if (!_pdfioTokenGet(tb, token, sizeof(token)))\n    return (NULL);\n\n  if (!strcmp(token, \"[\"))\n  {\n    // Start of array\n    if (depth >= PDFIO_MAX_DEPTH)\n    {\n      _pdfioFileError(pdf, \"Too many nested arrays.\");\n      return (NULL);\n    }\n\n    v->type = PDFIO_VALTYPE_ARRAY;\n    if ((v->value.array = _pdfioArrayRead(pdf, obj, tb, depth + 1)) == NULL)\n      return (NULL);\n  }\n  else if (!strcmp(token, \"<<\"))\n  {\n    // Start of dictionary\n    if (depth >= PDFIO_MAX_DEPTH)\n    {\n      _pdfioFileError(pdf, \"Too many nested dictionaries.\");\n      return (NULL);\n    }\n\n    v->type = PDFIO_VALTYPE_DICT;\n    if ((v->value.dict = _pdfioDictRead(pdf, obj, tb, depth + 1)) == NULL)\n      return (NULL);\n  }\n  else if (!strncmp(token, \"(D:\", 3))\n  {\n    // Possible date value of the form:\n    //\n    //   (D:YYYYMMDDhhmmssZ)\n    //   (D:YYYYMMDDhhmmss+HH'mm)\n    //   (D:YYYYMMDDhhmmss-HH'mm)\n    //\n    int\t\ti;\t\t\t// Looping var\n    struct tm\tdateval;\t\t// Date value\n    int\t\toffset;\t\t\t// Date offset\n\n    for (i = 3; i < 17; i ++)\n    {\n      if (!isdigit(token[i] & 255))\n        break;\n    }\n\n    if (i >= 17)\n    {\n      if (token[i] == 'Z')\n      {\n        i ++;\n      }\n      else if (token[i] == '-' || token[i] == '+')\n      {\n        if (isdigit(token[i + 1] & 255) && isdigit(token[i + 2] & 255) && token[i + 3] == '\\'' && isdigit(token[i + 4] & 255) && isdigit(token[i + 5] & 255))\n        {\n          i += 6;\n          if (token[i] == '\\'')\n            i ++;\n\t}\n      }\n    }\n\n    if (token[i])\n    {\n      // Just a string...\n      v->type         = PDFIO_VALTYPE_STRING;\n      v->value.string = pdfioStringCreate(pdf, token + 1);\n    }\n    else\n    {\n      // Date value...\n      memset(&dateval, 0, sizeof(dateval));\n\n      dateval.tm_year = (token[3] - '0') * 1000 + (token[4] - '0') * 100 + (token[5] - '0') * 10 + token[6] - '0' - 1900;\n      dateval.tm_mon  = (token[7] - '0') * 10 + token[8] - '0' - 1;\n      dateval.tm_mday = (token[9] - '0') * 10 + token[10] - '0';\n      dateval.tm_hour = (token[11] - '0') * 10 + token[12] - '0';\n      dateval.tm_min  = (token[13] - '0') * 10 + token[14] - '0';\n      dateval.tm_sec  = (token[15] - '0') * 10 + token[16] - '0';\n\n      if (token[17] == 'Z')\n      {\n        offset = 0;\n      }\n      else\n      {\n        offset = (token[18] - '0') * 600 + (token[19] - '0') * 60 + (token[20] - '0') * 10 + token[21] - '0';\n        if (token[17] == '-')\n          offset = -offset;\n      }\n\n      v->type       = PDFIO_VALTYPE_DATE;\n      v->value.date = mktime(&dateval) + offset;\n    }\n  }\n  else if (token[0] == '(')\n  {\n    // String\n    v->type         = PDFIO_VALTYPE_STRING;\n    v->value.string = pdfioStringCreate(pdf, token + 1);\n  }\n  else if (token[0] == '/')\n  {\n    // Name\n    v->type       = PDFIO_VALTYPE_NAME;\n    v->value.name = pdfioStringCreate(pdf, token + 1);\n  }\n  else if (token[0] == '<')\n  {\n    // Hex string\n    const char\t\t*tokptr;\t// Pointer into token\n    unsigned char\t*dataptr;\t// Pointer into data\n\n    v->type                 = PDFIO_VALTYPE_BINARY;\n    v->value.binary.datalen = strlen(token) / 2;\n    if ((v->value.binary.data = (unsigned char *)malloc(v->value.binary.datalen)) == NULL)\n    {\n      _pdfioFileError(pdf, \"Out of memory for hex string.\");\n      return (NULL);\n    }\n\n    // Convert hex to binary...\n    tokptr  = token + 1;\n    dataptr = v->value.binary.data;\n\n    while (*tokptr)\n    {\n      int\td;\t\t\t// Data value\n\n      if (isdigit(*tokptr))\n\td = (*tokptr++ - '0') << 4;\n      else\n\td = (tolower(*tokptr++) - 'a' + 10) << 4;\n\n      if (*tokptr)\n      {\n\t// PDF allows writers to drop a trailing 0...\n\tif (isdigit(*tokptr))\n\t  d |= *tokptr++ - '0';\n\telse\n\t  d |= tolower(*tokptr++) - 'a' + 10;\n      }\n\n      *dataptr++ = (unsigned char)d;\n    }\n\n    if (obj && pdf->encryption)\n    {\n      // Decrypt the string...\n      _pdfio_crypto_ctx_t ctx;\t\t// Decryption context\n      _pdfio_crypto_cb_t cb;\t\t// Decryption callback\n      size_t\tivlen;\t\t\t// Number of initialization vector bytes\n      uint8_t\ttemp[32768];\t\t// Temporary buffer for decryption\n      size_t\ttemplen;\t\t// Number of actual data bytes\n\n      if (v->value.binary.datalen > (sizeof(temp) - 32))\n      {\n\t_pdfioFileError(pdf, \"Unable to read encrypted binary string - too long.\");\n\treturn (false);\n      }\n\n      cb      = _pdfioCryptoMakeReader(pdf, obj, &ctx, v->value.binary.data, &ivlen);\n      templen = (cb)(&ctx, temp, v->value.binary.data + ivlen, v->value.binary.datalen - ivlen);\n\n      // Copy the decrypted string back to the value and adjust the length...\n      memcpy(v->value.binary.data, temp, templen);\n\n      if (pdf->encryption >= PDFIO_ENCRYPTION_AES_128)\n        v->value.binary.datalen = templen - temp[templen - 1];\n      else\n\tv->value.binary.datalen = templen;\n    }\n  }\n  else if (strchr(\"0123456789-+.\", token[0]) != NULL)\n  {\n    // Number or indirect object reference\n    if (isdigit(token[0]) && !strchr(token, '.'))\n    {\n      // Integer or object ref...\n      unsigned char *tempptr;\t\t// Pointer into buffer\n\n#ifdef DEBUG\n      PDFIO_DEBUG(\"_pdfioValueRead: %d bytes left in buffer: '\", (int)(tb->bufend - tb->bufptr));\n      for (tempptr = tb->bufptr; tempptr < tb->bufend; tempptr ++)\n      {\n\tif (*tempptr < ' ' || *tempptr == 0x7f)\n\t  PDFIO_DEBUG(\"\\\\%03o\", *tempptr);\n\telse\n\t  PDFIO_DEBUG(\"%c\", *tempptr);\n      }\n      PDFIO_DEBUG(\"'.\\n\");\n#endif // DEBUG\n\n      if ((tb->bufend - tb->bufptr) < 10)\n      {\n        // Fill up buffer...\n        ssize_t\tbytes;\t\t\t// Bytes peeked\n\n        _pdfioTokenFlush(tb);\n\n        if ((bytes = (tb->peek_cb)(tb->cb_data, tb->buffer, sizeof(tb->buffer))) > 0)\n\t  tb->bufend = tb->buffer + bytes;\n\n#ifdef DEBUG\n\tPDFIO_DEBUG(\"_pdfioValueRead: %d bytes now in buffer: '\", (int)(tb->bufend - tb->bufptr));\n\tfor (tempptr = tb->bufptr; tempptr < tb->bufend; tempptr ++)\n\t{\n\t  if (*tempptr < ' ' || *tempptr == 0x7f)\n\t    PDFIO_DEBUG(\"\\\\%03o\", *tempptr);\n\t  else\n\t    PDFIO_DEBUG(\"%c\", *tempptr);\n\t}\n\tPDFIO_DEBUG(\"'.\\n\");\n#endif // DEBUG\n      }\n\n      tempptr = tb->bufptr;\n\n      while (tempptr < tb->bufend && isspace(*tempptr & 255))\n        tempptr ++;\t\t\t// Skip whitespace as needed...\n\n      if (tempptr < tb->bufend && isdigit(*tempptr & 255))\n      {\n        // Integer...\n        long generation = 0;\t\t// Generation number\n\n        while (tempptr < tb->bufend && isdigit(*tempptr & 255))\n        {\n          generation = generation * 10 + *tempptr - '0';\n          tempptr ++;\n        }\n\n\twhile (tempptr < tb->bufend && isspace(*tempptr & 255))\n\t  tempptr ++;\t\t\t// Skip whitespace\n\n\tif (tempptr < tb->bufend && *tempptr == 'R')\n\t{\n\t  // Reference!\n\t  PDFIO_DEBUG(\"_pdfioValueRead: Consuming %d bytes.\\n\", (int)(tempptr - tb->bufptr + 1));\n\t  tb->bufptr = tempptr + 1;\n\n#ifdef DEBUG\n\t  PDFIO_DEBUG(\"_pdfioValueRead: Next bytes are '\");\n\t  for (tempptr = tb->bufptr; tempptr < tb->bufend; tempptr ++)\n\t  {\n\t    if (*tempptr < ' ' || *tempptr == 0x7f)\n\t      PDFIO_DEBUG(\"\\\\%03o\", *tempptr);\n\t    else\n\t      PDFIO_DEBUG(\"%c\", *tempptr);\n\t  }\n\t  PDFIO_DEBUG(\"'.\\n\");\n#endif // DEBUG\n\n\t  v->type                      = PDFIO_VALTYPE_INDIRECT;\n\t  v->value.indirect.number     = (size_t)strtoimax(token, NULL, 10);\n\t  v->value.indirect.generation = (unsigned short)generation;\n\n\t  PDFIO_DEBUG(\"_pdfioValueRead: Returning indirect value %lu %u R.\\n\", (unsigned long)v->value.indirect.number, v->value.indirect.generation);\n\n\t  return (v);\n\t}\n      }\n    }\n\n    // If we get here, we have a number...\n    v->type         = PDFIO_VALTYPE_NUMBER;\n    v->value.number = (double)strtod(token, NULL);\n  }\n  else if (!strcmp(token, \"true\") || !strcmp(token, \"false\"))\n  {\n    // Boolean value\n    v->type          = PDFIO_VALTYPE_BOOLEAN;\n    v->value.boolean = !strcmp(token, \"true\");\n  }\n  else if (!strcmp(token, \"null\"))\n  {\n    // null value\n    v->type = PDFIO_VALTYPE_NULL;\n  }\n  else\n  {\n    _pdfioFileError(pdf, \"Unexpected '%s' token seen.\", token);\n    return (NULL);\n  }\n\n  PDFIO_DEBUG(\"_pdfioValueRead: Returning %s value.\\n\", valtypes[v->type]);\n\n  return (v);\n}\n\n\n//\n// '_pdfioValueWrite()' - Write a value to a PDF file.\n//\n\nbool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioValueWrite(pdfio_file_t   *pdf,\t// I - PDF file\n                 pdfio_obj_t    *obj,\t// I - Object, if any\n                 _pdfio_value_t *v,\t// I - Value\n                 off_t          *length)// O - Offset to /Length value, if any\n{\n  switch (v->type)\n  {\n    default :\n        return (false);\n\n    case PDFIO_VALTYPE_ARRAY :\n        return (_pdfioArrayWrite(v->value.array, obj));\n\n    case PDFIO_VALTYPE_BINARY :\n        {\n          size_t\tdatabytes;\t// Bytes to write\n          uint8_t\ttemp[32768],\t// Temporary buffer for encryption\n\t\t\t*dataptr;\t// Pointer into data\n\n          if (obj && pdf->encryption)\n          {\n\t    // Write encrypted string...\n\t    _pdfio_crypto_ctx_t ctx;\t// Encryption context\n\t    _pdfio_crypto_cb_t cb;\t// Encryption callback\n\t    size_t\tivlen;\t\t// Number of initialization vector bytes\n\n            if (v->value.binary.datalen > (sizeof(temp) - 32))\n            {\n\t      _pdfioFileError(pdf, \"Unable to write encrypted binary string - too long.\");\n\t      return (false);\n            }\n\n\t    cb        = _pdfioCryptoMakeWriter(pdf, obj, &ctx, temp, &ivlen);\n\t    databytes = (cb)(&ctx, temp + ivlen, v->value.binary.data, v->value.binary.datalen) + ivlen;\n\t    dataptr   = temp;\n          }\n          else\n          {\n            dataptr   = v->value.binary.data;\n            databytes = v->value.binary.datalen;\n          }\n\n          if (!_pdfioFilePuts(pdf, \"<\"))\n            return (false);\n\n          for (; databytes > 1; databytes -= 2, dataptr += 2)\n          {\n            if (!_pdfioFilePrintf(pdf, \"%02X%02X\", dataptr[0], dataptr[1]))\n              return (false);\n          }\n\n          if (databytes > 0)\n            return (_pdfioFilePrintf(pdf, \"%02X>\", dataptr[0]));\n          else\n            return (_pdfioFilePuts(pdf, \">\"));\n        }\n\n    case PDFIO_VALTYPE_BOOLEAN :\n        if (v->value.boolean)\n          return (_pdfioFilePuts(pdf, \" true\"));\n        else\n          return (_pdfioFilePuts(pdf, \" false\"));\n\n    case PDFIO_VALTYPE_DATE :\n        {\n          struct tm\tdate;\t\t// Date values\n          char\t\tdatestr[32];\t// Formatted date value\n\n#ifdef _WIN32\n          gmtime_s(&date, &v->value.date);\n#else\n\t  gmtime_r(&v->value.date, &date);\n#endif // _WIN32\n\n\t  snprintf(datestr, sizeof(datestr), \"D:%04d%02d%02d%02d%02d%02dZ\", date.tm_year + 1900, date.tm_mon + 1, date.tm_mday, date.tm_hour, date.tm_min, date.tm_sec);\n\n\t  if (obj && pdf->encryption)\n\t  {\n\t    // Write encrypted string...\n\t    uint8_t\ttemp[32768],\t// Encrypted bytes\n\t\t\t*tempptr;\t// Pointer into encrypted bytes\n\t    _pdfio_crypto_ctx_t ctx;\t// Encryption context\n\t    _pdfio_crypto_cb_t cb;\t// Encryption callback\n\t    size_t\tlen = strlen(datestr),\n\t\t\t\t\t  // Length of value\n\t\t\tivlen,\t\t// Number of initialization vector bytes\n\t\t\ttempbytes;\t// Number of output bytes\n\n\t    cb        = _pdfioCryptoMakeWriter(pdf, obj, &ctx, temp, &ivlen);\n\t    tempbytes = (cb)(&ctx, temp + ivlen, (const uint8_t *)datestr, len) + ivlen;\n\n\t    if (!_pdfioFilePuts(pdf, \"<\"))\n\t      return (false);\n\n\t    for (tempptr = temp; tempbytes > 1; tempbytes -= 2, tempptr += 2)\n\t    {\n\t      if (!_pdfioFilePrintf(pdf, \"%02X%02X\", tempptr[0], tempptr[1]))\n\t\treturn (false);\n\t    }\n\n            if (tempbytes > 0)\n              return (_pdfioFilePrintf(pdf, \"%02X>\", *tempptr));\n            else\n\t      return (_pdfioFilePuts(pdf, \">\"));\n\t  }\n\t  else\n\t  {\n\t    return (_pdfioFilePrintf(pdf, \"(%s)\", datestr));\n\t  }\n        }\n\n    case PDFIO_VALTYPE_DICT :\n        return (_pdfioDictWrite(v->value.dict, obj, length));\n\n    case PDFIO_VALTYPE_INDIRECT :\n        return (_pdfioFilePrintf(pdf, \" %lu %u R\", (unsigned long)v->value.indirect.number, v->value.indirect.generation));\n\n    case PDFIO_VALTYPE_NAME :\n        return (_pdfioFilePrintf(pdf, \"/%s\", v->value.name));\n\n    case PDFIO_VALTYPE_NULL :\n        return (_pdfioFilePuts(pdf, \" null\"));\n\n    case PDFIO_VALTYPE_NUMBER :\n        return (_pdfioFilePrintf(pdf, \" %g\", v->value.number));\n\n    case PDFIO_VALTYPE_STRING :\n        if (obj && pdf->encryption)\n        {\n          // Write encrypted string...\n          uint8_t\ttemp[32768],\t// Encrypted bytes\n\t\t\t*tempptr;\t// Pointer into encrypted bytes\n          _pdfio_crypto_ctx_t ctx;\t// Encryption context\n          _pdfio_crypto_cb_t cb;\t// Encryption callback\n          size_t\tlen = strlen(v->value.string),\n\t\t\t\t\t// Length of value\n\t\t\tivlen,\t\t// Number of initialization vector bytes\n\t\t\ttempbytes;\t// Number of output bytes\n\n          if (len > (sizeof(temp) - 32))\n          {\n            _pdfioFileError(pdf, \"Unable to write encrypted string - too long.\");\n            return (false);\n          }\n\n          cb        = _pdfioCryptoMakeWriter(pdf, obj, &ctx, temp, &ivlen);\n          tempbytes = (cb)(&ctx, temp + ivlen, (const uint8_t *)v->value.string, len) + ivlen;\n\n          if (!_pdfioFilePuts(pdf, \"<\"))\n            return (false);\n\n          for (tempptr = temp; tempbytes > 1; tempbytes -= 2, tempptr += 2)\n          {\n            if (!_pdfioFilePrintf(pdf, \"%02X%02X\", tempptr[0], tempptr[1]))\n              return (false);\n          }\n\n          if (tempbytes > 0)\n            return (_pdfioFilePrintf(pdf, \"%02X>\", *tempptr));\n          else\n\t    return (_pdfioFilePuts(pdf, \">\"));\n        }\n        else\n        {\n          // Write unencrypted string...\n          const char *start,\t\t// Start of fragment\n\t\t     *end;\t\t// End of fragment\n\n          if (!_pdfioFilePuts(pdf, \"(\"))\n            return (false);\n\n          // Write a quoted string value...\n          for (start = v->value.string; *start; start = end)\n          {\n            // Find the next character that needs to be quoted...\n            for (end = start; *end; end ++)\n            {\n              if (*end == '\\\\' || *end == ')' || (*end & 255) < ' ')\n                break;\n            }\n\n            if (end > start)\n            {\n              // Write unquoted (safe) characters...\n\t      if (!_pdfioFileWrite(pdf, start, (size_t)(end - start)))\n\t\treturn (false);\n\t    }\n\n            if (*end)\n            {\n              // Quote this character...\n              bool success;\t\t// Did the write work?\n\n              if (*end == '\\\\' || *end == ')')\n                success = _pdfioFilePrintf(pdf, \"\\\\%c\", *end);\n              else\n                success = _pdfioFilePrintf(pdf, \"\\\\%03o\", *end);\n\n              if (!success)\n                return (false);\n\n              end ++;\n            }\n          }\n\n          return (_pdfioFilePuts(pdf, \")\"));\n        }\n  }\n\n  return (false);\n}\n"], "filenames": ["CHANGES.md", "Makefile", "NOTICE", "pdfio-common.c", "pdfio-dict.c", "pdfio-file.c", "pdfio-object.c", "pdfio-token.c", "pdfio-value.c"], "buggy_code_start_loc": [5, 4, 3, 4, 4, 4, 4, 4, 4], "buggy_code_end_loc": [7, 33, 4, 529, 938, 1986, 5, 588, 5], "fixing_code_start_loc": [5, 4, 3, 4, 4, 4, 4, 4, 4], "fixing_code_end_loc": [9, 33, 4, 531, 945, 1989, 5, 602, 5], "type": "CWE-835", "message": "PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-24808", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-07T01:15:09.567", "lastModified": "2023-02-14T23:39:50.847", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pdfio_project:pdfio:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.0", "matchCriteriaId": "FE34732E-6900-42B6-BC6E-0F5D047545E8"}]}]}], "references": [{"url": "https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/michaelrsweet/pdfio/security/advisories/GHSA-cjc4-x96x-fvgf", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb"}}