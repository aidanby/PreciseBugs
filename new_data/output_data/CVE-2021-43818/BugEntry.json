{"buggy_code": ["# cython: language_level=3str\n\n\"\"\"A cleanup tool for HTML.\n\nRemoves unwanted tags and content.  See the `Cleaner` class for\ndetails.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport copy\nimport re\nimport sys\ntry:\n    from urlparse import urlsplit\n    from urllib import unquote_plus\nexcept ImportError:\n    # Python 3\n    from urllib.parse import urlsplit, unquote_plus\nfrom lxml import etree\nfrom lxml.html import defs\nfrom lxml.html import fromstring, XHTML_NAMESPACE\nfrom lxml.html import xhtml_to_html, _transform_result\n\ntry:\n    unichr\nexcept NameError:\n    # Python 3\n    unichr = chr\ntry:\n    unicode\nexcept NameError:\n    # Python 3\n    unicode = str\ntry:\n    basestring\nexcept NameError:\n    basestring = (str, bytes)\n\n\n__all__ = ['clean_html', 'clean', 'Cleaner', 'autolink', 'autolink_html',\n           'word_break', 'word_break_html']\n\n# Look at http://code.sixapart.com/trac/livejournal/browser/trunk/cgi-bin/cleanhtml.pl\n#   Particularly the CSS cleaning; most of the tag cleaning is integrated now\n# I have multiple kinds of schemes searched; but should schemes be\n#   whitelisted instead?\n# max height?\n# remove images?  Also in CSS?  background attribute?\n# Some way to whitelist object, iframe, etc (e.g., if you want to\n#   allow *just* embedded YouTube movies)\n# Log what was deleted and why?\n# style=\"behavior: ...\" might be bad in IE?\n# Should we have something for just <meta http-equiv>?  That's the worst of the\n#   metas.\n# UTF-7 detections?  Example:\n#     <HEAD><META HTTP-EQUIV=\"CONTENT-TYPE\" CONTENT=\"text/html; charset=UTF-7\"> </HEAD>+ADw-SCRIPT+AD4-alert('XSS');+ADw-/SCRIPT+AD4-\n#   you don't always have to have the charset set, if the page has no charset\n#   and there's UTF7-like code in it.\n# Look at these tests: http://htmlpurifier.org/live/smoketests/xssAttacks.php\n\n\n# This is an IE-specific construct you can have in a stylesheet to\n# run some Javascript:\n_replace_css_javascript = re.compile(\n    r'expression\\s*\\(.*?\\)', re.S|re.I).sub\n\n# Do I have to worry about @\\nimport?\n_replace_css_import = re.compile(\n    r'@\\s*import', re.I).sub\n\n_looks_like_tag_content = re.compile(\n    r'</?[a-zA-Z]+|\\son[a-zA-Z]+\\s*=',\n    *((re.ASCII,) if sys.version_info[0] >= 3 else ())).search\n\n# All kinds of schemes besides just javascript: that can cause\n# execution:\n_is_image_dataurl = re.compile(\n    r'^data:image/.+;base64', re.I).search\n_is_possibly_malicious_scheme = re.compile(\n    r'(?:javascript|jscript|livescript|vbscript|data|about|mocha):',\n    re.I).search\ndef _is_javascript_scheme(s):\n    if _is_image_dataurl(s):\n        return None\n    return _is_possibly_malicious_scheme(s)\n\n_substitute_whitespace = re.compile(r'[\\s\\x00-\\x08\\x0B\\x0C\\x0E-\\x19]+').sub\n# FIXME: should data: be blocked?\n\n# FIXME: check against: http://msdn2.microsoft.com/en-us/library/ms537512.aspx\n_conditional_comment_re = re.compile(\n    r'\\[if[\\s\\n\\r]+.*?][\\s\\n\\r]*>', re.I|re.S)\n\n_find_styled_elements = etree.XPath(\n    \"descendant-or-self::*[@style]\")\n\n_find_external_links = etree.XPath(\n    (\"descendant-or-self::a  [normalize-space(@href) and substring(normalize-space(@href),1,1) != '#'] |\"\n     \"descendant-or-self::x:a[normalize-space(@href) and substring(normalize-space(@href),1,1) != '#']\"),\n    namespaces={'x':XHTML_NAMESPACE})\n\n\nclass Cleaner(object):\n    \"\"\"\n    Instances cleans the document of each of the possible offending\n    elements.  The cleaning is controlled by attributes; you can\n    override attributes in a subclass, or set them in the constructor.\n\n    ``scripts``:\n        Removes any ``<script>`` tags.\n\n    ``javascript``:\n        Removes any Javascript, like an ``onclick`` attribute. Also removes stylesheets\n        as they could contain Javascript.\n\n    ``comments``:\n        Removes any comments.\n\n    ``style``:\n        Removes any style tags.\n\n    ``inline_style``\n        Removes any style attributes.  Defaults to the value of the ``style`` option.\n\n    ``links``:\n        Removes any ``<link>`` tags\n\n    ``meta``:\n        Removes any ``<meta>`` tags\n\n    ``page_structure``:\n        Structural parts of a page: ``<head>``, ``<html>``, ``<title>``.\n\n    ``processing_instructions``:\n        Removes any processing instructions.\n\n    ``embedded``:\n        Removes any embedded objects (flash, iframes)\n\n    ``frames``:\n        Removes any frame-related tags\n\n    ``forms``:\n        Removes any form tags\n\n    ``annoying_tags``:\n        Tags that aren't *wrong*, but are annoying.  ``<blink>`` and ``<marquee>``\n\n    ``remove_tags``:\n        A list of tags to remove.  Only the tags will be removed,\n        their content will get pulled up into the parent tag.\n\n    ``kill_tags``:\n        A list of tags to kill.  Killing also removes the tag's content,\n        i.e. the whole subtree, not just the tag itself.\n\n    ``allow_tags``:\n        A list of tags to include (default include all).\n\n    ``remove_unknown_tags``:\n        Remove any tags that aren't standard parts of HTML.\n\n    ``safe_attrs_only``:\n        If true, only include 'safe' attributes (specifically the list\n        from the feedparser HTML sanitisation web site).\n\n    ``safe_attrs``:\n        A set of attribute names to override the default list of attributes\n        considered 'safe' (when safe_attrs_only=True).\n\n    ``add_nofollow``:\n        If true, then any <a> tags will have ``rel=\"nofollow\"`` added to them.\n\n    ``host_whitelist``:\n        A list or set of hosts that you can use for embedded content\n        (for content like ``<object>``, ``<link rel=\"stylesheet\">``, etc).\n        You can also implement/override the method\n        ``allow_embedded_url(el, url)`` or ``allow_element(el)`` to\n        implement more complex rules for what can be embedded.\n        Anything that passes this test will be shown, regardless of\n        the value of (for instance) ``embedded``.\n\n        Note that this parameter might not work as intended if you do not\n        make the links absolute before doing the cleaning.\n\n        Note that you may also need to set ``whitelist_tags``.\n\n    ``whitelist_tags``:\n        A set of tags that can be included with ``host_whitelist``.\n        The default is ``iframe`` and ``embed``; you may wish to\n        include other tags like ``script``, or you may want to\n        implement ``allow_embedded_url`` for more control.  Set to None to\n        include all tags.\n\n    This modifies the document *in place*.\n    \"\"\"\n\n    scripts = True\n    javascript = True\n    comments = True\n    style = False\n    inline_style = None\n    links = True\n    meta = True\n    page_structure = True\n    processing_instructions = True\n    embedded = True\n    frames = True\n    forms = True\n    annoying_tags = True\n    remove_tags = None\n    allow_tags = None\n    kill_tags = None\n    remove_unknown_tags = True\n    safe_attrs_only = True\n    safe_attrs = defs.safe_attrs\n    add_nofollow = False\n    host_whitelist = ()\n    whitelist_tags = {'iframe', 'embed'}\n\n    def __init__(self, **kw):\n        not_an_attribute = object()\n        for name, value in kw.items():\n            default = getattr(self, name, not_an_attribute)\n            if (default is not None and default is not True and default is not False\n                    and not isinstance(default, (frozenset, set, tuple, list))):\n                raise TypeError(\n                    \"Unknown parameter: %s=%r\" % (name, value))\n            setattr(self, name, value)\n        if self.inline_style is None and 'inline_style' not in kw:\n            self.inline_style = self.style\n\n        if kw.get(\"allow_tags\"):\n            if kw.get(\"remove_unknown_tags\"):\n                raise ValueError(\"It does not make sense to pass in both \"\n                                 \"allow_tags and remove_unknown_tags\")\n            self.remove_unknown_tags = False\n\n    # Used to lookup the primary URL for a given tag that is up for\n    # removal:\n    _tag_link_attrs = dict(\n        script='src',\n        link='href',\n        # From: http://java.sun.com/j2se/1.4.2/docs/guide/misc/applet.html\n        # From what I can tell, both attributes can contain a link:\n        applet=['code', 'object'],\n        iframe='src',\n        embed='src',\n        layer='src',\n        # FIXME: there doesn't really seem like a general way to figure out what\n        # links an <object> tag uses; links often go in <param> tags with values\n        # that we don't really know.  You'd have to have knowledge about specific\n        # kinds of plugins (probably keyed off classid), and match against those.\n        ##object=?,\n        # FIXME: not looking at the action currently, because it is more complex\n        # than than -- if you keep the form, you should keep the form controls.\n        ##form='action',\n        a='href',\n        )\n\n    def __call__(self, doc):\n        \"\"\"\n        Cleans the document.\n        \"\"\"\n        try:\n            getroot = doc.getroot\n        except AttributeError:\n            pass  # Element instance\n        else:\n            doc = getroot()  # ElementTree instance, instead of an element\n        # convert XHTML to HTML\n        xhtml_to_html(doc)\n        # Normalize a case that IE treats <image> like <img>, and that\n        # can confuse either this step or later steps.\n        for el in doc.iter('image'):\n            el.tag = 'img'\n        if not self.comments:\n            # Of course, if we were going to kill comments anyway, we don't\n            # need to worry about this\n            self.kill_conditional_comments(doc)\n\n        kill_tags = set(self.kill_tags or ())\n        remove_tags = set(self.remove_tags or ())\n        allow_tags = set(self.allow_tags or ())\n\n        if self.scripts:\n            kill_tags.add('script')\n        if self.safe_attrs_only:\n            safe_attrs = set(self.safe_attrs)\n            for el in doc.iter(etree.Element):\n                attrib = el.attrib\n                for aname in attrib.keys():\n                    if aname not in safe_attrs:\n                        del attrib[aname]\n        if self.javascript:\n            if not (self.safe_attrs_only and\n                    self.safe_attrs == defs.safe_attrs):\n                # safe_attrs handles events attributes itself\n                for el in doc.iter(etree.Element):\n                    attrib = el.attrib\n                    for aname in attrib.keys():\n                        if aname.startswith('on'):\n                            del attrib[aname]\n            doc.rewrite_links(self._remove_javascript_link,\n                              resolve_base_href=False)\n            # If we're deleting style then we don't have to remove JS links\n            # from styles, otherwise...\n            if not self.inline_style:\n                for el in _find_styled_elements(doc):\n                    old = el.get('style')\n                    new = _replace_css_javascript('', old)\n                    new = _replace_css_import('', new)\n                    if self._has_sneaky_javascript(new):\n                        # Something tricky is going on...\n                        del el.attrib['style']\n                    elif new != old:\n                        el.set('style', new)\n            if not self.style:\n                for el in list(doc.iter('style')):\n                    if el.get('type', '').lower().strip() == 'text/javascript':\n                        el.drop_tree()\n                        continue\n                    old = el.text or ''\n                    new = _replace_css_javascript('', old)\n                    # The imported CSS can do anything; we just can't allow:\n                    new = _replace_css_import('', new)\n                    if self._has_sneaky_javascript(new):\n                        # Something tricky is going on...\n                        el.text = '/* deleted */'\n                    elif new != old:\n                        el.text = new\n        if self.comments:\n            kill_tags.add(etree.Comment)\n        if self.processing_instructions:\n            kill_tags.add(etree.ProcessingInstruction)\n        if self.style:\n            kill_tags.add('style')\n        if self.inline_style:\n            etree.strip_attributes(doc, 'style')\n        if self.links:\n            kill_tags.add('link')\n        elif self.style or self.javascript:\n            # We must get rid of included stylesheets if Javascript is not\n            # allowed, as you can put Javascript in them\n            for el in list(doc.iter('link')):\n                if 'stylesheet' in el.get('rel', '').lower():\n                    # Note this kills alternate stylesheets as well\n                    if not self.allow_element(el):\n                        el.drop_tree()\n        if self.meta:\n            kill_tags.add('meta')\n        if self.page_structure:\n            remove_tags.update(('head', 'html', 'title'))\n        if self.embedded:\n            # FIXME: is <layer> really embedded?\n            # We should get rid of any <param> tags not inside <applet>;\n            # These are not really valid anyway.\n            for el in list(doc.iter('param')):\n                parent = el.getparent()\n                while parent is not None and parent.tag not in ('applet', 'object'):\n                    parent = parent.getparent()\n                if parent is None:\n                    el.drop_tree()\n            kill_tags.update(('applet',))\n            # The alternate contents that are in an iframe are a good fallback:\n            remove_tags.update(('iframe', 'embed', 'layer', 'object', 'param'))\n        if self.frames:\n            # FIXME: ideally we should look at the frame links, but\n            # generally frames don't mix properly with an HTML\n            # fragment anyway.\n            kill_tags.update(defs.frame_tags)\n        if self.forms:\n            remove_tags.add('form')\n            kill_tags.update(('button', 'input', 'select', 'textarea'))\n        if self.annoying_tags:\n            remove_tags.update(('blink', 'marquee'))\n\n        _remove = []\n        _kill = []\n        for el in doc.iter():\n            if el.tag in kill_tags:\n                if self.allow_element(el):\n                    continue\n                _kill.append(el)\n            elif el.tag in remove_tags:\n                if self.allow_element(el):\n                    continue\n                _remove.append(el)\n\n        if _remove and _remove[0] == doc:\n            # We have to drop the parent-most tag, which we can't\n            # do.  Instead we'll rewrite it:\n            el = _remove.pop(0)\n            el.tag = 'div'\n            el.attrib.clear()\n        elif _kill and _kill[0] == doc:\n            # We have to drop the parent-most element, which we can't\n            # do.  Instead we'll clear it:\n            el = _kill.pop(0)\n            if el.tag != 'html':\n                el.tag = 'div'\n            el.clear()\n\n        _kill.reverse() # start with innermost tags\n        for el in _kill:\n            el.drop_tree()\n        for el in _remove:\n            el.drop_tag()\n\n        if self.remove_unknown_tags:\n            if allow_tags:\n                raise ValueError(\n                    \"It does not make sense to pass in both allow_tags and remove_unknown_tags\")\n            allow_tags = set(defs.tags)\n        if allow_tags:\n            # make sure we do not remove comments/PIs if users want them (which is rare enough)\n            if not self.comments:\n                allow_tags.add(etree.Comment)\n            if not self.processing_instructions:\n                allow_tags.add(etree.ProcessingInstruction)\n\n            bad = []\n            for el in doc.iter():\n                if el.tag not in allow_tags:\n                    bad.append(el)\n            if bad:\n                if bad[0] is doc:\n                    el = bad.pop(0)\n                    el.tag = 'div'\n                    el.attrib.clear()\n                for el in bad:\n                    el.drop_tag()\n        if self.add_nofollow:\n            for el in _find_external_links(doc):\n                if not self.allow_follow(el):\n                    rel = el.get('rel')\n                    if rel:\n                        if ('nofollow' in rel\n                                and ' nofollow ' in (' %s ' % rel)):\n                            continue\n                        rel = '%s nofollow' % rel\n                    else:\n                        rel = 'nofollow'\n                    el.set('rel', rel)\n\n    def allow_follow(self, anchor):\n        \"\"\"\n        Override to suppress rel=\"nofollow\" on some anchors.\n        \"\"\"\n        return False\n\n    def allow_element(self, el):\n        \"\"\"\n        Decide whether an element is configured to be accepted or rejected.\n\n        :param el: an element.\n        :return: true to accept the element or false to reject/discard it.\n        \"\"\"\n        if el.tag not in self._tag_link_attrs:\n            return False\n        attr = self._tag_link_attrs[el.tag]\n        if isinstance(attr, (list, tuple)):\n            for one_attr in attr:\n                url = el.get(one_attr)\n                if not url:\n                    return False\n                if not self.allow_embedded_url(el, url):\n                    return False\n            return True\n        else:\n            url = el.get(attr)\n            if not url:\n                return False\n            return self.allow_embedded_url(el, url)\n\n    def allow_embedded_url(self, el, url):\n        \"\"\"\n        Decide whether a URL that was found in an element's attributes or text\n        if configured to be accepted or rejected.\n\n        :param el: an element.\n        :param url: a URL found on the element.\n        :return: true to accept the URL and false to reject it.\n        \"\"\"\n        if self.whitelist_tags is not None and el.tag not in self.whitelist_tags:\n            return False\n        scheme, netloc, path, query, fragment = urlsplit(url)\n        netloc = netloc.lower().split(':', 1)[0]\n        if scheme not in ('http', 'https'):\n            return False\n        if netloc in self.host_whitelist:\n            return True\n        return False\n\n    def kill_conditional_comments(self, doc):\n        \"\"\"\n        IE conditional comments basically embed HTML that the parser\n        doesn't normally see.  We can't allow anything like that, so\n        we'll kill any comments that could be conditional.\n        \"\"\"\n        has_conditional_comment = _conditional_comment_re.search\n        self._kill_elements(\n            doc, lambda el: has_conditional_comment(el.text),\n            etree.Comment)                \n\n    def _kill_elements(self, doc, condition, iterate=None):\n        bad = []\n        for el in doc.iter(iterate):\n            if condition(el):\n                bad.append(el)\n        for el in bad:\n            el.drop_tree()\n\n    def _remove_javascript_link(self, link):\n        # links like \"j a v a s c r i p t:\" might be interpreted in IE\n        new = _substitute_whitespace('', unquote_plus(link))\n        if _is_javascript_scheme(new):\n            # FIXME: should this be None to delete?\n            return ''\n        return link\n\n    _substitute_comments = re.compile(r'/\\*.*?\\*/', re.S).sub\n\n    def _has_sneaky_javascript(self, style):\n        \"\"\"\n        Depending on the browser, stuff like ``e x p r e s s i o n(...)``\n        can get interpreted, or ``expre/* stuff */ssion(...)``.  This\n        checks for attempt to do stuff like this.\n\n        Typically the response will be to kill the entire style; if you\n        have just a bit of Javascript in the style another rule will catch\n        that and remove only the Javascript from the style; this catches\n        more sneaky attempts.\n        \"\"\"\n        style = self._substitute_comments('', style)\n        style = style.replace('\\\\', '')\n        style = _substitute_whitespace('', style)\n        style = style.lower()\n        if 'javascript:' in style:\n            return True\n        if 'expression(' in style:\n            return True\n        if '</noscript' in style:\n            # e.g. '<noscript><style><a title=\"</noscript><img src=x onerror=alert(1)>\">'\n            return True\n        if _looks_like_tag_content(style):\n            # e.g. '<math><style><img src=x onerror=alert(1)></style></math>'\n            return True\n        return False\n\n    def clean_html(self, html):\n        result_type = type(html)\n        if isinstance(html, basestring):\n            doc = fromstring(html)\n        else:\n            doc = copy.deepcopy(html)\n        self(doc)\n        return _transform_result(result_type, doc)\n\nclean = Cleaner()\nclean_html = clean.clean_html\n\n############################################################\n## Autolinking\n############################################################\n\n_link_regexes = [\n    re.compile(r'(?P<body>https?://(?P<host>[a-z0-9._-]+)(?:/[/\\-_.,a-z0-9%&?;=~]*)?(?:\\([/\\-_.,a-z0-9%&?;=~]*\\))?)', re.I),\n    # This is conservative, but autolinking can be a bit conservative:\n    re.compile(r'mailto:(?P<body>[a-z0-9._-]+@(?P<host>[a-z0-9_.-]+[a-z]))', re.I),\n    ]\n\n_avoid_elements = ['textarea', 'pre', 'code', 'head', 'select', 'a']\n\n_avoid_hosts = [\n    re.compile(r'^localhost', re.I),\n    re.compile(r'\\bexample\\.(?:com|org|net)$', re.I),\n    re.compile(r'^127\\.0\\.0\\.1$'),\n    ]\n\n_avoid_classes = ['nolink']\n\ndef autolink(el, link_regexes=_link_regexes,\n             avoid_elements=_avoid_elements,\n             avoid_hosts=_avoid_hosts,\n             avoid_classes=_avoid_classes):\n    \"\"\"\n    Turn any URLs into links.\n\n    It will search for links identified by the given regular\n    expressions (by default mailto and http(s) links).\n\n    It won't link text in an element in avoid_elements, or an element\n    with a class in avoid_classes.  It won't link to anything with a\n    host that matches one of the regular expressions in avoid_hosts\n    (default localhost and 127.0.0.1).\n\n    If you pass in an element, the element's tail will not be\n    substituted, only the contents of the element.\n    \"\"\"\n    if el.tag in avoid_elements:\n        return\n    class_name = el.get('class')\n    if class_name:\n        class_name = class_name.split()\n        for match_class in avoid_classes:\n            if match_class in class_name:\n                return\n    for child in list(el):\n        autolink(child, link_regexes=link_regexes,\n                 avoid_elements=avoid_elements,\n                 avoid_hosts=avoid_hosts,\n                 avoid_classes=avoid_classes)\n        if child.tail:\n            text, tail_children = _link_text(\n                child.tail, link_regexes, avoid_hosts, factory=el.makeelement)\n            if tail_children:\n                child.tail = text\n                index = el.index(child)\n                el[index+1:index+1] = tail_children\n    if el.text:\n        text, pre_children = _link_text(\n            el.text, link_regexes, avoid_hosts, factory=el.makeelement)\n        if pre_children:\n            el.text = text\n            el[:0] = pre_children\n\ndef _link_text(text, link_regexes, avoid_hosts, factory):\n    leading_text = ''\n    links = []\n    last_pos = 0\n    while 1:\n        best_match, best_pos = None, None\n        for regex in link_regexes:\n            regex_pos = last_pos\n            while 1:\n                match = regex.search(text, pos=regex_pos)\n                if match is None:\n                    break\n                host = match.group('host')\n                for host_regex in avoid_hosts:\n                    if host_regex.search(host):\n                        regex_pos = match.end()\n                        break\n                else:\n                    break\n            if match is None:\n                continue\n            if best_pos is None or match.start() < best_pos:\n                best_match = match\n                best_pos = match.start()\n        if best_match is None:\n            # No more matches\n            if links:\n                assert not links[-1].tail\n                links[-1].tail = text\n            else:\n                assert not leading_text\n                leading_text = text\n            break\n        link = best_match.group(0)\n        end = best_match.end()\n        if link.endswith('.') or link.endswith(','):\n            # These punctuation marks shouldn't end a link\n            end -= 1\n            link = link[:-1]\n        prev_text = text[:best_match.start()]\n        if links:\n            assert not links[-1].tail\n            links[-1].tail = prev_text\n        else:\n            assert not leading_text\n            leading_text = prev_text\n        anchor = factory('a')\n        anchor.set('href', link)\n        body = best_match.group('body')\n        if not body:\n            body = link\n        if body.endswith('.') or body.endswith(','):\n            body = body[:-1]\n        anchor.text = body\n        links.append(anchor)\n        text = text[end:]\n    return leading_text, links\n                \ndef autolink_html(html, *args, **kw):\n    result_type = type(html)\n    if isinstance(html, basestring):\n        doc = fromstring(html)\n    else:\n        doc = copy.deepcopy(html)\n    autolink(doc, *args, **kw)\n    return _transform_result(result_type, doc)\n\nautolink_html.__doc__ = autolink.__doc__\n\n############################################################\n## Word wrapping\n############################################################\n\n_avoid_word_break_elements = ['pre', 'textarea', 'code']\n_avoid_word_break_classes = ['nobreak']\n\ndef word_break(el, max_width=40,\n               avoid_elements=_avoid_word_break_elements,\n               avoid_classes=_avoid_word_break_classes,\n               break_character=unichr(0x200b)):\n    \"\"\"\n    Breaks any long words found in the body of the text (not attributes).\n\n    Doesn't effect any of the tags in avoid_elements, by default\n    ``<textarea>`` and ``<pre>``\n\n    Breaks words by inserting &#8203;, which is a unicode character\n    for Zero Width Space character.  This generally takes up no space\n    in rendering, but does copy as a space, and in monospace contexts\n    usually takes up space.\n\n    See http://www.cs.tut.fi/~jkorpela/html/nobr.html for a discussion\n    \"\"\"\n    # Character suggestion of &#8203 comes from:\n    #   http://www.cs.tut.fi/~jkorpela/html/nobr.html\n    if el.tag in _avoid_word_break_elements:\n        return\n    class_name = el.get('class')\n    if class_name:\n        dont_break = False\n        class_name = class_name.split()\n        for avoid in avoid_classes:\n            if avoid in class_name:\n                dont_break = True\n                break\n        if dont_break:\n            return\n    if el.text:\n        el.text = _break_text(el.text, max_width, break_character)\n    for child in el:\n        word_break(child, max_width=max_width,\n                   avoid_elements=avoid_elements,\n                   avoid_classes=avoid_classes,\n                   break_character=break_character)\n        if child.tail:\n            child.tail = _break_text(child.tail, max_width, break_character)\n\ndef word_break_html(html, *args, **kw):\n    result_type = type(html)\n    doc = fromstring(html)\n    word_break(doc, *args, **kw)\n    return _transform_result(result_type, doc)\n\ndef _break_text(text, max_width, break_character):\n    words = text.split()\n    for word in words:\n        if len(word) > max_width:\n            replacement = _insert_break(word, max_width, break_character)\n            text = text.replace(word, replacement)\n    return text\n\n_break_prefer_re = re.compile(r'[^a-z]', re.I)\n\ndef _insert_break(word, width, break_character):\n    orig_word = word\n    result = ''\n    while len(word) > width:\n        start = word[:width]\n        breaks = list(_break_prefer_re.finditer(start))\n        if breaks:\n            last_break = breaks[-1]\n            # Only walk back up to 10 characters to find a nice break:\n            if last_break.end() > width-10:\n                # FIXME: should the break character be at the end of the\n                # chunk, or the beginning of the next chunk?\n                start = word[:last_break.end()]\n        result += start + break_character\n        word = word[len(start):]\n    result += word\n    return result\n    \n", "import unittest\nfrom lxml.tests.common_imports import make_doctest\n\nimport lxml.html\nfrom lxml.html.clean import Cleaner, clean_html\n\n\nclass CleanerTest(unittest.TestCase):\n    def test_allow_tags(self):\n        html = \"\"\"\n            <html>\n            <head>\n            </head>\n            <body>\n            <p>some text</p>\n            <table>\n            <tr>\n            <td>hello</td><td>world</td>\n            </tr>\n            <tr>\n            <td>hello</td><td>world</td>\n            </tr>\n            </table>\n            <img>\n            </body>\n            </html>\n            \"\"\"\n\n        html_root = lxml.html.document_fromstring(html)\n        cleaner = Cleaner(\n            remove_unknown_tags = False,\n            allow_tags = ['table', 'tr', 'td'])\n        result = cleaner.clean_html(html_root)\n\n        self.assertEqual(12-5+1, len(list(result.iter())))\n\n    def test_allow_and_remove(self):\n        with self.assertRaises(ValueError):\n            Cleaner(allow_tags=['a'], remove_unknown_tags=True)\n\n    def test_remove_unknown_tags(self):\n        html = \"\"\"<div><bun>lettuce, tomato, veggie patty</bun></div>\"\"\"\n        clean_html = \"\"\"<div>lettuce, tomato, veggie patty</div>\"\"\"\n        cleaner = Cleaner(remove_unknown_tags=True)\n        result = cleaner.clean_html(html)\n        self.assertEqual(\n            result,\n            clean_html,\n            msg=\"Unknown tags not removed. Got: %s\" % result,\n        )\n\n    def test_safe_attrs_included(self):\n        html = \"\"\"<p><span style=\"color: #00ffff;\">Cyan</span></p>\"\"\"\n\n        safe_attrs=set(lxml.html.defs.safe_attrs)\n        safe_attrs.add('style')\n\n        cleaner = Cleaner(\n            safe_attrs_only=True,\n            safe_attrs=safe_attrs)\n        result = cleaner.clean_html(html)\n\n        self.assertEqual(html, result)\n\n    def test_safe_attrs_excluded(self):\n        html = \"\"\"<p><span style=\"color: #00ffff;\">Cyan</span></p>\"\"\"\n        expected = \"\"\"<p><span>Cyan</span></p>\"\"\"\n\n        safe_attrs=set()\n\n        cleaner = Cleaner(\n            safe_attrs_only=True,\n            safe_attrs=safe_attrs)\n        result = cleaner.clean_html(html)\n\n        self.assertEqual(expected, result)\n\n    def test_clean_invalid_root_tag(self):\n        # only testing that cleaning with invalid root tags works at all\n        s = lxml.html.fromstring('parent <invalid tag>child</another>')\n        self.assertEqual('parent child', clean_html(s).text_content())\n\n        s = lxml.html.fromstring('<invalid tag>child</another>')\n        self.assertEqual('child', clean_html(s).text_content())\n\n    def test_clean_with_comments(self):\n        html = \"\"\"<p><span style=\"color: #00ffff;\">Cy<!-- xx -->an</span><!-- XXX --></p>\"\"\"\n        s = lxml.html.fragment_fromstring(html)\n\n        self.assertEqual(\n            b'<p><span>Cyan</span></p>',\n            lxml.html.tostring(clean_html(s)))\n        self.assertEqual(\n            '<p><span>Cyan</span></p>',\n            clean_html(html))\n\n        cleaner = Cleaner(comments=False)\n        result = cleaner.clean_html(s)\n        self.assertEqual(\n            b'<p><span>Cy<!-- xx -->an</span><!-- XXX --></p>',\n            lxml.html.tostring(result))\n        self.assertEqual(\n            '<p><span>Cy<!-- xx -->an</span><!-- XXX --></p>',\n            cleaner.clean_html(html))\n\n    def test_sneaky_noscript_in_style(self):\n        # This gets parsed as <noscript> -> <style>\"...</noscript>...\"</style>\n        # thus passing the </noscript> through into the output.\n        html = '<noscript><style><a title=\"</noscript><img src=x onerror=alert(1)>\">'\n        s = lxml.html.fragment_fromstring(html)\n\n        self.assertEqual(\n            b'<noscript><style>/* deleted */</style></noscript>',\n            lxml.html.tostring(clean_html(s)))\n\n    def test_sneaky_js_in_math_style(self):\n        # This gets parsed as <math> -> <style>\"...\"</style>\n        # thus passing any tag/script/whatever content through into the output.\n        html = '<math><style><img src=x onerror=alert(1)></style></math>'\n        s = lxml.html.fragment_fromstring(html)\n\n        self.assertEqual(\n            b'<math><style>/* deleted */</style></math>',\n            lxml.html.tostring(clean_html(s)))\n\n    def test_formaction_attribute_in_button_input(self):\n        # The formaction attribute overrides the form's action and should be\n        # treated as a malicious link attribute\n        html = ('<form id=\"test\"><input type=\"submit\" formaction=\"javascript:alert(1)\"></form>'\n        '<button form=\"test\" formaction=\"javascript:alert(1)\">X</button>')\n        expected = ('<div><form id=\"test\"><input type=\"submit\" formaction=\"\"></form>'\n        '<button form=\"test\" formaction=\"\">X</button></div>')\n        cleaner = Cleaner(\n            forms=False,\n            safe_attrs_only=False,\n        )\n        self.assertEqual(\n            expected,\n            cleaner.clean_html(html))\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([make_doctest('test_clean.txt')])\n    suite.addTests([make_doctest('test_clean_embed.txt')])\n    suite.addTests(unittest.makeSuite(CleanerTest))\n    return suite\n"], "fixing_code": ["# cython: language_level=3str\n\n\"\"\"A cleanup tool for HTML.\n\nRemoves unwanted tags and content.  See the `Cleaner` class for\ndetails.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport copy\nimport re\nimport sys\ntry:\n    from urlparse import urlsplit\n    from urllib import unquote_plus\nexcept ImportError:\n    # Python 3\n    from urllib.parse import urlsplit, unquote_plus\nfrom lxml import etree\nfrom lxml.html import defs\nfrom lxml.html import fromstring, XHTML_NAMESPACE\nfrom lxml.html import xhtml_to_html, _transform_result\n\ntry:\n    unichr\nexcept NameError:\n    # Python 3\n    unichr = chr\ntry:\n    unicode\nexcept NameError:\n    # Python 3\n    unicode = str\ntry:\n    basestring\nexcept NameError:\n    basestring = (str, bytes)\n\n\n__all__ = ['clean_html', 'clean', 'Cleaner', 'autolink', 'autolink_html',\n           'word_break', 'word_break_html']\n\n# Look at http://code.sixapart.com/trac/livejournal/browser/trunk/cgi-bin/cleanhtml.pl\n#   Particularly the CSS cleaning; most of the tag cleaning is integrated now\n# I have multiple kinds of schemes searched; but should schemes be\n#   whitelisted instead?\n# max height?\n# remove images?  Also in CSS?  background attribute?\n# Some way to whitelist object, iframe, etc (e.g., if you want to\n#   allow *just* embedded YouTube movies)\n# Log what was deleted and why?\n# style=\"behavior: ...\" might be bad in IE?\n# Should we have something for just <meta http-equiv>?  That's the worst of the\n#   metas.\n# UTF-7 detections?  Example:\n#     <HEAD><META HTTP-EQUIV=\"CONTENT-TYPE\" CONTENT=\"text/html; charset=UTF-7\"> </HEAD>+ADw-SCRIPT+AD4-alert('XSS');+ADw-/SCRIPT+AD4-\n#   you don't always have to have the charset set, if the page has no charset\n#   and there's UTF7-like code in it.\n# Look at these tests: http://htmlpurifier.org/live/smoketests/xssAttacks.php\n\n\n# This is an IE-specific construct you can have in a stylesheet to\n# run some Javascript:\n_replace_css_javascript = re.compile(\n    r'expression\\s*\\(.*?\\)', re.S|re.I).sub\n\n# Do I have to worry about @\\nimport?\n_replace_css_import = re.compile(\n    r'@\\s*import', re.I).sub\n\n_looks_like_tag_content = re.compile(\n    r'</?[a-zA-Z]+|\\son[a-zA-Z]+\\s*=',\n    *((re.ASCII,) if sys.version_info[0] >= 3 else ())).search\n\n# All kinds of schemes besides just javascript: that can cause\n# execution:\n_is_image_dataurl = re.compile(\n    r'^data:image/.+;base64', re.I).search\n_is_possibly_malicious_scheme = re.compile(\n    r'(?:javascript|jscript|livescript|vbscript|data|about|mocha):',\n    re.I).search\ndef _is_javascript_scheme(s):\n    if _is_image_dataurl(s):\n        return None\n    return _is_possibly_malicious_scheme(s)\n\n_substitute_whitespace = re.compile(r'[\\s\\x00-\\x08\\x0B\\x0C\\x0E-\\x19]+').sub\n# FIXME: should data: be blocked?\n\n# FIXME: check against: http://msdn2.microsoft.com/en-us/library/ms537512.aspx\n_conditional_comment_re = re.compile(\n    r'\\[if[\\s\\n\\r]+.*?][\\s\\n\\r]*>', re.I|re.S)\n\n_find_styled_elements = etree.XPath(\n    \"descendant-or-self::*[@style]\")\n\n_find_external_links = etree.XPath(\n    (\"descendant-or-self::a  [normalize-space(@href) and substring(normalize-space(@href),1,1) != '#'] |\"\n     \"descendant-or-self::x:a[normalize-space(@href) and substring(normalize-space(@href),1,1) != '#']\"),\n    namespaces={'x':XHTML_NAMESPACE})\n\n\nclass Cleaner(object):\n    \"\"\"\n    Instances cleans the document of each of the possible offending\n    elements.  The cleaning is controlled by attributes; you can\n    override attributes in a subclass, or set them in the constructor.\n\n    ``scripts``:\n        Removes any ``<script>`` tags.\n\n    ``javascript``:\n        Removes any Javascript, like an ``onclick`` attribute. Also removes stylesheets\n        as they could contain Javascript.\n\n    ``comments``:\n        Removes any comments.\n\n    ``style``:\n        Removes any style tags.\n\n    ``inline_style``\n        Removes any style attributes.  Defaults to the value of the ``style`` option.\n\n    ``links``:\n        Removes any ``<link>`` tags\n\n    ``meta``:\n        Removes any ``<meta>`` tags\n\n    ``page_structure``:\n        Structural parts of a page: ``<head>``, ``<html>``, ``<title>``.\n\n    ``processing_instructions``:\n        Removes any processing instructions.\n\n    ``embedded``:\n        Removes any embedded objects (flash, iframes)\n\n    ``frames``:\n        Removes any frame-related tags\n\n    ``forms``:\n        Removes any form tags\n\n    ``annoying_tags``:\n        Tags that aren't *wrong*, but are annoying.  ``<blink>`` and ``<marquee>``\n\n    ``remove_tags``:\n        A list of tags to remove.  Only the tags will be removed,\n        their content will get pulled up into the parent tag.\n\n    ``kill_tags``:\n        A list of tags to kill.  Killing also removes the tag's content,\n        i.e. the whole subtree, not just the tag itself.\n\n    ``allow_tags``:\n        A list of tags to include (default include all).\n\n    ``remove_unknown_tags``:\n        Remove any tags that aren't standard parts of HTML.\n\n    ``safe_attrs_only``:\n        If true, only include 'safe' attributes (specifically the list\n        from the feedparser HTML sanitisation web site).\n\n    ``safe_attrs``:\n        A set of attribute names to override the default list of attributes\n        considered 'safe' (when safe_attrs_only=True).\n\n    ``add_nofollow``:\n        If true, then any <a> tags will have ``rel=\"nofollow\"`` added to them.\n\n    ``host_whitelist``:\n        A list or set of hosts that you can use for embedded content\n        (for content like ``<object>``, ``<link rel=\"stylesheet\">``, etc).\n        You can also implement/override the method\n        ``allow_embedded_url(el, url)`` or ``allow_element(el)`` to\n        implement more complex rules for what can be embedded.\n        Anything that passes this test will be shown, regardless of\n        the value of (for instance) ``embedded``.\n\n        Note that this parameter might not work as intended if you do not\n        make the links absolute before doing the cleaning.\n\n        Note that you may also need to set ``whitelist_tags``.\n\n    ``whitelist_tags``:\n        A set of tags that can be included with ``host_whitelist``.\n        The default is ``iframe`` and ``embed``; you may wish to\n        include other tags like ``script``, or you may want to\n        implement ``allow_embedded_url`` for more control.  Set to None to\n        include all tags.\n\n    This modifies the document *in place*.\n    \"\"\"\n\n    scripts = True\n    javascript = True\n    comments = True\n    style = False\n    inline_style = None\n    links = True\n    meta = True\n    page_structure = True\n    processing_instructions = True\n    embedded = True\n    frames = True\n    forms = True\n    annoying_tags = True\n    remove_tags = None\n    allow_tags = None\n    kill_tags = None\n    remove_unknown_tags = True\n    safe_attrs_only = True\n    safe_attrs = defs.safe_attrs\n    add_nofollow = False\n    host_whitelist = ()\n    whitelist_tags = {'iframe', 'embed'}\n\n    def __init__(self, **kw):\n        not_an_attribute = object()\n        for name, value in kw.items():\n            default = getattr(self, name, not_an_attribute)\n            if (default is not None and default is not True and default is not False\n                    and not isinstance(default, (frozenset, set, tuple, list))):\n                raise TypeError(\n                    \"Unknown parameter: %s=%r\" % (name, value))\n            setattr(self, name, value)\n        if self.inline_style is None and 'inline_style' not in kw:\n            self.inline_style = self.style\n\n        if kw.get(\"allow_tags\"):\n            if kw.get(\"remove_unknown_tags\"):\n                raise ValueError(\"It does not make sense to pass in both \"\n                                 \"allow_tags and remove_unknown_tags\")\n            self.remove_unknown_tags = False\n\n    # Used to lookup the primary URL for a given tag that is up for\n    # removal:\n    _tag_link_attrs = dict(\n        script='src',\n        link='href',\n        # From: http://java.sun.com/j2se/1.4.2/docs/guide/misc/applet.html\n        # From what I can tell, both attributes can contain a link:\n        applet=['code', 'object'],\n        iframe='src',\n        embed='src',\n        layer='src',\n        # FIXME: there doesn't really seem like a general way to figure out what\n        # links an <object> tag uses; links often go in <param> tags with values\n        # that we don't really know.  You'd have to have knowledge about specific\n        # kinds of plugins (probably keyed off classid), and match against those.\n        ##object=?,\n        # FIXME: not looking at the action currently, because it is more complex\n        # than than -- if you keep the form, you should keep the form controls.\n        ##form='action',\n        a='href',\n        )\n\n    def __call__(self, doc):\n        \"\"\"\n        Cleans the document.\n        \"\"\"\n        try:\n            getroot = doc.getroot\n        except AttributeError:\n            pass  # Element instance\n        else:\n            doc = getroot()  # ElementTree instance, instead of an element\n        # convert XHTML to HTML\n        xhtml_to_html(doc)\n        # Normalize a case that IE treats <image> like <img>, and that\n        # can confuse either this step or later steps.\n        for el in doc.iter('image'):\n            el.tag = 'img'\n        if not self.comments:\n            # Of course, if we were going to kill comments anyway, we don't\n            # need to worry about this\n            self.kill_conditional_comments(doc)\n\n        kill_tags = set(self.kill_tags or ())\n        remove_tags = set(self.remove_tags or ())\n        allow_tags = set(self.allow_tags or ())\n\n        if self.scripts:\n            kill_tags.add('script')\n        if self.safe_attrs_only:\n            safe_attrs = set(self.safe_attrs)\n            for el in doc.iter(etree.Element):\n                attrib = el.attrib\n                for aname in attrib.keys():\n                    if aname not in safe_attrs:\n                        del attrib[aname]\n        if self.javascript:\n            if not (self.safe_attrs_only and\n                    self.safe_attrs == defs.safe_attrs):\n                # safe_attrs handles events attributes itself\n                for el in doc.iter(etree.Element):\n                    attrib = el.attrib\n                    for aname in attrib.keys():\n                        if aname.startswith('on'):\n                            del attrib[aname]\n            doc.rewrite_links(self._remove_javascript_link,\n                              resolve_base_href=False)\n            # If we're deleting style then we don't have to remove JS links\n            # from styles, otherwise...\n            if not self.inline_style:\n                for el in _find_styled_elements(doc):\n                    old = el.get('style')\n                    new = _replace_css_javascript('', old)\n                    new = _replace_css_import('', new)\n                    if self._has_sneaky_javascript(new):\n                        # Something tricky is going on...\n                        del el.attrib['style']\n                    elif new != old:\n                        el.set('style', new)\n            if not self.style:\n                for el in list(doc.iter('style')):\n                    if el.get('type', '').lower().strip() == 'text/javascript':\n                        el.drop_tree()\n                        continue\n                    old = el.text or ''\n                    new = _replace_css_javascript('', old)\n                    # The imported CSS can do anything; we just can't allow:\n                    new = _replace_css_import('', new)\n                    if self._has_sneaky_javascript(new):\n                        # Something tricky is going on...\n                        el.text = '/* deleted */'\n                    elif new != old:\n                        el.text = new\n        if self.comments:\n            kill_tags.add(etree.Comment)\n        if self.processing_instructions:\n            kill_tags.add(etree.ProcessingInstruction)\n        if self.style:\n            kill_tags.add('style')\n        if self.inline_style:\n            etree.strip_attributes(doc, 'style')\n        if self.links:\n            kill_tags.add('link')\n        elif self.style or self.javascript:\n            # We must get rid of included stylesheets if Javascript is not\n            # allowed, as you can put Javascript in them\n            for el in list(doc.iter('link')):\n                if 'stylesheet' in el.get('rel', '').lower():\n                    # Note this kills alternate stylesheets as well\n                    if not self.allow_element(el):\n                        el.drop_tree()\n        if self.meta:\n            kill_tags.add('meta')\n        if self.page_structure:\n            remove_tags.update(('head', 'html', 'title'))\n        if self.embedded:\n            # FIXME: is <layer> really embedded?\n            # We should get rid of any <param> tags not inside <applet>;\n            # These are not really valid anyway.\n            for el in list(doc.iter('param')):\n                parent = el.getparent()\n                while parent is not None and parent.tag not in ('applet', 'object'):\n                    parent = parent.getparent()\n                if parent is None:\n                    el.drop_tree()\n            kill_tags.update(('applet',))\n            # The alternate contents that are in an iframe are a good fallback:\n            remove_tags.update(('iframe', 'embed', 'layer', 'object', 'param'))\n        if self.frames:\n            # FIXME: ideally we should look at the frame links, but\n            # generally frames don't mix properly with an HTML\n            # fragment anyway.\n            kill_tags.update(defs.frame_tags)\n        if self.forms:\n            remove_tags.add('form')\n            kill_tags.update(('button', 'input', 'select', 'textarea'))\n        if self.annoying_tags:\n            remove_tags.update(('blink', 'marquee'))\n\n        _remove = []\n        _kill = []\n        for el in doc.iter():\n            if el.tag in kill_tags:\n                if self.allow_element(el):\n                    continue\n                _kill.append(el)\n            elif el.tag in remove_tags:\n                if self.allow_element(el):\n                    continue\n                _remove.append(el)\n\n        if _remove and _remove[0] == doc:\n            # We have to drop the parent-most tag, which we can't\n            # do.  Instead we'll rewrite it:\n            el = _remove.pop(0)\n            el.tag = 'div'\n            el.attrib.clear()\n        elif _kill and _kill[0] == doc:\n            # We have to drop the parent-most element, which we can't\n            # do.  Instead we'll clear it:\n            el = _kill.pop(0)\n            if el.tag != 'html':\n                el.tag = 'div'\n            el.clear()\n\n        _kill.reverse() # start with innermost tags\n        for el in _kill:\n            el.drop_tree()\n        for el in _remove:\n            el.drop_tag()\n\n        if self.remove_unknown_tags:\n            if allow_tags:\n                raise ValueError(\n                    \"It does not make sense to pass in both allow_tags and remove_unknown_tags\")\n            allow_tags = set(defs.tags)\n        if allow_tags:\n            # make sure we do not remove comments/PIs if users want them (which is rare enough)\n            if not self.comments:\n                allow_tags.add(etree.Comment)\n            if not self.processing_instructions:\n                allow_tags.add(etree.ProcessingInstruction)\n\n            bad = []\n            for el in doc.iter():\n                if el.tag not in allow_tags:\n                    bad.append(el)\n            if bad:\n                if bad[0] is doc:\n                    el = bad.pop(0)\n                    el.tag = 'div'\n                    el.attrib.clear()\n                for el in bad:\n                    el.drop_tag()\n        if self.add_nofollow:\n            for el in _find_external_links(doc):\n                if not self.allow_follow(el):\n                    rel = el.get('rel')\n                    if rel:\n                        if ('nofollow' in rel\n                                and ' nofollow ' in (' %s ' % rel)):\n                            continue\n                        rel = '%s nofollow' % rel\n                    else:\n                        rel = 'nofollow'\n                    el.set('rel', rel)\n\n    def allow_follow(self, anchor):\n        \"\"\"\n        Override to suppress rel=\"nofollow\" on some anchors.\n        \"\"\"\n        return False\n\n    def allow_element(self, el):\n        \"\"\"\n        Decide whether an element is configured to be accepted or rejected.\n\n        :param el: an element.\n        :return: true to accept the element or false to reject/discard it.\n        \"\"\"\n        if el.tag not in self._tag_link_attrs:\n            return False\n        attr = self._tag_link_attrs[el.tag]\n        if isinstance(attr, (list, tuple)):\n            for one_attr in attr:\n                url = el.get(one_attr)\n                if not url:\n                    return False\n                if not self.allow_embedded_url(el, url):\n                    return False\n            return True\n        else:\n            url = el.get(attr)\n            if not url:\n                return False\n            return self.allow_embedded_url(el, url)\n\n    def allow_embedded_url(self, el, url):\n        \"\"\"\n        Decide whether a URL that was found in an element's attributes or text\n        if configured to be accepted or rejected.\n\n        :param el: an element.\n        :param url: a URL found on the element.\n        :return: true to accept the URL and false to reject it.\n        \"\"\"\n        if self.whitelist_tags is not None and el.tag not in self.whitelist_tags:\n            return False\n        scheme, netloc, path, query, fragment = urlsplit(url)\n        netloc = netloc.lower().split(':', 1)[0]\n        if scheme not in ('http', 'https'):\n            return False\n        if netloc in self.host_whitelist:\n            return True\n        return False\n\n    def kill_conditional_comments(self, doc):\n        \"\"\"\n        IE conditional comments basically embed HTML that the parser\n        doesn't normally see.  We can't allow anything like that, so\n        we'll kill any comments that could be conditional.\n        \"\"\"\n        has_conditional_comment = _conditional_comment_re.search\n        self._kill_elements(\n            doc, lambda el: has_conditional_comment(el.text),\n            etree.Comment)                \n\n    def _kill_elements(self, doc, condition, iterate=None):\n        bad = []\n        for el in doc.iter(iterate):\n            if condition(el):\n                bad.append(el)\n        for el in bad:\n            el.drop_tree()\n\n    def _remove_javascript_link(self, link):\n        # links like \"j a v a s c r i p t:\" might be interpreted in IE\n        new = _substitute_whitespace('', unquote_plus(link))\n        if _is_javascript_scheme(new):\n            # FIXME: should this be None to delete?\n            return ''\n        return link\n\n    _substitute_comments = re.compile(r'/\\*.*?\\*/', re.S).sub\n\n    def _has_sneaky_javascript(self, style):\n        \"\"\"\n        Depending on the browser, stuff like ``e x p r e s s i o n(...)``\n        can get interpreted, or ``expre/* stuff */ssion(...)``.  This\n        checks for attempt to do stuff like this.\n\n        Typically the response will be to kill the entire style; if you\n        have just a bit of Javascript in the style another rule will catch\n        that and remove only the Javascript from the style; this catches\n        more sneaky attempts.\n        \"\"\"\n        style = self._substitute_comments('', style)\n        style = style.replace('\\\\', '')\n        style = _substitute_whitespace('', style)\n        style = style.lower()\n        if 'javascript:' in style:\n            return True\n        if 'expression(' in style:\n            return True\n        if '@import' in style:\n            return True\n        if '</noscript' in style:\n            # e.g. '<noscript><style><a title=\"</noscript><img src=x onerror=alert(1)>\">'\n            return True\n        if _looks_like_tag_content(style):\n            # e.g. '<math><style><img src=x onerror=alert(1)></style></math>'\n            return True\n        return False\n\n    def clean_html(self, html):\n        result_type = type(html)\n        if isinstance(html, basestring):\n            doc = fromstring(html)\n        else:\n            doc = copy.deepcopy(html)\n        self(doc)\n        return _transform_result(result_type, doc)\n\nclean = Cleaner()\nclean_html = clean.clean_html\n\n############################################################\n## Autolinking\n############################################################\n\n_link_regexes = [\n    re.compile(r'(?P<body>https?://(?P<host>[a-z0-9._-]+)(?:/[/\\-_.,a-z0-9%&?;=~]*)?(?:\\([/\\-_.,a-z0-9%&?;=~]*\\))?)', re.I),\n    # This is conservative, but autolinking can be a bit conservative:\n    re.compile(r'mailto:(?P<body>[a-z0-9._-]+@(?P<host>[a-z0-9_.-]+[a-z]))', re.I),\n    ]\n\n_avoid_elements = ['textarea', 'pre', 'code', 'head', 'select', 'a']\n\n_avoid_hosts = [\n    re.compile(r'^localhost', re.I),\n    re.compile(r'\\bexample\\.(?:com|org|net)$', re.I),\n    re.compile(r'^127\\.0\\.0\\.1$'),\n    ]\n\n_avoid_classes = ['nolink']\n\ndef autolink(el, link_regexes=_link_regexes,\n             avoid_elements=_avoid_elements,\n             avoid_hosts=_avoid_hosts,\n             avoid_classes=_avoid_classes):\n    \"\"\"\n    Turn any URLs into links.\n\n    It will search for links identified by the given regular\n    expressions (by default mailto and http(s) links).\n\n    It won't link text in an element in avoid_elements, or an element\n    with a class in avoid_classes.  It won't link to anything with a\n    host that matches one of the regular expressions in avoid_hosts\n    (default localhost and 127.0.0.1).\n\n    If you pass in an element, the element's tail will not be\n    substituted, only the contents of the element.\n    \"\"\"\n    if el.tag in avoid_elements:\n        return\n    class_name = el.get('class')\n    if class_name:\n        class_name = class_name.split()\n        for match_class in avoid_classes:\n            if match_class in class_name:\n                return\n    for child in list(el):\n        autolink(child, link_regexes=link_regexes,\n                 avoid_elements=avoid_elements,\n                 avoid_hosts=avoid_hosts,\n                 avoid_classes=avoid_classes)\n        if child.tail:\n            text, tail_children = _link_text(\n                child.tail, link_regexes, avoid_hosts, factory=el.makeelement)\n            if tail_children:\n                child.tail = text\n                index = el.index(child)\n                el[index+1:index+1] = tail_children\n    if el.text:\n        text, pre_children = _link_text(\n            el.text, link_regexes, avoid_hosts, factory=el.makeelement)\n        if pre_children:\n            el.text = text\n            el[:0] = pre_children\n\ndef _link_text(text, link_regexes, avoid_hosts, factory):\n    leading_text = ''\n    links = []\n    last_pos = 0\n    while 1:\n        best_match, best_pos = None, None\n        for regex in link_regexes:\n            regex_pos = last_pos\n            while 1:\n                match = regex.search(text, pos=regex_pos)\n                if match is None:\n                    break\n                host = match.group('host')\n                for host_regex in avoid_hosts:\n                    if host_regex.search(host):\n                        regex_pos = match.end()\n                        break\n                else:\n                    break\n            if match is None:\n                continue\n            if best_pos is None or match.start() < best_pos:\n                best_match = match\n                best_pos = match.start()\n        if best_match is None:\n            # No more matches\n            if links:\n                assert not links[-1].tail\n                links[-1].tail = text\n            else:\n                assert not leading_text\n                leading_text = text\n            break\n        link = best_match.group(0)\n        end = best_match.end()\n        if link.endswith('.') or link.endswith(','):\n            # These punctuation marks shouldn't end a link\n            end -= 1\n            link = link[:-1]\n        prev_text = text[:best_match.start()]\n        if links:\n            assert not links[-1].tail\n            links[-1].tail = prev_text\n        else:\n            assert not leading_text\n            leading_text = prev_text\n        anchor = factory('a')\n        anchor.set('href', link)\n        body = best_match.group('body')\n        if not body:\n            body = link\n        if body.endswith('.') or body.endswith(','):\n            body = body[:-1]\n        anchor.text = body\n        links.append(anchor)\n        text = text[end:]\n    return leading_text, links\n                \ndef autolink_html(html, *args, **kw):\n    result_type = type(html)\n    if isinstance(html, basestring):\n        doc = fromstring(html)\n    else:\n        doc = copy.deepcopy(html)\n    autolink(doc, *args, **kw)\n    return _transform_result(result_type, doc)\n\nautolink_html.__doc__ = autolink.__doc__\n\n############################################################\n## Word wrapping\n############################################################\n\n_avoid_word_break_elements = ['pre', 'textarea', 'code']\n_avoid_word_break_classes = ['nobreak']\n\ndef word_break(el, max_width=40,\n               avoid_elements=_avoid_word_break_elements,\n               avoid_classes=_avoid_word_break_classes,\n               break_character=unichr(0x200b)):\n    \"\"\"\n    Breaks any long words found in the body of the text (not attributes).\n\n    Doesn't effect any of the tags in avoid_elements, by default\n    ``<textarea>`` and ``<pre>``\n\n    Breaks words by inserting &#8203;, which is a unicode character\n    for Zero Width Space character.  This generally takes up no space\n    in rendering, but does copy as a space, and in monospace contexts\n    usually takes up space.\n\n    See http://www.cs.tut.fi/~jkorpela/html/nobr.html for a discussion\n    \"\"\"\n    # Character suggestion of &#8203 comes from:\n    #   http://www.cs.tut.fi/~jkorpela/html/nobr.html\n    if el.tag in _avoid_word_break_elements:\n        return\n    class_name = el.get('class')\n    if class_name:\n        dont_break = False\n        class_name = class_name.split()\n        for avoid in avoid_classes:\n            if avoid in class_name:\n                dont_break = True\n                break\n        if dont_break:\n            return\n    if el.text:\n        el.text = _break_text(el.text, max_width, break_character)\n    for child in el:\n        word_break(child, max_width=max_width,\n                   avoid_elements=avoid_elements,\n                   avoid_classes=avoid_classes,\n                   break_character=break_character)\n        if child.tail:\n            child.tail = _break_text(child.tail, max_width, break_character)\n\ndef word_break_html(html, *args, **kw):\n    result_type = type(html)\n    doc = fromstring(html)\n    word_break(doc, *args, **kw)\n    return _transform_result(result_type, doc)\n\ndef _break_text(text, max_width, break_character):\n    words = text.split()\n    for word in words:\n        if len(word) > max_width:\n            replacement = _insert_break(word, max_width, break_character)\n            text = text.replace(word, replacement)\n    return text\n\n_break_prefer_re = re.compile(r'[^a-z]', re.I)\n\ndef _insert_break(word, width, break_character):\n    orig_word = word\n    result = ''\n    while len(word) > width:\n        start = word[:width]\n        breaks = list(_break_prefer_re.finditer(start))\n        if breaks:\n            last_break = breaks[-1]\n            # Only walk back up to 10 characters to find a nice break:\n            if last_break.end() > width-10:\n                # FIXME: should the break character be at the end of the\n                # chunk, or the beginning of the next chunk?\n                start = word[:last_break.end()]\n        result += start + break_character\n        word = word[len(start):]\n    result += word\n    return result\n    \n", "import unittest\nfrom lxml.tests.common_imports import make_doctest\n\nimport lxml.html\nfrom lxml.html.clean import Cleaner, clean_html\n\n\nclass CleanerTest(unittest.TestCase):\n    def test_allow_tags(self):\n        html = \"\"\"\n            <html>\n            <head>\n            </head>\n            <body>\n            <p>some text</p>\n            <table>\n            <tr>\n            <td>hello</td><td>world</td>\n            </tr>\n            <tr>\n            <td>hello</td><td>world</td>\n            </tr>\n            </table>\n            <img>\n            </body>\n            </html>\n            \"\"\"\n\n        html_root = lxml.html.document_fromstring(html)\n        cleaner = Cleaner(\n            remove_unknown_tags = False,\n            allow_tags = ['table', 'tr', 'td'])\n        result = cleaner.clean_html(html_root)\n\n        self.assertEqual(12-5+1, len(list(result.iter())))\n\n    def test_allow_and_remove(self):\n        with self.assertRaises(ValueError):\n            Cleaner(allow_tags=['a'], remove_unknown_tags=True)\n\n    def test_remove_unknown_tags(self):\n        html = \"\"\"<div><bun>lettuce, tomato, veggie patty</bun></div>\"\"\"\n        clean_html = \"\"\"<div>lettuce, tomato, veggie patty</div>\"\"\"\n        cleaner = Cleaner(remove_unknown_tags=True)\n        result = cleaner.clean_html(html)\n        self.assertEqual(\n            result,\n            clean_html,\n            msg=\"Unknown tags not removed. Got: %s\" % result,\n        )\n\n    def test_safe_attrs_included(self):\n        html = \"\"\"<p><span style=\"color: #00ffff;\">Cyan</span></p>\"\"\"\n\n        safe_attrs=set(lxml.html.defs.safe_attrs)\n        safe_attrs.add('style')\n\n        cleaner = Cleaner(\n            safe_attrs_only=True,\n            safe_attrs=safe_attrs)\n        result = cleaner.clean_html(html)\n\n        self.assertEqual(html, result)\n\n    def test_safe_attrs_excluded(self):\n        html = \"\"\"<p><span style=\"color: #00ffff;\">Cyan</span></p>\"\"\"\n        expected = \"\"\"<p><span>Cyan</span></p>\"\"\"\n\n        safe_attrs=set()\n\n        cleaner = Cleaner(\n            safe_attrs_only=True,\n            safe_attrs=safe_attrs)\n        result = cleaner.clean_html(html)\n\n        self.assertEqual(expected, result)\n\n    def test_clean_invalid_root_tag(self):\n        # only testing that cleaning with invalid root tags works at all\n        s = lxml.html.fromstring('parent <invalid tag>child</another>')\n        self.assertEqual('parent child', clean_html(s).text_content())\n\n        s = lxml.html.fromstring('<invalid tag>child</another>')\n        self.assertEqual('child', clean_html(s).text_content())\n\n    def test_clean_with_comments(self):\n        html = \"\"\"<p><span style=\"color: #00ffff;\">Cy<!-- xx -->an</span><!-- XXX --></p>\"\"\"\n        s = lxml.html.fragment_fromstring(html)\n\n        self.assertEqual(\n            b'<p><span>Cyan</span></p>',\n            lxml.html.tostring(clean_html(s)))\n        self.assertEqual(\n            '<p><span>Cyan</span></p>',\n            clean_html(html))\n\n        cleaner = Cleaner(comments=False)\n        result = cleaner.clean_html(s)\n        self.assertEqual(\n            b'<p><span>Cy<!-- xx -->an</span><!-- XXX --></p>',\n            lxml.html.tostring(result))\n        self.assertEqual(\n            '<p><span>Cy<!-- xx -->an</span><!-- XXX --></p>',\n            cleaner.clean_html(html))\n\n    def test_sneaky_noscript_in_style(self):\n        # This gets parsed as <noscript> -> <style>\"...</noscript>...\"</style>\n        # thus passing the </noscript> through into the output.\n        html = '<noscript><style><a title=\"</noscript><img src=x onerror=alert(1)>\">'\n        s = lxml.html.fragment_fromstring(html)\n\n        self.assertEqual(\n            b'<noscript><style>/* deleted */</style></noscript>',\n            lxml.html.tostring(clean_html(s)))\n\n    def test_sneaky_js_in_math_style(self):\n        # This gets parsed as <math> -> <style>\"...\"</style>\n        # thus passing any tag/script/whatever content through into the output.\n        html = '<math><style><img src=x onerror=alert(1)></style></math>'\n        s = lxml.html.fragment_fromstring(html)\n\n        self.assertEqual(\n            b'<math><style>/* deleted */</style></math>',\n            lxml.html.tostring(clean_html(s)))\n\n    def test_sneaky_import_in_style(self):\n        # Prevent \"@@importimport\" -> \"@import\" replacement.\n        style_codes = [\n            \"@@importimport(extstyle.css)\",\n            \"@ @  import import(extstyle.css)\",\n            \"@ @ importimport(extstyle.css)\",\n            \"@@  import import(extstyle.css)\",\n            \"@ @import import(extstyle.css)\",\n            \"@@importimport()\",\n        ]\n        for style_code in style_codes:\n            html = '<style>%s</style>' % style_code\n            s = lxml.html.fragment_fromstring(html)\n\n            cleaned = lxml.html.tostring(clean_html(s))\n            self.assertEqual(\n                b'<style>/* deleted */</style>',\n                cleaned,\n                \"%s  ->  %s\" % (style_code, cleaned))\n\n    def test_formaction_attribute_in_button_input(self):\n        # The formaction attribute overrides the form's action and should be\n        # treated as a malicious link attribute\n        html = ('<form id=\"test\"><input type=\"submit\" formaction=\"javascript:alert(1)\"></form>'\n        '<button form=\"test\" formaction=\"javascript:alert(1)\">X</button>')\n        expected = ('<div><form id=\"test\"><input type=\"submit\" formaction=\"\"></form>'\n        '<button form=\"test\" formaction=\"\">X</button></div>')\n        cleaner = Cleaner(\n            forms=False,\n            safe_attrs_only=False,\n        )\n        self.assertEqual(\n            expected,\n            cleaner.clean_html(html))\n\n\ndef test_suite():\n    suite = unittest.TestSuite()\n    suite.addTests([make_doctest('test_clean.txt')])\n    suite.addTests([make_doctest('test_clean_embed.txt')])\n    suite.addTests(unittest.makeSuite(CleanerTest))\n    return suite\n"], "filenames": ["src/lxml/html/clean.py", "src/lxml/html/tests/test_clean.py"], "buggy_code_start_loc": [543, 125], "buggy_code_end_loc": [543, 125], "fixing_code_start_loc": [544, 126], "fixing_code_end_loc": [546, 146], "type": "CWE-74", "message": "lxml is a library for processing XML and HTML in the Python language. Prior to version 4.6.5, the HTML Cleaner in lxml.html lets certain crafted script content pass through, as well as script content in SVG files embedded using data URIs. Users that employ the HTML cleaner in a security relevant context should upgrade to lxml 4.6.5 to receive a patch. There are no known workarounds available.", "other": {"cve": {"id": "CVE-2021-43818", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-13T18:15:08.387", "lastModified": "2022-12-09T16:38:29.523", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lxml is a library for processing XML and HTML in the Python language. Prior to version 4.6.5, the HTML Cleaner in lxml.html lets certain crafted script content pass through, as well as script content in SVG files embedded using data URIs. Users that employ the HTML cleaner in a security relevant context should upgrade to lxml 4.6.5 to receive a patch. There are no known workarounds available."}, {"lang": "es", "value": "lxml es una biblioteca para procesar XML y HTML en el lenguaje Python. En versiones anteriores a 4.6.5, el limpiador de HTML en lxml.html dejaba pasar determinado contenido de scripts manipulados, as\u00ed como contenido de scripts en archivos SVG insertados usando URIs de datos. Los usuarios que empleen el limpiador de HTML en un contexto relevante para la seguridad deben actualizar a lxml versi\u00f3n 4.6.5 para recibir un parche. No se presentan soluciones conocidas disponibles"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 3.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}, {"lang": "en", "value": "CWE-79"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lxml:lxml:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.6.5", "matchCriteriaId": "DEE4409E-D026-41BB-B57D-65DCE636B964"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire_enterprise_sds:-:*:*:*:*:*:*:*", "matchCriteriaId": "5D18075A-E8D6-48B8-A7FA-54E336A434A2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_storage_node_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "4BC4299D-05D3-4875-BC79-C3DC02C88ECE"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "02DEB4FB-A21D-4CB1-B522-EEE5093E8521"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_binding_support_function:22.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "6EDB6772-7FDB-45FF-8D72-952902A7EE56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_exposure_function:22.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "9955F62A-75D3-4347-9AD3-5947FC365838"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_policy:22.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "7A6D77C7-A2F4-4700-AB5A-3EC853496ECA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:http_server:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "DFC79B17-E9D2-44D5-93ED-2F959E7A3D43"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:http_server:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "AD04BEE5-E9A8-4584-A68C-0195CE9C402C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:zfs_storage_appliance_kit:8.8:*:*:*:*:*:*:*", "matchCriteriaId": "D3E503FB-6279-4D4A-91D8-E237ECF9D2B0"}]}]}], "references": [{"url": "https://github.com/lxml/lxml/commit/12fa9669007180a7bb87d990c375cf91ca5b664a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/lxml/lxml/commit/a3eacbc0dcf1de1c822ec29fb7d090a4b1712a9c#diff-59130575b4fb2932c957db2922977d7d89afb0b2085357db1a14615a2fcad776", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/lxml/lxml/commit/f2330237440df7e8f39c3ad1b1aa8852be3b27c0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/lxml/lxml/security/advisories/GHSA-55x5-fj6c-h6m8", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/12/msg00037.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TUIS2KE3HZ2AAQKXFLTJFZPP2IFHJTC7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/V2XMOM5PFT6U5AAXY6EFNT5JZCKKHK2V/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WZGNET2A4WGLSUXLBFYKNC5PXHQMI3I7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZQ4SPKJX3RRJK4UWA6FXCRHD2TVRQI44/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-06", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220107-0005/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5043", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/lxml/lxml/commit/12fa9669007180a7bb87d990c375cf91ca5b664a"}}