{"buggy_code": ["//\n//  OTRXMPPManager.m\n//  Off the Record\n//\n//  Created by Chris Ballinger on 9/7/11.\n//  Copyright (c) 2011 Chris Ballinger. All rights reserved.\n//\n//  This file is part of ChatSecure.\n//\n//  ChatSecure is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ChatSecure is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with ChatSecure.  If not, see <http://www.gnu.org/licenses/>.\n\n#import \"OTRXMPPManager.h\"\n\n@import CocoaAsyncSocket;\n@import XMPPFramework;\n#import \"OTRYapDatabaseRosterStorage.h\"\n\n#import \"OTRLog.h\"\n\n#import <CFNetwork/CFNetwork.h>\n\n#import \"OTRSettingsManager.h\"\n#import \"OTRConstants.h\"\n#import \"OTRProtocolManager.h\"\n#include <stdlib.h>\n#import \"OTRConstants.h\"\n#import \"OTRUtilities.h\"\n\n#import \"OTRDatabaseManager.h\"\n@import YapDatabase;\n#import \"OTRXMPPBuddy.h\"\n#import \"OTRXMPPAccount.h\"\n#import \"OTRIncomingMessage.h\"\n#import \"OTROutgoingMessage.h\"\n#import \"OTRAccount.h\"\n#import \"OTRXMPPPresenceSubscriptionRequest.h\"\n#import \"OTRvCardYapDatabaseStorage.h\"\n#import \"OTRNotificationController.h\"\n#import \"OTRStreamManagementYapStorage.h\"\n@import OTRKit;\n#import \"OTRXMPPRoomManager.h\"\n#import \"OTRXMPPBuddyTimers.h\"\n#import \"OTRXMPPError.h\"\n#import \"OTRXMPPManager_Private.h\"\n#import \"OTRBuddyCache.h\"\n@import OTRAssets;\n\nNSString *const OTRXMPPRegisterSucceededNotificationName = @\"OTRXMPPRegisterSucceededNotificationName\";\nNSString *const OTRXMPPRegisterFailedNotificationName    = @\"OTRXMPPRegisterFailedNotificationName\";\n\nNSTimeInterval const kOTRChatStatePausedTimeout   = 5;\nNSTimeInterval const kOTRChatStateInactiveTimeout = 120;\n\nNSString *const OTRXMPPLoginStatusNotificationName = @\"OTRXMPPLoginStatusNotificationName\";\n\nNSString *const OTRXMPPOldLoginStatusKey = @\"OTRXMPPOldLoginStatusKey\";\nNSString *const OTRXMPPNewLoginStatusKey = @\"OTRXMPPNewLoginStatusKey\";\nNSString *const OTRXMPPLoginErrorKey = @\"OTRXMPPLoginErrorKey\";\n\n@implementation OTRXMPPManager\n\n- (instancetype)init\n{\n    if (self = [super init]) {\n        NSString * queueLabel = [NSString stringWithFormat:@\"%@.work.%@\",[self class],self];\n        _workQueue = dispatch_queue_create([queueLabel UTF8String], 0);\n        self.connectionStatus = OTRProtocolConnectionStatusDisconnected;\n        _buddyTimers = [NSMutableDictionary dictionary];\n        _databaseConnection = [OTRDatabaseManager sharedInstance].readWriteDatabaseConnection;\n    }\n    return self;\n}\n\n- (instancetype) initWithAccount:(OTRAccount *)newAccount {\n    if(self = [self init])\n    {\n        NSAssert([newAccount isKindOfClass:[OTRXMPPAccount class]], @\"Must have XMPP account\");\n        self.isRegisteringNewAccount = NO;\n        _account = (OTRXMPPAccount *)newAccount;\n        \n        // Setup the XMPP stream\n        [self setupStream];        \n    }\n    \n    return self;\n}\n\n- (void)dealloc\n{\n\t[self teardownStream];\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#pragma mark Private\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n- (void)setupStream\n{\n\tNSAssert(_xmppStream == nil, @\"Method setupStream invoked multiple times\");\n    \n\t_xmppStream = [[XMPPStream alloc] init];\n\n    //Used to fetch correct account from XMPPStream in delegate methods especailly\n    self.xmppStream.tag = self.account.uniqueId;\n    self.xmppStream.startTLSPolicy = XMPPStreamStartTLSPolicyRequired;\n    \n    [self.certificatePinningModule activate:self.xmppStream];\n    \n    _deliveryReceipts = [[XMPPMessageDeliveryReceipts alloc] init];\n    // We want to check if OTR messages can be decrypted\n    self.deliveryReceipts.autoSendMessageDeliveryReceipts = NO;\n    self.deliveryReceipts.autoSendMessageDeliveryRequests = YES;\n    [self.deliveryReceipts activate:self.xmppStream];\n\t\n#if !TARGET_IPHONE_SIMULATOR\n\t{\n\t\t// Want xmpp to run in the background?\n\t\t// \n\t\t// P.S. - The simulator doesn't support backgrounding yet.\n\t\t//        When you try to set the associated property on the simulator, it simply fails.\n\t\t//        And when you background an app on the simulator,\n\t\t//        it just queues network traffic til the app is foregrounded again.\n\t\t//        We are patiently waiting for a fix from Apple.\n\t\t//        If you do enableBackgroundingOnSocket on the simulator,\n\t\t//        you will simply see an error message from the xmpp stack when it fails to set the property.\n\t\t\n\t\tself.xmppStream.enableBackgroundingOnSocket = YES;\n\t}\n#endif\n\t\n\t// Setup reconnect\n\t// \n\t// The XMPPReconnect module monitors for \"accidental disconnections\" and\n\t// automatically reconnects the stream for you.\n\t// There's a bunch more information in the XMPPReconnect header file.\n\t\n\t_xmppReconnect = [[XMPPReconnect alloc] init];\n\t\n\t// Setup roster\n\t// \n\t// The XMPPRoster handles the xmpp protocol stuff related to the roster.\n\t// The storage for the roster is abstracted.\n\t// So you can use any storage mechanism you want.\n\t// You can store it all in memory, or use core data and store it on disk, or use core data with an in-memory store,\n\t// or setup your own using raw SQLite, or create your own storage mechanism.\n\t// You can do it however you like! It's your application.\n\t// But you do need to provide the roster with some storage facility.\n    \n    //DDLogInfo(@\"Unique Identifier: %@\",self.account.uniqueIdentifier);\n\t\n    OTRYapDatabaseRosterStorage * rosterStorage = [[OTRYapDatabaseRosterStorage alloc] init];\n\t\n\t_xmppRoster = [[XMPPRoster alloc] initWithRosterStorage:rosterStorage];\n\t\n\tself.xmppRoster.autoFetchRoster = YES;\n    self.xmppRoster.autoClearAllUsersAndResources = NO;\n\tself.xmppRoster.autoAcceptKnownPresenceSubscriptionRequests = YES;\n\t\n\t// Setup vCard support\n\t// \n\t// The vCard Avatar module works in conjuction with the standard vCard Temp module to download user avatars.\n\t// The XMPPRoster will automatically integrate with XMPPvCardAvatarModule to cache roster photos in the roster.\n\t\n    OTRvCardYapDatabaseStorage * vCardStorage  = [[OTRvCardYapDatabaseStorage alloc] init];\n\t_xmppvCardTempModule = [[XMPPvCardTempModule alloc] initWithvCardStorage:vCardStorage];\n\t\n\t_xmppvCardAvatarModule = [[XMPPvCardAvatarModule alloc] initWithvCardTempModule:self.xmppvCardTempModule];\n\t\n\t// Setup capabilities\n\t// \n\t// The XMPPCapabilities module handles all the complex hashing of the caps protocol (XEP-0115).\n\t// Basically, when other clients broadcast their presence on the network\n\t// they include information about what capabilities their client supports (audio, video, file transfer, etc).\n\t// But as you can imagine, this list starts to get pretty big.\n\t// This is where the hashing stuff comes into play.\n\t// Most people running the same version of the same client are going to have the same list of capabilities.\n\t// So the protocol defines a standardized way to hash the list of capabilities.\n\t// Clients then broadcast the tiny hash instead of the big list.\n\t// The XMPPCapabilities protocol automatically handles figuring out what these hashes mean,\n\t// and also persistently storing the hashes so lookups aren't needed in the future.\n\t// \n\t// Similarly to the roster, the storage of the module is abstracted.\n\t// You are strongly encouraged to persist caps information across sessions.\n\t// \n\t// The XMPPCapabilitiesCoreDataStorage is an ideal solution.\n\t// It can also be shared amongst multiple streams to further reduce hash lookups.\n\t\n\t_xmppCapabilitiesStorage = [[XMPPCapabilitiesCoreDataStorage alloc] initWithInMemoryStore];\n    _xmppCapabilities = [[XMPPCapabilities alloc] initWithCapabilitiesStorage:self.xmppCapabilitiesStorage];\n    \n    self.xmppCapabilities.autoFetchHashedCapabilities = YES;\n    self.xmppCapabilities.autoFetchNonHashedCapabilities = NO;\n    self.xmppCapabilities.autoFetchMyServerCapabilities = YES;\n    \n    \n\t// Activate xmpp modules\n    \n\t[self.xmppReconnect         activate:self.xmppStream];\n\t[self.xmppRoster            activate:self.xmppStream];\n\t[self.xmppvCardTempModule   activate:self.xmppStream];\n\t[self.xmppvCardAvatarModule activate:self.xmppStream];\n\t[self.xmppCapabilities      activate:self.xmppStream];\n    \n\t// Add ourself as a delegate to anything we may be interested in\n    \n\t[self.xmppStream addDelegate:self delegateQueue:self.workQueue];\n\t[self.xmppRoster addDelegate:self delegateQueue:self.workQueue];\n    [self.xmppCapabilities addDelegate:self delegateQueue:self.workQueue];\n    [self.xmppvCardTempModule addDelegate:self delegateQueue:self.workQueue];\n    \n    // Message Carbons\n    _messageCarbons = [[XMPPMessageCarbons alloc] init];\n    [self.messageCarbons activate:self.xmppStream];\n    \n    // Message storage\n    _messageStorage = [[OTRXMPPMessageYapStroage alloc] initWithDatabaseConnection:self.databaseConnection];\n    [self.messageStorage activate:self.xmppStream];\n    \n    //Stream Management\n    _streamManagementDelegate = [[OTRStreamManagementDelegate alloc] initWithDatabaseConnection:self.databaseConnection];\n    \n    //OTRStreamManagementYapStorage *streamManagementStorage = [[OTRStreamManagementYapStorage alloc] initWithDatabaseConnection:self.databaseConnection];\n    XMPPStreamManagementMemoryStorage *memoryStorage = [[XMPPStreamManagementMemoryStorage alloc] init];\n    _streamManagement = [[XMPPStreamManagement alloc] initWithStorage:memoryStorage];\n    [self.streamManagement addDelegate:self.streamManagementDelegate delegateQueue:self.workQueue];\n    [self.streamManagement automaticallyRequestAcksAfterStanzaCount:10 orTimeout:5];\n    [self.streamManagement automaticallySendAcksAfterStanzaCount:30 orTimeout:5];\n    self.streamManagement.autoResume = YES;\n    [self.streamManagement activate:self.xmppStream];\n    \n    //MUC\n    _roomManager = [[OTRXMPPRoomManager alloc] init];\n    self.roomManager.databaseConnection = [OTRDatabaseManager sharedInstance].readWriteDatabaseConnection;\n    [self.roomManager activate:self.xmppStream];\n    \n    //Buddy Manager (for deleting)\n    _xmppBuddyManager = [[OTRXMPPBuddyManager alloc] init];\n    self.xmppBuddyManager.databaseConnection = [OTRDatabaseManager sharedInstance].longLivedReadOnlyConnection;\n    self.xmppBuddyManager.protocol = self;\n    [self.xmppBuddyManager activate:self.xmppStream];\n    \n    //Message Queue Module\n    MessageQueueHandler *queueHandler = [OTRDatabaseManager sharedInstance].messageQueueHandler;\n    _messageStatusModule = [[OTRXMPPMessageStatusModule alloc] initWithDatabaseConnection:self.databaseConnection delegate:queueHandler];\n    [self.messageStatusModule activate:self.xmppStream];\n    \n    //OMEMO\n    self.omemoSignalCoordinator = [[OTROMEMOSignalCoordinator alloc] initWithAccountYapKey:self.account.uniqueId databaseConnection:self.databaseConnection error:nil];\n    _omemoModule = [[OMEMOModule alloc] initWithOMEMOStorage:self.omemoSignalCoordinator xmlNamespace:OMEMOModuleNamespaceConversationsLegacy];\n    [self.omemoModule addDelegate:self.omemoSignalCoordinator delegateQueue:self.omemoSignalCoordinator.workQueue];\n\n    [self.omemoModule activate:self.xmppStream];\n}\n\n- (void)teardownStream\n{\n    [_xmppStream removeDelegate:self];\n    [_xmppRoster removeDelegate:self];\n    [_xmppCapabilities removeDelegate:self];\n    [_xmppvCardTempModule removeDelegate:self];\n\n    [_xmppReconnect         deactivate];\n    [_xmppRoster            deactivate];\n    [_xmppvCardTempModule   deactivate];\n    [_xmppvCardAvatarModule deactivate];\n    [_xmppCapabilities      deactivate];\n    [_streamManagement      deactivate];\n    [_messageCarbons        deactivate];\n    [_messageStorage        deactivate];\n    [_certificatePinningModule deactivate];\n    [_deliveryReceipts deactivate];\n    [_streamManagement deactivate];\n    [_roomManager deactivate];\n    [_xmppBuddyManager deactivate];\n    [_messageStatusModule deactivate];\n    [_omemoModule deactivate];\n\n    [_xmppStream disconnect];\n}\n\n- (void)goOnline\n{\n    self.connectionStatus = OTRProtocolConnectionStatusConnected;\n    NSString *accountKey = self.account.uniqueId;\n    NSString *accountCollection = [[self.account class] collection];\n    NSDictionary *userInfo = nil;\n    if(accountKey && accountCollection) {\n        userInfo = @{kOTRNotificationAccountUniqueIdKey:accountKey,kOTRNotificationAccountCollectionKey:accountCollection};\n    }\n    [[NSNotificationCenter defaultCenter]\n     postNotificationName:kOTRProtocolLoginSuccess\n     object:self userInfo:userInfo];\n\tXMPPPresence *presence = [XMPPPresence presence]; // type=\"available\" is implicit\n\t\n\t[[self xmppStream] sendElement:presence];\n}\n\n- (void)goOffline\n{\n\tXMPPPresence *presence = [XMPPPresence presenceWithType:@\"unavailable\"];\n\t\n\t[[self xmppStream] sendElement:presence];\n}\n\n- (NSString *)accountDomainWithError:(id)error;\n{\n    return self.account.domain;\n}\n\n- (void)didRegisterNewAccountWithStream:(XMPPStream *)stream\n{\n    self.isRegisteringNewAccount = NO;\n    [self authenticateWithStream:stream];\n    [[NSNotificationCenter defaultCenter] postNotificationName:OTRXMPPRegisterSucceededNotificationName object:self];\n}\n- (void)failedToRegisterNewAccount:(NSError *)error\n{\n    if (error) {\n        [[NSNotificationCenter defaultCenter]\n         postNotificationName:OTRXMPPRegisterFailedNotificationName object:self userInfo:@{kOTRNotificationErrorKey:error}];\n    }\n    else {\n        [[NSNotificationCenter defaultCenter]\n         postNotificationName:OTRXMPPRegisterFailedNotificationName object:self];\n    }\n}\n\n\n- (void)authenticateWithStream:(XMPPStream *)stream {\n    NSError * error = nil;\n    BOOL status = YES;\n    if ([stream supportsXOAuth2GoogleAuthentication] && self.account.accountType == OTRAccountTypeGoogleTalk) {\n        status = [stream authenticateWithGoogleAccessToken:self.account.password error:&error];\n    }\n    else {\n        status = [stream authenticateWithPassword:self.account.password error:&error];\n    }\n}\n\n///////////////////////////////\n#pragma mark Capabilities Collected\n////////////////////////////////////////////\n\n- (NSArray *)myFeaturesForXMPPCapabilities:(XMPPCapabilities *)sender\n{\n    return @[@\"http://jabber.org/protocol/chatstates\"];\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#pragma mark Connect/disconnect\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n- (BOOL)startConnection\n{\n    self.connectionStatus = OTRProtocolConnectionStatusConnecting;\n    \n    XMPPJID *jid = [XMPPJID jidWithString:self.account.username resource:self.account.resource];\n    \n    if (![jid.domain isEqualToString:self.xmppStream.myJID.domain]) {\n        [self.xmppStream disconnect];\n    }\n    self.xmppStream.myJID = jid;\n\tif (![self.xmppStream isDisconnected]) {\n        [self authenticateWithStream:self.xmppStream];\n\t\treturn YES;\n\t}\n    \n\t//\n\t// If you don't want to use the Settings view to set the JID, \n\t// uncomment the section below to hard code a JID and password.\n\t//\n\t// Replace me with the proper JID and password:\n\t//\tmyJID = @\"user@gmail.com/xmppframework\";\n\t//\tmyPassword = @\"\";\n    \n\t\n    \n    \n    NSError * error = nil;\n    NSString * domainString = [self accountDomainWithError:error];\n    if (error) {\n        [self failedToConnect:error];\n        return NO;\n    }\n    if ([domainString length]) {\n        [self.xmppStream setHostName:domainString];\n    }\n    \n    [self.xmppStream setHostPort:self.account.port];\n\t\n    \n\terror = nil;\n\tif (![self.xmppStream connectWithTimeout:XMPPStreamTimeoutNone error:&error])\n\t{\n\t\t[self failedToConnect:error];\n        \n\t\tDDLogError(@\"Error connecting: %@\", error);\n        \n\t\treturn NO;\n\t}\n    \n\treturn YES;\n}\n\n- (void) disconnectSocketOnly:(BOOL)socketOnly {\n    DDLogVerbose(@\"%@: %@ %d\", THIS_FILE, THIS_METHOD, socketOnly);\n    if (socketOnly) {\n        [self.xmppStream disconnect];\n        self.connectionStatus = OTRProtocolConnectionStatusDisconnected;\n        return;\n    }\n    \n    [self goOffline];\n    [self.xmppStream disconnectAfterSending];\n    \n    __weak typeof(self)weakSelf = self;\n    __block NSArray<OTRXMPPBuddy*> *buddiesArray = nil;\n    [self.databaseConnection asyncReadWithBlock:^(YapDatabaseReadTransaction *transaction) {\n        __strong typeof(weakSelf)strongSelf = weakSelf;\n        buddiesArray = [strongSelf.account allBuddiesWithTransaction:transaction];\n    } completionQueue:dispatch_get_main_queue() completionBlock:^{\n        \n        __strong typeof(weakSelf)strongSelf = weakSelf;\n        if([OTRSettingsManager boolForOTRSettingKey:kOTRSettingKeyDeleteOnDisconnect])\n        {\n            [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n                [OTRBaseMessage deleteAllMessagesForAccountId:strongSelf.account.uniqueId transaction:transaction];\n            }];\n        }\n    }];\n}\n\n- (void)disconnect\n{\n    [self disconnectSocketOnly:NO];\n}\n\n- (BOOL)startRegisteringNewAccount\n{\n    self.isRegisteringNewAccount = YES;\n    if (self.xmppStream.isConnected) {\n        [self.xmppStream disconnect];\n        return NO;\n    }\n    \n    return [self startConnection];\n}\n\n- (BOOL)continueRegisteringNewAccount\n{\n    NSError * error = nil;\n    if ([self.xmppStream supportsInBandRegistration]) {\n        [self.xmppStream registerWithPassword:self.account.password error:&error];\n        if (error) {\n            [self failedToRegisterNewAccount:error];\n            return NO;\n        }\n    } else {\n        error = [NSError errorWithDomain:OTRXMPPErrorDomain code:OTRXMPPUnsupportedAction userInfo:nil];\n        [self failedToRegisterNewAccount:error];\n        return NO;\n    }\n    return YES;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#pragma mark XMPPStream Delegate\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n- (void)xmppStreamDidChangeMyJID:(XMPPStream *)stream\n{\n    if (![[stream.myJID bare] isEqualToString:self.account.username] || ![[stream.myJID resource] isEqualToString:self.account.resource])\n    {\n        self.account.username = [stream.myJID bare];\n        self.account.resource = [stream.myJID resource];\n        [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n            [self.account saveWithTransaction:transaction];\n        }];\n    }\n}\n\n- (void)xmppStream:(XMPPStream *)sender socketDidConnect:(GCDAsyncSocket *)socket \n{\n\tDDLogVerbose(@\"%@: %@\", THIS_FILE, THIS_METHOD);\n    [self changeLoginStatus:OTRLoginStatusConnected error:nil];\n}\n\n- (void)xmppStream:(XMPPStream *)sender willSecureWithSettings:(NSMutableDictionary *)settings\n{\n\tDDLogVerbose(@\"%@: %@\", THIS_FILE, THIS_METHOD);\n    \n    settings[GCDAsyncSocketSSLProtocolVersionMin] = @(kTLSProtocol1);\n    settings[GCDAsyncSocketSSLCipherSuites] = [OTRUtilities cipherSuites];\n    settings[GCDAsyncSocketManuallyEvaluateTrust] = @(YES);\n    \n    [self changeLoginStatus:OTRLoginStatusSecuring error:nil];\n}\n\n- (void)xmppStreamDidSecure:(XMPPStream *)sender\n{\n\tDDLogVerbose(@\"%@: %@\", THIS_FILE, THIS_METHOD);\n    \n    [self changeLoginStatus:OTRLoginStatusSecured error:nil];\n}\n\n- (void)xmppStreamDidConnect:(XMPPStream *)sender\n{\n\tDDLogVerbose(@\"%@: %@\", THIS_FILE, THIS_METHOD);\n    \n    if (self.isRegisteringNewAccount) {\n        [self continueRegisteringNewAccount];\n    }\n    else{\n        [self authenticateWithStream:sender];\n    }\n    \n    [self changeLoginStatus:OTRLoginStatusAuthenticating error:nil];\n}\n\n- (void)xmppStreamDidDisconnect:(XMPPStream *)sender withError:(NSError *)error\n{\n    DDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, error);\n    \n    self.connectionStatus = OTRProtocolConnectionStatusDisconnected;\n    \n    [self changeLoginStatus:OTRLoginStatusDisconnected error:error];\n    \n    if (self.loginStatus == OTRLoginStatusDisconnected)\n    {\n        DDLogError(@\"Unable to connect to server. Check xmppStream.hostName\");\n        \n        [self failedToConnect:error];\n    }\n    \n    //Reset buddy info to offline\n    __block NSArray<OTRXMPPBuddy*> *allBuddies = nil;\n    [self.databaseConnection asyncReadWithBlock:^(YapDatabaseReadTransaction *transaction) {\n        allBuddies = [self.account allBuddiesWithTransaction:transaction];\n    } completionBlock:^{\n        // We don't need to save in here because we're using OTRBuddyCache in memory storage\n        if (!self.streamManagementDelegate.streamManagementEnabled) {\n            [[OTRBuddyCache sharedInstance] purgeAllPropertiesForBuddies:allBuddies];\n        }\n    }];\n}\n\n- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender\n{\n\tDDLogVerbose(@\"%@: %@\", THIS_FILE, THIS_METHOD);\n    if ([sender supportsStreamManagement] && ![self.streamManagement didResume]) {\n        [self.streamManagement enableStreamManagementWithResumption:YES maxTimeout:300];\n    }\n    \n    self.connectionStatus = OTRProtocolConnectionStatusConnected;\n\t[self goOnline];\n    \n    \n    [self changeLoginStatus:OTRLoginStatusAuthenticated error:nil];\n    \n    // Refetch capabilities to check for XEP-0357 support\n    [self.xmppCapabilities fetchCapabilitiesForJID:self.xmppStream.myJID.bareJID];\n    \n    // Fetch latest vCard from server so we can update nickname\n    //[self.xmppvCardTempModule fetchvCardTempForJID:self.JID ignoreStorage:YES];\n}\n\n- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error\n{\n\tDDLogVerbose(@\"%@: %@\", THIS_FILE, THIS_METHOD);\n    self.connectionStatus = OTRProtocolConnectionStatusDisconnected;\n    NSError *err = [OTRXMPPError errorForXMLElement:error];\n    [self failedToConnect:err];\n    \n    [self changeLoginStatus:OTRLoginStatusSecured error:err];\n}\n\n- (BOOL)xmppStream:(XMPPStream *)sender didReceiveIQ:(XMPPIQ *)iq\n{\n\tDDLogVerbose(@\"%@: %@ - %@\", THIS_FILE, THIS_METHOD, iq);\n\treturn NO;\n}\n\n- (void)xmppStreamDidRegister:(XMPPStream *)sender {\n    [self didRegisterNewAccountWithStream:sender];\n}\n\n- (void)xmppStream:(XMPPStream *)sender didNotRegister:(NSXMLElement *)xmlError {\n    \n    self.isRegisteringNewAccount = NO;\n    NSError * error = [OTRXMPPError errorForXMLElement:xmlError];\n    [self failedToRegisterNewAccount:error];\n    \n    [self changeLoginStatus:OTRLoginStatusSecured error:error];\n}\n\n-(OTRXMPPBuddy *)buddyWithMessage:(XMPPMessage *)message transaction:(YapDatabaseReadTransaction *)transaction\n{\n    OTRXMPPBuddy *buddy = [OTRXMPPBuddy fetchBuddyWithUsername:[[message from] bare] withAccountUniqueId:self.account.uniqueId transaction:transaction];\n    return buddy;\n}\n\n\n- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)xmppMessage\n{\n\tDDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, xmppMessage);\n}\n\n- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence\n{\n\tDDLogVerbose(@\"%@: %@ - %@\\nType: %@\\nShow: %@\\nStatus: %@\", THIS_FILE, THIS_METHOD, [presence from], [presence type], [presence show],[presence status]);\n}\n\n- (void)xmppStream:(XMPPStream *)sender didReceiveError:(id)error\n{\n\tDDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, error);\n}\n\n- (void)xmppStream:(XMPPStream *)sender didFailToSendIQ:(XMPPIQ *)iq error:(NSError *)error\n{\n    DDLogVerbose(@\"%@: %@ %@ %@\", THIS_FILE, THIS_METHOD, iq, error);\n}\n\n- (void)xmppStream:(XMPPStream *)sender didFailToSendMessage:(XMPPMessage *)message error:(NSError *)error\n{\n    DDLogVerbose(@\"%@: %@ %@ %@\", THIS_FILE, THIS_METHOD, message, error);\n    if (![message.elementID length]) {\n        return;\n    }\n    [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n        [transaction enumerateMessagesWithId:message.elementID block:^(id<OTRMessageProtocol> _Nonnull databaseMessage, BOOL * _Null_unspecified stop) {\n            if ([databaseMessage isKindOfClass:[OTRBaseMessage class]]) {\n                ((OTRBaseMessage *)databaseMessage).error = error;\n                [(OTRBaseMessage *)databaseMessage saveWithTransaction:transaction];\n                *stop = YES;\n            }\n        }];\n    }];\n}\n- (void)xmppStream:(XMPPStream *)sender didFailToSendPresence:(XMPPPresence *)presence error:(NSError *)error\n{\n    DDLogVerbose(@\"%@: %@ %@ %@\", THIS_FILE, THIS_METHOD, presence, error);\n}\n\n#pragma mark XMPPvCardTempModuleDelegate\n\n- (void)xmppvCardTempModule:(XMPPvCardTempModule *)vCardTempModule\n        didReceivevCardTemp:(XMPPvCardTemp *)vCardTemp\n                     forJID:(XMPPJID *)jid {\n    DDLogVerbose(@\"%@: %@ %@ %@ %@\", THIS_FILE, THIS_METHOD, vCardTempModule, vCardTemp, jid);\n    \n    // update my vCard to local nickname setting\n    // currently this will clobber whatever you have on the server\n    if ([self.xmppStream.myJID isEqualToJID:jid options:XMPPJIDCompareBare]) {\n        if (self.account.displayName.length &&\n            vCardTemp.nickname.length &&\n            ![vCardTemp.nickname isEqualToString:self.account.displayName]) {\n            vCardTemp.nickname = self.account.displayName;\n            [vCardTempModule updateMyvCardTemp:vCardTemp];\n        } else if (vCardTemp.nickname.length) {\n            [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction * _Nonnull transaction) {\n                NSString *collection = [self.account.class collection];\n                NSString *key = self.account.uniqueId;\n                OTRXMPPAccount *account = [[transaction objectForKey:key inCollection:collection] copy];\n                account.displayName = vCardTemp.nickname;\n                [transaction setObject:account forKey:key inCollection:collection];\n            }];\n        }\n    } else {\n        // this is someone elses vCard\n        DDLogVerbose(@\"%@: other's vCard %@ %@ %@ %@\", THIS_FILE, THIS_METHOD, vCardTempModule, vCardTemp, jid);\n    }\n}\n\n- (void)xmppvCardTempModule:(XMPPvCardTempModule *)vCardTempModule\n   failedToFetchvCardForJID:(XMPPJID *)jid\n                      error:(NSXMLElement*)error {\n    DDLogVerbose(@\"%@: %@ %@ %@ %@\", THIS_FILE, THIS_METHOD, vCardTempModule, jid, error);\n    \n    // update my vCard to local nickname setting\n    if ([self.xmppStream.myJID isEqualToJID:jid options:XMPPJIDCompareBare] &&\n        self.account.displayName.length) {\n        XMPPvCardTemp *vCardTemp = [XMPPvCardTemp vCardTemp];\n        vCardTemp.nickname = self.account.displayName;\n        [vCardTempModule updateMyvCardTemp:vCardTemp];\n    }\n}\n\n- (void)xmppvCardTempModuleDidUpdateMyvCard:(XMPPvCardTempModule *)vCardTempModule {\n    DDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, vCardTempModule);\n}\n\n- (void)xmppvCardTempModule:(XMPPvCardTempModule *)vCardTempModule failedToUpdateMyvCard:(NSXMLElement *)error {\n    DDLogVerbose(@\"%@: %@ %@ %@\", THIS_FILE, THIS_METHOD, vCardTempModule, error);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#pragma mark XMPPRosterDelegate\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n- (void)xmppRoster:(XMPPRoster *)sender didReceiveRosterItem:(NSXMLElement *)item {\n    DDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, item);\n\n    // Because XMPP sucks, there's no way to know if a vCard has changed without fetching all of them again\n    // To preserve user mobile data, just fetch each vCard once, only if it's never been fetched\n    // Otherwise you'll only receive vCard updates if someone updates their avatar\n    NSString *jidStr = [item attributeStringValueForName:@\"jid\"];\n    XMPPJID *jid = [[XMPPJID jidWithString:jidStr] bareJID];\n    __block OTRXMPPBuddy *buddy = nil;\n    [[OTRDatabaseManager sharedInstance].readOnlyDatabaseConnection asyncReadWithBlock:^(YapDatabaseReadTransaction * _Nonnull transaction) {\n        buddy = [OTRXMPPBuddy fetchBuddyWithUsername:[jid bare] withAccountUniqueId:self.account.uniqueId transaction:transaction];\n    } completionQueue:self.workQueue completionBlock:^{\n        if (!buddy) { return; }\n        XMPPvCardTemp *vCard = [self.xmppvCardTempModule vCardTempForJID:jid shouldFetch:YES];\n        if (!vCard) { return; }\n        buddy = [buddy copy];\n        buddy.vCardTemp = vCard;\n        [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction * _Nonnull transaction) {\n            [buddy saveWithTransaction:transaction];\n        }];\n    }];\n}\n\n-(void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence\n{\n    DDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, presence);\n    \n\tNSString *jidStrBare = [presence fromStr];\n    \n    [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n        OTRXMPPPresenceSubscriptionRequest *request = [OTRXMPPPresenceSubscriptionRequest fetchPresenceSubscriptionRequestWithJID:jidStrBare accontUniqueId:self.account.uniqueId transaction:transaction];\n        if (!request) {\n            request = [[OTRXMPPPresenceSubscriptionRequest alloc] init];\n        }\n        \n        request.jid = jidStrBare;\n        request.accountUniqueId = self.account.uniqueId;\n        \n        [request saveWithTransaction:transaction];\n    }];\n}\n\n- (void)xmppRoster:(XMPPRoster *)sender didReceiveRosterPush:(XMPPIQ *)iq\n{\n    DDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, iq);\n    //verry unclear what this delegate call is supposed to do with jabber.ccc.de it seems to have all the subscription=both,none and jid\n    /*\n    if ([iq isSetIQ] && [[[[[[iq elementsForName:@\"query\"] firstObject] elementsForName:@\"item\"] firstObject] attributeStringValueForName:@\"subscription\"] isEqualToString:@\"from\"]) {\n        NSString *jidString = [[[[[iq elementsForName:@\"query\"] firstObject] elementsForName:@\"item\"] firstObject] attributeStringValueForName:@\"jid\"];\n        \n        [self.databaseConnection readWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n            OTRXMPPPresenceSubscriptionRequest *request = [OTRXMPPPresenceSubscriptionRequest fetchPresenceSubscriptionRequestWithJID:jidString accontUniqueId:self.account.uniqueId transaction:transaction];\n            if (!request) {\n                request = [[OTRXMPPPresenceSubscriptionRequest alloc] init];\n            }\n            \n            request.jid = jidString;\n            request.accountUniqueId = self.account.uniqueId;\n            \n            [transaction setObject:request forKey:request.uniqueId inCollection:[OTRXMPPPresenceSubscriptionRequest collection]];\n        }];\n    }\n    else if ([iq isSetIQ] && [[[[[[iq elementsForName:@\"query\"] firstObject] elementsForName:@\"item\"] firstObject] attributeStringValueForName:@\"subscription\"] isEqualToString:@\"none\"])\n    {\n        [self.databaseConnection readWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n            NSString *jidString = [[[[[iq elementsForName:@\"query\"] firstObject] elementsForName:@\"item\"] firstObject] attributeStringValueForName:@\"jid\"];\n            \n            OTRXMPPBuddy *buddy = [[OTRXMPPBuddy fetchBuddyWithUsername:jidString withAccountUniqueId:self.account.uniqueId transaction:transaction] copy];\n            buddy.pendingApproval = YES;\n            [buddy saveWithTransaction:transaction];\n        }];\n    }\n    \n    */\n    \n    \n}\n\n#pragma mark XMPPCapabilitiesDelegate\n\n- (void)xmppCapabilities:(XMPPCapabilities *)sender didDiscoverCapabilities:(NSXMLElement *)caps forJID:(XMPPJID *)jid {\n    DDLogVerbose(@\"%@: %@\\n%@:%@\", THIS_FILE, THIS_METHOD, jid, caps);\n    \n    // Enable XEP-0357 push bridge if server supports it\n    // ..but don't register for Tor accounts\n    if (self.account.accountType == OTRAccountTypeXMPPTor) {\n        return;\n    }\n    \n    NSString *myDomain = [self.xmppStream.myJID domain];\n    if ([[jid bare] isEqualToString:[jid domain]]) {\n        if (![[jid domain] isEqualToString:myDomain]) {\n            // You're checking the server's capabilities but it's not your server(?)\n            return;\n        }\n    } else {\n        if (![[self.xmppStream.myJID bare] isEqualToString:[jid bare]]) {\n            // You're checking someone else's capabilities\n            return;\n        }\n    }\n    __block BOOL supportsPushXEP = NO;\n    NSArray <NSXMLElement*> *featureElements = [caps elementsForName:@\"feature\"];\n    [featureElements enumerateObjectsUsingBlock:^(NSXMLElement * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        NSString *featureName = [obj attributeStringValueForName:@\"var\"];\n        if ([featureName isEqualToString:XMPPPushXMLNS]){\n            supportsPushXEP = YES;\n            *stop = YES;\n        }\n    }];\n    BOOL hasPushAccount = [[OTRProtocolManager sharedInstance].pushController.pushStorage hasPushAccount];\n    \n    if (supportsPushXEP && hasPushAccount) {\n        [[OTRProtocolManager sharedInstance].pushController getPubsubEndpoint:^(NSString * _Nullable endpoint, NSError * _Nullable error) {\n            if (endpoint) {\n                [[OTRProtocolManager sharedInstance].pushController getNewPushToken:nil completion:^(TokenContainer * _Nullable token, NSError * _Nullable error) {\n                    if (token) {\n                        [self enablePushWithToken:token endpoint:endpoint];\n                    } else if (error) {\n                        DDLogError(@\"fetch token error: %@\", error);\n                    }\n                }];\n            } else if (error) {\n                DDLogError(@\"357 pubsub Error: %@\", error);\n            }\n        }];\n    }\n}\n\n- (void) enablePushWithToken:(TokenContainer*)token endpoint:(NSString*)endpoint {\n    __block OTRXMPPAccount *account = nil;\n    [self.databaseConnection readWriteWithBlock:^(YapDatabaseReadWriteTransaction * _Nonnull transaction) {\n        NSString *collection = [self.account.class collection];\n        NSString *key = self.account.uniqueId;\n        account = [[transaction objectForKey:key inCollection:collection] copy];\n        account.pushPubsubEndpoint = endpoint;\n        if (!account.pushPubsubNode.length) {\n            account.pushPubsubNode = [[NSUUID UUID] UUIDString];\n        }\n        [transaction setObject:account forKey:key inCollection:collection];\n    }];\n    XMPPJID *nodeJID = [XMPPJID jidWithString:endpoint]; \n    NSString *tokenString = token.pushToken.tokenString;\n    if (tokenString.length > 0) {\n        NSString *pushEndpointURLString = [[OTRProtocolManager sharedInstance].pushController getMessagesEndpoint].absoluteString;\n        NSMutableDictionary *options = [NSMutableDictionary dictionary];\n        [options setObject:tokenString forKey:@\"token\"];\n        if (pushEndpointURLString) {\n            [options setObject:pushEndpointURLString forKey:@\"endpoint\"];\n        }\n        XMPPIQ *enableElement = [XMPPIQ enableNotificationsElementWithJID:nodeJID node:account.pushPubsubNode options:options];\n        [self.xmppStream sendElement:enableElement];\n    } else {\n        DDLogError(@\"Token string length 0!\");\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#pragma mark OTRProtocol\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n- (void) sendMessage:(OTROutgoingMessage*)message\n{\n    NSString *text = message.text;\n    \n    __block OTRBuddy *buddy = nil;\n    [[OTRDatabaseManager sharedInstance].readOnlyDatabaseConnection readWithBlock:^(YapDatabaseReadTransaction *transaction) {\n        buddy = (OTRBuddy *)[message threadOwnerWithTransaction:transaction];\n    }];\n    \n    [self invalidatePausedChatStateTimerForBuddyUniqueId:buddy.uniqueId];\n    \n    if ([text length])\n    {\n        NSString * messageID = message.messageId;\n        XMPPMessage * xmppMessage = [XMPPMessage messageWithType:@\"chat\" to:[XMPPJID jidWithString:buddy.username] elementID:messageID];\n        [xmppMessage addBody:text];\n\n        [xmppMessage addActiveChatState];\n        \n        if ([OTRKit stringStartsWithOTRPrefix:text]) {\n            [xmppMessage addPrivateMessageCarbons];\n            [xmppMessage addStorageHint:XMPPMessageStorageNoCopy];\n            [xmppMessage addStorageHint:XMPPMessageStorageNoPermanentStore];\n        }\n\t\t\n\t\t[self.xmppStream sendElement:xmppMessage];\n    }\n}\n\n- (NSString*) type {\n    return kOTRProtocolTypeXMPP;\n}\n\n- (void) connectUserInitiated:(BOOL)userInitiated\n{\n    // Don't issue a reconnect if we're already connected and authenticated\n    if ([self.xmppStream isConnected] && [self.xmppStream isAuthenticated]) {\n        return;\n    }\n    self.userInitiatedConnection = userInitiated;\n    [self startConnection];\n    if (self.userInitiatedConnection) {\n        [[OTRNotificationController sharedInstance] showAccountConnectingNotificationWithAccountName:self.account.username];\n    }\n}\n\n-(void)connect\n{\n    [self connectUserInitiated:NO];\n}\n\n-(void)sendChatState:(OTRChatState)chatState withBuddyID:(NSString *)buddyUniqueId\n{\n    \n    \n    dispatch_async(self.workQueue, ^{\n        \n        __block OTRXMPPBuddy *buddy = nil;\n        [[OTRDatabaseManager sharedInstance].readOnlyDatabaseConnection readWithBlock:^(YapDatabaseReadTransaction *transaction) {\n            buddy = [OTRXMPPBuddy fetchObjectWithUniqueID:buddyUniqueId transaction:transaction];\n        }];\n        \n        if (buddy.lastSentChatState == chatState) {\n            return;\n        }\n        \n        XMPPMessage * xMessage = [[XMPPMessage alloc] initWithType:@\"chat\" to:[XMPPJID jidWithString:buddy.username]];\n        BOOL shouldSend = YES;\n        \n        if (chatState == OTRChatStateActive) {\n            //Timers\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [[self pausedChatStateTimerForBuddyObjectID:buddyUniqueId] invalidate];\n                [self restartInactiveChatStateTimerForBuddyObjectID:buddyUniqueId];\n            });\n            \n            [xMessage addActiveChatState];\n        }\n        else if (chatState == OTRChatStateComposing)\n        {\n            if(buddy.lastSentChatState !=OTRChatStateComposing)\n                [xMessage addComposingChatState];\n            else\n                shouldSend = NO;\n            \n            //Timers\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [self restartPausedChatStateTimerForBuddyObjectID:buddy.uniqueId];\n                [[self inactiveChatStateTimerForBuddyObjectID:buddy.uniqueId] invalidate];\n            });\n        }\n        else if(chatState == OTRChatStateInactive)\n        {\n            if(buddy.lastSentChatState != OTRChatStateInactive)\n                [xMessage addInactiveChatState];\n            else\n                shouldSend = NO;\n        }\n        else if (chatState == OTRChatStatePaused)\n        {\n            [xMessage addPausedChatState];\n        }\n        else if (chatState == OTRChatStateGone)\n        {\n            [xMessage addGoneChatState];\n        }\n        else\n        {\n            shouldSend = NO;\n        }\n        \n        if(shouldSend)\n        {\n            [[OTRBuddyCache sharedInstance] setLastSentChatState:chatState forBuddy:buddy];\n            [self.xmppStream sendElement:xMessage];\n        }\n    });\n}\n\n- (void) addBuddy:(OTRXMPPBuddy *)newBuddy\n{\n    XMPPJID * newJID = [XMPPJID jidWithString:newBuddy.username];\n    [self.xmppRoster addUser:newJID withNickname:newBuddy.displayName];\n}\n- (void) setDisplayName:(NSString *) newDisplayName forBuddy:(OTRXMPPBuddy *)buddy\n{\n    XMPPJID * jid = [XMPPJID jidWithString:buddy.username];\n    [self.xmppRoster setNickname:newDisplayName forUser:jid];\n    \n}\n-(void)removeBuddies:(NSArray *)buddies\n{\n    for (OTRXMPPBuddy *buddy in buddies){\n        XMPPJID * jid = [XMPPJID jidWithString:buddy.username];\n        [self.xmppRoster removeUser:jid];\n    }\n    \n    \n    [[OTRDatabaseManager sharedInstance].readWriteDatabaseConnection readWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n        [transaction removeObjectsForKeys:[buddies valueForKey:NSStringFromSelector(@selector(uniqueId))] inCollection:[OTRXMPPBuddy collection]];\n    }];\n\n\n\n}\n-(void)blockBuddies:(NSArray *)buddies\n{\n    for (OTRXMPPBuddy *buddy in buddies){\n        XMPPJID * jid = [XMPPJID jidWithString:buddy.username];\n        [self.xmppRoster revokePresencePermissionFromUser:jid];\n    }\n}\n\n//Chat State\n\n-(OTRXMPPBuddyTimers *)buddyTimersForBuddyObjectID:(NSString *)\nmanagedBuddyObjectID\n{\n    OTRXMPPBuddyTimers * timers = [self.buddyTimers objectForKey:managedBuddyObjectID];\n    return timers;\n}\n\n-(NSTimer *)inactiveChatStateTimerForBuddyObjectID:(NSString *)\nmanagedBuddyObjectID\n{\n   return [self buddyTimersForBuddyObjectID:managedBuddyObjectID].inactiveChatStateTimer;\n    \n}\n-(NSTimer *)pausedChatStateTimerForBuddyObjectID:(NSString *)\nmanagedBuddyObjectID\n{\n    return [self buddyTimersForBuddyObjectID:managedBuddyObjectID].pausedChatStateTimer;\n}\n\n-(void)restartPausedChatStateTimerForBuddyObjectID:(NSString *)managedBuddyObjectID\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        OTRXMPPBuddyTimers * timer = [self.buddyTimers objectForKey:managedBuddyObjectID];\n        if(!timer)\n        {\n            timer = [[OTRXMPPBuddyTimers alloc] init];\n        }\n        [timer.pausedChatStateTimer invalidate];\n        timer.pausedChatStateTimer = [NSTimer scheduledTimerWithTimeInterval:kOTRChatStatePausedTimeout target:self selector:@selector(sendPausedChatState:) userInfo:managedBuddyObjectID repeats:NO];\n        [self.buddyTimers setObject:timer forKey:managedBuddyObjectID];\n    });\n    \n}\n-(void)restartInactiveChatStateTimerForBuddyObjectID:(NSString *)managedBuddyObjectID\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        OTRXMPPBuddyTimers * timer = [self.buddyTimers objectForKey:managedBuddyObjectID];\n        if(!timer)\n        {\n            timer = [[OTRXMPPBuddyTimers alloc] init];\n        }\n        [timer.inactiveChatStateTimer invalidate];\n        timer.inactiveChatStateTimer = [NSTimer scheduledTimerWithTimeInterval:kOTRChatStateInactiveTimeout target:self selector:@selector(sendInactiveChatState:) userInfo:managedBuddyObjectID repeats:NO];\n        [self.buddyTimers setObject:timer forKey:managedBuddyObjectID];\n    });\n}\n-(void)sendPausedChatState:(NSTimer *)timer\n{\n    NSString * managedBuddyObjectID= (NSString *)timer.userInfo;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [timer invalidate];\n    });\n    [self sendChatState:OTRChatStatePaused withBuddyID:managedBuddyObjectID];\n}\n-(void)sendInactiveChatState:(NSTimer *)timer\n{\n    NSString *managedBuddyObjectID= (NSString *)timer.userInfo;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [timer invalidate];\n    });\n    \n    [self sendChatState:OTRChatStateInactive withBuddyID:managedBuddyObjectID];\n}\n\n- (void)invalidatePausedChatStateTimerForBuddyUniqueId:(NSString *)buddyUniqueId\n{\n    [[self pausedChatStateTimerForBuddyObjectID:buddyUniqueId] invalidate];\n}\n\n- (void)failedToConnect:(NSError *)error\n{\n    __weak typeof(self)weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        __strong typeof(weakSelf)strongSelf = weakSelf;\n        \n        NSMutableDictionary *userInfo = [@{kOTRProtocolLoginUserInitiated : @(self.userInitiatedConnection)} mutableCopy];\n        if (error) {\n            [userInfo setObject:error forKey:kOTRNotificationErrorKey];\n        }\n        \n        [[NSNotificationCenter defaultCenter] postNotificationName:kOTRProtocolLoginFail object:self userInfo:userInfo];\n        //Only user initiated on the first time any subsequent attempts will not be from user\n        strongSelf.userInitiatedConnection = NO;\n    });\n}\n\n- (OTRCertificatePinning *)certificatePinningModule\n{\n    if(!_certificatePinningModule){\n        _certificatePinningModule = [OTRCertificatePinning defaultCertificates];\n        _certificatePinningModule.delegate = self;\n    }\n    return _certificatePinningModule;\n}\n\n- (void)newTrust:(SecTrustRef)trust withHostName:(NSString *)hostname systemTrustResult:(SecTrustResultType)trustResultType\n{\n    NSData * certifcateData = [OTRCertificatePinning dataForCertificate:[OTRCertificatePinning certForTrust:trust]];\n    DDLogVerbose(@\"New trustResultType: %d certLength: %d\", (int)trustResultType, (int)certifcateData.length);\n    NSError *error = [OTRXMPPError errorForTrustResult:trustResultType withCertData:certifcateData hostname:hostname];\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self failedToConnect:error];\n    });\n    \n    [self changeLoginStatus:OTRLoginStatusDisconnected error:error];\n}\n\n- (void)changeLoginStatus:(OTRLoginStatus)status error:(NSError *)error\n{\n    OTRLoginStatus oldStatus = self.loginStatus;\n    OTRLoginStatus newStatus = status;\n    self.loginStatus = status;\n    \n    NSMutableDictionary *userInfo = [@{OTRXMPPOldLoginStatusKey: @(oldStatus), OTRXMPPNewLoginStatusKey: @(newStatus)} mutableCopy];\n    \n    if (error) {\n        userInfo[OTRXMPPLoginErrorKey] = error;\n    }\n    \n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[NSNotificationCenter defaultCenter] postNotificationName:OTRXMPPLoginStatusNotificationName object:self userInfo:userInfo];\n    });\n}\n\n// Delivery receipts\n- (void) sendDeliveryReceiptForMessage:(OTRIncomingMessage*)message {\n    [[OTRDatabaseManager sharedInstance].readOnlyDatabaseConnection asyncReadWithBlock:^(YapDatabaseReadTransaction * _Nonnull transaction) {\n        OTRBuddy *buddy = [OTRBuddy fetchObjectWithUniqueID:message.buddyUniqueId transaction:transaction];        \n        XMPPMessage *tempMessage = [XMPPMessage messageWithType:@\"chat\" elementID:message.messageId];\n        [tempMessage addAttributeWithName:@\"from\" stringValue:buddy.username];\n        XMPPMessage *receiptMessage = [tempMessage generateReceiptResponse];\n        [self.xmppStream sendElement:receiptMessage];\n    }];\n}\n\n@end\n", "//\n//  OTRXMPPMessageYapStroage.h\n//  ChatSecure\n//\n//  Created by David Chiles on 8/13/15.\n//  Copyright (c) 2015 Chris Ballinger. All rights reserved.\n//\n\n@import XMPPFramework;\n@import YapDatabase;\n@class XMPPMessage;\n\nNS_ASSUME_NONNULL_BEGIN\n@interface OTRXMPPMessageYapStroage : XMPPModule\n\n@property (nonatomic, strong, readonly) YapDatabaseConnection *databaseConnection;\n\n/** This connection is only used for readWrites */\n- (instancetype)initWithDatabaseConnection:(YapDatabaseConnection *)databaseConnection;\n\n@end\nNS_ASSUME_NONNULL_END\n", "//\n//  OTRXMPPMessageYapStroage.m\n//  ChatSecure\n//\n//  Created by David Chiles on 8/13/15.\n//  Copyright (c) 2015 Chris Ballinger. All rights reserved.\n//\n\n#import \"OTRXMPPMessageYapStroage.h\"\n@import XMPPFramework;\n#import \"OTRLog.h\"\n@import OTRKit;\n#import \"OTRXMPPBuddy.h\"\n#import \"OTRIncomingMessage.h\"\n#import \"OTROutgoingMessage.h\"\n#import \"OTRAccount.h\"\n#import \"OTRConstants.h\"\n#import <ChatSecureCore/ChatSecureCore-Swift.h>\n#import \"OTRThreadOwner.h\"\n#import \"OTRBuddyCache.h\"\n\n@implementation OTRXMPPMessageYapStroage\n\n- (instancetype)initWithDatabaseConnection:(YapDatabaseConnection *)connection\n{\n    if (self = [self init]) {\n        _databaseConnection = connection;\n    }\n    return self;\n}\n\n- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)xmppMessage\n{\n    [self storeMessage:xmppMessage stream:sender incoming:YES];\n}\n\n- (void)storeMessage:(XMPPMessage *)xmppMessage stream:(XMPPStream *)stream incoming:(BOOL)incoming\n{\n    if ([xmppMessage isMessageCarbon]) {\n        [self handleCarbonMessage:xmppMessage stream:stream];\n    } else {\n        [self handleMessage:xmppMessage stream:stream incoming:incoming];\n    }\n}\n\n- (OTRXMPPBuddy *)buddyForUsername:(NSString *)username stream:(XMPPStream *)stream transaction:(YapDatabaseReadTransaction *)transaction\n{\n    return [OTRXMPPBuddy fetchBuddyWithUsername:username withAccountUniqueId:stream.tag transaction:transaction];\n}\n\n- (OTRBaseMessage *)baseMessageFromXMPPMessage:(XMPPMessage *)xmppMessage buddyId:(NSString *)buddyId class:(Class)class {\n    NSString *body = [xmppMessage body];\n    \n    NSDate * date = [xmppMessage delayedDeliveryDate];\n    \n    OTRBaseMessage *message = [[class alloc] init];\n    message.text = body;\n    message.buddyUniqueId = buddyId;\n    if (date) {\n        message.date = date;\n    }\n    \n    message.messageId = [xmppMessage elementID];\n    return message;\n}\n\n- (OTROutgoingMessage *)outgoingMessageFromXMPPMessage:(XMPPMessage *)xmppMessage buddyId:(NSString *)buddyId {\n    OTROutgoingMessage *outgoingMessage = (OTROutgoingMessage *)[self baseMessageFromXMPPMessage:xmppMessage buddyId:buddyId class:[OTROutgoingMessage class]];\n    // Fill in current data so it looks like this 'outgoing' message was really sent (but of course this is a message we received through carbons).\n    outgoingMessage.dateSent = [NSDate date];\n    return outgoingMessage;\n}\n\n- (OTRIncomingMessage *)incomingMessageFromXMPPMessage:(XMPPMessage *)xmppMessage buddyId:(NSString *)buddyId\n{\n    return (OTRIncomingMessage *)[self baseMessageFromXMPPMessage:xmppMessage buddyId:buddyId class:[OTRIncomingMessage class]];\n}\n\n- (void)handleMessage:(XMPPMessage *)xmppMessage stream:(XMPPStream *)stream incoming:(BOOL)incoming;\n{\n    // We don't handle incoming group chat messages here\n    // Check out OTRXMPPRoomYapStorage instead\n    if ([[xmppMessage type] isEqualToString:@\"groupchat\"] ||\n        [xmppMessage elementForName:@\"x\" xmlns:XMPPMUCUserNamespace] ||\n        [xmppMessage elementForName:@\"x\" xmlns:@\"jabber:x:conference\"]) {\n        return;\n    }\n    \n    [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n        if ([stream.tag isKindOfClass:[NSString class]]) {\n            NSString *username = [[xmppMessage from] bare];\n            \n            [self handleChatState:xmppMessage username:username stream:stream transaction:transaction];\n            [self handleDeliverResponse:xmppMessage transaction:transaction];\n            \n            OTRXMPPBuddy *messageBuddy = [OTRXMPPBuddy fetchBuddyWithUsername:username withAccountUniqueId:stream.tag transaction:transaction];\n            if (!messageBuddy) {\n                // message from server\n                DDLogWarn(@\"No buddy for message: %@\", xmppMessage);\n                return;\n            }\n            \n            OTRIncomingMessage *message = [self incomingMessageFromXMPPMessage:xmppMessage buddyId:messageBuddy.uniqueId];\n            NSString *activeThreadYapKey = [[OTRAppDelegate appDelegate] activeThreadYapKey];\n            if([activeThreadYapKey isEqualToString:message.threadId]) {\n                message.read = YES;\n            }\n            OTRAccount *account = [OTRAccount fetchObjectWithUniqueID:xmppStream.tag transaction:transaction];\n            \n            \n            if ([xmppMessage isErrorMessage]) {\n                NSError *error = [xmppMessage errorMessage];\n                message.error = error;\n                NSString *errorText = [[xmppMessage elementForName:@\"error\"] elementForName:@\"text\"].stringValue;\n                if (!message.text) {\n                    if (errorText) {\n                        message.text = errorText;\n                    } else {\n                        message.text = error.localizedDescription;\n                    }\n                }\n                if ([errorText containsString:@\"OTR Error\"]) {\n                    // automatically renegotiate a new session when there's an error\n                    [[OTRProtocolManager sharedInstance].encryptionManager.otrKit initiateEncryptionWithUsername:username accountName:account.username protocol:account.protocolTypeString];\n                }\n                // Suppress error messages for now...\n                // [message saveWithTransaction:transaction];\n                return;\n            }\n            \n            if ([self duplicateMessage:xmppMessage buddyUniqueId:messageBuddy.uniqueId transaction:transaction]) {\n                DDLogWarn(@\"Duplicate message received: %@\", xmppMessage);\n                return;\n            }\n            \n            if (message.text) {\n                [[OTRProtocolManager sharedInstance].encryptionManager.otrKit decodeMessage:message.text username:messageBuddy.username accountName:account.username protocol:kOTRProtocolTypeXMPP tag:message];\n            }\n        }\n    }];\n}\n\n- (void)handleChatState:(XMPPMessage *)xmppMessage username:(NSString *)username stream:(XMPPStream *)stream transaction:(YapDatabaseReadTransaction *)transaction\n{\n    // Saves aren't needed when setting chatState or status because OTRBuddyCache is used internally\n\n    OTRXMPPBuddy *messageBuddy = [OTRXMPPBuddy fetchBuddyWithUsername:username withAccountUniqueId:stream.tag transaction:transaction];\n    if (!messageBuddy) { return; }\n    OTRChatState chatState = OTRChatStateUnknown;\n    if([xmppMessage hasChatState])\n    {\n        if([xmppMessage hasComposingChatState])\n            chatState = OTRChatStateComposing;\n        else if([xmppMessage hasPausedChatState])\n            chatState = OTRChatStatePaused;\n        else if([xmppMessage hasActiveChatState])\n            chatState = OTRChatStateActive;\n        else if([xmppMessage hasInactiveChatState])\n            chatState = OTRChatStateInactive;\n        else if([xmppMessage hasGoneChatState])\n            chatState = OTRChatStateGone;\n    }\n    [[OTRBuddyCache sharedInstance] setChatState:chatState forBuddy:messageBuddy];\n}\n\n- (void)handleDeliverResponse:(XMPPMessage *)xmppMessage transaction:(YapDatabaseReadWriteTransaction *)transaction\n{\n    if ([xmppMessage hasReceiptResponse] && ![xmppMessage isErrorMessage]) {\n        [OTROutgoingMessage receivedDeliveryReceiptForMessageId:[xmppMessage receiptResponseID] transaction:transaction];\n    }\n}\n\n- (BOOL)duplicateMessage:(XMPPMessage *)message buddyUniqueId:(NSString *)buddyUniqueId transaction:(YapDatabaseReadWriteTransaction *)transaction\n{\n    __block BOOL result = NO;\n    if ([message.elementID length]) {\n        [transaction enumerateMessagesWithId:message.elementID block:^(id<OTRMessageProtocol> _Nonnull databaseMessage, BOOL * _Null_unspecified stop) {\n            if ([[databaseMessage threadId] isEqualToString:buddyUniqueId]) {\n                *stop = YES;\n                result = YES;\n            }\n        }];\n    }\n    return result;\n}\n\n- (void)handleCarbonMessage:(XMPPMessage *)xmppMessage stream:(XMPPStream *)stream\n{\n    //Sent Message Carbons are sent by our account to another\n    //So from is our JID and to is buddy\n    BOOL incoming = NO;\n    XMPPMessage *forwardedMessage = [xmppMessage messageCarbonForwardedMessage];\n    \n    \n    NSString *username = nil;\n    if ([xmppMessage isReceivedMessageCarbon]) {\n        username = [[forwardedMessage from] bare];\n        incoming = YES;\n    } else {\n        username = [[forwardedMessage to] bare];\n    }\n    \n    [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction * __nonnull transaction) {\n        \n        OTRXMPPBuddy *buddy = [OTRXMPPBuddy fetchBuddyForUsername:username accountName:stream.tag transaction:transaction];\n        \n        if (!buddy) {\n            return;\n        }\n        if (![self duplicateMessage:forwardedMessage buddyUniqueId:buddy.uniqueId transaction:transaction]) {\n            if (incoming) {\n                [self handleChatState:forwardedMessage username:username stream:stream transaction:transaction];\n                [self handleDeliverResponse:forwardedMessage transaction:transaction];\n            }\n            \n            if ([forwardedMessage isMessageWithBody] && ![forwardedMessage isErrorMessage] && ![OTRKit stringStartsWithOTRPrefix:forwardedMessage.body]) {\n                if (incoming) {\n                    OTRIncomingMessage *message = [self incomingMessageFromXMPPMessage:forwardedMessage buddyId:buddy.uniqueId];\n                    NSString *activeThreadYapKey = [[OTRAppDelegate appDelegate] activeThreadYapKey];\n                    if([activeThreadYapKey isEqualToString:message.threadId]) {\n                        message.read = YES;\n                    }\n                    [message saveWithTransaction:transaction];\n                } else {\n                    OTROutgoingMessage *message = [self outgoingMessageFromXMPPMessage:forwardedMessage buddyId:buddy.uniqueId];\n                    [message saveWithTransaction:transaction];\n                }\n            }\n        }\n    }];\n}\n\n@end\n"], "fixing_code": ["//\n//  OTRXMPPManager.m\n//  Off the Record\n//\n//  Created by Chris Ballinger on 9/7/11.\n//  Copyright (c) 2011 Chris Ballinger. All rights reserved.\n//\n//  This file is part of ChatSecure.\n//\n//  ChatSecure is free software: you can redistribute it and/or modify\n//  it under the terms of the GNU General Public License as published by\n//  the Free Software Foundation, either version 3 of the License, or\n//  (at your option) any later version.\n//\n//  ChatSecure is distributed in the hope that it will be useful,\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//  GNU General Public License for more details.\n//\n//  You should have received a copy of the GNU General Public License\n//  along with ChatSecure.  If not, see <http://www.gnu.org/licenses/>.\n\n#import \"OTRXMPPManager.h\"\n\n@import CocoaAsyncSocket;\n@import XMPPFramework;\n#import \"OTRYapDatabaseRosterStorage.h\"\n\n#import \"OTRLog.h\"\n\n#import <CFNetwork/CFNetwork.h>\n\n#import \"OTRSettingsManager.h\"\n#import \"OTRConstants.h\"\n#import \"OTRProtocolManager.h\"\n#include <stdlib.h>\n#import \"OTRConstants.h\"\n#import \"OTRUtilities.h\"\n\n#import \"OTRDatabaseManager.h\"\n@import YapDatabase;\n#import \"OTRXMPPBuddy.h\"\n#import \"OTRXMPPAccount.h\"\n#import \"OTRIncomingMessage.h\"\n#import \"OTROutgoingMessage.h\"\n#import \"OTRAccount.h\"\n#import \"OTRXMPPPresenceSubscriptionRequest.h\"\n#import \"OTRvCardYapDatabaseStorage.h\"\n#import \"OTRNotificationController.h\"\n#import \"OTRStreamManagementYapStorage.h\"\n@import OTRKit;\n#import \"OTRXMPPRoomManager.h\"\n#import \"OTRXMPPBuddyTimers.h\"\n#import \"OTRXMPPError.h\"\n#import \"OTRXMPPManager_Private.h\"\n#import \"OTRBuddyCache.h\"\n@import OTRAssets;\n\nNSString *const OTRXMPPRegisterSucceededNotificationName = @\"OTRXMPPRegisterSucceededNotificationName\";\nNSString *const OTRXMPPRegisterFailedNotificationName    = @\"OTRXMPPRegisterFailedNotificationName\";\n\nNSTimeInterval const kOTRChatStatePausedTimeout   = 5;\nNSTimeInterval const kOTRChatStateInactiveTimeout = 120;\n\nNSString *const OTRXMPPLoginStatusNotificationName = @\"OTRXMPPLoginStatusNotificationName\";\n\nNSString *const OTRXMPPOldLoginStatusKey = @\"OTRXMPPOldLoginStatusKey\";\nNSString *const OTRXMPPNewLoginStatusKey = @\"OTRXMPPNewLoginStatusKey\";\nNSString *const OTRXMPPLoginErrorKey = @\"OTRXMPPLoginErrorKey\";\n\n@implementation OTRXMPPManager\n\n- (instancetype)init\n{\n    if (self = [super init]) {\n        NSString * queueLabel = [NSString stringWithFormat:@\"%@.work.%@\",[self class],self];\n        _workQueue = dispatch_queue_create([queueLabel UTF8String], 0);\n        self.connectionStatus = OTRProtocolConnectionStatusDisconnected;\n        _buddyTimers = [NSMutableDictionary dictionary];\n        _databaseConnection = [OTRDatabaseManager sharedInstance].readWriteDatabaseConnection;\n    }\n    return self;\n}\n\n- (instancetype) initWithAccount:(OTRAccount *)newAccount {\n    if(self = [self init])\n    {\n        NSAssert([newAccount isKindOfClass:[OTRXMPPAccount class]], @\"Must have XMPP account\");\n        self.isRegisteringNewAccount = NO;\n        _account = (OTRXMPPAccount *)newAccount;\n        \n        // Setup the XMPP stream\n        [self setupStream];        \n    }\n    \n    return self;\n}\n\n- (void)dealloc\n{\n\t[self teardownStream];\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#pragma mark Private\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n- (void)setupStream\n{\n\tNSAssert(_xmppStream == nil, @\"Method setupStream invoked multiple times\");\n    \n\t_xmppStream = [[XMPPStream alloc] init];\n\n    //Used to fetch correct account from XMPPStream in delegate methods especailly\n    self.xmppStream.tag = self.account.uniqueId;\n    self.xmppStream.startTLSPolicy = XMPPStreamStartTLSPolicyRequired;\n    \n    [self.certificatePinningModule activate:self.xmppStream];\n    \n    _deliveryReceipts = [[XMPPMessageDeliveryReceipts alloc] init];\n    // We want to check if OTR messages can be decrypted\n    self.deliveryReceipts.autoSendMessageDeliveryReceipts = NO;\n    self.deliveryReceipts.autoSendMessageDeliveryRequests = YES;\n    [self.deliveryReceipts activate:self.xmppStream];\n\t\n#if !TARGET_IPHONE_SIMULATOR\n\t{\n\t\t// Want xmpp to run in the background?\n\t\t// \n\t\t// P.S. - The simulator doesn't support backgrounding yet.\n\t\t//        When you try to set the associated property on the simulator, it simply fails.\n\t\t//        And when you background an app on the simulator,\n\t\t//        it just queues network traffic til the app is foregrounded again.\n\t\t//        We are patiently waiting for a fix from Apple.\n\t\t//        If you do enableBackgroundingOnSocket on the simulator,\n\t\t//        you will simply see an error message from the xmpp stack when it fails to set the property.\n\t\t\n\t\tself.xmppStream.enableBackgroundingOnSocket = YES;\n\t}\n#endif\n\t\n\t// Setup reconnect\n\t// \n\t// The XMPPReconnect module monitors for \"accidental disconnections\" and\n\t// automatically reconnects the stream for you.\n\t// There's a bunch more information in the XMPPReconnect header file.\n\t\n\t_xmppReconnect = [[XMPPReconnect alloc] init];\n\t\n\t// Setup roster\n\t// \n\t// The XMPPRoster handles the xmpp protocol stuff related to the roster.\n\t// The storage for the roster is abstracted.\n\t// So you can use any storage mechanism you want.\n\t// You can store it all in memory, or use core data and store it on disk, or use core data with an in-memory store,\n\t// or setup your own using raw SQLite, or create your own storage mechanism.\n\t// You can do it however you like! It's your application.\n\t// But you do need to provide the roster with some storage facility.\n    \n    //DDLogInfo(@\"Unique Identifier: %@\",self.account.uniqueIdentifier);\n\t\n    OTRYapDatabaseRosterStorage * rosterStorage = [[OTRYapDatabaseRosterStorage alloc] init];\n\t\n\t_xmppRoster = [[XMPPRoster alloc] initWithRosterStorage:rosterStorage];\n\t\n\tself.xmppRoster.autoFetchRoster = YES;\n    self.xmppRoster.autoClearAllUsersAndResources = NO;\n\tself.xmppRoster.autoAcceptKnownPresenceSubscriptionRequests = YES;\n\t\n\t// Setup vCard support\n\t// \n\t// The vCard Avatar module works in conjuction with the standard vCard Temp module to download user avatars.\n\t// The XMPPRoster will automatically integrate with XMPPvCardAvatarModule to cache roster photos in the roster.\n\t\n    OTRvCardYapDatabaseStorage * vCardStorage  = [[OTRvCardYapDatabaseStorage alloc] init];\n\t_xmppvCardTempModule = [[XMPPvCardTempModule alloc] initWithvCardStorage:vCardStorage];\n\t\n\t_xmppvCardAvatarModule = [[XMPPvCardAvatarModule alloc] initWithvCardTempModule:self.xmppvCardTempModule];\n\t\n\t// Setup capabilities\n\t// \n\t// The XMPPCapabilities module handles all the complex hashing of the caps protocol (XEP-0115).\n\t// Basically, when other clients broadcast their presence on the network\n\t// they include information about what capabilities their client supports (audio, video, file transfer, etc).\n\t// But as you can imagine, this list starts to get pretty big.\n\t// This is where the hashing stuff comes into play.\n\t// Most people running the same version of the same client are going to have the same list of capabilities.\n\t// So the protocol defines a standardized way to hash the list of capabilities.\n\t// Clients then broadcast the tiny hash instead of the big list.\n\t// The XMPPCapabilities protocol automatically handles figuring out what these hashes mean,\n\t// and also persistently storing the hashes so lookups aren't needed in the future.\n\t// \n\t// Similarly to the roster, the storage of the module is abstracted.\n\t// You are strongly encouraged to persist caps information across sessions.\n\t// \n\t// The XMPPCapabilitiesCoreDataStorage is an ideal solution.\n\t// It can also be shared amongst multiple streams to further reduce hash lookups.\n\t\n\t_xmppCapabilitiesStorage = [[XMPPCapabilitiesCoreDataStorage alloc] initWithInMemoryStore];\n    _xmppCapabilities = [[XMPPCapabilities alloc] initWithCapabilitiesStorage:self.xmppCapabilitiesStorage];\n    \n    self.xmppCapabilities.autoFetchHashedCapabilities = YES;\n    self.xmppCapabilities.autoFetchNonHashedCapabilities = NO;\n    self.xmppCapabilities.autoFetchMyServerCapabilities = YES;\n    \n    \n\t// Activate xmpp modules\n    \n\t[self.xmppReconnect         activate:self.xmppStream];\n\t[self.xmppRoster            activate:self.xmppStream];\n\t[self.xmppvCardTempModule   activate:self.xmppStream];\n\t[self.xmppvCardAvatarModule activate:self.xmppStream];\n\t[self.xmppCapabilities      activate:self.xmppStream];\n    \n\t// Add ourself as a delegate to anything we may be interested in\n    \n\t[self.xmppStream addDelegate:self delegateQueue:self.workQueue];\n\t[self.xmppRoster addDelegate:self delegateQueue:self.workQueue];\n    [self.xmppCapabilities addDelegate:self delegateQueue:self.workQueue];\n    [self.xmppvCardTempModule addDelegate:self delegateQueue:self.workQueue];\n    \n    // Message storage\n    _messageStorage = [[OTRXMPPMessageYapStroage alloc] initWithDatabaseConnection:self.databaseConnection];\n    [self.messageStorage activate:self.xmppStream];\n    \n    // Message Carbons\n    _messageCarbons = [[XMPPMessageCarbons alloc] init];\n    [self.messageCarbons addDelegate:self.messageStorage delegateQueue:self.messageStorage.moduleDelegateQueue];\n    [self.messageCarbons activate:self.xmppStream];\n    \n    //Stream Management\n    _streamManagementDelegate = [[OTRStreamManagementDelegate alloc] initWithDatabaseConnection:self.databaseConnection];\n    \n    //OTRStreamManagementYapStorage *streamManagementStorage = [[OTRStreamManagementYapStorage alloc] initWithDatabaseConnection:self.databaseConnection];\n    XMPPStreamManagementMemoryStorage *memoryStorage = [[XMPPStreamManagementMemoryStorage alloc] init];\n    _streamManagement = [[XMPPStreamManagement alloc] initWithStorage:memoryStorage];\n    [self.streamManagement addDelegate:self.streamManagementDelegate delegateQueue:self.workQueue];\n    [self.streamManagement automaticallyRequestAcksAfterStanzaCount:10 orTimeout:5];\n    [self.streamManagement automaticallySendAcksAfterStanzaCount:30 orTimeout:5];\n    self.streamManagement.autoResume = YES;\n    [self.streamManagement activate:self.xmppStream];\n    \n    //MUC\n    _roomManager = [[OTRXMPPRoomManager alloc] init];\n    self.roomManager.databaseConnection = [OTRDatabaseManager sharedInstance].readWriteDatabaseConnection;\n    [self.roomManager activate:self.xmppStream];\n    \n    //Buddy Manager (for deleting)\n    _xmppBuddyManager = [[OTRXMPPBuddyManager alloc] init];\n    self.xmppBuddyManager.databaseConnection = [OTRDatabaseManager sharedInstance].longLivedReadOnlyConnection;\n    self.xmppBuddyManager.protocol = self;\n    [self.xmppBuddyManager activate:self.xmppStream];\n    \n    //Message Queue Module\n    MessageQueueHandler *queueHandler = [OTRDatabaseManager sharedInstance].messageQueueHandler;\n    _messageStatusModule = [[OTRXMPPMessageStatusModule alloc] initWithDatabaseConnection:self.databaseConnection delegate:queueHandler];\n    [self.messageStatusModule activate:self.xmppStream];\n    \n    //OMEMO\n    self.omemoSignalCoordinator = [[OTROMEMOSignalCoordinator alloc] initWithAccountYapKey:self.account.uniqueId databaseConnection:self.databaseConnection error:nil];\n    _omemoModule = [[OMEMOModule alloc] initWithOMEMOStorage:self.omemoSignalCoordinator xmlNamespace:OMEMOModuleNamespaceConversationsLegacy];\n    [self.omemoModule addDelegate:self.omemoSignalCoordinator delegateQueue:self.omemoSignalCoordinator.workQueue];\n\n    [self.omemoModule activate:self.xmppStream];\n}\n\n- (void)teardownStream\n{\n    [_xmppStream removeDelegate:self];\n    [_xmppRoster removeDelegate:self];\n    [_xmppCapabilities removeDelegate:self];\n    [_xmppvCardTempModule removeDelegate:self];\n\n    [_xmppReconnect         deactivate];\n    [_xmppRoster            deactivate];\n    [_xmppvCardTempModule   deactivate];\n    [_xmppvCardAvatarModule deactivate];\n    [_xmppCapabilities      deactivate];\n    [_streamManagement      deactivate];\n    [_messageCarbons        deactivate];\n    [_messageStorage        deactivate];\n    [_certificatePinningModule deactivate];\n    [_deliveryReceipts deactivate];\n    [_streamManagement deactivate];\n    [_roomManager deactivate];\n    [_xmppBuddyManager deactivate];\n    [_messageStatusModule deactivate];\n    [_omemoModule deactivate];\n\n    [_xmppStream disconnect];\n}\n\n- (void)goOnline\n{\n    self.connectionStatus = OTRProtocolConnectionStatusConnected;\n    NSString *accountKey = self.account.uniqueId;\n    NSString *accountCollection = [[self.account class] collection];\n    NSDictionary *userInfo = nil;\n    if(accountKey && accountCollection) {\n        userInfo = @{kOTRNotificationAccountUniqueIdKey:accountKey,kOTRNotificationAccountCollectionKey:accountCollection};\n    }\n    [[NSNotificationCenter defaultCenter]\n     postNotificationName:kOTRProtocolLoginSuccess\n     object:self userInfo:userInfo];\n\tXMPPPresence *presence = [XMPPPresence presence]; // type=\"available\" is implicit\n\t\n\t[[self xmppStream] sendElement:presence];\n}\n\n- (void)goOffline\n{\n\tXMPPPresence *presence = [XMPPPresence presenceWithType:@\"unavailable\"];\n\t\n\t[[self xmppStream] sendElement:presence];\n}\n\n- (NSString *)accountDomainWithError:(id)error;\n{\n    return self.account.domain;\n}\n\n- (void)didRegisterNewAccountWithStream:(XMPPStream *)stream\n{\n    self.isRegisteringNewAccount = NO;\n    [self authenticateWithStream:stream];\n    [[NSNotificationCenter defaultCenter] postNotificationName:OTRXMPPRegisterSucceededNotificationName object:self];\n}\n- (void)failedToRegisterNewAccount:(NSError *)error\n{\n    if (error) {\n        [[NSNotificationCenter defaultCenter]\n         postNotificationName:OTRXMPPRegisterFailedNotificationName object:self userInfo:@{kOTRNotificationErrorKey:error}];\n    }\n    else {\n        [[NSNotificationCenter defaultCenter]\n         postNotificationName:OTRXMPPRegisterFailedNotificationName object:self];\n    }\n}\n\n\n- (void)authenticateWithStream:(XMPPStream *)stream {\n    NSError * error = nil;\n    BOOL status = YES;\n    if ([stream supportsXOAuth2GoogleAuthentication] && self.account.accountType == OTRAccountTypeGoogleTalk) {\n        status = [stream authenticateWithGoogleAccessToken:self.account.password error:&error];\n    }\n    else {\n        status = [stream authenticateWithPassword:self.account.password error:&error];\n    }\n}\n\n///////////////////////////////\n#pragma mark Capabilities Collected\n////////////////////////////////////////////\n\n- (NSArray *)myFeaturesForXMPPCapabilities:(XMPPCapabilities *)sender\n{\n    return @[@\"http://jabber.org/protocol/chatstates\"];\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#pragma mark Connect/disconnect\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n- (BOOL)startConnection\n{\n    self.connectionStatus = OTRProtocolConnectionStatusConnecting;\n    \n    XMPPJID *jid = [XMPPJID jidWithString:self.account.username resource:self.account.resource];\n    \n    if (![jid.domain isEqualToString:self.xmppStream.myJID.domain]) {\n        [self.xmppStream disconnect];\n    }\n    self.xmppStream.myJID = jid;\n\tif (![self.xmppStream isDisconnected]) {\n        [self authenticateWithStream:self.xmppStream];\n\t\treturn YES;\n\t}\n    \n\t//\n\t// If you don't want to use the Settings view to set the JID, \n\t// uncomment the section below to hard code a JID and password.\n\t//\n\t// Replace me with the proper JID and password:\n\t//\tmyJID = @\"user@gmail.com/xmppframework\";\n\t//\tmyPassword = @\"\";\n    \n\t\n    \n    \n    NSError * error = nil;\n    NSString * domainString = [self accountDomainWithError:error];\n    if (error) {\n        [self failedToConnect:error];\n        return NO;\n    }\n    if ([domainString length]) {\n        [self.xmppStream setHostName:domainString];\n    }\n    \n    [self.xmppStream setHostPort:self.account.port];\n\t\n    \n\terror = nil;\n\tif (![self.xmppStream connectWithTimeout:XMPPStreamTimeoutNone error:&error])\n\t{\n\t\t[self failedToConnect:error];\n        \n\t\tDDLogError(@\"Error connecting: %@\", error);\n        \n\t\treturn NO;\n\t}\n    \n\treturn YES;\n}\n\n- (void) disconnectSocketOnly:(BOOL)socketOnly {\n    DDLogVerbose(@\"%@: %@ %d\", THIS_FILE, THIS_METHOD, socketOnly);\n    if (socketOnly) {\n        [self.xmppStream disconnect];\n        self.connectionStatus = OTRProtocolConnectionStatusDisconnected;\n        return;\n    }\n    \n    [self goOffline];\n    [self.xmppStream disconnectAfterSending];\n    \n    __weak typeof(self)weakSelf = self;\n    __block NSArray<OTRXMPPBuddy*> *buddiesArray = nil;\n    [self.databaseConnection asyncReadWithBlock:^(YapDatabaseReadTransaction *transaction) {\n        __strong typeof(weakSelf)strongSelf = weakSelf;\n        buddiesArray = [strongSelf.account allBuddiesWithTransaction:transaction];\n    } completionQueue:dispatch_get_main_queue() completionBlock:^{\n        \n        __strong typeof(weakSelf)strongSelf = weakSelf;\n        if([OTRSettingsManager boolForOTRSettingKey:kOTRSettingKeyDeleteOnDisconnect])\n        {\n            [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n                [OTRBaseMessage deleteAllMessagesForAccountId:strongSelf.account.uniqueId transaction:transaction];\n            }];\n        }\n    }];\n}\n\n- (void)disconnect\n{\n    [self disconnectSocketOnly:NO];\n}\n\n- (BOOL)startRegisteringNewAccount\n{\n    self.isRegisteringNewAccount = YES;\n    if (self.xmppStream.isConnected) {\n        [self.xmppStream disconnect];\n        return NO;\n    }\n    \n    return [self startConnection];\n}\n\n- (BOOL)continueRegisteringNewAccount\n{\n    NSError * error = nil;\n    if ([self.xmppStream supportsInBandRegistration]) {\n        [self.xmppStream registerWithPassword:self.account.password error:&error];\n        if (error) {\n            [self failedToRegisterNewAccount:error];\n            return NO;\n        }\n    } else {\n        error = [NSError errorWithDomain:OTRXMPPErrorDomain code:OTRXMPPUnsupportedAction userInfo:nil];\n        [self failedToRegisterNewAccount:error];\n        return NO;\n    }\n    return YES;\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#pragma mark XMPPStream Delegate\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n- (void)xmppStreamDidChangeMyJID:(XMPPStream *)stream\n{\n    if (![[stream.myJID bare] isEqualToString:self.account.username] || ![[stream.myJID resource] isEqualToString:self.account.resource])\n    {\n        self.account.username = [stream.myJID bare];\n        self.account.resource = [stream.myJID resource];\n        [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n            [self.account saveWithTransaction:transaction];\n        }];\n    }\n}\n\n- (void)xmppStream:(XMPPStream *)sender socketDidConnect:(GCDAsyncSocket *)socket \n{\n\tDDLogVerbose(@\"%@: %@\", THIS_FILE, THIS_METHOD);\n    [self changeLoginStatus:OTRLoginStatusConnected error:nil];\n}\n\n- (void)xmppStream:(XMPPStream *)sender willSecureWithSettings:(NSMutableDictionary *)settings\n{\n\tDDLogVerbose(@\"%@: %@\", THIS_FILE, THIS_METHOD);\n    \n    settings[GCDAsyncSocketSSLProtocolVersionMin] = @(kTLSProtocol1);\n    settings[GCDAsyncSocketSSLCipherSuites] = [OTRUtilities cipherSuites];\n    settings[GCDAsyncSocketManuallyEvaluateTrust] = @(YES);\n    \n    [self changeLoginStatus:OTRLoginStatusSecuring error:nil];\n}\n\n- (void)xmppStreamDidSecure:(XMPPStream *)sender\n{\n\tDDLogVerbose(@\"%@: %@\", THIS_FILE, THIS_METHOD);\n    \n    [self changeLoginStatus:OTRLoginStatusSecured error:nil];\n}\n\n- (void)xmppStreamDidConnect:(XMPPStream *)sender\n{\n\tDDLogVerbose(@\"%@: %@\", THIS_FILE, THIS_METHOD);\n    \n    if (self.isRegisteringNewAccount) {\n        [self continueRegisteringNewAccount];\n    }\n    else{\n        [self authenticateWithStream:sender];\n    }\n    \n    [self changeLoginStatus:OTRLoginStatusAuthenticating error:nil];\n}\n\n- (void)xmppStreamDidDisconnect:(XMPPStream *)sender withError:(NSError *)error\n{\n    DDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, error);\n    \n    self.connectionStatus = OTRProtocolConnectionStatusDisconnected;\n    \n    [self changeLoginStatus:OTRLoginStatusDisconnected error:error];\n    \n    if (self.loginStatus == OTRLoginStatusDisconnected)\n    {\n        DDLogError(@\"Unable to connect to server. Check xmppStream.hostName\");\n        \n        [self failedToConnect:error];\n    }\n    \n    //Reset buddy info to offline\n    __block NSArray<OTRXMPPBuddy*> *allBuddies = nil;\n    [self.databaseConnection asyncReadWithBlock:^(YapDatabaseReadTransaction *transaction) {\n        allBuddies = [self.account allBuddiesWithTransaction:transaction];\n    } completionBlock:^{\n        // We don't need to save in here because we're using OTRBuddyCache in memory storage\n        if (!self.streamManagementDelegate.streamManagementEnabled) {\n            [[OTRBuddyCache sharedInstance] purgeAllPropertiesForBuddies:allBuddies];\n        }\n    }];\n}\n\n- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender\n{\n\tDDLogVerbose(@\"%@: %@\", THIS_FILE, THIS_METHOD);\n    if ([sender supportsStreamManagement] && ![self.streamManagement didResume]) {\n        [self.streamManagement enableStreamManagementWithResumption:YES maxTimeout:300];\n    }\n    \n    self.connectionStatus = OTRProtocolConnectionStatusConnected;\n\t[self goOnline];\n    \n    \n    [self changeLoginStatus:OTRLoginStatusAuthenticated error:nil];\n    \n    // Refetch capabilities to check for XEP-0357 support\n    [self.xmppCapabilities fetchCapabilitiesForJID:self.xmppStream.myJID.bareJID];\n    \n    // Fetch latest vCard from server so we can update nickname\n    //[self.xmppvCardTempModule fetchvCardTempForJID:self.JID ignoreStorage:YES];\n}\n\n- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error\n{\n\tDDLogVerbose(@\"%@: %@\", THIS_FILE, THIS_METHOD);\n    self.connectionStatus = OTRProtocolConnectionStatusDisconnected;\n    NSError *err = [OTRXMPPError errorForXMLElement:error];\n    [self failedToConnect:err];\n    \n    [self changeLoginStatus:OTRLoginStatusSecured error:err];\n}\n\n- (BOOL)xmppStream:(XMPPStream *)sender didReceiveIQ:(XMPPIQ *)iq\n{\n\tDDLogVerbose(@\"%@: %@ - %@\", THIS_FILE, THIS_METHOD, iq);\n\treturn NO;\n}\n\n- (void)xmppStreamDidRegister:(XMPPStream *)sender {\n    [self didRegisterNewAccountWithStream:sender];\n}\n\n- (void)xmppStream:(XMPPStream *)sender didNotRegister:(NSXMLElement *)xmlError {\n    \n    self.isRegisteringNewAccount = NO;\n    NSError * error = [OTRXMPPError errorForXMLElement:xmlError];\n    [self failedToRegisterNewAccount:error];\n    \n    [self changeLoginStatus:OTRLoginStatusSecured error:error];\n}\n\n-(OTRXMPPBuddy *)buddyWithMessage:(XMPPMessage *)message transaction:(YapDatabaseReadTransaction *)transaction\n{\n    OTRXMPPBuddy *buddy = [OTRXMPPBuddy fetchBuddyWithUsername:[[message from] bare] withAccountUniqueId:self.account.uniqueId transaction:transaction];\n    return buddy;\n}\n\n\n- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)xmppMessage\n{\n\tDDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, xmppMessage);\n}\n\n- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence\n{\n\tDDLogVerbose(@\"%@: %@ - %@\\nType: %@\\nShow: %@\\nStatus: %@\", THIS_FILE, THIS_METHOD, [presence from], [presence type], [presence show],[presence status]);\n}\n\n- (void)xmppStream:(XMPPStream *)sender didReceiveError:(id)error\n{\n\tDDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, error);\n}\n\n- (void)xmppStream:(XMPPStream *)sender didFailToSendIQ:(XMPPIQ *)iq error:(NSError *)error\n{\n    DDLogVerbose(@\"%@: %@ %@ %@\", THIS_FILE, THIS_METHOD, iq, error);\n}\n\n- (void)xmppStream:(XMPPStream *)sender didFailToSendMessage:(XMPPMessage *)message error:(NSError *)error\n{\n    DDLogVerbose(@\"%@: %@ %@ %@\", THIS_FILE, THIS_METHOD, message, error);\n    if (![message.elementID length]) {\n        return;\n    }\n    [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n        [transaction enumerateMessagesWithId:message.elementID block:^(id<OTRMessageProtocol> _Nonnull databaseMessage, BOOL * _Null_unspecified stop) {\n            if ([databaseMessage isKindOfClass:[OTRBaseMessage class]]) {\n                ((OTRBaseMessage *)databaseMessage).error = error;\n                [(OTRBaseMessage *)databaseMessage saveWithTransaction:transaction];\n                *stop = YES;\n            }\n        }];\n    }];\n}\n- (void)xmppStream:(XMPPStream *)sender didFailToSendPresence:(XMPPPresence *)presence error:(NSError *)error\n{\n    DDLogVerbose(@\"%@: %@ %@ %@\", THIS_FILE, THIS_METHOD, presence, error);\n}\n\n#pragma mark XMPPvCardTempModuleDelegate\n\n- (void)xmppvCardTempModule:(XMPPvCardTempModule *)vCardTempModule\n        didReceivevCardTemp:(XMPPvCardTemp *)vCardTemp\n                     forJID:(XMPPJID *)jid {\n    DDLogVerbose(@\"%@: %@ %@ %@ %@\", THIS_FILE, THIS_METHOD, vCardTempModule, vCardTemp, jid);\n    \n    // update my vCard to local nickname setting\n    // currently this will clobber whatever you have on the server\n    if ([self.xmppStream.myJID isEqualToJID:jid options:XMPPJIDCompareBare]) {\n        if (self.account.displayName.length &&\n            vCardTemp.nickname.length &&\n            ![vCardTemp.nickname isEqualToString:self.account.displayName]) {\n            vCardTemp.nickname = self.account.displayName;\n            [vCardTempModule updateMyvCardTemp:vCardTemp];\n        } else if (vCardTemp.nickname.length) {\n            [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction * _Nonnull transaction) {\n                NSString *collection = [self.account.class collection];\n                NSString *key = self.account.uniqueId;\n                OTRXMPPAccount *account = [[transaction objectForKey:key inCollection:collection] copy];\n                account.displayName = vCardTemp.nickname;\n                [transaction setObject:account forKey:key inCollection:collection];\n            }];\n        }\n    } else {\n        // this is someone elses vCard\n        DDLogVerbose(@\"%@: other's vCard %@ %@ %@ %@\", THIS_FILE, THIS_METHOD, vCardTempModule, vCardTemp, jid);\n    }\n}\n\n- (void)xmppvCardTempModule:(XMPPvCardTempModule *)vCardTempModule\n   failedToFetchvCardForJID:(XMPPJID *)jid\n                      error:(NSXMLElement*)error {\n    DDLogVerbose(@\"%@: %@ %@ %@ %@\", THIS_FILE, THIS_METHOD, vCardTempModule, jid, error);\n    \n    // update my vCard to local nickname setting\n    if ([self.xmppStream.myJID isEqualToJID:jid options:XMPPJIDCompareBare] &&\n        self.account.displayName.length) {\n        XMPPvCardTemp *vCardTemp = [XMPPvCardTemp vCardTemp];\n        vCardTemp.nickname = self.account.displayName;\n        [vCardTempModule updateMyvCardTemp:vCardTemp];\n    }\n}\n\n- (void)xmppvCardTempModuleDidUpdateMyvCard:(XMPPvCardTempModule *)vCardTempModule {\n    DDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, vCardTempModule);\n}\n\n- (void)xmppvCardTempModule:(XMPPvCardTempModule *)vCardTempModule failedToUpdateMyvCard:(NSXMLElement *)error {\n    DDLogVerbose(@\"%@: %@ %@ %@\", THIS_FILE, THIS_METHOD, vCardTempModule, error);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#pragma mark XMPPRosterDelegate\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n- (void)xmppRoster:(XMPPRoster *)sender didReceiveRosterItem:(NSXMLElement *)item {\n    DDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, item);\n\n    // Because XMPP sucks, there's no way to know if a vCard has changed without fetching all of them again\n    // To preserve user mobile data, just fetch each vCard once, only if it's never been fetched\n    // Otherwise you'll only receive vCard updates if someone updates their avatar\n    NSString *jidStr = [item attributeStringValueForName:@\"jid\"];\n    XMPPJID *jid = [[XMPPJID jidWithString:jidStr] bareJID];\n    __block OTRXMPPBuddy *buddy = nil;\n    [[OTRDatabaseManager sharedInstance].readOnlyDatabaseConnection asyncReadWithBlock:^(YapDatabaseReadTransaction * _Nonnull transaction) {\n        buddy = [OTRXMPPBuddy fetchBuddyWithUsername:[jid bare] withAccountUniqueId:self.account.uniqueId transaction:transaction];\n    } completionQueue:self.workQueue completionBlock:^{\n        if (!buddy) { return; }\n        XMPPvCardTemp *vCard = [self.xmppvCardTempModule vCardTempForJID:jid shouldFetch:YES];\n        if (!vCard) { return; }\n        buddy = [buddy copy];\n        buddy.vCardTemp = vCard;\n        [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction * _Nonnull transaction) {\n            [buddy saveWithTransaction:transaction];\n        }];\n    }];\n}\n\n-(void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence\n{\n    DDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, presence);\n    \n\tNSString *jidStrBare = [presence fromStr];\n    \n    [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n        OTRXMPPPresenceSubscriptionRequest *request = [OTRXMPPPresenceSubscriptionRequest fetchPresenceSubscriptionRequestWithJID:jidStrBare accontUniqueId:self.account.uniqueId transaction:transaction];\n        if (!request) {\n            request = [[OTRXMPPPresenceSubscriptionRequest alloc] init];\n        }\n        \n        request.jid = jidStrBare;\n        request.accountUniqueId = self.account.uniqueId;\n        \n        [request saveWithTransaction:transaction];\n    }];\n}\n\n- (void)xmppRoster:(XMPPRoster *)sender didReceiveRosterPush:(XMPPIQ *)iq\n{\n    DDLogVerbose(@\"%@: %@ %@\", THIS_FILE, THIS_METHOD, iq);\n    //verry unclear what this delegate call is supposed to do with jabber.ccc.de it seems to have all the subscription=both,none and jid\n    /*\n    if ([iq isSetIQ] && [[[[[[iq elementsForName:@\"query\"] firstObject] elementsForName:@\"item\"] firstObject] attributeStringValueForName:@\"subscription\"] isEqualToString:@\"from\"]) {\n        NSString *jidString = [[[[[iq elementsForName:@\"query\"] firstObject] elementsForName:@\"item\"] firstObject] attributeStringValueForName:@\"jid\"];\n        \n        [self.databaseConnection readWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n            OTRXMPPPresenceSubscriptionRequest *request = [OTRXMPPPresenceSubscriptionRequest fetchPresenceSubscriptionRequestWithJID:jidString accontUniqueId:self.account.uniqueId transaction:transaction];\n            if (!request) {\n                request = [[OTRXMPPPresenceSubscriptionRequest alloc] init];\n            }\n            \n            request.jid = jidString;\n            request.accountUniqueId = self.account.uniqueId;\n            \n            [transaction setObject:request forKey:request.uniqueId inCollection:[OTRXMPPPresenceSubscriptionRequest collection]];\n        }];\n    }\n    else if ([iq isSetIQ] && [[[[[[iq elementsForName:@\"query\"] firstObject] elementsForName:@\"item\"] firstObject] attributeStringValueForName:@\"subscription\"] isEqualToString:@\"none\"])\n    {\n        [self.databaseConnection readWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n            NSString *jidString = [[[[[iq elementsForName:@\"query\"] firstObject] elementsForName:@\"item\"] firstObject] attributeStringValueForName:@\"jid\"];\n            \n            OTRXMPPBuddy *buddy = [[OTRXMPPBuddy fetchBuddyWithUsername:jidString withAccountUniqueId:self.account.uniqueId transaction:transaction] copy];\n            buddy.pendingApproval = YES;\n            [buddy saveWithTransaction:transaction];\n        }];\n    }\n    \n    */\n    \n    \n}\n\n#pragma mark XMPPCapabilitiesDelegate\n\n- (void)xmppCapabilities:(XMPPCapabilities *)sender didDiscoverCapabilities:(NSXMLElement *)caps forJID:(XMPPJID *)jid {\n    DDLogVerbose(@\"%@: %@\\n%@:%@\", THIS_FILE, THIS_METHOD, jid, caps);\n    \n    // Enable XEP-0357 push bridge if server supports it\n    // ..but don't register for Tor accounts\n    if (self.account.accountType == OTRAccountTypeXMPPTor) {\n        return;\n    }\n    \n    NSString *myDomain = [self.xmppStream.myJID domain];\n    if ([[jid bare] isEqualToString:[jid domain]]) {\n        if (![[jid domain] isEqualToString:myDomain]) {\n            // You're checking the server's capabilities but it's not your server(?)\n            return;\n        }\n    } else {\n        if (![[self.xmppStream.myJID bare] isEqualToString:[jid bare]]) {\n            // You're checking someone else's capabilities\n            return;\n        }\n    }\n    __block BOOL supportsPushXEP = NO;\n    NSArray <NSXMLElement*> *featureElements = [caps elementsForName:@\"feature\"];\n    [featureElements enumerateObjectsUsingBlock:^(NSXMLElement * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        NSString *featureName = [obj attributeStringValueForName:@\"var\"];\n        if ([featureName isEqualToString:XMPPPushXMLNS]){\n            supportsPushXEP = YES;\n            *stop = YES;\n        }\n    }];\n    BOOL hasPushAccount = [[OTRProtocolManager sharedInstance].pushController.pushStorage hasPushAccount];\n    \n    if (supportsPushXEP && hasPushAccount) {\n        [[OTRProtocolManager sharedInstance].pushController getPubsubEndpoint:^(NSString * _Nullable endpoint, NSError * _Nullable error) {\n            if (endpoint) {\n                [[OTRProtocolManager sharedInstance].pushController getNewPushToken:nil completion:^(TokenContainer * _Nullable token, NSError * _Nullable error) {\n                    if (token) {\n                        [self enablePushWithToken:token endpoint:endpoint];\n                    } else if (error) {\n                        DDLogError(@\"fetch token error: %@\", error);\n                    }\n                }];\n            } else if (error) {\n                DDLogError(@\"357 pubsub Error: %@\", error);\n            }\n        }];\n    }\n}\n\n- (void) enablePushWithToken:(TokenContainer*)token endpoint:(NSString*)endpoint {\n    __block OTRXMPPAccount *account = nil;\n    [self.databaseConnection readWriteWithBlock:^(YapDatabaseReadWriteTransaction * _Nonnull transaction) {\n        NSString *collection = [self.account.class collection];\n        NSString *key = self.account.uniqueId;\n        account = [[transaction objectForKey:key inCollection:collection] copy];\n        account.pushPubsubEndpoint = endpoint;\n        if (!account.pushPubsubNode.length) {\n            account.pushPubsubNode = [[NSUUID UUID] UUIDString];\n        }\n        [transaction setObject:account forKey:key inCollection:collection];\n    }];\n    XMPPJID *nodeJID = [XMPPJID jidWithString:endpoint]; \n    NSString *tokenString = token.pushToken.tokenString;\n    if (tokenString.length > 0) {\n        NSString *pushEndpointURLString = [[OTRProtocolManager sharedInstance].pushController getMessagesEndpoint].absoluteString;\n        NSMutableDictionary *options = [NSMutableDictionary dictionary];\n        [options setObject:tokenString forKey:@\"token\"];\n        if (pushEndpointURLString) {\n            [options setObject:pushEndpointURLString forKey:@\"endpoint\"];\n        }\n        XMPPIQ *enableElement = [XMPPIQ enableNotificationsElementWithJID:nodeJID node:account.pushPubsubNode options:options];\n        [self.xmppStream sendElement:enableElement];\n    } else {\n        DDLogError(@\"Token string length 0!\");\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n#pragma mark OTRProtocol\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n- (void) sendMessage:(OTROutgoingMessage*)message\n{\n    NSString *text = message.text;\n    \n    __block OTRBuddy *buddy = nil;\n    [[OTRDatabaseManager sharedInstance].readOnlyDatabaseConnection readWithBlock:^(YapDatabaseReadTransaction *transaction) {\n        buddy = (OTRBuddy *)[message threadOwnerWithTransaction:transaction];\n    }];\n    \n    [self invalidatePausedChatStateTimerForBuddyUniqueId:buddy.uniqueId];\n    \n    if ([text length])\n    {\n        NSString * messageID = message.messageId;\n        XMPPMessage * xmppMessage = [XMPPMessage messageWithType:@\"chat\" to:[XMPPJID jidWithString:buddy.username] elementID:messageID];\n        [xmppMessage addBody:text];\n\n        [xmppMessage addActiveChatState];\n        \n        if ([OTRKit stringStartsWithOTRPrefix:text]) {\n            [xmppMessage addPrivateMessageCarbons];\n            [xmppMessage addStorageHint:XMPPMessageStorageNoCopy];\n            [xmppMessage addStorageHint:XMPPMessageStorageNoPermanentStore];\n        }\n\t\t\n\t\t[self.xmppStream sendElement:xmppMessage];\n    }\n}\n\n- (NSString*) type {\n    return kOTRProtocolTypeXMPP;\n}\n\n- (void) connectUserInitiated:(BOOL)userInitiated\n{\n    // Don't issue a reconnect if we're already connected and authenticated\n    if ([self.xmppStream isConnected] && [self.xmppStream isAuthenticated]) {\n        return;\n    }\n    self.userInitiatedConnection = userInitiated;\n    [self startConnection];\n    if (self.userInitiatedConnection) {\n        [[OTRNotificationController sharedInstance] showAccountConnectingNotificationWithAccountName:self.account.username];\n    }\n}\n\n-(void)connect\n{\n    [self connectUserInitiated:NO];\n}\n\n-(void)sendChatState:(OTRChatState)chatState withBuddyID:(NSString *)buddyUniqueId\n{\n    \n    \n    dispatch_async(self.workQueue, ^{\n        \n        __block OTRXMPPBuddy *buddy = nil;\n        [[OTRDatabaseManager sharedInstance].readOnlyDatabaseConnection readWithBlock:^(YapDatabaseReadTransaction *transaction) {\n            buddy = [OTRXMPPBuddy fetchObjectWithUniqueID:buddyUniqueId transaction:transaction];\n        }];\n        \n        if (buddy.lastSentChatState == chatState) {\n            return;\n        }\n        \n        XMPPMessage * xMessage = [[XMPPMessage alloc] initWithType:@\"chat\" to:[XMPPJID jidWithString:buddy.username]];\n        BOOL shouldSend = YES;\n        \n        if (chatState == OTRChatStateActive) {\n            //Timers\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [[self pausedChatStateTimerForBuddyObjectID:buddyUniqueId] invalidate];\n                [self restartInactiveChatStateTimerForBuddyObjectID:buddyUniqueId];\n            });\n            \n            [xMessage addActiveChatState];\n        }\n        else if (chatState == OTRChatStateComposing)\n        {\n            if(buddy.lastSentChatState !=OTRChatStateComposing)\n                [xMessage addComposingChatState];\n            else\n                shouldSend = NO;\n            \n            //Timers\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [self restartPausedChatStateTimerForBuddyObjectID:buddy.uniqueId];\n                [[self inactiveChatStateTimerForBuddyObjectID:buddy.uniqueId] invalidate];\n            });\n        }\n        else if(chatState == OTRChatStateInactive)\n        {\n            if(buddy.lastSentChatState != OTRChatStateInactive)\n                [xMessage addInactiveChatState];\n            else\n                shouldSend = NO;\n        }\n        else if (chatState == OTRChatStatePaused)\n        {\n            [xMessage addPausedChatState];\n        }\n        else if (chatState == OTRChatStateGone)\n        {\n            [xMessage addGoneChatState];\n        }\n        else\n        {\n            shouldSend = NO;\n        }\n        \n        if(shouldSend)\n        {\n            [[OTRBuddyCache sharedInstance] setLastSentChatState:chatState forBuddy:buddy];\n            [self.xmppStream sendElement:xMessage];\n        }\n    });\n}\n\n- (void) addBuddy:(OTRXMPPBuddy *)newBuddy\n{\n    XMPPJID * newJID = [XMPPJID jidWithString:newBuddy.username];\n    [self.xmppRoster addUser:newJID withNickname:newBuddy.displayName];\n}\n- (void) setDisplayName:(NSString *) newDisplayName forBuddy:(OTRXMPPBuddy *)buddy\n{\n    XMPPJID * jid = [XMPPJID jidWithString:buddy.username];\n    [self.xmppRoster setNickname:newDisplayName forUser:jid];\n    \n}\n-(void)removeBuddies:(NSArray *)buddies\n{\n    for (OTRXMPPBuddy *buddy in buddies){\n        XMPPJID * jid = [XMPPJID jidWithString:buddy.username];\n        [self.xmppRoster removeUser:jid];\n    }\n    \n    \n    [[OTRDatabaseManager sharedInstance].readWriteDatabaseConnection readWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n        [transaction removeObjectsForKeys:[buddies valueForKey:NSStringFromSelector(@selector(uniqueId))] inCollection:[OTRXMPPBuddy collection]];\n    }];\n\n\n\n}\n-(void)blockBuddies:(NSArray *)buddies\n{\n    for (OTRXMPPBuddy *buddy in buddies){\n        XMPPJID * jid = [XMPPJID jidWithString:buddy.username];\n        [self.xmppRoster revokePresencePermissionFromUser:jid];\n    }\n}\n\n//Chat State\n\n-(OTRXMPPBuddyTimers *)buddyTimersForBuddyObjectID:(NSString *)\nmanagedBuddyObjectID\n{\n    OTRXMPPBuddyTimers * timers = [self.buddyTimers objectForKey:managedBuddyObjectID];\n    return timers;\n}\n\n-(NSTimer *)inactiveChatStateTimerForBuddyObjectID:(NSString *)\nmanagedBuddyObjectID\n{\n   return [self buddyTimersForBuddyObjectID:managedBuddyObjectID].inactiveChatStateTimer;\n    \n}\n-(NSTimer *)pausedChatStateTimerForBuddyObjectID:(NSString *)\nmanagedBuddyObjectID\n{\n    return [self buddyTimersForBuddyObjectID:managedBuddyObjectID].pausedChatStateTimer;\n}\n\n-(void)restartPausedChatStateTimerForBuddyObjectID:(NSString *)managedBuddyObjectID\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        OTRXMPPBuddyTimers * timer = [self.buddyTimers objectForKey:managedBuddyObjectID];\n        if(!timer)\n        {\n            timer = [[OTRXMPPBuddyTimers alloc] init];\n        }\n        [timer.pausedChatStateTimer invalidate];\n        timer.pausedChatStateTimer = [NSTimer scheduledTimerWithTimeInterval:kOTRChatStatePausedTimeout target:self selector:@selector(sendPausedChatState:) userInfo:managedBuddyObjectID repeats:NO];\n        [self.buddyTimers setObject:timer forKey:managedBuddyObjectID];\n    });\n    \n}\n-(void)restartInactiveChatStateTimerForBuddyObjectID:(NSString *)managedBuddyObjectID\n{\n    dispatch_async(dispatch_get_main_queue(), ^{\n        OTRXMPPBuddyTimers * timer = [self.buddyTimers objectForKey:managedBuddyObjectID];\n        if(!timer)\n        {\n            timer = [[OTRXMPPBuddyTimers alloc] init];\n        }\n        [timer.inactiveChatStateTimer invalidate];\n        timer.inactiveChatStateTimer = [NSTimer scheduledTimerWithTimeInterval:kOTRChatStateInactiveTimeout target:self selector:@selector(sendInactiveChatState:) userInfo:managedBuddyObjectID repeats:NO];\n        [self.buddyTimers setObject:timer forKey:managedBuddyObjectID];\n    });\n}\n-(void)sendPausedChatState:(NSTimer *)timer\n{\n    NSString * managedBuddyObjectID= (NSString *)timer.userInfo;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [timer invalidate];\n    });\n    [self sendChatState:OTRChatStatePaused withBuddyID:managedBuddyObjectID];\n}\n-(void)sendInactiveChatState:(NSTimer *)timer\n{\n    NSString *managedBuddyObjectID= (NSString *)timer.userInfo;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [timer invalidate];\n    });\n    \n    [self sendChatState:OTRChatStateInactive withBuddyID:managedBuddyObjectID];\n}\n\n- (void)invalidatePausedChatStateTimerForBuddyUniqueId:(NSString *)buddyUniqueId\n{\n    [[self pausedChatStateTimerForBuddyObjectID:buddyUniqueId] invalidate];\n}\n\n- (void)failedToConnect:(NSError *)error\n{\n    __weak typeof(self)weakSelf = self;\n    dispatch_async(dispatch_get_main_queue(), ^{\n        __strong typeof(weakSelf)strongSelf = weakSelf;\n        \n        NSMutableDictionary *userInfo = [@{kOTRProtocolLoginUserInitiated : @(self.userInitiatedConnection)} mutableCopy];\n        if (error) {\n            [userInfo setObject:error forKey:kOTRNotificationErrorKey];\n        }\n        \n        [[NSNotificationCenter defaultCenter] postNotificationName:kOTRProtocolLoginFail object:self userInfo:userInfo];\n        //Only user initiated on the first time any subsequent attempts will not be from user\n        strongSelf.userInitiatedConnection = NO;\n    });\n}\n\n- (OTRCertificatePinning *)certificatePinningModule\n{\n    if(!_certificatePinningModule){\n        _certificatePinningModule = [OTRCertificatePinning defaultCertificates];\n        _certificatePinningModule.delegate = self;\n    }\n    return _certificatePinningModule;\n}\n\n- (void)newTrust:(SecTrustRef)trust withHostName:(NSString *)hostname systemTrustResult:(SecTrustResultType)trustResultType\n{\n    NSData * certifcateData = [OTRCertificatePinning dataForCertificate:[OTRCertificatePinning certForTrust:trust]];\n    DDLogVerbose(@\"New trustResultType: %d certLength: %d\", (int)trustResultType, (int)certifcateData.length);\n    NSError *error = [OTRXMPPError errorForTrustResult:trustResultType withCertData:certifcateData hostname:hostname];\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [self failedToConnect:error];\n    });\n    \n    [self changeLoginStatus:OTRLoginStatusDisconnected error:error];\n}\n\n- (void)changeLoginStatus:(OTRLoginStatus)status error:(NSError *)error\n{\n    OTRLoginStatus oldStatus = self.loginStatus;\n    OTRLoginStatus newStatus = status;\n    self.loginStatus = status;\n    \n    NSMutableDictionary *userInfo = [@{OTRXMPPOldLoginStatusKey: @(oldStatus), OTRXMPPNewLoginStatusKey: @(newStatus)} mutableCopy];\n    \n    if (error) {\n        userInfo[OTRXMPPLoginErrorKey] = error;\n    }\n    \n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[NSNotificationCenter defaultCenter] postNotificationName:OTRXMPPLoginStatusNotificationName object:self userInfo:userInfo];\n    });\n}\n\n// Delivery receipts\n- (void) sendDeliveryReceiptForMessage:(OTRIncomingMessage*)message {\n    [[OTRDatabaseManager sharedInstance].readOnlyDatabaseConnection asyncReadWithBlock:^(YapDatabaseReadTransaction * _Nonnull transaction) {\n        OTRBuddy *buddy = [OTRBuddy fetchObjectWithUniqueID:message.buddyUniqueId transaction:transaction];        \n        XMPPMessage *tempMessage = [XMPPMessage messageWithType:@\"chat\" elementID:message.messageId];\n        [tempMessage addAttributeWithName:@\"from\" stringValue:buddy.username];\n        XMPPMessage *receiptMessage = [tempMessage generateReceiptResponse];\n        [self.xmppStream sendElement:receiptMessage];\n    }];\n}\n\n@end\n", "//\n//  OTRXMPPMessageYapStroage.h\n//  ChatSecure\n//\n//  Created by David Chiles on 8/13/15.\n//  Copyright (c) 2015 Chris Ballinger. All rights reserved.\n//\n\n@import XMPPFramework;\n@import YapDatabase;\n@class XMPPMessage;\n\nNS_ASSUME_NONNULL_BEGIN\n@interface OTRXMPPMessageYapStroage : XMPPModule\n\n@property (nonatomic, strong, readonly) YapDatabaseConnection *databaseConnection;\n@property (nonatomic, readonly) dispatch_queue_t moduleDelegateQueue;\n\n/** This connection is only used for readWrites */\n- (instancetype)initWithDatabaseConnection:(YapDatabaseConnection *)databaseConnection;\n\n@end\nNS_ASSUME_NONNULL_END\n", "//\n//  OTRXMPPMessageYapStroage.m\n//  ChatSecure\n//\n//  Created by David Chiles on 8/13/15.\n//  Copyright (c) 2015 Chris Ballinger. All rights reserved.\n//\n\n#import \"OTRXMPPMessageYapStroage.h\"\n@import XMPPFramework;\n#import \"OTRLog.h\"\n@import OTRKit;\n#import \"OTRXMPPBuddy.h\"\n#import \"OTRIncomingMessage.h\"\n#import \"OTROutgoingMessage.h\"\n#import \"OTRAccount.h\"\n#import \"OTRConstants.h\"\n#import <ChatSecureCore/ChatSecureCore-Swift.h>\n#import \"OTRThreadOwner.h\"\n#import \"OTRBuddyCache.h\"\n\n@implementation OTRXMPPMessageYapStroage\n\n- (instancetype)initWithDatabaseConnection:(YapDatabaseConnection *)connection\n{\n    if (self = [self init]) {\n        _databaseConnection = connection;\n        _moduleDelegateQueue = dispatch_queue_create(\"OTRXMPPMessageYapStroage-delegateQueue\", 0);\n    }\n    return self;\n}\n\n\n- (OTRXMPPBuddy *)buddyForUsername:(NSString *)username stream:(XMPPStream *)stream transaction:(YapDatabaseReadTransaction *)transaction\n{\n    return [OTRXMPPBuddy fetchBuddyWithUsername:username withAccountUniqueId:stream.tag transaction:transaction];\n}\n\n- (OTRBaseMessage *)baseMessageFromXMPPMessage:(XMPPMessage *)xmppMessage buddyId:(NSString *)buddyId class:(Class)class {\n    NSString *body = [xmppMessage body];\n    \n    NSDate * date = [xmppMessage delayedDeliveryDate];\n    \n    OTRBaseMessage *message = [[class alloc] init];\n    message.text = body;\n    message.buddyUniqueId = buddyId;\n    if (date) {\n        message.date = date;\n    }\n    \n    message.messageId = [xmppMessage elementID];\n    return message;\n}\n\n- (OTROutgoingMessage *)outgoingMessageFromXMPPMessage:(XMPPMessage *)xmppMessage buddyId:(NSString *)buddyId {\n    OTROutgoingMessage *outgoingMessage = (OTROutgoingMessage *)[self baseMessageFromXMPPMessage:xmppMessage buddyId:buddyId class:[OTROutgoingMessage class]];\n    // Fill in current data so it looks like this 'outgoing' message was really sent (but of course this is a message we received through carbons).\n    outgoingMessage.dateSent = [NSDate date];\n    return outgoingMessage;\n}\n\n- (OTRIncomingMessage *)incomingMessageFromXMPPMessage:(XMPPMessage *)xmppMessage buddyId:(NSString *)buddyId\n{\n    return (OTRIncomingMessage *)[self baseMessageFromXMPPMessage:xmppMessage buddyId:buddyId class:[OTRIncomingMessage class]];\n}\n\n- (void)xmppStream:(XMPPStream *)stream didReceiveMessage:(XMPPMessage *)xmppMessage\n{\n    // We don't handle incoming group chat messages here\n    // Check out OTRXMPPRoomYapStorage instead\n    if ([[xmppMessage type] isEqualToString:@\"groupchat\"] ||\n        [xmppMessage elementForName:@\"x\" xmlns:XMPPMUCUserNamespace] ||\n        [xmppMessage elementForName:@\"x\" xmlns:@\"jabber:x:conference\"]) {\n        return;\n    }\n    \n    if ([xmppMessage isMessageCarbon]) {\n        return;\n    }\n    \n    [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n        if ([stream.tag isKindOfClass:[NSString class]]) {\n            NSString *username = [[xmppMessage from] bare];\n            \n            [self handleChatState:xmppMessage username:username stream:stream transaction:transaction];\n            [self handleDeliverResponse:xmppMessage transaction:transaction];\n            \n            OTRXMPPBuddy *messageBuddy = [OTRXMPPBuddy fetchBuddyWithUsername:username withAccountUniqueId:stream.tag transaction:transaction];\n            if (!messageBuddy) {\n                // message from server\n                DDLogWarn(@\"No buddy for message: %@\", xmppMessage);\n                return;\n            }\n            \n            OTRIncomingMessage *message = [self incomingMessageFromXMPPMessage:xmppMessage buddyId:messageBuddy.uniqueId];\n            NSString *activeThreadYapKey = [[OTRAppDelegate appDelegate] activeThreadYapKey];\n            if([activeThreadYapKey isEqualToString:message.threadId]) {\n                message.read = YES;\n            }\n            OTRAccount *account = [OTRAccount fetchObjectWithUniqueID:xmppStream.tag transaction:transaction];\n            \n            \n            if ([xmppMessage isErrorMessage]) {\n                NSError *error = [xmppMessage errorMessage];\n                message.error = error;\n                NSString *errorText = [[xmppMessage elementForName:@\"error\"] elementForName:@\"text\"].stringValue;\n                if (!message.text) {\n                    if (errorText) {\n                        message.text = errorText;\n                    } else {\n                        message.text = error.localizedDescription;\n                    }\n                }\n                if ([errorText containsString:@\"OTR Error\"]) {\n                    // automatically renegotiate a new session when there's an error\n                    [[OTRProtocolManager sharedInstance].encryptionManager.otrKit initiateEncryptionWithUsername:username accountName:account.username protocol:account.protocolTypeString];\n                }\n                // Suppress error messages for now...\n                // [message saveWithTransaction:transaction];\n                return;\n            }\n            \n            if ([self duplicateMessage:xmppMessage buddyUniqueId:messageBuddy.uniqueId transaction:transaction]) {\n                DDLogWarn(@\"Duplicate message received: %@\", xmppMessage);\n                return;\n            }\n            \n            if (message.text) {\n                [[OTRProtocolManager sharedInstance].encryptionManager.otrKit decodeMessage:message.text username:messageBuddy.username accountName:account.username protocol:kOTRProtocolTypeXMPP tag:message];\n            }\n        }\n    }];\n}\n\n- (void)handleChatState:(XMPPMessage *)xmppMessage username:(NSString *)username stream:(XMPPStream *)stream transaction:(YapDatabaseReadTransaction *)transaction\n{\n    // Saves aren't needed when setting chatState or status because OTRBuddyCache is used internally\n\n    OTRXMPPBuddy *messageBuddy = [OTRXMPPBuddy fetchBuddyWithUsername:username withAccountUniqueId:stream.tag transaction:transaction];\n    if (!messageBuddy) { return; }\n    OTRChatState chatState = OTRChatStateUnknown;\n    if([xmppMessage hasChatState])\n    {\n        if([xmppMessage hasComposingChatState])\n            chatState = OTRChatStateComposing;\n        else if([xmppMessage hasPausedChatState])\n            chatState = OTRChatStatePaused;\n        else if([xmppMessage hasActiveChatState])\n            chatState = OTRChatStateActive;\n        else if([xmppMessage hasInactiveChatState])\n            chatState = OTRChatStateInactive;\n        else if([xmppMessage hasGoneChatState])\n            chatState = OTRChatStateGone;\n    }\n    [[OTRBuddyCache sharedInstance] setChatState:chatState forBuddy:messageBuddy];\n}\n\n- (void)handleDeliverResponse:(XMPPMessage *)xmppMessage transaction:(YapDatabaseReadWriteTransaction *)transaction\n{\n    if ([xmppMessage hasReceiptResponse] && ![xmppMessage isErrorMessage]) {\n        [OTROutgoingMessage receivedDeliveryReceiptForMessageId:[xmppMessage receiptResponseID] transaction:transaction];\n    }\n}\n\n- (BOOL)duplicateMessage:(XMPPMessage *)message buddyUniqueId:(NSString *)buddyUniqueId transaction:(YapDatabaseReadWriteTransaction *)transaction\n{\n    __block BOOL result = NO;\n    if ([message.elementID length]) {\n        [transaction enumerateMessagesWithId:message.elementID block:^(id<OTRMessageProtocol> _Nonnull databaseMessage, BOOL * _Null_unspecified stop) {\n            if ([[databaseMessage threadId] isEqualToString:buddyUniqueId]) {\n                *stop = YES;\n                result = YES;\n            }\n        }];\n    }\n    return result;\n}\n\n- (void)handleCarbonMessage:(XMPPMessage *)forwardedMessage stream:(XMPPStream *)stream outgoing:(BOOL)isOutgoing\n{\n    //Sent Message Carbons are sent by our account to another\n    //So from is our JID and to is buddy\n    BOOL incoming = !isOutgoing;\n    \n    \n    NSString *username = nil;\n    if (incoming) {\n        username = [[forwardedMessage from] bare];\n    } else {\n        username = [[forwardedMessage to] bare];\n    }\n    \n    [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction * __nonnull transaction) {\n        \n        OTRXMPPBuddy *buddy = [OTRXMPPBuddy fetchBuddyForUsername:username accountName:stream.tag transaction:transaction];\n        \n        if (!buddy) {\n            return;\n        }\n        if (![self duplicateMessage:forwardedMessage buddyUniqueId:buddy.uniqueId transaction:transaction]) {\n            if (incoming) {\n                [self handleChatState:forwardedMessage username:username stream:stream transaction:transaction];\n                [self handleDeliverResponse:forwardedMessage transaction:transaction];\n            }\n            \n            if ([forwardedMessage isMessageWithBody] && ![forwardedMessage isErrorMessage] && ![OTRKit stringStartsWithOTRPrefix:forwardedMessage.body]) {\n                if (incoming) {\n                    OTRIncomingMessage *message = [self incomingMessageFromXMPPMessage:forwardedMessage buddyId:buddy.uniqueId];\n                    NSString *activeThreadYapKey = [[OTRAppDelegate appDelegate] activeThreadYapKey];\n                    if([activeThreadYapKey isEqualToString:message.threadId]) {\n                        message.read = YES;\n                    }\n                    [message saveWithTransaction:transaction];\n                } else {\n                    OTROutgoingMessage *message = [self outgoingMessageFromXMPPMessage:forwardedMessage buddyId:buddy.uniqueId];\n                    [message saveWithTransaction:transaction];\n                }\n            }\n        }\n    }];\n}\n\n#pragma - mark XMPPMessageCarbonsDelegate\n\n- (void)xmppMessageCarbons:(XMPPMessageCarbons *)xmppMessageCarbons didReceiveMessage:(XMPPMessage *)message outgoing:(BOOL)isOutgoing\n{\n    [self handleCarbonMessage:message stream:xmppMessageCarbons.xmppStream outgoing:isOutgoing];\n}\n\n@end\n"], "filenames": ["ChatSecure/Classes/Controllers/XMPP/OTRXMPPManager.m", "ChatSecure/Classes/Controllers/XMPP/OTRXMPPMessageYapStroage.h", "ChatSecure/Classes/Controllers/XMPP/OTRXMPPMessageYapStroage.m"], "buggy_code_start_loc": [222, 16, 27], "buggy_code_end_loc": [228, 16, 232], "fixing_code_start_loc": [221, 17, 28], "fixing_code_end_loc": [230, 18, 230], "type": "CWE-20", "message": "An incorrect implementation of \"XEP-0280: Message Carbons\" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for ChatSecure (3.2.0 - 4.0.0; only iOS) and Zom (all versions up to 1.0.11; only iOS).", "other": {"cve": {"id": "CVE-2017-5590", "sourceIdentifier": "cve@mitre.org", "published": "2017-02-09T20:59:00.200", "lastModified": "2017-03-01T02:59:05.527", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An incorrect implementation of \"XEP-0280: Message Carbons\" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for ChatSecure (3.2.0 - 4.0.0; only iOS) and Zom (all versions up to 1.0.11; only iOS)."}, {"lang": "es", "value": "Una implementaci\u00f3n incorrecta de \"XEP-0280: Message Carbons\" en m\u00faltiples clientes XMPP permite a un atacante remoto personificar cualquier usuario, incluidos los contactos, en la pantalla de la aplicaci\u00f3n vulnerable. Esto permite varios tipos de ataques de ingenier\u00eda social. Esta CVE es para ChatSecure (3.2.0 - 4.0.0; solo iOS) y Zom (todas las versiones hasta la 1.0.11; solo iOS)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}, {"lang": "en", "value": "CWE-346"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chatsecure:chatsecure:3.2.0:*:*:*:*:iphone_os:*:*", "matchCriteriaId": "8EA871A9-0979-4D25-8FF9-52F29168CDAE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:chatsecure:chatsecure:3.2.1:*:*:*:*:iphone_os:*:*", "matchCriteriaId": "E0B181D1-AEB1-4BD8-B722-9A819DABC66D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:chatsecure:chatsecure:3.2.2:*:*:*:*:iphone_os:*:*", "matchCriteriaId": "19D39CE7-0D9F-4878-B6F6-916B09E2B2D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:chatsecure:chatsecure:3.2.3:*:*:*:*:iphone_os:*:*", "matchCriteriaId": "CA0652B8-53BD-4246-A078-71A1AC4FCFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:chatsecure:chatsecure:4.0.0:*:*:*:*:iphone_os:*:*", "matchCriteriaId": "89229A2D-F6D7-4EFF-AEDA-DA90F9F89FA5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zom:zom:*:*:*:*:*:iphone_os:*:*", "versionEndIncluding": "1.0.11", "matchCriteriaId": "436A20AC-C1BD-401F-ADE4-448F03E2F85A"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2017/02/09/29", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96165", "source": "cve@mitre.org"}, {"url": "https://github.com/ChatSecure/ChatSecure-iOS/commit/a340b4bb519227d89f85f2716a10a197a65d4856", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/zom/Zom-iOS/commit/880051eaa8ba32d1b257c87a7d8798a93561bfd3", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://rt-solutions.de/en/2017/02/CVE-2017-5589_xmpp_carbons/", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}, {"url": "https://rt-solutions.de/wp-content/uploads/2017/02/CVE-2017-5589_xmpp_carbons.pdf", "source": "cve@mitre.org", "tags": ["Exploit", "Technical Description", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ChatSecure/ChatSecure-iOS/commit/a340b4bb519227d89f85f2716a10a197a65d4856"}}