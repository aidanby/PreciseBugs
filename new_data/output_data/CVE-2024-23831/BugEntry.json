{"buggy_code": ["[% WRAPPER \"ui-header.html\"\nstylesheet=\"ledgersmb.css\"\ninclude_stylesheet=[\"system/setup.css\"] %]\n[% PROCESS elements.html %]\n<body id=\"setup-begin-backup\" class=\"lsmb [% dojo_theme %]\">\n<div><div class=\"setupconsole\">\n<h2>[% text('Database Management Console') %]</h2>\n<div class=\"listtop\">[% text('Where shall we send the backup?') %]</div>\n[% # notice, message, and operation are all localized. %]\n<div id=\"notice\">[% notice %]</div>\n<form data-dojo-type=\"lsmb/SimpleForm\" action=\"setup.pl\" method=\"POST\" name=\"confirm_operation\">\n[% INCLUDE input element_data = {\n    name = 'database'\n    type = 'hidden'\n   value = database\n} %]\n[% INCLUDE input element_data = {\n    name = 'backup'\n    type = 'hidden'\n   value = backup\n} %]\n<div class=\"inputrow\" id=\"emailopt\">\n[% IF can_email %]\n[% INCLUDE input element_data = {\n        type = 'radio'\n        name = 'backup_type'\n       label = text('To email') #'\n       value = 'email'\n    }, label_pos = 1\n%]\n[% INCLUDE input element_data = {\n    type = \"text\"\n    name = \"email\"\n   value = email\n   class = \"email\"\n} %]\n[% ELSE %]\n[% INCLUDE input element_data = {\n        type = 'radio'\n        name = 'backup_type'\n       label = text('To email') #'\n       value = 'email'\n    disabled = 'disabled'\n    }, label_pos = 1\n%]\n[% INCLUDE input element_data = {\n    type = \"text\"\n    name = \"email\"\n   value = email\n   class = \"email\"\ndisabled = \"disabled\"\n} %]\n[% END %]\n</div>\n<div class=\"inputrow\" id=\"browseropt\">\n[% INCLUDE input element_data = {\n    type = 'radio'\n    name = 'backup_type'\n   label = text('To my browser') #'\n   value = 'browser'\n checked = \"checked\"\n}, label_pos = 1 %]\n</div>\n<div class=\"inputrow\">\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'run_backup'\n    type = 'submit'\n   class = 'submit'\n    text = text('Run Backup') #'\n} %]\n</div>\n</form>\n</div></div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\nstylesheet=\"ledgersmb.css\"\ninclude_stylesheet=[\"system/setup.css\"] %]\n[% PROCESS elements.html %]\n<body id=\"setup-confirm-operation\" class=\"lsmb [% dojo_theme %]\">\n<div><div class=\"setupconsole\">\n<h2>[% text('Database Management Console') %]</h2>\n[% # notice, message, and operation are all localized. %]\n[% INCLUDE 'setup/ui-db-credentials.html' %]\n<div class=\"listtop\">[% text('Confirm Operation') %]</div>\n<div id=\"notice\">[% notice %]</div>\n<div id=\"message\">[% message %]</div>\n<div id=\"operation\">[% operation %]</div>\n<form data-dojo-type=\"lsmb/SimpleForm\"\n      action=\"setup.pl\"\n      method=\"POST\"\n      name=\"confirm_operation\">\n[% INCLUDE input element_data = {\n    name = 'database'\n    type = 'hidden'\n   value = database\n} %]\n<div class=\"inputrow\">\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = next_action\n    type = 'submit'\n   class = 'submit'\n    text = text('Yes')\n} %]\n</div>\n<div id=\"sep\" class=\"listheading\">[% text('Other Actions') %]</div>\n[% IF next_action == 'rebuild_modules' %]\n<div id=\"copy-database\">\n[% INCLUDE input element_data = {\n    name = 'new_name'\n    type = 'text'\n   class = 'dbname'\n   label = text('Copy to New Name') #'\n}; %]\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'copy_db'\n    type = 'submit'\n   class = 'submit'\n    text = text('Copy') #'\n}; %]\n</div>\n<div id=\"user\">\n<div>[% text('Users') %]</div>\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'add_user'\n    type = 'submit'\n   class = 'submit'\n    text = text('Add User') #'\n}; %]\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'list_users'\n    type = 'submit'\n   class = 'submit'\n    text = text('List Users') #'\n}; %]\n</div>\n<div id=\"templates\">\n<div>[% text('Templates') %]</div>\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'load_templates'\n    type = 'submit'\n   class = 'submit'\n    text = text('Load Templates') #'\n};\nINCLUDE input element_data = {\n    name = \"only_templates\"\n   value = \"1\"\n    type = \"hidden\"\n}; %]\n</div>\n[% END %]\n[% IF next_action != 'create_db' %]\n<div id=\"others\">[% text('Backup') %]</div>\n<div class=\"inputrow\">\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'backup_db'\n    type = 'submit'\n   class = 'submit'\n    text = text('Backup DB') #'\n} %]\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'backup_roles'\n    type = 'submit'\n   class = 'next'\n    text = text('Backup Roles') #'\n} %]\n</div>\n<div id=\"diagnostics\">[% text('System diagnostics') %]</div>\n<div class=\"inputrow\">\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'system_info'\n    type = 'submit'\n   class = 'submit'\n    text = text('System Info') #'\n} %]\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'consistency'\n    type = 'submit'\n   class = 'submit'\n    text = text('Check consistency') #'\n} %]\n</div>\n[% END %]\n</form>\n[% IF lsmb_info %]\n<table class='lsmb_info'>\n  <thead>\n  <tr><th colspan=\"2\">[% text('LedgerSMB Database Statistics') %]</th></tr>\n  <tr><th colspan=\"2\">[% text('Row counts') %]</th></tr>\n  </thead>\n  <tbody>\n  <tr><th>[% text('AP') %]</th><td>[% lsmb_info.ap_count %]</td></tr>\n  <tr><th>[% text('AR') %]</th><td>[% lsmb_info.ar_count %]</td></tr>\n  <tr><th>[% text('GL') %]</th><td>[% lsmb_info.gl_count %]</td></tr>\n  <tr><th>[% text('Journal Lines') %]</th><td>[% lsmb_info.acc_trans_count %]</td></tr>\n  <tr><th>[% text('Orders') %]</th><td>[% lsmb_info.oe_count %]</td></tr>\n  <tr><th>[% text('Customer/Vendor Accounts') %]</th><td>[% lsmb_info.eca_count %]</td></tr>\n  <tr><th>[% text('Transactions') %]</th><td>[% lsmb_info.transactions_count %]</td></tr>\n  <tr><th>[% text('Users') %]</th><td>[% lsmb_info.users_count %]</td></tr>\n  </tbody>\n</table>\n[% END %]\n</div></div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\n       stylesheet=\"ledgersmb.css\"\n       include_stylesheet=[\"system/setup.css\"];\n       PROCESS elements.html -%]\n<body id=\"setup-login\" class=\"lsmb [% dojo_theme%]\">\n  <div style=\"width:100%;height:100%\">\n    <div>\n        <div class=\"setupconsole\">\n          <div id=\"loading\">\n                <img style=\"display:block;position:absolute;margin:auto;top:50%;left:50%;transsform:translateX(-50%) translateY(-50%)\"\n                    src=\"js/dijit/icons/images/loadingAnimation.gif\"\n                    alt=\"If this text is showing, there's most likely a problem with the Dojo setup\"\n                    title=\"Loading ...\"\n                  width=\"20\" height=\"20\" />\n          </div>\n            <div id=\"logindiv\">\n                <div class=\"login\" align=\"center\">\n                    <a href=\"http://www.ledgersmb.org/\"\n                    target=\"_top\">\n                    <img src=\"images/ledgersmb.png\"\n                            class=\"logo\"\n                            alt=\"LedgerSMB Logo\" />\n                    </a>\n                    <h2 align=\"center\" style=\"margin-top: 0\">\n                        [% version %]\n                    </h2>\n                    <div class=\"listtop\">\n                        [% text('Database administrator credentials') %]\n                    </div>\n                </div>\n                <form id=\"loginform\"\n                      name=\"credentials\"\n                      style=\"margin-top:1em\">\n                  <div class=\"login_form\">\n                    [% select_hint = text('Select or Enter User');\n                       INCLUDE select element_data = {\n                                   name = 's_user'\n                                   id = 's-user'\n                                   options =  [ { value = 'lsmb_dbadmin',\n                                                  text = 'lsmb_dbadmin'},\n                                                { value = 'postgres',\n                                                  text  = 'postgres'} ]\n                                   class = 'username'\n                                   tabindex = 1\n                                   label = text('DB admin login')\n                                   \"data-dojo-type\" = \"dijit/form/ComboBox\"\n                                   \"data-dojo-props\" = \"value:'$s_user', placeHolder:'$select_hint'\"\n                                    attributes = { autocomplete = 'off'}\n                       };\n                       INCLUDE input element_data = {\n                                    name = 's_password'\n                                    id = 's-password'\n                                    value = s_password\n                                    type = 'password'\n                                    size = '15'\n                                    class = 'password'\n                                    tabindex = 2\n                                    label = text('Password')\n                                    attributes = { autocomplete = 'off'}\n                       };\n                       INCLUDE input element_data = {\n                                    name = 'database'\n                                    value = database\n                                    type = 'text'\n                                    size = '15'\n                                    class = 'database'\n                                    tabindex = 3\n                                    label = text('Database')\n                       } %]\n                  </div>\n                  <div class=\"inputrow\"\n                       style=\"text-align:right; padding-right: 4ex; margin-top: 1ex\">\n                    <button data-dojo-type=\"lsmb/SetupLoginButton\"\n                            class=\"submit\"\n                            data-dojo-props=\"action:'login'\"\n                            tabindex=\"4\"\n                            >[% text('Login') %]</button>\n                    <button data-dojo-type=\"lsmb/SetupLoginButton\"\n                            class=\"submit\"\n                            data-dojo-props=\"action:'create_db'\"\n                            tabindex=\"5\"\n                            >[% text('Create') %]</button>\n                  </div>\n                </form>\n            </div>\n        </div>\n    </div>\n  </div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\nstylesheet=\"ledgersmb.css\"\ninclude_stylesheet=[\"system/setup.css\"];\n       PROCESS \"elements.html\";\n       PROCESS \"dynatable.html\"; %]\n<body id=\"setup-edit-user\" class=\"[% dojo_theme %]\">\n <div><div class=\"setupconsole\">\n        <div class=\"listtop\">\n            [%\n               IF request.pls_import;\n                       text('Duplicate User Found: Importing User');\n                       action = 'save_user';\n                ELSIF user.user_id;\n                      text('Editing User');\n                      action = 'edit_user';\n                ELSE;\n                      text('New User');\n                      action = 'save_user';\n                END %]\n        </div>\n\n    <form data-dojo-type=\"lsmb/SimpleForm\" method=\"POST\" action=\"[% request.script %]\">\n      <input type=\"hidden\" name=\"id\" value=\"[% request.id %]\" />\n      <input type=\"hidden\" name=\"database\" value=\"[% request.database %]\" />\n        <table id=\"user-data\">\n\n            [% IF user.user_id and not request.pls_import %]\n            <tr>\n                <td>[% text('Username') %]</td>\n                <td>\n                    [% user.username;\n                    INCLUDE input element_data = {\n                            name  = 'username'\n                            type  = 'hidden'\n                            value = user.username\n                    } %]\n                </td>\n            </tr>\n\n            [% ELSE %]\n            <tr>\n                <td>[% text('Username') %]</td>\n                <td>\n                    <input type=\"text\" name=\"username\" value=\"[% user.username %]\" required/>\n                </td>\n            </tr>\n            [% END %]\n            <tr>\n                <td><label for=\"password\">[% text('Password') %]</label>\n                </td>\n                <td>\n                  [% PROCESS input element_data = {\n                               type = \"password\"\n                               id   = \"password\"\n                               name = \"password\"\n                               autocomplete = \"off\"\n                  } %]\n                </td>\n            </tr>\n\n            [% IF (request.pls_import == 1) OR !user.username %]\n            <tr>\n                <td>[% text('Import') %]</td>\n                [%\n                  IF request.pls_import;\n                      importc1 = 'CHECKED';\n                      importc0 = '';\n                  ELSE;\n                      importc1 = '';\n                      importc0 = 'CHECKED';\n                  END; %]\n                <td><div class=\"input_line\"><div overflow=\"auto\" class=\"input_group\">\n                  [% INCLUDE input element_data = {\n                           label   = 'Yes'\n                           value   = '1'\n                           checked = importc1\n                           name    = 'pls_import'\n                           type    = 'radio'\n                   } %]</div><div overflow=\"auto\" class=\"input_group\">[%\n                   INCLUDE input element_data = {\n                           label   = 'No'\n                           value   = '0'\n                           checked = importc0\n                           name    = 'pls_import'\n                           type    = 'radio'\n                   } %]</div></div></td>\n            </tr>\n            [% END # unless employee.entity_id %]\n        </table>\n           [% IF user.username and not request.pls_import;\n                PROCESS button element_data  = {\n                         text = text('Reset Password') #'\n                         name = '__action'\n                         type = 'submit'\n                        class = 'submit'\n                  value = 'reset_password'\n                  attributes = { autocomplete = \"off\" }\n                };\n           ELSE;\n                PROCESS button element_data  = {\n                         text = text('Add User') #'\n                         name = '__action'\n                         type = 'submit'\n                        class = 'submit'\n                        value = 'create_user'\n                };\n           END;\n    %]\n    </form>\n    [% IF user.user_id and not request.pls_import%]\n        <hr />\n        <form data-dojo-type=\"lsmb/SimpleForm\" name=\"groups\" method=\"POST\" action=\"[% request.script %]\">\n            <input type=\"hidden\" name=\"database\" value=\"[% request.database %]\" />\n            [% PROCESS input element_data = {\n               type=\"hidden\"\n               name=\"id\"\n               value=request.id\n              };\n           %]\n        <input type=\"hidden\" name=\"entity_id\" value=\"[% entity_id %]\"/>\n           <div>\n            <table id=\"user-roles\">\n                <!-- Groups section -->\n                <tr>\n                [% FOREACH role IN roles %]\n                    <td>\n                        [% rolcheck = undef;\n                           IF user.roles.grep(role.name).size;\n                              rolcheck = \"checked\";\n                           END %]\n                        [% PROCESS input element_data = {\n                               type = \"checkbox\"\n                               label = role.description\n                               value = 1\n                               name = role.name\n                               id = role.name\n                               checked = rolcheck\n                         }, label_pos = 1 %]\n                    </td>\n                [% IF loop.even() %]\n                </tr>\n                <tr>\n                [% END %]\n                [% END %]\n                </tr>\n            </table>\n\n            <table>\n                <tr>\n                    <td>[% PROCESS button element_data = {\n                          text = text('Save Groups') #'\n                          class = \"submit\"\n                          name = \"__action\"\n                          value = \"save_user_roles\"\n                          'data-lsmb-doing' = text('Saving...')\n                          'data-lsmb-done' = text('Saved')\n                    } %]</td>\n                </tr>\n            </table></div>\n        </form>\n[% END %]\n</div></div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\n       stylesheet=\"ledgersmb.css\";\n       PROCESS elements.html;\n       PROCESS 'dynatable.html' %]\n\n<body id=\"setup-migration_step\" class=\"lsmb [% dojo_theme%]\">\n  <div><div class=\"setupconsole\">\n    <h1 style=\"font-weight: bold; margin-bottom: 1em; text-align: center\">\n        [% text('Database Management Console') %]\n    </h1>\n    [% # We cannot use form-dynatable, for it requires lsmb/Form and maindiv %]\n    <form data-dojo-type=\"lsmb/SimpleForm\"\n          method=\"post\"\n          action=\"[% form.script %]\"\n          id=\"migration-step-dynatable\">\n    [% FOREACH header IN headers %]<div class=\"listtop\">\n             [% INCLUDE decorated_text element_data = {\n                    msg => header };\n             %]</div>\n    [% END %]\n\n    [% PROCESS 'dynatable' tbody = { rows = rows } %]\n    <br />\n\n    [% FOREACH hidden IN hiddens.keys;\n        PROCESS input element_data={\n            type => 'hidden',\n            name => hidden,\n            value => hiddens.item(hidden)\n            }; END %]\n    [% FOREACH button IN buttons; PROCESS button element_data=button; END %]\n    </form>\n  </div></div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\nstylesheet=\"ledgersmb.css\"\ninclude_stylesheet=[\"system/setup.css\"] %]\n[% PROCESS elements.html %]\n<body id=\"setup-new-user\" class=\"lsmb [% dojo_theme %]\">\n  <div>\n    <div class=\"setupconsole\">\n      <h2>[% text('Database Management Console') %]</h2>\n      <div class=\"listtop\">[% text('Enter User') %]</div>\n      <form data-dojo-type=\"lsmb/SimpleForm\"\n            action=\"setup.pl\" method=\"POST\" name=\"new_user\">\n        [% INCLUDE input element_data = {\n                      name = 'database'\n                      type = 'hidden'\n                      value = database\n        } %]\n        <div style=\"display:grid;gap:0.3em;grid-template-columns:auto auto\">\n          [% INCLUDE input element_data = {\n                      name  = 'username'\n                      type  = 'text'\n                      label = text('Username')\n                      class = 'username'\n                      value = username\n                      required = 'required'\n          } %]\n          <label id=\"password-label\" for=\"password\" class=\"password\">[%\n            text('Password') %]</label>\n          [% PROCESS input element_data = {\n                      name='password'\n                      type='password'\n                      class = 'password'\n                      size='60',\n                      attributes = { autocomplete = 'off' }\n          } %]\n          <label>[% text('User creation') %]</label>\n          <div class=\"input_group\">\n            <div>\n              [%\n                label_pos = 1 ;\n                PROCESS input element_data = {\n                      label   = text(\"Create new user\")\n                      value   = '0'\n                      checked = 'CHECKED'\n                      name    = 'pls_import'\n                      type    = 'radio'\n              }\n               %]\n            </div>\n            <div style=\"float:left\">\n              [% label_pos = 1;\n                 PROCESS input element_data = {\n                      label   = text(\"Import existing user\")\n                      value   = '1'\n                      checked = ''\n                      name    = 'pls_import'\n                      type    = 'radio'\n              } ;\n              label_pos = -1;\n              %]\n            </div>\n            [%- IF notice -%]\n            <div class=\"notice\" style=\"float:left\">[% notice %]</div>\n            [%- END # IF notice -%]\n            <div data-dojo-type=\"dijit/Tooltip\"\n                 data-dojo-props=\"connectId:'pls-import-1',position:['below']\">\n              <div style=\"width:30em\">\n                <b>Import an existing user (from another database)</b>\n                <br /><br />\n                This username exists because it is being used with another\n                database; using it with the current database requires it to\n                be <em>imported</em>.\n                <br /><br />\n                <em>The password for both databases will be the same. Providing\n                  a password when importing a user, also resets the password\n                  for the other companies.\n                </em>\n                <br /><br />\n                Note that technically any existing PostgreSQL &quot;role&quot;\n                that is to be used as a username needs to be imported this way,\n                regardless of whether it is a username in a different database.\n              </div>\n            </div>\n            <div data-dojo-type=\"dijit/Tooltip\"\n                 data-dojo-props=\"connectId:'pls-import-0'\">\n              <div style=\"width:30em\">\n                <b>Creates a new user</b><br />\n                This username <em>must not</em> be used by any of the other\n                databases. If you want to use a username that is already used\n                with another database, you can do so by selecting the\n                <b>Import</b> option.\n              </div>\n            </div>\n          </div>\n          [% INCLUDE select element_data = {\n                options       = salutations\n                text_attr     = 'salutation'\n                value_attr    = 'id'\n                default_blank = 1\n                default_values = [salutation_id]\n                name           = 'salutation_id'\n                label          = 'Salutation'\n                required       = 'required'\n          };\n          INCLUDE input element_data = {\n                name     = 'first_name'\n                class    = 'name'\n                type     = 'text'\n                size     = '15'\n                value    = first_name\n                label    = text('First Name')\n                required = 'required'\n          };\n          INCLUDE input element_data = {\n                name     = 'last_name'\n                class    = 'name'\n                type     = 'text'\n                size     = '15'\n                value    = last_name\n                label    = text('Last name')\n                required = 'required'\n          };\n          INCLUDE input element_data = {\n                name = 'employeenumber'\n                class = 'control_code'\n                type = 'text'\n                size = '15'\n                label = text('Employee Number')\n                value = employeenumber\n                required = 'required'\n          };\n          INCLUDE input element_data = {\n                name = 'dob'\n                type = 'date'\n                size = '10'\n                label = text('Date of Birth')\n                value = dob\n                required = 'required'\n          };\n          INCLUDE input element_data = {\n                name = 'ssn'\n                class = 'tax_id'\n                type = 'text'\n                size = '15'\n                label = text('Tax ID/SSN')\n                value = ssn\n                required = 'required'\n          };\n          INCLUDE select element_data = {\n                options = countries\n                text_attr = 'name'\n                value_attr = 'id'\n                default_blank = 1\n                default_values = [country_id]\n                name = 'country_id'\n                label = 'Country'\n                required = 'required'\n          };\n          INCLUDE select element_data = {\n                options = perm_sets\n                text_attr = 'label'\n                value_attr = 'id'\n                name = 'perms'\n                default_blank = 1\n                default_values = [perms]\n                label = 'Assign Permissions'\n                required = 'required'\n          };\n          INCLUDE button element_data = {\n                text = text('Create User') #';\n                name = '__action'\n                value = save_action\n                type = 'submit'\n                class = 'submit'\n          } %]\n        </div>\n      </form>\n    </div>\n  </div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\nstylesheet=\"ledgersmb.css\"\ninclude_stylesheet=[\"system/setup.css\"] %]\n[% PROCESS elements.html %]\n<body id=\"setup-select-coa\" class=\"lsmb [% dojo_theme %]\">\n<div class=\"setupconsole\">\n<h2>[% text('Database Management Console') %]</h2>\n<div><div class=\"listtop\">[% title %]</div>\n<form data-dojo-type=\"lsmb/SimpleForm\" action=\"setup.pl\" method=\"POST\" name=\"credentials\">\n  <div id=\"sep\" class=\"listheading\">\n    Pre-defined Chart-of-Accounts selection\n  </div>\n\n  [% IF coa_lc;\n   INCLUDE input element_data = {\n        name = 'coa_lc'\n        type = 'hidden'\n       value = coa_lc\n         } ;\n         %]\n  <p>\n    The selected country ('[% coa_lc %]') has the following charts\n    predefined.\n  </p>\n  [% ELSE %]\n  <p>\n    Please select a country from the list of countries with predefined\n    charts of accounts, or select Skip and define or import accounts and\n    headings later. Please do take note that you want to load a chart\n    for evaluation purposes as many functions depend on accounts of\n    certain types being defined.\n  </p>\n  [% END %]\n<div class=\"inputrow\">\n[% IF coa_lc;\n    INCLUDE select element_data = {\n         options = charts\n            name = 'chart'\n       text_attr = 'name'\n      value_attr = 'name'\n           label = text('Chart of accounts')\n    };\n    IF gifis.size > 0;\n-%]\n</div>\n<div class=\"inputrow\">\n[%\n       INCLUDE select element_data = {\n         options = gifis\n            name = 'gifi'\n       text_attr = 'name'\n      value_attr = 'name'\n           label = text('GIFI')\n       };\n    END;\n    IF sics.size > 0;\n-%]\n</div>\n<div class=\"inputrow\">\n[%\n       INCLUDE select element_data = {\n         options = sics\n            name = 'sic'\n       text_attr = 'name'\n      value_attr = 'name'\n           label = text('SIC')\n       };\n    END;\n   ELSE;\n    INCLUDE select element_data = {\n         options = coa_lcs\n            name = 'coa_lc'\n       text_attr = 'name'\n      value_attr = 'code'\n           label = text('Country') #'\n    };\nEND %]\n</div>\n<div class=\"inputrow\">\n[% INCLUDE input element_data = {\n    name = 'database'\n   value = database\n    type = 'hidden'\n} %]\n</div>\n<div class=\"inputrow\">\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'select_coa'\n    type = 'submit'\n   class = 'submit'\n    text = text('Next')\n} %]\n</div>\n<div class=\"inputrow\">\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'skip_coa'\n    type = 'submit'\n   class = 'submit'\n    text = text('Skip')\n} %]\n</div>\n</form>\n</div></div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\n       stylesheet=\"ledgersmb.css\"\n       include_stylesheet=[\"system/setup.css\"] ;\n    PROCESS \"elements.html\"\n%]<body id=\"setup-template-info\" class=\"lsmb [% dojo_theme %]\">\n<div><div class=\"setupconsole\">\n<h2>[% text('Database Management Console') %]</h2>\n<form data-dojo-type=\"lsmb/SimpleForm\" action=\"setup.pl\" method=\"post\">\n<div class=\"listtop\">[% text('Select Templates to Load') %]</div>\n[%\nPROCESS input element_data = {\n    type = \"hidden\"\n    name = \"database\"\n   value = database\n};\nPROCESS input element_data = {\n    type = \"hidden\"\n    name = \"only_templates\"\n   value = only_templates\n};\nPROCESS select element_data = {\n       name = \"template_dir\"\n    options = template_dirs\n      label = text('Templates')\n} %]<br />\n[% PROCESS button element_data = {\n      name = \"__action\"\n     value = templates_action\n      text = text('Load Templates') #'\n} %]\n</form>\n</div></div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\nstylesheet=\"ledgersmb.css\"\ninclude_stylesheet=[\"system/setup.css\"] %]\n[% PROCESS elements.html %]\n<body id=\"setup-upgrade-info\" class=\"lsmb [% dojo_theme %]\">\n<div><div class=\"setupconsole\">\n<h2>[% text('Database Management Console') %]</h2>\n<div class=\"listtop\">[% text('Upgrade Info') %]</div>\n<form data-dojo-type=\"lsmb/SimpleForm\"\n      action=\"setup.pl\" method=\"POST\"\n      name=\"upgrade_info\">\n[% INCLUDE input element_data = {\n    name = 'database'\n    type = 'hidden'\n   value = database\n};\nINCLUDE input element_data = {\n    name = 'slschema'\n    type = 'hidden'\n   value = slschema\n};\nINCLUDE input element_data = {\n    name = 'lsmbversion'\n    type = 'hidden'\n   value = lsmbversion\n} %]\n<div class=\"form\">\n<p>\n  [% text('LedgerSMB has introduced three new system wide default values which ' _\n              'you will need to set as part of the upgrade process.') %]\n</p>\n<p>\n  [% text('In addition to these new defaults LedgerSMB 1.3 adds stricter ' _\n              'checks on data validity in the database. Because of these stricter checks ' _\n              'it''s no longer valid to leave companies without a country or customers ' _\n              'without accounts receivable reference. The defaults you choose below will ' _\n              'be used to add values where these are currently missing but required.') %]\n</p>\n<div class=\"input_row\">\n[% INCLUDE select element_data = {\n                          options = default_country\n                            name  = 'default_country'\n                           label  = text('Default Country') #'\n                            class = 'country'\n} %]\n</div>\n[% IF default_ar.size > 1; %]\n<div class=\"input_row\">\n<p>\n  [% text('LedgerSMB supports multiple <em>Accounts receivable (AR)</em> accounts ' _\n              'per company. One of those must be the system default. Please select ' _\n              'your default below in case of multiple. If the list below is empty, ' _\n              'your database is in an inconsistent state and needs to be fixed first.') %]\n</p>\n[% INCLUDE select element_data = {\n                            name  = 'default_ar'\n                           label  = text('Default AR') #'\n                            class = 'accno'\n                            options = default_ar\n} %]\n</div>\n[% ELSE;\nINCLUDE input element_data = {\n    name = 'default_ar'\n    type = 'hidden'\n   value = default_ar\n};\nEND %]\n[% IF default_ap.size > 1; %]\n<div class=\"input_row\">\n<p>\n  [% text('LedgerSMB supports multiple <em>Accounts payable (AP)</em> accounts ' _\n              'per company. One of those must be the system default. Please select ' _\n              'your default below in case of multiple. If the list below is empty, ' _\n              'your database is in an inconsistent state and needs to be fixed first.') %]\n</p>\n[% INCLUDE select element_data = {\n                            name  = 'default_ap'\n                           label  = text('Default AP') #'\n                            class = 'accno'\n                            options = default_ap\n} %]\n</div>\n[% ELSE;\nINCLUDE input element_data = {\n    name = 'default_ap'\n    type = 'hidden'\n   value = default_ap\n};\nEND %]\n<div class=\"input_row\">\n<p>\n  [% text('Note that the process invoked by hitting the button below might ' _\n              'take long to complete as it will run the upgrade process and will ' _\n              'copy all data from the 1.2 tables into the 1.3 tables.') %]\n</p>\n[% INCLUDE button element_data = {\n    text = text('Upgrade')\n    name = '__action'\n   value = upgrade_action\n    type = 'submit'\n   class = 'submit'\n} %]\n</div>\n</div>\n</form>\n</div></div>\n</body>\n[% END %]\n", "\npackage LedgerSMB;\n\n=head1 NAME\n\nLedgerSMB - The Base class for many LedgerSMB objects, including DBObject.\n\n=head1 DESCRIPTION\n\nThis module creates a basic request handler with utility functions available\nin database objects (LedgerSMB::DBObject)\n\n=head1 METHODS\n\n=over\n\n=item new ()\n\nThis method creates a new base request instance. It also validates the\nsession/user credentials, as appropriate for the run mode.  Finally, it sets up\nthe database connections for the user.\n\n=item open_form()\n\nThis sets a $self->{form_id} to be used in later form validation (anti-XSRF\nmeasure).\n\n=item close_form()\n\nThis returns true if the form_id was associated with the session, and false if\nnot and also removes the form_id from the\nsession.\n\n=item is_allowed_role({allowed_roles => @role_names})\n\nThis function returns 1 if the user's roles include any of the roles in\n@role_names.\n\n=item merge ($hashref, keys => @list, index => $number);\n\nThis command merges the $hashref into the current object.  If keys are\nspecified, only those keys are used.  Otherwise all keys are merged.\n\nIf an index is specified, the merged keys are given a form of\n\"$key\" . \"_$index\", otherwise the key is used on both sides.\n\n\n=item get_relative_url\n\nReturns the script and query string part of the URL of the GET request,\nwithout the script path, or undef.\n\nReturns a URL-decoded string to prevent double-encoding when the URL\nis round-tripped.x\n\n=cut\n\n=item upload([$filename])\n\nThis function returns - when called without arguments - the number of\nfiles in the upload data when called in scalar context or the names\nof the files when called in list context.\n\nCalling the function with a filename argument returns a filehandle\nto the content.\n\n=item call_procedure( procname => $procname, args => $args )\n\nFunction that allows you to call a stored procedure by name and map the appropriate argument to the function values.\n\nArgs is an arrayref.  The members of args can be scalars or arrayrefs in which\ncase they are just bound to the placeholders (arrayref to Pg array conversion\noccurs automatically in DBD::Pg 2.x), or they can be hashrefs of the following\nsyntax: {value => $data, type=> $db_type}.  The type field is any SQL type\nDBD::Pg supports (such as 'PG_BYTEA').\n\n=item dberror()\n\nLocalizes and returns database errors and error codes within LedgerSMB\n\n=item error()\n\nReturns HTML errors in LedgerSMB. Needs refactored into a general Error class.\n\n=item get_user_info()\n\nLoads user configuration info from LedgerSMB::User\n\n=item initialize_with_db\n\nThis function sets up the db handle for the request\n\n=item system_info($dbh)\n\nReturns a hashref with the keys being system information sections,\neach being a hashref detailing configuration items with their values.\n\n=item setting()\n\nAccessor method and lazy initialisation for a shared LedgerSMB::Setting\ninstance.\n\nReturns a reference to an initialised LedgerSMB::Setting instance.\n\n=item all_months()\n\nReturns hashref of localized date data with following members:\n\n=over\n\n=item dropdown\n\nMonth information in drop down format.\n\n=item hashref\n\nMonth info in hashref format in 01 => January format\n\n=back\n\n=item all_years()\n\nReturns hashref of localized date data with following members:\n\n=over\n\n=item dropdown\n\nMonth information in drop down format.\n\n=item hashref\n\nMonth info in hashref format in 01 => January format\n\n=back\n\n=item enabled_languages()\n\nReturns arrayref of hashes with the following keys:\n\n=over\n\n=item value\n\nThe code of the language as per the CLDR\n\n=item text\n\nThe name of the language, translated into the user's selected language\n\n=back\n\n=item enabled_countries()\n\nReturns arrayref of hashes with the following keys:\n\n=over\n\n=item id\n\nThe internal identifier for the country\n\n=item short_name\n\nThe 2-leter iso code of the country\n\n=item name\n\nThe country's full name translated into the user's selected language\n\n=back\n\n=item report_renderer_ui\n\nReturns a code reference to render a report on the UI - pass as the\nnamed argument 'renderer' to the C<LedgerSMB::Report->render> method.\n\n  my $report = LedgerSMB::Report\n  $report->render( renderer => $request->report_renderer_ui);\n\n\n=item report_renderer_doc\n\nReturns a code reference to render a report as a document - pass as the\nnamed argument 'renderer' to the C<LedgerSMB::Report->render> method.\n\n  my $report = LedgerSMB::Report\n  $report->render( renderer => $request->report_renderer_doc);\n\n\n=item render_report($report)\n\nRenders the report as a document or UI element, depending on whether\nthe request's C<format> property has a non-false value.\n\n\n=item parse_amount($amount)\n\nParses the $amount given the session user's number formatting settings.\n\n=item parse_date($date)\n\nParses the $date given the session user's date formatting settings.\n\n=item format_amount($amount, %args)\n\nformats the $amount given the session user's number formatting settings.\n\n=item formatter_options()\n\nReturns a hashref containing the session user's number and date formatting\npreferences for use in LedgerSMB::Report-s.\n\n=back\n\n\n=head1 Copyright (C) 2006-2023, The LedgerSMB core team.\n\n # This work contains copyrighted information from a number of sources\n # all used with permission.\n #\n # This file contains source code included with or based on SQL-Ledger\n # which is Copyright Dieter Simader and DWS Systems Inc. 2000-2005\n # and licensed under the GNU General Public License version 2 or, at\n # your option, any later version.  For a full list including contact\n # information of contributors, maintainers, and copyright holders,\n # see the CONTRIBUTORS file.\n #\n # Original Copyright Notice from SQL-Ledger 2.6.17 (before the fork):\n # Copyright (C) 2000\n #\n #  Author: DWS Systems Inc.\n #     Web: http://www.sql-ledger.org\n #\n # Contributors: Thomas Bayen <bayen@gmx.de>\n #               Antti Kaihola <akaihola@siba.fi>\n #               Moritz Bunkus (tex)\n #               Jim Rawlings <jim@your-dba.com> (DB2)\n #====================================================================\n=cut\n\nuse strict;\nuse warnings;\n\nuse Carp;\nuse DateTime::Format::Duration::ISO8601;\nuse Encode qw(perlio_ok);\nuse HTTP::Headers::Fast;\nuse HTTP::Status qw( HTTP_OK );\nuse List::Util qw( pairgrep );\nuse Locale::CLDR;\nuse Locales unicode => 1;\nuse Log::Any;\nuse PGObject;\nuse Plack;\nuse URI;\nuse URI::Escape;\n\nuse LedgerSMB::Company_Config;\nuse LedgerSMB::Locale;\nuse LedgerSMB::PGDate;\nuse LedgerSMB::PGNumber;\nuse LedgerSMB::PSGI::Util qw( template_response );\nuse LedgerSMB::Setting;\nuse LedgerSMB::Template;\nuse LedgerSMB::User;\n\nour $VERSION = '1.12.0-dev';\n\nmy $logger = Log::Any->get_logger(category => 'LedgerSMB');\nmy $expiration_parser = DateTime::Format::Duration::ISO8601->new;\n\nsub new {\n    my ($class, $request, $wire) = @_;\n    my $self = {};\n    bless $self, $class;\n\n    # Properties prefixed with underscore are hidden from UI templates.\n    #\n    # Some tests construct LedgerSMB objects without $auth argument\n    # (in fact, without any arguments), so check for having an $auth\n    # arg before trying to call methods on it.\n    $self->{login} = $request->env->{'lsmb.session'}->{login};\n    $self->{version} = $VERSION;\n    $self->{dbversion} = $VERSION;\n    $self->{_uploads} = $request->uploads if defined $request->uploads;\n    $self->{_cookies} = $request->cookies if defined $request->cookies;\n    $self->{query_string} = $request->query_string if defined $request->query_string;\n    $self->{script} = $request->env->{'lsmb.script'};\n    $self->{dbh} = $request->env->{'lsmb.app'};\n    $self->{company} = $request->env->{'lsmb.session'}->{company};\n    $self->{_session_id} = $request->env->{'lsmb.session_id'};\n    $self->{_create_session} = $request->env->{'lsmb.create_session_cb'};\n    $self->{_logout} = $request->env->{'lsmb.invalidate_session_cb'};\n    $self->{_setting} = $request->env->{'lsmb.setting'};\n    $self->{_req} = $request;\n    $self->{_wire} = $wire;\n\n    my $q = $self->{query_string} // '';\n    $self->{_uri} = URI->new(\n        $request->env->{'lsmb.script'} . ($q ? \"?$q\" : ''),\n        $request->request_uri\n        );\n\n    # Initialize ourselves from parameters in $self->{_req}\n    $self->_process_args;\n    $self->_set_default_locale();\n\n    return $self;\n}\n\nsub open_form {\n    my ($self) = @_;\n    my @vars = $self->call_procedure(procname => 'form_open',\n                              args => [$self->{_session_id}],\n                              continue_on_error => 1\n    );\n    return $self->{form_id} = $vars[0]->{form_open};\n}\n\nsub close_form {\n    my ($self) = @_;\n    my @vars = $self->call_procedure(funcname => 'form_close',\n                              args => [$self->{_session_id}, $self->{form_id}]\n    );\n    delete $self->{form_id};\n    return $vars[0]->{form_close};\n}\n\nsub initialize_with_db {\n    my ($self) = @_;\n    my $sth;\n\n\n    $sth = $self->{dbh}->prepare('SELECT check_expiration()')\n        or die $self->{dbh}->errstr;\n    $sth->execute or die $sth->errstr;\n    ($self->{warn_expire}) = $sth->fetchrow_array;\n\n    if ($self->{warn_expire}){\n        $sth = $self->{dbh}->prepare('SELECT user__check_my_expiration()')\n            or die $self->{dbh}->errstr;\n        $sth->execute or die $sth->errstr;\n        my ($pw_expires) = $sth->fetchrow_array;\n        $self->{pw_expires} = $expiration_parser->parse_duration($pw_expires);\n    }\n\n    $self->{_company_config} =\n        LedgerSMB::Company_Config::initialize($self->{dbh});\n\n    $self->get_user_info;\n\n    $self->{_locale} =\n        LedgerSMB::Locale->get_handle($self->{_user}->{language})\n        or $self->error(__FILE__.':'.__LINE__.\": Locale not loaded: $!\\n\");\n\n    $self->{stylesheet} =\n        $self->{_user}->{stylesheet} unless $self->{stylesheet};\n\n    return;\n}\n\n\nsub get_user_info {\n    my ($self) = @_;\n    $self->{_user} = LedgerSMB::User->fetch_config($self);\n    return $self->{_user}->{language} ||= 'en';\n}\n\nsub _set_default_locale {\n    my ($self) = @_;\n\n    my $lang = $self->{_wire}->get( 'default_locale' )\n        ->from_header( $self->{_req}->header( 'Accept-Language' ) );\n\n    $self->{_user}->{language} = $lang;\n    $self->{_user}->{dateformat} = 'YYYY-MM-DD';\n    $self->{_user}->{numberformat} = '1000.00';\n    $self->{_locale}=LedgerSMB::Locale->get_handle($lang);\n    $self->error( __FILE__ . ':' . __LINE__\n                  . \": Locale ($lang) not loaded: $!\\n\" )\n        unless $self->{_locale};\n\n    return;\n}\n\nsub _process_args {\n    my ($self) = @_;\n\n    # Prefer body parameters over query string parameters\n    # Normally, they shouldn't both be present, but there's at least a bug in\n    # Safari 15 which submits query parameters, even when told not to.\n    #\n    # $self->{_req}->parameters values query and body parameters equally, causing\n    # them to be collected into arrays when both are specified. This way, we\n    # prefer one over the other instead.\n    for my $args ($self->{_req}->query_parameters, $self->{_req}->body_parameters) {\n        for my $key (keys %$args){\n            my @values = grep { defined $_ && $_ ne '' } $args->get_all($key);\n            next if ! @values;\n\n            my $value = (@values == 1) ? $values[0] : \\@values;\n            next if $value eq '_!lsmb!empty!_';\n\n            $self->{$key} = $value;\n        }\n    }\n    return;\n}\n\nsub upload {\n    my ($self, $name) = @_;\n\n    if (! defined $name) {\n        return map { $_->basename } $self->{_uploads}->values;\n    }\n\n    my $upload = $self->{_uploads}->get($name) or return undef;\n    my $tmpfname = $upload->path;\n\n    my $headers = HTTP::Headers::Fast->new(\n        Content_Type => $upload->content_type\n    );\n    my $encoding = ':bytes';\n    my $charset = $headers->content_type_charset;\n    if ($charset) {\n        if (perlio_ok $charset) {\n            $encoding = ':encoding(' . $charset . ')';\n        }\n        else {\n            die \"Unsupported PerlIO encoding: $charset\";\n        }\n    }\n\n    open my $fh, \"<$encoding\", $tmpfname\n        or die \"Can't open uploaded temporary file $tmpfname: $!\";\n\n    my $bom_length = 0;\n    if (! $charset\n        && ($headers->content_is_text\n            || $headers->content_is_xml)\n        && -s $tmpfname >= 4) {\n        sysread $fh, my $bytes, 4;\n        if (\"\\xFF\\xFE\" eq substr($bytes, 0, 2)) {\n            $encoding = 'UTF-16LE';\n            $bom_length = 2;\n        }\n        elsif (\"\\xFE\\xFF\" eq substr($bytes, 0, 2)) {\n            $encoding = 'UTF-16BE';\n            $bom_length = 2;\n        }\n        elsif (\"\\xEF\\xBB\\xBF\" eq substr($bytes, 0, 3)) {\n            $encoding = 'UTF-8';\n            $bom_length = 3;\n        }\n        elsif (\"\\x00\\x00\\xFE\\xFF\" eq $bytes) {\n            $encoding = 'UTF-32LE';\n            $bom_length = 4;\n        }\n        elsif (\"\\xFF\\xFE\\x00\\x00\" eq $bytes) {\n            $encoding = 'UTF-32BE';\n            $bom_length = 4;\n        }\n        else { # no BOM\n            $encoding = 'UTF-8';\n            $bom_length = 0;\n        }\n        sysseek $fh, 0, 0;\n    }\n\n    if ($encoding) {\n        binmode $fh, ':encoding(' . $encoding . ')';\n    }\n    if ($bom_length) {\n        read($fh, my $unused, 1); # read the bom character\n    }\n\n    return $fh;\n}\n\nsub call_procedure {\n    my $self = shift;\n    my %args = @_;\n    $args{funcschema} ||= $self->{_wire}->get( 'db' )->schema;\n    $args{funcname} ||= $args{procname};\n    $args{dbh} = $self->{dbh};\n    $args{args} ||= [];\n    return PGObject->call_procedure(%args);\n}\n\n# Keeping this here due to common requirements\nsub is_allowed_role {\n    my ($self, $args) = @_;\n    my ($access) =  $self->call_procedure(\n         procname => 'lsmb__is_allowed_role', args => [$args->{allowed_roles}]\n    );\n    return $access->{lsmb__is_allowed_role};\n}\n\nsub error {\n    my ($self, $msg) = @_;\n    Carp::croak $msg;\n}\n\n\n# Database routines used throughout\n\nsub dberror{\n   my $self = shift @_;\n   my $state_error = {};\n   my $locale = $self->{_locale};\n   my $dbh = $self->{_dbh};\n   $state_error = {\n            '42883' => $locale->text('Internal Database Error'),\n            '42501' => $locale->text('Access Denied'),\n            '42401' => $locale->text('Access Denied'),\n            '22008' => $locale->text('Invalid date/time entered'),\n            '22012' => $locale->text('Division by 0 error'),\n            '22004' => $locale->text('Required input not provided'),\n            '23502' => $locale->text('Required input not provided'),\n            '23505' => $locale->text('Conflict with Existing Data.  Perhaps you already entered this?'),\n            'P0001' => $locale->text('Error from Function:') . \"\\n\" .\n                    $dbh->errstr,\n   };\n   $logger->error(\"Logging SQL State $dbh->state, error $dbh->err, string $dbh->errstr\");\n\n   if (defined $state_error->{$dbh->state}){\n       die $state_error->{$dbh->state}\n           . \"\\n\" .\n          $locale->text('More information has been reported in the error logs');\n   }\n   die $dbh->state . ':' . $dbh->errstr;\n}\n\nsub merge {\n    my ( $self, $src ) = @_;\n    for my $arg ( $self, $src ) {\n        shift;\n    }\n    my %args  = @_;\n    my @keys;\n    if (defined $args{keys}){\n         @keys  = @{ $args{keys} };\n    }\n    my $index = $args{index};\n    if ( !scalar @keys ) {\n        @keys = keys %{$src};\n    }\n    for my $arg ( @keys ) {\n        my $dst_arg;\n        if ($index) {\n            $dst_arg = $arg . \"_$index\";\n        }\n        else {\n            $dst_arg = $arg;\n        }\n        $self->{$dst_arg} = $src->{$arg};\n    }\n    return;\n}\n\nsub system_info {\n    my ($dbh) = @_;\n\n    return {\n        system => {\n            perl => $^V->stringify,\n            LedgerSMB => $VERSION,\n            Plack => $Plack::VERSION,\n            INCLUDE_PATH => join(\"\\n\", @INC),\n        }\n    };\n}\n\nsub setting {\n    my ($self) = @_;\n\n    unless($self->{_setting}) {\n        $self->{dbh} or croak(\n            'cannot initialise LedgerSMB::Setting object -'.\n            'database handler is undefined'\n        );\n        $self->{_setting} = LedgerSMB::Setting->new();\n        $self->{_setting}->set_dbh($self->{dbh});\n    }\n\n    return $self->{_setting};\n}\n\nsub all_months {\n    my ($self) = @_;\n    my $i18n = $self->{_locale};\n    my $months = {\n     '01' => $i18n->text('January'),\n     '02' => $i18n->text('February'),\n     '03' => $i18n->text('March'),\n     '04' => $i18n->text('April'),\n     '05' => $i18n->text('May'),\n     '06' => $i18n->text('June'),\n     '07' => $i18n->text('July'),\n     '08' => $i18n->text('August'),\n     '09' => $i18n->text('September'),\n     '10' => $i18n->text('October'),\n     '11' => $i18n->text('November'),\n     '12' => $i18n->text('December'),\n    };\n\n    my $for_dropdown = [];\n    my $as_hashref = {};\n    for my $key (sort {$a cmp $b} keys %$months){\n        push @$for_dropdown, {text => $months->{$key}, value => $key};\n    }\n    return { as_hashref => $months, dropdown=> $for_dropdown };\n}\n\nsub all_years {\n    my ($self) = @_;\n\n    my @years = $self->call_procedure(\n        funcname => 'date_get_all_years'\n        );\n\n    return { as_hashref => \\@years,\n             dropdown => [ map { +{ text => $_->{date_get_all_years},\n                                    value => $_->{date_get_all_years} }\n                           } @years ] };\n}\n\nsub enabled_languages {\n    my ($self) = @_;\n\n    my $l = Locales->new( $self->{_user}->{language} );\n    return [\n        map {\n            +{\n                value => $_->{code},\n                text => ucfirst($l->get_language_from_code($_->{code})\n                                // $_->{description})\n            }\n        } $self->call_procedure(funcname => 'person__list_languages')\n        ];\n}\n\nsub enabled_countries {\n    my ($self) = @_;\n\n    my $regions = Locale::CLDR->new($self->{_user}->{language})->all_regions;\n    return [\n        map {\n            +{\n                $_->%*,\n                name => $regions->{$_->{short_name}} // $_->{name}\n            }\n        } $self->call_procedure(funcname => 'location_list_country')\n        ];\n}\n\nsub report_renderer_ui {\n  my ($request) = @_;\n  my $ui = $request->{_wire}->get('ui');\n  my $uri = $request->{_uri}->clone;\n  if (not pairgrep { $a eq 'company' } $uri->query_form) {\n      $uri->query_form(\n          $uri->query_form,\n          company => $request->{company},\n          );\n  }\n\n  return sub {\n      my ($template_name, $report, $vars, $cvars) = @_;\n      $vars->{REPORT_LINK} = $uri->as_string;\n      $vars->{SCRIPT} = $request->{script};\n      $vars->{SETTINGS} = {\n          papersize    => 'letter', # default paper size when not configured\n          (%{$request->{_company_config} // {}},)\n      };\n      $vars->{SETTINGS}->{company_name} ||= $request->{company};\n      $vars->{HIDDENS} = $request->{hiddens};\n      $vars->{FORM_ID} = $request->{form_id};\n\n      return $ui->render($request, \"Reports/$template_name\", $vars, $cvars);\n  };\n}\n\nsub report_renderer_doc {\n    my ($request) = @_;\n    my $renderer =\n        $request->{_wire}->get( 'output_formatter' )->report_doc_renderer(\n            $request->{_dbh},\n            $request->formatter_options,\n            uc($request->{format}) || 'HTML',\n            {\n                SETTINGS => {\n                     # default paper size when not configured\n                    papersize    => 'letter',\n                    (%{$request->{_company_config} // {}},)\n                }\n            });\n\n    return sub {\n        my ($template_name, $report, $vars, $cvars) = @_;\n\n        return template_response(\n            $renderer->( $template_name, $report, $vars, $cvars ),\n            disposition => 'attach' );\n    };\n}\n\n\nsub render_report {\n    my ($request, $report) = @_;\n\n    my $renderer;\n    if ($request->{format}) {\n        # render as (stand alone) document\n        $renderer = $request->report_renderer_doc;\n    }\n    else {\n        # render as UI element\n        $renderer = $request->report_renderer_ui;\n    }\n    return $report->render( renderer => $renderer);\n}\n\n\nsub parse_amount {\n    my ($request, $amount_str) = @_;\n    my $config = $request->{_user};\n\n    return LedgerSMB::PGNumber->from_input(\n        $amount_str,\n        format => $config->{numberformat}\n        );\n}\n\nsub parse_date {\n    my ($request, $date_str) = @_;\n    my $config = $request->{_user};\n\n    return LedgerSMB::PGDate->from_input(\n        $date_str,\n        format => $config->{dateformat}\n        );\n}\n\nsub format_amount {\n    my ($request, $amount, %args) = @_;\n    my $config = $request->{_user};\n\n    return $amount->to_output(\n        format => $config->{numberformat},\n        money_places => $LedgerSMB::Company_Config::settings->{decimal_places},\n        %args\n        );\n}\n\nsub formatter_options {\n    my ($request) = @_;\n    my $config = $request->{_user};\n\n    return {\n        $config->%{ qw( numberformat dateformat ) },\n        money_places => $LedgerSMB::Company_Config::settings->{decimal_places},\n    };\n}\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (C) 2006-2023 The LedgerSMB Core Team\n\nThis file is licensed under the GNU General Public License version 2, or at your\noption any later version.  A copy of the license should have been included with\nyour software.\n\n=cut\n\n\n1;\n", "\npackage LedgerSMB::Middleware::SessionStorage;\n\n=head1 NAME\n\nLedgerSMB::Middleware::SessionStorage - Client side session (cookie) storage\n\n=head1 SYNOPSIS\n\n builder {\n   enable \"+LedgerSMB::Middleware::SessionStorage\",\n         domain   => 'setup',\n         cookie   => 'LedgerSMB/setup',\n         duration => 15*60;\n   $app;\n }\n\n=head1 DESCRIPTION\n\nLedgerSMB::Middleware::SessionStorage makes sure session state exists\n(but empty if it didn't exist before) and is persisted at the end of\nthe request.\n\n=cut\n\nuse strict;\nuse warnings;\nuse parent qw ( Plack::Middleware );\n\nuse Cookie::Baker;\nuse Plack::Request;\nuse Plack::Util;\nuse Plack::Util::Accessor\n    qw( cookie cookie_path domain duration inner_serialize secret store );\nuse Session::Storage::Secure;\n\nuse LedgerSMB::PSGI::Util;\n\n=head1 METHODS\n\n=head2 $self->prepare_app\n\nImplements C<Plack::Component->prepare_app()>.\n\n=head2 $self->call($env)\n\nImplements C<Plack::Middleware->call()>.\n\n=cut\n\nsub prepare_app {\n    my $self = shift;\n    my $store = Session::Storage::Secure->new(\n        secret_key => $self->secret,\n        default_duration => 24*60*60*90, # 90 days\n        );\n    $self->store( $store );\n}\n\nsub call {\n    my $self = shift;\n    my ($env) = @_;\n    my $req = Plack::Request->new($env);\n\n    my $cookie      = $req->cookies->{$self->cookie};\n    my $session     = $self->store->decode($cookie);\n\n    my $secure = defined($env->{HTTPS}) && $env->{HTTPS} eq 'ON';\n    my $path =\n        $self->cookie_path //\n        LedgerSMB::PSGI::Util::cookie_path($env->{SCRIPT_NAME});\n    $env->{'lsmb.session'} = $session;\n    return Plack::Util::response_cb(\n        $self->app->($env), sub {\n            my $res = shift;\n\n            if (! $self->inner_serialize) {\n                my $_cookie_attributes = {\n                    value    => $self->store->encode(\n                        $env->{'lsmb.session'},\n                        time + ($env->{'lsmb.session.duration'}\n                                // $self->duration)),\n                    httponly => 1,\n                    path     => $path,\n                    secure   => $secure,\n                    samesite => 'Strict',\n                    expires  => ($env->{'lsmb.session.expire'}\n                                    ? '1' : undef),\n                };\n                Plack::Util::header_push(\n                    $res->[1], 'Set-Cookie',\n                    bake_cookie(\n                        $self->cookie,\n                        $_cookie_attributes\n                    ));\n            }\n        });\n}\n\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (C) 2020-2024 The LedgerSMB Core Team\n\nThis file is licensed under the GNU General Public License version 2, or at your\noption any later version.  A copy of the license should have been included with\nyour software.\n\n=cut\n\n\n1;\n", "package LedgerSMB::PSGI;\n\n=head1 NAME\n\nLedgerSMB::PSGI - PSGI application routines for LedgerSMB\n\n=head1 DESCRIPTION\n\nMaps the URL name space to the various entry points.\n\n=head1 SYNOPSIS\n\n use LedgerSMB::PSGI;\n my $app = LedgerSMB::PSGI->get_app();\n\n=head1 METHODS\n\nThis module doesn't specify any (public) methods.\n\n=cut\n\nuse strict;\nuse warnings;\n\nuse LedgerSMB;\nuse LedgerSMB::App_State;\nuse LedgerSMB::Company_Config;\nuse LedgerSMB::oldHandler;\nuse LedgerSMB::Magic qw( SCRIPT_NEWSCRIPTS );\nuse LedgerSMB::PSGI::Util;\nuse LedgerSMB::Router keywords => [ qw( router ) ];\nuse LedgerSMB::Routes::ERP::API::Accounts;\nuse LedgerSMB::Routes::ERP::API::Contacts;\nuse LedgerSMB::Routes::ERP::API::Countries;\nuse LedgerSMB::Routes::ERP::API::Goods;\nuse LedgerSMB::Routes::ERP::API::GeneralLedger;\nuse LedgerSMB::Routes::ERP::API::Invoices;\nuse LedgerSMB::Routes::ERP::API::MenuNodes;\nuse LedgerSMB::Routes::ERP::API::Languages;\nuse LedgerSMB::Routes::ERP::API::Products;\nuse LedgerSMB::Routes::ERP::API::Session;\nuse LedgerSMB::Routes::ERP::API::Templates;\nuse LedgerSMB::Setting;\n\nuse CGI::Emulate::PSGI;\nuse HTTP::Status qw( HTTP_FOUND );\nuse List::Util qw{  none };\nuse Log::Any;\nuse Log::Log4perl;\nuse Scalar::Util qw{ reftype };\nuse String::Random;\nuse Feature::Compat::Try;\n\n# To build the URL space\nuse Plack;\nuse Plack::Builder;\nuse Plack::Request::WithEncoding;\nuse Plack::App::File;\nuse Plack::Middleware::ConditionalGET;\nuse Plack::Middleware::ReverseProxy;\nuse Plack::Builder::Conditionals;\nuse Plack::Util;\n\n\nuse English;\nif ($EUID == 0) {\n    die join(\"\\n\",\n        'Running a Web Service as root is a security problem.',\n        'If you are starting LedgerSMB as a system service,',\n        'please make sure that you drop privileges as per README.md',\n        'and the example files in doc/conf/.',\n        'The method of passing a --user argument to starman cannot',\n        'be used as starman drops privileges too late, starting us as root.'\n    );\n}\n\nlocal $@ = undef; # localizes just for initial load.\neval { require LedgerSMB::Template::LaTeX; };\n\n=head1 FUNCTIONS\n\n=over\n\n=item old_app\n\nReturns a 'PSGI app' which handles requests for the 'old-code' scripts in old/bin/\n\n=cut\n\nsub old_app {\n    my $script = shift;\n    my $wire = shift;\n\n    # marshall the psgi environment into the cgi environment\n    # so we can re-use state from the various middlewares\n    return sub {\n        my $env = shift;\n\n        return Plack::Util::response_cb(\n            CGI::Emulate::PSGI->handler(\n                sub {\n                    local $ENV{CONTENT_LENGTH} = $ENV{CONTENT_LENGTH} // 0;\n\n                    if (my $cpid = fork()){\n                        waitpid $cpid, 0;\n                    } else {\n                        # make 100% sure any \"die\"-s don't bubble up higher than\n                        # this point in the stack: we're a fork()ed process and\n                        # should under no circumstance end up acting like another\n                        # worker. When we are done, we need to exit() below.\n                        try {\n                            local ($!, $@) = (undef, undef);\n                            # the lsmb_legacy package is created by the\n                            # oldHandler use statement\n                            unless ( lsmb_legacy->handle($script, $env, $wire) ) { ## no critic (RequireExplicitInclusion)\n                                if ($! or $@) {\n                                    print \"Status: 500 Internal server error (PSGI.pm)\\n\\n\";\n                                    warn \"Failed to execute old request ($!): $@\\n\";\n                                }\n                            }\n                        }\n                        catch ($e) {\n                        }\n                        exit;\n                    }\n                    return;\n                }\n            )->($env),\n            sub {\n                Plack::Util::header_set($_[0]->[1],\n                                        'Content-Security-Policy',\n                                        q{frame-ancestors 'self'});\n                if (not Plack::Util::header_exists($_[0]->[1],\n                                                   'X-LedgerSMB-App-Content')) {\n                    Plack::Util::header_push($_[0]->[1],\n                                             'X-LedgerSMB-App-Content', 'yes');\n                }\n            });\n    }\n}\n\n\n=item psgi_app\n\nImplements a PSGI application for the purpose of calling the entry-points\nin LedgerSMB::Scripts::*.\n\n=cut\n\n\nsub psgi_app {\n    my $wire = shift;\n\n    return sub {\n        my $env = shift;\n        my $psgi_req = Plack::Request::WithEncoding->new($env);\n        my $request = LedgerSMB->new($psgi_req, $wire);\n\n        $request->{__action} = $env->{'lsmb.action_name'};\n        my $res;\n        try {\n            LedgerSMB::App_State::run_with_state sub {\n\n                $request->initialize_with_db if $request->{dbh};\n                $res = $env->{'lsmb.action'}->($request);\n            }, DBH     => $env->{'lsmb.db'};\n\n            $request->{dbh}->commit if defined $request->{dbh};\n        }\n        catch ($error) {\n            # Explicitly roll back, because middleware may require the\n            # database connection to be in a working state (e.g. DisableBackbutton)\n            $request->{dbh}->rollback\n                if $request->{dbh};\n            if ($error !~ /^Died at/) {\n                $env->{'psgix.logger'}->({\n                    level => 'error',\n                    message => $error });\n                $res = LedgerSMB::PSGI::Util::internal_server_error(\n                    $error,\n                    'Error!',\n                    $request->{company},\n                    $request->{dbversion},\n                    );\n            }\n            else {\n                $res = [ '500', [ 'Content-Type' => 'text/plain' ], [ $error ]];\n            }\n        }\n\n        return Plack::Util::response_cb(\n            $res,\n            sub {\n                my $res = shift;\n                Plack::Util::header_set($res->[1],\n                                        'Content-Security-Policy',\n                                        q{frame-ancestors 'self'});\n            });\n    };\n}\n\n=item setup_url_space(development => $boolean, coverage => $boolean)\n\nSets up the URL space for the PSGI app, pointing various URLs at the\nappropriate PSGI handlers/apps.\n\n=cut\n\nsub _hook_psgi_logger {\n    my ($env, $settings, $router) = @_;\n    my $logger_name = $settings->{logger} ? \".$settings->{logger}\" : '';\n    my $logger = Log::Any->get_logger(category => \"LedgerSMB$logger_name\");\n\n    $env->{'psgix.logger'} = sub {\n        my ($level, $msg) = @{$_[0]}{qw/ level message /};\n\n        return if not defined $msg;\n\n        local $Log::Log4perl::caller_depth = $Log::Log4perl::caller_depth + 1;\n        $logger->$level( ($msg =~ s/\\n/\\\\n/gr) );\n        return;\n    };\n\n    return;\n}\n\nsub setup_url_space {\n    my %args        = @_;\n    my $wire        = $args{wire};\n    my $psgi_app    = psgi_app($wire);\n\n    my $cookie      = $wire->get( 'cookie' )->{name} // 'LedgerSMB';\n    my $secret      = $wire->get( 'cookie' )->{secret} //\n        String::Random->new->randpattern('.' x 50);\n\n    return builder {\n        if (my $proxy_ip = eval { $wire->get( 'miscellaneous/proxy_ip' ); }) {\n            enable match_if addr([ split / /, $proxy_ip ]), 'ReverseProxy';\n        }\n        enable match_if path(qr!.+\\.(css|js|png|ico|jp(e)?g|gif)$!),\n            'ConditionalGET';\n\n        # not using LedgerSMB::Magic::SCRIPT_OLDSCRIPTS:\n        #   it has more than only entry-points\n        mount \"/$_.pl\" => builder {\n            my $script = $_;\n            enable '+LedgerSMB::Middleware::RequestID';\n            enable 'AccessLog', format => 'Req:%{Request-Id}i %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"';\n            enable '+LedgerSMB::Middleware::SessionStorage',\n                domain          => 'main',\n                cookie          => $cookie,\n                duration        => 60*60*24*90,\n                secret          => $secret,\n                # can marshall state in, but not back out (due to forking)\n                # so have the inner scope handle serialization itself\n                inner_serialize => 1;\n            enable '+LedgerSMB::Middleware::Log4perl',\n                script          => $script;\n            enable '+LedgerSMB::Middleware::Authenticate::Company',\n                provide_connection => 'closed',\n                factory            => $wire->get( 'db' );\n            enable '+LedgerSMB::Middleware::MainAppConnect',\n                provide_connection => 'closed',\n                require_version    => $LedgerSMB::VERSION;\n            old_app($script, $wire)\n        }\n        for ('aa', 'am', 'ap', 'ar', 'gl', 'ic', 'ir', 'is', 'oe', 'pe');\n\n        mount \"/$_\" => builder {\n            my $script = $_;\n            enable '+LedgerSMB::Middleware::RequestID';\n            enable 'AccessLog',\n                format => 'Req:%{Request-Id}i %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"';\n            enable '+LedgerSMB::Middleware::SessionStorage',\n                domain   => 'main',\n                cookie   => $cookie,\n                secret   => $secret,\n                duration => 60*60*24*90;\n            enable '+LedgerSMB::Middleware::DynamicLoadWorkflow',\n                max_post_size => $wire->get( 'miscellaneous/max_upload_size' ),\n                script   => $script;\n            enable '+LedgerSMB::Middleware::Log4perl',\n                script   => $script;\n            enable '+LedgerSMB::Middleware::Authenticate::Company',\n                provide_connection => 'open',\n                factory         => $wire->get( 'db' );\n            enable '+LedgerSMB::Middleware::MainAppConnect',\n                provide_connection => 'open',\n                require_version => $LedgerSMB::VERSION;\n            enable '+LedgerSMB::Middleware::DisableBackButton';\n            $psgi_app;\n        }\n        for  (grep { $_ !~ m/^(login|setup)[.]pl$/ } (SCRIPT_NEWSCRIPTS)->@*);\n\n        mount '/login.pl' => builder {\n            enable '+LedgerSMB::Middleware::RequestID';\n            enable 'AccessLog',\n                format => 'Req:%{Request-Id}i %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"';\n            enable '+LedgerSMB::Middleware::SessionStorage',\n                domain   => 'main',\n                cookie   => $cookie,\n                secret   => $secret,\n                duration => 60*60*24*90;\n            enable '+LedgerSMB::Middleware::DynamicLoadWorkflow',\n                max_post_size => $wire->get( 'miscellaneous/max_upload_size' ),\n                script   => 'login.pl';\n            enable '+LedgerSMB::Middleware::Log4perl',\n                script   => 'login.pl';\n            enable '+LedgerSMB::Middleware::Authenticate::Company',\n                provide_connection => 'none',\n                factory         => $wire->get( 'db' );\n            enable '+LedgerSMB::Middleware::MainAppConnect',\n                provide_connection => 'none',\n                require_version => $LedgerSMB::VERSION;\n            enable '+LedgerSMB::Middleware::DisableBackButton';\n            $psgi_app;\n        };\n\n        mount '/erp/api/v0' => builder {\n            enable '+LedgerSMB::Middleware::RequestID';\n            enable 'AccessLog',\n                format => 'Req:%{Request-Id}i %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"';\n            enable '+LedgerSMB::Middleware::SessionStorage',\n                domain      => 'main',\n                cookie      => $cookie,\n                cookie_path => '/',\n                secret      => $secret,\n                duration    => 60*60*24*90;\n            enable '+LedgerSMB::Middleware::Authenticate::Company',\n                provide_connection => 'open',\n                factory         => $wire->get( 'db' );\n            enable '+LedgerSMB::Middleware::MainAppConnect',\n                provide_connection => 'open',\n                require_version => $LedgerSMB::VERSION;\n\n            my $router = router 'erp/api';\n            $router->hooks('before' => \\&_hook_psgi_logger);\n            $router->hooks(\n                'before' => sub {\n                    my ($env) = @_;\n                    $env->{'lsmb.settings'} =\n                        LedgerSMB::Company_Config::initialize($env->{'lsmb.db'});\n                    $env->{wire} = $wire;\n                    return;\n                });\n            sub { return $router->dispatch(@_); };\n        };\n\n        mount '/setup.pl' => builder {\n            enable '+LedgerSMB::Middleware::RequestID';\n            enable 'AccessLog',\n                format => 'Req:%{Request-Id}i %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"';\n            enable '+LedgerSMB::Middleware::DynamicLoadWorkflow',\n                max_post_size => $wire->get( 'miscellaneous/max_upload_size' ),\n                script => 'setup.pl';\n            enable '+LedgerSMB::Middleware::Log4perl',\n                script => 'setup.pl';\n            enable '+LedgerSMB::Middleware::SetupAuthentication';\n            enable '+LedgerSMB::Middleware::DisableBackButton';\n            $psgi_app;\n        };\n\n        enable sub {\n            my $app = shift;\n\n            return sub {\n                my $env = shift;\n\n                return [ HTTP_FOUND,\n                         [ Location => 'login.pl' ],\n                         [ '' ] ]\n                             if $env->{PATH_INFO} eq '/';\n\n                return $app->($env);\n            }\n        };\n\n        mount '/' => Plack::App::File->new( root => $wire->get('paths/UI') )->to_app;\n    };\n\n}\n\n\n\n\n=back\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (C) 2014-2018 The LedgerSMB Core Team\n\nThis file is licensed under the GNU General Public License version 2, or at your\noption any later version.  A copy of the license should have been included with\nyour software.\n\n=cut\n\n\n1;\n", "\npackage LedgerSMB::Scripts::setup;\n\n=head1 NAME\n\nLedgerSMB::Scripts::setup - web entry points for database administration\n\n=head1 DESCRIPTION\n\nThe workflows for creating new databases, updating old ones, and running\nmanagement tasks.\n\n=head1 METHODS\n\n=over\n\n=cut\n\n# DEVELOPER NOTES:\n# This script currently is required to maintain all its own database connections\n# for the reason that the database logic is fairly complex.  Most of the time\n# these are maintained inside the LedgerSMB::Database package.\n#\n\nuse strict;\nuse warnings;\nuse version;\n\nuse Carp;\nuse Digest::MD5 qw(md5_hex);\nuse Encode;\nuse File::Spec;\nuse HTML::Escape;\nuse HTTP::Status qw( HTTP_OK HTTP_INTERNAL_SERVER_ERROR HTTP_UNAUTHORIZED );\nuse Log::Any;\nuse MIME::Base64;\nuse Scope::Guard;\nuse Feature::Compat::Try;\n\nuse LedgerSMB;\nuse LedgerSMB::App_State;\nuse LedgerSMB::Company;\nuse LedgerSMB::Database;\nuse LedgerSMB::Database::Config;\nuse LedgerSMB::Database::ConsistencyChecks;\nuse LedgerSMB::Entity::User;\nuse LedgerSMB::Entity::Person::Employee;\nuse LedgerSMB::I18N;\nuse LedgerSMB::Magic qw( EC_EMPLOYEE HTTP_454 PERL_TIME_EPOCH );\nuse LedgerSMB::Mailer;\nuse LedgerSMB::PGDate;\nuse LedgerSMB::PSGI::Util;\nuse LedgerSMB::Setting;\nuse LedgerSMB::Setup::SchemaChecks qw( html_formatter_context );\nuse LedgerSMB::Template::DB;\nuse LedgerSMB::Database::Upgrade;\nuse LedgerSMB::User;\n\n\n\nmy $logger = Log::Any->get_logger(category => 'LedgerSMB::Scripts::setup');\nmy $CURRENT_MINOR_VERSION;\nif ( $LedgerSMB::VERSION =~ /(\\d+\\.\\d+)./ ) {\n    $CURRENT_MINOR_VERSION = $1;\n}\n\n=item authenticate\n\nThis method is a remnant of authentication shared with\nlogin.pl.\n\n=cut\n\nsub authenticate {\n    my ($request) = @_;\n    my $creds = $request->{_req}->env->{'lsmb.auth'}->get_credentials;\n\n    return [ HTTP_UNAUTHORIZED,\n             [ 'WWW-Authenticate' => 'Basic realm=\"LedgerSMB\"',\n               'Content-Type' => 'text/text; charset=UTF-8' ],\n             [ 'Please enter your credentials' ] ]\n        if ! defined $creds->{password};\n\n    return [ HTTP_OK,\n             [ 'Content-Type' => 'text/plain; charset=utf-8' ],\n             [ 'Success' ] ];\n}\n\n\nsub __default {\n    my ($request) = @_;\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/credentials', $request);\n}\n\nsub _get_database {\n    my ($request) = @_;\n    my $creds = $request->{_req}->env->{'lsmb.auth'}->get_credentials;\n    $request->{login} = $creds->{login};\n\n    return [ HTTP_UNAUTHORIZED,\n             [ 'WWW-Authenticate' => 'Basic realm=\"LedgerSMB\"',\n               'Content-Type' => 'text/text; charset=UTF-8' ],\n             [ 'Please enter your credentials' ] ]\n        if ! defined $creds->{password};\n\n    # Ideally this regex should be configurable per instance, and possibly per admin user\n    # for now we simply use a fixed regex. It will cover many if not most use cases.\n    return [ HTTP_454,\n             [ 'WWW-Authenticate' => 'Basic realm=\"LedgerSMB\"',\n               'Content-Type' => 'text/html; charset=UTF-8' ],\n             [ \"<html><body><h1 align='center'>Access to the ($request->{database}) database is Forbidden!</h1></br><h4 align='center'><a href='/setup.pl?database=$request->{database}'>return to setup</a></h4></body></html>\" ] ]\n        if ( $request->{database} && $request->{database} =~ /postgres|template0|template1/);\n\n    return (undef,\n            $request->{_wire}->get( 'db' )->instance(\n                user     => $creds->{login},\n                password => $creds->{password},\n                dbname   => $request->{database},\n            ));\n}\n\n\nsub _init_db {\n    my ($request) = @_;\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    local $@ = undef;\n    $request->{dbh} = eval {\n        $database->connect({PrintError => 0, AutoCommit => 0 })\n    } if ! defined $request->{dbh};\n    $LedgerSMB::App_State::DBH = $request->{dbh};\n\n    return (undef, $database);\n}\n\n=item login\n\nProcesses the login and examines the database to determine appropriate steps to\ntake.\n)\n=cut\n\n=item get_dispatch_table\n\nReturns the main dispatch table for the versions with supported upgrades\n\n=cut\n\nsub get_dispatch_table {\n    my ($request) = @_;\n    my $sl_detect = $request->{_locale}->text('SQL-Ledger database detected.');\n    my $migratemsg =  $request->{_locale}->text(\n               'Would you like to migrate the database?'\n    );\n    my $upgrademsg =  $request->{_locale}->text(\n               'Would you like to upgrade the database?'\n    );\n\n    return ( { appname => 'sql-ledger',\n        version => '2.7',\n        slschema => 'sl27',\n        message => $sl_detect,\n        operation => $migratemsg,\n        next_action => 'upgrade' },\n      { appname => 'sql-ledger',\n        version => '2.8',\n        slschema => 'sl28',\n        message => $sl_detect,\n        operation => $migratemsg,\n        next_action => 'upgrade' },\n      { appname => 'sql-ledger',\n        version => '3.0',\n        slschema => 'sl30',\n        message => $request->{_locale}->text(\n                     'SQL-Ledger 3.0 database detected.'\n                   ),\n        operation => $migratemsg,\n        next_action => 'upgrade' },\n      { appname => 'sql-ledger',\n        version => undef,\n        message => $request->{_locale}->text(\n                      'Unsupported SQL-Ledger version detected.'\n                   ),\n        operation => $request->{_locale}->text('Cancel'),\n        next_action => 'cancel' },\n      { appname => 'ledgersmb',\n        version => '1.2',\n        message => $request->{_locale}->text('LedgerSMB 1.2 db found.'),\n        operation => $upgrademsg,\n        next_action => 'upgrade' },\n      { appname => 'ledgersmb',\n        version => '1.3',\n        message => $request->{_locale}->text('LedgerSMB 1.3 db found.'),\n        operation => $upgrademsg,\n        next_action => 'upgrade' },\n      { appname => 'ledgersmb',\n        version => '1.4',\n        message => $request->{_locale}->text('LedgerSMB 1.4 db found.'),\n        operation => $upgrademsg,\n        # rebuild_modules will upgrade 1.4->1.5 by applying (relevant) changes\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.5',\n        message => $request->{_locale}->text('LedgerSMB 1.5 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.6',\n        message => $request->{_locale}->text('LedgerSMB 1.6 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.7',\n        message => $request->{_locale}->text('LedgerSMB 1.7 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.8',\n        message => $request->{_locale}->text('LedgerSMB 1.8 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.9',\n        message => $request->{_locale}->text('LedgerSMB 1.9 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.10',\n        message => $request->{_locale}->text('LedgerSMB 1.10 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.11',\n        message => $request->{_locale}->text('LedgerSMB 1.11 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.12',\n        message => $request->{_locale}->text('LedgerSMB 1.12 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => undef,\n        message => $request->{_locale}->text('Unsupported LedgerSMB version detected.'),\n        operation => $request->{_locale}->text('Cancel'),\n        next_action => 'cancel' } );\n}\n\n\nsub _sanity_checks {\n    my $checks = LedgerSMB::Database->verify_helpers(helpers => [ 'psql' ]);\n\n    die q{Unable to execute 'psql'} unless $checks->{psql};\n}\n\n\nsub login {\n    my ($request) = @_;\n    if (!$request->{database}){\n        return list_databases($request);\n    }\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    my $template = $request->{_wire}->get('ui');\n    my $settings = $request->{_wire}->get( 'setup_settings' );\n    my $auth_db = ($settings and $settings->{auth_db}) // 'postgres';\n    $database->{connect_data}->{options} = \"-c search_path=$database->{schema},public\";\n\n    my $version_info = $database->get_info($auth_db);\n\n    my $server_version     = version->parse(\n        $version_info->{system_info}->{'PostgreSQL (server)'}\n        );\n    my $server_min_version = version->parse('10.0.0');\n\n    return $template->render($request,\n                             'setup/mismatch',\n                             {\n                                 found    => \"$server_version\",\n                                 required => \"$server_min_version\",\n                             })\n        if $server_version < $server_min_version;\n\n    ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    _sanity_checks();\n    $request->{login_name} = $version_info->{username};\n    if ($version_info->{status} eq 'does not exist'){\n        $request->{message} = $request->{_locale}->text(\n             'Database does not exist.');\n        $request->{operation} = $request->{_locale}->text('Create Database?');\n        $request->{next_action} = 'create_db';\n    }\n    else {\n        foreach my $dispatch_entry (get_dispatch_table($request)) {\n            if ($version_info->{appname} eq $dispatch_entry->{appname}\n                && ($version_info->{version} eq $dispatch_entry->{version}\n                    || ! defined $dispatch_entry->{version})) {\n                foreach my $field (qw|operation message next_action slschema|) {\n                    $request->{$field} = $dispatch_entry->{$field};\n                }\n                last;\n            }\n        }\n\n        if (! defined $request->{next_action}) {\n            $request->{message} = $request->{_locale}->text(\n                'Unknown database found.'\n                ) . $version_info->{full_version};\n            $request->{operation} = $request->{_locale}->text('Cancel?');\n            $request->{next_action} = 'cancel';\n        } elsif ($request->{next_action} eq 'rebuild_modules') {\n            # we found the current version\n            # check we don't have stale migrations around\n            my $dbh = $request->{dbh};\n            my $sth = $dbh->prepare(q(\n                SELECT count(*)<>0\n                  FROM defaults\n                 WHERE setting_key = 'migration_ok' and value = 'no'\n              ));\n            $sth->execute();\n            my ($has_stale_migration) = $sth->fetchrow_array();\n            if ($has_stale_migration) {\n                $request->{operation} = 'Restore old version?';\n                $request->{message} = 'Failed migration found';\n                $request->{next_action} = 'revert_migration';\n            }\n        }\n    }\n    return $template->render($request, 'setup/confirm_operation', $request);\n}\n\n=item list_databases\nLists all databases as hyperlinks to continue operations.\n\n=cut\n\nsub list_databases {\n    my ($request) = @_;\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    my @results = $database->list_dbs(\n        $request->{_wire}->get('setup_settings')->{admin_db}\n        );\n    $request->{dbs} = [];\n    # Ideally we would extend DBAdmin->list_dbs to accept an argument containing a list of databases to exclude using a method similar to that shown at https://git.framasoft.org/framasoft/OCB/commit/7a6e94edd83e9e73e56d2d148e3238618\n    # also, we should add a new function DBAdmin->list_dbs_this_user which only returns db's the currently auth'd user has access to. Once again the framasoft.org link shows a method of doing this\n    # for now we simply use a fixed regex. It will cover many if not most use cases.\n    @{$request->{dbs}} = map {+{ row_id => $_, db  => $_ }} grep { ! m/^(postgres|template0|template1)$/ } @results ;\n\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/list_databases', $request);\n}\n\n=item list_users\nLists all users in the selected database\n\n=cut\n\nsub list_users {\n    my ($request) = @_;\n    my ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    my @users = LedgerSMB::User->get_all_users($request);\n    $request->{users} = [];\n    for my $user (@users) {\n        push @{$request->{users}}, {row_id => $user->{id}, name => $user->{username} };\n    }\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/list_users', $request);\n}\n\n=item copy_db\n\nCopies db to the name of $request->{new_name}\n\n=cut\n\nsub copy_db {\n    my ($request) = @_;\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    $database->copy($request->{new_name})\n           || die 'An error occurred. Please check your database logs.' ;\n\n    return complete($request);\n}\n\n\n=item backup_db\n\nBacks up a full db\n\n=cut\n\nsub backup_db {\n    my $request = shift @_;\n    $request->{backup} = 'db';\n    return _begin_backup($request);\n}\n\n=item backup_roles\n\nBacks up roles only (for all db's)\n\n=cut\n\nsub backup_roles {\n    my $request = shift @_;\n    $request->{backup} = 'roles';\n    return _begin_backup($request);\n}\n\n# Private method, basically just passes the inputs on to the next screen.\nsub _begin_backup {\n    my $request = shift @_;\n    $request->{can_email} = eval {\n        # when accessing an undefined service, an exception is thrown;\n        # suppress the exception: all we want to know is if there is a value\n        $request->{_wire}->get( 'miscellaneous/backup_email_from' );\n    };\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/begin_backup', $request);\n};\n\n\n=item run_backup\n\nRuns the backup.  If backup_type is set to email, emails the\n\n=cut\n\nsub run_backup {\n    my $request = shift @_;\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    my $backuptype;\n    my $backupfile;\n    my $mimetype;\n\n    if ($request->{backup} eq 'roles') {\n        $backupfile = $database->backup_globals;\n        $backuptype = 'roles';\n        $mimetype = 'text/x-sql';\n    }\n    elsif ($request->{backup} eq 'db') {\n        $backupfile = $database->backup;\n        $backuptype = 'db';\n        $mimetype   = 'application/octet-stream';\n    }\n    else {\n        die $request->{_locale}->text('Invalid backup request');\n    }\n\n    $backupfile or\n        die $request->{_locale}->text('Error creating backup file');\n\n    if ($request->{backup_type} eq 'email') {\n\n        my $mail = LedgerSMB::Mailer->new(\n            transport => $request->{_wire}->get( 'mail' )->{transport},\n            from      => $request->{_wire}->get( 'miscellaneous/backup_email_from' ),\n\n            to        => $request->{email},\n            subject   => 'Email of Backup',\n            message   => 'The Backup is Attached',\n        );\n        $mail->attach(\n            mimetype => $mimetype,\n            filename => \"ledgersmb-$backuptype-\" . time . '.sqlc',\n            file     => $backupfile,\n        );\n        $mail->send;\n        unlink $backupfile;\n        my $template = $request->{_wire}->get('ui');\n        return $template->render($request, 'setup/complete', $request);\n    }\n    elsif ($request->{backup_type} eq 'browser') {\n        my $attachment_name = \"ledgersmb-$backuptype-\" . time . '.sqlc';\n        return sub {\n            my $responder = shift;\n\n            open my $bak, '<:bytes', $backupfile\n                or die \"Failed to open temporary backup file $backupfile: $!\";\n            $responder->(\n                [\n                 HTTP_OK,\n                 [\n                  'Content-Type' => $mimetype,\n                  'Content-Disposition' =>\n                      \"attachment; filename=\\\"$attachment_name\\\"\"\n                 ],\n                 $bak  # the file-handle\n                ]);\n            close $bak\n                or warn \"Failed to close temporary backup file $backupfile: $!\";\n            unlink $backupfile\n                or warn \"Failed to unlink temporary backup file $backupfile: $!\";\n        };\n    }\n    else {\n        die $request->{_locale}->text('Don\\'t know what to do with backup');\n    }\n}\n\n=item consistency\n\n=cut\n\nsub consistency {\n    my ($request) = @_;\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    my $dbh = $database->connect({PrintError => 0, AutoCommit => 0});\n    my $paths = find_checks($request->{_wire}->get( 'paths/sql' ) );\n    my $checks = load_checks( $paths );\n    my $results = run_checks( $dbh, $checks );\n\n    return $request->{_wire}->get('ui')->render(\n        $request,\n        'setup/consistency_results',\n        {\n            database => $request->{database},\n            login    => $request->{login},\n            results  => $results\n        });\n}\n\n\n=item revert_migration\n\n=cut\n\nsub revert_migration {\n    my ($request) = @_;\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    my $dbh = $database->connect({PrintError => 0, AutoCommit => 0});\n    my $sth = $dbh->prepare(q(\n         SELECT value\n           FROM defaults\n          WHERE setting_key = 'migration_src_schema'\n      ));\n    $sth->execute();\n    my ($src_schema) = $sth->fetchrow_array();\n    $dbh->rollback();\n    $dbh->do('DROP SCHEMA public CASCADE');\n    $dbh->do(\"ALTER SCHEMA $src_schema RENAME TO public\");\n    $dbh->commit();\n\n    my $template = $request->{_wire}->get('ui');\n\n    return $template->render($request, 'setup/complete_migration_revert',\n                             $request);\n}\n\n=item template_screen\n\nShows the screen for loading templates.  This should appear before loading\nthe user.\n\n=cut\n\nsub template_screen {\n    my ($request, $entrypoint) = @_;\n    $request->{template_dirs} =\n        [ map { +{ text => $_, value => $_ } }\n          sort keys %{ LedgerSMB::Database::Config->new(\n                           templates_dir => $request->{_wire}->get( 'paths/templates' ),\n                           )->templates } ];\n    return $request->{_wire}->get('ui')\n        ->render($request, 'setup/template_info',\n                 { %$request, templates_action => $entrypoint });\n}\n\n=item load_templates\n\nThis bulk loads the templates.  Expectated inputs are template_dir and\noptionally only_templates (which if true returns to the confirmation screen\nand not the user creation screen.\n\n=cut\n\nsub _save_templates {\n    my ($request, $entrypoint) = @_;\n    my $templates = LedgerSMB::Database::Config->new(\n        templates_dir => $request->{_wire}->get( 'paths/templates' ),\n        )->templates;\n\n    return template_screen($request, $entrypoint)\n        if not exists $templates->{$request->{template_dir}};\n\n    my ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $dbh = $request->{dbh};\n\n    for my $template (@{$templates->{$request->{template_dir}}}) {\n       my $dbtemp = LedgerSMB::Template::DB->get_from_file($template);\n       $dbtemp->save;\n    }\n\n    return;\n}\n\nsub load_templates {\n    my ($request) = @_;\n\n    return (_save_templates($request, 'load_templates')\n            or login($request));\n}\n\n\n=item upgrade\n\n\n=cut\n\nmy %upgrade_run_step = (\n    'sql-ledger/2.7' => '_initial_sl27',\n    'sql-ledger/2.8' => '_initial_sl28',\n    'sql-ledger/3.0' => '_initial_sl30',\n    'ledgersmb/1.2'  => '_initial_ls12',\n    'ledgersmb/1.3'  => '_initial_ls13'\n    );\n\n# Note that by the time we get to these steps,\n# all upgrade checks have already been executed\nmy %upgrade_next_steps = (\n    # The protocol for each of the right-hand sides here:\n\n    # * The right-hand sides are all subroutine names in this module\n    # * Each subroutine returns either\n    #   * a PSGI-triplet\n    #     The returned page posts its interaction back to the entrypoint\n    #   * the result of a call to _dispatch_upgrade_workflow\n    #     called with two arguments: the request environment and its own name\n    #\n    # This makes sure that the steps in the workflow are correctly\n    # \"stepped through\" without there being an explicit or hard-coded\n    # dependency or sequence between steps.\n\n    # new database\n    _create_db             => '_select_coa',\n    _select_coa            => '_select_templates',\n\n    #sl28 specific\n    _initial_sl28          => '_run_sl28_upgrade',\n    _run_sl28_upgrade      => '_post_sl28_migration',\n    _post_sl28_migration   => '_select_templates',\n\n    #sl30 specific\n    _initial_sl30          => '_run_sl30_upgrade',\n    _run_sl30_upgrade      => '_post_sl30_migration',\n    _post_sl30_migration   => '_select_templates',\n\n    #lsmb12 specific\n    _initial_ls12          => '_run_ls12_upgrade',\n    _run_ls12_upgrade      => '_post_ls12_migration',\n    _post_ls12_migration   => '_select_templates',\n\n    #lsmb13 specific\n    _initial_ls13          => '_run_ls13_upgrade',\n    _run_ls13_upgrade      => '_post_ls13_migration',\n    _post_ls13_migration   => '_load_templates',\n\n    # common final steps\n#   _migrate_users could be used to create sl and lsmb12 users\n#   _select_templates      => '_migrate_users',\n#   _migrate_users         => '_complete',\n    _select_templates      => '_create_initial_user',\n    _load_templates        => '_complete',\n    _create_initial_user   => '_complete',\n    );\n\nsub _dispatch_upgrade_workflow {\n    my ($request, $step_name) = @_;\n\n    if (my $next = $upgrade_next_steps{$step_name}) {\n        return __PACKAGE__->can($next)->($request);\n    }\n\n    croak \"Upgrade workflow error: no next step for '$step_name'\";\n}\n\nsub _select_coa {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    return (select_coa($request)\n            or _dispatch_upgrade_workflow($request, '_select_coa'));\n}\n\nsub _process_and_run_upgrade_script {\n    my ($request, $type) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $hdr = $request->{_req}->header( 'Accept-Language' );\n    my $lang = $request->{_wire}->get( 'default_locale' )->from_header( $hdr );\n\n    my $upgrade = LedgerSMB::Database::Upgrade->new(\n        database => $database,\n        type     => $type,\n        language => $lang\n        );\n    try {\n        my $info = $database->get_info();\n        $upgrade->run_upgrade_script(\n            {\n                sl_version => version->parse($info->{full_version}),\n                %{$request}{qw( default_country default_ap default_ar\n                                slschema lsmbschema lsmbversion)}\n            });\n        $upgrade->run_post_upgrade_steps;\n    }\n    catch ($e) {\n        my $error_text = escape_html( $e );\n        local $/ = undef;\n        my $stdout = '';\n        if ( open( my $out, '<:encoding(UTF-8)', $upgrade->logfiles->{out} ) ) {\n            $stdout = escape_html( <$out> );\n        }\n        else {\n            $logger->warn(\n                \"Unable to open psql upgrade script STDOUT logfile: $!\"\n                );\n        }\n\n        my $stderr = '';\n        if ( open( my $err, '<:encoding(UTF-8)', $upgrade->logfiles->{err} ) ) {\n            $stderr = escape_html( <$err> );\n        }\n        else {\n            $logger->warn(\n                \"Unable to open psql upgrade script STDERR logfile: $!\"\n                );\n        }\n\n        return [ HTTP_INTERNAL_SERVER_ERROR,\n                 [ 'Content-Type' => 'text/html; charset=UTF-8' ],\n                 [ <<~EMBEDDED_HTML ] ];\n        <html>\n          <body>\n            <h1>Error!</h1>\n            <p><b>$error_text</b></p>\n\n            <h3>STDERR</h3>\n            <pre style=\"max-height:30em;overflow:scroll\">$stderr</pre>\n\n            <h3>STDOUT</h3>\n            <pre style=\"max-height:30em;overflow:scroll\">$stdout</pre>\n          </body>\n        </html>\n        EMBEDDED_HTML\n    };\n\n    return;\n}\n\nsub _run_sl28_upgrade {\n    my ($request) = @_;\n\n    return (_process_and_run_upgrade_script($request, 'sql-ledger/2.8')\n            or _dispatch_upgrade_workflow($request, '_run_sl28_upgrade'));\n}\n\nsub _run_sl30_upgrade {\n    my ($request) = @_;\n\n    return (_process_and_run_upgrade_script($request, 'sql-ledger/3.0')\n            or _dispatch_upgrade_workflow($request, '_run_sl30_upgrade'));\n}\n\nsub _run_ls12_upgrade {\n    my ($request) = @_;\n\n    return (_process_and_run_upgrade_script($request, 'ledgersmb/1.2')\n            or _dispatch_upgrade_workflow($request, '_run_ls12_upgrade'));\n}\n\nsub _run_ls13_upgrade {\n    my ($request) = @_;\n\n    return (_process_and_run_upgrade_script($request, 'ledgersmb/1.3')\n            or _dispatch_upgrade_workflow($request, '_run_ls13_upgrade'));\n}\n\n\nsub _post_sl28_migration {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    return (_post_migration_schema_upgrade($request, $database,\n                                          '_post_sl28_migration')\n            or _dispatch_upgrade_workflow($request, '_post_sl28_migration'));\n}\n\nsub _post_sl30_migration {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    return (_post_migration_schema_upgrade($request, $database,\n                                          '_post_sl30_migration')\n            or _dispatch_upgrade_workflow($request, '_post_sl30_migration'));\n}\n\nsub _post_ls12_migration {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    return (_post_migration_schema_upgrade($request, $database,\n                                          '_post_ls12_migration')\n            or _dispatch_upgrade_workflow($request, '_post_ls12_migration'));\n}\n\nsub _post_ls13_migration {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    return (_post_migration_schema_upgrade($request, $database,\n                                          '_post_ls13_migration')\n            or _dispatch_upgrade_workflow($request, '_post_ls13_migration'));\n}\n\n\nsub _select_templates {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n\n    return (_save_templates($request, '_select_templates')\n            or _dispatch_upgrade_workflow($request, '_select_templates'));\n}\n\nsub _load_templates {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $dbh = $request->{dbh};\n    #### Suppress selecting templates!\n    ### Suppress next steps in load templates!\n\n    $request->{template_dir} //=\n        LedgerSMB::Setting->new(dbh => $dbh)->get('templates');\n    return (_save_templates($request, '_load_templates')\n            or _dispatch_upgrade_workflow($request, '_load_templates'));\n}\n\n\n\n\nsub upgrade {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $settings = $request->{_wire}->get( 'setup_settings' );\n    my $auth_db = ($settings and $settings->{auth_db}) // 'postgres';\n    my $dbinfo = $database->get_info($auth_db);\n    my $upgrade_type = \"$dbinfo->{appname}/$dbinfo->{version}\";\n    my $locale = $request->{_locale};\n\n    $request->{dbh}->{AutoCommit} = 0;\n\n    my $hdr = $request->{_req}->header( 'Accept-Language' );\n    my $lang = $request->{_wire}->get( 'default_locale' )->from_header( $hdr );\n    my $upgrade = LedgerSMB::Database::Upgrade->new(\n        database => $database,\n        type     => $upgrade_type,\n        language => $lang\n        );\n\n    my $rv;\n    $logger->debug( \"Running upgrade tests for '$upgrade_type'\" );\n    $upgrade->run_tests(\n        sub {\n            my ($check, $dbh, $sth) = @_;\n            $rv = _failed_check($request, $check, $sth);\n        });\n\n    return $rv if $rv;\n\n    my $required_vars = $upgrade->required_vars;\n    if (not %$required_vars) {\n        $request->{dbh}->rollback();\n\n        return _dispatch_upgrade_workflow($request,\n                                          $upgrade_run_step{$upgrade_type});\n    }\n\n    my $template = $request->{_wire}->get('ui');\n\n    my $step = $upgrade_run_step{$upgrade_type};\n    my $upgrade_action = $upgrade_next_steps{$step};\n    $request->{upgrade_action} = $upgrade_action;\n\n    die \"Upgrade type $upgrade_type not associated with a next step (step: $step)\"\n        unless $upgrade_action;\n\n    for my $key (keys %$required_vars) {\n        my $val = $required_vars->{$key};\n        $request->{$key} = (ref($val) eq 'ARRAY')\n            ? ((@$val > 1) ? [ {}, @$val ]\n                          : ($val->[0] ? $val->[0]->{value} : 'null'))\n            : $val;\n    }\n    $request->{lsmbversion} = $CURRENT_MINOR_VERSION;\n    return $template->render($request, 'setup/upgrade_info', $request);\n}\n\nsub _failed_check {\n    my ($request, $check, $sth) = @_;\n\n    my %selectable_values =\n        %{$check->query_selectable_values($request->{dbh})};\n\n    my $hiddens = {\n       check => $check->name,\nverify_check => md5_hex($check->test_query),\n    database => $request->{database}\n    };\n    my @skip_keys = grep /^skip_/, keys %$request;\n    $hiddens->{@skip_keys} = $request->{@skip_keys};\n\n    my $cols = [];\n    for my $column (@{$check->display_cols // []}) {\n        my $selectable_value = $selectable_values{$column};\n\n        if (grep { $column eq $_ } @{$check->columns // []}) {\n            if ( defined $selectable_value && @$selectable_value ) {\n                push @$cols, {\n                    col_id => $column,\n                    name => $column,\n                    type => 'select',\n                    options => $selectable_value,\n                    default_blank => ( 1 != @$selectable_value ),\n                };\n            }\n            else {\n                push @$cols, {\n                    col_id => $column,\n                    name => $column,\n                    type => 'input_text',\n                };\n            }\n        }\n        else {\n            push @$cols, {\n                col_id => $column,\n                name => $column,\n                type => 'text',\n            };\n        }\n    };\n    push @$cols, {\n        col_id => 'id',\n        type => 'hidden',\n    };\n\n    my $rows = [];\n    while (my $row = $sth->fetchrow_hashref('NAME_lc')) {\n        $row->{row_id} = 1+@$rows;\n        $row->{id} =\n            join(',', map { MIME::Base64::encode(($row->{$_} // ''), '')}\n                 @{$check->id_columns});\n        push @$rows, $row;\n    }\n    $hiddens->{count} = scalar(@$rows);\n    $sth->finish();\n\n    my %buttons = map { $_ => 1 } @{$check->buttons};\n    my $enabled_buttons;\n    for (\n        { value => 'fix_tests', label => 'Save and Retry',\n          cond => defined($check->{columns})},\n        { value => 'cancel',    label => 'Cancel',\n          cond => 1                         },\n        { value => 'force',     label => 'Force',\n          cond => $check->{force_queries}   },\n    ) {\n        if ( $buttons{$_->{label}} && $_->{cond}) {\n            push @$enabled_buttons, {\n                 type => 'submit',\n                 name => '__action',\n                value => $_->{value},\n              tooltip => { id => 'action-' . $_->{value},\n                           msg => $check->{tooltips}->{$_->{label}}\n                                ? $request->{_locale}->maketext($check->{tooltips}->{$_->{label}})\n                                : undef,\n                           position => 'above'\n                         },\n                 text => $request->{_locale}->maketext($_->{label}),\n                class => 'submit'\n            }\n        }\n    }\n\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/migration_step', {\n           form               => $request,\n           headers            => [\n               $request->{_locale}->maketext($check->display_name),\n               $request->{_locale}->maketext($check->instructions)\n               ],\n           columns            => $cols,\n           rows               => $rows,\n           buttons            => $enabled_buttons,\n           hiddens            => $hiddens,\n           include_stylesheet => 'system/setup.css',\n    });\n}\n\n=item fix_tests\n\nHandles input from the failed test function and then re-runs the migrate db\nscript.\n\n=cut\n\nsub fix_tests {\n    my ($request) = @_;\n\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $settings = $request->{_wire}->get( 'setup_settings' );\n    my $auth_db = ($settings and $settings->{auth_db}) // 'postgres';\n    my $dbinfo = $database->get_info($auth_db);\n    my $upgrade_type = \"$dbinfo->{appname}/$dbinfo->{version}\";\n    my $dbh = $request->{dbh};\n    $dbh->{AutoCommit} = 0;\n\n    my $hdr = $request->{_req}->header( 'Accept-Language' );\n    my $lang = $request->{_wire}->get( 'default_locale' )->from_header( $hdr );\n    my $upgrade = LedgerSMB::Database::Upgrade->new(\n        database => $database,\n        type     => $upgrade_type,\n        language => $lang\n        );\n\n    my $check = $upgrade->applicable_test_by_name($request->{check});\n    die \"Inconsistent state fixing data for $request->{check}: \"\n        . 'found no applicable tests for given identifier'\n        unless $check;\n\n    die \"Inconsistent state fixing data for $request->{check}: \"\n        . 'found different test by the same name while fixing data'\n        if $request->{verify_check} ne md5_hex($check->test_query);\n\n    my @fixed_rows;\n    for my $count (1 .. $request->{count}){\n        my %row_data;\n        for my $key (@{$check->columns}) {\n            $row_data{$key} = $request->{\"${key}_$count\"};\n            $logger->trace( \"Setting row $count field $key to $row_data{$key}\" );\n        }\n        @row_data{@{$check->id_columns}} =\n            map {\n                $_ ne '' ? MIME::Base64::decode($_) : undef\n        } split(/,/, $request->{\"id_$count\"});\n\n        push @fixed_rows, \\%row_data;\n    }\n\n    $check->fix($dbh, \\@fixed_rows);\n    return upgrade($request);\n}\n\n=item create_db\n\n Beginning of the new database workflow\n\n=cut\n\nsub create_db {\n    my ($request) = @_;\n\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    my $settings = $request->{_wire}->get( 'setup_settings' );\n    my $auth_db = ($settings and $settings->{auth_db}) // 'postgres';\n    my $version_info = $database->get_info($auth_db);\n    $request->{login_name} = $version_info->{username};\n    if ($version_info->{status} ne 'does not exist') {\n        $request->{message} = $request->{_locale}->text(\n            'Database exists.');\n        $request->{operation} =\n            $request->{_locale}->text('Login?');\n        $request->{next_action} = 'login';\n\n        my $template = $request->{_wire}->get('ui');\n        return $template->render($request, 'setup/confirm_operation', $request);\n    }\n\n    my $rc = $database->create_and_load();\n    $logger->info(\"create_and_load rc=$rc\");\n\n    return _dispatch_upgrade_workflow($request, '_create_db');\n}\n\n=item select_coa\n\nSelects and loads the COA.\n\nThere are three distinct input scenarios here:\n\ncoa_lc and chart are set:  load the coa file specified (sql/coa/$coa_lc/$chart)\ncoa_lc set, chart not set:  select the chart\ncoa_lc not set:  Select the coa location code\n\n=cut\n\nsub select_coa {\n    my ($request) = @_;\n    my $hdr = $request->{_req}->header( 'Accept-Language' );\n    my $lang = $request->{_wire}->get( 'default_locale' )->from_header( $hdr );\n    my $coa_data = LedgerSMB::Database::Config\n        ->new( language =>  $lang )\n        ->charts_of_accounts;\n\n    if ($request->{coa_lc}) {\n        my $coa_lc = $request->{coa_lc};\n        if (not exists $coa_data->{$coa_lc}) {\n            die $request->{_locale}->text('Invalid request');\n        }\n\n        for my $coa_type (qw( chart sic )) {\n            if ($request->{$coa_type}) {\n                if (! grep { $_ eq $request->{$coa_type} }\n                    @{$coa_data->{$coa_lc}->{$coa_type}}) {\n                    die $request->{_locale}->text('Invalid request');\n                }\n            }\n        }\n\n        if ($request->{chart}) {\n            my ($reauth, $database) = _get_database($request);\n            return $reauth if $reauth;\n\n            my $c = LedgerSMB::Company->new(\n                dbh => $database->connect(),\n                )->configuration;\n            my $fn = File::Spec->catdir('.', 'locale', 'coa',\n                                        $request->{coa_lc}, $request->{chart});\n            open my $fh, '<:encoding(UTF-8)', $fn\n                or die \"Failed to open $fn: $!\";\n            $c->from_xml($fh);\n            $c->dbh->commit;\n            $c->dbh->disconnect;\n            close $fh\n                or warn \"Error closing $fn: $!\";\n\n            $database->load_sic(\n                {\n                    country => $request->{coa_lc},\n                    sic => $request->{sic}\n                });\n\n            # successful completion returns 'undef'\n            return _dispatch_upgrade_workflow($request, '_select_coa');\n        } else {\n            for my $select (qw( chart sic )) {\n                $request->{\"${select}s\"} =\n                    [ map { +{ name => $_ } }\n                      @{$coa_data->{$request->{coa_lc}}->{$select}} ];\n            }\n       }\n    } else {\n        $request->{coa_lcs} = [ sort { $a->{name} cmp $b->{name} }\n                                values %$coa_data ];\n    }\n\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/select_coa', $request);\n}\n\n\n=item skip_coa\n\nEntry point when on the CoA selection screen the 'Skip' button\nis being pressed.  This allows the user to load a CoA later.\n\nThe CoA loaded at a later time may be a self-defined CoA, i.e. not\none distributed with the LSMB standard distribution.  The 'Skip'\nbutton facilitates that scenario.\n\n=cut\n\nsub skip_coa {\n    my ($request) = @_;\n\n    return _dispatch_upgrade_workflow($request, '_select_coa')\n}\n\n\n=item _render_user\n\nRenders the new user screen. Common functionality to both the\nselect_coa and skip_coa functions.\n\n=cut\n\nsub _render_user {\n    my ($request, $entrypoint) = @_;\n\n    @{$request->{salutations}} = $request->call_procedure(\n        funcname => 'person__list_salutations'\n    );\n\n    $request->{countries} = $request->enabled_countries;\n    my $locale = $request->{_locale};\n\n    @{$request->{perm_sets}} = (\n        {id => '0', label => $locale->text('Manage Users')},\n        {id => '1', label => $locale->text('Full Permissions')},\n        {id => '-1', label => $locale->text('No changes')},\n        );\n\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/new_user',\n                             { %$request, save_action => $entrypoint });\n}\n\n=item _render_new_user\n\nRenders the new user screen. Common functionality to both the\nselect_coa and skip_coa functions.\n\n=cut\n\nsub _render_new_user {\n    my ($request, $entrypoint) = @_;\n\n    # One thing to remember here is that the setup.pl does not get the\n    # benefit of the automatic db connection.  So in order to build this\n    # form, we have to manage that ourselves.\n    #\n    # However we get the benefit of having had to set the environment\n    # variables for the Pg connection above, so don't need to pass much\n    # info.\n    #\n    # Also I am opting to use the lower-level call_procedure interface\n    # here in order to avoid creating objects just to get argument\n    # mapping going. --CT\n\n\n    my ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    $request->{dbh}->{AutoCommit} = 0;\n\n    if ( $request->{coa_lc} ) {\n        LedgerSMB::Setting->new(%$request)->set('default_country',$request->{coa_lc});\n    }\n    return _render_user($request, $entrypoint);\n}\n\n\n\n=item _save_user\n\nSaves the administrative user, and then directs to the login page.\n\n=cut\n\nsub _save_user {\n    my ($request, $entrypoint) = @_;\n    $request->{entity_class} = EC_EMPLOYEE;\n    $request->{name} = \"$request->{last_name}, $request->{first_name}\";\n\n    my ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    $request->{dbh}->{AutoCommit} = 0;\n\n    $request->{control_code} = $request->{employeenumber};\n    my $emp = LedgerSMB::Entity::Person::Employee->new(\n        %$request,\n        dob => $request->parse_date( $request->{dob} ),\n        start_date => $request->parse_date( $request->{start_date} ),\n        end_date => $request->parse_date( $request->{end_date} ),\n        );\n    $emp->save;\n    $request->{entity_id} = $emp->entity_id;\n    my $user = LedgerSMB::Entity::User->new(%$request);\n\n    try {\n        $user->create($request->{password});\n    }\n    catch ($var) {\n        if ($var =~ /duplicate user/i){\n            $request->{dbh}->rollback;\n            $request->{notice} = $request->{_locale}->text(\n                'User already exists. Import?'\n                );\n            $request->{pls_import} = 1;\n\n            # return from the 'catch' block\n            return _render_user($request, $entrypoint);\n        }\n        else {\n            die $var;\n        }\n    };\n\n    if ($request->{perms} == 1){\n         for my $role (\n                $request->call_procedure(funcname => 'admin__get_roles')\n         ){\n             $request->call_procedure(funcname => 'admin__add_user_to_role',\n                                      args => [ $request->{username},\n                                                $role->{rolname}\n                                              ]);\n         }\n    } elsif ($request->{perms} == 0) {\n        $request->call_procedure(funcname => 'admin__add_user_to_role',\n                                 args => [ $request->{username},\n                                           'users_manage',\n                                         ]\n        );\n    }\n    $request->{dbh}->commit;\n\n    return;\n}\n\n\n\nsub _post_migration_schema_upgrade {\n    my ($request, $database, $entrypoint) = @_;\n    my $dbh = $request->{dbh};\n    my $guard = Scope::Guard->new(\n        sub {\n            if ($dbh) {\n                $dbh->rollback;\n                $dbh->disconnect;\n            }\n        });\n    my $reauth;\n\n    ($reauth, $database) = _init_db($request) if not $database;\n    return $reauth if $reauth;\n\n\n    if (my $rv = _rebuild_modules($request, $entrypoint, $database)) {\n        ### should we *really* commit??\n        ### or should we treat *any* return value as problematic\n        ### (and leave committing the transaction to the inner scope?\n        if ($rv->[0] == 200) {\n            $dbh->commit;\n            $guard->dismiss;\n        }\n\n        return $rv;\n    }\n\n    # If users are added to the user table, and appropriate roles created, this\n    # then grants the base_user permission to them.  Note it only affects users\n    # found also in pg_roles, so as to avoid errors.  --CT\n    $guard->dismiss;\n    $dbh->do(q{SELECT admin__add_user_to_role(username, 'base_user')\n                 FROM users WHERE username IN (select rolname from pg_roles)});\n\n    $dbh->commit;\n\n    return;\n}\n\n=item add_user\n\n=cut\n\nsub _create_initial_user {\n    my ($request) = @_;\n    return _render_new_user($request, '_create_initial_user')\n        unless $request->{username};\n\n    return (_save_user($request, '_create_initial_user')\n            or _dispatch_upgrade_workflow($request, '_create_initial_user'));\n}\n\nsub add_user {\n    my ($request) = @_;\n\n    return (_create_initial_user($request)\n            or login($request));\n}\n\n=item edit_user_roles\n\n=cut\n\nsub edit_user_roles {\n    my ($request) = @_;\n\n    my $reauth;\n    ($reauth) = _init_db($request)\n        unless $request->{dbh};\n    return $reauth if $reauth;\n\n    my $template = $request->{_wire}->get('ui');\n    my ($user) = $request->call_procedure(\n        funcname => 'admin__get_user',\n        args     => [ $request->{id} ]);\n    return $template->render(\n        $request,\n        'setup/edit_user',\n        {\n            request => $request,\n            roles   => [\n                map {\n                    +{\n                        name => $_->{rolname},\n                        description => ($_->{rolname} =~ s/_/ /gr),\n                    }\n                }\n                $request->call_procedure(funcname => 'admin__get_roles')\n                ],\n            user    => {\n                roles    => [\n                    map { $_->{admin__get_roles_for_user} }\n                    $request->call_procedure(\n                        funcname => 'admin__get_roles_for_user',\n                        args     => [ $request->{id} ])\n                    ],\n                user_id  => $request->{id},\n                username => $user->{username},\n            }\n        });\n}\n\n=item save_user_roles\n\n=cut\n\nsub save_user_roles {\n    my ($request) = @_;\n\n    my ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    my ($user) = $request->call_procedure(\n        funcname => 'admin__get_user',\n        args => [ $request->{id} ] );\n    my %active_roles = map {\n        $_->{admin__get_roles_for_user} => 1\n    } $request->call_procedure(\n        funcname => 'admin__get_roles_for_user',\n        args     => [ $request->{id} ]);\n\n    for my $role (\n        map { $_->{rolname} }\n        $request->call_procedure( funcname => 'admin__get_roles' ) ) {\n        if ($active_roles{$role} and not $request->{$role}) {\n            # remove\n            $request->call_procedure(\n                funcname => 'admin__remove_user_from_role',\n                args     => [ $user->{username}, $role ] );\n        }\n        elsif ($request->{$role} and not $active_roles{$role}) {\n            # add\n            $request->call_procedure(\n                funcname => 'admin__add_user_to_role',\n                args     => [ $user->{username}, $role ] );\n        }\n    }\n\n    return edit_user_roles($request);\n}\n\n\n=item reset_password\n\n=cut\n\nsub reset_password {\n    my ($request) = @_;\n\n    my ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $user = LedgerSMB::Entity::User->new(%$request);\n    $user->reset_password($request->{password});\n\n    $request->{password} = '';\n\n    return edit_user_roles($request);\n}\n\n\n\n=item cancel\n\nCancels work.  Returns to login screen.\n\n=cut\nsub cancel{\n    return __default(@_);\n}\n\n=item force\n\nForce work.  Forgets unmatching tests, applies a curing statement and move on.\n\n=cut\n\nsub force {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $hdr = $request->{_req}->header( 'Accept-Language' );\n    my $lang = $request->{_wire}->get( 'default_locale' )->from_header( $hdr );\n    my $upgrade = LedgerSMB::Database::Upgrade->new(\n        database => $database,\n        type => '.../...',\n        language => $lang\n        );\n\n    my $test = $upgrade->applicable_test_by_name($request->{check});\n    $test->force($request->{dbh});\n\n    return upgrade($request);\n}\n\n=item rebuild_modules\n\nThis method rebuilds the modules and sets the version setting in the defaults\ntable to the version of the LedgerSMB request object.  This is used when moving\nbetween versions on a stable branch (typically upgrading)\n\n=cut\n\nsub _rebuild_modules {\n    my ($request, $entrypoint, $database) = @_;\n\n    if (not defined $database) {\n        my ($reauth, $db) = _init_db($request);\n        return $reauth if $reauth;\n\n        $database = $db;\n    }\n\n    # The order is important here:\n    #  New modules should be able to depend on the latest changes\n    #  e.g. table definitions, etc.\n\n    $request->{resubmit_action} //= $entrypoint;\n    my $HTML = html_formatter_context {\n        return ! $database->apply_changes( checks => 1 );\n    } $request;\n\n    return [ HTTP_OK,\n             [ 'Content-Type' => 'text/html; charset=UTF-8' ],\n             [ map { encode_utf8($_) } @$HTML ]\n        ]\n        if $HTML;\n\n    $database->upgrade_modules('LOADORDER', $LedgerSMB::VERSION)\n        or die 'Upgrade failed.';\n\n    return;\n}\n\nsub rebuild_modules {\n    my ($request) = @_;\n\n    if (my $rv = _rebuild_modules($request, 'rebuild_modules')) {\n        return $rv;\n    }\n    return complete($request);\n}\n\n=item complete\n\nGets the statistics info and shows the complete screen.\n\n=cut\n\nsub _complete {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $temp = $database->loader_log_filename();\n    $request->{lsmb_info} = $database->stats();\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/complete', $request);\n}\n\nsub complete { return _complete(@_) };\n\n=item system_info\n\nAsks the various modules for system and version info, showing the result\n\n=cut\n\nsub system_info {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    # the intent here is to get a much more sophisticated system which\n    # asks registered modules for their system and dependency info\n    my $settings = $request->{_wire}->get( 'setup_settings' );\n    my $auth_db = ($settings and $settings->{auth_db}) // 'postgres';\n    my $info = {\n        db     => $database->get_info($auth_db)->{system_info},\n        system => LedgerSMB::system_info()->{system},\n        environment => \\%ENV,\n        modules => \\%INC,\n    };\n    $request->{info} = $info;\n    return $request->{_wire}->get('ui')\n        ->render($request, 'setup/system_info', $request);\n}\n\n\n=back\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (C) 2011-2022 The LedgerSMB Core Team\n\nThis file is licensed under the GNU General Public License version 2, or at your\noption any later version.  A copy of the license should have been included with\nyour software.\n\n=cut\n\n\n1;\n", "\npackage LedgerSMB::Template::UI;\n\n=head1 NAME\n\nLedgerSMB::Template::UI - Renderer for UI templates\n\n=head1 DESCRIPTION\n\nThis module instantiates a singleton UI template rendering engine\n(backed by Template Toolkit).\n\n=head1 METHODS\n\n=cut\n\nuse strict;\nuse warnings;\n\nuse LedgerSMB::Locale;\nuse LedgerSMB::Template;\n\nuse Carp;\nuse File::Spec;\nuse HTML::Escape;\nuse HTML::Entities;\nuse Template;\n\nour $engine;\nour $singleton;\nour @pre_render_cbs = (\n    sub {\n        my ($request, $template, $vars, $cvars) = @_;\n        $vars->{USER} = $request->{_user};\n        $vars->{locale} = $vars->{language} // $vars->{locale};\n        $cvars->{locale} = $cvars->{language} // $cvars->{locale};\n    },\n    );\n\n\n=head2 new_UI( cache => $path, root => $path )\n\nConstructor. Returns (singleton) template UI renderer.\n\n=cut\n\nsub new_UI {\n    my $class = shift;\n    my %args = @_;\n    my $cache = $args{cache} // 'lsmb_templates/';\n    my $root = $args{root} // './UI/';\n\n    if (! defined $singleton) {\n        if (!defined $engine) {\n            $engine = Template->new(\n                INCLUDE_PATH => [\n                    map { $root . $_ } ('js', '', 'lib') ],\n                ENCODING => 'utf8',\n                TRIM => 1,\n                START_TAG => quotemeta('[%'),\n                END_TAG => quotemeta('%]'),\n                DELIMITER => ';',\n                COMPILE_EXT => '.lttc',\n                COMPILE_DIR =>\n                   File::Spec->rel2abs( $cache, File::Spec->tmpdir ),\n                VARIABLES => {\n                    UNESCAPE => sub {\n                        return decode_entities(shift @_);\n                    },\n                })\n                or die Template->error;\n        }\n\n        $singleton = bless {\n            root => $root,\n            stylesheet => $args{stylesheet} // 'ledgersmb.css',\n            standard_vars => {\n            },\n        }, __PACKAGE__;\n    }\n    return $singleton;\n}\n\n=head2 render_string($self, $request, $template, $vars, $cvars)\n\nReturns the processed template as a string (of bytes, UTF-8 encoded).\n\nAdds template variables C<USER>, C<DBNAME>, C<locale> and C<SETTINGS>\nfrom C<$request>.\n\nRenders the template stored in the file indicated by C<$template>.\nThe file is looked up in the root templates directory as configured\nor in the C<lib/> subdirectory of it and should be a relative\npath to either of those.\n\nThe values of the variables specified in C<$vars> will be HTML-encoded\nand passed to the template.\n\nC<$cvars> is optional. It's an additional set of variables assumed to\nbe HTML encoded and ready for inclusion in the generated HTML output.\n\n=cut\n\nsub render_string {\n    my ($self, $request, $template, $vars, $cvars) = @_;\n    my $locale;\n    $vars //= {};\n    delete $vars->{HIDDENS}->{form_id} if $vars->{HIDDENS};\n\n    for my $cb (@pre_render_cbs) {\n        $cb->($request, $template, $vars, $cvars);\n    }\n\n    if ($vars->{locale}) {\n        $locale = LedgerSMB::Locale->get_handle($vars->{locale});\n    }\n    elsif ($request->{_locale}) {\n        $locale = $request->{_locale};\n    }\n    my $cleanvars = {\n        ( %{LedgerSMB::Template::preprocess(\n                {\n                    $vars->%*,\n                    PRINTERS => [\n                        ( $request->{_wire}->get( 'printers' )->as_options,\n                          {\n                              text  => $request->{_locale}->text('Screen'),\n                              value => 'screen'\n                          } )\n                    ],\n                    SETTINGS => {\n                        ($request->{_company_config} // {})->%*,\n                        # Reports rendered as UI elements have SETTINGS in $vars\n                        ($vars->{SETTINGS} // {})->%*\n                    },\n                    dojo_theme => (\n                        $request->{_company_config}->{dojo_theme} || 'claro'\n                        )\n                },\n                sub { return escape_html($_[0]); },\n                $request->formatter_options,\n                )},\n          %{$self->{standard_vars}},\n          LIST_FORMATS => sub {\n              return [\n                  map { escape_html($_) }\n                  $request->{_wire}->get( 'output_formatter' )->get_formats->@*\n                  ];\n          },\n          # translation of constant-string arguments\n          text => sub {\n              if ($locale) {\n                  return escape_html($locale->maketext(@_));\n              }\n              else {\n                  return shift;\n              }\n          },\n          # translation of dynamic string content\n          maketext => sub {\n              if ($locale) {\n                  return escape_html($locale->maketext(@_));\n              }\n              else {\n                  return escape_html(shift);\n              }\n          },\n          %{$cvars // {}}\n        )\n    };\n    if (defined $cleanvars->{form}->{stylesheet}\n        and not defined $cleanvars->{stylesheet}) {\n        $cleanvars->{stylesheet} = $cleanvars->{form}->{stylesheet};\n    }\n    if (not defined $cleanvars->{stylesheet}\n        or (defined $cleanvars->{stylesheet}\n            and not -e ($self->{root} . 'css/' . $cleanvars->{stylesheet}))) {\n        $cleanvars->{stylesheet} = $self->{stylesheet};\n    }\n\n    my $output;\n    if (! $engine->process(\n            $template . '.html',\n            $cleanvars,\n            \\$output,\n            { binmode => 'utf8' })) {\n        my $error = $engine->error() // '<undef>';\n        croak 'Template error: ' . $error;\n    }\n    utf8::encode($output) if utf8::is_utf8($output); ## no critic\n    return $output;\n}\n\n=head2 render($self, $request, $template, $vars, $cvars)\n\nCalls C<render_string> with its arguments and converts the response\nto a PSGI response triplet.\n\n=cut\n\nsub render {\n    return [ 200, [ 'Content-Type' => 'text/html; charset=UTF-8' ],\n             [ render_string(@_) ] ];\n}\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (C) 2018 The LedgerSMB Core Team\n\nThis file is licensed under the GNU General Public License version 2, or at your\noption any later version.  A copy of the license should have been included with\nyour software.\n\n=cut\n\n1;\n"], "fixing_code": ["[% WRAPPER \"ui-header.html\"\nstylesheet=\"ledgersmb.css\"\ninclude_stylesheet=[\"system/setup.css\"] %]\n[% PROCESS elements.html %]\n<body id=\"setup-begin-backup\" class=\"lsmb [% dojo_theme %]\">\n<div><div class=\"setupconsole\">\n<h2>[% text('Database Management Console') %]</h2>\n<div class=\"listtop\">[% text('Where shall we send the backup?') %]</div>\n[% # notice, message, and operation are all localized. %]\n<div id=\"notice\">[% notice %]</div>\n<form data-dojo-type=\"lsmb/SimpleForm\" action=\"setup.pl\" method=\"POST\" name=\"confirm_operation\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"[% csrf_token %]\" />\n[% INCLUDE input element_data = {\n    name = 'database'\n    type = 'hidden'\n   value = database\n} %]\n[% INCLUDE input element_data = {\n    name = 'backup'\n    type = 'hidden'\n   value = backup\n} %]\n<div class=\"inputrow\" id=\"emailopt\">\n[% IF can_email %]\n[% INCLUDE input element_data = {\n        type = 'radio'\n        name = 'backup_type'\n       label = text('To email') #'\n       value = 'email'\n    }, label_pos = 1\n%]\n[% INCLUDE input element_data = {\n    type = \"text\"\n    name = \"email\"\n   value = email\n   class = \"email\"\n} %]\n[% ELSE %]\n[% INCLUDE input element_data = {\n        type = 'radio'\n        name = 'backup_type'\n       label = text('To email') #'\n       value = 'email'\n    disabled = 'disabled'\n    }, label_pos = 1\n%]\n[% INCLUDE input element_data = {\n    type = \"text\"\n    name = \"email\"\n   value = email\n   class = \"email\"\ndisabled = \"disabled\"\n} %]\n[% END %]\n</div>\n<div class=\"inputrow\" id=\"browseropt\">\n[% INCLUDE input element_data = {\n    type = 'radio'\n    name = 'backup_type'\n   label = text('To my browser') #'\n   value = 'browser'\n checked = \"checked\"\n}, label_pos = 1 %]\n</div>\n<div class=\"inputrow\">\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'run_backup'\n    type = 'submit'\n   class = 'submit'\n    text = text('Run Backup') #'\n} %]\n</div>\n</form>\n</div></div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\nstylesheet=\"ledgersmb.css\"\ninclude_stylesheet=[\"system/setup.css\"] %]\n[% PROCESS elements.html %]\n<body id=\"setup-confirm-operation\" class=\"lsmb [% dojo_theme %]\">\n<div><div class=\"setupconsole\">\n<h2>[% text('Database Management Console') %]</h2>\n[% # notice, message, and operation are all localized. %]\n[% INCLUDE 'setup/ui-db-credentials.html' %]\n<div class=\"listtop\">[% text('Confirm Operation') %]</div>\n<div id=\"notice\">[% notice %]</div>\n<div id=\"message\">[% message %]</div>\n<div id=\"operation\">[% operation %]</div>\n<form data-dojo-type=\"lsmb/SimpleForm\"\n      action=\"setup.pl\"\n      method=\"POST\"\n      name=\"confirm_operation\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"[% csrf_token %]\" />\n[% INCLUDE input element_data = {\n    name = 'database'\n    type = 'hidden'\n   value = database\n} %]\n<div class=\"inputrow\">\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = next_action\n    type = 'submit'\n   class = 'submit'\n    text = text('Yes')\n} %]\n</div>\n<div id=\"sep\" class=\"listheading\">[% text('Other Actions') %]</div>\n[% IF next_action == 'rebuild_modules' %]\n<div id=\"copy-database\">\n[% INCLUDE input element_data = {\n    name = 'new_name'\n    type = 'text'\n   class = 'dbname'\n   label = text('Copy to New Name') #'\n}; %]\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'copy_db'\n    type = 'submit'\n   class = 'submit'\n    text = text('Copy') #'\n}; %]\n</div>\n<div id=\"user\">\n<div>[% text('Users') %]</div>\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'add_user'\n    type = 'submit'\n   class = 'submit'\n    text = text('Add User') #'\n}; %]\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'list_users'\n    type = 'submit'\n   class = 'submit'\n    text = text('List Users') #'\n}; %]\n</div>\n<div id=\"templates\">\n<div>[% text('Templates') %]</div>\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'load_templates'\n    type = 'submit'\n   class = 'submit'\n    text = text('Load Templates') #'\n};\nINCLUDE input element_data = {\n    name = \"only_templates\"\n   value = \"1\"\n    type = \"hidden\"\n}; %]\n</div>\n[% END %]\n[% IF next_action != 'create_db' %]\n<div id=\"others\">[% text('Backup') %]</div>\n<div class=\"inputrow\">\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'backup_db'\n    type = 'submit'\n   class = 'submit'\n    text = text('Backup DB') #'\n} %]\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'backup_roles'\n    type = 'submit'\n   class = 'next'\n    text = text('Backup Roles') #'\n} %]\n</div>\n<div id=\"diagnostics\">[% text('System diagnostics') %]</div>\n<div class=\"inputrow\">\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'system_info'\n    type = 'submit'\n   class = 'submit'\n    text = text('System Info') #'\n} %]\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'consistency'\n    type = 'submit'\n   class = 'submit'\n    text = text('Check consistency') #'\n} %]\n</div>\n[% END %]\n</form>\n[% IF lsmb_info %]\n<table class='lsmb_info'>\n  <thead>\n  <tr><th colspan=\"2\">[% text('LedgerSMB Database Statistics') %]</th></tr>\n  <tr><th colspan=\"2\">[% text('Row counts') %]</th></tr>\n  </thead>\n  <tbody>\n  <tr><th>[% text('AP') %]</th><td>[% lsmb_info.ap_count %]</td></tr>\n  <tr><th>[% text('AR') %]</th><td>[% lsmb_info.ar_count %]</td></tr>\n  <tr><th>[% text('GL') %]</th><td>[% lsmb_info.gl_count %]</td></tr>\n  <tr><th>[% text('Journal Lines') %]</th><td>[% lsmb_info.acc_trans_count %]</td></tr>\n  <tr><th>[% text('Orders') %]</th><td>[% lsmb_info.oe_count %]</td></tr>\n  <tr><th>[% text('Customer/Vendor Accounts') %]</th><td>[% lsmb_info.eca_count %]</td></tr>\n  <tr><th>[% text('Transactions') %]</th><td>[% lsmb_info.transactions_count %]</td></tr>\n  <tr><th>[% text('Users') %]</th><td>[% lsmb_info.users_count %]</td></tr>\n  </tbody>\n</table>\n[% END %]\n</div></div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\n       stylesheet=\"ledgersmb.css\"\n       include_stylesheet=[\"system/setup.css\"];\n       PROCESS elements.html -%]\n<body id=\"setup-login\" class=\"lsmb [% dojo_theme%]\">\n  <div style=\"width:100%;height:100%\">\n    <div>\n        <div class=\"setupconsole\">\n          <div id=\"loading\">\n                <img style=\"display:block;position:absolute;margin:auto;top:50%;left:50%;transsform:translateX(-50%) translateY(-50%)\"\n                    src=\"js/dijit/icons/images/loadingAnimation.gif\"\n                    alt=\"If this text is showing, there's most likely a problem with the Dojo setup\"\n                    title=\"Loading ...\"\n                  width=\"20\" height=\"20\" />\n          </div>\n            <div id=\"logindiv\">\n                <div class=\"login\" align=\"center\">\n                    <a href=\"http://www.ledgersmb.org/\"\n                    target=\"_top\">\n                    <img src=\"images/ledgersmb.png\"\n                            class=\"logo\"\n                            alt=\"LedgerSMB Logo\" />\n                    </a>\n                    <h2 align=\"center\" style=\"margin-top: 0\">\n                        [% version %]\n                    </h2>\n                    <div class=\"listtop\">\n                        [% text('Database administrator credentials') %]\n                    </div>\n                </div>\n                <form id=\"loginform\"\n                      name=\"credentials\"\n                      style=\"margin-top:1em\">\n                  <input type=\"hidden\" name=\"csrf_token\" value=\"[% csrf_token %]\" />\n                  <div class=\"login_form\">\n                    [% select_hint = text('Select or Enter User');\n                       INCLUDE select element_data = {\n                                   name = 's_user'\n                                   id = 's-user'\n                                   options =  [ { value = 'lsmb_dbadmin',\n                                                  text = 'lsmb_dbadmin'},\n                                                { value = 'postgres',\n                                                  text  = 'postgres'} ]\n                                   class = 'username'\n                                   tabindex = 1\n                                   label = text('DB admin login')\n                                   \"data-dojo-type\" = \"dijit/form/ComboBox\"\n                                   \"data-dojo-props\" = \"value:'$s_user', placeHolder:'$select_hint'\"\n                                    attributes = { autocomplete = 'off'}\n                       };\n                       INCLUDE input element_data = {\n                                    name = 's_password'\n                                    id = 's-password'\n                                    value = s_password\n                                    type = 'password'\n                                    size = '15'\n                                    class = 'password'\n                                    tabindex = 2\n                                    label = text('Password')\n                                    attributes = { autocomplete = 'off'}\n                       };\n                       INCLUDE input element_data = {\n                                    name = 'database'\n                                    value = database\n                                    type = 'text'\n                                    size = '15'\n                                    class = 'database'\n                                    tabindex = 3\n                                    label = text('Database')\n                       } %]\n                  </div>\n                  <div class=\"inputrow\"\n                       style=\"text-align:right; padding-right: 4ex; margin-top: 1ex\">\n                    <button data-dojo-type=\"lsmb/SetupLoginButton\"\n                            class=\"submit\"\n                            data-dojo-props=\"action:'login'\"\n                            tabindex=\"4\"\n                            >[% text('Login') %]</button>\n                    <button data-dojo-type=\"lsmb/SetupLoginButton\"\n                            class=\"submit\"\n                            data-dojo-props=\"action:'create_db'\"\n                            tabindex=\"5\"\n                            >[% text('Create') %]</button>\n                  </div>\n                </form>\n            </div>\n        </div>\n    </div>\n  </div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\nstylesheet=\"ledgersmb.css\"\ninclude_stylesheet=[\"system/setup.css\"];\n       PROCESS \"elements.html\";\n       PROCESS \"dynatable.html\"; %]\n<body id=\"setup-edit-user\" class=\"[% dojo_theme %]\">\n <div><div class=\"setupconsole\">\n        <div class=\"listtop\">\n            [%\n               IF request.pls_import;\n                       text('Duplicate User Found: Importing User');\n                       action = 'save_user';\n                ELSIF user.user_id;\n                      text('Editing User');\n                      action = 'edit_user';\n                ELSE;\n                      text('New User');\n                      action = 'save_user';\n                END %]\n        </div>\n\n    <form data-dojo-type=\"lsmb/SimpleForm\" method=\"POST\" action=\"[% request.script %]\">\n      <input type=\"hidden\" name=\"csrf_token\" value=\"[% csrf_token %]\" />\n      <input type=\"hidden\" name=\"id\" value=\"[% request.id %]\" />\n      <input type=\"hidden\" name=\"database\" value=\"[% request.database %]\" />\n        <table id=\"user-data\">\n\n            [% IF user.user_id and not request.pls_import %]\n            <tr>\n                <td>[% text('Username') %]</td>\n                <td>\n                    [% user.username;\n                    INCLUDE input element_data = {\n                            name  = 'username'\n                            type  = 'hidden'\n                            value = user.username\n                    } %]\n                </td>\n            </tr>\n\n            [% ELSE %]\n            <tr>\n                <td>[% text('Username') %]</td>\n                <td>\n                    <input type=\"text\" name=\"username\" value=\"[% user.username %]\" required/>\n                </td>\n            </tr>\n            [% END %]\n            <tr>\n                <td><label for=\"password\">[% text('Password') %]</label>\n                </td>\n                <td>\n                  [% PROCESS input element_data = {\n                               type = \"password\"\n                               id   = \"password\"\n                               name = \"password\"\n                               autocomplete = \"off\"\n                  } %]\n                </td>\n            </tr>\n\n            [% IF (request.pls_import == 1) OR !user.username %]\n            <tr>\n                <td>[% text('Import') %]</td>\n                [%\n                  IF request.pls_import;\n                      importc1 = 'CHECKED';\n                      importc0 = '';\n                  ELSE;\n                      importc1 = '';\n                      importc0 = 'CHECKED';\n                  END; %]\n                <td><div class=\"input_line\"><div overflow=\"auto\" class=\"input_group\">\n                  [% INCLUDE input element_data = {\n                           label   = 'Yes'\n                           value   = '1'\n                           checked = importc1\n                           name    = 'pls_import'\n                           type    = 'radio'\n                   } %]</div><div overflow=\"auto\" class=\"input_group\">[%\n                   INCLUDE input element_data = {\n                           label   = 'No'\n                           value   = '0'\n                           checked = importc0\n                           name    = 'pls_import'\n                           type    = 'radio'\n                   } %]</div></div></td>\n            </tr>\n            [% END # unless employee.entity_id %]\n        </table>\n           [% IF user.username and not request.pls_import;\n                PROCESS button element_data  = {\n                         text = text('Reset Password') #'\n                         name = '__action'\n                         type = 'submit'\n                        class = 'submit'\n                  value = 'reset_password'\n                  attributes = { autocomplete = \"off\" }\n                };\n           ELSE;\n                PROCESS button element_data  = {\n                         text = text('Add User') #'\n                         name = '__action'\n                         type = 'submit'\n                        class = 'submit'\n                        value = 'create_user'\n                };\n           END;\n    %]\n    </form>\n    [% IF user.user_id and not request.pls_import%]\n        <hr />\n        <form data-dojo-type=\"lsmb/SimpleForm\" name=\"groups\" method=\"POST\" action=\"[% request.script %]\">\n          <input type=\"hidden\" name=\"csrf_token\" value=\"[% csrf_token %]\" />\n            <input type=\"hidden\" name=\"database\" value=\"[% request.database %]\" />\n            [% PROCESS input element_data = {\n               type=\"hidden\"\n               name=\"id\"\n               value=request.id\n              };\n           %]\n        <input type=\"hidden\" name=\"entity_id\" value=\"[% entity_id %]\"/>\n           <div>\n            <table id=\"user-roles\">\n                <!-- Groups section -->\n                <tr>\n                [% FOREACH role IN roles %]\n                    <td>\n                        [% rolcheck = undef;\n                           IF user.roles.grep(role.name).size;\n                              rolcheck = \"checked\";\n                           END %]\n                        [% PROCESS input element_data = {\n                               type = \"checkbox\"\n                               label = role.description\n                               value = 1\n                               name = role.name\n                               id = role.name\n                               checked = rolcheck\n                         }, label_pos = 1 %]\n                    </td>\n                [% IF loop.even() %]\n                </tr>\n                <tr>\n                [% END %]\n                [% END %]\n                </tr>\n            </table>\n\n            <table>\n                <tr>\n                    <td>[% PROCESS button element_data = {\n                          text = text('Save Groups') #'\n                          class = \"submit\"\n                          name = \"__action\"\n                          value = \"save_user_roles\"\n                          'data-lsmb-doing' = text('Saving...')\n                          'data-lsmb-done' = text('Saved')\n                    } %]</td>\n                </tr>\n            </table></div>\n        </form>\n[% END %]\n</div></div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\n       stylesheet=\"ledgersmb.css\";\n       PROCESS elements.html;\n       PROCESS 'dynatable.html' %]\n\n<body id=\"setup-migration_step\" class=\"lsmb [% dojo_theme%]\">\n  <div><div class=\"setupconsole\">\n    <h1 style=\"font-weight: bold; margin-bottom: 1em; text-align: center\">\n        [% text('Database Management Console') %]\n    </h1>\n    [% # We cannot use form-dynatable, for it requires lsmb/Form and maindiv %]\n    <form data-dojo-type=\"lsmb/SimpleForm\"\n          method=\"post\"\n          action=\"[% form.script %]\"\n          id=\"migration-step-dynatable\">\n      <input type=\"hidden\" name=\"csrf_token\" value=\"[% csrf_token %]\" />\n    [% FOREACH header IN headers %]<div class=\"listtop\">\n             [% INCLUDE decorated_text element_data = {\n                    msg => header };\n             %]</div>\n    [% END %]\n\n    [% PROCESS 'dynatable' tbody = { rows = rows } %]\n    <br />\n\n    [% FOREACH hidden IN hiddens.keys;\n        PROCESS input element_data={\n            type => 'hidden',\n            name => hidden,\n            value => hiddens.item(hidden)\n            }; END %]\n    [% FOREACH button IN buttons; PROCESS button element_data=button; END %]\n    </form>\n  </div></div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\nstylesheet=\"ledgersmb.css\"\ninclude_stylesheet=[\"system/setup.css\"] %]\n[% PROCESS elements.html %]\n<body id=\"setup-new-user\" class=\"lsmb [% dojo_theme %]\">\n  <div>\n    <div class=\"setupconsole\">\n      <h2>[% text('Database Management Console') %]</h2>\n      <div class=\"listtop\">[% text('Enter User') %]</div>\n      <form data-dojo-type=\"lsmb/SimpleForm\"\n            action=\"setup.pl\" method=\"POST\" name=\"new_user\">\n        <input type=\"hidden\" name=\"csrf_token\" value=\"[% csrf_token %]\" />\n        [% INCLUDE input element_data = {\n                      name = 'database'\n                      type = 'hidden'\n                      value = database\n        } %]\n        <div style=\"display:grid;gap:0.3em;grid-template-columns:auto auto\">\n          [% INCLUDE input element_data = {\n                      name  = 'username'\n                      type  = 'text'\n                      label = text('Username')\n                      class = 'username'\n                      value = username\n                      required = 'required'\n          } %]\n          <label id=\"password-label\" for=\"password\" class=\"password\">[%\n            text('Password') %]</label>\n          [% PROCESS input element_data = {\n                      name='password'\n                      type='password'\n                      class = 'password'\n                      size='60',\n                      attributes = { autocomplete = 'off' }\n          } %]\n          <label>[% text('User creation') %]</label>\n          <div class=\"input_group\">\n            <div>\n              [%\n                label_pos = 1 ;\n                PROCESS input element_data = {\n                      label   = text(\"Create new user\")\n                      value   = '0'\n                      checked = 'CHECKED'\n                      name    = 'pls_import'\n                      type    = 'radio'\n              }\n               %]\n            </div>\n            <div style=\"float:left\">\n              [% label_pos = 1;\n                 PROCESS input element_data = {\n                      label   = text(\"Import existing user\")\n                      value   = '1'\n                      checked = ''\n                      name    = 'pls_import'\n                      type    = 'radio'\n              } ;\n              label_pos = -1;\n              %]\n            </div>\n            [%- IF notice -%]\n            <div class=\"notice\" style=\"float:left\">[% notice %]</div>\n            [%- END # IF notice -%]\n            <div data-dojo-type=\"dijit/Tooltip\"\n                 data-dojo-props=\"connectId:'pls-import-1',position:['below']\">\n              <div style=\"width:30em\">\n                <b>Import an existing user (from another database)</b>\n                <br /><br />\n                This username exists because it is being used with another\n                database; using it with the current database requires it to\n                be <em>imported</em>.\n                <br /><br />\n                <em>The password for both databases will be the same. Providing\n                  a password when importing a user, also resets the password\n                  for the other companies.\n                </em>\n                <br /><br />\n                Note that technically any existing PostgreSQL &quot;role&quot;\n                that is to be used as a username needs to be imported this way,\n                regardless of whether it is a username in a different database.\n              </div>\n            </div>\n            <div data-dojo-type=\"dijit/Tooltip\"\n                 data-dojo-props=\"connectId:'pls-import-0'\">\n              <div style=\"width:30em\">\n                <b>Creates a new user</b><br />\n                This username <em>must not</em> be used by any of the other\n                databases. If you want to use a username that is already used\n                with another database, you can do so by selecting the\n                <b>Import</b> option.\n              </div>\n            </div>\n          </div>\n          [% INCLUDE select element_data = {\n                options       = salutations\n                text_attr     = 'salutation'\n                value_attr    = 'id'\n                default_blank = 1\n                default_values = [salutation_id]\n                name           = 'salutation_id'\n                label          = 'Salutation'\n                required       = 'required'\n          };\n          INCLUDE input element_data = {\n                name     = 'first_name'\n                class    = 'name'\n                type     = 'text'\n                size     = '15'\n                value    = first_name\n                label    = text('First Name')\n                required = 'required'\n          };\n          INCLUDE input element_data = {\n                name     = 'last_name'\n                class    = 'name'\n                type     = 'text'\n                size     = '15'\n                value    = last_name\n                label    = text('Last name')\n                required = 'required'\n          };\n          INCLUDE input element_data = {\n                name = 'employeenumber'\n                class = 'control_code'\n                type = 'text'\n                size = '15'\n                label = text('Employee Number')\n                value = employeenumber\n                required = 'required'\n          };\n          INCLUDE input element_data = {\n                name = 'dob'\n                type = 'date'\n                size = '10'\n                label = text('Date of Birth')\n                value = dob\n                required = 'required'\n          };\n          INCLUDE input element_data = {\n                name = 'ssn'\n                class = 'tax_id'\n                type = 'text'\n                size = '15'\n                label = text('Tax ID/SSN')\n                value = ssn\n                required = 'required'\n          };\n          INCLUDE select element_data = {\n                options = countries\n                text_attr = 'name'\n                value_attr = 'id'\n                default_blank = 1\n                default_values = [country_id]\n                name = 'country_id'\n                label = 'Country'\n                required = 'required'\n          };\n          INCLUDE select element_data = {\n                options = perm_sets\n                text_attr = 'label'\n                value_attr = 'id'\n                name = 'perms'\n                default_blank = 1\n                default_values = [perms]\n                label = 'Assign Permissions'\n                required = 'required'\n          };\n          INCLUDE button element_data = {\n                text = text('Create User') #';\n                name = '__action'\n                value = save_action\n                type = 'submit'\n                class = 'submit'\n          } %]\n        </div>\n      </form>\n    </div>\n  </div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\nstylesheet=\"ledgersmb.css\"\ninclude_stylesheet=[\"system/setup.css\"] %]\n[% PROCESS elements.html %]\n<body id=\"setup-select-coa\" class=\"lsmb [% dojo_theme %]\">\n<div class=\"setupconsole\">\n<h2>[% text('Database Management Console') %]</h2>\n<div><div class=\"listtop\">[% title %]</div>\n<form data-dojo-type=\"lsmb/SimpleForm\" action=\"setup.pl\" method=\"POST\" name=\"credentials\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"[% csrf_token %]\" />\n  <div id=\"sep\" class=\"listheading\">\n    Pre-defined Chart-of-Accounts selection\n  </div>\n\n  [% IF coa_lc;\n   INCLUDE input element_data = {\n        name = 'coa_lc'\n        type = 'hidden'\n       value = coa_lc\n         } ;\n         %]\n  <p>\n    The selected country ('[% coa_lc %]') has the following charts\n    predefined.\n  </p>\n  [% ELSE %]\n  <p>\n    Please select a country from the list of countries with predefined\n    charts of accounts, or select Skip and define or import accounts and\n    headings later. Please do take note that you want to load a chart\n    for evaluation purposes as many functions depend on accounts of\n    certain types being defined.\n  </p>\n  [% END %]\n<div class=\"inputrow\">\n[% IF coa_lc;\n    INCLUDE select element_data = {\n         options = charts\n            name = 'chart'\n       text_attr = 'name'\n      value_attr = 'name'\n           label = text('Chart of accounts')\n    };\n    IF gifis.size > 0;\n-%]\n</div>\n<div class=\"inputrow\">\n[%\n       INCLUDE select element_data = {\n         options = gifis\n            name = 'gifi'\n       text_attr = 'name'\n      value_attr = 'name'\n           label = text('GIFI')\n       };\n    END;\n    IF sics.size > 0;\n-%]\n</div>\n<div class=\"inputrow\">\n[%\n       INCLUDE select element_data = {\n         options = sics\n            name = 'sic'\n       text_attr = 'name'\n      value_attr = 'name'\n           label = text('SIC')\n       };\n    END;\n   ELSE;\n    INCLUDE select element_data = {\n         options = coa_lcs\n            name = 'coa_lc'\n       text_attr = 'name'\n      value_attr = 'code'\n           label = text('Country') #'\n    };\nEND %]\n</div>\n<div class=\"inputrow\">\n[% INCLUDE input element_data = {\n    name = 'database'\n   value = database\n    type = 'hidden'\n} %]\n</div>\n<div class=\"inputrow\">\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'select_coa'\n    type = 'submit'\n   class = 'submit'\n    text = text('Next')\n} %]\n</div>\n<div class=\"inputrow\">\n[% INCLUDE button element_data = {\n    name = '__action'\n   value = 'skip_coa'\n    type = 'submit'\n   class = 'submit'\n    text = text('Skip')\n} %]\n</div>\n</form>\n</div></div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\n       stylesheet=\"ledgersmb.css\"\n       include_stylesheet=[\"system/setup.css\"] ;\n    PROCESS \"elements.html\"\n%]<body id=\"setup-template-info\" class=\"lsmb [% dojo_theme %]\">\n<div><div class=\"setupconsole\">\n<h2>[% text('Database Management Console') %]</h2>\n<form data-dojo-type=\"lsmb/SimpleForm\" action=\"setup.pl\" method=\"post\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"[% csrf_token %]\" />\n<div class=\"listtop\">[% text('Select Templates to Load') %]</div>\n[%\nPROCESS input element_data = {\n    type = \"hidden\"\n    name = \"database\"\n   value = database\n};\nPROCESS input element_data = {\n    type = \"hidden\"\n    name = \"only_templates\"\n   value = only_templates\n};\nPROCESS select element_data = {\n       name = \"template_dir\"\n    options = template_dirs\n      label = text('Templates')\n} %]<br />\n[% PROCESS button element_data = {\n      name = \"__action\"\n     value = templates_action\n      text = text('Load Templates') #'\n} %]\n</form>\n</div></div>\n</body>\n[% END %]\n", "[% WRAPPER \"ui-header.html\"\nstylesheet=\"ledgersmb.css\"\ninclude_stylesheet=[\"system/setup.css\"] %]\n[% PROCESS elements.html %]\n<body id=\"setup-upgrade-info\" class=\"lsmb [% dojo_theme %]\">\n<div><div class=\"setupconsole\">\n<h2>[% text('Database Management Console') %]</h2>\n<div class=\"listtop\">[% text('Upgrade Info') %]</div>\n<form data-dojo-type=\"lsmb/SimpleForm\"\n      action=\"setup.pl\" method=\"POST\"\n      name=\"upgrade_info\">\n  <input type=\"hidden\" name=\"csrf_token\" value=\"[% csrf_token %]\" />\n[% INCLUDE input element_data = {\n    name = 'database'\n    type = 'hidden'\n   value = database\n};\nINCLUDE input element_data = {\n    name = 'slschema'\n    type = 'hidden'\n   value = slschema\n};\nINCLUDE input element_data = {\n    name = 'lsmbversion'\n    type = 'hidden'\n   value = lsmbversion\n} %]\n<div class=\"form\">\n<p>\n  [% text('LedgerSMB has introduced three new system wide default values which ' _\n              'you will need to set as part of the upgrade process.') %]\n</p>\n<p>\n  [% text('In addition to these new defaults LedgerSMB 1.3 adds stricter ' _\n              'checks on data validity in the database. Because of these stricter checks ' _\n              'it''s no longer valid to leave companies without a country or customers ' _\n              'without accounts receivable reference. The defaults you choose below will ' _\n              'be used to add values where these are currently missing but required.') %]\n</p>\n<div class=\"input_row\">\n[% INCLUDE select element_data = {\n                          options = default_country\n                            name  = 'default_country'\n                           label  = text('Default Country') #'\n                            class = 'country'\n} %]\n</div>\n[% IF default_ar.size > 1; %]\n<div class=\"input_row\">\n<p>\n  [% text('LedgerSMB supports multiple <em>Accounts receivable (AR)</em> accounts ' _\n              'per company. One of those must be the system default. Please select ' _\n              'your default below in case of multiple. If the list below is empty, ' _\n              'your database is in an inconsistent state and needs to be fixed first.') %]\n</p>\n[% INCLUDE select element_data = {\n                            name  = 'default_ar'\n                           label  = text('Default AR') #'\n                            class = 'accno'\n                            options = default_ar\n} %]\n</div>\n[% ELSE;\nINCLUDE input element_data = {\n    name = 'default_ar'\n    type = 'hidden'\n   value = default_ar\n};\nEND %]\n[% IF default_ap.size > 1; %]\n<div class=\"input_row\">\n<p>\n  [% text('LedgerSMB supports multiple <em>Accounts payable (AP)</em> accounts ' _\n              'per company. One of those must be the system default. Please select ' _\n              'your default below in case of multiple. If the list below is empty, ' _\n              'your database is in an inconsistent state and needs to be fixed first.') %]\n</p>\n[% INCLUDE select element_data = {\n                            name  = 'default_ap'\n                           label  = text('Default AP') #'\n                            class = 'accno'\n                            options = default_ap\n} %]\n</div>\n[% ELSE;\nINCLUDE input element_data = {\n    name = 'default_ap'\n    type = 'hidden'\n   value = default_ap\n};\nEND %]\n<div class=\"input_row\">\n<p>\n  [% text('Note that the process invoked by hitting the button below might ' _\n              'take long to complete as it will run the upgrade process and will ' _\n              'copy all data from the 1.2 tables into the 1.3 tables.') %]\n</p>\n[% INCLUDE button element_data = {\n    text = text('Upgrade')\n    name = '__action'\n   value = upgrade_action\n    type = 'submit'\n   class = 'submit'\n} %]\n</div>\n</div>\n</form>\n</div></div>\n</body>\n[% END %]\n", "\npackage LedgerSMB;\n\n=head1 NAME\n\nLedgerSMB - The Base class for many LedgerSMB objects, including DBObject.\n\n=head1 DESCRIPTION\n\nThis module creates a basic request handler with utility functions available\nin database objects (LedgerSMB::DBObject)\n\n=head1 METHODS\n\n=over\n\n=item new ()\n\nThis method creates a new base request instance. It also validates the\nsession/user credentials, as appropriate for the run mode.  Finally, it sets up\nthe database connections for the user.\n\n=item verify_csrf()\n\nThis method verifies the C<csrf_token> value in request parameters (held in\nC<$self->{csrf_token}>) against the value in the session object.  When one is\nnot defined or they are not equal, this function returns a PSGI triplet to be\nused as the response resulting in a 400 -- Bad Request.\n\nWhen the CSRF token matches, C<undef> is returned indicating processing is to\ncontinue.\n\n=item open_form()\n\nThis sets a $self->{form_id} to be used in later form validation (anti-XSRF\nmeasure).\n\n=item close_form()\n\nThis returns true if the form_id was associated with the session, and false if\nnot and also removes the form_id from the\nsession.\n\n=item is_allowed_role({allowed_roles => @role_names})\n\nThis function returns 1 if the user's roles include any of the roles in\n@role_names.\n\n=item merge ($hashref, keys => @list, index => $number);\n\nThis command merges the $hashref into the current object.  If keys are\nspecified, only those keys are used.  Otherwise all keys are merged.\n\nIf an index is specified, the merged keys are given a form of\n\"$key\" . \"_$index\", otherwise the key is used on both sides.\n\n\n=item get_relative_url\n\nReturns the script and query string part of the URL of the GET request,\nwithout the script path, or undef.\n\nReturns a URL-decoded string to prevent double-encoding when the URL\nis round-tripped.x\n\n=cut\n\n=item upload([$filename])\n\nThis function returns - when called without arguments - the number of\nfiles in the upload data when called in scalar context or the names\nof the files when called in list context.\n\nCalling the function with a filename argument returns a filehandle\nto the content.\n\n=item call_procedure( procname => $procname, args => $args )\n\nFunction that allows you to call a stored procedure by name and map the appropriate argument to the function values.\n\nArgs is an arrayref.  The members of args can be scalars or arrayrefs in which\ncase they are just bound to the placeholders (arrayref to Pg array conversion\noccurs automatically in DBD::Pg 2.x), or they can be hashrefs of the following\nsyntax: {value => $data, type=> $db_type}.  The type field is any SQL type\nDBD::Pg supports (such as 'PG_BYTEA').\n\n=item dberror()\n\nLocalizes and returns database errors and error codes within LedgerSMB\n\n=item error()\n\nReturns HTML errors in LedgerSMB. Needs refactored into a general Error class.\n\n=item get_user_info()\n\nLoads user configuration info from LedgerSMB::User\n\n=item initialize_with_db\n\nThis function sets up the db handle for the request\n\n=item system_info($dbh)\n\nReturns a hashref with the keys being system information sections,\neach being a hashref detailing configuration items with their values.\n\n=item setting()\n\nAccessor method and lazy initialisation for a shared LedgerSMB::Setting\ninstance.\n\nReturns a reference to an initialised LedgerSMB::Setting instance.\n\n=item all_months()\n\nReturns hashref of localized date data with following members:\n\n=over\n\n=item dropdown\n\nMonth information in drop down format.\n\n=item hashref\n\nMonth info in hashref format in 01 => January format\n\n=back\n\n=item all_years()\n\nReturns hashref of localized date data with following members:\n\n=over\n\n=item dropdown\n\nMonth information in drop down format.\n\n=item hashref\n\nMonth info in hashref format in 01 => January format\n\n=back\n\n=item enabled_languages()\n\nReturns arrayref of hashes with the following keys:\n\n=over\n\n=item value\n\nThe code of the language as per the CLDR\n\n=item text\n\nThe name of the language, translated into the user's selected language\n\n=back\n\n=item enabled_countries()\n\nReturns arrayref of hashes with the following keys:\n\n=over\n\n=item id\n\nThe internal identifier for the country\n\n=item short_name\n\nThe 2-leter iso code of the country\n\n=item name\n\nThe country's full name translated into the user's selected language\n\n=back\n\n=item report_renderer_ui\n\nReturns a code reference to render a report on the UI - pass as the\nnamed argument 'renderer' to the C<LedgerSMB::Report->render> method.\n\n  my $report = LedgerSMB::Report\n  $report->render( renderer => $request->report_renderer_ui);\n\n\n=item report_renderer_doc\n\nReturns a code reference to render a report as a document - pass as the\nnamed argument 'renderer' to the C<LedgerSMB::Report->render> method.\n\n  my $report = LedgerSMB::Report\n  $report->render( renderer => $request->report_renderer_doc);\n\n\n=item render_report($report)\n\nRenders the report as a document or UI element, depending on whether\nthe request's C<format> property has a non-false value.\n\n\n=item parse_amount($amount)\n\nParses the $amount given the session user's number formatting settings.\n\n=item parse_date($date)\n\nParses the $date given the session user's date formatting settings.\n\n=item format_amount($amount, %args)\n\nformats the $amount given the session user's number formatting settings.\n\n=item formatter_options()\n\nReturns a hashref containing the session user's number and date formatting\npreferences for use in LedgerSMB::Report-s.\n\n=back\n\n\n=head1 Copyright (C) 2006-2023, The LedgerSMB core team.\n\n # This work contains copyrighted information from a number of sources\n # all used with permission.\n #\n # This file contains source code included with or based on SQL-Ledger\n # which is Copyright Dieter Simader and DWS Systems Inc. 2000-2005\n # and licensed under the GNU General Public License version 2 or, at\n # your option, any later version.  For a full list including contact\n # information of contributors, maintainers, and copyright holders,\n # see the CONTRIBUTORS file.\n #\n # Original Copyright Notice from SQL-Ledger 2.6.17 (before the fork):\n # Copyright (C) 2000\n #\n #  Author: DWS Systems Inc.\n #     Web: http://www.sql-ledger.org\n #\n # Contributors: Thomas Bayen <bayen@gmx.de>\n #               Antti Kaihola <akaihola@siba.fi>\n #               Moritz Bunkus (tex)\n #               Jim Rawlings <jim@your-dba.com> (DB2)\n #====================================================================\n=cut\n\nuse strict;\nuse warnings;\n\nuse Carp;\nuse DateTime::Format::Duration::ISO8601;\nuse Encode qw(perlio_ok);\nuse HTTP::Headers::Fast;\nuse HTTP::Status qw( HTTP_OK HTTP_BAD_REQUEST );\nuse List::Util qw( pairgrep );\nuse Locale::CLDR;\nuse Locales unicode => 1;\nuse Log::Any;\nuse PGObject;\nuse Plack;\nuse URI;\nuse URI::Escape;\n\nuse LedgerSMB::Company_Config;\nuse LedgerSMB::Locale;\nuse LedgerSMB::PGDate;\nuse LedgerSMB::PGNumber;\nuse LedgerSMB::PSGI::Util qw( template_response );\nuse LedgerSMB::Setting;\nuse LedgerSMB::Template;\nuse LedgerSMB::User;\n\nour $VERSION = '1.12.0-dev';\n\nmy $logger = Log::Any->get_logger(category => 'LedgerSMB');\nmy $expiration_parser = DateTime::Format::Duration::ISO8601->new;\n\nsub new {\n    my ($class, $request, $wire) = @_;\n    my $self = {};\n    bless $self, $class;\n\n    # Properties prefixed with underscore are hidden from UI templates.\n    #\n    # Some tests construct LedgerSMB objects without $auth argument\n    # (in fact, without any arguments), so check for having an $auth\n    # arg before trying to call methods on it.\n    $self->{login} = $request->env->{'lsmb.session'}->{login};\n    $self->{version} = $VERSION;\n    $self->{dbversion} = $VERSION;\n    $self->{_uploads} = $request->uploads if defined $request->uploads;\n    $self->{_cookies} = $request->cookies if defined $request->cookies;\n    $self->{query_string} = $request->query_string if defined $request->query_string;\n    $self->{script} = $request->env->{'lsmb.script'};\n    $self->{dbh} = $request->env->{'lsmb.app'};\n    $self->{company} = $request->env->{'lsmb.session'}->{company};\n    $self->{_session_id} = $request->env->{'lsmb.session_id'};\n    $self->{_create_session} = $request->env->{'lsmb.create_session_cb'};\n    $self->{_logout} = $request->env->{'lsmb.invalidate_session_cb'};\n    $self->{_setting} = $request->env->{'lsmb.setting'};\n    $self->{_req} = $request;\n    $self->{_wire} = $wire;\n\n    my $q = $self->{query_string} // '';\n    $self->{_uri} = URI->new(\n        $request->env->{'lsmb.script'} . ($q ? \"?$q\" : ''),\n        $request->request_uri\n        );\n\n    # Initialize ourselves from parameters in $self->{_req}\n    $self->_process_args;\n    $self->_set_default_locale();\n\n    return $self;\n}\n\n\nsub verify_csrf {\n    my ($self) = @_;\n    my $got = $self->{csrf_token};\n    my $want = $self->{_req}->env->{'lsmb.session'}->{csrf_token};\n    if (not ($got and $want and $got eq $want)) {\n        $logger->debug( \"CSRF have '$got'; want '$want'\" );\n        return [ HTTP_BAD_REQUEST,\n                 [ 'Content-Type' => 'text/plain; charset=ascii' ],\n                 [ 'Bad request: CSRF token failure' ] ];\n    }\n    return undef;\n}\n\nsub open_form {\n    my ($self) = @_;\n    my @vars = $self->call_procedure(procname => 'form_open',\n                              args => [$self->{_session_id}],\n                              continue_on_error => 1\n    );\n    return $self->{form_id} = $vars[0]->{form_open};\n}\n\nsub close_form {\n    my ($self) = @_;\n    my @vars = $self->call_procedure(funcname => 'form_close',\n                              args => [$self->{_session_id}, $self->{form_id}]\n    );\n    delete $self->{form_id};\n    return $vars[0]->{form_close};\n}\n\nsub initialize_with_db {\n    my ($self) = @_;\n    my $sth;\n\n\n    $sth = $self->{dbh}->prepare('SELECT check_expiration()')\n        or die $self->{dbh}->errstr;\n    $sth->execute or die $sth->errstr;\n    ($self->{warn_expire}) = $sth->fetchrow_array;\n\n    if ($self->{warn_expire}){\n        $sth = $self->{dbh}->prepare('SELECT user__check_my_expiration()')\n            or die $self->{dbh}->errstr;\n        $sth->execute or die $sth->errstr;\n        my ($pw_expires) = $sth->fetchrow_array;\n        $self->{pw_expires} = $expiration_parser->parse_duration($pw_expires);\n    }\n\n    $self->{_company_config} =\n        LedgerSMB::Company_Config::initialize($self->{dbh});\n\n    $self->get_user_info;\n\n    $self->{_locale} =\n        LedgerSMB::Locale->get_handle($self->{_user}->{language})\n        or $self->error(__FILE__.':'.__LINE__.\": Locale not loaded: $!\\n\");\n\n    $self->{stylesheet} =\n        $self->{_user}->{stylesheet} unless $self->{stylesheet};\n\n    return;\n}\n\n\nsub get_user_info {\n    my ($self) = @_;\n    $self->{_user} = LedgerSMB::User->fetch_config($self);\n    return $self->{_user}->{language} ||= 'en';\n}\n\nsub _set_default_locale {\n    my ($self) = @_;\n\n    my $lang = $self->{_wire}->get( 'default_locale' )\n        ->from_header( $self->{_req}->header( 'Accept-Language' ) );\n\n    $self->{_user}->{language} = $lang;\n    $self->{_user}->{dateformat} = 'YYYY-MM-DD';\n    $self->{_user}->{numberformat} = '1000.00';\n    $self->{_locale}=LedgerSMB::Locale->get_handle($lang);\n    $self->error( __FILE__ . ':' . __LINE__\n                  . \": Locale ($lang) not loaded: $!\\n\" )\n        unless $self->{_locale};\n\n    return;\n}\n\nsub _process_args {\n    my ($self) = @_;\n\n    # Prefer body parameters over query string parameters\n    # Normally, they shouldn't both be present, but there's at least a bug in\n    # Safari 15 which submits query parameters, even when told not to.\n    #\n    # $self->{_req}->parameters values query and body parameters equally, causing\n    # them to be collected into arrays when both are specified. This way, we\n    # prefer one over the other instead.\n    for my $args ($self->{_req}->query_parameters, $self->{_req}->body_parameters) {\n        for my $key (keys %$args){\n            my @values = grep { defined $_ && $_ ne '' } $args->get_all($key);\n            next if ! @values;\n\n            my $value = (@values == 1) ? $values[0] : \\@values;\n            next if $value eq '_!lsmb!empty!_';\n\n            $self->{$key} = $value;\n        }\n    }\n    return;\n}\n\nsub upload {\n    my ($self, $name) = @_;\n\n    if (! defined $name) {\n        return map { $_->basename } $self->{_uploads}->values;\n    }\n\n    my $upload = $self->{_uploads}->get($name) or return undef;\n    my $tmpfname = $upload->path;\n\n    my $headers = HTTP::Headers::Fast->new(\n        Content_Type => $upload->content_type\n    );\n    my $encoding = ':bytes';\n    my $charset = $headers->content_type_charset;\n    if ($charset) {\n        if (perlio_ok $charset) {\n            $encoding = ':encoding(' . $charset . ')';\n        }\n        else {\n            die \"Unsupported PerlIO encoding: $charset\";\n        }\n    }\n\n    open my $fh, \"<$encoding\", $tmpfname\n        or die \"Can't open uploaded temporary file $tmpfname: $!\";\n\n    my $bom_length = 0;\n    if (! $charset\n        && ($headers->content_is_text\n            || $headers->content_is_xml)\n        && -s $tmpfname >= 4) {\n        sysread $fh, my $bytes, 4;\n        if (\"\\xFF\\xFE\" eq substr($bytes, 0, 2)) {\n            $encoding = 'UTF-16LE';\n            $bom_length = 2;\n        }\n        elsif (\"\\xFE\\xFF\" eq substr($bytes, 0, 2)) {\n            $encoding = 'UTF-16BE';\n            $bom_length = 2;\n        }\n        elsif (\"\\xEF\\xBB\\xBF\" eq substr($bytes, 0, 3)) {\n            $encoding = 'UTF-8';\n            $bom_length = 3;\n        }\n        elsif (\"\\x00\\x00\\xFE\\xFF\" eq $bytes) {\n            $encoding = 'UTF-32LE';\n            $bom_length = 4;\n        }\n        elsif (\"\\xFF\\xFE\\x00\\x00\" eq $bytes) {\n            $encoding = 'UTF-32BE';\n            $bom_length = 4;\n        }\n        else { # no BOM\n            $encoding = 'UTF-8';\n            $bom_length = 0;\n        }\n        sysseek $fh, 0, 0;\n    }\n\n    if ($encoding) {\n        binmode $fh, ':encoding(' . $encoding . ')';\n    }\n    if ($bom_length) {\n        read($fh, my $unused, 1); # read the bom character\n    }\n\n    return $fh;\n}\n\nsub call_procedure {\n    my $self = shift;\n    my %args = @_;\n    $args{funcschema} ||= $self->{_wire}->get( 'db' )->schema;\n    $args{funcname} ||= $args{procname};\n    $args{dbh} = $self->{dbh};\n    $args{args} ||= [];\n    return PGObject->call_procedure(%args);\n}\n\n# Keeping this here due to common requirements\nsub is_allowed_role {\n    my ($self, $args) = @_;\n    my ($access) =  $self->call_procedure(\n         procname => 'lsmb__is_allowed_role', args => [$args->{allowed_roles}]\n    );\n    return $access->{lsmb__is_allowed_role};\n}\n\nsub error {\n    my ($self, $msg) = @_;\n    Carp::croak $msg;\n}\n\n\n# Database routines used throughout\n\nsub dberror{\n   my $self = shift @_;\n   my $state_error = {};\n   my $locale = $self->{_locale};\n   my $dbh = $self->{_dbh};\n   $state_error = {\n            '42883' => $locale->text('Internal Database Error'),\n            '42501' => $locale->text('Access Denied'),\n            '42401' => $locale->text('Access Denied'),\n            '22008' => $locale->text('Invalid date/time entered'),\n            '22012' => $locale->text('Division by 0 error'),\n            '22004' => $locale->text('Required input not provided'),\n            '23502' => $locale->text('Required input not provided'),\n            '23505' => $locale->text('Conflict with Existing Data.  Perhaps you already entered this?'),\n            'P0001' => $locale->text('Error from Function:') . \"\\n\" .\n                    $dbh->errstr,\n   };\n   $logger->error(\"Logging SQL State $dbh->state, error $dbh->err, string $dbh->errstr\");\n\n   if (defined $state_error->{$dbh->state}){\n       die $state_error->{$dbh->state}\n           . \"\\n\" .\n          $locale->text('More information has been reported in the error logs');\n   }\n   die $dbh->state . ':' . $dbh->errstr;\n}\n\nsub merge {\n    my ( $self, $src ) = @_;\n    for my $arg ( $self, $src ) {\n        shift;\n    }\n    my %args  = @_;\n    my @keys;\n    if (defined $args{keys}){\n         @keys  = @{ $args{keys} };\n    }\n    my $index = $args{index};\n    if ( !scalar @keys ) {\n        @keys = keys %{$src};\n    }\n    for my $arg ( @keys ) {\n        my $dst_arg;\n        if ($index) {\n            $dst_arg = $arg . \"_$index\";\n        }\n        else {\n            $dst_arg = $arg;\n        }\n        $self->{$dst_arg} = $src->{$arg};\n    }\n    return;\n}\n\nsub system_info {\n    my ($dbh) = @_;\n\n    return {\n        system => {\n            perl => $^V->stringify,\n            LedgerSMB => $VERSION,\n            Plack => $Plack::VERSION,\n            INCLUDE_PATH => join(\"\\n\", @INC),\n        }\n    };\n}\n\nsub setting {\n    my ($self) = @_;\n\n    unless($self->{_setting}) {\n        $self->{dbh} or croak(\n            'cannot initialise LedgerSMB::Setting object -'.\n            'database handler is undefined'\n        );\n        $self->{_setting} = LedgerSMB::Setting->new();\n        $self->{_setting}->set_dbh($self->{dbh});\n    }\n\n    return $self->{_setting};\n}\n\nsub all_months {\n    my ($self) = @_;\n    my $i18n = $self->{_locale};\n    my $months = {\n     '01' => $i18n->text('January'),\n     '02' => $i18n->text('February'),\n     '03' => $i18n->text('March'),\n     '04' => $i18n->text('April'),\n     '05' => $i18n->text('May'),\n     '06' => $i18n->text('June'),\n     '07' => $i18n->text('July'),\n     '08' => $i18n->text('August'),\n     '09' => $i18n->text('September'),\n     '10' => $i18n->text('October'),\n     '11' => $i18n->text('November'),\n     '12' => $i18n->text('December'),\n    };\n\n    my $for_dropdown = [];\n    my $as_hashref = {};\n    for my $key (sort {$a cmp $b} keys %$months){\n        push @$for_dropdown, {text => $months->{$key}, value => $key};\n    }\n    return { as_hashref => $months, dropdown=> $for_dropdown };\n}\n\nsub all_years {\n    my ($self) = @_;\n\n    my @years = $self->call_procedure(\n        funcname => 'date_get_all_years'\n        );\n\n    return { as_hashref => \\@years,\n             dropdown => [ map { +{ text => $_->{date_get_all_years},\n                                    value => $_->{date_get_all_years} }\n                           } @years ] };\n}\n\nsub enabled_languages {\n    my ($self) = @_;\n\n    my $l = Locales->new( $self->{_user}->{language} );\n    return [\n        map {\n            +{\n                value => $_->{code},\n                text => ucfirst($l->get_language_from_code($_->{code})\n                                // $_->{description})\n            }\n        } $self->call_procedure(funcname => 'person__list_languages')\n        ];\n}\n\nsub enabled_countries {\n    my ($self) = @_;\n\n    my $regions = Locale::CLDR->new($self->{_user}->{language})->all_regions;\n    return [\n        map {\n            +{\n                $_->%*,\n                name => $regions->{$_->{short_name}} // $_->{name}\n            }\n        } $self->call_procedure(funcname => 'location_list_country')\n        ];\n}\n\nsub report_renderer_ui {\n  my ($request) = @_;\n  my $ui = $request->{_wire}->get('ui');\n  my $uri = $request->{_uri}->clone;\n  if (not pairgrep { $a eq 'company' } $uri->query_form) {\n      $uri->query_form(\n          $uri->query_form,\n          company => $request->{company},\n          );\n  }\n\n  return sub {\n      my ($template_name, $report, $vars, $cvars) = @_;\n      $vars->{REPORT_LINK} = $uri->as_string;\n      $vars->{SCRIPT} = $request->{script};\n      $vars->{SETTINGS} = {\n          papersize    => 'letter', # default paper size when not configured\n          (%{$request->{_company_config} // {}},)\n      };\n      $vars->{SETTINGS}->{company_name} ||= $request->{company};\n      $vars->{HIDDENS} = $request->{hiddens};\n      $vars->{FORM_ID} = $request->{form_id};\n\n      return $ui->render($request, \"Reports/$template_name\", $vars, $cvars);\n  };\n}\n\nsub report_renderer_doc {\n    my ($request) = @_;\n    my $renderer =\n        $request->{_wire}->get( 'output_formatter' )->report_doc_renderer(\n            $request->{_dbh},\n            $request->formatter_options,\n            uc($request->{format}) || 'HTML',\n            {\n                SETTINGS => {\n                     # default paper size when not configured\n                    papersize    => 'letter',\n                    (%{$request->{_company_config} // {}},)\n                }\n            });\n\n    return sub {\n        my ($template_name, $report, $vars, $cvars) = @_;\n\n        return template_response(\n            $renderer->( $template_name, $report, $vars, $cvars ),\n            disposition => 'attach' );\n    };\n}\n\n\nsub render_report {\n    my ($request, $report) = @_;\n\n    my $renderer;\n    if ($request->{format}) {\n        # render as (stand alone) document\n        $renderer = $request->report_renderer_doc;\n    }\n    else {\n        # render as UI element\n        $renderer = $request->report_renderer_ui;\n    }\n    return $report->render( renderer => $renderer);\n}\n\n\nsub parse_amount {\n    my ($request, $amount_str) = @_;\n    my $config = $request->{_user};\n\n    return LedgerSMB::PGNumber->from_input(\n        $amount_str,\n        format => $config->{numberformat}\n        );\n}\n\nsub parse_date {\n    my ($request, $date_str) = @_;\n    my $config = $request->{_user};\n\n    return LedgerSMB::PGDate->from_input(\n        $date_str,\n        format => $config->{dateformat}\n        );\n}\n\nsub format_amount {\n    my ($request, $amount, %args) = @_;\n    my $config = $request->{_user};\n\n    return $amount->to_output(\n        format => $config->{numberformat},\n        money_places => $LedgerSMB::Company_Config::settings->{decimal_places},\n        %args\n        );\n}\n\nsub formatter_options {\n    my ($request) = @_;\n    my $config = $request->{_user};\n\n    return {\n        $config->%{ qw( numberformat dateformat ) },\n        money_places => $LedgerSMB::Company_Config::settings->{decimal_places},\n    };\n}\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (C) 2006-2023 The LedgerSMB Core Team\n\nThis file is licensed under the GNU General Public License version 2, or at your\noption any later version.  A copy of the license should have been included with\nyour software.\n\n=cut\n\n\n1;\n", "\npackage LedgerSMB::Middleware::SessionStorage;\n\n=head1 NAME\n\nLedgerSMB::Middleware::SessionStorage - Client side session (cookie) storage\n\n=head1 SYNOPSIS\n\n builder {\n   enable \"+LedgerSMB::Middleware::SessionStorage\",\n         domain   => 'setup',\n         cookie   => 'LedgerSMB/setup',\n         duration => 15*60;\n   $app;\n }\n\n=head1 DESCRIPTION\n\nLedgerSMB::Middleware::SessionStorage makes sure session state exists\n(but empty if it didn't exist before) and is persisted at the end of\nthe request.\n\n=cut\n\nuse strict;\nuse warnings;\nuse parent qw ( Plack::Middleware );\n\nuse Cookie::Baker;\nuse Plack::Request;\nuse Plack::Util;\nuse Plack::Util::Accessor\n    qw( cookie cookie_path domain duration inner_serialize secret store );\nuse Session::Storage::Secure;\nuse String::Random;\n\nuse LedgerSMB::PSGI::Util;\n\n=head1 METHODS\n\n=head2 $self->prepare_app\n\nImplements C<Plack::Component->prepare_app()>.\n\n=head2 $self->call($env)\n\nImplements C<Plack::Middleware->call()>.\n\n=cut\n\nsub prepare_app {\n    my $self = shift;\n    my $store = Session::Storage::Secure->new(\n        secret_key => $self->secret,\n        default_duration => 24*60*60*90, # 90 days\n        );\n    $self->store( $store );\n}\n\nsub call {\n    my $self = shift;\n    my ($env) = @_;\n    my $req = Plack::Request->new($env);\n\n    my $cookie             = $req->cookies->{$self->cookie};\n    my $session            = $self->store->decode($cookie);\n    $session->{csrf_token} //= String::Random->new->randpattern('.' x 23);\n\n    my $secure = defined($env->{HTTPS}) && $env->{HTTPS} eq 'ON';\n    my $path =\n        $self->cookie_path //\n        LedgerSMB::PSGI::Util::cookie_path($env->{SCRIPT_NAME});\n    $env->{'lsmb.session'} = $session;\n    return Plack::Util::response_cb(\n        $self->app->($env), sub {\n            my $res = shift;\n\n            if (! $self->inner_serialize) {\n                my $_cookie_attributes = {\n                    value    => $self->store->encode(\n                        $env->{'lsmb.session'},\n                        time + ($env->{'lsmb.session.duration'}\n                                // $self->duration)),\n                    httponly => 1,\n                    path     => $path,\n                    secure   => $secure,\n                    samesite => 'Strict',\n                    expires  => ($env->{'lsmb.session.expire'}\n                                    ? '1' : undef),\n                };\n                Plack::Util::header_push(\n                    $res->[1], 'Set-Cookie',\n                    bake_cookie(\n                        $self->cookie,\n                        $_cookie_attributes\n                    ));\n            }\n        });\n}\n\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (C) 2020-2024 The LedgerSMB Core Team\n\nThis file is licensed under the GNU General Public License version 2, or at your\noption any later version.  A copy of the license should have been included with\nyour software.\n\n=cut\n\n\n1;\n", "package LedgerSMB::PSGI;\n\n=head1 NAME\n\nLedgerSMB::PSGI - PSGI application routines for LedgerSMB\n\n=head1 DESCRIPTION\n\nMaps the URL name space to the various entry points.\n\n=head1 SYNOPSIS\n\n use LedgerSMB::PSGI;\n my $app = LedgerSMB::PSGI->get_app();\n\n=head1 METHODS\n\nThis module doesn't specify any (public) methods.\n\n=cut\n\nuse strict;\nuse warnings;\n\nuse LedgerSMB;\nuse LedgerSMB::App_State;\nuse LedgerSMB::Company_Config;\nuse LedgerSMB::oldHandler;\nuse LedgerSMB::Magic qw( SCRIPT_NEWSCRIPTS );\nuse LedgerSMB::PSGI::Util;\nuse LedgerSMB::Router keywords => [ qw( router ) ];\nuse LedgerSMB::Routes::ERP::API::Accounts;\nuse LedgerSMB::Routes::ERP::API::Contacts;\nuse LedgerSMB::Routes::ERP::API::Countries;\nuse LedgerSMB::Routes::ERP::API::Goods;\nuse LedgerSMB::Routes::ERP::API::GeneralLedger;\nuse LedgerSMB::Routes::ERP::API::Invoices;\nuse LedgerSMB::Routes::ERP::API::MenuNodes;\nuse LedgerSMB::Routes::ERP::API::Languages;\nuse LedgerSMB::Routes::ERP::API::Products;\nuse LedgerSMB::Routes::ERP::API::Session;\nuse LedgerSMB::Routes::ERP::API::Templates;\nuse LedgerSMB::Setting;\n\nuse CGI::Emulate::PSGI;\nuse HTTP::Status qw( HTTP_FOUND );\nuse List::Util qw{  none };\nuse Log::Any;\nuse Log::Log4perl;\nuse Scalar::Util qw{ reftype };\nuse String::Random;\nuse Feature::Compat::Try;\n\n# To build the URL space\nuse Plack;\nuse Plack::Builder;\nuse Plack::Request::WithEncoding;\nuse Plack::App::File;\nuse Plack::Middleware::ConditionalGET;\nuse Plack::Middleware::ReverseProxy;\nuse Plack::Builder::Conditionals;\nuse Plack::Util;\n\n\nuse English;\nif ($EUID == 0) {\n    die join(\"\\n\",\n        'Running a Web Service as root is a security problem.',\n        'If you are starting LedgerSMB as a system service,',\n        'please make sure that you drop privileges as per README.md',\n        'and the example files in doc/conf/.',\n        'The method of passing a --user argument to starman cannot',\n        'be used as starman drops privileges too late, starting us as root.'\n    );\n}\n\nlocal $@ = undef; # localizes just for initial load.\neval { require LedgerSMB::Template::LaTeX; };\n\n=head1 FUNCTIONS\n\n=over\n\n=item old_app\n\nReturns a 'PSGI app' which handles requests for the 'old-code' scripts in old/bin/\n\n=cut\n\nsub old_app {\n    my $script = shift;\n    my $wire = shift;\n\n    # marshall the psgi environment into the cgi environment\n    # so we can re-use state from the various middlewares\n    return sub {\n        my $env = shift;\n\n        return Plack::Util::response_cb(\n            CGI::Emulate::PSGI->handler(\n                sub {\n                    local $ENV{CONTENT_LENGTH} = $ENV{CONTENT_LENGTH} // 0;\n\n                    if (my $cpid = fork()){\n                        waitpid $cpid, 0;\n                    } else {\n                        # make 100% sure any \"die\"-s don't bubble up higher than\n                        # this point in the stack: we're a fork()ed process and\n                        # should under no circumstance end up acting like another\n                        # worker. When we are done, we need to exit() below.\n                        try {\n                            local ($!, $@) = (undef, undef);\n                            # the lsmb_legacy package is created by the\n                            # oldHandler use statement\n                            unless ( lsmb_legacy->handle($script, $env, $wire) ) { ## no critic (RequireExplicitInclusion)\n                                if ($! or $@) {\n                                    print \"Status: 500 Internal server error (PSGI.pm)\\n\\n\";\n                                    warn \"Failed to execute old request ($!): $@\\n\";\n                                }\n                            }\n                        }\n                        catch ($e) {\n                        }\n                        exit;\n                    }\n                    return;\n                }\n            )->($env),\n            sub {\n                Plack::Util::header_set($_[0]->[1],\n                                        'Content-Security-Policy',\n                                        q{frame-ancestors 'self'});\n                if (not Plack::Util::header_exists($_[0]->[1],\n                                                   'X-LedgerSMB-App-Content')) {\n                    Plack::Util::header_push($_[0]->[1],\n                                             'X-LedgerSMB-App-Content', 'yes');\n                }\n            });\n    }\n}\n\n\n=item psgi_app\n\nImplements a PSGI application for the purpose of calling the entry-points\nin LedgerSMB::Scripts::*.\n\n=cut\n\n\nsub psgi_app {\n    my $wire = shift;\n\n    return sub {\n        my $env = shift;\n        my $psgi_req = Plack::Request::WithEncoding->new($env);\n        my $request = LedgerSMB->new($psgi_req, $wire);\n\n        $request->{__action} = $env->{'lsmb.action_name'};\n        my $res;\n        try {\n            LedgerSMB::App_State::run_with_state sub {\n\n                $request->initialize_with_db if $request->{dbh};\n                $res = $env->{'lsmb.action'}->($request);\n            }, DBH     => $env->{'lsmb.db'};\n\n            $request->{dbh}->commit if defined $request->{dbh};\n        }\n        catch ($error) {\n            # Explicitly roll back, because middleware may require the\n            # database connection to be in a working state (e.g. DisableBackbutton)\n            $request->{dbh}->rollback\n                if $request->{dbh};\n            if ($error !~ /^Died at/) {\n                $env->{'psgix.logger'}->({\n                    level => 'error',\n                    message => $error });\n                $res = LedgerSMB::PSGI::Util::internal_server_error(\n                    $error,\n                    'Error!',\n                    $request->{company},\n                    $request->{dbversion},\n                    );\n            }\n            else {\n                $res = [ '500', [ 'Content-Type' => 'text/plain' ], [ $error ]];\n            }\n        }\n\n        return Plack::Util::response_cb(\n            $res,\n            sub {\n                my $res = shift;\n                Plack::Util::header_set($res->[1],\n                                        'Content-Security-Policy',\n                                        q{frame-ancestors 'self'});\n            });\n    };\n}\n\n=item setup_url_space(development => $boolean, coverage => $boolean)\n\nSets up the URL space for the PSGI app, pointing various URLs at the\nappropriate PSGI handlers/apps.\n\n=cut\n\nsub _hook_psgi_logger {\n    my ($env, $settings, $router) = @_;\n    my $logger_name = $settings->{logger} ? \".$settings->{logger}\" : '';\n    my $logger = Log::Any->get_logger(category => \"LedgerSMB$logger_name\");\n\n    $env->{'psgix.logger'} = sub {\n        my ($level, $msg) = @{$_[0]}{qw/ level message /};\n\n        return if not defined $msg;\n\n        local $Log::Log4perl::caller_depth = $Log::Log4perl::caller_depth + 1;\n        $logger->$level( ($msg =~ s/\\n/\\\\n/gr) );\n        return;\n    };\n\n    return;\n}\n\nsub setup_url_space {\n    my %args        = @_;\n    my $wire        = $args{wire};\n    my $psgi_app    = psgi_app($wire);\n\n    my $cookie      = $wire->get( 'cookie' )->{name} // 'LedgerSMB';\n    my $secret      = $wire->get( 'cookie' )->{secret} //\n        String::Random->new->randpattern('.' x 50);\n\n    return builder {\n        if (my $proxy_ip = eval { $wire->get( 'miscellaneous/proxy_ip' ); }) {\n            enable match_if addr([ split / /, $proxy_ip ]), 'ReverseProxy';\n        }\n        enable match_if path(qr!.+\\.(css|js|png|ico|jp(e)?g|gif)$!),\n            'ConditionalGET';\n\n        # not using LedgerSMB::Magic::SCRIPT_OLDSCRIPTS:\n        #   it has more than only entry-points\n        mount \"/$_.pl\" => builder {\n            my $script = $_;\n            enable '+LedgerSMB::Middleware::RequestID';\n            enable 'AccessLog', format => 'Req:%{Request-Id}i %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"';\n            enable '+LedgerSMB::Middleware::SessionStorage',\n                domain          => 'main',\n                cookie          => $cookie,\n                duration        => 60*60*24*90,\n                secret          => $secret,\n                # can marshall state in, but not back out (due to forking)\n                # so have the inner scope handle serialization itself\n                inner_serialize => 1;\n            enable '+LedgerSMB::Middleware::Log4perl',\n                script          => $script;\n            enable '+LedgerSMB::Middleware::Authenticate::Company',\n                provide_connection => 'closed',\n                factory            => $wire->get( 'db' );\n            enable '+LedgerSMB::Middleware::MainAppConnect',\n                provide_connection => 'closed',\n                require_version    => $LedgerSMB::VERSION;\n            old_app($script, $wire)\n        }\n        for ('aa', 'am', 'ap', 'ar', 'gl', 'ic', 'ir', 'is', 'oe', 'pe');\n\n        mount \"/$_\" => builder {\n            my $script = $_;\n            enable '+LedgerSMB::Middleware::RequestID';\n            enable 'AccessLog',\n                format => 'Req:%{Request-Id}i %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"';\n            enable '+LedgerSMB::Middleware::SessionStorage',\n                domain   => 'main',\n                cookie   => $cookie,\n                secret   => $secret,\n                duration => 60*60*24*90;\n            enable '+LedgerSMB::Middleware::DynamicLoadWorkflow',\n                max_post_size => $wire->get( 'miscellaneous/max_upload_size' ),\n                script   => $script;\n            enable '+LedgerSMB::Middleware::Log4perl',\n                script   => $script;\n            enable '+LedgerSMB::Middleware::Authenticate::Company',\n                provide_connection => 'open',\n                factory         => $wire->get( 'db' );\n            enable '+LedgerSMB::Middleware::MainAppConnect',\n                provide_connection => 'open',\n                require_version => $LedgerSMB::VERSION;\n            enable '+LedgerSMB::Middleware::DisableBackButton';\n            $psgi_app;\n        }\n        for  (grep { $_ !~ m/^(login|setup)[.]pl$/ } (SCRIPT_NEWSCRIPTS)->@*);\n\n        mount '/login.pl' => builder {\n            enable '+LedgerSMB::Middleware::RequestID';\n            enable 'AccessLog',\n                format => 'Req:%{Request-Id}i %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"';\n            enable '+LedgerSMB::Middleware::SessionStorage',\n                domain   => 'main',\n                cookie   => $cookie,\n                secret   => $secret,\n                duration => 60*60*24*90;\n            enable '+LedgerSMB::Middleware::DynamicLoadWorkflow',\n                max_post_size => $wire->get( 'miscellaneous/max_upload_size' ),\n                script   => 'login.pl';\n            enable '+LedgerSMB::Middleware::Log4perl',\n                script   => 'login.pl';\n            enable '+LedgerSMB::Middleware::Authenticate::Company',\n                provide_connection => 'none',\n                factory         => $wire->get( 'db' );\n            enable '+LedgerSMB::Middleware::MainAppConnect',\n                provide_connection => 'none',\n                require_version => $LedgerSMB::VERSION;\n            enable '+LedgerSMB::Middleware::DisableBackButton';\n            $psgi_app;\n        };\n\n        mount '/erp/api/v0' => builder {\n            enable '+LedgerSMB::Middleware::RequestID';\n            enable 'AccessLog',\n                format => 'Req:%{Request-Id}i %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"';\n            enable '+LedgerSMB::Middleware::SessionStorage',\n                domain      => 'main',\n                cookie      => $cookie,\n                cookie_path => '/',\n                secret      => $secret,\n                duration    => 60*60*24*90;\n            enable '+LedgerSMB::Middleware::Authenticate::Company',\n                provide_connection => 'open',\n                factory         => $wire->get( 'db' );\n            enable '+LedgerSMB::Middleware::MainAppConnect',\n                provide_connection => 'open',\n                require_version => $LedgerSMB::VERSION;\n\n            my $router = router 'erp/api';\n            $router->hooks('before' => \\&_hook_psgi_logger);\n            $router->hooks(\n                'before' => sub {\n                    my ($env) = @_;\n                    $env->{'lsmb.settings'} =\n                        LedgerSMB::Company_Config::initialize($env->{'lsmb.db'});\n                    $env->{wire} = $wire;\n                    return;\n                });\n            sub { return $router->dispatch(@_); };\n        };\n\n        mount '/setup.pl' => builder {\n            enable '+LedgerSMB::Middleware::RequestID';\n            enable 'AccessLog',\n                format => 'Req:%{Request-Id}i %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"';\n            enable '+LedgerSMB::Middleware::DynamicLoadWorkflow',\n                max_post_size => $wire->get( 'miscellaneous/max_upload_size' ),\n                script => 'setup.pl';\n            enable '+LedgerSMB::Middleware::Log4perl',\n                script => 'setup.pl';\n            enable '+LedgerSMB::Middleware::SessionStorage',\n                domain      => 'setup',\n                cookie      => \"$cookie~setup\",\n                cookie_path => '/',\n                secret      => $secret,\n                duration    => 60*60*24*90;\n            enable '+LedgerSMB::Middleware::SetupAuthentication';\n            enable '+LedgerSMB::Middleware::DisableBackButton';\n            $psgi_app;\n        };\n\n        enable sub {\n            my $app = shift;\n\n            return sub {\n                my $env = shift;\n\n                return [ HTTP_FOUND,\n                         [ Location => 'login.pl' ],\n                         [ '' ] ]\n                             if $env->{PATH_INFO} eq '/';\n\n                return $app->($env);\n            }\n        };\n\n        mount '/' => Plack::App::File->new( root => $wire->get('paths/UI') )->to_app;\n    };\n\n}\n\n\n\n\n=back\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (C) 2014-2018 The LedgerSMB Core Team\n\nThis file is licensed under the GNU General Public License version 2, or at your\noption any later version.  A copy of the license should have been included with\nyour software.\n\n=cut\n\n\n1;\n", "\npackage LedgerSMB::Scripts::setup;\n\n=head1 NAME\n\nLedgerSMB::Scripts::setup - web entry points for database administration\n\n=head1 DESCRIPTION\n\nThe workflows for creating new databases, updating old ones, and running\nmanagement tasks.\n\n=head1 METHODS\n\n=over\n\n=cut\n\n# DEVELOPER NOTES:\n# This script currently is required to maintain all its own database connections\n# for the reason that the database logic is fairly complex.  Most of the time\n# these are maintained inside the LedgerSMB::Database package.\n#\n\nuse strict;\nuse warnings;\nuse version;\n\nuse Carp;\nuse Digest::MD5 qw(md5_hex);\nuse Encode;\nuse File::Spec;\nuse HTML::Escape;\nuse HTTP::Status qw( HTTP_OK HTTP_INTERNAL_SERVER_ERROR HTTP_UNAUTHORIZED );\nuse Log::Any;\nuse MIME::Base64;\nuse Scope::Guard;\nuse Feature::Compat::Try;\n\nuse LedgerSMB;\nuse LedgerSMB::App_State;\nuse LedgerSMB::Company;\nuse LedgerSMB::Database;\nuse LedgerSMB::Database::Config;\nuse LedgerSMB::Database::ConsistencyChecks;\nuse LedgerSMB::Entity::User;\nuse LedgerSMB::Entity::Person::Employee;\nuse LedgerSMB::I18N;\nuse LedgerSMB::Magic qw( EC_EMPLOYEE HTTP_454 PERL_TIME_EPOCH );\nuse LedgerSMB::Mailer;\nuse LedgerSMB::PGDate;\nuse LedgerSMB::PSGI::Util;\nuse LedgerSMB::Setting;\nuse LedgerSMB::Setup::SchemaChecks qw( html_formatter_context );\nuse LedgerSMB::Template::DB;\nuse LedgerSMB::Database::Upgrade;\nuse LedgerSMB::User;\n\n\n\nmy $logger = Log::Any->get_logger(category => 'LedgerSMB::Scripts::setup');\nmy $CURRENT_MINOR_VERSION;\nif ( $LedgerSMB::VERSION =~ /(\\d+\\.\\d+)./ ) {\n    $CURRENT_MINOR_VERSION = $1;\n}\n\n=item authenticate\n\nThis method is a remnant of authentication shared with\nlogin.pl.\n\n=cut\n\nsub authenticate {\n    my ($request) = @_;\n    my $creds = $request->{_req}->env->{'lsmb.auth'}->get_credentials;\n\n    return [ HTTP_UNAUTHORIZED,\n             [ 'WWW-Authenticate' => 'Basic realm=\"LedgerSMB\"',\n               'Content-Type' => 'text/text; charset=UTF-8' ],\n             [ 'Please enter your credentials' ] ]\n        if ! defined $creds->{password};\n\n    return [ HTTP_OK,\n             [ 'Content-Type' => 'text/plain; charset=utf-8' ],\n             [ 'Success' ] ];\n}\n\n\nsub __default {\n    my ($request) = @_;\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/credentials', $request);\n}\n\nsub _get_database {\n    my ($request) = @_;\n    my $creds = $request->{_req}->env->{'lsmb.auth'}->get_credentials;\n    $request->{login} = $creds->{login};\n\n    return [ HTTP_UNAUTHORIZED,\n             [ 'WWW-Authenticate' => 'Basic realm=\"LedgerSMB\"',\n               'Content-Type' => 'text/text; charset=UTF-8' ],\n             [ 'Please enter your credentials' ] ]\n        if ! defined $creds->{password};\n\n    # Ideally this regex should be configurable per instance, and possibly per admin user\n    # for now we simply use a fixed regex. It will cover many if not most use cases.\n    return [ HTTP_454,\n             [ 'WWW-Authenticate' => 'Basic realm=\"LedgerSMB\"',\n               'Content-Type' => 'text/html; charset=UTF-8' ],\n             [ \"<html><body><h1 align='center'>Access to the ($request->{database}) database is Forbidden!</h1></br><h4 align='center'><a href='/setup.pl?database=$request->{database}'>return to setup</a></h4></body></html>\" ] ]\n        if ( $request->{database} && $request->{database} =~ /postgres|template0|template1/);\n\n    return (undef,\n            $request->{_wire}->get( 'db' )->instance(\n                user     => $creds->{login},\n                password => $creds->{password},\n                dbname   => $request->{database},\n            ));\n}\n\n\nsub _init_db {\n    my ($request) = @_;\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    local $@ = undef;\n    $request->{dbh} = eval {\n        $database->connect({PrintError => 0, AutoCommit => 0 })\n    } if ! defined $request->{dbh};\n    $LedgerSMB::App_State::DBH = $request->{dbh};\n\n    return (undef, $database);\n}\n\n=item login\n\nProcesses the login and examines the database to determine appropriate steps to\ntake.\n)\n=cut\n\n=item get_dispatch_table\n\nReturns the main dispatch table for the versions with supported upgrades\n\n=cut\n\nsub get_dispatch_table {\n    my ($request) = @_;\n    my $sl_detect = $request->{_locale}->text('SQL-Ledger database detected.');\n    my $migratemsg =  $request->{_locale}->text(\n               'Would you like to migrate the database?'\n    );\n    my $upgrademsg =  $request->{_locale}->text(\n               'Would you like to upgrade the database?'\n    );\n\n    return ( { appname => 'sql-ledger',\n        version => '2.7',\n        slschema => 'sl27',\n        message => $sl_detect,\n        operation => $migratemsg,\n        next_action => 'upgrade' },\n      { appname => 'sql-ledger',\n        version => '2.8',\n        slschema => 'sl28',\n        message => $sl_detect,\n        operation => $migratemsg,\n        next_action => 'upgrade' },\n      { appname => 'sql-ledger',\n        version => '3.0',\n        slschema => 'sl30',\n        message => $request->{_locale}->text(\n                     'SQL-Ledger 3.0 database detected.'\n                   ),\n        operation => $migratemsg,\n        next_action => 'upgrade' },\n      { appname => 'sql-ledger',\n        version => undef,\n        message => $request->{_locale}->text(\n                      'Unsupported SQL-Ledger version detected.'\n                   ),\n        operation => $request->{_locale}->text('Cancel'),\n        next_action => 'cancel' },\n      { appname => 'ledgersmb',\n        version => '1.2',\n        message => $request->{_locale}->text('LedgerSMB 1.2 db found.'),\n        operation => $upgrademsg,\n        next_action => 'upgrade' },\n      { appname => 'ledgersmb',\n        version => '1.3',\n        message => $request->{_locale}->text('LedgerSMB 1.3 db found.'),\n        operation => $upgrademsg,\n        next_action => 'upgrade' },\n      { appname => 'ledgersmb',\n        version => '1.4',\n        message => $request->{_locale}->text('LedgerSMB 1.4 db found.'),\n        operation => $upgrademsg,\n        # rebuild_modules will upgrade 1.4->1.5 by applying (relevant) changes\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.5',\n        message => $request->{_locale}->text('LedgerSMB 1.5 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.6',\n        message => $request->{_locale}->text('LedgerSMB 1.6 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.7',\n        message => $request->{_locale}->text('LedgerSMB 1.7 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.8',\n        message => $request->{_locale}->text('LedgerSMB 1.8 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.9',\n        message => $request->{_locale}->text('LedgerSMB 1.9 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.10',\n        message => $request->{_locale}->text('LedgerSMB 1.10 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.11',\n        message => $request->{_locale}->text('LedgerSMB 1.11 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => '1.12',\n        message => $request->{_locale}->text('LedgerSMB 1.12 db found.'),\n        operation => $request->{_locale}->text('Rebuild/Upgrade?'),\n        next_action => 'rebuild_modules' },\n      { appname => 'ledgersmb',\n        version => undef,\n        message => $request->{_locale}->text('Unsupported LedgerSMB version detected.'),\n        operation => $request->{_locale}->text('Cancel'),\n        next_action => 'cancel' } );\n}\n\n\nsub _sanity_checks {\n    my $checks = LedgerSMB::Database->verify_helpers(helpers => [ 'psql' ]);\n\n    die q{Unable to execute 'psql'} unless $checks->{psql};\n}\n\n\nsub login {\n    my ($request) = @_;\n    if (!$request->{database}){\n        return list_databases($request);\n    }\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    my $template = $request->{_wire}->get('ui');\n    my $settings = $request->{_wire}->get( 'setup_settings' );\n    my $auth_db = ($settings and $settings->{auth_db}) // 'postgres';\n    $database->{connect_data}->{options} = \"-c search_path=$database->{schema},public\";\n\n    my $version_info = $database->get_info($auth_db);\n\n    my $server_version     = version->parse(\n        $version_info->{system_info}->{'PostgreSQL (server)'}\n        );\n    my $server_min_version = version->parse('10.0.0');\n\n    return $template->render($request,\n                             'setup/mismatch',\n                             {\n                                 found    => \"$server_version\",\n                                 required => \"$server_min_version\",\n                             })\n        if $server_version < $server_min_version;\n\n    ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    _sanity_checks();\n    $request->{login_name} = $version_info->{username};\n    if ($version_info->{status} eq 'does not exist'){\n        $request->{message} = $request->{_locale}->text(\n             'Database does not exist.');\n        $request->{operation} = $request->{_locale}->text('Create Database?');\n        $request->{next_action} = 'create_db';\n    }\n    else {\n        foreach my $dispatch_entry (get_dispatch_table($request)) {\n            if ($version_info->{appname} eq $dispatch_entry->{appname}\n                && ($version_info->{version} eq $dispatch_entry->{version}\n                    || ! defined $dispatch_entry->{version})) {\n                foreach my $field (qw|operation message next_action slschema|) {\n                    $request->{$field} = $dispatch_entry->{$field};\n                }\n                last;\n            }\n        }\n\n        if (! defined $request->{next_action}) {\n            $request->{message} = $request->{_locale}->text(\n                'Unknown database found.'\n                ) . $version_info->{full_version};\n            $request->{operation} = $request->{_locale}->text('Cancel?');\n            $request->{next_action} = 'cancel';\n        } elsif ($request->{next_action} eq 'rebuild_modules') {\n            # we found the current version\n            # check we don't have stale migrations around\n            my $dbh = $request->{dbh};\n            my $sth = $dbh->prepare(q(\n                SELECT count(*)<>0\n                  FROM defaults\n                 WHERE setting_key = 'migration_ok' and value = 'no'\n              ));\n            $sth->execute();\n            my ($has_stale_migration) = $sth->fetchrow_array();\n            if ($has_stale_migration) {\n                $request->{operation} = 'Restore old version?';\n                $request->{message} = 'Failed migration found';\n                $request->{next_action} = 'revert_migration';\n            }\n        }\n    }\n    return $template->render($request, 'setup/confirm_operation', $request);\n}\n\n=item list_databases\nLists all databases as hyperlinks to continue operations.\n\n=cut\n\nsub list_databases {\n    my ($request) = @_;\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    my @results = $database->list_dbs(\n        $request->{_wire}->get('setup_settings')->{admin_db}\n        );\n    $request->{dbs} = [];\n    # Ideally we would extend DBAdmin->list_dbs to accept an argument containing a list of databases to exclude using a method similar to that shown at https://git.framasoft.org/framasoft/OCB/commit/7a6e94edd83e9e73e56d2d148e3238618\n    # also, we should add a new function DBAdmin->list_dbs_this_user which only returns db's the currently auth'd user has access to. Once again the framasoft.org link shows a method of doing this\n    # for now we simply use a fixed regex. It will cover many if not most use cases.\n    @{$request->{dbs}} = map {+{ row_id => $_, db  => $_ }} grep { ! m/^(postgres|template0|template1)$/ } @results ;\n\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/list_databases', $request);\n}\n\n=item list_users\nLists all users in the selected database\n\n=cut\n\nsub list_users {\n    my ($request) = @_;\n    my ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    my @users = LedgerSMB::User->get_all_users($request);\n    $request->{users} = [];\n    for my $user (@users) {\n        push @{$request->{users}}, {row_id => $user->{id}, name => $user->{username} };\n    }\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/list_users', $request);\n}\n\n=item copy_db\n\nCopies db to the name of $request->{new_name}\n\n=cut\n\nsub copy_db {\n    my ($request) = @_;\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    $database->copy($request->{new_name})\n           || die 'An error occurred. Please check your database logs.' ;\n\n    return complete($request);\n}\n\n\n=item backup_db\n\nBacks up a full db\n\n=cut\n\nsub backup_db {\n    my $request = shift @_;\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    $request->{backup} = 'db';\n    return _begin_backup($request);\n}\n\n=item backup_roles\n\nBacks up roles only (for all db's)\n\n=cut\n\nsub backup_roles {\n    my $request = shift @_;\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    $request->{backup} = 'roles';\n    return _begin_backup($request);\n}\n\n# Private method, basically just passes the inputs on to the next screen.\nsub _begin_backup {\n    my $request = shift @_;\n    $request->{can_email} = eval {\n        # when accessing an undefined service, an exception is thrown;\n        # suppress the exception: all we want to know is if there is a value\n        $request->{_wire}->get( 'miscellaneous/backup_email_from' );\n    };\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/begin_backup', $request);\n};\n\n\n=item run_backup\n\nRuns the backup.  If backup_type is set to email, emails the\n\n=cut\n\nsub run_backup {\n    my $request = shift @_;\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    my $backuptype;\n    my $backupfile;\n    my $mimetype;\n\n    if ($request->{backup} eq 'roles') {\n        $backupfile = $database->backup_globals;\n        $backuptype = 'roles';\n        $mimetype = 'text/x-sql';\n    }\n    elsif ($request->{backup} eq 'db') {\n        $backupfile = $database->backup;\n        $backuptype = 'db';\n        $mimetype   = 'application/octet-stream';\n    }\n    else {\n        die $request->{_locale}->text('Invalid backup request');\n    }\n\n    $backupfile or\n        die $request->{_locale}->text('Error creating backup file');\n\n    if ($request->{backup_type} eq 'email') {\n\n        my $mail = LedgerSMB::Mailer->new(\n            transport => $request->{_wire}->get( 'mail' )->{transport},\n            from      => $request->{_wire}->get( 'miscellaneous/backup_email_from' ),\n\n            to        => $request->{email},\n            subject   => 'Email of Backup',\n            message   => 'The Backup is Attached',\n        );\n        $mail->attach(\n            mimetype => $mimetype,\n            filename => \"ledgersmb-$backuptype-\" . time . '.sqlc',\n            file     => $backupfile,\n        );\n        $mail->send;\n        unlink $backupfile;\n        my $template = $request->{_wire}->get('ui');\n        return $template->render($request, 'setup/complete', $request);\n    }\n    elsif ($request->{backup_type} eq 'browser') {\n        my $attachment_name = \"ledgersmb-$backuptype-\" . time . '.sqlc';\n        return sub {\n            my $responder = shift;\n\n            open my $bak, '<:bytes', $backupfile\n                or die \"Failed to open temporary backup file $backupfile: $!\";\n            $responder->(\n                [\n                 HTTP_OK,\n                 [\n                  'Content-Type' => $mimetype,\n                  'Content-Disposition' =>\n                      \"attachment; filename=\\\"$attachment_name\\\"\"\n                 ],\n                 $bak  # the file-handle\n                ]);\n            close $bak\n                or warn \"Failed to close temporary backup file $backupfile: $!\";\n            unlink $backupfile\n                or warn \"Failed to unlink temporary backup file $backupfile: $!\";\n        };\n    }\n    else {\n        die $request->{_locale}->text('Don\\'t know what to do with backup');\n    }\n}\n\n=item consistency\n\n=cut\n\nsub consistency {\n    my ($request) = @_;\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    my $dbh = $database->connect({PrintError => 0, AutoCommit => 0});\n    my $paths = find_checks($request->{_wire}->get( 'paths/sql' ) );\n    my $checks = load_checks( $paths );\n    my $results = run_checks( $dbh, $checks );\n\n    return $request->{_wire}->get('ui')->render(\n        $request,\n        'setup/consistency_results',\n        {\n            database => $request->{database},\n            login    => $request->{login},\n            results  => $results\n        });\n}\n\n\n=item revert_migration\n\n=cut\n\nsub revert_migration {\n    my ($request) = @_;\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    my $dbh = $database->connect({PrintError => 0, AutoCommit => 0});\n    my $sth = $dbh->prepare(q(\n         SELECT value\n           FROM defaults\n          WHERE setting_key = 'migration_src_schema'\n      ));\n    $sth->execute();\n    my ($src_schema) = $sth->fetchrow_array();\n    $dbh->rollback();\n    $dbh->do('DROP SCHEMA public CASCADE');\n    $dbh->do(\"ALTER SCHEMA $src_schema RENAME TO public\");\n    $dbh->commit();\n\n    my $template = $request->{_wire}->get('ui');\n\n    return $template->render($request, 'setup/complete_migration_revert',\n                             $request);\n}\n\n=item template_screen\n\nShows the screen for loading templates.  This should appear before loading\nthe user.\n\n=cut\n\nsub template_screen {\n    my ($request, $entrypoint) = @_;\n    $request->{template_dirs} =\n        [ map { +{ text => $_, value => $_ } }\n          sort keys %{ LedgerSMB::Database::Config->new(\n                           templates_dir => $request->{_wire}->get( 'paths/templates' ),\n                           )->templates } ];\n    return $request->{_wire}->get('ui')\n        ->render($request, 'setup/template_info',\n                 { %$request, templates_action => $entrypoint });\n}\n\n=item load_templates\n\nThis bulk loads the templates.  Expectated inputs are template_dir and\noptionally only_templates (which if true returns to the confirmation screen\nand not the user creation screen.\n\n=cut\n\nsub _save_templates {\n    my ($request, $entrypoint) = @_;\n    my $templates = LedgerSMB::Database::Config->new(\n        templates_dir => $request->{_wire}->get( 'paths/templates' ),\n        )->templates;\n\n    return template_screen($request, $entrypoint)\n        if not exists $templates->{$request->{template_dir}};\n\n    my ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $dbh = $request->{dbh};\n\n    for my $template (@{$templates->{$request->{template_dir}}}) {\n       my $dbtemp = LedgerSMB::Template::DB->get_from_file($template);\n       $dbtemp->save;\n    }\n\n    return;\n}\n\nsub load_templates {\n    my ($request) = @_;\n\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    return (_save_templates($request, 'load_templates')\n            or login($request));\n}\n\n\n=item upgrade\n\n\n=cut\n\nmy %upgrade_run_step = (\n    'sql-ledger/2.7' => '_initial_sl27',\n    'sql-ledger/2.8' => '_initial_sl28',\n    'sql-ledger/3.0' => '_initial_sl30',\n    'ledgersmb/1.2'  => '_initial_ls12',\n    'ledgersmb/1.3'  => '_initial_ls13'\n    );\n\n# Note that by the time we get to these steps,\n# all upgrade checks have already been executed\nmy %upgrade_next_steps = (\n    # The protocol for each of the right-hand sides here:\n\n    # * The right-hand sides are all subroutine names in this module\n    # * Each subroutine returns either\n    #   * a PSGI-triplet\n    #     The returned page posts its interaction back to the entrypoint\n    #   * the result of a call to _dispatch_upgrade_workflow\n    #     called with two arguments: the request environment and its own name\n    #\n    # This makes sure that the steps in the workflow are correctly\n    # \"stepped through\" without there being an explicit or hard-coded\n    # dependency or sequence between steps.\n\n    # new database\n    _create_db             => '_select_coa',\n    _select_coa            => '_select_templates',\n\n    #sl28 specific\n    _initial_sl28          => '_run_sl28_upgrade',\n    _run_sl28_upgrade      => '_post_sl28_migration',\n    _post_sl28_migration   => '_select_templates',\n\n    #sl30 specific\n    _initial_sl30          => '_run_sl30_upgrade',\n    _run_sl30_upgrade      => '_post_sl30_migration',\n    _post_sl30_migration   => '_select_templates',\n\n    #lsmb12 specific\n    _initial_ls12          => '_run_ls12_upgrade',\n    _run_ls12_upgrade      => '_post_ls12_migration',\n    _post_ls12_migration   => '_select_templates',\n\n    #lsmb13 specific\n    _initial_ls13          => '_run_ls13_upgrade',\n    _run_ls13_upgrade      => '_post_ls13_migration',\n    _post_ls13_migration   => '_load_templates',\n\n    # common final steps\n#   _migrate_users could be used to create sl and lsmb12 users\n#   _select_templates      => '_migrate_users',\n#   _migrate_users         => '_complete',\n    _select_templates      => '_create_initial_user',\n    _load_templates        => '_complete',\n    _create_initial_user   => '_complete',\n    );\n\nsub _dispatch_upgrade_workflow {\n    my ($request, $step_name) = @_;\n\n    if (my $next = $upgrade_next_steps{$step_name}) {\n        return __PACKAGE__->can($next)->($request);\n    }\n\n    croak \"Upgrade workflow error: no next step for '$step_name'\";\n}\n\nsub _select_coa {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    return (select_coa($request)\n            or _dispatch_upgrade_workflow($request, '_select_coa'));\n}\n\nsub _process_and_run_upgrade_script {\n    my ($request, $type) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $hdr = $request->{_req}->header( 'Accept-Language' );\n    my $lang = $request->{_wire}->get( 'default_locale' )->from_header( $hdr );\n\n    my $upgrade = LedgerSMB::Database::Upgrade->new(\n        database => $database,\n        type     => $type,\n        language => $lang\n        );\n    try {\n        my $info = $database->get_info();\n        $upgrade->run_upgrade_script(\n            {\n                sl_version => version->parse($info->{full_version}),\n                %{$request}{qw( default_country default_ap default_ar\n                                slschema lsmbschema lsmbversion)}\n            });\n        $upgrade->run_post_upgrade_steps;\n    }\n    catch ($e) {\n        my $error_text = escape_html( $e );\n        local $/ = undef;\n        my $stdout = '';\n        if ( open( my $out, '<:encoding(UTF-8)', $upgrade->logfiles->{out} ) ) {\n            $stdout = escape_html( <$out> );\n        }\n        else {\n            $logger->warn(\n                \"Unable to open psql upgrade script STDOUT logfile: $!\"\n                );\n        }\n\n        my $stderr = '';\n        if ( open( my $err, '<:encoding(UTF-8)', $upgrade->logfiles->{err} ) ) {\n            $stderr = escape_html( <$err> );\n        }\n        else {\n            $logger->warn(\n                \"Unable to open psql upgrade script STDERR logfile: $!\"\n                );\n        }\n\n        return [ HTTP_INTERNAL_SERVER_ERROR,\n                 [ 'Content-Type' => 'text/html; charset=UTF-8' ],\n                 [ <<~EMBEDDED_HTML ] ];\n        <html>\n          <body>\n            <h1>Error!</h1>\n            <p><b>$error_text</b></p>\n\n            <h3>STDERR</h3>\n            <pre style=\"max-height:30em;overflow:scroll\">$stderr</pre>\n\n            <h3>STDOUT</h3>\n            <pre style=\"max-height:30em;overflow:scroll\">$stdout</pre>\n          </body>\n        </html>\n        EMBEDDED_HTML\n    };\n\n    return;\n}\n\nsub _run_sl28_upgrade {\n    my ($request) = @_;\n\n    return (_process_and_run_upgrade_script($request, 'sql-ledger/2.8')\n            or _dispatch_upgrade_workflow($request, '_run_sl28_upgrade'));\n}\n\nsub _run_sl30_upgrade {\n    my ($request) = @_;\n\n    return (_process_and_run_upgrade_script($request, 'sql-ledger/3.0')\n            or _dispatch_upgrade_workflow($request, '_run_sl30_upgrade'));\n}\n\nsub _run_ls12_upgrade {\n    my ($request) = @_;\n\n    return (_process_and_run_upgrade_script($request, 'ledgersmb/1.2')\n            or _dispatch_upgrade_workflow($request, '_run_ls12_upgrade'));\n}\n\nsub _run_ls13_upgrade {\n    my ($request) = @_;\n\n    return (_process_and_run_upgrade_script($request, 'ledgersmb/1.3')\n            or _dispatch_upgrade_workflow($request, '_run_ls13_upgrade'));\n}\n\n\nsub _post_sl28_migration {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    return (_post_migration_schema_upgrade($request, $database,\n                                          '_post_sl28_migration')\n            or _dispatch_upgrade_workflow($request, '_post_sl28_migration'));\n}\n\nsub _post_sl30_migration {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    return (_post_migration_schema_upgrade($request, $database,\n                                          '_post_sl30_migration')\n            or _dispatch_upgrade_workflow($request, '_post_sl30_migration'));\n}\n\nsub _post_ls12_migration {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    return (_post_migration_schema_upgrade($request, $database,\n                                          '_post_ls12_migration')\n            or _dispatch_upgrade_workflow($request, '_post_ls12_migration'));\n}\n\nsub _post_ls13_migration {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    return (_post_migration_schema_upgrade($request, $database,\n                                          '_post_ls13_migration')\n            or _dispatch_upgrade_workflow($request, '_post_ls13_migration'));\n}\n\n\nsub _select_templates {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n\n    return (_save_templates($request, '_select_templates')\n            or _dispatch_upgrade_workflow($request, '_select_templates'));\n}\n\nsub _load_templates {\n    my ($request) = @_;\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $dbh = $request->{dbh};\n    #### Suppress selecting templates!\n    ### Suppress next steps in load templates!\n\n    $request->{template_dir} //=\n        LedgerSMB::Setting->new(dbh => $dbh)->get('templates');\n    return (_save_templates($request, '_load_templates')\n            or _dispatch_upgrade_workflow($request, '_load_templates'));\n}\n\n\n\n\nsub upgrade {\n    my ($request) = @_;\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $settings = $request->{_wire}->get( 'setup_settings' );\n    my $auth_db = ($settings and $settings->{auth_db}) // 'postgres';\n    my $dbinfo = $database->get_info($auth_db);\n    my $upgrade_type = \"$dbinfo->{appname}/$dbinfo->{version}\";\n    my $locale = $request->{_locale};\n\n    $request->{dbh}->{AutoCommit} = 0;\n\n    my $hdr = $request->{_req}->header( 'Accept-Language' );\n    my $lang = $request->{_wire}->get( 'default_locale' )->from_header( $hdr );\n    my $upgrade = LedgerSMB::Database::Upgrade->new(\n        database => $database,\n        type     => $upgrade_type,\n        language => $lang\n        );\n\n    my $rv;\n    $logger->debug( \"Running upgrade tests for '$upgrade_type'\" );\n    $upgrade->run_tests(\n        sub {\n            my ($check, $dbh, $sth) = @_;\n            $rv = _failed_check($request, $check, $sth);\n        });\n\n    return $rv if $rv;\n\n    my $required_vars = $upgrade->required_vars;\n    if (not %$required_vars) {\n        $request->{dbh}->rollback();\n\n        return _dispatch_upgrade_workflow($request,\n                                          $upgrade_run_step{$upgrade_type});\n    }\n\n    my $template = $request->{_wire}->get('ui');\n\n    my $step = $upgrade_run_step{$upgrade_type};\n    my $upgrade_action = $upgrade_next_steps{$step};\n    $request->{upgrade_action} = $upgrade_action;\n\n    die \"Upgrade type $upgrade_type not associated with a next step (step: $step)\"\n        unless $upgrade_action;\n\n    for my $key (keys %$required_vars) {\n        my $val = $required_vars->{$key};\n        $request->{$key} = (ref($val) eq 'ARRAY')\n            ? ((@$val > 1) ? [ {}, @$val ]\n                          : ($val->[0] ? $val->[0]->{value} : 'null'))\n            : $val;\n    }\n    $request->{lsmbversion} = $CURRENT_MINOR_VERSION;\n    return $template->render($request, 'setup/upgrade_info', $request);\n}\n\nsub _failed_check {\n    my ($request, $check, $sth) = @_;\n\n    my %selectable_values =\n        %{$check->query_selectable_values($request->{dbh})};\n\n    my $hiddens = {\n       check => $check->name,\nverify_check => md5_hex($check->test_query),\n    database => $request->{database}\n    };\n    my @skip_keys = grep /^skip_/, keys %$request;\n    $hiddens->{@skip_keys} = $request->{@skip_keys};\n\n    my $cols = [];\n    for my $column (@{$check->display_cols // []}) {\n        my $selectable_value = $selectable_values{$column};\n\n        if (grep { $column eq $_ } @{$check->columns // []}) {\n            if ( defined $selectable_value && @$selectable_value ) {\n                push @$cols, {\n                    col_id => $column,\n                    name => $column,\n                    type => 'select',\n                    options => $selectable_value,\n                    default_blank => ( 1 != @$selectable_value ),\n                };\n            }\n            else {\n                push @$cols, {\n                    col_id => $column,\n                    name => $column,\n                    type => 'input_text',\n                };\n            }\n        }\n        else {\n            push @$cols, {\n                col_id => $column,\n                name => $column,\n                type => 'text',\n            };\n        }\n    };\n    push @$cols, {\n        col_id => 'id',\n        type => 'hidden',\n    };\n\n    my $rows = [];\n    while (my $row = $sth->fetchrow_hashref('NAME_lc')) {\n        $row->{row_id} = 1+@$rows;\n        $row->{id} =\n            join(',', map { MIME::Base64::encode(($row->{$_} // ''), '')}\n                 @{$check->id_columns});\n        push @$rows, $row;\n    }\n    $hiddens->{count} = scalar(@$rows);\n    $sth->finish();\n\n    my %buttons = map { $_ => 1 } @{$check->buttons};\n    my $enabled_buttons;\n    for (\n        { value => 'fix_tests', label => 'Save and Retry',\n          cond => defined($check->{columns})},\n        { value => 'cancel',    label => 'Cancel',\n          cond => 1                         },\n        { value => 'force',     label => 'Force',\n          cond => $check->{force_queries}   },\n    ) {\n        if ( $buttons{$_->{label}} && $_->{cond}) {\n            push @$enabled_buttons, {\n                 type => 'submit',\n                 name => '__action',\n                value => $_->{value},\n              tooltip => { id => 'action-' . $_->{value},\n                           msg => $check->{tooltips}->{$_->{label}}\n                                ? $request->{_locale}->maketext($check->{tooltips}->{$_->{label}})\n                                : undef,\n                           position => 'above'\n                         },\n                 text => $request->{_locale}->maketext($_->{label}),\n                class => 'submit'\n            }\n        }\n    }\n\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/migration_step', {\n           form               => $request,\n           headers            => [\n               $request->{_locale}->maketext($check->display_name),\n               $request->{_locale}->maketext($check->instructions)\n               ],\n           columns            => $cols,\n           rows               => $rows,\n           buttons            => $enabled_buttons,\n           hiddens            => $hiddens,\n           include_stylesheet => 'system/setup.css',\n    });\n}\n\n=item fix_tests\n\nHandles input from the failed test function and then re-runs the migrate db\nscript.\n\n=cut\n\nsub fix_tests {\n    my ($request) = @_;\n\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $settings = $request->{_wire}->get( 'setup_settings' );\n    my $auth_db = ($settings and $settings->{auth_db}) // 'postgres';\n    my $dbinfo = $database->get_info($auth_db);\n    my $upgrade_type = \"$dbinfo->{appname}/$dbinfo->{version}\";\n    my $dbh = $request->{dbh};\n    $dbh->{AutoCommit} = 0;\n\n    my $hdr = $request->{_req}->header( 'Accept-Language' );\n    my $lang = $request->{_wire}->get( 'default_locale' )->from_header( $hdr );\n    my $upgrade = LedgerSMB::Database::Upgrade->new(\n        database => $database,\n        type     => $upgrade_type,\n        language => $lang\n        );\n\n    my $check = $upgrade->applicable_test_by_name($request->{check});\n    die \"Inconsistent state fixing data for $request->{check}: \"\n        . 'found no applicable tests for given identifier'\n        unless $check;\n\n    die \"Inconsistent state fixing data for $request->{check}: \"\n        . 'found different test by the same name while fixing data'\n        if $request->{verify_check} ne md5_hex($check->test_query);\n\n    my @fixed_rows;\n    for my $count (1 .. $request->{count}){\n        my %row_data;\n        for my $key (@{$check->columns}) {\n            $row_data{$key} = $request->{\"${key}_$count\"};\n            $logger->trace( \"Setting row $count field $key to $row_data{$key}\" );\n        }\n        @row_data{@{$check->id_columns}} =\n            map {\n                $_ ne '' ? MIME::Base64::decode($_) : undef\n        } split(/,/, $request->{\"id_$count\"});\n\n        push @fixed_rows, \\%row_data;\n    }\n\n    $check->fix($dbh, \\@fixed_rows);\n    return upgrade($request);\n}\n\n=item create_db\n\n Beginning of the new database workflow\n\n=cut\n\nsub create_db {\n    my ($request) = @_;\n\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    my ($reauth, $database) = _get_database($request);\n    return $reauth if $reauth;\n\n    my $settings = $request->{_wire}->get( 'setup_settings' );\n    my $auth_db = ($settings and $settings->{auth_db}) // 'postgres';\n    my $version_info = $database->get_info($auth_db);\n    $request->{login_name} = $version_info->{username};\n    if ($version_info->{status} ne 'does not exist') {\n        $request->{message} = $request->{_locale}->text(\n            'Database exists.');\n        $request->{operation} =\n            $request->{_locale}->text('Login?');\n        $request->{next_action} = 'login';\n\n        my $template = $request->{_wire}->get('ui');\n        return $template->render($request, 'setup/confirm_operation', $request);\n    }\n\n    my $rc = $database->create_and_load();\n    $logger->info(\"create_and_load rc=$rc\");\n\n    return _dispatch_upgrade_workflow($request, '_create_db');\n}\n\n=item select_coa\n\nSelects and loads the COA.\n\nThere are three distinct input scenarios here:\n\ncoa_lc and chart are set:  load the coa file specified (sql/coa/$coa_lc/$chart)\ncoa_lc set, chart not set:  select the chart\ncoa_lc not set:  Select the coa location code\n\n=cut\n\nsub select_coa {\n    my ($request) = @_;\n    my $hdr = $request->{_req}->header( 'Accept-Language' );\n    my $lang = $request->{_wire}->get( 'default_locale' )->from_header( $hdr );\n    my $coa_data = LedgerSMB::Database::Config\n        ->new( language =>  $lang )\n        ->charts_of_accounts;\n\n    if ($request->{coa_lc}) {\n        my $coa_lc = $request->{coa_lc};\n        if (not exists $coa_data->{$coa_lc}) {\n            die $request->{_locale}->text('Invalid request');\n        }\n\n        for my $coa_type (qw( chart sic )) {\n            if ($request->{$coa_type}) {\n                if (! grep { $_ eq $request->{$coa_type} }\n                    @{$coa_data->{$coa_lc}->{$coa_type}}) {\n                    die $request->{_locale}->text('Invalid request');\n                }\n            }\n        }\n\n        if ($request->{chart}) {\n            if (my $csrf = $request->verify_csrf) {\n                return $csrf;\n            }\n            my ($reauth, $database) = _get_database($request);\n            return $reauth if $reauth;\n\n            my $c = LedgerSMB::Company->new(\n                dbh => $database->connect(),\n                )->configuration;\n            my $fn = File::Spec->catdir('.', 'locale', 'coa',\n                                        $request->{coa_lc}, $request->{chart});\n            open my $fh, '<:encoding(UTF-8)', $fn\n                or die \"Failed to open $fn: $!\";\n            $c->from_xml($fh);\n            $c->dbh->commit;\n            $c->dbh->disconnect;\n            close $fh\n                or warn \"Error closing $fn: $!\";\n\n            $database->load_sic(\n                {\n                    country => $request->{coa_lc},\n                    sic => $request->{sic}\n                });\n\n            # successful completion returns 'undef'\n            return _dispatch_upgrade_workflow($request, '_select_coa');\n        } else {\n            for my $select (qw( chart sic )) {\n                $request->{\"${select}s\"} =\n                    [ map { +{ name => $_ } }\n                      @{$coa_data->{$request->{coa_lc}}->{$select}} ];\n            }\n       }\n    } else {\n        $request->{coa_lcs} = [ sort { $a->{name} cmp $b->{name} }\n                                values %$coa_data ];\n    }\n\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/select_coa', $request);\n}\n\n\n=item skip_coa\n\nEntry point when on the CoA selection screen the 'Skip' button\nis being pressed.  This allows the user to load a CoA later.\n\nThe CoA loaded at a later time may be a self-defined CoA, i.e. not\none distributed with the LSMB standard distribution.  The 'Skip'\nbutton facilitates that scenario.\n\n=cut\n\nsub skip_coa {\n    my ($request) = @_;\n\n    return _dispatch_upgrade_workflow($request, '_select_coa')\n}\n\n\n=item _render_user\n\nRenders the new user screen. Common functionality to both the\nselect_coa and skip_coa functions.\n\n=cut\n\nsub _render_user {\n    my ($request, $entrypoint) = @_;\n\n    @{$request->{salutations}} = $request->call_procedure(\n        funcname => 'person__list_salutations'\n    );\n\n    $request->{countries} = $request->enabled_countries;\n    my $locale = $request->{_locale};\n\n    @{$request->{perm_sets}} = (\n        {id => '0', label => $locale->text('Manage Users')},\n        {id => '1', label => $locale->text('Full Permissions')},\n        {id => '-1', label => $locale->text('No changes')},\n        );\n\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/new_user',\n                             { %$request, save_action => $entrypoint });\n}\n\n=item _render_new_user\n\nRenders the new user screen. Common functionality to both the\nselect_coa and skip_coa functions.\n\n=cut\n\nsub _render_new_user {\n    my ($request, $entrypoint) = @_;\n\n    # One thing to remember here is that the setup.pl does not get the\n    # benefit of the automatic db connection.  So in order to build this\n    # form, we have to manage that ourselves.\n    #\n    # However we get the benefit of having had to set the environment\n    # variables for the Pg connection above, so don't need to pass much\n    # info.\n    #\n    # Also I am opting to use the lower-level call_procedure interface\n    # here in order to avoid creating objects just to get argument\n    # mapping going. --CT\n\n\n    my ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    $request->{dbh}->{AutoCommit} = 0;\n\n    if ( $request->{coa_lc} ) {\n        LedgerSMB::Setting->new(%$request)->set('default_country',$request->{coa_lc});\n    }\n    return _render_user($request, $entrypoint);\n}\n\n\n\n=item _save_user\n\nSaves the administrative user, and then directs to the login page.\n\n=cut\n\nsub _save_user {\n    my ($request, $entrypoint) = @_;\n    $request->{entity_class} = EC_EMPLOYEE;\n    $request->{name} = \"$request->{last_name}, $request->{first_name}\";\n\n    my ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    $request->{dbh}->{AutoCommit} = 0;\n\n    $request->{control_code} = $request->{employeenumber};\n    my $emp = LedgerSMB::Entity::Person::Employee->new(\n        %$request,\n        dob => $request->parse_date( $request->{dob} ),\n        start_date => $request->parse_date( $request->{start_date} ),\n        end_date => $request->parse_date( $request->{end_date} ),\n        );\n    $emp->save;\n    $request->{entity_id} = $emp->entity_id;\n    my $user = LedgerSMB::Entity::User->new(%$request);\n\n    try {\n        $user->create($request->{password});\n    }\n    catch ($var) {\n        if ($var =~ /duplicate user/i){\n            $request->{dbh}->rollback;\n            $request->{notice} = $request->{_locale}->text(\n                'User already exists. Import?'\n                );\n            $request->{pls_import} = 1;\n\n            # return from the 'catch' block\n            return _render_user($request, $entrypoint);\n        }\n        else {\n            die $var;\n        }\n    };\n\n    if ($request->{perms} == 1){\n         for my $role (\n                $request->call_procedure(funcname => 'admin__get_roles')\n         ){\n             $request->call_procedure(funcname => 'admin__add_user_to_role',\n                                      args => [ $request->{username},\n                                                $role->{rolname}\n                                              ]);\n         }\n    } elsif ($request->{perms} == 0) {\n        $request->call_procedure(funcname => 'admin__add_user_to_role',\n                                 args => [ $request->{username},\n                                           'users_manage',\n                                         ]\n        );\n    }\n    $request->{dbh}->commit;\n\n    return;\n}\n\n\n\nsub _post_migration_schema_upgrade {\n    my ($request, $database, $entrypoint) = @_;\n    my $dbh = $request->{dbh};\n    my $guard = Scope::Guard->new(\n        sub {\n            if ($dbh) {\n                $dbh->rollback;\n                $dbh->disconnect;\n            }\n        });\n    my $reauth;\n\n    ($reauth, $database) = _init_db($request) if not $database;\n    return $reauth if $reauth;\n\n\n    if (my $rv = _rebuild_modules($request, $entrypoint, $database)) {\n        ### should we *really* commit??\n        ### or should we treat *any* return value as problematic\n        ### (and leave committing the transaction to the inner scope?\n        if ($rv->[0] == 200) {\n            $dbh->commit;\n            $guard->dismiss;\n        }\n\n        return $rv;\n    }\n\n    # If users are added to the user table, and appropriate roles created, this\n    # then grants the base_user permission to them.  Note it only affects users\n    # found also in pg_roles, so as to avoid errors.  --CT\n    $guard->dismiss;\n    $dbh->do(q{SELECT admin__add_user_to_role(username, 'base_user')\n                 FROM users WHERE username IN (select rolname from pg_roles)});\n\n    $dbh->commit;\n\n    return;\n}\n\n=item add_user\n\n=cut\n\nsub _create_initial_user {\n    my ($request) = @_;\n    return _render_new_user($request, '_create_initial_user')\n        unless $request->{username};\n\n    return (_save_user($request, '_create_initial_user')\n            or _dispatch_upgrade_workflow($request, '_create_initial_user'));\n}\n\nsub add_user {\n    my ($request) = @_;\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n\n    return (_create_initial_user($request)\n            or login($request));\n}\n\n=item edit_user_roles\n\n=cut\n\nsub edit_user_roles {\n    my ($request) = @_;\n\n    my $reauth;\n    ($reauth) = _init_db($request)\n        unless $request->{dbh};\n    return $reauth if $reauth;\n\n    my $template = $request->{_wire}->get('ui');\n    my ($user) = $request->call_procedure(\n        funcname => 'admin__get_user',\n        args     => [ $request->{id} ]);\n    return $template->render(\n        $request,\n        'setup/edit_user',\n        {\n            request => $request,\n            roles   => [\n                map {\n                    +{\n                        name => $_->{rolname},\n                        description => ($_->{rolname} =~ s/_/ /gr),\n                    }\n                }\n                $request->call_procedure(funcname => 'admin__get_roles')\n                ],\n            user    => {\n                roles    => [\n                    map { $_->{admin__get_roles_for_user} }\n                    $request->call_procedure(\n                        funcname => 'admin__get_roles_for_user',\n                        args     => [ $request->{id} ])\n                    ],\n                user_id  => $request->{id},\n                username => $user->{username},\n            }\n        });\n}\n\n=item save_user_roles\n\n=cut\n\nsub save_user_roles {\n    my ($request) = @_;\n\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    my ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    my ($user) = $request->call_procedure(\n        funcname => 'admin__get_user',\n        args => [ $request->{id} ] );\n    my %active_roles = map {\n        $_->{admin__get_roles_for_user} => 1\n    } $request->call_procedure(\n        funcname => 'admin__get_roles_for_user',\n        args     => [ $request->{id} ]);\n\n    for my $role (\n        map { $_->{rolname} }\n        $request->call_procedure( funcname => 'admin__get_roles' ) ) {\n        if ($active_roles{$role} and not $request->{$role}) {\n            # remove\n            $request->call_procedure(\n                funcname => 'admin__remove_user_from_role',\n                args     => [ $user->{username}, $role ] );\n        }\n        elsif ($request->{$role} and not $active_roles{$role}) {\n            # add\n            $request->call_procedure(\n                funcname => 'admin__add_user_to_role',\n                args     => [ $user->{username}, $role ] );\n        }\n    }\n\n    return edit_user_roles($request);\n}\n\n\n=item reset_password\n\n=cut\n\nsub reset_password {\n    my ($request) = @_;\n\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    my ($reauth) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $user = LedgerSMB::Entity::User->new(%$request);\n    $user->reset_password($request->{password});\n\n    $request->{password} = '';\n\n    return edit_user_roles($request);\n}\n\n\n\n=item cancel\n\nCancels work.  Returns to login screen.\n\n=cut\nsub cancel{\n    return __default(@_);\n}\n\n=item force\n\nForce work.  Forgets unmatching tests, applies a curing statement and move on.\n\n=cut\n\nsub force {\n    my ($request) = @_;\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $hdr = $request->{_req}->header( 'Accept-Language' );\n    my $lang = $request->{_wire}->get( 'default_locale' )->from_header( $hdr );\n    my $upgrade = LedgerSMB::Database::Upgrade->new(\n        database => $database,\n        type => '.../...',\n        language => $lang\n        );\n\n    my $test = $upgrade->applicable_test_by_name($request->{check});\n    $test->force($request->{dbh});\n\n    return upgrade($request);\n}\n\n=item rebuild_modules\n\nThis method rebuilds the modules and sets the version setting in the defaults\ntable to the version of the LedgerSMB request object.  This is used when moving\nbetween versions on a stable branch (typically upgrading)\n\n=cut\n\nsub _rebuild_modules {\n    my ($request, $entrypoint, $database) = @_;\n\n    if (not defined $database) {\n        my ($reauth, $db) = _init_db($request);\n        return $reauth if $reauth;\n\n        $database = $db;\n    }\n\n    # The order is important here:\n    #  New modules should be able to depend on the latest changes\n    #  e.g. table definitions, etc.\n\n    $request->{resubmit_action} //= $entrypoint;\n    my $HTML = html_formatter_context {\n        return ! $database->apply_changes( checks => 1 );\n    } $request;\n\n    return [ HTTP_OK,\n             [ 'Content-Type' => 'text/html; charset=UTF-8' ],\n             [ map { encode_utf8($_) } @$HTML ]\n        ]\n        if $HTML;\n\n    $database->upgrade_modules('LOADORDER', $LedgerSMB::VERSION)\n        or die 'Upgrade failed.';\n\n    return;\n}\n\nsub rebuild_modules {\n    my ($request) = @_;\n\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    if (my $rv = _rebuild_modules($request, 'rebuild_modules')) {\n        return $rv;\n    }\n    return complete($request);\n}\n\n=item complete\n\nGets the statistics info and shows the complete screen.\n\n=cut\n\nsub _complete {\n    my ($request) = @_;\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    my $temp = $database->loader_log_filename();\n    $request->{lsmb_info} = $database->stats();\n    my $template = $request->{_wire}->get('ui');\n    return $template->render($request, 'setup/complete', $request);\n}\n\nsub complete { return _complete(@_) };\n\n=item system_info\n\nAsks the various modules for system and version info, showing the result\n\n=cut\n\nsub system_info {\n    my ($request) = @_;\n    if (my $csrf = $request->verify_csrf) {\n        return $csrf;\n    }\n    my ($reauth, $database) = _init_db($request);\n    return $reauth if $reauth;\n\n    # the intent here is to get a much more sophisticated system which\n    # asks registered modules for their system and dependency info\n    my $settings = $request->{_wire}->get( 'setup_settings' );\n    my $auth_db = ($settings and $settings->{auth_db}) // 'postgres';\n    my $info = {\n        db     => $database->get_info($auth_db)->{system_info},\n        system => LedgerSMB::system_info()->{system},\n        environment => \\%ENV,\n        modules => \\%INC,\n    };\n    $request->{info} = $info;\n    return $request->{_wire}->get('ui')\n        ->render($request, 'setup/system_info', $request);\n}\n\n\n=back\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (C) 2011-2024 The LedgerSMB Core Team\n\nThis file is licensed under the GNU General Public License version 2, or at your\noption any later version.  A copy of the license should have been included with\nyour software.\n\n=cut\n\n\n1;\n", "\npackage LedgerSMB::Template::UI;\n\n=head1 NAME\n\nLedgerSMB::Template::UI - Renderer for UI templates\n\n=head1 DESCRIPTION\n\nThis module instantiates a singleton UI template rendering engine\n(backed by Template Toolkit).\n\n=head1 METHODS\n\n=cut\n\nuse strict;\nuse warnings;\n\nuse LedgerSMB::Locale;\nuse LedgerSMB::Template;\n\nuse Carp;\nuse File::Spec;\nuse HTML::Escape;\nuse HTML::Entities;\nuse Template;\n\nour $engine;\nour $singleton;\nour @pre_render_cbs = (\n    sub {\n        my ($request, $template, $vars, $cvars) = @_;\n        $vars->{USER} = $request->{_user};\n        $vars->{locale} = $vars->{language} // $vars->{locale};\n        $cvars->{locale} = $cvars->{language} // $cvars->{locale};\n    },\n    );\n\n\n=head2 new_UI( cache => $path, root => $path )\n\nConstructor. Returns (singleton) template UI renderer.\n\n=cut\n\nsub new_UI {\n    my $class = shift;\n    my %args = @_;\n    my $cache = $args{cache} // 'lsmb_templates/';\n    my $root = $args{root} // './UI/';\n\n    if (! defined $singleton) {\n        if (!defined $engine) {\n            $engine = Template->new(\n                INCLUDE_PATH => [\n                    map { $root . $_ } ('js', '', 'lib') ],\n                ENCODING => 'utf8',\n                TRIM => 1,\n                START_TAG => quotemeta('[%'),\n                END_TAG => quotemeta('%]'),\n                DELIMITER => ';',\n                COMPILE_EXT => '.lttc',\n                COMPILE_DIR =>\n                   File::Spec->rel2abs( $cache, File::Spec->tmpdir ),\n                VARIABLES => {\n                    UNESCAPE => sub {\n                        return decode_entities(shift @_);\n                    },\n                })\n                or die Template->error;\n        }\n\n        $singleton = bless {\n            root => $root,\n            stylesheet => $args{stylesheet} // 'ledgersmb.css',\n            standard_vars => {\n            },\n        }, __PACKAGE__;\n    }\n    return $singleton;\n}\n\n=head2 render_string($self, $request, $template, $vars, $cvars)\n\nReturns the processed template as a string (of bytes, UTF-8 encoded).\n\nAdds template variables C<USER>, C<DBNAME>, C<locale> and C<SETTINGS>\nfrom C<$request>.\n\nRenders the template stored in the file indicated by C<$template>.\nThe file is looked up in the root templates directory as configured\nor in the C<lib/> subdirectory of it and should be a relative\npath to either of those.\n\nThe values of the variables specified in C<$vars> will be HTML-encoded\nand passed to the template.\n\nC<$cvars> is optional. It's an additional set of variables assumed to\nbe HTML encoded and ready for inclusion in the generated HTML output.\n\n=cut\n\nsub render_string {\n    my ($self, $request, $template, $vars, $cvars) = @_;\n    my $locale;\n    $vars //= {};\n    delete $vars->{HIDDENS}->{form_id} if $vars->{HIDDENS};\n\n    for my $cb (@pre_render_cbs) {\n        $cb->($request, $template, $vars, $cvars);\n    }\n\n    if ($vars->{locale}) {\n        $locale = LedgerSMB::Locale->get_handle($vars->{locale});\n    }\n    elsif ($request->{_locale}) {\n        $locale = $request->{_locale};\n    }\n    my $cleanvars = {\n        ( %{LedgerSMB::Template::preprocess(\n                {\n                    $vars->%*,\n                    PRINTERS => [\n                        ( $request->{_wire}->get( 'printers' )->as_options,\n                          {\n                              text  => $request->{_locale}->text('Screen'),\n                              value => 'screen'\n                          } )\n                    ],\n                    SETTINGS => {\n                        ($request->{_company_config} // {})->%*,\n                        # Reports rendered as UI elements have SETTINGS in $vars\n                        ($vars->{SETTINGS} // {})->%*\n                    },\n                    dojo_theme => (\n                        $request->{_company_config}->{dojo_theme} || 'claro'\n                        ),\n                    csrf_token => $request->{_req}->env->{'lsmb.session'}->{csrf_token},\n                },\n                sub { return escape_html($_[0]); },\n                $request->formatter_options,\n                )},\n          %{$self->{standard_vars}},\n          LIST_FORMATS => sub {\n              return [\n                  map { escape_html($_) }\n                  $request->{_wire}->get( 'output_formatter' )->get_formats->@*\n                  ];\n          },\n          # translation of constant-string arguments\n          text => sub {\n              if ($locale) {\n                  return escape_html($locale->maketext(@_));\n              }\n              else {\n                  return shift;\n              }\n          },\n          # translation of dynamic string content\n          maketext => sub {\n              if ($locale) {\n                  return escape_html($locale->maketext(@_));\n              }\n              else {\n                  return escape_html(shift);\n              }\n          },\n          %{$cvars // {}}\n        )\n    };\n    if (defined $cleanvars->{form}->{stylesheet}\n        and not defined $cleanvars->{stylesheet}) {\n        $cleanvars->{stylesheet} = $cleanvars->{form}->{stylesheet};\n    }\n    if (not defined $cleanvars->{stylesheet}\n        or (defined $cleanvars->{stylesheet}\n            and not -e ($self->{root} . 'css/' . $cleanvars->{stylesheet}))) {\n        $cleanvars->{stylesheet} = $self->{stylesheet};\n    }\n\n    my $output;\n    if (! $engine->process(\n            $template . '.html',\n            $cleanvars,\n            \\$output,\n            { binmode => 'utf8' })) {\n        my $error = $engine->error() // '<undef>';\n        croak 'Template error: ' . $error;\n    }\n    utf8::encode($output) if utf8::is_utf8($output); ## no critic\n    return $output;\n}\n\n=head2 render($self, $request, $template, $vars, $cvars)\n\nCalls C<render_string> with its arguments and converts the response\nto a PSGI response triplet.\n\n=cut\n\nsub render {\n    return [ 200, [ 'Content-Type' => 'text/html; charset=UTF-8' ],\n             [ render_string(@_) ] ];\n}\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (C) 2018 The LedgerSMB Core Team\n\nThis file is licensed under the GNU General Public License version 2, or at your\noption any later version.  A copy of the license should have been included with\nyour software.\n\n=cut\n\n1;\n"], "filenames": ["UI/setup/begin_backup.html", "UI/setup/confirm_operation.html", "UI/setup/credentials.html", "UI/setup/edit_user.html", "UI/setup/migration_step.html", "UI/setup/new_user.html", "UI/setup/select_coa.html", "UI/setup/template_info.html", "UI/setup/upgrade_info.html", "lib/LedgerSMB.pm", "lib/LedgerSMB/Middleware/SessionStorage.pm", "lib/LedgerSMB/PSGI.pm", "lib/LedgerSMB/Scripts/setup.pm", "lib/LedgerSMB/Template/UI.pm"], "buggy_code_start_loc": [11, 17, 33, 22, 15, 11, 9, 8, 11, 21, 35, 357, 386, 138], "buggy_code_end_loc": [11, 17, 33, 112, 15, 11, 9, 8, 11, 311, 67, 357, 1644, 139], "fixing_code_start_loc": [12, 18, 34, 23, 16, 12, 10, 9, 12, 22, 36, 358, 387, 138], "fixing_code_end_loc": [13, 19, 35, 115, 17, 13, 11, 10, 13, 336, 69, 364, 1695, 140], "type": "CWE-352", "message": "LedgerSMB is a free web-based double-entry accounting system. When a LedgerSMB database administrator has an active session in /setup.pl, an attacker can trick the admin into clicking on a link which automatically submits a request to setup.pl without the admin's consent.  This request can be used to create a new user account with full application (/login.pl) privileges, leading to privilege escalation.  The vulnerability is patched in versions 1.10.30 and 1.11.9.\n", "other": {"cve": {"id": "CVE-2024-23831", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-02T16:15:55.593", "lastModified": "2024-02-10T01:43:51.527", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "LedgerSMB is a free web-based double-entry accounting system. When a LedgerSMB database administrator has an active session in /setup.pl, an attacker can trick the admin into clicking on a link which automatically submits a request to setup.pl without the admin's consent.  This request can be used to create a new user account with full application (/login.pl) privileges, leading to privilege escalation.  The vulnerability is patched in versions 1.10.30 and 1.11.9.\n"}, {"lang": "es", "value": "LedgerSMB es un sistema de contabilidad por partida doble gratuito basado en la web. Cuando un administrador de base de datos LedgerSMB tiene una sesi\u00f3n activa en /setup.pl, un atacante puede enga\u00f1ar al administrador para que haga clic en un enlace que env\u00eda autom\u00e1ticamente una solicitud a setup.pl sin el consentimiento del administrador. Esta solicitud se puede utilizar para crear una nueva cuenta de usuario con privilegios completos de aplicaci\u00f3n (/login.pl), lo que lleva a una escalada de privilegios. La vulnerabilidad est\u00e1 parcheada en las versiones 1.10.30 y 1.11.9."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ledgersmb:ledgersmb:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.3.0", "versionEndExcluding": "1.10.30", "matchCriteriaId": "E75E01ED-83A6-4BEF-BCCE-3DC1A99C0F90"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ledgersmb:ledgersmb:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.11.0", "versionEndExcluding": "1.11.9", "matchCriteriaId": "6BAB4653-68D6-4094-8E16-62DD69A1BAA1"}]}]}], "references": [{"url": "https://github.com/ledgersmb/LedgerSMB/commit/8c2ae5be68a782d62cb9c0e17c0127bf30ef4165", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/ledgersmb/LedgerSMB/security/advisories/GHSA-98ff-f638-qxjm", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ledgersmb/LedgerSMB/commit/8c2ae5be68a782d62cb9c0e17c0127bf30ef4165"}}