{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Romain Bouqueau, Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2018-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / AV1 IVF/OBU/annexB reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n#include <gpac/internal/media_dev.h>\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble duration;\n} AV1Idx;\n\ntypedef enum {\n\tNOT_SET,   /*Section 5*/\n\tOBUs,   /*Section 5*/\n\tAnnexB,\n\tIVF,\n\tUNSUPPORTED\n} AV1BitstreamSyntax;\n\ntypedef struct\n{\n\t//filter args\n\tGF_Fraction fps;\n\tDouble index;\n\tBool importer;\n\tBool deps;\n\t\n\tu32 bsdbg;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tAV1BitstreamSyntax bsmode;\n\n\tGF_BitStream *bs;\n\tu64 cts;\n\tu32 width, height;\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\tGF_Fraction cur_fps;\n\n\tu32 resume_from;\n\n\tchar *buffer;\n\tu32 buf_size, alloc_size;\n\n\t//ivf header for now\n\tu32 file_hdr_size;\n\n\tBool is_av1;\n\tBool is_vp9;\n\tBool is_vpX;\n\tu32 codecid;\n\tGF_VPConfig *vp_cfg;\n\n\tBool is_playing;\n\tBool is_file, file_loaded;\n\tBool initial_play_done;\n\n\tGF_FilterPacket *src_pck;\n\n\tAV1Idx *indexes;\n\tu32 index_alloc_size, index_size;\n\n\tAV1State state;\n\tu32 dsi_crc;\n\n\tBool pts_from_file;\n\tu64 cumulated_dur, last_pts;\n\tu32 bitrate;\n} GF_AV1DmxCtx;\n\n\nGF_Err av1dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_AV1DmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) ctx->timescale = p->value.uint;\n\tctx->state.mem_mode = GF_TRUE;\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t}\n\tif (ctx->timescale) {\n\t\t//if we have a FPS prop, use it\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\tif (p) ctx->cur_fps = p->value.frac;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err av1dmx_check_format(GF_Filter *filter, GF_AV1DmxCtx *ctx, GF_BitStream *bs, u32 *last_obu_end)\n{\n\tGF_Err e;\n\tif (last_obu_end) (*last_obu_end) = 0;\n\t//probing av1 bs mode\n\tif (ctx->bsmode != NOT_SET) return GF_OK;\n\n\n\tif (!ctx->state.config)\n\t\tctx->state.config = gf_odf_av1_cfg_new();\n\n\tctx->is_av1 = ctx->is_vp9 = ctx->is_vpX = GF_FALSE;\n\tctx->codecid = 0;\n\tif (ctx->vp_cfg) gf_odf_vp_cfg_del(ctx->vp_cfg);\n\tctx->vp_cfg = NULL;\n\tctx->cur_fps = ctx->fps;\n\tif (!ctx->fps.num || !ctx->fps.den) {\n\t\tctx->cur_fps.num = 25000;\n\t\tctx->cur_fps.den = 1000;\n\t}\n\n\tctx->pts_from_file = GF_FALSE;\n\tif (gf_media_probe_ivf(bs)) {\n\t\tu32 width = 0, height = 0;\n\t\tu32 codec_fourcc = 0, timebase_den = 0, timebase_num = 0, num_frames = 0;\n\t\tctx->bsmode = IVF;\n\n\t\te = gf_media_parse_ivf_file_header(bs, &width, &height, &codec_fourcc, &timebase_num, &timebase_den, &num_frames);\n\t\tif (e) return e;\n\n\t\tswitch (codec_fourcc) {\n\t\tcase GF_4CC('A', 'V', '0', '1'):\n\t\t\tctx->is_av1 = GF_TRUE;\n\t\t\tctx->codecid = GF_CODECID_AV1;\n\t\t\tbreak;\n\t\tcase GF_4CC('V', 'P', '9', '0'):\n\t\t\tctx->is_vp9 = GF_TRUE;\n\t\t\tctx->codecid = GF_CODECID_VP9;\n\t\t\tctx->vp_cfg = gf_odf_vp_cfg_new();\n\t\t\tbreak;\n\t\tcase GF_4CC('V', 'P', '8', '0'):\n\t\t\tctx->codecid = GF_CODECID_VP8;\n\t\t\tctx->vp_cfg = gf_odf_vp_cfg_new();\n\t\t\tbreak;\n\t\tcase GF_4CC('V', 'P', '1', '0'):\n\t\t\tctx->codecid = GF_CODECID_VP10;\n\t\t\tctx->vp_cfg = gf_odf_vp_cfg_new();\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[IVF] %s parsing not implemented, import might be uncomplete or broken\\n\", gf_4cc_to_str(codec_fourcc) ));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tctx->codecid = codec_fourcc;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[IVF] Unsupported codec FourCC %s\\n\", gf_4cc_to_str(codec_fourcc) ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tif (ctx->vp_cfg && !ctx->is_vp9) {\n\t\t\tctx->is_vpX = GF_TRUE;\n\t\t\tctx->vp_cfg->profile = 1;\n\t\t\tctx->vp_cfg->level = 10;\n\t\t\tctx->vp_cfg->bit_depth = 8;\n\t\t\t//leave the rest as 0\n\t\t}\n\n\t\tctx->state.width = ctx->state.width < width ? width : ctx->state.width;\n\t\tctx->state.height = ctx->state.height < height ? height : ctx->state.height;\n\t\tctx->state.tb_num = timebase_num;\n\t\tctx->state.tb_den = timebase_den;\n\n\t\tif ((!ctx->fps.num || !ctx->fps.den) && ctx->state.tb_num && ctx->state.tb_den && ! ( (ctx->state.tb_num<=1) && (ctx->state.tb_den<=1) ) ) {\n\t\t\tctx->cur_fps.num = ctx->state.tb_num;\n\t\t\tctx->cur_fps.den = ctx->state.tb_den;\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[AV1Dmx] Detected IVF format FPS %d/%d\\n\", ctx->cur_fps.num, ctx->cur_fps.den));\n\t\t\tctx->pts_from_file = GF_TRUE;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[AV1Dmx] Detected IVF format\\n\"));\n\t\t}\n\t\tctx->file_hdr_size = (u32) gf_bs_get_position(bs);\n\t\tif (last_obu_end) (*last_obu_end) = (u32) gf_bs_get_position(bs);\n\t\treturn GF_OK;\n\t} else if (gf_media_aom_probe_annexb(bs)) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] Detected Annex B format\\n\"));\n\t\tctx->bsmode = AnnexB;\n\t} else {\n\t\tgf_bs_seek(bs, 0);\n\t\te = aom_av1_parse_temporal_unit_from_section5(bs, &ctx->state);\n\t\tif (e && !gf_list_count(ctx->state.frame_state.frame_obus) ) {\n\t\t\tgf_filter_setup_failure(filter, e);\n\t\t\tctx->bsmode = UNSUPPORTED;\n\t\t\treturn e;\n\t\t}\n\t\tif (ctx->state.obu_type != OBU_TEMPORAL_DELIMITER) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1Dmx] Error OBU stream start with %s, not a temporal delimiter - NOT SUPPORTED\\n\", gf_av1_get_obu_name(ctx->state.obu_type) ));\n\t\t\tgf_filter_setup_failure(filter, e);\n\t\t\tctx->bsmode = UNSUPPORTED;\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] Detected OBUs Section 5 format\\n\"));\n\t\tctx->bsmode = OBUs;\n\n\t\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\tgf_bs_seek(bs, 0);\n\t}\n\tctx->is_av1 = GF_TRUE;\n\tctx->state.unframed = GF_TRUE;\n\tctx->codecid = GF_CODECID_AV1;\n\treturn GF_OK;\n}\n\n\nstatic void av1dmx_check_dur(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tFILE *stream;\n\tGF_Err e;\n\tGF_BitStream *bs;\n\tu64 duration, cur_dur, last_cdur, rate;\n\tAV1State av1state;\n\tconst char *filepath=NULL;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tfilepath = p->value.string;\n\tctx->is_file = GF_TRUE;\n\n\tif (ctx->index<0) {\n\t\tif (gf_opts_get_bool(\"temp\", \"force_indexing\")) {\n\t\t\tctx->index = 1.0;\n\t\t} else {\n\t\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_DOWN_SIZE);\n\t\t\tif (!p || (p->value.longuint > 100000000)) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"[AV1/VP9] Source file larger than 100M, skipping indexing\\n\"));\n\t\t\t} else {\n\t\t\t\tctx->index = -ctx->index;\n\t\t\t}\n\t\t}\n\t}\n\tif (ctx->index<=0)\n\t\treturn;\n\n\tstream = gf_fopen(filepath, \"rb\");\n\tif (!stream) return;\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\n\tif (ctx->file_hdr_size) {\n\t\tgf_bs_seek(bs, ctx->file_hdr_size);\n\t}\n\tgf_av1_init_state(&av1state);\n\tav1state.skip_frames = GF_TRUE;\n\tav1state.config = gf_odf_av1_cfg_new();\n\n\tduration = 0;\n\tcur_dur = last_cdur = 0;\n\twhile (gf_bs_available(bs)) {\n\t\tBool is_sap=GF_FALSE;\n\t\tu64 pts = GF_FILTER_NO_TS;\n\t\tu64 frame_start = gf_bs_get_position(bs);\n\t\tgf_av1_reset_state(&av1state, GF_FALSE);\n\n\t\t/*we process each TU and extract only the necessary OBUs*/\n\t\tswitch (ctx->bsmode) {\n\t\tcase OBUs:\n\t\t\te = aom_av1_parse_temporal_unit_from_section5(bs, &av1state);\n\t\t\tbreak;\n\t\tcase AnnexB:\n\t\t\te = aom_av1_parse_temporal_unit_from_annexb(bs, &av1state);\n\t\t\tbreak;\n\t\tcase IVF:\n\t\t\tif (ctx->is_av1) {\n\t\t\t\te = aom_av1_parse_temporal_unit_from_ivf(bs, &av1state);\n\t\t\t} else {\n\t\t\t\tu64 frame_size;\n\t\t\t\te = gf_media_parse_ivf_frame_header(bs, &frame_size, &pts);\n\t\t\t\tif (!e) gf_bs_skip_bytes(bs, frame_size);\n\t\t \t\tis_sap = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t}\n\t\tif (e)\n\t\t \tbreak;\n\n\t\tif (pts != GF_FILTER_NO_TS) {\n\t\t\tduration = pts;\n\t\t\tcur_dur = pts - last_cdur;\n\t\t} else {\n\t\t\tduration += ctx->cur_fps.den;\n\t\t\tcur_dur += ctx->cur_fps.den;\n\t\t}\n\t\tif (av1state.frame_state.key_frame)\n\t\t \tis_sap = GF_TRUE;\n\n\t\t//only index at I-frame start\n\t\tif (frame_start && is_sap && (cur_dur > ctx->index * ctx->cur_fps.num) ) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(AV1Idx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = frame_start;\n\t\t\tctx->indexes[ctx->index_size].duration = (Double) duration;\n\t\t\tctx->indexes[ctx->index_size].duration /= ctx->cur_fps.num;\n\t\t\tctx->index_size ++;\n\t\t\tlast_cdur = cur_dur;\n\t\t\tcur_dur = 0;\n\t\t}\n\t}\n\trate = gf_bs_get_position(bs);\n\tgf_bs_del(bs);\n\tgf_fclose(stream);\n\tgf_odf_av1_cfg_del(av1state.config);\n\tgf_av1_reset_state(&av1state, GF_TRUE);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * ctx->cur_fps.num != duration * ctx->duration.den)) {\n\t\tctx->duration.num = (s32) duration;\n\t\tctx->duration.den = ctx->cur_fps.num;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration && (!gf_sys_is_test_mode() || gf_opts_get_bool(\"temp\", \"force_indexing\"))) {\n\t\t\trate *= 8 * ctx->duration.den;\n\t\t\trate /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) rate;\n\t\t}\n\t}\n\n\t//currently not supported because of OBU size field rewrite - could work on some streams but we would\n\t//need to analyse all OBUs in the stream for that\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_FALSE) );\n}\n\n\nstatic Bool av1dmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tu64 file_pos = 0;\n\tGF_FilterEvent fevt;\n\tGF_AV1DmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\tctx->buf_size = 0;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\n\t\tif (ctx->start_range) {\n\n\t\t\tif (ctx->index<0) {\n\t\t\t\tctx->index = -ctx->index;\n\t\t\t\tctx->file_loaded = GF_FALSE;\n\t\t\t\tctx->duration.den = ctx->duration.num = 0;\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"[AV1/VP9Demx] Play request from %d, building index\\n\", ctx->start_range));\n\t\t\t\tav1dmx_check_dur(filter, ctx);\n\t\t\t}\n\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif (ctx->indexes[i].duration>ctx->start_range) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->cur_fps.num);\n\t\t\t\t\tfile_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->buf_size = 0;\n\t\tif (!file_pos)\n\t\t\tfile_pos = ctx->file_hdr_size;\n\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\t//don't cancel event\n\t\tctx->is_playing = GF_FALSE;\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void av1dmx_update_cts(GF_AV1DmxCtx *ctx)\n{\n\tassert(ctx->cur_fps.num);\n\tassert(ctx->cur_fps.den);\n\n\tif (ctx->timescale) {\n\t\tu64 inc = ctx->cur_fps.den;\n\t\tinc *= ctx->timescale;\n\t\tinc /= ctx->cur_fps.num;\n\t\tctx->cts += inc;\n\t} else {\n\t\tctx->cts += ctx->cur_fps.den;\n\t}\n}\n\nstatic void av1dmx_check_pid(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu8 *dsi;\n\tu32 dsi_size, crc;\n\n\t//no config or no config change\n\tif (ctx->is_av1 && !gf_list_count(ctx->state.frame_state.header_obus)) return;\n\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tav1dmx_check_dur(filter, ctx);\n\t}\n\tdsi = NULL;\n\tdsi_size = 0;\n\n\tif (ctx->vp_cfg) {\n\t\tgf_odf_vp_cfg_write(ctx->vp_cfg, &dsi, &dsi_size, ctx->vp_cfg->codec_initdata_size ? GF_TRUE : GF_FALSE);\n\t} else if (ctx->is_av1) {\n\t\t//first or config changed, compute dsi\n\t\twhile (gf_list_count(ctx->state.config->obu_array)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*) gf_list_pop_back(ctx->state.config->obu_array);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t\tdsi = NULL;\n\t\tdsi_size = 0;\n\t\twhile (gf_list_count(ctx->state.frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*) gf_list_get(ctx->state.frame_state.header_obus, 0);\n\t\t\tgf_list_add(ctx->state.config->obu_array, a);\n\t\t\tgf_list_rem(ctx->state.frame_state.header_obus, 0);\n\t\t}\n\t\tgf_odf_av1_cfg_write(ctx->state.config, &dsi, &dsi_size);\n\n\t\tif ((!ctx->fps.num || !ctx->fps.den) && ctx->state.tb_num && ctx->state.tb_den && ! ( (ctx->state.tb_num<=1) && (ctx->state.tb_den<=1) ) ) {\n\t\t\tctx->cur_fps.num = ctx->state.tb_num;\n\t\t\tctx->cur_fps.den = ctx->state.tb_den;\n\t\t}\n\n\t}\n\tcrc = gf_crc_32(dsi, dsi_size);\n\n\tif (crc == ctx->dsi_crc) {\n\t\tgf_free(dsi);\n\t\treturn;\n\t}\n\tctx->dsi_crc = crc;\n\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL));\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(ctx->codecid));\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->cur_fps.num));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_FPS, & PROP_FRAC(ctx->cur_fps));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, & PROP_UINT(ctx->state.width));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, & PROP_UINT(ctx->state.height));\n\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tif (dsi && dsi_size)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY(dsi, dsi_size));\n\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n\n\tif (ctx->is_av1) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, & PROP_UINT(ctx->state.color_primaries) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, & PROP_UINT(ctx->state.transfer_characteristics) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, & PROP_UINT(ctx->state.matrix_coefficients) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, & PROP_BOOL(ctx->state.color_range) );\n\t}\n}\n\nGF_Err av1dmx_parse_ivf(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tGF_Err e;\n\tu32 pck_size;\n\tu64 frame_size = 0, pts = GF_FILTER_NO_TS;\n\tGF_FilterPacket *pck;\n\tu64 pos, pos_ivf_hdr;\n\tu8 *output;\n\n\tpos_ivf_hdr = gf_bs_get_position(ctx->bs);\n\te = gf_media_parse_ivf_frame_header(ctx->bs, &frame_size, &pts);\n\tif (e) return e;\n\n\tpos = gf_bs_get_position(ctx->bs);\n\tif (gf_bs_available(ctx->bs) < frame_size) {\n\t\tgf_bs_seek(ctx->bs, pos_ivf_hdr);\n\t\treturn GF_EOS;\n\t}\n\n\tif (ctx->pts_from_file) {\n\t\tpts += ctx->cumulated_dur;\n\t\tif (ctx->last_pts && (ctx->last_pts>pts)) {\n\t\t\tpts -= ctx->cumulated_dur;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[IVF/AV1] Corrupted timestamp \"LLU\" less than previous timestamp \"LLU\", assuming concatenation\\n\", pts, ctx->last_pts));\n\t\t\tctx->cumulated_dur = ctx->last_pts + ctx->cur_fps.den;\n\t\t\tctx->cumulated_dur -= pts;\n\t\t\tpts = ctx->cumulated_dur;\n\t\t}\n\t\tctx->last_pts = pts;\n\t}\n\n\n\t//check pid state\n\tav1dmx_check_pid(filter, ctx);\n\n\tif (!ctx->opid) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!ctx->is_playing) {\n\t\tgf_bs_seek(ctx->bs, pos_ivf_hdr);\n\t\treturn GF_EOS;\n\t}\n\n\tpck_size = (u32)frame_size;\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (!pck) {\n\t\tgf_bs_seek(ctx->bs, pos_ivf_hdr);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tif (ctx->pts_from_file) {\n\t\tgf_filter_pck_set_cts(pck, pts);\n\t} else {\n\t\tgf_filter_pck_set_cts(pck, ctx->cts);\n\t}\n\n\tgf_bs_seek(ctx->bs, pos);\n\tgf_bs_read_data(ctx->bs, output, pck_size);\n\n\tif (output[0] & 0x80)\n\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\telse\n\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_NONE);\n\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\treturn GF_OK;\n}\n\nGF_Err av1dmx_parse_vp9(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tBool key_frame = GF_FALSE;\n\tu64 frame_size = 0, pts = 0;\n\tu64 pos, pos_ivf_hdr;\n\tu32 width = 0, height = 0, renderWidth, renderHeight;\n\tu32 num_frames_in_superframe = 0, superframe_index_size = 0, i = 0;\n\tu32 frame_sizes[VP9_MAX_FRAMES_IN_SUPERFRAME];\n\tu8 *output;\n\tGF_Err e;\n\n\tpos_ivf_hdr = gf_bs_get_position(ctx->bs);\n\te = gf_media_parse_ivf_frame_header(ctx->bs, &frame_size, &pts);\n\tif (e) return e;\n\n\tpos = gf_bs_get_position(ctx->bs);\n\tif (gf_bs_available(ctx->bs) < frame_size) {\n\t\tgf_bs_seek(ctx->bs, pos_ivf_hdr);\n\t\treturn GF_EOS;\n\t}\n\n\tif (ctx->pts_from_file) {\n\t\tpts += ctx->cumulated_dur;\n\t\tif (ctx->last_pts && (ctx->last_pts>pts)) {\n\t\t\tpts -= ctx->cumulated_dur;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[IVF/VP9] Corrupted timestamp \"LLU\" less than previous timestamp \"LLU\", assuming concatenation\\n\", pts, ctx->last_pts));\n\t\t\tctx->cumulated_dur = ctx->last_pts + ctx->cur_fps.den;\n\t\t\tctx->cumulated_dur -= pts;\n\t\t\tpts = ctx->cumulated_dur;\n\t\t}\n\t\tctx->last_pts = pts;\n\t}\n\n\t/*check if it is a superframe*/\n\te = gf_media_vp9_parse_superframe(ctx->bs, frame_size, &num_frames_in_superframe, frame_sizes, &superframe_index_size);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[VP9Dmx] Error parsing superframe structure\\n\"));\n\t\treturn e;\n\t}\n\n\tfor (i = 0; i < num_frames_in_superframe; ++i) {\n\t\tu64 pos2 = gf_bs_get_position(ctx->bs);\n\t\tif (gf_media_vp9_parse_sample(ctx->bs, ctx->vp_cfg, &key_frame, &width, &height, &renderWidth, &renderHeight) != GF_OK) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[VP9Dmx] Error parsing frame\\n\"));\n\t\t\treturn e;\n\t\t}\n\t\te = gf_bs_seek(ctx->bs, pos2 + frame_sizes[i]);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[VP9Dmx] Seek bad param (offset \"LLU\") (1)\", pos2 + frame_sizes[i]));\n\t\t\treturn e;\n\t\t}\n\t}\n\tif (gf_bs_get_position(ctx->bs) + superframe_index_size != pos + frame_size) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[VP9Dmx] Inconsistent IVF frame size of \"LLU\" bytes.\\n\", frame_size));\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"      Detected %d frames (+ %d bytes for the superframe index):\\n\", num_frames_in_superframe, superframe_index_size));\n\t\tfor (i = 0; i < num_frames_in_superframe; ++i) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"         superframe %d, size is %u bytes\\n\", i, frame_sizes[i]));\n\t\t}\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"\\n\"));\n\t}\n\te = gf_bs_seek(ctx->bs, pos + frame_size);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[VP9Dmx] Seek bad param (offset \"LLU\") (2)\", pos + frame_size));\n\t\treturn e;\n\t}\n\n\tu32 pck_size = (u32)(gf_bs_get_position(ctx->bs) - pos);\n\tassert(pck_size == frame_size);\n\n\t//check pid state\n\tav1dmx_check_pid(filter, ctx);\n\n\tif (!ctx->opid) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!ctx->is_playing) {\n\t\tgf_bs_seek(ctx->bs, pos_ivf_hdr);\n\t\treturn GF_EOS;\n\t}\n\n\tGF_FilterPacket *pck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (!pck) {\n\t\tgf_bs_seek(ctx->bs, pos_ivf_hdr);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tif (ctx->pts_from_file) {\n\t\tgf_filter_pck_set_cts(pck, pts);\n\t} else {\n\t\tgf_filter_pck_set_cts(pck, ctx->cts);\n\t}\n\n\n\tif (key_frame) {\n\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\t}\n\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = (key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t\t//flags |= 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t\t//flags |= ctx->has_redundant ? 1 : 2;\n\t\tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\n\tgf_bs_seek(ctx->bs, pos);\n\tgf_bs_read_data(ctx->bs, output, pck_size);\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\treturn GF_OK;\n}\n\nstatic GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n\t\treturn GF_OK;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t \t//flags |= ctx->has_redundant ? 1 : 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\n\treturn GF_OK;\n\n}\nGF_Err av1dmx_parse_av1(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tGF_Err e = GF_OK;\n\tu64 start;\n\n\tif (!ctx->is_playing) {\n\t\tctx->state.frame_state.is_first_frame = GF_TRUE;\n\t}\n\n\t/*we process each TU and extract only the necessary OBUs*/\n\tstart = gf_bs_get_position(ctx->bs);\n\tswitch (ctx->bsmode) {\n\tcase OBUs:\n\t\t//first frame loaded !\n\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs) && (ctx->state.obu_type == OBU_TEMPORAL_DELIMITER)) {\n\t\t\te = GF_OK;\n\t\t} else {\n\t\t\te = aom_av1_parse_temporal_unit_from_section5(ctx->bs, &ctx->state);\n\t\t}\n\t\tbreak;\n\tcase AnnexB:\n\t\t//first TU loaded !\n\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs)) {\n\t\t\te = GF_OK;\n\t\t} else {\n\t\t\te = aom_av1_parse_temporal_unit_from_annexb(ctx->bs, &ctx->state);\n\t\t\tif (e==GF_BUFFER_TOO_SMALL) {\n\t\t\t\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\t\t\tgf_bs_seek(ctx->bs, start);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IVF:\n\t\t//first frame loaded !\n\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs)) {\n\t\t\te = GF_OK;\n\t\t} else {\n\t\t\te = aom_av1_parse_temporal_unit_from_ivf(ctx->bs, &ctx->state);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\te = GF_NOT_SUPPORTED;\n\t}\n\n\t//check pid state\n\tav1dmx_check_pid(filter, ctx);\n\n\tif (e) return e;\n\n\n\tif (!ctx->opid) {\n\t\tif (ctx->state.obu_type != OBU_TEMPORAL_DELIMITER) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1Dmx] output pid not configured (no sequence header yet ?), skipping OBU\\n\"));\n\t\t}\n\t\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\treturn GF_OK;\n\t}\n\n\tif (!ctx->is_playing) {\n\t\t//don't reset state we would skip seq header obu in first frame\n\t\t//gf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\treturn GF_OK;\n\t}\n\n\treturn av1dmx_parse_flush_sample(filter, ctx);\n\n}\n\nGF_Err gf_bs_set_logger(GF_BitStream *bs, void (*on_bs_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3), void *udta);\nstatic void av1dmx_bs_log(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3)\n{\n\tGF_AV1DmxCtx *ctx = (GF_AV1DmxCtx *) udta;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\" %s\", field_name));\n\tif (idx1>=0) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"_%d\", idx1));\n\t\tif (idx2>=0) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"_%d\", idx2));\n\t\t\tif (idx3>=0) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"_%d\", idx3));\n\t\t\t}\n\t\t}\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"=\\\"\"LLD, field_val));\n\tif ((ctx->bsdbg==2) && ((s32) nb_bits > 1) )\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"(%u)\", nb_bits));\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"\\\" \"));\n}\n\nGF_Err av1dmx_process_buffer(GF_Filter *filter, GF_AV1DmxCtx *ctx, const char *data, u32 data_size, Bool is_copy)\n{\n\tu32 last_obu_end = 0;\n\tGF_Err e = GF_OK;\n\n\tif (!ctx->bs) ctx->bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ctx->bs, data, data_size);\n\n#ifndef GPAC_DISABLE_LOG\n\tif (ctx->bsdbg && gf_log_tool_level_on(GF_LOG_PARSER, GF_LOG_DEBUG))\n\t\tgf_bs_set_logger(ctx->bs, av1dmx_bs_log, ctx);\n#endif\n\n\t//check ivf vs obu vs annexB\n\te = av1dmx_check_format(filter, ctx, ctx->bs, &last_obu_end);\n\tif (e) return e;\n\n\twhile (gf_bs_available(ctx->bs)) {\n\n\t\tif (ctx->is_vp9) {\n\t\t\te = av1dmx_parse_vp9(filter, ctx);\n\t\t} else if (ctx->is_av1) {\n\t\t\te = av1dmx_parse_av1(filter, ctx);\n\t\t} else {\n\t\t\te = av1dmx_parse_ivf(filter, ctx);\n\t\t}\n\n\t\tif (e!=GF_EOS)\n\t\t\tlast_obu_end = (u32) gf_bs_get_position(ctx->bs);\n\n\t\tif (e) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!ctx->is_playing && ctx->opid)\n\t\t\tbreak;\n\t}\n\n\tif (is_copy && last_obu_end) {\n\t\tassert(ctx->buf_size>=last_obu_end);\n\t\tmemmove(ctx->buffer, ctx->buffer+last_obu_end, sizeof(char) * (ctx->buf_size-last_obu_end));\n\t\tctx->buf_size -= last_obu_end;\n\t}\n\tif (e==GF_EOS) return GF_OK;\n\tif (e==GF_BUFFER_TOO_SMALL) return GF_OK;\n\treturn e;\n}\n\nGF_Err av1dmx_process(GF_Filter *filter)\n{\n\tGF_Err e;\n\tGF_AV1DmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tchar *data;\n\tu32 pck_size;\n\n\tif (ctx->bsmode == UNSUPPORTED) return GF_EOS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tav1dmx_check_dur(filter, ctx);\n\n\tif (!ctx->is_playing && ctx->opid)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\t//flush\n\t\t\twhile (ctx->buf_size) {\n\t\t\t\tu32 buf_size = ctx->buf_size;\n\t\t\t\te = av1dmx_process_buffer(filter, ctx, ctx->buffer, ctx->buf_size, GF_TRUE);\n\t\t\t\tif (e) break;\n\t\t\t\tif (buf_size == ctx->buf_size) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs))\n\t\t\t\tav1dmx_parse_flush_sample(filter, ctx);\n\n\t\t\tctx->buf_size = 0;\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (ctx->opid) {\n\t\tif (!ctx->is_playing || gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale) {\n\t\tBool start, end;\n\t\tu64 cts;\n\n\t\te = GF_OK;\n\n\t\tgf_filter_pck_get_framing(pck, &start, &end);\n\t\t//middle or end of frame, reaggregation\n\t\tif (!start) {\n\t\t\tif (ctx->alloc_size < ctx->buf_size + pck_size) {\n\t\t\t\tctx->alloc_size = ctx->buf_size + pck_size;\n\t\t\t\tctx->buffer = gf_realloc(ctx->buffer, ctx->alloc_size);\n\t\t\t}\n\t\t\tmemcpy(ctx->buffer+ctx->buf_size, data, pck_size);\n\t\t\tctx->buf_size += pck_size;\n\n\t\t\t//end of frame, process av1\n\t\t\tif (end) {\n\t\t\t\te = av1dmx_process_buffer(filter, ctx, ctx->buffer, ctx->buf_size, GF_TRUE);\n\t\t\t}\n\t\t\tctx->buf_size=0;\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn e;\n\t\t}\n\t\t//flush of pending frame (might have lost something)\n\t\tif (ctx->buf_size) {\n\t\t\te = av1dmx_process_buffer(filter, ctx, ctx->buffer, ctx->buf_size, GF_TRUE);\n\t\t\tctx->buf_size = 0;\n\t\t\tif (e) return e;\n\t\t}\n\n\t\t//begining of a new frame\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t\tif (cts != GF_FILTER_NO_TS)\n\t\t\tctx->cts = cts;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\tctx->buf_size = 0;\n\n\t\tif (!end) {\n\t\t\tif (ctx->alloc_size < ctx->buf_size + pck_size) {\n\t\t\t\tctx->alloc_size = ctx->buf_size + pck_size;\n\t\t\t\tctx->buffer = gf_realloc(ctx->buffer, ctx->alloc_size);\n\t\t\t}\n\t\t\tmemcpy(ctx->buffer+ctx->buf_size, data, pck_size);\n\t\t\tctx->buf_size += pck_size;\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tassert(start && end);\n\t\t//process\n\t\te = av1dmx_process_buffer(filter, ctx, data, pck_size, GF_FALSE);\n\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\treturn e;\n\t}\n\n\t//not from framed stream, copy buffer\n\tif (ctx->alloc_size < ctx->buf_size + pck_size) {\n\t\tctx->alloc_size = ctx->buf_size + pck_size;\n\t\tctx->buffer = gf_realloc(ctx->buffer, ctx->alloc_size);\n\t}\n\tmemcpy(ctx->buffer+ctx->buf_size, data, pck_size);\n\tctx->buf_size += pck_size;\n\te = av1dmx_process_buffer(filter, ctx, ctx->buffer, ctx->buf_size, GF_TRUE);\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\treturn e;\n}\n\nstatic void av1dmx_finalize(GF_Filter *filter)\n{\n\tGF_AV1DmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\n\tgf_av1_reset_state(&ctx->state, GF_TRUE);\n\tif (ctx->state.config) gf_odf_av1_cfg_del(ctx->state.config);\n\tif (ctx->state.bs) gf_bs_del(ctx->state.bs);\n\tif (ctx->state.frame_obus) gf_free(ctx->state.frame_obus);\n\tif (ctx->buffer) gf_free(ctx->buffer);\n\n\tif (ctx->vp_cfg) gf_odf_vp_cfg_del(ctx->vp_cfg);\n}\n\nstatic const char * av1dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tGF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tBool res;\n\tu32 lt;\n\tconst char *mime = \"video/av1\";\n\tlt = gf_log_get_tool_level(GF_LOG_CODING);\n\tgf_log_set_tool_level(GF_LOG_CODING, GF_LOG_QUIET);\n\n\tres = gf_media_probe_ivf(bs);\n\tif (res) {\n\t\t*score = GF_FPROBE_SUPPORTED;\n\t\tmime = \"video/x-ivf\";\n\t} else {\n\t\tres = gf_media_aom_probe_annexb(bs);\n\t\tif (res) *score = GF_FPROBE_SUPPORTED;\n\t\telse {\n\t\t\tAV1State state;\n\t\t\tGF_Err e;\n\t\t\tu32 nb_units = 0;\n\n\t\t\tgf_av1_init_state(&state);\n\t\t\tstate.config = gf_odf_av1_cfg_new();\n\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\te = aom_av1_parse_temporal_unit_from_section5(bs, &state);\n\t\t\t\tif ((e==GF_OK) || (nb_units && (e==GF_BUFFER_TOO_SMALL) ) ) {\n\t\t\t\t\tif (!nb_units || gf_list_count(state.frame_state.header_obus) || gf_list_count(state.frame_state.frame_obus)) {\n\t\t\t\t\t\tnb_units++;\n\t\t\t\t\t\tif (e==GF_BUFFER_TOO_SMALL)\n\t\t\t\t\t\t\tnb_units++;\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_av1_reset_state(&state, GF_FALSE);\n\t\t\t\tif (nb_units>2) break;\n\t\t\t}\n\t\t\tgf_odf_av1_cfg_del(state.config);\n\t\t\tgf_av1_reset_state(&state, GF_TRUE);\n\t\t\tif (nb_units>2) {\n\t\t\t\tres = GF_TRUE;\n\t\t\t\t*score = GF_FPROBE_MAYBE_SUPPORTED;\n\t\t\t}\n\t\t}\n\t}\n\n\tgf_log_set_tool_level(GF_LOG_CODING, lt);\n\n\tgf_bs_del(bs);\n\tif (res) return mime;\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability AV1DmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"ivf|obu|av1b|av1\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"video/x-ivf|video/av1\"),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AV1),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_VP8),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_VP9),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_VP10),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AV1),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_VP8),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_VP9),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_VP10),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_AV1DmxCtx, _n)\nstatic const GF_FilterArgs AV1DmxArgs[] =\n{\n\t{ OFFS(fps), \"import frame rate (0 default to FPS from bitstream or 25 Hz)\", GF_PROP_FRACTION, \"0/1000\", NULL, 0},\n\t{ OFFS(index), \"indexing window length. If 0, bitstream is not probed for duration. A negative value skips the indexing if the source file is larger than 100M (slows down importers) unless a play with start range > 0 is issued, otherwise uses the positive value\", GF_PROP_DOUBLE, \"-1.0\", NULL, 0},\n\n\t{ OFFS(importer), \"compatibility with old importer\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(deps), \"import samples dependencies information\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(bsdbg), \"debug NAL parsing in parser@debug logs\\n\"\n\t\t\"- off: not enabled\\n\"\n\t\t\"- on: enabled\\n\"\n\t\t\"- full: enable with number of bits dumped\", GF_PROP_UINT, \"off\", \"off|on|full\", GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\n\nGF_FilterRegister AV1DmxRegister = {\n\t.name = \"rfav1\",\n\tGF_FS_SET_DESCRIPTION(\"AV1/IVF/VP9 reframer\")\n\tGF_FS_SET_HELP(\"This filter parses AV1 OBU, AV1 AnnexB or IVF with AV1 or VP9 files/data and outputs corresponding visual PID and frames.\")\n\t.private_size = sizeof(GF_AV1DmxCtx),\n\t.args = AV1DmxArgs,\n\t.finalize = av1dmx_finalize,\n\tSETCAPS(AV1DmxCaps),\n\t.configure_pid = av1dmx_configure_pid,\n\t.process = av1dmx_process,\n\t.probe_data = av1dmx_probe_data,\n\t.process_event = av1dmx_process_event\n};\n\n\nconst GF_FilterRegister *av1dmx_register(GF_FilterSession *session)\n{\n\treturn &AV1DmxRegister;\n}\n\n#else\nconst GF_FilterRegister *av1dmx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_AV_PARSERS\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Romain Bouqueau, Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2018-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / AV1 IVF/OBU/annexB reframer filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/avparse.h>\n#include <gpac/constants.h>\n#include <gpac/filters.h>\n#include <gpac/internal/media_dev.h>\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\ntypedef struct\n{\n\tu64 pos;\n\tDouble duration;\n} AV1Idx;\n\ntypedef enum {\n\tNOT_SET,   /*Section 5*/\n\tOBUs,   /*Section 5*/\n\tAnnexB,\n\tIVF,\n\tUNSUPPORTED\n} AV1BitstreamSyntax;\n\ntypedef struct\n{\n\t//filter args\n\tGF_Fraction fps;\n\tDouble index;\n\tBool importer;\n\tBool deps;\n\t\n\tu32 bsdbg;\n\n\t//only one input pid declared\n\tGF_FilterPid *ipid;\n\t//only one output pid declared\n\tGF_FilterPid *opid;\n\n\tAV1BitstreamSyntax bsmode;\n\n\tGF_BitStream *bs;\n\tu64 cts;\n\tu32 width, height;\n\tGF_Fraction64 duration;\n\tDouble start_range;\n\tBool in_seek;\n\tu32 timescale;\n\tGF_Fraction cur_fps;\n\n\tu32 resume_from;\n\n\tchar *buffer;\n\tu32 buf_size, alloc_size;\n\n\t//ivf header for now\n\tu32 file_hdr_size;\n\n\tBool is_av1;\n\tBool is_vp9;\n\tBool is_vpX;\n\tu32 codecid;\n\tGF_VPConfig *vp_cfg;\n\n\tBool is_playing;\n\tBool is_file, file_loaded;\n\tBool initial_play_done;\n\n\tGF_FilterPacket *src_pck;\n\n\tAV1Idx *indexes;\n\tu32 index_alloc_size, index_size;\n\n\tAV1State state;\n\tu32 dsi_crc;\n\n\tBool pts_from_file;\n\tu64 cumulated_dur, last_pts;\n\tu32 bitrate;\n} GF_AV1DmxCtx;\n\n\nGF_Err av1dmx_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tconst GF_PropertyValue *p;\n\tGF_AV1DmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\tif (ctx->opid) {\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\tctx->ipid = pid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\tif (p) ctx->timescale = p->value.uint;\n\tctx->state.mem_mode = GF_TRUE;\n\tif (ctx->timescale && !ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t}\n\tif (ctx->timescale) {\n\t\t//if we have a FPS prop, use it\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\tif (p) ctx->cur_fps = p->value.frac;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err av1dmx_check_format(GF_Filter *filter, GF_AV1DmxCtx *ctx, GF_BitStream *bs, u32 *last_obu_end)\n{\n\tGF_Err e;\n\tif (last_obu_end) (*last_obu_end) = 0;\n\t//probing av1 bs mode\n\tif (ctx->bsmode != NOT_SET) return GF_OK;\n\n\n\tif (!ctx->state.config)\n\t\tctx->state.config = gf_odf_av1_cfg_new();\n\n\tctx->is_av1 = ctx->is_vp9 = ctx->is_vpX = GF_FALSE;\n\tctx->codecid = 0;\n\tif (ctx->vp_cfg) gf_odf_vp_cfg_del(ctx->vp_cfg);\n\tctx->vp_cfg = NULL;\n\tctx->cur_fps = ctx->fps;\n\tif (!ctx->fps.num || !ctx->fps.den) {\n\t\tctx->cur_fps.num = 25000;\n\t\tctx->cur_fps.den = 1000;\n\t}\n\n\tctx->pts_from_file = GF_FALSE;\n\tif (gf_media_probe_ivf(bs)) {\n\t\tu32 width = 0, height = 0;\n\t\tu32 codec_fourcc = 0, timebase_den = 0, timebase_num = 0, num_frames = 0;\n\t\tctx->bsmode = IVF;\n\n\t\te = gf_media_parse_ivf_file_header(bs, &width, &height, &codec_fourcc, &timebase_num, &timebase_den, &num_frames);\n\t\tif (e) return e;\n\n\t\tswitch (codec_fourcc) {\n\t\tcase GF_4CC('A', 'V', '0', '1'):\n\t\t\tctx->is_av1 = GF_TRUE;\n\t\t\tctx->codecid = GF_CODECID_AV1;\n\t\t\tbreak;\n\t\tcase GF_4CC('V', 'P', '9', '0'):\n\t\t\tctx->is_vp9 = GF_TRUE;\n\t\t\tctx->codecid = GF_CODECID_VP9;\n\t\t\tctx->vp_cfg = gf_odf_vp_cfg_new();\n\t\t\tbreak;\n\t\tcase GF_4CC('V', 'P', '8', '0'):\n\t\t\tctx->codecid = GF_CODECID_VP8;\n\t\t\tctx->vp_cfg = gf_odf_vp_cfg_new();\n\t\t\tbreak;\n\t\tcase GF_4CC('V', 'P', '1', '0'):\n\t\t\tctx->codecid = GF_CODECID_VP10;\n\t\t\tctx->vp_cfg = gf_odf_vp_cfg_new();\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[IVF] %s parsing not implemented, import might be uncomplete or broken\\n\", gf_4cc_to_str(codec_fourcc) ));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tctx->codecid = codec_fourcc;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[IVF] Unsupported codec FourCC %s\\n\", gf_4cc_to_str(codec_fourcc) ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tif (ctx->vp_cfg && !ctx->is_vp9) {\n\t\t\tctx->is_vpX = GF_TRUE;\n\t\t\tctx->vp_cfg->profile = 1;\n\t\t\tctx->vp_cfg->level = 10;\n\t\t\tctx->vp_cfg->bit_depth = 8;\n\t\t\t//leave the rest as 0\n\t\t}\n\n\t\tctx->state.width = ctx->state.width < width ? width : ctx->state.width;\n\t\tctx->state.height = ctx->state.height < height ? height : ctx->state.height;\n\t\tctx->state.tb_num = timebase_num;\n\t\tctx->state.tb_den = timebase_den;\n\n\t\tif ((!ctx->fps.num || !ctx->fps.den) && ctx->state.tb_num && ctx->state.tb_den && ! ( (ctx->state.tb_num<=1) && (ctx->state.tb_den<=1) ) ) {\n\t\t\tctx->cur_fps.num = ctx->state.tb_num;\n\t\t\tctx->cur_fps.den = ctx->state.tb_den;\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[AV1Dmx] Detected IVF format FPS %d/%d\\n\", ctx->cur_fps.num, ctx->cur_fps.den));\n\t\t\tctx->pts_from_file = GF_TRUE;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[AV1Dmx] Detected IVF format\\n\"));\n\t\t}\n\t\tctx->file_hdr_size = (u32) gf_bs_get_position(bs);\n\t\tif (last_obu_end) (*last_obu_end) = (u32) gf_bs_get_position(bs);\n\t\treturn GF_OK;\n\t} else if (gf_media_aom_probe_annexb(bs)) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] Detected Annex B format\\n\"));\n\t\tctx->bsmode = AnnexB;\n\t} else {\n\t\tgf_bs_seek(bs, 0);\n\t\te = aom_av1_parse_temporal_unit_from_section5(bs, &ctx->state);\n\t\tif (e && !gf_list_count(ctx->state.frame_state.frame_obus) ) {\n\t\t\tgf_filter_setup_failure(filter, e);\n\t\t\tctx->bsmode = UNSUPPORTED;\n\t\t\treturn e;\n\t\t}\n\t\tif (ctx->state.obu_type != OBU_TEMPORAL_DELIMITER) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1Dmx] Error OBU stream start with %s, not a temporal delimiter - NOT SUPPORTED\\n\", gf_av1_get_obu_name(ctx->state.obu_type) ));\n\t\t\tgf_filter_setup_failure(filter, e);\n\t\t\tctx->bsmode = UNSUPPORTED;\n\t\t\treturn e;\n\t\t}\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] Detected OBUs Section 5 format\\n\"));\n\t\tctx->bsmode = OBUs;\n\n\t\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\tgf_bs_seek(bs, 0);\n\t}\n\tctx->is_av1 = GF_TRUE;\n\tctx->state.unframed = GF_TRUE;\n\tctx->codecid = GF_CODECID_AV1;\n\treturn GF_OK;\n}\n\n\nstatic void av1dmx_check_dur(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tFILE *stream;\n\tGF_Err e;\n\tGF_BitStream *bs;\n\tu64 duration, cur_dur, last_cdur, rate;\n\tAV1State av1state;\n\tconst char *filepath=NULL;\n\tconst GF_PropertyValue *p;\n\tif (!ctx->opid || ctx->timescale || ctx->file_loaded) return;\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILE_CACHED);\n\tif (p && p->value.boolean) ctx->file_loaded = GF_TRUE;\n\n\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_FILEPATH);\n\tif (!p || !p->value.string || !strncmp(p->value.string, \"gmem://\", 7)) {\n\t\tctx->is_file = GF_FALSE;\n\t\tctx->file_loaded = GF_TRUE;\n\t\treturn;\n\t}\n\tfilepath = p->value.string;\n\tctx->is_file = GF_TRUE;\n\n\tif (ctx->index<0) {\n\t\tif (gf_opts_get_bool(\"temp\", \"force_indexing\")) {\n\t\t\tctx->index = 1.0;\n\t\t} else {\n\t\t\tp = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_DOWN_SIZE);\n\t\t\tif (!p || (p->value.longuint > 100000000)) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"[AV1/VP9] Source file larger than 100M, skipping indexing\\n\"));\n\t\t\t} else {\n\t\t\t\tctx->index = -ctx->index;\n\t\t\t}\n\t\t}\n\t}\n\tif (ctx->index<=0)\n\t\treturn;\n\n\tstream = gf_fopen(filepath, \"rb\");\n\tif (!stream) return;\n\n\tctx->index_size = 0;\n\n\tbs = gf_bs_from_file(stream, GF_BITSTREAM_READ);\n\n\tif (ctx->file_hdr_size) {\n\t\tgf_bs_seek(bs, ctx->file_hdr_size);\n\t}\n\tgf_av1_init_state(&av1state);\n\tav1state.skip_frames = GF_TRUE;\n\tav1state.config = gf_odf_av1_cfg_new();\n\n\tduration = 0;\n\tcur_dur = last_cdur = 0;\n\twhile (gf_bs_available(bs)) {\n\t\tBool is_sap=GF_FALSE;\n\t\tu64 pts = GF_FILTER_NO_TS;\n\t\tu64 frame_start = gf_bs_get_position(bs);\n\t\tgf_av1_reset_state(&av1state, GF_FALSE);\n\n\t\t/*we process each TU and extract only the necessary OBUs*/\n\t\tswitch (ctx->bsmode) {\n\t\tcase OBUs:\n\t\t\te = aom_av1_parse_temporal_unit_from_section5(bs, &av1state);\n\t\t\tbreak;\n\t\tcase AnnexB:\n\t\t\te = aom_av1_parse_temporal_unit_from_annexb(bs, &av1state);\n\t\t\tbreak;\n\t\tcase IVF:\n\t\t\tif (ctx->is_av1) {\n\t\t\t\te = aom_av1_parse_temporal_unit_from_ivf(bs, &av1state);\n\t\t\t} else {\n\t\t\t\tu64 frame_size;\n\t\t\t\te = gf_media_parse_ivf_frame_header(bs, &frame_size, &pts);\n\t\t\t\tif (!e) gf_bs_skip_bytes(bs, frame_size);\n\t\t \t\tis_sap = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t}\n\t\tif (e)\n\t\t \tbreak;\n\n\t\tif (pts != GF_FILTER_NO_TS) {\n\t\t\tduration = pts;\n\t\t\tcur_dur = pts - last_cdur;\n\t\t} else {\n\t\t\tduration += ctx->cur_fps.den;\n\t\t\tcur_dur += ctx->cur_fps.den;\n\t\t}\n\t\tif (av1state.frame_state.key_frame)\n\t\t \tis_sap = GF_TRUE;\n\n\t\t//only index at I-frame start\n\t\tif (frame_start && is_sap && (cur_dur > ctx->index * ctx->cur_fps.num) ) {\n\t\t\tif (!ctx->index_alloc_size) ctx->index_alloc_size = 10;\n\t\t\telse if (ctx->index_alloc_size == ctx->index_size) ctx->index_alloc_size *= 2;\n\t\t\tctx->indexes = gf_realloc(ctx->indexes, sizeof(AV1Idx)*ctx->index_alloc_size);\n\t\t\tctx->indexes[ctx->index_size].pos = frame_start;\n\t\t\tctx->indexes[ctx->index_size].duration = (Double) duration;\n\t\t\tctx->indexes[ctx->index_size].duration /= ctx->cur_fps.num;\n\t\t\tctx->index_size ++;\n\t\t\tlast_cdur = cur_dur;\n\t\t\tcur_dur = 0;\n\t\t}\n\t}\n\trate = gf_bs_get_position(bs);\n\tgf_bs_del(bs);\n\tgf_fclose(stream);\n\tgf_odf_av1_cfg_del(av1state.config);\n\tgf_av1_reset_state(&av1state, GF_TRUE);\n\n\tif (!ctx->duration.num || (ctx->duration.num  * ctx->cur_fps.num != duration * ctx->duration.den)) {\n\t\tctx->duration.num = (s32) duration;\n\t\tctx->duration.den = ctx->cur_fps.num;\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\t\tif (duration && (!gf_sys_is_test_mode() || gf_opts_get_bool(\"temp\", \"force_indexing\"))) {\n\t\t\trate *= 8 * ctx->duration.den;\n\t\t\trate /= ctx->duration.num;\n\t\t\tctx->bitrate = (u32) rate;\n\t\t}\n\t}\n\n\t//currently not supported because of OBU size field rewrite - could work on some streams but we would\n\t//need to analyse all OBUs in the stream for that\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_FALSE) );\n}\n\n\nstatic Bool av1dmx_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i;\n\tu64 file_pos = 0;\n\tGF_FilterEvent fevt;\n\tGF_AV1DmxCtx *ctx = gf_filter_get_udta(filter);\n\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (!ctx->is_playing) {\n\t\t\tctx->is_playing = GF_TRUE;\n\t\t\tctx->cts = 0;\n\t\t}\n\t\tif (! ctx->is_file) {\n\t\t\tctx->buf_size = 0;\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->in_seek = GF_TRUE;\n\n\t\tif (ctx->start_range) {\n\n\t\t\tif (ctx->index<0) {\n\t\t\t\tctx->index = -ctx->index;\n\t\t\t\tctx->file_loaded = GF_FALSE;\n\t\t\t\tctx->duration.den = ctx->duration.num = 0;\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"[AV1/VP9Demx] Play request from %d, building index\\n\", ctx->start_range));\n\t\t\t\tav1dmx_check_dur(filter, ctx);\n\t\t\t}\n\n\t\t\tfor (i=1; i<ctx->index_size; i++) {\n\t\t\t\tif (ctx->indexes[i].duration>ctx->start_range) {\n\t\t\t\t\tctx->cts = (u64) (ctx->indexes[i-1].duration * ctx->cur_fps.num);\n\t\t\t\t\tfile_pos = ctx->indexes[i-1].pos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ctx->initial_play_done) {\n\t\t\tctx->initial_play_done = GF_TRUE;\n\t\t\t//seek will not change the current source state, don't send a seek\n\t\t\tif (!file_pos)\n\t\t\t\treturn GF_TRUE;\n\t\t}\n\t\tctx->buf_size = 0;\n\t\tif (!file_pos)\n\t\t\tfile_pos = ctx->file_hdr_size;\n\n\t\t//post a seek\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_SOURCE_SEEK, ctx->ipid);\n\t\tfevt.seek.start_offset = file_pos;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\t//don't cancel event\n\t\tctx->is_playing = GF_FALSE;\n\t\treturn GF_FALSE;\n\n\tcase GF_FEVT_SET_SPEED:\n\t\t//cancel event\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tbreak;\n\t}\n\t//by default don't cancel event - to rework once we have downloading in place\n\treturn GF_FALSE;\n}\n\nstatic GFINLINE void av1dmx_update_cts(GF_AV1DmxCtx *ctx)\n{\n\tassert(ctx->cur_fps.num);\n\tassert(ctx->cur_fps.den);\n\n\tif (ctx->timescale) {\n\t\tu64 inc = ctx->cur_fps.den;\n\t\tinc *= ctx->timescale;\n\t\tinc /= ctx->cur_fps.num;\n\t\tctx->cts += inc;\n\t} else {\n\t\tctx->cts += ctx->cur_fps.den;\n\t}\n}\n\nstatic void av1dmx_check_pid(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu8 *dsi;\n\tu32 dsi_size, crc;\n\n\t//no config or no config change\n\tif (ctx->is_av1 && !gf_list_count(ctx->state.frame_state.header_obus)) return;\n\n\tif (!ctx->opid) {\n\t\tctx->opid = gf_filter_pid_new(filter);\n\t\tav1dmx_check_dur(filter, ctx);\n\t}\n\tdsi = NULL;\n\tdsi_size = 0;\n\n\tif (ctx->vp_cfg) {\n\t\tgf_odf_vp_cfg_write(ctx->vp_cfg, &dsi, &dsi_size, ctx->vp_cfg->codec_initdata_size ? GF_TRUE : GF_FALSE);\n\t} else if (ctx->is_av1) {\n\t\t//first or config changed, compute dsi\n\t\twhile (gf_list_count(ctx->state.config->obu_array)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*) gf_list_pop_back(ctx->state.config->obu_array);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t\tdsi = NULL;\n\t\tdsi_size = 0;\n\t\twhile (gf_list_count(ctx->state.frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*) gf_list_get(ctx->state.frame_state.header_obus, 0);\n\t\t\tgf_list_add(ctx->state.config->obu_array, a);\n\t\t\tgf_list_rem(ctx->state.frame_state.header_obus, 0);\n\t\t}\n\t\tgf_odf_av1_cfg_write(ctx->state.config, &dsi, &dsi_size);\n\n\t\tif ((!ctx->fps.num || !ctx->fps.den) && ctx->state.tb_num && ctx->state.tb_den && ! ( (ctx->state.tb_num<=1) && (ctx->state.tb_den<=1) ) ) {\n\t\t\tctx->cur_fps.num = ctx->state.tb_num;\n\t\t\tctx->cur_fps.den = ctx->state.tb_den;\n\t\t}\n\n\t}\n\tcrc = gf_crc_32(dsi, dsi_size);\n\n\tif (crc == ctx->dsi_crc) {\n\t\tgf_free(dsi);\n\t\treturn;\n\t}\n\tctx->dsi_crc = crc;\n\n\t//copy properties at init or reconfig\n\tgf_filter_pid_copy_properties(ctx->opid, ctx->ipid);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL));\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(ctx->codecid));\n\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->cur_fps.num));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_FPS, & PROP_FRAC(ctx->cur_fps));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, & PROP_UINT(ctx->state.width));\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, & PROP_UINT(ctx->state.height));\n\n\tif (ctx->duration.num)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));\n\n\tif (ctx->bitrate) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));\n\t}\n\n\tif (dsi && dsi_size)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY(dsi, dsi_size));\n\n\tif (ctx->is_file && ctx->index) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t}\n\n\tif (ctx->is_av1) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, & PROP_UINT(ctx->state.color_primaries) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, & PROP_UINT(ctx->state.transfer_characteristics) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, & PROP_UINT(ctx->state.matrix_coefficients) );\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, & PROP_BOOL(ctx->state.color_range) );\n\t}\n}\n\nGF_Err av1dmx_parse_ivf(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tGF_Err e;\n\tu32 pck_size;\n\tu64 frame_size = 0, pts = GF_FILTER_NO_TS;\n\tGF_FilterPacket *pck;\n\tu64 pos, pos_ivf_hdr;\n\tu8 *output;\n\n\tpos_ivf_hdr = gf_bs_get_position(ctx->bs);\n\te = gf_media_parse_ivf_frame_header(ctx->bs, &frame_size, &pts);\n\tif (e) return e;\n\n\tpos = gf_bs_get_position(ctx->bs);\n\tif (gf_bs_available(ctx->bs) < frame_size) {\n\t\tgf_bs_seek(ctx->bs, pos_ivf_hdr);\n\t\treturn GF_EOS;\n\t}\n\n\tif (ctx->pts_from_file) {\n\t\tpts += ctx->cumulated_dur;\n\t\tif (ctx->last_pts && (ctx->last_pts>pts)) {\n\t\t\tpts -= ctx->cumulated_dur;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[IVF/AV1] Corrupted timestamp \"LLU\" less than previous timestamp \"LLU\", assuming concatenation\\n\", pts, ctx->last_pts));\n\t\t\tctx->cumulated_dur = ctx->last_pts + ctx->cur_fps.den;\n\t\t\tctx->cumulated_dur -= pts;\n\t\t\tpts = ctx->cumulated_dur;\n\t\t}\n\t\tctx->last_pts = pts;\n\t}\n\n\n\t//check pid state\n\tav1dmx_check_pid(filter, ctx);\n\n\tif (!ctx->opid) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!ctx->is_playing) {\n\t\tgf_bs_seek(ctx->bs, pos_ivf_hdr);\n\t\treturn GF_EOS;\n\t}\n\n\tpck_size = (u32)frame_size;\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (!pck) {\n\t\tgf_bs_seek(ctx->bs, pos_ivf_hdr);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tif (ctx->pts_from_file) {\n\t\tgf_filter_pck_set_cts(pck, pts);\n\t} else {\n\t\tgf_filter_pck_set_cts(pck, ctx->cts);\n\t}\n\n\tgf_bs_seek(ctx->bs, pos);\n\tgf_bs_read_data(ctx->bs, output, pck_size);\n\n\tif (output[0] & 0x80)\n\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\telse\n\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_NONE);\n\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\treturn GF_OK;\n}\n\nGF_Err av1dmx_parse_vp9(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tBool key_frame = GF_FALSE;\n\tu64 frame_size = 0, pts = 0;\n\tu64 pos, pos_ivf_hdr;\n\tu32 width = 0, height = 0, renderWidth, renderHeight;\n\tu32 num_frames_in_superframe = 0, superframe_index_size = 0, i = 0;\n\tu32 frame_sizes[VP9_MAX_FRAMES_IN_SUPERFRAME];\n\tu8 *output;\n\tGF_Err e;\n\n\tpos_ivf_hdr = gf_bs_get_position(ctx->bs);\n\te = gf_media_parse_ivf_frame_header(ctx->bs, &frame_size, &pts);\n\tif (e) return e;\n\n\tpos = gf_bs_get_position(ctx->bs);\n\tif (gf_bs_available(ctx->bs) < frame_size) {\n\t\tgf_bs_seek(ctx->bs, pos_ivf_hdr);\n\t\treturn GF_EOS;\n\t}\n\n\tif (ctx->pts_from_file) {\n\t\tpts += ctx->cumulated_dur;\n\t\tif (ctx->last_pts && (ctx->last_pts>pts)) {\n\t\t\tpts -= ctx->cumulated_dur;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[IVF/VP9] Corrupted timestamp \"LLU\" less than previous timestamp \"LLU\", assuming concatenation\\n\", pts, ctx->last_pts));\n\t\t\tctx->cumulated_dur = ctx->last_pts + ctx->cur_fps.den;\n\t\t\tctx->cumulated_dur -= pts;\n\t\t\tpts = ctx->cumulated_dur;\n\t\t}\n\t\tctx->last_pts = pts;\n\t}\n\n\t/*check if it is a superframe*/\n\te = gf_media_vp9_parse_superframe(ctx->bs, frame_size, &num_frames_in_superframe, frame_sizes, &superframe_index_size);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[VP9Dmx] Error parsing superframe structure\\n\"));\n\t\treturn e;\n\t}\n\n\tfor (i = 0; i < num_frames_in_superframe; ++i) {\n\t\tu64 pos2 = gf_bs_get_position(ctx->bs);\n\t\tif (gf_media_vp9_parse_sample(ctx->bs, ctx->vp_cfg, &key_frame, &width, &height, &renderWidth, &renderHeight) != GF_OK) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[VP9Dmx] Error parsing frame\\n\"));\n\t\t\treturn e;\n\t\t}\n\t\te = gf_bs_seek(ctx->bs, pos2 + frame_sizes[i]);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[VP9Dmx] Seek bad param (offset \"LLU\") (1)\", pos2 + frame_sizes[i]));\n\t\t\treturn e;\n\t\t}\n\t}\n\tif (gf_bs_get_position(ctx->bs) + superframe_index_size != pos + frame_size) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[VP9Dmx] Inconsistent IVF frame size of \"LLU\" bytes.\\n\", frame_size));\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"      Detected %d frames (+ %d bytes for the superframe index):\\n\", num_frames_in_superframe, superframe_index_size));\n\t\tfor (i = 0; i < num_frames_in_superframe; ++i) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"         superframe %d, size is %u bytes\\n\", i, frame_sizes[i]));\n\t\t}\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"\\n\"));\n\t}\n\te = gf_bs_seek(ctx->bs, pos + frame_size);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[VP9Dmx] Seek bad param (offset \"LLU\") (2)\", pos + frame_size));\n\t\treturn e;\n\t}\n\n\tu32 pck_size = (u32)(gf_bs_get_position(ctx->bs) - pos);\n\tassert(pck_size == frame_size);\n\n\t//check pid state\n\tav1dmx_check_pid(filter, ctx);\n\n\tif (!ctx->opid) {\n\t\treturn GF_OK;\n\t}\n\n\tif (!ctx->is_playing) {\n\t\tgf_bs_seek(ctx->bs, pos_ivf_hdr);\n\t\treturn GF_EOS;\n\t}\n\n\tGF_FilterPacket *pck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (!pck) {\n\t\tgf_bs_seek(ctx->bs, pos_ivf_hdr);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tif (ctx->pts_from_file) {\n\t\tgf_filter_pck_set_cts(pck, pts);\n\t} else {\n\t\tgf_filter_pck_set_cts(pck, ctx->cts);\n\t}\n\n\n\tif (key_frame) {\n\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\t}\n\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = (key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t\t//flags |= 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t\t//flags |= ctx->has_redundant ? 1 : 2;\n\t\tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\n\tgf_bs_seek(ctx->bs, pos);\n\tgf_bs_read_data(ctx->bs, output, pck_size);\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\treturn GF_OK;\n}\n\nstatic GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\n\tif (!ctx->opid)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n\t\treturn GF_OK;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t \t//flags |= ctx->has_redundant ? 1 : 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\n\treturn GF_OK;\n\n}\nGF_Err av1dmx_parse_av1(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tGF_Err e = GF_OK;\n\tu64 start;\n\n\tif (!ctx->is_playing) {\n\t\tctx->state.frame_state.is_first_frame = GF_TRUE;\n\t}\n\n\t/*we process each TU and extract only the necessary OBUs*/\n\tstart = gf_bs_get_position(ctx->bs);\n\tswitch (ctx->bsmode) {\n\tcase OBUs:\n\t\t//first frame loaded !\n\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs) && (ctx->state.obu_type == OBU_TEMPORAL_DELIMITER)) {\n\t\t\te = GF_OK;\n\t\t} else {\n\t\t\te = aom_av1_parse_temporal_unit_from_section5(ctx->bs, &ctx->state);\n\t\t}\n\t\tbreak;\n\tcase AnnexB:\n\t\t//first TU loaded !\n\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs)) {\n\t\t\te = GF_OK;\n\t\t} else {\n\t\t\te = aom_av1_parse_temporal_unit_from_annexb(ctx->bs, &ctx->state);\n\t\t\tif (e==GF_BUFFER_TOO_SMALL) {\n\t\t\t\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\t\t\tgf_bs_seek(ctx->bs, start);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IVF:\n\t\t//first frame loaded !\n\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs)) {\n\t\t\te = GF_OK;\n\t\t} else {\n\t\t\te = aom_av1_parse_temporal_unit_from_ivf(ctx->bs, &ctx->state);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\te = GF_NOT_SUPPORTED;\n\t}\n\n\t//check pid state\n\tav1dmx_check_pid(filter, ctx);\n\n\tif (e) return e;\n\n\n\tif (!ctx->opid) {\n\t\tif (ctx->state.obu_type != OBU_TEMPORAL_DELIMITER) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1Dmx] output pid not configured (no sequence header yet ?), skipping OBU\\n\"));\n\t\t}\n\t\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\treturn GF_OK;\n\t}\n\n\tif (!ctx->is_playing) {\n\t\t//don't reset state we would skip seq header obu in first frame\n\t\t//gf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\treturn GF_OK;\n\t}\n\n\treturn av1dmx_parse_flush_sample(filter, ctx);\n\n}\n\nGF_Err gf_bs_set_logger(GF_BitStream *bs, void (*on_bs_log)(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3), void *udta);\nstatic void av1dmx_bs_log(void *udta, const char *field_name, u32 nb_bits, u64 field_val, s32 idx1, s32 idx2, s32 idx3)\n{\n\tGF_AV1DmxCtx *ctx = (GF_AV1DmxCtx *) udta;\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\" %s\", field_name));\n\tif (idx1>=0) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"_%d\", idx1));\n\t\tif (idx2>=0) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"_%d\", idx2));\n\t\t\tif (idx3>=0) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"_%d\", idx3));\n\t\t\t}\n\t\t}\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"=\\\"\"LLD, field_val));\n\tif ((ctx->bsdbg==2) && ((s32) nb_bits > 1) )\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"(%u)\", nb_bits));\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"\\\" \"));\n}\n\nGF_Err av1dmx_process_buffer(GF_Filter *filter, GF_AV1DmxCtx *ctx, const char *data, u32 data_size, Bool is_copy)\n{\n\tu32 last_obu_end = 0;\n\tGF_Err e = GF_OK;\n\n\tif (!ctx->bs) ctx->bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ctx->bs, data, data_size);\n\n#ifndef GPAC_DISABLE_LOG\n\tif (ctx->bsdbg && gf_log_tool_level_on(GF_LOG_PARSER, GF_LOG_DEBUG))\n\t\tgf_bs_set_logger(ctx->bs, av1dmx_bs_log, ctx);\n#endif\n\n\t//check ivf vs obu vs annexB\n\te = av1dmx_check_format(filter, ctx, ctx->bs, &last_obu_end);\n\tif (e) return e;\n\n\twhile (gf_bs_available(ctx->bs)) {\n\n\t\tif (ctx->is_vp9) {\n\t\t\te = av1dmx_parse_vp9(filter, ctx);\n\t\t} else if (ctx->is_av1) {\n\t\t\te = av1dmx_parse_av1(filter, ctx);\n\t\t} else {\n\t\t\te = av1dmx_parse_ivf(filter, ctx);\n\t\t}\n\n\t\tif (e!=GF_EOS)\n\t\t\tlast_obu_end = (u32) gf_bs_get_position(ctx->bs);\n\n\t\tif (e) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!ctx->is_playing && ctx->opid)\n\t\t\tbreak;\n\t}\n\n\tif (is_copy && last_obu_end) {\n\t\tassert(ctx->buf_size>=last_obu_end);\n\t\tmemmove(ctx->buffer, ctx->buffer+last_obu_end, sizeof(char) * (ctx->buf_size-last_obu_end));\n\t\tctx->buf_size -= last_obu_end;\n\t}\n\tif (e==GF_EOS) return GF_OK;\n\tif (e==GF_BUFFER_TOO_SMALL) return GF_OK;\n\treturn e;\n}\n\nGF_Err av1dmx_process(GF_Filter *filter)\n{\n\tGF_Err e;\n\tGF_AV1DmxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tchar *data;\n\tu32 pck_size;\n\n\tif (ctx->bsmode == UNSUPPORTED) return GF_EOS;\n\n\t//always reparse duration\n\tif (!ctx->duration.num)\n\t\tav1dmx_check_dur(filter, ctx);\n\n\tif (!ctx->is_playing && ctx->opid)\n\t\treturn GF_OK;\n\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\tif (gf_filter_pid_is_eos(ctx->ipid)) {\n\t\t\t//flush\n\t\t\twhile (ctx->buf_size) {\n\t\t\t\tu32 buf_size = ctx->buf_size;\n\t\t\t\te = av1dmx_process_buffer(filter, ctx, ctx->buffer, ctx->buf_size, GF_TRUE);\n\t\t\t\tif (e) break;\n\t\t\t\tif (buf_size == ctx->buf_size) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs))\n\t\t\t\tav1dmx_parse_flush_sample(filter, ctx);\n\n\t\t\tctx->buf_size = 0;\n\t\t\tif (ctx->opid)\n\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\t\tctx->src_pck = NULL;\n\t\t\treturn GF_EOS;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (ctx->opid) {\n\t\tif (!ctx->is_playing || gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\n\tdata = (char *) gf_filter_pck_get_data(pck, &pck_size);\n\n\t//input pid sets some timescale - we flushed pending data , update cts\n\tif (ctx->timescale) {\n\t\tBool start, end;\n\t\tu64 cts;\n\n\t\te = GF_OK;\n\n\t\tgf_filter_pck_get_framing(pck, &start, &end);\n\t\t//middle or end of frame, reaggregation\n\t\tif (!start) {\n\t\t\tif (ctx->alloc_size < ctx->buf_size + pck_size) {\n\t\t\t\tctx->alloc_size = ctx->buf_size + pck_size;\n\t\t\t\tctx->buffer = gf_realloc(ctx->buffer, ctx->alloc_size);\n\t\t\t}\n\t\t\tmemcpy(ctx->buffer+ctx->buf_size, data, pck_size);\n\t\t\tctx->buf_size += pck_size;\n\n\t\t\t//end of frame, process av1\n\t\t\tif (end) {\n\t\t\t\te = av1dmx_process_buffer(filter, ctx, ctx->buffer, ctx->buf_size, GF_TRUE);\n\t\t\t}\n\t\t\tctx->buf_size=0;\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn e;\n\t\t}\n\t\t//flush of pending frame (might have lost something)\n\t\tif (ctx->buf_size) {\n\t\t\te = av1dmx_process_buffer(filter, ctx, ctx->buffer, ctx->buf_size, GF_TRUE);\n\t\t\tctx->buf_size = 0;\n\t\t\tif (e) return e;\n\t\t}\n\n\t\t//begining of a new frame\n\t\tcts = gf_filter_pck_get_cts(pck);\n\t\tif (cts != GF_FILTER_NO_TS)\n\t\t\tctx->cts = cts;\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\tctx->buf_size = 0;\n\n\t\tif (!end) {\n\t\t\tif (ctx->alloc_size < ctx->buf_size + pck_size) {\n\t\t\t\tctx->alloc_size = ctx->buf_size + pck_size;\n\t\t\t\tctx->buffer = gf_realloc(ctx->buffer, ctx->alloc_size);\n\t\t\t}\n\t\t\tmemcpy(ctx->buffer+ctx->buf_size, data, pck_size);\n\t\t\tctx->buf_size += pck_size;\n\t\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tassert(start && end);\n\t\t//process\n\t\te = av1dmx_process_buffer(filter, ctx, data, pck_size, GF_FALSE);\n\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\treturn e;\n\t}\n\n\t//not from framed stream, copy buffer\n\tif (ctx->alloc_size < ctx->buf_size + pck_size) {\n\t\tctx->alloc_size = ctx->buf_size + pck_size;\n\t\tctx->buffer = gf_realloc(ctx->buffer, ctx->alloc_size);\n\t}\n\tmemcpy(ctx->buffer+ctx->buf_size, data, pck_size);\n\tctx->buf_size += pck_size;\n\te = av1dmx_process_buffer(filter, ctx, ctx->buffer, ctx->buf_size, GF_TRUE);\n\tgf_filter_pid_drop_packet(ctx->ipid);\n\treturn e;\n}\n\nstatic void av1dmx_finalize(GF_Filter *filter)\n{\n\tGF_AV1DmxCtx *ctx = gf_filter_get_udta(filter);\n\tif (ctx->bs) gf_bs_del(ctx->bs);\n\tif (ctx->indexes) gf_free(ctx->indexes);\n\n\tgf_av1_reset_state(&ctx->state, GF_TRUE);\n\tif (ctx->state.config) gf_odf_av1_cfg_del(ctx->state.config);\n\tif (ctx->state.bs) gf_bs_del(ctx->state.bs);\n\tif (ctx->state.frame_obus) gf_free(ctx->state.frame_obus);\n\tif (ctx->buffer) gf_free(ctx->buffer);\n\n\tif (ctx->vp_cfg) gf_odf_vp_cfg_del(ctx->vp_cfg);\n}\n\nstatic const char * av1dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)\n{\n\tGF_BitStream *bs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\tBool res;\n\tu32 lt;\n\tconst char *mime = \"video/av1\";\n\tlt = gf_log_get_tool_level(GF_LOG_CODING);\n\tgf_log_set_tool_level(GF_LOG_CODING, GF_LOG_QUIET);\n\n\tres = gf_media_probe_ivf(bs);\n\tif (res) {\n\t\t*score = GF_FPROBE_SUPPORTED;\n\t\tmime = \"video/x-ivf\";\n\t} else {\n\t\tres = gf_media_aom_probe_annexb(bs);\n\t\tif (res) *score = GF_FPROBE_SUPPORTED;\n\t\telse {\n\t\t\tAV1State state;\n\t\t\tGF_Err e;\n\t\t\tu32 nb_units = 0;\n\n\t\t\tgf_av1_init_state(&state);\n\t\t\tstate.config = gf_odf_av1_cfg_new();\n\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\te = aom_av1_parse_temporal_unit_from_section5(bs, &state);\n\t\t\t\tif ((e==GF_OK) || (nb_units && (e==GF_BUFFER_TOO_SMALL) ) ) {\n\t\t\t\t\tif (!nb_units || gf_list_count(state.frame_state.header_obus) || gf_list_count(state.frame_state.frame_obus)) {\n\t\t\t\t\t\tnb_units++;\n\t\t\t\t\t\tif (e==GF_BUFFER_TOO_SMALL)\n\t\t\t\t\t\t\tnb_units++;\n\t\t\t\t\t} else\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_av1_reset_state(&state, GF_FALSE);\n\t\t\t\tif (nb_units>2) break;\n\t\t\t}\n\t\t\tgf_odf_av1_cfg_del(state.config);\n\t\t\tgf_av1_reset_state(&state, GF_TRUE);\n\t\t\tif (nb_units>2) {\n\t\t\t\tres = GF_TRUE;\n\t\t\t\t*score = GF_FPROBE_MAYBE_SUPPORTED;\n\t\t\t}\n\t\t}\n\t}\n\n\tgf_log_set_tool_level(GF_LOG_CODING, lt);\n\n\tgf_bs_del(bs);\n\tif (res) return mime;\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability AV1DmxCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"ivf|obu|av1b|av1\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"video/x-ivf|video/av1\"),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_AV1),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_VP8),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_VP9),\n\tCAP_UINT(GF_CAPS_OUTPUT_STATIC, GF_PROP_PID_CODECID, GF_CODECID_VP10),\n\tCAP_BOOL(GF_CAPS_OUTPUT_STATIC_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t{0},\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_AV1),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_VP8),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_VP9),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_CODECID, GF_CODECID_VP10),\n\tCAP_BOOL(GF_CAPS_INPUT,GF_PROP_PID_UNFRAMED, GF_TRUE),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_AV1DmxCtx, _n)\nstatic const GF_FilterArgs AV1DmxArgs[] =\n{\n\t{ OFFS(fps), \"import frame rate (0 default to FPS from bitstream or 25 Hz)\", GF_PROP_FRACTION, \"0/1000\", NULL, 0},\n\t{ OFFS(index), \"indexing window length. If 0, bitstream is not probed for duration. A negative value skips the indexing if the source file is larger than 100M (slows down importers) unless a play with start range > 0 is issued, otherwise uses the positive value\", GF_PROP_DOUBLE, \"-1.0\", NULL, 0},\n\n\t{ OFFS(importer), \"compatibility with old importer\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(deps), \"import samples dependencies information\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(bsdbg), \"debug NAL parsing in parser@debug logs\\n\"\n\t\t\"- off: not enabled\\n\"\n\t\t\"- on: enabled\\n\"\n\t\t\"- full: enable with number of bits dumped\", GF_PROP_UINT, \"off\", \"off|on|full\", GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\n\nGF_FilterRegister AV1DmxRegister = {\n\t.name = \"rfav1\",\n\tGF_FS_SET_DESCRIPTION(\"AV1/IVF/VP9 reframer\")\n\tGF_FS_SET_HELP(\"This filter parses AV1 OBU, AV1 AnnexB or IVF with AV1 or VP9 files/data and outputs corresponding visual PID and frames.\")\n\t.private_size = sizeof(GF_AV1DmxCtx),\n\t.args = AV1DmxArgs,\n\t.finalize = av1dmx_finalize,\n\tSETCAPS(AV1DmxCaps),\n\t.configure_pid = av1dmx_configure_pid,\n\t.process = av1dmx_process,\n\t.probe_data = av1dmx_probe_data,\n\t.process_event = av1dmx_process_event\n};\n\n\nconst GF_FilterRegister *av1dmx_register(GF_FilterSession *session)\n{\n\treturn &AV1DmxRegister;\n}\n\n#else\nconst GF_FilterRegister *av1dmx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_AV_PARSERS\n\n"], "filenames": ["src/filters/reframe_av1.c"], "buggy_code_start_loc": [741], "buggy_code_end_loc": [741], "fixing_code_start_loc": [742], "fixing_code_end_loc": [745], "type": "CWE-476", "message": "There is a Null Pointer Dereference in function filter_core/filter_pck.c:gf_filter_pck_new_alloc_internal in GPAC 1.0.1. The pid comes from function av1dmx_parse_flush_sample, the ctx.opid maybe NULL. The result is a crash in gf_filter_pck_new_alloc_internal.", "other": {"cve": {"id": "CVE-2021-30015", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-19T20:15:14.427", "lastModified": "2021-04-21T19:21:44.380", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is a Null Pointer Dereference in function filter_core/filter_pck.c:gf_filter_pck_new_alloc_internal in GPAC 1.0.1. The pid comes from function av1dmx_parse_flush_sample, the ctx.opid maybe NULL. The result is a crash in gf_filter_pck_new_alloc_internal."}, {"lang": "es", "value": "Se presenta una desreferencia del puntero null en la funci\u00f3n filter_core/filter_pck.c:gf_filter_pck_new_alloc_internal en GPAC versi\u00f3n 1.0.1.&#xa0;El pid proviene de la funci\u00f3n av1dmx_parse_flush_sample, el ctx.opid puede ser NULL.&#xa0;El resultado es un bloqueo en la funci\u00f3n gf_filter_pck_new_alloc_internal"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/13dad7d5ef74ca2e6fe4010f5b03eb12e9bbe0ec", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1719", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/13dad7d5ef74ca2e6fe4010f5b03eb12e9bbe0ec"}}