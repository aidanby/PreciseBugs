{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Update Data PDUs\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/collections.h>\n\n#include \"update.h\"\n#include \"surface.h\"\n#include \"message.h\"\n#include \"info.h\"\n#include \"window.h\"\n\n#include <freerdp/log.h>\n#include <freerdp/peer.h>\n#include <freerdp/codec/bitmap.h>\n\n#include \"../cache/pointer.h\"\n#include \"../cache/palette.h\"\n#include \"../cache/bitmap.h\"\n\n#define TAG FREERDP_TAG(\"core.update\")\n\nstatic const char* const UPDATE_TYPE_STRINGS[] = { \"Orders\", \"Bitmap\", \"Palette\", \"Synchronize\" };\n\nstatic const char* update_type_to_string(UINT16 updateType)\n{\n\tif (updateType >= ARRAYSIZE(UPDATE_TYPE_STRINGS))\n\t\treturn \"UNKNOWN\";\n\n\treturn UPDATE_TYPE_STRINGS[updateType];\n}\n\nstatic BOOL update_recv_orders(rdpUpdate* update, wStream* s)\n{\n\tUINT16 numberOrders;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 6\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek_UINT16(s);               /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, numberOrders); /* numberOrders (2 bytes) */\n\tStream_Seek_UINT16(s);               /* pad2OctetsB (2 bytes) */\n\n\twhile (numberOrders > 0)\n\t{\n\t\tif (!update_recv_order(update, s))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_recv_order() failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tnumberOrders--;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_write_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 64 + bitmapData->bitmapLength))\n\t\treturn FALSE;\n\n\tif (update->autoCalculateBitmapData)\n\t{\n\t\tbitmapData->flags = 0;\n\t\tbitmapData->cbCompFirstRowSize = 0;\n\n\t\tif (bitmapData->compressed)\n\t\t\tbitmapData->flags |= BITMAP_COMPRESSION;\n\n\t\tif (update->context->settings->NoBitmapCompressionHeader)\n\t\t{\n\t\t\tbitmapData->flags |= NO_BITMAP_COMPRESSION_HDR;\n\t\t\tbitmapData->cbCompMainBodySize = bitmapData->bitmapLength;\n\t\t}\n\t}\n\n\tStream_Write_UINT16(s, bitmapData->destLeft);\n\tStream_Write_UINT16(s, bitmapData->destTop);\n\tStream_Write_UINT16(s, bitmapData->destRight);\n\tStream_Write_UINT16(s, bitmapData->destBottom);\n\tStream_Write_UINT16(s, bitmapData->width);\n\tStream_Write_UINT16(s, bitmapData->height);\n\tStream_Write_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Write_UINT16(s, bitmapData->flags);\n\tStream_Write_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t}\n\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nBITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\" PRIu32 \"\", bitmapUpdate->number);\n\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT32 count = bitmapUpdate->number * 2;\n\t\tBITMAP_DATA* newdata =\n\t\t    (BITMAP_DATA*)realloc(bitmapUpdate->rectangles, sizeof(BITMAP_DATA) * count);\n\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\t/* rectangles */\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}\n\nstatic BOOL update_write_bitmap_update(rdpUpdate* update, wStream* s,\n                                       const BITMAP_UPDATE* bitmapUpdate)\n{\n\tint i;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, UPDATE_TYPE_BITMAP);   /* updateType */\n\tStream_Write_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\n\t/* rectangles */\n\tfor (i = 0; i < (int)bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_write_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nPALETTE_UPDATE* update_read_palette(rdpUpdate* update, wStream* s)\n{\n\tint i;\n\tPALETTE_ENTRY* entry;\n\tPALETTE_UPDATE* palette_update = calloc(1, sizeof(PALETTE_UPDATE));\n\n\tif (!palette_update)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Seek_UINT16(s);                         /* pad2Octets (2 bytes) */\n\tStream_Read_UINT32(s, palette_update->number); /* numberColors (4 bytes), must be set to 256 */\n\n\tif (palette_update->number > 256)\n\t\tpalette_update->number = 256;\n\n\tif (Stream_GetRemainingLength(s) < palette_update->number * 3)\n\t\tgoto fail;\n\n\t/* paletteEntries */\n\tfor (i = 0; i < (int)palette_update->number; i++)\n\t{\n\t\tentry = &palette_update->entries[i];\n\t\tStream_Read_UINT8(s, entry->red);\n\t\tStream_Read_UINT8(s, entry->green);\n\t\tStream_Read_UINT8(s, entry->blue);\n\t}\n\n\treturn palette_update;\nfail:\n\tfree_palette_update(update->context, palette_update);\n\treturn NULL;\n}\n\nstatic void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\t                       /**\n\t                        * The Synchronize Update is an artifact from the\n\t                        * T.128 protocol and should be ignored.\n\t                        */\n}\n\nstatic BOOL update_read_play_sound(wStream* s, PLAY_SOUND_UPDATE* play_sound)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, play_sound->duration);  /* duration (4 bytes) */\n\tStream_Read_UINT32(s, play_sound->frequency); /* frequency (4 bytes) */\n\treturn TRUE;\n}\n\nBOOL update_recv_play_sound(rdpUpdate* update, wStream* s)\n{\n\tPLAY_SOUND_UPDATE play_sound;\n\n\tif (!update_read_play_sound(s, &play_sound))\n\t\treturn FALSE;\n\n\treturn IFCALLRESULT(FALSE, update->PlaySound, update->context, &play_sound);\n}\n\nPOINTER_POSITION_UPDATE* update_read_pointer_position(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_POSITION_UPDATE* pointer_position = calloc(1, sizeof(POINTER_POSITION_UPDATE));\n\n\tif (!pointer_position)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_position->xPos); /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_position->yPos); /* yPos (2 bytes) */\n\treturn pointer_position;\nfail:\n\tfree_pointer_position_update(update->context, pointer_position);\n\treturn NULL;\n}\n\nPOINTER_SYSTEM_UPDATE* update_read_pointer_system(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_SYSTEM_UPDATE* pointer_system = calloc(1, sizeof(POINTER_SYSTEM_UPDATE));\n\n\tif (!pointer_system)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT32(s, pointer_system->type); /* systemPointerType (4 bytes) */\n\treturn pointer_system;\nfail:\n\tfree_pointer_system_update(update->context, pointer_system);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_color(wStream* s, POINTER_COLOR_UPDATE* pointer_color, BYTE xorBpp)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->xPos);       /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->yPos);       /* yPos (2 bytes) */\n\t/**\n\t *  As stated in 2.2.9.1.1.4.4 Color Pointer Update:\n\t *  The maximum allowed pointer width/height is 96 pixels if the client indicated support\n\t *  for large pointers by setting the LARGE_POINTER_FLAG (0x00000001) in the Large\n\t *  Pointer Capability Set (section 2.2.7.2.7). If the LARGE_POINTER_FLAG was not\n\t *  set, the maximum allowed pointer width/height is 32 pixels.\n\t *\n\t *  So we check for a maximum of 96 for CVE-2014-0250.\n\t */\n\tStream_Read_UINT16(s, pointer_color->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->height); /* height (2 bytes) */\n\n\tif ((pointer_color->width > 96) || (pointer_color->height > 96))\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->lengthAndMask); /* lengthAndMask (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->lengthXorMask); /* lengthXorMask (2 bytes) */\n\n\t/**\n\t * There does not seem to be any documentation on why\n\t * xPos / yPos can be larger than width / height\n\t * so it is missing in documentation or a bug in implementation\n\t * 2.2.9.1.1.4.4 Color Pointer Update (TS_COLORPOINTERATTRIBUTE)\n\t */\n\tif (pointer_color->xPos >= pointer_color->width)\n\t\tpointer_color->xPos = 0;\n\n\tif (pointer_color->yPos >= pointer_color->height)\n\t\tpointer_color->yPos = 0;\n\n\tif (pointer_color->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will\n\t\t * consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to\n\t\t * the next even number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + xorBpp * pointer_color->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->width, pointer_color->height, pointer_color->lengthXorMask,\n\t\t\t         scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->xorMaskData = newMask;\n\t\tStream_Read(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\t}\n\n\tif (pointer_color->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will\n\t\t * consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even\n\t\t * number of bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer_color->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->lengthAndMask, scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->andMaskData = newMask;\n\t\tStream_Read(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_COLOR_UPDATE* update_read_pointer_color(rdpUpdate* update, wStream* s, BYTE xorBpp)\n{\n\tPOINTER_COLOR_UPDATE* pointer_color = calloc(1, sizeof(POINTER_COLOR_UPDATE));\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_color(s, pointer_color, xorBpp))\n\t\tgoto fail;\n\n\treturn pointer_color;\nfail:\n\tfree_pointer_color_update(update->context, pointer_color);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_large(wStream* s, POINTER_LARGE_UPDATE* pointer)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->xorBpp);\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer->hotSpotX);   /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer->hotSpotY);   /* yPos (2 bytes) */\n\n\tStream_Read_UINT16(s, pointer->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer->height); /* height (2 bytes) */\n\n\tif ((pointer->width > 384) || (pointer->height > 384))\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->lengthAndMask); /* lengthAndMask (2 bytes) */\n\tStream_Read_UINT16(s, pointer->lengthXorMask); /* lengthXorMask (2 bytes) */\n\n\tif (pointer->hotSpotX >= pointer->width)\n\t\tpointer->hotSpotX = 0;\n\n\tif (pointer->hotSpotY >= pointer->height)\n\t\tpointer->hotSpotY = 0;\n\n\tif (pointer->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will\n\t\t * consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to\n\t\t * the next even number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + pointer->xorBpp * pointer->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer->height != pointer->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->width, pointer->height, pointer->lengthXorMask,\n\t\t\t         scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer->xorMaskData, pointer->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer->xorMaskData = newMask;\n\t\tStream_Read(s, pointer->xorMaskData, pointer->lengthXorMask);\n\t}\n\n\tif (pointer->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will\n\t\t * consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even\n\t\t * number of bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer->height != pointer->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->lengthAndMask, scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer->andMaskData, pointer->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer->andMaskData = newMask;\n\t\tStream_Read(s, pointer->andMaskData, pointer->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_LARGE_UPDATE* update_read_pointer_large(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_LARGE_UPDATE* pointer = calloc(1, sizeof(POINTER_LARGE_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_large(s, pointer))\n\t\tgoto fail;\n\n\treturn pointer;\nfail:\n\tfree_pointer_large_update(update->context, pointer);\n\treturn NULL;\n}\n\nPOINTER_NEW_UPDATE* update_read_pointer_new(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_NEW_UPDATE* pointer_new = calloc(1, sizeof(POINTER_NEW_UPDATE));\n\n\tif (!pointer_new)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\n\tif ((pointer_new->xorBpp < 1) || (pointer_new->xorBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid xorBpp %\" PRIu32 \"\", pointer_new->xorBpp);\n\t\tgoto fail;\n\t}\n\n\tif (!_update_read_pointer_color(s, &pointer_new->colorPtrAttr,\n\t                                pointer_new->xorBpp)) /* colorPtrAttr */\n\t\tgoto fail;\n\n\treturn pointer_new;\nfail:\n\tfree_pointer_new_update(update->context, pointer_new);\n\treturn NULL;\n}\n\nPOINTER_CACHED_UPDATE* update_read_pointer_cached(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_CACHED_UPDATE* pointer = calloc(1, sizeof(POINTER_CACHED_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\treturn pointer;\nfail:\n\tfree_pointer_cached_update(update->context, pointer);\n\treturn NULL;\n}\n\nBOOL update_recv_pointer(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 messageType;\n\trdpContext* context = update->context;\n\trdpPointerUpdate* pointer = update->pointer;\n\n\tif (Stream_GetRemainingLength(s) < 2 + 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, messageType); /* messageType (2 bytes) */\n\tStream_Seek_UINT16(s);              /* pad2Octets (2 bytes) */\n\n\tswitch (messageType)\n\t{\n\t\tcase PTR_MSG_TYPE_POSITION:\n\t\t{\n\t\t\tPOINTER_POSITION_UPDATE* pointer_position = update_read_pointer_position(update, s);\n\n\t\t\tif (pointer_position)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerPosition, context, pointer_position);\n\t\t\t\tfree_pointer_position_update(context, pointer_position);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_SYSTEM:\n\t\t{\n\t\t\tPOINTER_SYSTEM_UPDATE* pointer_system = update_read_pointer_system(update, s);\n\n\t\t\tif (pointer_system)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerSystem, context, pointer_system);\n\t\t\t\tfree_pointer_system_update(context, pointer_system);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_COLOR:\n\t\t{\n\t\t\tPOINTER_COLOR_UPDATE* pointer_color = update_read_pointer_color(update, s, 24);\n\n\t\t\tif (pointer_color)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerColor, context, pointer_color);\n\t\t\t\tfree_pointer_color_update(context, pointer_color);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER_LARGE:\n\t\t{\n\t\t\tPOINTER_LARGE_UPDATE* pointer_large = update_read_pointer_large(update, s);\n\n\t\t\tif (pointer_large)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerLarge, context, pointer_large);\n\t\t\t\tfree_pointer_large_update(context, pointer_large);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER:\n\t\t{\n\t\t\tPOINTER_NEW_UPDATE* pointer_new = update_read_pointer_new(update, s);\n\n\t\t\tif (pointer_new)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerNew, context, pointer_new);\n\t\t\t\tfree_pointer_new_update(context, pointer_new);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_CACHED:\n\t\t{\n\t\t\tPOINTER_CACHED_UPDATE* pointer_cached = update_read_pointer_cached(update, s);\n\n\t\t\tif (pointer_cached)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerCached, context, pointer_cached);\n\t\t\t\tfree_pointer_cached_update(context, pointer_cached);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nBOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nvoid update_reset_state(rdpUpdate* update)\n{\n\trdpPrimaryUpdate* primary = update->primary;\n\trdpAltSecUpdate* altsec = update->altsec;\n\n\tif (primary->fast_glyph.glyphData.aj)\n\t{\n\t\tfree(primary->fast_glyph.glyphData.aj);\n\t\tprimary->fast_glyph.glyphData.aj = NULL;\n\t}\n\n\tZeroMemory(&primary->order_info, sizeof(ORDER_INFO));\n\tZeroMemory(&primary->dstblt, sizeof(DSTBLT_ORDER));\n\tZeroMemory(&primary->patblt, sizeof(PATBLT_ORDER));\n\tZeroMemory(&primary->scrblt, sizeof(SCRBLT_ORDER));\n\tZeroMemory(&primary->opaque_rect, sizeof(OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->draw_nine_grid, sizeof(DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->multi_dstblt, sizeof(MULTI_DSTBLT_ORDER));\n\tZeroMemory(&primary->multi_patblt, sizeof(MULTI_PATBLT_ORDER));\n\tZeroMemory(&primary->multi_scrblt, sizeof(MULTI_SCRBLT_ORDER));\n\tZeroMemory(&primary->multi_opaque_rect, sizeof(MULTI_OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->multi_draw_nine_grid, sizeof(MULTI_DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->line_to, sizeof(LINE_TO_ORDER));\n\tZeroMemory(&primary->polyline, sizeof(POLYLINE_ORDER));\n\tZeroMemory(&primary->memblt, sizeof(MEMBLT_ORDER));\n\tZeroMemory(&primary->mem3blt, sizeof(MEM3BLT_ORDER));\n\tZeroMemory(&primary->save_bitmap, sizeof(SAVE_BITMAP_ORDER));\n\tZeroMemory(&primary->glyph_index, sizeof(GLYPH_INDEX_ORDER));\n\tZeroMemory(&primary->fast_index, sizeof(FAST_INDEX_ORDER));\n\tZeroMemory(&primary->fast_glyph, sizeof(FAST_GLYPH_ORDER));\n\tZeroMemory(&primary->polygon_sc, sizeof(POLYGON_SC_ORDER));\n\tZeroMemory(&primary->polygon_cb, sizeof(POLYGON_CB_ORDER));\n\tZeroMemory(&primary->ellipse_sc, sizeof(ELLIPSE_SC_ORDER));\n\tZeroMemory(&primary->ellipse_cb, sizeof(ELLIPSE_CB_ORDER));\n\tprimary->order_info.orderType = ORDER_TYPE_PATBLT;\n\n\tif (!update->initialState)\n\t{\n\t\taltsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\t\tIFCALL(altsec->SwitchSurface, update->context, &(altsec->switch_surface));\n\t}\n}\n\nBOOL update_post_connect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tif (!(update->proxy = update_message_proxy_new(update)))\n\t\t\treturn FALSE;\n\n\tupdate->altsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\tIFCALL(update->altsec->SwitchSurface, update->context, &(update->altsec->switch_surface));\n\tupdate->initialState = FALSE;\n\treturn TRUE;\n}\n\nvoid update_post_disconnect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tupdate_message_proxy_free(update->proxy);\n\n\tupdate->initialState = TRUE;\n}\n\nstatic BOOL _update_begin_paint(rdpContext* context)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\n\tif (update->us)\n\t{\n\t\tif (!update_end_paint(update))\n\t\t\treturn FALSE;\n\t}\n\n\ts = fastpath_update_pdu_init_new(context->rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_SealLength(s);\n\tStream_Seek(s, 2); /* numberOrders (2 bytes) */\n\tupdate->combineUpdates = TRUE;\n\tupdate->numberOrders = 0;\n\tupdate->us = s;\n\treturn TRUE;\n}\n\nstatic BOOL _update_end_paint(rdpContext* context)\n{\n\twStream* s;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\n\tif (!update->us)\n\t\treturn FALSE;\n\n\ts = update->us;\n\theaderLength = Stream_Length(s);\n\tStream_SealLength(s);\n\tStream_SetPosition(s, headerLength);\n\tStream_Write_UINT16(s, update->numberOrders); /* numberOrders (2 bytes) */\n\tStream_SetPosition(s, Stream_Length(s));\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tWLog_DBG(TAG, \"sending %\" PRIu16 \" orders\", update->numberOrders);\n\t\tfastpath_send_update_pdu(context->rdp->fastpath, FASTPATH_UPDATETYPE_ORDERS, s, FALSE);\n\t}\n\n\tupdate->combineUpdates = FALSE;\n\tupdate->numberOrders = 0;\n\tupdate->us = NULL;\n\tStream_Free(s, TRUE);\n\treturn TRUE;\n}\n\nstatic void update_flush(rdpContext* context)\n{\n\trdpUpdate* update = context->update;\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tupdate_end_paint(update);\n\t\tupdate_begin_paint(update);\n\t}\n}\n\nstatic void update_force_flush(rdpContext* context)\n{\n\tupdate_flush(context);\n}\n\nstatic BOOL update_check_flush(rdpContext* context, int size)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\ts = update->us;\n\n\tif (!update->us)\n\t{\n\t\tupdate_begin_paint(update);\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetPosition(s) + size + 64 >= 0x3FFF)\n\t{\n\t\tupdate_flush(context);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic BOOL update_set_bounds(rdpContext* context, const rdpBounds* bounds)\n{\n\trdpUpdate* update = context->update;\n\tCopyMemory(&update->previousBounds, &update->currentBounds, sizeof(rdpBounds));\n\n\tif (!bounds)\n\t\tZeroMemory(&update->currentBounds, sizeof(rdpBounds));\n\telse\n\t\tCopyMemory(&update->currentBounds, bounds, sizeof(rdpBounds));\n\n\treturn TRUE;\n}\n\nstatic BOOL update_bounds_is_null(rdpBounds* bounds)\n{\n\tif ((bounds->left == 0) && (bounds->top == 0) && (bounds->right == 0) && (bounds->bottom == 0))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic BOOL update_bounds_equals(rdpBounds* bounds1, rdpBounds* bounds2)\n{\n\tif ((bounds1->left == bounds2->left) && (bounds1->top == bounds2->top) &&\n\t    (bounds1->right == bounds2->right) && (bounds1->bottom == bounds2->bottom))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic int update_prepare_bounds(rdpContext* context, ORDER_INFO* orderInfo)\n{\n\tint length = 0;\n\trdpUpdate* update = context->update;\n\torderInfo->boundsFlags = 0;\n\n\tif (update_bounds_is_null(&update->currentBounds))\n\t\treturn 0;\n\n\torderInfo->controlFlags |= ORDER_BOUNDS;\n\n\tif (update_bounds_equals(&update->previousBounds, &update->currentBounds))\n\t{\n\t\torderInfo->controlFlags |= ORDER_ZERO_BOUNDS_DELTAS;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tlength += 1;\n\n\t\tif (update->previousBounds.left != update->currentBounds.left)\n\t\t{\n\t\t\torderInfo->bounds.left = update->currentBounds.left;\n\t\t\torderInfo->boundsFlags |= BOUND_LEFT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.top != update->currentBounds.top)\n\t\t{\n\t\t\torderInfo->bounds.top = update->currentBounds.top;\n\t\t\torderInfo->boundsFlags |= BOUND_TOP;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.right != update->currentBounds.right)\n\t\t{\n\t\t\torderInfo->bounds.right = update->currentBounds.right;\n\t\t\torderInfo->boundsFlags |= BOUND_RIGHT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.bottom != update->currentBounds.bottom)\n\t\t{\n\t\t\torderInfo->bounds.bottom = update->currentBounds.bottom;\n\t\t\torderInfo->boundsFlags |= BOUND_BOTTOM;\n\t\t\tlength += 2;\n\t\t}\n\t}\n\n\treturn length;\n}\n\nstatic int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}\n\nstatic int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); /* controlFlags (1 byte) */\n\n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}\n\nstatic void update_write_refresh_rect(wStream* s, BYTE count, const RECTANGLE_16* areas)\n{\n\tint i;\n\tStream_Write_UINT8(s, count); /* numberOfAreas (1 byte) */\n\tStream_Seek(s, 3);            /* pad3Octets (3 bytes) */\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tStream_Write_UINT16(s, areas[i].left);   /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].top);    /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].right);  /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_refresh_rect(rdpContext* context, BYTE count, const RECTANGLE_16* areas)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->RefreshRect)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_refresh_rect(s, count, areas);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_REFRESH_RECT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_write_suppress_output(wStream* s, BYTE allow, const RECTANGLE_16* area)\n{\n\tStream_Write_UINT8(s, allow); /* allowDisplayUpdates (1 byte) */\n\t/* Use zeros for padding (like mstsc) for compatibility with legacy servers */\n\tStream_Zero(s, 3); /* pad3Octets (3 bytes) */\n\n\tif (allow > 0)\n\t{\n\t\tStream_Write_UINT16(s, area->left);   /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, area->top);    /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, area->right);  /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, area->bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_suppress_output(rdpContext* context, BYTE allow, const RECTANGLE_16* area)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->SuppressOutput)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_suppress_output(s, allow, area);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SUPPRESS_OUTPUT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_surface_command(rdpContext* context, wStream* s)\n{\n\twStream* update;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\tupdate = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(update, Stream_GetPosition(s)))\n\t{\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\n\n\tStream_Write(update, Stream_Buffer(s), Stream_GetPosition(s));\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, update, FALSE);\nout:\n\tStream_Release(update);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_bits(rdpContext* context,\n                                     const SURFACE_BITS_COMMAND* surfaceBitsCommand)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_surface_bits(s, surfaceBitsCommand))\n\t\tgoto out_fail;\n\n\tif (!fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                              surfaceBitsCommand->skipCompression))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_marker(rdpContext* context,\n                                             const SURFACE_FRAME_MARKER* surfaceFrameMarker)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_frame_marker(s, surfaceFrameMarker->frameAction,\n\t                                       surfaceFrameMarker->frameId) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s, FALSE))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_bits(rdpContext* context, const SURFACE_BITS_COMMAND* cmd,\n                                           BOOL first, BOOL last, UINT32 frameId)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (first)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_BEGIN, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!update_write_surfcmd_surface_bits(s, cmd))\n\t\tgoto out_fail;\n\n\tif (last)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_END, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                               cmd->skipCompression);\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_frame_acknowledge(rdpContext* context, UINT32 frameId)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->ReceivedCapabilities[CAPSET_TYPE_FRAME_ACKNOWLEDGE])\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, frameId);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_FRAME_ACKNOWLEDGE, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_synchronize(rdpContext* context)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Zero(s, 2); /* pad2Octets (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SYNCHRONIZE, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_desktop_resize(rdpContext* context)\n{\n\treturn rdp_server_reactivate(context->rdp);\n}\n\nstatic BOOL update_send_bitmap_update(rdpContext* context, const BITMAP_UPDATE* bitmapUpdate)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\trdpUpdate* update = context->update;\n\tBOOL ret = TRUE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_bitmap_update(update, s, bitmapUpdate) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_BITMAP, s,\n\t                              bitmapUpdate->skipCompression))\n\t{\n\t\tret = FALSE;\n\t\tgoto out_fail;\n\t}\n\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_play_sound(rdpContext* context, const PLAY_SOUND_UPDATE* play_sound)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\n\tif (!rdp->settings->ReceivedCapabilities[CAPSET_TYPE_SOUND])\n\t{\n\t\treturn TRUE;\n\t}\n\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, play_sound->duration);\n\tStream_Write_UINT32(s, play_sound->frequency);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_PLAY_SOUND, rdp->mcs->userId);\n}\n\n/**\n * Primary Drawing Orders\n */\n\nstatic BOOL update_send_dstblt(rdpContext* context, const DSTBLT_ORDER* dstblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_DSTBLT);\n\tinf = update_approximate_dstblt_order(&orderInfo, dstblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_dstblt_order(s, &orderInfo, dstblt))\n\t\treturn FALSE;\n\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_patblt(rdpContext* context, PATBLT_ORDER* patblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_PATBLT);\n\tupdate_check_flush(context, headerLength + update_approximate_patblt_order(&orderInfo, patblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_patblt_order(s, &orderInfo, patblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_scrblt(rdpContext* context, const SCRBLT_ORDER* scrblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_SCRBLT);\n\tinf = update_approximate_scrblt_order(&orderInfo, scrblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn TRUE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_scrblt_order(s, &orderInfo, scrblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_opaque_rect(rdpContext* context, const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_OPAQUE_RECT);\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_opaque_rect_order(&orderInfo, opaque_rect));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_opaque_rect_order(s, &orderInfo, opaque_rect);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_line_to(rdpContext* context, const LINE_TO_ORDER* line_to)\n{\n\twStream* s;\n\tint offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_LINE_TO);\n\tinf = update_approximate_line_to_order(&orderInfo, line_to);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_line_to_order(s, &orderInfo, line_to);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_memblt(rdpContext* context, MEMBLT_ORDER* memblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_MEMBLT);\n\tupdate_check_flush(context, headerLength + update_approximate_memblt_order(&orderInfo, memblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_memblt_order(s, &orderInfo, memblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_glyph_index(rdpContext* context, GLYPH_INDEX_ORDER* glyph_index)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tint inf;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_GLYPH_INDEX);\n\tinf = update_approximate_glyph_index_order(&orderInfo, glyph_index);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_glyph_index_order(s, &orderInfo, glyph_index);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/*\n * Secondary Drawing Orders\n */\n\nstatic BOOL update_send_cache_bitmap(rdpContext* context, const CACHE_BITMAP_ORDER* cache_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tint inf;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap->compressed ? ORDER_TYPE_CACHE_BITMAP_COMPRESSED\n\t                                     : ORDER_TYPE_BITMAP_UNCOMPRESSED;\n\tinf =\n\t    update_approximate_cache_bitmap_order(cache_bitmap, cache_bitmap->compressed, &extraFlags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_order(s, cache_bitmap, cache_bitmap->compressed, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v2(rdpContext* context, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap_v2->compressed ? ORDER_TYPE_BITMAP_COMPRESSED_V2\n\t                                        : ORDER_TYPE_BITMAP_UNCOMPRESSED_V2;\n\n\tif (context->settings->NoBitmapCompressionHeader)\n\t\tcache_bitmap_v2->flags |= CBR2_NO_BITMAP_COMPRESSION_HDR;\n\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_cache_bitmap_v2_order(\n\t                                    cache_bitmap_v2, cache_bitmap_v2->compressed, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v2_order(s, cache_bitmap_v2, cache_bitmap_v2->compressed,\n\t                                        &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v3(rdpContext* context, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = ORDER_TYPE_BITMAP_COMPRESSED_V3;\n\tupdate_check_flush(context, headerLength + update_approximate_cache_bitmap_v3_order(\n\t                                               cache_bitmap_v3, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v3_order(s, cache_bitmap_v3, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_color_table(rdpContext* context,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_color_table_order(cache_color_table, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_color_table_order(s, cache_color_table, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_COLOR_TABLE);     /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph(rdpContext* context, const CACHE_GLYPH_ORDER* cache_glyph)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_order(s, cache_glyph, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph_v2(rdpContext* context,\n                                       const CACHE_GLYPH_V2_ORDER* cache_glyph_v2)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_v2_order(s, cache_glyph_v2, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_brush(rdpContext* context, const CACHE_BRUSH_ORDER* cache_brush)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_brush_order(cache_brush, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_brush_order(s, cache_brush, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_BRUSH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/**\n * Alternate Secondary Drawing Orders\n */\n\nstatic BOOL update_send_create_offscreen_bitmap_order(\n    rdpContext* context, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_CREATE_OFFSCREEN_BITMAP;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_create_offscreen_bitmap_order(s, create_offscreen_bitmap))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_switch_surface_order(rdpContext* context,\n                                             const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update;\n\n\tif (!context || !switch_surface || !context->update)\n\t\treturn FALSE;\n\n\tupdate = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_SWITCH_SURFACE;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_switch_surface_order(switch_surface);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_switch_surface_order(s, switch_surface))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_system(rdpContext* context,\n                                       const POINTER_SYSTEM_UPDATE* pointer_system)\n{\n\twStream* s;\n\tBYTE updateCode;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (pointer_system->type == SYSPTR_NULL)\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_NULL;\n\telse\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_DEFAULT;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, updateCode, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_position(rdpContext* context,\n                                         const POINTER_POSITION_UPDATE* pointerPosition)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointerPosition->xPos); /* xPos (2 bytes) */\n\tStream_Write_UINT16(s, pointerPosition->yPos); /* yPos (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_PTR_POSITION, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_color(wStream* s, const POINTER_COLOR_UPDATE* pointer_color)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 32 + pointer_color->lengthAndMask +\n\t                                           pointer_color->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_color->cacheIndex);\n\tStream_Write_UINT16(s, pointer_color->xPos);\n\tStream_Write_UINT16(s, pointer_color->yPos);\n\tStream_Write_UINT16(s, pointer_color->width);\n\tStream_Write_UINT16(s, pointer_color->height);\n\tStream_Write_UINT16(s, pointer_color->lengthAndMask);\n\tStream_Write_UINT16(s, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthXorMask > 0)\n\t\tStream_Write(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthAndMask > 0)\n\t\tStream_Write(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_color(rdpContext* context,\n                                      const POINTER_COLOR_UPDATE* pointer_color)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_color(s, pointer_color))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_COLOR, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_large(wStream* s, const POINTER_LARGE_UPDATE* pointer)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 32 + pointer->lengthAndMask + pointer->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer->xorBpp);\n\tStream_Write_UINT16(s, pointer->cacheIndex);\n\tStream_Write_UINT16(s, pointer->hotSpotX);\n\tStream_Write_UINT16(s, pointer->hotSpotY);\n\tStream_Write_UINT16(s, pointer->width);\n\tStream_Write_UINT16(s, pointer->height);\n\tStream_Write_UINT32(s, pointer->lengthAndMask);\n\tStream_Write_UINT32(s, pointer->lengthXorMask);\n\tStream_Write(s, pointer->xorMaskData, pointer->lengthXorMask);\n\tStream_Write(s, pointer->andMaskData, pointer->lengthAndMask);\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_large(rdpContext* context, const POINTER_LARGE_UPDATE* pointer)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_large(s, pointer))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_LARGE_POINTER, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_new(rdpContext* context, const POINTER_NEW_UPDATE* pointer_new)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\tupdate_write_pointer_color(s, &pointer_new->colorPtrAttr);\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_POINTER, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_cached(rdpContext* context,\n                                       const POINTER_CACHED_UPDATE* pointer_cached)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_cached->cacheIndex); /* cacheIndex (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_CACHED, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nBOOL update_read_refresh_rect(rdpUpdate* update, wStream* s)\n{\n\tint index;\n\tBYTE numberOfAreas;\n\tRECTANGLE_16* areas;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, numberOfAreas);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (Stream_GetRemainingLength(s) < ((size_t)numberOfAreas * 4 * 2))\n\t\treturn FALSE;\n\n\tareas = (RECTANGLE_16*)calloc(numberOfAreas, sizeof(RECTANGLE_16));\n\n\tif (!areas)\n\t\treturn FALSE;\n\n\tfor (index = 0; index < numberOfAreas; index++)\n\t{\n\t\tStream_Read_UINT16(s, areas[index].left);\n\t\tStream_Read_UINT16(s, areas[index].top);\n\t\tStream_Read_UINT16(s, areas[index].right);\n\t\tStream_Read_UINT16(s, areas[index].bottom);\n\t}\n\n\tif (update->context->settings->RefreshRect)\n\t\tIFCALL(update->RefreshRect, update->context, numberOfAreas, areas);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring refresh rect request from client\");\n\n\tfree(areas);\n\treturn TRUE;\n}\n\nBOOL update_read_suppress_output(rdpUpdate* update, wStream* s)\n{\n\tRECTANGLE_16* prect = NULL;\n\tRECTANGLE_16 rect = { 0 };\n\tBYTE allowDisplayUpdates;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, allowDisplayUpdates);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (allowDisplayUpdates > 0)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < sizeof(RECTANGLE_16))\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT16(s, rect.left);\n\t\tStream_Read_UINT16(s, rect.top);\n\t\tStream_Read_UINT16(s, rect.right);\n\t\tStream_Read_UINT16(s, rect.bottom);\n\n\t\tprect = &rect;\n\t}\n\n\tif (update->context->settings->SuppressOutput)\n\t\tIFCALL(update->SuppressOutput, update->context, allowDisplayUpdates, prect);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring suppress output request from client\");\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_set_keyboard_indicators(rdpContext* context, UINT16 led_flags)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 0);         /* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.1.1 */\n\tStream_Write_UINT16(s, led_flags); /* ledFlags (2 bytes) */\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS, rdp->mcs->userId);\n}\n\nstatic BOOL update_send_set_keyboard_ime_status(rdpContext* context, UINT16 imeId, UINT32 imeState,\n                                                UINT32 imeConvMode)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.2.1 */\n\tStream_Write_UINT16(s, imeId);\n\tStream_Write_UINT32(s, imeState);\n\tStream_Write_UINT32(s, imeConvMode);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS, rdp->mcs->userId);\n}\n\nstatic UINT16 update_calculate_new_or_existing_window(const WINDOW_ORDER_INFO* orderInfo,\n                                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\tUINT16 orderSize = 11;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t\torderSize += 2 + stateOrder->titleInfo.length;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t\torderSize += 2 + stateOrder->numWindowRects * sizeof(RECTANGLE_16);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t\torderSize += 2 + stateOrder->numVisibilityRects * sizeof(RECTANGLE_16);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t\torderSize += 2 + stateOrder->OverlayDescription.length;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t\torderSize += 1;\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_new_or_existing_window(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const WINDOW_STATE_ORDER* stateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_new_or_existing_window(orderInfo, stateOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\tStream_Write_UINT32(s, stateOrder->ownerWindowId);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->style);\n\t\tStream_Write_UINT32(s, stateOrder->extendedStyle);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->showState);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->titleInfo.length);\n\t\tStream_Write(s, stateOrder->titleInfo.string, stateOrder->titleInfo.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaWidth);\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaHeight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginLeft);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginRight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginTop);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginBottom);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->RPContent);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->rootParentHandle);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaX);\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->windowWidth);\n\t\tStream_Write_UINT32(s, stateOrder->windowHeight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numWindowRects);\n\t\tStream_Write(s, stateOrder->windowRects, stateOrder->numWindowRects * sizeof(RECTANGLE_16));\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetX);\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numVisibilityRects);\n\t\tStream_Write(s, stateOrder->visibilityRects,\n\t\t             stateOrder->numVisibilityRects * sizeof(RECTANGLE_16));\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->OverlayDescription.length);\n\t\tStream_Write(s, stateOrder->OverlayDescription.string,\n\t\t             stateOrder->OverlayDescription.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->TaskbarButton);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->EnforceServerZOrder);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarState);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarEdge);\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_create(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\treturn update_send_new_or_existing_window(context, orderInfo, stateOrder);\n}\n\nstatic BOOL update_send_window_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\treturn update_send_new_or_existing_window(context, orderInfo, stateOrder);\n}\n\nstatic UINT16 update_calculate_window_icon_order(const WINDOW_ORDER_INFO* orderInfo,\n                                                 const WINDOW_ICON_ORDER* iconOrder)\n{\n\tUINT16 orderSize = 23;\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\n\torderSize += iconInfo->cbBitsColor + iconInfo->cbBitsMask;\n\n\tif (iconInfo->bpp <= 8)\n\t\torderSize += 2 + iconInfo->cbColorTable;\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_window_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                    const WINDOW_ICON_ORDER* iconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\tUINT16 orderSize = update_calculate_window_icon_order(orderInfo, iconOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s || !iconInfo)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\t/* Write body */\n\tStream_Write_UINT16(s, iconInfo->cacheEntry); /* CacheEntry (2 bytes) */\n\tStream_Write_UINT8(s, iconInfo->cacheId);     /* CacheId (1 byte) */\n\tStream_Write_UINT8(s, iconInfo->bpp);         /* Bpp (1 byte) */\n\tStream_Write_UINT16(s, iconInfo->width);      /* Width (2 bytes) */\n\tStream_Write_UINT16(s, iconInfo->height);     /* Height (2 bytes) */\n\n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write_UINT16(s, iconInfo->cbColorTable); /* CbColorTable (2 bytes) */\n\t}\n\n\tStream_Write_UINT16(s, iconInfo->cbBitsMask);              /* CbBitsMask (2 bytes) */\n\tStream_Write_UINT16(s, iconInfo->cbBitsColor);             /* CbBitsColor (2 bytes) */\n\tStream_Write(s, iconInfo->bitsMask, iconInfo->cbBitsMask); /* BitsMask (variable) */\n\n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write(s, iconInfo->colorTable, iconInfo->cbColorTable); /* ColorTable (variable) */\n\t}\n\n\tStream_Write(s, iconInfo->bitsColor, iconInfo->cbBitsColor); /* BitsColor (variable) */\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_cached_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const WINDOW_CACHED_ICON_ORDER* cachedIconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 14;\n\tCACHED_ICON_INFO cachedIcon = cachedIconOrder->cachedIcon;\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\t/* Write body */\n\tStream_Write_UINT16(s, cachedIcon.cacheEntry); /* CacheEntry (2 bytes) */\n\tStream_Write_UINT8(s, cachedIcon.cacheId);     /* CacheId (1 byte) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_delete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 11;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic UINT16 update_calculate_new_or_existing_notification_icons_order(\n    const WINDOW_ORDER_INFO* orderInfo, const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\tUINT16 orderSize = 15;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\torderSize += 2 + iconStateOrder->toolTip.length;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\t\torderSize += 12 + infoTip.text.length + infoTip.title.length;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\torderSize += 4;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\torderSize += 12;\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t\torderSize += 2 + iconInfo.cbColorTable;\n\n\t\torderSize += iconInfo.cbBitsMask + iconInfo.cbBitsColor;\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\torderSize += 3;\n\t}\n\n\treturn orderSize;\n}\n\nstatic BOOL\nupdate_send_new_or_existing_notification_icons(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tBOOL versionFieldPresent = FALSE;\n\tUINT16 orderSize =\n\t    update_calculate_new_or_existing_notification_icons_order(orderInfo, iconStateOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);             /* Header (1 byte) */\n\tStream_Write_INT16(s, orderSize);                /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);     /* WindowID (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->notifyIconId); /* NotifyIconId (4 bytes) */\n\n\t/* Write body */\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t{\n\t\tversionFieldPresent = TRUE;\n\t\tStream_Write_UINT32(s, iconStateOrder->version);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\tStream_Write_UINT16(s, iconStateOrder->toolTip.length);\n\t\tStream_Write(s, iconStateOrder->toolTip.string, iconStateOrder->toolTip.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\n\t\t/* info tip should not be sent when version is 0 */\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, infoTip.timeout);     /* Timeout (4 bytes) */\n\t\tStream_Write_UINT32(s, infoTip.flags);       /* InfoFlags (4 bytes) */\n\t\tStream_Write_UINT16(s, infoTip.text.length); /* InfoTipText (variable) */\n\t\tStream_Write(s, infoTip.text.string, infoTip.text.length);\n\t\tStream_Write_UINT16(s, infoTip.title.length); /* Title (variable) */\n\t\tStream_Write(s, infoTip.title.string, infoTip.title.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\t/* notify state should not be sent when version is 0 */\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, iconStateOrder->state);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\tStream_Write_UINT16(s, iconInfo.cacheEntry); /* CacheEntry (2 bytes) */\n\t\tStream_Write_UINT8(s, iconInfo.cacheId);     /* CacheId (1 byte) */\n\t\tStream_Write_UINT8(s, iconInfo.bpp);         /* Bpp (1 byte) */\n\t\tStream_Write_UINT16(s, iconInfo.width);      /* Width (2 bytes) */\n\t\tStream_Write_UINT16(s, iconInfo.height);     /* Height (2 bytes) */\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write_UINT16(s, iconInfo.cbColorTable); /* CbColorTable (2 bytes) */\n\t\t}\n\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsMask);             /* CbBitsMask (2 bytes) */\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsColor);            /* CbBitsColor (2 bytes) */\n\t\tStream_Write(s, iconInfo.bitsMask, iconInfo.cbBitsMask); /* BitsMask (variable) */\n\t\torderSize += iconInfo.cbBitsMask;\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write(s, iconInfo.colorTable, iconInfo.cbColorTable); /* ColorTable (variable) */\n\t\t}\n\n\t\tStream_Write(s, iconInfo.bitsColor, iconInfo.cbBitsColor); /* BitsColor (variable) */\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\tCACHED_ICON_INFO cachedIcon = iconStateOrder->cachedIcon;\n\t\tStream_Write_UINT16(s, cachedIcon.cacheEntry); /* CacheEntry (2 bytes) */\n\t\tStream_Write_UINT8(s, cachedIcon.cacheId);     /* CacheId (1 byte) */\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_notify_icon_create(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\treturn update_send_new_or_existing_notification_icons(context, orderInfo, iconStateOrder);\n}\n\nstatic BOOL update_send_notify_icon_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\treturn update_send_new_or_existing_notification_icons(context, orderInfo, iconStateOrder);\n}\n\nstatic BOOL update_send_notify_icon_delete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 15;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);             /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);               /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);     /* WindowID (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->notifyIconId); /* NotifyIconId (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic UINT16 update_calculate_monitored_desktop(const WINDOW_ORDER_INFO* orderInfo,\n                                                 const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT16 orderSize = 7;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\torderSize += 4;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\torderSize += 1 + (4 * monitoredDesktop->numWindowIds);\n\t}\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_monitored_desktop(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                          const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT32 i;\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_monitored_desktop(orderInfo, monitoredDesktop);\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\tStream_Write_UINT32(s, monitoredDesktop->activeWindowId); /* activeWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tStream_Write_UINT8(s, monitoredDesktop->numWindowIds); /* numWindowIds (1 byte) */\n\n\t\t/* windowIds */\n\t\tfor (i = 0; i < monitoredDesktop->numWindowIds; i++)\n\t\t{\n\t\t\tStream_Write_UINT32(s, monitoredDesktop->windowIds[i]);\n\t\t}\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_non_monitored_desktop(rdpContext* context,\n                                              const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 7;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nvoid update_register_server_callbacks(rdpUpdate* update)\n{\n\tupdate->BeginPaint = _update_begin_paint;\n\tupdate->EndPaint = _update_end_paint;\n\tupdate->SetBounds = update_set_bounds;\n\tupdate->Synchronize = update_send_synchronize;\n\tupdate->DesktopResize = update_send_desktop_resize;\n\tupdate->BitmapUpdate = update_send_bitmap_update;\n\tupdate->SurfaceBits = update_send_surface_bits;\n\tupdate->SurfaceFrameMarker = update_send_surface_frame_marker;\n\tupdate->SurfaceCommand = update_send_surface_command;\n\tupdate->SurfaceFrameBits = update_send_surface_frame_bits;\n\tupdate->PlaySound = update_send_play_sound;\n\tupdate->SetKeyboardIndicators = update_send_set_keyboard_indicators;\n\tupdate->SetKeyboardImeStatus = update_send_set_keyboard_ime_status;\n\tupdate->SaveSessionInfo = rdp_send_save_session_info;\n\tupdate->ServerStatusInfo = rdp_send_server_status_info;\n\tupdate->primary->DstBlt = update_send_dstblt;\n\tupdate->primary->PatBlt = update_send_patblt;\n\tupdate->primary->ScrBlt = update_send_scrblt;\n\tupdate->primary->OpaqueRect = update_send_opaque_rect;\n\tupdate->primary->LineTo = update_send_line_to;\n\tupdate->primary->MemBlt = update_send_memblt;\n\tupdate->primary->GlyphIndex = update_send_glyph_index;\n\tupdate->secondary->CacheBitmap = update_send_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_send_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_send_cache_bitmap_v3;\n\tupdate->secondary->CacheColorTable = update_send_cache_color_table;\n\tupdate->secondary->CacheGlyph = update_send_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_send_cache_glyph_v2;\n\tupdate->secondary->CacheBrush = update_send_cache_brush;\n\tupdate->altsec->CreateOffscreenBitmap = update_send_create_offscreen_bitmap_order;\n\tupdate->altsec->SwitchSurface = update_send_switch_surface_order;\n\tupdate->pointer->PointerSystem = update_send_pointer_system;\n\tupdate->pointer->PointerPosition = update_send_pointer_position;\n\tupdate->pointer->PointerColor = update_send_pointer_color;\n\tupdate->pointer->PointerLarge = update_send_pointer_large;\n\tupdate->pointer->PointerNew = update_send_pointer_new;\n\tupdate->pointer->PointerCached = update_send_pointer_cached;\n\tupdate->window->WindowCreate = update_send_window_create;\n\tupdate->window->WindowUpdate = update_send_window_update;\n\tupdate->window->WindowIcon = update_send_window_icon;\n\tupdate->window->WindowCachedIcon = update_send_window_cached_icon;\n\tupdate->window->WindowDelete = update_send_window_delete;\n\tupdate->window->NotifyIconCreate = update_send_notify_icon_create;\n\tupdate->window->NotifyIconUpdate = update_send_notify_icon_update;\n\tupdate->window->NotifyIconDelete = update_send_notify_icon_delete;\n\tupdate->window->MonitoredDesktop = update_send_monitored_desktop;\n\tupdate->window->NonMonitoredDesktop = update_send_non_monitored_desktop;\n}\n\nvoid update_register_client_callbacks(rdpUpdate* update)\n{\n\tupdate->RefreshRect = update_send_refresh_rect;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->SurfaceFrameAcknowledge = update_send_frame_acknowledge;\n}\n\nint update_process_messages(rdpUpdate* update)\n{\n\treturn update_message_queue_process_pending_messages(update);\n}\n\nstatic void update_free_queued_message(void* obj)\n{\n\twMessage* msg = (wMessage*)obj;\n\tupdate_message_queue_free_message(msg);\n}\n\nvoid update_free_window_state(WINDOW_STATE_ORDER* window_state)\n{\n\tif (!window_state)\n\t\treturn;\n\n\tfree(window_state->OverlayDescription.string);\n\tfree(window_state->titleInfo.string);\n\tfree(window_state->windowRects);\n\tfree(window_state->visibilityRects);\n\tmemset(window_state, 0, sizeof(WINDOW_STATE_ORDER));\n}\n\nrdpUpdate* update_new(rdpRdp* rdp)\n{\n\tconst wObject cb = { NULL, NULL, NULL, update_free_queued_message, NULL };\n\trdpUpdate* update;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\tWINPR_UNUSED(rdp);\n\tupdate = (rdpUpdate*)calloc(1, sizeof(rdpUpdate));\n\n\tif (!update)\n\t\treturn NULL;\n\n\tupdate->log = WLog_Get(\"com.freerdp.core.update\");\n\tInitializeCriticalSection(&(update->mux));\n\tupdate->pointer = (rdpPointerUpdate*)calloc(1, sizeof(rdpPointerUpdate));\n\n\tif (!update->pointer)\n\t\tgoto fail;\n\n\tupdate->primary = (rdpPrimaryUpdate*)calloc(1, sizeof(rdpPrimaryUpdate));\n\n\tif (!update->primary)\n\t\tgoto fail;\n\n\tupdate->secondary = (rdpSecondaryUpdate*)calloc(1, sizeof(rdpSecondaryUpdate));\n\n\tif (!update->secondary)\n\t\tgoto fail;\n\n\tupdate->altsec = (rdpAltSecUpdate*)calloc(1, sizeof(rdpAltSecUpdate));\n\n\tif (!update->altsec)\n\t\tgoto fail;\n\n\tupdate->window = (rdpWindowUpdate*)calloc(1, sizeof(rdpWindowUpdate));\n\n\tif (!update->window)\n\t\tgoto fail;\n\n\tdeleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\tdeleteList->sIndices = 64;\n\tdeleteList->indices = calloc(deleteList->sIndices, 2);\n\n\tif (!deleteList->indices)\n\t\tgoto fail;\n\n\tdeleteList->cIndices = 0;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->initialState = TRUE;\n\tupdate->autoCalculateBitmapData = TRUE;\n\tupdate->queue = MessageQueue_New(&cb);\n\n\tif (!update->queue)\n\t\tgoto fail;\n\n\treturn update;\nfail:\n\tupdate_free(update);\n\treturn NULL;\n}\n\nvoid update_free(rdpUpdate* update)\n{\n\tif (update != NULL)\n\t{\n\t\tOFFSCREEN_DELETE_LIST* deleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\n\t\tif (deleteList)\n\t\t\tfree(deleteList->indices);\n\n\t\tfree(update->pointer);\n\n\t\tif (update->primary)\n\t\t{\n\t\t\tfree(update->primary->polyline.points);\n\t\t\tfree(update->primary->polygon_sc.points);\n\t\t\tfree(update->primary->fast_glyph.glyphData.aj);\n\t\t\tfree(update->primary);\n\t\t}\n\n\t\tfree(update->secondary);\n\t\tfree(update->altsec);\n\n\t\tif (update->window)\n\t\t{\n\t\t\tfree(update->window);\n\t\t}\n\n\t\tMessageQueue_Free(update->queue);\n\t\tDeleteCriticalSection(&update->mux);\n\t\tfree(update);\n\t}\n}\n\nBOOL update_begin_paint(rdpUpdate* update)\n{\n\tif (!update)\n\t\treturn FALSE;\n\n\tEnterCriticalSection(&update->mux);\n\n\tif (!update->BeginPaint)\n\t\treturn TRUE;\n\n\treturn update->BeginPaint(update->context);\n}\n\nBOOL update_end_paint(rdpUpdate* update)\n{\n\tBOOL rc = FALSE;\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (update->EndPaint)\n\t\trc = update->EndPaint(update->context);\n\n\tLeaveCriticalSection(&update->mux);\n\treturn rc;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Update Data PDUs\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n#include <winpr/print.h>\n#include <winpr/synch.h>\n#include <winpr/thread.h>\n#include <winpr/collections.h>\n\n#include \"update.h\"\n#include \"surface.h\"\n#include \"message.h\"\n#include \"info.h\"\n#include \"window.h\"\n\n#include <freerdp/log.h>\n#include <freerdp/peer.h>\n#include <freerdp/codec/bitmap.h>\n\n#include \"../cache/pointer.h\"\n#include \"../cache/palette.h\"\n#include \"../cache/bitmap.h\"\n\n#define TAG FREERDP_TAG(\"core.update\")\n\nstatic const char* const UPDATE_TYPE_STRINGS[] = { \"Orders\", \"Bitmap\", \"Palette\", \"Synchronize\" };\n\nstatic const char* update_type_to_string(UINT16 updateType)\n{\n\tif (updateType >= ARRAYSIZE(UPDATE_TYPE_STRINGS))\n\t\treturn \"UNKNOWN\";\n\n\treturn UPDATE_TYPE_STRINGS[updateType];\n}\n\nstatic BOOL update_recv_orders(rdpUpdate* update, wStream* s)\n{\n\tUINT16 numberOrders;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 6\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Seek_UINT16(s);               /* pad2OctetsA (2 bytes) */\n\tStream_Read_UINT16(s, numberOrders); /* numberOrders (2 bytes) */\n\tStream_Seek_UINT16(s);               /* pad2OctetsB (2 bytes) */\n\n\twhile (numberOrders > 0)\n\t{\n\t\tif (!update_recv_order(update, s))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"update_recv_order() failed\");\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tnumberOrders--;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_write_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 64 + bitmapData->bitmapLength))\n\t\treturn FALSE;\n\n\tif (update->autoCalculateBitmapData)\n\t{\n\t\tbitmapData->flags = 0;\n\t\tbitmapData->cbCompFirstRowSize = 0;\n\n\t\tif (bitmapData->compressed)\n\t\t\tbitmapData->flags |= BITMAP_COMPRESSION;\n\n\t\tif (update->context->settings->NoBitmapCompressionHeader)\n\t\t{\n\t\t\tbitmapData->flags |= NO_BITMAP_COMPRESSION_HDR;\n\t\t\tbitmapData->cbCompMainBodySize = bitmapData->bitmapLength;\n\t\t}\n\t}\n\n\tStream_Write_UINT16(s, bitmapData->destLeft);\n\tStream_Write_UINT16(s, bitmapData->destTop);\n\tStream_Write_UINT16(s, bitmapData->destRight);\n\tStream_Write_UINT16(s, bitmapData->destBottom);\n\tStream_Write_UINT16(s, bitmapData->width);\n\tStream_Write_UINT16(s, bitmapData->height);\n\tStream_Write_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Write_UINT16(s, bitmapData->flags);\n\tStream_Write_UINT16(s, bitmapData->bitmapLength);\n\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompFirstRowSize); /* cbCompFirstRowSize (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbCompMainBodySize); /* cbCompMainBodySize (2 bytes) */\n\t\t\tStream_Write_UINT16(s, bitmapData->cbScanWidth);     /* cbScanWidth (2 bytes) */\n\t\t\tStream_Write_UINT16(s,\n\t\t\t                    bitmapData->cbUncompressedSize); /* cbUncompressedSize (2 bytes) */\n\t\t}\n\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\telse\n\t{\n\t\tStream_Write(s, bitmapData->bitmapDataStream, bitmapData->bitmapLength);\n\t}\n\n\treturn TRUE;\n}\n\nBITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\" PRIu32 \"\", bitmapUpdate->number);\n\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT32 count = bitmapUpdate->number * 2;\n\t\tBITMAP_DATA* newdata =\n\t\t    (BITMAP_DATA*)realloc(bitmapUpdate->rectangles, sizeof(BITMAP_DATA) * count);\n\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\t/* rectangles */\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}\n\nstatic BOOL update_write_bitmap_update(rdpUpdate* update, wStream* s,\n                                       const BITMAP_UPDATE* bitmapUpdate)\n{\n\tint i;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 32))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, UPDATE_TYPE_BITMAP);   /* updateType */\n\tStream_Write_UINT16(s, bitmapUpdate->number); /* numberRectangles (2 bytes) */\n\n\t/* rectangles */\n\tfor (i = 0; i < (int)bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_write_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nPALETTE_UPDATE* update_read_palette(rdpUpdate* update, wStream* s)\n{\n\tint i;\n\tPALETTE_ENTRY* entry;\n\tPALETTE_UPDATE* palette_update = calloc(1, sizeof(PALETTE_UPDATE));\n\n\tif (!palette_update)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Seek_UINT16(s);                         /* pad2Octets (2 bytes) */\n\tStream_Read_UINT32(s, palette_update->number); /* numberColors (4 bytes), must be set to 256 */\n\n\tif (palette_update->number > 256)\n\t\tpalette_update->number = 256;\n\n\tif (Stream_GetRemainingLength(s) < palette_update->number * 3)\n\t\tgoto fail;\n\n\t/* paletteEntries */\n\tfor (i = 0; i < (int)palette_update->number; i++)\n\t{\n\t\tentry = &palette_update->entries[i];\n\t\tStream_Read_UINT8(s, entry->red);\n\t\tStream_Read_UINT8(s, entry->green);\n\t\tStream_Read_UINT8(s, entry->blue);\n\t}\n\n\treturn palette_update;\nfail:\n\tfree_palette_update(update->context, palette_update);\n\treturn NULL;\n}\n\nstatic BOOL update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\treturn Stream_SafeSeek(s, 2); /* pad2Octets (2 bytes) */\n\t                              /**\n\t                               * The Synchronize Update is an artifact from the\n\t                               * T.128 protocol and should be ignored.\n\t                               */\n}\n\nstatic BOOL update_read_play_sound(wStream* s, PLAY_SOUND_UPDATE* play_sound)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, play_sound->duration);  /* duration (4 bytes) */\n\tStream_Read_UINT32(s, play_sound->frequency); /* frequency (4 bytes) */\n\treturn TRUE;\n}\n\nBOOL update_recv_play_sound(rdpUpdate* update, wStream* s)\n{\n\tPLAY_SOUND_UPDATE play_sound;\n\n\tif (!update_read_play_sound(s, &play_sound))\n\t\treturn FALSE;\n\n\treturn IFCALLRESULT(FALSE, update->PlaySound, update->context, &play_sound);\n}\n\nPOINTER_POSITION_UPDATE* update_read_pointer_position(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_POSITION_UPDATE* pointer_position = calloc(1, sizeof(POINTER_POSITION_UPDATE));\n\n\tif (!pointer_position)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_position->xPos); /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_position->yPos); /* yPos (2 bytes) */\n\treturn pointer_position;\nfail:\n\tfree_pointer_position_update(update->context, pointer_position);\n\treturn NULL;\n}\n\nPOINTER_SYSTEM_UPDATE* update_read_pointer_system(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_SYSTEM_UPDATE* pointer_system = calloc(1, sizeof(POINTER_SYSTEM_UPDATE));\n\n\tif (!pointer_system)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\tgoto fail;\n\n\tStream_Read_UINT32(s, pointer_system->type); /* systemPointerType (4 bytes) */\n\treturn pointer_system;\nfail:\n\tfree_pointer_system_update(update->context, pointer_system);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_color(wStream* s, POINTER_COLOR_UPDATE* pointer_color, BYTE xorBpp)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->xPos);       /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->yPos);       /* yPos (2 bytes) */\n\t/**\n\t *  As stated in 2.2.9.1.1.4.4 Color Pointer Update:\n\t *  The maximum allowed pointer width/height is 96 pixels if the client indicated support\n\t *  for large pointers by setting the LARGE_POINTER_FLAG (0x00000001) in the Large\n\t *  Pointer Capability Set (section 2.2.7.2.7). If the LARGE_POINTER_FLAG was not\n\t *  set, the maximum allowed pointer width/height is 32 pixels.\n\t *\n\t *  So we check for a maximum of 96 for CVE-2014-0250.\n\t */\n\tStream_Read_UINT16(s, pointer_color->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->height); /* height (2 bytes) */\n\n\tif ((pointer_color->width > 96) || (pointer_color->height > 96))\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_color->lengthAndMask); /* lengthAndMask (2 bytes) */\n\tStream_Read_UINT16(s, pointer_color->lengthXorMask); /* lengthXorMask (2 bytes) */\n\n\t/**\n\t * There does not seem to be any documentation on why\n\t * xPos / yPos can be larger than width / height\n\t * so it is missing in documentation or a bug in implementation\n\t * 2.2.9.1.1.4.4 Color Pointer Update (TS_COLORPOINTERATTRIBUTE)\n\t */\n\tif (pointer_color->xPos >= pointer_color->width)\n\t\tpointer_color->xPos = 0;\n\n\tif (pointer_color->yPos >= pointer_color->height)\n\t\tpointer_color->yPos = 0;\n\n\tif (pointer_color->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will\n\t\t * consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to\n\t\t * the next even number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + xorBpp * pointer_color->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->width, pointer_color->height, pointer_color->lengthXorMask,\n\t\t\t         scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->xorMaskData = newMask;\n\t\tStream_Read(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\t}\n\n\tif (pointer_color->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will\n\t\t * consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even\n\t\t * number of bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer_color->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer_color->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer_color->height != pointer_color->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer_color->lengthAndMask, scanlineSize * pointer_color->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer_color->andMaskData = newMask;\n\t\tStream_Read(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_COLOR_UPDATE* update_read_pointer_color(rdpUpdate* update, wStream* s, BYTE xorBpp)\n{\n\tPOINTER_COLOR_UPDATE* pointer_color = calloc(1, sizeof(POINTER_COLOR_UPDATE));\n\n\tif (!pointer_color)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_color(s, pointer_color, xorBpp))\n\t\tgoto fail;\n\n\treturn pointer_color;\nfail:\n\tfree_pointer_color_update(update->context, pointer_color);\n\treturn NULL;\n}\n\nstatic BOOL _update_read_pointer_large(wStream* s, POINTER_LARGE_UPDATE* pointer)\n{\n\tBYTE* newMask;\n\tUINT32 scanlineSize;\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 14)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->xorBpp);\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT16(s, pointer->hotSpotX);   /* xPos (2 bytes) */\n\tStream_Read_UINT16(s, pointer->hotSpotY);   /* yPos (2 bytes) */\n\n\tStream_Read_UINT16(s, pointer->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, pointer->height); /* height (2 bytes) */\n\n\tif ((pointer->width > 384) || (pointer->height > 384))\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->lengthAndMask); /* lengthAndMask (2 bytes) */\n\tStream_Read_UINT16(s, pointer->lengthXorMask); /* lengthXorMask (2 bytes) */\n\n\tif (pointer->hotSpotX >= pointer->width)\n\t\tpointer->hotSpotX = 0;\n\n\tif (pointer->hotSpotY >= pointer->height)\n\t\tpointer->hotSpotY = 0;\n\n\tif (pointer->lengthXorMask > 0)\n\t{\n\t\t/**\n\t\t * Spec states that:\n\t\t *\n\t\t * xorMaskData (variable): A variable-length array of bytes. Contains the 24-bpp, bottom-up\n\t\t * XOR mask scan-line data. The XOR mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 3x3 pixel cursor is being sent, then each scan-line will\n\t\t * consume 10 bytes (3 pixels per scan-line multiplied by 3 bytes per pixel, rounded up to\n\t\t * the next even number of bytes).\n\t\t *\n\t\t * In fact instead of 24-bpp, the bpp parameter is given by the containing packet.\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthXorMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = (7 + pointer->xorBpp * pointer->width) / 8;\n\t\tscanlineSize = ((scanlineSize + 1) / 2) * 2;\n\n\t\tif (scanlineSize * pointer->height != pointer->lengthXorMask)\n\t\t{\n\t\t\tWLog_ERR(TAG,\n\t\t\t         \"invalid lengthXorMask: width=%\" PRIu32 \" height=%\" PRIu32 \", %\" PRIu32\n\t\t\t         \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->width, pointer->height, pointer->lengthXorMask,\n\t\t\t         scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer->xorMaskData, pointer->lengthXorMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer->xorMaskData = newMask;\n\t\tStream_Read(s, pointer->xorMaskData, pointer->lengthXorMask);\n\t}\n\n\tif (pointer->lengthAndMask > 0)\n\t{\n\t\t/**\n\t\t * andMaskData (variable): A variable-length array of bytes. Contains the 1-bpp, bottom-up\n\t\t * AND mask scan-line data. The AND mask is padded to a 2-byte boundary for each encoded\n\t\t * scan-line. For example, if a 7x7 pixel cursor is being sent, then each scan-line will\n\t\t * consume 2 bytes (7 pixels per scan-line multiplied by 1 bpp, rounded up to the next even\n\t\t * number of bytes).\n\t\t */\n\t\tif (Stream_GetRemainingLength(s) < pointer->lengthAndMask)\n\t\t\tgoto fail;\n\n\t\tscanlineSize = ((7 + pointer->width) / 8);\n\t\tscanlineSize = ((1 + scanlineSize) / 2) * 2;\n\n\t\tif (scanlineSize * pointer->height != pointer->lengthAndMask)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"invalid lengthAndMask: %\" PRIu32 \" instead of %\" PRIu32 \"\",\n\t\t\t         pointer->lengthAndMask, scanlineSize * pointer->height);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnewMask = realloc(pointer->andMaskData, pointer->lengthAndMask);\n\n\t\tif (!newMask)\n\t\t\tgoto fail;\n\n\t\tpointer->andMaskData = newMask;\n\t\tStream_Read(s, pointer->andMaskData, pointer->lengthAndMask);\n\t}\n\n\tif (Stream_GetRemainingLength(s) > 0)\n\t\tStream_Seek_UINT8(s); /* pad (1 byte) */\n\n\treturn TRUE;\nfail:\n\treturn FALSE;\n}\n\nPOINTER_LARGE_UPDATE* update_read_pointer_large(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_LARGE_UPDATE* pointer = calloc(1, sizeof(POINTER_LARGE_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (!_update_read_pointer_large(s, pointer))\n\t\tgoto fail;\n\n\treturn pointer;\nfail:\n\tfree_pointer_large_update(update->context, pointer);\n\treturn NULL;\n}\n\nPOINTER_NEW_UPDATE* update_read_pointer_new(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_NEW_UPDATE* pointer_new = calloc(1, sizeof(POINTER_NEW_UPDATE));\n\n\tif (!pointer_new)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\n\tif ((pointer_new->xorBpp < 1) || (pointer_new->xorBpp > 32))\n\t{\n\t\tWLog_ERR(TAG, \"invalid xorBpp %\" PRIu32 \"\", pointer_new->xorBpp);\n\t\tgoto fail;\n\t}\n\n\tif (!_update_read_pointer_color(s, &pointer_new->colorPtrAttr,\n\t                                pointer_new->xorBpp)) /* colorPtrAttr */\n\t\tgoto fail;\n\n\treturn pointer_new;\nfail:\n\tfree_pointer_new_update(update->context, pointer_new);\n\treturn NULL;\n}\n\nPOINTER_CACHED_UPDATE* update_read_pointer_cached(rdpUpdate* update, wStream* s)\n{\n\tPOINTER_CACHED_UPDATE* pointer = calloc(1, sizeof(POINTER_CACHED_UPDATE));\n\n\tif (!pointer)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, pointer->cacheIndex); /* cacheIndex (2 bytes) */\n\treturn pointer;\nfail:\n\tfree_pointer_cached_update(update->context, pointer);\n\treturn NULL;\n}\n\nBOOL update_recv_pointer(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 messageType;\n\trdpContext* context = update->context;\n\trdpPointerUpdate* pointer = update->pointer;\n\n\tif (Stream_GetRemainingLength(s) < 2 + 2)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, messageType); /* messageType (2 bytes) */\n\tStream_Seek_UINT16(s);              /* pad2Octets (2 bytes) */\n\n\tswitch (messageType)\n\t{\n\t\tcase PTR_MSG_TYPE_POSITION:\n\t\t{\n\t\t\tPOINTER_POSITION_UPDATE* pointer_position = update_read_pointer_position(update, s);\n\n\t\t\tif (pointer_position)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerPosition, context, pointer_position);\n\t\t\t\tfree_pointer_position_update(context, pointer_position);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_SYSTEM:\n\t\t{\n\t\t\tPOINTER_SYSTEM_UPDATE* pointer_system = update_read_pointer_system(update, s);\n\n\t\t\tif (pointer_system)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerSystem, context, pointer_system);\n\t\t\t\tfree_pointer_system_update(context, pointer_system);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_COLOR:\n\t\t{\n\t\t\tPOINTER_COLOR_UPDATE* pointer_color = update_read_pointer_color(update, s, 24);\n\n\t\t\tif (pointer_color)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerColor, context, pointer_color);\n\t\t\t\tfree_pointer_color_update(context, pointer_color);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER_LARGE:\n\t\t{\n\t\t\tPOINTER_LARGE_UPDATE* pointer_large = update_read_pointer_large(update, s);\n\n\t\t\tif (pointer_large)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerLarge, context, pointer_large);\n\t\t\t\tfree_pointer_large_update(context, pointer_large);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_POINTER:\n\t\t{\n\t\t\tPOINTER_NEW_UPDATE* pointer_new = update_read_pointer_new(update, s);\n\n\t\t\tif (pointer_new)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerNew, context, pointer_new);\n\t\t\t\tfree_pointer_new_update(context, pointer_new);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tcase PTR_MSG_TYPE_CACHED:\n\t\t{\n\t\t\tPOINTER_CACHED_UPDATE* pointer_cached = update_read_pointer_cached(update, s);\n\n\t\t\tif (pointer_cached)\n\t\t\t{\n\t\t\t\trc = IFCALLRESULT(FALSE, pointer->PointerCached, context, pointer_cached);\n\t\t\t\tfree_pointer_cached_update(context, pointer_cached);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nBOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); /* updateType (2 bytes) */\n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nvoid update_reset_state(rdpUpdate* update)\n{\n\trdpPrimaryUpdate* primary = update->primary;\n\trdpAltSecUpdate* altsec = update->altsec;\n\n\tif (primary->fast_glyph.glyphData.aj)\n\t{\n\t\tfree(primary->fast_glyph.glyphData.aj);\n\t\tprimary->fast_glyph.glyphData.aj = NULL;\n\t}\n\n\tZeroMemory(&primary->order_info, sizeof(ORDER_INFO));\n\tZeroMemory(&primary->dstblt, sizeof(DSTBLT_ORDER));\n\tZeroMemory(&primary->patblt, sizeof(PATBLT_ORDER));\n\tZeroMemory(&primary->scrblt, sizeof(SCRBLT_ORDER));\n\tZeroMemory(&primary->opaque_rect, sizeof(OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->draw_nine_grid, sizeof(DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->multi_dstblt, sizeof(MULTI_DSTBLT_ORDER));\n\tZeroMemory(&primary->multi_patblt, sizeof(MULTI_PATBLT_ORDER));\n\tZeroMemory(&primary->multi_scrblt, sizeof(MULTI_SCRBLT_ORDER));\n\tZeroMemory(&primary->multi_opaque_rect, sizeof(MULTI_OPAQUE_RECT_ORDER));\n\tZeroMemory(&primary->multi_draw_nine_grid, sizeof(MULTI_DRAW_NINE_GRID_ORDER));\n\tZeroMemory(&primary->line_to, sizeof(LINE_TO_ORDER));\n\tZeroMemory(&primary->polyline, sizeof(POLYLINE_ORDER));\n\tZeroMemory(&primary->memblt, sizeof(MEMBLT_ORDER));\n\tZeroMemory(&primary->mem3blt, sizeof(MEM3BLT_ORDER));\n\tZeroMemory(&primary->save_bitmap, sizeof(SAVE_BITMAP_ORDER));\n\tZeroMemory(&primary->glyph_index, sizeof(GLYPH_INDEX_ORDER));\n\tZeroMemory(&primary->fast_index, sizeof(FAST_INDEX_ORDER));\n\tZeroMemory(&primary->fast_glyph, sizeof(FAST_GLYPH_ORDER));\n\tZeroMemory(&primary->polygon_sc, sizeof(POLYGON_SC_ORDER));\n\tZeroMemory(&primary->polygon_cb, sizeof(POLYGON_CB_ORDER));\n\tZeroMemory(&primary->ellipse_sc, sizeof(ELLIPSE_SC_ORDER));\n\tZeroMemory(&primary->ellipse_cb, sizeof(ELLIPSE_CB_ORDER));\n\tprimary->order_info.orderType = ORDER_TYPE_PATBLT;\n\n\tif (!update->initialState)\n\t{\n\t\taltsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\t\tIFCALL(altsec->SwitchSurface, update->context, &(altsec->switch_surface));\n\t}\n}\n\nBOOL update_post_connect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tif (!(update->proxy = update_message_proxy_new(update)))\n\t\t\treturn FALSE;\n\n\tupdate->altsec->switch_surface.bitmapId = SCREEN_BITMAP_SURFACE;\n\tIFCALL(update->altsec->SwitchSurface, update->context, &(update->altsec->switch_surface));\n\tupdate->initialState = FALSE;\n\treturn TRUE;\n}\n\nvoid update_post_disconnect(rdpUpdate* update)\n{\n\tupdate->asynchronous = update->context->settings->AsyncUpdate;\n\n\tif (update->asynchronous)\n\t\tupdate_message_proxy_free(update->proxy);\n\n\tupdate->initialState = TRUE;\n}\n\nstatic BOOL _update_begin_paint(rdpContext* context)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\n\tif (update->us)\n\t{\n\t\tif (!update_end_paint(update))\n\t\t\treturn FALSE;\n\t}\n\n\ts = fastpath_update_pdu_init_new(context->rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_SealLength(s);\n\tStream_Seek(s, 2); /* numberOrders (2 bytes) */\n\tupdate->combineUpdates = TRUE;\n\tupdate->numberOrders = 0;\n\tupdate->us = s;\n\treturn TRUE;\n}\n\nstatic BOOL _update_end_paint(rdpContext* context)\n{\n\twStream* s;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\n\tif (!update->us)\n\t\treturn FALSE;\n\n\ts = update->us;\n\theaderLength = Stream_Length(s);\n\tStream_SealLength(s);\n\tStream_SetPosition(s, headerLength);\n\tStream_Write_UINT16(s, update->numberOrders); /* numberOrders (2 bytes) */\n\tStream_SetPosition(s, Stream_Length(s));\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tWLog_DBG(TAG, \"sending %\" PRIu16 \" orders\", update->numberOrders);\n\t\tfastpath_send_update_pdu(context->rdp->fastpath, FASTPATH_UPDATETYPE_ORDERS, s, FALSE);\n\t}\n\n\tupdate->combineUpdates = FALSE;\n\tupdate->numberOrders = 0;\n\tupdate->us = NULL;\n\tStream_Free(s, TRUE);\n\treturn TRUE;\n}\n\nstatic void update_flush(rdpContext* context)\n{\n\trdpUpdate* update = context->update;\n\n\tif (update->numberOrders > 0)\n\t{\n\t\tupdate_end_paint(update);\n\t\tupdate_begin_paint(update);\n\t}\n}\n\nstatic void update_force_flush(rdpContext* context)\n{\n\tupdate_flush(context);\n}\n\nstatic BOOL update_check_flush(rdpContext* context, int size)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\ts = update->us;\n\n\tif (!update->us)\n\t{\n\t\tupdate_begin_paint(update);\n\t\treturn FALSE;\n\t}\n\n\tif (Stream_GetPosition(s) + size + 64 >= 0x3FFF)\n\t{\n\t\tupdate_flush(context);\n\t\treturn TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nstatic BOOL update_set_bounds(rdpContext* context, const rdpBounds* bounds)\n{\n\trdpUpdate* update = context->update;\n\tCopyMemory(&update->previousBounds, &update->currentBounds, sizeof(rdpBounds));\n\n\tif (!bounds)\n\t\tZeroMemory(&update->currentBounds, sizeof(rdpBounds));\n\telse\n\t\tCopyMemory(&update->currentBounds, bounds, sizeof(rdpBounds));\n\n\treturn TRUE;\n}\n\nstatic BOOL update_bounds_is_null(rdpBounds* bounds)\n{\n\tif ((bounds->left == 0) && (bounds->top == 0) && (bounds->right == 0) && (bounds->bottom == 0))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic BOOL update_bounds_equals(rdpBounds* bounds1, rdpBounds* bounds2)\n{\n\tif ((bounds1->left == bounds2->left) && (bounds1->top == bounds2->top) &&\n\t    (bounds1->right == bounds2->right) && (bounds1->bottom == bounds2->bottom))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nstatic int update_prepare_bounds(rdpContext* context, ORDER_INFO* orderInfo)\n{\n\tint length = 0;\n\trdpUpdate* update = context->update;\n\torderInfo->boundsFlags = 0;\n\n\tif (update_bounds_is_null(&update->currentBounds))\n\t\treturn 0;\n\n\torderInfo->controlFlags |= ORDER_BOUNDS;\n\n\tif (update_bounds_equals(&update->previousBounds, &update->currentBounds))\n\t{\n\t\torderInfo->controlFlags |= ORDER_ZERO_BOUNDS_DELTAS;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tlength += 1;\n\n\t\tif (update->previousBounds.left != update->currentBounds.left)\n\t\t{\n\t\t\torderInfo->bounds.left = update->currentBounds.left;\n\t\t\torderInfo->boundsFlags |= BOUND_LEFT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.top != update->currentBounds.top)\n\t\t{\n\t\t\torderInfo->bounds.top = update->currentBounds.top;\n\t\t\torderInfo->boundsFlags |= BOUND_TOP;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.right != update->currentBounds.right)\n\t\t{\n\t\t\torderInfo->bounds.right = update->currentBounds.right;\n\t\t\torderInfo->boundsFlags |= BOUND_RIGHT;\n\t\t\tlength += 2;\n\t\t}\n\n\t\tif (update->previousBounds.bottom != update->currentBounds.bottom)\n\t\t{\n\t\t\torderInfo->bounds.bottom = update->currentBounds.bottom;\n\t\t\torderInfo->boundsFlags |= BOUND_BOTTOM;\n\t\t\tlength += 2;\n\t\t}\n\t}\n\n\treturn length;\n}\n\nstatic int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}\n\nstatic int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); /* controlFlags (1 byte) */\n\n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}\n\nstatic void update_write_refresh_rect(wStream* s, BYTE count, const RECTANGLE_16* areas)\n{\n\tint i;\n\tStream_Write_UINT8(s, count); /* numberOfAreas (1 byte) */\n\tStream_Seek(s, 3);            /* pad3Octets (3 bytes) */\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tStream_Write_UINT16(s, areas[i].left);   /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].top);    /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].right);  /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, areas[i].bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_refresh_rect(rdpContext* context, BYTE count, const RECTANGLE_16* areas)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->RefreshRect)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_refresh_rect(s, count, areas);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_REFRESH_RECT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic void update_write_suppress_output(wStream* s, BYTE allow, const RECTANGLE_16* area)\n{\n\tStream_Write_UINT8(s, allow); /* allowDisplayUpdates (1 byte) */\n\t/* Use zeros for padding (like mstsc) for compatibility with legacy servers */\n\tStream_Zero(s, 3); /* pad3Octets (3 bytes) */\n\n\tif (allow > 0)\n\t{\n\t\tStream_Write_UINT16(s, area->left);   /* left (2 bytes) */\n\t\tStream_Write_UINT16(s, area->top);    /* top (2 bytes) */\n\t\tStream_Write_UINT16(s, area->right);  /* right (2 bytes) */\n\t\tStream_Write_UINT16(s, area->bottom); /* bottom (2 bytes) */\n\t}\n}\n\nstatic BOOL update_send_suppress_output(rdpContext* context, BYTE allow, const RECTANGLE_16* area)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->SuppressOutput)\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tupdate_write_suppress_output(s, allow, area);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SUPPRESS_OUTPUT, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_surface_command(rdpContext* context, wStream* s)\n{\n\twStream* update;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\tupdate = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(update, Stream_GetPosition(s)))\n\t{\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\n\n\tStream_Write(update, Stream_Buffer(s), Stream_GetPosition(s));\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, update, FALSE);\nout:\n\tStream_Release(update);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_bits(rdpContext* context,\n                                     const SURFACE_BITS_COMMAND* surfaceBitsCommand)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_surface_bits(s, surfaceBitsCommand))\n\t\tgoto out_fail;\n\n\tif (!fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                              surfaceBitsCommand->skipCompression))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_marker(rdpContext* context,\n                                             const SURFACE_FRAME_MARKER* surfaceFrameMarker)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_surfcmd_frame_marker(s, surfaceFrameMarker->frameAction,\n\t                                       surfaceFrameMarker->frameId) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s, FALSE))\n\t\tgoto out_fail;\n\n\tupdate_force_flush(context);\n\tret = TRUE;\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_surface_frame_bits(rdpContext* context, const SURFACE_BITS_COMMAND* cmd,\n                                           BOOL first, BOOL last, UINT32 frameId)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (first)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_BEGIN, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!update_write_surfcmd_surface_bits(s, cmd))\n\t\tgoto out_fail;\n\n\tif (last)\n\t{\n\t\tif (!update_write_surfcmd_frame_marker(s, SURFACECMD_FRAMEACTION_END, frameId))\n\t\t\tgoto out_fail;\n\t}\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SURFCMDS, s,\n\t                               cmd->skipCompression);\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_frame_acknowledge(rdpContext* context, UINT32 frameId)\n{\n\trdpRdp* rdp = context->rdp;\n\n\tif (rdp->settings->ReceivedCapabilities[CAPSET_TYPE_FRAME_ACKNOWLEDGE])\n\t{\n\t\twStream* s = rdp_data_pdu_init(rdp);\n\n\t\tif (!s)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, frameId);\n\t\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_FRAME_ACKNOWLEDGE, rdp->mcs->userId);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_synchronize(rdpContext* context)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Zero(s, 2); /* pad2Octets (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_SYNCHRONIZE, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_desktop_resize(rdpContext* context)\n{\n\treturn rdp_server_reactivate(context->rdp);\n}\n\nstatic BOOL update_send_bitmap_update(rdpContext* context, const BITMAP_UPDATE* bitmapUpdate)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\trdpUpdate* update = context->update;\n\tBOOL ret = TRUE;\n\tupdate_force_flush(context);\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_bitmap_update(update, s, bitmapUpdate) ||\n\t    !fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_BITMAP, s,\n\t                              bitmapUpdate->skipCompression))\n\t{\n\t\tret = FALSE;\n\t\tgoto out_fail;\n\t}\n\n\tupdate_force_flush(context);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_play_sound(rdpContext* context, const PLAY_SOUND_UPDATE* play_sound)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\n\tif (!rdp->settings->ReceivedCapabilities[CAPSET_TYPE_SOUND])\n\t{\n\t\treturn TRUE;\n\t}\n\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT32(s, play_sound->duration);\n\tStream_Write_UINT32(s, play_sound->frequency);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_PLAY_SOUND, rdp->mcs->userId);\n}\n\n/**\n * Primary Drawing Orders\n */\n\nstatic BOOL update_send_dstblt(rdpContext* context, const DSTBLT_ORDER* dstblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_DSTBLT);\n\tinf = update_approximate_dstblt_order(&orderInfo, dstblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_dstblt_order(s, &orderInfo, dstblt))\n\t\treturn FALSE;\n\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_patblt(rdpContext* context, PATBLT_ORDER* patblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_PATBLT);\n\tupdate_check_flush(context, headerLength + update_approximate_patblt_order(&orderInfo, patblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_patblt_order(s, &orderInfo, patblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_scrblt(rdpContext* context, const SCRBLT_ORDER* scrblt)\n{\n\twStream* s;\n\tUINT32 offset;\n\tUINT32 headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_SCRBLT);\n\tinf = update_approximate_scrblt_order(&orderInfo, scrblt);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn TRUE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_scrblt_order(s, &orderInfo, scrblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_opaque_rect(rdpContext* context, const OPAQUE_RECT_ORDER* opaque_rect)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_OPAQUE_RECT);\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_opaque_rect_order(&orderInfo, opaque_rect));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_opaque_rect_order(s, &orderInfo, opaque_rect);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_line_to(rdpContext* context, const LINE_TO_ORDER* line_to)\n{\n\twStream* s;\n\tint offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\tint inf;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_LINE_TO);\n\tinf = update_approximate_line_to_order(&orderInfo, line_to);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_line_to_order(s, &orderInfo, line_to);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_memblt(rdpContext* context, MEMBLT_ORDER* memblt)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_MEMBLT);\n\tupdate_check_flush(context, headerLength + update_approximate_memblt_order(&orderInfo, memblt));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_memblt_order(s, &orderInfo, memblt);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_glyph_index(rdpContext* context, GLYPH_INDEX_ORDER* glyph_index)\n{\n\twStream* s;\n\tsize_t offset;\n\tint headerLength;\n\tint inf;\n\tORDER_INFO orderInfo;\n\trdpUpdate* update = context->update;\n\theaderLength = update_prepare_order_info(context, &orderInfo, ORDER_TYPE_GLYPH_INDEX);\n\tinf = update_approximate_glyph_index_order(&orderInfo, glyph_index);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\toffset = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\tupdate_write_glyph_index_order(s, &orderInfo, glyph_index);\n\tupdate_write_order_info(context, s, &orderInfo, offset);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/*\n * Secondary Drawing Orders\n */\n\nstatic BOOL update_send_cache_bitmap(rdpContext* context, const CACHE_BITMAP_ORDER* cache_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tint inf;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap->compressed ? ORDER_TYPE_CACHE_BITMAP_COMPRESSED\n\t                                     : ORDER_TYPE_BITMAP_UNCOMPRESSED;\n\tinf =\n\t    update_approximate_cache_bitmap_order(cache_bitmap, cache_bitmap->compressed, &extraFlags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_order(s, cache_bitmap, cache_bitmap->compressed, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v2(rdpContext* context, CACHE_BITMAP_V2_ORDER* cache_bitmap_v2)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = cache_bitmap_v2->compressed ? ORDER_TYPE_BITMAP_COMPRESSED_V2\n\t                                        : ORDER_TYPE_BITMAP_UNCOMPRESSED_V2;\n\n\tif (context->settings->NoBitmapCompressionHeader)\n\t\tcache_bitmap_v2->flags |= CBR2_NO_BITMAP_COMPRESSION_HDR;\n\n\tupdate_check_flush(context, headerLength +\n\t                                update_approximate_cache_bitmap_v2_order(\n\t                                    cache_bitmap_v2, cache_bitmap_v2->compressed, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v2_order(s, cache_bitmap_v2, cache_bitmap_v2->compressed,\n\t                                        &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_bitmap_v3(rdpContext* context, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3)\n{\n\twStream* s;\n\tsize_t bm, em;\n\tBYTE orderType;\n\tint headerLength;\n\tUINT16 extraFlags;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\textraFlags = 0;\n\theaderLength = 6;\n\torderType = ORDER_TYPE_BITMAP_COMPRESSED_V3;\n\tupdate_check_flush(context, headerLength + update_approximate_cache_bitmap_v3_order(\n\t                                               cache_bitmap_v3, &extraFlags));\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_bitmap_v3_order(s, cache_bitmap_v3, &extraFlags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, extraFlags);                      /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, orderType);                        /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_color_table(rdpContext* context,\n                                          const CACHE_COLOR_TABLE_ORDER* cache_color_table)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_color_table_order(cache_color_table, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_color_table_order(s, cache_color_table, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_COLOR_TABLE);     /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph(rdpContext* context, const CACHE_GLYPH_ORDER* cache_glyph)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_order(cache_glyph, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_order(s, cache_glyph, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_glyph_v2(rdpContext* context,\n                                       const CACHE_GLYPH_V2_ORDER* cache_glyph_v2)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_glyph_v2_order(cache_glyph_v2, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_glyph_v2_order(s, cache_glyph_v2, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_GLYPH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_cache_brush(rdpContext* context, const CACHE_BRUSH_ORDER* cache_brush)\n{\n\twStream* s;\n\tUINT16 flags;\n\tsize_t bm, em, inf;\n\tint headerLength;\n\tINT16 orderLength;\n\trdpUpdate* update = context->update;\n\tflags = 0;\n\theaderLength = 6;\n\tinf = update_approximate_cache_brush_order(cache_brush, &flags);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_cache_brush_order(s, cache_brush, &flags))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\torderLength = (em - bm) - 13;\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, ORDER_STANDARD | ORDER_SECONDARY); /* controlFlags (1 byte) */\n\tStream_Write_UINT16(s, orderLength);                     /* orderLength (2 bytes) */\n\tStream_Write_UINT16(s, flags);                           /* extraFlags (2 bytes) */\n\tStream_Write_UINT8(s, ORDER_TYPE_CACHE_BRUSH);           /* orderType (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\n/**\n * Alternate Secondary Drawing Orders\n */\n\nstatic BOOL update_send_create_offscreen_bitmap_order(\n    rdpContext* context, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_CREATE_OFFSCREEN_BITMAP;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_create_offscreen_bitmap_order(s, create_offscreen_bitmap))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_switch_surface_order(rdpContext* context,\n                                             const SWITCH_SURFACE_ORDER* switch_surface)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update;\n\n\tif (!context || !switch_surface || !context->update)\n\t\treturn FALSE;\n\n\tupdate = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_SWITCH_SURFACE;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_switch_surface_order(switch_surface);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_switch_surface_order(s, switch_surface))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); /* controlFlags (1 byte) */\n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_system(rdpContext* context,\n                                       const POINTER_SYSTEM_UPDATE* pointer_system)\n{\n\twStream* s;\n\tBYTE updateCode;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (pointer_system->type == SYSPTR_NULL)\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_NULL;\n\telse\n\t\tupdateCode = FASTPATH_UPDATETYPE_PTR_DEFAULT;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, updateCode, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_position(rdpContext* context,\n                                         const POINTER_POSITION_UPDATE* pointerPosition)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointerPosition->xPos); /* xPos (2 bytes) */\n\tStream_Write_UINT16(s, pointerPosition->yPos); /* yPos (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_PTR_POSITION, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_color(wStream* s, const POINTER_COLOR_UPDATE* pointer_color)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 32 + pointer_color->lengthAndMask +\n\t                                           pointer_color->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_color->cacheIndex);\n\tStream_Write_UINT16(s, pointer_color->xPos);\n\tStream_Write_UINT16(s, pointer_color->yPos);\n\tStream_Write_UINT16(s, pointer_color->width);\n\tStream_Write_UINT16(s, pointer_color->height);\n\tStream_Write_UINT16(s, pointer_color->lengthAndMask);\n\tStream_Write_UINT16(s, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthXorMask > 0)\n\t\tStream_Write(s, pointer_color->xorMaskData, pointer_color->lengthXorMask);\n\n\tif (pointer_color->lengthAndMask > 0)\n\t\tStream_Write(s, pointer_color->andMaskData, pointer_color->lengthAndMask);\n\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_color(rdpContext* context,\n                                      const POINTER_COLOR_UPDATE* pointer_color)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_color(s, pointer_color))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_COLOR, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_write_pointer_large(wStream* s, const POINTER_LARGE_UPDATE* pointer)\n{\n\tif (!Stream_EnsureRemainingCapacity(s, 32 + pointer->lengthAndMask + pointer->lengthXorMask))\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer->xorBpp);\n\tStream_Write_UINT16(s, pointer->cacheIndex);\n\tStream_Write_UINT16(s, pointer->hotSpotX);\n\tStream_Write_UINT16(s, pointer->hotSpotY);\n\tStream_Write_UINT16(s, pointer->width);\n\tStream_Write_UINT16(s, pointer->height);\n\tStream_Write_UINT32(s, pointer->lengthAndMask);\n\tStream_Write_UINT32(s, pointer->lengthXorMask);\n\tStream_Write(s, pointer->xorMaskData, pointer->lengthXorMask);\n\tStream_Write(s, pointer->andMaskData, pointer->lengthAndMask);\n\tStream_Write_UINT8(s, 0); /* pad (1 byte) */\n\treturn TRUE;\n}\n\nstatic BOOL update_send_pointer_large(rdpContext* context, const POINTER_LARGE_UPDATE* pointer)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!update_write_pointer_large(s, pointer))\n\t\tgoto out_fail;\n\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_LARGE_POINTER, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_new(rdpContext* context, const POINTER_NEW_UPDATE* pointer_new)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret = FALSE;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 16))\n\t\tgoto out_fail;\n\n\tStream_Write_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */\n\tupdate_write_pointer_color(s, &pointer_new->colorPtrAttr);\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_POINTER, s, FALSE);\nout_fail:\n\tStream_Release(s);\n\treturn ret;\n}\n\nstatic BOOL update_send_pointer_cached(rdpContext* context,\n                                       const POINTER_CACHED_UPDATE* pointer_cached)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\tBOOL ret;\n\ts = fastpath_update_pdu_init(rdp->fastpath);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, pointer_cached->cacheIndex); /* cacheIndex (2 bytes) */\n\tret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_CACHED, s, FALSE);\n\tStream_Release(s);\n\treturn ret;\n}\n\nBOOL update_read_refresh_rect(rdpUpdate* update, wStream* s)\n{\n\tint index;\n\tBYTE numberOfAreas;\n\tRECTANGLE_16* areas;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, numberOfAreas);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (Stream_GetRemainingLength(s) < ((size_t)numberOfAreas * 4 * 2))\n\t\treturn FALSE;\n\n\tareas = (RECTANGLE_16*)calloc(numberOfAreas, sizeof(RECTANGLE_16));\n\n\tif (!areas)\n\t\treturn FALSE;\n\n\tfor (index = 0; index < numberOfAreas; index++)\n\t{\n\t\tStream_Read_UINT16(s, areas[index].left);\n\t\tStream_Read_UINT16(s, areas[index].top);\n\t\tStream_Read_UINT16(s, areas[index].right);\n\t\tStream_Read_UINT16(s, areas[index].bottom);\n\t}\n\n\tif (update->context->settings->RefreshRect)\n\t\tIFCALL(update->RefreshRect, update->context, numberOfAreas, areas);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring refresh rect request from client\");\n\n\tfree(areas);\n\treturn TRUE;\n}\n\nBOOL update_read_suppress_output(rdpUpdate* update, wStream* s)\n{\n\tRECTANGLE_16* prect = NULL;\n\tRECTANGLE_16 rect = { 0 };\n\tBYTE allowDisplayUpdates;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(s, allowDisplayUpdates);\n\tStream_Seek(s, 3); /* pad3Octects */\n\n\tif (allowDisplayUpdates > 0)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < sizeof(RECTANGLE_16))\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT16(s, rect.left);\n\t\tStream_Read_UINT16(s, rect.top);\n\t\tStream_Read_UINT16(s, rect.right);\n\t\tStream_Read_UINT16(s, rect.bottom);\n\n\t\tprect = &rect;\n\t}\n\n\tif (update->context->settings->SuppressOutput)\n\t\tIFCALL(update->SuppressOutput, update->context, allowDisplayUpdates, prect);\n\telse\n\t\tWLog_Print(update->log, WLOG_WARN, \"ignoring suppress output request from client\");\n\n\treturn TRUE;\n}\n\nstatic BOOL update_send_set_keyboard_indicators(rdpContext* context, UINT16 led_flags)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT16(s, 0);         /* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.1.1 */\n\tStream_Write_UINT16(s, led_flags); /* ledFlags (2 bytes) */\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_INDICATORS, rdp->mcs->userId);\n}\n\nstatic BOOL update_send_set_keyboard_ime_status(rdpContext* context, UINT16 imeId, UINT32 imeState,\n                                                UINT32 imeConvMode)\n{\n\twStream* s;\n\trdpRdp* rdp = context->rdp;\n\ts = rdp_data_pdu_init(rdp);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* unitId should be 0 according to MS-RDPBCGR 2.2.8.2.2.1 */\n\tStream_Write_UINT16(s, imeId);\n\tStream_Write_UINT32(s, imeState);\n\tStream_Write_UINT32(s, imeConvMode);\n\treturn rdp_send_data_pdu(rdp, s, DATA_PDU_TYPE_SET_KEYBOARD_IME_STATUS, rdp->mcs->userId);\n}\n\nstatic UINT16 update_calculate_new_or_existing_window(const WINDOW_ORDER_INFO* orderInfo,\n                                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\tUINT16 orderSize = 11;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t\torderSize += 2 + stateOrder->titleInfo.length;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t\torderSize += 2 + stateOrder->numWindowRects * sizeof(RECTANGLE_16);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t\torderSize += 8;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t\torderSize += 2 + stateOrder->numVisibilityRects * sizeof(RECTANGLE_16);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t\torderSize += 2 + stateOrder->OverlayDescription.length;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t\torderSize += 1;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t\torderSize += 1;\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_new_or_existing_window(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const WINDOW_STATE_ORDER* stateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_new_or_existing_window(orderInfo, stateOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OWNER) != 0)\n\t\tStream_Write_UINT32(s, stateOrder->ownerWindowId);\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_STYLE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->style);\n\t\tStream_Write_UINT32(s, stateOrder->extendedStyle);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_SHOW) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->showState);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TITLE) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->titleInfo.length);\n\t\tStream_Write(s, stateOrder->titleInfo.string, stateOrder->titleInfo.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->clientOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_CLIENT_AREA_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaWidth);\n\t\tStream_Write_UINT32(s, stateOrder->clientAreaHeight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_X) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginLeft);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginRight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RESIZE_MARGIN_Y) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginTop);\n\t\tStream_Write_UINT32(s, stateOrder->resizeMarginBottom);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_RP_CONTENT) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->RPContent);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ROOT_PARENT) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->rootParentHandle);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_OFFSET) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetX);\n\t\tStream_Write_INT32(s, stateOrder->windowOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_CLIENT_DELTA) != 0)\n\t{\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaX);\n\t\tStream_Write_INT32(s, stateOrder->windowClientDeltaY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_SIZE) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->windowWidth);\n\t\tStream_Write_UINT32(s, stateOrder->windowHeight);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_WND_RECTS) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numWindowRects);\n\t\tStream_Write(s, stateOrder->windowRects, stateOrder->numWindowRects * sizeof(RECTANGLE_16));\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VIS_OFFSET) != 0)\n\t{\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetX);\n\t\tStream_Write_UINT32(s, stateOrder->visibleOffsetY);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_VISIBILITY) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->numVisibilityRects);\n\t\tStream_Write(s, stateOrder->visibilityRects,\n\t\t             stateOrder->numVisibilityRects * sizeof(RECTANGLE_16));\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_OVERLAY_DESCRIPTION) != 0)\n\t{\n\t\tStream_Write_UINT16(s, stateOrder->OverlayDescription.length);\n\t\tStream_Write(s, stateOrder->OverlayDescription.string,\n\t\t             stateOrder->OverlayDescription.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_TASKBAR_BUTTON) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->TaskbarButton);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_ENFORCE_SERVER_ZORDER) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->EnforceServerZOrder);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_STATE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarState);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_APPBAR_EDGE) != 0)\n\t{\n\t\tStream_Write_UINT8(s, stateOrder->AppBarEdge);\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_create(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\treturn update_send_new_or_existing_window(context, orderInfo, stateOrder);\n}\n\nstatic BOOL update_send_window_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                      const WINDOW_STATE_ORDER* stateOrder)\n{\n\treturn update_send_new_or_existing_window(context, orderInfo, stateOrder);\n}\n\nstatic UINT16 update_calculate_window_icon_order(const WINDOW_ORDER_INFO* orderInfo,\n                                                 const WINDOW_ICON_ORDER* iconOrder)\n{\n\tUINT16 orderSize = 23;\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\n\torderSize += iconInfo->cbBitsColor + iconInfo->cbBitsMask;\n\n\tif (iconInfo->bpp <= 8)\n\t\torderSize += 2 + iconInfo->cbColorTable;\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_window_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                    const WINDOW_ICON_ORDER* iconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tICON_INFO* iconInfo = iconOrder->iconInfo;\n\tUINT16 orderSize = update_calculate_window_icon_order(orderInfo, iconOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s || !iconInfo)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\t/* Write body */\n\tStream_Write_UINT16(s, iconInfo->cacheEntry); /* CacheEntry (2 bytes) */\n\tStream_Write_UINT8(s, iconInfo->cacheId);     /* CacheId (1 byte) */\n\tStream_Write_UINT8(s, iconInfo->bpp);         /* Bpp (1 byte) */\n\tStream_Write_UINT16(s, iconInfo->width);      /* Width (2 bytes) */\n\tStream_Write_UINT16(s, iconInfo->height);     /* Height (2 bytes) */\n\n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write_UINT16(s, iconInfo->cbColorTable); /* CbColorTable (2 bytes) */\n\t}\n\n\tStream_Write_UINT16(s, iconInfo->cbBitsMask);              /* CbBitsMask (2 bytes) */\n\tStream_Write_UINT16(s, iconInfo->cbBitsColor);             /* CbBitsColor (2 bytes) */\n\tStream_Write(s, iconInfo->bitsMask, iconInfo->cbBitsMask); /* BitsMask (variable) */\n\n\tif (iconInfo->bpp <= 8)\n\t{\n\t\tStream_Write(s, iconInfo->colorTable, iconInfo->cbColorTable); /* ColorTable (variable) */\n\t}\n\n\tStream_Write(s, iconInfo->bitsColor, iconInfo->cbBitsColor); /* BitsColor (variable) */\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_cached_icon(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const WINDOW_CACHED_ICON_ORDER* cachedIconOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 14;\n\tCACHED_ICON_INFO cachedIcon = cachedIconOrder->cachedIcon;\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\t/* Write body */\n\tStream_Write_UINT16(s, cachedIcon.cacheEntry); /* CacheEntry (2 bytes) */\n\tStream_Write_UINT8(s, cachedIcon.cacheId);     /* CacheId (1 byte) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_window_delete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 11;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);   /* WindowID (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic UINT16 update_calculate_new_or_existing_notification_icons_order(\n    const WINDOW_ORDER_INFO* orderInfo, const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\tUINT16 orderSize = 15;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t\torderSize += 4;\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\torderSize += 2 + iconStateOrder->toolTip.length;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\t\torderSize += 12 + infoTip.text.length + infoTip.title.length;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\torderSize += 4;\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\torderSize += 12;\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t\torderSize += 2 + iconInfo.cbColorTable;\n\n\t\torderSize += iconInfo.cbBitsMask + iconInfo.cbBitsColor;\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\torderSize += 3;\n\t}\n\n\treturn orderSize;\n}\n\nstatic BOOL\nupdate_send_new_or_existing_notification_icons(rdpContext* context,\n                                               const WINDOW_ORDER_INFO* orderInfo,\n                                               const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tBOOL versionFieldPresent = FALSE;\n\tUINT16 orderSize =\n\t    update_calculate_new_or_existing_notification_icons_order(orderInfo, iconStateOrder);\n\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s, orderSize))\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);             /* Header (1 byte) */\n\tStream_Write_INT16(s, orderSize);                /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);     /* WindowID (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->notifyIconId); /* NotifyIconId (4 bytes) */\n\n\t/* Write body */\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_VERSION) != 0)\n\t{\n\t\tversionFieldPresent = TRUE;\n\t\tStream_Write_UINT32(s, iconStateOrder->version);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_TIP) != 0)\n\t{\n\t\tStream_Write_UINT16(s, iconStateOrder->toolTip.length);\n\t\tStream_Write(s, iconStateOrder->toolTip.string, iconStateOrder->toolTip.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_INFO_TIP) != 0)\n\t{\n\t\tNOTIFY_ICON_INFOTIP infoTip = iconStateOrder->infoTip;\n\n\t\t/* info tip should not be sent when version is 0 */\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, infoTip.timeout);     /* Timeout (4 bytes) */\n\t\tStream_Write_UINT32(s, infoTip.flags);       /* InfoFlags (4 bytes) */\n\t\tStream_Write_UINT16(s, infoTip.text.length); /* InfoTipText (variable) */\n\t\tStream_Write(s, infoTip.text.string, infoTip.text.length);\n\t\tStream_Write_UINT16(s, infoTip.title.length); /* Title (variable) */\n\t\tStream_Write(s, infoTip.title.string, infoTip.title.length);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_FIELD_NOTIFY_STATE) != 0)\n\t{\n\t\t/* notify state should not be sent when version is 0 */\n\t\tif (versionFieldPresent && iconStateOrder->version == 0)\n\t\t\treturn FALSE;\n\n\t\tStream_Write_UINT32(s, iconStateOrder->state);\n\t}\n\n\tif ((orderInfo->fieldFlags & WINDOW_ORDER_ICON) != 0)\n\t{\n\t\tICON_INFO iconInfo = iconStateOrder->icon;\n\t\tStream_Write_UINT16(s, iconInfo.cacheEntry); /* CacheEntry (2 bytes) */\n\t\tStream_Write_UINT8(s, iconInfo.cacheId);     /* CacheId (1 byte) */\n\t\tStream_Write_UINT8(s, iconInfo.bpp);         /* Bpp (1 byte) */\n\t\tStream_Write_UINT16(s, iconInfo.width);      /* Width (2 bytes) */\n\t\tStream_Write_UINT16(s, iconInfo.height);     /* Height (2 bytes) */\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write_UINT16(s, iconInfo.cbColorTable); /* CbColorTable (2 bytes) */\n\t\t}\n\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsMask);             /* CbBitsMask (2 bytes) */\n\t\tStream_Write_UINT16(s, iconInfo.cbBitsColor);            /* CbBitsColor (2 bytes) */\n\t\tStream_Write(s, iconInfo.bitsMask, iconInfo.cbBitsMask); /* BitsMask (variable) */\n\t\torderSize += iconInfo.cbBitsMask;\n\n\t\tif (iconInfo.bpp <= 8)\n\t\t{\n\t\t\tStream_Write(s, iconInfo.colorTable, iconInfo.cbColorTable); /* ColorTable (variable) */\n\t\t}\n\n\t\tStream_Write(s, iconInfo.bitsColor, iconInfo.cbBitsColor); /* BitsColor (variable) */\n\t}\n\telse if ((orderInfo->fieldFlags & WINDOW_ORDER_CACHED_ICON) != 0)\n\t{\n\t\tCACHED_ICON_INFO cachedIcon = iconStateOrder->cachedIcon;\n\t\tStream_Write_UINT16(s, cachedIcon.cacheEntry); /* CacheEntry (2 bytes) */\n\t\tStream_Write_UINT8(s, cachedIcon.cacheId);     /* CacheId (1 byte) */\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_notify_icon_create(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\treturn update_send_new_or_existing_notification_icons(context, orderInfo, iconStateOrder);\n}\n\nstatic BOOL update_send_notify_icon_update(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                           const NOTIFY_ICON_STATE_ORDER* iconStateOrder)\n{\n\treturn update_send_new_or_existing_notification_icons(context, orderInfo, iconStateOrder);\n}\n\nstatic BOOL update_send_notify_icon_delete(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 15;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\t/* Write Hdr */\n\tStream_Write_UINT8(s, controlFlags);             /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);               /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags);   /* FieldsPresentFlags (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->windowId);     /* WindowID (4 bytes) */\n\tStream_Write_UINT32(s, orderInfo->notifyIconId); /* NotifyIconId (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic UINT16 update_calculate_monitored_desktop(const WINDOW_ORDER_INFO* orderInfo,\n                                                 const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT16 orderSize = 7;\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\torderSize += 4;\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\torderSize += 1 + (4 * monitoredDesktop->numWindowIds);\n\t}\n\n\treturn orderSize;\n}\n\nstatic BOOL update_send_monitored_desktop(rdpContext* context, const WINDOW_ORDER_INFO* orderInfo,\n                                          const MONITORED_DESKTOP_ORDER* monitoredDesktop)\n{\n\tUINT32 i;\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = update_calculate_monitored_desktop(orderInfo, monitoredDesktop);\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ACTIVE_WND)\n\t{\n\t\tStream_Write_UINT32(s, monitoredDesktop->activeWindowId); /* activeWindowId (4 bytes) */\n\t}\n\n\tif (orderInfo->fieldFlags & WINDOW_ORDER_FIELD_DESKTOP_ZORDER)\n\t{\n\t\tStream_Write_UINT8(s, monitoredDesktop->numWindowIds); /* numWindowIds (1 byte) */\n\n\t\t/* windowIds */\n\t\tfor (i = 0; i < monitoredDesktop->numWindowIds; i++)\n\t\t{\n\t\t\tStream_Write_UINT32(s, monitoredDesktop->windowIds[i]);\n\t\t}\n\t}\n\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nstatic BOOL update_send_non_monitored_desktop(rdpContext* context,\n                                              const WINDOW_ORDER_INFO* orderInfo)\n{\n\twStream* s;\n\trdpUpdate* update = context->update;\n\tBYTE controlFlags = ORDER_SECONDARY | (ORDER_TYPE_WINDOW << 2);\n\tUINT16 orderSize = 7;\n\tupdate_check_flush(context, orderSize);\n\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tStream_Write_UINT8(s, controlFlags);           /* Header (1 byte) */\n\tStream_Write_UINT16(s, orderSize);             /* OrderSize (2 bytes) */\n\tStream_Write_UINT32(s, orderInfo->fieldFlags); /* FieldsPresentFlags (4 bytes) */\n\tupdate->numberOrders++;\n\treturn TRUE;\n}\n\nvoid update_register_server_callbacks(rdpUpdate* update)\n{\n\tupdate->BeginPaint = _update_begin_paint;\n\tupdate->EndPaint = _update_end_paint;\n\tupdate->SetBounds = update_set_bounds;\n\tupdate->Synchronize = update_send_synchronize;\n\tupdate->DesktopResize = update_send_desktop_resize;\n\tupdate->BitmapUpdate = update_send_bitmap_update;\n\tupdate->SurfaceBits = update_send_surface_bits;\n\tupdate->SurfaceFrameMarker = update_send_surface_frame_marker;\n\tupdate->SurfaceCommand = update_send_surface_command;\n\tupdate->SurfaceFrameBits = update_send_surface_frame_bits;\n\tupdate->PlaySound = update_send_play_sound;\n\tupdate->SetKeyboardIndicators = update_send_set_keyboard_indicators;\n\tupdate->SetKeyboardImeStatus = update_send_set_keyboard_ime_status;\n\tupdate->SaveSessionInfo = rdp_send_save_session_info;\n\tupdate->ServerStatusInfo = rdp_send_server_status_info;\n\tupdate->primary->DstBlt = update_send_dstblt;\n\tupdate->primary->PatBlt = update_send_patblt;\n\tupdate->primary->ScrBlt = update_send_scrblt;\n\tupdate->primary->OpaqueRect = update_send_opaque_rect;\n\tupdate->primary->LineTo = update_send_line_to;\n\tupdate->primary->MemBlt = update_send_memblt;\n\tupdate->primary->GlyphIndex = update_send_glyph_index;\n\tupdate->secondary->CacheBitmap = update_send_cache_bitmap;\n\tupdate->secondary->CacheBitmapV2 = update_send_cache_bitmap_v2;\n\tupdate->secondary->CacheBitmapV3 = update_send_cache_bitmap_v3;\n\tupdate->secondary->CacheColorTable = update_send_cache_color_table;\n\tupdate->secondary->CacheGlyph = update_send_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_send_cache_glyph_v2;\n\tupdate->secondary->CacheBrush = update_send_cache_brush;\n\tupdate->altsec->CreateOffscreenBitmap = update_send_create_offscreen_bitmap_order;\n\tupdate->altsec->SwitchSurface = update_send_switch_surface_order;\n\tupdate->pointer->PointerSystem = update_send_pointer_system;\n\tupdate->pointer->PointerPosition = update_send_pointer_position;\n\tupdate->pointer->PointerColor = update_send_pointer_color;\n\tupdate->pointer->PointerLarge = update_send_pointer_large;\n\tupdate->pointer->PointerNew = update_send_pointer_new;\n\tupdate->pointer->PointerCached = update_send_pointer_cached;\n\tupdate->window->WindowCreate = update_send_window_create;\n\tupdate->window->WindowUpdate = update_send_window_update;\n\tupdate->window->WindowIcon = update_send_window_icon;\n\tupdate->window->WindowCachedIcon = update_send_window_cached_icon;\n\tupdate->window->WindowDelete = update_send_window_delete;\n\tupdate->window->NotifyIconCreate = update_send_notify_icon_create;\n\tupdate->window->NotifyIconUpdate = update_send_notify_icon_update;\n\tupdate->window->NotifyIconDelete = update_send_notify_icon_delete;\n\tupdate->window->MonitoredDesktop = update_send_monitored_desktop;\n\tupdate->window->NonMonitoredDesktop = update_send_non_monitored_desktop;\n}\n\nvoid update_register_client_callbacks(rdpUpdate* update)\n{\n\tupdate->RefreshRect = update_send_refresh_rect;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->SurfaceFrameAcknowledge = update_send_frame_acknowledge;\n}\n\nint update_process_messages(rdpUpdate* update)\n{\n\treturn update_message_queue_process_pending_messages(update);\n}\n\nstatic void update_free_queued_message(void* obj)\n{\n\twMessage* msg = (wMessage*)obj;\n\tupdate_message_queue_free_message(msg);\n}\n\nvoid update_free_window_state(WINDOW_STATE_ORDER* window_state)\n{\n\tif (!window_state)\n\t\treturn;\n\n\tfree(window_state->OverlayDescription.string);\n\tfree(window_state->titleInfo.string);\n\tfree(window_state->windowRects);\n\tfree(window_state->visibilityRects);\n\tmemset(window_state, 0, sizeof(WINDOW_STATE_ORDER));\n}\n\nrdpUpdate* update_new(rdpRdp* rdp)\n{\n\tconst wObject cb = { NULL, NULL, NULL, update_free_queued_message, NULL };\n\trdpUpdate* update;\n\tOFFSCREEN_DELETE_LIST* deleteList;\n\tWINPR_UNUSED(rdp);\n\tupdate = (rdpUpdate*)calloc(1, sizeof(rdpUpdate));\n\n\tif (!update)\n\t\treturn NULL;\n\n\tupdate->log = WLog_Get(\"com.freerdp.core.update\");\n\tInitializeCriticalSection(&(update->mux));\n\tupdate->pointer = (rdpPointerUpdate*)calloc(1, sizeof(rdpPointerUpdate));\n\n\tif (!update->pointer)\n\t\tgoto fail;\n\n\tupdate->primary = (rdpPrimaryUpdate*)calloc(1, sizeof(rdpPrimaryUpdate));\n\n\tif (!update->primary)\n\t\tgoto fail;\n\n\tupdate->secondary = (rdpSecondaryUpdate*)calloc(1, sizeof(rdpSecondaryUpdate));\n\n\tif (!update->secondary)\n\t\tgoto fail;\n\n\tupdate->altsec = (rdpAltSecUpdate*)calloc(1, sizeof(rdpAltSecUpdate));\n\n\tif (!update->altsec)\n\t\tgoto fail;\n\n\tupdate->window = (rdpWindowUpdate*)calloc(1, sizeof(rdpWindowUpdate));\n\n\tif (!update->window)\n\t\tgoto fail;\n\n\tdeleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\tdeleteList->sIndices = 64;\n\tdeleteList->indices = calloc(deleteList->sIndices, 2);\n\n\tif (!deleteList->indices)\n\t\tgoto fail;\n\n\tdeleteList->cIndices = 0;\n\tupdate->SuppressOutput = update_send_suppress_output;\n\tupdate->initialState = TRUE;\n\tupdate->autoCalculateBitmapData = TRUE;\n\tupdate->queue = MessageQueue_New(&cb);\n\n\tif (!update->queue)\n\t\tgoto fail;\n\n\treturn update;\nfail:\n\tupdate_free(update);\n\treturn NULL;\n}\n\nvoid update_free(rdpUpdate* update)\n{\n\tif (update != NULL)\n\t{\n\t\tOFFSCREEN_DELETE_LIST* deleteList = &(update->altsec->create_offscreen_bitmap.deleteList);\n\n\t\tif (deleteList)\n\t\t\tfree(deleteList->indices);\n\n\t\tfree(update->pointer);\n\n\t\tif (update->primary)\n\t\t{\n\t\t\tfree(update->primary->polyline.points);\n\t\t\tfree(update->primary->polygon_sc.points);\n\t\t\tfree(update->primary->fast_glyph.glyphData.aj);\n\t\t\tfree(update->primary);\n\t\t}\n\n\t\tfree(update->secondary);\n\t\tfree(update->altsec);\n\n\t\tif (update->window)\n\t\t{\n\t\t\tfree(update->window);\n\t\t}\n\n\t\tMessageQueue_Free(update->queue);\n\t\tDeleteCriticalSection(&update->mux);\n\t\tfree(update);\n\t}\n}\n\nBOOL update_begin_paint(rdpUpdate* update)\n{\n\tif (!update)\n\t\treturn FALSE;\n\n\tEnterCriticalSection(&update->mux);\n\n\tif (!update->BeginPaint)\n\t\treturn TRUE;\n\n\treturn update->BeginPaint(update->context);\n}\n\nBOOL update_end_paint(rdpUpdate* update)\n{\n\tBOOL rc = FALSE;\n\n\tif (!update)\n\t\treturn FALSE;\n\n\tif (update->EndPaint)\n\t\trc = update->EndPaint(update->context);\n\n\tLeaveCriticalSection(&update->mux);\n\treturn rc;\n}\n"], "filenames": ["libfreerdp/core/update.c"], "buggy_code_start_loc": [290], "buggy_code_end_loc": [811], "fixing_code_start_loc": [290], "fixing_code_end_loc": [812], "type": "CWE-119", "message": "In FreeRDP after 1.0 and before 2.0.0, there is a stream out-of-bounds seek in update_read_synchronize that could lead to a later out-of-bounds read.", "other": {"cve": {"id": "CVE-2020-11046", "sourceIdentifier": "security-advisories@github.com", "published": "2020-05-07T19:15:11.843", "lastModified": "2021-09-14T18:15:56.017", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP after 1.0 and before 2.0.0, there is a stream out-of-bounds seek in update_read_synchronize that could lead to a later out-of-bounds read."}, {"lang": "es", "value": "En FreeRDP versiones posteriores a 1.0 y versiones anteriores a 2.0.0, se presenta una b\u00fasqueda fuera de l\u00edmites de flujo de datos en update_read_synchronize que podr\u00eda conllevar a una lectura posterior fuera de l\u00edmites."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.2, "baseSeverity": "LOW"}, "exploitabilityScore": 0.7, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.3, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionStartExcluding": "1.0.0", "versionEndExcluding": "2.0.0", "matchCriteriaId": "BB5FC56A-970D-4AE5-A27E-EFD567E17449"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/ed53cd148f43cbab905eaa0f5308c2bf3c48cc37", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/issues/6006", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-hx48-wmmm-mr5q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00054.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4379-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4382-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/ed53cd148f43cbab905eaa0f5308c2bf3c48cc37"}}