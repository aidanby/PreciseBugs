{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Glyph Cache\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n\n#include <winpr/crt.h>\n\n#include <freerdp/freerdp.h>\n#include <winpr/stream.h>\n\n#include <freerdp/log.h>\n#include <freerdp/cache/glyph.h>\n\n#include \"glyph.h\"\n\n#define TAG FREERDP_TAG(\"cache.glyph\")\n\nstatic rdpGlyph* glyph_cache_get(rdpGlyphCache* glyph_cache, UINT32 id, UINT32 index);\nstatic BOOL glyph_cache_put(rdpGlyphCache* glyph_cache, UINT32 id, UINT32 index, rdpGlyph* entry);\n\nstatic const void* glyph_cache_fragment_get(rdpGlyphCache* glyph, UINT32 index, UINT32* count);\nstatic BOOL glyph_cache_fragment_put(rdpGlyphCache* glyph, UINT32 index, UINT32 count,\n                                     const void* entry);\n\nstatic UINT32 update_glyph_offset(const BYTE* data, size_t length, UINT32 index, INT32* x, INT32* y,\n                                  UINT32 ulCharInc, UINT32 flAccel)\n{\n\tif ((ulCharInc == 0) && (!(flAccel & SO_CHAR_INC_EQUAL_BM_BASE)))\n\t{\n\t\tUINT32 offset = data[index++];\n\n\t\tif (offset & 0x80)\n\t\t{\n\n\t\t\tif (index + 1 < length)\n\t\t\t{\n\t\t\t\toffset = data[index++];\n\t\t\t\toffset |= ((UINT32)data[index++]) << 8;\n\t\t\t}\n\t\t\telse\n\t\t\t\tWLog_WARN(TAG, \"[%s] glyph index out of bound %\" PRIu32 \" [max %\" PRIuz \"]\", index,\n\t\t\t\t          length);\n\t\t}\n\n\t\tif (flAccel & SO_VERTICAL)\n\t\t\t*y += offset;\n\n\t\tif (flAccel & SO_HORIZONTAL)\n\t\t\t*x += offset;\n\t}\n\n\treturn index;\n}\n\nstatic BOOL update_process_glyph(rdpContext* context, const BYTE* data, UINT32 cacheIndex, INT32* x,\n                                 INT32* y, UINT32 cacheId, UINT32 flAccel, BOOL fOpRedundant,\n                                 const RDP_RECT* bound)\n{\n\tINT32 sx = 0, sy = 0;\n\tINT32 dx, dy;\n\trdpGlyph* glyph;\n\trdpGlyphCache* glyph_cache;\n\n\tif (!context || !data || !x || !y || !context->graphics || !context->cache ||\n\t    !context->cache->glyph)\n\t\treturn FALSE;\n\n\tglyph_cache = context->cache->glyph;\n\tglyph = glyph_cache_get(glyph_cache, cacheId, cacheIndex);\n\n\tif (!glyph)\n\t\treturn FALSE;\n\n\tdx = glyph->x + *x;\n\tdy = glyph->y + *y;\n\n\tif (dx < bound->x)\n\t{\n\t\tsx = bound->x - dx;\n\t\tdx = bound->x;\n\t}\n\n\tif (dy < bound->y)\n\t{\n\t\tsy = bound->y - dy;\n\t\tdy = bound->y;\n\t}\n\n\tif ((dx <= (bound->x + bound->width)) && (dy <= (bound->y + bound->height)))\n\t{\n\t\tINT32 dw = glyph->cx - sx;\n\t\tINT32 dh = glyph->cy - sy;\n\n\t\tif ((dw + dx) > (bound->x + bound->width))\n\t\t\tdw = (bound->x + bound->width) - (dw + dx);\n\n\t\tif ((dh + dy) > (bound->y + bound->height))\n\t\t\tdh = (bound->y + bound->height) - (dh + dy);\n\n\t\tif ((dh > 0) && (dw > 0))\n\t\t{\n\t\t\tif (!glyph->Draw(context, glyph, dx, dy, dw, dh, sx, sy, fOpRedundant))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (flAccel & SO_CHAR_INC_EQUAL_BM_BASE)\n\t\t*x += glyph->cx;\n\n\treturn TRUE;\n}\n\nstatic BOOL update_process_glyph_fragments(rdpContext* context, const BYTE* data, UINT32 length,\n                                           UINT32 cacheId, UINT32 ulCharInc, UINT32 flAccel,\n                                           UINT32 bgcolor, UINT32 fgcolor, INT32 x, INT32 y,\n                                           INT32 bkX, INT32 bkY, INT32 bkWidth, INT32 bkHeight,\n                                           INT32 opX, INT32 opY, INT32 opWidth, INT32 opHeight,\n                                           BOOL fOpRedundant)\n{\n\tUINT32 n;\n\tUINT32 id;\n\tUINT32 size;\n\tUINT32 index = 0;\n\tBYTE* fragments;\n\trdpGraphics* graphics;\n\trdpGlyphCache* glyph_cache;\n\trdpGlyph* glyph;\n\tRDP_RECT bound;\n\n\tif (!context || !data || !context->graphics || !context->cache || !context->cache->glyph)\n\t\treturn FALSE;\n\n\tgraphics = context->graphics;\n\tglyph_cache = context->cache->glyph;\n\tglyph = graphics->Glyph_Prototype;\n\n\tif (!glyph)\n\t\treturn FALSE;\n\n\t/* Limit op rectangle to visible screen. */\n\tif (opX < 0)\n\t{\n\t\topWidth += opX;\n\t\topX = 0;\n\t}\n\n\tif (opY < 0)\n\t{\n\t\topHeight += opY;\n\t\topY = 0;\n\t}\n\n\tif (opWidth < 0)\n\t\topWidth = 0;\n\n\tif (opHeight < 0)\n\t\topHeight = 0;\n\n\t/* Limit bk rectangle to visible screen. */\n\tif (bkX < 0)\n\t{\n\t\tbkWidth += bkX;\n\t\tbkX = 0;\n\t}\n\n\tif (bkY < 0)\n\t{\n\t\tbkHeight += bkY;\n\t\tbkY = 0;\n\t}\n\n\tif (bkWidth < 0)\n\t\tbkWidth = 0;\n\n\tif (bkHeight < 0)\n\t\tbkHeight = 0;\n\n\tif (opX + opWidth > (INT64)context->settings->DesktopWidth)\n\t{\n\t\t/**\n\t\t * Some Microsoft servers send erroneous high values close to the\n\t\t * sint16 maximum in the OpRight field of the GlyphIndex, FastIndex and\n\t\t * FastGlyph drawing orders, probably a result of applications trying to\n\t\t * clear the text line to the very right end.\n\t\t * One example where this can be seen is typing in notepad.exe within\n\t\t * a RDP session to Windows XP Professional SP3.\n\t\t * This workaround prevents resulting problems in the UI callbacks.\n\t\t */\n\t\topWidth = context->settings->DesktopWidth - opX;\n\t}\n\n\tif (bkX + bkWidth > (INT64)context->settings->DesktopWidth)\n\t{\n\t\t/**\n\t\t * Some Microsoft servers send erroneous high values close to the\n\t\t * sint16 maximum in the OpRight field of the GlyphIndex, FastIndex and\n\t\t * FastGlyph drawing orders, probably a result of applications trying to\n\t\t * clear the text line to the very right end.\n\t\t * One example where this can be seen is typing in notepad.exe within\n\t\t * a RDP session to Windows XP Professional SP3.\n\t\t * This workaround prevents resulting problems in the UI callbacks.\n\t\t */\n\t\tbkWidth = context->settings->DesktopWidth - bkX;\n\t}\n\n\tbound.x = bkX;\n\tbound.y = bkY;\n\tbound.width = bkWidth;\n\tbound.height = bkHeight;\n\n\tif (!glyph->BeginDraw(context, opX, opY, opWidth, opHeight, bgcolor, fgcolor, fOpRedundant))\n\t\treturn FALSE;\n\n\tif (!IFCALLRESULT(TRUE, glyph->SetBounds, context, bkX, bkY, bkWidth, bkHeight))\n\t\treturn FALSE;\n\n\twhile (index < length)\n\t{\n\t\tconst UINT32 op = data[index++];\n\n\t\tswitch (op)\n\t\t{\n\t\t\tcase GLYPH_FRAGMENT_USE:\n\t\t\t\tif (index + 1 >= length)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tid = data[index++];\n\t\t\t\tfragments = (BYTE*)glyph_cache_fragment_get(glyph_cache, id, &size);\n\n\t\t\t\tif (fragments == NULL)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tfor (n = 0; n < size;)\n\t\t\t\t{\n\t\t\t\t\tconst UINT32 fop = fragments[n++];\n\t\t\t\t\tn = update_glyph_offset(fragments, size, n, &x, &y, ulCharInc, flAccel);\n\n\t\t\t\t\tif (!update_process_glyph(context, fragments, fop, &x, &y, cacheId, flAccel,\n\t\t\t\t\t                          fOpRedundant, &bound))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase GLYPH_FRAGMENT_ADD:\n\t\t\t\tif (index + 2 > length)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tid = data[index++];\n\t\t\t\tsize = data[index++];\n\t\t\t\tglyph_cache_fragment_put(glyph_cache, id, size, data);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tindex = update_glyph_offset(data, length, index, &x, &y, ulCharInc, flAccel);\n\n\t\t\t\tif (!update_process_glyph(context, data, op, &x, &y, cacheId, flAccel, fOpRedundant,\n\t\t\t\t                          &bound))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn glyph->EndDraw(context, opX, opY, opWidth, opHeight, bgcolor, fgcolor);\n}\n\nstatic BOOL update_gdi_glyph_index(rdpContext* context, GLYPH_INDEX_ORDER* glyphIndex)\n{\n\tINT32 bkWidth = 0, bkHeight = 0, opWidth = 0, opHeight = 0;\n\n\tif (!context || !glyphIndex || !context->cache)\n\t\treturn FALSE;\n\n\tif (glyphIndex->bkRight > glyphIndex->bkLeft)\n\t\tbkWidth = glyphIndex->bkRight - glyphIndex->bkLeft + 1;\n\n\tif (glyphIndex->opRight > glyphIndex->opLeft)\n\t\topWidth = glyphIndex->opRight - glyphIndex->opLeft + 1;\n\n\tif (glyphIndex->bkBottom > glyphIndex->bkTop)\n\t\tbkHeight = glyphIndex->bkBottom - glyphIndex->bkTop + 1;\n\n\tif (glyphIndex->opBottom > glyphIndex->opTop)\n\t\topHeight = glyphIndex->opBottom - glyphIndex->opTop + 1;\n\n\treturn update_process_glyph_fragments(\n\t    context, glyphIndex->data, glyphIndex->cbData, glyphIndex->cacheId, glyphIndex->ulCharInc,\n\t    glyphIndex->flAccel, glyphIndex->backColor, glyphIndex->foreColor, glyphIndex->x,\n\t    glyphIndex->y, glyphIndex->bkLeft, glyphIndex->bkTop, bkWidth, bkHeight, glyphIndex->opLeft,\n\t    glyphIndex->opTop, opWidth, opHeight, glyphIndex->fOpRedundant);\n}\n\nstatic BOOL update_gdi_fast_index(rdpContext* context, const FAST_INDEX_ORDER* fastIndex)\n{\n\tINT32 x, y;\n\tINT32 opLeft, opTop;\n\tINT32 opRight, opBottom;\n\tINT32 opWidth = 0, opHeight = 0;\n\tINT32 bkWidth = 0, bkHeight = 0;\n\n\tif (!context || !fastIndex || !context->cache)\n\t\treturn FALSE;\n\n\topLeft = fastIndex->opLeft;\n\topTop = fastIndex->opTop;\n\topRight = fastIndex->opRight;\n\topBottom = fastIndex->opBottom;\n\tx = fastIndex->x;\n\ty = fastIndex->y;\n\n\tif (opBottom == -32768)\n\t{\n\t\tBYTE flags = (BYTE)(opTop & 0x0F);\n\n\t\tif (flags & 0x01)\n\t\t\topBottom = fastIndex->bkBottom;\n\n\t\tif (flags & 0x02)\n\t\t\topRight = fastIndex->bkRight;\n\n\t\tif (flags & 0x04)\n\t\t\topTop = fastIndex->bkTop;\n\n\t\tif (flags & 0x08)\n\t\t\topLeft = fastIndex->bkLeft;\n\t}\n\n\tif (opLeft == 0)\n\t\topLeft = fastIndex->bkLeft;\n\n\tif (opRight == 0)\n\t\topRight = fastIndex->bkRight;\n\n\t/* Server can send a massive number (32766) which appears to be\n\t * undocumented special behavior for \"Erase all the way right\".\n\t * X11 has nondeterministic results asking for a draw that wide. */\n\tif (opRight > (INT64)context->instance->settings->DesktopWidth)\n\t\topRight = (int)context->instance->settings->DesktopWidth;\n\n\tif (x == -32768)\n\t\tx = fastIndex->bkLeft;\n\n\tif (y == -32768)\n\t\ty = fastIndex->bkTop;\n\n\tif (fastIndex->bkRight > fastIndex->bkLeft)\n\t\tbkWidth = fastIndex->bkRight - fastIndex->bkLeft + 1;\n\n\tif (fastIndex->bkBottom > fastIndex->bkTop)\n\t\tbkHeight = fastIndex->bkBottom - fastIndex->bkTop + 1;\n\n\tif (opRight > opLeft)\n\t\topWidth = opRight - opLeft + 1;\n\n\tif (opBottom > opTop)\n\t\topHeight = opBottom - opTop + 1;\n\n\treturn update_process_glyph_fragments(\n\t    context, fastIndex->data, fastIndex->cbData, fastIndex->cacheId, fastIndex->ulCharInc,\n\t    fastIndex->flAccel, fastIndex->backColor, fastIndex->foreColor, x, y, fastIndex->bkLeft,\n\t    fastIndex->bkTop, bkWidth, bkHeight, opLeft, opTop, opWidth, opHeight, FALSE);\n}\n\nstatic BOOL update_gdi_fast_glyph(rdpContext* context, const FAST_GLYPH_ORDER* fastGlyph)\n{\n\tINT32 x, y;\n\tBYTE text_data[4] = { 0 };\n\tINT32 opLeft, opTop;\n\tINT32 opRight, opBottom;\n\tINT32 opWidth = 0, opHeight = 0;\n\tINT32 bkWidth = 0, bkHeight = 0;\n\trdpCache* cache;\n\n\tif (!context || !fastGlyph || !context->cache)\n\t\treturn FALSE;\n\n\tcache = context->cache;\n\topLeft = fastGlyph->opLeft;\n\topTop = fastGlyph->opTop;\n\topRight = fastGlyph->opRight;\n\topBottom = fastGlyph->opBottom;\n\tx = fastGlyph->x;\n\ty = fastGlyph->y;\n\n\tif (opBottom == -32768)\n\t{\n\t\tBYTE flags = (BYTE)(opTop & 0x0F);\n\n\t\tif (flags & 0x01)\n\t\t\topBottom = fastGlyph->bkBottom;\n\n\t\tif (flags & 0x02)\n\t\t\topRight = fastGlyph->bkRight;\n\n\t\tif (flags & 0x04)\n\t\t\topTop = fastGlyph->bkTop;\n\n\t\tif (flags & 0x08)\n\t\t\topLeft = fastGlyph->bkLeft;\n\t}\n\n\tif (opLeft == 0)\n\t\topLeft = fastGlyph->bkLeft;\n\n\tif (opRight == 0)\n\t\topRight = fastGlyph->bkRight;\n\n\t/* See update_gdi_fast_index opRight comment. */\n\tif (opRight > (INT64)context->instance->settings->DesktopWidth)\n\t\topRight = (int)context->instance->settings->DesktopWidth;\n\n\tif (x == -32768)\n\t\tx = fastGlyph->bkLeft;\n\n\tif (y == -32768)\n\t\ty = fastGlyph->bkTop;\n\n\tif ((fastGlyph->cbData > 1) && (fastGlyph->glyphData.aj))\n\t{\n\t\t/* got option font that needs to go into cache */\n\t\trdpGlyph* glyph;\n\t\tconst GLYPH_DATA_V2* glyphData = &fastGlyph->glyphData;\n\n\t\tglyph = Glyph_Alloc(context, glyphData->x, glyphData->y, glyphData->cx, glyphData->cy,\n\t\t                    glyphData->cb, glyphData->aj);\n\n\t\tif (!glyph)\n\t\t\treturn FALSE;\n\n\t\tif (!glyph_cache_put(cache->glyph, fastGlyph->cacheId, fastGlyph->data[0], glyph))\n\t\t{\n\t\t\tglyph->Free(context, glyph);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\ttext_data[0] = fastGlyph->data[0];\n\ttext_data[1] = 0;\n\n\tif (fastGlyph->bkRight > fastGlyph->bkLeft)\n\t\tbkWidth = fastGlyph->bkRight - fastGlyph->bkLeft + 1;\n\n\tif (fastGlyph->bkBottom > fastGlyph->bkTop)\n\t\tbkHeight = fastGlyph->bkBottom - fastGlyph->bkTop + 1;\n\n\tif (opRight > opLeft)\n\t\topWidth = opRight - opLeft + 1;\n\n\tif (opBottom > opTop)\n\t\topHeight = opBottom - opTop + 1;\n\n\treturn update_process_glyph_fragments(\n\t    context, text_data, sizeof(text_data), fastGlyph->cacheId, fastGlyph->ulCharInc,\n\t    fastGlyph->flAccel, fastGlyph->backColor, fastGlyph->foreColor, x, y, fastGlyph->bkLeft,\n\t    fastGlyph->bkTop, bkWidth, bkHeight, opLeft, opTop, opWidth, opHeight, FALSE);\n}\n\nstatic BOOL update_gdi_cache_glyph(rdpContext* context, const CACHE_GLYPH_ORDER* cacheGlyph)\n{\n\tUINT32 i;\n\trdpCache* cache;\n\n\tif (!context || !cacheGlyph || !context->cache)\n\t\treturn FALSE;\n\n\tcache = context->cache;\n\n\tfor (i = 0; i < cacheGlyph->cGlyphs; i++)\n\t{\n\t\tconst GLYPH_DATA* glyph_data = &cacheGlyph->glyphData[i];\n\t\trdpGlyph* glyph;\n\n\t\tif (!glyph_data)\n\t\t\treturn FALSE;\n\n\t\tif (!(glyph = Glyph_Alloc(context, glyph_data->x, glyph_data->y, glyph_data->cx,\n\t\t                          glyph_data->cy, glyph_data->cb, glyph_data->aj)))\n\t\t\treturn FALSE;\n\n\t\tif (!glyph_cache_put(cache->glyph, cacheGlyph->cacheId, glyph_data->cacheIndex, glyph))\n\t\t{\n\t\t\tglyph->Free(context, glyph);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_gdi_cache_glyph_v2(rdpContext* context, const CACHE_GLYPH_V2_ORDER* cacheGlyphV2)\n{\n\tUINT32 i;\n\trdpCache* cache;\n\n\tif (!context || !cacheGlyphV2 || !context->cache)\n\t\treturn FALSE;\n\n\tcache = context->cache;\n\n\tfor (i = 0; i < cacheGlyphV2->cGlyphs; i++)\n\t{\n\t\tconst GLYPH_DATA_V2* glyphData = &cacheGlyphV2->glyphData[i];\n\t\trdpGlyph* glyph;\n\n\t\tif (!glyphData)\n\t\t\treturn FALSE;\n\n\t\tglyph = Glyph_Alloc(context, glyphData->x, glyphData->y, glyphData->cx, glyphData->cy,\n\t\t                    glyphData->cb, glyphData->aj);\n\n\t\tif (!glyph)\n\t\t\treturn FALSE;\n\n\t\tif (!glyph_cache_put(cache->glyph, cacheGlyphV2->cacheId, glyphData->cacheIndex, glyph))\n\t\t{\n\t\t\tglyph->Free(context, glyph);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nrdpGlyph* glyph_cache_get(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index)\n{\n\trdpGlyph* glyph;\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCacheGet: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn NULL;\n\t}\n\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"index %\" PRIu32 \" out of range for cache id: %\" PRIu32 \"\", index, id);\n\t\treturn NULL;\n\t}\n\n\tglyph = glyphCache->glyphCache[id].entries[index];\n\n\tif (!glyph)\n\t\tWLog_ERR(TAG, \"no glyph found at cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index,\n\t\t         id);\n\n\treturn glyph;\n}\n\nBOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}\n\nconst void* glyph_cache_fragment_get(rdpGlyphCache* glyphCache, UINT32 index, UINT32* size)\n{\n\tvoid* fragment;\n\n\tif (index > 255)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache fragment index: %\" PRIu32 \"\", index);\n\t\treturn NULL;\n\t}\n\n\tfragment = glyphCache->fragCache.entries[index].fragment;\n\t*size = (BYTE)glyphCache->fragCache.entries[index].size;\n\tWLog_Print(glyphCache->log, WLOG_DEBUG,\n\t           \"GlyphCacheFragmentGet: index: %\" PRIu32 \" size: %\" PRIu32 \"\", index, *size);\n\n\tif (!fragment)\n\t\tWLog_ERR(TAG, \"invalid glyph fragment at index:%\" PRIu32 \"\", index);\n\n\treturn fragment;\n}\n\nBOOL glyph_cache_fragment_put(rdpGlyphCache* glyphCache, UINT32 index, UINT32 size,\n                              const void* fragment)\n{\n\tvoid* prevFragment;\n\tvoid* copy;\n\n\tif (index > 255)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache fragment index: %\" PRIu32 \"\", index);\n\t\treturn FALSE;\n\t}\n\n\tcopy = malloc(size);\n\n\tif (!copy)\n\t\treturn FALSE;\n\n\tWLog_Print(glyphCache->log, WLOG_DEBUG,\n\t           \"GlyphCacheFragmentPut: index: %\" PRIu32 \" size: %\" PRIu32 \"\", index, size);\n\tCopyMemory(copy, fragment, size);\n\tprevFragment = glyphCache->fragCache.entries[index].fragment;\n\tglyphCache->fragCache.entries[index].fragment = copy;\n\tglyphCache->fragCache.entries[index].size = size;\n\tfree(prevFragment);\n\treturn TRUE;\n}\n\nvoid glyph_cache_register_callbacks(rdpUpdate* update)\n{\n\tupdate->primary->GlyphIndex = update_gdi_glyph_index;\n\tupdate->primary->FastIndex = update_gdi_fast_index;\n\tupdate->primary->FastGlyph = update_gdi_fast_glyph;\n\tupdate->secondary->CacheGlyph = update_gdi_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_gdi_cache_glyph_v2;\n}\n\nrdpGlyphCache* glyph_cache_new(rdpSettings* settings)\n{\n\tint i;\n\trdpGlyphCache* glyphCache;\n\tglyphCache = (rdpGlyphCache*)calloc(1, sizeof(rdpGlyphCache));\n\n\tif (!glyphCache)\n\t\treturn NULL;\n\n\tglyphCache->log = WLog_Get(\"com.freerdp.cache.glyph\");\n\tglyphCache->settings = settings;\n\tglyphCache->context = ((freerdp*)settings->instance)->update->context;\n\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tglyphCache->glyphCache[i].number = settings->GlyphCache[i].cacheEntries;\n\t\tglyphCache->glyphCache[i].maxCellSize = settings->GlyphCache[i].cacheMaximumCellSize;\n\t\tglyphCache->glyphCache[i].entries =\n\t\t    (rdpGlyph**)calloc(glyphCache->glyphCache[i].number, sizeof(rdpGlyph*));\n\n\t\tif (!glyphCache->glyphCache[i].entries)\n\t\t\tgoto fail;\n\t}\n\n\tglyphCache->fragCache.entries = calloc(256, sizeof(FRAGMENT_CACHE_ENTRY));\n\n\tif (!glyphCache->fragCache.entries)\n\t\tgoto fail;\n\n\treturn glyphCache;\nfail:\n\tglyph_cache_free(glyphCache);\n\treturn NULL;\n}\n\nvoid glyph_cache_free(rdpGlyphCache* glyphCache)\n{\n\tif (glyphCache)\n\t{\n\t\tint i;\n\t\tGLYPH_CACHE* cache = glyphCache->glyphCache;\n\n\t\tfor (i = 0; i < 10; i++)\n\t\t{\n\t\t\tUINT32 j;\n\t\t\trdpGlyph** entries = cache[i].entries;\n\n\t\t\tif (!entries)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < cache[i].number; j++)\n\t\t\t{\n\t\t\t\trdpGlyph* glyph = entries[j];\n\n\t\t\t\tif (glyph)\n\t\t\t\t{\n\t\t\t\t\tglyph->Free(glyphCache->context, glyph);\n\t\t\t\t\tentries[j] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfree(entries);\n\t\t\tcache[i].entries = NULL;\n\t\t}\n\n\t\tif (glyphCache->fragCache.entries)\n\t\t{\n\t\t\tfor (i = 0; i < 256; i++)\n\t\t\t{\n\t\t\t\tfree(glyphCache->fragCache.entries[i].fragment);\n\t\t\t\tglyphCache->fragCache.entries[i].fragment = NULL;\n\t\t\t}\n\t\t}\n\n\t\tfree(glyphCache->fragCache.entries);\n\t\tfree(glyphCache);\n\t}\n}\n\nCACHE_GLYPH_ORDER* copy_cache_glyph_order(rdpContext* context, const CACHE_GLYPH_ORDER* glyph)\n{\n\tsize_t x;\n\tCACHE_GLYPH_ORDER* dst = calloc(1, sizeof(CACHE_GLYPH_ORDER));\n\n\tif (!dst || !glyph)\n\t\tgoto fail;\n\n\t*dst = *glyph;\n\n\tfor (x = 0; x < glyph->cGlyphs; x++)\n\t{\n\t\tconst GLYPH_DATA* src = &glyph->glyphData[x];\n\t\tGLYPH_DATA* data = &dst->glyphData[x];\n\n\t\tif (src->aj)\n\t\t{\n\t\t\tconst size_t size = src->cb;\n\t\t\tdata->aj = malloc(size);\n\n\t\t\tif (!data->aj)\n\t\t\t\tgoto fail;\n\n\t\t\tmemcpy(data->aj, src->aj, size);\n\t\t}\n\t}\n\n\tif (glyph->unicodeCharacters)\n\t{\n\t\tif (glyph->cGlyphs == 0)\n\t\t\tgoto fail;\n\n\t\tdst->unicodeCharacters = calloc(glyph->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!dst->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tmemcpy(dst->unicodeCharacters, glyph->unicodeCharacters, sizeof(WCHAR) * glyph->cGlyphs);\n\t}\n\n\treturn dst;\nfail:\n\tfree_cache_glyph_order(context, dst);\n\treturn NULL;\n}\n\nvoid free_cache_glyph_order(rdpContext* context, CACHE_GLYPH_ORDER* glyph)\n{\n\tif (glyph)\n\t{\n\t\tsize_t x;\n\n\t\tfor (x = 0; x < ARRAYSIZE(glyph->glyphData); x++)\n\t\t\tfree(glyph->glyphData[x].aj);\n\n\t\tfree(glyph->unicodeCharacters);\n\t}\n\n\tfree(glyph);\n}\n\nCACHE_GLYPH_V2_ORDER* copy_cache_glyph_v2_order(rdpContext* context,\n                                                const CACHE_GLYPH_V2_ORDER* glyph)\n{\n\tsize_t x;\n\tCACHE_GLYPH_V2_ORDER* dst = calloc(1, sizeof(CACHE_GLYPH_V2_ORDER));\n\n\tif (!dst || !glyph)\n\t\tgoto fail;\n\n\t*dst = *glyph;\n\n\tfor (x = 0; x < glyph->cGlyphs; x++)\n\t{\n\t\tconst GLYPH_DATA_V2* src = &glyph->glyphData[x];\n\t\tGLYPH_DATA_V2* data = &dst->glyphData[x];\n\n\t\tif (src->aj)\n\t\t{\n\t\t\tconst size_t size = src->cb;\n\t\t\tdata->aj = malloc(size);\n\n\t\t\tif (!data->aj)\n\t\t\t\tgoto fail;\n\n\t\t\tmemcpy(data->aj, src->aj, size);\n\t\t}\n\t}\n\n\tif (glyph->unicodeCharacters)\n\t{\n\t\tif (glyph->cGlyphs == 0)\n\t\t\tgoto fail;\n\n\t\tdst->unicodeCharacters = calloc(glyph->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!dst->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tmemcpy(dst->unicodeCharacters, glyph->unicodeCharacters, sizeof(WCHAR) * glyph->cGlyphs);\n\t}\n\n\treturn dst;\nfail:\n\tfree_cache_glyph_v2_order(context, dst);\n\treturn NULL;\n}\n\nvoid free_cache_glyph_v2_order(rdpContext* context, CACHE_GLYPH_V2_ORDER* glyph)\n{\n\tif (glyph)\n\t{\n\t\tsize_t x;\n\n\t\tfor (x = 0; x < ARRAYSIZE(glyph->glyphData); x++)\n\t\t\tfree(glyph->glyphData[x].aj);\n\n\t\tfree(glyph->unicodeCharacters);\n\t}\n\n\tfree(glyph);\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Glyph Cache\n *\n * Copyright 2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n\n#include <winpr/crt.h>\n\n#include <freerdp/freerdp.h>\n#include <winpr/stream.h>\n\n#include <freerdp/log.h>\n#include <freerdp/cache/glyph.h>\n\n#include \"glyph.h\"\n\n#define TAG FREERDP_TAG(\"cache.glyph\")\n\nstatic rdpGlyph* glyph_cache_get(rdpGlyphCache* glyph_cache, UINT32 id, UINT32 index);\nstatic BOOL glyph_cache_put(rdpGlyphCache* glyph_cache, UINT32 id, UINT32 index, rdpGlyph* entry);\n\nstatic const void* glyph_cache_fragment_get(rdpGlyphCache* glyph, UINT32 index, UINT32* count);\nstatic BOOL glyph_cache_fragment_put(rdpGlyphCache* glyph, UINT32 index, UINT32 count,\n                                     const void* entry);\n\nstatic UINT32 update_glyph_offset(const BYTE* data, size_t length, UINT32 index, INT32* x, INT32* y,\n                                  UINT32 ulCharInc, UINT32 flAccel)\n{\n\tif ((ulCharInc == 0) && (!(flAccel & SO_CHAR_INC_EQUAL_BM_BASE)))\n\t{\n\t\tUINT32 offset = data[index++];\n\n\t\tif (offset & 0x80)\n\t\t{\n\n\t\t\tif (index + 1 < length)\n\t\t\t{\n\t\t\t\toffset = data[index++];\n\t\t\t\toffset |= ((UINT32)data[index++]) << 8;\n\t\t\t}\n\t\t\telse\n\t\t\t\tWLog_WARN(TAG, \"[%s] glyph index out of bound %\" PRIu32 \" [max %\" PRIuz \"]\", index,\n\t\t\t\t          length);\n\t\t}\n\n\t\tif (flAccel & SO_VERTICAL)\n\t\t\t*y += offset;\n\n\t\tif (flAccel & SO_HORIZONTAL)\n\t\t\t*x += offset;\n\t}\n\n\treturn index;\n}\n\nstatic BOOL update_process_glyph(rdpContext* context, const BYTE* data, UINT32 cacheIndex, INT32* x,\n                                 INT32* y, UINT32 cacheId, UINT32 flAccel, BOOL fOpRedundant,\n                                 const RDP_RECT* bound)\n{\n\tINT32 sx = 0, sy = 0;\n\tINT32 dx, dy;\n\trdpGlyph* glyph;\n\trdpGlyphCache* glyph_cache;\n\n\tif (!context || !data || !x || !y || !context->graphics || !context->cache ||\n\t    !context->cache->glyph)\n\t\treturn FALSE;\n\n\tglyph_cache = context->cache->glyph;\n\tglyph = glyph_cache_get(glyph_cache, cacheId, cacheIndex);\n\n\tif (!glyph)\n\t\treturn FALSE;\n\n\tdx = glyph->x + *x;\n\tdy = glyph->y + *y;\n\n\tif (dx < bound->x)\n\t{\n\t\tsx = bound->x - dx;\n\t\tdx = bound->x;\n\t}\n\n\tif (dy < bound->y)\n\t{\n\t\tsy = bound->y - dy;\n\t\tdy = bound->y;\n\t}\n\n\tif ((dx <= (bound->x + bound->width)) && (dy <= (bound->y + bound->height)))\n\t{\n\t\tINT32 dw = glyph->cx - sx;\n\t\tINT32 dh = glyph->cy - sy;\n\n\t\tif ((dw + dx) > (bound->x + bound->width))\n\t\t\tdw = (bound->x + bound->width) - (dw + dx);\n\n\t\tif ((dh + dy) > (bound->y + bound->height))\n\t\t\tdh = (bound->y + bound->height) - (dh + dy);\n\n\t\tif ((dh > 0) && (dw > 0))\n\t\t{\n\t\t\tif (!glyph->Draw(context, glyph, dx, dy, dw, dh, sx, sy, fOpRedundant))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tif (flAccel & SO_CHAR_INC_EQUAL_BM_BASE)\n\t\t*x += glyph->cx;\n\n\treturn TRUE;\n}\n\nstatic BOOL update_process_glyph_fragments(rdpContext* context, const BYTE* data, UINT32 length,\n                                           UINT32 cacheId, UINT32 ulCharInc, UINT32 flAccel,\n                                           UINT32 bgcolor, UINT32 fgcolor, INT32 x, INT32 y,\n                                           INT32 bkX, INT32 bkY, INT32 bkWidth, INT32 bkHeight,\n                                           INT32 opX, INT32 opY, INT32 opWidth, INT32 opHeight,\n                                           BOOL fOpRedundant)\n{\n\tUINT32 n;\n\tUINT32 id;\n\tUINT32 size;\n\tUINT32 index = 0;\n\tBYTE* fragments;\n\trdpGraphics* graphics;\n\trdpGlyphCache* glyph_cache;\n\trdpGlyph* glyph;\n\tRDP_RECT bound;\n\n\tif (!context || !data || !context->graphics || !context->cache || !context->cache->glyph)\n\t\treturn FALSE;\n\n\tgraphics = context->graphics;\n\tglyph_cache = context->cache->glyph;\n\tglyph = graphics->Glyph_Prototype;\n\n\tif (!glyph)\n\t\treturn FALSE;\n\n\t/* Limit op rectangle to visible screen. */\n\tif (opX < 0)\n\t{\n\t\topWidth += opX;\n\t\topX = 0;\n\t}\n\n\tif (opY < 0)\n\t{\n\t\topHeight += opY;\n\t\topY = 0;\n\t}\n\n\tif (opWidth < 0)\n\t\topWidth = 0;\n\n\tif (opHeight < 0)\n\t\topHeight = 0;\n\n\t/* Limit bk rectangle to visible screen. */\n\tif (bkX < 0)\n\t{\n\t\tbkWidth += bkX;\n\t\tbkX = 0;\n\t}\n\n\tif (bkY < 0)\n\t{\n\t\tbkHeight += bkY;\n\t\tbkY = 0;\n\t}\n\n\tif (bkWidth < 0)\n\t\tbkWidth = 0;\n\n\tif (bkHeight < 0)\n\t\tbkHeight = 0;\n\n\tif (opX + opWidth > (INT64)context->settings->DesktopWidth)\n\t{\n\t\t/**\n\t\t * Some Microsoft servers send erroneous high values close to the\n\t\t * sint16 maximum in the OpRight field of the GlyphIndex, FastIndex and\n\t\t * FastGlyph drawing orders, probably a result of applications trying to\n\t\t * clear the text line to the very right end.\n\t\t * One example where this can be seen is typing in notepad.exe within\n\t\t * a RDP session to Windows XP Professional SP3.\n\t\t * This workaround prevents resulting problems in the UI callbacks.\n\t\t */\n\t\topWidth = context->settings->DesktopWidth - opX;\n\t}\n\n\tif (bkX + bkWidth > (INT64)context->settings->DesktopWidth)\n\t{\n\t\t/**\n\t\t * Some Microsoft servers send erroneous high values close to the\n\t\t * sint16 maximum in the OpRight field of the GlyphIndex, FastIndex and\n\t\t * FastGlyph drawing orders, probably a result of applications trying to\n\t\t * clear the text line to the very right end.\n\t\t * One example where this can be seen is typing in notepad.exe within\n\t\t * a RDP session to Windows XP Professional SP3.\n\t\t * This workaround prevents resulting problems in the UI callbacks.\n\t\t */\n\t\tbkWidth = context->settings->DesktopWidth - bkX;\n\t}\n\n\tbound.x = bkX;\n\tbound.y = bkY;\n\tbound.width = bkWidth;\n\tbound.height = bkHeight;\n\n\tif (!glyph->BeginDraw(context, opX, opY, opWidth, opHeight, bgcolor, fgcolor, fOpRedundant))\n\t\treturn FALSE;\n\n\tif (!IFCALLRESULT(TRUE, glyph->SetBounds, context, bkX, bkY, bkWidth, bkHeight))\n\t\treturn FALSE;\n\n\twhile (index < length)\n\t{\n\t\tconst UINT32 op = data[index++];\n\n\t\tswitch (op)\n\t\t{\n\t\t\tcase GLYPH_FRAGMENT_USE:\n\t\t\t\tif (index + 1 >= length)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tid = data[index++];\n\t\t\t\tfragments = (BYTE*)glyph_cache_fragment_get(glyph_cache, id, &size);\n\n\t\t\t\tif (fragments == NULL)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tfor (n = 0; n < size;)\n\t\t\t\t{\n\t\t\t\t\tconst UINT32 fop = fragments[n++];\n\t\t\t\t\tn = update_glyph_offset(fragments, size, n, &x, &y, ulCharInc, flAccel);\n\n\t\t\t\t\tif (!update_process_glyph(context, fragments, fop, &x, &y, cacheId, flAccel,\n\t\t\t\t\t                          fOpRedundant, &bound))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase GLYPH_FRAGMENT_ADD:\n\t\t\t\tif (index + 2 > length)\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tid = data[index++];\n\t\t\t\tsize = data[index++];\n\t\t\t\tglyph_cache_fragment_put(glyph_cache, id, size, data);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tindex = update_glyph_offset(data, length, index, &x, &y, ulCharInc, flAccel);\n\n\t\t\t\tif (!update_process_glyph(context, data, op, &x, &y, cacheId, flAccel, fOpRedundant,\n\t\t\t\t                          &bound))\n\t\t\t\t\treturn FALSE;\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn glyph->EndDraw(context, opX, opY, opWidth, opHeight, bgcolor, fgcolor);\n}\n\nstatic BOOL update_gdi_glyph_index(rdpContext* context, GLYPH_INDEX_ORDER* glyphIndex)\n{\n\tINT32 bkWidth = 0, bkHeight = 0, opWidth = 0, opHeight = 0;\n\n\tif (!context || !glyphIndex || !context->cache)\n\t\treturn FALSE;\n\n\tif (glyphIndex->bkRight > glyphIndex->bkLeft)\n\t\tbkWidth = glyphIndex->bkRight - glyphIndex->bkLeft + 1;\n\n\tif (glyphIndex->opRight > glyphIndex->opLeft)\n\t\topWidth = glyphIndex->opRight - glyphIndex->opLeft + 1;\n\n\tif (glyphIndex->bkBottom > glyphIndex->bkTop)\n\t\tbkHeight = glyphIndex->bkBottom - glyphIndex->bkTop + 1;\n\n\tif (glyphIndex->opBottom > glyphIndex->opTop)\n\t\topHeight = glyphIndex->opBottom - glyphIndex->opTop + 1;\n\n\treturn update_process_glyph_fragments(\n\t    context, glyphIndex->data, glyphIndex->cbData, glyphIndex->cacheId, glyphIndex->ulCharInc,\n\t    glyphIndex->flAccel, glyphIndex->backColor, glyphIndex->foreColor, glyphIndex->x,\n\t    glyphIndex->y, glyphIndex->bkLeft, glyphIndex->bkTop, bkWidth, bkHeight, glyphIndex->opLeft,\n\t    glyphIndex->opTop, opWidth, opHeight, glyphIndex->fOpRedundant);\n}\n\nstatic BOOL update_gdi_fast_index(rdpContext* context, const FAST_INDEX_ORDER* fastIndex)\n{\n\tINT32 x, y;\n\tINT32 opLeft, opTop;\n\tINT32 opRight, opBottom;\n\tINT32 opWidth = 0, opHeight = 0;\n\tINT32 bkWidth = 0, bkHeight = 0;\n\n\tif (!context || !fastIndex || !context->cache)\n\t\treturn FALSE;\n\n\topLeft = fastIndex->opLeft;\n\topTop = fastIndex->opTop;\n\topRight = fastIndex->opRight;\n\topBottom = fastIndex->opBottom;\n\tx = fastIndex->x;\n\ty = fastIndex->y;\n\n\tif (opBottom == -32768)\n\t{\n\t\tBYTE flags = (BYTE)(opTop & 0x0F);\n\n\t\tif (flags & 0x01)\n\t\t\topBottom = fastIndex->bkBottom;\n\n\t\tif (flags & 0x02)\n\t\t\topRight = fastIndex->bkRight;\n\n\t\tif (flags & 0x04)\n\t\t\topTop = fastIndex->bkTop;\n\n\t\tif (flags & 0x08)\n\t\t\topLeft = fastIndex->bkLeft;\n\t}\n\n\tif (opLeft == 0)\n\t\topLeft = fastIndex->bkLeft;\n\n\tif (opRight == 0)\n\t\topRight = fastIndex->bkRight;\n\n\t/* Server can send a massive number (32766) which appears to be\n\t * undocumented special behavior for \"Erase all the way right\".\n\t * X11 has nondeterministic results asking for a draw that wide. */\n\tif (opRight > (INT64)context->instance->settings->DesktopWidth)\n\t\topRight = (int)context->instance->settings->DesktopWidth;\n\n\tif (x == -32768)\n\t\tx = fastIndex->bkLeft;\n\n\tif (y == -32768)\n\t\ty = fastIndex->bkTop;\n\n\tif (fastIndex->bkRight > fastIndex->bkLeft)\n\t\tbkWidth = fastIndex->bkRight - fastIndex->bkLeft + 1;\n\n\tif (fastIndex->bkBottom > fastIndex->bkTop)\n\t\tbkHeight = fastIndex->bkBottom - fastIndex->bkTop + 1;\n\n\tif (opRight > opLeft)\n\t\topWidth = opRight - opLeft + 1;\n\n\tif (opBottom > opTop)\n\t\topHeight = opBottom - opTop + 1;\n\n\treturn update_process_glyph_fragments(\n\t    context, fastIndex->data, fastIndex->cbData, fastIndex->cacheId, fastIndex->ulCharInc,\n\t    fastIndex->flAccel, fastIndex->backColor, fastIndex->foreColor, x, y, fastIndex->bkLeft,\n\t    fastIndex->bkTop, bkWidth, bkHeight, opLeft, opTop, opWidth, opHeight, FALSE);\n}\n\nstatic BOOL update_gdi_fast_glyph(rdpContext* context, const FAST_GLYPH_ORDER* fastGlyph)\n{\n\tINT32 x, y;\n\tBYTE text_data[4] = { 0 };\n\tINT32 opLeft, opTop;\n\tINT32 opRight, opBottom;\n\tINT32 opWidth = 0, opHeight = 0;\n\tINT32 bkWidth = 0, bkHeight = 0;\n\trdpCache* cache;\n\n\tif (!context || !fastGlyph || !context->cache)\n\t\treturn FALSE;\n\n\tcache = context->cache;\n\topLeft = fastGlyph->opLeft;\n\topTop = fastGlyph->opTop;\n\topRight = fastGlyph->opRight;\n\topBottom = fastGlyph->opBottom;\n\tx = fastGlyph->x;\n\ty = fastGlyph->y;\n\n\tif (opBottom == -32768)\n\t{\n\t\tBYTE flags = (BYTE)(opTop & 0x0F);\n\n\t\tif (flags & 0x01)\n\t\t\topBottom = fastGlyph->bkBottom;\n\n\t\tif (flags & 0x02)\n\t\t\topRight = fastGlyph->bkRight;\n\n\t\tif (flags & 0x04)\n\t\t\topTop = fastGlyph->bkTop;\n\n\t\tif (flags & 0x08)\n\t\t\topLeft = fastGlyph->bkLeft;\n\t}\n\n\tif (opLeft == 0)\n\t\topLeft = fastGlyph->bkLeft;\n\n\tif (opRight == 0)\n\t\topRight = fastGlyph->bkRight;\n\n\t/* See update_gdi_fast_index opRight comment. */\n\tif (opRight > (INT64)context->instance->settings->DesktopWidth)\n\t\topRight = (int)context->instance->settings->DesktopWidth;\n\n\tif (x == -32768)\n\t\tx = fastGlyph->bkLeft;\n\n\tif (y == -32768)\n\t\ty = fastGlyph->bkTop;\n\n\tif ((fastGlyph->cbData > 1) && (fastGlyph->glyphData.aj))\n\t{\n\t\t/* got option font that needs to go into cache */\n\t\trdpGlyph* glyph;\n\t\tconst GLYPH_DATA_V2* glyphData = &fastGlyph->glyphData;\n\n\t\tglyph = Glyph_Alloc(context, glyphData->x, glyphData->y, glyphData->cx, glyphData->cy,\n\t\t                    glyphData->cb, glyphData->aj);\n\n\t\tif (!glyph)\n\t\t\treturn FALSE;\n\n\t\tif (!glyph_cache_put(cache->glyph, fastGlyph->cacheId, fastGlyph->data[0], glyph))\n\t\t{\n\t\t\tglyph->Free(context, glyph);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\ttext_data[0] = fastGlyph->data[0];\n\ttext_data[1] = 0;\n\n\tif (fastGlyph->bkRight > fastGlyph->bkLeft)\n\t\tbkWidth = fastGlyph->bkRight - fastGlyph->bkLeft + 1;\n\n\tif (fastGlyph->bkBottom > fastGlyph->bkTop)\n\t\tbkHeight = fastGlyph->bkBottom - fastGlyph->bkTop + 1;\n\n\tif (opRight > opLeft)\n\t\topWidth = opRight - opLeft + 1;\n\n\tif (opBottom > opTop)\n\t\topHeight = opBottom - opTop + 1;\n\n\treturn update_process_glyph_fragments(\n\t    context, text_data, sizeof(text_data), fastGlyph->cacheId, fastGlyph->ulCharInc,\n\t    fastGlyph->flAccel, fastGlyph->backColor, fastGlyph->foreColor, x, y, fastGlyph->bkLeft,\n\t    fastGlyph->bkTop, bkWidth, bkHeight, opLeft, opTop, opWidth, opHeight, FALSE);\n}\n\nstatic BOOL update_gdi_cache_glyph(rdpContext* context, const CACHE_GLYPH_ORDER* cacheGlyph)\n{\n\tUINT32 i;\n\trdpCache* cache;\n\n\tif (!context || !cacheGlyph || !context->cache)\n\t\treturn FALSE;\n\n\tcache = context->cache;\n\n\tfor (i = 0; i < cacheGlyph->cGlyphs; i++)\n\t{\n\t\tconst GLYPH_DATA* glyph_data = &cacheGlyph->glyphData[i];\n\t\trdpGlyph* glyph;\n\n\t\tif (!glyph_data)\n\t\t\treturn FALSE;\n\n\t\tif (!(glyph = Glyph_Alloc(context, glyph_data->x, glyph_data->y, glyph_data->cx,\n\t\t                          glyph_data->cy, glyph_data->cb, glyph_data->aj)))\n\t\t\treturn FALSE;\n\n\t\tif (!glyph_cache_put(cache->glyph, cacheGlyph->cacheId, glyph_data->cacheIndex, glyph))\n\t\t{\n\t\t\tglyph->Free(context, glyph);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL update_gdi_cache_glyph_v2(rdpContext* context, const CACHE_GLYPH_V2_ORDER* cacheGlyphV2)\n{\n\tUINT32 i;\n\trdpCache* cache;\n\n\tif (!context || !cacheGlyphV2 || !context->cache)\n\t\treturn FALSE;\n\n\tcache = context->cache;\n\n\tfor (i = 0; i < cacheGlyphV2->cGlyphs; i++)\n\t{\n\t\tconst GLYPH_DATA_V2* glyphData = &cacheGlyphV2->glyphData[i];\n\t\trdpGlyph* glyph;\n\n\t\tif (!glyphData)\n\t\t\treturn FALSE;\n\n\t\tglyph = Glyph_Alloc(context, glyphData->x, glyphData->y, glyphData->cx, glyphData->cy,\n\t\t                    glyphData->cb, glyphData->aj);\n\n\t\tif (!glyph)\n\t\t\treturn FALSE;\n\n\t\tif (!glyph_cache_put(cache->glyph, cacheGlyphV2->cacheId, glyphData->cacheIndex, glyph))\n\t\t{\n\t\t\tglyph->Free(context, glyph);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nrdpGlyph* glyph_cache_get(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index)\n{\n\trdpGlyph* glyph;\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCacheGet: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn NULL;\n\t}\n\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"index %\" PRIu32 \" out of range for cache id: %\" PRIu32 \"\", index, id);\n\t\treturn NULL;\n\t}\n\n\tglyph = glyphCache->glyphCache[id].entries[index];\n\n\tif (!glyph)\n\t\tWLog_ERR(TAG, \"no glyph found at cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index,\n\t\t         id);\n\n\treturn glyph;\n}\n\nBOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\n\tif (index >= glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}\n\nconst void* glyph_cache_fragment_get(rdpGlyphCache* glyphCache, UINT32 index, UINT32* size)\n{\n\tvoid* fragment;\n\n\tif (index > 255)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache fragment index: %\" PRIu32 \"\", index);\n\t\treturn NULL;\n\t}\n\n\tfragment = glyphCache->fragCache.entries[index].fragment;\n\t*size = (BYTE)glyphCache->fragCache.entries[index].size;\n\tWLog_Print(glyphCache->log, WLOG_DEBUG,\n\t           \"GlyphCacheFragmentGet: index: %\" PRIu32 \" size: %\" PRIu32 \"\", index, *size);\n\n\tif (!fragment)\n\t\tWLog_ERR(TAG, \"invalid glyph fragment at index:%\" PRIu32 \"\", index);\n\n\treturn fragment;\n}\n\nBOOL glyph_cache_fragment_put(rdpGlyphCache* glyphCache, UINT32 index, UINT32 size,\n                              const void* fragment)\n{\n\tvoid* prevFragment;\n\tvoid* copy;\n\n\tif (index > 255)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache fragment index: %\" PRIu32 \"\", index);\n\t\treturn FALSE;\n\t}\n\n\tcopy = malloc(size);\n\n\tif (!copy)\n\t\treturn FALSE;\n\n\tWLog_Print(glyphCache->log, WLOG_DEBUG,\n\t           \"GlyphCacheFragmentPut: index: %\" PRIu32 \" size: %\" PRIu32 \"\", index, size);\n\tCopyMemory(copy, fragment, size);\n\tprevFragment = glyphCache->fragCache.entries[index].fragment;\n\tglyphCache->fragCache.entries[index].fragment = copy;\n\tglyphCache->fragCache.entries[index].size = size;\n\tfree(prevFragment);\n\treturn TRUE;\n}\n\nvoid glyph_cache_register_callbacks(rdpUpdate* update)\n{\n\tupdate->primary->GlyphIndex = update_gdi_glyph_index;\n\tupdate->primary->FastIndex = update_gdi_fast_index;\n\tupdate->primary->FastGlyph = update_gdi_fast_glyph;\n\tupdate->secondary->CacheGlyph = update_gdi_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_gdi_cache_glyph_v2;\n}\n\nrdpGlyphCache* glyph_cache_new(rdpSettings* settings)\n{\n\tint i;\n\trdpGlyphCache* glyphCache;\n\tglyphCache = (rdpGlyphCache*)calloc(1, sizeof(rdpGlyphCache));\n\n\tif (!glyphCache)\n\t\treturn NULL;\n\n\tglyphCache->log = WLog_Get(\"com.freerdp.cache.glyph\");\n\tglyphCache->settings = settings;\n\tglyphCache->context = ((freerdp*)settings->instance)->update->context;\n\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tglyphCache->glyphCache[i].number = settings->GlyphCache[i].cacheEntries;\n\t\tglyphCache->glyphCache[i].maxCellSize = settings->GlyphCache[i].cacheMaximumCellSize;\n\t\tglyphCache->glyphCache[i].entries =\n\t\t    (rdpGlyph**)calloc(glyphCache->glyphCache[i].number, sizeof(rdpGlyph*));\n\n\t\tif (!glyphCache->glyphCache[i].entries)\n\t\t\tgoto fail;\n\t}\n\n\tglyphCache->fragCache.entries = calloc(256, sizeof(FRAGMENT_CACHE_ENTRY));\n\n\tif (!glyphCache->fragCache.entries)\n\t\tgoto fail;\n\n\treturn glyphCache;\nfail:\n\tglyph_cache_free(glyphCache);\n\treturn NULL;\n}\n\nvoid glyph_cache_free(rdpGlyphCache* glyphCache)\n{\n\tif (glyphCache)\n\t{\n\t\tint i;\n\t\tGLYPH_CACHE* cache = glyphCache->glyphCache;\n\n\t\tfor (i = 0; i < 10; i++)\n\t\t{\n\t\t\tUINT32 j;\n\t\t\trdpGlyph** entries = cache[i].entries;\n\n\t\t\tif (!entries)\n\t\t\t\tcontinue;\n\n\t\t\tfor (j = 0; j < cache[i].number; j++)\n\t\t\t{\n\t\t\t\trdpGlyph* glyph = entries[j];\n\n\t\t\t\tif (glyph)\n\t\t\t\t{\n\t\t\t\t\tglyph->Free(glyphCache->context, glyph);\n\t\t\t\t\tentries[j] = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfree(entries);\n\t\t\tcache[i].entries = NULL;\n\t\t}\n\n\t\tif (glyphCache->fragCache.entries)\n\t\t{\n\t\t\tfor (i = 0; i < 256; i++)\n\t\t\t{\n\t\t\t\tfree(glyphCache->fragCache.entries[i].fragment);\n\t\t\t\tglyphCache->fragCache.entries[i].fragment = NULL;\n\t\t\t}\n\t\t}\n\n\t\tfree(glyphCache->fragCache.entries);\n\t\tfree(glyphCache);\n\t}\n}\n\nCACHE_GLYPH_ORDER* copy_cache_glyph_order(rdpContext* context, const CACHE_GLYPH_ORDER* glyph)\n{\n\tsize_t x;\n\tCACHE_GLYPH_ORDER* dst = calloc(1, sizeof(CACHE_GLYPH_ORDER));\n\n\tif (!dst || !glyph)\n\t\tgoto fail;\n\n\t*dst = *glyph;\n\n\tfor (x = 0; x < glyph->cGlyphs; x++)\n\t{\n\t\tconst GLYPH_DATA* src = &glyph->glyphData[x];\n\t\tGLYPH_DATA* data = &dst->glyphData[x];\n\n\t\tif (src->aj)\n\t\t{\n\t\t\tconst size_t size = src->cb;\n\t\t\tdata->aj = malloc(size);\n\n\t\t\tif (!data->aj)\n\t\t\t\tgoto fail;\n\n\t\t\tmemcpy(data->aj, src->aj, size);\n\t\t}\n\t}\n\n\tif (glyph->unicodeCharacters)\n\t{\n\t\tif (glyph->cGlyphs == 0)\n\t\t\tgoto fail;\n\n\t\tdst->unicodeCharacters = calloc(glyph->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!dst->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tmemcpy(dst->unicodeCharacters, glyph->unicodeCharacters, sizeof(WCHAR) * glyph->cGlyphs);\n\t}\n\n\treturn dst;\nfail:\n\tfree_cache_glyph_order(context, dst);\n\treturn NULL;\n}\n\nvoid free_cache_glyph_order(rdpContext* context, CACHE_GLYPH_ORDER* glyph)\n{\n\tif (glyph)\n\t{\n\t\tsize_t x;\n\n\t\tfor (x = 0; x < ARRAYSIZE(glyph->glyphData); x++)\n\t\t\tfree(glyph->glyphData[x].aj);\n\n\t\tfree(glyph->unicodeCharacters);\n\t}\n\n\tfree(glyph);\n}\n\nCACHE_GLYPH_V2_ORDER* copy_cache_glyph_v2_order(rdpContext* context,\n                                                const CACHE_GLYPH_V2_ORDER* glyph)\n{\n\tsize_t x;\n\tCACHE_GLYPH_V2_ORDER* dst = calloc(1, sizeof(CACHE_GLYPH_V2_ORDER));\n\n\tif (!dst || !glyph)\n\t\tgoto fail;\n\n\t*dst = *glyph;\n\n\tfor (x = 0; x < glyph->cGlyphs; x++)\n\t{\n\t\tconst GLYPH_DATA_V2* src = &glyph->glyphData[x];\n\t\tGLYPH_DATA_V2* data = &dst->glyphData[x];\n\n\t\tif (src->aj)\n\t\t{\n\t\t\tconst size_t size = src->cb;\n\t\t\tdata->aj = malloc(size);\n\n\t\t\tif (!data->aj)\n\t\t\t\tgoto fail;\n\n\t\t\tmemcpy(data->aj, src->aj, size);\n\t\t}\n\t}\n\n\tif (glyph->unicodeCharacters)\n\t{\n\t\tif (glyph->cGlyphs == 0)\n\t\t\tgoto fail;\n\n\t\tdst->unicodeCharacters = calloc(glyph->cGlyphs, sizeof(WCHAR));\n\n\t\tif (!dst->unicodeCharacters)\n\t\t\tgoto fail;\n\n\t\tmemcpy(dst->unicodeCharacters, glyph->unicodeCharacters, sizeof(WCHAR) * glyph->cGlyphs);\n\t}\n\n\treturn dst;\nfail:\n\tfree_cache_glyph_v2_order(context, dst);\n\treturn NULL;\n}\n\nvoid free_cache_glyph_v2_order(rdpContext* context, CACHE_GLYPH_V2_ORDER* glyph)\n{\n\tif (glyph)\n\t{\n\t\tsize_t x;\n\n\t\tfor (x = 0; x < ARRAYSIZE(glyph->glyphData); x++)\n\t\t\tfree(glyph->glyphData[x].aj);\n\n\t\tfree(glyph->unicodeCharacters);\n\t}\n\n\tfree(glyph);\n}\n"], "filenames": ["libfreerdp/cache/glyph.c"], "buggy_code_start_loc": [582], "buggy_code_end_loc": [583], "fixing_code_start_loc": [582], "fixing_code_end_loc": [583], "type": "CWE-125", "message": "In FreeRDP before version 2.1.2, there is an out-of-bound read in glyph_cache_put. This affects all FreeRDP clients with `+glyph-cache` option enabled This is fixed in version 2.1.2.", "other": {"cve": {"id": "CVE-2020-11098", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-22T22:15:12.180", "lastModified": "2022-07-19T11:36:10.730", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP before version 2.1.2, there is an out-of-bound read in glyph_cache_put. This affects all FreeRDP clients with `+glyph-cache` option enabled This is fixed in version 2.1.2."}, {"lang": "es", "value": "En FreeRDP versiones anteriores a 2.1.2, se presenta una lectura fuera de l\u00edmite en glyph_cache_put. Esto afecta a todos los clientes de FreeRDP con la opci\u00f3n \"+glyph-cache\" habilitada.  Esto es corregido en la versi\u00f3n 2.1.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.2", "matchCriteriaId": "DDAC8E89-8F23-4799-AA42-AD419455D1F6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00080.html", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.freerdp.com/2020/06/22/2_1_2-released", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/c0fd449ec0870b050d350d6d844b1ea6dad4bc7d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-jr57-f58x-hjmv", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6Y35HBHG2INICLSGCIKNAR7GCXEHQACQ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XOZLH35OJWIQLM7FYDXAP2EAUBDXE76V/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4481-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/c0fd449ec0870b050d350d6d844b1ea6dad4bc7d"}}