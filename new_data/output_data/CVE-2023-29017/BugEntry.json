{"buggy_code": ["/* global host, bridge, data, context */\n\n'use strict';\n\nconst {\n\tObject: localObject,\n\tArray: localArray,\n\tError: LocalError,\n\tReflect: localReflect,\n\tProxy: LocalProxy,\n\tWeakMap: LocalWeakMap,\n\tFunction: localFunction,\n\tPromise: localPromise,\n\teval: localEval\n} = global;\n\nconst {\n\tfreeze: localObjectFreeze\n} = localObject;\n\nconst {\n\tgetPrototypeOf: localReflectGetPrototypeOf,\n\tapply: localReflectApply,\n\tdeleteProperty: localReflectDeleteProperty,\n\thas: localReflectHas,\n\tdefineProperty: localReflectDefineProperty,\n\tsetPrototypeOf: localReflectSetPrototypeOf,\n\tgetOwnPropertyDescriptor: localReflectGetOwnPropertyDescriptor\n} = localReflect;\n\nconst {\n\tisArray: localArrayIsArray\n} = localArray;\n\nconst {\n\tensureThis,\n\tReadOnlyHandler,\n\tfrom,\n\tfromWithFactory,\n\treadonlyFactory,\n\tconnect,\n\taddProtoMapping,\n\tVMError,\n\tReadOnlyMockHandler\n} = bridge;\n\nconst {\n\tallowAsync,\n\tGeneratorFunction,\n\tAsyncFunction,\n\tAsyncGeneratorFunction\n} = data;\n\nconst {\n\tget: localWeakMapGet,\n\tset: localWeakMapSet\n} = LocalWeakMap.prototype;\n\nfunction localUnexpected() {\n\treturn new VMError('Should not happen');\n}\n\n// global is originally prototype of host.Object so it can be used to climb up from the sandbox.\nif (!localReflectSetPrototypeOf(context, localObject.prototype)) throw localUnexpected();\n\nObject.defineProperties(global, {\n\tglobal: {value: global, writable: true, configurable: true, enumerable: true},\n\tglobalThis: {value: global, writable: true, configurable: true},\n\tGLOBAL: {value: global, writable: true, configurable: true},\n\troot: {value: global, writable: true, configurable: true},\n\tError: {value: LocalError}\n});\n\nif (!localReflectDefineProperty(global, 'VMError', {\n\t__proto__: null,\n\tvalue: VMError,\n\twritable: true,\n\tenumerable: false,\n\tconfigurable: true\n})) throw localUnexpected();\n\n// Fixes buffer unsafe allocation\n/* eslint-disable no-use-before-define */\nclass BufferHandler extends ReadOnlyHandler {\n\n\tapply(target, thiz, args) {\n\t\tif (args.length > 0 && typeof args[0] === 'number') {\n\t\t\treturn LocalBuffer.alloc(args[0]);\n\t\t}\n\t\treturn localReflectApply(LocalBuffer.from, LocalBuffer, args);\n\t}\n\n\tconstruct(target, args, newTarget) {\n\t\tif (args.length > 0 && typeof args[0] === 'number') {\n\t\t\treturn LocalBuffer.alloc(args[0]);\n\t\t}\n\t\treturn localReflectApply(LocalBuffer.from, LocalBuffer, args);\n\t}\n\n}\n/* eslint-enable no-use-before-define */\n\nconst LocalBuffer = fromWithFactory(obj => new BufferHandler(obj), host.Buffer);\n\n\nif (!localReflectDefineProperty(global, 'Buffer', {\n\t__proto__: null,\n\tvalue: LocalBuffer,\n\twritable: true,\n\tenumerable: false,\n\tconfigurable: true\n})) throw localUnexpected();\n\naddProtoMapping(LocalBuffer.prototype, host.Buffer.prototype, 'Uint8Array');\n\n/**\n *\n * @param {*} size Size of new buffer\n * @this LocalBuffer\n * @return {LocalBuffer}\n */\nfunction allocUnsafe(size) {\n\treturn LocalBuffer.alloc(size);\n}\n\nconnect(allocUnsafe, host.Buffer.allocUnsafe);\n\n/**\n *\n * @param {*} size Size of new buffer\n * @this LocalBuffer\n * @return {LocalBuffer}\n */\nfunction allocUnsafeSlow(size) {\n\treturn LocalBuffer.alloc(size);\n}\n\nconnect(allocUnsafeSlow, host.Buffer.allocUnsafeSlow);\n\n/**\n * Replacement for Buffer inspect\n *\n * @param {*} recurseTimes\n * @param {*} ctx\n * @this LocalBuffer\n * @return {string}\n */\nfunction inspect(recurseTimes, ctx) {\n\t// Mimic old behavior, could throw but didn't pass a test.\n\tconst max = host.INSPECT_MAX_BYTES;\n\tconst actualMax = Math.min(max, this.length);\n\tconst remaining = this.length - max;\n\tlet str = this.hexSlice(0, actualMax).replace(/(.{2})/g, '$1 ').trim();\n\tif (remaining > 0) str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n\treturn `<${this.constructor.name} ${str}>`;\n}\n\nconnect(inspect, host.Buffer.prototype.inspect);\n\nconnect(localFunction.prototype.bind, host.Function.prototype.bind);\n\nconnect(localObject.prototype.__defineGetter__, host.Object.prototype.__defineGetter__);\nconnect(localObject.prototype.__defineSetter__, host.Object.prototype.__defineSetter__);\nconnect(localObject.prototype.__lookupGetter__, host.Object.prototype.__lookupGetter__);\nconnect(localObject.prototype.__lookupSetter__, host.Object.prototype.__lookupSetter__);\n\n/*\n * PrepareStackTrace sanitization\n */\n\nconst oldPrepareStackTraceDesc = localReflectGetOwnPropertyDescriptor(LocalError, 'prepareStackTrace');\n\nlet currentPrepareStackTrace = LocalError.prepareStackTrace;\nconst wrappedPrepareStackTrace = new LocalWeakMap();\nif (typeof currentPrepareStackTrace === 'function') {\n\twrappedPrepareStackTrace.set(currentPrepareStackTrace, currentPrepareStackTrace);\n}\n\nlet OriginalCallSite;\nLocalError.prepareStackTrace = (e, sst) => {\n\tOriginalCallSite = sst[0].constructor;\n};\nnew LocalError().stack;\nif (typeof OriginalCallSite === 'function') {\n\tLocalError.prepareStackTrace = undefined;\n\n\tfunction makeCallSiteGetters(list) {\n\t\tconst callSiteGetters = [];\n\t\tfor (let i=0; i<list.length; i++) {\n\t\t\tconst name = list[i];\n\t\t\tconst func = OriginalCallSite.prototype[name];\n\t\t\tcallSiteGetters[i] = {__proto__: null,\n\t\t\t\tname,\n\t\t\t\tpropName: '_' + name,\n\t\t\t\tfunc: (thiz) => {\n\t\t\t\t\treturn localReflectApply(func, thiz, []);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn callSiteGetters;\n\t}\n\n\tfunction applyCallSiteGetters(thiz, callSite, getters) {\n\t\tfor (let i=0; i<getters.length; i++) {\n\t\t\tconst getter = getters[i];\n\t\t\tlocalReflectDefineProperty(thiz, getter.propName, {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: getter.func(callSite)\n\t\t\t});\n\t\t}\n\t}\n\n\tconst callSiteGetters = makeCallSiteGetters([\n\t\t'getTypeName',\n\t\t'getFunctionName',\n\t\t'getMethodName',\n\t\t'getFileName',\n\t\t'getLineNumber',\n\t\t'getColumnNumber',\n\t\t'getEvalOrigin',\n\t\t'isToplevel',\n\t\t'isEval',\n\t\t'isNative',\n\t\t'isConstructor',\n\t\t'isAsync',\n\t\t'isPromiseAll',\n\t\t'getPromiseIndex'\n\t]);\n\n\tclass CallSite {\n\t\tconstructor(callSite) {\n\t\t\tapplyCallSiteGetters(this, callSite, callSiteGetters);\n\t\t}\n\t\tgetThis() {\n\t\t\treturn undefined;\n\t\t}\n\t\tgetFunction() {\n\t\t\treturn undefined;\n\t\t}\n\t\ttoString() {\n\t\t\treturn 'CallSite {}';\n\t\t}\n\t}\n\n\n\tfor (let i=0; i<callSiteGetters.length; i++) {\n\t\tconst name = callSiteGetters[i].name;\n\t\tconst funcProp = localReflectGetOwnPropertyDescriptor(OriginalCallSite.prototype, name);\n\t\tif (!funcProp) continue;\n\t\tconst propertyName = callSiteGetters[i].propName;\n\t\tconst func = {func() {\n\t\t\treturn this[propertyName];\n\t\t}}.func;\n\t\tconst nameProp = localReflectGetOwnPropertyDescriptor(func, 'name');\n\t\tif (!nameProp) throw localUnexpected();\n\t\tnameProp.value = name;\n\t\tif (!localReflectDefineProperty(func, 'name', nameProp)) throw localUnexpected();\n\t\tfuncProp.value = func;\n\t\tif (!localReflectDefineProperty(CallSite.prototype, name, funcProp)) throw localUnexpected();\n\t}\n\n\tif (!localReflectDefineProperty(LocalError, 'prepareStackTrace', {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\tget() {\n\t\t\treturn currentPrepareStackTrace;\n\t\t},\n\t\tset(value) {\n\t\t\tif (typeof(value) !== 'function') {\n\t\t\t\tcurrentPrepareStackTrace = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst wrapped = localReflectApply(localWeakMapGet, wrappedPrepareStackTrace, [value]);\n\t\t\tif (wrapped) {\n\t\t\t\tcurrentPrepareStackTrace = wrapped;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newWrapped = (error, sst) => {\n\t\t\t\tif (localArrayIsArray(sst)) {\n\t\t\t\t\tfor (let i=0; i < sst.length; i++) {\n\t\t\t\t\t\tconst cs = sst[i];\n\t\t\t\t\t\tif (typeof cs === 'object' && localReflectGetPrototypeOf(cs) === OriginalCallSite.prototype) {\n\t\t\t\t\t\t\tsst[i] = new CallSite(cs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value(error, sst);\n\t\t\t};\n\t\t\tlocalReflectApply(localWeakMapSet, wrappedPrepareStackTrace, [value, newWrapped]);\n\t\t\tlocalReflectApply(localWeakMapSet, wrappedPrepareStackTrace, [newWrapped, newWrapped]);\n\t\t\tcurrentPrepareStackTrace = newWrapped;\n\t\t}\n\t})) throw localUnexpected();\n} else if (oldPrepareStackTraceDesc) {\n\tlocalReflectDefineProperty(LocalError, 'prepareStackTrace', oldPrepareStackTraceDesc);\n} else {\n\tlocalReflectDeleteProperty(LocalError, 'prepareStackTrace');\n}\n\n/*\n * Exception sanitization\n */\n\nconst withProxy = localObjectFreeze({\n\t__proto__: null,\n\thas(target, key) {\n\t\tif (key === host.INTERNAL_STATE_NAME) return false;\n\t\treturn localReflectHas(target, key);\n\t}\n});\n\nconst interanState = localObjectFreeze({\n\t__proto__: null,\n\twrapWith(x) {\n\t\tif (x === null || x === undefined) return x;\n\t\treturn new LocalProxy(localObject(x), withProxy);\n\t},\n\thandleException: ensureThis,\n\timport(what) {\n\t\tthrow new VMError('Dynamic Import not supported');\n\t}\n});\n\nif (!localReflectDefineProperty(global, host.INTERNAL_STATE_NAME, {\n\t__proto__: null,\n\tconfigurable: false,\n\tenumerable: false,\n\twritable: false,\n\tvalue: interanState\n})) throw localUnexpected();\n\n/*\n * Eval sanitization\n */\n\nfunction throwAsync() {\n\treturn new VMError('Async not available');\n}\n\nfunction makeFunction(inputArgs, isAsync, isGenerator) {\n\tconst lastArgs = inputArgs.length - 1;\n\tlet code = lastArgs >= 0 ? `${inputArgs[lastArgs]}` : '';\n\tlet args = lastArgs > 0 ? `${inputArgs[0]}` : '';\n\tfor (let i = 1; i < lastArgs; i++) {\n\t\targs += `,${inputArgs[i]}`;\n\t}\n\ttry {\n\t\tcode = host.transformAndCheck(args, code, isAsync, isGenerator, allowAsync);\n\t} catch (e) {\n\t\tthrow bridge.from(e);\n\t}\n\treturn localEval(code);\n}\n\nconst FunctionHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\treturn makeFunction(args, this.isAsync, this.isGenerator);\n\t},\n\tconstruct(target, args, newTarget) {\n\t\treturn makeFunction(args, this.isAsync, this.isGenerator);\n\t}\n};\n\nconst EvalHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tif (args.length === 0) return undefined;\n\t\tlet code = `${args[0]}`;\n\t\ttry {\n\t\t\tcode = host.transformAndCheck(null, code, false, false, allowAsync);\n\t\t} catch (e) {\n\t\t\tthrow bridge.from(e);\n\t\t}\n\t\treturn localEval(code);\n\t}\n};\n\nconst AsyncErrorHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tthrow throwAsync();\n\t},\n\tconstruct(target, args, newTarget) {\n\t\tthrow throwAsync();\n\t}\n};\n\nfunction makeCheckFunction(isAsync, isGenerator) {\n\tif (isAsync && !allowAsync) return AsyncErrorHandler;\n\treturn {\n\t\t__proto__: FunctionHandler,\n\t\tisAsync,\n\t\tisGenerator\n\t};\n}\n\nfunction overrideWithProxy(obj, prop, value, handler) {\n\tconst proxy = new LocalProxy(value, handler);\n\tif (!localReflectDefineProperty(obj, prop, {__proto__: null, value: proxy})) throw localUnexpected();\n\treturn proxy;\n}\n\nconst proxiedFunction = overrideWithProxy(localFunction.prototype, 'constructor', localFunction, makeCheckFunction(false, false));\nif (GeneratorFunction) {\n\tif (!localReflectSetPrototypeOf(GeneratorFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(GeneratorFunction.prototype, 'constructor', GeneratorFunction, makeCheckFunction(false, true));\n}\nif (AsyncFunction) {\n\tif (!localReflectSetPrototypeOf(AsyncFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(AsyncFunction.prototype, 'constructor', AsyncFunction, makeCheckFunction(true, false));\n}\nif (AsyncGeneratorFunction) {\n\tif (!localReflectSetPrototypeOf(AsyncGeneratorFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(AsyncGeneratorFunction.prototype, 'constructor', AsyncGeneratorFunction, makeCheckFunction(true, true));\n}\n\nglobal.Function = proxiedFunction;\nglobal.eval = new LocalProxy(localEval, EvalHandler);\n\n/*\n * Promise sanitization\n */\n\nif (localPromise && !allowAsync) {\n\n\tconst PromisePrototype = localPromise.prototype;\n\n\toverrideWithProxy(PromisePrototype, 'then', PromisePrototype.then, AsyncErrorHandler);\n\t// This seems not to work, and will produce\n\t// UnhandledPromiseRejectionWarning: TypeError: Method Promise.prototype.then called on incompatible receiver [object Object].\n\t// This is likely caused since the host.Promise.prototype.then cannot use the VM Proxy object.\n\t// Contextify.connect(host.Promise.prototype.then, Promise.prototype.then);\n\n\tif (PromisePrototype.finally) {\n\t\toverrideWithProxy(PromisePrototype, 'finally', PromisePrototype.finally, AsyncErrorHandler);\n\t\t// Contextify.connect(host.Promise.prototype.finally, Promise.prototype.finally);\n\t}\n\tif (Promise.prototype.catch) {\n\t\toverrideWithProxy(PromisePrototype, 'catch', PromisePrototype.catch, AsyncErrorHandler);\n\t\t// Contextify.connect(host.Promise.prototype.catch, Promise.prototype.catch);\n\t}\n\n}\n\nfunction readonly(other, mock) {\n\t// Note: other@other(unsafe) mock@other(unsafe) returns@this(unsafe) throws@this(unsafe)\n\tif (!mock) return fromWithFactory(readonlyFactory, other);\n\tconst tmock = from(mock);\n\treturn fromWithFactory(obj=>new ReadOnlyMockHandler(obj, tmock), other);\n}\n\nreturn {\n\t__proto__: null,\n\treadonly,\n\tglobal\n};\n"], "fixing_code": ["/* global host, bridge, data, context */\n\n'use strict';\n\nconst {\n\tObject: localObject,\n\tArray: localArray,\n\tError: LocalError,\n\tReflect: localReflect,\n\tProxy: LocalProxy,\n\tWeakMap: LocalWeakMap,\n\tFunction: localFunction,\n\tPromise: localPromise,\n\teval: localEval\n} = global;\n\nconst {\n\tfreeze: localObjectFreeze\n} = localObject;\n\nconst {\n\tgetPrototypeOf: localReflectGetPrototypeOf,\n\tapply: localReflectApply,\n\tdeleteProperty: localReflectDeleteProperty,\n\thas: localReflectHas,\n\tdefineProperty: localReflectDefineProperty,\n\tsetPrototypeOf: localReflectSetPrototypeOf,\n\tgetOwnPropertyDescriptor: localReflectGetOwnPropertyDescriptor\n} = localReflect;\n\nconst {\n\tisArray: localArrayIsArray\n} = localArray;\n\nconst {\n\tensureThis,\n\tReadOnlyHandler,\n\tfrom,\n\tfromWithFactory,\n\treadonlyFactory,\n\tconnect,\n\taddProtoMapping,\n\tVMError,\n\tReadOnlyMockHandler\n} = bridge;\n\nconst {\n\tallowAsync,\n\tGeneratorFunction,\n\tAsyncFunction,\n\tAsyncGeneratorFunction\n} = data;\n\nconst {\n\tget: localWeakMapGet,\n\tset: localWeakMapSet\n} = LocalWeakMap.prototype;\n\nfunction localUnexpected() {\n\treturn new VMError('Should not happen');\n}\n\n// global is originally prototype of host.Object so it can be used to climb up from the sandbox.\nif (!localReflectSetPrototypeOf(context, localObject.prototype)) throw localUnexpected();\n\nObject.defineProperties(global, {\n\tglobal: {value: global, writable: true, configurable: true, enumerable: true},\n\tglobalThis: {value: global, writable: true, configurable: true},\n\tGLOBAL: {value: global, writable: true, configurable: true},\n\troot: {value: global, writable: true, configurable: true},\n\tError: {value: LocalError}\n});\n\nif (!localReflectDefineProperty(global, 'VMError', {\n\t__proto__: null,\n\tvalue: VMError,\n\twritable: true,\n\tenumerable: false,\n\tconfigurable: true\n})) throw localUnexpected();\n\n// Fixes buffer unsafe allocation\n/* eslint-disable no-use-before-define */\nclass BufferHandler extends ReadOnlyHandler {\n\n\tapply(target, thiz, args) {\n\t\tif (args.length > 0 && typeof args[0] === 'number') {\n\t\t\treturn LocalBuffer.alloc(args[0]);\n\t\t}\n\t\treturn localReflectApply(LocalBuffer.from, LocalBuffer, args);\n\t}\n\n\tconstruct(target, args, newTarget) {\n\t\tif (args.length > 0 && typeof args[0] === 'number') {\n\t\t\treturn LocalBuffer.alloc(args[0]);\n\t\t}\n\t\treturn localReflectApply(LocalBuffer.from, LocalBuffer, args);\n\t}\n\n}\n/* eslint-enable no-use-before-define */\n\nconst LocalBuffer = fromWithFactory(obj => new BufferHandler(obj), host.Buffer);\n\n\nif (!localReflectDefineProperty(global, 'Buffer', {\n\t__proto__: null,\n\tvalue: LocalBuffer,\n\twritable: true,\n\tenumerable: false,\n\tconfigurable: true\n})) throw localUnexpected();\n\naddProtoMapping(LocalBuffer.prototype, host.Buffer.prototype, 'Uint8Array');\n\n/**\n *\n * @param {*} size Size of new buffer\n * @this LocalBuffer\n * @return {LocalBuffer}\n */\nfunction allocUnsafe(size) {\n\treturn LocalBuffer.alloc(size);\n}\n\nconnect(allocUnsafe, host.Buffer.allocUnsafe);\n\n/**\n *\n * @param {*} size Size of new buffer\n * @this LocalBuffer\n * @return {LocalBuffer}\n */\nfunction allocUnsafeSlow(size) {\n\treturn LocalBuffer.alloc(size);\n}\n\nconnect(allocUnsafeSlow, host.Buffer.allocUnsafeSlow);\n\n/**\n * Replacement for Buffer inspect\n *\n * @param {*} recurseTimes\n * @param {*} ctx\n * @this LocalBuffer\n * @return {string}\n */\nfunction inspect(recurseTimes, ctx) {\n\t// Mimic old behavior, could throw but didn't pass a test.\n\tconst max = host.INSPECT_MAX_BYTES;\n\tconst actualMax = Math.min(max, this.length);\n\tconst remaining = this.length - max;\n\tlet str = this.hexSlice(0, actualMax).replace(/(.{2})/g, '$1 ').trim();\n\tif (remaining > 0) str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n\treturn `<${this.constructor.name} ${str}>`;\n}\n\nconnect(inspect, host.Buffer.prototype.inspect);\n\nconnect(localFunction.prototype.bind, host.Function.prototype.bind);\n\nconnect(localObject.prototype.__defineGetter__, host.Object.prototype.__defineGetter__);\nconnect(localObject.prototype.__defineSetter__, host.Object.prototype.__defineSetter__);\nconnect(localObject.prototype.__lookupGetter__, host.Object.prototype.__lookupGetter__);\nconnect(localObject.prototype.__lookupSetter__, host.Object.prototype.__lookupSetter__);\n\n/*\n * PrepareStackTrace sanitization\n */\n\nconst oldPrepareStackTraceDesc = localReflectGetOwnPropertyDescriptor(LocalError, 'prepareStackTrace');\n\nlet currentPrepareStackTrace = LocalError.prepareStackTrace;\nconst wrappedPrepareStackTrace = new LocalWeakMap();\nif (typeof currentPrepareStackTrace === 'function') {\n\twrappedPrepareStackTrace.set(currentPrepareStackTrace, currentPrepareStackTrace);\n}\n\nlet OriginalCallSite;\nLocalError.prepareStackTrace = (e, sst) => {\n\tOriginalCallSite = sst[0].constructor;\n};\nnew LocalError().stack;\nif (typeof OriginalCallSite === 'function') {\n\tLocalError.prepareStackTrace = undefined;\n\n\tfunction makeCallSiteGetters(list) {\n\t\tconst callSiteGetters = [];\n\t\tfor (let i=0; i<list.length; i++) {\n\t\t\tconst name = list[i];\n\t\t\tconst func = OriginalCallSite.prototype[name];\n\t\t\tcallSiteGetters[i] = {__proto__: null,\n\t\t\t\tname,\n\t\t\t\tpropName: '_' + name,\n\t\t\t\tfunc: (thiz) => {\n\t\t\t\t\treturn localReflectApply(func, thiz, []);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\treturn callSiteGetters;\n\t}\n\n\tfunction applyCallSiteGetters(thiz, callSite, getters) {\n\t\tfor (let i=0; i<getters.length; i++) {\n\t\t\tconst getter = getters[i];\n\t\t\tlocalReflectDefineProperty(thiz, getter.propName, {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: getter.func(callSite)\n\t\t\t});\n\t\t}\n\t}\n\n\tconst callSiteGetters = makeCallSiteGetters([\n\t\t'getTypeName',\n\t\t'getFunctionName',\n\t\t'getMethodName',\n\t\t'getFileName',\n\t\t'getLineNumber',\n\t\t'getColumnNumber',\n\t\t'getEvalOrigin',\n\t\t'isToplevel',\n\t\t'isEval',\n\t\t'isNative',\n\t\t'isConstructor',\n\t\t'isAsync',\n\t\t'isPromiseAll',\n\t\t'getPromiseIndex'\n\t]);\n\n\tclass CallSite {\n\t\tconstructor(callSite) {\n\t\t\tapplyCallSiteGetters(this, callSite, callSiteGetters);\n\t\t}\n\t\tgetThis() {\n\t\t\treturn undefined;\n\t\t}\n\t\tgetFunction() {\n\t\t\treturn undefined;\n\t\t}\n\t\ttoString() {\n\t\t\treturn 'CallSite {}';\n\t\t}\n\t}\n\n\n\tfor (let i=0; i<callSiteGetters.length; i++) {\n\t\tconst name = callSiteGetters[i].name;\n\t\tconst funcProp = localReflectGetOwnPropertyDescriptor(OriginalCallSite.prototype, name);\n\t\tif (!funcProp) continue;\n\t\tconst propertyName = callSiteGetters[i].propName;\n\t\tconst func = {func() {\n\t\t\treturn this[propertyName];\n\t\t}}.func;\n\t\tconst nameProp = localReflectGetOwnPropertyDescriptor(func, 'name');\n\t\tif (!nameProp) throw localUnexpected();\n\t\tnameProp.value = name;\n\t\tif (!localReflectDefineProperty(func, 'name', nameProp)) throw localUnexpected();\n\t\tfuncProp.value = func;\n\t\tif (!localReflectDefineProperty(CallSite.prototype, name, funcProp)) throw localUnexpected();\n\t}\n\n\tif (!localReflectDefineProperty(LocalError, 'prepareStackTrace', {\n\t\tconfigurable: false,\n\t\tenumerable: false,\n\t\tget() {\n\t\t\treturn currentPrepareStackTrace;\n\t\t},\n\t\tset(value) {\n\t\t\tif (typeof(value) !== 'function') {\n\t\t\t\tcurrentPrepareStackTrace = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst wrapped = localReflectApply(localWeakMapGet, wrappedPrepareStackTrace, [value]);\n\t\t\tif (wrapped) {\n\t\t\t\tcurrentPrepareStackTrace = wrapped;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newWrapped = (error, sst) => {\n\t\t\t\tconst sandboxSst = ensureThis(sst);\n\t\t\t\tif (localArrayIsArray(sst)) {\n\t\t\t\t\tif (sst === sandboxSst) {\n\t\t\t\t\t\tfor (let i=0; i < sst.length; i++) {\n\t\t\t\t\t\t\tconst cs = sst[i];\n\t\t\t\t\t\t\tif (typeof cs === 'object' && localReflectGetPrototypeOf(cs) === OriginalCallSite.prototype) {\n\t\t\t\t\t\t\t\tsst[i] = new CallSite(cs);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsst = [];\n\t\t\t\t\t\tfor (let i=0; i < sandboxSst.length; i++) {\n\t\t\t\t\t\t\tconst cs = sandboxSst[i];\n\t\t\t\t\t\t\tlocalReflectDefineProperty(sst, i, {\n\t\t\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\t\t\tvalue: new CallSite(cs),\n\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\t\twritable: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsst = sandboxSst;\n\t\t\t\t}\n\t\t\t\treturn value(error, sst);\n\t\t\t};\n\t\t\tlocalReflectApply(localWeakMapSet, wrappedPrepareStackTrace, [value, newWrapped]);\n\t\t\tlocalReflectApply(localWeakMapSet, wrappedPrepareStackTrace, [newWrapped, newWrapped]);\n\t\t\tcurrentPrepareStackTrace = newWrapped;\n\t\t}\n\t})) throw localUnexpected();\n} else if (oldPrepareStackTraceDesc) {\n\tlocalReflectDefineProperty(LocalError, 'prepareStackTrace', oldPrepareStackTraceDesc);\n} else {\n\tlocalReflectDeleteProperty(LocalError, 'prepareStackTrace');\n}\n\n/*\n * Exception sanitization\n */\n\nconst withProxy = localObjectFreeze({\n\t__proto__: null,\n\thas(target, key) {\n\t\tif (key === host.INTERNAL_STATE_NAME) return false;\n\t\treturn localReflectHas(target, key);\n\t}\n});\n\nconst interanState = localObjectFreeze({\n\t__proto__: null,\n\twrapWith(x) {\n\t\tif (x === null || x === undefined) return x;\n\t\treturn new LocalProxy(localObject(x), withProxy);\n\t},\n\thandleException: ensureThis,\n\timport(what) {\n\t\tthrow new VMError('Dynamic Import not supported');\n\t}\n});\n\nif (!localReflectDefineProperty(global, host.INTERNAL_STATE_NAME, {\n\t__proto__: null,\n\tconfigurable: false,\n\tenumerable: false,\n\twritable: false,\n\tvalue: interanState\n})) throw localUnexpected();\n\n/*\n * Eval sanitization\n */\n\nfunction throwAsync() {\n\treturn new VMError('Async not available');\n}\n\nfunction makeFunction(inputArgs, isAsync, isGenerator) {\n\tconst lastArgs = inputArgs.length - 1;\n\tlet code = lastArgs >= 0 ? `${inputArgs[lastArgs]}` : '';\n\tlet args = lastArgs > 0 ? `${inputArgs[0]}` : '';\n\tfor (let i = 1; i < lastArgs; i++) {\n\t\targs += `,${inputArgs[i]}`;\n\t}\n\ttry {\n\t\tcode = host.transformAndCheck(args, code, isAsync, isGenerator, allowAsync);\n\t} catch (e) {\n\t\tthrow bridge.from(e);\n\t}\n\treturn localEval(code);\n}\n\nconst FunctionHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\treturn makeFunction(args, this.isAsync, this.isGenerator);\n\t},\n\tconstruct(target, args, newTarget) {\n\t\treturn makeFunction(args, this.isAsync, this.isGenerator);\n\t}\n};\n\nconst EvalHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tif (args.length === 0) return undefined;\n\t\tlet code = `${args[0]}`;\n\t\ttry {\n\t\t\tcode = host.transformAndCheck(null, code, false, false, allowAsync);\n\t\t} catch (e) {\n\t\t\tthrow bridge.from(e);\n\t\t}\n\t\treturn localEval(code);\n\t}\n};\n\nconst AsyncErrorHandler = {\n\t__proto__: null,\n\tapply(target, thiz, args) {\n\t\tthrow throwAsync();\n\t},\n\tconstruct(target, args, newTarget) {\n\t\tthrow throwAsync();\n\t}\n};\n\nfunction makeCheckFunction(isAsync, isGenerator) {\n\tif (isAsync && !allowAsync) return AsyncErrorHandler;\n\treturn {\n\t\t__proto__: FunctionHandler,\n\t\tisAsync,\n\t\tisGenerator\n\t};\n}\n\nfunction overrideWithProxy(obj, prop, value, handler) {\n\tconst proxy = new LocalProxy(value, handler);\n\tif (!localReflectDefineProperty(obj, prop, {__proto__: null, value: proxy})) throw localUnexpected();\n\treturn proxy;\n}\n\nconst proxiedFunction = overrideWithProxy(localFunction.prototype, 'constructor', localFunction, makeCheckFunction(false, false));\nif (GeneratorFunction) {\n\tif (!localReflectSetPrototypeOf(GeneratorFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(GeneratorFunction.prototype, 'constructor', GeneratorFunction, makeCheckFunction(false, true));\n}\nif (AsyncFunction) {\n\tif (!localReflectSetPrototypeOf(AsyncFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(AsyncFunction.prototype, 'constructor', AsyncFunction, makeCheckFunction(true, false));\n}\nif (AsyncGeneratorFunction) {\n\tif (!localReflectSetPrototypeOf(AsyncGeneratorFunction, proxiedFunction)) throw localUnexpected();\n\toverrideWithProxy(AsyncGeneratorFunction.prototype, 'constructor', AsyncGeneratorFunction, makeCheckFunction(true, true));\n}\n\nglobal.Function = proxiedFunction;\nglobal.eval = new LocalProxy(localEval, EvalHandler);\n\n/*\n * Promise sanitization\n */\n\nif (localPromise && !allowAsync) {\n\n\tconst PromisePrototype = localPromise.prototype;\n\n\toverrideWithProxy(PromisePrototype, 'then', PromisePrototype.then, AsyncErrorHandler);\n\t// This seems not to work, and will produce\n\t// UnhandledPromiseRejectionWarning: TypeError: Method Promise.prototype.then called on incompatible receiver [object Object].\n\t// This is likely caused since the host.Promise.prototype.then cannot use the VM Proxy object.\n\t// Contextify.connect(host.Promise.prototype.then, Promise.prototype.then);\n\n\tif (PromisePrototype.finally) {\n\t\toverrideWithProxy(PromisePrototype, 'finally', PromisePrototype.finally, AsyncErrorHandler);\n\t\t// Contextify.connect(host.Promise.prototype.finally, Promise.prototype.finally);\n\t}\n\tif (Promise.prototype.catch) {\n\t\toverrideWithProxy(PromisePrototype, 'catch', PromisePrototype.catch, AsyncErrorHandler);\n\t\t// Contextify.connect(host.Promise.prototype.catch, Promise.prototype.catch);\n\t}\n\n}\n\nfunction readonly(other, mock) {\n\t// Note: other@other(unsafe) mock@other(unsafe) returns@this(unsafe) throws@this(unsafe)\n\tif (!mock) return fromWithFactory(readonlyFactory, other);\n\tconst tmock = from(mock);\n\treturn fromWithFactory(obj=>new ReadOnlyMockHandler(obj, tmock), other);\n}\n\nreturn {\n\t__proto__: null,\n\treadonly,\n\tglobal\n};\n"], "filenames": ["lib/setup-sandbox.js"], "buggy_code_start_loc": [278], "buggy_code_end_loc": [285], "fixing_code_start_loc": [279], "fixing_code_end_loc": [303], "type": "CWE-913", "message": "vm2 is a sandbox that can run untrusted code with whitelisted Node's built-in modules. Prior to version 3.9.15, vm2 was not properly handling host objects passed to `Error.prepareStackTrace` in case of unhandled async errors. A threat actor could bypass the sandbox protections to gain remote code execution rights on the host running the sandbox. This vulnerability was patched in the release of version 3.9.15 of vm2. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-29017", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-06T20:15:08.723", "lastModified": "2023-04-13T13:20:46.003", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vm2 is a sandbox that can run untrusted code with whitelisted Node's built-in modules. Prior to version 3.9.15, vm2 was not properly handling host objects passed to `Error.prepareStackTrace` in case of unhandled async errors. A threat actor could bypass the sandbox protections to gain remote code execution rights on the host running the sandbox. This vulnerability was patched in the release of version 3.9.15 of vm2. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-913"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vm2_project:vm2:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.9.15", "matchCriteriaId": "ADA32E89-C69C-4459-9515-D3F7B53EFCAE"}]}]}], "references": [{"url": "https://gist.github.com/seongil-wi/2a44e082001b959bfe304b62121fb76d", "source": "security-advisories@github.com", "tags": ["Exploit"]}, {"url": "https://github.com/patriksimek/vm2/commit/d534e5785f38307b70d3aac1945260a261a94d50", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/patriksimek/vm2/issues/515", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://github.com/patriksimek/vm2/security/advisories/GHSA-7jxr-cg7f-gpgv", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/patriksimek/vm2/commit/d534e5785f38307b70d3aac1945260a261a94d50"}}