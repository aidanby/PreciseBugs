{"buggy_code": ["/*\n * plist.c\n * XML plist implementation\n *\n * Copyright (c) 2008 Jonathan Beck All Rights Reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n#include <inttypes.h>\n#include <locale.h>\n\n#include <libxml/parser.h>\n#include <libxml/tree.h>\n\n#include <node.h>\n#include <node_list.h>\n#include <node_iterator.h>\n\n#include \"plist.h\"\n#include \"base64.h\"\n\n#define XPLIST_TEXT\tBAD_CAST(\"text\")\n#define XPLIST_KEY\tBAD_CAST(\"key\")\n#define XPLIST_FALSE\tBAD_CAST(\"false\")\n#define XPLIST_TRUE\tBAD_CAST(\"true\")\n#define XPLIST_INT\tBAD_CAST(\"integer\")\n#define XPLIST_REAL\tBAD_CAST(\"real\")\n#define XPLIST_DATE\tBAD_CAST(\"date\")\n#define XPLIST_DATA\tBAD_CAST(\"data\")\n#define XPLIST_STRING\tBAD_CAST(\"string\")\n#define XPLIST_ARRAY\tBAD_CAST(\"array\")\n#define XPLIST_DICT\tBAD_CAST(\"dict\")\n\n#define MAC_EPOCH 978307200\n\nstatic const char *plist_base = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\\\n<!DOCTYPE plist PUBLIC \\\"-//Apple//DTD PLIST 1.0//EN\\\" \\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\">\\n\\\n<plist version=\\\"1.0\\\">\\n\\\n</plist>\\0\";\n\n\n/** Formats a block of text to be a given indentation and width.\n *\n * The total width of the return string will be depth + cols.\n *\n * @param buf The string to format.\n * @param cols The number of text columns for returned block of text.\n * @param depth The number of tabs to indent the returned block of text.\n *\n * @return The formatted string.\n */\nstatic char *format_string(const char *buf, size_t len, int cols, int depth)\n{\n    if (!buf || !(len > 0)) return NULL;\n    int colw = depth + cols + 1;\n    int nlines = len / cols + 1;\n    char *new_buf = NULL;\n    int i = 0;\n    int j = 0;\n\n    assert(cols >= 0);\n    assert(depth >= 0);\n\n    new_buf = (char*) malloc(nlines * colw + depth + 1);\n    assert(new_buf != 0);\n    memset(new_buf, 0, nlines * colw + depth + 1);\n\n    // Inserts new lines and tabs at appropriate locations\n    for (i = 0; i < nlines; i++)\n    {\n        new_buf[i * colw] = '\\n';\n        for (j = 0; j < depth; j++)\n            new_buf[i * colw + 1 + j] = '\\t';\n        memcpy(new_buf + i * colw + 1 + depth, buf + i * cols, (size_t)(i + 1) * cols <= len ? (size_t)cols : len - i * cols);\n    }\n    new_buf[len + (1 + depth) * nlines] = '\\n';\n\n    // Inserts final row of indentation and termination character\n    for (j = 0; j < depth; j++)\n        new_buf[len + (1 + depth) * nlines + 1 + j] = '\\t';\n    new_buf[len + (1 + depth) * nlines + depth + 1] = '\\0';\n\n    return new_buf;\n}\n\n\n\nstruct xml_node\n{\n    xmlNodePtr xml;\n    uint32_t depth;\n};\n\n/** Creates a new plist XML document.\n *\n * @return The plist XML document.\n */\nstatic xmlDocPtr new_xml_plist(void)\n{\n    char *plist = strdup(plist_base);\n    xmlDocPtr plist_xml = xmlParseMemory(plist, strlen(plist));\n\n    free(plist);\n\n    return plist_xml;\n}\n\nstatic struct node_t* new_key_node(const char* name)\n{\n    plist_data_t data = plist_new_plist_data();\n    data->type = PLIST_KEY;\n    int size = strlen(name);\n    data->strval = strdup(name);\n    data->length = size;\n    return node_create(NULL, data);\n}\n\nstatic struct node_t* new_uint_node(uint64_t value)\n{\n    plist_data_t data = plist_new_plist_data();\n    data->type = PLIST_UINT;\n    data->intval = value;\n    data->length = sizeof(uint64_t);\n    return node_create(NULL, data);\n}\n\nstatic void node_to_xml(node_t* node, void *xml_struct)\n{\n    struct xml_node *xstruct = NULL;\n    plist_data_t node_data = NULL;\n\n    xmlNodePtr child_node = NULL;\n    char isStruct = FALSE;\n    char isUIDNode = FALSE;\n\n    const xmlChar *tag = NULL;\n    char *val = NULL;\n\n    //for base64\n    char *valtmp = NULL;\n\n    uint32_t i = 0;\n\n    if (!node)\n        return;\n\n    xstruct = (struct xml_node *) xml_struct;\n    node_data = plist_get_data(node);\n\n    switch (node_data->type)\n    {\n    case PLIST_BOOLEAN:\n    {\n        if (node_data->boolval)\n            tag = XPLIST_TRUE;\n        else\n            tag = XPLIST_FALSE;\n    }\n    break;\n\n    case PLIST_UINT:\n        tag = XPLIST_INT;\n        val = (char*)malloc(64);\n        if (node_data->length == 16) {\n\t        (void)snprintf(val, 64, \"%\"PRIu64, node_data->intval);\n\t} else {\n\t        (void)snprintf(val, 64, \"%\"PRIi64, node_data->intval);\n\t}\n        break;\n\n    case PLIST_REAL:\n        tag = XPLIST_REAL;\n        val = (char*)malloc(64);\n        (void)snprintf(val, 64, \"%f\", node_data->realval);\n        break;\n\n    case PLIST_STRING:\n        tag = XPLIST_STRING;\n        val = strdup((char*) node_data->strval);\n        break;\n\n    case PLIST_KEY:\n        tag = XPLIST_KEY;\n        val = strdup((char*) node_data->strval);\n        break;\n\n    case PLIST_DATA:\n        tag = XPLIST_DATA;\n        if (node_data->length)\n        {\n            size_t len = node_data->length;\n            valtmp = base64encode(node_data->buff, &len);\n            val = format_string(valtmp, len, 68, xstruct->depth);\n            free(valtmp);\n        }\n        break;\n    case PLIST_ARRAY:\n        tag = XPLIST_ARRAY;\n        isStruct = TRUE;\n        break;\n    case PLIST_DICT:\n        tag = XPLIST_DICT;\n        isStruct = TRUE;\n        break;\n    case PLIST_DATE:\n        tag = XPLIST_DATE;\n        {\n            time_t timev = (time_t)node_data->timeval.tv_sec + MAC_EPOCH;\n            struct tm *btime = gmtime(&timev);\n            if (btime) {\n                val = (char*)malloc(24);\n                memset(val, 0, 24);\n                if (strftime(val, 24, \"%Y-%m-%dT%H:%M:%SZ\", btime) <= 0) {\n                    free (val);\n                    val = NULL;\n                }\n            }\n        }\n        break;\n    case PLIST_UID:\n        // special case for keyed encoding\n        tag = XPLIST_DICT;\n        isStruct = TRUE;\n        isUIDNode = TRUE;\n        node_data->type = PLIST_DICT;\n        node_attach(node, new_key_node(\"CF$UID\"));\n        node_attach(node, new_uint_node(node_data->intval));\n        break;\n    default:\n        break;\n    }\n\n    for (i = 0; i < xstruct->depth; i++)\n    {\n        xmlNodeAddContent(xstruct->xml, BAD_CAST(\"\\t\"));\n    }\n    if (node_data->type == PLIST_STRING || node_data->type == PLIST_KEY) {\n        /* make sure we convert the following predefined xml entities */\n        /* < = &lt; > = &gt; ' = &apos; \" = &quot; & = &amp; */\n        child_node = xmlNewTextChild(xstruct->xml, NULL, tag, BAD_CAST(val));\n    } else\n        child_node = xmlNewChild(xstruct->xml, NULL, tag, BAD_CAST(val));\n    xmlNodeAddContent(xstruct->xml, BAD_CAST(\"\\n\"));\n    if (val) {\n        free(val);\n    }\n\n    //add return for structured types\n    if (node_data->type == PLIST_ARRAY || node_data->type == PLIST_DICT)\n        xmlNodeAddContent(child_node, BAD_CAST(\"\\n\"));\n\n    //make sure we don't produce <data/> if it's empty\n    if ((node_data->type == PLIST_DATA) && !val) {\n        xmlNodeAddContent(child_node, BAD_CAST(\"\\n\"));\n        for (i = 0; i < xstruct->depth; i++)\n        {\n            xmlNodeAddContent(child_node, BAD_CAST(\"\\t\"));\n        }\n    }\n\n    if (isStruct)\n    {\n        struct xml_node child = { child_node, xstruct->depth + 1 };\n        node_iterator_t *ni = node_iterator_create(node->children);\n        node_t *ch;\n        while ((ch = node_iterator_next(ni))) {\n            node_to_xml(ch, &child);\n        }\n        node_iterator_destroy(ni);\n    }\n    //fix indent for structured types\n    if (node_data->type == PLIST_ARRAY || node_data->type == PLIST_DICT)\n    {\n\n        for (i = 0; i < xstruct->depth; i++)\n        {\n            xmlNodeAddContent(child_node, BAD_CAST(\"\\t\"));\n        }\n    }\n    if (isUIDNode)\n    {\n        unsigned int num = node_n_children(node);\n        unsigned int j;\n        for (j = num; j > 0; j--) {\n            node_t* ch = node_nth_child(node, j-1);\n            node_detach(node, ch);\n            node_destroy(ch);\n        }\n        node_data->type = PLIST_UID;\n    }\n\n    return;\n}\n\nstatic void parse_date(const char *strval, struct tm *btime)\n{\n    if (!btime) return;\n    memset(btime, 0, sizeof(struct tm));\n    if (!strval) return;\n#ifdef strptime\n    strptime((char*)strval, \"%Y-%m-%dT%H:%M:%SZ\", btime);\n#else\n    sscanf(strval, \"%d-%d-%dT%d:%d:%dZ\", &btime->tm_year, &btime->tm_mon, &btime->tm_mday, &btime->tm_hour, &btime->tm_min, &btime->tm_sec);\n    btime->tm_year-=1900;\n    btime->tm_mon--;\n#endif\n    btime->tm_isdst=0;\n}\n\nstatic void xml_to_node(xmlNodePtr xml_node, plist_t * plist_node)\n{\n    xmlNodePtr node = NULL;\n    plist_data_t data = NULL;\n    plist_t subnode = NULL;\n\n    //for string\n    long len = 0;\n    int type = 0;\n\n    if (!xml_node)\n        return;\n\n    for (node = xml_node->children; node; node = node->next)\n    {\n\n        while (node && !xmlStrcmp(node->name, XPLIST_TEXT))\n            node = node->next;\n        if (!node)\n            break;\n\n        if (!xmlStrcmp(node->name, BAD_CAST(\"comment\"))) {\n            continue;\n        }\n\n        data = plist_new_plist_data();\n        subnode = plist_new_node(data);\n        if (*plist_node)\n            node_attach(*plist_node, subnode);\n        else\n            *plist_node = subnode;\n\n        if (!xmlStrcmp(node->name, XPLIST_TRUE))\n        {\n            data->boolval = TRUE;\n            data->type = PLIST_BOOLEAN;\n            data->length = 1;\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_FALSE))\n        {\n            data->boolval = FALSE;\n            data->type = PLIST_BOOLEAN;\n            data->length = 1;\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_INT))\n        {\n            xmlChar *strval = xmlNodeGetContent(node);\n            int is_negative = 0;\n            char *str = (char*)strval;\n            if ((str[0] == '-') || (str[0] == '+')) {\n                if (str[0] == '-') {\n                    is_negative = 1;\n                }\n                str++;\n            }\n            char* endp = NULL;\n            data->intval = strtoull((char*)str, &endp, 0);\n            if ((endp != NULL) && (strlen(endp) > 0)) {\n                fprintf(stderr, \"%s: integer parse error: string contains invalid characters: '%s'\\n\", __func__, endp);\n            }\n            if (is_negative || (data->intval <= INT64_MAX)) {\n                int64_t v = data->intval;\n                if (is_negative) {\n                    v = -v;\n                }\n                data->intval = (uint64_t)v;\n                data->length = 8;\n            } else {\n                data->length = 16;\n            }\n            data->type = PLIST_UINT;\n            xmlFree(strval);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_REAL))\n        {\n            xmlChar *strval = xmlNodeGetContent(node);\n            data->realval = atof((char *) strval);\n            data->type = PLIST_REAL;\n            data->length = 8;\n            xmlFree(strval);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_DATE))\n        {\n            xmlChar *strval = xmlNodeGetContent(node);\n            time_t timev = 0;\n            if (strlen((const char*)strval) >= 11) {\n                struct tm btime;\n                struct tm* tm_utc;\n                parse_date((const char*)strval, &btime);\n                timev = mktime(&btime);\n                tm_utc = gmtime(&timev);\n                timev -= (mktime(tm_utc) - timev);\n            }\n            data->timeval.tv_sec = (long)(timev - MAC_EPOCH);\n            data->timeval.tv_usec = 0;\n            data->type = PLIST_DATE;\n            data->length = sizeof(struct timeval);\n            xmlFree(strval);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_STRING))\n        {\n            xmlChar *strval = xmlNodeGetContent(node);\n            len = strlen((char *) strval);\n            type = xmlDetectCharEncoding(strval, len);\n\n            if (XML_CHAR_ENCODING_UTF8 == type || XML_CHAR_ENCODING_ASCII == type || XML_CHAR_ENCODING_NONE == type)\n            {\n                data->strval = strdup((char *) strval);\n                data->type = PLIST_STRING;\n                data->length = strlen(data->strval);\n            }\n            xmlFree(strval);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_KEY))\n        {\n            xmlChar *strval = xmlNodeGetContent(node);\n            len = strlen((char *) strval);\n            type = xmlDetectCharEncoding(strval, len);\n\n            if (XML_CHAR_ENCODING_UTF8 == type || XML_CHAR_ENCODING_ASCII == type || XML_CHAR_ENCODING_NONE == type)\n            {\n                data->strval = strdup((char *) strval);\n                data->type = PLIST_KEY;\n                data->length = strlen(data->strval);\n            }\n            xmlFree(strval);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_DATA))\n        {\n            xmlChar *strval = xmlNodeGetContent(node);\n            size_t size = 0;\n            unsigned char *dec = base64decode((char*)strval, &size);\n            data->buff = (uint8_t *) malloc(size * sizeof(uint8_t));\n            memcpy(data->buff, dec, size * sizeof(uint8_t));\n            free(dec);\n            data->length = size;\n            data->type = PLIST_DATA;\n            xmlFree(strval);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_ARRAY))\n        {\n            data->type = PLIST_ARRAY;\n            xml_to_node(node, &subnode);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_DICT))\n        {\n            data->type = PLIST_DICT;\n            xml_to_node(node, &subnode);\n            if (plist_get_node_type(subnode) == PLIST_DICT) {\n                if (plist_dict_get_size(subnode) == 1) {\n                    plist_t uid = plist_dict_get_item(subnode, \"CF$UID\");\n                    if (uid) {\n                        uint64_t val = 0;\n                        plist_get_uint_val(uid, &val);\n                        plist_dict_remove_item(subnode, \"CF$UID\");\n                        plist_data_t nodedata = plist_get_data((node_t*)subnode);\n                        free(nodedata->buff);\n                        nodedata->type = PLIST_UID;\n                        nodedata->length = sizeof(uint64_t);\n                        nodedata->intval = val;\n                    } \n                }\n            }\n            continue;\n        }\n    }\n}\n\nPLIST_API void plist_to_xml(plist_t plist, char **plist_xml, uint32_t * length)\n{\n    xmlDocPtr plist_doc = NULL;\n    xmlNodePtr root_node = NULL;\n    struct xml_node root = { NULL, 0 };\n    int size = 0;\n\n    if (!plist || !plist_xml || *plist_xml)\n        return;\n    plist_doc = new_xml_plist();\n    root_node = xmlDocGetRootElement(plist_doc);\n    root.xml = root_node;\n\n    char *current_locale = setlocale(LC_NUMERIC, NULL);\n    char *saved_locale = NULL;\n    if (current_locale) {\n        saved_locale = strdup(current_locale);\n    }\n    if (saved_locale) {\n        setlocale(LC_NUMERIC, \"POSIX\");\n    }\n    node_to_xml(plist, &root);\n\n    xmlChar* tmp = NULL;\n    xmlDocDumpMemory(plist_doc, &tmp, &size);\n    if (size >= 0 && tmp)\n    {\n\t/* make sure to copy the terminating 0-byte */\n        *plist_xml = (char*)malloc((size+1) * sizeof(char));\n\tmemcpy(*plist_xml, tmp, size+1);\n        *length = size;\n\txmlFree(tmp);\n\ttmp = NULL;\n    }\n    xmlFreeDoc(plist_doc);\n\n    if (saved_locale) {\n        setlocale(LC_NUMERIC, saved_locale);\n        free(saved_locale);\n    }\n}\n\nPLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}\n"], "fixing_code": ["/*\n * plist.c\n * XML plist implementation\n *\n * Copyright (c) 2008 Jonathan Beck All Rights Reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n#include <inttypes.h>\n#include <locale.h>\n\n#include <libxml/xmlIO.h>\n#include <libxml/parser.h>\n#include <libxml/tree.h>\n\n#include <node.h>\n#include <node_list.h>\n#include <node_iterator.h>\n\n#include \"plist.h\"\n#include \"base64.h\"\n\n#define XPLIST_TEXT\tBAD_CAST(\"text\")\n#define XPLIST_KEY\tBAD_CAST(\"key\")\n#define XPLIST_FALSE\tBAD_CAST(\"false\")\n#define XPLIST_TRUE\tBAD_CAST(\"true\")\n#define XPLIST_INT\tBAD_CAST(\"integer\")\n#define XPLIST_REAL\tBAD_CAST(\"real\")\n#define XPLIST_DATE\tBAD_CAST(\"date\")\n#define XPLIST_DATA\tBAD_CAST(\"data\")\n#define XPLIST_STRING\tBAD_CAST(\"string\")\n#define XPLIST_ARRAY\tBAD_CAST(\"array\")\n#define XPLIST_DICT\tBAD_CAST(\"dict\")\n\n#define MAC_EPOCH 978307200\n\nstatic const char *plist_base = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\\\n<!DOCTYPE plist PUBLIC \\\"-//Apple//DTD PLIST 1.0//EN\\\" \\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\">\\n\\\n<plist version=\\\"1.0\\\">\\n\\\n</plist>\\0\";\n\n\n/** Formats a block of text to be a given indentation and width.\n *\n * The total width of the return string will be depth + cols.\n *\n * @param buf The string to format.\n * @param cols The number of text columns for returned block of text.\n * @param depth The number of tabs to indent the returned block of text.\n *\n * @return The formatted string.\n */\nstatic char *format_string(const char *buf, size_t len, int cols, int depth)\n{\n    if (!buf || !(len > 0)) return NULL;\n    int colw = depth + cols + 1;\n    int nlines = len / cols + 1;\n    char *new_buf = NULL;\n    int i = 0;\n    int j = 0;\n\n    assert(cols >= 0);\n    assert(depth >= 0);\n\n    new_buf = (char*) malloc(nlines * colw + depth + 1);\n    assert(new_buf != 0);\n    memset(new_buf, 0, nlines * colw + depth + 1);\n\n    // Inserts new lines and tabs at appropriate locations\n    for (i = 0; i < nlines; i++)\n    {\n        new_buf[i * colw] = '\\n';\n        for (j = 0; j < depth; j++)\n            new_buf[i * colw + 1 + j] = '\\t';\n        memcpy(new_buf + i * colw + 1 + depth, buf + i * cols, (size_t)(i + 1) * cols <= len ? (size_t)cols : len - i * cols);\n    }\n    new_buf[len + (1 + depth) * nlines] = '\\n';\n\n    // Inserts final row of indentation and termination character\n    for (j = 0; j < depth; j++)\n        new_buf[len + (1 + depth) * nlines + 1 + j] = '\\t';\n    new_buf[len + (1 + depth) * nlines + depth + 1] = '\\0';\n\n    return new_buf;\n}\n\n\n\nstruct xml_node\n{\n    xmlNodePtr xml;\n    uint32_t depth;\n};\n\n/** Creates a new plist XML document.\n *\n * @return The plist XML document.\n */\nstatic xmlDocPtr new_xml_plist(void)\n{\n    char *plist = strdup(plist_base);\n    xmlDocPtr plist_xml = xmlParseMemory(plist, strlen(plist));\n\n    free(plist);\n\n    return plist_xml;\n}\n\nstatic struct node_t* new_key_node(const char* name)\n{\n    plist_data_t data = plist_new_plist_data();\n    data->type = PLIST_KEY;\n    int size = strlen(name);\n    data->strval = strdup(name);\n    data->length = size;\n    return node_create(NULL, data);\n}\n\nstatic struct node_t* new_uint_node(uint64_t value)\n{\n    plist_data_t data = plist_new_plist_data();\n    data->type = PLIST_UINT;\n    data->intval = value;\n    data->length = sizeof(uint64_t);\n    return node_create(NULL, data);\n}\n\nstatic void node_to_xml(node_t* node, void *xml_struct)\n{\n    struct xml_node *xstruct = NULL;\n    plist_data_t node_data = NULL;\n\n    xmlNodePtr child_node = NULL;\n    char isStruct = FALSE;\n    char isUIDNode = FALSE;\n\n    const xmlChar *tag = NULL;\n    char *val = NULL;\n\n    //for base64\n    char *valtmp = NULL;\n\n    uint32_t i = 0;\n\n    if (!node)\n        return;\n\n    xstruct = (struct xml_node *) xml_struct;\n    node_data = plist_get_data(node);\n\n    switch (node_data->type)\n    {\n    case PLIST_BOOLEAN:\n    {\n        if (node_data->boolval)\n            tag = XPLIST_TRUE;\n        else\n            tag = XPLIST_FALSE;\n    }\n    break;\n\n    case PLIST_UINT:\n        tag = XPLIST_INT;\n        val = (char*)malloc(64);\n        if (node_data->length == 16) {\n\t        (void)snprintf(val, 64, \"%\"PRIu64, node_data->intval);\n\t} else {\n\t        (void)snprintf(val, 64, \"%\"PRIi64, node_data->intval);\n\t}\n        break;\n\n    case PLIST_REAL:\n        tag = XPLIST_REAL;\n        val = (char*)malloc(64);\n        (void)snprintf(val, 64, \"%f\", node_data->realval);\n        break;\n\n    case PLIST_STRING:\n        tag = XPLIST_STRING;\n        val = strdup((char*) node_data->strval);\n        break;\n\n    case PLIST_KEY:\n        tag = XPLIST_KEY;\n        val = strdup((char*) node_data->strval);\n        break;\n\n    case PLIST_DATA:\n        tag = XPLIST_DATA;\n        if (node_data->length)\n        {\n            size_t len = node_data->length;\n            valtmp = base64encode(node_data->buff, &len);\n            val = format_string(valtmp, len, 68, xstruct->depth);\n            free(valtmp);\n        }\n        break;\n    case PLIST_ARRAY:\n        tag = XPLIST_ARRAY;\n        isStruct = TRUE;\n        break;\n    case PLIST_DICT:\n        tag = XPLIST_DICT;\n        isStruct = TRUE;\n        break;\n    case PLIST_DATE:\n        tag = XPLIST_DATE;\n        {\n            time_t timev = (time_t)node_data->timeval.tv_sec + MAC_EPOCH;\n            struct tm *btime = gmtime(&timev);\n            if (btime) {\n                val = (char*)malloc(24);\n                memset(val, 0, 24);\n                if (strftime(val, 24, \"%Y-%m-%dT%H:%M:%SZ\", btime) <= 0) {\n                    free (val);\n                    val = NULL;\n                }\n            }\n        }\n        break;\n    case PLIST_UID:\n        // special case for keyed encoding\n        tag = XPLIST_DICT;\n        isStruct = TRUE;\n        isUIDNode = TRUE;\n        node_data->type = PLIST_DICT;\n        node_attach(node, new_key_node(\"CF$UID\"));\n        node_attach(node, new_uint_node(node_data->intval));\n        break;\n    default:\n        break;\n    }\n\n    for (i = 0; i < xstruct->depth; i++)\n    {\n        xmlNodeAddContent(xstruct->xml, BAD_CAST(\"\\t\"));\n    }\n    if (node_data->type == PLIST_STRING || node_data->type == PLIST_KEY) {\n        /* make sure we convert the following predefined xml entities */\n        /* < = &lt; > = &gt; ' = &apos; \" = &quot; & = &amp; */\n        child_node = xmlNewTextChild(xstruct->xml, NULL, tag, BAD_CAST(val));\n    } else\n        child_node = xmlNewChild(xstruct->xml, NULL, tag, BAD_CAST(val));\n    xmlNodeAddContent(xstruct->xml, BAD_CAST(\"\\n\"));\n    if (val) {\n        free(val);\n    }\n\n    //add return for structured types\n    if (node_data->type == PLIST_ARRAY || node_data->type == PLIST_DICT)\n        xmlNodeAddContent(child_node, BAD_CAST(\"\\n\"));\n\n    //make sure we don't produce <data/> if it's empty\n    if ((node_data->type == PLIST_DATA) && !val) {\n        xmlNodeAddContent(child_node, BAD_CAST(\"\\n\"));\n        for (i = 0; i < xstruct->depth; i++)\n        {\n            xmlNodeAddContent(child_node, BAD_CAST(\"\\t\"));\n        }\n    }\n\n    if (isStruct)\n    {\n        struct xml_node child = { child_node, xstruct->depth + 1 };\n        node_iterator_t *ni = node_iterator_create(node->children);\n        node_t *ch;\n        while ((ch = node_iterator_next(ni))) {\n            node_to_xml(ch, &child);\n        }\n        node_iterator_destroy(ni);\n    }\n    //fix indent for structured types\n    if (node_data->type == PLIST_ARRAY || node_data->type == PLIST_DICT)\n    {\n\n        for (i = 0; i < xstruct->depth; i++)\n        {\n            xmlNodeAddContent(child_node, BAD_CAST(\"\\t\"));\n        }\n    }\n    if (isUIDNode)\n    {\n        unsigned int num = node_n_children(node);\n        unsigned int j;\n        for (j = num; j > 0; j--) {\n            node_t* ch = node_nth_child(node, j-1);\n            node_detach(node, ch);\n            node_destroy(ch);\n        }\n        node_data->type = PLIST_UID;\n    }\n\n    return;\n}\n\nstatic void parse_date(const char *strval, struct tm *btime)\n{\n    if (!btime) return;\n    memset(btime, 0, sizeof(struct tm));\n    if (!strval) return;\n#ifdef strptime\n    strptime((char*)strval, \"%Y-%m-%dT%H:%M:%SZ\", btime);\n#else\n    sscanf(strval, \"%d-%d-%dT%d:%d:%dZ\", &btime->tm_year, &btime->tm_mon, &btime->tm_mday, &btime->tm_hour, &btime->tm_min, &btime->tm_sec);\n    btime->tm_year-=1900;\n    btime->tm_mon--;\n#endif\n    btime->tm_isdst=0;\n}\n\nstatic void xml_to_node(xmlNodePtr xml_node, plist_t * plist_node)\n{\n    xmlNodePtr node = NULL;\n    plist_data_t data = NULL;\n    plist_t subnode = NULL;\n\n    //for string\n    long len = 0;\n    int type = 0;\n\n    if (!xml_node)\n        return;\n\n    for (node = xml_node->children; node; node = node->next)\n    {\n\n        while (node && !xmlStrcmp(node->name, XPLIST_TEXT))\n            node = node->next;\n        if (!node)\n            break;\n\n        if (!xmlStrcmp(node->name, BAD_CAST(\"comment\"))) {\n            continue;\n        }\n\n        data = plist_new_plist_data();\n        subnode = plist_new_node(data);\n        if (*plist_node)\n            node_attach(*plist_node, subnode);\n        else\n            *plist_node = subnode;\n\n        if (!xmlStrcmp(node->name, XPLIST_TRUE))\n        {\n            data->boolval = TRUE;\n            data->type = PLIST_BOOLEAN;\n            data->length = 1;\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_FALSE))\n        {\n            data->boolval = FALSE;\n            data->type = PLIST_BOOLEAN;\n            data->length = 1;\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_INT))\n        {\n            xmlChar *strval = xmlNodeGetContent(node);\n            int is_negative = 0;\n            char *str = (char*)strval;\n            if ((str[0] == '-') || (str[0] == '+')) {\n                if (str[0] == '-') {\n                    is_negative = 1;\n                }\n                str++;\n            }\n            char* endp = NULL;\n            data->intval = strtoull((char*)str, &endp, 0);\n            if ((endp != NULL) && (strlen(endp) > 0)) {\n                fprintf(stderr, \"%s: integer parse error: string contains invalid characters: '%s'\\n\", __func__, endp);\n            }\n            if (is_negative || (data->intval <= INT64_MAX)) {\n                int64_t v = data->intval;\n                if (is_negative) {\n                    v = -v;\n                }\n                data->intval = (uint64_t)v;\n                data->length = 8;\n            } else {\n                data->length = 16;\n            }\n            data->type = PLIST_UINT;\n            xmlFree(strval);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_REAL))\n        {\n            xmlChar *strval = xmlNodeGetContent(node);\n            data->realval = atof((char *) strval);\n            data->type = PLIST_REAL;\n            data->length = 8;\n            xmlFree(strval);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_DATE))\n        {\n            xmlChar *strval = xmlNodeGetContent(node);\n            time_t timev = 0;\n            if (strlen((const char*)strval) >= 11) {\n                struct tm btime;\n                struct tm* tm_utc;\n                parse_date((const char*)strval, &btime);\n                timev = mktime(&btime);\n                tm_utc = gmtime(&timev);\n                timev -= (mktime(tm_utc) - timev);\n            }\n            data->timeval.tv_sec = (long)(timev - MAC_EPOCH);\n            data->timeval.tv_usec = 0;\n            data->type = PLIST_DATE;\n            data->length = sizeof(struct timeval);\n            xmlFree(strval);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_STRING))\n        {\n            xmlChar *strval = xmlNodeGetContent(node);\n            len = strlen((char *) strval);\n            type = xmlDetectCharEncoding(strval, len);\n\n            if (XML_CHAR_ENCODING_UTF8 == type || XML_CHAR_ENCODING_ASCII == type || XML_CHAR_ENCODING_NONE == type)\n            {\n                data->strval = strdup((char *) strval);\n                data->type = PLIST_STRING;\n                data->length = strlen(data->strval);\n            }\n            xmlFree(strval);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_KEY))\n        {\n            xmlChar *strval = xmlNodeGetContent(node);\n            len = strlen((char *) strval);\n            type = xmlDetectCharEncoding(strval, len);\n\n            if (XML_CHAR_ENCODING_UTF8 == type || XML_CHAR_ENCODING_ASCII == type || XML_CHAR_ENCODING_NONE == type)\n            {\n                data->strval = strdup((char *) strval);\n                data->type = PLIST_KEY;\n                data->length = strlen(data->strval);\n            }\n            xmlFree(strval);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_DATA))\n        {\n            xmlChar *strval = xmlNodeGetContent(node);\n            size_t size = 0;\n            unsigned char *dec = base64decode((char*)strval, &size);\n            data->buff = (uint8_t *) malloc(size * sizeof(uint8_t));\n            memcpy(data->buff, dec, size * sizeof(uint8_t));\n            free(dec);\n            data->length = size;\n            data->type = PLIST_DATA;\n            xmlFree(strval);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_ARRAY))\n        {\n            data->type = PLIST_ARRAY;\n            xml_to_node(node, &subnode);\n            continue;\n        }\n\n        if (!xmlStrcmp(node->name, XPLIST_DICT))\n        {\n            data->type = PLIST_DICT;\n            xml_to_node(node, &subnode);\n            if (plist_get_node_type(subnode) == PLIST_DICT) {\n                if (plist_dict_get_size(subnode) == 1) {\n                    plist_t uid = plist_dict_get_item(subnode, \"CF$UID\");\n                    if (uid) {\n                        uint64_t val = 0;\n                        plist_get_uint_val(uid, &val);\n                        plist_dict_remove_item(subnode, \"CF$UID\");\n                        plist_data_t nodedata = plist_get_data((node_t*)subnode);\n                        free(nodedata->buff);\n                        nodedata->type = PLIST_UID;\n                        nodedata->length = sizeof(uint64_t);\n                        nodedata->intval = val;\n                    } \n                }\n            }\n            continue;\n        }\n    }\n}\n\nPLIST_API void plist_to_xml(plist_t plist, char **plist_xml, uint32_t * length)\n{\n    xmlDocPtr plist_doc = NULL;\n    xmlNodePtr root_node = NULL;\n    struct xml_node root = { NULL, 0 };\n    int size = 0;\n\n    if (!plist || !plist_xml || *plist_xml)\n        return;\n    plist_doc = new_xml_plist();\n    root_node = xmlDocGetRootElement(plist_doc);\n    root.xml = root_node;\n\n    char *current_locale = setlocale(LC_NUMERIC, NULL);\n    char *saved_locale = NULL;\n    if (current_locale) {\n        saved_locale = strdup(current_locale);\n    }\n    if (saved_locale) {\n        setlocale(LC_NUMERIC, \"POSIX\");\n    }\n    node_to_xml(plist, &root);\n\n    xmlChar* tmp = NULL;\n    xmlDocDumpMemory(plist_doc, &tmp, &size);\n    if (size >= 0 && tmp)\n    {\n\t/* make sure to copy the terminating 0-byte */\n        *plist_xml = (char*)malloc((size+1) * sizeof(char));\n\tmemcpy(*plist_xml, tmp, size+1);\n        *length = size;\n\txmlFree(tmp);\n\ttmp = NULL;\n    }\n    xmlFreeDoc(plist_doc);\n\n    if (saved_locale) {\n        setlocale(LC_NUMERIC, saved_locale);\n        free(saved_locale);\n    }\n}\n\nstatic xmlParserInputPtr plist_xml_external_entity_loader(const char *URL, const char *ID, xmlParserCtxtPtr ctxt)\n{\n    return NULL;\n}\n\nPLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    /* CVE-2013-0339: disable external entity loading to prevent XXE vulnerability */\n    xmlSetExternalEntityLoader(plist_xml_external_entity_loader);\n\n    /* read XML from memory and disable network access for security reasons */\n    xmlDocPtr plist_doc = xmlReadMemory(plist_xml, length, \"plist_from_xml:memory\", NULL, XML_PARSE_NONET);\n    if (plist_doc) {\n        xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n\n        xml_to_node(root_node, plist);\n        xmlFreeDoc(plist_doc);\n    }\n}\n"], "filenames": ["src/xplist.c"], "buggy_code_start_loc": [31], "buggy_code_end_loc": [566], "fixing_code_start_loc": [32], "fixing_code_end_loc": [578], "type": "CWE-611", "message": "A vulnerability classified as problematic has been found in UIKit0 libplist 1.12. This affects the function plist_from_xml of the file src/xplist.c of the component XML Handler. The manipulation leads to xml external entity reference. The name of the patch is c086cb139af7c82845f6d565e636073ff4b37440. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-221499.", "other": {"cve": {"id": "CVE-2015-10082", "sourceIdentifier": "cna@vuldb.com", "published": "2023-02-21T07:15:10.173", "lastModified": "2023-03-02T23:03:01.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic has been found in UIKit0 libplist 1.12. This affects the function plist_from_xml of the file src/xplist.c of the component XML Handler. The manipulation leads to xml external entity reference. The name of the patch is c086cb139af7c82845f6d565e636073ff4b37440. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-221499."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libimobiledevice:libplist:1.12:*:*:*:*:*:*:*", "matchCriteriaId": "1CFE62B4-E9A8-4711-AF4E-86B3D048A648"}]}]}], "references": [{"url": "https://github.com/UIKit0/libplist/commit/c086cb139af7c82845f6d565e636073ff4b37440", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://vuldb.com/?ctiid.221499", "source": "cna@vuldb.com", "tags": ["Permissions Required"]}, {"url": "https://vuldb.com/?id.221499", "source": "cna@vuldb.com", "tags": ["Permissions Required"]}]}, "github_commit_url": "https://github.com/UIKit0/libplist/commit/c086cb139af7c82845f6d565e636073ff4b37440"}}