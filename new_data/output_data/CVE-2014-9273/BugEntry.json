{"buggy_code": ["/* hivex - Windows Registry \"hive\" extraction library.\n * Copyright (C) 2009-2011 Red Hat Inc.\n * Derived from code by Petter Nordahl-Hagen under a compatible license:\n *   Copyright (c) 1997-2007 Petter Nordahl-Hagen.\n * Derived from code by Markus Stephany under a compatible license:\n *   Copyright (c) 2000-2004, Markus Stephany.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation;\n * version 2.1 of the License.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * See file LICENSE for the full license.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <assert.h>\n\n#ifdef HAVE_MMAP\n#include <sys/mman.h>\n#else\n/* On systems without mmap (and munmap), use a replacement function. */\n#include \"mmap.h\"\n#endif\n\n#include \"full-read.h\"\n#include \"full-write.h\"\n#include \"c-ctype.h\"\n\n#include \"hivex.h\"\n#include \"hivex-internal.h\"\n\nstatic uint32_t\nheader_checksum (const hive_h *h)\n{\n  uint32_t *daddr = (uint32_t *) h->addr;\n  size_t i;\n  uint32_t sum = 0;\n\n  for (i = 0; i < 0x1fc / 4; ++i) {\n    sum ^= le32toh (*daddr);\n    daddr++;\n  }\n\n  return sum;\n}\n\n#define HIVEX_OPEN_MSGLVL_MASK (HIVEX_OPEN_VERBOSE|HIVEX_OPEN_DEBUG)\n\nhive_h *\nhivex_open (const char *filename, int flags)\n{\n  hive_h *h = NULL;\n\n  assert (sizeof (struct ntreg_header) == 0x1000);\n  assert (offsetof (struct ntreg_header, csum) == 0x1fc);\n\n  h = calloc (1, sizeof *h);\n  if (h == NULL)\n    goto error;\n\n  h->msglvl = flags & HIVEX_OPEN_MSGLVL_MASK;\n\n  const char *debug = getenv (\"HIVEX_DEBUG\");\n  if (debug && STREQ (debug, \"1\"))\n    h->msglvl = 2;\n\n  DEBUG (2, \"created handle %p\", h);\n\n  h->writable = !!(flags & HIVEX_OPEN_WRITE);\n  h->filename = strdup (filename);\n  if (h->filename == NULL)\n    goto error;\n\n#ifdef O_CLOEXEC\n  h->fd = open (filename, O_RDONLY | O_CLOEXEC | O_BINARY);\n#else\n  h->fd = open (filename, O_RDONLY | O_BINARY);\n#endif\n  if (h->fd == -1)\n    goto error;\n#ifndef O_CLOEXEC\n  fcntl (h->fd, F_SETFD, FD_CLOEXEC);\n#endif\n\n  struct stat statbuf;\n  if (fstat (h->fd, &statbuf) == -1)\n    goto error;\n\n  h->size = statbuf.st_size;\n\n  if (!h->writable) {\n    h->addr = mmap (NULL, h->size, PROT_READ, MAP_SHARED, h->fd, 0);\n    if (h->addr == MAP_FAILED)\n      goto error;\n\n    DEBUG (2, \"mapped file at %p\", h->addr);\n  } else {\n    h->addr = malloc (h->size);\n    if (h->addr == NULL)\n      goto error;\n\n    if (full_read (h->fd, h->addr, h->size) < h->size)\n      goto error;\n\n    /* We don't need the file descriptor along this path, since we\n     * have read all the data.\n     */\n    if (close (h->fd) == -1)\n      goto error;\n    h->fd = -1;\n  }\n\n  /* Check header. */\n  if (h->hdr->magic[0] != 'r' ||\n      h->hdr->magic[1] != 'e' ||\n      h->hdr->magic[2] != 'g' ||\n      h->hdr->magic[3] != 'f') {\n    SET_ERRNO (ENOTSUP,\n               \"%s: not a Windows NT Registry hive file\", filename);\n    goto error;\n  }\n\n  /* Check major version. */\n  uint32_t major_ver = le32toh (h->hdr->major_ver);\n  if (major_ver != 1) {\n    SET_ERRNO (ENOTSUP,\n               \"%s: hive file major version %\" PRIu32 \" (expected 1)\",\n               filename, major_ver);\n    goto error;\n  }\n\n  h->bitmap = calloc (1 + h->size / 32, 1);\n  if (h->bitmap == NULL)\n    goto error;\n\n  /* Header checksum. */\n  uint32_t sum = header_checksum (h);\n  if (sum != le32toh (h->hdr->csum)) {\n    SET_ERRNO (EINVAL, \"%s: bad checksum in hive header\", filename);\n    goto error;\n  }\n\n  /* Last modified time. */\n  h->last_modified = le64toh ((int64_t) h->hdr->last_modified);\n\n  if (h->msglvl >= 2) {\n    char *name = _hivex_windows_utf16_to_utf8 (h->hdr->name, 64);\n\n    fprintf (stderr,\n             \"hivex_open: header fields:\\n\"\n             \"  file version             %\" PRIu32 \".%\" PRIu32 \"\\n\"\n             \"  sequence nos             %\" PRIu32 \" %\" PRIu32 \"\\n\"\n             \"    (sequences nos should match if hive was synched at shutdown)\\n\"\n             \"  last modified            %\" PRIu64 \"\\n\"\n             \"    (Windows filetime, x 100 ns since 1601-01-01)\\n\"\n             \"  original file name       %s\\n\"\n             \"    (only 32 chars are stored, name is probably truncated)\\n\"\n             \"  root offset              0x%x + 0x1000\\n\"\n             \"  end of last page         0x%x + 0x1000 (total file size 0x%zx)\\n\"\n             \"  checksum                 0x%x (calculated 0x%x)\\n\",\n             major_ver, le32toh (h->hdr->minor_ver),\n             le32toh (h->hdr->sequence1), le32toh (h->hdr->sequence2),\n             h->last_modified,\n             name ? name : \"(conversion failed)\",\n             le32toh (h->hdr->offset),\n             le32toh (h->hdr->blocks), h->size,\n             le32toh (h->hdr->csum), sum);\n    free (name);\n  }\n\n  h->rootoffs = le32toh (h->hdr->offset) + 0x1000;\n  h->endpages = le32toh (h->hdr->blocks) + 0x1000;\n\n  DEBUG (2, \"root offset = 0x%zx\", h->rootoffs);\n\n  /* We'll set this flag when we see a block with the root offset (ie.\n   * the root block).\n   */\n  int seen_root_block = 0, bad_root_block = 0;\n\n  /* Collect some stats. */\n  size_t pages = 0;           /* Number of hbin pages read. */\n  size_t smallest_page = SIZE_MAX, largest_page = 0;\n  size_t blocks = 0;          /* Total number of blocks found. */\n  size_t smallest_block = SIZE_MAX, largest_block = 0, blocks_bytes = 0;\n  size_t used_blocks = 0;     /* Total number of used blocks found. */\n  size_t used_size = 0;       /* Total size (bytes) of used blocks. */\n\n  /* Read the pages and blocks.  The aim here is to be robust against\n   * corrupt or malicious registries.  So we make sure the loops\n   * always make forward progress.  We add the address of each block\n   * we read to a hash table so pointers will only reference the start\n   * of valid blocks.\n   */\n  size_t off;\n  struct ntreg_hbin_page *page;\n  for (off = 0x1000; off < h->size; off += le32toh (page->page_size)) {\n    if (off >= h->endpages)\n      break;\n\n    page = (struct ntreg_hbin_page *) ((char *) h->addr + off);\n    if (page->magic[0] != 'h' ||\n        page->magic[1] != 'b' ||\n        page->magic[2] != 'i' ||\n        page->magic[3] != 'n') {\n      SET_ERRNO (ENOTSUP,\n                 \"%s: trailing garbage at end of file \"\n                 \"(at 0x%zx, after %zu pages)\",\n                 filename, off, pages);\n      goto error;\n    }\n\n    size_t page_size = le32toh (page->page_size);\n    DEBUG (2, \"page at 0x%zx, size %zu\", off, page_size);\n    pages++;\n    if (page_size < smallest_page) smallest_page = page_size;\n    if (page_size > largest_page) largest_page = page_size;\n\n    if (page_size <= sizeof (struct ntreg_hbin_page) ||\n        (page_size & 0x0fff) != 0) {\n      SET_ERRNO (ENOTSUP,\n                 \"%s: page size %zu at 0x%zx, bad registry\",\n                 filename, page_size, off);\n      goto error;\n    }\n\n    /* Read the blocks in this page. */\n    size_t blkoff;\n    struct ntreg_hbin_block *block;\n    size_t seg_len;\n    for (blkoff = off + 0x20;\n         blkoff < off + page_size;\n         blkoff += seg_len) {\n      blocks++;\n\n      int is_root = blkoff == h->rootoffs;\n      if (is_root)\n        seen_root_block = 1;\n\n      block = (struct ntreg_hbin_block *) ((char *) h->addr + blkoff);\n      int used;\n      seg_len = block_len (h, blkoff, &used);\n      if (seg_len <= 4 || (seg_len & 3) != 0) {\n        SET_ERRNO (ENOTSUP,\n                   \"%s: block size %\" PRIu32 \" at 0x%zx, bad registry\",\n                   filename, le32toh (block->seg_len), blkoff);\n        goto error;\n      }\n\n      if (h->msglvl >= 2) {\n        unsigned char *id = (unsigned char *) block->id;\n        int id0 = id[0], id1 = id[1];\n\n        fprintf (stderr, \"%s: %s: \"\n                 \"%s block id %d,%d (%c%c) at 0x%zx size %zu%s\\n\",\n                 \"hivex\", __func__,\n                 used ? \"used\" : \"free\",\n                 id0, id1,\n                 c_isprint (id0) ? id0 : '.',\n                 c_isprint (id1) ? id1 : '.',\n                 blkoff,\n                 seg_len, is_root ? \" (root)\" : \"\");\n      }\n\n      blocks_bytes += seg_len;\n      if (seg_len < smallest_block) smallest_block = seg_len;\n      if (seg_len > largest_block) largest_block = seg_len;\n\n      if (is_root && !used)\n        bad_root_block = 1;\n\n      if (used) {\n        used_blocks++;\n        used_size += seg_len;\n\n        /* Root block must be an nk-block. */\n        if (is_root && (block->id[0] != 'n' || block->id[1] != 'k'))\n          bad_root_block = 1;\n\n        /* Note this blkoff is a valid address. */\n        BITMAP_SET (h->bitmap, blkoff);\n      }\n    }\n  }\n\n  if (!seen_root_block) {\n    SET_ERRNO (ENOTSUP, \"%s: no root block found\", filename);\n    goto error;\n  }\n\n  if (bad_root_block) {\n    SET_ERRNO (ENOTSUP, \"%s: bad root block (free or not nk)\", filename);\n    goto error;\n  }\n\n  DEBUG (1, \"successfully read Windows Registry hive file:\\n\"\n         \"  pages:          %zu [sml: %zu, lge: %zu]\\n\"\n         \"  blocks:         %zu [sml: %zu, avg: %zu, lge: %zu]\\n\"\n         \"  blocks used:    %zu\\n\"\n         \"  bytes used:     %zu\",\n         pages, smallest_page, largest_page,\n         blocks, smallest_block, blocks_bytes / blocks, largest_block,\n         used_blocks, used_size);\n\n  return h;\n\n error:;\n  int err = errno;\n  if (h) {\n    free (h->bitmap);\n    if (h->addr && h->size && h->addr != MAP_FAILED) {\n      if (!h->writable)\n        munmap (h->addr, h->size);\n      else\n        free (h->addr);\n    }\n    if (h->fd >= 0)\n      close (h->fd);\n    free (h->filename);\n    free (h);\n  }\n  errno = err;\n  return NULL;\n}\n\nint\nhivex_close (hive_h *h)\n{\n  int r;\n\n  DEBUG (1, \"hivex_close\");\n\n  free (h->bitmap);\n  if (!h->writable)\n    munmap (h->addr, h->size);\n  else\n    free (h->addr);\n  if (h->fd >= 0)\n    r = close (h->fd);\n  else\n    r = 0;\n  free (h->filename);\n  free (h);\n\n  return r;\n}\n\nint\nhivex_commit (hive_h *h, const char *filename, int flags)\n{\n  int fd;\n\n  if (flags != 0) {\n    SET_ERRNO (EINVAL, \"flags != 0\");\n    return -1;\n  }\n\n  CHECK_WRITABLE (-1);\n\n  filename = filename ? : h->filename;\n#ifdef O_CLOEXEC\n  fd = open (filename, O_WRONLY|O_CREAT|O_TRUNC|O_NOCTTY|O_CLOEXEC|O_BINARY,\n             0666);\n#else\n  fd = open (filename, O_WRONLY|O_CREAT|O_TRUNC|O_NOCTTY|O_BINARY, 0666);\n#endif\n  if (fd == -1)\n    return -1;\n#ifndef O_CLOEXEC\n  fcntl (fd, F_SETFD, FD_CLOEXEC);\n#endif\n\n  /* Update the header fields. */\n  uint32_t sequence = le32toh (h->hdr->sequence1);\n  sequence++;\n  h->hdr->sequence1 = htole32 (sequence);\n  h->hdr->sequence2 = htole32 (sequence);\n  /* XXX Ought to update h->hdr->last_modified. */\n  h->hdr->blocks = htole32 (h->endpages - 0x1000);\n\n  /* Recompute header checksum. */\n  uint32_t sum = header_checksum (h);\n  h->hdr->csum = htole32 (sum);\n\n  DEBUG (2, \"hivex_commit: new header checksum: 0x%x\", sum);\n\n  if (full_write (fd, h->addr, h->size) != h->size) {\n    int err = errno;\n    close (fd);\n    errno = err;\n    return -1;\n  }\n\n  if (close (fd) == -1)\n    return -1;\n\n  return 0;\n}\n"], "fixing_code": ["/* hivex - Windows Registry \"hive\" extraction library.\n * Copyright (C) 2009-2011 Red Hat Inc.\n * Derived from code by Petter Nordahl-Hagen under a compatible license:\n *   Copyright (c) 1997-2007 Petter Nordahl-Hagen.\n * Derived from code by Markus Stephany under a compatible license:\n *   Copyright (c) 2000-2004, Markus Stephany.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation;\n * version 2.1 of the License.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * See file LICENSE for the full license.\n */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <assert.h>\n\n#ifdef HAVE_MMAP\n#include <sys/mman.h>\n#else\n/* On systems without mmap (and munmap), use a replacement function. */\n#include \"mmap.h\"\n#endif\n\n#include \"full-read.h\"\n#include \"full-write.h\"\n#include \"c-ctype.h\"\n\n#include \"hivex.h\"\n#include \"hivex-internal.h\"\n\nstatic uint32_t\nheader_checksum (const hive_h *h)\n{\n  uint32_t *daddr = (uint32_t *) h->addr;\n  size_t i;\n  uint32_t sum = 0;\n\n  for (i = 0; i < 0x1fc / 4; ++i) {\n    sum ^= le32toh (*daddr);\n    daddr++;\n  }\n\n  return sum;\n}\n\n#define HIVEX_OPEN_MSGLVL_MASK (HIVEX_OPEN_VERBOSE|HIVEX_OPEN_DEBUG)\n\nhive_h *\nhivex_open (const char *filename, int flags)\n{\n  hive_h *h = NULL;\n\n  assert (sizeof (struct ntreg_header) == 0x1000);\n  assert (offsetof (struct ntreg_header, csum) == 0x1fc);\n\n  h = calloc (1, sizeof *h);\n  if (h == NULL)\n    goto error;\n\n  h->msglvl = flags & HIVEX_OPEN_MSGLVL_MASK;\n\n  const char *debug = getenv (\"HIVEX_DEBUG\");\n  if (debug && STREQ (debug, \"1\"))\n    h->msglvl = 2;\n\n  DEBUG (2, \"created handle %p\", h);\n\n  h->writable = !!(flags & HIVEX_OPEN_WRITE);\n  h->filename = strdup (filename);\n  if (h->filename == NULL)\n    goto error;\n\n#ifdef O_CLOEXEC\n  h->fd = open (filename, O_RDONLY | O_CLOEXEC | O_BINARY);\n#else\n  h->fd = open (filename, O_RDONLY | O_BINARY);\n#endif\n  if (h->fd == -1)\n    goto error;\n#ifndef O_CLOEXEC\n  fcntl (h->fd, F_SETFD, FD_CLOEXEC);\n#endif\n\n  struct stat statbuf;\n  if (fstat (h->fd, &statbuf) == -1)\n    goto error;\n\n  h->size = statbuf.st_size;\n\n  if (h->size < 0x2000) {\n    SET_ERRNO (EINVAL,\n               \"%s: file is too small to be a Windows NT Registry hive file\",\n               filename);\n    goto error;\n  }\n\n  if (!h->writable) {\n    h->addr = mmap (NULL, h->size, PROT_READ, MAP_SHARED, h->fd, 0);\n    if (h->addr == MAP_FAILED)\n      goto error;\n\n    DEBUG (2, \"mapped file at %p\", h->addr);\n  } else {\n    h->addr = malloc (h->size);\n    if (h->addr == NULL)\n      goto error;\n\n    if (full_read (h->fd, h->addr, h->size) < h->size)\n      goto error;\n\n    /* We don't need the file descriptor along this path, since we\n     * have read all the data.\n     */\n    if (close (h->fd) == -1)\n      goto error;\n    h->fd = -1;\n  }\n\n  /* Check header. */\n  if (h->hdr->magic[0] != 'r' ||\n      h->hdr->magic[1] != 'e' ||\n      h->hdr->magic[2] != 'g' ||\n      h->hdr->magic[3] != 'f') {\n    SET_ERRNO (ENOTSUP,\n               \"%s: not a Windows NT Registry hive file\", filename);\n    goto error;\n  }\n\n  /* Check major version. */\n  uint32_t major_ver = le32toh (h->hdr->major_ver);\n  if (major_ver != 1) {\n    SET_ERRNO (ENOTSUP,\n               \"%s: hive file major version %\" PRIu32 \" (expected 1)\",\n               filename, major_ver);\n    goto error;\n  }\n\n  h->bitmap = calloc (1 + h->size / 32, 1);\n  if (h->bitmap == NULL)\n    goto error;\n\n  /* Header checksum. */\n  uint32_t sum = header_checksum (h);\n  if (sum != le32toh (h->hdr->csum)) {\n    SET_ERRNO (EINVAL, \"%s: bad checksum in hive header\", filename);\n    goto error;\n  }\n\n  /* Last modified time. */\n  h->last_modified = le64toh ((int64_t) h->hdr->last_modified);\n\n  if (h->msglvl >= 2) {\n    char *name = _hivex_windows_utf16_to_utf8 (h->hdr->name, 64);\n\n    fprintf (stderr,\n             \"hivex_open: header fields:\\n\"\n             \"  file version             %\" PRIu32 \".%\" PRIu32 \"\\n\"\n             \"  sequence nos             %\" PRIu32 \" %\" PRIu32 \"\\n\"\n             \"    (sequences nos should match if hive was synched at shutdown)\\n\"\n             \"  last modified            %\" PRIu64 \"\\n\"\n             \"    (Windows filetime, x 100 ns since 1601-01-01)\\n\"\n             \"  original file name       %s\\n\"\n             \"    (only 32 chars are stored, name is probably truncated)\\n\"\n             \"  root offset              0x%x + 0x1000\\n\"\n             \"  end of last page         0x%x + 0x1000 (total file size 0x%zx)\\n\"\n             \"  checksum                 0x%x (calculated 0x%x)\\n\",\n             major_ver, le32toh (h->hdr->minor_ver),\n             le32toh (h->hdr->sequence1), le32toh (h->hdr->sequence2),\n             h->last_modified,\n             name ? name : \"(conversion failed)\",\n             le32toh (h->hdr->offset),\n             le32toh (h->hdr->blocks), h->size,\n             le32toh (h->hdr->csum), sum);\n    free (name);\n  }\n\n  h->rootoffs = le32toh (h->hdr->offset) + 0x1000;\n  h->endpages = le32toh (h->hdr->blocks) + 0x1000;\n\n  DEBUG (2, \"root offset = 0x%zx\", h->rootoffs);\n\n  /* We'll set this flag when we see a block with the root offset (ie.\n   * the root block).\n   */\n  int seen_root_block = 0, bad_root_block = 0;\n\n  /* Collect some stats. */\n  size_t pages = 0;           /* Number of hbin pages read. */\n  size_t smallest_page = SIZE_MAX, largest_page = 0;\n  size_t blocks = 0;          /* Total number of blocks found. */\n  size_t smallest_block = SIZE_MAX, largest_block = 0, blocks_bytes = 0;\n  size_t used_blocks = 0;     /* Total number of used blocks found. */\n  size_t used_size = 0;       /* Total size (bytes) of used blocks. */\n\n  /* Read the pages and blocks.  The aim here is to be robust against\n   * corrupt or malicious registries.  So we make sure the loops\n   * always make forward progress.  We add the address of each block\n   * we read to a hash table so pointers will only reference the start\n   * of valid blocks.\n   */\n  size_t off;\n  struct ntreg_hbin_page *page;\n  for (off = 0x1000; off < h->size; off += le32toh (page->page_size)) {\n    if (off >= h->endpages)\n      break;\n\n    page = (struct ntreg_hbin_page *) ((char *) h->addr + off);\n    if (page->magic[0] != 'h' ||\n        page->magic[1] != 'b' ||\n        page->magic[2] != 'i' ||\n        page->magic[3] != 'n') {\n      SET_ERRNO (ENOTSUP,\n                 \"%s: trailing garbage at end of file \"\n                 \"(at 0x%zx, after %zu pages)\",\n                 filename, off, pages);\n      goto error;\n    }\n\n    size_t page_size = le32toh (page->page_size);\n    DEBUG (2, \"page at 0x%zx, size %zu\", off, page_size);\n    pages++;\n    if (page_size < smallest_page) smallest_page = page_size;\n    if (page_size > largest_page) largest_page = page_size;\n\n    if (page_size <= sizeof (struct ntreg_hbin_page) ||\n        (page_size & 0x0fff) != 0) {\n      SET_ERRNO (ENOTSUP,\n                 \"%s: page size %zu at 0x%zx, bad registry\",\n                 filename, page_size, off);\n      goto error;\n    }\n\n    /* Read the blocks in this page. */\n    size_t blkoff;\n    struct ntreg_hbin_block *block;\n    size_t seg_len;\n    for (blkoff = off + 0x20;\n         blkoff < off + page_size;\n         blkoff += seg_len) {\n      blocks++;\n\n      int is_root = blkoff == h->rootoffs;\n      if (is_root)\n        seen_root_block = 1;\n\n      block = (struct ntreg_hbin_block *) ((char *) h->addr + blkoff);\n      int used;\n      seg_len = block_len (h, blkoff, &used);\n      if (seg_len <= 4 || (seg_len & 3) != 0) {\n        SET_ERRNO (ENOTSUP,\n                   \"%s: block size %\" PRIu32 \" at 0x%zx, bad registry\",\n                   filename, le32toh (block->seg_len), blkoff);\n        goto error;\n      }\n\n      if (h->msglvl >= 2) {\n        unsigned char *id = (unsigned char *) block->id;\n        int id0 = id[0], id1 = id[1];\n\n        fprintf (stderr, \"%s: %s: \"\n                 \"%s block id %d,%d (%c%c) at 0x%zx size %zu%s\\n\",\n                 \"hivex\", __func__,\n                 used ? \"used\" : \"free\",\n                 id0, id1,\n                 c_isprint (id0) ? id0 : '.',\n                 c_isprint (id1) ? id1 : '.',\n                 blkoff,\n                 seg_len, is_root ? \" (root)\" : \"\");\n      }\n\n      blocks_bytes += seg_len;\n      if (seg_len < smallest_block) smallest_block = seg_len;\n      if (seg_len > largest_block) largest_block = seg_len;\n\n      if (is_root && !used)\n        bad_root_block = 1;\n\n      if (used) {\n        used_blocks++;\n        used_size += seg_len;\n\n        /* Root block must be an nk-block. */\n        if (is_root && (block->id[0] != 'n' || block->id[1] != 'k'))\n          bad_root_block = 1;\n\n        /* Note this blkoff is a valid address. */\n        BITMAP_SET (h->bitmap, blkoff);\n      }\n    }\n  }\n\n  if (!seen_root_block) {\n    SET_ERRNO (ENOTSUP, \"%s: no root block found\", filename);\n    goto error;\n  }\n\n  if (bad_root_block) {\n    SET_ERRNO (ENOTSUP, \"%s: bad root block (free or not nk)\", filename);\n    goto error;\n  }\n\n  DEBUG (1, \"successfully read Windows Registry hive file:\\n\"\n         \"  pages:          %zu [sml: %zu, lge: %zu]\\n\"\n         \"  blocks:         %zu [sml: %zu, avg: %zu, lge: %zu]\\n\"\n         \"  blocks used:    %zu\\n\"\n         \"  bytes used:     %zu\",\n         pages, smallest_page, largest_page,\n         blocks, smallest_block, blocks_bytes / blocks, largest_block,\n         used_blocks, used_size);\n\n  return h;\n\n error:;\n  int err = errno;\n  if (h) {\n    free (h->bitmap);\n    if (h->addr && h->size && h->addr != MAP_FAILED) {\n      if (!h->writable)\n        munmap (h->addr, h->size);\n      else\n        free (h->addr);\n    }\n    if (h->fd >= 0)\n      close (h->fd);\n    free (h->filename);\n    free (h);\n  }\n  errno = err;\n  return NULL;\n}\n\nint\nhivex_close (hive_h *h)\n{\n  int r;\n\n  DEBUG (1, \"hivex_close\");\n\n  free (h->bitmap);\n  if (!h->writable)\n    munmap (h->addr, h->size);\n  else\n    free (h->addr);\n  if (h->fd >= 0)\n    r = close (h->fd);\n  else\n    r = 0;\n  free (h->filename);\n  free (h);\n\n  return r;\n}\n\nint\nhivex_commit (hive_h *h, const char *filename, int flags)\n{\n  int fd;\n\n  if (flags != 0) {\n    SET_ERRNO (EINVAL, \"flags != 0\");\n    return -1;\n  }\n\n  CHECK_WRITABLE (-1);\n\n  filename = filename ? : h->filename;\n#ifdef O_CLOEXEC\n  fd = open (filename, O_WRONLY|O_CREAT|O_TRUNC|O_NOCTTY|O_CLOEXEC|O_BINARY,\n             0666);\n#else\n  fd = open (filename, O_WRONLY|O_CREAT|O_TRUNC|O_NOCTTY|O_BINARY, 0666);\n#endif\n  if (fd == -1)\n    return -1;\n#ifndef O_CLOEXEC\n  fcntl (fd, F_SETFD, FD_CLOEXEC);\n#endif\n\n  /* Update the header fields. */\n  uint32_t sequence = le32toh (h->hdr->sequence1);\n  sequence++;\n  h->hdr->sequence1 = htole32 (sequence);\n  h->hdr->sequence2 = htole32 (sequence);\n  /* XXX Ought to update h->hdr->last_modified. */\n  h->hdr->blocks = htole32 (h->endpages - 0x1000);\n\n  /* Recompute header checksum. */\n  uint32_t sum = header_checksum (h);\n  h->hdr->csum = htole32 (sum);\n\n  DEBUG (2, \"hivex_commit: new header checksum: 0x%x\", sum);\n\n  if (full_write (fd, h->addr, h->size) != h->size) {\n    int err = errno;\n    close (fd);\n    errno = err;\n    return -1;\n  }\n\n  if (close (fd) == -1)\n    return -1;\n\n  return 0;\n}\n"], "filenames": ["lib/handle.c"], "buggy_code_start_loc": [105], "buggy_code_end_loc": [105], "fixing_code_start_loc": [106], "fixing_code_end_loc": [113], "type": "CWE-119", "message": "lib/handle.c in Hivex before 1.3.11 allows local users to execute arbitrary code and gain privileges via a small hive files, which triggers an out-of-bounds read or write.", "other": {"cve": {"id": "CVE-2014-9273", "sourceIdentifier": "secalert@redhat.com", "published": "2014-12-08T16:59:11.947", "lastModified": "2018-10-30T16:27:35.843", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "lib/handle.c in Hivex before 1.3.11 allows local users to execute arbitrary code and gain privileges via a small hive files, which triggers an out-of-bounds read or write."}, {"lang": "es", "value": "lib/handle.c en Hivex anterior a 1.3.11 permite a usuarios locales ejecutar c\u00f3digo arbitrario y ganar privilegios a trav\u00e9s de un fichero de hive peque\u00f1o, lo que provoca una lectura o escritura fuera de rango."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": true, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "C2FAC325-6EEB-466D-9EBA-8ED4DBC9CFBF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:debian:hivex:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.3.10-2", "matchCriteriaId": "9C345E9F-F4FB-46BE-B55C-DBD7E7DD605F"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2015-02/msg00005.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0301.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-1378.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/11/25/6", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/12/04/14", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/71279", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1167756", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/libguestfs/hivex/commit/357f26fa64fd1d9ccac2331fe174a8ee9c607adb", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Issue Tracking"]}, {"url": "https://github.com/libguestfs/hivex/commit/4bbdf555f88baeae0fa804a369a81a83908bd705", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Issue Tracking"]}, {"url": "https://security.gentoo.org/glsa/201503-07", "source": "secalert@redhat.com"}, {"url": "https://www.redhat.com/archives/libguestfs/2014-October/msg00235.html", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/libguestfs/hivex/commit/357f26fa64fd1d9ccac2331fe174a8ee9c607adb"}}