{"buggy_code": ["<?php\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Enterprise License (PEL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @category   Pimcore\n * @package    Asset\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PEL\n */\n\nnamespace Pimcore\\Model;\n\nuse Pimcore\\Config;\nuse Pimcore\\Event\\AssetEvents;\nuse Pimcore\\Event\\FrontendEvents;\nuse Pimcore\\Event\\Model\\AssetEvent;\nuse Pimcore\\File;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\Element\\ElementInterface;\nuse Pimcore\\Tool\\Mime;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\n\n/**\n * @method \\Pimcore\\Model\\Asset\\Dao getDao()\n * @method bool __isBasedOnLatestData()\n */\nclass Asset extends Element\\AbstractElement\n{\n    /**\n     * possible types of an asset\n     *\n     * @var array\n     */\n    public static $types = ['folder', 'image', 'text', 'audio', 'video', 'document', 'archive', 'unknown'];\n\n    /**\n     * Unique ID\n     *\n     * @var int\n     */\n    protected $id;\n\n    /**\n     * ID of the parent asset\n     *\n     * @var int\n     */\n    protected $parentId;\n\n    /**\n     * @var Asset\n     */\n    protected $parent;\n\n    /**\n     * Type\n     *\n     * @var string\n     */\n    protected $type;\n\n    /**\n     * Name of the file\n     *\n     * @var string\n     */\n    protected $filename;\n\n    /**\n     * Path of the file, without the filename, only the full path of the parent asset\n     *\n     * @var string\n     */\n    protected $path;\n\n    /**\n     * Mime-Type of the file\n     *\n     * @var string\n     */\n    protected $mimetype;\n\n    /**\n     * Timestamp of creation\n     *\n     * @var int\n     */\n    protected $creationDate;\n\n    /**\n     * Timestamp of modification\n     *\n     * @var int\n     */\n    protected $modificationDate;\n\n    /**\n     * @var resource\n     */\n    protected $stream;\n\n    /**\n     * ID of the owner user\n     *\n     * @var int\n     */\n    protected $userOwner;\n\n    /**\n     * ID of the user who make the latest changes\n     *\n     * @var int\n     */\n    protected $userModification;\n\n    /**\n     * List of properties\n     *\n     * @var array\n     */\n    protected $properties = null;\n\n    /**\n     * List of versions\n     *\n     * @var array\n     */\n    protected $versions = null;\n\n    /**\n     * @var array\n     */\n    protected $metadata = [];\n\n    /**\n     * enum('self','propagate') nullable\n     *\n     * @var string\n     */\n    protected $locked;\n\n    /**\n     * List of some custom settings  [key] => value\n     * Here there can be stored some data, eg. the video thumbnail files, ...  of the asset, ...\n     *\n     * @var array\n     */\n    protected $customSettings = [];\n\n    /**\n     * @var bool\n     */\n    protected $hasMetaData = false;\n\n    /**\n     * Dependencies of this asset\n     *\n     * @var Dependency\n     */\n    protected $dependencies;\n\n    /**\n     * Contains a list of sibling documents\n     *\n     * @var array\n     */\n    protected $siblings;\n\n    /**\n     * Indicator if document has siblings or not\n     *\n     * @var bool\n     */\n    protected $hasSiblings;\n\n    /**\n     * Contains all scheduled tasks\n     *\n     * @var array\n     */\n    protected $scheduledTasks = null;\n\n    /**\n     * Indicator if data has changed\n     *\n     * @var bool\n     */\n    protected $_dataChanged = false;\n\n    /** @var int */\n    protected $versionCount;\n\n    /**\n     *\n     * @return array\n     */\n    public static function getTypes()\n    {\n        return self::$types;\n    }\n\n    /**\n     * Static helper to get an asset by the passed path\n     *\n     * @param string $path\n     * @param bool $force\n     *\n     * @return Asset|Asset\\Archive|Asset\\Audio|Asset\\Document|Asset\\Folder|Asset\\Image|Asset\\Text|Asset\\Unknown|Asset\\Video\n     */\n    public static function getByPath($path, $force = false)\n    {\n        $path = Element\\Service::correctPath($path);\n\n        try {\n            $asset = new Asset();\n            $asset->getDao()->getByPath($path);\n\n            return self::getById($asset->getId(), $force);\n        } catch (\\Exception $e) {\n            return null;\n        }\n    }\n\n    /**\n     * @param Asset $asset\n     *\n     * @return bool\n     */\n    protected static function typeMatch(Asset $asset)\n    {\n        $staticType = get_called_class();\n        if ($staticType != Asset::class) {\n            if (!$asset instanceof $staticType) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Static helper to get an asset by the passed ID\n     *\n     * @param int $id\n     * @param bool $force\n     *\n     * @return Asset|Asset\\Archive|Asset\\Audio|Asset\\Document|Asset\\Folder|Asset\\Image|Asset\\Text|Asset\\Unknown|Asset\\Video\n     */\n    public static function getById($id, $force = false)\n    {\n        if (!is_numeric($id) || $id < 1) {\n            return null;\n        }\n        $id = intval($id);\n\n        $cacheKey = 'asset_' . $id;\n\n        if (!$force && \\Pimcore\\Cache\\Runtime::isRegistered($cacheKey)) {\n            $asset = \\Pimcore\\Cache\\Runtime::get($cacheKey);\n            if ($asset && static::typeMatch($asset)) {\n                return $asset;\n            }\n        }\n\n        try {\n            if ($force || !($asset = \\Pimcore\\Cache::load($cacheKey))) {\n                $asset = new Asset();\n                $asset->getDao()->getById($id);\n\n                $className = 'Pimcore\\\\Model\\\\Asset\\\\' . ucfirst($asset->getType());\n\n                $asset = self::getModelFactory()->build($className);\n                \\Pimcore\\Cache\\Runtime::set($cacheKey, $asset);\n                $asset->getDao()->getById($id);\n                $asset->__setDataVersionTimestamp($asset->getModificationDate());\n\n                \\Pimcore\\Cache::save($asset, $cacheKey);\n            } else {\n                \\Pimcore\\Cache\\Runtime::set($cacheKey, $asset);\n            }\n        } catch (\\Exception $e) {\n            return null;\n        }\n\n        if (!$asset || !static::typeMatch($asset)) {\n            return null;\n        }\n\n        return $asset;\n    }\n\n    /**\n     * Helper to quickly create a new asset\n     *\n     * @param int $parentId\n     * @param array $data\n     * @param bool $save\n     *\n     * @return Asset\n     */\n    public static function create($parentId, $data = [], $save = true)\n    {\n\n        // create already the real class for the asset type, this is especially for images, because a system-thumbnail\n        // (tree) is generated immediately after creating an image\n        $class = Asset::class;\n        if (array_key_exists('filename', $data) && (array_key_exists('data', $data) || array_key_exists('sourcePath', $data) || array_key_exists('stream', $data))) {\n            if (array_key_exists('data', $data) || array_key_exists('stream', $data)) {\n                $tmpFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/asset-create-tmp-file-' . uniqid() . '.' . File::getFileExtension($data['filename']);\n                if (array_key_exists('data', $data)) {\n                    File::put($tmpFile, $data['data']);\n                    $mimeType = Mime::detect($tmpFile);\n                    unlink($tmpFile);\n                } else {\n                    $streamMeta = stream_get_meta_data($data['stream']);\n                    if (file_exists($streamMeta['uri'])) {\n                        // stream is a local file, so we don't have to write a tmp file\n                        $mimeType = Mime::detect($streamMeta['uri']);\n                    } else {\n                        // write a tmp file because the stream isn't a pointer to the local filesystem\n                        rewind($data['stream']);\n                        $dest = fopen($tmpFile, 'w+', false, File::getContext());\n                        stream_copy_to_stream($data['stream'], $dest);\n                        fclose($dest);\n                        $mimeType = Mime::detect($tmpFile);\n                        unlink($tmpFile);\n                    }\n                }\n            } else {\n                $mimeType = Mime::detect($data['sourcePath'], $data['filename']);\n                if (is_file($data['sourcePath'])) {\n                    $data['stream'] = fopen($data['sourcePath'], 'r+', false, File::getContext());\n                }\n\n                unset($data['sourcePath']);\n            }\n\n            $type = self::getTypeFromMimeMapping($mimeType, $data['filename']);\n            $class = '\\\\Pimcore\\\\Model\\\\Asset\\\\' . ucfirst($type);\n            if (array_key_exists('type', $data)) {\n                unset($data['type']);\n            }\n        }\n\n        $asset = new $class();\n        $asset->setParentId($parentId);\n        $asset->setValues($data);\n\n        if ($save) {\n            $asset->save();\n        }\n\n        return $asset;\n    }\n\n    /**\n     * @param array $config\n     *\n     * @return mixed\n     *\n     * @throws \\Exception\n     */\n    public static function getList($config = [])\n    {\n        if (is_array($config)) {\n            $listClass = 'Pimcore\\\\Model\\\\Asset\\\\Listing';\n\n            $list = self::getModelFactory()->build($listClass);\n            $list->setValues($config);\n            $list->load();\n\n            return $list;\n        }\n    }\n\n    /**\n     * @param array $config\n     *\n     * @return int total count\n     */\n    public static function getTotalCount($config = [])\n    {\n        if (is_array($config)) {\n            $listClass = 'Pimcore\\\\Model\\\\Asset\\\\Listing';\n            $list = self::getModelFactory()->build($listClass);\n            $list->setValues($config);\n            $count = $list->getTotalCount();\n\n            return $count;\n        }\n    }\n\n    /**\n     * returns the asset type of a filename and mimetype\n     *\n     * @param $mimeType\n     * @param $filename\n     *\n     * @return int|string\n     */\n    public static function getTypeFromMimeMapping($mimeType, $filename)\n    {\n        if ($mimeType == 'directory') {\n            return 'folder';\n        }\n\n        $type = null;\n\n        $mappings = [\n            'unknown' => [\"/\\.stp$/\"],\n            'image' => ['/image/', \"/\\.eps$/\", \"/\\.ai$/\", \"/\\.svgz$/\", \"/\\.pcx$/\", \"/\\.iff$/\", \"/\\.pct$/\", \"/\\.wmf$/\"],\n            'text' => ['/text/', '/xml$/'],\n            'audio' => ['/audio/'],\n            'video' => ['/video/'],\n            'document' => ['/msword/', '/pdf/', '/powerpoint/', '/office/', '/excel/', '/opendocument/'],\n            'archive' => ['/zip/', '/tar/'],\n        ];\n\n        foreach ($mappings as $assetType => $patterns) {\n            foreach ($patterns as $pattern) {\n                if (preg_match($pattern, $mimeType . ' .'. File::getFileExtension($filename))) {\n                    $type = $assetType;\n                    break;\n                }\n            }\n\n            // break at first match\n            if ($type) {\n                break;\n            }\n        }\n\n        if (!$type) {\n            $type = 'unknown';\n        }\n\n        return $type;\n    }\n\n    /**\n     * Get full path to the asset on the filesystem\n     *\n     * @return string\n     */\n    public function getFileSystemPath()\n    {\n        return PIMCORE_ASSET_DIRECTORY . $this->getRealFullPath();\n    }\n\n    /**\n     * @return $this\n     *\n     * @throws \\Exception\n     */\n    public function save()\n    {\n        // additional parameters (e.g. \"versionNote\" for the version note)\n        $params = [];\n        if (func_num_args() && is_array(func_get_arg(0))) {\n            $params = func_get_arg(0);\n        }\n\n        $isUpdate = false;\n\n        $preEvent = new AssetEvent($this, $params);\n\n        if ($this->getId()) {\n            $isUpdate = true;\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::PRE_UPDATE, $preEvent);\n        } else {\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::PRE_ADD, $preEvent);\n        }\n\n        $params = $preEvent->getArguments();\n\n        $this->correctPath();\n\n        // we wrap the save actions in a loop here, so that we can restart the database transactions in the case it fails\n        // if a transaction fails it gets restarted $maxRetries times, then the exception is thrown out\n        // this is especially useful to avoid problems with deadlocks in multi-threaded environments (forked workers, ...)\n        $maxRetries = 5;\n        for ($retries = 0; $retries < $maxRetries; $retries++) {\n            $this->beginTransaction();\n\n            try {\n                if (!$isUpdate) {\n                    $this->getDao()->create();\n                }\n\n                // get the old path from the database before the update is done\n                $oldPath = null;\n                if ($isUpdate) {\n                    $oldPath = $this->getDao()->getCurrentFullPath();\n                }\n\n                $this->update($params);\n\n                // if the old path is different from the new path, update all children\n                $updatedChildren = [];\n                if ($oldPath && $oldPath != $this->getRealFullPath()) {\n                    $oldFullPath = PIMCORE_ASSET_DIRECTORY . $oldPath;\n                    if (is_file($oldFullPath) || is_dir($oldFullPath)) {\n                        if (!@File::rename(PIMCORE_ASSET_DIRECTORY . $oldPath, $this->getFileSystemPath())) {\n                            $error = error_get_last();\n                            throw new \\Exception('Unable to rename asset ' . $this->getId() . ' on the filesystem: ' . $oldFullPath . ' - Reason: ' . $error['message']);\n                        }\n                        $differentOldPath = $oldPath;\n                        $this->getDao()->updateWorkspaces();\n                        $updatedChildren = $this->getDao()->updateChildsPaths($oldPath);\n                    }\n                }\n\n                // lastly create a new version if necessary\n                // this has to be after the registry update and the DB update, otherwise this would cause problem in the\n                // $this->__wakeUp() method which is called by $version->save(); (path correction for version restore)\n                if ($this->getType() != 'folder') {\n                    $this->saveVersion(false, false, isset($params['versionNote']) ? $params['versionNote'] : null);\n                }\n\n                $this->commit();\n\n                break; // transaction was successfully completed, so we cancel the loop here -> no restart required\n            } catch (\\Exception $e) {\n                try {\n                    $this->rollBack();\n                } catch (\\Exception $er) {\n                    // PDO adapter throws exceptions if rollback fails\n                    Logger::error($er);\n                }\n\n                // we try to start the transaction $maxRetries times again (deadlocks, ...)\n                if ($retries < ($maxRetries - 1)) {\n                    $run = $retries + 1;\n                    $waitTime = rand(1, 5) * 100000; // microseconds\n                    Logger::warn('Unable to finish transaction (' . $run . \". run) because of the following reason '\" . $e->getMessage() . \"'. --> Retrying in \" . $waitTime . ' microseconds ... (' . ($run + 1) . ' of ' . $maxRetries . ')');\n\n                    usleep($waitTime); // wait specified time until we restart the transaction\n                } else {\n                    if ($isUpdate) {\n                        \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_UPDATE_FAILURE, new AssetEvent($this));\n                    } else {\n                        \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_ADD_FAILURE, new AssetEvent($this));\n                    }\n                    // if the transaction still fail after $maxRetries retries, we throw out the exception\n                    throw $e;\n                }\n            }\n        }\n\n        $additionalTags = [];\n        if (isset($updatedChildren) && is_array($updatedChildren)) {\n            foreach ($updatedChildren as $assetId) {\n                $tag = 'asset_' . $assetId;\n                $additionalTags[] = $tag;\n\n                // remove the child also from registry (internal cache) to avoid path inconsistencies during long running scripts, such as CLI\n                \\Pimcore\\Cache\\Runtime::set($tag, null);\n            }\n        }\n        $this->clearDependentCache($additionalTags);\n        $this->setDataChanged(false);\n\n        if ($isUpdate) {\n            $updateEvent = new AssetEvent($this);\n            if ($differentOldPath) {\n                $updateEvent->setArgument('oldPath', $differentOldPath);\n            }\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_UPDATE, $updateEvent);\n        } else {\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_ADD, new AssetEvent($this));\n        }\n\n        return $this;\n    }\n\n    /**\n     * @throws \\Exception\n     */\n    public function correctPath()\n    {\n        // set path\n        if ($this->getId() != 1) { // not for the root node\n\n            if (!Element\\Service::isValidKey($this->getKey(), 'asset')) {\n                throw new \\Exception(\"invalid filename '\".$this->getKey().\"' for asset with id [ \" . $this->getId() . ' ]');\n            }\n\n            if ($this->getParentId() == $this->getId()) {\n                throw new \\Exception(\"ParentID and ID is identical, an element can't be the parent of itself.\");\n            }\n\n            if ($this->getFilename() === '..' || $this->getFilename() === '.') {\n                throw new \\Exception('Cannot create asset called \"..\" or \".\"');\n            }\n\n            $parent = Asset::getById($this->getParentId());\n            if ($parent) {\n                // use the parent's path from the database here (getCurrentFullPath), to ensure the path really exists and does not rely on the path\n                // that is currently in the parent asset (in memory), because this might have changed but wasn't not saved\n                $this->setPath(str_replace('//', '/', $parent->getCurrentFullPath() . '/'));\n            } else {\n                // parent document doesn't exist anymore, set the parent to to root\n                $this->setParentId(1);\n                $this->setPath('/');\n            }\n        } elseif ($this->getId() == 1) {\n            // some data in root node should always be the same\n            $this->setParentId(0);\n            $this->setPath('/');\n            $this->setFilename('');\n            $this->setType('folder');\n        }\n\n        // do not allow PHP and .htaccess files\n        if (preg_match(\"@\\.ph(p[\\d+]?|t|tml|ps)$@i\", $this->getFilename()) || $this->getFilename() == '.htaccess') {\n            $this->setFilename($this->getFilename() . '.txt');\n        }\n\n        if (Asset\\Service::pathExists($this->getRealFullPath())) {\n            $duplicate = Asset::getByPath($this->getRealFullPath());\n            if ($duplicate instanceof Asset and $duplicate->getId() != $this->getId()) {\n                throw new \\Exception('Duplicate full path [ ' . $this->getRealFullPath() . ' ] - cannot save asset');\n            }\n        }\n\n        $this->validatePathLength();\n    }\n\n    /**\n     * @param array $params additional parameters (e.g. \"versionNote\" for the version note)\n     *\n     * @throws \\Exception\n     */\n    protected function update($params = [])\n    {\n        $this->updateModificationInfos();\n\n        // create foldertree\n        // use current file name in order to prevent problems when filename has changed\n        // (otherwise binary data would be overwritten with old binary data with rename() in save method)\n        $destinationPathRelative = $this->getDao()->getCurrentFullPath();\n        if (!$destinationPathRelative) {\n            // this is happen during a restore from the recycle bin\n            $destinationPathRelative = $this->getRealFullPath();\n        }\n        $destinationPath = PIMCORE_ASSET_DIRECTORY . $destinationPathRelative;\n\n        $dirPath = dirname($destinationPath);\n        if (!is_dir($dirPath)) {\n            if (!File::mkdir($dirPath)) {\n                throw new \\Exception('Unable to create directory: '. $dirPath . ' for asset :' . $this->getId());\n            }\n        }\n\n        $typeChanged = false;\n\n        // fix for missing parent folders\n        // check if folder of new destination is already created and if not do so\n        $newPath = dirname($this->getFileSystemPath());\n        if (!is_dir($newPath)) {\n            if (!File::mkdir($newPath)) {\n                throw new \\Exception('Unable to create directory: '. $newPath . ' for asset :' . $this->getId());\n            }\n        }\n\n        if ($this->getType() != 'folder') {\n            if ($this->getDataChanged()) {\n                $src = $this->getStream();\n                $streamMeta = stream_get_meta_data($src);\n                if ($destinationPath != $streamMeta['uri']) {\n                    if (file_exists($destinationPath)) {\n                        // We don't open a stream on existing files, because they could be possibly used by versions\n                        // using hardlinks, so it's safer to delete them first, so the inode and therefore also the\n                        // versioning information persists. Using the stream on the existing file would overwrite the\n                        // contents of the inode and therefore leads to wrong version data\n                        unlink($destinationPath);\n                    }\n\n                    $dest = fopen($destinationPath, 'w', false, File::getContext());\n                    if ($dest) {\n                        stream_copy_to_stream($src, $dest);\n                        if (!fclose($dest)) {\n                            throw new \\Exception('Unable to close file handle ' . $destinationPath . ' for asset ' . $this->getId());\n                        }\n                    } else {\n                        throw new \\Exception('Unable to open file: ' . $destinationPath . ' for asset ' . $this->getId());\n                    }\n                }\n\n                $this->stream = null; // set stream to null, so that the source stream isn't used anymore after saving\n\n                @chmod($destinationPath, File::getDefaultMode());\n\n                // check file exists\n                if (!is_file($destinationPath)) {\n                    throw new \\Exception(\"couldn't create new asset, file \" . $destinationPath . \" doesn't exist\");\n                }\n\n                // set mime type\n                $mimetype = Mime::detect($destinationPath, $this->getFilename());\n                $this->setMimetype($mimetype);\n\n                // set type\n                $type = self::getTypeFromMimeMapping($mimetype, $this->getFilename());\n                if ($type != $this->getType()) {\n                    $this->setType($type);\n                    $typeChanged = true;\n                }\n\n                // not only check if the type is set but also if the implementation can be found\n                $className = 'Pimcore\\\\Model\\\\Asset\\\\' . ucfirst($this->getType());\n                if (!self::getModelFactory()->supports($className)) {\n                    throw new \\Exception('unable to resolve asset implementation with type: ' . $this->getType());\n                }\n            }\n\n            // scheduled tasks are saved in $this->saveVersion();\n        } else {\n            if (!is_dir($destinationPath) && !is_dir($this->getFileSystemPath())) {\n                if (!File::mkdir($this->getFileSystemPath())) {\n                    throw new \\Exception('Unable to create directory: '. $this->getFileSystemPath() . ' for asset :' . $this->getId());\n                }\n            }\n        }\n\n        $this->postPersistData();\n\n        // save properties\n        $this->getProperties();\n        $this->getDao()->deleteAllProperties();\n        if (is_array($this->getProperties()) and count($this->getProperties()) > 0) {\n            foreach ($this->getProperties() as $property) {\n                if (!$property->getInherited()) {\n                    $property->setDao(null);\n                    $property->setCid($this->getId());\n                    $property->setCtype('asset');\n                    $property->setCpath($this->getRealFullPath());\n                    $property->save();\n                }\n            }\n        }\n\n        // save dependencies\n        $d = new Dependency();\n        $d->setSourceType('asset');\n        $d->setSourceId($this->getId());\n\n        foreach ($this->resolveDependencies() as $requirement) {\n            if ($requirement['id'] == $this->getId() && $requirement['type'] == 'asset') {\n                // dont't add a reference to yourself\n                continue;\n            } else {\n                $d->addRequirement($requirement['id'], $requirement['type']);\n            }\n        }\n        $d->save();\n\n        $this->getDao()->update();\n\n        //set asset to registry\n        \\Pimcore\\Cache\\Runtime::set('asset_' . $this->getId(), $this);\n        if (get_class($this) == 'Asset' || $typeChanged) {\n            // get concrete type of asset\n            // this is important because at the time of creating an asset it's not clear which type (resp. class) it will have\n            // the type (image, document, ...) depends on the mime-type\n            \\Pimcore\\Cache\\Runtime::set('asset_' . $this->getId(), null);\n            $asset = Asset::getById($this->getId());\n            \\Pimcore\\Cache\\Runtime::set('asset_' . $this->getId(), $asset);\n        }\n\n        $this->closeStream();\n    }\n\n    protected function postPersistData()\n    {\n        // hook for the save process, can be overwritten in implementations, such as Image\n    }\n\n    /**\n     * @param bool $setModificationDate\n     * @param bool $saveOnlyVersion\n     * @param string $versionNote version note\n     *\n     * @return null|Version\n     *\n     * @throws \\Exception\n     */\n    public function saveVersion($setModificationDate = true, $saveOnlyVersion = true, $versionNote = null)\n    {\n\n        // hook should be also called if \"save only new version\" is selected\n        if ($saveOnlyVersion) {\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::PRE_UPDATE, new AssetEvent($this, [\n                'saveVersionOnly' => true\n            ]));\n        }\n\n        // set date\n        if ($setModificationDate) {\n            $this->setModificationDate(time());\n        }\n\n        // scheduled tasks are saved always, they are not versioned!\n        $this->saveScheduledTasks();\n\n        // create version\n        $version = null;\n\n        // only create a new version if there is at least 1 allowed\n        // or if saveVersion() was called directly (it's a newer version of the asset)\n        if (Config::getSystemConfig()->assets->versions->steps\n            || Config::getSystemConfig()->assets->versions->days\n            || $setModificationDate) {\n            $version = $this->doSaveVersion($versionNote, $saveOnlyVersion);\n        }\n\n        // hook should be also called if \"save only new version\" is selected\n        if ($saveOnlyVersion) {\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_UPDATE, new AssetEvent($this, [\n                'saveVersionOnly' => true\n            ]));\n        }\n\n        return $version;\n    }\n\n    /**\n     * Returns the full path of the document including the filename\n     *\n     * @return string\n     */\n    public function getFullPath()\n    {\n        $path = $this->getPath() . $this->getFilename();\n\n        if (\\Pimcore\\Tool::isFrontend()) {\n            $path = urlencode_ignore_slash($path);\n\n            $event = new GenericEvent($this, [\n                'frontendPath' => $path\n            ]);\n            \\Pimcore::getEventDispatcher()->dispatch(FrontendEvents::ASSET_PATH, $event);\n            $path = $event->getArgument('frontendPath');\n        }\n\n        return $path;\n    }\n\n    /**\n     * @return string\n     */\n    public function getRealPath()\n    {\n        return $this->path;\n    }\n\n    /**\n     * @return string\n     */\n    public function getRealFullPath()\n    {\n        $path = $this->getRealPath() . $this->getFilename();\n\n        return $path;\n    }\n\n    /**\n     * Get a list of the sibling assets\n     *\n     * @return array\n     */\n    public function getSiblings()\n    {\n        if ($this->siblings === null) {\n            $list = new Asset\\Listing();\n            // string conversion because parentId could be 0\n            $list->addConditionParam('parentId = ?', (string)$this->getParentId());\n            $list->addConditionParam('id != ?', $this->getId());\n            $list->setOrderKey('filename');\n            $list->setOrder('asc');\n            $this->siblings = $list->load();\n        }\n\n        return $this->siblings;\n    }\n\n    /**\n     * Returns true if the asset has at least one sibling\n     *\n     * @return bool\n     */\n    public function hasSiblings()\n    {\n        if (is_bool($this->hasSiblings)) {\n            if (($this->hasSiblings and empty($this->siblings)) or (!$this->hasSiblings and !empty($this->siblings))) {\n                return $this->getDao()->hasSiblings();\n            } else {\n                return $this->hasSiblings;\n            }\n        }\n\n        return $this->getDao()->hasSiblings();\n    }\n\n    /**\n     * @return bool\n     */\n    public function hasChildren()\n    {\n        return false;\n    }\n\n    /**\n     * Returns true if the element is locked\n     *\n     * @return string\n     */\n    public function getLocked()\n    {\n        return $this->locked;\n    }\n\n    /**\n     * @param  $locked\n     *\n     * @return $this\n     */\n    public function setLocked($locked)\n    {\n        $this->locked = $locked;\n\n        return $this;\n    }\n\n    /**\n     * Deletes file from filesystem\n     */\n    protected function deletePhysicalFile()\n    {\n        $fsPath = $this->getFileSystemPath();\n\n        if ($this->getType() != 'folder') {\n            if (is_file($fsPath) && is_writable($fsPath)) {\n                unlink($fsPath);\n            }\n        } else {\n            if (is_dir($fsPath) && is_writable($fsPath)) {\n                recursiveDelete($fsPath, true);\n            }\n        }\n    }\n\n    /**\n     * @param bool $isNested\n     *\n     * @throws \\Exception\n     */\n    public function delete(bool $isNested = false)\n    {\n        if ($this->getId() == 1) {\n            throw new \\Exception('root-node cannot be deleted');\n        }\n\n        \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::PRE_DELETE, new AssetEvent($this));\n\n        $this->beginTransaction();\n\n        try {\n            $this->closeStream();\n\n            // remove childs\n            if ($this->hasChildren()) {\n                foreach ($this->getChildren() as $child) {\n                    $child->delete(true);\n                }\n            }\n\n            $versions = $this->getVersions();\n            foreach ($versions as $version) {\n                $version->delete();\n            }\n\n            // remove permissions\n            $this->getDao()->deleteAllPermissions();\n\n            // remove all properties\n            $this->getDao()->deleteAllProperties();\n\n            // remove all metadata\n            $this->getDao()->deleteAllMetadata();\n\n            // remove all tasks\n            $this->getDao()->deleteAllTasks();\n\n            // remove dependencies\n            $d = $this->getDependencies();\n            $d->cleanAllForElement($this);\n\n            // remove from resource\n            $this->getDao()->delete();\n\n            $this->commit();\n\n            // remove file on filesystem\n            if (!$isNested) {\n                $fullPath = $this->getRealFullPath();\n                if ($fullPath != '/..' && !strpos($fullPath,\n                        '/../') && $this->getKey() !== '.' && $this->getKey() !== '..') {\n                    $this->deletePhysicalFile();\n                }\n            }\n        } catch (\\Exception $e) {\n            $this->rollBack();\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_DELETE_FAILURE, new AssetEvent($this));\n            Logger::crit($e);\n            throw $e;\n        }\n\n        // empty asset cache\n        $this->clearDependentCache();\n\n        // clear asset from registry\n        \\Pimcore\\Cache\\Runtime::set('asset_' . $this->getId(), null);\n\n        \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_DELETE, new AssetEvent($this));\n    }\n\n    /**\n     * @param array $additionalTags\n     */\n    public function clearDependentCache($additionalTags = [])\n    {\n        try {\n            $tags = ['asset_' . $this->getId(), 'asset_properties', 'output'];\n            $tags = array_merge($tags, $additionalTags);\n\n            \\Pimcore\\Cache::clearTags($tags);\n        } catch (\\Exception $e) {\n            Logger::crit($e);\n        }\n    }\n\n    /**\n     * @return Dependency\n     */\n    public function getDependencies()\n    {\n        if (!$this->dependencies) {\n            $this->dependencies = Dependency::getBySourceId($this->getId(), 'asset');\n        }\n\n        return $this->dependencies;\n    }\n\n    /**\n     * @return int\n     */\n    public function getCreationDate()\n    {\n        return $this->creationDate;\n    }\n\n    /**\n     * @return int\n     */\n    public function getId()\n    {\n        return (int) $this->id;\n    }\n\n    /**\n     * @return string\n     */\n    public function getFilename()\n    {\n        return (string) $this->filename;\n    }\n\n    /**\n     * Alias for getFilename()\n     *\n     * @return string\n     */\n    public function getKey()\n    {\n        return $this->getFilename();\n    }\n\n    /**\n     * @return int\n     */\n    public function getModificationDate()\n    {\n        return (int) $this->modificationDate;\n    }\n\n    /**\n     * @return int\n     */\n    public function getParentId()\n    {\n        return $this->parentId;\n    }\n\n    /**\n     * @return string\n     */\n    public function getPath()\n    {\n        return $this->path;\n    }\n\n    /**\n     * @return string\n     */\n    public function getType()\n    {\n        return $this->type;\n    }\n\n    /**\n     * @param int $creationDate\n     *\n     * @return $this\n     */\n    public function setCreationDate($creationDate)\n    {\n        $this->creationDate = (int) $creationDate;\n\n        return $this;\n    }\n\n    /**\n     * @param int $id\n     *\n     * @return $this\n     */\n    public function setId($id)\n    {\n        $this->id = (int) $id;\n\n        return $this;\n    }\n\n    /**\n     * @param string $filename\n     *\n     * @return $this\n     */\n    public function setFilename($filename)\n    {\n        $this->filename = (string) $filename;\n\n        return $this;\n    }\n\n    /**\n     * @param int $modificationDate\n     *\n     * @return $this\n     */\n    public function setModificationDate($modificationDate)\n    {\n        $this->modificationDate = (int) $modificationDate;\n\n        return $this;\n    }\n\n    /**\n     * @param int $parentId\n     *\n     * @return $this\n     */\n    public function setParentId($parentId)\n    {\n        $this->parentId = (int) $parentId;\n        $this->parent = null;\n\n        return $this;\n    }\n\n    /**\n     * @param string $path\n     *\n     * @return $this\n     */\n    public function setPath($path)\n    {\n        $this->path = $path;\n\n        return $this;\n    }\n\n    /**\n     * @param string $type\n     *\n     * @return $this\n     */\n    public function setType($type)\n    {\n        $this->type = $type;\n\n        return $this;\n    }\n\n    /**\n     * @return mixed\n     */\n    public function getData()\n    {\n        $stream = $this->getStream();\n        if ($stream) {\n            return stream_get_contents($stream);\n        }\n\n        return '';\n    }\n\n    /**\n     * @param mixed $data\n     *\n     * @return $this\n     */\n    public function setData($data)\n    {\n        $handle = tmpfile();\n        fwrite($handle, $data);\n        $this->setStream($handle);\n\n        return $this;\n    }\n\n    /**\n     * @return resource\n     */\n    public function getStream()\n    {\n        if ($this->stream) {\n            $streamMeta = stream_get_meta_data($this->stream);\n            if (!@rewind($this->stream) && $streamMeta['stream_type'] === 'STDIO') {\n                $this->stream = null;\n            }\n        }\n\n        if (!$this->stream && $this->getType() != 'folder') {\n            if (file_exists($this->getFileSystemPath())) {\n                $this->stream = fopen($this->getFileSystemPath(), 'r', false, File::getContext());\n            } else {\n                $this->stream = tmpfile();\n            }\n        }\n\n        return $this->stream;\n    }\n\n    /**\n     * @param $stream\n     *\n     * @return $this\n     */\n    public function setStream($stream)\n    {\n        // close existing stream\n        if ($stream !== $this->stream) {\n            $this->closeStream();\n        }\n\n        if (is_resource($stream)) {\n            $this->setDataChanged(true);\n            $this->stream = $stream;\n            rewind($this->stream);\n        } elseif (is_null($stream)) {\n            $this->stream = null;\n        }\n\n        return $this;\n    }\n\n    protected function closeStream()\n    {\n        if (is_resource($this->stream)) {\n            @fclose($this->stream);\n            $this->stream = null;\n        }\n    }\n\n    /**\n     * @param string $type\n     *\n     * @return null|string\n     *\n     * @throws \\Exception\n     */\n    public function getChecksum($type = 'md5')\n    {\n        $file = $this->getFileSystemPath();\n        if (is_file($file)) {\n            if ($type == 'md5') {\n                return md5_file($file);\n            } elseif ($type == 'sha1') {\n                return sha1_file($file);\n            } else {\n                throw new \\Exception(\"hashing algorithm '\" . $type . \"' isn't supported\");\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @return bool\n     */\n    public function getDataChanged()\n    {\n        return $this->_dataChanged;\n    }\n\n    /**\n     * @param bool $changed\n     *\n     * @return $this\n     */\n    public function setDataChanged($changed = true)\n    {\n        $this->_dataChanged = $changed;\n\n        return $this;\n    }\n\n    /**\n     * @return Property[]\n     */\n    public function getProperties()\n    {\n        if ($this->properties === null) {\n            // try to get from cache\n            $cacheKey = 'asset_properties_' . $this->getId();\n            $properties = \\Pimcore\\Cache::load($cacheKey);\n            if (!is_array($properties)) {\n                $properties = $this->getDao()->getProperties();\n                $elementCacheTag = $this->getCacheTag();\n                $cacheTags = ['asset_properties' => 'asset_properties', $elementCacheTag => $elementCacheTag];\n                \\Pimcore\\Cache::save($properties, $cacheKey, $cacheTags);\n            }\n\n            $this->setProperties($properties);\n        }\n\n        return $this->properties;\n    }\n\n    /**\n     * @param array $properties\n     *\n     * @return $this\n     */\n    public function setProperties($properties)\n    {\n        $this->properties = $properties;\n\n        return $this;\n    }\n\n    /**\n     * @param $name\n     * @param $type\n     * @param $data\n     * @param bool $inherited\n     * @param bool $inheritable\n     *\n     * @return $this\n     */\n    public function setProperty($name, $type, $data, $inherited = false, $inheritable = false)\n    {\n        $this->getProperties();\n\n        $property = new Property();\n        $property->setType($type);\n        $property->setCid($this->getId());\n        $property->setName($name);\n        $property->setCtype('asset');\n        $property->setData($data);\n        $property->setInherited($inherited);\n        $property->setInheritable($inheritable);\n\n        $this->properties[$name] = $property;\n\n        return $this;\n    }\n\n    /**\n     * @return int\n     */\n    public function getUserOwner()\n    {\n        return $this->userOwner;\n    }\n\n    /**\n     * @return int\n     */\n    public function getUserModification()\n    {\n        return $this->userModification;\n    }\n\n    /**\n     * @param int $userOwner\n     *\n     * @return $this\n     */\n    public function setUserOwner($userOwner)\n    {\n        $this->userOwner = (int) $userOwner;\n\n        return $this;\n    }\n\n    /**\n     * @param int $userModification\n     *\n     * @return $this\n     */\n    public function setUserModification($userModification)\n    {\n        $this->userModification = (int) $userModification;\n\n        return $this;\n    }\n\n    /**\n     * @return array\n     */\n    public function getVersions()\n    {\n        if ($this->versions === null) {\n            $this->setVersions($this->getDao()->getVersions());\n        }\n\n        return $this->versions;\n    }\n\n    /**\n     * @param array $versions\n     *\n     * @return $this\n     */\n    public function setVersions($versions)\n    {\n        $this->versions = $versions;\n\n        return $this;\n    }\n\n    /**\n     * returns the path to a temp file\n     *\n     * @return string\n     */\n    public function getTemporaryFile()\n    {\n        $destinationPath = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/asset-temporary/asset_' . $this->getId() . '_' . md5(microtime()) . '__' . $this->getFilename();\n        if (!is_dir(dirname($destinationPath))) {\n            File::mkdir(dirname($destinationPath));\n        }\n\n        $src = $this->getStream();\n        $dest = fopen($destinationPath, 'w+', false, File::getContext());\n        stream_copy_to_stream($src, $dest);\n        fclose($dest);\n\n        @chmod($destinationPath, File::getDefaultMode());\n\n        return $destinationPath;\n    }\n\n    /**\n     * @param string $key\n     * @param mixed $value\n     *\n     * @return $this\n     */\n    public function setCustomSetting($key, $value)\n    {\n        $this->customSettings[$key] = $value;\n\n        return $this;\n    }\n\n    /**\n     * @param $key\n     *\n     * @return null\n     */\n    public function getCustomSetting($key)\n    {\n        if (is_array($this->customSettings) && array_key_exists($key, $this->customSettings)) {\n            return $this->customSettings[$key];\n        }\n\n        return null;\n    }\n\n    /**\n     * @param $key\n     */\n    public function removeCustomSetting($key)\n    {\n        if (is_array($this->customSettings) && array_key_exists($key, $this->customSettings)) {\n            unset($this->customSettings[$key]);\n        }\n    }\n\n    /**\n     * @return array\n     */\n    public function getCustomSettings()\n    {\n        return $this->customSettings;\n    }\n\n    /**\n     * @param array $customSettings\n     *\n     * @return $this\n     */\n    public function setCustomSettings($customSettings)\n    {\n        if (is_string($customSettings)) {\n            $customSettings = \\Pimcore\\Tool\\Serialize::unserialize($customSettings);\n        }\n\n        if ($customSettings instanceof \\stdClass) {\n            $customSettings = (array) $customSettings;\n        }\n\n        if (!is_array($customSettings)) {\n            $customSettings = [];\n        }\n\n        $this->customSettings = $customSettings;\n\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getMimetype()\n    {\n        return $this->mimetype;\n    }\n\n    /**\n     * @param string $mimetype\n     *\n     * @return $this\n     */\n    public function setMimetype($mimetype)\n    {\n        $this->mimetype = $mimetype;\n\n        return $this;\n    }\n\n    /**\n     * @param array $metadata\n     */\n    public function setMetadata($metadata)\n    {\n        $this->metadata = $metadata;\n\n        if (!empty($metadata)) {\n            $this->setHasMetaData(true);\n        }\n    }\n\n    /**\n     * @return bool\n     */\n    public function getHasMetaData()\n    {\n        return $this->hasMetaData;\n    }\n\n    /**\n     * @param bool $hasMetaData\n     */\n    public function setHasMetaData($hasMetaData)\n    {\n        $this->hasMetaData = (bool) $hasMetaData;\n    }\n\n    /**\n     * @param string $name\n     * @param string $type can be \"folder\", \"image\", \"input\", \"audio\", \"video\", \"document\", \"archive\" or \"unknown\"\n     * @param null $data\n     * @param null $language\n     */\n    public function addMetadata($name, $type, $data = null, $language = null)\n    {\n        if ($name && $type) {\n            $tmp = [];\n            if (!is_array($this->metadata)) {\n                $this->metadata = [];\n            }\n\n            foreach ($this->metadata as $item) {\n                if ($item['name'] != $name || $language != $item['language']) {\n                    $tmp[] = $item;\n                }\n            }\n            $tmp[] = [\n                'name' => $name,\n                'type' => $type,\n                'data' => $data,\n                'language' => $language\n            ];\n            $this->metadata = $tmp;\n\n            $this->setHasMetaData(true);\n        }\n    }\n\n    /**\n     * @param null $name\n     * @param null $language\n     *\n     * @return array\n     */\n    public function getMetadata($name = null, $language = null)\n    {\n        $convert = function ($metaData) {\n            if (in_array($metaData['type'], ['asset', 'document', 'object']) && is_numeric($metaData['data'])) {\n                return Element\\Service::getElementById($metaData['type'], $metaData['data']);\n            }\n\n            return $metaData['data'];\n        };\n\n        if ($name) {\n            if ($language === null) {\n                $language = \\Pimcore::getContainer()->get('pimcore.locale')->findLocale();\n            }\n\n            $data = null;\n            foreach ($this->metadata as $md) {\n                if ($md['name'] == $name) {\n                    if ($language == $md['language']) {\n                        return $convert($md);\n                    }\n                    if (empty($md['language'])) {\n                        $data = $md;\n                    }\n                }\n            }\n\n            if ($data) {\n                return $convert($data);\n            }\n\n            return null;\n        }\n\n        $metaData = $this->getObjectVar('metadata');\n        if (is_array($metaData)) {\n            foreach ($metaData as &$md) {\n                $md = (array)$md;\n                $md['data'] = $convert($md);\n            }\n        }\n\n        return $metaData;\n    }\n\n    /**\n     * @return array\n     */\n    public function getScheduledTasks()\n    {\n        if ($this->scheduledTasks === null) {\n            $taskList = new Schedule\\Task\\Listing();\n            $taskList->setCondition(\"cid = ? AND ctype='asset'\", $this->getId());\n            $this->setScheduledTasks($taskList->load());\n        }\n\n        return $this->scheduledTasks;\n    }\n\n    /**\n     * @param $scheduledTasks\n     *\n     * @return $this\n     */\n    public function setScheduledTasks($scheduledTasks)\n    {\n        $this->scheduledTasks = $scheduledTasks;\n\n        return $this;\n    }\n\n    public function saveScheduledTasks()\n    {\n        $this->getScheduledTasks();\n        $this->getDao()->deleteAllTasks();\n\n        if (is_array($this->getScheduledTasks()) && count($this->getScheduledTasks()) > 0) {\n            foreach ($this->getScheduledTasks() as $task) {\n                $task->setId(null);\n                $task->setDao(null);\n                $task->setCid($this->getId());\n                $task->setCtype('asset');\n                $task->save();\n            }\n        }\n    }\n\n    /**\n     * Get filesize\n     *\n     * @param bool $formatted\n     * @param int $precision\n     *\n     * @return string\n     */\n    public function getFileSize($formatted = false, $precision = 2)\n    {\n        $bytes = 0;\n        if (is_file($this->getFileSystemPath())) {\n            $bytes = filesize($this->getFileSystemPath());\n        }\n\n        if ($formatted) {\n            return formatBytes($bytes, $precision);\n        }\n\n        return $bytes;\n    }\n\n    /**\n     * @return Asset\n     */\n    public function getParent()\n    {\n        if ($this->parent === null) {\n            $this->setParent(Asset::getById($this->getParentId()));\n        }\n\n        return $this->parent;\n    }\n\n    /**\n     * @param Asset $parent\n     *\n     * @return $this\n     */\n    public function setParent($parent)\n    {\n        $this->parent = $parent;\n        if ($parent instanceof Asset) {\n            $this->parentId = $parent->getId();\n        }\n\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getImageThumbnailSavePath()\n    {\n        $path = PIMCORE_TEMPORARY_DIRECTORY . '/image-thumbnails' . $this->getRealPath();\n        $path = rtrim($path, '/');\n\n        return $path;\n    }\n\n    /**\n     * @return string\n     */\n    public function getVideoThumbnailSavePath()\n    {\n        $path = PIMCORE_TEMPORARY_DIRECTORY . '/video-thumbnails' . $this->getRealPath();\n        $path = rtrim($path, '/');\n\n        return $path;\n    }\n\n    public function __sleep()\n    {\n        $finalVars = [];\n        $parentVars = parent::__sleep();\n\n        if (isset($this->_fulldump)) {\n            // this is if we want to make a full dump of the asset (eg. for a new version), including childs for recyclebin\n            $blockedVars = ['scheduledTasks', 'dependencies', 'userPermissions', 'hasChilds', 'versions', 'parent', 'stream'];\n            $finalVars[] = '_fulldump';\n            $this->removeInheritedProperties();\n        } else {\n            // this is if we want to cache the asset\n            $blockedVars = ['scheduledTasks', 'dependencies', 'userPermissions', 'hasChilds', 'versions', 'childs', 'properties', 'stream', 'parent'];\n        }\n\n        foreach ($parentVars as $key) {\n            if (!in_array($key, $blockedVars)) {\n                $finalVars[] = $key;\n            }\n        }\n\n        return $finalVars;\n    }\n\n    public function __wakeup()\n    {\n        if (isset($this->_fulldump)) {\n            // set current key and path this is necessary because the serialized data can have a different path than the original element (element was renamed or moved)\n            $originalElement = Asset::getById($this->getId());\n            if ($originalElement) {\n                $this->setFilename($originalElement->getFilename());\n                $this->setPath($originalElement->getRealPath());\n            }\n        }\n\n        if (isset($this->_fulldump) && $this->properties !== null) {\n            $this->renewInheritedProperties();\n        }\n\n        if (isset($this->_fulldump)) {\n            unset($this->_fulldump);\n        }\n    }\n\n    public function removeInheritedProperties()\n    {\n        $myProperties = $this->getProperties();\n\n        if ($myProperties) {\n            foreach ($this->getProperties() as $name => $property) {\n                if ($property->getInherited()) {\n                    unset($myProperties[$name]);\n                }\n            }\n        }\n\n        $this->setProperties($myProperties);\n    }\n\n    public function renewInheritedProperties()\n    {\n        $this->removeInheritedProperties();\n\n        // add to registry to avoid infinite regresses in the following $this->getDao()->getProperties()\n        $cacheKey = 'asset_' . $this->getId();\n        if (!\\Pimcore\\Cache\\Runtime::isRegistered($cacheKey)) {\n            \\Pimcore\\Cache\\Runtime::set($cacheKey, $this);\n        }\n\n        $myProperties = $this->getProperties();\n        $inheritedProperties = $this->getDao()->getProperties(true);\n        $this->setProperties(array_merge($inheritedProperties, $myProperties));\n    }\n\n    public function __destruct()\n    {\n\n        // close open streams\n        $this->closeStream();\n    }\n\n    /**\n     * @return int\n     */\n    public function getVersionCount(): int\n    {\n        return $this->versionCount ? $this->versionCount : 0;\n    }\n\n    /**\n     * @param int|null $versionCount\n     *\n     * @return Asset\n     */\n    public function setVersionCount(?int $versionCount): ElementInterface\n    {\n        $this->versionCount = (int) $versionCount;\n\n        return $this;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function resolveDependencies()\n    {\n        $dependencies = parent::resolveDependencies();\n\n        if ($this->hasMetaData) {\n            $metaData = $this->getMetadata();\n\n            foreach ($metaData as $md) {\n                if (isset($md['data']) && $md['data'] instanceof ElementInterface) {\n                    /**\n                     * @var $elementData ElementInterface\n                     */\n                    $elementData = $md['data'];\n                    $elementType = $md['type'];\n                    $key = $elementType . '_' . $elementData->getId();\n                    $dependencies[$key] = [\n                        'id' => $elementData->getId(),\n                        'type' => $elementType\n                    ];\n                }\n            }\n        }\n\n        return $dependencies;\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * Pimcore\n *\n * This source file is available under two different licenses:\n * - GNU General Public License version 3 (GPLv3)\n * - Pimcore Enterprise License (PEL)\n * Full copyright and license information is available in\n * LICENSE.md which is distributed with this source code.\n *\n * @category   Pimcore\n * @package    Asset\n *\n * @copyright  Copyright (c) Pimcore GmbH (http://www.pimcore.org)\n * @license    http://www.pimcore.org/license     GPLv3 and PEL\n */\n\nnamespace Pimcore\\Model;\n\nuse Pimcore\\Config;\nuse Pimcore\\Event\\AssetEvents;\nuse Pimcore\\Event\\FrontendEvents;\nuse Pimcore\\Event\\Model\\AssetEvent;\nuse Pimcore\\File;\nuse Pimcore\\Logger;\nuse Pimcore\\Model\\Element\\ElementInterface;\nuse Pimcore\\Tool\\Mime;\nuse Symfony\\Component\\EventDispatcher\\GenericEvent;\n\n/**\n * @method \\Pimcore\\Model\\Asset\\Dao getDao()\n * @method bool __isBasedOnLatestData()\n */\nclass Asset extends Element\\AbstractElement\n{\n    /**\n     * possible types of an asset\n     *\n     * @var array\n     */\n    public static $types = ['folder', 'image', 'text', 'audio', 'video', 'document', 'archive', 'unknown'];\n\n    /**\n     * Unique ID\n     *\n     * @var int\n     */\n    protected $id;\n\n    /**\n     * ID of the parent asset\n     *\n     * @var int\n     */\n    protected $parentId;\n\n    /**\n     * @var Asset\n     */\n    protected $parent;\n\n    /**\n     * Type\n     *\n     * @var string\n     */\n    protected $type;\n\n    /**\n     * Name of the file\n     *\n     * @var string\n     */\n    protected $filename;\n\n    /**\n     * Path of the file, without the filename, only the full path of the parent asset\n     *\n     * @var string\n     */\n    protected $path;\n\n    /**\n     * Mime-Type of the file\n     *\n     * @var string\n     */\n    protected $mimetype;\n\n    /**\n     * Timestamp of creation\n     *\n     * @var int\n     */\n    protected $creationDate;\n\n    /**\n     * Timestamp of modification\n     *\n     * @var int\n     */\n    protected $modificationDate;\n\n    /**\n     * @var resource\n     */\n    protected $stream;\n\n    /**\n     * ID of the owner user\n     *\n     * @var int\n     */\n    protected $userOwner;\n\n    /**\n     * ID of the user who make the latest changes\n     *\n     * @var int\n     */\n    protected $userModification;\n\n    /**\n     * List of properties\n     *\n     * @var array\n     */\n    protected $properties = null;\n\n    /**\n     * List of versions\n     *\n     * @var array\n     */\n    protected $versions = null;\n\n    /**\n     * @var array\n     */\n    protected $metadata = [];\n\n    /**\n     * enum('self','propagate') nullable\n     *\n     * @var string\n     */\n    protected $locked;\n\n    /**\n     * List of some custom settings  [key] => value\n     * Here there can be stored some data, eg. the video thumbnail files, ...  of the asset, ...\n     *\n     * @var array\n     */\n    protected $customSettings = [];\n\n    /**\n     * @var bool\n     */\n    protected $hasMetaData = false;\n\n    /**\n     * Dependencies of this asset\n     *\n     * @var Dependency\n     */\n    protected $dependencies;\n\n    /**\n     * Contains a list of sibling documents\n     *\n     * @var array\n     */\n    protected $siblings;\n\n    /**\n     * Indicator if document has siblings or not\n     *\n     * @var bool\n     */\n    protected $hasSiblings;\n\n    /**\n     * Contains all scheduled tasks\n     *\n     * @var array\n     */\n    protected $scheduledTasks = null;\n\n    /**\n     * Indicator if data has changed\n     *\n     * @var bool\n     */\n    protected $_dataChanged = false;\n\n    /** @var int */\n    protected $versionCount;\n\n    /**\n     *\n     * @return array\n     */\n    public static function getTypes()\n    {\n        return self::$types;\n    }\n\n    /**\n     * Static helper to get an asset by the passed path\n     *\n     * @param string $path\n     * @param bool $force\n     *\n     * @return Asset|Asset\\Archive|Asset\\Audio|Asset\\Document|Asset\\Folder|Asset\\Image|Asset\\Text|Asset\\Unknown|Asset\\Video\n     */\n    public static function getByPath($path, $force = false)\n    {\n        $path = Element\\Service::correctPath($path);\n\n        try {\n            $asset = new Asset();\n            $asset->getDao()->getByPath($path);\n\n            return self::getById($asset->getId(), $force);\n        } catch (\\Exception $e) {\n            return null;\n        }\n    }\n\n    /**\n     * @param Asset $asset\n     *\n     * @return bool\n     */\n    protected static function typeMatch(Asset $asset)\n    {\n        $staticType = get_called_class();\n        if ($staticType != Asset::class) {\n            if (!$asset instanceof $staticType) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Static helper to get an asset by the passed ID\n     *\n     * @param int $id\n     * @param bool $force\n     *\n     * @return Asset|Asset\\Archive|Asset\\Audio|Asset\\Document|Asset\\Folder|Asset\\Image|Asset\\Text|Asset\\Unknown|Asset\\Video\n     */\n    public static function getById($id, $force = false)\n    {\n        if (!is_numeric($id) || $id < 1) {\n            return null;\n        }\n        $id = intval($id);\n\n        $cacheKey = 'asset_' . $id;\n\n        if (!$force && \\Pimcore\\Cache\\Runtime::isRegistered($cacheKey)) {\n            $asset = \\Pimcore\\Cache\\Runtime::get($cacheKey);\n            if ($asset && static::typeMatch($asset)) {\n                return $asset;\n            }\n        }\n\n        try {\n            if ($force || !($asset = \\Pimcore\\Cache::load($cacheKey))) {\n                $asset = new Asset();\n                $asset->getDao()->getById($id);\n\n                $className = 'Pimcore\\\\Model\\\\Asset\\\\' . ucfirst($asset->getType());\n\n                $asset = self::getModelFactory()->build($className);\n                \\Pimcore\\Cache\\Runtime::set($cacheKey, $asset);\n                $asset->getDao()->getById($id);\n                $asset->__setDataVersionTimestamp($asset->getModificationDate());\n\n                \\Pimcore\\Cache::save($asset, $cacheKey);\n            } else {\n                \\Pimcore\\Cache\\Runtime::set($cacheKey, $asset);\n            }\n        } catch (\\Exception $e) {\n            return null;\n        }\n\n        if (!$asset || !static::typeMatch($asset)) {\n            return null;\n        }\n\n        return $asset;\n    }\n\n    /**\n     * Helper to quickly create a new asset\n     *\n     * @param int $parentId\n     * @param array $data\n     * @param bool $save\n     *\n     * @return Asset\n     */\n    public static function create($parentId, $data = [], $save = true)\n    {\n\n        // create already the real class for the asset type, this is especially for images, because a system-thumbnail\n        // (tree) is generated immediately after creating an image\n        $class = Asset::class;\n        if (array_key_exists('filename', $data) && (array_key_exists('data', $data) || array_key_exists('sourcePath', $data) || array_key_exists('stream', $data))) {\n            if (array_key_exists('data', $data) || array_key_exists('stream', $data)) {\n                $tmpFile = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/asset-create-tmp-file-' . uniqid() . '.' . File::getFileExtension($data['filename']);\n                if (array_key_exists('data', $data)) {\n                    File::put($tmpFile, $data['data']);\n                    $mimeType = Mime::detect($tmpFile);\n                    unlink($tmpFile);\n                } else {\n                    $streamMeta = stream_get_meta_data($data['stream']);\n                    if (file_exists($streamMeta['uri'])) {\n                        // stream is a local file, so we don't have to write a tmp file\n                        $mimeType = Mime::detect($streamMeta['uri']);\n                    } else {\n                        // write a tmp file because the stream isn't a pointer to the local filesystem\n                        rewind($data['stream']);\n                        $dest = fopen($tmpFile, 'w+', false, File::getContext());\n                        stream_copy_to_stream($data['stream'], $dest);\n                        fclose($dest);\n                        $mimeType = Mime::detect($tmpFile);\n                        unlink($tmpFile);\n                    }\n                }\n            } else {\n                $mimeType = Mime::detect($data['sourcePath'], $data['filename']);\n                if (is_file($data['sourcePath'])) {\n                    $data['stream'] = fopen($data['sourcePath'], 'r+', false, File::getContext());\n                }\n\n                unset($data['sourcePath']);\n            }\n\n            $type = self::getTypeFromMimeMapping($mimeType, $data['filename']);\n            $class = '\\\\Pimcore\\\\Model\\\\Asset\\\\' . ucfirst($type);\n            if (array_key_exists('type', $data)) {\n                unset($data['type']);\n            }\n        }\n\n        $asset = new $class();\n        $asset->setParentId($parentId);\n        $asset->setValues($data);\n\n        if ($save) {\n            $asset->save();\n        }\n\n        return $asset;\n    }\n\n    /**\n     * @param array $config\n     *\n     * @return mixed\n     *\n     * @throws \\Exception\n     */\n    public static function getList($config = [])\n    {\n        if (is_array($config)) {\n            $listClass = 'Pimcore\\\\Model\\\\Asset\\\\Listing';\n\n            $list = self::getModelFactory()->build($listClass);\n            $list->setValues($config);\n            $list->load();\n\n            return $list;\n        }\n    }\n\n    /**\n     * @param array $config\n     *\n     * @return int total count\n     */\n    public static function getTotalCount($config = [])\n    {\n        if (is_array($config)) {\n            $listClass = 'Pimcore\\\\Model\\\\Asset\\\\Listing';\n            $list = self::getModelFactory()->build($listClass);\n            $list->setValues($config);\n            $count = $list->getTotalCount();\n\n            return $count;\n        }\n    }\n\n    /**\n     * returns the asset type of a filename and mimetype\n     *\n     * @param $mimeType\n     * @param $filename\n     *\n     * @return int|string\n     */\n    public static function getTypeFromMimeMapping($mimeType, $filename)\n    {\n        if ($mimeType == 'directory') {\n            return 'folder';\n        }\n\n        $type = null;\n\n        $mappings = [\n            'unknown' => [\"/\\.stp$/\"],\n            'image' => ['/image/', \"/\\.eps$/\", \"/\\.ai$/\", \"/\\.svgz$/\", \"/\\.pcx$/\", \"/\\.iff$/\", \"/\\.pct$/\", \"/\\.wmf$/\"],\n            'text' => ['/text/', '/xml$/'],\n            'audio' => ['/audio/'],\n            'video' => ['/video/'],\n            'document' => ['/msword/', '/pdf/', '/powerpoint/', '/office/', '/excel/', '/opendocument/'],\n            'archive' => ['/zip/', '/tar/'],\n        ];\n\n        foreach ($mappings as $assetType => $patterns) {\n            foreach ($patterns as $pattern) {\n                if (preg_match($pattern, $mimeType . ' .'. File::getFileExtension($filename))) {\n                    $type = $assetType;\n                    break;\n                }\n            }\n\n            // break at first match\n            if ($type) {\n                break;\n            }\n        }\n\n        if (!$type) {\n            $type = 'unknown';\n        }\n\n        return $type;\n    }\n\n    /**\n     * Get full path to the asset on the filesystem\n     *\n     * @return string\n     */\n    public function getFileSystemPath()\n    {\n        return PIMCORE_ASSET_DIRECTORY . $this->getRealFullPath();\n    }\n\n    /**\n     * @return $this\n     *\n     * @throws \\Exception\n     */\n    public function save()\n    {\n        // additional parameters (e.g. \"versionNote\" for the version note)\n        $params = [];\n        if (func_num_args() && is_array(func_get_arg(0))) {\n            $params = func_get_arg(0);\n        }\n\n        $isUpdate = false;\n\n        $preEvent = new AssetEvent($this, $params);\n\n        if ($this->getId()) {\n            $isUpdate = true;\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::PRE_UPDATE, $preEvent);\n        } else {\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::PRE_ADD, $preEvent);\n        }\n\n        $params = $preEvent->getArguments();\n\n        $this->correctPath();\n\n        // we wrap the save actions in a loop here, so that we can restart the database transactions in the case it fails\n        // if a transaction fails it gets restarted $maxRetries times, then the exception is thrown out\n        // this is especially useful to avoid problems with deadlocks in multi-threaded environments (forked workers, ...)\n        $maxRetries = 5;\n        for ($retries = 0; $retries < $maxRetries; $retries++) {\n            $this->beginTransaction();\n\n            try {\n                if (!$isUpdate) {\n                    $this->getDao()->create();\n                }\n\n                // get the old path from the database before the update is done\n                $oldPath = null;\n                if ($isUpdate) {\n                    $oldPath = $this->getDao()->getCurrentFullPath();\n                }\n\n                $this->update($params);\n\n                // if the old path is different from the new path, update all children\n                $updatedChildren = [];\n                if ($oldPath && $oldPath != $this->getRealFullPath()) {\n                    $oldFullPath = PIMCORE_ASSET_DIRECTORY . $oldPath;\n                    if (is_file($oldFullPath) || is_dir($oldFullPath)) {\n                        if (!@File::rename(PIMCORE_ASSET_DIRECTORY . $oldPath, $this->getFileSystemPath())) {\n                            $error = error_get_last();\n                            throw new \\Exception('Unable to rename asset ' . $this->getId() . ' on the filesystem: ' . $oldFullPath . ' - Reason: ' . $error['message']);\n                        }\n                        $differentOldPath = $oldPath;\n                        $this->getDao()->updateWorkspaces();\n                        $updatedChildren = $this->getDao()->updateChildsPaths($oldPath);\n                    }\n                }\n\n                // lastly create a new version if necessary\n                // this has to be after the registry update and the DB update, otherwise this would cause problem in the\n                // $this->__wakeUp() method which is called by $version->save(); (path correction for version restore)\n                if ($this->getType() != 'folder') {\n                    $this->saveVersion(false, false, isset($params['versionNote']) ? $params['versionNote'] : null);\n                }\n\n                $this->commit();\n\n                break; // transaction was successfully completed, so we cancel the loop here -> no restart required\n            } catch (\\Exception $e) {\n                try {\n                    $this->rollBack();\n                } catch (\\Exception $er) {\n                    // PDO adapter throws exceptions if rollback fails\n                    Logger::error($er);\n                }\n\n                // we try to start the transaction $maxRetries times again (deadlocks, ...)\n                if ($retries < ($maxRetries - 1)) {\n                    $run = $retries + 1;\n                    $waitTime = rand(1, 5) * 100000; // microseconds\n                    Logger::warn('Unable to finish transaction (' . $run . \". run) because of the following reason '\" . $e->getMessage() . \"'. --> Retrying in \" . $waitTime . ' microseconds ... (' . ($run + 1) . ' of ' . $maxRetries . ')');\n\n                    usleep($waitTime); // wait specified time until we restart the transaction\n                } else {\n                    if ($isUpdate) {\n                        \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_UPDATE_FAILURE, new AssetEvent($this));\n                    } else {\n                        \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_ADD_FAILURE, new AssetEvent($this));\n                    }\n                    // if the transaction still fail after $maxRetries retries, we throw out the exception\n                    throw $e;\n                }\n            }\n        }\n\n        $additionalTags = [];\n        if (isset($updatedChildren) && is_array($updatedChildren)) {\n            foreach ($updatedChildren as $assetId) {\n                $tag = 'asset_' . $assetId;\n                $additionalTags[] = $tag;\n\n                // remove the child also from registry (internal cache) to avoid path inconsistencies during long running scripts, such as CLI\n                \\Pimcore\\Cache\\Runtime::set($tag, null);\n            }\n        }\n        $this->clearDependentCache($additionalTags);\n        $this->setDataChanged(false);\n\n        if ($isUpdate) {\n            $updateEvent = new AssetEvent($this);\n            if ($differentOldPath) {\n                $updateEvent->setArgument('oldPath', $differentOldPath);\n            }\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_UPDATE, $updateEvent);\n        } else {\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_ADD, new AssetEvent($this));\n        }\n\n        return $this;\n    }\n\n    /**\n     * @throws \\Exception\n     */\n    public function correctPath()\n    {\n        // set path\n        if ($this->getId() != 1) { // not for the root node\n\n            if (!Element\\Service::isValidKey($this->getKey(), 'asset')) {\n                throw new \\Exception(\"invalid filename '\".$this->getKey().\"' for asset with id [ \" . $this->getId() . ' ]');\n            }\n\n            if ($this->getParentId() == $this->getId()) {\n                throw new \\Exception(\"ParentID and ID is identical, an element can't be the parent of itself.\");\n            }\n\n            if ($this->getFilename() === '..' || $this->getFilename() === '.') {\n                throw new \\Exception('Cannot create asset called \"..\" or \".\"');\n            }\n\n            $parent = Asset::getById($this->getParentId());\n            if ($parent) {\n                // use the parent's path from the database here (getCurrentFullPath), to ensure the path really exists and does not rely on the path\n                // that is currently in the parent asset (in memory), because this might have changed but wasn't not saved\n                $this->setPath(str_replace('//', '/', $parent->getCurrentFullPath() . '/'));\n            } else {\n                // parent document doesn't exist anymore, set the parent to to root\n                $this->setParentId(1);\n                $this->setPath('/');\n            }\n        } elseif ($this->getId() == 1) {\n            // some data in root node should always be the same\n            $this->setParentId(0);\n            $this->setPath('/');\n            $this->setFilename('');\n            $this->setType('folder');\n        }\n\n        // do not allow PHP and .htaccess files\n        if (preg_match(\"@\\.ph(p[\\d+]?|t|tml|ps)$@i\", $this->getFilename()) || $this->getFilename() == '.htaccess') {\n            $this->setFilename($this->getFilename() . '.txt');\n        }\n\n        if(mb_strlen($this->getFilename()) > 255) {\n            throw new \\Exception('Filenames longer than 255 characters are not allowed');\n        }\n\n        if (Asset\\Service::pathExists($this->getRealFullPath())) {\n            $duplicate = Asset::getByPath($this->getRealFullPath());\n            if ($duplicate instanceof Asset and $duplicate->getId() != $this->getId()) {\n                throw new \\Exception('Duplicate full path [ ' . $this->getRealFullPath() . ' ] - cannot save asset');\n            }\n        }\n\n        $this->validatePathLength();\n    }\n\n    /**\n     * @param array $params additional parameters (e.g. \"versionNote\" for the version note)\n     *\n     * @throws \\Exception\n     */\n    protected function update($params = [])\n    {\n        $this->updateModificationInfos();\n\n        // create foldertree\n        // use current file name in order to prevent problems when filename has changed\n        // (otherwise binary data would be overwritten with old binary data with rename() in save method)\n        $destinationPathRelative = $this->getDao()->getCurrentFullPath();\n        if (!$destinationPathRelative) {\n            // this is happen during a restore from the recycle bin\n            $destinationPathRelative = $this->getRealFullPath();\n        }\n        $destinationPath = PIMCORE_ASSET_DIRECTORY . $destinationPathRelative;\n\n        $dirPath = dirname($destinationPath);\n        if (!is_dir($dirPath)) {\n            if (!File::mkdir($dirPath)) {\n                throw new \\Exception('Unable to create directory: '. $dirPath . ' for asset :' . $this->getId());\n            }\n        }\n\n        $typeChanged = false;\n\n        // fix for missing parent folders\n        // check if folder of new destination is already created and if not do so\n        $newPath = dirname($this->getFileSystemPath());\n        if (!is_dir($newPath)) {\n            if (!File::mkdir($newPath)) {\n                throw new \\Exception('Unable to create directory: '. $newPath . ' for asset :' . $this->getId());\n            }\n        }\n\n        if ($this->getType() != 'folder') {\n            if ($this->getDataChanged()) {\n                $src = $this->getStream();\n                $streamMeta = stream_get_meta_data($src);\n                if ($destinationPath != $streamMeta['uri']) {\n                    if (file_exists($destinationPath)) {\n                        // We don't open a stream on existing files, because they could be possibly used by versions\n                        // using hardlinks, so it's safer to delete them first, so the inode and therefore also the\n                        // versioning information persists. Using the stream on the existing file would overwrite the\n                        // contents of the inode and therefore leads to wrong version data\n                        unlink($destinationPath);\n                    }\n\n                    $dest = fopen($destinationPath, 'w', false, File::getContext());\n                    if ($dest) {\n                        stream_copy_to_stream($src, $dest);\n                        if (!fclose($dest)) {\n                            throw new \\Exception('Unable to close file handle ' . $destinationPath . ' for asset ' . $this->getId());\n                        }\n                    } else {\n                        throw new \\Exception('Unable to open file: ' . $destinationPath . ' for asset ' . $this->getId());\n                    }\n                }\n\n                $this->stream = null; // set stream to null, so that the source stream isn't used anymore after saving\n\n                @chmod($destinationPath, File::getDefaultMode());\n\n                // check file exists\n                if (!is_file($destinationPath)) {\n                    throw new \\Exception(\"couldn't create new asset, file \" . $destinationPath . \" doesn't exist\");\n                }\n\n                // set mime type\n                $mimetype = Mime::detect($destinationPath, $this->getFilename());\n                $this->setMimetype($mimetype);\n\n                // set type\n                $type = self::getTypeFromMimeMapping($mimetype, $this->getFilename());\n                if ($type != $this->getType()) {\n                    $this->setType($type);\n                    $typeChanged = true;\n                }\n\n                // not only check if the type is set but also if the implementation can be found\n                $className = 'Pimcore\\\\Model\\\\Asset\\\\' . ucfirst($this->getType());\n                if (!self::getModelFactory()->supports($className)) {\n                    throw new \\Exception('unable to resolve asset implementation with type: ' . $this->getType());\n                }\n            }\n\n            // scheduled tasks are saved in $this->saveVersion();\n        } else {\n            if (!is_dir($destinationPath) && !is_dir($this->getFileSystemPath())) {\n                if (!File::mkdir($this->getFileSystemPath())) {\n                    throw new \\Exception('Unable to create directory: '. $this->getFileSystemPath() . ' for asset :' . $this->getId());\n                }\n            }\n        }\n\n        $this->postPersistData();\n\n        // save properties\n        $this->getProperties();\n        $this->getDao()->deleteAllProperties();\n        if (is_array($this->getProperties()) and count($this->getProperties()) > 0) {\n            foreach ($this->getProperties() as $property) {\n                if (!$property->getInherited()) {\n                    $property->setDao(null);\n                    $property->setCid($this->getId());\n                    $property->setCtype('asset');\n                    $property->setCpath($this->getRealFullPath());\n                    $property->save();\n                }\n            }\n        }\n\n        // save dependencies\n        $d = new Dependency();\n        $d->setSourceType('asset');\n        $d->setSourceId($this->getId());\n\n        foreach ($this->resolveDependencies() as $requirement) {\n            if ($requirement['id'] == $this->getId() && $requirement['type'] == 'asset') {\n                // dont't add a reference to yourself\n                continue;\n            } else {\n                $d->addRequirement($requirement['id'], $requirement['type']);\n            }\n        }\n        $d->save();\n\n        $this->getDao()->update();\n\n        //set asset to registry\n        \\Pimcore\\Cache\\Runtime::set('asset_' . $this->getId(), $this);\n        if (get_class($this) == 'Asset' || $typeChanged) {\n            // get concrete type of asset\n            // this is important because at the time of creating an asset it's not clear which type (resp. class) it will have\n            // the type (image, document, ...) depends on the mime-type\n            \\Pimcore\\Cache\\Runtime::set('asset_' . $this->getId(), null);\n            $asset = Asset::getById($this->getId());\n            \\Pimcore\\Cache\\Runtime::set('asset_' . $this->getId(), $asset);\n        }\n\n        $this->closeStream();\n    }\n\n    protected function postPersistData()\n    {\n        // hook for the save process, can be overwritten in implementations, such as Image\n    }\n\n    /**\n     * @param bool $setModificationDate\n     * @param bool $saveOnlyVersion\n     * @param string $versionNote version note\n     *\n     * @return null|Version\n     *\n     * @throws \\Exception\n     */\n    public function saveVersion($setModificationDate = true, $saveOnlyVersion = true, $versionNote = null)\n    {\n\n        // hook should be also called if \"save only new version\" is selected\n        if ($saveOnlyVersion) {\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::PRE_UPDATE, new AssetEvent($this, [\n                'saveVersionOnly' => true\n            ]));\n        }\n\n        // set date\n        if ($setModificationDate) {\n            $this->setModificationDate(time());\n        }\n\n        // scheduled tasks are saved always, they are not versioned!\n        $this->saveScheduledTasks();\n\n        // create version\n        $version = null;\n\n        // only create a new version if there is at least 1 allowed\n        // or if saveVersion() was called directly (it's a newer version of the asset)\n        if (Config::getSystemConfig()->assets->versions->steps\n            || Config::getSystemConfig()->assets->versions->days\n            || $setModificationDate) {\n            $version = $this->doSaveVersion($versionNote, $saveOnlyVersion);\n        }\n\n        // hook should be also called if \"save only new version\" is selected\n        if ($saveOnlyVersion) {\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_UPDATE, new AssetEvent($this, [\n                'saveVersionOnly' => true\n            ]));\n        }\n\n        return $version;\n    }\n\n    /**\n     * Returns the full path of the document including the filename\n     *\n     * @return string\n     */\n    public function getFullPath()\n    {\n        $path = $this->getPath() . $this->getFilename();\n\n        if (\\Pimcore\\Tool::isFrontend()) {\n            $path = urlencode_ignore_slash($path);\n\n            $event = new GenericEvent($this, [\n                'frontendPath' => $path\n            ]);\n            \\Pimcore::getEventDispatcher()->dispatch(FrontendEvents::ASSET_PATH, $event);\n            $path = $event->getArgument('frontendPath');\n        }\n\n        return $path;\n    }\n\n    /**\n     * @return string\n     */\n    public function getRealPath()\n    {\n        return $this->path;\n    }\n\n    /**\n     * @return string\n     */\n    public function getRealFullPath()\n    {\n        $path = $this->getRealPath() . $this->getFilename();\n\n        return $path;\n    }\n\n    /**\n     * Get a list of the sibling assets\n     *\n     * @return array\n     */\n    public function getSiblings()\n    {\n        if ($this->siblings === null) {\n            $list = new Asset\\Listing();\n            // string conversion because parentId could be 0\n            $list->addConditionParam('parentId = ?', (string)$this->getParentId());\n            $list->addConditionParam('id != ?', $this->getId());\n            $list->setOrderKey('filename');\n            $list->setOrder('asc');\n            $this->siblings = $list->load();\n        }\n\n        return $this->siblings;\n    }\n\n    /**\n     * Returns true if the asset has at least one sibling\n     *\n     * @return bool\n     */\n    public function hasSiblings()\n    {\n        if (is_bool($this->hasSiblings)) {\n            if (($this->hasSiblings and empty($this->siblings)) or (!$this->hasSiblings and !empty($this->siblings))) {\n                return $this->getDao()->hasSiblings();\n            } else {\n                return $this->hasSiblings;\n            }\n        }\n\n        return $this->getDao()->hasSiblings();\n    }\n\n    /**\n     * @return bool\n     */\n    public function hasChildren()\n    {\n        return false;\n    }\n\n    /**\n     * Returns true if the element is locked\n     *\n     * @return string\n     */\n    public function getLocked()\n    {\n        return $this->locked;\n    }\n\n    /**\n     * @param  $locked\n     *\n     * @return $this\n     */\n    public function setLocked($locked)\n    {\n        $this->locked = $locked;\n\n        return $this;\n    }\n\n    /**\n     * Deletes file from filesystem\n     */\n    protected function deletePhysicalFile()\n    {\n        $fsPath = $this->getFileSystemPath();\n\n        if ($this->getType() != 'folder') {\n            if (is_file($fsPath) && is_writable($fsPath)) {\n                unlink($fsPath);\n            }\n        } else {\n            if (is_dir($fsPath) && is_writable($fsPath)) {\n                recursiveDelete($fsPath, true);\n            }\n        }\n    }\n\n    /**\n     * @param bool $isNested\n     *\n     * @throws \\Exception\n     */\n    public function delete(bool $isNested = false)\n    {\n        if ($this->getId() == 1) {\n            throw new \\Exception('root-node cannot be deleted');\n        }\n\n        \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::PRE_DELETE, new AssetEvent($this));\n\n        $this->beginTransaction();\n\n        try {\n            $this->closeStream();\n\n            // remove childs\n            if ($this->hasChildren()) {\n                foreach ($this->getChildren() as $child) {\n                    $child->delete(true);\n                }\n            }\n\n            $versions = $this->getVersions();\n            foreach ($versions as $version) {\n                $version->delete();\n            }\n\n            // remove permissions\n            $this->getDao()->deleteAllPermissions();\n\n            // remove all properties\n            $this->getDao()->deleteAllProperties();\n\n            // remove all metadata\n            $this->getDao()->deleteAllMetadata();\n\n            // remove all tasks\n            $this->getDao()->deleteAllTasks();\n\n            // remove dependencies\n            $d = $this->getDependencies();\n            $d->cleanAllForElement($this);\n\n            // remove from resource\n            $this->getDao()->delete();\n\n            $this->commit();\n\n            // remove file on filesystem\n            if (!$isNested) {\n                $fullPath = $this->getRealFullPath();\n                if ($fullPath != '/..' && !strpos($fullPath,\n                        '/../') && $this->getKey() !== '.' && $this->getKey() !== '..') {\n                    $this->deletePhysicalFile();\n                }\n            }\n        } catch (\\Exception $e) {\n            $this->rollBack();\n            \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_DELETE_FAILURE, new AssetEvent($this));\n            Logger::crit($e);\n            throw $e;\n        }\n\n        // empty asset cache\n        $this->clearDependentCache();\n\n        // clear asset from registry\n        \\Pimcore\\Cache\\Runtime::set('asset_' . $this->getId(), null);\n\n        \\Pimcore::getEventDispatcher()->dispatch(AssetEvents::POST_DELETE, new AssetEvent($this));\n    }\n\n    /**\n     * @param array $additionalTags\n     */\n    public function clearDependentCache($additionalTags = [])\n    {\n        try {\n            $tags = ['asset_' . $this->getId(), 'asset_properties', 'output'];\n            $tags = array_merge($tags, $additionalTags);\n\n            \\Pimcore\\Cache::clearTags($tags);\n        } catch (\\Exception $e) {\n            Logger::crit($e);\n        }\n    }\n\n    /**\n     * @return Dependency\n     */\n    public function getDependencies()\n    {\n        if (!$this->dependencies) {\n            $this->dependencies = Dependency::getBySourceId($this->getId(), 'asset');\n        }\n\n        return $this->dependencies;\n    }\n\n    /**\n     * @return int\n     */\n    public function getCreationDate()\n    {\n        return $this->creationDate;\n    }\n\n    /**\n     * @return int\n     */\n    public function getId()\n    {\n        return (int) $this->id;\n    }\n\n    /**\n     * @return string\n     */\n    public function getFilename()\n    {\n        return (string) $this->filename;\n    }\n\n    /**\n     * Alias for getFilename()\n     *\n     * @return string\n     */\n    public function getKey()\n    {\n        return $this->getFilename();\n    }\n\n    /**\n     * @return int\n     */\n    public function getModificationDate()\n    {\n        return (int) $this->modificationDate;\n    }\n\n    /**\n     * @return int\n     */\n    public function getParentId()\n    {\n        return $this->parentId;\n    }\n\n    /**\n     * @return string\n     */\n    public function getPath()\n    {\n        return $this->path;\n    }\n\n    /**\n     * @return string\n     */\n    public function getType()\n    {\n        return $this->type;\n    }\n\n    /**\n     * @param int $creationDate\n     *\n     * @return $this\n     */\n    public function setCreationDate($creationDate)\n    {\n        $this->creationDate = (int) $creationDate;\n\n        return $this;\n    }\n\n    /**\n     * @param int $id\n     *\n     * @return $this\n     */\n    public function setId($id)\n    {\n        $this->id = (int) $id;\n\n        return $this;\n    }\n\n    /**\n     * @param string $filename\n     *\n     * @return $this\n     */\n    public function setFilename($filename)\n    {\n        $this->filename = (string) $filename;\n\n        return $this;\n    }\n\n    /**\n     * @param int $modificationDate\n     *\n     * @return $this\n     */\n    public function setModificationDate($modificationDate)\n    {\n        $this->modificationDate = (int) $modificationDate;\n\n        return $this;\n    }\n\n    /**\n     * @param int $parentId\n     *\n     * @return $this\n     */\n    public function setParentId($parentId)\n    {\n        $this->parentId = (int) $parentId;\n        $this->parent = null;\n\n        return $this;\n    }\n\n    /**\n     * @param string $path\n     *\n     * @return $this\n     */\n    public function setPath($path)\n    {\n        $this->path = $path;\n\n        return $this;\n    }\n\n    /**\n     * @param string $type\n     *\n     * @return $this\n     */\n    public function setType($type)\n    {\n        $this->type = $type;\n\n        return $this;\n    }\n\n    /**\n     * @return mixed\n     */\n    public function getData()\n    {\n        $stream = $this->getStream();\n        if ($stream) {\n            return stream_get_contents($stream);\n        }\n\n        return '';\n    }\n\n    /**\n     * @param mixed $data\n     *\n     * @return $this\n     */\n    public function setData($data)\n    {\n        $handle = tmpfile();\n        fwrite($handle, $data);\n        $this->setStream($handle);\n\n        return $this;\n    }\n\n    /**\n     * @return resource\n     */\n    public function getStream()\n    {\n        if ($this->stream) {\n            $streamMeta = stream_get_meta_data($this->stream);\n            if (!@rewind($this->stream) && $streamMeta['stream_type'] === 'STDIO') {\n                $this->stream = null;\n            }\n        }\n\n        if (!$this->stream && $this->getType() != 'folder') {\n            if (file_exists($this->getFileSystemPath())) {\n                $this->stream = fopen($this->getFileSystemPath(), 'r', false, File::getContext());\n            } else {\n                $this->stream = tmpfile();\n            }\n        }\n\n        return $this->stream;\n    }\n\n    /**\n     * @param $stream\n     *\n     * @return $this\n     */\n    public function setStream($stream)\n    {\n        // close existing stream\n        if ($stream !== $this->stream) {\n            $this->closeStream();\n        }\n\n        if (is_resource($stream)) {\n            $this->setDataChanged(true);\n            $this->stream = $stream;\n            rewind($this->stream);\n        } elseif (is_null($stream)) {\n            $this->stream = null;\n        }\n\n        return $this;\n    }\n\n    protected function closeStream()\n    {\n        if (is_resource($this->stream)) {\n            @fclose($this->stream);\n            $this->stream = null;\n        }\n    }\n\n    /**\n     * @param string $type\n     *\n     * @return null|string\n     *\n     * @throws \\Exception\n     */\n    public function getChecksum($type = 'md5')\n    {\n        $file = $this->getFileSystemPath();\n        if (is_file($file)) {\n            if ($type == 'md5') {\n                return md5_file($file);\n            } elseif ($type == 'sha1') {\n                return sha1_file($file);\n            } else {\n                throw new \\Exception(\"hashing algorithm '\" . $type . \"' isn't supported\");\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @return bool\n     */\n    public function getDataChanged()\n    {\n        return $this->_dataChanged;\n    }\n\n    /**\n     * @param bool $changed\n     *\n     * @return $this\n     */\n    public function setDataChanged($changed = true)\n    {\n        $this->_dataChanged = $changed;\n\n        return $this;\n    }\n\n    /**\n     * @return Property[]\n     */\n    public function getProperties()\n    {\n        if ($this->properties === null) {\n            // try to get from cache\n            $cacheKey = 'asset_properties_' . $this->getId();\n            $properties = \\Pimcore\\Cache::load($cacheKey);\n            if (!is_array($properties)) {\n                $properties = $this->getDao()->getProperties();\n                $elementCacheTag = $this->getCacheTag();\n                $cacheTags = ['asset_properties' => 'asset_properties', $elementCacheTag => $elementCacheTag];\n                \\Pimcore\\Cache::save($properties, $cacheKey, $cacheTags);\n            }\n\n            $this->setProperties($properties);\n        }\n\n        return $this->properties;\n    }\n\n    /**\n     * @param array $properties\n     *\n     * @return $this\n     */\n    public function setProperties($properties)\n    {\n        $this->properties = $properties;\n\n        return $this;\n    }\n\n    /**\n     * @param $name\n     * @param $type\n     * @param $data\n     * @param bool $inherited\n     * @param bool $inheritable\n     *\n     * @return $this\n     */\n    public function setProperty($name, $type, $data, $inherited = false, $inheritable = false)\n    {\n        $this->getProperties();\n\n        $property = new Property();\n        $property->setType($type);\n        $property->setCid($this->getId());\n        $property->setName($name);\n        $property->setCtype('asset');\n        $property->setData($data);\n        $property->setInherited($inherited);\n        $property->setInheritable($inheritable);\n\n        $this->properties[$name] = $property;\n\n        return $this;\n    }\n\n    /**\n     * @return int\n     */\n    public function getUserOwner()\n    {\n        return $this->userOwner;\n    }\n\n    /**\n     * @return int\n     */\n    public function getUserModification()\n    {\n        return $this->userModification;\n    }\n\n    /**\n     * @param int $userOwner\n     *\n     * @return $this\n     */\n    public function setUserOwner($userOwner)\n    {\n        $this->userOwner = (int) $userOwner;\n\n        return $this;\n    }\n\n    /**\n     * @param int $userModification\n     *\n     * @return $this\n     */\n    public function setUserModification($userModification)\n    {\n        $this->userModification = (int) $userModification;\n\n        return $this;\n    }\n\n    /**\n     * @return array\n     */\n    public function getVersions()\n    {\n        if ($this->versions === null) {\n            $this->setVersions($this->getDao()->getVersions());\n        }\n\n        return $this->versions;\n    }\n\n    /**\n     * @param array $versions\n     *\n     * @return $this\n     */\n    public function setVersions($versions)\n    {\n        $this->versions = $versions;\n\n        return $this;\n    }\n\n    /**\n     * returns the path to a temp file\n     *\n     * @return string\n     */\n    public function getTemporaryFile()\n    {\n        $destinationPath = PIMCORE_SYSTEM_TEMP_DIRECTORY . '/asset-temporary/asset_' . $this->getId() . '_' . md5(microtime()) . '__' . $this->getFilename();\n        if (!is_dir(dirname($destinationPath))) {\n            File::mkdir(dirname($destinationPath));\n        }\n\n        $src = $this->getStream();\n        $dest = fopen($destinationPath, 'w+', false, File::getContext());\n        stream_copy_to_stream($src, $dest);\n        fclose($dest);\n\n        @chmod($destinationPath, File::getDefaultMode());\n\n        return $destinationPath;\n    }\n\n    /**\n     * @param string $key\n     * @param mixed $value\n     *\n     * @return $this\n     */\n    public function setCustomSetting($key, $value)\n    {\n        $this->customSettings[$key] = $value;\n\n        return $this;\n    }\n\n    /**\n     * @param $key\n     *\n     * @return null\n     */\n    public function getCustomSetting($key)\n    {\n        if (is_array($this->customSettings) && array_key_exists($key, $this->customSettings)) {\n            return $this->customSettings[$key];\n        }\n\n        return null;\n    }\n\n    /**\n     * @param $key\n     */\n    public function removeCustomSetting($key)\n    {\n        if (is_array($this->customSettings) && array_key_exists($key, $this->customSettings)) {\n            unset($this->customSettings[$key]);\n        }\n    }\n\n    /**\n     * @return array\n     */\n    public function getCustomSettings()\n    {\n        return $this->customSettings;\n    }\n\n    /**\n     * @param array $customSettings\n     *\n     * @return $this\n     */\n    public function setCustomSettings($customSettings)\n    {\n        if (is_string($customSettings)) {\n            $customSettings = \\Pimcore\\Tool\\Serialize::unserialize($customSettings);\n        }\n\n        if ($customSettings instanceof \\stdClass) {\n            $customSettings = (array) $customSettings;\n        }\n\n        if (!is_array($customSettings)) {\n            $customSettings = [];\n        }\n\n        $this->customSettings = $customSettings;\n\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getMimetype()\n    {\n        return $this->mimetype;\n    }\n\n    /**\n     * @param string $mimetype\n     *\n     * @return $this\n     */\n    public function setMimetype($mimetype)\n    {\n        $this->mimetype = $mimetype;\n\n        return $this;\n    }\n\n    /**\n     * @param array $metadata\n     */\n    public function setMetadata($metadata)\n    {\n        $this->metadata = $metadata;\n\n        if (!empty($metadata)) {\n            $this->setHasMetaData(true);\n        }\n    }\n\n    /**\n     * @return bool\n     */\n    public function getHasMetaData()\n    {\n        return $this->hasMetaData;\n    }\n\n    /**\n     * @param bool $hasMetaData\n     */\n    public function setHasMetaData($hasMetaData)\n    {\n        $this->hasMetaData = (bool) $hasMetaData;\n    }\n\n    /**\n     * @param string $name\n     * @param string $type can be \"folder\", \"image\", \"input\", \"audio\", \"video\", \"document\", \"archive\" or \"unknown\"\n     * @param null $data\n     * @param null $language\n     */\n    public function addMetadata($name, $type, $data = null, $language = null)\n    {\n        if ($name && $type) {\n            $tmp = [];\n            if (!is_array($this->metadata)) {\n                $this->metadata = [];\n            }\n\n            foreach ($this->metadata as $item) {\n                if ($item['name'] != $name || $language != $item['language']) {\n                    $tmp[] = $item;\n                }\n            }\n            $tmp[] = [\n                'name' => $name,\n                'type' => $type,\n                'data' => $data,\n                'language' => $language\n            ];\n            $this->metadata = $tmp;\n\n            $this->setHasMetaData(true);\n        }\n    }\n\n    /**\n     * @param null $name\n     * @param null $language\n     *\n     * @return array\n     */\n    public function getMetadata($name = null, $language = null)\n    {\n        $convert = function ($metaData) {\n            if (in_array($metaData['type'], ['asset', 'document', 'object']) && is_numeric($metaData['data'])) {\n                return Element\\Service::getElementById($metaData['type'], $metaData['data']);\n            }\n\n            return $metaData['data'];\n        };\n\n        if ($name) {\n            if ($language === null) {\n                $language = \\Pimcore::getContainer()->get('pimcore.locale')->findLocale();\n            }\n\n            $data = null;\n            foreach ($this->metadata as $md) {\n                if ($md['name'] == $name) {\n                    if ($language == $md['language']) {\n                        return $convert($md);\n                    }\n                    if (empty($md['language'])) {\n                        $data = $md;\n                    }\n                }\n            }\n\n            if ($data) {\n                return $convert($data);\n            }\n\n            return null;\n        }\n\n        $metaData = $this->getObjectVar('metadata');\n        if (is_array($metaData)) {\n            foreach ($metaData as &$md) {\n                $md = (array)$md;\n                $md['data'] = $convert($md);\n            }\n        }\n\n        return $metaData;\n    }\n\n    /**\n     * @return array\n     */\n    public function getScheduledTasks()\n    {\n        if ($this->scheduledTasks === null) {\n            $taskList = new Schedule\\Task\\Listing();\n            $taskList->setCondition(\"cid = ? AND ctype='asset'\", $this->getId());\n            $this->setScheduledTasks($taskList->load());\n        }\n\n        return $this->scheduledTasks;\n    }\n\n    /**\n     * @param $scheduledTasks\n     *\n     * @return $this\n     */\n    public function setScheduledTasks($scheduledTasks)\n    {\n        $this->scheduledTasks = $scheduledTasks;\n\n        return $this;\n    }\n\n    public function saveScheduledTasks()\n    {\n        $this->getScheduledTasks();\n        $this->getDao()->deleteAllTasks();\n\n        if (is_array($this->getScheduledTasks()) && count($this->getScheduledTasks()) > 0) {\n            foreach ($this->getScheduledTasks() as $task) {\n                $task->setId(null);\n                $task->setDao(null);\n                $task->setCid($this->getId());\n                $task->setCtype('asset');\n                $task->save();\n            }\n        }\n    }\n\n    /**\n     * Get filesize\n     *\n     * @param bool $formatted\n     * @param int $precision\n     *\n     * @return string\n     */\n    public function getFileSize($formatted = false, $precision = 2)\n    {\n        $bytes = 0;\n        if (is_file($this->getFileSystemPath())) {\n            $bytes = filesize($this->getFileSystemPath());\n        }\n\n        if ($formatted) {\n            return formatBytes($bytes, $precision);\n        }\n\n        return $bytes;\n    }\n\n    /**\n     * @return Asset\n     */\n    public function getParent()\n    {\n        if ($this->parent === null) {\n            $this->setParent(Asset::getById($this->getParentId()));\n        }\n\n        return $this->parent;\n    }\n\n    /**\n     * @param Asset $parent\n     *\n     * @return $this\n     */\n    public function setParent($parent)\n    {\n        $this->parent = $parent;\n        if ($parent instanceof Asset) {\n            $this->parentId = $parent->getId();\n        }\n\n        return $this;\n    }\n\n    /**\n     * @return string\n     */\n    public function getImageThumbnailSavePath()\n    {\n        $path = PIMCORE_TEMPORARY_DIRECTORY . '/image-thumbnails' . $this->getRealPath();\n        $path = rtrim($path, '/');\n\n        return $path;\n    }\n\n    /**\n     * @return string\n     */\n    public function getVideoThumbnailSavePath()\n    {\n        $path = PIMCORE_TEMPORARY_DIRECTORY . '/video-thumbnails' . $this->getRealPath();\n        $path = rtrim($path, '/');\n\n        return $path;\n    }\n\n    public function __sleep()\n    {\n        $finalVars = [];\n        $parentVars = parent::__sleep();\n\n        if (isset($this->_fulldump)) {\n            // this is if we want to make a full dump of the asset (eg. for a new version), including childs for recyclebin\n            $blockedVars = ['scheduledTasks', 'dependencies', 'userPermissions', 'hasChilds', 'versions', 'parent', 'stream'];\n            $finalVars[] = '_fulldump';\n            $this->removeInheritedProperties();\n        } else {\n            // this is if we want to cache the asset\n            $blockedVars = ['scheduledTasks', 'dependencies', 'userPermissions', 'hasChilds', 'versions', 'childs', 'properties', 'stream', 'parent'];\n        }\n\n        foreach ($parentVars as $key) {\n            if (!in_array($key, $blockedVars)) {\n                $finalVars[] = $key;\n            }\n        }\n\n        return $finalVars;\n    }\n\n    public function __wakeup()\n    {\n        if (isset($this->_fulldump)) {\n            // set current key and path this is necessary because the serialized data can have a different path than the original element (element was renamed or moved)\n            $originalElement = Asset::getById($this->getId());\n            if ($originalElement) {\n                $this->setFilename($originalElement->getFilename());\n                $this->setPath($originalElement->getRealPath());\n            }\n        }\n\n        if (isset($this->_fulldump) && $this->properties !== null) {\n            $this->renewInheritedProperties();\n        }\n\n        if (isset($this->_fulldump)) {\n            unset($this->_fulldump);\n        }\n    }\n\n    public function removeInheritedProperties()\n    {\n        $myProperties = $this->getProperties();\n\n        if ($myProperties) {\n            foreach ($this->getProperties() as $name => $property) {\n                if ($property->getInherited()) {\n                    unset($myProperties[$name]);\n                }\n            }\n        }\n\n        $this->setProperties($myProperties);\n    }\n\n    public function renewInheritedProperties()\n    {\n        $this->removeInheritedProperties();\n\n        // add to registry to avoid infinite regresses in the following $this->getDao()->getProperties()\n        $cacheKey = 'asset_' . $this->getId();\n        if (!\\Pimcore\\Cache\\Runtime::isRegistered($cacheKey)) {\n            \\Pimcore\\Cache\\Runtime::set($cacheKey, $this);\n        }\n\n        $myProperties = $this->getProperties();\n        $inheritedProperties = $this->getDao()->getProperties(true);\n        $this->setProperties(array_merge($inheritedProperties, $myProperties));\n    }\n\n    public function __destruct()\n    {\n\n        // close open streams\n        $this->closeStream();\n    }\n\n    /**\n     * @return int\n     */\n    public function getVersionCount(): int\n    {\n        return $this->versionCount ? $this->versionCount : 0;\n    }\n\n    /**\n     * @param int|null $versionCount\n     *\n     * @return Asset\n     */\n    public function setVersionCount(?int $versionCount): ElementInterface\n    {\n        $this->versionCount = (int) $versionCount;\n\n        return $this;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    public function resolveDependencies()\n    {\n        $dependencies = parent::resolveDependencies();\n\n        if ($this->hasMetaData) {\n            $metaData = $this->getMetadata();\n\n            foreach ($metaData as $md) {\n                if (isset($md['data']) && $md['data'] instanceof ElementInterface) {\n                    /**\n                     * @var $elementData ElementInterface\n                     */\n                    $elementData = $md['data'];\n                    $elementType = $md['type'];\n                    $key = $elementType . '_' . $elementData->getId();\n                    $dependencies[$key] = [\n                        'id' => $elementData->getId(),\n                        'type' => $elementType\n                    ];\n                }\n            }\n        }\n\n        return $dependencies;\n    }\n}\n"], "filenames": ["models/Asset.php"], "buggy_code_start_loc": [625], "buggy_code_end_loc": [625], "fixing_code_start_loc": [626], "fixing_code_end_loc": [630], "type": "CWE-434", "message": "In Pimcore before 5.7.1, an attacker with limited privileges can bypass file-extension restrictions via a 256-character filename, as demonstrated by the failure of automatic renaming of .php to .php.txt for long filenames, a different vulnerability than CVE-2019-10867 and CVE-2019-16317.", "other": {"cve": {"id": "CVE-2019-16318", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-14T18:15:11.260", "lastModified": "2019-09-17T13:09:33.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Pimcore before 5.7.1, an attacker with limited privileges can bypass file-extension restrictions via a 256-character filename, as demonstrated by the failure of automatic renaming of .php to .php.txt for long filenames, a different vulnerability than CVE-2019-10867 and CVE-2019-16317."}, {"lang": "es", "value": "En Pimcore versiones anteriores a 5.7.1, un atacante con privilegios limitados puede omitir las restricciones de extensi\u00f3n de archivo por medio de un nombre de archivo de 256 caracteres, como es demostrado por el fallo del renombramiento autom\u00e1tico de .php a .php.txt para nombres de archivo largos, una vulnerabilidad diferente de CVE -2019-10867 y CVE-2019-16317."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pimcore:pimcore:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.7.1", "matchCriteriaId": "543607DF-96CD-415B-BEED-DC71B4619632"}]}]}], "references": [{"url": "https://github.com/pimcore/pimcore/commit/732f1647cc6e0a29b5b1f5d904b4d726b5e9455f", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://snyk.io/vuln/SNYK-PHP-PIMCOREPIMCORE-451598", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pimcore/pimcore/commit/732f1647cc6e0a29b5b1f5d904b4d726b5e9455f"}}