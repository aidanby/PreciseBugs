{"buggy_code": ["/*\n *\tUDP over IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on linux/ipv4/udp.c\n *\n *\tFixes:\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tYOSHIFUJI Hideaki @USAGI and:\tSupport IPV6_V6ONLY socket option, which\n *\tAlexey Kuznetsov\t\tallow both IPv4 and IPv6 sockets to bind\n *\t\t\t\t\ta single port at the same time.\n *      Kazunori MIYAZAWA @USAGI:       change process style to use ip6_append_data\n *      YOSHIFUJI Hideaki @USAGI:\tconvert /proc/net/udp6 to seq_file.\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <asm/uaccess.h>\n\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/raw.h>\n#include <net/tcp_states.h>\n#include <net/ip6_checksum.h>\n#include <net/xfrm.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include \"udp_impl.h\"\n\nint ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2)\n{\n\tconst struct in6_addr *sk_rcv_saddr6 = &inet6_sk(sk)->rcv_saddr;\n\tconst struct in6_addr *sk2_rcv_saddr6 = inet6_rcv_saddr(sk2);\n\t__be32 sk1_rcv_saddr = sk_rcv_saddr(sk);\n\t__be32 sk2_rcv_saddr = sk_rcv_saddr(sk2);\n\tint sk_ipv6only = ipv6_only_sock(sk);\n\tint sk2_ipv6only = inet_v6_ipv6only(sk2);\n\tint addr_type = ipv6_addr_type(sk_rcv_saddr6);\n\tint addr_type2 = sk2_rcv_saddr6 ? ipv6_addr_type(sk2_rcv_saddr6) : IPV6_ADDR_MAPPED;\n\n\t/* if both are mapped, treat as IPv4 */\n\tif (addr_type == IPV6_ADDR_MAPPED && addr_type2 == IPV6_ADDR_MAPPED)\n\t\treturn (!sk2_ipv6only &&\n\t\t\t(!sk1_rcv_saddr || !sk2_rcv_saddr ||\n\t\t\t  sk1_rcv_saddr == sk2_rcv_saddr));\n\n\tif (addr_type2 == IPV6_ADDR_ANY &&\n\t    !(sk2_ipv6only && addr_type == IPV6_ADDR_MAPPED))\n\t\treturn 1;\n\n\tif (addr_type == IPV6_ADDR_ANY &&\n\t    !(sk_ipv6only && addr_type2 == IPV6_ADDR_MAPPED))\n\t\treturn 1;\n\n\tif (sk2_rcv_saddr6 &&\n\t    ipv6_addr_equal(sk_rcv_saddr6, sk2_rcv_saddr6))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic unsigned int udp6_portaddr_hash(struct net *net,\n\t\t\t\t       const struct in6_addr *addr6,\n\t\t\t\t       unsigned int port)\n{\n\tunsigned int hash, mix = net_hash_mix(net);\n\n\tif (ipv6_addr_any(addr6))\n\t\thash = jhash_1word(0, mix);\n\telse if (ipv6_addr_v4mapped(addr6))\n\t\thash = jhash_1word((__force u32)addr6->s6_addr32[3], mix);\n\telse\n\t\thash = jhash2((__force u32 *)addr6->s6_addr32, 4, mix);\n\n\treturn hash ^ port;\n}\n\n\nint udp_v6_get_port(struct sock *sk, unsigned short snum)\n{\n\tunsigned int hash2_nulladdr =\n\t\tudp6_portaddr_hash(sock_net(sk), &in6addr_any, snum);\n\tunsigned int hash2_partial = \n\t\tudp6_portaddr_hash(sock_net(sk), &inet6_sk(sk)->rcv_saddr, 0);\n\n\t/* precompute partial secondary hash */\n\tudp_sk(sk)->udp_portaddr_hash = hash2_partial;\n\treturn udp_lib_get_port(sk, snum, ipv6_rcv_saddr_equal, hash2_nulladdr);\n}\n\nstatic void udp_v6_rehash(struct sock *sk)\n{\n\tu16 new_hash = udp6_portaddr_hash(sock_net(sk),\n\t\t\t\t\t  &inet6_sk(sk)->rcv_saddr,\n\t\t\t\t\t  inet_sk(sk)->inet_num);\n\n\tudp_lib_rehash(sk, new_hash);\n}\n\nstatic inline int compute_score(struct sock *sk, struct net *net,\n\t\t\t\tunsigned short hnum,\n\t\t\t\tconst struct in6_addr *saddr, __be16 sport,\n\t\t\t\tconst struct in6_addr *daddr, __be16 dport,\n\t\t\t\tint dif)\n{\n\tint score = -1;\n\n\tif (net_eq(sock_net(sk), net) && udp_sk(sk)->udp_port_hash == hnum &&\n\t\t\tsk->sk_family == PF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\tscore = 0;\n\t\tif (inet->inet_dport) {\n\t\t\tif (inet->inet_dport != sport)\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t\tif (!ipv6_addr_any(&np->rcv_saddr)) {\n\t\t\tif (!ipv6_addr_equal(&np->rcv_saddr, daddr))\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t\tif (!ipv6_addr_any(&np->daddr)) {\n\t\t\tif (!ipv6_addr_equal(&np->daddr, saddr))\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t\tif (sk->sk_bound_dev_if) {\n\t\t\tif (sk->sk_bound_dev_if != dif)\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t}\n\treturn score;\n}\n\n#define SCORE2_MAX (1 + 1 + 1)\nstatic inline int compute_score2(struct sock *sk, struct net *net,\n\t\t\t\tconst struct in6_addr *saddr, __be16 sport,\n\t\t\t\tconst struct in6_addr *daddr, unsigned short hnum,\n\t\t\t\tint dif)\n{\n\tint score = -1;\n\n\tif (net_eq(sock_net(sk), net) && udp_sk(sk)->udp_port_hash == hnum &&\n\t\t\tsk->sk_family == PF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\tif (!ipv6_addr_equal(&np->rcv_saddr, daddr))\n\t\t\treturn -1;\n\t\tscore = 0;\n\t\tif (inet->inet_dport) {\n\t\t\tif (inet->inet_dport != sport)\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t\tif (!ipv6_addr_any(&np->daddr)) {\n\t\t\tif (!ipv6_addr_equal(&np->daddr, saddr))\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t\tif (sk->sk_bound_dev_if) {\n\t\t\tif (sk->sk_bound_dev_if != dif)\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t}\n\treturn score;\n}\n\n\n/* called with read_rcu_lock() */\nstatic struct sock *udp6_lib_lookup2(struct net *net,\n\t\tconst struct in6_addr *saddr, __be16 sport,\n\t\tconst struct in6_addr *daddr, unsigned int hnum, int dif,\n\t\tstruct udp_hslot *hslot2, unsigned int slot2)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tint score, badness;\n\nbegin:\n\tresult = NULL;\n\tbadness = -1;\n\tudp_portaddr_for_each_entry_rcu(sk, node, &hslot2->head) {\n\t\tscore = compute_score2(sk, net, saddr, sport,\n\t\t\t\t      daddr, hnum, dif);\n\t\tif (score > badness) {\n\t\t\tresult = sk;\n\t\t\tbadness = score;\n\t\t\tif (score == SCORE2_MAX)\n\t\t\t\tgoto exact_match;\n\t\t}\n\t}\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (get_nulls_value(node) != slot2)\n\t\tgoto begin;\n\n\tif (result) {\nexact_match:\n\t\tif (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(compute_score2(result, net, saddr, sport,\n\t\t\t\t  daddr, hnum, dif) < badness)) {\n\t\t\tsock_put(result);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic struct sock *__udp6_lib_lookup(struct net *net,\n\t\t\t\t      const struct in6_addr *saddr, __be16 sport,\n\t\t\t\t      const struct in6_addr *daddr, __be16 dport,\n\t\t\t\t      int dif, struct udp_table *udptable)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tunsigned short hnum = ntohs(dport);\n\tunsigned int hash2, slot2, slot = udp_hashfn(net, hnum, udptable->mask);\n\tstruct udp_hslot *hslot2, *hslot = &udptable->hash[slot];\n\tint score, badness;\n\n\trcu_read_lock();\n\tif (hslot->count > 10) {\n\t\thash2 = udp6_portaddr_hash(net, daddr, hnum);\n\t\tslot2 = hash2 & udptable->mask;\n\t\thslot2 = &udptable->hash2[slot2];\n\t\tif (hslot->count < hslot2->count)\n\t\t\tgoto begin;\n\n\t\tresult = udp6_lib_lookup2(net, saddr, sport,\n\t\t\t\t\t  daddr, hnum, dif,\n\t\t\t\t\t  hslot2, slot2);\n\t\tif (!result) {\n\t\t\thash2 = udp6_portaddr_hash(net, &in6addr_any, hnum);\n\t\t\tslot2 = hash2 & udptable->mask;\n\t\t\thslot2 = &udptable->hash2[slot2];\n\t\t\tif (hslot->count < hslot2->count)\n\t\t\t\tgoto begin;\n\n\t\t\tresult = udp6_lib_lookup2(net, saddr, sport,\n\t\t\t\t\t\t  &in6addr_any, hnum, dif,\n\t\t\t\t\t\t  hslot2, slot2);\n\t\t}\n\t\trcu_read_unlock();\n\t\treturn result;\n\t}\nbegin:\n\tresult = NULL;\n\tbadness = -1;\n\tsk_nulls_for_each_rcu(sk, node, &hslot->head) {\n\t\tscore = compute_score(sk, net, hnum, saddr, sport, daddr, dport, dif);\n\t\tif (score > badness) {\n\t\t\tresult = sk;\n\t\t\tbadness = score;\n\t\t}\n\t}\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (get_nulls_value(node) != slot)\n\t\tgoto begin;\n\n\tif (result) {\n\t\tif (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(compute_score(result, net, hnum, saddr, sport,\n\t\t\t\t\tdaddr, dport, dif) < badness)) {\n\t\t\tsock_put(result);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn result;\n}\n\nstatic struct sock *__udp6_lib_lookup_skb(struct sk_buff *skb,\n\t\t\t\t\t  __be16 sport, __be16 dport,\n\t\t\t\t\t  struct udp_table *udptable)\n{\n\tstruct sock *sk;\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\n\tif (unlikely(sk = skb_steal_sock(skb)))\n\t\treturn sk;\n\treturn __udp6_lib_lookup(dev_net(skb_dst(skb)->dev), &iph->saddr, sport,\n\t\t\t\t &iph->daddr, dport, inet6_iif(skb),\n\t\t\t\t udptable);\n}\n\nstruct sock *udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,\n\t\t\t     const struct in6_addr *daddr, __be16 dport, int dif)\n{\n\treturn __udp6_lib_lookup(net, saddr, sport, daddr, dport, dif, &udp_table);\n}\nEXPORT_SYMBOL_GPL(udp6_lib_lookup);\n\n\n/*\n * \tThis should be easy, if there is something there we\n * \treturn it, otherwise we block.\n */\n\nint udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t  struct msghdr *msg, size_t len,\n\t\t  int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned int ulen;\n\tint peeked;\n\tint err;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint is_udp4;\n\tbool slow;\n\n\tif (addr_len)\n\t\t*addr_len=sizeof(struct sockaddr_in6);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len);\n\ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tulen = skb->len - sizeof(struct udphdr);\n\tif (len > ulen)\n\t\tlen = ulen;\n\telse if (len < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\tis_udp4 = (skb->protocol == htons(ETH_P_IP));\n\n\t/*\n\t * If checksum is needed at all, try to do it while copying the\n\t * data.  If the data is truncated, or if we only want a partial\n\t * coverage checksum (UDP-Lite), do it before the copy.\n\t */\n\n\tif (len < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),\n\t\t\t\t\t      msg->msg_iov,len);\n\telse {\n\t\terr = skb_copy_and_csum_datagram_iovec(skb, sizeof(struct udphdr), msg->msg_iov);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (err)\n\t\tgoto out_free;\n\n\tif (!peeked) {\n\t\tif (is_udp4)\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\t\telse\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = (struct sockaddr_in6 *) msg->msg_name;\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = udp_hdr(skb)->source;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_scope_id = 0;\n\n\t\tif (is_udp4)\n\t\t\tipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\n\t\t\t\t\t       &sin6->sin6_addr);\n\t\telse {\n\t\t\tipv6_addr_copy(&sin6->sin6_addr,\n\t\t\t\t       &ipv6_hdr(skb)->saddr);\n\t\t\tif (ipv6_addr_type(&sin6->sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\t\tsin6->sin6_scope_id = IP6CB(skb)->iif;\n\t\t}\n\n\t}\n\tif (is_udp4) {\n\t\tif (inet->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\t} else {\n\t\tif (np->rxopt.all)\n\t\t\tdatagram_recv_ctl(sk, msg, skb);\n\t}\n\n\terr = len;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\n\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tif (is_udp4)\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INERRORS, is_udplite);\n\t\telse\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INERRORS, is_udplite);\n\t}\n\tunlock_sock_fast(sk, slow);\n\n\tif (flags & MSG_DONTWAIT)\n\t\treturn -EAGAIN;\n\tgoto try_again;\n}\n\nvoid __udp6_lib_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t    u8 type, u8 code, int offset, __be32 info,\n\t\t    struct udp_table *udptable)\n{\n\tstruct ipv6_pinfo *np;\n\tstruct ipv6hdr *hdr = (struct ipv6hdr*)skb->data;\n\tstruct in6_addr *saddr = &hdr->saddr;\n\tstruct in6_addr *daddr = &hdr->daddr;\n\tstruct udphdr *uh = (struct udphdr*)(skb->data+offset);\n\tstruct sock *sk;\n\tint err;\n\n\tsk = __udp6_lib_lookup(dev_net(skb->dev), daddr, uh->dest,\n\t\t\t       saddr, uh->source, inet6_iif(skb), udptable);\n\tif (sk == NULL)\n\t\treturn;\n\n\tnp = inet6_sk(sk);\n\n\tif (!icmpv6_err_convert(type, code, &err) && !np->recverr)\n\t\tgoto out;\n\n\tif (sk->sk_state != TCP_ESTABLISHED && !np->recverr)\n\t\tgoto out;\n\n\tif (np->recverr)\n\t\tipv6_icmp_error(sk, skb, err, uh->dest, ntohl(info), (u8 *)(uh+1));\n\n\tsk->sk_err = err;\n\tsk->sk_error_report(sk);\nout:\n\tsock_put(sk);\n}\n\nstatic __inline__ void udpv6_err(struct sk_buff *skb,\n\t\t\t\t struct inet6_skb_parm *opt, u8 type,\n\t\t\t\t u8 code, int offset, __be32 info     )\n{\n\t__udp6_lib_err(skb, opt, type, code, offset, info, &udp_table);\n}\n\nint udpv6_queue_rcv_skb(struct sock * sk, struct sk_buff *skb)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tint rc;\n\tint is_udplite = IS_UDPLITE(sk);\n\n\tif (!ipv6_addr_any(&inet6_sk(sk)->daddr))\n\t\tsock_rps_save_rxhash(sk, skb->rxhash);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto drop;\n\n\t/*\n\t * UDP-Lite specific tests, ignored on UDP sockets (see net/ipv4/udp.c).\n\t */\n\tif ((is_udplite & UDPLITE_RECV_CC)  &&  UDP_SKB_CB(skb)->partial_cov) {\n\n\t\tif (up->pcrlen == 0) {          /* full coverage was set  */\n\t\t\tLIMIT_NETDEBUG(KERN_WARNING \"UDPLITE6: partial coverage\"\n\t\t\t\t\" %d while full coverage %d requested\\n\",\n\t\t\t\tUDP_SKB_CB(skb)->cscov, skb->len);\n\t\t\tgoto drop;\n\t\t}\n\t\tif (UDP_SKB_CB(skb)->cscov  <  up->pcrlen) {\n\t\t\tLIMIT_NETDEBUG(KERN_WARNING \"UDPLITE6: coverage %d \"\n\t\t\t\t\t\t    \"too small, need min %d\\n\",\n\t\t\t\t       UDP_SKB_CB(skb)->cscov, up->pcrlen);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (rcu_dereference_raw(sk->sk_filter)) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto drop;\n\t}\n\n\tif ((rc = ip_queue_rcv_skb(sk, skb)) < 0) {\n\t\t/* Note that an ENOMEM error is charged twice */\n\t\tif (rc == -ENOMEM)\n\t\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\tUDP_MIB_RCVBUFERRORS, is_udplite);\n\t\tgoto drop_no_sk_drops_inc;\n\t}\n\n\treturn 0;\ndrop:\n\tatomic_inc(&sk->sk_drops);\ndrop_no_sk_drops_inc:\n\tUDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\nstatic struct sock *udp_v6_mcast_next(struct net *net, struct sock *sk,\n\t\t\t\t      __be16 loc_port, struct in6_addr *loc_addr,\n\t\t\t\t      __be16 rmt_port, struct in6_addr *rmt_addr,\n\t\t\t\t      int dif)\n{\n\tstruct hlist_nulls_node *node;\n\tstruct sock *s = sk;\n\tunsigned short num = ntohs(loc_port);\n\n\tsk_nulls_for_each_from(s, node) {\n\t\tstruct inet_sock *inet = inet_sk(s);\n\n\t\tif (!net_eq(sock_net(s), net))\n\t\t\tcontinue;\n\n\t\tif (udp_sk(s)->udp_port_hash == num &&\n\t\t    s->sk_family == PF_INET6) {\n\t\t\tstruct ipv6_pinfo *np = inet6_sk(s);\n\t\t\tif (inet->inet_dport) {\n\t\t\t\tif (inet->inet_dport != rmt_port)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!ipv6_addr_any(&np->daddr) &&\n\t\t\t    !ipv6_addr_equal(&np->daddr, rmt_addr))\n\t\t\t\tcontinue;\n\n\t\t\tif (s->sk_bound_dev_if && s->sk_bound_dev_if != dif)\n\t\t\t\tcontinue;\n\n\t\t\tif (!ipv6_addr_any(&np->rcv_saddr)) {\n\t\t\t\tif (!ipv6_addr_equal(&np->rcv_saddr, loc_addr))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!inet6_mc_check(s, loc_addr, rmt_addr))\n\t\t\t\tcontinue;\n\t\t\treturn s;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void flush_stack(struct sock **stack, unsigned int count,\n\t\t\tstruct sk_buff *skb, unsigned int final)\n{\n\tunsigned int i;\n\tstruct sock *sk;\n\tstruct sk_buff *skb1;\n\n\tfor (i = 0; i < count; i++) {\n\t\tskb1 = (i == final) ? skb : skb_clone(skb, GFP_ATOMIC);\n\n\t\tsk = stack[i];\n\t\tif (skb1) {\n\t\t\tif (sk_rcvqueues_full(sk, skb1)) {\n\t\t\t\tkfree_skb(skb1);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tbh_lock_sock(sk);\n\t\t\tif (!sock_owned_by_user(sk))\n\t\t\t\tudpv6_queue_rcv_skb(sk, skb1);\n\t\t\telse if (sk_add_backlog(sk, skb1)) {\n\t\t\t\tkfree_skb(skb1);\n\t\t\t\tbh_unlock_sock(sk);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\ndrop:\n\t\tatomic_inc(&sk->sk_drops);\n\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\tUDP_MIB_RCVBUFERRORS, IS_UDPLITE(sk));\n\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\tUDP_MIB_INERRORS, IS_UDPLITE(sk));\n\t}\n}\n/*\n * Note: called only from the BH handler context,\n * so we don't need to lock the hashes.\n */\nstatic int __udp6_lib_mcast_deliver(struct net *net, struct sk_buff *skb,\n\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\tstruct udp_table *udptable)\n{\n\tstruct sock *sk, *stack[256 / sizeof(struct sock *)];\n\tconst struct udphdr *uh = udp_hdr(skb);\n\tstruct udp_hslot *hslot = udp_hashslot(udptable, net, ntohs(uh->dest));\n\tint dif;\n\tunsigned int i, count = 0;\n\n\tspin_lock(&hslot->lock);\n\tsk = sk_nulls_head(&hslot->head);\n\tdif = inet6_iif(skb);\n\tsk = udp_v6_mcast_next(net, sk, uh->dest, daddr, uh->source, saddr, dif);\n\twhile (sk) {\n\t\tstack[count++] = sk;\n\t\tsk = udp_v6_mcast_next(net, sk_nulls_next(sk), uh->dest, daddr,\n\t\t\t\t       uh->source, saddr, dif);\n\t\tif (unlikely(count == ARRAY_SIZE(stack))) {\n\t\t\tif (!sk)\n\t\t\t\tbreak;\n\t\t\tflush_stack(stack, count, skb, ~0);\n\t\t\tcount = 0;\n\t\t}\n\t}\n\t/*\n\t * before releasing the lock, we must take reference on sockets\n\t */\n\tfor (i = 0; i < count; i++)\n\t\tsock_hold(stack[i]);\n\n\tspin_unlock(&hslot->lock);\n\n\tif (count) {\n\t\tflush_stack(stack, count, skb, count - 1);\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\tsock_put(stack[i]);\n\t} else {\n\t\tkfree_skb(skb);\n\t}\n\treturn 0;\n}\n\nstatic inline int udp6_csum_init(struct sk_buff *skb, struct udphdr *uh,\n\t\t\t\t int proto)\n{\n\tint err;\n\n\tUDP_SKB_CB(skb)->partial_cov = 0;\n\tUDP_SKB_CB(skb)->cscov = skb->len;\n\n\tif (proto == IPPROTO_UDPLITE) {\n\t\terr = udplite_checksum_init(skb, uh);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (uh->check == 0) {\n\t\t/* RFC 2460 section 8.1 says that we SHOULD log\n\t\t   this error. Well, it is reasonable.\n\t\t */\n\t\tLIMIT_NETDEBUG(KERN_INFO \"IPv6: udp checksum is 0\\n\");\n\t\treturn 1;\n\t}\n\tif (skb->ip_summed == CHECKSUM_COMPLETE &&\n\t    !csum_ipv6_magic(&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr,\n\t\t\t     skb->len, proto, skb->csum))\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tif (!skb_csum_unnecessary(skb))\n\t\tskb->csum = ~csum_unfold(csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\n\t\t\t\t\t\t\t &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t\t skb->len, proto, 0));\n\n\treturn 0;\n}\n\nint __udp6_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,\n\t\t   int proto)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tstruct udphdr *uh;\n\tstruct in6_addr *saddr, *daddr;\n\tu32 ulen = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\tgoto discard;\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\tuh = udp_hdr(skb);\n\n\tulen = ntohs(uh->len);\n\tif (ulen > skb->len)\n\t\tgoto short_packet;\n\n\tif (proto == IPPROTO_UDP) {\n\t\t/* UDP validates ulen. */\n\n\t\t/* Check for jumbo payload */\n\t\tif (ulen == 0)\n\t\t\tulen = skb->len;\n\n\t\tif (ulen < sizeof(*uh))\n\t\t\tgoto short_packet;\n\n\t\tif (ulen < skb->len) {\n\t\t\tif (pskb_trim_rcsum(skb, ulen))\n\t\t\t\tgoto short_packet;\n\t\t\tsaddr = &ipv6_hdr(skb)->saddr;\n\t\t\tdaddr = &ipv6_hdr(skb)->daddr;\n\t\t\tuh = udp_hdr(skb);\n\t\t}\n\t}\n\n\tif (udp6_csum_init(skb, uh, proto))\n\t\tgoto discard;\n\n\t/*\n\t *\tMulticast receive code\n\t */\n\tif (ipv6_addr_is_multicast(daddr))\n\t\treturn __udp6_lib_mcast_deliver(net, skb,\n\t\t\t\tsaddr, daddr, udptable);\n\n\t/* Unicast */\n\n\t/*\n\t * check socket cache ... must talk to Alan about his plans\n\t * for sock caches... i'll skip this for now.\n\t */\n\tsk = __udp6_lib_lookup_skb(skb, uh->source, uh->dest, udptable);\n\n\tif (sk == NULL) {\n\t\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\t\tgoto discard;\n\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto discard;\n\t\tUDP6_INC_STATS_BH(net, UDP_MIB_NOPORTS,\n\t\t\t\tproto == IPPROTO_UDPLITE);\n\n\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\t/* deliver */\n\n\tif (sk_rcvqueues_full(sk, skb)) {\n\t\tsock_put(sk);\n\t\tgoto discard;\n\t}\n\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk))\n\t\tudpv6_queue_rcv_skb(sk, skb);\n\telse if (sk_add_backlog(sk, skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tbh_unlock_sock(sk);\n\t\tsock_put(sk);\n\t\tgoto discard;\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n\nshort_packet:\n\tLIMIT_NETDEBUG(KERN_DEBUG \"UDP%sv6: short packet: From [%pI6c]:%u %d/%d to [%pI6c]:%u\\n\",\n\t\t       proto == IPPROTO_UDPLITE ? \"-Lite\" : \"\",\n\t\t       saddr,\n\t\t       ntohs(uh->source),\n\t\t       ulen,\n\t\t       skb->len,\n\t\t       daddr,\n\t\t       ntohs(uh->dest));\n\ndiscard:\n\tUDP6_INC_STATS_BH(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic __inline__ int udpv6_rcv(struct sk_buff *skb)\n{\n\treturn __udp6_lib_rcv(skb, &udp_table, IPPROTO_UDP);\n}\n\n/*\n * Throw away all pending data and cancel the corking. Socket is locked.\n */\nstatic void udp_v6_flush_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\n\tif (up->pending == AF_INET)\n\t\tudp_flush_pending_frames(sk);\n\telse if (up->pending) {\n\t\tup->len = 0;\n\t\tup->pending = 0;\n\t\tip6_flush_pending_frames(sk);\n\t}\n}\n\n/**\n * \tudp6_hwcsum_outgoing  -  handle outgoing HW checksumming\n * \t@sk: \tsocket we are sending on\n * \t@skb: \tsk_buff containing the filled-in UDP header\n * \t        (checksum field must be zeroed out)\n */\nstatic void udp6_hwcsum_outgoing(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t const struct in6_addr *saddr,\n\t\t\t\t const struct in6_addr *daddr, int len)\n{\n\tunsigned int offset;\n\tstruct udphdr *uh = udp_hdr(skb);\n\t__wsum csum = 0;\n\n\tif (skb_queue_len(&sk->sk_write_queue) == 1) {\n\t\t/* Only one fragment on the socket.  */\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct udphdr, check);\n\t\tuh->check = ~csum_ipv6_magic(saddr, daddr, len, IPPROTO_UDP, 0);\n\t} else {\n\t\t/*\n\t\t * HW-checksum won't work as there are two or more\n\t\t * fragments on the socket so that all csums of sk_buffs\n\t\t * should be together\n\t\t */\n\t\toffset = skb_transport_offset(skb);\n\t\tskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\tskb_queue_walk(&sk->sk_write_queue, skb) {\n\t\t\tcsum = csum_add(csum, skb->csum);\n\t\t}\n\n\t\tuh->check = csum_ipv6_magic(saddr, daddr, len, IPPROTO_UDP,\n\t\t\t\t\t    csum);\n\t\tif (uh->check == 0)\n\t\t\tuh->check = CSUM_MANGLED_0;\n\t}\n}\n\n/*\n *\tSending\n */\n\nstatic int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct udphdr *uh;\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\t__wsum csum = 0;\n\n\t/* Grab the skbuff where UDP header space exists. */\n\tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n\t\tgoto out;\n\n\t/*\n\t * Create a UDP header\n\t */\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\n\tif (is_udplite)\n\t\tcsum = udplite_csum_outgoing(sk, skb);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */\n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,\n\t\t\t\t     up->len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum_outgoing(sk, skb);\n\n\t/* add protocol-dependent pseudo-header */\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    up->len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\n\nsend:\n\terr = ip6_push_pending_frames(sk);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}\n\nint udpv6_sendmsg(struct kiocb *iocb, struct sock *sk,\n\t\t  struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) msg->msg_name;\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint err;\n\tint connected = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint (*getfrag)(void *, char *, int, int, int, struct sk_buff *);\n\n\t/* destination address check */\n\tif (sin6) {\n\t\tif (addr_len < offsetof(struct sockaddr, sa_data))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sin6->sin6_family) {\n\t\tcase AF_INET6:\n\t\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\tdaddr = &sin6->sin6_addr;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\tgoto do_udp_sendmsg;\n\t\tcase AF_UNSPEC:\n\t\t\tmsg->msg_name = sin6 = NULL;\n\t\t\tmsg->msg_namelen = addr_len = 0;\n\t\t\tdaddr = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!up->pending) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = &np->daddr;\n\t} else\n\t\tdaddr = NULL;\n\n\tif (daddr) {\n\t\tif (ipv6_addr_v4mapped(daddr)) {\n\t\t\tstruct sockaddr_in sin;\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = sin6 ? sin6->sin6_port : inet->inet_dport;\n\t\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\t\tmsg->msg_name = &sin;\n\t\t\tmsg->msg_namelen = sizeof(sin);\ndo_udp_sendmsg:\n\t\t\tif (__ipv6_only_sock(sk))\n\t\t\t\treturn -ENETUNREACH;\n\t\t\treturn udp_sendmsg(iocb, sk, msg, len);\n\t\t}\n\t}\n\n\tif (up->pending == AF_INET)\n\t\treturn udp_sendmsg(iocb, sk, msg, len);\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_append_data().\n\t   */\n\tif (len > INT_MAX - sizeof(struct udphdr))\n\t\treturn -EMSGSIZE;\n\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET6)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t\t}\n\t\t\tdst = NULL;\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (sin6) {\n\t\tif (sin6->sin6_port == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfl6.fl6_dport = sin6->sin6_port;\n\t\tdaddr = &sin6->sin6_addr;\n\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (flowlabel == NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdaddr = &flowlabel->dst;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &np->daddr))\n\t\t\tdaddr = &np->daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    ipv6_addr_type(daddr)&IPV6_ADDR_LINKLOCAL)\n\t\t\tfl6.flowi6_oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tdaddr = &np->daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tconnected = 1;\n\t}\n\n\tif (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;\n\n\tfl6.flowi6_mark = sk->sk_mark;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(*opt);\n\n\t\terr = datagram_send_ctl(sock_net(sk), msg, &fl6, opt, &hlimit,\n\t\t\t\t\t&tclass, &dontfrag);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (opt == NULL)\n\t\topt = np->opt;\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tipv6_addr_copy(&fl6.daddr, daddr);\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tipv6_addr_copy(&fl6.saddr, &np->saddr);\n\tfl6.fl6_sport = inet->inet_sport;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\tif (final_p)\n\t\tconnected = 0;\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr)) {\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\t\tconnected = 0;\n\t}\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_sk_dst_lookup_flow(sk, &fl6, final_p, true);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto out;\n\t}\n\n\tif (hlimit < 0) {\n\t\tif (ipv6_addr_is_multicast(&fl6.daddr))\n\t\t\thlimit = np->mcast_hops;\n\t\telse\n\t\t\thlimit = np->hop_limit;\n\t\tif (hlimit < 0)\n\t\t\thlimit = ip6_dst_hoplimit(dst);\n\t}\n\n\tif (tclass < 0)\n\t\ttclass = np->tclass;\n\n\tif (dontfrag < 0)\n\t\tdontfrag = np->dontfrag;\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tup->pending = AF_INET6;\n\ndo_append_data:\n\tup->len += ulen;\n\tgetfrag  =  is_udplite ?  udplite_getfrag : ip_generic_getfrag;\n\terr = ip6_append_data(sk, getfrag, msg->msg_iov, ulen,\n\t\tsizeof(struct udphdr), hlimit, tclass, opt, &fl6,\n\t\t(struct rt6_info*)dst,\n\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags, dontfrag);\n\tif (err)\n\t\tudp_v6_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_v6_push_pending_frames(sk);\n\telse if (unlikely(skb_queue_empty(&sk->sk_write_queue)))\n\t\tup->pending = 0;\n\n\tif (dst) {\n\t\tif (connected) {\n\t\t\tip6_dst_store(sk, dst,\n\t\t\t\t      ipv6_addr_equal(&fl6.daddr, &np->daddr) ?\n\t\t\t\t      &np->daddr : NULL,\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\t\t      ipv6_addr_equal(&fl6.saddr, &np->saddr) ?\n\t\t\t\t      &np->saddr :\n#endif\n\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t}\n\t\tdst = NULL;\n\t}\n\n\tif (err > 0)\n\t\terr = np->recverr ? net_xmit_errno(err) : 0;\n\trelease_sock(sk);\nout:\n\tdst_release(dst);\n\tfl6_sock_release(flowlabel);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_SNDBUFERRORS, is_udplite);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}\n\nvoid udpv6_destroy_sock(struct sock *sk)\n{\n\tlock_sock(sk);\n\tudp_v6_flush_pending_frames(sk);\n\trelease_sock(sk);\n\n\tinet6_destroy_sock(sk);\n}\n\n/*\n *\tSocket option code for UDP\n */\nint udpv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t     char __user *optval, unsigned int optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_setsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t\t  udp_v6_push_pending_frames);\n\treturn ipv6_setsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nint compat_udpv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, unsigned int optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_setsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t\t  udp_v6_push_pending_frames);\n\treturn compat_ipv6_setsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nint udpv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t     char __user *optval, int __user *optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_getsockopt(sk, level, optname, optval, optlen);\n\treturn ipv6_getsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nint compat_udpv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_getsockopt(sk, level, optname, optval, optlen);\n\treturn compat_ipv6_getsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nstatic int udp6_ufo_send_check(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *ipv6h;\n\tstruct udphdr *uh;\n\n\tif (!pskb_may_pull(skb, sizeof(*uh)))\n\t\treturn -EINVAL;\n\n\tipv6h = ipv6_hdr(skb);\n\tuh = udp_hdr(skb);\n\n\tuh->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr, skb->len,\n\t\t\t\t     IPPROTO_UDP, 0);\n\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\tskb->csum_offset = offsetof(struct udphdr, check);\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\treturn 0;\n}\n\nstatic struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, u32 features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *mac_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t/* Packet is from an untrusted source, reset gso_segs. */\n\t\tint type = skb_shinfo(skb)->gso_type;\n\n\t\tif (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t * do checksum of UDP packets sent as multiple IP fragments.\n\t */\n\toffset = skb->csum_start - skb_headroom(skb);\n\tcsum = skb_checksum(skb, offset, skb->len- offset, 0);\n\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t/* Check if there is enough headroom to insert fragment header. */\n\tif ((skb_headroom(skb) < frag_hdr_sz) &&\n\t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n\t\tgoto out;\n\n\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t * bytes to insert fragment header.\n\t */\n\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\tunfrag_len = skb_network_header(skb) - skb_mac_header(skb) +\n\t\t     unfrag_ip6hlen;\n\tmac_start = skb_mac_header(skb);\n\tmemmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);\n\n\tskb->mac_header -= frag_hdr_sz;\n\tskb->network_header -= frag_hdr_sz;\n\n\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\tfptr->nexthdr = nexthdr;\n\tfptr->reserved = 0;\n\tipv6_select_ident(fptr);\n\n\t/* Fragment the skb. ipv6 header and the remaining fields of the\n\t * fragment header are updated in ipv6_gso_segment()\n\t */\n\tsegs = skb_segment(skb, features);\n\nout:\n\treturn segs;\n}\n\nstatic const struct inet6_protocol udpv6_protocol = {\n\t.handler\t=\tudpv6_rcv,\n\t.err_handler\t=\tudpv6_err,\n\t.gso_send_check =\tudp6_ufo_send_check,\n\t.gso_segment\t=\tudp6_ufo_fragment,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\n/* ------------------------------------------------------------------------ */\n#ifdef CONFIG_PROC_FS\n\nstatic void udp6_sock_seq_show(struct seq_file *seq, struct sock *sp, int bucket)\n{\n\tstruct inet_sock *inet = inet_sk(sp);\n\tstruct ipv6_pinfo *np = inet6_sk(sp);\n\tstruct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\n\tdest  = &np->daddr;\n\tsrc   = &np->rcv_saddr;\n\tdestp = ntohs(inet->inet_dport);\n\tsrcp  = ntohs(inet->inet_sport);\n\tseq_printf(seq,\n\t\t   \"%5d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %lu %d %p %d\\n\",\n\t\t   bucket,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   sp->sk_state,\n\t\t   sk_wmem_alloc_get(sp),\n\t\t   sk_rmem_alloc_get(sp),\n\t\t   0, 0L, 0,\n\t\t   sock_i_uid(sp), 0,\n\t\t   sock_i_ino(sp),\n\t\t   atomic_read(&sp->sk_refcnt), sp,\n\t\t   atomic_read(&sp->sk_drops));\n}\n\nint udp6_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq,\n\t\t\t   \"  sl  \"\n\t\t\t   \"local_address                         \"\n\t\t\t   \"remote_address                        \"\n\t\t\t   \"st tx_queue rx_queue tr tm->when retrnsmt\"\n\t\t\t   \"   uid  timeout inode ref pointer drops\\n\");\n\telse\n\t\tudp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);\n\treturn 0;\n}\n\nstatic struct udp_seq_afinfo udp6_seq_afinfo = {\n\t.name\t\t= \"udp6\",\n\t.family\t\t= AF_INET6,\n\t.udp_table\t= &udp_table,\n\t.seq_fops\t= {\n\t\t.owner\t=\tTHIS_MODULE,\n\t},\n\t.seq_ops\t= {\n\t\t.show\t\t= udp6_seq_show,\n\t},\n};\n\nint __net_init udp6_proc_init(struct net *net)\n{\n\treturn udp_proc_register(net, &udp6_seq_afinfo);\n}\n\nvoid udp6_proc_exit(struct net *net) {\n\tudp_proc_unregister(net, &udp6_seq_afinfo);\n}\n#endif /* CONFIG_PROC_FS */\n\n/* ------------------------------------------------------------------------ */\n\nstruct proto udpv6_prot = {\n\t.name\t\t   = \"UDPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = udp_lib_close,\n\t.connect\t   = ip6_datagram_connect,\n\t.disconnect\t   = udp_disconnect,\n\t.ioctl\t\t   = udp_ioctl,\n\t.destroy\t   = udpv6_destroy_sock,\n\t.setsockopt\t   = udpv6_setsockopt,\n\t.getsockopt\t   = udpv6_getsockopt,\n\t.sendmsg\t   = udpv6_sendmsg,\n\t.recvmsg\t   = udpv6_recvmsg,\n\t.backlog_rcv\t   = udpv6_queue_rcv_skb,\n\t.hash\t\t   = udp_lib_hash,\n\t.unhash\t\t   = udp_lib_unhash,\n\t.rehash\t\t   = udp_v6_rehash,\n\t.get_port\t   = udp_v6_get_port,\n\t.memory_allocated  = &udp_memory_allocated,\n\t.sysctl_mem\t   = sysctl_udp_mem,\n\t.sysctl_wmem\t   = &sysctl_udp_wmem_min,\n\t.sysctl_rmem\t   = &sysctl_udp_rmem_min,\n\t.obj_size\t   = sizeof(struct udp6_sock),\n\t.slab_flags\t   = SLAB_DESTROY_BY_RCU,\n\t.h.udp_table\t   = &udp_table,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_udpv6_setsockopt,\n\t.compat_getsockopt = compat_udpv6_getsockopt,\n#endif\n\t.clear_sk\t   = sk_prot_clear_portaddr_nulls,\n};\n\nstatic struct inet_protosw udpv6_protosw = {\n\t.type =      SOCK_DGRAM,\n\t.protocol =  IPPROTO_UDP,\n\t.prot =      &udpv6_prot,\n\t.ops =       &inet6_dgram_ops,\n\t.no_check =  UDP_CSUM_DEFAULT,\n\t.flags =     INET_PROTOSW_PERMANENT,\n};\n\n\nint __init udpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&udpv6_protocol, IPPROTO_UDP);\n\tif (ret)\n\t\tgoto out;\n\n\tret = inet6_register_protosw(&udpv6_protosw);\n\tif (ret)\n\t\tgoto out_udpv6_protocol;\nout:\n\treturn ret;\n\nout_udpv6_protocol:\n\tinet6_del_protocol(&udpv6_protocol, IPPROTO_UDP);\n\tgoto out;\n}\n\nvoid udpv6_exit(void)\n{\n\tinet6_unregister_protosw(&udpv6_protosw);\n\tinet6_del_protocol(&udpv6_protocol, IPPROTO_UDP);\n}\n"], "fixing_code": ["/*\n *\tUDP over IPv6\n *\tLinux INET6 implementation\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n *\n *\tBased on linux/ipv4/udp.c\n *\n *\tFixes:\n *\tHideaki YOSHIFUJI\t:\tsin6_scope_id support\n *\tYOSHIFUJI Hideaki @USAGI and:\tSupport IPV6_V6ONLY socket option, which\n *\tAlexey Kuznetsov\t\tallow both IPv4 and IPv6 sockets to bind\n *\t\t\t\t\ta single port at the same time.\n *      Kazunori MIYAZAWA @USAGI:       change process style to use ip6_append_data\n *      YOSHIFUJI Hideaki @USAGI:\tconvert /proc/net/udp6 to seq_file.\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/in6.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/ipv6.h>\n#include <linux/icmpv6.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <asm/uaccess.h>\n\n#include <net/ndisc.h>\n#include <net/protocol.h>\n#include <net/transp_v6.h>\n#include <net/ip6_route.h>\n#include <net/raw.h>\n#include <net/tcp_states.h>\n#include <net/ip6_checksum.h>\n#include <net/xfrm.h>\n\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include \"udp_impl.h\"\n\nint ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2)\n{\n\tconst struct in6_addr *sk_rcv_saddr6 = &inet6_sk(sk)->rcv_saddr;\n\tconst struct in6_addr *sk2_rcv_saddr6 = inet6_rcv_saddr(sk2);\n\t__be32 sk1_rcv_saddr = sk_rcv_saddr(sk);\n\t__be32 sk2_rcv_saddr = sk_rcv_saddr(sk2);\n\tint sk_ipv6only = ipv6_only_sock(sk);\n\tint sk2_ipv6only = inet_v6_ipv6only(sk2);\n\tint addr_type = ipv6_addr_type(sk_rcv_saddr6);\n\tint addr_type2 = sk2_rcv_saddr6 ? ipv6_addr_type(sk2_rcv_saddr6) : IPV6_ADDR_MAPPED;\n\n\t/* if both are mapped, treat as IPv4 */\n\tif (addr_type == IPV6_ADDR_MAPPED && addr_type2 == IPV6_ADDR_MAPPED)\n\t\treturn (!sk2_ipv6only &&\n\t\t\t(!sk1_rcv_saddr || !sk2_rcv_saddr ||\n\t\t\t  sk1_rcv_saddr == sk2_rcv_saddr));\n\n\tif (addr_type2 == IPV6_ADDR_ANY &&\n\t    !(sk2_ipv6only && addr_type == IPV6_ADDR_MAPPED))\n\t\treturn 1;\n\n\tif (addr_type == IPV6_ADDR_ANY &&\n\t    !(sk_ipv6only && addr_type2 == IPV6_ADDR_MAPPED))\n\t\treturn 1;\n\n\tif (sk2_rcv_saddr6 &&\n\t    ipv6_addr_equal(sk_rcv_saddr6, sk2_rcv_saddr6))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic unsigned int udp6_portaddr_hash(struct net *net,\n\t\t\t\t       const struct in6_addr *addr6,\n\t\t\t\t       unsigned int port)\n{\n\tunsigned int hash, mix = net_hash_mix(net);\n\n\tif (ipv6_addr_any(addr6))\n\t\thash = jhash_1word(0, mix);\n\telse if (ipv6_addr_v4mapped(addr6))\n\t\thash = jhash_1word((__force u32)addr6->s6_addr32[3], mix);\n\telse\n\t\thash = jhash2((__force u32 *)addr6->s6_addr32, 4, mix);\n\n\treturn hash ^ port;\n}\n\n\nint udp_v6_get_port(struct sock *sk, unsigned short snum)\n{\n\tunsigned int hash2_nulladdr =\n\t\tudp6_portaddr_hash(sock_net(sk), &in6addr_any, snum);\n\tunsigned int hash2_partial = \n\t\tudp6_portaddr_hash(sock_net(sk), &inet6_sk(sk)->rcv_saddr, 0);\n\n\t/* precompute partial secondary hash */\n\tudp_sk(sk)->udp_portaddr_hash = hash2_partial;\n\treturn udp_lib_get_port(sk, snum, ipv6_rcv_saddr_equal, hash2_nulladdr);\n}\n\nstatic void udp_v6_rehash(struct sock *sk)\n{\n\tu16 new_hash = udp6_portaddr_hash(sock_net(sk),\n\t\t\t\t\t  &inet6_sk(sk)->rcv_saddr,\n\t\t\t\t\t  inet_sk(sk)->inet_num);\n\n\tudp_lib_rehash(sk, new_hash);\n}\n\nstatic inline int compute_score(struct sock *sk, struct net *net,\n\t\t\t\tunsigned short hnum,\n\t\t\t\tconst struct in6_addr *saddr, __be16 sport,\n\t\t\t\tconst struct in6_addr *daddr, __be16 dport,\n\t\t\t\tint dif)\n{\n\tint score = -1;\n\n\tif (net_eq(sock_net(sk), net) && udp_sk(sk)->udp_port_hash == hnum &&\n\t\t\tsk->sk_family == PF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\tscore = 0;\n\t\tif (inet->inet_dport) {\n\t\t\tif (inet->inet_dport != sport)\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t\tif (!ipv6_addr_any(&np->rcv_saddr)) {\n\t\t\tif (!ipv6_addr_equal(&np->rcv_saddr, daddr))\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t\tif (!ipv6_addr_any(&np->daddr)) {\n\t\t\tif (!ipv6_addr_equal(&np->daddr, saddr))\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t\tif (sk->sk_bound_dev_if) {\n\t\t\tif (sk->sk_bound_dev_if != dif)\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t}\n\treturn score;\n}\n\n#define SCORE2_MAX (1 + 1 + 1)\nstatic inline int compute_score2(struct sock *sk, struct net *net,\n\t\t\t\tconst struct in6_addr *saddr, __be16 sport,\n\t\t\t\tconst struct in6_addr *daddr, unsigned short hnum,\n\t\t\t\tint dif)\n{\n\tint score = -1;\n\n\tif (net_eq(sock_net(sk), net) && udp_sk(sk)->udp_port_hash == hnum &&\n\t\t\tsk->sk_family == PF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\tif (!ipv6_addr_equal(&np->rcv_saddr, daddr))\n\t\t\treturn -1;\n\t\tscore = 0;\n\t\tif (inet->inet_dport) {\n\t\t\tif (inet->inet_dport != sport)\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t\tif (!ipv6_addr_any(&np->daddr)) {\n\t\t\tif (!ipv6_addr_equal(&np->daddr, saddr))\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t\tif (sk->sk_bound_dev_if) {\n\t\t\tif (sk->sk_bound_dev_if != dif)\n\t\t\t\treturn -1;\n\t\t\tscore++;\n\t\t}\n\t}\n\treturn score;\n}\n\n\n/* called with read_rcu_lock() */\nstatic struct sock *udp6_lib_lookup2(struct net *net,\n\t\tconst struct in6_addr *saddr, __be16 sport,\n\t\tconst struct in6_addr *daddr, unsigned int hnum, int dif,\n\t\tstruct udp_hslot *hslot2, unsigned int slot2)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tint score, badness;\n\nbegin:\n\tresult = NULL;\n\tbadness = -1;\n\tudp_portaddr_for_each_entry_rcu(sk, node, &hslot2->head) {\n\t\tscore = compute_score2(sk, net, saddr, sport,\n\t\t\t\t      daddr, hnum, dif);\n\t\tif (score > badness) {\n\t\t\tresult = sk;\n\t\t\tbadness = score;\n\t\t\tif (score == SCORE2_MAX)\n\t\t\t\tgoto exact_match;\n\t\t}\n\t}\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (get_nulls_value(node) != slot2)\n\t\tgoto begin;\n\n\tif (result) {\nexact_match:\n\t\tif (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(compute_score2(result, net, saddr, sport,\n\t\t\t\t  daddr, hnum, dif) < badness)) {\n\t\t\tsock_put(result);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic struct sock *__udp6_lib_lookup(struct net *net,\n\t\t\t\t      const struct in6_addr *saddr, __be16 sport,\n\t\t\t\t      const struct in6_addr *daddr, __be16 dport,\n\t\t\t\t      int dif, struct udp_table *udptable)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tunsigned short hnum = ntohs(dport);\n\tunsigned int hash2, slot2, slot = udp_hashfn(net, hnum, udptable->mask);\n\tstruct udp_hslot *hslot2, *hslot = &udptable->hash[slot];\n\tint score, badness;\n\n\trcu_read_lock();\n\tif (hslot->count > 10) {\n\t\thash2 = udp6_portaddr_hash(net, daddr, hnum);\n\t\tslot2 = hash2 & udptable->mask;\n\t\thslot2 = &udptable->hash2[slot2];\n\t\tif (hslot->count < hslot2->count)\n\t\t\tgoto begin;\n\n\t\tresult = udp6_lib_lookup2(net, saddr, sport,\n\t\t\t\t\t  daddr, hnum, dif,\n\t\t\t\t\t  hslot2, slot2);\n\t\tif (!result) {\n\t\t\thash2 = udp6_portaddr_hash(net, &in6addr_any, hnum);\n\t\t\tslot2 = hash2 & udptable->mask;\n\t\t\thslot2 = &udptable->hash2[slot2];\n\t\t\tif (hslot->count < hslot2->count)\n\t\t\t\tgoto begin;\n\n\t\t\tresult = udp6_lib_lookup2(net, saddr, sport,\n\t\t\t\t\t\t  &in6addr_any, hnum, dif,\n\t\t\t\t\t\t  hslot2, slot2);\n\t\t}\n\t\trcu_read_unlock();\n\t\treturn result;\n\t}\nbegin:\n\tresult = NULL;\n\tbadness = -1;\n\tsk_nulls_for_each_rcu(sk, node, &hslot->head) {\n\t\tscore = compute_score(sk, net, hnum, saddr, sport, daddr, dport, dif);\n\t\tif (score > badness) {\n\t\t\tresult = sk;\n\t\t\tbadness = score;\n\t\t}\n\t}\n\t/*\n\t * if the nulls value we got at the end of this lookup is\n\t * not the expected one, we must restart lookup.\n\t * We probably met an item that was moved to another chain.\n\t */\n\tif (get_nulls_value(node) != slot)\n\t\tgoto begin;\n\n\tif (result) {\n\t\tif (unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(compute_score(result, net, hnum, saddr, sport,\n\t\t\t\t\tdaddr, dport, dif) < badness)) {\n\t\t\tsock_put(result);\n\t\t\tgoto begin;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn result;\n}\n\nstatic struct sock *__udp6_lib_lookup_skb(struct sk_buff *skb,\n\t\t\t\t\t  __be16 sport, __be16 dport,\n\t\t\t\t\t  struct udp_table *udptable)\n{\n\tstruct sock *sk;\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\n\tif (unlikely(sk = skb_steal_sock(skb)))\n\t\treturn sk;\n\treturn __udp6_lib_lookup(dev_net(skb_dst(skb)->dev), &iph->saddr, sport,\n\t\t\t\t &iph->daddr, dport, inet6_iif(skb),\n\t\t\t\t udptable);\n}\n\nstruct sock *udp6_lib_lookup(struct net *net, const struct in6_addr *saddr, __be16 sport,\n\t\t\t     const struct in6_addr *daddr, __be16 dport, int dif)\n{\n\treturn __udp6_lib_lookup(net, saddr, sport, daddr, dport, dif, &udp_table);\n}\nEXPORT_SYMBOL_GPL(udp6_lib_lookup);\n\n\n/*\n * \tThis should be easy, if there is something there we\n * \treturn it, otherwise we block.\n */\n\nint udpv6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t  struct msghdr *msg, size_t len,\n\t\t  int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned int ulen;\n\tint peeked;\n\tint err;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint is_udp4;\n\tbool slow;\n\n\tif (addr_len)\n\t\t*addr_len=sizeof(struct sockaddr_in6);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len);\n\ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tulen = skb->len - sizeof(struct udphdr);\n\tif (len > ulen)\n\t\tlen = ulen;\n\telse if (len < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\tis_udp4 = (skb->protocol == htons(ETH_P_IP));\n\n\t/*\n\t * If checksum is needed at all, try to do it while copying the\n\t * data.  If the data is truncated, or if we only want a partial\n\t * coverage checksum (UDP-Lite), do it before the copy.\n\t */\n\n\tif (len < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t}\n\n\tif (skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),\n\t\t\t\t\t      msg->msg_iov,len);\n\telse {\n\t\terr = skb_copy_and_csum_datagram_iovec(skb, sizeof(struct udphdr), msg->msg_iov);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (err)\n\t\tgoto out_free;\n\n\tif (!peeked) {\n\t\tif (is_udp4)\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\t\telse\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_in6 *sin6;\n\n\t\tsin6 = (struct sockaddr_in6 *) msg->msg_name;\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = udp_hdr(skb)->source;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_scope_id = 0;\n\n\t\tif (is_udp4)\n\t\t\tipv6_addr_set_v4mapped(ip_hdr(skb)->saddr,\n\t\t\t\t\t       &sin6->sin6_addr);\n\t\telse {\n\t\t\tipv6_addr_copy(&sin6->sin6_addr,\n\t\t\t\t       &ipv6_hdr(skb)->saddr);\n\t\t\tif (ipv6_addr_type(&sin6->sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\t\tsin6->sin6_scope_id = IP6CB(skb)->iif;\n\t\t}\n\n\t}\n\tif (is_udp4) {\n\t\tif (inet->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\t} else {\n\t\tif (np->rxopt.all)\n\t\t\tdatagram_recv_ctl(sk, msg, skb);\n\t}\n\n\terr = len;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\n\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\n\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tif (is_udp4)\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INERRORS, is_udplite);\n\t\telse\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\tUDP_MIB_INERRORS, is_udplite);\n\t}\n\tunlock_sock_fast(sk, slow);\n\n\tif (flags & MSG_DONTWAIT)\n\t\treturn -EAGAIN;\n\tgoto try_again;\n}\n\nvoid __udp6_lib_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n\t\t    u8 type, u8 code, int offset, __be32 info,\n\t\t    struct udp_table *udptable)\n{\n\tstruct ipv6_pinfo *np;\n\tstruct ipv6hdr *hdr = (struct ipv6hdr*)skb->data;\n\tstruct in6_addr *saddr = &hdr->saddr;\n\tstruct in6_addr *daddr = &hdr->daddr;\n\tstruct udphdr *uh = (struct udphdr*)(skb->data+offset);\n\tstruct sock *sk;\n\tint err;\n\n\tsk = __udp6_lib_lookup(dev_net(skb->dev), daddr, uh->dest,\n\t\t\t       saddr, uh->source, inet6_iif(skb), udptable);\n\tif (sk == NULL)\n\t\treturn;\n\n\tnp = inet6_sk(sk);\n\n\tif (!icmpv6_err_convert(type, code, &err) && !np->recverr)\n\t\tgoto out;\n\n\tif (sk->sk_state != TCP_ESTABLISHED && !np->recverr)\n\t\tgoto out;\n\n\tif (np->recverr)\n\t\tipv6_icmp_error(sk, skb, err, uh->dest, ntohl(info), (u8 *)(uh+1));\n\n\tsk->sk_err = err;\n\tsk->sk_error_report(sk);\nout:\n\tsock_put(sk);\n}\n\nstatic __inline__ void udpv6_err(struct sk_buff *skb,\n\t\t\t\t struct inet6_skb_parm *opt, u8 type,\n\t\t\t\t u8 code, int offset, __be32 info     )\n{\n\t__udp6_lib_err(skb, opt, type, code, offset, info, &udp_table);\n}\n\nint udpv6_queue_rcv_skb(struct sock * sk, struct sk_buff *skb)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\tint rc;\n\tint is_udplite = IS_UDPLITE(sk);\n\n\tif (!ipv6_addr_any(&inet6_sk(sk)->daddr))\n\t\tsock_rps_save_rxhash(sk, skb->rxhash);\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto drop;\n\n\t/*\n\t * UDP-Lite specific tests, ignored on UDP sockets (see net/ipv4/udp.c).\n\t */\n\tif ((is_udplite & UDPLITE_RECV_CC)  &&  UDP_SKB_CB(skb)->partial_cov) {\n\n\t\tif (up->pcrlen == 0) {          /* full coverage was set  */\n\t\t\tLIMIT_NETDEBUG(KERN_WARNING \"UDPLITE6: partial coverage\"\n\t\t\t\t\" %d while full coverage %d requested\\n\",\n\t\t\t\tUDP_SKB_CB(skb)->cscov, skb->len);\n\t\t\tgoto drop;\n\t\t}\n\t\tif (UDP_SKB_CB(skb)->cscov  <  up->pcrlen) {\n\t\t\tLIMIT_NETDEBUG(KERN_WARNING \"UDPLITE6: coverage %d \"\n\t\t\t\t\t\t    \"too small, need min %d\\n\",\n\t\t\t\t       UDP_SKB_CB(skb)->cscov, up->pcrlen);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (rcu_dereference_raw(sk->sk_filter)) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto drop;\n\t}\n\n\tif ((rc = ip_queue_rcv_skb(sk, skb)) < 0) {\n\t\t/* Note that an ENOMEM error is charged twice */\n\t\tif (rc == -ENOMEM)\n\t\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\tUDP_MIB_RCVBUFERRORS, is_udplite);\n\t\tgoto drop_no_sk_drops_inc;\n\t}\n\n\treturn 0;\ndrop:\n\tatomic_inc(&sk->sk_drops);\ndrop_no_sk_drops_inc:\n\tUDP6_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\tkfree_skb(skb);\n\treturn -1;\n}\n\nstatic struct sock *udp_v6_mcast_next(struct net *net, struct sock *sk,\n\t\t\t\t      __be16 loc_port, struct in6_addr *loc_addr,\n\t\t\t\t      __be16 rmt_port, struct in6_addr *rmt_addr,\n\t\t\t\t      int dif)\n{\n\tstruct hlist_nulls_node *node;\n\tstruct sock *s = sk;\n\tunsigned short num = ntohs(loc_port);\n\n\tsk_nulls_for_each_from(s, node) {\n\t\tstruct inet_sock *inet = inet_sk(s);\n\n\t\tif (!net_eq(sock_net(s), net))\n\t\t\tcontinue;\n\n\t\tif (udp_sk(s)->udp_port_hash == num &&\n\t\t    s->sk_family == PF_INET6) {\n\t\t\tstruct ipv6_pinfo *np = inet6_sk(s);\n\t\t\tif (inet->inet_dport) {\n\t\t\t\tif (inet->inet_dport != rmt_port)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!ipv6_addr_any(&np->daddr) &&\n\t\t\t    !ipv6_addr_equal(&np->daddr, rmt_addr))\n\t\t\t\tcontinue;\n\n\t\t\tif (s->sk_bound_dev_if && s->sk_bound_dev_if != dif)\n\t\t\t\tcontinue;\n\n\t\t\tif (!ipv6_addr_any(&np->rcv_saddr)) {\n\t\t\t\tif (!ipv6_addr_equal(&np->rcv_saddr, loc_addr))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!inet6_mc_check(s, loc_addr, rmt_addr))\n\t\t\t\tcontinue;\n\t\t\treturn s;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void flush_stack(struct sock **stack, unsigned int count,\n\t\t\tstruct sk_buff *skb, unsigned int final)\n{\n\tunsigned int i;\n\tstruct sock *sk;\n\tstruct sk_buff *skb1;\n\n\tfor (i = 0; i < count; i++) {\n\t\tskb1 = (i == final) ? skb : skb_clone(skb, GFP_ATOMIC);\n\n\t\tsk = stack[i];\n\t\tif (skb1) {\n\t\t\tif (sk_rcvqueues_full(sk, skb1)) {\n\t\t\t\tkfree_skb(skb1);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tbh_lock_sock(sk);\n\t\t\tif (!sock_owned_by_user(sk))\n\t\t\t\tudpv6_queue_rcv_skb(sk, skb1);\n\t\t\telse if (sk_add_backlog(sk, skb1)) {\n\t\t\t\tkfree_skb(skb1);\n\t\t\t\tbh_unlock_sock(sk);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tbh_unlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\ndrop:\n\t\tatomic_inc(&sk->sk_drops);\n\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\tUDP_MIB_RCVBUFERRORS, IS_UDPLITE(sk));\n\t\tUDP6_INC_STATS_BH(sock_net(sk),\n\t\t\t\tUDP_MIB_INERRORS, IS_UDPLITE(sk));\n\t}\n}\n/*\n * Note: called only from the BH handler context,\n * so we don't need to lock the hashes.\n */\nstatic int __udp6_lib_mcast_deliver(struct net *net, struct sk_buff *skb,\n\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\tstruct udp_table *udptable)\n{\n\tstruct sock *sk, *stack[256 / sizeof(struct sock *)];\n\tconst struct udphdr *uh = udp_hdr(skb);\n\tstruct udp_hslot *hslot = udp_hashslot(udptable, net, ntohs(uh->dest));\n\tint dif;\n\tunsigned int i, count = 0;\n\n\tspin_lock(&hslot->lock);\n\tsk = sk_nulls_head(&hslot->head);\n\tdif = inet6_iif(skb);\n\tsk = udp_v6_mcast_next(net, sk, uh->dest, daddr, uh->source, saddr, dif);\n\twhile (sk) {\n\t\tstack[count++] = sk;\n\t\tsk = udp_v6_mcast_next(net, sk_nulls_next(sk), uh->dest, daddr,\n\t\t\t\t       uh->source, saddr, dif);\n\t\tif (unlikely(count == ARRAY_SIZE(stack))) {\n\t\t\tif (!sk)\n\t\t\t\tbreak;\n\t\t\tflush_stack(stack, count, skb, ~0);\n\t\t\tcount = 0;\n\t\t}\n\t}\n\t/*\n\t * before releasing the lock, we must take reference on sockets\n\t */\n\tfor (i = 0; i < count; i++)\n\t\tsock_hold(stack[i]);\n\n\tspin_unlock(&hslot->lock);\n\n\tif (count) {\n\t\tflush_stack(stack, count, skb, count - 1);\n\n\t\tfor (i = 0; i < count; i++)\n\t\t\tsock_put(stack[i]);\n\t} else {\n\t\tkfree_skb(skb);\n\t}\n\treturn 0;\n}\n\nstatic inline int udp6_csum_init(struct sk_buff *skb, struct udphdr *uh,\n\t\t\t\t int proto)\n{\n\tint err;\n\n\tUDP_SKB_CB(skb)->partial_cov = 0;\n\tUDP_SKB_CB(skb)->cscov = skb->len;\n\n\tif (proto == IPPROTO_UDPLITE) {\n\t\terr = udplite_checksum_init(skb, uh);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (uh->check == 0) {\n\t\t/* RFC 2460 section 8.1 says that we SHOULD log\n\t\t   this error. Well, it is reasonable.\n\t\t */\n\t\tLIMIT_NETDEBUG(KERN_INFO \"IPv6: udp checksum is 0\\n\");\n\t\treturn 1;\n\t}\n\tif (skb->ip_summed == CHECKSUM_COMPLETE &&\n\t    !csum_ipv6_magic(&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr,\n\t\t\t     skb->len, proto, skb->csum))\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tif (!skb_csum_unnecessary(skb))\n\t\tskb->csum = ~csum_unfold(csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\n\t\t\t\t\t\t\t &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t\t\t skb->len, proto, 0));\n\n\treturn 0;\n}\n\nint __udp6_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,\n\t\t   int proto)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tstruct sock *sk;\n\tstruct udphdr *uh;\n\tstruct in6_addr *saddr, *daddr;\n\tu32 ulen = 0;\n\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr)))\n\t\tgoto discard;\n\n\tsaddr = &ipv6_hdr(skb)->saddr;\n\tdaddr = &ipv6_hdr(skb)->daddr;\n\tuh = udp_hdr(skb);\n\n\tulen = ntohs(uh->len);\n\tif (ulen > skb->len)\n\t\tgoto short_packet;\n\n\tif (proto == IPPROTO_UDP) {\n\t\t/* UDP validates ulen. */\n\n\t\t/* Check for jumbo payload */\n\t\tif (ulen == 0)\n\t\t\tulen = skb->len;\n\n\t\tif (ulen < sizeof(*uh))\n\t\t\tgoto short_packet;\n\n\t\tif (ulen < skb->len) {\n\t\t\tif (pskb_trim_rcsum(skb, ulen))\n\t\t\t\tgoto short_packet;\n\t\t\tsaddr = &ipv6_hdr(skb)->saddr;\n\t\t\tdaddr = &ipv6_hdr(skb)->daddr;\n\t\t\tuh = udp_hdr(skb);\n\t\t}\n\t}\n\n\tif (udp6_csum_init(skb, uh, proto))\n\t\tgoto discard;\n\n\t/*\n\t *\tMulticast receive code\n\t */\n\tif (ipv6_addr_is_multicast(daddr))\n\t\treturn __udp6_lib_mcast_deliver(net, skb,\n\t\t\t\tsaddr, daddr, udptable);\n\n\t/* Unicast */\n\n\t/*\n\t * check socket cache ... must talk to Alan about his plans\n\t * for sock caches... i'll skip this for now.\n\t */\n\tsk = __udp6_lib_lookup_skb(skb, uh->source, uh->dest, udptable);\n\n\tif (sk == NULL) {\n\t\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\t\tgoto discard;\n\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto discard;\n\t\tUDP6_INC_STATS_BH(net, UDP_MIB_NOPORTS,\n\t\t\t\tproto == IPPROTO_UDPLITE);\n\n\t\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_PORT_UNREACH, 0);\n\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\t/* deliver */\n\n\tif (sk_rcvqueues_full(sk, skb)) {\n\t\tsock_put(sk);\n\t\tgoto discard;\n\t}\n\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk))\n\t\tudpv6_queue_rcv_skb(sk, skb);\n\telse if (sk_add_backlog(sk, skb)) {\n\t\tatomic_inc(&sk->sk_drops);\n\t\tbh_unlock_sock(sk);\n\t\tsock_put(sk);\n\t\tgoto discard;\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n\nshort_packet:\n\tLIMIT_NETDEBUG(KERN_DEBUG \"UDP%sv6: short packet: From [%pI6c]:%u %d/%d to [%pI6c]:%u\\n\",\n\t\t       proto == IPPROTO_UDPLITE ? \"-Lite\" : \"\",\n\t\t       saddr,\n\t\t       ntohs(uh->source),\n\t\t       ulen,\n\t\t       skb->len,\n\t\t       daddr,\n\t\t       ntohs(uh->dest));\n\ndiscard:\n\tUDP6_INC_STATS_BH(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE);\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic __inline__ int udpv6_rcv(struct sk_buff *skb)\n{\n\treturn __udp6_lib_rcv(skb, &udp_table, IPPROTO_UDP);\n}\n\n/*\n * Throw away all pending data and cancel the corking. Socket is locked.\n */\nstatic void udp_v6_flush_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock *up = udp_sk(sk);\n\n\tif (up->pending == AF_INET)\n\t\tudp_flush_pending_frames(sk);\n\telse if (up->pending) {\n\t\tup->len = 0;\n\t\tup->pending = 0;\n\t\tip6_flush_pending_frames(sk);\n\t}\n}\n\n/**\n * \tudp6_hwcsum_outgoing  -  handle outgoing HW checksumming\n * \t@sk: \tsocket we are sending on\n * \t@skb: \tsk_buff containing the filled-in UDP header\n * \t        (checksum field must be zeroed out)\n */\nstatic void udp6_hwcsum_outgoing(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t const struct in6_addr *saddr,\n\t\t\t\t const struct in6_addr *daddr, int len)\n{\n\tunsigned int offset;\n\tstruct udphdr *uh = udp_hdr(skb);\n\t__wsum csum = 0;\n\n\tif (skb_queue_len(&sk->sk_write_queue) == 1) {\n\t\t/* Only one fragment on the socket.  */\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct udphdr, check);\n\t\tuh->check = ~csum_ipv6_magic(saddr, daddr, len, IPPROTO_UDP, 0);\n\t} else {\n\t\t/*\n\t\t * HW-checksum won't work as there are two or more\n\t\t * fragments on the socket so that all csums of sk_buffs\n\t\t * should be together\n\t\t */\n\t\toffset = skb_transport_offset(skb);\n\t\tskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\tskb_queue_walk(&sk->sk_write_queue, skb) {\n\t\t\tcsum = csum_add(csum, skb->csum);\n\t\t}\n\n\t\tuh->check = csum_ipv6_magic(saddr, daddr, len, IPPROTO_UDP,\n\t\t\t\t\t    csum);\n\t\tif (uh->check == 0)\n\t\t\tuh->check = CSUM_MANGLED_0;\n\t}\n}\n\n/*\n *\tSending\n */\n\nstatic int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct udphdr *uh;\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\t__wsum csum = 0;\n\n\t/* Grab the skbuff where UDP header space exists. */\n\tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n\t\tgoto out;\n\n\t/*\n\t * Create a UDP header\n\t */\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\n\tif (is_udplite)\n\t\tcsum = udplite_csum_outgoing(sk, skb);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */\n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,\n\t\t\t\t     up->len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum_outgoing(sk, skb);\n\n\t/* add protocol-dependent pseudo-header */\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    up->len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\n\nsend:\n\terr = ip6_push_pending_frames(sk);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}\n\nint udpv6_sendmsg(struct kiocb *iocb, struct sock *sk,\n\t\t  struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) msg->msg_name;\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint err;\n\tint connected = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint (*getfrag)(void *, char *, int, int, int, struct sk_buff *);\n\n\t/* destination address check */\n\tif (sin6) {\n\t\tif (addr_len < offsetof(struct sockaddr, sa_data))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sin6->sin6_family) {\n\t\tcase AF_INET6:\n\t\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\tdaddr = &sin6->sin6_addr;\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\tgoto do_udp_sendmsg;\n\t\tcase AF_UNSPEC:\n\t\t\tmsg->msg_name = sin6 = NULL;\n\t\t\tmsg->msg_namelen = addr_len = 0;\n\t\t\tdaddr = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!up->pending) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = &np->daddr;\n\t} else\n\t\tdaddr = NULL;\n\n\tif (daddr) {\n\t\tif (ipv6_addr_v4mapped(daddr)) {\n\t\t\tstruct sockaddr_in sin;\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = sin6 ? sin6->sin6_port : inet->inet_dport;\n\t\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\t\tmsg->msg_name = &sin;\n\t\t\tmsg->msg_namelen = sizeof(sin);\ndo_udp_sendmsg:\n\t\t\tif (__ipv6_only_sock(sk))\n\t\t\t\treturn -ENETUNREACH;\n\t\t\treturn udp_sendmsg(iocb, sk, msg, len);\n\t\t}\n\t}\n\n\tif (up->pending == AF_INET)\n\t\treturn udp_sendmsg(iocb, sk, msg, len);\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_append_data().\n\t   */\n\tif (len > INT_MAX - sizeof(struct udphdr))\n\t\treturn -EMSGSIZE;\n\n\tif (up->pending) {\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET6)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t\t}\n\t\t\tdst = NULL;\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\n\tif (sin6) {\n\t\tif (sin6->sin6_port == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfl6.fl6_dport = sin6->sin6_port;\n\t\tdaddr = &sin6->sin6_addr;\n\n\t\tif (np->sndflow) {\n\t\t\tfl6.flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\t\tif (flowlabel == NULL)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tdaddr = &flowlabel->dst;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &np->daddr))\n\t\t\tdaddr = &np->daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    ipv6_addr_type(daddr)&IPV6_ADDR_LINKLOCAL)\n\t\t\tfl6.flowi6_oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tdaddr = &np->daddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tconnected = 1;\n\t}\n\n\tif (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\n\tif (!fl6.flowi6_oif)\n\t\tfl6.flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;\n\n\tfl6.flowi6_mark = sk->sk_mark;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(*opt);\n\n\t\terr = datagram_send_ctl(sock_net(sk), msg, &fl6, opt, &hlimit,\n\t\t\t\t\t&tclass, &dontfrag);\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (flowlabel == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (opt == NULL)\n\t\topt = np->opt;\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tipv6_addr_copy(&fl6.daddr, daddr);\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\tipv6_addr_copy(&fl6.saddr, &np->saddr);\n\tfl6.fl6_sport = inet->inet_sport;\n\n\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n\tif (final_p)\n\t\tconnected = 0;\n\n\tif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr)) {\n\t\tfl6.flowi6_oif = np->mcast_oif;\n\t\tconnected = 0;\n\t}\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\n\tdst = ip6_sk_dst_lookup_flow(sk, &fl6, final_p, true);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto out;\n\t}\n\n\tif (hlimit < 0) {\n\t\tif (ipv6_addr_is_multicast(&fl6.daddr))\n\t\t\thlimit = np->mcast_hops;\n\t\telse\n\t\t\thlimit = np->hop_limit;\n\t\tif (hlimit < 0)\n\t\t\thlimit = ip6_dst_hoplimit(dst);\n\t}\n\n\tif (tclass < 0)\n\t\ttclass = np->tclass;\n\n\tif (dontfrag < 0)\n\t\tdontfrag = np->dontfrag;\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tLIMIT_NETDEBUG(KERN_DEBUG \"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tup->pending = AF_INET6;\n\ndo_append_data:\n\tup->len += ulen;\n\tgetfrag  =  is_udplite ?  udplite_getfrag : ip_generic_getfrag;\n\terr = ip6_append_data(sk, getfrag, msg->msg_iov, ulen,\n\t\tsizeof(struct udphdr), hlimit, tclass, opt, &fl6,\n\t\t(struct rt6_info*)dst,\n\t\tcorkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags, dontfrag);\n\tif (err)\n\t\tudp_v6_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_v6_push_pending_frames(sk);\n\telse if (unlikely(skb_queue_empty(&sk->sk_write_queue)))\n\t\tup->pending = 0;\n\n\tif (dst) {\n\t\tif (connected) {\n\t\t\tip6_dst_store(sk, dst,\n\t\t\t\t      ipv6_addr_equal(&fl6.daddr, &np->daddr) ?\n\t\t\t\t      &np->daddr : NULL,\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t\t\t      ipv6_addr_equal(&fl6.saddr, &np->saddr) ?\n\t\t\t\t      &np->saddr :\n#endif\n\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t}\n\t\tdst = NULL;\n\t}\n\n\tif (err > 0)\n\t\terr = np->recverr ? net_xmit_errno(err) : 0;\n\trelease_sock(sk);\nout:\n\tdst_release(dst);\n\tfl6_sock_release(flowlabel);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_SNDBUFERRORS, is_udplite);\n\t}\n\treturn err;\n\ndo_confirm:\n\tdst_confirm(dst);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}\n\nvoid udpv6_destroy_sock(struct sock *sk)\n{\n\tlock_sock(sk);\n\tudp_v6_flush_pending_frames(sk);\n\trelease_sock(sk);\n\n\tinet6_destroy_sock(sk);\n}\n\n/*\n *\tSocket option code for UDP\n */\nint udpv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t     char __user *optval, unsigned int optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_setsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t\t  udp_v6_push_pending_frames);\n\treturn ipv6_setsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nint compat_udpv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, unsigned int optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_setsockopt(sk, level, optname, optval, optlen,\n\t\t\t\t\t  udp_v6_push_pending_frames);\n\treturn compat_ipv6_setsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nint udpv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t     char __user *optval, int __user *optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_getsockopt(sk, level, optname, optval, optlen);\n\treturn ipv6_getsockopt(sk, level, optname, optval, optlen);\n}\n\n#ifdef CONFIG_COMPAT\nint compat_udpv6_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t    char __user *optval, int __user *optlen)\n{\n\tif (level == SOL_UDP  ||  level == SOL_UDPLITE)\n\t\treturn udp_lib_getsockopt(sk, level, optname, optval, optlen);\n\treturn compat_ipv6_getsockopt(sk, level, optname, optval, optlen);\n}\n#endif\n\nstatic int udp6_ufo_send_check(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *ipv6h;\n\tstruct udphdr *uh;\n\n\tif (!pskb_may_pull(skb, sizeof(*uh)))\n\t\treturn -EINVAL;\n\n\tipv6h = ipv6_hdr(skb);\n\tuh = udp_hdr(skb);\n\n\tuh->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr, skb->len,\n\t\t\t\t     IPPROTO_UDP, 0);\n\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\tskb->csum_offset = offsetof(struct udphdr, check);\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\treturn 0;\n}\n\nstatic struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, u32 features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *mac_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t/* Packet is from an untrusted source, reset gso_segs. */\n\t\tint type = skb_shinfo(skb)->gso_type;\n\n\t\tif (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t * do checksum of UDP packets sent as multiple IP fragments.\n\t */\n\toffset = skb->csum_start - skb_headroom(skb);\n\tcsum = skb_checksum(skb, offset, skb->len- offset, 0);\n\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t/* Check if there is enough headroom to insert fragment header. */\n\tif ((skb_mac_header(skb) < skb->head + frag_hdr_sz) &&\n\t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n\t\tgoto out;\n\n\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t * bytes to insert fragment header.\n\t */\n\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\tunfrag_len = skb_network_header(skb) - skb_mac_header(skb) +\n\t\t     unfrag_ip6hlen;\n\tmac_start = skb_mac_header(skb);\n\tmemmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);\n\n\tskb->mac_header -= frag_hdr_sz;\n\tskb->network_header -= frag_hdr_sz;\n\n\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\tfptr->nexthdr = nexthdr;\n\tfptr->reserved = 0;\n\tipv6_select_ident(fptr);\n\n\t/* Fragment the skb. ipv6 header and the remaining fields of the\n\t * fragment header are updated in ipv6_gso_segment()\n\t */\n\tsegs = skb_segment(skb, features);\n\nout:\n\treturn segs;\n}\n\nstatic const struct inet6_protocol udpv6_protocol = {\n\t.handler\t=\tudpv6_rcv,\n\t.err_handler\t=\tudpv6_err,\n\t.gso_send_check =\tudp6_ufo_send_check,\n\t.gso_segment\t=\tudp6_ufo_fragment,\n\t.flags\t\t=\tINET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,\n};\n\n/* ------------------------------------------------------------------------ */\n#ifdef CONFIG_PROC_FS\n\nstatic void udp6_sock_seq_show(struct seq_file *seq, struct sock *sp, int bucket)\n{\n\tstruct inet_sock *inet = inet_sk(sp);\n\tstruct ipv6_pinfo *np = inet6_sk(sp);\n\tstruct in6_addr *dest, *src;\n\t__u16 destp, srcp;\n\n\tdest  = &np->daddr;\n\tsrc   = &np->rcv_saddr;\n\tdestp = ntohs(inet->inet_dport);\n\tsrcp  = ntohs(inet->inet_sport);\n\tseq_printf(seq,\n\t\t   \"%5d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X \"\n\t\t   \"%02X %08X:%08X %02X:%08lX %08X %5d %8d %lu %d %p %d\\n\",\n\t\t   bucket,\n\t\t   src->s6_addr32[0], src->s6_addr32[1],\n\t\t   src->s6_addr32[2], src->s6_addr32[3], srcp,\n\t\t   dest->s6_addr32[0], dest->s6_addr32[1],\n\t\t   dest->s6_addr32[2], dest->s6_addr32[3], destp,\n\t\t   sp->sk_state,\n\t\t   sk_wmem_alloc_get(sp),\n\t\t   sk_rmem_alloc_get(sp),\n\t\t   0, 0L, 0,\n\t\t   sock_i_uid(sp), 0,\n\t\t   sock_i_ino(sp),\n\t\t   atomic_read(&sp->sk_refcnt), sp,\n\t\t   atomic_read(&sp->sk_drops));\n}\n\nint udp6_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq,\n\t\t\t   \"  sl  \"\n\t\t\t   \"local_address                         \"\n\t\t\t   \"remote_address                        \"\n\t\t\t   \"st tx_queue rx_queue tr tm->when retrnsmt\"\n\t\t\t   \"   uid  timeout inode ref pointer drops\\n\");\n\telse\n\t\tudp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);\n\treturn 0;\n}\n\nstatic struct udp_seq_afinfo udp6_seq_afinfo = {\n\t.name\t\t= \"udp6\",\n\t.family\t\t= AF_INET6,\n\t.udp_table\t= &udp_table,\n\t.seq_fops\t= {\n\t\t.owner\t=\tTHIS_MODULE,\n\t},\n\t.seq_ops\t= {\n\t\t.show\t\t= udp6_seq_show,\n\t},\n};\n\nint __net_init udp6_proc_init(struct net *net)\n{\n\treturn udp_proc_register(net, &udp6_seq_afinfo);\n}\n\nvoid udp6_proc_exit(struct net *net) {\n\tudp_proc_unregister(net, &udp6_seq_afinfo);\n}\n#endif /* CONFIG_PROC_FS */\n\n/* ------------------------------------------------------------------------ */\n\nstruct proto udpv6_prot = {\n\t.name\t\t   = \"UDPv6\",\n\t.owner\t\t   = THIS_MODULE,\n\t.close\t\t   = udp_lib_close,\n\t.connect\t   = ip6_datagram_connect,\n\t.disconnect\t   = udp_disconnect,\n\t.ioctl\t\t   = udp_ioctl,\n\t.destroy\t   = udpv6_destroy_sock,\n\t.setsockopt\t   = udpv6_setsockopt,\n\t.getsockopt\t   = udpv6_getsockopt,\n\t.sendmsg\t   = udpv6_sendmsg,\n\t.recvmsg\t   = udpv6_recvmsg,\n\t.backlog_rcv\t   = udpv6_queue_rcv_skb,\n\t.hash\t\t   = udp_lib_hash,\n\t.unhash\t\t   = udp_lib_unhash,\n\t.rehash\t\t   = udp_v6_rehash,\n\t.get_port\t   = udp_v6_get_port,\n\t.memory_allocated  = &udp_memory_allocated,\n\t.sysctl_mem\t   = sysctl_udp_mem,\n\t.sysctl_wmem\t   = &sysctl_udp_wmem_min,\n\t.sysctl_rmem\t   = &sysctl_udp_rmem_min,\n\t.obj_size\t   = sizeof(struct udp6_sock),\n\t.slab_flags\t   = SLAB_DESTROY_BY_RCU,\n\t.h.udp_table\t   = &udp_table,\n#ifdef CONFIG_COMPAT\n\t.compat_setsockopt = compat_udpv6_setsockopt,\n\t.compat_getsockopt = compat_udpv6_getsockopt,\n#endif\n\t.clear_sk\t   = sk_prot_clear_portaddr_nulls,\n};\n\nstatic struct inet_protosw udpv6_protosw = {\n\t.type =      SOCK_DGRAM,\n\t.protocol =  IPPROTO_UDP,\n\t.prot =      &udpv6_prot,\n\t.ops =       &inet6_dgram_ops,\n\t.no_check =  UDP_CSUM_DEFAULT,\n\t.flags =     INET_PROTOSW_PERMANENT,\n};\n\n\nint __init udpv6_init(void)\n{\n\tint ret;\n\n\tret = inet6_add_protocol(&udpv6_protocol, IPPROTO_UDP);\n\tif (ret)\n\t\tgoto out;\n\n\tret = inet6_register_protosw(&udpv6_protosw);\n\tif (ret)\n\t\tgoto out_udpv6_protocol;\nout:\n\treturn ret;\n\nout_udpv6_protocol:\n\tinet6_del_protocol(&udpv6_protocol, IPPROTO_UDP);\n\tgoto out;\n}\n\nvoid udpv6_exit(void)\n{\n\tinet6_unregister_protosw(&udpv6_protosw);\n\tinet6_del_protocol(&udpv6_protocol, IPPROTO_UDP);\n}\n"], "filenames": ["net/ipv6/udp.c"], "buggy_code_start_loc": [1338], "buggy_code_end_loc": [1339], "fixing_code_start_loc": [1338], "fixing_code_end_loc": [1339], "type": "CWE-399", "message": "The udp6_ufo_fragment function in net/ipv6/udp.c in the Linux kernel before 2.6.39, when a certain UDP Fragmentation Offload (UFO) configuration is enabled, allows remote attackers to cause a denial of service (system crash) by sending fragmented IPv6 UDP packets to a bridge device.", "other": {"cve": {"id": "CVE-2011-4326", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-17T11:00:33.837", "lastModified": "2023-02-13T01:21:45.080", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The udp6_ufo_fragment function in net/ipv6/udp.c in the Linux kernel before 2.6.39, when a certain UDP Fragmentation Offload (UFO) configuration is enabled, allows remote attackers to cause a denial of service (system crash) by sending fragmented IPv6 UDP packets to a bridge device."}, {"lang": "es", "value": "La funci\u00f3n udp6_ufo_fragment en net/ipv6/udp.c en el kernel de Linux antes de v2.6.39, cuando la opci\u00f3n de \"UDP Fragmentation Offload\" (UFO) est\u00e1 activada, permite a atacantes remotos causar una denegaci\u00f3n de servicio (ca\u00edda del sistema) mediante el env\u00edo de paquetes IPv6 UDP a un dispositivo de puente."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.39", "matchCriteriaId": "176353CE-F17E-4776-AD9F-19014DA75B76"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:avaya:96x1_ip_deskphone_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndIncluding": "6.6.0", "matchCriteriaId": "829711E4-DDFD-49DA-8551-3571405B8267"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:avaya:96x1_ip_deskphone:-:*:*:*:*:*:*:*", "matchCriteriaId": "B1BDA0A2-6A72-4C30-84BE-B60B8A9DE928"}]}]}], "references": [{"url": "http://downloads.avaya.com/css/P8/documents/100156038", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=a9cf73ea7ff78f52662c8658d93c226effbbedde", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2011/11/21/10", "source": "secalert@redhat.com", "tags": ["Mailing List"]}, {"url": "http://www.securityfocus.com/bid/50751", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=682066", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=755584", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/a9cf73ea7ff78f52662c8658d93c226effbbedde", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a9cf73ea7ff78f52662c8658d93c226effbbedde"}}