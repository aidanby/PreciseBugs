{"buggy_code": ["<?php\n\nnamespace Knp\\Snappy;\n\nuse Knp\\Snappy\\Exception\\FileAlreadyExistsException;\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerAwareTrait;\nuse Symfony\\Component\\Process\\Process;\nuse Exception;\nuse LogicException;\nuse RuntimeException;\nuse InvalidArgumentException;\n\n/**\n * Base generator class for medias.\n *\n * @author  Matthieu Bontemps <matthieu.bontemps@knplabs.com>\n * @author  Antoine H\u00e9rault <antoine.herault@knplabs.com>\n */\nabstract class AbstractGenerator implements GeneratorInterface, LoggerAwareInterface\n{\n    use LoggerAwareTrait;\n\n    /**\n     * @var array\n     */\n    public $temporaryFiles = [];\n\n    /**\n     * @var string\n     */\n    protected $temporaryFolder;\n\n    /**\n     * @var null|string\n     */\n    private $binary;\n\n    /**\n     * @var array\n     */\n    private $options = [];\n\n    /**\n     * @var null|array\n     */\n    private $env;\n\n    /**\n     * @var null|int\n     */\n    private $timeout;\n\n    /**\n     * @var string\n     */\n    private $defaultExtension;\n\n    /**\n     * @param null|string $binary\n     * @param array       $options\n     * @param null|array  $env\n     */\n    public function __construct($binary, array $options = [], array $env = null)\n    {\n        $this->configure();\n\n        $this->setBinary($binary);\n        $this->setOptions($options);\n        $this->env = empty($env) ? null : $env;\n\n        if (\\is_callable([$this, 'removeTemporaryFiles'])) {\n            \\register_shutdown_function([$this, 'removeTemporaryFiles']);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->removeTemporaryFiles();\n    }\n\n    /**\n     * Sets the default extension.\n     * Useful when letting Snappy deal with file creation.\n     *\n     * @param string $defaultExtension\n     *\n     * @return $this\n     */\n    public function setDefaultExtension($defaultExtension)\n    {\n        $this->defaultExtension = $defaultExtension;\n\n        return $this;\n    }\n\n    /**\n     * Gets the default extension.\n     *\n     * @return string\n     */\n    public function getDefaultExtension(): string\n    {\n        return $this->defaultExtension;\n    }\n\n    /**\n     * Sets an option. Be aware that option values are NOT validated and that\n     * it is your responsibility to validate user inputs.\n     *\n     * @param string $name  The option to set\n     * @param mixed  $value The value (NULL to unset)\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return $this\n     */\n    public function setOption($name, $value)\n    {\n        if (!\\array_key_exists($name, $this->options)) {\n            throw new InvalidArgumentException(\\sprintf('The option \\'%s\\' does not exist.', $name));\n        }\n\n        $this->options[$name] = $value;\n\n        if (null !== $this->logger) {\n            $this->logger->debug(\\sprintf('Set option \"%s\".', $name), ['value' => $value]);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets the timeout.\n     *\n     * @param null|int $timeout The timeout to set\n     *\n     * @return $this\n     */\n    public function setTimeout($timeout)\n    {\n        $this->timeout = $timeout;\n\n        return $this;\n    }\n\n    /**\n     * Sets an array of options.\n     *\n     * @param array $options An associative array of options as name/value\n     *\n     * @return $this\n     */\n    public function setOptions(array $options)\n    {\n        foreach ($options as $name => $value) {\n            $this->setOption($name, $value);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns all the options.\n     *\n     * @return array\n     */\n    public function getOptions()\n    {\n        return $this->options;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function generate($input, $output, array $options = [], $overwrite = false)\n    {\n        $this->prepareOutput($output, $overwrite);\n\n        $command = $this->getCommand($input, $output, $options);\n\n        $inputFiles = \\is_array($input) ? \\implode('\", \"', $input) : $input;\n\n        if (null !== $this->logger) {\n            $this->logger->info(\\sprintf('Generate from file(s) \"%s\" to file \"%s\".', $inputFiles, $output), [\n                'command' => $command,\n                'env' => $this->env,\n                'timeout' => $this->timeout,\n            ]);\n        }\n\n        try {\n            list($status, $stdout, $stderr) = $this->executeCommand($command);\n            $this->checkProcessStatus($status, $stdout, $stderr, $command);\n            $this->checkOutput($output, $command);\n        } catch (Exception $e) {\n            if (null !== $this->logger) {\n                $this->logger->error(\\sprintf('An error happened while generating \"%s\".', $output), [\n                    'command' => $command,\n                    'status' => $status ?? null,\n                    'stdout' => $stdout ?? null,\n                    'stderr' => $stderr ?? null,\n                ]);\n            }\n\n            throw $e;\n        }\n\n        if (null !== $this->logger) {\n            $this->logger->info(\\sprintf('File \"%s\" has been successfully generated.', $output), [\n                'command' => $command,\n                'stdout' => $stdout,\n                'stderr' => $stderr,\n            ]);\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function generateFromHtml($html, $output, array $options = [], $overwrite = false)\n    {\n        $fileNames = [];\n        if (\\is_array($html)) {\n            foreach ($html as $htmlInput) {\n                $fileNames[] = $this->createTemporaryFile($htmlInput, 'html');\n            }\n        } else {\n            $fileNames[] = $this->createTemporaryFile($html, 'html');\n        }\n\n        $this->generate($fileNames, $output, $options, $overwrite);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getOutput($input, array $options = [])\n    {\n        $filename = $this->createTemporaryFile(null, $this->getDefaultExtension());\n\n        $this->generate($input, $filename, $options);\n\n        return $this->getFileContents($filename);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getOutputFromHtml($html, array $options = [])\n    {\n        $fileNames = [];\n        if (\\is_array($html)) {\n            foreach ($html as $htmlInput) {\n                $fileNames[] = $this->createTemporaryFile($htmlInput, 'html');\n            }\n        } else {\n            $fileNames[] = $this->createTemporaryFile($html, 'html');\n        }\n\n        return $this->getOutput($fileNames, $options);\n    }\n\n    /**\n     * Defines the binary.\n     *\n     * @param null|string $binary The path/name of the binary\n     *\n     * @return $this\n     */\n    public function setBinary($binary)\n    {\n        $this->binary = $binary;\n\n        return $this;\n    }\n\n    /**\n     * Returns the binary.\n     *\n     * @return null|string\n     */\n    public function getBinary()\n    {\n        return $this->binary;\n    }\n\n    /**\n     * Returns the command for the given input and output files.\n     *\n     * @param array|string $input   The input file\n     * @param string       $output  The ouput file\n     * @param array        $options An optional array of options that will be used\n     *                              only for this command\n     *\n     * @return string\n     */\n    public function getCommand($input, $output, array $options = [])\n    {\n        if (null === $this->binary) {\n            throw new LogicException('You must define a binary prior to conversion.');\n        }\n\n        $options = $this->mergeOptions($options);\n\n        return $this->buildCommand($this->binary, $input, $output, $options);\n    }\n\n    /**\n     * Removes all temporary files.\n     *\n     * @return void\n     */\n    public function removeTemporaryFiles()\n    {\n        foreach ($this->temporaryFiles as $file) {\n            $this->unlink($file);\n        }\n    }\n\n    /**\n     * Get TemporaryFolder.\n     *\n     * @return string\n     */\n    public function getTemporaryFolder()\n    {\n        if ($this->temporaryFolder === null) {\n            return \\sys_get_temp_dir();\n        }\n\n        return $this->temporaryFolder;\n    }\n\n    /**\n     * Set temporaryFolder.\n     *\n     * @param string $temporaryFolder\n     *\n     * @return $this\n     */\n    public function setTemporaryFolder($temporaryFolder)\n    {\n        $this->temporaryFolder = $temporaryFolder;\n\n        return $this;\n    }\n\n    /**\n     * Reset all options to their initial values.\n     *\n     * @return void\n     */\n    public function resetOptions()\n    {\n        $this->options = [];\n        $this->configure();\n    }\n\n    /**\n     * This method must configure the media options.\n     *\n     * @return void\n     *\n     * @see AbstractGenerator::addOption()\n     */\n    abstract protected function configure();\n\n    /**\n     * Adds an option.\n     *\n     * @param string $name    The name\n     * @param mixed  $default An optional default value\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return $this\n     */\n    protected function addOption($name, $default = null)\n    {\n        if (\\array_key_exists($name, $this->options)) {\n            throw new InvalidArgumentException(\\sprintf('The option \\'%s\\' already exists.', $name));\n        }\n\n        $this->options[$name] = $default;\n\n        return $this;\n    }\n\n    /**\n     * Adds an array of options.\n     *\n     * @param array $options\n     *\n     * @return $this\n     */\n    protected function addOptions(array $options)\n    {\n        foreach ($options as $name => $default) {\n            $this->addOption($name, $default);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Merges the given array of options to the instance options and returns\n     * the result options array. It does NOT change the instance options.\n     *\n     * @param array $options\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return array\n     */\n    protected function mergeOptions(array $options)\n    {\n        $mergedOptions = $this->options;\n\n        foreach ($options as $name => $value) {\n            if (!\\array_key_exists($name, $mergedOptions)) {\n                throw new InvalidArgumentException(\\sprintf('The option \\'%s\\' does not exist.', $name));\n            }\n\n            $mergedOptions[$name] = $value;\n        }\n\n        return $mergedOptions;\n    }\n\n    /**\n     * Checks the specified output.\n     *\n     * @param string $output  The output filename\n     * @param string $command The generation command\n     *\n     * @throws RuntimeException if the output file generation failed\n     *\n     * @return void\n     */\n    protected function checkOutput($output, $command)\n    {\n        // the output file must exist\n        if (!$this->fileExists($output)) {\n            throw new RuntimeException(\\sprintf('The file \\'%s\\' was not created (command: %s).', $output, $command));\n        }\n\n        // the output file must not be empty\n        if (0 === $this->filesize($output)) {\n            throw new RuntimeException(\\sprintf('The file \\'%s\\' was created but is empty (command: %s).', $output, $command));\n        }\n    }\n\n    /**\n     * Checks the process return status.\n     *\n     * @param int    $status  The exit status code\n     * @param string $stdout  The stdout content\n     * @param string $stderr  The stderr content\n     * @param string $command The run command\n     *\n     * @throws RuntimeException if the output file generation failed\n     *\n     * @return void\n     */\n    protected function checkProcessStatus($status, $stdout, $stderr, $command)\n    {\n        if (0 !== $status && '' !== $stderr) {\n            throw new RuntimeException(\\sprintf('The exit status code \\'%s\\' says something went wrong:' . \"\\n\" . 'stderr: \"%s\"' . \"\\n\" . 'stdout: \"%s\"' . \"\\n\" . 'command: %s.', $status, $stderr, $stdout, $command), $status);\n        }\n    }\n\n    /**\n     * Creates a temporary file.\n     * The file is not created if the $content argument is null.\n     *\n     * @param null|string $content   Optional content for the temporary file\n     * @param null|string $extension An optional extension for the filename\n     *\n     * @return string The filename\n     */\n    protected function createTemporaryFile($content = null, $extension = null)\n    {\n        $dir = \\rtrim($this->getTemporaryFolder(), \\DIRECTORY_SEPARATOR);\n\n        if (!\\is_dir($dir)) {\n            if (false === @\\mkdir($dir, 0777, true) && !\\is_dir($dir)) {\n                throw new RuntimeException(\\sprintf(\"Unable to create directory: %s\\n\", $dir));\n            }\n        } elseif (!\\is_writable($dir)) {\n            throw new RuntimeException(\\sprintf(\"Unable to write in directory: %s\\n\", $dir));\n        }\n\n        $filename = $dir . \\DIRECTORY_SEPARATOR . \\uniqid('knp_snappy', true);\n\n        if (null !== $extension) {\n            $filename .= '.' . $extension;\n        }\n\n        if (null !== $content) {\n            \\file_put_contents($filename, $content);\n        }\n\n        $this->temporaryFiles[] = $filename;\n\n        return $filename;\n    }\n\n    /**\n     * Builds the command string.\n     *\n     * @param string       $binary  The binary path/name\n     * @param array|string $input   Url(s) or file location(s) of the page(s) to process\n     * @param string       $output  File location to the image-to-be\n     * @param array        $options An array of options\n     *\n     * @return string\n     */\n    protected function buildCommand($binary, $input, $output, array $options = [])\n    {\n        $command = $binary;\n        $escapedBinary = \\escapeshellarg($binary);\n        if (\\is_executable($escapedBinary)) {\n            $command = $escapedBinary;\n        }\n\n        foreach ($options as $key => $option) {\n            if (null !== $option && false !== $option) {\n                if (true === $option) {\n                    // Dont't put '--' if option is 'toc'.\n                    if ($key === 'toc') {\n                        $command .= ' ' . $key;\n                    } else {\n                        $command .= ' --' . $key;\n                    }\n                } elseif (\\is_array($option)) {\n                    if ($this->isAssociativeArray($option)) {\n                        foreach ($option as $k => $v) {\n                            $command .= ' --' . $key . ' ' . \\escapeshellarg($k) . ' ' . \\escapeshellarg($v);\n                        }\n                    } else {\n                        foreach ($option as $v) {\n                            $command .= ' --' . $key . ' ' . \\escapeshellarg($v);\n                        }\n                    }\n                } else {\n                    // Dont't add '--' if option is \"cover\"  or \"toc\".\n                    if (\\in_array($key, ['toc', 'cover'])) {\n                        $command .= ' ' . $key . ' ' . \\escapeshellarg($option);\n                    } elseif (\\in_array($key, ['image-dpi', 'image-quality'])) {\n                        $command .= ' --' . $key . ' ' . (int) $option;\n                    } else {\n                        $command .= ' --' . $key . ' ' . \\escapeshellarg($option);\n                    }\n                }\n            }\n        }\n\n        if (\\is_array($input)) {\n            foreach ($input as $i) {\n                $command .= ' ' . \\escapeshellarg($i) . ' ';\n            }\n            $command .= \\escapeshellarg($output);\n        } else {\n            $command .= ' ' . \\escapeshellarg($input) . ' ' . \\escapeshellarg($output);\n        }\n\n        return $command;\n    }\n\n    /**\n     * Return true if the array is an associative array\n     * and not an indexed array.\n     *\n     * @param array $array\n     *\n     * @return bool\n     */\n    protected function isAssociativeArray(array $array)\n    {\n        return (bool) \\count(\\array_filter(\\array_keys($array), 'is_string'));\n    }\n\n    /**\n     * Executes the given command via shell and returns the complete output as\n     * a string.\n     *\n     * @param string $command\n     *\n     * @return array [status, stdout, stderr]\n     */\n    protected function executeCommand($command)\n    {\n        if (\\method_exists(Process::class, 'fromShellCommandline')) {\n            $process = Process::fromShellCommandline($command, null, $this->env);\n        } else {\n            $process = new Process($command, null, $this->env);\n        }\n\n        if (null !== $this->timeout) {\n            $process->setTimeout($this->timeout);\n        }\n\n        $process->run();\n\n        return [\n            $process->getExitCode(),\n            $process->getOutput(),\n            $process->getErrorOutput(),\n        ];\n    }\n\n    /**\n     * Prepares the specified output.\n     *\n     * @param string $filename  The output filename\n     * @param bool   $overwrite Whether to overwrite the file if it already\n     *                          exist\n     *\n     * @throws FileAlreadyExistsException\n     * @throws RuntimeException\n     * @throws InvalidArgumentException\n     *\n     * @return void\n     */\n    protected function prepareOutput($filename, $overwrite)\n    {\n        if (\\strpos($filename, 'phar://') === 0) {\n            throw new InvalidArgumentException('The output file cannot be a phar archive.');\n        }\n\n        $directory = \\dirname($filename);\n\n        if ($this->fileExists($filename)) {\n            if (!$this->isFile($filename)) {\n                throw new InvalidArgumentException(\\sprintf('The output file \\'%s\\' already exists and it is a %s.', $filename, $this->isDir($filename) ? 'directory' : 'link'));\n            }\n            if (false === $overwrite) {\n                throw new FileAlreadyExistsException(\\sprintf('The output file \\'%s\\' already exists.', $filename));\n            }\n            if (!$this->unlink($filename)) {\n                throw new RuntimeException(\\sprintf('Could not delete already existing output file \\'%s\\'.', $filename));\n            }\n        } elseif (!$this->isDir($directory) && !$this->mkdir($directory)) {\n            throw new RuntimeException(\\sprintf('The output file\\'s directory \\'%s\\' could not be created.', $directory));\n        }\n    }\n\n    /**\n     * Wrapper for the \"file_get_contents\" function.\n     *\n     * @param string $filename\n     *\n     * @return string\n     */\n    protected function getFileContents($filename)\n    {\n        $fileContent = \\file_get_contents($filename);\n\n        if (false === $fileContent) {\n            throw new RuntimeException(\\sprintf('Could not read file \\'%s\\' content.', $filename));\n        }\n\n        return $fileContent;\n    }\n\n    /**\n     * Wrapper for the \"file_exists\" function.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function fileExists($filename)\n    {\n        return \\file_exists($filename);\n    }\n\n    /**\n     * Wrapper for the \"is_file\" method.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function isFile($filename)\n    {\n        return \\strlen($filename) <= \\PHP_MAXPATHLEN && \\is_file($filename);\n    }\n\n    /**\n     * Wrapper for the \"filesize\" function.\n     *\n     * @param string $filename\n     *\n     * @return int\n     */\n    protected function filesize($filename)\n    {\n        $filesize = \\filesize($filename);\n\n        if (false === $filesize) {\n            throw new RuntimeException(\\sprintf('Could not read file \\'%s\\' size.', $filename));\n        }\n\n        return $filesize;\n    }\n\n    /**\n     * Wrapper for the \"unlink\" function.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function unlink($filename)\n    {\n        return $this->fileExists($filename) ? \\unlink($filename) : false;\n    }\n\n    /**\n     * Wrapper for the \"is_dir\" function.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function isDir($filename)\n    {\n        return \\is_dir($filename);\n    }\n\n    /**\n     * Wrapper for the mkdir function.\n     *\n     * @param string $pathname\n     *\n     * @return bool\n     */\n    protected function mkdir($pathname)\n    {\n        return \\mkdir($pathname, 0777, true);\n    }\n}\n", "<?php\n\nnamespace Tests\\Knp\\Snappy;\n\nuse Knp\\Snappy\\AbstractGenerator;\nuse Knp\\Snappy\\Exception\\FileAlreadyExistsException;\nuse PHPUnit\\Framework\\TestCase;\nuse Psr\\Log\\LoggerInterface;\nuse InvalidArgumentException;\nuse RuntimeException;\nuse ReflectionProperty;\nuse ReflectionMethod;\n\nclass AbstractGeneratorTest extends TestCase\n{\n    public function testAddOption(): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $this->assertEquals([], $media->getOptions());\n\n        $r = new ReflectionMethod($media, 'addOption');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, ['foo', 'bar']);\n\n        $this->assertEquals(['foo' => 'bar'], $media->getOptions(), '->addOption() adds an option');\n\n        $r->invokeArgs($media, ['baz', 'bat']);\n\n        $this->assertEquals(\n            [\n                'foo' => 'bar',\n                'baz' => 'bat',\n            ],\n            $media->getOptions(),\n            '->addOption() appends the option to the existing ones'\n        );\n\n        $message = '->addOption() raises an exception when the specified option already exists';\n\n        try {\n            $r->invokeArgs($media, ['baz', 'bat']);\n            $this->fail($message);\n            // @phpstan-ignore-next-line\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testAddOptions(): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $this->assertEquals([], $media->getOptions());\n\n        $r = new ReflectionMethod($media, 'addOptions');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, [['foo' => 'bar', 'baz' => 'bat']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'bar',\n                'baz' => 'bat',\n            ],\n            $media->getOptions(),\n            '->addOptions() adds all the given options'\n        );\n\n        $r->invokeArgs($media, [['ban' => 'bag', 'bal' => 'bac']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'bar',\n                'baz' => 'bat',\n                'ban' => 'bag',\n                'bal' => 'bac',\n            ],\n            $media->getOptions(),\n            '->addOptions() adds the given options to the existing ones'\n        );\n\n        $message = '->addOptions() raises an exception when one of the given options already exists';\n\n        try {\n            $r->invokeArgs($media, [['bak' => 'bam', 'bah' => 'bap', 'baz' => 'bat']]);\n            $this->fail($message);\n            // @phpstan-ignore-next-line\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testSetOption(): void\n    {\n        $media = $this\n            ->getMockBuilder(AbstractGenerator::class)\n            ->setConstructorArgs(['/usr/local/bin/wkhtmltopdf'])\n            ->getMockForAbstractClass()\n        ;\n\n        $logger = $this\n            ->getMockBuilder(LoggerInterface::class)\n            ->getMock()\n        ;\n        $media->setLogger($logger);\n        $logger->expects($this->once())->method('debug');\n\n        $r = new ReflectionMethod($media, 'addOption');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, ['foo', 'bar']);\n\n        $media->setOption('foo', 'abc');\n\n        $this->assertEquals(\n            [\n                'foo' => 'abc',\n            ],\n            $media->getOptions(),\n            '->setOption() defines the value of an option'\n        );\n\n        $message = '->setOption() raises an exception when the specified option does not exist';\n\n        try {\n            $media->setOption('bad', 'def');\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testSetOptions(): void\n    {\n        $media = $this\n            ->getMockBuilder(AbstractGenerator::class)\n            ->setConstructorArgs(['/usr/local/bin/wkhtmltopdf'])\n            ->getMockForAbstractClass()\n        ;\n\n        $logger = $this\n            ->getMockBuilder(LoggerInterface::class)\n            ->getMock()\n        ;\n        $media->setLogger($logger);\n        $logger->expects($this->exactly(4))->method('debug');\n\n        $r = new ReflectionMethod($media, 'addOptions');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, [['foo' => 'bar', 'baz' => 'bat']]);\n\n        $media->setOptions(['foo' => 'abc', 'baz' => 'def']);\n\n        $this->assertEquals(\n            [\n                'foo' => 'abc',\n                'baz' => 'def',\n            ],\n            $media->getOptions(),\n            '->setOptions() defines the values of all the specified options'\n        );\n\n        $message = '->setOptions() raises an exception when one of the specified options does not exist';\n\n        try {\n            $media->setOptions(['foo' => 'abc', 'baz' => 'def', 'bad' => 'ghi']);\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testGenerate(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'prepareOutput',\n                'getCommand',\n                'executeCommand',\n                'checkOutput',\n                'checkProcessStatus',\n            ])\n            ->setConstructorArgs(['the_binary', []])\n            ->getMock()\n        ;\n\n        $logger = $this\n            ->getMockBuilder(LoggerInterface::class)\n            ->getMock()\n        ;\n        $media->setLogger($logger);\n        $logger\n            ->expects($this->exactly(2))\n            ->method('info')\n            ->with(\n                $this->logicalOr(\n                    'Generate from file(s) \"the_input_file\" to file \"the_output_file\".',\n                    'File \"the_output_file\" has been successfully generated.'\n                ),\n                $this->logicalOr(\n                    ['command' => 'the command', 'env' => null, 'timeout' => false],\n                    ['command' => 'the command', 'stdout' => 'stdout', 'stderr' => 'stderr']\n                )\n            )\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('prepareOutput')\n            ->with($this->equalTo('the_output_file'))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('getCommand')\n            ->with(\n                $this->equalTo('the_input_file'),\n                $this->equalTo('the_output_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n            ->will($this->returnValue('the command'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('executeCommand')\n            ->with($this->equalTo('the command'))\n            ->willReturn([0, 'stdout', 'stderr'])\n        ;\n        $media\n            ->expects($this->once())\n            ->method('checkProcessStatus')\n            ->with(0, 'stdout', 'stderr', 'the command')\n        ;\n        $media\n            ->expects($this->once())\n            ->method('checkOutput')\n            ->with(\n                $this->equalTo('the_output_file'),\n                $this->equalTo('the command')\n            )\n        ;\n\n        $media->generate('the_input_file', 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testFailingGenerate(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'prepareOutput',\n                'getCommand',\n                'executeCommand',\n                'checkOutput',\n                'checkProcessStatus',\n            ])\n            ->setConstructorArgs(['the_binary', [], ['PATH' => '/usr/bin']])\n            ->getMock()\n        ;\n\n        $logger = $this->getMockBuilder(LoggerInterface::class)->getMock();\n        $media->setLogger($logger);\n        $media->setTimeout(2000);\n\n        $logger\n            ->expects($this->once())\n            ->method('info')\n            ->with(\n                $this->equalTo('Generate from file(s) \"the_input_file\" to file \"the_output_file\".'),\n                $this->equalTo(['command' => 'the command', 'env' => ['PATH' => '/usr/bin'], 'timeout' => 2000])\n            )\n        ;\n\n        $logger\n            ->expects($this->once())\n            ->method('error')\n            ->with(\n                $this->equalTo('An error happened while generating \"the_output_file\".'),\n                $this->equalTo(['command' => 'the command', 'status' => 1, 'stdout' => 'stdout', 'stderr' => 'stderr'])\n            )\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('prepareOutput')\n            ->with($this->equalTo('the_output_file'))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('getCommand')\n            ->with(\n                $this->equalTo('the_input_file'),\n                $this->equalTo('the_output_file')\n            )\n            ->will($this->returnValue('the command'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('executeCommand')\n            ->with($this->equalTo('the command'))\n            ->willReturn([1, 'stdout', 'stderr'])\n        ;\n        $media\n            ->expects($this->once())\n            ->method('checkProcessStatus')\n            ->with(1, 'stdout', 'stderr', 'the command')\n            ->willThrowException(new RuntimeException())\n        ;\n\n        $this->expectException(RuntimeException::class);\n\n        $media->generate('the_input_file', 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testGenerateFromHtml(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'generate',\n                'createTemporaryFile',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('generate')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo('the_output_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n        ;\n\n        $media->generateFromHtml('<html>foo</html>', 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testGenerateFromHtmlWithHtmlArray(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'generate',\n                'createTemporaryFile',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('generate')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo('the_output_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n        ;\n\n        $media->generateFromHtml(['<html>foo</html>'], 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testGetOutput(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'getDefaultExtension',\n                'createTemporaryFile',\n                'generate',\n                'getFileContents',\n                'unlink',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->any())\n            ->method('getDefaultExtension')\n            ->will($this->returnValue('ext'))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo(null),\n                $this->equalTo('ext')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('generate')\n            ->with(\n                $this->equalTo('the_input_file'),\n                $this->equalTo('the_temporary_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n        ;\n        $media\n            ->expects($this->once())\n            ->method('getFileContents')\n            ->will($this->returnValue('the file contents'))\n        ;\n\n        $media\n            ->expects($this->any())\n            ->method('unlink')\n            ->with($this->equalTo('the_temporary_file'))\n            ->will($this->returnValue(true))\n        ;\n\n        $this->assertEquals('the file contents', $media->getOutput('the_input_file', ['foo' => 'bar']));\n    }\n\n    public function testGetOutputFromHtml(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'getOutput',\n                'createTemporaryFile',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('getOutput')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo(['foo' => 'bar'])\n            )\n            ->will($this->returnValue('the output'))\n        ;\n\n        $this->assertEquals('the output', $media->getOutputFromHtml('<html>foo</html>', ['foo' => 'bar']));\n    }\n\n    public function testGetOutputFromHtmlWithHtmlArray(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'getOutput',\n                'createTemporaryFile',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('getOutput')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo(['foo' => 'bar'])\n            )\n            ->will($this->returnValue('the output'))\n        ;\n\n        $this->assertEquals('the output', $media->getOutputFromHtml(['<html>foo</html>'], ['foo' => 'bar']));\n    }\n\n    public function testMergeOptions(): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $originalOptions = ['foo' => 'bar', 'baz' => 'bat'];\n\n        $addOptions = new ReflectionMethod($media, 'addOptions');\n        $addOptions->setAccessible(true);\n        $addOptions->invokeArgs($media, [$originalOptions]);\n\n        $r = new ReflectionMethod($media, 'mergeOptions');\n        $r->setAccessible(true);\n\n        $mergedOptions = $r->invokeArgs($media, [['foo' => 'ban']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'ban',\n                'baz' => 'bat',\n            ],\n            $mergedOptions,\n            '->mergeOptions() merges an option to the instance ones and returns the result options array'\n        );\n\n        $this->assertEquals(\n            $originalOptions,\n            $media->getOptions(),\n            '->mergeOptions() does NOT change the instance options'\n        );\n\n        $mergedOptions = $r->invokeArgs($media, [['foo' => 'ban', 'baz' => 'bag']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'ban',\n                'baz' => 'bag',\n            ],\n            $mergedOptions,\n            '->mergeOptions() merges many options to the instance ones and returns the result options array'\n        );\n\n        $message = '->mergeOptions() throws an InvalidArgumentException once there is an undefined option in the given array';\n\n        try {\n            $r->invokeArgs($media, [['foo' => 'ban', 'bad' => 'bah']]);\n            $this->fail($message);\n            // @phpstan-ignore-next-line\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    /**\n     * @dataProvider dataForBuildCommand\n     */\n    public function testBuildCommand(string $binary, string $url, string $path, array $options, string $expected): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $r = new ReflectionMethod($media, 'buildCommand');\n        $r->setAccessible(true);\n\n        $this->assertEquals($expected, $r->invokeArgs($media, [$binary, $url, $path, $options]));\n    }\n\n    public function dataForBuildCommand(): array\n    {\n        $theBinary = $this->getPHPExecutableFromPath() . ' -v'; // i.e.: '/usr/bin/php -v'\n\n        return [\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [],\n                $theBinary . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'foo' => null,\n                    'bar' => false,\n                    'baz' => [],\n                ],\n                $theBinary . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'foo' => 'foovalue',\n                    'bar' => ['barvalue1', 'barvalue2'],\n                    'baz' => true,\n                ],\n                $theBinary . ' --foo ' . \\escapeshellarg('foovalue') . ' --bar ' . \\escapeshellarg('barvalue1') . ' --bar ' . \\escapeshellarg('barvalue2') . ' --baz ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'cookie' => ['session' => 'bla', 'phpsess' => 12],\n                    'no-background' => '1',\n                ],\n                $theBinary . ' --cookie ' . \\escapeshellarg('session') . ' ' . \\escapeshellarg('bla') . ' --cookie ' . \\escapeshellarg('phpsess') . ' ' . \\escapeshellarg('12') . ' --no-background ' . \\escapeshellarg('1') . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'allow' => ['/path1', '/path2'],\n                    'no-background' => '1',\n                ],\n                $theBinary . ' --allow ' . \\escapeshellarg('/path1') . ' --allow ' . \\escapeshellarg('/path2') . ' --no-background ' . \\escapeshellarg('1') . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'image-dpi' => 100,\n                    'image-quality' => 50,\n                ],\n                $theBinary . ' ' . '--image-dpi 100 --image-quality 50 ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n        ];\n    }\n\n    public function testCheckOutput(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'filesize',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('fileExists')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(true))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('filesize')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(123))\n        ;\n\n        $r = new ReflectionMethod($media, 'checkOutput');\n        $r->setAccessible(true);\n\n        $message = '->checkOutput() checks both file existence and size';\n\n        try {\n            $r->invokeArgs($media, ['the_output_file', 'the command']);\n            $this->anything();\n        } catch (RuntimeException $e) {\n            $this->fail($message);\n        }\n    }\n\n    public function testCheckOutputWhenTheFileDoesNotExist(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'filesize',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('fileExists')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(false))\n        ;\n\n        $r = new ReflectionMethod($media, 'checkOutput');\n        $r->setAccessible(true);\n\n        $message = '->checkOutput() throws an InvalidArgumentException when the file does not exist';\n\n        try {\n            $r->invokeArgs($media, ['the_output_file', 'the command']);\n            $this->fail($message);\n        } catch (RuntimeException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testCheckOutputWhenTheFileIsEmpty(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'filesize',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('fileExists')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(true))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('filesize')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(0))\n        ;\n\n        $r = new ReflectionMethod($media, 'checkOutput');\n        $r->setAccessible(true);\n\n        $message = '->checkOutput() throws an InvalidArgumentException when the file is empty';\n\n        try {\n            $r->invokeArgs($media, ['the_output_file', 'the command']);\n            $this->fail($message);\n        } catch (RuntimeException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testCheckProcessStatus(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods(['configure'])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $r = new ReflectionMethod($media, 'checkProcessStatus');\n        $r->setAccessible(true);\n\n        try {\n            $r->invokeArgs($media, [0, '', '', 'the command']);\n            $this->anything();\n        } catch (RuntimeException $e) {\n            $this->fail('0 status means success');\n        }\n\n        try {\n            $r->invokeArgs($media, [1, '', '', 'the command']);\n            $this->anything();\n        } catch (RuntimeException $e) {\n            $this->fail('1 status means failure, but no stderr content');\n        }\n\n        try {\n            $r->invokeArgs($media, [1, '', 'Could not connect to X', 'the command']);\n            $this->fail('1 status means failure');\n        } catch (RuntimeException $e) {\n            $this->assertEquals(1, $e->getCode(), 'Exception thrown by checkProcessStatus should pass on the error code');\n        }\n    }\n\n    /**\n     * @dataProvider dataForIsAssociativeArray\n     */\n    public function testIsAssociativeArray(array $array, bool $isAssociativeArray): void\n    {\n        $generator = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $r = new ReflectionMethod($generator, 'isAssociativeArray');\n        $r->setAccessible(true);\n        $this->assertEquals($isAssociativeArray, $r->invokeArgs($generator, [$array]));\n    }\n\n    public function testItThrowsTheProperExceptionWhenFileExistsAndNotOverwritting(): void\n    {\n        $this->expectException(FileAlreadyExistsException::class);\n\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'isFile',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $media\n            ->expects($this->any())\n            ->method('fileExists')\n            ->will($this->returnValue(true))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('isFile')\n            ->will($this->returnValue(true))\n        ;\n        $r = new ReflectionMethod($media, 'prepareOutput');\n        $r->setAccessible(true);\n\n        $r->invokeArgs($media, ['', false]);\n    }\n\n    public function dataForIsAssociativeArray(): array\n    {\n        return [\n            [\n                ['key' => 'value'],\n                true,\n            ],\n            [\n                ['key' => 2],\n                true,\n            ],\n            [\n                ['key' => 'value', 'key2' => 'value2'],\n                true,\n            ],\n            [\n                [0 => 'value', 1 => 'value2', 'deux' => 'value3'],\n                true,\n            ],\n            [\n                [0 => 'value'],\n                false,\n            ],\n            [\n                [0 => 'value', 1 => 'value2', 3 => 'value3'],\n                false,\n            ],\n            [\n                ['0' => 'value', '1' => 'value2', '3' => 'value3'],\n                false,\n            ],\n            [\n                [],\n                false,\n            ],\n        ];\n    }\n\n    public function testCleanupEmptyTemporaryFiles(): void\n    {\n        $generator = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'unlink',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->getMock()\n        ;\n\n        $generator\n            ->expects($this->once())\n            ->method('unlink')\n        ;\n\n        $create = new ReflectionMethod($generator, 'createTemporaryFile');\n        $create->setAccessible(true);\n        $create->invoke($generator, null, null);\n\n        $files = new ReflectionProperty($generator, 'temporaryFiles');\n        $files->setAccessible(true);\n        $this->assertCount(1, $files->getValue($generator));\n\n        $remove = new ReflectionMethod($generator, 'removeTemporaryFiles');\n        $remove->setAccessible(true);\n        $remove->invoke($generator);\n    }\n\n    public function testleanupTemporaryFiles(): void\n    {\n        $generator = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'unlink',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->getMock()\n        ;\n\n        $generator\n            ->expects($this->once())\n            ->method('unlink')\n        ;\n\n        $create = new ReflectionMethod($generator, 'createTemporaryFile');\n        $create->setAccessible(true);\n        $create->invoke($generator, '<html/>', 'html');\n\n        $files = new ReflectionProperty($generator, 'temporaryFiles');\n        $files->setAccessible(true);\n        $this->assertCount(1, $files->getValue($generator));\n\n        $remove = new ReflectionMethod($generator, 'removeTemporaryFiles');\n        $remove->setAccessible(true);\n        $remove->invoke($generator);\n    }\n\n    public function testResetOptions(): void\n    {\n        $media = new class('/usr/local/bin/wkhtmltopdf') extends AbstractGenerator {\n            protected function configure(): void\n            {\n                $this->addOptions([\n                    'optionA' => null,\n                    'optionB' => 'abc',\n                ]);\n            }\n        };\n\n        $media->setOption('optionA', 'bar');\n\n        $this->assertEquals(\n            [\n                'optionA' => 'bar',\n                'optionB' => 'abc',\n            ],\n            $media->getOptions()\n        );\n\n        $media->resetOptions();\n\n        $this->assertEquals(\n            [\n                'optionA' => null,\n                'optionB' => 'abc',\n            ],\n            $media->getOptions()\n        );\n    }\n\n    public function testFailingGenerateWithOutputContainingPharPrefix(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'prepareOutput',\n            ])\n            ->setConstructorArgs(['the_binary', [], ['PATH' => '/usr/bin']])\n            ->getMock()\n        ;\n\n        $media->setTimeout(2000);\n\n        $media\n            ->expects($this->once())\n            ->method('prepareOutput')\n            ->with($this->equalTo('phar://the_output_file'))\n        ;\n\n        $this->expectException(InvalidArgumentException::class);\n\n        $media->generate('the_input_file', 'phar://the_output_file', ['foo' => 'bar']);\n    }\n\n    /**\n     * @return null|string\n     */\n    private function getPHPExecutableFromPath(): ?string\n    {\n        if (isset($_SERVER['_'])) {\n            return $_SERVER['_'];\n        }\n\n        if (@\\defined(\\PHP_BINARY)) {\n            return \\PHP_BINARY;\n        }\n\n        if (false === \\getenv('PATH')) {\n            return null;\n        }\n\n        $paths = \\explode(\\PATH_SEPARATOR, \\getenv('PATH'));\n        foreach ($paths as $path) {\n            // we need this for XAMPP (Windows)\n            if (\\strstr($path, 'php.exe') && isset($_SERVER['WINDIR']) && \\file_exists($path) && \\is_file($path)) {\n                return $path;\n            }\n            $php_executable = $path . \\DIRECTORY_SEPARATOR . 'php' . (isset($_SERVER['WINDIR']) ? '.exe' : '');\n            if (\\file_exists($php_executable) && \\is_file($php_executable)) {\n                return $php_executable;\n            }\n        }\n\n        return null; // not found\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Knp\\Snappy;\n\nuse Knp\\Snappy\\Exception\\FileAlreadyExistsException;\nuse Psr\\Log\\LoggerAwareInterface;\nuse Psr\\Log\\LoggerAwareTrait;\nuse Symfony\\Component\\Process\\Process;\nuse Exception;\nuse LogicException;\nuse RuntimeException;\nuse InvalidArgumentException;\n\n/**\n * Base generator class for medias.\n *\n * @author  Matthieu Bontemps <matthieu.bontemps@knplabs.com>\n * @author  Antoine H\u00e9rault <antoine.herault@knplabs.com>\n */\nabstract class AbstractGenerator implements GeneratorInterface, LoggerAwareInterface\n{\n    use LoggerAwareTrait;\n\n    /**\n     * @var array\n     */\n    public $temporaryFiles = [];\n\n    /**\n     * @var string\n     */\n    protected $temporaryFolder;\n\n    /**\n     * @var null|string\n     */\n    private $binary;\n\n    /**\n     * @var array\n     */\n    private $options = [];\n\n    /**\n     * @var null|array\n     */\n    private $env;\n\n    /**\n     * @var null|int\n     */\n    private $timeout;\n\n    /**\n     * @var string\n     */\n    private $defaultExtension;\n\n    /**\n     * @param null|string $binary\n     * @param array       $options\n     * @param null|array  $env\n     */\n    public function __construct($binary, array $options = [], array $env = null)\n    {\n        $this->configure();\n\n        $this->setBinary($binary);\n        $this->setOptions($options);\n        $this->env = empty($env) ? null : $env;\n\n        if (\\is_callable([$this, 'removeTemporaryFiles'])) {\n            \\register_shutdown_function([$this, 'removeTemporaryFiles']);\n        }\n    }\n\n    public function __destruct()\n    {\n        $this->removeTemporaryFiles();\n    }\n\n    /**\n     * Sets the default extension.\n     * Useful when letting Snappy deal with file creation.\n     *\n     * @param string $defaultExtension\n     *\n     * @return $this\n     */\n    public function setDefaultExtension($defaultExtension)\n    {\n        $this->defaultExtension = $defaultExtension;\n\n        return $this;\n    }\n\n    /**\n     * Gets the default extension.\n     *\n     * @return string\n     */\n    public function getDefaultExtension(): string\n    {\n        return $this->defaultExtension;\n    }\n\n    /**\n     * Sets an option. Be aware that option values are NOT validated and that\n     * it is your responsibility to validate user inputs.\n     *\n     * @param string $name  The option to set\n     * @param mixed  $value The value (NULL to unset)\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return $this\n     */\n    public function setOption($name, $value)\n    {\n        if (!\\array_key_exists($name, $this->options)) {\n            throw new InvalidArgumentException(\\sprintf('The option \\'%s\\' does not exist.', $name));\n        }\n\n        $this->options[$name] = $value;\n\n        if (null !== $this->logger) {\n            $this->logger->debug(\\sprintf('Set option \"%s\".', $name), ['value' => $value]);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Sets the timeout.\n     *\n     * @param null|int $timeout The timeout to set\n     *\n     * @return $this\n     */\n    public function setTimeout($timeout)\n    {\n        $this->timeout = $timeout;\n\n        return $this;\n    }\n\n    /**\n     * Sets an array of options.\n     *\n     * @param array $options An associative array of options as name/value\n     *\n     * @return $this\n     */\n    public function setOptions(array $options)\n    {\n        foreach ($options as $name => $value) {\n            $this->setOption($name, $value);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Returns all the options.\n     *\n     * @return array\n     */\n    public function getOptions()\n    {\n        return $this->options;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function generate($input, $output, array $options = [], $overwrite = false)\n    {\n        $this->prepareOutput($output, $overwrite);\n\n        $command = $this->getCommand($input, $output, $options);\n\n        $inputFiles = \\is_array($input) ? \\implode('\", \"', $input) : $input;\n\n        if (null !== $this->logger) {\n            $this->logger->info(\\sprintf('Generate from file(s) \"%s\" to file \"%s\".', $inputFiles, $output), [\n                'command' => $command,\n                'env' => $this->env,\n                'timeout' => $this->timeout,\n            ]);\n        }\n\n        try {\n            list($status, $stdout, $stderr) = $this->executeCommand($command);\n            $this->checkProcessStatus($status, $stdout, $stderr, $command);\n            $this->checkOutput($output, $command);\n        } catch (Exception $e) {\n            if (null !== $this->logger) {\n                $this->logger->error(\\sprintf('An error happened while generating \"%s\".', $output), [\n                    'command' => $command,\n                    'status' => $status ?? null,\n                    'stdout' => $stdout ?? null,\n                    'stderr' => $stderr ?? null,\n                ]);\n            }\n\n            throw $e;\n        }\n\n        if (null !== $this->logger) {\n            $this->logger->info(\\sprintf('File \"%s\" has been successfully generated.', $output), [\n                'command' => $command,\n                'stdout' => $stdout,\n                'stderr' => $stderr,\n            ]);\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function generateFromHtml($html, $output, array $options = [], $overwrite = false)\n    {\n        $fileNames = [];\n        if (\\is_array($html)) {\n            foreach ($html as $htmlInput) {\n                $fileNames[] = $this->createTemporaryFile($htmlInput, 'html');\n            }\n        } else {\n            $fileNames[] = $this->createTemporaryFile($html, 'html');\n        }\n\n        $this->generate($fileNames, $output, $options, $overwrite);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getOutput($input, array $options = [])\n    {\n        $filename = $this->createTemporaryFile(null, $this->getDefaultExtension());\n\n        $this->generate($input, $filename, $options);\n\n        return $this->getFileContents($filename);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function getOutputFromHtml($html, array $options = [])\n    {\n        $fileNames = [];\n        if (\\is_array($html)) {\n            foreach ($html as $htmlInput) {\n                $fileNames[] = $this->createTemporaryFile($htmlInput, 'html');\n            }\n        } else {\n            $fileNames[] = $this->createTemporaryFile($html, 'html');\n        }\n\n        return $this->getOutput($fileNames, $options);\n    }\n\n    /**\n     * Defines the binary.\n     *\n     * @param null|string $binary The path/name of the binary\n     *\n     * @return $this\n     */\n    public function setBinary($binary)\n    {\n        $this->binary = $binary;\n\n        return $this;\n    }\n\n    /**\n     * Returns the binary.\n     *\n     * @return null|string\n     */\n    public function getBinary()\n    {\n        return $this->binary;\n    }\n\n    /**\n     * Returns the command for the given input and output files.\n     *\n     * @param array|string $input   The input file\n     * @param string       $output  The ouput file\n     * @param array        $options An optional array of options that will be used\n     *                              only for this command\n     *\n     * @return string\n     */\n    public function getCommand($input, $output, array $options = [])\n    {\n        if (null === $this->binary) {\n            throw new LogicException('You must define a binary prior to conversion.');\n        }\n\n        $options = $this->mergeOptions($options);\n\n        return $this->buildCommand($this->binary, $input, $output, $options);\n    }\n\n    /**\n     * Removes all temporary files.\n     *\n     * @return void\n     */\n    public function removeTemporaryFiles()\n    {\n        foreach ($this->temporaryFiles as $file) {\n            $this->unlink($file);\n        }\n    }\n\n    /**\n     * Get TemporaryFolder.\n     *\n     * @return string\n     */\n    public function getTemporaryFolder()\n    {\n        if ($this->temporaryFolder === null) {\n            return \\sys_get_temp_dir();\n        }\n\n        return $this->temporaryFolder;\n    }\n\n    /**\n     * Set temporaryFolder.\n     *\n     * @param string $temporaryFolder\n     *\n     * @return $this\n     */\n    public function setTemporaryFolder($temporaryFolder)\n    {\n        $this->temporaryFolder = $temporaryFolder;\n\n        return $this;\n    }\n\n    /**\n     * Reset all options to their initial values.\n     *\n     * @return void\n     */\n    public function resetOptions()\n    {\n        $this->options = [];\n        $this->configure();\n    }\n\n    /**\n     * This method must configure the media options.\n     *\n     * @return void\n     *\n     * @see AbstractGenerator::addOption()\n     */\n    abstract protected function configure();\n\n    /**\n     * Adds an option.\n     *\n     * @param string $name    The name\n     * @param mixed  $default An optional default value\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return $this\n     */\n    protected function addOption($name, $default = null)\n    {\n        if (\\array_key_exists($name, $this->options)) {\n            throw new InvalidArgumentException(\\sprintf('The option \\'%s\\' already exists.', $name));\n        }\n\n        $this->options[$name] = $default;\n\n        return $this;\n    }\n\n    /**\n     * Adds an array of options.\n     *\n     * @param array $options\n     *\n     * @return $this\n     */\n    protected function addOptions(array $options)\n    {\n        foreach ($options as $name => $default) {\n            $this->addOption($name, $default);\n        }\n\n        return $this;\n    }\n\n    /**\n     * Merges the given array of options to the instance options and returns\n     * the result options array. It does NOT change the instance options.\n     *\n     * @param array $options\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return array\n     */\n    protected function mergeOptions(array $options)\n    {\n        $mergedOptions = $this->options;\n\n        foreach ($options as $name => $value) {\n            if (!\\array_key_exists($name, $mergedOptions)) {\n                throw new InvalidArgumentException(\\sprintf('The option \\'%s\\' does not exist.', $name));\n            }\n\n            $mergedOptions[$name] = $value;\n        }\n\n        return $mergedOptions;\n    }\n\n    /**\n     * Checks the specified output.\n     *\n     * @param string $output  The output filename\n     * @param string $command The generation command\n     *\n     * @throws RuntimeException if the output file generation failed\n     *\n     * @return void\n     */\n    protected function checkOutput($output, $command)\n    {\n        // the output file must exist\n        if (!$this->fileExists($output)) {\n            throw new RuntimeException(\\sprintf('The file \\'%s\\' was not created (command: %s).', $output, $command));\n        }\n\n        // the output file must not be empty\n        if (0 === $this->filesize($output)) {\n            throw new RuntimeException(\\sprintf('The file \\'%s\\' was created but is empty (command: %s).', $output, $command));\n        }\n    }\n\n    /**\n     * Checks the process return status.\n     *\n     * @param int    $status  The exit status code\n     * @param string $stdout  The stdout content\n     * @param string $stderr  The stderr content\n     * @param string $command The run command\n     *\n     * @throws RuntimeException if the output file generation failed\n     *\n     * @return void\n     */\n    protected function checkProcessStatus($status, $stdout, $stderr, $command)\n    {\n        if (0 !== $status && '' !== $stderr) {\n            throw new RuntimeException(\\sprintf('The exit status code \\'%s\\' says something went wrong:' . \"\\n\" . 'stderr: \"%s\"' . \"\\n\" . 'stdout: \"%s\"' . \"\\n\" . 'command: %s.', $status, $stderr, $stdout, $command), $status);\n        }\n    }\n\n    /**\n     * Creates a temporary file.\n     * The file is not created if the $content argument is null.\n     *\n     * @param null|string $content   Optional content for the temporary file\n     * @param null|string $extension An optional extension for the filename\n     *\n     * @return string The filename\n     */\n    protected function createTemporaryFile($content = null, $extension = null)\n    {\n        $dir = \\rtrim($this->getTemporaryFolder(), \\DIRECTORY_SEPARATOR);\n\n        if (!\\is_dir($dir)) {\n            if (false === @\\mkdir($dir, 0777, true) && !\\is_dir($dir)) {\n                throw new RuntimeException(\\sprintf(\"Unable to create directory: %s\\n\", $dir));\n            }\n        } elseif (!\\is_writable($dir)) {\n            throw new RuntimeException(\\sprintf(\"Unable to write in directory: %s\\n\", $dir));\n        }\n\n        $filename = $dir . \\DIRECTORY_SEPARATOR . \\uniqid('knp_snappy', true);\n\n        if (null !== $extension) {\n            $filename .= '.' . $extension;\n        }\n\n        if (null !== $content) {\n            \\file_put_contents($filename, $content);\n        }\n\n        $this->temporaryFiles[] = $filename;\n\n        return $filename;\n    }\n\n    /**\n     * Builds the command string.\n     *\n     * @param string       $binary  The binary path/name\n     * @param array|string $input   Url(s) or file location(s) of the page(s) to process\n     * @param string       $output  File location to the image-to-be\n     * @param array        $options An array of options\n     *\n     * @return string\n     */\n    protected function buildCommand($binary, $input, $output, array $options = [])\n    {\n        $command = $binary;\n        $escapedBinary = \\escapeshellarg($binary);\n        if (\\is_executable($escapedBinary)) {\n            $command = $escapedBinary;\n        }\n\n        foreach ($options as $key => $option) {\n            if (null !== $option && false !== $option) {\n                if (true === $option) {\n                    // Dont't put '--' if option is 'toc'.\n                    if ($key === 'toc') {\n                        $command .= ' ' . $key;\n                    } else {\n                        $command .= ' --' . $key;\n                    }\n                } elseif (\\is_array($option)) {\n                    if ($this->isAssociativeArray($option)) {\n                        foreach ($option as $k => $v) {\n                            $command .= ' --' . $key . ' ' . \\escapeshellarg($k) . ' ' . \\escapeshellarg($v);\n                        }\n                    } else {\n                        foreach ($option as $v) {\n                            $command .= ' --' . $key . ' ' . \\escapeshellarg($v);\n                        }\n                    }\n                } else {\n                    // Dont't add '--' if option is \"cover\"  or \"toc\".\n                    if (\\in_array($key, ['toc', 'cover'])) {\n                        $command .= ' ' . $key . ' ' . \\escapeshellarg($option);\n                    } elseif (\\in_array($key, ['image-dpi', 'image-quality'])) {\n                        $command .= ' --' . $key . ' ' . (int) $option;\n                    } else {\n                        $command .= ' --' . $key . ' ' . \\escapeshellarg($option);\n                    }\n                }\n            }\n        }\n\n        if (\\is_array($input)) {\n            foreach ($input as $i) {\n                $command .= ' ' . \\escapeshellarg($i) . ' ';\n            }\n            $command .= \\escapeshellarg($output);\n        } else {\n            $command .= ' ' . \\escapeshellarg($input) . ' ' . \\escapeshellarg($output);\n        }\n\n        return $command;\n    }\n\n    /**\n     * Return true if the array is an associative array\n     * and not an indexed array.\n     *\n     * @param array $array\n     *\n     * @return bool\n     */\n    protected function isAssociativeArray(array $array)\n    {\n        return (bool) \\count(\\array_filter(\\array_keys($array), 'is_string'));\n    }\n\n    /**\n     * Executes the given command via shell and returns the complete output as\n     * a string.\n     *\n     * @param string $command\n     *\n     * @return array [status, stdout, stderr]\n     */\n    protected function executeCommand($command)\n    {\n        if (\\method_exists(Process::class, 'fromShellCommandline')) {\n            $process = Process::fromShellCommandline($command, null, $this->env);\n        } else {\n            $process = new Process($command, null, $this->env);\n        }\n\n        if (null !== $this->timeout) {\n            $process->setTimeout($this->timeout);\n        }\n\n        $process->run();\n\n        return [\n            $process->getExitCode(),\n            $process->getOutput(),\n            $process->getErrorOutput(),\n        ];\n    }\n\n    /**\n     * Prepares the specified output.\n     *\n     * @param string $filename  The output filename\n     * @param bool   $overwrite Whether to overwrite the file if it already\n     *                          exist\n     *\n     * @throws FileAlreadyExistsException\n     * @throws RuntimeException\n     * @throws InvalidArgumentException\n     *\n     * @return void\n     */\n    protected function prepareOutput($filename, $overwrite)\n    {\n        if (false === $parsedFilename = \\parse_url($filename)) {\n            throw new InvalidArgumentException('The output filename is invalid.');\n        }\n\n        $scheme = isset($parsedFilename['scheme']) ? \\mb_strtolower($parsedFilename['scheme']) : '';\n        if ($scheme !== '' && $scheme !== 'file') {\n            throw new InvalidArgumentException(\\sprintf('The output file scheme is not supported. Expected \\'\\' or \\'file\\' but got \\'%s\\'.', $scheme));\n        }\n\n        $directory = \\dirname($filename);\n\n        if ($this->fileExists($filename)) {\n            if (!$this->isFile($filename)) {\n                throw new InvalidArgumentException(\\sprintf('The output file \\'%s\\' already exists and it is a %s.', $filename, $this->isDir($filename) ? 'directory' : 'link'));\n            }\n            if (false === $overwrite) {\n                throw new FileAlreadyExistsException(\\sprintf('The output file \\'%s\\' already exists.', $filename));\n            }\n            if (!$this->unlink($filename)) {\n                throw new RuntimeException(\\sprintf('Could not delete already existing output file \\'%s\\'.', $filename));\n            }\n        } elseif (!$this->isDir($directory) && !$this->mkdir($directory)) {\n            throw new RuntimeException(\\sprintf('The output file\\'s directory \\'%s\\' could not be created.', $directory));\n        }\n    }\n\n    /**\n     * Wrapper for the \"file_get_contents\" function.\n     *\n     * @param string $filename\n     *\n     * @return string\n     */\n    protected function getFileContents($filename)\n    {\n        $fileContent = \\file_get_contents($filename);\n\n        if (false === $fileContent) {\n            throw new RuntimeException(\\sprintf('Could not read file \\'%s\\' content.', $filename));\n        }\n\n        return $fileContent;\n    }\n\n    /**\n     * Wrapper for the \"file_exists\" function.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function fileExists($filename)\n    {\n        return \\file_exists($filename);\n    }\n\n    /**\n     * Wrapper for the \"is_file\" method.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function isFile($filename)\n    {\n        return \\strlen($filename) <= \\PHP_MAXPATHLEN && \\is_file($filename);\n    }\n\n    /**\n     * Wrapper for the \"filesize\" function.\n     *\n     * @param string $filename\n     *\n     * @return int\n     */\n    protected function filesize($filename)\n    {\n        $filesize = \\filesize($filename);\n\n        if (false === $filesize) {\n            throw new RuntimeException(\\sprintf('Could not read file \\'%s\\' size.', $filename));\n        }\n\n        return $filesize;\n    }\n\n    /**\n     * Wrapper for the \"unlink\" function.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function unlink($filename)\n    {\n        return $this->fileExists($filename) ? \\unlink($filename) : false;\n    }\n\n    /**\n     * Wrapper for the \"is_dir\" function.\n     *\n     * @param string $filename\n     *\n     * @return bool\n     */\n    protected function isDir($filename)\n    {\n        return \\is_dir($filename);\n    }\n\n    /**\n     * Wrapper for the mkdir function.\n     *\n     * @param string $pathname\n     *\n     * @return bool\n     */\n    protected function mkdir($pathname)\n    {\n        return \\mkdir($pathname, 0777, true);\n    }\n}\n", "<?php\n\nnamespace Tests\\Knp\\Snappy;\n\nuse Knp\\Snappy\\AbstractGenerator;\nuse Knp\\Snappy\\Exception\\FileAlreadyExistsException;\nuse PHPUnit\\Framework\\TestCase;\nuse Psr\\Log\\LoggerInterface;\nuse InvalidArgumentException;\nuse RuntimeException;\nuse ReflectionProperty;\nuse ReflectionMethod;\n\nclass AbstractGeneratorTest extends TestCase\n{\n    public function testAddOption(): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $this->assertEquals([], $media->getOptions());\n\n        $r = new ReflectionMethod($media, 'addOption');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, ['foo', 'bar']);\n\n        $this->assertEquals(['foo' => 'bar'], $media->getOptions(), '->addOption() adds an option');\n\n        $r->invokeArgs($media, ['baz', 'bat']);\n\n        $this->assertEquals(\n            [\n                'foo' => 'bar',\n                'baz' => 'bat',\n            ],\n            $media->getOptions(),\n            '->addOption() appends the option to the existing ones'\n        );\n\n        $message = '->addOption() raises an exception when the specified option already exists';\n\n        try {\n            $r->invokeArgs($media, ['baz', 'bat']);\n            $this->fail($message);\n            // @phpstan-ignore-next-line\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testAddOptions(): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $this->assertEquals([], $media->getOptions());\n\n        $r = new ReflectionMethod($media, 'addOptions');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, [['foo' => 'bar', 'baz' => 'bat']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'bar',\n                'baz' => 'bat',\n            ],\n            $media->getOptions(),\n            '->addOptions() adds all the given options'\n        );\n\n        $r->invokeArgs($media, [['ban' => 'bag', 'bal' => 'bac']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'bar',\n                'baz' => 'bat',\n                'ban' => 'bag',\n                'bal' => 'bac',\n            ],\n            $media->getOptions(),\n            '->addOptions() adds the given options to the existing ones'\n        );\n\n        $message = '->addOptions() raises an exception when one of the given options already exists';\n\n        try {\n            $r->invokeArgs($media, [['bak' => 'bam', 'bah' => 'bap', 'baz' => 'bat']]);\n            $this->fail($message);\n            // @phpstan-ignore-next-line\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testSetOption(): void\n    {\n        $media = $this\n            ->getMockBuilder(AbstractGenerator::class)\n            ->setConstructorArgs(['/usr/local/bin/wkhtmltopdf'])\n            ->getMockForAbstractClass()\n        ;\n\n        $logger = $this\n            ->getMockBuilder(LoggerInterface::class)\n            ->getMock()\n        ;\n        $media->setLogger($logger);\n        $logger->expects($this->once())->method('debug');\n\n        $r = new ReflectionMethod($media, 'addOption');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, ['foo', 'bar']);\n\n        $media->setOption('foo', 'abc');\n\n        $this->assertEquals(\n            [\n                'foo' => 'abc',\n            ],\n            $media->getOptions(),\n            '->setOption() defines the value of an option'\n        );\n\n        $message = '->setOption() raises an exception when the specified option does not exist';\n\n        try {\n            $media->setOption('bad', 'def');\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testSetOptions(): void\n    {\n        $media = $this\n            ->getMockBuilder(AbstractGenerator::class)\n            ->setConstructorArgs(['/usr/local/bin/wkhtmltopdf'])\n            ->getMockForAbstractClass()\n        ;\n\n        $logger = $this\n            ->getMockBuilder(LoggerInterface::class)\n            ->getMock()\n        ;\n        $media->setLogger($logger);\n        $logger->expects($this->exactly(4))->method('debug');\n\n        $r = new ReflectionMethod($media, 'addOptions');\n        $r->setAccessible(true);\n        $r->invokeArgs($media, [['foo' => 'bar', 'baz' => 'bat']]);\n\n        $media->setOptions(['foo' => 'abc', 'baz' => 'def']);\n\n        $this->assertEquals(\n            [\n                'foo' => 'abc',\n                'baz' => 'def',\n            ],\n            $media->getOptions(),\n            '->setOptions() defines the values of all the specified options'\n        );\n\n        $message = '->setOptions() raises an exception when one of the specified options does not exist';\n\n        try {\n            $media->setOptions(['foo' => 'abc', 'baz' => 'def', 'bad' => 'ghi']);\n            $this->fail($message);\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testGenerate(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'prepareOutput',\n                'getCommand',\n                'executeCommand',\n                'checkOutput',\n                'checkProcessStatus',\n            ])\n            ->setConstructorArgs(['the_binary', []])\n            ->getMock()\n        ;\n\n        $logger = $this\n            ->getMockBuilder(LoggerInterface::class)\n            ->getMock()\n        ;\n        $media->setLogger($logger);\n        $logger\n            ->expects($this->exactly(2))\n            ->method('info')\n            ->with(\n                $this->logicalOr(\n                    'Generate from file(s) \"the_input_file\" to file \"the_output_file\".',\n                    'File \"the_output_file\" has been successfully generated.'\n                ),\n                $this->logicalOr(\n                    ['command' => 'the command', 'env' => null, 'timeout' => false],\n                    ['command' => 'the command', 'stdout' => 'stdout', 'stderr' => 'stderr']\n                )\n            )\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('prepareOutput')\n            ->with($this->equalTo('the_output_file'))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('getCommand')\n            ->with(\n                $this->equalTo('the_input_file'),\n                $this->equalTo('the_output_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n            ->will($this->returnValue('the command'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('executeCommand')\n            ->with($this->equalTo('the command'))\n            ->willReturn([0, 'stdout', 'stderr'])\n        ;\n        $media\n            ->expects($this->once())\n            ->method('checkProcessStatus')\n            ->with(0, 'stdout', 'stderr', 'the command')\n        ;\n        $media\n            ->expects($this->once())\n            ->method('checkOutput')\n            ->with(\n                $this->equalTo('the_output_file'),\n                $this->equalTo('the command')\n            )\n        ;\n\n        $media->generate('the_input_file', 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testFailingGenerate(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'prepareOutput',\n                'getCommand',\n                'executeCommand',\n                'checkOutput',\n                'checkProcessStatus',\n            ])\n            ->setConstructorArgs(['the_binary', [], ['PATH' => '/usr/bin']])\n            ->getMock()\n        ;\n\n        $logger = $this->getMockBuilder(LoggerInterface::class)->getMock();\n        $media->setLogger($logger);\n        $media->setTimeout(2000);\n\n        $logger\n            ->expects($this->once())\n            ->method('info')\n            ->with(\n                $this->equalTo('Generate from file(s) \"the_input_file\" to file \"the_output_file\".'),\n                $this->equalTo(['command' => 'the command', 'env' => ['PATH' => '/usr/bin'], 'timeout' => 2000])\n            )\n        ;\n\n        $logger\n            ->expects($this->once())\n            ->method('error')\n            ->with(\n                $this->equalTo('An error happened while generating \"the_output_file\".'),\n                $this->equalTo(['command' => 'the command', 'status' => 1, 'stdout' => 'stdout', 'stderr' => 'stderr'])\n            )\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('prepareOutput')\n            ->with($this->equalTo('the_output_file'))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('getCommand')\n            ->with(\n                $this->equalTo('the_input_file'),\n                $this->equalTo('the_output_file')\n            )\n            ->will($this->returnValue('the command'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('executeCommand')\n            ->with($this->equalTo('the command'))\n            ->willReturn([1, 'stdout', 'stderr'])\n        ;\n        $media\n            ->expects($this->once())\n            ->method('checkProcessStatus')\n            ->with(1, 'stdout', 'stderr', 'the command')\n            ->willThrowException(new RuntimeException())\n        ;\n\n        $this->expectException(RuntimeException::class);\n\n        $media->generate('the_input_file', 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testGenerateFromHtml(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'generate',\n                'createTemporaryFile',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('generate')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo('the_output_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n        ;\n\n        $media->generateFromHtml('<html>foo</html>', 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testGenerateFromHtmlWithHtmlArray(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'generate',\n                'createTemporaryFile',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('generate')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo('the_output_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n        ;\n\n        $media->generateFromHtml(['<html>foo</html>'], 'the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testGetOutput(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'getDefaultExtension',\n                'createTemporaryFile',\n                'generate',\n                'getFileContents',\n                'unlink',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->any())\n            ->method('getDefaultExtension')\n            ->will($this->returnValue('ext'))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo(null),\n                $this->equalTo('ext')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('generate')\n            ->with(\n                $this->equalTo('the_input_file'),\n                $this->equalTo('the_temporary_file'),\n                $this->equalTo(['foo' => 'bar'])\n            )\n        ;\n        $media\n            ->expects($this->once())\n            ->method('getFileContents')\n            ->will($this->returnValue('the file contents'))\n        ;\n\n        $media\n            ->expects($this->any())\n            ->method('unlink')\n            ->with($this->equalTo('the_temporary_file'))\n            ->will($this->returnValue(true))\n        ;\n\n        $this->assertEquals('the file contents', $media->getOutput('the_input_file', ['foo' => 'bar']));\n    }\n\n    public function testGetOutputFromHtml(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'getOutput',\n                'createTemporaryFile',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('getOutput')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo(['foo' => 'bar'])\n            )\n            ->will($this->returnValue('the output'))\n        ;\n\n        $this->assertEquals('the output', $media->getOutputFromHtml('<html>foo</html>', ['foo' => 'bar']));\n    }\n\n    public function testGetOutputFromHtmlWithHtmlArray(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'getOutput',\n                'createTemporaryFile',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('createTemporaryFile')\n            ->with(\n                $this->equalTo('<html>foo</html>'),\n                $this->equalTo('html')\n            )\n            ->will($this->returnValue('the_temporary_file'))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('getOutput')\n            ->with(\n                $this->equalTo(['the_temporary_file']),\n                $this->equalTo(['foo' => 'bar'])\n            )\n            ->will($this->returnValue('the output'))\n        ;\n\n        $this->assertEquals('the output', $media->getOutputFromHtml(['<html>foo</html>'], ['foo' => 'bar']));\n    }\n\n    public function testMergeOptions(): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $originalOptions = ['foo' => 'bar', 'baz' => 'bat'];\n\n        $addOptions = new ReflectionMethod($media, 'addOptions');\n        $addOptions->setAccessible(true);\n        $addOptions->invokeArgs($media, [$originalOptions]);\n\n        $r = new ReflectionMethod($media, 'mergeOptions');\n        $r->setAccessible(true);\n\n        $mergedOptions = $r->invokeArgs($media, [['foo' => 'ban']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'ban',\n                'baz' => 'bat',\n            ],\n            $mergedOptions,\n            '->mergeOptions() merges an option to the instance ones and returns the result options array'\n        );\n\n        $this->assertEquals(\n            $originalOptions,\n            $media->getOptions(),\n            '->mergeOptions() does NOT change the instance options'\n        );\n\n        $mergedOptions = $r->invokeArgs($media, [['foo' => 'ban', 'baz' => 'bag']]);\n\n        $this->assertEquals(\n            [\n                'foo' => 'ban',\n                'baz' => 'bag',\n            ],\n            $mergedOptions,\n            '->mergeOptions() merges many options to the instance ones and returns the result options array'\n        );\n\n        $message = '->mergeOptions() throws an InvalidArgumentException once there is an undefined option in the given array';\n\n        try {\n            $r->invokeArgs($media, [['foo' => 'ban', 'bad' => 'bah']]);\n            $this->fail($message);\n            // @phpstan-ignore-next-line\n        } catch (InvalidArgumentException $e) {\n            $this->anything();\n        }\n    }\n\n    /**\n     * @dataProvider dataForBuildCommand\n     */\n    public function testBuildCommand(string $binary, string $url, string $path, array $options, string $expected): void\n    {\n        $media = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $r = new ReflectionMethod($media, 'buildCommand');\n        $r->setAccessible(true);\n\n        $this->assertEquals($expected, $r->invokeArgs($media, [$binary, $url, $path, $options]));\n    }\n\n    public function dataForBuildCommand(): array\n    {\n        $theBinary = $this->getPHPExecutableFromPath() . ' -v'; // i.e.: '/usr/bin/php -v'\n\n        return [\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [],\n                $theBinary . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'foo' => null,\n                    'bar' => false,\n                    'baz' => [],\n                ],\n                $theBinary . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'foo' => 'foovalue',\n                    'bar' => ['barvalue1', 'barvalue2'],\n                    'baz' => true,\n                ],\n                $theBinary . ' --foo ' . \\escapeshellarg('foovalue') . ' --bar ' . \\escapeshellarg('barvalue1') . ' --bar ' . \\escapeshellarg('barvalue2') . ' --baz ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'cookie' => ['session' => 'bla', 'phpsess' => 12],\n                    'no-background' => '1',\n                ],\n                $theBinary . ' --cookie ' . \\escapeshellarg('session') . ' ' . \\escapeshellarg('bla') . ' --cookie ' . \\escapeshellarg('phpsess') . ' ' . \\escapeshellarg('12') . ' --no-background ' . \\escapeshellarg('1') . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'allow' => ['/path1', '/path2'],\n                    'no-background' => '1',\n                ],\n                $theBinary . ' --allow ' . \\escapeshellarg('/path1') . ' --allow ' . \\escapeshellarg('/path2') . ' --no-background ' . \\escapeshellarg('1') . ' ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n            [\n                $theBinary,\n                'http://the.url/',\n                '/the/path',\n                [\n                    'image-dpi' => 100,\n                    'image-quality' => 50,\n                ],\n                $theBinary . ' ' . '--image-dpi 100 --image-quality 50 ' . \\escapeshellarg('http://the.url/') . ' ' . \\escapeshellarg('/the/path'),\n            ],\n        ];\n    }\n\n    public function testCheckOutput(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'filesize',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('fileExists')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(true))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('filesize')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(123))\n        ;\n\n        $r = new ReflectionMethod($media, 'checkOutput');\n        $r->setAccessible(true);\n\n        $message = '->checkOutput() checks both file existence and size';\n\n        try {\n            $r->invokeArgs($media, ['the_output_file', 'the command']);\n            $this->anything();\n        } catch (RuntimeException $e) {\n            $this->fail($message);\n        }\n    }\n\n    public function testCheckOutputWhenTheFileDoesNotExist(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'filesize',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n        $media\n            ->expects($this->once())\n            ->method('fileExists')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(false))\n        ;\n\n        $r = new ReflectionMethod($media, 'checkOutput');\n        $r->setAccessible(true);\n\n        $message = '->checkOutput() throws an InvalidArgumentException when the file does not exist';\n\n        try {\n            $r->invokeArgs($media, ['the_output_file', 'the command']);\n            $this->fail($message);\n        } catch (RuntimeException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testCheckOutputWhenTheFileIsEmpty(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'filesize',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $media\n            ->expects($this->once())\n            ->method('fileExists')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(true))\n        ;\n        $media\n            ->expects($this->once())\n            ->method('filesize')\n            ->with($this->equalTo('the_output_file'))\n            ->will($this->returnValue(0))\n        ;\n\n        $r = new ReflectionMethod($media, 'checkOutput');\n        $r->setAccessible(true);\n\n        $message = '->checkOutput() throws an InvalidArgumentException when the file is empty';\n\n        try {\n            $r->invokeArgs($media, ['the_output_file', 'the command']);\n            $this->fail($message);\n        } catch (RuntimeException $e) {\n            $this->anything();\n        }\n    }\n\n    public function testCheckProcessStatus(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods(['configure'])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $r = new ReflectionMethod($media, 'checkProcessStatus');\n        $r->setAccessible(true);\n\n        try {\n            $r->invokeArgs($media, [0, '', '', 'the command']);\n            $this->anything();\n        } catch (RuntimeException $e) {\n            $this->fail('0 status means success');\n        }\n\n        try {\n            $r->invokeArgs($media, [1, '', '', 'the command']);\n            $this->anything();\n        } catch (RuntimeException $e) {\n            $this->fail('1 status means failure, but no stderr content');\n        }\n\n        try {\n            $r->invokeArgs($media, [1, '', 'Could not connect to X', 'the command']);\n            $this->fail('1 status means failure');\n        } catch (RuntimeException $e) {\n            $this->assertEquals(1, $e->getCode(), 'Exception thrown by checkProcessStatus should pass on the error code');\n        }\n    }\n\n    /**\n     * @dataProvider dataForIsAssociativeArray\n     */\n    public function testIsAssociativeArray(array $array, bool $isAssociativeArray): void\n    {\n        $generator = $this->getMockForAbstractClass(AbstractGenerator::class, [], '', false);\n\n        $r = new ReflectionMethod($generator, 'isAssociativeArray');\n        $r->setAccessible(true);\n        $this->assertEquals($isAssociativeArray, $r->invokeArgs($generator, [$array]));\n    }\n\n    public function testItThrowsTheProperExceptionWhenFileExistsAndNotOverwritting(): void\n    {\n        $this->expectException(FileAlreadyExistsException::class);\n\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'fileExists',\n                'isFile',\n            ])\n            ->disableOriginalConstructor()\n            ->getMock()\n        ;\n\n        $media\n            ->expects($this->any())\n            ->method('fileExists')\n            ->will($this->returnValue(true))\n        ;\n        $media\n            ->expects($this->any())\n            ->method('isFile')\n            ->will($this->returnValue(true))\n        ;\n        $r = new ReflectionMethod($media, 'prepareOutput');\n        $r->setAccessible(true);\n\n        $r->invokeArgs($media, ['', false]);\n    }\n\n    public function dataForIsAssociativeArray(): array\n    {\n        return [\n            [\n                ['key' => 'value'],\n                true,\n            ],\n            [\n                ['key' => 2],\n                true,\n            ],\n            [\n                ['key' => 'value', 'key2' => 'value2'],\n                true,\n            ],\n            [\n                [0 => 'value', 1 => 'value2', 'deux' => 'value3'],\n                true,\n            ],\n            [\n                [0 => 'value'],\n                false,\n            ],\n            [\n                [0 => 'value', 1 => 'value2', 3 => 'value3'],\n                false,\n            ],\n            [\n                ['0' => 'value', '1' => 'value2', '3' => 'value3'],\n                false,\n            ],\n            [\n                [],\n                false,\n            ],\n        ];\n    }\n\n    public function testCleanupEmptyTemporaryFiles(): void\n    {\n        $generator = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'unlink',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->getMock()\n        ;\n\n        $generator\n            ->expects($this->once())\n            ->method('unlink')\n        ;\n\n        $create = new ReflectionMethod($generator, 'createTemporaryFile');\n        $create->setAccessible(true);\n        $create->invoke($generator, null, null);\n\n        $files = new ReflectionProperty($generator, 'temporaryFiles');\n        $files->setAccessible(true);\n        $this->assertCount(1, $files->getValue($generator));\n\n        $remove = new ReflectionMethod($generator, 'removeTemporaryFiles');\n        $remove->setAccessible(true);\n        $remove->invoke($generator);\n    }\n\n    public function testleanupTemporaryFiles(): void\n    {\n        $generator = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'unlink',\n            ])\n            ->setConstructorArgs(['the_binary'])\n            ->getMock()\n        ;\n\n        $generator\n            ->expects($this->once())\n            ->method('unlink')\n        ;\n\n        $create = new ReflectionMethod($generator, 'createTemporaryFile');\n        $create->setAccessible(true);\n        $create->invoke($generator, '<html/>', 'html');\n\n        $files = new ReflectionProperty($generator, 'temporaryFiles');\n        $files->setAccessible(true);\n        $this->assertCount(1, $files->getValue($generator));\n\n        $remove = new ReflectionMethod($generator, 'removeTemporaryFiles');\n        $remove->setAccessible(true);\n        $remove->invoke($generator);\n    }\n\n    public function testResetOptions(): void\n    {\n        $media = new class('/usr/local/bin/wkhtmltopdf') extends AbstractGenerator {\n            protected function configure(): void\n            {\n                $this->addOptions([\n                    'optionA' => null,\n                    'optionB' => 'abc',\n                ]);\n            }\n        };\n\n        $media->setOption('optionA', 'bar');\n\n        $this->assertEquals(\n            [\n                'optionA' => 'bar',\n                'optionB' => 'abc',\n            ],\n            $media->getOptions()\n        );\n\n        $media->resetOptions();\n\n        $this->assertEquals(\n            [\n                'optionA' => null,\n                'optionB' => 'abc',\n            ],\n            $media->getOptions()\n        );\n    }\n\n    public function testFailingGenerateWithOutputContainingPharPrefix(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'prepareOutput',\n            ])\n            ->setConstructorArgs(['the_binary', [], ['PATH' => '/usr/bin']])\n            ->getMock()\n        ;\n\n        $media->setTimeout(2000);\n\n        $media\n            ->expects($this->once())\n            ->method('prepareOutput')\n            ->with($this->equalTo('phar://the_output_file'))\n        ;\n\n        $this->expectException(InvalidArgumentException::class);\n\n        $media->generate('the_input_file', 'phar://the_output_file', ['foo' => 'bar']);\n    }\n\n    public function testFailingGenerateWithOutputContainingUppercasePharPrefix(): void\n    {\n        $media = $this->getMockBuilder(AbstractGenerator::class)\n            ->setMethods([\n                'configure',\n                'prepareOutput',\n            ])\n            ->setConstructorArgs(['the_binary', [], ['PATH' => '/usr/bin']])\n            ->getMock()\n        ;\n\n        $media->setTimeout(2000);\n\n        $media\n            ->expects($this->once())\n            ->method('prepareOutput')\n            ->with($this->equalTo('PHAR://the_output_file'))\n        ;\n\n        $this->expectException(InvalidArgumentException::class);\n\n        $media->generate('the_input_file', 'PHAR://the_output_file', ['foo' => 'bar']);\n    }\n\n    /**\n     * @return null|string\n     */\n    private function getPHPExecutableFromPath(): ?string\n    {\n        if (isset($_SERVER['_'])) {\n            return $_SERVER['_'];\n        }\n\n        if (@\\defined(\\PHP_BINARY)) {\n            return \\PHP_BINARY;\n        }\n\n        if (false === \\getenv('PATH')) {\n            return null;\n        }\n\n        $paths = \\explode(\\PATH_SEPARATOR, \\getenv('PATH'));\n        foreach ($paths as $path) {\n            // we need this for XAMPP (Windows)\n            if (\\strstr($path, 'php.exe') && isset($_SERVER['WINDIR']) && \\file_exists($path) && \\is_file($path)) {\n                return $path;\n            }\n            $php_executable = $path . \\DIRECTORY_SEPARATOR . 'php' . (isset($_SERVER['WINDIR']) ? '.exe' : '');\n            if (\\file_exists($php_executable) && \\is_file($php_executable)) {\n                return $php_executable;\n            }\n        }\n\n        return null; // not found\n    }\n}\n"], "filenames": ["src/Knp/Snappy/AbstractGenerator.php", "tests/Knp/Snappy/AbstractGeneratorTest.php"], "buggy_code_start_loc": [628, 965], "buggy_code_end_loc": [630, 965], "fixing_code_start_loc": [628, 966], "fixing_code_end_loc": [635, 990], "type": "CWE-502", "message": "knplabs/knp-snappy is a PHP library allowing thumbnail, snapshot or PDF generation from a url or a html page.\n## Issue\n\nOn March 17th the vulnerability CVE-2023-28115 was disclosed, allowing an attacker to gain remote code execution through PHAR deserialization. Version 1.4.2 added a check `if (\\strpos($filename, 'phar://') === 0)` in the `prepareOutput` function to resolve this CVE, however if the user is able to control the second parameter of the `generateFromHtml()` function of Snappy, it will then be passed as the `$filename` parameter in the `prepareOutput()` function. In the original vulnerability, a file name with a `phar://` wrapper could be sent to the `fileExists()` function, equivalent to the `file_exists()` PHP function. This allowed users to trigger a deserialization on arbitrary PHAR files. To fix this issue, the string is now passed to the `strpos()` function and if it starts with `phar://`, an exception is raised. However, PHP wrappers being case insensitive, this patch can be bypassed using `PHAR://` instead of `phar://`. A successful exploitation of this vulnerability allows executing arbitrary code and accessing the underlying filesystem. The attacker must be able to upload a file and the server must be running a PHP version prior to 8. This issue has been addressed in commit `d3b742d61a` which has been included in version 1.4.3. Users are advised to upgrade. Users unable to upgrade should ensure that only trusted users may submit data to the `AbstractGenerator->generate(...)` function.\n", "other": {"cve": {"id": "CVE-2023-41330", "sourceIdentifier": "security-advisories@github.com", "published": "2023-09-06T18:15:09.153", "lastModified": "2023-09-12T20:42:58.853", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "knplabs/knp-snappy is a PHP library allowing thumbnail, snapshot or PDF generation from a url or a html page.\n## Issue\n\nOn March 17th the vulnerability CVE-2023-28115 was disclosed, allowing an attacker to gain remote code execution through PHAR deserialization. Version 1.4.2 added a check `if (\\strpos($filename, 'phar://') === 0)` in the `prepareOutput` function to resolve this CVE, however if the user is able to control the second parameter of the `generateFromHtml()` function of Snappy, it will then be passed as the `$filename` parameter in the `prepareOutput()` function. In the original vulnerability, a file name with a `phar://` wrapper could be sent to the `fileExists()` function, equivalent to the `file_exists()` PHP function. This allowed users to trigger a deserialization on arbitrary PHAR files. To fix this issue, the string is now passed to the `strpos()` function and if it starts with `phar://`, an exception is raised. However, PHP wrappers being case insensitive, this patch can be bypassed using `PHAR://` instead of `phar://`. A successful exploitation of this vulnerability allows executing arbitrary code and accessing the underlying filesystem. The attacker must be able to upload a file and the server must be running a PHP version prior to 8. This issue has been addressed in commit `d3b742d61a` which has been included in version 1.4.3. Users are advised to upgrade. Users unable to upgrade should ensure that only trusted users may submit data to the `AbstractGenerator->generate(...)` function.\n"}, {"lang": "es", "value": "knplabs/knp-snappy es una librer\u00eda PHP que permite la generaci\u00f3n de thumbnail, snapshots o PDFs desde una URL o una p\u00e1gina HTML. ## El problema que revel\u00f3 la vulnerabilidad CVE-2023-28115 el 17 de marzo, permite a un atacante obtener la ejecuci\u00f3n remota de c\u00f3digo mediante la deserializaci\u00f3n PHAR. La versi\u00f3n 1.4.2 agreg\u00f3 una verificaci\u00f3n `if (\\strpos($filename, 'phar://') === 0)` en la funci\u00f3n `prepareOutput` para resolver este CVE, sin embargo, si el usuario puede controlar el segundo par\u00e1metro de la funci\u00f3n `generateFromHtml()` de Snappy, luego se pasar\u00e1 como el par\u00e1metro `$filename` en la funci\u00f3n `prepareOutput()`. En la vulnerabilidad original, un nombre de archivo con un contenedor `phar://` podr\u00eda enviarse a la funci\u00f3n `fileExists()`, equivalente a la funci\u00f3n PHP `file_exists()`. Esto permiti\u00f3 a los usuarios activar una deserializaci\u00f3n en archivos PHAR arbitrarios. Para solucionar este problema, la cadena ahora se pasa a la funci\u00f3n `strpos()` y si comienza con `phar://`, se genera una excepci\u00f3n. Sin embargo, como los contenedores de PHP no distinguen entre may\u00fasculas y min\u00fasculas, este parche se puede omitir usando `PHAR://` en lugar de `phar://`. Una explotaci\u00f3n exitosa de esta vulnerabilidad permite ejecutar c\u00f3digo arbitrario y acceder al sistema de archivos subyacente. El atacante debe poder cargar un archivo y el servidor debe ejecutar una versi\u00f3n de PHP anterior a la 8. Este problema se solucion\u00f3 en el commit `d3b742d61a` que se incluy\u00f3 en la versi\u00f3n 1.4.3. Se recomienda a los usuarios que actualicen. Los usuarios que no puedan actualizar deben asegurarse de que solo los usuarios confiables puedan enviar datos a la funci\u00f3n `AbstractGenerator-&gt;generate(...)`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:knplabs:snappy:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.3", "matchCriteriaId": "C2412BC7-4738-4E4B-9382-9C967F55BEC0"}]}]}], "references": [{"url": "https://github.com/KnpLabs/snappy/commit/d3b742d61a68bf93866032c2c0a7f1486128b67e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/KnpLabs/snappy/security/advisories/GHSA-92rv-4j2h-8mjj", "source": "security-advisories@github.com", "tags": ["Exploit", "Mitigation", "Vendor Advisory"]}, {"url": "https://github.com/KnpLabs/snappy/security/advisories/GHSA-gq6w-q6wh-jggc", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/KnpLabs/snappy/commit/d3b742d61a68bf93866032c2c0a7f1486128b67e"}}