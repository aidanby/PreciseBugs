{"buggy_code": ["# -*- coding: utf-8 -*-\n# frozen_string_literal: true\n#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\n\nrequire 'rubygems/version'\nrequire 'rubygems/requirement'\nrequire 'rubygems/platform'\nrequire 'rubygems/deprecate'\nrequire 'rubygems/basic_specification'\nrequire 'rubygems/stub_specification'\nrequire 'rubygems/util/list'\nrequire 'stringio'\n\n##\n# The Specification class contains the information for a Gem.  Typically\n# defined in a .gemspec file or a Rakefile, and looks like this:\n#\n#   Gem::Specification.new do |s|\n#     s.name        = 'example'\n#     s.version     = '0.1.0'\n#     s.licenses    = ['MIT']\n#     s.summary     = \"This is an example!\"\n#     s.description = \"Much longer explanation of the example!\"\n#     s.authors     = [\"Ruby Coder\"]\n#     s.email       = 'rubycoder@example.com'\n#     s.files       = [\"lib/example.rb\"]\n#     s.homepage    = 'https://rubygems.org/gems/example'\n#     s.metadata    = { \"source_code_uri\" => \"https://github.com/example/example\" }\n#   end\n#\n# Starting in RubyGems 2.0, a Specification can hold arbitrary\n# metadata.  See #metadata for restrictions on the format and size of metadata\n# items you may add to a specification.\n\nclass Gem::Specification < Gem::BasicSpecification\n\n  # REFACTOR: Consider breaking out this version stuff into a separate\n  # module. There's enough special stuff around it that it may justify\n  # a separate class.\n\n  ##\n  # The version number of a specification that does not specify one\n  # (i.e. RubyGems 0.7 or earlier).\n\n  NONEXISTENT_SPECIFICATION_VERSION = -1\n\n  ##\n  # The specification version applied to any new Specification instances\n  # created.  This should be bumped whenever something in the spec format\n  # changes.\n  #\n  # Specification Version History:\n  #\n  #   spec   ruby\n  #    ver    ver yyyy-mm-dd description\n  #     -1 <0.8.0            pre-spec-version-history\n  #      1  0.8.0 2004-08-01 Deprecated \"test_suite_file\" for \"test_files\"\n  #                          \"test_file=x\" is a shortcut for \"test_files=[x]\"\n  #      2  0.9.5 2007-10-01 Added \"required_rubygems_version\"\n  #                          Now forward-compatible with future versions\n  #      3  1.3.2 2009-01-03 Added Fixnum validation to specification_version\n  #      4  1.9.0 2011-06-07 Added metadata\n  #--\n  # When updating this number, be sure to also update #to_ruby.\n  #\n  # NOTE RubyGems < 1.2 cannot load specification versions > 2.\n\n  CURRENT_SPECIFICATION_VERSION = 4 # :nodoc:\n\n  ##\n  # An informal list of changes to the specification.  The highest-valued\n  # key should be equal to the CURRENT_SPECIFICATION_VERSION.\n\n  SPECIFICATION_VERSION_HISTORY = { # :nodoc:\n    -1 => ['(RubyGems versions up to and including 0.7 did not have versioned specifications)'],\n    1  => [\n      'Deprecated \"test_suite_file\" in favor of the new, but equivalent, \"test_files\"',\n      '\"test_file=x\" is a shortcut for \"test_files=[x]\"'\n    ],\n    2  => [\n      'Added \"required_rubygems_version\"',\n      'Now forward-compatible with future versions',\n    ],\n    3 => [\n       'Added Fixnum validation to the specification_version'\n    ],\n    4 => [\n      'Added sandboxed freeform metadata to the specification version.'\n    ]\n  }\n\n  MARSHAL_FIELDS = { # :nodoc:\n    -1 => 16,\n     1 => 16,\n     2 => 16,\n     3 => 17,\n     4 => 18,\n  }\n\n  today = Time.now.utc\n  TODAY = Time.utc(today.year, today.month, today.day) # :nodoc:\n\n  LOAD_CACHE = {} # :nodoc:\n\n  private_constant :LOAD_CACHE if defined? private_constant\n\n  VALID_NAME_PATTERN = /\\A[a-zA-Z0-9\\.\\-\\_]+\\z/ # :nodoc:\n\n  # :startdoc:\n\n  ##\n  # List of attribute names: [:name, :version, ...]\n\n  @@required_attributes = [:rubygems_version,\n                           :specification_version,\n                           :name,\n                           :version,\n                           :date,\n                           :summary,\n                           :require_paths]\n\n  ##\n  # Map of attribute names to default values.\n\n  @@default_value = {\n    :authors                   => [],\n    :autorequire               => nil,\n    :bindir                    => 'bin',\n    :cert_chain                => [],\n    :date                      => TODAY,\n    :dependencies              => [],\n    :description               => nil,\n    :email                     => nil,\n    :executables               => [],\n    :extensions                => [],\n    :extra_rdoc_files          => [],\n    :files                     => [],\n    :homepage                  => nil,\n    :licenses                  => [],\n    :metadata                  => {},\n    :name                      => nil,\n    :platform                  => Gem::Platform::RUBY,\n    :post_install_message      => nil,\n    :rdoc_options              => [],\n    :require_paths             => ['lib'],\n    :required_ruby_version     => Gem::Requirement.default,\n    :required_rubygems_version => Gem::Requirement.default,\n    :requirements              => [],\n    :rubyforge_project         => nil,\n    :rubygems_version          => Gem::VERSION,\n    :signing_key               => nil,\n    :specification_version     => CURRENT_SPECIFICATION_VERSION,\n    :summary                   => nil,\n    :test_files                => [],\n    :version                   => nil,\n  }.freeze\n\n  INITIALIZE_CODE_FOR_DEFAULTS = { } # :nodoc:\n\n  @@default_value.each do |k,v|\n    INITIALIZE_CODE_FOR_DEFAULTS[k] = case v\n    when [], {}, true, false, nil, Numeric, Symbol\n      v.inspect\n    when String\n      v.dump\n    when Numeric\n       \"default_value(:#{k})\"\n    else\n       \"default_value(:#{k}).dup\"\n    end\n  end\n\n  @@attributes = @@default_value.keys.sort_by { |s| s.to_s }\n  @@array_attributes = @@default_value.reject { |k,v| v != [] }.keys\n  @@nil_attributes, @@non_nil_attributes = @@default_value.keys.partition { |k|\n    @@default_value[k].nil?\n  }\n\n  @@stubs_by_name = {}\n\n  # Sentinel object to represent \"not found\" stubs\n  NOT_FOUND = Struct.new(:to_spec, :this).new # :nodoc:\n  @@spec_with_requirable_file          = {}\n  @@active_stub_with_requirable_file   = {}\n\n  ######################################################################\n  # :section: Required gemspec attributes\n\n  ##\n  # This gem's name.\n  #\n  # Usage:\n  #\n  #   spec.name = 'rake'\n\n  attr_accessor :name\n\n  ##\n  # This gem's version.\n  #\n  # The version string can contain numbers and periods, such as +1.0.0+.\n  # A gem is a 'prerelease' gem if the version has a letter in it, such as\n  # +1.0.0.pre+.\n  #\n  # Usage:\n  #\n  #   spec.version = '0.4.1'\n\n  attr_reader :version\n\n  ##\n  # A short summary of this gem's description.  Displayed in `gem list -d`.\n  #\n  # The #description should be more detailed than the summary.\n  #\n  # Usage:\n  #\n  #   spec.summary = \"This is a small summary of my gem\"\n\n  attr_reader :summary\n\n  ##\n  # Files included in this gem.  You cannot append to this accessor, you must\n  # assign to it.\n  #\n  # Only add files you can require to this list, not directories, etc.\n  #\n  # Directories are automatically stripped from this list when building a gem,\n  # other non-files cause an error.\n  #\n  # Usage:\n  #\n  #   require 'rake'\n  #   spec.files = FileList['lib/**/*.rb',\n  #                         'bin/*',\n  #                         '[A-Z]*',\n  #                         'test/**/*'].to_a\n  #\n  #   # or without Rake...\n  #   spec.files = Dir['lib/**/*.rb'] + Dir['bin/*']\n  #   spec.files += Dir['[A-Z]*'] + Dir['test/**/*']\n  #   spec.files.reject! { |fn| fn.include? \"CVS\" }\n\n  def files\n    # DO NOT CHANGE TO ||= ! This is not a normal accessor. (yes, it sucks)\n    # DOC: Why isn't it normal? Why does it suck? How can we fix this?\n    @files = [@files,\n              @test_files,\n              add_bindir(@executables),\n              @extra_rdoc_files,\n              @extensions,\n             ].flatten.compact.uniq.sort\n  end\n\n  ######################################################################\n  # :section: Recommended gemspec attributes\n\n  ##\n  # Singular writer for #authors\n  #\n  # Usage:\n  #\n  #   spec.author = 'John Jones'\n\n  def author= o\n    self.authors = [o]\n  end\n\n  ##\n  # Sets the list of authors, ensuring it is an array.\n  #\n  # Usage:\n  #\n  #   spec.authors = ['John Jones', 'Mary Smith']\n\n  def authors= value\n    @authors = Array(value).flatten.grep(String)\n  end\n\n  ##\n  # A long description of this gem\n  #\n  # The description should be more detailed than the summary but not\n  # excessively long.  A few paragraphs is a recommended length with no\n  # examples or formatting.\n  #\n  # Usage:\n  #\n  #   spec.description = <<-EOF\n  #     Rake is a Make-like program implemented in Ruby. Tasks and\n  #     dependencies are specified in standard Ruby syntax.\n  #   EOF\n\n  attr_reader :description\n\n  ##\n  # A contact email address (or addresses) for this gem\n  #\n  # Usage:\n  #\n  #   spec.email = 'john.jones@example.com'\n  #   spec.email = ['jack@example.com', 'jill@example.com']\n\n  attr_accessor :email\n\n  ##\n  # The URL of this gem's home page\n  #\n  # Usage:\n  #\n  #   spec.homepage = 'https://github.com/ruby/rake'\n\n  attr_accessor :homepage\n\n  ##\n  # The license for this gem.\n  #\n  # The license must be no more than 64 characters.\n  #\n  # This should just be the name of your license. The full text of the license\n  # should be inside of the gem (at the top level) when you build it.\n  #\n  # The simplest way, is to specify the standard SPDX ID\n  # https://spdx.org/licenses/ for the license.\n  # Ideally you should pick one that is OSI (Open Source Initiative)\n  # http://opensource.org/licenses/alphabetical approved.\n  #\n  # The most commonly used OSI approved licenses are MIT and Apache-2.0.\n  # GitHub also provides a license picker at http://choosealicense.com/.\n  #\n  # You should specify a license for your gem so that people know how they are\n  # permitted to use it, and any restrictions you're placing on it.  Not\n  # specifying a license means all rights are reserved; others have no rights\n  # to use the code for any purpose.\n  #\n  # You can set multiple licenses with #licenses=\n  #\n  # Usage:\n  #   spec.license = 'MIT'\n\n  def license=o\n    self.licenses = [o]\n  end\n\n  ##\n  # The license(s) for the library.\n  #\n  # Each license must be a short name, no more than 64 characters.\n  #\n  # This should just be the name of your license. The full\n  # text of the license should be inside of the gem when you build it.\n  #\n  # See #license= for more discussion\n  #\n  # Usage:\n  #   spec.licenses = ['MIT', 'GPL-2.0']\n\n  def licenses= licenses\n    @licenses = Array licenses\n  end\n\n  ##\n  # The metadata holds extra data for this gem that may be useful to other\n  # consumers and is settable by gem authors without requiring an update to\n  # the rubygems software.\n  #\n  # Metadata items have the following restrictions:\n  #\n  # * The metadata must be a Hash object\n  # * All keys and values must be Strings\n  # * Keys can be a maximum of 128 bytes and values can be a maximum of 1024\n  #   bytes\n  # * All strings must be UTF-8, no binary data is allowed\n  #\n  # You can use metadata to specify links to your gem's homepage, codebase,\n  # documentation, wiki, mailing list, issue tracker and changelog.\n  #\n  #   s.metadata = {\n  #     \"bug_tracker_uri\"   => \"https://example.com/user/bestgemever/issues\",\n  #     \"changelog_uri\"     => \"https://example.com/user/bestgemever/CHANGELOG.md\",\n  #     \"documentation_uri\" => \"https://www.example.info/gems/bestgemever/0.0.1\",\n  #     \"homepage_uri\"      => \"https://bestgemever.example.io\",\n  #     \"mailing_list_uri\"  => \"https://groups.example.com/bestgemever\",\n  #     \"source_code_uri\"   => \"https://example.com/user/bestgemever\",\n  #     \"wiki_uri\"          => \"https://example.com/user/bestgemever/wiki\"\n  #   }\n  #\n  # These links will be used on your gem's page on rubygems.org and must pass\n  # validation against following regex.\n  #\n  #   %r{\\Ahttps?:\\/\\/([^\\s:@]+:[^\\s:@]*@)?[A-Za-z\\d\\-]+(\\.[A-Za-z\\d\\-]+)+\\.?(:\\d{1,5})?([\\/?]\\S*)?\\z}\n\n  attr_accessor :metadata\n\n  ######################################################################\n  # :section: Optional gemspec attributes\n\n  ##\n  # The path in the gem for executable scripts.  Usually 'bin'\n  #\n  # Usage:\n  #\n  #   spec.bindir = 'bin'\n\n  attr_accessor :bindir\n\n  ##\n  # The certificate chain used to sign this gem.  See Gem::Security for\n  # details.\n\n  attr_accessor :cert_chain\n\n  ##\n  # A message that gets displayed after the gem is installed.\n  #\n  # Usage:\n  #\n  #   spec.post_install_message = \"Thanks for installing!\"\n\n  attr_accessor :post_install_message\n\n  ##\n  # The platform this gem runs on.\n  #\n  # This is usually Gem::Platform::RUBY or Gem::Platform::CURRENT.\n  #\n  # Most gems contain pure Ruby code; they should simply leave the default\n  # value in place.  Some gems contain C (or other) code to be compiled into a\n  # Ruby \"extension\".  The gem should leave the default value in place unless\n  # the code will only compile on a certain type of system.  Some gems consist\n  # of pre-compiled code (\"binary gems\").  It's especially important that they\n  # set the platform attribute appropriately.  A shortcut is to set the\n  # platform to Gem::Platform::CURRENT, which will cause the gem builder to set\n  # the platform to the appropriate value for the system on which the build is\n  # being performed.\n  #\n  # If this attribute is set to a non-default value, it will be included in\n  # the filename of the gem when it is built such as:\n  # nokogiri-1.6.0-x86-mingw32.gem\n  #\n  # Usage:\n  #\n  #   spec.platform = Gem::Platform.local\n\n  def platform= platform\n    if @original_platform.nil? or\n       @original_platform == Gem::Platform::RUBY then\n      @original_platform = platform\n    end\n\n    case platform\n    when Gem::Platform::CURRENT then\n      @new_platform = Gem::Platform.local\n      @original_platform = @new_platform.to_s\n\n    when Gem::Platform then\n      @new_platform = platform\n\n    # legacy constants\n    when nil, Gem::Platform::RUBY then\n      @new_platform = Gem::Platform::RUBY\n    when 'mswin32' then # was Gem::Platform::WIN32\n      @new_platform = Gem::Platform.new 'x86-mswin32'\n    when 'i586-linux' then # was Gem::Platform::LINUX_586\n      @new_platform = Gem::Platform.new 'x86-linux'\n    when 'powerpc-darwin' then # was Gem::Platform::DARWIN\n      @new_platform = Gem::Platform.new 'ppc-darwin'\n    else\n      @new_platform = Gem::Platform.new platform\n    end\n\n    @platform = @new_platform.to_s\n\n    invalidate_memoized_attributes\n\n    @new_platform\n  end\n\n  ##\n  # Paths in the gem to add to <code>$LOAD_PATH</code> when this gem is\n  # activated.\n  #--\n  # See also #require_paths\n  #++\n  # If you have an extension you do not need to add <code>\"ext\"</code> to the\n  # require path, the extension build process will copy the extension files\n  # into \"lib\" for you.\n  #\n  # The default value is <code>\"lib\"</code>\n  #\n  # Usage:\n  #\n  #   # If all library files are in the root directory...\n  #   spec.require_paths = ['.']\n\n  def require_paths=(val)\n    @require_paths = Array(val)\n  end\n\n  ##\n  # The version of Ruby required by this gem\n\n  attr_reader :required_ruby_version\n\n  ##\n  # The RubyGems version required by this gem\n\n  attr_reader :required_rubygems_version\n\n  ##\n  # The version of RubyGems used to create this gem.\n  #\n  # Do not set this, it is set automatically when the gem is packaged.\n\n  attr_accessor :rubygems_version\n\n  ##\n  # The key used to sign this gem.  See Gem::Security for details.\n\n  attr_accessor :signing_key\n\n  ##\n  # Adds a development dependency named +gem+ with +requirements+ to this\n  # gem.\n  #\n  # Usage:\n  #\n  #   spec.add_development_dependency 'example', '~> 1.1', '>= 1.1.4'\n  #\n  # Development dependencies aren't installed by default and aren't\n  # activated when a gem is required.\n\n  def add_development_dependency(gem, *requirements)\n    add_dependency_with_type(gem, :development, requirements)\n  end\n\n  ##\n  # Adds a runtime dependency named +gem+ with +requirements+ to this gem.\n  #\n  # Usage:\n  #\n  #   spec.add_runtime_dependency 'example', '~> 1.1', '>= 1.1.4'\n\n  def add_runtime_dependency(gem, *requirements)\n    add_dependency_with_type(gem, :runtime, requirements)\n  end\n\n  ##\n  # Executables included in the gem.\n  #\n  # For example, the rake gem has rake as an executable. You don\u2019t specify the\n  # full path (as in bin/rake); all application-style files are expected to be\n  # found in bindir.  These files must be executable Ruby files.  Files that\n  # use bash or other interpreters will not work.\n  #\n  # Executables included may only be ruby scripts, not scripts for other\n  # languages or compiled binaries.\n  #\n  # Usage:\n  #\n  #   spec.executables << 'rake'\n\n  def executables\n    @executables ||= []\n  end\n\n  ##\n  # Extensions to build when installing the gem, specifically the paths to\n  # extconf.rb-style files used to compile extensions.\n  #\n  # These files will be run when the gem is installed, causing the C (or\n  # whatever) code to be compiled on the user\u2019s machine.\n  #\n  # Usage:\n  #\n  #  spec.extensions << 'ext/rmagic/extconf.rb'\n  #\n  # See Gem::Ext::Builder for information about writing extensions for gems.\n\n  def extensions\n    @extensions ||= []\n  end\n\n  ##\n  # Extra files to add to RDoc such as README or doc/examples.txt\n  #\n  # When the user elects to generate the RDoc documentation for a gem (typically\n  # at install time), all the library files are sent to RDoc for processing.\n  # This option allows you to have some non-code files included for a more\n  # complete set of documentation.\n  #\n  # Usage:\n  #\n  #  spec.extra_rdoc_files = ['README', 'doc/user-guide.txt']\n\n  def extra_rdoc_files\n    @extra_rdoc_files ||= []\n  end\n\n  ##\n  # The version of RubyGems that installed this gem.  Returns\n  # <code>Gem::Version.new(0)</code> for gems installed by versions earlier\n  # than RubyGems 2.2.0.\n\n  def installed_by_version # :nodoc:\n    @installed_by_version ||= Gem::Version.new(0)\n  end\n\n  ##\n  # Sets the version of RubyGems that installed this gem.  See also\n  # #installed_by_version.\n\n  def installed_by_version= version # :nodoc:\n    @installed_by_version = Gem::Version.new version\n  end\n\n  ##\n  # Specifies the rdoc options to be used when generating API documentation.\n  #\n  # Usage:\n  #\n  #   spec.rdoc_options << '--title' << 'Rake -- Ruby Make' <<\n  #     '--main' << 'README' <<\n  #     '--line-numbers'\n\n  def rdoc_options\n    @rdoc_options ||= []\n  end\n\n  ##\n  # The version of Ruby required by this gem.  The ruby version can be\n  # specified to the patch-level:\n  #\n  #   $ ruby -v -e 'p Gem.ruby_version'\n  #   ruby 2.0.0p247 (2013-06-27 revision 41674) [x86_64-darwin12.4.0]\n  #   #<Gem::Version \"2.0.0.247\">\n  #\n  # Because patch-level is taken into account, be very careful specifying using\n  # `<=`: `<= 2.2.2` will not match any patch-level of 2.2.2 after the `p0`\n  # release. It is much safer to specify `< 2.2.3` instead\n  #\n  # Usage:\n  #\n  #  # This gem will work with 1.8.6 or greater...\n  #  spec.required_ruby_version = '>= 1.8.6'\n  #\n  #  # Only with ruby 2.0.x\n  #  spec.required_ruby_version = '~> 2.0'\n  #\n  #  # Only with ruby between 2.2.0 and 2.2.2\n  #  spec.required_ruby_version = ['>= 2.2.0', '< 2.2.3']\n\n  def required_ruby_version= req\n    @required_ruby_version = Gem::Requirement.create req\n  end\n\n  ##\n  # The RubyGems version required by this gem\n\n  def required_rubygems_version= req\n    @required_rubygems_version = Gem::Requirement.create req\n  end\n\n  ##\n  # Lists the external (to RubyGems) requirements that must be met for this gem\n  # to work.  It's simply information for the user.\n  #\n  # Usage:\n  #\n  #   spec.requirements << 'libmagick, v6.0'\n  #   spec.requirements << 'A good graphics card'\n\n  def requirements\n    @requirements ||= []\n  end\n\n  ##\n  # A collection of unit test files.  They will be loaded as unit tests when\n  # the user requests a gem to be unit tested.\n  #\n  # Usage:\n  #   spec.test_files = Dir.glob('test/tc_*.rb')\n  #   spec.test_files = ['tests/test-suite.rb']\n\n  def test_files= files # :nodoc:\n    @test_files = Array files\n  end\n\n  ######################################################################\n  # :section: Specification internals\n\n  ##\n  # True when this gemspec has been activated. This attribute is not persisted.\n\n  attr_accessor :activated\n\n  alias :activated? :activated\n\n  ##\n  # Autorequire was used by old RubyGems to automatically require a file.\n  #\n  # Deprecated: It is neither supported nor functional.\n\n  attr_accessor :autorequire # :nodoc:\n\n  ##\n  # Sets the default executable for this gem.\n  #\n  # Deprecated: You must now specify the executable name to  Gem.bin_path.\n\n  attr_writer :default_executable\n\n  ##\n  # Allows deinstallation of gems with legacy platforms.\n\n  attr_writer :original_platform # :nodoc:\n\n  ##\n  # The rubyforge project this gem lives under.  i.e. RubyGems'\n  # rubyforge_project is \"rubygems\".\n  #\n  # This option is deprecated.\n\n  attr_accessor :rubyforge_project\n\n  ##\n  # The Gem::Specification version of this gemspec.\n  #\n  # Do not set this, it is set automatically when the gem is packaged.\n\n  attr_accessor :specification_version\n\n  def self._all # :nodoc:\n    unless defined?(@@all) && @@all then\n      @@all = stubs.map(&:to_spec)\n      if @@all.any?(&:nil?) # TODO: remove once we're happy\n        raise \"pid: #{$$} nil spec! included in #{stubs.inspect}\"\n      end\n\n      # After a reset, make sure already loaded specs\n      # are still marked as activated.\n      specs = {}\n      Gem.loaded_specs.each_value{|s| specs[s] = true}\n      @@all.each{|s| s.activated = true if specs[s]}\n    end\n    @@all\n  end\n\n  def self._clear_load_cache # :nodoc:\n    LOAD_CACHE.clear\n  end\n\n  def self.each_gemspec(dirs) # :nodoc:\n    dirs.each do |dir|\n      Dir[File.join(dir, \"*.gemspec\")].each do |path|\n        yield path.untaint\n      end\n    end\n  end\n\n  def self.gemspec_stubs_in dir, pattern\n    Dir[File.join(dir, pattern)].map { |path| yield path }.select(&:valid?)\n  end\n  private_class_method :gemspec_stubs_in\n\n  def self.default_stubs pattern\n    base_dir = Gem.default_dir\n    gems_dir = File.join base_dir, \"gems\"\n    gemspec_stubs_in(default_specifications_dir, pattern) do |path|\n      Gem::StubSpecification.default_gemspec_stub(path, base_dir, gems_dir)\n    end\n  end\n  private_class_method :default_stubs\n\n  def self.installed_stubs dirs, pattern\n    map_stubs(dirs, pattern) do |path, base_dir, gems_dir|\n      Gem::StubSpecification.gemspec_stub(path, base_dir, gems_dir)\n    end\n  end\n  private_class_method :installed_stubs\n\n  if [].respond_to? :flat_map\n    def self.map_stubs(dirs, pattern) # :nodoc:\n      dirs.flat_map { |dir|\n        base_dir = File.dirname dir\n        gems_dir = File.join base_dir, \"gems\"\n        gemspec_stubs_in(dir, pattern) { |path| yield path, base_dir, gems_dir }\n      }\n    end\n  else # FIXME: remove when 1.8 is dropped\n    def self.map_stubs(dirs, pattern) # :nodoc:\n      dirs.map { |dir|\n        base_dir = File.dirname dir\n        gems_dir = File.join base_dir, \"gems\"\n        gemspec_stubs_in(dir, pattern) { |path| yield path, base_dir, gems_dir }\n      }.flatten 1\n    end\n  end\n  private_class_method :map_stubs\n\n  uniq_takes_a_block = false\n  [1,2].uniq { uniq_takes_a_block = true }\n\n  if uniq_takes_a_block\n    def self.uniq_by(list, &block) # :nodoc:\n      list.uniq(&block)\n    end\n  else # FIXME: remove when 1.8 is dropped\n    def self.uniq_by(list) # :nodoc:\n      values = {}\n      list.each { |item|\n        value = yield item\n        values[value] ||= item\n      }\n      values.values\n    end\n  end\n  private_class_method :uniq_by\n\n  if [].respond_to? :sort_by!\n    def self.sort_by! list, &block\n      list.sort_by!(&block)\n    end\n  else # FIXME: remove when 1.8 is dropped\n    def self.sort_by! list, &block\n      list.replace list.sort_by(&block)\n    end\n  end\n  private_class_method :sort_by!\n\n  def self.each_spec(dirs) # :nodoc:\n    each_gemspec(dirs) do |path|\n      spec = self.load path\n      yield spec if spec\n    end\n  end\n\n  ##\n  # Returns a Gem::StubSpecification for every installed gem\n\n  def self.stubs\n    @@stubs ||= begin\n      pattern = \"*.gemspec\"\n      stubs = default_stubs(pattern).concat installed_stubs(dirs, pattern)\n      stubs = uniq_by(stubs) { |stub| stub.full_name }\n\n      _resort!(stubs)\n      @@stubs_by_name = stubs.group_by(&:name)\n      stubs\n    end\n  end\n\n  EMPTY = [].freeze # :nodoc:\n\n  ##\n  # Returns a Gem::StubSpecification for installed gem named +name+\n\n  def self.stubs_for name\n    if @@stubs\n      @@stubs_by_name[name] || []\n    else\n      pattern = \"#{name}-*.gemspec\"\n      stubs = default_stubs(pattern) + installed_stubs(dirs, pattern)\n      stubs = uniq_by(stubs) { |stub| stub.full_name }.group_by(&:name)\n      stubs.each_value { |v| _resort!(v) }\n\n      @@stubs_by_name.merge! stubs\n      @@stubs_by_name[name] ||= EMPTY\n    end\n  end\n\n  def self._resort!(specs) # :nodoc:\n    specs.sort! { |a, b|\n      names = a.name <=> b.name\n      next names if names.nonzero?\n      b.version <=> a.version\n    }\n  end\n\n  ##\n  # Loads the default specifications. It should be called only once.\n\n  def self.load_defaults\n    each_spec([default_specifications_dir]) do |spec|\n      # #load returns nil if the spec is bad, so we just ignore\n      # it at this stage\n      Gem.register_default_spec(spec)\n    end\n  end\n\n  ##\n  # Adds +spec+ to the known specifications, keeping the collection\n  # properly sorted.\n\n  def self.add_spec spec\n    warn \"Gem::Specification.add_spec is deprecated and will be removed in RubyGems 3.0\" unless Gem::Deprecate.skip\n    # TODO: find all extraneous adds\n    # puts\n    # p :add_spec => [spec.full_name, caller.reject { |s| s =~ /minitest/ }]\n\n    # TODO: flush the rest of the crap from the tests\n    # raise \"no dupes #{spec.full_name} in #{all_names.inspect}\" if\n    #   _all.include? spec\n\n    raise \"nil spec!\" unless spec # TODO: remove once we're happy with tests\n\n    return if _all.include? spec\n\n    _all << spec\n    stubs << spec\n    (@@stubs_by_name[spec.name] ||= []) << spec\n    sort_by!(@@stubs_by_name[spec.name]) { |s| s.version }\n    _resort!(_all)\n    _resort!(stubs)\n  end\n\n  ##\n  # Adds multiple specs to the known specifications.\n\n  def self.add_specs *specs\n    warn \"Gem::Specification.add_specs is deprecated and will be removed in RubyGems 3.0\" unless Gem::Deprecate.skip\n\n    raise \"nil spec!\" if specs.any?(&:nil?) # TODO: remove once we're happy\n\n    # TODO: this is much more efficient, but we need the extra checks for now\n    # _all.concat specs\n    # _resort!\n\n    Gem::Deprecate.skip_during do\n      specs.each do |spec| # TODO: slow\n        add_spec spec\n      end\n    end\n  end\n\n  ##\n  # Returns all specifications. This method is discouraged from use.\n  # You probably want to use one of the Enumerable methods instead.\n\n  def self.all\n    warn \"NOTE: Specification.all called from #{caller.first}\" unless\n      Gem::Deprecate.skip\n    _all\n  end\n\n  ##\n  # Sets the known specs to +specs+. Not guaranteed to work for you in\n  # the future. Use at your own risk. Caveat emptor. Doomy doom doom.\n  # Etc etc.\n  #\n  #--\n  # Makes +specs+ the known specs\n  # Listen, time is a river\n  # Winter comes, code breaks\n  #\n  # -- wilsonb\n\n  def self.all= specs\n    raise \"nil spec!\" if specs.any?(&:nil?) # TODO: remove once we're happy\n    @@stubs_by_name = specs.group_by(&:name)\n    @@all = @@stubs = specs\n  end\n\n  ##\n  # Return full names of all specs in sorted order.\n\n  def self.all_names\n    self._all.map(&:full_name)\n  end\n\n  ##\n  # Return the list of all array-oriented instance variables.\n  #--\n  # Not sure why we need to use so much stupid reflection in here...\n\n  def self.array_attributes\n    @@array_attributes.dup\n  end\n\n  ##\n  # Return the list of all instance variables.\n  #--\n  # Not sure why we need to use so much stupid reflection in here...\n\n  def self.attribute_names\n    @@attributes.dup\n  end\n\n  ##\n  # Return the directories that Specification uses to find specs.\n\n  def self.dirs\n    @@dirs ||= Gem.path.collect { |dir|\n      File.join dir.dup.untaint, \"specifications\"\n    }\n  end\n\n  ##\n  # Set the directories that Specification uses to find specs. Setting\n  # this resets the list of known specs.\n\n  def self.dirs= dirs\n    self.reset\n\n    @@dirs = Array(dirs).map { |dir| File.join dir, \"specifications\" }\n  end\n\n  extend Enumerable\n\n  ##\n  # Enumerate every known spec.  See ::dirs= and ::add_spec to set the list of\n  # specs.\n\n  def self.each\n    return enum_for(:each) unless block_given?\n\n    self._all.each do |x|\n      yield x\n    end\n  end\n\n  ##\n  # Returns every spec that matches +name+ and optional +requirements+.\n\n  def self.find_all_by_name name, *requirements\n    requirements = Gem::Requirement.default if requirements.empty?\n\n    # TODO: maybe try: find_all { |s| spec === dep }\n\n    Gem::Dependency.new(name, *requirements).matching_specs\n  end\n\n  ##\n  # Returns every spec that has the given +full_name+\n\n  def self.find_all_by_full_name(full_name)\n    stubs.select {|s| s.full_name == full_name }.map(&:to_spec)\n  end\n\n  ##\n  # Find the best specification matching a +name+ and +requirements+. Raises\n  # if the dependency doesn't resolve to a valid specification.\n\n  def self.find_by_name name, *requirements\n    requirements = Gem::Requirement.default if requirements.empty?\n\n    # TODO: maybe try: find { |s| spec === dep }\n\n    Gem::Dependency.new(name, *requirements).to_spec\n  end\n\n  ##\n  # Return the best specification that contains the file matching +path+.\n\n  def self.find_by_path path\n    path = path.dup.freeze\n    spec = @@spec_with_requirable_file[path] ||= (stubs.find { |s|\n      next unless Gem::BundlerVersionFinder.compatible?(s)\n      s.contains_requirable_file? path\n    } || NOT_FOUND)\n    spec.to_spec\n  end\n\n  ##\n  # Return the best specification that contains the file matching +path+\n  # amongst the specs that are not activated.\n\n  def self.find_inactive_by_path path\n    stub = stubs.find { |s|\n      next if s.activated?\n      next unless Gem::BundlerVersionFinder.compatible?(s)\n      s.contains_requirable_file? path\n    }\n    stub && stub.to_spec\n  end\n\n  def self.find_active_stub_by_path path\n    stub = @@active_stub_with_requirable_file[path] ||= (stubs.find { |s|\n      s.activated? and s.contains_requirable_file? path\n    } || NOT_FOUND)\n    stub.this\n  end\n\n  ##\n  # Return currently unresolved specs that contain the file matching +path+.\n\n  def self.find_in_unresolved path\n    # TODO: do we need these?? Kill it\n    specs = unresolved_deps.values.map { |dep| dep.to_specs }.flatten\n\n    specs.find_all { |spec| spec.contains_requirable_file? path }\n  end\n\n  ##\n  # Search through all unresolved deps and sub-dependencies and return\n  # specs that contain the file matching +path+.\n\n  def self.find_in_unresolved_tree path\n    specs = unresolved_deps.values.map { |dep| dep.to_specs }.flatten\n\n    specs.each do |spec|\n      spec.traverse do |from_spec, dep, to_spec, trail|\n        if to_spec.has_conflicts? || to_spec.conficts_when_loaded_with?(trail)\n          :next\n        else\n          return trail.reverse if to_spec.contains_requirable_file? path\n        end\n      end\n    end\n\n    []\n  end\n\n  ##\n  # Special loader for YAML files.  When a Specification object is loaded\n  # from a YAML file, it bypasses the normal Ruby object initialization\n  # routine (#initialize).  This method makes up for that and deals with\n  # gems of different ages.\n  #\n  # +input+ can be anything that YAML.load() accepts: String or IO.\n\n  def self.from_yaml(input)\n    Gem.load_yaml\n\n    input = normalize_yaml_input input\n    spec = Gem::SafeYAML.safe_load input\n\n    if spec && spec.class == FalseClass then\n      raise Gem::EndOfYAMLException\n    end\n\n    unless Gem::Specification === spec then\n      raise Gem::Exception, \"YAML data doesn't evaluate to gem specification\"\n    end\n\n    spec.specification_version ||= NONEXISTENT_SPECIFICATION_VERSION\n    spec.reset_nil_attributes_to_default\n\n    spec\n  end\n\n  ##\n  # Return the latest specs, optionally including prerelease specs if\n  # +prerelease+ is true.\n\n  def self.latest_specs prerelease = false\n    _latest_specs Gem::Specification._all, prerelease\n  end\n\n  def self._latest_specs specs, prerelease = false # :nodoc:\n    result = Hash.new { |h,k| h[k] = {} }\n    native = {}\n\n    specs.reverse_each do |spec|\n      next if spec.version.prerelease? unless prerelease\n\n      native[spec.name] = spec.version if spec.platform == Gem::Platform::RUBY\n      result[spec.name][spec.platform] = spec\n    end\n\n    result.map(&:last).map(&:values).flatten.reject { |spec|\n      minimum = native[spec.name]\n      minimum && spec.version < minimum\n    }.sort_by{ |tup| tup.name }\n  end\n\n  ##\n  # Loads Ruby format gemspec from +file+.\n\n  def self.load file\n    return unless file\n\n    _spec = LOAD_CACHE[file]\n    return _spec if _spec\n\n    file = file.dup.untaint\n    return unless File.file?(file)\n\n    code = if defined? Encoding\n             File.read file, :mode => 'r:UTF-8:-'\n           else\n             File.read file\n           end\n\n    code.untaint\n\n    begin\n      _spec = eval code, binding, file\n\n      if Gem::Specification === _spec\n        _spec.loaded_from = File.expand_path file.to_s\n        LOAD_CACHE[file] = _spec\n        return _spec\n      end\n\n      warn \"[#{file}] isn't a Gem::Specification (#{_spec.class} instead).\"\n    rescue SignalException, SystemExit\n      raise\n    rescue SyntaxError, Exception => e\n      warn \"Invalid gemspec in [#{file}]: #{e}\"\n    end\n\n    nil\n  end\n\n  ##\n  # Specification attributes that must be non-nil\n\n  def self.non_nil_attributes\n    @@non_nil_attributes.dup\n  end\n\n  ##\n  # Make sure the YAML specification is properly formatted with dashes\n\n  def self.normalize_yaml_input(input)\n    result = input.respond_to?(:read) ? input.read : input\n    result = \"--- \" + result unless result =~ /\\A--- /\n    result = result.dup\n    result.gsub!(/ !!null \\n/, \" \\n\")\n    # date: 2011-04-26 00:00:00.000000000Z\n    # date: 2011-04-26 00:00:00.000000000 Z\n    result.gsub!(/^(date: \\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d+?)Z/, '\\1 Z')\n    result\n  end\n\n  ##\n  # Return a list of all outdated local gem names.  This method is HEAVY\n  # as it must go fetch specifications from the server.\n  #\n  # Use outdated_and_latest_version if you wish to retrieve the latest remote\n  # version as well.\n\n  def self.outdated\n    outdated_and_latest_version.map { |local, _| local.name }\n  end\n\n  ##\n  # Enumerates the outdated local gems yielding the local specification and\n  # the latest remote version.\n  #\n  # This method may take some time to return as it must check each local gem\n  # against the server's index.\n\n  def self.outdated_and_latest_version\n    return enum_for __method__ unless block_given?\n\n    # TODO: maybe we should switch to rubygems' version service?\n    fetcher = Gem::SpecFetcher.fetcher\n\n    latest_specs(true).each do |local_spec|\n      dependency =\n        Gem::Dependency.new local_spec.name, \">= #{local_spec.version}\"\n\n      remotes, = fetcher.search_for_dependency dependency\n      remotes  = remotes.map { |n, _| n.version }\n\n      latest_remote = remotes.sort.last\n\n      yield [local_spec, latest_remote] if\n        latest_remote and local_spec.version < latest_remote\n    end\n\n    nil\n  end\n\n  ##\n  # Removes +spec+ from the known specs.\n\n  def self.remove_spec spec\n    warn \"Gem::Specification.remove_spec is deprecated and will be removed in RubyGems 3.0\" unless Gem::Deprecate.skip\n    _all.delete spec\n    stubs.delete_if { |s| s.full_name == spec.full_name }\n    (@@stubs_by_name[spec.name] || []).delete_if { |s| s.full_name == spec.full_name }\n    reset\n  end\n\n  ##\n  # Is +name+ a required attribute?\n\n  def self.required_attribute?(name)\n    @@required_attributes.include? name.to_sym\n  end\n\n  ##\n  # Required specification attributes\n\n  def self.required_attributes\n    @@required_attributes.dup\n  end\n\n  ##\n  # Reset the list of known specs, running pre and post reset hooks\n  # registered in Gem.\n\n  def self.reset\n    @@dirs = nil\n    Gem.pre_reset_hooks.each { |hook| hook.call }\n    @@all = nil\n    @@stubs = nil\n    @@stubs_by_name = {}\n    @@spec_with_requirable_file          = {}\n    @@active_stub_with_requirable_file   = {}\n    _clear_load_cache\n    unresolved = unresolved_deps\n    unless unresolved.empty? then\n      w = \"W\" + \"ARN\"\n      warn \"#{w}: Unresolved specs during Gem::Specification.reset:\"\n      unresolved.values.each do |dep|\n        warn \"      #{dep}\"\n      end\n      warn \"#{w}: Clearing out unresolved specs.\"\n      warn \"Please report a bug if this causes problems.\"\n      unresolved.clear\n    end\n    Gem.post_reset_hooks.each { |hook| hook.call }\n  end\n\n  # DOC: This method needs documented or nodoc'd\n  def self.unresolved_deps\n    @unresolved_deps ||= Hash.new { |h, n| h[n] = Gem::Dependency.new n }\n  end\n\n  ##\n  # Load custom marshal format, re-initializing defaults as needed\n\n  def self._load(str)\n    array = Marshal.load str\n\n    spec = Gem::Specification.new\n    spec.instance_variable_set :@specification_version, array[1]\n\n    current_version = CURRENT_SPECIFICATION_VERSION\n\n    field_count = if spec.specification_version > current_version then\n                    spec.instance_variable_set :@specification_version,\n                                               current_version\n                    MARSHAL_FIELDS[current_version]\n                  else\n                    MARSHAL_FIELDS[spec.specification_version]\n                  end\n\n    if array.size < field_count then\n      raise TypeError, \"invalid Gem::Specification format #{array.inspect}\"\n    end\n\n    # Cleanup any YAML::PrivateType. They only show up for an old bug\n    # where nil => null, so just convert them to nil based on the type.\n\n    array.map! { |e| e.kind_of?(YAML::PrivateType) ? nil : e }\n\n    spec.instance_variable_set :@rubygems_version,          array[0]\n    # spec version\n    spec.instance_variable_set :@name,                      array[2]\n    spec.instance_variable_set :@version,                   array[3]\n    spec.date =                                             array[4]\n    spec.instance_variable_set :@summary,                   array[5]\n    spec.instance_variable_set :@required_ruby_version,     array[6]\n    spec.instance_variable_set :@required_rubygems_version, array[7]\n    spec.instance_variable_set :@original_platform,         array[8]\n    spec.instance_variable_set :@dependencies,              array[9]\n    spec.instance_variable_set :@rubyforge_project,         array[10]\n    spec.instance_variable_set :@email,                     array[11]\n    spec.instance_variable_set :@authors,                   array[12]\n    spec.instance_variable_set :@description,               array[13]\n    spec.instance_variable_set :@homepage,                  array[14]\n    spec.instance_variable_set :@has_rdoc,                  array[15]\n    spec.instance_variable_set :@new_platform,              array[16]\n    spec.instance_variable_set :@platform,                  array[16].to_s\n    spec.instance_variable_set :@license,                   array[17]\n    spec.instance_variable_set :@metadata,                  array[18]\n    spec.instance_variable_set :@loaded,                    false\n    spec.instance_variable_set :@activated,                 false\n\n    spec\n  end\n\n  def <=>(other) # :nodoc:\n    sort_obj <=> other.sort_obj\n  end\n\n  def == other # :nodoc:\n    self.class === other &&\n      name == other.name &&\n      version == other.version &&\n      platform == other.platform\n  end\n\n  ##\n  # Dump only crucial instance variables.\n  #--\n  # MAINTAIN ORDER!\n  # (down with the man)\n\n  def _dump(limit)\n    Marshal.dump [\n      @rubygems_version,\n      @specification_version,\n      @name,\n      @version,\n      date,\n      @summary,\n      @required_ruby_version,\n      @required_rubygems_version,\n      @original_platform,\n      @dependencies,\n      @rubyforge_project,\n      @email,\n      @authors,\n      @description,\n      @homepage,\n      true, # has_rdoc\n      @new_platform,\n      @licenses,\n      @metadata\n    ]\n  end\n\n  ##\n  # Activate this spec, registering it as a loaded spec and adding\n  # it's lib paths to $LOAD_PATH. Returns true if the spec was\n  # activated, false if it was previously activated. Freaks out if\n  # there are conflicts upon activation.\n\n  def activate\n    other = Gem.loaded_specs[self.name]\n    if other then\n      check_version_conflict other\n      return false\n    end\n\n    raise_if_conflicts\n\n    activate_dependencies\n    add_self_to_load_path\n\n    Gem.loaded_specs[self.name] = self\n    @activated = true\n    @loaded = true\n\n    return true\n  end\n\n  ##\n  # Activate all unambiguously resolved runtime dependencies of this\n  # spec. Add any ambiguous dependencies to the unresolved list to be\n  # resolved later, as needed.\n\n  def activate_dependencies\n    unresolved = Gem::Specification.unresolved_deps\n\n    self.runtime_dependencies.each do |spec_dep|\n      if loaded = Gem.loaded_specs[spec_dep.name]\n        next if spec_dep.matches_spec? loaded\n\n        msg = \"can't satisfy '#{spec_dep}', already activated '#{loaded.full_name}'\"\n        e = Gem::LoadError.new msg\n        e.name = spec_dep.name\n\n        raise e\n      end\n\n      specs = spec_dep.to_specs\n\n      if specs.size == 1 then\n        specs.first.activate\n      else\n        name = spec_dep.name\n        unresolved[name] = unresolved[name].merge spec_dep\n      end\n    end\n\n    unresolved.delete self.name\n  end\n\n  ##\n  # Abbreviate the spec for downloading.  Abbreviated specs are only used for\n  # searching, downloading and related activities and do not need deployment\n  # specific information (e.g. list of files).  So we abbreviate the spec,\n  # making it much smaller for quicker downloads.\n\n  def abbreviate\n    self.files = []\n    self.test_files = []\n    self.rdoc_options = []\n    self.extra_rdoc_files = []\n    self.cert_chain = []\n  end\n\n  ##\n  # Sanitize the descriptive fields in the spec.  Sometimes non-ASCII\n  # characters will garble the site index.  Non-ASCII characters will\n  # be replaced by their XML entity equivalent.\n\n  def sanitize\n    self.summary              = sanitize_string(summary)\n    self.description          = sanitize_string(description)\n    self.post_install_message = sanitize_string(post_install_message)\n    self.authors              = authors.collect { |a| sanitize_string(a) }\n  end\n\n  ##\n  # Sanitize a single string.\n\n  def sanitize_string(string)\n    return string unless string\n\n    # HACK the #to_s is in here because RSpec has an Array of Arrays of\n    # Strings for authors.  Need a way to disallow bad values on gemspec\n    # generation.  (Probably won't happen.)\n    string = string.to_s\n\n    begin\n      Builder::XChar.encode string\n    rescue NameError, NoMethodError\n      string.to_xs\n    end\n  end\n\n  ##\n  # Returns an array with bindir attached to each executable in the\n  # +executables+ list\n\n  def add_bindir(executables)\n    return nil if executables.nil?\n\n    if @bindir then\n      Array(executables).map { |e| File.join(@bindir, e) }\n    else\n      executables\n    end\n  rescue\n    return nil\n  end\n\n  ##\n  # Adds a dependency on gem +dependency+ with type +type+ that requires\n  # +requirements+.  Valid types are currently <tt>:runtime</tt> and\n  # <tt>:development</tt>.\n\n  def add_dependency_with_type(dependency, type, requirements)\n    requirements = if requirements.empty? then\n                     Gem::Requirement.default\n                   else\n                     requirements.flatten\n                   end\n\n    unless dependency.respond_to?(:name) &&\n           dependency.respond_to?(:requirement)\n      dependency = Gem::Dependency.new(dependency.to_s, requirements, type)\n    end\n\n    dependencies << dependency\n  end\n\n  private :add_dependency_with_type\n\n  alias add_dependency add_runtime_dependency\n\n  ##\n  # Adds this spec's require paths to LOAD_PATH, in the proper location.\n\n  def add_self_to_load_path\n    return if default_gem?\n\n    paths = full_require_paths\n\n    # gem directories must come after -I and ENV['RUBYLIB']\n    insert_index = Gem.load_path_insert_index\n\n    if insert_index then\n      # gem directories must come after -I and ENV['RUBYLIB']\n      $LOAD_PATH.insert(insert_index, *paths)\n    else\n      # we are probably testing in core, -I and RUBYLIB don't apply\n      $LOAD_PATH.unshift(*paths)\n    end\n  end\n\n  ##\n  # Singular reader for #authors.  Returns the first author in the list\n\n  def author\n    val = authors and val.first\n  end\n\n  ##\n  # The list of author names who wrote this gem.\n  #\n  #   spec.authors = ['Chad Fowler', 'Jim Weirich', 'Rich Kilmer']\n\n  def authors\n    @authors ||= []\n  end\n\n  ##\n  # Returns the full path to installed gem's bin directory.\n  #\n  # NOTE: do not confuse this with +bindir+, which is just 'bin', not\n  # a full path.\n\n  def bin_dir\n    @bin_dir ||= File.join gem_dir, bindir # TODO: this is unfortunate\n  end\n\n  ##\n  # Returns the full path to an executable named +name+ in this gem.\n\n  def bin_file name\n    File.join bin_dir, name\n  end\n\n  ##\n  # Returns the build_args used to install the gem\n\n  def build_args\n    if File.exist? build_info_file\n      build_info = File.readlines build_info_file\n      build_info = build_info.map { |x| x.strip }\n      build_info.delete \"\"\n      build_info\n    else\n      []\n    end\n  end\n\n  ##\n  # Builds extensions for this platform if the gem has extensions listed and\n  # the gem.build_complete file is missing.\n\n  def build_extensions # :nodoc:\n    return if default_gem?\n    return if extensions.empty?\n    return if installed_by_version < Gem::Version.new('2.2.0.preview.2')\n    return if File.exist? gem_build_complete_path\n    return if !File.writable?(base_dir)\n    return if !File.exist?(File.join(base_dir, 'extensions'))\n\n    begin\n      # We need to require things in $LOAD_PATH without looking for the\n      # extension we are about to build.\n      unresolved_deps = Gem::Specification.unresolved_deps.dup\n      Gem::Specification.unresolved_deps.clear\n\n      require 'rubygems/config_file'\n      require 'rubygems/ext'\n      require 'rubygems/user_interaction'\n\n      ui = Gem::SilentUI.new\n      Gem::DefaultUserInteraction.use_ui ui do\n        builder = Gem::Ext::Builder.new self\n        builder.build_extensions\n      end\n    ensure\n      ui.close if ui\n      Gem::Specification.unresolved_deps.replace unresolved_deps\n    end\n  end\n\n  ##\n  # Returns the full path to the build info directory\n\n  def build_info_dir\n    File.join base_dir, \"build_info\"\n  end\n\n  ##\n  # Returns the full path to the file containing the build\n  # information generated when the gem was installed\n\n  def build_info_file\n    File.join build_info_dir, \"#{full_name}.info\"\n  end\n\n  ##\n  # Used to detect if the gem is bundled in older version of Ruby, but not\n  # detectable as default gem (see BasicSpecification#default_gem?).\n\n  def bundled_gem_in_old_ruby?\n    !default_gem? &&\n      RUBY_VERSION < \"2.0.0\" &&\n      summary == \"This #{name} is bundled with Ruby\"\n  end\n\n  ##\n  # Returns the full path to the cache directory containing this\n  # spec's cached gem.\n\n  def cache_dir\n    @cache_dir ||= File.join base_dir, \"cache\"\n  end\n\n  ##\n  # Returns the full path to the cached gem for this spec.\n\n  def cache_file\n    @cache_file ||= File.join cache_dir, \"#{full_name}.gem\"\n  end\n\n  ##\n  # Return any possible conflicts against the currently loaded specs.\n\n  def conflicts\n    conflicts = {}\n    self.runtime_dependencies.each { |dep|\n      spec = Gem.loaded_specs[dep.name]\n      if spec and not spec.satisfies_requirement? dep\n        (conflicts[spec] ||= []) << dep\n      end\n    }\n    env_req = Gem.env_requirement(name)\n    (conflicts[self] ||= []) << env_req unless env_req.satisfied_by? version\n    conflicts\n  end\n\n  ##\n  # return true if there will be conflict when spec if loaded together with the list of specs.\n\n  def conficts_when_loaded_with?(list_of_specs) # :nodoc:\n    result = list_of_specs.any? { |spec|\n      spec.dependencies.any? { |dep| dep.runtime? && (dep.name == name) && !satisfies_requirement?(dep) }\n    }\n    result\n  end\n\n  ##\n  # Return true if there are possible conflicts against the currently loaded specs.\n\n  def has_conflicts?\n    return true unless Gem.env_requirement(name).satisfied_by?(version)\n    self.dependencies.any? { |dep|\n      if dep.runtime? then\n        spec = Gem.loaded_specs[dep.name]\n        spec and not spec.satisfies_requirement? dep\n      else\n        false\n      end\n    }\n  end\n\n  ##\n  # The date this gem was created.  Lazily defaults to the current UTC date.\n  #\n  # There is no need to set this in your gem specification.\n\n  def date\n    @date ||= TODAY\n  end\n\n  DateLike = Object.new # :nodoc:\n  def DateLike.===(obj) # :nodoc:\n    defined?(::Date) and Date === obj\n  end\n\n  DateTimeFormat = # :nodoc:\n    /\\A\n     (\\d{4})-(\\d{2})-(\\d{2})\n     (\\s+ \\d{2}:\\d{2}:\\d{2}\\.\\d+ \\s* (Z | [-+]\\d\\d:\\d\\d) )?\n     \\Z/x\n\n  ##\n  # The date this gem was created\n  #\n  # DO NOT set this, it is set automatically when the gem is packaged.\n\n  def date= date\n    # We want to end up with a Time object with one-day resolution.\n    # This is the cleanest, most-readable, faster-than-using-Date\n    # way to do it.\n    @date = case date\n            when String then\n              if DateTimeFormat =~ date then\n                Time.utc($1.to_i, $2.to_i, $3.to_i)\n\n              # Workaround for where the date format output from psych isn't\n              # parsed as a Time object by syck and thus comes through as a\n              # string.\n              elsif /\\A(\\d{4})-(\\d{2})-(\\d{2}) \\d{2}:\\d{2}:\\d{2}\\.\\d+?Z\\z/ =~ date then\n                Time.utc($1.to_i, $2.to_i, $3.to_i)\n              else\n                raise(Gem::InvalidSpecificationException,\n                      \"invalid date format in specification: #{date.inspect}\")\n              end\n            when Time, DateLike then\n              Time.utc(date.year, date.month, date.day)\n            else\n              TODAY\n            end\n  end\n\n  ##\n  # The default executable for this gem.\n  #\n  # Deprecated: The name of the gem is assumed to be the name of the\n  # executable now.  See Gem.bin_path.\n\n  def default_executable # :nodoc:\n    if defined?(@default_executable) and @default_executable\n      result = @default_executable\n    elsif @executables and @executables.size == 1\n      result = Array(@executables).first\n    else\n      result = nil\n    end\n    result\n  end\n\n  ##\n  # The default value for specification attribute +name+\n\n  def default_value name\n    @@default_value[name]\n  end\n\n  ##\n  # A list of Gem::Dependency objects this gem depends on.\n  #\n  # Use #add_dependency or #add_development_dependency to add dependencies to\n  # a gem.\n\n  def dependencies\n    @dependencies ||= []\n  end\n\n  ##\n  # Return a list of all gems that have a dependency on this gemspec.  The\n  # list is structured with entries that conform to:\n  #\n  #   [depending_gem, dependency, [list_of_gems_that_satisfy_dependency]]\n\n  def dependent_gems\n    out = []\n    Gem::Specification.each do |spec|\n      spec.dependencies.each do |dep|\n        if self.satisfies_requirement?(dep) then\n          sats = []\n          find_all_satisfiers(dep) do |sat|\n            sats << sat\n          end\n          out << [spec, dep, sats]\n        end\n      end\n    end\n    out\n  end\n\n  ##\n  # Returns all specs that matches this spec's runtime dependencies.\n\n  def dependent_specs\n    runtime_dependencies.map { |dep| dep.to_specs }.flatten\n  end\n\n  ##\n  # A detailed description of this gem.  See also #summary\n\n  def description= str\n    @description = str.to_s\n  end\n\n  ##\n  # List of dependencies that are used for development\n\n  def development_dependencies\n    dependencies.select { |d| d.type == :development }\n  end\n\n  ##\n  # Returns the full path to this spec's documentation directory.  If +type+\n  # is given it will be appended to the end.  For example:\n  #\n  #   spec.doc_dir      # => \"/path/to/gem_repo/doc/a-1\"\n  #\n  #   spec.doc_dir 'ri' # => \"/path/to/gem_repo/doc/a-1/ri\"\n\n  def doc_dir type = nil\n    @doc_dir ||= File.join base_dir, 'doc', full_name\n\n    if type then\n      File.join @doc_dir, type\n    else\n      @doc_dir\n    end\n  end\n\n  def encode_with coder # :nodoc:\n    mark_version\n\n    coder.add 'name', @name\n    coder.add 'version', @version\n    platform = case @original_platform\n               when nil, '' then\n                 'ruby'\n               when String then\n                 @original_platform\n               else\n                 @original_platform.to_s\n               end\n    coder.add 'platform', platform\n\n    attributes = @@attributes.map(&:to_s) - %w[name version platform]\n    attributes.each do |name|\n      coder.add name, instance_variable_get(\"@#{name}\")\n    end\n  end\n\n  def eql? other # :nodoc:\n    self.class === other && same_attributes?(other)\n  end\n\n  ##\n  # Singular accessor for #executables\n\n  def executable\n    val = executables and val.first\n  end\n\n  ##\n  # Singular accessor for #executables\n\n  def executable=o\n    self.executables = [o]\n  end\n\n  ##\n  # Sets executables to +value+, ensuring it is an array. Don't\n  # use this, push onto the array instead.\n\n  def executables= value\n    # TODO: warn about setting instead of pushing\n    @executables = Array(value)\n  end\n\n  ##\n  # Sets extensions to +extensions+, ensuring it is an array. Don't\n  # use this, push onto the array instead.\n\n  def extensions= extensions\n    # TODO: warn about setting instead of pushing\n    @extensions = Array extensions\n  end\n\n  ##\n  # Sets extra_rdoc_files to +files+, ensuring it is an array. Don't\n  # use this, push onto the array instead.\n\n  def extra_rdoc_files= files\n    # TODO: warn about setting instead of pushing\n    @extra_rdoc_files = Array files\n  end\n\n  ##\n  # The default (generated) file name of the gem.  See also #spec_name.\n  #\n  #   spec.file_name # => \"example-1.0.gem\"\n\n  def file_name\n    \"#{full_name}.gem\"\n  end\n\n  ##\n  # Sets files to +files+, ensuring it is an array.\n\n  def files= files\n    @files = Array files\n  end\n\n  ##\n  # Finds all gems that satisfy +dep+\n\n  def find_all_satisfiers dep\n    Gem::Specification.each do |spec|\n      yield spec if spec.satisfies_requirement? dep\n    end\n  end\n\n  private :find_all_satisfiers\n\n  ##\n  # Creates a duplicate spec without large blobs that aren't used at runtime.\n\n  def for_cache\n    spec = dup\n\n    spec.files = nil\n    spec.test_files = nil\n\n    spec\n  end\n\n  def full_name\n    @full_name ||= super\n  end\n\n  ##\n  # Work around bundler removing my methods\n\n  def gem_dir # :nodoc:\n    super\n  end\n\n  def gems_dir\n    # TODO: this logic seems terribly broken, but tests fail if just base_dir\n    @gems_dir ||= File.join(loaded_from && base_dir || Gem.dir, \"gems\")\n  end\n\n  ##\n  # Deprecated and ignored, defaults to true.\n  #\n  # Formerly used to indicate this gem was RDoc-capable.\n\n  def has_rdoc # :nodoc:\n    true\n  end\n\n  ##\n  # Deprecated and ignored.\n  #\n  # Formerly used to indicate this gem was RDoc-capable.\n\n  def has_rdoc= ignored # :nodoc:\n    @has_rdoc = true\n  end\n\n  alias :has_rdoc? :has_rdoc # :nodoc:\n\n  ##\n  # True if this gem has files in test_files\n\n  def has_unit_tests? # :nodoc:\n    not test_files.empty?\n  end\n\n  # :stopdoc:\n  alias has_test_suite? has_unit_tests?\n  # :startdoc:\n\n  def hash # :nodoc:\n    name.hash ^ version.hash\n  end\n\n  def init_with coder # :nodoc:\n    @installed_by_version ||= nil\n    yaml_initialize coder.tag, coder.map\n  end\n\n\n\n  eval <<-RB, binding, __FILE__, __LINE__ + 1\n    def set_nil_attributes_to_nil\n      #{@@nil_attributes.map {|key| \"@#{key} = nil\" }.join \"; \"}\n    end\n    private :set_nil_attributes_to_nil\n\n    def set_not_nil_attributes_to_default_values\n      #{@@non_nil_attributes.map {|key| \"@#{key} = #{INITIALIZE_CODE_FOR_DEFAULTS[key]}\" }.join \";\"}\n    end\n    private :set_not_nil_attributes_to_default_values\n  RB\n\n  ##\n  # Specification constructor. Assigns the default values to the attributes\n  # and yields itself for further initialization.  Optionally takes +name+ and\n  # +version+.\n\n  def initialize name = nil, version = nil\n    super()\n    @gems_dir              = nil\n    @base_dir              = nil\n    @loaded = false\n    @activated = false\n    @loaded_from = nil\n    @original_platform = nil\n    @installed_by_version = nil\n\n    set_nil_attributes_to_nil\n    set_not_nil_attributes_to_default_values\n\n    @new_platform = Gem::Platform::RUBY\n\n    self.name = name if name\n    self.version = version if version\n\n    yield self if block_given?\n  end\n\n  ##\n  # Duplicates array_attributes from +other_spec+ so state isn't shared.\n\n  def initialize_copy other_spec\n    self.class.array_attributes.each do |name|\n      name = :\"@#{name}\"\n      next unless other_spec.instance_variable_defined? name\n\n      begin\n        val = other_spec.instance_variable_get(name)\n        if val then\n          instance_variable_set name, val.dup\n        elsif Gem.configuration.really_verbose\n          warn \"WARNING: #{full_name} has an invalid nil value for #{name}\"\n        end\n      rescue TypeError\n        e = Gem::FormatException.new \\\n          \"#{full_name} has an invalid value for #{name}\"\n\n        e.file_path = loaded_from\n        raise e\n      end\n    end\n  end\n\n  def base_dir\n    return Gem.dir unless loaded_from\n    @base_dir ||= if default_gem? then\n                    File.dirname File.dirname File.dirname loaded_from\n                  else\n                    File.dirname File.dirname loaded_from\n                  end\n  end\n\n  ##\n  # Expire memoized instance variables that can incorrectly generate, replace\n  # or miss files due changes in certain attributes used to compute them.\n\n  def invalidate_memoized_attributes\n    @full_name = nil\n    @cache_file = nil\n  end\n\n  private :invalidate_memoized_attributes\n\n  def inspect # :nodoc:\n    if $DEBUG\n      super\n    else\n      \"#{super[0..-2]} #{full_name}>\"\n    end\n  end\n\n  ##\n  # Files in the Gem under one of the require_paths\n\n  def lib_files\n    @files.select do |file|\n      require_paths.any? do |path|\n        file.start_with? path\n      end\n    end\n  end\n\n  ##\n  # Singular accessor for #licenses\n\n  def license\n    licenses.first\n  end\n\n  ##\n  # Plural accessor for setting licenses\n  #\n  # See #license= for details\n\n  def licenses\n    @licenses ||= []\n  end\n\n  def internal_init # :nodoc:\n    super\n    @bin_dir       = nil\n    @cache_dir     = nil\n    @cache_file    = nil\n    @doc_dir       = nil\n    @ri_dir        = nil\n    @spec_dir      = nil\n    @spec_file     = nil\n  end\n\n  ##\n  # Sets the rubygems_version to the current RubyGems version.\n\n  def mark_version\n    @rubygems_version = Gem::VERSION\n  end\n\n  ##\n  # Warn about unknown attributes while loading a spec.\n\n  def method_missing(sym, *a, &b) # :nodoc:\n    if @specification_version > CURRENT_SPECIFICATION_VERSION and\n      sym.to_s =~ /=$/ then\n      warn \"ignoring #{sym} loading #{full_name}\" if $DEBUG\n    else\n      super\n    end\n  end\n\n  ##\n  # Is this specification missing its extensions?  When this returns true you\n  # probably want to build_extensions\n\n  def missing_extensions?\n    return false if default_gem?\n    return false if extensions.empty?\n    return false if installed_by_version < Gem::Version.new('2.2.0.preview.2')\n    return false if File.exist? gem_build_complete_path\n\n    true\n  end\n\n  ##\n  # Normalize the list of files so that:\n  # * All file lists have redundancies removed.\n  # * Files referenced in the extra_rdoc_files are included in the package\n  #   file list.\n\n  def normalize\n    if defined?(@extra_rdoc_files) and @extra_rdoc_files then\n      @extra_rdoc_files.uniq!\n      @files ||= []\n      @files.concat(@extra_rdoc_files)\n    end\n\n    @files            = @files.uniq if @files\n    @extensions       = @extensions.uniq if @extensions\n    @test_files       = @test_files.uniq if @test_files\n    @executables      = @executables.uniq if @executables\n    @extra_rdoc_files = @extra_rdoc_files.uniq if @extra_rdoc_files\n  end\n\n  ##\n  # Return a NameTuple that represents this Specification\n\n  def name_tuple\n    Gem::NameTuple.new name, version, original_platform\n  end\n\n  ##\n  # Returns the full name (name-version) of this gemspec using the original\n  # platform.  For use with legacy gems.\n\n  def original_name # :nodoc:\n    if platform == Gem::Platform::RUBY or platform.nil? then\n      \"#{@name}-#{@version}\"\n    else\n      \"#{@name}-#{@version}-#{@original_platform}\"\n    end\n  end\n\n  ##\n  # Cruft. Use +platform+.\n\n  def original_platform # :nodoc:\n    @original_platform ||= platform\n  end\n\n  ##\n  # The platform this gem runs on.  See Gem::Platform for details.\n\n  def platform\n    @new_platform ||= Gem::Platform::RUBY\n  end\n\n  def pretty_print(q) # :nodoc:\n    q.group 2, 'Gem::Specification.new do |s|', 'end' do\n      q.breakable\n\n      attributes = @@attributes - [:name, :version]\n      attributes.unshift :installed_by_version\n      attributes.unshift :version\n      attributes.unshift :name\n\n      attributes.each do |attr_name|\n        current_value = self.send attr_name\n        if current_value != default_value(attr_name) or\n           self.class.required_attribute? attr_name then\n\n          q.text \"s.#{attr_name} = \"\n\n          if attr_name == :date then\n            current_value = current_value.utc\n\n            q.text \"Time.utc(#{current_value.year}, #{current_value.month}, #{current_value.day})\"\n          else\n            q.pp current_value\n          end\n\n          q.breakable\n        end\n      end\n    end\n  end\n\n  ##\n  # Raise an exception if the version of this spec conflicts with the one\n  # that is already loaded (+other+)\n\n  def check_version_conflict other # :nodoc:\n    return if self.version == other.version\n\n    # This gem is already loaded.  If the currently loaded gem is not in the\n    # list of candidate gems, then we have a version conflict.\n\n    msg = \"can't activate #{full_name}, already activated #{other.full_name}\"\n\n    e = Gem::LoadError.new msg\n    e.name = self.name\n    # TODO: e.requirement = dep.requirement\n\n    raise e\n  end\n\n  private :check_version_conflict\n\n  ##\n  # Check the spec for possible conflicts and freak out if there are any.\n\n  def raise_if_conflicts # :nodoc:\n    if has_conflicts? then\n      raise Gem::ConflictError.new self, conflicts\n    end\n  end\n\n  ##\n  # Sets rdoc_options to +value+, ensuring it is an array. Don't\n  # use this, push onto the array instead.\n\n  def rdoc_options= options\n    # TODO: warn about setting instead of pushing\n    @rdoc_options = Array options\n  end\n\n  ##\n  # Singular accessor for #require_paths\n\n  def require_path\n    val = require_paths and val.first\n  end\n\n  ##\n  # Singular accessor for #require_paths\n\n  def require_path= path\n    self.require_paths = Array(path)\n  end\n\n  ##\n  # Set requirements to +req+, ensuring it is an array. Don't\n  # use this, push onto the array instead.\n\n  def requirements= req\n    # TODO: warn about setting instead of pushing\n    @requirements = Array req\n  end\n\n  def respond_to_missing? m, include_private = false # :nodoc:\n    false\n  end\n\n  ##\n  # Returns the full path to this spec's ri directory.\n\n  def ri_dir\n    @ri_dir ||= File.join base_dir, 'ri', full_name\n  end\n\n  ##\n  # Return a string containing a Ruby code representation of the given\n  # object.\n\n  def ruby_code(obj)\n    case obj\n    when String            then obj.dump + \".freeze\"\n    when Array             then '[' + obj.map { |x| ruby_code x }.join(\", \") + ']'\n    when Hash              then\n      seg = obj.keys.sort.map { |k| \"#{k.to_s.dump} => #{obj[k].to_s.dump}\" }\n      \"{ #{seg.join(', ')} }\"\n    when Gem::Version      then obj.to_s.dump\n    when DateLike          then obj.strftime('%Y-%m-%d').dump\n    when Time              then obj.strftime('%Y-%m-%d').dump\n    when Numeric           then obj.inspect\n    when true, false, nil  then obj.inspect\n    when Gem::Platform     then \"Gem::Platform.new(#{obj.to_a.inspect})\"\n    when Gem::Requirement  then\n      list = obj.as_list\n      \"Gem::Requirement.new(#{ruby_code(list.size == 1 ? obj.to_s : list)})\"\n    else raise Gem::Exception, \"ruby_code case not handled: #{obj.class}\"\n    end\n  end\n\n  private :ruby_code\n\n  ##\n  # List of dependencies that will automatically be activated at runtime.\n\n  def runtime_dependencies\n    dependencies.select(&:runtime?)\n  end\n\n  ##\n  # True if this gem has the same attributes as +other+.\n\n  def same_attributes? spec\n    @@attributes.all? { |name, default| self.send(name) == spec.send(name) }\n  end\n\n  private :same_attributes?\n\n  ##\n  # Checks if this specification meets the requirement of +dependency+.\n\n  def satisfies_requirement? dependency\n    return @name == dependency.name &&\n      dependency.requirement.satisfied_by?(@version)\n  end\n\n  ##\n  # Returns an object you can use to sort specifications in #sort_by.\n\n  def sort_obj\n    [@name, @version, @new_platform == Gem::Platform::RUBY ? -1 : 1]\n  end\n\n  ##\n  # Used by Gem::Resolver to order Gem::Specification objects\n\n  def source # :nodoc:\n    Gem::Source::Installed.new\n  end\n\n  ##\n  # Returns the full path to the directory containing this spec's\n  # gemspec file. eg: /usr/local/lib/ruby/gems/1.8/specifications\n\n  def spec_dir\n    @spec_dir ||= File.join base_dir, \"specifications\"\n  end\n\n  ##\n  # Returns the full path to this spec's gemspec file.\n  # eg: /usr/local/lib/ruby/gems/1.8/specifications/mygem-1.0.gemspec\n\n  def spec_file\n    @spec_file ||= File.join spec_dir, \"#{full_name}.gemspec\"\n  end\n\n  ##\n  # The default name of the gemspec.  See also #file_name\n  #\n  #   spec.spec_name # => \"example-1.0.gemspec\"\n\n  def spec_name\n    \"#{full_name}.gemspec\"\n  end\n\n  ##\n  # A short summary of this gem's description.\n\n  def summary= str\n    @summary = str.to_s.strip.\n      gsub(/(\\w-)\\n[ \\t]*(\\w)/, '\\1\\2').gsub(/\\n[ \\t]*/, \" \") # so. weird.\n  end\n\n  ##\n  # Singular accessor for #test_files\n\n  def test_file # :nodoc:\n    val = test_files and val.first\n  end\n\n  ##\n  # Singular mutator for #test_files\n\n  def test_file= file # :nodoc:\n    self.test_files = [file]\n  end\n\n  ##\n  # Test files included in this gem.  You cannot append to this accessor, you\n  # must assign to it.\n\n  def test_files # :nodoc:\n    # Handle the possibility that we have @test_suite_file but not\n    # @test_files.  This will happen when an old gem is loaded via\n    # YAML.\n    if defined? @test_suite_file then\n      @test_files = [@test_suite_file].flatten\n      @test_suite_file = nil\n    end\n    if defined?(@test_files) and @test_files then\n      @test_files\n    else\n      @test_files = []\n    end\n  end\n\n  ##\n  # Returns a Ruby code representation of this specification, such that it can\n  # be eval'ed and reconstruct the same specification later.  Attributes that\n  # still have their default values are omitted.\n\n  def to_ruby\n    mark_version\n    result = []\n    result << \"# -*- encoding: utf-8 -*-\"\n    result << \"#{Gem::StubSpecification::PREFIX}#{name} #{version} #{platform} #{raw_require_paths.join(\"\\0\")}\"\n    result << \"#{Gem::StubSpecification::PREFIX}#{extensions.join \"\\0\"}\" unless\n      extensions.empty?\n    result << nil\n    result << \"Gem::Specification.new do |s|\"\n\n    result << \"  s.name = #{ruby_code name}\"\n    result << \"  s.version = #{ruby_code version}\"\n    unless platform.nil? or platform == Gem::Platform::RUBY then\n      result << \"  s.platform = #{ruby_code original_platform}\"\n    end\n    result << \"\"\n    result << \"  s.required_rubygems_version = #{ruby_code required_rubygems_version} if s.respond_to? :required_rubygems_version=\"\n\n    if metadata and !metadata.empty?\n      result << \"  s.metadata = #{ruby_code metadata} if s.respond_to? :metadata=\"\n    end\n    result << \"  s.require_paths = #{ruby_code raw_require_paths}\"\n\n    handled = [\n      :dependencies,\n      :name,\n      :platform,\n      :require_paths,\n      :required_rubygems_version,\n      :specification_version,\n      :version,\n      :has_rdoc,\n      :default_executable,\n      :metadata\n    ]\n\n    @@attributes.each do |attr_name|\n      next if handled.include? attr_name\n      current_value = self.send(attr_name)\n      if current_value != default_value(attr_name) or\n         self.class.required_attribute? attr_name then\n        result << \"  s.#{attr_name} = #{ruby_code current_value}\"\n      end\n    end\n\n    if @installed_by_version then\n      result << nil\n      result << \"  s.installed_by_version = \\\"#{Gem::VERSION}\\\" if s.respond_to? :installed_by_version\"\n    end\n\n    unless dependencies.empty? then\n      result << nil\n      result << \"  if s.respond_to? :specification_version then\"\n      result << \"    s.specification_version = #{specification_version}\"\n      result << nil\n\n      result << \"    if Gem::Version.new(Gem::VERSION) >= Gem::Version.new('1.2.0') then\"\n\n      dependencies.each do |dep|\n        req = dep.requirements_list.inspect\n        dep.instance_variable_set :@type, :runtime if dep.type.nil? # HACK\n        result << \"      s.add_#{dep.type}_dependency(%q<#{dep.name}>.freeze, #{req})\"\n      end\n\n      result << \"    else\"\n\n      dependencies.each do |dep|\n        version_reqs_param = dep.requirements_list.inspect\n        result << \"      s.add_dependency(%q<#{dep.name}>.freeze, #{version_reqs_param})\"\n      end\n\n      result << '    end'\n\n      result << \"  else\"\n      dependencies.each do |dep|\n        version_reqs_param = dep.requirements_list.inspect\n        result << \"    s.add_dependency(%q<#{dep.name}>.freeze, #{version_reqs_param})\"\n      end\n      result << \"  end\"\n    end\n\n    result << \"end\"\n    result << nil\n\n    result.join \"\\n\"\n  end\n\n  ##\n  # Returns a Ruby lighter-weight code representation of this specification,\n  # used for indexing only.\n  #\n  # See #to_ruby.\n\n  def to_ruby_for_cache\n    for_cache.to_ruby\n  end\n\n  def to_s # :nodoc:\n    \"#<Gem::Specification name=#{@name} version=#{@version}>\"\n  end\n\n  ##\n  # Returns self\n\n  def to_spec\n    self\n  end\n\n  def to_yaml(opts = {}) # :nodoc:\n    if (YAML.const_defined?(:ENGINE) && !YAML::ENGINE.syck?) ||\n        (defined?(Psych) && YAML == Psych) then\n      # Because the user can switch the YAML engine behind our\n      # back, we have to check again here to make sure that our\n      # psych code was properly loaded, and load it if not.\n      unless Gem.const_defined?(:NoAliasYAMLTree)\n        require 'rubygems/psych_tree'\n      end\n\n      builder = Gem::NoAliasYAMLTree.create\n      builder << self\n      ast = builder.tree\n\n      io = StringIO.new\n      io.set_encoding Encoding::UTF_8 if Object.const_defined? :Encoding\n\n      Psych::Visitors::Emitter.new(io).accept(ast)\n\n      io.string.gsub(/ !!null \\n/, \" \\n\")\n    else\n      YAML.quick_emit object_id, opts do |out|\n        out.map taguri, to_yaml_style do |map|\n          encode_with map\n        end\n      end\n    end\n  end\n\n  ##\n  # Recursively walk dependencies of this spec, executing the +block+ for each\n  # hop.\n\n  def traverse trail = [], visited = {}, &block\n    trail.push(self)\n    begin\n      dependencies.each do |dep|\n        next unless dep.runtime?\n        dep.to_specs.each do |dep_spec|\n          next if visited.has_key?(dep_spec)\n          visited[dep_spec] = true\n          trail.push(dep_spec)\n          begin\n            result = block[self, dep, dep_spec, trail]\n          ensure\n            trail.pop\n          end\n          unless result == :next\n            spec_name = dep_spec.name\n            dep_spec.traverse(trail, visited, &block) unless\n              trail.any? { |s| s.name == spec_name }\n          end\n        end\n      end\n    ensure\n      trail.pop\n    end\n  end\n\n  ##\n  # Checks that the specification contains all required fields, and does a\n  # very basic sanity check.\n  #\n  # Raises InvalidSpecificationException if the spec does not pass the\n  # checks..\n\n  def validate packaging = true\n    @warnings = 0\n    require 'rubygems/user_interaction'\n    extend Gem::UserInteraction\n    normalize\n\n    nil_attributes = self.class.non_nil_attributes.find_all do |attrname|\n      instance_variable_get(\"@#{attrname}\").nil?\n    end\n\n    unless nil_attributes.empty? then\n      raise Gem::InvalidSpecificationException,\n        \"#{nil_attributes.join ', '} must not be nil\"\n    end\n\n    if packaging and rubygems_version != Gem::VERSION then\n      raise Gem::InvalidSpecificationException,\n            \"expected RubyGems version #{Gem::VERSION}, was #{rubygems_version}\"\n    end\n\n    @@required_attributes.each do |symbol|\n      unless self.send symbol then\n        raise Gem::InvalidSpecificationException,\n              \"missing value for attribute #{symbol}\"\n      end\n    end\n\n    if !name.is_a?(String) then\n      raise Gem::InvalidSpecificationException,\n            \"invalid value for attribute name: \\\"#{name.inspect}\\\" must be a string\"\n    elsif name !~ /[a-zA-Z]/ then\n      raise Gem::InvalidSpecificationException,\n            \"invalid value for attribute name: #{name.dump} must include at least one letter\"\n    elsif name !~ VALID_NAME_PATTERN then\n      raise Gem::InvalidSpecificationException,\n            \"invalid value for attribute name: #{name.dump} can only include letters, numbers, dashes, and underscores\"\n    end\n\n    if raw_require_paths.empty? then\n      raise Gem::InvalidSpecificationException,\n            'specification must have at least one require_path'\n    end\n\n    @files.delete_if            { |x| File.directory?(x) && !File.symlink?(x) }\n    @test_files.delete_if       { |x| File.directory?(x) && !File.symlink?(x) }\n    @executables.delete_if      { |x| File.directory?(File.join(@bindir, x)) }\n    @extra_rdoc_files.delete_if { |x| File.directory?(x) && !File.symlink?(x) }\n    @extensions.delete_if       { |x| File.directory?(x) && !File.symlink?(x) }\n\n    non_files = files.reject { |x| File.file?(x) || File.symlink?(x) }\n\n    unless not packaging or non_files.empty? then\n      raise Gem::InvalidSpecificationException,\n            \"[\\\"#{non_files.join \"\\\", \\\"\"}\\\"] are not files\"\n    end\n\n    if files.include? file_name then\n      raise Gem::InvalidSpecificationException,\n            \"#{full_name} contains itself (#{file_name}), check your files list\"\n    end\n\n    unless specification_version.is_a?(Integer)\n      raise Gem::InvalidSpecificationException,\n            'specification_version must be an Integer (did you mean version?)'\n    end\n\n    case platform\n    when Gem::Platform, Gem::Platform::RUBY then # ok\n    else\n      raise Gem::InvalidSpecificationException,\n            \"invalid platform #{platform.inspect}, see Gem::Platform\"\n    end\n\n    self.class.array_attributes.each do |field|\n      val = self.send field\n      klass = case field\n              when :dependencies\n                Gem::Dependency\n              else\n                String\n              end\n\n      unless Array === val and val.all? { |x| x.kind_of?(klass) } then\n        raise(Gem::InvalidSpecificationException,\n              \"#{field} must be an Array of #{klass}\")\n      end\n    end\n\n    [:authors].each do |field|\n      val = self.send field\n      raise Gem::InvalidSpecificationException, \"#{field} may not be empty\" if\n        val.empty?\n    end\n\n    unless Hash === metadata\n      raise Gem::InvalidSpecificationException,\n              'metadata must be a hash'\n    end\n\n    validate_metadata\n\n    licenses.each { |license|\n      if license.length > 64\n        raise Gem::InvalidSpecificationException,\n          \"each license must be 64 characters or less\"\n      end\n\n      if !Gem::Licenses.match?(license)\n        suggestions = Gem::Licenses.suggestions(license)\n        message = <<-warning\nlicense value '#{license}' is invalid.  Use a license identifier from\nhttp://spdx.org/licenses or '#{Gem::Licenses::NONSTANDARD}' for a nonstandard license.\n        warning\n        message += \"Did you mean #{suggestions.map { |s| \"'#{s}'\"}.join(', ')}?\\n\" unless suggestions.nil?\n        warning(message)\n      end\n    }\n\n    warning <<-warning if licenses.empty?\nlicenses is empty, but is recommended.  Use a license identifier from\nhttp://spdx.org/licenses or '#{Gem::Licenses::NONSTANDARD}' for a nonstandard license.\n    warning\n\n    validate_permissions\n\n    # reject lazy developers:\n\n    lazy = '\"FIxxxXME\" or \"TOxxxDO\"'.gsub(/xxx/, '')\n\n    unless authors.grep(/FI XME|TO DO/x).empty? then\n      raise Gem::InvalidSpecificationException, \"#{lazy} is not an author\"\n    end\n\n    unless Array(email).grep(/FI XME|TO DO/x).empty? then\n      raise Gem::InvalidSpecificationException, \"#{lazy} is not an email\"\n    end\n\n    if description =~ /FI XME|TO DO/x then\n      raise Gem::InvalidSpecificationException, \"#{lazy} is not a description\"\n    end\n\n    if summary =~ /FI XME|TO DO/x then\n      raise Gem::InvalidSpecificationException, \"#{lazy} is not a summary\"\n    end\n\n    if homepage and not homepage.empty? and\n       homepage !~ /\\A[a-z][a-z\\d+.-]*:/i then\n      raise Gem::InvalidSpecificationException,\n            \"\\\"#{homepage}\\\" is not a URI\"\n    end\n\n    # Warnings\n\n    %w[author homepage summary files].each do |attribute|\n      value = self.send attribute\n      warning \"no #{attribute} specified\" if value.nil? or value.empty?\n    end\n\n    if description == summary then\n      warning 'description and summary are identical'\n    end\n\n    # TODO: raise at some given date\n    warning \"deprecated autorequire specified\" if autorequire\n\n    executables.each do |executable|\n      executable_path = File.join(bindir, executable)\n      shebang = File.read(executable_path, 2) == '#!'\n\n      warning \"#{executable_path} is missing #! line\" unless shebang\n    end\n\n    files.each do |file|\n      next unless File.symlink?(file)\n      warning \"#{file} is a symlink, which is not supported on all platforms\"\n    end\n\n    validate_dependencies\n\n    true\n  ensure\n    if $! or @warnings > 0 then\n      alert_warning \"See http://guides.rubygems.org/specification-reference/ for help\"\n    end\n  end\n\n  def validate_metadata\n    url_validation_regex = %r{\\Ahttps?:\\/\\/([^\\s:@]+:[^\\s:@]*@)?[A-Za-z\\d\\-]+(\\.[A-Za-z\\d\\-]+)+\\.?(:\\d{1,5})?([\\/?]\\S*)?\\z}\n    link_keys = %w(\n      bug_tracker_uri\n      changelog_uri\n      documentation_uri\n      homepage_uri\n      mailing_list_uri\n      source_code_uri\n      wiki_uri\n    )\n\n    metadata.each do|key, value|\n      if !key.kind_of?(String)\n        raise Gem::InvalidSpecificationException,\n                \"metadata keys must be a String\"\n      end\n\n      if key.size > 128\n        raise Gem::InvalidSpecificationException,\n                \"metadata key too large (#{key.size} > 128)\"\n      end\n\n      if !value.kind_of?(String)\n        raise Gem::InvalidSpecificationException,\n                \"metadata values must be a String\"\n      end\n\n      if value.size > 1024\n        raise Gem::InvalidSpecificationException,\n                \"metadata value too large (#{value.size} > 1024)\"\n      end\n\n      if link_keys.include? key\n        if value !~ url_validation_regex\n          raise Gem::InvalidSpecificationException,\n                 \"metadata['#{key}'] has invalid link: #{value.inspect}\"\n        end\n      end\n    end\n  end\n\n  ##\n  # Checks that dependencies use requirements as we recommend.  Warnings are\n  # issued when dependencies are open-ended or overly strict for semantic\n  # versioning.\n\n  def validate_dependencies # :nodoc:\n    # NOTE: see REFACTOR note in Gem::Dependency about types - this might be brittle\n    seen = Gem::Dependency::TYPES.inject({}) { |types, type| types.merge({ type => {}}) }\n\n    error_messages = []\n    warning_messages = []\n    dependencies.each do |dep|\n      if prev = seen[dep.type][dep.name] then\n        error_messages << <<-MESSAGE\nduplicate dependency on #{dep}, (#{prev.requirement}) use:\n    add_#{dep.type}_dependency '#{dep.name}', '#{dep.requirement}', '#{prev.requirement}'\n        MESSAGE\n      end\n\n      seen[dep.type][dep.name] = dep\n\n      prerelease_dep = dep.requirements_list.any? do |req|\n        Gem::Requirement.new(req).prerelease?\n      end\n\n      warning_messages << \"prerelease dependency on #{dep} is not recommended\" if\n        prerelease_dep && !version.prerelease?\n\n      overly_strict = dep.requirement.requirements.length == 1 &&\n        dep.requirement.requirements.any? do |op, version|\n          op == '~>' and\n            not version.prerelease? and\n            version.segments.length > 2 and\n            version.segments.first != 0\n        end\n\n      if overly_strict then\n        _, dep_version = dep.requirement.requirements.first\n\n        base = dep_version.segments.first 2\n\n        warning_messages << <<-WARNING\npessimistic dependency on #{dep} may be overly strict\n  if #{dep.name} is semantically versioned, use:\n    add_#{dep.type}_dependency '#{dep.name}', '~> #{base.join '.'}', '>= #{dep_version}'\n        WARNING\n      end\n\n      open_ended = dep.requirement.requirements.all? do |op, version|\n        not version.prerelease? and (op == '>' or op == '>=')\n      end\n\n      if open_ended then\n        op, dep_version = dep.requirement.requirements.first\n\n        base = dep_version.segments.first 2\n\n        bugfix = if op == '>' then\n                   \", '> #{dep_version}'\"\n                 elsif op == '>=' and base != dep_version.segments then\n                   \", '>= #{dep_version}'\"\n                 end\n\n        warning_messages << <<-WARNING\nopen-ended dependency on #{dep} is not recommended\n  if #{dep.name} is semantically versioned, use:\n    add_#{dep.type}_dependency '#{dep.name}', '~> #{base.join '.'}'#{bugfix}\n        WARNING\n      end\n    end\n    if error_messages.any?\n      raise Gem::InvalidSpecificationException, error_messages.join\n    end\n    if warning_messages.any?\n      warning_messages.each { |warning_message| warning warning_message }\n    end\n  end\n\n  ##\n  # Checks to see if the files to be packaged are world-readable.\n\n  def validate_permissions\n    return if Gem.win_platform?\n\n    files.each do |file|\n      next unless File.file?(file)\n      next if File.stat(file).mode & 0444 == 0444\n      warning \"#{file} is not world-readable\"\n    end\n\n    executables.each do |name|\n      exec = File.join @bindir, name\n      next unless File.file?(exec)\n      next if File.stat(exec).executable?\n      warning \"#{exec} is not executable\"\n    end\n  end\n\n  ##\n  # Set the version to +version+, potentially also setting\n  # required_rubygems_version if +version+ indicates it is a\n  # prerelease.\n\n  def version= version\n    @version = Gem::Version.create(version)\n    self.required_rubygems_version = '> 1.3.1' if @version.prerelease?\n    invalidate_memoized_attributes\n\n    return @version\n  end\n\n  def stubbed?\n    false\n  end\n\n  def yaml_initialize(tag, vals) # :nodoc:\n    vals.each do |ivar, val|\n      case ivar\n      when \"date\"\n        # Force Date to go through the extra coerce logic in date=\n        self.date = val.untaint\n      else\n        instance_variable_set \"@#{ivar}\", val.untaint\n      end\n    end\n\n    @original_platform = @platform # for backwards compatibility\n    self.platform = Gem::Platform.new @platform\n  end\n\n  ##\n  # Reset nil attributes to their default values to make the spec valid\n\n  def reset_nil_attributes_to_default\n    nil_attributes = self.class.non_nil_attributes.find_all do |name|\n      !instance_variable_defined?(\"@#{name}\") || instance_variable_get(\"@#{name}\").nil?\n    end\n\n    nil_attributes.each do |attribute|\n      default = self.default_value attribute\n\n      value = case default\n              when Time, Numeric, Symbol, true, false, nil then default\n              else default.dup\n              end\n\n      instance_variable_set \"@#{attribute}\", value\n    end\n\n    @installed_by_version ||= nil\n  end\n\n  def warning statement # :nodoc:\n    @warnings += 1\n\n    alert_warning statement\n  end\n\n  def raw_require_paths # :nodoc:\n    @require_paths\n  end\n\n  extend Gem::Deprecate\n\n  # TODO:\n  # deprecate :has_rdoc,            :none,       2011, 10\n  # deprecate :has_rdoc?,           :none,       2011, 10\n  # deprecate :has_rdoc=,           :none,       2011, 10\n  # deprecate :default_executable,  :none,       2011, 10\n  # deprecate :default_executable=, :none,       2011, 10\n  # deprecate :file_name,           :cache_file, 2011, 10\n  # deprecate :full_gem_path,     :cache_file, 2011, 10\nend\n\n# DOC: What is this and why is it here, randomly, at the end of this file?\nGem.clear_paths\n", "# frozen_string_literal: true\nrequire 'benchmark'\nrequire 'rubygems/test_case'\nrequire 'pathname'\nrequire 'stringio'\nrequire 'rubygems/ext'\nrequire 'rubygems/specification'\nrequire 'rubygems/installer'\n\nclass TestGemSpecification < Gem::TestCase\n\n  LEGACY_YAML_SPEC = <<-EOF\n--- !ruby/object:Gem::Specification\nrubygems_version: \"1.0\"\nname: keyedlist\nversion: !ruby/object:Gem::Version\n  version: 0.4.0\ndate: 2004-03-28 15:37:49.828000 +02:00\nplatform:\nsummary: A Hash which automatically computes keys.\nrequire_paths:\n  - lib\nfiles:\n  - lib/keyedlist.rb\nautorequire: keyedlist\nauthor: Florian Gross\nemail: flgr@ccan.de\nhas_rdoc: true\n  EOF\n\n  LEGACY_RUBY_SPEC = <<-EOF\nGem::Specification.new do |s|\n  s.name = %q{keyedlist}\n  s.version = %q{0.4.0}\n  s.has_rdoc = true\n  s.summary = %q{A Hash which automatically computes keys.}\n  s.files = [%q{lib/keyedlist.rb}]\n  s.require_paths = [%q{lib}]\n  s.autorequire = %q{keyedlist}\n  s.author = %q{Florian Gross}\n  s.email = %q{flgr@ccan.de}\nend\n  EOF\n\n  def make_spec_c1\n    @c1 = util_spec 'a', '1' do |s|\n      s.executable = 'exec'\n      s.extensions << 'ext/a/extconf.rb'\n      s.test_file = 'test/suite.rb'\n      s.requirements << 'A working computer'\n      s.rubyforge_project = 'example'\n      s.license = 'MIT'\n\n      s.add_dependency 'rake', '> 0.4'\n      s.add_dependency 'jabber4r', '> 0.0.0'\n      s.add_dependency 'pqa', ['> 0.4', '<= 0.6']\n\n      s.mark_version\n      s.files = %w[lib/code.rb]\n    end\n  end\n\n  def ext_spec\n    @ext = util_spec 'ext', '1' do |s|\n      s.executable = 'exec'\n      s.test_file = 'test/suite.rb'\n      s.extensions = %w[ext/extconf.rb]\n      s.license = 'MIT'\n\n      s.mark_version\n      s.files = %w[lib/code.rb]\n      s.installed_by_version = v('2.2')\n    end\n  end\n\n  def setup\n    super\n\n    @a1 = util_spec 'a', '1' do |s|\n      s.executable = 'exec'\n      s.test_file = 'test/suite.rb'\n      s.requirements << 'A working computer'\n      s.rubyforge_project = 'example'\n      s.license = 'MIT'\n\n      s.mark_version\n      s.files = %w[lib/code.rb]\n    end\n\n    @a2 = util_spec 'a', '2' do |s|\n      s.files = %w[lib/code.rb]\n    end\n\n    @a3 = util_spec 'a', '3' do |s|\n      s.metadata['allowed_push_host'] = \"https://privategemserver.com\"\n    end\n\n    @current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n\n    load 'rubygems/syck_hack.rb'\n  end\n\n  def test_self_find_active_stub_by_path\n    spec = new_spec('a', '1', nil, 'lib/foo.rb')\n    spec.activated = true\n\n    # There used to be a bug (introduced in a9c1aaf) when Gem::Specification\n    # objects are present in the @stubs collection. This test verifies that\n    # this scenario works correctly.\n    Gem::Specification.all = [spec]\n    Gem::Specification.find_active_stub_by_path('foo')\n  end\n\n  def test_self_activate\n    foo = util_spec 'foo', '1'\n\n    assert_activate %w[foo-1], foo\n  end\n\n  def test_self_activate_ambiguous_direct\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec(\"b\", \"1\", { \"c\" => \">= 1\" }, \"lib/d.rb\")\n      b2 = new_spec(\"b\", \"2\", { \"c\" => \">= 2\" }, \"lib/d.rb\")\n      c1 = new_spec \"c\", \"1\"\n      c2 = new_spec \"c\", \"2\"\n\n      Gem::Specification.reset\n      install_specs c1, c2, b1, b2, a1\n\n      a1.activate\n      assert_equal %w(a-1), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n\n      require \"d\"\n\n      assert_equal %w(a-1 b-2 c-2), loaded_spec_names\n      assert_equal [], unresolved_names\n    end\n  end\n\n  def test_find_in_unresolved_tree_is_not_exponentiental\n    save_loaded_features do\n      num_of_pkg = 7\n      num_of_version_per_pkg = 3\n      packages = (0..num_of_pkg).map do |pkgi|\n        (0..num_of_version_per_pkg).map do |pkg_version|\n          deps = Hash[((pkgi + 1)..num_of_pkg).map { |deppkgi|\n            [\"pkg#{deppkgi}\", \">= 0\"]\n          }]\n          new_spec \"pkg#{pkgi}\", pkg_version.to_s, deps\n        end\n      end\n      base = new_spec \"pkg_base\", \"1\", {\"pkg0\" => \">= 0\"}\n\n      Gem::Specification.reset\n      install_specs(*packages.flatten.reverse)\n      install_specs base\n      base.activate\n\n      tms = Benchmark.measure {\n        assert_raises(LoadError) { require 'no_such_file_foo' }\n      }\n      assert_operator tms.total, :<=, 10\n    end\n  end\n\n  def test_self_activate_ambiguous_indirect\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 1\"\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 2\"\n      c1 = new_spec \"c\", \"1\", nil, \"lib/d.rb\"\n      c2 = new_spec \"c\", \"2\", nil, \"lib/d.rb\"\n\n      install_specs c1, c2, b1, b2, a1\n\n      a1.activate\n      assert_equal %w(a-1), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n\n      require \"d\"\n\n      assert_equal %w(a-1 b-2 c-2), loaded_spec_names\n      assert_equal [], unresolved_names\n    end\n  end\n\n  def test_self_activate_ambiguous_indirect_conflict\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      a2 = new_spec \"a\", \"2\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 1\"\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 2\"\n      c1 = new_spec \"c\", \"1\", nil, \"lib/d.rb\"\n      c2 = new_spec(\"c\", \"2\", { \"a\" => \"1\" }, \"lib/d.rb\") # conflicts with a-2\n\n      install_specs c1, b1, a1, a2, c2, b2\n\n      a2.activate\n      assert_equal %w(a-2), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n\n      require \"d\"\n\n      assert_equal %w(a-2 b-1 c-1), loaded_spec_names\n      assert_equal [], unresolved_names\n    end\n  end\n\n  def test_self_activate_ambiguous_unrelated\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 1\"\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 2\"\n      c1 = new_spec \"c\", \"1\"\n      c2 = new_spec \"c\", \"2\"\n      d1 = new_spec \"d\", \"1\", nil, \"lib/d.rb\"\n\n      install_specs d1, c1, c2, b1, b2, a1\n\n      a1.activate\n      assert_equal %w(a-1), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n\n      require \"d\"\n\n      assert_equal %w(a-1 d-1), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n    end\n  end\n\n  def test_require_should_prefer_latest_gem_level1\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 0\" # unresolved\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 0\"\n      c1 = new_spec \"c\", \"1\", nil, \"lib/c.rb\"  # 1st level\n      c2 = new_spec \"c\", \"2\", nil, \"lib/c.rb\"\n\n      install_specs c1, c2, b1, b2, a1\n\n      a1.activate\n\n      require \"c\"\n\n      assert_equal %w(a-1 b-2 c-2), loaded_spec_names\n    end\n  end\n\n  def test_require_should_prefer_latest_gem_level2\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 0\" # unresolved\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 0\"\n      c1 = new_spec \"c\", \"1\", \"d\" => \">= 0\"  # 1st level\n      c2 = new_spec \"c\", \"2\", \"d\" => \">= 0\"\n      d1 = new_spec \"d\", \"1\", nil, \"lib/d.rb\" # 2nd level\n      d2 = new_spec \"d\", \"2\", nil, \"lib/d.rb\"\n\n      install_specs d1, d2, c1, c2, b1, b2, a1\n\n      a1.activate\n\n      require \"d\"\n\n      assert_equal %w(a-1 b-2 c-2 d-2), loaded_spec_names\n    end\n  end\n\n  def test_require_finds_in_2nd_level_indirect\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 0\" # unresolved\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 0\"\n      c1 = new_spec \"c\", \"1\", \"d\" => \"<= 2\" # 1st level\n      c2 = new_spec \"c\", \"2\", \"d\" => \"<= 2\"\n      d1 = new_spec \"d\", \"1\", nil, \"lib/d.rb\" # 2nd level\n      d2 = new_spec \"d\", \"2\", nil, \"lib/d.rb\"\n      d3 = new_spec \"d\", \"3\", nil, \"lib/d.rb\"\n\n      install_specs d1, d2, d3, c1, c2, b1, b2, a1\n\n      a1.activate\n\n      require \"d\"\n\n      assert_equal %w(a-1 b-2 c-2 d-2), loaded_spec_names\n    end\n  end\n\n  def test_require_should_prefer_reachable_gems\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 0\" # unresolved\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 0\"\n      c1 = new_spec \"c\", \"1\", \"d\" => \"<= 2\" # 1st level\n      c2 = new_spec \"c\", \"2\", \"d\" => \"<= 2\"\n      d1 = new_spec \"d\", \"1\", nil, \"lib/d.rb\" # 2nd level\n      d2 = new_spec \"d\", \"2\", nil, \"lib/d.rb\"\n      d3 = new_spec \"d\", \"3\", nil, \"lib/d.rb\"\n      e  = new_spec \"anti_d\", \"1\", nil, \"lib/d.rb\"\n\n      install_specs d1, d2, d3, e, c1, c2, b1, b2, a1\n\n      a1.activate\n\n      require \"d\"\n\n      assert_equal %w(a-1 b-2 c-2 d-2), loaded_spec_names\n    end\n  end\n\n  def test_require_should_not_conflict\n    save_loaded_features do\n      base = new_spec \"0\", \"1\", \"A\" => \">= 1\"\n      a1 = new_spec \"A\", \"1\", {\"c\" => \">= 2\", \"b\" => \"> 0\"}, \"lib/a.rb\"\n      a2 = new_spec \"A\", \"2\", {\"c\" => \">= 2\", \"b\" => \"> 0\"}, \"lib/a.rb\"\n      b1 = new_spec \"b\", \"1\", {\"c\" => \"= 1\"}, \"lib/d.rb\"\n      b2 = new_spec \"b\", \"2\", {\"c\" => \"= 2\"}, \"lib/d.rb\"\n      c1 = new_spec \"c\", \"1\", {}, \"lib/c.rb\"\n      c2 = new_spec \"c\", \"2\", {}, \"lib/c.rb\"\n      c3 = new_spec \"c\", \"3\", {}, \"lib/c.rb\"\n\n      install_specs c1, c2, c3, b1, b2, a1, a2, base\n\n      base.activate\n      assert_equal %w(0-1), loaded_spec_names\n      assert_equal [\"A (>= 1)\"], unresolved_names\n\n      require \"d\"\n\n      assert_equal %w(0-1 A-2 b-2 c-2), loaded_spec_names\n      assert_equal [], unresolved_names\n    end\n  end\n\n  def test_inner_clonflict_in_indirect_gems\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 1\" # unresolved\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 1\", \"d\" => \"< 3\"\n      c1 = new_spec \"c\", \"1\", \"d\" => \"<= 2\" # 1st level\n      c2 = new_spec \"c\", \"2\", \"d\" => \"<= 2\"\n      c3 = new_spec \"c\", \"3\", \"d\" => \"<= 3\"\n      d1 = new_spec \"d\", \"1\", nil, \"lib/d.rb\" # 2nd level\n      d2 = new_spec \"d\", \"2\", nil, \"lib/d.rb\"\n      d3 = new_spec \"d\", \"3\", nil, \"lib/d.rb\"\n\n      install_specs d1, d2, d3, c1, c2, c3, b1, b2, a1\n\n      a1.activate\n\n      require \"d\"\n\n      assert_includes [%w(a-1 b-2 c-3 d-2),%w(a-1 b-2 d-2)], loaded_spec_names\n    end\n  end\n\n  def test_inner_clonflict_in_indirect_gems_reversed\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"xc\" => \">= 1\" # unresolved\n      b2 = new_spec \"b\", \"2\", \"xc\" => \">= 1\", \"d\" => \"< 3\"\n      c1 = new_spec \"xc\", \"1\", \"d\" => \"<= 3\" # 1st level\n      c2 = new_spec \"xc\", \"2\", \"d\" => \"<= 2\"\n      c3 = new_spec \"xc\", \"3\", \"d\" => \"<= 3\"\n      d1 = new_spec \"d\", \"1\", nil, \"lib/d.rb\" # 2nd level\n      d2 = new_spec \"d\", \"2\", nil, \"lib/d.rb\"\n      d3 = new_spec \"d\", \"3\", nil, \"lib/d.rb\"\n\n      install_specs d1, d2, d3, c1, c2, c3, b1, b2, a1\n\n      a1.activate\n\n      require \"d\"\n\n      assert_includes [%w(a-1 b-2 d-2 xc-3), %w(a-1 b-2 d-2)], loaded_spec_names\n    end\n  end\n\n  ##\n  # [A] depends on\n  #     [C]  = 1.0 depends on\n  #         [B] = 2.0\n  #     [B] ~> 1.0 (satisfied by 1.0)\n\n  def test_self_activate_checks_dependencies\n    a  = util_spec 'a', '1.0'\n            a.add_dependency 'c', '= 1.0'\n            a.add_dependency 'b', '~> 1.0'\n\n    b1 = util_spec 'b', '1.0'\n    b2 = util_spec 'b', '2.0'\n    c  = util_spec 'c', '1.0', 'b' => '= 2.0'\n    install_specs b1, b2, c, a\n\n    e = assert_raises Gem::LoadError do\n      assert_activate nil, a, c, \"b\"\n    end\n\n    expected = \"can't satisfy 'b (~> 1.0)', already activated 'b-2.0'\"\n    assert_equal expected, e.message\n  end\n\n  ##\n  # [A] depends on\n  #     [B] ~> 1.0 (satisfied by 1.0)\n  #     [C]  = 1.0 depends on\n  #         [B] = 2.0\n\n  def test_self_activate_divergent\n    a  = util_spec 'a', '1.0', 'b' => '~> 1.0', 'c' => '= 1.0'\n    b1 = util_spec 'b', '1.0'\n    b2 = util_spec 'b', '2.0'\n    c  = util_spec 'c', '1.0', 'b' => '= 2.0'\n\n    install_specs b1, b2, c, a\n\n    e = assert_raises Gem::ConflictError do\n      assert_activate nil, a, c, \"b\"\n    end\n\n    assert_match(/Unable to activate c-1.0,/, e.message)\n    assert_match(/because b-1.0 conflicts with b .= 2.0/, e.message)\n  end\n\n  ##\n  # DOC\n\n  def test_self_activate_old_required\n    e1, = util_spec 'e', '1', 'd' => '= 1'\n    @d1 = util_spec 'd', '1'\n    @d2 = util_spec 'd', '2'\n\n    install_specs @d1, @d2, e1\n\n    assert_activate %w[d-1 e-1], e1, \"d\"\n  end\n\n  ##\n  # DOC\n\n  def test_self_activate_platform_alternate\n    @x1_m = util_spec 'x', '1' do |s|\n      s.platform = Gem::Platform.new %w[cpu my_platform 1]\n    end\n\n    @x1_o = util_spec 'x', '1' do |s|\n      s.platform = Gem::Platform.new %w[cpu other_platform 1]\n    end\n\n    @w1 = util_spec 'w', '1', 'x' => nil\n\n    util_set_arch 'cpu-my_platform1'\n    install_specs @x1_m, @x1_o, @w1\n\n    assert_activate %w[x-1-cpu-my_platform-1 w-1], @w1, @x1_m\n  end\n\n  ##\n  # DOC\n\n  def test_self_activate_platform_bump\n    @y1 = util_spec 'y', '1'\n\n    @y1_1_p = util_spec 'y', '1.1' do |s|\n      s.platform = Gem::Platform.new %w[cpu my_platform 1]\n    end\n\n    @z1 = util_spec 'z', '1', 'y' => nil\n    install_specs @y1, @y1_1_p, @z1\n\n    assert_activate %w[y-1 z-1], @z1, @y1\n  end\n\n  ##\n  # [C] depends on\n  #     [A] = 1.a\n  #     [B] = 1.0 depends on\n  #         [A] >= 0 (satisfied by 1.a)\n\n  def test_self_activate_prerelease\n    @c1_pre = util_spec 'c', '1.a', \"a\" => \"1.a\", \"b\" => \"1\"\n    @a1_pre = util_spec 'a', '1.a'\n    @b1     = util_spec 'b', '1' do |s|\n      s.add_dependency 'a'\n      s.add_development_dependency 'aa'\n    end\n    install_specs @a1_pre, @b1, @c1_pre\n\n    assert_activate %w[a-1.a b-1 c-1.a], @c1_pre, @a1_pre, @b1\n  end\n\n  def test_self_activate_via_require\n    a1 = new_spec \"a\", \"1\", \"b\" => \"= 1\"\n    b1 = new_spec \"b\", \"1\", nil, \"lib/b/c.rb\"\n    b2 = new_spec \"b\", \"2\", nil, \"lib/b/c.rb\"\n\n    install_specs b1, b2, a1\n\n    a1.activate\n    save_loaded_features do\n      require \"b/c\"\n    end\n\n    assert_equal %w(a-1 b-1), loaded_spec_names\n  end\n\n  def test_self_activate_via_require_wtf\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\", \"d\" => \"> 0\"    # this\n      b1 = new_spec \"b\", \"1\", { \"c\" => \">= 1\" }, \"lib/b.rb\"\n      b2 = new_spec \"b\", \"2\", { \"c\" => \">= 2\" }, \"lib/b.rb\" # this\n      c1 = new_spec \"c\", \"1\"\n      c2 = new_spec \"c\", \"2\"                                # this\n      d1 = new_spec \"d\", \"1\", { \"c\" => \"< 2\" },  \"lib/d.rb\"\n      d2 = new_spec \"d\", \"2\", { \"c\" => \"< 2\" },  \"lib/d.rb\" # this\n\n      install_specs c1, c2, b1, b2, d1, d2, a1\n\n      a1.activate\n\n      assert_equal %w(a-1), loaded_spec_names\n      assert_equal [\"b (> 0)\", \"d (> 0)\"], unresolved_names\n\n      require \"b\"\n\n      e = assert_raises Gem::LoadError do\n        require \"d\"\n      end\n\n      assert_equal \"unable to find a version of 'd' to activate\", e.message\n\n      assert_equal %w(a-1 b-2 c-2), loaded_spec_names\n      assert_equal [\"d (> 0)\"], unresolved_names\n    end\n  end\n\n  def test_self_activate_deep_unambiguous\n    a1 = new_spec \"a\", \"1\", \"b\" => \"= 1\"\n    b1 = new_spec \"b\", \"1\", \"c\" => \"= 1\"\n    b2 = new_spec \"b\", \"2\", \"c\" => \"= 2\"\n    c1 = new_spec \"c\", \"1\"\n    c2 = new_spec \"c\", \"2\"\n\n    install_specs c1, c2, b1, b2, a1\n\n    a1.activate\n    assert_equal %w(a-1 b-1 c-1), loaded_spec_names\n  end\n\n  def test_self_activate_loaded\n    foo = util_spec 'foo', '1'\n\n    assert foo.activate\n    refute foo.activate\n  end\n\n  ##\n  # [A] depends on\n  #     [B] >= 1.0 (satisfied by 2.0)\n  # [C] depends on nothing\n\n  def test_self_activate_unrelated\n    a = util_spec 'a', '1.0', 'b' => '>= 1.0'\n    b = util_spec 'b', '1.0'\n    c = util_spec 'c', '1.0'\n    install_specs b, c, a\n\n    assert_activate %w[b-1.0 c-1.0 a-1.0], a, c, \"b\"\n  end\n\n  ##\n  # [A] depends on\n  #     [B] >= 1.0 (satisfied by 2.0)\n  #     [C]  = 1.0 depends on\n  #         [B] ~> 1.0\n  #\n  # and should resolve using b-1.0\n  # TODO: move these to specification\n\n  def test_self_activate_over\n    a = util_spec 'a', '1.0', 'b' => '>= 1.0', 'c' => '= 1.0'\n    install_specs util_spec 'b', '1.0'\n    install_specs util_spec 'b', '1.1'\n    install_specs util_spec 'b', '2.0'\n    install_specs util_spec 'c', '1.0', 'b' => '~> 1.0'\n    install_specs a\n\n    a.activate\n\n    assert_equal %w[a-1.0 c-1.0], loaded_spec_names\n    assert_equal [\"b (>= 1.0, ~> 1.0)\"], unresolved_names\n  end\n\n  ##\n  # [A] depends on\n  #     [B] ~> 1.0 (satisfied by 1.1)\n  #     [C]  = 1.0 depends on\n  #         [B] = 1.0\n  #\n  # and should resolve using b-1.0\n  #\n  # TODO: this is not under, but over... under would require depth\n  # first resolve through a dependency that is later pruned.\n\n  def test_self_activate_under\n    a    = util_spec 'a', '1.0', 'b' => '~> 1.0', 'c' => '= 1.0'\n    b1   = util_spec 'b', '1.0'\n    b1_1 = util_spec 'b', '1.1'\n    c    = util_spec 'c', '1.0', 'b' => '= 1.0'\n\n    install_specs b1, b1_1, c, a\n\n    assert_activate %w[b-1.0 c-1.0 a-1.0], a, c, \"b\"\n  end\n\n  ##\n  # [A1] depends on\n  #    [B] > 0 (satisfied by 2.0)\n  # [B1] depends on\n  #    [C] > 0 (satisfied by 1.0)\n  # [B2] depends on nothing!\n  # [C1] depends on nothing\n\n  def test_self_activate_dropped\n    a1 = util_spec 'a', '1', 'b' => nil\n    b1 = util_spec 'b', '1', 'c' => nil\n    b2 = util_spec 'b', '2'\n    c1 = util_spec 'c', '1'\n    install_specs c1, b1, b2, a1\n\n    assert_activate %w[b-2 a-1], a1, \"b\"\n  end\n\n  ##\n  # [A] depends on\n  #     [B] >= 1.0 (satisfied by 1.1) depends on\n  #         [Z]\n  #     [C] >= 1.0 depends on\n  #         [B] = 1.0\n  #\n  # and should backtrack to resolve using b-1.0, pruning Z from the\n  # resolve.\n\n  def test_self_activate_raggi_the_edgecase_generator\n    a    = util_spec 'a', '1.0', 'b' => '>= 1.0', 'c' => '>= 1.0'\n    b1   = util_spec 'b', '1.0'\n    b1_0 = util_spec 'b', '1.1', 'z' => '>= 1.0'\n    c    = util_spec 'c', '1.0', 'b' => '= 1.0'\n    z    = util_spec 'z', '1'\n\n    install_specs z, b1, b1_0, c, z\n\n    assert_activate %w[b-1.0 c-1.0 a-1.0], a, c, \"b\"\n  end\n\n  def test_self_activate_conflict\n    install_specs util_spec 'b', '1.0'\n    install_specs util_spec 'b', '2.0'\n\n    gem \"b\", \"= 1.0\"\n\n    assert_raises Gem::LoadError do\n      gem \"b\", \"= 2.0\"\n    end\n  end\n\n  def test_self_all_equals\n    a = new_spec \"foo\", \"1\", nil, \"lib/foo.rb\"\n\n    install_specs a\n    Gem::Specification.all = [a]\n\n    assert_equal a, Gem::Specification.find_inactive_by_path('foo')\n  end\n\n  def test_self_attribute_names\n    expected_value = %w[\n      authors\n      autorequire\n      bindir\n      cert_chain\n      date\n      dependencies\n      description\n      email\n      executables\n      extensions\n      extra_rdoc_files\n      files\n      homepage\n      licenses\n      metadata\n      name\n      platform\n      post_install_message\n      rdoc_options\n      require_paths\n      required_ruby_version\n      required_rubygems_version\n      requirements\n      rubyforge_project\n      rubygems_version\n      signing_key\n      specification_version\n      summary\n      test_files\n      version\n    ]\n\n    actual_value = Gem::Specification.attribute_names.map { |a| a.to_s }.sort\n\n    assert_equal expected_value, actual_value\n  end\n\n  def test_self__load_future\n    spec = Gem::Specification.new\n    spec.name = 'a'\n    spec.version = '1'\n    spec.specification_version = @current_version + 1\n\n    new_spec = Marshal.load Marshal.dump(spec)\n\n    assert_equal 'a', new_spec.name\n    assert_equal Gem::Version.new(1), new_spec.version\n    assert_equal @current_version, new_spec.specification_version\n  end\n\n  def test_self_from_yaml\n    @a1.instance_variable_set :@specification_version, nil\n\n    spec = Gem::Specification.from_yaml @a1.to_yaml\n\n    assert_equal Gem::Specification::NONEXISTENT_SPECIFICATION_VERSION,\n                 spec.specification_version\n  end\n\n  def test_self_from_yaml_syck_date_bug\n    # This is equivalent to (and totally valid) psych 1.0 output and\n    # causes parse errors on syck.\n    yaml = @a1.to_yaml\n    yaml.sub!(/^date:.*/, \"date: 2011-04-26 00:00:00.000000000Z\")\n\n    new_spec = with_syck do\n      Gem::Specification.from_yaml yaml\n    end\n\n    assert_kind_of Time, @a1.date\n    assert_kind_of Time, new_spec.date\n  end\n\n  def test_self_from_yaml_syck_default_key_bug\n    # This is equivalent to (and totally valid) psych 1.0 output and\n    # causes parse errors on syck.\n    yaml = <<-YAML\n--- !ruby/object:Gem::Specification\nname: posix-spawn\nversion: !ruby/object:Gem::Version\n  version: 0.3.6\n  prerelease:\ndependencies:\n- !ruby/object:Gem::Dependency\n  name: rake-compiler\n  requirement: &70243867725240 !ruby/object:Gem::Requirement\n    none: false\n    requirements:\n    - - =\n      - !ruby/object:Gem::Version\n        version: 0.7.6\n  type: :development\n  prerelease: false\n  version_requirements: *70243867725240\nplatform: ruby\nfiles: []\ntest_files: []\nbindir:\n    YAML\n\n    new_spec = with_syck do\n      Gem::Specification.from_yaml yaml\n    end\n\n    op = new_spec.dependencies.first.requirement.requirements.first.first\n    refute_kind_of YAML::Syck::DefaultKey, op\n\n    refute_match %r%DefaultKey%, new_spec.to_ruby\n  end\n\n  def test_self_from_yaml_cleans_up_defaultkey\n    yaml = <<-YAML\n--- !ruby/object:Gem::Specification\nname: posix-spawn\nversion: !ruby/object:Gem::Version\n  version: 0.3.6\n  prerelease:\ndependencies:\n- !ruby/object:Gem::Dependency\n  name: rake-compiler\n  requirement: &70243867725240 !ruby/object:Gem::Requirement\n    none: false\n    requirements:\n    - - !ruby/object:YAML::Syck::DefaultKey {}\n\n      - !ruby/object:Gem::Version\n        version: 0.7.6\n  type: :development\n  prerelease: false\n  version_requirements: *70243867725240\nplatform: ruby\nfiles: []\ntest_files: []\nbindir:\n    YAML\n\n    new_spec = Gem::Specification.from_yaml yaml\n\n    op = new_spec.dependencies.first.requirement.requirements.first.first\n    refute_kind_of YAML::Syck::DefaultKey, op\n\n    refute_match %r%DefaultKey%, new_spec.to_ruby\n  end\n\n  def test_self_from_yaml_cleans_up_defaultkey_from_newer_192\n    yaml = <<-YAML\n--- !ruby/object:Gem::Specification\nname: posix-spawn\nversion: !ruby/object:Gem::Version\n  version: 0.3.6\n  prerelease:\ndependencies:\n- !ruby/object:Gem::Dependency\n  name: rake-compiler\n  requirement: &70243867725240 !ruby/object:Gem::Requirement\n    none: false\n    requirements:\n    - - !ruby/object:Syck::DefaultKey {}\n\n      - !ruby/object:Gem::Version\n        version: 0.7.6\n  type: :development\n  prerelease: false\n  version_requirements: *70243867725240\nplatform: ruby\nfiles: []\ntest_files: []\nbindir:\n    YAML\n\n    new_spec = Gem::Specification.from_yaml yaml\n\n    op = new_spec.dependencies.first.requirement.requirements.first.first\n    refute_kind_of YAML::Syck::DefaultKey, op\n\n    refute_match %r%DefaultKey%, new_spec.to_ruby\n  end\n\n  def test_self_from_yaml_cleans_up_Date_objects\n    yaml = <<-YAML\n--- !ruby/object:Gem::Specification\nrubygems_version: 0.8.1\nspecification_version: 1\nname: diff-lcs\nversion: !ruby/object:Gem::Version\n  version: 1.1.2\ndate: 2004-10-20\nsummary: Provides a list of changes that represent the difference between two sequenced collections.\nrequire_paths:\n  - lib\nauthor: Austin Ziegler\nemail: diff-lcs@halostatue.ca\nhomepage: http://rubyforge.org/projects/ruwiki/\nrubyforge_project: ruwiki\ndescription: \"Test\"\nbindir: bin\nhas_rdoc: true\nrequired_ruby_version: !ruby/object:Gem::Version::Requirement\n  requirements:\n    -\n      - \">=\"\n      - !ruby/object:Gem::Version\n        version: 1.8.1\n  version:\nplatform: ruby\nfiles:\n  - tests/00test.rb\nrdoc_options:\n  - \"--title\"\n  - \"Diff::LCS -- A Diff Algorithm\"\n  - \"--main\"\n  - README\n  - \"--line-numbers\"\nextra_rdoc_files:\n  - README\n  - ChangeLog\n  - Install\nexecutables:\n  - ldiff\n  - htmldiff\nextensions: []\nrequirements: []\ndependencies: []\n    YAML\n\n    new_spec = Gem::Specification.from_yaml yaml\n\n    assert_kind_of Time, new_spec.date\n  end\n\n  def test_self_load\n    full_path = @a2.spec_file\n    write_file full_path do |io|\n      io.write @a2.to_ruby_for_cache\n    end\n\n    spec = Gem::Specification.load full_path\n\n    @a2.files.clear\n\n    assert_equal @a2, spec\n  end\n\n  def test_self_load_relative\n    File.open 'a-2.gemspec', 'w' do |io|\n      io.write @a2.to_ruby_for_cache\n    end\n\n    spec = Gem::Specification.load 'a-2.gemspec'\n\n    @a2.files.clear\n\n    assert_equal @a2, spec\n\n    assert_equal File.join(@tempdir, 'a-2.gemspec'), spec.loaded_from\n  end\n\n  def test_self_load_tainted\n    full_path = @a2.spec_file\n    write_file full_path do |io|\n      io.write @a2.to_ruby_for_cache\n    end\n\n    full_path.taint\n    loader = Thread.new { $SAFE = 1; Gem::Specification.load full_path }\n    spec = loader.value\n\n    @a2.files.clear\n\n    assert_equal @a2, spec\n\n  ensure\n    $SAFE = 0\n  end\n\n  def test_self_load_escape_curly\n    @a2.name = 'a};raise \"improper escaping\";%q{'\n\n    full_path = @a2.spec_file\n    begin\n      write_file full_path do |io|\n        io.write @a2.to_ruby_for_cache\n      end\n    rescue Errno::EINVAL\n      skip \"cannot create '#{full_path}' on this platform\"\n    end\n\n    spec = Gem::Specification.load full_path\n\n    @a2.files.clear\n\n    assert_equal @a2, spec\n  end\n\n  def test_self_load_escape_interpolation\n    @a2.name = 'a#{raise %<improper escaping>}'\n\n    full_path = @a2.spec_file\n    begin\n      write_file full_path do |io|\n        io.write @a2.to_ruby_for_cache\n      end\n    rescue Errno::EINVAL\n      skip \"cannot create '#{full_path}' on this platform\"\n    end\n\n    spec = Gem::Specification.load full_path\n\n    @a2.files.clear\n\n    assert_equal @a2, spec\n  end\n\n  def test_self_load_escape_quote\n    @a2.name = 'a\";raise \"improper escaping\";\"'\n\n    full_path = @a2.spec_file\n    begin\n      write_file full_path do |io|\n        io.write @a2.to_ruby_for_cache\n      end\n    rescue Errno::EINVAL\n      skip \"cannot create '#{full_path}' on this platform\"\n    end\n\n    spec = Gem::Specification.load full_path\n\n    @a2.files.clear\n\n    assert_equal @a2, spec\n  end\n\n  if defined?(Encoding)\n  def test_self_load_utf8_with_ascii_encoding\n    int_enc = Encoding.default_internal\n    silence_warnings { Encoding.default_internal = 'US-ASCII' }\n\n    spec2 = @a2.dup\n    bin = \"\\u5678\".dup\n    spec2.authors = [bin]\n    full_path = spec2.spec_file\n    write_file full_path do |io|\n      io.write spec2.to_ruby_for_cache.force_encoding('BINARY').sub(\"\\\\u{5678}\", bin.force_encoding('BINARY'))\n    end\n\n    spec = Gem::Specification.load full_path\n\n    spec2.files.clear\n\n    assert_equal spec2, spec\n  ensure\n    silence_warnings { Encoding.default_internal = int_enc }\n  end\n  end\n\n  def test_self_load_legacy_ruby\n    spec = Gem::Deprecate.skip_during do\n      eval LEGACY_RUBY_SPEC\n    end\n    assert_equal 'keyedlist', spec.name\n    assert_equal '0.4.0', spec.version.to_s\n    assert_equal Gem::Specification::TODAY, spec.date\n    assert spec.required_ruby_version.satisfied_by?(Gem::Version.new('1'))\n    assert_equal false, spec.has_unit_tests?\n  end\n\n  def test_self_normalize_yaml_input_with_183_yaml\n    input = \"!ruby/object:Gem::Specification \"\n    assert_equal \"--- #{input}\", Gem::Specification.normalize_yaml_input(input)\n  end\n\n  def test_self_normalize_yaml_input_with_non_183_yaml\n    input = \"--- !ruby/object:Gem::Specification \"\n    assert_equal input, Gem::Specification.normalize_yaml_input(input)\n  end\n\n  def test_self_normalize_yaml_input_with_183_io\n    input = \"!ruby/object:Gem::Specification \"\n    assert_equal \"--- #{input}\",\n      Gem::Specification.normalize_yaml_input(StringIO.new(input))\n  end\n\n  def test_self_normalize_yaml_input_with_non_183_io\n    input = \"--- !ruby/object:Gem::Specification \"\n    assert_equal input,\n      Gem::Specification.normalize_yaml_input(StringIO.new(input))\n  end\n\n  def test_self_normalize_yaml_input_with_192_yaml\n    input = \"--- !ruby/object:Gem::Specification \\nblah: !!null \\n\"\n    expected = \"--- !ruby/object:Gem::Specification \\nblah: \\n\"\n\n    assert_equal expected, Gem::Specification.normalize_yaml_input(input)\n  end\n\n  def test_self_outdated\n    spec_fetcher do |fetcher|\n      fetcher.download 'a', 4\n\n      fetcher.spec 'a', 3\n    end\n\n    assert_equal %w[a], Gem::Specification.outdated\n  end\n\n  def test_self_outdated_and_latest_remotes\n    specs = spec_fetcher do |fetcher|\n      fetcher.download 'a', 4\n      fetcher.download 'b', 3\n\n      fetcher.spec 'a', '3.a'\n      fetcher.spec 'b', 2\n    end\n\n    expected = [\n      [specs['a-3.a'], v(4)],\n      [specs['b-2'],   v(3)],\n    ]\n\n    assert_equal expected, Gem::Specification.outdated_and_latest_version.to_a\n  end\n\n  def test_self_remove_spec\n    install_specs @a1\n\n    assert_includes Gem::Specification.all_names, 'a-1'\n    assert_includes Gem::Specification.stubs.map { |s| s.full_name }, 'a-1'\n\n    uninstall_gem @a1\n    Gem::Specification.reset\n\n    refute_includes Gem::Specification.all_names, 'a-1'\n    refute_includes Gem::Specification.stubs.map { |s| s.full_name }, 'a-1'\n  end\n\n  def test_self_remove_spec_removed\n    File.open @a1.spec_file, 'w' do |io|\n      io.write @a1.to_ruby\n    end\n\n    Gem::Specification.reset\n\n    FileUtils.rm @a1.spec_file # bug #698\n\n    Gem::Specification.reset\n\n    refute_includes Gem::Specification.all_names, 'a-1'\n    refute_includes Gem::Specification.stubs.map { |s| s.full_name }, 'a-1'\n  end\n\n  DATA_PATH = File.expand_path \"../data\", __FILE__\n\n  def test_handles_private_null_type\n    path = File.join DATA_PATH, \"null-type.gemspec.rz\"\n\n    data = Marshal.load Gem.inflate(Gem.read_binary(path))\n\n    assert_equal nil, data.rubyforge_project\n  end\n\n  def test_emits_zulu_timestamps_properly\n    t = Time.utc(2012, 3, 12)\n    @a2.date = t\n\n    yaml = with_psych { @a2.to_yaml }\n\n    assert_match %r!date: 2012-03-12 00:00:00\\.000000000 Z!, yaml\n  end if RUBY_VERSION =~ /1\\.9\\.2/\n\n  def test_initialize\n    spec = Gem::Specification.new do |s|\n      s.name = \"blah\"\n      s.version = \"1.3.5\"\n    end\n\n    assert_equal \"blah\", spec.name\n    assert_equal \"1.3.5\", spec.version.to_s\n    assert_equal Gem::Platform::RUBY, spec.platform\n    assert_equal nil, spec.summary\n    assert_equal [], spec.files\n\n    assert_equal [], spec.test_files\n    assert_equal [], spec.rdoc_options\n    assert_equal [], spec.extra_rdoc_files\n    assert_equal [], spec.executables\n    assert_equal [], spec.extensions\n    assert_equal [], spec.requirements\n    assert_equal [], spec.dependencies\n    assert_equal 'bin', spec.bindir\n    assert_equal '>= 0', spec.required_ruby_version.to_s\n    assert_equal '>= 0', spec.required_rubygems_version.to_s\n  end\n\n  def test_initialize_future\n    version = Gem::Specification::CURRENT_SPECIFICATION_VERSION + 1\n    spec = Gem::Specification.new do |s|\n      s.name = \"blah\"\n      s.version = \"1.3.5\"\n\n      s.specification_version = version\n\n      s.new_unknown_attribute = \"a value\"\n    end\n\n    assert_equal \"blah\", spec.name\n    assert_equal \"1.3.5\", spec.version.to_s\n  end\n\n  def test_initialize_copy\n    spec = Gem::Specification.new do |s|\n      s.name = \"blah\"\n      s.version = \"1.3.5\"\n      s.summary = 'summary'\n      s.description = 'description'\n      s.authors = 'author a', 'author b'\n      s.licenses = 'BSD-2-Clause'\n      s.files = 'lib/file.rb'\n      s.test_files = 'test/file.rb'\n      s.rdoc_options = '--foo'\n      s.extra_rdoc_files = 'README.txt'\n      s.executables = 'exec'\n      s.extensions = 'ext/extconf.rb'\n      s.requirements = 'requirement'\n      s.add_dependency 'some_gem'\n    end\n\n    new_spec = spec.dup\n\n    assert_equal \"blah\", spec.name\n    assert_same  spec.name, new_spec.name\n\n    assert_equal \"1.3.5\", spec.version.to_s\n    assert_same spec.version, new_spec.version\n\n    assert_equal Gem::Platform::RUBY, spec.platform\n    assert_same spec.platform, new_spec.platform\n\n    assert_equal 'summary', spec.summary\n    assert_same spec.summary, new_spec.summary\n\n    assert_equal %w[README.txt bin/exec ext/extconf.rb lib/file.rb\n                    test/file.rb].sort,\n                 spec.files\n    refute_same spec.files, new_spec.files, 'files'\n\n    assert_equal %w[test/file.rb], spec.test_files\n    refute_same spec.test_files, new_spec.test_files, 'test_files'\n\n    assert_equal %w[--foo], spec.rdoc_options\n    refute_same spec.rdoc_options, new_spec.rdoc_options, 'rdoc_options'\n\n    assert_equal %w[README.txt], spec.extra_rdoc_files\n    refute_same spec.extra_rdoc_files, new_spec.extra_rdoc_files,\n                'extra_rdoc_files'\n\n    assert_equal %w[exec], spec.executables\n    refute_same spec.executables, new_spec.executables, 'executables'\n\n    assert_equal %w[ext/extconf.rb], spec.extensions\n    refute_same spec.extensions, new_spec.extensions, 'extensions'\n\n    assert_equal %w[requirement], spec.requirements\n    refute_same spec.requirements, new_spec.requirements, 'requirements'\n\n    assert_equal [Gem::Dependency.new('some_gem', Gem::Requirement.default)],\n                 spec.dependencies\n    refute_same spec.dependencies, new_spec.dependencies, 'dependencies'\n\n    assert_equal 'bin', spec.bindir\n    assert_same spec.bindir, new_spec.bindir\n\n    assert_equal '>= 0', spec.required_ruby_version.to_s\n    assert_same spec.required_ruby_version, new_spec.required_ruby_version\n\n    assert_equal '>= 0', spec.required_rubygems_version.to_s\n    assert_same spec.required_rubygems_version,\n                new_spec.required_rubygems_version\n  end\n\n  def test_initialize_copy_broken\n    spec = Gem::Specification.new do |s|\n      s.name = 'a'\n      s.version = '1'\n    end\n\n    spec.instance_variable_set :@licenses, (class << (Object.new);self;end)\n    spec.loaded_from = '/path/to/file'\n\n    e = assert_raises Gem::FormatException do\n      spec.dup\n    end\n\n    assert_equal 'a-1 has an invalid value for @licenses', e.message\n    assert_equal '/path/to/file', e.file_path\n  end\n\n  def test__dump\n    @a2.platform = Gem::Platform.local\n    @a2.instance_variable_set :@original_platform, 'old_platform'\n\n    data = Marshal.dump @a2\n\n    same_spec = Marshal.load data\n\n    assert_equal 'old_platform', same_spec.original_platform\n  end\n\n  def test_activate\n    @a2.activate\n\n    assert @a2.activated?\n  end\n\n  def test_add_dependency_with_type\n    gem = util_spec \"awesome\", \"1.0\" do |awesome|\n      awesome.add_dependency true\n      awesome.add_dependency :gem_name\n    end\n\n    assert_equal %w[true gem_name], gem.dependencies.map { |dep| dep.name }\n  end\n\n  def test_add_dependency_from_existing_dependency\n    dep  = Gem::Dependency.new(\"existing_dep\", Gem::Requirement.new('> 1'), :runtime)\n    spec = Gem::Specification.new { |s| s.add_dependency dep }\n    assert_equal dep, spec.dependencies.first\n  end\n\n  def test_add_dependency_with_type_explicit\n    gem = util_spec \"awesome\", \"1.0\" do |awesome|\n      awesome.add_development_dependency \"monkey\"\n    end\n\n    monkey = gem.dependencies.detect { |d| d.name == \"monkey\" }\n    assert_equal(:development, monkey.type)\n  end\n\n  def test_author\n    assert_equal 'A User', @a1.author\n  end\n\n  def test_authors\n    assert_equal ['A User'], @a1.authors\n  end\n\n  def test_bindir_equals\n    @a1.bindir = 'apps'\n\n    assert_equal 'apps', @a1.bindir\n  end\n\n  def test_bindir_equals_nil\n    @a2.bindir = nil\n    @a2.executable = 'app'\n\n    assert_equal nil, @a2.bindir\n    assert_equal %w[app lib/code.rb].sort, @a2.files\n  end\n\n  def test_extensions_equals_nil\n    @a2.instance_variable_set(:@extensions, nil)\n    assert_equal nil, @a2.instance_variable_get(:@extensions)\n    assert_equal %w[lib/code.rb], @a2.files\n  end\n\n  def test_test_files_equals_nil\n    @a2.instance_variable_set(:@test_files, nil)\n    assert_equal nil, @a2.instance_variable_get(:@test_files)\n    assert_equal %w[lib/code.rb], @a2.files\n  end\n\n  def test_executables_equals_nil\n    @a2.instance_variable_set(:@executables, nil)\n    assert_equal nil, @a2.instance_variable_get(:@executables)\n    assert_equal %w[lib/code.rb], @a2.files\n  end\n\n  def test_extra_rdoc_files_equals_nil\n    @a2.instance_variable_set(:@extra_rdoc_files, nil)\n    assert_equal nil, @a2.instance_variable_get(:@extra_rdoc_files)\n    assert_equal %w[lib/code.rb], @a2.files\n  end\n\n  def test_build_args\n    ext_spec\n\n    assert_empty @ext.build_args\n\n    File.open @ext.build_info_file, 'w' do |io|\n      io.puts\n    end\n\n    assert_empty @ext.build_args\n\n    File.open @ext.build_info_file, 'w' do |io|\n      io.puts '--with-foo-dir=wherever'\n    end\n\n    assert_equal %w[--with-foo-dir=wherever], @ext.build_args\n  end\n\n  def test_build_extensions\n    ext_spec\n\n    refute_path_exists @ext.extension_dir, 'sanity check'\n    refute_empty @ext.extensions, 'sanity check'\n\n    extconf_rb = File.join @ext.gem_dir, @ext.extensions.first\n    FileUtils.mkdir_p File.dirname extconf_rb\n\n    File.open extconf_rb, 'w' do |f|\n      f.write <<-'RUBY'\n        File.open 'Makefile', 'w' do |f|\n          f.puts \"clean:\\n\\techo clean\"\n          f.puts \"default:\\n\\techo built\"\n          f.puts \"install:\\n\\techo installed\"\n        end\n      RUBY\n    end\n\n    @ext.build_extensions\n\n    assert_path_exists @ext.extension_dir\n  end\n\n  def test_default_spec_stub_is_marked_default\n    default = new_default_spec 'default', 2\n    install_default_gems default\n\n    stub = Gem::Specification.stubs.find { |s| s.name == 'default' }\n    assert_predicate stub, :default_gem?\n\n    stub = Gem::Specification.find_all_by_name('default').first\n    assert_predicate stub, :default_gem?\n  end\n\n  def test_build_extensions_built\n    ext_spec\n\n    refute_empty @ext.extensions, 'sanity check'\n\n    gem_build_complete =\n      File.join @ext.extension_dir, 'gem.build_complete'\n\n    FileUtils.mkdir_p @ext.extension_dir\n    FileUtils.touch gem_build_complete\n\n    @ext.build_extensions\n\n    gem_make_out = File.join @ext.extension_dir, 'gem_make.out'\n    refute_path_exists gem_make_out\n  end\n\n  def test_build_extensions_default_gem\n    spec = new_default_spec 'default', 1\n    spec.extensions << 'extconf.rb'\n\n    extconf_rb = File.join spec.gem_dir, spec.extensions.first\n    FileUtils.mkdir_p File.dirname extconf_rb\n\n    File.open extconf_rb, 'w' do |f|\n      f.write <<-'RUBY'\n        File.open 'Makefile', 'w' do |f|\n          f.puts \"default:\\n\\techo built\"\n          f.puts \"install:\\n\\techo installed\"\n        end\n      RUBY\n    end\n\n    spec.build_extensions\n\n    refute_path_exists spec.extension_dir\n  end\n\n  def test_build_extensions_error\n    ext_spec\n\n    refute_empty @ext.extensions, 'sanity check'\n\n    assert_raises Gem::Ext::BuildError do\n      @ext.build_extensions\n    end\n  end\n\n  def test_build_extensions_extensions_dir_unwritable\n    skip 'chmod not supported' if Gem.win_platform?\n    skip 'skipped in root privilege' if Process.uid.zero?\n\n    ext_spec\n\n    refute_empty @ext.extensions, 'sanity check'\n\n    extconf_rb = File.join @ext.gem_dir, @ext.extensions.first\n    FileUtils.mkdir_p File.dirname extconf_rb\n\n    File.open extconf_rb, 'w' do |f|\n      f.write <<-'RUBY'\n        File.open 'Makefile', 'w' do |f|\n          f.puts \"clean:\\n\\techo clean\"\n          f.puts \"default:\\n\\techo built\"\n          f.puts \"install:\\n\\techo installed\"\n        end\n      RUBY\n    end\n\n    FileUtils.mkdir_p File.join @ext.base_dir, 'extensions'\n    FileUtils.chmod 0555, @ext.base_dir\n    FileUtils.chmod 0555, File.join(@ext.base_dir, 'extensions')\n\n    @ext.build_extensions\n    refute_path_exists @ext.extension_dir\n  ensure\n    unless ($DEBUG or win_platform? or Process.uid.zero?) then\n      FileUtils.chmod 0755, File.join(@ext.base_dir, 'extensions')\n      FileUtils.chmod 0755, @ext.base_dir\n    end\n  end\n\n  def test_build_extensions_no_extensions_dir_unwritable\n    skip 'chmod not supported' if Gem.win_platform?\n\n    ext_spec\n\n    refute_empty @ext.extensions, 'sanity check'\n\n    extconf_rb = File.join @ext.gem_dir, @ext.extensions.first\n    FileUtils.mkdir_p File.dirname extconf_rb\n\n    File.open extconf_rb, 'w' do |f|\n      f.write <<-'RUBY'\n        File.open 'Makefile', 'w' do |f|\n          f.puts \"clean:\\n\\techo clean\"\n          f.puts \"default:\\n\\techo built\"\n          f.puts \"install:\\n\\techo installed\"\n        end\n      RUBY\n    end\n\n    FileUtils.rm_r File.join @gemhome, 'extensions'\n    FileUtils.chmod 0555, @gemhome\n\n    @ext.build_extensions\n\n    gem_make_out = File.join @ext.extension_dir, 'gem_make.out'\n    refute_path_exists gem_make_out\n  ensure\n    FileUtils.chmod 0755, @gemhome\n  end\n\n  def test_build_extensions_none\n    refute_path_exists @a1.extension_dir, 'sanity check'\n    assert_empty @a1.extensions, 'sanity check'\n\n    @a1.build_extensions\n\n    refute_path_exists @a1.extension_dir\n  end\n\n  def test_build_extensions_old\n    ext_spec\n\n    refute_empty @ext.extensions, 'sanity check'\n\n    @ext.installed_by_version = v(0)\n\n    @ext.build_extensions\n\n    gem_make_out = File.join @ext.extension_dir, 'gem_make.out'\n    refute_path_exists gem_make_out\n  end\n\n  def test_build_extensions_preview\n    ext_spec\n\n    extconf_rb = File.join @ext.gem_dir, @ext.extensions.first\n    FileUtils.mkdir_p File.dirname extconf_rb\n\n    File.open extconf_rb, 'w' do |f|\n      f.write <<-'RUBY'\n        File.open 'Makefile', 'w' do |f|\n          f.puts \"clean:\\n\\techo clean\"\n          f.puts \"default:\\n\\techo built\"\n          f.puts \"install:\\n\\techo installed\"\n        end\n      RUBY\n    end\n\n    refute_empty @ext.extensions, 'sanity check'\n\n    @ext.installed_by_version = v('2.2.0.preview.2')\n\n    @ext.build_extensions\n\n    gem_make_out = File.join @ext.extension_dir, 'gem_make.out'\n    assert_path_exists gem_make_out\n  end\n\n  def test_contains_requirable_file_eh\n    code_rb = File.join @a1.gem_dir, 'lib', 'code.rb'\n    FileUtils.mkdir_p File.dirname code_rb\n    FileUtils.touch code_rb\n\n    assert @a1.contains_requirable_file? 'code'\n  end\n\n  def test_contains_requirable_file_eh_extension\n    ext_spec\n\n    _, err = capture_io do\n      refute @ext.contains_requirable_file? 'nonexistent'\n    end\n\n    expected = \"Ignoring ext-1 because its extensions are not built. \" +\n               \"Try: gem pristine ext --version 1\\n\"\n\n    assert_equal expected, err\n  end\n\n  def test_date\n    assert_equal Gem::Specification::TODAY, @a1.date\n  end\n\n  def test_date_equals_date\n    @a1.date = Date.new(2003, 9, 17)\n    assert_equal Time.utc(2003, 9, 17, 0,0,0), @a1.date\n  end\n\n  def test_date_equals_string\n    @a1.date = '2003-09-17'\n    assert_equal Time.utc(2003, 9, 17, 0,0,0), @a1.date\n  end\n\n  def test_date_equals_string_bad\n    assert_raises Gem::InvalidSpecificationException do\n      @a1.date = '9/11/2003'\n    end\n  end\n\n  def test_date_equals_time\n    @a1.date = Time.local(2003, 9, 17, 0,0,0)\n    assert_equal Time.utc(2003, 9, 17, 0,0,0), @a1.date\n  end\n\n  def test_date_equals_time_local\n    @a1.date = Time.local(2003, 9, 17, 19,50,0) # may not pass in utc >= +4\n    assert_equal Time.utc(2003, 9, 17, 0,0,0), @a1.date\n  end\n\n  def test_date_equals_time_utc\n    @a1.date = Time.utc(2003, 9, 17, 19,50,0)\n    assert_equal Time.utc(2003, 9, 17, 0,0,0), @a1.date\n  end\n\n  def test_date_tolerates_hour_sec_zulu\n    @a1.date = \"2012-01-12 11:22:33.4444444 Z\"\n    assert_equal Time.utc(2012,01,12,0,0,0), @a1.date\n  end\n\n  def test_date_tolerates_hour_sec_and_timezone\n    @a1.date = \"2012-01-12 11:22:33.4444444 +02:33\"\n    assert_equal Time.utc(2012,01,12,0,0,0), @a1.date\n  end\n\n  def test_dependencies\n    util_setup_deps\n    assert_equal [@bonobo, @monkey], @gem.dependencies\n  end\n\n  def test_dependent_gems\n    util_setup_deps\n\n    assert_empty @gem.dependent_gems\n\n    bonobo = util_spec 'bonobo', 1\n    install_gem bonobo\n    install_gem @gem\n\n    expected = [\n      [@gem, @bonobo, [bonobo]],\n    ]\n\n    assert_equal expected, bonobo.dependent_gems\n  end\n\n  def test_doc_dir\n    assert_equal File.join(@gemhome, 'doc', 'a-1'), @a1.doc_dir\n  end\n\n  def test_doc_dir_type\n    assert_equal File.join(@gemhome, 'doc', 'a-1', 'ri'), @a1.doc_dir('ri')\n  end\n\n  def test_runtime_dependencies\n    util_setup_deps\n    assert_equal [@bonobo], @gem.runtime_dependencies\n  end\n\n  def test_development_dependencies\n    util_setup_deps\n    assert_equal [@monkey], @gem.development_dependencies\n  end\n\n  def test_description\n    assert_equal 'This is a test description', @a1.description\n  end\n\n  def test_eql_eh\n    g1 = new_spec 'gem', 1\n    g2 = new_spec 'gem', 1\n\n    assert_equal g1, g2\n    assert_equal g1.hash, g2.hash\n    assert_equal true, g1.eql?(g2)\n  end\n\n  def test_eql_eh_extensions\n    spec = @a1.dup\n    spec.extensions = 'xx'\n\n    refute_operator @a1, :eql?, spec\n    refute_operator spec, :eql?, @a1\n  end\n\n  def test_executables\n    @a1.executable = 'app'\n    assert_equal %w[app], @a1.executables\n  end\n\n  def test_executable_equals\n    @a2.executable = 'app'\n    assert_equal 'app', @a2.executable\n    assert_equal %w[bin/app lib/code.rb].sort, @a2.files\n  end\n\n  def test_extensions\n    assert_equal ['ext/extconf.rb'], ext_spec.extensions\n  end\n\n  def test_extension_dir\n    enable_shared, RbConfig::CONFIG['ENABLE_SHARED'] =\n      RbConfig::CONFIG['ENABLE_SHARED'], 'no'\n\n    ext_spec\n\n    refute_empty @ext.extensions\n\n    expected =\n      File.join(@ext.base_dir, 'extensions', Gem::Platform.local.to_s,\n                \"#{Gem.ruby_api_version}-static\", @ext.full_name)\n\n    assert_equal expected, @ext.extension_dir\n  ensure\n    RbConfig::CONFIG['ENABLE_SHARED'] = enable_shared\n  end\n\n  def test_extension_dir_override\n    enable_shared, RbConfig::CONFIG['ENABLE_SHARED'] =\n      RbConfig::CONFIG['ENABLE_SHARED'], 'no'\n\n    class << Gem\n      alias orig_default_ext_dir_for default_ext_dir_for\n\n      remove_method :default_ext_dir_for\n\n      def Gem.default_ext_dir_for(base_dir)\n        'elsewhere'\n      end\n    end\n\n    ext_spec\n\n    refute_empty @ext.extensions\n\n    expected = File.join @tempdir, 'elsewhere', @ext.full_name\n\n    assert_equal expected, @ext.extension_dir\n  ensure\n    RbConfig::CONFIG['ENABLE_SHARED'] = enable_shared\n\n    class << Gem\n      remove_method :default_ext_dir_for\n\n      alias default_ext_dir_for orig_default_ext_dir_for\n    end\n  end\n\n  def test_files\n    @a1.files = %w(files bin/common)\n    @a1.test_files = %w(test_files bin/common)\n    @a1.executables = %w(executables common)\n    @a1.extra_rdoc_files = %w(extra_rdoc_files bin/common)\n    @a1.extensions = %w(extensions bin/common)\n\n    expected = %w[\n      bin/common\n      bin/executables\n      extensions\n      extra_rdoc_files\n      files\n      test_files\n    ]\n    assert_equal expected, @a1.files\n  end\n\n  def test_files_append\n    @a1.files            = %w(files bin/common)\n    @a1.test_files       = %w(test_files bin/common)\n    @a1.executables      = %w(executables common)\n    @a1.extra_rdoc_files = %w(extra_rdoc_files bin/common)\n    @a1.extensions       = %w(extensions bin/common)\n\n    expected = %w[\n      bin/common\n      bin/executables\n      extensions\n      extra_rdoc_files\n      files\n      test_files\n    ]\n    assert_equal expected, @a1.files\n\n    @a1.files << \"generated_file.c\"\n\n    expected << \"generated_file.c\"\n    expected.sort!\n\n    assert_equal expected, @a1.files\n  end\n\n  def test_files_duplicate\n    @a2.files = %w[a b c d b]\n    @a2.extra_rdoc_files = %w[x y z x]\n    @a2.normalize\n\n    assert_equal %w[a b c d x y z], @a2.files\n    assert_equal %w[x y z], @a2.extra_rdoc_files\n  end\n\n  def test_files_extra_rdoc_files\n    @a2.files = %w[a b c d]\n    @a2.extra_rdoc_files = %w[x y z]\n    @a2.normalize\n    assert_equal %w[a b c d x y z], @a2.files\n  end\n\n  def test_files_non_array\n    @a1.files = \"F\"\n    @a1.test_files = \"TF\"\n    @a1.executables = \"X\"\n    @a1.extra_rdoc_files = \"ERF\"\n    @a1.extensions = \"E\"\n\n    assert_equal %w[E ERF F TF bin/X], @a1.files\n  end\n\n  def test_files_non_array_pathological\n    @a1.instance_variable_set :@files, \"F\"\n    @a1.instance_variable_set :@test_files, \"TF\"\n    @a1.instance_variable_set :@extra_rdoc_files, \"ERF\"\n    @a1.instance_variable_set :@extensions, \"E\"\n    @a1.instance_variable_set :@executables, \"X\"\n\n    assert_equal %w[E ERF F TF bin/X], @a1.files\n    assert_kind_of Integer, @a1.hash\n  end\n\n  def test_for_cache\n    @a2.add_runtime_dependency 'b', '1'\n    @a2.dependencies.first.instance_variable_set :@type, nil\n    @a2.required_rubygems_version = Gem::Requirement.new '> 0'\n    @a2.test_files = %w[test/test_b.rb]\n\n    refute_empty @a2.files\n    refute_empty @a2.test_files\n\n    spec = @a2.for_cache\n\n    assert_empty spec.files\n    assert_empty spec.test_files\n\n    refute_empty @a2.files\n    refute_empty @a2.test_files\n  end\n\n  def test_full_gem_path\n    assert_equal File.join(@gemhome, 'gems', @a1.full_name), @a1.full_gem_path\n\n    @a1.original_platform = 'mswin32'\n\n    assert_equal File.join(@gemhome, 'gems', @a1.original_name),\n                 @a1.full_gem_path\n  end\n\n  def test_full_gem_path_double_slash\n    gemhome = @gemhome.to_s.sub(/\\w\\//, '\\&/')\n    @a1.loaded_from = File.join gemhome, \"specifications\", @a1.spec_name\n\n    expected = File.join @gemhome, \"gems\", @a1.full_name\n    assert_equal expected, @a1.full_gem_path\n  end\n\n  def test_full_name\n    assert_equal 'a-1', @a1.full_name\n\n    @a1 = Gem::Specification.new \"a\", 1\n    @a1.platform = Gem::Platform.new ['universal', 'darwin', nil]\n    assert_equal 'a-1-universal-darwin', @a1.full_name\n\n    @a1 = Gem::Specification.new \"a\", 1\n    @a1.instance_variable_set :@new_platform, 'mswin32'\n    assert_equal 'a-1-mswin32', @a1.full_name, 'legacy'\n\n    return if win_platform?\n\n    @a1 = Gem::Specification.new \"a\", 1\n    @a1.platform = 'current'\n    assert_equal 'a-1-x86-darwin-8', @a1.full_name\n  end\n\n  def test_full_name_windows\n    test_cases = {\n      'i386-mswin32'      => 'a-1-x86-mswin32-60',\n      'i386-mswin32_80'   => 'a-1-x86-mswin32-80',\n      'i386-mingw32'      => 'a-1-x86-mingw32'\n    }\n\n    test_cases.each do |arch, expected|\n      @a1 = Gem::Specification.new \"a\", 1\n      util_set_arch arch\n      @a1.platform = 'current'\n      assert_equal expected, @a1.full_name\n    end\n  end\n\n  def test_gem_build_complete_path\n    expected = File.join @a1.extension_dir, 'gem.build_complete'\n    assert_equal expected, @a1.gem_build_complete_path\n  end\n\n  def test_hash\n    assert_equal @a1.hash, @a1.hash\n    assert_equal @a1.hash, @a1.dup.hash\n    refute_equal @a1.hash, @a2.hash\n  end\n\n  def test_installed_by_version\n    assert_equal v(0), @a1.installed_by_version\n\n    @a1.installed_by_version = Gem.rubygems_version\n\n    assert_equal Gem.rubygems_version, @a1.installed_by_version\n  end\n\n  def test_base_dir\n    assert_equal @gemhome, @a1.base_dir\n  end\n\n  def test_base_dir_not_loaded\n    @a1.instance_variable_set :@loaded_from, nil\n\n    assert_equal Gem.dir, @a1.base_dir\n  end\n\n  def test_base_dir_default\n    default_dir =\n      File.join Gem::Specification.default_specifications_dir, @a1.spec_name\n\n    @a1.instance_variable_set :@loaded_from, default_dir\n\n    assert_equal Gem.default_dir, @a1.base_dir\n  end\n\n  def test_lib_files\n    @a1.files = %w[lib/foo.rb Rakefile]\n\n    assert_equal %w[lib/foo.rb], @a1.lib_files\n  end\n\n  def test_license\n    assert_equal 'MIT', @a1.license\n  end\n\n  def test_licenses\n    assert_equal ['MIT'], @a1.licenses\n  end\n\n  def test_name\n    assert_equal 'a', @a1.name\n  end\n\n  def test_original_name\n    assert_equal 'a-1', @a1.full_name\n\n    @a1.platform = 'i386-linux'\n    @a1.instance_variable_set :@original_platform, 'i386-linux'\n    assert_equal 'a-1-i386-linux', @a1.original_name\n  end\n\n  def test_platform\n    assert_equal Gem::Platform::RUBY, @a1.platform\n  end\n\n  def test_platform_change_reset_full_name\n    orig_full_name = @a1.full_name\n\n    @a1.platform = \"universal-unknown\"\n    refute_equal orig_full_name, @a1.full_name\n  end\n\n  def test_platform_change_reset_cache_file\n    orig_cache_file = @a1.cache_file\n\n    @a1.platform = \"universal-unknown\"\n    refute_equal orig_cache_file, @a1.cache_file\n  end\n\n  def test_platform_equals\n    @a1.platform = nil\n    assert_equal Gem::Platform::RUBY, @a1.platform\n\n    @a1.platform = Gem::Platform::RUBY\n    assert_equal Gem::Platform::RUBY, @a1.platform\n\n    test_cases = {\n      'i386-mswin32'    => ['x86', 'mswin32', '60'],\n      'i386-mswin32_80' => ['x86', 'mswin32', '80'],\n      'i386-mingw32'    => ['x86', 'mingw32', nil ],\n      'x86-darwin8'     => ['x86', 'darwin',  '8' ],\n    }\n\n    test_cases.each do |arch, expected|\n      util_set_arch arch\n      @a1.platform = Gem::Platform::CURRENT\n      assert_equal Gem::Platform.new(expected), @a1.platform\n    end\n  end\n\n  def test_platform_equals_current\n    @a1.platform = Gem::Platform::CURRENT\n    assert_equal Gem::Platform.local, @a1.platform\n    assert_equal Gem::Platform.local.to_s, @a1.original_platform\n  end\n\n  def test_platform_equals_legacy\n    @a1.platform = 'mswin32'\n    assert_equal Gem::Platform.new('x86-mswin32'), @a1.platform\n\n    @a1.platform = 'i586-linux'\n    assert_equal Gem::Platform.new('x86-linux'), @a1.platform\n\n    @a1.platform = 'powerpc-darwin'\n    assert_equal Gem::Platform.new('ppc-darwin'), @a1.platform\n  end\n\n  def test_prerelease_spec_adds_required_rubygems_version\n    @prerelease = util_spec('tardis', '2.2.0.a')\n    refute @prerelease.required_rubygems_version.satisfied_by?(Gem::Version.new('1.3.1'))\n    assert @prerelease.required_rubygems_version.satisfied_by?(Gem::Version.new('1.4.0'))\n  end\n\n  def test_require_paths\n    enable_shared 'no' do\n      ext_spec\n\n      @ext.require_paths = 'lib'\n\n      assert_equal [@ext.extension_dir, 'lib'], @ext.require_paths\n    end\n  end\n\n  def test_require_paths_default_ext_dir_for\n    class << Gem\n      send :alias_method, :orig_default_ext_dir_for, :default_ext_dir_for\n\n      remove_method :default_ext_dir_for\n    end\n\n    def Gem.default_ext_dir_for base_dir\n      '/foo'\n    end\n\n    enable_shared 'no' do\n      ext_spec\n\n      @ext.require_paths = 'lib'\n\n      assert_equal [File.expand_path('/foo/ext-1'), 'lib'], @ext.require_paths\n    end\n  ensure\n    class << Gem\n      send :remove_method, :default_ext_dir_for\n      send :alias_method,  :default_ext_dir_for, :orig_default_ext_dir_for\n      send :remove_method, :orig_default_ext_dir_for\n    end\n  end\n\n  def test_source\n    assert_kind_of Gem::Source::Installed, @a1.source\n  end\n\n  def test_source_paths\n    ext_spec\n\n    @ext.require_paths = %w[lib ext foo]\n    @ext.extensions << 'bar/baz'\n\n    expected = %w[\n      lib\n      ext\n      foo\n      bar\n    ]\n\n    assert_equal expected, @ext.source_paths\n  end\n\n  def test_full_require_paths\n    ext_spec\n\n    @ext.require_paths = 'lib'\n\n    expected = [\n      File.join(@gemhome, 'gems', @ext.original_name, 'lib'),\n      @ext.extension_dir,\n    ]\n\n    assert_equal expected, @ext.full_require_paths\n  end\n\n  def test_to_fullpath\n    ext_spec\n\n    @ext.require_paths = 'lib'\n\n    dir = File.join(@gemhome, 'gems', @ext.original_name, 'lib')\n    expected_rb = File.join(dir, 'code.rb')\n    FileUtils.mkdir_p dir\n    FileUtils.touch expected_rb\n\n    dir = @ext.extension_dir\n    ext = RbConfig::CONFIG[\"DLEXT\"]\n    expected_so = File.join(dir, \"ext.#{ext}\")\n    FileUtils.mkdir_p dir\n    FileUtils.touch expected_so\n\n    assert_nil @ext.to_fullpath(\"code\")\n    assert_nil @ext.to_fullpath(\"code.rb\")\n    assert_nil @ext.to_fullpath(\"code.#{ext}\")\n\n    assert_nil @ext.to_fullpath(\"ext\")\n    assert_nil @ext.to_fullpath(\"ext.rb\")\n    assert_nil @ext.to_fullpath(\"ext.#{ext}\")\n\n    @ext.activate\n\n    assert_equal expected_rb, @ext.to_fullpath(\"code\")\n    assert_equal expected_rb, @ext.to_fullpath(\"code.rb\")\n    assert_nil @ext.to_fullpath(\"code.#{ext}\")\n\n    assert_equal expected_so, @ext.to_fullpath(\"ext\")\n    assert_nil @ext.to_fullpath(\"ext.rb\")\n    assert_equal expected_so, @ext.to_fullpath(\"ext.#{ext}\")\n\n    assert_nil @ext.to_fullpath(\"notexist\")\n  end\n\n  def test_fullpath_return_rb_extension_file_when_exist_the_same_name_file\n    ext_spec\n\n    @ext.require_paths = 'lib'\n\n    dir = File.join(@gemhome, 'gems', @ext.original_name, 'lib')\n    expected_rb = File.join(dir, 'code.rb')\n    FileUtils.mkdir_p dir\n    FileUtils.touch expected_rb\n\n    dir = @ext.extension_dir\n    ext = RbConfig::CONFIG[\"DLEXT\"]\n    expected_so = File.join(dir, \"code.#{ext}\")\n    FileUtils.mkdir_p dir\n    FileUtils.touch expected_so\n\n    @ext.activate\n\n    assert_equal expected_rb, @ext.to_fullpath(\"code\")\n  end\n\n  def test_require_already_activated\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", nil, \"lib/d.rb\"\n\n      install_specs a1 # , a2, b1, b2, c1, c2\n\n      a1.activate\n      assert_equal %w(a-1), loaded_spec_names\n      assert_equal [], unresolved_names\n\n      assert require \"d\"\n\n      assert_equal %w(a-1), loaded_spec_names\n      assert_equal [], unresolved_names\n    end\n  end\n\n  def test_require_already_activated_indirect_conflict\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      a2 = new_spec \"a\", \"2\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 1\"\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 2\"\n      c1 = new_spec \"c\", \"1\", nil, \"lib/d.rb\"\n      c2 = new_spec(\"c\", \"2\", { \"a\" => \"1\" }, \"lib/d.rb\") # conflicts with a-2\n\n      install_specs c1, b1, a1, a2, c2, b2\n\n      a1.activate\n      c1.activate\n      assert_equal %w(a-1 c-1), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n\n      assert require \"d\"\n\n      assert_equal %w(a-1 c-1), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n    end\n  end\n\n  def test_requirements\n    assert_equal ['A working computer'], @a1.requirements\n  end\n\n  def test_allowed_push_host\n    assert_equal nil, @a1.metadata['allowed_push_host']\n    assert_equal 'https://privategemserver.com', @a3.metadata['allowed_push_host']\n  end\n\n  def test_runtime_dependencies_legacy\n    make_spec_c1\n    # legacy gems don't have a type\n    @c1.runtime_dependencies.each do |dep|\n      dep.instance_variable_set :@type, nil\n    end\n\n    expected = %w[rake jabber4r pqa]\n\n    assert_equal expected, @c1.runtime_dependencies.map { |d| d.name }\n  end\n\n  def test_spaceship_name\n    s1 = new_spec 'a', '1'\n    s2 = new_spec 'b', '1'\n\n    assert_equal(-1, (s1 <=> s2))\n    assert_equal( 0, (s1 <=> s1))\n    assert_equal( 1, (s2 <=> s1))\n  end\n\n  def test_spaceship_platform\n    s1 = new_spec 'a', '1'\n    s2 = new_spec 'a', '1' do |s|\n      s.platform = Gem::Platform.new 'x86-my_platform1'\n    end\n\n    assert_equal( -1, (s1 <=> s2))\n    assert_equal(  0, (s1 <=> s1))\n    assert_equal(  1, (s2 <=> s1))\n  end\n\n  def test_spaceship_version\n    s1 = new_spec 'a', '1'\n    s2 = new_spec 'a', '2'\n\n    assert_equal( -1, (s1 <=> s2))\n    assert_equal(  0, (s1 <=> s1))\n    assert_equal(  1, (s2 <=> s1))\n  end\n\n  def test_spec_file\n    assert_equal File.join(@gemhome, 'specifications', 'a-1.gemspec'),\n                 @a1.spec_file\n  end\n\n  def test_spec_name\n    assert_equal 'a-1.gemspec', @a1.spec_name\n  end\n\n  def test_summary\n    assert_equal 'this is a summary', @a1.summary\n  end\n\n  def test_test_files\n    @a1.test_file = 'test/suite.rb'\n    assert_equal ['test/suite.rb'], @a1.test_files\n  end\n\n  def test_runtime_predicate_true\n    @a2.add_runtime_dependency 'b', '1'\n    assert_predicate @a2.dependencies.first, :runtime?\n\n    @a2.dependencies.first.instance_variable_set :@type, nil\n    assert_predicate @a2.dependencies.first, :runtime?\n  end\n\n  def test_runtime_predicate_false\n    @a2.add_development_dependency 'b', '1'\n    refute_predicate @a2.dependencies.first, :runtime?\n  end\n\n  def test_to_ruby\n    @a2.add_runtime_dependency 'b', '1'\n    @a2.dependencies.first.instance_variable_set :@type, nil\n    @a2.required_rubygems_version = Gem::Requirement.new '> 0'\n    @a2.require_paths << 'other'\n\n    ruby_code = @a2.to_ruby\n\n    expected = <<-SPEC\n# -*- encoding: utf-8 -*-\n# stub: a 2 ruby lib\\0other\n\nGem::Specification.new do |s|\n  s.name = \"a\".freeze\n  s.version = \"2\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\\\"> 0\\\".freeze) if s.respond_to? :required_rubygems_version=\n  s.require_paths = [\"lib\".freeze, \"other\".freeze]\n  s.authors = [\"A User\".freeze]\n  s.date = \"#{Gem::Specification::TODAY.strftime \"%Y-%m-%d\"}\"\n  s.description = \"This is a test description\".freeze\n  s.email = \"example@example.com\".freeze\n  s.files = [\"lib/code.rb\".freeze]\n  s.homepage = \"http://example.com\".freeze\n  s.rubygems_version = \"#{Gem::VERSION}\".freeze\n  s.summary = \"this is a summary\".freeze\n\n  if s.respond_to? :specification_version then\n    s.specification_version = #{Gem::Specification::CURRENT_SPECIFICATION_VERSION}\n\n    if Gem::Version.new(Gem::VERSION) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<b>.freeze, [\\\"= 1\\\"])\n    else\n      s.add_dependency(%q<b>.freeze, [\\\"= 1\\\"])\n    end\n  else\n    s.add_dependency(%q<b>.freeze, [\\\"= 1\\\"])\n  end\nend\n    SPEC\n\n    assert_equal expected, ruby_code\n\n    same_spec = eval ruby_code\n\n    assert_equal @a2, same_spec\n  end\n\n  def test_to_ruby_for_cache\n    @a2.add_runtime_dependency 'b', '1'\n    @a2.dependencies.first.instance_variable_set :@type, nil\n    @a2.required_rubygems_version = Gem::Requirement.new '> 0'\n    @a2.installed_by_version = Gem.rubygems_version\n\n    # cached specs do not have spec.files populated:\n    ruby_code = @a2.to_ruby_for_cache\n\n    expected = <<-SPEC\n# -*- encoding: utf-8 -*-\n# stub: a 2 ruby lib\n\nGem::Specification.new do |s|\n  s.name = \"a\".freeze\n  s.version = \"2\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\\\"> 0\\\".freeze) if s.respond_to? :required_rubygems_version=\n  s.require_paths = [\"lib\".freeze]\n  s.authors = [\"A User\".freeze]\n  s.date = \"#{Gem::Specification::TODAY.strftime \"%Y-%m-%d\"}\"\n  s.description = \"This is a test description\".freeze\n  s.email = \"example@example.com\".freeze\n  s.homepage = \"http://example.com\".freeze\n  s.rubygems_version = \"#{Gem::VERSION}\".freeze\n  s.summary = \"this is a summary\".freeze\n\n  s.installed_by_version = \"#{Gem::VERSION}\" if s.respond_to? :installed_by_version\n\n  if s.respond_to? :specification_version then\n    s.specification_version = #{Gem::Specification::CURRENT_SPECIFICATION_VERSION}\n\n    if Gem::Version.new(Gem::VERSION) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<b>.freeze, [\\\"= 1\\\"])\n    else\n      s.add_dependency(%q<b>.freeze, [\\\"= 1\\\"])\n    end\n  else\n    s.add_dependency(%q<b>.freeze, [\\\"= 1\\\"])\n  end\nend\n    SPEC\n\n    assert_equal expected, ruby_code\n\n    same_spec = eval ruby_code\n\n    # cached specs do not have spec.files populated:\n    @a2.files = []\n    assert_equal @a2, same_spec\n  end\n\n  def test_to_ruby_fancy\n    make_spec_c1\n\n    @c1.platform = Gem::Platform.local\n    ruby_code = @c1.to_ruby\n\n    local = Gem::Platform.local\n    expected_platform = \"[#{local.cpu.inspect}, #{local.os.inspect}, #{local.version.inspect}]\"\n    stub_require_paths =\n      @c1.instance_variable_get(:@require_paths).join \"\\u0000\"\n    extensions = @c1.extensions.join \"\\u0000\"\n\n    expected = <<-SPEC\n# -*- encoding: utf-8 -*-\n# stub: a 1 #{win_platform? ? \"x86-mswin32-60\" : \"x86-darwin-8\"} #{stub_require_paths}\n# stub: #{extensions}\n\nGem::Specification.new do |s|\n  s.name = \"a\".freeze\n  s.version = \"1\"\n  s.platform = Gem::Platform.new(#{expected_platform})\n\n  s.required_rubygems_version = Gem::Requirement.new(\\\">= 0\\\".freeze) if s.respond_to? :required_rubygems_version=\n  s.require_paths = [\"lib\".freeze]\n  s.authors = [\"A User\".freeze]\n  s.date = \"#{Gem::Specification::TODAY.strftime \"%Y-%m-%d\"}\"\n  s.description = \"This is a test description\".freeze\n  s.email = \"example@example.com\".freeze\n  s.executables = [\"exec\".freeze]\n  s.extensions = [\"ext/a/extconf.rb\".freeze]\n  s.files = [\"bin/exec\".freeze, \"ext/a/extconf.rb\".freeze, \"lib/code.rb\".freeze, \"test/suite.rb\".freeze]\n  s.homepage = \"http://example.com\".freeze\n  s.licenses = [\"MIT\".freeze]\n  s.requirements = [\"A working computer\".freeze]\n  s.rubyforge_project = \"example\".freeze\n  s.rubygems_version = \"#{Gem::VERSION}\".freeze\n  s.summary = \"this is a summary\".freeze\n  s.test_files = [\"test/suite.rb\".freeze]\n\n  if s.respond_to? :specification_version then\n    s.specification_version = 4\n\n    if Gem::Version.new(Gem::VERSION) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<rake>.freeze, [\\\"> 0.4\\\"])\n      s.add_runtime_dependency(%q<jabber4r>.freeze, [\\\"> 0.0.0\\\"])\n      s.add_runtime_dependency(%q<pqa>.freeze, [\\\"<= 0.6\\\", \\\"> 0.4\\\"])\n    else\n      s.add_dependency(%q<rake>.freeze, [\\\"> 0.4\\\"])\n      s.add_dependency(%q<jabber4r>.freeze, [\\\"> 0.0.0\\\"])\n      s.add_dependency(%q<pqa>.freeze, [\\\"<= 0.6\\\", \\\"> 0.4\\\"])\n    end\n  else\n    s.add_dependency(%q<rake>.freeze, [\\\"> 0.4\\\"])\n    s.add_dependency(%q<jabber4r>.freeze, [\\\"> 0.0.0\\\"])\n    s.add_dependency(%q<pqa>.freeze, [\\\"<= 0.6\\\", \\\"> 0.4\\\"])\n  end\nend\n    SPEC\n\n    assert_equal expected, ruby_code\n\n    same_spec = eval ruby_code\n\n    assert_equal @c1, same_spec\n  end\n\n  def test_to_ruby_legacy\n    gemspec1 = Gem::Deprecate.skip_during do\n      eval LEGACY_RUBY_SPEC\n    end\n    ruby_code = gemspec1.to_ruby\n    gemspec2 = eval ruby_code\n\n    assert_equal gemspec1, gemspec2\n  end\n\n  def test_to_ruby_nested_hash\n    metadata = {}\n    metadata[metadata] = metadata\n\n    @a2.metadata = metadata\n\n    ruby = @a2.to_ruby\n\n    assert_match %r%^  s\\.metadata = \\{ \"%, ruby\n  end\n\n  def test_to_ruby_platform\n    @a2.platform = Gem::Platform.local\n    @a2.instance_variable_set :@original_platform, 'old_platform'\n\n    ruby_code = @a2.to_ruby\n\n    same_spec = eval ruby_code\n\n    assert_equal 'old_platform', same_spec.original_platform\n  end\n\n  def test_to_yaml\n    yaml_str = @a1.to_yaml\n\n    refute_match '!!null', yaml_str\n\n    same_spec = Gem::Specification.from_yaml(yaml_str)\n\n    assert_equal @a1, same_spec\n  end\n\n  def test_to_yaml_fancy\n    @a1.platform = Gem::Platform.local\n    yaml_str = @a1.to_yaml\n\n    same_spec = Gem::Specification.from_yaml(yaml_str)\n\n    assert_equal Gem::Platform.local, same_spec.platform\n\n    assert_equal @a1, same_spec\n  end\n\n  def test_to_yaml_platform_empty_string\n    @a1.instance_variable_set :@original_platform, ''\n\n    assert_match %r|^platform: ruby$|, @a1.to_yaml\n  end\n\n  def test_to_yaml_platform_legacy\n    @a1.platform = 'powerpc-darwin7.9.0'\n    @a1.instance_variable_set :@original_platform, 'powerpc-darwin7.9.0'\n\n    yaml_str = @a1.to_yaml\n\n    same_spec = YAML.load yaml_str\n\n    assert_equal Gem::Platform.new('powerpc-darwin7'), same_spec.platform\n    assert_equal 'powerpc-darwin7.9.0', same_spec.original_platform\n  end\n\n  def test_to_yaml_platform_nil\n    @a1.instance_variable_set :@original_platform, nil\n\n    assert_match %r|^platform: ruby$|, @a1.to_yaml\n  end\n\n  def test_validate\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      assert @a1.validate\n    end\n  end\n\n  def x s; s.gsub(/xxx/, ''); end\n  def w; x \"WARxxxNING\"; end\n  def t; x \"TOxxxDO\"; end\n  def f; x \"FxxxIXME\"; end\n\n  def test_validate_authors\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.authors = [\"\"]\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  no author specified\\n\", @ui.error, 'error'\n\n      @a1.authors = [Object.new]\n\n      assert_equal [], @a1.authors\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal \"authors may not be empty\", e.message\n\n      @a1.authors = [\"#{f} (who is writing this software)\"]\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not an author}, e.message\n\n      @a1.authors = [\"#{t} (who is writing this software)\"]\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not an author}, e.message\n    end\n  end\n\n  def test_validate_autorequire\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.autorequire = 'code'\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  deprecated autorequire specified\\n\",\n                   @ui.error, 'error'\n    end\n  end\n\n  def test_validate_dependencies\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.add_runtime_dependency     'b', '>= 1.0.rc1'\n      @a1.add_development_dependency 'c', '>= 2.0.rc2'\n      @a1.add_runtime_dependency     'd', '~> 1.2.3'\n      @a1.add_runtime_dependency     'e', '~> 1.2.3.4'\n      @a1.add_runtime_dependency     'g', '~> 1.2.3', '>= 1.2.3.4'\n      @a1.add_runtime_dependency     'h', '>= 1.2.3', '<= 2'\n      @a1.add_runtime_dependency     'i', '>= 1.2'\n      @a1.add_runtime_dependency     'j', '>= 1.2.3'\n      @a1.add_runtime_dependency     'k', '> 1.2'\n      @a1.add_runtime_dependency     'l', '> 1.2.3'\n      @a1.add_runtime_dependency     'm', '~> 2.1.0'\n      @a1.add_runtime_dependency     'n', '~> 0.1.0'\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      expected = <<-EXPECTED\n#{w}:  prerelease dependency on b (>= 1.0.rc1) is not recommended\n#{w}:  prerelease dependency on c (>= 2.0.rc2, development) is not recommended\n#{w}:  pessimistic dependency on d (~> 1.2.3) may be overly strict\n  if d is semantically versioned, use:\n    add_runtime_dependency 'd', '~> 1.2', '>= 1.2.3'\n#{w}:  pessimistic dependency on e (~> 1.2.3.4) may be overly strict\n  if e is semantically versioned, use:\n    add_runtime_dependency 'e', '~> 1.2', '>= 1.2.3.4'\n#{w}:  open-ended dependency on i (>= 1.2) is not recommended\n  if i is semantically versioned, use:\n    add_runtime_dependency 'i', '~> 1.2'\n#{w}:  open-ended dependency on j (>= 1.2.3) is not recommended\n  if j is semantically versioned, use:\n    add_runtime_dependency 'j', '~> 1.2', '>= 1.2.3'\n#{w}:  open-ended dependency on k (> 1.2) is not recommended\n  if k is semantically versioned, use:\n    add_runtime_dependency 'k', '~> 1.2', '> 1.2'\n#{w}:  open-ended dependency on l (> 1.2.3) is not recommended\n  if l is semantically versioned, use:\n    add_runtime_dependency 'l', '~> 1.2', '> 1.2.3'\n#{w}:  pessimistic dependency on m (~> 2.1.0) may be overly strict\n  if m is semantically versioned, use:\n    add_runtime_dependency 'm', '~> 2.1', '>= 2.1.0'\n#{w}:  See http://guides.rubygems.org/specification-reference/ for help\n      EXPECTED\n\n      assert_equal expected, @ui.error, 'warning'\n    end\n  end\n\n  def test_validate_dependencies_duplicates\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.add_runtime_dependency 'b', '~> 1.2'\n      @a1.add_runtime_dependency 'b', '>= 1.2.3'\n      @a1.add_development_dependency 'c', '~> 1.2'\n      @a1.add_development_dependency 'c', '>= 1.2.3'\n\n      use_ui @ui do\n        e = assert_raises Gem::InvalidSpecificationException do\n          @a1.validate\n        end\n\n        expected = <<-EXPECTED\nduplicate dependency on b (>= 1.2.3), (~> 1.2) use:\n    add_runtime_dependency 'b', '>= 1.2.3', '~> 1.2'\nduplicate dependency on c (>= 1.2.3, development), (~> 1.2) use:\n    add_development_dependency 'c', '>= 1.2.3', '~> 1.2'\n        EXPECTED\n\n        assert_equal expected, e.message\n      end\n\n      assert_equal <<-EXPECTED, @ui.error\n#{w}:  See http://guides.rubygems.org/specification-reference/ for help\n      EXPECTED\n    end\n  end\n\n  def test_validate_dependencies_allowed_duplicates\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.add_runtime_dependency 'b', '~> 1.2'\n      @a1.add_development_dependency 'b', '= 1.2.3'\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_equal '', @ui.error, 'warning'\n    end\n  end\n\n  def test_validate_prerelease_dependencies_with_prerelease_version\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.version = '1.0.0.beta.1'\n      @a1.add_runtime_dependency 'b', '~> 1.2.0.beta.1'\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_equal '', @ui.error, 'warning'\n    end\n  end\n\n  def test_validate_description\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.description = ''\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      @ui = Gem::MockGemUi.new\n      @a1.summary = \"this is my summary\"\n      @a1.description = @a1.summary\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  description and summary are identical\\n\",\n                   @ui.error, \"error\"\n\n      @a1.description = \"#{f} (describe your package)\"\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not a description}, e.message\n\n      @a1.description = \"#{t} (describe your package)\"\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not a description}, e.message\n    end\n  end\n\n  def test_validate_email\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.email = \"FIxxxXME (your e-mail)\".sub(/xxx/, \"\")\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not an email}, e.message\n\n      @a1.email = \"#{t} (your e-mail)\"\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not an email}, e.message\n    end\n  end\n\n  def test_validate_empty\n    e = assert_raises Gem::InvalidSpecificationException do\n      Gem::Specification.new.validate\n    end\n\n    assert_equal 'missing value for attribute name', e.message\n  end\n\n  def test_validate_error\n    assert_raises Gem::InvalidSpecificationException do\n      use_ui @ui do\n        Gem::Specification.new.validate\n      end\n    end\n\n    assert_match 'See http://guides.rubygems.org/specification-reference/ for help', @ui.error\n  end\n\n  def test_validate_executables\n    util_setup_validate\n\n    FileUtils.mkdir_p File.join(@tempdir, 'bin')\n    File.open File.join(@tempdir, 'bin', 'exec'), 'w' do end\n    FileUtils.mkdir_p File.join(@tempdir, 'exec')\n\n    use_ui @ui do\n      Dir.chdir @tempdir do\n        assert @a1.validate\n      end\n    end\n\n    assert_equal %w[exec], @a1.executables\n\n    assert_equal '', @ui.output, 'output'\n    assert_match \"#{w}:  bin/exec is missing #! line\\n\", @ui.error, 'error'\n  end\n\n  def test_validate_empty_require_paths\n    if win_platform? then\n      skip 'test_validate_empty_require_paths skipped on MS Windows (symlink)'\n    else\n      util_setup_validate\n\n      @a1.require_paths = []\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal 'specification must have at least one require_path',\n                   e.message\n    end\n  end\n\n  def test_validate_files\n    skip 'test_validate_files skipped on MS Windows (symlink)' if win_platform?\n    util_setup_validate\n\n    @a1.files += ['lib', 'lib2']\n    @a1.extensions << 'ext/a/extconf.rb'\n\n    Dir.chdir @tempdir do\n      FileUtils.ln_s 'lib/code.rb', 'lib2' unless vc_windows?\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match 'WARNING:  lib2 is a symlink, which is not supported on all platforms', @ui.error\n    end\n\n    assert_equal %w[bin/exec ext/a/extconf.rb lib/code.rb lib2 test/suite.rb].sort,\n                 @a1.files\n  end\n\n  def test_validate_files_recursive\n    util_setup_validate\n    FileUtils.touch @a1.file_name\n\n    @a1.files = [@a1.file_name]\n\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n\n    assert_equal \"#{@a1.full_name} contains itself (#{@a1.file_name}), check your files list\",\n                 e.message\n  end\n\n  def test_validate_homepage\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.homepage = nil\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  no homepage specified\\n\", @ui.error, 'error'\n\n      @ui = Gem::MockGemUi.new\n\n      @a1.homepage = ''\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  no homepage specified\\n\", @ui.error, 'error'\n\n      @a1.homepage = 'over at my cool site'\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal '\"over at my cool site\" is not a URI', e.message\n    end\n  end\n\n  def test_validate_license\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses.clear\n      @a1.validate\n    end\n\n    assert_match <<-warning, @ui.error\nWARNING:  licenses is empty, but is recommended.  Use a license identifier from\nhttp://spdx.org/licenses or 'Nonstandard' for a nonstandard license.\n    warning\n  end\n\n  def test_validate_license_values\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses = ['BSD']\n      @a1.validate\n    end\n\n    assert_match <<-warning, @ui.error\nWARNING:  license value 'BSD' is invalid.  Use a license identifier from\nhttp://spdx.org/licenses or 'Nonstandard' for a nonstandard license.\n    warning\n  end\n\n  def test_validate_license_values_plus\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses = ['GPL-2.0+']\n      @a1.validate\n    end\n\n    assert_empty @ui.error\n  end\n\n  def test_validate_license_values_with\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses = ['GPL-2.0+ WITH Autoconf-exception-2.0']\n      @a1.validate\n    end\n\n    assert_empty @ui.error\n  end\n\n  def test_validate_license_with_nonsense_suffix\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses = ['GPL-2.0+ FOO', 'GPL-2.0 FOO']\n      @a1.validate\n    end\n\n    assert_match <<-warning, @ui.error\nWARNING:  license value 'GPL-2.0+ FOO' is invalid.  Use a license identifier from\nhttp://spdx.org/licenses or 'Nonstandard' for a nonstandard license.\n    warning\n    assert_match <<-warning, @ui.error\nWARNING:  license value 'GPL-2.0 FOO' is invalid.  Use a license identifier from\nhttp://spdx.org/licenses or 'Nonstandard' for a nonstandard license.\n    warning\n  end\n\n  def test_validate_license_gives_suggestions\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses = ['ruby']\n      @a1.validate\n    end\n\n    assert_match <<-warning, @ui.error\nWARNING:  license value 'ruby' is invalid.  Use a license identifier from\nhttp://spdx.org/licenses or 'Nonstandard' for a nonstandard license.\nDid you mean 'Ruby'?\n    warning\n  end\n\n  def test_validate_empty_files\n    util_setup_validate\n\n    use_ui @ui do\n      # we have to set all of these for #files to be empty\n      @a1.files = []\n      @a1.test_files = []\n      @a1.executables = []\n\n      @a1.validate\n    end\n\n    assert_match \"no files specified\", @ui.error\n  end\n\n  def test_validate_empty_homepage\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.homepage = nil\n      @a1.validate\n    end\n\n    assert_match \"no homepage specified\", @ui.error\n  end\n\n  def test_validate_empty_summary\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.summary = nil\n      @a1.validate\n    end\n\n    assert_match \"no summary specified\", @ui.error\n  end\n\n  def test_validate_name\n    util_setup_validate\n\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.name = :json\n      @a1.validate\n    end\n\n    assert_equal 'invalid value for attribute name: \":json\" must be a string', e.message\n\n    @a1.name = []\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n    assert_equal \"invalid value for attribute name: \\\"[]\\\" must be a string\", e.message\n\n    @a1.name = \"\"\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n    assert_equal \"invalid value for attribute name: \\\"\\\" must include at least one letter\", e.message\n\n    @a1.name = \"12345\"\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n    assert_equal \"invalid value for attribute name: \\\"12345\\\" must include at least one letter\", e.message\n\n    @a1.name = \"../malicious\"\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n    assert_equal \"invalid value for attribute name: \\\"../malicious\\\" can only include letters, numbers, dashes, and underscores\", e.message\n\n    @a1.name = \"\\ba\\t\"\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n    assert_equal \"invalid value for attribute name: \\\"\\\\ba\\\\t\\\" can only include letters, numbers, dashes, and underscores\", e.message\n  end\n\n  def test_validate_non_nil\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      assert @a1.validate\n\n      Gem::Specification.non_nil_attributes.each do |name|\n        next if name == :files # set by #normalize\n        spec = @a1.dup\n        spec.instance_variable_set \"@#{name}\", nil\n\n        e = assert_raises Gem::InvalidSpecificationException do\n          spec.validate\n        end\n\n        assert_match %r%^#{name}%, e.message\n      end\n    end\n  end\n\n  def test_validate_permissions\n    skip 'chmod not supported' if Gem.win_platform?\n\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      File.chmod 0640, File.join('lib', 'code.rb')\n      File.chmod 0640, File.join('bin', 'exec')\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  lib/code.rb is not world-readable\\n\", @ui.error\n      assert_match \"#{w}:  bin/exec is not world-readable\\n\", @ui.error\n      assert_match \"#{w}:  bin/exec is not executable\\n\", @ui.error\n    end\n  end\n\n  def test_validate_permissions_of_missing_file_non_packaging\n    skip 'chmod not supported' if Gem.win_platform?\n\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      File.delete File.join('lib', 'code.rb')\n\n      use_ui @ui do\n        assert @a1.validate(false)\n      end\n    end\n  end\n\n  def test_validate_platform_legacy\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.platform = 'mswin32'\n      assert @a1.validate\n\n      @a1.platform = 'i586-linux'\n      assert @a1.validate\n\n      @a1.platform = 'powerpc-darwin'\n      assert @a1.validate\n    end\n  end\n\n  def test_validate_rubygems_version\n    util_setup_validate\n\n    @a1.rubygems_version = \"3\"\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n\n    assert_equal \"expected RubyGems version #{Gem::VERSION}, was 3\",\n                 e.message\n  end\n\n  def test_validate_specification_version\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.specification_version = '1.0'\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        use_ui @ui do\n          @a1.validate\n        end\n      end\n\n      err = 'specification_version must be an Integer (did you mean version?)'\n      assert_equal err, e.message\n    end\n  end\n\n  def test_validate_summary\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.summary = ''\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  no summary specified\\n\", @ui.error, 'error'\n\n      @a1.summary = \"#{f} (describe your package)\"\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not a summary}, e.message\n\n      @a1.summary = \"#{t} (describe your package)\"\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not a summary}, e.message\n    end\n  end\n\n  def test_validate_warning\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses.clear\n      @a1.validate\n    end\n\n    assert_match 'See http://guides.rubygems.org/specification-reference/ for help', @ui.error\n  end\n\n  def test_version\n    assert_equal Gem::Version.new('1'), @a1.version\n  end\n\n  def test_version_change_reset_full_name\n    orig_full_name = @a1.full_name\n\n    @a1.version = \"2\"\n\n    refute_equal orig_full_name, @a1.full_name\n  end\n\n  def test_version_change_reset_cache_file\n    orig_cache_file = @a1.cache_file\n\n    @a1.version = \"2\"\n\n    refute_equal orig_cache_file, @a1.cache_file\n  end\n\n  def test__load_fixes_Date_objects\n    spec = new_spec \"a\", 1\n    spec.instance_variable_set :@date, Date.today\n\n    spec = Marshal.load Marshal.dump(spec)\n\n    assert_kind_of Time, spec.date\n  end\n\n  def test_load_errors_contain_filename\n    specfile = Tempfile.new(self.class.name.downcase)\n    specfile.write \"raise 'boom'\"\n    specfile.close\n    begin\n      capture_io do\n        Gem::Specification.load(specfile.path)\n      end\n    rescue => e\n      name_rexp = Regexp.new(Regexp.escape(specfile.path))\n      assert e.backtrace.grep(name_rexp).any?\n    end\n  ensure\n    specfile.delete\n  end\n\n  ##\n  # KEEP p-1-x86-darwin-8\n  # KEEP p-1\n  # KEEP c-1.2\n  # KEEP a_evil-9\n  #      a-1\n  #      a-1-x86-my_platform-1\n  # KEEP a-2\n  #      a-2-x86-other_platform-1\n  # KEEP a-2-x86-my_platform-1\n  #      a-3.a\n  # KEEP a-3-x86-other_platform-1\n\n  def test_latest_specs\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 1 do |s|\n        s.platform = Gem::Platform.new 'x86-my_platform1'\n      end\n\n      fetcher.spec 'a', 2\n\n      fetcher.spec 'a', 2 do |s|\n        s.platform = Gem::Platform.new 'x86-my_platform1'\n      end\n\n      fetcher.spec 'a', 2 do |s|\n        s.platform = Gem::Platform.new 'x86-other_platform1'\n      end\n\n      fetcher.spec 'a', 3 do |s|\n        s.platform = Gem::Platform.new 'x86-other_platform1'\n      end\n    end\n\n    expected = %W[\n                  a-2\n                  a-2-x86-my_platform-1\n                  a-3-x86-other_platform-1\n                 ]\n\n    latest_specs = Gem::Specification.latest_specs.map(&:full_name).sort\n\n    assert_equal expected, latest_specs\n  end\n\n  def test_metadata_validates_ok\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @m1 = quick_gem 'm', '1' do |s|\n        s.files = %w[lib/code.rb]\n        s.metadata = {\n          \"one\"          => \"two\",\n          \"home\"         => \"three\",\n          \"homepage_uri\" => \"https://example.com/user/repo\"\n        }\n      end\n\n      use_ui @ui do\n        @m1.validate\n      end\n    end\n  end\n\n  def test_metadata_key_type_validation_fails\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @m2 = quick_gem 'm', '2' do |s|\n        s.files = %w[lib/code.rb]\n        s.metadata = { 1 => \"fail\" }\n      end\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @m2.validate\n      end\n\n      assert_equal \"metadata keys must be a String\", e.message\n    end\n  end\n\n  def test_metadata_key_size_validation_fails\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @m2 = quick_gem 'm', '2' do |s|\n        s.files = %w[lib/code.rb]\n        s.metadata = { (\"x\" * 129) => \"fail\" }\n      end\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @m2.validate\n      end\n\n      assert_equal \"metadata key too large (129 > 128)\", e.message\n    end\n  end\n\n  def test_metadata_value_type_validation_fails\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @m2 = quick_gem 'm', '2' do |s|\n        s.files = %w[lib/code.rb]\n        s.metadata = { 'fail' => [] }\n      end\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @m2.validate\n      end\n\n      assert_equal \"metadata values must be a String\", e.message\n    end\n  end\n\n  def test_metadata_value_size_validation_fails\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @m2 = quick_gem 'm', '2' do |s|\n        s.files = %w[lib/code.rb]\n        s.metadata = { 'fail' => (\"x\" * 1025) }\n      end\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @m2.validate\n      end\n\n      assert_equal \"metadata value too large (1025 > 1024)\", e.message\n    end\n  end\n\n  def test_metadata_link_validation_fails\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @m2 = quick_gem 'm', '2' do |s|\n        s.files = %w[lib/code.rb]\n        s.metadata = { 'homepage_uri' => 'http:/example.com' }\n      end\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @m2.validate\n      end\n\n      assert_equal \"metadata['homepage_uri'] has invalid link: \\\"http:/example.com\\\"\", e.message\n    end\n  end\n\n  def test_metadata_specs\n    valid_ruby_spec = <<-EOF\n# -*- encoding: utf-8 -*-\n# stub: m 1 ruby lib\n\nGem::Specification.new do |s|\n  s.name = \"m\".freeze\n  s.version = \"1\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\".freeze) if s.respond_to? :required_rubygems_version=\n  s.metadata = { \"one\" => \"two\", \"two\" => \"three\" } if s.respond_to? :metadata=\n  s.require_paths = [\"lib\".freeze]\n  s.authors = [\"A User\".freeze]\n  s.date = \"#{Gem::Specification::TODAY.strftime(\"%Y-%m-%d\")}\"\n  s.description = \"This is a test description\".freeze\n  s.email = \"example@example.com\".freeze\n  s.files = [\"lib/code.rb\".freeze]\n  s.homepage = \"http://example.com\".freeze\n  s.rubygems_version = \"#{Gem::VERSION}\".freeze\n  s.summary = \"this is a summary\".freeze\nend\n    EOF\n\n    @m1 = quick_gem 'm', '1' do |s|\n      s.files = %w[lib/code.rb]\n      s.metadata = { 'one' => \"two\", 'two' => \"three\" }\n    end\n\n    assert_equal @m1.to_ruby, valid_ruby_spec\n  end\n\n  def test_missing_extensions_eh\n    ext_spec\n\n    assert @ext.missing_extensions?\n\n    extconf_rb = File.join @ext.gem_dir, @ext.extensions.first\n    FileUtils.mkdir_p File.dirname extconf_rb\n\n    File.open extconf_rb, 'w' do |f|\n      f.write <<-'RUBY'\n        File.open 'Makefile', 'w' do |f|\n          f.puts \"clean:\\n\\techo clean\"\n          f.puts \"default:\\n\\techo built\"\n          f.puts \"install:\\n\\techo installed\"\n        end\n      RUBY\n    end\n\n    @ext.build_extensions\n\n    refute @ext.missing_extensions?\n  end\n\n  def test_missing_extensions_eh_default_gem\n    spec = new_default_spec 'default', 1\n    spec.extensions << 'extconf.rb'\n\n    refute spec.missing_extensions?\n  end\n\n  def test_missing_extensions_eh_legacy\n    ext_spec\n\n    @ext.installed_by_version = v '2.2.0.preview.2'\n\n    assert @ext.missing_extensions?\n\n    @ext.installed_by_version = v '2.2.0.preview.1'\n\n    refute @ext.missing_extensions?\n  end\n\n  def test_missing_extensions_eh_none\n    refute @a1.missing_extensions?\n  end\n\n  def test_find_all_by_full_name\n    pl = Gem::Platform.new 'i386-linux'\n\n    a1 = util_spec \"a\", \"1\"\n    a1_pre = util_spec \"a\", \"1.0.0.pre.1\"\n    a_1_platform = util_spec(\"a\", \"1\") {|s| s.platform = pl }\n    a_b_1 = util_spec \"a-b\", \"1\"\n    a_b_1_platform = util_spec(\"a-b\", \"1\") {|s| s.platform = pl }\n\n    a_b_1_1 = util_spec \"a-b-1\", \"1\"\n    a_b_1_1_platform = util_spec(\"a-b-1\", \"1\") {|s| s.platform = pl }\n\n    install_specs(a1, a1_pre, a_1_platform, a_b_1, a_b_1_platform,\n                  a_b_1_1, a_b_1_1_platform)\n\n    assert_equal [a1], Gem::Specification.find_all_by_full_name(\"a-1\")\n    assert_equal [a1_pre], Gem::Specification.find_all_by_full_name(\"a-1.0.0.pre.1\")\n    assert_equal [a_1_platform], Gem::Specification.find_all_by_full_name(\"a-1-x86-linux\")\n    assert_equal [a_b_1_1], Gem::Specification.find_all_by_full_name(\"a-b-1-1\")\n    assert_equal [a_b_1_1_platform], Gem::Specification.find_all_by_full_name(\"a-b-1-1-x86-linux\")\n\n    assert_equal [], Gem::Specification.find_all_by_full_name(\"monkeys\")\n    assert_equal [], Gem::Specification.find_all_by_full_name(\"a-1-foo\")\n  end\n\n  def test_find_by_name\n    install_specs util_spec \"a\"\n    install_specs util_spec \"a\", 1\n\n    assert Gem::Specification.find_by_name \"a\"\n    assert Gem::Specification.find_by_name \"a\", \"1\"\n    assert Gem::Specification.find_by_name \"a\", \">1\"\n\n    assert_raises Gem::MissingSpecError do\n      Gem::Specification.find_by_name \"monkeys\"\n    end\n  end\n\n  def test_find_by_name_with_only_prereleases\n    q = util_spec \"q\", \"2.a\"\n    install_specs q\n\n    assert Gem::Specification.find_by_name \"q\"\n  end\n\n  def test_find_by_name_prerelease\n    b = util_spec \"b\", \"2.a\"\n\n    b.activate\n\n    install_specs b\n\n    assert Gem::Specification.find_by_name \"b\"\n\n    assert_raises Gem::MissingSpecVersionError do\n      Gem::Specification.find_by_name \"b\", \"1\"\n    end\n\n    assert Gem::Specification.find_by_name \"b\", \">1\"\n  end\n\n  def test_find_by_path\n    a = new_spec \"foo\", \"1\", nil, \"lib/foo.rb\"\n\n    install_specs a\n\n    assert_equal a, Gem::Specification.find_by_path('foo')\n    a.activate\n    assert_equal a, Gem::Specification.find_by_path('foo')\n  end\n\n  def test_find_inactive_by_path\n    a = new_spec \"foo\", \"1\", nil, \"lib/foo.rb\"\n\n    install_specs a\n\n    assert_equal a, Gem::Specification.find_inactive_by_path('foo')\n    a.activate\n    assert_equal nil, Gem::Specification.find_inactive_by_path('foo')\n  end\n\n  def test_load_default_gem\n    Gem::Specification.reset\n    assert_equal [], Gem::Specification.map(&:full_name)\n\n    default_gem_spec = new_default_spec(\"default\", \"2.0.0.0\",\n                                        nil, \"default/gem.rb\")\n    spec_path = File.join(@default_spec_dir, default_gem_spec.spec_name)\n    write_file(spec_path) do |file|\n      file.print(default_gem_spec.to_ruby)\n    end\n    Gem::Specification.reset\n    assert_equal [\"default-2.0.0.0\"], Gem::Specification.map(&:full_name)\n  end\n\n  def test_detect_bundled_gem_in_old_ruby\n    util_set_RUBY_VERSION '1.9.3', 551\n\n    spec = new_spec 'bigdecimal', '1.1.0' do |s|\n      s.summary = \"This bigdecimal is bundled with Ruby\"\n    end\n\n    assert spec.bundled_gem_in_old_ruby?\n  ensure\n    util_restore_RUBY_VERSION\n  end\n\n  def util_setup_deps\n    @gem = util_spec \"awesome\", \"1.0\" do |awesome|\n      awesome.add_runtime_dependency \"bonobo\", []\n      awesome.add_development_dependency \"monkey\", []\n    end\n\n    @bonobo = Gem::Dependency.new(\"bonobo\", [])\n    @monkey = Gem::Dependency.new(\"monkey\", [], :development)\n  end\n\n  def util_setup_validate\n    Dir.chdir @tempdir do\n      FileUtils.mkdir_p File.join(\"ext\", \"a\")\n      FileUtils.mkdir_p \"lib\"\n      FileUtils.mkdir_p \"test\"\n      FileUtils.mkdir_p \"bin\"\n\n      FileUtils.touch File.join(\"ext\", \"a\", \"extconf.rb\")\n      FileUtils.touch File.join(\"lib\", \"code.rb\")\n      FileUtils.touch File.join(\"test\", \"suite.rb\")\n\n      File.open \"bin/exec\", \"w\", 0755 do |fp|\n        fp.puts \"#!#{Gem.ruby}\"\n      end\n    end\n  end\n\n  def with_syck\n    begin\n      verbose, $VERBOSE = $VERBOSE, nil\n      require \"yaml\"\n      old_engine = YAML::ENGINE.yamler\n      YAML::ENGINE.yamler = 'syck'\n      load 'rubygems/syck_hack.rb'\n    rescue NameError\n      # probably on 1.8, ignore\n    ensure\n      $VERBOSE = verbose\n    end\n\n    yield\n  ensure\n    begin\n      YAML::ENGINE.yamler = old_engine\n      load 'rubygems/syck_hack.rb'\n    rescue NameError\n      # ignore\n    end\n  end\n\n  def with_psych\n    begin\n      require \"yaml\"\n      old_engine = YAML::ENGINE.yamler\n      YAML::ENGINE.yamler = 'psych'\n      load 'rubygems/syck_hack.rb'\n    rescue NameError\n      # probably on 1.8, ignore\n    end\n\n    yield\n  ensure\n    begin\n      YAML::ENGINE.yamler = old_engine\n      load 'rubygems/syck_hack.rb'\n    rescue NameError\n      # ignore\n    end\n  end\n\n  def silence_warnings\n    old_verbose, $VERBOSE = $VERBOSE, false\n    yield\n  ensure\n    $VERBOSE = old_verbose\n  end\nend\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n# frozen_string_literal: true\n#--\n# Copyright 2006 by Chad Fowler, Rich Kilmer, Jim Weirich and others.\n# All rights reserved.\n# See LICENSE.txt for permissions.\n#++\n\n\nrequire 'rubygems/version'\nrequire 'rubygems/requirement'\nrequire 'rubygems/platform'\nrequire 'rubygems/deprecate'\nrequire 'rubygems/basic_specification'\nrequire 'rubygems/stub_specification'\nrequire 'rubygems/util/list'\nrequire 'stringio'\nrequire 'uri'\n\n##\n# The Specification class contains the information for a Gem.  Typically\n# defined in a .gemspec file or a Rakefile, and looks like this:\n#\n#   Gem::Specification.new do |s|\n#     s.name        = 'example'\n#     s.version     = '0.1.0'\n#     s.licenses    = ['MIT']\n#     s.summary     = \"This is an example!\"\n#     s.description = \"Much longer explanation of the example!\"\n#     s.authors     = [\"Ruby Coder\"]\n#     s.email       = 'rubycoder@example.com'\n#     s.files       = [\"lib/example.rb\"]\n#     s.homepage    = 'https://rubygems.org/gems/example'\n#     s.metadata    = { \"source_code_uri\" => \"https://github.com/example/example\" }\n#   end\n#\n# Starting in RubyGems 2.0, a Specification can hold arbitrary\n# metadata.  See #metadata for restrictions on the format and size of metadata\n# items you may add to a specification.\n\nclass Gem::Specification < Gem::BasicSpecification\n\n  # REFACTOR: Consider breaking out this version stuff into a separate\n  # module. There's enough special stuff around it that it may justify\n  # a separate class.\n\n  ##\n  # The version number of a specification that does not specify one\n  # (i.e. RubyGems 0.7 or earlier).\n\n  NONEXISTENT_SPECIFICATION_VERSION = -1\n\n  ##\n  # The specification version applied to any new Specification instances\n  # created.  This should be bumped whenever something in the spec format\n  # changes.\n  #\n  # Specification Version History:\n  #\n  #   spec   ruby\n  #    ver    ver yyyy-mm-dd description\n  #     -1 <0.8.0            pre-spec-version-history\n  #      1  0.8.0 2004-08-01 Deprecated \"test_suite_file\" for \"test_files\"\n  #                          \"test_file=x\" is a shortcut for \"test_files=[x]\"\n  #      2  0.9.5 2007-10-01 Added \"required_rubygems_version\"\n  #                          Now forward-compatible with future versions\n  #      3  1.3.2 2009-01-03 Added Fixnum validation to specification_version\n  #      4  1.9.0 2011-06-07 Added metadata\n  #--\n  # When updating this number, be sure to also update #to_ruby.\n  #\n  # NOTE RubyGems < 1.2 cannot load specification versions > 2.\n\n  CURRENT_SPECIFICATION_VERSION = 4 # :nodoc:\n\n  ##\n  # An informal list of changes to the specification.  The highest-valued\n  # key should be equal to the CURRENT_SPECIFICATION_VERSION.\n\n  SPECIFICATION_VERSION_HISTORY = { # :nodoc:\n    -1 => ['(RubyGems versions up to and including 0.7 did not have versioned specifications)'],\n    1  => [\n      'Deprecated \"test_suite_file\" in favor of the new, but equivalent, \"test_files\"',\n      '\"test_file=x\" is a shortcut for \"test_files=[x]\"'\n    ],\n    2  => [\n      'Added \"required_rubygems_version\"',\n      'Now forward-compatible with future versions',\n    ],\n    3 => [\n       'Added Fixnum validation to the specification_version'\n    ],\n    4 => [\n      'Added sandboxed freeform metadata to the specification version.'\n    ]\n  }\n\n  MARSHAL_FIELDS = { # :nodoc:\n    -1 => 16,\n     1 => 16,\n     2 => 16,\n     3 => 17,\n     4 => 18,\n  }\n\n  today = Time.now.utc\n  TODAY = Time.utc(today.year, today.month, today.day) # :nodoc:\n\n  LOAD_CACHE = {} # :nodoc:\n\n  private_constant :LOAD_CACHE if defined? private_constant\n\n  VALID_NAME_PATTERN = /\\A[a-zA-Z0-9\\.\\-\\_]+\\z/ # :nodoc:\n\n  # :startdoc:\n\n  ##\n  # List of attribute names: [:name, :version, ...]\n\n  @@required_attributes = [:rubygems_version,\n                           :specification_version,\n                           :name,\n                           :version,\n                           :date,\n                           :summary,\n                           :require_paths]\n\n  ##\n  # Map of attribute names to default values.\n\n  @@default_value = {\n    :authors                   => [],\n    :autorequire               => nil,\n    :bindir                    => 'bin',\n    :cert_chain                => [],\n    :date                      => TODAY,\n    :dependencies              => [],\n    :description               => nil,\n    :email                     => nil,\n    :executables               => [],\n    :extensions                => [],\n    :extra_rdoc_files          => [],\n    :files                     => [],\n    :homepage                  => nil,\n    :licenses                  => [],\n    :metadata                  => {},\n    :name                      => nil,\n    :platform                  => Gem::Platform::RUBY,\n    :post_install_message      => nil,\n    :rdoc_options              => [],\n    :require_paths             => ['lib'],\n    :required_ruby_version     => Gem::Requirement.default,\n    :required_rubygems_version => Gem::Requirement.default,\n    :requirements              => [],\n    :rubyforge_project         => nil,\n    :rubygems_version          => Gem::VERSION,\n    :signing_key               => nil,\n    :specification_version     => CURRENT_SPECIFICATION_VERSION,\n    :summary                   => nil,\n    :test_files                => [],\n    :version                   => nil,\n  }.freeze\n\n  INITIALIZE_CODE_FOR_DEFAULTS = { } # :nodoc:\n\n  @@default_value.each do |k,v|\n    INITIALIZE_CODE_FOR_DEFAULTS[k] = case v\n    when [], {}, true, false, nil, Numeric, Symbol\n      v.inspect\n    when String\n      v.dump\n    when Numeric\n       \"default_value(:#{k})\"\n    else\n       \"default_value(:#{k}).dup\"\n    end\n  end\n\n  @@attributes = @@default_value.keys.sort_by { |s| s.to_s }\n  @@array_attributes = @@default_value.reject { |k,v| v != [] }.keys\n  @@nil_attributes, @@non_nil_attributes = @@default_value.keys.partition { |k|\n    @@default_value[k].nil?\n  }\n\n  @@stubs_by_name = {}\n\n  # Sentinel object to represent \"not found\" stubs\n  NOT_FOUND = Struct.new(:to_spec, :this).new # :nodoc:\n  @@spec_with_requirable_file          = {}\n  @@active_stub_with_requirable_file   = {}\n\n  ######################################################################\n  # :section: Required gemspec attributes\n\n  ##\n  # This gem's name.\n  #\n  # Usage:\n  #\n  #   spec.name = 'rake'\n\n  attr_accessor :name\n\n  ##\n  # This gem's version.\n  #\n  # The version string can contain numbers and periods, such as +1.0.0+.\n  # A gem is a 'prerelease' gem if the version has a letter in it, such as\n  # +1.0.0.pre+.\n  #\n  # Usage:\n  #\n  #   spec.version = '0.4.1'\n\n  attr_reader :version\n\n  ##\n  # A short summary of this gem's description.  Displayed in `gem list -d`.\n  #\n  # The #description should be more detailed than the summary.\n  #\n  # Usage:\n  #\n  #   spec.summary = \"This is a small summary of my gem\"\n\n  attr_reader :summary\n\n  ##\n  # Files included in this gem.  You cannot append to this accessor, you must\n  # assign to it.\n  #\n  # Only add files you can require to this list, not directories, etc.\n  #\n  # Directories are automatically stripped from this list when building a gem,\n  # other non-files cause an error.\n  #\n  # Usage:\n  #\n  #   require 'rake'\n  #   spec.files = FileList['lib/**/*.rb',\n  #                         'bin/*',\n  #                         '[A-Z]*',\n  #                         'test/**/*'].to_a\n  #\n  #   # or without Rake...\n  #   spec.files = Dir['lib/**/*.rb'] + Dir['bin/*']\n  #   spec.files += Dir['[A-Z]*'] + Dir['test/**/*']\n  #   spec.files.reject! { |fn| fn.include? \"CVS\" }\n\n  def files\n    # DO NOT CHANGE TO ||= ! This is not a normal accessor. (yes, it sucks)\n    # DOC: Why isn't it normal? Why does it suck? How can we fix this?\n    @files = [@files,\n              @test_files,\n              add_bindir(@executables),\n              @extra_rdoc_files,\n              @extensions,\n             ].flatten.compact.uniq.sort\n  end\n\n  ######################################################################\n  # :section: Recommended gemspec attributes\n\n  ##\n  # Singular writer for #authors\n  #\n  # Usage:\n  #\n  #   spec.author = 'John Jones'\n\n  def author= o\n    self.authors = [o]\n  end\n\n  ##\n  # Sets the list of authors, ensuring it is an array.\n  #\n  # Usage:\n  #\n  #   spec.authors = ['John Jones', 'Mary Smith']\n\n  def authors= value\n    @authors = Array(value).flatten.grep(String)\n  end\n\n  ##\n  # A long description of this gem\n  #\n  # The description should be more detailed than the summary but not\n  # excessively long.  A few paragraphs is a recommended length with no\n  # examples or formatting.\n  #\n  # Usage:\n  #\n  #   spec.description = <<-EOF\n  #     Rake is a Make-like program implemented in Ruby. Tasks and\n  #     dependencies are specified in standard Ruby syntax.\n  #   EOF\n\n  attr_reader :description\n\n  ##\n  # A contact email address (or addresses) for this gem\n  #\n  # Usage:\n  #\n  #   spec.email = 'john.jones@example.com'\n  #   spec.email = ['jack@example.com', 'jill@example.com']\n\n  attr_accessor :email\n\n  ##\n  # The URL of this gem's home page\n  #\n  # Usage:\n  #\n  #   spec.homepage = 'https://github.com/ruby/rake'\n\n  attr_accessor :homepage\n\n  ##\n  # The license for this gem.\n  #\n  # The license must be no more than 64 characters.\n  #\n  # This should just be the name of your license. The full text of the license\n  # should be inside of the gem (at the top level) when you build it.\n  #\n  # The simplest way, is to specify the standard SPDX ID\n  # https://spdx.org/licenses/ for the license.\n  # Ideally you should pick one that is OSI (Open Source Initiative)\n  # http://opensource.org/licenses/alphabetical approved.\n  #\n  # The most commonly used OSI approved licenses are MIT and Apache-2.0.\n  # GitHub also provides a license picker at http://choosealicense.com/.\n  #\n  # You should specify a license for your gem so that people know how they are\n  # permitted to use it, and any restrictions you're placing on it.  Not\n  # specifying a license means all rights are reserved; others have no rights\n  # to use the code for any purpose.\n  #\n  # You can set multiple licenses with #licenses=\n  #\n  # Usage:\n  #   spec.license = 'MIT'\n\n  def license=o\n    self.licenses = [o]\n  end\n\n  ##\n  # The license(s) for the library.\n  #\n  # Each license must be a short name, no more than 64 characters.\n  #\n  # This should just be the name of your license. The full\n  # text of the license should be inside of the gem when you build it.\n  #\n  # See #license= for more discussion\n  #\n  # Usage:\n  #   spec.licenses = ['MIT', 'GPL-2.0']\n\n  def licenses= licenses\n    @licenses = Array licenses\n  end\n\n  ##\n  # The metadata holds extra data for this gem that may be useful to other\n  # consumers and is settable by gem authors without requiring an update to\n  # the rubygems software.\n  #\n  # Metadata items have the following restrictions:\n  #\n  # * The metadata must be a Hash object\n  # * All keys and values must be Strings\n  # * Keys can be a maximum of 128 bytes and values can be a maximum of 1024\n  #   bytes\n  # * All strings must be UTF-8, no binary data is allowed\n  #\n  # You can use metadata to specify links to your gem's homepage, codebase,\n  # documentation, wiki, mailing list, issue tracker and changelog.\n  #\n  #   s.metadata = {\n  #     \"bug_tracker_uri\"   => \"https://example.com/user/bestgemever/issues\",\n  #     \"changelog_uri\"     => \"https://example.com/user/bestgemever/CHANGELOG.md\",\n  #     \"documentation_uri\" => \"https://www.example.info/gems/bestgemever/0.0.1\",\n  #     \"homepage_uri\"      => \"https://bestgemever.example.io\",\n  #     \"mailing_list_uri\"  => \"https://groups.example.com/bestgemever\",\n  #     \"source_code_uri\"   => \"https://example.com/user/bestgemever\",\n  #     \"wiki_uri\"          => \"https://example.com/user/bestgemever/wiki\"\n  #   }\n  #\n  # These links will be used on your gem's page on rubygems.org and must pass\n  # validation against following regex.\n  #\n  #   %r{\\Ahttps?:\\/\\/([^\\s:@]+:[^\\s:@]*@)?[A-Za-z\\d\\-]+(\\.[A-Za-z\\d\\-]+)+\\.?(:\\d{1,5})?([\\/?]\\S*)?\\z}\n\n  attr_accessor :metadata\n\n  ######################################################################\n  # :section: Optional gemspec attributes\n\n  ##\n  # The path in the gem for executable scripts.  Usually 'bin'\n  #\n  # Usage:\n  #\n  #   spec.bindir = 'bin'\n\n  attr_accessor :bindir\n\n  ##\n  # The certificate chain used to sign this gem.  See Gem::Security for\n  # details.\n\n  attr_accessor :cert_chain\n\n  ##\n  # A message that gets displayed after the gem is installed.\n  #\n  # Usage:\n  #\n  #   spec.post_install_message = \"Thanks for installing!\"\n\n  attr_accessor :post_install_message\n\n  ##\n  # The platform this gem runs on.\n  #\n  # This is usually Gem::Platform::RUBY or Gem::Platform::CURRENT.\n  #\n  # Most gems contain pure Ruby code; they should simply leave the default\n  # value in place.  Some gems contain C (or other) code to be compiled into a\n  # Ruby \"extension\".  The gem should leave the default value in place unless\n  # the code will only compile on a certain type of system.  Some gems consist\n  # of pre-compiled code (\"binary gems\").  It's especially important that they\n  # set the platform attribute appropriately.  A shortcut is to set the\n  # platform to Gem::Platform::CURRENT, which will cause the gem builder to set\n  # the platform to the appropriate value for the system on which the build is\n  # being performed.\n  #\n  # If this attribute is set to a non-default value, it will be included in\n  # the filename of the gem when it is built such as:\n  # nokogiri-1.6.0-x86-mingw32.gem\n  #\n  # Usage:\n  #\n  #   spec.platform = Gem::Platform.local\n\n  def platform= platform\n    if @original_platform.nil? or\n       @original_platform == Gem::Platform::RUBY then\n      @original_platform = platform\n    end\n\n    case platform\n    when Gem::Platform::CURRENT then\n      @new_platform = Gem::Platform.local\n      @original_platform = @new_platform.to_s\n\n    when Gem::Platform then\n      @new_platform = platform\n\n    # legacy constants\n    when nil, Gem::Platform::RUBY then\n      @new_platform = Gem::Platform::RUBY\n    when 'mswin32' then # was Gem::Platform::WIN32\n      @new_platform = Gem::Platform.new 'x86-mswin32'\n    when 'i586-linux' then # was Gem::Platform::LINUX_586\n      @new_platform = Gem::Platform.new 'x86-linux'\n    when 'powerpc-darwin' then # was Gem::Platform::DARWIN\n      @new_platform = Gem::Platform.new 'ppc-darwin'\n    else\n      @new_platform = Gem::Platform.new platform\n    end\n\n    @platform = @new_platform.to_s\n\n    invalidate_memoized_attributes\n\n    @new_platform\n  end\n\n  ##\n  # Paths in the gem to add to <code>$LOAD_PATH</code> when this gem is\n  # activated.\n  #--\n  # See also #require_paths\n  #++\n  # If you have an extension you do not need to add <code>\"ext\"</code> to the\n  # require path, the extension build process will copy the extension files\n  # into \"lib\" for you.\n  #\n  # The default value is <code>\"lib\"</code>\n  #\n  # Usage:\n  #\n  #   # If all library files are in the root directory...\n  #   spec.require_paths = ['.']\n\n  def require_paths=(val)\n    @require_paths = Array(val)\n  end\n\n  ##\n  # The version of Ruby required by this gem\n\n  attr_reader :required_ruby_version\n\n  ##\n  # The RubyGems version required by this gem\n\n  attr_reader :required_rubygems_version\n\n  ##\n  # The version of RubyGems used to create this gem.\n  #\n  # Do not set this, it is set automatically when the gem is packaged.\n\n  attr_accessor :rubygems_version\n\n  ##\n  # The key used to sign this gem.  See Gem::Security for details.\n\n  attr_accessor :signing_key\n\n  ##\n  # Adds a development dependency named +gem+ with +requirements+ to this\n  # gem.\n  #\n  # Usage:\n  #\n  #   spec.add_development_dependency 'example', '~> 1.1', '>= 1.1.4'\n  #\n  # Development dependencies aren't installed by default and aren't\n  # activated when a gem is required.\n\n  def add_development_dependency(gem, *requirements)\n    add_dependency_with_type(gem, :development, requirements)\n  end\n\n  ##\n  # Adds a runtime dependency named +gem+ with +requirements+ to this gem.\n  #\n  # Usage:\n  #\n  #   spec.add_runtime_dependency 'example', '~> 1.1', '>= 1.1.4'\n\n  def add_runtime_dependency(gem, *requirements)\n    add_dependency_with_type(gem, :runtime, requirements)\n  end\n\n  ##\n  # Executables included in the gem.\n  #\n  # For example, the rake gem has rake as an executable. You don\u2019t specify the\n  # full path (as in bin/rake); all application-style files are expected to be\n  # found in bindir.  These files must be executable Ruby files.  Files that\n  # use bash or other interpreters will not work.\n  #\n  # Executables included may only be ruby scripts, not scripts for other\n  # languages or compiled binaries.\n  #\n  # Usage:\n  #\n  #   spec.executables << 'rake'\n\n  def executables\n    @executables ||= []\n  end\n\n  ##\n  # Extensions to build when installing the gem, specifically the paths to\n  # extconf.rb-style files used to compile extensions.\n  #\n  # These files will be run when the gem is installed, causing the C (or\n  # whatever) code to be compiled on the user\u2019s machine.\n  #\n  # Usage:\n  #\n  #  spec.extensions << 'ext/rmagic/extconf.rb'\n  #\n  # See Gem::Ext::Builder for information about writing extensions for gems.\n\n  def extensions\n    @extensions ||= []\n  end\n\n  ##\n  # Extra files to add to RDoc such as README or doc/examples.txt\n  #\n  # When the user elects to generate the RDoc documentation for a gem (typically\n  # at install time), all the library files are sent to RDoc for processing.\n  # This option allows you to have some non-code files included for a more\n  # complete set of documentation.\n  #\n  # Usage:\n  #\n  #  spec.extra_rdoc_files = ['README', 'doc/user-guide.txt']\n\n  def extra_rdoc_files\n    @extra_rdoc_files ||= []\n  end\n\n  ##\n  # The version of RubyGems that installed this gem.  Returns\n  # <code>Gem::Version.new(0)</code> for gems installed by versions earlier\n  # than RubyGems 2.2.0.\n\n  def installed_by_version # :nodoc:\n    @installed_by_version ||= Gem::Version.new(0)\n  end\n\n  ##\n  # Sets the version of RubyGems that installed this gem.  See also\n  # #installed_by_version.\n\n  def installed_by_version= version # :nodoc:\n    @installed_by_version = Gem::Version.new version\n  end\n\n  ##\n  # Specifies the rdoc options to be used when generating API documentation.\n  #\n  # Usage:\n  #\n  #   spec.rdoc_options << '--title' << 'Rake -- Ruby Make' <<\n  #     '--main' << 'README' <<\n  #     '--line-numbers'\n\n  def rdoc_options\n    @rdoc_options ||= []\n  end\n\n  ##\n  # The version of Ruby required by this gem.  The ruby version can be\n  # specified to the patch-level:\n  #\n  #   $ ruby -v -e 'p Gem.ruby_version'\n  #   ruby 2.0.0p247 (2013-06-27 revision 41674) [x86_64-darwin12.4.0]\n  #   #<Gem::Version \"2.0.0.247\">\n  #\n  # Because patch-level is taken into account, be very careful specifying using\n  # `<=`: `<= 2.2.2` will not match any patch-level of 2.2.2 after the `p0`\n  # release. It is much safer to specify `< 2.2.3` instead\n  #\n  # Usage:\n  #\n  #  # This gem will work with 1.8.6 or greater...\n  #  spec.required_ruby_version = '>= 1.8.6'\n  #\n  #  # Only with ruby 2.0.x\n  #  spec.required_ruby_version = '~> 2.0'\n  #\n  #  # Only with ruby between 2.2.0 and 2.2.2\n  #  spec.required_ruby_version = ['>= 2.2.0', '< 2.2.3']\n\n  def required_ruby_version= req\n    @required_ruby_version = Gem::Requirement.create req\n  end\n\n  ##\n  # The RubyGems version required by this gem\n\n  def required_rubygems_version= req\n    @required_rubygems_version = Gem::Requirement.create req\n  end\n\n  ##\n  # Lists the external (to RubyGems) requirements that must be met for this gem\n  # to work.  It's simply information for the user.\n  #\n  # Usage:\n  #\n  #   spec.requirements << 'libmagick, v6.0'\n  #   spec.requirements << 'A good graphics card'\n\n  def requirements\n    @requirements ||= []\n  end\n\n  ##\n  # A collection of unit test files.  They will be loaded as unit tests when\n  # the user requests a gem to be unit tested.\n  #\n  # Usage:\n  #   spec.test_files = Dir.glob('test/tc_*.rb')\n  #   spec.test_files = ['tests/test-suite.rb']\n\n  def test_files= files # :nodoc:\n    @test_files = Array files\n  end\n\n  ######################################################################\n  # :section: Specification internals\n\n  ##\n  # True when this gemspec has been activated. This attribute is not persisted.\n\n  attr_accessor :activated\n\n  alias :activated? :activated\n\n  ##\n  # Autorequire was used by old RubyGems to automatically require a file.\n  #\n  # Deprecated: It is neither supported nor functional.\n\n  attr_accessor :autorequire # :nodoc:\n\n  ##\n  # Sets the default executable for this gem.\n  #\n  # Deprecated: You must now specify the executable name to  Gem.bin_path.\n\n  attr_writer :default_executable\n\n  ##\n  # Allows deinstallation of gems with legacy platforms.\n\n  attr_writer :original_platform # :nodoc:\n\n  ##\n  # The rubyforge project this gem lives under.  i.e. RubyGems'\n  # rubyforge_project is \"rubygems\".\n  #\n  # This option is deprecated.\n\n  attr_accessor :rubyforge_project\n\n  ##\n  # The Gem::Specification version of this gemspec.\n  #\n  # Do not set this, it is set automatically when the gem is packaged.\n\n  attr_accessor :specification_version\n\n  def self._all # :nodoc:\n    unless defined?(@@all) && @@all then\n      @@all = stubs.map(&:to_spec)\n      if @@all.any?(&:nil?) # TODO: remove once we're happy\n        raise \"pid: #{$$} nil spec! included in #{stubs.inspect}\"\n      end\n\n      # After a reset, make sure already loaded specs\n      # are still marked as activated.\n      specs = {}\n      Gem.loaded_specs.each_value{|s| specs[s] = true}\n      @@all.each{|s| s.activated = true if specs[s]}\n    end\n    @@all\n  end\n\n  def self._clear_load_cache # :nodoc:\n    LOAD_CACHE.clear\n  end\n\n  def self.each_gemspec(dirs) # :nodoc:\n    dirs.each do |dir|\n      Dir[File.join(dir, \"*.gemspec\")].each do |path|\n        yield path.untaint\n      end\n    end\n  end\n\n  def self.gemspec_stubs_in dir, pattern\n    Dir[File.join(dir, pattern)].map { |path| yield path }.select(&:valid?)\n  end\n  private_class_method :gemspec_stubs_in\n\n  def self.default_stubs pattern\n    base_dir = Gem.default_dir\n    gems_dir = File.join base_dir, \"gems\"\n    gemspec_stubs_in(default_specifications_dir, pattern) do |path|\n      Gem::StubSpecification.default_gemspec_stub(path, base_dir, gems_dir)\n    end\n  end\n  private_class_method :default_stubs\n\n  def self.installed_stubs dirs, pattern\n    map_stubs(dirs, pattern) do |path, base_dir, gems_dir|\n      Gem::StubSpecification.gemspec_stub(path, base_dir, gems_dir)\n    end\n  end\n  private_class_method :installed_stubs\n\n  if [].respond_to? :flat_map\n    def self.map_stubs(dirs, pattern) # :nodoc:\n      dirs.flat_map { |dir|\n        base_dir = File.dirname dir\n        gems_dir = File.join base_dir, \"gems\"\n        gemspec_stubs_in(dir, pattern) { |path| yield path, base_dir, gems_dir }\n      }\n    end\n  else # FIXME: remove when 1.8 is dropped\n    def self.map_stubs(dirs, pattern) # :nodoc:\n      dirs.map { |dir|\n        base_dir = File.dirname dir\n        gems_dir = File.join base_dir, \"gems\"\n        gemspec_stubs_in(dir, pattern) { |path| yield path, base_dir, gems_dir }\n      }.flatten 1\n    end\n  end\n  private_class_method :map_stubs\n\n  uniq_takes_a_block = false\n  [1,2].uniq { uniq_takes_a_block = true }\n\n  if uniq_takes_a_block\n    def self.uniq_by(list, &block) # :nodoc:\n      list.uniq(&block)\n    end\n  else # FIXME: remove when 1.8 is dropped\n    def self.uniq_by(list) # :nodoc:\n      values = {}\n      list.each { |item|\n        value = yield item\n        values[value] ||= item\n      }\n      values.values\n    end\n  end\n  private_class_method :uniq_by\n\n  if [].respond_to? :sort_by!\n    def self.sort_by! list, &block\n      list.sort_by!(&block)\n    end\n  else # FIXME: remove when 1.8 is dropped\n    def self.sort_by! list, &block\n      list.replace list.sort_by(&block)\n    end\n  end\n  private_class_method :sort_by!\n\n  def self.each_spec(dirs) # :nodoc:\n    each_gemspec(dirs) do |path|\n      spec = self.load path\n      yield spec if spec\n    end\n  end\n\n  ##\n  # Returns a Gem::StubSpecification for every installed gem\n\n  def self.stubs\n    @@stubs ||= begin\n      pattern = \"*.gemspec\"\n      stubs = default_stubs(pattern).concat installed_stubs(dirs, pattern)\n      stubs = uniq_by(stubs) { |stub| stub.full_name }\n\n      _resort!(stubs)\n      @@stubs_by_name = stubs.group_by(&:name)\n      stubs\n    end\n  end\n\n  EMPTY = [].freeze # :nodoc:\n\n  ##\n  # Returns a Gem::StubSpecification for installed gem named +name+\n\n  def self.stubs_for name\n    if @@stubs\n      @@stubs_by_name[name] || []\n    else\n      pattern = \"#{name}-*.gemspec\"\n      stubs = default_stubs(pattern) + installed_stubs(dirs, pattern)\n      stubs = uniq_by(stubs) { |stub| stub.full_name }.group_by(&:name)\n      stubs.each_value { |v| _resort!(v) }\n\n      @@stubs_by_name.merge! stubs\n      @@stubs_by_name[name] ||= EMPTY\n    end\n  end\n\n  def self._resort!(specs) # :nodoc:\n    specs.sort! { |a, b|\n      names = a.name <=> b.name\n      next names if names.nonzero?\n      b.version <=> a.version\n    }\n  end\n\n  ##\n  # Loads the default specifications. It should be called only once.\n\n  def self.load_defaults\n    each_spec([default_specifications_dir]) do |spec|\n      # #load returns nil if the spec is bad, so we just ignore\n      # it at this stage\n      Gem.register_default_spec(spec)\n    end\n  end\n\n  ##\n  # Adds +spec+ to the known specifications, keeping the collection\n  # properly sorted.\n\n  def self.add_spec spec\n    warn \"Gem::Specification.add_spec is deprecated and will be removed in RubyGems 3.0\" unless Gem::Deprecate.skip\n    # TODO: find all extraneous adds\n    # puts\n    # p :add_spec => [spec.full_name, caller.reject { |s| s =~ /minitest/ }]\n\n    # TODO: flush the rest of the crap from the tests\n    # raise \"no dupes #{spec.full_name} in #{all_names.inspect}\" if\n    #   _all.include? spec\n\n    raise \"nil spec!\" unless spec # TODO: remove once we're happy with tests\n\n    return if _all.include? spec\n\n    _all << spec\n    stubs << spec\n    (@@stubs_by_name[spec.name] ||= []) << spec\n    sort_by!(@@stubs_by_name[spec.name]) { |s| s.version }\n    _resort!(_all)\n    _resort!(stubs)\n  end\n\n  ##\n  # Adds multiple specs to the known specifications.\n\n  def self.add_specs *specs\n    warn \"Gem::Specification.add_specs is deprecated and will be removed in RubyGems 3.0\" unless Gem::Deprecate.skip\n\n    raise \"nil spec!\" if specs.any?(&:nil?) # TODO: remove once we're happy\n\n    # TODO: this is much more efficient, but we need the extra checks for now\n    # _all.concat specs\n    # _resort!\n\n    Gem::Deprecate.skip_during do\n      specs.each do |spec| # TODO: slow\n        add_spec spec\n      end\n    end\n  end\n\n  ##\n  # Returns all specifications. This method is discouraged from use.\n  # You probably want to use one of the Enumerable methods instead.\n\n  def self.all\n    warn \"NOTE: Specification.all called from #{caller.first}\" unless\n      Gem::Deprecate.skip\n    _all\n  end\n\n  ##\n  # Sets the known specs to +specs+. Not guaranteed to work for you in\n  # the future. Use at your own risk. Caveat emptor. Doomy doom doom.\n  # Etc etc.\n  #\n  #--\n  # Makes +specs+ the known specs\n  # Listen, time is a river\n  # Winter comes, code breaks\n  #\n  # -- wilsonb\n\n  def self.all= specs\n    raise \"nil spec!\" if specs.any?(&:nil?) # TODO: remove once we're happy\n    @@stubs_by_name = specs.group_by(&:name)\n    @@all = @@stubs = specs\n  end\n\n  ##\n  # Return full names of all specs in sorted order.\n\n  def self.all_names\n    self._all.map(&:full_name)\n  end\n\n  ##\n  # Return the list of all array-oriented instance variables.\n  #--\n  # Not sure why we need to use so much stupid reflection in here...\n\n  def self.array_attributes\n    @@array_attributes.dup\n  end\n\n  ##\n  # Return the list of all instance variables.\n  #--\n  # Not sure why we need to use so much stupid reflection in here...\n\n  def self.attribute_names\n    @@attributes.dup\n  end\n\n  ##\n  # Return the directories that Specification uses to find specs.\n\n  def self.dirs\n    @@dirs ||= Gem.path.collect { |dir|\n      File.join dir.dup.untaint, \"specifications\"\n    }\n  end\n\n  ##\n  # Set the directories that Specification uses to find specs. Setting\n  # this resets the list of known specs.\n\n  def self.dirs= dirs\n    self.reset\n\n    @@dirs = Array(dirs).map { |dir| File.join dir, \"specifications\" }\n  end\n\n  extend Enumerable\n\n  ##\n  # Enumerate every known spec.  See ::dirs= and ::add_spec to set the list of\n  # specs.\n\n  def self.each\n    return enum_for(:each) unless block_given?\n\n    self._all.each do |x|\n      yield x\n    end\n  end\n\n  ##\n  # Returns every spec that matches +name+ and optional +requirements+.\n\n  def self.find_all_by_name name, *requirements\n    requirements = Gem::Requirement.default if requirements.empty?\n\n    # TODO: maybe try: find_all { |s| spec === dep }\n\n    Gem::Dependency.new(name, *requirements).matching_specs\n  end\n\n  ##\n  # Returns every spec that has the given +full_name+\n\n  def self.find_all_by_full_name(full_name)\n    stubs.select {|s| s.full_name == full_name }.map(&:to_spec)\n  end\n\n  ##\n  # Find the best specification matching a +name+ and +requirements+. Raises\n  # if the dependency doesn't resolve to a valid specification.\n\n  def self.find_by_name name, *requirements\n    requirements = Gem::Requirement.default if requirements.empty?\n\n    # TODO: maybe try: find { |s| spec === dep }\n\n    Gem::Dependency.new(name, *requirements).to_spec\n  end\n\n  ##\n  # Return the best specification that contains the file matching +path+.\n\n  def self.find_by_path path\n    path = path.dup.freeze\n    spec = @@spec_with_requirable_file[path] ||= (stubs.find { |s|\n      next unless Gem::BundlerVersionFinder.compatible?(s)\n      s.contains_requirable_file? path\n    } || NOT_FOUND)\n    spec.to_spec\n  end\n\n  ##\n  # Return the best specification that contains the file matching +path+\n  # amongst the specs that are not activated.\n\n  def self.find_inactive_by_path path\n    stub = stubs.find { |s|\n      next if s.activated?\n      next unless Gem::BundlerVersionFinder.compatible?(s)\n      s.contains_requirable_file? path\n    }\n    stub && stub.to_spec\n  end\n\n  def self.find_active_stub_by_path path\n    stub = @@active_stub_with_requirable_file[path] ||= (stubs.find { |s|\n      s.activated? and s.contains_requirable_file? path\n    } || NOT_FOUND)\n    stub.this\n  end\n\n  ##\n  # Return currently unresolved specs that contain the file matching +path+.\n\n  def self.find_in_unresolved path\n    # TODO: do we need these?? Kill it\n    specs = unresolved_deps.values.map { |dep| dep.to_specs }.flatten\n\n    specs.find_all { |spec| spec.contains_requirable_file? path }\n  end\n\n  ##\n  # Search through all unresolved deps and sub-dependencies and return\n  # specs that contain the file matching +path+.\n\n  def self.find_in_unresolved_tree path\n    specs = unresolved_deps.values.map { |dep| dep.to_specs }.flatten\n\n    specs.each do |spec|\n      spec.traverse do |from_spec, dep, to_spec, trail|\n        if to_spec.has_conflicts? || to_spec.conficts_when_loaded_with?(trail)\n          :next\n        else\n          return trail.reverse if to_spec.contains_requirable_file? path\n        end\n      end\n    end\n\n    []\n  end\n\n  ##\n  # Special loader for YAML files.  When a Specification object is loaded\n  # from a YAML file, it bypasses the normal Ruby object initialization\n  # routine (#initialize).  This method makes up for that and deals with\n  # gems of different ages.\n  #\n  # +input+ can be anything that YAML.load() accepts: String or IO.\n\n  def self.from_yaml(input)\n    Gem.load_yaml\n\n    input = normalize_yaml_input input\n    spec = Gem::SafeYAML.safe_load input\n\n    if spec && spec.class == FalseClass then\n      raise Gem::EndOfYAMLException\n    end\n\n    unless Gem::Specification === spec then\n      raise Gem::Exception, \"YAML data doesn't evaluate to gem specification\"\n    end\n\n    spec.specification_version ||= NONEXISTENT_SPECIFICATION_VERSION\n    spec.reset_nil_attributes_to_default\n\n    spec\n  end\n\n  ##\n  # Return the latest specs, optionally including prerelease specs if\n  # +prerelease+ is true.\n\n  def self.latest_specs prerelease = false\n    _latest_specs Gem::Specification._all, prerelease\n  end\n\n  def self._latest_specs specs, prerelease = false # :nodoc:\n    result = Hash.new { |h,k| h[k] = {} }\n    native = {}\n\n    specs.reverse_each do |spec|\n      next if spec.version.prerelease? unless prerelease\n\n      native[spec.name] = spec.version if spec.platform == Gem::Platform::RUBY\n      result[spec.name][spec.platform] = spec\n    end\n\n    result.map(&:last).map(&:values).flatten.reject { |spec|\n      minimum = native[spec.name]\n      minimum && spec.version < minimum\n    }.sort_by{ |tup| tup.name }\n  end\n\n  ##\n  # Loads Ruby format gemspec from +file+.\n\n  def self.load file\n    return unless file\n\n    _spec = LOAD_CACHE[file]\n    return _spec if _spec\n\n    file = file.dup.untaint\n    return unless File.file?(file)\n\n    code = if defined? Encoding\n             File.read file, :mode => 'r:UTF-8:-'\n           else\n             File.read file\n           end\n\n    code.untaint\n\n    begin\n      _spec = eval code, binding, file\n\n      if Gem::Specification === _spec\n        _spec.loaded_from = File.expand_path file.to_s\n        LOAD_CACHE[file] = _spec\n        return _spec\n      end\n\n      warn \"[#{file}] isn't a Gem::Specification (#{_spec.class} instead).\"\n    rescue SignalException, SystemExit\n      raise\n    rescue SyntaxError, Exception => e\n      warn \"Invalid gemspec in [#{file}]: #{e}\"\n    end\n\n    nil\n  end\n\n  ##\n  # Specification attributes that must be non-nil\n\n  def self.non_nil_attributes\n    @@non_nil_attributes.dup\n  end\n\n  ##\n  # Make sure the YAML specification is properly formatted with dashes\n\n  def self.normalize_yaml_input(input)\n    result = input.respond_to?(:read) ? input.read : input\n    result = \"--- \" + result unless result =~ /\\A--- /\n    result = result.dup\n    result.gsub!(/ !!null \\n/, \" \\n\")\n    # date: 2011-04-26 00:00:00.000000000Z\n    # date: 2011-04-26 00:00:00.000000000 Z\n    result.gsub!(/^(date: \\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d+?)Z/, '\\1 Z')\n    result\n  end\n\n  ##\n  # Return a list of all outdated local gem names.  This method is HEAVY\n  # as it must go fetch specifications from the server.\n  #\n  # Use outdated_and_latest_version if you wish to retrieve the latest remote\n  # version as well.\n\n  def self.outdated\n    outdated_and_latest_version.map { |local, _| local.name }\n  end\n\n  ##\n  # Enumerates the outdated local gems yielding the local specification and\n  # the latest remote version.\n  #\n  # This method may take some time to return as it must check each local gem\n  # against the server's index.\n\n  def self.outdated_and_latest_version\n    return enum_for __method__ unless block_given?\n\n    # TODO: maybe we should switch to rubygems' version service?\n    fetcher = Gem::SpecFetcher.fetcher\n\n    latest_specs(true).each do |local_spec|\n      dependency =\n        Gem::Dependency.new local_spec.name, \">= #{local_spec.version}\"\n\n      remotes, = fetcher.search_for_dependency dependency\n      remotes  = remotes.map { |n, _| n.version }\n\n      latest_remote = remotes.sort.last\n\n      yield [local_spec, latest_remote] if\n        latest_remote and local_spec.version < latest_remote\n    end\n\n    nil\n  end\n\n  ##\n  # Removes +spec+ from the known specs.\n\n  def self.remove_spec spec\n    warn \"Gem::Specification.remove_spec is deprecated and will be removed in RubyGems 3.0\" unless Gem::Deprecate.skip\n    _all.delete spec\n    stubs.delete_if { |s| s.full_name == spec.full_name }\n    (@@stubs_by_name[spec.name] || []).delete_if { |s| s.full_name == spec.full_name }\n    reset\n  end\n\n  ##\n  # Is +name+ a required attribute?\n\n  def self.required_attribute?(name)\n    @@required_attributes.include? name.to_sym\n  end\n\n  ##\n  # Required specification attributes\n\n  def self.required_attributes\n    @@required_attributes.dup\n  end\n\n  ##\n  # Reset the list of known specs, running pre and post reset hooks\n  # registered in Gem.\n\n  def self.reset\n    @@dirs = nil\n    Gem.pre_reset_hooks.each { |hook| hook.call }\n    @@all = nil\n    @@stubs = nil\n    @@stubs_by_name = {}\n    @@spec_with_requirable_file          = {}\n    @@active_stub_with_requirable_file   = {}\n    _clear_load_cache\n    unresolved = unresolved_deps\n    unless unresolved.empty? then\n      w = \"W\" + \"ARN\"\n      warn \"#{w}: Unresolved specs during Gem::Specification.reset:\"\n      unresolved.values.each do |dep|\n        warn \"      #{dep}\"\n      end\n      warn \"#{w}: Clearing out unresolved specs.\"\n      warn \"Please report a bug if this causes problems.\"\n      unresolved.clear\n    end\n    Gem.post_reset_hooks.each { |hook| hook.call }\n  end\n\n  # DOC: This method needs documented or nodoc'd\n  def self.unresolved_deps\n    @unresolved_deps ||= Hash.new { |h, n| h[n] = Gem::Dependency.new n }\n  end\n\n  ##\n  # Load custom marshal format, re-initializing defaults as needed\n\n  def self._load(str)\n    array = Marshal.load str\n\n    spec = Gem::Specification.new\n    spec.instance_variable_set :@specification_version, array[1]\n\n    current_version = CURRENT_SPECIFICATION_VERSION\n\n    field_count = if spec.specification_version > current_version then\n                    spec.instance_variable_set :@specification_version,\n                                               current_version\n                    MARSHAL_FIELDS[current_version]\n                  else\n                    MARSHAL_FIELDS[spec.specification_version]\n                  end\n\n    if array.size < field_count then\n      raise TypeError, \"invalid Gem::Specification format #{array.inspect}\"\n    end\n\n    # Cleanup any YAML::PrivateType. They only show up for an old bug\n    # where nil => null, so just convert them to nil based on the type.\n\n    array.map! { |e| e.kind_of?(YAML::PrivateType) ? nil : e }\n\n    spec.instance_variable_set :@rubygems_version,          array[0]\n    # spec version\n    spec.instance_variable_set :@name,                      array[2]\n    spec.instance_variable_set :@version,                   array[3]\n    spec.date =                                             array[4]\n    spec.instance_variable_set :@summary,                   array[5]\n    spec.instance_variable_set :@required_ruby_version,     array[6]\n    spec.instance_variable_set :@required_rubygems_version, array[7]\n    spec.instance_variable_set :@original_platform,         array[8]\n    spec.instance_variable_set :@dependencies,              array[9]\n    spec.instance_variable_set :@rubyforge_project,         array[10]\n    spec.instance_variable_set :@email,                     array[11]\n    spec.instance_variable_set :@authors,                   array[12]\n    spec.instance_variable_set :@description,               array[13]\n    spec.instance_variable_set :@homepage,                  array[14]\n    spec.instance_variable_set :@has_rdoc,                  array[15]\n    spec.instance_variable_set :@new_platform,              array[16]\n    spec.instance_variable_set :@platform,                  array[16].to_s\n    spec.instance_variable_set :@license,                   array[17]\n    spec.instance_variable_set :@metadata,                  array[18]\n    spec.instance_variable_set :@loaded,                    false\n    spec.instance_variable_set :@activated,                 false\n\n    spec\n  end\n\n  def <=>(other) # :nodoc:\n    sort_obj <=> other.sort_obj\n  end\n\n  def == other # :nodoc:\n    self.class === other &&\n      name == other.name &&\n      version == other.version &&\n      platform == other.platform\n  end\n\n  ##\n  # Dump only crucial instance variables.\n  #--\n  # MAINTAIN ORDER!\n  # (down with the man)\n\n  def _dump(limit)\n    Marshal.dump [\n      @rubygems_version,\n      @specification_version,\n      @name,\n      @version,\n      date,\n      @summary,\n      @required_ruby_version,\n      @required_rubygems_version,\n      @original_platform,\n      @dependencies,\n      @rubyforge_project,\n      @email,\n      @authors,\n      @description,\n      @homepage,\n      true, # has_rdoc\n      @new_platform,\n      @licenses,\n      @metadata\n    ]\n  end\n\n  ##\n  # Activate this spec, registering it as a loaded spec and adding\n  # it's lib paths to $LOAD_PATH. Returns true if the spec was\n  # activated, false if it was previously activated. Freaks out if\n  # there are conflicts upon activation.\n\n  def activate\n    other = Gem.loaded_specs[self.name]\n    if other then\n      check_version_conflict other\n      return false\n    end\n\n    raise_if_conflicts\n\n    activate_dependencies\n    add_self_to_load_path\n\n    Gem.loaded_specs[self.name] = self\n    @activated = true\n    @loaded = true\n\n    return true\n  end\n\n  ##\n  # Activate all unambiguously resolved runtime dependencies of this\n  # spec. Add any ambiguous dependencies to the unresolved list to be\n  # resolved later, as needed.\n\n  def activate_dependencies\n    unresolved = Gem::Specification.unresolved_deps\n\n    self.runtime_dependencies.each do |spec_dep|\n      if loaded = Gem.loaded_specs[spec_dep.name]\n        next if spec_dep.matches_spec? loaded\n\n        msg = \"can't satisfy '#{spec_dep}', already activated '#{loaded.full_name}'\"\n        e = Gem::LoadError.new msg\n        e.name = spec_dep.name\n\n        raise e\n      end\n\n      specs = spec_dep.to_specs\n\n      if specs.size == 1 then\n        specs.first.activate\n      else\n        name = spec_dep.name\n        unresolved[name] = unresolved[name].merge spec_dep\n      end\n    end\n\n    unresolved.delete self.name\n  end\n\n  ##\n  # Abbreviate the spec for downloading.  Abbreviated specs are only used for\n  # searching, downloading and related activities and do not need deployment\n  # specific information (e.g. list of files).  So we abbreviate the spec,\n  # making it much smaller for quicker downloads.\n\n  def abbreviate\n    self.files = []\n    self.test_files = []\n    self.rdoc_options = []\n    self.extra_rdoc_files = []\n    self.cert_chain = []\n  end\n\n  ##\n  # Sanitize the descriptive fields in the spec.  Sometimes non-ASCII\n  # characters will garble the site index.  Non-ASCII characters will\n  # be replaced by their XML entity equivalent.\n\n  def sanitize\n    self.summary              = sanitize_string(summary)\n    self.description          = sanitize_string(description)\n    self.post_install_message = sanitize_string(post_install_message)\n    self.authors              = authors.collect { |a| sanitize_string(a) }\n  end\n\n  ##\n  # Sanitize a single string.\n\n  def sanitize_string(string)\n    return string unless string\n\n    # HACK the #to_s is in here because RSpec has an Array of Arrays of\n    # Strings for authors.  Need a way to disallow bad values on gemspec\n    # generation.  (Probably won't happen.)\n    string = string.to_s\n\n    begin\n      Builder::XChar.encode string\n    rescue NameError, NoMethodError\n      string.to_xs\n    end\n  end\n\n  ##\n  # Returns an array with bindir attached to each executable in the\n  # +executables+ list\n\n  def add_bindir(executables)\n    return nil if executables.nil?\n\n    if @bindir then\n      Array(executables).map { |e| File.join(@bindir, e) }\n    else\n      executables\n    end\n  rescue\n    return nil\n  end\n\n  ##\n  # Adds a dependency on gem +dependency+ with type +type+ that requires\n  # +requirements+.  Valid types are currently <tt>:runtime</tt> and\n  # <tt>:development</tt>.\n\n  def add_dependency_with_type(dependency, type, requirements)\n    requirements = if requirements.empty? then\n                     Gem::Requirement.default\n                   else\n                     requirements.flatten\n                   end\n\n    unless dependency.respond_to?(:name) &&\n           dependency.respond_to?(:requirement)\n      dependency = Gem::Dependency.new(dependency.to_s, requirements, type)\n    end\n\n    dependencies << dependency\n  end\n\n  private :add_dependency_with_type\n\n  alias add_dependency add_runtime_dependency\n\n  ##\n  # Adds this spec's require paths to LOAD_PATH, in the proper location.\n\n  def add_self_to_load_path\n    return if default_gem?\n\n    paths = full_require_paths\n\n    # gem directories must come after -I and ENV['RUBYLIB']\n    insert_index = Gem.load_path_insert_index\n\n    if insert_index then\n      # gem directories must come after -I and ENV['RUBYLIB']\n      $LOAD_PATH.insert(insert_index, *paths)\n    else\n      # we are probably testing in core, -I and RUBYLIB don't apply\n      $LOAD_PATH.unshift(*paths)\n    end\n  end\n\n  ##\n  # Singular reader for #authors.  Returns the first author in the list\n\n  def author\n    val = authors and val.first\n  end\n\n  ##\n  # The list of author names who wrote this gem.\n  #\n  #   spec.authors = ['Chad Fowler', 'Jim Weirich', 'Rich Kilmer']\n\n  def authors\n    @authors ||= []\n  end\n\n  ##\n  # Returns the full path to installed gem's bin directory.\n  #\n  # NOTE: do not confuse this with +bindir+, which is just 'bin', not\n  # a full path.\n\n  def bin_dir\n    @bin_dir ||= File.join gem_dir, bindir # TODO: this is unfortunate\n  end\n\n  ##\n  # Returns the full path to an executable named +name+ in this gem.\n\n  def bin_file name\n    File.join bin_dir, name\n  end\n\n  ##\n  # Returns the build_args used to install the gem\n\n  def build_args\n    if File.exist? build_info_file\n      build_info = File.readlines build_info_file\n      build_info = build_info.map { |x| x.strip }\n      build_info.delete \"\"\n      build_info\n    else\n      []\n    end\n  end\n\n  ##\n  # Builds extensions for this platform if the gem has extensions listed and\n  # the gem.build_complete file is missing.\n\n  def build_extensions # :nodoc:\n    return if default_gem?\n    return if extensions.empty?\n    return if installed_by_version < Gem::Version.new('2.2.0.preview.2')\n    return if File.exist? gem_build_complete_path\n    return if !File.writable?(base_dir)\n    return if !File.exist?(File.join(base_dir, 'extensions'))\n\n    begin\n      # We need to require things in $LOAD_PATH without looking for the\n      # extension we are about to build.\n      unresolved_deps = Gem::Specification.unresolved_deps.dup\n      Gem::Specification.unresolved_deps.clear\n\n      require 'rubygems/config_file'\n      require 'rubygems/ext'\n      require 'rubygems/user_interaction'\n\n      ui = Gem::SilentUI.new\n      Gem::DefaultUserInteraction.use_ui ui do\n        builder = Gem::Ext::Builder.new self\n        builder.build_extensions\n      end\n    ensure\n      ui.close if ui\n      Gem::Specification.unresolved_deps.replace unresolved_deps\n    end\n  end\n\n  ##\n  # Returns the full path to the build info directory\n\n  def build_info_dir\n    File.join base_dir, \"build_info\"\n  end\n\n  ##\n  # Returns the full path to the file containing the build\n  # information generated when the gem was installed\n\n  def build_info_file\n    File.join build_info_dir, \"#{full_name}.info\"\n  end\n\n  ##\n  # Used to detect if the gem is bundled in older version of Ruby, but not\n  # detectable as default gem (see BasicSpecification#default_gem?).\n\n  def bundled_gem_in_old_ruby?\n    !default_gem? &&\n      RUBY_VERSION < \"2.0.0\" &&\n      summary == \"This #{name} is bundled with Ruby\"\n  end\n\n  ##\n  # Returns the full path to the cache directory containing this\n  # spec's cached gem.\n\n  def cache_dir\n    @cache_dir ||= File.join base_dir, \"cache\"\n  end\n\n  ##\n  # Returns the full path to the cached gem for this spec.\n\n  def cache_file\n    @cache_file ||= File.join cache_dir, \"#{full_name}.gem\"\n  end\n\n  ##\n  # Return any possible conflicts against the currently loaded specs.\n\n  def conflicts\n    conflicts = {}\n    self.runtime_dependencies.each { |dep|\n      spec = Gem.loaded_specs[dep.name]\n      if spec and not spec.satisfies_requirement? dep\n        (conflicts[spec] ||= []) << dep\n      end\n    }\n    env_req = Gem.env_requirement(name)\n    (conflicts[self] ||= []) << env_req unless env_req.satisfied_by? version\n    conflicts\n  end\n\n  ##\n  # return true if there will be conflict when spec if loaded together with the list of specs.\n\n  def conficts_when_loaded_with?(list_of_specs) # :nodoc:\n    result = list_of_specs.any? { |spec|\n      spec.dependencies.any? { |dep| dep.runtime? && (dep.name == name) && !satisfies_requirement?(dep) }\n    }\n    result\n  end\n\n  ##\n  # Return true if there are possible conflicts against the currently loaded specs.\n\n  def has_conflicts?\n    return true unless Gem.env_requirement(name).satisfied_by?(version)\n    self.dependencies.any? { |dep|\n      if dep.runtime? then\n        spec = Gem.loaded_specs[dep.name]\n        spec and not spec.satisfies_requirement? dep\n      else\n        false\n      end\n    }\n  end\n\n  ##\n  # The date this gem was created.  Lazily defaults to the current UTC date.\n  #\n  # There is no need to set this in your gem specification.\n\n  def date\n    @date ||= TODAY\n  end\n\n  DateLike = Object.new # :nodoc:\n  def DateLike.===(obj) # :nodoc:\n    defined?(::Date) and Date === obj\n  end\n\n  DateTimeFormat = # :nodoc:\n    /\\A\n     (\\d{4})-(\\d{2})-(\\d{2})\n     (\\s+ \\d{2}:\\d{2}:\\d{2}\\.\\d+ \\s* (Z | [-+]\\d\\d:\\d\\d) )?\n     \\Z/x\n\n  ##\n  # The date this gem was created\n  #\n  # DO NOT set this, it is set automatically when the gem is packaged.\n\n  def date= date\n    # We want to end up with a Time object with one-day resolution.\n    # This is the cleanest, most-readable, faster-than-using-Date\n    # way to do it.\n    @date = case date\n            when String then\n              if DateTimeFormat =~ date then\n                Time.utc($1.to_i, $2.to_i, $3.to_i)\n\n              # Workaround for where the date format output from psych isn't\n              # parsed as a Time object by syck and thus comes through as a\n              # string.\n              elsif /\\A(\\d{4})-(\\d{2})-(\\d{2}) \\d{2}:\\d{2}:\\d{2}\\.\\d+?Z\\z/ =~ date then\n                Time.utc($1.to_i, $2.to_i, $3.to_i)\n              else\n                raise(Gem::InvalidSpecificationException,\n                      \"invalid date format in specification: #{date.inspect}\")\n              end\n            when Time, DateLike then\n              Time.utc(date.year, date.month, date.day)\n            else\n              TODAY\n            end\n  end\n\n  ##\n  # The default executable for this gem.\n  #\n  # Deprecated: The name of the gem is assumed to be the name of the\n  # executable now.  See Gem.bin_path.\n\n  def default_executable # :nodoc:\n    if defined?(@default_executable) and @default_executable\n      result = @default_executable\n    elsif @executables and @executables.size == 1\n      result = Array(@executables).first\n    else\n      result = nil\n    end\n    result\n  end\n\n  ##\n  # The default value for specification attribute +name+\n\n  def default_value name\n    @@default_value[name]\n  end\n\n  ##\n  # A list of Gem::Dependency objects this gem depends on.\n  #\n  # Use #add_dependency or #add_development_dependency to add dependencies to\n  # a gem.\n\n  def dependencies\n    @dependencies ||= []\n  end\n\n  ##\n  # Return a list of all gems that have a dependency on this gemspec.  The\n  # list is structured with entries that conform to:\n  #\n  #   [depending_gem, dependency, [list_of_gems_that_satisfy_dependency]]\n\n  def dependent_gems\n    out = []\n    Gem::Specification.each do |spec|\n      spec.dependencies.each do |dep|\n        if self.satisfies_requirement?(dep) then\n          sats = []\n          find_all_satisfiers(dep) do |sat|\n            sats << sat\n          end\n          out << [spec, dep, sats]\n        end\n      end\n    end\n    out\n  end\n\n  ##\n  # Returns all specs that matches this spec's runtime dependencies.\n\n  def dependent_specs\n    runtime_dependencies.map { |dep| dep.to_specs }.flatten\n  end\n\n  ##\n  # A detailed description of this gem.  See also #summary\n\n  def description= str\n    @description = str.to_s\n  end\n\n  ##\n  # List of dependencies that are used for development\n\n  def development_dependencies\n    dependencies.select { |d| d.type == :development }\n  end\n\n  ##\n  # Returns the full path to this spec's documentation directory.  If +type+\n  # is given it will be appended to the end.  For example:\n  #\n  #   spec.doc_dir      # => \"/path/to/gem_repo/doc/a-1\"\n  #\n  #   spec.doc_dir 'ri' # => \"/path/to/gem_repo/doc/a-1/ri\"\n\n  def doc_dir type = nil\n    @doc_dir ||= File.join base_dir, 'doc', full_name\n\n    if type then\n      File.join @doc_dir, type\n    else\n      @doc_dir\n    end\n  end\n\n  def encode_with coder # :nodoc:\n    mark_version\n\n    coder.add 'name', @name\n    coder.add 'version', @version\n    platform = case @original_platform\n               when nil, '' then\n                 'ruby'\n               when String then\n                 @original_platform\n               else\n                 @original_platform.to_s\n               end\n    coder.add 'platform', platform\n\n    attributes = @@attributes.map(&:to_s) - %w[name version platform]\n    attributes.each do |name|\n      coder.add name, instance_variable_get(\"@#{name}\")\n    end\n  end\n\n  def eql? other # :nodoc:\n    self.class === other && same_attributes?(other)\n  end\n\n  ##\n  # Singular accessor for #executables\n\n  def executable\n    val = executables and val.first\n  end\n\n  ##\n  # Singular accessor for #executables\n\n  def executable=o\n    self.executables = [o]\n  end\n\n  ##\n  # Sets executables to +value+, ensuring it is an array. Don't\n  # use this, push onto the array instead.\n\n  def executables= value\n    # TODO: warn about setting instead of pushing\n    @executables = Array(value)\n  end\n\n  ##\n  # Sets extensions to +extensions+, ensuring it is an array. Don't\n  # use this, push onto the array instead.\n\n  def extensions= extensions\n    # TODO: warn about setting instead of pushing\n    @extensions = Array extensions\n  end\n\n  ##\n  # Sets extra_rdoc_files to +files+, ensuring it is an array. Don't\n  # use this, push onto the array instead.\n\n  def extra_rdoc_files= files\n    # TODO: warn about setting instead of pushing\n    @extra_rdoc_files = Array files\n  end\n\n  ##\n  # The default (generated) file name of the gem.  See also #spec_name.\n  #\n  #   spec.file_name # => \"example-1.0.gem\"\n\n  def file_name\n    \"#{full_name}.gem\"\n  end\n\n  ##\n  # Sets files to +files+, ensuring it is an array.\n\n  def files= files\n    @files = Array files\n  end\n\n  ##\n  # Finds all gems that satisfy +dep+\n\n  def find_all_satisfiers dep\n    Gem::Specification.each do |spec|\n      yield spec if spec.satisfies_requirement? dep\n    end\n  end\n\n  private :find_all_satisfiers\n\n  ##\n  # Creates a duplicate spec without large blobs that aren't used at runtime.\n\n  def for_cache\n    spec = dup\n\n    spec.files = nil\n    spec.test_files = nil\n\n    spec\n  end\n\n  def full_name\n    @full_name ||= super\n  end\n\n  ##\n  # Work around bundler removing my methods\n\n  def gem_dir # :nodoc:\n    super\n  end\n\n  def gems_dir\n    # TODO: this logic seems terribly broken, but tests fail if just base_dir\n    @gems_dir ||= File.join(loaded_from && base_dir || Gem.dir, \"gems\")\n  end\n\n  ##\n  # Deprecated and ignored, defaults to true.\n  #\n  # Formerly used to indicate this gem was RDoc-capable.\n\n  def has_rdoc # :nodoc:\n    true\n  end\n\n  ##\n  # Deprecated and ignored.\n  #\n  # Formerly used to indicate this gem was RDoc-capable.\n\n  def has_rdoc= ignored # :nodoc:\n    @has_rdoc = true\n  end\n\n  alias :has_rdoc? :has_rdoc # :nodoc:\n\n  ##\n  # True if this gem has files in test_files\n\n  def has_unit_tests? # :nodoc:\n    not test_files.empty?\n  end\n\n  # :stopdoc:\n  alias has_test_suite? has_unit_tests?\n  # :startdoc:\n\n  def hash # :nodoc:\n    name.hash ^ version.hash\n  end\n\n  def init_with coder # :nodoc:\n    @installed_by_version ||= nil\n    yaml_initialize coder.tag, coder.map\n  end\n\n\n\n  eval <<-RB, binding, __FILE__, __LINE__ + 1\n    def set_nil_attributes_to_nil\n      #{@@nil_attributes.map {|key| \"@#{key} = nil\" }.join \"; \"}\n    end\n    private :set_nil_attributes_to_nil\n\n    def set_not_nil_attributes_to_default_values\n      #{@@non_nil_attributes.map {|key| \"@#{key} = #{INITIALIZE_CODE_FOR_DEFAULTS[key]}\" }.join \";\"}\n    end\n    private :set_not_nil_attributes_to_default_values\n  RB\n\n  ##\n  # Specification constructor. Assigns the default values to the attributes\n  # and yields itself for further initialization.  Optionally takes +name+ and\n  # +version+.\n\n  def initialize name = nil, version = nil\n    super()\n    @gems_dir              = nil\n    @base_dir              = nil\n    @loaded = false\n    @activated = false\n    @loaded_from = nil\n    @original_platform = nil\n    @installed_by_version = nil\n\n    set_nil_attributes_to_nil\n    set_not_nil_attributes_to_default_values\n\n    @new_platform = Gem::Platform::RUBY\n\n    self.name = name if name\n    self.version = version if version\n\n    yield self if block_given?\n  end\n\n  ##\n  # Duplicates array_attributes from +other_spec+ so state isn't shared.\n\n  def initialize_copy other_spec\n    self.class.array_attributes.each do |name|\n      name = :\"@#{name}\"\n      next unless other_spec.instance_variable_defined? name\n\n      begin\n        val = other_spec.instance_variable_get(name)\n        if val then\n          instance_variable_set name, val.dup\n        elsif Gem.configuration.really_verbose\n          warn \"WARNING: #{full_name} has an invalid nil value for #{name}\"\n        end\n      rescue TypeError\n        e = Gem::FormatException.new \\\n          \"#{full_name} has an invalid value for #{name}\"\n\n        e.file_path = loaded_from\n        raise e\n      end\n    end\n  end\n\n  def base_dir\n    return Gem.dir unless loaded_from\n    @base_dir ||= if default_gem? then\n                    File.dirname File.dirname File.dirname loaded_from\n                  else\n                    File.dirname File.dirname loaded_from\n                  end\n  end\n\n  ##\n  # Expire memoized instance variables that can incorrectly generate, replace\n  # or miss files due changes in certain attributes used to compute them.\n\n  def invalidate_memoized_attributes\n    @full_name = nil\n    @cache_file = nil\n  end\n\n  private :invalidate_memoized_attributes\n\n  def inspect # :nodoc:\n    if $DEBUG\n      super\n    else\n      \"#{super[0..-2]} #{full_name}>\"\n    end\n  end\n\n  ##\n  # Files in the Gem under one of the require_paths\n\n  def lib_files\n    @files.select do |file|\n      require_paths.any? do |path|\n        file.start_with? path\n      end\n    end\n  end\n\n  ##\n  # Singular accessor for #licenses\n\n  def license\n    licenses.first\n  end\n\n  ##\n  # Plural accessor for setting licenses\n  #\n  # See #license= for details\n\n  def licenses\n    @licenses ||= []\n  end\n\n  def internal_init # :nodoc:\n    super\n    @bin_dir       = nil\n    @cache_dir     = nil\n    @cache_file    = nil\n    @doc_dir       = nil\n    @ri_dir        = nil\n    @spec_dir      = nil\n    @spec_file     = nil\n  end\n\n  ##\n  # Sets the rubygems_version to the current RubyGems version.\n\n  def mark_version\n    @rubygems_version = Gem::VERSION\n  end\n\n  ##\n  # Warn about unknown attributes while loading a spec.\n\n  def method_missing(sym, *a, &b) # :nodoc:\n    if @specification_version > CURRENT_SPECIFICATION_VERSION and\n      sym.to_s =~ /=$/ then\n      warn \"ignoring #{sym} loading #{full_name}\" if $DEBUG\n    else\n      super\n    end\n  end\n\n  ##\n  # Is this specification missing its extensions?  When this returns true you\n  # probably want to build_extensions\n\n  def missing_extensions?\n    return false if default_gem?\n    return false if extensions.empty?\n    return false if installed_by_version < Gem::Version.new('2.2.0.preview.2')\n    return false if File.exist? gem_build_complete_path\n\n    true\n  end\n\n  ##\n  # Normalize the list of files so that:\n  # * All file lists have redundancies removed.\n  # * Files referenced in the extra_rdoc_files are included in the package\n  #   file list.\n\n  def normalize\n    if defined?(@extra_rdoc_files) and @extra_rdoc_files then\n      @extra_rdoc_files.uniq!\n      @files ||= []\n      @files.concat(@extra_rdoc_files)\n    end\n\n    @files            = @files.uniq if @files\n    @extensions       = @extensions.uniq if @extensions\n    @test_files       = @test_files.uniq if @test_files\n    @executables      = @executables.uniq if @executables\n    @extra_rdoc_files = @extra_rdoc_files.uniq if @extra_rdoc_files\n  end\n\n  ##\n  # Return a NameTuple that represents this Specification\n\n  def name_tuple\n    Gem::NameTuple.new name, version, original_platform\n  end\n\n  ##\n  # Returns the full name (name-version) of this gemspec using the original\n  # platform.  For use with legacy gems.\n\n  def original_name # :nodoc:\n    if platform == Gem::Platform::RUBY or platform.nil? then\n      \"#{@name}-#{@version}\"\n    else\n      \"#{@name}-#{@version}-#{@original_platform}\"\n    end\n  end\n\n  ##\n  # Cruft. Use +platform+.\n\n  def original_platform # :nodoc:\n    @original_platform ||= platform\n  end\n\n  ##\n  # The platform this gem runs on.  See Gem::Platform for details.\n\n  def platform\n    @new_platform ||= Gem::Platform::RUBY\n  end\n\n  def pretty_print(q) # :nodoc:\n    q.group 2, 'Gem::Specification.new do |s|', 'end' do\n      q.breakable\n\n      attributes = @@attributes - [:name, :version]\n      attributes.unshift :installed_by_version\n      attributes.unshift :version\n      attributes.unshift :name\n\n      attributes.each do |attr_name|\n        current_value = self.send attr_name\n        if current_value != default_value(attr_name) or\n           self.class.required_attribute? attr_name then\n\n          q.text \"s.#{attr_name} = \"\n\n          if attr_name == :date then\n            current_value = current_value.utc\n\n            q.text \"Time.utc(#{current_value.year}, #{current_value.month}, #{current_value.day})\"\n          else\n            q.pp current_value\n          end\n\n          q.breakable\n        end\n      end\n    end\n  end\n\n  ##\n  # Raise an exception if the version of this spec conflicts with the one\n  # that is already loaded (+other+)\n\n  def check_version_conflict other # :nodoc:\n    return if self.version == other.version\n\n    # This gem is already loaded.  If the currently loaded gem is not in the\n    # list of candidate gems, then we have a version conflict.\n\n    msg = \"can't activate #{full_name}, already activated #{other.full_name}\"\n\n    e = Gem::LoadError.new msg\n    e.name = self.name\n    # TODO: e.requirement = dep.requirement\n\n    raise e\n  end\n\n  private :check_version_conflict\n\n  ##\n  # Check the spec for possible conflicts and freak out if there are any.\n\n  def raise_if_conflicts # :nodoc:\n    if has_conflicts? then\n      raise Gem::ConflictError.new self, conflicts\n    end\n  end\n\n  ##\n  # Sets rdoc_options to +value+, ensuring it is an array. Don't\n  # use this, push onto the array instead.\n\n  def rdoc_options= options\n    # TODO: warn about setting instead of pushing\n    @rdoc_options = Array options\n  end\n\n  ##\n  # Singular accessor for #require_paths\n\n  def require_path\n    val = require_paths and val.first\n  end\n\n  ##\n  # Singular accessor for #require_paths\n\n  def require_path= path\n    self.require_paths = Array(path)\n  end\n\n  ##\n  # Set requirements to +req+, ensuring it is an array. Don't\n  # use this, push onto the array instead.\n\n  def requirements= req\n    # TODO: warn about setting instead of pushing\n    @requirements = Array req\n  end\n\n  def respond_to_missing? m, include_private = false # :nodoc:\n    false\n  end\n\n  ##\n  # Returns the full path to this spec's ri directory.\n\n  def ri_dir\n    @ri_dir ||= File.join base_dir, 'ri', full_name\n  end\n\n  ##\n  # Return a string containing a Ruby code representation of the given\n  # object.\n\n  def ruby_code(obj)\n    case obj\n    when String            then obj.dump + \".freeze\"\n    when Array             then '[' + obj.map { |x| ruby_code x }.join(\", \") + ']'\n    when Hash              then\n      seg = obj.keys.sort.map { |k| \"#{k.to_s.dump} => #{obj[k].to_s.dump}\" }\n      \"{ #{seg.join(', ')} }\"\n    when Gem::Version      then obj.to_s.dump\n    when DateLike          then obj.strftime('%Y-%m-%d').dump\n    when Time              then obj.strftime('%Y-%m-%d').dump\n    when Numeric           then obj.inspect\n    when true, false, nil  then obj.inspect\n    when Gem::Platform     then \"Gem::Platform.new(#{obj.to_a.inspect})\"\n    when Gem::Requirement  then\n      list = obj.as_list\n      \"Gem::Requirement.new(#{ruby_code(list.size == 1 ? obj.to_s : list)})\"\n    else raise Gem::Exception, \"ruby_code case not handled: #{obj.class}\"\n    end\n  end\n\n  private :ruby_code\n\n  ##\n  # List of dependencies that will automatically be activated at runtime.\n\n  def runtime_dependencies\n    dependencies.select(&:runtime?)\n  end\n\n  ##\n  # True if this gem has the same attributes as +other+.\n\n  def same_attributes? spec\n    @@attributes.all? { |name, default| self.send(name) == spec.send(name) }\n  end\n\n  private :same_attributes?\n\n  ##\n  # Checks if this specification meets the requirement of +dependency+.\n\n  def satisfies_requirement? dependency\n    return @name == dependency.name &&\n      dependency.requirement.satisfied_by?(@version)\n  end\n\n  ##\n  # Returns an object you can use to sort specifications in #sort_by.\n\n  def sort_obj\n    [@name, @version, @new_platform == Gem::Platform::RUBY ? -1 : 1]\n  end\n\n  ##\n  # Used by Gem::Resolver to order Gem::Specification objects\n\n  def source # :nodoc:\n    Gem::Source::Installed.new\n  end\n\n  ##\n  # Returns the full path to the directory containing this spec's\n  # gemspec file. eg: /usr/local/lib/ruby/gems/1.8/specifications\n\n  def spec_dir\n    @spec_dir ||= File.join base_dir, \"specifications\"\n  end\n\n  ##\n  # Returns the full path to this spec's gemspec file.\n  # eg: /usr/local/lib/ruby/gems/1.8/specifications/mygem-1.0.gemspec\n\n  def spec_file\n    @spec_file ||= File.join spec_dir, \"#{full_name}.gemspec\"\n  end\n\n  ##\n  # The default name of the gemspec.  See also #file_name\n  #\n  #   spec.spec_name # => \"example-1.0.gemspec\"\n\n  def spec_name\n    \"#{full_name}.gemspec\"\n  end\n\n  ##\n  # A short summary of this gem's description.\n\n  def summary= str\n    @summary = str.to_s.strip.\n      gsub(/(\\w-)\\n[ \\t]*(\\w)/, '\\1\\2').gsub(/\\n[ \\t]*/, \" \") # so. weird.\n  end\n\n  ##\n  # Singular accessor for #test_files\n\n  def test_file # :nodoc:\n    val = test_files and val.first\n  end\n\n  ##\n  # Singular mutator for #test_files\n\n  def test_file= file # :nodoc:\n    self.test_files = [file]\n  end\n\n  ##\n  # Test files included in this gem.  You cannot append to this accessor, you\n  # must assign to it.\n\n  def test_files # :nodoc:\n    # Handle the possibility that we have @test_suite_file but not\n    # @test_files.  This will happen when an old gem is loaded via\n    # YAML.\n    if defined? @test_suite_file then\n      @test_files = [@test_suite_file].flatten\n      @test_suite_file = nil\n    end\n    if defined?(@test_files) and @test_files then\n      @test_files\n    else\n      @test_files = []\n    end\n  end\n\n  ##\n  # Returns a Ruby code representation of this specification, such that it can\n  # be eval'ed and reconstruct the same specification later.  Attributes that\n  # still have their default values are omitted.\n\n  def to_ruby\n    mark_version\n    result = []\n    result << \"# -*- encoding: utf-8 -*-\"\n    result << \"#{Gem::StubSpecification::PREFIX}#{name} #{version} #{platform} #{raw_require_paths.join(\"\\0\")}\"\n    result << \"#{Gem::StubSpecification::PREFIX}#{extensions.join \"\\0\"}\" unless\n      extensions.empty?\n    result << nil\n    result << \"Gem::Specification.new do |s|\"\n\n    result << \"  s.name = #{ruby_code name}\"\n    result << \"  s.version = #{ruby_code version}\"\n    unless platform.nil? or platform == Gem::Platform::RUBY then\n      result << \"  s.platform = #{ruby_code original_platform}\"\n    end\n    result << \"\"\n    result << \"  s.required_rubygems_version = #{ruby_code required_rubygems_version} if s.respond_to? :required_rubygems_version=\"\n\n    if metadata and !metadata.empty?\n      result << \"  s.metadata = #{ruby_code metadata} if s.respond_to? :metadata=\"\n    end\n    result << \"  s.require_paths = #{ruby_code raw_require_paths}\"\n\n    handled = [\n      :dependencies,\n      :name,\n      :platform,\n      :require_paths,\n      :required_rubygems_version,\n      :specification_version,\n      :version,\n      :has_rdoc,\n      :default_executable,\n      :metadata\n    ]\n\n    @@attributes.each do |attr_name|\n      next if handled.include? attr_name\n      current_value = self.send(attr_name)\n      if current_value != default_value(attr_name) or\n         self.class.required_attribute? attr_name then\n        result << \"  s.#{attr_name} = #{ruby_code current_value}\"\n      end\n    end\n\n    if @installed_by_version then\n      result << nil\n      result << \"  s.installed_by_version = \\\"#{Gem::VERSION}\\\" if s.respond_to? :installed_by_version\"\n    end\n\n    unless dependencies.empty? then\n      result << nil\n      result << \"  if s.respond_to? :specification_version then\"\n      result << \"    s.specification_version = #{specification_version}\"\n      result << nil\n\n      result << \"    if Gem::Version.new(Gem::VERSION) >= Gem::Version.new('1.2.0') then\"\n\n      dependencies.each do |dep|\n        req = dep.requirements_list.inspect\n        dep.instance_variable_set :@type, :runtime if dep.type.nil? # HACK\n        result << \"      s.add_#{dep.type}_dependency(%q<#{dep.name}>.freeze, #{req})\"\n      end\n\n      result << \"    else\"\n\n      dependencies.each do |dep|\n        version_reqs_param = dep.requirements_list.inspect\n        result << \"      s.add_dependency(%q<#{dep.name}>.freeze, #{version_reqs_param})\"\n      end\n\n      result << '    end'\n\n      result << \"  else\"\n      dependencies.each do |dep|\n        version_reqs_param = dep.requirements_list.inspect\n        result << \"    s.add_dependency(%q<#{dep.name}>.freeze, #{version_reqs_param})\"\n      end\n      result << \"  end\"\n    end\n\n    result << \"end\"\n    result << nil\n\n    result.join \"\\n\"\n  end\n\n  ##\n  # Returns a Ruby lighter-weight code representation of this specification,\n  # used for indexing only.\n  #\n  # See #to_ruby.\n\n  def to_ruby_for_cache\n    for_cache.to_ruby\n  end\n\n  def to_s # :nodoc:\n    \"#<Gem::Specification name=#{@name} version=#{@version}>\"\n  end\n\n  ##\n  # Returns self\n\n  def to_spec\n    self\n  end\n\n  def to_yaml(opts = {}) # :nodoc:\n    if (YAML.const_defined?(:ENGINE) && !YAML::ENGINE.syck?) ||\n        (defined?(Psych) && YAML == Psych) then\n      # Because the user can switch the YAML engine behind our\n      # back, we have to check again here to make sure that our\n      # psych code was properly loaded, and load it if not.\n      unless Gem.const_defined?(:NoAliasYAMLTree)\n        require 'rubygems/psych_tree'\n      end\n\n      builder = Gem::NoAliasYAMLTree.create\n      builder << self\n      ast = builder.tree\n\n      io = StringIO.new\n      io.set_encoding Encoding::UTF_8 if Object.const_defined? :Encoding\n\n      Psych::Visitors::Emitter.new(io).accept(ast)\n\n      io.string.gsub(/ !!null \\n/, \" \\n\")\n    else\n      YAML.quick_emit object_id, opts do |out|\n        out.map taguri, to_yaml_style do |map|\n          encode_with map\n        end\n      end\n    end\n  end\n\n  ##\n  # Recursively walk dependencies of this spec, executing the +block+ for each\n  # hop.\n\n  def traverse trail = [], visited = {}, &block\n    trail.push(self)\n    begin\n      dependencies.each do |dep|\n        next unless dep.runtime?\n        dep.to_specs.each do |dep_spec|\n          next if visited.has_key?(dep_spec)\n          visited[dep_spec] = true\n          trail.push(dep_spec)\n          begin\n            result = block[self, dep, dep_spec, trail]\n          ensure\n            trail.pop\n          end\n          unless result == :next\n            spec_name = dep_spec.name\n            dep_spec.traverse(trail, visited, &block) unless\n              trail.any? { |s| s.name == spec_name }\n          end\n        end\n      end\n    ensure\n      trail.pop\n    end\n  end\n\n  ##\n  # Checks that the specification contains all required fields, and does a\n  # very basic sanity check.\n  #\n  # Raises InvalidSpecificationException if the spec does not pass the\n  # checks..\n\n  def validate packaging = true\n    @warnings = 0\n    require 'rubygems/user_interaction'\n    extend Gem::UserInteraction\n    normalize\n\n    nil_attributes = self.class.non_nil_attributes.find_all do |attrname|\n      instance_variable_get(\"@#{attrname}\").nil?\n    end\n\n    unless nil_attributes.empty? then\n      raise Gem::InvalidSpecificationException,\n        \"#{nil_attributes.join ', '} must not be nil\"\n    end\n\n    if packaging and rubygems_version != Gem::VERSION then\n      raise Gem::InvalidSpecificationException,\n            \"expected RubyGems version #{Gem::VERSION}, was #{rubygems_version}\"\n    end\n\n    @@required_attributes.each do |symbol|\n      unless self.send symbol then\n        raise Gem::InvalidSpecificationException,\n              \"missing value for attribute #{symbol}\"\n      end\n    end\n\n    if !name.is_a?(String) then\n      raise Gem::InvalidSpecificationException,\n            \"invalid value for attribute name: \\\"#{name.inspect}\\\" must be a string\"\n    elsif name !~ /[a-zA-Z]/ then\n      raise Gem::InvalidSpecificationException,\n            \"invalid value for attribute name: #{name.dump} must include at least one letter\"\n    elsif name !~ VALID_NAME_PATTERN then\n      raise Gem::InvalidSpecificationException,\n            \"invalid value for attribute name: #{name.dump} can only include letters, numbers, dashes, and underscores\"\n    end\n\n    if raw_require_paths.empty? then\n      raise Gem::InvalidSpecificationException,\n            'specification must have at least one require_path'\n    end\n\n    @files.delete_if            { |x| File.directory?(x) && !File.symlink?(x) }\n    @test_files.delete_if       { |x| File.directory?(x) && !File.symlink?(x) }\n    @executables.delete_if      { |x| File.directory?(File.join(@bindir, x)) }\n    @extra_rdoc_files.delete_if { |x| File.directory?(x) && !File.symlink?(x) }\n    @extensions.delete_if       { |x| File.directory?(x) && !File.symlink?(x) }\n\n    non_files = files.reject { |x| File.file?(x) || File.symlink?(x) }\n\n    unless not packaging or non_files.empty? then\n      raise Gem::InvalidSpecificationException,\n            \"[\\\"#{non_files.join \"\\\", \\\"\"}\\\"] are not files\"\n    end\n\n    if files.include? file_name then\n      raise Gem::InvalidSpecificationException,\n            \"#{full_name} contains itself (#{file_name}), check your files list\"\n    end\n\n    unless specification_version.is_a?(Integer)\n      raise Gem::InvalidSpecificationException,\n            'specification_version must be an Integer (did you mean version?)'\n    end\n\n    case platform\n    when Gem::Platform, Gem::Platform::RUBY then # ok\n    else\n      raise Gem::InvalidSpecificationException,\n            \"invalid platform #{platform.inspect}, see Gem::Platform\"\n    end\n\n    self.class.array_attributes.each do |field|\n      val = self.send field\n      klass = case field\n              when :dependencies\n                Gem::Dependency\n              else\n                String\n              end\n\n      unless Array === val and val.all? { |x| x.kind_of?(klass) } then\n        raise(Gem::InvalidSpecificationException,\n              \"#{field} must be an Array of #{klass}\")\n      end\n    end\n\n    [:authors].each do |field|\n      val = self.send field\n      raise Gem::InvalidSpecificationException, \"#{field} may not be empty\" if\n        val.empty?\n    end\n\n    unless Hash === metadata\n      raise Gem::InvalidSpecificationException,\n              'metadata must be a hash'\n    end\n\n    validate_metadata\n\n    licenses.each { |license|\n      if license.length > 64\n        raise Gem::InvalidSpecificationException,\n          \"each license must be 64 characters or less\"\n      end\n\n      if !Gem::Licenses.match?(license)\n        suggestions = Gem::Licenses.suggestions(license)\n        message = <<-warning\nlicense value '#{license}' is invalid.  Use a license identifier from\nhttp://spdx.org/licenses or '#{Gem::Licenses::NONSTANDARD}' for a nonstandard license.\n        warning\n        message += \"Did you mean #{suggestions.map { |s| \"'#{s}'\"}.join(', ')}?\\n\" unless suggestions.nil?\n        warning(message)\n      end\n    }\n\n    warning <<-warning if licenses.empty?\nlicenses is empty, but is recommended.  Use a license identifier from\nhttp://spdx.org/licenses or '#{Gem::Licenses::NONSTANDARD}' for a nonstandard license.\n    warning\n\n    validate_permissions\n\n    # reject lazy developers:\n\n    lazy = '\"FIxxxXME\" or \"TOxxxDO\"'.gsub(/xxx/, '')\n\n    unless authors.grep(/FI XME|TO DO/x).empty? then\n      raise Gem::InvalidSpecificationException, \"#{lazy} is not an author\"\n    end\n\n    unless Array(email).grep(/FI XME|TO DO/x).empty? then\n      raise Gem::InvalidSpecificationException, \"#{lazy} is not an email\"\n    end\n\n    if description =~ /FI XME|TO DO/x then\n      raise Gem::InvalidSpecificationException, \"#{lazy} is not a description\"\n    end\n\n    if summary =~ /FI XME|TO DO/x then\n      raise Gem::InvalidSpecificationException, \"#{lazy} is not a summary\"\n    end\n\n    # Make sure a homepage is valid HTTP/HTTPS URI\n    if homepage and not homepage.empty?\n      begin\n        homepage_uri = URI.parse(homepage)\n        unless [URI::HTTP, URI::HTTPS].member? homepage_uri.class\n          raise Gem::InvalidSpecificationException, \"\\\"#{homepage}\\\" is not a URI\"\n        end\n      rescue URI::InvalidURIError\n        raise Gem::InvalidSpecificationException, \"\\\"#{homepage}\\\" is not a URI\"\n      end\n    end\n\n    # Warnings\n\n    %w[author homepage summary files].each do |attribute|\n      value = self.send attribute\n      warning \"no #{attribute} specified\" if value.nil? or value.empty?\n    end\n\n    if description == summary then\n      warning 'description and summary are identical'\n    end\n\n    # TODO: raise at some given date\n    warning \"deprecated autorequire specified\" if autorequire\n\n    executables.each do |executable|\n      executable_path = File.join(bindir, executable)\n      shebang = File.read(executable_path, 2) == '#!'\n\n      warning \"#{executable_path} is missing #! line\" unless shebang\n    end\n\n    files.each do |file|\n      next unless File.symlink?(file)\n      warning \"#{file} is a symlink, which is not supported on all platforms\"\n    end\n\n    validate_dependencies\n\n    true\n  ensure\n    if $! or @warnings > 0 then\n      alert_warning \"See http://guides.rubygems.org/specification-reference/ for help\"\n    end\n  end\n\n  def validate_metadata\n    url_validation_regex = %r{\\Ahttps?:\\/\\/([^\\s:@]+:[^\\s:@]*@)?[A-Za-z\\d\\-]+(\\.[A-Za-z\\d\\-]+)+\\.?(:\\d{1,5})?([\\/?]\\S*)?\\z}\n    link_keys = %w(\n      bug_tracker_uri\n      changelog_uri\n      documentation_uri\n      homepage_uri\n      mailing_list_uri\n      source_code_uri\n      wiki_uri\n    )\n\n    metadata.each do|key, value|\n      if !key.kind_of?(String)\n        raise Gem::InvalidSpecificationException,\n                \"metadata keys must be a String\"\n      end\n\n      if key.size > 128\n        raise Gem::InvalidSpecificationException,\n                \"metadata key too large (#{key.size} > 128)\"\n      end\n\n      if !value.kind_of?(String)\n        raise Gem::InvalidSpecificationException,\n                \"metadata values must be a String\"\n      end\n\n      if value.size > 1024\n        raise Gem::InvalidSpecificationException,\n                \"metadata value too large (#{value.size} > 1024)\"\n      end\n\n      if link_keys.include? key\n        if value !~ url_validation_regex\n          raise Gem::InvalidSpecificationException,\n                 \"metadata['#{key}'] has invalid link: #{value.inspect}\"\n        end\n      end\n    end\n  end\n\n  ##\n  # Checks that dependencies use requirements as we recommend.  Warnings are\n  # issued when dependencies are open-ended or overly strict for semantic\n  # versioning.\n\n  def validate_dependencies # :nodoc:\n    # NOTE: see REFACTOR note in Gem::Dependency about types - this might be brittle\n    seen = Gem::Dependency::TYPES.inject({}) { |types, type| types.merge({ type => {}}) }\n\n    error_messages = []\n    warning_messages = []\n    dependencies.each do |dep|\n      if prev = seen[dep.type][dep.name] then\n        error_messages << <<-MESSAGE\nduplicate dependency on #{dep}, (#{prev.requirement}) use:\n    add_#{dep.type}_dependency '#{dep.name}', '#{dep.requirement}', '#{prev.requirement}'\n        MESSAGE\n      end\n\n      seen[dep.type][dep.name] = dep\n\n      prerelease_dep = dep.requirements_list.any? do |req|\n        Gem::Requirement.new(req).prerelease?\n      end\n\n      warning_messages << \"prerelease dependency on #{dep} is not recommended\" if\n        prerelease_dep && !version.prerelease?\n\n      overly_strict = dep.requirement.requirements.length == 1 &&\n        dep.requirement.requirements.any? do |op, version|\n          op == '~>' and\n            not version.prerelease? and\n            version.segments.length > 2 and\n            version.segments.first != 0\n        end\n\n      if overly_strict then\n        _, dep_version = dep.requirement.requirements.first\n\n        base = dep_version.segments.first 2\n\n        warning_messages << <<-WARNING\npessimistic dependency on #{dep} may be overly strict\n  if #{dep.name} is semantically versioned, use:\n    add_#{dep.type}_dependency '#{dep.name}', '~> #{base.join '.'}', '>= #{dep_version}'\n        WARNING\n      end\n\n      open_ended = dep.requirement.requirements.all? do |op, version|\n        not version.prerelease? and (op == '>' or op == '>=')\n      end\n\n      if open_ended then\n        op, dep_version = dep.requirement.requirements.first\n\n        base = dep_version.segments.first 2\n\n        bugfix = if op == '>' then\n                   \", '> #{dep_version}'\"\n                 elsif op == '>=' and base != dep_version.segments then\n                   \", '>= #{dep_version}'\"\n                 end\n\n        warning_messages << <<-WARNING\nopen-ended dependency on #{dep} is not recommended\n  if #{dep.name} is semantically versioned, use:\n    add_#{dep.type}_dependency '#{dep.name}', '~> #{base.join '.'}'#{bugfix}\n        WARNING\n      end\n    end\n    if error_messages.any?\n      raise Gem::InvalidSpecificationException, error_messages.join\n    end\n    if warning_messages.any?\n      warning_messages.each { |warning_message| warning warning_message }\n    end\n  end\n\n  ##\n  # Checks to see if the files to be packaged are world-readable.\n\n  def validate_permissions\n    return if Gem.win_platform?\n\n    files.each do |file|\n      next unless File.file?(file)\n      next if File.stat(file).mode & 0444 == 0444\n      warning \"#{file} is not world-readable\"\n    end\n\n    executables.each do |name|\n      exec = File.join @bindir, name\n      next unless File.file?(exec)\n      next if File.stat(exec).executable?\n      warning \"#{exec} is not executable\"\n    end\n  end\n\n  ##\n  # Set the version to +version+, potentially also setting\n  # required_rubygems_version if +version+ indicates it is a\n  # prerelease.\n\n  def version= version\n    @version = Gem::Version.create(version)\n    self.required_rubygems_version = '> 1.3.1' if @version.prerelease?\n    invalidate_memoized_attributes\n\n    return @version\n  end\n\n  def stubbed?\n    false\n  end\n\n  def yaml_initialize(tag, vals) # :nodoc:\n    vals.each do |ivar, val|\n      case ivar\n      when \"date\"\n        # Force Date to go through the extra coerce logic in date=\n        self.date = val.untaint\n      else\n        instance_variable_set \"@#{ivar}\", val.untaint\n      end\n    end\n\n    @original_platform = @platform # for backwards compatibility\n    self.platform = Gem::Platform.new @platform\n  end\n\n  ##\n  # Reset nil attributes to their default values to make the spec valid\n\n  def reset_nil_attributes_to_default\n    nil_attributes = self.class.non_nil_attributes.find_all do |name|\n      !instance_variable_defined?(\"@#{name}\") || instance_variable_get(\"@#{name}\").nil?\n    end\n\n    nil_attributes.each do |attribute|\n      default = self.default_value attribute\n\n      value = case default\n              when Time, Numeric, Symbol, true, false, nil then default\n              else default.dup\n              end\n\n      instance_variable_set \"@#{attribute}\", value\n    end\n\n    @installed_by_version ||= nil\n  end\n\n  def warning statement # :nodoc:\n    @warnings += 1\n\n    alert_warning statement\n  end\n\n  def raw_require_paths # :nodoc:\n    @require_paths\n  end\n\n  extend Gem::Deprecate\n\n  # TODO:\n  # deprecate :has_rdoc,            :none,       2011, 10\n  # deprecate :has_rdoc?,           :none,       2011, 10\n  # deprecate :has_rdoc=,           :none,       2011, 10\n  # deprecate :default_executable,  :none,       2011, 10\n  # deprecate :default_executable=, :none,       2011, 10\n  # deprecate :file_name,           :cache_file, 2011, 10\n  # deprecate :full_gem_path,     :cache_file, 2011, 10\nend\n\n# DOC: What is this and why is it here, randomly, at the end of this file?\nGem.clear_paths\n", "# frozen_string_literal: true\nrequire 'benchmark'\nrequire 'rubygems/test_case'\nrequire 'pathname'\nrequire 'stringio'\nrequire 'rubygems/ext'\nrequire 'rubygems/specification'\nrequire 'rubygems/installer'\n\nclass TestGemSpecification < Gem::TestCase\n\n  LEGACY_YAML_SPEC = <<-EOF\n--- !ruby/object:Gem::Specification\nrubygems_version: \"1.0\"\nname: keyedlist\nversion: !ruby/object:Gem::Version\n  version: 0.4.0\ndate: 2004-03-28 15:37:49.828000 +02:00\nplatform:\nsummary: A Hash which automatically computes keys.\nrequire_paths:\n  - lib\nfiles:\n  - lib/keyedlist.rb\nautorequire: keyedlist\nauthor: Florian Gross\nemail: flgr@ccan.de\nhas_rdoc: true\n  EOF\n\n  LEGACY_RUBY_SPEC = <<-EOF\nGem::Specification.new do |s|\n  s.name = %q{keyedlist}\n  s.version = %q{0.4.0}\n  s.has_rdoc = true\n  s.summary = %q{A Hash which automatically computes keys.}\n  s.files = [%q{lib/keyedlist.rb}]\n  s.require_paths = [%q{lib}]\n  s.autorequire = %q{keyedlist}\n  s.author = %q{Florian Gross}\n  s.email = %q{flgr@ccan.de}\nend\n  EOF\n\n  def make_spec_c1\n    @c1 = util_spec 'a', '1' do |s|\n      s.executable = 'exec'\n      s.extensions << 'ext/a/extconf.rb'\n      s.test_file = 'test/suite.rb'\n      s.requirements << 'A working computer'\n      s.rubyforge_project = 'example'\n      s.license = 'MIT'\n\n      s.add_dependency 'rake', '> 0.4'\n      s.add_dependency 'jabber4r', '> 0.0.0'\n      s.add_dependency 'pqa', ['> 0.4', '<= 0.6']\n\n      s.mark_version\n      s.files = %w[lib/code.rb]\n    end\n  end\n\n  def ext_spec\n    @ext = util_spec 'ext', '1' do |s|\n      s.executable = 'exec'\n      s.test_file = 'test/suite.rb'\n      s.extensions = %w[ext/extconf.rb]\n      s.license = 'MIT'\n\n      s.mark_version\n      s.files = %w[lib/code.rb]\n      s.installed_by_version = v('2.2')\n    end\n  end\n\n  def setup\n    super\n\n    @a1 = util_spec 'a', '1' do |s|\n      s.executable = 'exec'\n      s.test_file = 'test/suite.rb'\n      s.requirements << 'A working computer'\n      s.rubyforge_project = 'example'\n      s.license = 'MIT'\n\n      s.mark_version\n      s.files = %w[lib/code.rb]\n    end\n\n    @a2 = util_spec 'a', '2' do |s|\n      s.files = %w[lib/code.rb]\n    end\n\n    @a3 = util_spec 'a', '3' do |s|\n      s.metadata['allowed_push_host'] = \"https://privategemserver.com\"\n    end\n\n    @current_version = Gem::Specification::CURRENT_SPECIFICATION_VERSION\n\n    load 'rubygems/syck_hack.rb'\n  end\n\n  def test_self_find_active_stub_by_path\n    spec = new_spec('a', '1', nil, 'lib/foo.rb')\n    spec.activated = true\n\n    # There used to be a bug (introduced in a9c1aaf) when Gem::Specification\n    # objects are present in the @stubs collection. This test verifies that\n    # this scenario works correctly.\n    Gem::Specification.all = [spec]\n    Gem::Specification.find_active_stub_by_path('foo')\n  end\n\n  def test_self_activate\n    foo = util_spec 'foo', '1'\n\n    assert_activate %w[foo-1], foo\n  end\n\n  def test_self_activate_ambiguous_direct\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec(\"b\", \"1\", { \"c\" => \">= 1\" }, \"lib/d.rb\")\n      b2 = new_spec(\"b\", \"2\", { \"c\" => \">= 2\" }, \"lib/d.rb\")\n      c1 = new_spec \"c\", \"1\"\n      c2 = new_spec \"c\", \"2\"\n\n      Gem::Specification.reset\n      install_specs c1, c2, b1, b2, a1\n\n      a1.activate\n      assert_equal %w(a-1), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n\n      require \"d\"\n\n      assert_equal %w(a-1 b-2 c-2), loaded_spec_names\n      assert_equal [], unresolved_names\n    end\n  end\n\n  def test_find_in_unresolved_tree_is_not_exponentiental\n    save_loaded_features do\n      num_of_pkg = 7\n      num_of_version_per_pkg = 3\n      packages = (0..num_of_pkg).map do |pkgi|\n        (0..num_of_version_per_pkg).map do |pkg_version|\n          deps = Hash[((pkgi + 1)..num_of_pkg).map { |deppkgi|\n            [\"pkg#{deppkgi}\", \">= 0\"]\n          }]\n          new_spec \"pkg#{pkgi}\", pkg_version.to_s, deps\n        end\n      end\n      base = new_spec \"pkg_base\", \"1\", {\"pkg0\" => \">= 0\"}\n\n      Gem::Specification.reset\n      install_specs(*packages.flatten.reverse)\n      install_specs base\n      base.activate\n\n      tms = Benchmark.measure {\n        assert_raises(LoadError) { require 'no_such_file_foo' }\n      }\n      assert_operator tms.total, :<=, 10\n    end\n  end\n\n  def test_self_activate_ambiguous_indirect\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 1\"\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 2\"\n      c1 = new_spec \"c\", \"1\", nil, \"lib/d.rb\"\n      c2 = new_spec \"c\", \"2\", nil, \"lib/d.rb\"\n\n      install_specs c1, c2, b1, b2, a1\n\n      a1.activate\n      assert_equal %w(a-1), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n\n      require \"d\"\n\n      assert_equal %w(a-1 b-2 c-2), loaded_spec_names\n      assert_equal [], unresolved_names\n    end\n  end\n\n  def test_self_activate_ambiguous_indirect_conflict\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      a2 = new_spec \"a\", \"2\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 1\"\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 2\"\n      c1 = new_spec \"c\", \"1\", nil, \"lib/d.rb\"\n      c2 = new_spec(\"c\", \"2\", { \"a\" => \"1\" }, \"lib/d.rb\") # conflicts with a-2\n\n      install_specs c1, b1, a1, a2, c2, b2\n\n      a2.activate\n      assert_equal %w(a-2), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n\n      require \"d\"\n\n      assert_equal %w(a-2 b-1 c-1), loaded_spec_names\n      assert_equal [], unresolved_names\n    end\n  end\n\n  def test_self_activate_ambiguous_unrelated\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 1\"\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 2\"\n      c1 = new_spec \"c\", \"1\"\n      c2 = new_spec \"c\", \"2\"\n      d1 = new_spec \"d\", \"1\", nil, \"lib/d.rb\"\n\n      install_specs d1, c1, c2, b1, b2, a1\n\n      a1.activate\n      assert_equal %w(a-1), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n\n      require \"d\"\n\n      assert_equal %w(a-1 d-1), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n    end\n  end\n\n  def test_require_should_prefer_latest_gem_level1\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 0\" # unresolved\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 0\"\n      c1 = new_spec \"c\", \"1\", nil, \"lib/c.rb\"  # 1st level\n      c2 = new_spec \"c\", \"2\", nil, \"lib/c.rb\"\n\n      install_specs c1, c2, b1, b2, a1\n\n      a1.activate\n\n      require \"c\"\n\n      assert_equal %w(a-1 b-2 c-2), loaded_spec_names\n    end\n  end\n\n  def test_require_should_prefer_latest_gem_level2\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 0\" # unresolved\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 0\"\n      c1 = new_spec \"c\", \"1\", \"d\" => \">= 0\"  # 1st level\n      c2 = new_spec \"c\", \"2\", \"d\" => \">= 0\"\n      d1 = new_spec \"d\", \"1\", nil, \"lib/d.rb\" # 2nd level\n      d2 = new_spec \"d\", \"2\", nil, \"lib/d.rb\"\n\n      install_specs d1, d2, c1, c2, b1, b2, a1\n\n      a1.activate\n\n      require \"d\"\n\n      assert_equal %w(a-1 b-2 c-2 d-2), loaded_spec_names\n    end\n  end\n\n  def test_require_finds_in_2nd_level_indirect\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 0\" # unresolved\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 0\"\n      c1 = new_spec \"c\", \"1\", \"d\" => \"<= 2\" # 1st level\n      c2 = new_spec \"c\", \"2\", \"d\" => \"<= 2\"\n      d1 = new_spec \"d\", \"1\", nil, \"lib/d.rb\" # 2nd level\n      d2 = new_spec \"d\", \"2\", nil, \"lib/d.rb\"\n      d3 = new_spec \"d\", \"3\", nil, \"lib/d.rb\"\n\n      install_specs d1, d2, d3, c1, c2, b1, b2, a1\n\n      a1.activate\n\n      require \"d\"\n\n      assert_equal %w(a-1 b-2 c-2 d-2), loaded_spec_names\n    end\n  end\n\n  def test_require_should_prefer_reachable_gems\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 0\" # unresolved\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 0\"\n      c1 = new_spec \"c\", \"1\", \"d\" => \"<= 2\" # 1st level\n      c2 = new_spec \"c\", \"2\", \"d\" => \"<= 2\"\n      d1 = new_spec \"d\", \"1\", nil, \"lib/d.rb\" # 2nd level\n      d2 = new_spec \"d\", \"2\", nil, \"lib/d.rb\"\n      d3 = new_spec \"d\", \"3\", nil, \"lib/d.rb\"\n      e  = new_spec \"anti_d\", \"1\", nil, \"lib/d.rb\"\n\n      install_specs d1, d2, d3, e, c1, c2, b1, b2, a1\n\n      a1.activate\n\n      require \"d\"\n\n      assert_equal %w(a-1 b-2 c-2 d-2), loaded_spec_names\n    end\n  end\n\n  def test_require_should_not_conflict\n    save_loaded_features do\n      base = new_spec \"0\", \"1\", \"A\" => \">= 1\"\n      a1 = new_spec \"A\", \"1\", {\"c\" => \">= 2\", \"b\" => \"> 0\"}, \"lib/a.rb\"\n      a2 = new_spec \"A\", \"2\", {\"c\" => \">= 2\", \"b\" => \"> 0\"}, \"lib/a.rb\"\n      b1 = new_spec \"b\", \"1\", {\"c\" => \"= 1\"}, \"lib/d.rb\"\n      b2 = new_spec \"b\", \"2\", {\"c\" => \"= 2\"}, \"lib/d.rb\"\n      c1 = new_spec \"c\", \"1\", {}, \"lib/c.rb\"\n      c2 = new_spec \"c\", \"2\", {}, \"lib/c.rb\"\n      c3 = new_spec \"c\", \"3\", {}, \"lib/c.rb\"\n\n      install_specs c1, c2, c3, b1, b2, a1, a2, base\n\n      base.activate\n      assert_equal %w(0-1), loaded_spec_names\n      assert_equal [\"A (>= 1)\"], unresolved_names\n\n      require \"d\"\n\n      assert_equal %w(0-1 A-2 b-2 c-2), loaded_spec_names\n      assert_equal [], unresolved_names\n    end\n  end\n\n  def test_inner_clonflict_in_indirect_gems\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 1\" # unresolved\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 1\", \"d\" => \"< 3\"\n      c1 = new_spec \"c\", \"1\", \"d\" => \"<= 2\" # 1st level\n      c2 = new_spec \"c\", \"2\", \"d\" => \"<= 2\"\n      c3 = new_spec \"c\", \"3\", \"d\" => \"<= 3\"\n      d1 = new_spec \"d\", \"1\", nil, \"lib/d.rb\" # 2nd level\n      d2 = new_spec \"d\", \"2\", nil, \"lib/d.rb\"\n      d3 = new_spec \"d\", \"3\", nil, \"lib/d.rb\"\n\n      install_specs d1, d2, d3, c1, c2, c3, b1, b2, a1\n\n      a1.activate\n\n      require \"d\"\n\n      assert_includes [%w(a-1 b-2 c-3 d-2),%w(a-1 b-2 d-2)], loaded_spec_names\n    end\n  end\n\n  def test_inner_clonflict_in_indirect_gems_reversed\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"xc\" => \">= 1\" # unresolved\n      b2 = new_spec \"b\", \"2\", \"xc\" => \">= 1\", \"d\" => \"< 3\"\n      c1 = new_spec \"xc\", \"1\", \"d\" => \"<= 3\" # 1st level\n      c2 = new_spec \"xc\", \"2\", \"d\" => \"<= 2\"\n      c3 = new_spec \"xc\", \"3\", \"d\" => \"<= 3\"\n      d1 = new_spec \"d\", \"1\", nil, \"lib/d.rb\" # 2nd level\n      d2 = new_spec \"d\", \"2\", nil, \"lib/d.rb\"\n      d3 = new_spec \"d\", \"3\", nil, \"lib/d.rb\"\n\n      install_specs d1, d2, d3, c1, c2, c3, b1, b2, a1\n\n      a1.activate\n\n      require \"d\"\n\n      assert_includes [%w(a-1 b-2 d-2 xc-3), %w(a-1 b-2 d-2)], loaded_spec_names\n    end\n  end\n\n  ##\n  # [A] depends on\n  #     [C]  = 1.0 depends on\n  #         [B] = 2.0\n  #     [B] ~> 1.0 (satisfied by 1.0)\n\n  def test_self_activate_checks_dependencies\n    a  = util_spec 'a', '1.0'\n            a.add_dependency 'c', '= 1.0'\n            a.add_dependency 'b', '~> 1.0'\n\n    b1 = util_spec 'b', '1.0'\n    b2 = util_spec 'b', '2.0'\n    c  = util_spec 'c', '1.0', 'b' => '= 2.0'\n    install_specs b1, b2, c, a\n\n    e = assert_raises Gem::LoadError do\n      assert_activate nil, a, c, \"b\"\n    end\n\n    expected = \"can't satisfy 'b (~> 1.0)', already activated 'b-2.0'\"\n    assert_equal expected, e.message\n  end\n\n  ##\n  # [A] depends on\n  #     [B] ~> 1.0 (satisfied by 1.0)\n  #     [C]  = 1.0 depends on\n  #         [B] = 2.0\n\n  def test_self_activate_divergent\n    a  = util_spec 'a', '1.0', 'b' => '~> 1.0', 'c' => '= 1.0'\n    b1 = util_spec 'b', '1.0'\n    b2 = util_spec 'b', '2.0'\n    c  = util_spec 'c', '1.0', 'b' => '= 2.0'\n\n    install_specs b1, b2, c, a\n\n    e = assert_raises Gem::ConflictError do\n      assert_activate nil, a, c, \"b\"\n    end\n\n    assert_match(/Unable to activate c-1.0,/, e.message)\n    assert_match(/because b-1.0 conflicts with b .= 2.0/, e.message)\n  end\n\n  ##\n  # DOC\n\n  def test_self_activate_old_required\n    e1, = util_spec 'e', '1', 'd' => '= 1'\n    @d1 = util_spec 'd', '1'\n    @d2 = util_spec 'd', '2'\n\n    install_specs @d1, @d2, e1\n\n    assert_activate %w[d-1 e-1], e1, \"d\"\n  end\n\n  ##\n  # DOC\n\n  def test_self_activate_platform_alternate\n    @x1_m = util_spec 'x', '1' do |s|\n      s.platform = Gem::Platform.new %w[cpu my_platform 1]\n    end\n\n    @x1_o = util_spec 'x', '1' do |s|\n      s.platform = Gem::Platform.new %w[cpu other_platform 1]\n    end\n\n    @w1 = util_spec 'w', '1', 'x' => nil\n\n    util_set_arch 'cpu-my_platform1'\n    install_specs @x1_m, @x1_o, @w1\n\n    assert_activate %w[x-1-cpu-my_platform-1 w-1], @w1, @x1_m\n  end\n\n  ##\n  # DOC\n\n  def test_self_activate_platform_bump\n    @y1 = util_spec 'y', '1'\n\n    @y1_1_p = util_spec 'y', '1.1' do |s|\n      s.platform = Gem::Platform.new %w[cpu my_platform 1]\n    end\n\n    @z1 = util_spec 'z', '1', 'y' => nil\n    install_specs @y1, @y1_1_p, @z1\n\n    assert_activate %w[y-1 z-1], @z1, @y1\n  end\n\n  ##\n  # [C] depends on\n  #     [A] = 1.a\n  #     [B] = 1.0 depends on\n  #         [A] >= 0 (satisfied by 1.a)\n\n  def test_self_activate_prerelease\n    @c1_pre = util_spec 'c', '1.a', \"a\" => \"1.a\", \"b\" => \"1\"\n    @a1_pre = util_spec 'a', '1.a'\n    @b1     = util_spec 'b', '1' do |s|\n      s.add_dependency 'a'\n      s.add_development_dependency 'aa'\n    end\n    install_specs @a1_pre, @b1, @c1_pre\n\n    assert_activate %w[a-1.a b-1 c-1.a], @c1_pre, @a1_pre, @b1\n  end\n\n  def test_self_activate_via_require\n    a1 = new_spec \"a\", \"1\", \"b\" => \"= 1\"\n    b1 = new_spec \"b\", \"1\", nil, \"lib/b/c.rb\"\n    b2 = new_spec \"b\", \"2\", nil, \"lib/b/c.rb\"\n\n    install_specs b1, b2, a1\n\n    a1.activate\n    save_loaded_features do\n      require \"b/c\"\n    end\n\n    assert_equal %w(a-1 b-1), loaded_spec_names\n  end\n\n  def test_self_activate_via_require_wtf\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\", \"d\" => \"> 0\"    # this\n      b1 = new_spec \"b\", \"1\", { \"c\" => \">= 1\" }, \"lib/b.rb\"\n      b2 = new_spec \"b\", \"2\", { \"c\" => \">= 2\" }, \"lib/b.rb\" # this\n      c1 = new_spec \"c\", \"1\"\n      c2 = new_spec \"c\", \"2\"                                # this\n      d1 = new_spec \"d\", \"1\", { \"c\" => \"< 2\" },  \"lib/d.rb\"\n      d2 = new_spec \"d\", \"2\", { \"c\" => \"< 2\" },  \"lib/d.rb\" # this\n\n      install_specs c1, c2, b1, b2, d1, d2, a1\n\n      a1.activate\n\n      assert_equal %w(a-1), loaded_spec_names\n      assert_equal [\"b (> 0)\", \"d (> 0)\"], unresolved_names\n\n      require \"b\"\n\n      e = assert_raises Gem::LoadError do\n        require \"d\"\n      end\n\n      assert_equal \"unable to find a version of 'd' to activate\", e.message\n\n      assert_equal %w(a-1 b-2 c-2), loaded_spec_names\n      assert_equal [\"d (> 0)\"], unresolved_names\n    end\n  end\n\n  def test_self_activate_deep_unambiguous\n    a1 = new_spec \"a\", \"1\", \"b\" => \"= 1\"\n    b1 = new_spec \"b\", \"1\", \"c\" => \"= 1\"\n    b2 = new_spec \"b\", \"2\", \"c\" => \"= 2\"\n    c1 = new_spec \"c\", \"1\"\n    c2 = new_spec \"c\", \"2\"\n\n    install_specs c1, c2, b1, b2, a1\n\n    a1.activate\n    assert_equal %w(a-1 b-1 c-1), loaded_spec_names\n  end\n\n  def test_self_activate_loaded\n    foo = util_spec 'foo', '1'\n\n    assert foo.activate\n    refute foo.activate\n  end\n\n  ##\n  # [A] depends on\n  #     [B] >= 1.0 (satisfied by 2.0)\n  # [C] depends on nothing\n\n  def test_self_activate_unrelated\n    a = util_spec 'a', '1.0', 'b' => '>= 1.0'\n    b = util_spec 'b', '1.0'\n    c = util_spec 'c', '1.0'\n    install_specs b, c, a\n\n    assert_activate %w[b-1.0 c-1.0 a-1.0], a, c, \"b\"\n  end\n\n  ##\n  # [A] depends on\n  #     [B] >= 1.0 (satisfied by 2.0)\n  #     [C]  = 1.0 depends on\n  #         [B] ~> 1.0\n  #\n  # and should resolve using b-1.0\n  # TODO: move these to specification\n\n  def test_self_activate_over\n    a = util_spec 'a', '1.0', 'b' => '>= 1.0', 'c' => '= 1.0'\n    install_specs util_spec 'b', '1.0'\n    install_specs util_spec 'b', '1.1'\n    install_specs util_spec 'b', '2.0'\n    install_specs util_spec 'c', '1.0', 'b' => '~> 1.0'\n    install_specs a\n\n    a.activate\n\n    assert_equal %w[a-1.0 c-1.0], loaded_spec_names\n    assert_equal [\"b (>= 1.0, ~> 1.0)\"], unresolved_names\n  end\n\n  ##\n  # [A] depends on\n  #     [B] ~> 1.0 (satisfied by 1.1)\n  #     [C]  = 1.0 depends on\n  #         [B] = 1.0\n  #\n  # and should resolve using b-1.0\n  #\n  # TODO: this is not under, but over... under would require depth\n  # first resolve through a dependency that is later pruned.\n\n  def test_self_activate_under\n    a    = util_spec 'a', '1.0', 'b' => '~> 1.0', 'c' => '= 1.0'\n    b1   = util_spec 'b', '1.0'\n    b1_1 = util_spec 'b', '1.1'\n    c    = util_spec 'c', '1.0', 'b' => '= 1.0'\n\n    install_specs b1, b1_1, c, a\n\n    assert_activate %w[b-1.0 c-1.0 a-1.0], a, c, \"b\"\n  end\n\n  ##\n  # [A1] depends on\n  #    [B] > 0 (satisfied by 2.0)\n  # [B1] depends on\n  #    [C] > 0 (satisfied by 1.0)\n  # [B2] depends on nothing!\n  # [C1] depends on nothing\n\n  def test_self_activate_dropped\n    a1 = util_spec 'a', '1', 'b' => nil\n    b1 = util_spec 'b', '1', 'c' => nil\n    b2 = util_spec 'b', '2'\n    c1 = util_spec 'c', '1'\n    install_specs c1, b1, b2, a1\n\n    assert_activate %w[b-2 a-1], a1, \"b\"\n  end\n\n  ##\n  # [A] depends on\n  #     [B] >= 1.0 (satisfied by 1.1) depends on\n  #         [Z]\n  #     [C] >= 1.0 depends on\n  #         [B] = 1.0\n  #\n  # and should backtrack to resolve using b-1.0, pruning Z from the\n  # resolve.\n\n  def test_self_activate_raggi_the_edgecase_generator\n    a    = util_spec 'a', '1.0', 'b' => '>= 1.0', 'c' => '>= 1.0'\n    b1   = util_spec 'b', '1.0'\n    b1_0 = util_spec 'b', '1.1', 'z' => '>= 1.0'\n    c    = util_spec 'c', '1.0', 'b' => '= 1.0'\n    z    = util_spec 'z', '1'\n\n    install_specs z, b1, b1_0, c, z\n\n    assert_activate %w[b-1.0 c-1.0 a-1.0], a, c, \"b\"\n  end\n\n  def test_self_activate_conflict\n    install_specs util_spec 'b', '1.0'\n    install_specs util_spec 'b', '2.0'\n\n    gem \"b\", \"= 1.0\"\n\n    assert_raises Gem::LoadError do\n      gem \"b\", \"= 2.0\"\n    end\n  end\n\n  def test_self_all_equals\n    a = new_spec \"foo\", \"1\", nil, \"lib/foo.rb\"\n\n    install_specs a\n    Gem::Specification.all = [a]\n\n    assert_equal a, Gem::Specification.find_inactive_by_path('foo')\n  end\n\n  def test_self_attribute_names\n    expected_value = %w[\n      authors\n      autorequire\n      bindir\n      cert_chain\n      date\n      dependencies\n      description\n      email\n      executables\n      extensions\n      extra_rdoc_files\n      files\n      homepage\n      licenses\n      metadata\n      name\n      platform\n      post_install_message\n      rdoc_options\n      require_paths\n      required_ruby_version\n      required_rubygems_version\n      requirements\n      rubyforge_project\n      rubygems_version\n      signing_key\n      specification_version\n      summary\n      test_files\n      version\n    ]\n\n    actual_value = Gem::Specification.attribute_names.map { |a| a.to_s }.sort\n\n    assert_equal expected_value, actual_value\n  end\n\n  def test_self__load_future\n    spec = Gem::Specification.new\n    spec.name = 'a'\n    spec.version = '1'\n    spec.specification_version = @current_version + 1\n\n    new_spec = Marshal.load Marshal.dump(spec)\n\n    assert_equal 'a', new_spec.name\n    assert_equal Gem::Version.new(1), new_spec.version\n    assert_equal @current_version, new_spec.specification_version\n  end\n\n  def test_self_from_yaml\n    @a1.instance_variable_set :@specification_version, nil\n\n    spec = Gem::Specification.from_yaml @a1.to_yaml\n\n    assert_equal Gem::Specification::NONEXISTENT_SPECIFICATION_VERSION,\n                 spec.specification_version\n  end\n\n  def test_self_from_yaml_syck_date_bug\n    # This is equivalent to (and totally valid) psych 1.0 output and\n    # causes parse errors on syck.\n    yaml = @a1.to_yaml\n    yaml.sub!(/^date:.*/, \"date: 2011-04-26 00:00:00.000000000Z\")\n\n    new_spec = with_syck do\n      Gem::Specification.from_yaml yaml\n    end\n\n    assert_kind_of Time, @a1.date\n    assert_kind_of Time, new_spec.date\n  end\n\n  def test_self_from_yaml_syck_default_key_bug\n    # This is equivalent to (and totally valid) psych 1.0 output and\n    # causes parse errors on syck.\n    yaml = <<-YAML\n--- !ruby/object:Gem::Specification\nname: posix-spawn\nversion: !ruby/object:Gem::Version\n  version: 0.3.6\n  prerelease:\ndependencies:\n- !ruby/object:Gem::Dependency\n  name: rake-compiler\n  requirement: &70243867725240 !ruby/object:Gem::Requirement\n    none: false\n    requirements:\n    - - =\n      - !ruby/object:Gem::Version\n        version: 0.7.6\n  type: :development\n  prerelease: false\n  version_requirements: *70243867725240\nplatform: ruby\nfiles: []\ntest_files: []\nbindir:\n    YAML\n\n    new_spec = with_syck do\n      Gem::Specification.from_yaml yaml\n    end\n\n    op = new_spec.dependencies.first.requirement.requirements.first.first\n    refute_kind_of YAML::Syck::DefaultKey, op\n\n    refute_match %r%DefaultKey%, new_spec.to_ruby\n  end\n\n  def test_self_from_yaml_cleans_up_defaultkey\n    yaml = <<-YAML\n--- !ruby/object:Gem::Specification\nname: posix-spawn\nversion: !ruby/object:Gem::Version\n  version: 0.3.6\n  prerelease:\ndependencies:\n- !ruby/object:Gem::Dependency\n  name: rake-compiler\n  requirement: &70243867725240 !ruby/object:Gem::Requirement\n    none: false\n    requirements:\n    - - !ruby/object:YAML::Syck::DefaultKey {}\n\n      - !ruby/object:Gem::Version\n        version: 0.7.6\n  type: :development\n  prerelease: false\n  version_requirements: *70243867725240\nplatform: ruby\nfiles: []\ntest_files: []\nbindir:\n    YAML\n\n    new_spec = Gem::Specification.from_yaml yaml\n\n    op = new_spec.dependencies.first.requirement.requirements.first.first\n    refute_kind_of YAML::Syck::DefaultKey, op\n\n    refute_match %r%DefaultKey%, new_spec.to_ruby\n  end\n\n  def test_self_from_yaml_cleans_up_defaultkey_from_newer_192\n    yaml = <<-YAML\n--- !ruby/object:Gem::Specification\nname: posix-spawn\nversion: !ruby/object:Gem::Version\n  version: 0.3.6\n  prerelease:\ndependencies:\n- !ruby/object:Gem::Dependency\n  name: rake-compiler\n  requirement: &70243867725240 !ruby/object:Gem::Requirement\n    none: false\n    requirements:\n    - - !ruby/object:Syck::DefaultKey {}\n\n      - !ruby/object:Gem::Version\n        version: 0.7.6\n  type: :development\n  prerelease: false\n  version_requirements: *70243867725240\nplatform: ruby\nfiles: []\ntest_files: []\nbindir:\n    YAML\n\n    new_spec = Gem::Specification.from_yaml yaml\n\n    op = new_spec.dependencies.first.requirement.requirements.first.first\n    refute_kind_of YAML::Syck::DefaultKey, op\n\n    refute_match %r%DefaultKey%, new_spec.to_ruby\n  end\n\n  def test_self_from_yaml_cleans_up_Date_objects\n    yaml = <<-YAML\n--- !ruby/object:Gem::Specification\nrubygems_version: 0.8.1\nspecification_version: 1\nname: diff-lcs\nversion: !ruby/object:Gem::Version\n  version: 1.1.2\ndate: 2004-10-20\nsummary: Provides a list of changes that represent the difference between two sequenced collections.\nrequire_paths:\n  - lib\nauthor: Austin Ziegler\nemail: diff-lcs@halostatue.ca\nhomepage: http://rubyforge.org/projects/ruwiki/\nrubyforge_project: ruwiki\ndescription: \"Test\"\nbindir: bin\nhas_rdoc: true\nrequired_ruby_version: !ruby/object:Gem::Version::Requirement\n  requirements:\n    -\n      - \">=\"\n      - !ruby/object:Gem::Version\n        version: 1.8.1\n  version:\nplatform: ruby\nfiles:\n  - tests/00test.rb\nrdoc_options:\n  - \"--title\"\n  - \"Diff::LCS -- A Diff Algorithm\"\n  - \"--main\"\n  - README\n  - \"--line-numbers\"\nextra_rdoc_files:\n  - README\n  - ChangeLog\n  - Install\nexecutables:\n  - ldiff\n  - htmldiff\nextensions: []\nrequirements: []\ndependencies: []\n    YAML\n\n    new_spec = Gem::Specification.from_yaml yaml\n\n    assert_kind_of Time, new_spec.date\n  end\n\n  def test_self_load\n    full_path = @a2.spec_file\n    write_file full_path do |io|\n      io.write @a2.to_ruby_for_cache\n    end\n\n    spec = Gem::Specification.load full_path\n\n    @a2.files.clear\n\n    assert_equal @a2, spec\n  end\n\n  def test_self_load_relative\n    File.open 'a-2.gemspec', 'w' do |io|\n      io.write @a2.to_ruby_for_cache\n    end\n\n    spec = Gem::Specification.load 'a-2.gemspec'\n\n    @a2.files.clear\n\n    assert_equal @a2, spec\n\n    assert_equal File.join(@tempdir, 'a-2.gemspec'), spec.loaded_from\n  end\n\n  def test_self_load_tainted\n    full_path = @a2.spec_file\n    write_file full_path do |io|\n      io.write @a2.to_ruby_for_cache\n    end\n\n    full_path.taint\n    loader = Thread.new { $SAFE = 1; Gem::Specification.load full_path }\n    spec = loader.value\n\n    @a2.files.clear\n\n    assert_equal @a2, spec\n\n  ensure\n    $SAFE = 0\n  end\n\n  def test_self_load_escape_curly\n    @a2.name = 'a};raise \"improper escaping\";%q{'\n\n    full_path = @a2.spec_file\n    begin\n      write_file full_path do |io|\n        io.write @a2.to_ruby_for_cache\n      end\n    rescue Errno::EINVAL\n      skip \"cannot create '#{full_path}' on this platform\"\n    end\n\n    spec = Gem::Specification.load full_path\n\n    @a2.files.clear\n\n    assert_equal @a2, spec\n  end\n\n  def test_self_load_escape_interpolation\n    @a2.name = 'a#{raise %<improper escaping>}'\n\n    full_path = @a2.spec_file\n    begin\n      write_file full_path do |io|\n        io.write @a2.to_ruby_for_cache\n      end\n    rescue Errno::EINVAL\n      skip \"cannot create '#{full_path}' on this platform\"\n    end\n\n    spec = Gem::Specification.load full_path\n\n    @a2.files.clear\n\n    assert_equal @a2, spec\n  end\n\n  def test_self_load_escape_quote\n    @a2.name = 'a\";raise \"improper escaping\";\"'\n\n    full_path = @a2.spec_file\n    begin\n      write_file full_path do |io|\n        io.write @a2.to_ruby_for_cache\n      end\n    rescue Errno::EINVAL\n      skip \"cannot create '#{full_path}' on this platform\"\n    end\n\n    spec = Gem::Specification.load full_path\n\n    @a2.files.clear\n\n    assert_equal @a2, spec\n  end\n\n  if defined?(Encoding)\n  def test_self_load_utf8_with_ascii_encoding\n    int_enc = Encoding.default_internal\n    silence_warnings { Encoding.default_internal = 'US-ASCII' }\n\n    spec2 = @a2.dup\n    bin = \"\\u5678\".dup\n    spec2.authors = [bin]\n    full_path = spec2.spec_file\n    write_file full_path do |io|\n      io.write spec2.to_ruby_for_cache.force_encoding('BINARY').sub(\"\\\\u{5678}\", bin.force_encoding('BINARY'))\n    end\n\n    spec = Gem::Specification.load full_path\n\n    spec2.files.clear\n\n    assert_equal spec2, spec\n  ensure\n    silence_warnings { Encoding.default_internal = int_enc }\n  end\n  end\n\n  def test_self_load_legacy_ruby\n    spec = Gem::Deprecate.skip_during do\n      eval LEGACY_RUBY_SPEC\n    end\n    assert_equal 'keyedlist', spec.name\n    assert_equal '0.4.0', spec.version.to_s\n    assert_equal Gem::Specification::TODAY, spec.date\n    assert spec.required_ruby_version.satisfied_by?(Gem::Version.new('1'))\n    assert_equal false, spec.has_unit_tests?\n  end\n\n  def test_self_normalize_yaml_input_with_183_yaml\n    input = \"!ruby/object:Gem::Specification \"\n    assert_equal \"--- #{input}\", Gem::Specification.normalize_yaml_input(input)\n  end\n\n  def test_self_normalize_yaml_input_with_non_183_yaml\n    input = \"--- !ruby/object:Gem::Specification \"\n    assert_equal input, Gem::Specification.normalize_yaml_input(input)\n  end\n\n  def test_self_normalize_yaml_input_with_183_io\n    input = \"!ruby/object:Gem::Specification \"\n    assert_equal \"--- #{input}\",\n      Gem::Specification.normalize_yaml_input(StringIO.new(input))\n  end\n\n  def test_self_normalize_yaml_input_with_non_183_io\n    input = \"--- !ruby/object:Gem::Specification \"\n    assert_equal input,\n      Gem::Specification.normalize_yaml_input(StringIO.new(input))\n  end\n\n  def test_self_normalize_yaml_input_with_192_yaml\n    input = \"--- !ruby/object:Gem::Specification \\nblah: !!null \\n\"\n    expected = \"--- !ruby/object:Gem::Specification \\nblah: \\n\"\n\n    assert_equal expected, Gem::Specification.normalize_yaml_input(input)\n  end\n\n  def test_self_outdated\n    spec_fetcher do |fetcher|\n      fetcher.download 'a', 4\n\n      fetcher.spec 'a', 3\n    end\n\n    assert_equal %w[a], Gem::Specification.outdated\n  end\n\n  def test_self_outdated_and_latest_remotes\n    specs = spec_fetcher do |fetcher|\n      fetcher.download 'a', 4\n      fetcher.download 'b', 3\n\n      fetcher.spec 'a', '3.a'\n      fetcher.spec 'b', 2\n    end\n\n    expected = [\n      [specs['a-3.a'], v(4)],\n      [specs['b-2'],   v(3)],\n    ]\n\n    assert_equal expected, Gem::Specification.outdated_and_latest_version.to_a\n  end\n\n  def test_self_remove_spec\n    install_specs @a1\n\n    assert_includes Gem::Specification.all_names, 'a-1'\n    assert_includes Gem::Specification.stubs.map { |s| s.full_name }, 'a-1'\n\n    uninstall_gem @a1\n    Gem::Specification.reset\n\n    refute_includes Gem::Specification.all_names, 'a-1'\n    refute_includes Gem::Specification.stubs.map { |s| s.full_name }, 'a-1'\n  end\n\n  def test_self_remove_spec_removed\n    File.open @a1.spec_file, 'w' do |io|\n      io.write @a1.to_ruby\n    end\n\n    Gem::Specification.reset\n\n    FileUtils.rm @a1.spec_file # bug #698\n\n    Gem::Specification.reset\n\n    refute_includes Gem::Specification.all_names, 'a-1'\n    refute_includes Gem::Specification.stubs.map { |s| s.full_name }, 'a-1'\n  end\n\n  DATA_PATH = File.expand_path \"../data\", __FILE__\n\n  def test_handles_private_null_type\n    path = File.join DATA_PATH, \"null-type.gemspec.rz\"\n\n    data = Marshal.load Gem.inflate(Gem.read_binary(path))\n\n    assert_equal nil, data.rubyforge_project\n  end\n\n  def test_emits_zulu_timestamps_properly\n    t = Time.utc(2012, 3, 12)\n    @a2.date = t\n\n    yaml = with_psych { @a2.to_yaml }\n\n    assert_match %r!date: 2012-03-12 00:00:00\\.000000000 Z!, yaml\n  end if RUBY_VERSION =~ /1\\.9\\.2/\n\n  def test_initialize\n    spec = Gem::Specification.new do |s|\n      s.name = \"blah\"\n      s.version = \"1.3.5\"\n    end\n\n    assert_equal \"blah\", spec.name\n    assert_equal \"1.3.5\", spec.version.to_s\n    assert_equal Gem::Platform::RUBY, spec.platform\n    assert_equal nil, spec.summary\n    assert_equal [], spec.files\n\n    assert_equal [], spec.test_files\n    assert_equal [], spec.rdoc_options\n    assert_equal [], spec.extra_rdoc_files\n    assert_equal [], spec.executables\n    assert_equal [], spec.extensions\n    assert_equal [], spec.requirements\n    assert_equal [], spec.dependencies\n    assert_equal 'bin', spec.bindir\n    assert_equal '>= 0', spec.required_ruby_version.to_s\n    assert_equal '>= 0', spec.required_rubygems_version.to_s\n  end\n\n  def test_initialize_future\n    version = Gem::Specification::CURRENT_SPECIFICATION_VERSION + 1\n    spec = Gem::Specification.new do |s|\n      s.name = \"blah\"\n      s.version = \"1.3.5\"\n\n      s.specification_version = version\n\n      s.new_unknown_attribute = \"a value\"\n    end\n\n    assert_equal \"blah\", spec.name\n    assert_equal \"1.3.5\", spec.version.to_s\n  end\n\n  def test_initialize_copy\n    spec = Gem::Specification.new do |s|\n      s.name = \"blah\"\n      s.version = \"1.3.5\"\n      s.summary = 'summary'\n      s.description = 'description'\n      s.authors = 'author a', 'author b'\n      s.licenses = 'BSD-2-Clause'\n      s.files = 'lib/file.rb'\n      s.test_files = 'test/file.rb'\n      s.rdoc_options = '--foo'\n      s.extra_rdoc_files = 'README.txt'\n      s.executables = 'exec'\n      s.extensions = 'ext/extconf.rb'\n      s.requirements = 'requirement'\n      s.add_dependency 'some_gem'\n    end\n\n    new_spec = spec.dup\n\n    assert_equal \"blah\", spec.name\n    assert_same  spec.name, new_spec.name\n\n    assert_equal \"1.3.5\", spec.version.to_s\n    assert_same spec.version, new_spec.version\n\n    assert_equal Gem::Platform::RUBY, spec.platform\n    assert_same spec.platform, new_spec.platform\n\n    assert_equal 'summary', spec.summary\n    assert_same spec.summary, new_spec.summary\n\n    assert_equal %w[README.txt bin/exec ext/extconf.rb lib/file.rb\n                    test/file.rb].sort,\n                 spec.files\n    refute_same spec.files, new_spec.files, 'files'\n\n    assert_equal %w[test/file.rb], spec.test_files\n    refute_same spec.test_files, new_spec.test_files, 'test_files'\n\n    assert_equal %w[--foo], spec.rdoc_options\n    refute_same spec.rdoc_options, new_spec.rdoc_options, 'rdoc_options'\n\n    assert_equal %w[README.txt], spec.extra_rdoc_files\n    refute_same spec.extra_rdoc_files, new_spec.extra_rdoc_files,\n                'extra_rdoc_files'\n\n    assert_equal %w[exec], spec.executables\n    refute_same spec.executables, new_spec.executables, 'executables'\n\n    assert_equal %w[ext/extconf.rb], spec.extensions\n    refute_same spec.extensions, new_spec.extensions, 'extensions'\n\n    assert_equal %w[requirement], spec.requirements\n    refute_same spec.requirements, new_spec.requirements, 'requirements'\n\n    assert_equal [Gem::Dependency.new('some_gem', Gem::Requirement.default)],\n                 spec.dependencies\n    refute_same spec.dependencies, new_spec.dependencies, 'dependencies'\n\n    assert_equal 'bin', spec.bindir\n    assert_same spec.bindir, new_spec.bindir\n\n    assert_equal '>= 0', spec.required_ruby_version.to_s\n    assert_same spec.required_ruby_version, new_spec.required_ruby_version\n\n    assert_equal '>= 0', spec.required_rubygems_version.to_s\n    assert_same spec.required_rubygems_version,\n                new_spec.required_rubygems_version\n  end\n\n  def test_initialize_copy_broken\n    spec = Gem::Specification.new do |s|\n      s.name = 'a'\n      s.version = '1'\n    end\n\n    spec.instance_variable_set :@licenses, (class << (Object.new);self;end)\n    spec.loaded_from = '/path/to/file'\n\n    e = assert_raises Gem::FormatException do\n      spec.dup\n    end\n\n    assert_equal 'a-1 has an invalid value for @licenses', e.message\n    assert_equal '/path/to/file', e.file_path\n  end\n\n  def test__dump\n    @a2.platform = Gem::Platform.local\n    @a2.instance_variable_set :@original_platform, 'old_platform'\n\n    data = Marshal.dump @a2\n\n    same_spec = Marshal.load data\n\n    assert_equal 'old_platform', same_spec.original_platform\n  end\n\n  def test_activate\n    @a2.activate\n\n    assert @a2.activated?\n  end\n\n  def test_add_dependency_with_type\n    gem = util_spec \"awesome\", \"1.0\" do |awesome|\n      awesome.add_dependency true\n      awesome.add_dependency :gem_name\n    end\n\n    assert_equal %w[true gem_name], gem.dependencies.map { |dep| dep.name }\n  end\n\n  def test_add_dependency_from_existing_dependency\n    dep  = Gem::Dependency.new(\"existing_dep\", Gem::Requirement.new('> 1'), :runtime)\n    spec = Gem::Specification.new { |s| s.add_dependency dep }\n    assert_equal dep, spec.dependencies.first\n  end\n\n  def test_add_dependency_with_type_explicit\n    gem = util_spec \"awesome\", \"1.0\" do |awesome|\n      awesome.add_development_dependency \"monkey\"\n    end\n\n    monkey = gem.dependencies.detect { |d| d.name == \"monkey\" }\n    assert_equal(:development, monkey.type)\n  end\n\n  def test_author\n    assert_equal 'A User', @a1.author\n  end\n\n  def test_authors\n    assert_equal ['A User'], @a1.authors\n  end\n\n  def test_bindir_equals\n    @a1.bindir = 'apps'\n\n    assert_equal 'apps', @a1.bindir\n  end\n\n  def test_bindir_equals_nil\n    @a2.bindir = nil\n    @a2.executable = 'app'\n\n    assert_equal nil, @a2.bindir\n    assert_equal %w[app lib/code.rb].sort, @a2.files\n  end\n\n  def test_extensions_equals_nil\n    @a2.instance_variable_set(:@extensions, nil)\n    assert_equal nil, @a2.instance_variable_get(:@extensions)\n    assert_equal %w[lib/code.rb], @a2.files\n  end\n\n  def test_test_files_equals_nil\n    @a2.instance_variable_set(:@test_files, nil)\n    assert_equal nil, @a2.instance_variable_get(:@test_files)\n    assert_equal %w[lib/code.rb], @a2.files\n  end\n\n  def test_executables_equals_nil\n    @a2.instance_variable_set(:@executables, nil)\n    assert_equal nil, @a2.instance_variable_get(:@executables)\n    assert_equal %w[lib/code.rb], @a2.files\n  end\n\n  def test_extra_rdoc_files_equals_nil\n    @a2.instance_variable_set(:@extra_rdoc_files, nil)\n    assert_equal nil, @a2.instance_variable_get(:@extra_rdoc_files)\n    assert_equal %w[lib/code.rb], @a2.files\n  end\n\n  def test_build_args\n    ext_spec\n\n    assert_empty @ext.build_args\n\n    File.open @ext.build_info_file, 'w' do |io|\n      io.puts\n    end\n\n    assert_empty @ext.build_args\n\n    File.open @ext.build_info_file, 'w' do |io|\n      io.puts '--with-foo-dir=wherever'\n    end\n\n    assert_equal %w[--with-foo-dir=wherever], @ext.build_args\n  end\n\n  def test_build_extensions\n    ext_spec\n\n    refute_path_exists @ext.extension_dir, 'sanity check'\n    refute_empty @ext.extensions, 'sanity check'\n\n    extconf_rb = File.join @ext.gem_dir, @ext.extensions.first\n    FileUtils.mkdir_p File.dirname extconf_rb\n\n    File.open extconf_rb, 'w' do |f|\n      f.write <<-'RUBY'\n        File.open 'Makefile', 'w' do |f|\n          f.puts \"clean:\\n\\techo clean\"\n          f.puts \"default:\\n\\techo built\"\n          f.puts \"install:\\n\\techo installed\"\n        end\n      RUBY\n    end\n\n    @ext.build_extensions\n\n    assert_path_exists @ext.extension_dir\n  end\n\n  def test_default_spec_stub_is_marked_default\n    default = new_default_spec 'default', 2\n    install_default_gems default\n\n    stub = Gem::Specification.stubs.find { |s| s.name == 'default' }\n    assert_predicate stub, :default_gem?\n\n    stub = Gem::Specification.find_all_by_name('default').first\n    assert_predicate stub, :default_gem?\n  end\n\n  def test_build_extensions_built\n    ext_spec\n\n    refute_empty @ext.extensions, 'sanity check'\n\n    gem_build_complete =\n      File.join @ext.extension_dir, 'gem.build_complete'\n\n    FileUtils.mkdir_p @ext.extension_dir\n    FileUtils.touch gem_build_complete\n\n    @ext.build_extensions\n\n    gem_make_out = File.join @ext.extension_dir, 'gem_make.out'\n    refute_path_exists gem_make_out\n  end\n\n  def test_build_extensions_default_gem\n    spec = new_default_spec 'default', 1\n    spec.extensions << 'extconf.rb'\n\n    extconf_rb = File.join spec.gem_dir, spec.extensions.first\n    FileUtils.mkdir_p File.dirname extconf_rb\n\n    File.open extconf_rb, 'w' do |f|\n      f.write <<-'RUBY'\n        File.open 'Makefile', 'w' do |f|\n          f.puts \"default:\\n\\techo built\"\n          f.puts \"install:\\n\\techo installed\"\n        end\n      RUBY\n    end\n\n    spec.build_extensions\n\n    refute_path_exists spec.extension_dir\n  end\n\n  def test_build_extensions_error\n    ext_spec\n\n    refute_empty @ext.extensions, 'sanity check'\n\n    assert_raises Gem::Ext::BuildError do\n      @ext.build_extensions\n    end\n  end\n\n  def test_build_extensions_extensions_dir_unwritable\n    skip 'chmod not supported' if Gem.win_platform?\n    skip 'skipped in root privilege' if Process.uid.zero?\n\n    ext_spec\n\n    refute_empty @ext.extensions, 'sanity check'\n\n    extconf_rb = File.join @ext.gem_dir, @ext.extensions.first\n    FileUtils.mkdir_p File.dirname extconf_rb\n\n    File.open extconf_rb, 'w' do |f|\n      f.write <<-'RUBY'\n        File.open 'Makefile', 'w' do |f|\n          f.puts \"clean:\\n\\techo clean\"\n          f.puts \"default:\\n\\techo built\"\n          f.puts \"install:\\n\\techo installed\"\n        end\n      RUBY\n    end\n\n    FileUtils.mkdir_p File.join @ext.base_dir, 'extensions'\n    FileUtils.chmod 0555, @ext.base_dir\n    FileUtils.chmod 0555, File.join(@ext.base_dir, 'extensions')\n\n    @ext.build_extensions\n    refute_path_exists @ext.extension_dir\n  ensure\n    unless ($DEBUG or win_platform? or Process.uid.zero?) then\n      FileUtils.chmod 0755, File.join(@ext.base_dir, 'extensions')\n      FileUtils.chmod 0755, @ext.base_dir\n    end\n  end\n\n  def test_build_extensions_no_extensions_dir_unwritable\n    skip 'chmod not supported' if Gem.win_platform?\n\n    ext_spec\n\n    refute_empty @ext.extensions, 'sanity check'\n\n    extconf_rb = File.join @ext.gem_dir, @ext.extensions.first\n    FileUtils.mkdir_p File.dirname extconf_rb\n\n    File.open extconf_rb, 'w' do |f|\n      f.write <<-'RUBY'\n        File.open 'Makefile', 'w' do |f|\n          f.puts \"clean:\\n\\techo clean\"\n          f.puts \"default:\\n\\techo built\"\n          f.puts \"install:\\n\\techo installed\"\n        end\n      RUBY\n    end\n\n    FileUtils.rm_r File.join @gemhome, 'extensions'\n    FileUtils.chmod 0555, @gemhome\n\n    @ext.build_extensions\n\n    gem_make_out = File.join @ext.extension_dir, 'gem_make.out'\n    refute_path_exists gem_make_out\n  ensure\n    FileUtils.chmod 0755, @gemhome\n  end\n\n  def test_build_extensions_none\n    refute_path_exists @a1.extension_dir, 'sanity check'\n    assert_empty @a1.extensions, 'sanity check'\n\n    @a1.build_extensions\n\n    refute_path_exists @a1.extension_dir\n  end\n\n  def test_build_extensions_old\n    ext_spec\n\n    refute_empty @ext.extensions, 'sanity check'\n\n    @ext.installed_by_version = v(0)\n\n    @ext.build_extensions\n\n    gem_make_out = File.join @ext.extension_dir, 'gem_make.out'\n    refute_path_exists gem_make_out\n  end\n\n  def test_build_extensions_preview\n    ext_spec\n\n    extconf_rb = File.join @ext.gem_dir, @ext.extensions.first\n    FileUtils.mkdir_p File.dirname extconf_rb\n\n    File.open extconf_rb, 'w' do |f|\n      f.write <<-'RUBY'\n        File.open 'Makefile', 'w' do |f|\n          f.puts \"clean:\\n\\techo clean\"\n          f.puts \"default:\\n\\techo built\"\n          f.puts \"install:\\n\\techo installed\"\n        end\n      RUBY\n    end\n\n    refute_empty @ext.extensions, 'sanity check'\n\n    @ext.installed_by_version = v('2.2.0.preview.2')\n\n    @ext.build_extensions\n\n    gem_make_out = File.join @ext.extension_dir, 'gem_make.out'\n    assert_path_exists gem_make_out\n  end\n\n  def test_contains_requirable_file_eh\n    code_rb = File.join @a1.gem_dir, 'lib', 'code.rb'\n    FileUtils.mkdir_p File.dirname code_rb\n    FileUtils.touch code_rb\n\n    assert @a1.contains_requirable_file? 'code'\n  end\n\n  def test_contains_requirable_file_eh_extension\n    ext_spec\n\n    _, err = capture_io do\n      refute @ext.contains_requirable_file? 'nonexistent'\n    end\n\n    expected = \"Ignoring ext-1 because its extensions are not built. \" +\n               \"Try: gem pristine ext --version 1\\n\"\n\n    assert_equal expected, err\n  end\n\n  def test_date\n    assert_equal Gem::Specification::TODAY, @a1.date\n  end\n\n  def test_date_equals_date\n    @a1.date = Date.new(2003, 9, 17)\n    assert_equal Time.utc(2003, 9, 17, 0,0,0), @a1.date\n  end\n\n  def test_date_equals_string\n    @a1.date = '2003-09-17'\n    assert_equal Time.utc(2003, 9, 17, 0,0,0), @a1.date\n  end\n\n  def test_date_equals_string_bad\n    assert_raises Gem::InvalidSpecificationException do\n      @a1.date = '9/11/2003'\n    end\n  end\n\n  def test_date_equals_time\n    @a1.date = Time.local(2003, 9, 17, 0,0,0)\n    assert_equal Time.utc(2003, 9, 17, 0,0,0), @a1.date\n  end\n\n  def test_date_equals_time_local\n    @a1.date = Time.local(2003, 9, 17, 19,50,0) # may not pass in utc >= +4\n    assert_equal Time.utc(2003, 9, 17, 0,0,0), @a1.date\n  end\n\n  def test_date_equals_time_utc\n    @a1.date = Time.utc(2003, 9, 17, 19,50,0)\n    assert_equal Time.utc(2003, 9, 17, 0,0,0), @a1.date\n  end\n\n  def test_date_tolerates_hour_sec_zulu\n    @a1.date = \"2012-01-12 11:22:33.4444444 Z\"\n    assert_equal Time.utc(2012,01,12,0,0,0), @a1.date\n  end\n\n  def test_date_tolerates_hour_sec_and_timezone\n    @a1.date = \"2012-01-12 11:22:33.4444444 +02:33\"\n    assert_equal Time.utc(2012,01,12,0,0,0), @a1.date\n  end\n\n  def test_dependencies\n    util_setup_deps\n    assert_equal [@bonobo, @monkey], @gem.dependencies\n  end\n\n  def test_dependent_gems\n    util_setup_deps\n\n    assert_empty @gem.dependent_gems\n\n    bonobo = util_spec 'bonobo', 1\n    install_gem bonobo\n    install_gem @gem\n\n    expected = [\n      [@gem, @bonobo, [bonobo]],\n    ]\n\n    assert_equal expected, bonobo.dependent_gems\n  end\n\n  def test_doc_dir\n    assert_equal File.join(@gemhome, 'doc', 'a-1'), @a1.doc_dir\n  end\n\n  def test_doc_dir_type\n    assert_equal File.join(@gemhome, 'doc', 'a-1', 'ri'), @a1.doc_dir('ri')\n  end\n\n  def test_runtime_dependencies\n    util_setup_deps\n    assert_equal [@bonobo], @gem.runtime_dependencies\n  end\n\n  def test_development_dependencies\n    util_setup_deps\n    assert_equal [@monkey], @gem.development_dependencies\n  end\n\n  def test_description\n    assert_equal 'This is a test description', @a1.description\n  end\n\n  def test_eql_eh\n    g1 = new_spec 'gem', 1\n    g2 = new_spec 'gem', 1\n\n    assert_equal g1, g2\n    assert_equal g1.hash, g2.hash\n    assert_equal true, g1.eql?(g2)\n  end\n\n  def test_eql_eh_extensions\n    spec = @a1.dup\n    spec.extensions = 'xx'\n\n    refute_operator @a1, :eql?, spec\n    refute_operator spec, :eql?, @a1\n  end\n\n  def test_executables\n    @a1.executable = 'app'\n    assert_equal %w[app], @a1.executables\n  end\n\n  def test_executable_equals\n    @a2.executable = 'app'\n    assert_equal 'app', @a2.executable\n    assert_equal %w[bin/app lib/code.rb].sort, @a2.files\n  end\n\n  def test_extensions\n    assert_equal ['ext/extconf.rb'], ext_spec.extensions\n  end\n\n  def test_extension_dir\n    enable_shared, RbConfig::CONFIG['ENABLE_SHARED'] =\n      RbConfig::CONFIG['ENABLE_SHARED'], 'no'\n\n    ext_spec\n\n    refute_empty @ext.extensions\n\n    expected =\n      File.join(@ext.base_dir, 'extensions', Gem::Platform.local.to_s,\n                \"#{Gem.ruby_api_version}-static\", @ext.full_name)\n\n    assert_equal expected, @ext.extension_dir\n  ensure\n    RbConfig::CONFIG['ENABLE_SHARED'] = enable_shared\n  end\n\n  def test_extension_dir_override\n    enable_shared, RbConfig::CONFIG['ENABLE_SHARED'] =\n      RbConfig::CONFIG['ENABLE_SHARED'], 'no'\n\n    class << Gem\n      alias orig_default_ext_dir_for default_ext_dir_for\n\n      remove_method :default_ext_dir_for\n\n      def Gem.default_ext_dir_for(base_dir)\n        'elsewhere'\n      end\n    end\n\n    ext_spec\n\n    refute_empty @ext.extensions\n\n    expected = File.join @tempdir, 'elsewhere', @ext.full_name\n\n    assert_equal expected, @ext.extension_dir\n  ensure\n    RbConfig::CONFIG['ENABLE_SHARED'] = enable_shared\n\n    class << Gem\n      remove_method :default_ext_dir_for\n\n      alias default_ext_dir_for orig_default_ext_dir_for\n    end\n  end\n\n  def test_files\n    @a1.files = %w(files bin/common)\n    @a1.test_files = %w(test_files bin/common)\n    @a1.executables = %w(executables common)\n    @a1.extra_rdoc_files = %w(extra_rdoc_files bin/common)\n    @a1.extensions = %w(extensions bin/common)\n\n    expected = %w[\n      bin/common\n      bin/executables\n      extensions\n      extra_rdoc_files\n      files\n      test_files\n    ]\n    assert_equal expected, @a1.files\n  end\n\n  def test_files_append\n    @a1.files            = %w(files bin/common)\n    @a1.test_files       = %w(test_files bin/common)\n    @a1.executables      = %w(executables common)\n    @a1.extra_rdoc_files = %w(extra_rdoc_files bin/common)\n    @a1.extensions       = %w(extensions bin/common)\n\n    expected = %w[\n      bin/common\n      bin/executables\n      extensions\n      extra_rdoc_files\n      files\n      test_files\n    ]\n    assert_equal expected, @a1.files\n\n    @a1.files << \"generated_file.c\"\n\n    expected << \"generated_file.c\"\n    expected.sort!\n\n    assert_equal expected, @a1.files\n  end\n\n  def test_files_duplicate\n    @a2.files = %w[a b c d b]\n    @a2.extra_rdoc_files = %w[x y z x]\n    @a2.normalize\n\n    assert_equal %w[a b c d x y z], @a2.files\n    assert_equal %w[x y z], @a2.extra_rdoc_files\n  end\n\n  def test_files_extra_rdoc_files\n    @a2.files = %w[a b c d]\n    @a2.extra_rdoc_files = %w[x y z]\n    @a2.normalize\n    assert_equal %w[a b c d x y z], @a2.files\n  end\n\n  def test_files_non_array\n    @a1.files = \"F\"\n    @a1.test_files = \"TF\"\n    @a1.executables = \"X\"\n    @a1.extra_rdoc_files = \"ERF\"\n    @a1.extensions = \"E\"\n\n    assert_equal %w[E ERF F TF bin/X], @a1.files\n  end\n\n  def test_files_non_array_pathological\n    @a1.instance_variable_set :@files, \"F\"\n    @a1.instance_variable_set :@test_files, \"TF\"\n    @a1.instance_variable_set :@extra_rdoc_files, \"ERF\"\n    @a1.instance_variable_set :@extensions, \"E\"\n    @a1.instance_variable_set :@executables, \"X\"\n\n    assert_equal %w[E ERF F TF bin/X], @a1.files\n    assert_kind_of Integer, @a1.hash\n  end\n\n  def test_for_cache\n    @a2.add_runtime_dependency 'b', '1'\n    @a2.dependencies.first.instance_variable_set :@type, nil\n    @a2.required_rubygems_version = Gem::Requirement.new '> 0'\n    @a2.test_files = %w[test/test_b.rb]\n\n    refute_empty @a2.files\n    refute_empty @a2.test_files\n\n    spec = @a2.for_cache\n\n    assert_empty spec.files\n    assert_empty spec.test_files\n\n    refute_empty @a2.files\n    refute_empty @a2.test_files\n  end\n\n  def test_full_gem_path\n    assert_equal File.join(@gemhome, 'gems', @a1.full_name), @a1.full_gem_path\n\n    @a1.original_platform = 'mswin32'\n\n    assert_equal File.join(@gemhome, 'gems', @a1.original_name),\n                 @a1.full_gem_path\n  end\n\n  def test_full_gem_path_double_slash\n    gemhome = @gemhome.to_s.sub(/\\w\\//, '\\&/')\n    @a1.loaded_from = File.join gemhome, \"specifications\", @a1.spec_name\n\n    expected = File.join @gemhome, \"gems\", @a1.full_name\n    assert_equal expected, @a1.full_gem_path\n  end\n\n  def test_full_name\n    assert_equal 'a-1', @a1.full_name\n\n    @a1 = Gem::Specification.new \"a\", 1\n    @a1.platform = Gem::Platform.new ['universal', 'darwin', nil]\n    assert_equal 'a-1-universal-darwin', @a1.full_name\n\n    @a1 = Gem::Specification.new \"a\", 1\n    @a1.instance_variable_set :@new_platform, 'mswin32'\n    assert_equal 'a-1-mswin32', @a1.full_name, 'legacy'\n\n    return if win_platform?\n\n    @a1 = Gem::Specification.new \"a\", 1\n    @a1.platform = 'current'\n    assert_equal 'a-1-x86-darwin-8', @a1.full_name\n  end\n\n  def test_full_name_windows\n    test_cases = {\n      'i386-mswin32'      => 'a-1-x86-mswin32-60',\n      'i386-mswin32_80'   => 'a-1-x86-mswin32-80',\n      'i386-mingw32'      => 'a-1-x86-mingw32'\n    }\n\n    test_cases.each do |arch, expected|\n      @a1 = Gem::Specification.new \"a\", 1\n      util_set_arch arch\n      @a1.platform = 'current'\n      assert_equal expected, @a1.full_name\n    end\n  end\n\n  def test_gem_build_complete_path\n    expected = File.join @a1.extension_dir, 'gem.build_complete'\n    assert_equal expected, @a1.gem_build_complete_path\n  end\n\n  def test_hash\n    assert_equal @a1.hash, @a1.hash\n    assert_equal @a1.hash, @a1.dup.hash\n    refute_equal @a1.hash, @a2.hash\n  end\n\n  def test_installed_by_version\n    assert_equal v(0), @a1.installed_by_version\n\n    @a1.installed_by_version = Gem.rubygems_version\n\n    assert_equal Gem.rubygems_version, @a1.installed_by_version\n  end\n\n  def test_base_dir\n    assert_equal @gemhome, @a1.base_dir\n  end\n\n  def test_base_dir_not_loaded\n    @a1.instance_variable_set :@loaded_from, nil\n\n    assert_equal Gem.dir, @a1.base_dir\n  end\n\n  def test_base_dir_default\n    default_dir =\n      File.join Gem::Specification.default_specifications_dir, @a1.spec_name\n\n    @a1.instance_variable_set :@loaded_from, default_dir\n\n    assert_equal Gem.default_dir, @a1.base_dir\n  end\n\n  def test_lib_files\n    @a1.files = %w[lib/foo.rb Rakefile]\n\n    assert_equal %w[lib/foo.rb], @a1.lib_files\n  end\n\n  def test_license\n    assert_equal 'MIT', @a1.license\n  end\n\n  def test_licenses\n    assert_equal ['MIT'], @a1.licenses\n  end\n\n  def test_name\n    assert_equal 'a', @a1.name\n  end\n\n  def test_original_name\n    assert_equal 'a-1', @a1.full_name\n\n    @a1.platform = 'i386-linux'\n    @a1.instance_variable_set :@original_platform, 'i386-linux'\n    assert_equal 'a-1-i386-linux', @a1.original_name\n  end\n\n  def test_platform\n    assert_equal Gem::Platform::RUBY, @a1.platform\n  end\n\n  def test_platform_change_reset_full_name\n    orig_full_name = @a1.full_name\n\n    @a1.platform = \"universal-unknown\"\n    refute_equal orig_full_name, @a1.full_name\n  end\n\n  def test_platform_change_reset_cache_file\n    orig_cache_file = @a1.cache_file\n\n    @a1.platform = \"universal-unknown\"\n    refute_equal orig_cache_file, @a1.cache_file\n  end\n\n  def test_platform_equals\n    @a1.platform = nil\n    assert_equal Gem::Platform::RUBY, @a1.platform\n\n    @a1.platform = Gem::Platform::RUBY\n    assert_equal Gem::Platform::RUBY, @a1.platform\n\n    test_cases = {\n      'i386-mswin32'    => ['x86', 'mswin32', '60'],\n      'i386-mswin32_80' => ['x86', 'mswin32', '80'],\n      'i386-mingw32'    => ['x86', 'mingw32', nil ],\n      'x86-darwin8'     => ['x86', 'darwin',  '8' ],\n    }\n\n    test_cases.each do |arch, expected|\n      util_set_arch arch\n      @a1.platform = Gem::Platform::CURRENT\n      assert_equal Gem::Platform.new(expected), @a1.platform\n    end\n  end\n\n  def test_platform_equals_current\n    @a1.platform = Gem::Platform::CURRENT\n    assert_equal Gem::Platform.local, @a1.platform\n    assert_equal Gem::Platform.local.to_s, @a1.original_platform\n  end\n\n  def test_platform_equals_legacy\n    @a1.platform = 'mswin32'\n    assert_equal Gem::Platform.new('x86-mswin32'), @a1.platform\n\n    @a1.platform = 'i586-linux'\n    assert_equal Gem::Platform.new('x86-linux'), @a1.platform\n\n    @a1.platform = 'powerpc-darwin'\n    assert_equal Gem::Platform.new('ppc-darwin'), @a1.platform\n  end\n\n  def test_prerelease_spec_adds_required_rubygems_version\n    @prerelease = util_spec('tardis', '2.2.0.a')\n    refute @prerelease.required_rubygems_version.satisfied_by?(Gem::Version.new('1.3.1'))\n    assert @prerelease.required_rubygems_version.satisfied_by?(Gem::Version.new('1.4.0'))\n  end\n\n  def test_require_paths\n    enable_shared 'no' do\n      ext_spec\n\n      @ext.require_paths = 'lib'\n\n      assert_equal [@ext.extension_dir, 'lib'], @ext.require_paths\n    end\n  end\n\n  def test_require_paths_default_ext_dir_for\n    class << Gem\n      send :alias_method, :orig_default_ext_dir_for, :default_ext_dir_for\n\n      remove_method :default_ext_dir_for\n    end\n\n    def Gem.default_ext_dir_for base_dir\n      '/foo'\n    end\n\n    enable_shared 'no' do\n      ext_spec\n\n      @ext.require_paths = 'lib'\n\n      assert_equal [File.expand_path('/foo/ext-1'), 'lib'], @ext.require_paths\n    end\n  ensure\n    class << Gem\n      send :remove_method, :default_ext_dir_for\n      send :alias_method,  :default_ext_dir_for, :orig_default_ext_dir_for\n      send :remove_method, :orig_default_ext_dir_for\n    end\n  end\n\n  def test_source\n    assert_kind_of Gem::Source::Installed, @a1.source\n  end\n\n  def test_source_paths\n    ext_spec\n\n    @ext.require_paths = %w[lib ext foo]\n    @ext.extensions << 'bar/baz'\n\n    expected = %w[\n      lib\n      ext\n      foo\n      bar\n    ]\n\n    assert_equal expected, @ext.source_paths\n  end\n\n  def test_full_require_paths\n    ext_spec\n\n    @ext.require_paths = 'lib'\n\n    expected = [\n      File.join(@gemhome, 'gems', @ext.original_name, 'lib'),\n      @ext.extension_dir,\n    ]\n\n    assert_equal expected, @ext.full_require_paths\n  end\n\n  def test_to_fullpath\n    ext_spec\n\n    @ext.require_paths = 'lib'\n\n    dir = File.join(@gemhome, 'gems', @ext.original_name, 'lib')\n    expected_rb = File.join(dir, 'code.rb')\n    FileUtils.mkdir_p dir\n    FileUtils.touch expected_rb\n\n    dir = @ext.extension_dir\n    ext = RbConfig::CONFIG[\"DLEXT\"]\n    expected_so = File.join(dir, \"ext.#{ext}\")\n    FileUtils.mkdir_p dir\n    FileUtils.touch expected_so\n\n    assert_nil @ext.to_fullpath(\"code\")\n    assert_nil @ext.to_fullpath(\"code.rb\")\n    assert_nil @ext.to_fullpath(\"code.#{ext}\")\n\n    assert_nil @ext.to_fullpath(\"ext\")\n    assert_nil @ext.to_fullpath(\"ext.rb\")\n    assert_nil @ext.to_fullpath(\"ext.#{ext}\")\n\n    @ext.activate\n\n    assert_equal expected_rb, @ext.to_fullpath(\"code\")\n    assert_equal expected_rb, @ext.to_fullpath(\"code.rb\")\n    assert_nil @ext.to_fullpath(\"code.#{ext}\")\n\n    assert_equal expected_so, @ext.to_fullpath(\"ext\")\n    assert_nil @ext.to_fullpath(\"ext.rb\")\n    assert_equal expected_so, @ext.to_fullpath(\"ext.#{ext}\")\n\n    assert_nil @ext.to_fullpath(\"notexist\")\n  end\n\n  def test_fullpath_return_rb_extension_file_when_exist_the_same_name_file\n    ext_spec\n\n    @ext.require_paths = 'lib'\n\n    dir = File.join(@gemhome, 'gems', @ext.original_name, 'lib')\n    expected_rb = File.join(dir, 'code.rb')\n    FileUtils.mkdir_p dir\n    FileUtils.touch expected_rb\n\n    dir = @ext.extension_dir\n    ext = RbConfig::CONFIG[\"DLEXT\"]\n    expected_so = File.join(dir, \"code.#{ext}\")\n    FileUtils.mkdir_p dir\n    FileUtils.touch expected_so\n\n    @ext.activate\n\n    assert_equal expected_rb, @ext.to_fullpath(\"code\")\n  end\n\n  def test_require_already_activated\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", nil, \"lib/d.rb\"\n\n      install_specs a1 # , a2, b1, b2, c1, c2\n\n      a1.activate\n      assert_equal %w(a-1), loaded_spec_names\n      assert_equal [], unresolved_names\n\n      assert require \"d\"\n\n      assert_equal %w(a-1), loaded_spec_names\n      assert_equal [], unresolved_names\n    end\n  end\n\n  def test_require_already_activated_indirect_conflict\n    save_loaded_features do\n      a1 = new_spec \"a\", \"1\", \"b\" => \"> 0\"\n      a2 = new_spec \"a\", \"2\", \"b\" => \"> 0\"\n      b1 = new_spec \"b\", \"1\", \"c\" => \">= 1\"\n      b2 = new_spec \"b\", \"2\", \"c\" => \">= 2\"\n      c1 = new_spec \"c\", \"1\", nil, \"lib/d.rb\"\n      c2 = new_spec(\"c\", \"2\", { \"a\" => \"1\" }, \"lib/d.rb\") # conflicts with a-2\n\n      install_specs c1, b1, a1, a2, c2, b2\n\n      a1.activate\n      c1.activate\n      assert_equal %w(a-1 c-1), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n\n      assert require \"d\"\n\n      assert_equal %w(a-1 c-1), loaded_spec_names\n      assert_equal [\"b (> 0)\"], unresolved_names\n    end\n  end\n\n  def test_requirements\n    assert_equal ['A working computer'], @a1.requirements\n  end\n\n  def test_allowed_push_host\n    assert_equal nil, @a1.metadata['allowed_push_host']\n    assert_equal 'https://privategemserver.com', @a3.metadata['allowed_push_host']\n  end\n\n  def test_runtime_dependencies_legacy\n    make_spec_c1\n    # legacy gems don't have a type\n    @c1.runtime_dependencies.each do |dep|\n      dep.instance_variable_set :@type, nil\n    end\n\n    expected = %w[rake jabber4r pqa]\n\n    assert_equal expected, @c1.runtime_dependencies.map { |d| d.name }\n  end\n\n  def test_spaceship_name\n    s1 = new_spec 'a', '1'\n    s2 = new_spec 'b', '1'\n\n    assert_equal(-1, (s1 <=> s2))\n    assert_equal( 0, (s1 <=> s1))\n    assert_equal( 1, (s2 <=> s1))\n  end\n\n  def test_spaceship_platform\n    s1 = new_spec 'a', '1'\n    s2 = new_spec 'a', '1' do |s|\n      s.platform = Gem::Platform.new 'x86-my_platform1'\n    end\n\n    assert_equal( -1, (s1 <=> s2))\n    assert_equal(  0, (s1 <=> s1))\n    assert_equal(  1, (s2 <=> s1))\n  end\n\n  def test_spaceship_version\n    s1 = new_spec 'a', '1'\n    s2 = new_spec 'a', '2'\n\n    assert_equal( -1, (s1 <=> s2))\n    assert_equal(  0, (s1 <=> s1))\n    assert_equal(  1, (s2 <=> s1))\n  end\n\n  def test_spec_file\n    assert_equal File.join(@gemhome, 'specifications', 'a-1.gemspec'),\n                 @a1.spec_file\n  end\n\n  def test_spec_name\n    assert_equal 'a-1.gemspec', @a1.spec_name\n  end\n\n  def test_summary\n    assert_equal 'this is a summary', @a1.summary\n  end\n\n  def test_test_files\n    @a1.test_file = 'test/suite.rb'\n    assert_equal ['test/suite.rb'], @a1.test_files\n  end\n\n  def test_runtime_predicate_true\n    @a2.add_runtime_dependency 'b', '1'\n    assert_predicate @a2.dependencies.first, :runtime?\n\n    @a2.dependencies.first.instance_variable_set :@type, nil\n    assert_predicate @a2.dependencies.first, :runtime?\n  end\n\n  def test_runtime_predicate_false\n    @a2.add_development_dependency 'b', '1'\n    refute_predicate @a2.dependencies.first, :runtime?\n  end\n\n  def test_to_ruby\n    @a2.add_runtime_dependency 'b', '1'\n    @a2.dependencies.first.instance_variable_set :@type, nil\n    @a2.required_rubygems_version = Gem::Requirement.new '> 0'\n    @a2.require_paths << 'other'\n\n    ruby_code = @a2.to_ruby\n\n    expected = <<-SPEC\n# -*- encoding: utf-8 -*-\n# stub: a 2 ruby lib\\0other\n\nGem::Specification.new do |s|\n  s.name = \"a\".freeze\n  s.version = \"2\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\\\"> 0\\\".freeze) if s.respond_to? :required_rubygems_version=\n  s.require_paths = [\"lib\".freeze, \"other\".freeze]\n  s.authors = [\"A User\".freeze]\n  s.date = \"#{Gem::Specification::TODAY.strftime \"%Y-%m-%d\"}\"\n  s.description = \"This is a test description\".freeze\n  s.email = \"example@example.com\".freeze\n  s.files = [\"lib/code.rb\".freeze]\n  s.homepage = \"http://example.com\".freeze\n  s.rubygems_version = \"#{Gem::VERSION}\".freeze\n  s.summary = \"this is a summary\".freeze\n\n  if s.respond_to? :specification_version then\n    s.specification_version = #{Gem::Specification::CURRENT_SPECIFICATION_VERSION}\n\n    if Gem::Version.new(Gem::VERSION) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<b>.freeze, [\\\"= 1\\\"])\n    else\n      s.add_dependency(%q<b>.freeze, [\\\"= 1\\\"])\n    end\n  else\n    s.add_dependency(%q<b>.freeze, [\\\"= 1\\\"])\n  end\nend\n    SPEC\n\n    assert_equal expected, ruby_code\n\n    same_spec = eval ruby_code\n\n    assert_equal @a2, same_spec\n  end\n\n  def test_to_ruby_for_cache\n    @a2.add_runtime_dependency 'b', '1'\n    @a2.dependencies.first.instance_variable_set :@type, nil\n    @a2.required_rubygems_version = Gem::Requirement.new '> 0'\n    @a2.installed_by_version = Gem.rubygems_version\n\n    # cached specs do not have spec.files populated:\n    ruby_code = @a2.to_ruby_for_cache\n\n    expected = <<-SPEC\n# -*- encoding: utf-8 -*-\n# stub: a 2 ruby lib\n\nGem::Specification.new do |s|\n  s.name = \"a\".freeze\n  s.version = \"2\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\\\"> 0\\\".freeze) if s.respond_to? :required_rubygems_version=\n  s.require_paths = [\"lib\".freeze]\n  s.authors = [\"A User\".freeze]\n  s.date = \"#{Gem::Specification::TODAY.strftime \"%Y-%m-%d\"}\"\n  s.description = \"This is a test description\".freeze\n  s.email = \"example@example.com\".freeze\n  s.homepage = \"http://example.com\".freeze\n  s.rubygems_version = \"#{Gem::VERSION}\".freeze\n  s.summary = \"this is a summary\".freeze\n\n  s.installed_by_version = \"#{Gem::VERSION}\" if s.respond_to? :installed_by_version\n\n  if s.respond_to? :specification_version then\n    s.specification_version = #{Gem::Specification::CURRENT_SPECIFICATION_VERSION}\n\n    if Gem::Version.new(Gem::VERSION) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<b>.freeze, [\\\"= 1\\\"])\n    else\n      s.add_dependency(%q<b>.freeze, [\\\"= 1\\\"])\n    end\n  else\n    s.add_dependency(%q<b>.freeze, [\\\"= 1\\\"])\n  end\nend\n    SPEC\n\n    assert_equal expected, ruby_code\n\n    same_spec = eval ruby_code\n\n    # cached specs do not have spec.files populated:\n    @a2.files = []\n    assert_equal @a2, same_spec\n  end\n\n  def test_to_ruby_fancy\n    make_spec_c1\n\n    @c1.platform = Gem::Platform.local\n    ruby_code = @c1.to_ruby\n\n    local = Gem::Platform.local\n    expected_platform = \"[#{local.cpu.inspect}, #{local.os.inspect}, #{local.version.inspect}]\"\n    stub_require_paths =\n      @c1.instance_variable_get(:@require_paths).join \"\\u0000\"\n    extensions = @c1.extensions.join \"\\u0000\"\n\n    expected = <<-SPEC\n# -*- encoding: utf-8 -*-\n# stub: a 1 #{win_platform? ? \"x86-mswin32-60\" : \"x86-darwin-8\"} #{stub_require_paths}\n# stub: #{extensions}\n\nGem::Specification.new do |s|\n  s.name = \"a\".freeze\n  s.version = \"1\"\n  s.platform = Gem::Platform.new(#{expected_platform})\n\n  s.required_rubygems_version = Gem::Requirement.new(\\\">= 0\\\".freeze) if s.respond_to? :required_rubygems_version=\n  s.require_paths = [\"lib\".freeze]\n  s.authors = [\"A User\".freeze]\n  s.date = \"#{Gem::Specification::TODAY.strftime \"%Y-%m-%d\"}\"\n  s.description = \"This is a test description\".freeze\n  s.email = \"example@example.com\".freeze\n  s.executables = [\"exec\".freeze]\n  s.extensions = [\"ext/a/extconf.rb\".freeze]\n  s.files = [\"bin/exec\".freeze, \"ext/a/extconf.rb\".freeze, \"lib/code.rb\".freeze, \"test/suite.rb\".freeze]\n  s.homepage = \"http://example.com\".freeze\n  s.licenses = [\"MIT\".freeze]\n  s.requirements = [\"A working computer\".freeze]\n  s.rubyforge_project = \"example\".freeze\n  s.rubygems_version = \"#{Gem::VERSION}\".freeze\n  s.summary = \"this is a summary\".freeze\n  s.test_files = [\"test/suite.rb\".freeze]\n\n  if s.respond_to? :specification_version then\n    s.specification_version = 4\n\n    if Gem::Version.new(Gem::VERSION) >= Gem::Version.new('1.2.0') then\n      s.add_runtime_dependency(%q<rake>.freeze, [\\\"> 0.4\\\"])\n      s.add_runtime_dependency(%q<jabber4r>.freeze, [\\\"> 0.0.0\\\"])\n      s.add_runtime_dependency(%q<pqa>.freeze, [\\\"<= 0.6\\\", \\\"> 0.4\\\"])\n    else\n      s.add_dependency(%q<rake>.freeze, [\\\"> 0.4\\\"])\n      s.add_dependency(%q<jabber4r>.freeze, [\\\"> 0.0.0\\\"])\n      s.add_dependency(%q<pqa>.freeze, [\\\"<= 0.6\\\", \\\"> 0.4\\\"])\n    end\n  else\n    s.add_dependency(%q<rake>.freeze, [\\\"> 0.4\\\"])\n    s.add_dependency(%q<jabber4r>.freeze, [\\\"> 0.0.0\\\"])\n    s.add_dependency(%q<pqa>.freeze, [\\\"<= 0.6\\\", \\\"> 0.4\\\"])\n  end\nend\n    SPEC\n\n    assert_equal expected, ruby_code\n\n    same_spec = eval ruby_code\n\n    assert_equal @c1, same_spec\n  end\n\n  def test_to_ruby_legacy\n    gemspec1 = Gem::Deprecate.skip_during do\n      eval LEGACY_RUBY_SPEC\n    end\n    ruby_code = gemspec1.to_ruby\n    gemspec2 = eval ruby_code\n\n    assert_equal gemspec1, gemspec2\n  end\n\n  def test_to_ruby_nested_hash\n    metadata = {}\n    metadata[metadata] = metadata\n\n    @a2.metadata = metadata\n\n    ruby = @a2.to_ruby\n\n    assert_match %r%^  s\\.metadata = \\{ \"%, ruby\n  end\n\n  def test_to_ruby_platform\n    @a2.platform = Gem::Platform.local\n    @a2.instance_variable_set :@original_platform, 'old_platform'\n\n    ruby_code = @a2.to_ruby\n\n    same_spec = eval ruby_code\n\n    assert_equal 'old_platform', same_spec.original_platform\n  end\n\n  def test_to_yaml\n    yaml_str = @a1.to_yaml\n\n    refute_match '!!null', yaml_str\n\n    same_spec = Gem::Specification.from_yaml(yaml_str)\n\n    assert_equal @a1, same_spec\n  end\n\n  def test_to_yaml_fancy\n    @a1.platform = Gem::Platform.local\n    yaml_str = @a1.to_yaml\n\n    same_spec = Gem::Specification.from_yaml(yaml_str)\n\n    assert_equal Gem::Platform.local, same_spec.platform\n\n    assert_equal @a1, same_spec\n  end\n\n  def test_to_yaml_platform_empty_string\n    @a1.instance_variable_set :@original_platform, ''\n\n    assert_match %r|^platform: ruby$|, @a1.to_yaml\n  end\n\n  def test_to_yaml_platform_legacy\n    @a1.platform = 'powerpc-darwin7.9.0'\n    @a1.instance_variable_set :@original_platform, 'powerpc-darwin7.9.0'\n\n    yaml_str = @a1.to_yaml\n\n    same_spec = YAML.load yaml_str\n\n    assert_equal Gem::Platform.new('powerpc-darwin7'), same_spec.platform\n    assert_equal 'powerpc-darwin7.9.0', same_spec.original_platform\n  end\n\n  def test_to_yaml_platform_nil\n    @a1.instance_variable_set :@original_platform, nil\n\n    assert_match %r|^platform: ruby$|, @a1.to_yaml\n  end\n\n  def test_validate\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      assert @a1.validate\n    end\n  end\n\n  def x s; s.gsub(/xxx/, ''); end\n  def w; x \"WARxxxNING\"; end\n  def t; x \"TOxxxDO\"; end\n  def f; x \"FxxxIXME\"; end\n\n  def test_validate_authors\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.authors = [\"\"]\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  no author specified\\n\", @ui.error, 'error'\n\n      @a1.authors = [Object.new]\n\n      assert_equal [], @a1.authors\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal \"authors may not be empty\", e.message\n\n      @a1.authors = [\"#{f} (who is writing this software)\"]\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not an author}, e.message\n\n      @a1.authors = [\"#{t} (who is writing this software)\"]\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not an author}, e.message\n    end\n  end\n\n  def test_validate_autorequire\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.autorequire = 'code'\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  deprecated autorequire specified\\n\",\n                   @ui.error, 'error'\n    end\n  end\n\n  def test_validate_dependencies\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.add_runtime_dependency     'b', '>= 1.0.rc1'\n      @a1.add_development_dependency 'c', '>= 2.0.rc2'\n      @a1.add_runtime_dependency     'd', '~> 1.2.3'\n      @a1.add_runtime_dependency     'e', '~> 1.2.3.4'\n      @a1.add_runtime_dependency     'g', '~> 1.2.3', '>= 1.2.3.4'\n      @a1.add_runtime_dependency     'h', '>= 1.2.3', '<= 2'\n      @a1.add_runtime_dependency     'i', '>= 1.2'\n      @a1.add_runtime_dependency     'j', '>= 1.2.3'\n      @a1.add_runtime_dependency     'k', '> 1.2'\n      @a1.add_runtime_dependency     'l', '> 1.2.3'\n      @a1.add_runtime_dependency     'm', '~> 2.1.0'\n      @a1.add_runtime_dependency     'n', '~> 0.1.0'\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      expected = <<-EXPECTED\n#{w}:  prerelease dependency on b (>= 1.0.rc1) is not recommended\n#{w}:  prerelease dependency on c (>= 2.0.rc2, development) is not recommended\n#{w}:  pessimistic dependency on d (~> 1.2.3) may be overly strict\n  if d is semantically versioned, use:\n    add_runtime_dependency 'd', '~> 1.2', '>= 1.2.3'\n#{w}:  pessimistic dependency on e (~> 1.2.3.4) may be overly strict\n  if e is semantically versioned, use:\n    add_runtime_dependency 'e', '~> 1.2', '>= 1.2.3.4'\n#{w}:  open-ended dependency on i (>= 1.2) is not recommended\n  if i is semantically versioned, use:\n    add_runtime_dependency 'i', '~> 1.2'\n#{w}:  open-ended dependency on j (>= 1.2.3) is not recommended\n  if j is semantically versioned, use:\n    add_runtime_dependency 'j', '~> 1.2', '>= 1.2.3'\n#{w}:  open-ended dependency on k (> 1.2) is not recommended\n  if k is semantically versioned, use:\n    add_runtime_dependency 'k', '~> 1.2', '> 1.2'\n#{w}:  open-ended dependency on l (> 1.2.3) is not recommended\n  if l is semantically versioned, use:\n    add_runtime_dependency 'l', '~> 1.2', '> 1.2.3'\n#{w}:  pessimistic dependency on m (~> 2.1.0) may be overly strict\n  if m is semantically versioned, use:\n    add_runtime_dependency 'm', '~> 2.1', '>= 2.1.0'\n#{w}:  See http://guides.rubygems.org/specification-reference/ for help\n      EXPECTED\n\n      assert_equal expected, @ui.error, 'warning'\n    end\n  end\n\n  def test_validate_dependencies_duplicates\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.add_runtime_dependency 'b', '~> 1.2'\n      @a1.add_runtime_dependency 'b', '>= 1.2.3'\n      @a1.add_development_dependency 'c', '~> 1.2'\n      @a1.add_development_dependency 'c', '>= 1.2.3'\n\n      use_ui @ui do\n        e = assert_raises Gem::InvalidSpecificationException do\n          @a1.validate\n        end\n\n        expected = <<-EXPECTED\nduplicate dependency on b (>= 1.2.3), (~> 1.2) use:\n    add_runtime_dependency 'b', '>= 1.2.3', '~> 1.2'\nduplicate dependency on c (>= 1.2.3, development), (~> 1.2) use:\n    add_development_dependency 'c', '>= 1.2.3', '~> 1.2'\n        EXPECTED\n\n        assert_equal expected, e.message\n      end\n\n      assert_equal <<-EXPECTED, @ui.error\n#{w}:  See http://guides.rubygems.org/specification-reference/ for help\n      EXPECTED\n    end\n  end\n\n  def test_validate_dependencies_allowed_duplicates\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.add_runtime_dependency 'b', '~> 1.2'\n      @a1.add_development_dependency 'b', '= 1.2.3'\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_equal '', @ui.error, 'warning'\n    end\n  end\n\n  def test_validate_prerelease_dependencies_with_prerelease_version\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.version = '1.0.0.beta.1'\n      @a1.add_runtime_dependency 'b', '~> 1.2.0.beta.1'\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_equal '', @ui.error, 'warning'\n    end\n  end\n\n  def test_validate_description\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.description = ''\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      @ui = Gem::MockGemUi.new\n      @a1.summary = \"this is my summary\"\n      @a1.description = @a1.summary\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  description and summary are identical\\n\",\n                   @ui.error, \"error\"\n\n      @a1.description = \"#{f} (describe your package)\"\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not a description}, e.message\n\n      @a1.description = \"#{t} (describe your package)\"\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not a description}, e.message\n    end\n  end\n\n  def test_validate_email\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.email = \"FIxxxXME (your e-mail)\".sub(/xxx/, \"\")\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not an email}, e.message\n\n      @a1.email = \"#{t} (your e-mail)\"\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not an email}, e.message\n    end\n  end\n\n  def test_validate_empty\n    e = assert_raises Gem::InvalidSpecificationException do\n      Gem::Specification.new.validate\n    end\n\n    assert_equal 'missing value for attribute name', e.message\n  end\n\n  def test_validate_error\n    assert_raises Gem::InvalidSpecificationException do\n      use_ui @ui do\n        Gem::Specification.new.validate\n      end\n    end\n\n    assert_match 'See http://guides.rubygems.org/specification-reference/ for help', @ui.error\n  end\n\n  def test_validate_executables\n    util_setup_validate\n\n    FileUtils.mkdir_p File.join(@tempdir, 'bin')\n    File.open File.join(@tempdir, 'bin', 'exec'), 'w' do end\n    FileUtils.mkdir_p File.join(@tempdir, 'exec')\n\n    use_ui @ui do\n      Dir.chdir @tempdir do\n        assert @a1.validate\n      end\n    end\n\n    assert_equal %w[exec], @a1.executables\n\n    assert_equal '', @ui.output, 'output'\n    assert_match \"#{w}:  bin/exec is missing #! line\\n\", @ui.error, 'error'\n  end\n\n  def test_validate_empty_require_paths\n    if win_platform? then\n      skip 'test_validate_empty_require_paths skipped on MS Windows (symlink)'\n    else\n      util_setup_validate\n\n      @a1.require_paths = []\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal 'specification must have at least one require_path',\n                   e.message\n    end\n  end\n\n  def test_validate_files\n    skip 'test_validate_files skipped on MS Windows (symlink)' if win_platform?\n    util_setup_validate\n\n    @a1.files += ['lib', 'lib2']\n    @a1.extensions << 'ext/a/extconf.rb'\n\n    Dir.chdir @tempdir do\n      FileUtils.ln_s 'lib/code.rb', 'lib2' unless vc_windows?\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match 'WARNING:  lib2 is a symlink, which is not supported on all platforms', @ui.error\n    end\n\n    assert_equal %w[bin/exec ext/a/extconf.rb lib/code.rb lib2 test/suite.rb].sort,\n                 @a1.files\n  end\n\n  def test_validate_files_recursive\n    util_setup_validate\n    FileUtils.touch @a1.file_name\n\n    @a1.files = [@a1.file_name]\n\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n\n    assert_equal \"#{@a1.full_name} contains itself (#{@a1.file_name}), check your files list\",\n                 e.message\n  end\n\n  def test_validate_homepage\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.homepage = nil\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  no homepage specified\\n\", @ui.error, 'error'\n\n      @ui = Gem::MockGemUi.new\n\n      @a1.homepage = ''\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  no homepage specified\\n\", @ui.error, 'error'\n\n      @a1.homepage = 'over at my cool site'\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal '\"over at my cool site\" is not a URI', e.message\n\n      @a1.homepage = 'ftp://rubygems.org'\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal '\"ftp://rubygems.org\" is not a URI', e.message\n\n      @a1.homepage = 'http://rubygems.org'\n\n      assert_equal true, @a1.validate\n\n    end\n  end\n\n  def test_validate_license\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses.clear\n      @a1.validate\n    end\n\n    assert_match <<-warning, @ui.error\nWARNING:  licenses is empty, but is recommended.  Use a license identifier from\nhttp://spdx.org/licenses or 'Nonstandard' for a nonstandard license.\n    warning\n  end\n\n  def test_validate_license_values\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses = ['BSD']\n      @a1.validate\n    end\n\n    assert_match <<-warning, @ui.error\nWARNING:  license value 'BSD' is invalid.  Use a license identifier from\nhttp://spdx.org/licenses or 'Nonstandard' for a nonstandard license.\n    warning\n  end\n\n  def test_validate_license_values_plus\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses = ['GPL-2.0+']\n      @a1.validate\n    end\n\n    assert_empty @ui.error\n  end\n\n  def test_validate_license_values_with\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses = ['GPL-2.0+ WITH Autoconf-exception-2.0']\n      @a1.validate\n    end\n\n    assert_empty @ui.error\n  end\n\n  def test_validate_license_with_nonsense_suffix\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses = ['GPL-2.0+ FOO', 'GPL-2.0 FOO']\n      @a1.validate\n    end\n\n    assert_match <<-warning, @ui.error\nWARNING:  license value 'GPL-2.0+ FOO' is invalid.  Use a license identifier from\nhttp://spdx.org/licenses or 'Nonstandard' for a nonstandard license.\n    warning\n    assert_match <<-warning, @ui.error\nWARNING:  license value 'GPL-2.0 FOO' is invalid.  Use a license identifier from\nhttp://spdx.org/licenses or 'Nonstandard' for a nonstandard license.\n    warning\n  end\n\n  def test_validate_license_gives_suggestions\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses = ['ruby']\n      @a1.validate\n    end\n\n    assert_match <<-warning, @ui.error\nWARNING:  license value 'ruby' is invalid.  Use a license identifier from\nhttp://spdx.org/licenses or 'Nonstandard' for a nonstandard license.\nDid you mean 'Ruby'?\n    warning\n  end\n\n  def test_validate_empty_files\n    util_setup_validate\n\n    use_ui @ui do\n      # we have to set all of these for #files to be empty\n      @a1.files = []\n      @a1.test_files = []\n      @a1.executables = []\n\n      @a1.validate\n    end\n\n    assert_match \"no files specified\", @ui.error\n  end\n\n  def test_validate_empty_homepage\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.homepage = nil\n      @a1.validate\n    end\n\n    assert_match \"no homepage specified\", @ui.error\n  end\n\n  def test_validate_empty_summary\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.summary = nil\n      @a1.validate\n    end\n\n    assert_match \"no summary specified\", @ui.error\n  end\n\n  def test_validate_name\n    util_setup_validate\n\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.name = :json\n      @a1.validate\n    end\n\n    assert_equal 'invalid value for attribute name: \":json\" must be a string', e.message\n\n    @a1.name = []\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n    assert_equal \"invalid value for attribute name: \\\"[]\\\" must be a string\", e.message\n\n    @a1.name = \"\"\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n    assert_equal \"invalid value for attribute name: \\\"\\\" must include at least one letter\", e.message\n\n    @a1.name = \"12345\"\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n    assert_equal \"invalid value for attribute name: \\\"12345\\\" must include at least one letter\", e.message\n\n    @a1.name = \"../malicious\"\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n    assert_equal \"invalid value for attribute name: \\\"../malicious\\\" can only include letters, numbers, dashes, and underscores\", e.message\n\n    @a1.name = \"\\ba\\t\"\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n    assert_equal \"invalid value for attribute name: \\\"\\\\ba\\\\t\\\" can only include letters, numbers, dashes, and underscores\", e.message\n  end\n\n  def test_validate_non_nil\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      assert @a1.validate\n\n      Gem::Specification.non_nil_attributes.each do |name|\n        next if name == :files # set by #normalize\n        spec = @a1.dup\n        spec.instance_variable_set \"@#{name}\", nil\n\n        e = assert_raises Gem::InvalidSpecificationException do\n          spec.validate\n        end\n\n        assert_match %r%^#{name}%, e.message\n      end\n    end\n  end\n\n  def test_validate_permissions\n    skip 'chmod not supported' if Gem.win_platform?\n\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      File.chmod 0640, File.join('lib', 'code.rb')\n      File.chmod 0640, File.join('bin', 'exec')\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  lib/code.rb is not world-readable\\n\", @ui.error\n      assert_match \"#{w}:  bin/exec is not world-readable\\n\", @ui.error\n      assert_match \"#{w}:  bin/exec is not executable\\n\", @ui.error\n    end\n  end\n\n  def test_validate_permissions_of_missing_file_non_packaging\n    skip 'chmod not supported' if Gem.win_platform?\n\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      File.delete File.join('lib', 'code.rb')\n\n      use_ui @ui do\n        assert @a1.validate(false)\n      end\n    end\n  end\n\n  def test_validate_platform_legacy\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.platform = 'mswin32'\n      assert @a1.validate\n\n      @a1.platform = 'i586-linux'\n      assert @a1.validate\n\n      @a1.platform = 'powerpc-darwin'\n      assert @a1.validate\n    end\n  end\n\n  def test_validate_rubygems_version\n    util_setup_validate\n\n    @a1.rubygems_version = \"3\"\n    e = assert_raises Gem::InvalidSpecificationException do\n      @a1.validate\n    end\n\n    assert_equal \"expected RubyGems version #{Gem::VERSION}, was 3\",\n                 e.message\n  end\n\n  def test_validate_specification_version\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.specification_version = '1.0'\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        use_ui @ui do\n          @a1.validate\n        end\n      end\n\n      err = 'specification_version must be an Integer (did you mean version?)'\n      assert_equal err, e.message\n    end\n  end\n\n  def test_validate_summary\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @a1.summary = ''\n\n      use_ui @ui do\n        @a1.validate\n      end\n\n      assert_match \"#{w}:  no summary specified\\n\", @ui.error, 'error'\n\n      @a1.summary = \"#{f} (describe your package)\"\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not a summary}, e.message\n\n      @a1.summary = \"#{t} (describe your package)\"\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @a1.validate\n      end\n\n      assert_equal %{\"#{f}\" or \"#{t}\" is not a summary}, e.message\n    end\n  end\n\n  def test_validate_warning\n    util_setup_validate\n\n    use_ui @ui do\n      @a1.licenses.clear\n      @a1.validate\n    end\n\n    assert_match 'See http://guides.rubygems.org/specification-reference/ for help', @ui.error\n  end\n\n  def test_version\n    assert_equal Gem::Version.new('1'), @a1.version\n  end\n\n  def test_version_change_reset_full_name\n    orig_full_name = @a1.full_name\n\n    @a1.version = \"2\"\n\n    refute_equal orig_full_name, @a1.full_name\n  end\n\n  def test_version_change_reset_cache_file\n    orig_cache_file = @a1.cache_file\n\n    @a1.version = \"2\"\n\n    refute_equal orig_cache_file, @a1.cache_file\n  end\n\n  def test__load_fixes_Date_objects\n    spec = new_spec \"a\", 1\n    spec.instance_variable_set :@date, Date.today\n\n    spec = Marshal.load Marshal.dump(spec)\n\n    assert_kind_of Time, spec.date\n  end\n\n  def test_load_errors_contain_filename\n    specfile = Tempfile.new(self.class.name.downcase)\n    specfile.write \"raise 'boom'\"\n    specfile.close\n    begin\n      capture_io do\n        Gem::Specification.load(specfile.path)\n      end\n    rescue => e\n      name_rexp = Regexp.new(Regexp.escape(specfile.path))\n      assert e.backtrace.grep(name_rexp).any?\n    end\n  ensure\n    specfile.delete\n  end\n\n  ##\n  # KEEP p-1-x86-darwin-8\n  # KEEP p-1\n  # KEEP c-1.2\n  # KEEP a_evil-9\n  #      a-1\n  #      a-1-x86-my_platform-1\n  # KEEP a-2\n  #      a-2-x86-other_platform-1\n  # KEEP a-2-x86-my_platform-1\n  #      a-3.a\n  # KEEP a-3-x86-other_platform-1\n\n  def test_latest_specs\n    spec_fetcher do |fetcher|\n      fetcher.spec 'a', 1 do |s|\n        s.platform = Gem::Platform.new 'x86-my_platform1'\n      end\n\n      fetcher.spec 'a', 2\n\n      fetcher.spec 'a', 2 do |s|\n        s.platform = Gem::Platform.new 'x86-my_platform1'\n      end\n\n      fetcher.spec 'a', 2 do |s|\n        s.platform = Gem::Platform.new 'x86-other_platform1'\n      end\n\n      fetcher.spec 'a', 3 do |s|\n        s.platform = Gem::Platform.new 'x86-other_platform1'\n      end\n    end\n\n    expected = %W[\n                  a-2\n                  a-2-x86-my_platform-1\n                  a-3-x86-other_platform-1\n                 ]\n\n    latest_specs = Gem::Specification.latest_specs.map(&:full_name).sort\n\n    assert_equal expected, latest_specs\n  end\n\n  def test_metadata_validates_ok\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @m1 = quick_gem 'm', '1' do |s|\n        s.files = %w[lib/code.rb]\n        s.metadata = {\n          \"one\"          => \"two\",\n          \"home\"         => \"three\",\n          \"homepage_uri\" => \"https://example.com/user/repo\"\n        }\n      end\n\n      use_ui @ui do\n        @m1.validate\n      end\n    end\n  end\n\n  def test_metadata_key_type_validation_fails\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @m2 = quick_gem 'm', '2' do |s|\n        s.files = %w[lib/code.rb]\n        s.metadata = { 1 => \"fail\" }\n      end\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @m2.validate\n      end\n\n      assert_equal \"metadata keys must be a String\", e.message\n    end\n  end\n\n  def test_metadata_key_size_validation_fails\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @m2 = quick_gem 'm', '2' do |s|\n        s.files = %w[lib/code.rb]\n        s.metadata = { (\"x\" * 129) => \"fail\" }\n      end\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @m2.validate\n      end\n\n      assert_equal \"metadata key too large (129 > 128)\", e.message\n    end\n  end\n\n  def test_metadata_value_type_validation_fails\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @m2 = quick_gem 'm', '2' do |s|\n        s.files = %w[lib/code.rb]\n        s.metadata = { 'fail' => [] }\n      end\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @m2.validate\n      end\n\n      assert_equal \"metadata values must be a String\", e.message\n    end\n  end\n\n  def test_metadata_value_size_validation_fails\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @m2 = quick_gem 'm', '2' do |s|\n        s.files = %w[lib/code.rb]\n        s.metadata = { 'fail' => (\"x\" * 1025) }\n      end\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @m2.validate\n      end\n\n      assert_equal \"metadata value too large (1025 > 1024)\", e.message\n    end\n  end\n\n  def test_metadata_link_validation_fails\n    util_setup_validate\n\n    Dir.chdir @tempdir do\n      @m2 = quick_gem 'm', '2' do |s|\n        s.files = %w[lib/code.rb]\n        s.metadata = { 'homepage_uri' => 'http:/example.com' }\n      end\n\n      e = assert_raises Gem::InvalidSpecificationException do\n        @m2.validate\n      end\n\n      assert_equal \"metadata['homepage_uri'] has invalid link: \\\"http:/example.com\\\"\", e.message\n    end\n  end\n\n  def test_metadata_specs\n    valid_ruby_spec = <<-EOF\n# -*- encoding: utf-8 -*-\n# stub: m 1 ruby lib\n\nGem::Specification.new do |s|\n  s.name = \"m\".freeze\n  s.version = \"1\"\n\n  s.required_rubygems_version = Gem::Requirement.new(\">= 0\".freeze) if s.respond_to? :required_rubygems_version=\n  s.metadata = { \"one\" => \"two\", \"two\" => \"three\" } if s.respond_to? :metadata=\n  s.require_paths = [\"lib\".freeze]\n  s.authors = [\"A User\".freeze]\n  s.date = \"#{Gem::Specification::TODAY.strftime(\"%Y-%m-%d\")}\"\n  s.description = \"This is a test description\".freeze\n  s.email = \"example@example.com\".freeze\n  s.files = [\"lib/code.rb\".freeze]\n  s.homepage = \"http://example.com\".freeze\n  s.rubygems_version = \"#{Gem::VERSION}\".freeze\n  s.summary = \"this is a summary\".freeze\nend\n    EOF\n\n    @m1 = quick_gem 'm', '1' do |s|\n      s.files = %w[lib/code.rb]\n      s.metadata = { 'one' => \"two\", 'two' => \"three\" }\n    end\n\n    assert_equal @m1.to_ruby, valid_ruby_spec\n  end\n\n  def test_missing_extensions_eh\n    ext_spec\n\n    assert @ext.missing_extensions?\n\n    extconf_rb = File.join @ext.gem_dir, @ext.extensions.first\n    FileUtils.mkdir_p File.dirname extconf_rb\n\n    File.open extconf_rb, 'w' do |f|\n      f.write <<-'RUBY'\n        File.open 'Makefile', 'w' do |f|\n          f.puts \"clean:\\n\\techo clean\"\n          f.puts \"default:\\n\\techo built\"\n          f.puts \"install:\\n\\techo installed\"\n        end\n      RUBY\n    end\n\n    @ext.build_extensions\n\n    refute @ext.missing_extensions?\n  end\n\n  def test_missing_extensions_eh_default_gem\n    spec = new_default_spec 'default', 1\n    spec.extensions << 'extconf.rb'\n\n    refute spec.missing_extensions?\n  end\n\n  def test_missing_extensions_eh_legacy\n    ext_spec\n\n    @ext.installed_by_version = v '2.2.0.preview.2'\n\n    assert @ext.missing_extensions?\n\n    @ext.installed_by_version = v '2.2.0.preview.1'\n\n    refute @ext.missing_extensions?\n  end\n\n  def test_missing_extensions_eh_none\n    refute @a1.missing_extensions?\n  end\n\n  def test_find_all_by_full_name\n    pl = Gem::Platform.new 'i386-linux'\n\n    a1 = util_spec \"a\", \"1\"\n    a1_pre = util_spec \"a\", \"1.0.0.pre.1\"\n    a_1_platform = util_spec(\"a\", \"1\") {|s| s.platform = pl }\n    a_b_1 = util_spec \"a-b\", \"1\"\n    a_b_1_platform = util_spec(\"a-b\", \"1\") {|s| s.platform = pl }\n\n    a_b_1_1 = util_spec \"a-b-1\", \"1\"\n    a_b_1_1_platform = util_spec(\"a-b-1\", \"1\") {|s| s.platform = pl }\n\n    install_specs(a1, a1_pre, a_1_platform, a_b_1, a_b_1_platform,\n                  a_b_1_1, a_b_1_1_platform)\n\n    assert_equal [a1], Gem::Specification.find_all_by_full_name(\"a-1\")\n    assert_equal [a1_pre], Gem::Specification.find_all_by_full_name(\"a-1.0.0.pre.1\")\n    assert_equal [a_1_platform], Gem::Specification.find_all_by_full_name(\"a-1-x86-linux\")\n    assert_equal [a_b_1_1], Gem::Specification.find_all_by_full_name(\"a-b-1-1\")\n    assert_equal [a_b_1_1_platform], Gem::Specification.find_all_by_full_name(\"a-b-1-1-x86-linux\")\n\n    assert_equal [], Gem::Specification.find_all_by_full_name(\"monkeys\")\n    assert_equal [], Gem::Specification.find_all_by_full_name(\"a-1-foo\")\n  end\n\n  def test_find_by_name\n    install_specs util_spec \"a\"\n    install_specs util_spec \"a\", 1\n\n    assert Gem::Specification.find_by_name \"a\"\n    assert Gem::Specification.find_by_name \"a\", \"1\"\n    assert Gem::Specification.find_by_name \"a\", \">1\"\n\n    assert_raises Gem::MissingSpecError do\n      Gem::Specification.find_by_name \"monkeys\"\n    end\n  end\n\n  def test_find_by_name_with_only_prereleases\n    q = util_spec \"q\", \"2.a\"\n    install_specs q\n\n    assert Gem::Specification.find_by_name \"q\"\n  end\n\n  def test_find_by_name_prerelease\n    b = util_spec \"b\", \"2.a\"\n\n    b.activate\n\n    install_specs b\n\n    assert Gem::Specification.find_by_name \"b\"\n\n    assert_raises Gem::MissingSpecVersionError do\n      Gem::Specification.find_by_name \"b\", \"1\"\n    end\n\n    assert Gem::Specification.find_by_name \"b\", \">1\"\n  end\n\n  def test_find_by_path\n    a = new_spec \"foo\", \"1\", nil, \"lib/foo.rb\"\n\n    install_specs a\n\n    assert_equal a, Gem::Specification.find_by_path('foo')\n    a.activate\n    assert_equal a, Gem::Specification.find_by_path('foo')\n  end\n\n  def test_find_inactive_by_path\n    a = new_spec \"foo\", \"1\", nil, \"lib/foo.rb\"\n\n    install_specs a\n\n    assert_equal a, Gem::Specification.find_inactive_by_path('foo')\n    a.activate\n    assert_equal nil, Gem::Specification.find_inactive_by_path('foo')\n  end\n\n  def test_load_default_gem\n    Gem::Specification.reset\n    assert_equal [], Gem::Specification.map(&:full_name)\n\n    default_gem_spec = new_default_spec(\"default\", \"2.0.0.0\",\n                                        nil, \"default/gem.rb\")\n    spec_path = File.join(@default_spec_dir, default_gem_spec.spec_name)\n    write_file(spec_path) do |file|\n      file.print(default_gem_spec.to_ruby)\n    end\n    Gem::Specification.reset\n    assert_equal [\"default-2.0.0.0\"], Gem::Specification.map(&:full_name)\n  end\n\n  def test_detect_bundled_gem_in_old_ruby\n    util_set_RUBY_VERSION '1.9.3', 551\n\n    spec = new_spec 'bigdecimal', '1.1.0' do |s|\n      s.summary = \"This bigdecimal is bundled with Ruby\"\n    end\n\n    assert spec.bundled_gem_in_old_ruby?\n  ensure\n    util_restore_RUBY_VERSION\n  end\n\n  def util_setup_deps\n    @gem = util_spec \"awesome\", \"1.0\" do |awesome|\n      awesome.add_runtime_dependency \"bonobo\", []\n      awesome.add_development_dependency \"monkey\", []\n    end\n\n    @bonobo = Gem::Dependency.new(\"bonobo\", [])\n    @monkey = Gem::Dependency.new(\"monkey\", [], :development)\n  end\n\n  def util_setup_validate\n    Dir.chdir @tempdir do\n      FileUtils.mkdir_p File.join(\"ext\", \"a\")\n      FileUtils.mkdir_p \"lib\"\n      FileUtils.mkdir_p \"test\"\n      FileUtils.mkdir_p \"bin\"\n\n      FileUtils.touch File.join(\"ext\", \"a\", \"extconf.rb\")\n      FileUtils.touch File.join(\"lib\", \"code.rb\")\n      FileUtils.touch File.join(\"test\", \"suite.rb\")\n\n      File.open \"bin/exec\", \"w\", 0755 do |fp|\n        fp.puts \"#!#{Gem.ruby}\"\n      end\n    end\n  end\n\n  def with_syck\n    begin\n      verbose, $VERBOSE = $VERBOSE, nil\n      require \"yaml\"\n      old_engine = YAML::ENGINE.yamler\n      YAML::ENGINE.yamler = 'syck'\n      load 'rubygems/syck_hack.rb'\n    rescue NameError\n      # probably on 1.8, ignore\n    ensure\n      $VERBOSE = verbose\n    end\n\n    yield\n  ensure\n    begin\n      YAML::ENGINE.yamler = old_engine\n      load 'rubygems/syck_hack.rb'\n    rescue NameError\n      # ignore\n    end\n  end\n\n  def with_psych\n    begin\n      require \"yaml\"\n      old_engine = YAML::ENGINE.yamler\n      YAML::ENGINE.yamler = 'psych'\n      load 'rubygems/syck_hack.rb'\n    rescue NameError\n      # probably on 1.8, ignore\n    end\n\n    yield\n  ensure\n    begin\n      YAML::ENGINE.yamler = old_engine\n      load 'rubygems/syck_hack.rb'\n    rescue NameError\n      # ignore\n    end\n  end\n\n  def silence_warnings\n    old_verbose, $VERBOSE = $VERBOSE, false\n    yield\n  ensure\n    $VERBOSE = old_verbose\n  end\nend\n"], "filenames": ["lib/rubygems/specification.rb", "test/rubygems/test_gem_specification.rb"], "buggy_code_start_loc": [17, 2889], "buggy_code_end_loc": [2829, 2889], "fixing_code_start_loc": [18, 2890], "fixing_code_end_loc": [2836, 2903], "type": "CWE-20", "message": "RubyGems version Ruby 2.2 series: 2.2.9 and earlier, Ruby 2.3 series: 2.3.6 and earlier, Ruby 2.4 series: 2.4.3 and earlier, Ruby 2.5 series: 2.5.0 and earlier, prior to trunk revision 62422 contains a Improper Input Validation vulnerability in ruby gems specification homepage attribute that can result in a malicious gem could set an invalid homepage URL. This vulnerability appears to have been fixed in 2.7.6.", "other": {"cve": {"id": "CVE-2018-1000077", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-13T15:29:00.677", "lastModified": "2019-05-20T13:29:02.993", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "RubyGems version Ruby 2.2 series: 2.2.9 and earlier, Ruby 2.3 series: 2.3.6 and earlier, Ruby 2.4 series: 2.4.3 and earlier, Ruby 2.5 series: 2.5.0 and earlier, prior to trunk revision 62422 contains a Improper Input Validation vulnerability in ruby gems specification homepage attribute that can result in a malicious gem could set an invalid homepage URL. This vulnerability appears to have been fixed in 2.7.6."}, {"lang": "es", "value": "Las versiones de RubyGems de la serie Ruby 2.2: 2.2.9 y anteriores, de la serie Ruby 2.3: 2.3.6 y anteriores, de la serie Ruby 2.4: 2.4.3 y anteriores, y de la serie Ruby 2.5: versiones 2.5.0 y anteriores, anteriores a la revisi\u00f3n del trunk 62422 contiene una vulnerabilidad de validaci\u00f3n de entradas incorrecta en el atributo specification homepage de ruby gems que puede resultar en que una gema maliciosa podr\u00eda establecer una URL de p\u00e1gina de inicio no v\u00e1lida. La vulnerabilidad parece haber sido solucionada en la versi\u00f3n 2.7.6."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2.9", "matchCriteriaId": "BEE89FF0-0079-4DF5-ACFC-E1B5415E54F4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.6", "matchCriteriaId": "8080FB82-5445-4A17-9ECB-806991906E80"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.4.3", "matchCriteriaId": "CCBC38C5-781E-4998-877D-42265F1DBD05"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rubygems:rubygems:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5.0", "matchCriteriaId": "6ACE6376-2E27-4F56-9315-03367963DB09"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}], "references": [{"url": "http://blog.rubygems.org/2018/02/15/2.7.6-released.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00036.html", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3729", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3730", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:3731", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:2028", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0542", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0591", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2020:0663", "source": "cve@mitre.org"}, {"url": "https://github.com/rubygems/rubygems/commit/feadefc2d351dcb95d6492f5ad17ebca546eb964", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/04/msg00000.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/04/msg00001.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/04/msg00023.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00012.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00028.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3621-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4219", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2018/dsa-4259", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/rubygems/rubygems/commit/feadefc2d351dcb95d6492f5ad17ebca546eb964"}}