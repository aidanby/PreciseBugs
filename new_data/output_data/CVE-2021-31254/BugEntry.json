{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre, Cyril Concolato\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2020\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n/* ProtectionInfo Box */\nGF_Box *sinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProtectionSchemeInfoBox, GF_ISOM_BOX_TYPE_SINF);\n\treturn (GF_Box *)tmp;\n}\n\nvoid sinf_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err sinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_ProtectionSchemeInfoBox *ptr = (GF_ProtectionSchemeInfoBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_FRMA:\n\t\tBOX_FIELD_ASSIGN(original_format, GF_OriginalFormatBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tBOX_FIELD_ASSIGN(scheme_type, GF_SchemeTypeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SchemeInformationBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn  gf_isom_box_write_header(s, bs);\n}\n\nGF_Err sinf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_ProtectionSchemeInfoBox *ptr = (GF_ProtectionSchemeInfoBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->original_format, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->scheme_type, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->info, &pos);\n    return GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/* OriginalFormat Box */\nGF_Box *frma_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OriginalFormatBox, GF_ISOM_BOX_TYPE_FRMA);\n\treturn (GF_Box *)tmp;\n}\n\nvoid frma_box_del(GF_Box *s)\n{\n\tGF_OriginalFormatBox *ptr = (GF_OriginalFormatBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err frma_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_OriginalFormatBox *ptr = (GF_OriginalFormatBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->data_format = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err frma_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OriginalFormatBox *ptr = (GF_OriginalFormatBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->data_format);\n\treturn GF_OK;\n}\n\nGF_Err frma_box_size(GF_Box *s)\n{\n\tGF_OriginalFormatBox *ptr = (GF_OriginalFormatBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/* SchemeType Box */\nGF_Box *schm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SchemeTypeBox, GF_ISOM_BOX_TYPE_SCHM);\n\treturn (GF_Box *)tmp;\n}\n\nvoid schm_box_del(GF_Box *s)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->URI) gf_free(ptr->URI);\n\tgf_free(ptr);\n}\n\nGF_Err schm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->scheme_type = gf_bs_read_u32(bs);\n\tptr->scheme_version = gf_bs_read_u32(bs);\n\n\tif (ptr->size && (ptr->flags & 0x000001)) {\n\t\tu32 len = (u32) (ptr->size);\n\t\tptr->URI = (char*)gf_malloc(sizeof(char)*len);\n\t\tif (!ptr->URI) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URI, len);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err schm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->scheme_type);\n\tgf_bs_write_u32(bs, ptr->scheme_version);\n\tif (ptr->flags & 0x000001) {\n\t\tif (ptr->URI)\n\t\t\tgf_bs_write_data(bs, ptr->URI, (u32) strlen(ptr->URI)+1);\n\t\telse\n\t\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err schm_box_size(GF_Box *s)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += 8;\n\tif (ptr->flags & 0x000001) ptr->size += 1 + (ptr->URI ? strlen(ptr->URI) : 0);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/* SchemeInformation Box */\nGF_Box *schi_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SchemeInformationBox, GF_ISOM_BOX_TYPE_SCHI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid schi_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err schi_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SchemeInformationBox *ptr = (GF_SchemeInformationBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_IKMS:\n\t\tBOX_FIELD_ASSIGN(ikms, GF_ISMAKMSBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_ISFM:\n\t\tBOX_FIELD_ASSIGN(isfm, GF_ISMASampleFormatBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_ISLT:\n\t\tBOX_FIELD_ASSIGN(islt, GF_ISMACrypSaltBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_ODKM:\n\t\tBOX_FIELD_ASSIGN(odkm, GF_OMADRMKMSBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TENC:\n\t\tBOX_FIELD_ASSIGN(tenc, GF_TrackEncryptionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_ADKM:\n\t\tBOX_FIELD_ASSIGN(adkm, GF_AdobeDRMKeyManagementSystemBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (((GF_UUIDBox*)a)->internal_4cc==GF_ISOM_BOX_UUID_TENC) {\n\t\t\tBOX_FIELD_ASSIGN(piff_tenc, GF_PIFFTrackEncryptionBox)\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err schi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err schi_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err schi_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_SchemeInformationBox *ptr = (GF_SchemeInformationBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->ikms, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->isfm, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->islt, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->odkm, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->tenc, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->adkm, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->piff_tenc, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/* ISMAKMS Box */\nGF_Box *iKMS_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ISMAKMSBox, GF_ISOM_BOX_TYPE_IKMS);\n\treturn (GF_Box *)tmp;\n}\n\nvoid iKMS_box_del(GF_Box *s)\n{\n\tGF_ISMAKMSBox *ptr = (GF_ISMAKMSBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->URI) gf_free(ptr->URI);\n\tgf_free(ptr);\n}\n\nGF_Err iKMS_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_ISMAKMSBox *ptr = (GF_ISMAKMSBox *)s;\n\n\tlen = (u32) (ptr->size);\n\tptr->URI = (char*) gf_malloc(sizeof(char)*len);\n\tif (!ptr->URI) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->URI, len);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err iKMS_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMAKMSBox *ptr = (GF_ISMAKMSBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n    if (ptr->URI)\n        gf_bs_write_data(bs, ptr->URI, (u32) strlen(ptr->URI));\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err iKMS_box_size(GF_Box *s)\n{\n\tGF_ISMAKMSBox *ptr = (GF_ISMAKMSBox *)s;\n    ptr->size += (ptr->URI ? strlen(ptr->URI) : 0) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/* ISMASampleFormat Box */\nGF_Box *iSFM_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ISMASampleFormatBox, GF_ISOM_BOX_TYPE_ISFM);\n\treturn (GF_Box *)tmp;\n}\n\nvoid iSFM_box_del(GF_Box *s)\n{\n\tGF_ISMASampleFormatBox *ptr = (GF_ISMASampleFormatBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err iSFM_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ISMASampleFormatBox *ptr = (GF_ISMASampleFormatBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->selective_encryption = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 7);\n\tptr->key_indicator_length = gf_bs_read_u8(bs);\n\tptr->IV_length = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err iSFM_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMASampleFormatBox *ptr = (GF_ISMASampleFormatBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->selective_encryption, 1);\n\tgf_bs_write_int(bs, 0, 7);\n\tgf_bs_write_u8(bs, ptr->key_indicator_length);\n\tgf_bs_write_u8(bs, ptr->IV_length);\n\treturn GF_OK;\n}\n\nGF_Err iSFM_box_size(GF_Box *s)\n{\n\tGF_ISMASampleFormatBox *ptr = (GF_ISMASampleFormatBox *)s;\n\tptr->size += 3;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/* ISMASampleFormat Box */\nGF_Box *iSLT_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ISMACrypSaltBox, GF_ISOM_BOX_TYPE_ISLT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid iSLT_box_del(GF_Box *s)\n{\n\tGF_ISMACrypSaltBox *ptr = (GF_ISMACrypSaltBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err iSLT_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ISMACrypSaltBox *ptr = (GF_ISMACrypSaltBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->salt = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err iSLT_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMACrypSaltBox *ptr = (GF_ISMACrypSaltBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u64(bs, ptr->salt);\n\treturn GF_OK;\n}\n\nGF_Err iSLT_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n/* OMADRMCommonHeader Box */\nGF_Box *ohdr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OMADRMCommonHeaderBox, GF_ISOM_BOX_TYPE_OHDR);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid ohdr_box_del(GF_Box *s)\n{\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->ContentID) gf_free(ptr->ContentID);\n\tif (ptr->RightsIssuerURL) gf_free(ptr->RightsIssuerURL);\n\tif (ptr->TextualHeaders) gf_free(ptr->TextualHeaders);\n\tgf_free(ptr);\n}\n\nGF_Err ohdr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu16 cid_len, ri_len;\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, (1+1+8+2+2+2) );\n\tptr->EncryptionMethod = gf_bs_read_u8(bs);\n\tptr->PaddingScheme = gf_bs_read_u8(bs);\n\tptr->PlaintextLength = gf_bs_read_u64(bs);\n\tcid_len = gf_bs_read_u16(bs);\n\tri_len = gf_bs_read_u16(bs);\n\tptr->TextualHeadersLen = gf_bs_read_u16(bs);\n\n\tif (ptr->size<cid_len+ri_len+ptr->TextualHeadersLen) return GF_ISOM_INVALID_FILE;\n\n\tif (cid_len) {\n\t\tptr->ContentID = (char *)gf_malloc(sizeof(char)*(cid_len+1));\n\t\tif (!ptr->ContentID) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->ContentID, cid_len);\n\t\tptr->ContentID[cid_len]=0;\n\t}\n\n\tif (ri_len) {\n\t\tptr->RightsIssuerURL = (char *)gf_malloc(sizeof(char)*(ri_len+1));\n\t\tif (!ptr->RightsIssuerURL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->RightsIssuerURL, ri_len);\n\t\tptr->RightsIssuerURL[ri_len]=0;\n\t}\n\n\tif (ptr->TextualHeadersLen) {\n\t\tptr->TextualHeaders = (char *)gf_malloc(sizeof(char)*(ptr->TextualHeadersLen+1));\n\t\tif (!ptr->TextualHeaders) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->TextualHeaders, ptr->TextualHeadersLen);\n\t\tptr->TextualHeaders[ptr->TextualHeadersLen] = 0;\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, (cid_len+ri_len+ptr->TextualHeadersLen) );\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err ohdr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu16 cid_len, ri_len;\n\tGF_Err e;\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->EncryptionMethod);\n\tgf_bs_write_u8(bs, ptr->PaddingScheme);\n\tgf_bs_write_u64(bs, ptr->PlaintextLength);\n\n\tcid_len = ptr->ContentID ? (u16) strlen(ptr->ContentID) : 0;\n\tgf_bs_write_u16(bs, cid_len);\n\tri_len = ptr->RightsIssuerURL ? (u16) strlen(ptr->RightsIssuerURL) : 0;\n\tgf_bs_write_u16(bs, ri_len);\n\tgf_bs_write_u16(bs, ptr->TextualHeadersLen);\n\n\tif (cid_len) gf_bs_write_data(bs, ptr->ContentID, (u32) strlen(ptr->ContentID));\n\tif (ri_len) gf_bs_write_data(bs, ptr->RightsIssuerURL, (u32) strlen(ptr->RightsIssuerURL));\n\tif (ptr->TextualHeadersLen) gf_bs_write_data(bs, ptr->TextualHeaders, ptr->TextualHeadersLen);\n\n\tISOM_DECREASE_SIZE(ptr, (cid_len+ri_len+ptr->TextualHeadersLen) );\n\treturn GF_OK;\n}\n\nGF_Err ohdr_box_size(GF_Box *s)\n{\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox *)s;\n\tptr->size += 1+1+8+2+2+2;\n\tif (ptr->ContentID) ptr->size += strlen(ptr->ContentID);\n\tif (ptr->RightsIssuerURL) ptr->size += strlen(ptr->RightsIssuerURL);\n\tif (ptr->TextualHeadersLen) ptr->size += ptr->TextualHeadersLen;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* OMADRMGroupID Box */\nGF_Box *grpi_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OMADRMGroupIDBox, GF_ISOM_BOX_TYPE_GRPI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid grpi_box_del(GF_Box *s)\n{\n\tGF_OMADRMGroupIDBox *ptr = (GF_OMADRMGroupIDBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->GroupID) gf_free(ptr->GroupID);\n\tif (ptr->GroupKey) gf_free(ptr->GroupKey);\n\tgf_free(ptr);\n}\n\nGF_Err grpi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu16 gid_len;\n\tGF_OMADRMGroupIDBox *ptr = (GF_OMADRMGroupIDBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, (1+2+2) );\n\tgid_len = gf_bs_read_u16(bs);\n\tptr->GKEncryptionMethod = gf_bs_read_u8(bs);\n\tptr->GKLength = gf_bs_read_u16(bs);\n\n\tif (ptr->size<gid_len+ptr->GKLength) return GF_ISOM_INVALID_FILE;\n\n\tptr->GroupID = gf_malloc(sizeof(char)*(gid_len+1));\n\tif (!ptr->GroupID) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->GroupID, gid_len);\n\tptr->GroupID[gid_len]=0;\n\n\tptr->GroupKey = (char *)gf_malloc(sizeof(char)*ptr->GKLength);\n\tif (!ptr->GroupKey) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->GroupKey, ptr->GKLength);\n\tISOM_DECREASE_SIZE(ptr, (gid_len+ptr->GKLength) );\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err grpi_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 gid_len;\n\tGF_OMADRMGroupIDBox *ptr = (GF_OMADRMGroupIDBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgid_len = ptr->GroupID ? (u16) strlen(ptr->GroupID) : 0;\n\tgf_bs_write_u16(bs, gid_len);\n\tgf_bs_write_u8(bs, ptr->GKEncryptionMethod);\n\tgf_bs_write_u16(bs, ptr->GKLength);\n\tgf_bs_write_data(bs, ptr->GroupID, gid_len);\n\tgf_bs_write_data(bs, ptr->GroupKey, ptr->GKLength);\n\treturn GF_OK;\n}\n\nGF_Err grpi_box_size(GF_Box *s)\n{\n\tGF_OMADRMGroupIDBox *ptr = (GF_OMADRMGroupIDBox *)s;\n\tptr->size += 2+2+1 + ptr->GKLength;\n\tif (ptr->GroupID) ptr->size += strlen(ptr->GroupID);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\n/* OMADRMMutableInformation Box */\nGF_Box *mdri_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OMADRMMutableInformationBox, GF_ISOM_BOX_TYPE_MDRI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid mdri_box_del(GF_Box *s)\n{\n\tGF_OMADRMMutableInformationBox*ptr = (GF_OMADRMMutableInformationBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mdri_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err mdri_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_OMADRMMutableInformationBox*ptr = (GF_OMADRMMutableInformationBox*)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\treturn GF_OK;\n}\n\nGF_Err mdri_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* OMADRMTransactionTracking Box */\nGF_Box *odtt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OMADRMTransactionTrackingBox, GF_ISOM_BOX_TYPE_ODTT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid odtt_box_del(GF_Box *s)\n{\n\tGF_OMADRMTransactionTrackingBox *ptr = (GF_OMADRMTransactionTrackingBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err odtt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_OMADRMTransactionTrackingBox *ptr = (GF_OMADRMTransactionTrackingBox *)s;\n\n\tgf_bs_read_data(bs, ptr->TransactionID, 16);\n\tISOM_DECREASE_SIZE(ptr, 16);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err odtt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OMADRMTransactionTrackingBox *ptr = (GF_OMADRMTransactionTrackingBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->TransactionID, 16);\n\treturn GF_OK;\n}\n\nGF_Err odtt_box_size(GF_Box *s)\n{\n\ts->size += 16;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n/* OMADRMRightsObject Box */\nGF_Box *odrb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OMADRMRightsObjectBox, GF_ISOM_BOX_TYPE_ODRB);\n\treturn (GF_Box *)tmp;\n}\n\nvoid odrb_box_del(GF_Box *s)\n{\n\tGF_OMADRMRightsObjectBox *ptr = (GF_OMADRMRightsObjectBox*)s;\n\tif (ptr->oma_ro) gf_free(ptr->oma_ro);\n\tgf_free(ptr);\n}\n\nGF_Err odrb_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_OMADRMRightsObjectBox *ptr = (GF_OMADRMRightsObjectBox *)s;\n\n\tptr->oma_ro_size = (u32) ptr->size;\n\tptr->oma_ro = (char*) gf_malloc(sizeof(char)*ptr->oma_ro_size);\n\tif (!ptr->oma_ro) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->oma_ro, ptr->oma_ro_size);\n\tptr->size = 0;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err odrb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OMADRMRightsObjectBox *ptr = (GF_OMADRMRightsObjectBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->oma_ro, ptr->oma_ro_size);\n\treturn GF_OK;\n}\n\nGF_Err odrb_box_size(GF_Box *s)\n{\n\tGF_OMADRMRightsObjectBox *ptr = (GF_OMADRMRightsObjectBox *)s;\n\ts->size += ptr->oma_ro_size;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\n/* OMADRMKMS Box */\nGF_Box *odkm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OMADRMKMSBox, GF_ISOM_BOX_TYPE_ODKM);\n\treturn (GF_Box *)tmp;\n}\n\nvoid odkm_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err odkm_Add(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_OMADRMKMSBox *ptr = (GF_OMADRMKMSBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_OHDR:\n\t\tBOX_FIELD_ASSIGN(hdr, GF_OMADRMCommonHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_ODAF:\n\t\tBOX_FIELD_ASSIGN(fmt, GF_OMADRMAUFormatBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err odkm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err odkm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err odkm_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_OMADRMKMSBox *ptr = (GF_OMADRMKMSBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->hdr, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->fmt, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *pssh_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProtectionSystemHeaderBox, GF_ISOM_BOX_TYPE_PSSH);\n\treturn (GF_Box *)tmp;\n}\n\nvoid pssh_box_del(GF_Box *s)\n{\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->private_data) gf_free(ptr->private_data);\n\tif (ptr->KIDs) gf_free(ptr->KIDs);\n\tgf_free(ptr);\n}\n\nGF_Err pssh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox *)s;\n\n\tgf_bs_read_data(bs, (char *) ptr->SystemID, 16);\n\tISOM_DECREASE_SIZE(ptr, 16);\n\tif (ptr->version > 0) {\n\t\tptr->KID_count = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tif (ptr->KID_count) {\n\t\t\tu32 i;\n\t\t\tif (ptr->size < ptr->KID_count * sizeof(bin128))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tptr->KIDs = gf_malloc(ptr->KID_count*sizeof(bin128));\n\t\t\tif (!ptr->KIDs)\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\tfor (i=0; i<ptr->KID_count; i++) {\n\t\t\t\tgf_bs_read_data(bs, (char *) ptr->KIDs[i], 16);\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\t}\n\t\t}\n\t}\n\tptr->private_data_size = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->private_data_size) {\n\t\tif (ptr->size < ptr->private_data_size)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->private_data = gf_malloc(sizeof(char)*ptr->private_data_size);\n\t\tif (!ptr->private_data)\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->private_data_size);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pssh_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, (char *) ptr->SystemID, 16);\n\tif (ptr->version > 0) {\n\t\tu32 i;\n\t\tgf_bs_write_u32(bs, ptr->KID_count);\n\t\tfor (i=0; i<ptr->KID_count; i++)\n\t\t\tgf_bs_write_data(bs, (char *) ptr->KIDs[i], 16);\n\t}\n\tif (ptr->private_data) {\n\t\tgf_bs_write_u32(bs, ptr->private_data_size);\n\t\tgf_bs_write_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\t} else\n\t\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err pssh_box_size(GF_Box *s)\n{\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox*)s;\n\n\tif (ptr->KID_count && !ptr->version) {\n\t\tptr->version = 1;\n\t}\n\n\tptr->size += 16;\n\tif (ptr->version) ptr->size += 4 + 16*ptr->KID_count;\n\tptr->size += 4 + (ptr->private_data ? ptr->private_data_size : 0);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Box *tenc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackEncryptionBox, GF_ISOM_BOX_TYPE_TENC);\n\treturn (GF_Box *)tmp;\n}\n\nvoid tenc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err tenc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu8 iv_size;\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\n\tgf_bs_read_u8(bs); //reserved\n\n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); //reserved\n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\n\n\tISOM_DECREASE_SIZE(ptr, 17);\n\n\tptr->key_info[0] = 0;\n\tptr->key_info[1] = 0;\n\tptr->key_info[2] = 0;\n\tptr->key_info[3] = iv_size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, ptr->key_info+4, 16);\n\tif (!iv_size && ptr->isProtected) {\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\tiv_size = ptr->key_info[20] = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->key_info[20]);\n\t\tgf_bs_read_data(bs, ptr->key_info+21, iv_size);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tenc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, 0); //reserved\n\n\tif (!ptr->version) {\n\t\tgf_bs_write_u8(bs, 0); //reserved\n\t} else {\n\t\tgf_bs_write_int(bs, ptr->crypt_byte_block, 4);\n\t\tgf_bs_write_int(bs, ptr->skip_byte_block, 4);\n\t}\n\tgf_bs_write_u8(bs, ptr->isProtected);\n\n\tgf_bs_write_u8(bs, ptr->key_info[3]);\n\tgf_bs_write_data(bs, ptr->key_info + 4, 16);\n\tif ((ptr->isProtected == 1) && !ptr->key_info[3]) {\n\t\tgf_bs_write_u8(bs, ptr->key_info[20]);\n\t\tgf_bs_write_data(bs, ptr->key_info + 21, ptr->key_info[20]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tenc_box_size(GF_Box *s)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\tptr->size += 3;\n\n\tptr->size += 17;\n\tif ((ptr->isProtected == 1) && ! ptr->key_info[3]) {\n\t\tptr->size += 1 + ptr->key_info[20];\n\t}\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *piff_tenc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PIFFTrackEncryptionBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TENC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid piff_tenc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err piff_tenc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PIFFTrackEncryptionBox *ptr = (GF_PIFFTrackEncryptionBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\t//PIFF TENC extends UUID and fullbox\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->AlgorithmID = gf_bs_read_int(bs, 24);\n\tptr->key_info[0] = 0;\n\tptr->key_info[1] = 0;\n\tptr->key_info[2] = 0;\n\tptr->key_info[3] = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, ptr->key_info+4, 16);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err piff_tenc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PIFFTrackEncryptionBox *ptr = (GF_PIFFTrackEncryptionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\n\tgf_bs_write_int(bs, ptr->AlgorithmID, 24);\n\tgf_bs_write_u8(bs, ptr->key_info[3]);\n\tgf_bs_write_data(bs, ptr->key_info+4, 16);\n\treturn GF_OK;\n}\n\nGF_Err piff_tenc_box_size(GF_Box *s)\n{\n\tGF_PIFFTrackEncryptionBox *ptr = (GF_PIFFTrackEncryptionBox*)s;\n\tptr->size += 24;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Box *piff_psec_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleEncryptionBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_PSEC;\n\ttmp->piff_type = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid piff_psec_box_del(GF_Box *s)\n{\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *)s;\n\twhile (gf_list_count(ptr->samp_aux_info)) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, 0);\n\t\tif (sai) gf_isom_cenc_samp_aux_info_del(sai);\n\t\tgf_list_rem(ptr->samp_aux_info, 0);\n\t}\n\tif (ptr->samp_aux_info) gf_list_del(ptr->samp_aux_info);\n\tgf_free(s);\n}\n\n\nGF_Err piff_psec_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\t//PIFF PSEC extends UUID and fullbox\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->AlgorithmID = gf_bs_read_int(bs, 24);\n\t\tptr->IV_size = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) ptr->KID, 16);\n\t}\n\tif (ptr->IV_size == 0)\n\t\tptr->IV_size = 8; //default to 8\n\n\tptr->bs_offset = gf_bs_get_position(bs);\n\n\t/*u32 sample_count = */gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->IV_size != 8 && ptr->IV_size != 16) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] PIFF PSEC box incorrect IV size: %u - shall be 8 or 16\\n\", ptr->IV_size));\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//as for senc, we skip parsing of the box until we have all saiz/saio info\n\tgf_bs_skip_bytes(bs, ptr->size);\n\tptr->size = 0;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err store_senc_info(GF_SampleEncryptionBox *ptr, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos, new_pos;\n\tif (!ptr->cenc_saio) return GF_OK;\n\n\tpos = gf_bs_get_position(bs);\n\tif (pos>0xFFFFFFFFULL) {\n\t\tif (ptr->cenc_saio && !ptr->cenc_saio->version) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] saio offset larger than 32-bits but box version 0 enforced. Retry without \\\"saio32\\\" option\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\te = gf_bs_seek(bs, ptr->cenc_saio->offset_first_offset_field);\n\tif (e) return e;\n\t//force using version 1 for saio box i.e offset has 64 bits\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->traf) {\n\t\tnew_pos = pos - ptr->traf->moof_start_in_bs;\n\t} else\n#endif\n\t{\n\t\tnew_pos = pos;\n\t}\n\n\tif (ptr->cenc_saio->offsets) {\n\t\tu32 i;\n\t\tu64 old_offset = ptr->cenc_saio->offsets[0];\n\t\tfor (i=0; i<ptr->cenc_saio->entry_count; i++) {\n\t\t\tif (ptr->cenc_saio->version) {\n\t\t\t\tgf_bs_write_u64(bs, new_pos + ptr->cenc_saio->offsets[i] - old_offset);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, (u32) (new_pos + ptr->cenc_saio->offsets[i] - old_offset));\n\t\t\t}\n\t\t\tptr->cenc_saio->offsets[i] = new_pos + ptr->cenc_saio->offsets[i] - old_offset;\n\t\t}\n\t} else {\n\t\tif (ptr->cenc_saio->version) {\n\t\t\tgf_bs_write_u64(bs, new_pos);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) new_pos);\n\t\t}\n\t}\n\n\treturn gf_bs_seek(bs, pos);\n}\n\nGF_Err piff_psec_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sample_count;\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\tif (!sample_count) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_int(bs, ptr->AlgorithmID, 24);\n\t\tgf_bs_write_u8(bs, ptr->IV_size);\n\t\tgf_bs_write_data(bs, (char *) ptr->KID, 16);\n\t}\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\tgf_bs_write_u32(bs, sample_count);\n\tif (sample_count) {\n\t\tu32 i;\n\t\te = store_senc_info((GF_SampleEncryptionBox *)ptr, bs);\n\t\tif (e) return e;\n\n\t\tfor (i = 0; i < sample_count; i++) {\n\t\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\t\t\tif (! sai->cenc_data_size) continue;\n\t\t\tgf_bs_write_data(bs, (char *)sai->cenc_data, sai->cenc_data_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err piff_psec_box_size(GF_Box *s)\n{\n\tu32 i, sample_count;\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox*)s;\n\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\tif (!sample_count) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\tptr->size += 4;\n\tif (ptr->flags & 1) {\n\t\tptr->size += 20;\n\t}\n\tptr->size += 4;\n\n\tfor (i = 0; i < sample_count; i++) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\t\tif (! sai->cenc_data_size) continue;\n\t\tptr->size += sai->cenc_data_size;\n\t}\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Box *piff_pssh_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PIFFProtectionSystemHeaderBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_PSSH;\n\treturn (GF_Box *)tmp;\n}\n\nvoid piff_pssh_box_del(GF_Box *s)\n{\n\tGF_PIFFProtectionSystemHeaderBox *ptr = (GF_PIFFProtectionSystemHeaderBox*)s;\n\tif (ptr->private_data) gf_free(ptr->private_data);\n\tgf_free(s);\n}\n\nGF_Err piff_pssh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PIFFProtectionSystemHeaderBox *ptr = (GF_PIFFProtectionSystemHeaderBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 24);\n\t//PIFF PSSH extends UUID and fullbox\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\tgf_bs_read_data(bs, (char *) ptr->SystemID, 16);\n\tptr->private_data_size = gf_bs_read_u32(bs);\n\n\tif (ptr->size < sizeof(char)*ptr->private_data_size)\n\t    return GF_ISOM_INVALID_FILE;\n\tptr->private_data = gf_malloc(sizeof(char)*ptr->private_data_size);\n\tif (!ptr->private_data)\n\t    return GF_OUT_OF_MEM;\n\n\tISOM_DECREASE_SIZE(ptr, ptr->private_data_size);\n\tgf_bs_read_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err piff_pssh_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PIFFProtectionSystemHeaderBox *ptr = (GF_PIFFProtectionSystemHeaderBox *) s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\n\tgf_bs_write_data(bs, (char *) ptr->SystemID, 16);\n\tgf_bs_write_u32(bs, ptr->private_data_size);\n\tgf_bs_write_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\treturn GF_OK;\n}\n\nGF_Err piff_pssh_box_size(GF_Box *s)\n{\n\tGF_PIFFProtectionSystemHeaderBox *ptr = (GF_PIFFProtectionSystemHeaderBox*)s;\n\n\tptr->size += 24 + ptr->private_data_size;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *senc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleEncryptionBox, GF_ISOM_BOX_TYPE_SENC);\n\treturn (GF_Box *)tmp;\n}\n\nvoid senc_box_del(GF_Box *s)\n{\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *)s;\n\twhile (gf_list_count(ptr->samp_aux_info)) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, 0);\n\t\tif (sai) gf_isom_cenc_samp_aux_info_del(sai);\n\t\tgf_list_rem(ptr->samp_aux_info, 0);\n\t}\n\tif (ptr->samp_aux_info) gf_list_del(ptr->samp_aux_info);\n\tgf_free(s);\n}\n\n\nu8 key_info_get_iv_size(const u8 *key_info, u32 nb_keys, u32 idx, u8 *const_iv_size, const u8 **const_iv)\n{\n\tu32 i, kpos=3;\n\tif (const_iv_size) *const_iv_size = 0;\n\tif (const_iv) *const_iv = NULL;\n\n\tfor (i=0; i<nb_keys; i++) {\n\t\tu8 civ_size=0;\n\t\tconst u8 *civ = NULL;\n\t\tu8 iv_size = key_info[kpos];\n\t\tkpos += 17;\n\t\tif (!iv_size) {\n\t\t\tciv_size = key_info[kpos];\n\t\t\tciv = key_info + kpos + 1;\n\t\t\tkpos += 1 + iv_size;\n\t\t}\n\t\tif (i+1==idx) {\n\t\t\tif (const_iv_size) *const_iv_size = civ_size;\n\t\t\tif (const_iv) *const_iv = civ;\n\t\t\treturn iv_size;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc)\n#else\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc)\n#endif\n{\n\tGF_Err e;\n\tBool parse_failed = GF_FALSE;\n\tu32 i, count, sample_number;\n\tu32 senc_size = (u32) senc->size;\n\tu32 subs_size = 0, def_IV_size;\n\tu64 pos = gf_bs_get_position(bs);\n\tBool do_warn = GF_TRUE;\n\tBool use_multikey = GF_FALSE;\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n#endif\n\n\t//BOX + version/flags\n\tif (senc_size<12) return GF_BAD_PARAM;\n\tsenc_size -= 12;\n\n\tif (senc->piff_type==1) {\n\t\t//UUID\n\t\tif (senc_size<16) return GF_BAD_PARAM;\n\t\tsenc_size -= 16;\n\t} else if (!senc->piff_type) {\n\t\tif (senc->version==1)\n\t\t\tuse_multikey = GF_TRUE;\n\t}\n\tif (senc->flags & 2) subs_size = 8;\n\n\tif (senc_size<4) return GF_BAD_PARAM;\n\n\tsample_number = 1;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (trak) sample_number += trak->sample_count_at_seg_start;\n#endif\n\n\tgf_bs_seek(bs, senc->bs_offset);\n\n\tcount = gf_bs_read_u32(bs);\n\tsenc_size -= 4;\n\n\tdef_IV_size = 0;\n\t//check the target size if we have one subsample\n\tif (senc_size >= count * (16 + subs_size)) {\n\t\tdef_IV_size = 16;\n\t}\n\telse if (senc_size >= count * (8 + subs_size)) {\n\t\tdef_IV_size = 8;\n\t}\n\telse if (senc_size >= count * (subs_size)) {\n\t\tdef_IV_size = 0;\n\t}\n\n\tif (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();\n\tfor (i=0; i<count; i++) {\n\t\tconst u8 *key_info=NULL;\n\t\tu32 key_info_size=0;\n\t\tBool is_encrypted;\n\t\tGF_CENCSampleAuxInfo *sai;\n\t\tu8 IV_size=0;\n\t\tu32 nb_keys = 0;\n\t\tu32 nb_bytes_subsample = 6;\n\t\tu32 nb_subs_bits = 16;\n\n\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\tif (!sai) {\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tif (trak) {\n\t\t\te = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, sample_number, &is_encrypted, NULL, NULL, &key_info, &key_info_size);\n\t\t\tif (! key_info) {\n\t\t\t\tIV_size = key_info_size; //piff default\n\t\t\t\tuse_multikey = GF_FALSE;\n\t\t\t\tsenc->piff_type = 2;\n\t\t\t} else if (use_multikey) {\n\t\t\t\tnb_keys = key_info[1];\n\t\t\t\tnb_keys <<= 8;\n\t\t\t\tnb_keys |= key_info[2];\n\t\t\t\tnb_bytes_subsample = 8;\n\t\t\t\tnb_subs_bits = 32;\n\t\t\t} else {\n\t\t\t\tIV_size = key_info[3];\n\t\t\t}\n\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", sample_number, gf_error_to_string(e) ));\n\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\tif (trak->moov->mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)\n\t\t\t\t\treturn GF_OK;\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t//no init movie setup (segment dump/inspaction, assume default encrypted and 16 bytes IV\n\t\telse {\n\t\t\tif (do_warn) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] no moov found, cannot get cenc default info, assuming isEncrypted, IV size %d (computed from senc size)\\n\", def_IV_size));\n\t\t\t\tdo_warn = GF_FALSE;\n\t\t\t}\n\t\t\tis_encrypted = GF_TRUE;\n\t\t\tIV_size = def_IV_size;\n\t\t}\n\t\tif (senc_size < IV_size) {\n\t\t\tparse_failed = GF_TRUE;\n\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\tbreak;\n\t\t}\n\n\t\tsample_number++;\n\n\t\t//subsample info is only signaled for encrypted samples\n\t\tif (is_encrypted) {\n\t\t\tu64 sai_start = gf_bs_get_position(bs);\n\t\t\tu32 nb_subs = 0;\n\n\t\t\tif (use_multikey) {\n\t\t\t\tu32 j;\n\t\t\t\tu32 nb_iv_init = gf_bs_read_u16(bs);\n\t\t\t\tfor (j=0; j<nb_iv_init; j++) {\n\t\t\t\t\tu32 idx = gf_bs_read_u16(bs);\n\t\t\t\t\tIV_size = key_info_get_iv_size(key_info, nb_keys, idx, NULL, NULL);\n\t\t\t\t\tif (!IV_size) {\n\t\t\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] Failed to parse SENC box, invalid SAI multikey with IV size 0\\n\" ));\n\t\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_skip_bytes(bs, IV_size);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif (IV_size > 16) {\n\t\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] Failed to parse SENC box, invalid SAI size\\n\" ));\n\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\tif (IV_size) {\n\t\t\t\t\tgf_bs_skip_bytes(bs, IV_size);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (senc->flags & 0x00000002) {\n\t\t\t\tnb_subs = gf_bs_read_int(bs, nb_subs_bits);\n\t\t\t}\n\n\t\t\tsai->cenc_data_size = (u32) (gf_bs_get_position(bs) - sai_start);\n\t\t\tsai->cenc_data_size += nb_subs * nb_bytes_subsample;\n\t\t\tgf_bs_seek(bs, sai_start);\n\n\t\t\tif ((s32) senc_size < sai->cenc_data_size) {\n\t\t\t\tparse_failed = GF_TRUE;\n\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsai->cenc_data = gf_malloc(sizeof(u8) * sai->cenc_data_size);\n\t\t\tif (!sai->cenc_data) {\n\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tgf_bs_read_data(bs, sai->cenc_data, sai->cenc_data_size);\n\t\t\tsenc_size -= sai->cenc_data_size;\n\t\t} else {\n\t\t\ti--;\n\t\t\tsai->isNotProtected = 1;\n\t\t}\n\n\t\tif (senc->internal_4cc == GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tsai->key_info_size = IV_size;\n\t\t} else {\n\t\t\tsai->key_info = key_info;\n\t\t\tsai->key_info_size = key_info_size;\n\t\t}\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t}\n\tgf_bs_seek(bs, pos);\n\tif (parse_failed) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] cannot parse senc, missing IV/crypto state\\n\"));\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err senc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\t//WARNING - PSEC (UUID) IS TYPECASTED TO SENC (FULL BOX) SO WE CANNOT USE USUAL FULL BOX FUNCTIONS\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tptr->bs_offset = gf_bs_get_position(bs);\n\tgf_bs_skip_bytes(bs, ptr->size);\n\tptr->size = 0;\n\tptr->load_needed = GF_TRUE;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err senc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tu32 sample_count, nb_crypt_samples;\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *) s;\n\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\t//temp patch until we cleanup the spec...\n\tnb_crypt_samples = 0;\n\tfor (i = 0; i < sample_count; i++) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\t\tif (!sai->isNotProtected) nb_crypt_samples++;\n\t}\n\tif (!nb_crypt_samples) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//WARNING - PSEC (UUID) IS TYPECASTED TO SENC (FULL BOX) SO WE CANNOT USE USUAL FULL BOX FUNCTIONS\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\n\tgf_bs_write_u32(bs, nb_crypt_samples);\n\n\te = store_senc_info(ptr, bs);\n\tif (e) return e;\n\n\tfor (i = 0; i < sample_count; i++) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\t\tif (sai->isNotProtected || !sai->cenc_data_size)\n\t\t\tcontinue;\n\t\tgf_bs_write_data(bs, sai->cenc_data, sai->cenc_data_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err senc_box_size(GF_Box *s)\n{\n\tu32 sample_count;\n\tu32 i, nb_crypt_samples;\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox*)s;\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\t//temp patch until we cleanup the spec...\n\tnb_crypt_samples=0;\n\tfor (i = 0; i < sample_count; i++) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\t\tif (!sai->isNotProtected) nb_crypt_samples++;\n\t}\n\n\tif (!nb_crypt_samples) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\t//WARNING - PSEC (UUID) IS TYPECASTED TO SENC (FULL BOX) SO WE CANNOT USE USUAL FULL BOX FUNCTIONS\n\tptr->size += 4; //version and flags\n\n\tptr->size += 4; //sample count\n\tfor (i = 0; i < sample_count; i++) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\t\tif (sai->isNotProtected)\n\t\t\tcontinue;\n\t\tptr->size += sai->cenc_data_size;\n\t}\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *adkm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeDRMKeyManagementSystemBox, GF_ISOM_BOX_TYPE_ADKM);\n\ttmp->version = 1;\n\ttmp->flags = 0;\n\treturn (GF_Box *)tmp;\n}\n\nvoid adkm_box_del(GF_Box *s)\n{\n\tGF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;\n\tif (!ptr) return;\n\tgf_free(s);\n}\n\nGF_Err adkm_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_AHDR:\n\t\tBOX_FIELD_ASSIGN(header, GF_AdobeDRMHeaderBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_ADAF:\n\t\tBOX_FIELD_ASSIGN(au_format, GF_AdobeDRMAUFormatBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err adkm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err adkm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err adkm_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->au_format, &pos);\n    return GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *ahdr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeDRMHeaderBox, GF_ISOM_BOX_TYPE_AHDR);\n\ttmp->version = 2;\n\ttmp->flags = 0;\n\treturn (GF_Box *)tmp;\n}\n\nvoid ahdr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err ahdr_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_AdobeDRMHeaderBox *ptr = (GF_AdobeDRMHeaderBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_APRM:\n\t\tBOX_FIELD_ASSIGN(std_enc_params, GF_AdobeStdEncryptionParamsBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ahdr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err ahdr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err ahdr_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_AdobeDRMHeaderBox *ptr = (GF_AdobeDRMHeaderBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->std_enc_params, &pos);\n    return GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *aprm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeStdEncryptionParamsBox, GF_ISOM_BOX_TYPE_APRM);\n\ttmp->version = 1;\n\ttmp->flags = 0;\n\treturn (GF_Box *)tmp;\n}\n\nvoid aprm_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err aprm_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_AdobeStdEncryptionParamsBox *ptr = (GF_AdobeStdEncryptionParamsBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_AEIB:\n\t\tBOX_FIELD_ASSIGN(enc_info, GF_AdobeEncryptionInfoBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AKEY:\n\t\tBOX_FIELD_ASSIGN(key_info, GF_AdobeKeyInfoBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err aprm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err aprm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err aprm_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_AdobeStdEncryptionParamsBox *ptr = (GF_AdobeStdEncryptionParamsBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->enc_info, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->key_info, &pos);\n    return GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *aeib_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeEncryptionInfoBox, GF_ISOM_BOX_TYPE_AEIB);\n\ttmp->version = 1;\n\ttmp->flags = 0;\n\treturn (GF_Box *)tmp;\n}\n\nvoid aeib_box_del(GF_Box *s)\n{\n\tGF_AdobeEncryptionInfoBox *ptr = (GF_AdobeEncryptionInfoBox*)s;\n\tif (!ptr) return;\n\tif (ptr->enc_algo) gf_free(ptr->enc_algo);\n\tgf_free(ptr);\n}\n\nGF_Err aeib_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeEncryptionInfoBox *ptr = (GF_AdobeEncryptionInfoBox*)s;\n\tu32 len;\n\n\tlen = (u32) ptr->size - 1;\n\tif (len) {\n\t\tptr->enc_algo = (char *)gf_malloc(len*sizeof(char));\n\t\tif (!ptr->enc_algo) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->enc_algo, len);\n\t}\n\tptr->key_length = gf_bs_read_u8(bs);\n\tptr->size = 0;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err aeib_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AdobeEncryptionInfoBox *ptr = (GF_AdobeEncryptionInfoBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->enc_algo) {\n\t\tgf_bs_write_data(bs, (char *) ptr->enc_algo, (u32) strlen(ptr->enc_algo));\n\t\tgf_bs_write_u8(bs, 0); //string end\n\t}\n\tgf_bs_write_u8(bs, ptr->key_length);\n\treturn GF_OK;\n}\n\nGF_Err aeib_box_size(GF_Box *s)\n{\n\tGF_AdobeEncryptionInfoBox *ptr = (GF_AdobeEncryptionInfoBox*)s;\n\tif (ptr->enc_algo)\n\t\tptr->size += strlen(ptr->enc_algo) + 1;\n\tptr->size += 1; //KeyLength\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *akey_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeKeyInfoBox, GF_ISOM_BOX_TYPE_AKEY);\n\ttmp->version = 1;\n\ttmp->flags = 0;\n\treturn (GF_Box *)tmp;\n}\n\nvoid akey_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err akey_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_AdobeKeyInfoBox *ptr = (GF_AdobeKeyInfoBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_FLXS:\n\t\tBOX_FIELD_ASSIGN(params, GF_AdobeFlashAccessParamsBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err akey_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err akey_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err akey_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_AdobeKeyInfoBox *ptr = (GF_AdobeKeyInfoBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->params, &pos);\n    return GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *flxs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFlashAccessParamsBox, GF_ISOM_BOX_TYPE_FLXS);\n\treturn (GF_Box *)tmp;\n}\n\nvoid flxs_box_del(GF_Box *s)\n{\n\tGF_AdobeFlashAccessParamsBox *ptr = (GF_AdobeFlashAccessParamsBox*)s;\n\tif (!ptr) return;\n\tif (ptr->metadata)\n\t\tgf_free(ptr->metadata);\n\tgf_free(ptr);\n}\n\nGF_Err flxs_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeFlashAccessParamsBox *ptr = (GF_AdobeFlashAccessParamsBox*)s;\n\tu32 len;\n\n\tlen = (u32) ptr->size;\n\tif (len) {\n\t\tptr->metadata = (char *)gf_malloc(len*sizeof(char));\n\t\tif (!ptr->metadata) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->metadata, len);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err flxs_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AdobeFlashAccessParamsBox *ptr = (GF_AdobeFlashAccessParamsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->metadata) {\n\t\tgf_bs_write_data(bs, ptr->metadata, (u32) strlen(ptr->metadata));\n\t\tgf_bs_write_u8(bs, 0); //string end\n\t}\n\treturn GF_OK;\n}\n\nGF_Err flxs_box_size(GF_Box *s)\n{\n\tGF_AdobeFlashAccessParamsBox *ptr = (GF_AdobeFlashAccessParamsBox*)s;\n\tif (ptr->metadata)\n\t\tptr->size += strlen(ptr->metadata) + 1;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *adaf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeDRMAUFormatBox, GF_ISOM_BOX_TYPE_ADAF);\n\treturn (GF_Box *)tmp;\n}\n\nvoid adaf_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err adaf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeDRMAUFormatBox *ptr = (GF_AdobeDRMAUFormatBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->selective_enc = gf_bs_read_u8(bs);\n\tgf_bs_read_u8(bs);//resersed\n\tptr->IV_length = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err adaf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AdobeDRMAUFormatBox *ptr = (GF_AdobeDRMAUFormatBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->selective_enc);\n\tgf_bs_write_u8(bs, 0x0);\n\tgf_bs_write_u8(bs, ptr->IV_length);\n\treturn GF_OK;\n}\n\nGF_Err adaf_box_size(GF_Box *s)\n{\n\tGF_AdobeDRMAUFormatBox *ptr = (GF_AdobeDRMAUFormatBox*)s;\n\tptr->size += 3;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre, Cyril Concolato\n *\t\t\tCopyright (c) Telecom ParisTech 2005-2020\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n/* ProtectionInfo Box */\nGF_Box *sinf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProtectionSchemeInfoBox, GF_ISOM_BOX_TYPE_SINF);\n\treturn (GF_Box *)tmp;\n}\n\nvoid sinf_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err sinf_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_ProtectionSchemeInfoBox *ptr = (GF_ProtectionSchemeInfoBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_FRMA:\n\t\tBOX_FIELD_ASSIGN(original_format, GF_OriginalFormatBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SCHM:\n\t\tBOX_FIELD_ASSIGN(scheme_type, GF_SchemeTypeBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SCHI:\n\t\tBOX_FIELD_ASSIGN(info, GF_SchemeInformationBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err sinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err sinf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn  gf_isom_box_write_header(s, bs);\n}\n\nGF_Err sinf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_ProtectionSchemeInfoBox *ptr = (GF_ProtectionSchemeInfoBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->original_format, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->scheme_type, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->info, &pos);\n    return GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/* OriginalFormat Box */\nGF_Box *frma_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OriginalFormatBox, GF_ISOM_BOX_TYPE_FRMA);\n\treturn (GF_Box *)tmp;\n}\n\nvoid frma_box_del(GF_Box *s)\n{\n\tGF_OriginalFormatBox *ptr = (GF_OriginalFormatBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err frma_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_OriginalFormatBox *ptr = (GF_OriginalFormatBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->data_format = gf_bs_read_u32(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err frma_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OriginalFormatBox *ptr = (GF_OriginalFormatBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->data_format);\n\treturn GF_OK;\n}\n\nGF_Err frma_box_size(GF_Box *s)\n{\n\tGF_OriginalFormatBox *ptr = (GF_OriginalFormatBox *)s;\n\tptr->size += 4;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/* SchemeType Box */\nGF_Box *schm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SchemeTypeBox, GF_ISOM_BOX_TYPE_SCHM);\n\treturn (GF_Box *)tmp;\n}\n\nvoid schm_box_del(GF_Box *s)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->URI) gf_free(ptr->URI);\n\tgf_free(ptr);\n}\n\nGF_Err schm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->scheme_type = gf_bs_read_u32(bs);\n\tptr->scheme_version = gf_bs_read_u32(bs);\n\n\tif (ptr->size && (ptr->flags & 0x000001)) {\n\t\tu32 len = (u32) (ptr->size);\n\t\tptr->URI = (char*)gf_malloc(sizeof(char)*len);\n\t\tif (!ptr->URI) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URI, len);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err schm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->scheme_type);\n\tgf_bs_write_u32(bs, ptr->scheme_version);\n\tif (ptr->flags & 0x000001) {\n\t\tif (ptr->URI)\n\t\t\tgf_bs_write_data(bs, ptr->URI, (u32) strlen(ptr->URI)+1);\n\t\telse\n\t\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err schm_box_size(GF_Box *s)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += 8;\n\tif (ptr->flags & 0x000001) ptr->size += 1 + (ptr->URI ? strlen(ptr->URI) : 0);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/* SchemeInformation Box */\nGF_Box *schi_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SchemeInformationBox, GF_ISOM_BOX_TYPE_SCHI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid schi_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err schi_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_SchemeInformationBox *ptr = (GF_SchemeInformationBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_IKMS:\n\t\tBOX_FIELD_ASSIGN(ikms, GF_ISMAKMSBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_ISFM:\n\t\tBOX_FIELD_ASSIGN(isfm, GF_ISMASampleFormatBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_ISLT:\n\t\tBOX_FIELD_ASSIGN(islt, GF_ISMACrypSaltBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_ODKM:\n\t\tBOX_FIELD_ASSIGN(odkm, GF_OMADRMKMSBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TENC:\n\t\tBOX_FIELD_ASSIGN(tenc, GF_TrackEncryptionBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_ADKM:\n\t\tBOX_FIELD_ASSIGN(adkm, GF_AdobeDRMKeyManagementSystemBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif (((GF_UUIDBox*)a)->internal_4cc==GF_ISOM_BOX_UUID_TENC) {\n\t\t\tBOX_FIELD_ASSIGN(piff_tenc, GF_PIFFTrackEncryptionBox)\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err schi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err schi_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_write_header(s, bs);\n}\n\nGF_Err schi_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_SchemeInformationBox *ptr = (GF_SchemeInformationBox *)s;\n\n\tgf_isom_check_position(s, (GF_Box *)ptr->ikms, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->isfm, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->islt, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->odkm, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->tenc, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->adkm, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->piff_tenc, &pos);\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/* ISMAKMS Box */\nGF_Box *iKMS_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ISMAKMSBox, GF_ISOM_BOX_TYPE_IKMS);\n\treturn (GF_Box *)tmp;\n}\n\nvoid iKMS_box_del(GF_Box *s)\n{\n\tGF_ISMAKMSBox *ptr = (GF_ISMAKMSBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->URI) gf_free(ptr->URI);\n\tgf_free(ptr);\n}\n\nGF_Err iKMS_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 len;\n\tGF_ISMAKMSBox *ptr = (GF_ISMAKMSBox *)s;\n\n\tlen = (u32) (ptr->size);\n\tptr->URI = (char*) gf_malloc(sizeof(char)*len);\n\tif (!ptr->URI) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->URI, len);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err iKMS_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMAKMSBox *ptr = (GF_ISMAKMSBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n    if (ptr->URI)\n        gf_bs_write_data(bs, ptr->URI, (u32) strlen(ptr->URI));\n    gf_bs_write_u8(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err iKMS_box_size(GF_Box *s)\n{\n\tGF_ISMAKMSBox *ptr = (GF_ISMAKMSBox *)s;\n    ptr->size += (ptr->URI ? strlen(ptr->URI) : 0) + 1;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/* ISMASampleFormat Box */\nGF_Box *iSFM_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ISMASampleFormatBox, GF_ISOM_BOX_TYPE_ISFM);\n\treturn (GF_Box *)tmp;\n}\n\nvoid iSFM_box_del(GF_Box *s)\n{\n\tGF_ISMASampleFormatBox *ptr = (GF_ISMASampleFormatBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err iSFM_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ISMASampleFormatBox *ptr = (GF_ISMASampleFormatBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->selective_encryption = gf_bs_read_int(bs, 1);\n\tgf_bs_read_int(bs, 7);\n\tptr->key_indicator_length = gf_bs_read_u8(bs);\n\tptr->IV_length = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err iSFM_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMASampleFormatBox *ptr = (GF_ISMASampleFormatBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_int(bs, ptr->selective_encryption, 1);\n\tgf_bs_write_int(bs, 0, 7);\n\tgf_bs_write_u8(bs, ptr->key_indicator_length);\n\tgf_bs_write_u8(bs, ptr->IV_length);\n\treturn GF_OK;\n}\n\nGF_Err iSFM_box_size(GF_Box *s)\n{\n\tGF_ISMASampleFormatBox *ptr = (GF_ISMASampleFormatBox *)s;\n\tptr->size += 3;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n/* ISMASampleFormat Box */\nGF_Box *iSLT_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ISMACrypSaltBox, GF_ISOM_BOX_TYPE_ISLT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid iSLT_box_del(GF_Box *s)\n{\n\tGF_ISMACrypSaltBox *ptr = (GF_ISMACrypSaltBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\n\nGF_Err iSLT_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ISMACrypSaltBox *ptr = (GF_ISMACrypSaltBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->salt = gf_bs_read_u64(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err iSLT_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ISMACrypSaltBox *ptr = (GF_ISMACrypSaltBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u64(bs, ptr->salt);\n\treturn GF_OK;\n}\n\nGF_Err iSLT_box_size(GF_Box *s)\n{\n\ts->size += 8;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n/* OMADRMCommonHeader Box */\nGF_Box *ohdr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OMADRMCommonHeaderBox, GF_ISOM_BOX_TYPE_OHDR);\n\ttmp->child_boxes = gf_list_new();\n\treturn (GF_Box *)tmp;\n}\n\nvoid ohdr_box_del(GF_Box *s)\n{\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->ContentID) gf_free(ptr->ContentID);\n\tif (ptr->RightsIssuerURL) gf_free(ptr->RightsIssuerURL);\n\tif (ptr->TextualHeaders) gf_free(ptr->TextualHeaders);\n\tgf_free(ptr);\n}\n\nGF_Err ohdr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu16 cid_len, ri_len;\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, (1+1+8+2+2+2) );\n\tptr->EncryptionMethod = gf_bs_read_u8(bs);\n\tptr->PaddingScheme = gf_bs_read_u8(bs);\n\tptr->PlaintextLength = gf_bs_read_u64(bs);\n\tcid_len = gf_bs_read_u16(bs);\n\tri_len = gf_bs_read_u16(bs);\n\tptr->TextualHeadersLen = gf_bs_read_u16(bs);\n\n\tif (ptr->size<cid_len+ri_len+ptr->TextualHeadersLen) return GF_ISOM_INVALID_FILE;\n\n\tif (cid_len) {\n\t\tptr->ContentID = (char *)gf_malloc(sizeof(char)*(cid_len+1));\n\t\tif (!ptr->ContentID) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->ContentID, cid_len);\n\t\tptr->ContentID[cid_len]=0;\n\t}\n\n\tif (ri_len) {\n\t\tptr->RightsIssuerURL = (char *)gf_malloc(sizeof(char)*(ri_len+1));\n\t\tif (!ptr->RightsIssuerURL) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->RightsIssuerURL, ri_len);\n\t\tptr->RightsIssuerURL[ri_len]=0;\n\t}\n\n\tif (ptr->TextualHeadersLen) {\n\t\tptr->TextualHeaders = (char *)gf_malloc(sizeof(char)*(ptr->TextualHeadersLen+1));\n\t\tif (!ptr->TextualHeaders) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->TextualHeaders, ptr->TextualHeadersLen);\n\t\tptr->TextualHeaders[ptr->TextualHeadersLen] = 0;\n\t}\n\n\tISOM_DECREASE_SIZE(ptr, (cid_len+ri_len+ptr->TextualHeadersLen) );\n\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err ohdr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tu16 cid_len, ri_len;\n\tGF_Err e;\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->EncryptionMethod);\n\tgf_bs_write_u8(bs, ptr->PaddingScheme);\n\tgf_bs_write_u64(bs, ptr->PlaintextLength);\n\n\tcid_len = ptr->ContentID ? (u16) strlen(ptr->ContentID) : 0;\n\tgf_bs_write_u16(bs, cid_len);\n\tri_len = ptr->RightsIssuerURL ? (u16) strlen(ptr->RightsIssuerURL) : 0;\n\tgf_bs_write_u16(bs, ri_len);\n\tgf_bs_write_u16(bs, ptr->TextualHeadersLen);\n\n\tif (cid_len) gf_bs_write_data(bs, ptr->ContentID, (u32) strlen(ptr->ContentID));\n\tif (ri_len) gf_bs_write_data(bs, ptr->RightsIssuerURL, (u32) strlen(ptr->RightsIssuerURL));\n\tif (ptr->TextualHeadersLen) gf_bs_write_data(bs, ptr->TextualHeaders, ptr->TextualHeadersLen);\n\n\tISOM_DECREASE_SIZE(ptr, (cid_len+ri_len+ptr->TextualHeadersLen) );\n\treturn GF_OK;\n}\n\nGF_Err ohdr_box_size(GF_Box *s)\n{\n\tGF_OMADRMCommonHeaderBox *ptr = (GF_OMADRMCommonHeaderBox *)s;\n\tptr->size += 1+1+8+2+2+2;\n\tif (ptr->ContentID) ptr->size += strlen(ptr->ContentID);\n\tif (ptr->RightsIssuerURL) ptr->size += strlen(ptr->RightsIssuerURL);\n\tif (ptr->TextualHeadersLen) ptr->size += ptr->TextualHeadersLen;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* OMADRMGroupID Box */\nGF_Box *grpi_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OMADRMGroupIDBox, GF_ISOM_BOX_TYPE_GRPI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid grpi_box_del(GF_Box *s)\n{\n\tGF_OMADRMGroupIDBox *ptr = (GF_OMADRMGroupIDBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->GroupID) gf_free(ptr->GroupID);\n\tif (ptr->GroupKey) gf_free(ptr->GroupKey);\n\tgf_free(ptr);\n}\n\nGF_Err grpi_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu16 gid_len;\n\tGF_OMADRMGroupIDBox *ptr = (GF_OMADRMGroupIDBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, (1+2+2) );\n\tgid_len = gf_bs_read_u16(bs);\n\tptr->GKEncryptionMethod = gf_bs_read_u8(bs);\n\tptr->GKLength = gf_bs_read_u16(bs);\n\n\tif (ptr->size<gid_len+ptr->GKLength) return GF_ISOM_INVALID_FILE;\n\n\tptr->GroupID = gf_malloc(sizeof(char)*(gid_len+1));\n\tif (!ptr->GroupID) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->GroupID, gid_len);\n\tptr->GroupID[gid_len]=0;\n\n\tptr->GroupKey = (char *)gf_malloc(sizeof(char)*ptr->GKLength);\n\tif (!ptr->GroupKey) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->GroupKey, ptr->GKLength);\n\tISOM_DECREASE_SIZE(ptr, (gid_len+ptr->GKLength) );\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err grpi_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 gid_len;\n\tGF_OMADRMGroupIDBox *ptr = (GF_OMADRMGroupIDBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgid_len = ptr->GroupID ? (u16) strlen(ptr->GroupID) : 0;\n\tgf_bs_write_u16(bs, gid_len);\n\tgf_bs_write_u8(bs, ptr->GKEncryptionMethod);\n\tgf_bs_write_u16(bs, ptr->GKLength);\n\tgf_bs_write_data(bs, ptr->GroupID, gid_len);\n\tgf_bs_write_data(bs, ptr->GroupKey, ptr->GKLength);\n\treturn GF_OK;\n}\n\nGF_Err grpi_box_size(GF_Box *s)\n{\n\tGF_OMADRMGroupIDBox *ptr = (GF_OMADRMGroupIDBox *)s;\n\tptr->size += 2+2+1 + ptr->GKLength;\n\tif (ptr->GroupID) ptr->size += strlen(ptr->GroupID);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\n/* OMADRMMutableInformation Box */\nGF_Box *mdri_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OMADRMMutableInformationBox, GF_ISOM_BOX_TYPE_MDRI);\n\treturn (GF_Box *)tmp;\n}\n\nvoid mdri_box_del(GF_Box *s)\n{\n\tGF_OMADRMMutableInformationBox*ptr = (GF_OMADRMMutableInformationBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}\n\nGF_Err mdri_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err mdri_box_write(GF_Box *s, GF_BitStream *bs)\n{\n//\tGF_OMADRMMutableInformationBox*ptr = (GF_OMADRMMutableInformationBox*)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\treturn GF_OK;\n}\n\nGF_Err mdri_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n/* OMADRMTransactionTracking Box */\nGF_Box *odtt_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OMADRMTransactionTrackingBox, GF_ISOM_BOX_TYPE_ODTT);\n\treturn (GF_Box *)tmp;\n}\n\nvoid odtt_box_del(GF_Box *s)\n{\n\tGF_OMADRMTransactionTrackingBox *ptr = (GF_OMADRMTransactionTrackingBox*)s;\n\tgf_free(ptr);\n}\n\nGF_Err odtt_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_OMADRMTransactionTrackingBox *ptr = (GF_OMADRMTransactionTrackingBox *)s;\n\n\tgf_bs_read_data(bs, ptr->TransactionID, 16);\n\tISOM_DECREASE_SIZE(ptr, 16);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err odtt_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OMADRMTransactionTrackingBox *ptr = (GF_OMADRMTransactionTrackingBox*)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->TransactionID, 16);\n\treturn GF_OK;\n}\n\nGF_Err odtt_box_size(GF_Box *s)\n{\n\ts->size += 16;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n/* OMADRMRightsObject Box */\nGF_Box *odrb_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OMADRMRightsObjectBox, GF_ISOM_BOX_TYPE_ODRB);\n\treturn (GF_Box *)tmp;\n}\n\nvoid odrb_box_del(GF_Box *s)\n{\n\tGF_OMADRMRightsObjectBox *ptr = (GF_OMADRMRightsObjectBox*)s;\n\tif (ptr->oma_ro) gf_free(ptr->oma_ro);\n\tgf_free(ptr);\n}\n\nGF_Err odrb_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_OMADRMRightsObjectBox *ptr = (GF_OMADRMRightsObjectBox *)s;\n\n\tptr->oma_ro_size = (u32) ptr->size;\n\tptr->oma_ro = (char*) gf_malloc(sizeof(char)*ptr->oma_ro_size);\n\tif (!ptr->oma_ro) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, ptr->oma_ro, ptr->oma_ro_size);\n\tptr->size = 0;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err odrb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OMADRMRightsObjectBox *ptr = (GF_OMADRMRightsObjectBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->oma_ro, ptr->oma_ro_size);\n\treturn GF_OK;\n}\n\nGF_Err odrb_box_size(GF_Box *s)\n{\n\tGF_OMADRMRightsObjectBox *ptr = (GF_OMADRMRightsObjectBox *)s;\n\ts->size += ptr->oma_ro_size;\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\n/* OMADRMKMS Box */\nGF_Box *odkm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_OMADRMKMSBox, GF_ISOM_BOX_TYPE_ODKM);\n\treturn (GF_Box *)tmp;\n}\n\nvoid odkm_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err odkm_Add(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_OMADRMKMSBox *ptr = (GF_OMADRMKMSBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_OHDR:\n\t\tBOX_FIELD_ASSIGN(hdr, GF_OMADRMCommonHeaderBox)\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_ODAF:\n\t\tBOX_FIELD_ASSIGN(fmt, GF_OMADRMAUFormatBox)\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err odkm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err odkm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err odkm_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_OMADRMKMSBox *ptr = (GF_OMADRMKMSBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->hdr, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->fmt, &pos);\n\treturn GF_OK;\n}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\n\n\nGF_Box *pssh_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProtectionSystemHeaderBox, GF_ISOM_BOX_TYPE_PSSH);\n\treturn (GF_Box *)tmp;\n}\n\nvoid pssh_box_del(GF_Box *s)\n{\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox*)s;\n\tif (ptr == NULL) return;\n\tif (ptr->private_data) gf_free(ptr->private_data);\n\tif (ptr->KIDs) gf_free(ptr->KIDs);\n\tgf_free(ptr);\n}\n\nGF_Err pssh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox *)s;\n\n\tgf_bs_read_data(bs, (char *) ptr->SystemID, 16);\n\tISOM_DECREASE_SIZE(ptr, 16);\n\tif (ptr->version > 0) {\n\t\tptr->KID_count = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tif (ptr->KID_count) {\n\t\t\tu32 i;\n\t\t\tif (ptr->size < ptr->KID_count * sizeof(bin128))\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tptr->KIDs = gf_malloc(ptr->KID_count*sizeof(bin128));\n\t\t\tif (!ptr->KIDs)\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\tfor (i=0; i<ptr->KID_count; i++) {\n\t\t\t\tgf_bs_read_data(bs, (char *) ptr->KIDs[i], 16);\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\t}\n\t\t}\n\t}\n\tptr->private_data_size = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->private_data_size) {\n\t\tif (ptr->size < ptr->private_data_size)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->private_data = gf_malloc(sizeof(char)*ptr->private_data_size);\n\t\tif (!ptr->private_data)\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->private_data_size);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err pssh_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_data(bs, (char *) ptr->SystemID, 16);\n\tif (ptr->version > 0) {\n\t\tu32 i;\n\t\tgf_bs_write_u32(bs, ptr->KID_count);\n\t\tfor (i=0; i<ptr->KID_count; i++)\n\t\t\tgf_bs_write_data(bs, (char *) ptr->KIDs[i], 16);\n\t}\n\tif (ptr->private_data) {\n\t\tgf_bs_write_u32(bs, ptr->private_data_size);\n\t\tgf_bs_write_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\t} else\n\t\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}\n\nGF_Err pssh_box_size(GF_Box *s)\n{\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox*)s;\n\n\tif (ptr->KID_count && !ptr->version) {\n\t\tptr->version = 1;\n\t}\n\n\tptr->size += 16;\n\tif (ptr->version) ptr->size += 4 + 16*ptr->KID_count;\n\tptr->size += 4 + (ptr->private_data ? ptr->private_data_size : 0);\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Box *tenc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackEncryptionBox, GF_ISOM_BOX_TYPE_TENC);\n\treturn (GF_Box *)tmp;\n}\n\nvoid tenc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err tenc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu8 iv_size;\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\n\tgf_bs_read_u8(bs); //reserved\n\n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); //reserved\n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\n\n\tISOM_DECREASE_SIZE(ptr, 17);\n\n\tptr->key_info[0] = 0;\n\tptr->key_info[1] = 0;\n\tptr->key_info[2] = 0;\n\tptr->key_info[3] = iv_size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, ptr->key_info+4, 16);\n\tif (!iv_size && ptr->isProtected) {\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\tiv_size = ptr->key_info[20] = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->key_info[20]);\n\t\tif ((iv_size!=8) && (iv_size!=16)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid constant IV size %d, must be 8 or 16\\n\", (u32) iv_size));\n\t\t\tptr->key_info[20] = 16;\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_read_data(bs, ptr->key_info+21, iv_size);\n\t}\n\telse if ((iv_size!=0) && (iv_size!=8) && (iv_size!=16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid IV size %d, must be 0, 8 or 16\\n\", (u32) iv_size));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err tenc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, 0); //reserved\n\n\tif (!ptr->version) {\n\t\tgf_bs_write_u8(bs, 0); //reserved\n\t} else {\n\t\tgf_bs_write_int(bs, ptr->crypt_byte_block, 4);\n\t\tgf_bs_write_int(bs, ptr->skip_byte_block, 4);\n\t}\n\tgf_bs_write_u8(bs, ptr->isProtected);\n\n\tgf_bs_write_u8(bs, ptr->key_info[3]);\n\tgf_bs_write_data(bs, ptr->key_info + 4, 16);\n\tif ((ptr->isProtected == 1) && !ptr->key_info[3]) {\n\t\tgf_bs_write_u8(bs, ptr->key_info[20]);\n\t\tgf_bs_write_data(bs, ptr->key_info + 21, ptr->key_info[20]);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err tenc_box_size(GF_Box *s)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\tptr->size += 3;\n\n\tptr->size += 17;\n\tif ((ptr->isProtected == 1) && ! ptr->key_info[3]) {\n\t\tptr->size += 1 + ptr->key_info[20];\n\t}\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *piff_tenc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PIFFTrackEncryptionBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_TENC;\n\treturn (GF_Box *)tmp;\n}\n\nvoid piff_tenc_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err piff_tenc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PIFFTrackEncryptionBox *ptr = (GF_PIFFTrackEncryptionBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\t//PIFF TENC extends UUID and fullbox\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tISOM_DECREASE_SIZE(ptr, 20);\n\tptr->AlgorithmID = gf_bs_read_int(bs, 24);\n\tptr->key_info[0] = 0;\n\tptr->key_info[1] = 0;\n\tptr->key_info[2] = 0;\n\tptr->key_info[3] = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, ptr->key_info+4, 16);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err piff_tenc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PIFFTrackEncryptionBox *ptr = (GF_PIFFTrackEncryptionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\n\tgf_bs_write_int(bs, ptr->AlgorithmID, 24);\n\tgf_bs_write_u8(bs, ptr->key_info[3]);\n\tgf_bs_write_data(bs, ptr->key_info+4, 16);\n\treturn GF_OK;\n}\n\nGF_Err piff_tenc_box_size(GF_Box *s)\n{\n\tGF_PIFFTrackEncryptionBox *ptr = (GF_PIFFTrackEncryptionBox*)s;\n\tptr->size += 24;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Box *piff_psec_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleEncryptionBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_PSEC;\n\ttmp->piff_type = 1;\n\treturn (GF_Box *)tmp;\n}\n\nvoid piff_psec_box_del(GF_Box *s)\n{\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *)s;\n\twhile (gf_list_count(ptr->samp_aux_info)) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, 0);\n\t\tif (sai) gf_isom_cenc_samp_aux_info_del(sai);\n\t\tgf_list_rem(ptr->samp_aux_info, 0);\n\t}\n\tif (ptr->samp_aux_info) gf_list_del(ptr->samp_aux_info);\n\tgf_free(s);\n}\n\n\nGF_Err piff_psec_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\t//PIFF PSEC extends UUID and fullbox\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tif (ptr->flags & 1) {\n\t\tISOM_DECREASE_SIZE(ptr, 20);\n\t\tptr->AlgorithmID = gf_bs_read_int(bs, 24);\n\t\tptr->IV_size = gf_bs_read_u8(bs);\n\t\tgf_bs_read_data(bs, (char *) ptr->KID, 16);\n\t}\n\tif (ptr->IV_size == 0)\n\t\tptr->IV_size = 8; //default to 8\n\n\tptr->bs_offset = gf_bs_get_position(bs);\n\n\t/*u32 sample_count = */gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->IV_size != 8 && ptr->IV_size != 16) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] PIFF PSEC box incorrect IV size: %u - shall be 8 or 16\\n\", ptr->IV_size));\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//as for senc, we skip parsing of the box until we have all saiz/saio info\n\tgf_bs_skip_bytes(bs, ptr->size);\n\tptr->size = 0;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err store_senc_info(GF_SampleEncryptionBox *ptr, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos, new_pos;\n\tif (!ptr->cenc_saio) return GF_OK;\n\n\tpos = gf_bs_get_position(bs);\n\tif (pos>0xFFFFFFFFULL) {\n\t\tif (ptr->cenc_saio && !ptr->cenc_saio->version) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] saio offset larger than 32-bits but box version 0 enforced. Retry without \\\"saio32\\\" option\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\te = gf_bs_seek(bs, ptr->cenc_saio->offset_first_offset_field);\n\tif (e) return e;\n\t//force using version 1 for saio box i.e offset has 64 bits\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ptr->traf) {\n\t\tnew_pos = pos - ptr->traf->moof_start_in_bs;\n\t} else\n#endif\n\t{\n\t\tnew_pos = pos;\n\t}\n\n\tif (ptr->cenc_saio->offsets) {\n\t\tu32 i;\n\t\tu64 old_offset = ptr->cenc_saio->offsets[0];\n\t\tfor (i=0; i<ptr->cenc_saio->entry_count; i++) {\n\t\t\tif (ptr->cenc_saio->version) {\n\t\t\t\tgf_bs_write_u64(bs, new_pos + ptr->cenc_saio->offsets[i] - old_offset);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u32(bs, (u32) (new_pos + ptr->cenc_saio->offsets[i] - old_offset));\n\t\t\t}\n\t\t\tptr->cenc_saio->offsets[i] = new_pos + ptr->cenc_saio->offsets[i] - old_offset;\n\t\t}\n\t} else {\n\t\tif (ptr->cenc_saio->version) {\n\t\t\tgf_bs_write_u64(bs, new_pos);\n\t\t} else {\n\t\t\tgf_bs_write_u32(bs, (u32) new_pos);\n\t\t}\n\t}\n\n\treturn gf_bs_seek(bs, pos);\n}\n\nGF_Err piff_psec_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 sample_count;\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\tif (!sample_count) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\n\tif (ptr->flags & 1) {\n\t\tgf_bs_write_int(bs, ptr->AlgorithmID, 24);\n\t\tgf_bs_write_u8(bs, ptr->IV_size);\n\t\tgf_bs_write_data(bs, (char *) ptr->KID, 16);\n\t}\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\tgf_bs_write_u32(bs, sample_count);\n\tif (sample_count) {\n\t\tu32 i;\n\t\te = store_senc_info((GF_SampleEncryptionBox *)ptr, bs);\n\t\tif (e) return e;\n\n\t\tfor (i = 0; i < sample_count; i++) {\n\t\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\t\t\tif (! sai->cenc_data_size) continue;\n\t\t\tgf_bs_write_data(bs, (char *)sai->cenc_data, sai->cenc_data_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_Err piff_psec_box_size(GF_Box *s)\n{\n\tu32 i, sample_count;\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox*)s;\n\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\tif (!sample_count) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\tptr->size += 4;\n\tif (ptr->flags & 1) {\n\t\tptr->size += 20;\n\t}\n\tptr->size += 4;\n\n\tfor (i = 0; i < sample_count; i++) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\t\tif (! sai->cenc_data_size) continue;\n\t\tptr->size += sai->cenc_data_size;\n\t}\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Box *piff_pssh_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_PIFFProtectionSystemHeaderBox, GF_ISOM_BOX_TYPE_UUID);\n\ttmp->internal_4cc = GF_ISOM_BOX_UUID_PSSH;\n\treturn (GF_Box *)tmp;\n}\n\nvoid piff_pssh_box_del(GF_Box *s)\n{\n\tGF_PIFFProtectionSystemHeaderBox *ptr = (GF_PIFFProtectionSystemHeaderBox*)s;\n\tif (ptr->private_data) gf_free(ptr->private_data);\n\tgf_free(s);\n}\n\nGF_Err piff_pssh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PIFFProtectionSystemHeaderBox *ptr = (GF_PIFFProtectionSystemHeaderBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 24);\n\t//PIFF PSSH extends UUID and fullbox\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\tgf_bs_read_data(bs, (char *) ptr->SystemID, 16);\n\tptr->private_data_size = gf_bs_read_u32(bs);\n\n\tif (ptr->size < sizeof(char)*ptr->private_data_size)\n\t    return GF_ISOM_INVALID_FILE;\n\tptr->private_data = gf_malloc(sizeof(char)*ptr->private_data_size);\n\tif (!ptr->private_data)\n\t    return GF_OUT_OF_MEM;\n\n\tISOM_DECREASE_SIZE(ptr, ptr->private_data_size);\n\tgf_bs_read_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err piff_pssh_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PIFFProtectionSystemHeaderBox *ptr = (GF_PIFFProtectionSystemHeaderBox *) s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\n\tgf_bs_write_data(bs, (char *) ptr->SystemID, 16);\n\tgf_bs_write_u32(bs, ptr->private_data_size);\n\tgf_bs_write_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\treturn GF_OK;\n}\n\nGF_Err piff_pssh_box_size(GF_Box *s)\n{\n\tGF_PIFFProtectionSystemHeaderBox *ptr = (GF_PIFFProtectionSystemHeaderBox*)s;\n\n\tptr->size += 24 + ptr->private_data_size;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *senc_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SampleEncryptionBox, GF_ISOM_BOX_TYPE_SENC);\n\treturn (GF_Box *)tmp;\n}\n\nvoid senc_box_del(GF_Box *s)\n{\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *)s;\n\twhile (gf_list_count(ptr->samp_aux_info)) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, 0);\n\t\tif (sai) gf_isom_cenc_samp_aux_info_del(sai);\n\t\tgf_list_rem(ptr->samp_aux_info, 0);\n\t}\n\tif (ptr->samp_aux_info) gf_list_del(ptr->samp_aux_info);\n\tgf_free(s);\n}\n\n\nu8 key_info_get_iv_size(const u8 *key_info, u32 nb_keys, u32 idx, u8 *const_iv_size, const u8 **const_iv)\n{\n\tu32 i, kpos=3;\n\tif (const_iv_size) *const_iv_size = 0;\n\tif (const_iv) *const_iv = NULL;\n\n\tfor (i=0; i<nb_keys; i++) {\n\t\tu8 civ_size=0;\n\t\tconst u8 *civ = NULL;\n\t\tu8 iv_size = key_info[kpos];\n\t\tkpos += 17;\n\t\tif (!iv_size) {\n\t\t\tciv_size = key_info[kpos];\n\t\t\tciv = key_info + kpos + 1;\n\t\t\tkpos += 1 + iv_size;\n\t\t}\n\t\tif (i+1==idx) {\n\t\t\tif (const_iv_size) *const_iv_size = civ_size;\n\t\t\tif (const_iv) *const_iv = civ;\n\t\t\treturn iv_size;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc)\n#else\nGF_Err senc_Parse(GF_BitStream *bs, GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc)\n#endif\n{\n\tGF_Err e;\n\tBool parse_failed = GF_FALSE;\n\tu32 i, count, sample_number;\n\tu32 senc_size = (u32) senc->size;\n\tu32 subs_size = 0, def_IV_size;\n\tu64 pos = gf_bs_get_position(bs);\n\tBool do_warn = GF_TRUE;\n\tBool use_multikey = GF_FALSE;\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!traf)\n\t\treturn GF_BAD_PARAM;\n#endif\n\n\t//BOX + version/flags\n\tif (senc_size<12) return GF_BAD_PARAM;\n\tsenc_size -= 12;\n\n\tif (senc->piff_type==1) {\n\t\t//UUID\n\t\tif (senc_size<16) return GF_BAD_PARAM;\n\t\tsenc_size -= 16;\n\t} else if (!senc->piff_type) {\n\t\tif (senc->version==1)\n\t\t\tuse_multikey = GF_TRUE;\n\t}\n\tif (senc->flags & 2) subs_size = 8;\n\n\tif (senc_size<4) return GF_BAD_PARAM;\n\n\tsample_number = 1;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (trak) sample_number += trak->sample_count_at_seg_start;\n#endif\n\n\tgf_bs_seek(bs, senc->bs_offset);\n\n\tcount = gf_bs_read_u32(bs);\n\tsenc_size -= 4;\n\n\tdef_IV_size = 0;\n\t//check the target size if we have one subsample\n\tif (senc_size >= count * (16 + subs_size)) {\n\t\tdef_IV_size = 16;\n\t}\n\telse if (senc_size >= count * (8 + subs_size)) {\n\t\tdef_IV_size = 8;\n\t}\n\telse if (senc_size >= count * (subs_size)) {\n\t\tdef_IV_size = 0;\n\t}\n\n\tif (!senc->samp_aux_info) senc->samp_aux_info = gf_list_new();\n\tfor (i=0; i<count; i++) {\n\t\tconst u8 *key_info=NULL;\n\t\tu32 key_info_size=0;\n\t\tBool is_encrypted;\n\t\tGF_CENCSampleAuxInfo *sai;\n\t\tu8 IV_size=0;\n\t\tu32 nb_keys = 0;\n\t\tu32 nb_bytes_subsample = 6;\n\t\tu32 nb_subs_bits = 16;\n\n\t\tGF_SAFEALLOC(sai, GF_CENCSampleAuxInfo);\n\t\tif (!sai) {\n\t\t\tgf_bs_seek(bs, pos);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tif (trak) {\n\t\t\te = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, sample_number, &is_encrypted, NULL, NULL, &key_info, &key_info_size);\n\t\t\tif (! key_info) {\n\t\t\t\tIV_size = key_info_size; //piff default\n\t\t\t\tuse_multikey = GF_FALSE;\n\t\t\t\tsenc->piff_type = 2;\n\t\t\t} else if (use_multikey) {\n\t\t\t\tnb_keys = key_info[1];\n\t\t\t\tnb_keys <<= 8;\n\t\t\t\tnb_keys |= key_info[2];\n\t\t\t\tnb_bytes_subsample = 8;\n\t\t\t\tnb_subs_bits = 32;\n\t\t\t} else {\n\t\t\t\tIV_size = key_info[3];\n\t\t\t}\n\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] could not get cenc info for sample %d: %s\\n\", sample_number, gf_error_to_string(e) ));\n\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\tif (trak->moov->mov->FragmentsFlags & GF_ISOM_FRAG_READ_DEBUG)\n\t\t\t\t\treturn GF_OK;\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t//no init movie setup (segment dump/inspaction, assume default encrypted and 16 bytes IV\n\t\telse {\n\t\t\tif (do_warn) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] no moov found, cannot get cenc default info, assuming isEncrypted, IV size %d (computed from senc size)\\n\", def_IV_size));\n\t\t\t\tdo_warn = GF_FALSE;\n\t\t\t}\n\t\t\tis_encrypted = GF_TRUE;\n\t\t\tIV_size = def_IV_size;\n\t\t}\n\t\tif (senc_size < IV_size) {\n\t\t\tparse_failed = GF_TRUE;\n\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\tbreak;\n\t\t}\n\n\t\tsample_number++;\n\n\t\t//subsample info is only signaled for encrypted samples\n\t\tif (is_encrypted) {\n\t\t\tu64 sai_start = gf_bs_get_position(bs);\n\t\t\tu32 nb_subs = 0;\n\n\t\t\tif (use_multikey) {\n\t\t\t\tu32 j;\n\t\t\t\tu32 nb_iv_init = gf_bs_read_u16(bs);\n\t\t\t\tfor (j=0; j<nb_iv_init; j++) {\n\t\t\t\t\tu32 idx = gf_bs_read_u16(bs);\n\t\t\t\t\tIV_size = key_info_get_iv_size(key_info, nb_keys, idx, NULL, NULL);\n\t\t\t\t\tif (!IV_size) {\n\t\t\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] Failed to parse SENC box, invalid SAI multikey with IV size 0\\n\" ));\n\t\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_skip_bytes(bs, IV_size);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tif (IV_size > 16) {\n\t\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isobmf] Failed to parse SENC box, invalid SAI size\\n\" ));\n\t\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\tif (IV_size) {\n\t\t\t\t\tgf_bs_skip_bytes(bs, IV_size);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (senc->flags & 0x00000002) {\n\t\t\t\tnb_subs = gf_bs_read_int(bs, nb_subs_bits);\n\t\t\t}\n\n\t\t\tsai->cenc_data_size = (u32) (gf_bs_get_position(bs) - sai_start);\n\t\t\tsai->cenc_data_size += nb_subs * nb_bytes_subsample;\n\t\t\tgf_bs_seek(bs, sai_start);\n\n\t\t\tif ((s32) senc_size < sai->cenc_data_size) {\n\t\t\t\tparse_failed = GF_TRUE;\n\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsai->cenc_data = gf_malloc(sizeof(u8) * sai->cenc_data_size);\n\t\t\tif (!sai->cenc_data) {\n\t\t\t\tgf_isom_cenc_samp_aux_info_del(sai);\n\t\t\t\tgf_bs_seek(bs, pos);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tgf_bs_read_data(bs, sai->cenc_data, sai->cenc_data_size);\n\t\t\tsenc_size -= sai->cenc_data_size;\n\t\t} else {\n\t\t\ti--;\n\t\t\tsai->isNotProtected = 1;\n\t\t}\n\n\t\tif (senc->internal_4cc == GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tsai->key_info_size = IV_size;\n\t\t} else {\n\t\t\tsai->key_info = key_info;\n\t\t\tsai->key_info_size = key_info_size;\n\t\t}\n\t\tgf_list_add(senc->samp_aux_info, sai);\n\t}\n\tgf_bs_seek(bs, pos);\n\tif (parse_failed) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[isobmf] cannot parse senc, missing IV/crypto state\\n\"));\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err senc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\t//WARNING - PSEC (UUID) IS TYPECASTED TO SENC (FULL BOX) SO WE CANNOT USE USUAL FULL BOX FUNCTIONS\n\tptr->version = gf_bs_read_u8(bs);\n\tptr->flags = gf_bs_read_u24(bs);\n\n\tptr->bs_offset = gf_bs_get_position(bs);\n\tgf_bs_skip_bytes(bs, ptr->size);\n\tptr->size = 0;\n\tptr->load_needed = GF_TRUE;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\nGF_Err senc_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tu32 sample_count, nb_crypt_samples;\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox *) s;\n\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\t//temp patch until we cleanup the spec...\n\tnb_crypt_samples = 0;\n\tfor (i = 0; i < sample_count; i++) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\t\tif (!sai->isNotProtected) nb_crypt_samples++;\n\t}\n\tif (!nb_crypt_samples) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\t//WARNING - PSEC (UUID) IS TYPECASTED TO SENC (FULL BOX) SO WE CANNOT USE USUAL FULL BOX FUNCTIONS\n\tgf_bs_write_u8(bs, ptr->version);\n\tgf_bs_write_u24(bs, ptr->flags);\n\n\tgf_bs_write_u32(bs, nb_crypt_samples);\n\n\te = store_senc_info(ptr, bs);\n\tif (e) return e;\n\n\tfor (i = 0; i < sample_count; i++) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\t\tif (sai->isNotProtected || !sai->cenc_data_size)\n\t\t\tcontinue;\n\t\tgf_bs_write_data(bs, sai->cenc_data, sai->cenc_data_size);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err senc_box_size(GF_Box *s)\n{\n\tu32 sample_count;\n\tu32 i, nb_crypt_samples;\n\tGF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox*)s;\n\tsample_count = gf_list_count(ptr->samp_aux_info);\n\t//temp patch until we cleanup the spec...\n\tnb_crypt_samples=0;\n\tfor (i = 0; i < sample_count; i++) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\t\tif (!sai->isNotProtected) nb_crypt_samples++;\n\t}\n\n\tif (!nb_crypt_samples) {\n\t\tptr->size = 0;\n\t\treturn GF_OK;\n\t}\n\n\t//WARNING - PSEC (UUID) IS TYPECASTED TO SENC (FULL BOX) SO WE CANNOT USE USUAL FULL BOX FUNCTIONS\n\tptr->size += 4; //version and flags\n\n\tptr->size += 4; //sample count\n\tfor (i = 0; i < sample_count; i++) {\n\t\tGF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);\n\t\tif (sai->isNotProtected)\n\t\t\tcontinue;\n\t\tptr->size += sai->cenc_data_size;\n\t}\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *adkm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeDRMKeyManagementSystemBox, GF_ISOM_BOX_TYPE_ADKM);\n\ttmp->version = 1;\n\ttmp->flags = 0;\n\treturn (GF_Box *)tmp;\n}\n\nvoid adkm_box_del(GF_Box *s)\n{\n\tGF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;\n\tif (!ptr) return;\n\tgf_free(s);\n}\n\nGF_Err adkm_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_AHDR:\n\t\tBOX_FIELD_ASSIGN(header, GF_AdobeDRMHeaderBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_ADAF:\n\t\tBOX_FIELD_ASSIGN(au_format, GF_AdobeDRMAUFormatBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err adkm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err adkm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err adkm_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->au_format, &pos);\n    return GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *ahdr_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeDRMHeaderBox, GF_ISOM_BOX_TYPE_AHDR);\n\ttmp->version = 2;\n\ttmp->flags = 0;\n\treturn (GF_Box *)tmp;\n}\n\nvoid ahdr_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\n\nGF_Err ahdr_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_AdobeDRMHeaderBox *ptr = (GF_AdobeDRMHeaderBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_APRM:\n\t\tBOX_FIELD_ASSIGN(std_enc_params, GF_AdobeStdEncryptionParamsBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err ahdr_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err ahdr_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err ahdr_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_AdobeDRMHeaderBox *ptr = (GF_AdobeDRMHeaderBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->std_enc_params, &pos);\n    return GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *aprm_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeStdEncryptionParamsBox, GF_ISOM_BOX_TYPE_APRM);\n\ttmp->version = 1;\n\ttmp->flags = 0;\n\treturn (GF_Box *)tmp;\n}\n\nvoid aprm_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err aprm_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_AdobeStdEncryptionParamsBox *ptr = (GF_AdobeStdEncryptionParamsBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_AEIB:\n\t\tBOX_FIELD_ASSIGN(enc_info, GF_AdobeEncryptionInfoBox)\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AKEY:\n\t\tBOX_FIELD_ASSIGN(key_info, GF_AdobeKeyInfoBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err aprm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err aprm_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err aprm_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_AdobeStdEncryptionParamsBox *ptr = (GF_AdobeStdEncryptionParamsBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->enc_info, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->key_info, &pos);\n    return GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *aeib_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeEncryptionInfoBox, GF_ISOM_BOX_TYPE_AEIB);\n\ttmp->version = 1;\n\ttmp->flags = 0;\n\treturn (GF_Box *)tmp;\n}\n\nvoid aeib_box_del(GF_Box *s)\n{\n\tGF_AdobeEncryptionInfoBox *ptr = (GF_AdobeEncryptionInfoBox*)s;\n\tif (!ptr) return;\n\tif (ptr->enc_algo) gf_free(ptr->enc_algo);\n\tgf_free(ptr);\n}\n\nGF_Err aeib_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeEncryptionInfoBox *ptr = (GF_AdobeEncryptionInfoBox*)s;\n\tu32 len;\n\n\tlen = (u32) ptr->size - 1;\n\tif (len) {\n\t\tptr->enc_algo = (char *)gf_malloc(len*sizeof(char));\n\t\tif (!ptr->enc_algo) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->enc_algo, len);\n\t}\n\tptr->key_length = gf_bs_read_u8(bs);\n\tptr->size = 0;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err aeib_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AdobeEncryptionInfoBox *ptr = (GF_AdobeEncryptionInfoBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->enc_algo) {\n\t\tgf_bs_write_data(bs, (char *) ptr->enc_algo, (u32) strlen(ptr->enc_algo));\n\t\tgf_bs_write_u8(bs, 0); //string end\n\t}\n\tgf_bs_write_u8(bs, ptr->key_length);\n\treturn GF_OK;\n}\n\nGF_Err aeib_box_size(GF_Box *s)\n{\n\tGF_AdobeEncryptionInfoBox *ptr = (GF_AdobeEncryptionInfoBox*)s;\n\tif (ptr->enc_algo)\n\t\tptr->size += strlen(ptr->enc_algo) + 1;\n\tptr->size += 1; //KeyLength\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *akey_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeKeyInfoBox, GF_ISOM_BOX_TYPE_AKEY);\n\ttmp->version = 1;\n\ttmp->flags = 0;\n\treturn (GF_Box *)tmp;\n}\n\nvoid akey_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err akey_on_child_box(GF_Box *s, GF_Box *a, Bool is_rem)\n{\n\tGF_AdobeKeyInfoBox *ptr = (GF_AdobeKeyInfoBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_FLXS:\n\t\tBOX_FIELD_ASSIGN(params, GF_AdobeFlashAccessParamsBox)\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err akey_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\nGF_Err akey_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}\n\nGF_Err akey_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_AdobeKeyInfoBox *ptr = (GF_AdobeKeyInfoBox *)s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->params, &pos);\n    return GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *flxs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFlashAccessParamsBox, GF_ISOM_BOX_TYPE_FLXS);\n\treturn (GF_Box *)tmp;\n}\n\nvoid flxs_box_del(GF_Box *s)\n{\n\tGF_AdobeFlashAccessParamsBox *ptr = (GF_AdobeFlashAccessParamsBox*)s;\n\tif (!ptr) return;\n\tif (ptr->metadata)\n\t\tgf_free(ptr->metadata);\n\tgf_free(ptr);\n}\n\nGF_Err flxs_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeFlashAccessParamsBox *ptr = (GF_AdobeFlashAccessParamsBox*)s;\n\tu32 len;\n\n\tlen = (u32) ptr->size;\n\tif (len) {\n\t\tptr->metadata = (char *)gf_malloc(len*sizeof(char));\n\t\tif (!ptr->metadata) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->metadata, len);\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err flxs_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AdobeFlashAccessParamsBox *ptr = (GF_AdobeFlashAccessParamsBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tif (ptr->metadata) {\n\t\tgf_bs_write_data(bs, ptr->metadata, (u32) strlen(ptr->metadata));\n\t\tgf_bs_write_u8(bs, 0); //string end\n\t}\n\treturn GF_OK;\n}\n\nGF_Err flxs_box_size(GF_Box *s)\n{\n\tGF_AdobeFlashAccessParamsBox *ptr = (GF_AdobeFlashAccessParamsBox*)s;\n\tif (ptr->metadata)\n\t\tptr->size += strlen(ptr->metadata) + 1;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\nGF_Box *adaf_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeDRMAUFormatBox, GF_ISOM_BOX_TYPE_ADAF);\n\treturn (GF_Box *)tmp;\n}\n\nvoid adaf_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}\n\nGF_Err adaf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_AdobeDRMAUFormatBox *ptr = (GF_AdobeDRMAUFormatBox*)s;\n\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tptr->selective_enc = gf_bs_read_u8(bs);\n\tgf_bs_read_u8(bs);//resersed\n\tptr->IV_length = gf_bs_read_u8(bs);\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err adaf_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AdobeDRMAUFormatBox *ptr = (GF_AdobeDRMAUFormatBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\n\tgf_bs_write_u8(bs, ptr->selective_enc);\n\tgf_bs_write_u8(bs, 0x0);\n\tgf_bs_write_u8(bs, ptr->IV_length);\n\treturn GF_OK;\n}\n\nGF_Err adaf_box_size(GF_Box *s)\n{\n\tGF_AdobeDRMAUFormatBox *ptr = (GF_AdobeDRMAUFormatBox*)s;\n\tptr->size += 3;\n\treturn GF_OK;\n}\n#endif //GPAC_DISABLE_ISOM_WRITE\n\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/box_code_drm.c"], "buggy_code_start_loc": [878], "buggy_code_end_loc": [879], "fixing_code_start_loc": [879], "fixing_code_end_loc": [889], "type": "CWE-787", "message": "Buffer overflow in the tenc_box_read function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file, related invalid IV sizes.", "other": {"cve": {"id": "CVE-2021-31254", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-19T19:15:18.077", "lastModified": "2021-04-22T00:13:44.613", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Buffer overflow in the tenc_box_read function in MP4Box in GPAC 1.0.1 allows attackers to cause a denial of service or execute arbitrary code via a crafted file, related invalid IV sizes."}, {"lang": "es", "value": "Un desbordamiento de b\u00fafer en la funci\u00f3n tenc_box_read en MP4Box en GPAC versi\u00f3n 1.0.1, permite a atacantes causar una denegaci\u00f3n de servicio o ejecutar c\u00f3digo arbitrario por medio de un archivo dise\u00f1ado, relacionado tama\u00f1os IV no v\u00e1lidos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/8986422c21fbd9a7bf6561cae65aae42077447e8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1703", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/8986422c21fbd9a7bf6561cae65aae42077447e8"}}