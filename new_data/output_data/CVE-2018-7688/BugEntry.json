{"buggy_code": ["require 'api_exception'\n\nclass Review < ApplicationRecord\n  class NotFoundError < APIException\n    setup 'review_not_found', 404, 'Review not found'\n  end\n\n  VALID_REVIEW_STATES = [:new, :declined, :accepted, :superseded, :obsoleted].freeze\n\n  belongs_to :bs_request, touch: true\n  has_many :history_elements, -> { order(:created_at) }, class_name: 'HistoryElement::Review', foreign_key: :op_object_id\n  has_many :history_elements_assigned, class_name: 'HistoryElement::ReviewAssigned', foreign_key: :op_object_id\n  validates :state, inclusion: { in: VALID_REVIEW_STATES }\n\n  validates :by_user, length: { maximum: 250 }\n  validates :by_group, length: { maximum: 250 }\n  validates :by_project, length: { maximum: 250 }\n  validates :by_package, length: { maximum: 250 }\n  validates :reviewer, length: { maximum: 250 }\n  validates :reason, length: { maximum: 65_534 }\n\n  validate :check_initial, on: [:create]\n  # Validate the review is not assigned to a review which is already assigned to this review\n  validate :validate_non_symmetric_assignment\n  validate :validate_not_self_assigned\n\n  belongs_to :user\n  belongs_to :group\n  belongs_to :project\n  belongs_to :package\n\n  belongs_to :review_assigned_from, class_name: 'Review', foreign_key: :review_id\n  has_one :review_assigned_to, class_name: 'Review', foreign_key: :review_id\n\n  scope :assigned, lambda {\n    left_outer_joins(:history_elements_assigned).having('COUNT(history_elements.id) > 0').group('reviews.id')\n  }\n\n  scope :unassigned, lambda {\n    left_outer_joins(:history_elements_assigned).having('COUNT(history_elements.id) = 0').group('reviews.id')\n  }\n\n  scope :bs_request_ids_of_involved_projects, ->(project_ids) { where(project_id: project_ids, state: :new).select(:bs_request_id) }\n  scope :bs_request_ids_of_involved_packages, ->(package_ids) { where(package_id: package_ids, state: :new).select(:bs_request_id) }\n  scope :bs_request_ids_of_involved_groups, ->(group_ids) { where(group_id: group_ids, state: :new).select(:bs_request_id) }\n  scope :bs_request_ids_of_involved_users, ->(user_ids) { where(user_id: user_ids).select(:bs_request_id) }\n\n  before_validation(on: :create) do\n    self.state = :new if self[:state].nil?\n  end\n\n  before_validation :set_reviewable_association\n  after_commit :update_cache\n\n  def validate_non_symmetric_assignment\n    return unless review_assigned_from && review_assigned_from == review_assigned_to\n\n    errors.add(\n      :review_id,\n      'assigned to review which is already assigned to this review'\n    )\n  end\n\n  def validate_not_self_assigned\n    return unless persisted? && id == review_id\n    errors.add(:review_id, 'recursive assignment')\n  end\n\n  def state\n    self[:state].to_sym\n  end\n\n  def accepted_at\n    if review_assigned_to && review_assigned_to.state == :accepted\n      review_assigned_to.accepted_history_element.created_at\n    elsif state == :accepted && !review_assigned_to\n      accepted_history_element.created_at\n    end\n  end\n\n  def declined_at\n    if review_assigned_to && review_assigned_to.state == :declined\n      review_assigned_to.declined_history_element.created_at\n    elsif state == :declined && !review_assigned_to\n      declined_history_element.created_at\n    end\n  end\n\n  def accepted_history_element\n    history_elements.find_by(type: 'HistoryElement::ReviewAccepted')\n  end\n\n  def declined_history_element\n    history_elements.find_by(type: 'HistoryElement::ReviewDeclined')\n  end\n\n  def assigned_reviewer\n    self[:reviewer] || by_user || by_group || by_project || by_package\n  end\n\n  def check_initial\n    # Validates the existence of references.\n    # NOTE: they can disappear later and the review should be still\n    #       usable to some degree (can be showed at least)\n    #       But it must not be possible to create one with broken references\n    unless by_user || by_group || by_project\n      errors.add(:unknown, 'no reviewer defined')\n    end\n\n    if validate_reviewer_fields\n      errors.add(:base, 'it is not allowed to have more than one reviewer entity: by_user, by_group, by_project, by_package')\n    end\n\n    errors.add(:by_user, \"#{by_user} not found\") if by_user && !user\n\n    errors.add(:by_group, \"#{by_group} not found\") if by_group && !group\n\n    if by_project && !project\n      # must be a local project or we can't ask\n      errors.add(:by_project, \"#{by_project} not found\")\n    end\n\n    if by_package && !by_project\n      errors.add(:unknown, 'by_package defined, but missing by_project')\n    end\n    return unless by_package && !package\n\n    # must be a local package. maybe we should rewrite in case the\n    # package comes via local project link...\n    errors.add(:by_package, \"#{by_project}/#{by_package} not found\")\n  end\n\n  def self.new_from_xml_hash(hash)\n    r = Review.new\n\n    r.state = hash.delete('state') { raise ArgumentError, 'no state' }\n    r.state = r.state.to_sym\n\n    r.by_user = hash.delete('by_user')\n    r.by_group = hash.delete('by_group')\n    r.by_project = hash.delete('by_project')\n    r.by_package = hash.delete('by_package')\n\n    r.reviewer = r.creator = hash.delete('who')\n    r.reason = hash.delete('comment')\n    begin\n      r.created_at = Time.zone.parse(hash.delete('when'))\n    rescue TypeError\n      # no valid time -> ignore\n    end\n\n    raise ArgumentError, \"too much information #{hash.inspect}\" if hash.present?\n    r\n  end\n\n  def _get_attributes\n    attributes = { state: state.to_s }\n    # old requests didn't have who and when\n    attributes[:when] = created_at.strftime('%Y-%m-%dT%H:%M:%S')\n    attributes[:who] = reviewer if reviewer\n    attributes[:by_group] = by_group if by_group\n    attributes[:by_user] = by_user if by_user\n    attributes[:by_package] = by_package if by_package\n    attributes[:by_project] = by_project if by_project\n\n    attributes\n  end\n\n  def render_xml(builder)\n    builder.review(_get_attributes) do\n      builder.comment! reason if reason\n      history_elements.each do |history|\n        history.render_xml(builder)\n      end\n    end\n  end\n\n  def webui_infos\n    ret = _get_attributes\n    # XML has this perl format, don't use that here\n    ret[:when] = created_at\n    ret\n  end\n\n  def reviewers_for_obj(obj)\n    return [] unless obj\n    relationships = obj.relationships\n    roles = relationships.where(role: Role.hashed['maintainer'])\n    User.where(id: roles.users.pluck(:user_id)) + Group.where(id: roles.groups.pluck(:group_id))\n  end\n\n  def users_and_groups_for_review\n    return [User.find_by_login!(by_user)] if by_user\n    return [Group.find_by_title!(by_group)] if by_group\n    if by_package\n      obj = Package.find_by_project_and_name(by_project, by_package)\n      return [] unless obj\n      reviewers_for_obj(obj) + reviewers_for_obj(obj.project)\n    else\n      reviewers_for_obj(Project.find_by_name(by_project))\n    end\n  end\n\n  def map_objects_to_ids(objs)\n    objs.map { |obj| { \"#{obj.class.to_s.downcase}_id\" => obj.id } }.uniq\n  end\n\n  def create_notification(params = {})\n    params = params.merge(_get_attributes)\n    params[:comment] = reason\n    params[:reviewers] = map_objects_to_ids(users_and_groups_for_review)\n\n    # send email later\n    Event::ReviewWanted.create params\n  end\n\n  def reviewable_by?(opts)\n    by_user && by_user == opts[:by_user] ||\n      by_group && by_group == opts[:by_group] ||\n      by_project && by_project == opts[:by_project] ||\n      by_package && by_package == opts[:by_package]\n  end\n\n  private\n\n  # The authoritative storage are the by_ attributes as even when a record (project, package ...) got deleted\n  # the review should still be usable, however, the entity association is nullified\n  def set_reviewable_association\n    self.package = Package.find_by_project_and_name(by_project, by_package)\n    self.project = Project.find_by_name(by_project)\n    self.user = User.find_by(login: by_user)\n    self.group = Group.find_by(title: by_group)\n  end\n\n  def validate_reviewer_fields\n    (by_user && (by_group || by_project || by_package)) || (by_group && (by_project || by_package))\n  end\n\n  def update_cache\n    # rubocop:disable Rails/SkipsModelValidations\n    # Skipping Model validations in this case is fine as we only want to touch\n    # the associated user models to invalidate the cache keys\n    if user_id\n      user_ids = [user_id]\n    elsif group_id\n      group.touch\n      user_ids = GroupsUser.where(group_id: group_id).pluck(:user_id)\n    elsif package_id\n      Group.joins(:relationships).where(relationships: { package_id: package_id }).update_all(updated_at: Time.now)\n      user_ids = Relationship.joins(:groups_users).where(package_id: package_id).groups.pluck('groups_users.user_id')\n      user_ids += Relationship.where(package_id: package_id).users.pluck(:user_id)\n    elsif project_id\n      Group.joins(:relationships).where(relationships: { project_id: project_id }).update_all(updated_at: Time.now)\n      user_ids = Relationship.joins(:groups_users).where(project_id: project_id).groups.pluck('groups_users.user_id')\n      user_ids += Relationship.where(project_id: project_id).users.pluck(:user_id)\n    end\n    User.where(id: user_ids).update_all(updated_at: Time.now)\n    # rubocop:enable Rails/SkipsModelValidations\n  end\nend\n\n# == Schema Information\n#\n# Table name: reviews\n#\n#  id            :integer          not null, primary key\n#  bs_request_id :integer          indexed\n#  creator       :string(255)      indexed\n#  reviewer      :string(255)      indexed\n#  reason        :text(65535)\n#  state         :string(255)      indexed => [by_project], indexed => [by_user]\n#  by_user       :string(255)      indexed, indexed => [state]\n#  by_group      :string(255)      indexed\n#  by_project    :string(255)      indexed => [by_package], indexed, indexed => [state]\n#  by_package    :string(255)      indexed => [by_project]\n#  created_at    :datetime         not null\n#  updated_at    :datetime         not null\n#  review_id     :integer          indexed\n#  user_id       :integer          indexed\n#  group_id      :integer          indexed\n#  project_id    :integer          indexed\n#  package_id    :integer          indexed\n#\n# Indexes\n#\n#  bs_request_id                               (bs_request_id)\n#  index_reviews_on_by_group                   (by_group)\n#  index_reviews_on_by_package_and_by_project  (by_package,by_project)\n#  index_reviews_on_by_project                 (by_project)\n#  index_reviews_on_by_user                    (by_user)\n#  index_reviews_on_creator                    (creator)\n#  index_reviews_on_group_id                   (group_id)\n#  index_reviews_on_package_id                 (package_id)\n#  index_reviews_on_project_id                 (project_id)\n#  index_reviews_on_review_id                  (review_id)\n#  index_reviews_on_reviewer                   (reviewer)\n#  index_reviews_on_state_and_by_project       (state,by_project)\n#  index_reviews_on_state_and_by_user          (state,by_user)\n#  index_reviews_on_user_id                    (user_id)\n#\n# Foreign Keys\n#\n#  fk_rails_...    (review_id => reviews.id)\n#  reviews_ibfk_1  (bs_request_id => bs_requests.id)\n#\n", "require 'rails_helper'\n\nRSpec.shared_context 'some assigned reviews and some unassigned reviews' do\n  let!(:user) { create(:user) }\n\n  let!(:review_assigned1) { create(:review, by_user: user.login) }\n  let!(:review_assigned2) { create(:review, by_user: user.login) }\n  let!(:review_unassigned1) { create(:review, by_user: user.login) }\n  let!(:review_unassigned2) { create(:review, by_user: user.login) }\n\n  let!(:history_element1) do\n    create(:history_element_review_assigned, op_object_id: review_assigned1.id, user_id: user.id)\n  end\n  let!(:history_element2) do\n    create(:history_element_review_assigned, op_object_id: review_assigned2.id, user_id: user.id)\n  end\n  let!(:history_element3) do\n    create(:history_element_review_accepted, op_object_id: review_assigned2.id, user_id: user.id)\n  end\n  let!(:history_element4) do\n    create(:history_element_review_accepted, op_object_id: review_unassigned1.id, user_id: user.id)\n  end\nend\n\nRSpec.describe Review do\n  let(:project) { create(:project_with_package, name: 'Apache', package_name: 'apache2') }\n  let(:package) { project.packages.first }\n  let(:user) { create(:user, login: 'King') }\n  let(:group) { create(:group, title: 'Staff') }\n\n  it { should belong_to(:bs_request).touch(true) }\n\n  describe 'validations' do\n    it 'is not allowed to specify by_user and any other reviewable' do\n      [:by_group, :by_project, :by_package].each do |reviewable|\n        review = Review.create(:by_user => user.login, reviewable => 'not-existent-reviewable')\n        expect(review.errors.messages[:base]).\n          to eq(['it is not allowed to have more than one reviewer entity: by_user, by_group, by_project, by_package'])\n      end\n    end\n\n    it 'is not allowed to specify by_group and any other reviewable' do\n      [:by_project, :by_package].each do |reviewable|\n        review = Review.create(:by_group => group.title, reviewable => 'not-existent-reviewable')\n        expect(review.errors.messages[:base]).\n          to eq(['it is not allowed to have more than one reviewer entity: by_user, by_group, by_project, by_package'])\n      end\n    end\n  end\n\n  describe '.assigned' do\n    include_context 'some assigned reviews and some unassigned reviews'\n\n    subject { Review.assigned }\n    it { is_expected.to match_array([review_assigned1, review_assigned2]) }\n  end\n\n  describe '.unassigned' do\n    include_context 'some assigned reviews and some unassigned reviews'\n\n    subject { Review.unassigned }\n    it { is_expected.to match_array([review_unassigned1, review_unassigned2]) }\n  end\n\n  describe '.set_associations' do\n    context 'with valid attributes' do\n      it 'sets user association when by_user object exists' do\n        review = create(:review, by_user: user.login)\n        expect(review.user).to eq(user)\n        expect(review.by_user).to eq(user.login)\n      end\n\n      it 'sets group association when by_group object exists' do\n        review = create(:review, by_group: group.title)\n        expect(review.group).to eq(group)\n        expect(review.by_group).to eq(group.title)\n      end\n\n      it 'sets project association when by_project object exists' do\n        review = create(:review, by_project: project.name)\n        expect(review.project).to eq(project)\n        expect(review.by_project).to eq(project.name)\n      end\n\n      it 'sets package and project associations when by_package and by_project object exists' do\n        review = create(:review, by_project: project.name, by_package: package.name)\n        expect(review.package).to eq(package)\n        expect(review.by_package).to eq(package.name)\n        expect(review.project).to eq(project)\n        expect(review.by_project).to eq(project.name)\n      end\n    end\n\n    context 'with invalid attributes' do\n      it 'does not set user association when by_user object does not exist' do\n        review = Review.new(by_user: 'not-existent')\n        expect(review.user).to eq(nil)\n        expect(review.valid?).to eq(false)\n      end\n\n      it 'does not set group association when by_group object does not exist' do\n        review = Review.new(by_group: 'not-existent')\n        expect(review.group).to eq(nil)\n        expect(review.valid?).to eq(false)\n      end\n\n      it 'does not set project association when by_project object does not exist' do\n        review = Review.new(by_project: 'not-existent')\n        expect(review.project).to eq(nil)\n        expect(review.valid?).to eq(false)\n      end\n\n      it 'does not set project and package associations when by_project and by_package object does not exist' do\n        review = Review.new(by_project: 'not-existent', by_package: 'not-existent')\n        expect(review.package).to eq(nil)\n        expect(review.valid?).to eq(false)\n      end\n\n      it 'does not set package association when by_project parameter is missing' do\n        review = Review.new(by_package: package.name)\n        expect(review.package).to eq(nil)\n        expect(review.valid?).to eq(false)\n      end\n    end\n  end\n\n  describe '#accepted_at' do\n    let!(:user) { create(:user) }\n    let(:review_state) { :accepted }\n    let!(:review) do\n      create(\n        :review,\n        by_user: user.login,\n        state: review_state\n      )\n    end\n    let!(:history_element_review_accepted) do\n      create(\n        :history_element_review_accepted,\n        review: review,\n        user: user,\n        created_at: Faker::Time.forward(1)\n      )\n    end\n\n    context 'with a review assigned to and assigned to state = accepted' do\n      let!(:review2) do\n        create(\n          :review,\n          by_user: user.login,\n          review_id: review.id,\n          state: :accepted\n        )\n      end\n      let!(:history_element_review_accepted2) do\n        create(\n          :history_element_review_accepted,\n          review: review2,\n          user: user,\n          created_at: Faker::Time.forward(2)\n        )\n      end\n\n      subject { review.accepted_at }\n\n      it { is_expected.to eq(history_element_review_accepted2.created_at) }\n    end\n\n    context 'with a review assigned to and assigned to state != accepted' do\n      let!(:review2) do\n        create(\n          :review,\n          by_user: user.login,\n          review_id: review.id,\n          updated_at: Faker::Time.forward(2),\n          state: :new\n        )\n      end\n\n      subject { review.accepted_at }\n\n      it { is_expected.to eq(nil) }\n    end\n\n    context 'with no reviewed assigned to and state = accepted' do\n      subject { review.accepted_at }\n\n      it { is_expected.to eq(history_element_review_accepted.created_at) }\n    end\n\n    context 'with no reviewed assigned to and state != accepted' do\n      let(:review_state) { :new }\n\n      subject { review.accepted_at }\n\n      it { is_expected.to eq(nil) }\n    end\n  end\n\n  describe '#declined_at' do\n    let!(:user) { create(:user) }\n    let(:review_state) { :declined }\n    let!(:review) do\n      create(\n        :review,\n        by_user: user.login,\n        state: review_state\n      )\n    end\n    let!(:history_element_review_declined) do\n      create(\n        :history_element_review_declined,\n        review: review,\n        user: user,\n        created_at: Faker::Time.forward(1)\n      )\n    end\n\n    context 'with a review assigned to and assigned to state = declined' do\n      let!(:review2) do\n        create(\n          :review,\n          by_user: user.login,\n          review_id: review.id,\n          state: :declined\n        )\n      end\n      let!(:history_element_review_declined2) do\n        create(\n          :history_element_review_declined,\n          review: review2,\n          user: user,\n          created_at: Faker::Time.forward(2)\n        )\n      end\n\n      subject { review.declined_at }\n\n      it { is_expected.to eq(history_element_review_declined2.created_at) }\n    end\n\n    context 'with a review assigned to and assigned to state != declined' do\n      let!(:review2) do\n        create(\n          :review,\n          by_user: user.login,\n          review_id: review.id,\n          updated_at: Faker::Time.forward(2),\n          state: :new\n        )\n      end\n\n      subject { review.declined_at }\n\n      it { is_expected.to eq(nil) }\n    end\n\n    context 'with no reviewed assigned to and state = declined' do\n      subject { review.declined_at }\n\n      it { is_expected.to eq(history_element_review_declined.created_at) }\n    end\n\n    context 'with no reviewed assigned to and state != declined' do\n      let(:review_state) { :new }\n\n      subject { review.declined_at }\n\n      it { is_expected.to eq(nil) }\n    end\n  end\n\n  describe '#validate_not_self_assigned' do\n    let!(:user) { create(:user) }\n    let!(:review) { create(:review, by_user: user.login) }\n\n    context 'assigned to itself' do\n      before { review.review_id = review.id }\n\n      subject! { review.valid? }\n\n      it { expect(review.errors[:review_id].count).to eq(1) }\n    end\n\n    context 'assigned to a different review' do\n      let!(:review2) { create(:review, by_user: user.login) }\n\n      before { review.review_id = review2.id }\n\n      subject! { review.valid? }\n\n      it { expect(review.errors[:review_id].count).to eq(0) }\n    end\n  end\n\n  describe '#validate_non_symmetric_assignment' do\n    let!(:user) { create(:user) }\n    let!(:review) { create(:review, by_user: user.login) }\n    let!(:review2) { create(:review, by_user: user.login, review_id: review.id) }\n\n    context 'review1 is assigned to review2 which is already assigned to review1' do\n      before { review.review_id = review2.id }\n\n      subject! { review.valid? }\n\n      it { expect(review.errors[:review_id].count).to eq(1) }\n    end\n\n    context 'review1 is assigned to review3' do\n      let!(:review3) { create(:review, by_user: user.login) }\n\n      before { review.review_id = review3.id }\n\n      subject! { review.valid? }\n\n      it { expect(review.errors[:review_id].count).to eq(0) }\n    end\n  end\n\n  describe '#update_caches' do\n    RSpec.shared_examples \"the subject's cache is reset when it's review changes\" do\n      before do\n        Timecop.travel(1.minute)\n        @cache_key = subject.cache_key\n        review.state = :accepted\n        review.save\n        subject.reload\n      end\n\n      it { expect(subject.cache_key).not_to eq(@cache_key) }\n    end\n\n    context 'by_user' do\n      let!(:review) { create(:user_review) }\n      subject { review.user }\n\n      it_should_behave_like \"the subject's cache is reset when it's review changes\"\n    end\n\n    context 'by_group' do\n      let(:groups_user) { create(:groups_user) }\n      let(:group) { groups_user.group }\n      let(:user) { groups_user.user }\n      let!(:review) { create(:review, by_group: group) }\n\n      it_should_behave_like \"the subject's cache is reset when it's review changes\" do\n        subject { user }\n      end\n      it_should_behave_like \"the subject's cache is reset when it's review changes\" do\n        subject { group }\n      end\n    end\n\n    context 'by_package with a direct relationship' do\n      let(:relationship_package_user) { create(:relationship_package_user) }\n      let(:package) { relationship_package_user.package }\n      let!(:review) { create(:review, by_package: package, by_project: package.project) }\n      subject { relationship_package_user.user }\n\n      it_should_behave_like \"the subject's cache is reset when it's review changes\"\n    end\n\n    context 'by_package with a group relationship' do\n      let(:relationship_package_group) { create(:relationship_package_group) }\n      let(:package) { relationship_package_group.package }\n      let(:group) { relationship_package_group.group }\n      let(:groups_user) { create(:groups_user, group: group) }\n      let!(:user) { groups_user.user }\n      let!(:review) { create(:review, by_package: package, by_project: package.project) }\n\n      it_should_behave_like \"the subject's cache is reset when it's review changes\" do\n        subject { user }\n      end\n      it_should_behave_like \"the subject's cache is reset when it's review changes\" do\n        subject { group }\n      end\n    end\n\n    context 'by_project with a direct relationship' do\n      let(:relationship_project_user) { create(:relationship_project_user) }\n      let(:project) { relationship_project_user.project }\n      let!(:review) { create(:review, by_project: project) }\n      subject { relationship_project_user.user }\n\n      it_should_behave_like \"the subject's cache is reset when it's review changes\"\n    end\n\n    context 'by_project with a group relationship' do\n      let(:relationship_project_group) { create(:relationship_project_group) }\n      let(:project) { relationship_project_group.project }\n      let(:group) { relationship_project_group.group }\n      let(:groups_user) { create(:groups_user, group: group) }\n      let!(:user) { groups_user.user }\n      let!(:review) { create(:review, by_project: project) }\n\n      it_should_behave_like \"the subject's cache is reset when it's review changes\" do\n        subject { user }\n      end\n      it_should_behave_like \"the subject's cache is reset when it's review changes\" do\n        subject { group }\n      end\n    end\n  end\n\n  describe '#reviewable_by?' do\n    let(:other_user)    { create(:user, login: 'bob') }\n    let(:other_group)   { create(:group, title: 'my_group') }\n    let(:other_project) { create(:project_with_package, name: 'doc:things', package_name: 'less') }\n    let(:other_package) { other_project.packages.first }\n\n    let(:review_by_user)    { create(:review, by_user:    user.login) }\n    let(:review_by_group)   { create(:review, by_group:   group.title) }\n    let(:review_by_project) { create(:review, by_project: project.name) }\n    let(:review_by_package) { create(:review, by_project: project.name, by_package: package.name) }\n\n    it 'returns true if review configuration matches provided hash' do\n      expect(review_by_user.reviewable_by?(by_user:       user.login)).to be true\n      expect(review_by_group.reviewable_by?(by_group:     group.title)).to be true\n      expect(review_by_project.reviewable_by?(by_project: project.name)).to be true\n      expect(review_by_package.reviewable_by?(by_package: package.name)).to be true\n    end\n\n    it 'returns false if review configuration does not match provided hash' do\n      expect(review_by_user.reviewable_by?(by_user:       other_user.login)).to be_falsy\n      expect(review_by_group.reviewable_by?(by_group:     other_group.title)).to be_falsy\n      expect(review_by_project.reviewable_by?(by_project: other_project.name)).to be_falsy\n      expect(review_by_package.reviewable_by?(by_package: other_package.name)).to be_falsy\n    end\n  end\nend\n", "require File.expand_path(File.dirname(__FILE__) + '/..') + '/test_helper'\n\nclass BsRequestTest < ActiveSupport::TestCase\n  fixtures :all\n\n  def setup\n    User.current = users(:Iggy)\n  end\n\n  test 'if create works' do\n    xml = '<request>\n              <action type=\"submit\">\n                <source project=\"BaseDistro\" package=\"pack2\" rev=\"1\"/>\n                <target project=\"home:tom\" package=\"pack1\"/>\n              </action>\n              <state name=\"new\" />\n          </request>'\n    req = BsRequest.new_from_xml(xml)\n    assert req.number.nil?\n    assert_equal 1, req.bs_request_actions.length\n    req.save!\n\n    User.current = users(:_nobody_)\n    req = BsRequest.new_from_xml(xml)\n    assert req.number.nil?\n    exception = assert_raise ActiveRecord::RecordInvalid do\n      req.save!\n    end\n    assert_match(/Validation failed: Creator Login _nobody_ is not an active user/, exception.message)\n  end\n\n  def test_target_maintainer\n    req = bs_requests(:missing_source_project)\n\n    assert req.is_target_maintainer?(users(:adrian))\n    assert !req.is_target_maintainer?(users(:user1))\n  end\n\n  def test_incremental_request_numbers\n    req = BsRequest.new_from_xml(load_backend_file('request/add_role'))\n    req.save!\n    req2 = BsRequest.new_from_xml(load_backend_file('request/add_role'))\n    req2.save!\n    req3 = BsRequest.new_from_xml(load_backend_file('request/add_role'))\n    req3.save!\n\n    assert_equal req.number + 1, req2.number\n    assert_equal req.number + 2, req3.number\n  end\n\n  def test_add_role\n    req = BsRequest.new_from_xml(load_backend_file('request/add_role'))\n    req.save!\n\n    wi = req.webui_infos(diffs: false)\n    assert_equal wi['number'], req.number\n    assert_equal wi['description'], ''\n    assert_equal wi['state'], :review\n    assert_equal wi['creator'].login, 'Iggy'\n    assert_equal wi['is_target_maintainer'], false\n    assert_equal wi['my_open_reviews'], []\n\n    wia = wi['actions'][0]\n    assert_equal wia[:type], :add_role\n    assert_equal wia[:tprj], 'kde4'\n    assert_equal wia[:role], 'reviewer'\n    assert_equal wia[:user], 'Iggy'\n\n    User.current = users(:fred)\n\n    wi = req.webui_infos(diffs: false)\n    assert_equal wi['id'], req.id\n    assert_equal wi['number'], req.number\n    assert_equal wi['description'], ''\n    assert_equal wi['state'], :review\n    assert_equal wi['creator'].login, 'Iggy'\n    assert_equal wi['is_target_maintainer'], true\n    assert_equal wi['my_open_reviews'], []\n\n    req.destroy\n  end\n\n  test 'change_review' do\n    req = BsRequest.new_from_xml(load_backend_file('request/add_role'))\n    req.save!\n    req.addreview(by_user: 'tom', comment: 'does it look ok?')\n    assert_raises BsRequest::InvalidReview do\n      req.change_review_state('accepted')\n    end\n    assert_raise Review::NotFoundError do\n      req.change_review_state('accepted', by_user: 'Iggy') # cheater!\n    end\n    req.change_review_state('accepted', by_user: 'tom') # he's allowed to - for some reason\n  end\n\n  def test_parse_bigger\n    xml = <<-XML.strip_heredoc\n      <request id=\"1027\" creator=\"Iggy\">\n        <action type=\"submit\">\n          <source project=\"home:Iggy\" package=\"TestPack\" rev=\"1\"/>\n          <target project=\"kde4\" package=\"mypackage\"/>\n          <options>\n            <sourceupdate>cleanup</sourceupdate>\n          </options>\n          <acceptinfo rev=\"1\" srcmd5=\"806a6e27ed7915d1bb8d8a989404fd5a\" osrcmd5=\"d41d8cd98f00b204e9800998ecf8427e\"/>\n        </action>\n        <priority>critical</priority>\n        <state name=\"review\" who=\"Iggy\" when=\"2012-11-07T21:13:12\">\n          <comment>No comment</comment>\n        </state>\n        <review state=\"new\" when=\"2017-09-01T09:11:11\" by_user=\"adrian\"/>\n        <review state=\"new\" when=\"2017-09-01T09:11:11\" by_group=\"test_group\"/>\n        <review state=\"accepted\" when=\"2012-11-07T21:13:12\" who=\"tom\" by_user=\"tom\">\n          <comment>review1</comment>\n        </review>\n        <review state=\"new\" when=\"2012-11-07T21:13:13\" who=\"tom\" by_user=\"tom\">\n          <comment>please accept</comment>\n        </review>\n        <description>Left blank</description>\n      </request>\n    XML\n    req = BsRequest.new_from_xml(xml)\n    req.save!\n    # number got increased by one\n    assert_equal 1027, req.number\n\n    newxml = req.render_xml\n    assert_equal xml, newxml\n\n    wi = req.webui_infos(diffs: false)\n    # iggy is *not* target maintainer\n    assert_equal false, wi['is_target_maintainer']\n    assert_equal wi['actions'][0], type: :submit,\n                                   sprj: 'home:Iggy',\n                                   spkg: 'TestPack',\n                                   srev: '1',\n                                   tprj: 'kde4',\n                                   tpkg: 'mypackage',\n                                   name: 'Submit TestPack'\n  end\n\n  def check_user_targets(user, *trues)\n    Backend::Test.start\n    User.current = User.find_by_login(user)\n    BsRequest.all.each do |r|\n      # puts r.render_xml\n      expect = trues.include?(r.number)\n      assert_equal expect, r.webui_infos(diffs: false)['is_target_maintainer'],\n                   \"Request #{r.number} should have #{expect} in target_maintainer for #{user}\"\n    end\n  end\n\n  test 'request ownership' do\n    check_user_targets(:Iggy, 10)\n    check_user_targets(:adrian, 1, 1000)\n  end\nend\n"], "fixing_code": ["require 'api_exception'\n\nclass Review < ApplicationRecord\n  class NotFoundError < APIException\n    setup 'review_not_found', 404, 'Review not found'\n  end\n\n  VALID_REVIEW_STATES = [:new, :declined, :accepted, :superseded, :obsoleted].freeze\n\n  belongs_to :bs_request, touch: true\n  has_many :history_elements, -> { order(:created_at) }, class_name: 'HistoryElement::Review', foreign_key: :op_object_id\n  has_many :history_elements_assigned, class_name: 'HistoryElement::ReviewAssigned', foreign_key: :op_object_id\n  validates :state, inclusion: { in: VALID_REVIEW_STATES }\n\n  validates :by_user, length: { maximum: 250 }\n  validates :by_group, length: { maximum: 250 }\n  validates :by_project, length: { maximum: 250 }\n  validates :by_package, length: { maximum: 250 }\n  validates :reviewer, length: { maximum: 250 }\n  validates :reason, length: { maximum: 65_534 }\n\n  validate :check_initial, on: [:create]\n  # Validate the review is not assigned to a review which is already assigned to this review\n  validate :validate_non_symmetric_assignment\n  validate :validate_not_self_assigned\n\n  belongs_to :user\n  belongs_to :group\n  belongs_to :project\n  belongs_to :package\n\n  belongs_to :review_assigned_from, class_name: 'Review', foreign_key: :review_id\n  has_one :review_assigned_to, class_name: 'Review', foreign_key: :review_id\n\n  scope :assigned, lambda {\n    left_outer_joins(:history_elements_assigned).having('COUNT(history_elements.id) > 0').group('reviews.id')\n  }\n\n  scope :unassigned, lambda {\n    left_outer_joins(:history_elements_assigned).having('COUNT(history_elements.id) = 0').group('reviews.id')\n  }\n\n  scope :bs_request_ids_of_involved_projects, ->(project_ids) { where(project_id: project_ids, state: :new).select(:bs_request_id) }\n  scope :bs_request_ids_of_involved_packages, ->(package_ids) { where(package_id: package_ids, state: :new).select(:bs_request_id) }\n  scope :bs_request_ids_of_involved_groups, ->(group_ids) { where(group_id: group_ids, state: :new).select(:bs_request_id) }\n  scope :bs_request_ids_of_involved_users, ->(user_ids) { where(user_id: user_ids).select(:bs_request_id) }\n\n  before_validation(on: :create) do\n    self.state = :new if self[:state].nil?\n  end\n\n  before_validation :set_reviewable_association\n  after_commit :update_cache\n\n  def validate_non_symmetric_assignment\n    return unless review_assigned_from && review_assigned_from == review_assigned_to\n\n    errors.add(\n      :review_id,\n      'assigned to review which is already assigned to this review'\n    )\n  end\n\n  def validate_not_self_assigned\n    return unless persisted? && id == review_id\n    errors.add(:review_id, 'recursive assignment')\n  end\n\n  def state\n    self[:state].to_sym\n  end\n\n  def accepted_at\n    if review_assigned_to && review_assigned_to.state == :accepted\n      review_assigned_to.accepted_history_element.created_at\n    elsif state == :accepted && !review_assigned_to\n      accepted_history_element.created_at\n    end\n  end\n\n  def declined_at\n    if review_assigned_to && review_assigned_to.state == :declined\n      review_assigned_to.declined_history_element.created_at\n    elsif state == :declined && !review_assigned_to\n      declined_history_element.created_at\n    end\n  end\n\n  def accepted_history_element\n    history_elements.find_by(type: 'HistoryElement::ReviewAccepted')\n  end\n\n  def declined_history_element\n    history_elements.find_by(type: 'HistoryElement::ReviewDeclined')\n  end\n\n  def assigned_reviewer\n    self[:reviewer] || by_user || by_group || by_project || by_package\n  end\n\n  def check_initial\n    # Validates the existence of references.\n    # NOTE: they can disappear later and the review should be still\n    #       usable to some degree (can be showed at least)\n    #       But it must not be possible to create one with broken references\n    unless by_user || by_group || by_project\n      errors.add(:unknown, 'no reviewer defined')\n    end\n\n    if validate_reviewer_fields\n      errors.add(:base, 'it is not allowed to have more than one reviewer entity: by_user, by_group, by_project, by_package')\n    end\n\n    errors.add(:by_user, \"#{by_user} not found\") if by_user && !user\n\n    errors.add(:by_group, \"#{by_group} not found\") if by_group && !group\n\n    if by_project && !project\n      # must be a local project or we can't ask\n      errors.add(:by_project, \"#{by_project} not found\")\n    end\n\n    if by_package && !by_project\n      errors.add(:unknown, 'by_package defined, but missing by_project')\n    end\n    return unless by_package && !package\n\n    # must be a local package. maybe we should rewrite in case the\n    # package comes via local project link...\n    errors.add(:by_package, \"#{by_project}/#{by_package} not found\")\n  end\n\n  def self.new_from_xml_hash(hash)\n    r = Review.new\n\n    r.state = :new\n    hash.delete('state')\n\n    r.by_user = hash.delete('by_user')\n    r.by_group = hash.delete('by_group')\n    r.by_project = hash.delete('by_project')\n    r.by_package = hash.delete('by_package')\n\n    r.reviewer = r.creator = hash.delete('who')\n    r.reason = hash.delete('comment')\n    begin\n      r.created_at = Time.zone.parse(hash.delete('when'))\n    rescue TypeError\n      # no valid time -> ignore\n    end\n\n    raise ArgumentError, \"too much information #{hash.inspect}\" if hash.present?\n    r\n  end\n\n  def _get_attributes\n    attributes = { state: state.to_s }\n    # old requests didn't have who and when\n    attributes[:when] = created_at.strftime('%Y-%m-%dT%H:%M:%S')\n    attributes[:who] = reviewer if reviewer\n    attributes[:by_group] = by_group if by_group\n    attributes[:by_user] = by_user if by_user\n    attributes[:by_package] = by_package if by_package\n    attributes[:by_project] = by_project if by_project\n\n    attributes\n  end\n\n  def render_xml(builder)\n    builder.review(_get_attributes) do\n      builder.comment! reason if reason\n      history_elements.each do |history|\n        history.render_xml(builder)\n      end\n    end\n  end\n\n  def webui_infos\n    ret = _get_attributes\n    # XML has this perl format, don't use that here\n    ret[:when] = created_at\n    ret\n  end\n\n  def reviewers_for_obj(obj)\n    return [] unless obj\n    relationships = obj.relationships\n    roles = relationships.where(role: Role.hashed['maintainer'])\n    User.where(id: roles.users.pluck(:user_id)) + Group.where(id: roles.groups.pluck(:group_id))\n  end\n\n  def users_and_groups_for_review\n    return [User.find_by_login!(by_user)] if by_user\n    return [Group.find_by_title!(by_group)] if by_group\n    if by_package\n      obj = Package.find_by_project_and_name(by_project, by_package)\n      return [] unless obj\n      reviewers_for_obj(obj) + reviewers_for_obj(obj.project)\n    else\n      reviewers_for_obj(Project.find_by_name(by_project))\n    end\n  end\n\n  def map_objects_to_ids(objs)\n    objs.map { |obj| { \"#{obj.class.to_s.downcase}_id\" => obj.id } }.uniq\n  end\n\n  def create_notification(params = {})\n    params = params.merge(_get_attributes)\n    params[:comment] = reason\n    params[:reviewers] = map_objects_to_ids(users_and_groups_for_review)\n\n    # send email later\n    Event::ReviewWanted.create params\n  end\n\n  def reviewable_by?(opts)\n    by_user && by_user == opts[:by_user] ||\n      by_group && by_group == opts[:by_group] ||\n      by_project && by_project == opts[:by_project] ||\n      by_package && by_package == opts[:by_package]\n  end\n\n  private\n\n  # The authoritative storage are the by_ attributes as even when a record (project, package ...) got deleted\n  # the review should still be usable, however, the entity association is nullified\n  def set_reviewable_association\n    self.package = Package.find_by_project_and_name(by_project, by_package)\n    self.project = Project.find_by_name(by_project)\n    self.user = User.find_by(login: by_user)\n    self.group = Group.find_by(title: by_group)\n  end\n\n  def validate_reviewer_fields\n    (by_user && (by_group || by_project || by_package)) || (by_group && (by_project || by_package))\n  end\n\n  def update_cache\n    # rubocop:disable Rails/SkipsModelValidations\n    # Skipping Model validations in this case is fine as we only want to touch\n    # the associated user models to invalidate the cache keys\n    if user_id\n      user_ids = [user_id]\n    elsif group_id\n      group.touch\n      user_ids = GroupsUser.where(group_id: group_id).pluck(:user_id)\n    elsif package_id\n      Group.joins(:relationships).where(relationships: { package_id: package_id }).update_all(updated_at: Time.now)\n      user_ids = Relationship.joins(:groups_users).where(package_id: package_id).groups.pluck('groups_users.user_id')\n      user_ids += Relationship.where(package_id: package_id).users.pluck(:user_id)\n    elsif project_id\n      Group.joins(:relationships).where(relationships: { project_id: project_id }).update_all(updated_at: Time.now)\n      user_ids = Relationship.joins(:groups_users).where(project_id: project_id).groups.pluck('groups_users.user_id')\n      user_ids += Relationship.where(project_id: project_id).users.pluck(:user_id)\n    end\n    User.where(id: user_ids).update_all(updated_at: Time.now)\n    # rubocop:enable Rails/SkipsModelValidations\n  end\nend\n\n# == Schema Information\n#\n# Table name: reviews\n#\n#  id            :integer          not null, primary key\n#  bs_request_id :integer          indexed\n#  creator       :string(255)      indexed\n#  reviewer      :string(255)      indexed\n#  reason        :text(65535)\n#  state         :string(255)      indexed => [by_project], indexed => [by_user]\n#  by_user       :string(255)      indexed, indexed => [state]\n#  by_group      :string(255)      indexed\n#  by_project    :string(255)      indexed => [by_package], indexed, indexed => [state]\n#  by_package    :string(255)      indexed => [by_project]\n#  created_at    :datetime         not null\n#  updated_at    :datetime         not null\n#  review_id     :integer          indexed\n#  user_id       :integer          indexed\n#  group_id      :integer          indexed\n#  project_id    :integer          indexed\n#  package_id    :integer          indexed\n#\n# Indexes\n#\n#  bs_request_id                               (bs_request_id)\n#  index_reviews_on_by_group                   (by_group)\n#  index_reviews_on_by_package_and_by_project  (by_package,by_project)\n#  index_reviews_on_by_project                 (by_project)\n#  index_reviews_on_by_user                    (by_user)\n#  index_reviews_on_creator                    (creator)\n#  index_reviews_on_group_id                   (group_id)\n#  index_reviews_on_package_id                 (package_id)\n#  index_reviews_on_project_id                 (project_id)\n#  index_reviews_on_review_id                  (review_id)\n#  index_reviews_on_reviewer                   (reviewer)\n#  index_reviews_on_state_and_by_project       (state,by_project)\n#  index_reviews_on_state_and_by_user          (state,by_user)\n#  index_reviews_on_user_id                    (user_id)\n#\n# Foreign Keys\n#\n#  fk_rails_...    (review_id => reviews.id)\n#  reviews_ibfk_1  (bs_request_id => bs_requests.id)\n#\n", "require 'rails_helper'\n\nRSpec.shared_context 'some assigned reviews and some unassigned reviews' do\n  let!(:user) { create(:user) }\n\n  let!(:review_assigned1) { create(:review, by_user: user.login) }\n  let!(:review_assigned2) { create(:review, by_user: user.login) }\n  let!(:review_unassigned1) { create(:review, by_user: user.login) }\n  let!(:review_unassigned2) { create(:review, by_user: user.login) }\n\n  let!(:history_element1) do\n    create(:history_element_review_assigned, op_object_id: review_assigned1.id, user_id: user.id)\n  end\n  let!(:history_element2) do\n    create(:history_element_review_assigned, op_object_id: review_assigned2.id, user_id: user.id)\n  end\n  let!(:history_element3) do\n    create(:history_element_review_accepted, op_object_id: review_assigned2.id, user_id: user.id)\n  end\n  let!(:history_element4) do\n    create(:history_element_review_accepted, op_object_id: review_unassigned1.id, user_id: user.id)\n  end\nend\n\nRSpec.describe Review do\n  let(:project) { create(:project_with_package, name: 'Apache', package_name: 'apache2') }\n  let(:package) { project.packages.first }\n  let(:user) { create(:user, login: 'King') }\n  let(:group) { create(:group, title: 'Staff') }\n\n  it { should belong_to(:bs_request).touch(true) }\n\n  describe 'validations' do\n    it 'is not allowed to specify by_user and any other reviewable' do\n      [:by_group, :by_project, :by_package].each do |reviewable|\n        review = Review.create(:by_user => user.login, reviewable => 'not-existent-reviewable')\n        expect(review.errors.messages[:base]).\n          to eq(['it is not allowed to have more than one reviewer entity: by_user, by_group, by_project, by_package'])\n      end\n    end\n\n    it 'is not allowed to specify by_group and any other reviewable' do\n      [:by_project, :by_package].each do |reviewable|\n        review = Review.create(:by_group => group.title, reviewable => 'not-existent-reviewable')\n        expect(review.errors.messages[:base]).\n          to eq(['it is not allowed to have more than one reviewer entity: by_user, by_group, by_project, by_package'])\n      end\n    end\n  end\n\n  describe '.assigned' do\n    include_context 'some assigned reviews and some unassigned reviews'\n\n    subject { Review.assigned }\n    it { is_expected.to match_array([review_assigned1, review_assigned2]) }\n  end\n\n  describe '.unassigned' do\n    include_context 'some assigned reviews and some unassigned reviews'\n\n    subject { Review.unassigned }\n    it { is_expected.to match_array([review_unassigned1, review_unassigned2]) }\n  end\n\n  describe '.set_associations' do\n    context 'with valid attributes' do\n      it 'sets user association when by_user object exists' do\n        review = create(:review, by_user: user.login)\n        expect(review.user).to eq(user)\n        expect(review.by_user).to eq(user.login)\n      end\n\n      it 'sets group association when by_group object exists' do\n        review = create(:review, by_group: group.title)\n        expect(review.group).to eq(group)\n        expect(review.by_group).to eq(group.title)\n      end\n\n      it 'sets project association when by_project object exists' do\n        review = create(:review, by_project: project.name)\n        expect(review.project).to eq(project)\n        expect(review.by_project).to eq(project.name)\n      end\n\n      it 'sets package and project associations when by_package and by_project object exists' do\n        review = create(:review, by_project: project.name, by_package: package.name)\n        expect(review.package).to eq(package)\n        expect(review.by_package).to eq(package.name)\n        expect(review.project).to eq(project)\n        expect(review.by_project).to eq(project.name)\n      end\n    end\n\n    context 'with invalid attributes' do\n      it 'does not set user association when by_user object does not exist' do\n        review = Review.new(by_user: 'not-existent')\n        expect(review.user).to eq(nil)\n        expect(review.valid?).to eq(false)\n      end\n\n      it 'does not set group association when by_group object does not exist' do\n        review = Review.new(by_group: 'not-existent')\n        expect(review.group).to eq(nil)\n        expect(review.valid?).to eq(false)\n      end\n\n      it 'does not set project association when by_project object does not exist' do\n        review = Review.new(by_project: 'not-existent')\n        expect(review.project).to eq(nil)\n        expect(review.valid?).to eq(false)\n      end\n\n      it 'does not set project and package associations when by_project and by_package object does not exist' do\n        review = Review.new(by_project: 'not-existent', by_package: 'not-existent')\n        expect(review.package).to eq(nil)\n        expect(review.valid?).to eq(false)\n      end\n\n      it 'does not set package association when by_project parameter is missing' do\n        review = Review.new(by_package: package.name)\n        expect(review.package).to eq(nil)\n        expect(review.valid?).to eq(false)\n      end\n    end\n  end\n\n  describe '#accepted_at' do\n    let!(:user) { create(:user) }\n    let(:review_state) { :accepted }\n    let!(:review) do\n      create(\n        :review,\n        by_user: user.login,\n        state: review_state\n      )\n    end\n    let!(:history_element_review_accepted) do\n      create(\n        :history_element_review_accepted,\n        review: review,\n        user: user,\n        created_at: Faker::Time.forward(1)\n      )\n    end\n\n    context 'with a review assigned to and assigned to state = accepted' do\n      let!(:review2) do\n        create(\n          :review,\n          by_user: user.login,\n          review_id: review.id,\n          state: :accepted\n        )\n      end\n      let!(:history_element_review_accepted2) do\n        create(\n          :history_element_review_accepted,\n          review: review2,\n          user: user,\n          created_at: Faker::Time.forward(2)\n        )\n      end\n\n      subject { review.accepted_at }\n\n      it { is_expected.to eq(history_element_review_accepted2.created_at) }\n    end\n\n    context 'with a review assigned to and assigned to state != accepted' do\n      let!(:review2) do\n        create(\n          :review,\n          by_user: user.login,\n          review_id: review.id,\n          updated_at: Faker::Time.forward(2),\n          state: :new\n        )\n      end\n\n      subject { review.accepted_at }\n\n      it { is_expected.to eq(nil) }\n    end\n\n    context 'with no reviewed assigned to and state = accepted' do\n      subject { review.accepted_at }\n\n      it { is_expected.to eq(history_element_review_accepted.created_at) }\n    end\n\n    context 'with no reviewed assigned to and state != accepted' do\n      let(:review_state) { :new }\n\n      subject { review.accepted_at }\n\n      it { is_expected.to eq(nil) }\n    end\n  end\n\n  describe '#declined_at' do\n    let!(:user) { create(:user) }\n    let(:review_state) { :declined }\n    let!(:review) do\n      create(\n        :review,\n        by_user: user.login,\n        state: review_state\n      )\n    end\n    let!(:history_element_review_declined) do\n      create(\n        :history_element_review_declined,\n        review: review,\n        user: user,\n        created_at: Faker::Time.forward(1)\n      )\n    end\n\n    context 'with a review assigned to and assigned to state = declined' do\n      let!(:review2) do\n        create(\n          :review,\n          by_user: user.login,\n          review_id: review.id,\n          state: :declined\n        )\n      end\n      let!(:history_element_review_declined2) do\n        create(\n          :history_element_review_declined,\n          review: review2,\n          user: user,\n          created_at: Faker::Time.forward(2)\n        )\n      end\n\n      subject { review.declined_at }\n\n      it { is_expected.to eq(history_element_review_declined2.created_at) }\n    end\n\n    context 'with a review assigned to and assigned to state != declined' do\n      let!(:review2) do\n        create(\n          :review,\n          by_user: user.login,\n          review_id: review.id,\n          updated_at: Faker::Time.forward(2),\n          state: :new\n        )\n      end\n\n      subject { review.declined_at }\n\n      it { is_expected.to eq(nil) }\n    end\n\n    context 'with no reviewed assigned to and state = declined' do\n      subject { review.declined_at }\n\n      it { is_expected.to eq(history_element_review_declined.created_at) }\n    end\n\n    context 'with no reviewed assigned to and state != declined' do\n      let(:review_state) { :new }\n\n      subject { review.declined_at }\n\n      it { is_expected.to eq(nil) }\n    end\n  end\n\n  describe '#validate_not_self_assigned' do\n    let!(:user) { create(:user) }\n    let!(:review) { create(:review, by_user: user.login) }\n\n    context 'assigned to itself' do\n      before { review.review_id = review.id }\n\n      subject! { review.valid? }\n\n      it { expect(review.errors[:review_id].count).to eq(1) }\n    end\n\n    context 'assigned to a different review' do\n      let!(:review2) { create(:review, by_user: user.login) }\n\n      before { review.review_id = review2.id }\n\n      subject! { review.valid? }\n\n      it { expect(review.errors[:review_id].count).to eq(0) }\n    end\n  end\n\n  describe '#validate_non_symmetric_assignment' do\n    let!(:user) { create(:user) }\n    let!(:review) { create(:review, by_user: user.login) }\n    let!(:review2) { create(:review, by_user: user.login, review_id: review.id) }\n\n    context 'review1 is assigned to review2 which is already assigned to review1' do\n      before { review.review_id = review2.id }\n\n      subject! { review.valid? }\n\n      it { expect(review.errors[:review_id].count).to eq(1) }\n    end\n\n    context 'review1 is assigned to review3' do\n      let!(:review3) { create(:review, by_user: user.login) }\n\n      before { review.review_id = review3.id }\n\n      subject! { review.valid? }\n\n      it { expect(review.errors[:review_id].count).to eq(0) }\n    end\n  end\n\n  describe '#update_caches' do\n    RSpec.shared_examples \"the subject's cache is reset when it's review changes\" do\n      before do\n        Timecop.travel(1.minute)\n        @cache_key = subject.cache_key\n        review.state = :accepted\n        review.save\n        subject.reload\n      end\n\n      it { expect(subject.cache_key).not_to eq(@cache_key) }\n    end\n\n    context 'by_user' do\n      let!(:review) { create(:user_review) }\n      subject { review.user }\n\n      it_should_behave_like \"the subject's cache is reset when it's review changes\"\n    end\n\n    context 'by_group' do\n      let(:groups_user) { create(:groups_user) }\n      let(:group) { groups_user.group }\n      let(:user) { groups_user.user }\n      let!(:review) { create(:review, by_group: group) }\n\n      it_should_behave_like \"the subject's cache is reset when it's review changes\" do\n        subject { user }\n      end\n      it_should_behave_like \"the subject's cache is reset when it's review changes\" do\n        subject { group }\n      end\n    end\n\n    context 'by_package with a direct relationship' do\n      let(:relationship_package_user) { create(:relationship_package_user) }\n      let(:package) { relationship_package_user.package }\n      let!(:review) { create(:review, by_package: package, by_project: package.project) }\n      subject { relationship_package_user.user }\n\n      it_should_behave_like \"the subject's cache is reset when it's review changes\"\n    end\n\n    context 'by_package with a group relationship' do\n      let(:relationship_package_group) { create(:relationship_package_group) }\n      let(:package) { relationship_package_group.package }\n      let(:group) { relationship_package_group.group }\n      let(:groups_user) { create(:groups_user, group: group) }\n      let!(:user) { groups_user.user }\n      let!(:review) { create(:review, by_package: package, by_project: package.project) }\n\n      it_should_behave_like \"the subject's cache is reset when it's review changes\" do\n        subject { user }\n      end\n      it_should_behave_like \"the subject's cache is reset when it's review changes\" do\n        subject { group }\n      end\n    end\n\n    context 'by_project with a direct relationship' do\n      let(:relationship_project_user) { create(:relationship_project_user) }\n      let(:project) { relationship_project_user.project }\n      let!(:review) { create(:review, by_project: project) }\n      subject { relationship_project_user.user }\n\n      it_should_behave_like \"the subject's cache is reset when it's review changes\"\n    end\n\n    context 'by_project with a group relationship' do\n      let(:relationship_project_group) { create(:relationship_project_group) }\n      let(:project) { relationship_project_group.project }\n      let(:group) { relationship_project_group.group }\n      let(:groups_user) { create(:groups_user, group: group) }\n      let!(:user) { groups_user.user }\n      let!(:review) { create(:review, by_project: project) }\n\n      it_should_behave_like \"the subject's cache is reset when it's review changes\" do\n        subject { user }\n      end\n      it_should_behave_like \"the subject's cache is reset when it's review changes\" do\n        subject { group }\n      end\n    end\n  end\n\n  describe '#reviewable_by?' do\n    let(:other_user)    { create(:user, login: 'bob') }\n    let(:other_group)   { create(:group, title: 'my_group') }\n    let(:other_project) { create(:project_with_package, name: 'doc:things', package_name: 'less') }\n    let(:other_package) { other_project.packages.first }\n\n    let(:review_by_user)    { create(:review, by_user:    user.login) }\n    let(:review_by_group)   { create(:review, by_group:   group.title) }\n    let(:review_by_project) { create(:review, by_project: project.name) }\n    let(:review_by_package) { create(:review, by_project: project.name, by_package: package.name) }\n\n    it 'returns true if review configuration matches provided hash' do\n      expect(review_by_user.reviewable_by?(by_user:       user.login)).to be true\n      expect(review_by_group.reviewable_by?(by_group:     group.title)).to be true\n      expect(review_by_project.reviewable_by?(by_project: project.name)).to be true\n      expect(review_by_package.reviewable_by?(by_package: package.name)).to be true\n    end\n\n    it 'returns false if review configuration does not match provided hash' do\n      expect(review_by_user.reviewable_by?(by_user:       other_user.login)).to be_falsy\n      expect(review_by_group.reviewable_by?(by_group:     other_group.title)).to be_falsy\n      expect(review_by_project.reviewable_by?(by_project: other_project.name)).to be_falsy\n      expect(review_by_package.reviewable_by?(by_package: other_package.name)).to be_falsy\n    end\n  end\n\n  describe '.new_from_xml_hash' do\n    let(:request_xml) do\n      \"<request>\n        <review state='accepted' by_user='#{user}'/>\n      </request>\"\n    end\n    let(:request_hash) { Xmlhash.parse(request_xml) }\n    let(:review_hash) { request_hash['review'] }\n\n    subject { Review.new_from_xml_hash(review_hash) }\n\n    it 'initalizes the review in state :new' do\n      expect(subject.state).to eq(:new)\n    end\n  end\nend\n", "require File.expand_path(File.dirname(__FILE__) + '/..') + '/test_helper'\n\nclass BsRequestTest < ActiveSupport::TestCase\n  fixtures :all\n\n  def setup\n    User.current = users(:Iggy)\n  end\n\n  test 'if create works' do\n    xml = '<request>\n              <action type=\"submit\">\n                <source project=\"BaseDistro\" package=\"pack2\" rev=\"1\"/>\n                <target project=\"home:tom\" package=\"pack1\"/>\n              </action>\n              <state name=\"new\" />\n          </request>'\n    req = BsRequest.new_from_xml(xml)\n    assert req.number.nil?\n    assert_equal 1, req.bs_request_actions.length\n    req.save!\n\n    User.current = users(:_nobody_)\n    req = BsRequest.new_from_xml(xml)\n    assert req.number.nil?\n    exception = assert_raise ActiveRecord::RecordInvalid do\n      req.save!\n    end\n    assert_match(/Validation failed: Creator Login _nobody_ is not an active user/, exception.message)\n  end\n\n  def test_target_maintainer\n    req = bs_requests(:missing_source_project)\n\n    assert req.is_target_maintainer?(users(:adrian))\n    assert !req.is_target_maintainer?(users(:user1))\n  end\n\n  def test_incremental_request_numbers\n    req = BsRequest.new_from_xml(load_backend_file('request/add_role'))\n    req.save!\n    req2 = BsRequest.new_from_xml(load_backend_file('request/add_role'))\n    req2.save!\n    req3 = BsRequest.new_from_xml(load_backend_file('request/add_role'))\n    req3.save!\n\n    assert_equal req.number + 1, req2.number\n    assert_equal req.number + 2, req3.number\n  end\n\n  def test_add_role\n    req = BsRequest.new_from_xml(load_backend_file('request/add_role'))\n    req.save!\n\n    wi = req.webui_infos(diffs: false)\n    assert_equal wi['number'], req.number\n    assert_equal wi['description'], ''\n    assert_equal wi['state'], :review\n    assert_equal wi['creator'].login, 'Iggy'\n    assert_equal wi['is_target_maintainer'], false\n    assert_equal wi['my_open_reviews'], []\n\n    wia = wi['actions'][0]\n    assert_equal wia[:type], :add_role\n    assert_equal wia[:tprj], 'kde4'\n    assert_equal wia[:role], 'reviewer'\n    assert_equal wia[:user], 'Iggy'\n\n    User.current = users(:fred)\n\n    wi = req.webui_infos(diffs: false)\n    assert_equal wi['id'], req.id\n    assert_equal wi['number'], req.number\n    assert_equal wi['description'], ''\n    assert_equal wi['state'], :review\n    assert_equal wi['creator'].login, 'Iggy'\n    assert_equal wi['is_target_maintainer'], true\n    assert_equal wi['my_open_reviews'], []\n\n    req.destroy\n  end\n\n  test 'change_review' do\n    req = BsRequest.new_from_xml(load_backend_file('request/add_role'))\n    req.save!\n    req.addreview(by_user: 'tom', comment: 'does it look ok?')\n    assert_raises BsRequest::InvalidReview do\n      req.change_review_state('accepted')\n    end\n    assert_raise Review::NotFoundError do\n      req.change_review_state('accepted', by_user: 'Iggy') # cheater!\n    end\n    req.change_review_state('accepted', by_user: 'tom') # he's allowed to - for some reason\n  end\n\n  def test_parse_bigger\n    xml = <<-XML.strip_heredoc\n      <request id=\"1027\" creator=\"Iggy\">\n        <action type=\"submit\">\n          <source project=\"home:Iggy\" package=\"TestPack\" rev=\"1\"/>\n          <target project=\"kde4\" package=\"mypackage\"/>\n          <options>\n            <sourceupdate>cleanup</sourceupdate>\n          </options>\n          <acceptinfo rev=\"1\" srcmd5=\"806a6e27ed7915d1bb8d8a989404fd5a\" osrcmd5=\"d41d8cd98f00b204e9800998ecf8427e\"/>\n        </action>\n        <priority>critical</priority>\n        <state name=\"review\" who=\"Iggy\" when=\"2012-11-07T21:13:12\">\n          <comment>No comment</comment>\n        </state>\n        <review state=\"new\" when=\"2017-09-01T09:11:11\" by_user=\"adrian\"/>\n        <review state=\"new\" when=\"2017-09-01T09:11:11\" by_group=\"test_group\"/>\n        <review state=\"accepted\" when=\"2012-11-07T21:13:12\" who=\"tom\" by_user=\"tom\">\n          <comment>review1</comment>\n        </review>\n        <review state=\"new\" when=\"2012-11-07T21:13:13\" who=\"tom\" by_user=\"tom\">\n          <comment>please accept</comment>\n        </review>\n        <description>Left blank</description>\n      </request>\n    XML\n    req = BsRequest.new_from_xml(xml)\n    req.save!\n    # number got increased by one\n    assert_equal 1027, req.number\n\n    newxml = req.render_xml\n    expected = <<-XML.strip_heredoc\n      <request id=\"1027\" creator=\"Iggy\">\n        <action type=\"submit\">\n          <source project=\"home:Iggy\" package=\"TestPack\" rev=\"1\"/>\n          <target project=\"kde4\" package=\"mypackage\"/>\n          <options>\n            <sourceupdate>cleanup</sourceupdate>\n          </options>\n          <acceptinfo rev=\"1\" srcmd5=\"806a6e27ed7915d1bb8d8a989404fd5a\" osrcmd5=\"d41d8cd98f00b204e9800998ecf8427e\"/>\n        </action>\n        <priority>critical</priority>\n        <state name=\"review\" who=\"Iggy\" when=\"2012-11-07T21:13:12\">\n          <comment>No comment</comment>\n        </state>\n        <review state=\"new\" when=\"2017-09-01T09:11:11\" by_user=\"adrian\"/>\n        <review state=\"new\" when=\"2017-09-01T09:11:11\" by_group=\"test_group\"/>\n        <review state=\"new\" when=\"2012-11-07T21:13:12\" who=\"tom\" by_user=\"tom\">\n          <comment>review1</comment>\n        </review>\n        <review state=\"new\" when=\"2012-11-07T21:13:13\" who=\"tom\" by_user=\"tom\">\n          <comment>please accept</comment>\n        </review>\n        <description>Left blank</description>\n      </request>\n    XML\n    assert_equal expected, newxml\n\n    wi = req.webui_infos(diffs: false)\n    # iggy is *not* target maintainer\n    assert_equal false, wi['is_target_maintainer']\n    assert_equal wi['actions'][0], type: :submit,\n                                   sprj: 'home:Iggy',\n                                   spkg: 'TestPack',\n                                   srev: '1',\n                                   tprj: 'kde4',\n                                   tpkg: 'mypackage',\n                                   name: 'Submit TestPack'\n  end\n\n  def check_user_targets(user, *trues)\n    Backend::Test.start\n    User.current = User.find_by_login(user)\n    BsRequest.all.each do |r|\n      # puts r.render_xml\n      expect = trues.include?(r.number)\n      assert_equal expect, r.webui_infos(diffs: false)['is_target_maintainer'],\n                   \"Request #{r.number} should have #{expect} in target_maintainer for #{user}\"\n    end\n  end\n\n  test 'request ownership' do\n    check_user_targets(:Iggy, 10)\n    check_user_targets(:adrian, 1, 1000)\n  end\nend\n"], "filenames": ["src/api/app/models/review.rb", "src/api/spec/models/review_spec.rb", "src/api/test/unit/bs_request_test.rb"], "buggy_code_start_loc": [136, 429, 128], "buggy_code_end_loc": [138, 429, 129], "fixing_code_start_loc": [136, 430, 128], "fixing_code_end_loc": [138, 446, 154], "type": "CWE-862", "message": "A missing permission check in the review handling of openSUSE Open Build Service before 2.9.3 allowed all authenticated users to modify sources in projects where they do not have write permissions.", "other": {"cve": {"id": "CVE-2018-7688", "sourceIdentifier": "meissner@suse.de", "published": "2018-06-07T13:29:00.287", "lastModified": "2019-10-09T23:42:28.033", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A missing permission check in the review handling of openSUSE Open Build Service before 2.9.3 allowed all authenticated users to modify sources in projects where they do not have write permissions."}, {"lang": "es", "value": "La falta de una comprobaci\u00f3n de permisos en la gesti\u00f3n de openSUSE Open Build Service en versiones anteriores a la 2.9.3 permit\u00eda que todos los usuarios autenticados modifiquen las fuentes en proyectos en los que no tienen permisos de escritura."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "meissner@suse.de", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}, {"source": "meissner@suse.de", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:open_build_service:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.9.3", "matchCriteriaId": "16419162-F255-49B2-9A11-2B8A51508438"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=CVE-2018-7688", "source": "meissner@suse.de", "tags": ["Issue Tracking"]}, {"url": "https://github.com/openSUSE/open-build-service/commit/b15cf19e9e01115f653c76ffdc8f54cd97566553", "source": "meissner@suse.de", "tags": ["Patch"]}, {"url": "https://lists.opensuse.org/opensuse-buildservice/2018-06/msg00014.html", "source": "meissner@suse.de", "tags": ["Mailing List", "Release Notes"]}]}, "github_commit_url": "https://github.com/openSUSE/open-build-service/commit/b15cf19e9e01115f653c76ffdc8f54cd97566553"}}