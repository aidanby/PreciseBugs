{"buggy_code": ["// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*- \n// vim: ts=8 sw=2 smarttab\n#ifndef CEPH_RGW_BASIC_TYPES_H\n#define CEPH_RGW_BASIC_TYPES_H\n\n#include <string>\n\n#include \"include/types.h\"\n\nstruct rgw_user {\n  std::string tenant;\n  std::string id;\n\n  rgw_user() {}\n  // cppcheck-suppress noExplicitConstructor\n  rgw_user(const std::string& s) {\n    from_str(s);\n  }\n  rgw_user(const std::string& tenant, const std::string& id)\n    : tenant(tenant),\n      id(id) {\n  }\n  rgw_user(std::string&& tenant, std::string&& id)\n    : tenant(std::move(tenant)),\n      id(std::move(id)) {\n  }\n\n  void encode(bufferlist& bl) const {\n    ENCODE_START(1, 1, bl);\n    ::encode(tenant, bl);\n    ::encode(id, bl);\n    ENCODE_FINISH(bl);\n  }\n  void decode(bufferlist::iterator& bl) {\n    DECODE_START(1, bl);\n    ::decode(tenant, bl);\n    ::decode(id, bl);\n    DECODE_FINISH(bl);\n  }\n\n  void to_str(std::string& str) const {\n    if (!tenant.empty()) {\n      str = tenant + '$' + id;\n    } else {\n      str = id;\n    }\n  }\n\n  void clear() {\n    tenant.clear();\n    id.clear();\n  }\n\n  bool empty() const {\n    return id.empty();\n  }\n\n  string to_str() const {\n    string s;\n    to_str(s);\n    return s;\n  }\n\n  void from_str(const std::string& str) {\n    size_t pos = str.find('$');\n    if (pos != std::string::npos) {\n      tenant = str.substr(0, pos);\n      id = str.substr(pos + 1);\n    } else {\n      tenant.clear();\n      id = str;\n    }\n  }\n\n  rgw_user& operator=(const string& str) {\n    from_str(str);\n    return *this;\n  }\n\n  int compare(const rgw_user& u) const {\n    int r = tenant.compare(u.tenant);\n    if (r != 0)\n      return r;\n\n    return id.compare(u.id);\n  }\n  int compare(const string& str) const {\n    rgw_user u(str);\n    return compare(u);\n  }\n\n  bool operator!=(const rgw_user& rhs) const {\n    return (compare(rhs) != 0);\n  }\n  bool operator==(const rgw_user& rhs) const {\n    return (compare(rhs) == 0);\n  }\n  bool operator<(const rgw_user& rhs) const {\n    if (tenant < rhs.tenant) {\n      return true;\n    } else if (tenant > rhs.tenant) {\n      return false;\n    }\n    return (id < rhs.id);\n  }\n};\nWRITE_CLASS_ENCODER(rgw_user)\n\n// Represents an identity. This is more wide-ranging than a\n// 'User'. Its purposes is to be matched against by an\n// IdentityApplier. The internal representation will doubtless change as\n// more types are added. We may want to expose the type enum and make\n// the member public so people can switch/case on it.\n\nnamespace rgw {\nnamespace auth {\nclass Principal {\n  enum types { User, Role, Tenant, Wildcard };\n  types t;\n  rgw_user u;\n\n  Principal(types t)\n    : t(t) {}\n\n  Principal(types t, std::string&& n, std::string i)\n    : t(t), u(std::move(n), std::move(i)) {}\n\npublic:\n\n  static Principal wildcard() {\n    return Principal(Wildcard);\n  }\n\n  static Principal user(std::string&& t, std::string&& u) {\n    return Principal(User, std::move(t), std::move(u));\n  }\n\n  static Principal role(std::string&& t, std::string&& u) {\n    return Principal(Role, std::move(t), std::move(u));\n  }\n\n  static Principal tenant(std::string&& t) {\n    return Principal(Tenant, std::move(t), {});\n  }\n\n  bool is_wildcard() const {\n    return t == Wildcard;\n  }\n\n  bool is_user() const {\n    return t == User;\n  }\n\n  bool is_role() const {\n    return t == Role;\n  }\n\n  bool is_tenant() const {\n    return t == Tenant;\n  }\n\n  const std::string& get_tenant() const {\n    ceph_assert(t != Wildcard);\n    return u.tenant;\n  }\n\n  const std::string& get_id() const {\n    ceph_assert(t != Wildcard && t != Tenant);\n    return u.id;\n  }\n\n  bool operator ==(const Principal& o) const {\n    return (t == o.t) && (u == o.u);\n  }\n\n  bool operator <(const Principal& o) const {\n    return (t < o.t) || ((t == o.t) && (u < o.u));\n  }\n};\n\nstd::ostream& operator <<(std::ostream& m, const Principal& p);\nstd::string to_string(const Principal& p);\n}\n}\n\nclass JSONObj;\n\nvoid decode_json_obj(rgw_user& val, JSONObj *obj);\nvoid encode_json(const char *name, const rgw_user& val, Formatter *f);\n\ninline ostream& operator<<(ostream& out, const rgw_user &u) {\n  string s;\n  u.to_str(s);\n  return out << s;\n}\n\n\n#endif\n", "// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-\n// vim: ts=8 sw=2 smarttab\n\n\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <utility>\n\n#include <boost/regex.hpp>\n#include <iostream>\n#include \"rapidjson/reader.h\"\n\n#include \"common/backport14.h\"\n#include \"rgw_auth.h\"\n#include <arpa/inet.h>\n#include \"rgw_iam_policy.h\"\n\nnamespace {\nconstexpr int dout_subsys = ceph_subsys_rgw;\n}\n\nusing std::bitset;\nusing std::find;\nusing std::int64_t;\nusing std::move;\nusing std::pair;\nusing std::size_t;\nusing std::string;\nusing std::stringstream;\nusing std::ostream;\nusing std::uint16_t;\nusing std::uint64_t;\nusing std::unordered_map;\n\nusing boost::container::flat_set;\nusing boost::none;\nusing boost::optional;\nusing boost::regex;\nusing boost::regex_constants::ECMAScript;\nusing boost::regex_constants::optimize;\nusing boost::regex_match;\nusing boost::smatch;\n\nusing rapidjson::BaseReaderHandler;\nusing rapidjson::UTF8;\nusing rapidjson::SizeType;\nusing rapidjson::Reader;\nusing rapidjson::kParseCommentsFlag;\nusing rapidjson::kParseNumbersAsStringsFlag;\nusing rapidjson::StringStream;\nusing rapidjson::ParseResult;\n\nusing rgw::auth::Principal;\n\nnamespace rgw {\nnamespace IAM {\n#include \"rgw_iam_policy_keywords.frag.cc\"\n\nstruct actpair {\n  const char* name;\n  const uint64_t bit;\n};\n\nnamespace {\noptional<Partition> to_partition(const smatch::value_type& p,\n\t\t\t\t bool wildcards) {\n  if (p == \"aws\") {\n    return Partition::aws;\n  } else if (p == \"aws-cn\") {\n    return Partition::aws_cn;\n  } else if (p == \"aws-us-gov\") {\n    return Partition::aws_us_gov;\n  } else if (p == \"*\" && wildcards) {\n    return Partition::wildcard;\n  } else {\n    return none;\n  }\n\n  ceph_abort();\n}\n\noptional<Service> to_service(const smatch::value_type& s,\n\t\t\t     bool wildcards) {\n  static const unordered_map<string, Service> services = {\n    { \"acm\", Service::acm },\n    { \"apigateway\", Service::apigateway },\n    { \"appstream\", Service::appstream },\n    { \"artifact\", Service::artifact },\n    { \"autoscaling\", Service::autoscaling },\n    { \"aws-marketplace\", Service::aws_marketplace },\n    { \"aws-marketplace-management\",\n      Service::aws_marketplace_management },\n    { \"aws-portal\", Service::aws_portal },\n    { \"cloudformation\", Service::cloudformation },\n    { \"cloudfront\", Service::cloudfront },\n    { \"cloudhsm\", Service::cloudhsm },\n    { \"cloudsearch\", Service::cloudsearch },\n    { \"cloudtrail\", Service::cloudtrail },\n    { \"cloudwatch\", Service::cloudwatch },\n    { \"codebuild\", Service::codebuild },\n    { \"codecommit\", Service::codecommit },\n    { \"codedeploy\", Service::codedeploy },\n    { \"codepipeline\", Service::codepipeline },\n    { \"cognito-identity\", Service::cognito_identity },\n    { \"cognito-idp\", Service::cognito_idp },\n    { \"cognito-sync\", Service::cognito_sync },\n    { \"config\", Service::config },\n    { \"datapipeline\", Service::datapipeline },\n    { \"devicefarm\", Service::devicefarm },\n    { \"directconnect\", Service::directconnect },\n    { \"dms\", Service::dms },\n    { \"ds\", Service::ds },\n    { \"dynamodb\", Service::dynamodb },\n    { \"ec2\", Service::ec2 },\n    { \"ecr\", Service::ecr },\n    { \"ecs\", Service::ecs },\n    { \"elasticache\", Service::elasticache },\n    { \"elasticbeanstalk\", Service::elasticbeanstalk },\n    { \"elasticfilesystem\", Service::elasticfilesystem },\n    { \"elasticloadbalancing\", Service::elasticloadbalancing },\n    { \"elasticmapreduce\", Service::elasticmapreduce },\n    { \"elastictranscoder\", Service::elastictranscoder },\n    { \"es\", Service::es },\n    { \"events\", Service::events },\n    { \"firehose\", Service::firehose },\n    { \"gamelift\", Service::gamelift },\n    { \"glacier\", Service::glacier },\n    { \"health\", Service::health },\n    { \"iam\", Service::iam },\n    { \"importexport\", Service::importexport },\n    { \"inspector\", Service::inspector },\n    { \"iot\", Service::iot },\n    { \"kinesis\", Service::kinesis },\n    { \"kinesisanalytics\", Service::kinesisanalytics },\n    { \"kms\", Service::kms },\n    { \"lambda\", Service::lambda },\n    { \"lightsail\", Service::lightsail },\n    { \"logs\", Service::logs },\n    { \"machinelearning\", Service::machinelearning },\n    { \"mobileanalytics\", Service::mobileanalytics },\n    { \"mobilehub\", Service::mobilehub },\n    { \"opsworks\", Service::opsworks },\n    { \"opsworks-cm\", Service::opsworks_cm },\n    { \"polly\", Service::polly },\n    { \"rds\", Service::rds },\n    { \"redshift\", Service::redshift },\n    { \"route53\", Service::route53 },\n    { \"route53domains\", Service::route53domains },\n    { \"s3\", Service::s3 },\n    { \"sdb\", Service::sdb },\n    { \"servicecatalog\", Service::servicecatalog },\n    { \"ses\", Service::ses },\n    { \"sns\", Service::sns },\n    { \"sqs\", Service::sqs },\n    { \"ssm\", Service::ssm },\n    { \"states\", Service::states },\n    { \"storagegateway\", Service::storagegateway },\n    { \"sts\", Service::sts },\n    { \"support\", Service::support },\n    { \"swf\", Service::swf },\n    { \"trustedadvisor\", Service::trustedadvisor },\n    { \"waf\", Service::waf },\n    { \"workmail\", Service::workmail },\n    { \"workspaces\", Service::workspaces }};\n\n  if (wildcards && s == \"*\") {\n    return Service::wildcard;\n  }\n\n  auto i = services.find(s);\n  if (i == services.end()) {\n    return none;\n  } else {\n    return i->second;\n  }\n}\n}\n\nARN::ARN(const rgw_obj& o)\n  : partition(Partition::aws),\n    service(Service::s3),\n    region(),\n    account(o.bucket.tenant),\n    resource(o.bucket.name)\n{\n  resource.push_back('/');\n  resource.append(o.key.name);\n}\n\nARN::ARN(const rgw_bucket& b)\n  : partition(Partition::aws),\n    service(Service::s3),\n    region(),\n    account(b.tenant),\n    resource(b.name) { }\n\nARN::ARN(const rgw_bucket& b, const string& o)\n  : partition(Partition::aws),\n    service(Service::s3),\n    region(),\n    account(b.tenant),\n    resource(b.name) {\n  resource.push_back('/');\n  resource.append(o);\n}\n\noptional<ARN> ARN::parse(const string& s, bool wildcards) {\n  static const char str_wild[] = \"arn:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)\";\n  static const regex rx_wild(str_wild,\n\t\t\t\t    sizeof(str_wild) - 1,\n\t\t\t\t    ECMAScript | optimize);\n  static const char str_no_wild[]\n    = \"arn:([^:*]*):([^:*]*):([^:*]*):([^:*]*):([^:*]*)\";\n  static const regex rx_no_wild(str_no_wild,\n\t\t\t\tsizeof(str_no_wild) - 1,\n\t\t\t\tECMAScript | optimize);\n\n  smatch match;\n\n  if ((s == \"*\") && wildcards) {\n    return ARN(Partition::wildcard, Service::wildcard, \"*\", \"*\", \"*\");\n  } else if (regex_match(s, match, wildcards ? rx_wild : rx_no_wild)) {\n    ceph_assert(match.size() == 6);\n\n    ARN a;\n    {\n      auto p = to_partition(match[1], wildcards);\n      if (!p)\n\treturn none;\n\n      a.partition = *p;\n    }\n    {\n      auto s = to_service(match[2], wildcards);\n      if (!s) {\n\treturn none;\n      }\n      a.service = *s;\n    }\n\n    a.region = match[3];\n    a.account = match[4];\n    a.resource = match[5];\n\n    return a;\n  }\n  return none;\n}\n\nstring ARN::to_string() const {\n  string s;\n\n  if (partition == Partition::aws) {\n    s.append(\"aws:\");\n  } else if (partition == Partition::aws_cn) {\n    s.append(\"aws-cn:\");\n  } else if (partition == Partition::aws_us_gov) {\n    s.append(\"aws-us-gov:\");\n  } else {\n    s.append(\"*:\");\n  }\n\n  static const unordered_map<Service, string> services = {\n    { Service::acm, \"acm\" },\n    { Service::apigateway, \"apigateway\" },\n    { Service::appstream, \"appstream\" },\n    { Service::artifact, \"artifact\" },\n    { Service::autoscaling, \"autoscaling\" },\n    { Service::aws_marketplace, \"aws-marketplace\" },\n    { Service::aws_marketplace_management, \"aws-marketplace-management\" },\n    { Service::aws_portal, \"aws-portal\" },\n    { Service::cloudformation, \"cloudformation\" },\n    { Service::cloudfront, \"cloudfront\" },\n    { Service::cloudhsm, \"cloudhsm\" },\n    { Service::cloudsearch, \"cloudsearch\" },\n    { Service::cloudtrail, \"cloudtrail\" },\n    { Service::cloudwatch, \"cloudwatch\" },\n    { Service::codebuild, \"codebuild\" },\n    { Service::codecommit, \"codecommit\" },\n    { Service::codedeploy, \"codedeploy\" },\n    { Service::codepipeline, \"codepipeline\" },\n    { Service::cognito_identity, \"cognito-identity\" },\n    { Service::cognito_idp, \"cognito-idp\" },\n    { Service::cognito_sync, \"cognito-sync\" },\n    { Service::config, \"config\" },\n    { Service::datapipeline, \"datapipeline\" },\n    { Service::devicefarm, \"devicefarm\" },\n    { Service::directconnect, \"directconnect\" },\n    { Service::dms, \"dms\" },\n    { Service::ds, \"ds\" },\n    { Service::dynamodb, \"dynamodb\" },\n    { Service::ec2, \"ec2\" },\n    { Service::ecr, \"ecr\" },\n    { Service::ecs, \"ecs\" },\n    { Service::elasticache, \"elasticache\" },\n    { Service::elasticbeanstalk, \"elasticbeanstalk\" },\n    { Service::elasticfilesystem, \"elasticfilesystem\" },\n    { Service::elasticloadbalancing, \"elasticloadbalancing\" },\n    { Service::elasticmapreduce, \"elasticmapreduce\" },\n    { Service::elastictranscoder, \"elastictranscoder\" },\n    { Service::es, \"es\" },\n    { Service::events, \"events\" },\n    { Service::firehose, \"firehose\" },\n    { Service::gamelift, \"gamelift\" },\n    { Service::glacier, \"glacier\" },\n    { Service::health, \"health\" },\n    { Service::iam, \"iam\" },\n    { Service::importexport, \"importexport\" },\n    { Service::inspector, \"inspector\" },\n    { Service::iot, \"iot\" },\n    { Service::kinesis, \"kinesis\" },\n    { Service::kinesisanalytics, \"kinesisanalytics\" },\n    { Service::kms, \"kms\" },\n    { Service::lambda, \"lambda\" },\n    { Service::lightsail, \"lightsail\" },\n    { Service::logs, \"logs\" },\n    { Service::machinelearning, \"machinelearning\" },\n    { Service::mobileanalytics, \"mobileanalytics\" },\n    { Service::mobilehub, \"mobilehub\" },\n    { Service::opsworks, \"opsworks\" },\n    { Service::opsworks_cm, \"opsworks-cm\" },\n    { Service::polly, \"polly\" },\n    { Service::rds, \"rds\" },\n    { Service::redshift, \"redshift\" },\n    { Service::route53, \"route53\" },\n    { Service::route53domains, \"route53domains\" },\n    { Service::s3, \"s3\" },\n    { Service::sdb, \"sdb\" },\n    { Service::servicecatalog, \"servicecatalog\" },\n    { Service::ses, \"ses\" },\n    { Service::sns, \"sns\" },\n    { Service::sqs, \"sqs\" },\n    { Service::ssm, \"ssm\" },\n    { Service::states, \"states\" },\n    { Service::storagegateway, \"storagegateway\" },\n    { Service::sts, \"sts\" },\n    { Service::support, \"support\" },\n    { Service::swf, \"swf\" },\n    { Service::trustedadvisor, \"trustedadvisor\" },\n    { Service::waf, \"waf\" },\n    { Service::workmail, \"workmail\" },\n    { Service::workspaces, \"workspaces\" }};\n\n  auto i = services.find(service);\n  if (i != services.end()) {\n    s.append(i->second);\n  } else {\n    s.push_back('*');\n  }\n  s.push_back(':');\n\n  s.append(region);\n  s.push_back(':');\n\n  s.append(account);\n  s.push_back(':');\n\n  s.append(resource);\n\n  return s;\n}\n\nbool operator ==(const ARN& l, const ARN& r) {\n  return ((l.partition == r.partition) &&\n\t  (l.service == r.service) &&\n\t  (l.region == r.region) &&\n\t  (l.account == r.account) &&\n\t  (l.resource == r.resource));\n}\nbool operator <(const ARN& l, const ARN& r) {\n  return ((l.partition < r.partition) ||\n\t  (l.service < r.service) ||\n\t  (l.region < r.region) ||\n\t  (l.account < r.account) ||\n\t  (l.resource < r.resource));\n}\n\n// The candidate is not allowed to have wildcards. The only way to\n// do that sanely would be to use unification rather than matching.\nbool ARN::match(const ARN& candidate) const {\n  if ((candidate.partition == Partition::wildcard) ||\n      (partition != candidate.partition && partition\n       != Partition::wildcard)) {\n    return false;\n  }\n\n  if ((candidate.service == Service::wildcard) ||\n      (service != candidate.service && service != Service::wildcard)) {\n    return false;\n  }\n\n  if (!match_policy(region, candidate.region, MATCH_POLICY_ARN)) {\n    return false;\n  }\n\n  if (!match_policy(account, candidate.account, MATCH_POLICY_ARN)) {\n    return false;\n  }\n\n  if (!match_policy(resource, candidate.resource, MATCH_POLICY_ARN)) {\n    return false;\n  }\n\n  return true;\n}\n\nstatic const actpair actpairs[] =\n{{ \"s3:AbortMultipartUpload\", s3AbortMultipartUpload },\n { \"s3:CreateBucket\", s3CreateBucket },\n { \"s3:DeleteBucketPolicy\", s3DeleteBucketPolicy },\n { \"s3:DeleteBucket\", s3DeleteBucket },\n { \"s3:DeleteBucketWebsite\", s3DeleteBucketWebsite },\n { \"s3:DeleteObject\", s3DeleteObject },\n { \"s3:DeleteObjectVersion\", s3DeleteObjectVersion },\n { \"s3:DeleteObjectTagging\", s3DeleteObjectTagging },\n { \"s3:DeleteObjectVersionTagging\", s3DeleteObjectVersionTagging },\n { \"s3:DeleteReplicationConfiguration\", s3DeleteReplicationConfiguration },\n { \"s3:GetAccelerateConfiguration\", s3GetAccelerateConfiguration },\n { \"s3:GetBucketAcl\", s3GetBucketAcl },\n { \"s3:GetBucketCORS\", s3GetBucketCORS },\n { \"s3:GetBucketLocation\", s3GetBucketLocation },\n { \"s3:GetBucketLogging\", s3GetBucketLogging },\n { \"s3:GetBucketNotification\", s3GetBucketNotification },\n { \"s3:GetBucketPolicy\", s3GetBucketPolicy },\n { \"s3:GetBucketRequestPayment\", s3GetBucketRequestPayment },\n { \"s3:GetBucketTagging\", s3GetBucketTagging },\n { \"s3:GetBucketVersioning\", s3GetBucketVersioning },\n { \"s3:GetBucketWebsite\", s3GetBucketWebsite },\n { \"s3:GetLifecycleConfiguration\", s3GetLifecycleConfiguration },\n { \"s3:GetObjectAcl\", s3GetObjectAcl },\n { \"s3:GetObject\", s3GetObject },\n { \"s3:GetObjectTorrent\", s3GetObjectTorrent },\n { \"s3:GetObjectVersionAcl\", s3GetObjectVersionAcl },\n { \"s3:GetObjectVersion\", s3GetObjectVersion },\n { \"s3:GetObjectVersionTorrent\", s3GetObjectVersionTorrent },\n { \"s3:GetObjectTagging\", s3GetObjectTagging },\n { \"s3:GetObjectVersionTagging\", s3GetObjectVersionTagging},\n { \"s3:GetReplicationConfiguration\", s3GetReplicationConfiguration },\n { \"s3:ListAllMyBuckets\", s3ListAllMyBuckets },\n { \"s3:ListBucketMultiPartUploads\", s3ListBucketMultiPartUploads },\n { \"s3:ListBucket\", s3ListBucket },\n { \"s3:ListBucketVersions\", s3ListBucketVersions },\n { \"s3:ListMultipartUploadParts\", s3ListMultipartUploadParts },\n { \"s3:PutAccelerateConfiguration\", s3PutAccelerateConfiguration },\n { \"s3:PutBucketAcl\", s3PutBucketAcl },\n { \"s3:PutBucketCORS\", s3PutBucketCORS },\n { \"s3:PutBucketLogging\", s3PutBucketLogging },\n { \"s3:PutBucketNotification\", s3PutBucketNotification },\n { \"s3:PutBucketPolicy\", s3PutBucketPolicy },\n { \"s3:PutBucketRequestPayment\", s3PutBucketRequestPayment },\n { \"s3:PutBucketTagging\", s3PutBucketTagging },\n { \"s3:PutBucketVersioning\", s3PutBucketVersioning },\n { \"s3:PutBucketWebsite\", s3PutBucketWebsite },\n { \"s3:PutLifecycleConfiguration\", s3PutLifecycleConfiguration },\n { \"s3:PutObjectAcl\",  s3PutObjectAcl },\n { \"s3:PutObject\", s3PutObject },\n { \"s3:PutObjectVersionAcl\", s3PutObjectVersionAcl },\n { \"s3:PutObjectTagging\", s3PutObjectTagging },\n { \"s3:PutObjectVersionTagging\", s3PutObjectVersionTagging },\n { \"s3:PutReplicationConfiguration\", s3PutReplicationConfiguration },\n { \"s3:RestoreObject\", s3RestoreObject }};\n\nstruct PolicyParser;\n\nconst Keyword top[1]{\"<Top>\", TokenKind::pseudo, TokenID::Top, 0, false,\n    false};\nconst Keyword cond_key[1]{\"<Condition Key>\", TokenKind::cond_key,\n    TokenID::CondKey, 0, true, false};\n\nstruct ParseState {\n  PolicyParser* pp;\n  const Keyword* w;\n\n  bool arraying = false;\n  bool objecting = false;\n  bool cond_ifexists = false;\n\n  void reset();\n\n  ParseState(PolicyParser* pp, const Keyword* w)\n    : pp(pp), w(w) {}\n\n  bool obj_start();\n\n  bool obj_end();\n\n  bool array_start() {\n    if (w->arrayable && !arraying) {\n      arraying = true;\n      return true;\n    }\n    return false;\n  }\n\n  bool array_end();\n\n  bool key(const char* s, size_t l);\n  bool do_string(CephContext* cct, const char* s, size_t l);\n  bool number(const char* str, size_t l);\n};\n\n// If this confuses you, look up the Curiously Recurring Template Pattern\nstruct PolicyParser : public BaseReaderHandler<UTF8<>, PolicyParser> {\n  keyword_hash tokens;\n  std::vector<ParseState> s;\n  CephContext* cct;\n  const string& tenant;\n  Policy& policy;\n  uint32_t v = 0;\n\n  uint32_t seen = 0;\n\n  uint32_t dex(TokenID in) const {\n    switch (in) {\n    case TokenID::Version:\n      return 0x1;\n    case TokenID::Id:\n      return 0x2;\n    case TokenID::Statement:\n      return 0x4;\n    case TokenID::Sid:\n      return 0x8;\n    case TokenID::Effect:\n      return 0x10;\n    case TokenID::Principal:\n      return 0x20;\n    case TokenID::NotPrincipal:\n      return 0x40;\n    case TokenID::Action:\n      return 0x80;\n    case TokenID::NotAction:\n      return 0x100;\n    case TokenID::Resource:\n      return 0x200;\n    case TokenID::NotResource:\n      return 0x400;\n    case TokenID::Condition:\n      return 0x800;\n    case TokenID::AWS:\n      return 0x1000;\n    case TokenID::Federated:\n      return 0x2000;\n    case TokenID::Service:\n      return 0x4000;\n    case TokenID::CanonicalUser:\n      return 0x8000;\n    default:\n      ceph_abort();\n    }\n  }\n  bool test(TokenID in) {\n    return seen & dex(in);\n  }\n  void set(TokenID in) {\n    seen |= dex(in);\n    if (dex(in) & (dex(TokenID::Sid) | dex(TokenID::Effect) |\n\t\t   dex(TokenID::Principal) | dex(TokenID::NotPrincipal) |\n\t\t   dex(TokenID::Action) | dex(TokenID::NotAction) |\n\t\t   dex(TokenID::Resource) | dex(TokenID::NotResource) |\n\t\t   dex(TokenID::Condition) | dex(TokenID::AWS) |\n\t\t   dex(TokenID::Federated) | dex(TokenID::Service) |\n\t\t   dex(TokenID::CanonicalUser))) {\n      v |= dex(in);\n    }\n  }\n  void set(std::initializer_list<TokenID> l) {\n    for (auto in : l) {\n      seen |= dex(in);\n      if (dex(in) & (dex(TokenID::Sid) | dex(TokenID::Effect) |\n\t\t     dex(TokenID::Principal) | dex(TokenID::NotPrincipal) |\n\t\t     dex(TokenID::Action) | dex(TokenID::NotAction) |\n\t\t     dex(TokenID::Resource) | dex(TokenID::NotResource) |\n\t\t     dex(TokenID::Condition) | dex(TokenID::AWS) |\n\t\t     dex(TokenID::Federated) | dex(TokenID::Service) |\n\t\t     dex(TokenID::CanonicalUser))) {\n\tv |= dex(in);\n      }\n    }\n  }\n  void reset(TokenID in) {\n    seen &= ~dex(in);\n    if (dex(in) & (dex(TokenID::Sid) | dex(TokenID::Effect) |\n\t\t   dex(TokenID::Principal) | dex(TokenID::NotPrincipal) |\n\t\t   dex(TokenID::Action) | dex(TokenID::NotAction) |\n\t\t   dex(TokenID::Resource) | dex(TokenID::NotResource) |\n\t\t   dex(TokenID::Condition) | dex(TokenID::AWS) |\n\t\t   dex(TokenID::Federated) | dex(TokenID::Service) |\n\t\t   dex(TokenID::CanonicalUser))) {\n      v &= ~dex(in);\n    }\n  }\n  void reset(std::initializer_list<TokenID> l) {\n    for (auto in : l) {\n      seen &= ~dex(in);\n      if (dex(in) & (dex(TokenID::Sid) | dex(TokenID::Effect) |\n\t\t     dex(TokenID::Principal) | dex(TokenID::NotPrincipal) |\n\t\t     dex(TokenID::Action) | dex(TokenID::NotAction) |\n\t\t     dex(TokenID::Resource) | dex(TokenID::NotResource) |\n\t\t     dex(TokenID::Condition) | dex(TokenID::AWS) |\n\t\t     dex(TokenID::Federated) | dex(TokenID::Service) |\n\t\t     dex(TokenID::CanonicalUser))) {\n\tv &= ~dex(in);\n      }\n    }\n  }\n  void reset(uint32_t& v) {\n    seen &= ~v;\n    v = 0;\n  }\n\n  PolicyParser(CephContext* cct, const string& tenant, Policy& policy)\n    : cct(cct), tenant(tenant), policy(policy) {}\n  PolicyParser(const PolicyParser& policy) = delete;\n\n  bool StartObject() {\n    if (s.empty()) {\n      s.push_back({this, top});\n      s.back().objecting = true;\n      return true;\n    }\n\n    return s.back().obj_start();\n  }\n  bool EndObject(SizeType memberCount) {\n    if (s.empty()) {\n      return false;\n    }\n    return s.back().obj_end();\n  }\n  bool Key(const char* str, SizeType length, bool copy) {\n    if (s.empty()) {\n      return false;\n    }\n    return s.back().key(str, length);\n  }\n\n  bool String(const char* str, SizeType length, bool copy) {\n    if (s.empty()) {\n      return false;\n    }\n    return s.back().do_string(cct, str, length);\n  }\n  bool RawNumber(const char* str, SizeType length, bool copy) {\n    if (s.empty()) {\n      return false;\n    }\n\n    return s.back().number(str, length);\n  }\n  bool StartArray() {\n    if (s.empty()) {\n      return false;\n    }\n\n    return s.back().array_start();\n  }\n  bool EndArray(SizeType) {\n    if (s.empty()) {\n      return false;\n    }\n\n    return s.back().array_end();\n  }\n\n  bool Default() {\n    return false;\n  }\n};\n\n\n// I really despise this misfeature of C++.\n//\nbool ParseState::obj_end() {\n  if (objecting) {\n    objecting = false;\n    if (!arraying) {\n      pp->s.pop_back();\n    } else {\n      reset();\n    }\n    return true;\n  }\n  return false;\n}\n\nbool ParseState::key(const char* s, size_t l) {\n  auto token_len = l;\n  bool ifexists = false;\n  if (w->id == TokenID::Condition && w->kind == TokenKind::statement) {\n    static constexpr char IfExists[] = \"IfExists\";\n    if (boost::algorithm::ends_with(boost::string_view{s, l}, IfExists)) {\n      ifexists = true;\n      token_len -= sizeof(IfExists)-1;\n    }\n  }\n  auto k = pp->tokens.lookup(s, token_len);\n\n  if (!k) {\n    if (w->kind == TokenKind::cond_op) {\n      auto id = w->id;\n      auto& t = pp->policy.statements.back();\n      auto c_ife =  cond_ifexists;\n      pp->s.emplace_back(pp, cond_key);\n      t.conditions.emplace_back(id, s, l, c_ife);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // If the token we're going with belongs within the condition at the\n  // top of the stack and we haven't already encountered it, push it\n  // on the stack\n  // Top\n  if ((((w->id == TokenID::Top) && (k->kind == TokenKind::top)) ||\n       // Statement\n       ((w->id == TokenID::Statement) && (k->kind == TokenKind::statement)) ||\n\n       /// Principal\n       ((w->id == TokenID::Principal || w->id == TokenID::NotPrincipal) &&\n\t(k->kind == TokenKind::princ_type))) &&\n\n      // Check that it hasn't been encountered. Note that this\n      // conjoins with the run of disjunctions above.\n      !pp->test(k->id)) {\n    pp->set(k->id);\n    pp->s.emplace_back(pp, k);\n    return true;\n  } else if ((w->id == TokenID::Condition) &&\n\t     (k->kind == TokenKind::cond_op)) {\n    pp->s.emplace_back(pp, k);\n    pp->s.back().cond_ifexists = ifexists;\n    return true;\n  }\n  return false;\n}\n\n// I should just rewrite a few helper functions to use iterators,\n// which will make all of this ever so much nicer.\nstatic optional<Principal> parse_principal(CephContext* cct, TokenID t,\n\t\t\t\t    string&& s) {\n  // Wildcard!\n  if ((t == TokenID::AWS) && (s == \"*\")) {\n    return Principal::wildcard();\n\n    // Do nothing for now.\n  } else if (t == TokenID::CanonicalUser) {\n\n    // AWS ARNs\n  } else if (t == TokenID::AWS) {\n    auto a = ARN::parse(s);\n    if (!a) {\n      if (std::none_of(s.begin(), s.end(),\n\t\t       [](const char& c) {\n\t\t\t return (c == ':') || (c == '/');\n\t\t       })) {\n\t// Since tenants are simply prefixes, there's no really good\n\t// way to see if one exists or not. So we return the thing and\n\t// let them try to match against it.\n\treturn Principal::tenant(std::move(s));\n      }\n    }\n\n    if (a->resource == \"root\") {\n      return Principal::tenant(std::move(a->account));\n    }\n\n    static const char rx_str[] = \"([^/]*)/(.*)\";\n    static const regex rx(rx_str, sizeof(rx_str) - 1,\n\t\t\t  ECMAScript | optimize);\n    smatch match;\n    if (regex_match(a->resource, match, rx)) {\n      ceph_assert(match.size() == 3);\n\n      if (match[1] == \"user\") {\n\treturn Principal::user(std::move(a->account),\n\t\t\t       match[2]);\n      }\n\n      if (match[1] == \"role\") {\n\treturn Principal::role(std::move(a->account),\n\t\t\t       match[2]);\n      }\n    }\n  }\n\n  ldout(cct, 0) << \"Supplied principal is discarded: \" << s << dendl;\n  return boost::none;\n}\n\nbool ParseState::do_string(CephContext* cct, const char* s, size_t l) {\n  auto k = pp->tokens.lookup(s, l);\n  Policy& p = pp->policy;\n  bool is_action = false;\n  bool is_validaction = false;\n  Statement* t = p.statements.empty() ? nullptr : &(p.statements.back());\n\n  // Top level!\n  if ((w->id == TokenID::Version) && k &&\n      k->kind == TokenKind::version_key) {\n    p.version = static_cast<Version>(k->specific);\n  } else if (w->id == TokenID::Id) {\n    p.id = string(s, l);\n\n    // Statement\n\n  } else if (w->id == TokenID::Sid) {\n    t->sid.emplace(s, l);\n  } else if ((w->id == TokenID::Effect) &&\n\t     k->kind == TokenKind::effect_key) {\n    t->effect = static_cast<Effect>(k->specific);\n  } else if (w->id == TokenID::Principal && s && *s == '*') {\n    t->princ.emplace(Principal::wildcard());\n  } else if (w->id == TokenID::NotPrincipal && s && *s == '*') {\n    t->noprinc.emplace(Principal::wildcard());\n  } else if ((w->id == TokenID::Action) ||\n\t     (w->id == TokenID::NotAction)) {\n    is_action = true;\n    for (auto& p : actpairs) {\n      if (match_policy({s, l}, p.name, MATCH_POLICY_ACTION)) {\n        is_validaction = true;\n\t(w->id == TokenID::Action ? t->action : t->notaction) |= p.bit;\n      }\n    }\n  } else if (w->id == TokenID::Resource || w->id == TokenID::NotResource) {\n    auto a = ARN::parse({s, l}, true);\n    // You can't specify resources for someone ELSE'S account.\n    if (a && (a->account.empty() || a->account == pp->tenant ||\n\t      a->account == \"*\")) {\n      if (a->account.empty() || a->account == \"*\")\n\ta->account = pp->tenant;\n      (w->id == TokenID::Resource ? t->resource : t->notresource)\n\t.emplace(std::move(*a));\n    }\n    else\n      ldout(cct, 0) << \"Supplied resource is discarded: \" << string(s, l)\n\t\t    << dendl;\n  } else if (w->kind == TokenKind::cond_key) {\n    auto& t = pp->policy.statements.back();\n    t.conditions.back().vals.emplace_back(s, l);\n\n    // Principals\n\n  } else if (w->kind == TokenKind::princ_type) {\n    ceph_assert(pp->s.size() > 1);\n    auto& pri = pp->s[pp->s.size() - 2].w->id == TokenID::Principal ?\n      t->princ : t->noprinc;\n\n    auto o = parse_principal(pp->cct, w->id, string(s, l));\n    if (o)\n      pri.emplace(std::move(*o));\n\n    // Failure\n\n  } else {\n    return false;\n  }\n\n  if (!arraying) {\n    pp->s.pop_back();\n  }\n\n  if (is_action && !is_validaction){\n    return false;\n  }\n\n  return true;\n}\n\nbool ParseState::number(const char* s, size_t l) {\n  // Top level!\n  if (w->kind == TokenKind::cond_key) {\n    auto& t = pp->policy.statements.back();\n    t.conditions.back().vals.emplace_back(s, l);\n\n    // Failure\n\n  } else {\n    return false;\n  }\n\n  if (!arraying) {\n    pp->s.pop_back();\n  }\n\n  return true;\n}\n\nvoid ParseState::reset() {\n  pp->reset(pp->v);\n}\n\nbool ParseState::obj_start() {\n  if (w->objectable && !objecting) {\n    objecting = true;\n    if (w->id == TokenID::Statement) {\n      pp->policy.statements.push_back({});\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n\nbool ParseState::array_end() {\n  if (arraying && !objecting) {\n    pp->s.pop_back();\n    return true;\n  }\n\n  return false;\n}\n\nostream& operator <<(ostream& m, const MaskedIP& ip) {\n  // I have a theory about why std::bitset is the way it is.\n  if (ip.v6) {\n    for (int i = 15; i >= 0; --i) {\n      uint8_t b = 0;\n      for (int j = 7; j >= 0; --j) {\n\tb |= (ip.addr[(i * 8) + j] << j);\n      }\n      m << hex << b;\n      if (i != 0) {\n\tm << \"::\";\n      }\n    }\n  } else {\n    // It involves Satan.\n    for (int i = 3; i >= 0; --i) {\n      uint8_t b = 0;\n      for (int j = 7; j >= 0; --j) {\n\tb |= (ip.addr[(i * 8) + j] << j);\n      }\n      m << b;\n      if (i != 0) {\n\tm << \".\";\n      }\n    }\n  }\n  m << \"/\" << ip.prefix;\n  // It would explain a lot\n  return m;\n}\n\nstring to_string(const MaskedIP& m) {\n  stringstream ss;\n  ss << m;\n  return ss.str();\n}\n\nbool Condition::eval(const Environment& env) const {\n  auto i = env.find(key);\n  if (op == TokenID::Null) {\n    return i == env.end() ? true : false;\n  }\n\n  if (i == env.end()) {\n    return ifexists;\n  }\n  const auto& s = i->second;\n\n  switch (op) {\n    // String!\n  case TokenID::StringEquals:\n    return orrible(std::equal_to<std::string>(), s, vals);\n\n  case TokenID::StringNotEquals:\n    return orrible(ceph::not_fn(std::equal_to<std::string>()),\n\t\t   s, vals);\n\n  case TokenID::StringEqualsIgnoreCase:\n    return orrible(ci_equal_to(), s, vals);\n\n  case TokenID::StringNotEqualsIgnoreCase:\n    return orrible(ceph::not_fn(ci_equal_to()), s, vals);\n\n  case TokenID::StringLike:\n    return orrible(string_like(), s, vals);\n\n  case TokenID::StringNotLike:\n    return orrible(ceph::not_fn(string_like()), s, vals);\n\n    // Numeric\n  case TokenID::NumericEquals:\n    return shortible(std::equal_to<double>(), as_number, s, vals);\n\n  case TokenID::NumericNotEquals:\n    return shortible(ceph::not_fn(std::equal_to<double>()),\n\t\t     as_number, s, vals);\n\n\n  case TokenID::NumericLessThan:\n    return shortible(std::less<double>(), as_number, s, vals);\n\n\n  case TokenID::NumericLessThanEquals:\n    return shortible(std::less_equal<double>(), as_number, s, vals);\n\n  case TokenID::NumericGreaterThan:\n    return shortible(std::greater<double>(), as_number, s, vals);\n\n  case TokenID::NumericGreaterThanEquals:\n    return shortible(std::greater_equal<double>(), as_number, s, vals);\n\n    // Date!\n  case TokenID::DateEquals:\n    return shortible(std::equal_to<ceph::real_time>(), as_date, s, vals);\n\n  case TokenID::DateNotEquals:\n    return shortible(ceph::not_fn(std::equal_to<ceph::real_time>()),\n\t\t     as_date, s, vals);\n\n  case TokenID::DateLessThan:\n    return shortible(std::less<ceph::real_time>(), as_date, s, vals);\n\n\n  case TokenID::DateLessThanEquals:\n    return shortible(std::less_equal<ceph::real_time>(), as_date, s, vals);\n\n  case TokenID::DateGreaterThan:\n    return shortible(std::greater<ceph::real_time>(), as_date, s, vals);\n\n  case TokenID::DateGreaterThanEquals:\n    return shortible(std::greater_equal<ceph::real_time>(), as_date, s,\n\t\t     vals);\n\n    // Bool!\n  case TokenID::Bool:\n    return shortible(std::equal_to<bool>(), as_bool, s, vals);\n\n    // Binary!\n  case TokenID::BinaryEquals:\n    return shortible(std::equal_to<ceph::bufferlist>(), as_binary, s,\n\t\t     vals);\n\n    // IP Address!\n  case TokenID::IpAddress:\n    return shortible(std::equal_to<MaskedIP>(), as_network, s, vals);\n\n  case TokenID::NotIpAddress:\n    return shortible(ceph::not_fn(std::equal_to<MaskedIP>()), as_network, s,\n\t\t     vals);\n\n#if 0\n    // Amazon Resource Names! (Does S3 need this?)\n    TokenID::ArnEquals, TokenID::ArnNotEquals, TokenID::ArnLike,\n      TokenID::ArnNotLike,\n#endif\n\n  default:\n    return false;\n  }\n}\n\noptional<MaskedIP> Condition::as_network(const string& s) {\n  MaskedIP m;\n  if (s.empty()) {\n    return none;\n  }\n\n  m.v6 = s.find(':');\n  auto slash = s.find('/');\n  if (slash == string::npos) {\n    m.prefix = m.v6 ? 128 : 32;\n  } else {\n    char* end = 0;\n    m.prefix = strtoul(s.data() + slash + 1, &end, 10);\n    if (*end != 0 || (m.v6 && m.prefix > 128) ||\n\t(!m.v6 && m.prefix > 32)) {\n      return none;\n    }\n  }\n\n  string t;\n  auto p = &s;\n\n  if (slash != string::npos) {\n    t.assign(s, 0, slash);\n    p = &t;\n  }\n\n  if (m.v6) {\n    struct sockaddr_in6 a;\n    if (inet_pton(AF_INET6, p->c_str(), static_cast<void*>(&a)) != 1) {\n      return none;\n    }\n\n    m.addr |= Address(a.sin6_addr.s6_addr[0]) << 0;\n    m.addr |= Address(a.sin6_addr.s6_addr[1]) << 8;\n    m.addr |= Address(a.sin6_addr.s6_addr[2]) << 16;\n    m.addr |= Address(a.sin6_addr.s6_addr[3]) << 24;\n    m.addr |= Address(a.sin6_addr.s6_addr[4]) << 32;\n    m.addr |= Address(a.sin6_addr.s6_addr[5]) << 40;\n    m.addr |= Address(a.sin6_addr.s6_addr[6]) << 48;\n    m.addr |= Address(a.sin6_addr.s6_addr[7]) << 56;\n    m.addr |= Address(a.sin6_addr.s6_addr[8]) << 64;\n    m.addr |= Address(a.sin6_addr.s6_addr[9]) << 72;\n    m.addr |= Address(a.sin6_addr.s6_addr[10]) << 80;\n    m.addr |= Address(a.sin6_addr.s6_addr[11]) << 88;\n    m.addr |= Address(a.sin6_addr.s6_addr[12]) << 96;\n    m.addr |= Address(a.sin6_addr.s6_addr[13]) << 104;\n    m.addr |= Address(a.sin6_addr.s6_addr[14]) << 112;\n    m.addr |= Address(a.sin6_addr.s6_addr[15]) << 120;\n  } else {\n    struct sockaddr_in a;\n    if (inet_pton(AF_INET, p->c_str(), static_cast<void*>(&a)) != 1) {\n      return none;\n    }\n    m.addr = ntohl(a.sin_addr.s_addr);\n  }\n\n  return none;\n}\n\nnamespace {\nconst char* condop_string(const TokenID t) {\n  switch (t) {\n  case TokenID::StringEquals:\n    return \"StringEquals\";\n\n  case TokenID::StringNotEquals:\n    return \"StringNotEquals\";\n\n  case TokenID::StringEqualsIgnoreCase:\n    return \"StringEqualsIgnoreCase\";\n\n  case TokenID::StringNotEqualsIgnoreCase:\n    return \"StringNotEqualsIgnoreCase\";\n\n  case TokenID::StringLike:\n    return \"StringLike\";\n\n  case TokenID::StringNotLike:\n    return \"StringNotLike\";\n\n  // Numeric!\n  case TokenID::NumericEquals:\n    return \"NumericEquals\";\n\n  case TokenID::NumericNotEquals:\n    return \"NumericNotEquals\";\n\n  case TokenID::NumericLessThan:\n    return \"NumericLessThan\";\n\n  case TokenID::NumericLessThanEquals:\n    return \"NumericLessThanEquals\";\n\n  case TokenID::NumericGreaterThan:\n    return \"NumericGreaterThan\";\n\n  case TokenID::NumericGreaterThanEquals:\n    return \"NumericGreaterThanEquals\";\n\n  case TokenID::DateEquals:\n    return \"DateEquals\";\n\n  case TokenID::DateNotEquals:\n    return \"DateNotEquals\";\n\n  case TokenID::DateLessThan:\n    return \"DateLessThan\";\n\n  case TokenID::DateLessThanEquals:\n    return \"DateLessThanEquals\";\n\n  case TokenID::DateGreaterThan:\n    return \"DateGreaterThan\";\n\n  case TokenID::DateGreaterThanEquals:\n    return \"DateGreaterThanEquals\";\n\n  case TokenID::Bool:\n    return \"Bool\";\n\n  case TokenID::BinaryEquals:\n    return \"BinaryEquals\";\n\n  case TokenID::IpAddress:\n    return \"case TokenID::IpAddress\";\n\n  case TokenID::NotIpAddress:\n    return \"NotIpAddress\";\n\n  case TokenID::ArnEquals:\n    return \"ArnEquals\";\n\n  case TokenID::ArnNotEquals:\n    return \"ArnNotEquals\";\n\n  case TokenID::ArnLike:\n    return \"ArnLike\";\n\n  case TokenID::ArnNotLike:\n    return \"ArnNotLike\";\n\n  case TokenID::Null:\n    return \"Null\";\n\n  default:\n    return \"InvalidConditionOperator\";\n  }\n}\n\ntemplate<typename Iterator>\nostream& print_array(ostream& m, Iterator begin, Iterator end) {\n  if (begin == end) {\n    m << \"[\";\n  } else {\n    auto beforelast = end - 1;\n    m << \"[ \";\n    for (auto i = begin; i != end; ++i) {\n      m << *i;\n      if (i != beforelast) {\n\tm << \", \";\n      } else {\n\tm << \" \";\n      }\n    }\n  }\n  m << \"]\";\n  return m;\n}\n}\n\nostream& operator <<(ostream& m, const Condition& c) {\n  m << \"{ \" << condop_string(c.op);\n  if (c.ifexists) {\n    m << \"IfExists\";\n  }\n  m << \": { \" << c.key;\n  print_array(m, c.vals.cbegin(), c.vals.cend());\n  return m << \"}\";\n}\n\nstring to_string(const Condition& c) {\n  stringstream ss;\n  ss << c;\n  return ss.str();\n}\n\nEffect Statement::eval(const Environment& e,\n\t\t       optional<const rgw::auth::Identity&> ida,\n\t\t       uint64_t act, const ARN& res) const {\n  if (ida && (!ida->is_identity(princ) || ida->is_identity(noprinc))) {\n    return Effect::Pass;\n  }\n\n\n  if (!std::any_of(resource.begin(), resource.end(),\n\t\t   [&res](const ARN& pattern) {\n\t\t     return pattern.match(res);\n\t\t   }) ||\n      (std::any_of(notresource.begin(), notresource.end(),\n\t\t   [&res](const ARN& pattern) {\n\t\t     return pattern.match(res);\n\t\t   }))) {\n    return Effect::Pass;\n  }\n\n  if (!(action & act) || (notaction & act)) {\n    return Effect::Pass;\n  }\n\n  if (std::all_of(conditions.begin(),\n\t\t  conditions.end(),\n\t\t  [&e](const Condition& c) { return c.eval(e);})) {\n    return effect;\n  }\n\n  return Effect::Pass;\n}\n\nnamespace {\nconst char* action_bit_string(uint64_t action) {\n  switch (action) {\n  case s3GetObject:\n    return \"s3:GetObject\";\n\n  case s3GetObjectVersion:\n    return \"s3:GetObjectVersion\";\n\n  case s3PutObject:\n    return \"s3:PutObject\";\n\n  case s3GetObjectAcl:\n    return \"s3:GetObjectAcl\";\n\n  case s3GetObjectVersionAcl:\n    return \"s3:GetObjectVersionAcl\";\n\n  case s3PutObjectAcl:\n    return \"s3:PutObjectAcl\";\n\n  case s3PutObjectVersionAcl:\n    return \"s3:PutObjectVersionAcl\";\n\n  case s3DeleteObject:\n    return \"s3:DeleteObject\";\n\n  case s3DeleteObjectVersion:\n    return \"s3:DeleteObjectVersion\";\n\n  case s3ListMultipartUploadParts:\n    return \"s3:ListMultipartUploadParts\";\n\n  case s3AbortMultipartUpload:\n    return \"s3:AbortMultipartUpload\";\n\n  case s3GetObjectTorrent:\n    return \"s3:GetObjectTorrent\";\n\n  case s3GetObjectVersionTorrent:\n    return \"s3:GetObjectVersionTorrent\";\n\n  case s3RestoreObject:\n    return \"s3:RestoreObject\";\n\n  case s3CreateBucket:\n    return \"s3:CreateBucket\";\n\n  case s3DeleteBucket:\n    return \"s3:DeleteBucket\";\n\n  case s3ListBucket:\n    return \"s3:ListBucket\";\n\n  case s3ListBucketVersions:\n    return \"s3:ListBucketVersions\";\n  case s3ListAllMyBuckets:\n    return \"s3:ListAllMyBuckets\";\n\n  case s3ListBucketMultiPartUploads:\n    return \"s3:ListBucketMultiPartUploads\";\n\n  case s3GetAccelerateConfiguration:\n    return \"s3:GetAccelerateConfiguration\";\n\n  case s3PutAccelerateConfiguration:\n    return \"s3:PutAccelerateConfiguration\";\n\n  case s3GetBucketAcl:\n    return \"s3:GetBucketAcl\";\n\n  case s3PutBucketAcl:\n    return \"s3:PutBucketAcl\";\n\n  case s3GetBucketCORS:\n    return \"s3:GetBucketCORS\";\n\n  case s3PutBucketCORS:\n    return \"s3:PutBucketCORS\";\n\n  case s3GetBucketVersioning:\n    return \"s3:GetBucketVersioning\";\n\n  case s3PutBucketVersioning:\n    return \"s3:PutBucketVersioning\";\n\n  case s3GetBucketRequestPayment:\n    return \"s3:GetBucketRequestPayment\";\n\n  case s3PutBucketRequestPayment:\n    return \"s3:PutBucketRequestPayment\";\n\n  case s3GetBucketLocation:\n    return \"s3:GetBucketLocation\";\n\n  case s3GetBucketPolicy:\n    return \"s3:GetBucketPolicy\";\n\n  case s3DeleteBucketPolicy:\n    return \"s3:DeleteBucketPolicy\";\n\n  case s3PutBucketPolicy:\n    return \"s3:PutBucketPolicy\";\n\n  case s3GetBucketNotification:\n    return \"s3:GetBucketNotification\";\n\n  case s3PutBucketNotification:\n    return \"s3:PutBucketNotification\";\n\n  case s3GetBucketLogging:\n    return \"s3:GetBucketLogging\";\n\n  case s3PutBucketLogging:\n    return \"s3:PutBucketLogging\";\n\n  case s3GetBucketTagging:\n    return \"s3:GetBucketTagging\";\n\n  case s3PutBucketTagging:\n    return \"s3:PutBucketTagging\";\n\n  case s3GetBucketWebsite:\n    return \"s3:GetBucketWebsite\";\n\n  case s3PutBucketWebsite:\n    return \"s3:PutBucketWebsite\";\n\n  case s3DeleteBucketWebsite:\n    return \"s3:DeleteBucketWebsite\";\n\n  case s3GetLifecycleConfiguration:\n    return \"s3:GetLifecycleConfiguration\";\n\n  case s3PutLifecycleConfiguration:\n    return \"s3:PutLifecycleConfiguration\";\n\n  case s3PutReplicationConfiguration:\n    return \"s3:PutReplicationConfiguration\";\n\n  case s3GetReplicationConfiguration:\n    return \"s3:GetReplicationConfiguration\";\n\n  case s3DeleteReplicationConfiguration:\n    return \"s3:DeleteReplicationConfiguration\";\n\n  case s3PutObjectTagging:\n    return \"s3:PutObjectTagging\";\n\n  case s3PutObjectVersionTagging:\n    return \"s3:PutObjectVersionTagging\";\n\n  case s3GetObjectTagging:\n    return \"s3:GetObjectTagging\";\n\n  case s3GetObjectVersionTagging:\n    return \"s3:GetObjectVersionTagging\";\n\n  case s3DeleteObjectTagging:\n    return \"s3:DeleteObjectTagging\";\n\n  case s3DeleteObjectVersionTagging:\n    return \"s3:DeleteObjectVersionTagging\";\n  }\n  return \"s3Invalid\";\n}\n\nostream& print_actions(ostream& m, const uint64_t a) {\n  bool begun = false;\n  m << \"[ \";\n  for (auto i = 0U; i < s3Count; ++i) {\n    if (a & (1 << i)) {\n      if (begun) {\n\tm << \", \";\n      } else {\n\tbegun = true;\n      }\n      m << action_bit_string(1 << i);\n    }\n  }\n  if (begun) {\n    m << \" ]\";\n  } else {\n    m << \"]\";\n  }\n  return m;\n}\n}\n\nostream& operator <<(ostream& m, const Statement& s) {\n  m << \"{ \";\n  if (s.sid) {\n    m << \"Sid: \" << *s.sid << \", \";\n  }\n  if (!s.princ.empty()) {\n    m << \"Principal: \";\n    print_array(m, s.princ.cbegin(), s.princ.cend());\n    m << \", \";\n  }\n  if (!s.noprinc.empty()) {\n    m << \"NotPrincipal: \";\n    print_array(m, s.noprinc.cbegin(), s.noprinc.cend());\n    m << \", \";\n  }\n\n  m << \"Effect: \" <<\n    (s.effect == Effect::Allow ?\n     (const char*) \"Allow\" :\n     (const char*) \"Deny\");\n\n  if (s.action || s.notaction || !s.resource.empty() ||\n      !s.notresource.empty() || !s.conditions.empty()) {\n    m << \", \";\n  }\n\n  if (s.action) {\n    m << \"Action: \";\n    print_actions(m, s.action);\n\n    if (s.notaction || !s.resource.empty() ||\n\t!s.notresource.empty() || !s.conditions.empty()) {\n      m << \", \";\n    }\n  }\n\n  if (s.notaction) {\n    m << \"NotAction: \";\n    print_actions(m, s.notaction);\n\n    if (!s.resource.empty() || !s.notresource.empty() ||\n\t!s.conditions.empty()) {\n      m << \", \";\n    }\n  }\n\n  if (!s.resource.empty()) {\n    m << \"Resource: \";\n    print_array(m, s.resource.cbegin(), s.resource.cend());\n\n    if (!s.notresource.empty() || !s.conditions.empty()) {\n      m << \", \";\n    }\n  }\n\n  if (!s.notresource.empty()) {\n    m << \"NotResource: \";\n    print_array(m, s.notresource.cbegin(), s.notresource.cend());\n\n    if (!s.conditions.empty()) {\n      m << \", \";\n    }\n  }\n\n  if (!s.conditions.empty()) {\n    m << \"Condition: \";\n    print_array(m, s.conditions.cbegin(), s.conditions.cend());\n  }\n\n  return m << \" }\";\n}\n\nstring to_string(const Statement& s) {\n  stringstream m;\n  m << s;\n  return m.str();\n}\n\nPolicy::Policy(CephContext* cct, const string& tenant,\n\t       const bufferlist& _text)\n  : text(_text.to_str()) {\n  StringStream ss(text.data());\n  PolicyParser pp(cct, tenant, *this);\n  auto pr = Reader{}.Parse<kParseNumbersAsStringsFlag |\n\t\t\t   kParseCommentsFlag>(ss, pp);\n  if (!pr) {\n    throw PolicyParseException(std::move(pr));\n  }\n}\n\nEffect Policy::eval(const Environment& e,\n\t\t    optional<const rgw::auth::Identity&> ida,\n\t\t    std::uint64_t action, const ARN& resource) const {\n  auto allowed = false;\n  for (auto& s : statements) {\n    auto g = s.eval(e, ida, action, resource);\n    if (g == Effect::Deny) {\n      return g;\n    } else if (g == Effect::Allow) {\n      allowed = true;\n    }\n  }\n  return allowed ? Effect::Allow : Effect::Pass;\n}\n\nostream& operator <<(ostream& m, const Policy& p) {\n  m << \"{ Version: \"\n    << (p.version == Version::v2008_10_17 ? \"2008-10-17\" : \"2012-10-17\");\n\n  if (p.id || !p.statements.empty()) {\n    m << \", \";\n  }\n\n  if (p.id) {\n    m << \"Id: \" << *p.id;\n    if (!p.statements.empty()) {\n      m << \", \";\n    }\n  }\n\n  if (!p.statements.empty()) {\n    m << \"Statements: \";\n    print_array(m, p.statements.cbegin(), p.statements.cend());\n    m << \", \";\n  }\n  return m << \" }\";\n}\n\nstring to_string(const Policy& p) {\n  stringstream s;\n  s << p;\n  return s.str();\n}\n\n}\n}\n", "// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-\n// vim: ts=8 sw=2 smarttab\n\n#ifndef CEPH_RGW_IAM_POLICY_H\n#define CEPH_RGW_IAM_POLICY_H\n\n#include <bitset>\n#include <chrono>\n#include <cstdint>\n#include <iostream>\n#include <string>\n\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/container/flat_map.hpp>\n#include <boost/container/flat_set.hpp>\n#include <boost/optional.hpp>\n#include <boost/thread/shared_mutex.hpp>\n#include <boost/utility/string_ref.hpp>\n#include <boost/variant.hpp>\n\n#include \"common/ceph_time.h\"\n#include \"common/iso_8601.h\"\n\n#include \"rapidjson/error/error.h\"\n#include \"rapidjson/error/en.h\"\n\n#include \"rgw_acl.h\"\n#include \"rgw_basic_types.h\"\n#include \"rgw_iam_policy_keywords.h\"\n#include \"rgw_string.h\"\n\n#include \"include/assert.h\" // razzin' frazzin' ...grrr.\n\nclass RGWRados;\nnamespace rgw {\nnamespace auth {\nclass Identity;\n}\n}\nstruct rgw_obj;\nstruct rgw_bucket;\n\nnamespace rgw {\nnamespace IAM {\nstatic constexpr std::uint64_t s3None = 0;\nstatic constexpr std::uint64_t s3GetObject = 1ULL << 0;\nstatic constexpr std::uint64_t s3GetObjectVersion = 1ULL << 1;\nstatic constexpr std::uint64_t s3PutObject = 1ULL << 2;\nstatic constexpr std::uint64_t s3GetObjectAcl = 1ULL << 3;\nstatic constexpr std::uint64_t s3GetObjectVersionAcl = 1ULL << 4;\nstatic constexpr std::uint64_t s3PutObjectAcl = 1ULL << 5;\nstatic constexpr std::uint64_t s3PutObjectVersionAcl = 1ULL << 6;\nstatic constexpr std::uint64_t s3DeleteObject = 1ULL << 7;\nstatic constexpr std::uint64_t s3DeleteObjectVersion = 1ULL << 8;\nstatic constexpr std::uint64_t s3ListMultipartUploadParts = 1ULL << 9;\nstatic constexpr std::uint64_t s3AbortMultipartUpload = 1ULL << 10;\nstatic constexpr std::uint64_t s3GetObjectTorrent = 1ULL << 11;\nstatic constexpr std::uint64_t s3GetObjectVersionTorrent = 1ULL << 12;\nstatic constexpr std::uint64_t s3RestoreObject = 1ULL << 13;\nstatic constexpr std::uint64_t s3CreateBucket = 1ULL << 14;\nstatic constexpr std::uint64_t s3DeleteBucket = 1ULL << 15;\nstatic constexpr std::uint64_t s3ListBucket = 1ULL << 16;\nstatic constexpr std::uint64_t s3ListBucketVersions = 1ULL << 17;\nstatic constexpr std::uint64_t s3ListAllMyBuckets = 1ULL << 18;\nstatic constexpr std::uint64_t s3ListBucketMultiPartUploads = 1ULL << 19;\nstatic constexpr std::uint64_t s3GetAccelerateConfiguration = 1ULL << 20;\nstatic constexpr std::uint64_t s3PutAccelerateConfiguration = 1ULL << 21;\nstatic constexpr std::uint64_t s3GetBucketAcl = 1ULL << 22;\nstatic constexpr std::uint64_t s3PutBucketAcl = 1ULL << 23;\nstatic constexpr std::uint64_t s3GetBucketCORS = 1ULL << 24;\nstatic constexpr std::uint64_t s3PutBucketCORS = 1ULL << 25;\nstatic constexpr std::uint64_t s3GetBucketVersioning = 1ULL << 26;\nstatic constexpr std::uint64_t s3PutBucketVersioning = 1ULL << 27;\nstatic constexpr std::uint64_t s3GetBucketRequestPayment = 1ULL << 28;\nstatic constexpr std::uint64_t s3PutBucketRequestPayment = 1ULL << 29;\nstatic constexpr std::uint64_t s3GetBucketLocation = 1ULL << 30;\nstatic constexpr std::uint64_t s3GetBucketPolicy = 1ULL << 31;\nstatic constexpr std::uint64_t s3DeleteBucketPolicy = 1ULL << 32;\nstatic constexpr std::uint64_t s3PutBucketPolicy = 1ULL << 33;\nstatic constexpr std::uint64_t s3GetBucketNotification = 1ULL << 34;\nstatic constexpr std::uint64_t s3PutBucketNotification = 1ULL << 35;\nstatic constexpr std::uint64_t s3GetBucketLogging = 1ULL << 36;\nstatic constexpr std::uint64_t s3PutBucketLogging = 1ULL << 37;\nstatic constexpr std::uint64_t s3GetBucketTagging = 1ULL << 38;\nstatic constexpr std::uint64_t s3PutBucketTagging = 1ULL << 39;\nstatic constexpr std::uint64_t s3GetBucketWebsite = 1ULL << 40;\nstatic constexpr std::uint64_t s3PutBucketWebsite = 1ULL << 41;\nstatic constexpr std::uint64_t s3DeleteBucketWebsite = 1ULL << 42;\nstatic constexpr std::uint64_t s3GetLifecycleConfiguration = 1ULL << 43;\nstatic constexpr std::uint64_t s3PutLifecycleConfiguration = 1ULL << 44;\nstatic constexpr std::uint64_t s3PutReplicationConfiguration = 1ULL << 45;\nstatic constexpr std::uint64_t s3GetReplicationConfiguration = 1ULL << 46;\nstatic constexpr std::uint64_t s3DeleteReplicationConfiguration = 1ULL << 47;\nstatic constexpr std::uint64_t s3GetObjectTagging = 1ULL << 48;\nstatic constexpr std::uint64_t s3PutObjectTagging = 1ULL << 49;\nstatic constexpr std::uint64_t s3DeleteObjectTagging = 1ULL << 50;\nstatic constexpr std::uint64_t s3GetObjectVersionTagging = 1ULL << 51;\nstatic constexpr std::uint64_t s3PutObjectVersionTagging = 1ULL << 52;\nstatic constexpr std::uint64_t s3DeleteObjectVersionTagging = 1ULL << 53;\nstatic constexpr std::uint64_t s3Count = 54;\nstatic constexpr std::uint64_t s3All = (1ULL << s3Count) - 1;\n\nnamespace {\ninline int op_to_perm(std::uint64_t op) {\n  switch (op) {\n  case s3GetObject:\n  case s3GetObjectTorrent:\n  case s3GetObjectVersion:\n  case s3GetObjectVersionTorrent:\n  case s3GetObjectTagging:\n  case s3GetObjectVersionTagging:\n  case s3ListAllMyBuckets:\n  case s3ListBucket:\n  case s3ListBucketMultiPartUploads:\n  case s3ListBucketVersions:\n  case s3ListMultipartUploadParts:\n    return RGW_PERM_READ;\n\n  case s3AbortMultipartUpload:\n  case s3CreateBucket:\n  case s3DeleteBucket:\n  case s3DeleteObject:\n  case s3DeleteObjectVersion:\n  case s3PutObject:\n  case s3PutObjectTagging:\n  case s3PutObjectVersionTagging:\n  case s3DeleteObjectTagging:\n  case s3DeleteObjectVersionTagging:\n  case s3RestoreObject:\n    return RGW_PERM_WRITE;\n\n  case s3GetAccelerateConfiguration:\n  case s3GetBucketAcl:\n  case s3GetBucketCORS:\n  case s3GetBucketLocation:\n  case s3GetBucketLogging:\n  case s3GetBucketNotification:\n  case s3GetBucketPolicy:\n  case s3GetBucketRequestPayment:\n  case s3GetBucketTagging:\n  case s3GetBucketVersioning:\n  case s3GetBucketWebsite:\n  case s3GetLifecycleConfiguration:\n  case s3GetObjectAcl:\n  case s3GetObjectVersionAcl:\n  case s3GetReplicationConfiguration:\n    return RGW_PERM_READ_ACP;\n\n  case s3DeleteBucketPolicy:\n  case s3DeleteBucketWebsite:\n  case s3DeleteReplicationConfiguration:\n  case s3PutAccelerateConfiguration:\n  case s3PutBucketAcl:\n  case s3PutBucketCORS:\n  case s3PutBucketLogging:\n  case s3PutBucketNotification:\n  case s3PutBucketPolicy:\n  case s3PutBucketRequestPayment:\n  case s3PutBucketTagging:\n  case s3PutBucketVersioning:\n  case s3PutBucketWebsite:\n  case s3PutLifecycleConfiguration:\n  case s3PutObjectAcl:\n  case s3PutObjectVersionAcl:\n  case s3PutReplicationConfiguration:\n    return RGW_PERM_WRITE_ACP;\n\n  case s3All:\n    return RGW_PERM_FULL_CONTROL;\n  }\n  return RGW_PERM_INVALID;\n}\n}\n\nusing Environment = boost::container::flat_map<std::string, std::string>;\n\nenum struct Partition {\n  aws, aws_cn, aws_us_gov, wildcard\n  // If we wanted our own ARNs for principal type unique to us\n  // (maybe to integrate better with Swift) or for anything else we\n  // provide that doesn't map onto S3, we could add an 'rgw'\n  // partition type.\n};\n\nenum struct Service {\n  apigateway, appstream, artifact, autoscaling, aws_portal, acm,\n  cloudformation, cloudfront, cloudhsm, cloudsearch, cloudtrail,\n  cloudwatch, events, logs, codebuild, codecommit, codedeploy,\n  codepipeline, cognito_idp, cognito_identity, cognito_sync,\n  config, datapipeline, dms, devicefarm, directconnect,\n  ds, dynamodb, ec2, ecr, ecs, ssm, elasticbeanstalk, elasticfilesystem,\n  elasticloadbalancing, elasticmapreduce, elastictranscoder, elasticache,\n  es, gamelift, glacier, health, iam, importexport, inspector, iot,\n  kms, kinesisanalytics, firehose, kinesis, lambda, lightsail,\n  machinelearning, aws_marketplace, aws_marketplace_management,\n  mobileanalytics, mobilehub, opsworks, opsworks_cm, polly,\n  redshift, rds, route53, route53domains, sts, servicecatalog,\n  ses, sns, sqs, s3, swf, sdb, states, storagegateway, support,\n  trustedadvisor, waf, workmail, workspaces, wildcard\n};\n\nstruct ARN {\n  Partition partition;\n  Service service;\n  std::string region;\n  // Once we refity tenant, we should probably use that instead of a\n  // string.\n  std::string account;\n  std::string resource;\n\n  ARN()\n    : partition(Partition::wildcard), service(Service::wildcard) {}\n  ARN(Partition partition, Service service, std::string region,\n      std::string account, std::string resource)\n    : partition(partition), service(service), region(std::move(region)),\n      account(std::move(account)), resource(std::move(resource)) {}\n  ARN(const rgw_obj& o);\n  ARN(const rgw_bucket& b);\n  ARN(const rgw_bucket& b, const std::string& o);\n\n  static boost::optional<ARN> parse(const std::string& s,\n\t\t\t\t    bool wildcard = false);\n  std::string to_string() const;\n\n  // `this` is the pattern\n  bool match(const ARN& candidate) const;\n};\n\ninline std::string to_string(const ARN& a) {\n  return a.to_string();\n}\n\ninline std::ostream& operator <<(std::ostream& m, const ARN& a) {\n  return m << to_string(a);\n}\n\nbool operator ==(const ARN& l, const ARN& r);\nbool operator <(const ARN& l, const ARN& r);\n\nusing Address = std::bitset<128>;\nstruct MaskedIP {\n  bool v6;\n  Address addr;\n  // Since we're mapping IPv6 to IPv4 addresses, we may want to\n  // consider making the prefix always be in terms of a v6 address\n  // and just use the v6 bit to rewrite it as a v4 prefix for\n  // output.\n  unsigned int prefix;\n};\n\nstd::ostream& operator <<(std::ostream& m, const MaskedIP& ip);\nstring to_string(const MaskedIP& m);\n\ninline bool operator ==(const MaskedIP& l, const MaskedIP& r) {\n  auto shift = std::max((l.v6 ? 128 : 32) - l.prefix,\n\t\t\t(r.v6 ? 128 : 32) - r.prefix);\n  ceph_assert(shift > 0);\n  return (l.addr >> shift) == (r.addr >> shift);\n}\n\nstruct Condition {\n  TokenID op;\n  // Originally I was going to use a perfect hash table, but Marcus\n  // says keys are to be added at run-time not compile time.\n\n  // In future development, use symbol internment.\n  std::string key;\n  bool ifexists = false;\n  // Much to my annoyance there is no actual way to do this in a\n  // typed way that is compatible with AWS. I know this because I've\n  // seen examples where the same value is used as a string in one\n  // context and a date in another.\n  std::vector<std::string> vals;\n\n  Condition() = default;\n  Condition(TokenID op, const char* s, std::size_t len, bool ifexists)\n    : op(op), key(s, len), ifexists(ifexists) {}\n\n  bool eval(const Environment& e) const;\n\n  static boost::optional<double> as_number(const std::string& s) {\n    std::size_t p = 0;\n\n    try {\n      double d = std::stod(s, &p);\n      if (p < s.length()) {\n\treturn boost::none;\n      }\n\n      return d;\n    } catch (const std::logic_error& e) {\n      return boost::none;\n    }\n  }\n\n  static boost::optional<ceph::real_time> as_date(const std::string& s) {\n    std::size_t p = 0;\n\n    try {\n      double d = std::stod(s, &p);\n      if (p == s.length()) {\n\treturn ceph::real_time(\n\t  std::chrono::seconds(static_cast<uint64_t>(d)) +\n\t  std::chrono::nanoseconds(\n\t    static_cast<uint64_t>((d - static_cast<uint64_t>(d))\n\t\t\t\t  * 1000000000)));\n      }\n\n      return from_iso_8601(boost::string_ref(s), false);\n    } catch (const std::logic_error& e) {\n      return boost::none;\n    }\n  }\n\n  static boost::optional<bool> as_bool(const std::string& s) {\n    std::size_t p = 0;\n\n    if (s.empty() || boost::iequals(s, \"false\")) {\n      return false;\n    }\n\n    try {\n      double d = std::stod(s, &p);\n      if (p == s.length()) {\n\treturn !((d == +0.0) || (d == -0.0) || std::isnan(d));\n      }\n    } catch (const std::logic_error& e) {\n      // Fallthrough\n    }\n\n    return true;\n  }\n\n  static boost::optional<ceph::bufferlist> as_binary(const std::string& s) {\n    // In a just world\n    ceph::bufferlist base64;\n    // I could populate a bufferlist\n    base64.push_back(buffer::create_static(\n\t\t       s.length(),\n\t\t       const_cast<char*>(s.data()))); // Yuck\n    // From a base64 encoded std::string.\n    ceph::bufferlist bin;\n\n    try {\n      base64.decode_base64(bin);\n    } catch (const ceph::buffer::malformed_input& e) {\n      return boost::none;\n    }\n    return bin;\n  }\n\n  static boost::optional<MaskedIP> as_network(const std::string& s);\n\n\n  struct ci_equal_to {\n    bool operator ()(const std::string& s1,\n\t\t     const std::string& s2) const {\n      return boost::iequals(s1, s2);\n    }\n  };\n\n  struct string_like {\n    bool operator ()(const std::string& input,\n                     const std::string& pattern) const {\n      return match_wildcards(pattern, input, 0);\n    }\n  };\n\n  template<typename F>\n  static bool orrible(F&& f, const std::string& c,\n\t\t      const std::vector<std::string>& v) {\n    for (const auto& d : v) {\n      if (std::forward<F>(f)(c, d)) {\n\treturn true;\n      }\n    }\n    return false;\n  }\n\n  template<typename F, typename X>\n  static bool shortible(F&& f, X& x, const std::string& c,\n\t\t\tconst std::vector<std::string>& v) {\n    auto xc = std::forward<X>(x)(c);\n    if (!xc) {\n      return false;\n    }\n\n    for (const auto& d : v) {\n      auto xd = std::forward<X>(x)(d);\n      if (!xd) {\n\tcontinue;\n      }\n\n      if (std::forward<F>(f)(*xc, *xd)) {\n\treturn true;\n      }\n    }\n    return false;\n  }\n};\n\nstd::ostream& operator <<(std::ostream& m, const Condition& c);\n\nstd::string to_string(const Condition& c);\n\nstruct Statement {\n  boost::optional<std::string> sid = boost::none;\n\n  boost::container::flat_set<rgw::auth::Principal> princ;\n  boost::container::flat_set<rgw::auth::Principal> noprinc;\n\n  // Every statement MUST provide an effect. I just initialize it to\n  // deny as defensive programming.\n  Effect effect = Effect::Deny;\n\n  std::uint64_t action = 0;\n  std::uint64_t notaction = 0;\n\n  boost::container::flat_set<ARN> resource;\n  boost::container::flat_set<ARN> notresource;\n\n  std::vector<Condition> conditions;\n\n  Effect eval(const Environment& e,\n\t      boost::optional<const rgw::auth::Identity&> ida,\n\t      std::uint64_t action, const ARN& resource) const;\n};\n\nstd::ostream& operator <<(ostream& m, const Statement& s);\nstd::string to_string(const Statement& s);\n\nstruct PolicyParseException : public std::exception {\n  rapidjson::ParseResult pr;\n\n  PolicyParseException(rapidjson::ParseResult&& pr)\n    : pr(pr) { }\n  const char* what() const noexcept override {\n    return rapidjson::GetParseError_En(pr.Code());\n  }\n};\n\nstruct Policy {\n  std::string text;\n  Version version = Version::v2008_10_17;\n  boost::optional<std::string> id = boost::none;\n\n  std::vector<Statement> statements;\n\n  Policy(CephContext* cct, const std::string& tenant,\n\t const bufferlist& text);\n\n  Effect eval(const Environment& e,\n\t      boost::optional<const rgw::auth::Identity&> ida,\n\t      std::uint64_t action, const ARN& resource) const;\n};\n\nstd::ostream& operator <<(ostream& m, const Policy& p);\nstd::string to_string(const Policy& p);\n}\n}\n\nnamespace std {\ntemplate<>\nstruct hash<::rgw::IAM::Service> {\n  size_t operator()(const ::rgw::IAM::Service& s) const noexcept {\n    // Invoke a default-constructed hash object for int.\n    return hash<int>()(static_cast<int>(s));\n  }\n};\n}\n\n#endif\n"], "fixing_code": ["// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*- \n// vim: ts=8 sw=2 smarttab\n#ifndef CEPH_RGW_BASIC_TYPES_H\n#define CEPH_RGW_BASIC_TYPES_H\n\n#include <string>\n\n#include \"include/types.h\"\n\nstruct rgw_user {\n  std::string tenant;\n  std::string id;\n\n  rgw_user() {}\n  // cppcheck-suppress noExplicitConstructor\n  rgw_user(const std::string& s) {\n    from_str(s);\n  }\n  rgw_user(const std::string& tenant, const std::string& id)\n    : tenant(tenant),\n      id(id) {\n  }\n  rgw_user(std::string&& tenant, std::string&& id)\n    : tenant(std::move(tenant)),\n      id(std::move(id)) {\n  }\n\n  void encode(bufferlist& bl) const {\n    ENCODE_START(1, 1, bl);\n    ::encode(tenant, bl);\n    ::encode(id, bl);\n    ENCODE_FINISH(bl);\n  }\n  void decode(bufferlist::iterator& bl) {\n    DECODE_START(1, bl);\n    ::decode(tenant, bl);\n    ::decode(id, bl);\n    DECODE_FINISH(bl);\n  }\n\n  void to_str(std::string& str) const {\n    if (!tenant.empty()) {\n      str = tenant + '$' + id;\n    } else {\n      str = id;\n    }\n  }\n\n  void clear() {\n    tenant.clear();\n    id.clear();\n  }\n\n  bool empty() const {\n    return id.empty();\n  }\n\n  string to_str() const {\n    string s;\n    to_str(s);\n    return s;\n  }\n\n  void from_str(const std::string& str) {\n    size_t pos = str.find('$');\n    if (pos != std::string::npos) {\n      tenant = str.substr(0, pos);\n      id = str.substr(pos + 1);\n    } else {\n      tenant.clear();\n      id = str;\n    }\n  }\n\n  rgw_user& operator=(const string& str) {\n    from_str(str);\n    return *this;\n  }\n\n  int compare(const rgw_user& u) const {\n    int r = tenant.compare(u.tenant);\n    if (r != 0)\n      return r;\n\n    return id.compare(u.id);\n  }\n  int compare(const string& str) const {\n    rgw_user u(str);\n    return compare(u);\n  }\n\n  bool operator!=(const rgw_user& rhs) const {\n    return (compare(rhs) != 0);\n  }\n  bool operator==(const rgw_user& rhs) const {\n    return (compare(rhs) == 0);\n  }\n  bool operator<(const rgw_user& rhs) const {\n    if (tenant < rhs.tenant) {\n      return true;\n    } else if (tenant > rhs.tenant) {\n      return false;\n    }\n    return (id < rhs.id);\n  }\n};\nWRITE_CLASS_ENCODER(rgw_user)\n\n// Represents an identity. This is more wide-ranging than a\n// 'User'. Its purposes is to be matched against by an\n// IdentityApplier. The internal representation will doubtless change as\n// more types are added. We may want to expose the type enum and make\n// the member public so people can switch/case on it.\n\nnamespace rgw {\nnamespace auth {\nclass Principal {\n  enum types { User, Role, Tenant, Wildcard };\n  types t;\n  rgw_user u;\n\n  Principal(types t)\n    : t(t) {}\n\n  Principal(types t, std::string&& n, std::string i)\n    : t(t), u(std::move(n), std::move(i)) {}\n\npublic:\n\n  static Principal wildcard() {\n    return Principal(Wildcard);\n  }\n\n  static Principal user(std::string&& t, std::string&& u) {\n    return Principal(User, std::move(t), std::move(u));\n  }\n\n  static Principal role(std::string&& t, std::string&& u) {\n    return Principal(Role, std::move(t), std::move(u));\n  }\n\n  static Principal tenant(std::string&& t) {\n    return Principal(Tenant, std::move(t), {});\n  }\n\n  bool is_wildcard() const {\n    return t == Wildcard;\n  }\n\n  bool is_user() const {\n    return t == User;\n  }\n\n  bool is_role() const {\n    return t == Role;\n  }\n\n  bool is_tenant() const {\n    return t == Tenant;\n  }\n\n  const std::string& get_tenant() const {\n    return u.tenant;\n  }\n\n  const std::string& get_id() const {\n    return u.id;\n  }\n\n  bool operator ==(const Principal& o) const {\n    return (t == o.t) && (u == o.u);\n  }\n\n  bool operator <(const Principal& o) const {\n    return (t < o.t) || ((t == o.t) && (u < o.u));\n  }\n};\n\nstd::ostream& operator <<(std::ostream& m, const Principal& p);\nstd::string to_string(const Principal& p);\n}\n}\n\nclass JSONObj;\n\nvoid decode_json_obj(rgw_user& val, JSONObj *obj);\nvoid encode_json(const char *name, const rgw_user& val, Formatter *f);\n\ninline ostream& operator<<(ostream& out, const rgw_user &u) {\n  string s;\n  u.to_str(s);\n  return out << s;\n}\n\n\n#endif\n", "// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-\n// vim: ts=8 sw=2 smarttab\n\n\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <utility>\n\n#include <boost/regex.hpp>\n#include <iostream>\n#include \"rapidjson/reader.h\"\n\n#include \"common/backport14.h\"\n#include \"rgw_auth.h\"\n#include <arpa/inet.h>\n#include \"rgw_iam_policy.h\"\n\nnamespace {\nconstexpr int dout_subsys = ceph_subsys_rgw;\n}\n\nusing std::bitset;\nusing std::find;\nusing std::int64_t;\nusing std::move;\nusing std::pair;\nusing std::size_t;\nusing std::string;\nusing std::stringstream;\nusing std::ostream;\nusing std::uint16_t;\nusing std::uint64_t;\nusing std::unordered_map;\n\nusing boost::container::flat_set;\nusing boost::none;\nusing boost::optional;\nusing boost::regex;\nusing boost::regex_constants::ECMAScript;\nusing boost::regex_constants::optimize;\nusing boost::regex_match;\nusing boost::smatch;\n\nusing rapidjson::BaseReaderHandler;\nusing rapidjson::UTF8;\nusing rapidjson::SizeType;\nusing rapidjson::Reader;\nusing rapidjson::kParseCommentsFlag;\nusing rapidjson::kParseNumbersAsStringsFlag;\nusing rapidjson::StringStream;\nusing rapidjson::ParseResult;\n\nusing rgw::auth::Principal;\n\nnamespace rgw {\nnamespace IAM {\n#include \"rgw_iam_policy_keywords.frag.cc\"\n\nstruct actpair {\n  const char* name;\n  const uint64_t bit;\n};\n\nnamespace {\noptional<Partition> to_partition(const smatch::value_type& p,\n\t\t\t\t bool wildcards) {\n  if (p == \"aws\") {\n    return Partition::aws;\n  } else if (p == \"aws-cn\") {\n    return Partition::aws_cn;\n  } else if (p == \"aws-us-gov\") {\n    return Partition::aws_us_gov;\n  } else if (p == \"*\" && wildcards) {\n    return Partition::wildcard;\n  } else {\n    return none;\n  }\n\n  ceph_abort();\n}\n\noptional<Service> to_service(const smatch::value_type& s,\n\t\t\t     bool wildcards) {\n  static const unordered_map<string, Service> services = {\n    { \"acm\", Service::acm },\n    { \"apigateway\", Service::apigateway },\n    { \"appstream\", Service::appstream },\n    { \"artifact\", Service::artifact },\n    { \"autoscaling\", Service::autoscaling },\n    { \"aws-marketplace\", Service::aws_marketplace },\n    { \"aws-marketplace-management\",\n      Service::aws_marketplace_management },\n    { \"aws-portal\", Service::aws_portal },\n    { \"cloudformation\", Service::cloudformation },\n    { \"cloudfront\", Service::cloudfront },\n    { \"cloudhsm\", Service::cloudhsm },\n    { \"cloudsearch\", Service::cloudsearch },\n    { \"cloudtrail\", Service::cloudtrail },\n    { \"cloudwatch\", Service::cloudwatch },\n    { \"codebuild\", Service::codebuild },\n    { \"codecommit\", Service::codecommit },\n    { \"codedeploy\", Service::codedeploy },\n    { \"codepipeline\", Service::codepipeline },\n    { \"cognito-identity\", Service::cognito_identity },\n    { \"cognito-idp\", Service::cognito_idp },\n    { \"cognito-sync\", Service::cognito_sync },\n    { \"config\", Service::config },\n    { \"datapipeline\", Service::datapipeline },\n    { \"devicefarm\", Service::devicefarm },\n    { \"directconnect\", Service::directconnect },\n    { \"dms\", Service::dms },\n    { \"ds\", Service::ds },\n    { \"dynamodb\", Service::dynamodb },\n    { \"ec2\", Service::ec2 },\n    { \"ecr\", Service::ecr },\n    { \"ecs\", Service::ecs },\n    { \"elasticache\", Service::elasticache },\n    { \"elasticbeanstalk\", Service::elasticbeanstalk },\n    { \"elasticfilesystem\", Service::elasticfilesystem },\n    { \"elasticloadbalancing\", Service::elasticloadbalancing },\n    { \"elasticmapreduce\", Service::elasticmapreduce },\n    { \"elastictranscoder\", Service::elastictranscoder },\n    { \"es\", Service::es },\n    { \"events\", Service::events },\n    { \"firehose\", Service::firehose },\n    { \"gamelift\", Service::gamelift },\n    { \"glacier\", Service::glacier },\n    { \"health\", Service::health },\n    { \"iam\", Service::iam },\n    { \"importexport\", Service::importexport },\n    { \"inspector\", Service::inspector },\n    { \"iot\", Service::iot },\n    { \"kinesis\", Service::kinesis },\n    { \"kinesisanalytics\", Service::kinesisanalytics },\n    { \"kms\", Service::kms },\n    { \"lambda\", Service::lambda },\n    { \"lightsail\", Service::lightsail },\n    { \"logs\", Service::logs },\n    { \"machinelearning\", Service::machinelearning },\n    { \"mobileanalytics\", Service::mobileanalytics },\n    { \"mobilehub\", Service::mobilehub },\n    { \"opsworks\", Service::opsworks },\n    { \"opsworks-cm\", Service::opsworks_cm },\n    { \"polly\", Service::polly },\n    { \"rds\", Service::rds },\n    { \"redshift\", Service::redshift },\n    { \"route53\", Service::route53 },\n    { \"route53domains\", Service::route53domains },\n    { \"s3\", Service::s3 },\n    { \"sdb\", Service::sdb },\n    { \"servicecatalog\", Service::servicecatalog },\n    { \"ses\", Service::ses },\n    { \"sns\", Service::sns },\n    { \"sqs\", Service::sqs },\n    { \"ssm\", Service::ssm },\n    { \"states\", Service::states },\n    { \"storagegateway\", Service::storagegateway },\n    { \"sts\", Service::sts },\n    { \"support\", Service::support },\n    { \"swf\", Service::swf },\n    { \"trustedadvisor\", Service::trustedadvisor },\n    { \"waf\", Service::waf },\n    { \"workmail\", Service::workmail },\n    { \"workspaces\", Service::workspaces }};\n\n  if (wildcards && s == \"*\") {\n    return Service::wildcard;\n  }\n\n  auto i = services.find(s);\n  if (i == services.end()) {\n    return none;\n  } else {\n    return i->second;\n  }\n}\n}\n\nARN::ARN(const rgw_obj& o)\n  : partition(Partition::aws),\n    service(Service::s3),\n    region(),\n    account(o.bucket.tenant),\n    resource(o.bucket.name)\n{\n  resource.push_back('/');\n  resource.append(o.key.name);\n}\n\nARN::ARN(const rgw_bucket& b)\n  : partition(Partition::aws),\n    service(Service::s3),\n    region(),\n    account(b.tenant),\n    resource(b.name) { }\n\nARN::ARN(const rgw_bucket& b, const string& o)\n  : partition(Partition::aws),\n    service(Service::s3),\n    region(),\n    account(b.tenant),\n    resource(b.name) {\n  resource.push_back('/');\n  resource.append(o);\n}\n\noptional<ARN> ARN::parse(const string& s, bool wildcards) {\n  static const char str_wild[] = \"arn:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)\";\n  static const regex rx_wild(str_wild,\n\t\t\t\t    sizeof(str_wild) - 1,\n\t\t\t\t    ECMAScript | optimize);\n  static const char str_no_wild[]\n    = \"arn:([^:*]*):([^:*]*):([^:*]*):([^:*]*):([^:*]*)\";\n  static const regex rx_no_wild(str_no_wild,\n\t\t\t\tsizeof(str_no_wild) - 1,\n\t\t\t\tECMAScript | optimize);\n\n  smatch match;\n\n  if ((s == \"*\") && wildcards) {\n    return ARN(Partition::wildcard, Service::wildcard, \"*\", \"*\", \"*\");\n  } else if (regex_match(s, match, wildcards ? rx_wild : rx_no_wild)) {\n    if (match.size() != 6) {\n      return boost::none;\n    }\n\n    ARN a;\n    {\n      auto p = to_partition(match[1], wildcards);\n      if (!p)\n\treturn none;\n\n      a.partition = *p;\n    }\n    {\n      auto s = to_service(match[2], wildcards);\n      if (!s) {\n\treturn none;\n      }\n      a.service = *s;\n    }\n\n    a.region = match[3];\n    a.account = match[4];\n    a.resource = match[5];\n\n    return a;\n  }\n  return none;\n}\n\nstring ARN::to_string() const {\n  string s;\n\n  if (partition == Partition::aws) {\n    s.append(\"aws:\");\n  } else if (partition == Partition::aws_cn) {\n    s.append(\"aws-cn:\");\n  } else if (partition == Partition::aws_us_gov) {\n    s.append(\"aws-us-gov:\");\n  } else {\n    s.append(\"*:\");\n  }\n\n  static const unordered_map<Service, string> services = {\n    { Service::acm, \"acm\" },\n    { Service::apigateway, \"apigateway\" },\n    { Service::appstream, \"appstream\" },\n    { Service::artifact, \"artifact\" },\n    { Service::autoscaling, \"autoscaling\" },\n    { Service::aws_marketplace, \"aws-marketplace\" },\n    { Service::aws_marketplace_management, \"aws-marketplace-management\" },\n    { Service::aws_portal, \"aws-portal\" },\n    { Service::cloudformation, \"cloudformation\" },\n    { Service::cloudfront, \"cloudfront\" },\n    { Service::cloudhsm, \"cloudhsm\" },\n    { Service::cloudsearch, \"cloudsearch\" },\n    { Service::cloudtrail, \"cloudtrail\" },\n    { Service::cloudwatch, \"cloudwatch\" },\n    { Service::codebuild, \"codebuild\" },\n    { Service::codecommit, \"codecommit\" },\n    { Service::codedeploy, \"codedeploy\" },\n    { Service::codepipeline, \"codepipeline\" },\n    { Service::cognito_identity, \"cognito-identity\" },\n    { Service::cognito_idp, \"cognito-idp\" },\n    { Service::cognito_sync, \"cognito-sync\" },\n    { Service::config, \"config\" },\n    { Service::datapipeline, \"datapipeline\" },\n    { Service::devicefarm, \"devicefarm\" },\n    { Service::directconnect, \"directconnect\" },\n    { Service::dms, \"dms\" },\n    { Service::ds, \"ds\" },\n    { Service::dynamodb, \"dynamodb\" },\n    { Service::ec2, \"ec2\" },\n    { Service::ecr, \"ecr\" },\n    { Service::ecs, \"ecs\" },\n    { Service::elasticache, \"elasticache\" },\n    { Service::elasticbeanstalk, \"elasticbeanstalk\" },\n    { Service::elasticfilesystem, \"elasticfilesystem\" },\n    { Service::elasticloadbalancing, \"elasticloadbalancing\" },\n    { Service::elasticmapreduce, \"elasticmapreduce\" },\n    { Service::elastictranscoder, \"elastictranscoder\" },\n    { Service::es, \"es\" },\n    { Service::events, \"events\" },\n    { Service::firehose, \"firehose\" },\n    { Service::gamelift, \"gamelift\" },\n    { Service::glacier, \"glacier\" },\n    { Service::health, \"health\" },\n    { Service::iam, \"iam\" },\n    { Service::importexport, \"importexport\" },\n    { Service::inspector, \"inspector\" },\n    { Service::iot, \"iot\" },\n    { Service::kinesis, \"kinesis\" },\n    { Service::kinesisanalytics, \"kinesisanalytics\" },\n    { Service::kms, \"kms\" },\n    { Service::lambda, \"lambda\" },\n    { Service::lightsail, \"lightsail\" },\n    { Service::logs, \"logs\" },\n    { Service::machinelearning, \"machinelearning\" },\n    { Service::mobileanalytics, \"mobileanalytics\" },\n    { Service::mobilehub, \"mobilehub\" },\n    { Service::opsworks, \"opsworks\" },\n    { Service::opsworks_cm, \"opsworks-cm\" },\n    { Service::polly, \"polly\" },\n    { Service::rds, \"rds\" },\n    { Service::redshift, \"redshift\" },\n    { Service::route53, \"route53\" },\n    { Service::route53domains, \"route53domains\" },\n    { Service::s3, \"s3\" },\n    { Service::sdb, \"sdb\" },\n    { Service::servicecatalog, \"servicecatalog\" },\n    { Service::ses, \"ses\" },\n    { Service::sns, \"sns\" },\n    { Service::sqs, \"sqs\" },\n    { Service::ssm, \"ssm\" },\n    { Service::states, \"states\" },\n    { Service::storagegateway, \"storagegateway\" },\n    { Service::sts, \"sts\" },\n    { Service::support, \"support\" },\n    { Service::swf, \"swf\" },\n    { Service::trustedadvisor, \"trustedadvisor\" },\n    { Service::waf, \"waf\" },\n    { Service::workmail, \"workmail\" },\n    { Service::workspaces, \"workspaces\" }};\n\n  auto i = services.find(service);\n  if (i != services.end()) {\n    s.append(i->second);\n  } else {\n    s.push_back('*');\n  }\n  s.push_back(':');\n\n  s.append(region);\n  s.push_back(':');\n\n  s.append(account);\n  s.push_back(':');\n\n  s.append(resource);\n\n  return s;\n}\n\nbool operator ==(const ARN& l, const ARN& r) {\n  return ((l.partition == r.partition) &&\n\t  (l.service == r.service) &&\n\t  (l.region == r.region) &&\n\t  (l.account == r.account) &&\n\t  (l.resource == r.resource));\n}\nbool operator <(const ARN& l, const ARN& r) {\n  return ((l.partition < r.partition) ||\n\t  (l.service < r.service) ||\n\t  (l.region < r.region) ||\n\t  (l.account < r.account) ||\n\t  (l.resource < r.resource));\n}\n\n// The candidate is not allowed to have wildcards. The only way to\n// do that sanely would be to use unification rather than matching.\nbool ARN::match(const ARN& candidate) const {\n  if ((candidate.partition == Partition::wildcard) ||\n      (partition != candidate.partition && partition\n       != Partition::wildcard)) {\n    return false;\n  }\n\n  if ((candidate.service == Service::wildcard) ||\n      (service != candidate.service && service != Service::wildcard)) {\n    return false;\n  }\n\n  if (!match_policy(region, candidate.region, MATCH_POLICY_ARN)) {\n    return false;\n  }\n\n  if (!match_policy(account, candidate.account, MATCH_POLICY_ARN)) {\n    return false;\n  }\n\n  if (!match_policy(resource, candidate.resource, MATCH_POLICY_ARN)) {\n    return false;\n  }\n\n  return true;\n}\n\nstatic const actpair actpairs[] =\n{{ \"s3:AbortMultipartUpload\", s3AbortMultipartUpload },\n { \"s3:CreateBucket\", s3CreateBucket },\n { \"s3:DeleteBucketPolicy\", s3DeleteBucketPolicy },\n { \"s3:DeleteBucket\", s3DeleteBucket },\n { \"s3:DeleteBucketWebsite\", s3DeleteBucketWebsite },\n { \"s3:DeleteObject\", s3DeleteObject },\n { \"s3:DeleteObjectVersion\", s3DeleteObjectVersion },\n { \"s3:DeleteObjectTagging\", s3DeleteObjectTagging },\n { \"s3:DeleteObjectVersionTagging\", s3DeleteObjectVersionTagging },\n { \"s3:DeleteReplicationConfiguration\", s3DeleteReplicationConfiguration },\n { \"s3:GetAccelerateConfiguration\", s3GetAccelerateConfiguration },\n { \"s3:GetBucketAcl\", s3GetBucketAcl },\n { \"s3:GetBucketCORS\", s3GetBucketCORS },\n { \"s3:GetBucketLocation\", s3GetBucketLocation },\n { \"s3:GetBucketLogging\", s3GetBucketLogging },\n { \"s3:GetBucketNotification\", s3GetBucketNotification },\n { \"s3:GetBucketPolicy\", s3GetBucketPolicy },\n { \"s3:GetBucketRequestPayment\", s3GetBucketRequestPayment },\n { \"s3:GetBucketTagging\", s3GetBucketTagging },\n { \"s3:GetBucketVersioning\", s3GetBucketVersioning },\n { \"s3:GetBucketWebsite\", s3GetBucketWebsite },\n { \"s3:GetLifecycleConfiguration\", s3GetLifecycleConfiguration },\n { \"s3:GetObjectAcl\", s3GetObjectAcl },\n { \"s3:GetObject\", s3GetObject },\n { \"s3:GetObjectTorrent\", s3GetObjectTorrent },\n { \"s3:GetObjectVersionAcl\", s3GetObjectVersionAcl },\n { \"s3:GetObjectVersion\", s3GetObjectVersion },\n { \"s3:GetObjectVersionTorrent\", s3GetObjectVersionTorrent },\n { \"s3:GetObjectTagging\", s3GetObjectTagging },\n { \"s3:GetObjectVersionTagging\", s3GetObjectVersionTagging},\n { \"s3:GetReplicationConfiguration\", s3GetReplicationConfiguration },\n { \"s3:ListAllMyBuckets\", s3ListAllMyBuckets },\n { \"s3:ListBucketMultiPartUploads\", s3ListBucketMultiPartUploads },\n { \"s3:ListBucket\", s3ListBucket },\n { \"s3:ListBucketVersions\", s3ListBucketVersions },\n { \"s3:ListMultipartUploadParts\", s3ListMultipartUploadParts },\n { \"s3:PutAccelerateConfiguration\", s3PutAccelerateConfiguration },\n { \"s3:PutBucketAcl\", s3PutBucketAcl },\n { \"s3:PutBucketCORS\", s3PutBucketCORS },\n { \"s3:PutBucketLogging\", s3PutBucketLogging },\n { \"s3:PutBucketNotification\", s3PutBucketNotification },\n { \"s3:PutBucketPolicy\", s3PutBucketPolicy },\n { \"s3:PutBucketRequestPayment\", s3PutBucketRequestPayment },\n { \"s3:PutBucketTagging\", s3PutBucketTagging },\n { \"s3:PutBucketVersioning\", s3PutBucketVersioning },\n { \"s3:PutBucketWebsite\", s3PutBucketWebsite },\n { \"s3:PutLifecycleConfiguration\", s3PutLifecycleConfiguration },\n { \"s3:PutObjectAcl\",  s3PutObjectAcl },\n { \"s3:PutObject\", s3PutObject },\n { \"s3:PutObjectVersionAcl\", s3PutObjectVersionAcl },\n { \"s3:PutObjectTagging\", s3PutObjectTagging },\n { \"s3:PutObjectVersionTagging\", s3PutObjectVersionTagging },\n { \"s3:PutReplicationConfiguration\", s3PutReplicationConfiguration },\n { \"s3:RestoreObject\", s3RestoreObject }};\n\nstruct PolicyParser;\n\nconst Keyword top[1]{\"<Top>\", TokenKind::pseudo, TokenID::Top, 0, false,\n    false};\nconst Keyword cond_key[1]{\"<Condition Key>\", TokenKind::cond_key,\n    TokenID::CondKey, 0, true, false};\n\nstruct ParseState {\n  PolicyParser* pp;\n  const Keyword* w;\n\n  bool arraying = false;\n  bool objecting = false;\n  bool cond_ifexists = false;\n\n  void reset();\n\n  ParseState(PolicyParser* pp, const Keyword* w)\n    : pp(pp), w(w) {}\n\n  bool obj_start();\n\n  bool obj_end();\n\n  bool array_start() {\n    if (w->arrayable && !arraying) {\n      arraying = true;\n      return true;\n    }\n    return false;\n  }\n\n  bool array_end();\n\n  bool key(const char* s, size_t l);\n  bool do_string(CephContext* cct, const char* s, size_t l);\n  bool number(const char* str, size_t l);\n};\n\n// If this confuses you, look up the Curiously Recurring Template Pattern\nstruct PolicyParser : public BaseReaderHandler<UTF8<>, PolicyParser> {\n  keyword_hash tokens;\n  std::vector<ParseState> s;\n  CephContext* cct;\n  const string& tenant;\n  Policy& policy;\n  uint32_t v = 0;\n\n  uint32_t seen = 0;\n\n  uint32_t dex(TokenID in) const {\n    switch (in) {\n    case TokenID::Version:\n      return 0x1;\n    case TokenID::Id:\n      return 0x2;\n    case TokenID::Statement:\n      return 0x4;\n    case TokenID::Sid:\n      return 0x8;\n    case TokenID::Effect:\n      return 0x10;\n    case TokenID::Principal:\n      return 0x20;\n    case TokenID::NotPrincipal:\n      return 0x40;\n    case TokenID::Action:\n      return 0x80;\n    case TokenID::NotAction:\n      return 0x100;\n    case TokenID::Resource:\n      return 0x200;\n    case TokenID::NotResource:\n      return 0x400;\n    case TokenID::Condition:\n      return 0x800;\n    case TokenID::AWS:\n      return 0x1000;\n    case TokenID::Federated:\n      return 0x2000;\n    case TokenID::Service:\n      return 0x4000;\n    case TokenID::CanonicalUser:\n      return 0x8000;\n    default:\n      ceph_abort();\n    }\n  }\n  bool test(TokenID in) {\n    return seen & dex(in);\n  }\n  void set(TokenID in) {\n    seen |= dex(in);\n    if (dex(in) & (dex(TokenID::Sid) | dex(TokenID::Effect) |\n\t\t   dex(TokenID::Principal) | dex(TokenID::NotPrincipal) |\n\t\t   dex(TokenID::Action) | dex(TokenID::NotAction) |\n\t\t   dex(TokenID::Resource) | dex(TokenID::NotResource) |\n\t\t   dex(TokenID::Condition) | dex(TokenID::AWS) |\n\t\t   dex(TokenID::Federated) | dex(TokenID::Service) |\n\t\t   dex(TokenID::CanonicalUser))) {\n      v |= dex(in);\n    }\n  }\n  void set(std::initializer_list<TokenID> l) {\n    for (auto in : l) {\n      seen |= dex(in);\n      if (dex(in) & (dex(TokenID::Sid) | dex(TokenID::Effect) |\n\t\t     dex(TokenID::Principal) | dex(TokenID::NotPrincipal) |\n\t\t     dex(TokenID::Action) | dex(TokenID::NotAction) |\n\t\t     dex(TokenID::Resource) | dex(TokenID::NotResource) |\n\t\t     dex(TokenID::Condition) | dex(TokenID::AWS) |\n\t\t     dex(TokenID::Federated) | dex(TokenID::Service) |\n\t\t     dex(TokenID::CanonicalUser))) {\n\tv |= dex(in);\n      }\n    }\n  }\n  void reset(TokenID in) {\n    seen &= ~dex(in);\n    if (dex(in) & (dex(TokenID::Sid) | dex(TokenID::Effect) |\n\t\t   dex(TokenID::Principal) | dex(TokenID::NotPrincipal) |\n\t\t   dex(TokenID::Action) | dex(TokenID::NotAction) |\n\t\t   dex(TokenID::Resource) | dex(TokenID::NotResource) |\n\t\t   dex(TokenID::Condition) | dex(TokenID::AWS) |\n\t\t   dex(TokenID::Federated) | dex(TokenID::Service) |\n\t\t   dex(TokenID::CanonicalUser))) {\n      v &= ~dex(in);\n    }\n  }\n  void reset(std::initializer_list<TokenID> l) {\n    for (auto in : l) {\n      seen &= ~dex(in);\n      if (dex(in) & (dex(TokenID::Sid) | dex(TokenID::Effect) |\n\t\t     dex(TokenID::Principal) | dex(TokenID::NotPrincipal) |\n\t\t     dex(TokenID::Action) | dex(TokenID::NotAction) |\n\t\t     dex(TokenID::Resource) | dex(TokenID::NotResource) |\n\t\t     dex(TokenID::Condition) | dex(TokenID::AWS) |\n\t\t     dex(TokenID::Federated) | dex(TokenID::Service) |\n\t\t     dex(TokenID::CanonicalUser))) {\n\tv &= ~dex(in);\n      }\n    }\n  }\n  void reset(uint32_t& v) {\n    seen &= ~v;\n    v = 0;\n  }\n\n  PolicyParser(CephContext* cct, const string& tenant, Policy& policy)\n    : cct(cct), tenant(tenant), policy(policy) {}\n  PolicyParser(const PolicyParser& policy) = delete;\n\n  bool StartObject() {\n    if (s.empty()) {\n      s.push_back({this, top});\n      s.back().objecting = true;\n      return true;\n    }\n\n    return s.back().obj_start();\n  }\n  bool EndObject(SizeType memberCount) {\n    if (s.empty()) {\n      return false;\n    }\n    return s.back().obj_end();\n  }\n  bool Key(const char* str, SizeType length, bool copy) {\n    if (s.empty()) {\n      return false;\n    }\n    return s.back().key(str, length);\n  }\n\n  bool String(const char* str, SizeType length, bool copy) {\n    if (s.empty()) {\n      return false;\n    }\n    return s.back().do_string(cct, str, length);\n  }\n  bool RawNumber(const char* str, SizeType length, bool copy) {\n    if (s.empty()) {\n      return false;\n    }\n\n    return s.back().number(str, length);\n  }\n  bool StartArray() {\n    if (s.empty()) {\n      return false;\n    }\n\n    return s.back().array_start();\n  }\n  bool EndArray(SizeType) {\n    if (s.empty()) {\n      return false;\n    }\n\n    return s.back().array_end();\n  }\n\n  bool Default() {\n    return false;\n  }\n};\n\n\n// I really despise this misfeature of C++.\n//\nbool ParseState::obj_end() {\n  if (objecting) {\n    objecting = false;\n    if (!arraying) {\n      pp->s.pop_back();\n    } else {\n      reset();\n    }\n    return true;\n  }\n  return false;\n}\n\nbool ParseState::key(const char* s, size_t l) {\n  auto token_len = l;\n  bool ifexists = false;\n  if (w->id == TokenID::Condition && w->kind == TokenKind::statement) {\n    static constexpr char IfExists[] = \"IfExists\";\n    if (boost::algorithm::ends_with(boost::string_view{s, l}, IfExists)) {\n      ifexists = true;\n      token_len -= sizeof(IfExists)-1;\n    }\n  }\n  auto k = pp->tokens.lookup(s, token_len);\n\n  if (!k) {\n    if (w->kind == TokenKind::cond_op) {\n      auto id = w->id;\n      auto& t = pp->policy.statements.back();\n      auto c_ife =  cond_ifexists;\n      pp->s.emplace_back(pp, cond_key);\n      t.conditions.emplace_back(id, s, l, c_ife);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // If the token we're going with belongs within the condition at the\n  // top of the stack and we haven't already encountered it, push it\n  // on the stack\n  // Top\n  if ((((w->id == TokenID::Top) && (k->kind == TokenKind::top)) ||\n       // Statement\n       ((w->id == TokenID::Statement) && (k->kind == TokenKind::statement)) ||\n\n       /// Principal\n       ((w->id == TokenID::Principal || w->id == TokenID::NotPrincipal) &&\n\t(k->kind == TokenKind::princ_type))) &&\n\n      // Check that it hasn't been encountered. Note that this\n      // conjoins with the run of disjunctions above.\n      !pp->test(k->id)) {\n    pp->set(k->id);\n    pp->s.emplace_back(pp, k);\n    return true;\n  } else if ((w->id == TokenID::Condition) &&\n\t     (k->kind == TokenKind::cond_op)) {\n    pp->s.emplace_back(pp, k);\n    pp->s.back().cond_ifexists = ifexists;\n    return true;\n  }\n  return false;\n}\n\n// I should just rewrite a few helper functions to use iterators,\n// which will make all of this ever so much nicer.\nstatic optional<Principal> parse_principal(CephContext* cct, TokenID t,\n\t\t\t\t    string&& s) {\n  // Wildcard!\n  if ((t == TokenID::AWS) && (s == \"*\")) {\n    return Principal::wildcard();\n\n    // Do nothing for now.\n  } else if (t == TokenID::CanonicalUser) {\n\n    // AWS ARNs\n  } else if (t == TokenID::AWS) {\n    auto a = ARN::parse(s);\n    if (!a) {\n      if (std::none_of(s.begin(), s.end(),\n\t\t       [](const char& c) {\n\t\t\t return (c == ':') || (c == '/');\n\t\t       })) {\n\t// Since tenants are simply prefixes, there's no really good\n\t// way to see if one exists or not. So we return the thing and\n\t// let them try to match against it.\n\treturn Principal::tenant(std::move(s));\n      }\n    }\n\n    if (a->resource == \"root\") {\n      return Principal::tenant(std::move(a->account));\n    }\n\n    static const char rx_str[] = \"([^/]*)/(.*)\";\n    static const regex rx(rx_str, sizeof(rx_str) - 1,\n\t\t\t  ECMAScript | optimize);\n    smatch match;\n    if (regex_match(a->resource, match, rx)) {\n      if (match.size() != 3) {\n\treturn boost::none;\n      }\n\n      if (match[1] == \"user\") {\n\treturn Principal::user(std::move(a->account),\n\t\t\t       match[2]);\n      }\n\n      if (match[1] == \"role\") {\n\treturn Principal::role(std::move(a->account),\n\t\t\t       match[2]);\n      }\n    }\n  }\n\n  ldout(cct, 0) << \"Supplied principal is discarded: \" << s << dendl;\n  return boost::none;\n}\n\nbool ParseState::do_string(CephContext* cct, const char* s, size_t l) {\n  auto k = pp->tokens.lookup(s, l);\n  Policy& p = pp->policy;\n  bool is_action = false;\n  bool is_validaction = false;\n  Statement* t = p.statements.empty() ? nullptr : &(p.statements.back());\n\n  // Top level!\n  if ((w->id == TokenID::Version) && k &&\n      k->kind == TokenKind::version_key) {\n    p.version = static_cast<Version>(k->specific);\n  } else if (w->id == TokenID::Id) {\n    p.id = string(s, l);\n\n    // Statement\n\n  } else if (w->id == TokenID::Sid) {\n    t->sid.emplace(s, l);\n  } else if ((w->id == TokenID::Effect) &&\n\t     k->kind == TokenKind::effect_key) {\n    t->effect = static_cast<Effect>(k->specific);\n  } else if (w->id == TokenID::Principal && s && *s == '*') {\n    t->princ.emplace(Principal::wildcard());\n  } else if (w->id == TokenID::NotPrincipal && s && *s == '*') {\n    t->noprinc.emplace(Principal::wildcard());\n  } else if ((w->id == TokenID::Action) ||\n\t     (w->id == TokenID::NotAction)) {\n    is_action = true;\n    for (auto& p : actpairs) {\n      if (match_policy({s, l}, p.name, MATCH_POLICY_ACTION)) {\n        is_validaction = true;\n\t(w->id == TokenID::Action ? t->action : t->notaction) |= p.bit;\n      }\n    }\n  } else if (w->id == TokenID::Resource || w->id == TokenID::NotResource) {\n    auto a = ARN::parse({s, l}, true);\n    // You can't specify resources for someone ELSE'S account.\n    if (a && (a->account.empty() || a->account == pp->tenant ||\n\t      a->account == \"*\")) {\n      if (a->account.empty() || a->account == \"*\")\n\ta->account = pp->tenant;\n      (w->id == TokenID::Resource ? t->resource : t->notresource)\n\t.emplace(std::move(*a));\n    }\n    else\n      ldout(cct, 0) << \"Supplied resource is discarded: \" << string(s, l)\n\t\t    << dendl;\n  } else if (w->kind == TokenKind::cond_key) {\n    auto& t = pp->policy.statements.back();\n    t.conditions.back().vals.emplace_back(s, l);\n\n    // Principals\n\n  } else if (w->kind == TokenKind::princ_type) {\n    if (pp->s.size() <= 1) {\n      return false;\n    }\n    auto& pri = pp->s[pp->s.size() - 2].w->id == TokenID::Principal ?\n      t->princ : t->noprinc;\n\n    auto o = parse_principal(pp->cct, w->id, string(s, l));\n    if (o)\n      pri.emplace(std::move(*o));\n\n    // Failure\n\n  } else {\n    return false;\n  }\n\n  if (!arraying) {\n    pp->s.pop_back();\n  }\n\n  if (is_action && !is_validaction){\n    return false;\n  }\n\n  return true;\n}\n\nbool ParseState::number(const char* s, size_t l) {\n  // Top level!\n  if (w->kind == TokenKind::cond_key) {\n    auto& t = pp->policy.statements.back();\n    t.conditions.back().vals.emplace_back(s, l);\n\n    // Failure\n\n  } else {\n    return false;\n  }\n\n  if (!arraying) {\n    pp->s.pop_back();\n  }\n\n  return true;\n}\n\nvoid ParseState::reset() {\n  pp->reset(pp->v);\n}\n\nbool ParseState::obj_start() {\n  if (w->objectable && !objecting) {\n    objecting = true;\n    if (w->id == TokenID::Statement) {\n      pp->policy.statements.push_back({});\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\n\nbool ParseState::array_end() {\n  if (arraying && !objecting) {\n    pp->s.pop_back();\n    return true;\n  }\n\n  return false;\n}\n\nostream& operator <<(ostream& m, const MaskedIP& ip) {\n  // I have a theory about why std::bitset is the way it is.\n  if (ip.v6) {\n    for (int i = 15; i >= 0; --i) {\n      uint8_t b = 0;\n      for (int j = 7; j >= 0; --j) {\n\tb |= (ip.addr[(i * 8) + j] << j);\n      }\n      m << hex << b;\n      if (i != 0) {\n\tm << \"::\";\n      }\n    }\n  } else {\n    // It involves Satan.\n    for (int i = 3; i >= 0; --i) {\n      uint8_t b = 0;\n      for (int j = 7; j >= 0; --j) {\n\tb |= (ip.addr[(i * 8) + j] << j);\n      }\n      m << b;\n      if (i != 0) {\n\tm << \".\";\n      }\n    }\n  }\n  m << \"/\" << ip.prefix;\n  // It would explain a lot\n  return m;\n}\n\nstring to_string(const MaskedIP& m) {\n  stringstream ss;\n  ss << m;\n  return ss.str();\n}\n\nbool Condition::eval(const Environment& env) const {\n  auto i = env.find(key);\n  if (op == TokenID::Null) {\n    return i == env.end() ? true : false;\n  }\n\n  if (i == env.end()) {\n    return ifexists;\n  }\n  const auto& s = i->second;\n\n  switch (op) {\n    // String!\n  case TokenID::StringEquals:\n    return orrible(std::equal_to<std::string>(), s, vals);\n\n  case TokenID::StringNotEquals:\n    return orrible(ceph::not_fn(std::equal_to<std::string>()),\n\t\t   s, vals);\n\n  case TokenID::StringEqualsIgnoreCase:\n    return orrible(ci_equal_to(), s, vals);\n\n  case TokenID::StringNotEqualsIgnoreCase:\n    return orrible(ceph::not_fn(ci_equal_to()), s, vals);\n\n  case TokenID::StringLike:\n    return orrible(string_like(), s, vals);\n\n  case TokenID::StringNotLike:\n    return orrible(ceph::not_fn(string_like()), s, vals);\n\n    // Numeric\n  case TokenID::NumericEquals:\n    return shortible(std::equal_to<double>(), as_number, s, vals);\n\n  case TokenID::NumericNotEquals:\n    return shortible(ceph::not_fn(std::equal_to<double>()),\n\t\t     as_number, s, vals);\n\n\n  case TokenID::NumericLessThan:\n    return shortible(std::less<double>(), as_number, s, vals);\n\n\n  case TokenID::NumericLessThanEquals:\n    return shortible(std::less_equal<double>(), as_number, s, vals);\n\n  case TokenID::NumericGreaterThan:\n    return shortible(std::greater<double>(), as_number, s, vals);\n\n  case TokenID::NumericGreaterThanEquals:\n    return shortible(std::greater_equal<double>(), as_number, s, vals);\n\n    // Date!\n  case TokenID::DateEquals:\n    return shortible(std::equal_to<ceph::real_time>(), as_date, s, vals);\n\n  case TokenID::DateNotEquals:\n    return shortible(ceph::not_fn(std::equal_to<ceph::real_time>()),\n\t\t     as_date, s, vals);\n\n  case TokenID::DateLessThan:\n    return shortible(std::less<ceph::real_time>(), as_date, s, vals);\n\n\n  case TokenID::DateLessThanEquals:\n    return shortible(std::less_equal<ceph::real_time>(), as_date, s, vals);\n\n  case TokenID::DateGreaterThan:\n    return shortible(std::greater<ceph::real_time>(), as_date, s, vals);\n\n  case TokenID::DateGreaterThanEquals:\n    return shortible(std::greater_equal<ceph::real_time>(), as_date, s,\n\t\t     vals);\n\n    // Bool!\n  case TokenID::Bool:\n    return shortible(std::equal_to<bool>(), as_bool, s, vals);\n\n    // Binary!\n  case TokenID::BinaryEquals:\n    return shortible(std::equal_to<ceph::bufferlist>(), as_binary, s,\n\t\t     vals);\n\n    // IP Address!\n  case TokenID::IpAddress:\n    return shortible(std::equal_to<MaskedIP>(), as_network, s, vals);\n\n  case TokenID::NotIpAddress:\n    return shortible(ceph::not_fn(std::equal_to<MaskedIP>()), as_network, s,\n\t\t     vals);\n\n#if 0\n    // Amazon Resource Names! (Does S3 need this?)\n    TokenID::ArnEquals, TokenID::ArnNotEquals, TokenID::ArnLike,\n      TokenID::ArnNotLike,\n#endif\n\n  default:\n    return false;\n  }\n}\n\noptional<MaskedIP> Condition::as_network(const string& s) {\n  MaskedIP m;\n  if (s.empty()) {\n    return none;\n  }\n\n  m.v6 = s.find(':');\n  auto slash = s.find('/');\n  if (slash == string::npos) {\n    m.prefix = m.v6 ? 128 : 32;\n  } else {\n    char* end = 0;\n    m.prefix = strtoul(s.data() + slash + 1, &end, 10);\n    if (*end != 0 || (m.v6 && m.prefix > 128) ||\n\t(!m.v6 && m.prefix > 32)) {\n      return none;\n    }\n  }\n\n  string t;\n  auto p = &s;\n\n  if (slash != string::npos) {\n    t.assign(s, 0, slash);\n    p = &t;\n  }\n\n  if (m.v6) {\n    struct sockaddr_in6 a;\n    if (inet_pton(AF_INET6, p->c_str(), static_cast<void*>(&a)) != 1) {\n      return none;\n    }\n\n    m.addr |= Address(a.sin6_addr.s6_addr[0]) << 0;\n    m.addr |= Address(a.sin6_addr.s6_addr[1]) << 8;\n    m.addr |= Address(a.sin6_addr.s6_addr[2]) << 16;\n    m.addr |= Address(a.sin6_addr.s6_addr[3]) << 24;\n    m.addr |= Address(a.sin6_addr.s6_addr[4]) << 32;\n    m.addr |= Address(a.sin6_addr.s6_addr[5]) << 40;\n    m.addr |= Address(a.sin6_addr.s6_addr[6]) << 48;\n    m.addr |= Address(a.sin6_addr.s6_addr[7]) << 56;\n    m.addr |= Address(a.sin6_addr.s6_addr[8]) << 64;\n    m.addr |= Address(a.sin6_addr.s6_addr[9]) << 72;\n    m.addr |= Address(a.sin6_addr.s6_addr[10]) << 80;\n    m.addr |= Address(a.sin6_addr.s6_addr[11]) << 88;\n    m.addr |= Address(a.sin6_addr.s6_addr[12]) << 96;\n    m.addr |= Address(a.sin6_addr.s6_addr[13]) << 104;\n    m.addr |= Address(a.sin6_addr.s6_addr[14]) << 112;\n    m.addr |= Address(a.sin6_addr.s6_addr[15]) << 120;\n  } else {\n    struct sockaddr_in a;\n    if (inet_pton(AF_INET, p->c_str(), static_cast<void*>(&a)) != 1) {\n      return none;\n    }\n    m.addr = ntohl(a.sin_addr.s_addr);\n  }\n\n  return none;\n}\n\nnamespace {\nconst char* condop_string(const TokenID t) {\n  switch (t) {\n  case TokenID::StringEquals:\n    return \"StringEquals\";\n\n  case TokenID::StringNotEquals:\n    return \"StringNotEquals\";\n\n  case TokenID::StringEqualsIgnoreCase:\n    return \"StringEqualsIgnoreCase\";\n\n  case TokenID::StringNotEqualsIgnoreCase:\n    return \"StringNotEqualsIgnoreCase\";\n\n  case TokenID::StringLike:\n    return \"StringLike\";\n\n  case TokenID::StringNotLike:\n    return \"StringNotLike\";\n\n  // Numeric!\n  case TokenID::NumericEquals:\n    return \"NumericEquals\";\n\n  case TokenID::NumericNotEquals:\n    return \"NumericNotEquals\";\n\n  case TokenID::NumericLessThan:\n    return \"NumericLessThan\";\n\n  case TokenID::NumericLessThanEquals:\n    return \"NumericLessThanEquals\";\n\n  case TokenID::NumericGreaterThan:\n    return \"NumericGreaterThan\";\n\n  case TokenID::NumericGreaterThanEquals:\n    return \"NumericGreaterThanEquals\";\n\n  case TokenID::DateEquals:\n    return \"DateEquals\";\n\n  case TokenID::DateNotEquals:\n    return \"DateNotEquals\";\n\n  case TokenID::DateLessThan:\n    return \"DateLessThan\";\n\n  case TokenID::DateLessThanEquals:\n    return \"DateLessThanEquals\";\n\n  case TokenID::DateGreaterThan:\n    return \"DateGreaterThan\";\n\n  case TokenID::DateGreaterThanEquals:\n    return \"DateGreaterThanEquals\";\n\n  case TokenID::Bool:\n    return \"Bool\";\n\n  case TokenID::BinaryEquals:\n    return \"BinaryEquals\";\n\n  case TokenID::IpAddress:\n    return \"case TokenID::IpAddress\";\n\n  case TokenID::NotIpAddress:\n    return \"NotIpAddress\";\n\n  case TokenID::ArnEquals:\n    return \"ArnEquals\";\n\n  case TokenID::ArnNotEquals:\n    return \"ArnNotEquals\";\n\n  case TokenID::ArnLike:\n    return \"ArnLike\";\n\n  case TokenID::ArnNotLike:\n    return \"ArnNotLike\";\n\n  case TokenID::Null:\n    return \"Null\";\n\n  default:\n    return \"InvalidConditionOperator\";\n  }\n}\n\ntemplate<typename Iterator>\nostream& print_array(ostream& m, Iterator begin, Iterator end) {\n  if (begin == end) {\n    m << \"[\";\n  } else {\n    auto beforelast = end - 1;\n    m << \"[ \";\n    for (auto i = begin; i != end; ++i) {\n      m << *i;\n      if (i != beforelast) {\n\tm << \", \";\n      } else {\n\tm << \" \";\n      }\n    }\n  }\n  m << \"]\";\n  return m;\n}\n}\n\nostream& operator <<(ostream& m, const Condition& c) {\n  m << \"{ \" << condop_string(c.op);\n  if (c.ifexists) {\n    m << \"IfExists\";\n  }\n  m << \": { \" << c.key;\n  print_array(m, c.vals.cbegin(), c.vals.cend());\n  return m << \"}\";\n}\n\nstring to_string(const Condition& c) {\n  stringstream ss;\n  ss << c;\n  return ss.str();\n}\n\nEffect Statement::eval(const Environment& e,\n\t\t       optional<const rgw::auth::Identity&> ida,\n\t\t       uint64_t act, const ARN& res) const {\n  if (ida && (!ida->is_identity(princ) || ida->is_identity(noprinc))) {\n    return Effect::Pass;\n  }\n\n\n  if (!std::any_of(resource.begin(), resource.end(),\n\t\t   [&res](const ARN& pattern) {\n\t\t     return pattern.match(res);\n\t\t   }) ||\n      (std::any_of(notresource.begin(), notresource.end(),\n\t\t   [&res](const ARN& pattern) {\n\t\t     return pattern.match(res);\n\t\t   }))) {\n    return Effect::Pass;\n  }\n\n  if (!(action & act) || (notaction & act)) {\n    return Effect::Pass;\n  }\n\n  if (std::all_of(conditions.begin(),\n\t\t  conditions.end(),\n\t\t  [&e](const Condition& c) { return c.eval(e);})) {\n    return effect;\n  }\n\n  return Effect::Pass;\n}\n\nnamespace {\nconst char* action_bit_string(uint64_t action) {\n  switch (action) {\n  case s3GetObject:\n    return \"s3:GetObject\";\n\n  case s3GetObjectVersion:\n    return \"s3:GetObjectVersion\";\n\n  case s3PutObject:\n    return \"s3:PutObject\";\n\n  case s3GetObjectAcl:\n    return \"s3:GetObjectAcl\";\n\n  case s3GetObjectVersionAcl:\n    return \"s3:GetObjectVersionAcl\";\n\n  case s3PutObjectAcl:\n    return \"s3:PutObjectAcl\";\n\n  case s3PutObjectVersionAcl:\n    return \"s3:PutObjectVersionAcl\";\n\n  case s3DeleteObject:\n    return \"s3:DeleteObject\";\n\n  case s3DeleteObjectVersion:\n    return \"s3:DeleteObjectVersion\";\n\n  case s3ListMultipartUploadParts:\n    return \"s3:ListMultipartUploadParts\";\n\n  case s3AbortMultipartUpload:\n    return \"s3:AbortMultipartUpload\";\n\n  case s3GetObjectTorrent:\n    return \"s3:GetObjectTorrent\";\n\n  case s3GetObjectVersionTorrent:\n    return \"s3:GetObjectVersionTorrent\";\n\n  case s3RestoreObject:\n    return \"s3:RestoreObject\";\n\n  case s3CreateBucket:\n    return \"s3:CreateBucket\";\n\n  case s3DeleteBucket:\n    return \"s3:DeleteBucket\";\n\n  case s3ListBucket:\n    return \"s3:ListBucket\";\n\n  case s3ListBucketVersions:\n    return \"s3:ListBucketVersions\";\n  case s3ListAllMyBuckets:\n    return \"s3:ListAllMyBuckets\";\n\n  case s3ListBucketMultiPartUploads:\n    return \"s3:ListBucketMultiPartUploads\";\n\n  case s3GetAccelerateConfiguration:\n    return \"s3:GetAccelerateConfiguration\";\n\n  case s3PutAccelerateConfiguration:\n    return \"s3:PutAccelerateConfiguration\";\n\n  case s3GetBucketAcl:\n    return \"s3:GetBucketAcl\";\n\n  case s3PutBucketAcl:\n    return \"s3:PutBucketAcl\";\n\n  case s3GetBucketCORS:\n    return \"s3:GetBucketCORS\";\n\n  case s3PutBucketCORS:\n    return \"s3:PutBucketCORS\";\n\n  case s3GetBucketVersioning:\n    return \"s3:GetBucketVersioning\";\n\n  case s3PutBucketVersioning:\n    return \"s3:PutBucketVersioning\";\n\n  case s3GetBucketRequestPayment:\n    return \"s3:GetBucketRequestPayment\";\n\n  case s3PutBucketRequestPayment:\n    return \"s3:PutBucketRequestPayment\";\n\n  case s3GetBucketLocation:\n    return \"s3:GetBucketLocation\";\n\n  case s3GetBucketPolicy:\n    return \"s3:GetBucketPolicy\";\n\n  case s3DeleteBucketPolicy:\n    return \"s3:DeleteBucketPolicy\";\n\n  case s3PutBucketPolicy:\n    return \"s3:PutBucketPolicy\";\n\n  case s3GetBucketNotification:\n    return \"s3:GetBucketNotification\";\n\n  case s3PutBucketNotification:\n    return \"s3:PutBucketNotification\";\n\n  case s3GetBucketLogging:\n    return \"s3:GetBucketLogging\";\n\n  case s3PutBucketLogging:\n    return \"s3:PutBucketLogging\";\n\n  case s3GetBucketTagging:\n    return \"s3:GetBucketTagging\";\n\n  case s3PutBucketTagging:\n    return \"s3:PutBucketTagging\";\n\n  case s3GetBucketWebsite:\n    return \"s3:GetBucketWebsite\";\n\n  case s3PutBucketWebsite:\n    return \"s3:PutBucketWebsite\";\n\n  case s3DeleteBucketWebsite:\n    return \"s3:DeleteBucketWebsite\";\n\n  case s3GetLifecycleConfiguration:\n    return \"s3:GetLifecycleConfiguration\";\n\n  case s3PutLifecycleConfiguration:\n    return \"s3:PutLifecycleConfiguration\";\n\n  case s3PutReplicationConfiguration:\n    return \"s3:PutReplicationConfiguration\";\n\n  case s3GetReplicationConfiguration:\n    return \"s3:GetReplicationConfiguration\";\n\n  case s3DeleteReplicationConfiguration:\n    return \"s3:DeleteReplicationConfiguration\";\n\n  case s3PutObjectTagging:\n    return \"s3:PutObjectTagging\";\n\n  case s3PutObjectVersionTagging:\n    return \"s3:PutObjectVersionTagging\";\n\n  case s3GetObjectTagging:\n    return \"s3:GetObjectTagging\";\n\n  case s3GetObjectVersionTagging:\n    return \"s3:GetObjectVersionTagging\";\n\n  case s3DeleteObjectTagging:\n    return \"s3:DeleteObjectTagging\";\n\n  case s3DeleteObjectVersionTagging:\n    return \"s3:DeleteObjectVersionTagging\";\n  }\n  return \"s3Invalid\";\n}\n\nostream& print_actions(ostream& m, const uint64_t a) {\n  bool begun = false;\n  m << \"[ \";\n  for (auto i = 0U; i < s3Count; ++i) {\n    if (a & (1 << i)) {\n      if (begun) {\n\tm << \", \";\n      } else {\n\tbegun = true;\n      }\n      m << action_bit_string(1 << i);\n    }\n  }\n  if (begun) {\n    m << \" ]\";\n  } else {\n    m << \"]\";\n  }\n  return m;\n}\n}\n\nostream& operator <<(ostream& m, const Statement& s) {\n  m << \"{ \";\n  if (s.sid) {\n    m << \"Sid: \" << *s.sid << \", \";\n  }\n  if (!s.princ.empty()) {\n    m << \"Principal: \";\n    print_array(m, s.princ.cbegin(), s.princ.cend());\n    m << \", \";\n  }\n  if (!s.noprinc.empty()) {\n    m << \"NotPrincipal: \";\n    print_array(m, s.noprinc.cbegin(), s.noprinc.cend());\n    m << \", \";\n  }\n\n  m << \"Effect: \" <<\n    (s.effect == Effect::Allow ?\n     (const char*) \"Allow\" :\n     (const char*) \"Deny\");\n\n  if (s.action || s.notaction || !s.resource.empty() ||\n      !s.notresource.empty() || !s.conditions.empty()) {\n    m << \", \";\n  }\n\n  if (s.action) {\n    m << \"Action: \";\n    print_actions(m, s.action);\n\n    if (s.notaction || !s.resource.empty() ||\n\t!s.notresource.empty() || !s.conditions.empty()) {\n      m << \", \";\n    }\n  }\n\n  if (s.notaction) {\n    m << \"NotAction: \";\n    print_actions(m, s.notaction);\n\n    if (!s.resource.empty() || !s.notresource.empty() ||\n\t!s.conditions.empty()) {\n      m << \", \";\n    }\n  }\n\n  if (!s.resource.empty()) {\n    m << \"Resource: \";\n    print_array(m, s.resource.cbegin(), s.resource.cend());\n\n    if (!s.notresource.empty() || !s.conditions.empty()) {\n      m << \", \";\n    }\n  }\n\n  if (!s.notresource.empty()) {\n    m << \"NotResource: \";\n    print_array(m, s.notresource.cbegin(), s.notresource.cend());\n\n    if (!s.conditions.empty()) {\n      m << \", \";\n    }\n  }\n\n  if (!s.conditions.empty()) {\n    m << \"Condition: \";\n    print_array(m, s.conditions.cbegin(), s.conditions.cend());\n  }\n\n  return m << \" }\";\n}\n\nstring to_string(const Statement& s) {\n  stringstream m;\n  m << s;\n  return m.str();\n}\n\nPolicy::Policy(CephContext* cct, const string& tenant,\n\t       const bufferlist& _text)\n  : text(_text.to_str()) {\n  StringStream ss(text.data());\n  PolicyParser pp(cct, tenant, *this);\n  auto pr = Reader{}.Parse<kParseNumbersAsStringsFlag |\n\t\t\t   kParseCommentsFlag>(ss, pp);\n  if (!pr) {\n    throw PolicyParseException(std::move(pr));\n  }\n}\n\nEffect Policy::eval(const Environment& e,\n\t\t    optional<const rgw::auth::Identity&> ida,\n\t\t    std::uint64_t action, const ARN& resource) const {\n  auto allowed = false;\n  for (auto& s : statements) {\n    auto g = s.eval(e, ida, action, resource);\n    if (g == Effect::Deny) {\n      return g;\n    } else if (g == Effect::Allow) {\n      allowed = true;\n    }\n  }\n  return allowed ? Effect::Allow : Effect::Pass;\n}\n\nostream& operator <<(ostream& m, const Policy& p) {\n  m << \"{ Version: \"\n    << (p.version == Version::v2008_10_17 ? \"2008-10-17\" : \"2012-10-17\");\n\n  if (p.id || !p.statements.empty()) {\n    m << \", \";\n  }\n\n  if (p.id) {\n    m << \"Id: \" << *p.id;\n    if (!p.statements.empty()) {\n      m << \", \";\n    }\n  }\n\n  if (!p.statements.empty()) {\n    m << \"Statements: \";\n    print_array(m, p.statements.cbegin(), p.statements.cend());\n    m << \", \";\n  }\n  return m << \" }\";\n}\n\nstring to_string(const Policy& p) {\n  stringstream s;\n  s << p;\n  return s.str();\n}\n\n}\n}\n", "// -*- mode:C++; tab-width:8; c-basic-offset:2; indent-tabs-mode:t -*-\n// vim: ts=8 sw=2 smarttab\n\n#ifndef CEPH_RGW_IAM_POLICY_H\n#define CEPH_RGW_IAM_POLICY_H\n\n#include <bitset>\n#include <chrono>\n#include <cstdint>\n#include <iostream>\n#include <string>\n\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/container/flat_map.hpp>\n#include <boost/container/flat_set.hpp>\n#include <boost/optional.hpp>\n#include <boost/thread/shared_mutex.hpp>\n#include <boost/utility/string_ref.hpp>\n#include <boost/variant.hpp>\n\n#include \"common/ceph_time.h\"\n#include \"common/iso_8601.h\"\n\n#include \"rapidjson/error/error.h\"\n#include \"rapidjson/error/en.h\"\n\n#include \"rgw_acl.h\"\n#include \"rgw_basic_types.h\"\n#include \"rgw_iam_policy_keywords.h\"\n#include \"rgw_string.h\"\n\nclass RGWRados;\nnamespace rgw {\nnamespace auth {\nclass Identity;\n}\n}\nstruct rgw_obj;\nstruct rgw_bucket;\n\nnamespace rgw {\nnamespace IAM {\nstatic constexpr std::uint64_t s3None = 0;\nstatic constexpr std::uint64_t s3GetObject = 1ULL << 0;\nstatic constexpr std::uint64_t s3GetObjectVersion = 1ULL << 1;\nstatic constexpr std::uint64_t s3PutObject = 1ULL << 2;\nstatic constexpr std::uint64_t s3GetObjectAcl = 1ULL << 3;\nstatic constexpr std::uint64_t s3GetObjectVersionAcl = 1ULL << 4;\nstatic constexpr std::uint64_t s3PutObjectAcl = 1ULL << 5;\nstatic constexpr std::uint64_t s3PutObjectVersionAcl = 1ULL << 6;\nstatic constexpr std::uint64_t s3DeleteObject = 1ULL << 7;\nstatic constexpr std::uint64_t s3DeleteObjectVersion = 1ULL << 8;\nstatic constexpr std::uint64_t s3ListMultipartUploadParts = 1ULL << 9;\nstatic constexpr std::uint64_t s3AbortMultipartUpload = 1ULL << 10;\nstatic constexpr std::uint64_t s3GetObjectTorrent = 1ULL << 11;\nstatic constexpr std::uint64_t s3GetObjectVersionTorrent = 1ULL << 12;\nstatic constexpr std::uint64_t s3RestoreObject = 1ULL << 13;\nstatic constexpr std::uint64_t s3CreateBucket = 1ULL << 14;\nstatic constexpr std::uint64_t s3DeleteBucket = 1ULL << 15;\nstatic constexpr std::uint64_t s3ListBucket = 1ULL << 16;\nstatic constexpr std::uint64_t s3ListBucketVersions = 1ULL << 17;\nstatic constexpr std::uint64_t s3ListAllMyBuckets = 1ULL << 18;\nstatic constexpr std::uint64_t s3ListBucketMultiPartUploads = 1ULL << 19;\nstatic constexpr std::uint64_t s3GetAccelerateConfiguration = 1ULL << 20;\nstatic constexpr std::uint64_t s3PutAccelerateConfiguration = 1ULL << 21;\nstatic constexpr std::uint64_t s3GetBucketAcl = 1ULL << 22;\nstatic constexpr std::uint64_t s3PutBucketAcl = 1ULL << 23;\nstatic constexpr std::uint64_t s3GetBucketCORS = 1ULL << 24;\nstatic constexpr std::uint64_t s3PutBucketCORS = 1ULL << 25;\nstatic constexpr std::uint64_t s3GetBucketVersioning = 1ULL << 26;\nstatic constexpr std::uint64_t s3PutBucketVersioning = 1ULL << 27;\nstatic constexpr std::uint64_t s3GetBucketRequestPayment = 1ULL << 28;\nstatic constexpr std::uint64_t s3PutBucketRequestPayment = 1ULL << 29;\nstatic constexpr std::uint64_t s3GetBucketLocation = 1ULL << 30;\nstatic constexpr std::uint64_t s3GetBucketPolicy = 1ULL << 31;\nstatic constexpr std::uint64_t s3DeleteBucketPolicy = 1ULL << 32;\nstatic constexpr std::uint64_t s3PutBucketPolicy = 1ULL << 33;\nstatic constexpr std::uint64_t s3GetBucketNotification = 1ULL << 34;\nstatic constexpr std::uint64_t s3PutBucketNotification = 1ULL << 35;\nstatic constexpr std::uint64_t s3GetBucketLogging = 1ULL << 36;\nstatic constexpr std::uint64_t s3PutBucketLogging = 1ULL << 37;\nstatic constexpr std::uint64_t s3GetBucketTagging = 1ULL << 38;\nstatic constexpr std::uint64_t s3PutBucketTagging = 1ULL << 39;\nstatic constexpr std::uint64_t s3GetBucketWebsite = 1ULL << 40;\nstatic constexpr std::uint64_t s3PutBucketWebsite = 1ULL << 41;\nstatic constexpr std::uint64_t s3DeleteBucketWebsite = 1ULL << 42;\nstatic constexpr std::uint64_t s3GetLifecycleConfiguration = 1ULL << 43;\nstatic constexpr std::uint64_t s3PutLifecycleConfiguration = 1ULL << 44;\nstatic constexpr std::uint64_t s3PutReplicationConfiguration = 1ULL << 45;\nstatic constexpr std::uint64_t s3GetReplicationConfiguration = 1ULL << 46;\nstatic constexpr std::uint64_t s3DeleteReplicationConfiguration = 1ULL << 47;\nstatic constexpr std::uint64_t s3GetObjectTagging = 1ULL << 48;\nstatic constexpr std::uint64_t s3PutObjectTagging = 1ULL << 49;\nstatic constexpr std::uint64_t s3DeleteObjectTagging = 1ULL << 50;\nstatic constexpr std::uint64_t s3GetObjectVersionTagging = 1ULL << 51;\nstatic constexpr std::uint64_t s3PutObjectVersionTagging = 1ULL << 52;\nstatic constexpr std::uint64_t s3DeleteObjectVersionTagging = 1ULL << 53;\nstatic constexpr std::uint64_t s3Count = 54;\nstatic constexpr std::uint64_t s3All = (1ULL << s3Count) - 1;\n\nnamespace {\ninline int op_to_perm(std::uint64_t op) {\n  switch (op) {\n  case s3GetObject:\n  case s3GetObjectTorrent:\n  case s3GetObjectVersion:\n  case s3GetObjectVersionTorrent:\n  case s3GetObjectTagging:\n  case s3GetObjectVersionTagging:\n  case s3ListAllMyBuckets:\n  case s3ListBucket:\n  case s3ListBucketMultiPartUploads:\n  case s3ListBucketVersions:\n  case s3ListMultipartUploadParts:\n    return RGW_PERM_READ;\n\n  case s3AbortMultipartUpload:\n  case s3CreateBucket:\n  case s3DeleteBucket:\n  case s3DeleteObject:\n  case s3DeleteObjectVersion:\n  case s3PutObject:\n  case s3PutObjectTagging:\n  case s3PutObjectVersionTagging:\n  case s3DeleteObjectTagging:\n  case s3DeleteObjectVersionTagging:\n  case s3RestoreObject:\n    return RGW_PERM_WRITE;\n\n  case s3GetAccelerateConfiguration:\n  case s3GetBucketAcl:\n  case s3GetBucketCORS:\n  case s3GetBucketLocation:\n  case s3GetBucketLogging:\n  case s3GetBucketNotification:\n  case s3GetBucketPolicy:\n  case s3GetBucketRequestPayment:\n  case s3GetBucketTagging:\n  case s3GetBucketVersioning:\n  case s3GetBucketWebsite:\n  case s3GetLifecycleConfiguration:\n  case s3GetObjectAcl:\n  case s3GetObjectVersionAcl:\n  case s3GetReplicationConfiguration:\n    return RGW_PERM_READ_ACP;\n\n  case s3DeleteBucketPolicy:\n  case s3DeleteBucketWebsite:\n  case s3DeleteReplicationConfiguration:\n  case s3PutAccelerateConfiguration:\n  case s3PutBucketAcl:\n  case s3PutBucketCORS:\n  case s3PutBucketLogging:\n  case s3PutBucketNotification:\n  case s3PutBucketPolicy:\n  case s3PutBucketRequestPayment:\n  case s3PutBucketTagging:\n  case s3PutBucketVersioning:\n  case s3PutBucketWebsite:\n  case s3PutLifecycleConfiguration:\n  case s3PutObjectAcl:\n  case s3PutObjectVersionAcl:\n  case s3PutReplicationConfiguration:\n    return RGW_PERM_WRITE_ACP;\n\n  case s3All:\n    return RGW_PERM_FULL_CONTROL;\n  }\n  return RGW_PERM_INVALID;\n}\n}\n\nusing Environment = boost::container::flat_map<std::string, std::string>;\n\nenum struct Partition {\n  aws, aws_cn, aws_us_gov, wildcard\n  // If we wanted our own ARNs for principal type unique to us\n  // (maybe to integrate better with Swift) or for anything else we\n  // provide that doesn't map onto S3, we could add an 'rgw'\n  // partition type.\n};\n\nenum struct Service {\n  apigateway, appstream, artifact, autoscaling, aws_portal, acm,\n  cloudformation, cloudfront, cloudhsm, cloudsearch, cloudtrail,\n  cloudwatch, events, logs, codebuild, codecommit, codedeploy,\n  codepipeline, cognito_idp, cognito_identity, cognito_sync,\n  config, datapipeline, dms, devicefarm, directconnect,\n  ds, dynamodb, ec2, ecr, ecs, ssm, elasticbeanstalk, elasticfilesystem,\n  elasticloadbalancing, elasticmapreduce, elastictranscoder, elasticache,\n  es, gamelift, glacier, health, iam, importexport, inspector, iot,\n  kms, kinesisanalytics, firehose, kinesis, lambda, lightsail,\n  machinelearning, aws_marketplace, aws_marketplace_management,\n  mobileanalytics, mobilehub, opsworks, opsworks_cm, polly,\n  redshift, rds, route53, route53domains, sts, servicecatalog,\n  ses, sns, sqs, s3, swf, sdb, states, storagegateway, support,\n  trustedadvisor, waf, workmail, workspaces, wildcard\n};\n\nstruct ARN {\n  Partition partition;\n  Service service;\n  std::string region;\n  // Once we refity tenant, we should probably use that instead of a\n  // string.\n  std::string account;\n  std::string resource;\n\n  ARN()\n    : partition(Partition::wildcard), service(Service::wildcard) {}\n  ARN(Partition partition, Service service, std::string region,\n      std::string account, std::string resource)\n    : partition(partition), service(service), region(std::move(region)),\n      account(std::move(account)), resource(std::move(resource)) {}\n  ARN(const rgw_obj& o);\n  ARN(const rgw_bucket& b);\n  ARN(const rgw_bucket& b, const std::string& o);\n\n  static boost::optional<ARN> parse(const std::string& s,\n\t\t\t\t    bool wildcard = false);\n  std::string to_string() const;\n\n  // `this` is the pattern\n  bool match(const ARN& candidate) const;\n};\n\ninline std::string to_string(const ARN& a) {\n  return a.to_string();\n}\n\ninline std::ostream& operator <<(std::ostream& m, const ARN& a) {\n  return m << to_string(a);\n}\n\nbool operator ==(const ARN& l, const ARN& r);\nbool operator <(const ARN& l, const ARN& r);\n\nusing Address = std::bitset<128>;\nstruct MaskedIP {\n  bool v6;\n  Address addr;\n  // Since we're mapping IPv6 to IPv4 addresses, we may want to\n  // consider making the prefix always be in terms of a v6 address\n  // and just use the v6 bit to rewrite it as a v4 prefix for\n  // output.\n  unsigned int prefix;\n};\n\nstd::ostream& operator <<(std::ostream& m, const MaskedIP& ip);\nstring to_string(const MaskedIP& m);\n\ninline bool operator ==(const MaskedIP& l, const MaskedIP& r) {\n  auto shift = std::max((l.v6 ? 128 : 32) - l.prefix,\n\t\t\t(r.v6 ? 128 : 32) - r.prefix);\n  return (l.addr >> shift) == (r.addr >> shift);\n}\n\nstruct Condition {\n  TokenID op;\n  // Originally I was going to use a perfect hash table, but Marcus\n  // says keys are to be added at run-time not compile time.\n\n  // In future development, use symbol internment.\n  std::string key;\n  bool ifexists = false;\n  // Much to my annoyance there is no actual way to do this in a\n  // typed way that is compatible with AWS. I know this because I've\n  // seen examples where the same value is used as a string in one\n  // context and a date in another.\n  std::vector<std::string> vals;\n\n  Condition() = default;\n  Condition(TokenID op, const char* s, std::size_t len, bool ifexists)\n    : op(op), key(s, len), ifexists(ifexists) {}\n\n  bool eval(const Environment& e) const;\n\n  static boost::optional<double> as_number(const std::string& s) {\n    std::size_t p = 0;\n\n    try {\n      double d = std::stod(s, &p);\n      if (p < s.length()) {\n\treturn boost::none;\n      }\n\n      return d;\n    } catch (const std::logic_error& e) {\n      return boost::none;\n    }\n  }\n\n  static boost::optional<ceph::real_time> as_date(const std::string& s) {\n    std::size_t p = 0;\n\n    try {\n      double d = std::stod(s, &p);\n      if (p == s.length()) {\n\treturn ceph::real_time(\n\t  std::chrono::seconds(static_cast<uint64_t>(d)) +\n\t  std::chrono::nanoseconds(\n\t    static_cast<uint64_t>((d - static_cast<uint64_t>(d))\n\t\t\t\t  * 1000000000)));\n      }\n\n      return from_iso_8601(boost::string_ref(s), false);\n    } catch (const std::logic_error& e) {\n      return boost::none;\n    }\n  }\n\n  static boost::optional<bool> as_bool(const std::string& s) {\n    std::size_t p = 0;\n\n    if (s.empty() || boost::iequals(s, \"false\")) {\n      return false;\n    }\n\n    try {\n      double d = std::stod(s, &p);\n      if (p == s.length()) {\n\treturn !((d == +0.0) || (d == -0.0) || std::isnan(d));\n      }\n    } catch (const std::logic_error& e) {\n      // Fallthrough\n    }\n\n    return true;\n  }\n\n  static boost::optional<ceph::bufferlist> as_binary(const std::string& s) {\n    // In a just world\n    ceph::bufferlist base64;\n    // I could populate a bufferlist\n    base64.push_back(buffer::create_static(\n\t\t       s.length(),\n\t\t       const_cast<char*>(s.data()))); // Yuck\n    // From a base64 encoded std::string.\n    ceph::bufferlist bin;\n\n    try {\n      base64.decode_base64(bin);\n    } catch (const ceph::buffer::malformed_input& e) {\n      return boost::none;\n    }\n    return bin;\n  }\n\n  static boost::optional<MaskedIP> as_network(const std::string& s);\n\n\n  struct ci_equal_to {\n    bool operator ()(const std::string& s1,\n\t\t     const std::string& s2) const {\n      return boost::iequals(s1, s2);\n    }\n  };\n\n  struct string_like {\n    bool operator ()(const std::string& input,\n                     const std::string& pattern) const {\n      return match_wildcards(pattern, input, 0);\n    }\n  };\n\n  template<typename F>\n  static bool orrible(F&& f, const std::string& c,\n\t\t      const std::vector<std::string>& v) {\n    for (const auto& d : v) {\n      if (std::forward<F>(f)(c, d)) {\n\treturn true;\n      }\n    }\n    return false;\n  }\n\n  template<typename F, typename X>\n  static bool shortible(F&& f, X& x, const std::string& c,\n\t\t\tconst std::vector<std::string>& v) {\n    auto xc = std::forward<X>(x)(c);\n    if (!xc) {\n      return false;\n    }\n\n    for (const auto& d : v) {\n      auto xd = std::forward<X>(x)(d);\n      if (!xd) {\n\tcontinue;\n      }\n\n      if (std::forward<F>(f)(*xc, *xd)) {\n\treturn true;\n      }\n    }\n    return false;\n  }\n};\n\nstd::ostream& operator <<(std::ostream& m, const Condition& c);\n\nstd::string to_string(const Condition& c);\n\nstruct Statement {\n  boost::optional<std::string> sid = boost::none;\n\n  boost::container::flat_set<rgw::auth::Principal> princ;\n  boost::container::flat_set<rgw::auth::Principal> noprinc;\n\n  // Every statement MUST provide an effect. I just initialize it to\n  // deny as defensive programming.\n  Effect effect = Effect::Deny;\n\n  std::uint64_t action = 0;\n  std::uint64_t notaction = 0;\n\n  boost::container::flat_set<ARN> resource;\n  boost::container::flat_set<ARN> notresource;\n\n  std::vector<Condition> conditions;\n\n  Effect eval(const Environment& e,\n\t      boost::optional<const rgw::auth::Identity&> ida,\n\t      std::uint64_t action, const ARN& resource) const;\n};\n\nstd::ostream& operator <<(ostream& m, const Statement& s);\nstd::string to_string(const Statement& s);\n\nstruct PolicyParseException : public std::exception {\n  rapidjson::ParseResult pr;\n\n  PolicyParseException(rapidjson::ParseResult&& pr)\n    : pr(pr) { }\n  const char* what() const noexcept override {\n    return rapidjson::GetParseError_En(pr.Code());\n  }\n};\n\nstruct Policy {\n  std::string text;\n  Version version = Version::v2008_10_17;\n  boost::optional<std::string> id = boost::none;\n\n  std::vector<Statement> statements;\n\n  Policy(CephContext* cct, const std::string& tenant,\n\t const bufferlist& text);\n\n  Effect eval(const Environment& e,\n\t      boost::optional<const rgw::auth::Identity&> ida,\n\t      std::uint64_t action, const ARN& resource) const;\n};\n\nstd::ostream& operator <<(ostream& m, const Policy& p);\nstd::string to_string(const Policy& p);\n}\n}\n\nnamespace std {\ntemplate<>\nstruct hash<::rgw::IAM::Service> {\n  size_t operator()(const ::rgw::IAM::Service& s) const noexcept {\n    // Invoke a default-constructed hash object for int.\n    return hash<int>()(static_cast<int>(s));\n  }\n};\n}\n\n#endif\n"], "filenames": ["src/rgw/rgw_basic_types.h", "src/rgw/rgw_iam_policy.cc", "src/rgw/rgw_iam_policy.h"], "buggy_code_start_loc": [163, 224, 31], "buggy_code_end_loc": [169, 847, 258], "fixing_code_start_loc": [162, 224, 30], "fixing_code_end_loc": [166, 853, 254], "type": "CWE-617", "message": "RADOS Gateway in Ceph 12.1.0 through 12.2.1 allows remote authenticated users to cause a denial of service (assertion failure and application exit) by leveraging \"full\" (not necessarily admin) privileges to post an invalid profile to the admin API, related to rgw/rgw_iam_policy.cc, rgw/rgw_basic_types.h, and rgw/rgw_iam_types.h.", "other": {"cve": {"id": "CVE-2017-16818", "sourceIdentifier": "cve@mitre.org", "published": "2017-12-20T17:29:00.307", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "RADOS Gateway in Ceph 12.1.0 through 12.2.1 allows remote authenticated users to cause a denial of service (assertion failure and application exit) by leveraging \"full\" (not necessarily admin) privileges to post an invalid profile to the admin API, related to rgw/rgw_iam_policy.cc, rgw/rgw_basic_types.h, and rgw/rgw_iam_types.h."}, {"lang": "es", "value": "RADOS Gateway en Ceph desde la versi\u00f3n 12.1.0 hasta la 12.2.1 permite que los usuarios autenticados remotos provoquen una denegaci\u00f3n de servicio (fallo de aserci\u00f3n y salida de la aplicaci\u00f3n) utilizando privilegios \"full\" (no necesariamente admin) para publicar un perfil no v\u00e1lido en la API admin. Esto est\u00e1 relacionado con rgw/rgw_iam_policy.cc, rgw/rgw_basic_types.h y rgw/rgw_iam_types.h."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ceph:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.1.0", "versionEndIncluding": "12.2.1", "matchCriteriaId": "2263DE64-5503-471D-BBD1-F678E58F008D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:27:*:*:*:*:*:*:*", "matchCriteriaId": "DBEACBFF-6D05-4B69-BF7A-F7E539D9BF6E"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1515872", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ceph/ceph/commit/b3118cabb8060a8cc6a01c4e8264cb18e7b1745a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U6VJA32U7HKGDRJQDJVM7JBYWD4T7BJL/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ceph/ceph/commit/b3118cabb8060a8cc6a01c4e8264cb18e7b1745a"}}